head	1.2;
access;
symbols
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2;
locks; strict;
comment	@ * @;


1.2
date	98.06.02.15.19.39;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	98.06.02.13.04.31;	author jont;	state Exp;
branches;
next	;


desc
@new unit
Putting application tests into hope and daily
@


1.2
log
@Automatic checkin:
changed attribute _comment to ' * '
@
text
@(*
 *
 * $Log$
 *
 *)
RCS "$Id: DivPre.str,v 1.3 1994/12/03 14:43:33 pxs Exp $";
functor DivPre ( structure GenP : GENPRE ) : DIVPRE =
struct
   structure DivC = GenP.DivC
   structure Elem = DivC.Elem
   structure PG = Elem.PG

(*****************************************************************************)
(* The initialization predicate for the divergence preorder                  *)
(*****************************************************************************)

   fun initdivpreordpred (s1,s2) =
       Elem.actlistinclusion(Elem.divinf s2,Elem.divinf s1) andalso
       ((DivC.globdivpred s1) orelse not (DivC.globdivpred s2))

(*****************************************************************************)
(* The general function for the variations of the divergence preorder        *)
(*****************************************************************************)

   fun divpreorder (slist1,slist2,s1,s2) =
       GenP.genpreord (DivC.globdivpred,initdivpreordpred)
                    ((s1,slist1),(s2,slist2))

(*****************************************************************************)
(* Derived functions to check:                                               *)
(*    a) strong preorder       c) weak precongruence  e) weak equivalence    *)
(*    b) weak preorder         d) strong equivalence  f) weak congruence     *)
(*****************************************************************************)

   fun strongpreorder ((sr1,slist1),(sr2,slist2)) =
       (ignore(DivC.strlocdivinf slist1);
        ignore(DivC.strlocdivinf slist2);
        divpreorder (slist1,slist2,sr1,sr2))

   fun weakpreorder ((sr1,slist1),(sr2,slist2)) =
       (ignore(DivC.weaklocdivinf slist1);
        ignore(PG.obscl(sr1,slist1));
        ignore(DivC.weaklocdivinf slist2);
        ignore(PG.obscl(sr2,slist2));
        divpreorder(slist1,slist2,sr1,sr2))

   fun precongruence ((sr1,slist1),(sr2,slist2)) =
       let val _ = DivC.weaklocdivinf slist1
           val (sr1,slist1) =
               PG.congrcl (Elem.preinfcongrcl sr1) (sr1,slist1)
           val _ = DivC.weaklocdivinf slist2
           val (sr2,slist2) =
               PG.epscl (PG.congrcl (Elem.preinfcongrcl sr2) (sr2,slist2))
        in divpreorder(slist1,slist2,sr1,sr2)
       end

   fun strongequivalence ((sr1,slist1),(sr2,slist2)) =
       divpreorder(slist1,slist2,sr1,sr2)

   fun weakequivalence ((sr1,slist1),(sr2,slist2)) =
       (ignore(PG.obscl(sr1,slist1));
        ignore(PG.obscl(sr2,slist2));
        divpreorder(slist1,slist2,sr1,sr2))

   fun weakcongruence ((sr1,slist1),(sr2,slist2)) =
       let val (sr1,slist1) =
               PG.congrcl (Elem.preinfcongrcl sr1) (sr1,slist1)
           val (sr2,slist2) =
               PG.congrcl (Elem.preinfcongrcl sr2) (sr2,slist2)
        in divpreorder(slist1,slist2,sr1,sr2)
       end

   fun twothirds((sr1,slist1),(sr2,slist2)) =
       let fun covers l = forall (fn x => Lib.member PG.act_eq (x,l))
           fun samefst(ref(PG.S({suc=suc1,...})),ref(PG.S({suc=suc2,...}))) =
               covers (map fst (!suc1)) (map fst (!suc2))
        in GenP.genpreord (fn _=>true,samefst) ((sr1,slist1),(sr2,slist2))
       end
end

@


1.1
log
@new unit
Putting application tests into hope and daily
@
text
@@
