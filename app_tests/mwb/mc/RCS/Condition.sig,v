head	1.2;
access;
symbols
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2;
locks; strict;
comment	@ * @;


1.2
date	98.06.11.13.18.31;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	98.06.10.17.12.53;	author jont;	state Exp;
branches;
next	;


desc
@new unit
Adding applications into hope and daily
@


1.2
log
@Automatic checkin:
changed attribute _comment to ' * '
@
text
@(*
 *
 * $Log$
 *
 *)
signature CONDITION =
sig

  structure NS : NAMESUBSTITUTION

  structure F : FORMULA

  type general_cond

  (* Name substitutions special case of name conditions *)
  datatype cond = NameSubst of NS.name_subst |
                  GeneralCond of general_cond

  (* Constructors *)

  val mk_cond: NS.name_subst -> cond

  (* testers *)

  val eq: cond -> cond -> bool

  val entails: cond -> cond -> bool

  (* selectors *)

  val mk_form: cond -> F.formula

  val domain: cond -> NS.N.name list

  (* Given a domain nl and a name condition c, partition nl c builds     *)
  (* a maximal list of name substitutions with domain nl union domain c  *)
  (* such that each name substitution in the list is a distinct model    *)
  (* of c                                                                *)
  val partition: NS.N.name list -> cond -> NS.name_subst list

  (* Special functions *)

  (* diff: For now only applicable to name substitutions. Given a name x *)
  (* in domain(c), diff x c computes a formula f such that if            *)
  (* NS.eq ns1 (NS.restrict ns2 [x]) and x is in the domain of ns2       *)
  (* then mk_form(NameSubst ns2) and mk_and(mk_form(NameSubst ns1),      *)
  (* diff x (NameSubst ns2)) are equivalent.                             *) 
  val diff: NS.N.name -> cond -> F.formula

end
@


1.1
log
@new unit
Adding applications into hope and daily
@
text
@@
