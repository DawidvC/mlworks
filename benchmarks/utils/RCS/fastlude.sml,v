head	1.4;
access;
symbols
	MLWorks_21c0_1999_03_25:1.4
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.4
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.1
	MLWorks_20m1_1997_10_23:1.1
	MLWorks_11r1:1.1.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.1.1.1.1.1
	MLWorks_10r3:1.1.1.1.3
	MLWorks_10r2_551:1.1.1.1.2
	MLWorks_11:1.1.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.1.1
	MLWorks_20m0_1997_06_20:1.1
	MLWorks_1_0_r2c2_1997_06_14:1.1.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.1
	MLWorks_BugFix_1997_04_24:1.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.1
	MLWorks_1_0_r2_Unix_1997_04_04:1.1;
locks; strict;
comment	@ *  @;


1.4
date	98.03.26.15.33.23;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	98.02.20.09.02.14;	author mitchell;	state Exp;
branches;
next	1.2;

1.2
date	98.02.19.18.30.32;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	97.01.07.13.38.28;	author matthew;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.12.10.23.29;	author hope;	state Exp;
branches
	1.1.1.1.1.1
	1.1.1.1.2.1
	1.1.1.1.3.1;
next	;

1.1.1.1.1.1
date	97.07.28.18.09.23;	author daveb;	state Exp;
branches
	1.1.1.1.1.1.1.1;
next	;

1.1.1.1.1.1.1.1
date	97.10.07.11.33.12;	author jkbrook;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	97.09.08.17.02.46;	author daveb;	state Exp;
branches;
next	;

1.1.1.1.3.1
date	97.09.09.13.57.23;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.4
log
@[Bug #30090]
Remove use of MLWorks.IO
@
text
@(* $Log: utils:fastlude.sml,v $
 *  Revision 1.3  1998/02/20  09:02:14  mitchell
 *  [Bug #30349]
 *  Fix to avoid non-unit sequence warnings
 *
 *  Revision 1.2  1998/02/19  18:30:32  jont
 *  [Bug #30364]
 *  Remove use of loadSource, no longer necessary
 *
 *  Revision 1.1  1997/01/07  13:38:28  matthew
 *  new unit
 * *)

  (* fast version of TIl prelude *)

  (* list ops *)

  fun rev l =
	let fun f (nil, h) = h
	      | f (a::r, h) = f(r, a::h)
	in  f(l,nil)
	end
  fun nil @@ M = M
    | (x :: L) @@ M = x :: (L @@ M)
  fun map f =
      let fun m nil = nil
	    | m (a::r) = f a :: m r
      in  m
      end
  fun length l = 
      let fun j(k,nil) = k
	    | j(k, a::x) = j(k+1,x)
      in j(0,l)
      end
  exception NthTail
  exception Hd (* = List.Empty *)
  exception Tl (* = List.Empty *)
  exception Nth = Subscript

  fun hd (a::r) = a | hd nil = raise Hd
  fun tl (a::r) = r | tl nil = raise Tl    
  fun null nil = true | null _ = false
  fun fold f [] = (fn b => b)
    | fold f (a::r) = (fn b => let fun f2(e,[]) = f(e,b)
				     | f2(e,a::r) = f(e,f2(a,r))
			       in f2(a,r)
			       end)
  fun revfold f [] = (fn b => b)
    | revfold f (a::r) = (fn b => let fun f2(e,[],b) = f(e,b)
					| f2(e,a::r,b) = f2(a,r,f(e,b))
				  in f2(a,r,b)
				  end)	
  fun app f =
      let fun loop [] = ()
	    | loop (hd::tl) = (ignore(f hd); loop tl)
      in
	 loop
      end
  fun revapp f = let fun a2 (e::r) = (a2 r; ignore(f e); ()) | a2 nil = () in a2 end
  fun nthtail(e,0) = e 
    | nthtail(e::r,n) = nthtail(r,n-1)
    | nthtail _ = raise NthTail
  fun nth x = hd(nthtail x) handle NthTail => raise Nth | Hd => raise Nth
  fun exists pred =
      let fun f nil = false
	    | f (hd::tl) = pred hd orelse f tl
      in  f
      end

    
    type 'a array1 = 'a Array.array

    fun unsafe_array1(s : int, e : '_a) : '_a array1 =  Array.array(s,e)

    val length1 = Array.length

    fun unsafe_sub1(a : '_a array1, index : int) : '_a = 
	  MLWorks.Internal.Value.unsafe_array_sub (a,index)

    fun unsafe_update1(a : '_a array1, index : int, e : '_a) : unit = 
	  MLWorks.Internal.Value.unsafe_array_update (a,index,e)

    fun array1 (s:int, e : '_a) =
	if s<0 then raise Size
	else unsafe_array1(s,e)
  
    fun sub1 (a : '_a array1, index :int) =
	if index<0 orelse index>=length1 a then raise Subscript
	else unsafe_sub1(a,index)

    fun update1(a : '_a array1, index : int, e : '_a) : unit =
	if index<0 orelse index>=length1 a then raise Subscript
	else unsafe_update1(a,index,e)


    type '_a array2 = {rows : int,columns : int, v : '_a array1}

    fun array2(rows : int, columns : int, e : '_a) : '_a array2 = 
	if rows<0 orelse columns<0 then raise Size
	else {rows=rows,columns=columns,v=unsafe_array1(rows*columns,e)}

    (* column major order *)
(*
    fun sub2 ({rows,columns,v}, s :int, t:int) =
	if s <0 orelse s>=rows orelse t<0 orelse t>=columns then raise Subscript
	else unsafe_sub1(v,s*columns+t)
*)

    fun sub2 ({rows,columns,v}, s :int, t:int) =
	if s < 0 then raise Subscript
        else if s>=rows then raise Subscript
        else if t<0 then raise Subscript
        else if t>=columns then raise Subscript
	else unsafe_sub1(v,s*columns+t)

    fun update2 ({rows,columns,v}, s : int, t:int, e) : unit =
	if s<0 orelse s>=rows orelse t<0 orelse t>=columns then raise Subscript
	else unsafe_update1(v,s*columns+t,e)

    fun length2 ({rows,columns,v}) : int * int = (rows,columns)
    
    val makestring_int = Int.toString : int -> string
    val makestring_real = Real.toString : real -> string
    fun makestring_bool true = "true"
      | makestring_bool false = "false"
	
    fun inc r = r := !r + 1
    fun dec r = r := !r - 1
    (* misc *)
   fun min(a:int,b) = if a<b then a else b
   fun max(a:int,b) = if a>b then a else b

   val implode = implode

   val input_line = TextIO.inputLine

   val ordof = MLWorks.String.ordof
   val substring = MLWorks.String.substring

   exception Overflow

   infix 9 &&
   val op && = MLWorks.Internal.Bits.andb

  (* end of fast version of TIL prelude for MLWorks *)
@


1.3
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d2 4
d135 1
a135 1
   val input_line = MLWorks.IO.input_line
@


1.2
log
@[Bug #30364]
Remove use of loadSource, no longer necessary
@
text
@d2 4
d51 1
a51 1
	    | loop (hd::tl) = (f hd; loop tl)
d55 1
a55 1
  fun revapp f = let fun a2 (e::r) = (a2 r; f e; ()) | a2 nil = () in a2 end
@


1.1
log
@new unit
@
text
@d1 4
a4 5
(* $Log$ *)

Shell.Build.loadSource "basis.__int";
Shell.Build.loadSource "basis.__real";
Shell.Build.loadSource "basis.__array";
@


1.1.1.1
log
@branched from 1.1
@
text
@d1 1
a1 4
(* $Log: utils:fastlude.sml,v $
 *  Revision 1.1  1997/01/07  13:38:28  matthew
 *  new unit
 * *)
@


1.1.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a1 3
 *  Revision 1.1.1.1  1997/05/12  10:23:29  hope
 *  branched from 1.1
 *
@


1.1.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a1 3
 *  Revision 1.1.1.1  1997/05/12  10:23:29  hope
 *  branched from 1.1
 *
@


1.1.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a1 3
 *  Revision 1.1.1.1  1997/05/12  10:23:29  hope
 *  branched from 1.1
 *
@


1.1.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a1 3
 *  Revision 1.1.1.1.1.1  1997/07/28  18:09:23  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@
