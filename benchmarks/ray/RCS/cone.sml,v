head	1.2;
access;
symbols
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_11r1:1.1.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.1.1.1.1.1
	MLWorks_10r3:1.1.1.1.3
	MLWorks_10r2_551:1.1.1.1.2
	MLWorks_11:1.1.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.1.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.1.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.1
	MLWorks_BugFix_1997_04_24:1.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.1
	MLWorks_1_0_r2_Unix_1997_04_04:1.1;
locks; strict;
comment	@ *  @;


1.2
date	97.05.20.15.54.42;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	96.12.11.12.32.49;	author matthew;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.12.10.23.16;	author hope;	state Exp;
branches
	1.1.1.1.1.1
	1.1.1.1.2.1
	1.1.1.1.3.1;
next	;

1.1.1.1.1.1
date	97.07.28.18.09.11;	author daveb;	state Exp;
branches
	1.1.1.1.1.1.1.1;
next	;

1.1.1.1.1.1.1.1
date	97.10.07.11.33.02;	author jkbrook;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	97.09.08.17.02.35;	author daveb;	state Exp;
branches;
next	;

1.1.1.1.3.1
date	97.09.09.13.57.13;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.2
log
@Fixing warnings
@
text
@(***************************************************************************)
(* Cone/Tube Primitive for The Ghost CSG Raytracer - (C) Chris Walton 1994 *)
(***************************************************************************)

(*
   Functions to calculate the intersection points and normals for a cone. 
   Routine modified directly from the MTV raytracer by Mark VandeWetterling

   Cone primitive definition :

   primtype = 5
   vecdata = [cone_base, cone_apex, cone_u, cone_v, cone_w]
   realdata = [baseradius, base_d, apexradius, height, slope, min_d, max_d]
   intdata = []

*)

functor cone (structure Csg : CSG) : PRIMITIVE =
  struct

    structure Csg = Csg
    open Csg
    open Ray
    open Vector
    
    fun conedata (Prim s) =
          let val (B,A,U,V,W) = 
            case #vecdata s of
              (B::A::U::V::W::_) => (B,A,U,V,W)
                | _ => raise Match
              val (br,bd,ar,height,slope,mind,maxd) =
                case #realdata s of
                  (br::bd::ar::height::slope::mind::maxd::_) =>
                    (br,bd,ar,height,slope,mind,maxd)
                | _ => raise Match
          in 
            (B, A, U, V, W, br, bd, ar, height, slope, mind, maxd) 
          end

    fun intersect (Prim s, surf, Ray (O, D)) =
          let val (B, A, U, V, W, br, bd, ar, height, slope, mind, maxd) = 
                conedata (Prim s)
              val VV = VecSub(O, B)
              val P0 = VecDot(VV, U)
              val P1 = VecDot(VV, V)
              val P2 = VecDot(VV, W)
              val D0 = VecDot(D, U)
              val D1 = VecDot(D, V)
              val D2 = VecDot(D, W)
              val a = D0*D0+D1*D1-slope*slope*D2*D2
              val b = 2.0*(P0*D0+P1*D1-slope*slope*P2*D2-br*slope*D2)
              val ct = slope*P2+br
              val c = P0*P0+P1*P1-(ct*ct) 
              val disc = b*b-4.0*a*c
          in
            if disc<0.0 then (false, [])
            else
              let val disc2 = sqrt(disc)
                  val l1 = ((~b)+disc2)/(a+a)
              in
                if l1<epsilon then (false, [])
                else 
                  let val l0=((~b)-disc2)/(a+a)
                      val nroots = if l0<epsilon then 1 else 2
                  in
                    if l0<epsilon then
                      let val d = VecDot(W, RayPoint(Ray(O, D), l1))
                      in 
                        if d>=mind andalso d<=maxd then 
                          (true, IsectAdd([], l1, (Prim s, surf), false))
                        else (false, [])
                      end
                    else
                      let val d0 = VecDot(W, RayPoint(Ray(O, D), l0))
                          val d1 = VecDot(W, RayPoint(Ray(O, D), l1))
                          val r0 = (d0>=mind andalso d0<=maxd)
                          val r1 = (d1>=mind andalso d1<=maxd)
                      in
                        if (r0 andalso r1) then 
                          (false, IsectAdd(IsectAdd([], l0, (Prim s, surf),
                          true), l1, (Prim s, surf), false))
                        else if r0 then
                          (false, IsectAdd([], l0, (Prim s, surf), true))
                        else if r1 then 
                          (true, IsectAdd([], l1, (Prim s, surf), false))
                        else (false, [])
                      end
                  end
              end
          end

    fun normal (Prim s, P) =
          let val (B, _, _, _, W, _, bd, _, _, slope, _, _) = conedata (Prim s)
              val t = ~(VecDot(P, W)+bd)
          in
            VecUnit(VecAddS((~ slope),W,VecUnit(VecSub(VecAddS(t, W, P), B)))) 
          end
  end
@


1.1
log
@new unit
@
text
@d27 9
a35 2
          let val (B::A::U::V::W::_) = #vecdata s
              val (br::bd::ar::height::slope::mind::maxd::_) = #realdata s
@


1.1.1.1
log
@branched from 1.1
@
text
@@


1.1.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.1.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.1.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.1.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@
