head	1.8;
access;
symbols
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.8
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.7
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.3
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_20m1_1997_10_23:1.1
	MLWorks_11r1:1.1.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.1.1.1.1.1
	MLWorks_10r3:1.1.1.1.3
	MLWorks_10r2_551:1.1.1.1.2
	MLWorks_11:1.1.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.1.1
	MLWorks_20m0_1997_06_20:1.1
	MLWorks_1_0_r2c2_1997_06_14:1.1.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.1
	MLWorks_BugFix_1997_04_24:1.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.1
	MLWorks_1_0_r2_Unix_1997_04_04:1.1;
locks; strict;
comment	@ *  @;


1.8
date	98.06.15.12.26.41;	author mitchell;	state Exp;
branches;
next	1.7;

1.7
date	98.06.04.14.43.40;	author johnh;	state Exp;
branches;
next	1.6;

1.6
date	98.05.21.12.23.36;	author mitchell;	state Exp;
branches;
next	1.5;

1.5
date	98.05.07.09.30.31;	author mitchell;	state Exp;
branches;
next	1.4;

1.4
date	98.05.04.17.24.14;	author mitchell;	state Exp;
branches;
next	1.3;

1.3
date	97.11.24.14.24.25;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	97.11.19.21.04.27;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	97.01.29.10.43.40;	author andreww;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.12.11.11.45;	author hope;	state Exp;
branches
	1.1.1.1.1.1
	1.1.1.1.2.1
	1.1.1.1.3.1;
next	;

1.1.1.1.1.1
date	97.07.28.18.53.55;	author daveb;	state Exp;
branches
	1.1.1.1.1.1.1.1;
next	;

1.1.1.1.1.1.1.1
date	97.10.07.12.18.33;	author jkbrook;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	97.09.08.17.45.42;	author daveb;	state Exp;
branches;
next	;

1.1.1.1.3.1
date	97.09.09.14.44.57;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
A test for the new mutual exclusion primitives.
@


1.8
log
@[Bug #30422]
newProject now requires a directory
@
text
@(*
 * Bounded Buffers implementation.  Test for new MLWorks Threads mutexes.

Result: OK

 *
 * Revision Log:
 * -------------
 * $Log: mutexes.sml,v $
 *  Revision 1.7  1998/06/04  14:43:40  johnh
 *  [Bug #30369]
 *  Replace source path with a list of files.
 *
 *  Revision 1.6  1998/05/21  12:23:36  mitchell
 *  [Bug #50071]
 *  Replace touchAllSource by a force compile
 *
 *  Revision 1.5  1998/05/07  09:30:31  mitchell
 *  [Bug #50071]
 *  Modify test to perform a Shell.Project.touchAllSources before compiling to force a recompile
 *
 *  Revision 1.4  1998/05/04  17:24:14  mitchell
 *  [Bug #50071]
 *  Replace uses of Shell.Build.loadSource by Shell.Project
 *
 *  Revision 1.3  1997/11/24  14:24:25  daveb
 *  [Bug #30323]
 *
 *  Revision 1.2  1997/11/19  21:04:27  jont
 *  [Bug #30085]
 *  Make independent of structure changes
 *
 *  Revision 1.1  1997/01/29  10:43:40  andreww
 *  new unit
 *  A test for the new mutual exclusion primitives.
 *
 *
 *
 * Copyright (C) 1997 Harlequin Ltd.
 *
 *)

Shell.Options.set (Shell.Options.ValuePrinter.maximumStrDepth,0);
(
  Shell.Project.newProject (OS.Path.fromUnixPath "/tmp");
  let
    val root_dir = OS.FileSys.getDir()
    fun concatenate s = OS.Path.concat [root_dir, "..", "src", "utils", s]
  in
    Shell.Project.setFiles (map concatenate ["__mutex.sml", "mutex.sml"])
  end;
  Shell.Project.setTargetDetails "__mutex.sml";
  Shell.Project.setTargets ["__mutex.sml"];
  Shell.Project.forceCompileAll();
  Shell.Project.loadAll()
)

val deadlockFlag = ref false;

local
  structure T = MLWorks.Threads;
  structure I = T.Internal;
  structure P = I.Preemption;
    

    
    
  (* shared resource *)
    
  local
    val buffer = Array.array(10,0);
    val size = ref 0;
    val putIndex = ref 0;
    val getIndex = ref 0;
  in
    fun addToBuffer x = 
      (if !size=10 then print "data lost!\n"       (* shouldn't happen*)
       else size:= !size+1;
         Array.update(buffer,!putIndex,x);
         putIndex:=(!putIndex+1) mod 10)
         
    fun readFromBuffer () =
      (if !size=0 then print "phantom data!\n"     (*shouldn't happen*)
       else size:= !size-1;
         Array.sub(buffer,!getIndex) before
         getIndex:=(!getIndex+1) mod 10)
  end



  (* mutexes for buffer access *)

  val access = Mutex.newBinaryMutex false;
  val empty = Mutex.newCountingMutex 10;
  val full = Mutex.newCountingMutex 0;
    
    
    
  (* producer *)
    
  fun makeProducer () =
    let
      val producerData = ref 0;
        
      fun nextItem()=(!producerData) before (producerData:=(!producerData)+1);
        
      fun produce() =
        while true do
          let val item = nextItem()
          in
            Mutex.wait [empty];
            Mutex.critical([access],addToBuffer) item;
            Mutex.signal [full]
          end
    in
      produce
    end






  (* consumer *)

  val output: int list ref = ref []
    
  fun makeConsumer () =
    let
      fun processDatum x = output:= x::(!output)
      
      fun consume() =
        while true do
          let
            val _ = Mutex.wait [full];
            val datum = Mutex.critical([access],readFromBuffer)();
            val _ = Mutex.signal [empty];
          in
            processDatum datum
          end
    in
      consume
    end
  



in

  (*  set up the threads mechanism *)


  fun run timeLimit =
    let
      
      val _ = output:=[]
        
      val p1 = makeProducer()
      val p2 = makeConsumer()
        
        
      (*  set up the threads mechanism *)
      val _ = P.set_interval 10;
      val _ = P.start();
        
      val id1 = T.fork p1 ()
      val id2 = T.fork p2 ()
        
        
      fun detectDeadlock() =
        if Mutex.allSleeping [id1,id2]
          then deadlockFlag:=true
        else detectDeadlock()
          
      val _ = deadlockFlag:=false
      val dd = T.fork detectDeadlock ()
        
        
        
        
        
        
      fun checkTime timer =
        if !deadlockFlag then ()
        else if Time.toSeconds(Timer.checkRealTimer timer)<timeLimit
               then checkTime timer
             else (I.kill id1;
                   I.kill id2;
                   if !deadlockFlag then () else I.kill dd)
               
               
               
               
      (* set up a timer *)
               
      val timer = Timer.startRealTimer()
      val _ =  checkTime timer
        
    in
      ()
    end
  
  
  

  fun testOutput () =
    let
      fun testOK ([],_) = true
        | testOK (h::t,n) = h+1=n andalso testOK(t,h)
    in
      case (!output)
        of [] => true
         | (h::t) => testOK (t,h)
    end
  
end  


val testAnswer =  (run 10; 
                   if !deadlockFlag then "Deadlocked."
                     else if testOutput() then "OK" else "WRONG");
                      
@


1.7
log
@[Bug #30369]
Replace source path with a list of files.
@
text
@d10 4
d45 1
a45 1
  Shell.Project.newProject();
@


1.6
log
@[Bug #50071]
Replace touchAllSource by a force compile
@
text
@d10 4
d42 6
a47 1
  Shell.Project.setSourcePath([OS.FileSys.getDir()^"/../src/utils"]);
@


1.5
log
@[Bug #50071]
Modify test to perform a Shell.Project.touchAllSources before compiling to force a recompile
@
text
@d10 4
d41 1
a41 2
  Shell.Project.touchAllSources();
  Shell.Project.compileAll();
@


1.4
log
@[Bug #50071]
Replace uses of Shell.Build.loadSource by Shell.Project
@
text
@d10 4
d37 1
@


1.3
log
@[Bug #30323]
@
text
@d10 3
d28 8
a35 1
Shell.Build.loadSource "utils.__mutex";
@


1.2
log
@[Bug #30085]
Make independent of structure changes
@
text
@d10 4
a24 3
Shell.Build.loadSource "system.__time";
Shell.Build.loadSource "basis.__array";
Shell.Build.loadSource "basis.__timer";
a25 1

@


1.1
log
@new unit
A test for the new mutual exclusion primitives.
@
text
@d9 5
a13 1
 * $Log:,v$
d20 1
@


1.1.1.1
log
@branched from 1.1
@
text
@d9 1
a9 5
 * $Log: mutexes.sml,v $
 *  Revision 1.1  1997/01/29  10:43:40  andreww
 *  new unit
 *  A test for the new mutual exclusion primitives.
 *
@


1.1.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 *  Revision 1.1.1.1  1997/05/12  11:11:45  hope
 *  branched from 1.1
 *
@


1.1.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 *  Revision 1.1.1.1  1997/05/12  11:11:45  hope
 *  branched from 1.1
 *
@


1.1.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 *  Revision 1.1.1.1  1997/05/12  11:11:45  hope
 *  branched from 1.1
 *
@


1.1.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 3
 *  Revision 1.1.1.1.1.1  1997/07/28  18:53:55  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@
