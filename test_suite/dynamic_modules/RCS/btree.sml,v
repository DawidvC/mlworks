head	1.2;
access;
symbols
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_11r1:1.2.8.1.1.1.1
	MLWorks_11c0_1997_09_09:1.2.8.1.1.1
	MLWorks_10r3:1.2.8.1.3
	MLWorks_10r2_551:1.2.8.1.2
	MLWorks_11:1.2.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.2.8.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.2.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.2.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.2.8
	MLWorks_BugFix_1997_04_24:1.2
	MLWorks_1_0_r2_Win32_1997_04_11:1.2
	MLWorks_1_0_r2_Unix_1997_04_04:1.2
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.6.1.1
	MLWorks_gui_1996_12_18:1.2.7
	MLWorks_1_0_Win32_1996_12_17:1.2.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.4.1
	MLWorks_1_0_Irix_1996_11_28:1.2.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.5
	MLWorks_1_0_Unix_1996_11_14:1.2.4
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ * @;


1.2
date	96.02.23.16.28.23;	author daveb;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1
	1.2.4.1
	1.2.5.1
	1.2.6.1
	1.2.7.1
	1.2.8.1;
next	1.1;

1.1
date	95.12.22.15.16.04;	author jont;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.31.13;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.16.22.02;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.42.33;	author hope;	state Exp;
branches;
next	;

1.2.4.1
date	96.11.14.13.09.49;	author hope;	state Exp;
branches
	1.2.4.1.1.1;
next	;

1.2.4.1.1.1
date	96.11.28.15.19.43;	author hope;	state Exp;
branches;
next	;

1.2.5.1
date	96.11.22.18.27.14;	author hope;	state Exp;
branches;
next	;

1.2.6.1
date	96.12.17.18.05.47;	author hope;	state Exp;
branches
	1.2.6.1.1.1;
next	;

1.2.6.1.1.1
date	97.02.24.11.58.14;	author hope;	state Exp;
branches;
next	;

1.2.7.1
date	96.12.18.10.00.49;	author hope;	state Exp;
branches;
next	;

1.2.8.1
date	97.05.12.10.59.45;	author hope;	state Exp;
branches
	1.2.8.1.1.1
	1.2.8.1.2.1
	1.2.8.1.3.1;
next	;

1.2.8.1.1.1
date	97.07.28.18.41.56;	author daveb;	state Exp;
branches
	1.2.8.1.1.1.1.1;
next	;

1.2.8.1.1.1.1.1
date	97.10.07.12.07.10;	author jkbrook;	state Exp;
branches;
next	;

1.2.8.1.2.1
date	97.09.08.17.34.21;	author daveb;	state Exp;
branches;
next	;

1.2.8.1.3.1
date	97.09.09.14.32.44;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.2
log
@Converted Shell structure to new capitalisation convention.
@
text
@(*
Debug info must be cleared when recompilation
takes place and the debug switches are off.

Result: OK
 
$Log: btree.sml,v $
 *  Revision 1.1  1995/12/22  15:16:04  jont
 *  new unit
 *

Copyright (c) 1995 Harlequin Ltd.
*)
val _ = Shell.Options.set(Shell.Options.Compiler.generateDebugInfo, true)
val _ = Shell.Options.set(Shell.Options.Compiler.generateVariableDebugInfo, true)
structure Btree =
  struct

    datatype 'a TreeRep = E | T of 'a * int * 'a TreeRep * 'a TreeRep
    datatype 'a Tree = Tree of 'a TreeRep * ('a * 'a -> bool)

    local

      fun size' E = 0
	| size' (T(_,n,_,_)) = n

      val weight = 3

      (*fun N(v,l,r) = T(v,1+size'(l)+size'(r),l,r)*)
      fun N(v,E,              E)               = T(v,1,E,E)
	| N(v,E,              r as T(_,n,_,_)) = T(v,n+1,E,r)
	| N(v,l as T(_,n,_,_),E)               = T(v,n+1,l,E)
	| N(v,l as T(_,n,_,_),r as T(_,m,_,_)) = T(v,n+m+1,l,r)

      fun single_L (a,x,T(b,_,y,z)) = N(b,N(a,x,y),z)
	| single_L _ = raise Match
      fun single_R (b,T(a,_,x,y),z) = N(a,x,N(b,y,z))
	| single_R _ = raise Match
      fun double_L (a,w,T(c,_,T(b,_,x,y),z)) = N(b,N(a,w,x),N(c,y,z))
	| double_L _ = raise Match
      fun double_R (c,T(a,_,w,T(b,_,x,y)),z) = N(b,N(a,w,x),N(c,y,z))
	| double_R _ = raise Match

      fun T' (v,E,E) = T(v,1,E,E)
	| T' (v,E,r as T(_,_,E,E))     = T(v,2,E,r)
	| T' (v,l as T(_,_,E,E),E)     = T(v,2,l,E)

	| T' (p as (_,E,T(_,_,T(_,_,_,_),E))) = double_L p
	| T' (p as (_,T(_,_,E,T(_,_,_,_)),E)) = double_R p

	(* these cases almost never happen with small weight*)
	| T' (p as (_,E,T(_,_,T(_,ln,_,_),T(_,rn,_,_)))) =
	  if ln < rn then single_L p else double_L p
	| T' (p as (_,T(_,_,T(_,ln,_,_),T(_,rn,_,_)),E)) =
	  if rn < ln then single_R p else double_R p

	| T' (p as (_,E,T(_,_,E,_)))  = single_L p
	| T' (p as (_,T(_,_,_,E),E))  = single_R p

	| T' (p as (v,l as T(lv,ln,ll,lr),r as T(rv,rn,rl,rr))) =
	  if rn>=weight*ln then (*right is too big*)
	    let val rln = size' rl
	      val rrn = size' rr
	    in
	      if rln < rrn then  single_L p  else  double_L p
	    end
		    
	  else if ln>=weight*rn then  (*left is too big*)
	    let val lln = size' ll
	      val lrn = size' lr
	    in
	      if lrn < lln then  single_R p  else  double_R p
	    end

	       else
		 T(v,ln+rn+1,l,r)

      fun add' _ (E, 42) = raise Div
	| add' _ (E, x) = T (x, 1, E, E)
	| add' lt (tree as T (v, _, l, r), x) =
	  if lt(x,v) then T' (v, add' lt (l,x), r)
	  else if lt(v,x) then T' (v, l, add' lt (r,x))
	       else tree

      fun concat3 lt (E,v,r) = add' lt (r,v)
	| concat3 lt (l,v,E) = add' lt (l,v)
	| concat3 lt (l as T(v1,n1,l1,r1), v, r as T(v2,n2,l2,r2)) =
	  if weight*n1 < n2 then T' (v2, concat3 lt (l,v,l2), r2)
	  else if weight*n2 < n1 then T' (v1, l1, concat3 lt (r1,v,r))
	       else N (v, l, r)

      fun split_lt lt (E,x) = E
	| split_lt lt (t as T(v,_,l,r), x) =
	  if lt(x,v) then split_lt lt (l,x)
	  else if lt(v,x) then concat3 lt (l, v, split_lt lt (r,x))
	       else l

      fun split_gt lt (E,x) = E
	| split_gt lt (t as T(v,_,l,r), x) =
	  if lt(v,x) then split_gt lt (r, x)
	  else if lt(x,v) then concat3 lt (split_gt lt (l,x), v, r)
	       else r

      fun min (T(v,_,E,_)) = v
	| min (T(v,_,l,_)) = min l
	| min _            = raise Match
		
      and delete' (E,r) = r
	| delete' (l,E) = l
	| delete' (l,r) = let val min_elt = min r in
	  T'(min_elt,l,delmin r)
			  end
      and delmin (T(_,_,E,r)) = r
	| delmin (T(v,_,l,r)) = T'(v,delmin l,r)
	| delmin _ = raise Match

      fun delete'' lt (E, x) = E
	| delete'' lt (tree as T (v, _, l, r), x) =
	  if lt(x,v) then T' (v, delete'' lt (l, x), r)
	  else if lt(v,x) then T' (v, l, delete'' lt (r, x))
	       else delete' (l, r)

      fun concat (E,  s2) = s2
	| concat (s1, E)  = s1
	| concat (t1 as T(v1,n1,l1,r1), t2 as T(v2,n2,l2,r2)) =
	  if weight*n1 < n2 then T'(v2,concat(t1,l2),r2)
	  else if weight*n2 < n1 then T'(v1,l1,concat(r1,t2))
	       else T'(min t2,t1, delmin t2)

      fun fold(f,base,set) =
	let fun fold'(base,E) = base
	      | fold'(base,T(v,_,l,r)) = fold'(f(v,fold'(base,r)),l)
	in 
	  fold'(base,set)
	end

      fun listfold f b [] = b
	| listfold f b (h::t) = listfold f (f (h, b)) t
    in
      fun size (Tree (tree, lt)) = size' tree

      fun empty lt = Tree (E, lt)

      fun add (Tree (tree, lt), v) = Tree (add' lt (tree, v), lt)
		
      fun member (x, Tree (tree, lt)) =
	let fun mem E = false
	      | mem (T(v,_,l,r)) =
		if lt(x,v) then
		  mem l
		else if lt(v,x) then
		  mem r
		     else true
	in mem tree end

	  fun delete (Tree (tree, lt), x) = Tree (delete'' lt (tree, x), lt)

	  fun members (Tree (tree, _)) = fold(op::,[],tree)

	  fun fromList (l, lt) =
	    Tree (listfold (fn (x,y) => add' lt (y,x)) E l, lt)

	  val eg = fromList ([12,23,1,~54,7896,8,~96], op<)
    end
  end

val x = Btree.fromList([1,2,3], op>)
@


1.2.8.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1996/02/23  16:28:23  daveb
 * Converted Shell structure to new capitalisation convention.
 *
@


1.2.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.2.8.1  1997/05/12  10:59:45  hope
 * branched from 1.2
 *
@


1.2.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.2.8.1  1997/05/12  10:59:45  hope
 * branched from 1.2
 *
@


1.2.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.2.8.1  1997/05/12  10:59:45  hope
 * branched from 1.2
 *
@


1.2.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.2.8.1.1.1  1997/07/28  18:41:56  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.2.7.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1996/02/23  16:28:23  daveb
 * Converted Shell structure to new capitalisation convention.
 *
@


1.2.6.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1996/02/23  16:28:23  daveb
 * Converted Shell structure to new capitalisation convention.
 *
@


1.2.6.1.1.1
log
@branched from 1.2.6.1
@
text
@a7 3
 * Revision 1.2.6.1  1996/12/17  18:05:47  hope
 * branched from 1.2
 *
@


1.2.5.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1996/02/23  16:28:23  daveb
 * Converted Shell structure to new capitalisation convention.
 *
@


1.2.4.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1996/02/23  16:28:23  daveb
 * Converted Shell structure to new capitalisation convention.
 *
@


1.2.4.1.1.1
log
@branched from 1.2.4.1
@
text
@a7 3
 * Revision 1.2.4.1  1996/11/14  13:09:49  hope
 * branched from 1.2
 *
@


1.2.3.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1996/02/23  16:28:23  daveb
 * Converted Shell structure to new capitalisation convention.
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1996/02/23  16:28:23  daveb
 * Converted Shell structure to new capitalisation convention.
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a7 3
 * Revision 1.2  1996/02/23  16:28:23  daveb
 * Converted Shell structure to new capitalisation convention.
 *
@


1.1
log
@new unit
@
text
@d7 4
a10 1
$Log$
d14 2
a15 2
val _ = Shell.Options.set(Shell.Options.Compiler.generate_debug_info, true)
val _ = Shell.Options.set(Shell.Options.Compiler.generate_variable_debug_info, true)
@
