head	1.15;
access;
symbols
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.14
	MLWorks_20b2_Windows_1998_06_12:1.14
	MLWorks_20b1c1_1998_05_07:1.13
	MLWorks_20b0_1998_04_07:1.13
	MLWorks_20b0_1998_03_20:1.13
	MLWorks_20m2_1998_02_16:1.13
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.9.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.9.1.1.1.1
	MLWorks_10r3:1.9.1.1.3
	MLWorks_10r2_551:1.9.1.1.2
	MLWorks_11:1.9.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.9.1.1
	MLWorks_20m0_1997_06_20:1.10
	MLWorks_1_0_r2c2_1997_06_14:1.9.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.9.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.9.1
	MLWorks_BugFix_1997_04_24:1.9
	MLWorks_1_0_r2_Win32_1997_04_11:1.9
	MLWorks_1_0_r2_Unix_1997_04_04:1.9
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.4.1.1
	MLWorks_gui_1996_12_18:1.6.5
	MLWorks_1_0_Win32_1996_12_17:1.6.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.2.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.2.1
	MLWorks_1_0_Irix_1996_11_28:1.6.2.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.3
	MLWorks_1_0_Unix_1996_11_14:1.6.2
	MLWorks_Open_Beta2_1996_10_11:1.6.1
	MLWorks_License_dev:1.5.1
	MLWorks_1_open_beta_1996_09_13:1.3.1
	MLWorks_Open_Beta_1996_08_22:1.3
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.3
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.3
	MLWorks_Beta_1996_05_31:1.3
	MLWorks_Beta_1996_05_30:1.3;
locks; strict;
comment	@ *  @;


1.15
date	98.10.09.14.29.14;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	98.05.08.16.32.08;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	97.11.21.10.43.52;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	97.09.25.10.39.54;	author brucem;	state Exp;
branches;
next	1.11;

1.11
date	97.09.11.15.25.33;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	97.05.07.13.29.24;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	97.03.27.09.48.02;	author jont;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	97.03.03.12.31.33;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	96.12.20.12.15.29;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	96.10.14.08.56.53;	author stephenb;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1;
next	1.5;

1.5
date	96.10.07.11.10.31;	author stephenb;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	96.10.02.11.28.55;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.10.19.02;	author daveb;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	96.05.16.13.51.37;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.05.10.17.01.06;	author jont;	state Exp;
branches;
next	;

1.3.1.1
date	96.09.13.11.38.41;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.10.07.16.30.08;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.10.17.11.50.45;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.11.14.13.18.11;	author hope;	state Exp;
branches
	1.6.2.1.1.1;
next	;

1.6.2.1.1.1
date	96.11.28.15.28.41;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.11.22.18.35.57;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.12.17.18.14.56;	author hope;	state Exp;
branches
	1.6.4.1.1.1;
next	;

1.6.4.1.1.1
date	97.02.24.12.07.56;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	96.12.18.10.09.55;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	97.05.12.11.08.35;	author hope;	state Exp;
branches
	1.9.1.1.1.1
	1.9.1.1.2.1
	1.9.1.1.3.1;
next	;

1.9.1.1.1.1
date	97.07.28.18.50.56;	author daveb;	state Exp;
branches
	1.9.1.1.1.1.1.1;
next	;

1.9.1.1.1.1.1.1
date	97.10.07.12.15.38;	author jkbrook;	state Exp;
branches;
next	;

1.9.1.1.2.1
date	97.09.08.17.42.41;	author daveb;	state Exp;
branches;
next	;

1.9.1.1.3.1
date	97.09.09.14.42.07;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.15
log
@[Bug #30489]
Add test for empty string to Date.fmt
@
text
@(* Test suite for Date functions.

Result: OK
 * $Log: date.sml,v $
 *  Revision 1.14  1998/05/08  16:32:08  jont
 *  [Bug #70110]
 *  Modify so it works on most unix machines
 *
 *  Revision 1.13  1997/11/21  10:43:52  daveb
 *  [Bug #30323]
 *
 *  Revision 1.12  1997/09/25  10:39:54  brucem
 *  [Bug #30269]
 *  DATE signature has been revised.  Test features of new specification.
 *
 *  Revision 1.11  1997/09/11  15:25:33  jont
 *  [Bug #20102]
 *  Fix problems caused by incompatibility of support for strftime
 *  formats between unix and Win32
 *
 *  Revision 1.10  1997/05/07  13:29:24  daveb
 *  [Bug #30112]
 *  Added use of Date.fmt.  Replaced MLWorks.IO.output with print.
 *  Added more information for failing tests.
 *
 *  Revision 1.9  1997/03/27  09:48:02  jont
 *  Modify date comparison not to use polymorphic equality
 *  as some fields aren't guaranteed
 *
 *  Revision 1.8  1997/03/03  12:31:33  daveb
 *  [Bug #1937]
 *  Corrected the type of Date.scan.
 *
 *  Revision 1.7  1996/12/20  12:15:29  jont
 *  [Bug #0]
 *  Changed because test suite has moved
 *
 *  Revision 1.6  1996/10/14  08:56:53  stephenb
 *  The previous change breaks on machines which aren't running under
 *  GMT (e.g. babylon) since Date.fromUTC o Date.toTime is not the identity
 *  in such timezones.  Consequently changed it back to fromTime o toTime.
 *  This means that the test now fails under SunOS (sorrol) again.
 *
 *  Revision 1.5  1996/10/07  11:10:31  stephenb
 *  Change to use fromUTC to avoid a bug in SunOS when using fromTime
 *  on the equivalent of Time.zeroTime.
 *
 *  Revision 1.4  1996/10/02  11:28:55  stephenb
 *  Add Date.toTime tests.
 *
 *  Revision 1.3  1996/05/22  10:19:02  daveb
 *  Shell.Module renamed to Shell.Build.
 *
 *  Revision 1.2  1996/05/16  13:51:37  jont
 *  chars has moved to char
 *
 *  Revision 1.1  1996/05/10  17:01:06  jont
 *  new unit
 *
 *
 * Copyright (c) 1996 Harlequin Ltd.
 *
 *)


local
  (* We need two version of the date string here *)
  (* One is the result produced by Date.toString *)
  (* The other is the result produced by Date.fmt *)
  (* Under xpg4 Date.fmt has an option (%e) to allow it to produce *)
  (* leading spaces instead of leading zeroes *)
  (* Unfortunately Win32 doesn't support this, and we are forced *)
  (* to use %d instead *)
  val date_string_a = "Thu May  9 16:30:10 1996"
  val date_string_b = "Thu May 09 16:30:10 1996"
  val fmt_string = "%a %b %d %H:%M:%S %Y"

  fun getc(s, i) =
    if i >= size s then
      NONE
    else
      SOME(Char.chr(MLWorks.String.ordof(s, i)), (s, i+1))

  fun compare_dates
	(msg_string,
	 date, date') =
    if Date.compare(date, date') = EQUAL then
      (print (msg_string ^ " succeeded.\n"); true)
    else
      let
        val year = Date.year date and year' = Date.year date'
        val month = Date.month date and month' = Date.month date'
        val day = Date.day date and day' = Date.day date'
        val hour = Date.hour date and hour' = Date.hour date'
        val minute = Date.minute date and minute' = Date.minute date'
        val second = Date.second date and second' = Date.second date'
        val wday = Date.weekDay date and wday' = Date.weekDay date'
        val yday = Date.yearDay date and yday' = Date.yearDay date'
      in
        (print (msg_string ^ " Error different dates:\n");
         print ("  Dates are "^(Date.toString date)^
                " and "^(Date.toString date')^"\n");
         (if year<>year' then print"  years fail\n" else ());
         (if month<>month' then print"  months fail\n" else ());
         (if day<>day' then print"   days fail\n" else ());
         (if hour<>hour' then print"  hours fail\n" else ());
         (if minute<>minute' then print"  minutes fail\n" else ());
         (if second<>second' then print"  seconds fail\n" else ());
         (if wday<>wday' then print"  weekDays fail\n" else ());
         (if yday<>yday' then print"  yearDays fail\n" else ());
         false)
      end
in

  local
    val date =
      case Date.fromString date_string_a of
        NONE => (print ("Date.fromString \""^date_string_a^"\" failed\n");
	         raise Match)
      | SOME date => date

    val date' =
      let
        val date_string' = MLWorks.String.substring(Date.toString date, 0, 24)
      in
        if date_string' = date_string_a then
          let
	    val date' = Date.scan getc (date_string_a, 0)
          in
	    case date' of
	      SOME(date', _) =>
	        (if compare_dates("date", date, date') then
		   let 
		     val date_fmt = Date.fmt fmt_string date 
                   in
		     if date_fmt = date_string_b then
		       print "Date fmt succeeded\n"
                     else
                       print("Date fmt returned '" ^ date_fmt ^
                             "', instead of '" ^ date_string_b ^ "'\n")
                   end
                 else
                   print "Date scan gave wrong answer\n";
                 date')
              | NONE =>
	        (print "Date scan failed entirely\n";
	         date)
	  end
        else
	  (print ("Date print failed with '" ^ date_string' ^ "'\n");
	   date)
      end
    in
    end

  local
    (* These are local as they will vary between Unix and Win32 *)
    val dateStart = Date.date {year= 1970, month= Date.Jan, day= 2,
                               hour= 0, minute= 0, second= 0,
                               offset = NONE}
    val dateEnd = Date.date {year= 2030, month= Date.Dec, day= 31,
                             hour= 23, minute= 59, second= 59,
                             offset = NONE}
    val dateStart' = Date.fromTimeLocal (Date.toTime dateStart)
    val dateEnd' = Date.fromTimeLocal (Date.toTime dateEnd)
  in
    val _ = compare_dates("dateStart", dateStart, dateStart')
    val _ = compare_dates("dateEnd", dateEnd, dateEnd')
  end

  local
    (* As early a date as we expect to deal with: *)
    val date1 =
      Date.date{year=1900, month=Date.Jan, day=1,
                hour=00, minute=00, second=00, offset=NONE}
    (* This should be the same as date1 *)
    val date2 =
      Date.date{year=1899, month=Date.Dec, day=31,
                hour=23, minute=59, second=60, offset=NONE}
  in
    val _ = print ((Date.toString date1)^"\n");
    val _ = print ((Date.toString date2)^"\n");
    val _ = compare_dates("Carrying over start of 1900", date1, date2)
  end

  local
    fun isLeap year = 
      let
        val date = Date.date{year = year, month = Date.Feb, day = 29,
                             hour = 12, minute = 0, second = 0, offset = NONE}
        val month = Date.month date
      in
        month = Date.Feb
      end
    fun test year = if isLeap year then
                      print ((Int.toString year)^" is a leap year\n")
                    else
                      print ((Int.toString year)^" is not a leap year\n")
  in
    val _ = (test 1900; test 1984; test 1983; test 2000; test 1600)
  end

  (* check day of the week *)
  val _ =
    let
      val date = Date.date{year=1997, month=Date.Sep, day = 23,
                           hour=12, minute=0, second=0, offset=NONE}
      val day = Date.weekDay date
    in
      if day = Date.Tue then
         print "Day of the week succeeded.\n"
      else
         print ("Day of the week failed.\n  "^(Date.toString date)^"\n")
    end

  (* Test that incorrect times are not created.
     An exception should be raised by Date.toTime when it encounters
     a date which cannot be represented as a time.
     If a correct time is created then change the date in the test
     to something earlier.
     Any date before Date.fromTimeUniv(Time.zeroTime) (on all platforms)
     should work. *)
  val _ =
    let
      val date = Date.date{year=1500, month=Date.Sep, day = 23,
                           hour=12, minute=0, second=0,
                           offset=SOME (Time.zeroTime)}
      val time = Date.toTime date
            handle Date.Date =>
               (print "Date.toTime raised exception Date ok.\n";
                raise Fail "ok")
      val date' = Date.fromTimeUniv time
    in
      if Date.compare(date, date') = EQUAL then
        print "Date.toTime failed, incorrect time created\n"
      else
        print ("Date.toTime test failed, please change test file.\n")
    end
    handle Fail "ok" => ()
         | _ => print "Date.ToTime raised wrong exception.\n"

  (* Test that timezone stuff works.  This is best executed outside GMT
     (e.g. in the summer).  As we use the time `now', any errors from
     this may be caused by a problem due to changes that have happened
     now (e.g. changing to BST). *)
  val _ =
    let
      val now = Time.now ()

      val dateLocal = Date.fromTimeLocal now
      val dateUniv = Date.fromTimeUniv now
      val offsetLocal = Date.offset dateLocal
      val offsetUniv = Date.offset dateUniv
      val timeLocal = Date.toTime dateLocal
      val timeUniv = Date.toTime dateUniv

      val reportedOffset = Date.localOffset ()
      (* Get the difference between the dates as a time from 0..24 hours. *)
      val measuredOffset =
        Time.-(timeUniv, timeLocal)
        handle Time.Time =>
          Time.-(Time.+(timeUniv, Time.fromSeconds(24*60*60)), timeLocal)
    in
      (case offsetLocal of
         NONE => print "Offset of timeLocal is correct (NONE).\n"
       | SOME _ => print "Offset of timeLocal is incorrect (SOME _).\n");
      (case offsetUniv of 
         NONE => print "offsetUniv is incorrect (NONE).\n"
       | SOME t => if t=Time.zeroTime then
                     print "Offset of timeUniv is correct (SOME 0).\n"
                   else
                     print ("Offset of timeUniv is incorrect (SOME " ^
                            (Time.toString t) ^ ").\n") );
      (if reportedOffset = measuredOffset then
         print "localOffset matches my calculation ok.\n"
       else
         print ("Local offset doesn't match, measured = " ^ 
                (Time.toString measuredOffset) ^
                ", reported = " ^ (Time.toString reportedOffset) ^ ".\n") )
    end
    


end

val x = Date.fmt "" (Date.fromTimeLocal(Time.now())) = "";
@


1.14
log
@[Bug #70110]
Modify so it works on most unix machines
@
text
@d5 4
d285 2
@


1.13
log
@[Bug #30323]
@
text
@d5 3
d154 1
a154 1
    val dateStart = Date.date {year= 1970, month= Date.Jan, day= 1,
@


1.12
log
@[Bug #30269]
DATE signature has been revised.  Test features of new specification.
@
text
@d5 4
a57 10
local
  (* Avoid answer files dependency on structure contents *)
  val _ =  Shell.Options.set(Shell.Options.ValuePrinter.maximumStrDepth, 0);
in
  val _ =
    (Shell.Build.loadSource "basis.__date";
     Shell.Build.loadSource "system.__time";
     Shell.Build.loadSource "basis.__int";
     Shell.Build.loadSource "basis.__char")
end;
@


1.11
log
@[Bug #20102]
Fix problems caused by incompatibility of support for strftime
formats between unix and Win32
@
text
@d5 5
d61 1
d85 3
a87 8
	 Date.DATE{year, month, day, hour, minute, second, wday, yday, isDst},
         Date.DATE{year=year', month=month', day=day', hour=hour',
		   minute=minute', second=second', wday=wday', yday=yday',
		   isDst=isDst'}) =
    if year=year' andalso month=month' andalso day=day' andalso
       hour=hour' andalso minute=minute' andalso second=second' andalso
       wday=wday' andalso yday=yday' then
      true
d89 23
a111 10
      (print (msg_string ^ ":\n");
       (if year<>year' then print"years fail\n" else ());
       (if month<>month' then print"months fail\n" else ());
       (if day<>day' then print"days fail\n" else ());
       (if hour<>hour' then print"hours fail\n" else ());
       (if minute<>minute' then print"minutes fail\n" else ());
       (if second<>second' then print"seconds fail\n" else ());
       (if wday<>wday' then print"wdays fail\n" else ());
       (if yday<>yday' then print"ydays fail\n" else ());
       false)
a112 5
  val date =
    case Date.fromString date_string_a of
      NONE => (print "Date conversion failed\n";
	       raise Match)
    | SOME date => date
d114 38
a151 3
  val date' =
    let
      val date_string' = MLWorks.String.substring(Date.toString date, 0, 24)
a152 26
      if date_string' = date_string_a then
        let
	  val date' = Date.scan getc (date_string_a, 0)
	in
	  case date' of
	    SOME(date', _) =>
	      (if compare_dates("date", date, date') then
		 let 
		   val date_fmt = Date.fmt fmt_string date 
		 in
		   if date_fmt = date_string_b then
		     print "Date fmt succeeded\n"
		   else
		     print("Date fmt returned '" ^ date_fmt ^
		           "', instead of '" ^ date_string_b ^ "'\n")
		 end
	       else
		 print "Date scan gave wrong answer\n";
	       date')
	  | NONE =>
	      (print "Date scan failed entirely\n";
	       date)
	end
      else
	(print ("Date print failed with '" ^ date_string' ^ "'\n");
	 date)
d154 1
a154 1
  
d157 41
a197 8
    val dateStart = Date.DATE {year= 1970, month= Date.Jan, day= 1,
                         hour= 0, minute= 0, second= 0,
                         wday= SOME Date.Thu, yday= SOME 0, isDst= SOME false}
    val dateEnd = Date.DATE {year= 2030, month= Date.Dec, day= 31,
                       hour= 23, minute= 59, second= 59,
                        wday= SOME Date.Tue, yday= SOME 364, isDst= SOME false}
    val dateStart' = Date.fromTime (Date.toTime dateStart)
    val dateEnd' = Date.fromTime (Date.toTime dateEnd)
d199 1
a199 2
    val time_a = compare_dates("dateStart", dateStart, dateStart')
    val time_b = compare_dates("dateEnd", dateEnd, dateEnd')
d201 82
@


1.10
log
@[Bug #30112]
Added use of Date.fmt.  Replaced MLWorks.IO.output with print.
Added more information for failing tests.
@
text
@d5 5
d49 9
a57 3
Shell.Build.loadSource "basis.__date";
Shell.Build.loadSource "system.__time";
Shell.Build.loadSource "basis.__char";
d60 10
a69 2
  val date_string = "Thu May  9 16:30:10 1996"
  val fmt_string = "%a %b %e %T %Y"
d100 1
a100 1
    case Date.fromString date_string of
d109 1
a109 1
      if date_string' = date_string then
d111 1
a111 1
	  val date' = Date.scan getc (date_string, 0)
d117 1
a117 1
		     val date_fmt = Date.fmt fmt_string date 
d119 1
a119 1
		   if date_fmt = date_string then
d123 1
a123 1
		           "', instead of '" ^ date_string ^ "'\n")
d137 3
a139 1
  val dateStart = Date.DATE {year= 1970, month= Date.Jan, day= 1,
d142 1
a142 1
  val dateEnd = Date.DATE {year= 2030, month= Date.Dec, day= 31,
d145 6
a150 5
  val dateStart' = Date.fromTime (Date.toTime dateStart)
  val dateEnd' = Date.fromTime (Date.toTime dateEnd)

  val time_a = compare_dates("dateStart", dateStart, dateStart')
  val time_b = compare_dates("dateEnd", dateEnd, dateEnd')
@


1.9
log
@Modify date comparison not to use polymorphic equality
as some fields aren't guaranteed
@
text
@d5 4
a43 1
Shell.Path.setSourcePath ["../src"];
d48 37
a84 1
val date_string = "Thu May  9 16:30:10 1996"
d86 1
a86 10
fun getc(s, i) =
  if i >= size s then
    NONE
  else
    SOME(Char.chr(MLWorks.String.ordof(s, i)), (s, i+1))

val date = case Date.fromString date_string of
  NONE => (MLWorks.IO.output(MLWorks.IO.std_out, "Date conversion failed\n");
	   raise Match)
| SOME date =>
d91 1
a91 1
	let
d96 10
a105 2
	      (if date' = date then
		 MLWorks.IO.output(MLWorks.IO.std_out, "Date scan succeeded\n")
d107 2
a108 2
		 MLWorks.IO.output(MLWorks.IO.std_out, "Date scan gave wrong answer\n");
		date')
d110 1
a110 1
	      (MLWorks.IO.output(MLWorks.IO.std_out, "Date scan failed entirely\n");
d114 1
a114 2
	(MLWorks.IO.output(MLWorks.IO.std_out, "Date print failed with '" ^
			  date_string' ^ "'\n");
d117 1
a117 21



local
  fun output s = MLWorks.IO.output(MLWorks.IO.std_out, s^"\n")
  fun compare_dates(Date.DATE{year, month, day, hour, minute, second, wday, yday, isDst},
                    Date.DATE{year=year', month=month', day=day', hour=hour', minute=minute',
                              second=second', wday=wday', yday=yday', isDst=isDst'}) =
    if year=year' andalso month=month' andalso day=day' andalso hour=hour' andalso minute=minute' andalso
      second=second' andalso wday=wday' andalso yday=yday' then
      true
    else
      ((if year<>year' then output"years fail" else ());
       (if month<>month' then output"months fail" else ());
       (if day<>day' then output"days fail" else ());
       (if hour<>hour' then output"hours fail" else ());
       (if minute<>minute' then output"minutes fail" else ());
       (if second<>second' then output"seconds fail" else ());
       (if wday<>wday' then output"wdays fail" else ());
       (if yday<>yday' then output"ydays fail" else ());
       false)
d124 5
a128 3
in
  val time_a = compare_dates(dateStart, Date.fromTime (Date.toTime dateStart))
  val time_b = compare_dates(dateEnd, Date.fromTime (Date.toTime dateEnd))
@


1.9.1.1
log
@branched from 1.9
@
text
@a4 4
 *  Revision 1.9  1997/03/27  09:48:02  jont
 *  Modify date comparison not to use polymorphic equality
 *  as some fields aren't guaranteed
 *
@


1.9.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a4 3
 *  Revision 1.9.1.1  1997/05/12  11:08:35  hope
 *  branched from 1.9
 *
@


1.9.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a4 3
 *  Revision 1.9.1.1  1997/05/12  11:08:35  hope
 *  branched from 1.9
 *
@


1.9.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a4 3
 *  Revision 1.9.1.1  1997/05/12  11:08:35  hope
 *  branched from 1.9
 *
@


1.9.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a4 3
 *  Revision 1.9.1.1.1.1  1997/07/28  18:50:56  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.8
log
@[Bug #1937]
Corrected the type of Date.scan.
@
text
@d5 4
d84 17
d108 2
a109 2
  val time_a = dateStart = Date.fromTime (Date.toTime dateStart);
  val time_b = dateEnd = Date.fromTime (Date.toTime dateEnd)
@


1.7
log
@[Bug #0]
Changed because test suite has moved
@
text
@d5 4
d58 1
a58 1
	  val date' = Date.scan {getc=getc} (date_string, 0)
@


1.6
log
@The previous change breaks on machines which aren't running under
GMT (e.g. babylon) since Date.fromUTC o Date.toTime is not the identity
in such timezones.  Consequently changed it back to fromTime o toTime.
This means that the test now fails under SunOS (sorrol) again.
@
text
@d5 6
d32 1
a32 1
Shell.Path.setSourcePath [".."];
@


1.6.5.1
log
@branched from 1.6
@
text
@a4 6
 *  Revision 1.6  1996/10/14  08:56:53  stephenb
 *  The previous change breaks on machines which aren't running under
 *  GMT (e.g. babylon) since Date.fromUTC o Date.toTime is not the identity
 *  in such timezones.  Consequently changed it back to fromTime o toTime.
 *  This means that the test now fails under SunOS (sorrol) again.
 *
@


1.6.4.1
log
@branched from 1.6
@
text
@a4 6
 *  Revision 1.6  1996/10/14  08:56:53  stephenb
 *  The previous change breaks on machines which aren't running under
 *  GMT (e.g. babylon) since Date.fromUTC o Date.toTime is not the identity
 *  in such timezones.  Consequently changed it back to fromTime o toTime.
 *  This means that the test now fails under SunOS (sorrol) again.
 *
@


1.6.4.1.1.1
log
@branched from 1.6.4.1
@
text
@a4 3
 *  Revision 1.6.4.1  1996/12/17  18:14:56  hope
 *  branched from 1.6
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a4 6
 *  Revision 1.6  1996/10/14  08:56:53  stephenb
 *  The previous change breaks on machines which aren't running under
 *  GMT (e.g. babylon) since Date.fromUTC o Date.toTime is not the identity
 *  in such timezones.  Consequently changed it back to fromTime o toTime.
 *  This means that the test now fails under SunOS (sorrol) again.
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a4 6
 *  Revision 1.6  1996/10/14  08:56:53  stephenb
 *  The previous change breaks on machines which aren't running under
 *  GMT (e.g. babylon) since Date.fromUTC o Date.toTime is not the identity
 *  in such timezones.  Consequently changed it back to fromTime o toTime.
 *  This means that the test now fails under SunOS (sorrol) again.
 *
@


1.6.2.1.1.1
log
@branched from 1.6.2.1
@
text
@a4 3
 *  Revision 1.6.2.1  1996/11/14  13:18:11  hope
 *  branched from 1.6
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a4 6
 *  Revision 1.6  1996/10/14  08:56:53  stephenb
 *  The previous change breaks on machines which aren't running under
 *  GMT (e.g. babylon) since Date.fromUTC o Date.toTime is not the identity
 *  in such timezones.  Consequently changed it back to fromTime o toTime.
 *  This means that the test now fails under SunOS (sorrol) again.
 *
@


1.5
log
@Change to use fromUTC to avoid a bug in SunOS when using fromTime
on the equivalent of Time.zeroTime.
@
text
@d5 4
d77 2
a78 2
  val time_a = dateStart = Date.fromUTC (Date.toTime dateStart);
  val time_b = dateEnd = Date.fromUTC (Date.toTime dateEnd)
@


1.5.1.1
log
@branched from 1.5
@
text
@a4 4
 *  Revision 1.5  1996/10/07  11:10:31  stephenb
 *  Change to use fromUTC to avoid a bug in SunOS when using fromTime
 *  on the equivalent of Time.zeroTime.
 *
@


1.4
log
@Add Date.toTime tests.
@
text
@d5 3
d68 1
a68 1
                         wday= SOME Date.Thu, yday= SOME 0, isDst= SOME true}
d73 2
a74 2
  val time_a = dateStart = Date.fromTime (Date.toTime dateStart);
  val time_b = dateEnd = Date.fromTime (Date.toTime dateEnd)
@


1.3
log
@Shell.Module renamed to Shell.Build.
@
text
@d4 4
a7 1
 * $Log: basis:date.sml,v $
a19 1
Shell.Build.loadSource "basis.toplevel";
d21 1
d59 14
@


1.3.1.1
log
@branched from 1.3
@
text
@d4 1
a4 4
 * $Log: date.sml,v $
 *  Revision 1.3  1996/05/22  10:19:02  daveb
 *  Shell.Module renamed to Shell.Build.
 *
@


1.2
log
@chars has moved to char
@
text
@d5 3
d17 3
a19 3
Shell.Module.loadSource "basis.toplevel";
Shell.Module.loadSource "basis.__date";
Shell.Module.loadSource "basis.__char";
@


1.1
log
@new unit
@
text
@d4 4
a7 1
 * $Log$
d16 1
a16 1
Shell.Module.loadSource "basis.__chars";
@
