head	1.2;
access;
symbols
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_20m1_1997_10_23:1.1
	MLWorks_11r1:1.1.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.1.1.1.1.1
	MLWorks_10r3:1.1.1.1.3
	MLWorks_10r2_551:1.1.1.1.2
	MLWorks_11:1.1.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.1.1
	MLWorks_20m0_1997_06_20:1.1
	MLWorks_1_0_r2c2_1997_06_14:1.1.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.1
	MLWorks_BugFix_1997_04_24:1.1;
locks; strict;
comment	@# @;


1.2
date	97.11.25.19.27.26;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	97.04.15.13.19.16;	author andreww;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.05.13.10.22.51;	author hope;	state Exp;
branches
	1.1.1.1.1.1
	1.1.1.1.2.1
	1.1.1.1.3.1;
next	;

1.1.1.1.1.1
date	97.07.28.18.49.22;	author daveb;	state Exp;
branches
	1.1.1.1.1.1.1.1;
next	;

1.1.1.1.1.1.1.1
date	97.10.07.12.13.56;	author jkbrook;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	97.09.08.17.41.03;	author daveb;	state Exp;
branches;
next	;

1.1.1.1.3.1
date	97.09.09.14.40.29;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
[Bug #2043]
answer.
@


1.2
log
@[Bug #30323]
@
text
@val it : string = "test succeeded"
@


1.1
log
@new unit
[Bug #2043]
answer.
@
text
@a0 146
val it : unit = ()
structure Int =
  struct
    eqtype int = int
    val * : (int * int) -> int = fn
    val + : (int * int) -> int = fn
    val - : (int * int) -> int = fn
    val < : (int * int) -> bool = fn
    val <= : (int * int) -> bool = fn
    val > : (int * int) -> bool = fn
    val >= : (int * int) -> bool = fn
    val abs : int -> int = fn
    val compare : (int * int) -> order = fn
    val div : (int * int) -> int = fn
    val fmt : radix(hidden) -> int -> string = fn
    val fromInt : int -> int = fn
    val fromLarge : MLWorks.Internal.Types.int32 -> int = fn
    val fromString : string -> int option = fn
    val max : (int * int) -> int = fn
    val maxInt : int option = SOME 536870911
    val min : (int * int) -> int = fn
    val minInt : int option = SOME ~536870912
    val mod : (int * int) -> int = fn
    val precision : int option = SOME 30
    val quot : (int * int) -> int = fn
    val rem : (int * int) -> int = fn
    val sameSign : (int * int) -> bool = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (int * 'a) option = fn
    val sign : int -> int = fn
    val toInt : int -> int = fn
    val toLarge : int -> MLWorks.Internal.Types.int32 = fn
    val toString : int -> string = fn
    val ~ : int -> int = fn
  end
val it : unit = ()
structure LargeWord =
  struct
    eqtype word = word32
    val * : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val + : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val - : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val < : (LargeWord.word * LargeWord.word) -> bool = fn
    val << : (LargeWord.word * word) -> LargeWord.word = fn
    val <= : (LargeWord.word * LargeWord.word) -> bool = fn
    val > : (LargeWord.word * LargeWord.word) -> bool = fn
    val >= : (LargeWord.word * LargeWord.word) -> bool = fn
    val >> : (LargeWord.word * word) -> LargeWord.word = fn
    val andb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val compare : (LargeWord.word * LargeWord.word) -> order = fn
    val div : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val fmt : radix(hidden) -> LargeWord.word -> string = fn
    val fromInt : int -> LargeWord.word = fn
    val fromLargeInt : MLWorks.Internal.Types.int32 -> LargeWord.word = fn
    val fromLargeWord : LargeWord.word -> LargeWord.word = fn
    val fromString : string -> LargeWord.word option = fn
    val max : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val min : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val mod : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val notb : LargeWord.word -> LargeWord.word = fn
    val orb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option = fn
    val toInt : LargeWord.word -> int = fn
    val toIntX : LargeWord.word -> int = fn
    val toLargeInt : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeIntX : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeWord : LargeWord.word -> LargeWord.word = fn
    val toLargeWordX : LargeWord.word -> LargeWord.word = fn
    val toString : LargeWord.word -> string = fn
    val wordSize : int = 32
    val xorb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val ~>> : (LargeWord.word * word) -> LargeWord.word = fn
  end
structure SysWord =
  struct
    eqtype word = word32
    val * : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val + : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val - : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val < : (LargeWord.word * LargeWord.word) -> bool = fn
    val << : (LargeWord.word * word) -> LargeWord.word = fn
    val <= : (LargeWord.word * LargeWord.word) -> bool = fn
    val > : (LargeWord.word * LargeWord.word) -> bool = fn
    val >= : (LargeWord.word * LargeWord.word) -> bool = fn
    val >> : (LargeWord.word * word) -> LargeWord.word = fn
    val andb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val compare : (LargeWord.word * LargeWord.word) -> order = fn
    val div : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val fmt : radix(hidden) -> LargeWord.word -> string = fn
    val fromInt : int -> LargeWord.word = fn
    val fromLargeInt : MLWorks.Internal.Types.int32 -> LargeWord.word = fn
    val fromLargeWord : LargeWord.word -> LargeWord.word = fn
    val fromString : string -> LargeWord.word option = fn
    val max : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val min : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val mod : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val notb : LargeWord.word -> LargeWord.word = fn
    val orb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option = fn
    val toInt : LargeWord.word -> int = fn
    val toIntX : LargeWord.word -> int = fn
    val toLargeInt : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeIntX : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeWord : LargeWord.word -> LargeWord.word = fn
    val toLargeWordX : LargeWord.word -> LargeWord.word = fn
    val toString : LargeWord.word -> string = fn
    val wordSize : int = 32
    val xorb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val ~>> : (LargeWord.word * word) -> LargeWord.word = fn
  end
structure Word32 =
  struct
    eqtype word = word32
    val * : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val + : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val - : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val < : (LargeWord.word * LargeWord.word) -> bool = fn
    val << : (LargeWord.word * word) -> LargeWord.word = fn
    val <= : (LargeWord.word * LargeWord.word) -> bool = fn
    val > : (LargeWord.word * LargeWord.word) -> bool = fn
    val >= : (LargeWord.word * LargeWord.word) -> bool = fn
    val >> : (LargeWord.word * word) -> LargeWord.word = fn
    val andb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val compare : (LargeWord.word * LargeWord.word) -> order = fn
    val div : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val fmt : radix(hidden) -> LargeWord.word -> string = fn
    val fromInt : int -> LargeWord.word = fn
    val fromLargeInt : MLWorks.Internal.Types.int32 -> LargeWord.word = fn
    val fromLargeWord : LargeWord.word -> LargeWord.word = fn
    val fromString : string -> LargeWord.word option = fn
    val max : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val min : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val mod : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val notb : LargeWord.word -> LargeWord.word = fn
    val orb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option = fn
    val toInt : LargeWord.word -> int = fn
    val toIntX : LargeWord.word -> int = fn
    val toLargeInt : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeIntX : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeWord : LargeWord.word -> LargeWord.word = fn
    val toLargeWordX : LargeWord.word -> LargeWord.word = fn
    val toString : LargeWord.word -> string = fn
    val wordSize : int = 32
    val xorb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val ~>> : (LargeWord.word * word) -> LargeWord.word = fn
  end
@


1.1.1.1
log
@branched from 1.1
@
text
@@


1.1.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.1.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.1.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.1.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@
