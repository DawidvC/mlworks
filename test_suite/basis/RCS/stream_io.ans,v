head	1.21;
access;
symbols
	MLWorks_21c0_1999_03_25:1.21
	MLWorks_20c1_1998_08_20:1.21
	MLWorks_20c0_1998_08_04:1.21
	MLWorks_20b2c2_1998_06_19:1.21
	MLWorks_20b2_Windows_1998_06_12:1.21
	MLWorks_20b1c1_1998_05_07:1.21
	MLWorks_20b0_1998_04_07:1.21
	MLWorks_20b0_1998_03_20:1.21
	MLWorks_20m2_1998_02_16:1.21
	MLWorks_20m1_1997_10_23:1.19
	MLWorks_11r1:1.18.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.18.1.1.1.1
	MLWorks_10r3:1.18.1.1.3
	MLWorks_10r2_551:1.18.1.1.2
	MLWorks_11:1.18.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.18.1.1
	MLWorks_20m0_1997_06_20:1.18
	MLWorks_1_0_r2c2_1997_06_14:1.18.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.18.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.18.1
	MLWorks_BugFix_1997_04_24:1.18
	MLWorks_1_0_r2_Win32_1997_04_11:1.18
	MLWorks_1_0_r2_Unix_1997_04_04:1.18
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.3.1.1
	MLWorks_gui_1996_12_18:1.15.4
	MLWorks_1_0_Win32_1996_12_17:1.15.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.1.1
	MLWorks_1_0_Irix_1996_11_28:1.15.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.2
	MLWorks_1_0_Unix_1996_11_14:1.15.1
	MLWorks_Open_Beta2_1996_10_11:1.14.2
	MLWorks_License_dev:1.14.1
	MLWorks_1_open_beta_1996_09_13:1.13.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.3;
locks; strict;
comment	@# @;


1.21
date	98.01.30.12.21.04;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	97.11.25.19.24.33;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	97.08.05.09.50.08;	author brucem;	state Exp;
branches;
next	1.18;

1.18
date	97.03.24.14.14.13;	author andreww;	state Exp;
branches
	1.18.1.1;
next	1.17;

1.17
date	97.02.26.12.34.02;	author andreww;	state Exp;
branches;
next	1.16;

1.16
date	97.01.30.16.04.49;	author andreww;	state Exp;
branches;
next	1.15;

1.15
date	96.11.08.15.28.21;	author matthew;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1;
next	1.14;

1.14
date	96.10.01.12.56.58;	author io;	state Exp;
branches
	1.14.1.1
	1.14.2.1;
next	1.13;

1.13
date	96.09.09.11.14.01;	author io;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	96.09.07.00.02.26;	author io;	state Exp;
branches;
next	1.11;

1.11
date	96.08.29.00.07.59;	author stephenb;	state Exp;
branches;
next	1.10;

1.10
date	96.08.27.09.36.06;	author andreww;	state Exp;
branches;
next	1.9;

1.9
date	96.08.23.08.56.50;	author andreww;	state Exp;
branches;
next	1.8;

1.8
date	96.08.14.11.52.29;	author io;	state Exp;
branches;
next	1.7;

1.7
date	96.07.18.15.47.39;	author andreww;	state Exp;
branches;
next	1.6;

1.6
date	96.07.17.09.18.47;	author andreww;	state Exp;
branches;
next	1.5;

1.5
date	96.07.05.13.31.21;	author andreww;	state Exp;
branches;
next	1.4;

1.4
date	96.07.03.11.07.42;	author andreww;	state Exp;
branches;
next	1.3;

1.3
date	96.07.02.09.32.38;	author andreww;	state Exp;
branches;
next	1.2;

1.2
date	96.06.25.10.15.43;	author io;	state Exp;
branches;
next	1.1;

1.1
date	96.06.11.11.21.32;	author andreww;	state Exp;
branches;
next	;

1.13.1.1
date	96.09.13.11.38.30;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	96.10.07.16.29.52;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.10.17.11.50.33;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.11.14.13.17.59;	author hope;	state Exp;
branches
	1.15.1.1.1.1;
next	;

1.15.1.1.1.1
date	96.11.28.15.28.29;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.11.22.18.35.46;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.12.17.18.14.45;	author hope;	state Exp;
branches
	1.15.3.1.1.1;
next	;

1.15.3.1.1.1
date	97.02.24.12.07.43;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.12.18.10.09.44;	author hope;	state Exp;
branches;
next	;

1.18.1.1
date	97.05.12.11.08.22;	author hope;	state Exp;
branches
	1.18.1.1.1.1
	1.18.1.1.2.1
	1.18.1.1.3.1;
next	;

1.18.1.1.1.1
date	97.07.28.18.50.21;	author daveb;	state Exp;
branches
	1.18.1.1.1.1.1.1;
next	;

1.18.1.1.1.1.1.1
date	97.10.07.12.14.30;	author jkbrook;	state Exp;
branches;
next	;

1.18.1.1.2.1
date	97.09.08.17.42.11;	author daveb;	state Exp;
branches;
next	;

1.18.1.1.3.1
date	97.09.09.14.41.37;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Answer file for the tests for stream IO.
@


1.21
log
@[Bug #30330]
Modify answers now that type info correct in object files
@
text
@test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
val amy : TextIO.StreamIO.outstream = Out {data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), name="Amy", pos=ref(0), writer=ref(PUTmore WR {block=NONE, canOutput=SOME .., chunkSize=20, close=fn, endPos=SOME .., getPos=SOME .., ioDesc=NONE, name="Amy", setPos=SOME .., verifyPos=NONE, writeArr=SOME .., writeArrNB=SOME .., writeVec=SOME .., writeVecNB=SOME ..})}
val arthur : TextIO.StreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=false, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=0}
val benjamin : TextIO.StreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=5}
val colin : TextIO.StreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=5}
val comm_medium : string ref = ref("Yes, ")
val dave : TextIO.StreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=5}
val pos : int ref = ref(5)
val r : TextPrimIO.reader = RD {avail=fn, block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Arthur", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=SOME fn, verifyPos=NONE}
val reportOK : bool -> unit = fn
val s1 : string = "One T"
val s2 : string = "wo Th"
val s3 : string = "ree\n1Four Five Six\nSeven Eight Nine."
val test1 : (string * TextIO.StreamIO.instream) = ("One T", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test2 : (string * TextIO.StreamIO.instream) = ("One T", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test3 : (string * TextIO.StreamIO.instream) = ("wo Th", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test4 : (string * TextIO.StreamIO.instream) = ("One T", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test5 : string = "ree\n1Four Five Six\nSeven Eight Nine."
val test6 : (string * TextIO.StreamIO.instream) = ("wo Th", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val text2 : bool = true
val the_answer : string = "One Two Three\n1Four Five Six\nSeven Eight Nine."
val w : TextPrimIO.writer = WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Amy", setPos=SOME fn, verifyPos=NONE, writeArr=NONE, writeArrNB=NONE, writeVec=SOME fn, writeVecNB=NONE}
val x : unit = ()
@


1.20
log
@[Bug #30323]
@
text
@d11 4
a14 4
val amy : TextIO.StreamIO.outstream = Out _
val arthur : TextIO.StreamIO.instream = In _
val benjamin : TextIO.StreamIO.instream = In _
val colin : TextIO.StreamIO.instream = In _
d16 1
a16 1
val dave : TextIO.StreamIO.instream = In _
d18 1
a18 1
val r : TextPrimIO.reader = RD _
d23 4
a26 4
val test1 : (string * TextIO.StreamIO.instream) = ("One T", In _)
val test2 : (string * TextIO.StreamIO.instream) = ("One T", In _)
val test3 : (string * TextIO.StreamIO.instream) = ("wo Th", In _)
val test4 : (string * TextIO.StreamIO.instream) = ("One T", In _)
d28 1
a28 1
val test6 : (string * TextIO.StreamIO.instream) = ("wo Th", In _)
d31 1
a31 1
val w : TextPrimIO.writer = WR _
@


1.19
log
@[Bug #30004]
Reflect changes in sml file.
@
text
@a0 9
structure General = struct ... end
structure Char = struct ... end
structure CharVector = struct ... end
structure CharArray = struct ... end
structure OSPrimIO = struct ... end
structure BinPrimIO = struct ... end
structure TextPrimIO = struct ... end
structure TextStreamIO = struct ... end
structure IO = struct ... end
d11 4
a14 4
val amy : TextStreamIO.outstream = Out {data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), name="Amy", pos=ref(0), writer=ref(PUTmore WR {block=NONE, canOutput=SOME .., chunkSize=20, close=fn, endPos=SOME .., getPos=SOME .., ioDesc=NONE, name="Amy", setPos=SOME .., verifyPos=NONE, writeArr=SOME .., writeArrNB=SOME .., writeVec=SOME .., writeVecNB=SOME ..})}
val arthur : TextStreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=false, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=0}
val benjamin : TextStreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=5}
val colin : TextStreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=5}
d16 1
a16 1
val dave : TextStreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=5}
d18 1
a18 1
val r : OSPrimIO.text_reader = RD {avail=fn, block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Arthur", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=SOME fn, verifyPos=NONE}
d23 4
a26 4
val test1 : (string * TextStreamIO.instream) = ("One T", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test2 : (string * TextStreamIO.instream) = ("One T", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test3 : (string * TextStreamIO.instream) = ("wo Th", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test4 : (string * TextStreamIO.instream) = ("One T", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
d28 1
a28 1
val test6 : (string * TextStreamIO.instream) = ("wo Th", In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
d31 1
a31 1
val w : OSPrimIO.text_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Amy", setPos=SOME fn, verifyPos=NONE, writeArr=NONE, writeArrNB=NONE, writeVec=SOME fn, writeVecNB=NONE}
@


1.18
log
@[Bug #1960]
upating.
@
text
@d1 9
a9 246
val it : unit = ()
structure General =
  struct
    type exn = exn
    datatype 'a option =
      NONE |
      SOME of 'a
    datatype order =
      EQUAL |
      GREATER |
      LESS
    eqtype unit = unit
    val ! : 'a ref -> 'a = fn
    val := : ('a ref * 'a) -> unit = fn
    val <> : (''a * ''a) -> bool = fn
    exception Bind
    exception Chr
    exception Div
    exception Domain
    val EQUAL : order
    exception Fail of string
    val GREATER : order
    val LESS : order
    exception Match
    val NONE : 'a option
    exception Option
    exception Overflow
    val SOME : 'a -> 'a option
    exception Size
    exception Subscript
    val before : ('a * unit) -> 'a = fn
    val exnMessage : exn -> string = fn
    val exnName : exn -> string = fn
    val getOpt : ('a option * 'a) -> 'a = fn
    val ignore : 'a -> unit = fn
    val isSome : 'a option -> bool = fn
    val o : (('a -> 'b) * ('c -> 'a)) -> 'c -> 'b = fn
    val valOf : 'a option -> 'a = fn
  end
val it : unit = ()
structure Char =
  struct
    eqtype char = char
    eqtype string = string
    val < : (char * char) -> bool = fn
    val <= : (char * char) -> bool = fn
    val > : (char * char) -> bool = fn
    val >= : (char * char) -> bool = fn
    val chr : int -> char = fn
    val compare : (char * char) -> order = fn
    val contains : string -> char -> bool = fn
    val fromCString : string -> char option = fn
    val fromString : string -> char option = fn
    val isAlpha : char -> bool = fn
    val isAlphaNum : char -> bool = fn
    val isAscii : char -> bool = fn
    val isCntrl : char -> bool = fn
    val isDigit : char -> bool = fn
    val isGraph : char -> bool = fn
    val isHexDigit : char -> bool = fn
    val isLower : char -> bool = fn
    val isPrint : char -> bool = fn
    val isPunct : char -> bool = fn
    val isSpace : char -> bool = fn
    val isUpper : char -> bool = fn
    val maxChar : char = #"\255"
    val maxOrd : int = 255
    val minChar : char = #"\000"
    val notContains : string -> char -> bool = fn
    val ord : char -> int = fn
    val pred : char -> char = fn
    val scan : ('a -> (char * 'a) option) -> 'a -> (char * 'a) option = fn
    val succ : char -> char = fn
    val toCString : char -> string = fn
    val toLower : char -> char = fn
    val toString : char -> string = fn
    val toUpper : char -> char = fn
  end
val it : unit = ()
structure CharVector =
  struct
    eqtype elem = char
    eqtype vector = string
    val app : (char -> unit) -> string -> unit = fn
    val appi : ((int * char) -> unit) -> (string * int * int option) -> unit = fn
    val concat : string list -> string = fn
    val extract : (string * int * int option) -> string = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
    val fromList : char list -> string = fn
    val length : string -> int = fn
    val maxLen : int = 16777196
    val sub : (string * int) -> char = fn
    val tabulate : (int * (int -> char)) -> string = fn
  end
val it : unit = ()
structure CharArray =
  struct
    structure Vector =
      struct
        eqtype elem = char
        eqtype vector = string
        val app : (char -> unit) -> string -> unit = fn
        val appi : ((int * char) -> unit) -> (string * int * int option) -> unit = fn
        val concat : string list -> string = fn
        val extract : (string * int * int option) -> string = fn
        val foldl : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
        val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
        val foldr : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
        val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
        val fromList : char list -> string = fn
        val length : string -> int = fn
        val maxLen : int = 16777196
        val sub : (string * int) -> char = fn
        val tabulate : (int * (int -> char)) -> string = fn
      end
    eqtype array = array
    eqtype elem = char
    val app : (char -> unit) -> CharArray.array -> unit = fn
    val appi : ((int * char) -> unit) -> (CharArray.array * int * int option) -> unit = fn
    val array : (int * char) -> CharArray.array = fn
    val copy : {di: int, dst: CharArray.array, len: int option, si: int, src: CharArray.array} -> unit = fn
    val copyVec : {di: int, dst: CharArray.array, len: int option, si: int, src: string} -> unit = fn
    val extract : (CharArray.array * int * int option) -> string = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> CharArray.array -> 'a = fn
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int option) -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> CharArray.array -> 'a = fn
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int option) -> 'a = fn
    val fromList : char list -> CharArray.array = fn
    val length : CharArray.array -> int = fn
    val maxLen : int = 16777196
    val modify : (char -> char) -> CharArray.array -> unit = fn
    val modifyi : ((int * char) -> char) -> (CharArray.array * int * int option) -> unit = fn
    val sub : (CharArray.array * int) -> char = fn
    val tabulate : (int * (int -> char)) -> CharArray.array = fn
    val update : (CharArray.array * int * char) -> unit = fn
  end
val it : unit = ()
structure OSPrimIO =
  struct
    type bin_reader = reader
    type bin_writer = writer
    eqtype file_desc = file_desc
    type text_reader = reader
    type text_writer = writer
    val openApp : string -> OSPrimIO.bin_writer = fn
    val openRd : string -> OSPrimIO.bin_reader = fn
    val openString : string -> OSPrimIO.text_reader = fn
    val openWr : string -> OSPrimIO.bin_writer = fn
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=NONE, getPos=SOME fn, ioDesc=NONE, name="<stdOut>", setPos=SOME fn, verifyPos=SOME fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : OSPrimIO.bin_reader = RD {avail=fn, block=NONE, canInput=SOME fn, chunkSize=1, close=fn, endPos=NONE, getPos=SOME fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=SOME fn, verifyPos=SOME fn}
    val stdOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=NONE, getPos=SOME fn, ioDesc=NONE, name="<stdOut>", setPos=SOME fn, verifyPos=SOME fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val translateIn : OSPrimIO.bin_reader -> OSPrimIO.text_reader = fn
    val translateOut : OSPrimIO.bin_writer -> OSPrimIO.text_writer = fn
  end
val it : unit = ()
structure BinPrimIO =
  struct
    eqtype array = array
    eqtype elem = word8
    eqtype pos = int
    datatype reader =
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
    type vector = vector
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> BinPrimIO.vector) option, readVecNB: (int -> BinPrimIO.vector option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
    val augmentReader : BinPrimIO.reader -> BinPrimIO.reader = fn
    val augmentWriter : BinPrimIO.writer -> BinPrimIO.writer = fn
    val compare : (int * int) -> order = fn
  end
val it : unit = ()
structure TextPrimIO =
  struct
    eqtype array = array
    eqtype elem = char
    eqtype pos = int
    datatype reader =
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
    eqtype vector = string
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
    val augmentReader : OSPrimIO.text_reader -> OSPrimIO.text_reader = fn
    val augmentWriter : OSPrimIO.text_writer -> OSPrimIO.text_writer = fn
    val compare : (int * int) -> order = fn
  end
val it : unit = ()
structure TextStreamIO =
  struct
    eqtype elem = char
    type in_pos = in_pos
    type instream = instream
    type out_pos = out_pos
    eqtype outstream = outstream
    eqtype pos = int
    type reader = reader
    eqtype vector = string
    type writer = writer
    val canInput : (TextStreamIO.instream * int) -> int option = fn
    val closeIn : TextStreamIO.instream -> unit = fn
    val closeOut : TextStreamIO.outstream -> unit = fn
    val endOfStream : TextStreamIO.instream -> bool = fn
    val filePosIn : TextStreamIO.in_pos -> int = fn
    val filePosOut : TextStreamIO.out_pos -> int = fn
    val flushOut : TextStreamIO.outstream -> unit = fn
    val getBufferMode : TextStreamIO.outstream -> buffer_mode(hidden) = fn
    val getPosIn : TextStreamIO.instream -> TextStreamIO.in_pos = fn
    val getPosOut : TextStreamIO.outstream -> TextStreamIO.out_pos = fn
    val getReader : TextStreamIO.instream -> (OSPrimIO.text_reader * string) = fn
    val getWriter : TextStreamIO.outstream -> (OSPrimIO.text_writer * buffer_mode(hidden)) = fn
    val input : TextStreamIO.instream -> (string * TextStreamIO.instream) = fn
    val input1 : TextStreamIO.instream -> (char * TextStreamIO.instream) option = fn
    val inputAll : TextStreamIO.instream -> string = fn
    val inputLine : TextStreamIO.instream -> (string * TextStreamIO.instream) = fn
    val inputN : (TextStreamIO.instream * int) -> (string * TextStreamIO.instream) = fn
    val mkInstream : (OSPrimIO.text_reader * string) -> TextStreamIO.instream = fn
    val mkOutstream : (OSPrimIO.text_writer * buffer_mode(hidden)) -> TextStreamIO.outstream = fn
    val output : (TextStreamIO.outstream * string) -> unit = fn
    val output1 : (TextStreamIO.outstream * char) -> unit = fn
    val outputSubstr : (TextStreamIO.outstream * substring(hidden)) -> unit = fn
    val setBufferMode : (TextStreamIO.outstream * buffer_mode(hidden)) -> unit = fn
    val setPosIn : TextStreamIO.in_pos -> TextStreamIO.instream = fn
    val setPosOut : TextStreamIO.out_pos -> TextStreamIO.outstream = fn
  end
val it : unit = ()
structure IO =
  struct
    datatype buffer_mode =
      BLOCK_BUF |
      LINE_BUF |
      NO_BUF
    val BLOCK_BUF : IO.buffer_mode
    exception BlockingNotSupported
    exception ClosedStream
    exception Io of {cause: exn, function: string, name: string}
    val LINE_BUF : IO.buffer_mode
    val NO_BUF : IO.buffer_mode
    exception NonblockingNotSupported
    exception RandomAccessNotSupported
    exception TerminatedStream
  end
@


1.18.1.1
log
@branched from 1.18
@
text
@@


1.18.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.18.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.18.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.18.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.17
log
@[Bug #1759]
recompiling
changes owing to new TEXT_STREAM_IO signature.
@
text
@d152 1
a152 1
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="<stdOut>", setPos=SOME fn, verifyPos=SOME fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
@


1.16
log
@[Bug #1904]
mono vectors no longer equality types
@
text
@a192 35
structure BinStreamIO =
  struct
    eqtype elem = word8
    type in_pos = in_pos
    type instream = instream
    type out_pos = out_pos
    eqtype outstream = outstream
    eqtype pos = int
    type reader = reader
    type vector = vector
    type writer = writer
    val canInput : (BinStreamIO.instream * int) -> int option = fn
    val closeIn : BinStreamIO.instream -> unit = fn
    val closeOut : BinStreamIO.outstream -> unit = fn
    val endOfStream : BinStreamIO.instream -> bool = fn
    val filePosIn : BinStreamIO.in_pos -> int = fn
    val filePosOut : BinStreamIO.out_pos -> int = fn
    val flushOut : BinStreamIO.outstream -> unit = fn
    val getBufferMode : BinStreamIO.outstream -> buffer_mode(hidden) = fn
    val getPosIn : BinStreamIO.instream -> BinStreamIO.in_pos = fn
    val getPosOut : BinStreamIO.outstream -> BinStreamIO.out_pos = fn
    val getReader : BinStreamIO.instream -> (BinPrimIO.reader * BinPrimIO.vector) = fn
    val getWriter : BinStreamIO.outstream -> (BinPrimIO.writer * buffer_mode(hidden)) = fn
    val input : BinStreamIO.instream -> (BinPrimIO.vector * BinStreamIO.instream) = fn
    val input1 : BinStreamIO.instream -> (BinPrimIO.elem * BinStreamIO.instream) option = fn
    val inputAll : BinStreamIO.instream -> BinPrimIO.vector = fn
    val inputN : (BinStreamIO.instream * int) -> (BinPrimIO.vector * BinStreamIO.instream) = fn
    val mkInstream : (BinPrimIO.reader * BinPrimIO.vector) -> BinStreamIO.instream = fn
    val mkOutstream : (BinPrimIO.writer * buffer_mode(hidden)) -> BinStreamIO.outstream = fn
    val output : (BinStreamIO.outstream * BinPrimIO.vector) -> unit = fn
    val output1 : (BinStreamIO.outstream * BinPrimIO.elem) -> unit = fn
    val setBufferMode : (BinStreamIO.outstream * buffer_mode(hidden)) -> unit = fn
    val setPosIn : BinStreamIO.in_pos -> BinStreamIO.instream = fn
    val setPosOut : BinStreamIO.out_pos -> BinStreamIO.outstream = fn
  end
d219 1
d225 1
@


1.15
log
@[Bug #1661]
Updating
@
text
@d166 1
a166 1
    eqtype vector = vector
d202 1
a202 1
    eqtype vector = vector
@


1.15.4.1
log
@branched from 1.15
@
text
@@


1.15.3.1
log
@branched from 1.15
@
text
@@


1.15.3.1.1.1
log
@branched from 1.15.3.1
@
text
@@


1.15.2.1
log
@branched from 1.15
@
text
@@


1.15.1.1
log
@branched from 1.15
@
text
@@


1.15.1.1.1.1
log
@branched from 1.15.1.1
@
text
@@


1.14
log
@[Bug #1626]
update option in toCString
@
text
@d165 1
a165 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d168 3
a170 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> BinPrimIO.vector) option, readVecNB: (int -> BinPrimIO.vector option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
d182 1
a182 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d185 3
a187 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
@


1.14.2.1
log
@branched from 1.14
@
text
@@


1.14.1.1
log
@branched from 1.14
@
text
@@


1.13
log
@remove banner
@
text
@d74 1
a74 1
    val toCString : char -> string option = fn
@


1.13.1.1
log
@branched from 1.13
@
text
@@


1.12
log
@updating for commercial version flyer
@
text
@a0 2
commercial version may be purchased directly from Harlequin.

@


1.11
log
@Update wrt change in io_desc type.
@
text
@d1 2
@


1.10
log
@[Bug #1566]
updating.
,
@
text
@d165 1
a165 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d168 3
a170 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> BinPrimIO.vector) option, readVecNB: (int -> BinPrimIO.vector option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
d182 1
a182 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d185 3
a187 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
@


1.9
log
@[Bug #1566]
updating to take into account changes in the basis.
/
@
text
@a1 2
Compiling basis.general
Compiling basis.__general
a40 12
Compiling basis.toplevel
Compiling basis.string_cvt
Compiling basis.__pre_basis
Compiling basis.__pre_string_cvt
Compiling basis.__string_cvt
Compiling basis.char
Compiling basis.__preinteger
Compiling basis.__preint32
Compiling basis.integer
Compiling basis.__integer
Compiling basis.__pre_char
Compiling basis.__char
a79 4
Compiling basis.mono_vector
Compiling basis.list
Compiling basis.__list
Compiling basis.__charvector
a98 2
Compiling basis.mono_array
Compiling basis.__chararray
a140 45
Compiling basis.__preword32
Compiling basis.__preword
Compiling basis.word
Compiling basis.__word
Compiling basis.__word8
Compiling basis.__word8vector
Compiling basis.__word8array
Compiling basis.__position
Compiling basis.math
Compiling basis.__math
Compiling basis.ieeereal
Compiling basis.__ieeereal
Compiling basis.__prereal
Compiling basis.real
Compiling basis.__real
Compiling basis.time
Compiling unix.__time
Compiling basis.os_file_sys
Compiling basis.os_path
Compiling basis.os_process
Compiling basis.os_io
Compiling basis.os
Compiling basis.__word32
Compiling unix.unixos
Compiling unix._os
Compiling unix._unixos
Compiling unix.__unixos
Compiling basis.string
Compiling basis.__string
Compiling unix.__os_path
Compiling unix._os_file_sys
Compiling unix.__os_file_sys
Compiling basis.__exit
Compiling basis.exit
Compiling basis._os_process
Compiling basis.__os_process
Compiling unix._os_io
Compiling unix.__os_io
Compiling unix.__os
Compiling basis.prim_io
Compiling basis.os_prim_io
Compiling basis._prim_io
Compiling basis.__bin_prim_io
Compiling basis.__text_prim_io
Compiling unix.__os_prim_io
a192 5
Compiling basis.io
Compiling basis.__io
Compiling basis.stream_io
Compiling basis._stream_io
Compiling basis.__stream_io
@


1.8
log
@switch off Compiling messages...
@
text
@d2 2
d43 12
d94 4
d117 2
d161 45
d258 5
d360 1
a360 1
val amy : TextStreamIO.outstream = Out {closed=ref(false), data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), name="Amy", pos=ref(0), writer=ref(SOME WR {block=NONE, canOutput=SOME .., chunkSize=20, close=fn, endPos=SOME .., getPos=SOME .., ioDesc=NONE, name="Amy", setPos=SOME .., verifyPos=NONE, writeArr=SOME .., writeArrNB=SOME .., writeVec=SOME .., writeVecNB=SOME ..})}
@


1.7
log
@[Bug #1453]
updating with respect to the updating of revised basis IO library.
@
text
@a1 2
Compiling basis.general
Compiling basis.__general
a40 12
Compiling basis.toplevel
Compiling basis.string_cvt
Compiling basis.__pre_basis
Compiling basis.__pre_string_cvt
Compiling basis.__string_cvt
Compiling basis.char
Compiling basis.__preinteger
Compiling basis.__preint32
Compiling basis.integer
Compiling basis.__integer
Compiling basis.__pre_char
Compiling basis.__char
a79 4
Compiling basis.mono_vector
Compiling basis.list
Compiling basis.__list
Compiling basis.__charvector
a98 2
Compiling basis.mono_array
Compiling basis.__chararray
a140 45
Compiling basis.__preword32
Compiling basis.__preword
Compiling basis.word
Compiling basis.__word
Compiling basis.__word8
Compiling basis.__word8vector
Compiling basis.__word8array
Compiling basis.__position
Compiling basis.math
Compiling basis.__math
Compiling basis.ieeereal
Compiling basis.__ieeereal
Compiling basis.__prereal
Compiling basis.real
Compiling basis.__real
Compiling basis.time
Compiling unix.__time
Compiling basis.os_file_sys
Compiling basis.os_path
Compiling basis.os_process
Compiling basis.os_io
Compiling basis.os
Compiling basis.__word32
Compiling unix.unixos
Compiling unix._os
Compiling unix._unixos
Compiling unix.__unixos
Compiling basis.string
Compiling basis.__string
Compiling unix.__os_path
Compiling unix._os_file_sys
Compiling unix.__os_file_sys
Compiling basis.__exit
Compiling basis.exit
Compiling basis._os_process
Compiling basis.__os_process
Compiling unix._os_io
Compiling unix.__os_io
Compiling unix.__os
Compiling basis.prim_io
Compiling basis.os_prim_io
Compiling basis._prim_io
Compiling basis.__bin_prim_io
Compiling basis.__text_prim_io
Compiling unix.__os_prim_io
d166 1
a166 1
    eqtype vector = string
d169 2
a170 2
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
a192 5
Compiling basis.io
Compiling basis.__io
Compiling basis.stream_io
Compiling basis._stream_io
Compiling basis.__stream_io
d202 1
a202 1
    eqtype vector = string
d214 1
a214 1
    val getReader : BinStreamIO.instream -> (BinPrimIO.reader * string) = fn
d216 1
a216 1
    val input : BinStreamIO.instream -> (string * BinStreamIO.instream) = fn
d218 3
a220 3
    val inputAll : BinStreamIO.instream -> string = fn
    val inputN : (BinStreamIO.instream * int) -> (string * BinStreamIO.instream) = fn
    val mkInstream : (BinPrimIO.reader * string) -> BinStreamIO.instream = fn
d222 1
a222 1
    val output : (BinStreamIO.outstream * string) -> unit = fn
@


1.6
log
@updating.
@
text
@d201 2
a202 6
Compiling basis.osprimio
Compiling basis.io
Compiling basis.__io
Compiling basis.stream_io
Compiling basis._streamio
Compiling basis._primio
d205 1
a205 1
Compiling unix.__primio
d215 1
d217 3
a219 3
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : OSPrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val stdOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
d230 1
a230 1
      RD of {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: pos -> unit}
d233 3
a235 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, setPos: pos -> unit, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: int -> unit} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: OSPrimIO.file_desc option, name: string, setPos: int -> unit, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
d247 1
a247 1
      RD of {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: pos -> unit}
d250 3
a252 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, setPos: pos -> unit, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: int -> unit} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: OSPrimIO.file_desc option, name: string, setPos: int -> unit, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
d258 4
d266 1
d268 1
d270 1
d278 2
d282 2
d295 2
d301 1
d303 1
d305 1
d313 2
d317 2
d330 2
d347 1
d360 4
a363 4
val amy : TextStreamIO.outstream = Out {closed=ref(false), data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), name="Amy", pos=ref(0), writer=ref(SOME WR {block=NONE, canOutput=SOME .., chunkSize=20, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Amy", setPos=fn, writeArr=SOME .., writeArrNB=SOME .., writeVec=SOME .., writeVecNB=SOME ..})}
val arthur : TextStreamIO.instream = In {buffer=Buf {basePos=_, data=_, emptyMeansEof=false, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=0}
val benjamin : TextStreamIO.instream = In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=5}
val colin : TextStreamIO.instream = In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=5}
d365 1
a365 1
val dave : TextStreamIO.instream = In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(Buf ..)), name="Arthur"}, pos=5}
d367 1
a367 1
val r : OSPrimIO.text_reader = RD {block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Arthur", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=fn}
d372 4
a375 4
val test1 : (string * TextStreamIO.instream) = ("One T", In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test2 : (string * TextStreamIO.instream) = ("One T", In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test3 : (string * TextStreamIO.instream) = ("wo Th", In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val test4 : (string * TextStreamIO.instream) = ("One T", In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
d377 1
a377 1
val test6 : (string * TextStreamIO.instream) = ("wo Th", In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
d380 1
a380 1
val w : OSPrimIO.text_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Amy", setPos=fn, writeArr=NONE, writeArrNB=NONE, writeVec=SOME fn, writeVecNB=NONE}
@


1.5
log
@updating.
@
text
@a216 3
    val guiErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val guiIn : OSPrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val guiOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
d220 3
a222 3
    val terminalErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val terminalIn : OSPrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val terminalOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
@


1.4
log
@making consistent with previous answer files.
new general files.
@
text
@d44 1
a45 1
Compiling basis.string_cvt
d53 1
a62 2
    exception Dummy of char
    exception ToString of char
a75 1
    val isOctDigit : char -> bool = fn
a79 1
    val makestring : char -> string = fn
a86 1
    val scanc : ('a -> (char * 'a) option) -> 'a -> (char * 'a) option = fn
@


1.3
log
@updating --- recently added extra fields to output buffers.
@
text
@d2 1
d221 3
d227 3
a229 3
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : OSPrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val stdOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
@


1.2
log
@add __pre_char again
@
text
@a1 1
Compiling basis.general
d21 1
a21 1
    val EQUAL : General.order
d23 2
a24 2
    val GREATER : General.order
    val LESS : General.order
d26 1
a26 1
    val NONE : 'a General.option
d29 1
a29 1
    val SOME : 'a -> 'a General.option
d35 1
a35 1
    val getOpt : ('a General.option * 'a) -> 'a = fn
d37 1
a37 1
    val isSome : 'a General.option -> bool = fn
d39 1
a39 1
    val valOf : 'a General.option -> 'a = fn
d43 1
a44 1
Compiling basis.__pre_basis
a51 1
Compiling basis.__pre_char
d61 2
d64 1
a64 1
    val compare : (char * char) -> General.order = fn
d66 2
a67 2
    val fromCString : string -> char General.option = fn
    val fromString : string -> char General.option = fn
d76 1
d81 1
d88 2
a89 1
    val scan : ('a -> (char * 'a) General.option) -> 'a -> (char * 'a) General.option = fn
d91 1
a91 1
    val toCString : char -> string General.option = fn
d106 1
a106 1
    val appi : ((int * char) -> unit) -> (string * int * int General.option) -> unit = fn
d108 1
a108 1
    val extract : (string * int * int General.option) -> string = fn
d110 1
a110 1
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
d112 1
a112 1
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
d129 1
a129 1
        val appi : ((int * char) -> unit) -> (string * int * int General.option) -> unit = fn
d131 1
a131 1
        val extract : (string * int * int General.option) -> string = fn
d133 1
a133 1
        val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
d135 1
a135 1
        val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
d145 1
a145 1
    val appi : ((int * char) -> unit) -> (CharArray.array * int * int General.option) -> unit = fn
d147 3
a149 3
    val copy : {di: int, dst: CharArray.array, len: int General.option, si: int, src: CharArray.array} -> unit = fn
    val copyVec : {di: int, dst: CharArray.array, len: int General.option, si: int, src: string} -> unit = fn
    val extract : (CharArray.array * int * int General.option) -> string = fn
d151 1
a151 1
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int General.option) -> 'a = fn
d153 1
a153 1
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int General.option) -> 'a = fn
d158 1
a158 1
    val modifyi : ((int * char) -> char) -> (CharArray.array * int * int General.option) -> unit = fn
d204 1
a204 1
Compiling basis._primio
d209 1
d213 1
a213 1
structure PrimIO =
d220 8
a227 10
    val mkReader : {fd: PrimIO.file_desc, initialBlockMode: bool, initialPos: int, name: string} -> PrimIO.bin_reader = fn
    val mkWriter : {blocksize: int, fd: PrimIO.file_desc, initialBlockMode: bool, initialPos: int, name: string, size: int} -> PrimIO.bin_writer = fn
    val openApp : string -> PrimIO.bin_writer = fn
    val openRd : string -> PrimIO.bin_reader = fn
    val openWr : string -> PrimIO.bin_writer = fn
    val stdErr : PrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : PrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val stdOut : PrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val translateIn : 'a -> 'b = fn
    val translateOut : 'a -> 'b = fn
d240 2
a241 2
    val RD : {block: (unit -> unit) General.option, canInput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int) General.option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int General.option) General.option, readVec: (int -> string) General.option, readVecNB: (int -> string General.option) General.option, setPos: int -> unit} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) General.option, canOutput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, setPos: int -> unit, writeArr: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int) General.option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int General.option) General.option, writeVec: ({buf: string, i: int, sz: int General.option} -> int) General.option, writeVecNB: ({buf: string, i: int, sz: int General.option} -> int General.option) General.option} -> BinPrimIO.writer
d244 1
a244 1
    val compare : (int * int) -> General.order = fn
d257 5
a261 5
    val RD : {block: (unit -> unit) General.option, canInput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int General.option} -> int) General.option, readArrNB: ({buf: CharArray.array, i: int, sz: int General.option} -> int General.option) General.option, readVec: (int -> string) General.option, readVecNB: (int -> string General.option) General.option, setPos: int -> unit} -> PrimIO.text_reader
    val WR : {block: (unit -> unit) General.option, canOutput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, setPos: int -> unit, writeArr: ({buf: CharArray.array, i: int, sz: int General.option} -> int) General.option, writeArrNB: ({buf: CharArray.array, i: int, sz: int General.option} -> int General.option) General.option, writeVec: ({buf: string, i: int, sz: int General.option} -> int) General.option, writeVecNB: ({buf: string, i: int, sz: int General.option} -> int General.option) General.option} -> PrimIO.text_writer
    val augmentReader : PrimIO.text_reader -> PrimIO.text_reader = fn
    val augmentWriter : PrimIO.text_writer -> PrimIO.text_writer = fn
    val compare : (int * int) -> General.order = fn
d269 1
a269 1
    type outstream = outstream
d273 1
a273 1
    val canInput : (BinStreamIO.instream * int) -> int General.option = fn
d282 1
a282 1
    val input1 : BinStreamIO.instream -> (BinPrimIO.elem * BinStreamIO.instream) General.option = fn
d295 1
a295 1
    type outstream = outstream
d299 1
a299 1
    val canInput : (TextStreamIO.instream * int) -> int General.option = fn
d305 2
a306 2
    val getReader : TextStreamIO.instream -> (PrimIO.text_reader * string) = fn
    val getWriter : TextStreamIO.outstream -> (PrimIO.text_writer * buffer_mode(hidden)) = fn
d308 1
a308 1
    val input1 : TextStreamIO.instream -> (char * TextStreamIO.instream) General.option = fn
d311 2
a312 2
    val mkInstream : (PrimIO.text_reader * string) -> TextStreamIO.instream = fn
    val mkOutstream : (PrimIO.text_writer * buffer_mode(hidden)) -> TextStreamIO.outstream = fn
d343 1
a343 1
val amy : TextStreamIO.outstream = Out {data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), pos=ref(0), writer=WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Amy", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}}
d350 1
a350 1
val r : PrimIO.text_reader = RD {block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Arthur", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=fn}
d363 1
a363 1
val w : PrimIO.text_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Amy", setPos=fn, writeArr=NONE, writeArrNB=NONE, writeVec=SOME fn, writeVecNB=NONE}
@


1.1
log
@new unit
Answer file for the tests for stream IO.
@
text
@d44 1
a45 1
Compiling basis.string_cvt
d53 1
a62 2
    exception Dummy of char
    exception ToString of char
a75 1
    val isOctDigit : char -> bool = fn
a79 1
    val makestring : char -> string = fn
a86 1
    val scanc : ('a -> (char * 'a) General.option) -> 'a -> (char * 'a) General.option = fn
@
