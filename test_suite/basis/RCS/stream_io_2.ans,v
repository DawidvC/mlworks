head	1.14;
access;
symbols
	MLWorks_21c0_1999_03_25:1.14
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.14
	MLWorks_20b2_Windows_1998_06_12:1.14
	MLWorks_20b1c1_1998_05_07:1.14
	MLWorks_20b0_1998_04_07:1.14
	MLWorks_20b0_1998_03_20:1.14
	MLWorks_20m2_1998_02_16:1.14
	MLWorks_20m1_1997_10_23:1.13
	MLWorks_11r1:1.13.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.13.1.1.1.1
	MLWorks_10r3:1.13.1.1.3
	MLWorks_10r2_551:1.13.1.1.2
	MLWorks_11:1.13.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.13.1.1
	MLWorks_20m0_1997_06_20:1.13
	MLWorks_1_0_r2c2_1997_06_14:1.13.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.13.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.13.1
	MLWorks_BugFix_1997_04_24:1.13
	MLWorks_1_0_r2_Win32_1997_04_11:1.13
	MLWorks_1_0_r2_Unix_1997_04_04:1.13
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.9.3.1.1
	MLWorks_gui_1996_12_18:1.9.4
	MLWorks_1_0_Win32_1996_12_17:1.9.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.1.1
	MLWorks_1_0_Irix_1996_11_28:1.9.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.2
	MLWorks_1_0_Unix_1996_11_14:1.9.1
	MLWorks_Open_Beta2_1996_10_11:1.8.2
	MLWorks_License_dev:1.8.1
	MLWorks_1_open_beta_1996_09_13:1.5.1;
locks; strict;
comment	@# @;


1.14
date	97.11.25.19.24.39;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	97.04.02.21.50.05;	author jont;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	97.03.26.17.05.05;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	97.03.05.11.48.12;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	97.02.26.12.35.13;	author andreww;	state Exp;
branches;
next	1.9;

1.9
date	96.11.08.15.29.11;	author matthew;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1;
next	1.8;

1.8
date	96.09.25.09.46.44;	author andreww;	state Exp;
branches
	1.8.1.1
	1.8.2.1;
next	1.7;

1.7
date	96.09.19.10.20.25;	author io;	state Exp;
branches;
next	1.6;

1.6
date	96.09.18.15.20.08;	author io;	state Exp;
branches;
next	1.5;

1.5
date	96.09.09.11.23.28;	author io;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	96.09.07.00.02.28;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.08.28.23.54.55;	author stephenb;	state Exp;
branches;
next	1.2;

1.2
date	96.08.27.09.46.53;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	96.08.23.09.21.53;	author andreww;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.38.21;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.10.07.16.29.40;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.10.17.11.50.24;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.11.14.13.17.48;	author hope;	state Exp;
branches
	1.9.1.1.1.1;
next	;

1.9.1.1.1.1
date	96.11.28.15.28.18;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.11.22.18.35.36;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.12.17.18.14.35;	author hope;	state Exp;
branches
	1.9.3.1.1.1;
next	;

1.9.3.1.1.1
date	97.02.24.12.07.31;	author hope;	state Exp;
branches;
next	;

1.9.4.1
date	96.12.18.10.09.33;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	97.05.12.11.08.09;	author hope;	state Exp;
branches
	1.13.1.1.1.1
	1.13.1.1.2.1
	1.13.1.1.3.1;
next	;

1.13.1.1.1.1
date	97.07.28.18.49.26;	author daveb;	state Exp;
branches
	1.13.1.1.1.1.1.1;
next	;

1.13.1.1.1.1.1.1
date	97.10.07.12.13.58;	author jkbrook;	state Exp;
branches;
next	;

1.13.1.1.2.1
date	97.09.08.17.41.08;	author daveb;	state Exp;
branches;
next	;

1.13.1.1.3.1
date	97.09.09.14.40.34;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
[Bug #1566]
Answer file for stream_io_2.sml
@


1.14
log
@[Bug #30323]
@
text
@val reportOK : bool -> string = fn
val ans1 : string = "test succeeded."
val ans2 : string = "test succeeded."
@


1.13
log
@Modify to stop displaying syserror type
@
text
@a0 4
structure OS = struct ... end
structure TextIO = struct ... end
structure TextPrimIO = struct ... end
structure Substring = struct ... end
@


1.13.1.1
log
@branched from 1.13
@
text
@@


1.13.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.13.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.13.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.13.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.12
log
@[Bug #0]
Revise so stream chunkSize (which is system dependent) doesn't get into the answer
@
text
@d1 4
a4 268
val it : unit = ()
structure OS =
  struct
    structure FileSys =
      struct
        datatype access_mode =
          A_EXEC |
          A_READ |
          A_WRITE
        eqtype dirstream = dirstream
        eqtype file_id = file_id
        val A_EXEC : OS.FileSys.access_mode
        val A_READ : OS.FileSys.access_mode
        val A_WRITE : OS.FileSys.access_mode
        val access : (string * OS.FileSys.access_mode list) -> bool = fn
        val chDir : string -> unit = fn
        val closeDir : OS.FileSys.dirstream -> unit = fn
        val compare : (OS.FileSys.file_id * OS.FileSys.file_id) -> order = fn
        val fileId : string -> OS.FileSys.file_id = fn
        val fileSize : string -> int = fn
        val fullPath : string -> string = fn
        val getDir : unit -> string = fn
        val hash : OS.FileSys.file_id -> word = fn
        val isDir : string -> bool = fn
        val isLink : string -> bool = fn
        val mkDir : string -> unit = fn
        val modTime : string -> time(hidden) = fn
        val openDir : string -> OS.FileSys.dirstream = fn
        val readDir : OS.FileSys.dirstream -> string = fn
        val readLink : string -> string = fn
        val realPath : string -> string = fn
        val remove : string -> unit = fn
        val rename : {new: string, old: string} -> unit = fn
        val rewindDir : OS.FileSys.dirstream -> unit = fn
        val rmDir : string -> unit = fn
        val setTime : (string * time(hidden) option) -> unit = fn
        val tmpName : unit -> string = fn
      end
    structure IO =
      struct
        structure Kind = struct ... end
        eqtype iodesc = iodesc
        eqtype iodesc_kind = iodesc_kind
        eqtype poll_desc = poll_desc
        eqtype poll_info = poll_info
        exception Poll
        val compare : (OS.IO.iodesc * OS.IO.iodesc) -> order = fn
        val hash : OS.IO.iodesc -> word = fn
        val infoToPollDesc : OS.IO.poll_info -> OS.IO.poll_desc = fn
        val isIn : OS.IO.poll_info -> bool = fn
        val isOut : OS.IO.poll_info -> bool = fn
        val isPri : OS.IO.poll_info -> bool = fn
        val kind : OS.IO.iodesc -> OS.IO.iodesc_kind = fn
        val poll : (OS.IO.poll_desc list * time(hidden) option) -> OS.IO.poll_info list = fn
        val pollDesc : OS.IO.iodesc -> OS.IO.poll_desc option = fn
        val pollIn : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollOut : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollPri : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollToIODesc : OS.IO.poll_desc -> OS.IO.iodesc = fn
      end
    structure Path =
      struct
        exception Path
        val base : string -> string = fn
        val concat : (string * string) -> string = fn
        val currentArc : string = "."
        val dir : string -> string = fn
        val ext : string -> string option = fn
        val file : string -> string = fn
        val fromString : string -> {arcs: string list, isAbs: bool, vol: string} = fn
        val fromUnixPath : string -> string = fn
        val getParent : string -> string = fn
        val getVolume : string -> string = fn
        val isAbsolute : string -> bool = fn
        val isCanonical : string -> bool = fn
        val isRelative : string -> bool = fn
        val isRoot : string -> bool = fn
        val joinBaseExt : {base: string, ext: string option} -> string = fn
        val joinDirFile : {dir: string, file: string} -> string = fn
        val mkAbsolute : (string * string) -> string = fn
        val mkCanonical : string -> string = fn
        val mkRelative : (string * string) -> string = fn
        val parentArc : string = ".."
        val splitBaseExt : string -> {base: string, ext: string option} = fn
        val splitDirFile : string -> {dir: string, file: string} = fn
        val toString : {arcs: string list, isAbs: bool, vol: string} -> string = fn
        val toUnixPath : string -> string = fn
        val validVolume : {isAbs: bool, vol: string} -> bool = fn
      end
    structure Process =
      struct
        eqtype status = int
        val atExit : (unit -> unit) -> unit = fn
        val exit : int -> 'a = fn
        val failure : int = 1
        val getEnv : string -> string option = fn
        val success : int = 0
        val system : string -> int = fn
        val terminate : int -> 'a = fn
      end
    eqtype syserror = int
    exception SysErr of (string * syserror option)
    val errorMsg : int -> string = fn
    val errorName : int -> string = fn
    val syserror : string -> int option = fn
  end
val it : unit = ()
structure TextIO =
  struct
    structure StreamIO =
      struct
        eqtype elem = char
        type in_pos = in_pos
        type instream = instream
        type out_pos = out_pos
        eqtype outstream = outstream
        eqtype pos = int
        type reader = reader
        eqtype vector = string
        type writer = writer
        val canInput : (TextIO.StreamIO.instream * int) -> int option = fn
        val closeIn : TextIO.StreamIO.instream -> unit = fn
        val closeOut : TextIO.StreamIO.outstream -> unit = fn
        val endOfStream : TextIO.StreamIO.instream -> bool = fn
        val filePosIn : TextIO.StreamIO.in_pos -> int = fn
        val filePosOut : TextIO.StreamIO.out_pos -> int = fn
        val flushOut : TextIO.StreamIO.outstream -> unit = fn
        val getBufferMode : TextIO.StreamIO.outstream -> buffer_mode(hidden) = fn
        val getPosIn : TextIO.StreamIO.instream -> TextIO.StreamIO.in_pos = fn
        val getPosOut : TextIO.StreamIO.outstream -> TextIO.StreamIO.out_pos = fn
        val getReader : TextIO.StreamIO.instream -> (reader(hidden) * string) = fn
        val getWriter : TextIO.StreamIO.outstream -> (writer(hidden) * buffer_mode(hidden)) = fn
        val input : TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) = fn
        val input1 : TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option = fn
        val inputAll : TextIO.StreamIO.instream -> string = fn
        val inputLine : TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) = fn
        val inputN : (TextIO.StreamIO.instream * int) -> (string * TextIO.StreamIO.instream) = fn
        val mkInstream : (reader(hidden) * string) -> TextIO.StreamIO.instream = fn
        val mkOutstream : (writer(hidden) * buffer_mode(hidden)) -> TextIO.StreamIO.outstream = fn
        val output : (TextIO.StreamIO.outstream * string) -> unit = fn
        val output1 : (TextIO.StreamIO.outstream * char) -> unit = fn
        val outputSubstr : (TextIO.StreamIO.outstream * substring(hidden)) -> unit = fn
        val setBufferMode : (TextIO.StreamIO.outstream * buffer_mode(hidden)) -> unit = fn
        val setPosIn : TextIO.StreamIO.in_pos -> TextIO.StreamIO.instream = fn
        val setPosOut : TextIO.StreamIO.out_pos -> TextIO.StreamIO.outstream = fn
      end
    eqtype elem = char
    eqtype instream = instream ref
    eqtype outstream = outstream ref
    eqtype vector = string
    val canInput : (TextIO.StreamIO.instream ref * int) -> bool = fn
    val closeIn : TextIO.StreamIO.instream ref -> unit = fn
    val closeOut : TextIO.StreamIO.outstream ref -> unit = fn
    val endOfStream : TextIO.StreamIO.instream ref -> bool = fn
    val flushOut : TextIO.StreamIO.outstream ref -> unit = fn
    val getInstream : TextIO.StreamIO.instream ref -> TextIO.StreamIO.instream = fn
    val getOutstream : TextIO.StreamIO.outstream ref -> TextIO.StreamIO.outstream = fn
    val getPosIn : TextIO.StreamIO.instream ref -> TextIO.StreamIO.in_pos = fn
    val getPosOut : TextIO.StreamIO.outstream ref -> TextIO.StreamIO.out_pos = fn
    val input : TextIO.StreamIO.instream ref -> string = fn
    val input1 : TextIO.StreamIO.instream ref -> char option = fn
    val inputAll : TextIO.StreamIO.instream ref -> string = fn
    val inputLine : TextIO.StreamIO.instream ref -> string = fn
    val inputN : (TextIO.StreamIO.instream ref * int) -> string = fn
    val lookahead : TextIO.StreamIO.instream ref -> char option = fn
    val mkInstream : TextIO.StreamIO.instream -> TextIO.StreamIO.instream ref = fn
    val mkOutstream : TextIO.StreamIO.outstream -> TextIO.StreamIO.outstream ref = fn
    val openAppend : string -> TextIO.StreamIO.outstream ref = fn
    val openIn : string -> TextIO.StreamIO.instream ref = fn
    val openOut : string -> TextIO.StreamIO.outstream ref = fn
    val openString : string -> TextIO.StreamIO.instream ref = fn
    val output : (TextIO.StreamIO.outstream ref * string) -> unit = fn
    val output1 : (TextIO.StreamIO.outstream ref * char) -> unit = fn
    val outputSubstr : (TextIO.StreamIO.outstream ref * substring(hidden)) -> unit = fn
    val print : string -> unit = fn
    val scanStream : ((TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option) -> TextIO.StreamIO.instream -> ('a * TextIO.StreamIO.instream) option) -> TextIO.StreamIO.instream ref -> 'a option = fn
    val setInstream : (TextIO.StreamIO.instream ref * TextIO.StreamIO.instream) -> unit = fn
    val setOutstream : (TextIO.StreamIO.outstream ref * TextIO.StreamIO.outstream) -> unit = fn
    val setPosIn : (TextIO.StreamIO.instream ref * TextIO.StreamIO.in_pos) -> unit = fn
    val setPosOut : (TextIO.StreamIO.outstream ref * TextIO.StreamIO.out_pos) -> unit = fn
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(PUTmore WR ..)})
    val stdIn : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=false, more=ref(GETmore ..), name="<stdIn>"}, pos=0})
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(PUTmore WR ..)})
  end
val it : unit = ()
structure TextPrimIO =
  struct
    eqtype array = array
    eqtype elem = char
    eqtype pos = int
    datatype reader =
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
    eqtype vector = string
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OS.IO.iodesc option, name: string, readArr: ({buf: TextPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: TextPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> TextPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OS.IO.iodesc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: TextPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: TextPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> TextPrimIO.writer
    val augmentReader : TextPrimIO.reader -> TextPrimIO.reader = fn
    val augmentWriter : TextPrimIO.writer -> TextPrimIO.writer = fn
    val compare : (int * int) -> order = fn
  end
val it : unit = ()
structure Substring =
  struct
    structure String =
      struct
        structure Char = struct ... end
        eqtype char = char
        eqtype string = string
        val < : (string * string) -> bool = fn
        val <= : (string * string) -> bool = fn
        val > : (string * string) -> bool = fn
        val >= : (string * string) -> bool = fn
        val ^ : (string * string) -> string = fn
        val collate : ((char * char) -> order) -> (string * string) -> order = fn
        val compare : (string * string) -> order = fn
        val concat : string list -> string = fn
        val explode : string -> char list = fn
        val extract : (string * int * int option) -> string = fn
        val fields : (char -> bool) -> string -> string list = fn
        val fromCString : string -> string option = fn
        val fromString : string -> string option = fn
        val implode : char list -> string = fn
        val isPrefix : string -> string -> bool = fn
        val maxSize : int = 16777195
        val size : string -> int = fn
        val str : char -> string = fn
        val sub : (string * int) -> char = fn
        val substring : (string * int * int) -> string = fn
        val toCString : string -> string = fn
        val toString : string -> string = fn
        val tokens : (char -> bool) -> string -> string list = fn
        val translate : (char -> string) -> string -> string = fn
      end
    eqtype substring = substring
    val all : string -> Substring.substring = fn
    val app : (char -> unit) -> Substring.substring -> unit = fn
    val base : Substring.substring -> (string * int * int) = fn
    val collate : ((char * char) -> order) -> (Substring.substring * Substring.substring) -> order = fn
    val compare : (Substring.substring * Substring.substring) -> order = fn
    val concat : Substring.substring list -> string = fn
    val dropl : (char -> bool) -> Substring.substring -> Substring.substring = fn
    val dropr : (char -> bool) -> Substring.substring -> Substring.substring = fn
    val explode : Substring.substring -> char list = fn
    val extract : (string * int * int option) -> Substring.substring = fn
    val fields : (char -> bool) -> Substring.substring -> Substring.substring list = fn
    val first : Substring.substring -> char option = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> Substring.substring -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> Substring.substring -> 'a = fn
    val getc : Substring.substring -> (char * Substring.substring) option = fn
    val isEmpty : Substring.substring -> bool = fn
    val isPrefix : string -> Substring.substring -> bool = fn
    val position : string -> Substring.substring -> (Substring.substring * Substring.substring) = fn
    val size : Substring.substring -> int = fn
    val slice : (Substring.substring * int * int option) -> Substring.substring = fn
    val splitAt : (Substring.substring * int) -> (Substring.substring * Substring.substring) = fn
    val splitl : (char -> bool) -> Substring.substring -> (Substring.substring * Substring.substring) = fn
    val splitr : (char -> bool) -> Substring.substring -> (Substring.substring * Substring.substring) = fn
    val string : Substring.substring -> string = fn
    val sub : (Substring.substring * int) -> char = fn
    val substring : (string * int * int) -> Substring.substring = fn
    val takel : (char -> bool) -> Substring.substring -> Substring.substring = fn
    val taker : (char -> bool) -> Substring.substring -> Substring.substring = fn
    val tokens : (char -> bool) -> Substring.substring -> Substring.substring list = fn
    val translate : (char -> string) -> Substring.substring -> string = fn
    val triml : int -> Substring.substring -> Substring.substring = fn
    val trimr : int -> Substring.substring -> Substring.substring = fn
  end
@


1.11
log
@Modify because Path now has toUnixPath and fromUnixPath
@
text
@d270 2
a271 9
val file : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ..]), mode=ref(NO_BUF), name="foo", pos=ref(0), writer=ref(PUTmore WR ..)})
val stream : TextIO.StreamIO.outstream = Out {data=A(#B[97, 98, 99, 0, 0, 0, 0, 0, 0, 0, ..]), mode=ref(NO_BUF), name="foo", pos=ref(3), writer=ref(PUTmore WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=SOME .., getPos=SOME .., ioDesc=SOME .., name="foo", setPos=SOME .., verifyPos=SOME .., writeArr=SOME .., writeArrNB=SOME .., writeVec=SOME .., writeVecNB=SOME ..})}
val close : unit -> unit = fn
val write : {buf: string, i: int, sz: int option} -> int = fn
val ans : string = "test succeeded."
val file : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=false, more=ref(GETmore ..), name="foo"}, pos=0})
val close : unit -> unit = fn
val read : int -> string = fn
val ans : string = "test succeeded."
@


1.10
log
@[Bug #1759]
recompiling
changes owing to new TEXT_STREAM_IO signature.
@
text
@d71 1
d87 1
@


1.9
log
@[Bug #1661]
Updating
@
text
@d134 1
d140 1
@


1.9.4.1
log
@branched from 1.9
@
text
@@


1.9.3.1
log
@branched from 1.9
@
text
@@


1.9.3.1.1.1
log
@branched from 1.9.3.1
@
text
@@


1.9.2.1
log
@branched from 1.9
@
text
@@


1.9.1.1
log
@branched from 1.9
@
text
@@


1.9.1.1.1.1
log
@branched from 1.9.1.1
@
text
@@


1.8
log
@When we moved our test suite to run on Solaris rather than on SunOS
it meant that the various "test succeeded" messages were being
printed out at different places on the output file on different
machines.  Therefore this change is simply not to print out the
message, just to pass the "test succeeded" message as a string.
@
text
@d42 2
a43 2
        eqtype io_desc = io_desc
        eqtype io_desc_kind = io_desc_kind
d47 2
a48 2
        val compare : (OS.IO.io_desc * OS.IO.io_desc) -> order = fn
        val hash : OS.IO.io_desc -> word = fn
d53 1
a53 1
        val kind : OS.IO.io_desc -> OS.IO.io_desc_kind = fn
d55 1
a55 1
        val pollDesc : OS.IO.io_desc -> OS.IO.poll_desc option = fn
d59 1
a59 1
        val pollToIODesc : OS.IO.poll_desc -> OS.IO.io_desc = fn
d188 1
a188 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d191 3
a193 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OS.IO.io_desc option, name: string, readArr: ({buf: TextPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: TextPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> TextPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OS.IO.io_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: TextPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: TextPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> TextPrimIO.writer
@


1.8.2.1
log
@branched from 1.8
@
text
@@


1.8.1.1
log
@branched from 1.8
@
text
@@


1.7
log
@[Bug #1490]
redo checkin
@
text
@d265 2
a266 10
val reportOK : bool -> unit = fn
val file : TextI

test succeeded.



test succeeded.

O.StreamIO.outstream ref = ref(Out {data=A(#B[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ..]), mode=ref(NO_BUF), name="foo", pos=ref(0), writer=ref(PUTmore WR ..)})
d270 1
a270 1
val ans : unit = ()
d274 1
a274 1
val ans : unit = ()
@


1.6
log
@[Bug #1490]
update for String.maxSize
@
text
@d266 1
a266 1
val file : TextIO
d274 1
a274 1
.StreamIO.outstream ref = ref(Out {data=A(#B[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ..]), mode=ref(NO_BUF), name="foo", pos=ref(0), writer=ref(PUTmore WR ..)})
@


1.5
log
@remove banner
@
text
@d221 1
a221 1
        val maxSize : int = 8388606
@


1.5.1.1
log
@branched from 1.5
@
text
@@


1.4
log
@updating for commercial version flyer
@
text
@a0 2
commercial version may be purchased directly from Harlequin.

@


1.3
log
@Update wrt change in io_desc type.
@
text
@d1 2
@


1.2
log
@[Bug #1566]
updating.
,
@
text
@d42 1
a42 1
        eqtype io_desc = file_desc
d188 1
a188 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d191 1
a191 1
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
d266 1
a266 1
val file : 
d274 1
a274 1
TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ..]), mode=ref(NO_BUF), name="foo", pos=ref(0), writer=ref(PUTmore WR ..)})
@


1.1
log
@new unit
[Bug #1566]
Answer file for stream_io_2.sml
@
text
@a1 55
Compiling basis.toplevel
Compiling basis.string_cvt
Compiling basis.__pre_basis
Compiling basis.__pre_string_cvt
Compiling basis.__string_cvt
Compiling basis.__preinteger
Compiling basis.__preint32
Compiling basis.integer
Compiling basis.__integer
Compiling basis.__position
Compiling basis.char
Compiling basis.__pre_char
Compiling basis.__char
Compiling basis.general
Compiling basis.__general
Compiling basis.math
Compiling basis.__math
Compiling basis.ieeereal
Compiling basis.__ieeereal
Compiling basis.__prereal
Compiling basis.real
Compiling basis.__real
Compiling basis.time
Compiling unix.__time
Compiling basis.os_file_sys
Compiling basis.os_path
Compiling basis.os_process
Compiling basis.os_io
Compiling basis.os
Compiling basis.__preword32
Compiling basis.__preword
Compiling basis.word
Compiling basis.__word32
Compiling basis.mono_vector
Compiling basis.list
Compiling basis.__list
Compiling basis.__word
Compiling basis.__word8
Compiling basis.__word8vector
Compiling unix.unixos
Compiling unix._os
Compiling unix._unixos
Compiling unix.__unixos
Compiling basis.string
Compiling basis.__string
Compiling unix.__os_path
Compiling unix._os_file_sys
Compiling unix.__os_file_sys
Compiling basis.__exit
Compiling basis.exit
Compiling basis._os_process
Compiling basis.__os_process
Compiling unix._os_io
Compiling unix.__os_io
Compiling unix.__os
a105 22
Compiling basis.mono_array
Compiling basis.__word8array
Compiling basis.__charvector
Compiling basis.__chararray
Compiling basis.prim_io
Compiling basis.os_prim_io
Compiling basis._prim_io
Compiling basis.__bin_prim_io
Compiling basis.__text_prim_io
Compiling unix.__os_prim_io
Compiling basis.io
Compiling basis.__io
Compiling basis.stream_io
Compiling basis._stream_io
Compiling basis.__stream_io
Compiling basis.imperative_io
Compiling basis._imperative_io
Compiling basis.substring
Compiling basis.__substring
Compiling basis.text_io
Compiling basis._text_io
Compiling basis.__text_io
a240 8

test succeeded.



test succeeded.


d266 9
a274 1
val file : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ..]), mode=ref(NO_BUF), name="foo", pos=ref(0), writer=ref(PUTmore WR ..)})
@
