head	1.25;
access;
symbols
	MLWorks_21c0_1999_03_25:1.25
	MLWorks_20c1_1998_08_20:1.25
	MLWorks_20c0_1998_08_04:1.25
	MLWorks_20b2c2_1998_06_19:1.25
	MLWorks_20b2_Windows_1998_06_12:1.25
	MLWorks_20b1c1_1998_05_07:1.25
	MLWorks_20b0_1998_04_07:1.25
	MLWorks_20b0_1998_03_20:1.25
	MLWorks_20m2_1998_02_16:1.25
	MLWorks_20m1_1997_10_23:1.23
	MLWorks_11r1:1.23.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.23.1.1.1.1
	MLWorks_10r3:1.23.1.1.3
	MLWorks_10r2_551:1.23.1.1.2
	MLWorks_11:1.23.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.23.1.1
	MLWorks_20m0_1997_06_20:1.23
	MLWorks_1_0_r2c2_1997_06_14:1.23.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.23.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.23.1
	MLWorks_BugFix_1997_04_24:1.23
	MLWorks_1_0_r2_Win32_1997_04_11:1.23
	MLWorks_1_0_r2_Unix_1997_04_04:1.22
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.18.3.1.1
	MLWorks_gui_1996_12_18:1.18.4
	MLWorks_1_0_Win32_1996_12_17:1.18.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.18.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.18.1.1
	MLWorks_1_0_Irix_1996_11_28:1.18.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.18.2
	MLWorks_1_0_Unix_1996_11_14:1.18.1
	MLWorks_Open_Beta2_1996_10_11:1.17.2
	MLWorks_License_dev:1.17.1
	MLWorks_1_open_beta_1996_09_13:1.16.1
	MLWorks_Open_Beta_1996_08_22:1.11
	MLWorks_Beta_1996_07_02:1.6;
locks; strict;
comment	@# @;


1.25
date	98.01.30.12.20.03;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	97.11.25.19.19.10;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	97.04.03.10.07.50;	author jont;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	97.03.24.13.44.33;	author andreww;	state Exp;
branches;
next	1.21;

1.21
date	97.03.05.11.40.27;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	97.02.26.12.24.40;	author andreww;	state Exp;
branches;
next	1.19;

1.19
date	97.01.30.16.02.12;	author andreww;	state Exp;
branches;
next	1.18;

1.18
date	96.11.08.15.15.18;	author matthew;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1
	1.18.4.1;
next	1.17;

1.17
date	96.10.01.12.56.52;	author io;	state Exp;
branches
	1.17.1.1
	1.17.2.1;
next	1.16;

1.16
date	96.09.09.11.14.00;	author io;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	96.09.07.00.02.24;	author io;	state Exp;
branches;
next	1.14;

1.14
date	96.08.29.00.03.59;	author stephenb;	state Exp;
branches;
next	1.13;

1.13
date	96.08.27.09.33.31;	author andreww;	state Exp;
branches;
next	1.12;

1.12
date	96.08.23.08.58.09;	author andreww;	state Exp;
branches;
next	1.11;

1.11
date	96.08.14.11.18.12;	author io;	state Exp;
branches;
next	1.10;

1.10
date	96.07.18.15.44.55;	author andreww;	state Exp;
branches;
next	1.9;

1.9
date	96.07.17.11.43.28;	author andreww;	state Exp;
branches;
next	1.8;

1.8
date	96.07.05.13.28.46;	author andreww;	state Exp;
branches;
next	1.7;

1.7
date	96.07.03.11.19.13;	author andreww;	state Exp;
branches;
next	1.6;

1.6
date	96.07.02.09.30.14;	author andreww;	state Exp;
branches;
next	1.5;

1.5
date	96.06.25.10.16.15;	author io;	state Exp;
branches;
next	1.4;

1.4
date	96.06.13.14.04.30;	author andreww;	state Exp;
branches;
next	1.3;

1.3
date	96.06.12.09.09.36;	author andreww;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.13.14.58;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	96.06.11.12.51.18;	author andreww;	state Exp;
branches;
next	;

1.16.1.1
date	96.09.13.11.38.43;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.10.07.16.30.12;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.10.17.11.50.48;	author hope;	state Exp;
branches;
next	;

1.18.1.1
date	96.11.14.13.18.13;	author hope;	state Exp;
branches
	1.18.1.1.1.1;
next	;

1.18.1.1.1.1
date	96.11.28.15.28.44;	author hope;	state Exp;
branches;
next	;

1.18.2.1
date	96.11.22.18.35.59;	author hope;	state Exp;
branches;
next	;

1.18.3.1
date	96.12.17.18.14.59;	author hope;	state Exp;
branches
	1.18.3.1.1.1;
next	;

1.18.3.1.1.1
date	97.02.24.12.07.59;	author hope;	state Exp;
branches;
next	;

1.18.4.1
date	96.12.18.10.09.58;	author hope;	state Exp;
branches;
next	;

1.23.1.1
date	97.05.12.11.08.37;	author hope;	state Exp;
branches
	1.23.1.1.1.1
	1.23.1.1.2.1
	1.23.1.1.3.1;
next	;

1.23.1.1.1.1
date	97.07.28.18.50.33;	author daveb;	state Exp;
branches
	1.23.1.1.1.1.1.1;
next	;

1.23.1.1.1.1.1.1
date	97.10.07.12.15.28;	author jkbrook;	state Exp;
branches;
next	;

1.23.1.1.2.1
date	97.09.08.17.42.20;	author daveb;	state Exp;
branches;
next	;

1.23.1.1.3.1
date	97.09.09.14.41.46;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Answer file for imperative IO test.
@


1.25
log
@[Bug #30330]
Modify answers now that type info correct in object files
@
text
@test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
val amy : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), name="Amy", pos=ref(0), writer=ref(PUTmore WR ..)})
val arthur : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val comm_2 : string ref = ref("BBBBB")
val comm_medium : string ref = ref("AAAAA")
val interleave : TextIO.StreamIO.instream ref -> TextIO.StreamIO.instream -> string = fn
val pos : int ref = ref(5)
val pos2 : int ref = ref(5)
val r : TextPrimIO.reader = RD {avail=fn, block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Arthur", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=SOME fn, verifyPos=NONE}
val r2 : TextPrimIO.reader = RD {avail=fn, block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Arthur's twin", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=SOME fn, verifyPos=NONE}
val reportOK : bool -> unit = fn
val ruhtra : TextIO.StreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=false, more=ref(ISmore(Buf ..)), name="Arthur's twin"}, pos=0}
val s : string = "Oh the grand old Duke of York,\nHe had a leg of Pork,\nHe marched it up to the Microwave,\nAnd he ate it with a fork.\n\n\nFile created by test_suite/basis/imperative_io.sml"
val s'_1 : string = "Oh the grand old Duke of York,\n"
val s'_2 : string = "He had a leg of Pork,\nHe marched it up to the Microwave,\nAnd he ate it with a fork.\n\n\nFile created by test_suite/basis/imperative_io.smlSome enchanted evening,..."
val s_1 : string = "Oh the grand old Duke of York,\n"
val s_2 : string = "He had a leg of Pork,\n"
val s_3 : string = "He marched it up to the Microwave,\n"
val s_4 : string = "And he ate it with a fork.\n"
val s_5 : string = "\n\nFile created by test_suite/basis/imperative_io.sml"
val s_6 : string = "Some enchanted evening,..."
val test1 : bool = true
val test2 : bool = true
val the_answer : string = "One Two Three\n1Four Five Six\nSeven Eight Nine."
val w : TextPrimIO.writer = WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Amy", setPos=SOME fn, verifyPos=NONE, writeArr=NONE, writeArrNB=NONE, writeVec=SOME fn, writeVecNB=NONE}
val x : unit = ()
val y : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="123"}, pos=193})
@


1.24
log
@[Bug #30323]
@
text
@d7 2
a8 2
val amy : TextIO.StreamIO.outstream ref = ref(Out _)
val arthur : TextIO.StreamIO.instream ref = ref(In _)
d14 2
a15 2
val r : TextPrimIO.reader = RD _
val r2 : TextPrimIO.reader = RD _
d17 1
a17 1
val ruhtra : TextIO.StreamIO.instream = In _
d30 1
a30 1
val w : TextPrimIO.writer = WR _
d32 1
a32 1
val y : TextIO.StreamIO.instream ref = ref(In _)
@


1.23
log
@Modify to avoid displaying syserror type
@
text
@a0 10
structure General = struct ... end
structure Char = struct ... end
structure CharVector = struct ... end
structure CharArray = struct ... end
structure OSPrimIO = struct ... end
structure BinPrimIO = struct ... end
structure TextPrimIO = struct ... end
structure TextIO = struct ... end
structure IO = struct ... end
structure OS = struct ... end
d7 2
a8 2
val amy : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), name="Amy", pos=ref(0), writer=ref(PUTmore WR ..)})
val arthur : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
d14 2
a15 2
val r : OSPrimIO.text_reader = RD {avail=fn, block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Arthur", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=SOME fn, verifyPos=NONE}
val r2 : OSPrimIO.text_reader = RD {avail=fn, block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Arthur's twin", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=SOME fn, verifyPos=NONE}
d17 1
a17 1
val ruhtra : TextIO.StreamIO.instream = In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=false, more=ref(ISmore(Buf ..)), name="Arthur's twin"}, pos=0}
d30 1
a30 1
val w : OSPrimIO.text_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="Amy", setPos=SOME fn, verifyPos=NONE, writeArr=NONE, writeArrNB=NONE, writeVec=SOME fn, writeVecNB=NONE}
d32 1
a32 1
val y : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="123"}, pos=193})
@


1.23.1.1
log
@branched from 1.23
@
text
@@


1.23.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.23.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.23.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.23.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.22
log
@[Bug #1960]
upating.
@
text
@d1 10
a10 392
val it : unit = ()
structure General =
  struct
    type exn = exn
    datatype 'a option =
      NONE |
      SOME of 'a
    datatype order =
      EQUAL |
      GREATER |
      LESS
    eqtype unit = unit
    val ! : 'a ref -> 'a = fn
    val := : ('a ref * 'a) -> unit = fn
    val <> : (''a * ''a) -> bool = fn
    exception Bind
    exception Chr
    exception Div
    exception Domain
    val EQUAL : order
    exception Fail of string
    val GREATER : order
    val LESS : order
    exception Match
    val NONE : 'a option
    exception Option
    exception Overflow
    val SOME : 'a -> 'a option
    exception Size
    exception Subscript
    val before : ('a * unit) -> 'a = fn
    val exnMessage : exn -> string = fn
    val exnName : exn -> string = fn
    val getOpt : ('a option * 'a) -> 'a = fn
    val ignore : 'a -> unit = fn
    val isSome : 'a option -> bool = fn
    val o : (('a -> 'b) * ('c -> 'a)) -> 'c -> 'b = fn
    val valOf : 'a option -> 'a = fn
  end
val it : unit = ()
structure Char =
  struct
    eqtype char = char
    eqtype string = string
    val < : (char * char) -> bool = fn
    val <= : (char * char) -> bool = fn
    val > : (char * char) -> bool = fn
    val >= : (char * char) -> bool = fn
    val chr : int -> char = fn
    val compare : (char * char) -> order = fn
    val contains : string -> char -> bool = fn
    val fromCString : string -> char option = fn
    val fromString : string -> char option = fn
    val isAlpha : char -> bool = fn
    val isAlphaNum : char -> bool = fn
    val isAscii : char -> bool = fn
    val isCntrl : char -> bool = fn
    val isDigit : char -> bool = fn
    val isGraph : char -> bool = fn
    val isHexDigit : char -> bool = fn
    val isLower : char -> bool = fn
    val isPrint : char -> bool = fn
    val isPunct : char -> bool = fn
    val isSpace : char -> bool = fn
    val isUpper : char -> bool = fn
    val maxChar : char = #"\255"
    val maxOrd : int = 255
    val minChar : char = #"\000"
    val notContains : string -> char -> bool = fn
    val ord : char -> int = fn
    val pred : char -> char = fn
    val scan : ('a -> (char * 'a) option) -> 'a -> (char * 'a) option = fn
    val succ : char -> char = fn
    val toCString : char -> string = fn
    val toLower : char -> char = fn
    val toString : char -> string = fn
    val toUpper : char -> char = fn
  end
val it : unit = ()
structure CharVector =
  struct
    eqtype elem = char
    eqtype vector = string
    val app : (char -> unit) -> string -> unit = fn
    val appi : ((int * char) -> unit) -> (string * int * int option) -> unit = fn
    val concat : string list -> string = fn
    val extract : (string * int * int option) -> string = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
    val fromList : char list -> string = fn
    val length : string -> int = fn
    val maxLen : int = 16777196
    val sub : (string * int) -> char = fn
    val tabulate : (int * (int -> char)) -> string = fn
  end
val it : unit = ()
structure CharArray =
  struct
    structure Vector =
      struct
        eqtype elem = char
        eqtype vector = string
        val app : (char -> unit) -> string -> unit = fn
        val appi : ((int * char) -> unit) -> (string * int * int option) -> unit = fn
        val concat : string list -> string = fn
        val extract : (string * int * int option) -> string = fn
        val foldl : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
        val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
        val foldr : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
        val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
        val fromList : char list -> string = fn
        val length : string -> int = fn
        val maxLen : int = 16777196
        val sub : (string * int) -> char = fn
        val tabulate : (int * (int -> char)) -> string = fn
      end
    eqtype array = array
    eqtype elem = char
    val app : (char -> unit) -> CharArray.array -> unit = fn
    val appi : ((int * char) -> unit) -> (CharArray.array * int * int option) -> unit = fn
    val array : (int * char) -> CharArray.array = fn
    val copy : {di: int, dst: CharArray.array, len: int option, si: int, src: CharArray.array} -> unit = fn
    val copyVec : {di: int, dst: CharArray.array, len: int option, si: int, src: string} -> unit = fn
    val extract : (CharArray.array * int * int option) -> string = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> CharArray.array -> 'a = fn
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int option) -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> CharArray.array -> 'a = fn
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int option) -> 'a = fn
    val fromList : char list -> CharArray.array = fn
    val length : CharArray.array -> int = fn
    val maxLen : int = 16777196
    val modify : (char -> char) -> CharArray.array -> unit = fn
    val modifyi : ((int * char) -> char) -> (CharArray.array * int * int option) -> unit = fn
    val sub : (CharArray.array * int) -> char = fn
    val tabulate : (int * (int -> char)) -> CharArray.array = fn
    val update : (CharArray.array * int * char) -> unit = fn
  end
val it : unit = ()
structure OSPrimIO =
  struct
    type bin_reader = reader
    type bin_writer = writer
    eqtype file_desc = file_desc
    type text_reader = reader
    type text_writer = writer
    val openApp : string -> OSPrimIO.bin_writer = fn
    val openRd : string -> OSPrimIO.bin_reader = fn
    val openString : string -> OSPrimIO.text_reader = fn
    val openWr : string -> OSPrimIO.bin_writer = fn
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=NONE, getPos=SOME fn, ioDesc=NONE, name="<stdOut>", setPos=SOME fn, verifyPos=SOME fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : OSPrimIO.bin_reader = RD {avail=fn, block=NONE, canInput=SOME fn, chunkSize=1, close=fn, endPos=NONE, getPos=SOME fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=SOME fn, verifyPos=SOME fn}
    val stdOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=NONE, getPos=SOME fn, ioDesc=NONE, name="<stdOut>", setPos=SOME fn, verifyPos=SOME fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val translateIn : OSPrimIO.bin_reader -> OSPrimIO.text_reader = fn
    val translateOut : OSPrimIO.bin_writer -> OSPrimIO.text_writer = fn
  end
val it : unit = ()
structure BinPrimIO =
  struct
    eqtype array = array
    eqtype elem = word8
    eqtype pos = int
    datatype reader =
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
    type vector = vector
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> BinPrimIO.vector) option, readVecNB: (int -> BinPrimIO.vector option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
    val augmentReader : BinPrimIO.reader -> BinPrimIO.reader = fn
    val augmentWriter : BinPrimIO.writer -> BinPrimIO.writer = fn
    val compare : (int * int) -> order = fn
  end
val it : unit = ()
structure TextPrimIO =
  struct
    eqtype array = array
    eqtype elem = char
    eqtype pos = int
    datatype reader =
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
    eqtype vector = string
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
    val augmentReader : OSPrimIO.text_reader -> OSPrimIO.text_reader = fn
    val augmentWriter : OSPrimIO.text_writer -> OSPrimIO.text_writer = fn
    val compare : (int * int) -> order = fn
  end
val it : unit = ()
structure TextIO =
  struct
    structure StreamIO =
      struct
        eqtype elem = char
        type in_pos = in_pos
        type instream = instream
        type out_pos = out_pos
        eqtype outstream = outstream
        eqtype pos = int
        type reader = reader
        eqtype vector = string
        type writer = writer
        val canInput : (TextIO.StreamIO.instream * int) -> int option = fn
        val closeIn : TextIO.StreamIO.instream -> unit = fn
        val closeOut : TextIO.StreamIO.outstream -> unit = fn
        val endOfStream : TextIO.StreamIO.instream -> bool = fn
        val filePosIn : TextIO.StreamIO.in_pos -> int = fn
        val filePosOut : TextIO.StreamIO.out_pos -> int = fn
        val flushOut : TextIO.StreamIO.outstream -> unit = fn
        val getBufferMode : TextIO.StreamIO.outstream -> buffer_mode(hidden) = fn
        val getPosIn : TextIO.StreamIO.instream -> TextIO.StreamIO.in_pos = fn
        val getPosOut : TextIO.StreamIO.outstream -> TextIO.StreamIO.out_pos = fn
        val getReader : TextIO.StreamIO.instream -> (OSPrimIO.text_reader * string) = fn
        val getWriter : TextIO.StreamIO.outstream -> (OSPrimIO.text_writer * buffer_mode(hidden)) = fn
        val input : TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) = fn
        val input1 : TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option = fn
        val inputAll : TextIO.StreamIO.instream -> string = fn
        val inputLine : TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) = fn
        val inputN : (TextIO.StreamIO.instream * int) -> (string * TextIO.StreamIO.instream) = fn
        val mkInstream : (OSPrimIO.text_reader * string) -> TextIO.StreamIO.instream = fn
        val mkOutstream : (OSPrimIO.text_writer * buffer_mode(hidden)) -> TextIO.StreamIO.outstream = fn
        val output : (TextIO.StreamIO.outstream * string) -> unit = fn
        val output1 : (TextIO.StreamIO.outstream * char) -> unit = fn
        val outputSubstr : (TextIO.StreamIO.outstream * substring(hidden)) -> unit = fn
        val setBufferMode : (TextIO.StreamIO.outstream * buffer_mode(hidden)) -> unit = fn
        val setPosIn : TextIO.StreamIO.in_pos -> TextIO.StreamIO.instream = fn
        val setPosOut : TextIO.StreamIO.out_pos -> TextIO.StreamIO.outstream = fn
      end
    eqtype elem = char
    eqtype instream = instream ref
    eqtype outstream = outstream ref
    eqtype vector = string
    val canInput : (TextIO.StreamIO.instream ref * int) -> bool = fn
    val closeIn : TextIO.StreamIO.instream ref -> unit = fn
    val closeOut : TextIO.StreamIO.outstream ref -> unit = fn
    val endOfStream : TextIO.StreamIO.instream ref -> bool = fn
    val flushOut : TextIO.StreamIO.outstream ref -> unit = fn
    val getInstream : TextIO.StreamIO.instream ref -> TextIO.StreamIO.instream = fn
    val getOutstream : TextIO.StreamIO.outstream ref -> TextIO.StreamIO.outstream = fn
    val getPosIn : TextIO.StreamIO.instream ref -> TextIO.StreamIO.in_pos = fn
    val getPosOut : TextIO.StreamIO.outstream ref -> TextIO.StreamIO.out_pos = fn
    val input : TextIO.StreamIO.instream ref -> string = fn
    val input1 : TextIO.StreamIO.instream ref -> char option = fn
    val inputAll : TextIO.StreamIO.instream ref -> string = fn
    val inputLine : TextIO.StreamIO.instream ref -> string = fn
    val inputN : (TextIO.StreamIO.instream ref * int) -> string = fn
    val lookahead : TextIO.StreamIO.instream ref -> char option = fn
    val mkInstream : TextIO.StreamIO.instream -> TextIO.StreamIO.instream ref = fn
    val mkOutstream : TextIO.StreamIO.outstream -> TextIO.StreamIO.outstream ref = fn
    val openAppend : string -> TextIO.StreamIO.outstream ref = fn
    val openIn : string -> TextIO.StreamIO.instream ref = fn
    val openOut : string -> TextIO.StreamIO.outstream ref = fn
    val openString : string -> TextIO.StreamIO.instream ref = fn
    val output : (TextIO.StreamIO.outstream ref * string) -> unit = fn
    val output1 : (TextIO.StreamIO.outstream ref * char) -> unit = fn
    val outputSubstr : (TextIO.StreamIO.outstream ref * substring(hidden)) -> unit = fn
    val print : string -> unit = fn
    val scanStream : ((TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option) -> TextIO.StreamIO.instream -> ('a * TextIO.StreamIO.instream) option) -> TextIO.StreamIO.instream ref -> 'a option = fn
    val setInstream : (TextIO.StreamIO.instream ref * TextIO.StreamIO.instream) -> unit = fn
    val setOutstream : (TextIO.StreamIO.outstream ref * TextIO.StreamIO.outstream) -> unit = fn
    val setPosIn : (TextIO.StreamIO.instream ref * TextIO.StreamIO.in_pos) -> unit = fn
    val setPosOut : (TextIO.StreamIO.outstream ref * TextIO.StreamIO.out_pos) -> unit = fn
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(PUTmore WR ..)})
    val stdIn : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=false, more=ref(GETmore ..), name="<stdIn>"}, pos=0})
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(PUTmore WR ..)})
  end
val it : unit = ()
structure IO =
  struct
    datatype buffer_mode =
      BLOCK_BUF |
      LINE_BUF |
      NO_BUF
    val BLOCK_BUF : IO.buffer_mode
    exception BlockingNotSupported
    exception ClosedStream
    exception Io of {cause: exn, function: string, name: string}
    val LINE_BUF : IO.buffer_mode
    val NO_BUF : IO.buffer_mode
    exception NonblockingNotSupported
    exception RandomAccessNotSupported
    exception TerminatedStream
  end
val it : unit = ()
structure OS =
  struct
    structure FileSys =
      struct
        datatype access_mode =
          A_EXEC |
          A_READ |
          A_WRITE
        eqtype dirstream = dirstream
        eqtype file_id = file_id
        val A_EXEC : OS.FileSys.access_mode
        val A_READ : OS.FileSys.access_mode
        val A_WRITE : OS.FileSys.access_mode
        val access : (string * OS.FileSys.access_mode list) -> bool = fn
        val chDir : string -> unit = fn
        val closeDir : OS.FileSys.dirstream -> unit = fn
        val compare : (OS.FileSys.file_id * OS.FileSys.file_id) -> order = fn
        val fileId : string -> OS.FileSys.file_id = fn
        val fileSize : string -> int = fn
        val fullPath : string -> string = fn
        val getDir : unit -> string = fn
        val hash : OS.FileSys.file_id -> word = fn
        val isDir : string -> bool = fn
        val isLink : string -> bool = fn
        val mkDir : string -> unit = fn
        val modTime : string -> time(hidden) = fn
        val openDir : string -> OS.FileSys.dirstream = fn
        val readDir : OS.FileSys.dirstream -> string = fn
        val readLink : string -> string = fn
        val realPath : string -> string = fn
        val remove : string -> unit = fn
        val rename : {new: string, old: string} -> unit = fn
        val rewindDir : OS.FileSys.dirstream -> unit = fn
        val rmDir : string -> unit = fn
        val setTime : (string * time(hidden) option) -> unit = fn
        val tmpName : unit -> string = fn
      end
    structure IO =
      struct
        structure Kind = struct ... end
        eqtype iodesc = iodesc
        eqtype iodesc_kind = iodesc_kind
        eqtype poll_desc = poll_desc
        eqtype poll_info = poll_info
        exception Poll
        val compare : (OS.IO.iodesc * OS.IO.iodesc) -> order = fn
        val hash : OS.IO.iodesc -> word = fn
        val infoToPollDesc : OS.IO.poll_info -> OS.IO.poll_desc = fn
        val isIn : OS.IO.poll_info -> bool = fn
        val isOut : OS.IO.poll_info -> bool = fn
        val isPri : OS.IO.poll_info -> bool = fn
        val kind : OS.IO.iodesc -> OS.IO.iodesc_kind = fn
        val poll : (OS.IO.poll_desc list * time(hidden) option) -> OS.IO.poll_info list = fn
        val pollDesc : OS.IO.iodesc -> OS.IO.poll_desc option = fn
        val pollIn : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollOut : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollPri : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollToIODesc : OS.IO.poll_desc -> OS.IO.iodesc = fn
      end
    structure Path =
      struct
        exception Path
        val base : string -> string = fn
        val concat : (string * string) -> string = fn
        val currentArc : string = "."
        val dir : string -> string = fn
        val ext : string -> string option = fn
        val file : string -> string = fn
        val fromString : string -> {arcs: string list, isAbs: bool, vol: string} = fn
        val fromUnixPath : string -> string = fn
        val getParent : string -> string = fn
        val getVolume : string -> string = fn
        val isAbsolute : string -> bool = fn
        val isCanonical : string -> bool = fn
        val isRelative : string -> bool = fn
        val isRoot : string -> bool = fn
        val joinBaseExt : {base: string, ext: string option} -> string = fn
        val joinDirFile : {dir: string, file: string} -> string = fn
        val mkAbsolute : (string * string) -> string = fn
        val mkCanonical : string -> string = fn
        val mkRelative : (string * string) -> string = fn
        val parentArc : string = ".."
        val splitBaseExt : string -> {base: string, ext: string option} = fn
        val splitDirFile : string -> {dir: string, file: string} = fn
        val toString : {arcs: string list, isAbs: bool, vol: string} -> string = fn
        val toUnixPath : string -> string = fn
        val validVolume : {isAbs: bool, vol: string} -> bool = fn
      end
    structure Process =
      struct
        eqtype status = int
        val atExit : (unit -> unit) -> unit = fn
        val exit : int -> 'a = fn
        val failure : int = 1
        val getEnv : string -> string option = fn
        val success : int = 0
        val system : string -> int = fn
        val terminate : int -> 'a = fn
      end
    eqtype syserror = int
    exception SysErr of (string * syserror option)
    val errorMsg : int -> string = fn
    val errorName : int -> string = fn
    val syserror : string -> int option = fn
  end
@


1.21
log
@Modify because Path now has toUnixPath and fromUnixPath
@
text
@d152 1
a152 1
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="<stdOut>", setPos=SOME fn, verifyPos=SOME fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
@


1.20
log
@[Bug #1759]
recompiling
changes owing to new TEXT_STREAM_IO signature.
@
text
@d357 1
d373 1
@


1.19
log
@[Bug #1904]
mono vectors no longer eqtypes.
@
text
@d221 1
d227 1
@


1.18
log
@[Bug #1661]
Updating
@
text
@d166 1
a166 1
    eqtype vector = vector
@


1.18.4.1
log
@branched from 1.18
@
text
@@


1.18.3.1
log
@branched from 1.18
@
text
@@


1.18.3.1.1.1
log
@branched from 1.18.3.1
@
text
@@


1.18.2.1
log
@branched from 1.18
@
text
@@


1.18.1.1
log
@branched from 1.18
@
text
@@


1.18.1.1.1.1
log
@branched from 1.18.1.1
@
text
@@


1.17
log
@[Bug #1626]
update option in toCString
@
text
@d165 1
a165 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d168 3
a170 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> BinPrimIO.vector) option, readVecNB: (int -> BinPrimIO.vector option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
d182 1
a182 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d185 3
a187 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
d326 2
a327 2
        eqtype io_desc = io_desc
        eqtype io_desc_kind = io_desc_kind
d331 2
a332 2
        val compare : (OS.IO.io_desc * OS.IO.io_desc) -> order = fn
        val hash : OS.IO.io_desc -> word = fn
d337 1
a337 1
        val kind : OS.IO.io_desc -> OS.IO.io_desc_kind = fn
d339 1
a339 1
        val pollDesc : OS.IO.io_desc -> OS.IO.poll_desc option = fn
d343 1
a343 1
        val pollToIODesc : OS.IO.poll_desc -> OS.IO.io_desc = fn
@


1.17.2.1
log
@branched from 1.17
@
text
@@


1.17.1.1
log
@branched from 1.17
@
text
@@


1.16
log
@remove banner
@
text
@d74 1
a74 1
    val toCString : char -> string option = fn
@


1.16.1.1
log
@branched from 1.16
@
text
@@


1.15
log
@updating for commercial version flyer
@
text
@a0 2
commercial version may be purchased directly from Harlequin.

@


1.14
log
@Update wrt change in io_desc type.
@
text
@d1 2
@


1.13
log
@[Bug #1566]
updating.
,
@
text
@d165 1
a165 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d168 3
a170 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> BinPrimIO.vector) option, readVecNB: (int -> BinPrimIO.vector option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
d182 1
a182 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d185 3
a187 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
d326 1
a326 1
        eqtype io_desc = file_desc
d331 2
a332 2
        val compare : (OSPrimIO.file_desc * OSPrimIO.file_desc) -> order = fn
        val hash : OSPrimIO.file_desc -> word = fn
d337 1
a337 1
        val kind : OSPrimIO.file_desc -> OS.IO.io_desc_kind = fn
d339 1
a339 1
        val pollDesc : OSPrimIO.file_desc -> OS.IO.poll_desc option = fn
d343 1
a343 1
        val pollToIODesc : OS.IO.poll_desc -> OSPrimIO.file_desc = fn
@


1.12
log
@[Bug #1566]
updating to take into account changes in the basis.
/
@
text
@a1 2
Compiling basis.general
Compiling basis.__general
a40 12
Compiling basis.toplevel
Compiling basis.string_cvt
Compiling basis.__pre_basis
Compiling basis.__pre_string_cvt
Compiling basis.__string_cvt
Compiling basis.char
Compiling basis.__preinteger
Compiling basis.__preint32
Compiling basis.integer
Compiling basis.__integer
Compiling basis.__pre_char
Compiling basis.__char
a79 4
Compiling basis.mono_vector
Compiling basis.list
Compiling basis.__list
Compiling basis.__charvector
a98 2
Compiling basis.mono_array
Compiling basis.__chararray
a140 45
Compiling basis.__preword32
Compiling basis.__preword
Compiling basis.word
Compiling basis.__word
Compiling basis.__word8
Compiling basis.__word8vector
Compiling basis.__word8array
Compiling basis.__position
Compiling basis.math
Compiling basis.__math
Compiling basis.ieeereal
Compiling basis.__ieeereal
Compiling basis.__prereal
Compiling basis.real
Compiling basis.__real
Compiling basis.time
Compiling unix.__time
Compiling basis.os_file_sys
Compiling basis.os_path
Compiling basis.os_process
Compiling basis.os_io
Compiling basis.os
Compiling basis.__word32
Compiling unix.unixos
Compiling unix._os
Compiling unix._unixos
Compiling unix.__unixos
Compiling basis.string
Compiling basis.__string
Compiling unix.__os_path
Compiling unix._os_file_sys
Compiling unix.__os_file_sys
Compiling basis.__exit
Compiling basis.exit
Compiling basis._os_process
Compiling basis.__os_process
Compiling unix._os_io
Compiling unix.__os_io
Compiling unix.__os
Compiling basis.prim_io
Compiling basis.os_prim_io
Compiling basis._prim_io
Compiling basis.__bin_prim_io
Compiling basis.__text_prim_io
Compiling unix.__os_prim_io
a192 12
Compiling basis.io
Compiling basis.__io
Compiling basis.stream_io
Compiling basis._stream_io
Compiling basis.__stream_io
Compiling basis.imperative_io
Compiling basis._imperative_io
Compiling basis.substring
Compiling basis.__substring
Compiling basis.text_io
Compiling basis._text_io
Compiling basis.__text_io
@


1.11
log
@switch off Compiling messages...
@
text
@d2 2
d43 12
d94 4
d117 2
d161 45
d258 12
d341 1
a341 1
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {closed=ref(false), data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(SOME WR ..)})
d343 1
a343 1
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {closed=ref(false), data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(SOME WR ..)})
d472 1
a472 1
val amy : TextIO.StreamIO.outstream ref = ref(Out {closed=ref(false), data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), name="Amy", pos=ref(0), writer=ref(SOME WR ..)})
@


1.10
log
@[Bug #1453]
updating with respect to the updating of revised basis IO library.
@
text
@a1 2
Compiling basis.general
Compiling basis.__general
a40 12
Compiling basis.toplevel
Compiling basis.string_cvt
Compiling basis.__pre_basis
Compiling basis.__pre_string_cvt
Compiling basis.__string_cvt
Compiling basis.char
Compiling basis.__preinteger
Compiling basis.__preint32
Compiling basis.integer
Compiling basis.__integer
Compiling basis.__pre_char
Compiling basis.__char
a79 4
Compiling basis.mono_vector
Compiling basis.list
Compiling basis.__list
Compiling basis.__charvector
a98 2
Compiling basis.mono_array
Compiling basis.__chararray
a140 45
Compiling basis.__preword32
Compiling basis.__preword
Compiling basis.word
Compiling basis.__word
Compiling basis.__word8
Compiling basis.__word8vector
Compiling basis.__word8array
Compiling basis.__position
Compiling basis.math
Compiling basis.__math
Compiling basis.ieeereal
Compiling basis.__ieeereal
Compiling basis.__prereal
Compiling basis.real
Compiling basis.__real
Compiling basis.time
Compiling unix.__time
Compiling basis.os_file_sys
Compiling basis.os_path
Compiling basis.os_process
Compiling basis.os_io
Compiling basis.os
Compiling basis.__word32
Compiling unix.unixos
Compiling unix._os
Compiling unix._unixos
Compiling unix.__unixos
Compiling basis.string
Compiling basis.__string
Compiling unix.__os_path
Compiling unix._os_file_sys
Compiling unix.__os_file_sys
Compiling basis.__exit
Compiling basis.exit
Compiling basis._os_process
Compiling basis.__os_process
Compiling unix._os_io
Compiling unix.__os_io
Compiling unix.__os
Compiling basis.prim_io
Compiling basis.os_prim_io
Compiling basis._prim_io
Compiling basis.__bin_prim_io
Compiling basis.__text_prim_io
Compiling unix.__os_prim_io
d166 1
a166 1
    eqtype vector = string
d169 2
a170 2
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
a192 12
Compiling basis.io
Compiling basis.__io
Compiling basis.stream_io
Compiling basis._stream_io
Compiling basis.__stream_io
Compiling basis.imperative_io
Compiling basis._imperative_io
Compiling basis.substring
Compiling basis.__substring
Compiling basis.text_io
Compiling basis._text_io
Compiling basis.__text_io
@


1.9
log
@updating.
@
text
@d201 2
a202 6
Compiling basis.osprimio
Compiling basis.io
Compiling basis.__io
Compiling basis.stream_io
Compiling basis._streamio
Compiling basis._primio
d205 1
a205 1
Compiling unix.__primio
d215 1
d217 3
a219 3
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : OSPrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val stdOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
d230 1
a230 1
      RD of {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: pos -> unit}
d233 3
a235 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, setPos: pos -> unit, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: int -> unit} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: OSPrimIO.file_desc option, name: string, setPos: int -> unit, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
d247 1
a247 1
      RD of {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: pos -> unit}
d250 3
a252 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, setPos: pos -> unit, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: int -> unit} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: OSPrimIO.file_desc option, name: string, setPos: int -> unit, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
d258 4
d275 1
d277 1
d279 1
d287 2
d291 2
d304 2
d318 2
d331 1
d336 1
d339 2
d342 1
a342 1
    val stdIn : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=_, data=_, emptyMeansEof=false, more=ref(GETmore ..), name="<stdIn>"}, pos=0})
d359 1
d473 1
a473 1
val arthur : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
d479 2
a480 2
val r : OSPrimIO.text_reader = RD {block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Arthur", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=fn}
val r2 : OSPrimIO.text_reader = RD {block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Arthur's twin", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=fn}
d482 1
a482 1
val ruhtra : TextIO.StreamIO.instream = In {buffer=Buf {basePos=_, data=_, emptyMeansEof=false, more=ref(ISmore(Buf ..)), name="Arthur's twin"}, pos=0}
d495 1
a495 1
val w : OSPrimIO.text_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Amy", setPos=fn, writeArr=NONE, writeArrNB=NONE, writeVec=SOME fn, writeVecNB=NONE}
d497 1
a497 1
val y : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="123"}, pos=193})
@


1.8
log
@updating.
@
text
@a216 3
    val guiErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val guiIn : OSPrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val guiOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
d220 3
a222 3
    val terminalErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val terminalIn : OSPrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val terminalOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
d325 1
a325 1
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {closed=ref(false), data=A(#B[0]), mode=ref(NO_BUF), name="<stdErr>", pos=ref(0), writer=ref(SOME WR ..)})
d327 1
a327 1
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {closed=ref(false), data=A(#B[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ..]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(SOME WR ..)})
@


1.7
log
@making consistent with previous answer files.
@
text
@d44 1
a45 1
Compiling basis.string_cvt
d53 1
a62 2
    exception Dummy of char
    exception ToString of char
a75 1
    val isOctDigit : char -> bool = fn
a79 1
    val makestring : char -> string = fn
a86 1
    val scanc : ('a -> (char * 'a) option) -> 'a -> (char * 'a) option = fn
@


1.6
log
@updating answer file wrt changes made to streamIO.
@
text
@d2 1
d221 3
d227 3
a229 3
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : OSPrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val stdOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
@


1.5
log
@add __pre_char again
@
text
@a1 1
Compiling basis.general
d21 1
a21 1
    val EQUAL : General.order
d23 2
a24 2
    val GREATER : General.order
    val LESS : General.order
d26 1
a26 1
    val NONE : 'a General.option
d29 1
a29 1
    val SOME : 'a -> 'a General.option
d35 1
a35 1
    val getOpt : ('a General.option * 'a) -> 'a = fn
d37 1
a37 1
    val isSome : 'a General.option -> bool = fn
d39 1
a39 1
    val valOf : 'a General.option -> 'a = fn
d43 1
a44 1
Compiling basis.__pre_basis
a51 1
Compiling basis.__pre_char
d61 2
d64 1
a64 1
    val compare : (char * char) -> General.order = fn
d66 2
a67 2
    val fromCString : string -> char General.option = fn
    val fromString : string -> char General.option = fn
d76 1
d81 1
d88 2
a89 1
    val scan : ('a -> (char * 'a) General.option) -> 'a -> (char * 'a) General.option = fn
d91 1
a91 1
    val toCString : char -> string General.option = fn
d106 1
a106 1
    val appi : ((int * char) -> unit) -> (string * int * int General.option) -> unit = fn
d108 1
a108 1
    val extract : (string * int * int General.option) -> string = fn
d110 1
a110 1
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
d112 1
a112 1
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
d129 1
a129 1
        val appi : ((int * char) -> unit) -> (string * int * int General.option) -> unit = fn
d131 1
a131 1
        val extract : (string * int * int General.option) -> string = fn
d133 1
a133 1
        val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
d135 1
a135 1
        val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
d145 1
a145 1
    val appi : ((int * char) -> unit) -> (CharArray.array * int * int General.option) -> unit = fn
d147 3
a149 3
    val copy : {di: int, dst: CharArray.array, len: int General.option, si: int, src: CharArray.array} -> unit = fn
    val copyVec : {di: int, dst: CharArray.array, len: int General.option, si: int, src: string} -> unit = fn
    val extract : (CharArray.array * int * int General.option) -> string = fn
d151 1
a151 1
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int General.option) -> 'a = fn
d153 1
a153 1
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int General.option) -> 'a = fn
d158 1
a158 1
    val modifyi : ((int * char) -> char) -> (CharArray.array * int * int General.option) -> unit = fn
d204 1
a204 1
Compiling basis._primio
d209 1
d213 1
a213 1
structure PrimIO =
d220 8
a227 10
    val mkReader : {fd: PrimIO.file_desc, initialBlockMode: bool, initialPos: int, name: string} -> PrimIO.bin_reader = fn
    val mkWriter : {blocksize: int, fd: PrimIO.file_desc, initialBlockMode: bool, initialPos: int, name: string, size: int} -> PrimIO.bin_writer = fn
    val openApp : string -> PrimIO.bin_writer = fn
    val openRd : string -> PrimIO.bin_reader = fn
    val openWr : string -> PrimIO.bin_writer = fn
    val stdErr : PrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : PrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val stdOut : PrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val translateIn : 'a -> 'b = fn
    val translateOut : 'a -> 'b = fn
d240 2
a241 2
    val RD : {block: (unit -> unit) General.option, canInput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int) General.option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int General.option) General.option, readVec: (int -> string) General.option, readVecNB: (int -> string General.option) General.option, setPos: int -> unit} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) General.option, canOutput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, setPos: int -> unit, writeArr: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int) General.option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int General.option) General.option, writeVec: ({buf: string, i: int, sz: int General.option} -> int) General.option, writeVecNB: ({buf: string, i: int, sz: int General.option} -> int General.option) General.option} -> BinPrimIO.writer
d244 1
a244 1
    val compare : (int * int) -> General.order = fn
d257 5
a261 5
    val RD : {block: (unit -> unit) General.option, canInput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int General.option} -> int) General.option, readArrNB: ({buf: CharArray.array, i: int, sz: int General.option} -> int General.option) General.option, readVec: (int -> string) General.option, readVecNB: (int -> string General.option) General.option, setPos: int -> unit} -> PrimIO.text_reader
    val WR : {block: (unit -> unit) General.option, canOutput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, setPos: int -> unit, writeArr: ({buf: CharArray.array, i: int, sz: int General.option} -> int) General.option, writeArrNB: ({buf: CharArray.array, i: int, sz: int General.option} -> int General.option) General.option, writeVec: ({buf: string, i: int, sz: int General.option} -> int) General.option, writeVecNB: ({buf: string, i: int, sz: int General.option} -> int General.option) General.option} -> PrimIO.text_writer
    val augmentReader : PrimIO.text_reader -> PrimIO.text_reader = fn
    val augmentWriter : PrimIO.text_writer -> PrimIO.text_writer = fn
    val compare : (int * int) -> General.order = fn
a266 1
Compiling basis.osprimio
d278 1
a278 1
        type outstream = outstream
d282 1
a282 1
        val canInput : (TextIO.StreamIO.instream * int) -> int General.option = fn
d288 2
a289 2
        val getReader : TextIO.StreamIO.instream -> (PrimIO.text_reader * string) = fn
        val getWriter : TextIO.StreamIO.outstream -> (PrimIO.text_writer * buffer_mode(hidden)) = fn
d291 1
a291 1
        val input1 : TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) General.option = fn
d294 2
a295 2
        val mkInstream : (PrimIO.text_reader * string) -> TextIO.StreamIO.instream = fn
        val mkOutstream : (PrimIO.text_writer * buffer_mode(hidden)) -> TextIO.StreamIO.outstream = fn
d312 1
a312 1
    val input1 : TextIO.StreamIO.instream ref -> char General.option = fn
d316 1
a316 1
    val lookahead : TextIO.StreamIO.instream ref -> char General.option = fn
d328 1
a328 1
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), pos=ref(0), writer=WR {block=NONE, canOutput=NONE, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}})
d330 1
a330 1
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ..]), mode=ref(NO_BUF), pos=ref(0), writer=WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}})
d365 1
a365 1
        val compare : (OS.FileSys.file_id * OS.FileSys.file_id) -> General.order = fn
d383 1
a383 1
        val setTime : (string * time(hidden) General.option) -> unit = fn
d394 2
a395 2
        val compare : (PrimIO.file_desc * PrimIO.file_desc) -> General.order = fn
        val hash : PrimIO.file_desc -> word = fn
d400 3
a402 3
        val kind : PrimIO.file_desc -> OS.IO.io_desc_kind = fn
        val poll : (OS.IO.poll_desc list * time(hidden) General.option) -> OS.IO.poll_info list = fn
        val pollDesc : PrimIO.file_desc -> OS.IO.poll_desc General.option = fn
d406 1
a406 1
        val pollToIODesc : OS.IO.poll_desc -> PrimIO.file_desc = fn
d415 1
a415 1
        val ext : string -> string General.option = fn
d424 1
a424 1
        val joinBaseExt : {base: string, ext: string General.option} -> string = fn
d430 1
a430 1
        val splitBaseExt : string -> {base: string, ext: string General.option} = fn
d441 1
a441 1
        val getEnv : string -> string General.option = fn
d450 1
a450 1
    val syserror : string -> int General.option = fn
d458 1
a458 1
val amy : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), pos=ref(0), writer=WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Amy", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}})
d465 2
a466 2
val r : PrimIO.text_reader = RD {block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Arthur", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=fn}
val r2 : PrimIO.text_reader = RD {block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Arthur's twin", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=fn}
d481 1
a481 1
val w : PrimIO.text_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Amy", setPos=fn, writeArr=NONE, writeArrNB=NONE, writeVec=SOME fn, writeVecNB=NONE}
@


1.4
log
@recompiling.
@
text
@d44 1
a45 1
Compiling basis.string_cvt
d53 1
a62 2
    exception Dummy of char
    exception ToString of char
a75 1
    val isOctDigit : char -> bool = fn
a79 1
    val makestring : char -> string = fn
a86 1
    val scanc : ('a -> (char * 'a) General.option) -> 'a -> (char * 'a) General.option = fn
@


1.3
log
@recompiling.
@
text
@d1 486
a486 8
[Thread 1 dying due to uncaught exception "SysErr[<Pervasive>:1500,23 to 1500,58]" of {"No such file or directory", {1, 2}}
Stack backtrace
  102f9f8 closure 0x04001DCD
  103fee8 closure 0x00000014: raise
  103ff28 closure 0x0400418D: <handle>[ main._io:261]
  103ff70 closure 0x03000095: main[ interpreter._save_image:272]
  103ffc0 closure 0x00000004: ML stack start
]
@


1.2
log
@add more tests.
@
text
@d1 8
a8 487
val it : unit = ()
Compiling basis.general
Compiling basis.__general
structure General =
  struct
    type exn = exn
    datatype 'a option =
      NONE |
      SOME of 'a
    datatype order =
      EQUAL |
      GREATER |
      LESS
    eqtype unit = unit
    val ! : 'a ref -> 'a = fn
    val := : ('a ref * 'a) -> unit = fn
    val <> : (''a * ''a) -> bool = fn
    exception Bind
    exception Chr
    exception Div
    exception Domain
    val EQUAL : General.order
    exception Fail of string
    val GREATER : General.order
    val LESS : General.order
    exception Match
    val NONE : 'a General.option
    exception Option
    exception Overflow
    val SOME : 'a -> 'a General.option
    exception Size
    exception Subscript
    val before : ('a * unit) -> 'a = fn
    val exnMessage : exn -> string = fn
    val exnName : exn -> string = fn
    val getOpt : ('a General.option * 'a) -> 'a = fn
    val ignore : 'a -> unit = fn
    val isSome : 'a General.option -> bool = fn
    val o : (('a -> 'b) * ('c -> 'a)) -> 'c -> 'b = fn
    val valOf : 'a General.option -> 'a = fn
  end
val it : unit = ()
Compiling basis.toplevel
Compiling basis.__pre_basis
Compiling basis.string_cvt
Compiling basis.__pre_string_cvt
Compiling basis.__string_cvt
Compiling basis.char
Compiling basis.__preinteger
Compiling basis.__preint32
Compiling basis.integer
Compiling basis.__integer
Compiling basis.__char
structure Char =
  struct
    eqtype char = char
    eqtype string = string
    val < : (char * char) -> bool = fn
    val <= : (char * char) -> bool = fn
    val > : (char * char) -> bool = fn
    val >= : (char * char) -> bool = fn
    exception Dummy of char
    exception ToString of char
    val chr : int -> char = fn
    val compare : (char * char) -> General.order = fn
    val contains : string -> char -> bool = fn
    val fromCString : string -> char General.option = fn
    val fromString : string -> char General.option = fn
    val isAlpha : char -> bool = fn
    val isAlphaNum : char -> bool = fn
    val isAscii : char -> bool = fn
    val isCntrl : char -> bool = fn
    val isDigit : char -> bool = fn
    val isGraph : char -> bool = fn
    val isHexDigit : char -> bool = fn
    val isLower : char -> bool = fn
    val isOctDigit : char -> bool = fn
    val isPrint : char -> bool = fn
    val isPunct : char -> bool = fn
    val isSpace : char -> bool = fn
    val isUpper : char -> bool = fn
    val makestring : char -> string = fn
    val maxChar : char = #"\255"
    val maxOrd : int = 255
    val minChar : char = #"\000"
    val notContains : string -> char -> bool = fn
    val ord : char -> int = fn
    val pred : char -> char = fn
    val scan : ('a -> (char * 'a) General.option) -> 'a -> (char * 'a) General.option = fn
    val scanc : ('a -> (char * 'a) General.option) -> 'a -> (char * 'a) General.option = fn
    val succ : char -> char = fn
    val toCString : char -> string General.option = fn
    val toLower : char -> char = fn
    val toString : char -> string = fn
    val toUpper : char -> char = fn
  end
val it : unit = ()
Compiling basis.mono_vector
Compiling basis.list
Compiling basis.__list
Compiling basis.__charvector
structure CharVector =
  struct
    eqtype elem = char
    eqtype vector = string
    val app : (char -> unit) -> string -> unit = fn
    val appi : ((int * char) -> unit) -> (string * int * int General.option) -> unit = fn
    val concat : string list -> string = fn
    val extract : (string * int * int General.option) -> string = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
    val fromList : char list -> string = fn
    val length : string -> int = fn
    val maxLen : int = 16777196
    val sub : (string * int) -> char = fn
    val tabulate : (int * (int -> char)) -> string = fn
  end
val it : unit = ()
Compiling basis.mono_array
Compiling basis.__chararray
structure CharArray =
  struct
    structure Vector =
      struct
        eqtype elem = char
        eqtype vector = string
        val app : (char -> unit) -> string -> unit = fn
        val appi : ((int * char) -> unit) -> (string * int * int General.option) -> unit = fn
        val concat : string list -> string = fn
        val extract : (string * int * int General.option) -> string = fn
        val foldl : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
        val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
        val foldr : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
        val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int General.option) -> 'a = fn
        val fromList : char list -> string = fn
        val length : string -> int = fn
        val maxLen : int = 16777196
        val sub : (string * int) -> char = fn
        val tabulate : (int * (int -> char)) -> string = fn
      end
    eqtype array = array
    eqtype elem = char
    val app : (char -> unit) -> CharArray.array -> unit = fn
    val appi : ((int * char) -> unit) -> (CharArray.array * int * int General.option) -> unit = fn
    val array : (int * char) -> CharArray.array = fn
    val copy : {di: int, dst: CharArray.array, len: int General.option, si: int, src: CharArray.array} -> unit = fn
    val copyVec : {di: int, dst: CharArray.array, len: int General.option, si: int, src: string} -> unit = fn
    val extract : (CharArray.array * int * int General.option) -> string = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> CharArray.array -> 'a = fn
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int General.option) -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> CharArray.array -> 'a = fn
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int General.option) -> 'a = fn
    val fromList : char list -> CharArray.array = fn
    val length : CharArray.array -> int = fn
    val maxLen : int = 16777196
    val modify : (char -> char) -> CharArray.array -> unit = fn
    val modifyi : ((int * char) -> char) -> (CharArray.array * int * int General.option) -> unit = fn
    val sub : (CharArray.array * int) -> char = fn
    val tabulate : (int * (int -> char)) -> CharArray.array = fn
    val update : (CharArray.array * int * char) -> unit = fn
  end
val it : unit = ()
Compiling basis.__preword32
Compiling basis.__preword
Compiling basis.word
Compiling basis.__word
Compiling basis.__word8
Compiling basis.__word8vector
Compiling basis.__word8array
Compiling basis.__position
Compiling basis.math
Compiling basis.__math
Compiling basis.ieeereal
Compiling basis.__ieeereal
Compiling basis.__prereal
Compiling basis.real
Compiling basis.__real
Compiling basis.time
Compiling unix.__time
Compiling basis.os_file_sys
Compiling basis.os_path
Compiling basis.os_process
Compiling basis.os_io
Compiling basis.os
Compiling basis.__word32
Compiling unix.unixos
Compiling unix._os
Compiling unix._unixos
Compiling unix.__unixos
Compiling basis.string
Compiling basis.__string
Compiling unix.__os_path
Compiling unix._os_file_sys
Compiling unix.__os_file_sys
Compiling basis.__exit
Compiling basis.exit
Compiling basis._os_process
Compiling basis.__os_process
Compiling unix._os_io
Compiling unix.__os_io
Compiling unix.__os
Compiling basis.prim_io
Compiling basis._primio
Compiling basis.io
Compiling basis.__io
Compiling basis.stream_io
Compiling basis._streamio
Compiling basis.__bin_prim_io
Compiling basis.__text_prim_io
Compiling unix.__primio
structure PrimIO =
  struct
    type bin_reader = reader
    type bin_writer = writer
    eqtype file_desc = file_desc
    type text_reader = reader
    type text_writer = writer
    val mkReader : {fd: PrimIO.file_desc, initialBlockMode: bool, initialPos: int, name: string} -> PrimIO.bin_reader = fn
    val mkWriter : {blocksize: int, fd: PrimIO.file_desc, initialBlockMode: bool, initialPos: int, name: string, size: int} -> PrimIO.bin_writer = fn
    val openApp : string -> PrimIO.bin_writer = fn
    val openRd : string -> PrimIO.bin_reader = fn
    val openWr : string -> PrimIO.bin_writer = fn
    val stdErr : PrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : PrimIO.bin_reader = RD {block=NONE, canInput=SOME fn, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=fn}
    val stdOut : PrimIO.bin_writer = WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val translateIn : 'a -> 'b = fn
    val translateOut : 'a -> 'b = fn
  end
val it : unit = ()
structure BinPrimIO =
  struct
    eqtype array = array
    eqtype elem = word8
    eqtype pos = int
    datatype reader =
      RD of {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: pos -> unit}
    eqtype vector = string
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, setPos: pos -> unit, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {block: (unit -> unit) General.option, canInput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int) General.option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int General.option) General.option, readVec: (int -> string) General.option, readVecNB: (int -> string General.option) General.option, setPos: int -> unit} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) General.option, canOutput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, setPos: int -> unit, writeArr: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int) General.option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int General.option} -> int General.option) General.option, writeVec: ({buf: string, i: int, sz: int General.option} -> int) General.option, writeVecNB: ({buf: string, i: int, sz: int General.option} -> int General.option) General.option} -> BinPrimIO.writer
    val augmentReader : BinPrimIO.reader -> BinPrimIO.reader = fn
    val augmentWriter : BinPrimIO.writer -> BinPrimIO.writer = fn
    val compare : (int * int) -> General.order = fn
  end
val it : unit = ()
structure TextPrimIO =
  struct
    eqtype array = array
    eqtype elem = char
    eqtype pos = int
    datatype reader =
      RD of {block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: pos -> unit}
    eqtype vector = string
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: unit -> pos, getPos: unit -> pos, ioDesc: file_desc option, name: string, setPos: pos -> unit, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {block: (unit -> unit) General.option, canInput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int General.option} -> int) General.option, readArrNB: ({buf: CharArray.array, i: int, sz: int General.option} -> int General.option) General.option, readVec: (int -> string) General.option, readVecNB: (int -> string General.option) General.option, setPos: int -> unit} -> PrimIO.text_reader
    val WR : {block: (unit -> unit) General.option, canOutput: (unit -> bool) General.option, chunkSize: int, close: unit -> unit, endPos: unit -> int, getPos: unit -> int, ioDesc: PrimIO.file_desc General.option, name: string, setPos: int -> unit, writeArr: ({buf: CharArray.array, i: int, sz: int General.option} -> int) General.option, writeArrNB: ({buf: CharArray.array, i: int, sz: int General.option} -> int General.option) General.option, writeVec: ({buf: string, i: int, sz: int General.option} -> int) General.option, writeVecNB: ({buf: string, i: int, sz: int General.option} -> int General.option) General.option} -> PrimIO.text_writer
    val augmentReader : PrimIO.text_reader -> PrimIO.text_reader = fn
    val augmentWriter : PrimIO.text_writer -> PrimIO.text_writer = fn
    val compare : (int * int) -> General.order = fn
  end
val it : unit = ()
Compiling basis.__stream_io
Compiling basis.imperative_io
Compiling basis._imperative_io
Compiling basis.osprimio
Compiling basis.substring
Compiling basis.__substring
Compiling basis.text_io
Compiling basis._text_io
Compiling basis.__text_io
structure TextIO =
  struct
    structure StreamIO =
      struct
        eqtype elem = char
        type instream = instream
        type outstream = outstream
        type reader = reader
        eqtype vector = string
        type writer = writer
        val canInput : (TextIO.StreamIO.instream * int) -> int General.option = fn
        val closeIn : TextIO.StreamIO.instream -> unit = fn
        val closeOut : TextIO.StreamIO.outstream -> unit = fn
        val endOfStream : TextIO.StreamIO.instream -> bool = fn
        val flushOut : TextIO.StreamIO.outstream -> unit = fn
        val getBufferMode : TextIO.StreamIO.outstream -> buffer_mode(hidden) = fn
        val getReader : TextIO.StreamIO.instream -> (PrimIO.text_reader * string) = fn
        val getWriter : TextIO.StreamIO.outstream -> (PrimIO.text_writer * buffer_mode(hidden)) = fn
        val input : TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) = fn
        val input1 : TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) General.option = fn
        val inputAll : TextIO.StreamIO.instream -> string = fn
        val inputN : (TextIO.StreamIO.instream * int) -> (string * TextIO.StreamIO.instream) = fn
        val mkInstream : (PrimIO.text_reader * string) -> TextIO.StreamIO.instream = fn
        val mkOutstream : (PrimIO.text_writer * buffer_mode(hidden)) -> TextIO.StreamIO.outstream = fn
        val output : (TextIO.StreamIO.outstream * string) -> unit = fn
        val output1 : (TextIO.StreamIO.outstream * char) -> unit = fn
        val setBufferMode : (TextIO.StreamIO.outstream * buffer_mode(hidden)) -> unit = fn
      end
    eqtype elem = char
    eqtype instream = instream ref
    eqtype outstream = outstream ref
    eqtype vector = string
    val canInput : (TextIO.StreamIO.instream ref * int) -> bool = fn
    val closeIn : TextIO.StreamIO.instream ref -> unit = fn
    val closeOut : TextIO.StreamIO.outstream ref -> unit = fn
    val endOfStream : TextIO.StreamIO.instream ref -> bool = fn
    val flushOut : TextIO.StreamIO.outstream ref -> unit = fn
    val getInstream : TextIO.StreamIO.instream ref -> TextIO.StreamIO.instream = fn
    val getOutstream : TextIO.StreamIO.outstream ref -> TextIO.StreamIO.outstream = fn
    val input : TextIO.StreamIO.instream ref -> string = fn
    val input1 : TextIO.StreamIO.instream ref -> char General.option = fn
    val inputAll : TextIO.StreamIO.instream ref -> string = fn
    val inputLine : TextIO.StreamIO.instream ref -> string = fn
    val inputN : (TextIO.StreamIO.instream ref * int) -> string = fn
    val lookahead : TextIO.StreamIO.instream ref -> char General.option = fn
    val mkInstream : TextIO.StreamIO.instream -> TextIO.StreamIO.instream ref = fn
    val mkOutstream : TextIO.StreamIO.outstream -> TextIO.StreamIO.outstream ref = fn
    val openAppend : string -> TextIO.StreamIO.outstream ref = fn
    val openIn : string -> TextIO.StreamIO.instream ref = fn
    val openOut : string -> TextIO.StreamIO.outstream ref = fn
    val output : (TextIO.StreamIO.outstream ref * string) -> unit = fn
    val output1 : (TextIO.StreamIO.outstream ref * char) -> unit = fn
    val outputSubstr : (TextIO.StreamIO.outstream ref * substring(hidden)) -> unit = fn
    val print : string -> unit = fn
    val setInstream : (TextIO.StreamIO.instream ref * TextIO.StreamIO.instream) -> unit = fn
    val setOutstream : (TextIO.StreamIO.outstream ref * TextIO.StreamIO.outstream) -> unit = fn
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), pos=ref(0), writer=WR {block=NONE, canOutput=NONE, chunkSize=1, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdErr>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}})
    val stdIn : TextIO.StreamIO.instream ref = Output test succeeded
ref(In {buffer=Buf {basePos=_, data=_, emptyMeansEof=false, more=ref(GETmore ..), name="<stdIn>"}, pos=0})
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ..]), mode=ref(NO_BUF), pos=ref(0), writer=WR {block=NONE, canOutput=NONE, chunkSize=8192, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="<stdOut>", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}})
  end
val it : unit = ()
structure IO =
  struct
    datatype buffer_mode =
      BLOCK_BUF |
      LINE_BUF |
      NO_BUF
    val BLOCK_BUF : IO.buffer_mode
    exception BlockingNotSupported
    exception ClosedStream
    exception Io of {cause: exn, function: string, name: string}
    val LINE_BUF : IO.buffer_mode
    val NO_BUF : IO.buffer_mode
    exception NonblockingNotSupported
    exception TerminatedStream
  end
val it : unit = ()
structure OS =
  struct
    structure FileSys =
      struct
        datatype access_mode =
          A_EXEC |
          A_READ |
          A_WRITE
        eqtype dirstream = dirstream
        eqtype file_id = file_id
        val A_EXEC : OS.FileSys.access_mode
        val A_READ : OS.FileSys.access_mode
        val A_WRITE : OS.FileSys.access_mode
        val access : (string * OS.FileSys.access_mode list) -> bool = fn
        val chDir : string -> unit = fn
        val closeDir : OS.FileSys.dirstream -> unit = fn
        val compare : (OS.FileSys.file_id * OS.FileSys.file_id) -> General.order = fn
        val fileId : string -> OS.FileSys.file_id = fn
        val fileSize : string -> int = fn
        val fullPath : string -> string = fn
        val getDir : unit -> string = fn
        val hash : OS.FileSys.file_id -> word = fn
        val isDir : string -> bool = fn
        val isLink : string -> bool = fn
        val mkDir : string -> unit = fn
        val modTime : string -> time(hidden) = fn
        val openDir : string -> OS.FileSys.dirstream = fn
        val readDir : OS.FileSys.dirstream -> string = fn
        val readLink : string -> string = fn
        val realPath : string -> string = fn
        val remove : string -> unit = fn
        val rename : {new: string, old: string} -> unit = fn
        val rewindDir : OS.FileSys.dirstream -> unit = fn
        val rmDir : string -> unit = fn
        val setTime : (string * time(hidden) General.option) -> unit = fn
        val tmpName : unit -> string = fn
      end
    structure IO =
      struct
        structure Kind = struct ... end
        eqtype io_desc = file_desc
        eqtype io_desc_kind = io_desc_kind
        eqtype poll_desc = poll_desc
        eqtype poll_info = poll_info
        exception Poll
        val compare : (PrimIO.file_desc * PrimIO.file_desc) -> General.order = fn
        val hash : PrimIO.file_desc -> word = fn
        val infoToPollDesc : OS.IO.poll_info -> OS.IO.poll_desc = fn
        val isIn : OS.IO.poll_info -> bool = fn
        val isOut : OS.IO.poll_info -> bool = fn
        val isPri : OS.IO.poll_info -> bool = fn
        val kind : PrimIO.file_desc -> OS.IO.io_desc_kind = fn
        val poll : (OS.IO.poll_desc list * time(hidden) General.option) -> OS.IO.poll_info list = fn
        val pollDesc : PrimIO.file_desc -> OS.IO.poll_desc General.option = fn
        val pollIn : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollOut : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollPri : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollToIODesc : OS.IO.poll_desc -> PrimIO.file_desc = fn
      end
    structure Path =
      struct
        exception Path
        val base : string -> string = fn
        val concat : (string * string) -> string = fn
        val currentArc : string = "."
        val dir : string -> string = fn
        val ext : string -> string General.option = fn
        val file : string -> string = fn
        val fromString : string -> {arcs: string list, isAbs: bool, vol: string} = fn
        val getParent : string -> string = fn
        val getVolume : string -> string = fn
        val isAbsolute : string -> bool = fn
        val isCanonical : string -> bool = fn
        val isRelative : string -> bool = fn
        val isRoot : string -> bool = fn
        val joinBaseExt : {base: string, ext: string General.option} -> string = fn
        val joinDirFile : {dir: string, file: string} -> string = fn
        val mkAbsolute : (string * string) -> string = fn
        val mkCanonical : string -> string = fn
        val mkRelative : (string * string) -> string = fn
        val parentArc : string = ".."
        val splitBaseExt : string -> {base: string, ext: string General.option} = fn
        val splitDirFile : string -> {dir: string, file: string} = fn
        val toString : {arcs: string list, isAbs: bool, vol: string} -> string = fn
        val validVolume : {isAbs: bool, vol: string} -> bool = fn
      end
    structure Process =
      struct
        eqtype status = int
        val atExit : (unit -> unit) -> unit = fn
        val exit : int -> 'a = fn
        val failure : int = 1
        val getEnv : string -> string General.option = fn
        val success : int = 0
        val system : string -> int = fn
        val terminate : int -> 'a = fn
      end
    eqtype syserror = int
    exception SysErr of (string * syserror option)
    val errorMsg : int -> string = fn
    val errorName : int -> string = fn
    val syserror : string -> int General.option = fn
  end
test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
val amy : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[83, 101, 118, 101, 110, 32, 69, 105, 103, 104, ..]), mode=ref(LINE_BUF), pos=ref(0), writer=WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Amy", setPos=fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}})
val arthur : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="Arthur"}, pos=5})
val comm_2 : string ref = ref("BBBBB")
val comm_medium : string ref = ref("AAAAA")
val interleave : TextIO.StreamIO.instream ref -> TextIO.StreamIO.instream -> string = fn
val pos : int ref = ref(5)
val pos2 : int ref = ref(5)
val r : PrimIO.text_reader = RD {block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Arthur", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=fn}
val r2 : PrimIO.text_reader = RD {block=SOME fn, canInput=SOME fn, chunkSize=5, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Arthur's twin", readArr=NONE, readArrNB=NONE, readVec=SOME fn, readVecNB=NONE, setPos=fn}
val reportOK : bool -> unit = fn
val ruhtra : TextIO.StreamIO.instream = In {buffer=Buf {basePos=_, data=_, emptyMeansEof=false, more=ref(ISmore(Buf ..)), name="Arthur's twin"}, pos=0}
val s : string = "Oh the grand old Duke of York,\nHe had a leg of Pork,\nHe marched it up to the Microwave,\nAnd he ate it with a fork.\n\n\nFile created by test_suite/basis/imperative_io.sml"
val s'_1 : string = "Oh the grand old Duke of York,\n"
val s'_2 : string = "He had a leg of Pork,\nHe marched it up to the Microwave,\nAnd he ate it with a fork.\n\n\nFile created by test_suite/basis/imperative_io.smlSome enchanted evening,..."
val s_1 : string = "Oh the grand old Duke of York,\n"
val s_2 : string = "He had a leg of Pork,\n"
val s_3 : string = "He marched it up to the Microwave,\n"
val s_4 : string = "And he ate it with a fork.\n"
val s_5 : string = "\n\nFile created by test_suite/basis/imperative_io.sml"
val s_6 : string = "Some enchanted evening,..."
val test1 : bool = true
val test2 : bool = true
val the_answer : string = "One Two Three\n1Four Five Six\nSeven Eight Nine."
val w : PrimIO.text_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=20, close=fn, endPos=fn, getPos=fn, ioDesc=NONE, name="Amy", setPos=fn, writeArr=NONE, writeArrNB=NONE, writeVec=SOME fn, writeVecNB=NONE}
val x : unit = ()
val y : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="123"}, pos=193})
@


1.1
log
@new unit
Answer file for imperative IO test.
@
text
@d332 2
a333 2
    val stdIn : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=_, data=_, eOutput test succeeded
mptyMeansEof=false, more=ref(GETmore ..), name="<stdIn>"}, pos=0})
d460 2
d474 2
d481 1
d487 1
a487 1
val y : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=_, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="123"}, pos=167})
@
