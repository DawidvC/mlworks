head	1.3;
access;
symbols
	MLWorks_21c0_1999_03_25:1.3
	MLWorks_20c1_1998_08_20:1.3
	MLWorks_20c0_1998_08_04:1.3
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_20m1_1997_10_23:1.1
	MLWorks_20m0_1997_06_20:1.1;
locks; strict;
comment	@# @;


1.3
date	98.07.08.14.40.01;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	97.11.25.19.19.45;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	97.05.23.12.40.06;	author jkbrook;	state Exp;
branches;
next	;


desc
@new unit
Answer file for large_word.sml
@


1.3
log
@[Bug #70106]
Avoid getting LargeWord into answers, since it can appear as flags
@
text
@val it : bool = true
@


1.2
log
@[Bug #30323]
@
text
@d1 1
a1 1
val it : LargeWord.word = 0w3
@


1.1
log
@new unit
Answer file for large_word.sml
@
text
@a0 38
val it : unit = ()
structure LargeWord =
  struct
    eqtype word = word32
    val * : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val + : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val - : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val < : (LargeWord.word * LargeWord.word) -> bool = fn
    val << : (LargeWord.word * word) -> LargeWord.word = fn
    val <= : (LargeWord.word * LargeWord.word) -> bool = fn
    val > : (LargeWord.word * LargeWord.word) -> bool = fn
    val >= : (LargeWord.word * LargeWord.word) -> bool = fn
    val >> : (LargeWord.word * word) -> LargeWord.word = fn
    val andb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val compare : (LargeWord.word * LargeWord.word) -> order = fn
    val div : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val fmt : radix(hidden) -> LargeWord.word -> string = fn
    val fromInt : int -> LargeWord.word = fn
    val fromLargeInt : MLWorks.Internal.Types.int32 -> LargeWord.word = fn
    val fromLargeWord : LargeWord.word -> LargeWord.word = fn
    val fromString : string -> LargeWord.word option = fn
    val max : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val min : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val mod : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val notb : LargeWord.word -> LargeWord.word = fn
    val orb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option = fn
    val toInt : LargeWord.word -> int = fn
    val toIntX : LargeWord.word -> int = fn
    val toLargeInt : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeIntX : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeWord : LargeWord.word -> LargeWord.word = fn
    val toLargeWordX : LargeWord.word -> LargeWord.word = fn
    val toString : LargeWord.word -> string = fn
    val wordSize : int = 32
    val xorb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val ~>> : (LargeWord.word * word) -> LargeWord.word = fn
  end
@
