head	1.12;
access;
symbols
	MLWorks_21c0_1999_03_25:1.12
	MLWorks_20c1_1998_08_20:1.12
	MLWorks_20c0_1998_08_04:1.12
	MLWorks_20b2c2_1998_06_19:1.12
	MLWorks_20b2_Windows_1998_06_12:1.12
	MLWorks_20b1c1_1998_05_07:1.12
	MLWorks_20b0_1998_04_07:1.12
	MLWorks_20b0_1998_03_20:1.12
	MLWorks_20m2_1998_02_16:1.12
	MLWorks_20m1_1997_10_23:1.11
	MLWorks_11r1:1.11.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.11.1.1.1.1
	MLWorks_10r3:1.11.1.1.3
	MLWorks_10r2_551:1.11.1.1.2
	MLWorks_11:1.11.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.11.1.1
	MLWorks_20m0_1997_06_20:1.11
	MLWorks_1_0_r2c2_1997_06_14:1.11.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.11.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.11.1
	MLWorks_BugFix_1997_04_24:1.11
	MLWorks_1_0_r2_Win32_1997_04_11:1.11
	MLWorks_1_0_r2_Unix_1997_04_04:1.11
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.3.1.1
	MLWorks_gui_1996_12_18:1.8.4
	MLWorks_1_0_Win32_1996_12_17:1.8.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.1.1
	MLWorks_1_0_Irix_1996_11_28:1.8.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.2
	MLWorks_1_0_Unix_1996_11_14:1.8.1
	MLWorks_Open_Beta2_1996_10_11:1.7.2
	MLWorks_License_dev:1.7.1
	MLWorks_1_open_beta_1996_09_13:1.6.1
	MLWorks_Open_Beta_1996_08_22:1.1;
locks; strict;
comment	@# @;


1.12
date	97.11.25.19.21.11;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	97.04.02.21.44.15;	author jont;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	97.03.05.11.44.18;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	97.02.26.12.28.35;	author andreww;	state Exp;
branches;
next	1.8;

1.8
date	96.11.08.15.18.54;	author matthew;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1;
next	1.7;

1.7
date	96.09.18.15.20.10;	author io;	state Exp;
branches
	1.7.1.1
	1.7.2.1;
next	1.6;

1.6
date	96.09.09.11.14.02;	author io;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	96.09.07.00.02.28;	author io;	state Exp;
branches;
next	1.4;

1.4
date	96.08.29.09.11.12;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	96.08.27.09.43.44;	author andreww;	state Exp;
branches;
next	1.2;

1.2
date	96.08.22.12.26.28;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	96.08.16.15.18.23;	author stephenb;	state Exp;
branches;
next	;

1.6.1.1
date	96.09.13.11.38.23;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	96.10.07.16.29.44;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.10.17.11.50.26;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.11.14.13.17.50;	author hope;	state Exp;
branches
	1.8.1.1.1.1;
next	;

1.8.1.1.1.1
date	96.11.28.15.28.21;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.11.22.18.35.39;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.12.17.18.14.37;	author hope;	state Exp;
branches
	1.8.3.1.1.1;
next	;

1.8.3.1.1.1
date	97.02.24.12.07.33;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.12.18.10.09.35;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	97.05.12.11.08.12;	author hope;	state Exp;
branches
	1.11.1.1.1.1
	1.11.1.1.2.1
	1.11.1.1.3.1;
next	;

1.11.1.1.1.1
date	97.07.28.18.50.09;	author daveb;	state Exp;
branches
	1.11.1.1.1.1.1.1;
next	;

1.11.1.1.1.1.1.1
date	97.10.07.12.15.17;	author jkbrook;	state Exp;
branches;
next	;

1.11.1.1.2.1
date	97.09.08.17.41.59;	author daveb;	state Exp;
branches;
next	;

1.11.1.1.3.1
date	97.09.09.14.41.24;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.12
log
@[Bug #30323]
@
text
@val ans : ((string * (bool * bool * bool)) * (string * (bool * bool)) * (string * bool) * (string * bool)) = (("compare", (true, true, true)), ("kind", (true, true)), ("pollDescA", true), ("pollDescB", true))
val applyToInDesc : string -> (OS.IO.iodesc -> 'a) -> 'a = fn
val applyToOutDesc : string -> (OS.IO.iodesc -> 'a) -> 'a = fn
val compare_test : (OS.IO.iodesc * OS.IO.iodesc) -> (bool * bool * bool) = fn
val kind_test : (OS.IO.iodesc * OS.IO.iodesc) -> (bool * bool) = fn
val pollDesc_test : OS.IO.iodesc -> bool = fn
@


1.11
log
@Modify to stop displaying syserror type
@
text
@a0 4
structure OS = struct ... end
structure TextIO = struct ... end
structure TextPrimIO = struct ... end
structure Substring = struct ... end
@


1.11.1.1
log
@branched from 1.11
@
text
@@


1.11.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.11.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.11.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.11.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.10
log
@Modify because Path now has toUnixPath and fromUnixPath
@
text
@d1 4
a4 268
val it : unit = ()
structure OS =
  struct
    structure FileSys =
      struct
        datatype access_mode =
          A_EXEC |
          A_READ |
          A_WRITE
        eqtype dirstream = dirstream
        eqtype file_id = file_id
        val A_EXEC : OS.FileSys.access_mode
        val A_READ : OS.FileSys.access_mode
        val A_WRITE : OS.FileSys.access_mode
        val access : (string * OS.FileSys.access_mode list) -> bool = fn
        val chDir : string -> unit = fn
        val closeDir : OS.FileSys.dirstream -> unit = fn
        val compare : (OS.FileSys.file_id * OS.FileSys.file_id) -> order = fn
        val fileId : string -> OS.FileSys.file_id = fn
        val fileSize : string -> int = fn
        val fullPath : string -> string = fn
        val getDir : unit -> string = fn
        val hash : OS.FileSys.file_id -> word = fn
        val isDir : string -> bool = fn
        val isLink : string -> bool = fn
        val mkDir : string -> unit = fn
        val modTime : string -> time(hidden) = fn
        val openDir : string -> OS.FileSys.dirstream = fn
        val readDir : OS.FileSys.dirstream -> string = fn
        val readLink : string -> string = fn
        val realPath : string -> string = fn
        val remove : string -> unit = fn
        val rename : {new: string, old: string} -> unit = fn
        val rewindDir : OS.FileSys.dirstream -> unit = fn
        val rmDir : string -> unit = fn
        val setTime : (string * time(hidden) option) -> unit = fn
        val tmpName : unit -> string = fn
      end
    structure IO =
      struct
        structure Kind = struct ... end
        eqtype iodesc = iodesc
        eqtype iodesc_kind = iodesc_kind
        eqtype poll_desc = poll_desc
        eqtype poll_info = poll_info
        exception Poll
        val compare : (OS.IO.iodesc * OS.IO.iodesc) -> order = fn
        val hash : OS.IO.iodesc -> word = fn
        val infoToPollDesc : OS.IO.poll_info -> OS.IO.poll_desc = fn
        val isIn : OS.IO.poll_info -> bool = fn
        val isOut : OS.IO.poll_info -> bool = fn
        val isPri : OS.IO.poll_info -> bool = fn
        val kind : OS.IO.iodesc -> OS.IO.iodesc_kind = fn
        val poll : (OS.IO.poll_desc list * time(hidden) option) -> OS.IO.poll_info list = fn
        val pollDesc : OS.IO.iodesc -> OS.IO.poll_desc option = fn
        val pollIn : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollOut : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollPri : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollToIODesc : OS.IO.poll_desc -> OS.IO.iodesc = fn
      end
    structure Path =
      struct
        exception Path
        val base : string -> string = fn
        val concat : (string * string) -> string = fn
        val currentArc : string = "."
        val dir : string -> string = fn
        val ext : string -> string option = fn
        val file : string -> string = fn
        val fromString : string -> {arcs: string list, isAbs: bool, vol: string} = fn
        val fromUnixPath : string -> string = fn
        val getParent : string -> string = fn
        val getVolume : string -> string = fn
        val isAbsolute : string -> bool = fn
        val isCanonical : string -> bool = fn
        val isRelative : string -> bool = fn
        val isRoot : string -> bool = fn
        val joinBaseExt : {base: string, ext: string option} -> string = fn
        val joinDirFile : {dir: string, file: string} -> string = fn
        val mkAbsolute : (string * string) -> string = fn
        val mkCanonical : string -> string = fn
        val mkRelative : (string * string) -> string = fn
        val parentArc : string = ".."
        val splitBaseExt : string -> {base: string, ext: string option} = fn
        val splitDirFile : string -> {dir: string, file: string} = fn
        val toString : {arcs: string list, isAbs: bool, vol: string} -> string = fn
        val toUnixPath : string -> string = fn
        val validVolume : {isAbs: bool, vol: string} -> bool = fn
      end
    structure Process =
      struct
        eqtype status = int
        val atExit : (unit -> unit) -> unit = fn
        val exit : int -> 'a = fn
        val failure : int = 1
        val getEnv : string -> string option = fn
        val success : int = 0
        val system : string -> int = fn
        val terminate : int -> 'a = fn
      end
    eqtype syserror = int
    exception SysErr of (string * syserror option)
    val errorMsg : int -> string = fn
    val errorName : int -> string = fn
    val syserror : string -> int option = fn
  end
val it : unit = ()
structure TextIO =
  struct
    structure StreamIO =
      struct
        eqtype elem = char
        type in_pos = in_pos
        type instream = instream
        type out_pos = out_pos
        eqtype outstream = outstream
        eqtype pos = int
        type reader = reader
        eqtype vector = string
        type writer = writer
        val canInput : (TextIO.StreamIO.instream * int) -> int option = fn
        val closeIn : TextIO.StreamIO.instream -> unit = fn
        val closeOut : TextIO.StreamIO.outstream -> unit = fn
        val endOfStream : TextIO.StreamIO.instream -> bool = fn
        val filePosIn : TextIO.StreamIO.in_pos -> int = fn
        val filePosOut : TextIO.StreamIO.out_pos -> int = fn
        val flushOut : TextIO.StreamIO.outstream -> unit = fn
        val getBufferMode : TextIO.StreamIO.outstream -> buffer_mode(hidden) = fn
        val getPosIn : TextIO.StreamIO.instream -> TextIO.StreamIO.in_pos = fn
        val getPosOut : TextIO.StreamIO.outstream -> TextIO.StreamIO.out_pos = fn
        val getReader : TextIO.StreamIO.instream -> (reader(hidden) * string) = fn
        val getWriter : TextIO.StreamIO.outstream -> (writer(hidden) * buffer_mode(hidden)) = fn
        val input : TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) = fn
        val input1 : TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option = fn
        val inputAll : TextIO.StreamIO.instream -> string = fn
        val inputLine : TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) = fn
        val inputN : (TextIO.StreamIO.instream * int) -> (string * TextIO.StreamIO.instream) = fn
        val mkInstream : (reader(hidden) * string) -> TextIO.StreamIO.instream = fn
        val mkOutstream : (writer(hidden) * buffer_mode(hidden)) -> TextIO.StreamIO.outstream = fn
        val output : (TextIO.StreamIO.outstream * string) -> unit = fn
        val output1 : (TextIO.StreamIO.outstream * char) -> unit = fn
        val outputSubstr : (TextIO.StreamIO.outstream * substring(hidden)) -> unit = fn
        val setBufferMode : (TextIO.StreamIO.outstream * buffer_mode(hidden)) -> unit = fn
        val setPosIn : TextIO.StreamIO.in_pos -> TextIO.StreamIO.instream = fn
        val setPosOut : TextIO.StreamIO.out_pos -> TextIO.StreamIO.outstream = fn
      end
    eqtype elem = char
    eqtype instream = instream ref
    eqtype outstream = outstream ref
    eqtype vector = string
    val canInput : (TextIO.StreamIO.instream ref * int) -> bool = fn
    val closeIn : TextIO.StreamIO.instream ref -> unit = fn
    val closeOut : TextIO.StreamIO.outstream ref -> unit = fn
    val endOfStream : TextIO.StreamIO.instream ref -> bool = fn
    val flushOut : TextIO.StreamIO.outstream ref -> unit = fn
    val getInstream : TextIO.StreamIO.instream ref -> TextIO.StreamIO.instream = fn
    val getOutstream : TextIO.StreamIO.outstream ref -> TextIO.StreamIO.outstream = fn
    val getPosIn : TextIO.StreamIO.instream ref -> TextIO.StreamIO.in_pos = fn
    val getPosOut : TextIO.StreamIO.outstream ref -> TextIO.StreamIO.out_pos = fn
    val input : TextIO.StreamIO.instream ref -> string = fn
    val input1 : TextIO.StreamIO.instream ref -> char option = fn
    val inputAll : TextIO.StreamIO.instream ref -> string = fn
    val inputLine : TextIO.StreamIO.instream ref -> string = fn
    val inputN : (TextIO.StreamIO.instream ref * int) -> string = fn
    val lookahead : TextIO.StreamIO.instream ref -> char option = fn
    val mkInstream : TextIO.StreamIO.instream -> TextIO.StreamIO.instream ref = fn
    val mkOutstream : TextIO.StreamIO.outstream -> TextIO.StreamIO.outstream ref = fn
    val openAppend : string -> TextIO.StreamIO.outstream ref = fn
    val openIn : string -> TextIO.StreamIO.instream ref = fn
    val openOut : string -> TextIO.StreamIO.outstream ref = fn
    val openString : string -> TextIO.StreamIO.instream ref = fn
    val output : (TextIO.StreamIO.outstream ref * string) -> unit = fn
    val output1 : (TextIO.StreamIO.outstream ref * char) -> unit = fn
    val outputSubstr : (TextIO.StreamIO.outstream ref * substring(hidden)) -> unit = fn
    val print : string -> unit = fn
    val scanStream : ((TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option) -> TextIO.StreamIO.instream -> ('a * TextIO.StreamIO.instream) option) -> TextIO.StreamIO.instream ref -> 'a option = fn
    val setInstream : (TextIO.StreamIO.instream ref * TextIO.StreamIO.instream) -> unit = fn
    val setOutstream : (TextIO.StreamIO.outstream ref * TextIO.StreamIO.outstream) -> unit = fn
    val setPosIn : (TextIO.StreamIO.instream ref * TextIO.StreamIO.in_pos) -> unit = fn
    val setPosOut : (TextIO.StreamIO.outstream ref * TextIO.StreamIO.out_pos) -> unit = fn
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(PUTmore WR ..)})
    val stdIn : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=false, more=ref(GETmore ..), name="<stdIn>"}, pos=0})
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(PUTmore WR ..)})
  end
val it : unit = ()
structure TextPrimIO =
  struct
    eqtype array = array
    eqtype elem = char
    eqtype pos = int
    datatype reader =
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
    eqtype vector = string
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OS.IO.iodesc option, name: string, readArr: ({buf: TextPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: TextPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> TextPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OS.IO.iodesc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: TextPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: TextPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> TextPrimIO.writer
    val augmentReader : TextPrimIO.reader -> TextPrimIO.reader = fn
    val augmentWriter : TextPrimIO.writer -> TextPrimIO.writer = fn
    val compare : (int * int) -> order = fn
  end
val it : unit = ()
structure Substring =
  struct
    structure String =
      struct
        structure Char = struct ... end
        eqtype char = char
        eqtype string = string
        val < : (string * string) -> bool = fn
        val <= : (string * string) -> bool = fn
        val > : (string * string) -> bool = fn
        val >= : (string * string) -> bool = fn
        val ^ : (string * string) -> string = fn
        val collate : ((char * char) -> order) -> (string * string) -> order = fn
        val compare : (string * string) -> order = fn
        val concat : string list -> string = fn
        val explode : string -> char list = fn
        val extract : (string * int * int option) -> string = fn
        val fields : (char -> bool) -> string -> string list = fn
        val fromCString : string -> string option = fn
        val fromString : string -> string option = fn
        val implode : char list -> string = fn
        val isPrefix : string -> string -> bool = fn
        val maxSize : int = 16777195
        val size : string -> int = fn
        val str : char -> string = fn
        val sub : (string * int) -> char = fn
        val substring : (string * int * int) -> string = fn
        val toCString : string -> string = fn
        val toString : string -> string = fn
        val tokens : (char -> bool) -> string -> string list = fn
        val translate : (char -> string) -> string -> string = fn
      end
    eqtype substring = substring
    val all : string -> Substring.substring = fn
    val app : (char -> unit) -> Substring.substring -> unit = fn
    val base : Substring.substring -> (string * int * int) = fn
    val collate : ((char * char) -> order) -> (Substring.substring * Substring.substring) -> order = fn
    val compare : (Substring.substring * Substring.substring) -> order = fn
    val concat : Substring.substring list -> string = fn
    val dropl : (char -> bool) -> Substring.substring -> Substring.substring = fn
    val dropr : (char -> bool) -> Substring.substring -> Substring.substring = fn
    val explode : Substring.substring -> char list = fn
    val extract : (string * int * int option) -> Substring.substring = fn
    val fields : (char -> bool) -> Substring.substring -> Substring.substring list = fn
    val first : Substring.substring -> char option = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> Substring.substring -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> Substring.substring -> 'a = fn
    val getc : Substring.substring -> (char * Substring.substring) option = fn
    val isEmpty : Substring.substring -> bool = fn
    val isPrefix : string -> Substring.substring -> bool = fn
    val position : string -> Substring.substring -> (Substring.substring * Substring.substring) = fn
    val size : Substring.substring -> int = fn
    val slice : (Substring.substring * int * int option) -> Substring.substring = fn
    val splitAt : (Substring.substring * int) -> (Substring.substring * Substring.substring) = fn
    val splitl : (char -> bool) -> Substring.substring -> (Substring.substring * Substring.substring) = fn
    val splitr : (char -> bool) -> Substring.substring -> (Substring.substring * Substring.substring) = fn
    val string : Substring.substring -> string = fn
    val sub : (Substring.substring * int) -> char = fn
    val substring : (string * int * int) -> Substring.substring = fn
    val takel : (char -> bool) -> Substring.substring -> Substring.substring = fn
    val taker : (char -> bool) -> Substring.substring -> Substring.substring = fn
    val tokens : (char -> bool) -> Substring.substring -> Substring.substring list = fn
    val translate : (char -> string) -> Substring.substring -> string = fn
    val triml : int -> Substring.substring -> Substring.substring = fn
    val trimr : int -> Substring.substring -> Substring.substring = fn
  end
@


1.9
log
@[Bug #1759]
recompiling
changes owing to new TEXT_STREAM_IO signature.
@
text
@d71 1
d87 1
@


1.8
log
@[Bug #1661]
Updating
@
text
@d134 1
d140 1
@


1.8.4.1
log
@branched from 1.8
@
text
@@


1.8.3.1
log
@branched from 1.8
@
text
@@


1.8.3.1.1.1
log
@branched from 1.8.3.1
@
text
@@


1.8.2.1
log
@branched from 1.8
@
text
@@


1.8.1.1
log
@branched from 1.8
@
text
@@


1.8.1.1.1.1
log
@branched from 1.8.1.1
@
text
@@


1.7
log
@[Bug #1490]
update for String.maxSize
@
text
@d42 2
a43 2
        eqtype io_desc = io_desc
        eqtype io_desc_kind = io_desc_kind
d47 2
a48 2
        val compare : (OS.IO.io_desc * OS.IO.io_desc) -> order = fn
        val hash : OS.IO.io_desc -> word = fn
d53 1
a53 1
        val kind : OS.IO.io_desc -> OS.IO.io_desc_kind = fn
d55 1
a55 1
        val pollDesc : OS.IO.io_desc -> OS.IO.poll_desc option = fn
d59 1
a59 1
        val pollToIODesc : OS.IO.poll_desc -> OS.IO.io_desc = fn
d188 1
a188 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d191 3
a193 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OS.IO.io_desc option, name: string, readArr: ({buf: TextPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: TextPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> TextPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OS.IO.io_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: TextPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: TextPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> TextPrimIO.writer
d266 5
a270 5
val applyToInDesc : string -> (OS.IO.io_desc -> 'a) -> 'a = fn
val applyToOutDesc : string -> (OS.IO.io_desc -> 'a) -> 'a = fn
val compare_test : (OS.IO.io_desc * OS.IO.io_desc) -> (bool * bool * bool) = fn
val kind_test : (OS.IO.io_desc * OS.IO.io_desc) -> (bool * bool) = fn
val pollDesc_test : OS.IO.io_desc -> bool = fn
@


1.7.2.1
log
@branched from 1.7
@
text
@@


1.7.1.1
log
@branched from 1.7
@
text
@@


1.6
log
@remove banner
@
text
@d221 1
a221 1
        val maxSize : int = 8388606
@


1.6.1.1
log
@branched from 1.6
@
text
@@


1.5
log
@updating for commercial version flyer
@
text
@a0 2
commercial version may be purchased directly from Harlequin.

@


1.4
log
@Change the test so that it opens README instead of Makefile
since the test is being run in the test_suite directory,
not the src directory.
@
text
@d1 2
@


1.3
log
@[Bug #1566]
updating.
,
@
text
@d42 1
a42 1
        eqtype io_desc = file_desc
a105 27
structure Time =
  struct
    eqtype time = time
    val + : (Time.time * Time.time) -> Time.time = fn
    val - : (Time.time * Time.time) -> Time.time = fn
    val < : (Time.time * Time.time) -> bool = fn
    val <= : (Time.time * Time.time) -> bool = fn
    val > : (Time.time * Time.time) -> bool = fn
    val >= : (Time.time * Time.time) -> bool = fn
    exception Time
    val compare : (Time.time * Time.time) -> order = fn
    val fmt : int -> Time.time -> string = fn
    val fromMicroseconds : int -> Time.time = fn
    val fromMilliseconds : int -> Time.time = fn
    val fromReal : real -> Time.time = fn
    val fromSeconds : int -> Time.time = fn
    val fromString : string -> Time.time option = fn
    val now : unit -> Time.time = fn
    val scan : ('a -> (char * 'a) option) -> 'a -> (Time.time * 'a) option = fn
    val toMicroseconds : Time.time -> int = fn
    val toMilliseconds : Time.time -> int = fn
    val toReal : Time.time -> real = fn
    val toSeconds : Time.time -> int = fn
    val toString : Time.time -> string = fn
    val zeroTime : Time.time = TIME (0, 0, 0)
  end
val it : unit = ()
a181 71
structure BinStreamIO =
  struct
    eqtype elem = word8
    type in_pos = in_pos
    type instream = instream
    type out_pos = out_pos
    eqtype outstream = outstream
    eqtype pos = int
    type reader = reader
    eqtype vector = vector
    type writer = writer
    val canInput : (BinStreamIO.instream * int) -> int option = fn
    val closeIn : BinStreamIO.instream -> unit = fn
    val closeOut : BinStreamIO.outstream -> unit = fn
    val endOfStream : BinStreamIO.instream -> bool = fn
    val filePosIn : BinStreamIO.in_pos -> int = fn
    val filePosOut : BinStreamIO.out_pos -> int = fn
    val flushOut : BinStreamIO.outstream -> unit = fn
    val getBufferMode : BinStreamIO.outstream -> buffer_mode(hidden) = fn
    val getPosIn : BinStreamIO.instream -> BinStreamIO.in_pos = fn
    val getPosOut : BinStreamIO.outstream -> BinStreamIO.out_pos = fn
    val getReader : BinStreamIO.instream -> (BinStreamIO.reader * BinStreamIO.vector) = fn
    val getWriter : BinStreamIO.outstream -> (BinStreamIO.writer * buffer_mode(hidden)) = fn
    val input : BinStreamIO.instream -> (BinStreamIO.vector * BinStreamIO.instream) = fn
    val input1 : BinStreamIO.instream -> (BinStreamIO.elem * BinStreamIO.instream) option = fn
    val inputAll : BinStreamIO.instream -> BinStreamIO.vector = fn
    val inputN : (BinStreamIO.instream * int) -> (BinStreamIO.vector * BinStreamIO.instream) = fn
    val mkInstream : (BinStreamIO.reader * BinStreamIO.vector) -> BinStreamIO.instream = fn
    val mkOutstream : (BinStreamIO.writer * buffer_mode(hidden)) -> BinStreamIO.outstream = fn
    val output : (BinStreamIO.outstream * BinStreamIO.vector) -> unit = fn
    val output1 : (BinStreamIO.outstream * BinStreamIO.elem) -> unit = fn
    val setBufferMode : (BinStreamIO.outstream * buffer_mode(hidden)) -> unit = fn
    val setPosIn : BinStreamIO.in_pos -> BinStreamIO.instream = fn
    val setPosOut : BinStreamIO.out_pos -> BinStreamIO.outstream = fn
  end
structure TextStreamIO =
  struct
    eqtype elem = char
    type in_pos = in_pos
    type instream = instream
    type out_pos = out_pos
    eqtype outstream = outstream
    eqtype pos = int
    type reader = reader
    eqtype vector = string
    type writer = writer
    val canInput : (TextStreamIO.instream * int) -> int option = fn
    val closeIn : TextStreamIO.instream -> unit = fn
    val closeOut : TextStreamIO.outstream -> unit = fn
    val endOfStream : TextStreamIO.instream -> bool = fn
    val filePosIn : TextStreamIO.in_pos -> int = fn
    val filePosOut : TextStreamIO.out_pos -> int = fn
    val flushOut : TextStreamIO.outstream -> unit = fn
    val getBufferMode : TextStreamIO.outstream -> buffer_mode(hidden) = fn
    val getPosIn : TextStreamIO.instream -> TextStreamIO.in_pos = fn
    val getPosOut : TextStreamIO.outstream -> TextStreamIO.out_pos = fn
    val getReader : TextStreamIO.instream -> (TextStreamIO.reader * string) = fn
    val getWriter : TextStreamIO.outstream -> (TextStreamIO.writer * buffer_mode(hidden)) = fn
    val input : TextStreamIO.instream -> (string * TextStreamIO.instream) = fn
    val input1 : TextStreamIO.instream -> (char * TextStreamIO.instream) option = fn
    val inputAll : TextStreamIO.instream -> string = fn
    val inputN : (TextStreamIO.instream * int) -> (string * TextStreamIO.instream) = fn
    val mkInstream : (TextStreamIO.reader * string) -> TextStreamIO.instream = fn
    val mkOutstream : (TextStreamIO.writer * buffer_mode(hidden)) -> TextStreamIO.outstream = fn
    val output : (TextStreamIO.outstream * string) -> unit = fn
    val output1 : (TextStreamIO.outstream * char) -> unit = fn
    val setBufferMode : (TextStreamIO.outstream * buffer_mode(hidden)) -> unit = fn
    val setPosIn : TextStreamIO.in_pos -> TextStreamIO.instream = fn
    val setPosOut : TextStreamIO.out_pos -> TextStreamIO.outstream = fn
  end
val it : unit = ()
d188 1
a188 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d191 1
a191 1
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
d265 1
a267 1
val available_test : ((OS.IO.poll_desc -> OS.IO.poll_desc) * (bool -> 'a) * (bool -> 'b) * (bool -> 'c) * OS.IO.io_desc) -> ('a * 'b * 'c * bool * bool) option = fn
a268 1
val id : 'a -> 'a = fn
a270 1
val ans : ((string * (bool * bool * bool)) * (string * (bool * bool)) * (string * bool) * (string * bool) * (string * (bool * bool * bool * bool * bool) option) * (string * (bool * bool * bool * bool * bool) option) * (string * (bool * bool * bool * bool * bool) option) * (string * (bool * bool * bool * bool * bool) option)) = (("compare", (true, true, true)), ("kind", (true, true)), ("pollDescA", true), ("pollDescB", true), ("available.input.input", NONE), ("available.output.output", SOME (true, true, true, true, true)), ("available.input.output", SOME (true, true, true, true, true)), ("available.output.input", SOME (true, true, true, true, true)))
@


1.2
log
@[Bug #1554]
Win32 doesn't like select being passed file descriptors that
aren't sockets.  So moved this part of the test from the generic
test file to the unix specific one.
@
text
@d42 1
a42 1
        eqtype io_desc = io_desc
d106 27
d204 1
a204 1
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {closed=ref(false), data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(SOME WR ..)})
d206 72
a277 1
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {closed=ref(false), data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(SOME WR ..)})
d286 1
a286 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d289 1
a289 1
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
d363 8
a370 5
Exception Io[basis.__io] {cause=SysErr[unix._os] ("No such file or directory", SOME _), function="openIn", name="Makefile"} raised
Entering debugger, commands: q : quit (return to listener),  ? : more help
Current (innermost) stack frame:
applyToInDesc argument 1<??>
Debugger> @


1.1
log
@new unit
@
text
@d42 1
a42 1
        eqtype io_desc = file_desc
a105 27
structure Time =
  struct
    eqtype time = time
    val + : (Time.time * Time.time) -> Time.time = fn
    val - : (Time.time * Time.time) -> Time.time = fn
    val < : (Time.time * Time.time) -> bool = fn
    val <= : (Time.time * Time.time) -> bool = fn
    val > : (Time.time * Time.time) -> bool = fn
    val >= : (Time.time * Time.time) -> bool = fn
    exception Time
    val compare : (Time.time * Time.time) -> order = fn
    val fmt : int -> Time.time -> string = fn
    val fromMicroseconds : int -> Time.time = fn
    val fromMilliseconds : int -> Time.time = fn
    val fromReal : real -> Time.time = fn
    val fromSeconds : int -> Time.time = fn
    val fromString : string -> Time.time option = fn
    val now : unit -> Time.time = fn
    val scan : ('a -> (char * 'a) option) -> 'a -> (Time.time * 'a) option = fn
    val toMicroseconds : Time.time -> int = fn
    val toMilliseconds : Time.time -> int = fn
    val toReal : Time.time -> real = fn
    val toSeconds : Time.time -> int = fn
    val toString : Time.time -> string = fn
    val zeroTime : Time.time = TIME (0, 0, 0)
  end
val it : unit = ()
a181 71
structure BinStreamIO =
  struct
    eqtype elem = word8
    type in_pos = in_pos
    type instream = instream
    type out_pos = out_pos
    eqtype outstream = outstream
    eqtype pos = int
    type reader = reader
    eqtype vector = vector
    type writer = writer
    val canInput : (BinStreamIO.instream * int) -> int option = fn
    val closeIn : BinStreamIO.instream -> unit = fn
    val closeOut : BinStreamIO.outstream -> unit = fn
    val endOfStream : BinStreamIO.instream -> bool = fn
    val filePosIn : BinStreamIO.in_pos -> int = fn
    val filePosOut : BinStreamIO.out_pos -> int = fn
    val flushOut : BinStreamIO.outstream -> unit = fn
    val getBufferMode : BinStreamIO.outstream -> buffer_mode(hidden) = fn
    val getPosIn : BinStreamIO.instream -> BinStreamIO.in_pos = fn
    val getPosOut : BinStreamIO.outstream -> BinStreamIO.out_pos = fn
    val getReader : BinStreamIO.instream -> (BinStreamIO.reader * BinStreamIO.vector) = fn
    val getWriter : BinStreamIO.outstream -> (BinStreamIO.writer * buffer_mode(hidden)) = fn
    val input : BinStreamIO.instream -> (BinStreamIO.vector * BinStreamIO.instream) = fn
    val input1 : BinStreamIO.instream -> (BinStreamIO.elem * BinStreamIO.instream) option = fn
    val inputAll : BinStreamIO.instream -> BinStreamIO.vector = fn
    val inputN : (BinStreamIO.instream * int) -> (BinStreamIO.vector * BinStreamIO.instream) = fn
    val mkInstream : (BinStreamIO.reader * BinStreamIO.vector) -> BinStreamIO.instream = fn
    val mkOutstream : (BinStreamIO.writer * buffer_mode(hidden)) -> BinStreamIO.outstream = fn
    val output : (BinStreamIO.outstream * BinStreamIO.vector) -> unit = fn
    val output1 : (BinStreamIO.outstream * BinStreamIO.elem) -> unit = fn
    val setBufferMode : (BinStreamIO.outstream * buffer_mode(hidden)) -> unit = fn
    val setPosIn : BinStreamIO.in_pos -> BinStreamIO.instream = fn
    val setPosOut : BinStreamIO.out_pos -> BinStreamIO.outstream = fn
  end
structure TextStreamIO =
  struct
    eqtype elem = char
    type in_pos = in_pos
    type instream = instream
    type out_pos = out_pos
    eqtype outstream = outstream
    eqtype pos = int
    type reader = reader
    eqtype vector = string
    type writer = writer
    val canInput : (TextStreamIO.instream * int) -> int option = fn
    val closeIn : TextStreamIO.instream -> unit = fn
    val closeOut : TextStreamIO.outstream -> unit = fn
    val endOfStream : TextStreamIO.instream -> bool = fn
    val filePosIn : TextStreamIO.in_pos -> int = fn
    val filePosOut : TextStreamIO.out_pos -> int = fn
    val flushOut : TextStreamIO.outstream -> unit = fn
    val getBufferMode : TextStreamIO.outstream -> buffer_mode(hidden) = fn
    val getPosIn : TextStreamIO.instream -> TextStreamIO.in_pos = fn
    val getPosOut : TextStreamIO.outstream -> TextStreamIO.out_pos = fn
    val getReader : TextStreamIO.instream -> (TextStreamIO.reader * string) = fn
    val getWriter : TextStreamIO.outstream -> (TextStreamIO.writer * buffer_mode(hidden)) = fn
    val input : TextStreamIO.instream -> (string * TextStreamIO.instream) = fn
    val input1 : TextStreamIO.instream -> (char * TextStreamIO.instream) option = fn
    val inputAll : TextStreamIO.instream -> string = fn
    val inputN : (TextStreamIO.instream * int) -> (string * TextStreamIO.instream) = fn
    val mkInstream : (TextStreamIO.reader * string) -> TextStreamIO.instream = fn
    val mkOutstream : (TextStreamIO.writer * buffer_mode(hidden)) -> TextStreamIO.outstream = fn
    val output : (TextStreamIO.outstream * string) -> unit = fn
    val output1 : (TextStreamIO.outstream * char) -> unit = fn
    val setBufferMode : (TextStreamIO.outstream * buffer_mode(hidden)) -> unit = fn
    val setPosIn : TextStreamIO.in_pos -> TextStreamIO.instream = fn
    val setPosOut : TextStreamIO.out_pos -> TextStreamIO.outstream = fn
  end
val it : unit = ()
d188 1
a188 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d191 1
a191 1
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
d265 5
a269 8
val applyToInDesc : string -> (OS.IO.io_desc -> 'a) -> 'a = fn
val applyToOutDesc : string -> (OS.IO.io_desc -> 'a) -> 'a = fn
val available_test : ((OS.IO.poll_desc -> OS.IO.poll_desc) * (bool -> 'a) * (bool -> 'b) * (bool -> 'c) * OS.IO.io_desc) -> ('a * 'b * 'c * bool * bool) option = fn
val compare_test : (OS.IO.io_desc * OS.IO.io_desc) -> (bool * bool * bool) = fn
val id : 'a -> 'a = fn
val kind_test : (OS.IO.io_desc * OS.IO.io_desc) -> (bool * bool) = fn
val pollDesc_test : OS.IO.io_desc -> bool = fn
val ans : ((string * (bool * bool * bool)) * (string * (bool * bool)) * (string * bool) * (string * bool) * (string * (bool * bool * bool * bool * bool) option) * (string * (bool * bool * bool * bool * bool) option) * (string * (bool * bool * bool * bool * bool) option) * (string * (bool * bool * bool * bool * bool) option)) = (("compare", (true, true, true)), ("kind", (true, true)), ("pollDescA", true), ("pollDescB", true), ("available.input.input", NONE), ("available.output.output", SOME (true, true, true, true, true)), ("available.input.output", SOME (true, true, true, true, true)), ("available.output.input", SOME (true, true, true, true, true)))
@
