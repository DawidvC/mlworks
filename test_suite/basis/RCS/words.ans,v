head	1.13;
access;
symbols
	MLWorks_21c0_1999_03_25:1.13
	MLWorks_20c1_1998_08_20:1.13
	MLWorks_20c0_1998_08_04:1.13
	MLWorks_20b2c2_1998_06_19:1.13
	MLWorks_20b2_Windows_1998_06_12:1.13
	MLWorks_20b1c1_1998_05_07:1.13
	MLWorks_20b0_1998_04_07:1.13
	MLWorks_20b0_1998_03_20:1.13
	MLWorks_20m2_1998_02_16:1.13
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.9.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.9.1.1.1.1
	MLWorks_10r3:1.9.1.1.3
	MLWorks_10r2_551:1.9.1.1.2
	MLWorks_11:1.9.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.9.1.1
	MLWorks_20m0_1997_06_20:1.11
	MLWorks_1_0_r2c2_1997_06_14:1.9.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.9.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.9.1
	MLWorks_BugFix_1997_04_24:1.9
	MLWorks_1_0_r2_Win32_1997_04_11:1.9
	MLWorks_1_0_r2_Unix_1997_04_04:1.9
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.3.1.1
	MLWorks_gui_1996_12_18:1.8.4
	MLWorks_1_0_Win32_1996_12_17:1.8.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.1.1
	MLWorks_1_0_Irix_1996_11_28:1.8.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.2
	MLWorks_1_0_Unix_1996_11_14:1.8.1
	MLWorks_Open_Beta2_1996_10_11:1.7.3
	MLWorks_License_dev:1.7.2
	MLWorks_1_open_beta_1996_09_13:1.7.1
	MLWorks_Open_Beta_1996_08_22:1.5
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.3
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@# @;


1.13
date	97.11.25.19.28.26;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	97.08.05.10.02.12;	author brucem;	state Exp;
branches;
next	1.11;

1.11
date	97.06.06.11.13.05;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	97.05.01.22.24.02;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	97.03.06.13.53.38;	author matthew;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	96.10.22.13.32.12;	author jont;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1;
next	1.7;

1.7
date	96.09.09.11.14.03;	author io;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1;
next	1.6;

1.6
date	96.09.07.00.02.28;	author io;	state Exp;
branches;
next	1.5;

1.5
date	96.08.14.12.22.49;	author io;	state Exp;
branches;
next	1.4;

1.4
date	96.07.04.18.35.59;	author andreww;	state Exp;
branches;
next	1.3;

1.3
date	96.06.05.02.42.16;	author io;	state Exp;
branches;
next	1.2;

1.2
date	96.05.23.11.45.29;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	96.05.13.13.50.13;	author matthew;	state Exp;
branches;
next	;

1.7.1.1
date	96.09.13.11.37.26;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.10.07.16.28.42;	author hope;	state Exp;
branches;
next	;

1.7.3.1
date	96.10.17.11.49.33;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.11.14.13.16.57;	author hope;	state Exp;
branches
	1.8.1.1.1.1;
next	;

1.8.1.1.1.1
date	96.11.28.15.27.23;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.11.22.18.34.44;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.12.17.18.13.41;	author hope;	state Exp;
branches
	1.8.3.1.1.1;
next	;

1.8.3.1.1.1
date	97.02.24.12.06.30;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.12.18.10.08.39;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	97.05.12.11.07.11;	author hope;	state Exp;
branches
	1.9.1.1.1.1
	1.9.1.1.2.1
	1.9.1.1.3.1;
next	;

1.9.1.1.1.1
date	97.07.28.18.51.00;	author daveb;	state Exp;
branches
	1.9.1.1.1.1.1.1;
next	;

1.9.1.1.1.1.1.1
date	97.10.07.12.14.47;	author jkbrook;	state Exp;
branches;
next	;

1.9.1.1.2.1
date	97.09.08.17.42.44;	author daveb;	state Exp;
branches;
next	;

1.9.1.1.3.1
date	97.09.09.14.42.11;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New test
@


1.13
log
@[Bug #30323]
@
text
@val t10 : bool = true
val t11 : bool = true
val t12 : bool = true
val t13 : bool = true
val t14 : bool = true
val t15 : bool = true
val t16 : bool = true
val t17 : bool = true
val t18 : bool = true
val t19 : bool = true
val t2 : bool = true
val t20 : bool = true
val t21 : bool = true
val t3 : bool = true
val t4 : bool = true
val t5 : bool = true
val t6 : bool = true
val t7 : bool = true
val t8 : bool = true
val t9 : bool list = [true, true, true]
val t1 : bool = true
val t11 : bool = true
val t12 : bool = true
val t13 : bool = true
val t14 : bool = true
val t15 : bool = true
val t16 : bool = true
val t17 : bool = true
val t18 : bool = true
val t19 : bool = true
val t2 : bool = true
val t20 : bool = true
val t21 : bool = true
val t3 : bool = true
val t4 : bool = true
val t5 : bool = true
val t6 : bool = true
val t7 : bool = true
val t9 : bool list = [true, true, true]
val t1 : bool = true
val t10 : bool = true
val t11 : bool = true
val t12 : bool = true
val t13 : bool = true
val t14 : bool = true
val t15 : bool = true
val t16 : bool = true
val t17 : bool = true
val t18 : bool = true
val t19 : bool = true
val t2 : bool = true
val t20 : bool = true
val t21 : bool = true
val t3 : bool = true
val t4 : bool = true
val t5 : bool = true
val t6 : bool = true
val t7 : bool = true
val t8 : bool = true
val t9 : bool list = [true, true, true]
@


1.12
log
@[Bug #30004]
Reflect changes in sml file.
@
text
@a0 8
structure General = struct ... end
structure Word = struct ... end
structure Word8 = struct ... end
structure LargeWord = struct ... end
structure SysWord = struct ... end
structure Word32 = struct ... end
structure LargeInt = struct ... end
structure StringCvt = struct ... end
@


1.11
log
@New answer now list type in list
@
text
@d1 8
a8 293
val it : unit = ()
structure General =
  struct
    type exn = exn
    datatype 'a option =
      NONE |
      SOME of 'a
    datatype order =
      EQUAL |
      GREATER |
      LESS
    eqtype unit = unit
    val ! : 'a ref -> 'a = fn
    val := : ('a ref * 'a) -> unit = fn
    val <> : (''a * ''a) -> bool = fn
    exception Bind
    exception Chr
    exception Div
    exception Domain
    val EQUAL : order
    exception Fail of string
    val GREATER : order
    val LESS : order
    exception Match
    val NONE : 'a option
    exception Option
    exception Overflow
    val SOME : 'a -> 'a option
    exception Size
    exception Subscript
    val before : ('a * unit) -> 'a = fn
    val exnMessage : exn -> string = fn
    val exnName : exn -> string = fn
    val getOpt : ('a option * 'a) -> 'a = fn
    val ignore : 'a -> unit = fn
    val isSome : 'a option -> bool = fn
    val o : (('a -> 'b) * ('c -> 'a)) -> 'c -> 'b = fn
    val valOf : 'a option -> 'a = fn
  end
val it : unit = ()
structure Word =
  struct
    eqtype word = word
    val * : (word * word) -> word = fn
    val + : (word * word) -> word = fn
    val - : (word * word) -> word = fn
    val < : (word * word) -> bool = fn
    val << : (word * word) -> word = fn
    val <= : (word * word) -> bool = fn
    val > : (word * word) -> bool = fn
    val >= : (word * word) -> bool = fn
    val >> : (word * word) -> word = fn
    val andb : (word * word) -> word = fn
    val compare : (word * word) -> order = fn
    val div : (word * word) -> word = fn
    val fmt : radix(hidden) -> word -> string = fn
    val fromInt : int -> word = fn
    val fromLargeInt : MLWorks.Internal.Types.int32 -> word = fn
    val fromLargeWord : MLWorks.Internal.Types.word32 -> word = fn
    val fromString : string -> word option = fn
    val max : (word * word) -> word = fn
    val min : (word * word) -> word = fn
    val mod : (word * word) -> word = fn
    val notb : word -> word = fn
    val orb : (word * word) -> word = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (word * 'a) option = fn
    val toInt : word -> int = fn
    val toIntX : word -> int = fn
    val toLargeInt : word -> MLWorks.Internal.Types.int32 = fn
    val toLargeIntX : word -> MLWorks.Internal.Types.int32 = fn
    val toLargeWord : word -> MLWorks.Internal.Types.word32 = fn
    val toLargeWordX : word -> MLWorks.Internal.Types.word32 = fn
    val toString : word -> string = fn
    val wordSize : int = 30
    val xorb : (word * word) -> word = fn
    val ~>> : (word * word) -> word = fn
  end
val it : unit = ()
structure Word8 =
  struct
    eqtype word = word8
    val * : (Word8.word * Word8.word) -> Word8.word = fn
    val + : (Word8.word * Word8.word) -> Word8.word = fn
    val - : (Word8.word * Word8.word) -> Word8.word = fn
    val < : (Word8.word * Word8.word) -> bool = fn
    val << : (Word8.word * word) -> Word8.word = fn
    val <= : (Word8.word * Word8.word) -> bool = fn
    val > : (Word8.word * Word8.word) -> bool = fn
    val >= : (Word8.word * Word8.word) -> bool = fn
    val >> : (Word8.word * word) -> Word8.word = fn
    val andb : (Word8.word * Word8.word) -> Word8.word = fn
    val compare : (Word8.word * Word8.word) -> order = fn
    val div : (Word8.word * Word8.word) -> Word8.word = fn
    val fmt : radix(hidden) -> Word8.word -> string = fn
    val fromInt : int -> Word8.word = fn
    val fromLargeInt : MLWorks.Internal.Types.int32 -> Word8.word = fn
    val fromLargeWord : MLWorks.Internal.Types.word32 -> Word8.word = fn
    val fromString : string -> Word8.word option = fn
    val max : (Word8.word * Word8.word) -> Word8.word = fn
    val min : (Word8.word * Word8.word) -> Word8.word = fn
    val mod : (Word8.word * Word8.word) -> Word8.word = fn
    val notb : Word8.word -> Word8.word = fn
    val orb : (Word8.word * Word8.word) -> Word8.word = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (Word8.word * 'a) option = fn
    val toInt : Word8.word -> int = fn
    val toIntX : Word8.word -> int = fn
    val toLargeInt : Word8.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeIntX : Word8.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeWord : Word8.word -> MLWorks.Internal.Types.word32 = fn
    val toLargeWordX : Word8.word -> MLWorks.Internal.Types.word32 = fn
    val toString : Word8.word -> string = fn
    val wordSize : int = 8
    val xorb : (Word8.word * Word8.word) -> Word8.word = fn
    val ~>> : (Word8.word * word) -> Word8.word = fn
  end
val it : unit = ()
structure LargeWord =
  struct
    eqtype word = word32
    val * : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val + : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val - : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val < : (LargeWord.word * LargeWord.word) -> bool = fn
    val << : (LargeWord.word * word) -> LargeWord.word = fn
    val <= : (LargeWord.word * LargeWord.word) -> bool = fn
    val > : (LargeWord.word * LargeWord.word) -> bool = fn
    val >= : (LargeWord.word * LargeWord.word) -> bool = fn
    val >> : (LargeWord.word * word) -> LargeWord.word = fn
    val andb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val compare : (LargeWord.word * LargeWord.word) -> order = fn
    val div : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val fmt : radix(hidden) -> LargeWord.word -> string = fn
    val fromInt : int -> LargeWord.word = fn
    val fromLargeInt : MLWorks.Internal.Types.int32 -> LargeWord.word = fn
    val fromLargeWord : LargeWord.word -> LargeWord.word = fn
    val fromString : string -> LargeWord.word option = fn
    val max : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val min : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val mod : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val notb : LargeWord.word -> LargeWord.word = fn
    val orb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option = fn
    val toInt : LargeWord.word -> int = fn
    val toIntX : LargeWord.word -> int = fn
    val toLargeInt : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeIntX : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeWord : LargeWord.word -> LargeWord.word = fn
    val toLargeWordX : LargeWord.word -> LargeWord.word = fn
    val toString : LargeWord.word -> string = fn
    val wordSize : int = 32
    val xorb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val ~>> : (LargeWord.word * word) -> LargeWord.word = fn
  end
structure SysWord =
  struct
    eqtype word = word32
    val * : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val + : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val - : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val < : (LargeWord.word * LargeWord.word) -> bool = fn
    val << : (LargeWord.word * word) -> LargeWord.word = fn
    val <= : (LargeWord.word * LargeWord.word) -> bool = fn
    val > : (LargeWord.word * LargeWord.word) -> bool = fn
    val >= : (LargeWord.word * LargeWord.word) -> bool = fn
    val >> : (LargeWord.word * word) -> LargeWord.word = fn
    val andb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val compare : (LargeWord.word * LargeWord.word) -> order = fn
    val div : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val fmt : radix(hidden) -> LargeWord.word -> string = fn
    val fromInt : int -> LargeWord.word = fn
    val fromLargeInt : MLWorks.Internal.Types.int32 -> LargeWord.word = fn
    val fromLargeWord : LargeWord.word -> LargeWord.word = fn
    val fromString : string -> LargeWord.word option = fn
    val max : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val min : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val mod : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val notb : LargeWord.word -> LargeWord.word = fn
    val orb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option = fn
    val toInt : LargeWord.word -> int = fn
    val toIntX : LargeWord.word -> int = fn
    val toLargeInt : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeIntX : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeWord : LargeWord.word -> LargeWord.word = fn
    val toLargeWordX : LargeWord.word -> LargeWord.word = fn
    val toString : LargeWord.word -> string = fn
    val wordSize : int = 32
    val xorb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val ~>> : (LargeWord.word * word) -> LargeWord.word = fn
  end
structure Word32 =
  struct
    eqtype word = word32
    val * : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val + : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val - : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val < : (LargeWord.word * LargeWord.word) -> bool = fn
    val << : (LargeWord.word * word) -> LargeWord.word = fn
    val <= : (LargeWord.word * LargeWord.word) -> bool = fn
    val > : (LargeWord.word * LargeWord.word) -> bool = fn
    val >= : (LargeWord.word * LargeWord.word) -> bool = fn
    val >> : (LargeWord.word * word) -> LargeWord.word = fn
    val andb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val compare : (LargeWord.word * LargeWord.word) -> order = fn
    val div : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val fmt : radix(hidden) -> LargeWord.word -> string = fn
    val fromInt : int -> LargeWord.word = fn
    val fromLargeInt : MLWorks.Internal.Types.int32 -> LargeWord.word = fn
    val fromLargeWord : LargeWord.word -> LargeWord.word = fn
    val fromString : string -> LargeWord.word option = fn
    val max : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val min : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val mod : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val notb : LargeWord.word -> LargeWord.word = fn
    val orb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (LargeWord.word * 'a) option = fn
    val toInt : LargeWord.word -> int = fn
    val toIntX : LargeWord.word -> int = fn
    val toLargeInt : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeIntX : LargeWord.word -> MLWorks.Internal.Types.int32 = fn
    val toLargeWord : LargeWord.word -> LargeWord.word = fn
    val toLargeWordX : LargeWord.word -> LargeWord.word = fn
    val toString : LargeWord.word -> string = fn
    val wordSize : int = 32
    val xorb : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
    val ~>> : (LargeWord.word * word) -> LargeWord.word = fn
  end
val it : unit = ()
structure LargeInt =
  struct
    eqtype int = int32
    val * : (LargeInt.int * LargeInt.int) -> LargeInt.int = fn
    val + : (LargeInt.int * LargeInt.int) -> LargeInt.int = fn
    val - : (LargeInt.int * LargeInt.int) -> LargeInt.int = fn
    val < : (LargeInt.int * LargeInt.int) -> bool = fn
    val <= : (LargeInt.int * LargeInt.int) -> bool = fn
    val > : (LargeInt.int * LargeInt.int) -> bool = fn
    val >= : (LargeInt.int * LargeInt.int) -> bool = fn
    val abs : LargeInt.int -> LargeInt.int = fn
    val compare : (LargeInt.int * LargeInt.int) -> order = fn
    val div : (LargeInt.int * LargeInt.int) -> LargeInt.int = fn
    val fmt : radix(hidden) -> LargeInt.int -> string = fn
    val fromInt : int -> LargeInt.int = fn
    val fromLarge : LargeInt.int -> LargeInt.int = fn
    val fromString : string -> LargeInt.int option = fn
    val max : (LargeInt.int * LargeInt.int) -> LargeInt.int = fn
    val maxInt : LargeInt.int option = SOME 2147483647
    val min : (LargeInt.int * LargeInt.int) -> LargeInt.int = fn
    val minInt : LargeInt.int option = SOME ~2147483648
    val mod : (LargeInt.int * LargeInt.int) -> LargeInt.int = fn
    val precision : int option = SOME 32
    val quot : (LargeInt.int * LargeInt.int) -> LargeInt.int = fn
    val rem : (LargeInt.int * LargeInt.int) -> LargeInt.int = fn
    val sameSign : (LargeInt.int * LargeInt.int) -> bool = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (LargeInt.int * 'a) option = fn
    val sign : LargeInt.int -> int = fn
    val toInt : LargeInt.int -> int = fn
    val toLarge : LargeInt.int -> LargeInt.int = fn
    val toString : LargeInt.int -> string = fn
    val ~ : LargeInt.int -> LargeInt.int = fn
  end
val it : unit = ()
structure StringCvt =
  struct
    eqtype cs = int
    datatype radix =
      BIN |
      DEC |
      HEX |
      OCT
    type ('a, 'b) reader = 'b -> ('a * 'b) option
    datatype realfmt =
      EXACT |
      FIX of int option |
      GEN of int option |
      SCI of int option
    val BIN : StringCvt.radix
    val DEC : StringCvt.radix
    val EXACT : StringCvt.realfmt
    val FIX : int option -> StringCvt.realfmt
    val GEN : int option -> StringCvt.realfmt
    val HEX : StringCvt.radix
    val OCT : StringCvt.radix
    val SCI : int option -> StringCvt.realfmt
    val dropl : (char -> bool) -> ('a -> (char * 'a) option) -> 'a -> 'a = fn
    val padLeft : char -> int -> string -> string = fn
    val padRight : char -> int -> string -> string = fn
    val scanList : ((char list -> (char * char list) option) -> char list -> ('a * 'b) option) -> char list -> 'a option = fn
    val scanString : ((int -> (char * int) option) -> int -> ('a * int) option) -> string -> 'a option = fn
    val skipWS : ('a -> (char * 'a) option) -> 'a -> 'a = fn
    val splitl : (char -> bool) -> ('a -> (char * 'a) option) -> 'a -> (string * 'a) = fn
    val takel : (char -> bool) -> ('a -> (char * 'a) option) -> 'a -> string = fn
  end
@


1.10
log
@[Bug #30096]
Type of Int32.precision has changed.
@
text
@a228 33
structure Int32 =
  struct
    eqtype int = int32
    val * : (Int32.int * Int32.int) -> Int32.int = fn
    val + : (Int32.int * Int32.int) -> Int32.int = fn
    val - : (Int32.int * Int32.int) -> Int32.int = fn
    val < : (Int32.int * Int32.int) -> bool = fn
    val <= : (Int32.int * Int32.int) -> bool = fn
    val > : (Int32.int * Int32.int) -> bool = fn
    val >= : (Int32.int * Int32.int) -> bool = fn
    val abs : Int32.int -> Int32.int = fn
    val compare : (Int32.int * Int32.int) -> order = fn
    val div : (Int32.int * Int32.int) -> Int32.int = fn
    val fmt : radix(hidden) -> Int32.int -> string = fn
    val fromInt : int -> Int32.int = fn
    val fromLarge : Int32.int -> Int32.int = fn
    val fromString : string -> Int32.int option = fn
    val max : (Int32.int * Int32.int) -> Int32.int = fn
    val maxInt : Int32.int option = SOME 2147483647
    val min : (Int32.int * Int32.int) -> Int32.int = fn
    val minInt : Int32.int option = SOME ~2147483648
    val mod : (Int32.int * Int32.int) -> Int32.int = fn
    val precision : int option = SOME 32
    val quot : (Int32.int * Int32.int) -> Int32.int = fn
    val rem : (Int32.int * Int32.int) -> Int32.int = fn
    val sameSign : (Int32.int * Int32.int) -> bool = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (Int32.int * 'a) option = fn
    val sign : Int32.int -> int = fn
    val toInt : Int32.int -> int = fn
    val toLarge : Int32.int -> Int32.int = fn
    val toString : Int32.int -> string = fn
    val ~ : Int32.int -> Int32.int = fn
  end
d232 19
a250 19
    val * : (Int32.int * Int32.int) -> Int32.int = fn
    val + : (Int32.int * Int32.int) -> Int32.int = fn
    val - : (Int32.int * Int32.int) -> Int32.int = fn
    val < : (Int32.int * Int32.int) -> bool = fn
    val <= : (Int32.int * Int32.int) -> bool = fn
    val > : (Int32.int * Int32.int) -> bool = fn
    val >= : (Int32.int * Int32.int) -> bool = fn
    val abs : Int32.int -> Int32.int = fn
    val compare : (Int32.int * Int32.int) -> order = fn
    val div : (Int32.int * Int32.int) -> Int32.int = fn
    val fmt : radix(hidden) -> Int32.int -> string = fn
    val fromInt : int -> Int32.int = fn
    val fromLarge : Int32.int -> Int32.int = fn
    val fromString : string -> Int32.int option = fn
    val max : (Int32.int * Int32.int) -> Int32.int = fn
    val maxInt : Int32.int option = SOME 2147483647
    val min : (Int32.int * Int32.int) -> Int32.int = fn
    val minInt : Int32.int option = SOME ~2147483648
    val mod : (Int32.int * Int32.int) -> Int32.int = fn
d252 9
a260 9
    val quot : (Int32.int * Int32.int) -> Int32.int = fn
    val rem : (Int32.int * Int32.int) -> Int32.int = fn
    val sameSign : (Int32.int * Int32.int) -> bool = fn
    val scan : radix(hidden) -> ('a -> (char * 'a) option) -> 'a -> (Int32.int * 'a) option = fn
    val sign : Int32.int -> int = fn
    val toInt : Int32.int -> int = fn
    val toLarge : Int32.int -> Int32.int = fn
    val toString : Int32.int -> string = fn
    val ~ : Int32.int -> Int32.int = fn
@


1.9
log
@Updating


Updating
@
text
@d251 1
a251 1
    val precision : Int32.int option = SOME 32
d284 1
a284 1
    val precision : Int32.int option = SOME 32
@


1.9.1.1
log
@branched from 1.9
@
text
@@


1.9.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.9.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.9.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.9.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.8
log
@Remove references to toplevel
@
text
@d306 1
d312 1
@


1.8.4.1
log
@branched from 1.8
@
text
@@


1.8.3.1
log
@branched from 1.8
@
text
@@


1.8.3.1.1.1
log
@branched from 1.8.3.1
@
text
@@


1.8.2.1
log
@branched from 1.8
@
text
@@


1.8.1.1
log
@branched from 1.8
@
text
@@


1.8.1.1.1.1
log
@branched from 1.8.1.1
@
text
@@


1.7
log
@remove banner
@
text
@a1 1
val it : unit = ()
@


1.7.3.1
log
@branched from 1.7
@
text
@@


1.7.2.1
log
@branched from 1.7
@
text
@@


1.7.1.1
log
@branched from 1.7
@
text
@@


1.6
log
@updating for commercial version flyer
@
text
@a0 2
commercial version may be purchased directly from Harlequin.

@


1.5
log
@switch off Compiling messages...
@
text
@d1 2
@


1.4
log
@updating.
@
text
@a1 1
Compiling basis.toplevel
a2 2
Compiling basis.general
Compiling basis.__general
a41 10
Compiling basis.string_cvt
Compiling basis.__pre_basis
Compiling basis.__pre_string_cvt
Compiling basis.__string_cvt
Compiling basis.__preinteger
Compiling basis.__preword32
Compiling basis.__preint32
Compiling basis.__preword
Compiling basis.word
Compiling basis.__word
a79 1
Compiling basis.__word8
a117 1
Compiling basis.__word32
a229 2
Compiling basis.integer
Compiling basis.__int32
@


1.3
log
@stringcvt->string_cvt
@
text
@d2 2
a5 33
Compiling basis.toplevel
structure TopLevel =
  struct
    datatype 'a option =
      NONE |
      SOME of 'a
    datatype order =
      EQUAL |
      GREATER |
      LESS
    exception Domain
    val EQUAL : order
    exception Fail of string
    val GREATER : order
    val LESS : order
    val NONE : 'a option
    val SOME : 'a -> 'a option
  end
datatype 'a option =
  NONE |
  SOME of 'a
datatype order =
  EQUAL |
  GREATER |
  LESS
exception Domain
val EQUAL : order
exception Fail of string
val GREATER : order
val LESS : order
val NONE : 'a option
val SOME : 'a -> 'a option
val it : unit = ()
@


1.2
log
@Some problem with using File.loadSource
@
text
@d76 4
a79 3
Compiling basis.stringcvt
Compiling basis.__pre_char
Compiling basis.__stringcvt
@


1.1
log
@new unit
New test
@
text
@d131 1
a131 1
    val << : (Word8.word * Word8.word) -> Word8.word = fn
d135 1
a135 1
    val >> : (Word8.word * Word8.word) -> Word8.word = fn
d159 1
a159 1
    val ~>> : (Word8.word * Word8.word) -> Word8.word = fn
d170 1
a170 1
    val << : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
d174 1
a174 1
    val >> : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
d198 38
a235 1
    val ~>> : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
d244 1
a244 1
    val << : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
d248 1
a248 1
    val >> : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
d272 1
a272 1
    val ~>> : (LargeWord.word * LargeWord.word) -> LargeWord.word = fn
d295 1
a295 1
    val maxint : Int32.int option = SOME 2147483647
d297 1
a297 1
    val minint : Int32.int option = SOME ~2147483648
d328 1
a328 1
    val maxint : Int32.int option = SOME 2147483647
d330 1
a330 1
    val minint : Int32.int option = SOME ~2147483648
@
