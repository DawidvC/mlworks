head	1.6;
access;
symbols
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.6
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_11r1:1.4.5.1.1.1.1
	MLWorks_11c0_1997_09_09:1.4.5.1.1.1
	MLWorks_10r3:1.4.5.1.3
	MLWorks_10r2_551:1.4.5.1.2
	MLWorks_11:1.4.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.4.5.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.4.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.4.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.4.5
	MLWorks_BugFix_1997_04_24:1.4
	MLWorks_1_0_r2_Win32_1997_04_11:1.4
	MLWorks_1_0_r2_Unix_1997_04_04:1.4
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.3.1.1
	MLWorks_gui_1996_12_18:1.4.4
	MLWorks_1_0_Win32_1996_12_17:1.4.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.4.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.4.1.1
	MLWorks_1_0_Irix_1996_11_28:1.4.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.2
	MLWorks_1_0_Unix_1996_11_14:1.4.1
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ *  @;


1.6
date	97.11.21.10.51.31;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	97.05.28.11.26.58;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	96.11.06.12.06.29;	author matthew;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1
	1.4.4.1
	1.4.5.1;
next	1.3;

1.3
date	96.10.22.13.23.18;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.06.04.19.51.17;	author io;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	96.05.22.15.04.46;	author matthew;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.38.17;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.16.29.37;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.50.21;	author hope;	state Exp;
branches;
next	;

1.4.1.1
date	96.11.14.13.17.45;	author hope;	state Exp;
branches
	1.4.1.1.1.1;
next	;

1.4.1.1.1.1
date	96.11.28.15.28.15;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.11.22.18.35.33;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.12.17.18.14.32;	author hope;	state Exp;
branches
	1.4.3.1.1.1;
next	;

1.4.3.1.1.1
date	97.02.24.12.07.28;	author hope;	state Exp;
branches;
next	;

1.4.4.1
date	96.12.18.10.09.30;	author hope;	state Exp;
branches;
next	;

1.4.5.1
date	97.05.12.11.08.05;	author hope;	state Exp;
branches
	1.4.5.1.1.1
	1.4.5.1.2.1
	1.4.5.1.3.1;
next	;

1.4.5.1.1.1
date	97.07.28.18.49.40;	author daveb;	state Exp;
branches
	1.4.5.1.1.1.1.1;
next	;

1.4.5.1.1.1.1.1
date	97.10.07.12.15.01;	author jkbrook;	state Exp;
branches;
next	;

1.4.5.1.2.1
date	97.09.08.17.41.24;	author daveb;	state Exp;
branches;
next	;

1.4.5.1.3.1
date	97.09.09.14.40.52;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New test
@


1.6
log
@[Bug #30323]
@
text
@(*  ==== Testing ====
 *
 *  Result: OK
 *
 *  Revision Log
 *  ------------
 *  $Log: word8s.sml,v $
 *  Revision 1.5  1997/05/28  11:26:58  jont
 *  [Bug #30090]
 *  Remove uses of MLWorks.IO
 *
 *  Revision 1.4  1996/11/06  12:06:29  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
 *  Revision 1.3  1996/10/22  13:23:18  jont
 *  Remove references to toplevel
 *
 *  Revision 1.2  1996/06/04  19:51:17  io
 *  stringcvt -> string_cvt
 *
 *  Revision 1.1  1996/05/22  15:04:46  matthew
 *  new unit
 *  New test
 *
*)

(* test/word8.sml -- some test cases for Word8, appropriate for a
   two's complement machine whose Integer.precision = SOME 31 
   PS 1995-03-30, 1995-07-12, 1995-11-06 
   modified for MLWorks Fri May 17 11:43:55 1996 still incomplete
   *)


infix 1 seq
fun e1 seq e2 = e2;
fun check b = if b then "OK" else "WRONG";
fun check' f = (if f () then "OK" else "WRONG") handle _ => "EXN";

fun range (from, to) p = 
    let open Int
    in
	(from > to) orelse (p from) andalso (range (from+1, to) p)
    end;

fun checkrange bounds = check o range bounds;

local 
    fun pwr2 0 = 1 
      | pwr2 n = 2 * pwr2 (n-1);
    fun rwp i 0 = i
      | rwp i n = rwp i (n-1) div 2;

    (* Isn't this disgusting: *)
    type 'a foo4 = 'a * 'a * 'a * 'a
    type 'a foo5 = 'a * 'a * 'a * 'a * 'a
    val (gt,  lt,  ge,   le) = 
      (op>, op<, op>=, op<=) : (int * int -> bool) foo4
    val (add, sub, mul, idiv, imod) = 
      (op+, op-, op*, op div, op mod) : (int * int -> int) foo5
    open Word8;
    val op > = gt and op < = lt and op >= = ge and op <= = le;
    val op + = add and op - = sub and op * = mul 
    and op div = idiv and op mod = imod;
    val i2W = Word.fromInt
    val i2w = fromInt
    and w2i = toInt
    and w2ix = toIntX
in

val test1 = checkrange (0, 255) 
    (fn i => i = w2i (i2w i));

val test2 = checkrange (~1000, 1000) 
    (fn i => let val r = w2i (i2w i) 
	     in Int.<=(0,r) andalso Int.<(r, 256)end);

val test3 = checkrange (~128, 127) 
    (fn i => i = toIntX (i2w i));

val test4 = checkrange (~1000, 1000)
    (fn i => let val r = toIntX (i2w i) 
	     in ~128 <= r andalso r < 128 end);

val test5a = checkrange (0,15) 
    (fn i => (i+240) div 2 * 2 + 1
             = w2i (orb (i2w i, i2w 241)));
val test5b = checkrange (0,255)
    (fn i => i = w2i (orb (i2w i, i2w i)));
val test5c = checkrange (~1000,1000)
    (fn i => let val r = w2i (andb (i2w 2047, i2w i)) 
	     in 0 <= r andalso r < 256 end);
val test6a = checkrange (0,15) 
    (fn i => i div 2 * 2 = w2i (andb (i2w i, i2w 254)));
val test6b = checkrange (0,255)
    (fn i => i = w2i (andb (i2w i, i2w i)));
val test6c = checkrange (~1000,1000)
    (fn i => let val r = w2i (andb (i2w 2047, i2w i)) 
	     in 0 <= r andalso r < 256 end);
val test7a = checkrange (0,15) 
    (fn i => i+240 = w2i (xorb (i2w i, i2w 240)));
val test7b = checkrange (0, 255)
    (fn i => 0 = w2i (xorb (i2w i, i2w i)));
val test7c = checkrange (~1000,1000)
    (fn i => let val r = w2i (xorb (i2w 0, i2w i)) 
	     in 0 <= r andalso r < 256 end);
val test8a = check (255 = w2i (notb (i2w 0)));
val test8b = check (0 = w2i (notb (i2w 255)));
val test8c = checkrange (~1000,1000)
    (fn i => let val r = w2i (notb (i2w i)) 
	     in 0 <= r andalso r < 256 end);

val test9a = checkrange (0,7)
    (fn k => pwr2 k = w2i (<< (i2w 1, i2W k)));
val test9b = checkrange (8,70)
    (fn k => 0 = w2i (<< (i2w 1, i2W k)));
val test9c = checkrange (~50,50)
    (fn k => let val r = w2i (<< (i2w 1, i2W k))
	     in 0 <= r andalso r < 256 end);
val test9d = checkrange (~50,50)
    (fn k => let val r = w2i (>> (i2w 1, i2W k))
	     in 0 <= r andalso r < 256 end);
val test9e = checkrange (0, 127) 
    (fn i => 2 * i = w2i (<< (i2w i, i2W 1)));
val test9f = checkrange (0, 255)
    (fn i => i div 2 = w2i (>> (i2w i, i2W 1)));
val test9g = checkrange (0,64)
    (fn k => rwp 255 k = w2i (>> (i2w 255, i2W k)));
val test9h = checkrange (1,65)
    (fn k => 0 = w2i (<< (i2w 1, i2W (~k))));
val test9i = checkrange (1,65)
    (fn k => 0 = w2i (>> (i2w 1, i2W (~k))));

val test10a = checkrange (1,65)
    (fn k => 0 = w2i (~>> (i2w 1, i2W (~k))));
val test10b = checkrange (1,65)
    (fn k => ~1 = w2ix (~>> (i2w 255, i2W (~k))));
val test10c = checkrange (~50,50)
    (fn k => let val r = w2i (~>> (i2w 1, i2W k))
	     in 0 <= r andalso r < 256 end);
val test10d = checkrange (~128, 127)
    (fn i => i div 2 = toIntX (~>> (i2w i, i2W 1)));
val test10e = checkrange (0,65)
    (fn k => rwp ~128 k = toIntX (~>> (i2w ~128, i2W k)));

val test11a = check (Word8.>  (i2w 255, i2w 254));
val test11b = check (Word8.<  (i2w 253, i2w 254));
val test11c = check (Word8.>= (i2w 128, i2w 128));
val test11d = check (Word8.>= (i2w 128, i2w 127));
val test11e = check (Word8.<= (i2w 1,   i2w 1));
val test11f = check (Word8.<= (i2w 0,   i2w 1));

val test12a = check (w2i(Word8.+(i2w   5, i2w  10)) =  15);
val test12b = check (w2i(Word8.+(i2w 127, i2w  11)) = 138);
val test12c = check (w2i(Word8.+(i2w 254, i2w   3)) =   1);
val test12d = check (w2i(Word8.-(i2w  10, i2w   3)) =   7);
val test12e = check (w2i(Word8.-(i2w 138, i2w  11)) = 127);
val test12f = check (w2i(Word8.-(i2w   1, i2w   3)) = 254);
val test12g = check (w2i(Word8.*(i2w   5, i2w  11)) =  55);
val test12h = check (w2i(Word8.*(i2w   4, i2w  35)) = 140);
val test12i = check (w2i(Word8.*(i2w   3, i2w 129)) = 131);
val test12j = check (w2i(Word8.div(i2w  10, i2w 3)) =   3);
val test12k = check (w2i(Word8.div(i2w 255, i2w 1)) = 255);
val test12l = check (w2i(Word8.div(i2w 242, i2w 3)) =  80);
val test12m = check (w2i(Word8.mod(i2w  10, i2w 3)) =   1);
val test12n = check (w2i(Word8.mod(i2w 255, i2w 1)) =   0);
val test12o = check (w2i(Word8.mod(i2w 242, i2w 3)) =   2);
val test12p = (Word8.div(i2w 0, i2w 256) seq "WRONG")
              handle Div => "OK" | _ => "WRONG";
val test12q = (Word8.mod(i2w 0, i2w 256) seq "WRONG")
              handle Div => "OK" | _ => "WRONG";

fun chk f (s, r) = 
    check'(fn _ => 
	   case f s of
	       SOME res => res = i2w r
	     | NONE     => false)

fun chkScan fmt = chk (StringCvt.scanString (scan fmt))

val test13a = 
    List.map (chk fromString)
             [("21", 33),
	      ("0", 0),
	      ("ff", 255),
	      ("FF", 255),
	      (" \n\t21Grap", 33)];

val test13b = 
    List.map (fn s => case fromString s of NONE => "OK" | _ => "WRONG")
	   ["", "-", "~", "+", " \n\t", " \n\t-", " \n\t~", " \n\t+", 
	    "+1", "~1", "-1", "GG"];	    

val test13c = (fromString "100" seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

val test13d = (fromString "FFFFFFFFFFFFFFF" seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

val test14a = 
    List.map (chkScan StringCvt.DEC)
             [("123", 123),
	      ("0", 0),
	      ("255", 255),
	      (" \n\t123crap", 123)];

val test14b = 
    List.map (fn s => case StringCvt.scanString (scan StringCvt.DEC) s 
	              of NONE => "OK" | _ => "WRONG")
	   ["", "-", "~", "+", " \n\t", " \n\t-", " \n\t~", " \n\t+", 
	    "+1", "~1", "-1", "ff"];	    

val test14c = (StringCvt.scanString (scan StringCvt.DEC) "256" seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

val test14d = (StringCvt.scanString (scan StringCvt.DEC) "9999999999999999" 
	       seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

val test15a = 
    List.map (chkScan StringCvt.BIN)
             [("10010", 18),
	      (" \n\t10010crap", 18)];

val test15b = 
    List.map (fn s => case StringCvt.scanString (scan StringCvt.BIN) s 
	              of NONE => "OK" | _ => "WRONG")
	   ["", "-", "~", "+", " \n\t", " \n\t-", " \n\t~", " \n\t+", 
	    "+1", "~1", "-1", "2", "8", "ff"];

val test15c = (StringCvt.scanString (scan StringCvt.BIN) "100000000" 
	       seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

val test15d = (StringCvt.scanString (scan StringCvt.BIN) 
	       "1111111111111111111111111111111111111111111111111111111111" 
	       seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

val test16a = 
    List.map (chkScan StringCvt.OCT)
             [("207", 135),
	      ("0", 0),
	      ("377", 255),
	      (" \n\t207crap", 135)];

val test16b = 
    List.map (fn s => case StringCvt.scanString (scan StringCvt.OCT) s 
	              of NONE => "OK" | _ => "WRONG")
	   ["", "-", "~", "+", " \n\t", " \n\t-", " \n\t~", " \n\t+", 
	    "+1", "~1", "-1", "8", "ff"];

val test16c = (StringCvt.scanString (scan StringCvt.OCT) "400" seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

val test16d = (StringCvt.scanString (scan StringCvt.OCT) 
	       "7777777777777777777777777777777777777777777" seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

val test17a = 
    List.map (chkScan StringCvt.HEX)
             [("21", 33),
	      (" \n\t21Grap", 33)];

val test17b = 
    List.map (fn s => case StringCvt.scanString (scan StringCvt.HEX) s 
	              of NONE => "OK" | _ => "WRONG")
	   ["", "-", "~", "+", " \n\t", " \n\t-", " \n\t~", " \n\t+", 
	    "+1", "~1", "-1"];

val test17c = (StringCvt.scanString (scan StringCvt.HEX) "100" seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

val test17d = (StringCvt.scanString (scan StringCvt.HEX) 
	       "FFFFFFFFFFFFFFFFFF" seq "WRONG") 
              handle Overflow => "OK" | _ => "WRONG";

local 
    fun fromToString i = 
	fromString (toString (fromInt i)) = SOME (fromInt i);

    fun scanFmt radix i = 
	let val w = fromInt i
	    val s = fmt radix w
	in StringCvt.scanString (scan radix) s = SOME w end;

in
val test18 = 
    check'(fn _ => range (0, 255) fromToString);

val test19 = 
    check'(fn _ => range (0, 255) (scanFmt StringCvt.BIN));

val test20 = 
    check'(fn _ => range (0, 255) (scanFmt StringCvt.OCT));

val test21 = 
    check'(fn _ => range (0, 255) (scanFmt StringCvt.DEC));

val test22 = 
    check'(fn _ => range (0, 255) (scanFmt StringCvt.HEX));
end
end;

@


1.5
log
@[Bug #30090]
Remove uses of MLWorks.IO
@
text
@d8 4
d34 1
a34 1
Shell.Build.loadSource "basis.__int";
a46 5

Shell.Build.loadSource "basis.__word8";
Shell.Build.loadSource "basis.__word";
Shell.Build.loadSource "basis.__string_cvt";
Shell.Build.loadSource "basis.__list";
@


1.4
log
@[Bug #1728]
__integer becomes __int
@
text
@d8 4
a30 3
val output = MLWorks.IO.output
val std_out = MLWorks.IO.std_out
val flush_out = MLWorks.IO.flush_out
a32 1
fun say s = (output(std_out, s); flush_out std_out);
@


1.4.5.1
log
@branched from 1.4
@
text
@a7 4
 *  Revision 1.4  1996/11/06  12:06:29  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 *  Revision 1.4.5.1  1997/05/12  11:08:05  hope
 *  branched from 1.4
 *
@


1.4.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 *  Revision 1.4.5.1  1997/05/12  11:08:05  hope
 *  branched from 1.4
 *
@


1.4.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 *  Revision 1.4.5.1  1997/05/12  11:08:05  hope
 *  branched from 1.4
 *
@


1.4.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 *  Revision 1.4.5.1.1.1  1997/07/28  18:49:40  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.4.4.1
log
@branched from 1.4
@
text
@a7 4
 *  Revision 1.4  1996/11/06  12:06:29  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.3.1
log
@branched from 1.4
@
text
@a7 4
 *  Revision 1.4  1996/11/06  12:06:29  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.3.1.1.1
log
@branched from 1.4.3.1
@
text
@a7 3
 *  Revision 1.4.3.1  1996/12/17  18:14:32  hope
 *  branched from 1.4
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a7 4
 *  Revision 1.4  1996/11/06  12:06:29  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a7 4
 *  Revision 1.4  1996/11/06  12:06:29  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.1.1.1.1
log
@branched from 1.4.1.1
@
text
@a7 3
 *  Revision 1.4.1.1  1996/11/14  13:17:45  hope
 *  branched from 1.4
 *
@


1.3
log
@Remove references to toplevel
@
text
@d8 3
d26 1
a26 1
Shell.Build.loadSource "basis.__integer";
@


1.2
log
@stringcvt -> string_cvt
@
text
@d7 4
a10 1
 *  $Log: basis:word8s.sml,v $
d22 1
a22 1
Shell.Build.loadSource "basis.toplevel";
@


1.2.3.1
log
@branched from 1.2
@
text
@d7 1
a7 4
 *  $Log: word8s.sml,v $
 *  Revision 1.2  1996/06/04  19:51:17  io
 *  stringcvt -> string_cvt
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@d7 1
a7 4
 *  $Log: word8s.sml,v $
 *  Revision 1.2  1996/06/04  19:51:17  io
 *  stringcvt -> string_cvt
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@d7 1
a7 4
 *  $Log: word8s.sml,v $
 *  Revision 1.2  1996/06/04  19:51:17  io
 *  stringcvt -> string_cvt
 *
@


1.1
log
@new unit
New test
@
text
@d7 5
a11 1
 *  $Log: basis:char.sml,v $
d40 1
a40 1
Shell.Build.loadSource "basis.__stringcvt";
@
