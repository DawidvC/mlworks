head	1.15;
access;
symbols
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.15
	MLWorks_20c0_1998_08_04:1.15
	MLWorks_20b2c2_1998_06_19:1.15
	MLWorks_20b2_Windows_1998_06_12:1.15
	MLWorks_20b1c1_1998_05_07:1.15
	MLWorks_20b0_1998_04_07:1.15
	MLWorks_20b0_1998_03_20:1.15
	MLWorks_20m2_1998_02_16:1.15
	MLWorks_20m1_1997_10_23:1.13
	MLWorks_11r1:1.13.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.13.1.1.1.1
	MLWorks_10r3:1.13.1.1.3
	MLWorks_10r2_551:1.13.1.1.2
	MLWorks_11:1.13.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.13.1.1
	MLWorks_20m0_1997_06_20:1.13
	MLWorks_1_0_r2c2_1997_06_14:1.13.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.13.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.13.1
	MLWorks_BugFix_1997_04_24:1.13
	MLWorks_1_0_r2_Win32_1997_04_11:1.13
	MLWorks_1_0_r2_Unix_1997_04_04:1.13
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.3.1.1
	MLWorks_gui_1996_12_18:1.8.4
	MLWorks_1_0_Win32_1996_12_17:1.8.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.1.1
	MLWorks_1_0_Irix_1996_11_28:1.8.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.2
	MLWorks_1_0_Unix_1996_11_14:1.8.1
	MLWorks_Open_Beta2_1996_10_11:1.7.2
	MLWorks_License_dev:1.7.1
	MLWorks_1_open_beta_1996_09_13:1.6.1
	MLWorks_Open_Beta_1996_08_22:1.2;
locks; strict;
comment	@# @;


1.15
date	98.01.30.12.21.09;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	97.11.25.19.25.59;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	97.04.02.21.53.45;	author jont;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	97.03.24.14.24.48;	author andreww;	state Exp;
branches;
next	1.11;

1.11
date	97.03.05.11.50.23;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	97.02.26.12.31.20;	author andreww;	state Exp;
branches;
next	1.9;

1.9
date	97.01.30.16.05.49;	author andreww;	state Exp;
branches;
next	1.8;

1.8
date	96.11.08.15.31.55;	author matthew;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1;
next	1.7;

1.7
date	96.10.01.12.58.44;	author io;	state Exp;
branches
	1.7.1.1
	1.7.2.1;
next	1.6;

1.6
date	96.09.09.11.14.02;	author io;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	96.09.07.00.02.28;	author io;	state Exp;
branches;
next	1.4;

1.4
date	96.08.28.23.46.33;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	96.08.27.09.41.10;	author andreww;	state Exp;
branches;
next	1.2;

1.2
date	96.08.14.12.08.45;	author io;	state Exp;
branches;
next	1.1;

1.1
date	96.08.05.16.20.02;	author andreww;	state Exp;
branches;
next	;

1.6.1.1
date	96.09.13.11.37.46;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	96.10.07.16.29.02;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.10.17.11.49.50;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.11.14.13.17.14;	author hope;	state Exp;
branches
	1.8.1.1.1.1;
next	;

1.8.1.1.1.1
date	96.11.28.15.27.43;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.11.22.18.35.03;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.12.17.18.14.00;	author hope;	state Exp;
branches
	1.8.3.1.1.1;
next	;

1.8.3.1.1.1
date	97.02.24.12.06.51;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.12.18.10.08.58;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	97.05.12.11.07.31;	author hope;	state Exp;
branches
	1.13.1.1.1.1
	1.13.1.1.2.1
	1.13.1.1.3.1;
next	;

1.13.1.1.1.1
date	97.07.28.18.49.39;	author daveb;	state Exp;
branches
	1.13.1.1.1.1.1.1;
next	;

1.13.1.1.1.1.1.1
date	97.10.07.12.14.06;	author jkbrook;	state Exp;
branches;
next	;

1.13.1.1.2.1
date	97.09.08.17.41.23;	author daveb;	state Exp;
branches;
next	;

1.13.1.1.3.1
date	97.09.09.14.40.49;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Answer file for basis/text_io_2.sml test.
@


1.15
log
@[Bug #30330]
Modify answers now that type info correct in object files
@
text
@test succeeded.
test succeeded.
test succeeded.
test succeeded.
test succeeded.
val reportOK : bool -> unit = fn
val x : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="<stringIn>"}, pos=1})
@


1.14
log
@[Bug #30323]
@
text
@d7 1
a7 1
val x : TextIO.StreamIO.instream ref = ref(In _)
@


1.13
log
@Modify to stop displaying syserror type
@
text
@a0 10
structure General = struct ... end
structure Char = struct ... end
structure CharVector = struct ... end
structure CharArray = struct ... end
structure OSPrimIO = struct ... end
structure BinPrimIO = struct ... end
structure TextPrimIO = struct ... end
structure TextIO = struct ... end
structure IO = struct ... end
structure OS = struct ... end
d7 1
a7 1
val x : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=true, more=ref(ISmore(..)), name="<stringIn>"}, pos=1})
@


1.13.1.1
log
@branched from 1.13
@
text
@@


1.13.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.13.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.13.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.13.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.12
log
@[Bug #1960]
upating.
@
text
@d1 10
a10 392
val it : unit = ()
structure General =
  struct
    type exn = exn
    datatype 'a option =
      NONE |
      SOME of 'a
    datatype order =
      EQUAL |
      GREATER |
      LESS
    eqtype unit = unit
    val ! : 'a ref -> 'a = fn
    val := : ('a ref * 'a) -> unit = fn
    val <> : (''a * ''a) -> bool = fn
    exception Bind
    exception Chr
    exception Div
    exception Domain
    val EQUAL : order
    exception Fail of string
    val GREATER : order
    val LESS : order
    exception Match
    val NONE : 'a option
    exception Option
    exception Overflow
    val SOME : 'a -> 'a option
    exception Size
    exception Subscript
    val before : ('a * unit) -> 'a = fn
    val exnMessage : exn -> string = fn
    val exnName : exn -> string = fn
    val getOpt : ('a option * 'a) -> 'a = fn
    val ignore : 'a -> unit = fn
    val isSome : 'a option -> bool = fn
    val o : (('a -> 'b) * ('c -> 'a)) -> 'c -> 'b = fn
    val valOf : 'a option -> 'a = fn
  end
val it : unit = ()
structure Char =
  struct
    eqtype char = char
    eqtype string = string
    val < : (char * char) -> bool = fn
    val <= : (char * char) -> bool = fn
    val > : (char * char) -> bool = fn
    val >= : (char * char) -> bool = fn
    val chr : int -> char = fn
    val compare : (char * char) -> order = fn
    val contains : string -> char -> bool = fn
    val fromCString : string -> char option = fn
    val fromString : string -> char option = fn
    val isAlpha : char -> bool = fn
    val isAlphaNum : char -> bool = fn
    val isAscii : char -> bool = fn
    val isCntrl : char -> bool = fn
    val isDigit : char -> bool = fn
    val isGraph : char -> bool = fn
    val isHexDigit : char -> bool = fn
    val isLower : char -> bool = fn
    val isPrint : char -> bool = fn
    val isPunct : char -> bool = fn
    val isSpace : char -> bool = fn
    val isUpper : char -> bool = fn
    val maxChar : char = #"\255"
    val maxOrd : int = 255
    val minChar : char = #"\000"
    val notContains : string -> char -> bool = fn
    val ord : char -> int = fn
    val pred : char -> char = fn
    val scan : ('a -> (char * 'a) option) -> 'a -> (char * 'a) option = fn
    val succ : char -> char = fn
    val toCString : char -> string = fn
    val toLower : char -> char = fn
    val toString : char -> string = fn
    val toUpper : char -> char = fn
  end
val it : unit = ()
structure CharVector =
  struct
    eqtype elem = char
    eqtype vector = string
    val app : (char -> unit) -> string -> unit = fn
    val appi : ((int * char) -> unit) -> (string * int * int option) -> unit = fn
    val concat : string list -> string = fn
    val extract : (string * int * int option) -> string = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
    val fromList : char list -> string = fn
    val length : string -> int = fn
    val maxLen : int = 16777196
    val sub : (string * int) -> char = fn
    val tabulate : (int * (int -> char)) -> string = fn
  end
val it : unit = ()
structure CharArray =
  struct
    structure Vector =
      struct
        eqtype elem = char
        eqtype vector = string
        val app : (char -> unit) -> string -> unit = fn
        val appi : ((int * char) -> unit) -> (string * int * int option) -> unit = fn
        val concat : string list -> string = fn
        val extract : (string * int * int option) -> string = fn
        val foldl : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
        val foldli : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
        val foldr : ((char * 'a) -> 'a) -> 'a -> string -> 'a = fn
        val foldri : ((int * char * 'a) -> 'a) -> 'a -> (string * int * int option) -> 'a = fn
        val fromList : char list -> string = fn
        val length : string -> int = fn
        val maxLen : int = 16777196
        val sub : (string * int) -> char = fn
        val tabulate : (int * (int -> char)) -> string = fn
      end
    eqtype array = array
    eqtype elem = char
    val app : (char -> unit) -> CharArray.array -> unit = fn
    val appi : ((int * char) -> unit) -> (CharArray.array * int * int option) -> unit = fn
    val array : (int * char) -> CharArray.array = fn
    val copy : {di: int, dst: CharArray.array, len: int option, si: int, src: CharArray.array} -> unit = fn
    val copyVec : {di: int, dst: CharArray.array, len: int option, si: int, src: string} -> unit = fn
    val extract : (CharArray.array * int * int option) -> string = fn
    val foldl : ((char * 'a) -> 'a) -> 'a -> CharArray.array -> 'a = fn
    val foldli : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int option) -> 'a = fn
    val foldr : ((char * 'a) -> 'a) -> 'a -> CharArray.array -> 'a = fn
    val foldri : ((int * char * 'a) -> 'a) -> 'a -> (CharArray.array * int * int option) -> 'a = fn
    val fromList : char list -> CharArray.array = fn
    val length : CharArray.array -> int = fn
    val maxLen : int = 16777196
    val modify : (char -> char) -> CharArray.array -> unit = fn
    val modifyi : ((int * char) -> char) -> (CharArray.array * int * int option) -> unit = fn
    val sub : (CharArray.array * int) -> char = fn
    val tabulate : (int * (int -> char)) -> CharArray.array = fn
    val update : (CharArray.array * int * char) -> unit = fn
  end
val it : unit = ()
structure OSPrimIO =
  struct
    type bin_reader = reader
    type bin_writer = writer
    eqtype file_desc = file_desc
    type text_reader = reader
    type text_writer = writer
    val openApp : string -> OSPrimIO.bin_writer = fn
    val openRd : string -> OSPrimIO.bin_reader = fn
    val openString : string -> OSPrimIO.text_reader = fn
    val openWr : string -> OSPrimIO.bin_writer = fn
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=NONE, getPos=SOME fn, ioDesc=NONE, name="<stdOut>", setPos=SOME fn, verifyPos=SOME fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val stdIn : OSPrimIO.bin_reader = RD {avail=fn, block=NONE, canInput=SOME fn, chunkSize=1, close=fn, endPos=NONE, getPos=SOME fn, ioDesc=NONE, name="<stdIn>", readArr=SOME fn, readArrNB=SOME fn, readVec=SOME fn, readVecNB=SOME fn, setPos=SOME fn, verifyPos=SOME fn}
    val stdOut : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=NONE, getPos=SOME fn, ioDesc=NONE, name="<stdOut>", setPos=SOME fn, verifyPos=SOME fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
    val translateIn : OSPrimIO.bin_reader -> OSPrimIO.text_reader = fn
    val translateOut : OSPrimIO.bin_writer -> OSPrimIO.text_writer = fn
  end
val it : unit = ()
structure BinPrimIO =
  struct
    eqtype array = array
    eqtype elem = word8
    eqtype pos = int
    datatype reader =
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
    type vector = vector
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> BinPrimIO.vector) option, readVecNB: (int -> BinPrimIO.vector option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
    val augmentReader : BinPrimIO.reader -> BinPrimIO.reader = fn
    val augmentWriter : BinPrimIO.writer -> BinPrimIO.writer = fn
    val compare : (int * int) -> order = fn
  end
val it : unit = ()
structure TextPrimIO =
  struct
    eqtype array = array
    eqtype elem = char
    eqtype pos = int
    datatype reader =
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
    eqtype vector = string
    datatype writer =
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: iodesc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: iodesc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
    val augmentReader : OSPrimIO.text_reader -> OSPrimIO.text_reader = fn
    val augmentWriter : OSPrimIO.text_writer -> OSPrimIO.text_writer = fn
    val compare : (int * int) -> order = fn
  end
val it : unit = ()
structure TextIO =
  struct
    structure StreamIO =
      struct
        eqtype elem = char
        type in_pos = in_pos
        type instream = instream
        type out_pos = out_pos
        eqtype outstream = outstream
        eqtype pos = int
        type reader = reader
        eqtype vector = string
        type writer = writer
        val canInput : (TextIO.StreamIO.instream * int) -> int option = fn
        val closeIn : TextIO.StreamIO.instream -> unit = fn
        val closeOut : TextIO.StreamIO.outstream -> unit = fn
        val endOfStream : TextIO.StreamIO.instream -> bool = fn
        val filePosIn : TextIO.StreamIO.in_pos -> int = fn
        val filePosOut : TextIO.StreamIO.out_pos -> int = fn
        val flushOut : TextIO.StreamIO.outstream -> unit = fn
        val getBufferMode : TextIO.StreamIO.outstream -> buffer_mode(hidden) = fn
        val getPosIn : TextIO.StreamIO.instream -> TextIO.StreamIO.in_pos = fn
        val getPosOut : TextIO.StreamIO.outstream -> TextIO.StreamIO.out_pos = fn
        val getReader : TextIO.StreamIO.instream -> (OSPrimIO.text_reader * string) = fn
        val getWriter : TextIO.StreamIO.outstream -> (OSPrimIO.text_writer * buffer_mode(hidden)) = fn
        val input : TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) = fn
        val input1 : TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option = fn
        val inputAll : TextIO.StreamIO.instream -> string = fn
        val inputLine : TextIO.StreamIO.instream -> (string * TextIO.StreamIO.instream) = fn
        val inputN : (TextIO.StreamIO.instream * int) -> (string * TextIO.StreamIO.instream) = fn
        val mkInstream : (OSPrimIO.text_reader * string) -> TextIO.StreamIO.instream = fn
        val mkOutstream : (OSPrimIO.text_writer * buffer_mode(hidden)) -> TextIO.StreamIO.outstream = fn
        val output : (TextIO.StreamIO.outstream * string) -> unit = fn
        val output1 : (TextIO.StreamIO.outstream * char) -> unit = fn
        val outputSubstr : (TextIO.StreamIO.outstream * substring(hidden)) -> unit = fn
        val setBufferMode : (TextIO.StreamIO.outstream * buffer_mode(hidden)) -> unit = fn
        val setPosIn : TextIO.StreamIO.in_pos -> TextIO.StreamIO.instream = fn
        val setPosOut : TextIO.StreamIO.out_pos -> TextIO.StreamIO.outstream = fn
      end
    eqtype elem = char
    eqtype instream = instream ref
    eqtype outstream = outstream ref
    eqtype vector = string
    val canInput : (TextIO.StreamIO.instream ref * int) -> bool = fn
    val closeIn : TextIO.StreamIO.instream ref -> unit = fn
    val closeOut : TextIO.StreamIO.outstream ref -> unit = fn
    val endOfStream : TextIO.StreamIO.instream ref -> bool = fn
    val flushOut : TextIO.StreamIO.outstream ref -> unit = fn
    val getInstream : TextIO.StreamIO.instream ref -> TextIO.StreamIO.instream = fn
    val getOutstream : TextIO.StreamIO.outstream ref -> TextIO.StreamIO.outstream = fn
    val getPosIn : TextIO.StreamIO.instream ref -> TextIO.StreamIO.in_pos = fn
    val getPosOut : TextIO.StreamIO.outstream ref -> TextIO.StreamIO.out_pos = fn
    val input : TextIO.StreamIO.instream ref -> string = fn
    val input1 : TextIO.StreamIO.instream ref -> char option = fn
    val inputAll : TextIO.StreamIO.instream ref -> string = fn
    val inputLine : TextIO.StreamIO.instream ref -> string = fn
    val inputN : (TextIO.StreamIO.instream ref * int) -> string = fn
    val lookahead : TextIO.StreamIO.instream ref -> char option = fn
    val mkInstream : TextIO.StreamIO.instream -> TextIO.StreamIO.instream ref = fn
    val mkOutstream : TextIO.StreamIO.outstream -> TextIO.StreamIO.outstream ref = fn
    val openAppend : string -> TextIO.StreamIO.outstream ref = fn
    val openIn : string -> TextIO.StreamIO.instream ref = fn
    val openOut : string -> TextIO.StreamIO.outstream ref = fn
    val openString : string -> TextIO.StreamIO.instream ref = fn
    val output : (TextIO.StreamIO.outstream ref * string) -> unit = fn
    val output1 : (TextIO.StreamIO.outstream ref * char) -> unit = fn
    val outputSubstr : (TextIO.StreamIO.outstream ref * substring(hidden)) -> unit = fn
    val print : string -> unit = fn
    val scanStream : ((TextIO.StreamIO.instream -> (char * TextIO.StreamIO.instream) option) -> TextIO.StreamIO.instream -> ('a * TextIO.StreamIO.instream) option) -> TextIO.StreamIO.instream ref -> 'a option = fn
    val setInstream : (TextIO.StreamIO.instream ref * TextIO.StreamIO.instream) -> unit = fn
    val setOutstream : (TextIO.StreamIO.outstream ref * TextIO.StreamIO.outstream) -> unit = fn
    val setPosIn : (TextIO.StreamIO.instream ref * TextIO.StreamIO.in_pos) -> unit = fn
    val setPosOut : (TextIO.StreamIO.outstream ref * TextIO.StreamIO.out_pos) -> unit = fn
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(PUTmore WR ..)})
    val stdIn : TextIO.StreamIO.instream ref = ref(In {buffer=Buf {basePos=SOME _, data=_, emptyMeansEof=false, more=ref(GETmore ..), name="<stdIn>"}, pos=0})
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(PUTmore WR ..)})
  end
val it : unit = ()
structure IO =
  struct
    datatype buffer_mode =
      BLOCK_BUF |
      LINE_BUF |
      NO_BUF
    val BLOCK_BUF : IO.buffer_mode
    exception BlockingNotSupported
    exception ClosedStream
    exception Io of {cause: exn, function: string, name: string}
    val LINE_BUF : IO.buffer_mode
    val NO_BUF : IO.buffer_mode
    exception NonblockingNotSupported
    exception RandomAccessNotSupported
    exception TerminatedStream
  end
val it : unit = ()
structure OS =
  struct
    structure FileSys =
      struct
        datatype access_mode =
          A_EXEC |
          A_READ |
          A_WRITE
        eqtype dirstream = dirstream
        eqtype file_id = file_id
        val A_EXEC : OS.FileSys.access_mode
        val A_READ : OS.FileSys.access_mode
        val A_WRITE : OS.FileSys.access_mode
        val access : (string * OS.FileSys.access_mode list) -> bool = fn
        val chDir : string -> unit = fn
        val closeDir : OS.FileSys.dirstream -> unit = fn
        val compare : (OS.FileSys.file_id * OS.FileSys.file_id) -> order = fn
        val fileId : string -> OS.FileSys.file_id = fn
        val fileSize : string -> int = fn
        val fullPath : string -> string = fn
        val getDir : unit -> string = fn
        val hash : OS.FileSys.file_id -> word = fn
        val isDir : string -> bool = fn
        val isLink : string -> bool = fn
        val mkDir : string -> unit = fn
        val modTime : string -> time(hidden) = fn
        val openDir : string -> OS.FileSys.dirstream = fn
        val readDir : OS.FileSys.dirstream -> string = fn
        val readLink : string -> string = fn
        val realPath : string -> string = fn
        val remove : string -> unit = fn
        val rename : {new: string, old: string} -> unit = fn
        val rewindDir : OS.FileSys.dirstream -> unit = fn
        val rmDir : string -> unit = fn
        val setTime : (string * time(hidden) option) -> unit = fn
        val tmpName : unit -> string = fn
      end
    structure IO =
      struct
        structure Kind = struct ... end
        eqtype iodesc = iodesc
        eqtype iodesc_kind = iodesc_kind
        eqtype poll_desc = poll_desc
        eqtype poll_info = poll_info
        exception Poll
        val compare : (OS.IO.iodesc * OS.IO.iodesc) -> order = fn
        val hash : OS.IO.iodesc -> word = fn
        val infoToPollDesc : OS.IO.poll_info -> OS.IO.poll_desc = fn
        val isIn : OS.IO.poll_info -> bool = fn
        val isOut : OS.IO.poll_info -> bool = fn
        val isPri : OS.IO.poll_info -> bool = fn
        val kind : OS.IO.iodesc -> OS.IO.iodesc_kind = fn
        val poll : (OS.IO.poll_desc list * time(hidden) option) -> OS.IO.poll_info list = fn
        val pollDesc : OS.IO.iodesc -> OS.IO.poll_desc option = fn
        val pollIn : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollOut : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollPri : OS.IO.poll_desc -> OS.IO.poll_desc = fn
        val pollToIODesc : OS.IO.poll_desc -> OS.IO.iodesc = fn
      end
    structure Path =
      struct
        exception Path
        val base : string -> string = fn
        val concat : (string * string) -> string = fn
        val currentArc : string = "."
        val dir : string -> string = fn
        val ext : string -> string option = fn
        val file : string -> string = fn
        val fromString : string -> {arcs: string list, isAbs: bool, vol: string} = fn
        val fromUnixPath : string -> string = fn
        val getParent : string -> string = fn
        val getVolume : string -> string = fn
        val isAbsolute : string -> bool = fn
        val isCanonical : string -> bool = fn
        val isRelative : string -> bool = fn
        val isRoot : string -> bool = fn
        val joinBaseExt : {base: string, ext: string option} -> string = fn
        val joinDirFile : {dir: string, file: string} -> string = fn
        val mkAbsolute : (string * string) -> string = fn
        val mkCanonical : string -> string = fn
        val mkRelative : (string * string) -> string = fn
        val parentArc : string = ".."
        val splitBaseExt : string -> {base: string, ext: string option} = fn
        val splitDirFile : string -> {dir: string, file: string} = fn
        val toString : {arcs: string list, isAbs: bool, vol: string} -> string = fn
        val toUnixPath : string -> string = fn
        val validVolume : {isAbs: bool, vol: string} -> bool = fn
      end
    structure Process =
      struct
        eqtype status = int
        val atExit : (unit -> unit) -> unit = fn
        val exit : int -> 'a = fn
        val failure : int = 1
        val getEnv : string -> string option = fn
        val success : int = 0
        val system : string -> int = fn
        val terminate : int -> 'a = fn
      end
    eqtype syserror = int
    exception SysErr of (string * syserror option)
    val errorMsg : int -> string = fn
    val errorName : int -> string = fn
    val syserror : string -> int option = fn
  end
@


1.11
log
@Modify because Path now has toUnixPath and fromUnixPath
@
text
@d152 1
a152 1
    val stdErr : OSPrimIO.bin_writer = WR {block=NONE, canOutput=SOME fn, chunkSize=1, close=fn, endPos=SOME fn, getPos=SOME fn, ioDesc=NONE, name="<stdOut>", setPos=SOME fn, verifyPos=SOME fn, writeArr=SOME fn, writeArrNB=SOME fn, writeVec=SOME fn, writeVecNB=SOME fn}
@


1.10
log
@[Bug #1759]
recompiling
changes owing to new TEXT_STREAM_IO signature.
@
text
@d357 1
d373 1
@


1.9
log
@[Bug #1904]
mono vectors no longer equality types.
@
text
@d221 1
d227 1
@


1.8
log
@[Bug #1661]
Updating
@
text
@d166 1
a166 1
    eqtype vector = vector
@


1.8.4.1
log
@branched from 1.8
@
text
@@


1.8.3.1
log
@branched from 1.8
@
text
@@


1.8.3.1.1.1
log
@branched from 1.8.3.1
@
text
@@


1.8.2.1
log
@branched from 1.8
@
text
@@


1.8.1.1
log
@branched from 1.8
@
text
@@


1.8.1.1.1.1
log
@branched from 1.8.1.1
@
text
@@


1.7
log
@[Bug #1626]
update option in toCString
@
text
@d165 1
a165 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d168 3
a170 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> BinPrimIO.vector) option, readVecNB: (int -> BinPrimIO.vector option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
d182 1
a182 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d185 3
a187 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: io_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: io_desc(hidden) option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
d326 2
a327 2
        eqtype io_desc = io_desc
        eqtype io_desc_kind = io_desc_kind
d331 2
a332 2
        val compare : (OS.IO.io_desc * OS.IO.io_desc) -> order = fn
        val hash : OS.IO.io_desc -> word = fn
d337 1
a337 1
        val kind : OS.IO.io_desc -> OS.IO.io_desc_kind = fn
d339 1
a339 1
        val pollDesc : OS.IO.io_desc -> OS.IO.poll_desc option = fn
d343 1
a343 1
        val pollToIODesc : OS.IO.poll_desc -> OS.IO.io_desc = fn
@


1.7.2.1
log
@branched from 1.7
@
text
@@


1.7.1.1
log
@branched from 1.7
@
text
@@


1.6
log
@remove banner
@
text
@d74 1
a74 1
    val toCString : char -> string option = fn
@


1.6.1.1
log
@branched from 1.6
@
text
@@


1.5
log
@updating for commercial version flyer
@
text
@a0 2
commercial version may be purchased directly from Harlequin.

@


1.4
log
@Update wrt change in io_desc type.
@
text
@d1 2
@


1.3
log
@[Bug #1566]
updating.
,
@
text
@d165 1
a165 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d168 3
a170 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> BinPrimIO.vector) option, readVecNB: (int -> BinPrimIO.vector option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: BinPrimIO.vector, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
d182 1
a182 1
      RD of {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, readArr: ({buf: array, i: int, sz: int option} -> int) option, readArrNB: ({buf: array, i: int, sz: int option} -> int option) option, readVec: (int -> vector) option, readVecNB: (int -> vector option) option, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option}
d185 3
a187 3
      WR of {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> pos) option, getPos: (unit -> pos) option, ioDesc: file_desc option, name: string, setPos: (pos -> unit) option, verifyPos: (unit -> pos) option, writeArr: ({buf: array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: array, i: int, sz: int option} -> int option) option, writeVec: ({buf: vector, i: int, sz: int option} -> int) option, writeVecNB: ({buf: vector, i: int, sz: int option} -> int option) option}
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> OSPrimIO.text_reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: CharArray.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: CharArray.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> OSPrimIO.text_writer
d326 1
a326 1
        eqtype io_desc = file_desc
d331 2
a332 2
        val compare : (OSPrimIO.file_desc * OSPrimIO.file_desc) -> order = fn
        val hash : OSPrimIO.file_desc -> word = fn
d337 1
a337 1
        val kind : OSPrimIO.file_desc -> OS.IO.io_desc_kind = fn
d339 1
a339 1
        val pollDesc : OSPrimIO.file_desc -> OS.IO.poll_desc option = fn
d343 1
a343 1
        val pollToIODesc : OS.IO.poll_desc -> OSPrimIO.file_desc = fn
@


1.2
log
@switch off Compiling messages...
@
text
@d264 1
a264 1
    val stdErr : TextIO.StreamIO.outstream ref = ref(Out {closed=ref(false), data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(SOME WR ..)})
d266 1
a266 1
    val stdOut : TextIO.StreamIO.outstream ref = ref(Out {closed=ref(false), data=A(#B[0]), mode=ref(NO_BUF), name="<stdOut>", pos=ref(0), writer=ref(SOME WR ..)})
@


1.1
log
@new unit
Answer file for basis/text_io_2.sml test.
@
text
@a1 2
Compiling basis.general
Compiling basis.__general
a40 12
Compiling basis.toplevel
Compiling basis.string_cvt
Compiling basis.__pre_basis
Compiling basis.__pre_string_cvt
Compiling basis.__string_cvt
Compiling basis.char
Compiling basis.__preinteger
Compiling basis.__preint32
Compiling basis.integer
Compiling basis.__integer
Compiling basis.__pre_char
Compiling basis.__char
a79 4
Compiling basis.mono_vector
Compiling basis.list
Compiling basis.__list
Compiling basis.__charvector
a98 2
Compiling basis.mono_array
Compiling basis.__chararray
a140 45
Compiling basis.__preword32
Compiling basis.__preword
Compiling basis.word
Compiling basis.__word
Compiling basis.__word8
Compiling basis.__word8vector
Compiling basis.__word8array
Compiling basis.__position
Compiling basis.math
Compiling basis.__math
Compiling basis.ieeereal
Compiling basis.__ieeereal
Compiling basis.__prereal
Compiling basis.real
Compiling basis.__real
Compiling basis.time
Compiling unix.__time
Compiling basis.os_file_sys
Compiling basis.os_path
Compiling basis.os_process
Compiling basis.os_io
Compiling basis.os
Compiling basis.__word32
Compiling unix.unixos
Compiling unix._os
Compiling unix._unixos
Compiling unix.__unixos
Compiling basis.string
Compiling basis.__string
Compiling unix.__os_path
Compiling unix._os_file_sys
Compiling unix.__os_file_sys
Compiling basis.__exit
Compiling basis.exit
Compiling basis._os_process
Compiling basis.__os_process
Compiling unix._os_io
Compiling unix.__os_io
Compiling unix.__os
Compiling basis.prim_io
Compiling basis.os_prim_io
Compiling basis._prim_io
Compiling basis.__bin_prim_io
Compiling basis.__text_prim_io
Compiling unix.__os_prim_io
d166 1
a166 1
    eqtype vector = string
d169 2
a170 2
    val RD : {avail: unit -> int option, block: (unit -> unit) option, canInput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, readArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, readArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, readVec: (int -> string) option, readVecNB: (int -> string option) option, setPos: (int -> unit) option, verifyPos: (unit -> int) option} -> BinPrimIO.reader
    val WR : {block: (unit -> unit) option, canOutput: (unit -> bool) option, chunkSize: int, close: unit -> unit, endPos: (unit -> int) option, getPos: (unit -> int) option, ioDesc: OSPrimIO.file_desc option, name: string, setPos: (int -> unit) option, verifyPos: (unit -> int) option, writeArr: ({buf: BinPrimIO.array, i: int, sz: int option} -> int) option, writeArrNB: ({buf: BinPrimIO.array, i: int, sz: int option} -> int option) option, writeVec: ({buf: string, i: int, sz: int option} -> int) option, writeVecNB: ({buf: string, i: int, sz: int option} -> int option) option} -> BinPrimIO.writer
a192 12
Compiling basis.io
Compiling basis.__io
Compiling basis.stream_io
Compiling basis._stream_io
Compiling basis.__stream_io
Compiling basis.imperative_io
Compiling basis._imperative_io
Compiling basis.substring
Compiling basis.__substring
Compiling basis.text_io
Compiling basis._text_io
Compiling basis.__text_io
@
