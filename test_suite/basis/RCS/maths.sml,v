head	1.8;
access;
symbols
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.8
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.8
	MLWorks_20b0_1998_04_07:1.8
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.8
	MLWorks_20m1_1997_10_23:1.7
	MLWorks_11r1:1.4.5.1.1.1.1
	MLWorks_11c0_1997_09_09:1.4.5.1.1.1
	MLWorks_10r3:1.4.5.1.3
	MLWorks_10r2_551:1.4.5.1.2
	MLWorks_11:1.4.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.4.5.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.4.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.4.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.4.5
	MLWorks_BugFix_1997_04_24:1.4
	MLWorks_1_0_r2_Win32_1997_04_11:1.4
	MLWorks_1_0_r2_Unix_1997_04_04:1.4
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.3.1.1
	MLWorks_gui_1996_12_18:1.4.4
	MLWorks_1_0_Win32_1996_12_17:1.4.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.4.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.4.1.1
	MLWorks_1_0_Irix_1996_11_28:1.4.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.2
	MLWorks_1_0_Unix_1996_11_14:1.4.1
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ *  @;


1.8
date	97.11.25.13.44.56;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	97.10.09.15.39.23;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	97.09.25.13.23.26;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	97.05.28.11.06.35;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	96.11.06.13.36.39;	author andreww;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1
	1.4.4.1
	1.4.5.1;
next	1.3;

1.3
date	96.11.06.12.05.12;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	96.10.22.13.20.44;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.12.14.39;	author matthew;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	96.09.13.11.37.43;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.28.59;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.49.48;	author hope;	state Exp;
branches;
next	;

1.4.1.1
date	96.11.14.13.17.11;	author hope;	state Exp;
branches
	1.4.1.1.1.1;
next	;

1.4.1.1.1.1
date	96.11.28.15.27.40;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.11.22.18.35.00;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.12.17.18.13.57;	author hope;	state Exp;
branches
	1.4.3.1.1.1;
next	;

1.4.3.1.1.1
date	97.02.24.12.06.48;	author hope;	state Exp;
branches;
next	;

1.4.4.1
date	96.12.18.10.08.55;	author hope;	state Exp;
branches;
next	;

1.4.5.1
date	97.05.12.11.07.28;	author hope;	state Exp;
branches
	1.4.5.1.1.1
	1.4.5.1.2.1
	1.4.5.1.3.1;
next	;

1.4.5.1.1.1
date	97.07.28.18.49.35;	author daveb;	state Exp;
branches
	1.4.5.1.1.1.1.1;
next	;

1.4.5.1.1.1.1.1
date	97.10.07.12.14.58;	author jkbrook;	state Exp;
branches;
next	1.4.5.1.1.1.1.2;

1.4.5.1.1.1.1.2
date	97.10.07.17.31.35;	author jkbrook;	state Exp;
branches;
next	1.4.5.1.1.1.1.3;

1.4.5.1.1.1.1.3
date	97.10.12.16.14.57;	author jkbrook;	state Exp;
branches;
next	;

1.4.5.1.2.1
date	97.09.08.17.41.17;	author daveb;	state Exp;
branches;
next	;

1.4.5.1.3.1
date	97.09.09.14.40.44;	author daveb;	state Exp;
branches;
next	1.4.5.1.3.2;

1.4.5.1.3.2
date	97.09.25.16.10.03;	author jkbrook;	state Exp;
branches;
next	1.4.5.1.3.3;

1.4.5.1.3.3
date	97.10.12.16.33.34;	author jkbrook;	state Exp;
branches;
next	;


desc
@new unit
New test
@


1.8
log
@[Bug #30323]
@
text
@(*  ==== Testing ====
 *
    Result: OK
 *
 *
 *  Revision Log
 *  ------------
 *  $Log: maths.sml,v $
 *  Revision 1.7  1997/10/09  15:39:23  jont
 *  [Bug #30279]
 *  Remove duplicated test names 12j and 12k
 *  Add further tests for integer exponents
 *
 *  Revision 1.6  1997/09/25  13:23:26  jont
 *  [Bug #70012]
 *  Improved testing of pow function
 *
 *  Revision 1.5  1997/05/28  11:06:35  jont
 *  [Bug #30090]
 *  Remove uses of MLWorks.IO
 *
 *  Revision 1.4  1996/11/06  13:36:39  andreww
 *  [Bug #1711]
 *  reals no longer equality type.
 *
 *  Revision 1.3  1996/11/06  12:05:12  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
 *  Revision 1.2  1996/10/22  13:20:44  jont
 *  Remove references to toplevel
 *
 *  Revision 1.1  1996/05/22  12:14:39  matthew
 *  new unit
 *  New test
 *
*)

(* test/math.sml 
   PS 1995-02-25
   modified for MLWorks Fri May 17 10:44:35 1996
*)

fun check b = if b then "OK" else "WRONG";
fun check' f = (if f () then "OK" else "WRONG") handle _ => "EXN";

fun range (from, to) p = 
  let open Int
  in
    (from > to) orelse (p from) andalso (range (from+1, to) p)
  end;

fun checkrange bounds = check o range bounds;

val _ = Shell.Options.set(Shell.Options.Language.oldDefinition,true);

local
  fun check_nan (a : real) =
    if a = a then "WRONG"
    else "OK"

  open Math
  val MAXDOUBLE = 8.98846567431157E307;
  val MINDOUBLE = 4.94065645841246544E~324
  val PI = 3.14159265358979323846;
  val E = 2.7182818284590452354;
  val posinf = 1.0 / 0.0
  val neginf = ~posinf
  val eps = 1E~7;
  fun check1 (opr, a, r) =
    let val res = opr a
    in
      if r = res orelse r = 0.0 andalso abs res <= eps orelse abs(res/r - 1.0) <= eps
	then "OK" else "WRONG"
    end;
  fun check2 (opr, a1, a2, r) =
    let val res = opr(a1, a2)
    in
      if r = res orelse
	(r = 0.0 andalso abs res <= eps) orelse
	abs(res/r - 1.0) <= eps
	then "OK" else "WRONG"
    end;
in

val test0a = check(abs(PI - pi) <= eps);
val test0b = check(abs(E - e) <= eps);

val test1a = check1(sqrt, 64.0, 8.0);
val test1b = check1(sqrt, 0.0, 0.0);
val test1c = check_nan (sqrt ~1.0);

val test2a = check1(sin, 0.0, 0.0);
val test2b = check1(sin, pi/2.0, 1.0);
val test2c = check1(sin, pi, 0.0);
val test2d = check1(sin, 3.0*pi/2.0, ~1.0);

val test3a = check1(cos, 0.0, 1.0);
val test3b = check1(cos, pi/2.0, 0.0);
val test3c = check1(cos, pi, ~1.0);
val test3d = check1(cos, 3.0*pi/2.0, 0.0);

val test4a = check1(tan, 0.0, 0.0);
val test4b = check1(tan, pi/4.0, 1.0);
val test4c = check1(tan, pi, 0.0);
val test4d = check1(tan, 3.0*pi/4.0, ~1.0);
val test4e = check1(tan, ~pi/4.0, ~1.0);
val test4f = check((abs(tan (pi/2.0))  > 1E8) handle _ => true);
val test4g = check((abs(tan (~pi/2.0)) > 1E8) handle _ => true);

val test5a = check1(asin, 0.0, 0.0);
val test5b = check1(asin, 1.0, pi/2.0);
val test5c = check1(asin, ~1.0, ~pi/2.0);
val test5d = check_nan (asin 1.1)
val test5e = check_nan (asin ~1.1)

val test6a = check1(acos, 1.0, 0.0);
val test6b = check1(acos, 0.0, pi/2.0);
val test6c = check1(acos, ~1.0, pi);
val test6d = check_nan (acos 1.1)
val test6e = check_nan (acos ~1.1)

val test7a = check1(atan, 0.0, 0.0);
val test7b = check1(atan, 1.0, pi/4.0);
val test7c = check1(atan, ~1.0, ~pi/4.0);
val test7d = check1(atan, 1E8, pi/2.0);
val test7e = check1(atan, ~1E8, ~pi/2.0);

(* atan2 -- here I am in doubt over the argument order, since the New
Basis document is inconsistent with itself and with atan2 in the C
libraries. *)

val test8a = check2(atan2, 0.0, 0.0, 0.0);
val test8b = check2(atan2, 0.0, 1.0, pi/2.0);
val test8c = check2(atan2, 0.0, ~1.0, ~pi/2.0);
val test8d = check2(atan2, 1.0, 1.0, pi/4.0);
val test8e = check2(atan2, 1.0, ~1.0, ~pi/4.0);
val test8f = check2(atan2, ~1.0, ~1.0, ~3.0*pi/4.0);
val test8g = check2(atan2, ~1.0, 1.0, 3.0*pi/4.0);
val test8h = check2(atan2, 1.0, 1E8, pi/2.0);
val test8i = check2(atan2, 1.0, ~1E8, ~pi/2.0);
val test8j = check2(atan2, 1E8, 1.0, 0.0);
val test8k = check2(atan2, ~1E8, 1.0, pi);
val test8l = check2(atan2, ~1E8, ~1.0, ~pi);

val test9a = check1(exp, 0.0, 1.0);
val test9b = check1(exp, 1.0, e);
val test9c = check1(exp, ~1.0, 1.0/e);

val test10a = check1(ln, 1.0, 0.0);
val test10b = check1(ln, e, 1.0);
val test10c = check1(ln, 1.0/e, ~1.0);
val test10d = check1 (ln, 0.0, neginf);
val test10e = check_nan (ln ~1.0);

val nan = pow (~1.0, 1.1);

val test12a = check2(pow, 0.0, 0.0, 1.0); (* arbitrary, might be 0.0 *)
val test12b = check2(pow, 2.0, posinf, posinf);
val test12c = check2(pow, ~2.0, posinf, posinf);
val test12d = check2(pow, 0.5, posinf, 0.0);
val test12e = check2(pow, ~0.5, posinf, 0.0);
val test12f = check2(pow, 2.0, neginf, 0.0);
val test12g = check2(pow, ~2.0, neginf, 0.0);
val test12h = check2(pow, 0.5, neginf, posinf);
val test12i = check2(pow, ~0.5, neginf, posinf);
val test12j = check2(pow, posinf, 2.0, posinf);
val test12k = check2(pow, posinf, 0.5, posinf);
val test12l = check2(pow, posinf, ~2.0, 0.0);
val test12m = check2(pow, posinf, ~0.5, 0.0);
val test12n = check2(pow, neginf, 3.0, neginf);
val test12o = check2(pow, neginf, 2.5, posinf);
val test12p = check2(pow, neginf, 2.0, posinf);
val test12q = check2(pow, neginf, ~3.0, ~0.0);
val test12r = check2(pow, neginf, ~2.5, 0.0);
val test12s = check2(pow, neginf, ~2.0, 0.0);
val test12t = check_nan(pow(0.0, nan));
val test12u = check_nan(pow(~0.0, nan));
val test12v = check_nan(pow(0.5, nan));
val test12w = check_nan(pow(2.0, nan));
val test12x = check_nan(pow(~0.5, nan));
val test12y = check_nan(pow(~2.0, nan));
val test12z = check_nan(pow(posinf, nan));
val test12A = check_nan(pow(neginf, nan));
val test12B = check_nan(pow(nan, nan));
val test12C = check_nan(pow(nan, 0.5));
val test12D = check_nan(pow(nan, 1.0));
val test12E = check_nan(pow(nan, 2.0));
val test12F = check_nan(pow(nan, ~0.5));
val test12G = check_nan(pow(nan, ~1.0));
val test12H = check_nan(pow(nan, ~2.0));
val test12I = check_nan(pow(nan, posinf));
val test12J = check_nan(pow(nan, neginf));
val test12K = check_nan (pow (~1.0, 1.1));
val test12L = check_nan (pow (~1.0, 0.5));
val test12M = check_nan (pow (~2.0, 1.1));
val test12N = check_nan (pow (~2.0, 0.5));
val test12O = check_nan (pow (~0.5, 1.1));
val test12P = check_nan (pow (~0.5, 0.5));
val test12Q = check_nan (pow (1.0, posinf));
val test12R = check_nan (pow (1.0, neginf));
val test12S = check_nan (pow (~1.0, posinf));
val test12T = check_nan (pow (~1.0, neginf));
val test12U = check2(pow, 0.0, ~3.0, posinf);
val test12V = check2(pow, ~0.0, ~3.0, neginf);
val test12W = check2(pow, 0.0, ~2.0, posinf);
val test12X = check2(pow, ~0.0, ~2.0, posinf);
val test12Y = check2(pow, 0.0, 3.0, 0.0);
val test12Z = check2(pow, ~0.0, 3.0, ~0.0);
val test12aa = check2(pow, 0.0, 2.0, 0.0);
val test12ab = check2(pow, ~0.0, 2.0, 0.0);
val test12ac = check2(pow, 7.0, 0.0, 1.0);
val test12ad = check2(pow, 64.0, 0.5, 8.0); 
val test12ae = check2(pow, ~9.0, 2.0, 81.0); 
val test12af = check2(pow, 10.0, ~2.0, 0.01); 
val test12ag = check2(pow, ~10.0, ~2.0, 0.01); 
val test12ah = check2(pow, 0.0, 0.5, 0.0); 
val test12ai = check2(pow, 0.4, ~2.0, 6.25); 
val test12aj = check2 (pow, 0.0, ~1.0,posinf);
val test12ak = check2 (pow, 0.0, ~0.5,posinf);
val test12al = check2 (pow, 3.0, 1000000.0, posinf);
val test13a = check1(log10, 1.0, 0.0);
val test13b = check1(log10, 10.0, 1.0);
val test13c = check1(log10, 100.0, 2.0);
val test13d = check1(log10, 0.1, ~1.0);
val test13e = check1(log10, 0.01, ~2.0);
end
@


1.7
log
@[Bug #30279]
Remove duplicated test names 12j and 12k
Add further tests for integer exponents
@
text
@d9 5
a43 5
local
  val _ = Shell.Options.set(Shell.Options.ValuePrinter.maximumStrDepth, 0);
in
  val _ = Shell.Build.loadSource "basis.__int";
end
a54 2
val _ = Shell.Build.loadSource "basis.__math";

d58 4
a83 3
  fun check_nan (a : real) =
    if a = a then "WRONG"
    else "OK"
@


1.6
log
@[Bug #70012]
Improved testing of pow function
@
text
@d9 4
d39 5
a43 3
Shell.Build.loadSource "basis.__int";
infix 1 seq
fun e1 seq e2 = e2;
d48 4
a51 4
    let open Int
    in
	(from > to) orelse (p from) andalso (range (from+1, to) p)
    end;
d55 1
a55 1
Shell.Build.loadSource "basis.__math";
d57 1
a57 1
Shell.Options.set(Shell.Options.Language.oldDefinition,true);
d60 25
a84 23
    open Math
    val MAXDOUBLE = 8.98846567431157E307;
    val MINDOUBLE = 4.94065645841246544E~324
    val PI = 3.14159265358979323846;
    val E = 2.7182818284590452354;
    val posinf = 1.0 / 0.0
    val neginf = ~posinf
    val eps = 1E~7;
    fun check1 (opr, a, r) =
	let val res = opr a
	in
	    if r = res orelse r = 0.0 andalso abs res <= eps orelse abs(res/r - 1.0) <= eps
		then "OK" else "WRONG"
	end;
    fun check2 (opr, a1, a2, r) =
	let val res = opr(a1, a2)
	in
	    if r = res orelse r = 0.0 andalso abs res <= eps orelse abs(res/r - 1.0) <= eps
		then "OK" else "WRONG"
	end;
    fun check_nan (a : real) =
      if a = a then "WRONG"
      else "OK"
d170 53
a222 57
val test12j = check2(pow, posinf, ~2.0, 0.0);
val test12k = check2(pow, posinf, ~0.5, 0.0);
val test12l = check2(pow, neginf, 3.0, neginf);
val test12m = check2(pow, neginf, 2.5, posinf);
val test12n = check2(pow, neginf, ~3.0, ~0.0);
val test12o = check2(pow, neginf, ~2.5, 0.0);
val test12p = check_nan(pow(0.0, nan));
val test12q = check_nan(pow(~0.0, nan));
val test12r = check_nan(pow(0.5, nan));
val test12s = check_nan(pow(2.0, nan));
val test12t = check_nan(pow(~0.5, nan));
val test12u = check_nan(pow(~2.0, nan));
val test12v = check_nan(pow(posinf, nan));
val test12w = check_nan(pow(neginf, nan));
val test12x = check_nan(pow(nan, nan));
val test12y = check_nan(pow(nan, 0.5));
val test12z = check_nan(pow(nan, 1.0));
val test12A = check_nan(pow(nan, 2.0));
val test12B = check_nan(pow(nan, ~0.5));
val test12C = check_nan(pow(nan, ~1.0));
val test12D = check_nan(pow(nan, ~2.0));
val test12E = check_nan(pow(nan, posinf));
val test12F = check_nan(pow(nan, neginf));
val test12G = check_nan (pow (~1.0, 1.1));
val test12H = check_nan (pow (~1.0, 0.5));
val test12I = check_nan (pow (~2.0, 1.1));
val test12J = check_nan (pow (~2.0, 0.5));
val test12K = check_nan (pow (~0.5, 1.1));
val test12L = check_nan (pow (~0.5, 0.5));
val test12M = check_nan (pow (1.0, posinf));
val test12N = check_nan (pow (1.0, neginf));
val test12O = check_nan (pow (~1.0, posinf));
val test12P = check_nan (pow (~1.0, neginf));
val test12Q = check2(pow, 0.0, ~3.0, posinf);
val test12R = check2(pow, ~0.0, ~3.0, neginf);
val test12S = check2(pow, 0.0, ~2.0, posinf);
val test12T = check2(pow, ~0.0, ~2.0, posinf);
val test12U = check2(pow, 0.0, 3.0, 0.0);
val test12V = check2(pow, ~0.0, 3.0, ~0.0);
val test12W = check2(pow, 0.0, 2.0, 0.0);
val test12X = check2(pow, ~0.0, 2.0, 0.0);

val test12Y = check2(pow, 7.0, 0.0, 1.0);

val test12Z = check2(pow, 64.0, 0.5, 8.0); 
val test12aa = check2(pow, ~9.0, 2.0, 81.0); 

val test12ab = check2(pow, 10.0, ~2.0, 0.01); 
val test12ac = check2(pow, ~10.0, ~2.0, 0.01); 
val test12ad = check2(pow, 0.0, 0.5, 0.0); 
val test12ae = check2(pow, 0.4, ~2.0, 6.25); 

val test12af = check2 (pow, 0.0, ~1.0,posinf);
val test12ag = check2 (pow, 0.0, ~0.5,posinf);

val test12ah = check2 (pow, 3.0, 1000000.0, posinf);

@


1.5
log
@[Bug #30090]
Remove uses of MLWorks.IO
@
text
@d9 4
d149 2
d152 64
a215 14
val test12b = check2(pow, 7.0, 0.0, 1.0); 
val test12c = check2(pow, 0.0, 7.0, 0.0); 
val test12d = check2(pow, 64.0, 0.5, 8.0); 
val test12e = check2(pow, ~9.0, 2.0, 81.0); 

val test12f = check2(pow, 10.0, ~2.0, 0.01); 
val test12g = check2(pow, ~10.0, ~2.0, 0.01); 
val test12h = check2(pow, 0.0, 0.5, 0.0); 
val test12i = check2(pow, 0.4, ~2.0, 6.25); 

val test12j = check2 (pow, 0.0, ~1.0,posinf);
val test12k = check2 (pow, 0.0, ~0.5,posinf);
val test12l = check_nan (pow (~1.0, 1.1));
val test12m = check_nan (pow (~1.0, 0.5));
d217 1
a217 1
val test12n = check2 (pow, 3.0, 1000000.0, posinf);
@


1.4
log
@[Bug #1711]
reals no longer equality type.
@
text
@d9 4
a31 3
val output = MLWorks.IO.output
val std_out = MLWorks.IO.std_out
val flush_out = MLWorks.IO.flush_out
a33 1
fun say s = (output(std_out, s); flush_out std_out);
@


1.4.5.1
log
@branched from 1.4
@
text
@a8 4
 *  Revision 1.4  1996/11/06  13:36:39  andreww
 *  [Bug #1711]
 *  reals no longer equality type.
 *
@


1.4.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 *  Revision 1.4.5.1  1997/05/12  11:07:28  hope
 *  branched from 1.4
 *
@


1.4.5.1.3.2
log
@[Bug #70012]
Merging from trunk:
Make pow tests reflect special-cases list in Basis document
@
text
@a8 3
 *  Revision 1.4.5.1.3.1  1997/09/09  14:40:44  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
a151 2
val nan = pow (~1.0, 1.1);

d153 14
a166 64
val test12b = check2(pow, 2.0, posinf, posinf);
val test12c = check2(pow, ~2.0, posinf, posinf);
val test12d = check2(pow, 0.5, posinf, 0.0);
val test12e = check2(pow, ~0.5, posinf, 0.0);
val test12f = check2(pow, 2.0, neginf, 0.0);
val test12g = check2(pow, ~2.0, neginf, 0.0);
val test12h = check2(pow, 0.5, neginf, posinf);
val test12i = check2(pow, ~0.5, neginf, posinf);
val test12j = check2(pow, posinf, 2.0, posinf);
val test12k = check2(pow, posinf, 0.5, posinf);
val test12j = check2(pow, posinf, ~2.0, 0.0);
val test12k = check2(pow, posinf, ~0.5, 0.0);
val test12l = check2(pow, neginf, 3.0, neginf);
val test12m = check2(pow, neginf, 2.5, posinf);
val test12n = check2(pow, neginf, ~3.0, ~0.0);
val test12o = check2(pow, neginf, ~2.5, 0.0);
val test12p = check_nan(pow(0.0, nan));
val test12q = check_nan(pow(~0.0, nan));
val test12r = check_nan(pow(0.5, nan));
val test12s = check_nan(pow(2.0, nan));
val test12t = check_nan(pow(~0.5, nan));
val test12u = check_nan(pow(~2.0, nan));
val test12v = check_nan(pow(posinf, nan));
val test12w = check_nan(pow(neginf, nan));
val test12x = check_nan(pow(nan, nan));
val test12y = check_nan(pow(nan, 0.5));
val test12z = check_nan(pow(nan, 1.0));
val test12A = check_nan(pow(nan, 2.0));
val test12B = check_nan(pow(nan, ~0.5));
val test12C = check_nan(pow(nan, ~1.0));
val test12D = check_nan(pow(nan, ~2.0));
val test12E = check_nan(pow(nan, posinf));
val test12F = check_nan(pow(nan, neginf));
val test12G = check_nan (pow (~1.0, 1.1));
val test12H = check_nan (pow (~1.0, 0.5));
val test12I = check_nan (pow (~2.0, 1.1));
val test12J = check_nan (pow (~2.0, 0.5));
val test12K = check_nan (pow (~0.5, 1.1));
val test12L = check_nan (pow (~0.5, 0.5));
val test12M = check_nan (pow (1.0, posinf));
val test12N = check_nan (pow (1.0, neginf));
val test12O = check_nan (pow (~1.0, posinf));
val test12P = check_nan (pow (~1.0, neginf));
val test12Q = check2(pow, 0.0, ~3.0, posinf);
val test12R = check2(pow, ~0.0, ~3.0, neginf);
val test12S = check2(pow, 0.0, ~2.0, posinf);
val test12T = check2(pow, ~0.0, ~2.0, posinf);
val test12U = check2(pow, 0.0, 3.0, 0.0);
val test12V = check2(pow, ~0.0, 3.0, ~0.0);
val test12W = check2(pow, 0.0, 2.0, 0.0);
val test12X = check2(pow, ~0.0, 2.0, 0.0);

val test12Y = check2(pow, 7.0, 0.0, 1.0);

val test12Z = check2(pow, 64.0, 0.5, 8.0); 
val test12aa = check2(pow, ~9.0, 2.0, 81.0); 

val test12ab = check2(pow, 10.0, ~2.0, 0.01); 
val test12ac = check2(pow, ~10.0, ~2.0, 0.01); 
val test12ad = check2(pow, 0.0, 0.5, 0.0); 
val test12ae = check2(pow, 0.4, ~2.0, 6.25); 

val test12af = check2 (pow, 0.0, ~1.0,posinf);
val test12ag = check2 (pow, 0.0, ~0.5,posinf);
d168 1
a168 1
val test12ah = check2 (pow, 3.0, 1000000.0, posinf);
@


1.4.5.1.3.3
log
@[Bug #30279]
Merging from trunk:
Remove duplicated test names 12j and 12k
Add further tests for integer exponents
@
text
@a8 5
 *  Revision 1.4.5.1.3.2  1997/09/25  16:10:03  jkbrook
 *  [Bug #70012]
 *  Merging from trunk:
 *  Make pow tests reflect special-cases list in Basis document
 *
d37 7
a43 5
local
  val _ = Shell.Options.set(Shell.Options.ValuePrinter.maximumStrDepth, 0);
in
  val _ = Shell.Build.loadSource "basis.__int";
end
d48 4
a51 4
  let open Int
  in
    (from > to) orelse (p from) andalso (range (from+1, to) p)
  end;
d55 1
a55 1
val _ = Shell.Build.loadSource "basis.__math";
d57 1
a57 1
val _ = Shell.Options.set(Shell.Options.Language.oldDefinition,true);
d60 23
a82 25
  open Math
  val MAXDOUBLE = 8.98846567431157E307;
  val MINDOUBLE = 4.94065645841246544E~324
  val PI = 3.14159265358979323846;
  val E = 2.7182818284590452354;
  val posinf = 1.0 / 0.0
  val neginf = ~posinf
  val eps = 1E~7;
  fun check1 (opr, a, r) =
    let val res = opr a
    in
      if r = res orelse r = 0.0 andalso abs res <= eps orelse abs(res/r - 1.0) <= eps
	then "OK" else "WRONG"
    end;
  fun check2 (opr, a1, a2, r) =
    let val res = opr(a1, a2)
    in
      if r = res orelse
	(r = 0.0 andalso abs res <= eps) orelse
	abs(res/r - 1.0) <= eps
	then "OK" else "WRONG"
    end;
  fun check_nan (a : real) =
    if a = a then "WRONG"
    else "OK"
d168 57
a224 53
val test12l = check2(pow, posinf, ~2.0, 0.0);
val test12m = check2(pow, posinf, ~0.5, 0.0);
val test12n = check2(pow, neginf, 3.0, neginf);
val test12o = check2(pow, neginf, 2.5, posinf);
val test12p = check2(pow, neginf, 2.0, posinf);
val test12q = check2(pow, neginf, ~3.0, ~0.0);
val test12r = check2(pow, neginf, ~2.5, 0.0);
val test12s = check2(pow, neginf, ~2.0, 0.0);
val test12t = check_nan(pow(0.0, nan));
val test12u = check_nan(pow(~0.0, nan));
val test12v = check_nan(pow(0.5, nan));
val test12w = check_nan(pow(2.0, nan));
val test12x = check_nan(pow(~0.5, nan));
val test12y = check_nan(pow(~2.0, nan));
val test12z = check_nan(pow(posinf, nan));
val test12A = check_nan(pow(neginf, nan));
val test12B = check_nan(pow(nan, nan));
val test12C = check_nan(pow(nan, 0.5));
val test12D = check_nan(pow(nan, 1.0));
val test12E = check_nan(pow(nan, 2.0));
val test12F = check_nan(pow(nan, ~0.5));
val test12G = check_nan(pow(nan, ~1.0));
val test12H = check_nan(pow(nan, ~2.0));
val test12I = check_nan(pow(nan, posinf));
val test12J = check_nan(pow(nan, neginf));
val test12K = check_nan (pow (~1.0, 1.1));
val test12L = check_nan (pow (~1.0, 0.5));
val test12M = check_nan (pow (~2.0, 1.1));
val test12N = check_nan (pow (~2.0, 0.5));
val test12O = check_nan (pow (~0.5, 1.1));
val test12P = check_nan (pow (~0.5, 0.5));
val test12Q = check_nan (pow (1.0, posinf));
val test12R = check_nan (pow (1.0, neginf));
val test12S = check_nan (pow (~1.0, posinf));
val test12T = check_nan (pow (~1.0, neginf));
val test12U = check2(pow, 0.0, ~3.0, posinf);
val test12V = check2(pow, ~0.0, ~3.0, neginf);
val test12W = check2(pow, 0.0, ~2.0, posinf);
val test12X = check2(pow, ~0.0, ~2.0, posinf);
val test12Y = check2(pow, 0.0, 3.0, 0.0);
val test12Z = check2(pow, ~0.0, 3.0, ~0.0);
val test12aa = check2(pow, 0.0, 2.0, 0.0);
val test12ab = check2(pow, ~0.0, 2.0, 0.0);
val test12ac = check2(pow, 7.0, 0.0, 1.0);
val test12ad = check2(pow, 64.0, 0.5, 8.0); 
val test12ae = check2(pow, ~9.0, 2.0, 81.0); 
val test12af = check2(pow, 10.0, ~2.0, 0.01); 
val test12ag = check2(pow, ~10.0, ~2.0, 0.01); 
val test12ah = check2(pow, 0.0, 0.5, 0.0); 
val test12ai = check2(pow, 0.4, ~2.0, 6.25); 
val test12aj = check2 (pow, 0.0, ~1.0,posinf);
val test12ak = check2 (pow, 0.0, ~0.5,posinf);
val test12al = check2 (pow, 3.0, 1000000.0, posinf);
@


1.4.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 *  Revision 1.4.5.1  1997/05/12  11:07:28  hope
 *  branched from 1.4
 *
@


1.4.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 *  Revision 1.4.5.1  1997/05/12  11:07:28  hope
 *  branched from 1.4
 *
@


1.4.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 *  Revision 1.4.5.1.1.1  1997/07/28  18:49:35  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.4.5.1.1.1.1.2
log
@[Bug #70012]
Merging from MLWorks_10r3:
Make pow tests reflect special-cases list in Basis document
@
text
@a8 3
 *  Revision 1.4.5.1.1.1.1.1  1997/10/07  12:14:58  jkbrook
 *  branched from MLWorks_11 for label MLWorks_11r1
 *
a154 2
val nan = pow (~1.0, 1.1);

d156 14
a169 64
val test12b = check2(pow, 2.0, posinf, posinf);
val test12c = check2(pow, ~2.0, posinf, posinf);
val test12d = check2(pow, 0.5, posinf, 0.0);
val test12e = check2(pow, ~0.5, posinf, 0.0);
val test12f = check2(pow, 2.0, neginf, 0.0);
val test12g = check2(pow, ~2.0, neginf, 0.0);
val test12h = check2(pow, 0.5, neginf, posinf);
val test12i = check2(pow, ~0.5, neginf, posinf);
val test12j = check2(pow, posinf, 2.0, posinf);
val test12k = check2(pow, posinf, 0.5, posinf);
val test12j = check2(pow, posinf, ~2.0, 0.0);
val test12k = check2(pow, posinf, ~0.5, 0.0);
val test12l = check2(pow, neginf, 3.0, neginf);
val test12m = check2(pow, neginf, 2.5, posinf);
val test12n = check2(pow, neginf, ~3.0, ~0.0);
val test12o = check2(pow, neginf, ~2.5, 0.0);
val test12p = check_nan(pow(0.0, nan));
val test12q = check_nan(pow(~0.0, nan));
val test12r = check_nan(pow(0.5, nan));
val test12s = check_nan(pow(2.0, nan));
val test12t = check_nan(pow(~0.5, nan));
val test12u = check_nan(pow(~2.0, nan));
val test12v = check_nan(pow(posinf, nan));
val test12w = check_nan(pow(neginf, nan));
val test12x = check_nan(pow(nan, nan));
val test12y = check_nan(pow(nan, 0.5));
val test12z = check_nan(pow(nan, 1.0));
val test12A = check_nan(pow(nan, 2.0));
val test12B = check_nan(pow(nan, ~0.5));
val test12C = check_nan(pow(nan, ~1.0));
val test12D = check_nan(pow(nan, ~2.0));
val test12E = check_nan(pow(nan, posinf));
val test12F = check_nan(pow(nan, neginf));
val test12G = check_nan (pow (~1.0, 1.1));
val test12H = check_nan (pow (~1.0, 0.5));
val test12I = check_nan (pow (~2.0, 1.1));
val test12J = check_nan (pow (~2.0, 0.5));
val test12K = check_nan (pow (~0.5, 1.1));
val test12L = check_nan (pow (~0.5, 0.5));
val test12M = check_nan (pow (1.0, posinf));
val test12N = check_nan (pow (1.0, neginf));
val test12O = check_nan (pow (~1.0, posinf));
val test12P = check_nan (pow (~1.0, neginf));
val test12Q = check2(pow, 0.0, ~3.0, posinf);
val test12R = check2(pow, ~0.0, ~3.0, neginf);
val test12S = check2(pow, 0.0, ~2.0, posinf);
val test12T = check2(pow, ~0.0, ~2.0, posinf);
val test12U = check2(pow, 0.0, 3.0, 0.0);
val test12V = check2(pow, ~0.0, 3.0, ~0.0);
val test12W = check2(pow, 0.0, 2.0, 0.0);
val test12X = check2(pow, ~0.0, 2.0, 0.0);

val test12Y = check2(pow, 7.0, 0.0, 1.0);

val test12Z = check2(pow, 64.0, 0.5, 8.0); 
val test12aa = check2(pow, ~9.0, 2.0, 81.0); 

val test12ab = check2(pow, 10.0, ~2.0, 0.01); 
val test12ac = check2(pow, ~10.0, ~2.0, 0.01); 
val test12ad = check2(pow, 0.0, 0.5, 0.0); 
val test12ae = check2(pow, 0.4, ~2.0, 6.25); 

val test12af = check2 (pow, 0.0, ~1.0,posinf);
val test12ag = check2 (pow, 0.0, ~0.5,posinf);
d171 1
a171 1
val test12ah = check2 (pow, 3.0, 1000000.0, posinf);
@


1.4.5.1.1.1.1.3
log
@[Bug #30279]
Merging from trunk:
Remove duplicated test names 12j and 12k
Add further tests for integer exponents
@
text
@a8 5
 *  Revision 1.4.5.1.1.1.1.2  1997/10/07  17:31:35  jkbrook
 *  [Bug #70012]
 *  Merging from MLWorks_10r3:
 *  Make pow tests reflect special-cases list in Basis document
 *
d40 7
a46 5
local
  val _ = Shell.Options.set(Shell.Options.ValuePrinter.maximumStrDepth, 0);
in
  val _ = Shell.Build.loadSource "basis.__int";
end
d51 4
a54 4
  let open Int
  in
    (from > to) orelse (p from) andalso (range (from+1, to) p)
  end;
d58 1
a58 1
val _ = Shell.Build.loadSource "basis.__math";
d60 1
a60 1
val _ = Shell.Options.set(Shell.Options.Language.oldDefinition,true);
d63 23
a85 25
  open Math
  val MAXDOUBLE = 8.98846567431157E307;
  val MINDOUBLE = 4.94065645841246544E~324
  val PI = 3.14159265358979323846;
  val E = 2.7182818284590452354;
  val posinf = 1.0 / 0.0
  val neginf = ~posinf
  val eps = 1E~7;
  fun check1 (opr, a, r) =
    let val res = opr a
    in
      if r = res orelse r = 0.0 andalso abs res <= eps orelse abs(res/r - 1.0) <= eps
	then "OK" else "WRONG"
    end;
  fun check2 (opr, a1, a2, r) =
    let val res = opr(a1, a2)
    in
      if r = res orelse
	(r = 0.0 andalso abs res <= eps) orelse
	abs(res/r - 1.0) <= eps
	then "OK" else "WRONG"
    end;
  fun check_nan (a : real) =
    if a = a then "WRONG"
    else "OK"
d171 57
a227 53
val test12l = check2(pow, posinf, ~2.0, 0.0);
val test12m = check2(pow, posinf, ~0.5, 0.0);
val test12n = check2(pow, neginf, 3.0, neginf);
val test12o = check2(pow, neginf, 2.5, posinf);
val test12p = check2(pow, neginf, 2.0, posinf);
val test12q = check2(pow, neginf, ~3.0, ~0.0);
val test12r = check2(pow, neginf, ~2.5, 0.0);
val test12s = check2(pow, neginf, ~2.0, 0.0);
val test12t = check_nan(pow(0.0, nan));
val test12u = check_nan(pow(~0.0, nan));
val test12v = check_nan(pow(0.5, nan));
val test12w = check_nan(pow(2.0, nan));
val test12x = check_nan(pow(~0.5, nan));
val test12y = check_nan(pow(~2.0, nan));
val test12z = check_nan(pow(posinf, nan));
val test12A = check_nan(pow(neginf, nan));
val test12B = check_nan(pow(nan, nan));
val test12C = check_nan(pow(nan, 0.5));
val test12D = check_nan(pow(nan, 1.0));
val test12E = check_nan(pow(nan, 2.0));
val test12F = check_nan(pow(nan, ~0.5));
val test12G = check_nan(pow(nan, ~1.0));
val test12H = check_nan(pow(nan, ~2.0));
val test12I = check_nan(pow(nan, posinf));
val test12J = check_nan(pow(nan, neginf));
val test12K = check_nan (pow (~1.0, 1.1));
val test12L = check_nan (pow (~1.0, 0.5));
val test12M = check_nan (pow (~2.0, 1.1));
val test12N = check_nan (pow (~2.0, 0.5));
val test12O = check_nan (pow (~0.5, 1.1));
val test12P = check_nan (pow (~0.5, 0.5));
val test12Q = check_nan (pow (1.0, posinf));
val test12R = check_nan (pow (1.0, neginf));
val test12S = check_nan (pow (~1.0, posinf));
val test12T = check_nan (pow (~1.0, neginf));
val test12U = check2(pow, 0.0, ~3.0, posinf);
val test12V = check2(pow, ~0.0, ~3.0, neginf);
val test12W = check2(pow, 0.0, ~2.0, posinf);
val test12X = check2(pow, ~0.0, ~2.0, posinf);
val test12Y = check2(pow, 0.0, 3.0, 0.0);
val test12Z = check2(pow, ~0.0, 3.0, ~0.0);
val test12aa = check2(pow, 0.0, 2.0, 0.0);
val test12ab = check2(pow, ~0.0, 2.0, 0.0);
val test12ac = check2(pow, 7.0, 0.0, 1.0);
val test12ad = check2(pow, 64.0, 0.5, 8.0); 
val test12ae = check2(pow, ~9.0, 2.0, 81.0); 
val test12af = check2(pow, 10.0, ~2.0, 0.01); 
val test12ag = check2(pow, ~10.0, ~2.0, 0.01); 
val test12ah = check2(pow, 0.0, 0.5, 0.0); 
val test12ai = check2(pow, 0.4, ~2.0, 6.25); 
val test12aj = check2 (pow, 0.0, ~1.0,posinf);
val test12ak = check2 (pow, 0.0, ~0.5,posinf);
val test12al = check2 (pow, 3.0, 1000000.0, posinf);
@


1.4.4.1
log
@branched from 1.4
@
text
@a8 4
 *  Revision 1.4  1996/11/06  13:36:39  andreww
 *  [Bug #1711]
 *  reals no longer equality type.
 *
@


1.4.3.1
log
@branched from 1.4
@
text
@a8 4
 *  Revision 1.4  1996/11/06  13:36:39  andreww
 *  [Bug #1711]
 *  reals no longer equality type.
 *
@


1.4.3.1.1.1
log
@branched from 1.4.3.1
@
text
@a8 3
 *  Revision 1.4.3.1  1996/12/17  18:13:57  hope
 *  branched from 1.4
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a8 4
 *  Revision 1.4  1996/11/06  13:36:39  andreww
 *  [Bug #1711]
 *  reals no longer equality type.
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a8 4
 *  Revision 1.4  1996/11/06  13:36:39  andreww
 *  [Bug #1711]
 *  reals no longer equality type.
 *
@


1.4.1.1.1.1
log
@branched from 1.4.1.1
@
text
@a8 3
 *  Revision 1.4.1.1  1996/11/14  13:17:11  hope
 *  branched from 1.4
 *
@


1.3
log
@[Bug #1728]
__integer becomes __int
@
text
@d9 4
d47 1
@


1.2
log
@Remove references to toplevel
@
text
@d9 3
d23 1
a23 1
Shell.Build.loadSource "basis.__integer";
@


1.1
log
@new unit
New test
@
text
@d8 5
a12 1
 *  $Log: basis:char.sml,v $
a19 1
Shell.Build.loadSource "basis.toplevel";
@


1.1.3.1
log
@branched from 1.1
@
text
@d8 1
a8 5
 *  $Log: maths.sml,v $
 *  Revision 1.1  1996/05/22  12:14:39  matthew
 *  new unit
 *  New test
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d8 1
a8 5
 *  $Log: maths.sml,v $
 *  Revision 1.1  1996/05/22  12:14:39  matthew
 *  new unit
 *  New test
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d8 1
a8 5
 *  $Log: maths.sml,v $
 *  Revision 1.1  1996/05/22  12:14:39  matthew
 *  new unit
 *  New test
 *
@
