head	1.5;
access;
symbols
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.5
	MLWorks_20c0_1998_08_04:1.5
	MLWorks_20b2c2_1998_06_19:1.5
	MLWorks_20b2_Windows_1998_06_12:1.5
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.3.5.1.1.1.1
	MLWorks_11c0_1997_09_09:1.3.5.1.1.1
	MLWorks_10r3:1.3.5.1.3
	MLWorks_10r2_551:1.3.5.1.2
	MLWorks_11:1.3.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.5.1
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.3.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.3.5
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.3.3.1.1
	MLWorks_gui_1996_12_18:1.3.4
	MLWorks_1_0_Win32_1996_12_17:1.3.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.1.1
	MLWorks_1_0_Irix_1996_11_28:1.3.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.2
	MLWorks_1_0_Unix_1996_11_14:1.3.1
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ *  @;


1.5
date	97.11.21.15.01.42;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	97.05.28.11.25.57;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.11.06.12.05.55;	author matthew;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1
	1.3.5.1;
next	1.2;

1.2
date	96.10.22.13.22.06;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.14.58.34;	author matthew;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	96.09.13.11.38.25;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.29.47;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.50.28;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.11.14.13.17.53;	author hope;	state Exp;
branches
	1.3.1.1.1.1;
next	;

1.3.1.1.1.1
date	96.11.28.15.28.23;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.11.22.18.35.41;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.12.17.18.14.40;	author hope;	state Exp;
branches
	1.3.3.1.1.1;
next	;

1.3.3.1.1.1
date	97.02.24.12.07.37;	author hope;	state Exp;
branches;
next	;

1.3.4.1
date	96.12.18.10.09.38;	author hope;	state Exp;
branches;
next	;

1.3.5.1
date	97.05.12.11.08.16;	author hope;	state Exp;
branches
	1.3.5.1.1.1
	1.3.5.1.2.1
	1.3.5.1.3.1;
next	;

1.3.5.1.1.1
date	97.07.28.18.50.14;	author daveb;	state Exp;
branches
	1.3.5.1.1.1.1.1;
next	;

1.3.5.1.1.1.1.1
date	97.10.07.12.15.18;	author jkbrook;	state Exp;
branches;
next	;

1.3.5.1.2.1
date	97.09.08.17.42.04;	author daveb;	state Exp;
branches;
next	;

1.3.5.1.3.1
date	97.09.09.14.41.29;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New test
@


1.5
log
@[Bug #30323]
@
text
@(*  ==== Testing ====
 *
 *  Result: OK
 *
 *  Revision Log
 *  ------------
 *  $Log: word16s-2.sml,v $
 *  Revision 1.4  1997/05/28  11:25:57  jont
 *  [Bug #30090]
 *  Remove uses of MLWorks.IO
 *
 *  Revision 1.3  1996/11/06  12:05:55  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
 *  Revision 1.2  1996/10/22  13:22:06  jont
 *  Remove references to toplevel
 *
 *  Revision 1.1  1996/05/22  14:58:34  matthew
 *  new unit
 *  New test
 *
*)

(* test/word.sml -- some test cases for Word, appropriate for a two's
   complement machine whose Integer.precision = SOME 31 
   PS 1995-03-19 *)


infix 1 seq
fun e1 seq e2 = e2;
fun check b = if b then "OK" else "WRONG";
fun check' f = (if f () then "OK" else "WRONG") handle _ => "EXN";

fun range (from, to) p = 
    let open Int
    in
	(from > to) orelse (p from) andalso (range (from+1, to) p)
    end;

fun checkrange bounds = check o range bounds;

local 
    (* Isn't this disgusting: *)
    type 'a foo4 = 'a * 'a * 'a * 'a
    type 'a foo5 = 'a * 'a * 'a * 'a * 'a
    val (gt,  lt,  ge,   le) = 
      (op>, op<, op>=, op<=) : (int * int -> bool) foo4
    val (add, sub, mul, idiv, imod) = 
      (op+, op-, op*, op div, op mod) : (int * int -> int) foo5
    open Word16;
    val op > = gt and op < = lt and op >= = ge and op <= = le;
    val op + = add and op - = sub and op * = mul 
    and op div = idiv and op mod = imod;
    val intToWord = fromInt
    val wordToInt = toInt
    val i2w = intToWord
    and w2i = wordToInt;
in

fun shift (x,y) = if y > 0 then << (x,Word.fromInt y) else >> (x,Word.fromInt (~y))
fun ashift (x,y) = if y > 0 then << (x,Word.fromInt y) else ~>> (x, Word.fromInt (~y))
val signExtend = toIntX
val test1 = checkrange (0, 1025)
    (fn i => i = w2i (i2w i));

val test3 = checkrange (~1000, 1000) 
    (fn i => i = signExtend (i2w i));

val test5a = checkrange (0,15) 
    (fn i => (i+960) div 2 * 2 + 1
             = w2i (orb (i2w i, i2w 961)));
val test5b = checkrange (0,513)
    (fn i => i = w2i (orb (i2w i, i2w i)));
val test6a = checkrange (0,15) 
    (fn i => i div 2 * 2 = w2i (andb (i2w i, i2w ~2)));
val test6b = checkrange (0,513)
    (fn i => i = w2i (andb (i2w i, i2w i)));
val test7a = checkrange (0,15) 
    (fn i => i+960 = w2i (xorb (i2w i, i2w 960)));
val test7b = checkrange (0, 513)
    (fn i => 0 = w2i (xorb (i2w i, i2w i)));

val test8a = check (~1 = toIntX (notb (i2w 0)));
val test8b = check (0 = toIntX (notb (i2w ~1)));

val maxposint = 32767;
val maxnegint = ~maxposint-1;
fun pwr2 0 = 1 
  | pwr2 n = 2 * pwr2 (n-1);
fun rwp i 0 = i
  | rwp i n = rwp i (n-1) div 2;
val test9a = checkrange (0,14)
    (fn k => pwr2 k = w2i (shift (i2w 1, k)));
(* Not a required property *)
(*
val test9b = checkrange (31,65)
    (fn k => w2i (shift (i2w 1, k)) 
             = w2i (shift (i2w 1, k mod wordSize)));
*)
val test9c = check (~maxposint - 1 = toIntX (shift (i2w 1, 15)));
val test9d = checkrange (0, 1025)
    (fn i => 2 * i = w2i (shift (i2w i, 1)));
val test9e = checkrange (0, 1025)
    (fn i => i div 2 = w2i (shift (i2w i, ~1)));
val test9f = checkrange (0,30)
    (fn k => rwp maxposint k = w2i (shift (i2w maxposint, ~k)));

val test10a = checkrange (0, 14)
    (fn k => pwr2 k = w2i (ashift (i2w 1, k)));
(* Not a required property *)
(*
val test10b = checkrange (8,50)
    (fn k => w2i (ashift (i2w 1, k)) 
             = w2i (ashift (i2w 1, k mod wordSize)));
*)
(*
val test10c = check (maxnegint = signExtend (ashift (i2w 1, 29)));
*)
val test10d = checkrange (0, 513)
    (fn i => 2 * i = w2i (ashift (i2w i, 1)));
val test10e = checkrange (~513, 513)
    (fn i => i div 2 = signExtend (ashift (i2w i, ~1)));
val test10f = checkrange (0,30)
    (fn k => rwp maxnegint k = signExtend (ashift (i2w maxnegint, ~k)));
local 
    open Word16
in
val test11a = check (i2w 256 > i2w 255);
val test11b = check (i2w 0 < i2w ~1);
val test11c = check (i2w maxposint >= i2w maxposint);
val test11d = check (i2w maxnegint >= i2w 127);
val test11e = check (i2w 1 <= i2w 1);
val test11f = check (i2w 0 <= i2w 1);
val test11g = check (i2w 0 < i2w maxposint);
val test11h = check (i2w maxposint < i2w maxnegint);
val test11i = check (i2w maxnegint < i2w ~1);
end;

local 
    open Word16
in
val test12a = checkrange(0, 300) (fn k => w2i (i2w k + i2w 17) = add(k, 17));
val test12b = checkrange(0, 300) (fn k => toIntX (i2w k - i2w 17) = sub(k, 17));
val test12c = checkrange(0, 300) (fn k => w2i (i2w k * i2w 17) = mul(k, 17));
val test12d = checkrange(0, 300) 
    (fn k => w2i (i2w k div i2w 17) = idiv(k, 17));
val test12e = checkrange(0, 300) 
    (fn k => w2i (i2w k mod i2w 17) = imod(k, 17));
val test12f = checkrange(0, 300) 
    (fn k => toIntX (i2w k + i2w maxnegint) = add(k, maxnegint));
val test12g = checkrange(0, 300) 
    (fn k => toIntX (i2w maxnegint - i2w k - i2w 1) = sub(maxposint,k));
val test12h = checkrange(0, 300) 
    (fn k => toIntX (i2w k * i2w maxnegint) = mul(imod(k, 2), maxnegint));
val test12i = checkrange(0, 300) 
    (fn k => toIntX (i2w k * i2w maxposint + i2w k) = mul(imod(k, 2), maxnegint));
val test12j = checkrange(0, 300) 
    (fn k => w2i (i2w k div i2w ~1) = 0);
val test12k = checkrange(0, 300) 
    (fn k => w2i (i2w k mod i2w ~1) = k);
val test12l = check(toIntX (i2w maxposint + i2w 1) = maxnegint);
val test12m = check(toIntX (i2w maxnegint - i2w 1) = maxposint);
val test12n = check(toIntX (i2w ~1 div i2w 2) = maxposint);
val test12o = check(toIntX (i2w ~1 mod i2w 2) = 1);
val test12p = check(toIntX (i2w ~1 div i2w 100) = idiv(maxposint, 50));
val test12q = check(toIntX (i2w ~1 mod i2w 10) = 5);

val test13a = (i2w 17 div i2w 0 seq "WRONG") 
              handle Div => "OK" | _ => "WRONG";
val test13b = (i2w 17 mod i2w 0 seq "WRONG") 
              handle Div => "OK" | _ => "WRONG";
end;
end;
@


1.4
log
@[Bug #30090]
Remove uses of MLWorks.IO
@
text
@d8 4
d29 1
a29 1
Shell.Build.loadSource "basis.__int";
a41 3

Shell.Build.loadSource "basis.__word16";
Shell.Build.loadSource "basis.__word";
@


1.3
log
@[Bug #1728]
__integer becomes __int
@
text
@d8 4
a25 3
val output = MLWorks.IO.output
val std_out = MLWorks.IO.std_out
val flush_out = MLWorks.IO.flush_out
a27 1
fun say s = (output(std_out, s); flush_out std_out);
@


1.3.5.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:05:55  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 *  Revision 1.3.5.1  1997/05/12  11:08:16  hope
 *  branched from 1.3
 *
@


1.3.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 *  Revision 1.3.5.1  1997/05/12  11:08:16  hope
 *  branched from 1.3
 *
@


1.3.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 *  Revision 1.3.5.1  1997/05/12  11:08:16  hope
 *  branched from 1.3
 *
@


1.3.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 *  Revision 1.3.5.1.1.1  1997/07/28  18:50:14  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.3.4.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:05:55  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.3.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:05:55  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.3.1.1.1
log
@branched from 1.3.3.1
@
text
@a7 3
 *  Revision 1.3.3.1  1996/12/17  18:14:40  hope
 *  branched from 1.3
 *
@


1.3.2.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:05:55  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:05:55  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.1.1.1.1
log
@branched from 1.3.1.1
@
text
@a7 3
 *  Revision 1.3.1.1  1996/11/14  13:17:53  hope
 *  branched from 1.3
 *
@


1.2
log
@Remove references to toplevel
@
text
@d8 3
d21 1
a21 1
Shell.Build.loadSource "basis.__integer";
@


1.1
log
@new unit
New test
@
text
@d7 5
a11 1
 *  $Log: basis:char.sml,v $
a17 1
Shell.Build.loadSource "basis.toplevel";
@


1.1.3.1
log
@branched from 1.1
@
text
@d7 1
a7 5
 *  $Log: word16s-2.sml,v $
 *  Revision 1.1  1996/05/22  14:58:34  matthew
 *  new unit
 *  New test
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d7 1
a7 5
 *  $Log: word16s-2.sml,v $
 *  Revision 1.1  1996/05/22  14:58:34  matthew
 *  new unit
 *  New test
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d7 1
a7 5
 *  $Log: word16s-2.sml,v $
 *  Revision 1.1  1996/05/22  14:58:34  matthew
 *  new unit
 *  New test
 *
@
