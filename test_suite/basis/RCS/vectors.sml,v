head	1.7;
access;
symbols
	MLWorks_21c0_1999_03_25:1.7
	MLWorks_20c1_1998_08_20:1.7
	MLWorks_20c0_1998_08_04:1.7
	MLWorks_20b2c2_1998_06_19:1.7
	MLWorks_20b2_Windows_1998_06_12:1.7
	MLWorks_20b1c1_1998_05_07:1.7
	MLWorks_20b0_1998_04_07:1.7
	MLWorks_20b0_1998_03_20:1.7
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_11r1:1.3.5.1.1.1.1
	MLWorks_11c0_1997_09_09:1.3.5.1.1.1
	MLWorks_10r3:1.3.5.1.3
	MLWorks_10r2_551:1.3.5.1.2
	MLWorks_11:1.3.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.5.1
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.3.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.3.5
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.3.3.1.1
	MLWorks_gui_1996_12_18:1.3.4
	MLWorks_1_0_Win32_1996_12_17:1.3.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.1.1
	MLWorks_1_0_Irix_1996_11_28:1.3.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.2
	MLWorks_1_0_Unix_1996_11_14:1.3.1
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ *  @;


1.7
date	98.02.18.11.56.02;	author mitchell;	state Exp;
branches;
next	1.6;

1.6
date	97.11.21.10.50.30;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.16.33.14;	author brucem;	state Exp;
branches;
next	1.4;

1.4
date	97.05.28.11.23.54;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.11.06.12.06.45;	author matthew;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1
	1.3.5.1;
next	1.2;

1.2
date	96.10.22.13.21.49;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.12.28.55;	author matthew;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	96.09.13.11.37.27;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.28.42;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.49.34;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.11.14.13.16.58;	author hope;	state Exp;
branches
	1.3.1.1.1.1;
next	;

1.3.1.1.1.1
date	96.11.28.15.27.24;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.11.22.18.34.45;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.12.17.18.13.42;	author hope;	state Exp;
branches
	1.3.3.1.1.1;
next	;

1.3.3.1.1.1
date	97.02.24.12.06.31;	author hope;	state Exp;
branches;
next	;

1.3.4.1
date	96.12.18.10.08.40;	author hope;	state Exp;
branches;
next	;

1.3.5.1
date	97.05.12.11.07.12;	author hope;	state Exp;
branches
	1.3.5.1.1.1
	1.3.5.1.2.1
	1.3.5.1.3.1;
next	;

1.3.5.1.1.1
date	97.07.28.18.50.03;	author daveb;	state Exp;
branches
	1.3.5.1.1.1.1.1;
next	;

1.3.5.1.1.1.1.1
date	97.10.07.12.15.13;	author jkbrook;	state Exp;
branches;
next	;

1.3.5.1.2.1
date	97.09.08.17.41.52;	author daveb;	state Exp;
branches;
next	;

1.3.5.1.3.1
date	97.09.09.14.41.17;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New test
@


1.7
log
@[Bug #30349]
Fix test to avoid non-unit sequence warning
@
text
@(*  ==== Testing ====
 *
 *  Result: OK
 *
 *  Revision Log
 *  ------------
 *  $Log: vectors.sml,v $
 *  Revision 1.6  1997/11/21  10:50:30  daveb
 *  [Bug #30323]
 *
 *  Revision 1.5  1997/08/08  16:33:14  brucem
 *  [Bug #30086]
 *  Test map and mapi.
 *
 *  Revision 1.4  1997/05/28  11:23:54  jont
 *  [Bug #30090]
 *  Remove uses of MLWorks.IO
 *
 *  Revision 1.3  1996/11/06  12:06:45  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
 *  Revision 1.2  1996/10/22  13:21:49  jont
 *  Remove references to toplevel
 *
 *  Revision 1.1  1996/05/22  12:28:55  matthew
 *  new unit
 *  New test
 *
*)

(* test/vector.sml -- some test cases for Vector 
   PS 1994-12-10, 1995-06-14 
   modified for MLWorks Fri May 17 11:17:17 1996
 *)

infix 1 seq
fun e1 seq e2 = e2;
fun check b = if b then "OK" else "WRONG";
fun check' f = (if f () then "OK" else "WRONG") handle _ => "EXN";

fun range (from, to) p = 
    let open Int
    in
	(from > to) orelse (p from) andalso (range (from+1, to) p)
    end;

fun checkrange bounds = check o range bounds;


local
    open Vector;
    infix 9 sub;
in

infix ==
fun a == b =
  Vector.length a = Vector.length b
  andalso
  let
    fun scan i =
      if i = Vector.length a
        then true
      else
        Vector.sub (a,i) = Vector.sub (b,i)
        andalso scan (i+1)
  in
    scan 0
  end

val a = fromList [0,1,2,3,4,5,6];
val b = fromList [44,55,66];
val c = fromList [0,1,2,3,4,5,6];

val test1 = check'(fn _ => a<>b);
val test2 = check'(fn _ => a=c);

val d = tabulate(100, fn i => i mod 7);

val test3 = check'(fn _ => d sub 27 = 6);

val test4a = (tabulate(maxLen+1, fn i => i) seq "WRONG")
             handle Size => "OK" | _ => "WRONG";

val test4b = (tabulate(~1, fn i => i)       seq "WRONG")
             handle Size => "OK" | _ => "WRONG";

val test4c = check'(fn _ => length (tabulate(0, fn i => i div 0)) = 0);

val test5 = check'(fn _ => length (fromList []) = 0 andalso length a = 7);

val test6a = (c sub ~1 seq "WRONG") handle Subscript => "OK" | _ => "WRONG";
val test6b = (c sub 7  seq "WRONG") handle Subscript => "OK" | _ => "WRONG";
val test6c = check'(fn _ => c sub 0 = 0);

val e = concat [d, b, d];

val test7 = check'(fn _ => length e = 203);


val test8 = check'(fn _ => length (concat []) = 0);

val f = extract (e, 100, SOME 3); 

val test9 = check'(fn _ => f = b);

val test9a = check'(fn _ => e = extract(e, 0, SOME (length e)) 
		    andalso e = extract(e, 0, NONE));
val test9b = check'(fn _ => fromList [] == extract(e, 100, SOME 0));
val test9c = (extract(e, ~1, SOME (length e))  seq "WRONG") 
             handle Subscript => "OK" | _ => "WRONG"
val test9d = (extract(e, length e + 1, SOME 0)  seq "WRONG") 
             handle Subscript => "OK" | _ => "WRONG"
val test9e = (extract(e, 0, SOME (length e+1)) seq "WRONG") 
             handle Subscript => "OK" | _ => "WRONG"
val test9f = (extract(e, 20, SOME ~1)        seq "WRONG") 
             handle Subscript => "OK" | _ => "WRONG"
val test9g = (extract(e, ~1, NONE)  seq "WRONG") 
             handle Subscript => "OK" | _ => "WRONG"
val test9h = (extract(e, length e + 1, NONE)  seq "WRONG") 
             handle Subscript => "OK" | _ => "WRONG"
val test9i = check'(fn _ => fromList [] == extract(e, length e, SOME 0)
		    andalso fromList [] == extract(e, length e, NONE));

  (* Test map and mapi *)
  val v = (fromList [0, 1, 2, 3, 4, 5, 6, 7]) ;

  val add1 = (fn i => i+1) ;

  val addi = (fn (i, j) => i+j) ;

  val testAa = check'
         (fn _ => (map add1 v) == fromList [1, 2, 3, 4, 5, 6, 7, 8]) ;
  val testAb = check'
         (fn _ => (map add1 (fromList [])) == (fromList [])) ;
  val testAc = check'
         (fn _ => (mapi addi (v, 0, NONE)) == fromList [0,2,4,6,8,10,12,14]);
  val testAd = check'
         (fn _ => (mapi addi (v, 1, NONE)) == fromList [2,4,6,8,10,12,14]);
  val testAe = check'
         (fn _ => (mapi addi (v, 7, NONE)) == fromList [14]);
  val testAf = 
         (ignore(mapi addi (v, ~1, NONE)); "WRONG") handle Subscript => "OKEXN"
                                                  | _ => "WRONG EXN" ;
  val testAga = check'
         (fn _ => (mapi addi (v, 8, NONE)) == fromList [])
  val testAgb =
         (ignore(mapi addi (v, 9, NONE)); "WRONG") handle Subscript => "OKEXN"
                                                  | _ => "WRONG EXN" ;
  val testAh =
         check' (fn _ => mapi addi (v, 0, SOME 2) == fromList [0, 2]) ;
  val testAi =
         check' (fn _ => mapi addi (v, 6, SOME 2) == fromList [12,14]) ;
  val testAj =
         (ignore(mapi addi (v,7,SOME 2)); "WRONG") handle Subscript => "OKEXN"
                                                 | _ => "WRONG EXN" ;
  val testAk = check'
         (fn _ => mapi addi (v, 2, SOME 0) == fromList [])
  val testAl =
         (ignore(mapi addi (v, 2, SOME ~1)); "WRONG") handle Subscript => "OKEXN"
                                                 | _ => "WRONG EXN" ;
  (* Test appi *)
  local
    val c = ref 0
  in
    val testBa = check'
           (fn _ => ((appi (fn _ => c := !c+1) (v, 0, SOME 2)); !c)=2)
  end ;


end; (* of tests *)
@


1.6
log
@[Bug #30323]
@
text
@d8 3
d143 1
a143 1
         (mapi addi (v, ~1, NONE) ; "WRONG") handle Subscript => "OKEXN"
d148 1
a148 1
         (mapi addi (v, 9, NONE) ; "WRONG") handle Subscript => "OKEXN"
d155 1
a155 1
         (mapi addi (v,7,SOME 2) ; "WRONG") handle Subscript => "OKEXN"
d160 1
a160 1
         (mapi addi (v, 2, SOME ~1) ; "WRONG") handle Subscript => "OKEXN"
@


1.5
log
@[Bug #30086]
Test map and mapi.
@
text
@d8 4
a32 8

local
  val _ = Shell.Options.set(Shell.Options.ValuePrinter.maximumStrDepth, 0);
in
  val _ = (
    Shell.Build.loadSource "basis.__int";
    Shell.Build.loadSource "basis.__vector" )
end
@


1.4
log
@[Bug #30090]
Remove uses of MLWorks.IO
@
text
@d8 4
d30 8
a37 1
Shell.Build.loadSource "basis.__int";
a50 2
Shell.Build.loadSource "basis.__vector";

d126 47
a172 1
end;
@


1.3
log
@[Bug #1728]
__integer becomes __int
@
text
@d8 4
a26 3
val output = MLWorks.IO.output
val std_out = MLWorks.IO.std_out
val flush_out = MLWorks.IO.flush_out
a28 1
fun say s = (output(std_out, s); flush_out std_out);
@


1.3.5.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:06:45  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 *  Revision 1.3.5.1  1997/05/12  11:07:12  hope
 *  branched from 1.3
 *
@


1.3.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 *  Revision 1.3.5.1  1997/05/12  11:07:12  hope
 *  branched from 1.3
 *
@


1.3.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 *  Revision 1.3.5.1  1997/05/12  11:07:12  hope
 *  branched from 1.3
 *
@


1.3.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 *  Revision 1.3.5.1.1.1  1997/07/28  18:50:03  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.3.4.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:06:45  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.3.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:06:45  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.3.1.1.1
log
@branched from 1.3.3.1
@
text
@a7 3
 *  Revision 1.3.3.1  1996/12/17  18:13:42  hope
 *  branched from 1.3
 *
@


1.3.2.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:06:45  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a7 4
 *  Revision 1.3  1996/11/06  12:06:45  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.3.1.1.1.1
log
@branched from 1.3.1.1
@
text
@a7 3
 *  Revision 1.3.1.1  1996/11/14  13:16:58  hope
 *  branched from 1.3
 *
@


1.2
log
@Remove references to toplevel
@
text
@d8 3
d22 1
a22 1
Shell.Build.loadSource "basis.__integer";
@


1.1
log
@new unit
New test
@
text
@d7 5
a11 1
 *  $Log: basis:char.sml,v $
d18 1
a18 1
Shell.Build.loadSource "basis.toplevel";
@


1.1.3.1
log
@branched from 1.1
@
text
@d7 1
a7 5
 *  $Log: vectors.sml,v $
 *  Revision 1.1  1996/05/22  12:28:55  matthew
 *  new unit
 *  New test
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d7 1
a7 5
 *  $Log: vectors.sml,v $
 *  Revision 1.1  1996/05/22  12:28:55  matthew
 *  new unit
 *  New test
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d7 1
a7 5
 *  $Log: vectors.sml,v $
 *  Revision 1.1  1996/05/22  12:28:55  matthew
 *  new unit
 *  New test
 *
@
