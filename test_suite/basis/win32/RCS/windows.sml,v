head	1.10;
access;
symbols
	MLWorks_21c0_1999_03_25:1.10
	MLWorks_20c1_1998_08_20:1.3
	MLWorks_20c0_1998_08_04:1.2;
locks; strict;


1.10
date	99.03.19.10.52.22;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	99.03.17.15.57.58;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	98.10.27.15.56.09;	author io;	state Exp;
branches;
next	1.7;

1.7
date	98.10.13.16.55.24;	author io;	state Exp;
branches;
next	1.6;

1.6
date	98.10.12.16.39.45;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	98.10.01.16.58.12;	author io;	state Exp;
branches;
next	1.4;

1.4
date	98.08.25.16.41.11;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	98.08.11.16.58.22;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	98.07.24.17.33.48;	author io;	state Exp;
branches;
next	1.1;

1.1
date	98.07.24.17.24.31;	author io;	state Exp;
branches;
next	;


desc
@new unit
[Bug #70086]
simple tests for proposed basis Windows structure
@


1.10
log
@Automatic checkin:
changed attribute _comment to ''
@
text
@(*
 * Result: OK
 *
 * $Log: win32:windows.sml,v $
 *  Revision 1.8  1998/10/27  15:56:09  io
 *  change Result status and bits and bobs
 *
 *  Revision 1.7  1998/10/13  16:55:24  io
 *  use findExecutable to find sh rather than using d:/bin/sh
 *
 *  Revision 1.6  1998/10/12  16:39:45  jont
 *  [Bug #30490]
 *  Add test for Windows.streamsOf
 *
 *  Revision 1.5  1998/10/01  16:58:12  io
 *  ** No reason given. **
 *  simplify test structure, beef up existing tests, new tests for Reg and DDE
 *
 *  Revision 1.4  1998/08/25  16:41:11  jont
 *  [Bug #50095]
 *  Fix SysErr and get some other test sorted so they pass
 *
 *  Revision 1.3  1998/08/11  16:58:22  jont
 *  [Bug #50094]
 *  Modify to work now Windows is not included in guib.img by default
 *
 *  Revision 1.2  1998/07/24  17:33:48  io
 *  Automatic checkin:
 *  changed attribute _comment to ' *  '
 *
 * 
 *  Copyright (C) 1998. Harlequin Group plc
 *  All rights reserved.
 *)

val _ = Shell.Options.set(Shell.Options.ValuePrinter.maximumStrDepth, 0);

let
fun check' s f = 
  (print s;
   print ":";
   ((if (f ()) then print "OK" else print "WRONG") 
       handle exn => (print "\n"; 
                      print (General.exnMessage exn);
                      print "\n";
                      print "BADEXN"
                      ));
   print "\n")

fun checkexn' s exn f = 
  let 
    val res = (ignore (f ()); "FAIL") handle exn2 => 
      if General.exnName exn = General.exnName exn2 then
        "OKEXN"
      else
        "BADEXN:" ^ (General.exnMessage exn2)
  in
    print s;
    print ":";
    print res;
    print "\n"
  end

fun all2 f g xs = 
  let
    datatype 'a Res =
      RES of 'a
    | EXN of exn
    fun myApply g x = (RES (g x)) handle exn => (EXN exn)

    fun scan (acc, count, []) = rev acc
      | scan (acc, count, (RES x) :: xs) = scan (acc, count+1, xs)
      | scan (acc, count, (EXN exn) :: xs) = scan ((count, General.exnMessage exn) :: acc, count+1, xs)

    val res = map (myApply g) xs
    val exnres = scan ([], 0, res)
      
  in
    if (List.all f (map g xs)) handle exn => false then
      true
    else
      (print "\n";
       print (foldl (fn ((y,z),x) => x ^ (Int.toString y) ^ z ^ "\n") "" exnres);
       print "\n";
       false)
  end

  
val test1 = check' "check Windows.findExecutable: notepad and notepad.exe return same results"
  (fn _=>let
           val res0 = Windows.findExecutable "notepad"
           val res1 = Windows.findExecutable "notepad.exe"
         in
           case (res0, res1) of
             (SOME res0, SOME res1) => 
               res0 = res1 andalso
               size (OS.Path.dir res0) > 0 andalso
               (OS.Path.file res0) = "notepad.exe"
           | _ => false
         end)

val test2 = check' "check Windows.findExecutable: mixed case filenames shouldnt cause any exceptions"
  (fn _=>
   all2 (fn x=> isSome x andalso 
         case (String.map Char.toUpper) (valOf x) of 
           res0 => (OS.Path.base o OS.Path.file) res0 = "NOTEPAD")
   (Windows.findExecutable)
   ["NOTEPAD", "NOTEPAD.exe", "NOTEPAD.EXE", "notepad.EXE"]
   )


val test3 = check' "check Windows.findExecutable: failures results should be NONE"
  (fn _=>
   all2 (not o isSome) (Windows.findExecutable) ["notepad2", "notepad2.exe", "c:\\WINNT\\apple"])


val test4 = check' "check Windows.findExecutable: with directories result should be \"Explorer.exe\""
  (fn _=>
   all2 (fn x=> isSome x andalso (valOf x) = "C:\\WINNT\\Explorer.exe")
   (Windows.findExecutable)
   ["c:",
    "C:",
    "d:",
    "c:\\tmp",
    "",
    "c:\\WINNT\\system32",
    "c:/WINNT/system32",
    "d:/users/io/work/build", (* this fails *)
    "d:\\users\\io\\work\\build",
    "d:/users/io/work/",
    "d:/users/io/work",
    "d:\\users\\io\\work\\",
    "d:\\users\\io\\work"
    ]
   )
   

val test5 = check' "check Windows.findExecutable: on stuff in the NT directory"
  (fn _=> 
   all2 (isSome) (Windows.findExecutable) ["c:\\WINNT\\WinHlp32.BMK", (* seems to raise SysErr *)
                                                 "c:\\WINNT\\Win.INI",
                                                 "c:\\WINNT\\clock.avi",
                                                 "c:/WINNT/clock.avi",
                                                 "c:\\WINNT\\system32\\557SET.GID",
                                                 "c:\\WINNT\\system32\\PLUGIN.OCX" (* seems to raise SysErr *)
                                                 ])

val test6 = checkexn' "check Windows.findExecutable: with mixed directory separators is bad"
  (OS.SysErr ("file 'clock.avi' not found\013\n", NONE))
   (fn _=> 
    (not o isSome o  Windows.findExecutable) "c:\\WINNT/clock.avi")

val test7 = check' "check Windows.launchApplication runs hope help"
  (fn _=>
   let val exec = Windows.findExecutable "sh.exe"
   in
     case exec of 
       NONE => false
     | SOME exec => (Windows.launchApplication (exec, ["/x/c", "hope.bat", "help"]); true)
   end);


val test8 = check' "check Windows.lauchApplication runs sh for ten seconds"
  (fn _=>
   let val exec = Windows.findExecutable "sh.exe"
   in
     case exec of 
       NONE => false
     | SOME exec => (Windows.launchApplication (exec, ["-c", "\"help set; echo $0; echo $1; sleep 10\""]); 
                     true)
   end);
  
val test9 = check' "check Windows.launchApplications runs sh on cout"
  (fn _=>
   let val exec = Windows.findExecutable "sh.exe"
   in
     case exec of 
       NONE => false
     | SOME exec => (Windows.launchApplication (exec, ["d:/users/io/work/build/MLW/tools/cout"]);
                     true)
   end);


val test10 = check' "check Windows.launchApplication runs sh to use cout cout and should take a while"
  (fn _=>
   let val exec = Windows.findExecutable "sh.exe"
   in
     case exec of
       NONE => false
     | SOME exec => (Windows.launchApplication (exec, ["d:/users/io/work/build/MLW/tools/cout", "d:/users/io/work/build/MLW/tools/cout"]);
                     true)
   end);

val test11 = check' "check Windows.launchApplication is given a non executable"
  (fn _=>
   (Windows.launchApplication ("hope.bat",["help"]); true))

val test12 = checkexn' "check Windows.launchApplication is given a bogus file which should raise an exception"
  (OS.SysErr ("file 'hope2.bat' not found\013\n", NONE))
  (fn _=>
   (Windows.launchApplication ("hope2.bat", []); false))

val test13 = checkexn' "check Windows.launchApplication handling of bogus files"
  (OS.SysErr ("file 'a' not found\013\n", NONE))
  (fn _=>
   (Windows.launchApplication ("a", []); false))

val test14 = check' "check Windows.execute: uses its stdin and stdout"
  (fn _=>
   let
     val exec = Windows.findExecutable "cmd.exe"
   in
     case exec of
       NONE =>  false
     | SOME exec =>
	 let
	   val proc = Windows.execute (exec, [])
	   val procin = Windows.textInstreamOf proc
	   val procout = Windows.textOutstreamOf proc
	   val _ = TextIO.output(procout, "dir c:\\");
	   val _ = TextIO.flushOut procout;
	   val _ = TextIO.output(TextIO.stdOut, TextIO.inputLine procin);
	   val _ = TextIO.output(TextIO.stdOut, "Finishing output\n");
	 in
	   true
	 end
   end)


val test15 = checkexn' "check Windows.execute cannot find files"
  (OS.SysErr ("The system cannot find the file specified\013\n", NONE))
  (fn _=> Windows.execute ("bogus", []))

val test16 = checkexn' "check Windows.execute cannot find files"
  (OS.SysErr ("The system cannot find the file specified\013\n", NONE))
  (fn _=> Windows.execute ("", []))
  
val test17 = checkexn' "check Windows.execute raises access denied"
  (OS.SysErr ("Access is denied\013\n", NONE))
  (fn _=> Windows.execute ("c:", []))
   

  (* File System *)
  
val test18 = check' "check Windows.localFileTimeToFileTime"
  (fn _=>
   let
     val exec = Windows.findExecutable "sh.exe"
   in
     case exec of
       NONE => false
     | SOME exec => case OS.FileSys.modTime exec of
         sh_time => (Windows.fileTimeToLocalFileTime o Windows.localFileTimeToFileTime) sh_time = sh_time
   end);

val test19 = checkexn' "check Windows.getVolumeInformation would SysErr on unmounted floppy" 
  (OS.SysErr ("The device is not ready.\013\n", NONE)) 
  (fn _=>(ignore (Windows.getVolumeInformation "a:"); false))
  
val test20 = checkexn' "check Windows.getVolumeInformation would complain about an invalid volume"
  (OS.SysErr ("The system cannot find the path specified.\013\n", NONE))
  (fn _=>
   (ignore (Windows.getVolumeInformation "_:");
    false))
  
val test21 = checkexn' "check Windows.getVolumeInformation would complain about poor volume syntax"
  (OS.SysErr ("The filename, directory name, or volume label syntax is incorrect.\013\n", NONE))
  (fn _=>
   (ignore (Windows.getVolumeInformation "as:");
    false))

val test22 = check' "check Windows.getVolumeInformation: should pass"
  (fn _=>
   all2 (fn 
         {volumeName = volumeName,
          systemName = systemName,
          serialNumber = serialNumber,
          maximumComponentLength = maximumComponentLength}
         => (List.exists (fn x=>x=systemName) ["Samba", "FAT", "CDROM", "NTFS"]))

   (Windows.getVolumeInformation)
   ["c:", "d:", "e:", "y:", "z:"] (* d: seems to fail for me *)
   )

val test23 = check' "check Windows.Registry entries for MLWorks in HKEY_CURRENT_USER"
  (fn _=>
   let
     fun scan s = 
       let
         val software_hkey = (valOf o Windows.Reg.openKeyEx) (Windows.Reg.currentUser, "Software", Windows.Key.read)
         val harlequin_hkey = (valOf o Windows.Reg.openKeyEx) (software_hkey, "Harlequin", Windows.Key.read)
         val mlworks_hkey = (valOf o Windows.Reg.openKeyEx) (harlequin_hkey, "MLWorks", Windows.Key.read)
         val res = Windows.Reg.queryValueEx (mlworks_hkey, s)
       in
         ignore (app Windows.Reg.closeKey [mlworks_hkey, harlequin_hkey, software_hkey]);
         res
       end
     handle Option => "scan: Option raised"
   in
     all2 (fn x=> x <> "" andalso x <> "scan: Option raised" 
           (* andalso List.exists (fn y=>x=y) [Shell.Path.pervasive (), (hd o Shell.Path.sourcePath) ()] *)
           )
     scan
     [(* "Object Path",  returns null *)
      "Pervasive Path",
      "Source Path",
      "Startup Directory"]
     
   end)
   
val test24 = check' "check Windows.Registry entries for MLWorks in HKEY_CURRENT_USER using different case"
  (fn _=>
   let
     fun scan s = 
       let
         val software_hkey = (valOf o Windows.Reg.openKeyEx) (Windows.Reg.currentUser, "SOFTWARE", Windows.Key.read)
         val harlequin_hkey = (valOf o Windows.Reg.openKeyEx) (software_hkey, "HARLEQUIN", Windows.Key.read)
         val mlworks_hkey = (valOf o Windows.Reg.openKeyEx) (harlequin_hkey, "MLWORKS", Windows.Key.read)
         val res = Windows.Reg.queryValueEx (mlworks_hkey, s)
       in
         ignore (app Windows.Reg.closeKey [mlworks_hkey, harlequin_hkey, software_hkey]);
         res
       end
     handle Option => "scan: Option raised"
   in
     all2 (fn x=> x <> "" andalso x <> "scan: Option raised" 
           (* andalso List.exists (fn y=>x=y) [Shell.Path.pervasive (), (hd o Shell.Path.sourcePath) ()] *)
           )
     scan
     [(* "Object Path",  returns null *)
      "Pervasive Path",
      "Source Path",
      "Startup Directory"]
     
   end)

val test25 = check' "check Windows.Registry entries for MLWorks in HKEY_LOCAL using bogus arguments"
  (fn _=>
   let
     fun scan s = 
       let
         val software_hkey = (valOf o Windows.Reg.openKeyEx) (Windows.Reg.localMachine, "SOFTWARE", Windows.Key.read)
         val harlequin_hkey = (valOf o Windows.Reg.openKeyEx) (software_hkey, "HARLEQUIN", Windows.Key.read)
         val mlworks_hkey = (valOf o Windows.Reg.openKeyEx) (harlequin_hkey, "MLWORKS", Windows.Key.read)
         val res = Windows.Reg.queryValueEx (mlworks_hkey, s)
       in
         ignore (app Windows.Reg.closeKey [mlworks_hkey, harlequin_hkey, software_hkey]);
         res
       end
     handle Option => "scan: Option raised"
   in
     all2 (fn x=> x = "" andalso x <> "scan: Option raised")
     scan
     [(* "Object Path",  returns null *)
      "Pervasive Path",
      "Source Path",
      "Startup Directory"]
     
   end)

val test26 = check' "check Windows.Registry entries for MLWorks in HKEY_LOCAL_MACHINE"
  (fn _=>
   let
     val software_hkey = (valOf o Windows.Reg.openKeyEx) (Windows.Reg.localMachine, "Software", Windows.Key.read)
     val harlequin_hkey = (valOf o Windows.Reg.openKeyEx) (software_hkey, "Harlequin", Windows.Key.read)
     val mlworks_hkey = (valOf o Windows.Reg.openKeyEx) (harlequin_hkey, "MLWorks", Windows.Key.read)
   in
     true
   end)
  

val test27 = check' "check creation and deletion of registry entries"
  (fn _=>
   let
     val software_hkey = (valOf o Windows.Reg.openKeyEx) (Windows.Reg.currentUser, "Software", Windows.Key.read)
     val harlequin_hkey = (valOf o Windows.Reg.openKeyEx) (software_hkey, "Harlequin", Windows.Key.read)
     val mlworks_hkey = (valOf o Windows.Reg.openKeyEx) (harlequin_hkey, "MLWorks", Windows.Key.read)

     val test_suite_v_hkey = case (valOf o Windows.Reg.createKeyEx) (mlworks_hkey, "TestSuiteV", Windows.Reg.VOLATILE, Windows.Key.allAccess) of
       Windows.Reg.CREATED_NEW_KEY test_suite_hkey => test_suite_hkey
     | Windows.Reg.OPENED_EXISTING_KEY test_suite_hkey => test_suite_hkey

     val test_suite_v_hkey2 = case (valOf o Windows.Reg.createKeyEx) (mlworks_hkey, "TestSuiteV2", Windows.Reg.VOLATILE, Windows.Key.allAccess) of
       Windows.Reg.CREATED_NEW_KEY test_suite_hkey => test_suite_hkey
     | Windows.Reg.OPENED_EXISTING_KEY test_suite_hkey => test_suite_hkey
         
     val test_suite_nv_hkey = case (valOf o Windows.Reg.createKeyEx) (mlworks_hkey, "TestSuiteNV", Windows.Reg.NON_VOLATILE, Windows.Key.allAccess) of
       Windows.Reg.CREATED_NEW_KEY test_suite_hkey => test_suite_hkey
     | Windows.Reg.OPENED_EXISTING_KEY test_suite_hkey => test_suite_hkey

     val test_suite_nv_hkey2 = case (valOf o Windows.Reg.createKeyEx) (mlworks_hkey, "TestSuiteNV2", Windows.Reg.NON_VOLATILE, Windows.Key.allAccess) of
       Windows.Reg.CREATED_NEW_KEY test_suite_hkey => test_suite_hkey
     | Windows.Reg.OPENED_EXISTING_KEY test_suite_hkey => test_suite_hkey


     val subkeyList = [(test_suite_nv_hkey2, "TestSuiteNV2"),
                       (test_suite_nv_hkey, "TestSuiteNV"),
                       (test_suite_v_hkey2, "TestSuiteV2"),
                       (test_suite_v_hkey, "TestSuiteV")]

     val keyValueList = [("test key", "test value"), 
                         ("test2 key", "test2 value"), 
                         ("test3 key", "test3 value")]


     fun mungeKeyValueList s xs = map (fn (x,y)=> (s^x,y)) xs
       
       
     val test27a = check' "check setting key value pairs volatile registry"
       (fn _=>
        all2
        (fn x=> x=true)
        (fn x=>(Windows.Reg.setValueEx (test_suite_v_hkey, #1(x), #2(x));
                true))
        (mungeKeyValueList "v" keyValueList))

     val test27b = check' "check setting key value pairs volatile registry2"
       (fn _=>
        all2
        (fn x=> x=true)
        (fn x=>(Windows.Reg.setValueEx (test_suite_v_hkey2, #1(x), #2(x));
                true))
        (mungeKeyValueList "v2" keyValueList))
        
     val test27c = check' "check setting key value pairs non volatile registry"
       (fn _=>
        all2
        (fn x=> x=true)
        (fn x=>(Windows.Reg.setValueEx (test_suite_nv_hkey, #1(x), #2(x));
                true))
        (mungeKeyValueList "nv" keyValueList))
       
     val test27d = check' "check setting key value pairs non volatile registry2"
       (fn _=>
        all2
        (fn x=> x=true)
        (fn x=>(Windows.Reg.setValueEx (test_suite_nv_hkey2, #1(x), #2(x));
                true))
        (mungeKeyValueList "nv2" keyValueList))
       

     val test27e = check' "check deleting keys succeeds"
       (fn _=>
        all2 
        (fn x=>x = true)
        (fn x=>(Windows.Reg.deleteKey x; true))
        subkeyList)

         
     val test27f = check' "check closing keys succeeds"
       (fn _=>
        all2 
        (fn x=>x=true)
        (fn x=>(Windows.Reg.closeKey x; true))
        (map (#1) subkeyList))

     val test27g = check' "check closing keys again fail"
       (fn _=>
        all2
        (fn x=> x = "PASS12")
        (fn x=>((Windows.Reg.closeKey x; "FAIL")
                handle OS.SysErr ("The handle is invalid.\013\n", SOME arg) => ("PASS" ^ Int.toString arg)
                     | exn => "FAIL"))
        (map (#1) subkeyList))

     (* should test_suite_hkey = test_suite_hkey2? *)
   in
     true
   end)
       
       
 (* DDE *)


(* assume netscape is running at same time
 * some code to start Netscape when exception gets raised would need to be written
 *)

val test28 = check' "checks Windows.DDE tells Netscape to open a URL and move it to the foreground"
  (fn _=> 
   let 
     val info = Windows.DDE.startDialog ("NSShell", "WWW_OpenURL")
   in
     (* \"http://src.doc.ic.ac.uk\" kills netscape permanently you need to relogin *)
      ignore (Windows.DDE.executeString (info, "http://home.netscape.com", 3,3));
      ignore (Windows.DDE.stopDialog info);
      false
   end)
   


val test29 = check' "check DDE interaction with Netscape like crash it"
  (fn _ =>
   let
     val info = Windows.DDE.startDialog ("NSShell", "WWW_Version")
   in
     ignore (Windows.DDE.executeString (info, "", 3, 10));
     ignore (Windows.DDE.stopDialog info);
     false
   end)

(* ensure Netscape is running at the same time and c:/hqbin/nt/x86/ls.txt is loaded *)
val test30 = check' "check DDE interaction with Netscape like crash it"
  (fn _ =>
   let
     val info = Windows.DDE.startDialog ("NSShell", "WWW_QueryURLFile")
   in
     ignore (Windows.DDE.executeString (info, "file:///C|/hqbin/nt/x86/ls.txt",3,10));
     ignore (Windows.DDE.stopDialog info);
     false
   end)

val test31 = checkexn' "check DDE exception on unknown service"
  (OS.SysErr ("start_dde_dialog : DdeConnect - no conversation established\013\n", NONE))
  (fn _ =>
   let
     val info = Windows.DDE.startDialog ("NSShell_NON_APPLICATION", "WWW_QueryURLFile")
   in
     ignore (Windows.DDE.executeString (info, "file:///C|/hqbin/nt/x86/ls.txt",3,10));
     ignore (Windows.DDE.stopDialog info);
     true
   end)


  val _ = print "Windows.Registry: needs better coverage\n"
  val _ = print "Windows.hasOwnConsole: unimplemented"

in
  ()
end

  
@


1.9
log
@[Bug #190523]
Changes to Windows structure.
@
text
@@


1.8
log
@change Result status and bits and bobs
@
text
@d5 3
a36 4
val _ = Shell.Project.openProject "../src/basis.mlp";
val _ = Shell.Project.setConfiguration "I386/NT";
val _ = Shell.Project.load "windows";
val _ = Shell.Project.load "__windows";
a97 1
               (OS.Path.getVolume res0) = "C:" andalso
d153 1
a153 1
val test7 = check' "check Windows.shellExecute runs hope help"
d155 6
a160 7
   (Windows.shellExecute ("c:\\WINNT\\system32\\cmd", ["/x/c", "hope.bat", "help"]); true))

(* the following seems to fail but fails in an uncatchable way that the window pops up and immediately disappears 
 * val test7 = check' "check Windows.shellExecute runs"
 * (fn _=>
 * (Windows.shellExecute ("c:/WINNT/system32/cmd", ["/x/c", "hope.bat", "help"]); true))
 *)
d163 1
a163 1
val test8 = check' "check Windows.shellExecute runs sh for ten seconds"
d169 1
a169 1
     | SOME exec => (Windows.shellExecute (exec, ["-c", "\"help set; echo $0; echo $1; sleep 10\""]); 
d173 1
a173 1
val test9 = check' "check Windows.shellExecute runs sh on cout"
d179 1
a179 1
     | SOME exec => (Windows.shellExecute (exec, ["d:/users/io/work/build/MLW/tools/cout"]);
d184 1
a184 1
val test10 = check' "check Windows.shellExecute runs sh to use cout cout and should take a while"
d190 1
a190 1
     | SOME exec => (Windows.shellExecute (exec, ["d:/users/io/work/build/MLW/tools/cout", "d:/users/io/work/build/MLW/tools/cout"]);
d194 1
a194 1
val test11 = check' "check Windows.shellExecute is given a non executable"
d196 1
a196 1
   (Windows.shellExecute ("hope.bat",["help"]); true))
d198 1
a198 1
val test12 = checkexn' "check Windows.shellExecute is given a bogus file which should raise an exception"
d201 1
a201 1
   (Windows.shellExecute ("hope2.bat", []); false))
d203 1
a203 1
val test13 = checkexn' "check Windows.shellExecute handling of bogus files"
d206 1
a206 1
   (Windows.shellExecute ("a", []); false))
d218 2
a219 1
	   val (procin,procout) = Windows.streamsOf proc
d278 1
a278 2
          maximumComponentLength = maximumComponentLength,
          flags = flags}
d364 3
a366 11
     fun scan s = 
       let
         val software_hkey = (valOf o Windows.Reg.openKeyEx) (Windows.Reg.localMachine, "Software", Windows.Key.read)
         val harlequin_hkey = (valOf o Windows.Reg.openKeyEx) (software_hkey, "Harlequin", Windows.Key.read)
         val mlworks_hkey = (valOf o Windows.Reg.openKeyEx) (harlequin_hkey, "MLWorks", Windows.Key.read)
         val res = Windows.Reg.queryValueEx (mlworks_hkey, s)
       in
         ignore (app Windows.Reg.closeKey [mlworks_hkey, harlequin_hkey, software_hkey]);
         res
       end
     handle Option => "scan: Option raised"
d368 1
a368 4
     all2 (fn x=> x <> "" andalso x <> "scan: Option raised"
           )
     scan
     ["License", "User", "license", "user"]
a525 2
  val _ = print "Windows.DDE.requestString: unimplemented\n"
  val _ = print "Windows.newConsole: unimplemented\n"
d532 1
a532 1
  @


1.7
log
@use findExecutable to find sh rather than using d:/bin/sh
@
text
@d2 1
a2 1
 * Result: INTERPRETATION
d5 3
d130 1
a130 1
    "d:/users/io/work/build",
d172 1
a172 1
     | SOME exec => (Windows.shellExecute ("d:/bin/sh", ["-c", "\"help set; echo $0; echo $1; sleep 10\""]); 
d193 1
a193 1
     | SOME exec => (Windows.shellExecute ("d:/bin/sh", ["d:/users/io/work/build/MLW/tools/cout", "d:/users/io/work/build/MLW/tools/cout"]);
d242 1
a242 1
  (fn _=> Windows.execute ("", []))
@


1.6
log
@[Bug #30490]
Add test for Windows.streamsOf
@
text
@d5 4
d148 1
a148 1
  (OS.SysErr ("file 'hope2.bat' not found\013\n", NONE))
d165 7
a171 1
   (Windows.shellExecute ("d:/bin/sh", ["-c", "\"help set; echo $0; echo $1; sleep 10\""]); true));
d175 7
a181 1
   (Windows.shellExecute ("d:/bin/sh", ["d:/users/io/work/build/MLW/tools/cout"]); true))
d186 7
a192 1
   (Windows.shellExecute ("d:/bin/sh", ["d:/users/io/work/build/MLW/tools/cout", "d:/users/io/work/build/MLW/tools/cout"]); true))
d208 1
a208 1
val test14 = check' "check Windows.execute: UNRESOLVED"
d211 1
a211 1
     val exec = Windows.findExecutable"sh.exe"
d219 1
a219 1
	   val _ = TextIO.output(procout, "ls /");
d228 1
d244 1
a244 1
val test18 = check' "check Windows.localFiletimeToFileTime"
d247 1
a247 1
     val sh_time = OS.FileSys.modTime "d:/bin/sh.exe"
d249 5
a253 2
     ((Windows.fileTimeToLocalFileTime o Windows.localFileTimeToFileTime) sh_time) = sh_time
   end)
d536 1
a536 1
  val _ = print "Windows.Registry: needs better coverage"
@


1.5
log
@** No reason given. **
simplify test structure, beef up existing tests, new tests for Reg and DDE
@
text
@d5 4
d189 1
a189 2
     val proc = Windows.execute ("d:/bin/sh.exe", [])
     val (procin,procout) = Windows.streamsOf proc
d191 13
a203 1
     false
@


1.4
log
@[Bug #50095]
Fix SysErr and get some other test sorted so they pass
@
text
@d5 4
d28 25
a52 86
local
  structure Test =
    struct

      fun zip2 (x::xs) (y::ys) = (x,y) :: (zip2 xs ys)
	|  zip2 []      [] = []
	|  zip2 _       _ = raise Fail "zip2"

      fun show msg arg ans res =
	let 
	  val arg = concat ["\"", arg, "\""]
	  val (ans,res) = case (ans,res) of
	    ("", "") => ("", "")
	  | ("", res) => ("", concat [" resulted in \"", res, "\""])
	  | (ans, "") => (concat [" expected \"", ans, "\""], "")
	  | (ans, res) => (concat [" expected \"", ans, "\""], concat [" but resulted in \"", res, "\""])
	in
	  concat [msg, StringCvt.padRight #" " 5 arg, ans, res, "\n" ]
	end

      fun fail0 arg = show "FAIL: " arg "" ""
      fun pass0 arg = show "PASS: " arg "" ""
      fun fail arg ans res = show "FAIL: " arg ans res
      fun pass arg ans res = show "PASS: " arg ans res
      fun unresolved arg res = show "UNRESOLVED: " arg "" res 

      fun DoTest0 s testfn =
	print (if testfn then
		 pass0 s
	       else
		 fail0 s)

      fun DoTest s testfn args checkfn = 
	let
	  val res = map (fn x=>(testfn x)) args
	  val res2 = checkfn res
	in
	  print "\n";
	  print
	  (if res2 then
	     pass s "" ""
	   else
	     fail s "" "")
	end

      fun DoTest2 s f fromArg fromRes args =
	let
	  fun scan (acc,[]) = acc
	    | scan (acc, (arg, (res, match))::rest) = 
	    if match then 
	      scan ((pass (fromArg arg) "" (fromRes res)) :: acc, rest)
	    else 
	      scan ((fail (fromArg arg) "" (fromRes res)) :: acc, rest)
	in
	  print "\n";
	  print s;
	  print "\n";
	  case zip2 args (map f args) of
	    res => (print o concat o scan) ([],res)
	end

      fun DoTest3 s f arg = 
	(print "\n"; print s;
	 print "\n"; print (f arg);
	 print "\n")

      fun DoTest4 s f fromArg fromRes args =
	let
	  fun scan (acc,[]) = acc
	    | scan (acc, (arg, (res, NONE)) ::rest) = 
	    scan ((unresolved (fromArg arg) (fromRes res)) :: acc, rest)
	    | scan (acc, (arg, (res, SOME match))::rest) = 
	    if match then 
	      scan ((pass (fromArg arg) "" (fromRes res)) :: acc, rest)
	    else 
	      scan ((fail (fromArg arg) "" (fromRes res)) :: acc, rest)
	in
	  print "\n";
	  print s;
	  print "\n";
	  case zip2 args (map f args) of
	    res => (print o concat o scan) ([],res)
	end
    end
  open Test
in
d54 1
a54 1
  val _ =
d56 12
a67 1
    val toLower = String.map Char.toLower
d69 83
a151 64
    DoTest2 "check Windows.findExecutable: notepad and notepad.exe return same results"
    (fn x=>case (Windows.findExecutable x,Windows.findExecutable "notepad.exe") of 
     (res0,res1) => (res0,
		     res0 = res1 andalso
		     isSome res1 andalso
		     size (OS.Path.dir (valOf res0)) > 0 andalso
		     (OS.Path.getVolume (valOf res0)) = "C:" andalso
		     (OS.Path.file (valOf res0)) = "notepad.exe"))
    (fn x=>x)
    (valOf)
    ["notepad", "notepad.exe"];

    DoTest2 "check platform dependent Windows.findExecutable: mixed case filenames shouldnt cause any exceptions"
    (fn x=>case (Windows.findExecutable x, Windows.findExecutable "notepad.exe") of
     (res0,res1) => (res0,
		     case (((String.map Char.toUpper) o valOf) res0, ((String.map Char.toUpper) o valOf) res1) of
		       (res0a, res1a) => (res0a = res1a) andalso
			 (OS.Path.base o OS.Path.file) res0a = "NOTEPAD"))
    (fn x=>x)
    (valOf)
    ["NOTEPAD", "NOTEPAD.exe",
     "NOTEPAD.EXE", "NOTEPAD.exe",
     "notepad.EXE", "NOTEPAD.exe"];

    DoTest2 "check Windows.findExecutable: failures results should be NONE"
    (fn x=>case (Windows.findExecutable x) handle exn=>SOME (General.exnName exn) of 
     res => (res, not (isSome res)))
    (fn x=>x)
    (fn (SOME x) => x | NONE => "")
    ["notepad2"];

    DoTest2 "check Windows.findExecutable: directories result should be explorer"
    (fn x=>case (Windows.findExecutable x) handle exn=>SOME (General.exnName exn) of 
     res => (res, case res of
	     SOME x => toLower(OS.Path.file x) = "explorer.exe"
           | NONE => false))
    (fn x=>x)
    (valOf)
    ["", "c:", "C:", "c:\\tmp"];

    DoTest2 "check Windows.findExecutable: failures for valid non executable files (no checks for validity of files)"
    (fn x=>case (Windows.findExecutable x) handle exn => SOME (General.exnName exn) of
     res => (res, ((isSome res) andalso
		   valOf res <> "SysErr" andalso
		   List.exists (fn x=>((toLower o OS.Path.base o OS.Path.file o valOf) res)=x)
		   ["notepad", "textedit", "word", "gnuclientw", "gnudoit", "emacs", "textpad", "winhlp32"])
	     ))
    (fn x=>x)
    (fn SOME s => s | NONE => "")
    ["winnt.hlp"];
(*
 * my results are wierd and may not be duplicable on other systems
check Windows.findExecutable: failures for non executable files
PASS: arg "C:\WINNT\system32\winnt.hlp"
PASS: arg "winnt.hlp"
PASS: arg "C:BOOTLOG.TXT"
PASS: arg "C:\BOOTLOG.TXT"
and a trick to view the output is to negate the conditional and run it again gives:
check Windows.findExecutable: failures for non executable files
FAIL: arg "C:\WINNT\system32\winnt.hlp"  but found "C:\WINNT\System32\winhlp32.exe"
FAIL: arg "winnt.hlp"  but found "C:\WINNT\System32\winhlp32.exe"
FAIL: arg "C:BOOTLOG.TXT"  but found "d:\usr\local\soft\gnuserv\gnuclientw.exe"
FAIL: arg "C:\BOOTLOG.TXT"  but found "d:\usr\local\soft\gnuserv\gnuclientw.exe"
 *
d154 293
a446 82
    let
      fun toString (f,arg) = 
	let
	  fun toString x = 
	    case x of 
	      "" => "\"\"" 
	    | x => x
	  val argStr = foldr (fn (x,acc)=> (toString x) ^ " " ^ acc) "" arg
	in
	  concat [" ", toString f, "(", argStr, ")"]
	end
    in
      DoTest2 "check Windows.shellExecute: results should be SysErr"
      (fn x=>case (Windows.shellExecute x; "unit") handle exn=>General.exnName exn of
       res => (res, res = "SysErr"))
      toString
      (fn x=>x)
      [("apple",[]), ("pear",[]), ("oranges",[]), ("guava", ["expresso"]), ("guava", ["expresso", "cuppucino"]),
       ("", []),
       ("", ["", ""])
       ];
      DoTest2 "check Windows.shellExecute: valid executable and arguments"
      (fn x=>case (Windows.shellExecute x; "unit") handle exn=>General.exnName exn of
       res => (res, res = "unit"))
      toString
      (fn x=>x)
      [("dir", ["c:"]),
       ("dir", [])
       ]
    end;

(* interactive test only 
 DoTest2 "check Windows.shellExecute: valid interactive executable and arguments"
 (fn x=>case (Windows.shellExecute x; "unit") handle exn=>General.exnName exn of
 res => (res, res = "unit"))
 (fn (x,y)=>concat [x,"(...)"])
 (fn x=>x)
 [("c:\\WINNT\\system32\\notepad",
 ["c:\\BOOTLOG.TXT"]),
 ("notepad", ["C:bootlog.txt"])];
*)

    DoTest2 "check Windows.execute: valid SysErr failure cases"
    (fn x=>case (ignore (Windows.execute x); "unit") handle exn=> General.exnName exn of
     res => (res, res = "SysErr"))
    (fn (x,args)=>x)
    (fn x=>x)
    [("bogus", []),
     ("", []),
     ("c:", [])];

    DoTest2 "check Windows.execute: untested general cases"
    (fn x=>case (ignore (Windows.execute x); "unit") handle exn=>General.exnName exn of
     res=> (res, true))
    (fn (x,args)=>x)
    (fn x=>x)
    [];

    print (unresolved "check Windows.execute" "");

    (* MLWorks> case Windows.streamsOf proc of (procin, procout) => TextIO.inputLine procin; *)

    print (unresolved "check Windows.hasOwnConsole" "");

    DoTest2 "check Windows.hasOwnConsole: untested"
    (fn x=>case (Bool.toString o Windows.hasOwnConsole) x handle exn=> General.exnName exn of
     res => (res, res = "SysErr"))
    (fn x=>"()")
    (fn x=>x)
    [()];

(*
  GUI: SysErr
  console(bash-based): true
  console(bash-based within an emacs buffer): SysErr
*)

    print (unresolved "Windows.newConsole" "");

(* GUI: SysErr
 * emacs bash: creates new console
 * bash console: quits mlworks
d449 50
d500 3
a502 1
(* File System *)
d504 1
a504 101
    let
      fun myDoTest s f arg =
	(print ("check "^s); print "\n";
	 print (unresolved s ((Date.toString o Date.fromTimeLocal o f) arg)))

      val file = "c:\\bootlog.txt";
      val fileTime = OS.FileSys.modTime file;

    in
      myDoTest "OS.FileSys.modTime" (OS.FileSys.modTime) file;
      myDoTest "Windows.localFileTimeToFileTime" (Windows.localFileTimeToFileTime) fileTime;
      myDoTest "Windows.fileTimeToLocalFileTime" (Windows.fileTimeToLocalFileTime) fileTime;
      DoTest0 "Windows.fileTimeToLocalFileTime is inverse of Windows.localFileTimeToFileTime"
      (((Windows.fileTimeToLocalFileTime o Windows.localFileTimeToFileTime) fileTime) = fileTime)
    end handle _ =>
      print"File system tests fails with unexpected exception";

    DoTest2 "check Windows.getVolumeInformation: untested generic and failure case" 
    (fn x=>
     case (SOME (Windows.getVolumeInformation x), NONE) handle exn => (NONE, SOME (General.exnName exn)) of
       (SOME 
	{volumeName=volumeName,
	 systemName=systemName,
	 serialNumber=serialNumber,
	 maximumComponentLength=maximumComponentLength,
	 flags=flags}, NONE) => (concat [volumeName,":",systemName], true)
       | (NONE, exn) => (valOf exn, (not (valOf exn = "SysErr")))
       | (res, exn) => raise Fail "Impossible")
    (fn x=>x)
    (fn x=>x)
    ["a:", "g:", "", ":", "b:", "c:", "d:", "e:", "f:", "y:", "z:"];
(*
check Windows.getVolumeInformation: failure case
PASS: arg "z:" (* /u/io *)
FAIL: arg "y:"  but found "SysErr"  (* should be a samba drive linked to /u/sml  *)
PASS: arg "f:" (* hope directory *)
PASS: arg "e:" (* CDROM drive *)
PASS: arg "d:" (* NTFS drive *)
PASS: arg "c:" (* FAT drive *)
FAIL: arg "b:"  but found "SysErr"
FAIL: arg ":"  but found "SysErr"
FAIL: arg ""  but found "SysErr"
FAIL: arg "g:"  but found "SysErr"
PASS: arg "a:" (* Floppy drive *)
*)


(*

val lsid = Windows.execute ("d:\\usr\\H-i386-cygwin32\\bin\\ls.exe", []);;
val (lsin, lsout) = Windows.streamsOf lsid;

*)


(* Key *)
    print (unresolved "Windows.Key.allAccess" "");
    print (unresolved "\n\
     \mlworks reports type for Windows.createKeyEx as\n\
     \val createKeyEx : (Flags.flags * string * S.Reg.options * Flags.flags) -> S.Reg.create_result option = fn\n\
     \which makes hkey and Key.flags difficult to distinguish in the signature entry defined as\n\
     \val createKeyEx : hkey * string * options * Key.flags -> create_result option" "");
    print (unresolved "Windows.Key.createLink" "");
    print (unresolved "Windows.Key.createSubKey" "");
    print (unresolved "Windows.Key.enumerateSubKeys" "");
    print (unresolved "Windows.Key.execute" "");
    print (unresolved "Windows.Key.notify" "");
    print (unresolved "Windows.Key.queryValue" "");
    print (unresolved "Windows.Key.read" "");
    print (unresolved "Windows.Key.setValue" "");
    print (unresolved "Windows.Key.write" "");
    (* Reg *)
    print (unresolved "Windows.Reg.classesRoot" "");
    print (unresolved "Windows.Reg.currentUser" "");
    print (unresolved "Windows.Reg.localMachine" "");
    print (unresolved "Windows.Reg.users" "");
    
    print (unresolved "Windows.Reg.createKeyEx" "");
    print (unresolved "Windows.Reg.createKeyEx (Windows.Reg.currentUser, \"Software\", Windows.Reg.VOLATILE, Windows.Key.queryValue) crashes MLWorks" "");
    print (unresolved "Windows.Reg.openKeyEx" "");
    
    print (unresolved "Windows.Reg.openKeyEx (Windows.Reg.localMachine, \"Software\", Windows.Key.enumerateSubKeys) crashes MLWorks" "");
    print (unresolved "calling Windows.Reg.openKeyEx (Windows.Reg.currentUser, \"Software\", Windows.Key.execute) crashes MLWorks" "");
    print (unresolved "calling Windows.Reg.openKeyEx (Windows.Reg.localMachine, \"Software\", Windows.Key.execute) crashes MLWorks" "");
    print (unresolved "Windows.Reg.queryValueEx" "");
    print (unresolved "Windows.Reg.setValueEx" "");
    print (unresolved "Windows.Reg.closeKey" "");
    print (unresolved "Windows.Reg.deleteKey" "");
    print (unresolved "calling Windows.Reg.closeKey (Windows.Reg.localMachine)" "");
    print (unresolved "types in structure Windows for hkey and flags cannot be distinguished" "");
    
    
    (* DDE *)
    print (unresolved "Windows.DDE.startDialog" "");
    print (unresolved "Windows.DDE.startDialog (\"NETSCAPE\", \"System\"); raises SysErr instead of succeeding" "");
    print (unresolved "Windows.DDE.startDialog (\"NETSCAPE\", \"WWW_OpenURL\"); raises SysErr instead of succeeding" "");
    print (unresolved "Windows.DDE.executeString" "");
    print (unresolved "Windows.DDE.requestString" "");
    print (unresolved "Windows.DDE.stopDialog" "")
  end
end
@


1.3
log
@[Bug #50094]
Modify to work now Windows is not included in guib.img by default
@
text
@d5 4
d18 92
a109 76
Shell.Project.openProject "../src/basis.mlp";
Shell.Project.setConfiguration "I386/NT";
Shell.Project.load "windows";
Shell.Project.load "__windows";
structure Test =
  struct

    fun zip2 (x::xs) (y::ys) = (x,y) :: (zip2 xs ys)
      |  zip2 []      [] = []
      |  zip2 _       _ = raise Fail "zip2"
      

    fun show msg arg ans res =
      let 
        val arg = concat ["\"", arg, "\""]
	val (ans,res) = case (ans,res) of
          ("", "") => ("", "")
        | ("", res) => ("", concat [" resulted in \"", res, "\""])
        | (ans, "") => (concat [" expected \"", ans, "\""], "")
        | (ans, res) => (concat [" expected \"", ans, "\""], concat [" but resulted in \"", res, "\""])

      in
        concat [msg, StringCvt.padRight #" " 5 arg, ans, res, "\n" ]
      end

    fun fail0 arg = show "FAIL: " arg "" ""
    fun pass0 arg = show "PASS: " arg "" ""
    fun fail arg ans res = show "FAIL: " arg ans res
    fun pass arg ans res = show "PASS: " arg ans res
    fun unresolved arg res = show "UNRESOLVED: " arg "" res 

    fun DoTest0 s testfn =
      let
      in
        print (if testfn then
                 pass0 s
               else
                 fail0 s)
      end

    fun DoTest s testfn args checkfn = 
      let
        val res = map (fn x=>(testfn x)) args
        val res2 = checkfn res
      in
        print "\n";
        print
        (if res2 then
           pass s "" ""
         else
           fail s "" "")
      end

    fun DoTest2 s f fromArg fromRes args =
      let
        fun scan (acc,[]) = acc
          | scan (acc, (arg, (res, match))::rest) = 
          if match then 
            scan ((pass (fromArg arg) "" (fromRes res)) :: acc, rest)
          else 
            scan ((fail (fromArg arg) "" (fromRes res)) :: acc, rest)
      in
        print "\n";
        print s;
        print "\n";
        case zip2 args (map f args) of
          res => (print o concat o scan) ([],res)
      end

    fun DoTest3 s f arg = 
      let
      in
        print "\n"; print s;
        print "\n"; print (f arg);
        print "\n"
      end
d111 1
a111 1
fun DoTest4 s f fromArg fromRes args =
d113 36
a148 55
  fun scan (acc,[]) = acc
    | scan (acc, (arg, (res, NONE)) ::rest) = 
    scan ((unresolved (fromArg arg) (fromRes res)) :: acc, rest)
    | scan (acc, (arg, (res, SOME match))::rest) = 
    if match then 
      scan ((pass (fromArg arg) "" (fromRes res)) :: acc, rest)
    else 
      scan ((fail (fromArg arg) "" (fromRes res)) :: acc, rest)
in
  print "\n";
  print s;
  print "\n";
  case zip2 args (map f args) of
    res => (print o concat o scan) ([],res)
end
end
open Test;

let
  val toLower = String.map Char.toLower
in
DoTest2 "check Windows.findExecutable: notepad and notepad.exe return same results"
  (fn x=>case (Windows.findExecutable x,Windows.findExecutable "notepad.exe") of 
   (res0,res1) => (res0,
                   res0 = res1 andalso
                   isSome res1 andalso
                   size (OS.Path.dir (valOf res0)) > 0 andalso
                   (OS.Path.getVolume (valOf res0)) = "C:" andalso
                   (OS.Path.file (valOf res0)) = "notepad.exe"))
  (fn x=>x)
  (valOf)
  ["notepad", "notepad.exe"];

DoTest2 "check platform dependent Windows.findExecutable: mixed case filenames shouldnt cause any exceptions"
  (fn x=>case (Windows.findExecutable x, Windows.findExecutable "notepad.exe") of
   (res0,res1) => (res0,
                   case (((String.map Char.toUpper) o valOf) res0, ((String.map Char.toUpper) o valOf) res1) of
                     (res0a, res1a) => (res0a = res1a) andalso
                       (OS.Path.base o OS.Path.file) res0a = "NOTEPAD"))
  (fn x=>x)
  (valOf)
  ["NOTEPAD", "NOTEPAD.exe",
   "NOTEPAD.EXE", "NOTEPAD.exe",
   "notepad.EXE", "NOTEPAD.exe"];

DoTest2 "check Windows.findExecutable: failures results should be NONE"
  (fn x=>case (Windows.findExecutable x) handle exn=>SOME (General.exnName exn) of 
   res => (res, not (isSome res)))
  (fn x=>x)
  (fn (SOME x) => x | NONE => "")
  ["notepad2"];

DoTest2 "check Windows.findExecutable: directories result should be explorer"
  (fn x=>case (Windows.findExecutable x) handle exn=>SOME (General.exnName exn) of 
   res => (res, case res of
d151 14
a164 15
  (fn x=>x)
  (valOf)
  ["", "c:", "C:", "c:\\tmp"];

DoTest2 "check Windows.findExecutable: failures for valid non executable files (no checks for validity of files)"
  (fn x=>case (Windows.findExecutable x) handle exn => SOME (General.exnName exn) of
  res => (res, ((isSome res) andalso
                    valOf res <> "SysErr" andalso
          List.exists (fn x=>((toLower o OS.Path.base o OS.Path.file o valOf) res)=x)
          ["notepad", "textedit", "word", "gnuclientw", "gnudoit", "emacs", "textpad", "winhlp32"])
          ))
  (fn x=>x)
  (fn SOME s => s | NONE => "")
  ["winnt.hlp"];

a180 2
let
  fun toString (f,arg) = 
d182 10
a191 5
      fun toString x = 
        case x of 
          "" => "\"\"" 
        | x => x
      val argStr = foldr (fn (x,acc)=> (toString x) ^ " " ^ acc) "" arg
d193 18
a210 3
      concat [" ", toString f, "(", argStr, ")"]
    end
in
a211 21
  DoTest2 "check Windows.shellExecute: results should be SysErr"
  (fn x=>case (Windows.shellExecute x; "unit") handle exn=>General.exnName exn of
   res => (res, res = "SysErr"))
  toString
  (fn x=>x)
  [("apple",[]), ("pear",[]), ("oranges",[]), ("guava", ["expresso"]), ("guava", ["expresso", "cuppucino"]),
   ("", []),
   ("", ["", ""])
   ];


  DoTest2 "check Windows.shellExecute: valid executable and arguments"
  (fn x=>case (Windows.shellExecute x; "unit") handle exn=>General.exnName exn of
   res => (res, res = "unit"))
  toString
  (fn x=>x)
  [("dir", ["c:"]),
   ("dir", [])
   ]
end;
  
d223 28
a250 31

DoTest2 "check Windows.execute: valid SysErr failure cases"
  (fn x=>case (ignore (Windows.execute x); "unit") handle exn=> General.exnName exn of
   res => (res, res = "SysErr"))
  (fn (x,args)=>x)
  (fn x=>x)
  [("bogus", []),
   ("", []),
   ("c:", [])];


DoTest2 "check Windows.execute: untested general cases"
  (fn x=>case (ignore (Windows.execute x); "unit") handle exn=>General.exnName exn of
   res=> (res, true))
  (fn (x,args)=>x)
  (fn x=>x)
  [];

print (unresolved "check Windows.execute" "");


(* MLWorks> case Windows.streamsOf proc of (procin, procout) => TextIO.inputLine procin; *)

print (unresolved "check Windows.hasOwnConsole" "");

DoTest2 "check Windows.hasOwnConsole: untested"
  (fn x=>case (Bool.toString o Windows.hasOwnConsole) x handle exn=> General.exnName exn of
   res => (res, res = "SysErr"))
  (fn x=>"()")
  (fn x=>x)
  [()];
d258 1
a258 1
print (unresolved "Windows.newConsole" "");
a267 2
let
  fun myDoTest s f arg =
d269 3
a271 4
    in
      print ("check "^s); print "\n";
      print (unresolved s ((Date.toString o Date.fromTimeLocal o f) arg))
    end
d273 2
a274 25
  val file = "c:\\bootlog.txt";
  val fileTime = OS.FileSys.modTime file;

in
  myDoTest "OS.FileSys.modTime" (OS.FileSys.modTime) file;
  myDoTest "Windows.localFileTimeToFileTime" (Windows.localFileTimeToFileTime) fileTime;
  myDoTest "Windows.fileTimeToLocalFileTime" (Windows.fileTimeToLocalFileTime) fileTime;
  DoTest0 "Windows.fileTimeToLocalFileTime is inverse of Windows.localFileTimeToFileTime"
    (((Windows.fileTimeToLocalFileTime o Windows.localFileTimeToFileTime) fileTime) = fileTime)
end;

DoTest2 "check Windows.getVolumeInformation: untested generic and failure case" 
  (fn x=>
   case (SOME (Windows.getVolumeInformation x), NONE) handle exn => (NONE, SOME (General.exnName exn)) of
     (SOME 
      {volumeName=volumeName,
       systemName=systemName,
       serialNumber=serialNumber,
       maximumComponentLength=maximumComponentLength,
       flags=flags}, NONE) => (concat [volumeName,":",systemName], true)
   | (NONE, exn) => (valOf exn, (not (valOf exn = "SysErr")))
   | (res, exn) => raise Fail "Impossible")
  (fn x=>x)
  (fn x=>x)
  ["a:", "g:", "", ":", "b:", "c:", "d:", "e:", "f:", "y:", "z:"];
d276 23
d324 35
a358 40
  print (unresolved "Windows.Key.allAccess" "");
  print (unresolved "\n\
\mlworks reports type for Windows.createKeyEx as\n\
\val createKeyEx : (Flags.flags * string * S.Reg.options * Flags.flags) -> S.Reg.create_result option = fn\n\
\which makes hkey and Key.flags difficult to distinguish in the signature entry defined as\n\
\val createKeyEx : hkey * string * options * Key.flags -> create_result option" "");
  print (unresolved "Windows.Key.createLink" "");
  print (unresolved "Windows.Key.createSubKey" "");
  print (unresolved "Windows.Key.enumerateSubKeys" "");
  print (unresolved "Windows.Key.execute" "");
  print (unresolved "Windows.Key.notify" "");
  print (unresolved "Windows.Key.queryValue" "");
  print (unresolved "Windows.Key.read" "");
  print (unresolved "Windows.Key.setValue" "");
  print (unresolved "Windows.Key.write" "");
  (* Reg *)
  print (unresolved "Windows.Reg.classesRoot" "");
  print (unresolved "Windows.Reg.currentUser" "");
  print (unresolved "Windows.Reg.localMachine" "");
  print (unresolved "Windows.Reg.users" "");

  print (unresolved "Windows.Reg.createKeyEx" "");
  print (unresolved "Windows.Reg.createKeyEx (Windows.Reg.currentUser, \"Software\", Windows.Reg.VOLATILE, Windows.Key.queryValue) crashes MLWorks" "");
  print (unresolved "Windows.Reg.openKeyEx" "");

  print (unresolved "Windows.Reg.openKeyEx (Windows.Reg.localMachine, \"Software\", Windows.Key.enumerateSubKeys) crashes MLWorks" "");
  print (unresolved "calling Windows.Reg.openKeyEx (Windows.Reg.currentUser, \"Software\", Windows.Key.execute) crashes MLWorks" "");
  print (unresolved "calling Windows.Reg.openKeyEx (Windows.Reg.localMachine, \"Software\", Windows.Key.execute) crashes MLWorks" "");
  print (unresolved "Windows.Reg.queryValueEx" "");
  print (unresolved "Windows.Reg.setValueEx" "");
  print (unresolved "Windows.Reg.closeKey" "");
  print (unresolved "Windows.Reg.deleteKey" "");
  print (unresolved "calling Windows.Reg.closeKey (Windows.Reg.localMachine)" "");
  print (unresolved "types in structure Windows for hkey and flags cannot be distinguished" "");


  (* DDE *)
  print (unresolved "Windows.DDE.startDialog" "");
  print (unresolved "Windows.DDE.startDialog (\"NETSCAPE\", \"System\"); raises SysErr instead of succeeding" "");
  print (unresolved "Windows.DDE.startDialog (\"NETSCAPE\", \"WWW_OpenURL\"); raises SysErr instead of succeeding" "");
d360 8
a367 3
  print (unresolved "Windows.DDE.executeString" "");
  print (unresolved "Windows.DDE.requestString" "");
  print (unresolved "Windows.DDE.stopDialog" "")
@


1.2
log
@Automatic checkin:
changed attribute _comment to ' *  '
@
text
@d4 5
a8 1
 * $Log$
d14 4
a17 5

(*use "library.sml";*)
(*copied across library.sml to here in the interim *)
structure Test =
(*
a19 16
    val DoTest : string -> ('a -> 'b) -> 'a list -> ('b list -> bool) -> unit = fn
    val DoTest0 : string -> bool -> unit = fn
    val DoTest2 : string -> ('a -> ('b * bool)) -> ('a -> string) -> ('b -> string) -> 'a list -> unit = fn
    val DoTest3 : string -> ('a -> string) -> 'a -> unit = fn
    val DoTest4 : string -> ('a -> ('b * bool option)) -> ('a -> string) -> ('b -> string) -> 'a list -> unit = fn
    val fail : string -> string -> string -> string = fn
    val fail0 : string -> string = fn
    val pass : string -> string -> string -> string = fn
    val pass0 : string -> string = fn
    val show : string -> string -> string -> string -> string = fn
    val unresolved : string -> string -> string = fn
    val zip2 : 'a list -> 'b list -> ('a * 'b) list = fn
  end

*)
  struct
d112 1
d142 9
d152 1
a152 2
  ["notepad2", "", "c:", "C:", "c:\\tmp"];

d158 1
a158 1
          List.exists (fn x=>(((String.map Char.toLower) o OS.Path.base o OS.Path.file o valOf) res)=x)
d162 2
a163 2
  (valOf)
  ["C:\\BOOTLOG.TXT", "C:BOOTLOG.TXT", "winnt.hlp", "C:\\WINNT\\system32\\winnt.hlp"];
@


1.1
log
@new unit
[Bug #70086]
simple tests for proposed basis Windows structure
@
text
@@
