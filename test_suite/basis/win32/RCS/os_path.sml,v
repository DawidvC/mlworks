head	1.8;
access;
symbols
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.7
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.6
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.3.1.1.1.2.1
	MLWorks_11c0_1997_09_09:1.3.1.1.1.2
	MLWorks_10r3:1.3.1.1.3
	MLWorks_10r2_551:1.3.1.1.2
	MLWorks_11:1.3.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.1.1
	MLWorks_20m0_1997_06_20:1.3
	MLWorks_1_0_r2c2_1997_06_14:1.3.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.3.1
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.3.1.1
	MLWorks_gui_1996_12_18:1.2.4
	MLWorks_1_0_Win32_1996_12_17:1.2.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.1.1
	MLWorks_1_0_Irix_1996_11_28:1.2.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.2
	MLWorks_1_0_Unix_1996_11_14:1.2.1
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1;
locks; strict;
comment	@ *  @;


1.8
date	99.03.17.10.42.58;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	98.08.13.13.08.22;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	98.03.03.18.10.28;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	98.01.22.16.26.22;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	97.08.11.14.45.47;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	97.03.05.17.20.06;	author jont;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	96.10.22.13.24.57;	author jont;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1
	1.2.4.1;
next	1.1;

1.1
date	96.06.20.11.32.09;	author andreww;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	96.09.13.11.38.34;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.29.57;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.50.39;	author hope;	state Exp;
branches;
next	;

1.2.1.1
date	96.11.14.13.18.04;	author hope;	state Exp;
branches
	1.2.1.1.1.1;
next	;

1.2.1.1.1.1
date	96.11.28.15.28.33;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.11.22.18.35.50;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.12.17.18.14.49;	author hope;	state Exp;
branches
	1.2.3.1.1.1;
next	;

1.2.3.1.1.1
date	97.02.24.12.07.47;	author hope;	state Exp;
branches;
next	;

1.2.4.1
date	96.12.18.10.09.48;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	97.05.12.11.08.25;	author hope;	state Exp;
branches
	1.3.1.1.1.1
	1.3.1.1.2.1
	1.3.1.1.3.1;
next	;

1.3.1.1.1.1
date	97.07.28.18.50.26;	author daveb;	state Exp;
branches;
next	1.3.1.1.1.2;

1.3.1.1.1.2
date	97.08.12.09.37.58;	author johnh;	state Exp;
branches
	1.3.1.1.1.2.1.1;
next	;

1.3.1.1.1.2.1.1
date	97.10.07.12.14.32;	author jkbrook;	state Exp;
branches;
next	;

1.3.1.1.2.1
date	97.09.08.17.42.15;	author daveb;	state Exp;
branches;
next	;

1.3.1.1.3.1
date	97.09.09.14.41.41;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Test file for win_nt/__os_path.sml
@


1.8
log
@[Bug #30092]
Added tests for invalid arcs.
@
text
@(* Copyright (c) 1996 Harlequin Ltd.

Result: OK

 *
 * Test Win32 OS.PATH.*.  All tests should return true.
 * 
 *
 * Revision Log
 * ------------
 *
 * $Log: win32:os_path.sml,v $
 *  Revision 1.7  1998/08/13  13:08:22  jont
 *  [Bug #30468]
 *  mkAbsolute and mkRelative now takes records arguments rather than tuples
 *
 *  Revision 1.6  1998/03/03  18:10:28  jont
 *  [Bug #30323]
 *  Remove use of loadSource, and fix uses of concat to new spec
 *
 *  Revision 1.5  1998/01/22  16:26:22  jont
 *  [Bug #30323]
 *  Remove unnecessary uses of Shell.Build.loadSource
 *
 *  Revision 1.4  1997/08/11  14:45:47  jont
 *  [Bug #30245]
 *  Fix problems with basis structures changing
 *
 *  Revision 1.3  1997/03/05  17:20:06  jont
 *  [Bug #1939]
 *  Add tests for toUnixPath and fromUnixPath
 *
 *  Revision 1.2  1996/10/22  13:24:57  jont
 *  Remove references to toplevel
 *
 *  Revision 1.1  1996/06/20  11:32:09  andreww
 *  new unit
 *  Test file for win_nt/__os_path.sml
 *
 *
 *)

local 
  open OS.Path
  val dirSeparator = #"\\"
  val extSeparator = #"."
  val parentArc = ".."
  val currentArc = "."
  val volumeSeparator = #":"
  val sep = String.str dirSeparator
  val cur = currentArc
  val par = parentArc

  infix 1 seq
  fun e1 seq e2 = e2;
  fun check' f = (if f () then "OK" else "WRONG") handle _ => "EXN";

in
    
  val test1a = 
    check'(fn _ => fromString "" = {isAbs=false, vol = "", arcs = []});
  val test1b = 
    check'(fn _ => fromString sep = {isAbs=true, vol="", arcs=[""]});
  val test1c = 
    check'(fn _ => fromString (sep^sep)
           = {isAbs=true, vol="", arcs=["", ""]});
  val test1d = 
    check'(fn _ => fromString "a" = {isAbs=false, vol = "", arcs = ["a"]});
  val test1e =
    check'(fn _ => fromString (sep^"a") = {isAbs=true, vol="", arcs=["a"]});
  val test1f = 
    check'(fn _ => fromString (sep^sep^"a")
           = {isAbs=true, vol="", arcs=["","a"]});
  val test1g = 
    check'(fn _ => fromString ("a"^sep)
           = {isAbs=false, vol = "", arcs = ["a", ""]});
  val test1h = 
    check'(fn _ => fromString ("a"^sep^sep)
	   = {isAbs=false, vol = "", arcs = ["a", "", ""]});
  val test1i = 
    check'(fn _ => fromString ("a"^sep^"b")
           = {isAbs=false, vol = "", arcs = ["a", "b"]});
  val test1j = 
    check'(fn _ => fromString ("a.b"^sep^"c") = 
           {isAbs=false, vol = "", arcs = ["a.b", "c"]});
  val test1k = 
    check'(fn _ => fromString ("a.b"^sep^"c"^sep) =
           {isAbs=false, vol = "", arcs = ["a.b", "c", ""]});
  val test1l = 
    check'(fn _ => fromString ("a"^sep^cur^sep^"c")
           = {isAbs=false, vol = "", arcs = ["a", ".", "c"]});
  val test1m = 
    check'(fn _ => fromString ("a"^sep^par^sep^"c")
           = {isAbs=false, vol = "", arcs = ["a", "..", "c"]});
  val test1n = 
    check'(fn _ => fromString cur = {isAbs=false, vol = "", arcs = ["."]});

  val test2a =
    check'(fn _ => toString {isAbs=false, vol = "", arcs = []} = "");
  val test2b = 
    check'(fn _ => toString {isAbs=true, vol="a:", arcs=[]} = "a:"^sep);
  val test2c = 
    check'(fn _ => toString {isAbs=true, vol="A:", arcs=["", ""]} = 
           "A:"^sep^sep);
  val test2d = 
    check'(fn _ => toString {isAbs=false, vol = "", arcs = ["a"]} = "a");
  val test2e = 
    check'(fn _ => toString {isAbs=true, vol="a:", arcs=["a"]} = "a:"^sep^"a");
  val test2f = 
    check'(fn _ => toString {isAbs=true, vol="a:", arcs=["","a"]} = 
           "a:"^sep^sep^"a");
  val test2g = 
    check'(fn _ => toString {isAbs=false, vol = "", arcs = ["a", ""]} = "a"^sep);
  val test2h = 
    check'(fn _ => toString {isAbs=false, vol = "", arcs = ["a", "", ""]} = 
           "a"^sep^sep);
  val test2i = 
    check'(fn _ => toString {isAbs=false, vol = "", arcs = ["a", "b"]} = 
           "a"^sep^"b");
  val test2j = 
    check'(fn _ => toString {isAbs=false, vol = "", arcs = ["a.b", "c"]} = 
           "a.b"^sep^"c");
  val test2k = 
    check'(fn _ => toString {isAbs=false, vol = "", arcs = ["a.b", "c", ""]} 
           = "a.b"^sep^"c"^sep);
  val test2l = 
    check'(fn _ => toString {isAbs=false, vol = "", arcs = ["a", ".", "c"]} 
           = "a"^sep^cur^sep^"c");
  val test2m = 
    check'(fn _ => toString {isAbs=false, vol = "", arcs = ["a", "..", "c"]} 
           = "a"^sep^par^sep^"c");
  val test2n = 
    check'(fn _ => toString {isAbs=true, vol="", arcs=["a", "..", "c"]} 
           = sep^"a"^sep^par^sep^"c");
  val test2o = (toString {isAbs=false, vol = "", arcs =  ["", "a"]} seq "WRONG")
    handle Path => "OK" | _ => "WRONG";
  val test2p = 
    check'(fn _ => 
	   (toString {isAbs=true, vol = "C:", arcs =  ["windows"]} 
	    = "C:"^sep^"windows"));
  val test2q =
    (toString {isAbs=false, vol="", arcs = ["a\\b"]} seq "WRONG")
    handle InvalidArc => "OK" | _ => "WRONG"

  val test3b = 
    check'(fn _ => getVolume "\\" = "");
  val test3c = 
    check'(fn _ => getVolume "\\\\" = "");
  val test3d = 
    check'(fn _ => getVolume "a\\b\\c\\" = "");
  val test3e = 
    check'(fn _ => getVolume ".\\" = "");
  val test3f = 
    check'(fn _ => getVolume "..\\" = "");
  val test3g = 
    check'(fn _ => getVolume "" = "");
  val test3h = 
    check'(fn _ => getVolume "C:" = "C:");

  val test4a = 
    check'(fn _ => 
	   List.all isRelative ["", ".", "..", "a\\\\"]
	   andalso not (List.exists isRelative ["\\", "\\a", "\\\\"]));
  val test4b = 
    check'(fn _ => 
	   List.all isAbsolute ["\\", "\\a", "\\\\", "\\.", "\\.."]
	   andalso not (List.exists isAbsolute ["", ".", "..", "a\\\\"]));

  val test5a = 
    check'(fn _ => 
	   getParent "\\" = "\\"
	   andalso getParent "a" = "."
	   andalso getParent "a\\" = "a\\.."
	   andalso getParent "a\\\\\\" = "a\\\\\\.."
	   andalso getParent "a\\b" = "a"
	   andalso getParent "a\\b\\" = "a\\b\\.."
	   andalso getParent "\\a\\b" = "\\a"
	   andalso getParent "\\a\\b\\" = "\\a\\b\\.." 
	   andalso getParent ".." = "..\\.."
	   andalso getParent "." = ".."
	   andalso getParent "..\\" = "..\\.."
	   andalso getParent ".\\" = ".\\.."
	   andalso getParent "" = "..");

  val test6a = 
    check'(fn _ => 
	   concat(["a", "b"]) = "a\\b"
	   andalso concat(["a", "b\\c"]) = "a\\b\\c"
	   andalso concat(["\\", "b\\c"]) = "\\\\b\\c"
	   andalso concat(["", "b\\c"]) = "b\\c"
	   andalso concat(["\\a", "b\\c"]) = "\\a\\b\\c"
	   andalso concat(["a\\", "b\\c"]) = "a\\\\b\\c"
	   andalso concat(["a\\\\", "b\\c"]) = "a\\\\\\b\\c"
	   andalso concat([".", "b\\c"]) = ".\\b\\c"
	   andalso concat(["a\\b", ".."]) = "a\\b\\.."
	   andalso concat(["a\\b", "..\\c"]) = "a\\b\\..\\c");
  val test6b = (concat (["a", "\\b"]) seq "WRONG")
    handle Path => "OK" | _ => "WRONG";

  val test7a = 
    check'(fn _ => 
	   mkAbsolute{path="\\a\\b", relativeTo="\\c\\d"} = "\\a\\b"
	   andalso mkAbsolute{path="\\", relativeTo="\\c\\d"} = "\\"
	   andalso mkAbsolute{path="a\\b", relativeTo="\\c\\d"} = "\\c\\d\\a\\b");
  val test7b = (mkAbsolute{path="a", relativeTo="c\\d"} seq "WRONG")
    handle Path => "OK" | _ => "WRONG";
  val test7c = (mkAbsolute{path="\\a", relativeTo="c\\d"} seq "WRONG")
    handle Path => "OK" | _ => "WRONG";

  val test8a = 
    check'(fn _ => 
	   mkRelative{path="a\\b", relativeTo="\\c\\d"} = "a\\b"
	   andalso mkRelative{path="\\", relativeTo="\\a\\b\\c"}	   = "..\\..\\.." 
	   andalso mkRelative{path="\\a\\", relativeTo="\\a\\b\\c"}	   = "..\\..\\" 
	   andalso mkRelative{path="\\a\\b\\", relativeTo="\\a\\c"}	   = "..\\b\\"     
	   andalso mkRelative{path="\\a\\b",relativeTo= "\\a\\c\\"}	   = "..\\b"      
	   andalso mkRelative{path="\\a\\b\\", relativeTo="\\a\\c\\"}	   = "..\\b\\"     
	   andalso mkRelative{path="\\", relativeTo="\\"}		   = "."	      
	   andalso mkRelative{path="\\", relativeTo="\\."}	   = "."	      
	   andalso mkRelative{path="\\", relativeTo="\\.."}	   = "."	      
	   andalso mkRelative{path="\\", relativeTo="\\a"}	   = ".."	      
	   andalso mkRelative{path="\\a\\b\\..\\c", relativeTo="\\a\\d"} = "..\\b\\..\\c" 
	   andalso mkRelative{path="\\a\\b", relativeTo="\\c\\d"}      = "..\\..\\a\\b"
	   andalso mkRelative{path="\\c\\a\\b", relativeTo="\\c\\d"}    = "..\\a\\b"
	   andalso mkRelative{path="\\c\\d\\a\\b", relativeTo="\\c\\d"}  = "a\\b");
  val test8b = (mkRelative{path="\\a", relativeTo="c\\d"} seq "WRONG")
    handle Path => "OK" | _ => "WRONG";
  val test8c = (mkRelative{path="a", relativeTo="c\\d"} seq "WRONG")
    handle Path => "OK" | _ => "WRONG";

  val test9a =
    let
      fun chkCanon (a, b) =
	(mkCanonical a = b) 
	andalso (mkCanonical b = b)
	andalso (isCanonical b)
    in
      check'(fn _ => 
	     chkCanon("", ".")
	     andalso chkCanon(".", ".")
	     andalso chkCanon(".\\.", ".")
	     andalso chkCanon("\\.", "\\")
	     andalso chkCanon("..", "..")
	     andalso chkCanon("..\\..", "..\\..")
	     andalso chkCanon("b", "b")
	     andalso chkCanon("a\\b", "a\\b")
	     andalso chkCanon("\\a\\b", "\\a\\b")
	     andalso chkCanon("a\\b\\", "a\\b")
	     andalso chkCanon("a\\b\\\\", "a\\b")
	     andalso chkCanon("a\\..\\b", "b")
	     andalso chkCanon("a\\..", ".")
	     andalso chkCanon("a\\.", "a")
	     andalso chkCanon("a\\", "a")
	     andalso chkCanon("\\a\\..\\b\\", "\\b")
	     andalso chkCanon("\\..", "\\")
	     andalso chkCanon("\\..\\..\\a\\b", "\\a\\b")
	     andalso chkCanon("\\.\\..\\..\\a\\b", "\\a\\b")
	     andalso chkCanon("\\.\\..\\..", "\\")
	     andalso chkCanon("a\\..\\b", "b")
	     andalso chkCanon("a\\.\\b", "a\\b")
	     andalso chkCanon("a\\\\\\\\b", "a\\b")
	     andalso chkCanon("a\\\\\\\\b", "a\\b"))
    end

  val test10a = 
    check'(fn _ => 
	   not (isCanonical ".\\."
		orelse isCanonical "\\.."
		orelse isCanonical "\\."
		orelse isCanonical "\\\\"
		orelse isCanonical "a\\.."
		orelse isCanonical "a\\\\b"
		orelse isCanonical "a\\."
	        orelse isCanonical "a\\b\\"
		orelse isCanonical "a\\.."))

  val test11a = 
    check'(fn _ => 
	   splitDirFile "" = {dir = "", file = ""}
	   andalso splitDirFile "." = {dir = "", file = "."}
	   andalso splitDirFile ".." = {dir = "", file = ".."}
	   andalso splitDirFile "b" = {dir = "", file = "b"}
	   andalso splitDirFile "b\\" = {dir = "b", file = ""}
	   andalso splitDirFile "a\\b" = {dir = "a", file = "b"}
	   andalso splitDirFile "\\a" = {dir = "\\", file = "a"}
	   andalso splitDirFile "\\a\\b" = {dir = "\\a", file = "b"}
	   andalso splitDirFile "\\c\\a\\b" = {dir = "\\c\\a", file = "b"}
	   andalso splitDirFile "\\c\\a\\b\\" = {dir = "\\c\\a\\b", file = ""}
	   andalso splitDirFile "\\c\\a\\b.foo.bar" = {dir = "\\c\\a", file="b.foo.bar"}
	   andalso splitDirFile "\\c\\a\\b.foo" = {dir = "\\c\\a", file = "b.foo"});
    
  val test12 = 
    check'(fn _ => 
	   "" = joinDirFile {dir = "", file = ""}
	   andalso "b" = joinDirFile {dir = "", file = "b"}
	   andalso "\\" = joinDirFile {dir = "\\", file = ""}
	   andalso "\\b" = joinDirFile {dir = "\\", file = "b"}
	   andalso "a\\b" = joinDirFile {dir = "a", file = "b"}
	   andalso "\\a\\b" = joinDirFile {dir = "\\a", file = "b"}
	   andalso "\\c\\a\\b" = joinDirFile {dir = "\\c\\a", file = "b"}
	   andalso "\\c\\a\\b\\" = joinDirFile {dir = "\\c\\a\\b", file = ""}
	   andalso "\\c\\a\\b.foo.bar" = joinDirFile {dir = "\\c\\a", file="b.foo.bar"}
	   andalso "\\c\\a\\b.foo" = joinDirFile {dir = "\\c\\a", file = "b.foo"});
  val test12a =
    (joinDirFile {dir = "", file = "a\\b"} seq "WRONG")
    handle InvalidArc => "OK" | _ => "WRONG"

  val test13 = 
    check'(fn _ => 
	   dir "b" = ""
	   andalso dir "a\\b" = "a"
	   andalso dir "\\" = "\\"
	   andalso dir "\\b" = "\\"
	   andalso dir "\\a\\b" = "\\a"
	   andalso dir "\\c\\a\\b" = "\\c\\a"
	   andalso dir "\\c\\a\\b\\" = "\\c\\a\\b"
	   andalso dir "\\c\\a\\b.foo.bar" = "\\c\\a"
	   andalso dir "\\c\\a\\b.foo" = "\\c\\a");

  val test14 = 
    check'(fn _ => 
	   file "b" = "b"
	   andalso file "a\\b" = "b"
	   andalso file "\\" = ""
	   andalso file "\\b" = "b"
	   andalso file "\\a\\b" = "b"
	   andalso file "\\c\\a\\b" = "b"
	   andalso file "\\c\\a\\b\\" = ""
	   andalso file "\\c\\a\\b.foo.bar" = "b.foo.bar"
	   andalso file "\\c\\a\\b.foo" = "b.foo");

  val test15 = 
    check'(fn _ => 
	   splitBaseExt "" = {base = "", ext = NONE}
	   andalso splitBaseExt ".login" = {base = ".login", ext = NONE}
	   andalso splitBaseExt "\\.login" = {base = "\\.login", ext = NONE}
	   andalso splitBaseExt "a" = {base = "a", ext = NONE}
	   andalso splitBaseExt "a." = {base = "a.", ext = NONE}
	   andalso splitBaseExt "a.b" = {base = "a", ext = SOME "b"}
	   andalso splitBaseExt "a.b.c" = {base = "a.b", ext = SOME "c"}
	   andalso splitBaseExt "\\a.b" = {base = "\\a", ext = SOME "b"}
	   andalso splitBaseExt "\\c\\a.b" = {base = "\\c\\a", ext = SOME "b"}
	   andalso splitBaseExt "\\c\\a\\b\\.d" = {base = "\\c\\a\\b\\.d", ext = NONE}
	   andalso splitBaseExt "\\c.a\\b.d" = {base = "\\c.a\\b", ext = SOME "d"}
	   andalso splitBaseExt "\\c.a\\bd" = {base = "\\c.a\\bd", ext = NONE}
	   andalso splitBaseExt "\\c\\a\\b.foo.bar" = {base="\\c\\a\\b.foo",ext=SOME "bar"}
	   andalso splitBaseExt "\\c\\a\\b.foo" = {base = "\\c\\a\\b", ext = SOME "foo"});

  val test16 = 
    check'(fn _ => 
	   "" = joinBaseExt {base = "", ext = NONE}
	   andalso ".login" = joinBaseExt {base = ".login", ext = NONE}
	   andalso "a" = joinBaseExt {base = "a", ext = NONE}
	   andalso "a" = joinBaseExt {base = "a", ext = SOME ""}
	   andalso "a.b" = joinBaseExt {base = "a", ext = SOME "b"}
	   andalso "a.b.c" = joinBaseExt {base = "a.b", ext = SOME "c"}
	   andalso "a.b.c.d" = joinBaseExt {base = "a.b", ext = SOME "c.d"}
	   andalso "\\a.b" = joinBaseExt {base = "\\a", ext = SOME "b"}
	   andalso "\\c\\a.b" = joinBaseExt {base = "\\c\\a", ext = SOME "b"}
	   andalso "\\c\\a\\b\\.d" = joinBaseExt {base = "\\c\\a\\b\\", ext = SOME "d"}
	   andalso "\\c\\a\\b.foo.bar" = joinBaseExt {base="\\c\\a\\b",ext=SOME "foo.bar"}
	   andalso "\\c\\a\\b.foo" = joinBaseExt {base = "\\c\\a\\b", ext = SOME "foo"});

  val test17 = 
    check'(fn _ => 
	   ext "" = NONE
	   andalso ext ".login" = NONE
	   andalso ext "\\.login" = NONE
	   andalso ext "a" = NONE
	   andalso ext "a." = NONE
	   andalso ext "a.b" = SOME "b"
	   andalso ext "a.b.c" = SOME "c"
	   andalso ext "a.b.c.d" = SOME "d"
	   andalso ext "\\a.b" = SOME "b"
	   andalso ext "\\c\\a.b" = SOME "b"
	   andalso ext "\\c\\a\\b\\.d" = NONE
	   andalso ext "\\c.a\\b.d" = SOME "d"
	   andalso ext "\\c.a\\bd" = NONE
	   andalso ext "\\c\\a\\b.foo.bar" = SOME "bar"
	   andalso ext "\\c\\a\\b.foo" = SOME "foo");

  val test18 = 
    check'(fn _ => 
	   base "" = ""
	   andalso base ".d" = ".d"
	   andalso base ".login" = ".login"
	   andalso base "\\.login" = "\\.login"
	   andalso base "a" = "a"
	   andalso base "a." = "a."
	   andalso base "a.b" = "a"
	   andalso base "a.b.c" = "a.b" 
	   andalso base "a.b.c.d" = "a.b.c"
	   andalso base "\\a.b" = "\\a"
	   andalso base "\\c\\a.b" = "\\c\\a"
	   andalso base "\\c\\a\\b\\.d" = "\\c\\a\\b\\.d"
	   andalso base "\\c.a\\b.d" = "\\c.a\\b"
	   andalso base "\\c.a\\bd" = "\\c.a\\bd"
	   andalso base "\\c\\a\\b.foo.bar" = "\\c\\a\\b.foo"
	   andalso base "\\c\\a\\b.foo" = "\\c\\a\\b");

  val test19 = 
    check'(fn () => validVolume{isAbs=false, vol=""}
	   andalso validVolume{isAbs=true, vol=""}
	   andalso validVolume{isAbs=true, vol="C:"}
	   andalso validVolume{isAbs=false, vol="C:"}
	   andalso not (validVolume{isAbs=true, vol="\\"}
			orelse validVolume{isAbs=false, vol="\\"} 
			orelse validVolume{isAbs=true, vol=" "}
			orelse validVolume{isAbs=false, vol=" "})); 

  val toUnixPath_a = toUnixPath"" = ""

  val toUnixPath_b = toUnixPath"/" = "/"

  val toUnixPath_c = toUnixPath"." = "."

  val toUnixPath_d = toUnixPath"foo" = "foo"

  val toUnixPath_e = toUnixPath".." = ".."

  val toUnixPath_f = toUnixPath"\\" = "/"

  val toUnixPath_g = toUnixPath"\\foo" = "/foo"

  val toUnixPath_h = toUnixPath"c:\\foo" = "c:/foo"

  val toUnixPath_i = toUnixPath"\\foo\\bar" = "/foo/bar"

  val toUnixPath_j = toUnixPath"bar\\foo" = "bar/foo"

  val toUnixPath_g = toUnixPath"c:bar\\foo" = "c:bar/foo"

  val fromUnixPath_a = fromUnixPath"" = ""

  val fromUnixPath_b = fromUnixPath"/" = "\\"

  val fromUnixPath_c = fromUnixPath"." = "."

  val fromUnixPath_d = fromUnixPath"foo" = "foo"

  val fromUnixPath_e = fromUnixPath".." = ".."

  val fromUnixPath_f = fromUnixPath"/" = "\\"

  val fromUnixPath_g = fromUnixPath"/foo" = "\\foo"

  val fromUnixPath_h = fromUnixPath"c:/foo" = "c:\\foo"

  val fromUnixPath_i = fromUnixPath"/foo/bar" = "\\foo\\bar"

  val fromUnixPath_j = fromUnixPath"bar/foo" = "bar\\foo"

  val fromUnixPath_g = fromUnixPath"c:bar/foo" = "c:bar\\foo"

end
@


1.7
log
@[Bug #30468]
mkAbsolute and mkRelative now takes records arguments rather than tuples
@
text
@d13 4
d141 3
d304 3
@


1.6
log
@[Bug #30323]
Remove use of loadSource, and fix uses of concat to new spec
@
text
@d13 4
d195 4
a198 4
	   mkAbsolute("\\a\\b", "\\c\\d") = "\\a\\b"
	   andalso mkAbsolute("\\", "\\c\\d") = "\\"
	   andalso mkAbsolute("a\\b", "\\c\\d") = "\\c\\d\\a\\b");
  val test7b = (mkAbsolute("a", "c\\d") seq "WRONG")
d200 1
a200 1
  val test7c = (mkAbsolute("\\a", "c\\d") seq "WRONG")
d205 15
a219 15
	   mkRelative("a\\b", "\\c\\d") = "a\\b"
	   andalso mkRelative("\\", "\\a\\b\\c")	   = "..\\..\\.." 
	   andalso mkRelative("\\a\\", "\\a\\b\\c")	   = "..\\..\\" 
	   andalso mkRelative("\\a\\b\\", "\\a\\c")	   = "..\\b\\"     
	   andalso mkRelative("\\a\\b", "\\a\\c\\")	   = "..\\b"      
	   andalso mkRelative("\\a\\b\\", "\\a\\c\\")	   = "..\\b\\"     
	   andalso mkRelative("\\", "\\")		   = "."	      
	   andalso mkRelative("\\", "\\.")	   = "."	      
	   andalso mkRelative("\\", "\\..")	   = "."	      
	   andalso mkRelative("\\", "\\a")	   = ".."	      
	   andalso mkRelative("\\a\\b\\..\\c", "\\a\\d") = "..\\b\\..\\c" 
	   andalso mkRelative("\\a\\b", "\\c\\d")      = "..\\..\\a\\b"
	   andalso mkRelative("\\c\\a\\b", "\\c\\d")    = "..\\a\\b"
	   andalso mkRelative("\\c\\d\\a\\b", "\\c\\d")  = "a\\b");
  val test8b = (mkRelative("\\a", "c\\d") seq "WRONG")
d221 1
a221 1
  val test8c = (mkRelative("a", "c\\d") seq "WRONG")
@


1.5
log
@[Bug #30323]
Remove unnecessary uses of Shell.Build.loadSource
@
text
@d13 4
a34 6
local
  val _ = Shell.Options.set(Shell.Options.ValuePrinter.maximumStrDepth, 0);
in
  val _ = Shell.Build.loadSource "win_nt.__os_path"
end;

d36 13
a48 13
    open OSPath_
    val dirSeparator = #"\\"
    val extSeparator = #"."
    val parentArc = ".."
    val currentArc = "."
    val volumeSeparator = #":"
    val sep = String.str dirSeparator
    val cur = currentArc
    val par = parentArc

    infix 1 seq
    fun e1 seq e2 = e2;
    fun check' f = (if f () then "OK" else "WRONG") handle _ => "EXN";
d52 1
a52 1
val test1a = 
d54 1
a54 1
val test1b = 
d56 1
a56 1
val test1c = 
d59 1
a59 1
val test1d = 
d61 1
a61 1
val test1e = 
d63 1
a63 1
val test1f = 
d66 1
a66 1
val test1g = 
d69 1
a69 1
val test1h = 
d71 2
a72 2
            = {isAbs=false, vol = "", arcs = ["a", "", ""]});
val test1i = 
d75 1
a75 1
val test1j = 
d78 1
a78 1
val test1k = 
d81 1
a81 1
val test1l = 
d84 1
a84 1
val test1m = 
d87 1
a87 1
val test1n = 
d90 1
a90 5




val test2a =
d92 1
a92 1
val test2b = 
d94 1
a94 1
val test2c = 
d97 1
a97 1
val test2d = 
d99 1
a99 1
val test2e = 
d101 1
a101 1
val test2f = 
d104 1
a104 1
val test2g = 
d106 1
a106 1
val test2h = 
d109 1
a109 1
val test2i = 
d112 1
a112 1
val test2j = 
d115 1
a115 1
val test2k = 
d118 1
a118 1
val test2l = 
d121 1
a121 1
val test2m = 
d124 1
a124 1
val test2n = 
d127 3
a129 3
val test2o = (toString {isAbs=false, vol = "", arcs =  ["", "a"]} seq "WRONG")
             handle Path => "OK" | _ => "WRONG";
val test2p = 
d131 2
a132 2
   (toString {isAbs=true, vol = "C:", arcs =  ["windows"]} 
    = "C:"^sep^"windows"));
d134 1
a134 5




val test3b = 
d136 1
a136 1
val test3c = 
d138 1
a138 1
val test3d = 
d140 1
a140 1
val test3e = 
d142 1
a142 1
val test3f = 
d144 1
a144 1
val test3g = 
d146 1
a146 1
val test3h = 
d149 1
a149 5




val test4a = 
d153 1
a153 1
val test4b = 
d158 1
a158 2

val test5a = 
d174 1
a174 1
val test6a = 
d176 12
a187 12
	   concat("a", "b") = "a\\b"
	   andalso concat("a", "b\\c") = "a\\b\\c"
	   andalso concat("\\", "b\\c") = "\\\\b\\c"
	   andalso concat("", "b\\c") = "b\\c"
	   andalso concat("\\a", "b\\c") = "\\a\\b\\c"
	   andalso concat("a\\", "b\\c") = "a\\\\b\\c"
	   andalso concat("a\\\\", "b\\c") = "a\\\\\\b\\c"
	   andalso concat(".", "b\\c") = ".\\b\\c"
	   andalso concat("a\\b", "..") = "a\\b\\.."
	   andalso concat("a\\b", "..\\c") = "a\\b\\..\\c");
val test6b = (concat ("a", "\\b") seq "WRONG")
             handle Path => "OK" | _ => "WRONG";
d189 1
a189 2

val test7a = 
d194 4
a197 5
val test7b = (mkAbsolute("a", "c\\d") seq "WRONG")
             handle Path => "OK" | _ => "WRONG";
val test7c = (mkAbsolute("\\a", "c\\d") seq "WRONG")
              handle Path => "OK" | _ => "WRONG";

d199 1
a199 1
val test8a = 
d202 1
a202 1
	  andalso mkRelative("\\", "\\a\\b\\c")	   = "..\\..\\.." 
d215 11
a225 12
val test8b = (mkRelative("\\a", "c\\d") seq "WRONG")
              handle Path => "OK" | _ => "WRONG";
val test8c = (mkRelative("a", "c\\d") seq "WRONG")
              handle Path => "OK" | _ => "WRONG";



val test9a = let
    fun chkCanon (a, b) =
	  (mkCanonical a = b) 
	  andalso (mkCanonical b = b)
	  andalso (isCanonical b)
d228 24
a251 24
	   chkCanon("", ".")
	   andalso chkCanon(".", ".")
	   andalso chkCanon(".\\.", ".")
	   andalso chkCanon("\\.", "\\")
	   andalso chkCanon("..", "..")
	   andalso chkCanon("..\\..", "..\\..")
	   andalso chkCanon("b", "b")
	   andalso chkCanon("a\\b", "a\\b")
	   andalso chkCanon("\\a\\b", "\\a\\b")
	   andalso chkCanon("a\\b\\", "a\\b")
	   andalso chkCanon("a\\b\\\\", "a\\b")
	   andalso chkCanon("a\\..\\b", "b")
	   andalso chkCanon("a\\..", ".")
	   andalso chkCanon("a\\.", "a")
	   andalso chkCanon("a\\", "a")
	   andalso chkCanon("\\a\\..\\b\\", "\\b")
	   andalso chkCanon("\\..", "\\")
	   andalso chkCanon("\\..\\..\\a\\b", "\\a\\b")
	   andalso chkCanon("\\.\\..\\..\\a\\b", "\\a\\b")
	   andalso chkCanon("\\.\\..\\..", "\\")
	   andalso chkCanon("a\\..\\b", "b")
	   andalso chkCanon("a\\.\\b", "a\\b")
	   andalso chkCanon("a\\\\\\\\b", "a\\b")
           andalso chkCanon("a\\\\\\\\b", "a\\b"))
d254 1
a254 1
val test10a = 
d265 2
a266 2
		
val test11a = 
d280 2
a281 7

(*    
val test11b = (splitDirFile "" seq "WRONG") 
              handle Path => "OK" | _ => "WRONG";
*)

val test12 = 
d294 1
a294 1
val test13 = 
d306 1
a306 1
val test14 = 
d318 1
a318 1
val test15 = 
d335 1
a335 1
val test16 = 
d350 1
a350 1
val test17 = 
d368 1
a368 1
val test18 = 
d387 1
a387 1
val test19 = 
d397 1
a397 1
val toUnixPath_a = toUnixPath"" = ""
d399 1
a399 1
val toUnixPath_b = toUnixPath"/" = "/"
d401 1
a401 1
val toUnixPath_c = toUnixPath"." = "."
d403 1
a403 1
val toUnixPath_d = toUnixPath"foo" = "foo"
d405 1
a405 1
val toUnixPath_e = toUnixPath".." = ".."
d407 1
a407 1
val toUnixPath_f = toUnixPath"\\" = "/"
d409 1
a409 1
val toUnixPath_g = toUnixPath"\\foo" = "/foo"
d411 1
a411 1
val toUnixPath_h = toUnixPath"c:\\foo" = "c:/foo"
d413 1
a413 1
val toUnixPath_i = toUnixPath"\\foo\\bar" = "/foo/bar"
d415 1
a415 1
val toUnixPath_j = toUnixPath"bar\\foo" = "bar/foo"
d417 1
a417 1
val toUnixPath_g = toUnixPath"c:bar\\foo" = "c:bar/foo"
d419 1
a419 1
val fromUnixPath_a = fromUnixPath"" = ""
d421 1
a421 1
val fromUnixPath_b = fromUnixPath"/" = "\\"
d423 1
a423 1
val fromUnixPath_c = fromUnixPath"." = "."
d425 1
a425 1
val fromUnixPath_d = fromUnixPath"foo" = "foo"
d427 1
a427 1
val fromUnixPath_e = fromUnixPath".." = ".."
d429 1
a429 1
val fromUnixPath_f = fromUnixPath"/" = "\\"
d431 1
a431 1
val fromUnixPath_g = fromUnixPath"/foo" = "\\foo"
d433 1
a433 1
val fromUnixPath_h = fromUnixPath"c:/foo" = "c:\\foo"
d435 1
a435 1
val fromUnixPath_i = fromUnixPath"/foo/bar" = "\\foo\\bar"
d437 1
a437 1
val fromUnixPath_j = fromUnixPath"bar/foo" = "bar\\foo"
d439 1
a439 1
val fromUnixPath_g = fromUnixPath"c:bar/foo" = "c:bar\\foo"
@


1.4
log
@[Bug #30245]
Fix problems with basis structures changing
@
text
@d13 4
d34 1
a34 5
  val _ = 
    (Shell.Build.loadSource "basis.__list";
     Shell.Build.loadSource "basis.__string";
     Shell.Build.loadSource "basis.__char";
     Shell.Build.loadSource "win_nt.__os_path")
@


1.3
log
@[Bug #1939]
Add tests for toUnixPath and fromUnixPath
@
text
@d13 4
d27 9
a35 6
Shell.Build.loadSource "basis.__list";
Shell.Build.loadSource "basis.__string";
Shell.Build.loadSource "basis.os_path";
Shell.Build.loadSource "basis.__char";
Shell.Build.loadSource "win_nt.__os_path";

a50 2


@


1.3.1.1
log
@branched from 1.3
@
text
@a12 4
 *  Revision 1.3  1997/03/05  17:20:06  jont
 *  [Bug #1939]
 *  Add tests for toUnixPath and fromUnixPath
 *
@


1.3.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 *  Revision 1.3.1.1  1997/05/12  11:08:25  hope
 *  branched from 1.3
 *
@


1.3.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 *  Revision 1.3.1.1  1997/05/12  11:08:25  hope
 *  branched from 1.3
 *
@


1.3.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 *  Revision 1.3.1.1  1997/05/12  11:08:25  hope
 *  branched from 1.3
 *
@


1.3.1.1.1.2
log
@[Bug #30086]
[Bug #30245]
Merging - Fix problems with basis structures changing
@
text
@a12 3
 *  Revision 1.3.1.1.1.1  1997/07/28  18:50:26  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d30 6
a35 9
local
  val _ = Shell.Options.set(Shell.Options.ValuePrinter.maximumStrDepth, 0);
in
  val _ = 
    (Shell.Build.loadSource "basis.__list";
     Shell.Build.loadSource "basis.__string";
     Shell.Build.loadSource "basis.__char";
     Shell.Build.loadSource "win_nt.__os_path")
end;
d51 2
@


1.3.1.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 5
 *  Revision 1.3.1.1.1.2  1997/08/12  09:37:58  johnh
 *  [Bug #30086]
 *  [Bug #30245]
 *  Merging - Fix problems with basis structures changing
 *
@


1.2
log
@Remove references to toplevel
@
text
@d13 3
d414 45
@


1.2.4.1
log
@branched from 1.2
@
text
@a12 3
 *  Revision 1.2  1996/10/22  13:24:57  jont
 *  Remove references to toplevel
 *
@


1.2.3.1
log
@branched from 1.2
@
text
@a12 3
 *  Revision 1.2  1996/10/22  13:24:57  jont
 *  Remove references to toplevel
 *
@


1.2.3.1.1.1
log
@branched from 1.2.3.1
@
text
@a12 3
 *  Revision 1.2.3.1  1996/12/17  18:14:49  hope
 *  branched from 1.2
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@a12 3
 *  Revision 1.2  1996/10/22  13:24:57  jont
 *  Remove references to toplevel
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a12 3
 *  Revision 1.2  1996/10/22  13:24:57  jont
 *  Remove references to toplevel
 *
@


1.2.1.1.1.1
log
@branched from 1.2.1.1
@
text
@a12 3
 *  Revision 1.2.1.1  1996/11/14  13:18:04  hope
 *  branched from 1.2
 *
@


1.1
log
@new unit
Test file for win_nt/__os_path.sml
@
text
@d12 5
a16 1
 * $Log:$
a19 1
Shell.Build.loadSource "basis.toplevel";
@


1.1.3.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 * $Log: win32:os_path.sml,v $
 *  Revision 1.1  1996/06/20  11:32:09  andreww
 *  new unit
 *  Test file for win_nt/__os_path.sml
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 * $Log: win32:os_path.sml,v $
 *  Revision 1.1  1996/06/20  11:32:09  andreww
 *  new unit
 *  Test file for win_nt/__os_path.sml
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 * $Log: win32:os_path.sml,v $
 *  Revision 1.1  1996/06/20  11:32:09  andreww
 *  new unit
 *  Test file for win_nt/__os_path.sml
 *
@
