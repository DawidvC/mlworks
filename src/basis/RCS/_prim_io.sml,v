head	1.6;
access;
symbols
	MLW_daveb_inline_1_4_99:1.6.1
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.5
	MLWorks_20c0_1998_08_04:1.5
	MLWorks_20b2c2_1998_06_19:1.5
	MLWorks_20b2_Windows_1998_06_12:1.5
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.4
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.4.5.1.1.1.1
	MLWorks_workspace_97:1.4.7
	MLWorks_dt_wizard:1.4.6
	MLWorks_11c0_1997_09_09:1.4.5.1.1.1
	MLWorks_10r3:1.4.5.1.3
	MLWorks_10r2_551:1.4.5.1.2
	MLWorks_11:1.4.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.4.5.1
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.4.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.4.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.4.5
	MLWorks_BugFix_1997_04_24:1.4
	MLWorks_1_0_r2_Win32_1997_04_11:1.4
	MLWorks_1_0_r2_Unix_1997_04_04:1.4
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.3.1.1
	MLWorks_gui_1996_12_18:1.4.4
	MLWorks_1_0_Win32_1996_12_17:1.4.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.4.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.4.1.1
	MLWorks_1_0_Irix_1996_11_28:1.4.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.2
	MLWorks_1_0_Unix_1996_11_14:1.4.1
	MLWorks_Open_Beta2_1996_10_11:1.3.2
	MLWorks_License_dev:1.3.1
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2;
locks; strict;
comment	@ *  @;


1.6
date	99.03.20.21.44.16;	author daveb;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	98.02.19.16.19.24;	author mitchell;	state Exp;
branches;
next	1.4;

1.4
date	96.11.08.14.19.33;	author matthew;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1
	1.4.4.1
	1.4.5.1
	1.4.6.1
	1.4.7.1;
next	1.3;

1.3
date	96.10.03.15.11.00;	author io;	state Exp;
branches
	1.3.1.1
	1.3.2.1;
next	1.2;

1.2
date	96.08.14.09.46.00;	author andreww;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	96.07.17.17.17.01;	author andreww;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.10.02;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.10.07.16.00.54;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.10.17.11.19.09;	author hope;	state Exp;
branches;
next	;

1.4.1.1
date	96.11.14.12.42.41;	author hope;	state Exp;
branches
	1.4.1.1.1.1;
next	;

1.4.1.1.1.1
date	96.11.28.14.54.34;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.11.22.18.03.10;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.12.17.17.42.05;	author hope;	state Exp;
branches
	1.4.3.1.1.1;
next	;

1.4.3.1.1.1
date	97.02.24.11.30.29;	author hope;	state Exp;
branches;
next	;

1.4.4.1
date	96.12.18.09.36.03;	author hope;	state Exp;
branches;
next	;

1.4.5.1
date	97.05.12.10.28.10;	author hope;	state Exp;
branches
	1.4.5.1.1.1
	1.4.5.1.2.1
	1.4.5.1.3.1;
next	;

1.4.5.1.1.1
date	97.07.28.18.13.28;	author daveb;	state Exp;
branches
	1.4.5.1.1.1.1.1;
next	;

1.4.5.1.1.1.1.1
date	97.10.07.11.38.37;	author jkbrook;	state Exp;
branches;
next	;

1.4.5.1.2.1
date	97.09.08.17.06.49;	author daveb;	state Exp;
branches;
next	;

1.4.5.1.3.1
date	97.09.09.14.02.11;	author daveb;	state Exp;
branches;
next	;

1.4.6.1
date	97.09.10.19.16.37;	author brucem;	state Exp;
branches;
next	;

1.4.7.1
date	97.09.11.20.46.44;	author daveb;	state Exp;
branches;
next	;

1.6.1.1
date	99.04.01.17.51.46;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
[Bug 1453] updated (and renamed) version of _primio.sml
@


1.6
log
@[Bug #20125]
Replaced substructure with type.
@
text
@(*  ==== INITIAL BASIS : primio functor ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: _prim_io.sml,v $
 *  Revision 1.5  1998/02/19  16:19:24  mitchell
 *  [Bug #30349]
 *  Fix to avoid non-unit sequence warnings
 *
 *  Revision 1.4  1996/11/08  14:19:33  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
 *  Revision 1.3  1996/10/03  15:11:00  io
 *  [Bug #1614]
 *  remove redundant requires
 *
 *  Revision 1.2  1996/08/14  09:46:00  andreww
 *  [Bug #1537]
 *  adjusting augment reader/writer routines to propagate io descriptors
 *
 *  Revision 1.1  1996/07/17  17:17:01  andreww
 *  new unit
 *  [Bug 1453] updated (and renamed) version of _primio.sml
 *
 * Revision 1.5  1996/05/22  09:31:19  matthew
 * Fixing merge problem in last revision
 *
 * Revision 1.4  1996/05/22  09:15:13  matthew
 * Vector changes
 *
 * Revision 1.3  1996/05/20  12:11:10  jont
 * signature changes
 *
 * Revision 1.2  1996/05/15  13:20:04  jont
 * pack_words moved to pack_word
 *
 * Revision 1.1  1996/04/18  11:38:38  jont
 * new unit
 *
 *  Revision 1.2  1995/05/10  14:00:21  daveb
 *  Characters are no longer integers.
 *  Removed definitions of BinPrimIO and TextPrimIO.
 *
 *  Revision 1.1  1995/04/13  13:39:08  jont
 *  new unit
 *  No reason given
 *
 *
 *)

require "../system/__os";
require "mono_vector";
require "mono_array";
require "prim_io";

functor PrimIO(include sig
                 structure A : MONO_ARRAY
                 structure V : MONO_VECTOR
               end sharing type A.vector = V.vector
                       and type A.elem = V.elem
	       val someElem : A.elem
	       type pos
	       val compare : pos * pos -> order) : PRIM_IO =
  struct
    type elem = A.elem
    type vector = V.vector
    type array = A.array
    type pos = pos

    val compare = compare

    type 'a portion = {buf: 'a, i: int, sz: int option}

    datatype reader = RD of 
              {readVecNB : (int -> vector option) option,
               readArrNB: (array portion -> int option) option,
               readVec :   (int -> vector) option,
               readArr:   (array portion -> int) option,
               block      : (unit -> unit) option,
               canInput  : (unit -> bool) option,
               avail     : unit -> int option,
               name       : string,
               chunkSize  : int,
               close      : unit -> unit,
               getPos     : (unit -> pos) option,
               setPos     : (pos -> unit) option,
               endPos     : (unit -> pos) option,
               verifyPos  : (unit -> pos) option,
	       ioDesc : OS.IO.iodesc option}

    datatype writer = WR of 
              {writeVecNB: (vector portion -> int option) option,
               writeArrNB: (array portion -> int option) option,
               writeVec: (vector portion -> int) option,
               writeArr: (array portion -> int) option,
               block: (unit->unit) option,
               canOutput: (unit->bool) option,
               name: string,
               chunkSize: int,
               close: unit -> unit,
               getPos : (unit->pos) option,
               setPos : (pos->unit) option,
               endPos : (unit->pos) option,
               verifyPos : (unit -> pos) option,
	       ioDesc : OS.IO.iodesc option}

    fun noOption convert f x = 
      case convert f x
        of SOME result => result
         | NONE => raise Fail "bug in PrimIO"

    fun blockingOperation(readaNoBlock,block) = 
	     SOME(fn x => 
		  (ignore(block()); 
		   case readaNoBlock x 
		     of SOME r => r
		      | NONE => raise Fail "unexpected blocking operation"))


    fun augmentReader (r as RD r') =
      let
	fun readaToReadv reada i =
	  let
	    val a = A.array(i,someElem)
	  in case reada{buf=a,i=0,sz=SOME i}
	    of SOME i' => SOME(A.extract(a,0,SOME i'))
	  | NONE => NONE  
	  end

	fun readvToReada readv{buf: array, i: int, sz: int option} =
	  let
	    val nelems = case sz of
	      SOME i => i
	    | NONE => A.length buf - i
	    val first = i
	    val data = buf
	  in
	    case readv nelems of
	      SOME v => SOME(let val len = V.length v
				 fun loop i = 
				   if i >= len then len
				   else (A.update(data,i+first,V.sub(v,i));
					 loop(i+1))
			     in loop 0
			     end)
	    | NONE => NONE
	  end

	val readBlock' = 
          case r
	    of RD{readVec=SOME f,...} => SOME f
	  | RD{readArr=SOME f,...} => SOME(noOption readaToReadv (SOME o f))
	  | RD{readVecNB=SOME f,block=SOME b,...} =>
	      SOME(fn i => (b(); noOption (fn x=>x) f i))
	  | RD{readArrNB=SOME f, block=SOME b,...} =>
	      SOME(fn x => (b(); noOption readaToReadv f x))
	  | _ => NONE

	val readaBlock' = 
          case r
	    of RD{readArr=SOME f,...} => SOME f
	  | RD{readVec=SOME f,...} => SOME(noOption readvToReada (SOME o f))
	  | RD{readArrNB=SOME f, block=SOME b,...} =>
	      blockingOperation(f,b)
	  | RD{readVecNB=SOME f,block=SOME b,...} =>
	      blockingOperation(readvToReada f, b)
	  | _ => NONE

	val readNoBlock' =
	  case r
	    of RD{readVecNB=SOME f,...} => SOME f
	  | RD{readArrNB=SOME f,...} => SOME(readaToReadv f)
	  | RD{readVec=SOME f, canInput=SOME can,...} =>
	      SOME(fn i => if can()
			     then SOME(f i) else NONE)

	  | RD{readArr=SOME f, canInput=SOME can,...} =>
	      SOME(fn i => if can()
			     then readaToReadv (SOME o f) i else NONE)
	  | _ => NONE

        val readaNoBlock' =
	  case r
	    of RD{readArrNB=SOME f,...} => SOME f
	  | RD{readVecNB=SOME f,...} => SOME(readvToReada f)
	  | RD{readArr=SOME f, canInput=SOME can,...} =>
	      SOME(fn x => if can()
			     then SOME(f x) else NONE)
	  | RD{readVec=SOME f, canInput=SOME can,...} =>
	      SOME(fn x => if can()
			     then readvToReada (SOME o f) x else NONE)
	  | _ => NONE

      in RD{readVec=readBlock', readArr=readaBlock',
	    readVecNB=readNoBlock', readArrNB=readaNoBlock',
	    block= #block r', canInput = #canInput r',
            avail = #avail r',
	    name= #name r', chunkSize= #chunkSize r',
	    close= #close r', getPos = #getPos r', 
	    setPos = #setPos r', endPos = #endPos r',
            verifyPos = #verifyPos r',
	    ioDesc= #ioDesc r'}
      end

    fun augmentWriter (r as WR r') =
      let
	fun writevToWritea writev {buf,i,sz} =
	  let
	    val data = buf
	    val first = i
	    val nelems = case sz of
	      SOME i => i
	    | NONE => A.length buf - i
	    val v = A.extract(data,first,SOME nelems)
	  in
	    writev{buf=v,i=0,sz=SOME nelems}
	  end
	fun writeaToWritev writea {buf,i,sz=SOME 0} = SOME 0
	  | writeaToWritev writea {buf,i,sz} =
	    let
	      val nelems = case sz of
		SOME i => i
	      | NONE => V.length buf - i
	      val first = i
	      val data = buf
	      val a = A.array(nelems,V.sub(data,first))
	      fun loop i = if i >= nelems then  ()
			   else (A.update(a,i,V.sub(data,first+i));
				 loop(i+1))
	    in loop 1; writea{buf=a,i=0,sz=SOME nelems}
	    end

	val writeBlock' =
          case r
	    of WR{writeVec=SOME f,...} => SOME f
	  | WR{writeArr=SOME f,...} => 
	      SOME(noOption writeaToWritev (SOME o f))
	  | WR{writeVecNB=SOME f,block=SOME b,...} =>
	      SOME(fn i => (b(); noOption (fn x=>x) f i))
	  | WR{writeArrNB=SOME f, block=SOME b,...} =>
	      SOME(fn x => (b(); noOption writeaToWritev f x))
	  | _ => NONE

	val writeaBlock' = 
          case r
	    of WR{writeArr=SOME f,...} => SOME f
	  | WR{writeVec=SOME f,...} => 
	      SOME(noOption writevToWritea (SOME o f))
	  | WR{writeArrNB=SOME f, block=SOME b,...} =>
	      blockingOperation(f,b)
	  | WR{writeVecNB=SOME f,block=SOME b,...} =>
	      blockingOperation(writevToWritea f, b)
	  | _ => NONE

	val writeNoBlock' =
	  case r
	    of WR{writeVecNB=SOME f,...} => SOME f
	  | WR{writeArrNB=SOME f,...} => SOME(writeaToWritev f)
	  | WR{writeVec=SOME f, canOutput=SOME can,...} =>
	      SOME(fn i => if can()
			     then SOME(f i) else NONE)
	     
	  | WR{writeArr=SOME f, canOutput=SOME can,...} =>
	      SOME(fn i => if can()
			     then writeaToWritev (SOME o f) i else NONE)
	  | _ => NONE

	val writeaNoBlock' =
	  case r
	    of WR{writeArrNB=SOME f,...} => SOME f
	  | WR{writeVecNB=SOME f,...} => SOME(writevToWritea f)
	  | WR{writeArr=SOME f, canOutput=SOME can,...} =>
	      SOME(fn x => if can() then SOME(f x) else NONE)
	  | WR{writeVec=SOME f, canOutput=SOME can,...} =>
	      SOME(fn x => if can() 
			     then SOME(writevToWritea f x) else NONE)
	  | _ => NONE

      in WR{writeVec=writeBlock', writeArr=writeaBlock',
	    writeVecNB=writeNoBlock', writeArrNB=writeaNoBlock',
	    block= #block r', canOutput = #canOutput r',
	    name= #name r', chunkSize= #chunkSize r',
	    close= #close r', getPos = #getPos r', 
	    setPos = #setPos r', endPos = #endPos r',
            verifyPos = #verifyPos r',
	    ioDesc= #ioDesc r'}
      end

  end
@


1.6.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 4
 *  Revision 1.6  1999/03/20  21:44:16  daveb
 *  [Bug #20125]
 *  Replaced substructure with type.
 *
@


1.5
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d10 4
d64 1
a64 1
               end sharing type A.Vector.vector = V.vector
a69 1
    structure V = A.Vector
@


1.4
log
@[Bug #1661]
Changing io_desc to iodesc
@
text
@d10 4
d116 1
a116 1
		  (block(); 
@


1.4.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 4
 *  Revision 1.4  1996/11/08  14:19:33  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.4.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 4
 *  Revision 1.4  1996/11/08  14:19:33  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.4.5.1
log
@branched from 1.4
@
text
@a9 4
 *  Revision 1.4  1996/11/08  14:19:33  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.4.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 *  Revision 1.4.5.1  1997/05/12  10:28:10  hope
 *  branched from 1.4
 *
@


1.4.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 *  Revision 1.4.5.1  1997/05/12  10:28:10  hope
 *  branched from 1.4
 *
@


1.4.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 *  Revision 1.4.5.1  1997/05/12  10:28:10  hope
 *  branched from 1.4
 *
@


1.4.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 3
 *  Revision 1.4.5.1.1.1  1997/07/28  18:13:28  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.4.4.1
log
@branched from 1.4
@
text
@a9 4
 *  Revision 1.4  1996/11/08  14:19:33  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.4.3.1
log
@branched from 1.4
@
text
@a9 4
 *  Revision 1.4  1996/11/08  14:19:33  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.4.3.1.1.1
log
@branched from 1.4.3.1
@
text
@a9 3
 *  Revision 1.4.3.1  1996/12/17  17:42:05  hope
 *  branched from 1.4
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a9 4
 *  Revision 1.4  1996/11/08  14:19:33  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a9 4
 *  Revision 1.4  1996/11/08  14:19:33  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.4.1.1.1.1
log
@branched from 1.4.1.1
@
text
@a9 3
 *  Revision 1.4.1.1  1996/11/14  12:42:41  hope
 *  branched from 1.4
 *
@


1.3
log
@[Bug #1614]
remove redundant requires
@
text
@d10 4
d87 1
a87 1
	       ioDesc : OS.IO.io_desc option}
d103 1
a103 1
	       ioDesc : OS.IO.io_desc option}
@


1.3.2.1
log
@branched from 1.3
@
text
@a9 4
 *  Revision 1.3  1996/10/03  15:11:00  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a9 4
 *  Revision 1.3  1996/10/03  15:11:00  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.2
log
@[Bug #1537]
adjusting augment reader/writer routines to propagate io descriptors
@
text
@d10 4
a43 8
require "toplevel";
require "__word8";
require "__word8array";
require "__word8vector";
require "__char";
require "__chararray";
require "__charvector";
require "__position";
@


1.2.1.1
log
@branched from 1.2
@
text
@a9 4
 *  Revision 1.2  1996/08/14  09:46:00  andreww
 *  [Bug #1537]
 *  adjusting augment reader/writer routines to propagate io descriptors
 *
@


1.1
log
@new unit
[Bug 1453] updated (and renamed) version of _primio.sml
@
text
@d9 5
a13 1
 *  $Log: _primio.sml,v $
d200 1
a200 1
	    ioDesc=NONE}
d284 1
a284 1
	    ioDesc=NONE}
@
