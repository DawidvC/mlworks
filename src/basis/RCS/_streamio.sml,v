head	1.11;
access;
symbols
	MLWorks_Beta_1996_07_02:1.11
	MLWorks_Beta_1996_06_07:1.9
	MLWorks_Beta_1996_06_06:1.9
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.6
	MLWorks_Beta_1996_05_31:1.6
	MLWorks_Beta_1996_05_30:1.6;
locks; strict;
comment	@ * @;


1.11
date	96.06.28.14.02.47;	author andreww;	state Exp;
branches;
next	1.10;

1.10
date	96.06.11.10.08.08;	author andreww;	state Exp;
branches;
next	1.9;

1.9
date	96.06.06.12.50.03;	author andreww;	state Exp;
branches;
next	1.8;

1.8
date	96.06.04.15.46.03;	author andreww;	state Exp;
branches;
next	1.7;

1.7
date	96.06.03.12.56.52;	author andreww;	state Exp;
branches;
next	1.6;

1.6
date	96.05.22.09.34.05;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	96.05.22.09.15.20;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	96.05.20.14.16.10;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.05.15.13.10.18;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.04.23.11.33.46;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.11.38.43;	author jont;	state Exp;
branches;
next	;


desc
@new unit
@


1.11
log
@ensure that output and output1 raise an exception when outputting to
terminated streams.
@
text
@(*  ==== INITIAL BASIS : streamio functor ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: _streamio.sml,v $
 * Revision 1.10  1996/06/11  10:08:08  andreww
 * Ensure outstreams are flushed before closing,
 * and that flushing closed outstreams is a no-op
 *
 * Revision 1.9  1996/06/06  12:50:03  andreww
 * Implementing closeIn, and correcting endOfStream,
 *
 * Revision 1.8  1996/06/04  15:46:03  andreww
 * debug so that input <streamname> always returns the same info
 * (i.e., not imperative input).
 *
 * Revision 1.7  1996/06/03  12:56:52  andreww
 * modifying functor argument (in line with definition).
 *
 * Revision 1.6  1996/05/22  09:34:05  matthew
 * Fixing merge problem
 *
 * Revision 1.5  1996/05/22  09:15:20  matthew
 * New Vectors
 *
 * Revision 1.4  1996/05/20  14:16:10  jont
 * signature changes
 *
 * Revision 1.3  1996/05/15  13:10:18  jont
 * pack_words moved to pack_word
 *
 * Revision 1.2  1996/04/23  11:33:46  matthew
 * Integer is now Int
 *
 * Revision 1.1  1996/04/18  11:38:43  jont
 * new unit
 *
 *  Revision 1.3  1995/05/16  14:32:37  daveb
 *  Replaced copy function with a call to Arr.copyv.
 *  Removed redundant structure definition.
 *
 *  Revision 1.1  1995/04/13  13:41:03  jont
 *  new unit
 *  No reason given
 *
 *
 *)

require "toplevel";
require "mono_array";
require "mono_vector";
require "__integer";
require "__io";
require "prim_io";
require "stream_io";

exception Io of {name: string,
                 function: string,
                 cause: exn}

exception BlockingNotSupported
exception NonBlockingNotSupported
exception TerminatedStream
exception ClosedStream;

functor StreamIO(structure PrimIO : PRIM_IO
                 structure Vector : MONO_VECTOR
                 structure Array: MONO_ARRAY
                 val someElem : PrimIO.elem
               sharing type PrimIO.vector=Array.Vector.vector=Vector.vector
               sharing type PrimIO.array=Array.array
               sharing type Array.elem = PrimIO.elem = Vector.elem
                 ) : STREAM_IO =
 struct
    structure PrimIO=PrimIO
    type elem = PrimIO.elem
    type Array = PrimIO.array
    type vector = PrimIO.vector
    type pos = PrimIO.pos


    type reader = PrimIO.reader
    type writer = PrimIO.writer

    datatype buffer = Buf of {
	more     : more ref,
        data     : vector,
	basePos  : pos,
	emptyMeansEof: bool,
	name : string
      }				

    and more = GETmore of PrimIO.reader
             | ISmore of buffer
             | NOmore

    and instream = In of {
        pos      : int,
        buffer   : buffer}


  (* NOTE: I haven't implemented check to ensure blocking reads are possible.*)

    val empty = Vector.fromList[]

    fun mkInstream(r, v) = 
	let
	  val r' as PrimIO.RD{name,getPos,...} = PrimIO.augmentReader r
	in In{pos=0, 
	      buffer=Buf{name=name,
			 emptyMeansEof=false,
			 data=v,
			 more = ref(GETmore r'),
			 basePos=getPos()}}
	end

    fun handler(Buf{name,...},function,e) = 
	     raise Io{function=function,name=name,cause=e}

    fun closeBuf (Buf{more=ref NOmore,...}) = ()
      | closeBuf (Buf{more=ref(ISmore buf),...}) = closeBuf buf
      | closeBuf (b as Buf{more as ref(GETmore(PrimIO.RD{close,...})),...}) =
	    (close() handle e => handler(b,"closeIn",e); 
	     more := NOmore)

    fun closeIn (In{buffer,...}) = closeBuf buffer


    exception WouldBlock  (* not to be raised out of this module *)

    fun filbuf (doRead: PrimIO.reader -> vector, mlOp: string) 
	       (buffer as Buf{data,more,emptyMeansEof,name,basePos})=
         let val len = Vector.length data
         in if len = 0 andalso emptyMeansEof
              then {eof=true, 
                    rest=Buf{data=empty,more=more,name=name,
                             emptyMeansEof=false,basePos=basePos}}
            else case !more
                   of ISmore buf' => (*filbuf (doRead,mlOp) buf'*)
                     {eof=false, rest=buf'}
                    | NOmore => {eof=true,
                                 rest=Buf{data=empty,more=more,
                                          emptyMeansEof=true,
                                          name=name,basePos=basePos}}
                    | m as GETmore (gm as PrimIO.RD{getPos,...}) => 
                        (let val basePos' = getPos()
                             val v = doRead gm
                             val buf' = Buf{data=v, more=ref m,
                                            name=name, basePos=basePos',
                                            emptyMeansEof=true}
                        in more := ISmore buf';
                          {eof=false,
                           rest=buf'}         
                        end handle e => handler(buffer,mlOp,e))
         end
       
    fun generalizedInput (filbuf': buffer -> {eof: bool, rest: buffer}) 
	              : instream -> vector * instream =
    let fun get(In{pos,buffer as Buf{data,...}}) =
       let val len = Vector.length data
        in if pos < len
	    then (Vector.extract(data, pos, SOME (len - pos)),
		  In{pos=len,buffer=buffer})
	    else case filbuf' buffer
		  of {eof=true,rest} => (empty,In{pos=0,buffer=rest})
		   | {eof=false,rest} => get (In{pos=0,buffer=rest})
       end
     in get
    end

   fun chunk1 (PrimIO.RD{chunkSize,readVec=SOME read,...}) = read chunkSize
     | chunk1 _ = raise BlockingNotSupported


   fun chunkN n (PrimIO.RD{chunkSize=1,readVec=SOME read,...}) = read n
     | chunkN n (PrimIO.RD{chunkSize=k,readVec=SOME read,...}) =
                      (* round n up to the next multiple of k *)
	               read (((n-1+k) div k) * k)
     | chunkN _ _ = raise BlockingNotSupported

   val eofFilbuf = filbuf (chunk1, "endOfStream")

   fun endOfStream (In{pos,buffer as Buf{data,...}}) =
       if pos < Vector.length data then false
	   else let val {eof,rest=Buf{data,emptyMeansEof,...}}
                        = eofFilbuf buffer
           in eof orelse (emptyMeansEof
                          andalso (Vector.length data = 0))
           end
             

   val input = generalizedInput(filbuf(chunk1, "input"))

 local

(*
   fun bigchunk (arg as PrimIO.RD{getPos,endPos,...}) =
       case posDiff
        of SOME f => (chunkN (Int.max(f{hi=endPos(),lo=getPos()}, 1)) 
		      handle _ => chunk1) 
	             arg
         | NONE => chunk1 arg
*)
   fun bigchunk (arg as PrimIO.RD{getPos,endPos,...}) = chunk1 arg

   val biginput = generalizedInput(filbuf(bigchunk,"inputAll"))
		      
  in
    fun inputAll f =
	(* Try "biginput" the first time.  If that doesn't
	    get everything, treat it as unreliable and unnecessarily
	    expensive, i.e. don't waste time with "endPos" in the
	    rest of the input operations. *)
	let fun loop f = 
	       let val (s,rest) = input f
		in if Vector.length s = 0 then nil else s :: loop rest
               end
	    val (s,rest) = biginput f
         in if Vector.length s = 0 then s else Vector.concat(s :: loop rest)
        end
  end
	     
   local 
       fun nonBlockChunk (PrimIO.RD{chunkSize,readVecNB=SOME read,...})=
		      (case read chunkSize
			of NONE => raise WouldBlock
		         | SOME stuff => stuff)
         | nonBlockChunk _ = raise NonBlockingNotSupported

       val inpNob = generalizedInput (filbuf (nonBlockChunk, "inputNoBlock"))
    in 
      fun inputNoBlock x = SOME(inpNob x) handle WouldBlock => NONE

   end



    val input1Filbuf = filbuf(chunk1, "input1")

    fun input1(In{pos,buffer as Buf{data,...}}) =
      let
	val len = Vector.length data
      in
	if pos < len
	  then SOME(Vector.sub(data,pos), In{pos=pos+1,buffer=buffer})
	else
	  case input1Filbuf buffer of
	    {eof=true,rest} => NONE
	  | {eof=false,rest} => input1(In{pos=0,buffer=rest})
      end

    fun listInputN(In{pos,buffer as Buf{data,...}}, n) =
       let val len = Vector.length data
        in if pos + n <= len
	        then ([Vector.extract(data,pos,SOME n)],
                       In{pos=pos+n,buffer=buffer})
	    else if pos < len
		then let val hd = Vector.extract(data,pos,SOME (len-pos))
		         val (tl,f') = listInputN(In{pos=len,buffer=buffer},
						  n-(len-pos))
		      in (hd::tl,f')
		     end
	    else case filbuf (chunkN n, "inputN") buffer
		  of {eof=true,rest} => (nil,In{pos=0,buffer=rest})
		   | {eof=false,rest} => listInputN(In{pos=0,buffer=rest},n)
       end

    fun inputN(f,n) = 
	let val (vl,f') = listInputN(f,n)
         in (Vector.concat vl, f')
        end

    fun getReader' (Buf{more=ref(NOmore),...}) = raise TerminatedStream
      | getReader' (Buf{more=ref(ISmore b),...}) = getReader' b
      | getReader' (Buf{more=more as ref(GETmore m), data, ...}) = 
        (more:=NOmore;(m, data))                (*truncate Instream*)

    fun getReader(In{pos,buffer}) = 
      getReader' buffer handle e => handler(buffer,"getReader",e)

    fun endPosIn(In{pos,buffer}) =
      let
	val (PrimIO.RD{endPos,...}, _) = getReader' buffer
      in
	endPos()
      end handle e => handler(buffer,"endPosIn",e)


    (* OUTPUT: *)

    datatype outstream = Out of {
        name     : string,
        closed   : bool ref,
        data     : Array,
        pos      : int ref,
        mode     : IO.buffer_mode ref,
        writer   : PrimIO.writer option ref
      }


    fun handler(Out{name,...},function, cause) =
                     raise Io{name=name,function=function,cause=cause}


    fun mkOutstream(w, mode) =
	case PrimIO.augmentWriter w
         of w' as PrimIO.WR{name,chunkSize,...} =>
	Out{name=name,closed=ref false,data=Array.array(chunkSize,someElem), 
            pos=ref 0, writer=ref (SOME w'), mode=ref mode}


    fun flushOut' (Out{data,pos,
			writer=ref(SOME (PrimIO.WR{writeArr=SOME write,...})),
                        ...}) =
       let val p = !pos
	   fun loop i = if i<p 
	        then loop(i+write{buf=data,i=i,sz=SOME(p-i)}
			  handle e => (Array.copy{src=data,si=i,len=SOME (p-i),
						dst=data,di=0};
				       pos := p-i;
				       raise e))
		else ()
	in pos := 0; (* do this first, in case of interrupt *)
	   loop 0
       end      
      | flushOut'(Out{writer=ref NONE,...}) = ()
                                         (* do nothing on terminated stream*)
      | flushOut' _ = raise BlockingNotSupported

    fun flushOut f = flushOut' f
      handle e => handler(f,"flushOut",e)





    fun closeOut(f as Out{closed,
                          writer=w as ref (SOME (PrimIO.WR{close,name,...})),
                          ...})=((flushOut f; w:=NONE; closed:=true; close())
                                  handle e => handler(f,"closeOut",e))
      | closeOut _ = ()    (*file is already closed --- do nothing*)





    fun bigoutput(f as Out{writer=ref (SOME (PrimIO.WR{writeVec=SOME write,...})),
                           ...},
		  buffer as {buf,i=first,sz}) =
      let
	val nelems = case sz of
	  SOME i => i
	| NONE => Vector.length buf - first
      in
	if nelems=0 then ()
	else let val written = write buffer (* may raise exception! *)
	     in bigoutput(f, {buf=buf,i=first+written,
			      sz=SOME(nelems-written)})
	     end
      end
      | bigoutput (Out{name,closed,writer=ref NONE,...},_) = 
           if !closed then raise ClosedStream else raise TerminatedStream
      | bigoutput _ = raise BlockingNotSupported



    fun output(f as Out{closed,writer=w as (ref NONE),...}, _) =
        if !closed then handler(f,"output",ClosedStream)
        else handler(f,"output",TerminatedStream)
      | output(f as Out{data,pos,...}, s)=
     let val slen = Vector.length s
          val blen = Array.length data
          val p = !pos
	  fun copy offset =
	    (Array.copyVec {src=s, si=0, len=SOME slen, dst=data, di=offset};
             pos := offset + slen)
       in if p+slen < blen
           then copy p
           else ((flushOut' f;
		  if slen < blen
		     then copy 0
                     else bigoutput(f,{buf=s,i=0,sz=SOME slen}))
		 handle e => handler(f,"output",e))
      end



    fun output1(f as Out{closed,writer=w as (ref NONE),...},_)=
        if !closed then handler(f,"output1",ClosedStream)
        else handler(f,"output1",TerminatedStream)
      | output1(f as Out{data,pos,...}, e) =
      let val blen = Array.length data
          val p = !pos
       in if p < blen
           then (Array.update(data,p,e); pos := p+1)
           else if p=0
	         then bigoutput(f,{buf=Vector.fromList[e],i=0,sz=SOME 1})
		 else (flushOut' f handle e=> handler(f,"output1",e);
		       output1(f,e))
      end



    fun getWriter(f as Out{closed,writer=ref NONE,...}) =
         if !closed then handler(f,"getWriter",ClosedStream)
         else handler(f,"getWriter",TerminatedStream)
      | getWriter(f as Out{writer=writer as ref (SOME w), mode = ref m, ...}) = 
          (flushOut' f; writer:=NONE; (w, m))
                      handle e => handler(f,"getWriter",e)



    fun setBufferMode(Out{mode, ...}, bm) = mode := bm

    fun getBufferMode(Out{mode=ref m, ...}) = m


    local
      fun nonBlockChunk n (PrimIO.RD{chunkSize=k,readVecNB=SOME read,...})=
                      (* round n up to the next multiple of k *)
		      (case read (((n-1+k) div k) * k)
                        of NONE => Vector.fromList []
		         | SOME stuff => stuff)
         | nonBlockChunk _ _ = raise NonBlockingNotSupported


    in
      fun canInput(In{pos=pos,
                   buffer = buffer as Buf{more, data, basePos, emptyMeansEof,
                                          ...}}, i) =
        let val len = Vector.length data
        in
          if emptyMeansEof andalso (len=0) then SOME 0 else
          if (pos+i <= len) then SOME i 
          else let
            val {eof,rest} =
              filbuf (nonBlockChunk (pos+i-len),"canInput") buffer
            val remaining = pos+i-len
          in
            case canInput(In{pos=0,buffer=rest},remaining)
              of NONE => if pos=len andalso (not eof) then NONE 
                         else SOME (len-pos)
               | SOME k => if k+len-pos =0 andalso (not eof)
                          then NONE else SOME (len-pos+k)
          end
        end
    end

 end

@


1.10
log
@Ensure outstreams are flushed before closing,
and that flushing closed outstreams is a no-op
@
text
@d10 4
d279 2
a280 1
      | getReader' (Buf{more=ref(GETmore m), data, ...}) = (m, data)
d296 2
d301 1
a301 1
        writer   : PrimIO.writer
d304 2
a305 1
    fun handler(Out{writer=PrimIO.WR{name,...},...}, function, cause) =
d308 1
d311 3
a313 3
         of w' as PrimIO.WR{chunkSize,...} =>
	Out{data=Array.array(chunkSize,someElem), 
            pos=ref 0, writer=w', mode=ref mode}
d317 2
a318 1
			writer=PrimIO.WR{writeArr=SOME write,...},...}) =
d330 2
d335 12
a346 2
      handle MLWorks.Internal.SysErr("Bad file number",_) => ()
           | e => handler(f,"flushOut",e)
a347 2
    fun closeOut(f as Out{writer=PrimIO.WR{close,name,...},...})= 
				 (flushOut f; close()) handle _ => ()
d351 2
a352 1
    fun bigoutput(f as Out{writer=PrimIO.WR{writeVec=SOME write,...},...},
d365 2
a366 2
      | bigoutput (Out{writer=PrimIO.WR{writeArr=NONE,...},...}, _) =
	raise BlockingNotSupported
d369 7
a375 2
    fun output(f as Out{data,pos,...}, s) =
      let val slen = Vector.length s
d390 6
a395 1
    fun output1(f as Out{data,pos,...}, e) =
d406 10
a415 1
    fun getWriter(Out{writer, mode = ref m, ...}) = (writer, m)
@


1.9
log
@Implementing closeIn, and correcting endOfStream,
@
text
@d10 3
a305 2
    fun closeOut(Out{writer=PrimIO.WR{close,name,...},...})= 
				 close() handle _ => ()
d322 8
a329 1
    fun flushOut f = flushOut' f handle e => handler(f,"flushOut",e)
@


1.8
log
@debug so that input <streamname> always returns the same info
(i.e., not imperative input).
@
text
@d10 4
d70 1
a70 1
               ) : STREAM_IO =
d78 1
d99 1
a99 1
    (* NOTE: I haven't implemented check to ensure blocking reads are possible.*)
d150 1
a150 1
                           rest=buf'}
d182 6
a187 1
	   else #eof(eofFilbuf buffer)
d228 6
a233 2
    in fun inputNoBlock x = SOME(inpNob x) handle WouldBlock => NONE
  end
d252 2
a253 1
	        then ([Vector.extract(data,pos,SOME n)], In{pos=pos+n,buffer=buffer})
a314 1

d373 32
a404 12
    fun canInput(In{pos=pos, buffer = Buf{more=ref m, data, basePos, ...}}, i) =
      NONE
(* This isn't quite right, but I can't be bothered to fix it
      (basePos < Vector.length data) orelse
      (case m of
	 GETmore(PrimIO.RD{canInput, ...}) =>
	   (case canInput of
	      SOME f => f()
	    | NONE => false)
       | ISmore buffer => canInput(In{pos=pos, buffer=buffer})
       | NOmore => false)
*)
d406 1
@


1.7
log
@modifying functor argument (in line with definition).
@
text
@d10 3
d126 1
a126 1
          in if len = 0 andalso emptyMeansEof
d128 21
a148 20
		    rest=Buf{data=empty,more=more,name=name,
			     emptyMeansEof=false,basePos=basePos}}
             else case !more
		  of ISmore buf' => filbuf (doRead,mlOp) buf'
                   | NOmore => {eof=true,
				rest=Buf{data=empty,more=more,
					 emptyMeansEof=true,
					 name=name,basePos=basePos}}
		   | m as GETmore (gm as PrimIO.RD{getPos,...}) => 
			   (let val basePos' = getPos()
				val v = doRead gm
				val buf' = Buf{data=v, more=ref m,
					       name=name, basePos=basePos',
					       emptyMeansEof=true}
			     in more := ISmore buf';
			        {eof=false,
				 rest=buf'}
			    end handle e => handler(buffer,mlOp,e))
          end

@


1.6
log
@Fixing merge problem
@
text
@d10 3
d57 2
a58 1
                 structure Arr: MONO_ARRAY
d60 3
a62 5
		 val posLess : PrimIO.pos * PrimIO.pos -> bool
		 val posDiff : ({lo: PrimIO.pos, hi: PrimIO.pos} -> int) option
               sharing type PrimIO.vector=Arr.Vector.vector
               sharing type PrimIO.array=Arr.array
               sharing type Arr.elem = PrimIO.elem
a64 1
    structure Vec = Arr.Vector
d67 1
a67 1
    type array = PrimIO.array
d93 1
a93 1
    val empty = Vec.fromList[]
d122 1
a122 1
         let val len = Vec.length data
d148 1
a148 1
       let val len = Vec.length data
d150 1
a150 1
	    then (Vec.extract(data, pos, SOME (len - pos)),
d172 1
a172 1
       if pos < Vec.length data then false
d179 1
d186 2
d199 1
a199 1
		in if Vec.length s = 0 then nil else s :: loop rest
d202 1
a202 1
         in if Vec.length s = 0 then s else Vec.concat(s :: loop rest)
d221 1
a221 1
	val len = Vec.length data
d224 1
a224 1
	  then SOME(Vec.sub(data,pos), In{pos=pos+1,buffer=buffer})
d232 1
a232 1
       let val len = Vec.length data
d234 1
a234 1
	        then ([Vec.extract(data,pos,SOME n)], In{pos=pos+n,buffer=buffer})
d236 1
a236 1
		then let val hd = Vec.extract(data,pos,SOME (len-pos))
d248 1
a248 1
         in (Vec.concat vl, f')
d269 1
a269 1
        data     : array,
d281 2
a282 1
	Out{data=Arr.array(chunkSize,someElem), pos=ref 0, writer=w', mode=ref mode}
d292 1
a292 1
			  handle e => (Arr.copy{src=data,si=i,len=SOME (p-i),
d310 1
a310 1
	| NONE => Vec.length buf - first
d323 2
a324 2
      let val slen = Vec.length s
          val blen = Arr.length data
d327 1
a327 1
	    (Arr.copyVec {src=s, si=0, len=SOME slen, dst=data, di=offset};
d339 1
a339 1
      let val blen = Arr.length data
d342 1
a342 1
           then (Arr.update(data,p,e); pos := p+1)
d344 1
a344 1
	         then bigoutput(f,{buf=Vec.fromList[e],i=0,sz=SOME 1})
d358 1
a358 1
      (basePos < Vec.length data) orelse
@


1.5
log
@New Vectors
@
text
@d10 3
a61 1
<<<<<<< /usr/ldisk/matthew/ml/MLW/src/basis/_streamio.sml
d63 1
a63 8
  structure Vec = Arr.Vector
  structure PrimIO=PrimIO
  type elem = PrimIO.elem
  type array = PrimIO.array
  type vector = PrimIO.vector
  type pos = PrimIO.pos
=======
  struct
a68 1
>>>>>>> 1.4
d286 1
a286 2
<<<<<<< /usr/ldisk/matthew/ml/MLW/src/basis/_streamio.sml
	        then loop(i+write{data=data,first=i,nelems=p-i}
a287 4
=======
	        then loop(i+write{buf=data,i=i,sz=SOME(p-i)}
			  handle e => (Arr.copy{src=data,si=i,len=p-i,
>>>>>>> 1.4
d339 1
a339 5
<<<<<<< /usr/ldisk/matthew/ml/MLW/src/basis/_streamio.sml
	         then bigoutput(f,{data=Vec.fromList[e],first=0,nelems=1})
=======
	         then bigoutput(f,{buf=Vec.vector[e],i=0,sz=SOME 1})
>>>>>>> 1.4
@


1.4
log
@signature changes
@
text
@d10 3
a50 1
                 structure Vec: MONO_VECTOR
d55 1
a55 2
               sharing type PrimIO.elem = Arr.elem = Vec.elem 
               sharing type PrimIO.vector=Arr.vector=Vec.vector
d57 1
d59 9
d74 1
d96 1
a96 1
 (* NOTE: I haven't implemented check to ensure blocking reads are possible.*)
d98 1
a98 1
    val empty = Vec.vector[]
d155 1
a155 1
	    then (Vec.extract(data, pos, len - pos),
d236 1
a236 1
	        then ([Vec.extract(data,pos,n)], In{pos=pos+n,buffer=buffer})
d238 1
a238 1
		then let val hd = Vec.extract(data,pos,len-pos)
d292 4
d298 1
d333 1
a333 1
	    (Arr.copyv {src=s, si=0, len=slen, dst=data, di=offset};
d350 3
d354 1
@


1.3
log
@pack_words moved to pack_word
@
text
@d10 3
d34 3
a36 2
require "primio";
require "streamio";
d57 6
a62 6
 struct
  structure PrimIO=PrimIO
  type elem = PrimIO.elem
  type array = PrimIO.array
  type vector = PrimIO.vector
  type pos = PrimIO.pos
d64 2
a65 1
    type finder = ({data: vector, first:int, nelems: int}*pos) ->pos 
a70 1
	findPos  : finder,
d81 1
a81 2
        buffer   : buffer
      }
d88 9
a96 9
    fun mkInstream r = 
	let val r' as PrimIO.Rd{name,getPos,findPos,...} = PrimIO.augmentIn r
	 in In{pos=0, 
	       buffer=Buf{name=name,
			  emptyMeansEof=false,
			  data=empty,
			  more = ref(GETmore r'),
			  basePos=getPos(),
			  findPos=findPos}}
d104 1
a104 1
      | closeBuf (b as Buf{more as ref(GETmore(PrimIO.Rd{close,...})),...}) =
d114 1
a114 1
	       (buffer as Buf{data,more,emptyMeansEof,name,basePos,findPos})=
d119 1
a119 2
			     emptyMeansEof=false,basePos=basePos,
			     findPos=findPos}}
d125 2
a126 3
					 name=name,basePos=basePos,
					 findPos=findPos}}
		   | m as GETmore (gm as PrimIO.Rd{getPos,...}) => 
a130 1
					       findPos=findPos,
d152 1
a152 1
   fun chunk1 (PrimIO.Rd{chunkSize,readBlock=SOME read,...}) = read chunkSize
d156 2
a157 2
   fun chunkN n (PrimIO.Rd{chunkSize=1,readBlock=SOME read,...}) = read n
     | chunkN n (PrimIO.Rd{chunkSize=k,readBlock=SOME read,...}) =
d172 1
a172 1
   fun bigchunk (arg as PrimIO.Rd{getPos,endPos,...}) =
d197 1
a197 1
       fun nonBlockChunk (PrimIO.Rd{chunkSize,readNoBlock=SOME read,...})=
d210 10
a219 8
       let val len = Vec.length data
        in if pos < len
	        then (SOME(Vec.sub(data,pos)), In{pos=pos+1,buffer=buffer})
	    else case input1Filbuf buffer
		  of {eof=true,rest} => (NONE,In{pos=0,buffer=rest})
		   | {eof=false,rest} => input1(In{pos=0,buffer=rest})

       end
a240 33
    fun getPosIn(In{pos,buffer as Buf{data,basePos,findPos,...}}) =
            findPos({data=data,first=0,nelems=pos},basePos)
	     handle e => handler(buffer,"getPosIn",e)

    fun posLessEq(a,b) = not(posLess(b,a))

    fun setPosIn(In{pos,buffer as Buf{data,basePos,more,name,findPos,...}}, n) =
     let fun binarySearch(first,0) = In{pos=first,buffer=buffer}
	   | binarySearch(first,len) =
	      let val half = len div 2
	       in if posLessEq(n,findPos({data=data,first=first,nelems=half},basePos))
		    then binarySearch(first,half)
		    else binarySearch(first+half+1,len-(half+1))
	      end

         val datalen = Vec.length data
	 
      in if posLessEq(basePos,n) 
	  andalso posLessEq (n,
                          findPos({data=data,first=0,nelems=datalen},basePos))
	     then binarySearch(0,datalen)
	 else case !more
	    of ISmore f' => setPosIn(In{pos=0,buffer=f'}, n)
             | NOmore => handler(buffer,"setPosIn",TerminatedStream)
	     | m as GETmore(PrimIO.Rd{setPos,...}) =>
		(more := NOmore;
		 setPos n handle e => handler(buffer,"setPosIn",e);
		 In{pos=0,buffer=Buf{data=empty,more=ref m,name=name,
				     emptyMeansEof=false,
				     basePos=n,findPos=findPos}})

     end
         
d243 1
a243 1
      | getReader' (Buf{more=ref(GETmore m),...}) = m
d246 1
a246 1
	     getReader' buffer handle e => handler(buffer,"getReader",e)
d249 5
a253 3
	let val PrimIO.Rd{endPos,...} = getReader' buffer
         in endPos()
        end handle e => handler(buffer,"endPosIn",e)
d261 1
d265 1
a265 1
    fun handler(Out{writer=PrimIO.Wr{name,...},...}, function, cause) =
d268 4
a271 4
    fun mkOutstream w =
	case PrimIO.augmentOut w
         of w' as PrimIO.Wr{chunkSize,...} =>
	Out{data=Arr.array(chunkSize,someElem), pos=ref 0, writer=w'}
d273 1
a273 1
    fun closeOut(Out{writer=PrimIO.Wr{close,name,...},...})= 
a274 1
				 
d277 1
a277 1
			writer=PrimIO.Wr{writeaBlock=SOME write,...},...}) =
d280 1
a280 1
	        then loop(i+write{data=data,first=i,nelems=p-i}
d294 15
a308 9
    fun bigoutput(f as Out{writer=PrimIO.Wr{writeBlock=SOME write,...},...},
		  buf as {data,first,nelems}) =
	   if nelems=0 then ()
            else let val written = write buf (* may raise exception! *)
		  in bigoutput(f, {data=data,first=first+written,
				   nelems=nelems-written})
		 end
     | bigoutput (Out{writer=PrimIO.Wr{writeaBlock=NONE,...},...}, _) =
			  raise BlockingNotSupported
d323 1
a323 1
                     else bigoutput(f,{data=s,first=0,nelems=slen}))
d333 1
a333 1
	         then bigoutput(f,{data=Vec.vector[e],first=0,nelems=1})
d338 1
a338 2
    fun getPosOut(f as Out{writer=PrimIO.Wr{getPos,...},...}) =
	(flushOut' f; getPos()) handle e => handler(f,"getPosOut",e)
d340 1
a340 2
    fun setPosOut(f as Out{writer=PrimIO.Wr{setPos,...},...},p) =
	(flushOut' f; setPos p) handle e => handler(f,"setPosOut",e)
d342 1
a342 4
    fun endPosOut(f as Out{writer=PrimIO.Wr{endPos,...},...}) =
	(flushOut' f; endPos()) handle e => handler(f,"endPosOut",e)

    fun getWriter (Out{writer,...}) = writer
d344 12
a356 2

   
@


1.2
log
@Integer is now Int
@
text
@d10 3
d28 2
a29 2
require "mono_arrays";
require "mono_vectors";
@


1.1
log
@new unit
@
text
@d9 4
a12 1
 *  $Log$
d171 1
a171 1
        of SOME f => (chunkN (Integer.max(f{hi=endPos(),lo=getPos()}, 1)) 
@
