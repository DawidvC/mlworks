head	1.17;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.1
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.15
	MLWorks_20c0_1998_08_04:1.15
	MLWorks_20b2c2_1998_06_19:1.15
	MLWorks_20b2_Windows_1998_06_12:1.15
	MLWorks_20b1c1_1998_05_07:1.15
	MLWorks_20b0_1998_04_07:1.15
	MLWorks_20b0_1998_03_20:1.15
	MLWorks_20m2_1998_02_16:1.15
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.14.1.1.1.2.1
	MLWorks_workspace_97:1.15.2
	MLWorks_dt_wizard:1.15.1
	MLWorks_11c0_1997_09_09:1.14.1.1.1.2
	MLWorks_10r3:1.14.1.1.3
	MLWorks_10r2_551:1.14.1.1.2
	MLWorks_11:1.14.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.14.1.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.14.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.14.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.14.1
	MLWorks_BugFix_1997_04_24:1.14
	MLWorks_1_0_r2_Win32_1997_04_11:1.14
	MLWorks_1_0_r2_Unix_1997_04_04:1.14
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.12.5.1.1
	MLWorks_gui_1996_12_18:1.12.6
	MLWorks_1_0_Win32_1996_12_17:1.12.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.12.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.12.3.1
	MLWorks_1_0_Irix_1996_11_28:1.12.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.12.4
	MLWorks_1_0_Unix_1996_11_14:1.12.3
	MLWorks_Open_Beta2_1996_10_11:1.12.2
	MLWorks_License_dev:1.12.1
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.7
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.4
	MLWorks_Beta_1996_05_31:1.4
	MLWorks_Beta_1996_05_30:1.4;
locks; strict;
comment	@ *  @;


1.17
date	99.02.17.14.40.57;	author mitchell;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	99.02.02.15.58.20;	author mitchell;	state Exp;
branches;
next	1.15;

1.15
date	97.08.08.14.31.01;	author brucem;	state Exp;
branches
	1.15.1.1
	1.15.2.1;
next	1.14;

1.14
date	97.03.06.16.45.54;	author jont;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	96.12.17.16.52.29;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	96.10.03.14.23.06;	author io;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1
	1.12.4.1
	1.12.5.1
	1.12.6.1;
next	1.11;

1.11
date	96.10.01.13.11.27;	author io;	state Exp;
branches;
next	1.10;

1.10
date	96.07.26.10.24.56;	author daveb;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	96.07.25.14.31.06;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	96.07.09.12.13.31;	author andreww;	state Exp;
branches;
next	1.7;

1.7
date	96.07.02.15.19.53;	author io;	state Exp;
branches;
next	1.6;

1.6
date	96.06.24.20.07.13;	author io;	state Exp;
branches;
next	1.5;

1.5
date	96.06.04.17.53.50;	author io;	state Exp;
branches;
next	1.4;

1.4
date	96.05.23.20.38.11;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.05.16.16.58.55;	author io;	state Exp;
branches;
next	1.2;

1.2
date	96.05.16.14.54.11;	author io;	state Exp;
branches;
next	1.1;

1.1
date	96.05.16.09.39.54;	author io;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.09.42;	author hope;	state Exp;
branches;
next	;

1.12.1.1
date	96.10.07.16.00.35;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.10.17.11.18.50;	author hope;	state Exp;
branches;
next	;

1.12.3.1
date	96.11.14.12.42.22;	author hope;	state Exp;
branches
	1.12.3.1.1.1;
next	;

1.12.3.1.1.1
date	96.11.28.14.54.15;	author hope;	state Exp;
branches;
next	;

1.12.4.1
date	96.11.22.18.02.53;	author hope;	state Exp;
branches;
next	;

1.12.5.1
date	96.12.17.17.41.47;	author hope;	state Exp;
branches
	1.12.5.1.1.1;
next	;

1.12.5.1.1.1
date	97.02.24.11.30.06;	author hope;	state Exp;
branches;
next	;

1.12.6.1
date	96.12.18.09.35.45;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	97.05.12.10.27.49;	author hope;	state Exp;
branches
	1.14.1.1.1.1
	1.14.1.1.2.1
	1.14.1.1.3.1;
next	;

1.14.1.1.1.1
date	97.07.28.18.14.46;	author daveb;	state Exp;
branches;
next	1.14.1.1.1.2;

1.14.1.1.1.2
date	97.08.12.08.47.51;	author johnh;	state Exp;
branches
	1.14.1.1.1.2.1.1;
next	;

1.14.1.1.1.2.1.1
date	97.10.07.11.39.50;	author jkbrook;	state Exp;
branches;
next	;

1.14.1.1.2.1
date	97.09.08.17.08.11;	author daveb;	state Exp;
branches;
next	;

1.14.1.1.3.1
date	97.09.09.14.03.20;	author daveb;	state Exp;
branches;
next	;

1.15.1.1
date	97.09.10.19.17.49;	author brucem;	state Exp;
branches;
next	;

1.15.2.1
date	97.09.11.20.48.39;	author daveb;	state Exp;
branches;
next	;

1.17.1.1
date	99.04.01.17.52.44;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.17
log
@[Bug #190507]
Modify to satisfy CM constraints.
@
text
@(*  ==== INITIAL BASIS : STRINGS ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  Revision Log
 *  ------------
 *  $Log: __string.sml,v $
 *  Revision 1.16  1999/02/02  15:58:20  mitchell
 *  [Bug #190500]
 *  Remove redundant require statements
 *
 *  Revision 1.15  1997/08/08  14:31:01  brucem
 *  [Bug #30086]
 *  Add map and mapi.
 *
 *  Revision 1.14  1997/03/06  16:45:54  jont
 *  [Bug #1938]
 *  Get rid of unsafe stuff from PreBasis where possible
 *
 *  Revision 1.13  1996/12/17  16:52:29  matthew
 *  Using PreChar instead of Char
 *
 *  Revision 1.12  1996/10/03  14:23:06  io
 *  [Bug #1614]
 *  remove some redundant requires
 *
 *  Revision 1.11  1996/10/01  13:11:27  io
 *  [Bug #1626]
 *  remove option type for Char.toCString
 *
 *  Revision 1.10  1996/07/26  10:24:56  daveb
 *  Added comment describing optimisation used in extract.
 *
 *  Revision 1.9  1996/07/25  14:31:06  daveb
 *  [Bug #1497]
 *  Extract now does bound checking for the empty string.
 *
 *  Revision 1.8  1996/07/09  12:13:31  andreww
 *  rewriting to make use of expanded toplevel.
 *
 *  Revision 1.7  1996/07/02  15:19:53  io
 *  modify isPrint, fix fromCString accum bug
 *
 *  Revision 1.6  1996/06/24  20:07:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
 *  Revision 1.5  1996/06/04  17:53:50  io
 *  stringcvt->string_cvt
 *
 *  Revision 1.4  1996/05/23  20:38:11  io
 *  from|toCString
 *
 *  Revision 1.3  1996/05/16  16:58:55  io
 *  fix from, to String
 *
 *  Revision 1.2  1996/05/16  14:54:11  io
 *  remove warnings
 *
 *  Revision 1.1  1996/05/16  09:39:54  io
 *  new unit
 *
 *  Revision 1.2  1996/05/13  17:50:56  io
 *  fix explode and complete toString
 *
 *  Revision 1.1  1996/05/10  16:18:45  io
 *  new unit
 *
 *)
require "__pre_basis";
require "string";
require "__pre_char";

structure String : STRING = 
  struct
    val maxSize = PreBasis.maxSize

    val char_sub = chr o MLWorks.String.ordof

    (* miscellaneous *)
    val unsafe_concatenate : string * string -> string =
      MLWorks.Internal.Runtime.environment "string concatenate"
    (* end of miscellaneous *)

    structure Char = PreChar

    type char = Char.char
    type string = string
    val size = size

    fun sub (s, i) = 
      let val size = size s in
        if i < 0 orelse i >= size then 
          raise Subscript
        else
          char_sub(s, i)
      end

    (* Top level functions *)
    val substring: string * int * int -> string = substring
    val concat: string list -> string = concat
    val str: char -> string           = str
    val explode: string -> char list  = explode
    val implode: char list -> string  = implode

    (* basis concat is aka old style implode *)

    fun compare (x:string,y) = 
      if x<y then LESS else if x>y then GREATER else EQUAL

    fun collate (comp: (char * char) -> order) ((s1,s2):string * string) 
      : order = 
      let val s1l = explode s1
        val s2l = explode s2
        fun aux ([],[]) = EQUAL
          | aux ([], _) = LESS
          | aux (_, []) = GREATER
          | aux (x::xs, y::ys) = 
          case comp (x,y) of
            EQUAL => aux (xs, ys)
          | arg => arg
      in
        aux (s1l, s2l)
      end

    fun fields (isDelimiter:char -> bool) (s:string) : string list =
      let
        val size = size s
        fun aux (i, j, acc) = 
          let val size' = i+j in
            if (size' = size) then (MLWorks.String.substring (s, i, j) :: acc)
            else if isDelimiter (char_sub(s, size')) then
              aux (size'+1, 0, MLWorks.String.substring(s, i, j)::acc)
            else aux (i, j+1, acc)
          end
      in
        rev(aux (0, 0, []))
      end

    fun tokens (p:char -> bool) "" = []
      | tokens p s = 
      let
        val size = size s
        fun mySubstring (s, i, j, acc) =
              if j = 0 then acc else MLWorks.String.substring (s, i, j) :: acc
        fun skip i =
          if i = size then i else if p (char_sub(s, i)) then skip (i+1) else i
        fun aux (i, j, acc) =
          let 
            val size' = i+j 
          in
            if (size' = size) then mySubstring (s, i, j, acc)
            else if p (char_sub (s, size')) then
              aux (skip size', 0, mySubstring(s, i, j, acc))
            else 
              aux (i, j+1, acc)
          end
      in
        rev(aux (0, 0, []))
      end

    fun isPrefix (s:string) (t:string) = 
      let 
        val size_s = size s 
      in
        if size_s > size t then false
        else 
          let fun aux i = 
            if i < size_s then 
              char_sub(s,i) = char_sub (t, i) andalso 
              aux (i+1)
            else
              true
          in
            aux 0
          end
      end

    (* The bounds checking here uses unsigned comparisons as an optimisation.
       E.g. if size_s' > i' then we know both that size_s > i and i > 0
       (this relies on the fact that size_s > 0, which it must be). *)
    fun extract (s, i, NONE) =
      let
	val size_s = size s
	val size_s' = MLWorks.Internal.Value.cast size_s : word
	val i' = MLWorks.Internal.Value.cast i : word
      in
        if size_s' < i' then
          raise Subscript
        else
          MLWorks.String.substring (s, i, size_s - i)
      end
      | extract (s, i, SOME n) = 
      let
	val size_s = size s
	val size_s' = MLWorks.Internal.Value.cast size_s : word
	val i' = MLWorks.Internal.Value.cast i : word
	val n' = MLWorks.Internal.Value.cast n : word
      in
	if size_s' < i' orelse MLWorks.Internal.Value.cast (size_s - i) < n'
        then
	  raise Subscript
        else
          MLWorks.String.substring (s, i, n)
      end

    fun map f s =
      let
        val l = size s
        val newS = MLWorks.Internal.Value.alloc_string (l+1)
        val i = ref 0
        val _ =
          while (!i<l) do(
            MLWorks.Internal.Value.unsafe_string_update
             (newS, !i, 
              ord (f (chr(MLWorks.Internal.Value.unsafe_string_sub (s,!i)))));
            i := !i + 1 )
        val _ = MLWorks.Internal.Value.unsafe_string_update (newS, l, 0)
      in
        newS
      end

    fun check_slice (s, i, SOME j) =
      if i < 0 orelse j < 0 orelse i + j > size s
        then raise Subscript
      else j
      | check_slice (s, i, NONE) =
        let
          val l = size s
        in
          if i < 0 orelse i > l
            then raise Subscript
          else l - i
        end

    fun mapi f (st, s, l) =
      let
         val l' = check_slice (st, s, l)
         val newS = MLWorks.Internal.Value.alloc_string (l' + 1)
         val i = ref 0
         val _ =
           while (!i<l') do (
             MLWorks.Internal.Value.unsafe_string_update
               (newS, !i,
                ord (f (!i + s, 
                        chr(MLWorks.Internal.Value.unsafe_string_sub(st, !i+s )
                           )
                       )
                    )
               ) ; 
             i := !i + 1)
         val _ = MLWorks.Internal.Value.unsafe_string_update (newS, l', 0)
      in
         newS
      end
    
    fun translate _ "" = ""
      | translate (p:char -> string) (s:string) : string = 
      let 
        val size = size s 
        fun aux (i, acc) = 
          if i < size then
            aux (i+1, (p (char_sub (s, i)))::acc)
          else
            concat (rev acc)
      in
        aux (0, [])
      end

    fun toString s = translate Char.toString s
      
    fun fromString s = 
        let
          val sz = size s 
          fun getc i = 
            if i < sz then
              SOME (char_sub(s, i), i+1)
            else 
              NONE
          fun aux (i, acc) =
            if i < sz then
              case Char.scan getc i of
                SOME (c, i) => 
                  aux (i, c::acc)
              | NONE => acc
            else
              acc
        in
          case aux (0, []) of
            [] => NONE
          | xs => SOME (PreBasis.revImplode xs)
        end

    fun fromCString "" = NONE
      | fromCString s = 
      let 
        val sz = size s
        fun getc i = 
          if i < sz then
            SOME (char_sub(s, i), i+1)
          else
            NONE
        fun scan (i, acc) = 
          if i < sz then
            case PreChar.scanc getc i of
              SOME (c, i) =>
                scan (i, c::acc)
            | NONE => acc
          else
            acc
      in
        case scan (0, []) of
          [] => NONE
        | xs => SOME (PreBasis.revImplode xs)
      end
      
    fun toCString s = 
      translate Char.toCString s

    fun op^(s1, s2) = 
      if size s1 + size s2 > maxSize then raise Size 
      else unsafe_concatenate (s1, s2)

    val op< : string * string -> bool = op<
    val op<= : string * string -> bool = op<=
    val op> : string * string -> bool = op>
    val op>= : string * string -> bool = op>=

  end
@


1.17.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 *  Revision 1.17  1999/02/17  14:40:57  mitchell
 *  [Bug #190507]
 *  Modify to satisfy CM constraints.
 *
@


1.16
log
@[Bug #190500]
Remove redundant require statements
@
text
@d12 4
d88 1
a88 1
    structure Char = Char
@


1.15
log
@[Bug #30086]
Add map and mapi.
@
text
@d12 4
a71 2

require "__int"; (* Debugging only *)
@


1.15.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 *  Revision 1.15  1997/08/08  14:31:01  brucem
 *  [Bug #30086]
 *  Add map and mapi.
 *
@


1.15.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 *  Revision 1.15  1997/08/08  14:31:01  brucem
 *  [Bug #30086]
 *  Add map and mapi.
 *
@


1.14
log
@[Bug #1938]
Get rid of unsafe stuff from PreBasis where possible
@
text
@d12 4
d69 2
d108 2
a109 1
    fun collate (comp: (char * char) -> order) ((s1,s2):string * string) : order = 
d141 4
a144 2
        fun mySubstring (s, i, j, acc) = if j = 0 then acc else MLWorks.String.substring (s, i, j) :: acc
        fun skip i =  if i = size then i else if p (char_sub(s, i)) then skip (i+1) else i
d197 2
a198 1
	if size_s' < i' orelse MLWorks.Internal.Value.cast (size_s - i) < n' then
d202 50
@


1.14.1.1
log
@branched from 1.14
@
text
@a11 4
 *  Revision 1.14  1997/03/06  16:45:54  jont
 *  [Bug #1938]
 *  Get rid of unsafe stuff from PreBasis where possible
 *
@


1.14.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 *  Revision 1.14.1.1  1997/05/12  10:27:49  hope
 *  branched from 1.14
 *
@


1.14.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 *  Revision 1.14.1.1  1997/05/12  10:27:49  hope
 *  branched from 1.14
 *
@


1.14.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 *  Revision 1.14.1.1  1997/05/12  10:27:49  hope
 *  branched from 1.14
 *
@


1.14.1.1.1.2
log
@[Bug #30086]
Merging - add map and mapi.
@
text
@a11 3
 *  Revision 1.14.1.1.1.1  1997/07/28  18:14:46  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a71 2
require "__int"; (* Debugging only *)

d109 1
a109 2
    fun collate (comp: (char * char) -> order) ((s1,s2):string * string) 
      : order = 
d141 2
a142 4
        fun mySubstring (s, i, j, acc) =
              if j = 0 then acc else MLWorks.String.substring (s, i, j) :: acc
        fun skip i =
          if i = size then i else if p (char_sub(s, i)) then skip (i+1) else i
d195 1
a195 2
	if size_s' < i' orelse MLWorks.Internal.Value.cast (size_s - i) < n'
        then
a198 50
      end

    fun map f s =
      let
        val l = size s
        val newS = MLWorks.Internal.Value.alloc_string (l+1)
        val i = ref 0
        val _ =
          while (!i<l) do(
            MLWorks.Internal.Value.unsafe_string_update
             (newS, !i, 
              ord (f (chr(MLWorks.Internal.Value.unsafe_string_sub (s,!i)))));
            i := !i + 1 )
        val _ = MLWorks.Internal.Value.unsafe_string_update (newS, l, 0)
      in
        newS
      end

    fun check_slice (s, i, SOME j) =
      if i < 0 orelse j < 0 orelse i + j > size s
        then raise Subscript
      else j
      | check_slice (s, i, NONE) =
        let
          val l = size s
        in
          if i < 0 orelse i > l
            then raise Subscript
          else l - i
        end

    fun mapi f (st, s, l) =
      let
         val l' = check_slice (st, s, l)
         val newS = MLWorks.Internal.Value.alloc_string (l' + 1)
         val i = ref 0
         val _ =
           while (!i<l') do (
             MLWorks.Internal.Value.unsafe_string_update
               (newS, !i,
                ord (f (!i + s, 
                        chr(MLWorks.Internal.Value.unsafe_string_sub(st, !i+s )
                           )
                       )
                    )
               ) ; 
             i := !i + 1)
         val _ = MLWorks.Internal.Value.unsafe_string_update (newS, l', 0)
      in
         newS
@


1.14.1.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 4
 *  Revision 1.14.1.1.1.2  1997/08/12  08:47:51  johnh
 *  [Bug #30086]
 *  Merging - add map and mapi.
 *
@


1.13
log
@Using PreChar instead of Char
@
text
@d12 3
d69 2
d87 1
a87 1
          unsafe_string_char_sub (s, i)
d121 3
a123 3
            if (size' = size) then (unsafe_substring (s, i, j) :: acc)
            else if isDelimiter (unsafe_string_char_sub (s, size')) then
              aux (size'+1, 0, unsafe_substring(s, i, j)::acc)
d134 2
a135 2
        fun mySubstring (s, i, j, acc) = if j = 0 then acc else unsafe_substring (s, i, j) :: acc
        fun skip i =  if i = size then i else if p (unsafe_string_char_sub(s, i)) then skip (i+1) else i
d141 1
a141 1
            else if p (unsafe_string_char_sub (s, size')) then
d158 1
a158 1
              unsafe_string_char_sub(s,i) = unsafe_string_char_sub (t, i) andalso 
d173 2
a174 2
	val size_s' = cast size_s : word
	val i' = cast i : word
d179 1
a179 1
          unsafe_substring (s, i, size_s - i)
d184 3
a186 3
	val size_s' = cast size_s : word
	val i' = cast i : word
	val n' = cast n : word
d188 1
a188 1
	if size_s' < i' orelse cast (size_s - i) < n' then
d191 1
a191 1
          unsafe_substring (s, i, n)
d200 1
a200 1
            aux (i+1, (p (unsafe_string_char_sub (s, i)))::acc)
d214 1
a214 1
              SOME (unsafe_string_char_sub(s, i), i+1)
d228 1
a228 1
          | xs => SOME (revImplode xs)
d237 1
a237 1
            SOME (unsafe_string_char_sub(s, i), i+1)
d251 1
a251 1
        | xs => SOME (revImplode xs)
@


1.12
log
@[Bug #1614]
remove some redundant requires
@
text
@d12 4
d237 1
a237 1
            case Char.scanc getc i of
@


1.12.6.1
log
@branched from 1.12
@
text
@a11 4
 *  Revision 1.12  1996/10/03  14:23:06  io
 *  [Bug #1614]
 *  remove some redundant requires
 *
@


1.12.5.1
log
@branched from 1.12
@
text
@a11 4
 *  Revision 1.12  1996/10/03  14:23:06  io
 *  [Bug #1614]
 *  remove some redundant requires
 *
@


1.12.5.1.1.1
log
@branched from 1.12.5.1
@
text
@a11 3
 *  Revision 1.12.5.1  1996/12/17  17:41:47  hope
 *  branched from 1.12
 *
@


1.12.4.1
log
@branched from 1.12
@
text
@a11 4
 *  Revision 1.12  1996/10/03  14:23:06  io
 *  [Bug #1614]
 *  remove some redundant requires
 *
@


1.12.3.1
log
@branched from 1.12
@
text
@a11 4
 *  Revision 1.12  1996/10/03  14:23:06  io
 *  [Bug #1614]
 *  remove some redundant requires
 *
@


1.12.3.1.1.1
log
@branched from 1.12.3.1
@
text
@a11 3
 *  Revision 1.12.3.1  1996/11/14  12:42:22  hope
 *  branched from 1.12
 *
@


1.12.2.1
log
@branched from 1.12
@
text
@a11 4
 *  Revision 1.12  1996/10/03  14:23:06  io
 *  [Bug #1614]
 *  remove some redundant requires
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a11 4
 *  Revision 1.12  1996/10/03  14:23:06  io
 *  [Bug #1614]
 *  remove some redundant requires
 *
@


1.11
log
@[Bug #1626]
remove option type for Char.toCString
@
text
@d12 4
a53 1
require "toplevel";
a55 3
require "__pre_string_cvt";
require "__integer";
require "__list";
@


1.10
log
@Added comment describing optimisation used in extract.
@
text
@d12 3
d246 1
a246 1
      translate (fn x=> case Char.toCString x of SOME cs=>cs | NONE => raise Match) s
@


1.10.1.1
log
@branched from 1.10
@
text
@a11 3
 *  Revision 1.10  1996/07/26  10:24:56  daveb
 *  Added comment describing optimisation used in extract.
 *
@


1.9
log
@[Bug #1497]
Extract now does bound checking for the empty string.
@
text
@d12 4
d155 3
@


1.8
log
@rewriting to make use of expanded toplevel.
@
text
@d12 3
d50 1
d54 1
d56 2
a57 1
    val unsafe_concatenate : string * string -> string = MLWorks.Internal.Runtime.environment "string concatenate"
a59 23
(*
    fun implode (cl : char list) : string =
      let
        val cl : int list = cast cl
        fun copyall ([],start,to) = to
          | copyall (c::cl,start,to) =
          (unsafe_string_update (to,start, c);
           copyall (cl,start+1,to))
        fun get_size (a::rest,sz) = get_size (rest,1 + sz)
          | get_size ([],sz) = 
          if sz > 30 then internal_implode_char (cl,sz)
          else
            let
              val result = unsafe_alloc_string (sz+1)
              (* set the null terminator *)
              val _ = unsafe_string_char_update (result,sz,#"\000")
            in
              copyall (cl,0,result)
            end
      in
        get_size (cl,0)
      end
*)
d61 1
d65 1
d74 1
a74 17
(*
    fun substring (s, i, n) = 
      if i < 0 orelse n < 0 orelse size s < i+n then raise Subscript
      else if n <= 12 then
        let
          val alloc_s = unsafe_alloc_string (n+1)
          fun copy i' = 
            if i' < 0 then alloc_s
            else
              (unsafe_string_update (alloc_s, i', unsafe_string_sub (s, i+i'));
               copy (i'-1))
        in
          copy (n-1)
        end
      else (* n > 12 *)
        unsafe_substring (s, i, n)
*)        
a75 1

a82 24
(*
    fun concat [] = ""
      | concat xs = internal_string_concat xs
      
    fun str (c:char) : string = 
      let val alloc_s = unsafe_alloc_string (1+1)
      in
        unsafe_string_char_update(alloc_s, 0, c);
        alloc_s
      end

    fun explode (s:string) : char list = 
      let val size = size s 
        fun aux (i, acc) =
          if i >= 0 then
            aux (i-1, unsafe_string_char_sub(s, i)::acc)
          else
            acc
      in
        aux (size-1, [])
      end

*)

d85 1
d99 1
d151 11
a161 2
    fun extract ("", _, _) = ""
      | extract (s, i, NONE) = substring (s, i,size s-i)
d163 8
a170 3
      let val size = size s in
        if i<0 orelse n < 0 orelse size < i + n then
          raise Subscript
d241 1
@


1.7
log
@modify isPrint, fix fromCString accum bug
@
text
@d12 3
d54 1
d76 1
a76 1

d89 1
d105 7
a111 1
        
d114 2
d136 2
@


1.6
log
@unconstrain Char so that scanc can be seen by other basis routines
@
text
@d12 3
d217 1
a217 1
          val size = size s 
d219 1
a219 1
            if i < size then
d224 1
a224 1
            if i < size then
d228 1
a228 1
              | NONE => NONE
d230 1
a230 1
              SOME (revImplode acc)
d232 3
a234 1
          aux (0, [])
d239 2
a240 1
      let val size = size s
d242 1
a242 1
          if i < size then
d246 3
a248 3
        fun aux (acc, i) = 
          if i < size then
            case Char.scanc getc i of 
d250 2
a251 2
                aux (c::acc, i)
            | NONE => NONE
d253 1
a253 1
            SOME (revImplode acc)
d255 3
a257 1
        aux ([], 0)
@


1.5
log
@stringcvt->string_cvt
@
text
@d12 3
d40 1
a40 1
require "__char";
d194 1
a194 1
          substring (s, i, n)
d211 1
@


1.4
log
@from|toCString
@
text
@d12 3
d32 1
a32 2
require "__pre_char";
require "__char";
d34 1
a34 1
require "__stringcvt";
d37 1
d40 1
a40 1
    val maxSize = PreChar.maxSize
d42 21
a62 15
    val unsafe_substring : (string * int * int) -> string = 
      MLWorks.Internal.Runtime.environment "string unsafe substring"
    val unsafe_concatenate : string * string -> string = 
      MLWorks.Internal.Runtime.environment "string concatenate"
    val unsafe_implode : string list -> string = 
      MLWorks.Internal.Runtime.environment "string implode"
    fun copyFrom (cs:char list, d:string, offset:int, length:int) = 
      let 
        fun aux ([], i) = d
          | aux (c::cs, i) = 
          let in
            PreChar.unsafe_string_update 
            (d, i + offset, MLWorks.Internal.Value.cast c);
            aux (cs, i+1)
          end
d64 1
a64 1
        aux (cs,0)
a65 18
    fun unsafe_implode_char (cs:char list) : string = 
      let 
        val unsafe_implode_char : int list * int -> string =
          MLWorks.Internal.Runtime.environment "string c implode char"
        val length = List.length cs
      in
        if length <= 30 then
          let val alloc_s = PreChar.unsafe_alloc_string (length+1)
          in
            copyFrom (cs, alloc_s, 0, length)
          end
        else if length >= 30 andalso length <= maxSize then
          unsafe_implode_char (MLWorks.Internal.Value.cast cs, length)
        else raise Size
      end
    fun revImplode ([]:char list) : string = ""
      | revImplode cs = unsafe_implode_char (rev cs)
    (* end of miscellaneous *)
a67 1

d76 1
a76 1
          Char.chr (PreChar.unsafe_string_sub (s, i))
d81 13
a93 2
      else
        unsafe_substring (s, i, n) 
d97 2
a98 7
    fun concat xs = 
      let val size = List.foldl op+ 0 (map size xs) in
        if size > maxSize then raise Size
        else 
          (* foldr (unsafe_concatenate)  "" xs *)
          unsafe_implode xs
      end
d101 1
a101 1
      let val alloc_s = PreChar.unsafe_alloc_string (1+1)
d103 1
a103 1
        PreChar.unsafe_string_update(alloc_s, 0, Char.ord c);
a106 1
    fun implode (cs:char list) : string = unsafe_implode_char cs
d109 1
a109 1
        fun aux (acc, i) = 
d111 1
a111 1
            aux (Char.chr (PreChar.unsafe_string_sub(s, i))::acc, i-1)
d115 1
a115 1
        aux ([], size-1)
d117 1
d136 1
a136 1
        fun aux (acc, i, j) = 
d139 3
a141 3
            else if isDelimiter (Char.chr (PreChar.unsafe_string_sub (s, size'))) then
              aux (unsafe_substring(s, i, j)::acc, size'+1, 0)
            else aux (acc, i, j+1)
d144 1
a144 1
        rev(aux ([], 0, 0))
d152 2
a153 2
        fun skip i =  if i = size then i else if p (Char.chr (PreChar.unsafe_string_sub(s, i))) then skip (i+1) else i
        fun aux (acc, i, j) = 
d158 4
a161 3
            else if p (Char.chr (PreChar.unsafe_string_sub (s, size'))) then
              aux (mySubstring(s, i, j, acc), skip size', 0)
            else aux (acc, i, j+1)
d164 1
a164 1
        rev(aux ([], 0, 0))
a167 15
      let val size_s = size s
      in
        if size_s > (size t) then false
        else 
          let fun aux n = 
            if n > size_s-1 then true
            else if PreChar.unsafe_string_sub(s,n) <> PreChar.unsafe_string_sub(t,n) then
                false
            else
              aux (n+1)
          in
            aux 0
          end
      end
    fun isPrefix (s:string) (t:string):bool = 
d175 1
a175 1
              PreChar.unsafe_string_sub(s,i) = PreChar.unsafe_string_sub (t, i) andalso 
d193 3
a195 1
    fun translate (p:char -> string) (s:string) : string = 
d198 1
a198 1
        fun aux (acc, i) = 
d200 1
a200 1
            aux (p (Char.chr (PreChar.unsafe_string_sub (s, i)))::acc, i+1)
d204 1
a204 1
        aux ([], 0)
d213 1
a213 1
              SOME (sub(s, i), i+1)
d216 1
a216 1
          fun aux (acc, i) = 
d220 1
a220 1
                  aux (c::acc, i)
d225 1
a225 1
          aux ([], 0)
a227 77
    fun splitlN (n:int) (p:char->bool) getc src = 
      let fun aux (acc, count, cs) = 
        if count < n then
          case getc cs of
            SOME (c, cs') =>
              if p c then aux (c::acc, count+1, cs') 
              else
                (revImplode acc, cs)
          | NONE => (revImplode acc, cs)
        else
          (revImplode acc, cs)
      in
        aux ([], 0, src)
      end
    fun isOctDigit (c:char) : bool = #"0" <= c andalso c <= #"8"
    (* end of misc *)
      fun scanc getc cs = 
        case getc cs of
          SOME (#"\\", cs) =>
            (case getc cs of
               SOME (#"n", cs) => SOME (#"\n", cs)
             | SOME (#"t", cs) => SOME (#"\t", cs)
             | SOME (#"\\", cs) => SOME (#"\\", cs)
             | SOME (#"\"", cs) => SOME (#"\"", cs)
             | SOME (#"a", cs) => SOME (#"\a", cs)
             | SOME (#"b", cs) => SOME (#"\b", cs)
             | SOME (#"v", cs) => SOME (#"\v", cs)
             | SOME (#"f", cs) => SOME (#"\f", cs)
             | SOME (#"r", cs) => SOME (#"\r", cs)
             | SOME (#"?", cs) => SOME (#"?", cs)
             | SOME (#"'", cs) => SOME (#"'", cs)
             | SOME (#"x", cs) => 
                 (case splitlN 2 Char.isHexDigit getc cs of
                    ("", cs) => NONE 
                  | (digits, cs) =>
                      (case StringCvt.scanString (Int.scan StringCvt.HEX) digits of
                         SOME hex =>
                           if 0 <= hex andalso hex <= Char.maxOrd then 
                             SOME (Char.chr hex, cs)
                           else
                             NONE
                       | NONE => NONE))
             | SOME (c, cs) => 
                    if isOctDigit c then
                      (case getc cs of
                        NONE => NONE
                      | SOME (d, cs') =>
                          if isOctDigit d then
                            (case getc cs of
                               NONE => NONE
                             | SOME (e, cs'') =>
                                 if isOctDigit e then
                                   let fun convert (c, d, e) = 
                                     (8*8*(Char.ord c - Char.ord #"0")) + (8*(Char.ord d - Char.ord #"0")) + (Char.ord e - Char.ord #"0")
                                       val res = convert (c,d,e)
                                   in
                                     if 0 <= res andalso res <= Char.maxOrd then
                                       SOME (Char.chr res, cs'')
                                     else
                                       NONE
                                   end
                                 else
                                   NONE)
                          else
                            NONE)
                    else
                      NONE
              | NONE => NONE)
        | SOME (c, cs) => 
               if Char.isCntrl c orelse c = #"\127" orelse 
                 c = #"?" orelse c = #"'" orelse
                 (not (Char.isAscii c)) then
                 NONE 
               else 
                 SOME (c, cs)
        | NONE => NONE
            
d233 1
a233 1
            SOME (sub(s, i), i+1)
d238 1
a238 1
            case scanc getc i of 
d258 1
@


1.3
log
@fix from, to String
@
text
@d12 3
d32 2
d243 100
a342 2
    fun fromCString s = NONE
    fun toCString s = ""
@


1.2
log
@remove warnings
@
text
@d12 3
d81 1
a81 1
          PreChar.itoc (PreChar.unsafe_string_sub (s, i))
d102 1
a102 1
        PreChar.unsafe_string_update(alloc_s, 0, PreChar.ctoi c);
d111 1
a111 1
            aux (PreChar.itoc (PreChar.unsafe_string_sub(s, i))::acc, i-1)
d138 1
a138 1
            else if isDelimiter (PreChar.itoc (PreChar.unsafe_string_sub (s, size'))) then
d151 1
a151 1
        fun skip i =  if i = size then i else if p (PreChar.itoc (PreChar.unsafe_string_sub(s, i))) then skip (i+1) else i
d157 1
a157 1
            else if p (PreChar.itoc (PreChar.unsafe_string_sub (s, size'))) then
d211 1
a211 1
            aux (p (PreChar.itoc (PreChar.unsafe_string_sub (s, i)))::acc, i+1)
d219 19
a237 19
    fun fromString s = (* StringCvt.scanString scan *)
      let 
        val size = size s 
        fun getc i = 
          if i < size then
            SOME (PreChar.itoc (PreChar.unsafe_string_sub (s, i)), i+1)
          else
            NONE

        fun aux (acc, i) = 
          case Char.scan getc i of
            NONE =>
              revImplode acc
          | SOME (c, i) => aux (c::acc, i)
      in
        SOME (aux ([], 0))
      end


@


1.1
log
@new unit
@
text
@d11 4
a14 1
 *  $Log: __strings.sml,v $
d235 2
a236 2
    fun fromCString "" = NONE
    fun toCString "" = ""
@
