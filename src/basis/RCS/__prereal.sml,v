head	1.22;
access;
symbols
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.20.3.1.1
	MLWorks_gui_1996_12_18:1.20.4
	MLWorks_1_0_Win32_1996_12_17:1.20.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.20.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.20.1.1
	MLWorks_1_0_Irix_1996_11_28:1.20.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.20.2
	MLWorks_1_0_Unix_1996_11_14:1.20.1
	MLWorks_Open_Beta2_1996_10_11:1.17.1
	MLWorks_License_dev:1.16.1
	MLWorks_1_open_beta_1996_09_13:1.13.1
	MLWorks_Open_Beta_1996_08_22:1.13
	MLWorks_Beta_1996_07_02:1.10
	MLWorks_Beta_1996_06_07:1.10
	MLWorks_Beta_1996_06_06:1.10
	MLWorks_Beta_1996_06_05:1.10
	MLWorks_Beta_1996_06_03:1.9
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.9;
locks; strict;
comment	@ * @;


1.22
date	97.01.07.17.03.31;	author io;	state Exp;
branches;
next	1.21;

1.21
date	96.11.18.10.37.17;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	96.11.07.17.12.58;	author matthew;	state Exp;
branches
	1.20.1.1
	1.20.2.1
	1.20.3.1
	1.20.4.1;
next	1.19;

1.19
date	96.11.06.10.40.29;	author andreww;	state Exp;
branches;
next	1.18;

1.18
date	96.11.04.15.55.31;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	96.10.09.16.53.46;	author jont;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	96.10.04.10.38.15;	author io;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	96.10.03.14.55.25;	author io;	state Exp;
branches;
next	1.14;

1.14
date	96.10.03.12.51.12;	author io;	state Exp;
branches;
next	1.13;

1.13
date	96.08.08.15.57.01;	author andreww;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	96.08.08.15.32.25;	author andreww;	state Exp;
branches;
next	1.11;

1.11
date	96.07.05.16.13.57;	author andreww;	state Exp;
branches;
next	1.10;

1.10
date	96.06.04.16.03.12;	author io;	state Exp;
branches;
next	1.9;

1.9
date	96.05.22.13.24.02;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	96.05.21.13.46.24;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	96.05.17.09.38.16;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	96.05.10.15.37.57;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	96.05.09.14.16.05;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.16.39.58;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.05.01.11.08.52;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.04.30.11.31.18;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.11.33.11;	author jont;	state Exp;
branches;
next	;

1.13.1.1
date	96.09.13.11.10.25;	author hope;	state Exp;
branches;
next	;

1.16.1.1
date	96.10.07.16.01.12;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.10.17.11.19.27;	author hope;	state Exp;
branches;
next	;

1.20.1.1
date	96.11.14.12.42.59;	author hope;	state Exp;
branches
	1.20.1.1.1.1;
next	;

1.20.1.1.1.1
date	96.11.28.14.54.54;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.11.22.18.03.30;	author hope;	state Exp;
branches;
next	;

1.20.3.1
date	96.12.17.17.42.24;	author hope;	state Exp;
branches
	1.20.3.1.1.1;
next	;

1.20.3.1.1.1
date	97.02.24.11.30.55;	author hope;	state Exp;
branches;
next	;

1.20.4.1
date	96.12.18.09.36.23;	author hope;	state Exp;
branches;
next	;


desc
@new unit
@


1.22
log
@[Bug #1757]
renamed __ieeereal to __ieee_real
@
text
@(*  ==== INITIAL BASIS : Unconstrinaed Real structure ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: __prereal.sml,v $
 * Revision 1.21  1996/11/18  10:37:17  matthew
 * Improving real equality (again).
 *
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
 * Revision 1.19  1996/11/06  10:40:29  andreww
 * [Bug #1711]
 * real type loses equality attribute.
 *
 * Revision 1.18  1996/11/04  15:55:31  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.17  1996/10/09  16:53:46  jont
 * Fix rem
 *
 * Revision 1.16  1996/10/04  10:38:15  io
 * [Bug #1614]
 * remove Old
 *
 * Revision 1.15  1996/10/03  14:55:25  io
 * [Bug #1614]
 * remove redundant requires
 *
 * Revision 1.14  1996/10/03  12:51:12  io
 * [Bug #1614]
 * updating MLWorks.String
 *
 * Revision 1.13  1996/08/08  15:57:01  andreww
 * [Bug #1526]
 * Correcting problems with sign and nextAfter
 *
 * Revision 1.12  1996/08/08  15:32:25  andreww
 * [Bug #1526]
 * Swapping around the arguments and tests in nextAfter.
 *
 * Revision 1.11  1996/07/05  16:13:57  andreww
 * altering to make use of new toplevel functions.
 *
 * Revision 1.10  1996/06/04  16:03:12  io
 * stringcvt -> string_cvt
 *
 * Revision 1.9  1996/05/22  13:24:02  matthew
 * Fixing problem with sub1
 *
 * Revision 1.8  1996/05/21  13:46:24  matthew
 * Change implementation of fromString
 *
 * Revision 1.7  1996/05/17  09:38:16  matthew
 * Moved Bits to MLWorks.Internal.Bits
 *
 * Revision 1.6  1996/05/10  15:37:57  matthew
 * Adding scan
 *
 * Revision 1.5  1996/05/09  14:16:05  matthew
 * Updating.
 *
 * Revision 1.4  1996/05/02  16:39:58  io
 * redummying stringcvt.
 *
 * Revision 1.3  1996/05/01  11:08:52  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.2  1996/04/30  11:31:18  matthew
 * Revisions
 *
 * Revision 1.1  1996/04/18  11:33:11  jont
 * new unit
 *
 *  Revision 1.1  1995/04/13  13:28:55  jont
 *  new unit
 *  No reason given
 *
 *
 *)

require "__string";
require "__string_cvt";
require "__math";
require "__ieee_real";
require "__preinteger";
require "__preint32";
require "__pre_basis";

(* Implementation of IEEE double precision *)
structure Real =
  struct
    structure Bits = MLWorks.Internal.Bits

    type real = real

    structure Math = Math

    val equal : real * real -> bool = MLWorks.Internal.Value.real_equal
    val isNan : real -> bool = fn x => not (equal(x,x))
    val unordered = fn (x,y) => isNan x orelse isNan y

    (* This should, perhaps, be a builtin, but not yet *)
    val ?= : real * real -> bool =                   (* IEEE "?="*)
      fn (x,y) => not (x < y orelse y < x)

    val == : real * real -> bool = equal             (* IEEE "=" *)
    val op <> : real * real -> bool = not o ?=    (* IEEE "<>" *)
    val ?<> : real * real -> bool = not o ==      (* IEEE "?<>" *)

    infix ?= == ?<>


    val radix = 2
    val precision = 53
    val maxexp = 2047
    val fromRep:string -> real = MLWorks.Internal.Value.string_to_real
    val toRep: real -> string  = MLWorks.Internal.Value.real_to_string
    val minNormalPos = fromRep "\000\016\000\000\000\000\000\000";
    val minPos = fromRep "\000\000\000\000\000\000\000\001";
    val maxFinite =  fromRep "\127\239\255\255\255\255\255\255";

    val posInf = 1.0 / 0.0
    val negInf = ~posInf

    val *+ = fn (x:real,y,z) => x * y + z
    val *- = fn (x:real,y,z) => x * y - z

    val min = fn (x:real,y:real) => if x < y then x else y
    val max = fn (x:real,y:real) => if x > y then x else y

    val sign : real -> int =
      fn x => if x < 0.0 then ~1 else 
              if x == 0.0 then 0 else 
              if x > 0.0 then 1 else raise Domain

    (* Nice to do this without allocating the string *)
    val signBit : real -> bool = 
      fn x => 
      let
        val s = toRep x
      in
        ord(String.sub(s,0)) > 127
      end

    val sameSign : real * real -> bool =
      fn (r1, r2) => sign r1 = sign r2

    (* Gruesome *)
    val copySign : real * real -> real =
      fn (x,y) =>
      let
        val signbit = signBit y
        val s = toRep x
        val size = size s
        val first = ord(String.sub(s,0))
        val rest = substring (s,1,size - 1)
                            (* previously could raise Substring *)
        val newfirst = if signbit then Bits.orb (128,first) 
                       else Bits.andb (127,first)
      in
        fromRep ((str o chr) newfirst ^ rest)
      end

    val compare =
      fn (x:real,y:real) => 
      if x < y then LESS 
      else if x == y then EQUAL
      else if x > y then GREATER
      else raise IEEEReal.Unordered

    val compareReal =
      fn (x:real,y:real) => 
      if x < y then IEEEReal.LESS 
      else if x == y then IEEEReal.EQUAL
      else if x > y then IEEEReal.GREATER
      else IEEEReal.UNORDERED

    (* Returns the (biased) exponent *)
    fun exponent x =
      let
        val s = toRep x
        val b0 = Bits.andb (ord(String.sub(s,0)),127)
        val b1 = Bits.rshift (ord(String.sub(s,1)),4)
      in
        16 * b0 + b1
      end

    fun info x =
      let
        val s = toRep x
        val (a,b,rest) = 
          case map ord (explode s) of
            (a::b::rest) => (a,b,rest)
          | _ => (0,0,[])
        val b0 = Bits.andb (a,127)
        val b1 = Bits.rshift (b,4)
        val sign = a > 127
        val mantissa = Bits.andb (15,b) :: rest
        val exponent = 16 * b0 + b1
      in
        (sign,exponent,mantissa)
      end

    fun make (sign,exponent,b :: mantissa) =
      let
        val b1 = Bits.orb (if sign then 128 else 0,
                            exponent div 16)
        val b2 = Bits.orb (Bits.lshift (exponent mod 16,4),
                           b)
      in
	fromRep (implode (cast (b1 :: b2 :: mantissa) : char list))
      end
    | make _= 0.0

    val isFinite : real -> bool = fn x => exponent x < maxexp
    val isInfinite : real -> bool = fn x => not (isFinite x)
    val isNormal = 
      fn x => 
      let
        val e = exponent x
      in
        e < maxexp andalso e > 0
      end

    
    val class : real -> IEEEReal.float_class =
      fn x => 
      let
        fun is_zero [] = true
          | is_zero (0::b) =is_zero b
          | is_zero _ = false
        fun convert_nan (a::rest) =
          if Bits.andb (a,8) = 0
            then IEEEReal.SIGNALLING
          else IEEEReal.QUIET
          | convert_nan _ = IEEEReal.QUIET
        val (s,e,m) = info x
        fun convert_sign b = if b then IEEEReal.NEG else IEEEReal.POS
      in
        (* Ignore NaN's *)
        if e = maxexp
          then if is_zero m
                 then IEEEReal.INF (convert_sign s)
               else IEEEReal.NAN (convert_nan m)
        else if e = 0
               then if is_zero m
                      then IEEEReal.ZERO (convert_sign s)
                    else IEEEReal.SUBNORMAL (convert_sign s)
             else IEEEReal.NORMAL (convert_sign s)
      end
    val cfmt : StringCvt.realfmt * real -> string = 
      MLWorks.Internal.Runtime.environment "real fmt"

    fun fmt f x = cfmt (f,x)
    val toString = fmt (StringCvt.GEN NONE)

    val internalFromString : string -> real option = 
      fn x => SOME (MLWorks.Internal.string_to_real x)
      handle MLWorks.Internal.StringToReal => NONE

    exception Whoops
    fun scan getc src =
      (* just get the string and let C do the rest *)
      let
        fun is_digit c =
          #"0" <= c andalso c <= #"9"

        fun getdigits src = StringCvt.splitl is_digit getc src

        fun getpointnum src =
          case getc src of
            SOME (#".",src') =>
              let
                val (digs,src'') = getdigits src'
              in
                ("." ^ digs,src'')
              end
          | _ => ("",src)

        fun getsign src =
          case getc src of
            SOME (#"+",src') => ("",src')
          | SOME (#"-",src') => ("-",src')
          | SOME (#"~",src') => ("-",src')
          | _ => ("",src)

        fun getenum src =
          case getc src of
            SOME (char,src') =>
              if char = #"e" orelse char = #"E"
                then 
                  let
                    val (sign,src) = getsign src'
                    val (digs,src) = getdigits src
                  in
                    if digs = ""
                      then raise Whoops
                    else ("E" ^ sign ^ digs,src)
                  end
              else ("",src)
          | _ => ("",src)

        (* Skip whitespace *)
        val src = StringCvt.skipWS getc src
        val (signstring,src) = getsign src
        val (digits1,src) = getdigits src
        val (pointnum,src) = getpointnum src
        val _ = 
          if digits1 = "" andalso pointnum = "" orelse pointnum = "."
            then raise Whoops
          else ()
        val (enum,src) = getenum src
      in
        case internalFromString (signstring ^ digits1 ^ pointnum ^ enum) of
          SOME x => SOME (x,src)
        | _ => NONE
      end
    handle Whoops => NONE

        
    val fromString : string -> real option = 
      StringCvt.scanString scan 

    val toManExp : real -> {man : real, exp : int} =
      MLWorks.Internal.Runtime.environment "real from exp"
    val fromManExp : {man : real, exp : int} -> real =
      MLWorks.Internal.Runtime.environment "real load exp"
    val split : real -> {whole : real, frac : real} =
      MLWorks.Internal.Runtime.environment "real split"
    val maxman = ([15,255,255,255,255,255,255])
    val minman = ([ 0,  0,  0,  0,  0,  0,  0])

    (* This should never be called for all-zero numbers *)
    fun sub1 l =
      let
        fun aux [] = []
          | aux (0::rest) = 255 :: aux rest
          | aux (n::rest) = (n-1) :: rest
      in
        rev (aux (rev l))
      end

    fun add1 l =
      let
        fun aux [] = []
          | aux (255::rest) = 0 :: aux rest
          | aux (n::rest) = (n+1) :: rest
      in
        rev (aux (rev l))
      end

    (* x is neither infinity nor nan *)
    (* reduces towards zero (except zero goes negative) *)
    fun do_dec x =
      let
        val (s,e,m) = info x
      in
        if e = 0 (* we have a subnormal or zero *)
          then if m = minman
                 then (* its a zero *)
                   make (true,0,add1 minman)
               else
                 make (s,e,sub1 m)
        else (* not a subnormal *)
          if m = minman
            then make (s,e-1,maxman)
          else make (s,e,sub1 m)
      end

    (* x is neither infinity nor nan *)
    (* assume x >= 0.0 *)
    fun do_inc x =
      let
        val (s,e,m) = info x
      in
        if m = maxman
          then make (s,e+1,minman)
        else make (s,e,add1 m)
      end

    val nextAfter : real * real -> real = 
      (* check these are the right way round *)
      fn (r,t) =>
      if not(isFinite r) then r      (* returns r if either infinite or NaN*)
      else if r == t then r
      else if r < t then if r<0.0 then do_dec r else do_inc r
      else (*if r > t*)  if r<0.0 then do_inc r else do_dec r


    val checkFloat : real -> real =
      fn x =>
      if isNan x then raise Div
      else if isFinite x then x
      else raise Overflow

    val floor : real -> int = 
      fn x => if isNan x then raise Domain else floor x

    val ceil : real -> int =
      fn x => if isNan x then raise Domain else ceil x

    val trunc : real -> int =
      fn x => if isNan x then raise Domain else trunc x

    val round : real -> int =
      fn x => if isNan x then raise Domain else round x


    val toInt : IEEEReal.rounding_mode -> real -> Int.int = 
      fn mode => fn x =>
      case mode of
        IEEEReal.TO_NEAREST => round x
      | IEEEReal.TO_NEGINF => floor x
      | IEEEReal.TO_POSINF => ceil x
      | IEEEReal.TO_ZERO => trunc x
          
    val fromInt : Int.int -> real = real

    val rem : real * real -> real = 
      fn (x,y) => x - (fromInt (trunc (x / y)) * y)

    val cToLargeInt: IEEEReal.rounding_mode * real -> Int32.int = 
      MLWorks.Internal.Runtime.environment "real to large int"
    fun toLargeInt mode x = cToLargeInt (mode,x)

    val fromLargeInt : Int32.int -> real = 
      MLWorks.Internal.Runtime.environment "real from large int"

    val toLarge : real -> real = fn x => x
    val fromLarge : IEEEReal.rounding_mode -> real -> real = fn y => fn x => x

    (* Define these last so we can still use the overloaded versions *)
    val ~ : real -> real = ~
    val op + : real * real -> real = op +
    val op - : real * real -> real = op -
    val op * : real * real -> real = op *
    val op / : real * real -> real = op /
    val abs : real -> real = abs
    val op > : real * real -> bool = op >
    val op >= : real * real -> bool = op >=
    val op < : real * real -> bool = op <
    val op <= : real * real -> bool = op <=

  end

structure LargeReal = Real









@


1.21
log
@Improving real equality (again).
@
text
@d10 3
d93 1
a93 1
require "__ieeereal";
@


1.20
log
@Fixing problem with equal etc.
@
text
@d10 3
d104 1
a104 1
    val equal : real * real -> bool = fn (x,y) => x <= y andalso y <= x
d108 1
d110 2
a111 1
      fn (x,y) => isNan x orelse isNan y orelse equal(x,y)
@


1.20.4.1
log
@branched from 1.20
@
text
@a9 3
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
@


1.20.3.1
log
@branched from 1.20
@
text
@a9 3
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
@


1.20.3.1.1.1
log
@branched from 1.20.3.1
@
text
@a9 3
 * Revision 1.20.3.1  1996/12/17  17:42:24  hope
 * branched from 1.20
 *
@


1.20.2.1
log
@branched from 1.20
@
text
@a9 3
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a9 3
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
@


1.20.1.1.1.1
log
@branched from 1.20.1.1
@
text
@a9 3
 * Revision 1.20.1.1  1996/11/14  12:42:59  hope
 * branched from 1.20
 *
@


1.19
log
@[Bug #1711]
real type loses equality attribute.
@
text
@d10 4
d101 1
a101 1
    val equal : real * real -> bool = fn (x,y) => not(x < y orelse y > x)
d106 1
a106 2
      fn (x,y) => not(isNan x) andalso not(isNan y)
                  andalso equal(x,y)
@


1.18
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d10 4
d94 1
d97 14
d114 2
a115 2
    val fromRep = MLWorks.Internal.Value.string_to_real
    val toRep = MLWorks.Internal.Value.real_to_string
d130 3
a132 1
      fn x => if x < 0.0 then ~1 else if x = 0.0 then 0 else if x > 0.0 then 1 else raise Domain
d154 4
a157 2
        val rest = substring (s,1,size - 1) (* previously could raise Substring *)
        val newfirst = if signbit then Bits.orb (128,first) else Bits.andb (127,first)
d165 1
a165 1
      else if x = y then EQUAL
d172 1
a172 1
      else if x = y then IEEEReal.EQUAL
a212 5
    val isNan : real -> bool = fn x => not (x = x)
    val unequal : real * real -> bool =
      fn (x,y) => x < y orelse y > x
    val unordered = 
      fn (x,y) => isNan x orelse isNan y
d322 1
a322 1
    val toSci : real -> {man : real, exp : int} =
d324 1
a324 1
    val fromSci : {man : real, exp : int} -> real =
d383 1
a383 1
      else if r = t then r
a441 1

d445 1
@


1.17
log
@Fix rem
@
text
@d10 3
d76 1
d119 1
a119 1
        unsafe_string_sub (s,0) > 127
d132 1
a132 1
        val first = unsafe_string_sub (s,0)
d157 2
a158 2
        val b0 = Bits.andb (unsafe_string_sub (s,0),127)
        val b1 = Bits.rshift (unsafe_string_sub (s,1),4)
@


1.17.1.1
log
@branched from 1.17
@
text
@a9 3
 * Revision 1.17  1996/10/09  16:53:46  jont
 * Fix rem
 *
@


1.16
log
@[Bug #1614]
remove Old
@
text
@d10 4
d396 1
a396 1
      fn (x,y) => x - fromInt (trunc (x / y))
@


1.16.1.1
log
@branched from 1.16
@
text
@a9 4
 * Revision 1.16  1996/10/04  10:38:15  io
 * [Bug #1614]
 * remove Old
 *
@


1.15
log
@[Bug #1614]
remove redundant requires
@
text
@d10 4
a73 1
require "__old";
d128 1
a128 1
        fromRep (Old.chr newfirst ^ rest)
@


1.14
log
@[Bug #1614]
updating MLWorks.String
@
text
@d10 4
a64 1
require "toplevel";
d175 1
a175 1
	fromRep (implode (MLWorks.Internal.Value.cast (b1 :: b2 :: mantissa) : char list))
@


1.13
log
@[Bug #1526]
Correcting problems with sign and nextAfter
@
text
@d10 4
a62 1
require "__general";
d67 2
d105 1
a105 1
        String.ordof (s,0) > 127
d118 2
a119 2
        val first = String.ordof (s,0)
        val rest = String.substring (s,1,size - 1)
d122 1
a122 1
        fromRep (String.chr newfirst ^ rest)
d143 2
a144 2
        val b0 = Bits.andb (String.ordof (s,0),127)
        val b1 = Bits.rshift (String.ordof (s,1),4)
d153 1
a153 1
          case map String.ord (String.explode s) of
d172 1
a172 1
        fromRep (String.implode_char (b1 :: b2 :: mantissa))
d296 2
a297 2
    val maxman = [15,255,255,255,255,255,255]
    val minman = [ 0,  0,  0,  0,  0,  0,  0]
@


1.13.1.1
log
@branched from 1.13
@
text
@a9 4
 * Revision 1.13  1996/08/08  15:57:01  andreww
 * [Bug #1526]
 * Correcting problems with sign and nextAfter
 *
@


1.12
log
@[Bug #1526]
Swapping around the arguments and tests in nextAfter.
@
text
@d10 4
d347 2
a348 2
      else if r < t then do_inc r
      else (*if r > t*)  do_dec r
@


1.11
log
@altering to make use of new toplevel functions.
@
text
@d10 3
d340 6
a345 7
      fn (x,y) =>
      if x = y then x
      else if x < y then if y >= 0.0 then do_dec y else do_inc y
      else if x > y then if y >= 0.0 then do_inc y else do_dec y
      (* at least one is a nan *)
      else if isNan x then x 
      else y
d405 8
@


1.10
log
@stringcvt -> string_cvt
@
text
@d10 3
d354 2
a355 1
    val ceil : real -> int = fn x => ~(floor(~x))
d358 1
a358 2
      fn x =>
      if x >= 0.0 then floor x else ceil x
d361 2
a362 13
      (* round towards nearest, ties towards even *)
      fn x =>
      let
	val near = floor x
	val diff = abs(real near - x)
      in
	if diff < 0.5 then
	  near
	else
	  if diff > 0.5 orelse near mod 2 = 1 
            then near + 1
	  else near
      end
@


1.9
log
@Fixing problem with sub1
@
text
@d10 3
d48 1
a48 1
require "__stringcvt";
@


1.8
log
@Change implementation of fromString
@
text
@d10 3
a200 1
    val toString  : real -> string = MLWorks.Internal.real_to_string
d203 1
d281 1
d285 1
a285 1
          | aux (0::rest) = 1 :: aux rest
@


1.7
log
@Moved Bits to MLWorks.Internal.Bits
@
text
@d10 3
d202 1
a202 1
    val fromString : string -> real option = 
d204 1
d212 3
a214 10
        fun getdigits src =
          case StringCvt.splitl is_digit getc src of
            ("",src) => raise Whoops
          | res => res
        fun getsign src =
          case getc src of
            SOME (#"+",src') => ("",src')
          | SOME (#"-",src') => ("-",src')
          | SOME (#"~",src') => ("-",src')
          | _ => ("",src)
d224 8
d241 3
a243 1
                    ("E" ^ sign ^ digs,src)
d245 1
a245 2
              else 
                ("",src)
d247 2
d253 4
d259 1
a259 1
        case fromString (signstring ^ digits1 ^ pointnum ^ enum) of
d266 3
@


1.6
log
@Adding scan
@
text
@d10 3
d49 2
@


1.5
log
@Updating.
@
text
@d10 3
a48 3
    exception Dummy of string
    fun dummy s = raise Dummy s

a187 4
    val toString  : real -> string = MLWorks.Internal.real_to_string
    val fromString : string -> real option = 
      fn x => SOME (MLWorks.Internal.string_to_real x)

d190 1
d194 53
a246 2
    val scan : (char, 'a) StringCvt.reader -> (real, 'a) StringCvt.reader =
      fn _ => dummy "scan"
d248 1
@


1.4
log
@redummying stringcvt.
@
text
@d10 3
d47 1
a47 1
    fun dummy s x = raise Dummy s
d153 1
a190 2
    val fmt : StringCvt.realfmt -> real -> string = dummy "fmt"
    (* val scan : (char, 'a) StringCvt.reader -> (real, 'a) StringCvt.reader = raise StringCvt "scan" *)
d192 7
a198 4
    val toSci : real -> {man : real, exp : int} = dummy "toSci"
    val fromSci : {man : real, exp : int} -> real = dummy "fromSci"
    val split : real -> {whole : real, frac : real} = dummy "split"
    val rem : real * real -> real = dummy "rem"
d200 6
d272 3
a274 1
    val floor : real -> int = floor
d306 9
a314 2
    val toLargeInt : IEEEReal.rounding_mode -> real -> Int32.int = dummy "toLargeInt"
    val fromLargeInt : Int32.int -> real = dummy "fromLargeInt"
@


1.3
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d10 6
d188 1
a188 1
    val scan : (char, 'a) StringCvt.reader -> (real, 'a) StringCvt.reader = dummy "scan"
@


1.2
log
@Revisions
@
text
@d10 3
d84 1
a84 1
        fromRep (chr newfirst ^ rest)
d115 1
a115 1
          case map ord (explode s) of
@


1.1
log
@new unit
@
text
@d9 4
a12 1
 *  $Log$
d21 1
d23 4
d28 1
d32 58
a89 2
    exception Div = Div
    exception Overflow = General.Overflow
d91 162
d269 3
a271 4
	  if diff > 0.5 orelse near mod 2 = 1 then
	    near + 1
	  else
	    near
d274 17
d292 2
d296 1
a296 2
    val op + : real * real -> real = op +
    val op - : real * real -> real = op -
a300 1
    val abs : real -> real = abs
a301 2
    val sign : real -> int =
      fn x => if x < 0.0 then ~1 else if x = 0.0 then 0 else 1
d303 1
a303 5
    val sameSign : real * real -> bool =
      fn (r1, r2) => sign r1 = sign r2

    val toDefault : real -> real = fn x => x
    val fromDefault : real -> real = fn x => x
d305 1
a305 3
    val floor : real -> int = floor
    val real : int -> real = real
  end
@
