head	1.15;
access;
symbols
	MLW_daveb_inline_1_4_99:1.15.1
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.12
	MLWorks_20c0_1998_08_04:1.12
	MLWorks_20b2c2_1998_06_19:1.12
	MLWorks_20b2_Windows_1998_06_12:1.12
	MLWorks_20b1c1_1998_05_07:1.12
	MLWorks_20b0_1998_04_07:1.12
	MLWorks_20b0_1998_03_20:1.12
	MLWorks_20m2_1998_02_16:1.12
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.10.1.1.1.1.1
	MLWorks_workspace_97:1.11.2
	MLWorks_dt_wizard:1.11.1
	MLWorks_11c0_1997_09_09:1.10.1.1.1.1
	MLWorks_10r3:1.10.1.1.3
	MLWorks_10r2_551:1.10.1.1.2
	MLWorks_11:1.10.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.1.1
	MLWorks_20m0_1997_06_20:1.11
	MLWorks_1_0_r2c2_1997_06_14:1.10.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.1
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.9.5.1.1
	MLWorks_gui_1996_12_18:1.9.6
	MLWorks_1_0_Win32_1996_12_17:1.9.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.3.1
	MLWorks_1_0_Irix_1996_11_28:1.9.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.4
	MLWorks_1_0_Unix_1996_11_14:1.9.3
	MLWorks_Open_Beta2_1996_10_11:1.9.2
	MLWorks_License_dev:1.9.1
	MLWorks_1_open_beta_1996_09_13:1.8.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.7
	MLWorks_Beta_1996_05_31:1.7
	MLWorks_Beta_1996_05_30:1.6;
locks; strict;
comment	@ * @;


1.15
date	99.02.12.16.17.50;	author mitchell;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	99.02.02.15.57.44;	author mitchell;	state Exp;
branches;
next	1.13;

1.13
date	98.10.02.13.07.50;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	97.09.25.10.13.20;	author brucem;	state Exp;
branches;
next	1.11;

1.11
date	97.05.06.15.47.57;	author daveb;	state Exp;
branches
	1.11.1.1
	1.11.2.1;
next	1.10;

1.10
date	97.03.03.12.05.39;	author daveb;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	96.10.03.15.31.13;	author io;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1
	1.9.5.1
	1.9.6.1;
next	1.8;

1.8
date	96.06.04.17.59.29;	author io;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	96.05.30.11.33.01;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	96.05.16.13.43.17;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	96.05.15.12.46.42;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.16.53.21;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.05.09.17.20.44;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.05.02.10.05.48;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.11.25.36;	author jont;	state Exp;
branches;
next	;

1.8.1.1
date	96.09.13.11.09.26;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.10.07.16.00.23;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.17.11.18.37;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.11.14.12.42.10;	author hope;	state Exp;
branches
	1.9.3.1.1.1;
next	;

1.9.3.1.1.1
date	96.11.28.14.54.03;	author hope;	state Exp;
branches;
next	;

1.9.4.1
date	96.11.22.18.02.39;	author hope;	state Exp;
branches;
next	;

1.9.5.1
date	96.12.17.17.41.35;	author hope;	state Exp;
branches
	1.9.5.1.1.1;
next	;

1.9.5.1.1.1
date	97.02.24.11.29.51;	author hope;	state Exp;
branches;
next	;

1.9.6.1
date	96.12.18.09.35.31;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	97.05.12.10.27.33;	author hope;	state Exp;
branches
	1.10.1.1.1.1
	1.10.1.1.2.1
	1.10.1.1.3.1;
next	;

1.10.1.1.1.1
date	97.07.28.18.13.37;	author daveb;	state Exp;
branches
	1.10.1.1.1.1.1.1;
next	;

1.10.1.1.1.1.1.1
date	97.10.07.11.38.47;	author jkbrook;	state Exp;
branches;
next	;

1.10.1.1.2.1
date	97.09.08.17.07.03;	author daveb;	state Exp;
branches;
next	;

1.10.1.1.3.1
date	97.09.09.14.02.21;	author daveb;	state Exp;
branches;
next	;

1.11.1.1
date	97.09.10.19.16.48;	author brucem;	state Exp;
branches;
next	;

1.11.2.1
date	97.09.11.20.47.04;	author daveb;	state Exp;
branches;
next	;

1.15.1.1
date	99.04.01.17.52.21;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.15
log
@[Bug #190507]
Use PreStringCvt instead of StringCvt
@
text
@(*  ==== INITIAL BASIS : Date structure ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: __date.sml,v $
 * Revision 1.14  1999/02/02  15:57:44  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.13  1998/10/02  13:07:50  jont
 * [Bug #30487]
 * Modify to cope with use of LargeInt.int in Time
 *
 * Revision 1.12  1997/09/25  10:13:20  brucem
 * [Bug #30269]
 * DATE signature has been revised.  Change structure to new specification.
 *
 * Revision 1.11  1997/05/06  15:47:57  daveb
 * [Bug #30112]
 * Changed uncurry_fmt to a value.
 *
 * Revision 1.10  1997/03/03  12:05:39  daveb
 * [Bug #1937]
 * Corrected type of scan.
 *
 * Revision 1.9  1996/10/03  15:31:13  io
 * [Bug #1614]
 * remove redundant requires
 *
 * Revision 1.8  1996/06/04  17:59:29  io
 * stringcvt -> string_cvt
 *
 * Revision 1.7  1996/05/30  11:33:01  daveb
 * ord is now at top level.
 *
 * Revision 1.6  1996/05/16  13:43:17  jont
 * Include some date clamping to avoid runtime failures
 * Use full representation of year within dates
 *
 * Revision 1.5  1996/05/15  12:46:42  jont
 * pack_words moved to pack_word
 *
 * Revision 1.4  1996/05/10  16:53:21  jont
 * Fix problems in scan
 *
 * Revision 1.3  1996/05/09  17:20:44  jont
 * Bring up to latest revision of basis
 *
 * Revision 1.2  1996/05/02  10:05:48  stephenb
 * Update wrt change in Time implementation.
 * Also partially reimplemented it inline with the lastest basis definition.
 *
 * Revision 1.1  1996/04/18  11:25:36  jont
 * new unit
 *
 *  Revision 1.1  1995/04/13  13:15:51  jont
 *  new unit
 *  No reason given
 *
 *
 *)

require "../system/__time";
require "date";
require "__string";
require "__pre_string_cvt";
require "__pre_basis";
require "__int";

(* This makes use of routines in the runtime system for
     Date.localOffset
     Date.fromTimeLocal
     Date.fromTimeUniv
     Date.toTime
     Date.toString
   The rts routines will be sensitive to any changes in the 
   datatypes within this structure.
 *)

structure Date : DATE =
  struct


    val env = MLWorks.Internal.Runtime.environment


    datatype weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun
      
    datatype month = Jan | Feb | Mar | Apr | May | Jun
                   | Jul | Aug | Sep | Oct | Nov | Dec


    (* ``date value represents an instant in a particular time zone,''
       it contains the timezone (as a Time.time option, representing
       the time west from GMT (NONE is local-time), and the logical date. *)
    (* The user cannot manipulate dates directly.  All values of type date
       should be valid (internally consistent). *)
    datatype date = DATE of
      {
       year : int, (* e.g. 1997 *)
       month : month,
       day : int, (* day of month, 1st is day 1 *)
       hour : int,
       minute : int,
       second : int,
       wday : weekday,
       yday : int, (* day of the year, 1st Jan. is day 1. *)
       offset : Time.time option, (* Time west of GM, in range 0..24 hrs *)
       isDst : bool option
       }


    (* Exception `Date' is raised if an invalid date is encountered
       or would be produced. *)
    exception Date
    val dateRef : exn ref = env "Date.Date"
    val _ = dateRef := Date


    (* Extractors: *)
    fun year (DATE{year, ...}) = year
    fun month (DATE{month, ...}) = month
    fun day (DATE{day, ...}) = day
    fun hour (DATE{hour, ...}) = hour
    fun minute (DATE{minute, ...}) = minute
    fun second (DATE{second, ...}) = second
    fun weekDay (DATE{wday, ...}) = wday
    fun yearDay (DATE{yday, ...}) = yday
    fun isDst (DATE{isDst, ...}) = isDst 
    fun offset (DATE{offset, ...}) = offset
    

    local (* Local functions for function `date' *)

      (* Functions to convert a date into canonical form.
       * Assumptions:
       *   Gregorian calendar
       *   Leap years every 4 years, excluding centuries; also every 400 years
       *   Ignores leap seconds
       *   Ignores Daylight Saving Time
       *)

      fun leapYear year = 
        (year mod 4 = 0 andalso year mod 100 <> 0) orelse
        year mod 400 = 0

      fun dayOfWeek 0 = Mon
      |   dayOfWeek 1 = Tue
      |   dayOfWeek 2 = Wed
      |   dayOfWeek 3 = Thu
      |   dayOfWeek 4 = Fri
      |   dayOfWeek 5 = Sat
      |   dayOfWeek 6 = Sun
      |   dayOfWeek _ = raise Fail "dayOfWeek"

      (*
         offset must be between 0 and 24 hours.
         This function returns canonical offset and excess time
         to be added to the date.
         If you claim to be in timezone with offset=25 hours then
         the result date will be in timezone with offset=1 hour and
         the rest of the date will be one day ahead.
       *)
      fun makeOffset NONE = (NONE, 0)
        | makeOffset (SOME offset) = 
          let
            val secs = Time.toSeconds offset
            val offsetSecs = secs mod (60 * 60 * 24)
            val excessSecs = secs - offsetSecs
            val offset' = Time.fromSeconds offsetSecs
          in
            (SOME offset', excessSecs)
          end

      (* This implementation of dayToYear is based on the calendar facility
       * distributed with GNU emacs.  The emacs code was written by
       * Edward M. Reingold.
       *)
      fun dayToYear (day, year) =
        if year <= 0 then
          raise Date
        else
          let

            (* First, convert the year into a number of days since the
               imaginary date Sunday, December 31, 1 BC.  That's what the
               emacs code claims, but we seem to have day
               0 = Monday, Jan 1, 1 AD.  Maybe they count their days from 1. *)

            val priorYears = year - 1
            val absYear =
               365 * priorYears +    (* Days in prior years *)
               priorYears div 4 -    (* Julian leap years *)
               priorYears div 100 +  (* Century years *)
               priorYears div 400    (* Gregorian leap years *)

            (* Now adjust this by the number of days in this year. *)
            val absDay = Int.toLarge absYear + day

            (* The day of the week is now easy. *)
            val weekDay = dayOfWeek (Int.fromLarge((absDay-1) mod 7))

            (* Now convert the absolute number of days into the real year
               and day.  See the footnote on page 384 of ``Calendrical
               Calculations, Part II: Three Historical Calendars'' by
               E. M. Reingold,  N. Dershowitz, and S. M. Clamen,
               Software--Practice and Experience, Volume 23, Number 4
               (April, 1993), pages 383-404 for an explanation. *)

            val oneYear = 365
            val fourYears = 4 * oneYear + 1
            val oneHundredYears = 25 * fourYears - 1 
            val fourHundredYears = 4 * oneHundredYears + 1
            val d0 = absDay - 1
            val n400 = d0 div fourHundredYears (* number of 400 years *)
            val d1 = d0 mod fourHundredYears (* part of 400 years *)
            val n100 = d1 div oneHundredYears (* number of 100 years (0..3) *)
            val d2 = d1 mod oneHundredYears (* part of 100 years *)
            val n4 = d2 div fourYears (* number of 4 years (0..24) *)
            val d3 = d2 mod fourYears (* part of 4 years *)
            val n1 = d3 div oneYear (* number of years (0..3) *)
            val day' = d3 mod oneYear + 1 (* part of year (1.. ) *)
            val year' = n400 * 400 + n100 * 100 + n4 * 4 + n1
          in
	    (weekDay, Int.fromLarge day', Int.fromLarge(year' + 1))
          end (* of fun dayToYear *)

      val months =
        [(Jan,31),
         (Feb,28),
         (Mar,31),
         (Apr,30),
         (May,31),
         (Jun,30),
         (Jul,31),
         (Aug,31),
         (Sep,30),
         (Oct,31),
         (Nov,30),
         (Dec,31)]

      val leapMonths =
        [(Jan,31),
         (Feb,29),
         (Mar,31),
         (Apr,30),
         (May,31),
         (Jun,30),
         (Jul,31),
         (Aug,31),
         (Sep,30),
         (Oct,31),
         (Nov,30),
         (Dec,31)]

      fun dayToMonth' (day, []) =
            raise Fail ("dayToMonth excess="^(Int.toString day))
      |   dayToMonth' (day, (month,length) :: l) =
            if day <= length then
              (day, month) (* Both year and month days number from 1 *)
            else
              dayToMonth' (day - length, l)

      (* Given (day in year, year) return (day in month, month) *)
      fun dayToMonth (day, year) = 
            if leapYear year then
              dayToMonth' (day, leapMonths)
            else
              dayToMonth' (day, months)

      fun mkYearDay' (month, day, []) = raise Fail "yearDay'"
      |   mkYearDay' (month, day, (month', length) :: l) =
            if month = month' then
                day (* Both month and year days number from 1 *)
            else
              mkYearDay' (month, day + length, l)

      (* mkYearDay : int * Month * int -> int
         Usage: mkYearDay (year, month, dayOfMonth)
                Returns the day of the year for the given date. *)
      fun mkYearDay (year, month, day) =
            if leapYear year then
              mkYearDay' (month, day, leapMonths)
            else
              mkYearDay' (month, day, months)

    in

      (* Offset is not checked for validity or manipulated in any way.
         Perhaps it should be range checked? *)

      fun date {year, month, day, hour, minute, second, offset} =
        let
          val (offset', excessSecs) = makeOffset offset
          val yday = mkYearDay (year, month, day)
          val second' = Int.toLarge second + excessSecs
          val (second'', adjMinute) = (Int.fromLarge(second' mod 60),
				       Int.toLarge minute + second' div 60)
          val (minute', adjHour) = (Int.fromLarge(adjMinute mod 60),
				    Int.toLarge hour + adjMinute div 60)
          val (hour', adjDay) = (Int.fromLarge(adjHour mod 24), Int.toLarge yday + adjHour div 24)
          val (wday', yday', year') = dayToYear (adjDay, year)
          val (day', month') = dayToMonth (yday', year')
        in
          DATE
            {year = year', month = month', day = day',
             hour = hour' , minute = minute', second = second'',
             wday = wday', yday = yday',
             offset = offset', isDst = NONE}
        end (* of fun date *)

    end (* of local surrounding fun date *)


    val localOffset   : unit      -> Time.time = env "Date.localOffset"

    val fromTimeLocal : Time.time -> date      = env "Date.fromTimeLocal"

    val fromTimeUniv  : Time.time -> date      = env "Date.fromTimeUniv"

    val toTime        : date      -> Time.time = env "Date.toTime"

    val toString      : date      -> string    = env "Date.toString"


    local (* functions for function fromString *)

      fun ignore_space((s, i, size)) =
        if i >= size then
          i
        else
          let
            val ch = String.sub(s, i)
          in
            if PreBasis.isSpace ch then ignore_space(s, i+1, size) else i
          end

      val ignore_space = fn (s, i) => ignore_space(s, i, size s)

      fun check_space(s, i) =
        if i >= size s orelse String.sub(s, i) <> #" " then raise Date else ()
        
      fun three_char_string(s, i) = String.substring(s, i, 3)
      
      (* We must check that a valid day is given, though the result
         of this is not actually used. *)
      fun day_of_string "Mon" = Mon
        | day_of_string "Tue" = Tue
        | day_of_string "Wed" = Wed
        | day_of_string "Thu" = Thu
        | day_of_string "Fri" = Fri
        | day_of_string "Sat" = Sat
        | day_of_string "Sun" = Sun
        | day_of_string _ = raise Date

      fun mon_of_string "Jan" = Jan
        | mon_of_string "Feb" = Feb
        | mon_of_string "Mar" = Mar
        | mon_of_string "Apr" = Apr
        | mon_of_string "May" = May
        | mon_of_string "Jun" = Jun
        | mon_of_string "Jul" = Jul
        | mon_of_string "Aug" = Aug
        | mon_of_string "Sep" = Sep
        | mon_of_string "Oct" = Oct
        | mon_of_string "Nov" = Nov
        | mon_of_string "Dec" = Dec
        | mon_of_string _ = raise Date

      fun digit_to_int #"0" = 0
        | digit_to_int #"1" = 1
        | digit_to_int #"2" = 2
        | digit_to_int #"3" = 3
        | digit_to_int #"4" = 4
        | digit_to_int #"5" = 5
        | digit_to_int #"6" = 6
        | digit_to_int #"7" = 7
        | digit_to_int #"8" = 8
        | digit_to_int #"9" = 9
        | digit_to_int _ = raise Date

      fun read_mon_day(s, i) =
        let
          val ch = String.sub(s, i)
          val ch' = String.sub(s, i+1)
          val d = digit_to_int ch'
        in
          if ch = #" " then d else d + 10*digit_to_int ch
        end

      fun read_two_digits(s, i) =
        if i+1 >= size s then
          raise Date
        else
          10*digit_to_int(String.sub(s, i)) + digit_to_int(String.sub(s, i+1))

      fun check_colon(s, i) =
        if i >= size s orelse String.sub(s, i) <> #":" then raise Date else ()

      fun check_size(s, i) = if i + 24 <= size s then () else raise Date

    in
      
      (* Input to fromString must be of form
          "Mon Sep 22 11:05:51 1997"
         i.e. a `24 character date.'  If input is not of this form or
         cannot be represented as a date then NONE is returned.
         The function will not raise Date. *)

      fun fromString s =
        let
          val i = ignore_space(s, 0)
          val _ = check_size(s, i)
          val wday = three_char_string(s, i)
          val _ = check_space(s, i+3)
          val mon = three_char_string(s, i+4)
          val month = mon_of_string mon
          val _ = check_space(s, i+7)
          val mon_day = read_mon_day(s, i+8)	  
          val _ = check_space(s, i+10)
          val hour = read_two_digits(s, i+11)
          val _ = check_colon(s, i+13)
          val min = read_two_digits(s, i+14)
          val _ = check_colon(s, i+16)
          val sec = read_two_digits(s, i+17)
          val _ = check_space(s, i+19)
          val hi_year = read_two_digits(s, i+20)
          val lo_year = read_two_digits(s, i+22)
          val year = if hi_year <19 then
                       raise Date
                     else
                       hi_year*100+lo_year
        in

          (* Basis specification says:
               ``[Date.fromString] ignores the weekday (if supplied)
               and recomputes it on the basis of other fields.''
             So we call date to make the date.
             This will also make the date canonical and do range
             checks. *)
          SOME
            (date{year = year, month = month, day = mon_day,
                  hour = hour, minute = min, second = sec,
                  offset = NONE})

        end
        handle Date => NONE
      (* end of fun fromString *)

    end (* of local surrounding fun fromString *)


    fun scan getc stream =
      let
        val orig_stream = stream
        val stream = PreStringCvt.skipWS getc stream          
      in
        case PreStringCvt.getNChar 24 getc stream of
          NONE => NONE
        | SOME(charlist, stream) =>
            let val string = implode charlist
            in
              case fromString string of
                SOME date => SOME (date, stream)
              | NONE => NONE
            end handle Date => NONE
      end


    val uncurry_fmt = env "Date.fmt": string * date -> string
    fun fmt string date = uncurry_fmt(string, date)
      

    local (* functions for compare *)

      fun number_order(n : int, n') =
        if n < n' then LESS
        else
          if n > n' then GREATER
          else EQUAL

      fun month_number Jan = 0
        | month_number Feb = 1
        | month_number Mar = 2
        | month_number Apr = 3
        | month_number May = 4
        | month_number Jun = 5
        | month_number Jul = 6
        | month_number Aug = 7
        | month_number Sep = 8
        | month_number Oct = 9
        | month_number Nov = 10
        | month_number Dec = 11

      fun month_order(m, m') = number_order(month_number m, month_number m')

    in

      (* Ignore timezone offset and DST information, and just compare
         dates using the year, month, day, hour, minute and second
         information.
         We compare month and day, but yday could be used instead. *)
      fun compare
        (DATE{year,
              month,
              day,
              hour,
              minute,
              second,
              ...},
         DATE{year=year',
              month=month',
              day=day',
              hour=hour',
              minute=minute',
              second=second',
              ...}) =
        if year < year' then
          LESS
        else
          if year > year' then
            GREATER
          else
            let
              val order = month_order(month, month')
            in
              if order = EQUAL then
                if day < day' then
                  LESS
                else
                  if day > day' then
                    GREATER
                  else
                    if hour < hour' then
                      LESS
                    else
                      if hour > hour' then
                        GREATER
                      else
                        if minute < minute' then
                          LESS
                        else
                          if minute > minute' then
                            GREATER
                          else
                            number_order(second, second')
              else
                order
            end (* of fun compare *)

    end (* of local surrounding fun compare *)


  end (* of structure *)
@


1.15.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 4
 * Revision 1.15  1999/02/12  16:17:50  mitchell
 * [Bug #190507]
 * Use PreStringCvt instead of StringCvt
 *
@


1.14
log
@[Bug #190500]
Remove redundant require statements
@
text
@d10 4
d460 1
a460 1
        val stream = StringCvt.skipWS getc stream          
d462 1
a462 1
        case StringCvt.getNChar 24 getc stream of
@


1.13
log
@[Bug #30487]
Modify to cope with use of LargeInt.int in Time
@
text
@d10 4
a68 1
require "__large_int";
@


1.12
log
@[Bug #30269]
DATE signature has been revised.  Change structure to new specification.
@
text
@d10 4
d65 1
d195 1
a195 1
            val absDay = absYear + day
d198 1
a198 1
            val weekDay = dayOfWeek ((absDay-1) mod 7)
d222 1
a222 6
            (*
            if n100 = 4 orelse n1 = 4 then
              (weekDay, 365, year')
            else
             *)
              (weekDay, day', year' + 1)
d293 6
a298 4
          val second' = second + excessSecs
          val (second'', adjMinute) = (second' mod 60, minute + second' div 60)
          val (minute', adjHour) = (adjMinute mod 60, hour + adjMinute div 60)
          val (hour', adjDay) = (adjHour mod 24, yday + adjHour div 24)
@


1.11
log
@[Bug #30112]
Changed uncurry_fmt to a value.
@
text
@d10 4
d60 11
d74 2
d77 2
d82 8
a89 2
    | Jul | Aug | Sep | Oct | Nov | Dec
      
d92 1
a92 1
       year : int,
d94 1
a94 1
       day : int,
d98 3
a100 2
       wday : weekday option,
       yday : int option,
d103 4
a106 1
      
d108 15
d124 213
a336 17
    val fromTime : Time.time -> date = env "Date.fromTime"
      
    val fromUTC : Time.time -> date = env "Date.fromUTC"
      
    fun check_date(DATE{year,
                        month,
                        day,
                        hour,
                        minute,
                        second,
                        ...}) =
      if day < 0 orelse day > 31 orelse hour < 0 orelse hour > 23
        orelse minute < 0 orelse minute > 60 orelse second < 0 orelse second > 61
        orelse year < 1900 orelse year > 2100 then
        raise Date
      else
        ()
d338 1
a338 1
    val toTime : date -> Time.time = env "Date.toTime"
d340 38
a377 12
    val toTime =
      fn date => (check_date date; toTime date)
      
    val toString : date -> string = env "Date.toString"
      
    val toString =
      fn date => (check_date date; toString date)
      
    fun ignore_space((s, i, size)) =
      if i >= size then
        i
      else
d380 2
d383 1
a383 1
          if PreBasis.isSpace ch then ignore_space(s, i+1, size) else i
d385 13
d399 37
a435 84
    val ignore_space = fn (s, i) => ignore_space(s, i, size s)
      
    fun check_space(s, i) =
      if i >= size s orelse String.sub(s, i) <> #" " then raise Date else ()
        
    fun three_char_string(s, i) = String.substring(s, i, 3)
      
    fun day_of_string "Mon" = Mon
      | day_of_string "Tue" = Tue
      | day_of_string "Wed" = Wed
      | day_of_string "Thu" = Thu
      | day_of_string "Fri" = Fri
      | day_of_string "Sat" = Sat
      | day_of_string "Sun" = Sun
      | day_of_string _ = raise Date
      
    fun mon_of_string "Jan" = Jan
      | mon_of_string "Feb" = Feb
      | mon_of_string "Mar" = Mar
      | mon_of_string "Apr" = Apr
      | mon_of_string "May" = May
      | mon_of_string "Jun" = Jun
      | mon_of_string "Jul" = Jul
      | mon_of_string "Aug" = Aug
      | mon_of_string "Sep" = Sep
      | mon_of_string "Oct" = Oct
      | mon_of_string "Nov" = Nov
      | mon_of_string "Dec" = Dec
      | mon_of_string _ = raise Date
      
    fun digit_to_int #"0" = 0
      | digit_to_int #"1" = 1
      | digit_to_int #"2" = 2
      | digit_to_int #"3" = 3
      | digit_to_int #"4" = 4
      | digit_to_int #"5" = 5
      | digit_to_int #"6" = 6
      | digit_to_int #"7" = 7
      | digit_to_int #"8" = 8
      | digit_to_int #"9" = 9
      | digit_to_int _ = raise Date
      
    fun read_mon_day(s, i) =
      let
        val ch = String.sub(s, i)
        val ch' = String.sub(s, i+1)
        val d = digit_to_int ch'
      in
        if ch = #" " then d else d + 10*digit_to_int ch
      end
    
    fun read_two_digits(s, i) =
      if i+1 >= size s then
        raise Date
      else
        10*digit_to_int(String.sub(s, i)) + digit_to_int(String.sub(s, i+1))
        
    fun check_colon(s, i) =
      if i >= size s orelse String.sub(s, i) <> #":" then raise Date else ()
        
    fun check_size(s, i) = if i + 24 <= size s then () else raise Date
      
    fun fromString s =
      let
        val i = ignore_space(s, 0)
        val _ = check_size(s, i)
        val wday = three_char_string(s, i)
        val _ = check_space(s, i+3)
        val mon = three_char_string(s, i+4)
        val _ = check_space(s, i+7)
        val mon_day = read_mon_day(s, i+8)	  
        val _ = check_space(s, i+10)
        val hour = read_two_digits(s, i+11)
        val _ = check_colon(s, i+13)
        val min = read_two_digits(s, i+14)
        val _ = check_colon(s, i+16)
        val sec = read_two_digits(s, i+17)
        val _ = check_space(s, i+19)
        val hi_year = read_two_digits(s, i+20)
        val lo_year = read_two_digits(s, i+22)
      in
        if hi_year < 19 then
          NONE
        else
d437 11
a447 12
          (DATE
           {year = hi_year*100+lo_year,
            month = mon_of_string mon,
            day = mon_day,
            hour = hour,
            minute = min,
            second = sec,
            wday = SOME(day_of_string wday),
            yday = NONE,
            isDst = NONE})
      end handle Date => NONE
        
d463 2
a464 1
        
a465 1
      
d468 5
a472 6
    fun number_order(n : int, n') =
      if n < n' then
	LESS
      else
        if n > n' then
          GREATER
d474 41
a514 37
          EQUAL
          
    fun month_number Jan = 0
      | month_number Feb = 1
      | month_number Mar = 2
      | month_number Apr = 3
      | month_number May = 4
      | month_number Jun = 5
      | month_number Jul = 6
      | month_number Aug = 7
      | month_number Sep = 8
      | month_number Oct = 9
      | month_number Nov = 10
      | month_number Dec = 11
      
    fun month_order(m, m') = number_order(month_number m, month_number m')
      
    fun compare
      (DATE{year,
            month,
            day,
            hour,
            minute,
            second,
            ...},
       DATE{year=year',
            month=month',
            day=day',
            hour=hour',
            minute=minute',
            second=second',
            ...}) =
      if year < year' then
        LESS
      else
        if year > year' then
          GREATER
d516 9
a524 9
          let
            val order = month_order(month, month')
          in
            if order = EQUAL then
              if day < day' then
                LESS
              else
                if day > day' then
                  GREATER
d526 2
a527 2
                  if hour < hour' then
                    LESS
d529 2
a530 2
                    if hour > hour' then
                      GREATER
d532 2
a533 2
                      if minute < minute' then
                        LESS
d535 2
a536 2
                        if minute > minute' then
                          GREATER
d538 12
a549 5
                          number_order(second, second')
            else
              order
          end
  end
@


1.11.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 4
 * Revision 1.11  1997/05/06  15:47:57  daveb
 * [Bug #30112]
 * Changed uncurry_fmt to a value.
 *
@


1.11.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 4
 * Revision 1.11  1997/05/06  15:47:57  daveb
 * [Bug #30112]
 * Changed uncurry_fmt to a value.
 *
@


1.10
log
@[Bug #1937]
Corrected type of scan.
@
text
@d10 4
d231 1
a231 1
    fun uncurry_fmt(string, date) = env "Date.fmt"
d237 1
a237 1
        LESS
@


1.10.1.1
log
@branched from 1.10
@
text
@a9 4
 * Revision 1.10  1997/03/03  12:05:39  daveb
 * [Bug #1937]
 * Corrected type of scan.
 *
@


1.10.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 * Revision 1.10.1.1  1997/05/12  10:27:33  hope
 * branched from 1.10
 *
@


1.10.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 * Revision 1.10.1.1  1997/05/12  10:27:33  hope
 * branched from 1.10
 *
@


1.10.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 * Revision 1.10.1.1  1997/05/12  10:27:33  hope
 * branched from 1.10
 *
@


1.10.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 3
 * Revision 1.10.1.1.1.1  1997/07/28  18:13:37  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.9
log
@[Bug #1614]
remove redundant requires
@
text
@d10 4
d211 1
a211 1
    fun scan {getc} stream =
@


1.9.6.1
log
@branched from 1.9
@
text
@a9 4
 * Revision 1.9  1996/10/03  15:31:13  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.9.5.1
log
@branched from 1.9
@
text
@a9 4
 * Revision 1.9  1996/10/03  15:31:13  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.9.5.1.1.1
log
@branched from 1.9.5.1
@
text
@a9 3
 * Revision 1.9.5.1  1996/12/17  17:41:35  hope
 * branched from 1.9
 *
@


1.9.4.1
log
@branched from 1.9
@
text
@a9 4
 * Revision 1.9  1996/10/03  15:31:13  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.9.3.1
log
@branched from 1.9
@
text
@a9 4
 * Revision 1.9  1996/10/03  15:31:13  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.9.3.1.1.1
log
@branched from 1.9.3.1
@
text
@a9 3
 * Revision 1.9.3.1  1996/11/14  12:42:10  hope
 * branched from 1.9
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a9 4
 * Revision 1.9  1996/10/03  15:31:13  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a9 4
 * Revision 1.9  1996/10/03  15:31:13  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.8
log
@stringcvt -> string_cvt
@
text
@d10 3
a42 3
require "toplevel";
require "__integer";
require "__char";
d47 1
d107 1
a107 1
          if Char.isSpace ch then ignore_space(s, i+1, size) else i
d110 1
a110 1
    val ignore_space = fn (s, i) => ignore_space(s, i, String.size s)
d215 1
a215 1
            let val string = String.implode charlist
@


1.8.1.1
log
@branched from 1.8
@
text
@a9 3
 * Revision 1.8  1996/06/04  17:59:29  io
 * stringcvt -> string_cvt
 *
@


1.7
log
@ord is now at top level.
@
text
@d10 3
d45 2
d50 247
a296 275
    local
      structure String =
	struct
	  fun sub(s, i) = Char.chr(String.ordof(s, i))

	  val substring = MLWorks.String.substring

	  val size = size

	  fun implode char_list = MLWorks.String.implode(map (MLWorks.String.chr o ord) char_list)
	end
    in
      val env = MLWorks.Internal.Runtime.environment

      datatype weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun

      datatype month = Jan | Feb | Mar | Apr | May | Jun
      | Jul | Aug | Sep | Oct | Nov | Dec

      datatype date = DATE of
	{
	 year : int,
	 month : month,
	 day : int,
	 hour : int,
	 minute : int,
	 second : int,
	 wday : weekday option,
	 yday : int option,
	 isDst : bool option
	 }

      exception Date

      val fromTime : Time.time -> date = env "Date.fromTime"

      val fromUTC : Time.time -> date = env "Date.fromUTC"

      fun check_date(DATE{year,
			  month,
			  day,
			  hour,
			  minute,
			  second,
			  ...}) =
	if day < 0 orelse day > 31 orelse hour < 0 orelse hour > 23
	  orelse minute < 0 orelse minute > 60 orelse second < 0 orelse second > 61
	  orelse year < 1900 orelse year > 2100 then
	  raise Date
	else
	  ()

      val toTime : date -> Time.time = env "Date.toTime"

      val toTime =
	fn date => (check_date date; toTime date)

      val toString : date -> string = env "Date.toString"

      val toString =
	fn date => (check_date date; toString date)

      fun ignore_space((s, i, size)) =
	if i >= size then
	  i
	else
	  let
	    val ch = String.sub(s, i)
	  in
	    if Char.isSpace ch then ignore_space(s, i+1, size) else i
	  end

      val ignore_space = fn (s, i) => ignore_space(s, i, String.size s)

      fun check_space(s, i) =
	if i >= size s orelse String.sub(s, i) <> #" " then raise Date else ()

      fun three_char_string(s, i) = String.substring(s, i, 3)

      fun day_of_string "Mon" = Mon
	| day_of_string "Tue" = Tue
	| day_of_string "Wed" = Wed
	| day_of_string "Thu" = Thu
	| day_of_string "Fri" = Fri
	| day_of_string "Sat" = Sat
	| day_of_string "Sun" = Sun
	| day_of_string _ = raise Date

      fun mon_of_string "Jan" = Jan
	| mon_of_string "Feb" = Feb
	| mon_of_string "Mar" = Mar
	| mon_of_string "Apr" = Apr
	| mon_of_string "May" = May
	| mon_of_string "Jun" = Jun
	| mon_of_string "Jul" = Jul
	| mon_of_string "Aug" = Aug
	| mon_of_string "Sep" = Sep
	| mon_of_string "Oct" = Oct
	| mon_of_string "Nov" = Nov
	| mon_of_string "Dec" = Dec
	| mon_of_string _ = raise Date

      fun digit_to_int #"0" = 0
	| digit_to_int #"1" = 1
	| digit_to_int #"2" = 2
	| digit_to_int #"3" = 3
	| digit_to_int #"4" = 4
	| digit_to_int #"5" = 5
	| digit_to_int #"6" = 6
	| digit_to_int #"7" = 7
	| digit_to_int #"8" = 8
	| digit_to_int #"9" = 9
	| digit_to_int _ = raise Date

      fun read_mon_day(s, i) =
	let
	  val ch = String.sub(s, i)
	  val ch' = String.sub(s, i+1)
	  val d = digit_to_int ch'
	in
	  if ch = #" " then d else d + 10*digit_to_int ch
	end

      fun read_two_digits(s, i) =
	if i+1 >= size s then
	  raise Date
	else
	  10*digit_to_int(String.sub(s, i)) + digit_to_int(String.sub(s, i+1))

      fun check_colon(s, i) =
	if i >= size s orelse String.sub(s, i) <> #":" then raise Date else ()

      fun check_size(s, i) = if i + 24 <= size s then () else raise Date

      fun fromString s =
	let
	  val i = ignore_space(s, 0)
	  val _ = check_size(s, i)
	  val wday = three_char_string(s, i)
	  val _ = check_space(s, i+3)
	  val mon = three_char_string(s, i+4)
	  val _ = check_space(s, i+7)
	  val mon_day = read_mon_day(s, i+8)	  
	  val _ = check_space(s, i+10)
	  val hour = read_two_digits(s, i+11)
	  val _ = check_colon(s, i+13)
	  val min = read_two_digits(s, i+14)
	  val _ = check_colon(s, i+16)
	  val sec = read_two_digits(s, i+17)
	  val _ = check_space(s, i+19)
	  val hi_year = read_two_digits(s, i+20)
	  val lo_year = read_two_digits(s, i+22)
	in
	  if hi_year < 19 then
	    NONE
	  else
	    SOME
	    (DATE
	     {year = hi_year*100+lo_year,
	      month = mon_of_string mon,
	      day = mon_day,
	      hour = hour,
	      minute = min,
	      second = sec,
	      wday = SOME(day_of_string wday),
	      yday = NONE,
	      isDst = NONE})
	end handle Date => NONE

      fun ignore_stream_space(stream, getc) =
	case getc stream of
	  NONE => stream
	| SOME(ch, stream') =>
	    if Char.isSpace ch then ignore_stream_space(stream', getc) else stream

      fun read_n_chars getc =
	let
	  fun read_n_chars(n, stream, char_list) =
	    if n <= 0 then
	      (stream, String.implode(rev char_list))
	    else
	      case getc stream of
		NONE => raise Date
	      | SOME (ch, stream) => read_n_chars(n-1, stream, ch :: char_list)
	in
	  read_n_chars
	end

      fun scan {getc} stream =
	let
	  val orig_stream = stream
	  val stream = ignore_stream_space(stream, getc)
	  val (stream, string) = read_n_chars getc (24, stream, [])
	in
	  case fromString string of
	    SOME date => SOME(date, stream)
	  | NONE => NONE
	end handle Date => NONE

      fun uncurry_fmt(string, date) = env "Date.fmt"

      fun fmt string date = uncurry_fmt(string, date)

      fun number_order(n : int, n') =
	if n < n' then
	  LESS
	else
	  if n > n' then
	    GREATER
	  else
	    EQUAL

      fun month_number Jan = 0
	| month_number Feb = 1
	| month_number Mar = 2
	| month_number Apr = 3
	| month_number May = 4
	| month_number Jun = 5
	| month_number Jul = 6
	| month_number Aug = 7
	| month_number Sep = 8
	| month_number Oct = 9
	| month_number Nov = 10
	| month_number Dec = 11

      fun month_order(m, m') = number_order(month_number m, month_number m')

      fun compare
	(DATE{year,
	      month,
	      day,
	      hour,
	      minute,
	      second,
	      ...},
	 DATE{year=year',
	      month=month',
	      day=day',
	      hour=hour',
	      minute=minute',
	      second=second',
	      ...}) =
	if year < year' then
	  LESS
	else
	  if year > year' then
	    GREATER
	  else
	    let
	      val order = month_order(month, month')
	    in
	      if order = EQUAL then
		if day < day' then
		  LESS
		else
		  if day > day' then
		    GREATER
		  else
		    if hour < hour' then
		      LESS
		    else
		      if hour > hour' then
			GREATER
		      else
			if minute < minute' then
			  LESS
			else
			  if minute > minute' then
			    GREATER
			  else
			    number_order(second, second')
	      else
		order
	    end
    end
@


1.6
log
@Include some date clamping to avoid runtime failures
Use full representation of year within dates
@
text
@d10 4
d54 1
a54 1
	  fun implode char_list = MLWorks.String.implode(map (MLWorks.String.chr o Char.ord) char_list)
@


1.5
log
@pack_words moved to pack_word
@
text
@d10 3
d79 14
d95 3
d100 3
d199 1
a199 1
	     {year = (hi_year-19)*100+lo_year,
@


1.4
log
@Fix problems in scan
@
text
@d10 3
d32 1
a32 1
require "__chars";
@


1.3
log
@Bring up to latest revision of basis
@
text
@d10 3
d44 1
a44 1
	  fun implode char_list = MLWorks.String.implode(map Char.toString char_list)
d187 2
a188 2
	| SOME(ch, stream) =>
	    if Char.isSpace ch then ignore_stream_space(stream, getc) else stream
@


1.2
log
@Update wrt change in Time implementation.
Also partially reimplemented it inline with the lastest basis definition.
@
text
@d10 4
d26 1
d32 255
a286 83
    val env = MLWorks.Internal.Runtime.environment

    datatype weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun

    datatype month = Jan | Feb | Mar | Apr | May | Jun
    | Jul | Aug | Sep | Oct | Nov | Dec

    datatype date = DATE of
      {
       year : int,
       month : month,
       day : int,
       hour : int,
       minute : int,
       second : int,
       wday : weekday option,
       yday : int option,
       isDst : bool option
       }

    exception Date

    val fromTime : Time.time -> date = env "Date.fromTime"

    val fromUTC : Time.time -> date = env "Date.fromUTC"

    val toTime : date -> Time.time = env "Date.toTime"

    val toString : date -> string = env "Date.toString"

(*

    fun weekdayToString Mon = "Mon"
      | weekdayToString Tue = "Tue"
      | weekdayToString Wed = "Wed"
      | weekdayToString Thu = "Thu"
      | weekdayToString Fri = "Fri"
      | weekdayToString Sat = "Sat"
      | weekdayToString Sun = "Sun"


    fun monthToString Jan = "Jan"
      | monthToString Feb = "Feb"
      | monthToString Mar = "Mar"
      | monthToString Apr = "Apr"
      | monthToString May = "May"
      | monthToString Jun = "Jun"
      | monthToString Jul = "Jul"
      | monthToString Aug = "Aug"
      | monthToString Sep = "Sep"
      | monthToString Oct = "Oct"
      | monthToString Nov = "Nov"
      | monthToString Dec = "Dec"


    fun twoDigitInt x =
      let
        val str = Int.toString x
      in
        if size str = 1 then "0" ^ str else str
      end



    fun toString (DATE {year, month, day, hour, minute, second, wday, ...}) =
      String.implode 
        [ weekdayToString wday
        , " "
        , monthToString month
        , " "
        , twoDigitInt day
        , " "
        , twoDigitInt hours
        , ":"
        , twoDigitInt minutes
        , ":"
        , twoDigitInt seconds
        , " "
        , Int.toString (1900+year)
        ]

*)

@


1.1
log
@new unit
@
text
@d9 4
a12 1
 *  $Log$
d20 3
a22 1
require "__time";
d27 2
d36 1
a36 1
       year : int, (* since 1900 *)
d38 7
a44 7
       day : int, (* 1 - 31 *)
       hour : int, (* 0 - 23 *)
       minute : int, (* 0 - 59 *)
       second : int, (* 0 - 61 to allow for leap seconds *)
       offset : int, (* +/- from GMT? *)
       zone : string,
       wday : weekday
d47 11
a57 1
    type timezone = MLWorks.Time.zone
d59 7
a65 2
    val localTZ = MLWorks.Time.LOCAL
    val univTZ = MLWorks.Time.GREENWICH
a66 90
    exception Date
    type tm =
      {hour : int,
       isdst : int,
       mday : int,
       min : int,
       mon : int,
       sec : int,
       wday : int,
       yday : int,
       year : int}

    fun day_to_int Mon = 1
      | day_to_int Tue = 2
      | day_to_int Wed = 3
      | day_to_int Thu = 4
      | day_to_int Fri = 5
      | day_to_int Sat = 6
      | day_to_int Sun = 0

    fun int_to_day 1 = Mon
      | int_to_day 2 = Tue
      | int_to_day 3 = Wed
      | int_to_day 4 = Thu
      | int_to_day 5 = Fri
      | int_to_day 6 = Sat
      | int_to_day 0 = Sun
      | int_to_day _ = raise Date

    fun month_to_int Jan = 0
      | month_to_int Feb = 1
      | month_to_int Mar = 2
      | month_to_int Apr = 3
      | month_to_int May = 4
      | month_to_int Jun = 5
      | month_to_int Jul = 6
      | month_to_int Aug = 7
      | month_to_int Sep = 8
      | month_to_int Oct = 9
      | month_to_int Nov = 10
      | month_to_int Dec = 11

    fun int_to_month 0 = Jan
      | int_to_month 1 = Feb
      | int_to_month 2 = Mar
      | int_to_month 3 = Apr
      | int_to_month 4 = May
      | int_to_month 5 = Jun
      | int_to_month 6 = Jul
      | int_to_month 7 = Aug
      | int_to_month 8 = Sep
      | int_to_month 9 = Oct
      | int_to_month 10 = Nov
      | int_to_month 11 = Dec
      | int_to_month _ = raise Date

    fun date_to_tm(DATE{year, month, day, hour, minute, second, offset, zone, wday}) =
      {sec = second,
       min = minute,
       hour = hour,
       mday = day,
       mon = month_to_int month,
       year = year,
       wday = day_to_int wday,
       yday = 0, (* Irrelevant for call to C *)
       isdst = ~1 (* unknown *)}

    fun tm_to_date
      {sec,
       min,
       hour,
       mday,
       year,
       mon,
       wday,
       yday,
       isdst} =
      DATE
      {year = year,
       month = int_to_month mon,
       day = mday,
       hour = hour,
       minute = min,
       second = sec,
       offset = 0, (* This doesn't seem to be available *)
       zone = "",
       wday = int_to_day wday}

    val localTimeToTm : Time.time -> tm =
      MLWorks.Internal.Value.cast(MLWorks.Internal.Runtime.environment"time localtime")
d68 12
a79 2
    val gmTimeToTm : Time.time -> tm =
      MLWorks.Internal.Value.cast(MLWorks.Internal.Runtime.environment"time gmtime")
a80 2
    val tmToTime : tm -> Time.time =
      MLWorks.Internal.Value.cast(MLWorks.Internal.Runtime.environment"time mktime")
d82 1
a82 2
    val timeToDate : Time.time * timezone -> date =
      fn (time, MLWorks.Time.LOCAL) =>
d84 1
a84 1
	val tm = localTimeToTm time
d86 1
a86 15
	tm_to_date tm
      end
       | (time, MLWorks.Time.GREENWICH) =>
	   let
	     val tm = gmTimeToTm time
	   in
	     tm_to_date tm
	   end
      
    val dateToTime : date -> Time.time =
      fn x =>
      let
	val tm = date_to_tm x
      in
	tmToTime tm
a88 1
    val localTime : Time.time -> date = fn x => timeToDate(x, localTZ)
d90 21
a110 1
  end (* DATE *)
@
