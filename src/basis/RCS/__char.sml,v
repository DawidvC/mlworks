head	1.7;
access;
symbols
	MLW_daveb_inline_1_4_99:1.7.1
	MLWorks_21c0_1999_03_25:1.7
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.6
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.6.8.1.1.1.1
	MLWorks_workspace_97:1.6.10
	MLWorks_dt_wizard:1.6.9
	MLWorks_11c0_1997_09_09:1.6.8.1.1.1
	MLWorks_10r3:1.6.8.1.3
	MLWorks_10r2_551:1.6.8.1.2
	MLWorks_11:1.6.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.8.1
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.6.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.8
	MLWorks_BugFix_1997_04_24:1.6
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.6.1.1
	MLWorks_gui_1996_12_18:1.6.7
	MLWorks_1_0_Win32_1996_12_17:1.6.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.4.1
	MLWorks_1_0_Irix_1996_11_28:1.6.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.5
	MLWorks_1_0_Unix_1996_11_14:1.6.4
	MLWorks_Open_Beta2_1996_10_11:1.6.3
	MLWorks_License_dev:1.6.2
	MLWorks_1_open_beta_1996_09_13:1.6.1
	MLWorks_Open_Beta_1996_08_22:1.6
	MLWorks_Beta_1996_07_02:1.6
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.4
	MLWorks_Beta_1996_05_31:1.4
	MLWorks_Beta_1996_05_30:1.4;
locks; strict;
comment	@ *  @;


1.7
date	99.02.17.14.31.32;	author mitchell;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	96.06.24.10.36.13;	author io;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1
	1.6.6.1
	1.6.7.1
	1.6.8.1
	1.6.9.1
	1.6.10.1;
next	1.5;

1.5
date	96.06.04.18.54.09;	author io;	state Exp;
branches;
next	1.4;

1.4
date	96.05.21.22.51.57;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.05.18.00.18.34;	author io;	state Exp;
branches;
next	1.2;

1.2
date	96.05.16.14.21.35;	author io;	state Exp;
branches;
next	1.1;

1.1
date	96.05.15.12.42.49;	author jont;	state Exp;
branches;
next	;

1.6.1.1
date	96.09.13.11.09.25;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.10.07.16.00.22;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.10.17.11.18.36;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.11.14.12.42.09;	author hope;	state Exp;
branches
	1.6.4.1.1.1;
next	;

1.6.4.1.1.1
date	96.11.28.14.54.02;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	96.11.22.18.02.38;	author hope;	state Exp;
branches;
next	;

1.6.6.1
date	96.12.17.17.41.34;	author hope;	state Exp;
branches
	1.6.6.1.1.1;
next	;

1.6.6.1.1.1
date	97.02.24.11.29.50;	author hope;	state Exp;
branches;
next	;

1.6.7.1
date	96.12.18.09.35.30;	author hope;	state Exp;
branches;
next	;

1.6.8.1
date	97.05.12.10.27.32;	author hope;	state Exp;
branches
	1.6.8.1.1.1
	1.6.8.1.2.1
	1.6.8.1.3.1;
next	;

1.6.8.1.1.1
date	97.07.28.18.13.38;	author daveb;	state Exp;
branches
	1.6.8.1.1.1.1.1;
next	;

1.6.8.1.1.1.1.1
date	97.10.07.11.38.48;	author jkbrook;	state Exp;
branches;
next	;

1.6.8.1.2.1
date	97.09.08.17.07.05;	author daveb;	state Exp;
branches;
next	;

1.6.8.1.3.1
date	97.09.09.14.02.22;	author daveb;	state Exp;
branches;
next	;

1.6.9.1
date	97.09.10.19.16.49;	author brucem;	state Exp;
branches;
next	;

1.6.10.1
date	97.09.11.20.47.06;	author daveb;	state Exp;
branches;
next	;

1.7.1.1
date	99.04.01.17.52.22;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.7
log
@[Bug #190507]
Modify to satisfy CM constraints.
@
text
@(*  ==== INITIAL BASIS : structure Char ====
 *
 *  Copyright (C) 1996 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: __char.sml,v $
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
 *  Revision 1.5  1996/06/04  18:54:09  io
 *  stringcvt -> string_cvt
 *
 *  Revision 1.4  1996/05/21  22:51:57  io
 *  ** No reason given. **
 *
 *  Revision 1.3  1996/05/18  00:18:34  io
 *  fromCString
 *
 *  Revision 1.2  1996/05/16  14:21:35  io
 *  fix fromString, scan
 *
 *  Revision 1.1  1996/05/15  12:42:49  jont
 *  new unit
 *
 * Revision 1.6  1996/05/15  10:27:38  io
 * further mods to fromString, scan
 *
 * Revision 1.5  1996/05/13  17:56:33  io
 * update toString
 *
 * Revision 1.4  1996/05/13  15:22:22  io
 * complete toString
 *
 * Revision 1.3  1996/05/07  21:04:48  io
 * revising...
 *
 *)
require "char";
require "__pre_char";
structure Char : CHAR = PreChar
@


1.7.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 4
 *  Revision 1.7  1999/02/17  14:31:32  mitchell
 *  [Bug #190507]
 *  Modify to satisfy CM constraints.
 *
@


1.6
log
@unconstrain Char so that scanc can be seen by other basis routines
@
text
@d10 3
d43 1
a43 1
structure Char : CHAR = Char
@


1.6.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.6.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.6.8.1
log
@branched from 1.6
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.6.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 *  Revision 1.6.8.1  1997/05/12  10:27:32  hope
 *  branched from 1.6
 *
@


1.6.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 *  Revision 1.6.8.1  1997/05/12  10:27:32  hope
 *  branched from 1.6
 *
@


1.6.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 *  Revision 1.6.8.1  1997/05/12  10:27:32  hope
 *  branched from 1.6
 *
@


1.6.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 3
 *  Revision 1.6.8.1.1.1  1997/07/28  18:13:38  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.6.7.1
log
@branched from 1.6
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.6.6.1
log
@branched from 1.6
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.6.6.1.1.1
log
@branched from 1.6.6.1
@
text
@a9 3
 *  Revision 1.6.6.1  1996/12/17  17:41:34  hope
 *  branched from 1.6
 *
@


1.6.5.1
log
@branched from 1.6
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.6.4.1
log
@branched from 1.6
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.6.4.1.1.1
log
@branched from 1.6.4.1
@
text
@a9 3
 *  Revision 1.6.4.1  1996/11/14  12:42:09  hope
 *  branched from 1.6
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a9 3
 *  Revision 1.6  1996/06/24  10:36:13  io
 *  unconstrain Char so that scanc can be seen by other basis routines
 *
@


1.5
log
@stringcvt -> string_cvt
@
text
@d10 3
a37 2
require "toplevel";
require "__pre_basis";
d39 2
a40 262
require "__integer";
require "__pre_string_cvt";
structure Char = 
  struct
    (* local *)
    val makestring : char -> string = fn c=>
      let val alloc_s = unsafe_alloc_string (1+1)
      in unsafe_string_update(alloc_s, 0, ctoi c);
        alloc_s
      end
    (* end of local *)
    type char = char
    type string = string
    val chr = chr
    val ord = ord 
    (*      = ctoi *)
    val maxOrd = 255
    val minChar : char = #"\000"
    val maxChar : char = chr maxOrd
    fun succ (c:char) = 
      if c < maxChar then
        itoc ((ord c) + 1)
      else
        raise Chr
    fun pred (c:char) = 
      if c > minChar then
        itoc ((ord c)-1)
      else
        raise Chr
    fun compare (c:char, d:char):order = 
      if c < d then 
        LESS 
      else if c > d then 
        GREATER 
      else EQUAL
    fun contains "" = (fn _=>false)
      | contains s =
      let val size = size s in
        fn c=>
        let fun aux i = 
          if i < size then
            unsafe_string_char_sub (s, i) = c orelse aux (i+1)
          else
            false
        in
          aux 0
         end
      end

    fun notContains "" = (fn _=>true)
      | notContains s = 
      let val size = size s in
        fn c=>
        let fun aux i = 
          if i < size then
            unsafe_string_char_sub (s, i) <> c andalso aux (i+1)
          else
            true
        in
          aux 0
        end
      end
    local 
      val ascii_limit = chr 127 (* DEL *)
    in
    fun isDigit c = #"0" <= c andalso c <= #"9" 
    fun isLower c = #"a" <= c andalso c <= #"z"
    fun isUpper c = #"A" <= c andalso c <= #"Z"
    fun isAscii c = minChar <= c andalso c <= ascii_limit
    fun isAlpha c = isLower c orelse isUpper c
    fun isAlphaNum c = isDigit c orelse isAlpha c
    fun isSpace c = PreBasis.isSpace c
    fun toLower c = 
      if isUpper c then
        itoc (ord c - ord #"A" + ord #"a")
      else c
    fun toUpper c = 
      if isLower c then
        itoc (ord c - ord #"a" + ord #"A")
      else c
    fun isHexDigit (c:char) = 
      isDigit c orelse 
      (#"a" <= c andalso c <= #"f") orelse
      (#"A" <= c andalso c <= #"F")
    fun isOctDigit (c:char) = 
      #"0" <= c andalso c <= #"7"
      
    fun isCntrl (c:char) = #"\000" <= c andalso c <= #"\031"
    fun isPrint (c:char) = #"\032" <= c andalso c <  ascii_limit
    fun isGraph (c:char) = #"\032" <  c andalso c <  ascii_limit
    fun isPunct (c:char) : bool = isGraph c andalso not (isAlphaNum c)
  end

    exception ToString of char
    fun toString (c:char) = 
      if isPrint c then
        case c of
          #"\\" => "\\\\"
        | #"\"" => "\\\""
        | _ => makestring c
      else if isCntrl c orelse c < #"\032" then
        case c of
          #"\a" => "\\a" (* Alert 7 *)
        | #"\b" => "\\b" (* Backspace 8 *)
        | #"\t" => "\\t" (* Horizontal Tab 9 *)
        | #"\n" => "\\n" (* Linefeed 10 *)
        | #"\v" => "\\v" (* Vertical Tab 11 *)
        | #"\f" => "\\f" (* Form feed 12 *)
        | #"\r" => "\\r" (* Carriage return 13 *)
        | _ => "\\^" ^ makestring (chr (ord c + ord #"@@"))
      else (* > ascii_limit *)
        "\\" ^ Int.toString (ord c)
            
    fun scan getc cs = 
      case getc cs of
        SOME (#"\\", cs) =>
          (case getc cs of
             SOME (#"n", cs) => SOME (#"\n", cs)
           | SOME (#"t", cs) => SOME (#"\t", cs)
           | SOME (#"\\", cs) => SOME (#"\\", cs)
           | SOME (#"\"", cs) => SOME (#"\"", cs)
           | SOME (#"a", cs) => SOME (#"\a", cs)
           | SOME (#"b", cs) => SOME (#"\b", cs)
           | SOME (#"v", cs) => SOME (#"\v", cs)
           | SOME (#"f", cs) => SOME (#"\f", cs)
           | SOME (#"r", cs) => SOME (#"\r", cs)
           | SOME (#"^", cs) => 
               (case getc cs of
                  SOME (c, cs) => 
                    if 64 <= ord c andalso ord c <= 95 then
                      SOME (chr (ord c - 64), cs)
                    else
                      NONE
                | NONE => NONE)
           | SOME (c, cs) =>
                  if isDigit c then
                    (case StringCvt.getNChar 2 getc cs of
                       SOME ([d, e], cs) => 
                         if isDigit d andalso isDigit e then
                           let
                             fun convert (c,d,e) = (100 * (ord c - ord #"0") + 10 * (ord d - ord #"0") + (ord e - ord #"0"))
                             val res = convert (c, d, e)
                           in
                             if 0 <= res andalso res <= maxOrd then
                               SOME (chr res, cs)
                             else
                               NONE
                           end
                         else
                           NONE
                     | _ => NONE)
                  else
                    let
                      fun dropFormat getc cs = 
                        case getc cs of
                          SOME (#"\\", cs) => scan getc cs
                        | SOME (c, cs) => 
                            if isSpace c then
                              dropFormat getc cs
                            else
                              NONE
                        | NONE => NONE
                    in
                      dropFormat getc cs
                    end
                     | NONE => NONE)
      | SOME (c, cs) => 
             if isCntrl c orelse c = #"\127" orelse (not (isAscii c)) then
               NONE 
             else 
               SOME (c, cs)
      | NONE => NONE

      fun fromString "" = NONE
        | fromString s = StringCvt.scanString scan s

      (* See A2.5.2 Character Constants in K & R *)
      fun isOctDigit (c:char) : bool = #"0" <= c andalso c <= #"7"
      exception Dummy of char
      fun scanc getc cs = 
        case getc cs of
          SOME (#"\\", cs) =>
            (case getc cs of
               SOME (#"n", cs) => SOME (#"\n", cs)
             | SOME (#"t", cs) => SOME (#"\t", cs)
             | SOME (#"\\", cs) => SOME (#"\\", cs)
             | SOME (#"\"", cs) => SOME (#"\"", cs)
             | SOME (#"a", cs) => SOME (#"\a", cs)
             | SOME (#"b", cs) => SOME (#"\b", cs)
             | SOME (#"v", cs) => SOME (#"\v", cs)
             | SOME (#"f", cs) => SOME (#"\f", cs)
             | SOME (#"r", cs) => SOME (#"\r", cs)
             | SOME (#"?", cs) => SOME (#"?", cs)
             | SOME (#"'", cs) => SOME (#"'", cs)
             | SOME (#"x", cs) => 
                 (case StringCvt.splitlN 2 isHexDigit getc cs of
                    ("", cs) => NONE 
                  | (digits, cs) =>
                      (case StringCvt.scanString (Int.scan StringCvt.HEX) digits of
                         SOME hex =>
                           if 0 <= hex andalso hex <= maxOrd then 
                             SOME (chr hex, cs)
                           else
                             NONE
                       | NONE => NONE))
             | SOME (c, cs) => 
                    if isDigit c then
                      (case StringCvt.getNChar 2 getc cs of
                         SOME ([d, e], cs) =>
                           if isOctDigit d andalso isOctDigit e then
                             let fun convert (c, d, e) = 
                               (8*8*(ord c - ord #"0")) + (8*(ord d - ord#"0")) + (ord e - ord #"0")
                                 val res = convert (c, d, e)
                             in
                               if 0 <= res andalso res <= maxOrd then
                                 SOME (chr res, cs)
                               else 
                                 NONE
                             end
                           else
                             NONE
                       | _ => NONE)
                    else
                      NONE
              | NONE => NONE)
        | SOME (c, cs) => 
               if isCntrl c orelse c = #"\127" orelse 
                 c = #"?" orelse c = #"'" orelse
                 (not (isAscii c)) then
                 NONE 
               else 
                 SOME (c, cs)
        | NONE => NONE

        
      fun fromCString "" = NONE 
        | fromCString s = StringCvt.scanString scanc s
        
      fun toCString (c:char) =
        case c of
          #"\n" => SOME "\\n"
        | #"\t" => SOME "\\t"
        | #"\v" => SOME "\\v"
        | #"\b" => SOME "\\b"
        | #"\r" => SOME "\\r"
        | #"\f" => SOME "\\f"
        | #"\a" => SOME "\\a"
        | #"\\" => SOME "\\\\"
        | #"\"" => SOME "\\\""
        | #"?" => SOME "\\?"
        | _  => 
          if isCntrl c orelse not (isAscii c) then 
            SOME ("\\" ^ StringCvt.padLeft #"0" 3 (Int.fmt StringCvt.OCT (ord c)))
          else
            SOME (makestring c)

      val op < : char * char -> bool = op <
      val op <= : char * char -> bool= op <=
      val op >  : char * char -> bool= op >
      val op >= : char * char -> bool= op >=
  end

@


1.4
log
@** No reason given. **
@
text
@d10 3
d36 2
d39 2
a40 4
require "char";
require "__pre_char";
require "__stringcvt";
structure Char : CHAR = 
d42 5
a46 17
    open PreChar
    (* misc *)
    fun revImplode ([]:char list) : string = ""
      | revImplode cs = MLWorks.String.implode_char (map PreChar.ctoi (rev cs)) (* stolen from String *)
    fun splitlN (n:int) (p:char->bool) getc src = 
      let fun aux (acc, count, cs) = 
        if count < n then
          case getc cs of
            SOME (c, cs') =>
              if p c then aux (c::acc, count+1, cs') 
              else
                (revImplode acc, cs)
          | NONE => (revImplode acc, cs)
        else
          (revImplode acc, cs)
      in
        aux ([], 0, src)
d48 34
a81 10
      fun getNChar (n:int) getc cs = 
        let 
          fun aux (acc, i, cs) = 
            if i < n then
              case getc cs of
                SOME (c, cs') => aux (c::acc, i+1, cs')
              | NONE => (acc, cs)
            else
              (acc, cs)
          val (acc, cs') = aux ([], 0, cs)
d83 11
a93 2
          if acc = [] then
            NONE
d95 3
a97 1
            SOME (rev acc, cs')
d99 36
a134 28
      fun toDigit (c:char) : int = 
        if isDigit c then
          (ord c - ord #"0")
        else
          raise Match
      (* end of misc *)

    fun toControlString (c:char):string =
      case c of
        #"\a" => "\\a" (* Alert 7 *)
      | #"\b" => "\\b" (* Backspace 8 *)
      | #"\t" => "\\t" (* Horizontal Tab 9 *)
      | #"\n" => "\\n" (* Linefeed 10 *)
      | #"\v" => "\\v" (* Vertical Tab 11 *)
      | #"\f" => "\\f" (* Form feed 12 *)
      | #"\r" => "\\r" (* Carriage return 13 *)
      | _ =>
        if ord c < 32 then
          "\\^" ^ makestring (chr ((ord c) + ord #"@@"))
        else
          "??"
          
    (* could raise Match if character was unexpected *)
    fun toString (c:char) =
      if isCntrl c orelse (ord c) < 32 then
        toControlString c 
      else if c = #"\\" orelse c = #"\"" then (* \" *)
        case c of 
d137 12
a148 2
        | _ => raise Match
      else if ord c >= 127 then 
d150 1
a150 3
      else
        makestring c

d174 1
a174 1
                    (case getNChar 2 getc cs of
d178 1
a178 1
                             fun convert (c,d,e) = (100 * (toDigit c) + 10 * (toDigit d) + (toDigit e))
d215 1
a215 1
      fun isOctDigit (c:char) : bool = zero <= c andalso c <= #"7"
d233 1
a233 1
                 (case splitlN 2 isHexDigit getc cs of
d245 1
a245 1
                      (case getNChar 2 getc cs of
d249 1
a249 1
                               (8*8*(toDigit c)) + (8*(toDigit d)) + (toDigit e)
d299 1
@


1.3
log
@fromCString
@
text
@d10 3
d41 16
d115 2
a116 2
           | (args as (SOME (#"\\", cs))) => args
           | (args as (SOME (#"\"", cs))) => args (* \" *)
d123 32
a154 4
                       (case getc cs of
                          SOME (c, cs) => 
                            if 64 <= ord c andalso ord c <= 95 then
                              SOME (chr (ord c - 64), cs)
d157 10
a166 39
                        | NONE => NONE)

           | SOME (c, cs) =>
                          if isDigit c then
                            (case getNChar 2 getc cs of
                               SOME ([d, e], cs) => 
                                 if isDigit d andalso isDigit e then
                                   let
                                     fun convert (c,d,e) = (100 * (toDigit c) + 10 * (toDigit d) + (toDigit e))
                                     val res = convert (c, d, e)
                                   in
                                     if 0 <= res andalso res <= 255 then
                                       SOME (chr res, cs)
                                     else
                                       NONE
                                   end
                                 else
                                   NONE
                             | _ => NONE)
                          else
                            let
                              fun dropFormat getc cs = 
                                case getc cs of
                                  SOME (#"\\", cs) => scan getc cs
                                | SOME (c, cs) => 
                                    if isSpace c then
                                      dropFormat getc cs
                                    else
                                      NONE
                                | NONE => NONE
                            in
                              dropFormat getc cs
                            end
         | NONE => NONE)
      | args as SOME (c, cs) => 
               if not (isPrint c) then
                 NONE
               else
                 args
d173 2
a174 2
      fun isOctDigit (c:char) : bool = zero <= c andalso c <= #"8"
        
d178 40
a217 35
            let 
              val (digits, cs) = StringCvt.splitl isOctDigit getc cs
              val ds = size digits
            in
              if ds > 0 then
                if ds <= 3 then
                  case StringCvt.scanString (Int.scan StringCvt.OCT) digits of
                    SOME oct => 
                      if 0 <= oct andalso oct <= maxOrd then SOME (chr oct, cs)
                      else NONE
                  | NONE => NONE
                else
                  NONE
              else case getc cs of
                SOME (#"n", cs) => SOME (#"\n", cs)
              | SOME (#"t", cs) => SOME (#"\t", cs)
              | SOME (#"v", cs) => SOME (#"\v", cs)
              | SOME (#"b", cs) => SOME (#"\b", cs)
              | SOME (#"r", cs) => SOME (#"\r", cs)
              | SOME (#"f", cs) => SOME (#"\a", cs)
              | SOME (#"\\", cs) =>SOME (#"\\", cs)
              | SOME (#"?", cs) => SOME (#"?", cs)
              | SOME (#"'", cs) => SOME (#"'", cs)
              | SOME (#"\"", cs) =>SOME (#"\"", cs)
              | SOME (#"x", cs) => 
                  let
                    val (digits, cs) = StringCvt.splitl (fn c=> isHexDigit c) getc cs
                    val ds = size digits 
                  in
                    if 0 < ds andalso ds <= 2 then
                      case StringCvt.scanString (Int.scan StringCvt.HEX) digits of
                        SOME hex => 
                          if 0 <= hex andalso hex <= maxOrd then SOME (chr hex, cs)
                          else NONE
                      | NONE => NONE
d220 10
a229 10
                  end
              | _ => NONE
            end
        | SOME (c, cs) =>
            if not (isAscii c) then
              SOME (c, cs)
            else
              NONE
        | _ => NONE
              
d247 3
a249 1
          if isAscii c then
a250 3
          else
            SOME ("\\" ^ StringCvt.padLeft #"0" 3 (Int.fmt StringCvt.OCT (ord c)))

@


1.2
log
@fix fromString, scan
@
text
@d10 3
d61 1
a61 1
    fun toControlString (c:char):string = 
d75 1
a75 1

d155 5
a159 25
      exception Dummy of string
    fun fromCString "" = NONE 
      | fromCString s = 
      let
        val size = size s
      in
        if size = 1 then
          SOME (chr (unsafe_string_sub (s, 0)))
        else if (chr (unsafe_string_sub (s, 0))) = #"\\" then
          if size = 2 then
            (case chr (unsafe_string_sub(s,1)) of
                #"n" => SOME #"\n"
              | #"t" => SOME #"\t"
              | #"v" => SOME #"\v"
              | #"b" => SOME #"\b"
              | #"r" => SOME #"\r"
              | #"f" => SOME #"\f"
              | #"a" => SOME #"\a"
              | #"\\" => SOME #"\\"
              | #"?" => SOME #"?"
              | #"'" => SOME #"'"
              | #"\"" => SOME #"\"" 
              | c => raise Dummy ("octal 1 character "^makestring c))
          else if size = 4 andalso chr (unsafe_string_sub (s, 1)) = #"x" then
            (* hexadecimal conversion *)
d161 2
a162 2
              val c1 = chr (unsafe_string_sub (s, 2))
              val c2 = chr (unsafe_string_sub (s, 3))
d164 35
a198 4
              if isHexDigit c1 andalso isHexDigit c2 then
                raise Dummy "fromCString hexadecimal true"
              else
                raise Dummy "fromCString hexadecimal false"
d200 29
a228 10
          else raise Dummy "fromCString octal conversion"
       else
         raise Dummy "fromCString unexpected branch"
      end

    fun toCString c = 
      if isCntrl c then
        SOME (toControlString c)
      else
        raise Dummy "toCString not control character"
d230 4
a233 4
    val op < : char * char -> bool = op <
    val op <= : char * char -> bool= op <=
    val op >  : char * char -> bool= op >
    val op >= : char * char -> bool= op >=
@


1.1
log
@new unit
@
text
@d9 4
a12 1
 *  $Log: __chars.sml,v $
d53 1
a53 1
          ctoi c - ctoi #"0"
d68 2
a69 2
        if ctoi c < 32 then
          "\\^" ^ makestring (itoc ((ctoi c) + ctoi #"@@"))
d75 1
a75 1
      if isCntrl c orelse (ctoi c) < 32 then
d82 2
a83 2
      else if ctoi c >= 127 then 
        "\\" ^ Int.toString (ctoi c)
a86 1
(* still faulty but usable *)
d89 1
a89 2
        NONE => NONE
      | SOME (#"\\", cs) =>
d91 3
a93 1
             (args as (SOME (#"\\", cs))) => args
a96 2
           | SOME (#"t", cs) => SOME (#"\t", cs)
           | SOME (#"n", cs) => SOME (#"\n", cs)
d103 2
a104 2
                            if itoc 64 <= c andalso c <= itoc 95 then
                              SOME (itoc (ctoi c - 64), cs)
d119 1
a119 1
                                       SOME (itoc res, cs)
d127 14
a140 14
                               let
                                 fun isFormat c = contains "nt " c
                                 fun aux cs = 
                                   case getc cs of
                                     SOME (c, cs) => 
                                       if isFormat c then
                                         aux (StringCvt.dropl (fn c=>c <> #"\\" ) getc cs)
                                       else
                                         scan getc cs
                                   | _ => NONE
                               in
                                 aux cs
                               end
           | NONE => NONE)
d146 1
d159 2
a160 2
          SOME (itoc (unsafe_string_sub (s, 0)))
        else if (itoc (unsafe_string_sub (s, 0))) = #"\\" then
d162 1
a162 1
            (case itoc (unsafe_string_sub(s,1)) of
d175 1
a175 1
          else if size = 4 andalso itoc (unsafe_string_sub (s, 1)) = #"x" then
d178 2
a179 2
              val c1 = itoc (unsafe_string_sub (s, 2))
              val c2 = itoc (unsafe_string_sub (s, 3))
@
