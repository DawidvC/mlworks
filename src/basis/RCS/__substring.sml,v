head	1.11;
access;
symbols
	MLW_daveb_inline_1_4_99:1.11.3
	MLWorks_21c0_1999_03_25:1.11
	MLWorks_20c1_1998_08_20:1.11
	MLWorks_20c0_1998_08_04:1.11
	MLWorks_20b2c2_1998_06_19:1.11
	MLWorks_20b2_Windows_1998_06_12:1.11
	MLWorks_20b1c1_1998_05_07:1.11
	MLWorks_20b0_1998_04_07:1.11
	MLWorks_20b0_1998_03_20:1.11
	MLWorks_20m2_1998_02_16:1.11
	MLWorks_20m1_1997_10_23:1.11
	MLWorks_11r1:1.10.7.1.1.2.1
	MLWorks_workspace_97:1.11.2
	MLWorks_dt_wizard:1.11.1
	MLWorks_11c0_1997_09_09:1.10.7.1.1.2
	MLWorks_10r3:1.10.7.1.3
	MLWorks_10r2_551:1.10.7.1.2
	MLWorks_11:1.10.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.7.1
	MLWorks_20m0_1997_06_20:1.10
	MLWorks_1_0_r2c2_1997_06_14:1.10.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.7
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.5.1.1
	MLWorks_gui_1996_12_18:1.10.6
	MLWorks_1_0_Win32_1996_12_17:1.10.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.3.1
	MLWorks_1_0_Irix_1996_11_28:1.10.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.4
	MLWorks_1_0_Unix_1996_11_14:1.10.3
	MLWorks_Open_Beta2_1996_10_11:1.10.2
	MLWorks_License_dev:1.10.1
	MLWorks_1_open_beta_1996_09_13:1.8.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.5
	MLWorks_Beta_1996_06_07:1.4
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ *  @;


1.11
date	97.08.11.09.06.20;	author brucem;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1;
next	1.10;

1.10
date	96.10.03.15.05.46;	author io;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1
	1.10.4.1
	1.10.5.1
	1.10.6.1
	1.10.7.1;
next	1.9;

1.9
date	96.10.02.20.22.43;	author io;	state Exp;
branches;
next	1.8;

1.8
date	96.07.29.23.40.36;	author io;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	96.07.29.20.21.02;	author io;	state Exp;
branches;
next	1.6;

1.6
date	96.07.29.16.07.01;	author io;	state Exp;
branches;
next	1.5;

1.5
date	96.06.07.18.07.09;	author io;	state Exp;
branches;
next	1.4;

1.4
date	96.06.07.15.26.00;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.06.04.17.56.57;	author io;	state Exp;
branches;
next	1.2;

1.2
date	96.05.23.20.06.22;	author io;	state Exp;
branches;
next	1.1;

1.1
date	96.05.17.13.59.40;	author io;	state Exp;
branches;
next	;

1.8.1.1
date	96.09.13.11.09.52;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.10.07.16.00.45;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.17.11.18.59;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.11.14.12.42.34;	author hope;	state Exp;
branches
	1.10.3.1.1.1;
next	;

1.10.3.1.1.1
date	96.11.28.14.54.26;	author hope;	state Exp;
branches;
next	;

1.10.4.1
date	96.11.22.18.03.03;	author hope;	state Exp;
branches;
next	;

1.10.5.1
date	96.12.17.17.41.58;	author hope;	state Exp;
branches
	1.10.5.1.1.1;
next	;

1.10.5.1.1.1
date	97.02.24.11.30.20;	author hope;	state Exp;
branches;
next	;

1.10.6.1
date	96.12.18.09.35.55;	author hope;	state Exp;
branches;
next	;

1.10.7.1
date	97.05.12.10.28.01;	author hope;	state Exp;
branches
	1.10.7.1.1.1
	1.10.7.1.2.1
	1.10.7.1.3.1;
next	;

1.10.7.1.1.1
date	97.07.28.18.14.27;	author daveb;	state Exp;
branches;
next	1.10.7.1.1.2;

1.10.7.1.1.2
date	97.08.11.16.29.34;	author johnh;	state Exp;
branches
	1.10.7.1.1.2.1.1;
next	;

1.10.7.1.1.2.1.1
date	97.10.07.11.39.30;	author jkbrook;	state Exp;
branches;
next	;

1.10.7.1.2.1
date	97.09.08.17.07.53;	author daveb;	state Exp;
branches;
next	;

1.10.7.1.3.1
date	97.09.09.14.03.03;	author daveb;	state Exp;
branches;
next	;

1.11.1.1
date	97.09.10.19.17.31;	author brucem;	state Exp;
branches;
next	;

1.11.2.1
date	97.09.11.20.48.16;	author daveb;	state Exp;
branches;
next	;

1.11.3.1
date	99.04.01.17.52.01;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.11
log
@[Bug #30094]
Add span.
@
text
@(*  ==== INITIAL BASIS : structure SUBSTRING ===
 *
 * Copyright (C) 1996 Harlequin Ltd.
 *
 * Description
 * -----------
 *  This is part of the extended Initial Basis. 
 *
 * $Log: __substring.sml,v $
 *  Revision 1.10  1996/10/03  15:05:46  io
 *  [Bug #1614]
 *  remove redundant requires
 *
 *  Revision 1.9  1996/10/02  20:22:43  io
 *  [Bug #1630]
 *  fix typo in sub for raising Subscript
 *
 *  Revision 1.8  1996/07/29  23:40:36  io
 *  [Bug #1509]
 *  blotched checkin
 *
 *  Revision 1.7  1996/07/29  20:21:02  io
 *  [Bug #1509]
 *  typo in size check in isPrefix
 *
 *  Revision 1.6  1996/07/29  16:07:01  io
 *  [Bug #1508]
 *  Add structure String
 *
 *  Revision 1.5  1996/06/07  18:07:09  io
 *  fix split[lr] & position
 *
 *  Revision 1.4  1996/06/07  15:26:00  io
 *  fix tokens, fields
 *
 *  Revision 1.3  1996/06/04  17:56:57  io
 *  removing __pre_char
 *
 *  Revision 1.2  1996/05/23  20:06:22  io
 *  ** No reason given. **
 *
 *  Revision 1.1  1996/05/17  13:59:40  io
 *  new unit
 *
 *)

require "substring";
require "__string";

structure Substring : SUBSTRING =
  struct
    structure String = String
    datatype substring = SS of (string * int * int)
      (* (s, i, n) 
       * string
       * index
       * size
       *)
    fun base (SS arg) : string * int * int = arg
    fun string (SS arg) : string = substring arg
    fun concat ssl = (String.concat o (map string)) ssl

    fun substring (ok as (s, i, n)) : substring =
      if 0 <= i andalso 0 <= n andalso (i+n) <= size s then
        SS ok
      else
        raise Subscript	
    fun extract (s, i, NONE) = substring (s, i, size s - i)
      | extract (s, i, SOME n) = substring (s, i, n)

    fun all (s:string) : substring = SS (s, 0, size s)
    fun isEmpty (SS (_,_,0)) : bool = true
      | isEmpty _ = false
    fun getc (SS (_, _, 0)) : (char * substring) option = NONE
      | getc (SS (s, i, n)) = SOME ( (String.sub(s, i)), SS(s, i+1, n-1))
    fun first (SS (_, _, 0)) : char option = NONE
      | first (SS (s, i, n)) = SOME ( (String.sub (s, i)))
    fun triml (k:int) (SS (s, i, n)) : substring = 
      if (k < 0) then raise Subscript
      else if (k >= n) then SS(s, i+n, 0)
           else SS (s, i+k, n-k)
    fun trimr (k:int) (SS (s, i, n)) : substring = 
      if (k < 0) then raise Subscript
      else if (k >= n) then SS(s, i, 0)
           else SS (s, i, n-k)
    fun slice (SS (s, i, n), j, m: int option) : substring =
      let val m = case m of
        NONE => n - j
      | SOME m => m
      in
        if j >= 0 andalso 
          m >= 0 andalso
          j + m <= n then
          SS (s, i+j, m)
        else
          raise Subscript
      end
    
    fun sub (SS (s, i, n), j:int):char = 
      if j < 0 orelse j >= n then raise Subscript
      else  (String.sub (s, i + j))
	

    fun explode (SS(s, i, n)) : char list = 
      let
        fun aux (acc, j) = 
          if j < i then
            acc
          else
            aux ((String.sub (s, j))::acc, j-1)
      in
        aux ([], i+n-1)
      end

    fun foldl f acc (SS (s, i, n)) = 
      let
        fun aux (acc, i') = 
          if i' < i+n then
            aux (f (String.sub(s, i'), acc), i'+1)
          else
            acc
      in
        aux (acc, i)
      end
    fun foldr f acc (SS (s, i, n)) = 
      let
        fun aux (acc, i') = 
          if i' >= i then
            aux (f (String.sub (s, i'), acc), i'-1)
          else
            acc
      in
        aux (acc, i+n-1)
      end

    fun app (f: char -> unit) (SS (s, i, n)) : unit = 
      let
        fun aux j = 
          if j < i+n then 
            let in
              f ( (String.sub (s, j)));
              aux (j+1)
            end
          else ()
      in
        aux i
      end

    (* slow versions: needs work *)
    fun collate p (ss1, ss2) = 
      String.collate p (string ss1, string ss2)
    fun compare (ss1, ss2) = 
      String.compare (string ss1, string ss2)
      
    fun splitAt (ss as SS(s,ii,nn), j) = 
      if j < 0 orelse j > nn then
        raise Subscript
      else
        (SS (s, ii, j), SS (s, ii+j, nn-j))

    fun splitl p (ss as SS(s, ii, nn)) =
      let
        val sz = ii+nn
        fun scan j = 
          if j < sz andalso p (String.sub (s, j)) then
            scan (j+1)
          else
            j
        val res = (scan ii) - ii
      in
        splitAt (ss, res)
      end

    fun splitr p (ss as SS(s,ii,nn)) =
      let 
        val sz = ii+nn
        val exit = ii-1
        fun scan j = 
          if j > exit andalso p (String.sub (s, j)) then
            scan (j-1)
          else
            j
        val res = ((scan (sz-1)) - ii)+1
      in
        splitAt (ss, res)
      end

    fun isPrefix p (ss as SS(s, i, n)) =
      let
	val sz = size p
      in
	if sz > n then false
	else
	  let
	    fun scan i = 
	      if i < sz then
		String.sub(p, i) = sub(ss, i) andalso scan (i+1)
	      else
		true
	  in
	    scan 0
	  end
      end

    fun fields p (ss as SS(s,ii,nn)) =
      let
        val sz = ii+nn
        fun substr (i, j, acc) = SS (s, i, j-i) :: acc
        fun scan (i, j, acc) = 
          if j < sz then 
            (if p (String.sub (s, j)) then
               scan (j+1, j+1, substr(i, j, acc))
             else
               scan (i, j+1, acc))
          else
            substr (i, j, acc)
      in
        rev (scan (ii, ii, []))
      end

    fun translate p (SS(s, i, n)) = 
      let
        fun aux (acc, i') = 
          if i' < i+n then
            aux (p (String.sub(s,i'))::acc, i'+1)
          else
            String.concat (rev acc)
      in
        aux ([], i)
      end
      
    fun dropl (p:char -> bool) ss : substring = #2(splitl p ss)
    fun takel (p:char -> bool) ss : substring = #1(splitl p ss)
    fun taker (p:char -> bool) ss : substring = #2(splitr p ss)
    fun dropr (p:char -> bool) ss : substring = #1(splitr p ss)

    fun position t (ss as SS (s,ii, nn)) = 
      let
        val size = size t
        val sz = ii+nn-size

        fun compare (i, j) =
          if i < size then
            (if String.sub(t, i)=String.sub(s, j) then
               compare (i+1, j+1)
             else
               false)
          else
            true

        fun scan j =
          if j <= sz then
            (if compare (0, j) then 
               j
             else
               scan (j+1))
          else
            ii+nn
        val res = (scan ii) - ii
      in
        splitAt (ss, res)
      end
            
    fun tokens p (SS (s,ii,nn)) = 
      let
        val sz = ii+nn
        fun substr (acc, x, y) = 
          if x=y then acc else SS(s, x, y-x)::acc
        fun skipSep (acc,x) = 
          if x < sz then
            if p (String.sub (s, x)) then
              skipSep(acc, x+1)
            else
              aux (acc, x, x+1)
          else
            acc
        and aux (acc, x, y) =
          if y < sz then
            if p (String.sub (s, y)) then
              skipSep (substr(acc, x, y), y+1)
            else
              aux (acc, x, y+1)
          else
            substr (acc, x, y)
      in
        rev (aux ([], ii, ii))
      end

    fun size (SS (s,i,n)) = n

    exception Span

    fun span (SS(s1, i1, n1), SS(s2, i2, n2)) =
        if (s1 = s2) andalso (i1 <= i2+n2)
        then SS(s1, i1, i2+n2-i1)
        else raise Span

  end
@


1.11.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 4
 *  Revision 1.11  1997/08/11  09:06:20  brucem
 *  [Bug #30094]
 *  Add span.
 *
@


1.11.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 4
 *  Revision 1.11  1997/08/11  09:06:20  brucem
 *  [Bug #30094]
 *  Add span.
 *
@


1.11.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 4
 *  Revision 1.11  1997/08/11  09:06:20  brucem
 *  [Bug #30094]
 *  Add span.
 *
@


1.10
log
@[Bug #1614]
remove redundant requires
@
text
@d10 4
d290 8
@


1.10.7.1
log
@branched from 1.10
@
text
@a9 4
 *  Revision 1.10  1996/10/03  15:05:46  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.10.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 *  Revision 1.10.7.1  1997/05/12  10:28:01  hope
 *  branched from 1.10
 *
@


1.10.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 *  Revision 1.10.7.1  1997/05/12  10:28:01  hope
 *  branched from 1.10
 *
@


1.10.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 *  Revision 1.10.7.1  1997/05/12  10:28:01  hope
 *  branched from 1.10
 *
@


1.10.7.1.1.2
log
@[Bug #30094]
Merging - add span.
@
text
@a9 3
 *  Revision 1.10.7.1.1.1  1997/07/28  18:14:27  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a292 8

    exception Span

    fun span (SS(s1, i1, n1), SS(s2, i2, n2)) =
        if (s1 = s2) andalso (i1 <= i2+n2)
        then SS(s1, i1, i2+n2-i1)
        else raise Span

@


1.10.7.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 4
 *  Revision 1.10.7.1.1.2  1997/08/11  16:29:34  johnh
 *  [Bug #30094]
 *  Merging - add span.
 *
@


1.10.6.1
log
@branched from 1.10
@
text
@a9 4
 *  Revision 1.10  1996/10/03  15:05:46  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.10.5.1
log
@branched from 1.10
@
text
@a9 4
 *  Revision 1.10  1996/10/03  15:05:46  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.10.5.1.1.1
log
@branched from 1.10.5.1
@
text
@a9 3
 *  Revision 1.10.5.1  1996/12/17  17:41:58  hope
 *  branched from 1.10
 *
@


1.10.4.1
log
@branched from 1.10
@
text
@a9 4
 *  Revision 1.10  1996/10/03  15:05:46  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.10.3.1
log
@branched from 1.10
@
text
@a9 4
 *  Revision 1.10  1996/10/03  15:05:46  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.10.3.1.1.1
log
@branched from 1.10.3.1
@
text
@a9 3
 *  Revision 1.10.3.1  1996/11/14  12:42:34  hope
 *  branched from 1.10
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a9 4
 *  Revision 1.10  1996/10/03  15:05:46  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a9 4
 *  Revision 1.10  1996/10/03  15:05:46  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.9
log
@[Bug #1630]
fix typo in sub for raising Subscript
@
text
@d10 4
a42 2
require "toplevel";
require "__integer";
a44 1
require "__list";
d56 3
a58 1
    fun string (SS arg) : string = String.substring arg
d63 4
a66 2
        raise Subscript
	
d217 10
a226 2
    fun concat ssl = (String.concat o (List.map string)) ssl

a227 3
    fun extract (s, i, NONE) = substring (s, i, size s - i)
      | extract (s, i, SOME n) = substring (s, i, n)

d282 1
a282 1
        List.rev (aux ([], ii, ii))
a284 10
    fun translate p (SS(s, i, n)) = 
      let
        fun aux (acc, i') = 
          if i' < i+n then
            aux (p (String.sub(s,i'))::acc, i'+1)
          else
            String.concat (rev acc)
      in
        aux ([], i)
      end
@


1.8
log
@[Bug #1509]
blotched checkin
@
text
@d10 4
d91 1
a91 1
      if j < 0 orelse j > n then raise Subscript
@


1.8.1.1
log
@branched from 1.8
@
text
@a9 4
 *  Revision 1.8  1996/07/29  23:40:36  io
 *  [Bug #1509]
 *  blotched checkin
 *
@


1.7
log
@[Bug #1509]
typo in size check in isPrefix
@
text
@d10 4
d179 1
a179 1
	if n > sz then false
@


1.6
log
@[Bug #1508]
Add structure String
@
text
@d10 4
d53 1
d81 1
d85 1
d171 1
a171 1
    fun isPrefix s' (ss as SS(s, i, n)) =
d173 1
a173 2
        val sz_s' = size s'
        val sz_ss = i+n
d175 11
a185 12
        if sz_s' > sz_ss then false
        else
          let
            fun aux i = 
              if i < sz_s' then
                String.sub(s', i) = sub (ss, i) andalso 
                aux (i+1)
              else
                true
          in
            aux 0
          end
d206 1
@


1.5
log
@fix split[lr] & position
@
text
@d10 3
d35 1
d272 1
a272 1
  end@


1.4
log
@fix tokens, fields
@
text
@d10 3
d126 3
a128 2
    fun splitAt (SS(s,i,n), k) = 
      if k < 0 orelse k > n then
d131 1
a131 1
        (SS (s, i, k), SS(s, i+k, n-k))
d133 6
a138 9

    fun splitl p (ss as SS(s,i,n)) : substring * substring = 
      let 
        fun aux j = 
          if j < i+n then
            if not (p (sub (ss, j))) then
              splitAt (ss, j)
            else
              aux (j+1)
d140 2
a141 1
            (ss, SS(s, i, 0))
d143 1
a143 1
        aux (#2(base ss))
d145 8
a152 8
    fun splitr p ss : substring * substring = 
      let
        fun aux i = 
          if i > 0 then
            if not (p (sub (ss, i))) then
              splitAt (ss, i)
            else
              aux (i-1)
d154 2
a155 1
            (ss, all "")
d157 1
a157 1
        aux (#2(base ss))
d159 1
d200 18
a217 4
    fun dropl (p:char -> bool) ss : substring = #2(splitl p ss)    (* buggy *)
    fun takel (p:char -> bool) ss : substring = #1(splitl p ss)    (* buggy *)
    fun taker (p:char -> bool) ss : substring = #2(splitr p ss)    (* buggy *)
    fun dropr (p:char -> bool) ss : substring = #1(splitr p ss)    (* buggy *)
d219 9
a227 13
    fun position t (rag as SS (s, i, n)) = 
      let
        fun aux i' = 
          if i' < i+n then
            if isPrefix t (SS(s,i',i+n-i')) then
              (i'-i)
            else
              aux (i'+1)
          else
            0
        val _ = MLWorks.IO.output
          (MLWorks.IO.std_out, 
           Int.toString (aux i))
d229 1
a229 1
        splitAt (rag, aux i)
d231 1
a231 1

@


1.3
log
@removing __pre_char
@
text
@d10 3
d175 1
a175 2
    (* buggy *)
    fun fields (isDelim:char -> bool) (ss:substring) : substring list = 
d177 10
a186 9
        val size = #3 (base ss)
        fun aux (acc, i, j) = 
          let val size' = i + j in
            if (size' = size) then ((substring (string ss, i, j)) :: acc)
            else if isDelim (sub (ss, size')) then
              aux (substring (string ss, i, j) :: acc, size'+1, 0)
            else
              aux (acc, i, j+1)
          end
d188 1
a188 1
        rev (aux ([], 0, 0))
d190 1
a200 1
    (* do not use as it is buggy *)
a216 1
    
d218 1
a218 1
    fun tokens p (SS (s,i,n)) = 
d220 1
d224 1
a224 1
          if x < i+n then
d232 1
a232 1
          if x < i+n then
a238 1

d240 1
a240 1
        aux ([], i, i)
@


1.2
log
@** No reason given. **
@
text
@d10 3
d18 1
a19 1
require "toplevel";
a20 1
require "__pre_char";
d188 3
@


1.1
log
@new unit
@
text
@d9 4
a12 1
 * $Log$
d14 2
d21 1
d41 1
a41 1
      | getc (SS (s, i, n)) = SOME (PreChar.itoc (PreChar.unsafe_string_sub(s, i)), SS(s, i+1, n-1))
d43 1
a43 1
      | first (SS (s, i, n)) = SOME (PreChar.itoc (PreChar.unsafe_string_sub (s, i)))
d66 1
a66 1
      else PreChar.itoc (PreChar.unsafe_string_sub (s, i + j))
d74 1
a74 1
            aux (Char.chr (PreChar.unsafe_string_sub (s, j))::acc, j-1)
d81 3
a83 3
        fun aux (acc, j) = 
          if j < i+n then
            aux (f (PreChar.itoc (PreChar.unsafe_string_sub (s, j)), acc), j+1)
d91 3
a93 3
        fun aux (acc, j) = 
          if j > i then
            aux (f (PreChar.itoc (PreChar.unsafe_string_sub (s, j)), acc), j-1)
d105 1
a105 1
              f (PreChar.itoc (PreChar.unsafe_string_sub (s, j)));
d119 6
a124 1
      (substring (s, i, k), substring (s, i+k, n-k))
a126 1
        val exit = i+n
d128 5
a132 3
        if j < i+n then
          if not (p (sub (ss, j))) then
            splitAt (ss, j)
d134 1
a134 3
            aux (j+1)
        else
          (ss, all "")
d136 1
a136 1
        aux 0
d151 1
a151 1
    fun isPrefix (s:string) (ss:substring) : bool = 
d153 2
a154 3
        val size_s = size s
        val size_ss = #3 (base ss)
        val offset = #2(base ss)
d156 1
a156 1
        if size_s > size_ss then false
d158 7
a164 7
          let fun aux i = 
            if i > size_s then
              true
            else if PreChar.itoc(PreChar.unsafe_string_sub (s, i)) <> sub(ss, i+offset) then
              false
            else
              aux (i+1)
d169 2
a185 8
    fun dropl (p:char -> bool) ss : substring = #2(splitl p ss)
    fun takel (p:char -> bool) ss : substring = #1(splitl p ss)
    fun taker (p:char -> bool) ss : substring = #2(splitr p ss)
    fun dropr (p:char -> bool) ss : substring = #1(splitr p ss)

    fun position "" ss = (all "", all "")
    fun tokens p (SS ("", 0, 0)) = []
    fun translate p (SS ("", 0, 0)) = ""
d187 60
a246 1
    fun size (SS arg):int = #3 arg
@
