head	1.2;
access;
symbols
	MLW_daveb_inline_1_4_99:1.2.1
	MLWorks_21c0_1999_03_25:1.2;
locks; strict;
comment	@ *  @;


1.2
date	99.02.16.09.31.39;	author mitchell;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	99.02.15.14.08.13;	author mitchell;	state Exp;
branches;
next	;

1.2.1.1
date	99.04.01.17.51.45;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
[Bug #190508]
Add socket support to the basis library
@


1.2
log
@[Bug #190508]
Improve layout
@
text
@(* socket.sml
 *
 * This file includes parts which are Copyright (c) 1995 AT&T Bell 
 * Laboratories. All rights reserved.  
 *
 * $Log: socket.sml,v $
 *  Revision 1.1  1999/02/15  14:08:13  mitchell
 *  new unit
 *  [Bug #190508]
 *  Add socket support to the basis library
 *
 *)

require "__host_db.sml";
require "__word8_array";
require "__word8_vector";
require "__time";
require "__os";

signature SOCKET =
  sig

    (* sockets are polymorphic; the instantiation of the type variables
     * provides a way to distinguish between different kinds of sockets. *)
    type ('af, 'sock) sock
    type 'af sock_addr

    (* witness types for the socket parameter *)
    type dgram
    type 'a stream
    type passive        (* for passive streams *)
    type active         (* for active (connected) streams *)

    (* address families *)
    structure AF : sig
        type addr_family = NetHostDB.addr_family
        val list : unit -> (string * addr_family) list
            (* list known address families *)
        val toString : addr_family -> string
        val fromString : string -> addr_family option
      end

    (* socket types *)
    structure SOCK : sig
        eqtype sock_type
        val stream : sock_type          (* stream sockets *)
        val dgram : sock_type           (* datagram sockets *)
        val list : unit -> (string * sock_type) list
            (* list known socket types *)
        val toString : sock_type -> string
        val fromString : string -> sock_type option
      end

    (* socket control operations *)
    structure Ctl : sig

      (* get/set socket options *)
      val getDEBUG            : ('a, 'b) sock -> bool
      val setDEBUG            : (('a, 'b) sock * bool) -> unit
      val getREUSEADDR        : ('a, 'b) sock -> bool
      val setREUSEADDR        : (('a, 'b) sock * bool) -> unit
      val getKEEPALIVE        : ('a, 'b) sock -> bool
      val setKEEPALIVE        : (('a, 'b) sock * bool) -> unit
      val getDONTROUTE        : ('a, 'b) sock -> bool
      val setDONTROUTE        : (('a, 'b) sock * bool) -> unit
      val getLINGER           : ('a, 'b) sock -> Time.time option
      val setLINGER           : (('a, 'b) sock * Time.time option) -> unit
      val getBROADCAST        : ('a, 'b) sock -> bool
      val setBROADCAST        : (('a, 'b) sock * bool) -> unit
      val getOOBINLINE        : ('a, 'b) sock -> bool
      val setOOBINLINE        : (('a, 'b) sock * bool) -> unit
      val getSNDBUF           : ('a, 'b) sock -> int
      val setSNDBUF           : (('a, 'b) sock * int) -> unit
      val getRCVBUF           : ('a, 'b) sock -> int
      val setRCVBUF           : (('a, 'b) sock * int) -> unit
      val getTYPE             : ('a, 'b) sock -> SOCK.sock_type
      val getERROR            : ('a, 'b) sock -> bool

      val getPeerName         : ('a, 'b) sock -> 'a sock_addr
      val getSockName         : ('a, 'b) sock -> 'a sock_addr
      val setNBIO             : (('a, 'b) sock * bool) -> unit
      val getNREAD            : ('a, 'b) sock -> int
      val getATMARK           : ('a, active stream) sock -> bool
    end (* Ctl *)

    (* socket address operations *)
    val sameAddr     : ('a sock_addr * 'a sock_addr) -> bool
    val familyOfAddr : 'a sock_addr -> AF.addr_family

    (* socket management *)
    val accept  : ('a, passive stream) sock
                    -> (('a, active stream) sock * 'a sock_addr)
    val bind    : (('a, 'b) sock * 'a sock_addr) -> unit
    val connect : (('a, 'b) sock * 'a sock_addr) -> unit
    val listen  : (('a, passive stream) sock * int) -> unit
    val close   : ('a, 'b) sock -> unit
    datatype shutdown_mode = NO_RECVS | NO_SENDS | NO_RECVS_OR_SENDS
    val shutdown : (('a, 'b stream) sock * shutdown_mode) -> unit

    val pollDesc : ('a, 'b) sock -> OS.IO.poll_desc

    (* Sock I/O option types *)
    type out_flags = {don't_route : bool, oob : bool}
    type in_flags = {peek : bool, oob : bool}

    type 'a buf = {buf : 'a, i : int, sz : int option}

    (* Sock output operations *)
    val sendVec  : (('a, active stream) sock * Word8Vector.vector buf)
                      -> int
    val sendArr  : (('a, active stream) sock * Word8Array.array buf)
                      -> int
    val sendVec' : (('a, active stream) sock * Word8Vector.vector buf * out_flags)
                      -> int
    val sendArr' : (('a, active stream) sock * Word8Array.array buf * out_flags)
                      -> int
    val sendVecTo: (('a, dgram) sock * 'a sock_addr * Word8Vector.vector buf)
                        -> int
    val sendArrTo: (('a, dgram) sock * 'a sock_addr * Word8Array.array buf)
                        -> int
    val sendVecTo': (('a, dgram) sock * 'a sock_addr * Word8Vector.vector buf * out_flags)
                        -> int
    val sendArrTo': (('a, dgram) sock * 'a sock_addr * Word8Array.array buf * out_flags)
                        -> int

    (* Sock input operations *)
    val recvVec      : (('a, active stream) sock * int)
                        -> Word8Vector.vector
    val recvArr      : (('a, active stream) sock * Word8Array.array buf)
                        -> int
    val recvVec'     : (('a, active stream) sock * int * in_flags)
                        -> Word8Vector.vector
    val recvArr'     : (('a, active stream) sock * Word8Array.array buf * in_flags)
                        -> int
    val recvVecFrom  : (('a, dgram) sock * int)
                        -> (Word8Vector.vector * 'b sock_addr)
    val recvArrFrom  : (('a, dgram) sock * {buf : Word8Array.array, i : int})
                        -> (int * 'a sock_addr)
    val recvVecFrom' : (('a, dgram) sock * int * in_flags)
                        -> (Word8Vector.vector * 'b sock_addr)
    val recvArrFrom' : (('a, dgram) sock * {buf : Word8Array.array, i : int} * in_flags)
                        -> (int * 'a sock_addr)

  end

@


1.2.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a6 4
 *  Revision 1.2  1999/02/16  09:31:39  mitchell
 *  [Bug #190508]
 *  Improve layout
 *
@


1.1
log
@new unit
[Bug #190508]
Add socket support to the basis library
@
text
@d6 5
a10 1
 * $Log$
d23 2
a24 3
  (* sockets are polymorphic; the instantiation of the type variables
   * provides a way to distinguish between different kinds of sockets.
   *)
d28 1
a28 1
  (* witness types for the socket parameter *)
d31 2
a32 2
    type passive	(* for passive streams *)
    type active		(* for active (connected) streams *)
d34 1
a34 1
  (* address families *)
d36 3
a38 3
	type addr_family = NetHostDB.addr_family
	val list : unit -> (string * addr_family) list
	    (* list known address families *)
d40 1
a40 1
	val fromString : string -> addr_family option
d43 1
a43 1
  (* socket types *)
d45 7
a51 7
	eqtype sock_type
	val stream : sock_type		(* stream sockets *)
	val dgram : sock_type		(* datagram sockets *)
	val list : unit -> (string * sock_type) list
	    (* list known socket types *)
	val toString : sock_type -> string
	val fromString : string -> sock_type option
d54 1
a54 1
  (* socket control operations *)
d58 27
a84 27
        val getDEBUG		: ('a, 'b) sock -> bool
        val setDEBUG		: (('a, 'b) sock * bool) -> unit
        val getREUSEADDR	: ('a, 'b) sock -> bool
        val setREUSEADDR	: (('a, 'b) sock * bool) -> unit
        val getKEEPALIVE	: ('a, 'b) sock -> bool
        val setKEEPALIVE	: (('a, 'b) sock * bool) -> unit
        val getDONTROUTE	: ('a, 'b) sock -> bool
        val setDONTROUTE	: (('a, 'b) sock * bool) -> unit
        val getLINGER		: ('a, 'b) sock -> Time.time option
        val setLINGER		: (('a, 'b) sock * Time.time option) -> unit
        val getBROADCAST	: ('a, 'b) sock -> bool
        val setBROADCAST	: (('a, 'b) sock * bool) -> unit
        val getOOBINLINE	: ('a, 'b) sock -> bool
        val setOOBINLINE	: (('a, 'b) sock * bool) -> unit
        val getSNDBUF		: ('a, 'b) sock -> int
        val setSNDBUF		: (('a, 'b) sock * int) -> unit
        val getRCVBUF		: ('a, 'b) sock -> int
        val setRCVBUF		: (('a, 'b) sock * int) -> unit
        val getTYPE		: ('a, 'b) sock -> SOCK.sock_type
        val getERROR		: ('a, 'b) sock -> bool

	val getPeerName		: ('a, 'b) sock -> 'a sock_addr
	val getSockName		: ('a, 'b) sock -> 'a sock_addr
	val setNBIO		: (('a, 'b) sock * bool) -> unit
	val getNREAD		: ('a, 'b) sock -> int
	val getATMARK		: ('a, active stream) sock -> bool
      end (* Ctl *)
d86 1
a86 1
  (* socket address operations *)
d90 1
a90 1
  (* socket management *)
d92 1
a92 1
		    -> (('a, active stream) sock * 'a sock_addr)
d102 1
a102 1
  (* Sock I/O option types *)
d108 17
a124 17
  (* Sock output operations *)
    val sendVec	   : (('a, active stream) sock * Word8Vector.vector buf)
			-> int
    val sendArr	   : (('a, active stream) sock * Word8Array.array buf)
			-> int
    val sendVec'   : (('a, active stream) sock * Word8Vector.vector buf * out_flags)
			-> int
    val sendArr'   : (('a, active stream) sock * Word8Array.array buf * out_flags)
			-> int
    val sendVecTo  : (('a, dgram) sock * 'a sock_addr * Word8Vector.vector buf)
			-> int
    val sendArrTo  : (('a, dgram) sock * 'a sock_addr * Word8Array.array buf)
			-> int
    val sendVecTo' : (('a, dgram) sock * 'a sock_addr * Word8Vector.vector buf * out_flags)
			-> int
    val sendArrTo' : (('a, dgram) sock * 'a sock_addr * Word8Array.array buf * out_flags)
			-> int
d126 1
a126 1
  (* Sock input operations *)
d128 3
a130 3
			-> Word8Vector.vector
    val recvArr	     : (('a, active stream) sock * Word8Array.array buf)
			-> int
d132 1
a132 1
			-> Word8Vector.vector
d134 1
a134 1
			-> int
d136 1
a136 1
			-> (Word8Vector.vector * 'b sock_addr)
d138 1
a138 1
			-> (int * 'a sock_addr)
d140 1
a140 1
			-> (Word8Vector.vector * 'b sock_addr)
d142 1
a142 1
			-> (int * 'a sock_addr)
a145 9
(*
 * $Log: socket-sig.sml,v $
 * Revision 1.2  1997/12/18 19:13:13  jhr
 *   Fixed bug in types of Socket.Ctl.{getPeerName,getSockName}
 *
 * Revision 1.1.1.1  1997/01/14  01:38:24  george
 *   Version 109.24
 *
 *)
@
