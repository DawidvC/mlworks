head	1.31;
access;
symbols
	MLW_daveb_inline_1_4_99:1.31.1
	MLWorks_21c0_1999_03_25:1.31
	MLWorks_20c1_1998_08_20:1.29
	MLWorks_20c0_1998_08_04:1.29
	MLWorks_20b2c2_1998_06_19:1.29
	MLWorks_20b2_Windows_1998_06_12:1.29
	MLWorks_20b1c1_1998_05_07:1.29
	MLWorks_20b0_1998_04_07:1.28
	MLWorks_20b0_1998_03_20:1.28
	MLWorks_20m2_1998_02_16:1.26
	MLWorks_20m1_1997_10_23:1.26
	MLWorks_11r1:1.26.1.1.1.1.1
	MLWorks_workspace_97:1.26.3
	MLWorks_dt_wizard:1.26.2
	MLWorks_11c0_1997_09_09:1.26.1.1.1.1
	MLWorks_10r3:1.26.1.1.3
	MLWorks_10r2_551:1.26.1.1.2
	MLWorks_11:1.26.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.26.1.1
	MLWorks_20m0_1997_06_20:1.26
	MLWorks_1_0_r2c2_1997_06_14:1.26.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.26.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.26.1
	MLWorks_BugFix_1997_04_24:1.26
	MLWorks_1_0_r2_Win32_1997_04_11:1.26
	MLWorks_1_0_r2_Unix_1997_04_04:1.26
	MLWorks_gui_1996_12_18:1.20.4
	MLWorks_1_0_Win32_1996_12_17:1.20.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.20.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.20.1.1
	MLWorks_1_0_Irix_1996_11_28:1.20.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.20.2
	MLWorks_1_0_Unix_1996_11_14:1.20.1
	MLWorks_Open_Beta2_1996_10_11:1.17.1
	MLWorks_License_dev:1.16.1
	MLWorks_1_open_beta_1996_09_13:1.13.1
	MLWorks_Open_Beta_1996_08_22:1.13
	MLWorks_Beta_1996_07_02:1.10
	MLWorks_Beta_1996_06_07:1.10
	MLWorks_Beta_1996_06_06:1.10
	MLWorks_Beta_1996_06_05:1.10
	MLWorks_Beta_1996_06_03:1.9
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.9;
locks; strict;
comment	@ * @;


1.31
date	99.02.17.14.38.26;	author mitchell;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	99.02.02.15.58.11;	author mitchell;	state Exp;
branches;
next	1.29;

1.29
date	98.04.16.15.34.11;	author mitchell;	state Exp;
branches;
next	1.28;

1.28
date	98.02.26.12.45.45;	author mitchell;	state Exp;
branches;
next	1.27;

1.27
date	98.02.25.08.37.18;	author mitchell;	state Exp;
branches;
next	1.26;

1.26
date	97.03.14.11.04.19;	author matthew;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1;
next	1.25;

1.25
date	97.03.06.17.01.25;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	97.03.06.11.11.07;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	97.01.14.17.52.34;	author io;	state Exp;
branches;
next	1.22;

1.22
date	97.01.07.17.03.31;	author io;	state Exp;
branches;
next	1.21;

1.21
date	96.11.18.10.37.17;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	96.11.07.17.12.58;	author matthew;	state Exp;
branches
	1.20.1.1
	1.20.2.1
	1.20.3.1
	1.20.4.1;
next	1.19;

1.19
date	96.11.06.10.40.29;	author andreww;	state Exp;
branches;
next	1.18;

1.18
date	96.11.04.15.55.31;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	96.10.09.16.53.46;	author jont;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	96.10.04.10.38.15;	author io;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	96.10.03.14.55.25;	author io;	state Exp;
branches;
next	1.14;

1.14
date	96.10.03.12.51.12;	author io;	state Exp;
branches;
next	1.13;

1.13
date	96.08.08.15.57.01;	author andreww;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	96.08.08.15.32.25;	author andreww;	state Exp;
branches;
next	1.11;

1.11
date	96.07.05.16.13.57;	author andreww;	state Exp;
branches;
next	1.10;

1.10
date	96.06.04.16.03.12;	author io;	state Exp;
branches;
next	1.9;

1.9
date	96.05.22.13.24.02;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	96.05.21.13.46.24;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	96.05.17.09.38.16;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	96.05.10.15.37.57;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	96.05.09.14.16.05;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.16.39.58;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.05.01.11.08.52;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.04.30.11.31.18;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.11.33.11;	author jont;	state Exp;
branches;
next	;

1.13.1.1
date	96.09.13.11.10.25;	author hope;	state Exp;
branches;
next	;

1.16.1.1
date	96.10.07.16.01.12;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.10.17.11.19.27;	author hope;	state Exp;
branches;
next	;

1.20.1.1
date	96.11.14.12.42.59;	author hope;	state Exp;
branches
	1.20.1.1.1.1;
next	;

1.20.1.1.1.1
date	96.11.28.14.54.54;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.11.22.18.03.30;	author hope;	state Exp;
branches;
next	;

1.20.3.1
date	96.12.17.17.42.24;	author hope;	state Exp;
branches;
next	;

1.20.4.1
date	96.12.18.09.36.23;	author hope;	state Exp;
branches;
next	;

1.26.1.1
date	97.05.12.10.28.05;	author hope;	state Exp;
branches
	1.26.1.1.1.1
	1.26.1.1.2.1
	1.26.1.1.3.1;
next	;

1.26.1.1.1.1
date	97.07.28.18.14.04;	author daveb;	state Exp;
branches
	1.26.1.1.1.1.1.1;
next	;

1.26.1.1.1.1.1.1
date	97.10.07.11.39.11;	author jkbrook;	state Exp;
branches;
next	;

1.26.1.1.2.1
date	97.09.08.17.07.31;	author daveb;	state Exp;
branches;
next	;

1.26.1.1.3.1
date	97.09.09.14.02.45;	author daveb;	state Exp;
branches;
next	;

1.26.2.1
date	97.09.10.19.17.13;	author brucem;	state Exp;
branches;
next	;

1.26.3.1
date	97.09.11.20.47.47;	author daveb;	state Exp;
branches;
next	;

1.31.1.1
date	99.04.01.17.51.58;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.31
log
@[Bug #190507]
Modify to satisfy CM constraints.
@
text
@(*  ==== INITIAL BASIS : Unconstrinaed Real structure ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: __pre_real.sml,v $
 * Revision 1.30  1999/02/02  15:58:11  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.29  1998/04/16  15:34:11  mitchell
 * [Bug #30336]
 * The basis group have decided to get rid of NaN(xxxx)
 *
 * Revision 1.28  1998/02/26  12:45:45  mitchell
 * [Bug #30335]
 * Fix dumb error that's causing the compiler to loop
 *
 * Revision 1.27  1998/02/25  08:37:18  mitchell
 * [Bug #30335]
 * Replace IEEEReal.decimal_approx by an abstract type
 *
 * Revision 1.26  1997/03/14  11:04:19  matthew
 * Print sign for exact representation of nans
 *
 * Revision 1.25  1997/03/06  17:01:25  jont
 * [Bug #1938]
 * Remove nasty stuff from __pre_basis
 *
 * Revision 1.24  1997/03/06  11:11:07  matthew
 * Updating for new basis
 *
 * Revision 1.23  1997/01/14  17:52:34  io
 * [Bug #1892]
 * rename __pre{integer,int32,real,word{,32}} to
 *        __pre_{int{,32},real,word{,32}}
 *
 * Revision 1.22  1997/01/07  17:03:31  io
 * [Bug #1757]
 * renamed __ieeereal to __ieee_real
 *
 * Revision 1.21  1996/11/18  10:37:17  matthew
 * Improving real equality (again).
 *
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
 * Revision 1.19  1996/11/06  10:40:29  andreww
 * [Bug #1711]
 * real type loses equality attribute.
 *
 * Revision 1.18  1996/11/04  15:55:31  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.17  1996/10/09  16:53:46  jont
 * Fix rem
 *
 * Revision 1.16  1996/10/04  10:38:15  io
 * [Bug #1614]
 * remove Old
 *
 * Revision 1.15  1996/10/03  14:55:25  io
 * [Bug #1614]
 * remove redundant requires
 *
 * Revision 1.14  1996/10/03  12:51:12  io
 * [Bug #1614]
 * updating MLWorks.String
 *
 * Revision 1.13  1996/08/08  15:57:01  andreww
 * [Bug #1526]
 * Correcting problems with sign and nextAfter
 *
 * Revision 1.12  1996/08/08  15:32:25  andreww
 * [Bug #1526]
 * Swapping around the arguments and tests in nextAfter.
 *
 * Revision 1.11  1996/07/05  16:13:57  andreww
 * altering to make use of new toplevel functions.
 *
 * Revision 1.10  1996/06/04  16:03:12  io
 * stringcvt -> string_cvt
 *
 * Revision 1.9  1996/05/22  13:24:02  matthew
 * Fixing problem with sub1
 *
 * Revision 1.8  1996/05/21  13:46:24  matthew
 * Change implementation of fromString
 *
 * Revision 1.7  1996/05/17  09:38:16  matthew
 * Moved Bits to MLWorks.Internal.Bits
 *
 * Revision 1.6  1996/05/10  15:37:57  matthew
 * Adding scan
 *
 * Revision 1.5  1996/05/09  14:16:05  matthew
 * Updating.
 *
 * Revision 1.4  1996/05/02  16:39:58  io
 * redummying stringcvt.
 *
 * Revision 1.3  1996/05/01  11:08:52  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.2  1996/04/30  11:31:18  matthew
 * Revisions
 *
 * Revision 1.1  1996/04/18  11:33:11  jont
 * new unit
 *
 *  Revision 1.1  1995/04/13  13:28:55  jont
 *  new unit
 *  No reason given
 *
 *
 *)

require "__string";
require "__string_cvt";
require "__list";
require "__math";
require "__pre_ieee_real";
require "__pre_int";
require "__pre_int32";
require "__pre_ieee_real";

(* Implementation of IEEE double precision *)
structure PreReal =
  struct
    structure Bits = MLWorks.Internal.Bits
    structure IEEEReal = PreIEEEReal

    structure Math = Math

    type real = real

    fun crash s = raise Fail ("Library Error: " ^ s)

    val equal : real * real -> bool = MLWorks.Internal.Value.real_equal
    val isNan : real -> bool = fn x => not (equal(x,x))
    fun unordered (x,y) = isNan x orelse isNan y

    val == : real * real -> bool = equal             (* IEEE "=" *)
    val != : real * real -> bool = not o ==          (* IEEE "?<>" *)
    (* This should, perhaps, be a builtin, but not yet *)
    val op <> : real * real -> bool =                (* IEEE "<>" *)
      fn (x,y) => x < y orelse y < x
    val ?= : real * real -> bool =                   (* IEEE "?="*)
      not o op <>

    infix ?= == !=


    val radix = 2
    val precision = 53
    val maxexp = 2047
    val fromRep:string -> real = MLWorks.Internal.Value.string_to_real
    val toRep: real -> string  = MLWorks.Internal.Value.real_to_string
    val minNormalPos = fromRep "\000\016\000\000\000\000\000\000";
    val minPos = fromRep "\000\000\000\000\000\000\000\001";
    val maxFinite =  fromRep "\127\239\255\255\255\255\255\255";
    val neg_default_nan = fromRep "\255\255\255\255\255\255\255\255"
    val pos_default_nan = fromRep "\127\255\255\255\255\255\255\255"

    val posInf = 1.0 / 0.0
    val negInf = ~posInf

    val *+ = fn (x:real,y,z) => x * y + z
    val *- = fn (x:real,y,z) => x * y - z

    val min = fn (x:real,y:real) => if x < y then x else y
    val max = fn (x:real,y:real) => if x > y then x else y

    fun sign x = if x < 0.0 then ~1 else 
                 if x == 0.0 then 0 else 
                 if x > 0.0 then 1 else raise Domain

    (* Nice to do this without allocating the string *)
    fun signBit x = 
      let
        val s = toRep x
      in
        ord(String.sub(s,0)) > 127
      end

    fun sameSign (r1, r2) = sign r1 = sign r2

    (* Gruesome *)
    fun copySign (x,y) =
      let
        val signbit = signBit y
        val s = toRep x
        val size = size s
        val first = ord(String.sub(s,0))
        val rest = substring (s,1,size - 1)
                            (* previously could raise Substring *)
        val newfirst = if signbit then Bits.orb (128,first) 
                       else Bits.andb (127,first)
      in
        fromRep ((str o chr) newfirst ^ rest)
      end

    fun compare (x:real,y:real) =
      if x < y then LESS 
      else if x == y then EQUAL
      else if x > y then GREATER
      else raise IEEEReal.Unordered

    fun compareReal (x:real,y:real) =
      if x < y then IEEEReal.LESS 
      else if x == y then IEEEReal.EQUAL
      else if x > y then IEEEReal.GREATER
      else IEEEReal.UNORDERED

    (* Returns the (biased) exponent *)
    fun exponent x =
      let
        val s = toRep x
        val b0 = Bits.andb (ord(String.sub(s,0)),127)
        val b1 = Bits.rshift (ord(String.sub(s,1)),4)
      in
        16 * b0 + b1
      end

    fun info x =
      let
        val s = toRep x
        val (a,b,rest) = 
          case map ord (explode s) of
            (a::b::rest) => (a,b,rest)
          | _ => (0,0,[])
        val b0 = Bits.andb (a,127)
        val b1 = Bits.rshift (b,4)
        val sign = a > 127
        val mantissa = Bits.andb (15,b) :: rest
        val exponent = 16 * b0 + b1
      in
        (sign,exponent,mantissa)
      end

    fun make (sign,exponent,b :: mantissa) =
      let
        val b1 = Bits.orb (if sign then 128 else 0,
                            exponent div 16)
        val b2 = Bits.orb (Bits.lshift (exponent mod 16,4),
                           b)
      in
	fromRep (implode (MLWorks.Internal.Value.cast (b1 :: b2 :: mantissa) : char list))
      end
    | make _= 0.0

    fun isFinite x = exponent x < maxexp
    fun isInfinite x = not (isFinite x)
    fun isNormal x =
      let
        val e = exponent x
      in
        e < maxexp andalso e > 0
      end

    
    fun class x =
      let
        fun is_zero [] = true
          | is_zero (0::b) =is_zero b
          | is_zero _ = false
        val (s,e,m) = info x
      in
        (* Ignore NaN's *)
        if e = maxexp
          then if is_zero m
                 then IEEEReal.INF
               else IEEEReal.NAN
        else if e = 0
               then if is_zero m
                      then IEEEReal.ZERO
                    else IEEEReal.SUBNORMAL
             else IEEEReal.NORMAL
      end

    (* Printing and reading *)

    (* Divide a digit list in base from by to *)
    fun ldiv (from,to) = 
      let
        fun div' (c,[],acc) = (c,rev acc)
          | div' (c,d::rest,acc) = 
          let
            val d = from * c + d
            val d' =  d div to
            val c' = d mod to
            val acc' = 
              case acc of 
                [] => if d' = 0 then [] else [d']
              | _ => d'::acc
          in
            div' (c',rest,acc')
          end
        fun ldiv l = div'(0,l,[])
      in
        ldiv
      end

    (* Convert base from from to to *)
    fun convert_base (from,to) l =
      let
        fun f ([],acc) = acc
          | f (l,acc) =
          let
            val (c,l) = ldiv (from,to) l
          in
            f (l,c::acc)
          end
      in
        f (l,[])
      end

    fun pad (l,n) =
      let
        val len = length l
        fun loop (0,l) =l
          | loop (n,l) = loop (n-1,0::l)
      in
        if len < n
          then
            loop (n-len,l)
        else l
      end

    val dec_to_byte = convert_base  (10,256)
    val byte_to_dec = convert_base  (256,10)

    (* This is going to raise Overflow if the number is too big *)
    (* digits is a list of decimal digits,leading zeroes suppressed *)
    fun make_nan (true,[]) = neg_default_nan
      | make_nan (false,[]) = pos_default_nan
      | make_nan (sign,digits) =
      let
        val bytes = dec_to_byte digits
      in
        if List.length bytes > 7
          then raise Overflow
        else
          case pad (bytes,7) of
            b1::rest =>
              if b1 > 15 then raise Overflow
              else
                fromRep
                (implode (map chr
                          ((if sign then 255 else 127) ::
                           240 + b1 :: rest)))
          | _ => crash "make_nan"
      end

    (* Get the decimal representation of a NaN *)
    fun get_nan_digits x =
      case map ord (explode (toRep x)) of
        (b0 :: b1::rest) =>
          let
            val bytes = b1-240 :: rest
          in
            (b0 >= 128, byte_to_dec bytes)
          end
      | _ => crash "print_nan"


    fun toChar x = chr (x + ord #"0")

    fun exact_fmt_nan x =
      let
        val (sign,digits) = get_nan_digits x
      in
        (if sign then "~" else "") ^ "nan" 
      end

    val cfmt : StringCvt.realfmt * real -> string = 
      MLWorks.Internal.Runtime.environment "real fmt"

    fun fmt f x = 
      if f = StringCvt.EXACT andalso isNan x
        then exact_fmt_nan (x)
      else cfmt (f,x)

    val toString = fmt (StringCvt.GEN NONE)

    fun internalFromString x = SOME (MLWorks.Internal.string_to_real x)
                               handle MLWorks.Internal.StringToReal => NONE

        
    fun scan getc orig_src =
      case IEEEReal.scan getc orig_src of
        NONE => NONE
      | SOME (da,src) =>
          let val kind = IEEEReal.class da
              val sign = IEEEReal.signBit da
           in
           case kind of
             IEEEReal.ZERO => SOME (if sign then ~(0.0) else 0.0,src)
           | IEEEReal.INF => SOME (if sign then negInf else posInf,src)
           | IEEEReal.NAN => SOME (make_nan (sign,IEEEReal.digits da),src)
           | _ => 
               let
                 val string = implode ((if sign then [#"~"] else []) @@
                                       [#"0", #"."] @@
                                       map toChar (IEEEReal.digits da) @@
                                       [#"E"] @@
                                       explode (PreInt.toString (IEEEReal.exp da)))
               in
                 case internalFromString (string) of
                    SOME x => SOME (x,src)
                  (* We have a valid regexp so it must be unrepresentable *)
                  | _ => raise Overflow
               end
          end
      
    val fromString : string -> real option = 
      StringCvt.scanString scan

    val toManExp : real -> {man : real, exp : int} =
      MLWorks.Internal.Runtime.environment "real from exp"
    val fromManExp : {man : real, exp : int} -> real =
      MLWorks.Internal.Runtime.environment "real load exp"
    val split : real -> {whole : real, frac : real} =
      MLWorks.Internal.Runtime.environment "real split"
    val realMod = #frac o split (* We could do this more efficiently I suppose *)
    val maxman = ([15,255,255,255,255,255,255])
    val minman = ([ 0,  0,  0,  0,  0,  0,  0])

    (* This should never be called for all-zero numbers *)
    fun sub1 l =
      let
        fun aux [] = []
          | aux (0::rest) = 255 :: aux rest
          | aux (n::rest) = (n-1) :: rest
      in
        rev (aux (rev l))
      end

    fun add1 l =
      let
        fun aux [] = []
          | aux (255::rest) = 0 :: aux rest
          | aux (n::rest) = (n+1) :: rest
      in
        rev (aux (rev l))
      end

    (* x is neither infinity nor nan *)
    (* reduces towards zero (except zero goes negative) *)
    fun do_dec x =
      let
        val (s,e,m) = info x
      in
        if e = 0 (* we have a subnormal or zero *)
          then if m = minman
                 then (* its a zero *)
                   make (true,0,add1 minman)
               else
                 make (s,e,sub1 m)
        else (* not a subnormal *)
          if m = minman
            then make (s,e-1,maxman)
          else make (s,e,sub1 m)
      end

    (* x is neither infinity nor nan *)
    (* assume x >= 0.0 *)
    fun do_inc x =
      let
        val (s,e,m) = info x
      in
        if m = maxman
          then make (s,e+1,minman)
        else make (s,e,add1 m)
      end

    fun nextAfter (r,t) =
      (* check these are the right way round *)
      if not(isFinite r) then r      (* returns r if either infinite or NaN*)
      else if r == t then r
      else if r < t then if r<0.0 then do_dec r else do_inc r
      else (*if r > t*)  if r<0.0 then do_inc r else do_dec r


    fun checkFloat x =
      if isNan x then raise Div
      else if isFinite x then x
      else raise Overflow

    fun realFloor r =
      let
        val {whole,frac} = split r
      in
        if whole < 0.0 andalso frac != 0.0 then whole - 1.0 else whole
      end

    fun realCeil r =
      let
        val {whole,frac} = split r
      in
        if whole > 0.0 andalso frac != 0.0 then whole + 1.0 else whole
      end

    fun realTrunc r =
      let
        val {whole,frac} = split r
      in
        whole
      end

    val floor = fn x => if isNan x then raise Domain else floor x

    val ceil  = fn x => if isNan x then raise Domain else ceil x

    val trunc = fn x => if isNan x then raise Domain else trunc x

    val round = fn x => if isNan x then raise Domain else round x


    fun toInt mode x =
      case mode of
        IEEEReal.TO_NEAREST => round x
      | IEEEReal.TO_NEGINF => floor x
      | IEEEReal.TO_POSINF => ceil x
      | IEEEReal.TO_ZERO => trunc x
          
    val fromInt : PreInt.int -> real = real

    fun rem (x,y) = x - (fromInt (trunc (x / y)) * y)

    val cToLargeInt: IEEEReal.rounding_mode * real -> PreInt32.int = 
      MLWorks.Internal.Runtime.environment "real to large int"
    fun toLargeInt mode x = cToLargeInt (mode,x)

    val fromLargeInt : PreInt32.int -> real = 
      MLWorks.Internal.Runtime.environment "real from large int"

    fun toLarge x = x
    fun fromLarge y x = x

    exception Decimal 
    val rawToDecimal : real -> string * int * bool =
      MLWorks.Internal.Runtime.environment"real decimal rep"
    fun get_digits s =
      map (fn c => ord c - ord #"0") (explode s)
    fun toDecimal (x: real) : IEEEReal.decimal_approx =
      let
        val kind = class x
        val (rep,exp,sign) = rawToDecimal x
      in
        case kind of
          IEEEReal.INF => IEEEReal.DEC_APPROX{kind=kind,sign=sign,digits=[],exp=0}
        | IEEEReal.ZERO => IEEEReal.DEC_APPROX{kind=kind,sign=sign,digits=[],exp=0}
        | IEEEReal.NAN  => IEEEReal.DEC_APPROX{kind=kind, sign=sign, digits = #2(get_nan_digits x),exp=0}
        | _ => IEEEReal.DEC_APPROX{kind=kind,sign=sign,digits=get_digits rep,exp=exp}
      end

    (* Take the easy route of printing and then using fromString *)
    (* ensures consistency between the two functions *)
    fun fromDecimal rep =
      let val kind = IEEEReal.class rep
          val sign = IEEEReal.signBit rep
       in case kind of
            IEEEReal.ZERO => if sign then ~(0.0) else 0.0
          | _ =>
              (case (fromString (IEEEReal.toString rep)) of
                 NONE => crash "fromDecimal"
               | SOME x => x)
      end

    (* Define these last so we can still use the overloaded versions *)
    val ~ : real -> real = ~
    val op + : real * real -> real = op +
    val op - : real * real -> real = op -
    val op * : real * real -> real = op *
    val op / : real * real -> real = op /
    val abs : real -> real = abs
    val op > : real * real -> bool = op >
    val op >= : real * real -> bool = op >=
    val op < : real * real -> bool = op <
    val op <= : real * real -> bool = op <=

  end

structure PreLargeReal = PreReal

@


1.31.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 4
 * Revision 1.31  1999/02/17  14:38:26  mitchell
 * [Bug #190507]
 * Modify to satisfy CM constraints.
 *
@


1.30
log
@[Bug #190500]
Remove redundant require statements
@
text
@d10 4
d135 1
a135 1
structure Real =
d414 1
a414 1
                                       explode (Int.toString (IEEEReal.exp da)))
d534 1
a534 1
    val fromInt : Int.int -> real = real
d538 1
a538 1
    val cToLargeInt: IEEEReal.rounding_mode * real -> Int32.int = 
d542 1
a542 1
    val fromLargeInt : Int32.int -> real = 
d592 1
a592 1
structure LargeReal = Real
@


1.29
log
@[Bug #30336]
The basis group have decided to get rid of NaN(xxxx)
@
text
@d10 4
a120 1
require "__general";
a128 1
require "__pre_char";
@


1.28
log
@[Bug #30335]
Fix dumb error that's causing the compiler to loop
@
text
@d10 4
d374 1
a374 1
        (if sign then "~" else "") ^ "nan(" ^ implode (map toChar digits) ^ ")"
@


1.27
log
@[Bug #30335]
Replace IEEEReal.decimal_approx by an abstract type
@
text
@d10 4
d508 1
a508 1
    fun floor x = if isNan x then raise Domain else floor x
d510 1
a510 1
    fun ceil x = if isNan x then raise Domain else ceil x
d512 1
a512 1
    fun trunc x = if isNan x then raise Domain else trunc x
d514 1
a514 1
    fun round x = if isNan x then raise Domain else round x
d583 1
@


1.26
log
@Print sign for exact representation of nans
@
text
@d10 3
d125 1
d134 1
a134 1
    val unordered = fn (x,y) => isNan x orelse isNan y
d167 3
a169 4
    val sign : real -> int =
      fn x => if x < 0.0 then ~1 else 
              if x == 0.0 then 0 else 
              if x > 0.0 then 1 else raise Domain
d172 1
a172 2
    val signBit : real -> bool = 
      fn x => 
d179 1
a179 2
    val sameSign : real * real -> bool =
      fn (r1, r2) => sign r1 = sign r2
d182 1
a182 2
    val copySign : real * real -> real =
      fn (x,y) =>
d196 1
a196 2
    val compare =
      fn (x:real,y:real) => 
d202 1
a202 2
    val compareReal =
      fn (x:real,y:real) => 
d245 3
a247 4
    val isFinite : real -> bool = fn x => exponent x < maxexp
    val isInfinite : real -> bool = fn x => not (isFinite x)
    val isNormal = 
      fn x => 
d255 1
a255 2
    val class : real -> IEEEReal.float_class =
      fn x => 
a259 5
        fun convert_nan (a::rest) =
          if Bits.andb (a,8) = 0
            then IEEEReal.SIGNALLING
          else IEEEReal.QUIET
          | convert_nan _ = IEEEReal.QUIET
d266 1
a266 1
               else IEEEReal.NAN (convert_nan m)
d379 2
a380 3
    val internalFromString : string -> real option = 
      fn x => SOME (MLWorks.Internal.string_to_real x)
      handle MLWorks.Internal.StringToReal => NONE
d386 5
a390 2
      | SOME ({kind,sign,digits,exp},src) =>
          (case kind of
d393 1
a393 1
           | IEEEReal.NAN _ => SOME (make_nan (sign,digits),src)
d398 1
a398 1
                                       map toChar digits @@
d400 1
a400 1
                                       explode (Int.toString exp))
d406 2
a407 1
               end)
d470 1
a470 1
    val nextAfter : real * real -> real = 
a471 1
      fn (r,t) =>
d478 1
a478 2
    val checkFloat : real -> real =
      fn x =>
d504 1
a504 2
    val floor : real -> int = 
      fn x => if isNan x then raise Domain else floor x
d506 1
a506 2
    val ceil : real -> int =
      fn x => if isNan x then raise Domain else ceil x
d508 1
a508 2
    val trunc : real -> int =
      fn x => if isNan x then raise Domain else trunc x
d510 1
a510 2
    val round : real -> int =
      fn x => if isNan x then raise Domain else round x
d513 1
a513 2
    val toInt : IEEEReal.rounding_mode -> real -> Int.int = 
      fn mode => fn x =>
d522 1
a522 2
    val rem : real * real -> real = 
      fn (x,y) => x - (fromInt (trunc (x / y)) * y)
d531 2
a532 2
    val toLarge : real -> real = fn x => x
    val fromLarge : IEEEReal.rounding_mode -> real -> real = fn y => fn x => x
d545 4
a548 4
          IEEEReal.INF => {kind=kind,sign=sign,digits=[],exp=0}
        | IEEEReal.ZERO => {kind=kind,sign=sign,digits=[],exp=0}
        | IEEEReal.NAN _ => {kind=kind, sign=sign, digits = #2(get_nan_digits x),exp=0}
        | _ => {kind=kind,sign=sign,digits=get_digits rep,exp=exp}
d553 10
a562 8
    val fromDecimal : IEEEReal.decimal_approx -> real = 
      fn rep as {kind,sign,...} =>
      case kind of
        IEEEReal.ZERO => if sign then ~(0.0) else 0.0
      | _ =>
          (case (fromString (IEEEReal.toString rep)) of
             NONE => crash "fromDecimal"
           | SOME x => x)
@


1.26.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 3
 * Revision 1.26  1997/03/14  11:04:19  matthew
 * Print sign for exact representation of nans
 *
@


1.26.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 3
 * Revision 1.26  1997/03/14  11:04:19  matthew
 * Print sign for exact representation of nans
 *
@


1.26.1.1
log
@branched from 1.26
@
text
@a9 3
 * Revision 1.26  1997/03/14  11:04:19  matthew
 * Print sign for exact representation of nans
 *
@


1.26.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 * Revision 1.26.1.1  1997/05/12  10:28:05  hope
 * branched from 1.26
 *
@


1.26.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 * Revision 1.26.1.1  1997/05/12  10:28:05  hope
 * branched from 1.26
 *
@


1.26.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 * Revision 1.26.1.1  1997/05/12  10:28:05  hope
 * branched from 1.26
 *
@


1.26.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 3
 * Revision 1.26.1.1.1.1  1997/07/28  18:14:04  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.25
log
@[Bug #1938]
Remove nasty stuff from __pre_basis
@
text
@d10 4
d364 1
a364 1
            byte_to_dec bytes
d373 1
a373 1
        val digits = get_nan_digits x
d375 1
a375 1
        "nan(" ^ implode (map toChar digits) ^ ")"
d561 1
a561 1
        | IEEEReal.NAN _ => {kind=kind,sign=sign,digits=get_nan_digits x,exp=0}
@


1.24
log
@Updating for new basis
@
text
@d10 3
a109 1
require "__pre_basis";
d239 1
a239 1
	fromRep (implode (cast (b1 :: b2 :: mantissa) : char list))
d545 2
a546 1
    val rawToDecimal : real -> string * int * bool = env "real decimal rep"
@


1.23
log
@[Bug #1892]
rename __pre{integer,int32,real,word{,32}} to
       __pre_{int{,32},real,word{,32}}
@
text
@d10 5
d99 1
d102 1
d104 1
a104 1
require "__ieee_real";
d108 2
d115 2
d120 1
a120 1
    structure Math = Math
d126 2
d129 2
d132 1
a132 1
      fn (x,y) => not (x < y orelse y < x)
d134 1
a134 5
    val == : real * real -> bool = equal             (* IEEE "=" *)
    val op <> : real * real -> bool = not o ?=    (* IEEE "<>" *)
    val ?<> : real * real -> bool = not o ==      (* IEEE "?<>" *)

    infix ?= == ?<>
d145 2
a263 1
        fun convert_sign b = if b then IEEEReal.NEG else IEEEReal.POS
d268 1
a268 1
                 then IEEEReal.INF (convert_sign s)
d272 40
a311 3
                      then IEEEReal.ZERO (convert_sign s)
                    else IEEEReal.SUBNORMAL (convert_sign s)
             else IEEEReal.NORMAL (convert_sign s)
d313 59
d375 5
a379 1
    fun fmt f x = cfmt (f,x)
a385 59
    exception Whoops
    fun scan getc src =
      (* just get the string and let C do the rest *)
      let
        fun is_digit c =
          #"0" <= c andalso c <= #"9"

        fun getdigits src = StringCvt.splitl is_digit getc src

        fun getpointnum src =
          case getc src of
            SOME (#".",src') =>
              let
                val (digs,src'') = getdigits src'
              in
                ("." ^ digs,src'')
              end
          | _ => ("",src)

        fun getsign src =
          case getc src of
            SOME (#"+",src') => ("",src')
          | SOME (#"-",src') => ("-",src')
          | SOME (#"~",src') => ("-",src')
          | _ => ("",src)

        fun getenum src =
          case getc src of
            SOME (char,src') =>
              if char = #"e" orelse char = #"E"
                then 
                  let
                    val (sign,src) = getsign src'
                    val (digs,src) = getdigits src
                  in
                    if digs = ""
                      then raise Whoops
                    else ("E" ^ sign ^ digs,src)
                  end
              else ("",src)
          | _ => ("",src)

        (* Skip whitespace *)
        val src = StringCvt.skipWS getc src
        val (signstring,src) = getsign src
        val (digits1,src) = getdigits src
        val (pointnum,src) = getpointnum src
        val _ = 
          if digits1 = "" andalso pointnum = "" orelse pointnum = "."
            then raise Whoops
          else ()
        val (enum,src) = getenum src
      in
        case internalFromString (signstring ^ digits1 ^ pointnum ^ enum) of
          SOME x => SOME (x,src)
        | _ => NONE
      end
    handle Whoops => NONE

d387 22
d410 1
a410 1
      StringCvt.scanString scan 
d418 1
d485 21
d542 27
a583 9









@


1.22
log
@[Bug #1757]
renamed __ieeereal to __ieee_real
@
text
@d9 5
a13 1
 *  $Log: __prereal.sml,v $
d98 2
a99 2
require "__preinteger";
require "__preint32";
@


1.21
log
@Improving real equality (again).
@
text
@d10 3
d93 1
a93 1
require "__ieeereal";
@


1.20
log
@Fixing problem with equal etc.
@
text
@d10 3
d104 1
a104 1
    val equal : real * real -> bool = fn (x,y) => x <= y andalso y <= x
d108 1
d110 2
a111 1
      fn (x,y) => isNan x orelse isNan y orelse equal(x,y)
@


1.20.4.1
log
@branched from 1.20
@
text
@a9 3
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
@


1.20.3.1
log
@branched from 1.20
@
text
@a9 3
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
@


1.20.2.1
log
@branched from 1.20
@
text
@a9 3
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a9 3
 * Revision 1.20  1996/11/07  17:12:58  matthew
 * Fixing problem with equal etc.
 *
@


1.20.1.1.1.1
log
@branched from 1.20.1.1
@
text
@a9 3
 * Revision 1.20.1.1  1996/11/14  12:42:59  hope
 * branched from 1.20
 *
@


1.19
log
@[Bug #1711]
real type loses equality attribute.
@
text
@d10 4
d101 1
a101 1
    val equal : real * real -> bool = fn (x,y) => not(x < y orelse y > x)
d106 1
a106 2
      fn (x,y) => not(isNan x) andalso not(isNan y)
                  andalso equal(x,y)
@


1.18
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d10 4
d94 1
d97 14
d114 2
a115 2
    val fromRep = MLWorks.Internal.Value.string_to_real
    val toRep = MLWorks.Internal.Value.real_to_string
d130 3
a132 1
      fn x => if x < 0.0 then ~1 else if x = 0.0 then 0 else if x > 0.0 then 1 else raise Domain
d154 4
a157 2
        val rest = substring (s,1,size - 1) (* previously could raise Substring *)
        val newfirst = if signbit then Bits.orb (128,first) else Bits.andb (127,first)
d165 1
a165 1
      else if x = y then EQUAL
d172 1
a172 1
      else if x = y then IEEEReal.EQUAL
a212 5
    val isNan : real -> bool = fn x => not (x = x)
    val unequal : real * real -> bool =
      fn (x,y) => x < y orelse y > x
    val unordered = 
      fn (x,y) => isNan x orelse isNan y
d322 1
a322 1
    val toSci : real -> {man : real, exp : int} =
d324 1
a324 1
    val fromSci : {man : real, exp : int} -> real =
d383 1
a383 1
      else if r = t then r
a441 1

d445 1
@


1.17
log
@Fix rem
@
text
@d10 3
d76 1
d119 1
a119 1
        unsafe_string_sub (s,0) > 127
d132 1
a132 1
        val first = unsafe_string_sub (s,0)
d157 2
a158 2
        val b0 = Bits.andb (unsafe_string_sub (s,0),127)
        val b1 = Bits.rshift (unsafe_string_sub (s,1),4)
@


1.17.1.1
log
@branched from 1.17
@
text
@a9 3
 * Revision 1.17  1996/10/09  16:53:46  jont
 * Fix rem
 *
@


1.16
log
@[Bug #1614]
remove Old
@
text
@d10 4
d396 1
a396 1
      fn (x,y) => x - fromInt (trunc (x / y))
@


1.16.1.1
log
@branched from 1.16
@
text
@a9 4
 * Revision 1.16  1996/10/04  10:38:15  io
 * [Bug #1614]
 * remove Old
 *
@


1.15
log
@[Bug #1614]
remove redundant requires
@
text
@d10 4
a73 1
require "__old";
d128 1
a128 1
        fromRep (Old.chr newfirst ^ rest)
@


1.14
log
@[Bug #1614]
updating MLWorks.String
@
text
@d10 4
a64 1
require "toplevel";
d175 1
a175 1
	fromRep (implode (MLWorks.Internal.Value.cast (b1 :: b2 :: mantissa) : char list))
@


1.13
log
@[Bug #1526]
Correcting problems with sign and nextAfter
@
text
@d10 4
a62 1
require "__general";
d67 2
d105 1
a105 1
        String.ordof (s,0) > 127
d118 2
a119 2
        val first = String.ordof (s,0)
        val rest = String.substring (s,1,size - 1)
d122 1
a122 1
        fromRep (String.chr newfirst ^ rest)
d143 2
a144 2
        val b0 = Bits.andb (String.ordof (s,0),127)
        val b1 = Bits.rshift (String.ordof (s,1),4)
d153 1
a153 1
          case map String.ord (String.explode s) of
d172 1
a172 1
        fromRep (String.implode_char (b1 :: b2 :: mantissa))
d296 2
a297 2
    val maxman = [15,255,255,255,255,255,255]
    val minman = [ 0,  0,  0,  0,  0,  0,  0]
@


1.13.1.1
log
@branched from 1.13
@
text
@a9 4
 * Revision 1.13  1996/08/08  15:57:01  andreww
 * [Bug #1526]
 * Correcting problems with sign and nextAfter
 *
@


1.12
log
@[Bug #1526]
Swapping around the arguments and tests in nextAfter.
@
text
@d10 4
d347 2
a348 2
      else if r < t then do_inc r
      else (*if r > t*)  do_dec r
@


1.11
log
@altering to make use of new toplevel functions.
@
text
@d10 3
d340 6
a345 7
      fn (x,y) =>
      if x = y then x
      else if x < y then if y >= 0.0 then do_dec y else do_inc y
      else if x > y then if y >= 0.0 then do_inc y else do_dec y
      (* at least one is a nan *)
      else if isNan x then x 
      else y
d405 8
@


1.10
log
@stringcvt -> string_cvt
@
text
@d10 3
d354 2
a355 1
    val ceil : real -> int = fn x => ~(floor(~x))
d358 1
a358 2
      fn x =>
      if x >= 0.0 then floor x else ceil x
d361 2
a362 13
      (* round towards nearest, ties towards even *)
      fn x =>
      let
	val near = floor x
	val diff = abs(real near - x)
      in
	if diff < 0.5 then
	  near
	else
	  if diff > 0.5 orelse near mod 2 = 1 
            then near + 1
	  else near
      end
@


1.9
log
@Fixing problem with sub1
@
text
@d10 3
d48 1
a48 1
require "__stringcvt";
@


1.8
log
@Change implementation of fromString
@
text
@d10 3
a200 1
    val toString  : real -> string = MLWorks.Internal.real_to_string
d203 1
d281 1
d285 1
a285 1
          | aux (0::rest) = 1 :: aux rest
@


1.7
log
@Moved Bits to MLWorks.Internal.Bits
@
text
@d10 3
d202 1
a202 1
    val fromString : string -> real option = 
d204 1
d212 3
a214 10
        fun getdigits src =
          case StringCvt.splitl is_digit getc src of
            ("",src) => raise Whoops
          | res => res
        fun getsign src =
          case getc src of
            SOME (#"+",src') => ("",src')
          | SOME (#"-",src') => ("-",src')
          | SOME (#"~",src') => ("-",src')
          | _ => ("",src)
d224 8
d241 3
a243 1
                    ("E" ^ sign ^ digs,src)
d245 1
a245 2
              else 
                ("",src)
d247 2
d253 4
d259 1
a259 1
        case fromString (signstring ^ digits1 ^ pointnum ^ enum) of
d266 3
@


1.6
log
@Adding scan
@
text
@d10 3
d49 2
@


1.5
log
@Updating.
@
text
@d10 3
a48 3
    exception Dummy of string
    fun dummy s = raise Dummy s

a187 4
    val toString  : real -> string = MLWorks.Internal.real_to_string
    val fromString : string -> real option = 
      fn x => SOME (MLWorks.Internal.string_to_real x)

d190 1
d194 53
a246 2
    val scan : (char, 'a) StringCvt.reader -> (real, 'a) StringCvt.reader =
      fn _ => dummy "scan"
d248 1
@


1.4
log
@redummying stringcvt.
@
text
@d10 3
d47 1
a47 1
    fun dummy s x = raise Dummy s
d153 1
a190 2
    val fmt : StringCvt.realfmt -> real -> string = dummy "fmt"
    (* val scan : (char, 'a) StringCvt.reader -> (real, 'a) StringCvt.reader = raise StringCvt "scan" *)
d192 7
a198 4
    val toSci : real -> {man : real, exp : int} = dummy "toSci"
    val fromSci : {man : real, exp : int} -> real = dummy "fromSci"
    val split : real -> {whole : real, frac : real} = dummy "split"
    val rem : real * real -> real = dummy "rem"
d200 6
d272 3
a274 1
    val floor : real -> int = floor
d306 9
a314 2
    val toLargeInt : IEEEReal.rounding_mode -> real -> Int32.int = dummy "toLargeInt"
    val fromLargeInt : Int32.int -> real = dummy "fromLargeInt"
@


1.3
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d10 6
d188 1
a188 1
    val scan : (char, 'a) StringCvt.reader -> (real, 'a) StringCvt.reader = dummy "scan"
@


1.2
log
@Revisions
@
text
@d10 3
d84 1
a84 1
        fromRep (chr newfirst ^ rest)
d115 1
a115 1
          case map ord (explode s) of
@


1.1
log
@new unit
@
text
@d9 4
a12 1
 *  $Log$
d21 1
d23 4
d28 1
d32 58
a89 2
    exception Div = Div
    exception Overflow = General.Overflow
d91 162
d269 3
a271 4
	  if diff > 0.5 orelse near mod 2 = 1 then
	    near + 1
	  else
	    near
d274 17
d292 2
d296 1
a296 2
    val op + : real * real -> real = op +
    val op - : real * real -> real = op -
a300 1
    val abs : real -> real = abs
a301 2
    val sign : real -> int =
      fn x => if x < 0.0 then ~1 else if x = 0.0 then 0 else 1
d303 1
a303 5
    val sameSign : real * real -> bool =
      fn (r1, r2) => sign r1 = sign r2

    val toDefault : real -> real = fn x => x
    val fromDefault : real -> real = fn x => x
d305 1
a305 3
    val floor : real -> int = floor
    val real : int -> real = real
  end
@
