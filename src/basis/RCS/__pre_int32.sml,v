head	1.12;
access;
symbols
	MLW_daveb_inline_1_4_99:1.12.1
	MLWorks_21c0_1999_03_25:1.12
	MLWorks_20c1_1998_08_20:1.11
	MLWorks_20c0_1998_08_04:1.11
	MLWorks_20b2c2_1998_06_19:1.11
	MLWorks_20b2_Windows_1998_06_12:1.11
	MLWorks_20b1c1_1998_05_07:1.11
	MLWorks_20b0_1998_04_07:1.11
	MLWorks_20b0_1998_03_20:1.11
	MLWorks_20m2_1998_02_16:1.11
	MLWorks_20m1_1997_10_23:1.11
	MLWorks_11r1:1.10.1.1.1.1.1
	MLWorks_workspace_97:1.11.2
	MLWorks_dt_wizard:1.11.1
	MLWorks_11c0_1997_09_09:1.10.1.1.1.1
	MLWorks_10r3:1.10.1.1.3
	MLWorks_10r2_551:1.10.1.1.2
	MLWorks_11:1.10.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.1.1
	MLWorks_20m0_1997_06_20:1.11
	MLWorks_1_0_r2c2_1997_06_14:1.10.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.1
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MLWorks_gui_1996_12_18:1.9.6
	MLWorks_1_0_Win32_1996_12_17:1.9.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.3.1
	MLWorks_1_0_Irix_1996_11_28:1.9.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.4
	MLWorks_1_0_Unix_1996_11_14:1.9.3
	MLWorks_Open_Beta2_1996_10_11:1.9.2
	MLWorks_License_dev:1.9.1
	MLWorks_1_open_beta_1996_09_13:1.7.1
	MLWorks_Open_Beta_1996_08_22:1.7
	MLWorks_Beta_1996_07_02:1.7
	MLWorks_Beta_1996_06_07:1.7
	MLWorks_Beta_1996_06_06:1.7
	MLWorks_Beta_1996_06_05:1.7
	MLWorks_Beta_1996_06_03:1.6
	MLWorks_Beta_1996_05_31:1.6
	MLWorks_Beta_1996_05_30:1.5;
locks; strict;
comment	@ *  @;


1.12
date	99.02.17.14.35.31;	author mitchell;	state Exp;
branches
	1.12.1.1;
next	1.11;

1.11
date	97.05.01.17.03.40;	author jont;	state Exp;
branches
	1.11.1.1
	1.11.2.1;
next	1.10;

1.10
date	97.01.14.17.52.21;	author io;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	96.10.03.14.53.27;	author io;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1
	1.9.5.1
	1.9.6.1;
next	1.8;

1.8
date	96.10.03.12.26.42;	author io;	state Exp;
branches;
next	1.7;

1.7
date	96.06.04.15.32.27;	author io;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	96.05.30.11.32.55;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	96.05.17.11.22.24;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.41.08;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	96.05.09.09.38.13;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	96.04.30.15.46.02;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.04.30.14.40.42;	author matthew;	state Exp;
branches;
next	;

1.7.1.1
date	96.09.13.11.10.40;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.10.07.16.01.26;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.17.11.19.42;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.11.14.12.43.16;	author hope;	state Exp;
branches
	1.9.3.1.1.1;
next	;

1.9.3.1.1.1
date	96.11.28.14.55.08;	author hope;	state Exp;
branches;
next	;

1.9.4.1
date	96.11.22.18.03.43;	author hope;	state Exp;
branches;
next	;

1.9.5.1
date	96.12.17.17.42.39;	author hope;	state Exp;
branches;
next	;

1.9.6.1
date	96.12.18.09.36.37;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	97.05.12.10.27.48;	author hope;	state Exp;
branches
	1.10.1.1.1.1
	1.10.1.1.2.1
	1.10.1.1.3.1;
next	;

1.10.1.1.1.1
date	97.07.28.18.14.16;	author daveb;	state Exp;
branches
	1.10.1.1.1.1.1.1;
next	;

1.10.1.1.1.1.1.1
date	97.10.07.11.39.21;	author jkbrook;	state Exp;
branches;
next	;

1.10.1.1.2.1
date	97.09.08.17.07.43;	author daveb;	state Exp;
branches;
next	;

1.10.1.1.3.1
date	97.09.09.14.02.54;	author daveb;	state Exp;
branches;
next	;

1.11.1.1
date	97.09.10.19.17.22;	author brucem;	state Exp;
branches;
next	;

1.11.2.1
date	97.09.11.20.48.03;	author daveb;	state Exp;
branches;
next	;

1.12.1.1
date	99.04.01.17.52.32;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.12
log
@[Bug #190507]
Modify to satisfy CM constraints.
@
text
@(*  ==== INITIAL BASIS : 32-bit Integer structure ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: __pre_int32.sml,v $
 *  Revision 1.11  1997/05/01  17:03:40  jont
 *  [Bug #30096]
 *  Change type of precision
 *
 *  Revision 1.10  1997/01/14  17:52:21  io
 *  [Bug #1892]
 *  rename __pre{integer,int32,real,word{,32}} to
 *         __pre_{int{,32},real,word{,32}}
 *
 *  Revision 1.9  1996/10/03  14:53:27  io
 *  [Bug #1614]
 *  remove redundant requires
 *
 *  Revision 1.8  1996/10/03  12:26:42  io
 *  [Bug #1614]
 *  update MLWorks.String
 *
 *  Revision 1.7  1996/06/04  15:32:27  io
 *  stringcvt -> string_cvt
 *
 *  Revision 1.6  1996/05/30  11:32:55  daveb
 *  ord is now at top level.
 *
 *  Revision 1.5  1996/05/17  11:22:24  jont
 *  Revise to latest signature
 *
 *  Revision 1.4  1996/05/10  12:41:08  matthew
 *  Adding scan
 *
 *  Revision 1.3  1996/05/09  09:38:13  matthew
 *  Adding scan, cvt
 *
 *  Revision 1.2  1996/04/30  15:46:02  jont
 *  String functions explode, implode, chr and ord now only available from String
 *  io functions and types
 *  instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 *  now only available from MLWorks.IO
 *
 *  Revision 1.1  1996/04/30  14:40:42  matthew
 *  new unit
 *
 * Revision 1.1  1996/04/18  11:27:39  jont
 * new unit
 *
 * Revision 1.2  1996/03/19  16:53:14  matthew
 * Changes for value polymorphism
 *
 * Revision 1.1  1995/09/15  16:56:50  daveb
 * new unit
 * 32-bit integers.
 *
 *)

require "__pre_int";
require "__string_cvt";

structure PreInt32 =
  struct
    type int = MLWorks.Internal.Types.int32
    val cast = MLWorks.Internal.Value.cast
    val precision = SOME 32
    val minInt = SOME (~2147483648: int)
    val maxInt = SOME (2147483647: int)

    val toInt = PreInt.fromLarge
    val fromInt = PreInt.toLarge

    fun toLarge x = x
    fun fromLarge x = x

    fun tobase StringCvt.BIN = 2 : int
      | tobase StringCvt.OCT = 8 : int
      | tobase StringCvt.DEC = 10 : int
      | tobase StringCvt.HEX = 16 : int
      
    fun scan radix getc src =
      let
        val base = tobase radix
        val ibase = toInt base

        (* Handy predicates *)
        fun isSign c =
          case c of
            #"+" => true
          | #"~" => true
          | #"-" => true
          | _ => false

        fun isDigit a =
          if ibase <= 10
            then 
              a >= ord #"0" andalso
              a < ord #"0" + ibase
          else
            (a >= ord #"0" andalso a < ord #"0" + 10) orelse
            (a >= ord #"A" andalso a < ord #"A" + ibase - 10) orelse
            (a >= ord #"a" andalso a < ord #"a" + ibase - 10)

        exception Valof
        fun valof n =
          if n >= ord #"0" andalso n <= ord #"9"
            then n - ord #"0"
          else if n >= ord #"a" andalso n <= ord #"z"
                 then n - ord #"a" + 10
          else if n >= ord #"A" andalso n <= ord #"Z"
                 then n - ord #"A" + 10
               else raise Valof

        fun convert_digits s =
          let
            fun convert ([],acc) = acc
              | convert (c :: rest,acc) =
                convert (rest,acc * base - fromInt (valof c))
          in
            convert (map ord (explode s),0)
          end

        fun convert_sign "~" = 1
          | convert_sign "-" = 1
          | convert_sign _ = ~1

        val (sign,src) = StringCvt.splitl isSign getc (StringCvt.skipWS getc src)
      in
        if size sign > 1 then NONE
        else
          case StringCvt.splitl (isDigit o ord) getc src of
            ("",src) => NONE
          | (digits,src) => 
              SOME (convert_sign sign * convert_digits digits,src)
      end

    val fromString = StringCvt.scanString (scan StringCvt.DEC)

    fun makeString (base : int, n : int) =
      let
        fun make_digit digit =
          if digit >= 10 then chr (ord #"A" + digit - 10)
          else chr (ord #"0" + digit)
        fun makedigits (n,acc) =
            let
              val digit = 
                if n >= 0 
                  then n mod base
                else 
                  let
                    val res = n mod base
                  in
                    if res = 0 then 0 else base - res
                  end
              val n' = 
                if n >= 0 orelse digit = 0 then 
                  n div base
                else 1 + n div base
              val acc' = make_digit (toInt digit) :: acc
            in 
              if n' <> 0
                then makedigits (n',acc')
              else acc'
            end
        in
          implode (if n < 0 then #"~" :: makedigits (n,[]) else makedigits (n,[]))
        end

    fun fmt radix n =
      makeString (tobase radix,n)

    fun toString n = fmt StringCvt.DEC n

    val ~ : int -> int = ~
    val op* : int * int -> int = op*
    val op div : int * int -> int = op div
    val op mod : int * int -> int = op mod

    fun quot(a, b) =
      let
	val q = a div b
	val r = a mod b
      in
	if r = 0 orelse (a > 0 andalso b > 0) orelse (a < 0 andalso b < 0) then
	  q
	else
	  q + 1
      end

    fun rem(a, b) =
      let
	val r = a mod b
      in
	if r = 0 orelse (a > 0 andalso b > 0) orelse (a < 0 andalso b < 0) then
	  r
	else
	  r - b
      end

    val op + : int * int -> int = op +
    val op - : int * int -> int = op -
    val op > : int * int -> bool = op >
    val op >= : int * int -> bool = op >=
    val op < : int * int -> bool = op <
    val op <= : int * int -> bool = op <=
    val abs : int -> int = abs

    val compare = 
      fn (n,m) =>
      if n < m then LESS
      else if n > m then GREATER
      else EQUAL

    fun min(a, b) = if a < b then a else b: int
    fun max(a, b) = if a < b then b else a: int
    fun sign x = if x < 0 then ~1 else if x = 0 then 0 else 1: PreInt.int

    fun sameSign(a, b) = sign a = sign b


  end

structure PreLargeInt = PreInt32

@


1.12.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 4
 *  Revision 1.12  1999/02/17  14:35:31  mitchell
 *  [Bug #190507]
 *  Modify to satisfy CM constraints.
 *
@


1.11
log
@[Bug #30096]
Change type of precision
@
text
@d10 4
d66 1
a66 1
structure Int32 =
d74 2
a75 2
    val toInt = Int.fromLarge
    val fromInt = Int.toLarge
d220 1
a220 1
    fun sign x = if x < 0 then ~1 else if x = 0 then 0 else 1: Int.int
d227 2
a228 1
structure LargeInt = Int32
@


1.11.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 4
 *  Revision 1.11  1997/05/01  17:03:40  jont
 *  [Bug #30096]
 *  Change type of precision
 *
@


1.11.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 4
 *  Revision 1.11  1997/05/01  17:03:40  jont
 *  [Bug #30096]
 *  Change type of precision
 *
@


1.10
log
@[Bug #1892]
rename __pre{integer,int32,real,word{,32}} to
       __pre_{int{,32},real,word{,32}}
@
text
@d10 5
d66 1
a66 1
    val precision = SOME (32: int)
@


1.10.1.1
log
@branched from 1.10
@
text
@a9 5
 *  Revision 1.10  1997/01/14  17:52:21  io
 *  [Bug #1892]
 *  rename __pre{integer,int32,real,word{,32}} to
 *         __pre_{int{,32},real,word{,32}}
 *
@


1.10.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 *  Revision 1.10.1.1  1997/05/12  10:27:48  hope
 *  branched from 1.10
 *
@


1.10.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 *  Revision 1.10.1.1  1997/05/12  10:27:48  hope
 *  branched from 1.10
 *
@


1.10.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 *  Revision 1.10.1.1  1997/05/12  10:27:48  hope
 *  branched from 1.10
 *
@


1.10.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 3
 *  Revision 1.10.1.1.1.1  1997/07/28  18:14:16  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.9
log
@[Bug #1614]
remove redundant requires
@
text
@d9 5
a13 1
 *  $Log: __preint32.sml,v $
d54 1
a54 1
require "__preinteger";
@


1.9.6.1
log
@branched from 1.9
@
text
@a9 4
 *  Revision 1.9  1996/10/03  14:53:27  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.9.5.1
log
@branched from 1.9
@
text
@a9 4
 *  Revision 1.9  1996/10/03  14:53:27  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.9.4.1
log
@branched from 1.9
@
text
@a9 4
 *  Revision 1.9  1996/10/03  14:53:27  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.9.3.1
log
@branched from 1.9
@
text
@a9 4
 *  Revision 1.9  1996/10/03  14:53:27  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.9.3.1.1.1
log
@branched from 1.9.3.1
@
text
@a9 3
 *  Revision 1.9.3.1  1996/11/14  12:43:16  hope
 *  branched from 1.9
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a9 4
 *  Revision 1.9  1996/10/03  14:53:27  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a9 4
 *  Revision 1.9  1996/10/03  14:53:27  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.8
log
@[Bug #1614]
update MLWorks.String
@
text
@d10 4
a49 1
require "toplevel";
@


1.7
log
@stringcvt -> string_cvt
@
text
@d10 3
d108 1
a108 1
            convert (map String.ord (String.explode s),0)
d130 2
a131 3
          if digit >= 10 then String.chr (String.ord "A" + digit - 10)
          else String.chr (String.ord "0" + digit)
        val sign = if n < 0 then "~" else ""
d154 1
a154 1
          String.implode (sign :: makedigits (n,[]))
@


1.7.1.1
log
@branched from 1.7
@
text
@a9 3
 *  Revision 1.7  1996/06/04  15:32:27  io
 *  stringcvt -> string_cvt
 *
@


1.6
log
@ord is now at top level.
@
text
@d10 3
d43 1
d45 1
a45 2
require "toplevel";
require "__stringcvt";
@


1.5
log
@Revise to latest signature
@
text
@d10 3
d79 2
a80 2
              a >= Char.ord #"0" andalso
              a < Char.ord #"0" + ibase
d82 3
a84 3
            (a >= Char.ord #"0" andalso a < Char.ord #"0" + 10) orelse
            (a >= Char.ord #"A" andalso a < Char.ord #"A" + ibase - 10) orelse
            (a >= Char.ord #"a" andalso a < Char.ord #"a" + ibase - 10)
d88 6
a93 6
          if n >= Char.ord #"0" andalso n <= Char.ord #"9"
            then n - Char.ord #"0"
          else if n >= Char.ord #"a" andalso n <= Char.ord #"z"
                 then n - Char.ord #"a" + 10
          else if n >= Char.ord #"A" andalso n <= Char.ord #"Z"
                 then n - Char.ord #"A" + 10
d113 1
a113 1
          case StringCvt.splitl (isDigit o Char.ord) getc src of
@


1.4
log
@Adding scan
@
text
@d10 3
d46 2
a47 2
    val minint = SOME (~2147483648: int)
    val maxint = SOME (2147483647: int)
@


1.3
log
@Adding scan, cvt
@
text
@d10 3
a39 4
    exception Dummy of string
    fun dummy s = raise Dummy s


d52 6
a57 1
    fun fromString str : int option =
d59 2
a60 18
        (* skip whitespace *)
        fun skip (" "::rest) = skip rest
          | skip ("\t" :: rest) = skip rest
          | skip ("\n" :: rest) = skip rest
          | skip rest = rest
        (* get a sign *)
        fun sign ("+"::rest) = (1 : int, rest)
          | sign ("~"::rest) = (~1 : int, rest)
          | sign ("-"::rest) = (~1 : int, rest)
          | sign rest = (1 : int, rest)

        fun is_digit a = 
          a >= String.ord "0" andalso
          a <= String.ord "9"

        fun check (a::rest) =
          is_digit (String.ord a)
          | check _ = false
d62 40
a101 9
	fun convert ([],acc) = acc
	  | convert (a :: rest,acc) =
            let
              val d = String.ord a - String.ord "0"
            in
              if d >= 0 andalso d < 10 then
                convert (rest,acc * 10 + fromInt d)
              else acc
            end
d103 1
a103 1
        val (sign,chars) = sign (skip (String.explode str))
d105 6
a110 3
        if check chars
          then SOME (sign * convert (chars,0))
        else NONE
d113 1
a113 1
    fun scan _ = dummy "scan"
d115 27
a141 16
    fun makeString (base,n) =
      if n = 0 then "0"
      else
        let
          fun make_digit digit =
            if digit >= 10 then String.chr (String.ord "A" + digit - 10)
            else String.chr (String.ord "0" + digit)
          val (s,n) = if n < 0 then ("~",~n) else ("",n)
          fun makedigits (0,acc) = acc
            | makedigits (n,acc) =
              let
                val digit = toInt (n mod base)
                val n' = n div base
              in 
                makedigits (n',make_digit digit :: acc)
              end
d143 1
a143 1
          String.implode (s :: makedigits (n,[]))
a145 5
    fun tobase StringCvt.BIN = 2 : int
      | tobase StringCvt.OCT = 8 : int
      | tobase StringCvt.DEC = 10 : int
      | tobase StringCvt.HEX = 16 : int
      
@


1.2
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d10 6
d33 1
d37 4
d47 45
a91 1
    infix == 
d93 29
a121 1
    val op == = fn (x:int,y) => x <= y andalso y <= x
a127 7
    val toInt = Int.fromLarge
    val fromInt = Int.toLarge

    fun toLarge x = x
    fun fromLarge x = x


d133 1
a133 1
	if r == 0 orelse (a > 0 andalso b > 0) orelse (a < 0 andalso b < 0) then
d143 1
a143 1
	if r == 0 orelse (a > 0 andalso b > 0) orelse (a < 0 andalso b < 0) then
d165 1
a165 1
    fun sign x = if x < 0 then ~1 else if x == 0 then 0 else 1: Int.int
a168 28
    fun toString (anint : int) =
      let
        val sign = if anint < 0 then "~" else ""
        fun makedigits anint =
          let
            val digit = if anint >= 0 
                          then anint mod 10 
                        else 
                          let
                            val res = anint mod 10
                          in
                            if res == 0
                              then 0
                                else 10 - res
                          end
            val new_int = if anint >= 0 orelse digit == 0
                            then anint div 10
                          else 1 + anint div 10
          in
            (if new_int <> 0
               then makedigits new_int
             else
               "") ^
               String.chr (toInt (digit + 48))
          end
      in
        sign ^ makedigits anint
      end
a169 17
    fun fromString str =
      let
        exception Invalid
	fun convert res [] = res
	  | convert res (h :: t) =
	    let
	      val d = fromInt (String.ord h) - fromInt (String.ord "0")
	    in
	      if d >= 0 andalso d <= 9 then
		convert (res * 10 + d) t
	      else
		raise Invalid
	    end
      in
	SOME (convert 0 (String.explode str))
        handle Invalid => NONE
      end
@


1.1
log
@new unit
@
text
@d9 4
a12 1
 *  $Log: __int32.sml,v $
d116 1
a116 1
               chr (toInt (digit + 48))
d128 1
a128 1
	      val d = fromInt (ord h) - fromInt (ord "0")
d136 1
a136 1
	SOME (convert 0 (explode str))
@
