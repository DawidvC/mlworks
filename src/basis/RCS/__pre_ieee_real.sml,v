head	1.5;
access;
symbols
	MLW_daveb_inline_1_4_99:1.5.1
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.3
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_11r1:1.2.1.1.1.1.1
	MLWorks_workspace_97:1.2.3
	MLWorks_dt_wizard:1.2.2
	MLWorks_11c0_1997_09_09:1.2.1.1.1.1
	MLWorks_10r3:1.2.1.1.3
	MLWorks_10r2_551:1.2.1.1.2
	MLWorks_11:1.2.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.2.1.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.2.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.2.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.2.1
	MLWorks_BugFix_1997_04_24:1.2
	MLWorks_1_0_r2_Win32_1997_04_11:1.2
	MLWorks_1_0_r2_Unix_1997_04_04:1.2;
locks; strict;
comment	@ *  @;


1.5
date	99.02.17.14.34.53;	author mitchell;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	98.04.16.15.48.54;	author mitchell;	state Exp;
branches;
next	1.3;

1.3
date	98.02.24.16.03.10;	author mitchell;	state Exp;
branches;
next	1.2;

1.2
date	97.03.06.16.57.38;	author jont;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	97.03.06.14.37.09;	author matthew;	state Exp;
branches;
next	;

1.2.1.1
date	97.05.12.10.28.26;	author hope;	state Exp;
branches
	1.2.1.1.1.1
	1.2.1.1.2.1
	1.2.1.1.3.1;
next	;

1.2.1.1.1.1
date	97.07.28.18.14.56;	author daveb;	state Exp;
branches
	1.2.1.1.1.1.1.1;
next	;

1.2.1.1.1.1.1.1
date	97.10.07.11.40.00;	author jkbrook;	state Exp;
branches;
next	;

1.2.1.1.2.1
date	97.09.08.17.08.23;	author daveb;	state Exp;
branches;
next	;

1.2.1.1.3.1
date	97.09.09.14.03.30;	author daveb;	state Exp;
branches;
next	;

1.2.2.1
date	97.09.10.19.17.59;	author brucem;	state Exp;
branches;
next	;

1.2.3.1
date	97.09.11.20.48.53;	author daveb;	state Exp;
branches;
next	;

1.5.1.1
date	99.04.01.17.52.48;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Renamed from __ieee_real.sml
@


1.5
log
@[Bug #190507]
Modify to satisfy CM constraints.
@
text
@(*  ==== INITIAL BASIS : IEEEReal ====
 *
 *  Copyright (C) 1996 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: __pre_ieee_real.sml,v $
 *  Revision 1.4  1998/04/16  15:48:54  mitchell
 *  [Bug #30336]
 *  The basis group have decided to get rid of NaN(xxxx)
 *
 *  Revision 1.3  1998/02/24  16:03:10  mitchell
 *  [Bug #30335]
 *  Replace IEEEReal.decimal_approx by an abstract type
 *
 *  Revision 1.2  1997/03/06  16:57:38  jont
 *  [Bug #1938]
 *  Qualify values from PreBasis
 *
 *  Revision 1.1  1997/03/06  14:37:09  matthew
 *  new unit
 *  Renamed from __ieee_real.sml
 *
 *  Revision 1.1  1997/01/14  10:37:31  io
 *  new unit
 *  [Bug #1757]
 *  renamed __ieeereal to __ieee_real
 *
 *  Revision 1.3  1996/05/10  10:12:58  matthew
 *  Removing dummy function
 *
 *  Revision 1.2  1996/05/10  08:59:33  matthew
 *  Updating
 *
 *  Revision 1.1  1996/04/23  10:41:53  matthew
 *  new unit
 *
 *
 *
 *)

require "__pre_basis";
require "__pre_char";
require "__pre_string_cvt";
require "__int";
require "__list";
structure PreIEEEReal =
  struct

    fun crash s = raise Fail ("Library Error: " ^ s)

    exception Unordered
    datatype real_order = LESS | EQUAL | GREATER | UNORDERED
    datatype float_class = 
      NAN |
      INF |
      ZERO |
      NORMAL |
      SUBNORMAL
    datatype rounding_mode = TO_NEAREST | TO_NEGINF | TO_POSINF | TO_ZERO

    val setRoundingMode : rounding_mode -> unit =
      MLWorks.Internal.Runtime.environment "real set rounding mode"
    val getRoundingMode : unit -> rounding_mode =
      MLWorks.Internal.Runtime.environment "real get rounding mode"

    (* We want decimal_approx to be an abstract type, but because of it's use in
       __pre_real.sml we can't just use an opaque signature match when defining IEEEReal.
       So we have to do things the messy way... *)
    abstype decimal_approx = 
      DE of { kind : float_class, sign : bool, digits : int list, exp : int }
    with
      fun class (DE {kind, ...}) = kind
      fun signBit (DE {sign, ...}) = sign
      fun digits (DE {digits, ...}) = digits
      fun exp (DE {exp, ...}) = exp
      val DEC_APPROX = DE
    end;

    fun digit_to_char d = chr (d + ord #"0")
    fun char_to_digit c = ord c - ord #"0"
    fun toString (da : decimal_approx) =
      case class(da) of
        NAN => "nan" 
      | INF => if signBit(da) then "-inf" else "inf"
      | ZERO => "0.0"
      | _ =>
          implode ((if signBit(da) then [#"~"] else []) @@
                   [#"0",#"."] @@
                   map digit_to_char (digits da) @@
                   (if (exp da) <> 0 
                      then #"E" :: explode (Int.toString (exp da))
                    else []))

    fun stripWS (c::rest) =
      if PreBasis.isSpace c then stripWS rest
      else c :: rest
      | stripWS [] = []

    exception Fail

    val inf_chars = explode "inf"
    val infinity_chars = explode "infinity"
    val nan_chars = explode "nan"

    exception Fail

    (* Get a decimal approx from a character source *)
    fun scan getc src =
      (* just get the string and let C do the rest *)
      let
        (* Does the source match a list of characters *)
        fun trychars [] (getc,src) = SOME src
          | trychars (c::rest) (getc,src) =
          (case getc src of
             SOME (c',src) =>
               if PreChar.toLower c' = c
                 then trychars rest (getc,src)
               else NONE
           | _ => NONE)

        val get_inf = trychars inf_chars 
        val get_infinity = trychars infinity_chars
        val get_nan = trychars nan_chars

        fun getdigits src = 
          let
            fun get (src,acc) =
              case getc src of
                SOME (c,src') =>
                  if PreChar.isDigit c then get (src',char_to_digit c::acc)
                  else (rev acc,src)
              | NONE => (rev acc,src)
          in
            get (src,[])
          end

        (* Return an indication of whether an exponent should be looked for *)
        fun getpointnum orig_src =
          case getc orig_src of
            SOME (#".",src) =>
              let
                val (digs,src) = getdigits src
              in
                case digs of 
                  [] => ([],orig_src,false)
                | _ => (digs,src,true)
              end
          | _ => ([],orig_src,true)

        fun getsign src =
          case getc src of
            SOME (#"+",src') => (false,src')
          | SOME (#"-",src') => (true,src')
          | SOME (#"~",src') => (true,src')
          | _ => (false,src)

        fun getenum orig_src =
          case getc orig_src of
            SOME (char,src) =>
              if char = #"e" orelse char = #"E"
                then 
                  let
                    fun makenum (a::b,acc) =
                      makenum (b,a+10*acc)
                      | makenum (_,acc) = acc
                    val (sign,src) = getsign src
                    val (digs,src) = getdigits src
                    val signfactor = if sign then ~1 else 1
                  in
                    if digs = []
                      then (0,orig_src)
                    else (signfactor * makenum (digs,0),src)
                  end
              else (0,orig_src)
          | _ => (0,orig_src)


        fun strip_zero (0::rest) = strip_zero rest
          | strip_zero rest = rest
            
        (* Skip whitespace *)
        val src = PreStringCvt.skipWS getc src
        val (sign,src) = getsign src
        fun get_special src =
          case get_infinity (getc,src) of
            SOME src => SOME (DEC_APPROX{kind=INF,digits=[],sign=sign,exp=0},src)
          | _ =>
              (case get_inf (getc,src) of
                 SOME src => SOME (DEC_APPROX{kind=INF,digits=[],sign=sign,exp=0},src)
               | _ =>
                   (case get_nan (getc,src) of
                      SOME src => 
                        SOME (DEC_APPROX{kind=NAN,sign=sign,digits=[],exp=0},src)
                    | _ => NONE))
      in
        case get_special src of
          SOME (x,src) => SOME (x,src)
        | _ => 
            let
              val (digits1,src) = getdigits src
              val (digits2,src,continue) = getpointnum src
            in
              if digits1 = [] andalso digits2 = []
                then NONE
              else
                let
                  val (exp,src) = if continue then getenum src else (0,src)
                  fun strip (0 ::rest) = strip rest
                    | strip chars = chars
                  val strip_end = rev o strip o rev
                  fun balance (0::digits,exp) =
                    balance (digits,exp-1)
                    | balance (digits,exp) =
                    (strip_end digits,exp)
                  val (digits,exp) = balance (digits1 @@ digits2,
                                              exp + List.length digits1)
                in
                  case digits of
                    [] => SOME (DEC_APPROX{kind=ZERO,sign=sign,digits=[],exp=0},src)
                  | _ => SOME (DEC_APPROX{kind=NORMAL,sign=sign,digits=digits,exp = exp},src)
                end
            end
      end

    val fromString : string -> decimal_approx option =
      PreStringCvt.scanString scan
  end


@


1.5.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 4
 *  Revision 1.5  1999/02/17  14:34:53  mitchell
 *  [Bug #190507]
 *  Modify to satisfy CM constraints.
 *
@


1.4
log
@[Bug #30336]
The basis group have decided to get rid of NaN(xxxx)
@
text
@d10 4
d119 1
a119 1
               if Char.toLower c' = c
d133 1
a133 1
                  if Char.isDigit c then get (src',char_to_digit c::acc)
d185 1
a185 1
        val src = StringCvt.skipWS getc src
d229 1
a229 1
      StringCvt.scanString scan
@


1.3
log
@[Bug #30335]
Replace IEEEReal.decimal_approx by an abstract type
@
text
@d10 4
d82 1
a82 1
        NAN => "nan(" ^ implode (map digit_to_char (digits da)) ^ ")"
a179 25
        fun do_nan (src,sign) =
          let
            fun default () = SOME (DEC_APPROX{kind=NAN,sign=sign,digits=[],exp=0},src)
          in
            case getc src of
              SOME (#"(",src) =>
                let
                  val (digits,src) = getdigits src
                  val digits = strip_zero digits
                in
                  if digits = [] then default ()
                  else 
                    case getc src of
                      SOME (#")",src) => 
                        SOME (DEC_APPROX
                              {kind=NAN,
                               sign=sign,
                               digits=digits,
                               exp=0},
                              src)
                    | _ => default ()
                end
            | _ => default ()
          end
                    
d191 2
a192 1
                      SOME src => do_nan (src,sign)
@


1.2
log
@[Bug #1938]
Qualify values from PreBasis
@
text
@d10 4
a47 1
    datatype nan_mode = QUIET | SIGNALLING
d49 1
a49 1
      NAN of nan_mode |
d60 13
a72 1
    type decimal_approx = { kind : float_class, sign : bool, digits : int list, exp : int }
d76 4
a79 5
    val toString : decimal_approx -> string =
      fn {kind,sign,digits,exp} =>
      case kind of
        NAN _ => "nan(" ^ implode (map digit_to_char digits) ^ ")"
      | INF => if sign then "-inf" else "inf"
d82 1
a82 1
          implode ((if sign then [#"~"] else []) @@
d84 3
a86 3
                   map digit_to_char digits @@
                   (if exp <> 0 
                      then #"E" :: explode (Int.toString exp)
d178 1
a178 1
            fun default () = SOME ({kind=NAN QUIET,sign=sign,digits=[],exp=0},src)
d190 2
a191 1
                        SOME ({kind=NAN QUIET,
d206 1
a206 1
            SOME src => SOME ({kind=INF,digits=[],sign=sign,exp=0},src)
d209 1
a209 1
                 SOME src => SOME ({kind=INF,digits=[],sign=sign,exp=0},src)
d238 2
a239 2
                    [] => SOME ({kind=ZERO,sign=sign,digits=[],exp=0},src)
                  | _ => SOME ({kind=NORMAL,sign=sign,digits=digits,exp = exp},src)
d247 1
@


1.2.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 4
 *  Revision 1.2  1997/03/06  16:57:38  jont
 *  [Bug #1938]
 *  Qualify values from PreBasis
 *
@


1.2.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 4
 *  Revision 1.2  1997/03/06  16:57:38  jont
 *  [Bug #1938]
 *  Qualify values from PreBasis
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a9 4
 *  Revision 1.2  1997/03/06  16:57:38  jont
 *  [Bug #1938]
 *  Qualify values from PreBasis
 *
@


1.2.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 *  Revision 1.2.1.1  1997/05/12  10:28:26  hope
 *  branched from 1.2
 *
@


1.2.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 *  Revision 1.2.1.1  1997/05/12  10:28:26  hope
 *  branched from 1.2
 *
@


1.2.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 *  Revision 1.2.1.1  1997/05/12  10:28:26  hope
 *  branched from 1.2
 *
@


1.2.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 3
 *  Revision 1.2.1.1.1.1  1997/07/28  18:14:56  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.1
log
@new unit
Renamed from __ieee_real.sml
@
text
@d9 5
a13 1
 *  $Log: __ieee_real.sml,v $
d76 1
a76 1
      if isSpace c then stripWS rest
@
