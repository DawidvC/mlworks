head	1.9;
access;
symbols
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.5.1.1
	MLWorks_gui_1996_12_18:1.8.6
	MLWorks_1_0_Win32_1996_12_17:1.8.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.3.1
	MLWorks_1_0_Irix_1996_11_28:1.8.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.4
	MLWorks_1_0_Unix_1996_11_14:1.8.3
	MLWorks_Open_Beta2_1996_10_11:1.8.2
	MLWorks_License_dev:1.8.1
	MLWorks_1_open_beta_1996_09_13:1.6.1
	MLWorks_Open_Beta_1996_08_22:1.6
	MLWorks_Beta_1996_07_02:1.5
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5;
locks; strict;
comment	@ * @;


1.9
date	96.11.16.11.34.49;	author io;	state Exp;
branches;
next	1.8;

1.8
date	96.10.03.14.46.14;	author io;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1
	1.8.5.1
	1.8.6.1;
next	1.7;

1.7
date	96.09.18.15.23.56;	author io;	state Exp;
branches;
next	1.6;

1.6
date	96.08.16.15.53.40;	author daveb;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	96.05.21.12.11.37;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	96.05.17.09.37.54;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	96.05.15.13.09.02;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.04.23.15.43.36;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.11.24.40;	author jont;	state Exp;
branches;
next	;

1.6.1.1
date	96.09.13.11.10.44;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.10.07.16.01.30;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.10.17.11.19.45;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.11.14.12.43.19;	author hope;	state Exp;
branches
	1.8.3.1.1.1;
next	;

1.8.3.1.1.1
date	96.11.28.14.55.12;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.11.22.18.03.47;	author hope;	state Exp;
branches;
next	;

1.8.5.1
date	96.12.17.17.42.42;	author hope;	state Exp;
branches
	1.8.5.1.1.1;
next	;

1.8.5.1.1.1
date	97.02.24.11.31.17;	author hope;	state Exp;
branches;
next	;

1.8.6.1
date	96.12.18.09.36.41;	author hope;	state Exp;
branches;
next	;


desc
@new unit
@


1.9
log
@[Bug #1757]
renamed __chararray to __char_array
@
text
@asdsadasdsad ensure this does not compile as name has changed
(*  ==== INITIAL BASIS : chararray structure ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: __chararray.sml,v $
 * Revision 1.8  1996/10/03  14:46:14  io
 * [Bug #1614]
 * remove redundant requires
 *
 * Revision 1.7  1996/09/18  15:23:56  io
 * [Bug #1603]
 * convert MLWorks.ByteArray to MLWorks.Internal.ByteArray or equivalent basis functions
 *
 * Revision 1.6  1996/08/16  15:53:40  daveb
 * Removed unused reference to ByteArray.from_string.
 *
 * Revision 1.5  1996/05/21  12:11:37  matthew
 * Updating
 *
 * Revision 1.4  1996/05/17  09:37:54  matthew
 * Moved Bits to MLWorks.Internal.Bits
 *
 * Revision 1.3  1996/05/15  13:09:02  jont
 * pack_words moved to pack_word
 *
 * Revision 1.2  1996/04/23  15:43:36  matthew
 * Updating
 *
 * Revision 1.1  1996/04/18  11:24:40  jont
 * new unit
 *
 *  Revision 1.3  1995/05/16  12:55:35  daveb
 *  Removed commented out old code.
 *
 * Revision 1.1  1995/04/13  13:14:35  jont
 * new unit
 * No reason given
 *
 *
 *)

require "mono_array";
require "__charvector";

structure CharArray : MONO_ARRAY =
  struct
    val cast = MLWorks.Internal.Value.cast
    type elem = char
    structure Vector = CharVector

    (* <URI:basis/__word8array> duplicated here *)
    datatype array = A of MLWorks.Internal.ByteArray.bytearray

    val maxLen = MLWorks.Internal.ByteArray.maxLen

    (* 
     * unsigned comparison is used in the same manner as
     * <URI:basis/__string.sml#extract> 
     * 
     *)
    fun check_size n =
      if (cast n:word) < (cast maxLen:word) then n else raise Size 

    fun array (i: int, e: elem) : array =
      A (MLWorks.Internal.ByteArray.array (check_size i, cast e))

    fun tabulate (i : int, f : int -> elem) : array =
      A (MLWorks.Internal.ByteArray.tabulate (check_size i,cast f))

    (* uses toplevel List.length which is overridden afterwords *)
    fun fromList (l : elem list) : array =
      (check_size (length l);
       A (MLWorks.Internal.ByteArray.arrayoflist (cast l)))

    val length   : array -> int                     = cast(MLWorks.Internal.ByteArray.length)
    val sub      : (array * int) -> elem            = cast(MLWorks.Internal.ByteArray.sub)
    val update   : (array * int * elem) -> unit     = cast(MLWorks.Internal.ByteArray.update)

    val extract  : (array * int * int option ) -> Vector.vector =
      fn (A a,i,len) =>
      let
        val len =
          case len of
            SOME l => l
          | NONE => MLWorks.Internal.ByteArray.length a - i
      in 
        if i >= 0 andalso len >= 0 andalso i + len <= MLWorks.Internal.ByteArray.length a
          then cast(MLWorks.Internal.ByteArray.substring (a,i,len))
        else raise Subscript
      end

    
    fun copy { src=A(src_ba), si, len, dst=A(dst_ba), di } =
      let
        val l = case len of
          SOME l => l
        | NONE => MLWorks.Internal.ByteArray.length src_ba - si
      in
        if si >= 0 andalso l >= 0 andalso si + l <= MLWorks.Internal.ByteArray.length src_ba
          andalso di >= 0 andalso di + l <= MLWorks.Internal.ByteArray.length dst_ba
          then MLWorks.Internal.ByteArray.copy(src_ba, si, si+l, dst_ba, di)
        else raise Subscript
      end

    fun copyv_ba (from, start, len, to, start') =
      let
        val finish = start+len
        val l1 = Vector.length from
        val l2 = MLWorks.Internal.ByteArray.length to
        val unsafe_update = MLWorks.Internal.Value.unsafe_bytearray_update
        val unsafe_sub = MLWorks.Internal.Value.unsafe_string_sub
      in
        if start < 0 orelse start > l1 orelse start+len > l1 orelse
           start' < 0 orelse start' + len  > l2 then
          raise Subscript
        else
          let
            fun copy' 0 = ()
              | copy' n =
                let
                  val n' = n-1
                in
                  (unsafe_update (to, start'+n', unsafe_sub (from, start+n'));
                   copy' n')
                end
          in
            copy' len
          end
      end

    fun copyVec {src, si, len, dst=A(dst_ba), di} =
      let
        val len =
          case len of
            SOME l => l
          | _ => Vector.length src - si
      in
        copyv_ba(src, si, len, dst_ba, di)
      end

    fun app f vector =
      let
	val l = length vector
	fun iterate n =
	  if n = l then
	    ()
	  else
	    (f(sub(vector, n));
	     iterate(n+1))
      in
	iterate 0
      end

    fun appi f (array, i, j) =
      let
	val l = length array
	val len = case j of
	  SOME len => i+len
	| NONE => l
	fun iterate' n =
	  if n >= len then
	    ()
	  else
	    (f (n, sub (array, n));
	     iterate'(n+1))
      in
	iterate' i
      end

    fun foldl f b array =
      let
	val l = length array
	fun reduce(n, x) =
	  if n = l then
	    x
	  else
	    reduce(n+1, f(sub(array, n), x))
      in
	reduce(0, b)
      end

    fun foldr f b array =
      let
	val l = length array
	fun reduce(n, x) =
	  if n < 0 then
	    x
	  else
	    reduce(n-1, f(sub(array, n), x))
      in
	reduce(l-1, b)
      end

    fun foldli f b (array, i, j) =
      let
	val l = length array
	val len = case j of
	  SOME len => i+len
	| NONE => l
	fun reduce (n, x) =
	  if n >= l then
	    x
	  else
	    reduce(n+1, f(n, sub(array, n), x))
      in
	reduce(i, b)
      end

    fun foldri f b (array, i, j) =
      let
	val l = length array
	val len = case j of
	  SOME len => i+len
	| NONE => l
	fun reduce (n, x) =
	  if n < i then
	    x
	  else
	    reduce(n-1, f(n, sub(array, n), x))
      in
	reduce(len-1, b)
      end

    fun modify f array =
      let
	val l = length array
	fun iterate n =
	  if n = l then
	    ()
	  else
	    (update(array, n, f(sub(array, n)));
	     iterate(n+1))
      in
	iterate 0
      end

    fun modifyi f (array, i, j) =
      let
	val l = length array
	val len = case j of
	  SOME len => i+len
	| NONE => l
	fun iterate n =
	  if n >= l then
	    ()
	  else
	    (update(array, n, f(n, sub(array, n)));
	     iterate(n+1))
      in
	iterate i
      end

  end (* structure CharArray *)
@


1.8
log
@[Bug #1614]
remove redundant requires
@
text
@d1 1
d11 4
@


1.8.6.1
log
@branched from 1.8
@
text
@a9 4
 * Revision 1.8  1996/10/03  14:46:14  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.8.5.1
log
@branched from 1.8
@
text
@a9 4
 * Revision 1.8  1996/10/03  14:46:14  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.8.5.1.1.1
log
@branched from 1.8.5.1
@
text
@a9 3
 * Revision 1.8.5.1  1996/12/17  17:42:42  hope
 * branched from 1.8
 *
@


1.8.4.1
log
@branched from 1.8
@
text
@a9 4
 * Revision 1.8  1996/10/03  14:46:14  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.8.3.1
log
@branched from 1.8
@
text
@a9 4
 * Revision 1.8  1996/10/03  14:46:14  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.8.3.1.1.1
log
@branched from 1.8.3.1
@
text
@a9 3
 * Revision 1.8.3.1  1996/11/14  12:43:19  hope
 * branched from 1.8
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a9 4
 * Revision 1.8  1996/10/03  14:46:14  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a9 4
 * Revision 1.8  1996/10/03  14:46:14  io
 * [Bug #1614]
 * remove redundant requires
 *
@


1.7
log
@[Bug #1603]
convert MLWorks.ByteArray to MLWorks.Internal.ByteArray or equivalent basis functions
@
text
@d10 4
a42 1
require "toplevel";
@


1.6
log
@Removed unused reference to ByteArray.from_string.
@
text
@d10 3
d38 1
a39 3
require "__general";
require "__char";
require "__list";
a40 1
require "mono_array";
d44 1
d48 2
a49 17
    (* From here its copied verbatim from __word8array *)
    structure Bits = MLWorks.Internal.Bits

    val MLWcast         = MLWorks.Internal.Value.cast

    structure ByteArray = MLWorks.ByteArray
    type bytearray      = ByteArray.bytearray

    val array_ba        = ByteArray.array
    val tabulate_ba     = ByteArray.tabulate
    val arrayoflist_ba  = ByteArray.arrayoflist
    val length_ba       = ByteArray.length
    val sub_ba          = ByteArray.sub
    val update_ba       = ByteArray.update
    val substring_ba    = ByteArray.substring
    val copy_ba         = ByteArray.copy
    datatype array = A of bytearray
d51 1
a51 1
    val maxLen = ByteArray.maxLen
d53 5
d59 1
a59 1
      if n < 0 orelse n > maxLen then raise Size else n
d62 1
a62 1
      A (array_ba (check_size i, MLWcast e))
d65 1
a65 1
      A (tabulate_ba (check_size i,MLWcast f))
d67 1
d69 2
a70 2
      (check_size (List.length l);
       A (arrayoflist_ba (MLWcast l)))
d72 3
a74 3
    val length   : array -> int                     = MLWcast(length_ba) 
    val sub      : (array * int) -> elem            = MLWcast(sub_ba)
    val update   : (array * int * elem) -> unit     = MLWcast(update_ba)
d82 1
a82 1
          | NONE => length_ba a - i
d84 2
a85 2
        if i >= 0 andalso len >= 0 andalso i + len <= length_ba a
          then MLWcast(substring_ba (a,i,len))
d94 1
a94 1
        | NONE => length_ba src_ba - si
d96 3
a98 3
        if si >= 0 andalso l >= 0 andalso si + l <= length_ba src_ba
          andalso di >= 0 andalso di + l <= length_ba dst_ba
          then copy_ba(src_ba, si, si+l, dst_ba, di)
d106 1
a106 1
        val l2 = ByteArray.length to
d250 1
a250 1
  end
@


1.6.1.1
log
@branched from 1.6
@
text
@a9 3
 * Revision 1.6  1996/08/16  15:53:40  daveb
 * Removed unused reference to ByteArray.from_string.
 *
@


1.5
log
@Updating
@
text
@d10 3
a63 2

    val from_string     = ByteArray.from_string
@


1.4
log
@Moved Bits to MLWorks.Internal.Bits
@
text
@d10 3
d32 1
d35 1
d41 4
d60 1
d64 1
a64 5
    fun pow2(n)         = Bits.lshift(1,n)

    datatype array = A of bytearray

    type elem = char
d66 2
a67 1
    type vector = CharVector.vector
d69 2
a70 1
    val maxlen = pow2(28)
d72 2
a73 2
    val array    : (int * elem) -> array            = MLWcast(array_ba)
    val tabulate : (int * (int -> elem)) -> array   = MLWcast(tabulate_ba)
d75 3
a77 1
    val arrayOfList : elem list -> array            = MLWcast(arrayoflist_ba)
a81 1
    val extract  : (array * int * int) -> vector    = MLWcast(substring_ba)
d83 14
d98 10
a107 1
        copy_ba(src_ba, si, len, dst_ba, di)
d109 1
a109 1
    fun copyv_ba (from, start, finish, to, start') =
d111 2
a112 1
        val l1 = CharVector.length from
d117 3
a119 4
        if start < 0 orelse start > l1 orelse finish > l1 orelse
           start > finish orelse
           start' < 0 orelse start' + finish - start > l2 then
          raise ByteArray.Copy (start, finish, start')
d127 1
a127 2
                  (unsafe_update
  		     (to, start'+n', unsafe_sub (from, start+n'));
d131 1
a131 1
            copy' (finish - start)
d135 105
a239 2
    fun copyv {src, si, len, dst=A(dst_ba), di} =
      copyv_ba(src, si, len, dst_ba, di)
d241 15
@


1.3
log
@pack_words moved to pack_word
@
text
@d10 3
d36 1
@


1.2
log
@Updating
@
text
@d10 3
d27 1
a27 1
require "__chars";
d29 1
a29 2

require "mono_arrays";
@


1.1
log
@new unit
@
text
@d9 4
a12 1
 *  $Log$
d23 4
a26 1
require "__word8array";
d29 74
a102 1
structure CharArray : MONO_ARRAY = Word8Array
@
