head	1.2;
access;
symbols;
locks; strict;
comment	@ *  @;


1.2
date	96.05.13.17.50.56;	author io;	state Exp;
branches;
next	1.1;

1.1
date	96.05.10.16.18.45;	author io;	state Exp;
branches;
next	;


desc
@new unit
@


1.2
log
@fix explode and complete toString
@
text
@(*  ==== INITIAL BASIS : STRINGS ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  Revision Log
 *  ------------
 *  $Log: __strings.sml,v $
 *  Revision 1.1  1996/05/10  16:18:45  io
 *  new unit
 *
 *)
require "toplevel";
require "__pre_char";
require "__chars";
require "strings";
require "__list";
structure String : STRING = 
  struct
    val maxSize = PreChar.maxSize
    (* miscellaneous *)
    val unsafe_substring : (string * int * int) -> string = 
      MLWorks.Internal.Runtime.environment "string unsafe substring"
    val unsafe_concatenate : string * string -> string = 
      MLWorks.Internal.Runtime.environment "string concatenate"
    val unsafe_implode : string list -> string = 
      MLWorks.Internal.Runtime.environment "string implode"
    fun copyFrom (cs:char list, d:string, offset:int, length:int) = 
      let 
        fun aux ([], i) = d
          | aux (c::cs, i) = 
          let in
            PreChar.unsafe_string_update 
            (d, i + offset, MLWorks.Internal.Value.cast c);
            aux (cs, i+1)
          end
      in
        aux (cs,0)
      end
    fun unsafe_implode_char (cs:char list) : string = 
      let 
        val unsafe_implode_char : int list * int -> string =
          MLWorks.Internal.Runtime.environment "string c implode char"
        val length = List.length cs
      in
        if length <= 30 then
          let val alloc_s = PreChar.unsafe_alloc_string (length+1)
          in
            copyFrom (cs, alloc_s, 0, length)
          end
        else if length >= 30 andalso length <= maxSize then
          unsafe_implode_char (MLWorks.Internal.Value.cast cs, length)
        else raise Size
      end
    fun revImplode ([]:char list) : string = ""
      | revImplode cs = unsafe_implode_char (rev cs)
    (* end of miscellaneous *)

    structure Char = Char

    type char = Char.char
    type string = string
    val size = size
    fun sub (s, i) = 
      let val size = size s in
        if i < 0 orelse i >= size then 
          raise Subscript
        else
          PreChar.itoc (PreChar.unsafe_string_sub (s, i))
      end

    fun substring (s, i, n) = 
      if i < 0 orelse n < 0 orelse size s < i+n then raise Subscript
      else
        unsafe_substring (s, i, n) 
        

    (* basis concat is aka old style implode *)
    fun concat xs = 
      let val size = List.foldl op+ 0 (map size xs) in
        if size > maxSize then raise Size
        else 
          (* foldr (unsafe_concatenate)  "" xs *)
          unsafe_implode xs
      end
      
    fun str (c:char) : string = 
      let val alloc_s = PreChar.unsafe_alloc_string (1+1)
      in
        PreChar.unsafe_string_update(alloc_s, 0, PreChar.ctoi c);
        alloc_s
      end

    fun implode (cs:char list) : string = unsafe_implode_char cs
    fun explode (s:string) : char list = 
      let val size = size s 
        fun aux (acc, i) = 
          if i >= 0 then
            aux (PreChar.itoc (PreChar.unsafe_string_sub(s, i))::acc, i-1)
          else
            acc
      in
        aux ([], size-1)
      end
    fun compare (x:string,y) = 
      if x<y then LESS else if x>y then GREATER else EQUAL
    fun collate (comp: (char * char) -> order) ((s1,s2):string * string) : order = 
      let val s1l = explode s1
        val s2l = explode s2
        fun aux ([],[]) = EQUAL
          | aux ([], _) = LESS
          | aux (_, []) = GREATER
          | aux (x::xs, y::ys) = 
          case comp (x,y) of
            EQUAL => aux (xs, ys)
          | arg => arg
      in
        aux (s1l, s2l)
      end
    fun fields (isDelimiter:char -> bool) (s:string) : string list =
      let
        val size = size s
        fun aux (acc, i, j) = 
          let val size' = i+j in
            if (size' = size) then (unsafe_substring (s, i, j) :: acc)
            else if isDelimiter (PreChar.itoc (PreChar.unsafe_string_sub (s, size'))) then
              aux (unsafe_substring(s, i, j)::acc, size'+1, 0)
            else aux (acc, i, j+1)
          end
      in
        rev(aux ([], 0, 0))
      end

    fun tokens (p:char -> bool) "" = []
      | tokens p s = 
      let
        val size = size s
        fun mySubstring (s, i, j, acc) = if j = 0 then acc else unsafe_substring (s, i, j) :: acc
        fun skip i =  if i = size then i else if p (PreChar.itoc (PreChar.unsafe_string_sub(s, i))) then skip (i+1) else i
        fun aux (acc, i, j) = 
          let 
            val size' = i+j 
          in
            if (size' = size) then mySubstring (s, i, j, acc)
            else if p (PreChar.itoc (PreChar.unsafe_string_sub (s, size'))) then
              aux (mySubstring(s, i, j, acc), skip size', 0)
            else aux (acc, i, j+1)
          end
      in
        rev(aux ([], 0, 0))
      end

    fun isPrefix (s:string) (t:string) = 
      let val size_s = size s
      in
        if size_s > (size t) then false
        else 
          let fun aux n = 
            if n > size_s-1 then true
            else if PreChar.unsafe_string_sub(s,n) <> PreChar.unsafe_string_sub(t,n) then
                false
            else
              aux (n+1)
          in
            aux 0
          end
      end
    fun isPrefix (s:string) (t:string):bool = 
      let 
        val size_s = size s 
      in
        if size_s > size t then false
        else 
          let fun aux i = 
            if i < size_s then 
              PreChar.unsafe_string_sub(s,i) = PreChar.unsafe_string_sub (t, i) andalso 
              aux (i+1)
            else
              true
          in
            aux 0
          end
      end

    fun extract ("", _, _) = ""
      | extract (s, i, NONE) = substring (s, i,size s-i)
      | extract (s, i, SOME n) = 
      let val size = size s in
        if i<0 orelse n < 0 orelse size < i + n then
          raise Subscript
        else
          substring (s, i, n)
      end
    fun translate (p:char -> string) (s:string) : string = 
      let 
        val size = size s 
        fun aux (acc, i) = 
          if i < size then
            aux (p (PreChar.itoc (PreChar.unsafe_string_sub (s, i)))::acc, i+1)
          else
            concat (rev acc)
      in
        aux ([], 0)
      end

    fun toString s = translate Char.toString s
    fun fromString s = (* StringCvt.scanString scan *)
      let 
        val size = size s 
        fun getc i = 
          if i < size then
            SOME (PreChar.itoc (PreChar.unsafe_string_sub (s, i)), i+1)
          else
            NONE

        fun aux (acc, i) = 
          case Char.scan getc i of
            NONE =>
              revImplode acc
          | SOME (c, i) => aux (c::acc, i)
      in
        SOME (aux ([], 0))
      end

(*
    fun fromString "" = NONE
    fun fromCString "" = NONE
    fun toCString "" = ""
*)
    fun op^(s1, s2) = 
      if size s1 + size s2 > maxSize then raise Size 
      else unsafe_concatenate (s1, s2)
    val op< : string * string -> bool = op<
    val op<= : string * string -> bool = op<=
    val op> : string * string -> bool = op>
    val op>= : string * string -> bool = op>=
  end
@


1.1
log
@new unit
@
text
@d11 4
a14 1
 *  $Log$
d20 1
d23 1
a26 3
(*  val unsafe_substring : (string * int * int) -> string = 
      MLWorks.String.substring
*)
d29 11
a39 6
    val unsafe_implode : string list -> string = MLWorks.String.implode
    (* stolen from List structure *)
    fun length l =
      let
        fun loop ([], acc) = acc
          | loop (_::t, acc) = loop (t, 1+acc)
d41 1
a41 1
        loop (l, 0)
d43 5
a47 11
    (* end of miscellaneous *)
    (* local *)
    fun foldl f i list = 
      let fun red (acc, []) = acc
            | red (acc, (x::xs)) = red (f (x, acc), xs)
      in 
        red (i, list)
      end
    fun foldr f i list = 
      let fun red (acc, []) = acc
            | red (acc, x::xs) = red (f (x,acc), xs)
d49 8
a56 1
        red (i, rev list)
d58 4
a61 1
    (* end of local *)
d63 1
a63 1
    val maxSize = PreChar.maxSize
d83 1
a83 1
      let val size = foldl op+ 0 (map size xs) in
d97 1
a97 8
    fun unsafe_implode (cs:char list) : string = MLWorks.String.implode_char (map PreChar.ctoi cs)
    fun implode (cs:char list) : string = 
      let val length = length cs in
        if length <= maxSize then
          unsafe_implode cs
        else
          raise Size
      end
d101 2
a102 2
          if i < size then
            aux (PreChar.itoc (PreChar.unsafe_string_sub(s, i))::acc, i+1)
d106 1
a106 1
        aux ([], 0)
d208 20
a229 1
    fun toString "" = ""
@
