head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.9.1
	MLWorks_21c0_1999_03_25:1.9
	MLWorks_20c1_1998_08_20:1.8
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.7
	MLWorks_20b0_1998_04_07:1.7
	MLWorks_20b0_1998_03_20:1.7
	MLWorks_20m2_1998_02_16:1.7
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.5.7.1.1.1.1
	MLWorks_workspace_97:1.5.9
	MLWorks_dt_wizard:1.5.8
	MLWorks_11c0_1997_09_09:1.5.7.1.1.1
	MLWorks_10r3:1.5.7.1.3
	MLWorks_10r2_551:1.5.7.1.2
	MLWorks_11:1.5.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.7.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.5.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.7
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.5.1.1
	MLWorks_gui_1996_12_18:1.5.6
	MLWorks_1_0_Win32_1996_12_17:1.5.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.3.1
	MLWorks_1_0_Irix_1996_11_28:1.5.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.4
	MLWorks_1_0_Unix_1996_11_14:1.5.3
	MLWorks_Open_Beta2_1996_10_11:1.5.2
	MLWorks_License_dev:1.5.1
	MLWorks_1_open_beta_1996_09_13:1.4.1
	MLWorks_Open_Beta_1996_08_22:1.4
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.1;
locks; strict;
comment	@ *  @;


1.9
date	99.03.20.21.49.25;	author daveb;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	98.05.26.13.56.24;	author mitchell;	state Exp;
branches;
next	1.7;

1.7
date	97.11.25.17.37.00;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	97.10.07.16.03.41;	author johnh;	state Exp;
branches;
next	1.5;

1.5
date	96.10.03.15.08.41;	author io;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1
	1.5.5.1
	1.5.6.1
	1.5.7.1
	1.5.8.1
	1.5.9.1;
next	1.4;

1.4
date	96.07.17.15.42.23;	author andreww;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	96.06.11.12.36.31;	author andreww;	state Exp;
branches;
next	1.2;

1.2
date	96.06.06.12.24.01;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	96.06.03.14.09.32;	author andreww;	state Exp;
branches;
next	;

1.4.1.1
date	96.09.13.11.10.58;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.10.07.16.01.43;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.17.11.19.58;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.11.14.12.43.32;	author hope;	state Exp;
branches
	1.5.3.1.1.1;
next	;

1.5.3.1.1.1
date	96.11.28.14.55.25;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.11.22.18.03.59;	author hope;	state Exp;
branches;
next	;

1.5.5.1
date	96.12.17.17.42.54;	author hope;	state Exp;
branches
	1.5.5.1.1.1;
next	;

1.5.5.1.1.1
date	97.02.24.11.31.30;	author hope;	state Exp;
branches;
next	;

1.5.6.1
date	96.12.18.09.36.54;	author hope;	state Exp;
branches;
next	;

1.5.7.1
date	97.05.12.10.29.02;	author hope;	state Exp;
branches
	1.5.7.1.1.1
	1.5.7.1.2.1
	1.5.7.1.3.1;
next	;

1.5.7.1.1.1
date	97.07.28.18.13.24;	author daveb;	state Exp;
branches
	1.5.7.1.1.1.1.1;
next	;

1.5.7.1.1.1.1.1
date	97.10.07.11.38.34;	author jkbrook;	state Exp;
branches;
next	;

1.5.7.1.2.1
date	97.09.08.17.06.45;	author daveb;	state Exp;
branches;
next	;

1.5.7.1.3.1
date	97.09.09.14.02.08;	author daveb;	state Exp;
branches;
next	;

1.5.8.1
date	97.09.10.19.16.33;	author brucem;	state Exp;
branches;
next	;

1.5.9.1
date	97.09.11.20.46.39;	author daveb;	state Exp;
branches;
next	;

1.9.1.1
date	99.04.01.17.52.15;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
support file for revised basis.
@


1.9
log
@[Bug #20125]
Replaced substructure with type.
@
text
@(*  ==== INITIAL BASIS : streamio functor ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  $Log: _imperative_io.sml,v $
 *  Revision 1.8  1998/05/26  13:56:24  mitchell
 *  [Bug #30413]
 *  Remove tracking of open output streams as this is now done in stream_io
 *
 *  Revision 1.7  1997/11/25  17:37:00  daveb
 *  [Bug #30329]
 *  Removed bogus Process argument.
 *
 *  Revision 1.6  1997/10/07  16:03:41  johnh
 *  [Bug #30226]
 *  Closing streams on exit.
 *
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
 *  Revision 1.4  1996/07/17  15:42:23  andreww
 *  [Bug #1453]
 *  Updating to bring inline with the new basis document of May 30 '96
 *
 *  Revision 1.3  1996/06/11  12:36:31  andreww
 *  Debugging input1 to return NONE input correctly.
 *
 *  Revision 1.2  1996/06/06  12:24:01  andreww
 *  canInput must check that exactly the required number of elements
 *  can be input without blocking.
 *
 *  Revision 1.1  1996/06/03  14:09:32  andreww
 *  new unit
 *  support file for revised basis.
 *
 *)

require "mono_array";
require "mono_vector";
require "stream_io";
require "imperative_io";

functor ImperativeIO(structure StreamIO : STREAM_IO
                     structure Vector: MONO_VECTOR
                     structure Array: MONO_ARRAY
                       sharing type StreamIO.elem=Vector.elem=Array.elem
                       sharing type StreamIO.vector=Vector.vector
                                                   =Array.vector
 		     ) : IMPERATIVE_IO = 

  struct
    structure StreamIO = StreamIO
    type instream = StreamIO.instream ref
    type outstream = StreamIO.outstream ref
    type elem = StreamIO.elem
    type vector = StreamIO.vector

    (* list of outstreams which are currently open *)
    val mkInstream = ref
    val getInstream = !
    val setInstream = op :=
    val mkOutstream = ref
    val getOutstream = !
    val setOutstream = op :=
    fun endOf f = if StreamIO.endOfStream f then f 
                  else endOf(#2(StreamIO.input f))

    fun closeIn(r as ref f) = (StreamIO.closeIn f; r := endOf f)
    fun inputN (r as ref f, n) = let val (v,f') = StreamIO.inputN(f,n) 
                                 in  r:=f'; v end

    fun input (r as ref f) = let val (v,f') = StreamIO.input f in r:=f'; v end
    fun input1 (r as ref f) =
      case StreamIO.input1 f of
        SOME (v,f') => (r:=f'; SOME v)
      | NONE => NONE


    fun inputAll(r as ref f) =
      let val v = StreamIO.inputAll f
      in
	r := endOf f; v
      end


    val endOfStream = StreamIO.endOfStream o !


    fun lookahead(ref f) = case StreamIO.input1 f of
      NONE => NONE
    | SOME(e, _) => SOME e

    fun getPosIn(ref f) = StreamIO.getPosIn f

    fun setPosIn(f, pos) = f:=(StreamIO.setPosIn pos)

    val closeOut = StreamIO.closeOut o ! 
    fun output(ref f, v) = StreamIO.output(f,v)
    fun output1(ref f, x) = StreamIO.output1(f,x)
    val flushOut = StreamIO.flushOut o !

    fun canInput(ref instream, i) = case StreamIO.canInput(instream, i) of
      SOME j => i=j
    | NONE => false

    fun getPosOut (ref f) = StreamIO.getPosOut f

    fun setPosOut (f,pos) = f:=(StreamIO.setPosOut pos)

  end











@


1.9.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 4
 *  Revision 1.9  1999/03/20  21:49:25  daveb
 *  [Bug #20125]
 *  Replaced substructure with type.
 *
@


1.8
log
@[Bug #30413]
Remove tracking of open output streams as this is now done in stream_io
@
text
@d10 4
d53 1
a53 1
                                                   =Array.Vector.vector
@


1.7
log
@[Bug #30329]
Removed bogus Process argument.
@
text
@d10 4
a41 1
require "__exit";
a59 13
    val openStreams = ref []

    val addOpenStream = fn s => (openStreams := s :: !openStreams; s)

    fun rmOpenStream s =
      let
        fun rm [] = []
          | rm (h::t) = if h=s then t else h::(rm t)
      in
        openStreams := rm (!openStreams);
        s
      end

d63 1
a63 1
    val mkOutstream = addOpenStream o ref
d98 1
a98 1
    val closeOut = StreamIO.closeOut o ! o rmOpenStream
a109 10

    fun exitFunction () = 
      let
        fun app [] = ()
          | app (h::t) = (closeOut h; app t)
      in
        app (!openStreams)
      end

    val _ = Exit_.atExit exitFunction 
@


1.6
log
@[Bug #30226]
Closing streams on exit.
@
text
@d10 4
d38 1
a38 1
require "os_process";
d47 1
a47 2
 		     structure Process: OS_PROCESS)
                                                         : IMPERATIVE_IO = 
d129 1
a129 1
    val _ = Process.atExit exitFunction 
@


1.5
log
@[Bug #1614]
remove redundant requires
@
text
@d10 4
d34 1
d42 2
a43 1
                                                   =Array.Vector.vector)
d52 15
d70 1
a70 1
    val mkOutstream = ref
d105 1
a105 1
    val closeOut = StreamIO.closeOut o !
d117 10
@


1.5.9.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 4
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.5.8.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 4
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.5.7.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.5.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 *  Revision 1.5.7.1  1997/05/12  10:29:02  hope
 *  branched from 1.5
 *
@


1.5.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 *  Revision 1.5.7.1  1997/05/12  10:29:02  hope
 *  branched from 1.5
 *
@


1.5.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 *  Revision 1.5.7.1  1997/05/12  10:29:02  hope
 *  branched from 1.5
 *
@


1.5.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 3
 *  Revision 1.5.7.1.1.1  1997/07/28  18:13:24  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.5.6.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.5.5.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.5.5.1.1.1
log
@branched from 1.5.5.1
@
text
@a9 3
 *  Revision 1.5.5.1  1996/12/17  17:42:54  hope
 *  branched from 1.5
 *
@


1.5.4.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.5.3.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.5.3.1.1.1
log
@branched from 1.5.3.1
@
text
@a9 3
 *  Revision 1.5.3.1  1996/11/14  12:43:32  hope
 *  branched from 1.5
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/03  15:08:41  io
 *  [Bug #1614]
 *  remove redundant requires
 *
@


1.4
log
@[Bug #1453]
Updating to bring inline with the new basis document of May 30 '96
@
text
@d10 4
a26 1
require "toplevel";
@


1.4.1.1
log
@branched from 1.4
@
text
@a9 4
 *  Revision 1.4  1996/07/17  15:42:23  andreww
 *  [Bug #1453]
 *  Updating to bring inline with the new basis document of May 30 '96
 *
@


1.3
log
@Debugging input1 to return NONE input correctly.
@
text
@d10 3
d77 1
d79 1
d89 5
d95 9
@


1.2
log
@canInput must check that exactly the required number of elements
can be input without blocking.
@
text
@d10 4
d55 4
a58 7
      let
	val (v,f') = case StreamIO.input1 f of
	  SOME foo => foo
	| NONE => raise Bind (* This needs to change *)
      in
	r:=f'; SOME v
      end
@


1.1
log
@new unit
support file for revised basis.
@
text
@d9 5
a13 1
 *  $Log:$
d81 1
a81 1
      SOME i => true
a85 2
(*                       sharing type StreamIO.array=Array.array)
*)
@
