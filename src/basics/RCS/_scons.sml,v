head	1.8;
access;
symbols
	MLW_daveb_inline_1_4_99:1.8.4
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.8
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.8
	MLWorks_20b0_1998_04_07:1.8
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.8
	MLWorks_20m1_1997_10_23:1.8
	MLWorks_11r1:1.8.1.1.1.1.1
	MLWorks_workspace_97:1.8.3
	MLWorks_dt_wizard:1.8.2
	MLWorks_11c0_1997_09_09:1.8.1.1.1.1
	MLWorks_10r3:1.8.1.1.3
	MLWorks_10r2_551:1.8.1.1.2
	MLWorks_11:1.8.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.8.1.1
	MLWorks_20m0_1997_06_20:1.8
	MLWorks_1_0_r2c2_1997_06_14:1.8.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.8.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.8.1
	MLWorks_BugFix_1997_04_24:1.8
	MLWorks_1_0_r2_Win32_1997_04_11:1.8
	MLWorks_1_0_r2_Unix_1997_04_04:1.8
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.7.3.1.1
	MLWorks_gui_1996_12_18:1.7.4
	MLWorks_1_0_Win32_1996_12_17:1.7.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.7.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.7.1.1
	MLWorks_1_0_Irix_1996_11_28:1.7.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.7.2
	MLWorks_1_0_Unix_1996_11_14:1.7.1
	MLWorks_Open_Beta2_1996_10_11:1.5.3
	MLWorks_License_dev:1.5.2
	MLWorks_1_open_beta_1996_09_13:1.5.1
	MLWorks_Open_Beta_1996_08_22:1.5
	MLWorks_Beta_1996_07_02:1.5
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5;
locks; strict;
comment	@ * @;


1.8
date	97.03.06.16.03.22;	author jont;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1;
next	1.7;

1.7
date	96.11.04.14.45.51;	author jont;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1
	1.7.4.1;
next	1.6;

1.6
date	96.10.29.17.49.08;	author io;	state Exp;
branches;
next	1.5;

1.5
date	96.04.30.16.22.44;	author jont;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1;
next	1.4;

1.4
date	96.01.03.16.57.34;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.07.26.11.03.07;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	95.07.25.11.39.53;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	95.07.19.16.49.42;	author jont;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.08.50;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.07.15.59.50;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.10.17.11.18.10;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	96.11.14.12.41.43;	author hope;	state Exp;
branches
	1.7.1.1.1.1;
next	;

1.7.1.1.1.1
date	96.11.28.14.53.36;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.11.22.18.02.09;	author hope;	state Exp;
branches;
next	;

1.7.3.1
date	96.12.17.17.41.05;	author hope;	state Exp;
branches
	1.7.3.1.1.1;
next	;

1.7.3.1.1.1
date	97.02.24.11.29.08;	author hope;	state Exp;
branches;
next	;

1.7.4.1
date	96.12.18.09.35.00;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	97.05.12.10.27.03;	author hope;	state Exp;
branches
	1.8.1.1.1.1
	1.8.1.1.2.1
	1.8.1.1.3.1;
next	;

1.8.1.1.1.1
date	97.07.28.18.13.04;	author daveb;	state Exp;
branches
	1.8.1.1.1.1.1.1;
next	;

1.8.1.1.1.1.1.1
date	97.10.07.11.38.05;	author jkbrook;	state Exp;
branches;
next	;

1.8.1.1.2.1
date	97.09.08.17.06.23;	author daveb;	state Exp;
branches;
next	;

1.8.1.1.3.1
date	97.09.09.14.01.46;	author daveb;	state Exp;
branches;
next	;

1.8.2.1
date	97.09.10.19.16.11;	author brucem;	state Exp;
branches;
next	;

1.8.3.1
date	97.09.11.20.46.06;	author daveb;	state Exp;
branches;
next	;

1.8.4.1
date	99.04.01.17.51.43;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
No reason given
@


1.8
log
@[Bug #1938]
Remove __pre_basis from require list
@
text
@(*   ==== SCON EQAULITY OF MEANING ====
 *              FUNCTOR
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This module contains an Ident.SCon equality of meaning function
 *
 *  $Log: _scons.sml,v $
 * Revision 1.7  1996/11/04  14:45:51  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.6  1996/10/29  17:49:08  io
 * moving String from toplevel
 *
 * Revision 1.5  1996/04/30  16:22:44  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.4  1996/01/03  16:57:34  matthew
 * Take account of negative hex scons
 *
 *  Revision 1.3  1995/07/26  11:03:07  jont
 *  Handle unrepresentable bignums in scon_eqval
 *
 *  Revision 1.2  1995/07/25  11:39:53  jont
 *  Add comparisons on words and hex words
 *
 *  Revision 1.1  1995/07/19  16:49:42  jont
 *  new unit
 *  No reason given
 *
 *)

require "ident.sml";
require "^.basis.__string";
require "^.utils.bignum";
require "scons";

functor Scons(
  structure Ident : IDENT
  structure BigNum : BIGNUM) : SCONS =
  struct

    type SCon = Ident.SCon

    fun is_hex_int (s:string):bool = 
      String.isPrefix "0x" s orelse String.isPrefix "~0x" s
      
    (* Words aren't signed *)
    fun is_hex_word (s:string):bool = String.isPrefix "0wx" s

    fun sign (s:string) = String.sub(s,0) = #"~"

    fun strip_zeroes(s, i) =
      if i >= size s then ""
      else if String.sub(s, i) = #"0" then
	strip_zeroes (s, i+1)
      else
	String.extract (s, i, NONE)

    fun int_is_zero s =
      let
	val ptr = if sign s then 1 else 0
      in
	strip_zeroes(s, if is_hex_int s then 2+ptr else ptr) = ""
      end

    fun word_is_zero s =
      let
	val ptr = if sign s then 1 else 0
      in
	strip_zeroes(s, if is_hex_word s then 3+ptr else ptr) = ""
      end

    fun scon_eqval(Ident.INT(s, _), Ident.INT(t, _)) =
      s = t orelse
      (int_is_zero s andalso int_is_zero t)
      orelse
      (* Tricky one. There may be leading zeroes, or even hex representation *)
      (* First fail if signs different since not both zero *)
      ((sign s = sign t) andalso
       let
	 val s_is_hex = is_hex_int s
	 val t_is_hex = is_hex_int t
       in
	 if s_is_hex = t_is_hex then
	   let
	     val ptr = if sign s then 1 else 0
	     val ptr = if s_is_hex then ptr+2 else ptr
	   in
	     strip_zeroes(s, ptr) = strip_zeroes(t, ptr)
	   end
	 else
	   (* One hex, one decimal *)
	   (if s_is_hex then
	      BigNum.eq(BigNum.hex_string_to_bignum s, BigNum.string_to_bignum t)
	    else
	      BigNum.eq(BigNum.hex_string_to_bignum t, BigNum.string_to_bignum s))
	      handle BigNum.Unrepresentable => false
       (* Regard too big values as unequal, they will fail later *)
       end)

      | scon_eqval(Ident.WORD(s, _), Ident.WORD(t, _)) =
	s = t orelse
	(word_is_zero s andalso word_is_zero t)
	orelse
	(* Tricky one. There may be leading zeroes, or even hex representation *)
	(* First fail if signs different since not both zero *)
	((sign s = sign t) andalso
	 let
	   val s_is_hex = is_hex_word s
	   val t_is_hex = is_hex_word t
	 in
	   if s_is_hex = t_is_hex then
	     let
	       val ptr = if sign s then 1 else 0
	       val ptr = if s_is_hex then ptr+3 else ptr
	     in
	       strip_zeroes(s, ptr) = strip_zeroes(t, ptr)
	     end
	   else
	     (* One hex, one decimal *)
	     (if s_is_hex then
		BigNum.eq(BigNum.hex_word_string_to_bignum s,
			  BigNum.word_string_to_bignum t)
	      else
		BigNum.eq(BigNum.hex_word_string_to_bignum t,
			  BigNum.word_string_to_bignum s))
		handle BigNum.Unrepresentable => false
	 (* Regard too big values as unequal, they will fail later *)
	 end)
      | scon_eqval (Ident.REAL(s, _), Ident.REAL(t, _)) = s = t
      | scon_eqval (Ident.STRING s, Ident.STRING t) = s = t
      | scon_eqval (Ident.CHAR s, Ident.CHAR t) = s = t
      | scon_eqval (_, _) = false

  end
@


1.8.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.8  1997/03/06  16:03:22  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.8.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 4
 * Revision 1.8  1997/03/06  16:03:22  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.8.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 4
 * Revision 1.8  1997/03/06  16:03:22  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a10 4
 * Revision 1.8  1997/03/06  16:03:22  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.8.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
 * Revision 1.8.1.1  1997/05/12  10:27:03  hope
 * branched from 1.8
 *
@


1.8.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
 * Revision 1.8.1.1  1997/05/12  10:27:03  hope
 * branched from 1.8
 *
@


1.8.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
 * Revision 1.8.1.1  1997/05/12  10:27:03  hope
 * branched from 1.8
 *
@


1.8.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 3
 * Revision 1.8.1.1.1.1  1997/07/28  18:13:04  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.7
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d11 4
a40 1
require "^.basis.__pre_basis";
@


1.7.4.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/11/04  14:45:51  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
@


1.7.3.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/11/04  14:45:51  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
@


1.7.3.1.1.1
log
@branched from 1.7.3.1
@
text
@a10 3
 * Revision 1.7.3.1  1996/12/17  17:41:05  hope
 * branched from 1.7
 *
@


1.7.2.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/11/04  14:45:51  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
@


1.7.1.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/11/04  14:45:51  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
@


1.7.1.1.1.1
log
@branched from 1.7.1.1
@
text
@a10 3
 * Revision 1.7.1.1  1996/11/14  12:41:43  hope
 * branched from 1.7
 *
@


1.6
log
@moving String from toplevel
@
text
@d11 3
d54 1
a54 1
    fun sign (s:string) = PreBasis.unsafe_string_char_sub (s,0) = #"~"
d58 1
a58 1
      else if PreBasis.unsafe_string_char_sub (s, i) = #"0" then
@


1.5
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d11 6
d33 3
a35 1
require "../utils/bignum";
d45 3
a47 7
    fun is_hex_int s =
      (size s >= 2 andalso
       String.substring(s, 0, 2) = "0x")
      orelse
      (size s >= 3 andalso
       String.substring(s, 0, 3) = "~0x")

d49 1
a49 5
    fun is_hex_word s =
      size s >= 3 andalso
      case String.substring(s, 0, 3) of
	"0wx" => true
      | _ => false
d51 1
a51 1
    fun sign s = String.ordof(s, 0) = String.ord"~"
d55 2
d58 1
a58 4
	if String.ordof(s, i) = String.ord"0" then
	  strip_zeroes(s, i + 1)
	else
	  String.substring(s, i, size s - i)
@


1.5.3.1
log
@branched from 1.5
@
text
@a10 6
 * Revision 1.5  1996/04/30  16:22:44  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a10 6
 * Revision 1.5  1996/04/30  16:22:44  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a10 6
 * Revision 1.5  1996/04/30  16:22:44  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.4
log
@Take account of negative hex scons
@
text
@d11 3
d51 1
a51 1
    fun sign s = String.ordof(s, 0) = ord"~"
d56 1
a56 1
	if String.ordof(s, i) = ord"0" then
@


1.3
log
@Handle unrepresentable bignums in scon_eqval
@
text
@d11 3
d35 5
a39 4
      size s >= 2 andalso
      case String.substring(s, 0, 2) of
	"0x" => true
      | _ => false
d41 1
@


1.2
log
@Add comparisons on words and hex words
@
text
@d11 3
d87 6
a92 4
	   if s_is_hex then
	     BigNum.eq(BigNum.hex_string_to_bignum s, BigNum.string_to_bignum t)
	   else
	     BigNum.eq(BigNum.hex_string_to_bignum t, BigNum.string_to_bignum s)
d115 8
a122 6
	     if s_is_hex then
	       BigNum.eq(BigNum.hex_word_string_to_bignum s,
			 BigNum.word_string_to_bignum t)
	     else
	       BigNum.eq(BigNum.hex_word_string_to_bignum t,
			 BigNum.word_string_to_bignum s)
@


1.1
log
@new unit
No reason given
@
text
@d10 5
a14 1
 *  $Log$
d28 1
a28 1
    fun is_hex s =
d34 6
d50 8
a57 1
    fun is_zero s =
d61 1
a61 1
	strip_zeroes(s, if is_hex s then 2+ptr else ptr) = ""
d64 1
a64 1
    fun scon_eqval(Ident.INT (s,_), Ident.INT (t,_)) =
d66 1
a66 1
      (is_zero s andalso is_zero t)
d72 2
a73 2
	 val s_is_hex = is_hex s
	 val t_is_hex = is_hex t
d90 28
a117 1
      | scon_eqval (Ident.REAL (s,_), Ident.REAL(t,_)) = s = t
@
