head	1.18;
access;
symbols
	MLW_daveb_inline_1_4_99:1.18.4
	MLWorks_21c0_1999_03_25:1.18
	MLWorks_20c1_1998_08_20:1.18
	MLWorks_20c0_1998_08_04:1.18
	MLWorks_20b2c2_1998_06_19:1.18
	MLWorks_20b2_Windows_1998_06_12:1.18
	MLWorks_20b1c1_1998_05_07:1.18
	MLWorks_20b0_1998_04_07:1.18
	MLWorks_20b0_1998_03_20:1.18
	MLWorks_20m2_1998_02_16:1.18
	MLWorks_20m1_1997_10_23:1.18
	MLWorks_11r1:1.18.1.1.1.1.1
	MLWorks_workspace_97:1.18.3
	MLWorks_dt_wizard:1.18.2
	MLWorks_11c0_1997_09_09:1.18.1.1.1.1
	MLWorks_10r3:1.18.1.1.3
	MLWorks_10r2_551:1.18.1.1.2
	MLWorks_11:1.18.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.18.1.1
	MLWorks_20m0_1997_06_20:1.18
	MLWorks_1_0_r2c2_1997_06_14:1.18.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.18.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.18.1
	MLWorks_BugFix_1997_04_24:1.18
	MLWorks_1_0_r2_Win32_1997_04_11:1.18
	MLWorks_1_0_r2_Unix_1997_04_04:1.18
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.17.3.1.1
	MLWorks_gui_1996_12_18:1.17.4
	MLWorks_1_0_Win32_1996_12_17:1.17.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.17.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.17.1.1
	MLWorks_1_0_Irix_1996_11_28:1.17.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.17.2
	MLWorks_1_0_Unix_1996_11_14:1.17.1
	MLWorks_Open_Beta2_1996_10_11:1.14.3
	MLWorks_License_dev:1.14.2
	MLWorks_1_open_beta_1996_09_13:1.14.1
	MLWorks_Open_Beta_1996_08_22:1.14
	MLWorks_Beta_1996_07_02:1.13
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.13
	MLWorks_Beta_1996_05_31:1.13
	MLWorks_Beta_1996_05_30:1.12
	ML_beta_release_12/08/94:1.4
	ML_beta_release_03/08/94:1.4
	ML_revised_beta_release_25/05/94:1.4
	ML_final_beta_release_02/03/94:1.3
	mlworks-28-01-1994:1.3
	Release:1.3
	mlworks-beta-01-09-1993:1.3
	MLWorks-1-0-4-29/01/1993:1.2
	MLWorks-1-0-3-21/12/1992:1.1
	MLWorks-1-0-2-15/12/1992:1.1
	MLWorks-1-0-1-04/12/1992:1.1;
locks; strict;
comment	@ * @;


1.18
date	97.03.06.16.03.13;	author jont;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1
	1.18.4.1;
next	1.17;

1.17
date	96.11.06.10.51.21;	author matthew;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1;
next	1.16;

1.16
date	96.11.04.15.56.55;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	96.10.18.18.08.38;	author io;	state Exp;
branches;
next	1.14;

1.14
date	96.08.05.13.11.04;	author stephenb;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1;
next	1.13;

1.13
date	96.05.30.12.00.38;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	96.05.15.16.30.45;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	96.05.15.14.22.58;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	96.04.30.17.32.09;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	96.04.29.16.16.42;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	96.02.21.11.59.50;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	96.02.02.12.35.50;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	96.01.15.16.47.09;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	94.10.04.12.28.32;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	94.03.08.14.40.30;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	93.04.15.16.30.16;	author matthew;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	93.01.14.15.31.15;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	92.09.04.08.24.15;	author richard;	state Exp;
branches;
next	;

1.3.1.1
date	93.04.15.16.30.16;	author jont;	state Exp;
branches;
next	;

1.14.1.1
date	96.09.13.11.08.44;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.10.07.15.59.43;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.10.17.11.18.05;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.11.14.12.41.37;	author hope;	state Exp;
branches
	1.17.1.1.1.1;
next	;

1.17.1.1.1.1
date	96.11.28.14.53.30;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.11.22.18.02.03;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.12.17.17.40.59;	author hope;	state Exp;
branches
	1.17.3.1.1.1;
next	;

1.17.3.1.1.1
date	97.02.24.11.28.54;	author hope;	state Exp;
branches;
next	;

1.17.4.1
date	96.12.18.09.34.54;	author hope;	state Exp;
branches;
next	;

1.18.1.1
date	97.05.12.10.26.56;	author hope;	state Exp;
branches
	1.18.1.1.1.1
	1.18.1.1.2.1
	1.18.1.1.3.1;
next	;

1.18.1.1.1.1
date	97.07.28.18.12.57;	author daveb;	state Exp;
branches
	1.18.1.1.1.1.1.1;
next	;

1.18.1.1.1.1.1.1
date	97.10.07.11.37.58;	author jkbrook;	state Exp;
branches;
next	;

1.18.1.1.2.1
date	97.09.08.17.06.14;	author daveb;	state Exp;
branches;
next	;

1.18.1.1.3.1
date	97.09.09.14.01.40;	author daveb;	state Exp;
branches;
next	;

1.18.2.1
date	97.09.10.19.16.04;	author brucem;	state Exp;
branches;
next	;

1.18.3.1
date	97.09.11.20.45.55;	author daveb;	state Exp;
branches;
next	;

1.18.4.1
date	99.04.01.17.51.38;	author daveb;	state Exp;
branches;
next	;


desc
@Source location type.
@


1.18
log
@[Bug #1938]
Remove __pre_basis from require list
@
text
@(* _location.sml the functor *)
(*
$Log: _location.sml,v $
 * Revision 1.17  1996/11/06  10:51:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.16  1996/11/04  15:56:55  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.15  1996/10/18  18:08:38  io
 * moving String from toplevel
 *
 * Revision 1.14  1996/08/05  13:11:04  stephenb
 * [Bug #1510]
 * extract_components: fixed bug which stopped the device being
 * identified -- this was due to a test of the form
 * c >= "a" andalso c <= "a" where the second "a" should obviously
 * be "z".  Didn't fix this directly, instead replaced all the
 * MLWorks.String.* functions with higher level ones from the Basis
 * such as Char.isAlpha.
 *
 * Revision 1.13  1996/05/30  12:00:38  daveb
 * The Ord exception is no longer at top level.
 *
 * Revision 1.12  1996/05/15  16:30:45  matthew
 * Removing diagnostics
 *
 * Revision 1.11  1996/05/15  14:22:58  matthew
 * Adding Windows device name parser thingy
 *
 * Revision 1.10  1996/04/30  17:32:09  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.9  1996/04/29  16:16:42  matthew
 * Removing utils/integer.sml
 *
 * Revision 1.8  1996/02/21  11:59:50  jont
 * Add file_of_location to extract the filename part of a location
 *
 * Revision 1.7  1996/02/02  12:35:50  daveb
 * Made extract handle POSITION case.
 *
Revision 1.6  1996/01/15  16:47:09  daveb
Added extract function.

Revision 1.5  1994/10/04  12:28:32  matthew
Added result signature

Revision 1.4  1994/03/08  14:40:30  daveb
Stopped printing of zero-length ranges as, e.g., 2,1 to 2,1.
Added first_col and first_line.

Revision 1.3  1993/04/15  16:30:16  matthew
Added a function to parse a string representing a location

Revision 1.2  1993/01/14  15:31:15  jont
Added a range type to Location.T

Revision 1.1  1992/09/04  08:24:15  richard
Initial revision

Copyright (C) 1992 Harlequin Ltd
*)
require "^.basis.__int";
require "^.basis.__char";
require "^.basis.__string";
require "location";

functor Location () : LOCATION =
  struct
    datatype T =
      FILE of string
      | LINE of string * int
      | POSITION of string * int * int
      | EXTENT of {name:string, s_line:int, s_col:int, e_line:int, e_col: int}
      | UNKNOWN
    
    val unknown_string = "unknown location"
    val unknown_size = size unknown_string

    val first_line = 1
    val first_col = 1

    fun to_string UNKNOWN = unknown_string
      | to_string (FILE name) = name
      | to_string (LINE (name, line)) =
      concat [name, ":", Int.toString line]
      | to_string (POSITION (name, line, column)) =
      concat [name, ":", Int.toString line, ",", Int.toString column]
      | to_string
      (EXTENT{name:string, s_line:int, s_col:int, e_line:int, e_col: int}) =
      if s_line = e_line andalso (s_col >= e_col - 1) then
	concat [name, ":", Int.toString s_line, ",", Int.toString s_col]
      else
	concat [name, ":", Int.toString s_line, ",",
		Int.toString s_col, " to ", Int.toString e_line,
		",", Int.toString
		(if e_col = first_col then first_col else e_col - 1)]


    fun parse_string (delimiters, s) = 
      let
	val sz = size s
	fun isPrefix (x,offset, s) = 
	  let val szx = size x
	    fun scan i = 
	      if i < szx then
		String.sub(x, i) = String.sub(s, i+offset) andalso
(*
		unsafe_string_char_sub (x, i) = unsafe_string_char_sub (s, i+offset) andalso
*)
		scan (i+1)
	      else
		true
	  in
	    scan 0
	  end (* isPrefix *)
        fun subp (sub,index) =
          let
            val subsize = size sub
            fun aux (index) =
              if (index + subsize <= sz) then
		if isPrefix (sub, index, s) then
		  index
		else
		  aux (index+1)
	      else
		~1
	  in
	    aux index
	  end (* subp *)
	fun scan (delim::l, index, acc) = 
	  (case subp (delim, index) of
	     ~1 => String.substring(s, index, sz-index) :: acc
	   | n => scan (l, n+size delim, String.substring(s, index, n-index)::acc))
	  | scan ([], index, acc) = 
	  if index < sz then
	    String.substring(s, index, sz-index) :: acc
	    else acc
      in
	rev (scan (delimiters, 0, []))
      end (* parseString *)


    exception InvalidLocation

    (* Need this vileness to cope with device names in PC locations
     *
     * As far as I the device is just a letter followed by colon i.e.
     * it is of the form  "[A-Za-z]:".  However, the following also
     * checks to make sure that the character following the colon
     * is not a digit.  Don't know what that check is for - stephenb
     *)
    fun extract_components s =
      let
        val (device,rest) =
          if      size s >= 3
          andalso Char.isAlpha (String.sub (s, 0))
          andalso String.sub (s, 1) = #":"
          andalso not (Char.isDigit (String.sub (s, 2)))
          then
            (substring (s, 0, 3), substring (s, 3, size s - 3))
          else
            ("",s)
      in
        case parse_string ([":", ",", " to ", ","],rest) of 
          [] => []
        | (name::stuff) => device ^ name ::stuff
      end

    exception InvalidInt
    fun getint s = 
      case Int.fromString s of
        SOME n => n
      | _ => 
          ((* MLWorks.IO.output (MLWorks.IO.terminal_out,"Invalid int " ^ s ^"\n"); *)
           raise InvalidInt)

    fun from_string s =
      if String.isPrefix unknown_string s then
	UNKNOWN
      else
        (* look for a filename and any other components *)
        (case extract_components s of
           [name] => FILE name
         | [name,line] => LINE(name,getint line)
         | [name,line,column] =>
             POSITION(name,
                      getint line,
                      getint column)
         | [name,s_line,s_col,e_line,e_col] =>
             EXTENT {name = name,
                     s_line = getint s_line,
                     s_col = getint s_col,
                     e_line = getint e_line,
                     e_col = getint e_col}
         | _ => ((* MLWorks.IO.output (MLWorks.IO.terminal_out,"Invalid location 1 " ^ s ^"\n"); *)
                 raise InvalidLocation))
           handle InvalidInt => ((* MLWorks.IO.output (MLWorks.IO.terminal_out,"Invalid location 2 " ^ s ^"\n"); *)
                                 raise InvalidLocation)
               

    fun combine(EXTENT{name, s_line, s_col, ...}, EXTENT{e_line, e_col, ...}) =
      EXTENT{name=name, s_line=s_line, s_col=s_col, e_line=e_line, e_col=e_col}
      | combine(t, _) = t (* Don't really care about this *)

    local
      (* input: number of lines to advance * start position.
           returns: position of first character of nth line. *)
      fun n_lines (str, 1, pos) = pos
      |   n_lines (str, n, pos) =
        if MLWorks.String.ordof (str, pos) = ord #"\n" then
          n_lines (str, n-1, pos+1)
        else
          n_lines (str, n, pos+1)
        handle
          MLWorks.String.Ord => size str - 1

    in
      fun extract (EXTENT {s_line, s_col, e_line, e_col, ...}, str) =
        let
          val s_pos = n_lines (str, s_line, 0) + s_col - 1;
  
          val e_pos =
            if s_line = e_line then
	      if e_col = s_col then
                s_pos + 1
	      else
                s_pos + e_col - s_col
            else
              n_lines (str, e_line - s_line + 1, s_pos) + e_col - 1
        in
          (s_pos, e_pos)
        end
      |   extract (POSITION (_, col, line), str) =
        let
          val pos = n_lines (str, line, 0) + col - 1
	in
	  (pos, pos + 1)
	end
      |   extract (loc,_) = 
          ((* MLWorks.IO.output (MLWorks.IO.terminal_out,"Invalid location 3 " ^ to_string loc ^"\n"); *)
           raise InvalidLocation)
    end

    fun file_of_location(FILE name) = name
      | file_of_location(LINE(name, _)) = name
      | file_of_location(POSITION(name, _, _)) = name
      | file_of_location(EXTENT{name, ...}) = name
      | file_of_location UNKNOWN = ""

  end

@


1.18.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.18  1997/03/06  16:03:13  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.18.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.18  1997/03/06  16:03:13  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.18.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.18  1997/03/06  16:03:13  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.18.1.1
log
@branched from 1.18
@
text
@a3 4
 * Revision 1.18  1997/03/06  16:03:13  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.18.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.18.1.1  1997/05/12  10:26:56  hope
 * branched from 1.18
 *
@


1.18.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.18.1.1  1997/05/12  10:26:56  hope
 * branched from 1.18
 *
@


1.18.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.18.1.1  1997/05/12  10:26:56  hope
 * branched from 1.18
 *
@


1.18.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.18.1.1.1.1  1997/07/28  18:12:57  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.17
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
a71 1
require "^.basis.__pre_basis";
@


1.17.4.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/11/06  10:51:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.3.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/11/06  10:51:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.3.1.1.1
log
@branched from 1.17.3.1
@
text
@a3 3
 * Revision 1.17.3.1  1996/12/17  17:40:59  hope
 * branched from 1.17
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/11/06  10:51:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/11/06  10:51:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.1.1.1.1
log
@branched from 1.17.1.1
@
text
@a3 3
 * Revision 1.17.1.1  1996/11/14  12:41:37  hope
 * branched from 1.17
 *
@


1.16
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d4 4
d65 1
a65 1
require "^.basis.__integer";
@


1.15
log
@moving String from toplevel
@
text
@d4 3
d106 2
d109 1
d132 2
a133 2
	     ~1 => unsafe_substring (s, index, sz-index) :: acc
	   | n => scan (l, n+size delim, unsafe_substring (s, index, n-index)::acc))
d136 1
a136 1
	    unsafe_substring (s, index, sz-index) :: acc
@


1.14
log
@[Bug #1510]
extract_components: fixed bug which stopped the device being
identified -- this was due to a test of the form
c >= "a" andalso c <= "a" where the second "a" should obviously
be "z".  Didn't fix this directly, instead replaced all the
MLWorks.String.* functions with higher level ones from the Basis
such as Char.isAlpha.
@
text
@d4 9
d61 1
a65 1
    structure Option = MLWorks.Option
d67 5
a71 5
      UNKNOWN |
      FILE of string |
      LINE of string * int |
      POSITION of string * int * int |
      EXTENT of {name:string, s_line:int, s_col:int, e_line:int, e_col: int}
d82 1
a82 1
        MLWorks.String.implode [name, ":", Int.toString line]
d84 1
a84 1
        MLWorks.String.implode [name, ":", Int.toString line, ",", Int.toString column]
d86 9
a94 8
	(EXTENT{name:string, s_line:int, s_col:int, e_line:int, e_col: int}) =
	if s_line = e_line andalso (s_col >= e_col - 1) then
	  MLWorks.String.implode [name, ":", Int.toString s_line, ",", Int.toString s_col]
	else
	  MLWorks.String.implode [name, ":", Int.toString s_line, ",",
		   Int.toString s_col, " to ", Int.toString e_line,
		   ",", Int.toString
			  (if e_col = first_col then first_col else e_col - 1)]
d96 1
a96 1
    fun parse_string delimiters string =
d98 12
a109 1
        val stringsize = size string
d114 18
a131 18
              if (index + subsize <= stringsize)
                then
                  if MLWorks.String.substring(string,index,subsize) = sub
                    then index
                  else
                    aux(index+1)
              else ~1
          in
            aux index
          end
        fun aux ([],index,acc) =
          if index < stringsize
            then (MLWorks.String.substring(string,index,stringsize-index)) :: acc
          else acc
          | aux (delim::l,index,acc) =
            (case subp (delim,index) of
               ~1 => (MLWorks.String.substring(string,index,stringsize-index) :: acc)
             | n => aux(l,n+size delim,MLWorks.String.substring(string,index,n-index)::acc))
d133 3
a135 2
        rev (aux(delimiters,0,[]))
      end
a136 1
    
d154 1
a154 1
            (String.substring (s, 0, 3), String.substring (s, 3, size s - 3))
d158 1
a158 1
        case parse_string [":", ",", " to ", ","] rest of 
d166 1
a166 1
        Option.SOME n => n
d172 2
a173 3
      if (size s >= unknown_size) andalso 
        (MLWorks.String.substring (s,0,unknown_size) = unknown_string)
        then UNKNOWN
d204 1
a204 1
        if MLWorks.String.ordof (str, pos) = MLWorks.String.ord "\n" then
@


1.14.3.1
log
@branched from 1.14
@
text
@a3 9
 * Revision 1.14  1996/08/05  13:11:04  stephenb
 * [Bug #1510]
 * extract_components: fixed bug which stopped the device being
 * identified -- this was due to a test of the form
 * c >= "a" andalso c <= "a" where the second "a" should obviously
 * be "z".  Didn't fix this directly, instead replaced all the
 * MLWorks.String.* functions with higher level ones from the Basis
 * such as Char.isAlpha.
 *
@


1.14.2.1
log
@branched from 1.14
@
text
@a3 9
 * Revision 1.14  1996/08/05  13:11:04  stephenb
 * [Bug #1510]
 * extract_components: fixed bug which stopped the device being
 * identified -- this was due to a test of the form
 * c >= "a" andalso c <= "a" where the second "a" should obviously
 * be "z".  Didn't fix this directly, instead replaced all the
 * MLWorks.String.* functions with higher level ones from the Basis
 * such as Char.isAlpha.
 *
@


1.14.1.1
log
@branched from 1.14
@
text
@a3 9
 * Revision 1.14  1996/08/05  13:11:04  stephenb
 * [Bug #1510]
 * extract_components: fixed bug which stopped the device being
 * identified -- this was due to a test of the form
 * c >= "a" andalso c <= "a" where the second "a" should obviously
 * be "z".  Didn't fix this directly, instead replaced all the
 * MLWorks.String.* functions with higher level ones from the Basis
 * such as Char.isAlpha.
 *
@


1.13
log
@The Ord exception is no longer at top level.
@
text
@d4 3
d49 3
a51 1
require "../basis/__integer";
d118 7
a124 1
    (* Need this vileness to cope with device names in PC locations *)
d128 6
a133 8
          if size s >= 3 andalso
            ((MLWorks.String.substring (s,0,1) >= "A" andalso MLWorks.String.substring (s,0,1) <= "Z") orelse
             (MLWorks.String.substring (s,0,1) >= "a" andalso MLWorks.String.substring (s,0,1) <= "a")) andalso
            MLWorks.String.substring (s,1,1) = ":" andalso
            (MLWorks.String.substring (s,2,1) < "0" orelse MLWorks.String.substring (s,2,1) > "9")
            then
              (MLWorks.String.substring (s,0,3),
               MLWorks.String.substring (s,3,size s - 3))
@


1.12
log
@Removing diagnostics
@
text
@d4 3
d68 1
a68 1
        String.implode [name, ":", Int.toString line]
d70 1
a70 1
        String.implode [name, ":", Int.toString line, ",", Int.toString column]
d74 1
a74 1
	  String.implode [name, ":", Int.toString s_line, ",", Int.toString s_col]
d76 1
a76 1
	  String.implode [name, ":", Int.toString s_line, ",",
d90 1
a90 1
                  if String.substring(string,index,subsize) = sub
d100 1
a100 1
            then (String.substring(string,index,stringsize-index)) :: acc
d104 2
a105 2
               ~1 => (String.substring(string,index,stringsize-index) :: acc)
             | n => aux(l,n+size delim,String.substring(string,index,n-index)::acc))
d118 4
a121 4
            ((String.substring (s,0,1) >= "A" andalso String.substring (s,0,1) <= "Z") orelse
             (String.substring (s,0,1) >= "a" andalso String.substring (s,0,1) <= "a")) andalso
            String.substring (s,1,1) = ":" andalso
            (String.substring (s,2,1) < "0" orelse String.substring (s,2,1) > "9")
d123 2
a124 2
              (String.substring (s,0,3),
               String.substring (s,3,size s - 3))
d143 1
a143 1
        (String.substring (s,0,unknown_size) = unknown_string)
d175 1
a175 1
        if String.ordof (str, pos) = String.ord "\n" then
d180 1
a180 1
          Ord => size str - 1
@


1.11
log
@Adding Windows device name parser thingy
@
text
@d4 3
d135 1
a135 1
          (MLWorks.IO.output (MLWorks.IO.terminal_out,"Invalid int " ^ s ^"\n");
d157 1
a157 1
         | _ => (MLWorks.IO.output (MLWorks.IO.terminal_out,"Invalid location 1 " ^ s ^"\n");
d159 1
a159 1
           handle InvalidInt => (MLWorks.IO.output (MLWorks.IO.terminal_out,"Invalid location 2 " ^ s ^"\n");
d202 1
a202 1
          (MLWorks.IO.output (MLWorks.IO.terminal_out,"Invalid location 3 " ^ to_string loc ^"\n");
@


1.10
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d107 1
d109 17
a125 1
      parse_string [":", ",", " to ", ","] s
d131 3
a133 1
      | _ => raise InvalidInt
d154 4
a157 2
         | _ => raise InvalidLocation)
           handle InvalidInt => raise InvalidLocation
d198 3
a200 1
      |   extract _ = raise InvalidLocation
@


1.9
log
@Removing utils/integer.sml
@
text
@d4 3
d56 1
a56 1
        implode [name, ":", Int.toString line]
d58 1
a58 1
        implode [name, ":", Int.toString line, ",", Int.toString column]
d62 1
a62 1
	  implode [name, ":", Int.toString s_line, ",", Int.toString s_col]
d64 1
a64 1
	  implode [name, ":", Int.toString s_line, ",",
d142 1
a142 1
        if String.ordof (str, pos) = ord "\n" then
@


1.8
log
@Add file_of_location to extract the filename part of a location
@
text
@d4 3
d31 1
a31 1
require "../utils/integer";
d34 1
a34 1
functor Location (structure Integer : INTEGER) : LOCATION =
d36 1
d53 1
a53 1
        implode [name, ":", Integer.makestring line]
d55 1
a55 1
        implode [name, ":", Integer.makestring line, ",", Integer.makestring column]
d59 1
a59 1
	  implode [name, ":", Integer.makestring s_line, ",", Integer.makestring s_col]
d61 3
a63 3
	  implode [name, ":", Integer.makestring s_line, ",",
		   Integer.makestring s_col, " to ", Integer.makestring e_line,
		   ",", Integer.makestring
d101 6
d115 1
a115 1
         | [name,line] => LINE(name,Integer.getint line)
d118 2
a119 2
                      Integer.getint line,
                      Integer.getint column)
d122 4
a125 4
                     s_line = Integer.getint s_line,
                     s_col = Integer.getint s_col,
                     e_line = Integer.getint e_line,
                     e_col = Integer.getint e_col}
d127 1
a127 1
           handle Integer.Invalid => raise InvalidLocation
@


1.7
log
@Made extract handle POSITION case.
@
text
@d4 3
d160 8
a167 1
  end;
@


1.6
log
@Added extract function.
@
text
@d4 3
d121 2
a122 3
    fun extract (EXTENT {s_line, s_col, e_line, e_col, ...}, str) =
      let
        (* input: number of lines to advance * start position.
d124 33
a156 20
        fun n_lines (1, pos) = pos
        |   n_lines (n, pos) =
          if String.ordof (str, pos) = ord "\n" then
            n_lines (n-1, pos+1)
          else
            n_lines (n, pos+1)
          handle
            Ord => size str - 1

        val s_pos = n_lines (s_line, 0) + s_col - 1;

        val e_pos =
          if s_line = e_line then
            s_pos + e_col - s_col
          else
            n_lines (e_line - s_line + 1, s_pos) + e_col - 1
      in
        (s_pos, e_pos)
      end
    |   extract _ = raise InvalidLocation
@


1.5
log
@Added result signature
@
text
@d4 3
d117 25
@


1.4
log
@Stopped printing of zero-length ranges as, e.g., 2,1 to 2,1.
Added first_col and first_line.
@
text
@d4 4
d22 1
a22 1
functor Location (structure Integer : INTEGER) =
@


1.3
log
@Added a function to parse a string representing a location
@
text
@d4 3
d30 3
d41 7
a47 2
	implode [name, ":", Integer.makestring s_line, ",", Integer.makestring s_col,
		 " to ", Integer.makestring e_line, ",", Integer.makestring e_col]
@


1.3.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.3  1993/04/15  16:30:16  matthew
Added a function to parse a string representing a location

@


1.2
log
@Added a range type to Location.T
@
text
@d4 3
d24 4
a27 1
    fun to_string UNKNOWN = "unknown location"
d37 58
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d18 2
a19 1
      POSITION of string * int * int
d27 8
@
