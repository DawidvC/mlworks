head	1.51;
access;
symbols
	MLW_daveb_inline_1_4_99:1.51.3
	MLWorks_21c0_1999_03_25:1.51
	MLWorks_20c1_1998_08_20:1.51
	MLWorks_20c0_1998_08_04:1.51
	MLWorks_20b2c2_1998_06_19:1.51
	MLWorks_20b2_Windows_1998_06_12:1.51
	MLWorks_20b1c1_1998_05_07:1.51
	MLWorks_20b0_1998_04_07:1.51
	MLWorks_20b0_1998_03_20:1.51
	MLWorks_20m2_1998_02_16:1.51
	MLWorks_20m1_1997_10_23:1.51
	MLWorks_11r1:1.50.5.1.1.1.1
	MLWorks_workspace_97:1.51.2
	MLWorks_dt_wizard:1.51.1
	MLWorks_11c0_1997_09_09:1.50.5.1.1.1
	MLWorks_10r3:1.50.5.1.3
	MLWorks_10r2_551:1.50.5.1.2
	MLWorks_11:1.50.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.50.5.1
	MLWorks_20m0_1997_06_20:1.51
	MLWorks_1_0_r2c2_1997_06_14:1.50.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.50.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.50.5
	MLWorks_BugFix_1997_04_24:1.50
	MLWorks_1_0_r2_Win32_1997_04_11:1.50
	MLWorks_1_0_r2_Unix_1997_04_04:1.50
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.50.3.1.1
	MLWorks_gui_1996_12_18:1.50.4
	MLWorks_1_0_Win32_1996_12_17:1.50.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.50.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.50.1.1
	MLWorks_1_0_Irix_1996_11_28:1.50.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.50.2
	MLWorks_1_0_Unix_1996_11_14:1.50.1
	MLWorks_Open_Beta2_1996_10_11:1.49.1
	MLWorks_License_dev:1.48.1
	MLWorks_1_open_beta_1996_09_13:1.46.1
	MLWorks_Open_Beta_1996_08_22:1.46
	MLWorks_Beta_1996_07_02:1.46
	MLWorks_Beta_1996_06_07:1.46
	MLWorks_Beta_1996_06_06:1.46
	MLWorks_Beta_1996_06_05:1.46
	MLWorks_Beta_1996_06_03:1.46
	MLWorks_Beta_1996_05_31:1.46
	MLWorks_Beta_1996_05_30:1.46
	ML_beta_release_12/08/94:1.35
	ML_beta_release_03/08/94:1.35
	ML_revised_beta_release_25/05/94:1.35
	ML_final_beta_release_02/03/94:1.35
	mlworks-28-01-1994:1.34
	Release:1.31
	mlworks-beta-01-09-1993:1.31
	MLWorks-1-0-4-29/01/1993:1.20
	MLWorks-1-0-3-21/12/1992:1.20
	MLWorks-1-0-2-15/12/1992:1.19
	MLWorks-1-0-1-04/12/1992:1.18
	checkpoint_17_08_92:1.13
	Ten15_release_19-11-91:1.4
	Ten15_release_21-08-91:1.4
	Ten15_release_19-08-91:1.4
	ten15_release:1.4;
locks; strict;
comment	@ * @;


1.51
date	97.05.01.12.24.09;	author jont;	state Exp;
branches
	1.51.1.1
	1.51.2.1
	1.51.3.1;
next	1.50;

1.50
date	96.10.28.17.26.08;	author andreww;	state Exp;
branches
	1.50.1.1
	1.50.2.1
	1.50.3.1
	1.50.4.1
	1.50.5.1;
next	1.49;

1.49
date	96.10.04.17.57.52;	author andreww;	state Exp;
branches
	1.49.1.1;
next	1.48;

1.48
date	96.10.04.10.55.51;	author matthew;	state Exp;
branches
	1.48.1.1;
next	1.47;

1.47
date	96.09.18.11.54.17;	author andreww;	state Exp;
branches;
next	1.46;

1.46
date	96.03.29.12.09.37;	author matthew;	state Exp;
branches
	1.46.1.1;
next	1.45;

1.45
date	96.03.26.15.06.51;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	96.03.18.16.50.04;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	96.01.16.12.21.40;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.12.27.12.37.35;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	95.12.05.12.21.04;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	95.11.22.09.26.58;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	95.09.05.14.08.05;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	95.08.31.13.13.32;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.01.17.13.34.02;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	94.09.14.11.41.07;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	94.02.28.05.52.34;	author nosa;	state Exp;
branches;
next	1.34;

1.34
date	93.12.03.16.36.45;	author nickh;	state Exp;
branches;
next	1.33;

1.33
date	93.11.25.09.31.43;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.09.03.10.19.13;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	93.08.12.14.56.00;	author daveb;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	93.08.06.13.14.07;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.07.09.11.52.27;	author nosa;	state Exp;
branches;
next	1.28;

1.28
date	93.07.02.15.59.56;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	93.05.20.12.14.39;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.05.18.18.38.35;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.04.06.11.52.27;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.03.09.12.54.49;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.02.16.17.44.26;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.02.08.15.37.49;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.02.03.17.48.15;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	92.12.17.17.33.09;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	92.12.08.14.48.38;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.10.14.12.06.37;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	92.10.09.13.38.49;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.09.08.15.32.19;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	92.09.04.08.26.07;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.09.02.14.09.23;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.08.12.12.18.18;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.08.04.12.20.24;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.06.29.10.54.38;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.06.15.09.31.03;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.06.11.08.25.29;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.05.19.17.37.39;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.04.13.15.50.28;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	91.11.22.17.11.14;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.11.21.15.56.00;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.06.27.13.40.50;	author colin;	state Exp;
branches;
next	1.3;

1.3
date	91.06.27.09.04.14;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	91.06.19.18.38.00;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.10.54.42;	author colin;	state Exp;
branches;
next	;

1.31.1.1
date	93.08.12.14.56.00;	author jont;	state Exp;
branches;
next	;

1.46.1.1
date	96.09.13.11.08.45;	author hope;	state Exp;
branches;
next	;

1.48.1.1
date	96.10.07.15.59.44;	author hope;	state Exp;
branches;
next	;

1.49.1.1
date	96.10.17.11.18.06;	author hope;	state Exp;
branches;
next	;

1.50.1.1
date	96.11.14.12.41.38;	author hope;	state Exp;
branches
	1.50.1.1.1.1;
next	;

1.50.1.1.1.1
date	96.11.28.14.53.31;	author hope;	state Exp;
branches;
next	;

1.50.2.1
date	96.11.22.18.02.04;	author hope;	state Exp;
branches;
next	;

1.50.3.1
date	96.12.17.17.41.00;	author hope;	state Exp;
branches
	1.50.3.1.1.1;
next	;

1.50.3.1.1.1
date	97.02.24.11.28.56;	author hope;	state Exp;
branches;
next	;

1.50.4.1
date	96.12.18.09.34.55;	author hope;	state Exp;
branches;
next	;

1.50.5.1
date	97.05.12.10.26.57;	author hope;	state Exp;
branches
	1.50.5.1.1.1
	1.50.5.1.2.1
	1.50.5.1.3.1;
next	;

1.50.5.1.1.1
date	97.07.28.18.12.58;	author daveb;	state Exp;
branches
	1.50.5.1.1.1.1.1;
next	;

1.50.5.1.1.1.1.1
date	97.10.07.11.37.59;	author jkbrook;	state Exp;
branches;
next	;

1.50.5.1.2.1
date	97.09.08.17.06.15;	author daveb;	state Exp;
branches;
next	;

1.50.5.1.3.1
date	97.09.09.14.01.41;	author daveb;	state Exp;
branches;
next	;

1.51.1.1
date	97.09.10.19.16.06;	author brucem;	state Exp;
branches;
next	;

1.51.2.1
date	97.09.11.20.45.57;	author daveb;	state Exp;
branches;
next	;

1.51.3.1
date	99.04.01.17.51.39;	author daveb;	state Exp;
branches;
next	;


desc
@> Abstract Syntax Datatype
@


1.51
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* _absyn.sml the functor *)
(*
$Log: _absyn.sml,v $
 * Revision 1.50  1996/10/28  17:26:08  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
 * Revision 1.49  1996/10/04  17:57:52  andreww
 * [Bug #1592]
 * threading location argument to local declaration expression
 * syntax.
 * /
 *
 * Revision 1.48  1996/10/04  10:55:51  matthew
 * [Bug #1622]
 * Adding some locations
 *
 * Revision 1.47  1996/09/18  11:54:17  andreww
 * [Bug #1577]
 * Adding production for datatype replication.
 *
 * Revision 1.46  1996/03/29  12:09:37  matthew
 * Adding WHEREsigxp properly
 *
 * Revision 1.45  1996/03/26  15:06:51  matthew
 * Adding explicit tyvars field to VALdec
 *
 * Revision 1.44  1996/03/18  16:50:04  matthew
 * New language definition
 *
 * Revision 1.43  1996/01/16  12:21:40  daveb
 * Added location information to SIGNATUREtopdec.
 *
Revision 1.42  1995/12/27  12:37:35  jont
Removing Option in favour of MLWorks.Option

Revision 1.41  1995/12/05  12:21:04  jont
Add functions to check strdecs and strexps for the location of
free imperative type variable errors

Revision 1.40  1995/11/22  09:26:58  daveb
Changed REQUIREtopdec to take a string instead of a module_id.

Revision 1.39  1995/09/05  14:08:05  daveb
Added types for different lengths of words, ints and reals.

Revision 1.38  1995/08/31  13:13:32  jont
Add location info to wild pats for use in redundancy warnings

Revision 1.37  1995/01/17  13:34:02  matthew
Renaming debugger_env to runtime_env

Revision 1.36  1994/09/14  11:41:07  matthew
Abstraction of debug information

Revision 1.35  1994/02/28  05:52:34  nosa
Type function, debugger structure, and structure recording for Modules Debugger.

Revision 1.34  1993/12/03  16:36:45  nickh
Added location information to COERCEexp.

Revision 1.33  1993/11/25  09:31:43  matthew
Added fixity annotations to APPexps and APPpats

Revision 1.32  1993/09/03  10:19:13  nosa
Runtime-instance in VALpats and LAYEREDpats and Compilation-instance
in VALexps for polymorphic debugger.

Revision 1.31  1993/08/12  14:56:00  daveb
Require declarations now take moduleids instead of strings.

Revision 1.30  1993/08/06  13:14:07  matthew
Added location information to matches

Revision 1.29  1993/07/09  11:52:27  nosa
structure Option.

Revision 1.28  1993/07/02  15:59:56  daveb
Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.

Revision 1.27  1993/05/20  12:14:39  matthew
Added abstractions

Revision 1.26  1993/05/18  18:38:35  jont
Removed integer parameter

Revision 1.25  1993/04/06  11:52:27  matthew
Added MLVALUEexp.  This is just used internally and has no concrete syntax currently

Revision 1.24  1993/03/09  12:54:49  matthew
Removed Datatypes substructure and replaced with Ident substructure
and Type and Structure types.

Revision 1.23  1993/02/16  17:44:26  matthew
Added dynamic and coerce abstract syntax

Revision 1.22  1993/02/08  15:37:49  matthew
Removed nameset structure and ref nameset from FunBind (which wasn't used)

Revision 1.21  1993/02/03  17:48:15  matthew
Rationalised functor parameter

Revision 1.20  1992/12/17  17:33:09  matthew
> Changed int and real scons to carry a location around

Revision 1.19  1992/12/08  14:48:38  jont
Removed a number of duplicated signatures and structures

Revision 1.18  1992/10/14  12:06:37  richard
Added location information to the `require' topdec.

Revision 1.17  1992/10/09  13:38:49  clive
Tynames now have a slot recording their definition point

Revision 1.16  1992/09/08  15:32:19  matthew
Added locations to some datatypes.

Revision 1.15  1992/09/04  08:26:07  richard
Installed central error reporting mechanism.

Revision 1.14  1992/09/02  14:09:23  richard
Insalled central error reporting mechanism.

Revision 1.13  1992/08/12  12:18:18  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.12  1992/08/04  12:20:24  jont
Tidied up functor argument to reducing number of parameters and sharing

Revision 1.11  1992/06/29  10:54:38  clive
Added a slot to appexp for debugging type information for function call type

Revision 1.10  1992/06/15  09:31:03  clive
Added debug info to handlers

Revision 1.9  1992/06/11  08:25:29  clive
Added some maarks for typechecker error messages

Revision 1.8  1992/05/19  17:37:39  clive
Added marks for better error reporting

Revision 1.7  1992/04/13  15:50:28  clive
First version of the profiler

Revision 1.6  1991/11/22  17:11:14  jont
Removed opens

Revision 1.5  91/11/21  15:56:00  jont
Added copyright message

Revision 1.4  91/06/27  13:40:50  colin
added Interface annotation for signature expressions

Revision 1.3  91/06/27  09:04:14  nickh
Added REQUIREtopdec of string.

Revision 1.2  91/06/19  18:38:00  colin
Added a type ref to HANDLEexp for ten15 code generator

Revision 1.1  91/06/07  10:54:42  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/set";
require "../utils/lists";
require "../typechecker/types";
require "../debugger/runtime_env";
require "absyn";

functor Absyn (
  structure Types : TYPES
  structure Set : SET
  structure Lists : LISTS
  structure RuntimeEnv : RUNTIMEENV

  sharing type RuntimeEnv.Type = Types.Datatypes.Type

) : ABSYN =
  struct
    structure Datatypes = Types.Datatypes
    structure Set = Set
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Location = Ident.Location

    type Type = Datatypes.Type
    type Tyfun = Datatypes.Tyfun
    type Instance = Datatypes.Instance
    type DebuggerStr = Datatypes.DebuggerStr
    type Structure = Datatypes.Structure
    type RuntimeInfo = RuntimeEnv.RuntimeInfo
    type InstanceInfo = Datatypes.InstanceInfo
    
    type options = Types.Options.options
  val print_type = Types.print_type

  val nullType = Datatypes.NULLTYPE
  val nullTyfun = Datatypes.TYFUN(nullType,0)
  val nullDebuggerStr = Datatypes.EMPTY_DSTR
  val nullRuntimeInfo = RuntimeEnv.RUNTIMEINFO (NONE,nil)
  val nullInstanceInfo = Datatypes.ZERO

  datatype Exp =
    SCONexp of Ident.SCon * Type ref | 
    VALexp of Ident.LongValId * Type ref * Ident.Location.T
               * (InstanceInfo * Instance ref option) ref |
    RECORDexp of (Ident.Lab * Exp) list|
    LOCALexp of Dec * Exp * Location.T |
    APPexp of Exp * Exp * Location.T * Datatypes.Type ref * bool |
    TYPEDexp of Exp * Ty * Location.T |
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp * Ident.Location.T) list * Location.T * string |
    RAISEexp of Exp * Location.T  |
    FNexp of (Pat * Exp * Ident.Location.T) list * Type ref * string * Ident.Location.T |
    DYNAMICexp of (Exp * Ident.TyVar Set.Set * (Type * int * Ident.TyVar Set.Set) ref) |
    COERCEexp of (Exp * Ty * Type ref * Ident.Location.T) |
    MLVALUEexp of MLWorks.Internal.Value.T



  and Dec = 
	  (* the two lists in VALdec list the bindings before and after
	   the first occurence of rec. tyvarset is used to hold
	   information about tyvars scoped at this particular value
	   declaration (see 4.6 in The Definition *)

     VALdec of (Pat * Exp * Location.T) list *  (Pat * Exp * Location.T) list *
     Ident.TyVar Set.Set * Ident.TyVar list |
     TYPEdec of (Ident.TyVar list * Ident.TyCon * Ty * Tyfun ref option) list |
     DATATYPEdec of Location.T *
                    (Ident.TyVar list * Ident.TyCon *
		     Datatypes.Type ref * Tyfun ref option * 
		     ((Ident.ValId * Datatypes.Type ref) *
		      Ty option) list) list |
     DATATYPErepl of Ident.Location.T *
                     (Ident.TyCon * Ident.LongTyCon) *
                      Datatypes.Valenv option ref|
     ABSTYPEdec of Location.T *
                   (Ident.TyVar list * Ident.TyCon *
		    Datatypes.Type ref * Tyfun ref option * 
		    ((Ident.ValId * Datatypes.Type ref) *
		     Ty option) list) list * Dec |
     EXCEPTIONdec of ExBind list|
     LOCALdec of Dec * Dec |
     OPENdec of Ident.LongStrId list * Ident.Location.T |
     SEQUENCEdec of Dec list

  and ExBind = 
    NEWexbind of ((Ident.ValId * Datatypes.Type ref) * Ty option * Location.T * string) |
    OLDexbind of ((Ident.ValId * Datatypes.Type ref) *
		  Ident.LongValId * Location.T * string)

  and Pat =
    WILDpat of Ident.Location.T |
    SCONpat of Ident.SCon * Type ref |
    VALpat of (Ident.LongValId * (Datatypes.Type ref * RuntimeInfo ref))
    * Ident.Location.T |
    RECORDpat of (Ident.Lab * Pat) list * bool * Datatypes.Type ref |
    APPpat of (Ident.LongValId * Datatypes.Type ref) * Pat * Location.T * bool |
    TYPEDpat of Pat * Ty  * Location.T |
    LAYEREDpat of (Ident.ValId * (Datatypes.Type ref * RuntimeInfo ref)) * Pat

  and Ty =
    TYVARty of Ident.TyVar |
    RECORDty of (Ident.Lab * Ty) list |
    APPty of Ty list * Ident.LongTyCon * Location.T |
    FNty of Ty * Ty

  (* The following datatypes are for the modules syntax classes *)

  datatype StrExp =
    NEWstrexp of StrDec |
    OLDstrexp of Ident.LongStrId * Ident.Location.T * Structure option ref option |
    APPstrexp of Ident.FunId * StrExp * bool ref * Location.T * DebuggerStr ref option |
    CONSTRAINTstrexp of StrExp * SigExp * bool * bool ref * Location.T |
    LOCALstrexp of StrDec * StrExp

  and StrDec =
    DECstrdec of Dec |
    STRUCTUREstrdec of
      (Ident.StrId * (SigExp * bool) option * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref option * Structure option ref option) list
      |
    ABSTRACTIONstrdec of
      (Ident.StrId * (SigExp * bool) option * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref option * Structure option ref option) list |
    LOCALstrdec of StrDec * StrDec |
    SEQUENCEstrdec of StrDec list

  and SigExp =
    NEWsigexp of Spec * Datatypes.Structure option ref | 
    OLDsigexp of Ident.SigId * Datatypes.Structure option ref * Location.T |
    WHEREsigexp of (SigExp * (Ident.TyVar list * Ident.LongTyCon * Ty * Location.T) list)

  and Spec =
    VALspec of (Ident.ValId * Ty * Ident.TyVar Set.Set) list * Location.T |
    TYPEspec of (Ident.TyVar list * Ident.TyCon) list |
    EQTYPEspec of (Ident.TyVar list * Ident.TyCon) list |
    DATATYPEspec of (Ident.TyVar list * Ident.TyCon *
		     (Ident.ValId * Ty option * Location.T) list) list |
    DATATYPEreplSpec of Ident.Location.T * Ident.TyCon * Ident.LongTyCon * 
                       (Ident.ValId * Type option * Location.T) list option ref |
    EXCEPTIONspec of (Ident.ValId * Ty option * Location.T) list |
    STRUCTUREspec of (Ident.StrId * SigExp) list |
    SHARINGspec of Spec * (SharEq * Location.T) list |
    LOCALspec of Spec * Spec |
    OPENspec of Ident.LongStrId list * Location.T |
    INCLUDEspec of SigExp * Location.T |
    SEQUENCEspec of Spec list

  and SharEq =
    STRUCTUREshareq of Ident.LongStrId list |
    TYPEshareq of Ident.LongTyCon list

  datatype SigBind = SIGBIND of (Ident.SigId * SigExp * Location.T) list
             
  datatype FunBind = 
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * (SigExp * bool) option *
		string * bool ref * Ident.Location.T * DebuggerStr ref option * Structure option ref option) list 

  datatype TopDec =
    STRDECtopdec of StrDec * Location.T |
    SIGNATUREtopdec of SigBind list * Location.T |
    FUNCTORtopdec of FunBind list * Location.T |
    REQUIREtopdec of string * Location.T

  val empty_tyvarset = Set.empty_set

(*
  fun expansivep (VALexp _) = false
    | expansivep (FNexp _) = false
    | expansivep (TYPEDexp (e,_,_)) = expansivep e
    | expansivep _ = true
*)

  fun expansive_op (Ident.LONGVALID (Ident.NOPATH,Ident.CON s)) =
    Symbol.symbol_name s = "ref"
    | expansive_op (Ident.LONGVALID (_,Ident.CON s)) = false
    | expansive_op (Ident.LONGVALID (_,Ident.EXCON s)) = false
    | expansive_op _ = true

  fun expansivep (SCONexp _) = false
    | expansivep (VALexp _) = false
    | expansivep (RECORDexp labexplist) =
      Lists.exists (fn (lab,exp) => expansivep exp) labexplist
    | expansivep (APPexp (VALexp (v,_,_,_),exp2,_,_,_)) = 
      expansive_op v orelse expansivep exp2
    | expansivep (TYPEDexp (e,_,_)) = expansivep e
    | expansivep (HANDLEexp (exp,_,_,_,_)) =
      expansivep exp
    | expansivep (FNexp _) = false
    | expansivep _ = true

  fun has_tyvar (TYVARty _) = true
    | has_tyvar (RECORDty lab_tylist) = 
      let 
	fun collect ([]) = false
	  | collect ((_,ty)::lab_tylist) = 
	    has_tyvar (ty) orelse collect (lab_tylist)
      in
	collect (lab_tylist)
      end
    | has_tyvar (APPty (tylist,_,_)) = 
      let
	fun collect ([]) = false
	  | collect (ty::tylist) = 	has_tyvar (ty) orelse collect (tylist)
      in
	collect (tylist)
      end
    | has_tyvar (FNty (ty,ty')) = has_tyvar (ty) orelse has_tyvar (ty')

  fun check_ty(ty, ty', loc) =
    (* See if ty = ty' or ty occurs in ty' *)
    if Types.type_occurs(ty', ty) then
      SOME loc
    else
      NONE

  fun get_loc_from_pat(WILDpat loc) = SOME loc
    | get_loc_from_pat(SCONpat _) = NONE
    | get_loc_from_pat(VALpat(_, loc)) = SOME loc
    | get_loc_from_pat(RECORDpat(lab_pat_list, _, _)) =
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, (_, pat)) => get_loc_from_pat pat)
      (NONE, lab_pat_list)
    | get_loc_from_pat(APPpat(_, _, loc, _)) =
      SOME loc
    | get_loc_from_pat(TYPEDpat(_, _, loc)) =
      SOME loc
    | get_loc_from_pat(LAYEREDpat(_, pat)) =
      get_loc_from_pat pat

  fun check_pat_for_free_imp(WILDpat _, _, _) = NONE
    | check_pat_for_free_imp(SCONpat _, _, _) = NONE
    | check_pat_for_free_imp(VALpat((_, (ref ty', _)), loc), ty, _) =
      check_ty(ty', ty, loc)
    | check_pat_for_free_imp(RECORDpat(lab_pat_list, _, _), ty, loc') =
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, (_, pat)) => check_pat_for_free_imp(pat, ty, loc'))
      (NONE, lab_pat_list)
    | check_pat_for_free_imp(APPpat(_, pat, _, _), ty, loc) =
      check_pat_for_free_imp(pat, ty, loc)
    | check_pat_for_free_imp(TYPEDpat(pat, _, _), ty, loc) =
      check_pat_for_free_imp(pat, ty, loc)
    | check_pat_for_free_imp(LAYEREDpat((_, (ref ty', _)), pat), ty, loc) =
      if Types.type_occurs(ty, ty') then
	case get_loc_from_pat pat of
	  (* Use this location if no other available *)
	  NONE => SOME loc
	| x => x
      else
	NONE

  fun check_exbind_for_free_imp(NEWexbind((_, ref ty'), _, loc, _), ty) =
    check_ty(ty, ty', loc)
    | check_exbind_for_free_imp(OLDexbind((_, ref ty'), _, loc, _), ty) =
      check_ty(ty, ty', loc)

  fun check_dec_for_free_imp(VALdec(dec_list1, dec_list2,_,_), ty) =
    let
      fun check_pat_exp(loc as SOME _, _) =
	loc
	| check_pat_exp(_, (pat, exp, loc)) =
	  case check_pat_for_free_imp(pat, ty, loc) of
	    NONE =>
	      check_exp_for_free_imp(exp, ty)
	  | x => x
    in
      case Lists.reducel
	check_pat_exp
	(NONE, dec_list1) of
	NONE => Lists.reducel
	  check_pat_exp
	  (NONE, dec_list2)
      | x => x
    end
    | check_dec_for_free_imp(TYPEdec _, _) = NONE
    | check_dec_for_free_imp(DATATYPEdec _, _) = NONE
    | check_dec_for_free_imp(DATATYPErepl _, _) = NONE
    | check_dec_for_free_imp(ABSTYPEdec _, _) = NONE
    | check_dec_for_free_imp(EXCEPTIONdec e_list, ty) =
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, e_bind) => check_exbind_for_free_imp(e_bind, ty))
      (NONE, e_list)
    | check_dec_for_free_imp(LOCALdec(dec, dec'), ty) =
      (case check_dec_for_free_imp(dec, ty) of
	 loc as SOME _ => loc
       | _ => check_dec_for_free_imp(dec', ty))
    | check_dec_for_free_imp(OPENdec _, _) = NONE
    | check_dec_for_free_imp(SEQUENCEdec dec_list, ty) =
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, dec) =>
	check_dec_for_free_imp(dec, ty))
      (NONE, dec_list)

  and check_exp_for_free_imp(SCONexp _, ty) = NONE
    | check_exp_for_free_imp(VALexp _, ty) = NONE
    | check_exp_for_free_imp(RECORDexp lab_exp_list, ty) =
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, (_, exp)) =>
	check_exp_for_free_imp(exp, ty))
      (NONE, lab_exp_list)
    | check_exp_for_free_imp(LOCALexp(dec, exp,_), ty) =
      (case check_dec_for_free_imp(dec, ty) of
	 NONE =>
	   check_exp_for_free_imp(exp, ty)
       | x => x)
    | check_exp_for_free_imp(APPexp(exp1, exp2, _, _, _), ty) =
      (case check_exp_for_free_imp(exp1, ty) of
	 NONE =>
	   check_exp_for_free_imp(exp2, ty)
       | x => x)
    | check_exp_for_free_imp(TYPEDexp(exp, _, _), ty) =
      check_exp_for_free_imp(exp, ty)
    | check_exp_for_free_imp(HANDLEexp(exp, _, pe_list, _, _), ty)=
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, (_, exp, _)) =>
	check_exp_for_free_imp(exp, ty))
      (NONE, pe_list)
    | check_exp_for_free_imp(RAISEexp(exp, _), ty) =
      check_exp_for_free_imp(exp, ty)
    | check_exp_for_free_imp(FNexp(pe_list, _, _, _), ty) =
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, (_, exp, _)) =>
	check_exp_for_free_imp(exp, ty))
      (NONE, pe_list)
    | check_exp_for_free_imp(DYNAMICexp(exp, _, _), ty) =
      check_exp_for_free_imp(exp, ty)
    | check_exp_for_free_imp(COERCEexp(exp, _, _, _), ty) =
      check_exp_for_free_imp(exp, ty)
    | check_exp_for_free_imp(MLVALUEexp _, ty) = NONE

  fun check_strexp_for_free_imp(NEWstrexp strdec, ty) =
    check_strdec_for_free_imp(strdec, ty)
    | check_strexp_for_free_imp(OLDstrexp _, ty) =
      NONE
    | check_strexp_for_free_imp(APPstrexp _, ty) =
      NONE
    | check_strexp_for_free_imp(LOCALstrexp(strdec, strexp), ty) =
      (case check_strdec_for_free_imp(strdec, ty) of
         NONE =>
           check_strexp_for_free_imp(strexp, ty)
       | x => x)
    | check_strexp_for_free_imp(CONSTRAINTstrexp (strexp,_,_,_,_),ty) =
      check_strexp_for_free_imp (strexp,ty)

  and check_strdec_for_free_imp(DECstrdec dec, ty) =
    check_dec_for_free_imp(dec, ty)
    | check_strdec_for_free_imp(STRUCTUREstrdec e_list, ty) =
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, (_, _, strexp, _, _, _, _)) =>
	check_strexp_for_free_imp(strexp, ty))
      (NONE, e_list)
    | check_strdec_for_free_imp(ABSTRACTIONstrdec abs_list, ty) =
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, {3=strexp, ...}) => check_strexp_for_free_imp(strexp, ty))
      (NONE, abs_list)
    | check_strdec_for_free_imp(LOCALstrdec(strdec1, strdec2), ty) =
      (case check_strdec_for_free_imp(strdec1, ty) of
	 NONE => check_strdec_for_free_imp(strdec2, ty)
       | x => x)
    | check_strdec_for_free_imp(SEQUENCEstrdec s_list, ty) =
      Lists.reducel
      (fn (loc as SOME _, _) => loc
    | (_, strdec) => check_strdec_for_free_imp(strdec, ty))
      (NONE, s_list)

end
@


1.51.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.51  1997/05/01  12:24:09  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.51.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.51  1997/05/01  12:24:09  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.51.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.51  1997/05/01  12:24:09  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.50
log
@[Bug #1708]
changing syntax of datatype replication.
@
text
@d4 4
d204 1
a204 1
  val nullRuntimeInfo = RuntimeEnv.RUNTIMEINFO (MLWorks.Option.NONE,nil)
d210 1
a210 1
               * (InstanceInfo * Instance ref MLWorks.Option.option) ref |
d232 1
a232 1
     TYPEdec of (Ident.TyVar list * Ident.TyCon * Ty * Tyfun ref MLWorks.Option.option) list |
d235 1
a235 1
		     Datatypes.Type ref * Tyfun ref MLWorks.Option.option * 
d237 1
a237 1
		      Ty MLWorks.Option.option) list) list |
d243 1
a243 1
		    Datatypes.Type ref * Tyfun ref MLWorks.Option.option * 
d245 1
a245 1
		     Ty MLWorks.Option.option) list) list * Dec |
d252 1
a252 1
    NEWexbind of ((Ident.ValId * Datatypes.Type ref) * Ty MLWorks.Option.option * Location.T * string) |
d276 2
a277 2
    OLDstrexp of Ident.LongStrId * Ident.Location.T * Structure MLWorks.Option.option ref MLWorks.Option.option |
    APPstrexp of Ident.FunId * StrExp * bool ref * Location.T * DebuggerStr ref MLWorks.Option.option |
d284 2
a285 2
      (Ident.StrId * (SigExp * bool) MLWorks.Option.option * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref MLWorks.Option.option * Structure MLWorks.Option.option ref MLWorks.Option.option) list
d288 2
a289 2
      (Ident.StrId * (SigExp * bool) MLWorks.Option.option * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref MLWorks.Option.option * Structure MLWorks.Option.option ref MLWorks.Option.option) list |
d294 2
a295 2
    NEWsigexp of Spec * Datatypes.Structure MLWorks.Option.option ref | 
    OLDsigexp of Ident.SigId * Datatypes.Structure MLWorks.Option.option ref * Location.T |
d303 1
a303 1
		     (Ident.ValId * Ty MLWorks.Option.option * Location.T) list) list |
d306 1
a306 1
    EXCEPTIONspec of (Ident.ValId * Ty MLWorks.Option.option * Location.T) list |
d321 2
a322 2
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * (SigExp * bool) MLWorks.Option.option *
		string * bool ref * Ident.Location.T * DebuggerStr ref MLWorks.Option.option * Structure MLWorks.Option.option ref MLWorks.Option.option) list 
d378 1
a378 1
      MLWorks.Option.SOME loc
d380 1
a380 1
      MLWorks.Option.NONE
d382 3
a384 3
  fun get_loc_from_pat(WILDpat loc) = MLWorks.Option.SOME loc
    | get_loc_from_pat(SCONpat _) = MLWorks.Option.NONE
    | get_loc_from_pat(VALpat(_, loc)) = MLWorks.Option.SOME loc
d387 1
a387 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d389 1
a389 1
      (MLWorks.Option.NONE, lab_pat_list)
d391 1
a391 1
      MLWorks.Option.SOME loc
d393 1
a393 1
      MLWorks.Option.SOME loc
d397 2
a398 2
  fun check_pat_for_free_imp(WILDpat _, _, _) = MLWorks.Option.NONE
    | check_pat_for_free_imp(SCONpat _, _, _) = MLWorks.Option.NONE
d403 1
a403 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d405 1
a405 1
      (MLWorks.Option.NONE, lab_pat_list)
d414 1
a414 1
	  MLWorks.Option.NONE => MLWorks.Option.SOME loc
d417 1
a417 1
	MLWorks.Option.NONE
d426 1
a426 1
      fun check_pat_exp(loc as MLWorks.Option.SOME _, _) =
d430 1
a430 1
	    MLWorks.Option.NONE =>
d436 2
a437 2
	(MLWorks.Option.NONE, dec_list1) of
	MLWorks.Option.NONE => Lists.reducel
d439 1
a439 1
	  (MLWorks.Option.NONE, dec_list2)
d442 4
a445 4
    | check_dec_for_free_imp(TYPEdec _, _) = MLWorks.Option.NONE
    | check_dec_for_free_imp(DATATYPEdec _, _) = MLWorks.Option.NONE
    | check_dec_for_free_imp(DATATYPErepl _, _) = MLWorks.Option.NONE
    | check_dec_for_free_imp(ABSTYPEdec _, _) = MLWorks.Option.NONE
d448 1
a448 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d450 1
a450 1
      (MLWorks.Option.NONE, e_list)
d453 1
a453 1
	 loc as MLWorks.Option.SOME _ => loc
d455 1
a455 1
    | check_dec_for_free_imp(OPENdec _, _) = MLWorks.Option.NONE
d458 1
a458 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d461 1
a461 1
      (MLWorks.Option.NONE, dec_list)
d463 2
a464 2
  and check_exp_for_free_imp(SCONexp _, ty) = MLWorks.Option.NONE
    | check_exp_for_free_imp(VALexp _, ty) = MLWorks.Option.NONE
d467 1
a467 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d470 1
a470 1
      (MLWorks.Option.NONE, lab_exp_list)
d473 1
a473 1
	 MLWorks.Option.NONE =>
d478 1
a478 1
	 MLWorks.Option.NONE =>
d485 1
a485 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d488 1
a488 1
      (MLWorks.Option.NONE, pe_list)
d493 1
a493 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d496 1
a496 1
      (MLWorks.Option.NONE, pe_list)
d501 1
a501 1
    | check_exp_for_free_imp(MLVALUEexp _, ty) = MLWorks.Option.NONE
d506 1
a506 1
      MLWorks.Option.NONE
d508 1
a508 1
      MLWorks.Option.NONE
d511 1
a511 1
         MLWorks.Option.NONE =>
d521 1
a521 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d524 1
a524 1
      (MLWorks.Option.NONE, e_list)
d527 1
a527 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d529 1
a529 1
      (MLWorks.Option.NONE, abs_list)
d532 1
a532 1
	 MLWorks.Option.NONE => check_strdec_for_free_imp(strdec2, ty)
d536 1
a536 1
      (fn (loc as MLWorks.Option.SOME _, _) => loc
d538 1
a538 1
      (MLWorks.Option.NONE, s_list)
@


1.50.5.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:26:08  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.50.5.1  1997/05/12  10:26:57  hope
 * branched from 1.50
 *
@


1.50.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.50.5.1  1997/05/12  10:26:57  hope
 * branched from 1.50
 *
@


1.50.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.50.5.1  1997/05/12  10:26:57  hope
 * branched from 1.50
 *
@


1.50.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.50.5.1.1.1  1997/07/28  18:12:58  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.50.4.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:26:08  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.3.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:26:08  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.3.1.1.1
log
@branched from 1.50.3.1
@
text
@a3 3
 * Revision 1.50.3.1  1996/12/17  17:41:00  hope
 * branched from 1.50
 *
@


1.50.2.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:26:08  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.1.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:26:08  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.1.1.1.1
log
@branched from 1.50.1.1
@
text
@a3 3
 * Revision 1.50.1.1  1996/11/14  12:41:38  hope
 * branched from 1.50
 *
@


1.49
log
@[Bug #1592]
threading location argument to local declaration expression
syntax.
/
@
text
@d4 6
d235 1
a235 2
                     (Ident.TyVar list * Ident.TyCon *
                      Ident.LongTyCon) *
d300 1
a300 1
    DATATYPEreplSpec of Ident.Location.T * Ident.TyVar list * Ident.TyCon * Ident.LongTyCon * 
@


1.49.1.1
log
@branched from 1.49
@
text
@a3 6
 * Revision 1.49  1996/10/04  17:57:52  andreww
 * [Bug #1592]
 * threading location argument to local declaration expression
 * syntax.
 * /
 *
@


1.48
log
@[Bug #1622]
Adding some locations
@
text
@d4 4
d202 1
a202 1
    LOCALexp of Dec * Exp |
d462 1
a462 1
    | check_exp_for_free_imp(LOCALexp(dec, exp), ty) =
@


1.48.1.1
log
@branched from 1.48
@
text
@a3 4
 * Revision 1.48  1996/10/04  10:55:51  matthew
 * [Bug #1622]
 * Adding some locations
 *
@


1.47
log
@[Bug #1577]
Adding production for datatype replication.
@
text
@d4 4
d290 1
a290 1
		     (Ident.ValId * Ty MLWorks.Option.option) list) list |
d292 1
a292 1
                       (Ident.ValId * Type option) list option ref |
@


1.46
log
@Adding WHEREsigxp properly
@
text
@d4 3
d180 3
d220 4
d287 2
d427 1
@


1.46.1.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/03/29  12:09:37  matthew
 * Adding WHEREsigxp properly
 *
@


1.45
log
@Adding explicit tyvars field to VALdec
@
text
@d4 3
d251 1
a251 1
    CONSTRAINTstrexp of StrExp * SigExp * bool * bool ref|
d269 1
a269 1
    WHEREsigexp of SigExp (* * stuff *)
d272 1
a272 1
    VALspec of (Ident.ValId * Ty * Ident.TyVar Set.Set) list |
d279 1
a279 1
    SHARINGspec of (SharEq * Location.T) list |
d484 1
a484 1
    | check_strexp_for_free_imp(CONSTRAINTstrexp (strexp,_,_,_),ty) =
@


1.44
log
@New language definition
@
text
@d4 3
d204 1
a204 1
     Ident.TyVar Set.Set|
d248 1
d254 1
a254 1
      (Ident.StrId * SigExp MLWorks.Option.option * StrExp * bool ref 
d258 1
a258 1
      (Ident.StrId * SigExp MLWorks.Option.option * StrExp * bool ref 
d265 2
a266 1
    OLDsigexp of Ident.SigId * Datatypes.Structure MLWorks.Option.option ref * Location.T
d279 1
a279 1
    INCLUDEspec of Ident.SigId list * Location.T |
d289 1
a289 1
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * SigExp MLWorks.Option.option *
d392 1
a392 1
  fun check_dec_for_free_imp(VALdec(dec_list1, dec_list2, _), ty) =
d477 6
a482 4
      case check_strdec_for_free_imp(strdec, ty) of
	MLWorks.Option.NONE =>
	  check_strexp_for_free_imp(strexp, ty)
      | x => x
@


1.43
log
@Added location information to SIGNATUREtopdec.
@
text
@d4 3
d160 1
d295 1
d299 19
@


1.42
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d285 1
a285 1
    SIGNATUREtopdec of SigBind list |
@


1.41
log
@Add functions to check strdecs and strexps for the location of
free imperative type variable errors
@
text
@d4 4
a147 1
  sharing Types.Datatypes.Option = RuntimeEnv.Option
a153 1
    structure Option = Datatypes.Option
d167 1
a167 1
  val nullRuntimeInfo = RuntimeEnv.RUNTIMEINFO (Option.ABSENT,nil)
d173 1
a173 1
               * (InstanceInfo * Instance ref Option.opt) ref |
d195 1
a195 1
     TYPEdec of (Ident.TyVar list * Ident.TyCon * Ty * Tyfun ref Option.opt) list |
d198 1
a198 1
		     Datatypes.Type ref * Tyfun ref Option.opt * 
d200 1
a200 1
		      Ty Option.opt) list) list |
d203 1
a203 1
		    Datatypes.Type ref * Tyfun ref Option.opt * 
d205 1
a205 1
		     Ty Option.opt) list) list * Dec |
d212 1
a212 1
    NEWexbind of ((Ident.ValId * Datatypes.Type ref) * Ty Option.opt * Location.T * string) |
d236 2
a237 2
    OLDstrexp of Ident.LongStrId * Ident.Location.T * Structure Option.opt ref Option.opt |
    APPstrexp of Ident.FunId * StrExp * bool ref * Location.T * DebuggerStr ref Option.opt |
d243 2
a244 2
      (Ident.StrId * SigExp Option.opt * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref Option.opt * Structure Option.opt ref Option.opt) list
d247 2
a248 2
      (Ident.StrId * SigExp Option.opt * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref Option.opt * Structure Option.opt ref Option.opt) list |
d253 2
a254 2
    NEWsigexp of Spec * Datatypes.Structure Option.opt ref | 
    OLDsigexp of Ident.SigId * Datatypes.Structure Option.opt ref * Location.T
d261 2
a262 2
		     (Ident.ValId * Ty Option.opt) list) list |
    EXCEPTIONspec of (Ident.ValId * Ty Option.opt * Location.T) list |
d277 2
a278 2
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * SigExp Option.opt *
		string * bool ref * Ident.Location.T * DebuggerStr ref Option.opt * Structure Option.opt ref Option.opt) list 
@


1.40
log
@Changed REQUIREtopdec to take a string instead of a module_id.
@
text
@d4 3
d132 2
a133 1
require "../typechecker/datatypes";
d138 1
a138 1
  structure Datatypes : DATATYPES
d140 1
d143 2
a144 2
  sharing type RuntimeEnv.Type = Datatypes.Type
  sharing Datatypes.Option = RuntimeEnv.Option
d148 1
a148 1
    structure Datatypes = Datatypes
d308 163
@


1.39
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
a130 1
require "module_id";
a134 1
  structure ModuleId : MODULE_ID
a138 1
  sharing type Datatypes.Ident.Symbol.Symbol = ModuleId.Symbol
a153 1
    type ModuleId = ModuleId.ModuleId
d277 1
a277 1
    REQUIREtopdec of ModuleId * Location.T
@


1.38
log
@Add location info to wild pats for use in redundancy warnings
@
text
@d4 3
d165 1
a165 1
    SCONexp of Ident.SCon | 
d212 1
a212 1
    SCONpat of Ident.SCon |
@


1.37
log
@Renaming debugger_env to runtime_env
@
text
@d4 3
d208 1
a208 1
    WILDpat |
@


1.36
log
@Abstraction of debug information
@
text
@d4 3
d121 1
a121 1
require "../debugger/debugger_env";
d150 1
d156 1
d161 1
a161 1
               * (int list * Instance ref Option.opt) ref |
@


1.35
log
@Type function, debugger structure, and structure recording for Modules Debugger.
@
text
@d4 3
d118 1
d126 1
d128 1
d130 2
d146 1
d151 1
d202 1
a202 2
    VALpat of (Ident.LongValId * (Type * Instance ref Option.opt 
                                  * (Tyfun ref * (int,int) Option.option ref) list) ref)
d207 1
a207 2
    LAYEREDpat of (Ident.ValId * (Type * Instance ref Option.opt 
                                  * (Tyfun ref * (int,int) Option.option ref) list) ref) * Pat
@


1.34
log
@Added location information to COERCEexp.
@
text
@d4 3
d133 3
a135 1
    type Instance = Datatypes.instance
d140 2
d146 1
a146 1
               * (int list * Instance ref Option.opt) ref Option.opt |
d168 1
a168 1
     TYPEdec of (Ident.TyVar list * Ident.TyCon * Ty) list |
d171 1
a171 1
		     Datatypes.Type ref * 
d176 1
a176 1
		    Datatypes.Type ref * 
d181 1
a181 1
     OPENdec of Ident.LongStrId list * Location.T |
d192 2
a193 1
    VALpat of (Ident.LongValId * (Type * Instance ref Option.opt) ref)
d198 2
a199 1
    LAYEREDpat of (Ident.ValId * (Type * Instance ref Option.opt) ref) * Pat
d211 2
a212 2
    OLDstrexp of Ident.LongStrId * Location.T |
    APPstrexp of Ident.FunId * StrExp * bool ref * Location.T |
d218 3
a220 1
      (Ident.StrId * SigExp Option.opt * StrExp * bool ref * Location.T) list |
d222 2
a223 1
      (Ident.StrId * SigExp Option.opt * StrExp * bool ref * Location.T) list |
d250 1
a250 1
           
d253 1
a253 1
		string * bool ref * Location.T) list 
@


1.33
log
@Added fixity annotations to APPexps and APPpats
@
text
@d4 3
d148 1
a148 1
    COERCEexp of (Exp * Ty * Type ref) |
@


1.32
log
@Runtime-instance in VALpats and LAYEREDpats and Compilation-instance
in VALexps for polymorphic debugger.
@
text
@d4 4
d139 1
a139 1
    APPexp of Exp * Exp * Location.T * Datatypes.Type ref |
d185 1
a185 1
    APPpat of (Ident.LongValId * Datatypes.Type ref) * Pat * Location.T |
@


1.31
log
@Require declarations now take moduleids instead of strings.
@
text
@d4 3
d123 1
d131 2
a132 1
    VALexp of (Ident.LongValId * Type ref * Ident.Location.T) |
d141 1
a141 1
    COERCEexp of (Exp * Ty * Datatypes.Type ref) |
d178 2
a179 1
    VALpat of (Ident.LongValId * Datatypes.Type ref) * Location.T |
d183 1
a183 1
    LAYEREDpat of (Ident.ValId * Type ref) * Pat
@


1.31.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.31  1993/08/12  14:56:00  daveb
Require declarations now take moduleids instead of strings.

@


1.30
log
@Added location information to matches
@
text
@d4 3
a100 1
require "../utils/option";
d102 1
d107 1
d109 3
a111 2
  structure Option : OPTION
    ) : ABSYN =
d116 1
a116 1
    structure Option = Option
d121 1
d234 1
a234 1
    REQUIREtopdec of string * Location.T
@


1.29
log
@structure Option.
@
text
@d4 3
d126 1
a126 1
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp) list * Location.T * string |
d128 1
a128 1
    FNexp of (Pat * Exp) list * Type ref * string * Ident.Location.T |
@


1.28
log
@Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.
@
text
@d4 4
d95 1
d102 1
d108 1
d114 1
a114 3
    val nullType = Datatypes.NULLTYPE

    datatype 'a opt = PRESENT of 'a | ABSENT
d118 1
a118 1
    VALexp of (Ident.LongValId * Datatypes.Type ref * Location.T) |
d124 2
a125 2
    RAISEexp of Exp * Location.T |
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string * Location.T |
d145 1
a145 1
		      Ty opt) list) list |
d150 1
a150 1
		     Ty opt) list) list * Dec |
d157 1
a157 1
    NEWexbind of ((Ident.ValId * Datatypes.Type ref) * Ty opt * Location.T * string) |
d168 1
a168 1
    LAYEREDpat of (Ident.ValId * Datatypes.Type ref) * Pat
d187 1
a187 1
      (Ident.StrId * SigExp opt * StrExp * bool ref * Location.T) list |
d189 1
a189 1
      (Ident.StrId * SigExp opt * StrExp * bool ref * Location.T) list |
d194 2
a195 2
    NEWsigexp of Spec * Datatypes.Structure opt ref | 
    OLDsigexp of Ident.SigId * Datatypes.Structure opt ref * Location.T
d202 2
a203 2
		     (Ident.ValId * Ty opt) list) list |
    EXCEPTIONspec of (Ident.ValId * Ty opt * Location.T) list |
d218 1
a218 1
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * SigExp opt *
@


1.27
log
@Added abstractions
@
text
@d4 3
d176 1
a176 1
    APPstrexp of Ident.FunId * StrExp * Location.T |
d181 4
a184 2
    STRUCTUREstrdec of (Ident.StrId * SigExp opt * StrExp * Location.T) list |
    ABSTRACTIONstrdec of (Ident.StrId * SigExp opt * StrExp * Location.T) list |
d213 2
a214 2
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp *
		StrExp * SigExp opt * string * Location.T) list 
@


1.26
log
@Removed integer parameter
@
text
@d4 3
d179 1
@


1.25
log
@Added MLVALUEexp.  This is just used internally and has no concrete syntax currently
@
text
@d4 3
a83 1
require "../utils/integer";
a88 1
  structure Integer : INTEGER
a92 1

d96 1
a96 2
    structure Location = Datatypes.Ident.Location
    structure Ident = Datatypes.Ident
@


1.24
log
@Removed Datatypes substructure and replaced with Ident substructure
and Type and Structure types.
@
text
@d4 4
d116 3
a118 2
    DYNAMICexp of (Exp * Datatypes.Type ref) |
    COERCEexp of (Exp * Ty * Datatypes.Type ref)
@


1.23
log
@Added dynamic and coerce abstract syntax
@
text
@d4 3
d90 2
a91 1
    structure IdentClass = Datatypes.Ident
d93 6
a98 1
    structure Set = Set
d100 1
a100 1
  datatype 'a opt = PRESENT of 'a | ABSENT
d103 3
a105 3
    SCONexp of IdentClass.SCon | 
    VALexp of (IdentClass.LongValId * Datatypes.Type ref * Location.T) |
    RECORDexp of (IdentClass.Lab * Exp) list|
d124 2
a125 2
     IdentClass.TyVar Set.Set|
     TYPEdec of (IdentClass.TyVar list * IdentClass.TyCon * Ty) list |
d127 1
a127 1
                    (IdentClass.TyVar list * IdentClass.TyCon *
d129 1
a129 1
		     ((IdentClass.ValId * Datatypes.Type ref) *
d132 1
a132 1
                   (IdentClass.TyVar list * IdentClass.TyCon *
d134 1
a134 1
		    ((IdentClass.ValId * Datatypes.Type ref) *
d138 1
a138 1
     OPENdec of IdentClass.LongStrId list * Location.T |
d142 3
a144 3
    NEWexbind of ((IdentClass.ValId * Datatypes.Type ref) * Ty opt * Location.T * string) |
    OLDexbind of ((IdentClass.ValId * Datatypes.Type ref) *
		  IdentClass.LongValId * Location.T * string)
d148 4
a151 4
    SCONpat of IdentClass.SCon |
    VALpat of (IdentClass.LongValId * Datatypes.Type ref) * Location.T |
    RECORDpat of (IdentClass.Lab * Pat) list * bool * Datatypes.Type ref |
    APPpat of (IdentClass.LongValId * Datatypes.Type ref) * Pat * Location.T |
d153 1
a153 1
    LAYEREDpat of (IdentClass.ValId * Datatypes.Type ref) * Pat
d156 3
a158 3
    TYVARty of IdentClass.TyVar |
    RECORDty of (IdentClass.Lab * Ty) list |
    APPty of Ty list * IdentClass.LongTyCon * Location.T |
d165 2
a166 2
    OLDstrexp of IdentClass.LongStrId * Location.T |
    APPstrexp of IdentClass.FunId * StrExp * Location.T |
d171 1
a171 1
    STRUCTUREstrdec of (IdentClass.StrId * SigExp opt * StrExp * Location.T) list |
d176 2
a177 2
    NEWsigexp of Spec * Datatypes.Str opt ref | 
    OLDsigexp of IdentClass.SigId * Datatypes.Str opt ref * Location.T
d180 7
a186 7
    VALspec of (IdentClass.ValId * Ty * IdentClass.TyVar Set.Set) list |
    TYPEspec of (IdentClass.TyVar list * IdentClass.TyCon) list |
    EQTYPEspec of (IdentClass.TyVar list * IdentClass.TyCon) list |
    DATATYPEspec of (IdentClass.TyVar list * IdentClass.TyCon *
		     (IdentClass.ValId * Ty opt) list) list |
    EXCEPTIONspec of (IdentClass.ValId * Ty opt * Location.T) list |
    STRUCTUREspec of (IdentClass.StrId * SigExp) list |
d189 2
a190 2
    OPENspec of IdentClass.LongStrId list * Location.T |
    INCLUDEspec of IdentClass.SigId list * Location.T |
d194 2
a195 2
    STRUCTUREshareq of IdentClass.LongStrId list |
    TYPEshareq of IdentClass.LongTyCon list
d197 1
a197 1
  datatype SigBind = SIGBIND of (IdentClass.SigId * SigExp * Location.T) list
d200 1
a200 2
    FUNBIND of (IdentClass.FunId * IdentClass.StrId * SigExp *
(*		Nameset.Nameset ref * *)
@


1.22
log
@Removed nameset structure and ref nameset from FunBind (which wasn't used)
@
text
@d4 3
d102 5
a106 1
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string * Location.T
@


1.21
log
@Rationalised functor parameter
@
text
@d4 3
d70 1
a70 1
require "../typechecker/nameset";
d73 1
a76 1
  structure Nameset : NAMESET
d78 1
d83 1
a83 2
    structure Nameset = Nameset
    structure Datatypes = Nameset.Datatypes
d185 1
a185 1
		Nameset.Nameset ref *
@


1.20
log
@> Changed int and real scons to carry a location around
@
text
@d4 3
a66 1
require "absyn";
d68 1
a68 1
require "../typechecker/interface";
d70 1
a70 1
require "../utils/integer";
a73 1
  structure Interface : INTERFACE
a78 1
    structure Datatypes = Interface.Datatypes
d80 1
a80 1
    structure Interface = Interface
d157 2
a158 2
    NEWsigexp of Spec * Interface.Int ref | 
    OLDsigexp of IdentClass.SigId * Interface.Int ref * Location.T
d195 1
@


1.19
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
a64 1
require "location";
a74 1
  structure Location : LOCATION
d82 1
a83 1
    structure Location = Location
@


1.18
log
@Added location information to the `require' topdec.
@
text
@d4 3
a73 3
(*
  sharing Interface.Datatypes.Ident = Interface.Ident
*)
d75 1
a75 1
struct
d77 6
a82 6
  structure Datatypes = Interface.Datatypes
  structure Nameset = Nameset
  structure Interface = Interface
  structure IdentClass = Datatypes.Ident
  structure Set = Set
  structure Location = Location
@


1.17
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d188 1
a188 1
    REQUIREtopdec of string
@


1.16
log
@Added locations to some datatypes.
@
text
@d4 3
d103 3
a105 2
     DATATYPEdec of (IdentClass.TyVar list * IdentClass.TyCon *
		     Datatypes.Type ref *
d108 3
a110 2
     ABSTYPEdec of (IdentClass.TyVar list * IdentClass.TyCon *
		    Datatypes.Type ref *
@


1.15
log
@Installed central error reporting mechanism.
@
text
@d4 3
d121 1
a121 1
    VALpat of (IdentClass.LongValId * Datatypes.Type ref) |
d123 2
a124 2
    APPpat of (IdentClass.LongValId * Datatypes.Type ref) * Pat |
    TYPEDpat of Pat * Ty |
d130 1
a130 1
    APPty of Ty list * IdentClass.LongTyCon |
d137 1
a137 1
    OLDstrexp of IdentClass.LongStrId |
d149 1
a149 1
    OLDsigexp of IdentClass.SigId * Interface.Int ref
d161 2
a162 2
    OPENspec of IdentClass.LongStrId list |
    INCLUDEspec of IdentClass.SigId list |
d197 1
a197 1
    | has_tyvar (APPty (tylist,_)) = 
@


1.14
log
@Insalled central error reporting mechanism.
@
text
@d4 3
d50 1
a54 1
require "../main/error";
d61 1
a61 1
  structure Error : ERROR
d73 1
a73 1
  structure Error = Error
a76 2
  type location = Error.location

d79 1
a79 1
    VALexp of (IdentClass.LongValId * Datatypes.Type ref * location) |
d82 5
a86 5
    APPexp of Exp * Exp * location * Datatypes.Type ref |
    TYPEDexp of Exp * Ty * location |
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp) list * location * string |
    RAISEexp of Exp * location |
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string * location
d94 1
a94 1
     VALdec of (Pat * Exp * location) list *  (Pat * Exp * location) list *
d107 1
a107 1
     OPENdec of IdentClass.LongStrId list * location |
d111 1
a111 1
    NEWexbind of ((IdentClass.ValId * Datatypes.Type ref) * Ty opt * location * string) |
d113 1
a113 1
		  IdentClass.LongValId * location * string)
d135 1
a135 1
    APPstrexp of IdentClass.FunId * StrExp * location |
d140 1
a140 1
    STRUCTUREstrdec of (IdentClass.StrId * SigExp opt * StrExp * location) list |
d154 1
a154 1
    EXCEPTIONspec of (IdentClass.ValId * Ty opt * location) list |
d156 1
a156 1
    SHARINGspec of (SharEq * location) list |
d166 1
a166 1
  datatype SigBind = SIGBIND of (IdentClass.SigId * SigExp * location) list
d171 1
a171 1
		StrExp * SigExp opt * string * location) list 
d174 1
a174 1
    STRDECtopdec of StrDec * location |
d176 1
a176 1
    FUNCTORtopdec of FunBind list * location |
@


1.13
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d51 1
d58 1
d70 1
d74 1
a74 5
  type Source_marks = int * int
  fun Source_marks_to_string (x,y) = "Line " ^ Integer.makestring x ^ ",position " ^ Integer.makestring y ^ " "
  fun tuple_to_Source_marks x = x
  fun Source_marks_to_tuple x = x
  val dummy_marks = (0,0)
d78 1
a78 1
    VALexp of (IdentClass.LongValId * Datatypes.Type ref * Source_marks) |
d81 5
a85 5
    APPexp of Exp * Exp * Source_marks * Datatypes.Type ref |
    TYPEDexp of Exp * Ty * Source_marks |
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp) list * Source_marks * string |
    RAISEexp of Exp * Source_marks |
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string * Source_marks
d93 1
a93 1
     VALdec of (Pat * Exp * Source_marks) list *  (Pat * Exp * Source_marks) list *
d106 1
a106 1
     OPENdec of IdentClass.LongStrId list * Source_marks |
d110 1
a110 1
    NEWexbind of ((IdentClass.ValId * Datatypes.Type ref) * Ty opt * Source_marks * string) |
d112 1
a112 1
		  IdentClass.LongValId * Source_marks * string)
d134 1
a134 1
    APPstrexp of IdentClass.FunId * StrExp * Source_marks |
d139 1
a139 1
    STRUCTUREstrdec of (IdentClass.StrId * SigExp opt * StrExp * Source_marks) list |
d153 1
a153 1
    EXCEPTIONspec of (IdentClass.ValId * Ty opt * Source_marks) list |
d155 1
a155 1
    SHARINGspec of (SharEq * Source_marks) list |
d165 1
a165 1
  datatype SigBind = SIGBIND of (IdentClass.SigId * SigExp * Source_marks) list
d170 1
a170 1
		StrExp * SigExp opt * string * Source_marks) list 
d173 1
a173 1
    STRDECtopdec of StrDec * Source_marks |
d175 1
a175 1
    FUNCTORtopdec of FunBind list * Source_marks |
@


1.12
log
@Tidied up functor argument to reducing number of parameters and sharing
@
text
@d4 3
d53 1
d55 1
d62 1
a62 1
  structure IdentClass = Interface.Ident
d70 1
@


1.11
log
@Added a slot to appexp for debugging type information for function call type
@
text
@d4 3
a39 1
require "../typechecker/datatypes";
a41 1
require "ident";
d45 7
a51 7
functor Absyn (structure Datatypes : DATATYPES
	       structure Nameset : NAMESET
	       structure Interface : INTERFACE
               structure Integer : INTEGER
	       structure Ident : IDENTCLASS
	       structure Set : SET
	       sharing Datatypes.Ident = Ident) : ABSYN =
d54 1
a54 1
  structure Datatypes = Datatypes
d57 1
a57 1
  structure IdentClass = Ident
@


1.10
log
@Added debug info to handlers
@
text
@d4 3
d71 1
a71 1
    APPexp of Exp * Exp * Source_marks |
@


1.9
log
@Added some maarks for typechecker error messages
@
text
@d4 3
d97 1
a97 1
    NEWexbind of ((IdentClass.ValId * Datatypes.Type ref) * Ty opt * Source_marks) |
d99 1
a99 1
		  IdentClass.LongValId * Source_marks)
@


1.8
log
@Added marks for better error reporting
@
text
@d4 3
d67 1
a67 1
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp) list * Source_marks |
d69 1
a69 1
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string 
@


1.7
log
@First version of the profiler
@
text
@d4 3
d33 1
d38 1
d52 5
d59 1
a59 1
    VALexp of (IdentClass.LongValId * Datatypes.Type ref) |
d62 5
a66 5
    APPexp of Exp * Exp |
    TYPEDexp of Exp * Ty |
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp) list |
    RAISEexp of Exp  |
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string |
a67 4
    (* this expression type is only used in the ten15 code generator
     the parser will never generate it *)
    TEN15exp of IdentClass.ValId list

d74 1
a74 1
     VALdec of (Pat * Exp) list *  (Pat * Exp) list *
d87 1
a87 1
     OPENdec of IdentClass.LongStrId list |
d91 1
a91 1
    NEWexbind of ((IdentClass.ValId * Datatypes.Type ref) * Ty opt) |
d93 1
a93 1
		  IdentClass.LongValId)
d115 1
a115 1
    APPstrexp of IdentClass.FunId * StrExp |
d120 1
a120 1
    STRUCTUREstrdec of (IdentClass.StrId * SigExp opt * StrExp) list |
d134 1
a134 1
    EXCEPTIONspec of (IdentClass.ValId * Ty opt) list |
d136 1
a136 1
    SHARINGspec of SharEq list |
d146 1
a146 1
  datatype SigBind = SIGBIND of (IdentClass.SigId * SigExp) list
d151 1
a151 1
		StrExp * SigExp opt * string) list 
d154 1
a154 1
    STRDECtopdec of StrDec |
d156 1
a156 1
    FUNCTORtopdec of FunBind list |
@


1.6
log
@Removed opens
@
text
@d3 4
a6 1
$Log:	_absyn.sml,v $
d55 2
a56 2
    RAISEexp of Exp * int list |
    FNexp of (Pat * Exp) list * Datatypes.Type ref * int list |
d145 1
a145 1
		StrExp * SigExp opt) list 
@


1.5
log
@Added copyright message
@
text
@d4 3
d34 1
a34 1
  struct
d36 5
a40 5
    structure Datatypes = Datatypes
    structure Nameset = Nameset
    structure Interface = Interface
    structure IdentClass = Ident
    structure Set = Set
d42 1
a42 1
    open Datatypes
d44 10
a53 3
    local
      open IdentClass
    in
d55 3
a57 1
      datatype 'a opt = PRESENT of 'a | ABSENT
d59 5
a63 14
      datatype Exp =
        SCONexp of SCon | 
        VALexp of (LongValId * Type ref) |
        RECORDexp of (Lab * Exp) list|
        LOCALexp of Dec * Exp |
        APPexp of Exp * Exp |
        TYPEDexp of Exp * Ty |
        HANDLEexp of Exp * Type ref * (Pat * Exp) list |
        RAISEexp of Exp * int list |
        FNexp of (Pat * Exp) list * Type ref * int list |
	
	(* this expression type is only used in the ten15 code generator
	   the parser will never generate it *)
	TEN15exp of ValId list
d65 15
a79 5
      and Dec = 
         (* the two lists in VALdec list the bindings before and after
          the first occurence of rec. tyvarset is used to hold
          information about tyvars scoped at this particular value
          declaration (see 4.6 in The Definition *)
d81 4
d86 8
a93 10
         VALdec of (Pat * Exp) list *  (Pat * Exp) list * TyVar Set.Set|
         TYPEdec of (TyVar list * TyCon * Ty) list |
         DATATYPEdec of (TyVar list * TyCon * Type ref *
			 ((ValId * Type ref) * Ty opt) list) list |
         ABSTYPEdec of (TyVar list * TyCon * Type ref *
			((ValId * Type ref) * Ty opt) list) list * Dec |
         EXCEPTIONdec of ExBind list|
         LOCALdec of Dec * Dec |
         OPENdec of LongStrId list |
         SEQUENCEdec of Dec list
d95 5
a99 3
      and ExBind = 
        NEWexbind of ((ValId * Type ref) * Ty opt) |
        OLDexbind of ((ValId * Type ref) * LongValId)
d101 1
a101 8
      and Pat =
        WILDpat |
        SCONpat of SCon |
        VALpat of (LongValId * Type ref) |
        RECORDpat of (Lab * Pat) list * bool * Type ref |
        APPpat of (LongValId * Type ref) * Pat |
        TYPEDpat of Pat * Ty |
        LAYEREDpat of (ValId * Type ref) * Pat
d103 5
a107 5
      and Ty =
        TYVARty of TyVar |
        RECORDty of (Lab * Ty) list |
        APPty of Ty list * LongTyCon |
        FNty of Ty * Ty
d109 5
a113 1
      (* The following datatypes are for the modules syntax classes *)
d115 3
a117 5
      datatype StrExp =
        NEWstrexp of StrDec |
        OLDstrexp of LongStrId |
        APPstrexp of FunId * StrExp |
        LOCALstrexp of StrDec * StrExp
d119 13
a131 5
      and StrDec =
        DECstrdec of Dec |
        STRUCTUREstrdec of (StrId * SigExp opt * StrExp) list |
        LOCALstrdec of StrDec * StrDec |
        SEQUENCEstrdec of StrDec list
d133 3
a135 3
      and SigExp =
        NEWsigexp of Spec * Interface.Int ref | 
        OLDsigexp of SigId * Interface.Int ref
d137 1
a137 18
      and Spec =
        VALspec of (ValId * Ty * TyVar Set.Set) list|
        TYPEspec of (TyVar list * TyCon) list|
        EQTYPEspec of (TyVar list * TyCon) list|
        DATATYPEspec of (TyVar list * TyCon * (ValId * Ty opt) list) list|
        EXCEPTIONspec of (ValId * Ty opt) list|
        STRUCTUREspec of (StrId * SigExp) list|
        SHARINGspec of SharEq list|
        LOCALspec of Spec * Spec|
        OPENspec of LongStrId list|
        INCLUDEspec of SigId list |
	SEQUENCEspec of Spec list

      and SharEq =
        STRUCTUREshareq of LongStrId list|
        TYPEshareq of LongTyCon list

      datatype SigBind = SIGBIND of (SigId * SigExp) list
d139 4
a142 3
      datatype FunBind = 
        FUNBIND of (FunId * StrId * SigExp * Nameset.Nameset ref *
		    StrExp * SigExp opt) list 
d144 5
a148 5
      datatype TopDec =
        STRDECtopdec of StrDec |
        SIGNATUREtopdec of SigBind list |
        FUNCTORtopdec of FunBind list |
	REQUIREtopdec of string
d150 1
a150 1
      val empty_tyvarset = Set.empty_set
d152 3
a154 3
      fun expansivep (VALexp _) = false
	| expansivep (FNexp _) = false
	| expansivep _ = true
d156 18
a173 19
      fun has_tyvar (TYVARty _) = true
	| has_tyvar (RECORDty lab_tylist) = 
	  let 
	    fun collect ([]) = false
	      | collect ((_,ty)::lab_tylist) = 
		has_tyvar (ty) orelse collect (lab_tylist)
	  in
	    collect (lab_tylist)
	  end
	| has_tyvar (APPty (tylist,_)) = 
	  let
	    fun collect ([]) = false
	      | collect (ty::tylist) = 	has_tyvar (ty) orelse collect (tylist)
	  in
	    collect (tylist)
	  end
	| has_tyvar (FNty (ty,ty')) = has_tyvar (ty) orelse has_tyvar (ty')
    end
  end
@


1.4
log
@added Interface annotation for signature expressions
@
text
@d1 1
d4 3
d16 1
@


1.3
log
@Added REQUIREtopdec of string.
@
text
@d3 3
d16 1
d22 1
d30 1
d109 2
a110 2
        NEWsigexp of Spec|
        OLDsigexp of SigId
@


1.2
log
@Added a type ref to HANDLEexp for ten15 code generator
@
text
@d3 3
d132 2
a133 1
        FUNCTORtopdec of FunBind list
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d40 1
a40 1
        HANDLEexp of Exp * (Pat * Exp) list |
@
