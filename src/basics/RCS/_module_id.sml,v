head	1.33;
access;
symbols
	MLW_daveb_inline_1_4_99:1.33.1
	MLWorks_21c0_1999_03_25:1.33
	MLWorks_20c1_1998_08_20:1.32
	MLWorks_20c0_1998_08_04:1.32
	MLWorks_20b2c2_1998_06_19:1.32
	MLWorks_20b2_Windows_1998_06_12:1.32
	MLWorks_20b1c1_1998_05_07:1.32
	MLWorks_20b0_1998_04_07:1.32
	MLWorks_20b0_1998_03_20:1.31
	MLWorks_20m2_1998_02_16:1.31
	MLWorks_20m1_1997_10_23:1.30
	MLWorks_11r1:1.29.5.1.1.1.1
	MLWorks_workspace_97:1.29.7
	MLWorks_dt_wizard:1.29.6
	MLWorks_11c0_1997_09_09:1.29.5.1.1.1
	MLWorks_10r3:1.29.5.1.3
	MLWorks_10r2_551:1.29.5.1.2
	MLWorks_11:1.29.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.29.5.1
	MLWorks_20m0_1997_06_20:1.29
	MLWorks_1_0_r2c2_1997_06_14:1.29.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.29.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.29.5
	MLWorks_BugFix_1997_04_24:1.29
	MLWorks_1_0_r2_Win32_1997_04_11:1.29
	MLWorks_1_0_r2_Unix_1997_04_04:1.29
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.29.3.1.1
	MLWorks_gui_1996_12_18:1.29.4
	MLWorks_1_0_Win32_1996_12_17:1.29.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.29.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.29.1.1
	MLWorks_1_0_Irix_1996_11_28:1.29.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.29.2
	MLWorks_1_0_Unix_1996_11_14:1.29.1
	MLWorks_Open_Beta2_1996_10_11:1.28.3
	MLWorks_License_dev:1.28.2
	MLWorks_1_open_beta_1996_09_13:1.28.1
	MLWorks_Open_Beta_1996_08_22:1.28
	MLWorks_Beta_1996_07_02:1.28
	MLWorks_Beta_1996_06_07:1.28
	MLWorks_Beta_1996_06_06:1.28
	MLWorks_Beta_1996_06_05:1.28
	MLWorks_Beta_1996_06_03:1.28
	MLWorks_Beta_1996_05_31:1.28
	MLWorks_Beta_1996_05_30:1.28
	ML_beta_release_12/08/94:1.11
	ML_beta_release_03/08/94:1.11
	ML_revised_beta_release_25/05/94:1.10
	ML_final_beta_release_02/03/94:1.9
	mlworks-28-01-1994:1.8
	Release:1.4
	mlworks-beta-01-09-1993:1.4;
locks; strict;
comment	@ * @;


1.33
date	99.02.03.15.20.27;	author mitchell;	state Exp;
branches
	1.33.1.1;
next	1.32;

1.32
date	98.03.31.13.13.04;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	98.01.28.10.33.40;	author johnh;	state Exp;
branches;
next	1.30;

1.30
date	97.09.18.14.33.19;	author brucem;	state Exp;
branches;
next	1.29;

1.29
date	96.10.29.17.45.08;	author io;	state Exp;
branches
	1.29.1.1
	1.29.2.1
	1.29.3.1
	1.29.4.1
	1.29.5.1
	1.29.6.1
	1.29.7.1;
next	1.28;

1.28
date	96.05.21.11.13.05;	author stephenb;	state Exp;
branches
	1.28.1.1
	1.28.2.1
	1.28.3.1;
next	1.27;

1.27
date	96.04.30.14.33.31;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	96.04.18.15.17.06;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	96.04.11.15.10.24;	author stephenb;	state Exp;
branches;
next	1.24;

1.24
date	96.03.26.15.06.14;	author stephenb;	state Exp;
branches;
next	1.23;

1.23
date	96.03.15.12.35.20;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	95.12.06.18.00.17;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	95.12.05.10.02.55;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	95.12.04.15.24.26;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	95.09.06.15.36.24;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	95.04.28.15.51.49;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	95.04.20.18.53.36;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	95.04.19.11.41.35;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	95.02.28.15.55.27;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	95.01.25.14.36.52;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	95.01.18.13.29.39;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	94.10.06.10.29.01;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	94.06.02.15.50.06;	author brianm;	state Exp;
branches;
next	1.10;

1.10
date	94.03.22.14.52.01;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	94.02.02.12.08.49;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	93.12.22.17.13.59;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	93.11.09.11.33.09;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	93.09.10.17.43.42;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	93.09.02.14.24.33;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	93.08.27.13.47.55;	author daveb;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	93.08.26.13.03.36;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	93.08.24.17.07.11;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	93.08.17.17.24.45;	author daveb;	state Exp;
branches;
next	;

1.4.1.1
date	93.08.27.13.47.55;	author jont;	state Exp;
branches;
next	1.4.1.2;

1.4.1.2
date	93.09.02.13.25.22;	author jont;	state Exp;
branches;
next	1.4.1.3;

1.4.1.3
date	93.09.10.15.09.47;	author jont;	state Exp;
branches;
next	1.4.1.4;

1.4.1.4
date	93.10.22.15.44.22;	author daveb;	state Exp;
branches;
next	;

1.28.1.1
date	96.09.13.11.08.40;	author hope;	state Exp;
branches;
next	;

1.28.2.1
date	96.10.07.15.59.39;	author hope;	state Exp;
branches;
next	;

1.28.3.1
date	96.10.17.11.18.00;	author hope;	state Exp;
branches;
next	;

1.29.1.1
date	96.11.14.12.41.32;	author hope;	state Exp;
branches
	1.29.1.1.1.1;
next	;

1.29.1.1.1.1
date	96.11.28.14.53.26;	author hope;	state Exp;
branches;
next	;

1.29.2.1
date	96.11.22.18.01.59;	author hope;	state Exp;
branches;
next	;

1.29.3.1
date	96.12.17.17.40.55;	author hope;	state Exp;
branches
	1.29.3.1.1.1;
next	;

1.29.3.1.1.1
date	97.02.24.11.28.46;	author hope;	state Exp;
branches;
next	;

1.29.4.1
date	96.12.18.09.34.50;	author hope;	state Exp;
branches;
next	;

1.29.5.1
date	97.05.12.10.26.52;	author hope;	state Exp;
branches
	1.29.5.1.1.1
	1.29.5.1.2.1
	1.29.5.1.3.1;
next	;

1.29.5.1.1.1
date	97.07.28.18.12.53;	author daveb;	state Exp;
branches
	1.29.5.1.1.1.1.1;
next	;

1.29.5.1.1.1.1.1
date	97.10.07.11.37.54;	author jkbrook;	state Exp;
branches;
next	;

1.29.5.1.2.1
date	97.09.08.17.06.09;	author daveb;	state Exp;
branches;
next	;

1.29.5.1.3.1
date	97.09.09.14.01.36;	author daveb;	state Exp;
branches;
next	;

1.29.6.1
date	97.09.10.19.16.00;	author brucem;	state Exp;
branches;
next	;

1.29.7.1
date	97.09.11.20.45.48;	author daveb;	state Exp;
branches;
next	1.29.7.2;

1.29.7.2
date	97.09.17.15.19.15;	author daveb;	state Exp;
branches;
next	;

1.33.1.1
date	99.04.01.17.51.32;	author daveb;	state Exp;
branches;
next	;


desc
@Module identifiers - the functor
@


1.33
log
@[Bug #50108]
Change ModuleId from an equality type
@
text
@(* Module identifiers - for OS-independent recompilation.
 
$Log: _module_id.sml,v $
 * Revision 1.32  1998/03/31  13:13:04  jont
 * [Bug #70077]
 * Remove use of Path, and replace with OS.Path
 *
 * Revision 1.31  1998/01/28  10:33:40  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.30  1997/09/18  14:33:19  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.29.7.2  1997/09/17  15:19:15  daveb
 * [Bug #30071]
 * Replaced build system with project workspace.
 *
 * Revision 1.29.7.1  1997/09/11  20:45:48  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.29  1996/10/29  17:45:08  io
 * moving String from toplevel
 *
 * Revision 1.28  1996/05/21  11:13:05  stephenb
 * Change to pull in Path directly rather than OS.Path since the latter
 * now conforms to the latest basis and it is too much effort to update
 * the code to OS.Path at this point.
 *
 * Revision 1.27  1996/04/30  14:33:31  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.26  1996/04/18  15:17:06  jont
 * initbasis moves to basis
 *
 * Revision 1.25  1996/04/11  15:10:24  stephenb
 * Update wrt Os -> OS name change.
 *
 * Revision 1.24  1996/03/26  15:06:14  stephenb
 * Replace the use of Path by Os.Path.
 *
 * Revision 1.23  1996/03/15  12:35:20  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.22  1995/12/06  18:00:17  daveb
 * Added the is_pervasive predicate.
 *
Revision 1.21  1995/12/05  10:02:55  daveb
Corrected previous log message.

Revision 1.20  1995/12/04  15:24:26  daveb
Added perv_from_string, perv_from_require_string and from_mo_string.
Changed error message in squash_path.

Revision 1.19  1995/09/06  15:36:24  jont
Provide non-faulting form of from_string

Revision 1.18  1995/04/28  15:51:49  jont
Modifications to from_require_string

Revision 1.17  1995/04/20  18:53:36  daveb
filesys and path moved from utils to initbasis.

Revision 1.16  1995/04/19  11:41:35  jont
Add functionality to support object paths

Revision 1.15  1995/02/28  15:55:27  daveb
New path syntax.

Revision 1.14  1995/01/25  14:36:52  daveb
Replaced FileName parameter with Path.
Added to_host function so that _module can be OS-independent.

Revision 1.13  1995/01/18  13:29:39  jont
Parameterise on pathname separator

Revision 1.12  1994/10/06  10:29:01  matthew
Added eq fun for module_ids

Revision 1.11  1994/06/02  15:50:06  brianm
Adding hyphen to module names and made invalid module name errors fatal

Revision 1.10  1994/03/22  14:52:01  daveb
Adding .mo to extensions that from_string knows about.

Revision 1.9  1994/02/02  12:08:49  daveb
changed from_unix_string (OS-specific) to from_require_string.

Revision 1.8  1993/12/22  17:13:59  daveb
from_string now checks for trailing ".sml".

Revision 1.7  1993/11/09  11:33:09  daveb
Merged in bug fix.

Revision 1.6  1993/09/10  17:43:42  jont
Merging in bug fixes

Revision 1.4.1.4  1993/10/22  15:44:22  daveb
Removed create function, as require can no longer take module ids.
Changed from_string to recognise either / or . as separators.

Revision 1.5  1993/09/02  14:24:33  jont
Merging in bug fixes

Revision 1.4.1.3  1993/09/10  15:09:47  jont
Changed the order of the terms in a moduleid. This will be a compiler
efficiency issue. Fixed lt to be a proper ordering function

Revision 1.5  1993/09/02  14:24:33  jont
Merging in bug fixes

Revision 1.4.1.2  1993/09/02  13:25:22  jont
Improvements to use String.ordof rather than String.substring

Revision 1.4.1.1  1993/08/27  13:47:55  jont
Fork for bug fixing

Revision 1.4  1993/08/27  13:47:55  daveb
Added a comparison function.

Revision 1.3  1993/08/26  13:03:36  daveb
from_string and from_unix_string return a more informative symbol on error.

Revision 1.2  1993/08/24  17:07:11  daveb
Fixed bug in from_string.
 Added create function that checks that moduleids are alphanumeric.
Checked legality of moduleids in old-fashioned require declarations.

Revision 1.1  1993/08/17  17:24:45  daveb
Initial revision


Copyright (c) 1993 Harlequin Ltd

*)

require "symbol";
require "^.main.info";
require "^.basis.os_path";
require "$.basis.__string";
require "module_id";

functor ModuleId
  (structure Symbol: SYMBOL
   structure Info: INFO
   structure Path: OS_PATH
  ): MODULE_ID =
struct
  type Symbol = Symbol.Symbol
  type Location = Info.Location.T
  structure Location = Info.Location

  (* Path components are stored in reverse order *)
  datatype ModuleId = MODID of Symbol * Symbol list
  datatype Path = PATH of Symbol list

  fun insert ([], _) = []
  |   insert ([x], _) = [x]
  |   insert (x::l, c) = x :: c :: insert (l, c)

  fun string (MODID (s, l)) =
    concat (insert (map Symbol.symbol_name (rev (s :: l)), "."))

  fun lt' ((s, l), (s', l')) =
    if Symbol.symbol_lt (s, s') then true
    else
      if Symbol.symbol_lt (s', s) then false
      else
	(* The tricky case, where we compare the path *)
	(* Shorter paths will be less than longer paths *)
	case l of
	  [] => l' <> [] (* lt provided second path not nil *)
	| (h :: t) =>
	    case l' of
	      [] => false (* ~lt if second path nil and first not *)
	    | (h' :: t') => lt'((h, t), (h', t'))

  (* Pervasive module names begin with a space. *)

  fun isPervasiveName s =
    String.sub(s, 0) = #" "

  fun is_pervasive (MODID (s, _)) =
    isPervasiveName (Symbol.symbol_name s)

  fun module_unit_to_string(MODID(s, l), ext) =
    (* Produce a file system string for the final part of the module name *)
    let
      val path_ext = if ext = "" then NONE else SOME ext
      val name = Symbol.symbol_name s
      val name' =
	(* Remove any leading space; this is there to hide the module_id
	   from the user's name space. *)
	if isPervasiveName name then
	  substring (* could raise Substring *) (name, 1, size name - 1)
	else
	  name
    in
      Path.joinBaseExt {base = name', ext = path_ext}
    end

  fun lt (MODID a, MODID b) = lt'(a, b)

  fun eq (m:ModuleId, m') = m = m'

  fun int_is_alpha c =
    (c >= ord #"A" andalso c <= ord #"Z") orelse
    (c >= ord #"a" andalso c <= ord #"z") orelse
    (c = ord #"_") orelse (c = ord #"-")
    (* underscores allowed here to cope with our file naming scheme *)
  
  fun legal c =
    (c >= ord #"0" andalso c <= ord #"9") orelse
    int_is_alpha c orelse c = ord #"'"
    
  fun path (MODID (_, l)) = PATH l

  fun path_string (PATH l) =
    concat (insert (map Symbol.symbol_name (rev l), "."))

  val empty_path = PATH []

  fun squash_path(name, [], acc) = rev acc
    | squash_path(name, x :: xs, acc) =
      case Symbol.symbol_name x of
	"^" =>
	  (case xs of
	     [] =>
	       (Info.default_error'
		(Info.FATAL, Location.UNKNOWN,
		 "can't find parent for module name: " ^ string name))
	   | y :: ys =>
	       (* We start with the final component, and work backwards *)
	       (* Therefore ^ refers to the next one in the input *)
	       squash_path(name, ys, acc))
      | "$" => rev acc
      | _ => squash_path(name, xs, x :: acc)

  (* XXX As a temporary measure, ignore the path here.  We should ignore
         it everywhere.  *)
  fun add_path (PATH l, MODID (s, l')) = MODID (s, [])
    (*
    MODID (s, squash_path(MODID(s, l' @@ l), l' @@ l, []))
    *)

  exception NoParent

  fun parent (PATH (_::l)) = PATH l
  |   parent _ = raise NoParent


  exception Parse of string

  fun internal_from_string (s, init_offset, ord_sep, allow_space) =
    let
      val len = size s
      val s' =
        if len - init_offset >= 3 andalso
           substring (* could raise Substring *) (s, len - 3, 3) = ".mo" then
          substring (* could raise Substring *) (s, 0, len - 3)
        else if len - init_offset >= 4 andalso
           substring (* could raise Substring *) (s, len - 4, 4) = ".sml" then
          substring (* could raise Substring *) (s, 0, len - 4)
        else
          s
      val len = size s'

      fun find_separator' i =
        if i = len then i
        else
          let
            val ch = MLWorks.String.ordof (s', i)
          in
            if ch = ord_sep then
	      i
            else
	      if legal ch then
		find_separator' (i+1)
	      else
		raise Parse s
          end
          
      fun find_separator i =
        if i = len orelse
	  let
	    val c = MLWorks.String.ordof(s', i)
	  in
	    int_is_alpha c orelse
	    (allow_space andalso c = ord #" ") orelse
	    ((c = ord #"^" orelse c = ord #"$")
	     andalso i+1 < len andalso MLWorks.String.ordof(s', i+1) = ord_sep)
	  end then
          find_separator' (i+1)
        else
          raise Parse s

      fun from i =
        if i = len then raise Parse s
        else
          let
            val split = find_separator i
            val substr =
              substring (* could raise Substring *) (s', i, split - i)
            val symbol =
              Symbol.find_symbol(Path.mkCanonical substr)
          in
            if split = len then
              ([], symbol)
            else
              let val (path, child) = from (split + 1)
              in (symbol :: path, child)
              end
          end
      val (l, s'') = from init_offset
    in
      MODID (s'', rev l)
    end

  fun from_string (s, location) =
    internal_from_string (s, 0, ord #".", false)
    handle Parse s =>
      (Info.default_error'
	 (Info.FATAL, location,
	  "from_string: invalid module name: `" ^ s ^ "'"))

  fun from_mo_string (s, location) =
    internal_from_string (s, 0, ord #".", true)
    handle Parse s =>
      (Info.default_error'
	 (Info.FATAL, location,
	  "from_mo_string: invalid module name: `" ^ s ^ "'"))

  fun perv_from_string (s, location) =
    case from_string (s, location)
    of MODID (s, l) =>
      MODID (Symbol.find_symbol (" " ^ Symbol.symbol_name s), l)

  fun from_host (s, location) =
    let
      val {dir, file} = Path.splitDirFile s

      val {isAbs, vol, arcs} = Path.fromString dir

      val name = Path.base file

      fun validComponent (s, ~1) = true
      |   validComponent (s, i) =
	if legal (MLWorks.String.ordof (s, i)) then
	  validComponent (s, i-1)
	else
	  false
	
      fun mk_symbol s =
	if validComponent (s, size s - 1) then
	  Symbol.find_symbol (Path.mkCanonical s)
	else
	  raise Parse s

      val list = map mk_symbol arcs

      val sym = mk_symbol name
    in
      MODID (sym, rev list)
    end
    handle Parse s =>
      (Info.default_error'
	 (Info.FATAL, location,
	  "from_host: invalid module name: `" ^ s ^ "'"))

  fun find_a_slash(s, i, size) =
    (i < size) andalso
    (MLWorks.String.ordof(s, i) = ord #"/" orelse find_a_slash(s, i+1, size))

  fun prefix_hats(0, list) = concat list
    | prefix_hats(n, list) =
      prefix_hats(n-1, "^/" :: list)

  val prefix_hats =
    fn ((n, hats, location)) =>
    if n < 0 then
      Info.default_error'
        (Info.FAULT, location, "negative hats value")
    else
      prefix_hats(n, hats)

  fun from_require_string (s, location) =
    let
      val len = size s

      fun from(i, hats) =
        (if len - i >= 3 andalso substring (* could raise Substring *) (s, i, 3) = "../" then
	   from (i + 3, hats+1)
         else
	   if hats >= 1 orelse find_a_slash(s, 0, size s) then
	     internal_from_string
	       (prefix_hats
		  (hats, [substring (* could raise Substring *)(s, i, size s - 3*hats)], location),
	        0, ord #"/", false)
	   else
	     internal_from_string(s, 0, ord #".", false))
        handle Parse s =>
          (Info.default_error'
	     (Info.FATAL, location,
	     "from_require_string: invalid module name: `" ^ s ^ "'"))
    in
      from(0, 0)
    end

  (* Pervasive units are all single names, without separators or parent
     notation, so we don't need the complexity of from_require_string. *)
  fun perv_from_require_string (s, location) =
    from_mo_string (s, location)

  fun from_string' s =
    SOME (internal_from_string (s, 0, ord #".", true))
    handle Parse s =>
      NONE
    
end;
@


1.33.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.33  1999/02/03  15:20:27  mitchell
 * [Bug #50108]
 * Change ModuleId from an equality type
 *
@


1.32
log
@[Bug #70077]
Remove use of Path, and replace with OS.Path
@
text
@d4 4
d306 2
d309 1
a309 1
              Symbol.find_symbol (substring (* could raise Substring *) (s', i, split - i))
d359 1
a359 1
	  Symbol.find_symbol s
@


1.31
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d139 1
a139 1
require "^.basis.path";
d146 1
a146 1
   structure Path: PATH
a185 26
  fun to_host (MODID (s, l), ext) =
    let
      val arcs = map Symbol.symbol_name (rev l)
      val dir = Path.implodePath {root = Path.REL, arcs = arcs}
      val path_ext = if ext = "" then Path.NOEXT else Path.EXT ext
      val name = Symbol.symbol_name s
      val name' =
	(* Remove any leading space; this is there to hide the module_id
	   from the user's name space. *)
	if isPervasiveName name then
	  substring (* could raise Substring *) (name, 1, size name -1)
	else
	  name
      val last = Path.addExt {name = name', ext = path_ext}
    in
      Path.addLast {dir = dir, last = last}
    end

  fun module_component_to_string(MODID(s, l)) =
    (* Produce a file system string for the prefix part of the module name *)
    let
      val arcs = map Symbol.symbol_name (rev l)
    in
      Path.implodePath {root = Path.REL, arcs = arcs}
    end

d189 1
a189 1
      val path_ext = if ext = "" then Path.NOEXT else Path.EXT ext
d199 1
a199 1
      Path.addExt {name = name', ext = path_ext}
d338 1
a338 1
      val {dir, last} = Path.splitLast s
d340 1
a340 1
      val {root, arcs} = Path.explodePath dir
d342 1
a342 1
      val name = Path.name last
@


1.30
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 11
d261 4
a264 1
  fun add_path (PATH l, MODID (s, l')) =
d266 1
@


1.29
log
@moving String from toplevel
@
text
@d4 3
d125 1
a126 1
require "^.basis.__old";
d164 4
d169 1
a169 1
    Old.ord (Symbol.symbol_name s) = ord #" "
d180 1
a180 1
	if Old.ord name = ord #" " then
d205 1
a205 1
	if Old.ord name = ord #" " then
@


1.29.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.29  1996/10/29  17:45:08  io
 * moving String from toplevel
 *
@


1.29.7.2
log
@[Bug #30071]
Replaced build system with project workspace.
@
text
@a3 3
 * Revision 1.29.7.1  1997/09/11  20:45:48  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d246 1
a246 4
  (* XXX As a temporary measure, ignore the path here.  We should ignore
         it everywhere.  *)
  fun add_path (PATH l, MODID (s, l')) = MODID (s, [])
    (*
a247 1
    *)
@


1.29.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.29  1996/10/29  17:45:08  io
 * moving String from toplevel
 *
@


1.29.5.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/10/29  17:45:08  io
 * moving String from toplevel
 *
@


1.29.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.29.5.1  1997/05/12  10:26:52  hope
 * branched from 1.29
 *
@


1.29.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.29.5.1  1997/05/12  10:26:52  hope
 * branched from 1.29
 *
@


1.29.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.29.5.1  1997/05/12  10:26:52  hope
 * branched from 1.29
 *
@


1.29.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.29.5.1.1.1  1997/07/28  18:12:53  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.29.4.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/10/29  17:45:08  io
 * moving String from toplevel
 *
@


1.29.3.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/10/29  17:45:08  io
 * moving String from toplevel
 *
@


1.29.3.1.1.1
log
@branched from 1.29.3.1
@
text
@a3 3
 * Revision 1.29.3.1  1996/12/17  17:40:55  hope
 * branched from 1.29
 *
@


1.29.2.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/10/29  17:45:08  io
 * moving String from toplevel
 *
@


1.29.1.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/10/29  17:45:08  io
 * moving String from toplevel
 *
@


1.29.1.1.1.1
log
@branched from 1.29.1.1
@
text
@a3 3
 * Revision 1.29.1.1  1996/11/14  12:41:32  hope
 * branched from 1.29
 *
@


1.28
log
@Change to pull in Path directly rather than OS.Path since the latter
now conforms to the latest basis and it is too much effort to update
the code to OS.Path at this point.
@
text
@d4 5
d120 2
a121 2
require "../main/info";
require "../basis/path";
d123 1
d144 1
a144 1
    String.implode (insert (map Symbol.symbol_name (rev (s :: l)), "."))
d162 1
a162 1
    String.ord (Symbol.symbol_name s) = String.ord " "
d173 2
a174 2
	if String.ord name = String.ord " " then
	  String.substring (name, 1, size name -1)
d198 2
a199 2
	if String.ord name = String.ord " " then
	  String.substring (name, 1, size name - 1)
d211 3
a213 3
    (c >= String.ord "A" andalso c <= String.ord "Z") orelse
    (c >= String.ord "a" andalso c <= String.ord "z") orelse
    (c = String.ord "_") orelse (c = String.ord "-")
d217 2
a218 2
    (c >= String.ord "0" andalso c <= String.ord "9") orelse
    int_is_alpha c orelse c = String.ord"'"
d223 1
a223 1
    String.implode (insert (map Symbol.symbol_name (rev l), "."))
d259 2
a260 2
           String.substring (s, len - 3, 3) = ".mo" then
          String.substring (s, 0, len - 3)
d262 2
a263 2
           String.substring (s, len - 4, 4) = ".sml" then
          String.substring (s, 0, len - 4)
d272 1
a272 1
            val ch = String.ordof (s', i)
d286 1
a286 1
	    val c = String.ordof(s', i)
d289 3
a291 3
	    (allow_space andalso c = String.ord " ") orelse
	    ((c = String.ord "^" orelse c = String.ord "$")
	     andalso i+1 < len andalso String.ordof(s', i+1) = ord_sep)
d303 1
a303 1
              Symbol.find_symbol (String.substring (s', i, split - i))
d318 1
a318 1
    internal_from_string (s, 0, String.ord ".", false)
d325 1
a325 1
    internal_from_string (s, 0, String.ord ".", true)
d346 1
a346 1
	if legal (String.ordof (s, i)) then
d370 1
a370 1
    (String.ordof(s, i) = String.ord"/" orelse find_a_slash(s, i+1, size))
d372 1
a372 1
  fun prefix_hats(0, list) = String.implode list
d389 1
a389 1
        (if len - i >= 3 andalso String.substring (s, i, 3) = "../" then
d395 2
a396 2
		  (hats, [String.substring(s, i, size s - 3*hats)], location),
	        0, String.ord"/", false)
d398 1
a398 1
	     internal_from_string(s, 0, String.ord ".", false))
d413 1
a413 1
    MLWorks.Option.SOME(internal_from_string (s, 0, String.ord ".", true))
d415 1
a415 1
      MLWorks.Option.NONE
@


1.28.3.1
log
@branched from 1.28
@
text
@a3 5
 * Revision 1.28  1996/05/21  11:13:05  stephenb
 * Change to pull in Path directly rather than OS.Path since the latter
 * now conforms to the latest basis and it is too much effort to update
 * the code to OS.Path at this point.
 *
@


1.28.2.1
log
@branched from 1.28
@
text
@a3 5
 * Revision 1.28  1996/05/21  11:13:05  stephenb
 * Change to pull in Path directly rather than OS.Path since the latter
 * now conforms to the latest basis and it is too much effort to update
 * the code to OS.Path at this point.
 *
@


1.28.1.1
log
@branched from 1.28
@
text
@a3 5
 * Revision 1.28  1996/05/21  11:13:05  stephenb
 * Change to pull in Path directly rather than OS.Path since the latter
 * now conforms to the latest basis and it is too much effort to update
 * the code to OS.Path at this point.
 *
@


1.27
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d116 1
a116 1
require "../basis/os";
d122 1
a122 1
   structure OS: OS
d161 2
a162 2
      val dir = OS.Path.implodePath {root = OS.Path.REL, arcs = arcs}
      val path_ext = if ext = "" then OS.Path.NOEXT else OS.Path.EXT ext
d171 1
a171 1
      val last = OS.Path.addExt {name = name', ext = path_ext}
d173 1
a173 1
      OS.Path.addLast {dir = dir, last = last}
d181 1
a181 1
      OS.Path.implodePath {root = OS.Path.REL, arcs = arcs}
d187 1
a187 1
      val path_ext = if ext = "" then OS.Path.NOEXT else OS.Path.EXT ext
d197 1
a197 1
      OS.Path.addExt {name = name', ext = path_ext}
d332 1
a332 1
      val {dir, last} = OS.Path.splitLast s
d334 1
a334 1
      val {root, arcs} = OS.Path.explodePath dir
d336 1
a336 1
      val name = OS.Path.name last
@


1.26
log
@initbasis moves to basis
@
text
@d4 3
d132 1
a132 1
    implode (insert (map Symbol.symbol_name (rev (s :: l)), "."))
d150 1
a150 1
    ord (Symbol.symbol_name s) = ord " "
d161 1
a161 1
	if ord name = ord " " then
d186 1
a186 1
	if ord name = ord " " then
d199 3
a201 3
    (c >= ord "A" andalso c <= ord "Z") orelse
    (c >= ord "a" andalso c <= ord "z") orelse
    (c = ord "_") orelse (c = ord "-")
d205 2
a206 2
    (c >= ord "0" andalso c <= ord "9") orelse
    int_is_alpha c orelse c = ord"'"
d211 1
a211 1
    implode (insert (map Symbol.symbol_name (rev l), "."))
d277 2
a278 2
	    (allow_space andalso c = ord " ") orelse
	    ((c = ord "^" orelse c = ord "$")
d306 1
a306 1
    internal_from_string (s, 0, ord ".", false)
d313 1
a313 1
    internal_from_string (s, 0, ord ".", true)
d358 1
a358 1
    (String.ordof(s, i) = ord"/" orelse find_a_slash(s, i+1, size))
d360 1
a360 1
  fun prefix_hats(0, list) = implode list
d384 1
a384 1
	        0, ord"/", false)
d386 1
a386 1
	     internal_from_string(s, 0, ord ".", false))
d401 1
a401 1
    MLWorks.Option.SOME(internal_from_string (s, 0, ord ".", true))
@


1.25
log
@Update wrt Os -> OS name change.
@
text
@d4 3
d107 1
a107 1
require "../initbasis/os";
@


1.24
log
@Replace the use of Path by Os.Path.
@
text
@d4 3
d110 1
a110 1
   structure Os: OS
d149 2
a150 2
      val dir = Os.Path.implodePath {root = Os.Path.REL, arcs = arcs}
      val path_ext = if ext = "" then Os.Path.NOEXT else Os.Path.EXT ext
d159 1
a159 1
      val last = Os.Path.addExt {name = name', ext = path_ext}
d161 1
a161 1
      Os.Path.addLast {dir = dir, last = last}
d169 1
a169 1
      Os.Path.implodePath {root = Os.Path.REL, arcs = arcs}
d175 1
a175 1
      val path_ext = if ext = "" then Os.Path.NOEXT else Os.Path.EXT ext
d185 1
a185 1
      Os.Path.addExt {name = name', ext = path_ext}
d320 1
a320 1
      val {dir, last} = Os.Path.splitLast s
d322 1
a322 1
      val {root, arcs} = Os.Path.explodePath dir
d324 1
a324 1
      val name = Os.Path.name last
@


1.23
log
@Fixed use of Info.default_options.
@
text
@d4 3
d101 1
a101 1
require "../initbasis/path";
d107 1
a107 1
   structure Path: PATH
d146 2
a147 2
      val dir = Path.implodePath {root = Path.REL, arcs = arcs}
      val path_ext = if ext = "" then Path.NOEXT else Path.EXT ext
d156 1
a156 1
      val last = Path.addExt {name = name', ext = path_ext}
d158 1
a158 1
      Path.addLast {dir = dir, last = last}
d166 1
a166 1
      Path.implodePath {root = Path.REL, arcs = arcs}
d172 1
a172 1
      val path_ext = if ext = "" then Path.NOEXT else Path.EXT ext
d182 1
a182 1
      Path.addExt {name = name', ext = path_ext}
d317 1
a317 1
      val {dir, last} = Path.splitLast s
d319 1
a319 1
      val {root, arcs} = Path.explodePath dir
d321 1
a321 1
      val name = Path.name last
@


1.22
log
@Added the is_pervasive predicate.
@
text
@d4 3
d209 1
a209 2
	       (Info.error'
		Info.default_options
d296 1
a296 2
      (Info.error'
	 Info.default_options
d303 1
a303 2
      (Info.error'
	 Info.default_options
d340 1
a340 2
      (Info.error'
	 Info.default_options
d355 2
a356 3
      Info.error'
      Info.default_options
      (Info.FAULT, location, "negative hats value")
d376 1
a376 2
          (Info.error'
	     Info.default_options
@


1.21
log
@Corrected previous log message.
@
text
@d4 3
d132 4
@


1.20
log
@Changed error message in squash_path.
@
text
@d4 4
@


1.19
log
@Provide non-faulting form of from_string
@
text
@d4 3
d131 9
a139 1
      val last = Path.addExt {name = Symbol.symbol_name s, ext = path_ext}
d156 8
a163 1
      val last = Path.addExt {name = Symbol.symbol_name s, ext = path_ext}
d165 1
a165 1
      Path.addExt {name = Symbol.symbol_name s, ext = path_ext}
d180 1
a180 1
    int_is_alpha c orelse c = ord"'" (*orelse c = ord"$" orelse c = ord"^"*)
d197 2
a198 1
		(Info.FATAL, Location.UNKNOWN, "invalid module name: " ^ string name))
d217 1
a217 1
  fun internal_from_string (s, init_offset, ord_sep) =
d240 3
a242 1
	      if not (legal ch) then
a243 2
	      else
		find_separator' (i+1)
d252 3
a254 2
	    ((c = ord"^" orelse c = ord"$") andalso
	     i+1 < len andalso String.ordof(s', i+1) = ord_sep)
d281 1
a281 1
    internal_from_string (s, 0, ord ".")
d285 15
a299 1
	 (Info.FATAL, location, "invalid module name: " ^ s))
d331 2
a332 1
	 (Info.FATAL, location, "invalid module name: " ^ s))
d360 4
a363 2
	     internal_from_string(prefix_hats(hats, [String.substring(s, i, size s - 3*hats)],
				      location), 0, ord"/")
d365 1
a365 1
	     internal_from_string(s, 0, ord"."))
d369 2
a370 1
	     (Info.FATAL, location, "invalid module name: " ^ s))
d375 5
d381 1
a381 1
    MLWorks.Option.SOME(internal_from_string (s, 0, ord "."))
@


1.18
log
@Modifications to from_require_string
@
text
@d4 3
d198 1
a198 1
  fun from_string' (s, init_offset, ord_sep) =
d261 1
a261 1
    from_string' (s, 0, ord ".")
d325 1
a325 1
	     from_string'(prefix_hats(hats, [String.substring(s, i, size s - 3*hats)],
d328 1
a328 1
	     from_string'(s, 0, ord"."))
d337 5
@


1.17
log
@filesys and path moved from utils to initbasis.
@
text
@d4 3
d93 1
d159 1
a159 1
    int_is_alpha c orelse c = ord"'"
d168 18
a185 1
  fun add_path (PATH l, MODID (s, l')) = MODID (s, l' @@ l)
a197 2
      (* val ord_dot = ord "." *)
      (* val ord_slash = ord "/" *)
d215 7
a221 3
            if ch = ord_sep (* ch = ord_dot orelse ch = ord_slash *) then i
            else if not (legal ch) then raise Parse s
            else find_separator' (i+1)
d225 10
a234 1
        if i = len orelse not (int_is_alpha (String.ordof (s', i))) then
a235 2
        else
          find_separator' (i+1)
d296 17
d317 1
a317 4
      fun from i =
	(* Hack to cope with our NJ compatibility scheme.  This should
	   eventually disappear, as should the admittance of '/' as a
	   separator. *)
d319 1
a319 1
	   from (i + 3)
d321 5
a325 1
	   from_string' (s, i, ord "/"))
d331 1
a331 1
      from 0
@


1.16
log
@Add functionality to support object paths
@
text
@d4 3
d79 1
a79 1
require "../utils/path";
@


1.15
log
@New path syntax.
@
text
@d4 3
d121 17
@


1.14
log
@Replaced FileName parameter with Path.
Added to_host function so that _module can be OS-independent.
@
text
@d4 4
d113 1
a113 1
      val dir = Path.implodePath {root = Path.REL, arcs = arcs, last = ""}
d115 1
d117 1
a117 1
      Path.makePath {dir = dir, name = Symbol.symbol_name s, ext = path_ext}
d213 3
a215 1
      val {root, arcs, last} = Path.explodePath s
@


1.13
log
@Parameterise on pathname separator
@
text
@d4 3
d69 1
a69 1
require "../utils/filename";
d75 1
a75 2
   structure Lists: sig val forall: ('a -> bool) -> 'a list -> bool end
   structure FileName : FILENAME
d86 2
a87 2
    | insert ([x], _) = [x]
    | insert (x::l, c) = x :: c :: insert (l, c)
d106 9
d117 1
a117 5
  fun eq_paths ([],[]) = true
    | eq_paths ([],s::l) = false
    | eq_paths (s::l,[]) = false
    | eq_paths (s::l,s'::l') =
      Symbol.eq_symbol (s,s') andalso eq_paths (l,l')
a118 3
  fun eq (MODID (s,l),MODID (s',l')) =
    Symbol.eq_symbol (s,s') andalso eq_paths (l,l')

d125 1
a125 1
  fun int_is_legal c =
d127 1
a127 1
    int_is_alpha c orelse c = ord"'" orelse c = ord":"
d143 4
a146 2
  exception Parse
  fun from_string' (s, init_offset) =
d149 2
a150 2
      val ord_dot = ord "."
      val ord_slash = ord FileName.separator
d152 6
a157 6
	if len - init_offset >= 3 andalso
	   String.substring (s, len - 3, 3) = ".mo" then
	  String.substring (s, 0, len - 3)
	else if len - init_offset >= 4 andalso
	   String.substring (s, len - 4, 4) = ".sml" then
	  String.substring (s, 0, len - 4)
d159 1
a159 1
	  s
d165 8
a172 8
	  let
	    val ch = String.ordof (s', i)
	  in
	    if ch = ord_dot orelse ch = ord_slash then i
	    else if not (int_is_legal ch) then raise Parse
	    else find_separator' (i+1)
	  end
	  
d175 1
a175 1
	  raise Parse
d177 1
a177 1
	  find_separator' (i+1)
d180 1
a180 1
        if i = len then raise Parse
d182 12
a193 13
	  let
	    val split = find_separator i
	    val symbol =
	      Symbol.find_symbol (String.substring (s', i, split - i))
	  in
	    if split = len then
	      ([], symbol)
	    else
	      let val (path, child) = from (split + 1)
	      in (symbol :: path, child)
	      end
	  end

d200 2
a201 2
    from_string' (s, 0)
    handle Parse =>
d204 20
a223 1
	 (Info.FATAL, location, "(from_string)invalid module name: " ^ s))
d225 10
a234 25
  fun trans_hard_slash str =
    if FileName.separator = "/" then
      str
    else
      (* Need to translate / into the real separator *)
      let
	val len = size str
	fun do_trans(result, index, last) =
	  if index >= len then
	    if last >= len then
	      (* Name ended with /, silly, but it will be caught later *)
	      result
	    else
	      (* Put on final component *)
	      result ^ String.substring(str, last, len - last)
	  else
	    if String.ordof(str, index) = ord"/" then
	      do_trans(result ^ String.substring(str, last, index - last) ^
		       FileName.separator, index + 1, index + 1)
	    else
	      do_trans(result, index + 1, last)
	val result = do_trans("", 0, 0)
      in
	result
      end
d241 1
a241 1
	(* Hack to cope with our NJU compatiility scheme.  This should
d247 2
a248 2
	   from_string'(trans_hard_slash(String.substring(s, i, len - i)), 0))
        handle Parse =>
d251 1
a251 1
	     (Info.FATAL, location, "(from_require_string)invalid module name: " ^ s))
@


1.12
log
@Added eq fun for module_ids
@
text
@d4 3
d66 1
a66 1
require "../utils/lists";
d73 1
d84 2
a85 2
  |   insert ([x], _) = [x]
  |   insert (x::l, c) = x :: c :: insert (l, c)
d123 1
a123 1
    int_is_alpha c orelse c = ord"'"
d144 1
a144 1
      val ord_slash = ord "/"
d199 27
a225 1
	 (Info.FATAL, location, "invalid module name: " ^ s))
d238 1
a238 1
	   from_string' (s, i))
d242 1
a242 1
	     (Info.FATAL, location, "invalid module name: " ^ s))
@


1.11
log
@Adding hyphen to module names and made invalid module name errors fatal
@
text
@d4 3
d101 9
@


1.10
log
@Adding .mo to extensions that from_string knows about.
@
text
@d4 3
d102 1
a102 1
    c = ord "_"
d181 1
a181 1
      (Info.error
d183 1
a183 2
	 (Info.FATAL, location, "invalid module name: " ^ s);
       MODID (Symbol.find_symbol ("<invalid module name `" ^ s ^ "'>"), []))
d198 1
a198 1
          (Info.error
d200 1
a200 2
	     (Info.RECOVERABLE, location, "invalid module name: " ^ s);
           MODID (Symbol.find_symbol ("<invalid module name `" ^ s ^ "'>"), []))
@


1.9
log
@changed from_unix_string (OS-specific) to from_require_string.
@
text
@d4 3
d127 4
a130 1
	if len - init_offset >= 4 andalso
@


1.8
log
@from_string now checks for trailing ".sml".
@
text
@d4 3
d177 1
a177 1
  fun from_unix_string (s, location) =
d182 3
@


1.7
log
@Merged in bug fix.
@
text
@d4 3
d120 7
d132 1
a132 1
	    val ch = String.ordof (s, i)
d140 1
a140 1
        if i = len orelse not (int_is_alpha (String.ordof (s, i))) then
d150 2
a151 1
	    val symbol = Symbol.find_symbol (String.substring (s, i, split - i))
d161 1
a161 1
      val (l, s) = from init_offset
d163 1
a163 1
      MODID (s, rev l)
a180 2
	 else if len >= 4 andalso String.substring (s, len - 4, 4) = ".sml" then
	   from_string' (String.substring (s, 0, len - 4), i)
@


1.6
log
@Merging in bug fixes
@
text
@d4 10
a96 27
  fun create (l, s, location) =
    let
      fun is_alpha_symbol sym =
	let val s = Symbol.symbol_name sym

	    fun is_all_legal i =
	      i = size s orelse
	      (int_is_legal (MLWorks.String.ordof (s, i)) andalso
	       is_all_legal (i+1))
	in
	  size s = 0 orelse
	  (int_is_alpha (MLWorks.String.ordof (s, 0)) andalso
	   is_all_legal 1)
	end

      val modid = MODID (s, rev l)
    in
      if Lists.forall is_alpha_symbol l andalso
	 is_alpha_symbol s then
	()
      else
	Info.error
	  Info.default_options
	  (Info.RECOVERABLE, location, "invalid module name: " ^ string modid);
      modid
    end

d112 1
a112 1
  fun from_string' (s, sep, init_offset) =
d115 3
a117 1
      val ord_sep = ord sep
d124 1
a124 1
	    if ch = ord_sep then i
d156 1
a156 1
    from_string' (s, ".", 0)
d171 1
a171 1
	   from_string' (String.substring (s, 0, len - 4), "/", i)
d173 1
a173 1
	   from_string' (s, "/", i))
@


1.5
log
@Merging in bug fixes
@
text
@d4 7
d51 1
a51 1
  datatype ModuleId = MODID of Symbol list * Symbol
d58 1
a58 1
  fun string (MODID (l, s)) =
d61 13
a73 2
  fun lt (MODID (l, s), MODID (l', s')) =
    Symbol.symbol_lt (s, s')
d75 2
d102 1
a102 1
      val modid = MODID (rev l, s)
d114 1
a114 1
  fun path (MODID (l, _)) = PATH l
d121 1
a121 1
  fun add_path (PATH l, MODID (l', s)) = MODID (l' @@ l, s)
d167 1
a167 1
      MODID (rev l, s)
d176 1
a176 1
       MODID ([], Symbol.find_symbol ("<invalid module name `" ^ s ^ "'>")))
d193 1
a193 1
           MODID ([], Symbol.find_symbol ("<invalid module name `" ^ s ^ "'>")))
@


1.4
log
@Added a comparison function.
@
text
@d4 9
d57 4
a60 4
  fun is_alpha c =
    (ord c >= ord "A" andalso ord c <= ord "Z") orelse
    (ord c >= ord "a" andalso ord c <= ord "z") orelse
    c = "_"
d63 4
a66 4
  fun is_legal c =
    (ord c >= ord "0" andalso ord c <= ord "9") orelse
    is_alpha c orelse c = "'"

d74 1
a74 1
	      (is_legal (MLWorks.String.substring (s, i, 1)) andalso
d78 1
a78 1
	  (is_alpha (MLWorks.String.substring (s, 0, 1)) andalso
d112 1
a112 1

d116 2
a117 1
	  let val ch = String.substring (s, i, 1)
d119 2
a120 2
	    if ch = sep then i
	    else if not (is_legal ch) then raise Parse
d125 1
a125 1
        if i = len orelse not (is_alpha (String.substring (s, i, 1))) then
@


1.4.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.4  1993/08/27  13:47:55  daveb
Added a comparison function.

@


1.4.1.2
log
@Improvements to use String.ordof rather than String.substring
@
text
@a3 3
Revision 1.4.1.1  1993/08/27  13:47:55  jont
Fork for bug fixing

d51 4
a54 4
  fun int_is_alpha c =
    (c >= ord "A" andalso c <= ord "Z") orelse
    (c >= ord "a" andalso c <= ord "z") orelse
    c = ord "_"
d57 4
a60 4
  fun int_is_legal c =
    (c >= ord "0" andalso c <= ord "9") orelse
    int_is_alpha c orelse c = ord"'"
    
d68 1
a68 1
	      (int_is_legal (MLWorks.String.ordof (s, i)) andalso
d72 1
a72 1
	  (int_is_alpha (MLWorks.String.ordof (s, 0)) andalso
d106 1
a106 1
      val ord_sep = ord sep
d110 1
a110 2
	  let
	    val ch = String.ordof (s, i)
d112 2
a113 2
	    if ch = ord_sep then i
	    else if not (int_is_legal ch) then raise Parse
d118 1
a118 1
        if i = len orelse not (int_is_alpha (String.ordof (s, i))) then
@


1.4.1.3
log
@Changed the order of the terms in a moduleid. This will be a compiler
efficiency issue. Fixed lt to be a proper ordering function
@
text
@a3 3
Revision 1.4.1.2  1993/09/02  13:25:22  jont
Improvements to use String.ordof rather than String.substring

d41 1
a41 1
  datatype ModuleId = MODID of Symbol * Symbol list
d48 1
a48 1
  fun string (MODID (s, l)) =
d51 2
a52 13
  fun lt' ((s, l), (s', l')) =
    if Symbol.symbol_lt (s, s') then true
    else
      if Symbol.symbol_lt (s', s) then false
      else
	(* The tricky case, where we compare the path *)
	(* Shorter paths will be less than longer paths *)
	case l of
	  [] => l' <> [] (* lt provided second path not nil *)
	| (h :: t) =>
	    case l' of
	      [] => false (* ~lt if second path nil and first not *)
	    | (h' :: t') => lt'((h, t), (h', t'))
a53 2
  fun lt (MODID a, MODID b) = lt'(a, b)

d79 1
a79 1
      val modid = MODID (s, rev l)
d91 1
a91 1
  fun path (MODID (_, l)) = PATH l
d98 1
a98 1
  fun add_path (PATH l, MODID (s, l')) = MODID (s, l' @@ l)
d144 1
a144 1
      MODID (s, rev l)
d153 1
a153 1
       MODID (Symbol.find_symbol ("<invalid module name `" ^ s ^ "'>"), []))
d170 1
a170 1
           MODID (Symbol.find_symbol ("<invalid module name `" ^ s ^ "'>"), []))
@


1.4.1.4
log
@Removed create function, as require can no longer take module ids.
Changed from_string to recognise either / or . as separators.
@
text
@a3 7
Revision 1.5  1993/09/02  14:24:33  jont
Merging in bug fixes

Revision 1.4.1.3  1993/09/10  15:09:47  jont
Changed the order of the terms in a moduleid. This will be a compiler
efficiency issue. Fixed lt to be a proper ordering function

d80 27
d122 1
a122 1
  fun from_string' (s, init_offset) =
d125 1
a125 3
      val ord_dot = ord "."
      val ord_slash = ord "/"

d132 1
a132 1
	    if ch = ord_dot orelse ch = ord_slash then i
d164 1
a164 1
    from_string' (s, 0)
d179 1
a179 1
	   from_string' (String.substring (s, 0, len - 4), i)
d181 1
a181 1
	   from_string' (s, i))
@


1.3
log
@from_string and from_unix_string return a more informative symbol on error.
@
text
@d4 3
d44 3
@


1.2
log
@Fixed bug in from_string.
 Added create function that checks that moduleids are alphanumeric.
Checked legality of moduleids in old-fashioned require declarations.
@
text
@d4 5
d140 1
a140 1
       MODID ([], Symbol.find_symbol ""))
d157 1
a157 1
           MODID ([], Symbol.find_symbol ""))
@


1.1
log
@Initial revision
@
text
@d3 3
a5 1
$Log$
d7 1
d14 1
d20 1
d37 37
d88 2
a89 1
  fun from_string s =
d93 3
a95 18
      fun is_alpha c =
        (ord c >= ord "A" andalso ord c <= ord "Z") orelse
        (ord c >= ord "a" andalso ord c <= ord "z") orelse
        c = "_"
	(* underscores allowed here to cope with our file naming scheme *)

      fun is_legal c =
        (ord c >= ord "0" andalso ord c <= ord "9") orelse
        is_alpha c orelse c = "'"

      fun error () =
	Info.error'
	  Info.default_options
	  (Info.FATAL, Info.Location.UNKNOWN, "invalid module name: " ^ s)

      fun find_dot' i =
	if i = len then i
	else
d98 3
a100 3
	    if ch = "." then i
	    else if not (is_legal ch) then error ()
	    else find_dot' (i+1)
d103 1
a103 1
      fun find_dot i =
d105 3
a107 3
	  error ()
	else
	  find_dot' (i+1)
d110 1
a110 1
        if i = len then error()
d113 1
a113 1
	    val split = find_dot i
d123 2
d126 1
a126 1
      MODID (from 0)
d129 8
a140 6
      fun find_slash i =
        if i = len orelse String.substring (s, i, 1) = "/" then
	  i
        else
	  find_slash (i + 1)
  	
d142 8
a149 2
        if i = len then
	  (Info.error
d151 2
a152 16
	     (Info.RECOVERABLE, location, "module name has empty last part");
	   ([], Symbol.find_symbol ""))
        else if len - i >= 3 andalso String.substring (s, i, 3) = "../" then
	  from (i + 3)
        else
	  let
	    val split = find_slash i
	    val symbol = Symbol.find_symbol (String.substring (s, i, split - i))
	  in
	    if split = len then
	      ([], symbol)
	    else
	      let val (path, child) = from (split + 1)
	      in (symbol :: path, child)
	      end
	  end
d154 1
a154 1
      MODID (from 0)
@
