head	1.45;
access;
symbols
	MLWorks_20b0_1998_04_07:1.45
	MLWorks_20b0_1998_03_20:1.45
	MLWorks_20m2_1998_02_16:1.44
	MLWorks_20m1_1997_10_23:1.42
	MLWorks_11r1:1.40.1.1.1.1.1
	MLWorks_workspace_97:1.42.2
	MLWorks_dt_wizard:1.42.1
	MLWorks_11c0_1997_09_09:1.40.1.1.1.1
	MLWorks_10r3:1.40.1.1.3
	MLWorks_10r2_551:1.40.1.1.2
	MLWorks_11:1.40.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.40.1.1
	MLWorks_20m0_1997_06_20:1.42
	MLWorks_1_0_r2c2_1997_06_14:1.40.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.40.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.40.1
	MLWorks_BugFix_1997_04_24:1.40
	MLWorks_1_0_r2_Win32_1997_04_11:1.40
	MLWorks_1_0_r2_Unix_1997_04_04:1.40
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.36.6.1.1
	MLWorks_gui_1996_12_18:1.36.7
	MLWorks_1_0_Win32_1996_12_17:1.36.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.36.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.36.4.1
	MLWorks_1_0_Irix_1996_11_28:1.36.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.36.5
	MLWorks_1_0_Unix_1996_11_14:1.36.4
	MLWorks_Open_Beta2_1996_10_11:1.36.3
	MLWorks_License_dev:1.36.2
	MLWorks_1_open_beta_1996_09_13:1.36.1
	MLWorks_Open_Beta_1996_08_22:1.35
	MLWorks_Beta_1996_07_02:1.34
	MLWorks_Beta_1996_06_07:1.33
	MLWorks_Beta_1996_06_06:1.33
	MLWorks_Beta_1996_06_05:1.33
	MLWorks_Beta_1996_06_03:1.33
	MLWorks_Beta_1996_05_31:1.33
	MLWorks_Beta_1996_05_30:1.32
	ML_beta_release_12/08/94:1.4
	ML_beta_release_03/08/94:1.4
	ML_revised_beta_release_25/05/94:1.4
	ML_final_beta_release_02/03/94:1.2;
locks; strict;
comment	@ * @;


1.45
date	98.02.19.08.57.06;	author mitchell;	state Exp;
branches;
next	1.44;

1.44
date	98.01.30.09.32.54;	author johnh;	state Exp;
branches;
next	1.43;

1.43
date	97.10.20.15.40.42;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	97.05.12.15.58.02;	author jont;	state Exp;
branches
	1.42.1.1
	1.42.2.1;
next	1.41;

1.41
date	97.05.08.09.13.53;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	97.03.21.11.07.00;	author johnh;	state Exp;
branches
	1.40.1.1;
next	1.39;

1.39
date	97.03.05.12.30.57;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	97.02.28.14.43.40;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	97.02.12.13.22.02;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	96.08.27.12.45.12;	author daveb;	state Exp;
branches
	1.36.1.1
	1.36.2.1
	1.36.3.1
	1.36.4.1
	1.36.5.1
	1.36.6.1
	1.36.7.1;
next	1.35;

1.35
date	96.08.16.14.52.01;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	96.06.21.15.28.28;	author stephenb;	state Exp;
branches;
next	1.33;

1.33
date	96.05.30.12.05.49;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	96.05.23.12.19.30;	author stephenb;	state Exp;
branches;
next	1.31;

1.31
date	96.05.21.11.13.54;	author stephenb;	state Exp;
branches;
next	1.30;

1.30
date	96.04.30.14.40.05;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	96.04.18.15.16.58;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	96.04.17.14.31.23;	author stephenb;	state Exp;
branches;
next	1.27;

1.27
date	96.04.17.10.32.28;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	96.04.09.13.50.13;	author stephenb;	state Exp;
branches;
next	1.25;

1.25
date	96.04.01.09.27.15;	author stephenb;	state Exp;
branches;
next	1.24;

1.24
date	96.03.26.09.59.59;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	96.03.15.16.55.45;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	96.03.15.12.31.53;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	96.02.23.16.11.39;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	95.12.12.11.46.08;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	95.12.05.14.51.18;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.04.28.15.23.34;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	95.04.21.13.52.55;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	95.04.20.14.29.37;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	95.04.12.13.26.19;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	95.02.28.17.14.40;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	95.02.28.17.09.58;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	95.02.28.12.44.12;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	95.02.17.15.23.57;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	95.02.17.15.15.05;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.01.25.16.06.55;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	95.01.18.13.49.28;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	94.12.08.17.36.12;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.10.13.10.18.36;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	94.10.06.10.28.29;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	94.03.25.16.16.49;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	94.03.22.16.15.12;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	94.02.08.15.59.53;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	94.02.02.13.39.30;	author johnk;	state Exp;
branches;
next	;

1.36.1.1
date	96.09.13.11.08.49;	author hope;	state Exp;
branches;
next	;

1.36.2.1
date	96.10.07.15.59.49;	author hope;	state Exp;
branches;
next	;

1.36.3.1
date	96.10.17.11.18.10;	author hope;	state Exp;
branches;
next	;

1.36.4.1
date	96.11.14.12.41.42;	author hope;	state Exp;
branches
	1.36.4.1.1.1;
next	;

1.36.4.1.1.1
date	96.11.28.14.53.35;	author hope;	state Exp;
branches;
next	;

1.36.5.1
date	96.11.22.18.02.08;	author hope;	state Exp;
branches;
next	;

1.36.6.1
date	96.12.17.17.41.04;	author hope;	state Exp;
branches
	1.36.6.1.1.1;
next	;

1.36.6.1.1.1
date	97.02.24.11.29.05;	author hope;	state Exp;
branches;
next	;

1.36.7.1
date	96.12.18.09.34.59;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	97.05.12.10.27.02;	author hope;	state Exp;
branches
	1.40.1.1.1.1
	1.40.1.1.2.1
	1.40.1.1.3.1;
next	;

1.40.1.1.1.1
date	97.07.28.18.13.03;	author daveb;	state Exp;
branches
	1.40.1.1.1.1.1.1;
next	;

1.40.1.1.1.1.1.1
date	97.10.07.11.38.04;	author jkbrook;	state Exp;
branches;
next	;

1.40.1.1.2.1
date	97.09.08.17.06.22;	author daveb;	state Exp;
branches;
next	;

1.40.1.1.3.1
date	97.09.09.14.01.45;	author daveb;	state Exp;
branches;
next	;

1.42.1.1
date	97.09.10.19.16.10;	author brucem;	state Exp;
branches;
next	;

1.42.2.1
date	97.09.11.20.46.05;	author daveb;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	97.10.29.13.42.46;	author daveb;	state Exp;
branches;
next	1.42.2.3;

1.42.2.3
date	97.11.20.16.51.26;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.45
log
@[Bug #30337]
Change uses of OS.Path.concat to take a string list, instead of a pair of strings.
@
text
@(*  Modules - ModuleId + Directory.
 *
 *  This module contains LOCALE-specific strings.
 *
 *  Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
 *
 *  $Log: _module.sml,v $
 * Revision 1.44  1998/01/30  09:32:54  johnh
 * [Bug #30326]
 * Merge in Project Workspace changes.
 *
 * Revision 1.43  1997/10/20  15:40:42  jont
 * [Bug #30089]
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
 * Revision 1.42.2.3  1997/11/20  16:51:26  daveb
 * [Bug #30326]
 *
 * Revision 1.42.2.2  1997/10/29  13:42:46  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
 * Revision 1.42.2.1  1997/09/11  20:46:05  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.42  1997/05/12  15:58:02  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
 * Revision 1.41  1997/05/08  09:13:53  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.40  1997/03/21  11:07:00  johnh
 * [Bug #1965]
 * Dealt with NotSet exception.
 *
 * Revision 1.39  1997/03/05  12:30:57  jont
 * [Bug #1940]
 * Use Path.fromUnixPath instead of mkAbsolute to translate from
 * unix paths to win32 paths.
 *
 * Revision 1.38  1997/02/28  14:43:40  jont
 * [Bug #1931]
 * Sort out problems with splitBaseExt on Win32 not understanding unix pathnames
 *
 * Revision 1.37  1997/02/12  13:22:02  daveb
 * Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
 *
 * Revision 1.36  1996/08/27  12:45:12  daveb
 * Added comments (in preparation for a code review).
 *
 * Revision 1.35  1996/08/16  14:52:01  daveb
 * [Bug #982]
 * Made find_file convert .mo into .sml.
 *
 * Revision 1.34  1996/06/21  15:28:28  stephenb
 * Remove a (debugging) line that somehow got left behind when I last
 * checked this file in.
 *
 * Revision 1.33  1996/05/30  12:05:49  daveb
 * The Io exception is no longer at top level.
 *
 * Revision 1.32  1996/05/23  12:19:30  stephenb
 * Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
 * now does what the former used to do.
 *
 * Revision 1.31  1996/05/21  11:13:54  stephenb
 * Change to pull in Path directly rather than OS.Path since the latter
 * now conforms to the latest basis and it is too much effort to update
 * the code to OS.Path at this point.
 *
 * Revision 1.30  1996/04/30  14:40:05  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.29  1996/04/18  15:16:58  jont
 * initbasis moves to basis
 *
 * Revision 1.28  1996/04/17  14:31:23  stephenb
 * Update wrt Os -> OS name change.
 *
 * Revision 1.27  1996/04/17  10:32:28  jont
 * Modify to use set_source_path_without_expansion when extending
 * and retracting source_path
 *
 * Revision 1.26  1996/04/09  13:50:13  stephenb
 * find_file: add handlers for Os.Path.Path, OS.SysErr and Io.
 *
 * Revision 1.25  1996/04/01  09:27:15  stephenb
 * Updated to use new basis compatible OS.  In the process renameOS -> OLD_OS,
 * and Os -> OldOs.
 *
 * Revision 1.24  1996/03/26  09:59:59  daveb
 * Revised with_source_path; removed call to find_file.  This is now done in
 * Incremental.match_source_path.
 *
 * Revision 1.23  1996/03/15  16:55:45  daveb
 * Module.mo_name now takes an Info.options argument.
 *
 * Revision 1.22  1996/03/15  12:31:53  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.21  1996/02/23  16:11:39  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.20  1995/12/12  11:46:08  daveb
 * Added message parameter to with_source_path.
 *
 * Revision 1.19  1995/12/05  14:51:18  daveb
 * Removed caches.
 *
 * Revision 1.18  1995/04/28  15:23:34  jont
 * new module naming stuff
 *
 * Revision 1.17  1995/04/21  13:52:55  daveb
 * FileSys.get_dir renamed FileSys.getDir.
 * Expansion of home directories moved to Getenv.
 * path and filesys moved from utils to initbasis.
 * with_source_path takes a location argument.
 *
 * Revision 1.16  1995/04/20  14:29:37  jont
 * Modifications to allow object paths
 *
 * Revision 1.15  1995/04/12  13:26:19  jont
 * Change FILESYS to FILE_SYS
 *
 * Revision 1.14  1995/02/28  17:14:40  daveb
 * New path syntax simplifies implementation of suffix function.
 *
 * Revision 1.13  1995/02/28  17:09:58  daveb
 * Fixed bug in my new suffix function.
 *
 * Revision 1.12  1995/02/28  12:44:12  daveb
 * The Path signature no longer provides a suffix function.
 *
 * Revision 1.11  1995/02/17  15:23:57  daveb
 * Replaced a call to check_search_path with Path.suffix of the current
 * entry on the source path.
 *
 * Revision 1.10  1995/02/17  15:15:05  daveb
 * Added a diagnostic when extending the source path.
 *
 * Revision 1.9  1995/01/25  16:06:55  daveb
 * Replaced the FileName structure with the new Path structure.
 * Replaced the Option structure with references to MLWorks.Option.
 *
 * Revision 1.8  1995/01/18  13:49:28  jont
 * Parameterise pathname separator on FileName
 *
 * Revision 1.7  1994/12/08  17:36:12  jont
 * Move OS specific stuff into a system link directory
 *
 * Revision 1.6  1994/10/13  10:18:36  matthew
 * Use pervasive Option.option for return values in NewMap
 *
 * Revision 1.5  1994/10/06  10:28:29  matthew
 * Better caching and other improvements
 *
 * Revision 1.4  1994/03/25  16:16:49  daveb
 * Added with_source_path.
 *
 * Revision 1.3  1994/03/22  16:15:12  daveb
 * Canonicalised module names.
 *
 * Revision 1.2  1994/02/08  15:59:53  daveb
 * module_and_path is now called find_file, and is functional.
 * check_search_path returns an option instead of raising an exception.
 *
 * Revision 1.1  1994/02/02  13:39:30  johnk
 * new file
 *
 *)

require "../main/mlworks_io";
require "module";
require "module_id";
require "../main/info";
require "../utils/diagnostic";
require "../basis/os";
require "../utils/getenv";

(* The Module type locates a file as a pair of an entry on the source
   path and a module id.  It is used by functions that work out the
   module id of a file given the full path name, and by functions
   that need both the full path name and the module id. *)

functor Module
  (structure Io : MLWORKS_IO
   structure OS : OS
   structure Getenv : GETENV
   structure ModuleId : MODULE_ID
   structure Info: INFO
   structure Diagnostic: DIAGNOSTIC
   sharing type Info.Location.T = ModuleId.Location
  ): MODULE =
struct
    structure FileSys = OS.FileSys
    type ModuleId = ModuleId.ModuleId
    type Location = ModuleId.Location
    type InfoOptions = Info.options

    fun diagnostic (level, output_function) =
      Diagnostic.output level
        (fn verbosity => "Module: " :: (output_function verbosity))

    datatype Module = MODULE of string * ModuleId

    (* Projection functions *)
    fun module_id (MODULE (_, module_id)) = module_id
    fun module_dir (MODULE (dir, _)) = dir

    val source_ext = "sml"
    val object_ext = "mo"

    fun sourceName (MODULE (dir, module_id)) =
      OS.Path.mkCanonical
	(OS.Path.concat [dir, ModuleId.to_host (module_id, source_ext)])
	(* concat cannot fail, as ModuleId.to_host always returns
	   a relative path. *)

    (* parse_object explodes the object_path into root and arcs, ready
       for expanding the %S and %C components. *)
    fun parse_object_path() =
      let
	val object_path = Io.get_object_path()
      in
	OS.Path.fromString(OS.Path.fromUnixPath object_path)
      end

    (* objectName returns the file name of the mo file, after expanding the
       object path.  The object path consists of a pathname, in which one
       arc may be %C and one %S.  %S is replaced by the entry from the
       source path, and %C by the component part of the module name. *)
    fun objectName (error_info, loc) (MODULE(dir, module_id)) =
      let
	(* This reference is used to keep track of whether the component
	   part of the path is used during the expansion of the arcs.
	   It is simpler to side-effect this during the map than to
	   thread the value through all the function calls. *)
	val used_component = ref false
	val component = ModuleId.module_component_to_string module_id

	fun substitute_object_path_arc "%S" = dir
	  | substitute_object_path_arc "%C" =
	      (used_component := true;
	       component)
	  | substitute_object_path_arc s = s

	val {isAbs, vol, arcs} = parse_object_path()

	val result =
	  OS.Path.toString
	    {isAbs = isAbs,
	     vol = vol,
	     arcs = map substitute_object_path_arc arcs @@
	            [ModuleId.module_unit_to_string(module_id, object_ext)]}

	(* Warn if the object path ignores the component part of
	   the module name. *)
	val _ =
	  if component <> "." andalso not(!used_component) then
	    Info.error
	      error_info
	      (Info.WARNING, loc,
	       "Module " ^ ModuleId.string module_id ^
	       " has non-trivial prefix ignored by object path ")
	  else
	    ()
      in
	OS.Path.mkCanonical result
      end

    (* suffix takes two paths, p1 and p2.  If p2 is a prefix of p1, it
       returns the remaining elements of p1 as a list of arcs.  Otherwise
       it returns NONE. *)
    fun suffix (p1, p2) =
      let
	val explode1 = OS.Path.fromString p1
	val explode2 = OS.Path.fromString p2

	fun lists_suffix ([], l) = 
	  SOME (OS.Path.toString {isAbs = false, vol = #vol explode1, arcs = l})
	|   lists_suffix (_, []) =  NONE
	|   lists_suffix (h1::t1, h2::t2) =
	  if h1 = h2 then
	    lists_suffix (t1, t2)
	  else
	    NONE
      in 
	if #vol explode1 <> #vol explode2 then
	  NONE
	else
	  lists_suffix (#arcs explode2, #arcs explode1)
      end

    (* check_search_path checks whether filename refers to a file in a
       subdirectory of a directory on the source path. *)
    fun check_search_path (filename, loc) =
      let
	val path = Io.get_source_path ()

        fun check [] = NONE
        |   check (h::t) =
	  case suffix (filename, h)
	  of NONE =>
	    check t
	  |  SOME i => 
	    SOME (MODULE (h, ModuleId.from_host (i, loc)))
      in 
        check path
      end

    (* find_module finds the file that corresponds to the module_id,
       by searching the source path.  The name argument produces the
       file name from the directory and module_id.  The expand_links
       argument expands any symbolic links (source files only). *)
    fun find_module
	  (error_info, loc)
	  (module_id, name, expand_links) =
      let
        val source_path = Io.get_source_path ()

	fun search [] = NONE
	  | search (dir::rest) =
	  let
	    val filename = name (MODULE (dir, module_id))

	    val _ =
	      diagnostic
	      (2, fn _ => ["searching: ", filename])
	  in
	    let
	      val stamp = FileSys.modTime filename
	    in
	      let
		val real_name =
		  OS.FileSys.fullPath filename
	      in
		expand_links (real_name, MODULE (dir, module_id), stamp)
	      end handle OS.SysErr _ =>
		(* I'm not sure that this can ever happen.  The file
		 must exist, so symbolic links must be valid. *)
		Info.default_error'
		(Info.FATAL, loc,
		 (* LOCALE *)
		 "Module " ^ ModuleId.string module_id ^
		 " points to " ^ filename ^
		 ", which does not expand to a real file")
	    end handle OS.SysErr _ => search rest
	  end
      in
        search source_path
      end

    (* findSource and findObject are the exported functions to find the
       appropriate file for the module_id, via calls to find_module. *)

    (* findSource expands any symbolic links in the file name, and
       recalculates the module name from the expanded path.  This allows
       e.g. our links from machine->{sparc,mips,i386}, while giving a
       unique name to each compilation unit. *)
    local
      fun expand_links loc (real_name, MODULE (dir, module_id), stamp) =
        case suffix (real_name, dir) of
	  SOME s =>
	    SOME
	      (real_name,
	       MODULE (dir, ModuleId.from_host (s, loc)),
	       stamp)
        |  NONE =>
          Info.default_error'
	    (Info.FATAL, loc,
	     (* LOCALE *)
	     "Module " ^ ModuleId.string module_id ^
	     " points to " ^ real_name ^
	     ", which lies outside its entry on the source path")
    in
      fun findSource (error_info, loc) module_id =
        find_module
	  (error_info, loc)
	  (module_id, sourceName, fn x => expand_links loc x)
    end 

    (* findObject doesn't have to expand symbolic links, because the
       module name is read from the object file itself. *)
    fun findObject (error_info, loc) module_id =
      find_module
	(error_info, loc)
	(module_id, objectName (error_info, loc), fn x => SOME x)
      handle Io.NotSet _ => NONE


    (* Given a module_id for a pervasive module, findPervasiveObject finds
       the corresponding object file, and returns the file name, module,
       and modification time. *)
    fun findPervasiveObject (error_info, loc) module_id = 
      let
        val dir = Io.get_pervasive_dir()
	val filename = objectName (error_info, loc) (MODULE(dir, module_id))
      in
	let
	  val time = FileSys.modTime filename
	in
	  SOME(filename, MODULE(dir, module_id), time)
	end handle OS.SysErr _ => NONE
      end
      handle Io.NotSet _ => NONE

    (* Given a module_id for a pervasive module, findPervasiveSource finds
       the corresponding source file, and returns the file name, module,
       and modification time. *)
    fun findPervasiveSource (error_info, loc) module_id =
      let
        val module = MODULE (Io.get_pervasive_dir(), module_id)
        val sml_str = sourceName module
      in
	let
	  val time = FileSys.modTime sml_str
	in
          (diagnostic (2, fn _ => ["Found `", sml_str, "'"]);
	   SOME (sml_str, module, time))
        end handle OS.SysErr _ => NONE
      end
      handle Io.NotSet _ => NONE

    exception NoSuchFile of string
    exception BadHomeName = Getenv.BadHomeName

    (* find_file finds the named file and checks whether it is on the
       source path.  If it is on the source path, find_file returns true,
       paired with a module that consists of the appropriate entry from
       the path and the corresponding module id.  If it isn't on the
       source path, find_file returns false, paired with a module id
       constructed from the base name of the file and the directory
       containing it.  
       The Location argument is used for error messages. *)
    fun find_file (filename, loc) =
      let
	(* First, check that the file exists.  Expand the directory, add
	   the extension, and use mtime. *)
	(* Also, apply Path.fromUnixPath in case we are on Win32 *)
	(* but supplied with a unix style path name *)
	val filename' = OS.Path.fromUnixPath filename
	val extended =
	  case OS.Path.splitBaseExt filename' of
	    {ext = SOME ext, base} =>
	      if ext = object_ext then
	      (* If we are asked to find an .mo file, look for the .sml file
		 instead.  See bug 982. *)
	        OS.Path.joinBaseExt {base = base, ext = SOME source_ext} 
	      else
	        filename'
	  | {base, ...} =>
	      OS.Path.joinBaseExt {base = base, ext = SOME source_ext}

        val absolute = OS.Path.mkAbsolute
	  (OS.FileSys.fullPath(Getenv.expand_home_dir extended), OS.FileSys.getDir())
          handle
            OS.Path.Path => raise NoSuchFile filename
          | OS.SysErr _ => raise NoSuchFile filename

	val time = FileSys.modTime absolute handle OS.SysErr _ => raise NoSuchFile absolute
      in
	case check_search_path (absolute, loc) of
	  SOME module => (true, module)
	| NONE =>
	    (false,
	     MODULE (OS.Path.dir absolute,
		     ModuleId.from_host (OS.Path.file absolute, loc)))
      end

    (* with_source_path extends the source path with the directory part
       of the module argument while evaluating the function argument
       applied to the module_id part. *)
    fun with_source_path (module, reason) f =
      let
        val old_source_path = Io.get_source_path ()

	val mod_id = module_id module
	val dir = module_dir module

        val _ =
	  print
	    (* LOCALE *)
            ("Extending source path with directory "
             ^ dir ^ " while " ^ reason ^ " module `"
             ^ ModuleId.string mod_id  ^ "'\n");

	val _ =
           Io.set_source_path_without_expansion (dir :: old_source_path)

        val result =
          f mod_id
          handle
            exn =>
	      (Io.set_source_path_without_expansion old_source_path;
	       raise exn)
      in
        Io.set_source_path_without_expansion old_source_path;
        result
      end

  end;
@


1.44
log
@[Bug #30326]
Merge in Project Workspace changes.
@
text
@d8 4
d221 1
a221 1
	(OS.Path.concat (dir, ModuleId.to_host (module_id, source_ext)))
@


1.43
log
@[Bug #30089]
Remove use of OldOs.mtime in favour of OsFileSys.modTime
@
text
@d8 15
d174 1
a174 1
require "../main/io";
@


1.42
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d8 4
a162 1
require "../make/old_os";
a176 1
   structure OldOs: OLD_OS
d182 1
d317 18
a334 19
	    case OldOs.mtime filename of
	      OldOs.NOT_EXIST =>
	        search rest
	    | OldOs.EXISTS stamp =>
		let
		  val real_name =
		    OS.FileSys.fullPath filename
		in
		  expand_links (real_name, MODULE (dir, module_id), stamp)
		end
		handle OS.SysErr _ =>
		  (* I'm not sure that this can ever happen.  The file
		     must exist, so symbolic links must be valid. *)
		  Info.default_error'
		    (Info.FATAL, loc,
		    (* LOCALE *)
		    "Module " ^ ModuleId.string module_id ^
		    " points to " ^ filename ^
		    ", which does not expand to a real file")
d386 5
a390 5
        case OldOs.mtime filename of
          OldOs.EXISTS time =>
	    SOME(filename, MODULE(dir, module_id), time)
	| OldOs.NOT_EXIST =>
	    NONE
d402 3
a404 2
        case OldOs.mtime sml_str of
            OldOs.EXISTS time =>
d406 2
a407 2
             SOME (sml_str, module, time))
        | OldOs.NOT_EXIST => NONE
d447 1
d449 6
a454 10
	case OldOs.mtime absolute of
	  OldOs.NOT_EXIST =>
	    raise NoSuchFile absolute
	| OldOs.EXISTS _ =>
	      case check_search_path (absolute, loc) of
		SOME module => (true, module)
	      | NONE =>
		  (false,
		   MODULE (OS.Path.dir absolute,
			   ModuleId.from_host (OS.Path.file absolute, loc)))
@


1.42.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
 * Revision 1.42  1997/05/12  15:58:02  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
@


1.42.2.2
log
@[Bug #30089]
Merged from trunk:
Remove use of OldOs.mtime in favour of OsFileSys.modTime
@
text
@a7 3
 * Revision 1.42.2.1  1997/09/11  20:46:05  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d163 1
d178 1
a183 1
    structure FileSys = OS.FileSys
d318 19
a336 18
	    let
	      val stamp = FileSys.modTime filename
	    in
	      let
		val real_name =
		  OS.FileSys.fullPath filename
	      in
		expand_links (real_name, MODULE (dir, module_id), stamp)
	      end handle OS.SysErr _ =>
		(* I'm not sure that this can ever happen.  The file
		 must exist, so symbolic links must be valid. *)
		Info.default_error'
		(Info.FATAL, loc,
		 (* LOCALE *)
		 "Module " ^ ModuleId.string module_id ^
		 " points to " ^ filename ^
		 ", which does not expand to a real file")
	    end handle OS.SysErr _ => search rest
d388 5
a392 5
	let
	  val time = FileSys.modTime filename
	in
	  SOME(filename, MODULE(dir, module_id), time)
	end handle OS.SysErr _ => NONE
d404 2
a405 3
	let
	  val time = FileSys.modTime sml_str
	in
d407 2
a408 2
	   SOME (sml_str, module, time))
        end handle OS.SysErr _ => NONE
a447 1
	val time = FileSys.modTime absolute handle OS.SysErr _ => raise NoSuchFile absolute
d449 10
a458 6
	case check_search_path (absolute, loc) of
	  SOME module => (true, module)
	| NONE =>
	    (false,
	     MODULE (OS.Path.dir absolute,
		     ModuleId.from_host (OS.Path.file absolute, loc)))
@


1.42.2.3
log
@[Bug #30326]
@
text
@a7 5
 * Revision 1.42.2.2  1997/10/29  13:42:46  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
d162 1
a162 1
require "../main/mlworks_io";
@


1.42.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
 * Revision 1.42  1997/05/12  15:58:02  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
@


1.41
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d8 4
d170 1
a170 1
  (structure Io : IO
@


1.40
log
@[Bug #1965]
Dealt with NotSet exception.
@
text
@d8 4
d205 1
a205 1
	OS.Path.fromString object_path
@


1.40.1.1
log
@branched from 1.40
@
text
@a7 4
 * Revision 1.40  1997/03/21  11:07:00  johnh
 * [Bug #1965]
 * Dealt with NotSet exception.
 *
@


1.40.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.40.1.1  1997/05/12  10:27:02  hope
 * branched from 1.40
 *
@


1.40.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.40.1.1  1997/05/12  10:27:02  hope
 * branched from 1.40
 *
@


1.40.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.40.1.1  1997/05/12  10:27:02  hope
 * branched from 1.40
 *
@


1.40.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.40.1.1.1.1  1997/07/28  18:13:03  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.39
log
@[Bug #1940]
Use Path.fromUnixPath instead of mkAbsolute to translate from
unix paths to win32 paths.
@
text
@d8 5
d365 1
@


1.38
log
@[Bug #1931]
Sort out problems with splitBaseExt on Win32 not understanding unix pathnames
@
text
@d8 4
d409 3
a411 4
	(* This first call to splitBaseExt may fail under Win32 *)
	(* if the path supplied is using unix separators *)
	(* However, fullPath will sort that out *)
	(* so we do another call to splitBaseExt later *)
d413 1
a413 1
	  case OS.Path.splitBaseExt filename of
d420 1
a420 1
	        filename
a428 12

	val absolute =
	  case OS.Path.splitBaseExt absolute of
	    {ext = SOME ext, base} =>
	      if ext = object_ext then
	      (* If we are asked to find an .mo file, look for the .sml file
		 instead.  See bug 982. *)
	        OS.Path.joinBaseExt {base = base, ext = SOME source_ext} 
	      else
	        absolute
	  | {base, ...} =>
	      OS.Path.joinBaseExt {base = base, ext = SOME source_ext}
@


1.37
log
@Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
@
text
@d8 3
d405 4
d421 2
a422 4
        val absolute =
	  OS.Path.mkAbsolute
	    (OS.FileSys.fullPath (Getenv.expand_home_dir extended),
	     OS.FileSys.getDir ())
d427 12
d440 10
a449 10
	case OldOs.mtime absolute
	of OldOs.NOT_EXIST =>
	  raise NoSuchFile absolute
	|  OldOs.EXISTS _ =>
          case check_search_path (absolute, loc)
	  of SOME module => (true, module)
	  |  NONE =>
	    (false,
	     MODULE (OS.Path.dir absolute,
		     ModuleId.from_host (OS.Path.file absolute, loc)))
@


1.36
log
@Added comments (in preparation for a code review).
@
text
@d3 3
a5 1
 *  Copyright (C) 1994 Harlequin Ltd.
d8 3
a136 1
require "symbol";
a140 1
require "../utils/map";
a141 1
require "../basis/path";
a151 1
   structure Path : PATH
a153 1
   structure Symbol : SYMBOL
a156 1
   structure NewMap: MAP
a157 1
   sharing type ModuleId.Symbol = Symbol.Symbol
d170 12
a181 13
    fun print_time (MLWorks.Option.SOME (_,t)) =
      MLWorks.Time.Interval.format (MLWorks.Time.interval (t,MLWorks.Time.zero))
      | print_time (MLWorks.Option.NONE) = "<No time>"

    fun print_module (MLWorks.Option.SOME (MODULE(s, m),_)) =
      "module_string = '" ^ s ^ "', id = '" ^ ModuleId.string m ^ "'"
      | print_module (MLWorks.Option.NONE) = "<No module>"

    fun module_id (MODULE (_, m)) = m
    fun module_dir (MODULE (s, _)) = s

    fun sml_name (MODULE (s, m)) =
      Path.mkCanonical (Path.concatPath (s, ModuleId.to_host (m, "sml")))
d189 1
a189 1
	Path.explodePath object_path
d192 5
a196 3
    (* mo_name returns the file name of the mo file, after expanding the
       object path. *)
    fun mo_name error_info (MODULE(s, m)) =
d198 4
d203 6
a208 3
	val component = ModuleId.module_component_to_string m
	fun substitute_object_path_arc "%S" = s
	  | substitute_object_path_arc "%C" = (used_component := true; component)
d210 12
a221 4
	val {root, arcs} = parse_object_path()
	val result = Path.implodePath{root=root,
				      arcs=map substitute_object_path_arc arcs @@
				      [ModuleId.module_unit_to_string(m, "mo")]}
d226 2
a227 2
	      (Info.WARNING, Info.Location.UNKNOWN,
	       "Module " ^ ModuleId.string m ^
a230 3
(*
	val _ = output(std_out, "Produced mo_name '" ^ result ^ "'\n")
*)
d232 1
a232 4
	Path.mkCanonical result
(*
	Path.concatPath (s, ModuleId.to_host (m, "mo"))
*)
d240 2
a241 2
	val explode1 = Path.explodePath p1
	val explode2 = Path.explodePath p2
d244 2
a245 2
	  MLWorks.Option.SOME (Path.implodePath {root = Path.REL, arcs = l})
	|   lists_suffix (_, []) =  MLWorks.Option.NONE
d250 1
a250 1
	    MLWorks.Option.NONE
d252 4
a255 1
	lists_suffix (#arcs explode2, #arcs explode1)
d258 1
a258 1
    (* check_search_path checks whether the path s refers to a file in a
d260 1
a260 1
    fun check_search_path (s, loc) =
d264 1
a264 1
        fun check [] = MLWorks.Option.NONE
d266 2
a267 2
	  case suffix (s, h)
	  of MLWorks.Option.NONE =>
d269 2
a270 3
	  |  MLWorks.Option.SOME i => 
	    MLWorks.Option.SOME
	      (MODULE (h, ModuleId.from_host (i, loc)))
d276 6
a281 3
       searching the source path and expanding the object path as
       appropriate. *)
    fun find_module error_info (module_id, extension, use_object_path) =
d285 2
a286 2
	fun search [] = MLWorks.Option.NONE
	  | search ((dir, filename)::rest) =
d288 2
a289 1
	  (*
a292 1
	  *)
d295 3
a297 1
	      OldOs.EXISTS stamp =>
d299 2
a300 2
		  val real_name = OS.FileSys.fullPath filename
                  (* XXXEXCEPTION: should handle OS.SysErr *)
d302 1
a302 18
		  if use_object_path then
		    MLWorks.Option.SOME
		      (real_name, MODULE(dir, module_id), stamp)
		  else
		    case suffix (real_name, dir) of
		      MLWorks.Option.SOME s =>
		        MLWorks.Option.SOME
			  (real_name,
			   MODULE
			     (dir,
			      ModuleId.from_host (s, Info.Location.UNKNOWN)),
			   stamp)
		    |  MLWorks.Option.NONE =>
		         Info.default_error'
			   (Info.FATAL, Info.Location.UNKNOWN,
			    "Module " ^ ModuleId.string module_id ^
			    " points to " ^ real_name ^
			    ", which lies outside its entry on the source path")
d304 9
a312 2
	    | OldOs.NOT_EXIST =>
	        search rest
a313 12

        val filenames =
	  (if use_object_path then
	     map
	       (fn dir => (dir, mo_name error_info (MODULE(dir, module_id))))
	   else
	     map
	       (fn dir =>
	          (dir,
		   Path.concatPath
		     (dir, ModuleId.to_host(module_id, extension)))))
	       source_path
d315 1
a315 1
        search filenames
d318 2
a319 5
    fun find_sml error_info module_id =
      find_module error_info (module_id, "sml", false)

    fun find_mo error_info module_id =
      find_module error_info (module_id, "mo", true)
d321 38
a358 1
    fun find_pervasive_mo error_info module_id = 
d361 1
a361 6

(*
        val filename =
          Path.concatPath (dir, ModuleId.to_host (module_id, "mo"))
*)
	val filename = mo_name error_info (MODULE(dir, module_id))
d365 1
a365 1
	    MLWorks.Option.SOME(filename, MODULE(dir, module_id), time)
d367 17
a383 1
	    MLWorks.Option.NONE
d385 1
a385 1
      handle Io.NotSet _ => MLWorks.Option.NONE
d390 8
a397 2
    (* find_file takes a file name, checks that the file exists, and
       determines the corresponding (directory, module id) pair. *)
d403 10
a412 6
	  case Path.splitExt filename of
	    {ext = Path.EXT "mo", name} =>
	      Path.addExt {name = name, ext = Path.EXT "sml"} 
	  | {ext = Path.EXT _, ...} => filename
	  | {name, ...} =>
	      Path.addExt {name = name, ext = Path.EXT "sml"}
d415 1
a415 1
	  Path.mkAbsolute
d419 1
a419 1
            Path.Path => raise NoSuchFile filename
d428 2
a429 2
	  of MLWorks.Option.SOME module => (true, module)
	  |  MLWorks.Option.NONE =>
d431 2
a432 2
	     MODULE (Path.dir absolute,
		     ModuleId.from_host (Path.last absolute, loc)))
d446 8
a453 6
          (MLWorks.IO.output
             (MLWorks.IO.std_out,
              "Extending source path with directory "
              ^ dir ^ " while " ^ reason ^ " module `"
              ^ ModuleId.string mod_id  ^ "'\n");
           Io.set_source_path_without_expansion (dir :: old_source_path))
d458 3
a460 1
            exn => (Io.set_source_path_without_expansion old_source_path; raise exn)
@


1.36.7.1
log
@branched from 1.36
@
text
@a5 3
 * Revision 1.36  1996/08/27  12:45:12  daveb
 * Added comments (in preparation for a code review).
 *
@


1.36.6.1
log
@branched from 1.36
@
text
@a5 3
 * Revision 1.36  1996/08/27  12:45:12  daveb
 * Added comments (in preparation for a code review).
 *
@


1.36.6.1.1.1
log
@branched from 1.36.6.1
@
text
@a5 3
 * Revision 1.36.6.1  1996/12/17  17:41:04  hope
 * branched from 1.36
 *
@


1.36.5.1
log
@branched from 1.36
@
text
@a5 3
 * Revision 1.36  1996/08/27  12:45:12  daveb
 * Added comments (in preparation for a code review).
 *
@


1.36.4.1
log
@branched from 1.36
@
text
@a5 3
 * Revision 1.36  1996/08/27  12:45:12  daveb
 * Added comments (in preparation for a code review).
 *
@


1.36.4.1.1.1
log
@branched from 1.36.4.1
@
text
@a5 3
 * Revision 1.36.4.1  1996/11/14  12:41:42  hope
 * branched from 1.36
 *
@


1.36.3.1
log
@branched from 1.36
@
text
@a5 3
 * Revision 1.36  1996/08/27  12:45:12  daveb
 * Added comments (in preparation for a code review).
 *
@


1.36.2.1
log
@branched from 1.36
@
text
@a5 3
 * Revision 1.36  1996/08/27  12:45:12  daveb
 * Added comments (in preparation for a code review).
 *
@


1.36.1.1
log
@branched from 1.36
@
text
@a5 3
 * Revision 1.36  1996/08/27  12:45:12  daveb
 * Added comments (in preparation for a code review).
 *
@


1.35
log
@[Bug #982]
Made find_file convert .mo into .sml.
@
text
@d6 4
d142 5
d186 2
d195 2
d227 3
d247 2
d265 3
d352 2
d387 3
@


1.34
log
@Remove a (debugging) line that somehow got left behind when I last
checked this file in.
@
text
@d6 4
d337 3
a339 1
	    {ext = Path.EXT _, ...} => filename
d341 1
a341 1
	    Path.addExt {name = name, ext = Path.EXT "sml"}
@


1.33
log
@The Io exception is no longer at top level.
@
text
@d6 3
a343 2
          | MLWorks.IO.Io _ => raise NoSuchFile filename (* XXX: support SML/NJ *)
          | exn => (MLWorks.IO.output (MLWorks.IO.std_out, "XXXX\n"); raise exn)
@


1.32
log
@Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
now does what the former used to do.
@
text
@d6 4
d341 1
a341 1
          | Io _ => raise NoSuchFile filename (* XXX: support SML/NJ *)
@


1.31
log
@Change to pull in Path directly rather than OS.Path since the latter
now conforms to the latest basis and it is too much effort to update
the code to OS.Path at this point.
@
text
@d6 5
d252 1
a252 1
		  val real_name = OS.FileSys.realPath filename
d332 1
a332 1
	    (OS.FileSys.realPath (Getenv.expand_home_dir extended),
@


1.30
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d6 6
d119 1
d125 1
d159 1
a159 1
      OS.Path.mkCanonical (OS.Path.concatPath (s, ModuleId.to_host (m, "sml")))
d165 1
a165 1
	OS.Path.explodePath object_path
d176 1
a176 1
	val result = OS.Path.implodePath{root=root,
d192 1
a192 1
	OS.Path.mkCanonical result
d194 1
a194 1
	OS.Path.concatPath (s, ModuleId.to_host (m, "mo"))
d200 2
a201 2
	val explode1 = OS.Path.explodePath p1
	val explode2 = OS.Path.explodePath p2
d204 1
a204 1
	  MLWorks.Option.SOME (OS.Path.implodePath {root = OS.Path.REL, arcs = l})
d281 1
a281 1
		   OS.Path.concatPath
d300 1
a300 1
          OS.Path.concatPath (dir, ModuleId.to_host (module_id, "mo"))
d320 2
a321 2
	  case OS.Path.splitExt filename of
	    {ext = OS.Path.EXT _, ...} => filename
d323 1
a323 1
	    OS.Path.addExt {name = name, ext = OS.Path.EXT "sml"}
d326 1
a326 1
	  OS.Path.mkAbsolute
d330 1
a330 1
            OS.Path.Path => raise NoSuchFile filename
d344 2
a345 2
	     MODULE (OS.Path.dir absolute,
		     ModuleId.from_host (OS.Path.last absolute, loc)))
@


1.29
log
@initbasis moves to basis
@
text
@d6 3
d325 1
a325 1
          | exn => (output (std_out, "XXXX\n"); raise exn)
d348 2
a349 2
          (output
             (std_out,
@


1.28
log
@Update wrt Os -> OS name change.
@
text
@d6 3
d109 1
a109 1
require "../initbasis/os";
@


1.27
log
@Modify to use set_source_path_without_expansion when extending
and retracting source_path
@
text
@d6 4
d111 1
a111 1
   structure Os : OS
d145 1
a145 1
      Os.Path.mkCanonical (Os.Path.concatPath (s, ModuleId.to_host (m, "sml")))
d151 1
a151 1
	Os.Path.explodePath object_path
d162 1
a162 1
	val result = Os.Path.implodePath{root=root,
d178 1
a178 1
	Os.Path.mkCanonical result
d180 1
a180 1
	Os.Path.concatPath (s, ModuleId.to_host (m, "mo"))
d186 2
a187 2
	val explode1 = Os.Path.explodePath p1
	val explode2 = Os.Path.explodePath p2
d190 1
a190 1
	  MLWorks.Option.SOME (Os.Path.implodePath {root = Os.Path.REL, arcs = l})
d233 2
a234 1
		  val real_name = Os.FileSys.realPath filename
d267 1
a267 1
		   Os.Path.concatPath
d286 1
a286 1
          Os.Path.concatPath (dir, ModuleId.to_host (module_id, "mo"))
d306 2
a307 2
	  case Os.Path.splitExt filename of
	    {ext = Os.Path.EXT _, ...} => filename
d309 1
a309 1
	    Os.Path.addExt {name = name, ext = Os.Path.EXT "sml"}
d312 3
a314 3
	  Os.Path.mkAbsolute
	    (Os.FileSys.realPath (Getenv.expand_home_dir extended),
	     Os.FileSys.getDir ())
d316 2
a317 2
            Os.Path.Path => raise NoSuchFile filename
          | Os.SysErr _ => raise NoSuchFile filename
d319 1
d330 2
a331 2
	     MODULE (Os.Path.dir absolute,
		     ModuleId.from_host (Os.Path.last absolute, loc)))
@


1.26
log
@find_file: add handlers for Os.Path.Path, OS.SysErr and Io.
@
text
@d6 3
d341 1
a341 1
           Io.set_source_path (dir :: old_source_path))
d346 1
a346 1
            exn => (Io.set_source_path old_source_path; raise exn)
d348 1
a348 1
        Io.set_source_path old_source_path;
@


1.25
log
@Updated to use new basis compatible OS.  In the process renameOS -> OLD_OS,
and Os -> OldOs.
@
text
@d6 4
d307 5
@


1.24
log
@Revised with_source_path; removed call to find_file.  This is now done in
Incremental.match_source_path.
@
text
@d6 4
d92 1
a92 1
require "../make/os";
d95 1
a95 2
require "../initbasis/path";
require "../initbasis/filesys";
d100 1
a100 2
   structure Path : PATH
   structure FileSys : FILE_SYS
d104 1
a104 1
   structure Os: OS
d134 1
a134 1
      Path.mkCanonical (Path.concatPath (s, ModuleId.to_host (m, "sml")))
d140 1
a140 1
	Path.explodePath object_path
d151 1
a151 1
	val result = Path.implodePath{root=root,
d167 1
a167 1
	Path.mkCanonical result
d169 1
a169 1
	Path.concatPath (s, ModuleId.to_host (m, "mo"))
d175 2
a176 2
	val explode1 = Path.explodePath p1
	val explode2 = Path.explodePath p2
d179 1
a179 1
	  MLWorks.Option.SOME (Path.implodePath {root = Path.REL, arcs = l})
d219 2
a220 2
	    case Os.mtime filename of
	      Os.EXISTS stamp =>
d222 1
a222 1
		  val real_name = FileSys.realPath filename
d243 1
a243 1
	    | Os.NOT_EXIST =>
d255 1
a255 1
		   Path.concatPath
d274 1
a274 1
          Path.concatPath (dir, ModuleId.to_host (module_id, "mo"))
d278 2
a279 2
        case Os.mtime filename of
          Os.EXISTS time =>
d281 1
a281 1
	| Os.NOT_EXIST =>
d294 2
a295 2
	  case Path.splitExt filename of
	    {ext = Path.EXT _, ...} => filename
d297 1
a297 1
	    Path.addExt {name = name, ext = Path.EXT "sml"}
d300 3
a302 3
	  Path.mkAbsolute
	    (FileSys.realPath (Getenv.expand_home_dir extended),
	     FileSys.getDir ())
d304 2
a305 2
	case Os.mtime absolute
	of Os.NOT_EXIST =>
d307 1
a307 1
	|  Os.EXISTS _ =>
d312 2
a313 2
	     MODULE (Path.dir absolute,
		     ModuleId.from_host (Path.last absolute, loc)))
@


1.23
log
@Module.mo_name now takes an Info.options argument.
@
text
@d6 3
d132 1
a132 1
      Path.concatPath (s, ModuleId.to_host (m, "sml"))
d165 1
a165 1
	result
d285 1
d314 1
a314 1
    fun with_source_path (f, location, filename, reason) =
d317 4
a320 11
  
        val (on_path, module) =
          find_file (filename, location)
          handle
            NoSuchFile s =>
              Info.default_error'
                (Info.FATAL, location, "No such file: `" ^ s ^ "'")
          | Getenv.BadHomeName s =>
              Info.default_error'
                (Info.FATAL, location, "Invalid home name: " ^ s)
  
d322 7
a328 10
  	  if not on_path then
            (output
               (std_out,
                "Extending source path with directory " ^ module_dir module
                ^ " while " ^ reason ^ " module "
                ^ ModuleId.string (module_id module) ^ "\n");
            Io.set_source_path (module_dir module :: old_source_path))
          else
            ();
  
d330 3
a332 4
	  f (module_id module)
          handle x =>
            (Io.set_source_path old_source_path;
             raise x)
@


1.22
log
@Fixed use of Info.default_options.
@
text
@d6 3
d109 1
d138 1
a138 2
    (* mo_name should take an error_info argument *)
    fun mo_name(MODULE(s, m)) =
d152 4
a155 4
	    (Info.make_default_options ())
	    (Info.WARNING, Info.Location.UNKNOWN,
	     "Module " ^ ModuleId.string m ^
	     " has non-trivial prefix ignored by object path ")
d201 1
a201 1
    fun find_module (module_id, extension, use_object_path) =
d245 1
a245 1
	       (fn dir => (dir, mo_name(MODULE(dir, module_id))))
d257 2
a258 1
    fun find_sml module_id = find_module (module_id, "sml", false)
d260 2
a261 1
    fun find_mo module_id = find_module (module_id, "mo", true)
d263 1
a263 1
    fun find_pervasive_mo module_id = 
d271 1
a271 1
	val filename = mo_name(MODULE(dir, module_id))
@


1.21
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d6 3
d134 1
d149 1
a149 1
	    Info.default_options
d229 1
a229 2
		         Info.error'
			   Info.default_options
d313 1
a313 2
              Info.error'
                (Info.make_default_options ())
d316 1
a316 2
              Info.error'
                Info.default_options
@


1.20
log
@Added message parameter to with_source_path.
@
text
@d6 3
d81 1
a81 1
require "../utils/newmap";
d96 1
a96 1
   structure NewMap: NEWMAP
@


1.19
log
@Removed caches.
@
text
@d6 3
d299 1
a299 1
    fun with_source_path (f, location, filename) =
d319 3
a321 5
                "Extending source path with directory "
                ^ module_dir module
                ^ " for compilation of module "
                ^ ModuleId.string (module_id module)
                ^ "\n");
@


1.18
log
@new module naming stuff
@
text
@d6 3
a103 10
    datatype Cache =
      CACHE of
	(ModuleId, (string * Module * MLWorks.Time.time) MLWorks.Option.option) NewMap.T

    val empty_cache = CACHE (NewMap.empty (ModuleId.lt,ModuleId.eq))
    val last_cache = ref empty_cache

    fun cache_size(CACHE cache) = NewMap.size cache
    fun cache_list(CACHE cache) = NewMap.domain_ordered cache

a111 8
    fun update_cache (CACHE c, module_id, value) = 
      ( (* diagnostic
       (2,
        fn _ => ["Updating ", ModuleId.string module_id,
                 " to ", print_time(MLWorks.Option.SOME value),
		 " with name ", print_module(MLWorks.Option.SOME value)]); *)
       CACHE (NewMap.define (c, module_id, MLWorks.Option.SOME value)))

d188 6
a193 9
    fun find_module (module_id, extension, c as CACHE cache, use_object_path) =
      case NewMap.tryApply' (cache, module_id) of
	MLWorks.Option.SOME x =>
	  ( (* diagnostic
	   (2, fn _ => ["found ", ModuleId.string module_id,
			extension, " in cache, time: ",
                        print_time x, " with name ", print_module x]); *)
	   (x, c))
      | MLWorks.Option.NONE =>
d195 8
a202 4
	    val source_path = Io.get_source_path ()

	    fun search [] = MLWorks.Option.NONE
	      | search ((dir, filename)::rest) =
d204 1
a204 5
		(*
		  val _ =
		    diagnostic
		    (2, fn _ => ["searching: ", filename])
		  *)
d206 19
a224 25
		  case Os.mtime filename of
		    Os.EXISTS stamp =>
		      let
			val real_name = FileSys.realPath filename
		      in
			if use_object_path then
			  MLWorks.Option.SOME(real_name, MODULE(dir, module_id), stamp)
			else
			  case suffix (real_name, dir) of
			    MLWorks.Option.SOME s =>
			      MLWorks.Option.SOME
			      (real_name, MODULE
			       (dir,
				ModuleId.from_host (s, Info.Location.UNKNOWN)),
			       stamp)
			  |  MLWorks.Option.NONE =>
			       Info.error'
			       Info.default_options
			       (Info.FATAL, Info.Location.UNKNOWN,
				"Module " ^ ModuleId.string module_id ^
				" points to " ^ real_name ^
				", which lies outside its entry on the source path")
		      end
		  | Os.NOT_EXIST =>
		      search rest
d226 3
d230 14
a243 19
	    val filenames =
	      (if use_object_path then
		 map
		 (fn dir => (dir, mo_name(MODULE(dir, module_id))))
	       else
		 map
		 (fn dir =>
		  (dir, Path.concatPath(dir, ModuleId.to_host(module_id, extension)))))
		 source_path

	    val result = search filenames

	    (*
            val _ = 
              (diagnostic
               (2, fn _ => ["Adding ", ModuleId.string module_id,
                            " to ", extension, " cache, time: ",
                            print_time result]))
	    *)
d245 1
a245 4
	    val new_cache = CACHE (NewMap.define (cache, module_id, result))
	  in
	    (result, new_cache)
	  end
d247 1
a247 1
    fun find_sml (module_id, cache) = find_module (module_id, "sml", cache, false)
d249 3
a251 8
    fun find_mo (module_id, cache) = find_module (module_id, "mo", cache, true)

    fun find_pervasive_mo(module_id, c as CACHE cache) =
      case NewMap.tryApply'(cache, module_id) of
	MLWorks.Option.SOME x => (x, c)
      | _ =>
	  let
	    val dir = Io.get_pervasive_dir()
d254 2
a255 2
	    val filename =
	      Path.concatPath (dir, ModuleId.to_host (module_id, "mo"))
d257 9
a265 13
	    val filename = mo_name(MODULE(dir, module_id))
	  in
	    case Os.mtime filename of
	      Os.EXISTS time =>
		let
		  val info = MLWorks.Option.SOME(filename, MODULE(dir, module_id), time)
		in
		  (info, CACHE(NewMap.define(cache, module_id, info)))
		end
	    | Os.NOT_EXIST =>
		(MLWorks.Option.NONE, c)
	  end
	handle Io.NotSet _ => (MLWorks.Option.NONE, c)
@


1.17
log
@FileSys.get_dir renamed FileSys.getDir.
Expansion of home directories moved to Getenv.
path and filesys moved from utils to initbasis.
with_source_path takes a location argument.
@
text
@d6 6
d103 1
a103 1
	(ModuleId, (Module * MLWorks.Time.time) MLWorks.Option.option) NewMap.T
a169 3
    fun relative_mo (path, module_id) =
      mo_name (MODULE (path, module_id))

d229 17
a245 14
			case suffix (real_name, dir)
			  of MLWorks.Option.SOME s =>
			    MLWorks.Option.SOME
			    (MODULE
			     (dir,
			      ModuleId.from_host (s, Info.Location.UNKNOWN)),
			     stamp)
			|  MLWorks.Option.NONE =>
			     Info.error'
			     Info.default_options
			     (Info.FATAL, Info.Location.UNKNOWN,
			      "Module " ^ ModuleId.string module_id ^
			      " points to " ^ real_name ^
			      ", which lies outside its entry on the source path")
d287 1
d290 2
d296 1
a296 1
		  val info = MLWorks.Option.SOME(MODULE(dir, module_id), time)
@


1.16
log
@Modifications to allow object paths
@
text
@d6 3
d67 3
a69 2
require "../utils/path";
require "../utils/filesys";
d75 1
d195 1
a195 4
	      (MODULE (h,
		       ModuleId.from_host
		         (i (* String.substring (s, i, size s - i) *),
		          Info.Location.UNKNOWN)))
d224 1
a224 1
			val real_name = FileSys.expand_path filename
d310 2
a311 1
	    (FileSys.expand_path extended, FileSys.getdir ())
d325 1
a325 1
    fun with_source_path (f, filename) =
d330 1
a330 1
          find_file (filename, Info.Location.UNKNOWN)
d334 6
a339 2
              (Info.make_default_options ())
              (Info.FATAL, Info.Location.UNKNOWN, "No such file: `" ^ s ^ "'")
@


1.15
log
@Change FILESYS to FILE_SYS
@
text
@d6 3
d104 4
d112 2
a113 1
                 " to ", print_time (MLWorks.Option.SOME value)]); *)
d122 36
a157 2
    fun mo_name (MODULE (s, m)) =
      Path.concatPath (s, ModuleId.to_host (m, "mo"))
d198 1
a198 1
    fun find_module (module_id, extension, c as CACHE cache) =
d204 1
a204 1
                        print_time x]); *)
d208 1
a208 1
	    val module_name = ModuleId.to_host (module_id, extension)
d211 1
a211 1
	      | search (dir::rest) = 
d213 1
a213 3
		  val filename =
		    Path.concatPath (dir, module_name)
		  (*
d224 6
a229 6
	  		case suffix (real_name, dir)
			of MLWorks.Option.SOME s =>
			  MLWorks.Option.SOME
	         	    (MODULE
			       (dir,
		          	ModuleId.from_host (s, Info.Location.UNKNOWN)),
d231 7
a237 7
	  		|  MLWorks.Option.NONE =>
			  Info.error'
			  Info.default_options
			  (Info.FATAL, Info.Location.UNKNOWN,
			   "Module " ^ ModuleId.string module_id ^
			   " points to " ^ real_name ^
			   ", which lies outside its entry on the source path")
d240 1
a240 1
		    search rest
d243 11
a253 1
	    val result = search (Io.get_source_path ())
d268 1
a268 1
    fun find_sml (module_id, cache) = find_module (module_id, "sml", cache)
d270 1
a270 1
    fun find_mo (module_id, cache) = find_module (module_id, "mo", cache)
@


1.14
log
@New path syntax simplifies implementation of suffix function.
@
text
@d6 3
d67 1
a67 1
   structure FileSys : FILESYS
@


1.13
log
@Fixed bug in my new suffix function.
@
text
@d6 3
d122 4
a125 7
	val last2 = #last explode2

	fun lists_suffix ([], l, last) = 
	  MLWorks.Option.SOME
	    (Path.implodePath {root = Path.REL, arcs = l, last = last})
	|   lists_suffix (_, [], _) =  MLWorks.Option.NONE
	|   lists_suffix (h1::t1, h2::t2, last) =
d127 1
a127 1
	    lists_suffix (t1, t2, last)
d131 1
a131 2
	lists_suffix (#arcs explode2 @@ (if last2 = "" then [] else [last2]),
		      #arcs explode1, #last explode1)
d248 1
a248 1
	  case Path.splitPath filename of
d250 2
a251 2
	  | {dir, name, ...} =>
	    Path.makePath {dir = dir, name = name, ext = Path.EXT "sml"}
@


1.12
log
@The Path signature no longer provides a suffix function.
@
text
@d6 3
a120 11
	fun tails_suffix ([], l, last) = 
	  MLWorks.Option.SOME
	    (Path.implodePath {root = Path.REL, arcs = l, last = last})
	|   tails_suffix (_, [], _) =  MLWorks.Option.NONE
	|   tails_suffix (h1::t1, l2 as h2::t2, last) =
	  if h1 = h2 then
	    tails_suffix (t1, t2, last)
	  else
	    MLWorks.Option.SOME
	      (Path.implodePath {root = Path.REL, arcs = l2, last = last})

d127 1
a127 1
	    tails_suffix (t1, t2, last)
@


1.11
log
@Replaced a call to check_search_path with Path.suffix of the current
entry on the source path.
@
text
@d6 4
d93 1
a93 1
      ((* diagnostic
d111 32
d149 1
a149 1
	  case Path.suffix (s, h)
d156 1
a156 1
		         (String.substring (s, i, size s - i),
d165 1
a165 1
	  ((* diagnostic
d179 1
a179 1
(*
d183 1
a183 1
*)
d190 2
a191 2
			case Path.suffix (real_name, dir)
			of MLWorks.Option.SOME i =>
d193 1
a193 1
			    (MODULE
d195 1
a195 4
			        ModuleId.from_host
			          (String.substring
			             (real_name, i, size real_name - i),
			           Info.Location.UNKNOWN)),
d197 7
a203 6
			|  MLWorks.Option.NONE =>
			     Info.error'
			     Info.default_options
			     (Info.FATAL, Info.Location.UNKNOWN,
			      "Module " ^ ModuleId.string module_id ^
			      " points outside the source tree")
d211 1
a211 1
(*
d215 1
a215 1
                            extension, " in cache, time: ",
d217 1
a217 1
*)
@


1.10
log
@Added a diagnostic when extending the source path.
@
text
@d6 3
d154 10
a163 3
			case check_search_path (real_name, Info.Location.UNKNOWN) of
			  MLWorks.Option.SOME m =>
			    MLWorks.Option.SOME (m, stamp)
@


1.9
log
@Replaced the FileName structure with the new Path structure.
Replaced the Option structure with references to MLWorks.Option.
@
text
@d6 4
d248 8
a255 1
            Io.set_source_path (module_dir module :: old_source_path)
@


1.8
log
@Parameterise pathname separator on FileName
@
text
@d6 3
d41 2
a42 1
require "../utils/filename";
d46 2
a47 1
   structure FileName : FILENAME
a54 1
   sharing type Io.Directory = string
a57 3
    structure Option = FileName.Option

    type Directory = Io.Directory
d65 1
a65 3
    datatype Module = MODULE of Directory * ModuleId

    fun dir_string x = x
d68 2
a69 1
      CACHE of (ModuleId, (Module * MLWorks.Time.time) Option.opt) NewMap.T
d77 1
a77 1
    fun print_time (Option.PRESENT (_,t)) =
d79 1
a79 1
      | print_time (Option.ABSENT) = "<Notime>"
d85 2
a86 2
                 " to ", print_time (Option.PRESENT value)]); *)
       CACHE (NewMap.define (c, module_id, Option.PRESENT value)))
d91 2
a92 3
    fun to_unix module_id =
      implode (map (fn "." => FileName.separator | x => x)
		   (explode (ModuleId.string module_id)))
d94 2
a95 2
    fun sml_name (MODULE (l, m)) = l ^ to_unix m ^ ".sml"
    fun mo_name (MODULE (l, m)) = l ^ to_unix m ^ ".mo"
a99 9
    local
      fun insert ([], _) = []
      |   insert ([x], _) = [x]
      |   insert (x::l, c) = x :: c :: insert (l, c)
    in
      fun module_string (ModuleId.MODID (s, l)) =
        implode (insert (map Symbol.symbol_name (rev (s :: l)), FileName.separator))
    end

d102 1
a102 16
	 val path = Io.get_source_path ()

        fun module_name n =
          if MLWorks.String.substring (s, n, 1) = FileName.separator then
            module_name (n + 1)
          else
	    MODULE
	      (MLWorks.String.substring (s, 0, n),
	       ModuleId.from_string
		 (MLWorks.String.substring (s, n, size s - n), loc))

        fun prefix (s, s') =
          let val len = size s
          in
            size s' > len andalso s = MLWorks.String.substring (s', 0, len)
          end
d104 1
a104 1
        fun check [] = Option.ABSENT
d106 9
a114 4
          if prefix (h, s) then
            Option.PRESENT (module_name (size h))
          else 
            check t
a118 5
    fun dir_slash s =
      if String.ordof (s, size s-1) = ord FileName.separator
        then s
      else s ^ FileName.separator

d129 3
a131 2
	    val module_name = to_unix module_id
	    fun search [] = Option.ABSENT
d134 2
a135 1
		  val filename = dir_slash dir ^ module_name ^ extension
d145 1
a145 1
			val real_name = FileName.realpath filename
d148 3
a150 3
			  Option.PRESENT m =>
			    Option.PRESENT (m, stamp)
			|  Option.ABSENT =>
d154 1
a154 1
			      "Module " ^ module_name ^
d176 1
a176 1
    fun find_sml (module_id, cache) = find_module (module_id, ".sml", cache)
d178 1
a178 1
    fun find_mo (module_id, cache) = find_module (module_id, ".mo", cache)
a184 1
	    val unix_name = to_unix module_id ^ ".mo"
d186 3
a188 1
	    val filename = dir_slash dir ^ unix_name	      
d193 1
a193 1
		  val info = Option.PRESENT(MODULE(dir, module_id), time)
d198 1
a198 1
		(Option.ABSENT, c)
d200 1
a200 1
	handle Io.NotSet _ => (Option.ABSENT, c)
d208 9
a216 9
        val absolute = FileName.parse_absolute filename

	val sml_abs =
	  case absolute
	  of FileName.ABSOLUTE (d, m, FileName.Option.ABSENT) =>
	    FileName.ABSOLUTE (d, m, FileName.Option.PRESENT "sml")
	  |  _ => absolute
	
	val sml_name = FileName.absolute_name sml_abs
d218 1
a218 1
	case Os.mtime sml_name
d220 1
a220 1
	  raise NoSuchFile sml_name
d222 6
a227 16
          case check_search_path (sml_name, loc)
	  of Option.PRESENT module => (true, module)
	  |  Option.ABSENT =>
	    let
	      fun find 0 = ("", sml_name)
              |   find n =
                if String.ordof (sml_name, n-1) = ord FileName.separator then
                  (String.substring (sml_name, 0, n),
                   String.substring (sml_name, n, size sml_name - n))
                else
                  find (n-1)
    
	      val (dir, file) = find (size sml_name)
	    in
	      (false, MODULE (dir, ModuleId.from_string (file, loc)))
	    end
@


1.7
log
@Move OS specific stuff into a system link directory
@
text
@d6 3
d92 1
a92 1
      implode (map (fn "." => "/" | x => x)
d107 1
a107 1
        implode (insert (map Symbol.symbol_name (rev (s :: l)), "/"))
d115 1
a115 1
          if MLWorks.String.substring (s, n, 1) = "/" then
d140 1
a140 1
      if String.ordof (s, size s-1) = ord "/"
d142 1
a142 1
      else s ^ "/"
d168 1
a168 1
			val real_name = MLWorks.OS.Unix.realpath filename
d250 1
a250 1
                if String.ordof (sml_name, n-1) = ord "/" then
@


1.6
log
@Use pervasive Option.option for return values in NewMap
@
text
@d6 19
a24 16
# Revision 1.5  1994/10/06  10:28:29  matthew
# Better caching and other improvements
#
# Revision 1.4  1994/03/25  16:16:49  daveb
# Added with_source_path.
#
# Revision 1.3  1994/03/22  16:15:12  daveb
# Canonicalised module names.
#
# Revision 1.2  1994/02/08  15:59:53  daveb
# module_and_path is now called find_file, and is functional.
# check_search_path returns an option instead of raising an exception.
#
# Revision 1.1  1994/02/02  13:39:30  johnk
# new file
#
d32 1
a32 1
require "../make/unix";
d42 1
a42 1
   structure Unix: UNIX
d162 4
a165 3
		  case Unix.mtime filename of
		    Unix.EXISTS stamp =>
		      let val real_name = MLWorks.OS.Unix.realpath filename
d167 3
a169 3
			case check_search_path (real_name, Info.Location.UNKNOWN)
			of Option.PRESENT m =>
			  Option.PRESENT (m, stamp)
d171 5
a175 5
			  Info.error'
			    Info.default_options
			    (Info.FATAL, Info.Location.UNKNOWN,
			     "Module " ^ module_name ^
			     " points outside the source tree")
d177 1
a177 1
		  | Unix.NOT_EXIST =>
d209 2
a210 2
	    case Unix.mtime filename of
	      Unix.EXISTS time =>
d216 1
a216 1
	    | Unix.NOT_EXIST =>
d237 2
a238 2
	case Unix.mtime sml_name
	of Unix.NOT_EXIST =>
d240 1
a240 1
	|  Unix.EXISTS _ =>
@


1.5
log
@Better caching and other improvements
@
text
@d6 3
d140 1
a140 1
	NewMap.YES x =>
d146 1
a146 1
      | NewMap.NO =>
d198 1
a198 1
	NewMap.YES x => (x, c)
@


1.4
log
@Added with_source_path.
@
text
@d6 3
d53 1
a53 1
        (fn verbosity => "FileName " :: (output_function verbosity))
d62 1
a62 1
    val empty_cache = CACHE (NewMap.empty' ModuleId.lt)
d67 5
d73 5
a77 1
      CACHE (NewMap.define (c, module_id, Option.PRESENT value))
d130 5
d138 4
a141 3
	  (diagnostic
	   (3, fn _ => ["found ", ModuleId.string module_id,
			extension, " in cache"]);
d149 2
a150 1
		  val filename = dir ^ "/" ^ module_name ^ extension
d154 1
d176 8
d200 1
a200 1
	    val filename = dir ^ "/" ^ unix_name	      
@


1.3
log
@Canonicalised module names.
@
text
@d6 3
d223 29
@


1.2
log
@module_and_path is now called find_file, and is functional.
check_search_path returns an option instead of raising an exception.
@
text
@d6 4
d19 1
d31 1
d34 1
d86 30
a115 1
    fun find_file (module_id, extension, c as CACHE cache) =
d124 1
a124 1
	    val unix_name = to_unix module_id ^ extension
d128 1
d131 1
a131 2
		    (2, fn _ => ["searching: ", dir, "/", unix_name])
		  val filename = dir ^ "/" ^ unix_name
d135 12
a146 1
		      Option.PRESENT (MODULE (dir, module_id), stamp)
d148 1
a148 1
		      search rest
d158 1
a158 1
    fun find_sml (module_id, cache) = find_file (module_id, ".sml", cache)
d160 1
a160 1
    fun find_mo (module_id, cache) = find_file (module_id, ".mo", cache)
a181 31

    exception NotOnSearchPath

    fun check_search_path (s, loc) =
      let
	 val path = Io.get_source_path ()

        fun module_name n =
          if MLWorks.String.substring (s, n, 1) = "/" then
            module_name (n + 1)
          else
	    MODULE
	      (MLWorks.String.substring (s, 0, n),
	       ModuleId.from_string
		 (MLWorks.String.substring (s, n, size s - n), loc))

        fun prefix (s, s') =
          let val len = size s
          in
            size s' > len andalso s = MLWorks.String.substring (s', 0, len)
          end

        fun check [] = Option.ABSENT
        |   check (h::t) =
          if prefix (h, s) then
            Option.PRESENT (module_name (size h))
          else 
            check t
      in 
        check path
      end
@


1.1
log
@new file
@
text
@d5 4
a8 1
 *  $Log$
d140 1
a140 3
	 val path =
	   Io.get_source_path ()
	   handle Io.NotSet _ => []
d157 1
a157 1
        fun check [] = raise NotOnSearchPath
d160 1
a160 1
            module_name (size h)
d169 1
a169 1
    fun module_and_path (s, loc) =
d173 1
a173 1
        val absolute = FileName.parse_absolute s
d187 11
a197 16
	  let
            val old_source_path =
              Io.get_source_path ()
              handle Io.NotSet _ => []

            val module =
              check_search_path (sml_name, loc)
              handle NotOnSearchPath =>
	        let
	          fun find 0 = ("", sml_name)
                  |   find n =
                    if String.ordof (sml_name, n-1) = ord "/" then
                      (String.substring (sml_name, 0, n),
                       String.substring (sml_name, n, size sml_name - n))
                    else
                      find (n-1)
d199 4
a202 8
	          val (dir, file) = find (size sml_name)
	        in
	          Io.set_source_path (dir :: old_source_path);
	          MODULE (dir, ModuleId.from_string (file, loc))
	        end
          in
            (module, old_source_path)
          end
@
