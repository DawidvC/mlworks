head	1.41;
access;
symbols
	MLW_daveb_inline_1_4_99:1.41.3
	MLWorks_21c0_1999_03_25:1.41
	MLWorks_20c1_1998_08_20:1.41
	MLWorks_20c0_1998_08_04:1.41
	MLWorks_20b2c2_1998_06_19:1.41
	MLWorks_20b2_Windows_1998_06_12:1.41
	MLWorks_20b1c1_1998_05_07:1.41
	MLWorks_20b0_1998_04_07:1.41
	MLWorks_20b0_1998_03_20:1.41
	MLWorks_20m2_1998_02_16:1.41
	MLWorks_20m1_1997_10_23:1.41
	MLWorks_11r1:1.40.5.1.1.1.1
	MLWorks_workspace_97:1.41.2
	MLWorks_dt_wizard:1.41.1
	MLWorks_11c0_1997_09_09:1.40.5.1.1.1
	MLWorks_10r3:1.40.5.1.3
	MLWorks_10r2_551:1.40.5.1.2
	MLWorks_11:1.40.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.40.5.1
	MLWorks_20m0_1997_06_20:1.41
	MLWorks_1_0_r2c2_1997_06_14:1.40.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.40.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.40.5
	MLWorks_BugFix_1997_04_24:1.40
	MLWorks_1_0_r2_Win32_1997_04_11:1.40
	MLWorks_1_0_r2_Unix_1997_04_04:1.40
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.40.3.1.1
	MLWorks_gui_1996_12_18:1.40.4
	MLWorks_1_0_Win32_1996_12_17:1.40.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.40.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.40.1.1
	MLWorks_1_0_Irix_1996_11_28:1.40.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.40.2
	MLWorks_1_0_Unix_1996_11_14:1.40.1
	MLWorks_Open_Beta2_1996_10_11:1.38.1
	MLWorks_License_dev:1.37.1
	MLWorks_1_open_beta_1996_09_13:1.36.1
	MLWorks_Open_Beta_1996_08_22:1.36
	MLWorks_Beta_1996_07_02:1.35
	MLWorks_Beta_1996_06_07:1.35
	MLWorks_Beta_1996_06_06:1.35
	MLWorks_Beta_1996_06_05:1.35
	MLWorks_Beta_1996_06_03:1.35
	MLWorks_Beta_1996_05_31:1.35
	MLWorks_Beta_1996_05_30:1.35
	ML_beta_release_12/08/94:1.29
	ML_beta_release_03/08/94:1.29
	ML_revised_beta_release_25/05/94:1.29
	ML_final_beta_release_02/03/94:1.29
	mlworks-28-01-1994:1.28
	Release:1.25
	mlworks-beta-01-09-1993:1.25
	MLWorks-1-0-4-29/01/1993:1.19
	MLWorks-1-0-3-21/12/1992:1.19
	MLWorks-1-0-2-15/12/1992:1.19
	MLWorks-1-0-1-04/12/1992:1.17
	checkpoint_17_08_92:1.12
	Ten15_release_19-11-91:1.3
	Ten15_release_21-08-91:1.3
	Ten15_release_19-08-91:1.3
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.41
date	97.05.01.13.08.01;	author jont;	state Exp;
branches
	1.41.1.1
	1.41.2.1
	1.41.3.1;
next	1.40;

1.40
date	96.11.06.10.51.11;	author matthew;	state Exp;
branches
	1.40.1.1
	1.40.2.1
	1.40.3.1
	1.40.4.1
	1.40.5.1;
next	1.39;

1.39
date	96.10.28.17.27.31;	author andreww;	state Exp;
branches;
next	1.38;

1.38
date	96.09.25.17.35.56;	author andreww;	state Exp;
branches
	1.38.1.1;
next	1.37;

1.37
date	96.09.16.13.53.07;	author andreww;	state Exp;
branches
	1.37.1.1;
next	1.36;

1.36
date	96.08.05.17.52.55;	author andreww;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	96.04.29.15.12.46;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	96.03.25.10.59.30;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	95.12.27.11.59.30;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	95.09.05.14.20.08;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	95.08.31.15.20.17;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	94.09.14.12.40.21;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	94.02.21.16.58.42;	author nosa;	state Exp;
branches;
next	1.28;

1.28
date	93.12.03.16.37.04;	author nickh;	state Exp;
branches;
next	1.27;

1.27
date	93.11.25.09.32.03;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.08.12.11.45.39;	author nosa;	state Exp;
branches;
next	1.25;

1.25
date	93.08.06.14.34.06;	author matthew;	state Exp;
branches
	1.25.1.1;
next	1.24;

1.24
date	93.07.12.08.59.27;	author nosa;	state Exp;
branches;
next	1.23;

1.23
date	93.05.18.13.31.22;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	93.04.06.11.53.33;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.03.09.12.55.07;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.02.22.11.36.02;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	92.12.09.10.06.28;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.12.08.18.29.39;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.11.26.13.24.33;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	92.10.09.15.02.53;	author clive;	state Exp;
branches;
next	1.15;

1.15
date	92.09.17.11.20.01;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	92.09.08.18.08.05;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.09.04.08.56.42;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.08.12.11.52.49;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.08.04.12.08.38;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.06.29.11.11.12;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.06.15.09.31.49;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.06.11.10.28.04;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.05.19.14.00.45;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.04.13.16.21.43;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.02.14.14.02.00;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.11.19.19.24.39;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.23.11.26.48;	author davida;	state Exp;
branches;
next	1.2;

1.2
date	91.06.19.18.37.00;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.10.55.03;	author colin;	state Exp;
branches;
next	;

1.25.1.1
date	93.08.06.14.34.06;	author jont;	state Exp;
branches;
next	;

1.36.1.1
date	96.09.13.11.09.09;	author hope;	state Exp;
branches;
next	;

1.37.1.1
date	96.10.07.16.00.06;	author hope;	state Exp;
branches;
next	;

1.38.1.1
date	96.10.17.11.18.24;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	96.11.14.12.41.57;	author hope;	state Exp;
branches
	1.40.1.1.1.1;
next	;

1.40.1.1.1.1
date	96.11.28.14.53.51;	author hope;	state Exp;
branches;
next	;

1.40.2.1
date	96.11.22.18.02.24;	author hope;	state Exp;
branches;
next	;

1.40.3.1
date	96.12.17.17.41.20;	author hope;	state Exp;
branches
	1.40.3.1.1.1;
next	;

1.40.3.1.1.1
date	97.02.24.11.29.35;	author hope;	state Exp;
branches;
next	;

1.40.4.1
date	96.12.18.09.35.17;	author hope;	state Exp;
branches;
next	;

1.40.5.1
date	97.05.12.10.27.17;	author hope;	state Exp;
branches
	1.40.5.1.1.1
	1.40.5.1.2.1
	1.40.5.1.3.1;
next	;

1.40.5.1.1.1
date	97.07.28.18.12.50;	author daveb;	state Exp;
branches
	1.40.5.1.1.1.1.1;
next	;

1.40.5.1.1.1.1.1
date	97.10.07.11.37.53;	author jkbrook;	state Exp;
branches;
next	;

1.40.5.1.2.1
date	97.09.08.17.06.08;	author daveb;	state Exp;
branches;
next	;

1.40.5.1.3.1
date	97.09.09.14.01.35;	author daveb;	state Exp;
branches;
next	;

1.41.1.1
date	97.09.10.19.15.59;	author brucem;	state Exp;
branches;
next	;

1.41.2.1
date	97.09.11.20.45.46;	author daveb;	state Exp;
branches;
next	;

1.41.3.1
date	99.04.01.17.51.31;	author daveb;	state Exp;
branches;
next	;


desc
@Converts abstract syntax to S-expressions for printing
@


1.41
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(*
$Log: _absynprint.sml,v $
 * Revision 1.40  1996/11/06  10:51:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.39  1996/10/28  17:27:31  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
 * Revision 1.38  1996/09/25  17:35:56  andreww
 * [Bug #1592]
 * threading location into Absyn.LOCALexp.
 *
 * Revision 1.37  1996/09/16  13:53:07  andreww
 * [Bug #1577]
 * Accounting for new datatype replication abstract syntax.
 *
 * Revision 1.36  1996/08/05  17:52:55  andreww
 * [Bug #1521]
 * propagating changes made to typechecker/_types.sml
 * (pass options rather than just print_options)
 *
 * Revision 1.35  1996/04/29  15:12:46  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.34  1996/03/25  10:59:30  matthew
 * Adding field to VALdec
 *
 * Revision 1.33  1995/12/27  11:59:30  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.32  1995/09/05  14:20:08  daveb
Added new types for different sizes of ints, words, and reals.

Revision 1.31  1995/08/31  15:20:17  jont
Add option to print location info when unparsing patterns

Revision 1.30  1994/09/14  12:40:21  matthew
Abstraction of debug information

Revision 1.29  1994/02/21  16:58:42  nosa
Type function, debugger structure, and structure recording for Modules Debugger.

Revision 1.28  1993/12/03  16:37:04  nickh
Added location information to COERCEexp.

Revision 1.27  1993/11/25  09:32:03  matthew
Added fixity annotations to APPexps and APPpats

Revision 1.26  1993/08/12  11:45:39  nosa
Runtime-instance in VALpats and LAYEREDpats and Compilation-instance
in VALexps for polymorphic debugger.

Revision 1.25  1993/08/06  14:34:06  matthew
Added location information to matches

Revision 1.24  1993/07/12  08:59:27  nosa
structure Option.

Revision 1.23  1993/05/18  13:31:22  jont
Removed Integer parameter

Revision 1.22  1993/04/06  11:53:33  matthew
Change to DYNAMICexp and added MLVALUEexp

Revision 1.21  1993/03/09  12:55:07  matthew
Options & Info changes

Revision 1.20  1993/02/22  11:36:02  matthew
Added printing of dynamic and coerce abstract syntax

Revision 1.19  1992/12/09  10:06:28  clive
Missing require for SET

Revision 1.18  1992/12/08  18:29:39  jont
Removed a number of duplicated signatures and structures

Revision 1.17  1992/11/26  13:24:33  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.16  1992/10/09  15:02:53  clive
Tynames now have a slot recording their definition point

Revision 1.15  1992/09/17  11:20:01  daveb
Improved printing of types, as the interpreter uses this module to
print types in signatures.

Revision 1.14  1992/09/08  18:08:05  matthew
Added locations to some datatypes.

Revision 1.13  1992/09/04  08:56:42  richard
Installed central error reporting mechanism.

Revision 1.12  1992/08/12  11:52:49  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.11  1992/08/04  12:08:38  jont
Tidied up functor argument to reducing number of parameters and sharing

Revision 1.10  1992/06/29  11:11:12  clive
Added a slot to appexp for debugging type information for function call type

Revision 1.9  1992/06/15  09:31:49  clive
Added debug info to handlers

Revision 1.8  1992/06/11  10:28:04  clive
Added some marks for typechecker error messages

Revision 1.7  1992/05/19  14:00:45  clive
Added marks for better error reporting

Revision 1.6  1992/04/13  16:21:43  clive
First version of the profiler

Revision 1.5  1992/02/14  14:02:00  jont
Added integer parameter

Revision 1.4  1991/11/19  19:24:39  jont
Fixed inexhaustive matches

Revision 1.3  91/07/23  11:26:48  davida
Tidied up unparse_ty a bit: empty type-arg lists not printed, tuples spaced.

Revision 1.2  91/06/19  18:37:00  colin
> Updated to handle extra type ref field in HANDLEexp

Revision 1.1  91/06/07  10:55:03  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";

require "../utils/sexpr";
require "../utils/lists";
require "../utils/set";
require "../typechecker/types";
require "identprint";
require "absynprint";
require "absyn";

functor AbsynPrint(
  structure Sexpr : SEXPR
  structure Lists : LISTS
  structure Absyn : ABSYN
  structure IdentPrint : IDENTPRINT
  structure Types : TYPES
  structure Set : SET
  sharing Types.Datatypes.Ident = IdentPrint.Ident = Absyn.Ident
  sharing Types.Options = IdentPrint.Options
  sharing Set = Absyn.Set

  sharing type Absyn.Type = Types.Datatypes.Type
  sharing type Absyn.Structure = Types.Datatypes.Structure

    ) : ABSYNPRINT =
  struct

    structure Absyn = Absyn
    structure S = Sexpr
    structure Set = Set
    structure IP = IdentPrint
    structure Ident = IP.Ident
    structure Symbol = Ident.Symbol
    structure Options = Types.Options
    structure Location = Ident.Location

    type Ty = Absyn.Ty and Pat = Absyn.Pat and Dec = Absyn.Dec and
         Exp = Absyn.Exp 

    type 'a Sexpr = 'a Sexpr.Sexpr

    fun detreeTy options ty =
      case ty of
	Absyn.TYVARty tyvar => S.ATOM (IP.printTyVar tyvar)
      | Absyn.RECORDty tyrow => 
	  S.list (S.ATOM "RECORDty" :: detreeTyRow options tyrow)
      | Absyn.APPty (tyseq, longtycon,_) => 
	  S.list (S.ATOM "APPty" :: S.ATOM (IP.printLongTyCon longtycon) ::
		  map (detreeTy options) tyseq)
      | Absyn.FNty (ty,ty') =>
	  S.list [S.ATOM "FNty", detreeTy options ty,
                                 detreeTy options ty']

    and detreeTyRow options (tyrow) =
      map (fn (lab,ty) => S.list [S.ATOM (IP.printLab lab), 
                          detreeTy options ty]) tyrow
      
    fun detreePat options pat =
      let val Options.OPTIONS{print_options,...}=options
      in
      case pat of
	Absyn.WILDpat _ => S.ATOM "_"
      | Absyn.SCONpat (scon, _) => S.ATOM (IP.printSCon scon)
      | Absyn.VALpat ((longvalid,(ref ty,_)),_) => 
	  S.list [S.ATOM (IP.printLongValId print_options longvalid),
		  S.ATOM (Types.print_type options ty)]
      | Absyn.RECORDpat (patrow, false, ref ty) => 
	  S.list [S.list (S.ATOM "RECORDpat" 
                      :: detreePatRow options patrow),
		  S.ATOM (Types.print_type options ty)]
      | Absyn.RECORDpat (patrow, true, ref ty) => 
	  S.list [S.list (S.ATOM "FLEXRECORDpat" :: 
                      detreePatRow options patrow),
		  S.ATOM (Types.print_type options ty)]
      | Absyn.APPpat ((longvalid,_), pat,_,_) => 
	  S.list [S.ATOM (IP.printLongValId print_options longvalid), 
                  detreePat options pat]
      | Absyn.TYPEDpat (pat,ty,_) => 
	  S.list [detreePat options pat, 
                  detreeTy options ty]
      | Absyn.LAYEREDpat ((valid,(ref ty,_)), pat) => 
	  S.list [S.list [S.ATOM (IP.printValId print_options valid),
			  S.ATOM (Types.print_type 
                                  options ty)], 
                  detreePat options pat]
      end
	  
    and detreePatRow options (patrow) =
      map (fn (lab,pat) => S.list [S.ATOM (IP.printLab lab), detreePat options pat])
      patrow
      

    fun detreeExp options exp =
      let val Options.OPTIONS{print_options,...} = options
      in
      case exp of
	Absyn.SCONexp (scon, _) => S.ATOM (IP.printSCon scon)
      | Absyn.VALexp (longvalid,ref ty,location,_) => 
          S.list [S.ATOM (IP.printLongValId print_options longvalid),
		  S.ATOM (Types.print_type options ty),
                  S.ATOM (Location.to_string location)]
      | Absyn.RECORDexp exprow => 
	  S.list (S.ATOM "RECORDexp" :: 
                  detreeExpRow options exprow)
      | Absyn.LOCALexp (dec,exp,location) => 
	  S.list [S.ATOM "LOCALexp", 
                  S.ATOM (Location.to_string location),
                  detreeDec options dec, detreeExp options exp]
      | Absyn.APPexp (exp,exp',location,_,_) => 
	  S.list [S.ATOM "APPexp",
                  S.ATOM (Location.to_string location),
                  detreeExp options exp, 
                  detreeExp options exp']
      | Absyn.TYPEDexp (exp,ty,location) => 
	  S.list [S.ATOM "TYPEDexp",S.ATOM(Location.to_string location), 
                  detreeExp options exp,
                  detreeTy options ty]
      | Absyn.HANDLEexp (exp,_,match,_,annotation) =>
	  S.list (S.ATOM "HANDLEexp" :: S.ATOM (annotation) :: 
                  detreeExp options exp :: 
                  detreeMatch options match)
      | Absyn.RAISEexp (exp,location) => 
	  S.list [S.ATOM "RAISEexp", S.ATOM(Location.to_string location) ,
                  detreeExp options exp]
      | Absyn.FNexp (match,_,name,_) =>
	  S.list (S.ATOM "FNexp" :: S.ATOM name ::
                  detreeMatch options match)
      | Absyn.DYNAMICexp(exp,_,_) =>
          S.list [S.ATOM "DYNAMICexp", 
                  detreeExp options exp]
      | Absyn.COERCEexp(exp,ty,_,_) =>
          S.list [S.ATOM "COERCEexp", 
                  detreeExp options exp, 
                  detreeTy options ty]
      | Absyn.MLVALUEexp (mlvalue) => S.ATOM "MLVALUEexp"
      end

    and detreeExpRow options exprow = 
      map (fn (lab,exp) => S.list [S.ATOM (IP.printLab lab), 
                            detreeExp options exp])
      exprow
      
    and detreeMatch options match =
      map (fn (pat,exp,loc) => S.list 
           [detreePat options pat,
            detreeExp options exp]) match
  
    and detreeDec options dec = 
      case dec of
	Absyn.VALdec (valbind,valbind',tyvars,_) =>
	  S.list[S.ATOM "VALdec",
		 S.list(detreeValBind options valbind),
		 S.list(detreeValBind options valbind'),
		 S.list (detreeTyVars (Set.set_to_list tyvars))]
	  
      | Absyn.TYPEdec typbind => 
	  S.list (S.ATOM "TYPEdec" :: 
                  detreeTypBind options typbind)
	  
      | Absyn.DATATYPEdec datbind => 
	  S.list (S.ATOM "DATATYPEdec" :: 
                  detreeDatBind options datbind)

      | Absyn.DATATYPErepl (_,(tycon,longtycon),_) => 
	  S.list [S.ATOM "DATATYPErepl",
                  S.ATOM (IP.printTyCon tycon),
                  S.ATOM (IP.printLongTyCon longtycon)]

	  
      | Absyn.ABSTYPEdec (location,datbind,dec) => 
	  S.list [S.ATOM "ABSTYPEdec",
		  S.list (detreeDatBind options (location,datbind)), 
                  detreeDec options dec]
	  
      | Absyn.EXCEPTIONdec (exbind) => 
	  S.list (S.ATOM "EXCEPTIONdec" :: 
                  detreeExBind options exbind)
	  
      | Absyn.LOCALdec (dec,dec') => 
	  S.list [S.ATOM "LOCALdec", 
                  detreeDec options dec, 
                  detreeDec options dec']
	  
      | Absyn.OPENdec (longstrids) => 
	  S.list (S.ATOM "OPENdec" :: detreeLongStrIds longstrids)

      | Absyn.SEQUENCEdec (decs) => 
	  S.list (S.ATOM "SEQUENCEdec" :: 
                  map (detreeDec options) decs)
	  
    and detreeTyVars (tyvars) =
      map (fn tyvar => S.ATOM (IP.printTyVar tyvar)) tyvars
      
    and detreeLongStrIds (longstrids) =
      map (fn longstrid => S.ATOM (IP.printLongStrId longstrid))
      (#1 longstrids)
  
    and detreeTypBind options (typbind) =
      map (fn (tyvars,tycon,ty,_) =>
	   S.list [S.list (S.ATOM (IP.printTyCon tycon) :: 
	   detreeTyVars tyvars), detreeTy options ty]) 
      typbind

    and detreeDatBind options (_,datbind) =
      map (fn (tyvars,tycon,_,_,conbind) =>
	   S.list (S.list (S.ATOM (IP.printTyCon tycon) :: 
		   detreeTyVars tyvars) :: 
                   detreeConBind options conbind)) 
      datbind

    and detreeConBind options conbind =
      let val Options.OPTIONS{print_options,...} = options
       in
      map (fn ((valid,ref ty),NONE) => 
	       S.list [S.ATOM (IP.printValId print_options valid),
		       S.ATOM (Types.print_type options ty)] 
             | ((valid,_),SOME ty) =>
		 S.list [S.ATOM (IP.printValId print_options valid), 
                         detreeTy options ty])
      conbind
      end 
      
    and detreeExBind options exbind =
     let val Options.OPTIONS{print_options,...} = options
       in

      map (fn Absyn.NEWexbind ((valid,ref ty),NONE,_,_) =>
	       S.list [S.ATOM (IP.printValId print_options valid),
		       S.ATOM (Types.print_type options ty)]
	    | Absyn.NEWexbind ((valid,ref ty),SOME ty',_,_) => 
		S.list [S.list [S.ATOM (IP.printValId print_options valid),
				S.ATOM (Types.print_type options ty)],
                        detreeTy options ty']
	    | Absyn.OLDexbind ((valid,ref ty),longvalid,_,_) => 
		S.list [S.list [S.ATOM (IP.printValId print_options valid),
				S.ATOM (Types.print_type options ty)],
			S.ATOM (IP.printLongValId print_options longvalid)])
      exbind
     end

    and detreeValBind options (valbind) =
      map (fn (pat,exp,location) => S.list 
           [detreePat options pat, 
            S.ATOM(Location.to_string location),
            detreeExp options exp]) valbind

    val printSexpr = S.pprintSexpr (fn x => x)

    fun printDec options x = printSexpr (detreeDec options x)
    fun printExp options x = printSexpr (detreeExp options x)
    fun printPat options x = printSexpr (detreePat options x)
    fun printTy  options x = printSexpr (detreeTy options x)

(* Make a string version of a record, with the labels separated
   from the items by labsep, and the fields separated by sep.  Using
   unparseLab to generate the string representation of the labels, and
   unparseOther to make the string version of the other fields. *)
    fun record_print labsep sep unparseLab unparseOther options all =
      let
	fun rec_f [] rest = rest
	  | rec_f [(lab, other)] rest =
	      rest ^ (unparseLab lab) ^ labsep ^ (unparseOther options other)
	  | rec_f ((lab, other)::more) rest =
	      rec_f more (rest ^ (unparseLab lab) ^
			  labsep ^ (unparseOther options other) ^ sep)
      in
	rec_f all ""
      end

(* Make a string version of a tuple. *)
    fun tuple_print _ unparseOther options [ one ] _ = unparseOther options one
      | tuple_print sep unparseOther options all need_brackets =
      let
	fun internal [] rest = rest
	  | internal [ h ] rest =
	      rest ^ (unparseOther options h)
	  | internal (h::t) rest =
	      internal t (rest ^ (unparseOther options h) ^ sep)
	val tuple = internal all ""
      in
	if need_brackets then "(" ^ tuple ^ ")"
	else tuple
      end

(* Given a record, find out if it is in suitable form to use
   tuple_print (ie we have all numeric labels from 1 -> n inclusive.)
   If so we return (true, the ordered list of values), otherwise we
   return (false, []). *)
    fun tuple_p all =
      let
	fun num_labs 0 _ rest = (true, rest)
	  | num_labs _ [] _ = (false, [])
	  | num_labs n all rest =
	    let
	      fun present a [] = (false, [])
		| present a ((Ident.LAB h, the_val)::t) =
		  if (Symbol.eq_symbol (a, h)) then
		    (true, the_val::rest)
		  else
		    present a t
	      val (found, newlist) = present (Symbol.find_symbol (Int.toString n)) all
	    in
	       if found then
		 num_labs (n - 1) all newlist
	       else
		 (false, [])
	    end
      in
	num_labs (Lists.length all) all []
      end

(* Convert a Type to a string. *)
    (* This type is used to indicate whether the type to be unparsed in
       in a tuple, on the lhs of a function, or elsewhere.
     *)
    datatype NeedBrackets = NONE | FUNCTION | TUPLE

    fun unparseTy' need_brackets options ty =
      let
	fun record all =
	  (* Catch case of empty tuple type *)
	  case tuple_p all of
	    (true, [])  => "unit"
	  | (true, new) =>
	    tuple_print " * " (unparseTy' TUPLE) options new (need_brackets = TUPLE)
	  | (false, _)  =>
	    "{" ^ (record_print ":" "," IP.printLab (unparseTy' NONE) options all) ^ "}"
      in
	case ty of
	  Absyn.TYVARty tyvar => IP.printTyVar tyvar
	| Absyn.RECORDty tyrow => record tyrow
	| Absyn.APPty ([],ltc,_) => (IP.printLongTyCon ltc)
 	| Absyn.APPty (tyseq, ltc,_) =>
	    ((tuple_print "," (unparseTy' NONE) options tyseq true) ^
	     " " ^ (IP.printLongTyCon ltc))
	| Absyn.FNty (ty, ty') =>
	    let val function =
		  (unparseTy' FUNCTION options ty) ^ " -> " ^ (unparseTy' NONE options ty')
	    in  if need_brackets = TUPLE orelse need_brackets = FUNCTION then
		  "(" ^ function ^ ")"
	        else function
	    end
      end

    fun unparseTy options ty = unparseTy' NONE options ty

(* Convert a Pat to a string. *)
    fun unparsePat print_loc =
      let
	fun find_record_loc [] = Location.UNKNOWN
	  | find_record_loc ((_, pat) :: rest) =
	    case pat_loc pat of
	      Location.UNKNOWN => find_record_loc rest
	    | loc => loc

	and pat_loc(Absyn.WILDpat loc) = loc
	  | pat_loc(Absyn.SCONpat (scon, _)) =
	    (case scon of
	       Ident.INT(_, loc) => loc
	     | Ident.REAL(_, loc) => loc
	     | Ident.WORD(_, loc) => loc
	     | _ => Location.UNKNOWN) 
	  | pat_loc(Absyn.VALpat((lvi, _), loc)) = loc
	  | pat_loc(Absyn.RECORDpat(pr, _, _)) = find_record_loc pr
	  | pat_loc(Absyn.APPpat(_, _, loc, _)) = loc
	  | pat_loc(Absyn.TYPEDpat(_, _, loc)) = loc
	  | pat_loc(Absyn.LAYEREDpat(_, pat)) = pat_loc pat

	fun unparsePat' options pat =
	  let
	    fun record all =
	      let
		val (is_tuple, new) = tuple_p all
	      in
		if is_tuple then
		  tuple_print "," (unparsePat false) options new true
		else
		  "{" ^ (record_print "=" "," IP.printLab (unparsePat false) options all) ^ "}"
	      end

(* Flex records have ', ...' extra, and can't be in tuple form *)
	    fun flex_record all =
	      "{" ^ (record_print "=" "," IP.printLab (unparsePat false) options all ) ^ ",...}"
	  in
	    case pat of
	      Absyn.WILDpat loc =>
		if print_loc then
		  Location.to_string loc ^ ": _"
		else
		  "_"
	    | Absyn.SCONpat (scon, _) => IP.printSCon scon
	    | Absyn.VALpat ((lvi, _), loc) =>
		(if print_loc then
		   Location.to_string loc ^ ": "
		 else
		   "") ^
		   IP.printLongValId options lvi
	    | Absyn.RECORDpat (pr, false, _) =>
		(if print_loc then
		   Location.to_string(find_record_loc pr) ^ ": "
		 else
		   "") ^
		   record pr
	    | Absyn.RECORDpat (pr, true, _)  =>
		(if print_loc then
		   Location.to_string(find_record_loc pr) ^ ": "
		 else
		   "") ^
		   flex_record pr

(* The routine should take account of the fact that infix constructor
   functions should be displayed differently from other APPpats.  But
   I'll leave this until later. *)

	    | Absyn.APPpat ((lvi, _), pat,loc,_) =>
		(((if print_loc then
		     Location.to_string loc ^ ": "
		   else
		     "")
		     ^ IP.printLongValId options lvi) ^ " " ^
		     unparsePat false options pat)
	    | Absyn.TYPEDpat (pat, ty,_) =>
		("(" ^ (unparsePat print_loc options pat) ^ " : " ^
		 (unparseTy options ty) ^ ")")
	    | Absyn.LAYEREDpat ((vi, _), pat) =>
		((IP.printValId options vi) ^ " as " ^
		 (unparsePat print_loc options pat))
	  end
      in
	unparsePat'
      end

    fun unparseExp options exp =
      let
	fun record all =
	  let
	    val (is_tuple, new) = tuple_p all
	  in
	    if (is_tuple) then
	      tuple_print "," unparseExp options new true
	    else
	      "{" ^ (record_print "=" "," IP.printLab unparseExp options all ) ^ "}"
	  end

	fun fn_body [] rest = rest
	  | fn_body [ (pat, exp,_) ] rest =
	      rest ^ (unparsePat false options pat) ^ " => " ^ (unparseExp options exp)
	  | fn_body ((pat, exp,_)::ll) rest =
	      fn_body ll (rest ^ (unparsePat false options pat) ^ " => " ^
			  (unparseExp options exp) ^ " | ")

      in
	case exp of
	  Absyn.SCONexp (scon, _) => IP.printSCon scon
	| Absyn.VALexp (lvi, _,_,_) => IP.printLongValId options lvi
	| Absyn.RECORDexp pr => record pr
	| Absyn.LOCALexp (dec, e,_) => "let ... in " ^ (unparseExp options e) ^ " end"
	| Absyn.APPexp (e1, e2,_,_,_) => "(" ^ (unparseExp options e1) ^ " " ^ (unparseExp options e2) ^ ")"
	| Absyn.TYPEDexp (e, ty,_) => (unparseExp options e) ^ ":" ^ (unparseTy options ty)
	| Absyn.HANDLEexp _ => "...handle..."
	| Absyn.RAISEexp _ => "...raise..."
	| Absyn.FNexp (all,_,_,_) => fn_body all "fn "
        | Absyn.DYNAMICexp _ => "Dynamic ..."
        | Absyn.COERCEexp _ => "Coerce ..."
        | Absyn.MLVALUEexp _ => "MLValue"
      end

  end


@


1.41.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.41  1997/05/01  13:08:01  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.41.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.41  1997/05/01  13:08:01  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.41.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.41  1997/05/01  13:08:01  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.40
log
@[Bug #1728]
__integer becomes __int
@
text
@d3 4
d349 1
a349 1
      map (fn ((valid,ref ty),MLWorks.Option.NONE) => 
d352 1
a352 1
             | ((valid,_),MLWorks.Option.SOME ty) =>
d362 1
a362 1
      map (fn Absyn.NEWexbind ((valid,ref ty),MLWorks.Option.NONE,_,_) =>
d365 1
a365 1
	    | Absyn.NEWexbind ((valid,ref ty),MLWorks.Option.SOME ty',_,_) => 
@


1.40.5.1
log
@branched from 1.40
@
text
@a2 4
 * Revision 1.40  1996/11/06  10:51:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.40.5.1  1997/05/12  10:27:17  hope
 * branched from 1.40
 *
@


1.40.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.40.5.1  1997/05/12  10:27:17  hope
 * branched from 1.40
 *
@


1.40.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.40.5.1  1997/05/12  10:27:17  hope
 * branched from 1.40
 *
@


1.40.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.40.5.1.1.1  1997/07/28  18:12:50  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.40.4.1
log
@branched from 1.40
@
text
@a2 4
 * Revision 1.40  1996/11/06  10:51:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.3.1
log
@branched from 1.40
@
text
@a2 4
 * Revision 1.40  1996/11/06  10:51:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.3.1.1.1
log
@branched from 1.40.3.1
@
text
@a2 3
 * Revision 1.40.3.1  1996/12/17  17:41:20  hope
 * branched from 1.40
 *
@


1.40.2.1
log
@branched from 1.40
@
text
@a2 4
 * Revision 1.40  1996/11/06  10:51:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.1.1
log
@branched from 1.40
@
text
@a2 4
 * Revision 1.40  1996/11/06  10:51:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.1.1.1.1
log
@branched from 1.40.1.1
@
text
@a2 3
 * Revision 1.40.1.1  1996/11/14  12:41:57  hope
 * branched from 1.40
 *
@


1.39
log
@[Bug #1708]
changing syntax of datatype replication.
@
text
@d3 4
d132 1
a132 1
require "../basis/__integer";
@


1.38
log
@[Bug #1592]
threading location into Absyn.LOCALexp.
@
text
@d3 4
d291 1
a291 1
      | Absyn.DATATYPErepl (_,(tyvars,tycon,longtycon),_) => 
a292 1
		  S.list (detreeTyVars tyvars),
a293 1
                  S.list (detreeTyVars tyvars),
@


1.38.1.1
log
@branched from 1.38
@
text
@a2 4
 * Revision 1.38  1996/09/25  17:35:56  andreww
 * [Bug #1592]
 * threading location into Absyn.LOCALexp.
 *
@


1.37
log
@[Bug #1577]
Accounting for new datatype replication abstract syntax.
@
text
@d3 4
d228 4
a231 2
      | Absyn.LOCALexp (dec,exp) => 
	  S.list [S.ATOM "LOCALexp", detreeDec options dec, detreeExp options exp]
d582 1
a582 1
	| Absyn.LOCALexp (dec, e) => "let ... in " ^ (unparseExp options e) ^ " end"
@


1.37.1.1
log
@branched from 1.37
@
text
@a2 4
 * Revision 1.37  1996/09/16  13:53:07  andreww
 * [Bug #1577]
 * Accounting for new datatype replication abstract syntax.
 *
@


1.36
log
@[Bug #1521]
propagating changes made to typechecker/_types.sml
(pass options rather than just print_options)
@
text
@d3 5
d280 8
@


1.36.1.1
log
@branched from 1.36
@
text
@a2 5
 * Revision 1.36  1996/08/05  17:52:55  andreww
 * [Bug #1521]
 * propagating changes made to typechecker/_types.sml
 * (pass options rather than just print_options)
 *
@


1.35
log
@Removing MLWorks.Integer
@
text
@d3 3
d165 2
a166 1
	  S.list [S.ATOM "FNty", detreeTy options ty, detreeTy options ty']
d169 2
a170 1
      map (fn (lab,ty) => S.list [S.ATOM (IP.printLab lab), detreeTy options ty]) tyrow
d173 2
d179 1
a179 1
	  S.list [S.ATOM (IP.printLongValId options longvalid),
d182 2
a183 1
	  S.list [S.list (S.ATOM "RECORDpat" :: detreePatRow options patrow),
d186 2
a187 1
	  S.list [S.list (S.ATOM "FLEXRECORDpat" :: detreePatRow options patrow),
d190 2
a191 1
	  S.list [S.ATOM (IP.printLongValId options longvalid), detreePat options pat]
d193 2
a194 1
	  S.list [detreePat options pat, detreeTy options ty]
d196 5
a200 2
	  S.list [S.list [S.ATOM (IP.printValId options valid),
			  S.ATOM (Types.print_type options ty)], detreePat options pat]
d208 2
d213 1
a213 1
          S.list [S.ATOM (IP.printLongValId options longvalid),
d217 2
a218 1
	  S.list (S.ATOM "RECORDexp" :: detreeExpRow options exprow)
d224 2
a225 1
                  detreeExp options exp, detreeExp options exp']
d227 3
a229 1
	  S.list [S.ATOM "TYPEDexp",S.ATOM(Location.to_string location), detreeExp options exp, detreeTy options ty]
d231 3
a233 1
	  S.list (S.ATOM "HANDLEexp" :: S.ATOM (annotation) :: detreeExp options exp :: detreeMatch options match)
d235 2
a236 1
	  S.list [S.ATOM "RAISEexp", S.ATOM(Location.to_string location) , detreeExp options exp]
d238 2
a239 1
	  S.list (S.ATOM "FNexp" :: S.ATOM name :: detreeMatch options match)
d241 2
a242 1
          S.list [S.ATOM "DYNAMICexp", detreeExp options exp]
d244 3
a246 1
          S.list [S.ATOM "COERCEexp", detreeExp options exp, detreeTy options ty]
d248 2
a249 1
	  
d251 2
a252 1
      map (fn (lab,exp) => S.list [S.ATOM (IP.printLab lab), detreeExp options exp])
d256 3
a258 1
      map (fn (pat,exp,loc) => S.list [detreePat options pat, detreeExp options exp]) match
d263 4
a266 4
	  S.list [S.ATOM "VALdec",
		  S.list (detreeValBind options valbind),
		  S.list (detreeValBind options valbind'),
		  S.list (detreeTyVars (Set.set_to_list tyvars))]
d269 2
a270 1
	  S.list (S.ATOM "TYPEdec" :: detreeTypBind options typbind)
d273 2
a274 1
	  S.list (S.ATOM "DATATYPEdec" :: detreeDatBind options datbind)
d278 2
a279 1
		  S.list (detreeDatBind options (location,datbind)), detreeDec options dec]
d282 2
a283 1
	  S.list (S.ATOM "EXCEPTIONdec" :: detreeExBind options exbind)
d286 3
a288 1
	  S.list [S.ATOM "LOCALdec", detreeDec options dec, detreeDec options dec']
d294 2
a295 1
	  S.list (S.ATOM "SEQUENCEdec" :: map (detreeDec options) decs)
d301 2
a302 1
      map (fn longstrid => S.ATOM (IP.printLongStrId longstrid)) (#1 longstrids)
d307 1
a307 1
			   detreeTyVars tyvars), detreeTy options ty]) 
d313 2
a314 1
			   detreeTyVars tyvars) :: detreeConBind options conbind)) 
d318 2
d321 2
a322 2
	       S.list [S.ATOM (IP.printValId options valid),
		       S.ATOM (Types.print_type options ty)]
d324 2
a325 1
		 S.list [S.ATOM (IP.printValId options valid), detreeTy options ty])
d327 1
d330 3
d334 1
a334 1
	       S.list [S.ATOM (IP.printValId options valid),
d337 3
a339 2
		S.list [S.list [S.ATOM (IP.printValId options valid),
				S.ATOM (Types.print_type options ty)],detreeTy options ty']
d341 1
a341 1
		S.list [S.list [S.ATOM (IP.printValId options valid),
d343 1
a343 1
			S.ATOM (IP.printLongValId options longvalid)])
d345 1
d348 4
a351 2
      map (fn (pat,exp,location) => S.list [detreePat options pat, S.ATOM(Location.to_string location),
                                         detreeExp options exp]) valbind
d358 1
a358 1
    fun printTy options x = printSexpr (detreeTy options x)
@


1.34
log
@Adding field to VALdec
@
text
@d3 3
d111 3
d356 1
a356 1
	      val (found, newlist) = present (Symbol.find_symbol (MLWorks.Integer.makestring n)) all
@


1.33
log
@Removing Option in favour of MLWorks.Option
@
text
@d3 3
d225 1
a225 1
	Absyn.VALdec (valbind,valbind',tyvars) =>
@


1.32
log
@Added new types for different sizes of ints, words, and reals.
@
text
@d3 3
a137 1
    structure Option = Absyn.Option
d269 1
a269 1
      map (fn ((valid,ref ty),Option.ABSENT) => 
d272 1
a272 1
             | ((valid,_),Option.PRESENT ty) =>
d277 1
a277 1
      map (fn Absyn.NEWexbind ((valid,ref ty),Option.ABSENT,_,_) =>
d280 1
a280 1
	    | Absyn.NEWexbind ((valid,ref ty),Option.PRESENT ty',_,_) => 
@


1.31
log
@Add option to print location info when unparsing patterns
@
text
@d3 3
d159 1
a159 1
      | Absyn.SCONpat scon => S.ATOM (IP.printSCon scon)
d184 1
a184 1
	Absyn.SCONexp scon => S.ATOM (IP.printSCon scon)
d401 1
a401 1
	  | pat_loc(Absyn.SCONpat scon) =
d435 1
a435 1
	    | Absyn.SCONpat scon => IP.printSCon scon
d454 1
d498 1
a498 1
	  Absyn.SCONexp scon => IP.printSCon scon
@


1.30
log
@Abstraction of debug information
@
text
@d3 3
d155 1
a155 1
	Absyn.WILDpat => S.ATOM "_"
d389 1
a389 1
    fun unparsePat options pat =
d391 20
a410 1
	fun record all =
d412 9
a420 7
	    val (is_tuple, new) = tuple_p all
	  in
	    if (is_tuple) then
	      tuple_print "," unparsePat options new true
	    else
	      "{" ^ (record_print "=" "," IP.printLab unparsePat options all) ^ "}"
	  end
d423 3
a425 3
	fun flex_record all =
	  "{" ^ (record_print "=" "," IP.printLab unparsePat options all ) ^ ",...}"
      in
d427 5
a431 1
	      Absyn.WILDpat => "_"
d433 18
a450 4
	    | Absyn.VALpat ((lvi, _),_) => IP.printLongValId options lvi
	    | Absyn.RECORDpat (pr, false, _) => record pr
	    | Absyn.RECORDpat (pr, true, _)  => flex_record pr

d452 2
a453 2
   functions should be displayed differently, to other APPpats.  But
   I'll leave this 'til later. *)
d455 7
a461 2
	    | Absyn.APPpat ((lvi, _), pat,_,_) =>
		((IP.printLongValId options lvi) ^ " " ^ unparsePat options pat)
d463 2
a464 1
		("(" ^ (unparsePat options pat) ^ " : " ^ (unparseTy options ty) ^ ")")
d466 5
a470 1
		((IP.printValId options vi) ^ " as " ^ (unparsePat options pat))
d487 1
a487 1
	      rest ^ (unparsePat options pat) ^ " => " ^ (unparseExp options exp)
d489 1
a489 1
	      fn_body ll (rest ^ (unparsePat options pat) ^ " => " ^
@


1.29
log
@Type function, debugger structure, and structure recording for Modules Debugger.
@
text
@d3 3
d129 1
d154 1
a154 1
      | Absyn.VALpat ((longvalid,ref (ty,_,_)),_) => 
d167 1
a167 1
      | Absyn.LAYEREDpat ((valid,ref (ty,_,_)), pat) => 
d261 1
a261 1
      map (fn ((valid,ref ty),Absyn.Option.ABSENT) => 
d264 1
a264 1
             | ((valid,_),Absyn.Option.PRESENT ty) =>
d269 1
a269 1
      map (fn Absyn.NEWexbind ((valid,ref ty),Absyn.Option.ABSENT,_,_) =>
d272 1
a272 1
	    | Absyn.NEWexbind ((valid,ref ty),Absyn.Option.PRESENT ty',_,_) => 
@


1.28
log
@Added location information to COERCEexp.
@
text
@d3 3
d150 1
a150 1
      | Absyn.VALpat ((longvalid,ref (ty,_)),_) => 
d163 1
a163 1
      | Absyn.LAYEREDpat ((valid,ref (ty,_)), pat) => 
d245 1
a245 1
      map (fn (tyvars,tycon,ty) =>
d251 1
a251 1
      map (fn (tyvars,tycon,_,conbind) =>
@


1.27
log
@Added fixity annotations to APPexps and APPpats
@
text
@d3 3
d194 1
a194 1
      | Absyn.COERCEexp(exp,ty,_) =>
@


1.26
log
@Runtime-instance in VALpats and LAYEREDpats and Compilation-instance
in VALexps for polymorphic debugger.
@
text
@d3 4
d153 1
a153 1
      | Absyn.APPpat ((longvalid,_), pat,_) => 
d177 1
a177 1
      | Absyn.APPexp (exp,exp',location,_) => 
d403 1
a403 1
	    | Absyn.APPpat ((lvi, _), pat,_) =>
d436 1
a436 1
	| Absyn.APPexp (e1, e2,_,_) => "(" ^ (unparseExp options e1) ^ " " ^ (unparseExp options e2) ^ ")"
@


1.25
log
@Added location information to matches
@
text
@d3 3
d140 1
a140 1
      | Absyn.VALpat ((longvalid,ref ty),_) => 
d153 1
a153 1
      | Absyn.LAYEREDpat ((valid,ref ty), pat) => 
d165 1
a165 1
      | Absyn.VALexp (longvalid,ref ty,location) => 
d429 1
a429 1
	| Absyn.VALexp (lvi, _,_) => IP.printLongValId options lvi
@


1.25.1.1
log
@Fork for bug fixing
@
text
@a2 3
Revision 1.25  1993/08/06  14:34:06  matthew
Added location information to matches

@


1.24
log
@structure Option.
@
text
@d3 3
d193 1
a193 1
      map (fn (pat,exp) => S.list [detreePat options pat, detreeExp options exp]) match
d417 1
a417 1
	  | fn_body [ (pat, exp) ] rest =
d419 1
a419 1
	  | fn_body ((pat, exp)::ll) rest =
@


1.23
log
@Removed Integer parameter
@
text
@d3 3
d241 1
a241 1
      map (fn ((valid,ref ty),Absyn.ABSENT) => 
d244 1
a244 1
             | ((valid,_),Absyn.PRESENT ty) =>
d249 1
a249 1
      map (fn Absyn.NEWexbind ((valid,ref ty),Absyn.ABSENT,_,_) =>
d252 1
a252 1
	    | Absyn.NEWexbind ((valid,ref ty),Absyn.PRESENT ty',_,_) => 
@


1.22
log
@Change to DYNAMICexp and added MLVALUEexp
@
text
@d3 3
a75 1
require "../utils/integer";
a84 1
  structure Integer : INTEGER
d316 1
a316 1
	      val (found, newlist) = present (Symbol.find_symbol (Integer.makestring n)) all
@


1.21
log
@Options & Info changes
@
text
@d3 3
d175 1
a175 1
      | Absyn.DYNAMICexp(exp,_) =>
d179 1
d429 1
@


1.20
log
@Added printing of dynamic and coerce abstract syntax
@
text
@d3 3
d85 2
a86 4
  sharing Absyn.Datatypes = Types.Datatypes
  sharing Types.Datatypes.Ident = IdentPrint.Ident
  sharing Types.Info = IdentPrint.Info
  sharing Absyn.Location = Types.Info.Location
d88 4
d101 2
a102 1
    structure Info = Types.Info
d155 1
a155 1
                  S.ATOM (Absyn.Location.to_string location)]
d162 1
a162 1
                  S.ATOM (Absyn.Location.to_string location),
d165 1
a165 1
	  S.list [S.ATOM "TYPEDexp",S.ATOM(Absyn.Location.to_string location), detreeExp options exp, detreeTy options ty]
d169 1
a169 1
	  S.list [S.ATOM "RAISEexp", S.ATOM(Absyn.Location.to_string location) , detreeExp options exp]
d254 1
a254 1
      map (fn (pat,exp,location) => S.list [detreePat options pat, S.ATOM(Absyn.Location.to_string location),
@


1.19
log
@Missing require for SET
@
text
@d3 3
d166 4
d416 3
a418 2
	| Absyn.FNexp (all,_,_,_) =>
	    fn_body all "fn "
@


1.18
log
@Removed a number of duplicated signatures and structures
@
text
@d3 3
d65 1
@


1.17
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d3 4
d74 1
d79 1
d85 1
a85 1
    structure Set = Absyn.Set
@


1.16
log
@Tynames now have a slot recording their definition point
@
text
@d3 3
d30 1
a30 1
Added some maarks for typechecker error messages
d72 2
d83 1
d90 1
a90 1
    fun detreeTy (ty) =
d94 1
a94 1
	  S.list (S.ATOM "RECORDty" :: detreeTyRow tyrow)
d97 1
a97 1
		  map detreeTy tyseq)
d99 1
a99 1
	  S.list [S.ATOM "FNty", detreeTy ty, detreeTy ty']
d101 2
a102 2
    and detreeTyRow (tyrow) =
      map (fn (lab,ty) => S.list [S.ATOM (IP.printLab lab), detreeTy ty]) tyrow
d104 1
a104 1
    fun detreePat (pat) =
d109 2
a110 2
	  S.list [S.ATOM (IP.printLongValId longvalid),
		  S.ATOM (Types.print_type ty)]
d112 2
a113 2
	  S.list [S.list (S.ATOM "RECORDpat" :: detreePatRow patrow),
		  S.ATOM (Types.print_type ty)]
d115 2
a116 2
	  S.list [S.list (S.ATOM "FLEXRECORDpat" :: detreePatRow patrow),
		  S.ATOM (Types.print_type ty)]
d118 1
a118 1
	  S.list [S.ATOM (IP.printLongValId longvalid), detreePat pat]
d120 1
a120 1
	  S.list [detreePat pat, detreeTy ty]
d122 2
a123 2
	  S.list [S.list [S.ATOM (IP.printValId valid),
			  S.ATOM (Types.print_type ty)], detreePat pat]
d125 2
a126 2
    and detreePatRow (patrow) =
      map (fn (lab,pat) => S.list [S.ATOM (IP.printLab lab), detreePat pat])
d130 1
a130 1
    fun detreeExp (exp) =
d134 2
a135 2
          S.list [S.ATOM (IP.printLongValId longvalid),
		  S.ATOM (Types.print_type ty),
d138 1
a138 1
	  S.list (S.ATOM "RECORDexp" :: detreeExpRow exprow)
d140 1
a140 1
	  S.list [S.ATOM "LOCALexp", detreeDec dec, detreeExp exp]
d144 1
a144 1
                  detreeExp exp, detreeExp exp']
d146 1
a146 1
	  S.list [S.ATOM "TYPEDexp",S.ATOM(Absyn.Location.to_string location), detreeExp exp, detreeTy ty]
d148 1
a148 1
	  S.list (S.ATOM "HANDLEexp" :: S.ATOM (annotation) :: detreeExp exp :: detreeMatch match)
d150 1
a150 1
	  S.list [S.ATOM "RAISEexp", S.ATOM(Absyn.Location.to_string location) , detreeExp exp]
d152 1
a152 1
	  S.list (S.ATOM "FNexp" :: S.ATOM name :: detreeMatch match)
d154 2
a155 2
    and detreeExpRow exprow = 
      map (fn (lab,exp) => S.list [S.ATOM (IP.printLab lab), detreeExp exp])
d158 2
a159 2
    and detreeMatch match =
      map (fn (pat,exp) => S.list [detreePat pat, detreeExp exp]) match
d161 1
a161 1
    and detreeDec dec = 
d165 2
a166 2
		  S.list (detreeValBind valbind),
		  S.list (detreeValBind valbind'),
d170 1
a170 1
	  S.list (S.ATOM "TYPEdec" :: detreeTypBind typbind)
d173 1
a173 1
	  S.list (S.ATOM "DATATYPEdec" :: detreeDatBind datbind)
d177 1
a177 1
		  S.list (detreeDatBind (location,datbind)), detreeDec dec]
d180 1
a180 1
	  S.list (S.ATOM "EXCEPTIONdec" :: detreeExBind exbind)
d183 1
a183 1
	  S.list [S.ATOM "LOCALdec", detreeDec dec, detreeDec dec']
d189 1
a189 1
	  S.list (S.ATOM "SEQUENCEdec" :: map detreeDec decs)
d197 1
a197 1
    and detreeTypBind (typbind) =
d200 1
a200 1
			   detreeTyVars tyvars), detreeTy ty]) 
d203 1
a203 1
    and detreeDatBind (_,datbind) =
d206 1
a206 1
			   detreeTyVars tyvars) :: detreeConBind conbind)) 
d209 1
a209 1
    and detreeConBind (conbind) =
d211 2
a212 2
	       S.list [S.ATOM (IP.printValId valid),
		       S.ATOM (Types.print_type ty)]
d214 1
a214 1
		 S.list [S.ATOM (IP.printValId valid), detreeTy ty])
d217 1
a217 1
    and detreeExBind (exbind) =
d219 2
a220 2
	       S.list [S.ATOM (IP.printValId valid),
		       S.ATOM (Types.print_type ty)]
d222 2
a223 2
		S.list [S.list [S.ATOM (IP.printValId valid),
				S.ATOM (Types.print_type ty)],detreeTy ty']
d225 3
a227 3
		S.list [S.list [S.ATOM (IP.printValId valid),
				S.ATOM (Types.print_type ty)],
			S.ATOM (IP.printLongValId longvalid)])
d230 3
a232 3
    and detreeValBind (valbind) =
      map (fn (pat,exp,location) => S.list [detreePat pat, S.ATOM(Absyn.Location.to_string location),
                                         detreeExp exp]) valbind
d236 4
a239 4
    fun printDec x = printSexpr (detreeDec x)
    fun printExp x = printSexpr (detreeExp x)
    fun printPat x = printSexpr (detreePat x)
    fun printTy x = printSexpr (detreeTy x)
d245 1
a245 1
    fun record_print labsep sep unparseLab unparseOther all =
d249 1
a249 1
	      rest ^ (unparseLab lab) ^ labsep ^ (unparseOther other)
d252 1
a252 1
			  labsep ^ (unparseOther other) ^ sep)
d258 2
a259 2
    fun tuple_print _ unparseOther [ one ] _ = unparseOther one
      | tuple_print sep unparseOther all need_brackets =
d263 1
a263 1
	      rest ^ (unparseOther h)
d265 1
a265 1
	      internal t (rest ^ (unparseOther h) ^ sep)
d305 1
a305 1
    fun unparseTy' need_brackets ty =
d312 1
a312 1
	    tuple_print " * " (unparseTy' TUPLE) new (need_brackets = TUPLE)
d314 1
a314 1
	    "{" ^ (record_print ":" "," IP.printLab (unparseTy' NONE) all) ^ "}"
d321 1
a321 1
	    ((tuple_print "," (unparseTy' NONE) tyseq true) ^
d325 1
a325 1
		  (unparseTy' FUNCTION ty) ^ " -> " ^ (unparseTy' NONE ty')
d332 1
a332 1
    fun unparseTy ty = unparseTy' NONE ty
d335 1
a335 1
    fun unparsePat pat =
d342 1
a342 1
	      tuple_print "," unparsePat new true
d344 1
a344 1
	      "{" ^ (record_print "=" "," IP.printLab unparsePat all) ^ "}"
d349 1
a349 1
	  "{" ^ (record_print "=" "," IP.printLab unparsePat all ) ^ ",...}"
d354 1
a354 1
	    | Absyn.VALpat ((lvi, _),_) => IP.printLongValId lvi
d363 1
a363 1
		((IP.printLongValId lvi) ^ " " ^ unparsePat pat)
d365 1
a365 1
		("(" ^ (unparsePat pat) ^ " : " ^ (unparseTy ty) ^ ")")
d367 1
a367 1
		((IP.printValId vi) ^ " as " ^ (unparsePat pat))
d370 1
a370 1
    fun unparseExp exp =
d377 1
a377 1
	      tuple_print "," unparseExp new true
d379 1
a379 1
	      "{" ^ (record_print "=" "," IP.printLab unparseExp all ) ^ "}"
d384 1
a384 1
	      rest ^ (unparsePat pat) ^ " => " ^ (unparseExp exp)
d386 2
a387 2
	      fn_body ll (rest ^ (unparsePat pat) ^ " => " ^
			  (unparseExp exp) ^ " | ")
d392 1
a392 1
	| Absyn.VALexp (lvi, _,_) => IP.printLongValId lvi
d394 3
a396 3
	| Absyn.LOCALexp (dec, e) => "let ... in " ^ (unparseExp e) ^ " end"
	| Absyn.APPexp (e1, e2,_,_) => "(" ^ (unparseExp e1) ^ " " ^ (unparseExp e2) ^ ")"
	| Absyn.TYPEDexp (e, ty,_) => (unparseExp e) ^ ":" ^ (unparseTy ty)
@


1.15
log
@Improved printing of types, as the interpreter uses this module to
print types in signatures.
@
text
@d3 4
d169 1
a169 1
      | Absyn.ABSTYPEdec (datbind,dec) => 
d171 1
a171 1
		  S.list (detreeDatBind datbind), detreeDec dec]
d197 1
a197 1
    and detreeDatBind (datbind) =
@


1.14
log
@Added locations to some datatypes.
@
text
@d3 3
d248 2
a249 2
    fun tuple_print _ unparseOther [ one ] = unparseOther one
      | tuple_print sep unparseOther all =
d256 1
d258 2
a259 1
	"(" ^ (internal all "") ^ ")"
d290 6
a295 1
    fun unparseTy ty =
d298 7
a304 9
	  let
	    val (is_tuple, new) = tuple_p all
	  in
	    if (is_tuple) then
	      tuple_print " * " unparseTy new
	    else
	      "{" ^ (record_print ":" "," IP.printLab unparseTy all) ^ "}"
	  end

d311 1
a311 1
	    ((tuple_print "," unparseTy tyseq) ^
d314 6
a319 1
	    ( "(" ^ (unparseTy ty) ^ " -> " ^ (unparseTy ty') ^ ")" )
d322 2
d332 1
a332 1
	      tuple_print "," unparsePat new
d334 1
a334 1
	      "{" ^ (record_print "=" "," IP.printLab unparsePat all ) ^ "}"
d367 1
a367 1
	      tuple_print "," unparseExp new
@


1.13
log
@Installed central error reporting mechanism.
@
text
@d3 3
d82 1
a82 1
      | Absyn.APPty (tyseq, longtycon) => 
d95 1
a95 1
      | Absyn.VALpat (longvalid,ref ty) => 
d104 1
a104 1
      | Absyn.APPpat ((longvalid,_), pat) => 
d106 1
a106 1
      | Absyn.TYPEDpat (pat,ty) => 
d301 2
a302 2
	| Absyn.APPty ([],ltc) => (IP.printLongTyCon ltc)
 	| Absyn.APPty (tyseq, ltc) =>
d329 1
a329 1
	    | Absyn.VALpat (lvi, _) => IP.printLongValId lvi
d337 1
a337 1
	    | Absyn.APPpat ((lvi, _), pat) =>
d339 1
a339 1
	    | Absyn.TYPEDpat (pat, ty) =>
@


1.12
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d3 4
d117 1
a117 1
      | Absyn.VALexp (longvalid,ref ty,marks) => 
d120 1
a120 1
                  S.ATOM (Absyn.Source_marks_to_string marks)]
d125 1
a125 1
      | Absyn.APPexp (exp,exp',marks,_) => 
d127 1
a127 1
                  S.ATOM (Absyn.Source_marks_to_string marks),
d129 2
a130 2
      | Absyn.TYPEDexp (exp,ty,marks) => 
	  S.list [S.ATOM "TYPEDexp",S.ATOM(Absyn.Source_marks_to_string marks), detreeExp exp, detreeTy ty]
d133 2
a134 2
      | Absyn.RAISEexp (exp,marks) => 
	  S.list [S.ATOM "RAISEexp", S.ATOM(Absyn.Source_marks_to_string marks) , detreeExp exp]
d215 1
a215 1
      map (fn (pat,exp,marks) => S.list [detreePat pat, S.ATOM(Absyn.Source_marks_to_string marks),
@


1.11
log
@Tidied up functor argument to reducing number of parameters and sharing
@
text
@d3 3
d41 2
a44 1
require "../typechecker/types";
a45 1

d51 1
d54 1
d61 1
a61 1
    structure IP = Types.Datatypes.IdentPrint
@


1.10
log
@Added a slot to appexp for debugging type information for function call type
@
text
@d3 3
a35 1
require "../utils/crash";
a38 1
require "identprint";
a39 1
require "ident";
a44 1
  structure Crash : CRASH
a46 1
  structure IdentPrint : IDENTPRINT
a47 1
  structure Ident : IDENT
a49 2
  sharing Absyn.IdentClass = Ident
  sharing Absyn.IdentClass = IdentPrint.Ident
d56 2
a57 2
    structure IP = IdentPrint
    structure Ident = Ident
@


1.9
log
@Added debug info to handlers
@
text
@d3 3
d121 3
a123 2
      | Absyn.APPexp (exp,exp',marks) => 
	  S.list [S.ATOM "APPexp",S.ATOM (Absyn.Source_marks_to_string marks),
d363 1
a363 1
	| Absyn.APPexp (e1, e2,_) => "(" ^ (unparseExp e1) ^ " " ^ (unparseExp e2) ^ ")"
@


1.8
log
@Added some maarks for typechecker error messages
@
text
@d3 3
d194 1
a194 1
      map (fn Absyn.NEWexbind ((valid,ref ty),Absyn.ABSENT,_) =>
d197 1
a197 1
	    | Absyn.NEWexbind ((valid,ref ty),Absyn.PRESENT ty',_) => 
d200 1
a200 1
	    | Absyn.OLDexbind ((valid,ref ty),longvalid,_) => 
@


1.7
log
@Added marks for better error reporting
@
text
@d3 3
d120 2
a121 2
      | Absyn.HANDLEexp (exp,_,match,marks) =>
	  S.list (S.ATOM "HANDLEexp" :: S.ATOM (Absyn.Source_marks_to_string marks) :: detreeExp exp :: detreeMatch match)
d124 1
a124 1
      | Absyn.FNexp (match,_,name) =>
d360 1
a360 1
	| Absyn.FNexp (all,_,_) =>
@


1.6
log
@First version of the profiler
@
text
@d3 3
d104 1
a104 1
      | Absyn.VALexp (longvalid,ref ty) => 
d106 2
a107 1
		  S.ATOM (Types.print_type ty)]
d112 9
a120 8
      | Absyn.APPexp (exp,exp') => 
	  S.list [S.ATOM "APPexp", detreeExp exp, detreeExp exp']
      | Absyn.TYPEDexp (exp,ty) => 
	  S.list [S.ATOM "TYPEDexp", detreeExp exp, detreeTy ty]
      | Absyn.HANDLEexp (exp,_,match) =>
	  S.list (S.ATOM "HANDLEexp" :: detreeExp exp :: detreeMatch match)
      | Absyn.RAISEexp (exp) => 
	  S.list [S.ATOM "RAISEexp", detreeExp exp]
a122 1
      | Absyn.TEN15exp _ => Crash.impossible"Absyn.TEN15exp"
d165 1
a165 1
      map (fn longstrid => S.ATOM (IP.printLongStrId longstrid)) longstrids
d188 1
a188 1
      map (fn Absyn.NEWexbind ((valid,ref ty),Absyn.ABSENT) =>
d191 1
a191 1
	    | Absyn.NEWexbind ((valid,ref ty),Absyn.PRESENT ty') => 
d194 1
a194 1
	    | Absyn.OLDexbind ((valid,ref ty),longvalid) => 
d201 2
a202 1
      map (fn (pat,exp) => S.list [detreePat pat, detreeExp exp]) valbind
d350 1
a350 1
	| Absyn.VALexp (lvi, _) => IP.printLongValId lvi
d353 2
a354 2
	| Absyn.APPexp (e1, e2) => "(" ^ (unparseExp e1) ^ " " ^ (unparseExp e2) ^ ")"
	| Absyn.TYPEDexp (e, ty) => (unparseExp e) ^ ":" ^ (unparseTy ty)
a358 1
	| Absyn.TEN15exp _ => Crash.impossible"Absyn.TEN15exp"
@


1.5
log
@Added integer parameter
@
text
@d3 3
d114 1
a114 1
      | Absyn.RAISEexp (exp,_) => 
d116 2
a117 2
      | Absyn.FNexp (match,_,_) =>
	  S.list (S.ATOM "FNexp" :: detreeMatch match)
@


1.4
log
@Fixed inexhaustive matches
@
text
@d2 4
a5 1
$Log:	_absynprint.sml,v $
a16 1
require "absynprint";
d19 3
d28 13
a40 9
functor AbsynPrint (structure Sexpr : SEXPR
		    structure Crash : CRASH
		    structure IdentPrint : IDENTPRINT
		    structure Absyn : ABSYN
		    structure Ident : IDENT
                    structure Types : TYPES
		    sharing Absyn.Datatypes = Types.Datatypes
		    sharing Absyn.IdentClass = Ident
		    sharing Absyn.IdentClass = IdentPrint.Ident) : ABSYNPRINT =
d256 1
a256 1
	num_labs (length all) all []
@


1.3
log
@Tidied up unparse_ty a bit: empty type-arg lists not printed, tuples spaced.
@
text
@d3 3
d12 1
d16 1
d24 1
d106 1
d342 1
@


1.2
log
@> Updated to handle extra type ref field in HANDLEexp
@
text
@d3 3
d251 1
a251 1
	      tuple_print "*" unparseTy new
d260 2
a261 1
	| Absyn.APPty (tyseq, ltc) =>
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d91 1
a91 1
      | Absyn.HANDLEexp (exp,match) =>
@
