head	1.17;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.10
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.17
	MLWorks_20c0_1998_08_04:1.17
	MLWorks_20b2c2_1998_06_19:1.17
	MLWorks_20b2_Windows_1998_06_12:1.17
	MLWorks_20b1c1_1998_05_07:1.17
	MLWorks_20b0_1998_04_07:1.17
	MLWorks_20b0_1998_03_20:1.17
	MLWorks_20m2_1998_02_16:1.17
	MLWorks_20m1_1997_10_23:1.17
	MLWorks_11r1:1.17.7.1.1.1.1
	MLWorks_workspace_97:1.17.9
	MLWorks_dt_wizard:1.17.8
	MLWorks_11c0_1997_09_09:1.17.7.1.1.1
	MLWorks_10r3:1.17.7.1.3
	MLWorks_10r2_551:1.17.7.1.2
	MLWorks_11:1.17.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.17.7.1
	MLWorks_20m0_1997_06_20:1.17
	MLWorks_1_0_r2c2_1997_06_14:1.17.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.17.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.17.7
	MLWorks_BugFix_1997_04_24:1.17
	MLWorks_1_0_r2_Win32_1997_04_11:1.17
	MLWorks_1_0_r2_Unix_1997_04_04:1.17
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.17.5.1.1
	MLWorks_gui_1996_12_18:1.17.6
	MLWorks_1_0_Win32_1996_12_17:1.17.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.17.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.17.3.1
	MLWorks_1_0_Irix_1996_11_28:1.17.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.17.4
	MLWorks_1_0_Unix_1996_11_14:1.17.3
	MLWorks_Open_Beta2_1996_10_11:1.17.2
	MLWorks_License_dev:1.17.1
	MLWorks_1_open_beta_1996_09_13:1.16.1
	MLWorks_Open_Beta_1996_08_22:1.16
	MLWorks_Beta_1996_07_02:1.16
	MLWorks_Beta_1996_06_07:1.16
	MLWorks_Beta_1996_06_06:1.16
	MLWorks_Beta_1996_06_05:1.16
	MLWorks_Beta_1996_06_03:1.16
	MLWorks_Beta_1996_05_31:1.16
	MLWorks_Beta_1996_05_30:1.16
	ML_beta_release_12/08/94:1.10
	ML_beta_release_03/08/94:1.10
	ML_revised_beta_release_25/05/94:1.10
	ML_final_beta_release_02/03/94:1.9
	mlworks-28-01-1994:1.8
	Release:1.8
	mlworks-beta-01-09-1993:1.8
	MLWorks-1-0-4-29/01/1993:1.8
	MLWorks-1-0-3-21/12/1992:1.8
	MLWorks-1-0-2-15/12/1992:1.7
	MLWorks-1-0-1-04/12/1992:1.7
	checkpoint_17_08_92:1.6
	Ten15_release_19-11-91:1.3.1.1
	Ten15_release_21-08-91:1.3
	Ten15_release_19-08-91:1.3
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.17
date	96.10.04.13.15.29;	author matthew;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1
	1.17.5.1
	1.17.6.1
	1.17.7.1
	1.17.8.1
	1.17.9.1
	1.17.10.1;
next	1.16;

1.16
date	95.09.08.17.42.00;	author daveb;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	95.07.27.16.25.00;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	95.07.24.15.51.48;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	95.07.19.15.17.53;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	95.07.19.09.42.11;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	95.07.13.11.35.10;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	94.05.04.12.29.40;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	93.12.03.11.39.48;	author nosa;	state Exp;
branches;
next	1.8;

1.8
date	92.12.17.16.33.29;	author matthew;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	92.09.15.17.09.40;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.02.27.17.27.20;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.11.21.15.58.49;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.11.19.12.16.18;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.24.12.16.49;	author davida;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	91.07.16.15.48.43;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.10.56.14;	author colin;	state Exp;
branches;
next	;

1.3.1.1
date	91.11.19.11.06.04;	author jont;	state Exp;
branches;
next	;

1.8.1.1
date	92.12.17.16.33.29;	author jont;	state Exp;
branches;
next	;

1.16.1.1
date	96.09.13.11.08.55;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.10.07.15.59.55;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.10.17.11.18.15;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.11.14.12.41.47;	author hope;	state Exp;
branches
	1.17.3.1.1.1;
next	;

1.17.3.1.1.1
date	96.11.28.14.53.41;	author hope;	state Exp;
branches;
next	;

1.17.4.1
date	96.11.22.18.02.14;	author hope;	state Exp;
branches;
next	;

1.17.5.1
date	96.12.17.17.41.09;	author hope;	state Exp;
branches
	1.17.5.1.1.1;
next	;

1.17.5.1.1.1
date	97.02.24.11.29.21;	author hope;	state Exp;
branches;
next	;

1.17.6.1
date	96.12.18.09.35.06;	author hope;	state Exp;
branches;
next	;

1.17.7.1
date	97.05.12.10.27.07;	author hope;	state Exp;
branches
	1.17.7.1.1.1
	1.17.7.1.2.1
	1.17.7.1.3.1;
next	;

1.17.7.1.1.1
date	97.07.28.18.13.08;	author daveb;	state Exp;
branches
	1.17.7.1.1.1.1.1;
next	;

1.17.7.1.1.1.1.1
date	97.10.07.11.38.11;	author jkbrook;	state Exp;
branches;
next	;

1.17.7.1.2.1
date	97.09.08.17.06.27;	author daveb;	state Exp;
branches;
next	;

1.17.7.1.3.1
date	97.09.09.14.01.51;	author daveb;	state Exp;
branches;
next	;

1.17.8.1
date	97.09.10.19.16.16;	author brucem;	state Exp;
branches;
next	;

1.17.9.1
date	97.09.11.20.46.16;	author daveb;	state Exp;
branches;
next	;

1.17.10.1
date	99.04.01.17.51.34;	author daveb;	state Exp;
branches;
next	;


desc
@Datatypes for identifier classes and special constants
@


1.17
log
@[Bug #1636]
Removing IDENTCLASS
@
text
@(* ident.sml the signature *)
(*
$Log: ident.sml,v $
 * Revision 1.16  1995/09/08  17:42:00  daveb
 * Added realint_tyvar for abs and ~; removed real_tyvar and int_tyvar.
 *
Revision 1.15  1995/07/27  16:25:00  jont
Add tyvars for dealing with overloading on ints and words

Revision 1.14  1995/07/24  15:51:48  jont
Add WORD SCon

Revision 1.13  1995/07/19  15:17:53  jont
Remove scon_eqrep from interface

Revision 1.12  1995/07/19  09:42:11  jont
Add special constant char type

Revision 1.11  1995/07/13  11:35:10  matthew
Moving Compiler.identifier type to Ident

Revision 1.10  1994/05/04  12:29:40  daveb
Added tyvars for new overloading scheme.

Revision 1.9  1993/12/03  11:39:48  nosa
TYCON' for type function functions in lambda code for Modules Debugger.

Revision 1.8  1992/12/17  16:33:29  matthew
Changed int and real scons to carry a location around

Revision 1.7  1992/09/15  17:09:40  jont
Added strict less than functions for all the symbol types

Revision 1.6  1992/02/27  17:27:20  jont
Added equality functions for all symbol based objects

Revision 1.5  1991/11/21  15:58:49  jont
Added copyright message

Revision 1.4  91/11/19  12:16:18  jont
Merging in comments from Ten15 branch to main trunk

Revision 1.3.1.1  91/11/19  11:06:04  jont
Added comments for DRA on functions

Revision 1.3  91/07/24  12:16:49  davida
Added equality of representation test on SCons

Revision 1.2  91/07/16  15:48:43  colin
Added function valid_eq which compares valids by symbol name only

Revision 1.1  91/06/07  10:56:14  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

(*

This module defines types for each class of identifier in SML (see
chapters 2 and 3 of the Definition). `Var', `Con', and `Excon' are
treated as subtypes (value constructors) of a `ValId' type, which
makes the type of a VarEnv much simpler.

Each type is simply an encapsulation of a Symbol (see
basics/symbol.sml), with the exception of TyVars, which also have
imperative and equality attributes (which could be determined from the
symbol name, but which are required so often that it is much cheaper
to evaluate them when the symbol is read and keep them separateyl).

Each type is provided with an ordering function (which is simply
symbol-order).

ValId's also have an equality function valid_eq, which tests equality
of the symbol names only. This is used in ValEnv's, when one must keep
only the most recently bound identifier class for any symbol.

Also defined here is the notion of a Path, which is essentially a
symbol list used to locate objects within structures, and a few
functions to manipulate them.

Finally, the values ref_valid and eq_valid are the ValId's for "ref"
and "=" respectively.

*)

require "symbol";
require "location";

signature IDENT =
  sig
    structure Symbol : SYMBOL
    structure Location : LOCATION

    (* first we have the identifiers in the core language *)
          
    datatype ValId =
      VAR of Symbol.Symbol
    | CON of Symbol.Symbol
    | EXCON of Symbol.Symbol
    | TYCON' of Symbol.Symbol

    val valid_eq : ValId * ValId -> bool
    val valid_order : ValId * ValId -> bool
    val valid_lt : ValId * ValId -> bool

    (* the two bools are for equality and imperative attributes *)

    datatype TyVar = TYVAR of Symbol.Symbol * bool * bool

    val tyvar_eq : TyVar * TyVar -> bool
    val tyvar_order : TyVar * TyVar -> bool
    val tyvar_lt : TyVar * TyVar -> bool

    val int_literal_tyvar : TyVar
    val real_literal_tyvar : TyVar
    val word_literal_tyvar : TyVar
    val real_tyvar : TyVar
    val wordint_tyvar : TyVar
    val realint_tyvar : TyVar
    val num_tyvar : TyVar
    val numtext_tyvar : TyVar

    datatype TyCon = TYCON of Symbol.Symbol    
    datatype Lab = LAB of Symbol.Symbol    
    datatype StrId = STRID of Symbol.Symbol    

    val tycon_eq : TyCon * TyCon -> bool
    val tycon_order : TyCon * TyCon -> bool 
    val tycon_lt : TyCon * TyCon -> bool 
    val lab_eq : Lab * Lab -> bool
    val lab_order : Lab * Lab -> bool
    val lab_lt : Lab * Lab -> bool
    val strid_eq : StrId * StrId -> bool
    val strid_order : StrId * StrId -> bool
    val strid_lt : StrId * StrId -> bool

    (* and then for modules *)

    datatype SigId = SIGID of Symbol.Symbol
    datatype FunId = FUNID of Symbol.Symbol

    val sigid_eq : SigId * SigId -> bool
    val sigid_order : SigId * SigId -> bool
    val sigid_lt : SigId * SigId -> bool
    val funid_eq : FunId * FunId -> bool
    val funid_order : FunId * FunId -> bool
    val funid_lt : FunId * FunId -> bool

    (* for long identifiers *)

    (* we define Path as a concrete datatype so as to have a constructor for
       an empty path which is useful for pattern matching against. This
       constructor should be only used for this purpose - in all other cases
       the functions followPath and followPath' should be used rather than
       explicitly destructuring the paths *)

    datatype Path = NOPATH | PATH of Symbol.Symbol * Path

    val followPath : (StrId * 'a -> 'a) -> Path * 'a -> 'a
    val followPath' : 
      ((StrId * 'a -> 'b) * (StrId * 'b -> 'b)) -> Path * 'a -> 'b
    val mkPath : Symbol.Symbol list -> Path
    val isemptyPath : Path -> bool

    datatype LongValId = LONGVALID of Path * ValId
    datatype LongTyCon = LONGTYCON of Path * TyCon
    datatype LongStrId = LONGSTRID of Path * StrId

    (* special constants form a pseudo identifier class as they also appear in
       the abstract syntax tree in the same way that real identifiers do *)

    datatype SCon = INT of (string * Location.T) | REAL of (string * Location.T) | STRING of string | CHAR of string | WORD of (string * Location.T)

    val ref_valid : ValId
    val eq_valid  : ValId

    datatype Identifier =
      VALUE of ValId |
      TYPE of TyCon |
      STRUCTURE of StrId |
      SIGNATURE of SigId |
      FUNCTOR of FunId

    val dummy_identifier: Identifier
    val compare_identifiers : Identifier * Identifier -> bool

  end

@


1.17.10.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.17.9.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.17.8.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.17.7.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.17.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.17.7.1  1997/05/12  10:27:07  hope
 * branched from 1.17
 *
@


1.17.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.17.7.1  1997/05/12  10:27:07  hope
 * branched from 1.17
 *
@


1.17.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.17.7.1  1997/05/12  10:27:07  hope
 * branched from 1.17
 *
@


1.17.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.17.7.1.1.1  1997/07/28  18:13:08  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.17.6.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.17.5.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.17.5.1.1.1
log
@branched from 1.17.5.1
@
text
@a3 3
 * Revision 1.17.5.1  1996/12/17  17:41:09  hope
 * branched from 1.17
 *
@


1.17.4.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.17.3.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.17.3.1.1.1
log
@branched from 1.17.3.1
@
text
@a3 3
 * Revision 1.17.3.1  1996/11/14  12:41:47  hope
 * branched from 1.17
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/10/04  13:15:29  matthew
 * [Bug #1636]
 * Removing IDENTCLASS
 *
@


1.16
log
@Added realint_tyvar for abs and ~; removed real_tyvar and int_tyvar.
@
text
@d4 3
a188 8


signature IDENTCLASS =
  sig
    eqtype ValId and LongValId and TyVar and TyCon and LongTyCon
    and Lab and StrId and LongStrId and SigId and FunId and SCon
  end

@


1.16.1.1
log
@branched from 1.16
@
text
@a3 3
 * Revision 1.16  1995/09/08  17:42:00  daveb
 * Added realint_tyvar for abs and ~; removed real_tyvar and int_tyvar.
 *
@


1.15
log
@Add tyvars for dealing with overloading on ints and words
@
text
@d4 3
d111 1
a111 1
    val int_tyvar : TyVar
a112 1
    val real_tyvar : TyVar
a113 1
    val word_tyvar : TyVar
d115 3
a119 1
    val wordint_tyvar : TyVar
@


1.14
log
@Add WORD SCon
@
text
@d4 3
d112 2
d116 1
@


1.13
log
@Remove scon_eqrep from interface
@
text
@d4 3
d161 1
a161 1
    datatype SCon = INT of (string * Location.T) | REAL of (string * Location.T) | STRING of string | CHAR of string
@


1.12
log
@Add special constant char type
@
text
@d4 3
a159 3
    val scon_eqrep : SCon * SCon -> bool  (* equality by representation:  *)
					  (* equates some subset of equal *)
					  (* pairs of SCon's.		  *)
@


1.11
log
@Moving Compiler.identifier type to Ident
@
text
@d4 3
d14 1
a14 1
> Changed int and real scons to carry a location around
d155 1
a155 1
    datatype SCon = INT of (string * Location.T) | REAL of (string * Location.T) | STRING of string
@


1.10
log
@Added tyvars for new overloading scheme.
@
text
@d4 3
d159 10
@


1.9
log
@TYCON' for type function functions in lambda code for Modules Debugger.
@
text
@d4 3
d93 6
@


1.8
log
@> Changed int and real scons to carry a location around
@
text
@d4 3
d77 1
@


1.8.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.8  1992/12/17  16:33:29  matthew
> Changed int and real scons to carry a location around

@


1.7
log
@Added strict less than functions for all the symbol types
@
text
@d4 3
d61 1
d66 1
d136 1
a136 1
    datatype SCon = INT of string | REAL of string | STRING of string
@


1.6
log
@Added equality functions for all symbol based objects
@
text
@d4 3
d72 1
d80 1
d88 1
d91 1
d94 1
d103 1
d106 1
@


1.5
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	ident.sml,v $
d74 1
d81 3
a83 1
    val tycon_order : TyCon * TyCon -> bool
d85 1
d93 1
d95 1
a136 1

@


1.4
log
@Merging in comments from Ten15 branch to main trunk
@
text
@d1 1
d4 3
d19 1
@


1.3
log
@Added equality of representation test on SCons
@
text
@d3 6
d16 30
@


1.3.1.1
log
@Added comments for DRA on functions
@
text
@a2 3
Revision 1.3  91/07/24  12:16:49  davida
Added equality of representation test on SCons

a9 30

(*

This module defines types for each class of identifier in SML (see
chapters 2 and 3 of the Definition). `Var', `Con', and `Excon' are
treated as subtypes (value constructors) of a `ValId' type, which
makes the type of a VarEnv much simpler.

Each type is simply an encapsulation of a Symbol (see
basics/symbol.sml), with the exception of TyVars, which also have
imperative and equality attributes (which could be determined from the
symbol name, but which are required so often that it is much cheaper
to evaluate them when the symbol is read and keep them separateyl).

Each type is provided with an ordering function (which is simply
symbol-order).

ValId's also have an equality function valid_eq, which tests equality
of the symbol names only. This is used in ValEnv's, when one must keep
only the most recently bound identifier class for any symbol.

Also defined here is the notion of a Path, which is essentially a
symbol list used to locate objects within structures, and a few
functions to manipulate them.

Finally, the values ref_valid and eq_valid are the ValId's for "ref"
and "=" respectively.

*)

@


1.2
log
@Added function valid_eq which compares valids by symbol name only
@
text
@d3 3
d73 3
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d20 1
@
