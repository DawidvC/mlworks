head	1.51;
access;
symbols
	MLW_daveb_inline_1_4_99:1.51.3
	MLWorks_21c0_1999_03_25:1.51
	MLWorks_20c1_1998_08_20:1.51
	MLWorks_20c0_1998_08_04:1.51
	MLWorks_20b2c2_1998_06_19:1.51
	MLWorks_20b2_Windows_1998_06_12:1.51
	MLWorks_20b1c1_1998_05_07:1.51
	MLWorks_20b0_1998_04_07:1.51
	MLWorks_20b0_1998_03_20:1.51
	MLWorks_20m2_1998_02_16:1.51
	MLWorks_20m1_1997_10_23:1.51
	MLWorks_11r1:1.50.5.1.1.1.1
	MLWorks_workspace_97:1.51.2
	MLWorks_dt_wizard:1.51.1
	MLWorks_11c0_1997_09_09:1.50.5.1.1.1
	MLWorks_10r3:1.50.5.1.3
	MLWorks_10r2_551:1.50.5.1.2
	MLWorks_11:1.50.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.50.5.1
	MLWorks_20m0_1997_06_20:1.51
	MLWorks_1_0_r2c2_1997_06_14:1.50.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.50.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.50.5
	MLWorks_BugFix_1997_04_24:1.50
	MLWorks_1_0_r2_Win32_1997_04_11:1.50
	MLWorks_1_0_r2_Unix_1997_04_04:1.50
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.50.3.1.1
	MLWorks_gui_1996_12_18:1.50.4
	MLWorks_1_0_Win32_1996_12_17:1.50.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.50.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.50.1.1
	MLWorks_1_0_Irix_1996_11_28:1.50.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.50.2
	MLWorks_1_0_Unix_1996_11_14:1.50.1
	MLWorks_Open_Beta2_1996_10_11:1.49.1
	MLWorks_License_dev:1.48.1
	MLWorks_1_open_beta_1996_09_13:1.45.1
	MLWorks_Open_Beta_1996_08_22:1.45
	MLWorks_Beta_1996_07_02:1.45
	MLWorks_Beta_1996_06_07:1.45
	MLWorks_Beta_1996_06_06:1.45
	MLWorks_Beta_1996_06_05:1.45
	MLWorks_Beta_1996_06_03:1.45
	MLWorks_Beta_1996_05_31:1.45
	MLWorks_Beta_1996_05_30:1.45
	ML_beta_release_12/08/94:1.35
	ML_beta_release_03/08/94:1.35
	ML_revised_beta_release_25/05/94:1.35
	ML_final_beta_release_02/03/94:1.35
	mlworks-28-01-1994:1.34
	Release:1.31
	mlworks-beta-01-09-1993:1.31
	MLWorks-1-0-4-29/01/1993:1.21
	MLWorks-1-0-3-21/12/1992:1.21
	MLWorks-1-0-2-15/12/1992:1.20
	MLWorks-1-0-1-04/12/1992:1.19
	checkpoint_17_08_92:1.15
	Ten15_release_19-11-91:1.4.1.1
	Ten15_release_21-08-91:1.4
	Ten15_release_19-08-91:1.4
	ten15_release:1.4;
locks; strict;
comment	@ * @;


1.51
date	97.05.01.12.25.23;	author jont;	state Exp;
branches
	1.51.1.1
	1.51.2.1
	1.51.3.1;
next	1.50;

1.50
date	96.10.28.17.28.04;	author andreww;	state Exp;
branches
	1.50.1.1
	1.50.2.1
	1.50.3.1
	1.50.4.1
	1.50.5.1;
next	1.49;

1.49
date	96.10.04.17.56.20;	author andreww;	state Exp;
branches
	1.49.1.1;
next	1.48;

1.48
date	96.10.04.10.55.22;	author matthew;	state Exp;
branches
	1.48.1.1;
next	1.47;

1.47
date	96.09.30.12.37.53;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	96.09.18.11.53.39;	author andreww;	state Exp;
branches;
next	1.45;

1.45
date	96.03.29.12.09.29;	author matthew;	state Exp;
branches
	1.45.1.1;
next	1.44;

1.44
date	96.03.26.16.23.48;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	96.01.16.12.21.29;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.12.27.10.39.13;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	95.12.05.12.21.16;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	95.11.22.09.09.04;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	95.09.05.14.13.26;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	95.08.31.13.13.07;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.01.17.12.51.10;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	94.09.14.11.41.26;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	94.02.28.05.52.22;	author nosa;	state Exp;
branches;
next	1.34;

1.34
date	93.12.03.16.36.08;	author nickh;	state Exp;
branches;
next	1.33;

1.33
date	93.11.25.09.31.30;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.09.03.10.20.01;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	93.08.12.14.55.33;	author daveb;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	93.08.06.13.13.28;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.07.09.11.52.53;	author nosa;	state Exp;
branches;
next	1.28;

1.28
date	93.07.02.16.03.13;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	93.05.20.11.59.22;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.04.06.11.52.45;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.03.09.11.17.15;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.02.16.17.44.10;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.02.08.15.36.41;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.01.25.18.28.40;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	92.12.17.17.00.23;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	92.12.08.15.15.30;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.10.14.12.06.39;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.10.09.13.38.55;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.09.08.15.14.44;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	92.09.04.08.26.08;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.08.14.11.00.14;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	92.08.04.11.42.57;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.08.04.11.42.57;	author davidt;	state Exp;
branches;
next	1.12;

1.12
date	92.06.29.10.54.24;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.06.15.09.30.45;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.06.11.08.24.31;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.05.19.15.15.09;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.04.13.15.50.14;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.02.04.11.53.10;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.11.22.17.08.42;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.11.21.15.57.54;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.06.27.13.39.59;	author colin;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	91.06.27.09.04.02;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	91.06.19.18.38.00;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.10.55.59;	author colin;	state Exp;
branches;
next	;

1.4.1.1
date	91.11.19.11.07.06;	author jont;	state Exp;
branches;
next	;

1.31.1.1
date	93.08.12.14.55.33;	author jont;	state Exp;
branches;
next	;

1.45.1.1
date	96.09.13.11.08.46;	author hope;	state Exp;
branches;
next	;

1.48.1.1
date	96.10.07.15.59.45;	author hope;	state Exp;
branches;
next	;

1.49.1.1
date	96.10.17.11.18.06;	author hope;	state Exp;
branches;
next	;

1.50.1.1
date	96.11.14.12.41.39;	author hope;	state Exp;
branches
	1.50.1.1.1.1;
next	;

1.50.1.1.1.1
date	96.11.28.14.53.32;	author hope;	state Exp;
branches;
next	;

1.50.2.1
date	96.11.22.18.02.05;	author hope;	state Exp;
branches;
next	;

1.50.3.1
date	96.12.17.17.41.01;	author hope;	state Exp;
branches
	1.50.3.1.1.1;
next	;

1.50.3.1.1.1
date	97.02.24.11.28.58;	author hope;	state Exp;
branches;
next	;

1.50.4.1
date	96.12.18.09.34.56;	author hope;	state Exp;
branches;
next	;

1.50.5.1
date	97.05.12.10.26.58;	author hope;	state Exp;
branches
	1.50.5.1.1.1
	1.50.5.1.2.1
	1.50.5.1.3.1;
next	;

1.50.5.1.1.1
date	97.07.28.18.13.00;	author daveb;	state Exp;
branches
	1.50.5.1.1.1.1.1;
next	;

1.50.5.1.1.1.1.1
date	97.10.07.11.38.01;	author jkbrook;	state Exp;
branches;
next	;

1.50.5.1.2.1
date	97.09.08.17.06.17;	author daveb;	state Exp;
branches;
next	;

1.50.5.1.3.1
date	97.09.09.14.01.42;	author daveb;	state Exp;
branches;
next	;

1.51.1.1
date	97.09.10.19.16.07;	author brucem;	state Exp;
branches;
next	;

1.51.2.1
date	97.09.11.20.45.59;	author daveb;	state Exp;
branches;
next	;

1.51.3.1
date	99.04.01.17.51.40;	author daveb;	state Exp;
branches;
next	;


desc
@Abstract Syntax Datatype
@


1.51
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* absyn.sml the signature *)
(*
$Log: absyn.sml,v $
 * Revision 1.50  1996/10/28  17:28:04  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
 * Revision 1.49  1996/10/04  17:56:20  andreww
 * [Bug #1592]
 * threading location argument to local declaration expression
 * syntax.
 * /
 *

 * Revision 1.48  1996/10/04  10:55:22  matthew
 * [Bug #1622]
 * Adding some locations
 *
 * Revision 1.47  1996/09/30  12:37:53  matthew
 * Removing require of module_id
 *
 * Revision 1.46  1996/09/18  11:53:39  andreww
 * [Bug #1577]
 * Adding production for datatype replication.
 *
 * Revision 1.45  1996/03/29  12:09:29  matthew
 * Adding WHEREsigxp properly
 *
 * Revision 1.44  1996/03/26  16:23:48  matthew
 * Adding explicit tyvars field to VALdec
 *
 * Revision 1.43  1996/01/16  12:21:29  daveb
 * Added location information to SIGNATUREtopdec.
 *
Revision 1.42  1995/12/27  10:39:13  jont
Removing Option in favour of MLWorks.Option

Revision 1.41  1995/12/05  12:21:16  jont
Add functions to check strdecs and strexps for the location of
free imperative type variable errors

Revision 1.40  1995/11/22  09:09:04  daveb
Changed REQUIREtopdec to take a string instead of a module_id.

Revision 1.39  1995/09/05  14:13:26  daveb
Added types for different lengths of words, ints and reals.

Revision 1.38  1995/08/31  13:13:07  jont
Add location info to wild pats for use in redundancy warnings

Revision 1.37  1995/01/17  12:51:10  matthew
Rationalizing debugger

Revision 1.36  1994/09/14  11:41:26  matthew
Abstraction of debug information

Revision 1.35  1994/02/28  05:52:22  nosa
Type function, debugger structure, and structure recording for Modules Debugger.

Revision 1.34  1993/12/03  16:36:08  nickh
Added location information to COERCEexp.

Revision 1.33  1993/11/25  09:31:30  matthew
Added fixity annotations to APPexps and APPpats

Revision 1.32  1993/09/03  10:20:01  nosa
Runtime-instance in VALpats and LAYEREDpats and Compilation-instance
in VALexps for polymorphic debugger.

Revision 1.31  1993/08/12  14:55:33  daveb
Require declarations now take moduleids instead of strings.

Revision 1.30  1993/08/06  13:13:28  matthew
Added location information to matches

Revision 1.29  1993/07/09  11:52:53  nosa
structure Option.

Revision 1.28  1993/07/02  16:03:13  daveb
Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.

Revision 1.27  1993/05/20  11:59:22  matthew
Added code for abstractions.

Revision 1.26  1993/04/06  11:52:45  matthew
Added MLVALUEexp.  Just used internally for now.

Revision 1.25  1993/03/09  11:17:15  matthew
> Removed Datatypes substructure and replaced with Ident substructure
 and Type and Structure types.

Revision 1.24  1993/02/16  17:44:10  matthew
Added syntax for dynamic and coerce expressions

Revision 1.23  1993/02/08  15:36:41  matthew
Removed nameset structure and ref nameset from FunBind (which wasn't used)

Revision 1.22  1993/01/25  18:28:40  matthew
Changed Interface ref to Str ref in sigexps

Revision 1.21  1992/12/17  17:00:23  matthew
> Changed int and real scons to carry a location around

Revision 1.20  1992/12/08  15:15:30  jont
Removed a number of duplicated signatures and structures

Revision 1.19  1992/10/14  12:06:39  richard
Added location information to the `require' topdec.

Revision 1.18  1992/10/09  13:38:55  clive
Tynames now have a slot recording their definition point

Revision 1.17  1992/09/08  15:14:44  matthew
Added locations to some datatypes.

Revision 1.16  1992/09/04  08:26:08  richard
Installed central error reporting mechanism.

Revision 1.15  1992/08/14  11:00:14  matthew
Really added the function this time.

Revision 1.14  1992/08/04  11:42:57  matthew
Added Source_marks_to_tuple function

Revision 1.13  1992/08/04  11:42:57  davidt
Changed cut down signatures to full versions.

Revision 1.12  1992/06/29  10:54:24  clive
Added a slot to appexp for debugging type information for function call type

Revision 1.11  1992/06/15  09:30:45  clive
Added debug info to handlers

Revision 1.10  1992/06/11  08:24:31  clive
Added some maarks for typechecker error messages

Revision 1.9  1992/05/19  15:15:09  clive
Added marks for better error reporting

Revision 1.8  1992/04/13  15:50:14  clive
First version of the profiler

Revision 1.7  1992/02/04  11:53:10  jont
Removed a couple of irrelevant requires

Revision 1.6  1991/11/22  17:08:42  jont
Removed opens

Revision 1.5  91/11/21  15:57:54  jont
Added copyright message

Revision 1.4  91/06/27  13:39:59  colin
added Interface annotation for signature expressions

Revision 1.3  91/06/27  09:04:02  nickh
Added REQUIREtopdec of string.

Revision 1.2  91/06/19  18:38:00  colin
Added a type ref to HANDLEexp for ten15 code generator

Revision 1.1  91/06/07  10:55:59  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "ident";
require "../typechecker/datatypes";

signature ABSYN =
sig

  structure Set : sig type ''a Set val empty_set : ''a Set end
  structure Ident : IDENT
  structure Datatypes : DATATYPES

  type Type 
  type Tyfun 
  type Instance
  type DebuggerStr
  type Structure
  type RuntimeInfo
  type InstanceInfo

  type options             (* this is included for Printing datatype
                              replications only *)
  val print_type: options -> Type -> string

  val nullType : Type
  val nullTyfun : Tyfun
  val nullDebuggerStr : DebuggerStr
  val nullRuntimeInfo : RuntimeInfo
  val nullInstanceInfo : InstanceInfo

  datatype Exp =
    SCONexp of Ident.SCon * Type ref | 
    VALexp of Ident.LongValId * Type ref * Ident.Location.T * (InstanceInfo * Instance ref option) ref |
    RECORDexp of (Ident.Lab * Exp) list|
    LOCALexp of Dec * Exp * Ident.Location.T |
    APPexp of Exp * Exp * Ident.Location.T * Type ref * bool |
    TYPEDexp of Exp * Ty * Ident.Location.T |
    HANDLEexp of Exp * Type ref * (Pat * Exp * Ident.Location.T) list * Ident.Location.T * string |
    RAISEexp of Exp * Ident.Location.T  |
    FNexp of (Pat * Exp * Ident.Location.T) list * Type ref * string * Ident.Location.T |
    DYNAMICexp of (Exp * Ident.TyVar Set.Set * (Type * int * Ident.TyVar Set.Set) ref) |
    COERCEexp of (Exp * Ty * Type ref * Ident.Location.T) |
    MLVALUEexp of MLWorks.Internal.Value.T

  and Dec = 
	  (* the two lists in VALdec list the bindings before and after
	   the first occurence of rec. tyvarset is used to hold
	   information about tyvars scoped at this particular value
	   declaration (see 4.6 in The Definition *)

     VALdec of (Pat * Exp * Ident.Location.T) list *  (Pat * Exp * Ident.Location.T) list *
     Ident.TyVar Set.Set * Ident.TyVar list |
     TYPEdec of (Ident.TyVar list * Ident.TyCon * Ty * Tyfun ref option) list |
     DATATYPEdec of Ident.Location.T *
                    (Ident.TyVar list * Ident.TyCon *
		     Type ref * Tyfun ref option * 
		     ((Ident.ValId * Type ref) *
		      Ty option) list) list |
     DATATYPErepl of Ident.Location.T *
                     (Ident.TyCon * Ident.LongTyCon) *
                      Datatypes.Valenv option ref|
     ABSTYPEdec of Ident.Location.T *
                   (Ident.TyVar list * Ident.TyCon *
		    Type ref * Tyfun ref option * 
		    ((Ident.ValId * Type ref) *
		     Ty option) list) list * Dec |
     EXCEPTIONdec of ExBind list|
     LOCALdec of Dec * Dec |
     OPENdec of Ident.LongStrId list * Ident.Location.T |
     SEQUENCEdec of Dec list

  and ExBind = 
    NEWexbind of ((Ident.ValId * Type ref) * Ty option * Ident.Location.T * string) |
    OLDexbind of ((Ident.ValId * Type ref) *
		  Ident.LongValId * Ident.Location.T * string)

  and Pat =
    WILDpat of Ident.Location.T |
    SCONpat of Ident.SCon * Type ref |
    VALpat of (Ident.LongValId * (Type ref * RuntimeInfo ref))
    * Ident.Location.T |
    RECORDpat of (Ident.Lab * Pat) list * bool * Type ref |
    APPpat of (Ident.LongValId * Type ref) * Pat * Ident.Location.T * bool |
    TYPEDpat of Pat * Ty  * Ident.Location.T |
    LAYEREDpat of (Ident.ValId * (Type ref * RuntimeInfo ref)) * Pat

  and Ty =
    TYVARty of Ident.TyVar |
    RECORDty of (Ident.Lab * Ty) list |
    APPty of Ty list * Ident.LongTyCon * Ident.Location.T |
    FNty of Ty * Ty

  (* The following datatypes are for the modules syntax classes *)
  (* APPstrexp, STRUCTUREstrdec,  ABSTRACTIONstrdec and FUNBIND each have
     a bool ref argument, which is for the type checker to mark signature
     matches that require some extra work in the lambda translator
     (when EXCONs are matched against value specifications). *)

  datatype StrExp =
    NEWstrexp of StrDec |
    OLDstrexp of Ident.LongStrId * Ident.Location.T * Structure option ref option |
    APPstrexp of Ident.FunId * StrExp * bool ref * Ident.Location.T * DebuggerStr ref option |
    CONSTRAINTstrexp of StrExp * SigExp * bool * bool ref * Ident.Location.T |
    LOCALstrexp of StrDec * StrExp

  and StrDec =
    DECstrdec of Dec |
    STRUCTUREstrdec of
      (Ident.StrId * (SigExp * bool) option * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref option * Structure option ref option) list
      |
    ABSTRACTIONstrdec of
      (Ident.StrId * (SigExp * bool) option * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref option * Structure option ref option) list |
    LOCALstrdec of StrDec * StrDec |
    SEQUENCEstrdec of StrDec list

  and SigExp =
    NEWsigexp of Spec * Structure option ref  | 
    OLDsigexp of Ident.SigId * Structure option ref * Ident.Location.T  |
    WHEREsigexp of (SigExp * (Ident.TyVar list * Ident.LongTyCon * Ty * Ident.Location.T) list)

  and Spec =
    VALspec of (Ident.ValId * Ty * Ident.TyVar Set.Set) list * Ident.Location.T |
    TYPEspec of (Ident.TyVar list * Ident.TyCon) list |
    EQTYPEspec of (Ident.TyVar list * Ident.TyCon) list |
    DATATYPEspec of (Ident.TyVar list * Ident.TyCon *
		     (Ident.ValId * Ty option * Ident.Location.T) list) list |
    DATATYPEreplSpec of Ident.Location.T * Ident.TyCon * Ident.LongTyCon * 
                        (Ident.ValId * Type option * Ident.Location.T) list option ref |
    EXCEPTIONspec of (Ident.ValId * Ty option * Ident.Location.T) list |
    STRUCTUREspec of (Ident.StrId * SigExp) list |
    SHARINGspec of Spec * (SharEq * Ident.Location.T) list |
    LOCALspec of Spec * Spec |
    OPENspec of Ident.LongStrId list * Ident.Location.T |
    INCLUDEspec of SigExp * Ident.Location.T |
    SEQUENCEspec of Spec list

  and SharEq =
    STRUCTUREshareq of Ident.LongStrId list |
    TYPEshareq of Ident.LongTyCon list

  datatype SigBind = SIGBIND of (Ident.SigId * SigExp * Ident.Location.T) list
           
  datatype FunBind = 
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * (SigExp * bool) option *
		string * bool ref * Ident.Location.T * DebuggerStr ref option * Structure option ref option) list 

  datatype TopDec =
    STRDECtopdec of StrDec * Ident.Location.T |
    SIGNATUREtopdec of SigBind list * Ident.Location.T |
    FUNCTORtopdec of FunBind list * Ident.Location.T |
    REQUIREtopdec of string * Ident.Location.T

  val empty_tyvarset : Ident.TyVar Set.Set

  val expansivep : Exp -> bool
  val has_tyvar : Ty -> bool

  val check_strexp_for_free_imp :
    StrExp * Type -> Ident.Location.T option
  val check_strdec_for_free_imp :
    StrDec * Type -> Ident.Location.T option
end
@


1.51.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.51  1997/05/01  12:25:23  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.51.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.51  1997/05/01  12:25:23  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.51.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.51  1997/05/01  12:25:23  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.50
log
@[Bug #1708]
changing syntax of datatype replication.
@
text
@d4 4
d198 1
a198 1
    VALexp of Ident.LongValId * Type ref * Ident.Location.T * (InstanceInfo * Instance ref MLWorks.Option.option) ref |
d218 1
a218 1
     TYPEdec of (Ident.TyVar list * Ident.TyCon * Ty * Tyfun ref MLWorks.Option.option) list |
d221 1
a221 1
		     Type ref * Tyfun ref MLWorks.Option.option * 
d223 1
a223 1
		      Ty MLWorks.Option.option) list) list |
d229 1
a229 1
		    Type ref * Tyfun ref MLWorks.Option.option * 
d231 1
a231 1
		     Ty MLWorks.Option.option) list) list * Dec |
d238 1
a238 1
    NEWexbind of ((Ident.ValId * Type ref) * Ty MLWorks.Option.option * Ident.Location.T * string) |
d266 2
a267 2
    OLDstrexp of Ident.LongStrId * Ident.Location.T * Structure MLWorks.Option.option ref MLWorks.Option.option |
    APPstrexp of Ident.FunId * StrExp * bool ref * Ident.Location.T * DebuggerStr ref MLWorks.Option.option |
d274 2
a275 2
      (Ident.StrId * (SigExp * bool) MLWorks.Option.option * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref MLWorks.Option.option * Structure MLWorks.Option.option ref MLWorks.Option.option) list
d278 2
a279 2
      (Ident.StrId * (SigExp * bool) MLWorks.Option.option * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref MLWorks.Option.option * Structure MLWorks.Option.option ref MLWorks.Option.option) list |
d284 2
a285 2
    NEWsigexp of Spec * Structure MLWorks.Option.option ref  | 
    OLDsigexp of Ident.SigId * Structure MLWorks.Option.option ref * Ident.Location.T  |
d293 1
a293 1
		     (Ident.ValId * Ty MLWorks.Option.option * Ident.Location.T) list) list |
d296 1
a296 1
    EXCEPTIONspec of (Ident.ValId * Ty MLWorks.Option.option * Ident.Location.T) list |
d311 2
a312 2
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * (SigExp * bool) MLWorks.Option.option *
		string * bool ref * Ident.Location.T * DebuggerStr ref MLWorks.Option.option * Structure MLWorks.Option.option ref MLWorks.Option.option) list 
d326 1
a326 1
    StrExp * Type -> Ident.Location.T MLWorks.Option.option
d328 1
a328 1
    StrDec * Type -> Ident.Location.T MLWorks.Option.option
@


1.50.5.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:28:04  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.50.5.1  1997/05/12  10:26:58  hope
 * branched from 1.50
 *
@


1.50.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.50.5.1  1997/05/12  10:26:58  hope
 * branched from 1.50
 *
@


1.50.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.50.5.1  1997/05/12  10:26:58  hope
 * branched from 1.50
 *
@


1.50.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.50.5.1.1.1  1997/07/28  18:13:00  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.50.4.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:28:04  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.3.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:28:04  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.3.1.1.1
log
@branched from 1.50.3.1
@
text
@a3 3
 * Revision 1.50.3.1  1996/12/17  17:41:01  hope
 * branched from 1.50
 *
@


1.50.2.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:28:04  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.1.1
log
@branched from 1.50
@
text
@a3 4
 * Revision 1.50  1996/10/28  17:28:04  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
@


1.50.1.1.1.1
log
@branched from 1.50.1.1
@
text
@a3 3
 * Revision 1.50.1.1  1996/11/14  12:41:39  hope
 * branched from 1.50
 *
@


1.49
log
@[Bug #1592]
threading location argument to local declaration expression
syntax.
/
@
text
@d4 6
d221 1
a221 2
                     (Ident.TyVar list * Ident.TyCon *
                      Ident.LongTyCon) *
d290 1
a290 1
    DATATYPEreplSpec of Ident.Location.T * Ident.TyVar list * Ident.TyCon * Ident.LongTyCon * 
@


1.49.1.1
log
@branched from 1.49
@
text
@a3 6
 * Revision 1.49  1996/10/04  17:56:20  andreww
 * [Bug #1592]
 * threading location argument to local declaration expression
 * syntax.
 * /
 *
@


1.48
log
@[Bug #1622]
Adding some locations
@
text
@d4 5
d190 1
a190 1
    LOCALexp of Dec * Exp |
@


1.48.1.1
log
@branched from 1.48
@
text
@a3 4
 * Revision 1.48  1996/10/04  10:55:22  matthew
 * [Bug #1622]
 * Adding some locations
 *
@


1.47
log
@Removing require of module_id
@
text
@d4 3
d279 1
a279 1
		     (Ident.ValId * Ty MLWorks.Option.option) list) list |
d281 1
a281 1
                        (Ident.ValId * Type option) list option ref |
@


1.46
log
@[Bug #1577]
Adding production for datatype replication.
@
text
@d4 4
a150 1
require "module_id";
@


1.45
log
@Adding WHEREsigxp properly
@
text
@d4 3
d148 1
d155 1
d165 4
d203 4
d274 2
@


1.45.1.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1996/03/29  12:09:29  matthew
 * Adding WHEREsigxp properly
 *
@


1.44
log
@Adding explicit tyvars field to VALdec
@
text
@d4 3
d235 1
a235 1
    CONSTRAINTstrexp of StrExp * SigExp * bool * bool ref |
d253 1
a253 1
    WHEREsigexp of SigExp
d256 1
a256 1
    VALspec of (Ident.ValId * Ty * Ident.TyVar Set.Set) list |
d263 1
a263 1
    SHARINGspec of (SharEq * Ident.Location.T) list |
@


1.43
log
@Added location information to SIGNATUREtopdec.
@
text
@d4 3
d184 1
a184 1
     Ident.TyVar Set.Set|
d232 1
d238 1
a238 1
      (Ident.StrId * SigExp MLWorks.Option.option * StrExp * bool ref 
d242 1
a242 1
      (Ident.StrId * SigExp MLWorks.Option.option * StrExp * bool ref 
d249 2
a250 1
    OLDsigexp of Ident.SigId * Structure MLWorks.Option.option ref * Ident.Location.T 
d263 1
a263 1
    INCLUDEspec of Ident.SigId list * Ident.Location.T |
d273 1
a273 1
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * SigExp MLWorks.Option.option *
@


1.42
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d273 1
a273 1
    SIGNATUREtopdec of SigBind list |
@


1.41
log
@Add functions to check strdecs and strexps for the location of
free imperative type variable errors
@
text
@d4 4
a135 1
require "../utils/option";
a141 1
  structure Option : OPTION
d159 1
a159 1
    VALexp of Ident.LongValId * Type ref * Ident.Location.T * (InstanceInfo * Instance ref Option.opt) ref |
d179 1
a179 1
     TYPEdec of (Ident.TyVar list * Ident.TyCon * Ty * Tyfun ref Option.opt) list |
d182 1
a182 1
		     Type ref * Tyfun ref Option.opt * 
d184 1
a184 1
		      Ty Option.opt) list) list |
d187 1
a187 1
		    Type ref * Tyfun ref Option.opt * 
d189 1
a189 1
		     Ty Option.opt) list) list * Dec |
d196 1
a196 1
    NEWexbind of ((Ident.ValId * Type ref) * Ty Option.opt * Ident.Location.T * string) |
d224 2
a225 2
    OLDstrexp of Ident.LongStrId * Ident.Location.T * Structure Option.opt ref Option.opt |
    APPstrexp of Ident.FunId * StrExp * bool ref * Ident.Location.T * DebuggerStr ref Option.opt |
d231 2
a232 2
      (Ident.StrId * SigExp Option.opt * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref Option.opt * Structure Option.opt ref Option.opt) list
d235 2
a236 2
      (Ident.StrId * SigExp Option.opt * StrExp * bool ref 
       * Ident.Location.T * DebuggerStr ref Option.opt * Structure Option.opt ref Option.opt) list |
d241 2
a242 2
    NEWsigexp of Spec * Structure Option.opt ref  | 
    OLDsigexp of Ident.SigId * Structure Option.opt ref * Ident.Location.T 
d249 2
a250 2
		     (Ident.ValId * Ty Option.opt) list) list |
    EXCEPTIONspec of (Ident.ValId * Ty Option.opt * Ident.Location.T) list |
d265 2
a266 2
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * SigExp Option.opt *
		string * bool ref * Ident.Location.T * DebuggerStr ref Option.opt * Structure Option.opt ref Option.opt) list 
@


1.40
log
@Changed REQUIREtopdec to take a string instead of a module_id.
@
text
@d4 3
d277 4
@


1.39
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
a141 1
  type ModuleId
d267 1
a267 1
    REQUIREtopdec of ModuleId * Ident.Location.T
@


1.38
log
@Add location info to wild pats for use in redundancy warnings
@
text
@d4 3
d151 1
a151 1
    SCONexp of Ident.SCon | 
d195 1
a195 1
    SCONpat of Ident.SCon |
@


1.37
log
@Rationalizing debugger
@
text
@d4 3
d191 1
a191 1
    WILDpat |
@


1.36
log
@Abstraction of debug information
@
text
@d4 3
d136 1
d142 1
d146 1
a146 1
    VALexp of Ident.LongValId * Type ref * Ident.Location.T * (int list * Instance ref Option.opt) ref |
@


1.35
log
@Type function, debugger structure, and structure recording for Modules Debugger.
@
text
@d4 3
d132 1
d137 1
d141 1
a141 2
    VALexp of Ident.LongValId * Type ref * Ident.Location.T 
               * (int list * Instance ref Option.opt) ref |
d185 1
a185 2
    VALpat of (Ident.LongValId * (Type * Instance ref Option.opt 
                                  * (Tyfun ref * (int,int) Option.option ref) list) ref)
d190 1
a190 2
    LAYEREDpat of (Ident.ValId * (Type * Instance ref Option.opt 
                                  * (Tyfun ref * (int,int) Option.option ref) list) ref) * Pat
@


1.34
log
@Added location information to COERCEexp.
@
text
@d4 3
d123 2
a124 1
  type Type  
d126 1
d131 2
d137 1
a137 1
               * (int list * Instance ref Option.opt) ref Option.opt |
d157 1
a157 1
     TYPEdec of (Ident.TyVar list * Ident.TyCon * Ty) list |
d160 1
a160 1
		     Type ref * 
d165 1
a165 1
		    Type ref * 
d181 2
a182 1
    VALpat of (Ident.LongValId * (Type * Instance ref Option.opt) ref)
d187 2
a188 1
    LAYEREDpat of (Ident.ValId * (Type * Instance ref Option.opt) ref) * Pat
d204 2
a205 2
    OLDstrexp of Ident.LongStrId * Ident.Location.T |
    APPstrexp of Ident.FunId * StrExp * bool ref * Ident.Location.T |
d211 3
a213 1
      (Ident.StrId * SigExp Option.opt * StrExp * bool ref * Ident.Location.T) list |
d215 2
a216 1
      (Ident.StrId * SigExp Option.opt * StrExp * bool ref * Ident.Location.T) list |
d246 1
a246 1
		string * bool ref * Ident.Location.T) list 
@


1.33
log
@Added fixity annotations to APPexps and APPpats
@
text
@d4 3
d139 1
a139 1
    COERCEexp of (Exp * Ty * Type ref) |
@


1.32
log
@Runtime-instance in VALpats and LAYEREDpats and Compilation-instance
in VALexps for polymorphic debugger.
@
text
@d4 4
d130 1
a130 1
    APPexp of Exp * Exp * Ident.Location.T * Type ref |
d174 1
a174 1
    APPpat of (Ident.LongValId * Type ref) * Pat * Ident.Location.T |
@


1.31
log
@Require declarations now take moduleids instead of strings.
@
text
@d4 3
d113 2
a115 1
  type Type 
d122 2
a123 1
    VALexp of (Ident.LongValId * Type ref * Ident.Location.T) |
d167 1
a167 1
    VALpat of (Ident.LongValId * Type ref) 
d172 1
a172 1
    LAYEREDpat of (Ident.ValId * Type ref) * Pat
@


1.31.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.31  1993/08/12  14:55:33  daveb
Require declarations now take moduleids instead of strings.

@


1.30
log
@Added location information to matches
@
text
@d4 3
d99 2
a100 1
require "../basics/ident";
d110 1
d228 1
a228 1
    REQUIREtopdec of string * Ident.Location.T
@


1.29
log
@structure Option.
@
text
@d4 3
d118 1
a118 1
    HANDLEexp of Exp * Type ref * (Pat * Exp) list * Ident.Location.T * string |
d120 1
a120 1
    FNexp of (Pat * Exp) list * Type ref * string * Ident.Location.T |
@


1.28
log
@Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.
@
text
@d4 4
d94 1
d101 1
a107 2
  datatype 'a opt = PRESENT of 'a | ABSENT

d116 1
a116 1
    RAISEexp of Exp * Ident.Location.T |
d135 1
a135 1
		      Ty opt) list) list |
d140 1
a140 1
		     Ty opt) list) list * Dec |
d147 1
a147 1
    NEWexbind of ((Ident.ValId * Type ref) * Ty opt * Ident.Location.T * string) |
d154 2
a155 1
    VALpat of (Ident.LongValId * Type ref) * Ident.Location.T |
d182 1
a182 1
      (Ident.StrId * SigExp opt * StrExp * bool ref * Ident.Location.T) list |
d184 1
a184 1
      (Ident.StrId * SigExp opt * StrExp * bool ref * Ident.Location.T) list |
d189 2
a190 2
    NEWsigexp of Spec * Structure opt ref | 
    OLDsigexp of Ident.SigId * Structure opt ref * Ident.Location.T
d197 2
a198 2
		     (Ident.ValId * Ty opt) list) list |
    EXCEPTIONspec of (Ident.ValId * Ty opt * Ident.Location.T) list |
d213 1
a213 1
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp * StrExp * SigExp opt *
@


1.27
log
@Added code for abstractions.
@
text
@d4 3
d163 4
d171 1
a171 1
    APPstrexp of Ident.FunId * StrExp * Ident.Location.T |
d176 4
a179 2
    STRUCTUREstrdec of (Ident.StrId * SigExp opt * StrExp * Ident.Location.T) list |
    ABSTRACTIONstrdec of (Ident.StrId * SigExp opt * StrExp * Ident.Location.T) list |
d208 2
a209 2
    FUNBIND of (Ident.FunId * Ident.StrId * SigExp *
		StrExp * SigExp opt * string * Ident.Location.T) list 
@


1.26
log
@Added MLVALUEexp.  Just used internally for now.
@
text
@d4 3
d170 1
@


1.25
log
@> Removed Datatypes substructure and replaced with Ident substructure
 and Type and Structure types.
@
text
@d4 4
d108 3
a110 2
    DYNAMICexp of (Exp * Type ref) |
    COERCEexp of (Exp * Ty * Type ref)
@


1.24
log
@Added syntax for dynamic and coerce expressions
@
text
@d4 3
d79 1
a79 2
require "../typechecker/datatypes";
require "location";
a83 2
  structure Datatypes : DATATYPES
(*  structure Nameset : sig type Nameset val empty_nameset : unit -> Nameset end *)
d85 4
a88 1
  structure Location : LOCATION
d90 1
a90 1
  sharing Datatypes.Ident.Location = Location
d95 3
a97 3
    SCONexp of Datatypes.Ident.SCon | 
    VALexp of (Datatypes.Ident.LongValId * Datatypes.Type ref * Location.T) |
    RECORDexp of (Datatypes.Ident.Lab * Exp) list|
d99 7
a105 7
    APPexp of Exp * Exp * Location.T * Datatypes.Type ref |
    TYPEDexp of Exp * Ty * Location.T |
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp) list * Location.T * string |
    RAISEexp of Exp * Location.T |
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string * Location.T |
    DYNAMICexp of (Exp * Datatypes.Type ref) |
    COERCEexp of (Exp * Ty * Datatypes.Type ref)
d113 7
a119 7
     VALdec of (Pat * Exp * Location.T) list *  (Pat * Exp * Location.T) list *
     Datatypes.Ident.TyVar Set.Set|
     TYPEdec of (Datatypes.Ident.TyVar list * Datatypes.Ident.TyCon * Ty) list |
     DATATYPEdec of Location.T *
                    (Datatypes.Ident.TyVar list * Datatypes.Ident.TyCon *
		     Datatypes.Type ref * 
		     ((Datatypes.Ident.ValId * Datatypes.Type ref) *
d121 4
a124 4
     ABSTYPEdec of Location.T *
                   (Datatypes.Ident.TyVar list * Datatypes.Ident.TyCon *
		    Datatypes.Type ref * 
		    ((Datatypes.Ident.ValId * Datatypes.Type ref) *
d128 1
a128 1
     OPENdec of Datatypes.Ident.LongStrId list * Location.T |
d132 3
a134 3
    NEWexbind of ((Datatypes.Ident.ValId * Datatypes.Type ref) * Ty opt * Location.T * string) |
    OLDexbind of ((Datatypes.Ident.ValId * Datatypes.Type ref) *
		  Datatypes.Ident.LongValId * Location.T * string)
d138 6
a143 6
    SCONpat of Datatypes.Ident.SCon |
    VALpat of (Datatypes.Ident.LongValId * Datatypes.Type ref) * Location.T |
    RECORDpat of (Datatypes.Ident.Lab * Pat) list * bool * Datatypes.Type ref |
    APPpat of (Datatypes.Ident.LongValId * Datatypes.Type ref) * Pat * Location.T |
    TYPEDpat of Pat * Ty  * Location.T |
    LAYEREDpat of (Datatypes.Ident.ValId * Datatypes.Type ref) * Pat
d146 3
a148 3
    TYVARty of Datatypes.Ident.TyVar |
    RECORDty of (Datatypes.Ident.Lab * Ty) list |
    APPty of Ty list * Datatypes.Ident.LongTyCon * Location.T |
d155 2
a156 2
    OLDstrexp of Datatypes.Ident.LongStrId * Location.T |
    APPstrexp of Datatypes.Ident.FunId * StrExp * Location.T |
d161 1
a161 1
    STRUCTUREstrdec of (Datatypes.Ident.StrId * SigExp opt * StrExp * Location.T) list |
d166 2
a167 2
    NEWsigexp of Spec * Datatypes.Str opt ref | 
    OLDsigexp of Datatypes.Ident.SigId * Datatypes.Str opt ref * Location.T
d170 8
a177 8
    VALspec of (Datatypes.Ident.ValId * Ty * Datatypes.Ident.TyVar Set.Set) list |
    TYPEspec of (Datatypes.Ident.TyVar list * Datatypes.Ident.TyCon) list |
    EQTYPEspec of (Datatypes.Ident.TyVar list * Datatypes.Ident.TyCon) list |
    DATATYPEspec of (Datatypes.Ident.TyVar list * Datatypes.Ident.TyCon *
		     (Datatypes.Ident.ValId * Ty opt) list) list |
    EXCEPTIONspec of (Datatypes.Ident.ValId * Ty opt * Location.T) list |
    STRUCTUREspec of (Datatypes.Ident.StrId * SigExp) list |
    SHARINGspec of (SharEq * Location.T) list |
d179 2
a180 2
    OPENspec of Datatypes.Ident.LongStrId list * Location.T |
    INCLUDEspec of Datatypes.Ident.SigId list * Location.T |
d184 2
a185 2
    STRUCTUREshareq of Datatypes.Ident.LongStrId list |
    TYPEshareq of Datatypes.Ident.LongTyCon list
d187 1
a187 1
  datatype SigBind = SIGBIND of (Datatypes.Ident.SigId * SigExp * Location.T) list
d190 2
a191 3
    FUNBIND of (Datatypes.Ident.FunId * Datatypes.Ident.StrId * SigExp *
(*		Nameset.Nameset ref * *)
		StrExp * SigExp opt * string * Location.T) list 
d194 1
a194 1
    STRDECtopdec of StrDec * Location.T |
d196 2
a197 2
    FUNCTORtopdec of FunBind list * Location.T |
    REQUIREtopdec of string * Location.T
d199 1
a199 1
  val empty_tyvarset : Datatypes.Ident.TyVar Set.Set
@


1.23
log
@Removed nameset structure and ref nameset from FunBind (which wasn't used)
@
text
@d4 3
d100 3
a102 1
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string * Location.T
@


1.22
log
@Changed Interface ref to Str ref in sigexps
@
text
@d4 3
d80 1
a80 1
  structure Nameset : sig type Nameset val empty_nameset : unit -> Nameset end
d183 1
a183 1
		Nameset.Nameset ref *
@


1.21
log
@> Changed int and real scons to carry a location around
@
text
@d4 3
a77 1
  structure Interface : sig type Int val emptyInt : Int end
d155 2
a156 2
    NEWsigexp of Spec * Interface.Int ref | 
    OLDsigexp of Datatypes.Ident.SigId * Interface.Int ref * Location.T
@


1.20
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d78 3
a80 1
      
@


1.19
log
@Added location information to the `require' topdec.
@
text
@d4 3
d63 1
a64 3
require "../typechecker/nameset";
require "../typechecker/interface";
require "ident";
a65 1
require "../utils/set";
d71 3
a73 4
  structure Nameset : NAMESET
  structure Interface : INTERFACE
  structure IdentClass : IDENTCLASS
  structure Set : SET
a74 2

  sharing IdentClass = Datatypes.Ident
d79 3
a81 3
    SCONexp of IdentClass.SCon | 
    VALexp of (IdentClass.LongValId * Datatypes.Type ref * Location.T) |
    RECORDexp of (IdentClass.Lab * Exp) list|
d96 2
a97 2
     IdentClass.TyVar Set.Set|
     TYPEdec of (IdentClass.TyVar list * IdentClass.TyCon * Ty) list |
d99 1
a99 1
                    (IdentClass.TyVar list * IdentClass.TyCon *
d101 1
a101 1
		     ((IdentClass.ValId * Datatypes.Type ref) *
d104 1
a104 1
                   (IdentClass.TyVar list * IdentClass.TyCon *
d106 1
a106 1
		    ((IdentClass.ValId * Datatypes.Type ref) *
d110 1
a110 1
     OPENdec of IdentClass.LongStrId list * Location.T |
d114 3
a116 3
    NEWexbind of ((IdentClass.ValId * Datatypes.Type ref) * Ty opt * Location.T * string) |
    OLDexbind of ((IdentClass.ValId * Datatypes.Type ref) *
		  IdentClass.LongValId * Location.T * string)
d120 4
a123 4
    SCONpat of IdentClass.SCon |
    VALpat of (IdentClass.LongValId * Datatypes.Type ref) * Location.T |
    RECORDpat of (IdentClass.Lab * Pat) list * bool * Datatypes.Type ref |
    APPpat of (IdentClass.LongValId * Datatypes.Type ref) * Pat * Location.T |
d125 1
a125 1
    LAYEREDpat of (IdentClass.ValId * Datatypes.Type ref) * Pat
d128 3
a130 3
    TYVARty of IdentClass.TyVar |
    RECORDty of (IdentClass.Lab * Ty) list |
    APPty of Ty list * IdentClass.LongTyCon * Location.T |
d137 2
a138 2
    OLDstrexp of IdentClass.LongStrId * Location.T |
    APPstrexp of IdentClass.FunId * StrExp * Location.T |
d143 1
a143 1
    STRUCTUREstrdec of (IdentClass.StrId * SigExp opt * StrExp * Location.T) list |
d149 1
a149 1
    OLDsigexp of IdentClass.SigId * Interface.Int ref * Location.T
d152 7
a158 7
    VALspec of (IdentClass.ValId * Ty * IdentClass.TyVar Set.Set) list |
    TYPEspec of (IdentClass.TyVar list * IdentClass.TyCon) list |
    EQTYPEspec of (IdentClass.TyVar list * IdentClass.TyCon) list |
    DATATYPEspec of (IdentClass.TyVar list * IdentClass.TyCon *
		     (IdentClass.ValId * Ty opt) list) list |
    EXCEPTIONspec of (IdentClass.ValId * Ty opt * Location.T) list |
    STRUCTUREspec of (IdentClass.StrId * SigExp) list |
d161 2
a162 2
    OPENspec of IdentClass.LongStrId list * Location.T |
    INCLUDEspec of IdentClass.SigId list * Location.T |
d166 2
a167 2
    STRUCTUREshareq of IdentClass.LongStrId list |
    TYPEshareq of IdentClass.LongTyCon list
d169 1
a169 1
  datatype SigBind = SIGBIND of (IdentClass.SigId * SigExp * Location.T) list
d172 1
a172 1
    FUNBIND of (IdentClass.FunId * IdentClass.StrId * SigExp *
d182 1
a182 1
  val empty_tyvarset : IdentClass.TyVar Set.Set
@


1.18
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d183 1
a183 1
    REQUIREtopdec of string
@


1.17
log
@Added locations to some datatypes.
@
text
@d4 3
d98 3
a100 2
     DATATYPEdec of (IdentClass.TyVar list * IdentClass.TyCon *
		     Datatypes.Type ref *
d103 3
a105 2
     ABSTYPEdec of (IdentClass.TyVar list * IdentClass.TyCon *
		    Datatypes.Type ref *
@


1.16
log
@Installed central error reporting mechanism.
@
text
@d4 3
d116 1
a116 1
    VALpat of (IdentClass.LongValId * Datatypes.Type ref) |
d118 2
a119 2
    APPpat of (IdentClass.LongValId * Datatypes.Type ref) * Pat |
    TYPEDpat of Pat * Ty |
d125 1
a125 1
    APPty of Ty list * IdentClass.LongTyCon |
d132 1
a132 1
    OLDstrexp of IdentClass.LongStrId |
d144 1
a144 1
    OLDsigexp of IdentClass.SigId * Interface.Int ref
d156 2
a157 2
    OPENspec of IdentClass.LongStrId list |
    INCLUDEspec of IdentClass.SigId list |
@


1.15
log
@Really added the function this time.
@
text
@d4 3
d55 1
d66 1
a71 6
  type Source_marks 
  val Source_marks_to_string : Source_marks -> string
  val tuple_to_Source_marks : int * int -> Source_marks
  val Source_marks_to_tuple : Source_marks -> int * int
  val dummy_marks : Source_marks

d74 1
a74 1
    VALexp of (IdentClass.LongValId * Datatypes.Type ref * Source_marks) |
d77 5
a81 5
    APPexp of Exp * Exp * Source_marks * Datatypes.Type ref |
    TYPEDexp of Exp * Ty * Source_marks |
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp) list * Source_marks * string |
    RAISEexp of Exp * Source_marks |
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string * Source_marks
d89 1
a89 1
     VALdec of (Pat * Exp * Source_marks) list *  (Pat * Exp * Source_marks) list *
d102 1
a102 1
     OPENdec of IdentClass.LongStrId list * Source_marks |
d106 1
a106 1
    NEWexbind of ((IdentClass.ValId * Datatypes.Type ref) * Ty opt * Source_marks * string) |
d108 1
a108 1
		  IdentClass.LongValId * Source_marks * string)
d130 1
a130 1
    APPstrexp of IdentClass.FunId * StrExp * Source_marks |
d135 1
a135 1
    STRUCTUREstrdec of (IdentClass.StrId * SigExp opt * StrExp * Source_marks) list |
d149 1
a149 1
    EXCEPTIONspec of (IdentClass.ValId * Ty opt * Source_marks) list |
d151 1
a151 1
    SHARINGspec of (SharEq * Source_marks) list |
d161 1
a161 1
  datatype SigBind = SIGBIND of (IdentClass.SigId * SigExp * Source_marks) list
d166 1
a166 1
		StrExp * SigExp opt * string * Source_marks) list 
d169 1
a169 1
    STRDECtopdec of StrDec * Source_marks |
d171 1
a171 1
    FUNCTORtopdec of FunBind list * Source_marks |
@


1.14
log
@Added Source_marks_to_tuple function
@
text
@d4 3
d70 1
@


1.13
log
@Changed cut down signatures to full versions.
@
text
@d4 3
@


1.12
log
@Added a slot to appexp for debugging type information for function call type
@
text
@d4 3
d43 2
d52 2
a53 2
  structure Nameset : sig type Nameset end
  structure Interface : sig type Int end
@


1.11
log
@Added debug info to handlers
@
text
@d4 3
d66 1
a66 1
    APPexp of Exp * Exp * Source_marks |
@


1.10
log
@Added some maarks for typechecker error messages
@
text
@d4 3
d92 1
a92 1
    NEWexbind of ((IdentClass.ValId * Datatypes.Type ref) * Ty opt * Source_marks) |
d94 1
a94 1
		  IdentClass.LongValId * Source_marks)
@


1.9
log
@Added marks for better error reporting
@
text
@d4 3
d62 1
a62 1
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp) list * Source_marks |
d64 1
a64 1
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string 
@


1.8
log
@First version of the profiler
@
text
@d4 3
d47 5
d54 1
a54 1
    VALexp of (IdentClass.LongValId * Datatypes.Type ref) |
d57 5
a61 5
    APPexp of Exp * Exp |
    TYPEDexp of Exp * Ty |
    HANDLEexp of Exp * Datatypes.Type ref * (Pat * Exp) list |
    RAISEexp of Exp  |
    FNexp of (Pat * Exp) list * Datatypes.Type ref * string |
a62 4
    (* this expression type is only used in the ten15 code generator
     the parser will never generate it *)
    TEN15exp of IdentClass.ValId list

d69 1
a69 1
     VALdec of (Pat * Exp) list *  (Pat * Exp) list *
d82 1
a82 1
     OPENdec of IdentClass.LongStrId list |
d86 1
a86 1
    NEWexbind of ((IdentClass.ValId * Datatypes.Type ref) * Ty opt) |
d88 1
a88 1
		  IdentClass.LongValId)
d110 1
a110 1
    APPstrexp of IdentClass.FunId * StrExp |
d115 1
a115 1
    STRUCTUREstrdec of (IdentClass.StrId * SigExp opt * StrExp) list |
d129 1
a129 1
    EXCEPTIONspec of (IdentClass.ValId * Ty opt) list |
d131 1
a131 1
    SHARINGspec of SharEq list |
d141 1
a141 1
  datatype SigBind = SIGBIND of (IdentClass.SigId * SigExp) list
d146 1
a146 1
		StrExp * SigExp opt * string) list 
d149 1
a149 1
    STRDECtopdec of StrDec |
d151 1
a151 1
    FUNCTORtopdec of FunBind list |
@


1.7
log
@Removed a couple of irrelevant requires
@
text
@d4 3
d52 2
a53 2
    RAISEexp of Exp * int list |
    FNexp of (Pat * Exp) list * Datatypes.Type ref * int list |
d142 1
a142 1
		StrExp * SigExp opt) list 
@


1.6
log
@Removed opens
@
text
@d3 4
a6 1
$Log:	absyn.sml,v $
a24 2
require "../typechecker/nameset";
require "../typechecker/interface";
@


1.5
log
@Added copyright message
@
text
@d4 3
d28 1
a28 1
  sig
d30 5
a34 5
    structure Datatypes : DATATYPES
    structure Nameset : sig type Nameset end
    structure Interface : sig type Int end
    structure IdentClass : IDENTCLASS
    structure Set : SET
d36 1
a36 1
    sharing IdentClass = Datatypes.Ident
d38 1
a38 1
    open Datatypes
d40 14
a53 5
    local
      open IdentClass
    in
                                
      datatype 'a opt = PRESENT of 'a | ABSENT
d55 5
a59 10
      datatype Exp =
        SCONexp of SCon | 
        VALexp of (LongValId * Type ref) |
        RECORDexp of (Lab * Exp) list|
        LOCALexp of Dec * Exp |
        APPexp of Exp * Exp |
        TYPEDexp of Exp * Ty |
        HANDLEexp of Exp * Type ref * (Pat * Exp) list |
        RAISEexp of Exp * int list |
        FNexp of (Pat * Exp) list * Type ref * int list |
d61 15
a75 3
	(* this expression type is only used in the ten15 code generator
	   the parser will never generate it *)
	TEN15exp of ValId list
d77 4
a80 5
      and Dec = 
         (* the two lists in VALdec list the bindings before and after
          the first occurence of rec. tyvarset is used to hold
          information about tyvars scoped at this particular value
          declaration (see 4.6 in The Definition *)
d82 8
d91 5
a95 10
         VALdec of (Pat * Exp) list *  (Pat * Exp) list * TyVar Set.Set|
         TYPEdec of (TyVar list * TyCon * Ty) list |
         DATATYPEdec of (TyVar list * TyCon * Type ref *
			 ((ValId * Type ref) * Ty opt) list) list |
         ABSTYPEdec of (TyVar list * TyCon * Type ref *
			((ValId * Type ref) * Ty opt) list) list * Dec |
         EXCEPTIONdec of ExBind list|
         LOCALdec of Dec * Dec |
         OPENdec of LongStrId list |
         SEQUENCEdec of Dec list
d97 1
a97 3
      and ExBind = 
        NEWexbind of ((ValId * Type ref) * Ty opt) |
        OLDexbind of ((ValId * Type ref) * LongValId)
d99 5
a103 8
      and Pat =
        WILDpat |
        SCONpat of SCon |
        VALpat of (LongValId * Type ref) |
        RECORDpat of (Lab * Pat) list * bool * Type ref |
        APPpat of (LongValId * Type ref) * Pat |
        TYPEDpat of Pat * Ty |
        LAYEREDpat of (ValId * Type ref) * Pat
d105 5
a109 5
      and Ty =
        TYVARty of TyVar |
        RECORDty of (Lab * Ty) list |
        APPty of Ty list * LongTyCon |
        FNty of Ty * Ty
d111 3
a113 1
      (* The following datatypes are for the modules syntax classes *)
d115 13
a127 5
      datatype StrExp =
        NEWstrexp of StrDec |
        OLDstrexp of LongStrId |
        APPstrexp of FunId * StrExp |
        LOCALstrexp of StrDec * StrExp
d129 3
a131 5
      and StrDec =
        DECstrdec of Dec |
        STRUCTUREstrdec of (StrId * SigExp opt * StrExp) list |
        LOCALstrdec of StrDec * StrDec |
        SEQUENCEstrdec of StrDec list
d133 1
a133 22
      and SigExp =
        NEWsigexp of Spec * Interface.Int ref | 
        OLDsigexp of SigId * Interface.Int ref

      and Spec =
        VALspec of (ValId * Ty * TyVar Set.Set) list|
        TYPEspec of (TyVar list * TyCon) list|
        EQTYPEspec of (TyVar list * TyCon) list|
        DATATYPEspec of (TyVar list * TyCon * (ValId * Ty opt) list) list|
        EXCEPTIONspec of (ValId * Ty opt) list|
        STRUCTUREspec of (StrId * SigExp) list|
        SHARINGspec of SharEq list|
        LOCALspec of Spec * Spec|
        OPENspec of LongStrId list|
        INCLUDEspec of SigId list |
	SEQUENCEspec of Spec list

      and SharEq =
        STRUCTUREshareq of LongStrId list|
        TYPEshareq of LongTyCon list

      datatype SigBind = SIGBIND of (SigId * SigExp) list
d135 4
a138 3
      datatype FunBind = 
        FUNBIND of (FunId * StrId * SigExp * Nameset.Nameset ref *
		    StrExp * SigExp opt) list 
d140 5
a144 5
      datatype TopDec =
        STRDECtopdec of StrDec |
        SIGNATUREtopdec of SigBind list |
        FUNCTORtopdec of FunBind list |
	REQUIREtopdec of string
d146 1
a146 1
      val empty_tyvarset : TyVar Set.Set
d148 2
a149 2
      val expansivep : Exp -> bool
      val has_tyvar : Ty -> bool
d151 1
a151 7
    end
  end





@


1.4
log
@added Interface annotation for signature expressions
@
text
@d1 1
d4 3
d16 1
@


1.4.1.1
log
@Added comments for DRA on functions
@
text
@a2 3
Revision 1.4  91/06/27  13:39:59  colin
added Interface annotation for signature expressions

a12 16

(*

This module defines the anstract syntax tree as a set of datatypes,
with names derived directly from those in the syntax definition
(chapters 2 and 3 of the Definition). There is a value constructor for
each line in the syntax, with a product type formed from all the
non-terminals on the right of the production.

There are also slots for type information. Because the typechecker
operates by updating the absyn, rather than creating new nodes, these
slots are all refs.

*)


@


1.3
log
@Added REQUIREtopdec of string.
@
text
@d3 3
d15 1
d24 1
d105 2
a106 2
        NEWsigexp of Spec|
        OLDsigexp of SigId
@


1.2
log
@Added a type ref to HANDLEexp for ten15 code generator
@
text
@d3 3
d129 2
a130 1
        FUNCTORtopdec of FunBind list
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d37 1
a37 1
        HANDLEexp of Exp * (Pat * Exp) list |
@
