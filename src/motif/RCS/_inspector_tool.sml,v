head	1.79;
access;
symbols
	ML_beta_release_12/08/94:1.51
	ML_beta_release_03/08/94:1.50
	ML_revised_beta_release_25/05/94:1.46
	ML_final_beta_release_02/03/94:1.45
	mlworks-28-01-1994:1.43
	Release:1.36
	mlworks-beta-01-09-1993:1.36;
locks; strict;
comment	@ * @;


1.79
date	95.07.26.13.20.35;	author matthew;	state Exp;
branches;
next	1.78;

1.78
date	95.07.20.16.17.40;	author matthew;	state Exp;
branches;
next	1.77;

1.77
date	95.07.13.11.54.33;	author matthew;	state Exp;
branches;
next	1.76;

1.76
date	95.07.07.15.31.31;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	95.07.04.13.53.27;	author matthew;	state Exp;
branches;
next	1.74;

1.74
date	95.06.14.13.21.33;	author daveb;	state Exp;
branches;
next	1.73;

1.73
date	95.06.08.13.39.44;	author daveb;	state Exp;
branches;
next	1.72;

1.72
date	95.06.08.09.29.26;	author daveb;	state Exp;
branches;
next	1.71;

1.71
date	95.06.06.16.07.48;	author daveb;	state Exp;
branches;
next	1.70;

1.70
date	95.06.06.10.30.03;	author daveb;	state Exp;
branches;
next	1.69;

1.69
date	95.06.01.10.32.09;	author daveb;	state Exp;
branches;
next	1.68;

1.68
date	95.05.23.14.12.51;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	95.05.23.08.47.12;	author daveb;	state Exp;
branches;
next	1.66;

1.66
date	95.05.04.09.58.46;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	95.04.28.16.49.08;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	95.04.18.14.50.53;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	95.03.31.16.41.11;	author daveb;	state Exp;
branches;
next	1.62;

1.62
date	95.03.31.13.43.51;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	95.03.17.11.29.07;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	95.03.16.14.32.43;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	95.03.15.16.19.47;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	95.03.10.15.28.23;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	95.03.02.17.13.33;	author daveb;	state Exp;
branches;
next	1.56;

1.56
date	95.02.27.13.08.21;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	95.02.06.16.58.36;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	95.01.13.15.22.45;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	94.11.30.16.16.02;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	94.09.21.16.28.29;	author brianm;	state Exp;
branches;
next	1.51;

1.51
date	94.08.10.11.41.01;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	94.08.01.10.30.22;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	94.07.27.15.59.07;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	94.07.12.16.11.34;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	94.06.20.11.33.53;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	94.03.14.16.43.55;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	94.02.23.17.02.19;	author nosa;	state Exp;
branches;
next	1.44;

1.44
date	94.02.02.11.53.29;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	93.12.20.12.57.49;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	93.12.10.15.16.20;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	93.12.09.19.34.46;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	93.12.06.14.37.38;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	93.11.26.12.25.38;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	93.10.22.16.59.47;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	93.10.08.16.33.41;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	93.08.29.16.47.08;	author daveb;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	93.08.25.15.03.22;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.08.24.13.44.40;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	93.08.12.18.05.30;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	93.08.11.11.25.19;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	93.08.10.14.46.45;	author nosa;	state Exp;
branches;
next	1.30;

1.30
date	93.08.10.10.28.17;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.08.03.14.39.12;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.06.16.16.34.40;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.06.04.10.07.16;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	93.06.03.17.03.51;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.06.03.11.54.57;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.05.28.16.05.01;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.05.26.17.18.30;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.05.13.11.34.33;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	93.05.13.10.00.22;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.05.12.13.09.00;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.05.11.17.17.07;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.05.10.16.03.36;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.05.10.14.25.22;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	93.05.07.17.25.13;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.05.07.11.02.15;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	93.05.06.16.08.25;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.05.06.14.57.36;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	93.05.05.19.11.53;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.05.05.12.00.34;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.04.30.14.01.00;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.04.23.14.53.09;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.04.21.16.45.28;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.04.20.10.25.26;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.04.06.17.50.36;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	93.04.06.16.25.10;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	93.04.02.17.51.07;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.04.02.14.16.05;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.30.16.35.14;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.26.16.50.09;	author matthew;	state Exp;
branches;
next	;

1.36.1.1
date	93.08.29.16.47.08;	author jont;	state Exp;
branches;
next	1.36.1.2;

1.36.1.2
date	93.10.08.14.02.45;	author matthew;	state Exp;
branches;
next	1.36.1.3;

1.36.1.3
date	93.10.21.14.03.30;	author daveb;	state Exp;
branches;
next	;


desc
@First version of windowing inspector
@


1.79
log
@Adding support for font dimensions etc.
@
text
@(*
 * Copyright (c) 1993 Harlequin Ltd.
 * $Log: _inspector_tool.sml,v $
 *  Revision 1.78  1995/07/20  16:17:40  matthew
 *  Adding Graphs
 *
 *  Revision 1.77  1995/07/13  11:54:33  matthew
 *  Moving identifier type to Ident
 *
 *  Revision 1.76  1995/07/07  15:31:31  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.75  1995/07/04  13:53:27  matthew
 *  Capification
 *
 *  Revision 1.74  1995/06/14  13:21:33  daveb
 *  ShellUtils.edit_* functions no longer require a context argument.
 *
 *  Revision 1.73  1995/06/08  13:39:44  daveb
 *  Removed require "output".
 *
 *  Revision 1.72  1995/06/08  09:29:26  daveb
 *  Removed Output widget and debugger function.
 *
 *  Revision 1.71  1995/06/06  16:07:48  daveb
 *  Removed input window.  Moved parent and toplevel buttons to main
 *  window from menu.  Added source text.
 *
 *  Revision 1.70  1995/06/06  10:30:03  daveb
 *  Removed inspect_variable.  Made create inspect current selection on
 *  start-up, instead of evaluating "it".
 *
 *  Revision 1.69  1995/06/01  10:32:09  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.68  1995/05/23  14:12:51  matthew
 *  Changing interface to list_select.
 *
 *  Revision 1.67  1995/05/23  08:47:12  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.66  1995/05/04  09:58:46  matthew
 *  Use create for making top level shell
 *  Removing exception EditObject
 *
 *  Revision 1.65  1995/04/28  16:49:08  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.64  1995/04/18  14:50:53  daveb
 *  Changes to context_menu.
 *  
 *  Revision 1.63  1995/03/31  16:41:11  daveb
 *  Added the history number to items in the history.
 *  
 *  Revision 1.62  1995/03/31  13:43:51  daveb
 *  Removed redundant require.
 *  
 *  Revision 1.61  1995/03/17  11:29:07  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 *  
 *  Revision 1.60  1995/03/16  14:32:43  daveb
 *  Removed context_function from register when closing the window.
 *  
 *  Revision 1.59  1995/03/15  16:19:47  daveb
 *  Changed to share current context with other tools..
 *  
 *  Revision 1.58  1995/03/10  15:28:23  daveb
 *  Added calls to register select function in current context.
 *  
 *  Revision 1.57  1995/03/02  17:13:33  daveb
 *  Added inspect_variable, with takes a context and looks the value up
 *  in that.
 *  
 *  Revision 1.56  1995/02/27  13:08:21  daveb
 *  Changed valLabel and typeLabel widgets to text widgets (and renamed
 *  them), so that we can constrain the number of columns.
 *  
 *  Revision 1.55  1995/02/06  16:58:36  daveb
 *  Removed argument from value_menu.
 *  
 *  Revision 1.54  1995/01/13  15:22:45  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *  
 *  Revision 1.53  1994/11/30  16:16:02  daveb
 *  Simplified Form constraints.
 *  
 *  Revision 1.52  1994/09/21  16:28:29  brianm
 *  Adding value menu ...
 *  
 *  Revision 1.51  1994/08/10  11:41:01  matthew
 *  Add flush output
 *  
 *  Revision 1.50  1994/08/01  10:30:22  daveb
 *  Moved preferences to separate structure.
 *  
 *  Revision 1.48  1994/07/12  16:11:34  daveb
 *  ToolData.works_menu takes different arguments.
 *  
 *  Revision 1.47  1994/06/20  11:33:53  daveb
 *  Moved output window code to separate file.
 *  Replaced context refs with user_contexts.
 *  
 *  Revision 1.46  1994/03/14  16:43:55  matthew
 *  Added untrace value facility
 *  
 *  Revision 1.45  1994/02/23  17:02:19  nosa
 *  Boolean indicator for Monomorphic debugger decapsulation;
 *  Debugger scripts for tracing tool using debugger.
 *  
 *  Revision 1.44  1994/02/02  11:53:29  daveb
 *  Changed substructure of InterMake.
 *  
 *  Revision 1.43  1993/12/20  12:57:49  matthew
 *  Changed name of output window
 *  
 *  Revision 1.42  1993/12/10  15:16:20  daveb
 *  Added context menu, ensured that changes do the right thing, ensured that
 *  new selection is passed on to child tools.
 *  
 *  Revision 1.41  1993/12/09  19:34:46  jont
 *  Added copyright message
 *  
 *  Revision 1.40  1993/12/06  14:37:38  daveb
 *  Ensured that output window is automatically shown when appropriate
 *  preference is set.
 *  
 *  Revision 1.39  1993/11/26  12:25:38  matthew
 *  Improvements to debugger calling.
 *  
 *  Revision 1.38  1993/10/22  16:59:47  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.37  1993/10/08  16:33:41  matthew
 *   Merging in bug fixes
 *  
 *  Revision 1.36.1.3  1993/10/21  14:03:30  daveb
 *  Changed ToolData.works_menu to take a (unit -> bool) function that
 *  controls whether the Close menu option is enabled.
 *  
 *  Revision 1.36.1.2  1993/10/08  14:02:45  matthew
 *  Added horizontal scrollbar to input pane
 *  Tests for editability and scrollability of objects
 *  Uses history utilities
 *  Added name completion
 *  
 *  Revision 1.36.1.1  1993/08/29  16:47:08  jont
 *  Fork for bug fixing
 *  
 *  Revision 1.36  1993/08/29  16:47:08  daveb
 *  Changed name of file menu to window.
 *  
 *  Revision 1.35  1993/08/25  15:03:22  matthew
 *  Return quit function from ShellUtils.edit_string
 *  
 *  Revision 1.34  1993/08/24  13:44:40  matthew
 *  Improved editing and tracing error handling
 *  
 *  Revision 1.33  1993/08/12  18:05:30  daveb
 *  Removed spurious sharing constraint.
 *  
 *  Revision 1.32  1993/08/11  11:25:19  matthew
 *  Changes to user options
 *  Removed preferences menu
 *  Options update
 *  
 *  Revision 1.31  1993/08/10  14:46:45  nosa
 *  Debugger-window now passed to Inspector-tool functions.
 *  
 *  Revision 1.30  1993/08/10  10:28:17  matthew
 *  Get maximum history length from options
 *  
 *  Revision 1.29  1993/08/03  14:39:12  matthew
 *  Changed history mechanism.
 *  
 *  Revision 1.28  1993/06/16  16:34:40  matthew
 *  Added value menu with edit and trace options
 *  
 *  Revision 1.27  1993/06/04  10:07:16  daveb
 *  Removed popHistory button.
 *  
 *  Revision 1.26  1993/06/03  17:03:51  matthew
 *  Clear text input on selection from history
 *  
 *  Revision 1.25  1993/06/03  11:54:57  matthew
 *  Limit error messages to first line.
 *  
 *  Revision 1.24  1993/05/28  16:05:01  matthew
 *  Added tty_ok value to WINDOWING
 *  Added history
 *  
 *  Revision 1.23  1993/05/26  17:18:30  matthew
 *  Changed error handling for eval
 *  
 *  Revision 1.22  1993/05/13  11:34:33  daveb
 *  All tools now set their own titles and pass them to their options menus.
 *  
 *  Revision 1.21  1993/05/13  10:00:22  matthew
 *  Fixed problem with debugger window.
 *  
 *  Revision 1.20  1993/05/12  13:09:00  matthew
 *  Uses ShellUtils more
 *  
 *  Revision 1.19  1993/05/11  17:17:07  matthew
 *  Changed layout.
 *  Better debugger interface
 *  
 *  Revision 1.18  1993/05/10  16:03:36  daveb
 *  Changed type of ml_debugger.
 *  
 *  Revision 1.17  1993/05/10  14:25:22  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *  
 *  Revision 1.16  1993/05/07  17:25:13  matthew
 *  Added sharing constraint
 *  
 *  Revision 1.15  1993/05/07  11:02:15  daveb
 *  Replaced some stuff with MotifUtils.make_scrolllist.
 *  Greatly improved layout.
 *  
 *  Revision 1.14  1993/05/06  16:08:25  matthew
 *  Removed printer_descriptors
 *  
 *  Revision 1.13  1993/05/06  14:57:36  daveb
 *  Added output widget for showing type errors, etc.
 *  
 *  Revision 1.12  1993/05/05  19:11:53  daveb
 *  Renamed inspect to create, and changed its type so that inspectors can
 *  be added to the list of tools on the Works menu.
 *  
 *  Revision 1.11  1993/05/05  12:00:34  matthew
 *  Print type using completion
 *  
 *  Revision 1.10  1993/04/30  14:01:00  matthew
 *  textInput widget now called textIO
 *  
 *  Revision 1.9  1993/04/23  14:53:09  matthew
 *  Immediately inspect "it" on startup.  Added inspect_value function
 *  Simple error handling for user defined methods
 *  
 *  Revision 1.8  1993/04/21  16:45:28  matthew
 *  Cleaned up
 *  
 *  Revision 1.7  1993/04/20  10:25:26  matthew
 *  Renamed Inspector_Values to InspectorValues
 *  
 *  Revision 1.6  1993/04/06  17:50:36  daveb
 *  Names of Callbacks have changed.
 *  
 *  Revision 1.5  1993/04/06  16:25:10  jont
 *  Moved user_options and version from interpreter to main
 *  
 *  Revision 1.4  1993/04/02  17:51:07  matthew
 *  Added text input window with expression evaluation
 *  
 *  Revision 1.2  1993/03/30  16:35:14  matthew
 *  Removed MENUSPEC data constructor
 *  
 *  Revision 1.1  1993/03/26  16:50:09  matthew
 *  Initial revision
 *  
 *)

require "../library/capi";
require "../library/graph_widget";
require "../basics/ident";
require "../main/user_options";
require "../main/preferences";
require "../utils/lists";
require "../interpreter/inspector_values";
require "../interpreter/shell_utils";
require "motif_utils";
require "menus";
require "tooldata";

require "inspector_tool";

functor InspectorTool (
  structure Capi : CAPI
  structure GraphWidget : GRAPH_WIDGET
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure Ident : IDENT
  structure Lists : LISTS
  structure InspectorValues : INSPECTOR_VALUES
  structure ShellUtils : SHELL_UTILS
  structure Menus : MENUS
  structure MotifUtils : MOTIF_UTILS
  structure ToolData : TOOL_DATA

  sharing UserOptions.Options = ToolData.ShellTypes.Options =
    ShellUtils.Options

  sharing type Ident.Identifier = ToolData.UserContext.identifier
  sharing type UserOptions.user_tool_options =
	       ToolData.ShellTypes.user_options =
               MotifUtils.user_tool_options = ShellUtils.UserOptions
  sharing type UserOptions.user_context_options =
	       MotifUtils.user_context_options =
	       ToolData.UserContext.user_context_options
  sharing type InspectorValues.Type = ShellUtils.Type
  sharing type Menus.Widget = Capi.Widget = MotifUtils.Widget = ToolData.Widget = GraphWidget.Widget
  sharing type Capi.GraphicsPorts.GraphicsPort = GraphWidget.GraphicsPort
  sharing type ToolData.ShellTypes.Context = ShellUtils.Context
  sharing type ToolData.ButtonSpec = Menus.ButtonSpec = MotifUtils.ButtonSpec
  sharing type MotifUtils.user_context = ToolData.ShellTypes.user_context
  sharing type Preferences.preferences = ShellUtils.preferences
  sharing type ShellUtils.user_preferences = Preferences.user_preferences =
  	       ToolData.ShellTypes.user_preferences =
	       MotifUtils.user_preferences
  sharing type MotifUtils.MotifContext = ToolData.MotifContext
) : INSPECTORTOOL =
struct
    structure Options = UserOptions.Options
    structure ShellTypes = ToolData.ShellTypes
    structure UserContext = ToolData.UserContext
    structure Info = ShellUtils.Info
    structure Option = MLWorks.Option

    type ToolData = ToolData.ToolData
    type Type = InspectorValues.Type

    val inspector_number = ref 1

    fun make_value_from_history_item
	  (UserContext.ITEM (_, id, context, _, src), options) =
      case id
      of Ident.VALUE (Ident.VAR s) =>
	let
	  val value =
	    ShellUtils.eval
              Info.default_options
              (Ident.Symbol.symbol_name s,
	       options, context, fn f => fn a => f a)
	in
          (* This should be done by with_standard_output *)
          MLWorks.IO.flush_out std_out;
          MLWorks.Option.SOME (src, value)
	end
      |  _ =>
	MLWorks.Option.NONE

    fun make_inspector_window
	  debugger_print
          (mk_initial_item,
           tooldata as ToolData.TOOLDATA
	     {args as ShellTypes.LISTENER_ARGS
                {user_options, user_context, user_preferences,
		 prompter, mk_xinterface_fn},
              appdata as ToolData.APPLICATIONDATA 
                {applicationShell,...},
              current_context, motif_context, tools, ...}) =
      let
        val title =
          let
            val n = !inspector_number
            fun p (s, 0) = s
              | p (s, n) = p (chr (48+(n mod 10)) ^ s, n div 10)
          in
            inspector_number := n+1;
            "Inspector #" ^ p ("", n)
          end

        val (full_menus, update_fns) =
	  case user_preferences
	  of Preferences.USER_PREFERENCES ({full_menus, ...}, update_fns) =>
	    (!full_menus, update_fns)

        val (shell,frame,menuBar,contextLabel) =
          Capi.make_main_window ("inspector",title,applicationShell,full_menus)

        val valText = Capi.make_managed_widget ("valText",Capi.Text,frame, [])
        val typeText = Capi.make_managed_widget ("typeText", Capi.Text,frame, [])
        val srcText = Capi.make_managed_widget  ("srcText", Capi.Text, frame, [])
        val buttonPane = Capi.make_managed_widget ("buttonPane", Capi.RowColumn, frame, []);

	val local_context = ref motif_context

        fun get_current_context () =
	  (UserContext.get_context
	     (MotifUtils.get_user_context (!local_context)))

        fun message_fun s =
          Capi.send_message (shell, s)

        fun get_user_tool_options () = user_options

        fun get_user_context_options () =
	  UserContext.get_user_options
	    (MotifUtils.get_user_context (!local_context))

	fun get_options () =
	  ShellTypes.new_options (user_options, user_context)

        fun print_fn print_options (label, typed_value) =
	  label ^ ": "
	  ^ ShellUtils.print_value
	      (typed_value,print_options,get_current_context())

        local
          val print_options = UserOptions.new_print_options user_options
        in 
          fun graph_print_item (typed_value) =
            ShellUtils.print_value
            (typed_value,print_options,get_current_context())
        end

	val (initial_str, initial_item) =
	  mk_initial_item (user_context, user_options)

        val current_item = ref initial_item

        fun set_state (set_items, (item as (value,ty),subitems)) =
          let
            val print_options = UserOptions.new_print_options user_options
            val context = get_current_context ()

            fun print_type ty =
              ShellUtils.print_type (ty,print_options,context)

            fun print_value value =
              ShellUtils.print_value (item,print_options,context)
          in
	    Capi.Text.set_string (valText, print_value item);
	    Capi.Text.set_string (typeText, print_type ty);
            current_item := item;
            set_items print_options subitems
          end

        fun edit_object _ =
          let
            val preferences = Preferences.new_preferences user_preferences 
          in
            ShellUtils.edit_object (#1 (!current_item), preferences);
	    ()
          end
          handle
	    ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)

        fun trace_object _ =
          ShellUtils.trace
	    (!current_item, user_options, get_current_context, message_fun)

        fun untrace_object _ =
          ShellUtils.untrace
	    (!current_item, user_options, get_current_context, message_fun)

        fun object_editable _ =
	  ShellUtils.object_editable (#1 (!current_item))

        fun object_traceable _ =
	  ShellUtils.object_traceable (#1 (!current_item))

        val history = ref []

        fun eq ( ((v,t),_), ((v',t'),_) ) =
          let
            fun cast x = (MLWorks.Internal.Value.cast x) : int ref
          in 
            cast v = cast v'
          end

        fun add_action a =
	  ShellUtils.add_history_item (a, history, eq, user_preferences)

        fun inspect_item (set_items, new_item, hist) =
          let
            val new_item_data =
              (new_item, InspectorValues.get_inspector_values debugger_print new_item)
              handle InspectorValues.DuffUserMethod _ =>
                (message_fun "Error in User Inspect Method";
                 (new_item,[]))
          in
            add_action (new_item_data);
            set_state (set_items, new_item_data)
          end

	fun select (_, _, set_items) (_, chosen_item) =
	  inspect_item (set_items, chosen_item, !history)

        val pane = Capi.make_managed_widget ("pane",Capi.Paned,frame,[])

	val (winScroll, winList, set_items) =
	  Capi.make_scrolllist
	    {parent = pane, name = "inspector", print_fn = print_fn,
	     select_fn = select, action_fn = fn _ => fn _ => ()}

        val graph_spec =
          GraphWidget.GRAPH_SPEC {child_position = GraphWidget.NEXT,
                                  parent_position = GraphWidget.CENTRE,
                                  orientation = GraphWidget.VERTICAL,
                                  line_style = GraphWidget.STRAIGHT,
                                  horizontal_delta = 10,
                                  vertical_delta = 20}

        (* Bundle up a node plus some cached display information *)
        datatype Item = ITEM of ((MLWorks.Internal.Value.T * Type) * (string * int * int * int) Option.option ref)
        fun make_graph root =
          let
            fun get_children (ITEM (item,_)) = 
              let
                fun scan ([],acc) = rev acc
                  | scan ((_,x)::rest,acc) =
                    if InspectorValues.is_scalar_value x
                      then scan (rest,acc)
                    else
                      scan (rest,ITEM (x,ref Option.NONE) :: acc)
              in
                scan (InspectorValues.get_inspector_values debugger_print item,[])
              end
            val cast : 'a -> int ref = MLWorks.Internal.Value.cast
            fun equality_fn ((x1,ty1),(x2,ty2)) =
              cast x1 = cast x2 andalso InspectorValues.type_eq (ty1,ty2)
          in
            (ITEM (root,ref Option.NONE),
             get_children,
             MLWorks.Option.SOME (fn (ITEM (i1,_),ITEM (i2,_)) => equality_fn (i1,i2)))
          end

        fun make_value_graph () = make_graph (!current_item)

        fun item_string (gp,(x,ty)) = graph_print_item (x,ty)

        fun get_item_data (ITEM (item,extents),gp) =
          case !extents of
            Option.SOME data => data
          | _ =>
              let
                val s = item_string  (gp,item)
                val {font_ascent,font_descent,width,...} = Capi.GraphicsPorts.text_extent (gp,s)
                val data = (s,font_ascent,font_descent,width)
              in
                extents := Option.SOME data;
                data
              end

        val baseline_height = 3
        fun max (x,y) = if x > y then x else y

        fun item_draw_item (item,gp,x,y) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
          in 
	    Capi.GraphicsPorts.draw_fill_rectangle (gp,
                                                    x-left-1,
                                                    y-font_ascent-baseline_height-1,
                                                    left+right+4,
                                                    font_ascent + font_descent + 4);
            Capi.GraphicsPorts.draw_image_string (gp,s,
                                                  x - left,
                                                  y - baseline_height)
          end

        fun item_extent (item,gp) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
          in
            (left,
             right+2,
             baseline_height + font_ascent+1,
             max (0,font_descent+3-baseline_height))
          end
    
        val (graph_window,initialize_graph,update_graph) = 
          GraphWidget.make ("inspectorGraph","InspectorGraph",
                            graph_spec,item_draw_item,item_extent,make_value_graph,pane)

        val quit_funs = ref [];

        fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

        fun can_pop _ =
          (case !history of 
             _ :: _ :: _ => true
           | _ => false)

        fun pop_history _ =
          (case !history of
             _ :: (l as (item_data :: _)) => (history := l;
                                              set_state (set_items, item_data))
           | _ => ())

        fun top_level _ =
          let 
            fun doit [] = ()
              | doit (l as [item_data]) =
                (history := l;
                 set_state (set_items,item_data))
              | doit (a::l) = doit l
          in
            doit (!history)
          end

        fun make_history_menu () =
          let
            val print_options = UserOptions.new_print_options user_options 
            val context = get_current_context()

            fun print_value item =
              ShellUtils.trim_history_string
		(ShellUtils.print_value (item, print_options, context),
		 user_preferences)

            fun doone (item_data as (item, _)) =
              Menus.PUSH (print_value item,
                          fn _ =>
                            (set_state (set_items,item_data)), fn _ => true)

            val items = !history
          in
            (map doone items)
          end

        val valTitleLabel = 
          Capi.make_managed_widget ("valTitleLabel",Capi.Label,frame,[])
        val typeTitleLabel = 
          Capi.make_managed_widget ("typeTitleLabel",Capi.Label,frame,[])
        val listLabel = 
          Capi.make_managed_widget ("listLabel",Capi.Label,frame,[])
        val srcTitleLabel =
	  Capi.make_managed_widget ("srcTitleLabel", Capi.Label, frame, [])

        fun set_context_label user_context =
	  case contextLabel
	  of MLWorks.Option.SOME w =>
            let
              val context_name =
	        UserContext.get_context_name user_context
              val cstring = "Context: " ^ context_name
            in
              Capi.set_label_string (w, cstring)
            end
	  |  MLWorks.Option.NONE => ()

        fun first_line (message) =
          let
            fun aux ([],_) = message
              | aux (("\n" :: _),acc) = implode (rev acc)
              | aux ((a::b),acc) = aux (b,a::acc)
          in
            aux (explode message,[])
          end

      fun select_fn item =
	case make_value_from_history_item (item, get_options ())
	of MLWorks.Option.SOME (s, v) =>
          (Capi.Text.set_string (srcText, s);
	   history := [];
           inspect_item (set_items, v, []);
           update_graph ())
        |  _ => ()

      fun sense_selection user_options =
	case UserContext.get_selected
	       (MotifUtils.get_user_context (!local_context), user_options)
	of MLWorks.Option.NONE => ()
	|  MLWorks.Option.SOME entry => select_fn entry

      val select_fn_key =
	ref (UserContext.add_select_fn
	       (MotifUtils.get_user_context (!local_context),
		(select_fn, get_user_tool_options)))

      fun set_context c =
        (UserContext.remove_select_fn
	   (MotifUtils.get_user_context (!local_context), !select_fn_key);
	 set_context_label (MotifUtils.get_user_context c);
	 select_fn_key :=
	   UserContext.add_select_fn
	     (MotifUtils.get_user_context c,
	      (select_fn, get_user_tool_options));
         history := [];
	 local_context := c;
	 case UserContext.get_selected
		(MotifUtils.get_user_context c, user_options)
	 of MLWorks.Option.SOME x => select_fn x
	 |  MLWorks.Option.NONE => ())

      val context_key =
	ToolData.add_context_fn
          (current_context, (set_context, get_user_tool_options, ToolData.ALL))

      val _ =
	quit_funs :=
          (fn _ => UserContext.remove_select_fn
		     (MotifUtils.get_user_context (!local_context),
		      !select_fn_key))
	  :: (fn _ => ToolData.remove_context_fn
			(current_context, context_key))
	  :: !quit_funs

      fun select_context user_context =
        (set_context user_context;
         ToolData.set_current
           (current_context, context_key, user_options, user_context))

	fun mk_tooldata () =
          ToolData.TOOLDATA
	    {args = ShellTypes.LISTENER_ARGS
                      {user_options = user_options,
                       user_preferences = user_preferences,
		       user_context =
			 MotifUtils.get_user_context (!local_context),
		       prompter = prompter,
		       mk_xinterface_fn = mk_xinterface_fn},
	     current_context = current_context,
             appdata = appdata,
	     motif_context = !local_context,
             tools = tools}

	val sep_size = 10

        fun close_window _ =
          (do_quit_funs ();
           Capi.destroy shell)

        val view_options =
          MotifUtils.view_options
            {parent = shell, title = title, user_options = user_options,
	     user_preferences = user_preferences,
             caller_update_fn = sense_selection,
	     sensitivity = MotifUtils.NO_SET_SELECTION,
	     view_type = MotifUtils.VIEW_ALL}

        val view_menu =
          Menus.CASCADE
            ("view",
             view_options,
             fn _ => true)

	val menuSpec =
	  [ToolData.works_menu
	    (mk_tooldata, close_window, fn () => true,
	     fn () => MotifUtils.get_user_context (!local_context)),
	   view_menu,
	   MotifUtils.value_menu
	     (shell, user_context, user_options, user_preferences, [srcText]),
	   MotifUtils.context_menu
	     {set_state = select_context,
	      get_context = fn _ => !local_context,
	      writable = MotifUtils.ALL,
	      applicationShell = applicationShell,
	      user_preferences = user_preferences},
           Menus.DYNAMIC ("history", make_history_menu, fn _ => true)]

      in
        Menus.make_submenus 
        (buttonPane,
         [Menus.PUSH ("parentButton",
                      pop_history,
                      fn _ => true),
          Menus.PUSH ("toplevelButton",
                      top_level,
                      fn _ => true)]);
        Menus.make_submenus (menuBar, menuSpec);
        Capi.Layout.lay_out
        ([Capi.Layout.MENUBAR menuBar] @@
         (case contextLabel of
            MLWorks.Option.SOME w => [Capi.Layout.OTHER w]
          | _ => [Capi.Layout.SPACE]) @@
         [Capi.Layout.OTHER srcTitleLabel,
          Capi.Layout.OTHER srcText,
          Capi.Layout.OTHER buttonPane,
          Capi.Layout.OTHER valTitleLabel,
          Capi.Layout.OTHER valText,
          Capi.Layout.OTHER typeTitleLabel,
          Capi.Layout.OTHER typeText,
          Capi.Layout.OTHER listLabel,
          Capi.Layout.TEXT pane,
          Capi.Layout.SPACE]);
        Capi.Text.set_string (srcText, initial_str);
        Capi.Callback.add (frame, Capi.Callback.Destroy, do_quit_funs);
	inspect_item (set_items, !current_item, []);
	set_context_label (user_context);
        Capi.manage shell;
        Capi.realize shell;
        initialize_graph ()
      end

    fun create tooldata =
      let
	fun mk_initial_item (user_context, user_options) =
          case UserContext.get_selected (user_context, user_options)
          of MLWorks.Option.NONE =>
	    ("()", ShellUtils.default_dynamic)
          |  MLWorks.Option.SOME history_item =>
	    case make_value_from_history_item
	           (history_item,
	            ShellTypes.new_options (user_options, user_context))
            of MLWorks.Option.NONE =>
	      ("()", ShellUtils.default_dynamic)
            |  MLWorks.Option.SOME item =>
	      item
      in
        make_inspector_window
	  false
	  (mk_initial_item, tooldata);
        ()
      end

    fun inspect_value debugger_print (str, v, tooldata) =
      make_inspector_window
	debugger_print
	(fn _ => (str, v), tooldata)
  end
@


1.78
log
@Adding Graphs
@
text
@d4 3
d317 1
d495 2
d499 11
a509 2
            fun get_children item = 
              map #2 (InspectorValues.get_inspector_values debugger_print item)
d511 2
d514 1
a514 1
            (root,
d516 1
a516 1
             MLWorks.Option.SOME (fn ((x,_),(y,_)) => cast x = cast y))
d523 16
d541 3
a543 7
            val s = item_string (gp,item)
            val ss = size s
            val left = (3 * ss) + 1
            val right = (3 * ss) + 2
            val up = 14
            val down = 2
            val fontheight = 12
d545 8
a552 2
	    Capi.GraphicsPorts.draw_fill_rectangle (gp,x-left,y-up,left+right,fontheight + 4);
            Capi.GraphicsPorts.draw_image_string (gp,s,x - left + 1,y-up+fontheight)
d557 3
a559 1
            val s = item_string (gp,item)
d561 4
a564 1
            ((3 * size s) + 1,(3 * size s) + 2,14,2)
d568 2
a569 1
          GraphWidget.make (graph_spec,item_draw_item,item_extent,make_value_graph,pane)
@


1.77
log
@Moving identifier type to Ident
@
text
@d4 3
d261 1
d276 1
d298 2
a299 1
  sharing type Menus.Widget = Capi.Widget = MotifUtils.Widget = ToolData.Widget
d395 8
d476 2
d480 1
a480 1
	    {parent = frame, name = "inspector", print_fn = print_fn,
d483 47
d611 2
a612 1
           inspect_item (set_items, v, []))
d731 1
a731 1
          Capi.Layout.TEXT winScroll,
d738 2
a739 1
        Capi.realize shell
@


1.76
log
@Minor changes to layout.
@
text
@d4 3
d258 1
a260 1
require "../main/compiler";
d274 1
a274 1
  structure Compiler : COMPILER
d285 1
a285 1
  sharing type Compiler.identifier = ToolData.UserContext.identifier
d317 1
a317 1
      of Compiler.VALUE (Compiler.Absyn.Ident.VAR s) =>
d322 1
a322 1
              (Compiler.Absyn.Ident.Symbol.symbol_name s,
@


1.75
log
@Capification
@
text
@d4 3
d654 2
a655 2
            MLWorks.Option.SOME w => [Capi.Layout.OTHER w,Capi.Layout.SPACE]
          | _ => []) @@
@


1.74
log
@ShellUtils.edit_* functions no longer require a context argument.
@
text
@d4 3
d251 1
a251 1
require "../library/xm";
d265 1
a265 1
  structure Xm : XM
d277 1
a277 1
	  MotifUtils.Options = ShellUtils.Options
d287 1
a287 1
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget = ToolData.Widget
d347 7
a353 41
        val shell =
          Xm.Widget.create (Xm.Widget.NAME "inspectorShell",
                            Xm.Widget.Class.TopLevelShell,
                            applicationShell,
                            [(Xm.Title, Xm.STRING title),
                             (Xm.IconName, Xm.STRING title)])

        val frame = Xm.Widget.createManaged (Xm.Widget.NAME "inspectorFrame",
                                             Xm.Widget.Class.Form,
                                             shell,
                                             [])
        val menuBar = Xm.Widget.createManaged (Xm.Widget.NAME "menuBar",
                                               Xm.Widget.Class.RowColumn,
                                               frame,[])

        val valText = Xm.Widget.createManaged (Xm.Widget.NAME "valText",
                                                 Xm.Widget.Class.Text,
                                                 frame, [])

        val typeText = Xm.Widget.createManaged (Xm.Widget.NAME "typeText",
                                                 Xm.Widget.Class.Text,
                                                 frame, [])

        val srcText =
	  Xm.Widget.createManaged
	    (Xm.Widget.NAME "srcText", Xm.Widget.Class.Text, frame, [])

        val buttonPane =
          Xm.Widget.createManaged
            (Xm.Widget.NAME "buttonPane", Xm.Widget.Class.RowColumn,
             frame, []);

        val parentButton =
          Xm.Widget.createManaged
            (Xm.Widget.NAME "parentButton", Xm.Widget.Class.PushButton,
             buttonPane, [])

        val toplevelButton =
          Xm.Widget.createManaged
            (Xm.Widget.NAME "toplevelButton", Xm.Widget.Class.PushButton,
             buttonPane, [])
d355 5
d367 1
a367 1
          MotifUtils.send_message (shell, s)
d399 2
a400 2
	    Xm.Text.setString (valText, print_value item);
	    Xm.Text.setString (typeText, print_type ty);
d457 1
a457 1
	  MotifUtils.make_scrolllist
d507 6
a512 23
        val (full_menus, update_fns) =
	  case user_preferences
	  of Preferences.USER_PREFERENCES ({full_menus, ...}, update_fns) =>
	    (!full_menus, update_fns)

        val contextLabel =
	  if full_menus then
	    MLWorks.Option.SOME
	      (Xm.Widget.createManaged
		 (Xm.Widget.NAME "contextLabel",
                  Xm.Widget.Class.Label, frame,[]))
	  else
	    MLWorks.Option.NONE

        val valTitleLabel = Xm.Widget.createManaged (Xm.Widget.NAME "valTitleLabel",
                                                 Xm.Widget.Class.LabelGadget,
                                                 frame,[])
        val typeTitleLabel = Xm.Widget.createManaged (Xm.Widget.NAME "typeTitleLabel",
                                                 Xm.Widget.Class.LabelGadget,
                                                 frame,[])
        val listLabel = Xm.Widget.createManaged (Xm.Widget.NAME "listLabel",
                                                 Xm.Widget.Class.LabelGadget,
                                                 frame,[])
d514 1
a514 3
	  Xm.Widget.createManaged
	    (Xm.Widget.NAME "srcTitleLabel", Xm.Widget.Class.LabelGadget,
	     frame, [])
d522 1
a522 2
              val cstring =
	        Xm.CompoundString.createSimple("Context: " ^ context_name)
d524 1
a524 2
              Xm.Widget.valuesSet
		(w, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
d540 1
a540 1
          (Xm.Text.setString (srcText, s);
d607 1
a607 1
           Xm.Widget.destroy shell)
d639 8
d648 17
a664 114
        Xm.Widget.valuesSet
	  (menuBar,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
	case contextLabel
	of MLWorks.Option.SOME w =>
          Xm.Widget.valuesSet
	    (w,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET menuBar),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.LeftOffset, Xm.INT sep_size),
              (Xm.RightOffset, Xm.INT sep_size),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)])
	|  MLWorks.Option.NONE => ();
        Xm.Widget.valuesSet
	  (srcTitleLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget,
	     case contextLabel
	     of MLWorks.Option.SOME w => Xm.WIDGET w
	     |  MLWorks.Option.NONE => Xm.WIDGET menuBar),
            (Xm.TopOffset,
	     case contextLabel
	     of MLWorks.Option.SOME w => Xm.INT 0
	     |  MLWorks.Option.NONE => Xm.INT sep_size),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (srcText,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET srcTitleLabel),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (buttonPane,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET srcText),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.TopOffset, Xm.INT sep_size),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (valTitleLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET buttonPane),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (valText,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET valTitleLabel),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (typeTitleLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET valText),
            (Xm.TopOffset, Xm.INT sep_size),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (typeText,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET typeTitleLabel),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (listLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET typeText),
            (Xm.TopOffset, Xm.INT sep_size),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (winScroll,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET listLabel),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
        Xm.Widget.callbackAdd (parentButton, Xm.Callback.Activate, pop_history);
        Xm.Widget.callbackAdd (toplevelButton, Xm.Callback.Activate, top_level);
        Xm.Text.setString (srcText, initial_str);
        Xm.Widget.callbackAdd (frame, Xm.Callback.Destroy, do_quit_funs);
d667 2
a668 2
        Xm.Widget.manage shell;
        Xm.Widget.realize shell
@


1.73
log
@Removed require "output".
@
text
@d4 3
a433 1
            val context = get_current_context()
d435 1
a435 1
            ShellUtils.edit_object (#1 (!current_item), context, preferences);
@


1.72
log
@Removed Output widget and debugger function.
@
text
@d4 3
a251 1
require "output";
a298 3
    type Widget = Xm.Widget
    type Context = ShellUtils.Context
    type UserOptions = UserOptions.user_tool_options
@


1.71
log
@Removed input window.  Moved parent and toplevel buttons to main
window from menu.  Added source text.
@
text
@d4 4
d245 1
a248 1
require "../debugger/ml_debugger";
d260 1
a263 1
  structure Ml_Debugger : ML_DEBUGGER
a266 1
  structure Output : OUTPUT_WINDOW
d268 1
a268 3
  sharing Ml_Debugger.ValuePrinter.Options = UserOptions.Options =
	  Ml_Debugger.Incremental.InterMake.Compiler.Options =
	  ToolData.ShellTypes.Options =
a269 2
  sharing ShellUtils.Info =
	  Ml_Debugger.Incremental.InterMake.Compiler.Info
d271 1
d278 3
a280 6
  sharing type InspectorValues.Type =
               Ml_Debugger.ValuePrinter.Type = ShellUtils.Type
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget = ToolData.Widget =
	       Output.Widget
  sharing type ToolData.ShellTypes.Context = Ml_Debugger.Incremental.Context =
    	       ShellUtils.Context = Output.Context
d283 1
a283 2
  sharing type Preferences.preferences = ShellUtils.preferences =
  	       Output.preferences = Ml_Debugger.preferences
a286 2
  sharing type ToolData.UserContext.identifier =
	       Ml_Debugger.Incremental.InterMake.Compiler.identifier
a292 1
    structure Compiler = Ml_Debugger.Incremental.InterMake.Compiler
d304 1
a304 2
	  (UserContext.ITEM (_, id, context, _, src),
	   debugger_function, options) =
d312 1
a312 1
	       options, context, debugger_function)
a322 1
	  debugger_window_fun
a401 25
        (* This creates the debugger window when the inspector is being created *)
        (* Strange things happen if done at debugger entry time *)
        val debugger_type = Ml_Debugger.WINDOWING (debugger_window_fun (shell,"debugger",tooldata),false)

        fun debugger_function f x =
          Ml_Debugger.with_start_frame
          (fn base_frame =>
           (f x)
           handle exn as Xm.SubLoopTerminated => raise exn
                | exn as ShellTypes.DebuggerTrapped => raise exn
                | exn as Interrupt => raise exn
                | exn as Info.Stop _ => raise exn
                | exn =>
             (Ml_Debugger.ml_debugger
              debugger_type
              (ShellTypes.new_options (user_options, user_context),
               Preferences.new_preferences user_preferences,
	       get_current_context ()) 
              (fn _ => output(std_out,"Debugger shell not defined yet\n"))
              base_frame
              (Ml_Debugger.EXCEPTION exn,
               Ml_Debugger.POSSIBLE("Exit",Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
               Ml_Debugger.NOT_POSSIBLE);
              raise ShellTypes.DebuggerTrapped))

d408 1
a408 1
	  mk_initial_item (debugger_function, user_context, user_options)
a485 7
        val {outstream, output_widget, output_visible, show_output} =
	  Output.create
	    {parent = shell, title = title,
	     get_context = get_current_context,
	     get_preferences =
	       fn () => Preferences.new_preferences user_preferences}

d584 1
a584 2
	case make_value_from_history_item
	  (item, debugger_function, get_options ())
d666 1
a666 3
             view_options
             @@ [Menus.TOGGLE
                  ("output", output_visible, show_output, fn () => true)],
d803 1
a803 2
        Xm.Widget.realize shell;
	Xm.Widget.realize output_widget
d806 1
a806 1
    fun create debugger_window_fun tooldata =
d808 1
a808 1
	fun mk_initial_item (debugger_function, user_context, user_options) =
d814 1
a814 1
	           (history_item, debugger_function,
a822 1
	  debugger_window_fun
d827 1
a827 1
    fun inspect_value debugger_print debugger_window_fun (str, v, tooldata) =
a829 1
	debugger_window_fun
@


1.70
log
@Removed inspect_variable.  Made create inspect current selection on
start-up, instead of evaluating "it".
@
text
@d4 4
d311 1
a311 1
	  (UserContext.ITEM (_, id, context, _, _),
d316 1
a316 1
	  val result =
d324 1
a324 1
          MLWorks.Option.SOME result
d332 1
a332 1
          (initial_str, mk_initial_item,
a365 5
        val textInput = Xm.Widget.createScrolledText (frame,
                                                      Xm.Widget.NAME "textIO",
                                                      [])
        val _ = Xm.Widget.manage textInput

d374 19
a398 2
        fun clear_input () = Xm.Text.setString (textInput,"")

d436 2
a437 2
        fun print_fn print_options (x, typed_value) =
	  x ^ ": "
d441 4
a444 2
        val current_item =
	  ref (mk_initial_item (debugger_function, user_context, user_options))
a488 1
        val item_history = ref []
d490 1
a490 2
        exception Eq
        fun eq ((((v,t),_)::_),(((v',t'),_)::_)) =
a495 1
        | eq _ = raise Eq
d500 1
a500 6
        fun save_current () =
          (case !item_history of
             [] => ()
           | _ => add_action (!item_history))

        fun inspect_item (set_items, new_item, history) =
d508 1
a508 2
            item_history := new_item_data :: history;
            add_action (!item_history);
d513 1
a513 1
	  inspect_item (set_items, chosen_item, !item_history)
d532 1
a532 1
          (case !item_history of 
d537 2
a538 3
          (case !item_history of
             _ :: (l as (item_data :: _)) => (clear_input ();
                                              item_history := l;
d542 1
a542 1
        fun do_toplevel _ =
d546 1
a546 2
                (clear_input ();
                 item_history := l;
d550 1
a550 1
            doit (!item_history)
d563 1
a563 2
            exception Doone
            fun doone (history as ((item_data as (item,subitems)) ::_)) =
d566 2
a567 5
                          (clear_input ();
                           item_history := history;
                           set_state (set_items,item_data)),
                          fn _ => true)
              | doone _ = raise Doone
a569 7
            Menus.PUSH ("parent",
                        pop_history,
                        can_pop) ::
            Menus.PUSH ("topLevel",
                        do_toplevel,
                        can_pop) ::
            Menus.SEPARATOR ::
a586 3
        val textLabel = Xm.Widget.createManaged (Xm.Widget.NAME "textLabel",
                                                 Xm.Widget.Class.LabelGadget,
                                                 frame,[])
d596 4
a623 26
        fun do_eval (text, context) =
          let
            val new_item =
              MLWorks.IO.with_standard_output
                outstream
                (fn () =>
                 let
                   val result = 
                     ShellUtils.eval
                       Info.default_options
                       (text, get_options (), context, debugger_function)
                 in
                   (* This should be done by with_standard_output *)
                   MLWorks.IO.flush_out std_out;
                   result
                 end)
          in
            inspect_item (set_items, new_item,[])
          end
          handle ShellTypes.DebuggerTrapped => ()
               | ShellUtils.Error(_,error,_) =>
                   MotifUtils.send_message
		     (shell, first_line (Info.string_error error))
               | ShellUtils.NotAnExpression =>
                   MotifUtils.send_message (shell, "Not an expression")

d627 4
a630 1
	of MLWorks.Option.SOME v => inspect_item (set_items, v, [])
a652 1
         item_history := [];
a676 80

        (* completion stuff *)
      datatype Exitter = NONE | SOME of (unit -> unit)

      val exitter_ref = ref NONE

      val completion_popup = MotifUtils.list_select (shell,"completions")

      fun do_completion start_pos =
        let
          val line = Xm.Text.getString textInput
	  val completion_menu =
	    case user_preferences
	    of Preferences.USER_PREFERENCES
		 ({completion_menu, ...}, _) => !completion_menu

          val options =
	    ShellTypes.new_options (user_options, user_context)

          val (sofar,completions) = 
            ShellUtils.get_completions
	      (line, options, get_current_context())

          fun insert_fun a =
            Xm.Text.insert (textInput,start_pos,String.substring(a,size sofar,size a - size sofar))
        in
          case completions of
            [] => MotifUtils.beep shell
          | [a] => insert_fun a
          | l => 
              let val c = ShellUtils.find_common_completion l 
              in
                if c = sofar then
                  if completion_menu then
                    exitter_ref :=
		      SOME (completion_popup (l,insert_fun, fn x => x))
                  else MotifUtils.beep shell
                else insert_fun c
              end
        end

      fun modifyVerify callback_data =
        let
          val _ =
            case !exitter_ref of
              NONE => ()
            | SOME f => (f();exitter_ref := NONE)

          val (_,_,doit,_,_,start_pos,end_pos,str) =
            Xm.Callback.convertTextVerify callback_data
        in
          if str = "\t"
            then
              (do_completion start_pos;
               Xm.Boolean.set (doit,false))
          else
            Xm.Boolean.set (doit, true)
        end

      fun do_return () =
	do_eval
	  (Xm.Text.getString textInput, get_current_context ())

      fun delete_current_line _ = Xm.Text.setString (textInput,"");

      fun activate callback_data =
	let val (_, event) = Xm.Callback.convertAny callback_data
	in
	  case event of
            Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^W", ...}) =>
              MotifUtils.cutSelection textInput
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^Y", ...}) =>
              MotifUtils.pasteSelection textInput
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^U", ...}) =>
              delete_current_line ()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\013", ...}) =>
              do_return ()
	  | _ => ()
	end

d719 1
a719 1
	     (shell, user_context, user_options, user_preferences, [textInput]),
d749 1
a749 1
	  (valTitleLabel,
d765 1
a765 1
	  (valText,
d767 1
a767 1
            (Xm.TopWidget, Xm.WIDGET valTitleLabel),
d774 1
a774 1
	  (typeTitleLabel,
d776 3
a778 1
            (Xm.TopWidget, Xm.WIDGET valText),
d780 7
d793 1
a793 1
	  (typeText,
d795 1
a795 1
            (Xm.TopWidget, Xm.WIDGET typeTitleLabel),
d802 1
a802 1
	  (textLabel,
d804 2
a805 2
            (Xm.TopWidget, Xm.WIDGET typeText),
	    (Xm.TopOffset, Xm.INT sep_size),
d812 1
a812 1
	  ((Xm.Widget.parent textInput),
d814 1
a814 1
            (Xm.TopWidget, Xm.WIDGET textLabel),
d823 1
a823 1
            (Xm.TopWidget, Xm.WIDGET (Xm.Widget.parent textInput)),
d840 3
a842 3
        Xm.Text.setString (textInput, initial_str);
        Xm.Widget.callbackAdd (textInput,Xm.Callback.Activate,activate);
        Xm.Widget.callbackAdd (textInput, Xm.Callback.ModifyVerify, modifyVerify);
d856 1
a856 1
	    ShellUtils.default_dynamic
d862 1
a862 1
	      ShellUtils.default_dynamic
d869 1
a869 1
	  ("", mk_initial_item, tooldata);
d877 1
a877 1
	(str, fn _ => v, tooldata)
@


1.69
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d4 3
d306 19
d328 1
a328 1
          (initial_str, initial_item,
d425 2
a426 1
        val current_item = ref initial_item
d450 2
a451 2
            (ShellUtils.edit_object (#1(!current_item),context,preferences);())
            handle ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
d453 2
d465 1
a465 1
          ShellUtils.object_editable (#1(!current_item))
d468 1
a468 1
          ShellUtils.object_traceable (#1 (!current_item))
d653 5
a657 15
      fun select_fn (UserContext.ITEM (_, id, context, _, _)) =
        case id of
          Compiler.VALUE (Compiler.Absyn.Ident.VAR s) =>
            let
              val result = 
                ShellUtils.eval
                  Info.default_options
                  (Compiler.Absyn.Ident.Symbol.symbol_name s,
		   get_options (), context, debugger_function)
            in
              (* This should be done by with_standard_output *)
              MLWorks.IO.flush_out std_out;
	      inspect_item (set_items, result, [])
            end
        | _ => ()
d942 1
a942 1
        inspect_item (set_items, initial_item,[]);
d949 14
a962 43
    fun create debugger_window_fun
	  (tooldata as ToolData.TOOLDATA
             {args as ShellTypes.LISTENER_ARGS
                {user_options, user_context, ...},
              ...}) =
      let val initial_item =
        (Info.with_report_fun
           Info.default_options
           (fn _ => ())
           ShellUtils.eval
           ("it;",
	    ShellTypes.new_options (user_options, user_context),
	    UserContext.get_context (user_context),
	    fn f => fn a => f a))
        handle _ => ShellUtils.default_dynamic
      in
        make_inspector_window
	  false
	  debugger_window_fun
	  ("", initial_item, tooldata);
        ()
      end

    fun inspect_variable
	  debugger_window_fun
	  (var,
	   context,
	   tooldata as ToolData.TOOLDATA
             {args as ShellTypes.LISTENER_ARGS
		{user_options, ...},
	      motif_context,
              ...}) =
      let val initial_item =
        (Info.with_report_fun
           Info.default_options
           (fn _ => ())
           ShellUtils.eval
             (var,
	      ShellTypes.new_options
		(user_options,
		 MotifUtils.get_user_context motif_context),
	      context, fn f => fn a => f a))
        handle _ => ShellUtils.default_dynamic
d967 1
a967 1
	  (var, initial_item, tooldata);
d971 5
a975 2
    fun inspect_value debugger_print = make_inspector_window debugger_print

@


1.68
log
@Changing interface to list_select.
@
text
@d4 3
d265 6
a270 2
  sharing type UserOptions.user_options = ToolData.ShellTypes.user_options =
               MotifUtils.UserOptions = ShellUtils.UserOptions
d280 4
a283 2
  	       UserOptions.preferences = Output.preferences =
	       Ml_Debugger.preferences
d286 1
d299 1
a299 1
    type UserOptions = UserOptions.user_options
a302 10
    fun eval_string
          error_info
          (string, context, user_options, debugger_function) =
      let
        val options = UserOptions.new_options user_options
      in
        ShellUtils.eval error_info (string,options,context,debugger_function)
      end


d309 2
a310 1
                {user_options, user_context, prompter, mk_xinterface_fn},
d313 1
a313 1
              current_context, tools, ...}) =
d353 1
a353 1
	val local_context = ref user_context
d356 2
a357 1
	  (UserContext.get_context (!local_context))
d364 8
a371 1
        fun get_user_options () = user_options
d388 2
a389 2
              (UserOptions.new_options user_options,
               UserOptions.new_preferences user_options,
d407 1
a407 2
            val options = UserOptions.new_options user_options 
            val Options.OPTIONS {print_options, ...} = options
d424 1
a424 1
            val preferences = UserOptions.new_preferences user_options 
d432 2
a433 8
          let
            val options = UserOptions.new_options user_options 
          in
            ShellUtils.trace (!current_item,
                              user_options,
                              get_current_context,
                              message_fun)
          end
d436 2
a437 8
          let
            val options = UserOptions.new_options user_options 
          in
            ShellUtils.untrace (!current_item,
                                user_options,
                                get_current_context,
                                message_fun)
          end
d457 2
a458 1
        fun add_action a = ShellUtils.add_history_item (a, history, eq, user_options)
d486 1
a486 2
        val {outstream, output_widget, output_visible,
             show_output, hide_output} =
d491 1
a491 1
	       fn () => UserOptions.new_preferences user_options}
d523 1
a523 2
            val options = UserOptions.new_options user_options 
            val Options.OPTIONS {print_options, ...} = options
d525 1
d527 3
a529 1
              ShellUtils.trim_history_string (ShellUtils.print_value (item,print_options,context),user_options)
d553 2
a554 2
	  case user_options
	  of UserOptions.USER_OPTIONS ({full_menus, ...}, update_fns) =>
d610 3
a612 3
                     eval_string
                     Info.default_options
                     (text, context, user_options, debugger_function)
d633 1
a633 1
                eval_string
d636 1
a636 1
		   context, user_options, debugger_function)
d645 2
a646 1
	case UserContext.get_selected (!local_context, user_options)
d652 2
a653 1
	       (!local_context, (select_fn, get_user_options)))
d657 2
a658 2
	   (!local_context, !select_fn_key);
	 set_context_label c;
d661 2
a662 1
	     (c, (select_fn, get_user_options));
d666 2
a667 1
	 case UserContext.get_selected (c, user_options)
d673 1
a673 1
          (current_context, (set_context, get_user_options, ToolData.ALL))
d678 2
a679 1
		     (!local_context, !select_fn_key))
a688 3
      val (options_menu,update) =
	MotifUtils.options_menu
	  (shell, title, get_user_options, sense_selection)
a689 2
      val _ = update_fns := update :: (!update_fns)

d700 7
a706 6
          val preferences = UserOptions.new_preferences user_options
          val Preferences.PREFERENCES
		{environment_options =
		   Preferences.ENVIRONMENT_OPTIONS {completion_menu,...},
		 ...} =
            preferences
a707 1
          val options = UserOptions.new_options user_options
d722 1
a722 1
                  if (!completion_menu) then
d773 3
a775 1
		       user_context = !local_context,
d780 1
d789 15
a803 5
	val menus_tail =
          [options_menu,
           Menus.DYNAMIC ("history",
                          make_history_menu,
                          fn _ => true)];
d806 14
a819 16
	  ToolData.works_menu
	    (mk_tooldata, close_window, fn () => true, fn () => !local_context)
	  :: MotifUtils.value_menu
	       (shell, user_context, user_options, [textInput])
          :: Menus.CASCADE
	       ("output",
                [Menus.PUSH
		   ("show", show_output, fn _ => not(output_visible ())),
                 Menus.PUSH ("hide", hide_output, output_visible)],
                fn _ => true)
	  :: (if full_menus then
	        MotifUtils.context_menu
	          (select_context, fn _ => !local_context, MotifUtils.ALL)
		:: menus_tail
	      else
		menus_tail)
d943 1
a943 1
           eval_string
d945 1
d947 1
a947 1
	    user_options, fn f => fn a => f a))
d962 3
a964 1
             {args as ShellTypes.LISTENER_ARGS {user_options, ...},
d970 6
a975 2
           eval_string
           (var, context, user_options, fn f => fn a => f a))
@


1.67
log
@Made contexts only visible if full_menus set.
@
text
@d4 3
d697 2
a698 1
      (* name completion *)
d726 1
a726 2
		      SOME (MotifUtils.list_select
			      (shell,"completions",l,insert_fun, fn x => x))
@


1.66
log
@Use create for making top level shell
Removing exception EditObject
@
text
@d4 4
d551 14
a564 3
        val contextLabel = Xm.Widget.createManaged (Xm.Widget.NAME "contextLabel",
                                                    Xm.Widget.Class.Label,
                                                    frame,[])
d579 12
a590 10
          let
            val context_name =
	      UserContext.get_context_name user_context
            val cstring =
	      Xm.CompoundString.createSimple("Context: " ^ context_name)
          in
            Xm.Widget.valuesSet (contextLabel,
                                 [(Xm.LabelString, 
                                   Xm.COMPOUNDSTRING cstring)])
          end
a686 2
      val UserOptions.USER_OPTIONS(_,update_fns) = user_options

d784 24
d809 1
d816 12
a827 9
        Xm.Widget.valuesSet
	  (contextLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
d831 8
a838 1
            (Xm.TopWidget, Xm.WIDGET contextLabel),
a910 36
        Menus.make_submenus (
 	  menuBar,
	  [ToolData.works_menu
	    (mk_tooldata, close_window, fn () => true, fn () => !local_context),

	    MotifUtils.value_menu
	      (shell, user_context, user_options, [textInput]),
(*
           Menus.CASCADE ("value",
                          [Menus.PUSH ("edit",
                                       edit_object,
                                       object_editable),
                           Menus.PUSH ("trace",
                                       trace_object,
                                       object_traceable),
                           Menus.PUSH ("untrace",
                                       untrace_object,
                                       object_traceable)],
                          fn _ => true),
*)
           Menus.CASCADE ("output",
                          [Menus.PUSH ("show",
                                       show_output,
                                       fn _ => not(output_visible ())),
                           Menus.PUSH ("hide",
                                       hide_output,
                                       output_visible)],
                          fn _ => true),
	   MotifUtils.context_menu
	     (select_context, fn _ => !local_context, MotifUtils.ALL),
	   (* MotifUtils.setup_menu (shell, get_user_options), *)
           options_menu,
           Menus.DYNAMIC ("history",
                          make_history_menu,
                          fn _ => true)
        ]);
@


1.65
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d4 3
d318 5
a322 5
          Xm.Widget.createPopupShell (Xm.Widget.NAME "inspectorShell",
                                      Xm.Widget.Class.TopLevelShell,
                                      applicationShell,
                                      [(Xm.Title, Xm.STRING title),
                                       (Xm.IconName, Xm.STRING title)])
d379 1
a379 1
               Ml_Debugger.NOT_POSSIBLE) [];
d413 1
a413 2
            handle ShellUtils.EditObject => message_fun "Can't edit object"
                 | ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
@


1.64
log
@Changes to context_menu.
@
text
@d3 214
a216 3
 $Log: _inspector_tool.sml,v $
Revision 1.63  1995/03/31  16:41:11  daveb
Added the history number to items in the history.
a217 208
Revision 1.62  1995/03/31  13:43:51  daveb
Removed redundant require.

Revision 1.61  1995/03/17  11:29:07  daveb
Merged ShellTypes.get_context_name and ShellTypes.string_context_name.

Revision 1.60  1995/03/16  14:32:43  daveb
Removed context_function from register when closing the window.

Revision 1.59  1995/03/15  16:19:47  daveb
Changed to share current context with other tools..

Revision 1.58  1995/03/10  15:28:23  daveb
Added calls to register select function in current context.

Revision 1.57  1995/03/02  17:13:33  daveb
Added inspect_variable, with takes a context and looks the value up
in that.

Revision 1.56  1995/02/27  13:08:21  daveb
Changed valLabel and typeLabel widgets to text widgets (and renamed
them), so that we can constrain the number of columns.

Revision 1.55  1995/02/06  16:58:36  daveb
Removed argument from value_menu.

Revision 1.54  1995/01/13  15:22:45  daveb
Replaced Option structure with references to MLWorks.Option.

Revision 1.53  1994/11/30  16:16:02  daveb
Simplified Form constraints.

Revision 1.52  1994/09/21  16:28:29  brianm
Adding value menu ...

Revision 1.51  1994/08/10  11:41:01  matthew
Add flush output

Revision 1.50  1994/08/01  10:30:22  daveb
Moved preferences to separate structure.

Revision 1.48  1994/07/12  16:11:34  daveb
ToolData.works_menu takes different arguments.

Revision 1.47  1994/06/20  11:33:53  daveb
Moved output window code to separate file.
Replaced context refs with user_contexts.

Revision 1.46  1994/03/14  16:43:55  matthew
Added untrace value facility

Revision 1.45  1994/02/23  17:02:19  nosa
Boolean indicator for Monomorphic debugger decapsulation;
Debugger scripts for tracing tool using debugger.

Revision 1.44  1994/02/02  11:53:29  daveb
Changed substructure of InterMake.

Revision 1.43  1993/12/20  12:57:49  matthew
Changed name of output window

Revision 1.42  1993/12/10  15:16:20  daveb
Added context menu, ensured that changes do the right thing, ensured that
new selection is passed on to child tools.

Revision 1.41  1993/12/09  19:34:46  jont
Added copyright message

Revision 1.40  1993/12/06  14:37:38  daveb
Ensured that output window is automatically shown when appropriate
preference is set.

Revision 1.39  1993/11/26  12:25:38  matthew
Improvements to debugger calling.

Revision 1.38  1993/10/22  16:59:47  daveb
Merged in bug fix.

Revision 1.37  1993/10/08  16:33:41  matthew
 Merging in bug fixes

Revision 1.36.1.3  1993/10/21  14:03:30  daveb
Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.

Revision 1.36.1.2  1993/10/08  14:02:45  matthew
Added horizontal scrollbar to input pane
Tests for editability and scrollability of objects
Uses history utilities
Added name completion

Revision 1.36.1.1  1993/08/29  16:47:08  jont
Fork for bug fixing

Revision 1.36  1993/08/29  16:47:08  daveb
Changed name of file menu to window.

Revision 1.35  1993/08/25  15:03:22  matthew
Return quit function from ShellUtils.edit_string

Revision 1.34  1993/08/24  13:44:40  matthew
Improved editing and tracing error handling

Revision 1.33  1993/08/12  18:05:30  daveb
Removed spurious sharing constraint.

Revision 1.32  1993/08/11  11:25:19  matthew
Changes to user options
Removed preferences menu
Options update

Revision 1.31  1993/08/10  14:46:45  nosa
Debugger-window now passed to Inspector-tool functions.

Revision 1.30  1993/08/10  10:28:17  matthew
Get maximum history length from options

Revision 1.29  1993/08/03  14:39:12  matthew
Changed history mechanism.

Revision 1.28  1993/06/16  16:34:40  matthew
Added value menu with edit and trace options

Revision 1.27  1993/06/04  10:07:16  daveb
Removed popHistory button.

Revision 1.26  1993/06/03  17:03:51  matthew
Clear text input on selection from history

Revision 1.25  1993/06/03  11:54:57  matthew
Limit error messages to first line.

Revision 1.24  1993/05/28  16:05:01  matthew
Added tty_ok value to WINDOWING
Added history

Revision 1.23  1993/05/26  17:18:30  matthew
Changed error handling for eval

Revision 1.22  1993/05/13  11:34:33  daveb
All tools now set their own titles and pass them to their options menus.

Revision 1.21  1993/05/13  10:00:22  matthew
Fixed problem with debugger window.

Revision 1.20  1993/05/12  13:09:00  matthew
Uses ShellUtils more

Revision 1.19  1993/05/11  17:17:07  matthew
Changed layout.
Better debugger interface

Revision 1.18  1993/05/10  16:03:36  daveb
Changed type of ml_debugger.

Revision 1.17  1993/05/10  14:25:22  daveb
Removed error_info field from ListenerArgs, ShellData and Incremental.options

Revision 1.16  1993/05/07  17:25:13  matthew
Added sharing constraint

Revision 1.15  1993/05/07  11:02:15  daveb
Replaced some stuff with MotifUtils.make_scrolllist.
Greatly improved layout.

Revision 1.14  1993/05/06  16:08:25  matthew
Removed printer_descriptors

Revision 1.13  1993/05/06  14:57:36  daveb
Added output widget for showing type errors, etc.

Revision 1.12  1993/05/05  19:11:53  daveb
Renamed inspect to create, and changed its type so that inspectors can
be added to the list of tools on the Works menu.

Revision 1.11  1993/05/05  12:00:34  matthew
Print type using completion

Revision 1.10  1993/04/30  14:01:00  matthew
textInput widget now called textIO

Revision 1.9  1993/04/23  14:53:09  matthew
Immediately inspect "it" on startup.  Added inspect_value function
Simple error handling for user defined methods

Revision 1.8  1993/04/21  16:45:28  matthew
Cleaned up

Revision 1.7  1993/04/20  10:25:26  matthew
Renamed Inspector_Values to InspectorValues

Revision 1.6  1993/04/06  17:50:36  daveb
Names of Callbacks have changed.

Revision 1.5  1993/04/06  16:25:10  jont
Moved user_options and version from interpreter to main

Revision 1.4  1993/04/02  17:51:07  matthew
Added text input window with expression evaluation

Revision 1.2  1993/03/30  16:35:14  matthew
Removed MENUSPEC data constructor

Revision 1.1  1993/03/26  16:50:09  matthew
Initial revision

*)

d249 1
a249 1
  sharing ToolData.ShellTypes.Info = ShellUtils.Info =
a259 2
  sharing type ToolData.ShellTypes.IncrementalOptions =
	       Ml_Debugger.Incremental.options
d265 1
a265 1
  sharing type ToolData.ShellTypes.identifier =
d271 1
d273 1
a273 1
    structure Info = ShellTypes.Info
d345 1
a345 1
	  (ShellTypes.get_context (!local_context))
d564 1
a564 1
	      ToolData.ShellTypes.get_context_name user_context
d608 1
a608 1
      fun select_fn (ShellTypes.ITEM (_, id, context, _, _)) =
d625 1
a625 1
	case ShellTypes.get_selected (!local_context, user_options)
d630 1
a630 1
	ref (ToolData.ShellTypes.add_select_fn
d634 1
a634 1
        (ToolData.ShellTypes.remove_select_fn
d638 1
a638 1
	   ToolData.ShellTypes.add_select_fn
d643 1
a643 1
	 case ToolData.ShellTypes.get_selected (c, user_options)
d653 1
a653 1
          (fn _ => ShellTypes.remove_select_fn
d917 1
a917 1
	    ShellTypes.get_context (user_context),
@


1.63
log
@Added the history number to items in the history.
@
text
@d4 3
d562 1
a562 1
	      ToolData.ShellTypes.context_name user_context
d885 2
a886 1
	   MotifUtils.context_menu (select_context, MotifUtils.ALL),
@


1.62
log
@Removed redundant require.
@
text
@d4 3
d603 1
a603 1
      fun select_fn (ShellTypes.ITEM (id, context, _, _)) =
@


1.61
log
@Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
@
text
@d4 3
a214 1
require "../debugger/value_printer";
@


1.60
log
@Removed context_function from register when closing the window.
@
text
@d4 3
d551 1
a551 1
        fun set_context_label context_ref =
d553 2
a554 3
            val context_name = ToolData.ShellTypes.get_context_name context_ref
            val context_string =
	      ToolData.ShellTypes.string_context_name context_name
d556 1
a556 1
	      Xm.CompoundString.createSimple("Context: " ^ context_string)
d639 1
a639 1
          (current_context, (set_context, get_user_options))
d852 1
a852 1
	    (mk_tooldata, close_window, fn () => true),
d877 1
a877 1
	   MotifUtils.context_menu select_context,
@


1.59
log
@Changed to share current context with other tools..
@
text
@d4 3
d206 1
d222 1
d470 2
a471 1
	    {parent = shell, title = title, get_context = get_current_context,
d475 4
d639 8
d751 4
d850 1
a850 1
	    (mk_tooldata, fn () => Xm.Widget.destroy shell, fn () => true),
d885 1
a885 4
        Xm.Widget.callbackAdd
          (frame, Xm.Callback.Destroy,
           fn _ => ShellTypes.remove_select_fn
                     (!local_context, !select_fn_key));
@


1.58
log
@Added calls to register select function in current context.
@
text
@d4 3
d284 1
a284 1
              tools, ...}) =
d324 1
a324 1
	val current_context = ref user_context
d327 1
a327 1
	  (ShellTypes.get_context (!current_context))
d353 1
a353 1
               ShellTypes.get_context user_context)
d362 3
a364 1
	  x ^ ": " ^ ShellUtils.print_value (typed_value,print_options,get_current_context())
d586 47
a632 38
	fun select_fn (ShellTypes.ITEM (id, context, _, _)) =
          case id of
            Compiler.VALUE (Compiler.Absyn.Ident.VAR s) =>
              let
                val result = 
                  eval_string
                    Info.default_options
                    (Compiler.Absyn.Ident.Symbol.symbol_name s,
		     context, user_options, debugger_function)
              in
                (* This should be done by with_standard_output *)
                MLWorks.IO.flush_out std_out;
		inspect_item (set_items, result, [])
              end
          | _ => ()

	fun sense_selection user_options =
	  case ShellTypes.get_selected (!current_context, user_options)
	  of MLWorks.Option.NONE => ()
	  |  MLWorks.Option.SOME entry => select_fn entry

	val select_fn_key =
	  ref (ToolData.ShellTypes.add_select_fn
		 (user_context, (select_fn, get_user_options)))

        fun set_context c =
	  (ToolData.ShellTypes.remove_select_fn
	     (!current_context, !select_fn_key);
	   set_context_label c;
	   select_fn_key :=
	     ToolData.ShellTypes.add_select_fn
	       (c, (select_fn, get_user_options));
           history := [];
           item_history := [];
	   current_context := c;
	   case ToolData.ShellTypes.get_selected (c, user_options)
	   of MLWorks.Option.SOME x => select_fn x
	   |  MLWorks.Option.NONE => ())
d702 1
a702 2
	  (Xm.Text.getString textInput,
	   ShellTypes.get_context (!current_context))
d725 1
a725 1
		       user_context = !current_context,
d728 1
d853 1
a853 1
	   MotifUtils.context_menu set_context,
d866 1
a866 1
                     (!current_context, !select_fn_key));
d868 1
a868 1
	set_context_label(!current_context);
d884 2
a885 1
           ("it;", ShellTypes.get_context user_context,
@


1.57
log
@Added inspect_variable, with takes a context and looks the value up
in that.
@
text
@d4 4
d245 2
d251 1
d581 25
d607 6
a612 1
	  (set_context_label c;
d616 3
a618 1
           do_eval ("it;", ShellTypes.get_context c))
d621 2
a622 1
	MotifUtils.options_menu (shell, title, get_user_options)
d849 4
@


1.56
log
@Changed valLabel and typeLabel widgets to text widgets (and renamed
them), so that we can constrain the number of columns.
@
text
@d4 4
d257 1
a257 1
          (string, context_ref, user_options, debugger_function) =
a258 1
        val context = ShellTypes.get_context context_ref
d265 10
a274 8
    fun make_inspector_window debugger_print debugger_window_fun
      (initial_str, initial_item,
       tooldata as ToolData.TOOLDATA
	 {args as ShellTypes.LISTENER_ARGS
                    {user_options, user_context, prompter, mk_xinterface_fn},
          appdata as ToolData.APPLICATIONDATA 
                       {applicationShell,...},
          tools, ...}) =
d548 1
a548 1
        fun do_eval (text, context_ref) =
d558 1
a558 1
                     (text, context_ref, user_options, debugger_function)
d560 1
a560 1
                   (* THis should be done by with_standard_output *)
d579 1
a579 1
           do_eval ("it;", c))
d647 3
a649 1
	do_eval (Xm.Text.getString textInput, !current_context)
d820 23
a842 1
              appdata = ToolData.APPLICATIONDATA {applicationShell, ...},
d846 4
a849 4
         Info.default_options
         (fn _ => ())
         eval_string
         ("it;", user_context, user_options, fn f => fn a => f a))
d852 4
a855 1
        make_inspector_window false debugger_window_fun ("", initial_item, tooldata);
d859 1
a859 1
    val inspect_value = fn debugger_print => make_inspector_window debugger_print
@


1.55
log
@Removed argument from value_menu.
@
text
@d4 3
d300 6
a305 2
(*
        val textInput = Xm.Widget.createManaged (Xm.Widget.NAME "textIO",
a306 4
                                                 frame,[])
*)
        val typeLabel = Xm.Widget.createManaged (Xm.Widget.NAME "typeLabel",
                                                 Xm.Widget.Class.Label,
a307 3
        val valLabel = Xm.Widget.createManaged (Xm.Widget.NAME "valLabel",
                                                Xm.Widget.Class.Label,
                                                frame, [])
d363 4
a366 12
            (Xm.Widget.valuesSet
             (valLabel,
              [(Xm.LabelString, 
                Xm.COMPOUNDSTRING
		  (Xm.CompoundString.createSimple (print_value item)))]);
             Xm.Widget.valuesSet
             (typeLabel,
              [(Xm.LabelString, 
                Xm.COMPOUNDSTRING
		  (Xm.CompoundString.createSimple(print_type ty)))]);
             current_item := item;
             set_items print_options subitems)
d698 1
a698 1
	  (valLabel,
d709 1
a709 1
            (Xm.TopWidget, Xm.WIDGET valLabel),
d717 1
a717 1
	  (typeLabel,
d728 1
a728 1
            (Xm.TopWidget, Xm.WIDGET typeLabel),
d769 2
a770 1
	    MotifUtils.value_menu (shell, user_context, user_options, [textInput]),
@


1.54
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d4 3
d777 1
a777 1
	    MotifUtils.value_menu (shell, user_context, user_options, [textInput,textLabel]),
@


1.53
log
@Simplified Form constraints.
@
text
@d4 3
a214 2
  sharing ToolData.ShellTypes.Option =
	  Ml_Debugger.Incremental.InterMake.Option
a235 1
    structure Option = ShellTypes.Option
@


1.52
log
@Adding value menu ...
@
text
@d4 3
a512 12
        val leftSep = Xm.Widget.createManaged (Xm.Widget.NAME "leftSep",
                                               Xm.Widget.Class.SeparatorGadget,
                                               frame,[])
        val rightSep = Xm.Widget.createManaged (Xm.Widget.NAME "rightSep",
                                               Xm.Widget.Class.SeparatorGadget,
                                               frame,[])
        val topSep = Xm.Widget.createManaged (Xm.Widget.NAME "topSep",
                                              Xm.Widget.Class.SeparatorGadget,
                                              frame,[])
        val bottomSep = Xm.Widget.createManaged (Xm.Widget.NAME "bottomSep",
                                                 Xm.Widget.Class.SeparatorGadget,
                                                 frame,[])
a515 3
        val textSep = Xm.Widget.createManaged (Xm.Widget.NAME "textSep",
                                               Xm.Widget.Class.SeparatorGadget,
                                               frame,[])
a521 3
        val typeSep = Xm.Widget.createManaged (Xm.Widget.NAME "typeSep",
                                               Xm.Widget.Class.SeparatorGadget,
                                               frame,[])
a524 3
        val listSep = Xm.Widget.createManaged (Xm.Widget.NAME "listSep",
                                               Xm.Widget.Class.SeparatorGadget,
                                               frame,[])
d675 2
d678 91
a768 129
        Xm.Widget.valuesSet (menuBar,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (leftSep,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET menuBar),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
			      (Xm.BottomWidget, Xm.WIDGET bottomSep)]);
        Xm.Widget.valuesSet (rightSep,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET menuBar),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
			      (Xm.BottomWidget, Xm.WIDGET bottomSep)]);
        Xm.Widget.valuesSet (contextLabel,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET menuBar),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (topSep,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET contextLabel),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (valTitleLabel,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET contextLabel),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (valLabel,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET valTitleLabel),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (typeSep,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET valLabel),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (typeTitleLabel,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET typeSep),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (typeLabel,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET typeTitleLabel),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (textSep,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET typeLabel),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (textLabel,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET textSep),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet ((Xm.Widget.parent textInput),
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET textLabel),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (listSep,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET (Xm.Widget.parent textInput)),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (listLabel,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET listSep),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (winScroll,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET listLabel),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.LeftWidget, Xm.WIDGET leftSep),
                              (Xm.RightWidget, Xm.WIDGET rightSep),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BottomWidget, Xm.WIDGET bottomSep)]);
        Xm.Widget.valuesSet (bottomSep,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
@


1.51
log
@Add flush output
@
text
@d4 3
d827 3
d841 1
@


1.50
log
@Moved preferences to separate structure.
@
text
@d4 3
d569 10
a578 3
                 eval_string
                 Info.default_options
                 (text, context_ref, user_options, debugger_function))
@


1.49
log
@Removed update button from history.
@
text
@d173 1
d188 1
a215 1
  sharing type UserOptions.Options.options = Output.options
d218 3
d324 2
a325 1
              (UserOptions.new_options(user_options),
d367 1
a367 1
            val options = UserOptions.new_options user_options 
d370 1
a370 1
            (ShellUtils.edit_object (#1(!current_item),context,options);())
d445 2
a446 1
	     get_options = fn () => UserOptions.new_options user_options}
d602 7
a609 2
          val Options.OPTIONS{environment_options = Options.ENVIRONMENT_OPTIONS {completion_menu,...},...} =
            options
d611 3
a613 3
            ShellUtils.get_completions (line,
                                        options,
                                        get_current_context())
@


1.48
log
@ToolData.works_menu takes different arguments.
@
text
@d4 3
a490 3
            Menus.PUSH ("update",
                        fn _ => (),
                        fn _ => false) ::
@


1.47
log
@Moved output window code to separate file.
Replaced context refs with user_contexts.
@
text
@d4 4
d219 1
a219 1
    structure ToolData = ToolData
d221 1
d801 2
a802 1
	  [ToolData.works_menu (shell, tools, mk_tooldata, fn () => true),
@


1.46
log
@Added untrace value facility
@
text
@d4 3
d170 1
d186 1
d198 1
a198 1
    MotifUtils.UserOptions = ShellUtils.UserOptions
d201 2
a202 1
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget = ToolData.Widget
d204 1
a204 1
    ShellUtils.Context
d207 1
d209 1
a209 2
  sharing type MotifUtils.UserOptions = ToolData.ShellTypes.user_options
  sharing type MotifUtils.ContextRef = ToolData.ShellTypes.ContextRef
a221 75
    fun make_text_output (parent, title, user_options) =
      let
        val shell =
          Xm.Widget.createPopupShell (Xm.Widget.NAME "textOutputShell",
                                      Xm.Widget.Class.TopLevelShell,
                                      parent,
                                      [(Xm.Title, Xm.STRING (title ^ " Output")),
                                       (Xm.IconName, Xm.STRING (title ^ " Output"))])

        val mainWindow =
          Xm.Widget.createManaged (Xm.Widget.NAME "main",
                                   Xm.Widget.Class.Form,
                                   shell, [])

        val menuBar =
          Xm.Widget.createManaged
          (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, mainWindow,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)
            ])

        val text =
          Xm.Widget.createScrolledText
          (mainWindow, Xm.Widget.NAME "textIO",
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)
            ])

        val output_visible_ref = ref false
        
        fun output_visible _ = !output_visible_ref

        fun unmanage_output _ = (output_visible_ref := false;
                                 Xm.Widget.unmanage shell)

        fun manage_output _ = (output_visible_ref := true;
                               Xm.Widget.manage shell)

        fun ensure_output () =
          let
            val UserOptions.USER_OPTIONS({auto_output_window,...},_) =
              user_options
          in
            if (!auto_output_window) then manage_output () else ()
          end
              
        val write_pos = ref 0

        fun insert_text str =
          (ensure_output ();
	   Xm.Text.insert(text, !write_pos, str);
           write_pos := size str + !write_pos;
           Xm.Text.setInsertionPosition (text, !write_pos)
           )

        val outstream = MotifUtils.make_outstream insert_text

        val menuspec =
          [Menus.CASCADE ("window",
                          [Menus.PUSH ("close",
                                       unmanage_output,
                                       fn _ => true)],
                          fn _ => true)]
      in
        Menus.make_submenus (menuBar,menuspec);
        Xm.Widget.manage text;
        (outstream,shell,output_visible,manage_output,unmanage_output)
      end


d228 1
a228 1
        val context = !(ShellTypes.get_context_ref context_ref)
d239 1
a239 1
                    {user_options, context_ref, prompter, mk_xinterface_fn},
d285 1
a285 1
	val current_context = ref context_ref
d288 1
a288 1
	  !(ShellTypes.get_context_ref (!current_context))
d313 1
a313 1
               ShellTypes.get_context_ref context_ref)
d428 5
a432 3
        val (outstream, text_output_widget, output_visible,
             manage_output, unmanage_output) =
	  make_text_output (shell, title, user_options)
d659 1
a659 1
		       context_ref = !current_context,
d810 1
a810 1
                                       manage_output,
d813 1
a813 1
                                       unmanage_output,
d830 1
a830 1
	Xm.Widget.realize text_output_widget
d836 1
a836 1
                {user_options, context_ref, ...},
d844 1
a844 1
         ("it;", context_ref, user_options, fn f => fn a => f a))
@


1.45
log
@Boolean indicator for Monomorphic debugger decapsulation;
Debugger scripts for tracing tool using debugger.
@
text
@d4 4
d441 10
d870 3
@


1.44
log
@Changed substructure of InterMake.
@
text
@d4 3
d299 2
a300 1
    fun make_inspector_window debugger_window_fun
d383 1
a383 1
               Ml_Debugger.NOT_POSSIBLE);
d465 1
a465 1
              (new_item, InspectorValues.get_inspector_values new_item)
d897 1
a897 1
        make_inspector_window debugger_window_fun ("", initial_item, tooldata);
d901 1
a901 1
    val inspect_value = make_inspector_window
@


1.43
log
@Changed name of output window
@
text
@d4 3
d183 1
a183 1
	  Ml_Debugger.Incremental.InterMake.FileName.Option
@


1.42
log
@Added context menu, ensured that changes do the right thing, ensured that
new selection is passed on to child tools.
@
text
@d4 4
d209 1
a209 1
          Xm.Widget.createPopupShell (Xm.Widget.NAME "shell",
@


1.41
log
@Added copyright message
@
text
@d4 3
d189 1
d280 2
a281 4
      error_info
      (string,
       ShellTypes.LISTENER_ARGS{context_ref,user_options,...},
       debugger_function) =
d291 6
a296 6
       tooldata as ToolData.TOOLDATA {
                                      args as ShellTypes.LISTENER_ARGS
                                      {user_options, context_ref, ...},
                                      appdata = ToolData.APPLICATIONDATA 
                                      {applicationShell,...},
                                      tools, ...}) =
d339 4
a342 1
        fun get_current_context () = !(ShellTypes.get_context_ref context_ref)
d569 1
a569 1
        fun set_context_label () =
d591 28
a618 3
        val (options_menu,update) = MotifUtils.options_menu (shell, title, get_user_options)
        val UserOptions.USER_OPTIONS(_,update_fns) = user_options
        val _ = update_fns := update :: (!update_fns)
d620 4
d678 1
a678 19
        let
          val text = Xm.Text.getString textInput
          val new_item =
            MLWorks.IO.with_standard_output
            outstream
            (fn () =>
             eval_string
             Info.default_options
             (text,args,debugger_function))
        in
          inspect_item (set_items, new_item,[])
        end
        handle ShellTypes.DebuggerTrapped => ()
             | ShellUtils.Error(_,error,_) =>
                 MotifUtils.send_message (shell,
                                          first_line (Info.string_error error))
             | ShellUtils.NotAnExpression =>
                 MotifUtils.send_message (shell,
                                          "Not an expression")
d696 10
d838 1
a838 1
	  [ToolData.works_menu (shell, tools, fn () => tooldata, fn () => true),
d855 1
d866 1
a866 1
	set_context_label();
d872 6
a877 4
    fun create debugger_window_fun (tooldata as ToolData.TOOLDATA
                                    {args,
                                     appdata = ToolData.APPLICATIONDATA {applicationShell, ...},
                                     ...}) =
d883 1
a883 1
         ("it;",args,fn f => fn a => f a))
@


1.40
log
@Ensured that output window is automatically shown when appropriate
preference is set.
@
text
@d2 1
d4 4
@


1.39
log
@Improvements to debugger calling.
@
text
@d3 3
d193 1
a193 1
    fun make_text_output (parent, title) =
a225 9
        val write_pos = ref 0

        fun insert_text str =
          ( Xm.Text.insert(text, !write_pos, str);
           write_pos := size str + !write_pos;
           Xm.Text.setInsertionPosition (text, !write_pos)
           )

        val outstream = MotifUtils.make_outstream insert_text
d236 19
d464 1
a464 1
	  make_text_output (shell, title)
a465 8
        fun ensure_output () =
          let
            val UserOptions.USER_OPTIONS({auto_output_window,...},_) =
              get_user_options()
          in
            if (!auto_output_window) then manage_output () else ()
          end
              
@


1.38
log
@Merged in bug fix.
@
text
@d3 3
a254 2
    exception Trapped

d269 1
a269 1
    fun make_inspector_window debugger_window 
d328 4
d333 1
a333 1
          MLWorks.Internal.Value.frame_call
d336 5
a340 1
           handle exn =>
d342 1
a342 1
              (Ml_Debugger.WINDOWING (debugger_window(shell,"debugger",tooldata),true))
d348 1
a348 1
               Ml_Debugger.POSSIBLE("Exit",Ml_Debugger.DO_RAISE Trapped),
d350 1
a350 3
              raise exn (* This never gets evaluated, but it keeps the
                         typechecker happy *)
                ))
d646 1
a646 1
        handle Trapped => ()
d835 4
a838 4
    fun create debugger_window (tooldata as ToolData.TOOLDATA
                                {args,
                                 appdata = ToolData.APPLICATIONDATA {applicationShell, ...},
                                 ...}) =
d847 1
a847 1
        make_inspector_window debugger_window ("", initial_item, tooldata);
@


1.37
log
@ Merging in bug fixes
@
text
@d3 7
d795 1
a795 1
	  [ToolData.works_menu (shell, tools, fn () => tooldata),
@


1.36
log
@Changed name of file menu to window.
@
text
@d3 12
d247 2
a256 1
        val result = ShellUtils.eval error_info (string,options,context,debugger_function)
d258 1
a258 1
        result
a260 2
    val inspector_number = ref 1

d294 6
d303 1
d311 1
a311 1
        val context = !(ShellTypes.get_context_ref context_ref)
d318 2
d339 1
a339 1
	  x ^ ": " ^ ShellUtils.print_value (typed_value,print_options,context)
d347 1
d369 1
a369 1
        fun edit_definition _ =
d372 1
a372 1
            val context = context
d379 1
a379 1
        fun trace_definition _ =
a381 1
            val context = context
d385 1
a385 1
                              fn () => context,
d389 2
a390 2
        fun definition_editable _ =
          true
d392 3
a394 8
        (* There is no need to go throught an options structure for this. *)
        fun get_max_history () =
          let
            val UserOptions.USER_OPTIONS({history_length,...},_) = user_options
          in
            !history_length
          end
          
d407 1
a407 12
        fun ministry_of_truth ([], _, _) = []
          |   ministry_of_truth (s::l, new_factoid, finish) =
              if finish > 0
                then
                  if eq (s,new_factoid) then
                    l
                  else
                    s :: ministry_of_truth (l, new_factoid, finish - 1)
              else []

        fun add_action a =
          history := a :: (ministry_of_truth (!history,a,get_max_history()))
d439 8
d470 1
d475 1
d477 1
a477 1
              ShellUtils.print_value (item,print_options,context)
a552 2
        fun get_user_options () = user_options

d565 91
d748 1
a748 1
        Xm.Widget.valuesSet (textInput,
d758 1
a758 1
                              (Xm.TopWidget, Xm.WIDGET textInput),
d791 2
a792 2
                                       edit_definition,
                                       definition_editable),
d794 2
a795 2
                                       trace_definition,
                                       fn _ => true)],
d812 2
a813 22
        Xm.Widget.callbackAdd
        (textInput,
         Xm.Callback.Activate,
         (fn _ =>
          let
            val text = Xm.Text.getString textInput
            val new_item = MLWorks.IO.with_standard_output
			     outstream
			     (fn () =>
                              eval_string
                              Info.default_options
                              (text,args,debugger_function))
          in
            inspect_item (set_items, new_item,[])
           end
         handle Trapped => ()
              | ShellUtils.Error(_,error,_) =>
                  MotifUtils.send_message (shell,
                                           first_line (Info.string_error error))
              | ShellUtils.NotAnExpression =>
                  MotifUtils.send_message (shell,
                                           "Not an expression")));
@


1.36.1.1
log
@Fork for bug fixing
@
text
@a2 3
Revision 1.36  1993/08/29  16:47:08  daveb
Changed name of file menu to window.

@


1.36.1.2
log
@Added horizontal scrollbar to input pane
Tests for editability and scrollability of objects
Uses history utilities
Added name completion
@
text
@a2 3
Revision 1.36.1.1  1993/08/29  16:47:08  jont
Fork for bug fixing

a237 2
    val inspector_number = ref 1

d246 1
d248 1
a248 1
        ShellUtils.eval error_info (string,options,context,debugger_function)
d251 2
a285 6

        val textInput = Xm.Widget.createScrolledText (frame,
                                                      Xm.Widget.NAME "textIO",
                                                      [])
        val _ = Xm.Widget.manage textInput
(*
a288 1
*)
d296 1
a296 1
        fun get_current_context () = !(ShellTypes.get_context_ref context_ref)
a302 2
        fun get_user_options () = user_options

d322 1
a322 1
	  x ^ ": " ^ ShellUtils.print_value (typed_value,print_options,get_current_context())
a329 1
            val context = get_current_context ()
d351 1
a351 1
        fun edit_object _ =
d354 1
a354 1
            val context = get_current_context()
d361 1
a361 1
        fun trace_object _ =
d364 1
d368 1
a368 1
                              get_current_context,
d372 2
a373 2
        fun object_editable _ =
          ShellUtils.object_editable (#1(!current_item))
d375 8
a382 3
        fun object_traceable _ =
          ShellUtils.object_traceable (#1 (!current_item))

d395 9
a403 1
        fun add_action a = ShellUtils.add_history_item (a, history, eq, user_options)
d405 3
a437 8
        fun ensure_output () =
          let
            val UserOptions.USER_OPTIONS({auto_output_window,...},_) =
              get_user_options()
          in
            if (!auto_output_window) then manage_output () else ()
          end
              
a460 1

a464 1
            val context = get_current_context()
d466 1
a466 1
              ShellUtils.trim_history_string (ShellUtils.print_value (item,print_options,context),user_options)
d542 2
a555 91

        (* completion stuff *)
      datatype Exitter = NONE | SOME of (unit -> unit)

      val exitter_ref = ref NONE

      (* name completion *)
      fun do_completion start_pos =
        let
          val line = Xm.Text.getString textInput
          val options = UserOptions.new_options user_options
          val Options.OPTIONS{environment_options = Options.ENVIRONMENT_OPTIONS {completion_menu,...},...} =
            options
          val (sofar,completions) = 
            ShellUtils.get_completions (line,
                                        options,
                                        get_current_context())
          fun insert_fun a =
            Xm.Text.insert (textInput,start_pos,String.substring(a,size sofar,size a - size sofar))
        in
          case completions of
            [] => MotifUtils.beep shell
          | [a] => insert_fun a
          | l => 
              let val c = ShellUtils.find_common_completion l 
              in
                if c = sofar then
                  if (!completion_menu) then
                    exitter_ref :=
		      SOME (MotifUtils.list_select
			      (shell,"completions",l,insert_fun, fn x => x))
                  else MotifUtils.beep shell
                else insert_fun c
              end
        end

      fun modifyVerify callback_data =
        let
          val _ =
            case !exitter_ref of
              NONE => ()
            | SOME f => (f();exitter_ref := NONE)

          val (_,_,doit,_,_,start_pos,end_pos,str) =
            Xm.Callback.convertTextVerify callback_data
        in
          if str = "\t"
            then
              (do_completion start_pos;
               Xm.Boolean.set (doit,false))
          else
            Xm.Boolean.set (doit, true)
        end

      fun do_return () =
        let
          val text = Xm.Text.getString textInput
          val new_item =
            MLWorks.IO.with_standard_output
            outstream
            (fn () =>
             eval_string
             Info.default_options
             (text,args,debugger_function))
        in
          inspect_item (set_items, new_item,[])
        end
        handle Trapped => ()
             | ShellUtils.Error(_,error,_) =>
                 MotifUtils.send_message (shell,
                                          first_line (Info.string_error error))
             | ShellUtils.NotAnExpression =>
                 MotifUtils.send_message (shell,
                                          "Not an expression")

      fun delete_current_line _ = Xm.Text.setString (textInput,"");

      fun activate callback_data =
	let val (_, event) = Xm.Callback.convertAny callback_data
	in
	  case event of
            Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^W", ...}) =>
              MotifUtils.cutSelection textInput
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^Y", ...}) =>
              MotifUtils.pasteSelection textInput
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^U", ...}) =>
              delete_current_line ()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\013", ...}) =>
              do_return ()
	  | _ => ()
	end
d648 1
a648 1
        Xm.Widget.valuesSet ((Xm.Widget.parent textInput),
d658 1
a658 1
                              (Xm.TopWidget, Xm.WIDGET (Xm.Widget.parent textInput)),
d691 2
a692 2
                                       edit_object,
                                       object_editable),
d694 2
a695 2
                                       trace_object,
                                       object_traceable)],
d712 22
a733 2
        Xm.Widget.callbackAdd (textInput,Xm.Callback.Activate,activate);
        Xm.Widget.callbackAdd (textInput, Xm.Callback.ModifyVerify, modifyVerify);
@


1.36.1.3
log
@Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.
@
text
@a2 6
Revision 1.36.1.2  1993/10/08  14:02:45  matthew
Added horizontal scrollbar to input pane
Tests for editability and scrollability of objects
Uses history utilities
Added name completion

d782 1
a782 1
	  [ToolData.works_menu (shell, tools, fn () => tooldata, fn () => true),
@


1.35
log
@Return quit function from ShellUtils.edit_string
@
text
@d3 3
d221 1
a221 1
          [Menus.CASCADE ("file",
@


1.34
log
@Improved editing and tracing error handling
@
text
@d3 3
d350 1
a350 1
            ShellUtils.edit_object (#1(!current_item),context,options)
@


1.33
log
@Removed spurious sharing constraint.
@
text
@d3 3
d291 3
d348 2
a349 2
            handle ShellUtils.EditObject =>
              output(std_out,"Can't edit object\n")
d357 4
a360 3
            ShellUtils.trace ((!current_item),user_options,fn () => context)
            handle ShellUtils.EditObject =>
              output(std_out,"Can't edit object\n")
d409 1
a409 2
                (MotifUtils.send_message (shell,
					  "Error in User Inspect Method");
@


1.32
log
@Changes to user options
Removed preferences menu
Options update
@
text
@d3 5
a134 1
  sharing ShellUtils.Filename = Ml_Debugger.Incremental.InterMake.FileName
@


1.31
log
@Debugger-window now passed to Inspector-tool functions.
@
text
@d3 3
d358 1
a358 1
            val UserOptions.USER_OPTIONS{history_length,...} = user_options
d533 4
d686 2
a687 2
	   MotifUtils.setup_menu (shell, get_user_options),
	   MotifUtils.options_menu (shell, title, get_user_options),
@


1.30
log
@Get maximum history length from options
@
text
@d3 3
a105 1
require "debugger_window";
a117 1
  structure DebuggerWindow : DEBUGGERWINDOW
d126 1
a126 2
	  Ml_Debugger.Incremental.InterMake.FileName.Option =
          DebuggerWindow.Option
d133 1
a133 2
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget = ToolData.Widget =
	       DebuggerWindow.Widget
d145 1
a150 1
    type ToolData = ToolData.ToolData
d234 8
a241 7
    fun make_inspector_window (initial_str, initial_item,
                               tooldata as ToolData.TOOLDATA {
				 args as ShellTypes.LISTENER_ARGS
				           {user_options, context_ref, ...},
				 appdata = ToolData.APPLICATIONDATA 
				             {applicationShell,...},
				 tools, ...}) =
a280 3
        val (debugger_window_fn,message_fn) =
          DebuggerWindow.make_debugger_window(shell,"debugger")

d287 1
a287 1
              (Ml_Debugger.WINDOWING (debugger_window_fn,message_fn,true))
d715 4
a718 4
    fun create (tooldata as ToolData.TOOLDATA
		  {args,
		   appdata = ToolData.APPLICATIONDATA {applicationShell, ...},
		   ...}) =
d727 1
a727 1
        make_inspector_window ("", initial_item, tooldata);
@


1.29
log
@Changed history mechanism.
@
text
@d3 3
d355 8
a362 1
        val max_history = 20
d375 1
a375 2
        fun ministry_of_truth (_, _, 0) = []
          |   ministry_of_truth ([], _, _) = []
d377 7
a383 4
              if eq (s,new_factoid) then
                l
              else
                s :: ministry_of_truth (l, new_factoid, finish - 1)
d386 1
a386 1
          history := a :: (ministry_of_truth (!history,a,max_history))
@


1.28
log
@Added value menu with edit and trace options
@
text
@d3 3
a350 2
          
        val history = ref []
d354 1
d356 2
a357 1
        fun eq (((v,t),_),((v',t'),_)) =
d363 1
d376 6
a381 1
        fun inspect_item (set_items, new_item) =
d390 2
a391 1
            add_action new_item_data;
d396 1
a396 1
	  inspect_item (set_items, chosen_item)
d408 1
a408 1
          (case !history of 
d413 3
a415 3
          (case !history of
             _ :: (l as (item_data :: _)) => (add_action item_data;
                                              clear_input ();
d419 11
d437 2
a438 1
            fun doone (item_data as (item,subitems)) =
d441 2
a442 2
                          (add_action item_data;
                           clear_input ();
d445 1
d448 10
d690 1
a690 1
            inspect_item (set_items, new_item)
d699 1
a699 1
        inspect_item (set_items, initial_item);
@


1.27
log
@Removed popHistory button.
@
text
@d3 3
d123 2
a124 1
  sharing type UserOptions.user_options = ToolData.ShellTypes.user_options
d299 2
d322 1
d326 23
d621 8
@


1.26
log
@Clear text input on selection from history
@
text
@d3 3
a394 1
            (Menus.PUSH ("popHistory",pop_history,can_pop)) ::
@


1.25
log
@Limit error messages to first line.
@
text
@d3 3
a6 4
>



d266 2
d372 1
d387 1
@


1.24
log
@>



Added tty_ok value to WINDOWING
Added history
@
text
@d3 8
d445 8
d619 1
a619 1
                                           Info.string_error error)
@


1.23
log
@Changed error handling for eval
@
text
@d3 3
d259 1
a259 1
        val debugger_window_fn =
d268 1
a268 1
              (Ml_Debugger.WINDOWING debugger_window_fn)
a279 2
        val stack = ref []

d307 23
d339 1
a339 1
            stack := new_item_data :: (!stack);
d356 1
a356 1
          (case !stack of 
d360 3
a362 3
        fun pop_stack _ =
          (case !stack of
             _ :: (l as (item_data :: _)) => (stack := l;
d366 19
d580 2
a581 4
           Menus.CASCADE ("history",
                          [Menus.PUSH ("popHistory",
                                       pop_stack,
                                       can_pop)],
@


1.22
log
@All tools now set their own titles and pass them to their options menus.
@
text
@d3 3
a129 2
    exception Error

d197 5
a201 3
    fun eval_string (string,
                     ShellTypes.LISTENER_ARGS{context_ref,user_options,...},
                     debugger_function) =
d205 1
a205 5
        val result = ShellUtils.eval (string,options,context,debugger_function)
          (* Lets not take any chances *)
          handle exn as Trapped => raise exn
               | exn as ShellUtils.NotAnExpression => raise exn
               | _ => raise Error
d552 4
a555 1
			     (fn () => eval_string (text,args,debugger_function))
d559 4
a562 2
         handle Error => manage_output ()
              | Trapped => ()
d578 6
a583 2
        eval_string ("it",args,fn f => fn a => f a)
        handle Error => ShellUtils.default_dynamic
@


1.21
log
@Fixed problem with debugger window.
@
text
@d3 3
d129 1
a129 1
    fun make_text_output parent =
d135 2
a136 2
                                      [(Xm.Title, Xm.STRING "Inspector Output"),
                                       (Xm.IconName, Xm.STRING "Inspector Output")])
d211 2
d221 10
d235 3
a237 1
                                      [])
d330 1
a330 1
	  make_text_output shell
d537 1
a537 1
	   MotifUtils.options_menu (shell, get_user_options),
@


1.20
log
@Uses ShellUtils more
@
text
@d3 3
d193 3
a195 4
    fun eval_string (ShellTypes.LISTENER_ARGS
		       {context_ref, user_options,
			mk_xinterface_fn, prompter},
		     shell, string) =
d199 5
a203 27

        val debugger_window_fn =
          DebuggerWindow.make_debugger_window(shell,"debugger")

        fun debugger_function f x =
          MLWorks.Internal.Value.frame_call
          (fn base_frame =>
           (f x)
           handle exn =>
             (Ml_Debugger.ml_debugger
              (Ml_Debugger.WINDOWING debugger_window_fn)
              (UserOptions.new_options(user_options),
               ShellTypes.get_context_ref context_ref)
              (fn _ => output(std_out,"Debugger shell not defined yet\n"))
              base_frame
              (Ml_Debugger.EXCEPTION exn,
               Ml_Debugger.POSSIBLE("Exit",Ml_Debugger.DO_RAISE Trapped),
               Ml_Debugger.NOT_POSSIBLE);
              raise exn (* This never gets evaluated, but it keeps the
                         typechecker happy *)
                ))

          val result = ShellUtils.eval (string,options,context,debugger_function)
            (* Lets not take any chances *)
            handle exn as Trapped => raise exn
                 | exn as ShellUtils.NotAnExpression => raise exn
                 | _ => raise Error
d240 20
a259 3
        val (outstream, text_output_widget, output_visible,
             manage_output, unmanage_output) =
	  make_text_output shell
d536 1
a536 1
			     (fn () => eval_string (args,shell,text))
d557 1
a557 1
        eval_string (args, applicationShell, "it")
@


1.19
log
@Changed layout.
Better debugger interface
@
text
@d3 4
a62 4
require "../parser/parser";
require "../typechecker/basis";
require "../typechecker/types";
require "../typechecker/completion";
d64 1
a64 1
require "../utils/integer";
d66 1
a66 3
require "../main/user_options";
require "../interpreter/shell";
require "../interpreter/tty_listener";
a77 2
  structure Integer : INTEGER
  structure Parser : PARSER
a78 3
  structure Basis : BASIS
  structure Types : TYPES
  structure Completion : COMPLETION
d80 1
a86 4
  sharing Ml_Debugger.Incremental.InterMake.Inter_EnvTypes.EnvironTypes.LambdaTypes.Ident =
          Basis.BasisTypes.Datatypes.Ident
  sharing Basis.BasisTypes.Datatypes = Types.Datatypes =
          Ml_Debugger.Incremental.Datatypes = Completion.Datatypes
d88 4
a91 5
	  Types.Options = Ml_Debugger.Incremental.InterMake.Compiler.Options =
	  Parser.Options = ToolData.ShellTypes.Options = Completion.Options =
	  MotifUtils.Options
  sharing Parser.Absyn = Ml_Debugger.Incremental.InterMake.Compiler.Absyn
  sharing Parser.Lexer.Info = ToolData.ShellTypes.Info =
d96 1
d99 2
a100 4
  sharing type Parser.ParserBasis =
	       Ml_Debugger.Incremental.InterMake.Compiler.ParserBasis
  sharing type Basis.BasisTypes.Datatypes.Type = InspectorValues.Type =
               Ml_Debugger.ValuePrinter.Type
d103 2
a104 3
  sharing type Basis.BasisTypes.Basis =
	       Ml_Debugger.Incremental.InterMake.Compiler.TypeBasis
  sharing type ToolData.ShellTypes.Context = Ml_Debugger.Incremental.Context
a110 4
    structure Incremental = Ml_Debugger.Incremental
    structure Ident = Basis.BasisTypes.Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Inter_EnvTypes = Incremental.InterMake.Inter_EnvTypes
a111 1
    structure BasisTypes = Basis.BasisTypes
d113 1
a113 1
    structure Info = Parser.Lexer.Info
d117 1
a117 1
    type Context = Incremental.Context
d194 1
a194 1
      (let
a196 1
        val parser_basis = Incremental.parser_basis context
d198 2
a199 2
      val debugger_window_fn =
        DebuggerWindow.make_debugger_window(shell,"debugger")
d201 1
a201 1
      fun debugger_function f x =
d204 20
a223 29
             (f x)
             handle exn =>
               (Ml_Debugger.ml_debugger
                 (Ml_Debugger.WINDOWING debugger_window_fn)
                 (UserOptions.new_options(user_options),
                  ShellTypes.get_context_ref context_ref)
                  (fn _ => output(std_out,"Debugger shell not defined yet\n"))
                  base_frame
                  (Ml_Debugger.EXCEPTION exn,
                   Ml_Debugger.POSSIBLE("Exit",Ml_Debugger.DO_RAISE Trapped),
                   Ml_Debugger.NOT_POSSIBLE);
		raise exn (* This never gets evaluated, but it keeps the
			     typechecker happy *)
	  ))

        val inc_options =
          Incremental.OPTIONS {options = options,
                               debugger = debugger_function}

        val input_fn =
          let val sref = ref string
          in
            fn _ => let val result = !sref in sref := "" ; result end
          end
        val token_stream = Parser.Lexer.mkTokenStream (input_fn,"Eval input")
        val (topdec,_) = Parser.parse_topdec Info.default_options
			   (options,token_stream,parser_basis)
        val result = Incremental.evaluate_exp_topdec
		       (inc_options,context,topdec)
a226 3
      (* Lets not take any chances *)
      handle exn as Trapped => raise exn
           | _ => raise Error)
a259 2
	val debug_info = Incremental.debug_info context

a265 4
        fun print_value print_options (object,ty) =
            Ml_Debugger.ValuePrinter.stringify_value
	      (print_options, object, ty, debug_info)

d267 1
a267 1
	  x ^ ": " ^ print_value print_options typed_value
d274 5
a278 10
            fun get_completion_env () =
              let
                val type_basis = Incremental.type_basis context
                val BasisTypes.BASIS(_,_,_,env) = type_basis
              in
                env
              end
                
            fun print_type ty = Completion.print_type
				  (print_options,get_completion_env(),ty)
d284 1
a284 1
		  (Xm.CompoundString.createSimple (print_value print_options item)))]);
d298 1
a298 1
                (MotifUtils.send_message (applicationShell,
d544 4
a547 1
              | Trapped => ()));
d561 1
a561 1
        handle Error => (MLWorks.Internal.Value.cast (),Types.empty_rectype)
@


1.18
log
@Changed type of ml_debugger.
@
text
@d3 3
d206 2
d232 1
a232 1
                   Ml_Debugger.NOT_POSSIBLE,
d256 2
a257 1
      handle _ => raise Error)
a288 1
	val options = UserOptions.new_options user_options 
a290 2
	val Options.OPTIONS {print_options, ...} = options

d308 3
d499 1
a499 1
        Xm.Widget.valuesSet (listSep,
d507 1
a507 1
        Xm.Widget.valuesSet (listLabel,
d509 1
a509 1
                              (Xm.TopWidget, Xm.WIDGET listSep),
d515 1
a515 1
        Xm.Widget.valuesSet (winScroll,
d517 1
a517 1
                              (Xm.TopWidget, Xm.WIDGET listLabel),
d523 1
a523 1
        Xm.Widget.valuesSet (textSep,
d525 1
a525 1
                              (Xm.TopWidget, Xm.WIDGET winScroll),
d531 1
a531 1
        Xm.Widget.valuesSet (textLabel,
d533 1
a533 1
                              (Xm.TopWidget, Xm.WIDGET textSep),
d539 1
a539 1
        Xm.Widget.valuesSet (textInput,
d541 1
a541 1
                              (Xm.TopWidget, Xm.WIDGET textLabel),
d546 2
a547 1
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
d549 1
a549 2
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET textInput),
d584 3
a586 1
           end handle Error => manage_output ()));
d598 3
a600 4
      let val (initial_str, initial_item) =
        ("it", eval_string (args, applicationShell, "it"))
        handle Error =>
	  ("()", (MLWorks.Internal.Value.cast (),Types.empty_rectype))
d602 1
a602 1
        make_inspector_window (initial_str, initial_item, tooldata);
@


1.17
log
@Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d3 3
d222 1
a222 3
                 (Incremental.OPTIONS
		    {options = UserOptions.new_options(user_options),
                     debugger = debugger_function},
@


1.16
log
@Added sharing constraint
@
text
@d3 3
d125 1
d201 1
a201 1
		       {context_ref, user_options, error_info,
d220 1
a220 2
		    {error_info = error_info,
                     options = UserOptions.new_options(user_options),
d233 1
a233 2
          Incremental.OPTIONS {error_info = error_info,
                               options = options,
d242 1
a242 1
        val (topdec,_) = Parser.parse_topdec error_info
@


1.15
log
@Replaced some stuff with MotifUtils.make_scrolllist.
Greatly improved layout.
@
text
@d3 4
d96 2
a97 1
	  Ml_Debugger.Incremental.InterMake.FileName.Option
@


1.14
log
@Removed printer_descriptors
@
text
@d3 3
d86 2
a87 1
	  Parser.Options = ToolData.ShellTypes.Options = Completion.Options
d106 2
d245 1
a245 16
    (* This should all just be replaced by the stuff in MotifUtils *)
    fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
    val convert_callback = env "x convert ListCallbackStruct"

    fun get_selected_pos callback_data =
      let val (_,_,_,_,n,_,_,_,_) = convert_callback callback_data
      in
        n
      end

    exception Nth
    fun nth (0,a::b) = a
      | nth (n,a::b) = nth(n-1,b)
      | nth (n,[]) = raise Nth
        
    fun make_inspector_window (initial_item,
d251 1
a251 1
				 ...}) =
d268 1
a268 1
        val typeLabel = Xm.Widget.createManaged (Xm.Widget.NAME "inspectorTypeLabel",
d271 1
a271 1
        val valLabel = Xm.Widget.createManaged (Xm.Widget.NAME "inspectorValLabel",
a273 5
        val win = Xm.Widget.createManaged (Xm.Widget.NAME "inspector",
                                           Xm.Widget.Class.List,
                                           frame,
                                           [(Xm.SelectionPolicy,
                                             Xm.SELECTIONPOLICY Xm.SINGLE_SELECT)])
d275 6
d288 8
a295 1
        fun set_state (item as (value,ty),subitems) =
a296 11
            val options = UserOptions.new_options user_options
            val context = !(ShellTypes.get_context_ref context_ref)
	    val Options.OPTIONS {print_options, ...} = options
	    val debug_info = Incremental.debug_info context

            fun print_value (object,ty) =
              Ml_Debugger.ValuePrinter.stringify_value(print_options,
                                                       object,
                                                       ty,
                                                       debug_info)

a306 9

            fun make_item_list l =
              map (fn (x,y) => implode[x,": ", print_value y]) l

            fun set_items (widget,itemlist) =
              (Xm.List.deleteAllItems widget;
               Xm.List.addItems (widget,
				 map Xm.CompoundString.createSimple itemlist,
				 0))
d312 1
a312 1
		  (Xm.CompoundString.createSimple (print_value item)))]);
d318 14
a331 1
             set_items (win,make_item_list subitems))
d334 12
d354 1
a354 1
                                              set_state item_data)
d357 38
a394 1
        fun inspect_item new_item =
d396 5
a400 6
            val new_item_data =
              (new_item,InspectorValues.get_inspector_values new_item)
              handle InspectorValues.DuffUserMethod _ =>
                (MotifUtils.send_message (applicationShell,
					  "Error in User Inspect Method");
                 (new_item,[]))
d402 3
a404 2
            stack := new_item_data :: (!stack);
            set_state new_item_data
d406 3
d415 1
a415 1
        Xm.Widget.valuesSet (textInput,
d419 7
d427 25
d455 21
a475 3
                              (Xm.TopWidget, Xm.WIDGET textInput),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
d479 5
a483 3
                              (Xm.TopWidget, Xm.WIDGET valLabel),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
d485 1
a485 1
        Xm.Widget.valuesSet (win,
d488 48
d541 1
a541 5
          [Menus.CASCADE ("file",
                          [Menus.PUSH ("close",
                                       fn _ => Xm.Widget.destroy shell,
                                       fn _ => true)],
                          fn _ => true),
d550 2
d558 1
a558 1
        Xm.Text.setString (textInput,"");
d569 1
a569 1
            inspect_item new_item
d571 2
a572 12
        Xm.Widget.callbackAdd
        (win,
         Xm.Callback.SingleSelection,
         (fn callback_data =>
          (let
            val pos = get_selected_pos (callback_data)
            val ((_,subitems) :: _) = !stack
            val new_item = #2(nth(pos-1,subitems))
           in
             inspect_item new_item
           end)));
        inspect_item initial_item;
d582 4
a585 3
      let val initial_item =
        eval_string (args, applicationShell, "it")
        handle Error => (MLWorks.Internal.Value.cast (),Types.empty_rectype)
d587 1
a587 1
        make_inspector_window (initial_item, tooldata);
@


1.13
log
@Added output widget for showing type errors, etc.
@
text
@d3 3
a89 2
  sharing type Ml_Debugger.ValuePrinter.printer_descriptor =
	       ToolData.ShellTypes.printer_descriptor
a101 2
  sharing type ToolData.ShellTypes.print_method_table =
	       Ml_Debugger.ValuePrinter.print_method_table
a103 1

d186 2
a187 2
		       {context_ref, user_options, error_info, name_monitor,
			print_method_table_ref, mk_xinterface_fn, prompter},
d204 1
a204 2
                 (!print_method_table_ref,
                  Incremental.OPTIONS
a206 1
                     name_monitor = name_monitor,
a220 1
                               name_monitor = name_monitor,
d257 1
a257 2
				           {user_options, context_ref,
				            print_method_table_ref, ...},
a295 3
	val options = UserOptions.new_options user_options 
        val context = !(ShellTypes.get_context_ref context_ref)

d298 2
d301 1
a301 7

            val printer_descriptor = 
	      Ml_Debugger.ValuePrinter.PRINTER_DESCRIPTOR
		{print_options = print_options,
		 print_method_table = !print_method_table_ref}

	    val debug_info = Incremental.debug_info (context)
d304 4
a307 4
              Ml_Debugger.ValuePrinter.stringify_value(printer_descriptor,
                                           object,
                                           ty,
                                           debug_info)
@


1.12
log
@Renamed inspect to create, and changed its type so that inspectors can
be added to the list of tools on the Works menu.
@
text
@d3 4
d122 64
d296 3
d408 21
a428 12
        Menus.make_submenus (menuBar,
                             [Menus.CASCADE ("file",
                                             [Menus.PUSH ("close",
                                                          fn _ => Xm.Widget.destroy shell,
                                                          fn _ => true)],
                                             fn _ => true),
                              Menus.CASCADE ("history",
                                             [Menus.PUSH ("popHistory",
                                                          pop_stack,
                                                          can_pop)],
                                             fn _ => true)
                              ]);
d436 3
a438 1
            val new_item = eval_string (args,shell,text)
d441 1
a441 1
           end handle Error => ()));
d455 2
a456 1
        Xm.Widget.realize shell
d459 4
a462 1
    fun create (tooldata as ToolData.TOOLDATA {args, appdata = ToolData.APPLICATIONDATA {applicationShell, ...}, ...}) =
a463 1
	(* This probably should take a better shell argument *)
@


1.11
log
@Print type using completion
@
text
@d3 3
a35 1
require "../interpreter/incremental";
d44 2
a45 1
require "../interpreter/shell_types";
d47 1
d50 2
d55 46
a100 38
functor InspectorTool (structure Xm : XM
                       structure Integer : INTEGER
                       structure Incremental : INCREMENTAL
                       structure Parser : PARSER
                       structure UserOptions : USER_OPTIONS
                       structure Basis : BASIS
                       structure Types : TYPES
                       structure Completion : COMPLETION
                       structure InspectorValues : INSPECTOR_VALUES
                       structure ValuePrinter : VALUE_PRINTER
                       structure Menus : MENUS
                       structure MotifUtils : MOTIF_UTILS
                       structure ShellTypes : SHELL_TYPES

                       sharing Incremental.InterMake.Inter_EnvTypes.EnvironTypes.LambdaTypes.Ident =
                         Basis.BasisTypes.Datatypes.Ident
                       sharing Basis.BasisTypes.Datatypes = Types.Datatypes =
                         Incremental.Datatypes = Completion.Datatypes
                       sharing ValuePrinter.Options = UserOptions.Options = Types.Options =
                         Incremental.InterMake.Compiler.Options = Parser.Options =
                         ShellTypes.Options = Completion.Options
                       sharing Parser.Absyn = Incremental.InterMake.Compiler.Absyn
                       sharing Parser.Lexer.Info = ShellTypes.Info

                       sharing type ValuePrinter.printer_descriptor = ShellTypes.printer_descriptor
                       sharing type UserOptions.user_options = ShellTypes.user_options
                       sharing type Parser.ParserBasis = Incremental.InterMake.Compiler.ParserBasis
                       sharing type ValuePrinter.DebugInformation =
                         Incremental.InterMake.Compiler.DebugInformation
                       sharing type Basis.BasisTypes.Datatypes.Type = InspectorValues.Type =
                         ValuePrinter.Type
                       sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget
                       sharing type Basis.BasisTypes.Basis = Incremental.InterMake.Compiler.TypeBasis
                       sharing type ShellTypes.Context = Incremental.Context
                       sharing type ShellTypes.IncrementalOptions = Incremental.options
                         ) : INSPECTORTOOL =

  struct
d102 1
d108 1
d114 1
a114 1
    type ShellData = ShellTypes.ShellData
d118 5
a122 1
    fun eval_string (shell_data,string) =
d124 2
a125 3
        val context = ShellTypes.get_current_context shell_data
        val error_info = ShellTypes.get_error_info shell_data
        val options = ShellTypes.get_current_options shell_data
d127 33
a159 1
        val inc_options = ShellTypes.make_incremental_options shell_data
d166 4
a169 2
        val (topdec,_) = Parser.parse_topdec error_info (options,token_stream,parser_basis)
        val result = Incremental.evaluate_exp_topdec (inc_options,context,topdec)
d192 7
a198 2
                               shell_data,
                               applicationShell) =
d231 3
d236 9
a244 3
            val printer_descriptor = ShellTypes.make_printer_descriptor shell_data
            val ValuePrinter.PRINTER_DESCRIPTOR{print_options,...} = printer_descriptor
            val debug_info = Incremental.debug_info (ShellTypes.get_current_context shell_data)
d246 1
a246 1
              ValuePrinter.stringify_value(printer_descriptor,
a252 1
                val context = ShellTypes.get_current_context shell_data
d259 2
a260 1
            fun print_type ty = Completion.print_type (print_options,get_completion_env(),ty)
d267 3
a269 1
               Xm.List.addItems (widget, map Xm.CompoundString.createSimple itemlist,0))
d274 2
a275 1
                Xm.COMPOUNDSTRING (Xm.CompoundString.createSimple (print_value item)))]);
d279 2
a280 1
                Xm.COMPOUNDSTRING (Xm.CompoundString.createSimple (print_type ty)))]);
d300 2
a301 1
                (MotifUtils.send_message (applicationShell,"Error in User Inspect Method");
d356 1
a356 1
            val new_item = eval_string (shell_data,text)
d376 1
a376 1
    fun inspect (shell_data,widget) =
d378 2
a379 1
        eval_string (shell_data,"it")
d382 1
a382 1
        make_inspector_window (initial_item,shell_data,widget);
@


1.10
log
@textInput widget now called textIO
@
text
@d3 3
d37 1
d56 1
d66 1
a66 1
                         Incremental.Datatypes
d68 2
a69 1
                         Incremental.InterMake.Compiler.Options = Parser.Options = ShellTypes.Options
d92 1
d184 10
a193 1
            val print_type = Types.print_type print_options
@


1.9
log
@Immediately inspect "it" on startup.  Added inspect_value function
Simple error handling for user defined methods
@
text
@d3 4
d147 1
a147 1
        val textInput = Xm.Widget.createManaged (Xm.Widget.NAME "inspectorTextInput",
@


1.8
log
@Cleaned up
@
text
@d3 3
d36 1
d51 1
d70 1
a70 1
                       sharing type Menus.Widget = Xm.Widget
d83 1
d127 2
a128 2
    fun make_inspector_window (initial_string,
                               shelldata,
d158 3
a160 1
        val stack = ref[]
d164 1
a164 1
            val printer_descriptor = ShellTypes.make_printer_descriptor shelldata
d166 1
a166 1
            val debug_info = Incremental.debug_info (ShellTypes.get_current_context shelldata)
d203 12
d257 1
a257 1
        Xm.Text.setString (textInput,initial_string);
d264 3
a266 5
            val new_item = eval_string (shelldata,text)
            val new_item_data = (new_item,InspectorValues.get_inspector_values new_item)
           in
             stack := new_item_data :: (!stack);
             set_state new_item_data
a275 1
            val new_item_data = (new_item,InspectorValues.get_inspector_values new_item)
d277 1
a277 2
             stack := new_item_data :: (!stack);
             set_state new_item_data
d279 1
d284 4
a287 8
    fun get_name context = "it"

    fun lookup_name (name,context) =
      let
        val tycontext = Basis.basis_to_context (Incremental.type_basis context)
        val valid = Ident.VAR(Symbol.find_symbol name)
        val valtype = Basis.lookup_val (Ident.NOPATH,valid,tycontext)
        val mlval = Inter_EnvTypes.lookup_val(valid,Incremental.inter_env context)
d289 2
a290 1
        (mlval,valtype)
d293 2
a294 3
    fun inspect (shelldata,widget) =
      (make_inspector_window ("it",shelldata,widget);
       ())
@


1.7
log
@Renamed Inspector_Values to InspectorValues
@
text
@d3 3
d58 1
d86 1
a86 1
      let
d103 2
d106 1
d122 1
a122 1
                               shell_data,
d156 3
a158 3
            val Options.OPTIONS{print_options,...} =
              UserOptions.new_options (ShellTypes.get_user_options shell_data)

d160 1
a160 3
              ValuePrinter.stringify_value(ValuePrinter.PRINTER_DESCRIPTOR
                                           {print_options = print_options,
                                            print_method_table = ValuePrinter.default_print_method_table},
d163 1
a163 2
                                           Incremental.debug_info
                                           (ShellTypes.get_current_context shell_data))
d244 1
a244 1
            val new_item = eval_string (shell_data,text)
d249 1
a249 1
           end));
d279 2
a280 2
    fun inspect (shell_data,widget) =
      (make_inspector_window ("it",shell_data,widget);
@


1.6
log
@Names of Callbacks have changed.
@
text
@d3 3
d41 1
a41 1
                       structure Inspector_Values : INSPECTOR_VALUES
d59 1
a59 1
                       sharing type Basis.BasisTypes.Datatypes.Type = Inspector_Values.Type =
d241 1
a241 1
            val new_item_data = (new_item,Inspector_Values.get_inspector_values new_item)
d254 1
a254 1
            val new_item_data = (new_item,Inspector_Values.get_inspector_values new_item)
@


1.5
log
@Moved user_options and version from interpreter to main
@
text
@d3 3
d233 1
a233 1
         Xm.ActivateCallback,
d245 1
a245 1
         Xm.SingleSelectionCallback,
@


1.4
log
@Added text input window with expression evaluation
@
text
@d3 3
d21 1
a21 1
require "../interpreter/user_options";
@


1.3
log
@Put printing code in here rather than in inspector_values
@
text
@d12 1
d19 1
d28 1
d35 1
d39 2
a40 1
                       sharing Basis.BasisTypes.Datatypes = Types.Datatypes
d42 3
a44 1
                         Incremental.InterMake.Compiler.Options
d46 2
d54 2
d68 1
d72 19
d105 3
a107 1
    fun make_inspector_window (user_options,item,context,applicationShell) =
d121 3
d136 1
a136 1
        val subitems = Inspector_Values.get_inspector_values item
a137 4
        val item_data = (item,subitems)

        val stack = ref[item_data]

d140 2
a141 1
            val Options.OPTIONS{print_options,...} = UserOptions.new_options user_options
d149 2
a150 1
                                           Incremental.debug_info context)
d188 6
d196 1
a196 1
                              (Xm.TopWidget, Xm.WIDGET menuBar),
d224 13
a236 1
        set_state item_data;
d266 3
a268 8
    fun inspect (user_options,ref context,widget) =
      let
        val name = get_name context
        val typed_object = lookup_name (name,context)
      in
        (make_inspector_window (user_options,typed_object,context,widget);
         ())
      end
@


1.2
log
@Removed MENUSPEC data constructor
@
text
@d3 3
d13 1
d16 3
a19 1
require "../interpreter/inspector_values";
d26 1
d28 1
d30 1
d35 8
a42 2
                       sharing Basis.BasisTypes.Datatypes = Inspector_Values.Datatypes

d52 1
d54 1
d56 1
a59 10
    type Widget = Xm.Widget
    type ContextRef = Inspector_Values.Datatypes.Type

    fun make_item_list l =
      map (fn (x,y) => implode[x,": ",y]) l

    fun set_items (widget,itemlist) =
      (Xm.List.deleteAllItems widget;
       Xm.List.addItems (widget, map Xm.CompoundString.createSimple itemlist,0))

d74 1
a74 1
    fun make_inspector_window (typedobject,applicationShell) =
d85 9
a93 12
        val menuBar =
          Xm.Widget.createManaged
	  (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn,frame,
	   [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)
            ])

        val label = Xm.Widget.createManaged (Xm.Widget.NAME "inspectorLabel",
                                             Xm.Widget.Class.Label,
                                             frame, [])
d97 20
a116 1
                                           [(Xm.SelectionPolicy, Xm.SELECTIONPOLICY Xm.SINGLE_SELECT)])
d118 30
a147 3
        val (title,items,cfn) = Inspector_Values.get_inspector_values typedobject
        val cfnref = ref cfn
        val itemsref = ref items
d149 6
a154 1
        Xm.Widget.valuesSet (label,
d160 6
d168 1
a168 1
                              (Xm.TopWidget, Xm.WIDGET label),
a171 1
        Xm.Widget.valuesSet (label, [(Xm.LabelString, Xm.COMPOUNDSTRING (Xm.CompoundString.createSimple title))]);
d174 1
a174 1
                                             [Menus.PUSH ("Close",
d177 8
a184 2
                                             fn _ => true)]);
        set_items (win,make_item_list items);
d191 7
a197 12
            val new_typedobject = (!cfnref) (#1(nth(pos-1,!itemsref)))
            val (newtitle,newitems,newcfn) = Inspector_Values.get_inspector_values new_typedobject
          in
            cfnref := newcfn;
            itemsref := newitems;
            Xm.Widget.valuesSet
            (label, [(Xm.LabelString, Xm.COMPOUNDSTRING (Xm.CompoundString.createSimple newtitle))]);
            set_items (win,make_item_list newitems)
          end
          handle
          Inspector_Values.CantInspect => ()
        | Inspector_Values.BadLabel => ())));
d214 1
a214 1
    fun inspect (ref context,widget) =
a215 1
        val _ = output(std_out,"Inspecting\n")
d219 1
a219 1
        (make_inspector_window (typed_object,widget);
@


1.1
log
@Initial revision
@
text
@d3 3
a111 1
                             Menus.MENUSPEC
a112 1
                                             Menus.MENUSPEC
@
