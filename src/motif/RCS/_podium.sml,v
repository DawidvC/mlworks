head	1.80;
access;
symbols
	MLW_daveb_inline_1_4_99:1.78.1
	MLWorks_21c0_1999_03_25:1.78
	MLWorks_20c1_1998_08_20:1.77
	MLWorks_20c0_1998_08_04:1.77
	MLWorks_20b2c2_1998_06_19:1.73
	MLWorks_20b2_Windows_1998_06_12:1.73
	MLWorks_20b1c1_1998_05_07:1.69
	MLWorks_20b0_1998_04_07:1.69
	MLWorks_20b0_1998_03_20:1.68
	MLWorks_20m2_1998_02_16:1.64
	MLWorks_20m1_1997_10_23:1.63
	MLWorks_workspace_97:1.62.2
	MLWorks_dt_wizard:1.62.1
	MLWorks_20m0_1997_06_20:1.61
	ML_beta_release_12/08/94:1.34
	ML_beta_release_03/08/94:1.34
	ML_revised_beta_release_25/05/94:1.30
	ML_final_beta_release_02/03/94:1.28
	mlworks-28-01-1994:1.27
	Release:1.21
	mlworks-beta-01-09-1993:1.21;
locks; strict;
comment	@ *  @;


1.80
date	99.05.13.13.57.15;	author daveb;	state Exp;
branches;
next	1.79;

1.79
date	99.04.30.16.16.55;	author johnh;	state Exp;
branches;
next	1.78;

1.78
date	98.11.23.12.51.24;	author johnh;	state Exp;
branches
	1.78.1.1;
next	1.77;

1.77
date	98.07.29.13.22.34;	author mitchell;	state Exp;
branches;
next	1.76;

1.76
date	98.07.14.09.33.15;	author jkbrook;	state Exp;
branches;
next	1.75;

1.75
date	98.07.09.14.01.12;	author johnh;	state Exp;
branches;
next	1.74;

1.74
date	98.06.22.13.54.06;	author mitchell;	state Exp;
branches;
next	1.73;

1.73
date	98.06.11.16.48.22;	author jkbrook;	state Exp;
branches;
next	1.72;

1.72
date	98.06.11.15.17.36;	author johnh;	state Exp;
branches;
next	1.71;

1.71
date	98.05.26.13.56.26;	author mitchell;	state Exp;
branches;
next	1.70;

1.70
date	98.05.14.15.24.54;	author johnh;	state Exp;
branches;
next	1.69;

1.69
date	98.03.26.12.29.32;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	98.03.16.11.06.44;	author mitchell;	state Exp;
branches;
next	1.67;

1.67
date	98.02.19.20.16.33;	author mitchell;	state Exp;
branches;
next	1.66;

1.66
date	98.02.18.17.11.31;	author jont;	state Exp;
branches;
next	1.65;

1.65
date	98.02.10.15.40.52;	author jont;	state Exp;
branches;
next	1.64;

1.64
date	98.01.27.16.52.02;	author johnh;	state Exp;
branches;
next	1.63;

1.63
date	97.10.09.15.06.46;	author johnh;	state Exp;
branches;
next	1.62;

1.62
date	97.07.17.16.24.58;	author johnh;	state Exp;
branches
	1.62.1.1
	1.62.2.1;
next	1.61;

1.61
date	97.06.17.15.32.55;	author johnh;	state Exp;
branches;
next	1.60;

1.60
date	97.06.17.15.31.50;	author johnh;	state Exp;
branches;
next	1.59;

1.59
date	95.07.18.13.37.21;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	95.07.07.15.31.08;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	95.07.04.14.18.07;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	95.06.15.13.03.20;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	95.06.08.13.50.57;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	95.06.08.09.56.01;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	95.06.01.12.53.37;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	95.05.23.08.45.38;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	95.05.19.15.52.28;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	95.05.15.15.58.01;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	95.05.04.09.44.06;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	95.04.28.15.03.29;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	95.04.24.15.52.14;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	95.04.24.10.40.14;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	95.04.18.15.33.28;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	95.04.13.17.56.39;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	95.04.13.10.27.55;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.04.07.10.52.57;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	95.03.30.14.03.42;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.03.27.13.46.15;	author io;	state Exp;
branches;
next	1.39;

1.39
date	95.03.17.11.50.36;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	95.03.16.16.27.08;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	95.03.15.16.50.27;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	95.03.10.15.54.18;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	95.01.13.16.56.07;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	94.07.14.14.50.29;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	94.07.12.16.22.48;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	94.06.30.08.56.42;	author nickh;	state Exp;
branches;
next	1.31;

1.31
date	94.06.20.13.03.25;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	94.04.07.12.07.37;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	94.03.21.17.23.35;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	94.02.02.11.59.57;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	93.12.09.14.38.08;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.11.18.18.01.09;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	93.11.09.15.55.37;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	93.10.22.17.00.49;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	93.09.07.14.04.22;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	93.09.07.11.18.09;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	93.08.11.13.12.46;	author matthew;	state Exp;
branches
	1.21.1.1;
next	1.20;

1.20
date	93.08.06.15.23.55;	author nosa;	state Exp;
branches;
next	1.19;

1.19
date	93.06.02.14.12.04;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	93.05.13.14.02.29;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.05.05.19.20.25;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	93.05.05.11.50.02;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	93.04.30.14.43.52;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	93.04.28.14.19.57;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	93.04.21.14.53.16;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	93.04.16.14.52.27;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.04.05.14.58.14;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	93.04.02.15.18.02;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.03.30.14.46.38;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.03.30.12.29.02;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.03.26.14.19.00;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.03.23.14.10.22;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.03.17.15.22.08;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.03.15.17.50.19;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.03.15.14.43.45;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.15.24.39;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.02.17.54.38;	author daveb;	state Exp;
branches;
next	;

1.21.1.1
date	93.08.11.13.12.46;	author jont;	state Exp;
branches;
next	1.21.1.2;

1.21.1.2
date	93.09.06.15.21.31;	author daveb;	state Exp;
branches;
next	1.21.1.3;

1.21.1.3
date	93.09.07.13.54.22;	author daveb;	state Exp;
branches;
next	1.21.1.4;

1.21.1.4
date	93.10.21.14.04.43;	author daveb;	state Exp;
branches;
next	1.21.1.5;

1.21.1.5
date	93.11.09.15.44.17;	author daveb;	state Exp;
branches;
next	;

1.62.1.1
date	97.09.10.19.28.27;	author brucem;	state Exp;
branches;
next	1.62.1.2;

1.62.1.2
date	97.09.12.10.06.32;	author brucem;	state Exp;
branches;
next	;

1.62.2.1
date	97.09.11.20.58.23;	author daveb;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	97.09.12.14.44.13;	author johnh;	state Exp;
branches;
next	1.62.2.3;

1.62.2.3
date	97.11.24.12.11.27;	author johnh;	state Exp;
branches;
next	1.62.2.4;

1.62.2.4
date	97.12.10.14.02.41;	author johnh;	state Exp;
branches;
next	1.62.2.5;

1.62.2.5
date	98.01.07.16.55.14;	author johnh;	state Exp;
branches;
next	;

1.78.1.1
date	99.04.01.17.58.56;	author daveb;	state Exp;
branches;
next	;


desc
@Podium for motif.
@


1.80
log
@[Bug #190553]
Replaced use of basis/exit with utils/mlworks_exit.
@
text
@(* podium.sml the functor.
 *  
 *  $Log: _podium.sml,v $
 *  Revision 1.79  1999/04/30  16:16:55  johnh
 *  [Bug #190552]
 *  Test return value of ProjProperties.new_project.
 *
 *  Revision 1.78  1998/11/23  12:51:24  johnh
 *  [Bug #70214]
 *  call ProjectWorkspace.updateDisplay before (and after) actions such as opening a different project.
 *
 *  Revision 1.77  1998/07/29  13:22:34  mitchell
 *  [Bug #30450]
 *  Replace broken dummy output routine in use of PrimIO writer
 *
 *  Revision 1.76  1998/07/14  09:33:15  jkbrook
 *  [Bug #30435]
 *  Remove license-prompting code
 *
 *  Revision 1.75  1998/07/09  14:01:12  johnh
 *  [Bug #30400]
 *  remove main_windows arg from exit_mlworks arg.
 *
 *  Revision 1.74  1998/06/22  13:54:06  mitchell
 *  [Bug #30429]
 *  Warn when saving sessions with debugging information enabled
 *
 *  Revision 1.73  1998/06/11  16:48:22  jkbrook
 *  [Bug #30411]
 *  Include Free edition
 *
 *  Revision 1.72  1998/06/11  15:17:36  johnh
 *  [Bug #30411]
 *  Call Capi.show_splash_screen.
 *
 *  Revision 1.71  1998/05/26  13:56:26  mitchell
 *  [Bug #30413]
 *  Use abstract exit status
 *
 *  Revision 1.70  1998/05/14  15:24:54  johnh
 *  [Bug #30384]
 *  Project Workspace should start up if MLWorks starts up with an open project.
 *
 *  Revision 1.69  1998/03/26  12:29:32  jont
 *  [Bug #30090]
 *  Remove uses of MLWorks.IO
 *
 *  Revision 1.68  1998/03/16  11:06:44  mitchell
 *  [Bug #50061]
 *  Remove redundant call to make_history
 *
 *  Revision 1.67  1998/02/19  20:16:33  mitchell
 *  [Bug #30349]
 *  Fix to avoid non-unit sequence warnings
 *
 *  Revision 1.66  1998/02/18  17:11:31  jont
 *  [Bug #70070]
 *  Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 *  Revision 1.65  1998/02/10  15:40:52  jont
 *  [Bug #70065]
 *  Remove uses of MLWorks.IO.messages and use the Messages structure
 *
 *  Revision 1.64  1998/01/27  16:52:02  johnh
 *  [Bug #30071]
 *  Merge in Project Workspace changes.
 *
 *  Revision 1.63  1997/10/09  15:06:46  johnh
 *  [Bug #30193]
 *  Call SysMessages.create.
 *
 *  Revision 1.62.2.5  1998/01/07  16:55:14  johnh
 *  [Bug #30071]
 *  Display Project Workspace window asap.
 *
 *  Revision 1.62.2.4  1997/12/10  14:02:41  johnh
 *  [Bug #30071]
 *  Add save_project_as to file menu.
 *
 *  Revision 1.62.2.3  1997/11/24  12:11:27  johnh
 *  [Bug #30071]
 *  Add File->ChangeCurrentDirectory (PathTool function).
 *
 *  Revision 1.62.2.2  1997/09/12  14:44:13  johnh
 *  [Bug #30071]
 *  Implement new Project Workspace tool.
 *
 *  Revision 1.62  1997/07/17  16:24:58  johnh
 *  [Bug #20074]
 *  Improve license dialog.
 *
 *  Revision 1.61  1997/06/17  15:32:55  johnh
 *  Automatic checkin:
 *  changed attribute _comment to ' *  '
 *
 * Revision 1.45  1997/06/09  15:09:20  johnh
 * [Bug #02030]
 * Removed Edit Error from the Listener menu.
 *
 * Revision 1.44  1997/06/09  10:26:58  johnh
 * [Bug #30068]
 * Making Break/Trace manager top level tool.
 *
 * Revision 1.43  1997/05/27  14:08:52  johnh
 * [Bug #20033]
 * Banner only displayed now if SaveImage.show_banner is true.
 *
 * Revision 1.42  1997/05/22  15:15:14  johnh
 * [Bug #20023]
 * Set Capi.evaluating to false when loading image.
 *
 * Revision 1.41  1997/05/21  09:02:06  johnh
 * Implementing toolbar on Windows.
 *
 * Revision 1.40  1997/05/16  15:34:42  johnh
 * Implementing single menu bar on Windows.
 *
 * Revision 1.39  1997/03/27  14:48:15  daveb
 * [Bug #1990]
 * Version.version_string is now Version.versionString, and a function instead
 * of a constant.
 *
 * Revision 1.38  1997/03/25  11:55:21  andreww
 * [Bug #1989]
 * Removing exn_name_string (giving functionality to exn_name).
 *
 * Revision 1.37  1997/03/17  11:39:40  andreww
 * [Bug #1677]
 * adding new access field to currentIO record.
 *
 * Revision 1.36  1996/11/20  18:46:09  daveb
 * [Bug #1796]
 * Corrected a bug introduced by the previous change: mainWindow must be
 * revealed before calling initialize_application_shell.
 *
 * Revision 1.35  1996/11/18  11:37:37  daveb
 * Added splash screen.
 *
 * Revision 1.34  1996/11/12  11:45:33  daveb
 * Revised licensing scheme to allow registration-style licensing.
 *
 * Revision 1.33  1996/11/01  14:42:56  johnh
 * Enabling close from control box on top left of window.
 *
 * Revision 1.32  1996/10/30  21:41:54  io
 * [Bug #1614]
 * remove toplevel String
 *
 * Revision 1.31  1996/10/17  12:55:49  jont
 * Add license server stuff
 *
 * Revision 1.30.1.2  1996/10/08  12:21:28  jont
 * Add call to initialise license
 *
 * Revision 1.30.1.1  1996/10/07  16:03:42  hope
 * branched from 1.30
 *
 * Revision 1.30  1996/09/23  14:01:18  matthew
 * Adding register_interrupt_window to capi
 *
 * Revision 1.29  1996/09/19  13:00:49  johnh
 * [Bug #1583]
 * passing has_controlling_tty to exit_mlworks instead of passed ing false.
 *
 * Revision 1.27  1996/07/15  12:47:22  andreww
 * propagating changes made to the GUI standard IO redirection mechanism
 * (see __pervasive_library.sml for the StandardIO structure)
 *
 * Revision 1.26  1996/07/02  15:14:15  andreww
 * Setting up the Gui StandardIO flag, so that system/__primio.sml
 * can detect the GUI even without a listener.
 *
 * Revision 1.25  1996/05/30  13:19:41  daveb
 * The Interrupt exception is no longer at top level.
 *
 * Revision 1.24  1996/05/29  14:39:21  daveb
 * DebuggerWindow.make_debugger_window now returns a clean-up function to call
 * at the end of each evaluation.
 *
 * Revision 1.23  1996/05/20  15:49:30  daveb
 * Added Save Image menu entry.
 *
 * Revision 1.22  1996/05/17  10:16:53  matthew
 * Improvng handling of uncaught exceptions at top level
 *
 * Revision 1.21  1996/05/16  13:16:51  stephenb
 * Update wrt MLWorks.Debugger -> MLWorks.Internal.Debugger change.
 *
 * Revision 1.20  1996/05/14  13:57:34  daveb
 * Reorganised menus to include File menu.
 *
 * Revision 1.19  1996/05/03  14:24:17  nickb
 * Add delivery wrapper around start_x_interface
 *
 * Revision 1.18  1996/05/01  11:25:52  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.17  1996/03/12  14:02:01  matthew
 * Adding Paths menu
 *
 * Revision 1.16  1996/02/29  14:25:28  matthew
 * Adding extra params to setup_menu
 *
 * Revision 1.15  1996/01/23  15:59:51  daveb
 * Added context menu, and changed names of break and trace buttons.
 *
 * Revision 1.14  1996/01/22  11:41:37  daveb
 * Removed evaluator from tools menu.  Moved Windows menu to correct position.
 *
 * Revision 1.13  1996/01/17  15:26:36  matthew
 * Removing inspector from top level
 *
 * Revision 1.12  1995/12/12  15:37:55  daveb
 * Removed File Tool.
 *
 * Revision 1.11  1995/12/04  15:31:07  daveb
 * Added project tool.
 *
 * Revision 1.10  1995/11/16  14:07:37  matthew
 * Changing interface to tool_data
 *
 * Revision 1.9  1995/11/15  14:01:38  matthew
 * Adding windows menu
 *
 * Revision 1.8  1995/10/04  11:24:41  daveb
 * Type of setup_menu has changed.
 *
 * Revision 1.7  1995/09/11  13:20:57  matthew
 * Changing top level window initialization
 *
 * Revision 1.6  1995/09/05  12:59:25  matthew
 * Using make_nonml_scrolled_text
 *
 * Revision 1.5  1995/08/31  12:02:29  matthew
 * Renaming layout constructors
 *
 * Revision 1.4  1995/08/14  10:33:50  matthew
 * Changes to make_main_subwindows
 *
 * Revision 1.3  1995/08/11  10:24:35  matthew
 * Adding make_buttons function to capi
 *
 * Revision 1.2  1995/07/27  10:58:25  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/26  14:46:29  matthew
 * new unit
 * New unit
 *
 *  Revision 1.59  1995/07/18  13:37:21  matthew
 *  Changin listener interface.
 *
 *  Revision 1.58  1995/07/07  15:31:08  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.57  1995/07/04  14:18:07  matthew
 *  Capifying
 *
 *  Revision 1.56  1995/06/15  13:03:20  daveb
 *  Hid details of WINDOWING type in ml_debugger.
 *
 *  Revision 1.55  1995/06/08  13:50:57  daveb
 *  InspectorTool no longer contains a Widget type.
 *
 *  Revision 1.54  1995/06/08  09:56:01  daveb
 *  Types of the InspectorTool functions have changed.
 *
 *  Revision 1.53  1995/06/01  12:53:37  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.52  1995/05/23  08:45:38  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.51  1995/05/19  15:52:28  daveb
 *  Added "Browse Initial" entry to tools menu.
 *
 *  Revision 1.50  1995/05/15  15:58:01  matthew
 *  Improving X_system_error message
 *
 *  Revision 1.49  1995/05/04  09:44:06  matthew
 *  Using createMenuBar for creating menuBar
 *
 *  Revision 1.48  1995/04/28  15:03:29  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.47  1995/04/24  15:52:14  matthew
 *  Make subwindow parents not be menuBar
 *  
 *  Revision 1.46  1995/04/24  10:40:14  daveb
 *  Added handler for Xm.SubLoopTerminated to mainLoop.
 *  
 *  Revision 1.45  1995/04/18  15:33:28  daveb
 *  Changes to context_menu.
 *  
 *  Revision 1.44  1995/04/13  17:56:39  daveb
 *  Xm.mainLoop is back to taking unit.
 *  
 *  Revision 1.43  1995/04/13  10:27:55  daveb
 *  Added a context menu.
 *  
 *  Revision 1.42  1995/04/07  10:52:57  daveb
 *  Added AppContext type to Xm library.
 *  
 *  Revision 1.41  1995/03/30  14:03:42  daveb
 *  Added ContextWindow to list of tools.
 *  
 *  Revision 1.40  1995/03/27  13:46:15  io
 *  catch X exn when DISPLAY left unset
 *  
 *  Revision 1.39  1995/03/17  11:50:36  daveb
 *  Added Writable component to tool list.
 *  
 *  Revision 1.38  1995/03/16  16:27:08  daveb
 *  Made all created tools share the same current_context value.
 *  
 *  Revision 1.37  1995/03/15  16:50:27  daveb
 *  listener_args now has a new type.
 *  
 *  Revision 1.36  1995/03/10  15:54:18  daveb
 *  GuiUtils.options_menu now takes an extra argument.
 *  
 *  Revision 1.35  1995/01/13  16:56:07  daveb
 *  Removed obsolete sharing constraint.
 *  
 *  Revision 1.34  1994/07/14  14:50:29  daveb
 *  start_x_interface now takes a boolean parameter that indicates whether
 *  it was called from a TTY.  If not, it MLWorks must have called it on
 *  start up, so it prints the version message.  This flag is passed into
 *  the appdata field of the ToolData type.
 *  
 *  Revision 1.33  1994/07/12  16:22:48  daveb
 *  ToolData.works_menu takes different arguments.
 *  InspectorTool.ToolData.ShellTypes.Option replaced with InspectorTool.Option
 *  
 *  Revision 1.32  1994/06/30  08:56:42  nickh
 *  Provide for messages to appear in the podium window.
 *  (and remove some dead code).
 *  
 *  Revision 1.31  1994/06/20  13:03:25  daveb
 *  Added the evaluator.
 *  Replaced context refs with user_contexts.
 *  
 *  Revision 1.30  1994/04/07  12:07:37  daveb
 *  Added case for DebuggerTrapped.
 *  
 *  Revision 1.29  1994/03/21  17:23:35  matthew
 *  Added catchall around event loop
 *  
 *  Revision 1.28  1994/02/02  11:59:57  daveb
 *  Changed substructure of InterMake.
 *  
 *  Revision 1.27  1993/12/09  14:38:08  matthew
 *  Added call to register application shell for inter client comms.
 *  
 *  Revision 1.26  1993/11/18  18:01:09  daveb
 *  The argument to Ml_Debugger.with_debugger_type now takesa frame argument
 *  instead of unit.
 *  
 *  Revision 1.25  1993/11/09  15:55:37  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.24  1993/10/22  17:00:49  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.23  1993/09/07  14:04:22  daveb
 *  Merged in bug fix.
 *  
 *  26,28d16
 *  Revision 1.22  1993/09/07  11:18:09  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.21.1.5  1993/11/09  15:44:17  daveb
 *  Made mainLoop properly tail recursive.
 *  
 *  Revision 1.21.1.4  1993/10/21  14:04:43  daveb
 *  Changed ToolData.works_menu to take a (unit -> bool) function that
 *  controls whether the Close menu option is enabled.
 *  
 *  Revision 1.21.1.3  1993/09/07  13:54:22  daveb
 *  Changed argument to debugger_type to ensure that it always uses a window
 *  debugger, even if the user prefers a TTY debugger (that preference only
 *  affects the listener).
 *  
 *  Revision 1.21.1.2  1993/09/06  15:21:31  daveb
 *  Wrapped debugger around mainLoop.
 *  
 *  Revision 1.21  1993/08/11  13:12:46  matthew
 *  Changes for automatic option menu updating
 *  
 *  Revision 1.20  1993/08/06  15:23:55  nosa
 *  Pass debugger_window to Inspector.
 *  
 *  Revision 1.19  1993/06/02  14:12:04  daveb
 *  Changed title to "MLWorks", since "MLWorks Console" wasn't popular.
 *  
 *  Revision 1.18  1993/05/13  14:02:29  daveb
 *  All tools now set their own titles and pass them to their options menus.
 *  
 *  Revision 1.17  1993/05/05  19:20:25  daveb
 *  Added InspectorTool to the list of tools.
 *  
 *  Revision 1.16  1993/05/05  11:50:02  daveb
 *  Moved exit_mlworks from _podium to _tooldata.  Added tools argument to
 *   works_menu(), removed exitApplication from TOOLDATA.
 *  
 *  Revision 1.15  1993/04/30  14:43:52  daveb
 *  Reorganised menus.
 *  
 *  Revision 1.14  1993/04/28  14:19:57  richard
 *  The podium now has a text messages widget and a horizontal menu bar
 *  rather than being like the old LispWorks podium.
 *  
 *  Revision 1.13  1993/04/21  14:53:16  daveb
 *  Removed context browser item from tools menu.
 *  
 *  Revision 1.12  1993/04/16  14:52:27  matthew
 *  Changed interface to tools
 *  Added file browser
 *  
 *  Revision 1.11  1993/04/05  14:58:14  daveb
 *  Names of Callbacks have changed.
 *  
 *  Revision 1.10  1993/04/02  15:18:02  matthew
 *  Removed Incremental structure
 *  
 *  Revision 1.9  1993/03/30  14:46:38  matthew
 *  Menus.MENUSPEC is no more
 *  
 *  Revision 1.8  1993/03/30  12:29:02  matthew
 *  Removed "destroying..": message
 *  
 *  Revision 1.7  1993/03/26  14:19:00  matthew
 *  Changed menus for consistency with listener
 *  
 *  Revision 1.6  1993/03/23  14:10:22  matthew
 *  Used generic menu facility
 *  
 *  Revision 1.5  1993/03/17  15:22:08  matthew
 *  Tried doing CloseDisplay instead of destroy applicationShell
 *  Currently commented out.
 *  
 *  Revision 1.4  1993/03/15  17:50:19  matthew
 *  Simplified ShellTypes type
 *  
 *  Revision 1.3  1993/03/15  14:43:45  daveb
 *  Prevented the podium from being resized.
 *  Changed quit dialog to offer option of returning to TTY listener or
 *  quitting completely.
 *  
 *  Revision 1.2  1993/03/08  15:24:39  matthew
 *  Changes for ShellData type
 *  
 *  Revision 1.1  1993/03/02  17:54:38  daveb
 *  Initial revision
 *  
 *  
 *  Copyright (c) 1993 Harlequin Ltd.
 *  
 *)

require "__os";
require "../basis/__string";
require "^.utils.__messages";
require "^.utils.__terminal";

require "../main/user_options";
require "../main/preferences";
require "../main/version";
require "../main/license";
require "../main/proj_file";
require "../debugger/ml_debugger";
require "../gui/capi";
require "../gui/menus";
require "../gui/debugger_window";
require "../gui/tooldata";
require "../gui/listener";
require "../gui/gui_utils";
require "../gui/break_trace";
require "../gui/browser_tool";
require "../gui/context";
require "../gui/sys_messages";
require "../gui/proj_workspace";
require "^.gui.proj_properties";
require "^.gui.path_tool";
require "../interpreter/save_image";
require "podium";

functor Podium (
  structure Capi: CAPI
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure License : LICENSE
  structure Version : VERSION
  structure Debugger_Window : DEBUGGERWINDOW
  structure ToolData : TOOL_DATA
  structure Menus : MENUS
  structure Listener: LISTENER
  structure BrowserTool : BROWSERTOOL
  structure ProjectWorkspace : PROJECT_WORKSPACE
  structure ContextHistory : CONTEXT_HISTORY
  structure GuiUtils : GUI_UTILS
  structure Ml_Debugger : ML_DEBUGGER
  structure SaveImage : SAVE_IMAGE
  structure BreakTrace : BREAK_TRACE
  structure SysMessages : SYS_MESSAGES
  structure ProjProperties : PROJ_PROPERTIES
  structure PathTool : PATH_TOOL
  structure ProjFile : PROJ_FILE

  sharing Ml_Debugger.ValuePrinter.Options = ToolData.ShellTypes.Options
  sharing type Ml_Debugger.preferences = ToolData.ShellTypes.preferences
  sharing type Listener.ToolData = ToolData.ToolData = 
               ProjectWorkspace.ToolData =
	       BrowserTool.ToolData = 
	       ContextHistory.ToolData =
	       Debugger_Window.ToolData =
	       BreakTrace.ToolData = 
	       SysMessages.ToolData
  sharing type Menus.Widget = ToolData.Widget = ProjProperties.Widget =
	       GuiUtils.Widget = Debugger_Window.Widget = Capi.Widget = 
	       PathTool.Widget
  sharing type GuiUtils.ButtonSpec = ToolData.ButtonSpec = Menus.ButtonSpec
  sharing type GuiUtils.user_tool_options = ToolData.ShellTypes.user_options =
    	       UserOptions.user_tool_options
  sharing type GuiUtils.user_context_options =
               UserOptions.user_context_options =
	       ToolData.UserContext.user_context_options
  sharing type Preferences.user_preferences = GuiUtils.user_preferences =
	       ToolData.ShellTypes.user_preferences
  sharing type GuiUtils.user_context = ToolData.ShellTypes.user_context
  sharing type GuiUtils.MotifContext = ToolData.MotifContext
  sharing type Ml_Debugger.debugger_window = Debugger_Window.debugger_window
  sharing type ToolData.ShellTypes.ShellData = SaveImage.ShellData

): PODIUM =
struct
  structure ShellTypes = ToolData.ShellTypes
  structure UserContext = ToolData.UserContext

  type ListenerArgs = ShellTypes.ListenerArgs

  val tool_list =
    [("listener", Listener.create false, ToolData.WRITABLE),
     ("projWorkspace", ProjectWorkspace.create, ToolData.WRITABLE),
     ("contextBrowser", BrowserTool.create, ToolData.ALL),
     ("initialBrowser", BrowserTool.create_initial, ToolData.ALL),
     ("contextWindow", ContextHistory.create, ToolData.ALL),
     ("breakTrace", BreakTrace.create, ToolData.ALL)]

  (*
   * Here, on Motif, although the podium no longer exists, an application
   * shell still needs to be created so that tooldata can be created and 
   * passed to all the tools, and the Listener uses this application shell 
   * as the shell for the Listener window rather than for the podium window.
   * On Windows, a new shell is created for the Listener.  
   *)
  fun start_x_interface args has_controlling_tty =
    let
      val print_message = Messages.output

      (* The following few lines set the StandardIO internal flag to 
         indicate the presence of the GUI, so that system/__primio.sml 
         can detect the GUI even when it is being loaded by the compilation
         manager in the presence of no listeners.  At the moment, the
         current window is set to junk; the listeners will  set the flag to
         point to the correct window. *)

      fun put_string {buf, i, sz} =
        let val s = String.extract(buf, i, sz) in print_message s; size s end

      val _ = MLWorks.Internal.StandardIO.redirectIO
        {output={descriptor=NONE,
                 put=put_string,
                 get_pos = NONE,
                 set_pos = NONE,
                 can_output=NONE,
                 close = fn()=>()},
         error={descriptor=NONE,
                 put=put_string,
                 get_pos = NONE,
                 set_pos = NONE,
                 can_output=NONE,
                 close=fn()=>()},
         input={descriptor=NONE,
                get=fn _ => "",
                get_pos=NONE,
                set_pos=NONE,
                can_input=NONE,
                close=fn()=>()},
         access=fn f=> f ()}
        (* see <URI:spring:/ML_Notebook/Design/GUI/Mutexes> for a
         * description of the access field.*)

      val applicationShell = Capi.initialize_application ("mlworks","MLWorks",
		has_controlling_tty)

      val ShellTypes.LISTENER_ARGS
	    {user_options, user_preferences, user_context, ...} = args

      val (full_menus, update_fns) =
	case user_preferences
	of Preferences.USER_PREFERENCES ({full_menus, ...}, update_fns) =>
	  (!full_menus, update_fns)

      fun get_user_options () = user_options

      val _ = GuiUtils.makeInitialContext
	        (applicationShell, user_preferences)

      val current_context =
	ToolData.make_current
	  (GuiUtils.make_context
	     (user_context, applicationShell, user_preferences))

      fun get_context () = ToolData.get_current current_context

      fun copy_args (ShellTypes.LISTENER_ARGS {user_context,
                                               user_options,
					       user_preferences,
                                               prompter,
                                               mk_xinterface_fn}) =
        ShellTypes.LISTENER_ARGS
	  {user_context =
           GuiUtils.get_user_context (get_context ()),
	   user_preferences = user_preferences,
           user_options = UserOptions.copy_user_tool_options user_options,
           prompter = prompter,
           mk_xinterface_fn = mk_xinterface_fn}

      val appdata =
	ToolData.APPLICATIONDATA
	  {applicationShell = applicationShell,
	   has_controlling_tty = has_controlling_tty}

      fun mk_tooldata () =
	ToolData.TOOLDATA
	  {args = copy_args args, appdata = appdata,
	   motif_context = get_context (),
	   current_context = current_context, tools = tool_list}
	  
      fun create_listener () = Listener.create false (mk_tooldata())

      fun get_current_user_context () =
        GuiUtils.get_user_context (get_context ())

      fun get_user_context_options () = 
        UserContext.get_user_options (get_current_user_context ())

      local
	fun handler_fn msg = Capi.send_message (applicationShell, msg)
      in
        fun save_image _ =
          ( let val UserOptions.USER_CONTEXT_OPTIONS
                     ({generate_debug_info, generate_variable_debug_info, ...},
                      _) =
                      get_user_context_options ()
             in if !generate_debug_info orelse !generate_variable_debug_info
                then Capi.send_message(applicationShell,
                     "Enabling the debug options " ^
                     "may result in large saved images")
                else () 
            end;
           
	    case Capi.save_as_dialog (applicationShell, ".img")
   	    of NONE => ()
	    |  SOME filename => 
	      SaveImage.saveImage
	        (false, handler_fn)
	        (filename, false) )
      end

      val messagesWindow = SysMessages.create (mk_tooldata())

      fun wrapUpdate condition_fn =
	(ProjectWorkspace.updateDisplay();
	 if condition_fn applicationShell then 
	   ProjectWorkspace.updateDisplay()
	 else ())

      fun new_project () = 
	let 
	  fun create_new appShell = 
	    let val wantNew = ProjProperties.new_project appShell
	    in
	      if wantNew then ProjectWorkspace.create (mk_tooldata()) else ();
	      wantNew
	    end
	in
	  wrapUpdate create_new
	end

      fun open_project () = 
	let 
	  fun open_it appShell = 
	    ProjProperties.open_project appShell
		(fn () => ProjectWorkspace.create (mk_tooldata()))
	in
	  wrapUpdate open_it
	end

      fun save_project () = wrapUpdate ProjProperties.save_project
      fun save_project_as () = wrapUpdate ProjProperties.save_project_as

      fun project_exists () = isSome (ProjFile.getProjectName())

      val file_menu = ToolData.set_global_file_items
	([("new_proj", new_project, fn _ => true),
	 ("open_proj", open_project, fn _ => true),
	 ("save_proj", save_project, project_exists),
	 ("save_proj_as", save_project_as, project_exists),
	 ("save",
            fn _ =>
              GuiUtils.save_history
                (false, get_current_user_context (), applicationShell),
            fn _ =>
	      not (UserContext.null_history (get_current_user_context ()))
                   andalso UserContext.saved_name_set
			     (get_current_user_context ())),
         ("saveAs",
            fn _ =>
              GuiUtils.save_history
                (true, get_current_user_context (), applicationShell),
            fn _ =>
              not (UserContext.null_history (get_current_user_context ()))),
	 ("saveImage", save_image, fn _ => true),
	 ("setWD", fn _ => PathTool.setWD applicationShell, fn _ => true),
	 ("exit",
	    fn _ => ToolData.exit_mlworks (applicationShell, appdata),
	    fn _ => not (!Capi.evaluating))])

      val usage_menu = 
	ToolData.set_global_usage_items 
	   ( (GuiUtils.setup_menu
		(applicationShell, get_context, user_preferences,get_user_context_options)) @@ 
	    [("sysMessages", messagesWindow, fn _ => true)],
	   [])

      val (run_debugger, clean_debugger) =
        Debugger_Window.make_debugger_window
	  (applicationShell, "MLWorks Debugger", mk_tooldata ())

      val debugger_type =
	Ml_Debugger.WINDOWING
	  (run_debugger,
	   (* I don't know what is the best function to use for the next
	      parameter here. *)
	   print_message, false)

      fun delivery_hook deliverer args =
        let
          fun inDeliveredImage f = 
	    let
	      val oldIO = MLWorks.Internal.StandardIO.currentIO()
	      val _ = MLWorks.Internal.StandardIO.resetIO();
	      val result = (f() handle exn =>
			    (MLWorks.Internal.StandardIO.redirectIO oldIO; raise exn))
	    in
	      MLWorks.Internal.StandardIO.redirectIO oldIO;
	      result
	    end
         in
           (fn () => inDeliveredImage(fn () => deliverer args)) ()
        end
           
      fun debugger_function exn = 
        let
          val shell_data as ShellTypes.SHELL_DATA{prompter,
                                                  mk_xinterface_fn, 
                                                 ...} = !ShellTypes.shell_data_ref
          val context = ShellTypes.get_current_context shell_data
        in
          Ml_Debugger.ml_debugger 
          (Ml_Debugger.get_debugger_type (),
           ShellTypes.get_current_options shell_data,
           ShellTypes.get_current_preferences shell_data)
          (Ml_Debugger.get_start_frame(),
           Ml_Debugger.EXCEPTION exn,
           Ml_Debugger.POSSIBLE ("Return to top level",
                                 Ml_Debugger.NORMAL_RETURN),
           Ml_Debugger.NOT_POSSIBLE)
        end
  
      val default_to_free : unit -> unit = 
             MLWorks.Internal.Runtime.environment "license set edition"

      fun license_ok () =
        has_controlling_tty orelse
	(
         let
           val license_status = 
	     License.license (Capi.license_complain applicationShell)
         in
           (case license_status of 
                SOME false => default_to_free ()
              | _ => ());
           if SaveImage.showBanner() then 
	     print_message (Version.versionString() ^ "\n")
	   else ();
           (case license_status of
              SOME _ => true
            | _  => false)
         end
        )

      fun mainLoop frame =
	let
	  val loop =
	    (Capi.main_loop (); false)
	    (* normal return, don't loop *)
	    handle 
            MLWorks.Interrupt => true	(* interrupt, continue X interface *)
          | ShellTypes.DebuggerTrapped => true (* continue X interface *)
	  | Capi.SubLoopTerminated => false  (* break *)
          | exn => 
              (debugger_function exn;
	      clean_debugger ();
              true)
	in
	  if loop then mainLoop frame else ()   (* else stop_messages()  *)
	(* tail recursive call *)
	end

    in 
        if (license_ok ()) then
        (Capi.show_splash_screen applicationShell;
         create_listener();
	 if isSome(ProjFile.getProjectName()) then 
	   ProjectWorkspace.create (mk_tooldata())
	 else ();
         Capi.initialize_application_shell applicationShell;
	 (* Set to false here so that any saved images saved with Shell.saveImage 
	  * have the exit menu item enabled when the image is loaded *)
	 Capi.evaluating := false;
         MLWorks.Deliver.with_delivery_hook delivery_hook
           (Ml_Debugger.with_debugger_type debugger_type) mainLoop;
	 ())
        else
         OS.Process.terminate OS.Process.failure
    end
    handle Capi.WindowSystemError s =>
       Terminal.output("Graphics interface problem: "^s^"\n")
end;
@


1.79
log
@[Bug #190552]
Test return value of ProjProperties.new_project.
@
text
@d4 4
d464 1
a464 1
require "../basis/__exit";
d841 1
a841 1
         Exit_.terminate Exit_.failure
@


1.78
log
@[Bug #70214]
call ProjectWorkspace.updateDisplay before (and after) actions such as opening a different project.
@
text
@d4 4
d680 7
a686 3
	let fun create_new appShell = (ProjProperties.new_project appShell;
				       ProjectWorkspace.create (mk_tooldata());
				       true)
@


1.78.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 *  Revision 1.78  1998/11/23  12:51:24  johnh
 *  [Bug #70214]
 *  call ProjectWorkspace.updateDisplay before (and after) actions such as opening a different project.
 *
@


1.77
log
@[Bug #30450]
Replace broken dummy output routine in use of PrimIO writer
@
text
@d4 4
d669 13
a681 3
      fun new_project () = (ProjProperties.new_project applicationShell;
			    ProjectWorkspace.create (mk_tooldata());
			    ProjectWorkspace.updateDisplay())
d684 10
a693 14
	if ProjProperties.open_project applicationShell 
	  (fn () => ProjectWorkspace.create (mk_tooldata())) then 
	     ProjectWorkspace.updateDisplay()
	else ()

      fun save_project () = 
	if ProjProperties.save_project applicationShell then
	  ProjectWorkspace.updateDisplay()
	else ()

      fun save_project_as () = 
	if ProjProperties.save_project_as applicationShell then
	  ProjectWorkspace.updateDisplay()
	else ()
@


1.76
log
@[Bug #30435]
Remove license-prompting code
@
text
@d4 4
d453 1
d559 3
d564 1
a564 1
                 put=fn _ => 0,
d570 1
a570 1
                 put=fn _ => 0,
@


1.75
log
@[Bug #30400]
remove main_windows arg from exit_mlworks arg.
@
text
@d4 4
d756 5
a760 2
      val license_ok =
	has_controlling_tty orelse
d763 2
a764 4
           val l_res = 
	 License.license
	   {promptUser = Capi.license_prompt applicationShell,
	    complain = Capi.license_complain applicationShell}
d766 9
a774 4
         if SaveImage.showBanner() then 
	   print_message (Version.versionString() ^ "\n")
	 else ();
         l_res
d797 1
a797 1
      if license_ok then
d810 2
a811 2
      else
	Exit_.terminate Exit_.failure
@


1.74
log
@[Bug #30429]
Warn when saving sessions with debugging information enabled
@
text
@d4 4
d697 1
a697 2
	    fn _ => ToolData.exit_mlworks (applicationShell, appdata, 
		map (fn (w,_) => w) (Capi.get_main_windows ())),
@


1.73
log
@[Bug #30411]
Include Free edition
@
text
@d4 4
d504 1
d628 17
a644 6
	  case Capi.save_as_dialog (applicationShell, ".img")
	  of NONE => ()
	  |  SOME filename => 
	    SaveImage.saveImage
	      (false, handler_fn)
	      (filename, false)
@


1.72
log
@[Bug #30411]
Call Capi.show_splash_screen.
@
text
@d4 4
d735 8
a742 1
	(if SaveImage.showBanner() then 
d745 3
a747 3
	 License.license
	   {promptUser = Capi.license_prompt applicationShell,
	    complain = Capi.license_complain applicationShell})
d770 1
a770 1
	 create_listener();
@


1.71
log
@[Bug #30413]
Use abstract exit status
@
text
@d4 4
d758 2
a759 1
        (create_listener();
@


1.70
log
@[Bug #30384]
Project Workspace should start up if MLWorks starts up with an open project.
@
text
@d4 4
d766 1
a766 1
	Exit_.terminate 1
@


1.69
log
@[Bug #30090]
Remove uses of MLWorks.IO
@
text
@d4 4
d751 3
@


1.68
log
@[Bug #50061]
Remove redundant call to make_history
@
text
@d4 4
d686 9
a694 5
            let val oldIO = MLWorks.Internal.StandardIO.currentIO()
            in (MLWorks.Internal.StandardIO.resetIO();
                ignore(f());
                MLWorks.Internal.StandardIO.redirectIO oldIO)
            end
d696 1
a696 10
           (fn () => inDeliveredImage
            (fn () => MLWorks.IO.with_standard_output
             MLWorks.IO.terminal_out
             (fn () =>
              MLWorks.IO.with_standard_error
              MLWorks.IO.terminal_out
              (fn () =>
               MLWorks.IO.with_standard_input
               MLWorks.IO.terminal_in
               (fn () => deliverer args))))) ()
@


1.67
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
a609 4

      val {update_history, prev_history, next_history, history_start,
	   history_end, history_menu} =
	GuiUtils.make_history (user_preferences, fn s => ())
@


1.66
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d4 4
d684 1
a684 1
                f();
@


1.65
log
@[Bug #70065]
Remove uses of MLWorks.IO.messages and use the Messages structure
@
text
@d4 4
d410 1
d733 1
a733 6
              ((* Don't want this message now I think *)
               (* MLWorks.IO.output(MLWorks.IO.terminal_out,
                      "SYSTEM ERROR: Unexpected exception " ^ 
                      (MLWorks.Internal.Value.exn_name exn) ^
                      "\nreached top level -- restarting loop\n"); *)
              debugger_function exn;
d755 1
a755 2
       MLWorks.IO.output
       (MLWorks.IO.terminal_out, "Graphics interface problem: "^s^"\n")
@


1.64
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d405 1
d499 1
a499 2
      fun print_message message = 
	MLWorks.IO.output (MLWorks.IO.messages, message)
@


1.63
log
@[Bug #30193]
Call SysMessages.create.
@
text
@d4 20
d406 1
d418 3
a420 1
require "../gui/comp_manager";
d435 1
a435 1
  structure CompilationManager : COMPILATION_MANAGER
d442 3
d449 1
a449 1
               CompilationManager.ToolData =
d455 3
a457 2
  sharing type Menus.Widget = ToolData.Widget =
	       GuiUtils.Widget = Debugger_Window.Widget = Capi.Widget
d479 1
a479 1
     ("compManager", CompilationManager.create, ToolData.WRITABLE),
d600 22
d623 5
a627 1
	([("save",
d642 1
d753 1
a753 1
end;@


1.62
log
@[Bug #20074]
Improve license dialog.
@
text
@d4 4
d396 1
d418 1
d427 2
a428 1
	       BreakTrace.ToolData
d571 2
d594 6
a599 2
      val usage_menu = ToolData.set_global_usage_items (GuiUtils.setup_menu
	(applicationShell, get_context, user_preferences,get_user_context_options), [])
@


1.62.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 *  Revision 1.62  1997/07/17  16:24:58  johnh
 *  [Bug #20074]
 *  Improve license dialog.
 *
@


1.62.2.2
log
@[Bug #30071]
Implement new Project Workspace tool.
@
text
@d396 1
a396 2
require "../gui/proj_workspace";
require "^.gui.proj_properties";
d411 1
a411 1
  structure ProjectWorkspace : PROJECT_WORKSPACE
a416 1
  structure ProjProperties : PROJ_PROPERTIES
d421 1
a421 1
               ProjectWorkspace.ToolData =
d426 1
a426 1
  sharing type Menus.Widget = ToolData.Widget = ProjProperties.Widget =
d449 1
a449 1
     ("projWorkspace", ProjectWorkspace.create, ToolData.WRITABLE),
a567 15
      fun new_project () = (ProjProperties.new_project applicationShell;
			    ProjectWorkspace.create (mk_tooldata());
			    ProjectWorkspace.updateDisplay())

      fun open_project () = 
	if ProjProperties.open_project applicationShell then
	  (ProjectWorkspace.create (mk_tooldata());
	   ProjectWorkspace.updateDisplay())
	else ()

      fun save_project () = 
	if ProjProperties.save_project applicationShell then
	  ProjectWorkspace.updateDisplay()
	else ()

d569 1
a569 6
	([("new_proj", new_project, fn _ => true),
	 ("open_proj", open_project, fn _ => true),
	 ("save_proj", save_project, fn _ => true),
(*					fn () => UserContext.project_file_set 
						(get_current_user_context())), *)
	("save",
d690 1
a690 1
end;
@


1.62.2.3
log
@[Bug #30071]
Add File->ChangeCurrentDirectory (PathTool function).
@
text
@a3 4
 *  Revision 1.62.2.2  1997/09/12  14:44:13  johnh
 *  [Bug #30071]
 *  Implement new Project Workspace tool.
 *
a397 1
require "^.gui.path_tool";
a418 1
  structure PathTool : PATH_TOOL
d429 1
a429 2
	       GuiUtils.Widget = Debugger_Window.Widget = Capi.Widget = 
	       PathTool.Widget
d589 3
a591 1
	 ("save",
a605 1
	 ("setWD", fn _ => PathTool.setWD applicationShell, fn _ => true),
@


1.62.2.4
log
@[Bug #30071]
Add save_project_as to file menu.
@
text
@a3 4
 *  Revision 1.62.2.3  1997/11/24  12:11:27  johnh
 *  [Bug #30071]
 *  Add File->ChangeCurrentDirectory (PathTool function).
 *
a389 1
require "../main/proj_file";
a424 1
  structure ProjFile : PROJ_FILE
a591 7
      fun save_project_as () = 
	if ProjProperties.save_project_as applicationShell then
	  ProjectWorkspace.updateDisplay()
	else ()

      fun project_exists () = isSome (ProjFile.getProjectName())

d595 1
a595 2
	 ("save_proj", save_project, project_exists),
	 ("save_proj_as", save_project_as, project_exists),
@


1.62.2.5
log
@[Bug #30071]
Display Project Workspace window asap.
@
text
@a3 4
 *  Revision 1.62.2.4  1997/12/10  14:02:41  johnh
 *  [Bug #30071]
 *  Add save_project_as to file menu.
 *
d588 3
a590 3
	if ProjProperties.open_project applicationShell 
	  (fn () => ProjectWorkspace.create (mk_tooldata())) then 
	     ProjectWorkspace.updateDisplay()
@


1.62.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 *  Revision 1.62  1997/07/17  16:24:58  johnh
 *  [Bug #20074]
 *  Improve license dialog.
 *
@


1.62.1.2
log
@Add Datatype Wizard.
@
text
@a396 1
require "^.gui.dt_wizard";
a416 1
  structure DTWizard : DT_WIZARD
d425 1
a425 2
	       BreakTrace.ToolData =
               DTWizard.ToolData
d453 1
a453 2
     ("breakTrace", BreakTrace.create, ToolData.ALL),
     ("dTWizard", DTWizard.create, ToolData.ALL)]
@


1.61
log
@Automatic checkin:
changed attribute _comment to ' *  '
@
text
@d4 4
d376 2
d681 1
a681 1
	()
@


1.60
log
@new unit
Made podium files platform specific.
@
text
@@


1.59
log
@Changin listener interface.
@
text
@d4 160
d231 1
a231 1
 *  MotifUtils.options_menu now takes an extra argument.
d375 1
a375 1
require "../library/capi";
d377 11
a387 10
require "debugger_window";
require "tooldata";
require "menus";
require "listener";
require "inspector_tool";
require "motif_utils";
require "fileselect";
require "browser_tool";
require "evaluator";
require "context";
d394 1
a399 2
  structure InspectorTool : INSPECTORTOOL
  structure FileSelect : FILE_SELECT
d401 1
a401 1
  structure Evaluator : EVALUATOR
d403 1
a403 1
  structure MotifUtils : MOTIF_UTILS
d405 2
d408 2
d411 5
a415 4
	       InspectorTool.ToolData =
	       BrowserTool.ToolData = FileSelect.ToolData =
	       Evaluator.ToolData = ContextHistory.ToolData =
	       Debugger_Window.ToolData
d417 3
a419 3
	       MotifUtils.Widget = Debugger_Window.Widget = Capi.Widget
  sharing type MotifUtils.ButtonSpec = ToolData.ButtonSpec = Menus.ButtonSpec
  sharing type MotifUtils.user_tool_options = ToolData.ShellTypes.user_options =
d421 1
a421 1
  sharing type MotifUtils.user_context_options =
d423 1
a423 1
  sharing type Preferences.user_preferences = MotifUtils.user_preferences =
d425 2
a426 3
  sharing type InspectorTool.Type = Ml_Debugger.ValuePrinter.Type
  sharing type MotifUtils.user_context = ToolData.ShellTypes.user_context
  sharing type MotifUtils.MotifContext = ToolData.MotifContext
d428 1
d439 1
a439 2
     ("evaluator", Evaluator.create, ToolData.WRITABLE),
     ("fileBrowser", FileSelect.create, ToolData.WRITABLE),
d443 1
a443 1
     ("inspector", InspectorTool.create, ToolData.ALL)]
d445 7
d454 35
a488 1
      val applicationShell = Capi.initialize_application ("mlworks","MLWorks")
a497 23
      val (mainWindow,menuBar,contextLabel) =
        Capi.make_main_subwindows (applicationShell,full_menus)

      val label = Capi.make_managed_widget ("label", Capi.Label, mainWindow,[])

      val (scroll,message) = Capi.make_scrolled_text ("message",mainWindow,[])

      fun set_context_label motif_context =
	case contextLabel
	of MLWorks.Option.SOME w =>
          let
            val context_name =
              MotifUtils.get_context_name motif_context

            val string = "Context: " ^ context_name
          in
            Capi.set_label_string (w,string)
          end
	|  MLWorks.Option.NONE => ()

      fun start_messages () = Capi.set_message_widget message
      fun stop_messages () = Capi.no_message_widget ()

d500 1
a500 1
      val _ = MotifUtils.makeInitialContext
d505 1
a505 1
	  (MotifUtils.make_context
d508 2
d517 1
a517 1
	     MotifUtils.get_user_context (ToolData.get_current current_context),
d531 1
a531 1
	   motif_context = ToolData.get_current current_context,
d534 51
a584 23
      val context_key =
        ToolData.add_context_fn
          (current_context, (set_context_label, get_user_options, ToolData.ALL))

      fun select_context user_context =
        (set_context_label user_context;
         ToolData.set_current
           (current_context, context_key, user_options, user_context))

      val menuspec =
	[ToolData.works_menu
	   (mk_tooldata,
	    fn () => ToolData.exit_mlworks (applicationShell, appdata),
	    fn () => true,
	    fn () => MotifUtils.get_user_context
		       (ToolData.get_current current_context)),
 	 MotifUtils.setup_menu (mainWindow, user_preferences),
         MotifUtils.context_menu
	   {set_state = select_context,
	    get_context = fn _ => ToolData.get_current current_context,
	    writable = MotifUtils.ALL,
	    applicationShell = applicationShell,
	    user_preferences = user_preferences}]
d588 1
a588 2
	  (Debugger_Window.make_debugger_window
	     (applicationShell, "debugger", mk_tooldata ()),
d591 1
a591 4
	   fn s => output (MLWorks.IO.messages, s),
	   false)

      val _ = start_messages ()
d593 47
a639 5
      val _ =
	if not has_controlling_tty then
	  output (MLWorks.IO.messages, Version.version_string ^ "\n")
	else
	  ()
d647 2
a648 2
            Interrupt => true	(* interrupt, continue X interface *)
          | ShellTypes.DebuggerTrapped => true	(* continue X interface *)
d651 2
a652 1
              (output(MLWorks.IO.terminal_out,
d654 4
a657 3
                      MLWorks.Internal.Value.exn_name_string (MLWorks.Internal.Value.exn_name exn) ^
                      "\nreached top level -- restarting loop\n");
              MLWorks.Debugger.break "SYSTEM ERROR";
d660 1
a660 1
	  if loop then mainLoop frame else stop_messages()
d663 1
d665 16
a680 18
      Capi.Layout.lay_out
      ([Capi.Layout.MENUBAR menuBar] @@
       (case contextLabel of
          MLWorks.Option.NONE => [Capi.Layout.SPACE]
        | MLWorks.Option.SOME w => [Capi.Layout.OTHER w]) @@
       [Capi.Layout.OTHER label,
        Capi.Layout.OTHER scroll,
        Capi.Layout.SPACE]);
      Menus.make_submenus(menuBar,menuspec);
      Capi.manage menuBar;
      Capi.manage label;
      Capi.manage message;
      Capi.realize applicationShell;
      (* Xm.Widget.register applicationShell; *)
      set_context_label (ToolData.get_current current_context);
      Ml_Debugger.with_debugger_type debugger_type mainLoop
    end handle Capi.WindowSystemError s => output(std_out, "Can't start graphics interface: "^s^"\n")
end;
@


1.58
log
@Minor changes to layout.
@
text
@d4 3
d273 1
a273 1
    [("listener", Listener.create, ToolData.WRITABLE),
@


1.57
log
@Capifying
@
text
@d4 3
d412 2
a413 2
          MLWorks.Option.NONE => []
        | MLWorks.Option.SOME w => [Capi.Layout.OTHER w,Capi.Layout.SPACE]) @@
@


1.56
log
@Hid details of WINDOWING type in ml_debugger.
@
text
@d4 3
d209 1
a209 1
require "../library/xm";
d224 1
a224 1
  structure Xm: XM
d245 2
a246 2
  sharing type Xm.Widget = Menus.Widget = ToolData.Widget =
	       MotifUtils.Widget = Debugger_Window.Widget
d277 1
a277 9
      val name = Xm.Widget.NAME "mlworks"
      val class = Xm.APP_CLASS "MLWorks"
        
      val title = "MLWorks"

      val applicationShell =
	Xm.initialize
	  (name, class,
	   [(Xm.Title, Xm.STRING title), (Xm.IconName, Xm.STRING title)]);
d287 4
a290 29
      val mainWindow =
        Xm.Widget.create
        (Xm.Widget.NAME "main", Xm.Widget.Class.Form, applicationShell, [])

      val sep_size = 10;

      val menuBar =
        Xm.Widget.createMenuBar
        (mainWindow, Xm.Widget.NAME "menuBar", 
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)])

      val contextLabel =
	if full_menus then
	  MLWorks.Option.SOME
   	    (Xm.Widget.createManaged
               (Xm.Widget.NAME "contextLabel", Xm.Widget.Class.Label,
		mainWindow,
                [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                 (Xm.TopWidget, Xm.WIDGET menuBar),
                 (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                 (Xm.LeftOffset, Xm.INT sep_size),
                 (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                 (Xm.RightOffset, Xm.INT sep_size),
                 (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]))
	else
	  MLWorks.Option.NONE
d292 1
a292 29
      val label =
        Xm.Widget.create
        (Xm.Widget.NAME "label", Xm.Widget.Class.Label, mainWindow,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget,
	   case contextLabel
	   of MLWorks.Option.SOME w => Xm.WIDGET w
	   |  MLWorks.Option.NONE => Xm.WIDGET menuBar),
          (Xm.TopOffset,
	   case contextLabel
	   of MLWorks.Option.SOME w => Xm.INT 0
	   |  MLWorks.Option.NONE => Xm.INT sep_size),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	  (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	  (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)])

      val message =
        Xm.Widget.createScrolledText
        (mainWindow, Xm.Widget.NAME "message",
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET label),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	  (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	  (Xm.RightOffset, Xm.INT sep_size),
	  (Xm.BottomOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)])
d301 1
a301 2
            val cstring =
              Xm.CompoundString.createSimple("Context: " ^ context_name)
d303 1
a303 2
            Xm.Widget.valuesSet
  	      (w, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
d307 2
a308 2
      fun start_messages () = Xm.Text.setMessageWidget message
      fun stop_messages () = Xm.Text.noMessageWidget ()
d388 1
a388 1
	    (Xm.mainLoop (); false)
d393 1
a393 1
	  | Xm.SubLoopTerminated => false  (* break *)
d399 1
d406 8
d415 5
a419 6
      Xm.Widget.manage menuBar;
      Xm.Widget.manage label;
      Xm.Widget.manage message;
      Xm.Widget.manage mainWindow;
      Xm.Widget.realize applicationShell;
      Xm.Widget.register applicationShell;
d422 1
a422 1
    end handle Xm.X_system_error s => output(std_out, "Can't start X interface: "^s^"\n")
@


1.55
log
@InspectorTool no longer contains a Widget type.
@
text
@d4 3
d251 1
a251 2
  sharing type InspectorTool.Type = Debugger_Window.Type
  sharing type Ml_Debugger.ValuePrinter.Type = Debugger_Window.Type
d254 2
d432 3
@


1.54
log
@Types of the InspectorTool functions have changed.
@
text
@d4 3
d240 1
a240 2
	       InspectorTool.Widget = MotifUtils.Widget =
	       Debugger_Window.Widget
@


1.53
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d4 3
d264 1
a264 3
     ("inspector",
      InspectorTool.create Debugger_Window.make_debugger_window,
      ToolData.ALL)]
@


1.52
log
@Made contexts only visible if full_menus set.
@
text
@d4 3
a11 1
 *  .,
d195 1
d203 2
a206 2
require "inspector_tool";
require "motif_utils";
d214 1
d220 1
d223 2
a224 1
  structure InspectorTool : INSPECTORTOOL
a226 2
  structure Evaluator : EVALUATOR
  structure ContextWindow : CONTEXT_WINDOW
d228 5
a232 4
  sharing type Listener.ToolData = FileSelect.ToolData = ToolData.ToolData =
	       BrowserTool.ToolData = InspectorTool.ToolData =
	       Debugger_Window.ToolData = Evaluator.ToolData =
	       ContextWindow.ToolData
d237 6
a242 2
  sharing type MotifUtils.UserOptions = ToolData.ShellTypes.user_options =
    	       UserOptions.user_options
d246 1
d260 1
a260 1
     ("contextWindow", ContextWindow.create, ToolData.ALL),
d277 2
a278 1
      val ShellTypes.LISTENER_ARGS {user_options, user_context, ...} = args
d281 2
a282 2
	case user_options
	of UserOptions.USER_OPTIONS ({full_menus, ...}, update_fns) =>
d345 1
a345 1
      fun set_context_label user_context =
d350 1
a350 1
              UserContext.get_context_name user_context
d365 2
a366 1
      val current_context = ToolData.make_current user_context
d368 5
d375 1
d379 4
a382 2
	  {user_context = ToolData.get_current current_context,
           user_options = UserOptions.copy user_options,
d394 1
a396 3
      val (options_menu,update) =
	MotifUtils.options_menu (mainWindow, title, get_user_options, fn _ => ())

a405 2
      val _ = update_fns := update :: (!update_fns)

d407 13
a419 13
	ToolData.works_menu
	  (mk_tooldata,
	   fn () => ToolData.exit_mlworks (applicationShell, appdata),
	   fn () => true,
	   fn () => ToolData.get_current current_context)
 	:: MotifUtils.setup_menu (mainWindow, get_user_options)
        :: (if full_menus then
	      [MotifUtils.context_menu
	         (select_context, fn _ => ToolData.get_current current_context,
	          MotifUtils.ALL),
	       options_menu]
	    else
	      [options_menu])
@


1.51
log
@Added "Browse Initial" entry to tools menu.
@
text
@d4 3
d267 7
d289 14
a302 9
   	Xm.Widget.createManaged
          (Xm.Widget.NAME "contextLabel", Xm.Widget.Class.Label, mainWindow,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)])
d308 8
a315 1
          (Xm.TopWidget, Xm.WIDGET contextLabel),
d335 13
a347 10
        let
          val context_name =
            UserContext.get_context_name user_context

          val cstring =
            Xm.CompoundString.createSimple("Context: " ^ context_name)
        in
          Xm.Widget.valuesSet
  	    (contextLabel, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
        end
a351 2
      val ShellTypes.LISTENER_ARGS {user_options, user_context, ...} = args

a378 2
      val UserOptions.USER_OPTIONS(_,update_fns) = user_options

d391 13
a403 10
	[ToolData.works_menu
	   (mk_tooldata,
	    fn () => ToolData.exit_mlworks (applicationShell, appdata),
	    fn () => true,
	    fn () => ToolData.get_current current_context),
 	 MotifUtils.setup_menu (mainWindow, get_user_options),
         MotifUtils.context_menu
	   (select_context, fn _ => ToolData.get_current current_context,
	    MotifUtils.ALL),
	 options_menu]
@


1.50
log
@Improving X_system_error message
.,
@
text
@d4 4
d246 1
@


1.49
log
@Using createMenuBar for creating menuBar
@
text
@d4 3
d279 1
d281 1
d292 1
d419 1
a419 1
    end handle Xm.X_system_error s => output(std_out, "exception X_system_error raised: "^s^"\n")
@


1.48
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d4 3
d263 2
a264 2
        Xm.Widget.createManaged
        (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, mainWindow,
d405 1
@


1.47
log
@Make subwindow parents not be menuBar
@
text
@d2 176
a178 174
$Log: _podium.sml,v $
Revision 1.46  1995/04/24  10:40:14  daveb
Added handler for Xm.SubLoopTerminated to mainLoop.

Revision 1.45  1995/04/18  15:33:28  daveb
Changes to context_menu.

Revision 1.44  1995/04/13  17:56:39  daveb
Xm.mainLoop is back to taking unit.

Revision 1.43  1995/04/13  10:27:55  daveb
Added a context menu.

Revision 1.42  1995/04/07  10:52:57  daveb
Added AppContext type to Xm library.

Revision 1.41  1995/03/30  14:03:42  daveb
Added ContextWindow to list of tools.

Revision 1.40  1995/03/27  13:46:15  io
catch X exn when DISPLAY left unset

Revision 1.39  1995/03/17  11:50:36  daveb
Added Writable component to tool list.

Revision 1.38  1995/03/16  16:27:08  daveb
Made all created tools share the same current_context value.

Revision 1.37  1995/03/15  16:50:27  daveb
listener_args now has a new type.

Revision 1.36  1995/03/10  15:54:18  daveb
MotifUtils.options_menu now takes an extra argument.

Revision 1.35  1995/01/13  16:56:07  daveb
Removed obsolete sharing constraint.

Revision 1.34  1994/07/14  14:50:29  daveb
start_x_interface now takes a boolean parameter that indicates whether
it was called from a TTY.  If not, it MLWorks must have called it on
start up, so it prints the version message.  This flag is passed into
the appdata field of the ToolData type.

Revision 1.33  1994/07/12  16:22:48  daveb
ToolData.works_menu takes different arguments.
InspectorTool.ToolData.ShellTypes.Option replaced with InspectorTool.Option

Revision 1.32  1994/06/30  08:56:42  nickh
Provide for messages to appear in the podium window.
(and remove some dead code).

Revision 1.31  1994/06/20  13:03:25  daveb
Added the evaluator.
Replaced context refs with user_contexts.

Revision 1.30  1994/04/07  12:07:37  daveb
Added case for DebuggerTrapped.

Revision 1.29  1994/03/21  17:23:35  matthew
Added catchall around event loop

Revision 1.28  1994/02/02  11:59:57  daveb
Changed substructure of InterMake.

Revision 1.27  1993/12/09  14:38:08  matthew
Added call to register application shell for inter client comms.

Revision 1.26  1993/11/18  18:01:09  daveb
The argument to Ml_Debugger.with_debugger_type now takesa frame argument
instead of unit.

Revision 1.25  1993/11/09  15:55:37  daveb
Merged in bug fix.

Revision 1.24  1993/10/22  17:00:49  daveb
Merged in bug fix.

Revision 1.23  1993/09/07  14:04:22  daveb
Merged in bug fix.

26,28d16
Revision 1.22  1993/09/07  11:18:09  daveb
Merged in bug fix.

Revision 1.21.1.5  1993/11/09  15:44:17  daveb
Made mainLoop properly tail recursive.

Revision 1.21.1.4  1993/10/21  14:04:43  daveb
Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.

Revision 1.21.1.3  1993/09/07  13:54:22  daveb
Changed argument to debugger_type to ensure that it always uses a window
debugger, even if the user prefers a TTY debugger (that preference only
affects the listener).

Revision 1.21.1.2  1993/09/06  15:21:31  daveb
Wrapped debugger around mainLoop.

Revision 1.21  1993/08/11  13:12:46  matthew
Changes for automatic option menu updating

Revision 1.20  1993/08/06  15:23:55  nosa
Pass debugger_window to Inspector.

Revision 1.19  1993/06/02  14:12:04  daveb
Changed title to "MLWorks", since "MLWorks Console" wasn't popular.

Revision 1.18  1993/05/13  14:02:29  daveb
All tools now set their own titles and pass them to their options menus.

Revision 1.17  1993/05/05  19:20:25  daveb
Added InspectorTool to the list of tools.

Revision 1.16  1993/05/05  11:50:02  daveb
Moved exit_mlworks from _podium to _tooldata.  Added tools argument to
 works_menu(), removed exitApplication from TOOLDATA.

Revision 1.15  1993/04/30  14:43:52  daveb
Reorganised menus.

Revision 1.14  1993/04/28  14:19:57  richard
The podium now has a text messages widget and a horizontal menu bar
rather than being like the old LispWorks podium.

Revision 1.13  1993/04/21  14:53:16  daveb
Removed context browser item from tools menu.

Revision 1.12  1993/04/16  14:52:27  matthew
Changed interface to tools
Added file browser

Revision 1.11  1993/04/05  14:58:14  daveb
Names of Callbacks have changed.

Revision 1.10  1993/04/02  15:18:02  matthew
Removed Incremental structure

Revision 1.9  1993/03/30  14:46:38  matthew
Menus.MENUSPEC is no more

Revision 1.8  1993/03/30  12:29:02  matthew
Removed "destroying..": message
/.

Revision 1.7  1993/03/26  14:19:00  matthew
Changed menus for consistency with listener

Revision 1.6  1993/03/23  14:10:22  matthew
Used generic menu facility

Revision 1.5  1993/03/17  15:22:08  matthew
Tried doing CloseDisplay instead of destroy applicationShell
Currently commented out.

Revision 1.4  1993/03/15  17:50:19  matthew
Simplified ShellTypes type

Revision 1.3  1993/03/15  14:43:45  daveb
Prevented the podium from being resized.
Changed quit dialog to offer option of returning to TTY listener or
quitting completely.

Revision 1.2  1993/03/08  15:24:39  matthew
Changes for ShellData type

Revision 1.1  1993/03/02  17:54:38  daveb
Initial revision


Copyright (c) 1993 Harlequin Ltd.

*)

a223 1

d227 2
d301 1
a301 1
            ToolData.ShellTypes.get_context_name user_context
@


1.46
log
@Added handler for Xm.SubLoopTerminated to mainLoop.
@
text
@d4 3
d257 1
a257 1
        Xm.Widget.create
d337 1
a337 1
	MotifUtils.options_menu (menuBar, title, get_user_options, fn _ => ())
d358 1
a358 1
 	 MotifUtils.setup_menu (menuBar, get_user_options),
a398 1
      Xm.Widget.manage menuBar;
@


1.45
log
@Changes to context_menu.
@
text
@d4 3
d383 1
@


1.44
log
@Xm.mainLoop is back to taking unit.
@
text
@d4 3
d292 1
a292 1
            ToolData.ShellTypes.context_name user_context
d353 3
a355 1
         MotifUtils.context_menu (select_context, MotifUtils.ALL),
@


1.43
log
@Added a context menu.
@
text
@d4 3
d370 1
a370 1
	    (Xm.mainLoop applicationShell; false)
@


1.42
log
@Added AppContext type to Xm library.
@
text
@a0 1

d4 3
d209 2
d242 2
d252 9
d265 1
a265 1
          (Xm.TopWidget, Xm.WIDGET menuBar),
d267 1
d277 1
d279 2
d283 12
d329 9
d346 2
a347 1
	 MotifUtils.setup_menu (menuBar, get_user_options),
d390 1
@


1.41
log
@Added ContextWindow to list of tools.
@
text
@d5 3
d229 4
a232 3
      val applicationShell = Xm.initialize
	(name, class,
	 [(Xm.Title, Xm.STRING title), (Xm.IconName, Xm.STRING title)]);
d326 2
a327 1
	    (Xm.mainLoop (); false)	(* normal return, don't loop *)
@


1.40
log
@catch X exn when DISPLAY left unset
@
text
@d5 3
d173 1
d190 1
d194 5
a198 3
	       Debugger_Window.ToolData = Evaluator.ToolData
  sharing type Xm.Widget = Menus.Widget = ToolData.Widget = InspectorTool.Widget
    = MotifUtils.Widget = Debugger_Window.Widget
d201 1
a201 1
    UserOptions.user_options
d214 1
@


1.39
log
@Added Writable component to tool list.
@
text
@d5 3
d337 1
a337 1
    end
@


1.38
log
@Made all created tools share the same current_context value.
@
text
@a0 2
(*
podium.sml the functor.
d2 2
d5 3
d200 7
a206 5
    [("listener",Listener.create),
     ("evaluator",Evaluator.create),
     ("fileBrowser",FileSelect.create),
     ("contextBrowser", BrowserTool.create),
     ("inspector", InspectorTool.create Debugger_Window.make_debugger_window)]
d289 2
a290 1
	    fn () => true),
@


1.37
log
@listener_args now has a new type.
@
text
@d5 3
d251 2
d257 5
a261 4
        ShellTypes.LISTENER_ARGS {user_context = user_context,
                                  user_options = UserOptions.copy user_options,
                                  prompter = prompter,
                                  mk_xinterface_fn = mk_xinterface_fn}
d271 1
a271 2
	   current_context = ToolData.make_current user_context,
	   tools = tool_list}
@


1.36
log
@MotifUtils.options_menu now takes an extra argument.
@
text
@d5 3
d244 1
a244 1
      val ShellTypes.LISTENER_ARGS {user_options, ...} = args
d264 3
a266 1
	  {args = copy_args args, appdata = appdata, tools = tool_list}
@


1.35
log
@Removed obsolete sharing constraint.
@
text
@d5 3
d264 1
a264 1
	MotifUtils.options_menu (menuBar, title, get_user_options)
@


1.34
log
@start_x_interface now takes a boolean parameter that indicates whether
it was called from a TTY.  If not, it MLWorks must have called it on
start up, so it prints the version message.  This flag is passed into
the appdata field of the ToolData type.
@
text
@d5 6
a171 2
  sharing Debugger_Window.Option = InspectorTool.Option =
	  Ml_Debugger.Incremental.InterMake.Option
@


1.33
log
@ToolData.works_menu takes different arguments.
InspectorTool.ToolData.ShellTypes.Option replaced with InspectorTool.Option
@
text
@d5 4
d137 1
d154 1
d190 1
a190 1
  fun start_x_interface args () =
d246 6
d254 4
a257 4
	  {args = copy_args args,
           appdata = ToolData.APPLICATIONDATA
		       {applicationShell = applicationShell},
           tools = tool_list}
a258 1
      val (options_menu,update) = MotifUtils.options_menu (menuBar, title, get_user_options)
d260 1
d262 1
d266 1
a266 2
	    fn () => ToolData.exit_mlworks
		       (applicationShell, applicationShell),
d278 6
@


1.32
log
@Provide for messages to appear in the podium window.
(and remove some dead code).
@
text
@d5 4
d160 1
a160 1
  sharing Debugger_Window.Option = InspectorTool.ToolData.ShellTypes.Option =
d163 1
a163 1
	       BrowserTool.ToolData = InspectorTool.ToolData.ToolData =
d252 4
a255 1
	   (applicationShell, tool_list, mk_tooldata, fn () => false),
@


1.31
log
@Added the evaluator.
Replaced context refs with user_contexts.
@
text
@d5 4
d221 2
a222 40
      val exit_mlworks =
        let
          val dialog =
            Xm.Widget.createPopupShell (Xm.Widget.NAME "quitDialog",
                                        Xm.Widget.Class.DialogShell,
                                        applicationShell, [])

          val message =
            let
              (* To make life easy, we use a standard MessageBox widget and
	       change the labels and actions around.
               *)
              val widget =
                Xm.Widget.create
	        (Xm.Widget.NAME "message", Xm.Widget.Class.MessageBox, dialog,
		 [(* This magic is actually done in the app-defaults file.
                   (Xm.OkLabelString, "End X Session"),
                   (Xm.CancelLabelString, "Exit MLWorks"),
                   (Xm.HelpLabelString, "Cancel"),
                   (Xm.MessageString, "Select an Action:")
		   *)
                 ])
                
              fun tty _ = ((* Xm.closeDisplay () *)
                           Xm.Widget.destroy applicationShell
                           )
              fun exit _ = MLWorks.exit 0;
              fun cancel _ = Xm.Widget.unmanage widget
            in
              Xm.Widget.callbackAdd (widget, Xm.Callback.Ok, tty);
              Xm.Widget.callbackAdd (widget, Xm.Callback.Help, cancel);
              Xm.Widget.callbackAdd (widget, Xm.Callback.Cancel, exit);
              widget
            end
        in
          fn _ => Xm.Widget.manage message
        end

      (* This doesn't work too well at the moment *)
      fun close_podium _ = Xm.Widget.unmanage applicationShell
d258 2
d274 2
a275 1
	  if loop then mainLoop frame else ()	(* tail recursive call *)
@


1.30
log
@Added case for DebuggerTrapped.
@
text
@d5 3
d135 1
d150 1
d155 2
a156 1
	       BrowserTool.ToolData = InspectorTool.ToolData.ToolData = Debugger_Window.ToolData
d171 1
d262 1
a262 1
      fun copy_args (ShellTypes.LISTENER_ARGS {context_ref,
d266 1
a266 1
        ShellTypes.LISTENER_ARGS {context_ref = context_ref,
@


1.29
log
@Added catchall around event loop
@
text
@d5 3
d291 1
@


1.28
log
@Changed substructure of InterMake.
@
text
@d5 3
d286 8
a293 1
	    handle Interrupt => true	(* interrupt, continue X interface *)
@


1.27
log
@Added call to register application shell for inter client comms.
@
text
@d5 3
d142 1
a142 1
	  Ml_Debugger.Incremental.InterMake.FileName.Option
@


1.26
log
@The argument to Ml_Debugger.with_debugger_type now takesa frame argument
instead of unit.
@
text
@d5 4
d291 1
@


1.25
log
@Merged in bug fix.
@
text
@d5 3
d14 4
a29 3
Revision 1.22  1993/09/07  11:18:09  daveb
Merged in bug fix.

d272 1
a272 1
      fun mainLoop () =
d278 1
a278 1
	  if loop then mainLoop () else ()	(* tail recursive call *)
@


1.24
log
@Merged in bug fix.
@
text
@d5 3
d11 3
d269 7
a275 2
	Xm.mainLoop ()
	handle Interrupt => mainLoop ()
@


1.23
log
@Merged in bug fix.
@
text
@d5 7
d251 2
a252 1
	[ToolData.works_menu (applicationShell, tool_list, mk_tooldata),
@


1.22
log
@Merged in bug fix.
@
text
@d5 8
d252 1
a252 1
	   true)
@


1.21
log
@Changes for automatic option menu updating
@
text
@d5 6
d85 1
d107 1
d109 2
a110 1
  sharing Debugger_Window.Option = InspectorTool.ToolData.ShellTypes.Option
d119 1
d239 10
d256 1
a256 1
      Xm.mainLoop ()
@


1.21.1.1
log
@Fork for bug fixing
@
text
@a4 3
Revision 1.21  1993/08/11  13:12:46  matthew
Changes for automatic option menu updating

@


1.21.1.2
log
@Wrapped debugger around mainLoop.
@
text
@a81 1
require "../debugger/ml_debugger";
a102 1
  structure Ml_Debugger : ML_DEBUGGER
d104 1
a104 2
  sharing Debugger_Window.Option = InspectorTool.ToolData.ShellTypes.Option =
	  Ml_Debugger.Incremental.InterMake.FileName.Option
a112 1
  sharing type Ml_Debugger.ValuePrinter.Type = Debugger_Window.Type
a231 10

      val debugger_type =
	Ml_Debugger.WINDOWING
	  (Debugger_Window.make_debugger_window
	     (applicationShell, "debugger", mk_tooldata ()),
	   true)

      fun mainLoop () =
	Xm.mainLoop ()
	handle Interrupt => mainLoop ()
d239 1
a239 1
      Ml_Debugger.with_debugger_type debugger_type mainLoop
@


1.21.1.3
log
@Changed argument to debugger_type to ensure that it always uses a window
debugger, even if the user prefers a TTY debugger (that preference only
affects the listener).
@
text
@a4 3
Revision 1.21.1.2  1993/09/06  15:21:31  daveb
Wrapped debugger around mainLoop.

d241 1
a241 1
	   false)
@


1.21.1.4
log
@Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.
@
text
@a4 5
Revision 1.21.1.3  1993/09/07  13:54:22  daveb
Changed argument to debugger_type to ensure that it always uses a window
debugger, even if the user prefers a TTY debugger (that preference only
affects the listener).

d236 1
a236 2
	[ToolData.works_menu
	   (applicationShell, tool_list, mk_tooldata, fn () => false),
@


1.21.1.5
log
@Made mainLoop properly tail recursive.
@
text
@a4 4
Revision 1.21.1.4  1993/10/21  14:04:43  daveb
Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.

d253 2
a254 7
	let
	  val loop =
	    (Xm.mainLoop (); false)	(* normal return, don't loop *)
	    handle Interrupt => true	(* interrupt, continue X interface *)
	in
	  if loop then mainLoop () else ()	(* tail recursive call *)
	end
@


1.20
log
@Pass debugger_window to Inspector.
@
text
@d5 3
d77 1
d91 1
d107 2
a108 1
  sharing type MotifUtils.UserOptions = ToolData.ShellTypes.user_options
d203 12
a214 4
      fun get_user_options () =
	case args of
	  ToolData.ShellTypes.LISTENER_ARGS {user_options, ...} => user_options
	  
d217 1
a217 1
	  {args = args,
d222 3
d228 1
a228 1
	 MotifUtils.options_menu (menuBar, title, get_user_options)]
@


1.19
log
@Changed title to "MLWorks", since "MLWorks Console" wasn't popular.
@
text
@d5 3
d75 1
d87 1
d96 1
d98 3
a100 2
	       BrowserTool.ToolData = InspectorTool.ToolData
  sharing type Xm.Widget = Menus.Widget = ToolData.Widget = MotifUtils.Widget
d103 1
d113 1
a113 1
     ("inspector", InspectorTool.create)]
@


1.18
log
@All tools now set their own titles and pass them to their options menus.
@
text
@d5 3
d112 1
a112 1
      val title = "MLWorks Console"
@


1.17
log
@Added InspectorTool to the list of tools.
@
text
@d5 3
d109 5
a113 1
      val applicationShell = Xm.initialize(name, class, []);
d200 1
a200 1
	 MotifUtils.options_menu (menuBar, get_user_options)]
@


1.16
log
@Moved exit_mlworks from _podium to _tooldata.  Added tools argument to
 works_menu(), removed exitApplication from TOOLDATA.
@
text
@d5 4
d71 1
d82 1
d86 1
a86 1
	       BrowserTool.ToolData
d98 2
a99 1
     ("contextBrowser", BrowserTool.create)]
@


1.15
log
@Reorganised menus.
@
text
@d5 3
d180 1
a180 2
		       {exitApplication = exit_mlworks,
                        applicationShell = applicationShell},
d184 1
a184 1
	[ToolData.works_menu (applicationShell, mk_tooldata),
@


1.14
log
@The podium now has a text messages widget and a horizontal menu bar
rather than being like the old LispWorks podium.
@
text
@d5 4
d63 2
d73 2
d76 5
a80 2
  sharing type Listener.ToolData = FileSelect.ToolData = ToolData.ToolData
  sharing type Xm.Widget = Menus.Widget = ToolData.Widget
d88 2
a89 1
     ("fileBrowser",FileSelect.create)]
d169 11
a179 11
      val tooldata = ToolData.TOOLDATA{args = args,
                                       appdata = ToolData.APPLICATIONDATA{exitApplication = exit_mlworks,
                                                                          applicationShell = applicationShell},
                                       tools = tool_list}
      val tools_buttons =
        map
        (fn (name,toolfun) =>
         Menus.PUSH (name,
                     fn _ => toolfun tooldata,
                     fn _ => true))
        tool_list
d182 3
a184 10
        [Menus.CASCADE ("file",
                       [Menus.PUSH ("close",
                                    close_podium,
                                    fn _ => false),
                        Menus.SEPARATOR,
                        Menus.PUSH ("exit",
                                    fn _ => exit_mlworks(),
                                    fn _ => true)],
                       fn _ => true),
        Menus.CASCADE ("tools",tools_buttons,fn _ => true)]
@


1.13
log
@Removed context browser item from tools menu.
@
text
@d5 3
d85 30
a114 22
        
      val podium =
        Xm.Widget.createManaged (Xm.Widget.NAME "podium",
                                 Xm.Widget.Class.BulletinBoard,
                                 applicationShell,
                                 [])
        
      val rowcolumn =
        Xm.Widget.createManaged (Xm.Widget.NAME "rowcolumn",
                                 Xm.Widget.Class.RowColumn,
                                 podium,
                                 [])
        
      val logo =
        Xm.Widget.createManaged (Xm.Widget.NAME "logo",
                                 Xm.Widget.Class.Label,
                                 rowcolumn, [])
        
      val menubar =
        Xm.Widget.createManaged (Xm.Widget.NAME "menuBar",
                                 Xm.Widget.Class.RowColumn,
                                 rowcolumn, [])
d122 1
a122 1
            
d181 5
a185 1
      Menus.make_submenus(menubar,menuspec);
@


1.12
log
@Changed interface to tools
Added file browser
@
text
@d5 4
d74 1
a74 2
     ("fileBrowser",FileSelect.create),
     ("contextBrowser", fn _ => ())]
@


1.11
log
@Names of Callbacks have changed.
@
text
@d5 3
d48 1
a48 1
require "../interpreter/shell_types";
d51 1
d56 2
d59 1
a59 2
  structure ShellTypes : SHELL_TYPES
  structure Menus : MENUS
d61 2
a62 2
  sharing type Listener.Args = ShellTypes.ListenerArgs
  sharing type Listener.Widget = Xm.Widget = Menus.Widget
d65 2
a66 1
  type Args = Listener.Args
d68 5
d139 1
d142 15
a156 4
    in 
      Menus.make_submenus
      (menubar,
       [Menus.CASCADE ("file",
d165 3
a167 10
        Menus.CASCADE ("tools",
                       [Menus.PUSH ("listener",
                                    fn _ =>
                                    Listener.create
                                    (args,exit_mlworks,applicationShell),
                                    fn _ => true),
                        Menus.PUSH ("fileBrowser",
                                    fn _ => output(std_out,"No file browser yet\n"),
                                    fn _ => false)],
                       fn _ => true)]);
@


1.10
log
@Removed Incremental structure
@
text
@d5 3
d120 3
a122 3
              Xm.Widget.callbackAdd (widget, Xm.OkCallback, tty);
              Xm.Widget.callbackAdd (widget, Xm.HelpCallback, cancel);
              Xm.Widget.callbackAdd (widget, Xm.CancelCallback, exit);
@


1.9
log
@Menus.MENUSPEC is no more
@
text
@d5 3
a56 2
  structure Incremental = Listener.Incremental

@


1.8
log
@Removed "destroying..": message
/.
@
text
@d5 4
a128 1
       Menus.MENUSPEC
d130 7
a136 7
                       Menus.MENUSPEC [Menus.PUSH ("close",
                                                   close_podium,
                                                   fn _ => false),
                                       Menus.SEPARATOR,
                                       Menus.PUSH ("exit",
                                                   fn _ => exit_mlworks(),
                                                   fn _ => true)],
a138 1
                       Menus.MENUSPEC
@


1.7
log
@Changed menus for consistency with listener
@
text
@d5 3
d106 3
a108 5
              fun tty _ = (output (std_out,
                                    "destroying applicationShell\n");
                            (* Xm.closeDisplay () *)
                            Xm.Widget.destroy applicationShell
                            )
@


1.6
log
@Used generic menu facility
@
text
@d5 3
d103 1
a103 1
              fun tty () = (output (std_out,
d108 2
a109 2
              fun exit () = MLWorks.exit 0;
              fun cancel () = Xm.Widget.unmanage widget
d119 2
d124 21
a144 19
       Menus.MENUSPEC [Menus.CASCADE ("Quit",
                                      Menus.MENUSPEC
                                      [Menus.PUSH ("quit",exit_mlworks,fn _ => true)],
                                      fn _ => true),
                       Menus.CASCADE ("New",
                                      Menus.MENUSPEC
                                      [Menus.PUSH ("Listener",
                                                     fn () =>
                                                     Listener.create
                                                     (ShellTypes.copy_listener_args args,
                                                      exit_mlworks,
                                                      applicationShell),
                                                     fn _ => true),
                                       Menus.PUSH ("Shared Context Listener",
                                                     fn () =>
                                                     Listener.create
                                                     (args,exit_mlworks,applicationShell),
                                                     fn _ => true)],
                                      fn _ => true)]);
@


1.5
log
@Tried doing CloseDisplay instead of destroy applicationShell
Currently commented out.
@
text
@d5 4
d30 1
d37 2
d40 2
a41 1
  sharing type Listener.Widget = Xm.Widget
d47 1
a66 4
      (*
val _ = Xm.Widget.valuesSet (podium, Xm.DELETE_RESPONSE DESTROY)
       *)
        
d72 2
a73 2
      val menu =
        Xm.Widget.createManaged (Xm.Widget.NAME "menu",
d76 2
a77 2
        
      val newButton =
a78 20
          val widget =
            Xm.Widget.createManaged (Xm.Widget.NAME "new",
                                     Xm.Widget.Class.PushButton,
                                     menu, [])
        in
          Xm.Widget.callbackAdd (
                                 widget,
                                 Xm.ActivateCallback,
                                 fn () => Listener.create(args, applicationShell)
                                 );
          widget
        end
      
      val quitButton =
        let
          val widget =
            Xm.Widget.createManaged (Xm.Widget.NAME "quit",
                                     Xm.Widget.Class.PushButton,
                                     menu, [])
            
d92 1
a92 1
		 [(* This magi is actually done in the app-defaults file.
d114 1
a114 4
          Xm.Widget.callbackAdd (widget,
                                 Xm.ActivateCallback,
                                 fn () => Xm.Widget.manage message);
          widget
d117 21
@


1.4
log
@Simplified ShellTypes type
@
text
@d5 3
d117 3
a119 1
                            Xm.Widget.destroy applicationShell)
@


1.3
log
@Prevented the podium from being resized.
Changed quit dialog to offer option of returning to TTY listener or
quitting completely.
@
text
@d5 5
d35 64
a98 64
  type ShellData = Listener.ShellData
  fun start_x_interface shell_data =
  let
    val name = Xm.Widget.NAME "mlworks"
    val class = Xm.APP_CLASS "MLWorks"

    val applicationShell = Xm.initialize(name, class, []);

    val podium =
      Xm.Widget.createManaged (Xm.Widget.NAME "podium",
                               Xm.Widget.Class.BulletinBoard,
                               applicationShell,
                               [])

    val rowcolumn =
      Xm.Widget.createManaged (Xm.Widget.NAME "rowcolumn",
                               Xm.Widget.Class.RowColumn,
                               podium,
                               [])

    (*
    val _ = Xm.Widget.valuesSet (podium, Xm.DELETE_RESPONSE DESTROY)
    *)

    val logo =
      Xm.Widget.createManaged (Xm.Widget.NAME "logo",
			       Xm.Widget.Class.Label,
			       rowcolumn, [])
  
    val menu =
      Xm.Widget.createManaged (Xm.Widget.NAME "menu",
			       Xm.Widget.Class.RowColumn,
			       rowcolumn, [])

    val newButton =
      let
        val widget =
          Xm.Widget.createManaged (Xm.Widget.NAME "new",
				   Xm.Widget.Class.PushButton,
				   menu, [])
      in
        Xm.Widget.callbackAdd (
	  widget,
	  Xm.ActivateCallback,
	  fn () => Listener.create(shell_data, applicationShell, fn args => fn () => start_x_interface args)
	);
        widget
      end

    val quitButton =
      let
        val widget =
          Xm.Widget.createManaged (Xm.Widget.NAME "quit",
	  			   Xm.Widget.Class.PushButton,
	 			   menu, [])
  
        val dialog =
          Xm.Widget.createPopupShell (Xm.Widget.NAME "quitDialog",
				      Xm.Widget.Class.DialogShell,
				      applicationShell, [])
  
        val message =
          let
	    (* To make life easy, we use a standard MessageBox widget and
d100 3
a102 3
	     *)
            val widget =
	      Xm.Widget.create
d105 4
a108 4
		     (Xm.OkLabelString, "End X Session"),
		     (Xm.CancelLabelString, "Exit MLWorks"),
		     (Xm.HelpLabelString, "Cancel"),
		     (Xm.MessageString, "Select an Action:")
d110 23
a132 23
		  ])

	    fun tty () = (output (std_out,
				  "destroying applicationShell\n");
	                  Xm.Widget.destroy applicationShell)
	    fun exit () = MLWorks.exit 0;
	    fun cancel () = Xm.Widget.unmanage widget
          in
            Xm.Widget.callbackAdd (widget, Xm.OkCallback, tty);
            Xm.Widget.callbackAdd (widget, Xm.HelpCallback, cancel);
            Xm.Widget.callbackAdd (widget, Xm.CancelCallback, exit);
            widget
          end
      in
        Xm.Widget.callbackAdd (widget,
			       Xm.ActivateCallback,
			       fn () => Xm.Widget.manage message);
        widget
      end
  in 
    Xm.Widget.realize applicationShell;
    Xm.mainLoop ()
  end
@


1.2
log
@Changes for ShellData type
@
text
@d5 3
d40 6
d47 1
a47 1
                               applicationShell,
d57 1
a57 1
			       podium, [])
d62 1
a62 1
			       podium, [])
d93 3
d97 15
a111 6
              Xm.Widget.create (Xm.Widget.NAME "message",
				Xm.Widget.Class.MessageBox,
				dialog, [])
	    fun activate () = (output (std_out,
				       "destroying applicationShell\n");
	                       Xm.Widget.destroy applicationShell)
d113 3
a115 3
            Xm.Widget.callbackAdd (widget, Xm.OkCallback, activate);
            Xm.Widget.callbackAdd (widget, Xm.CancelCallback,
	      			   fn () => Xm.Widget.unmanage widget);
@


1.1
log
@Initial revision
@
text
@d4 3
a6 1
$Log$
d8 1
d14 1
a25 2
  type UserOptions = Listener.UserOptions
  type PrinterDescriptor = Listener.PrinterDescriptor
d27 2
a28 3
  fun start_x_interface (
    user_options, printer_descriptor, shell_options, 
    info_options, current_context, prompter) =
d65 1
a65 4
	  fn () => Listener.create(user_options, printer_descriptor,
				   shell_options, info_options,
				   !current_context, prompter, applicationShell,
				   fn args => fn () => start_x_interface args)
@
