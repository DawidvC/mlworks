head	1.55;
access;
symbols
	MLW_daveb_inline_1_4_99:1.55.1
	MLWorks_21c0_1999_03_25:1.55
	MLWorks_20c1_1998_08_20:1.54
	MLWorks_20c0_1998_08_04:1.53
	MLWorks_20b2c2_1998_06_19:1.52
	MLWorks_20b2_Windows_1998_06_12:1.51
	MLWorks_20b1c1_1998_05_07:1.51
	MLWorks_20b0_1998_04_07:1.51
	MLWorks_20b0_1998_03_20:1.50
	MLWorks_20m2_1998_02_16:1.49
	MLWorks_20m1_1997_10_23:1.47
	MLWorks_11r1:1.40.5.1.1.1.1
	MLWorks_workspace_97:1.46.2
	MLWorks_dt_wizard:1.46.1
	MLWorks_11c0_1997_09_09:1.40.5.1.1.1
	MLWorks_10r3:1.40.5.1.3
	MLWorks_10r2_551:1.40.5.1.2
	MLWorks_11:1.40.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.40.5.1
	MLWorks_20m0_1997_06_20:1.45
	MLWorks_1_0_r2c2_1997_06_14:1.40.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.40.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.40.5
	MLWorks_BugFix_1997_04_24:1.40
	MLWorks_1_0_r2_Win32_1997_04_11:1.40
	MLWorks_1_0_r2_Unix_1997_04_04:1.40
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.40.3.1.1
	MLWorks_gui_1996_12_18:1.40.4
	MLWorks_1_0_Win32_1996_12_17:1.40.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.40.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.40.1.1
	MLWorks_1_0_Irix_1996_11_28:1.40.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.40.2
	MLWorks_1_0_Unix_1996_11_14:1.40.1
	MLWorks_Open_Beta2_1996_10_11:1.38.2
	MLWorks_License_dev:1.38.1
	MLWorks_1_open_beta_1996_09_13:1.37.1
	MLWorks_Open_Beta_1996_08_22:1.37
	MLWorks_Beta_1996_07_02:1.35
	MLWorks_Beta_1996_06_07:1.35
	MLWorks_Beta_1996_06_06:1.35
	MLWorks_Beta_1996_06_05:1.35
	MLWorks_Beta_1996_06_03:1.35
	MLWorks_Beta_1996_05_31:1.35
	MLWorks_Beta_1996_05_30:1.35
	ML_beta_release_12/08/94:1.19
	ML_beta_release_03/08/94:1.19
	ML_revised_beta_release_25/05/94:1.19
	ML_final_beta_release_02/03/94:1.19
	mlworks-28-01-1994:1.19
	Release:1.18
	mlworks-beta-01-09-1993:1.18;
locks; strict;
comment	@ * @;


1.55
date	99.03.23.14.51.09;	author johnh;	state Exp;
branches
	1.55.1.1;
next	1.54;

1.54
date	98.08.17.09.28.50;	author jkbrook;	state Exp;
branches;
next	1.53;

1.53
date	98.07.09.14.01.27;	author johnh;	state Exp;
branches;
next	1.52;

1.52
date	98.06.17.11.23.37;	author jkbrook;	state Exp;
branches;
next	1.51;

1.51
date	98.04.06.15.49.17;	author jkbrook;	state Exp;
branches;
next	1.50;

1.50
date	98.02.19.10.48.15;	author mitchell;	state Exp;
branches;
next	1.49;

1.49
date	97.11.06.14.06.09;	author johnh;	state Exp;
branches;
next	1.48;

1.48
date	97.10.28.12.32.56;	author johnh;	state Exp;
branches;
next	1.47;

1.47
date	97.09.18.15.17.15;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	97.09.08.08.49.26;	author johnh;	state Exp;
branches
	1.46.1.1
	1.46.2.1;
next	1.45;

1.45
date	97.06.16.14.46.31;	author johnh;	state Exp;
branches;
next	1.44;

1.44
date	97.06.13.09.35.09;	author johnh;	state Exp;
branches;
next	1.43;

1.43
date	97.05.28.10.35.11;	author johnh;	state Exp;
branches;
next	1.42;

1.42
date	97.05.21.09.30.11;	author johnh;	state Exp;
branches;
next	1.41;

1.41
date	97.05.16.14.51.40;	author johnh;	state Exp;
branches;
next	1.40;

1.40
date	96.11.06.11.17.14;	author matthew;	state Exp;
branches
	1.40.1.1
	1.40.2.1
	1.40.3.1
	1.40.4.1
	1.40.5.1;
next	1.39;

1.39
date	96.10.30.19.49.08;	author io;	state Exp;
branches;
next	1.38;

1.38
date	96.09.19.12.12.44;	author johnh;	state Exp;
branches
	1.38.1.1
	1.38.2.1;
next	1.37;

1.37
date	96.08.09.15.25.32;	author nickb;	state Exp;
branches
	1.37.1.1;
next	1.36;

1.36
date	96.07.12.16.47.09;	author andreww;	state Exp;
branches;
next	1.35;

1.35
date	96.05.28.10.47.29;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	96.05.01.10.36.41;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	96.04.30.09.54.27;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	96.04.19.16.08.31;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	96.02.26.15.25.24;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	95.10.17.16.23.03;	author nickb;	state Exp;
branches;
next	1.29;

1.29
date	95.10.03.16.16.17;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	95.08.30.10.02.43;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	95.08.25.11.11.24;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	95.08.08.10.36.23;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	95.07.27.11.02.44;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	95.07.26.14.12.26;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	95.07.06.13.31.58;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	95.05.22.12.35.20;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	95.05.04.10.04.48;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	95.04.20.12.27.53;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.10.13.11.57.01;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	93.08.19.14.25.05;	author matthew;	state Exp;
branches
	1.18.1.1;
next	1.17;

1.17
date	93.08.11.10.08.42;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.08.10.13.02.16;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.07.29.15.09.38;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.05.19.13.03.06;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	93.05.13.14.19.13;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	93.05.12.13.41.00;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.05.11.11.14.56;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	93.05.05.11.13.23;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.04.30.13.29.56;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.04.19.15.14.45;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.04.16.14.23.24;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	93.04.14.12.10.28;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.04.05.14.53.22;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	93.03.31.12.27.54;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.03.26.18.48.19;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.23.14.22.09;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.17.16.32.33;	author matthew;	state Exp;
branches;
next	;

1.18.1.1
date	93.08.19.14.25.05;	author jont;	state Exp;
branches;
next	1.18.1.2;

1.18.1.2
date	93.10.12.17.20.39;	author daveb;	state Exp;
branches;
next	;

1.37.1.1
date	96.09.13.11.19.54;	author hope;	state Exp;
branches;
next	;

1.38.1.1
date	96.10.07.16.09.48;	author hope;	state Exp;
branches;
next	;

1.38.2.1
date	96.10.17.11.28.07;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	96.11.14.12.53.45;	author hope;	state Exp;
branches
	1.40.1.1.1.1;
next	;

1.40.1.1.1.1
date	96.11.28.15.04.42;	author hope;	state Exp;
branches;
next	;

1.40.2.1
date	96.11.22.18.12.40;	author hope;	state Exp;
branches;
next	;

1.40.3.1
date	96.12.17.17.51.09;	author hope;	state Exp;
branches
	1.40.3.1.1.1;
next	;

1.40.3.1.1.1
date	97.02.24.11.41.38;	author hope;	state Exp;
branches;
next	;

1.40.4.1
date	96.12.18.09.45.23;	author hope;	state Exp;
branches;
next	;

1.40.5.1
date	97.05.12.10.37.52;	author hope;	state Exp;
branches
	1.40.5.1.1.1
	1.40.5.1.2.1
	1.40.5.1.3.1;
next	;

1.40.5.1.1.1
date	97.07.28.18.22.59;	author daveb;	state Exp;
branches
	1.40.5.1.1.1.1.1;
next	;

1.40.5.1.1.1.1.1
date	97.10.07.11.48.43;	author jkbrook;	state Exp;
branches;
next	;

1.40.5.1.2.1
date	97.09.08.17.16.24;	author daveb;	state Exp;
branches;
next	;

1.40.5.1.3.1
date	97.09.09.14.12.23;	author daveb;	state Exp;
branches;
next	;

1.46.1.1
date	97.09.10.19.28.25;	author brucem;	state Exp;
branches;
next	;

1.46.2.1
date	97.09.11.20.58.21;	author daveb;	state Exp;
branches;
next	;

1.55.1.1
date	99.04.01.17.58.54;	author daveb;	state Exp;
branches;
next	;


desc
@Menu utilities
@


1.55
log
@[Bug #190536]
Change help menu - add splash advert and about info.
@
text
@(* Motif menu bar utilites *)
(*

$Log: _menus.sml,v $
 * Revision 1.54  1998/08/17  09:28:50  jkbrook
 * [Bug #30480]
 * Change case of HTML index pages
 *
 * Revision 1.53  1998/07/09  14:01:27  johnh
 * [Bug #30400]
 * remove main_windows arg from exit_dialog.
 *
 * Revision 1.52  1998/06/17  11:23:37  jkbrook
 * [Bug #30424]
 * Restore linking to doc
 *
 * Revision 1.51  1998/04/06  15:49:17  jkbrook
 * [Bug #50046]
 * Temporarily change HTML paths for Help menu
 *
 * Revision 1.50  1998/02/19  10:48:15  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.49  1997/11/06  14:06:09  johnh
 * [Bug #30125]
 * Add help menu.
 *
 * Revision 1.48  1997/10/28  12:32:56  johnh
 * [Bug #30059]
 * Add combo box OptionSpec type, although not implemented yet.
 * Also implement list boxes - both single and extended style.
 *
 * Revision 1.47  1997/09/18  15:17:15  daveb
 * [Bug #30077]
 * Explicitly set the labels of the buttons in the exit dialog, because
 * Solaris overrides the labels in MLWorks-mono.
 *
 * Revision 1.46  1997/09/08  08:49:26  johnh
 * [Bug #30241]
 * Implement proper find dialog.
 *
 * Revision 1.45  1997/06/16  14:46:31  johnh
 * [Bug #30174]
 * Moving stuff into platform specific podium.
 *
 * Revision 1.44  1997/06/13  09:35:09  johnh
 * [Bug #30175]
 * Changing dynamic menus implementation.
 *
 * Revision 1.43  1997/05/28  10:35:11  johnh
 * [Bug #30155]
 * Added get_graph_menuspec.
 *
 * Revision 1.42  1997/05/21  09:30:11  johnh
 * Implementing toolbar on Windows - added dummy function here.
 *
 * Revision 1.41  1997/05/16  14:51:40  johnh
 * Re-organising menus for Motif.
 *
 * Revision 1.40  1996/11/06  11:17:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.39  1996/10/30  19:49:08  io
 * moving String from toplevel
 *
 * Revision 1.38  1996/09/19  12:12:44  johnh
 * Bug #148.
 * Passed list of main windows to exit_dialog function so that they can
 * be killed.
 *
 * Revision 1.37  1996/08/09  15:25:32  nickb
 * Option dialog setter functions now return accept/reject.
 *
 * Revision 1.36  1996/07/12  16:47:09  andreww
 * Reset standard IO redirection mechanism to point to the terminal
 * after destroying GUI window.
 *
 * Revision 1.35  1996/05/28  10:47:29  matthew
 * Don't call update function with unchanged dialogs
 *
 * Revision 1.34  1996/05/01  10:36:41  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.33  1996/04/30  09:54:27  matthew
 * Use basis/integer
 *
 * Revision 1.32  1996/04/19  16:08:31  daveb
 * The activeFn argument to TOGGLE buttons was being ignored.  Fixed it.
 *
 * Revision 1.31  1996/02/26  15:25:24  matthew
 * Revisions to Xm library
 *
 * Revision 1.30  1995/10/17  16:23:03  nickb
 * Add sliders.
 *
 * Revision 1.29  1995/10/03  16:16:17  daveb
 * Made make_buttons return a set_focus function.
 *
 *  Revision 1.28  1995/08/30  10:02:43  matthew
 *  Removing OPTSUBMENU
 *
 *  Revision 1.27  1995/08/25  11:11:24  matthew
 *  Updating for Windows changes
 *
 *  Revision 1.26  1995/08/08  10:36:23  matthew
 *  Adding make_buttons function
 *
 *  Revision 1.25  1995/07/27  11:02:44  matthew
 *  Moved menus to gui
 *
 *  Revision 1.24  1995/07/26  14:12:26  matthew
 *  Restructuring directories
 *
 *  Revision 1.23  1995/07/06  13:31:58  matthew
 *  Changing the type of PUSHBUTTON callback type
 *
 *  Revision 1.22  1995/05/22  12:35:20  daveb
 *  Reinstated some lines commented out by the last change.
 *
 *  Revision 1.21  1995/05/04  10:04:48  matthew
 *  Fiddling about
 *  
 *  Revision 1.20  1995/04/20  12:27:53  matthew
 *  Moving set_sensitivity to motif_utils
 *  Added list managers
 *  New break/trace menu
 *  
 *  Revision 1.19  1993/10/13  11:57:01  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.18.1.2  1993/10/12  17:20:39  daveb
 *  Allowed negative numbers in OPTINT boxes.
 *  
 *  Revision 1.18.1.1  1993/08/19  14:25:05  jont
 *  Fork for bug fixing
 *  
 *  Revision 1.18  1993/08/19  14:25:05  matthew
 *  Added OPTSUBMENU to Option menu (a non-radio box submenu)
 *  
 *  Revision 1.17  1993/08/11  10:08:42  matthew
 *  Simplified interface.
 *  Return update function from create_dialog
 *  
 *  Revision 1.16  1993/08/10  13:02:16  matthew
 *  Bring options menu to front on managing
 *  
 *  Revision 1.15  1993/07/29  15:09:38  matthew
 *  Use modify verify callback to ensure digits in integer prompter
 *  
 *  Revision 1.14  1993/05/19  13:03:06  daveb
 *  Added the OPTRADIO constructor.
 *  
 *  Revision 1.13  1993/05/13  14:19:13  daveb
 *  create_dialog now takes a string to use for the title of the popup shell.
 *  
 *  Revision 1.12  1993/05/12  13:41:00  daveb
 *  Added comment about profligracy with callback ids in dynamic menus.
 *  
 *  Revision 1.11  1993/05/11  11:14:56  daveb
 *  Dynamic menus now create dummy submenus on startup.
 *  
 *  Revision 1.10  1993/05/05  11:13:23  matthew
 *  Added greying out of apply and reset buttons
 *  
 *  Revision 1.9  1993/04/30  13:29:56  matthew
 *  Added create_dialog_with_action.  This does something after a selection
 *  has been made.
 *  
 *  Revision 1.8  1993/04/19  15:14:45  matthew
 *  Added TOGGLE button class
 *  
 *  Revision 1.7  1993/04/16  14:23:24  daveb
 *  Added DYNAMIC menus.
 *  
 *  Revision 1.6  1993/04/14  12:10:28  matthew
 *  Made dialog boxes set to non-homogeneous
 *  ,
 *  
 *  Revision 1.5  1993/04/05  14:53:22  daveb
 *  Names of Callbacks have changed.
 *  
 *  Revision 1.4  1993/03/31  12:27:54  matthew
 *  Added OptionSpec type.  Simplified ButtonSpec and removed MenuSpec type
 *  Now separate functions for making an ordinary menu and an options menu
 *  
 *  Revision 1.3  1993/03/26  18:48:19  matthew
 *  Added create_dialog function
 *  Changed callback types
 *  
 *  Revision 1.2  1993/03/23  14:22:09  matthew
 *  Much changed
 *  Extended types of button specifications
 *  Uses gadgets instead of widgets
 *  Added updating functions
 *  Return "menu update function" rather than widget
 *  
 *  Revision 1.1  1993/03/17  16:32:33  matthew
 *  Initial revision
 *  
 *  
 *  Copyright (c) 1993 Harlequin Ltd.
 *  
 *)

require "../basis/__int";
require "^.basis.__char";
require "^.basis.__list";
require "../motif/xm";
require "../utils/lists";
require "../utils/getenv";
require "../main/version";

require "../gui/menus";


(* some utility functions for specifying menus *)

functor Menus (structure Xm : XM
               structure Lists : LISTS
	       structure Getenv : GETENV
	       structure Version : VERSION
                 ) : MENUS =
  struct

    type Widget = Xm.widget

    (* use a list of these to specify the top level menu *)
    datatype ButtonSpec =
        (* a separator widget *)
        SEPARATOR
      | LABEL of string
        (* fun 1 is a function to get initial value, fun 2 is callback function, fun 3 is a sensitive function *)
      | TOGGLE of string * (unit -> bool) * (bool -> unit) * (unit -> bool)
	(* name, min, max, callback *)
      |	SLIDER of string * int * int * (int -> unit)
        (* name and callback function and test sensitivity *)
      | PUSH of string * (unit -> unit) * (unit -> bool)
	(* name, get function, and callback function (set) and sensitive function*)
      | RADIO of string * (unit -> bool) * (bool -> unit) * (unit -> bool)
        (* cascade button and submenu specification *)
      | CASCADE of string * ButtonSpec list * (unit -> bool)
	(* cade button and function to create submenu specification *)
      | DYNAMIC of string * (unit -> ButtonSpec list) * (unit -> bool)


    datatype selection = SINGLE | EXTENDED

    (* First function is get the value for the widget
       second is set the value for the widget, and returns accept/reject *)
    datatype OptionSpec =
      OPTSEPARATOR |
      OPTLABEL of string |
      OPTTOGGLE of string * (unit -> bool) * (bool -> bool) |
      OPTTEXT of string * (unit -> string) * (string -> bool) |
      OPTINT of string * (unit -> int) * (int -> bool) |
      OPTRADIO of OptionSpec list |
      OPTCOMBO of string * (unit -> string * string list) * (string -> bool) |
      OPTLIST of string *
		 (unit -> string list * string list) * 
		 (string list -> bool) *
		 selection

    fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

    fun k x y = x

    fun set_sensitivity (widget,sensitivity) =
      Xm.Widget.valuesSet (widget,[(Xm.SENSITIVE, Xm.BOOL sensitivity)])

(* Taken from _capi.sml *)
    fun send_message (parent,message) =
      let
        val dialog =
          Xm.Widget.createPopupShell ("messageDialog",
                                    Xm.Widget.DIALOG_SHELL,
                                    parent, [])
            
        val widget =
          Xm.Widget.create
          ("message", Xm.Widget.MESSAGE_BOX, dialog,
           [(Xm.MESSAGE_STRING, 
	     Xm.COMPOUND_STRING (Xm.CompoundString.createLtoR (message, Xm.CHAR_SET "")))])

        val _ =
          map 
           (fn c =>
             Xm.Widget.unmanageChild (Xm.MessageBox.getChild(widget,c)))
           [Xm.Child.CANCEL_BUTTON,
            Xm.Child.HELP_BUTTON]

        (* This really ought to reuse dialogs *)
        fun exit _ = Xm.Widget.destroy dialog
      in
        Xm.Callback.add (widget, Xm.Callback.OK, exit);
        Xm.Widget.manage widget
      end

    fun set_focus w =
      (ignore(Xm.Widget.processTraversal (w, Xm.Widget.TRAVERSE_CURRENT));
       ())

    (* The get_sensitive function is used to get the sensitivity of all the menu
     * items below a CASCADE menu item, and this is in turn used to set the 
     * sensitivity of the CASCADE item. *)
    fun get_sensitive SEPARATOR = false
      | get_sensitive (LABEL _) = false
      | get_sensitive (PUSH (name, act, sens)) = sens()
      | get_sensitive (SLIDER _) = false
      | get_sensitive (RADIO _) = false
      | get_sensitive (TOGGLE (name, get, act, sens)) = sens()
      | get_sensitive (DYNAMIC (name, blist, sens)) = sens()
      | get_sensitive (CASCADE (name, items, sens)) = 
		foldl (fn (a,b) => (get_sensitive a) orelse b) false items

    (* make_button returns an update function and a set_focus function *)
    fun make_button (parent,SEPARATOR) =
      let
        val widget = Xm.Widget.createManaged ("separator",
                                              Xm.Widget.SEPARATOR_GADGET,
                                              parent,[])
      in
        (fn _ => (), fn () => set_focus widget)
      end

      | make_button (parent,LABEL name) =
      let
        val widget =
          Xm.Widget.createManaged (name,
                                   Xm.Widget.LABEL_GADGET,
                                   parent, [])
      in
        (fn _ => (), fn () => set_focus widget)
      end
      
      | make_button (parent,TOGGLE(name,get_value,set_value,activefn)) =
        let
          val widget =
            Xm.Widget.createManaged (name,
                                     Xm.Widget.TOGGLE_BUTTON_GADGET,
                                     parent,[])
          fun callback_fun data =
            let
              val (_,_,n) = Xm.Callback.convertToggleButton data
              val value = not (n = 0)
            in
              set_value value
            end

        in
          Xm.Callback.add (widget,
                                 Xm.Callback.VALUE_CHANGED,
                                 callback_fun);
          (fn _ =>
             (Xm.Widget.valuesSet (widget,[(Xm.SET,Xm.BOOL (get_value()))]);
              set_sensitivity (widget,activefn ())),
	   fn () => set_focus widget)
        end

      | make_button (parent, RADIO (name, get, set, activefn)) = 
        make_button (parent, TOGGLE(name, get, set, activefn))

      | make_button (parent, SLIDER (name,min,max, set_value)) = 
	let
	  val widget = 
	    Xm.Widget.createManaged (name,
				     Xm.Widget.SCALE,
				     parent,[(Xm.MINIMUM, Xm.INT min),
					     (Xm.MAXIMUM, Xm.INT max)])
	  fun callback_fun data  =
	    let val (_,_,n) = Xm.Callback.convertScale data
	    in set_value n
	    end
	in
	  Xm.Callback.add (widget,
				 Xm.Callback.VALUE_CHANGED,
				 callback_fun);
	  Xm.Callback.add (widget,
				 Xm.Callback.DRAG,
				 callback_fun);
	  (fn _ => (),
	   fn () => set_focus widget)
	end
      | make_button (parent,PUSH (name,callback,activefn)) =
        let
          val widget =
            Xm.Widget.createManaged (name,
                                    Xm.Widget.PUSH_BUTTON_GADGET,
                                     parent, [])
        in
          Xm.Callback.add (widget,
                                 Xm.Callback.ACTIVATE,
                                 fn _ => callback ());
          (fn _ => set_sensitivity (widget,activefn ()),
	   fn () => set_focus widget)
        end
      
      | make_button (parent,CASCADE (name,submenuspec,activefn)) =
        let
          val menu =
            Xm.Widget.createPulldownMenu (parent,
                                          name ^ "Menu",
                                          [])
          val {update, ...} = make_buttons (menu,submenuspec)
          val widget =
            Xm.Widget.createManaged (name,
                                     Xm.Widget.CASCADE_BUTTON_GADGET,
                                     parent,
                                     [(Xm.SUBMENU_ID, Xm.WIDGET menu)])

	  fun active_fn () = get_sensitive (CASCADE (name, submenuspec, activefn))
        in
          Xm.Callback.add (widget,
                                 Xm.Callback.CASCADING,
                                 fn _ => update());
          (fn _ => set_sensitivity (widget,active_fn ()),
	   fn () => set_focus widget)
        end

      | make_button (parent,DYNAMIC (name,submenuspecfn,activefn)) =
        let
          val widget =
            Xm.Widget.createManaged (name,
                                     Xm.Widget.CASCADE_BUTTON_GADGET,
                                     parent,[])

	  (* Make a dummy menu to set the cascade marker when appropriate. *)
          val menu =
            Xm.Widget.createPulldownMenu (parent,
                                          name ^ "Menu",
                                          [])

	  val _ = Xm.Widget.valuesSet (widget, [(Xm.SUBMENU_ID, Xm.WIDGET menu)])

          fun update_function _ =
	    (* NB. This is rather wasteful of callback ids. *)
	    let
              val menu =
                Xm.Widget.createPulldownMenu (parent,
                                              name ^ "Menu",
                                              [])

	      val {update, ...} = make_buttons (menu,submenuspecfn());
            in
	      update ();
              Xm.Widget.valuesSet (widget, [(Xm.SUBMENU_ID, Xm.WIDGET menu)])
            end
        in
          Xm.Callback.add (widget,
                                 Xm.Callback.CASCADING,
                                 update_function);
          (fn _ => set_sensitivity (widget,activefn ()),
	   fn () => set_focus widget)
        end

    (* main function *)
    and make_buttons (parent, menuspec) =
      let
        val res_list = 
	  (map (fn buttonspec => make_button (parent,buttonspec)) menuspec)
      in
        {update = fn () => app (fn (f, _) => f ()) res_list,
	 set_focus = fn n => (#2 (Lists.nth (n, res_list))) ()} (* should be changed to List.nth repercussions? *)
      end

    val personalAdRef = ref NONE
    val licensingRef = ref NONE

    fun mkPersonalAd parent = 
      let
	val advertDialog =
	  Xm.Widget.createPopupShell
	    ("advertDialog",
             Xm.Widget.DIALOG_SHELL,
             parent,
             [(Xm.TITLE, Xm.STRING "About MLWorks Professional Edition"),
	      (Xm.DELETE_RESPONSE, Xm.DELETE_RESPONSE_VALUE Xm.DO_NOTHING),
	      (Xm.ALLOW_SHELL_RESIZE, Xm.BOOL false)])

	val mainWindow =
          Xm.Widget.create ("mainform", Xm.Widget.FORM, advertDialog, [])

	val cast = MLWorks.Internal.Value.cast
	val read_pixmap : Widget * string -> Xm.drawable = env "x read pixmap file"

	val runtime = 
	  let val typed_name = CommandLine.name()
	  in
	    if OS.Path.isRelative(typed_name) then
	      OS.Path.concat [OS.FileSys.getDir(), typed_name]
	    else
	      typed_name
	  end
	val start_dir = OS.Path.dir (OS.Path.mkCanonical runtime)

	val file = OS.Path.concat [start_dir, "splash_advert.xpm"]
	val p = read_pixmap (mainWindow, file)

	val pixmap_ok = (p <> (cast 0))

	val bitmap_label = 
	  Xm.Widget.createManaged ("advertLabel", Xm.Widget.LABEL_GADGET, mainWindow, [])

	fun close _ = 
	  (personalAdRef := NONE;
	   Xm.Widget.destroy advertDialog)

	val closeButton = 
	  Xm.Widget.createManaged ("personalAdExit", Xm.Widget.ROW_COLUMN, mainWindow, [])
      in
	if (pixmap_ok) then 
	  (Xm.Widget.valuesSet (bitmap_label, 
				[(Xm.LABEL_TYPE, Xm.LABEL_TYPE_VALUE Xm.PIXMAP_LABEL),
				 (Xm.LABEL_PIXMAP, Xm.PIXMAP p)]);
	   Xm.Widget.manage mainWindow)
	else ();
	ignore (make_buttons (closeButton, [PUSH ("   Close   ", close, fn _ => true)]));
	personalAdRef := SOME advertDialog;
	advertDialog
      end

    fun mkLicensingDialog parent =
      let 
	val licensingDialog =
	  Xm.Widget.createPopupShell
	    ("licensingInfo",
             Xm.Widget.DIALOG_SHELL,
             parent,
             [(Xm.TITLE, Xm.STRING "MLWorks licensing information"),
	      (Xm.DELETE_RESPONSE, Xm.DELETE_RESPONSE_VALUE Xm.DO_NOTHING),
	      (Xm.ALLOW_SHELL_RESIZE, Xm.BOOL false)])

	val mainWindow =
          Xm.Widget.create ("mainform", Xm.Widget.FORM, licensingDialog, [])

        val licLabel1 =
          Xm.Widget.createManaged ("licLabel1", Xm.Widget.LABEL_GADGET, mainWindow, [])
        val licLabel2 =
          Xm.Widget.createManaged ("licLabel2", Xm.Widget.LABEL_GADGET, mainWindow, [])
        val licLabel3 =
          Xm.Widget.createManaged ("licLabel3", Xm.Widget.LABEL_GADGET, mainWindow, [])
        val licLabel4 =
          Xm.Widget.createManaged ("licLabel4", Xm.Widget.LABEL_GADGET, mainWindow, [])
        val licLabel5 =
          Xm.Widget.createManaged ("licLabel5", Xm.Widget.LABEL_GADGET, mainWindow, [])
        val licLabel6 =
          Xm.Widget.createManaged ("licLabel6", Xm.Widget.LABEL_GADGET, mainWindow, [])
        val licLabel7 =
          Xm.Widget.createManaged ("licLabel7", Xm.Widget.LABEL_GADGET, mainWindow, [])

	val closeButton = 
	  Xm.Widget.createManaged ("licensingExit", Xm.Widget.ROW_COLUMN, mainWindow, [])

	fun close _ = 
	  (licensingRef := NONE;
	   Xm.Widget.destroy licensingDialog)
      in
	ignore (make_buttons (closeButton, [PUSH ("   Close   ", close, fn _ => true)]));
	licensingRef := SOME licensingDialog;
	Xm.Widget.manage mainWindow;
	licensingDialog
      end


    (* make_buttons and make_submenus need to be separate for Windoze *)
    fun make_submenus (menuBar, menuSpec) =
      let 
        val menu =
          Xm.Widget.createPulldownMenu (menuBar, "HelpMenu", [])

        val help_menu =
          Xm.Widget.createManaged ("help_menu",
                                   Xm.Widget.CASCADE_BUTTON_GADGET,
                                   menuBar,
                                   [(Xm.SUBMENU_ID, Xm.WIDGET menu)])
	
	val open_web_location : string -> string = env "x open web location"

	val doc_path_opt = Getenv.get_doc_dir()
	val doc_path = getOpt(doc_path_opt, "")

	fun open_help_file path () = 
	  let val result_str = open_web_location (doc_path ^ path ^ "/INDEX.HTM")
	  in
	    if (result_str <> "") then send_message(menuBar, result_str) else ()
	  end

	fun personalAd () =
	  let
	    val w = if isSome(!personalAdRef) then valOf(!personalAdRef)
		    else mkPersonalAd (Xm.Widget.parent menuBar)
	  in
	    Xm.Widget.toFront w
	  end

	fun mlwLicensing () = 
	  let
	    val w = if isSome(!licensingRef) then valOf(!licensingRef)
		    else mkLicensingDialog (Xm.Widget.parent menuBar)
	  in
	    Xm.Widget.toFront w
	  end

	fun aboutMLW () = send_message (menuBar, Version.versionString())
	val isFree = Version.edition() = Version.PERSONAL
      in
	ignore(make_buttons (menu,
	    [PUSH ("HM_userGuide", 	  open_help_file "/guide/htm/unix",   fn _ => true),
	     PUSH ("HM_referenceMan", 	  open_help_file "/reference/htm",    fn _ => true),
	     PUSH ("HM_installationHelp", open_help_file "/install/htm/unix", fn _ => true),
	     PUSH ("HM_licenseHelp", 	  open_help_file "/lsd/htm", 	      fn _ => true),
	     PUSH ("HM_releaseNotes", 	  open_help_file "/relnotes/htm",     fn _ => true),
	     SEPARATOR] @@
	    (if isFree then 
	       [PUSH ("HM_personalAd", personalAd, fn _ => true)] 
	     else []) @@
	    [PUSH ("HM_mlwLicensing", mlwLicensing, fn _ => true),
	     PUSH ("HM_aboutMLW", aboutMLW, fn _ => true)]));
        Xm.Widget.valuesSet (menuBar, [(Xm.MENU_HELP_WIDGET, Xm.WIDGET help_menu)]);
	ignore(make_buttons (menuBar, menuSpec));
	()
      end

    fun make_menus (parent, menuSpec, isPodium) = make_submenus (parent, menuSpec)
    fun quit () = ()

    (* The dependency graph and the tools menu have different menu structures between
     * Motif and Windows - see the signature file for details.
     *)
    fun get_graph_menuspec (close, graph) = 
      [CASCADE ("action", [close], fn _ => true),
       CASCADE ("view", [graph], fn _ => true)]
    fun get_tools_menuspec (tools_buttons, update_fn) = 
      DYNAMIC ("tools", fn _ => (tools_buttons @@ [SEPARATOR] @@ update_fn()), k true)

    datatype ToolButton = TB_SEP | TB_TOGGLE | TB_PUSH | TB_GROUP | TB_TOGGLE_GROUP
    datatype ToolState = CHECKED | ENABLED | HIDDEN | GRAYED | PRESSED | WRAP
    datatype ToolButtonSpec = TOOLBUTTON of 
	{style:	ToolButton,
	 states: ToolState list,
	 tooltip_id: int,
	 name: string}

    fun make_toolbar (parent, bmp_id, tbSpec) = 
	Xm.Widget.create("dummy", Xm.Widget.SEPARATOR_GADGET, parent, [])

    fun make_option (parent,OPTSEPARATOR,select_fn) =
      let
        val widget = Xm.Widget.createManaged ("separator",
                                              Xm.Widget.SEPARATOR_GADGET,
                                              parent,[])
      in
        (fn _ => (),fn _ => ())
      end

      | make_option (parent,OPTLABEL name,select_fn) =
      let
        val widget =
          Xm.Widget.createManaged (name,
                                   Xm.Widget.LABEL_GADGET,
                                   parent, [])
      in
        (fn _ => (),fn _ => ())
      end
      
      | make_option (parent,OPTTOGGLE (name,get_value,set_value),select_fn) =
      let
        val widget =
          Xm.Widget.createManaged (name,
                                   Xm.Widget.TOGGLE_BUTTON_GADGET,
                                   parent, [])
	fun show () = Xm.Widget.valuesSet (widget,
					   [(Xm.SET,Xm.BOOL (get_value()))])
	fun set () = let
		       val xval = Xm.Widget.valuesGet (widget,[Xm.SET])
		       val settable =
			 case xval of
			   [Xm.BOOL b] => set_value b
			 | _ => false
		     in
		       if settable then () else
			 Xm.Display.bell (Xm.Widget.display parent, 0)
		     end
      in
        Xm.Callback.add(widget,Xm.Callback.VALUE_CHANGED,select_fn);
        (show, set)
      end

      | make_option (parent, OPTTEXT (name,get_value,set_value),select_fn) =
        let
          val frame =
            Xm.Widget.createManaged ("textInputFrame",
                                     Xm.Widget.ROW_COLUMN,
                                     parent,[])
          val text =
            Xm.Widget.createManaged ("textInput",
                                     Xm.Widget.TEXT,
                                     frame,[])
          val label =
            Xm.Widget.createManaged (name,
                                     Xm.Widget.LABEL,
                                     frame,[])
	  fun show () = Xm.Text.setString(text, get_value())
	  fun set () = let val settable = set_value (Xm.Text.getString text)
		       in if settable then () else
			 (Xm.Display.bell (Xm.Widget.display parent, 0);
			  show())
		       end
        in
          Xm.Callback.add(text,Xm.Callback.MODIFY_VERIFY,select_fn);
          (show,set)
        end

      | make_option (parent, OPTLIST (name, get_value, set_value, sel_type), select_fn) = 
	let
	  fun get_sel_pos _ [] = ~1
	    | get_sel_pos item ((s,pos)::rest) = 
		if item = s then pos
		else get_sel_pos item rest

	  fun sel_pos [] pos_items = []
	    | sel_pos (item::rest) pos_items = 
		let val pos = get_sel_pos item pos_items
		in
		  if pos <> ~1 then pos::(sel_pos rest pos_items)
		  else sel_pos rest pos_items
		end

          val listScroll = 
	    Xm.Widget.createManaged ("scroll", Xm.Widget.SCROLLED_WINDOW, parent,[])

	  val listbox = 
	    Xm.Widget.createManaged ("listbox", Xm.Widget.LIST, listScroll,
				     (if sel_type = EXTENDED then
					[(Xm.HEIGHT, Xm.INT 120),
					 (Xm.SELECTION_POLICY,
					  Xm.SELECTION_POLICY_VALUE Xm.EXTENDED_SELECT)]
				      else 
					[(Xm.HEIGHT, Xm.INT 80),
					 (Xm.SELECTION_POLICY,
					  Xm.SELECTION_POLICY_VALUE Xm.SINGLE_SELECT)]))

	  fun show () = 
	    let 
              val (items, sel_items) = get_value()
              val (pos_items, _) = Lists.number_from_by_one (items, 1, fn n => n)
	      val sel_positions = sel_pos sel_items pos_items
	    in
	      Xm.List.deleteAllItems listbox;
              Xm.List.addItems (listbox, map Xm.CompoundString.createSimple items, 0);
	      app (fn pos => Xm.List.selectPos (listbox, pos, false)) sel_positions;
	      ()
	    end

	  fun set () = 
	    let 

              val (items, sel_items) = get_value()
              val (pos_items, _) = Lists.number_from_by_one (items, 1, fn n => n)

	      val pos_vector = Xm.List.getSelectedPos listbox
	      val num_sel = MLWorks.Internal.Vector.length pos_vector
	      fun set_sel n = 
		if n = num_sel then []
		else MLWorks.Internal.Vector.sub (pos_vector, n) :: (set_sel (n+1))
	      val select_pos = set_sel 0

	      fun get_item_by_pos [] _ = ""
		| get_item_by_pos ((item, pos2)::rest) pos = 
		    if pos = pos2 then item else get_item_by_pos rest pos

	      val new_sel_items = map (get_item_by_pos pos_items) select_pos

	      val settable = set_value new_sel_items
	    in
	      if settable then () else
		(Xm.Display.bell (Xm.Widget.display parent, 0);
		 show())
	    end

	  val modify_callback = 
	    if sel_type = EXTENDED then 
	      Xm.Callback.EXTENDED_SELECTION 
	    else Xm.Callback.SINGLE_SELECTION
	in
	  Xm.Callback.add(listbox, modify_callback, select_fn);
          (show,set)
	end

      | make_option (parent, OPTCOMBO (name, get, set), select_fn) = 
	  make_option (parent, OPTLIST (name, 
					fn () => (#2(get()), [#1(get())]), 
					fn [] => false
					 | (a::rest) => set a,
					SINGLE), select_fn)

      | make_option (parent, OPTINT (name,get_value,set_value),select_fn) =
        let
          fun modifyVerify callback_data =
            let
              val (_,_,doit,_,_,start_pos,end_pos,str) =
                Xm.Callback.convertTextVerify callback_data


	      (* replace this when enough time *)
              val yesno =
		case explode str
		  of #"~" :: l => List.all Char.isDigit l
		|  l => List.all Char.isDigit l
	    (* replace this *)
		  

		  
            in
              Xm.Boolean.set (doit,yesno);
              if yesno then select_fn callback_data else ()
            end

          val frame =
            Xm.Widget.createManaged ("intInputFrame",
                                     Xm.Widget.ROW_COLUMN,
                                     parent,[])
          val text =
            Xm.Widget.createManaged ("intInput",
                                     Xm.Widget.TEXT,
                                     frame,[])
          val label =
            Xm.Widget.createManaged (name,
                                     Xm.Widget.LABEL,
				     frame,[])
	  fun show () = Xm.Text.setString(text,Int.toString(get_value()))
	  fun set () = let
			 val num = Int.fromString (Xm.Text.getString text)
			 val settable = 
			   (case num of
			      SOME n => set_value n
			    | NONE => false)
		       in
			 if settable then () else
			   (Xm.Display.bell (Xm.Widget.display parent, 0);
			    show())
		       end
        in
          Xm.Callback.add(text,Xm.Callback.MODIFY_VERIFY,modifyVerify);
          (show,set)
        end
      | make_option (parent, OPTRADIO (optionspec), select_fn) =
        let
          val frame =
            Xm.Widget.createManaged ("radioFrame",
                                     Xm.Widget.ROW_COLUMN,
                                     parent,
				     [(Xm.RADIO_BEHAVIOR, Xm.BOOL true),
				      (Xm.PACKING, Xm.PACKING_VALUE Xm.PACK_TIGHT)])
        in
	  (* Should possibly do something with select_fn, but it doesn't match
	     the type of the select_fn expected by make_options_with_select. *)
	  make_options_with_select' (frame, optionspec, select_fn)
        end
    and make_options_with_select' (parent, optionspec, select_fn) =
      let
        val functions =
	  map (fn spec => make_option(parent,spec,select_fn)) optionspec
      in
        (fn () => app (fn (f,g) => f()) functions,
         fn () => app (fn (f,g) => g()) functions)
      end
          
    and make_options_with_select (parent, optionspec, select_fn) =
       make_options_with_select' (parent, optionspec, fn _ => select_fn ())

    and make_options  (parent, optionspec) =
      make_options_with_select (parent,optionspec,fn () => ())

    fun create_dialog (parent,title,name,action,optionsspec) =
      let
        val shell = Xm.Widget.createPopupShell (name,
                                                Xm.Widget.DIALOG_SHELL,
                                                parent,
						[(Xm.TITLE, Xm.STRING title),
     						 (Xm.ICON_NAME, Xm.STRING title)])
        val form = Xm.Widget.create ("optionsForm",
                                     Xm.Widget.FORM,
                                     shell,[])
        val frame = Xm.Widget.createManaged (name,
                                             Xm.Widget.ROW_COLUMN,
                                             form,
                                             [])
        (* Hack to make all dialog boxes non-homogeneous *)
        (* else radio boxes with labels generate warnings *)
        val _ = Xm.Widget.valuesSet(frame,[(Xm.IS_HOMOGENEOUS,Xm.BOOL false)])
        val separator = Xm.Widget.createManaged ("separator",
                                                 Xm.Widget.SEPARATOR,
                                                 form,[])
        val dialogButtons = Xm.Widget.createManaged ("dialogButtons",
                                                     Xm.Widget.ROW_COLUMN,
                                                     form,
                                                     [])
        val values_selected = ref false
        val set_selected_hook = ref (fn () => ())
        fun set_selected () = (!set_selected_hook) ()
        fun selection_made () =
          if not (!values_selected)
            then
              (values_selected := true;
               set_selected ())
          else ()
        val (update_fn,apply_fn) = make_options_with_select (frame,optionsspec,selection_made)
        fun maybe_fn _ =
          if !values_selected then (apply_fn (); action ())
          else ()

        val {update = buttons_update_fn, ...} = 
          make_buttons
          (dialogButtons,
           [PUSH ("ok",
                  fn _ => (maybe_fn ();
                           Xm.Widget.unmanageChild form),
                  fn _ => true),
            PUSH ("apply",
                  fn _ => (apply_fn ();
                           values_selected := false;
                           set_selected();
                           action()),
                  fn _ => !values_selected),
            PUSH ("reset",
                  fn _ => (update_fn ();
                           values_selected := false;
                           set_selected()),
                  fn _ => !values_selected),
            PUSH ("cancel",
                  fn _ => Xm.Widget.unmanageChild form,
                  fn _ => true)])
      in
        set_selected_hook := buttons_update_fn;
        Xm.Widget.valuesSet (frame,
                             [(Xm.TOP_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.LEFT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RIGHT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BOTTOM_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BOTTOM_WIDGET, Xm.WIDGET separator)]);
        Xm.Widget.valuesSet (separator,
                             [(Xm.TOP_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LEFT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RIGHT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BOTTOM_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BOTTOM_WIDGET, Xm.WIDGET dialogButtons)]);
        Xm.Widget.valuesSet (dialogButtons,
                             [(Xm.TOP_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LEFT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RIGHT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BOTTOM_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM)]);

        (fn _ =>
         (update_fn ();
          values_selected := false;
          buttons_update_fn();
          Xm.Widget.manage form;
          Xm.Widget.map shell; (* Sometimes the window is unmapped on being popped down! *)
          Xm.Widget.toFront shell),
         fn _ =>
         (update_fn ();
          values_selected := false;
          buttons_update_fn()))
          
      end

    (* This function should only be called for the special purpose of quitting *)
    (* So I haven't put it in xm.sml *)
    local 
      fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
    in
      val quit_on_exit : unit -> unit = env "x quit on exit"
    end

    fun exit_dialog (parent,applicationShell,has_controlling_tty) =
      let
        val shell =
          Xm.Widget.createPopupShell ("quitDialog",
                                      Xm.Widget.DIALOG_SHELL,
                                      parent, [])

        (* To make life easy, we use a standard MessageBox widget and
         change the labels and actions around.  *)
        val message =
          Xm.Widget.create
          ("message", Xm.Widget.MESSAGE_BOX, shell,
           [])
                
        fun tty _ = (MLWorks.Internal.StandardIO.resetIO();
                     Xm.Widget.destroy applicationShell)
        fun exit _ = (quit_on_exit(); Xm.Widget.destroy applicationShell);
        fun cancel _ = Xm.Widget.destroy shell
      in
        if not has_controlling_tty then
          Xm.Widget.unmanageChild
          (Xm.MessageBox.getChild
           (message, Xm.Child.OK_BUTTON))
        else 
          ();
	Xm.Widget.valuesSet
          (Xm.MessageBox.getChild (message, Xm.Child.OK_BUTTON),
	   [(Xm.LABEL_STRING,
	     Xm.COMPOUND_STRING
	       (Xm.CompoundString.createSimple "End X Session"))]);
	Xm.Widget.valuesSet
          (Xm.MessageBox.getChild (message, Xm.Child.CANCEL_BUTTON),
	   [(Xm.LABEL_STRING, 
	     Xm.COMPOUND_STRING
	       (Xm.CompoundString.createSimple "Exit MLWorks"))]);
	Xm.Widget.valuesSet
          (Xm.MessageBox.getChild (message, Xm.Child.HELP_BUTTON),
	   [(Xm.LABEL_STRING, 
	     Xm.COMPOUND_STRING
	       (Xm.CompoundString.createSimple "Cancel"))]);
        Xm.Callback.add (message, Xm.Callback.OK, tty);
        Xm.Callback.add (message, Xm.Callback.HELP, cancel);
        Xm.Callback.add (message, Xm.Callback.CANCEL, exit);
        Xm.Widget.manage message
      end
  end
@


1.55.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a4 4
 * Revision 1.55  1999/03/23  14:51:09  johnh
 * [Bug #190536]
 * Change help menu - add splash advert and about info.
 *
@


1.54
log
@[Bug #30480]
Change case of HTML index pages
@
text
@d5 4
d216 2
d226 1
d268 2
d286 2
a287 1
           [(Xm.MESSAGE_STRING, Xm.COMPOUND_STRING (Xm.CompoundString.createSimple message))])
d470 99
a580 2
	fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

d592 18
d616 7
a622 2
	     SEPARATOR,	
	     PUSH ("HM_releaseNotes", 	  open_help_file "/relnotes/htm",     fn _ => true)]));
@


1.53
log
@[Bug #30400]
remove main_windows arg from exit_dialog.
@
text
@d5 4
d480 1
a480 1
	  let val result_str = open_web_location (doc_path ^ path ^ "/index.htm")
@


1.52
log
@[Bug #30424]
Restore linking to doc
@
text
@d5 4
d846 1
a846 1
    fun exit_dialog (parent,applicationShell,has_controlling_tty,main_windows) =
@


1.51
log
@[Bug #50046]
Temporarily change HTML paths for Help menu
@
text
@d5 4
d472 1
a472 1
	  let val result_str = open_web_location (path ^ "/index.htm")
d479 4
a482 4
	    [PUSH ("HM_userGuide", 	  open_help_file "documentation",   fn _ => true),
	     PUSH ("HM_referenceMan", 	  open_help_file "documentation",    fn _ => true),
	     PUSH ("HM_installationHelp", open_help_file "documentation", fn _ => true),
	     PUSH ("HM_licenseHelp", 	  open_help_file "documentation", 	      fn _ => true),
d484 1
a484 1
	     PUSH ("HM_releaseNotes", 	  open_help_file "documentation",     fn _ => true)]));
@


1.50
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d5 4
d468 1
a468 1
	  let val result_str = open_web_location (doc_path ^ path ^ "/index.htm")
d475 4
a478 4
	    [PUSH ("HM_userGuide", 	  open_help_file "/guide/htm/unix",   fn _ => true),
	     PUSH ("HM_referenceMan", 	  open_help_file "/reference/htm",    fn _ => true),
	     PUSH ("HM_installationHelp", open_help_file "/install/htm/unix", fn _ => true),
	     PUSH ("HM_licenseHelp", 	  open_help_file "/lsd/htm", 	      fn _ => true),
d480 1
a480 1
	     PUSH ("HM_releaseNotes", 	  open_help_file "/relnotes/htm",     fn _ => true)]));
@


1.49
log
@[Bug #30125]
Add help menu.
@
text
@d5 4
d278 1
a278 1
      (Xm.Widget.processTraversal (w, Xm.Widget.TRAVERSE_CURRENT);
d470 1
a470 1
	make_buttons (menu,
d476 1
a476 1
	     PUSH ("HM_releaseNotes", 	  open_help_file "/relnotes/htm",     fn _ => true)]);
d478 1
a478 1
	make_buttons (menuBar, menuSpec);
d609 1
a609 1
	      map (fn pos => Xm.List.selectPos (listbox, pos, false)) sel_positions;
@


1.48
log
@[Bug #30059]
Add combo box OptionSpec type, although not implemented yet.
Also implement list boxes - both single and extended style.
@
text
@d5 5
d191 1
d199 1
d246 27
d441 36
a476 2
    fun make_submenus args =
      (make_buttons args; ())
@


1.47
log
@[Bug #30077]
Explicitly set the labels of the buttons in the exit dialog, because
Solaris overrides the labels in MLWorks-mono.
@
text
@d5 5
d217 2
d227 6
a232 1
      OPTRADIO of OptionSpec list
d499 83
@


1.46
log
@[Bug #30241]
Implement proper find dialog.
@
text
@d5 4
d35 3
a37 2
 * Bug #148.
 * Passed list a of main Winwindows to exit_dialog function so that they can be killed.
d692 15
a711 1

@


1.46.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a4 4
 * Revision 1.46  1997/09/08  08:49:26  johnh
 * [Bug #30241]
 * Implement proper find dialog.
 *
@


1.46.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a4 4
 * Revision 1.46  1997/09/08  08:49:26  johnh
 * [Bug #30241]
 * Implement proper find dialog.
 *
@


1.45
log
@[Bug #30174]
Moving stuff into platform specific podium.
@
text
@d5 4
d199 2
d233 1
d282 3
@


1.44
log
@[Bug #30175]
Changing dynamic menus implementation.
@
text
@d5 4
a384 1
    val isMotif = true
a402 1
    val podium_buttons = []
@


1.43
log
@[Bug #30155]
Added get_graph_menuspec.
@
text
@d5 4
d207 2
d368 2
a369 4
        val res_list =
          (map
           (fn buttonspec => make_button (parent,buttonspec))
           menuspec)
d382 4
d389 2
@


1.42
log
@Implementing toolbar on Windows - added dummy function here.
@
text
@d5 3
d378 3
@


1.41
log
@Re-organising menus for Motif.
@
text
@d5 3
d375 12
@


1.40
log
@[Bug #1728]
__integer becomes __int
@
text
@d5 4
d204 12
d307 2
d313 1
a313 1
          (fn _ => set_sensitivity (widget,activefn ()),
d368 4
@


1.40.5.1
log
@branched from 1.40
@
text
@a4 4
 * Revision 1.40  1996/11/06  11:17:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a4 3
 * Revision 1.40.5.1  1997/05/12  10:37:52  hope
 * branched from 1.40
 *
@


1.40.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a4 3
 * Revision 1.40.5.1  1997/05/12  10:37:52  hope
 * branched from 1.40
 *
@


1.40.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a4 3
 * Revision 1.40.5.1  1997/05/12  10:37:52  hope
 * branched from 1.40
 *
@


1.40.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a4 3
 * Revision 1.40.5.1.1.1  1997/07/28  18:22:59  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.40.4.1
log
@branched from 1.40
@
text
@a4 4
 * Revision 1.40  1996/11/06  11:17:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.3.1
log
@branched from 1.40
@
text
@a4 4
 * Revision 1.40  1996/11/06  11:17:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.3.1.1.1
log
@branched from 1.40.3.1
@
text
@a4 3
 * Revision 1.40.3.1  1996/12/17  17:51:09  hope
 * branched from 1.40
 *
@


1.40.2.1
log
@branched from 1.40
@
text
@a4 4
 * Revision 1.40  1996/11/06  11:17:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.1.1
log
@branched from 1.40
@
text
@a4 4
 * Revision 1.40  1996/11/06  11:17:14  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.1.1.1.1
log
@branched from 1.40.1.1
@
text
@a4 3
 * Revision 1.40.1.1  1996/11/14  12:53:45  hope
 * branched from 1.40
 *
@


1.39
log
@moving String from toplevel
@
text
@d5 3
d149 1
a149 1
require "../basis/__integer";
@


1.38
log
@Bug #148.
Passed list a of main Winwindows to exit_dialog function so that they can be killed.
@
text
@d5 4
d147 2
a148 2
require "../basis/__general";

d151 1
a152 1
require "../gui/menus";
d340 2
a341 2
        {update = fn () => Lists.iterate (fn (f, _) => f ()) res_list,
	 set_focus = fn n => (#2 (Lists.nth (n, res_list))) ()}
a418 2
              fun digitp c =
                String.ord c >= String.ord "0" andalso String.ord c <= String.ord "9"
d421 3
a423 1
	      val chars = String.explode str
d425 7
a431 3
		case chars
		of "~" :: l => Lists.forall digitp l
		|  l => Lists.forall digitp l
d483 2
a484 2
        (fn () => Lists.iterate (fn (f,g) => f()) functions,
         fn () => Lists.iterate (fn (f,g) => g()) functions)
@


1.38.2.1
log
@branched from 1.38
@
text
@a4 4
 * Revision 1.38  1996/09/19  12:12:44  johnh
 * Bug #148.
 * Passed list a of main Winwindows to exit_dialog function so that they can be killed.
 *
@


1.38.1.1
log
@branched from 1.38
@
text
@a4 4
 * Revision 1.38  1996/09/19  12:12:44  johnh
 * Bug #148.
 * Passed list a of main Winwindows to exit_dialog function so that they can be killed.
 *
@


1.37
log
@Option dialog setter functions now return accept/reject.
@
text
@d5 3
d586 1
a586 1
    fun exit_dialog (parent,applicationShell,has_controlling_tty) =
@


1.37.1.1
log
@branched from 1.37
@
text
@a4 3
 * Revision 1.37  1996/08/09  15:25:32  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.36
log
@Reset standard IO redirection mechanism to point to the terminal
after destroying GUI window.
@
text
@d5 4
d174 1
a174 1
       second is set the value for the widget *)
d178 3
a180 3
      OPTTOGGLE of string * (unit -> bool) * (bool -> unit) |
      OPTTEXT of string * (unit -> string) * (string -> unit) |
      OPTINT of string * (unit -> int) * (int -> unit) |
d366 12
d380 1
a380 6
        (fn () => (Xm.Widget.valuesSet (widget,[(Xm.SET,Xm.BOOL (get_value()))])),
         fn () =>
         (case Xm.Widget.valuesGet (widget,[Xm.SET])
            of
              [Xm.BOOL b] => set_value b
            | _ => (MLWorks.IO.output(MLWorks.IO.std_out,"Bad callback value\n");())))
d397 6
d405 1
a405 2
          (fn () => (Xm.Text.setString(text,get_value())),
           fn () => (set_value (Xm.Text.getString text)))
d437 13
a449 1
                                     frame,[])
d452 1
a452 3
          (fn () => (Xm.Text.setString(text,Int.toString(get_value()))),
           fn () => (set_value (General.valOf (Int.fromString (Xm.Text.getString text)))
                     handle General.Option => ()))
@


1.35
log
@Don't call update function with unchanged dialogs
@
text
@d5 3
d571 2
a572 1
        fun tty _ = Xm.Widget.destroy applicationShell
@


1.34
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d5 6
d487 4
d495 1
a495 2
                  fn _ => (apply_fn ();
                           action ();
@


1.33
log
@Use basis/integer
@
text
@d5 3
d360 1
a360 1
            | _ => (output(std_out,"Bad callback value\n");())))
d388 1
a388 1
                ord c >= ord "0" andalso ord c <= ord "9"
d391 1
a391 1
	      val chars = explode str
@


1.32
log
@The activeFn argument to TOGGLE buttons was being ignored.  Fixed it.
@
text
@d5 3
d123 3
a127 1
require "../utils/integer";
a134 1
               structure Integer : INTEGER
d412 3
a414 2
          (fn () => (Xm.Text.setString(text,Integer.makestring(get_value()))),
           fn () => (set_value (Integer.parseinteger (Xm.Text.getString text))))
@


1.31
log
@Revisions to Xm library
@
text
@d5 3
d209 2
a210 1
             Xm.Widget.valuesSet (widget,[(Xm.SET,Xm.BOOL (get_value()))]),
@


1.30
log
@Add sliders.
@
text
@d5 3
d131 1
a131 1
    type Widget = Xm.Widget
d161 1
a161 1
      Xm.Widget.valuesSet (widget,[(Xm.Sensitive, Xm.BOOL sensitivity)])
d170 2
a171 2
        val widget = Xm.Widget.createManaged (Xm.Widget.NAME "separator",
                                              Xm.Widget.Class.SeparatorGadget,
d180 2
a181 2
          Xm.Widget.createManaged (Xm.Widget.NAME name,
                                   Xm.Widget.Class.LabelGadget,
d190 2
a191 2
            Xm.Widget.createManaged (Xm.Widget.NAME name,
                                     Xm.Widget.Class.ToggleButtonGadget,
d202 2
a203 2
          Xm.Widget.callbackAdd (widget,
                                 Xm.Callback.ValueChanged,
d206 1
a206 1
             Xm.Widget.valuesSet (widget,[(Xm.Set,Xm.BOOL (get_value()))]),
d213 4
a216 4
	    Xm.Widget.createManaged (Xm.Widget.NAME name,
				     Xm.Widget.Class.Scale,
				     parent,[(Xm.Minimum, Xm.INT min),
					     (Xm.Maximum, Xm.INT max)])
d222 2
a223 2
	  Xm.Widget.callbackAdd (widget,
				 Xm.Callback.ValueChanged,
d225 2
a226 2
	  Xm.Widget.callbackAdd (widget,
				 Xm.Callback.Drag,
d234 2
a235 2
            Xm.Widget.createManaged (Xm.Widget.NAME name,
                                     Xm.Widget.Class.PushButtonGadget,
d238 2
a239 2
          Xm.Widget.callbackAdd (widget,
                                 Xm.Callback.Activate,
d249 1
a249 1
                                          Xm.Widget.NAME (name ^ "Menu"),
d253 2
a254 2
            Xm.Widget.createManaged (Xm.Widget.NAME name,
                                     Xm.Widget.Class.CascadeButtonGadget,
d256 1
a256 1
                                     [(Xm.SubMenuId, Xm.WIDGET menu)])
d258 2
a259 2
          Xm.Widget.callbackAdd (widget,
                                 Xm.Callback.Cascading,
d268 2
a269 2
            Xm.Widget.createManaged (Xm.Widget.NAME name,
                                     Xm.Widget.Class.CascadeButtonGadget,
d275 1
a275 1
                                          Xm.Widget.NAME (name ^ "Menu"),
d278 1
a278 1
	  val _ = Xm.Widget.valuesSet (widget, [(Xm.SubMenuId, Xm.WIDGET menu)])
d285 1
a285 1
                                              Xm.Widget.NAME (name ^ "Menu"),
d291 1
a291 1
              Xm.Widget.valuesSet (widget, [(Xm.SubMenuId, Xm.WIDGET menu)])
d294 2
a295 2
          Xm.Widget.callbackAdd (widget,
                                 Xm.Callback.Cascading,
d319 2
a320 2
        val widget = Xm.Widget.createManaged (Xm.Widget.NAME "separator",
                                              Xm.Widget.Class.SeparatorGadget,
d329 2
a330 2
          Xm.Widget.createManaged (Xm.Widget.NAME name,
                                   Xm.Widget.Class.LabelGadget,
d339 2
a340 2
          Xm.Widget.createManaged (Xm.Widget.NAME name,
                                   Xm.Widget.Class.ToggleButtonGadget,
d343 2
a344 2
        Xm.Widget.callbackAdd(widget,Xm.Callback.ValueChanged,select_fn);
        (fn () => (Xm.Widget.valuesSet (widget,[(Xm.Set,Xm.BOOL (get_value()))])),
d346 1
a346 1
         (case Xm.Widget.valuesGet (widget,[Xm.Set])
d355 2
a356 2
            Xm.Widget.createManaged (Xm.Widget.NAME ("textInputFrame"),
                                     Xm.Widget.Class.RowColumn,
d359 2
a360 2
            Xm.Widget.createManaged (Xm.Widget.NAME ("textInput"),
                                     Xm.Widget.Class.Text,
d363 2
a364 2
            Xm.Widget.createManaged (Xm.Widget.NAME name,
                                     Xm.Widget.Class.Label,
d367 1
a367 1
          Xm.Widget.callbackAdd(text,Xm.Callback.ModifyVerify,select_fn);
d391 2
a392 2
            Xm.Widget.createManaged (Xm.Widget.NAME ("intInputFrame"),
                                     Xm.Widget.Class.RowColumn,
d395 2
a396 2
            Xm.Widget.createManaged (Xm.Widget.NAME ("intInput"),
                                     Xm.Widget.Class.Text,
d399 2
a400 2
            Xm.Widget.createManaged (Xm.Widget.NAME name,
                                     Xm.Widget.Class.Label,
d403 1
a403 1
          Xm.Widget.callbackAdd(text,Xm.Callback.ModifyVerify,modifyVerify);
d410 2
a411 2
            Xm.Widget.createManaged (Xm.Widget.NAME ("radioFrame"),
                                     Xm.Widget.Class.RowColumn,
d413 2
a414 2
				     [(Xm.RadioBehavior, Xm.BOOL true),
				      (Xm.Packing, Xm.PACKING Xm.PACK_TIGHT)])
d437 2
a438 2
        val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME name,
                                                Xm.Widget.Class.DialogShell,
d440 4
a443 4
						[(Xm.Title, Xm.STRING title),
     						 (Xm.IconName, Xm.STRING title)])
        val form = Xm.Widget.create (Xm.Widget.NAME "optionsForm",
                                     Xm.Widget.Class.Form,
d445 2
a446 2
        val frame = Xm.Widget.createManaged (Xm.Widget.NAME name,
                                             Xm.Widget.Class.RowColumn,
d451 3
a453 3
        val _ = Xm.Widget.valuesSet(frame,[(Xm.IsHomogeneous,Xm.BOOL false)])
        val separator = Xm.Widget.createManaged (Xm.Widget.NAME "separator",
                                                 Xm.Widget.Class.Separator,
d455 4
a458 4
        val dialogButtons = Xm.Widget.createManaged (Xm.Widget.NAME "dialogButtons",
                                                      Xm.Widget.Class.RowColumn,
                                                      form,
                                                      [])
d475 1
a475 1
                           Xm.Widget.unmanage form),
d489 1
a489 1
                  fn _ => Xm.Widget.unmanage form,
d494 5
a498 5
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BottomWidget, Xm.WIDGET separator)]);
d500 5
a504 5
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BottomWidget, Xm.WIDGET dialogButtons)]);
d506 4
a509 4
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
d536 2
a537 2
          Xm.Widget.createPopupShell (Xm.Widget.NAME "quitDialog",
                                      Xm.Widget.Class.DialogShell,
d544 1
a544 1
          (Xm.Widget.NAME "message", Xm.Widget.Class.MessageBox, shell,
d552 3
a554 3
          Xm.Widget.unmanage
          (Xm.Widget.messageBoxGetChild
           (message, Xm.Widget.Child.OK_BUTTON))
d557 3
a559 3
        Xm.Widget.callbackAdd (message, Xm.Callback.Ok, tty);
        Xm.Widget.callbackAdd (message, Xm.Callback.Help, cancel);
        Xm.Widget.callbackAdd (message, Xm.Callback.Cancel, exit);
@


1.29
log
@Made make_buttons return a set_focus function.
@
text
@d5 3
d137 2
d206 22
a227 1
              
@


1.28
log
@Removing OPTSUBMENU
@
text
@d5 2
a6 2
 * Revision 1.27  1995/08/25  11:11:24  matthew
 * Updating for Windows changes
d8 2
a9 2
 * Revision 1.26  1995/08/08  10:36:23  matthew
 * Adding make_buttons function
d11 2
a12 2
 * Revision 1.25  1995/07/27  11:02:44  matthew
 * Moved menus to gui
d14 5
a18 2
 * Revision 1.24  1995/07/26  14:12:26  matthew
 * Restructuring directories
d26 84
a109 84
Revision 1.21  1995/05/04  10:04:48  matthew
Fiddling about

Revision 1.20  1995/04/20  12:27:53  matthew
Moving set_sensitivity to motif_utils
Added list managers
New break/trace menu

Revision 1.19  1993/10/13  11:57:01  daveb
Merged in bug fix.

Revision 1.18.1.2  1993/10/12  17:20:39  daveb
Allowed negative numbers in OPTINT boxes.

Revision 1.18.1.1  1993/08/19  14:25:05  jont
Fork for bug fixing

Revision 1.18  1993/08/19  14:25:05  matthew
Added OPTSUBMENU to Option menu (a non-radio box submenu)

Revision 1.17  1993/08/11  10:08:42  matthew
Simplified interface.
Return update function from create_dialog

Revision 1.16  1993/08/10  13:02:16  matthew
Bring options menu to front on managing

Revision 1.15  1993/07/29  15:09:38  matthew
Use modify verify callback to ensure digits in integer prompter

Revision 1.14  1993/05/19  13:03:06  daveb
Added the OPTRADIO constructor.

Revision 1.13  1993/05/13  14:19:13  daveb
create_dialog now takes a string to use for the title of the popup shell.

Revision 1.12  1993/05/12  13:41:00  daveb
Added comment about profligracy with callback ids in dynamic menus.

Revision 1.11  1993/05/11  11:14:56  daveb
Dynamic menus now create dummy submenus on startup.

Revision 1.10  1993/05/05  11:13:23  matthew
Added greying out of apply and reset buttons

Revision 1.9  1993/04/30  13:29:56  matthew
Added create_dialog_with_action.  This does something after a selection
has been made.

Revision 1.8  1993/04/19  15:14:45  matthew
Added TOGGLE button class

Revision 1.7  1993/04/16  14:23:24  daveb
Added DYNAMIC menus.

Revision 1.6  1993/04/14  12:10:28  matthew
Made dialog boxes set to non-homogeneous
,

Revision 1.5  1993/04/05  14:53:22  daveb
Names of Callbacks have changed.

Revision 1.4  1993/03/31  12:27:54  matthew
Added OptionSpec type.  Simplified ButtonSpec and removed MenuSpec type
Now separate functions for making an ordinary menu and an options menu

Revision 1.3  1993/03/26  18:48:19  matthew
Added create_dialog function
Changed callback types

Revision 1.2  1993/03/23  14:22:09  matthew
Much changed
Extended types of button specifications
Uses gadgets instead of widgets
Added updating functions
Return "menu update function" rather than widget

Revision 1.1  1993/03/17  16:32:33  matthew
Initial revision


Copyright (c) 1993 Harlequin Ltd.

*)
d155 5
d166 1
a166 1
        fn _ => ()
d176 1
a176 1
        fn _ => ()
a178 1

d197 3
a199 2
          fn _ =>
          Xm.Widget.valuesSet (widget,[(Xm.Set,Xm.BOOL (get_value()))])
d212 2
a213 1
          fn _ => set_sensitivity (widget,activefn ())
d222 1
a222 1
          val update_function = make_buttons (menu,submenuspec)
d231 3
a233 2
                                 fn _ => update_function());
          fn _ => set_sensitivity (widget,activefn ())
d258 2
d261 1
a261 1
              make_buttons (menu,submenuspecfn()) ();
d268 2
a269 1
          fn _ => set_sensitivity (widget,activefn ())
d275 1
a275 1
        val updatefn_list =
d280 2
a281 1
        fn () => Lists.iterate (fn f => f ()) updatefn_list
d286 1
a286 2
      (make_buttons args;
       ())
d440 1
a440 1
        val buttons_update_fn = 
@


1.27
log
@Updating for Windows changes
@
text
@d5 3
d147 1
a147 2
      OPTRADIO of OptionSpec list |
      OPTSUBMENU of OptionSpec list
a377 13
      | make_option (parent, OPTSUBMENU (optionspec), select_fn) =
        let
          val frame =
            Xm.Widget.createManaged (Xm.Widget.NAME ("subMenuFrame"),
                                     Xm.Widget.Class.RowColumn,
                                     parent,
				     [(Xm.Packing, Xm.PACKING Xm.PACK_TIGHT)])
        in
	  (* Should possibly do something with select_fn, but it doesn't match
	     the type of the select_fn expected by make_options_with_select. *)
	  make_options_with_select' (frame, optionspec, select_fn)
        end

@


1.26
log
@Adding make_buttons function
@
text
@d5 3
d493 39
@


1.25
log
@Moved menus to gui
@
text
@d5 3
d208 1
a208 1
          val update_function = make_submenus (menu,submenuspec)
d244 1
a244 1
              make_submenus (menu,submenuspecfn()) ();
d255 1
a255 1
    and make_submenus (parent, menuspec) =
d265 5
d436 1
a436 1
          make_submenus
@


1.24
log
@Restructuring directories
@
text
@d5 3
d103 1
a103 1
require "../library/menus";
@


1.23
log
@Changing the type of PUSHBUTTON callback type
@
text
@d5 3
d96 1
a96 1
require "../library/xm";
d100 1
a100 1
require "menus";
@


1.22
log
@Reinstated some lines commented out by the last change.
@
text
@d5 3
d117 1
a117 1
      | PUSH of string * (MLWorks.Internal.Value.T -> unit) * (unit -> bool)
d189 1
a189 1
                                 callback);
@


1.21
log
@Fiddling about
@
text
@d5 3
a202 1
(*
a206 2
*)
          fn _ => ()
@


1.20
log
@Moving set_sensitivity to motif_utils
Added list managers
New break/trace menu
@
text
@d5 5
a188 4
          val widget =
            Xm.Widget.createManaged (Xm.Widget.NAME name,
                                     Xm.Widget.Class.CascadeButtonGadget,
                                     parent,[])
d194 5
d200 1
a200 1
          Xm.Widget.valuesSet (widget, [(Xm.SubMenuId, Xm.WIDGET menu)]);
d205 2
@


1.19
log
@Merged in bug fix.
@
text
@d5 3
d124 2
a125 6
    fun set_sensitivity (sensitivity,widget) =
      if sensitivity
        then
          Xm.Widget.valuesSet (widget,[(Xm.Sensitive, Xm.BOOL true)])
      else
        Xm.Widget.valuesSet (widget,[(Xm.Sensitive, Xm.BOOL false)])
d179 1
a179 1
          fn _ => set_sensitivity (activefn (),widget)
d198 1
a198 1
          fn _ => set_sensitivity (activefn (),widget)
d231 1
a231 1
          fn _ => set_sensitivity (activefn (),widget)
d451 1
d457 1
@


1.18
log
@Added OPTSUBMENU to Option menu (a non-radio box submenu)
@
text
@d5 9
d309 5
a313 1
              val yesno = Lists.forall digitp (explode str)
@


1.18.1.1
log
@Fork for bug fixing
@
text
@a4 3
Revision 1.18  1993/08/19  14:25:05  matthew
Added OPTSUBMENU to Option menu (a non-radio box submenu)

@


1.18.1.2
log
@Allowed negative numbers in OPTINT boxes.
@
text
@a4 3
Revision 1.18.1.1  1993/08/19  14:25:05  jont
Fork for bug fixing

d303 1
a303 5
	      val chars = explode str
              val yesno =
		case chars
		of "~" :: l => Lists.forall digitp l
		|  l => Lists.forall digitp l
@


1.17
log
@Simplified interface.
Return update function from create_dialog
@
text
@d5 4
d109 2
a110 1
      OPTRADIO of OptionSpec list
d331 12
@


1.16
log
@Bring options menu to front on managing
@
text
@d5 3
d347 1
a347 1
    fun create_dialog_with_action (parent,title,name,optionsspec,action) =
d427 6
a432 1
          Xm.Widget.toFront shell))
a433 3

    fun create_dialog (parent,title,name,options) =
      create_dialog_with_action (parent,title,name,options,fn () => ())
@


1.15
log
@Use modify verify callback to ensure digits in integer prompter
@
text
@d5 3
d423 2
a424 1
          Xm.Widget.manage form))
@


1.14
log
@Added the OPTRADIO constructor.
@
text
@d5 3
d283 12
d308 1
a308 1
          Xm.Widget.callbackAdd(text,Xm.Callback.ModifyVerify,select_fn);
@


1.13
log
@create_dialog now takes a string to use for the title of the popup shell.
@
text
@d5 3
d95 2
a96 1
      OPTINT of string * (unit -> int) * (int -> unit)
d297 13
d311 1
a311 1
    fun make_options_with_select (parent, optionspec, select_fn) =
d313 2
a314 1
        val functions = map (fn spec => make_option(parent,spec,fn _ => select_fn ())) optionspec
d320 4
a323 1
    fun make_options  (parent, optionspec) =
@


1.12
log
@Added comment about profligracy with callback ids in dynamic menus.
@
text
@d5 3
d305 1
a305 1
    fun create_dialog_with_action (parent,name,optionsspec,action) =
d307 1
a307 1
        val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME "optionsDialog",
d309 3
a311 1
                                                parent, [])
d387 2
a388 2
    fun create_dialog (parent,name,options) =
      create_dialog_with_action (parent,name,options,fn () => ())
@


1.11
log
@Dynamic menus now create dummy submenus on startup.
@
text
@d5 3
d188 1
@


1.10
log
@Added greying out of apply and reset buttons
@
text
@d5 3
d175 9
@


1.9
log
@Added create_dialog_with_action.  This does something after a selection
has been made.
@
text
@d5 4
d200 1
a200 1
    fun make_option (parent,OPTSEPARATOR) =
d209 1
a209 1
      | make_option (parent,OPTLABEL name) =
d219 1
a219 1
      | make_option (parent,OPTTOGGLE (name,get_value,set_value)) =
d226 1
d229 4
a232 4
         let val [Xm.BOOL b] = Xm.Widget.valuesGet (widget,[Xm.Set])
         in
           set_value b
         end)
d235 1
a235 1
      | make_option (parent, OPTTEXT (name,get_value,set_value)) =
d250 1
d255 1
a255 1
      | make_option (parent, OPTINT (name,get_value,set_value)) =
d270 1
d275 1
a275 1
    fun make_options (parent, optionspec) =
d277 1
a277 1
        val functions = map (fn spec => make_option(parent,spec)) optionspec
d283 2
d308 11
a318 2
        val (update_fn,apply_fn) = make_options (frame,optionsspec)
        val buttons_updatefn = 
d327 5
a331 2
                  fn _ => (apply_fn ();action()),
                  fn _ => true),
d333 4
a336 2
                  fn _ => update_fn (),
                  fn _ => true),
d341 1
d361 2
d366 2
a367 1
    fun create_dialog (parent,name,options) = create_dialog_with_action (parent,name,options,fn () => ())
@


1.8
log
@Added TOGGLE button class
@
text
@d5 3
d277 1
a277 1
    fun create_dialog (parent,name,optionsspec) =
d305 1
d309 1
a309 1
                  fn _ => apply_fn (),
d340 1
@


1.7
log
@Added DYNAMIC menus.
@
text
@d5 3
d59 2
d104 23
@


1.6
log
@Made dialog boxes set to non-homogeneous
,
@
text
@d5 4
d60 3
a98 15
(*
      | make_button (parent,ARROW (name,callback,activefn)) =
      let
        val widget =
          Xm.Widget.createManaged (Xm.Widget.NAME name,
                                   Xm.Widget.Class.ArrowButtonGadget,
                                   parent, [])
      in
        Xm.Widget.callbackAdd (widget,
                               Xm.Callback.Activate,
                               callback);
        fn _ => set_sensitivity (activefn (),widget)
      end
*)
      
d128 23
@


1.5
log
@Names of Callbacks have changed.
@
text
@d5 3
d243 3
@


1.4
log
@Added OptionSpec type.  Simplified ButtonSpec and removed MenuSpec type
Now separate functions for making an ordinary menu and an options menu
@
text
@d5 4
d98 1
a98 1
                               Xm.ActivateCallback,
d112 1
a112 1
                                 Xm.ActivateCallback,
d131 1
a131 1
                                 Xm.CascadingCallback,
@


1.3
log
@Added create_dialog function
Changed callback types
@
text
@d5 4
d26 2
d33 3
a35 1
               structure Lists : LISTS) : MENUS =
a37 5
(*
    datatype ActiveTest = ACTIVETEST of unit -> bool
    val always = ACTIVETEST (fn _ => true)
*)

d40 2
a41 4
    (* use one of these to specify the top level menu *)
    datatype MenuSpec =
      MENUSPEC of ButtonSpec list
    and ButtonSpec =
d45 1
a45 3
      | TOGGLE of string * (MLWorks.Internal.Value.T -> unit) * (unit -> bool) * (unit -> bool)
      | ARROW of string * (MLWorks.Internal.Value.T -> unit) * (unit -> bool)
        (* name and callback function *)
d48 10
a57 3
      | CASCADE of string * MenuSpec * (unit -> bool)
      | TEXT of string * (unit -> string) * (string -> unit)
      | INT of string * (unit -> int) * (int -> unit)
d85 1
a85 11
      | make_button (parent,TOGGLE (name,callback,activefn,get_value)) =
      let
        val widget =
          Xm.Widget.createManaged (Xm.Widget.NAME name,
                                   Xm.Widget.Class.ToggleButtonGadget,
                                   parent, [])
      in
        fn _ => (Xm.Widget.valuesSet (widget,[(Xm.Set,Xm.BOOL (get_value()))]);
                 set_sensitivity (activefn (),widget))
      end
      
d98 1
d132 46
a177 1
      | make_button (parent, TEXT (name,get_value,set_value)) =
d192 2
a193 5
          Xm.Widget.callbackAdd (text,
                                 Xm.ActivateCallback,
                                 fn _ => (set_value (Xm.Text.getString text)));
          fn () => ()
          (* Xm.Widget.set_string *)
d196 1
a196 1
      | make_button (parent, INT (name,get_value,set_value)) =
d211 2
a212 4
          Xm.Widget.callbackAdd (text,
                                 Xm.ActivateCallback,
                                 fn _ => ((* set_value (Xm.Text.getString text)*)));
          fn () => ()
d215 1
a215 2
    (* main function *)
    and make_submenus (parent,MENUSPEC menuspec) =
d217 1
a217 4
        val updatefn_list =
          (map
           (fn buttonspec => make_button (parent,buttonspec))
           menuspec)
d219 2
a220 1
        fn () => Lists.iterate (fn f => f ()) updatefn_list
d222 1
d224 1
a224 1
    fun create_dialog (parent,menuspec) =
d232 1
a232 1
        val frame = Xm.Widget.createManaged (Xm.Widget.NAME "optionsFrame",
d243 1
a243 1
        val options_updatefn = make_submenus (frame,menuspec)
a246 1
           MENUSPEC
d248 1
a248 1
                  fn _ => (output(std_out,"Doing OK action\n");
d252 2
a253 2
                  fn _ => (),
                  fn _ => false),
d255 2
a256 2
                  fn _ => (),
                  fn _ => false),
a260 1
        
d278 3
a280 1
        (form,options_updatefn)
@


1.2
log
@Much changed
Extended types of button specifications
Uses gadgets instead of widgets
Added updating functions
Return "menu update function" rather than widget
@
text
@d5 7
d44 2
a45 2
      | TOGGLE of string * (unit -> unit) * (unit -> bool) * (unit -> bool)
      | ARROW of string * (unit -> unit) * (unit -> bool)
d47 1
a47 1
      | PUSH of string * (unit -> unit) * (unit -> bool)
d152 1
a152 1
                                 fn () => (set_value (Xm.Text.getString text)));
d174 1
a174 1
                                 fn () => ((* set_value (Xm.Text.getString text)*)));
d189 58
a246 5
(*
    fun set_activity (menubar,menuspec) =
      (* use the information in the menuspec to determine activity of menu *)
      ()
*)
@


1.1
log
@Initial revision
@
text
@d5 2
d8 1
a18 3
(* there is a strange semi-bug that generates a warning about
 passive grabs on destroying the application *)

d36 3
d40 1
a40 1
      | SIMPLE of string * (unit -> unit)
d42 10
a51 1
      | CASCADE of string * MenuSpec
d54 30
a83 4
      Xm.Widget.createManaged (Xm.Widget.NAME "separator",
                               Xm.Widget.Class.Separator,
                               parent,[])
      | make_button (parent,SIMPLE(name,callback)) =
d87 1
a87 1
                                   Xm.Widget.Class.PushButton,
d93 1
a93 1
        widget
d96 14
a109 1
      | make_button (parent,CASCADE(name,submenuspec)) =
d113 1
a113 1
                                     Xm.Widget.Class.CascadeButton,
d116 1
a116 1
            Xm.Widget.createPulldownMenu (widget,
d119 1
d122 26
a147 2
          make_submenus (menu,submenuspec);
          widget
d150 21
d173 9
a181 4
      Lists.iterate
      (fn buttonspec => make_button (parent,buttonspec))
      menuspec
       
@
