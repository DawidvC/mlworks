head	1.8;
access;
symbols
	ML_beta_release_12/08/94:1.2
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.8
date	95.07.03.15.34.51;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.06.19.14.00.49;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.06.13.17.19.04;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.05.31.11.00.21;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.04.13.17.49.24;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.04.06.15.42.35;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	94.07.28.13.12.23;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	94.07.05.19.51.01;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.8
log
@Capification
@
text
@(*
 *  Copyright (c) 1993 Harlequin Ltd.
 *  $Log: _input.sml,v $
 *  Revision 1.7  1995/06/19  14:00:49  daveb
 *  Split this into two panes, one showing the previous input, one for
 *  typing new input.
 *  Also removed the menu bar, and checked for multiple calls (as this
 *  code is not re-entrant).
 *
 *  Revision 1.6  1995/06/13  17:19:04  daveb
 *  Added initial message to be sure that layout is done correctly.
 *
 *  Revision 1.5  1995/05/31  11:00:21  daveb
 *  Made contexts only visible if full_menus set.
 *  Combined the show_output and hide_output fields of the result into
 *  a single function of type bool->unit, for use with Toggle buttons.
 *
 *  Revision 1.4  1995/04/13  17:49:24  daveb
 *  Xm.doInput is back to taking unit.
 *  
 *  Revision 1.3  1995/04/06  15:42:35  daveb
 *  Type of Xm.doInput has changed.
 *  
 *  Revision 1.2  1994/07/28  13:12:23  daveb
 *  Removed twee message.
 *  
 *  Revision 1.1  1994/07/05  19:51:01  daveb
 *  new file
 *  
 *)

require "../utils/lists";
require "../library/capi";
require "menus";
require "motif_utils";

require "input";

functor InputWindow(
  structure Lists : LISTS
  structure Capi : CAPI
  structure Menus : MENUS
  structure MotifUtils : MOTIF_UTILS

  sharing type Menus.Widget = MotifUtils.Widget = Capi.Widget
) : INPUT_WINDOW =
struct

  type Widget = Capi.Widget

  val do_debug = false
  fun debug s =
    if do_debug then output(MLWorks.IO.terminal_out,s ^ "\n") else ()

  fun create (parent, title, applicationShell) =
    let
      val shell = Capi.make_toplevel_shell  ("inputShell",title ^ " Input",parent,[])
      val frame = Capi.make_managed_widget ("main", Capi.Form, shell, [])
      val no_input_message = "No input required."

      val promptLabel = Capi.make_managed_widget ("promptLabel", Capi.Label, frame,[])
      val _ = Capi.set_label_string (promptLabel, no_input_message)
      val panedWindow = Capi.make_managed_widget ("panedWindow", Capi.Pane, frame, [])
      val outputPane = Capi.make_managed_widget ("outputPane", Capi.Form, panedWindow, [])
      val outputLabel = Capi.make_managed_widget ("outputLabel", Capi.Label,outputPane, [])
      val (scrolloutput,textoutput) = Capi.make_scrolled_text("textoutput",outputPane, [])
      val inputPane = Capi.make_managed_widget ("inputPane", Capi.Form, panedWindow, [])
      val inputLabel = Capi.make_managed_widget	("inputLabel", Capi.Label, inputPane, [])
      val (scrollinput,textinput) = Capi.make_scrolled_text ("textinput",inputPane, [])
      val buttonPane =  Capi.make_managed_widget ("buttonPane", Capi.RowColumn, frame, [])
        
      val buttons_update_function_ref = ref (fn () => ())
      fun buttons_update_function () = (!buttons_update_function_ref) ()
      val send_enabled = ref false
      fun prompt n =
	let val message =
	      "Please input " ^ MLWorks.Integer.makestring n ^
 	      (if n = 1 then " character" else " characters");
	in
          send_enabled := true;
          buttons_update_function();
          Capi.set_label_string (promptLabel,message)
        end

      fun unprompt () =
        (send_enabled := false;
         buttons_update_function ();
         Capi.set_label_string (promptLabel,no_input_message))

      val quit_funs = ref []

      fun do_quit_funs _ =
	(Lists.iterate (fn f => f ()) (!quit_funs);
	 quit_funs := [])

      val input_visible_ref = ref false
        
      fun input_visible () = !input_visible_ref

      fun show_input b =
	(input_visible_ref := b;
	 if b then
	   (Capi.manage shell;
	    Capi.set_focus textinput;
            Capi.to_front shell)
	 else
	   (do_quit_funs();
	    Capi.unmanage shell))

      (* input_flag is true when the evaluation has prompted the user for
	 more input, and is set to false when the user clicks on the "send"
	 button (or the "eof" button). *)
      val input_flag = ref false;

      (* input_pos records how many characters have been read from the
	 input.  The insertion point of the output window is set to this
	 position, to indicate which characters in the buffer are unread. *)

      val input_pos = ref 0;

      fun send _ = input_flag := false;

      local 
        val posref = ref 0
        val strref = ref ""
            
        fun input_fun n =
          (input_flag := true;
	   prompt n;
	   show_input true;
           Capi.event_loop input_flag;
	   let
	     val str = Capi.Text.get_string textinput
	     val len = size str
	   in 
	     unprompt ();
             debug ("Input line is:" ^ str ^ ":");
	     Capi.Text.insert (textoutput, Capi.Text.get_last_position textoutput, str);
             Capi.Text.set_string (textinput, "");
	     str
           end)

        fun refill_buff n =
          let val new_string = input_fun n
          in
            posref := 0;
            strref := new_string
          end

        val eof_flag = ref false
      in
        fun get_input n =
          let
            val string = !strref
            val pointer = !posref
            val len = size string
	  in
	    if !input_flag then
	      (* Another call to get_input has already been made.
		 This call can only happen because we don't have a concurrent
		 environment.  Just return "" as a dummy value. *)
	      ""
	    else if !eof_flag then
              ""
            else if pointer + n > len then
	      (input_pos := (!input_pos + len - pointer);
	       refill_buff (n - len + pointer);
               String.substring (string,pointer,len-pointer)
               ^ get_input (n - len + pointer))
            else
              let val result = String.substring (string,pointer,n)
              in
                posref := (!posref + n);
	        input_pos := (!input_pos + n);
                Capi.Text.set_insertion_position (textoutput, !input_pos);
                result
              end
          end

        fun clear_input _ =
	  let
	    val str = Capi.Text.get_string textoutput
	    val len = size str
	    val new_str = String.substring (str, 0, !input_pos)
	  in
            debug "Clearing input";
	    Capi.Text.set_string (textoutput, new_str);
	    Capi.Text.set_insertion_position (textoutput, !input_pos);
            posref := 0;
            strref := "";
            eof_flag := false
	  end
          
        fun do_lookahead () =
          if !eof_flag then
             ""
          else if !posref >= size (!strref) then
             (refill_buff 1;
              do_lookahead ())
          else 
	    String.substring (!strref, !posref, 1)
               
        fun close_in _ = eof_flag := true

        fun closed_in () = !eof_flag
          
        fun clear_eof () = eof_flag := false
      end;

      val instream = 
        MLWorks.IO.instream
	  {input = get_input,
           lookahead = do_lookahead,
           end_of_stream = fn () => do_lookahead () = "",
           clear_eof = clear_eof,
           close_in = close_in,
           closed_in = closed_in}

      val buttonspec =
        [Menus.PUSH ("sendButton",
                     fn _ => (send ();
                              Capi.set_focus textinput),
                     fn _ => !send_enabled),
         Menus.PUSH ("eofButton",
                     fn _ => (close_in ();
                              send ();
                              Capi.set_focus textinput),
                     fn _ => !send_enabled),
         Menus.PUSH ("clearButton",
                     fn _ => (clear_input ();
                              Capi.set_focus textinput),
                     fn _ => true),
         Menus.PUSH ("dismissButton",
                     fn _ => (show_input false;
                              Capi.set_focus textinput),
                     fn _ => true)]
    in
      buttons_update_function_ref :=
      Menus.make_submenus (buttonPane,buttonspec);
      Capi.Layout.lay_out [Capi.Layout.OTHER promptLabel,
                           Capi.Layout.TEXT panedWindow,
                           Capi.Layout.OTHER buttonPane,
                           Capi.Layout.SPACE];
      Capi.Layout.lay_out [Capi.Layout.OTHER inputLabel,
                           Capi.Layout.OTHER scrollinput];
      Capi.Layout.lay_out [Capi.Layout.OTHER outputLabel,
                           Capi.Layout.OTHER scrolloutput];

      Capi.Callback.add (frame, 
                         Capi.Callback.Unmap,
                         fn _ => (input_visible_ref := false;
                                  do_quit_funs ()));
      Capi.Callback.add (shell, Capi.Callback.Destroy,do_quit_funs);
      Capi.manage textinput;
      Capi.manage textoutput;
      Capi.set_focus textinput;
      buttons_update_function ();
      {instream = instream, input_widget = shell,
       input_visible = input_visible, clear_input = clear_input,
       show_input = show_input}
    end
          
end;
@


1.7
log
@Split this into two panes, one showing the previous input, one for
typing new input.
Also removed the menu bar, and checked for multiple calls (as this
code is not re-entrant).
@
text
@d4 6
d33 1
a33 1
require "../library/xm";
d41 1
a41 1
  structure Xm : XM
d45 1
a45 1
  sharing type Xm.Widget = Menus.Widget = MotifUtils.Widget
d49 1
a49 1
  type Widget = Xm.Widget
d57 2
a58 12
      val shell =
        Xm.Widget.createPopupShell
  	  (Xm.Widget.NAME "inputShell",
           Xm.Widget.Class.TopLevelShell,
           parent,
           [(Xm.Title, Xm.STRING (title ^ " Input")),
            (Xm.IconName, Xm.STRING (title ^ " Input"))])

      val frame =
        Xm.Widget.createManaged
  	  (Xm.Widget.NAME "main", Xm.Widget.Class.Form, shell, [])

d61 14
a74 63
      val promptLabel =
  	Xm.Widget.createManaged
	  (Xm.Widget.NAME "promptLabel", Xm.Widget.Class.Label, frame,
           [(Xm.LabelString,
	     Xm.COMPOUNDSTRING
	       (Xm.CompoundString.createSimple no_input_message))])

      val separator =
        Xm.Widget.createManaged
 	  (Xm.Widget.NAME "seperator", Xm.Widget.Class.Separator, frame, [])

      val panedWindow =
        Xm.Widget.createManaged
 	  (Xm.Widget.NAME "panedWindow", Xm.Widget.Class.PanedWindow, frame, [])

      val outputPane =
        Xm.Widget.createManaged
          (Xm.Widget.NAME "outputPane", Xm.Widget.Class.Form, panedWindow, [])

      val outputLabel =
  	Xm.Widget.createManaged
	  (Xm.Widget.NAME "outputLabel", Xm.Widget.Class.Label, outputPane, [])

      val textoutput =
        Xm.Widget.createScrolledText
          (outputPane, Xm.Widget.NAME "textoutput", [])

      val inputPane =
        Xm.Widget.createManaged
          (Xm.Widget.NAME "inputPane", Xm.Widget.Class.Form, panedWindow, [])

      val inputLabel =
  	Xm.Widget.createManaged
	  (Xm.Widget.NAME "inputLabel", Xm.Widget.Class.Label, inputPane, [])

      val textinput =
        Xm.Widget.createScrolledText
          (inputPane, Xm.Widget.NAME "textinput", [])

      val buttonPane =
        Xm.Widget.createManaged
          (Xm.Widget.NAME "buttonPane", Xm.Widget.Class.RowColumn, frame, [])

      val sendButton =
        Xm.Widget.createManaged
          (Xm.Widget.NAME "sendButton", Xm.Widget.Class.PushButton,
           buttonPane, [])

      val eofButton =
        Xm.Widget.createManaged
          (Xm.Widget.NAME "eofButton", Xm.Widget.Class.PushButton,
           buttonPane, [])

      val clearButton =
        Xm.Widget.createManaged
          (Xm.Widget.NAME "clearButton", Xm.Widget.Class.PushButton,
           buttonPane, [])

      val dismissButton =
        Xm.Widget.createManaged
          (Xm.Widget.NAME "dismissButton", Xm.Widget.Class.PushButton,
           buttonPane, [])

d80 3
a82 7
          Xm.Widget.valuesSet (sendButton, [(Xm.Sensitive, Xm.BOOL true)]);
          Xm.Widget.valuesSet (eofButton, [(Xm.Sensitive, Xm.BOOL true)]);
          Xm.Widget.valuesSet
            (promptLabel,
             [(Xm.LabelString, 
               Xm.COMPOUNDSTRING
                 (Xm.CompoundString.createSimple message))])
d86 3
a88 7
        (Xm.Widget.valuesSet (sendButton, [(Xm.Sensitive, Xm.BOOL false)]);
         Xm.Widget.valuesSet (eofButton, [(Xm.Sensitive, Xm.BOOL false)]);
         Xm.Widget.valuesSet
           (promptLabel,
            [(Xm.LabelString, 
              Xm.COMPOUNDSTRING
                (Xm.CompoundString.createSimple no_input_message))]))
d103 3
a105 3
	   (Xm.Widget.map shell;
	    Xm.Widget.processTraversal (textinput, Xm.Widget.TRAVERSE_CURRENT);
            Xm.Widget.toFront shell)
d108 1
a108 1
	    Xm.Widget.unmap shell))
d118 1
d131 1
a131 1
           while (!input_flag) do Xm.doInput ();
d133 1
a133 1
	     val str = Xm.Text.getString textinput
d137 3
a139 4
             debug("Input line is:" ^ str ^ ":");
	     Xm.Text.insert
	       (textoutput, Xm.Text.getLastPosition textoutput, str);
	     Xm.Text.setString (textinput, "");
d175 1
a175 1
	        Xm.Text.setInsertionPosition (textoutput, !input_pos);
d182 1
a182 1
	    val str = Xm.Text.getString textoutput
d187 2
a188 2
	    Xm.Text.setString (textoutput, new_str);
	    Xm.Text.setInsertionPosition (textoutput, !input_pos);
d219 18
a236 1
      val sep_size = 10
d238 20
a257 107
      Xm.Widget.valuesSet
        (promptLabel,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.TopOffset, Xm.INT sep_size),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
      Xm.Widget.valuesSet
        (separator,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET promptLabel),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
      Xm.Widget.valuesSet
        (panedWindow,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET separator),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.BottomWidget, Xm.WIDGET buttonPane)]);
      Xm.Widget.valuesSet
        (buttonPane,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);

      Xm.Widget.valuesSet
        (inputLabel,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.TopOffset, Xm.INT sep_size),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
      Xm.Widget.valuesSet
        (Xm.Widget.parent textinput,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET inputLabel),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);

      Xm.Widget.valuesSet
        (outputLabel,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.TopOffset, Xm.INT sep_size),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
      Xm.Widget.valuesSet
        (Xm.Widget.parent textoutput,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET outputLabel),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);

      Xm.Widget.callbackAdd
	(sendButton, Xm.Callback.Activate,
	 fn _ => (send ();
	          Xm.Widget.processTraversal
	            (textinput, Xm.Widget.TRAVERSE_CURRENT);
		  ()));
      Xm.Widget.callbackAdd
	(eofButton, Xm.Callback.Activate,
	 fn _ => (close_in ();
                  send ();
	          Xm.Widget.processTraversal
	            (textinput, Xm.Widget.TRAVERSE_CURRENT);
		  ()));
      Xm.Widget.callbackAdd
	(clearButton, Xm.Callback.Activate,
	 fn _ => (clear_input ();
	          Xm.Widget.processTraversal
	            (textinput, Xm.Widget.TRAVERSE_CURRENT);
		  ()));
      Xm.Widget.callbackAdd
	(dismissButton, Xm.Callback.Activate,
	 fn _ => (show_input false;
	          Xm.Widget.processTraversal
	            (textinput, Xm.Widget.TRAVERSE_CURRENT);
		  ()));
      Xm.Widget.callbackAdd (frame, Xm.Callback.Unmap,
			     fn _ => (input_visible_ref := false;
			       	      do_quit_funs ()));
      Xm.Widget.callbackAdd (shell, Xm.Callback.Destroy,do_quit_funs);
      Xm.Widget.manage textinput;
      Xm.Widget.manage textoutput;
      Xm.Widget.processTraversal (textinput, Xm.Widget.TRAVERSE_CURRENT);
      Xm.Widget.valuesSet (sendButton, [(Xm.Sensitive, Xm.BOOL false)]);
      Xm.Widget.valuesSet (eofButton, [(Xm.Sensitive, Xm.BOOL false)]);
@


1.6
log
@Added initial message to be sure that layout is done correctly.
@
text
@d4 3
a62 9
      val menuBar =
        Xm.Widget.createManaged
	  (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, frame,
	   [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)
           ])

d72 29
a100 1
      val text =
d102 1
a102 7
          (frame, Xm.Widget.NAME "textIO",
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)
           ])
d123 5
d165 1
d177 2
a178 3
	 input since the last clear_input.  Calls to input_fun ignore
	 characters that have been read, and these characters may not be
	 deleted or modified in the input window. *)
a180 14
      fun input_fun n =
        (input_flag := true;
	 prompt n;
	 show_input true;
         while (!input_flag) do Xm.doInput ();
	 let
	   val str = Xm.Text.getString text
	   val len = size str
	 in 
	   unprompt ();
           debug("Input line is:" ^ str ^ ":");
	   MLWorks.String.substring (str, !input_pos, len - !input_pos)
         end)

d187 17
d219 6
a224 1
            if !eof_flag then
d228 3
a230 3
               refill_buff (n - len + pointer);
               String.substring (string,pointer,len-pointer) ^
               get_input (n - len + pointer))
d235 2
a236 1
		input_pos := (!input_pos + n);
d242 12
a253 6
          (debug "Clearing input";
	   input_pos := 0;
	   Xm.Text.setString (text, "");
           posref := 0;
           strref := "";
           eof_flag := false)
d256 1
a256 1
          (if !eof_flag then
a259 1
	      input_pos := (!input_pos + 1);
d262 1
a262 1
            String.substring (!strref, !posref, 1))
a279 23
      fun modifyVerify callback_data =
        let
          val (_,event,doit,_,_,start_pos,end_pos,str) =
            Xm.Callback.convertTextVerify callback_data
        in
          debug
 	    ("Verify: start_pos is " ^ MLWorks.Integer.makestring start_pos ^
             ", end_pos is " ^ MLWorks.Integer.makestring end_pos ^
             ", input_pos is " ^ MLWorks.Integer.makestring (!input_pos) ^
             ", string is '" ^ str ^ "'");
	  if start_pos < !input_pos then
	    (MotifUtils.beep shell;
	     Xm.Boolean.set (doit, false))
	  else
	    Xm.Boolean.set (doit, true)
        end

      val menuspec =
        [Menus.CASCADE
	   ("window",
            [Menus.PUSH ("close", fn _ => show_input false, fn _ => true)],
            fn _ => true)]

a281 1
      Menus.make_submenus (menuBar,menuspec);
d283 1
a283 1
        (menuBar,
d285 1
d288 9
d299 1
a299 1
        (promptLabel,
d301 18
a318 1
          (Xm.TopWidget, Xm.WIDGET menuBar),
d326 1
a326 1
        (Xm.Widget.parent text,
d328 10
a337 1
          (Xm.TopWidget, Xm.WIDGET promptLabel),
d343 1
a343 3
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.BottomOffset, Xm.INT sep_size),
          (Xm.BottomWidget, Xm.WIDGET buttonPane)]);
d345 3
a347 2
        (buttonPane,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
a351 1
          (Xm.RightOffset, Xm.INT sep_size),
d354 1
d359 1
a359 1
	            (text, Xm.Widget.TRAVERSE_CURRENT);
d366 1
a366 1
	            (text, Xm.Widget.TRAVERSE_CURRENT);
d372 7
a378 1
	            (text, Xm.Widget.TRAVERSE_CURRENT);
a382 1
      Xm.Widget.callbackAdd (text, Xm.Callback.ModifyVerify, modifyVerify);
d384 5
a388 1
      Xm.Widget.manage text;
@


1.5
log
@Made contexts only visible if full_menus set.
Combined the show_output and hide_output fields of the result into
a single function of type bool->unit, for use with Toggle buttons.
@
text
@d4 5
d69 2
d75 2
a76 1
	     Xm.COMPOUNDSTRING (Xm.CompoundString.createSimple ""))])
d122 7
a128 10
	let val message = "No input required."
	in
          Xm.Widget.valuesSet (sendButton, [(Xm.Sensitive, Xm.BOOL false)]);
          Xm.Widget.valuesSet (eofButton, [(Xm.Sensitive, Xm.BOOL false)]);
          Xm.Widget.valuesSet
            (promptLabel,
             [(Xm.LabelString, 
               Xm.COMPOUNDSTRING
                 (Xm.CompoundString.createSimple message))])
        end
@


1.4
log
@Xm.doInput is back to taking unit.
@
text
@d2 14
a15 12
 * Copyright (c) 1993 Harlequin Ltd.
 * $Log: _input.sml,v $
# Revision 1.3  1995/04/06  15:42:35  daveb
# Type of Xm.doInput has changed.
#
# Revision 1.2  1994/07/28  13:12:23  daveb
# Removed twee message.
#
# Revision 1.1  1994/07/05  19:51:01  daveb
# new file
#
 *
d133 1
a133 1
      fun input_visible _ = !input_visible_ref
d135 8
a142 9
      fun hide_input _ =
	(input_visible_ref := false;
         do_quit_funs();
         Xm.Widget.unmap shell)

      fun show_input _ =
	(input_visible_ref := true;
         Xm.Widget.map shell;
         Xm.Widget.toFront shell)
d158 1
a158 1
	 show_input ();
d260 1
a260 1
            [Menus.PUSH ("close", hide_input, fn _ => true)],
d331 1
a331 1
       show_input = show_input, hide_input = hide_input}
@


1.3
log
@Type of Xm.doInput has changed.
@
text
@d4 3
d158 1
a158 1
         while (!input_flag) do Xm.doInput applicationShell;
@


1.2
log
@Removed twee message.
@
text
@d4 3
d36 1
a36 1
  fun create (parent, title) =
d155 1
a155 1
         while (!input_flag) do Xm.doInput ();
@


1.1
log
@new file
@
text
@d3 4
a6 1
 * $Log$
d106 1
a106 1
	let val message = "Thank you.  Have a nice day."
@
