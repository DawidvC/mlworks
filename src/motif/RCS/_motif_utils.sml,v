head	1.66;
access;
symbols
	ML_beta_release_12/08/94:1.41
	ML_beta_release_03/08/94:1.41
	ML_revised_beta_release_25/05/94:1.38
	ML_final_beta_release_02/03/94:1.36
	mlworks-28-01-1994:1.35
	Release:1.24
	mlworks-beta-01-09-1993:1.24;
locks; strict;
comment	@ * @;


1.66
date	95.07.17.12.40.56;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	95.07.13.14.12.11;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	95.07.04.15.58.39;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	95.06.30.16.22.09;	author daveb;	state Exp;
branches;
next	1.62;

1.62
date	95.06.20.12.39.25;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	95.06.14.14.09.39;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	95.06.13.14.30.05;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	95.06.05.13.20.48;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	95.06.01.10.44.27;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	95.05.23.14.07.27;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	95.05.22.18.27.13;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	95.05.15.15.03.21;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	95.05.01.15.40.29;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	95.04.28.12.39.32;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	95.04.24.15.54.06;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	95.04.24.14.50.38;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	95.04.20.12.30.16;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	95.04.19.10.20.42;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	95.03.30.18.01.52;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	95.03.16.18.27.05;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	95.03.13.21.31.22;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	95.03.10.15.20.59;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	94.11.30.16.43.35;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	94.09.26.09.42.44;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	94.09.21.16.11.38;	author brianm;	state Exp;
branches;
next	1.41;

1.41
date	94.08.02.10.57.14;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	94.07.27.12.57.56;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	94.06.20.11.13.34;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	94.05.06.10.22.01;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	94.04.06.11.50.58;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	94.02.22.00.50.13;	author nosa;	state Exp;
branches;
next	1.35;

1.35
date	93.12.17.18.15.49;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.12.10.16.57.25;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	93.12.01.16.15.33;	author io;	state Exp;
branches;
next	1.32;

1.32
date	93.12.01.15.33.57;	author io;	state Exp;
branches;
next	1.31;

1.31
date	93.11.29.13.20.35;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	93.11.18.11.50.06;	author nickh;	state Exp;
branches;
next	1.29;

1.29
date	93.11.08.16.08.35;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	93.10.13.11.58.38;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	93.10.08.16.43.29;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.09.17.14.05.13;	author nosa;	state Exp;
branches;
next	1.25;

1.25
date	93.09.13.09.16.33;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	93.08.24.12.16.17;	author matthew;	state Exp;
branches
	1.24.1.1;
next	1.23;

1.23
date	93.08.19.17.25.43;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	93.08.11.11.01.50;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.08.09.16.21.53;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.08.05.11.52.42;	author nosa;	state Exp;
branches;
next	1.19;

1.19
date	93.08.04.09.09.19;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.07.29.14.55.37;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.06.10.16.02.42;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.06.03.16.54.53;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	93.05.28.15.52.21;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.05.27.16.19.19;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.05.19.13.58.19;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	93.05.13.18.44.15;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.05.13.14.26.19;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	93.05.12.13.59.13;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	93.05.06.13.40.45;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	93.05.04.16.59.24;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.04.30.15.53.35;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	93.04.28.12.10.42;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	93.04.28.10.05.53;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	93.04.27.12.48.50;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	93.04.23.15.11.21;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.04.21.15.51.07;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	93.04.21.14.40.52;	author daveb;	state Exp;
branches;
next	;

1.24.1.1
date	93.08.24.12.16.17;	author jont;	state Exp;
branches;
next	1.24.1.2;

1.24.1.2
date	93.09.10.11.12.21;	author daveb;	state Exp;
branches;
next	1.24.1.3;

1.24.1.3
date	93.10.08.10.29.28;	author matthew;	state Exp;
branches;
next	1.24.1.4;

1.24.1.4
date	93.10.12.14.41.15;	author daveb;	state Exp;
branches;
next	;


desc
@Motif utility functions.
@


1.66
log
@Correcting layout of list_select pane
@
text
@(* Copyright (c) 1993 Harlequin Ltd.
 *
 * $Log: _motif_utils.sml,v $
 *  Revision 1.65  1995/07/13  14:12:11  matthew
 *  Adding some debugger utilities
 *
 *  Revision 1.64  1995/07/04  15:58:39  matthew
 *  Capification
 *
 *  Revision 1.63  1995/06/30  16:22:09  daveb
 *  Added float_precision option to ValuePrinter options.
 *
 *  Revision 1.62  1995/06/20  12:39:25  daveb
 *  Added variable info mode.
 *
 *  Revision 1.61  1995/06/14  14:09:39  daveb
 *  ShellUtils.edit_* functions no longer require a context argument.
 *  Added entries for new preferences to setup_menu.
 *
 *  Revision 1.60  1995/06/13  14:30:05  daveb
 *  Removed show_id_class and show_eq_info value printer options from interface.
 *
 *  Revision 1.59  1995/06/05  13:20:48  daveb
 *  Added NO_SENSE_SELECTION option for Sensitivity type.
 *
 *  Revision 1.58  1995/06/01  10:44:27  daveb
 *  Added new type MotifContext, which combines a user_context with
 *  dialog boxes for context-specific options.  Changed context_menu to
 *  incorporate entries for popping up the options dialogs for the current
 *  context.  Put the remaining options dialogs, for tool-specific options,
 *  in the view_options function, which returns items for use in "view"
 *  menus.
 *
 *  Revision 1.57  1995/05/23  14:07:27  matthew
 *  Changing interface to list_select.
 *
 *  Revision 1.56  1995/05/22  18:27:13  daveb
 *  Removed erroneous call to debug_output
 *
 *  Revision 1.55  1995/05/15  15:03:21  matthew
 *  Renaming nj_semicolons
 *
 *  Revision 1.54  1995/05/01  15:40:29  matthew
 *  Removing exception EditObject
 *
 *  Revision 1.53  1995/04/28  12:39:32  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.52  1995/04/24  15:54:06  daveb
 *  Removed stepper option, commented out poly_variable and moduler options.
 *  Also commented out default_overloads option.
 *
 *  Revision 1.51  1995/04/24  14:50:38  matthew
 *  Refinements to list manager widgets
 *
 *  Revision 1.50  1995/04/20  12:30:16  matthew
 *  Added list managers
 *  New break/trace menu
 *
 *  Revision 1.49  1995/04/19  10:20:42  daveb
 *  Added rename option to context menu.
 *
 *  Revision 1.48  1995/03/30  18:01:52  daveb
 *  Made make_scrolllist handle empty lists specially.
 *
 *  Revision 1.47  1995/03/16  18:27:05  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 *
 *  Revision 1.46  1995/03/13  21:31:22  daveb
 *  Added support for propagating changes of context.
 *
 *  Revision 1.45  1995/03/10  15:20:59  daveb
 *  Added support for selections to the options menu.
 *
 *  Revision 1.44  1994/11/30  16:43:35  daveb
 *  Ensured that if full_menus is false, only the required menus and
 *  dialogs are created.
 *
 *  Revision 1.43  1994/09/26  09:42:44  matthew
 *  Change to Basis.lookup_val
 *
 *  Revision 1.42  1994/09/21  16:11:38  brianm
 *  Adding value menu implementation ...
 *
 *  Revision 1.41  1994/08/02  10:57:14  daveb
 *  Revised editor preference dialog.
 *
 *  Revision 1.40  1994/07/27  12:57:56  daveb
 *  Cut down menus for novices.
 *
 *  Revision 1.39  1994/06/20  11:13:34  daveb
 *  Replaced ContextRef with user_context.
 *
 *  Revision 1.38  1994/05/06  10:22:01  daveb
 *  Added default_overloads option.
 *
 *  Revision 1.37  1994/04/06  11:50:58  daveb
 *  Added breakpoints menu.
 *
 *  Revision 1.36  1994/02/22  00:50:13  nosa
 *  Step and Modules Debugger compiler options.
 *
 *  Revision 1.35  1993/12/17  18:15:49  matthew
 *  Added maximum_str_depth to options.
 *
 *  Revision 1.34  1993/12/10  16:57:25  daveb
 *  Added context_menu function.
 *
 *  Revision 1.33  1993/12/01  16:15:33  io
 *  *** empty log message ***
 *
 *  Revision 1.32  1993/12/01  15:33:57  io
 *  Added max_num_errors
 *
 *  Revision 1.31  1993/11/29  13:20:35  matthew
 *  Added handler for SubLoopTerminated in with_message -- otherwise we try and
 *  set the cursor of a window after Motif has exitted.
 *  Changed outstreams so a line at a time is printed.  Scrolling behaviour is bas
 *   bad otherwise.
 *
 *  Revision 1.30  1993/11/18  11:50:06  nickh
 *  Change to outstream arguments.
 *
 *  Revision 1.29  1993/11/08  16:08:35  jont
 *  Added menu iterm for generating interruptable code
 *  .\
 *
 *  Revision 1.28  1993/10/13  11:58:38  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.27  1993/10/08  16:43:29  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.26  1993/09/17  14:05:13  nosa
 *  New compiler option debug_polyvariables for polymorphic debugger.
 *
 *  Revision 1.25  1993/09/13  09:16:33  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.24.1.4  1993/10/12  14:41:15  daveb
 *  Changed print options.
 *
 *  Revision 1.24.1.3  1993/10/08  10:29:28  matthew
 *  Added beep & cut buffer utilities
 *  Fixed problem with generate_variable_debug_info and debugging mode
 *
 *  Revision 1.24.1.2  1993/09/10  11:12:21  daveb
 *  Added name parameter to MotifUtils.list_select.
 *
 *  Revision 1.24.1.1  1993/08/24  12:16:17  jont
 *  Fork for bug fixing
 *
 *  Revision 1.24  1993/08/24  12:16:17  matthew
 *  Rationalized mode option functions
 *
 *  Revision 1.23  1993/08/19  17:25:43  daveb
 *  Removed core-only and functional options, since they didn't do anything.
 *
 *  Revision 1.22  1993/08/11  11:01:50  matthew
 *  Changes for automatic option menu updating
 *
 *  Revision 1.21  1993/08/09  16:21:53  matthew
 *  Extended environment menu
 *
 *  Revision 1.20  1993/08/05  11:52:42  nosa
 *  New compiler option generateVariableDebugInfo in options menu.
 *
 *  Revision 1.19  1993/08/04  09:09:19  matthew
 *  Changed strict option to standard
 *
 *  Revision 1.18  1993/07/29  14:55:37  matthew
 *  Added (unworking and deleted) with_message function
 *  Added working with_message function that sets the cursor to busy
 *
 *  Revision 1.17  1993/06/10  16:02:42  matthew
 *  Added open_fixity and fixity_specs options
 *
 *  Revision 1.16  1993/06/03  16:54:53  daveb
 *  Removed cancel and help buttons from message boxes.
 *
 *  Revision 1.15  1993/05/28  15:52:21  matthew
 *  Added environment options to preferences
 *
 *  Revision 1.14  1993/05/27  16:19:19  matthew
 *  Return exit function from list_select
 *  Added bool ref to control destruction of list select widget
 *
 *  Revision 1.13  1993/05/19  13:58:19  daveb
 *  Revised some exceptions and added Mode dialog box.
 *
 *  Revision 1.12  1993/05/13  18:44:15  daveb
 *  Changed names of scrolllist widgets to simplify the specification
 *  of resources.
 *
 *  Revision 1.11  1993/05/13  14:26:19  daveb
 *  options_menu now takes a string to use for the title of the options
 *  dialogs.
 *
 *  Revision 1.10  1993/05/12  13:59:13  daveb
 *  Added comment about profligracy in creation of options menus.
 *
 *  Revision 1.9  1993/05/06  13:40:45  daveb
 *  Added make_outstream.
 *
 *  Revision 1.8  1993/05/04  16:59:24  matthew
 *  Added fileselect function
 *
 *  Revision 1.7  1993/04/30  15:53:35  daveb
 *  Moved Editor options dialog to new setup menu.
 *
 *  Revision 1.6  1993/04/28  12:10:42  richard
 *  Unified profiling and tracing options into `intercept'.
 *  Removed poly_makestring option.
 *
 *  Revision 1.5  1993/04/28  10:05:53  daveb
 *  Changes to make_scrolllist.
 *
 *  Revision 1.4  1993/04/27  12:48:50  daveb
 *  Added options_menu code from _listener and _fileselect.
 *
 *  Revision 1.3  1993/04/23  15:11:21  matthew
 *  Added send message function
 *
 *  Revision 1.2  1993/04/21  15:51:07  daveb
 *  Whoops.  Gave myself a fright there.  Checked in an old version.
 *
 *  Revision 1.1  1993/04/21  14:40:52  daveb
 *  Initial revision
 *  
 *
 *)

require "../library/capi";
require "../utils/lists";
require "../main/user_options";
require "../utils/crash";
require "../main/preferences";
require "../debugger/newtrace";
require "../interpreter/shell_utils";
require "../interpreter/user_context";
require "menus";
require "motif_utils";

functor MotifUtils (
  structure Capi: CAPI 
  structure Lists: LISTS
  structure Crash: CRASH
  structure UserOptions: USER_OPTIONS
  structure Preferences: PREFERENCES
  structure Trace : TRACE
  structure Menus: MENUS
  structure UserContext: USER_CONTEXT
  structure ShellUtils: SHELL_UTILS

  sharing UserOptions.Options = ShellUtils.Options
                              = UserContext.Options

  sharing type Menus.Widget = Capi.Widget

  sharing type ShellUtils.preferences = Preferences.preferences
  sharing type ShellUtils.Context = UserContext.Context

  sharing type UserOptions.user_tool_options = UserContext.user_tool_options =
	       ShellUtils.UserOptions
  sharing type UserOptions.user_context_options =
	       UserContext.user_context_options
): MOTIF_UTILS =
struct

  structure Options = UserOptions.Options

  type Widget = Capi.Widget
  type ButtonSpec = Menus.ButtonSpec
  type user_tool_options = UserOptions.user_tool_options
  type user_context_options = UserOptions.user_context_options
  type user_preferences = Preferences.user_preferences
  type user_context = UserContext.user_context

  fun list_select (parent,name) =
    let
      val shell = Capi.make_popup_shell (name,parent, [])
      val form = Capi.make_widget ("listSelectForm", Capi.Form,
                                   shell,[])
      exception ListSelect
      val select_fn_ref = ref (fn _ => raise ListSelect)
      val print_fn_ref = ref (fn _ => raise ListSelect)

      fun exit _ = Capi.unmanage form

      val (scroll,_,setitems) =
        Capi.make_scrolllist
        {parent = form,
         name = "listSelect",
         select_fn = fn _ => fn x => (exit();(!select_fn_ref) x),
         action_fn = fn _ => fn _ => (),
         print_fn = fn _ => (!print_fn_ref)}
      val dialogButtons = Capi.make_managed_widget ("dialogButtons", Capi.RowColumn,form,[])
      val buttons_updatefn = 
        Menus.make_submenus
        (dialogButtons,
         [Menus.PUSH ("cancel",
                      exit,
                      fn _ => true)])
      fun popup (items,select_fn,print_fn) =
        (select_fn_ref := select_fn;
         print_fn_ref := print_fn;
         setitems Options.default_print_options items;
         Capi.manage form;
         exit)
        
    in
      Capi.Layout.lay_out
      [Capi.Layout.TEXT scroll,
       Capi.Layout.SPACE,
       Capi.Layout.OTHER dialogButtons,
       Capi.Layout.SPACE];
      popup
    end

  fun make_outstream insert_text =
    let
      val outbuff = ref [] : string list ref

      (* Motif text widgets don't scroll nicely with multi-line output *)
      (* So break up into nl-terminated lines *)
      (* This could probably all be made a lot more efficient *)

      fun make_strings sl =
        let 
          fun foo ([],[],acc) = rev acc
            | foo ([],l,acc) = rev (implode (rev l) :: acc)
            | foo ("\n"::rest,l,acc) = foo (rest,[],(implode (rev ("\n"::l)))::acc)
            | foo (c::rest,l,acc) = foo (rest,c::l,acc)
        in
          foo (explode (implode (rev sl)),[],[])
        end

      fun flush_buffer () =
        let val strings = (make_strings (!outbuff))
        in
          outbuff := [];
          Lists.iterate insert_text strings
        end

      fun output_fn s =
        let
          fun has_nl 0 = false
            | has_nl n =
              if String.ordof (s,n-1) = ord"\n"
                then true
              else
                has_nl (n-1)
        in
          outbuff := s :: !outbuff;
          if has_nl (size s) then
            flush_buffer()
          else ()
        end
    in
      MLWorks.IO.outstream {output = output_fn,
                            flush_out = flush_buffer,
                            close_out = fn () => (),
			    closed_out = fn () => false}
    end

  datatype Writable = WRITABLE | ALL

  (* A MotifContext combines options dialogs with a user_context *)
  abstype MotifContext =
      SHORT_MOTIF_CONTEXT of			(* full_menus = false *)
        {user_context: user_context,
         mode_dialog: unit -> unit,
         update_fn: unit -> unit}
    | FULL_MOTIF_CONTEXT of			(* full_menus = true *)
        {user_context: user_context,
         mode_dialog: unit -> unit,
         compiler_dialog: unit -> unit,
         compatibility_dialog: unit -> unit,
         extensions_dialog: unit -> unit,
         update_fn: unit -> unit}
  with
    fun get_user_context (SHORT_MOTIF_CONTEXT r) = #user_context r
    |   get_user_context (FULL_MOTIF_CONTEXT r) = #user_context r;

    fun get_context_name m =
      UserContext.get_context_name (get_user_context m)

    val context_list = ref []

    fun get_mode_dialog (FULL_MOTIF_CONTEXT r) = #mode_dialog r
    |   get_mode_dialog (SHORT_MOTIF_CONTEXT r) = #mode_dialog r

    fun get_compiler_dialog (FULL_MOTIF_CONTEXT r) = #compiler_dialog r
    |   get_compiler_dialog (SHORT_MOTIF_CONTEXT r) =
      Crash.impossible "get_compiler_dialog"

    fun get_compatibility_dialog (FULL_MOTIF_CONTEXT r) =
      #compatibility_dialog r
    |   get_compatibility_dialog (SHORT_MOTIF_CONTEXT r) =
      Crash.impossible "get_compatibility_dialog"

    fun get_extensions_dialog (FULL_MOTIF_CONTEXT r) = #extensions_dialog r
    |   get_extensions_dialog (SHORT_MOTIF_CONTEXT r) =
      Crash.impossible "get_extensions_dialog"

    fun make_context (user_context, parent, user_preferences) =
        let
	  val title = UserContext.get_context_name user_context

	  (* Each MotifContext contains a user_context, which contains a set
	     of user_context_options.  The MotifContext also contains a number
	     of dialog boxes.  When the options are updated, the dialog boxes
	     must be updated to match them.  This is done by storing update
	     functions in the user_context_options. *)
	  val UserOptions.USER_CONTEXT_OPTIONS (options, update_fns) =
	    UserContext.get_user_options user_context

          fun set_context_option_fun f a =
            (f options) := a
             
          fun get_context_option_fun f () =
            !(f options)
              
          fun int_context_widget (name, accessor) =
            Menus.OPTINT
	      (name,
	       get_context_option_fun accessor,
	       set_context_option_fun accessor)
              
          fun bool_context_widget (name, accessor) =
            Menus.OPTTOGGLE
	      (name,
	       get_context_option_fun accessor,
	       set_context_option_fun accessor)

          fun do_update () = Lists.iterate (fn f => f ()) (!update_fns);

	  fun is_harlequin _ =
	    get_context_option_fun #require_keyword () andalso
            get_context_option_fun #topdec_semicolons () andalso
            get_context_option_fun #type_dynamic () andalso
            not (get_context_option_fun #nj_op_in_datatype ()) andalso
            not (get_context_option_fun #infixr_assoc ()) andalso
            not (get_context_option_fun #nj_signatures ()) andalso
            not (get_context_option_fun #weak_type_vars ()) andalso
            not (get_context_option_fun #open_fixity ()) andalso
            not (get_context_option_fun #fixity_specs ()) andalso
            (get_context_option_fun #abstractions ()) andalso
            get_context_option_fun #string_inequalities ()

	  fun harlequin true =
	    (set_context_option_fun #require_keyword true;
             set_context_option_fun #topdec_semicolons true;
             set_context_option_fun #type_dynamic true;
             set_context_option_fun #nj_op_in_datatype false;
             set_context_option_fun #infixr_assoc false;
             set_context_option_fun #nj_signatures false;
             set_context_option_fun #weak_type_vars false;
             set_context_option_fun #open_fixity false;
             set_context_option_fun #fixity_specs false;
             set_context_option_fun #abstractions true;
             set_context_option_fun #string_inequalities true)
	  |   harlequin false = ()

	  fun is_new_jersey _ =
	    not (get_context_option_fun #require_keyword ()) andalso
            get_context_option_fun #topdec_semicolons () andalso
            not (get_context_option_fun #type_dynamic ()) andalso
            get_context_option_fun #nj_op_in_datatype () andalso
            get_context_option_fun #infixr_assoc () andalso
            get_context_option_fun #nj_signatures () andalso
            get_context_option_fun #weak_type_vars () andalso
            get_context_option_fun #open_fixity () andalso
            get_context_option_fun #fixity_specs () andalso
            get_context_option_fun #abstractions () andalso
            get_context_option_fun #string_inequalities ()

	  fun new_jersey true =
	    (set_context_option_fun #require_keyword false;
             set_context_option_fun #topdec_semicolons true;
             set_context_option_fun #type_dynamic false;
             set_context_option_fun #nj_op_in_datatype true;
             set_context_option_fun #infixr_assoc true;
             set_context_option_fun #nj_signatures true;
             set_context_option_fun #weak_type_vars true;
             set_context_option_fun #open_fixity true;
             set_context_option_fun #fixity_specs true;
             set_context_option_fun #abstractions true;
             set_context_option_fun #string_inequalities true)
	  |   new_jersey false = ()

	  fun is_standard _ =
	    not (get_context_option_fun #require_keyword ()) andalso
            not (get_context_option_fun #topdec_semicolons ()) andalso
            not (get_context_option_fun #type_dynamic ()) andalso
            not (get_context_option_fun #nj_op_in_datatype ()) andalso
            not (get_context_option_fun #infixr_assoc ()) andalso
            not (get_context_option_fun #nj_signatures ()) andalso
            not (get_context_option_fun #weak_type_vars ()) andalso
            not (get_context_option_fun #open_fixity ()) andalso
            not (get_context_option_fun #fixity_specs ()) andalso
            not (get_context_option_fun #abstractions ()) andalso
            not (get_context_option_fun #string_inequalities ())

	  fun standard true =
	    (set_context_option_fun #require_keyword false;
             set_context_option_fun #topdec_semicolons false;
             set_context_option_fun #type_dynamic false;
             set_context_option_fun #nj_op_in_datatype false;
             set_context_option_fun #infixr_assoc false;
             set_context_option_fun #nj_signatures false;
             set_context_option_fun #weak_type_vars false;
             set_context_option_fun #open_fixity false;
             set_context_option_fun #fixity_specs false;
             set_context_option_fun #abstractions false;
             set_context_option_fun #string_inequalities false)
	  |   standard false = ()

	  fun optimizing true =
	    (set_context_option_fun #optimize_leaf_fns true;
             set_context_option_fun #optimize_tail_calls true;
             set_context_option_fun #optimize_self_tail_calls true)
	  |   optimizing false =
	    (set_context_option_fun #optimize_leaf_fns false;
             set_context_option_fun #optimize_tail_calls false;
             set_context_option_fun #optimize_self_tail_calls false)

	  fun is_optimizing _ =
	    get_context_option_fun #optimize_leaf_fns () andalso
            get_context_option_fun #optimize_tail_calls () andalso
            get_context_option_fun #optimize_self_tail_calls ()

	  fun debugging true =
	    (set_context_option_fun #generate_debug_info true;
             set_context_option_fun #generate_interceptable_code true)
	  |   debugging false =
	    if get_context_option_fun #generate_variable_debug_info () then
	      ()
	    else
              (set_context_option_fun #generate_debug_info false;
               set_context_option_fun #generate_interceptable_code false)

	  fun is_debugging _ =
            get_context_option_fun #generate_debug_info () andalso
            get_context_option_fun #generate_interceptable_code ()

	  fun var_info true =
	    if is_debugging () then
              set_context_option_fun #generate_variable_debug_info true
	    else
	      ()
	  |   var_info false =
            set_context_option_fun #generate_variable_debug_info false;

	  fun is_var_info _ =
	    is_debugging () andalso
	    get_context_option_fun #generate_variable_debug_info ()

          fun popup_mode_options parent =
            Menus.create_dialog
            (parent,
	     title,
             "modeOptions",
             do_update,
             [Menus.OPTLABEL "modeOptionsLabel",
              Menus.OPTSEPARATOR,
	      Menus.OPTRADIO
	        [Menus.OPTTOGGLE ("harlequin", is_harlequin, harlequin),
                 Menus.OPTTOGGLE ("standard", is_standard, standard),
                 Menus.OPTTOGGLE ("new_jersey", is_new_jersey, new_jersey)],
              Menus.OPTSEPARATOR,
	      Menus.OPTSUBMENU
	        [Menus.OPTTOGGLE ("optimizing", is_optimizing, optimizing),
                 Menus.OPTTOGGLE ("debugging", is_debugging, debugging),
                 Menus.OPTTOGGLE ("var_info", is_var_info, var_info)]])

          val (mode_dialog,mode_dialog_update) =
	    popup_mode_options parent

	  val Preferences.USER_PREFERENCES (user_preferences, _) =
	    user_preferences
        in
	  if !(#full_menus user_preferences) then
	    let
              fun popup_compiler_options parent =
                Menus.create_dialog
                (parent,
	         title,
                 "compilerOptions",
                 do_update,
                 [Menus.OPTLABEL "compilerOptionsLabel",
                  Menus.OPTSEPARATOR,
	          bool_context_widget
	  	  ("generateInterruptableCode", #generate_interruptable_code),
                  bool_context_widget
	  	  ("generateInterceptableCode", #generate_interceptable_code),
                  bool_context_widget
	  	  ("generateDebugInfo", #generate_debug_info),
                  bool_context_widget
	  	  ("generateVariableDebugInfo", #generate_variable_debug_info),
	  	(*
                  bool_context_widget
	  	  ("generatePolyVariableDebugInfo",
	  	   #generate_polyvariable_debug_info),
                  bool_context_widget("generateModuler", #generate_moduler),
	  	*)
                  Menus.OPTSEPARATOR,
                  bool_context_widget("optimizeLeafFns", #optimize_leaf_fns),
                  bool_context_widget("optimizeTailCalls", #optimize_tail_calls),
                  bool_context_widget
	  	  ("optimizeSelfTailCalls",#optimize_self_tail_calls)])
            
              fun popup_compatibility_options parent =
                Menus.create_dialog
                (parent,
	         title,
                 "compatibilityOptions",
                 do_update,
                 [Menus.OPTLABEL "compatibilityOptionsLabel",
                  Menus.OPTSEPARATOR,
                  bool_context_widget("stringInequalities", #string_inequalities),
                  bool_context_widget("infixrAssoc", #infixr_assoc),
                  bool_context_widget("opInDatatype", #nj_op_in_datatype),
                  bool_context_widget("njSignatures", #nj_signatures),
                  bool_context_widget("weakTyvars", #weak_type_vars),
                  bool_context_widget("fixitySpecs", #fixity_specs),
                  bool_context_widget("openFixity", #open_fixity)
	  	(*
                  bool_context_widget("defaultOverloads", #default_overloads)
	  	*)
                  ])
                
              fun popup_extensions_options parent =
                Menus.create_dialog
                (parent,
	         title,
                 "extensionsOptions",
                 do_update,
                 [Menus.OPTLABEL "extensionsOptionsLabel",
                  Menus.OPTSEPARATOR,
                  bool_context_widget("requireKeyword",#require_keyword),
                  bool_context_widget("typeDynamic",#type_dynamic),
                  bool_context_widget("abstractions",#abstractions),
                  bool_context_widget("topDecSemiColons", #topdec_semicolons)])

              val (compiler_dialog,compiler_dialog_update) =
	        popup_compiler_options parent

              val (compatibility_dialog,compatibility_dialog_update) =
	        popup_compatibility_options parent

              val (extensions_dialog,extensions_dialog_update) =
	        popup_extensions_options parent

              fun update_dialogues () =
                Lists.iterate 
                (fn f => f ()) 
                [mode_dialog_update,
                 compiler_dialog_update,
                 compatibility_dialog_update,
                 extensions_dialog_update]

	      val result = 
                FULL_MOTIF_CONTEXT
                  {user_context = user_context,
	           mode_dialog = mode_dialog,
	  	   compiler_dialog = compiler_dialog,
	  	   compatibility_dialog = compatibility_dialog,
	  	   extensions_dialog = extensions_dialog,
	           update_fn = update_dialogues}
	    in
	      context_list := result :: !context_list;
	      update_fns := update_dialogues :: !update_fns;
	      result
	    end
	  else
	    (* short menus version *)
	    let
              fun update_dialogues () =
                Lists.iterate 
                (fn f => f ()) 
                [mode_dialog_update]
	    
	      val result = 
                SHORT_MOTIF_CONTEXT 
	  	{user_context = user_context,
	  	 mode_dialog = mode_dialog,
	  	 update_fn = update_dialogues}
	    in
	      context_list := result :: !context_list;
	      update_fns := update_dialogues :: !update_fns;
	      result
	    end
        end
  end (* abstype MotifContext *)
       
  (* The code for managing the initial MotifContext is similar to that for
     managing the initial UserContext (in the structure of that ilk). *)
  val initialContext = ref MLWorks.Option.NONE

  fun makeInitialContext (parent, user_preferences) =
    let
      val user_context = UserContext.getInitialContext ()

      val motif_context =
	make_context (user_context, parent, user_preferences)

      exception AlreadyInitialised
    in
      case !initialContext
      of MLWorks.Option.NONE =>
	initialContext := MLWorks.Option.SOME motif_context
      |  _ => raise AlreadyInitialised;
      context_list := [motif_context]
    end

  fun getInitialContext () =
    case !initialContext
    of MLWorks.Option.SOME c => c
    |  _ => Crash.impossible "Bad initial motif context!"

  fun save_history (prompt, user_context, applicationShell) =
    let
      val filename_opt =
        if prompt then
          Capi.find_file (applicationShell)
        else
          case UserContext.get_saved_file_name user_context
          of MLWorks.Option.NONE =>
            Capi.find_file (applicationShell)
          |  x => x
    in
      case filename_opt of
        MLWorks.Option.NONE => ()
      | MLWorks.Option.SOME filename =>
        let
          val file = open_out filename

          (* examine_source checks whether the source ends with a
             semi-colon, and if so whether the semicolon is followed
             by a newline.  It skips trailing white space. *)
          fun examine_source (s, ~1, seen_newline) =
            (false, false)
          |   examine_source (s, n, seen_newline) =
            let
              val c = String.ordof (s, n)
            in
              if c = ord ";" then
                (true, seen_newline)
              else if c = ord "\n" then
                examine_source (s, n-1, true)
              else if c = ord " " orelse c = ord "\t" then
                examine_source (s, n-1, seen_newline)
              else
                (false, false)
            end

          fun massage_source s =
            let
              val (has_semicolon, has_newline) =
                examine_source (s, size s - 1, false)
            in
              s ^ (if has_semicolon then "" else ";")
                ^ (if has_newline then "" else "\n")
            end

          fun write_hist (UserContext.ITEM (_, _, _, _, source)) =
            output (file, massage_source source)

          val context_name = UserContext.get_context_name user_context

          val (_, _, hist, _) = UserContext.get_context_info user_context
        in
          Lists.iterate write_hist (rev hist);
          MLWorks.IO.flush_out file;
          close_out file;
          Capi.send_message
		(applicationShell, "Saved " ^ context_name ^ " to " ^ filename);
          UserContext.set_saved_file_name (user_context, filename)
        end
        handle Io _ => ()
    end

  fun null_history user_context =
    let
	  val (_, _, hist, _) = UserContext.get_context_info user_context
    in
	  Lists.length hist = 0
    end

  fun save_name_set user_context =
    case UserContext.get_saved_file_name user_context
    of MLWorks.Option.NONE => false
    |  MLWorks.Option.SOME _ => true

  (* All option dialogs for context-specific options are created once for
     each context.  The context menu must get the correct dialogs. *)
  fun context_menu
	{set_state, get_context, writable, applicationShell, user_preferences} =
    let
      fun select_menu () =
	let
	  fun make_item c =
            let
	      val name = get_context_name c
            in
	      Menus.PUSH (name, fn _ => set_state c, fn _ => true)
            end

	  val contexts =
	    if writable = WRITABLE then
	      Lists.filter_outp
	        (UserContext.is_const_context o get_user_context)
		(!context_list)
	    else
              !context_list
	in
          map make_item contexts
	end

      fun get_current_user_context () =
	get_user_context (get_context ())

      fun push_state _ =
	set_state
	  (make_context
	     (UserContext.copyUserContext (get_current_user_context ()),
	      applicationShell, user_preferences))

      fun initialContext _ =
	set_state
	  (make_context
	    (UserContext.getNewInitialContext (),
	     applicationShell, user_preferences))

      fun popup_mode_dialog _ =
	(get_mode_dialog (get_context ())) ()
          
      fun popup_compiler_dialog _ =
	(get_compiler_dialog (get_context ())) ()
          
      fun popup_compatibility_dialog _ =
	(get_compatibility_dialog (get_context ())) ()
          
      fun popup_extensions_dialog _ =
	(get_extensions_dialog (get_context ())) ()
          
      val is_constant = UserContext.is_const_context o get_current_user_context

      val Preferences.USER_PREFERENCES (user_preferences, _) =
	user_preferences

      (* If full_menus is set, then users can create multiple contexts
	 and select between them.  Users can also set individual options. *)
      val tail_menu =
        if !(#full_menus user_preferences) then
	  let
	    val sub_tail =
              [Menus.SEPARATOR,
               Menus.DYNAMIC ("context", select_menu, fn _ => true),
               Menus.SEPARATOR,
               Menus.CASCADE
	         ("options",
                  [Menus.PUSH ("compiler", popup_compiler_dialog, fn _ => true),
                 Menus.PUSH
		   ("compatibility", popup_compatibility_dialog, fn _ => true),
                 Menus.PUSH
	           ("extensions", popup_extensions_dialog, fn _ => true)],
                fn _ => not (is_constant ()))]
	  in
	    (* A tool can only create new contexts if it can write to them. *)
            if writable = WRITABLE then
              [Menus.PUSH ("pushContext", push_state, fn _ => true),
               Menus.PUSH ("initialContext", initialContext, fn _ => true)]
	      @@ sub_tail
	    else
	      sub_tail
	  end
	else
	  []

    in
      Menus.CASCADE
        ("context",
         [Menus.PUSH ("mode", popup_mode_dialog, fn _ => not (is_constant ())),
          Menus.PUSH
            ("save",
             fn _ =>
	       save_history
		 (false, get_current_user_context (), applicationShell),
             fn _ => not (null_history (get_current_user_context ()))
		         andalso save_name_set (get_current_user_context ())),
          Menus.PUSH
            ("saveAs",
             fn _ =>
               save_history
		 (true, get_current_user_context (), applicationShell),
             fn _ => not (null_history (get_current_user_context ())))]
	 @@ tail_menu,
	 fn _ => true)
    end

    fun setup_menu (parent, user_preferences) =
      let
        (* When the preferences are updated, the dialog boxes must be
           updated to match them.  This is done by storing update
           functions in the user_preferences. *)
        val Preferences.USER_PREFERENCES (user_preferences, update_fns) =
          user_preferences

        fun preference_update () = ()

        fun set_preference_fun f a =
          (f user_preferences) := a
           
        fun get_preference_fun f () =
          !(f user_preferences)

        fun popup_editor_options parent =
          Menus.create_dialog
          (parent,
           "Global Preferences",
	   "editorOptions",
           preference_update,
           [Menus.OPTLABEL "editorOptionsLabel",
            Menus.OPTSEPARATOR,
            Menus.OPTTOGGLE ("select_emacs",
                             fn () => case get_preference_fun (#editor) () of
                             		"emacs_server" => true
  			     	      | _ => false,
                             fn true => set_preference_fun (#editor) "emacs_server"
			     |  false => ()),
            Menus.OPTTOGGLE ("select_xterm_editor",
                             fn () => case get_preference_fun (#editor) () of
  			                "xterm" => true
  			              | _ => false,
                             fn true => set_preference_fun (#editor) "xterm"
                              | false => ()),
	    Menus.OPTTEXT ("xterm_editor_command",
			   fn () => get_preference_fun (#xterm_editor_command) (),
			   fn s => set_preference_fun (#xterm_editor_command) s),
            Menus.OPTTOGGLE ("select_x_editor",
                             fn () => case get_preference_fun (#editor) () of
  			                "x" => true
  			              | _ => false,
                             fn true => set_preference_fun (#editor) "x"
                              | false => ()),
	    Menus.OPTTEXT ("x_editor_command",
			   fn () => get_preference_fun (#x_editor_command) (),
			   fn s => set_preference_fun (#x_editor_command) s)])

        fun popup_environment_options parent =
            Menus.create_dialog
              (parent,
               "Global Preferences",
	       "environmentOptions",
               preference_update,
               Menus.OPTLABEL "environmentOptionsLabel"
               :: Menus.OPTSEPARATOR
               :: Menus.OPTINT
		    ("maximumHistoryLength",
                     fn () => get_preference_fun (#history_length) (),
                     fn x => set_preference_fun (#history_length) x)
               :: Menus.OPTINT
		    ("maximumNumberErrors",
	    	     fn () => get_preference_fun (#max_num_errors) (),
		     fn x  => set_preference_fun (#max_num_errors) x)
               :: Menus.OPTTOGGLE
		    ("autoOutputWindow",
                     fn () => get_preference_fun (#auto_output_window) (),
                     fn x => set_preference_fun (#auto_output_window) x)
               :: Menus.OPTTOGGLE
		    ("completionMenu",
                     fn () => get_preference_fun (#completion_menu) (),
                     fn x => set_preference_fun (#completion_menu) x)
               :: Menus.OPTTOGGLE
		    ("useDebugger",
                     fn () => get_preference_fun (#use_debugger) (),
                     fn x => set_preference_fun (#use_debugger) x)
               :: Menus.OPTTOGGLE
		    ("useErrorBrowser",
                     fn () => get_preference_fun (#use_error_browser) (),
                     fn x => set_preference_fun (#use_error_browser) x)
	       :: (if !(#full_menus user_preferences) then
		     [Menus.OPTTOGGLE
		        ("windowDebugger",
                         fn () => get_preference_fun (#window_debugger) (),
                         fn x => set_preference_fun (#window_debugger) x)]
	           else
		     nil))

        val (editor_dialog,editor_update) =
          popup_editor_options parent

        val (environment_dialog,environment_update) =
          popup_environment_options parent
      in
	update_fns := editor_update :: environment_update :: !update_fns;
        Menus.CASCADE
	  ("setup",
	   [Menus.PUSH ("editor", fn _ => editor_dialog (), fn _ => true),
            Menus.PUSH
	      ("environment", fn _ => environment_dialog (), fn _ => true)],
           fn _ => true)
      end

    (* This makes a widget that allows the entry, deletion and display of a *)
    (* list of strings *) 

    fun make_string_list_manager (parent,name,get,set) =
      let
        (* Some state *)
        val changed = ref false
        val stringlist = ref [] : string list ref
        val set_selected_hook = ref (fn () => ())

        (* Make the widgets *)
        val shell = Capi.make_popup_shell (name,parent,[])
        val form = Capi.make_widget ("listManagerForm",Capi.Form,shell,[])
        val text = Capi.make_managed_widget ("stringInput",Capi.Text,form,[])
        val buttonPane = Capi.make_managed_widget ("listManagerButtonPane", Capi.RowColumn, form, []);

        fun set_selected () = 
          (Capi.set_focus text;
           (!set_selected_hook) ())

        val (scroll,list,list_set) = 
          Capi.make_scrolllist
          {parent = form,
           name = "listManagerList", (* Note that this name is ignored *)
           (* Do nothing for the moment *)
           select_fn = fn _ => fn s => (),
           action_fn = fn _ => fn s => (),
           print_fn = fn _ => fn s => s}
          
        val dialogButtons = Capi.make_managed_widget ("dialogButtons", Capi.RowColumn,form,[])

        fun initialize () =
          (changed := false;
           stringlist := get())

        fun reset_text _ = Capi.Text.set_string (text,"")
        fun set_list _ = list_set Options.default_print_options (!stringlist)
        fun ok_string s = 
          if s = "" then false else true

        fun text_apply _ = 
          let
            val name = Capi.Text.get_string text
          in
            if ok_string name
              then 
                (stringlist := name :: !stringlist;
                 changed := true;
                 reset_text ();
                 set_list ();
                 set_selected ())
            else
              ()
          end
                
        fun apply_fn _ = (text_apply (); set (!stringlist); changed := false; set_selected ())

        fun reset _ = (initialize (); reset_text (); set_list (); set_selected ())

        fun do_delete _ =
          let
            fun to_list v =
              let
                val l = Vector.length v
                fun aux (n,acc) =
                  if n = l then rev acc
                  else aux (n+1,Vector.sub (v,n) :: acc)
              in
                aux (0,[])
              end
            fun trim ([],_,n,acc) = rev acc
              | trim (l,[],_,acc) = (rev acc) @@ l
              | trim (a::b,n::m,p,acc) =
                if n = p then trim (b,m,p+1,acc)
                else trim (b,n::m,p+1,a :: acc)
            val selected = Lists.msort (op < : int * int -> bool) (to_list (Capi.List.get_selected_pos list))
            val newlist = trim (!stringlist,selected,1,[])
          in
            stringlist := newlist;
            changed := true;
            set_list ();
            set_selected ()
          end

        val buttons_update_fn = 
          Menus.make_submenus
          (dialogButtons,
           [Menus.PUSH ("ok",
                        fn _ => (apply_fn ();
                                 Capi.unmanage form),
                        fn _ => true),
            Menus.PUSH ("apply",
                        fn _ => apply_fn (),
                        fn _ => !changed),
            Menus.PUSH ("reset",
                        reset,
                        fn _ => !changed),
            Menus.PUSH ("cancel",
                        fn _ => (reset (); Capi.unmanage form),
                        fn _ => true)])
        val other_buttons_update_fn =
          Menus.make_submenus
          (buttonPane,
           [Menus.PUSH ("addNameButton",
                        text_apply,
                        fn _ => true),
            Menus.PUSH ("deleteSelectedButton",
                        do_delete,
                        fn _ => true)])
      in
        set_selected_hook := buttons_update_fn;
        Capi.Callback.add (text, Capi.Callback.Activate, text_apply);
        Capi.Layout.lay_out
        [Capi.Layout.OTHER text,
         Capi.Layout.OTHER buttonPane,
         Capi.Layout.TEXT scroll,
         Capi.Layout.SPACE,
         Capi.Layout.OTHER dialogButtons];
        (fn _ =>
         (reset ();
          Capi.manage form;
          Capi.to_front shell))
      end

    fun toggle_stepping _ =
      Trace.set_stepping (not (Trace.step_state ()))

    fun breakpoints_menu parent =
      let
        val popup_traces =
          make_string_list_manager (parent,
                                    "traceManager",
                                    Trace.simple_traces,
                                    Trace.simple_trace_list)
        val popup_breakpoints =
          make_string_list_manager (parent,
                                    "breakpointManager",
                                    Trace.simple_breakpoints,
                                    Trace.simple_break_list)
      in
          Menus.CASCADE ("breakTrace",
                         [Menus.TOGGLE ("stepToggleButton",
                                        Trace.step_state,
                                        toggle_stepping,
                                        fn _ => true),
                          Menus.PUSH ("breakButton",
                                      popup_breakpoints,
                                      fn _ => true),
                          Menus.PUSH ("traceButton",
                                      popup_traces,
                                      fn _ => true)],
                         fn _ => true)

      end


    (* view_options doesn't return a complete menu, just the items for
       popping up the options dialogs for the tool-specific options. *)

    datatype ViewOptions = VIEW_ALL | SENSE_ONLY
    datatype Sensitivity =
      SENSE_ALL | NO_SET_SELECTION | NO_SENSE_SELECTION | CONTEXT_ONLY

    (* This function creates the dialogs when the menu is created.
       This prevents the same dialog being created twice for each window. *)
    (* The caller_update_fn allows the calling tool to be updated as a
       result of setting an option - e.g. making a tool newly sensitive 
       to the current selection. *)
    fun view_options
	  {parent, title, user_options, user_preferences,
	   caller_update_fn, sensitivity, view_type} =
      let
        val UserOptions.USER_TOOL_OPTIONS (options, update_fns) =
          user_options

        val Preferences.USER_PREFERENCES (user_preferences, _) =
	  user_preferences

        fun set_tool_option_fun f a =
          (f options) := a
           
        fun get_tool_option_fun f () =
          !(f options)
            
        fun int_tool_widget (name, accessor) =
          Menus.OPTINT
	    (name,
	     get_tool_option_fun accessor,
	     set_tool_option_fun accessor)
            
        fun bool_tool_widget (name, accessor) =
          Menus.OPTTOGGLE
	    (name,
	     get_tool_option_fun accessor,
	     set_tool_option_fun accessor)

        fun do_update () =
          (Lists.iterate (fn f => f ()) (!update_fns);
	   caller_update_fn user_options)

        fun popup_valueprinter_options parent =
          Menus.create_dialog
          (parent,
	   title,
           "valuePrinterOptions",
           do_update,
           [Menus.OPTLABEL "valuePrinterOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_tool_widget("showFnDetails",#show_fn_details),
            bool_tool_widget("showExnDetails",#show_exn_details),
            int_tool_widget("floatPrecision",#float_precision),
            int_tool_widget("maximumSeqSize",#maximum_seq_size),
            int_tool_widget("maximumStringSize",#maximum_string_size),
            int_tool_widget("maximumDepth",#maximum_depth),
            int_tool_widget("maximumRefDepth",#maximum_ref_depth),
            int_tool_widget("maximumStrDepth",#maximum_str_depth)
            ])
              
        fun popup_sensitivity_options parent =
          Menus.create_dialog
          (parent,
	   title,
           "sensitivityOptions",
           do_update,
           [Menus.OPTLABEL "sensitivityOptionsLabel",
            Menus.OPTSEPARATOR]
	   @@ (if !(#full_menus user_preferences) then
                [bool_tool_widget("senseContext",#sense_context),
                 bool_tool_widget("setContext",#set_context)]
	      else
	        [])
	   @@ (case sensitivity
	      of CONTEXT_ONLY =>
	        []
	      |  NO_SENSE_SELECTION =>
                [bool_tool_widget("setSelection",#set_selection)]
	      |  NO_SET_SELECTION =>
                [bool_tool_widget("senseSelection",#sense_selection)]
	      |  SENSE_ALL =>
                [bool_tool_widget("senseSelection",#sense_selection),
                 bool_tool_widget("setSelection",#set_selection)]))

        fun popup_internals_options parent =
          Menus.create_dialog
          (parent,
           title,
           "internalsOptions",
           do_update,
           [Menus.OPTLABEL "internalsOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_tool_widget("showAbsyn",#show_absyn),
            bool_tool_widget("showLambda",#show_lambda),
            bool_tool_widget("showOptLambda",#show_opt_lambda),
            bool_tool_widget("showEnviron",#show_environ),
            bool_tool_widget("showMir",#show_mir),
            bool_tool_widget("showOptMir",#show_opt_mir),
            bool_tool_widget("showMach",#show_mach)])
      in
	case view_type
	of SENSE_ONLY =>
	  if !(#full_menus user_preferences)
	     orelse sensitivity <> CONTEXT_ONLY then
	    let
              val (sensitivity_dialog,sensitivity_dialog_update) =
	        popup_sensitivity_options parent
	    in
	      update_fns := sensitivity_dialog_update :: !update_fns;
              [Menus.PUSH
	         ("sensitivity", fn _ => sensitivity_dialog (), fn _ => true)]
	    end
	  else
	    (* full_menus is not set, and the tool is not affected by the
	       current selection, so there is nothing to show. *)
	    []
	|  VIEW_ALL =>
	  if !(#full_menus user_preferences) then
	    let
              val (sensitivity_dialog,sensitivity_dialog_update) =
	        popup_sensitivity_options parent

              val (valueprinter_dialog,valueprinter_dialog_update) =
	        popup_valueprinter_options parent
                  
              val (internals_dialog,internals_dialog_update) =
                popup_internals_options parent
	   
              fun update_dialogues () =
                Lists.iterate 
                (fn f => f ()) 
                [valueprinter_dialog_update,
                 sensitivity_dialog_update,
                 internals_dialog_update]
	    in
	      update_fns := update_dialogues :: !update_fns;
              [Menus.PUSH
	 	 ("sensitivity", fn _ => sensitivity_dialog (), fn _ => true),
               Menus.PUSH
		 ("valueprinter",
		  fn _ => valueprinter_dialog (),
		  fn _ => true),
               Menus.PUSH
	         ("internals", fn _ => internals_dialog (), fn _ => true)]
	    end
	  else if sensitivity <> CONTEXT_ONLY then
	    let
              val (sensitivity_dialog,sensitivity_dialog_update) =
	        popup_sensitivity_options parent

              val (valueprinter_dialog,valueprinter_dialog_update) =
	        popup_valueprinter_options parent
                  
              fun update_dialogues () =
                Lists.iterate 
                (fn f => f ()) 
                [valueprinter_dialog_update,
                 sensitivity_dialog_update]
	    in
	      update_fns := update_dialogues :: !update_fns;
              [Menus.PUSH
	 	 ("sensitivity", fn _ => sensitivity_dialog (), fn _ => true),
               Menus.PUSH
		 ("valueprinter",
		  fn _ => valueprinter_dialog (),
		  fn _ => true)]
	    end
	  else
	    let
              val (valueprinter_dialog,valueprinter_dialog_update) =
	        popup_valueprinter_options parent
	    in
	      update_fns := valueprinter_dialog_update :: !update_fns;
              [Menus.PUSH
		 ("valueprinter",
		  fn _ => valueprinter_dialog (),
		  fn _ => true)]
	    end
      end
              
    val cut_buffer = ref ""

    fun cutSelection text_widget =
      (cut_buffer := Capi.Text.get_selection text_widget;
       Capi.Text.remove_selection text_widget)

    fun copySelection text_widget =
      cut_buffer := Capi.Text.get_selection text_widget

    fun pasteSelection text_widget =
      Capi.Text.insert (text_widget,Capi.Text.get_insertion_position text_widget,!cut_buffer)

  local

    val do_debug = false
    fun debug s = if do_debug then output(MLWorks.IO.terminal_out,s ^ "\n") else ()

    fun apply f x =  f(x)

    val initial_item = ShellUtils.default_dynamic

    fun get_pane_input [] = ""
      | get_pane_input (txt::panes) =
	let
	  val str = Capi.Text.get_selection txt
	in
	  if str="" then get_pane_input(panes) else str
	end

    fun first_line (message) =
      let
	fun aux ([],_) = message
	  | aux (("\n" :: _),acc) = implode (rev acc)
	  | aux ((a::b),acc) = aux (b,a::acc)
      in
	aux (explode message,[])
      end

  in

    fun value_menu_strfun
	  (parent, user_context, user_options, user_preferences, get_name_fn) =
	let
	  val current_item = ref initial_item

	  fun get_current_context () =
	    (UserContext.get_context user_context)

	  fun message_fun s =
            Capi.send_message (parent, s)

	  fun get_input_value () =
	    let
	      val str = get_name_fn()
	    in
	       if str=""
	       then initial_item
	       else let
		      val context = get_current_context ()
                      (* fun msg_fun s = ( message_fun s ; initial_item ) *)
		    in
		      ShellUtils.lookup_name(str,context,initial_item)
		    end
	    end

          fun set_current_item () =
	    ( current_item := get_input_value () ;
	      ()
            )

	  fun object_editable _ =
	     ( set_current_item ();
 	       ShellUtils.object_editable (#1(!current_item))
             )

	  fun object_traceable _ =
	     ShellUtils.object_traceable (#1(!current_item))

	  fun edit_object _ =
	    let
              val preferences = Preferences.new_preferences user_preferences
	      val input   = get_name_fn()
	    in
	      (ShellUtils.edit_object (#1(!current_item), preferences);())
	      handle ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
	    end

	  fun trace_object _ =
	    ShellUtils.trace
	      (!current_item, user_options, get_current_context, message_fun)

	  fun untrace_object _ =
	    ShellUtils.untrace
	      (!current_item, user_options, get_current_context, message_fun)
	in
	   Menus.CASCADE ("value",
			  [Menus.PUSH ("edit",
				       edit_object,
				       object_editable),
			   Menus.PUSH ("trace",
				       trace_object,
				       object_traceable),
			   Menus.PUSH ("untrace",
				       untrace_object,
				       object_traceable)],
			  fn _ => true)
	end

    fun value_menu
	  (parent, user_context, user_options, user_preferences,
	   text_widget_panes) =
	let
          fun get_string_nm () = get_pane_input text_widget_panes
        in
          value_menu_strfun
	    (parent, user_context, user_options,
	     user_preferences, get_string_nm)
        end
  end

end

@


1.65
log
@Adding some debugger utilities
@
text
@d4 3
d313 1
a313 1
      [Capi.Layout.OTHER scroll,
d315 2
a316 1
       Capi.Layout.OTHER dialogButtons];
@


1.64
log
@Capification
@
text
@d4 3
a231 1
require "../typechecker/basis";
a235 1
require "../interpreter/incremental";
a244 1
  structure Basis: BASIS
a247 1
  structure Incremental: INCREMENTAL
a254 6
  sharing type Basis.BasisTypes.Basis
               = Incremental.InterMake.Compiler.TypeBasis

  sharing type Basis.BasisTypes.Datatypes.Ident.ValId
               = Incremental.InterMake.Inter_EnvTypes.EnvironTypes.LambdaTypes.Ident.ValId

a258 3
                                  = Incremental.Context

  sharing type ShellUtils.Type = Basis.BasisTypes.Datatypes.Type
a266 3
  structure Ident = Basis.BasisTypes.Datatypes.Ident
  structure Symbol = Ident.Symbol
  structure Inter_EnvTypes = Incremental.InterMake.Inter_EnvTypes
a1378 16
    (* This should evaluate an identifier *)
    fun lookup_name (name,context) =
      let
        val tycontext = Basis.basis_to_context (Incremental.type_basis context)
        val valid = Ident.VAR(Symbol.find_symbol name)
        val valtype =
	  #1(Basis.lookup_val (Ident.LONGVALID (Ident.NOPATH, valid),
                               tycontext,
                               Ident.Location.UNKNOWN,
                               false))
        val mlval = Inter_EnvTypes.lookup_val(valid,Incremental.inter_env context)
      in
        (mlval,valtype)
      end
    handle _ => initial_item

d1402 1
a1402 1
		      lookup_name(str,context)
@


1.63
log
@Added float_precision option to ValuePrinter options.
@
text
@d4 3
d227 1
a227 1
require "../library/xm";
a237 1
require "file_dialog";
d241 1
a241 1
  structure Xm: XM 
a249 1
  structure FileDialog: FILE_DIALOG
d262 1
a262 1
  sharing type Xm.Widget = Menus.Widget = FileDialog.Widget
d282 1
a282 1
  type Widget = Xm.Widget
a288 63
  fun make_scrolllist {parent, name, select_fn, action_fn, print_fn} =
    let
      val listScroll = Xm.Widget.createManaged(Xm.Widget.NAME ("scroll"),
                                               Xm.Widget.Class.ScrolledWindow,
                                               parent,[])
      val listList =
        Xm.Widget.createManaged (Xm.Widget.NAME ("list"),
                                 Xm.Widget.Class.List,
                                 listScroll,
                                 [])

      val itemlistref = ref []

      fun get_selected_pos callback_data =
        let
          val (_,_,_,_,n,_,_,_,_) = Xm.Callback.convertList callback_data
        in
          n
        end

      fun set_items print_options [] =
        (itemlistref := [];
         Xm.List.deleteAllItems listList;
         Xm.List.addItems
	   (listList, [Xm.CompoundString.createSimple "<empty>"], 0))
      |   set_items print_options items =
        (itemlistref := items;
         Xm.List.deleteAllItems listList;
         Xm.List.addItems
	   (listList,
            map (Xm.CompoundString.createSimple o
		   (print_fn print_options))
		 items,
            0))

      val select_fn' = select_fn (listScroll, listList,  set_items)
      val action_fn' = action_fn (listScroll, listList,  set_items)

      fun select_callback_fn callback_data =
        let
          val pos = get_selected_pos callback_data
        in
          select_fn' (Lists.nth (pos-1,!itemlistref))
          handle Lists.Nth => ()
        end

      fun action_callback_fn callback_data =
        let
          val pos = get_selected_pos callback_data
        in
          action_fn' (Lists.nth (pos-1,!itemlistref))
          handle Lists.Nth => ()
        end
    in
      Xm.Widget.callbackAdd (listList,
                             Xm.Callback.SingleSelection,
                             select_callback_fn);
      Xm.Widget.callbackAdd (listList,
                             Xm.Callback.DefaultAction,
                             action_callback_fn);
      (listScroll,listList,set_items)
    end

d291 2
a292 5
      val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME name,
                                              Xm.Widget.Class.DialogShell,
                                              parent, [])
      val form = Xm.Widget.create (Xm.Widget.NAME "listSelectForm",
                                   Xm.Widget.Class.Form,
d298 1
a298 1
      fun exit _ = Xm.Widget.unmanage form
d301 1
a301 1
        make_scrolllist
d307 1
a307 7
      val separator = Xm.Widget.createManaged (Xm.Widget.NAME "separator",
                                               Xm.Widget.Class.Separator,
                                               form,[])
      val dialogButtons = Xm.Widget.createManaged (Xm.Widget.NAME "dialogButtons",
                                                   Xm.Widget.Class.RowColumn,
                                                   form,
                                                   [])
d318 1
a318 1
         Xm.Widget.manage form;
d322 4
a325 17
      Xm.Widget.valuesSet (scroll,
                           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                            (Xm.BottomWidget, Xm.WIDGET separator)]);
      Xm.Widget.valuesSet (separator,
                           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                            (Xm.BottomWidget, Xm.WIDGET dialogButtons)]);
      Xm.Widget.valuesSet (dialogButtons,
                           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
a374 39
  fun send_message (parent,message) =
    let
      val dialog =
        Xm.Widget.createPopupShell (Xm.Widget.NAME "messageDialog",
                                    Xm.Widget.Class.DialogShell,
                                    parent, [])
            
      val widget =
        Xm.Widget.create
        (Xm.Widget.NAME "message", Xm.Widget.Class.MessageBox, dialog,
         [(Xm.MessageString, Xm.COMPOUNDSTRING (Xm.CompoundString.createSimple message))])

      val _ =
        map 
         (fn c =>
           Xm.Widget.unmanage (Xm.Widget.messageBoxGetChild(widget,c)))
         [Xm.Widget.Child.CANCEL_BUTTON,
          Xm.Widget.Child.HELP_BUTTON]

      (* This really ought to reuse dialogs *)
      fun exit _ = Xm.Widget.destroy dialog
    in
      Xm.Widget.callbackAdd (widget, Xm.Callback.Ok, exit);
      Xm.Widget.manage widget
    end

  fun beep widget = Xm.Display.bell (Xm.Widget.display widget,100)

  fun with_message (parent,message) f =
    let
      val _ = Xm.Widget.setBusy parent
      val result = f () 
        handle exn as Xm.SubLoopTerminated => raise exn
             | exn => (Xm.Widget.unSetBusy parent; raise exn)
    in
      Xm.Widget.unSetBusy parent;
      result
    end

d735 1
a735 1
          FileDialog.find_file (applicationShell, applicationShell)
d739 1
a739 1
            FileDialog.find_file (applicationShell, applicationShell)
d786 1
a786 1
          send_message
d1027 4
a1030 26
        val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME name,
                                                Xm.Widget.Class.DialogShell,
                                                parent,
						[])
        val form = Xm.Widget.create (Xm.Widget.NAME "listManagerForm",
                                     Xm.Widget.Class.Form,
                                     shell,[])

        val text = Xm.Widget.createManaged (Xm.Widget.NAME "stringInput",
                                             Xm.Widget.Class.Text,
                                             form,
                                             [])
        val buttonPane =
          Xm.Widget.createManaged
 	  (Xm.Widget.NAME "listManagerButtonPane", Xm.Widget.Class.RowColumn,
	   form, []);

        val addNameButton =
          Xm.Widget.createManaged
 	  (Xm.Widget.NAME "addNameButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

        val deleteSelectedButton =
          Xm.Widget.createManaged
 	  (Xm.Widget.NAME "deleteSelectedButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])
d1033 1
a1033 1
          (Xm.Widget.processTraversal (text, Xm.Widget.TRAVERSE_CURRENT);
a1034 1
           
d1037 1
a1037 1
          make_scrolllist
d1045 1
a1045 8
        val separator = Xm.Widget.createManaged (Xm.Widget.NAME "separator",
                                                 Xm.Widget.Class.Separator,
                                                 form,[])

        val dialogButtons = Xm.Widget.createManaged (Xm.Widget.NAME "dialogButtons",
                                                      Xm.Widget.Class.RowColumn,
                                                      form,
                                                      [])
d1051 1
a1051 1
        fun reset_text _ = Xm.Text.setString (text,"")
d1058 1
a1058 1
            val name = Xm.Text.getString text
d1091 1
a1091 1
            val selected = Lists.msort (op < : int * int -> bool) (to_list (Xm.List.getSelectedPos list))
d1105 1
a1105 1
                                 Xm.Widget.unmanage form),
d1114 10
a1123 1
                        fn _ => (reset (); Xm.Widget.unmanage form),
d1127 7
a1133 33
        Xm.Widget.callbackAdd (text, Xm.Callback.Activate, text_apply);
        Xm.Widget.callbackAdd (addNameButton, Xm.Callback.Activate, text_apply);
        Xm.Widget.callbackAdd (deleteSelectedButton, Xm.Callback.Activate, do_delete);
        Xm.Widget.valuesSet (text,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (buttonPane,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET text),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (scroll,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET buttonPane),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BottomWidget, Xm.WIDGET separator)]);
        Xm.Widget.valuesSet (separator,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BottomWidget, Xm.WIDGET dialogButtons)]);
        Xm.Widget.valuesSet (dialogButtons,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);

d1136 2
a1137 3
          Xm.Widget.manage form;
          Xm.Widget.map shell;
          Xm.Widget.toFront shell))
d1357 2
a1358 2
      (cut_buffer := Xm.Text.getSelection text_widget;
       Xm.Text.removeSelection text_widget)
d1361 1
a1361 1
      cut_buffer := Xm.Text.getSelection text_widget
d1364 1
a1364 1
      Xm.Text.insert (text_widget,Xm.Text.getInsertionPosition text_widget,!cut_buffer)
d1378 1
a1378 1
	  val str = Xm.Text.getSelection txt
d1419 1
a1419 1
              send_message (parent, s)
a1489 2
  fun set_sensitivity (widget,sensitivity) =
    Xm.Widget.valuesSet (widget,[(Xm.Sensitive, Xm.BOOL sensitivity)])
d1491 1
@


1.62
log
@Added variable info mode.
@
text
@d4 3
d1397 1
@


1.61
log
@ShellUtils.edit_* functions no longer require a context argument.
Added entries for new preferences to setup_menu.
@
text
@d4 4
a663 1
             (* set_context_option_fun #generate_variable_debug_info false; *)
d666 3
a669 1
               set_context_option_fun #generate_variable_debug_info false;
a673 1
	    (* get_context_option_fun #generate_variable_debug_info () andalso *)
d676 12
d703 2
a704 1
                 Menus.OPTTOGGLE ("debugging", is_debugging, debugging)]])
d722 2
a725 2
	          bool_context_widget
	  	  ("generateInterruptableCode", #generate_interruptable_code),
d736 1
a976 8
(*
      val save_bits =
         Menus.CASCADE
           ("history",
            [Menus.PUSH ("copy", fn _ => copy_history (), is_selection)
            Menus.PUSH ("edit", fn _ => (), is_selection)]
            fn _ => true)
*)
@


1.60
log
@Removed show_id_class and show_eq_info value printer options from interface.
@
text
@d4 3
d1095 8
a1607 1
	      val context = get_current_context()
d1610 1
a1610 1
	      (ShellUtils.edit_object (#1(!current_item),context,preferences);())
@


1.59
log
@Added NO_SENSE_SELECTION option for Sensitivity type.
@
text
@d4 3
a1370 2
            bool_tool_widget("showEqInfo",#show_eq_info),
            bool_tool_widget("showIdClass",#show_id_class),
@


1.58
log
@Added new type MotifContext, which combines a user_context with
dialog boxes for context-specific options.  Changed context_menu to
incorporate entries for popping up the options dialogs for the current
context.  Put the remaining options dialogs, for tool-specific options,
in the view_options function, which returns items for use in "view"
menus.
@
text
@d4 8
d1320 2
a1321 1
    datatype Sensitivity = SENSE_ALL | NO_SET_SELECTION | CONTEXT_ONLY
d1395 2
@


1.57
log
@Changing interface to list_select.
@
text
@d4 3
d207 2
d214 1
d220 1
d223 1
d227 1
d240 1
a240 2
  sharing type Xm.Widget = Menus.Widget

d242 1
a242 1
  sharing type ShellUtils.preferences = UserOptions.preferences
d248 4
a251 8
(*
  sharing type ShellUtils.Options.options = ShellUtils.UserOptions

  sharing type ShellUtils.Options.options
                  = UserOptions.Options.options
*)
  sharing type UserOptions.user_options = UserContext.user_options
                                        = ShellUtils.UserOptions
d262 3
a264 1
  type UserOptions = UserOptions.user_options
a465 29
(*
  fun with_message (parent,message) f =
    let
      val dialog =
        Xm.Widget.createPopupShell (Xm.Widget.NAME "withMessageDialog",
                                    Xm.Widget.Class.DialogShell,
                                    parent, [])
            
      val form =
        Xm.Widget.create
        (Xm.Widget.NAME "messageForm",Xm.Widget.Class.Form,dialog,[])
      val widget =
        Xm.Widget.createManaged
        (Xm.Widget.NAME "message", Xm.Widget.Class.Label, form,
         [(Xm.LabelString, Xm.COMPOUNDSTRING (Xm.CompoundString.createSimple message))])
      val _ =
        Xm.Widget.valuesSet (form,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)])

      val _ = Xm.Widget.manage form
      val result = f () handle exn => (Xm.Widget.destroy dialog; raise exn)
    in
      Xm.Widget.destroy dialog;
      result
    end
*)
d477 403
a879 1
  fun preference_update () = ()
d881 6
a886 1
  datatype Writable = WRITABLE | ALL
d888 9
a896 1
  fun context_menu (set_state, get_context, writable) =
d902 1
a902 1
	      val name = UserContext.get_context_name c
d910 2
a911 2
	        UserContext.is_const_context
                (UserContext.getCurrentContexts())
d913 1
a913 1
               UserContext.getCurrentContexts()
d918 3
d922 4
a925 1
        set_state (UserContext.copyUserContext (get_context ()))
d928 58
a985 5
        let
          val context = UserContext.getNewInitialContext()
        in
          set_state (context)
        end
d988 18
a1005 10
      if writable = WRITABLE then
        Menus.CASCADE
          ("context",
           [Menus.PUSH ("pushContext", push_state, fn _ => true),
            Menus.PUSH ("initialContext", initialContext, fn _ => true),
            Menus.SEPARATOR,
            Menus.DYNAMIC ("context", select_menu, fn _ => true)],
           fn _ => true)
      else
        Menus.DYNAMIC ("context", select_menu, fn _ => true)
d1008 1
a1008 1
    fun setup_menu (parent, get_user_options) =
d1010 10
a1019 6
        fun set_option_fun f a =
          let
            val UserOptions.USER_OPTIONS (options,_) = get_user_options()
          in
            (f options) := a
          end
d1021 2
a1022 6
        fun get_option_fun f () =
          let
            val UserOptions.USER_OPTIONS (options,_) = get_user_options()
          in
            !(f options)
          end
d1033 1
a1033 1
                             fn () => case get_option_fun (#editor) () of
d1036 1
a1036 1
                             fn true => set_option_fun (#editor) "emacs_server"
d1039 1
a1039 1
                             fn () => case get_option_fun (#editor) () of
d1042 1
a1042 1
                             fn true => set_option_fun (#editor) "xterm"
d1045 2
a1046 2
			   fn () => get_option_fun (#xterm_editor_command) (),
			   fn s => set_option_fun (#xterm_editor_command) s),
d1048 1
a1048 1
                             fn () => case get_option_fun (#editor) () of
d1051 1
a1051 1
                             fn true => set_option_fun (#editor) "x"
d1054 2
a1055 2
			   fn () => get_option_fun (#x_editor_command) (),
			   fn s => set_option_fun (#x_editor_command) s)])
a1057 3
	  let
            val UserOptions.USER_OPTIONS (options,_) = get_user_options()
	  in
d1067 2
a1068 2
                     fn () => get_option_fun (#history_length) (),
                     fn x => set_option_fun (#history_length) x)
d1071 2
a1072 2
	    	     fn () => get_option_fun (#max_num_errors) (),
		     fn x  => set_option_fun (#max_num_errors) x)
d1075 2
a1076 2
                     fn () => get_option_fun (#auto_output_window) (),
                     fn x => set_option_fun (#auto_output_window) x)
d1079 3
a1081 3
                     fn () => get_option_fun (#completion_menu) (),
                     fn x => set_option_fun (#completion_menu) x)
	       :: (if !(#full_menus options) then
d1084 2
a1085 2
                         fn () => get_option_fun (#window_debugger) (),
                         fn x => set_option_fun (#window_debugger) x)]
a1087 80
	  end

        val (editor_dialog,editor_update) = popup_editor_options parent
        val (environment_dialog,environment_update) = popup_environment_options parent
      in
          Menus.CASCADE ("setup",
                         [Menus.PUSH ("editor",
                                      editor_dialog,
                                      fn _ => true),
                          Menus.PUSH ("environment",
                                      environment_dialog,
                                      fn _ => true)],
                          fn _ => true)
      end

    fun input_string (parent,name,callback) =
      let
        val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME name,
                                                Xm.Widget.Class.DialogShell,
                                                parent,
						[])
        val form = Xm.Widget.create (Xm.Widget.NAME "stringInputForm",
                                     Xm.Widget.Class.Form,
                                     shell,[])
        val text = Xm.Widget.createManaged (Xm.Widget.NAME "stringInput",
                                             Xm.Widget.Class.Text,
                                             form,
                                             [])
        val separator = Xm.Widget.createManaged (Xm.Widget.NAME "separator",
                                                 Xm.Widget.Class.Separator,
                                                 form,[])
        val dialogButtons = Xm.Widget.createManaged (Xm.Widget.NAME "dialogButtons",
                                                      Xm.Widget.Class.RowColumn,
                                                      form,
                                                      [])
        fun reset _ = Xm.Text.setString (text,"")
        fun apply_fn _ = (callback (Xm.Text.getString text);reset ())

        val buttons_update_fn = 
          Menus.make_submenus
          (dialogButtons,
           [Menus.PUSH ("ok",
                        fn _ => (apply_fn ();
                                 Xm.Widget.unmanage form),
                        fn _ => true),
            Menus.PUSH ("apply",
                        fn _ => apply_fn (),
                        fn _ => true),
            Menus.PUSH ("reset",
                        reset,
                        fn _ => true),
            Menus.PUSH ("cancel",
                        fn _ => (reset (); Xm.Widget.unmanage form),
                        fn _ => true)])
      in
        Xm.Widget.callbackAdd (text, Xm.Callback.Activate, apply_fn);
        Xm.Widget.valuesSet (text,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BottomWidget, Xm.WIDGET separator)]);
        Xm.Widget.valuesSet (separator,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BottomWidget, Xm.WIDGET dialogButtons)]);
        Xm.Widget.valuesSet (dialogButtons,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);

        (fn _ =>
         (buttons_update_fn ();
          Xm.Widget.manage form;
          Xm.Widget.map shell;
          Xm.Widget.toFront shell))
      end
d1089 2
a1090 5
(*
    fun breakpoints_menu parent =
      let
        val set_breakpoint =
          input_string (parent,"setBreakpoint",MLWorks.Debugger.set_breakpoint)
d1092 2
a1093 13
        fun breakpoints_exist () =
          case MLWorks.Debugger.list_breakpoints ()
          of [] => false
          |  _ => true

        fun delete_breakpoint () =
          map
            (fn b =>
               Menus.PUSH
                 (b,
                  fn _ => MLWorks.Debugger.delete_breakpoint b,
                  fn _ => true))
            (MLWorks.Debugger.list_breakpoints ())
d1095 7
a1101 9
          Menus.CASCADE ("breakpoints",
                         [Menus.PUSH ("setBreakpoint",
                                      set_breakpoint,
                                      fn _ => true),
                          Menus.DYNAMIC ("deleteBreakpoint",
                                         delete_breakpoint,
                                         fn _ => breakpoints_exist ())],
                         fn _ => true)

a1102 1
*)
d1307 15
a1321 4
    fun options_menu (parent, title, get_user_options, caller_update_fn) =
      (* This function creates the dialogs when the menu is created.
         This prevents the same dialog being created twice for
         the same window, but is wasteful. *)
d1323 8
a1330 6
        fun set_option_fun f a =
          let
            val UserOptions.USER_OPTIONS (options,_) = get_user_options()
          in
            (f options) := a
          end
d1332 2
a1333 6
        fun get_option_fun f () =
          let
            val UserOptions.USER_OPTIONS (options,_) = get_user_options()
          in
            !(f options)
          end
d1335 5
a1339 2
        fun int_widget (name,accessor) =
          Menus.OPTINT(name,get_option_fun accessor,set_option_fun accessor)
d1341 5
a1345 2
        fun bool_widget (name,accessor) =
          Menus.OPTTOGGLE(name,get_option_fun accessor,set_option_fun accessor)
d1348 2
a1349 7
          let
            val user_options as
	      UserOptions.USER_OPTIONS (_,update_fns) = get_user_options()
          in
            Lists.iterate (fn f => f ()) (!update_fns);
	    caller_update_fn user_options
          end
d1359 9
a1367 9
            bool_widget("showEqInfo",#show_eq_info),
            bool_widget("showIdClass",#show_id_class),
            bool_widget("showFnDetails",#show_fn_details),
            bool_widget("showExnDetails",#show_exn_details),
            int_widget("maximumSeqSize",#maximum_seq_size),
            int_widget("maximumStringSize",#maximum_string_size),
            int_widget("maximumDepth",#maximum_depth),
            int_widget("maximumRefDepth",#maximum_ref_depth),
            int_widget("maximumStrDepth",#maximum_str_depth)
d1377 14
a1390 115
            Menus.OPTSEPARATOR,
            bool_widget("senseContext",#sense_context),
            bool_widget("setContext",#set_context),
            bool_widget("senseSelection",#sense_selection),
            bool_widget("setSelection",#set_selection)
            ])
              
	fun is_harlequin _ =
	  get_option_fun #require_keyword () andalso
          get_option_fun #topdec_semicolons () andalso
          get_option_fun #type_dynamic () andalso
          not (get_option_fun #nj_op_in_datatype ()) andalso
          not (get_option_fun #infixr_assoc ()) andalso
          not (get_option_fun #nj_signatures ()) andalso
          not (get_option_fun #weak_type_vars ()) andalso
          not (get_option_fun #open_fixity ()) andalso
          not (get_option_fun #fixity_specs ()) andalso
          (get_option_fun #abstractions ()) andalso
          get_option_fun #string_inequalities ()

	fun harlequin true =
	  (set_option_fun #require_keyword true;
           set_option_fun #topdec_semicolons true;
           set_option_fun #type_dynamic true;
           set_option_fun #nj_op_in_datatype false;
           set_option_fun #infixr_assoc false;
           set_option_fun #nj_signatures false;
           set_option_fun #weak_type_vars false;
           set_option_fun #open_fixity false;
           set_option_fun #fixity_specs false;
           set_option_fun #abstractions true;
           set_option_fun #string_inequalities true)
	|   harlequin false = ()

	fun is_new_jersey _ =
	  not (get_option_fun #require_keyword ()) andalso
          get_option_fun #topdec_semicolons () andalso
          not (get_option_fun #type_dynamic ()) andalso
          get_option_fun #nj_op_in_datatype () andalso
          get_option_fun #infixr_assoc () andalso
          get_option_fun #nj_signatures () andalso
          get_option_fun #weak_type_vars () andalso
          get_option_fun #open_fixity () andalso
          get_option_fun #fixity_specs () andalso
          get_option_fun #abstractions () andalso
          get_option_fun #string_inequalities ()

	fun new_jersey true =
	  (set_option_fun #require_keyword false;
           set_option_fun #topdec_semicolons true;
           set_option_fun #type_dynamic false;
           set_option_fun #nj_op_in_datatype true;
           set_option_fun #infixr_assoc true;
           set_option_fun #nj_signatures true;
           set_option_fun #weak_type_vars true;
           set_option_fun #open_fixity true;
           set_option_fun #fixity_specs true;
           set_option_fun #abstractions true;
           set_option_fun #string_inequalities true)
	|   new_jersey false = ()

	fun is_standard _ =
	  not (get_option_fun #require_keyword ()) andalso
          not (get_option_fun #topdec_semicolons ()) andalso
          not (get_option_fun #type_dynamic ()) andalso
          not (get_option_fun #nj_op_in_datatype ()) andalso
          not (get_option_fun #infixr_assoc ()) andalso
          not (get_option_fun #nj_signatures ()) andalso
          not (get_option_fun #weak_type_vars ()) andalso
          not (get_option_fun #open_fixity ()) andalso
          not (get_option_fun #fixity_specs ()) andalso
          not (get_option_fun #abstractions ()) andalso
          not (get_option_fun #string_inequalities ())

	fun standard true =
	  (set_option_fun #require_keyword false;
           set_option_fun #topdec_semicolons false;
           set_option_fun #type_dynamic false;
           set_option_fun #nj_op_in_datatype false;
           set_option_fun #infixr_assoc false;
           set_option_fun #nj_signatures false;
           set_option_fun #weak_type_vars false;
           set_option_fun #open_fixity false;
           set_option_fun #fixity_specs false;
           set_option_fun #abstractions false;
           set_option_fun #string_inequalities false)
	|   standard false = ()

	fun optimizing true =
	  (set_option_fun #optimize_leaf_fns true;
           set_option_fun #optimize_tail_calls true;
           set_option_fun #optimize_self_tail_calls true)
	|   optimizing false =
	  (set_option_fun #optimize_leaf_fns false;
           set_option_fun #optimize_tail_calls false;
           set_option_fun #optimize_self_tail_calls false)

	fun is_optimizing _ =
	  get_option_fun #optimize_leaf_fns () andalso
          get_option_fun #optimize_tail_calls () andalso
          get_option_fun #optimize_self_tail_calls ()

	fun debugging true =
	  (set_option_fun #generate_debug_info true;
           (* set_option_fun #generate_variable_debug_info false; *)
           set_option_fun #generate_interceptable_code true)
	|   debugging false =
            (set_option_fun #generate_debug_info false;
             set_option_fun #generate_variable_debug_info false;
             set_option_fun #generate_interceptable_code false)

	fun is_debugging _ =
          get_option_fun #generate_debug_info () andalso
	  (* get_option_fun #generate_variable_debug_info () andalso *)
          get_option_fun #generate_interceptable_code ()
d1392 1
a1392 1
        fun popup_mode_options parent =
d1395 2
a1396 2
	   title,
           "modeOptions",
d1398 1
a1398 1
           [Menus.OPTLABEL "modeOptionsLabel",
d1400 29
a1428 8
	    Menus.OPTRADIO
	      [Menus.OPTTOGGLE ("harlequin", is_harlequin, harlequin),
               Menus.OPTTOGGLE ("standard", is_standard, standard),
               Menus.OPTTOGGLE ("new_jersey", is_new_jersey, new_jersey)],
            Menus.OPTSEPARATOR,
	    Menus.OPTSUBMENU
	      [Menus.OPTTOGGLE ("optimizing", is_optimizing, optimizing),
               Menus.OPTTOGGLE ("debugging", is_debugging, debugging)]])
d1430 27
a1456 5
        val (valueprinter_dialog,valueprinter_dialog_update) =
	  popup_valueprinter_options parent

        val (sensitivity_dialog,sensitivity_dialog_update) =
	  popup_sensitivity_options parent
d1458 2
a1459 48
        val (mode_dialog,mode_dialog_update) =
	  popup_mode_options parent

        val UserOptions.USER_OPTIONS (options,_) = get_user_options()
      in
	if !(#full_menus options) then
	  let
            fun popup_compiler_options parent =
              Menus.create_dialog
              (parent,
	       title,
               "compilerOptions",
               do_update,
               [Menus.OPTLABEL "compilerOptionsLabel",
                Menus.OPTSEPARATOR,
                bool_widget
		  ("generateInterceptableCode", #generate_interceptable_code),
	        bool_widget
		  ("generateInterruptableCode", #generate_interruptable_code),
                bool_widget
		  ("generateDebugInfo", #generate_debug_info),
                bool_widget
		  ("generateVariableDebugInfo", #generate_variable_debug_info),
		(*
                bool_widget
		  ("generatePolyVariableDebugInfo",
		   #generate_polyvariable_debug_info),
                bool_widget("generateModuler", #generate_moduler),
		*)
                bool_widget("optimizeLeafFns", #optimize_leaf_fns),
                bool_widget("optimizeTailCalls", #optimize_tail_calls),
                bool_widget("optimizeSelfTailCalls",#optimize_self_tail_calls)])
          
            fun popup_internals_options parent =
              Menus.create_dialog
              (parent,
	       title,
               "internalsOptions",
               do_update,
               [Menus.OPTLABEL "internalsOptionsLabel",
                Menus.OPTSEPARATOR,
                bool_widget("showAbsyn",#show_absyn),
                bool_widget("showLambda",#show_lambda),
                bool_widget("showOptLambda",#show_opt_lambda),
                bool_widget("showEnviron",#show_environ),
                bool_widget("showMir",#show_mir),
                bool_widget("showOptMir",#show_opt_mir),
                bool_widget("showMach",#show_mach)])
d1461 26
a1486 19
            fun popup_compatibility_options parent =
              Menus.create_dialog
              (parent,
	       title,
               "compatibilityOptions",
               do_update,
               [Menus.OPTLABEL "compatibilityOptionsLabel",
                Menus.OPTSEPARATOR,
                bool_widget("stringInequalities", #string_inequalities),
                bool_widget("infixrAssoc", #infixr_assoc),
                bool_widget("opInDatatype", #nj_op_in_datatype),
                bool_widget("njSignatures", #nj_signatures),
                bool_widget("weakTyvars", #weak_type_vars),
                bool_widget("fixitySpecs", #fixity_specs),
                bool_widget("openFixity", #open_fixity)
		(*
                bool_widget("defaultOverloads", #default_overloads)
		*)
                ])
a1487 79
            fun popup_extensions_options parent =
              Menus.create_dialog
              (parent,
	       title,
               "extensionsOptions",
               do_update,
               [Menus.OPTLABEL "extensionsOptionsLabel",
                Menus.OPTSEPARATOR,
                bool_widget("requireKeyword",#require_keyword),
                bool_widget("typeDynamic",#type_dynamic),
                bool_widget("abstractions",#abstractions),
                bool_widget("topDecSemiColons", #topdec_semicolons)])

            val (compiler_dialog,compiler_dialog_update) =
	      popup_compiler_options parent

            val (internals_dialog,internals_dialog_update) =
	      popup_internals_options parent

            val (compatibility_dialog,compatibility_dialog_update) =
	      popup_compatibility_options parent

            val (extensions_dialog,extensions_dialog_update) =
	      popup_extensions_options parent

            fun update_dialogues () =
              Lists.iterate 
              (fn f => f ()) 
              [mode_dialog_update,
               compiler_dialog_update,
               valueprinter_dialog_update,
               sensitivity_dialog_update,
               internals_dialog_update,
               compatibility_dialog_update,
               extensions_dialog_update]
	  in
            (Menus.CASCADE
	       ("options",
                [Menus.PUSH
		   ("mode", mode_dialog, fn _ => true),
                 Menus.PUSH
		   ("sensitivity", sensitivity_dialog, fn _ => true),
                 Menus.PUSH
		   ("valueprinter", valueprinter_dialog, fn _ => true),
	         Menus.SEPARATOR,
                 Menus.PUSH
		   ("compiler", compiler_dialog, fn _ => true),
                 Menus.PUSH
		   ("compatibility", compatibility_dialog, fn _ => true),
                 Menus.PUSH
		   ("extensions", extensions_dialog, fn _ => true),
                 Menus.PUSH
		   ("internals", internals_dialog, fn _ => true)],
                fn _ => true),
             update_dialogues)
	  end
	else
	  (* short menus version *)
	  let
            fun update_dialogues () =
              Lists.iterate 
              (fn f => f ()) 
              [mode_dialog_update,
               sensitivity_dialog_update,
               valueprinter_dialog_update]
	  in
            (Menus.CASCADE
	       ("options",
                [Menus.PUSH
		   ("mode", mode_dialog, fn _ => true),
                 Menus.PUSH
		   ("sensitivity", sensitivity_dialog, fn _ => true),
                 Menus.PUSH
		   ("valueprinter", valueprinter_dialog, fn _ => true)],
                fn _ => true),
             update_dialogues)
	  end
      end

a1515 1
(*
a1516 10
    fun check_selection (txt) =
      ( debug "Checking selection of widget ...";
	let
	  val str = Xm.Text.getSelection txt
	in
	  debug ("Selection = (" ^ str ^ ")");
	  ()
	end
      )
*)
a1525 12
(*
    fun eval_string (string,context,options,msg_fun) =
	ShellUtils.eval
	   Info.default_options
	   (string^";",options,context,apply)
	    handle ShellTypes.DebuggerTrapped => initial_item
		 | ShellUtils.Error(_,error,_) =>
		     msg_fun(first_line (Info.string_error error))
		 | ShellUtils.NotAnExpression =>
		     msg_fun("Not an expression")
*)

d1544 2
a1545 1
    fun value_menu_strfun (parent, user_context, user_options, get_name_fn) =
a1548 2
	  val current_context = ref user_context

d1550 1
a1550 1
	    (UserContext.get_context (!current_context))
a1551 6
	  fun get_current_options () =
	    (UserOptions.new_options user_options)

	  fun get_current_preferences () =
	    (UserOptions.new_preferences user_options)

d1584 1
a1584 2

              val preferences = get_current_preferences() 
a1586 1

d1593 2
a1594 4
	      ShellUtils.trace (!current_item,
				user_options,
				get_current_context,
				message_fun)
d1597 2
a1598 4
	      ShellUtils.untrace (!current_item,
				  user_options,
				  get_current_context,
				  message_fun)
d1613 3
a1615 1
    fun value_menu (parent, user_context, user_options, text_widget_panes) =
d1619 3
a1621 1
          value_menu_strfun (parent, user_context, user_options, get_string_nm)
@


1.56
log
@Removed erroneous call to debug_output
@
text
@d4 3
d324 1
a324 1
  fun list_select (parent,name,items,select_fn,print_fn) =
a328 2
      val exited = ref false
      fun exit _ = if !exited then () else (Xm.Widget.destroy shell;exited:=true)
d332 6
d342 1
a342 1
         select_fn = fn _ => fn x => (exit();select_fn x),
d344 1
a344 1
         print_fn = fn _ => print_fn}
d358 7
d383 1
a383 3
      setitems Options.default_print_options items;
      Xm.Widget.manage form;
      exit
@


1.55
log
@Renaming nj_semicolons
@
text
@d4 3
a257 2
  fun debug_output s = output(MLWorks.IO.terminal_out,s ^"\n")

a1383 1
              debug_output str;
@


1.54
log
@Removing exception EditObject
@
text
@d4 3
d1004 1
a1004 1
          not (get_option_fun #nj_semicolons ()) andalso
d1017 1
a1017 1
           set_option_fun #nj_semicolons false;
d1031 1
a1031 1
          get_option_fun #nj_semicolons () andalso
d1044 1
a1044 1
           set_option_fun #nj_semicolons true;
d1058 1
a1058 1
          not (get_option_fun #nj_semicolons ()) andalso
d1071 1
a1071 1
           set_option_fun #nj_semicolons false;
a1194 1
                bool_widget("njSemiColons", #nj_semicolons),
d1213 2
a1214 1
                bool_widget("abstractions",#abstractions)])
@


1.53
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d4 3
d1354 1
a1354 1
      handle _ => initial_item
d1380 1
d1413 1
a1413 2
	      handle ShellUtils.EditObject => message_fun "Can't edit object"
		   | ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
@


1.52
log
@Removed stepper option, commented out poly_variable and moduler options.
Also commented out default_overloads option.
@
text
@d4 4
d195 1
a195 1
require "../interpreter/shell_types";
d207 1
a207 1
  structure ShellTypes: SHELL_TYPES
d211 1
a211 1
                              = ShellTypes.Options
d223 1
a223 1
  sharing type ShellUtils.Context = ShellTypes.Context
d234 1
a234 1
  sharing type UserOptions.user_options = ShellTypes.user_options
d247 1
a247 1
  type user_context = ShellTypes.user_context
d491 1
a491 1
	      val name = ShellTypes.get_context_name c
d499 2
a500 2
	        ShellTypes.is_const_context
                (ShellTypes.getCurrentContexts())
d502 1
a502 1
               ShellTypes.getCurrentContexts()
d508 1
a508 1
        set_state (ShellTypes.copyUserContext (get_context ()))
d512 1
a512 1
          val context = ShellTypes.getNewInitialContext()
d1362 1
a1362 1
	    (ShellTypes.get_context (!current_context))
@


1.51
log
@Refinements to list manager widgets
@
text
@d4 3
d1147 1
a1150 1
                bool_widget("generateStepper", #generate_stepper),
d1152 1
d1188 2
a1189 1
                bool_widget("openFixity", #open_fixity),
d1191 1
@


1.50
log
@Added list managers
New break/trace menu
@
text
@d4 4
a727 1
        fun set_selected () = (!set_selected_hook) ()
d757 5
d828 3
a830 1
            set_list ()
d908 4
a911 3
                         [Menus.PUSH ("step",
                                      toggle_stepping,
                                      fn _ => true),
@


1.49
log
@Added rename option to context menu.
@
text
@d4 3
d181 1
d189 2
d192 2
a194 1
  structure Lists: LISTS
a197 2
  structure UserOptions: USER_OPTIONS
  structure Xm: XM 
d249 1
a249 2
                                 [(Xm.SelectionPolicy,
                                   Xm.SELECTIONPOLICY Xm.SINGLE_SELECT)])
d617 67
d687 1
a687 9
          #1(Menus.create_dialog
             (parent,
              "Breakpoints",
              "debuggerDialog",
              fn () => (),
              [Menus.OPTTEXT ("setBreakpointDialog",
                              fn () => "",
                              fn breakpoint =>
                                MLWorks.Debugger.set_breakpoint (breakpoint))]))
d713 197
d1425 2
@


1.48
log
@Made make_scrolllist handle empty lists specially.
@
text
@d4 3
d470 1
a470 1
  fun context_menu (set_state, writable) =
d476 1
a476 1
	      val name = ShellTypes.context_name c
d491 11
d503 10
a512 1
      Menus.DYNAMIC ("context", select_menu, fn _ => true)
@


1.47
log
@Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
@
text
@d4 3
d253 6
a258 1
      fun set_items print_options items =
d261 6
a266 4
         Xm.List.addItems (listList,
                           map (Xm.CompoundString.createSimple o
				  (print_fn print_options)) items,
                           0))
@


1.46
log
@Added support for propagating changes of context.
@
text
@d4 3
d455 3
a457 1
  fun context_menu set_state =
d460 18
a477 11
        let val mk_context_name =
              ShellTypes.string_context_name o ShellTypes.get_context_name

        in
          map
	    (fn c =>
               let val name = mk_context_name c
               in Menus.PUSH (name, fn _ => set_state c, fn _ => true)
               end)
            (ShellTypes.getCurrentContexts())
        end
@


1.45
log
@Added support for selections to the options menu.
@
text
@d4 3
d606 1
a606 1
    fun options_menu (parent, title, get_user_options, sense_select) =
d637 1
a637 1
	    sense_select user_options
d667 2
@


1.44
log
@Ensured that if full_menus is false, only the required menus and
dialogs are created.
@
text
@d4 4
d603 1
a603 1
    fun options_menu (parent, title, get_user_options) =
d630 2
a631 1
            val UserOptions.USER_OPTIONS (_,update_fns) = get_user_options()
d633 2
a634 1
            Lists.iterate (fn f => f ()) (!update_fns)
d656 12
d797 3
d897 1
d907 2
d929 1
d936 2
@


1.43
log
@Change to Basis.lookup_val
@
text
@d4 3
d600 3
a649 66
        fun popup_compiler_options parent =
          Menus.create_dialog
          (parent,
	   title,
           "compilerOptions",
           do_update,
           [Menus.OPTLABEL "compilerOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_widget("generateInterceptableCode", #generate_interceptable_code),
	    bool_widget("generateInterruptableCode", #generate_interruptable_code),
            bool_widget("generateDebugInfo", #generate_debug_info),
            bool_widget("generateVariableDebugInfo", #generate_variable_debug_info),
            bool_widget("generatePolyVariableDebugInfo", #generate_polyvariable_debug_info),
            bool_widget("generateStepper", #generate_stepper),
            bool_widget("generateModuler", #generate_moduler),
            bool_widget("optimizeLeafFns", #optimize_leaf_fns),
            bool_widget("optimizeTailCalls", #optimize_tail_calls),
            bool_widget("optimizeSelfTailCalls",#optimize_self_tail_calls)])
          
        fun popup_internals_options parent =
          Menus.create_dialog
          (parent,
	   title,
           "internalsOptions",
           do_update,
           [Menus.OPTLABEL "internalsOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_widget("showAbsyn",#show_absyn),
            bool_widget("showLambda",#show_lambda),
            bool_widget("showOptLambda",#show_opt_lambda),
            bool_widget("showEnviron",#show_environ),
            bool_widget("showMir",#show_mir),
            bool_widget("showOptMir",#show_opt_mir),
            bool_widget("showMach",#show_mach)])
          
        fun popup_compatibility_options parent =
          Menus.create_dialog
          (parent,
	   title,
           "compatibilityOptions",
           do_update,
           [Menus.OPTLABEL "compatibilityOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_widget("stringInequalities", #string_inequalities),
            bool_widget("infixrAssoc", #infixr_assoc),
            bool_widget("opInDatatype", #nj_op_in_datatype),
            bool_widget("njSignatures", #nj_signatures),
            bool_widget("njSemiColons", #nj_semicolons),
            bool_widget("weakTyvars", #weak_type_vars),
            bool_widget("fixitySpecs", #fixity_specs),
            bool_widget("openFixity", #open_fixity),
            bool_widget("defaultOverloads", #default_overloads)
            ])
          
        fun popup_extensions_options parent =
          Menus.create_dialog
          (parent,
	   title,
           "extensionsOptions",
           do_update,
           [Menus.OPTLABEL "extensionsOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_widget("requireKeyword",#require_keyword),
            bool_widget("typeDynamic",#type_dynamic),
            bool_widget("abstractions",#abstractions)])

d775 6
a780 16
        val (mode_dialog,mode_dialog_update) = popup_mode_options parent
        val (compiler_dialog,compiler_dialog_update) = popup_compiler_options parent
        val (valueprinter_dialog,valueprinter_dialog_update) = popup_valueprinter_options parent
        val (internals_dialog,internals_dialog_update) = popup_internals_options parent
        val (compatibility_dialog,compatibility_dialog_update) = popup_compatibility_options parent
        val (extensions_dialog,extensions_dialog_update) = popup_extensions_options parent

        fun update_dialogues () =
          Lists.iterate 
          (fn f => f ()) 
          [mode_dialog_update,
           compiler_dialog_update,
           valueprinter_dialog_update,
           internals_dialog_update,
           compatibility_dialog_update,
           extensions_dialog_update]
d784 132
a915 28
	  (* This code creates the dialogs when the menu is created.
	     This prevents the same dialog being created twice for
	     the same window, but is wasteful. *)
        (Menus.CASCADE ("options",
                        Menus.PUSH ("mode",
                                    mode_dialog,
                                    fn _ => true)
                        :: Menus.PUSH ("valueprinter",
                                       valueprinter_dialog,
                                       fn _ => true)
			:: (if !(#full_menus options) then
			      [Menus.SEPARATOR,
                               Menus.PUSH ("compiler",
                                           compiler_dialog,
                                           fn _ => true),
                               Menus.PUSH ("compatibility",
                                           compatibility_dialog,
                                           fn _ => true),
                               Menus.PUSH ("extensions",
                                           extensions_dialog,
                                           fn _ => true),
                               Menus.PUSH ("internals",
                                           internals_dialog,
                                           fn _ => true)]
			    else
			      nil),
                          fn _ => true),
        update_dialogues)
@


1.42
log
@Adding value menu implementation ...
@
text
@d4 3
d951 4
a954 3
	  #1(Basis.lookup_val
	       (Ident.NOPATH, valid, tycontext,
		Ident.Location.UNKNOWN, false))
@


1.41
log
@Revised editor preference dialog.
@
text
@d4 3
d154 1
d156 2
d163 2
a164 1
  structure Xm: XM 
d167 2
d170 11
a180 1
  structure ShellTypes: SHELL_TYPES
d182 16
d200 4
d892 157
@


1.40
log
@Cut down menus for novices.
@
text
@d4 3
d444 1
a444 1
                             		"emacs" => true
d446 12
a457 3
                             fn false => set_option_fun (#editor) "vi"
                              | true => set_option_fun (#editor) "emacs"),
            Menus.OPTTOGGLE ("select_vi",
d459 1
a459 1
  			                "vi" => true
d461 5
a465 2
                             fn true => set_option_fun (#editor) "vi"
                              | false => set_option_fun (#editor) "emacs")])
@


1.39
log
@Replaced ContextRef with user_context.
@
text
@d4 3
d451 1
d453 35
a487 23
          Menus.create_dialog
          (parent,
           "Global Preferences",
	   "environmentOptions",
           preference_update,
           [Menus.OPTLABEL "environmentOptionsLabel",
            Menus.OPTSEPARATOR,
            Menus.OPTINT ("maximumHistoryLength",
                          fn () => get_option_fun (#history_length) (),
                          fn x => set_option_fun (#history_length) x),
            Menus.OPTINT ("maximumNumberErrors",
			  fn () => get_option_fun (#max_num_errors) (),
			  fn x  => set_option_fun (#max_num_errors) x),
	    Menus.OPTTOGGLE ("windowDebugger",
                             fn () => get_option_fun (#window_debugger) (),
                             fn x => set_option_fun (#window_debugger) x),
            Menus.OPTTOGGLE ("autoOutputWindow",
                             fn () => get_option_fun (#auto_output_window) (),
                             fn x => set_option_fun (#auto_output_window) x),
            Menus.OPTTOGGLE ("completionMenu",
                             fn () => get_option_fun (#completion_menu) (),
                             fn x => set_option_fun (#completion_menu) x)
            ])
d794 2
d801 22
a822 19
                         [Menus.PUSH ("mode",
                                      mode_dialog,
                                      fn _ => true),
			  Menus.SEPARATOR,
                          Menus.PUSH ("compiler",
                                      compiler_dialog,
                                      fn _ => true),
                          Menus.PUSH ("valueprinter",
                                      valueprinter_dialog,
                                      fn _ => true),
                          Menus.PUSH ("internals",
                                      internals_dialog,
                                      fn _ => true),
                          Menus.PUSH ("compatibility",
                                      compatibility_dialog,
                                      fn _ => true),
                          Menus.PUSH ("extensions",
                                      extensions_dialog,
                                      fn _ => true)],
@


1.38
log
@Added default_overloads option.
@
text
@d4 3
d164 1
a164 1
  type ContextRef = ShellTypes.ContextRef
@


1.37
log
@Added breakpoints menu.
@
text
@d4 3
d618 2
a619 1
            bool_widget("openFixity", #open_fixity)
@


1.36
log
@Step and Modules Debugger compiler options.
@
text
@d4 3
d477 38
@


1.35
log
@Added maximum_str_depth to options.
@
text
@d4 3
d537 2
@


1.34
log
@Added context_menu function.
@
text
@d4 3
d517 2
a518 1
            int_widget("maximumRefDepth",#maximum_ref_depth)
@


1.33
log
@*** empty log message ***
@
text
@d1 2
a2 1
(*
d4 3
d131 1
d140 1
d149 1
d378 18
@


1.32
log
@Added max_num_errors
@
text
@d3 3
d421 1
a421 1
			  fn x  => set_option_fun (#max_num_errors) x)
@


1.31
log
@Added handler for SubLoopTerminated in with_message -- otherwise we try and
set the cursor of a window after Motif has exitted.
Changed outstreams so a line at a time is printed.  Scrolling behaviour is bas
 bad otherwise.
@
text
@d3 6
d416 4
a419 1
            Menus.OPTTOGGLE ("windowDebugger",
@


1.30
log
@Change to outstream arguments.
@
text
@d3 3
d135 2
d251 14
d266 1
a266 1
        let val result = !outbuff
d269 1
a269 1
          insert_text (implode(rev(result)))
d353 3
a355 1
      val result = f () handle exn => (Xm.Widget.unSetBusy parent; raise exn)
@


1.29
log
@Added menu iterm for generating interruptable code
.\
@
text
@d3 4
d270 2
a271 1
                            close_out = fn () => ()}
@


1.28
log
@Merged in bug fix.
@
text
@d3 3
d463 1
@


1.27
log
@Merging in bug fixes
@
text
@d3 3
d12 3
d445 2
a446 1
            int_widget("maximumListSize",#maximum_list_size),
@


1.26
log
@New compiler option debug_polyvariables for polymorphic debugger.
@
text
@d3 3
d9 4
d286 2
d612 1
a612 1
          not (get_option_fun #generate_variable_debug_info ()) andalso
d674 12
@


1.25
log
@Merged in bug fix.
@
text
@d3 3
d446 1
@


1.24
log
@Rationalized mode option functions
@
text
@d3 9
d166 1
a166 1
  fun list_select (parent,items,select_fn,print_fn) =
d168 1
a168 1
      val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME "listDialog",
@


1.24.1.1
log
@Fork for bug fixing
@
text
@a2 3
 *  Revision 1.24  1993/08/24  12:16:17  matthew
 *  Rationalized mode option functions
 *
@


1.24.1.2
log
@Added name parameter to MotifUtils.list_select.
@
text
@a2 3
 *  Revision 1.24.1.1  1993/08/24  12:16:17  jont
 *  Fork for bug fixing
 *
d160 1
a160 1
  fun list_select (parent,name,items,select_fn,print_fn) =
d162 1
a162 1
      val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME name,
@


1.24.1.3
log
@Added cut buffer utilities
> Added beep & cut buffer utilities
Fixed problem with generate_variable_debug_info and debugging mode
@
text
@a2 3
 *  Revision 1.24.1.2  1993/09/10  11:12:21  daveb
 *  Added name parameter to MotifUtils.list_select.
 *
a272 2
  fun beep widget = Xm.Display.bell (Xm.Widget.display widget,100)

d596 1
a596 1
	  (* get_option_fun #generate_variable_debug_info () andalso *)
a657 12

    val cut_buffer = ref ""

    fun cutSelection text_widget =
      (cut_buffer := Xm.Text.getSelection text_widget;
       Xm.Text.removeSelection text_widget)

    fun copySelection text_widget =
      cut_buffer := Xm.Text.getSelection text_widget

    fun pasteSelection text_widget =
      Xm.Text.insert (text_widget,Xm.Text.getInsertionPosition text_widget,!cut_buffer)
@


1.24.1.4
log
@Changed print options.
@
text
@a2 5
 *  Revision 1.24.1.3  1993/10/08  10:29:28  matthew
 *  Added cut buffer utilities
 *  > Added beep & cut buffer utilities
 *  Fixed problem with generate_variable_debug_info and debugging mode
 *
d429 1
a429 2
            int_widget("maximumSeqSize",#maximum_seq_size),
            int_widget("maximumStringSize",#maximum_string_size),
@


1.23
log
@Removed core-only and functional options, since they didn't do anything.
@
text
@d3 3
d494 1
a494 1
          not (get_option_fun #abstractions ()) andalso
d507 1
a507 1
           set_option_fun #abstractions false;
d568 5
a572 5
           set_option_fun #optimize_self_tail_calls true;
           set_option_fun #generate_debug_info false;
           set_option_fun #generate_variable_debug_info false;
           set_option_fun #generate_interceptable_code false)
	|   optimizing false = ()
d577 1
a577 4
          get_option_fun #optimize_self_tail_calls () andalso
          not (get_option_fun #generate_debug_info ()) andalso
          not (get_option_fun #generate_variable_debug_info ()) andalso
          not (get_option_fun #generate_interceptable_code ())
d580 2
a581 5
	  (set_option_fun #optimize_leaf_fns false;
           set_option_fun #optimize_tail_calls false;
           set_option_fun #optimize_self_tail_calls false;
           set_option_fun #generate_debug_info true;
           set_option_fun #generate_variable_debug_info false;
d583 4
a586 1
	|   debugging false = ()
a588 3
	  not (get_option_fun #optimize_leaf_fns ()) andalso
          not (get_option_fun #optimize_tail_calls ()) andalso
          not (get_option_fun #optimize_self_tail_calls ()) andalso
d590 1
a590 1
          not (get_option_fun #generate_debug_info ()) andalso
d606 1
a606 1
	    Menus.OPTRADIO
@


1.22
log
@Changes for automatic option menu updating
@
text
@d3 3
a463 3
	    (* Hide this from the user, as we haven't implemented it yet.
            bool_widget("derivedRedef", #derived_redef),
	    *)
d466 1
a466 3
            bool_widget("openFixity", #open_fixity),
            bool_widget("coreOnly", #core_only),
            bool_widget("functional", #functional)
@


1.21
log
@Extended environment menu
@
text
@d3 3
d299 2
d305 1
a305 1
            val UserOptions.USER_OPTIONS options = get_user_options()
d312 1
a312 1
            val UserOptions.USER_OPTIONS options = get_user_options()
d316 1
a316 1
            
d322 1
d342 1
d358 2
d363 1
a363 1
                                      popup_editor_options parent,
d366 1
a366 1
                                      popup_environment_options parent,
d375 1
a375 1
            val UserOptions.USER_OPTIONS options = get_user_options()
d382 1
a382 1
            val UserOptions.USER_OPTIONS options = get_user_options()
d392 9
a400 2
              
        fun popup_print_options parent =
d405 1
d422 1
d437 1
d453 1
d476 1
d603 1
d614 16
a629 1

d634 1
a634 1
          Menus.CASCADE ("options",
d636 1
a636 1
                                      popup_mode_options parent,
d640 1
a640 1
                                      popup_compiler_options parent,
d643 1
a643 1
                                      popup_print_options parent,
d646 1
a646 1
                                      popup_internals_options parent,
d649 1
a649 1
                                      popup_compatibility_options parent,
d652 1
a652 1
                                      popup_extensions_options parent,
d654 2
a655 1
                          fn _ => true)
@


1.20
log
@New compiler option generateVariableDebugInfo in options menu.
@
text
@d3 3
d338 4
a341 1
            Menus.OPTTOGGLE ("window_debugger",
d343 8
a350 1
                             fn x => set_option_fun (#window_debugger) x)])
@


1.19
log
@Changed strict option to standard
@
text
@d3 3
d396 1
d535 1
d544 1
d552 1
d561 1
@


1.18
log
@Added (unworking and deleted) with_message function
Added working with_message function that sets the cursor to busy
@
text
@d3 4
d455 1
d468 1
d482 1
d495 1
d499 1
a499 1
	fun is_strict _ =
d509 1
d512 1
a512 1
	fun strict true =
d522 1
d524 1
a524 1
	|   strict false = ()
d565 1
a565 1
               Menus.OPTTOGGLE ("strict", is_strict, strict),
@


1.17
log
@Added open_fixity and fixity_specs options
@
text
@d3 3
d246 38
@


1.16
log
@Removed cancel and help buttons from message boxes.
@
text
@d3 3
d383 2
d408 2
d420 2
d433 2
d445 2
d458 2
d470 2
@


1.15
log
@Added environment options to preferences
@
text
@d3 3
d227 8
@


1.14
log
@Return exit function from list_select
Added bool ref to control destruction of list select widget
@
text
@d3 4
d266 10
d280 3
@


1.13
log
@Revised some exceptions and added Mode dialog box.
@
text
@d3 3
d130 2
a131 1
      fun exit _ = Xm.Widget.destroy shell
d174 2
a175 1
      Xm.Widget.manage form
@


1.12
log
@Changed names of scrolllist widgets to simplify the specification
of resources.
@
text
@d3 4
a299 1
            int_widget("maximumShapeDepth",#maximum_shape_depth),
a302 8
        fun popup_environment_options parent =
          Menus.create_dialog
          (parent,
	   title,
           "environmentOptions",
           [Menus.OPTLABEL "environmentOptionsLabel",
            Menus.OPTSEPARATOR])
          
d312 3
a314 4
            bool_widget("showDebugWarnings", #show_debug_warnings),
            bool_widget("optimiseLeafFns", #optimise_leaf_fns),
            bool_widget("optimiseTailCalls", #optimise_tail_calls),
            bool_widget("optimiseSelfTailCalls",#optimise_self_tail_calls)])
d340 9
a348 5
            bool_widget("opInDatatype", #op_in_datatype),
            bool_widget("njInclude", #nj_include),
            bool_widget("njOpen", #nj_local_open),
            bool_widget("semiColons", #semicolons),
            bool_widget("derivedRedef", #derived_redef)
d359 112
a470 1
            bool_widget("typeDynamic",#type_dynamic)])
d476 5
a480 1
                         [Menus.PUSH ("compiler",
@


1.11
log
@options_menu now takes a string to use for the title of the options
dialogs.
@
text
@d3 4
d63 1
a63 1
      val listScroll = Xm.Widget.createManaged(Xm.Widget.NAME (name ^ "Scroll"),
d67 1
a67 1
        Xm.Widget.createManaged (Xm.Widget.NAME (name ^ "List"),
d238 1
a238 1
	   "dialogShell",
@


1.10
log
@Added comment about profligracy in creation of options menus.
@
text
@d3 3
d233 2
a234 1
           "editorOptions",
d257 1
a257 1
    fun options_menu (parent, get_user_options) =
d282 1
d299 1
d307 1
d321 1
d336 1
d352 1
a357 1
          
@


1.9
log
@Added make_outstream.
@
text
@d3 3
d28 3
a30 3
Revision 1.1  1993/04/21  14:40:52  daveb
Initial revision

d350 3
@


1.8
log
@Added fileselect function
@
text
@d3 3
d157 31
@


1.7
log
@Moved Editor options dialog to new setup menu.
@
text
@d3 3
d103 51
@


1.6
log
@Unified profiling and tracing options into `intercept'.
Removed poly_makestring option.
@
text
@d3 4
d120 42
a257 18
        fun popup_editor_options parent =
          Menus.create_dialog
          (parent,
           "editorOptions",
           [Menus.OPTLABEL "editorOptionsLabel",
            Menus.OPTSEPARATOR,
            Menus.OPTTOGGLE ("select_emacs",
                             fn () => case get_option_fun (#editor) () of
                             "emacs" => true
  			     | _ => false,
                               fn false => set_option_fun (#editor) "vi"
                                | true => set_option_fun (#editor) "emacs"),
            Menus.OPTTOGGLE ("select_vi",
                             fn () => case get_option_fun (#editor) () of
  			       "vi" => true
  			     | _ => false,
                               fn true => set_option_fun (#editor) "vi"
                                | false => set_option_fun (#editor) "emacs")])
a273 3
                                      fn _ => true),
                          Menus.PUSH ("editor",
                                      popup_editor_options parent,
@


1.5
log
@Changes to make_scrolllist.
@
text
@d3 3
d167 1
a167 2
            bool_widget("generateTracingCode", #generate_tracing_code),
            bool_widget("generateProfilingCode", #generate_profiling_code),
a194 1
            bool_widget("polyMakestring", #poly_makestring),
@


1.4
log
@Added options_menu code from _listener and _fileselect.
@
text
@d3 3
d32 2
d38 1
a38 1
  fun make_scrolllist (parent, name, select_fun, action_fun, print_fun) =
d59 1
a59 1
      fun set_items items =
d63 2
a64 1
                           map (Xm.CompoundString.createSimple o print_fun) items,
d67 2
a68 2
      val select_fun' = select_fun (listScroll, listList,  set_items)
      val action_fun' = action_fun (listScroll, listList,  set_items)
d70 1
a70 1
      fun select_callback_fun callback_data =
d74 1
a74 1
          select_fun' (Lists.nth (pos-1,!itemlistref))
d78 1
a78 1
      fun action_callback_fun callback_data =
d82 1
a82 1
          action_fun' (Lists.nth (pos-1,!itemlistref))
d88 1
a88 1
                             select_callback_fun);
d91 1
a91 1
                             action_callback_fun);
@


1.3
log
@Added send message function
@
text
@d3 3
d17 2
d24 3
d30 2
d106 140
@


1.2
log
@Whoops.  Gave myself a fright there.  Checked in an old version.
@
text
@d3 3
d77 18
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
 * $Log$
a27 2
				 parent,
				 (*
a28 1
				 *)
@
