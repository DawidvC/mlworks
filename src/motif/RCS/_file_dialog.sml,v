head	1.38;
access;
symbols
	MLW_daveb_inline_1_4_99:1.38.1
	MLWorks_21c0_1999_03_25:1.38
	MLWorks_20c1_1998_08_20:1.38
	MLWorks_20c0_1998_08_04:1.37
	MLWorks_20b2c2_1998_06_19:1.37
	MLWorks_20b2_Windows_1998_06_12:1.37
	MLWorks_20b1c1_1998_05_07:1.36
	MLWorks_20b0_1998_04_07:1.36
	MLWorks_20b0_1998_03_20:1.36
	MLWorks_20m2_1998_02_16:1.35
	MLWorks_20m1_1997_10_23:1.34
	MLWorks_11r1:1.31.1.2.1.1.1
	MLWorks_workspace_97:1.33.2
	MLWorks_dt_wizard:1.33.1
	MLWorks_11c0_1997_09_09:1.31.1.2.1.1
	MLWorks_10r3:1.31.1.2.3
	MLWorks_10r2_551:1.31.1.2.2
	MLWorks_11:1.31.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.31.1.2
	MLWorks_20m0_1997_06_20:1.33
	MLWorks_1_0_r2c2_1997_06_14:1.31.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.31.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.31.1
	MLWorks_BugFix_1997_04_24:1.31
	MLWorks_1_0_r2_Win32_1997_04_11:1.31
	MLWorks_1_0_r2_Unix_1997_04_04:1.31
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.26.3.1.1
	MLWorks_gui_1996_12_18:1.26.4
	MLWorks_1_0_Win32_1996_12_17:1.26.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.26.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.26.1.1
	MLWorks_1_0_Irix_1996_11_28:1.26.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.26.2
	MLWorks_1_0_Unix_1996_11_14:1.26.1
	MLWorks_Open_Beta2_1996_10_11:1.24.3
	MLWorks_License_dev:1.24.2
	MLWorks_1_open_beta_1996_09_13:1.24.1
	MLWorks_Open_Beta_1996_08_22:1.24
	MLWorks_Beta_1996_07_02:1.24
	MLWorks_Beta_1996_06_07:1.24
	MLWorks_Beta_1996_06_06:1.24
	MLWorks_Beta_1996_06_05:1.24
	MLWorks_Beta_1996_06_03:1.24
	MLWorks_Beta_1996_05_31:1.24
	MLWorks_Beta_1996_05_30:1.24
	ML_beta_release_12/08/94:1.2
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.38
date	98.08.07.09.38.31;	author johnh;	state Exp;
branches
	1.38.1.1;
next	1.37;

1.37
date	98.06.01.17.23.49;	author johnh;	state Exp;
branches;
next	1.36;

1.36
date	98.02.19.10.46.00;	author mitchell;	state Exp;
branches;
next	1.35;

1.35
date	98.01.27.16.28.02;	author johnh;	state Exp;
branches;
next	1.34;

1.34
date	97.09.18.12.46.10;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	97.05.02.17.17.52;	author jont;	state Exp;
branches
	1.33.1.1
	1.33.2.1;
next	1.32;

1.32
date	97.04.29.16.18.03;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	97.04.04.13.10.02;	author johnh;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	97.04.01.10.33.04;	author johnh;	state Exp;
branches;
next	1.29;

1.29
date	97.02.26.14.05.35;	author johnh;	state Exp;
branches;
next	1.28;

1.28
date	97.02.06.13.35.54;	author johnh;	state Exp;
branches;
next	1.27;

1.27
date	97.02.06.11.45.47;	author johnh;	state Exp;
branches;
next	1.26;

1.26
date	96.11.01.17.47.48;	author daveb;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1
	1.26.4.1;
next	1.25;

1.25
date	96.10.09.12.02.01;	author io;	state Exp;
branches;
next	1.24;

1.24
date	96.05.23.12.17.16;	author stephenb;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1;
next	1.23;

1.23
date	96.05.17.16.09.39;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	96.05.01.10.34.38;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	96.04.18.15.19.25;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	96.04.12.08.54.55;	author stephenb;	state Exp;
branches;
next	1.19;

1.19
date	96.03.27.12.17.55;	author stephenb;	state Exp;
branches;
next	1.18;

1.18
date	96.03.15.14.37.46;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	96.03.15.14.37.46;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	96.03.01.17.45.11;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	96.02.26.15.24.33;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	96.01.18.10.31.10;	author stephenb;	state Exp;
branches;
next	1.13;

1.13
date	96.01.12.12.16.39;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	96.01.12.11.50.34;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	96.01.10.13.58.08;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	95.12.13.12.16.40;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.07.27.11.02.58;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.07.26.13.59.54;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.07.03.10.53.32;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.05.22.15.30.47;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.04.13.17.53.28;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.04.06.15.59.59;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.01.16.13.56.17;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	94.07.11.11.03.34;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	94.06.30.18.01.32;	author daveb;	state Exp;
branches;
next	;

1.24.1.1
date	96.09.13.11.19.59;	author hope;	state Exp;
branches;
next	;

1.24.2.1
date	96.10.07.16.09.53;	author hope;	state Exp;
branches;
next	;

1.24.3.1
date	96.10.17.11.28.13;	author hope;	state Exp;
branches;
next	;

1.26.1.1
date	96.11.14.12.53.52;	author hope;	state Exp;
branches
	1.26.1.1.1.1;
next	;

1.26.1.1.1.1
date	96.11.28.15.04.47;	author hope;	state Exp;
branches;
next	;

1.26.2.1
date	96.11.22.18.12.45;	author hope;	state Exp;
branches;
next	;

1.26.3.1
date	96.12.17.17.51.14;	author hope;	state Exp;
branches
	1.26.3.1.1.1;
next	;

1.26.3.1.1.1
date	97.02.24.11.41.43;	author hope;	state Exp;
branches;
next	;

1.26.4.1
date	96.12.18.09.45.28;	author hope;	state Exp;
branches;
next	;

1.31.1.1
date	97.05.12.10.37.57;	author hope;	state Exp;
branches;
next	1.31.1.2;

1.31.1.2
date	97.05.13.11.03.15;	author daveb;	state Exp;
branches
	1.31.1.2.1.1
	1.31.1.2.2.1
	1.31.1.2.3.1;
next	;

1.31.1.2.1.1
date	97.07.28.18.23.05;	author daveb;	state Exp;
branches
	1.31.1.2.1.1.1.1;
next	;

1.31.1.2.1.1.1.1
date	97.10.07.11.48.48;	author jkbrook;	state Exp;
branches;
next	;

1.31.1.2.2.1
date	97.09.08.17.16.29;	author daveb;	state Exp;
branches;
next	;

1.31.1.2.3.1
date	97.09.09.14.12.28;	author daveb;	state Exp;
branches;
next	;

1.33.1.1
date	97.09.10.19.28.29;	author brucem;	state Exp;
branches;
next	;

1.33.2.1
date	97.09.11.20.58.25;	author daveb;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	97.09.12.14.44.13;	author johnh;	state Exp;
branches;
next	;

1.38.1.1
date	99.04.01.17.58.57;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.38
log
@[Bug #50096]
When selecting a directory, the dialog title should be 'Directory selection dialog'.
@
text
@(*
 *  Copyright (c) 1994 Harlequin Ltd.
 *  $Log: _file_dialog.sml,v $
 * Revision 1.37  1998/06/01  17:23:49  johnh
 * [Bug #30369]
 * Replace source path with a list of files.
 *
 * Revision 1.36  1998/02/19  10:46:00  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.35  1998/01/27  16:28:02  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.34  1997/09/18  12:46:10  daveb
 * [Bug #30077]
 * Force the ScrollBarDisplayPolicy of the file list to be static, so that the
 * horizontal scrollbar is always displayed.  This is necessary for Sun's
 * implementation of Motif -- other implementations seem to get it right.
 *
 * Revision 1.33.2.2  1997/09/12  14:44:13  johnh
 * [Bug #30071]
 * Implement new Project Workspace tool.
 * Allow non-existing directories to be created.
 *
 * Revision 1.33  1997/05/02  17:17:52  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.32  1997/04/29  16:18:03  jont
 * [Bug #20024]
 * Fix saving images to files which don't exist yet.
 * Also give as good as possible warnings for other file access failures.
 * Remove all instances of silent failure where the dailog simply stays.
 *
 * Revision 1.31  1997/04/04  13:10:02  johnh
 * [Bug #2024]
 * Using OS.FileSys.isDir to check for invalid paths.
 *
 * Revision 1.30  1997/04/01  10:33:04  johnh
 * [Bug #1769]
 * Added a browse selection callback to get the selected text.
 *
 * Revision 1.29  1997/02/26  14:05:35  johnh
 * [Bug #1300]
 * Reintroduced a bug fix concerning the directory changing.
 *
 * Revision 1.28  1997/02/06  13:35:54  johnh
 * Undo last bug fixes as the Win32 equivalent fix didn't work.
 * Better to keep the functionality of the two platforms as similar as possible.
 *
 * Revision 1.26  1996/11/01  17:47:48  daveb
 * [Bug #1694]
 * Converted Xm.CompoundString.string_convert_text to standard convention.
 *
 * Revision 1.25  1996/10/09  12:02:01  io
 * moving String from toplevel
 *
 * Revision 1.24  1996/05/23  12:17:16  stephenb
 * Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
 * now does what the former used to do.
 *
 * Revision 1.23  1996/05/17  16:09:39  daveb
 * Replaced  Os.FileSys.getDir with the string ".", added a handler for realPath
 * (needed for files that don't exist yet), and added a missing "*" to the mask.
 *
 * Revision 1.22  1996/05/01  10:34:38  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.21  1996/04/18  15:19:25  jont
 * initbasis moves to basis
 *
 * Revision 1.20  1996/04/12  08:54:55  stephenb
 * Rename Os -> OS to conform with latest basis revision.
 *
 * Revision 1.19  1996/03/27  12:17:55  stephenb
 * Update in accordance with the latest revised basis.
 *
 * Revision 1.18  1996/03/15  14:37:46  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.16  1996/03/01  17:45:11  daveb
 * Removed file selection list from directory dialog.
 *
 * Revision 1.15  1996/02/26  15:24:33  matthew
 * Revisions to Xm library
 *
 * Revision 1.14  1996/01/18  10:31:10  stephenb
 * OS reorganisation: parameterise functor with UnixOS since all
 * OS specific stuff has been removed from the pervasive library.
 *
 * Revision 1.13  1996/01/12  12:16:39  daveb
 * Moved file_dialog from gui to motif.
 *
 * Revision 1.12  1996/01/12  11:50:34  daveb
 * Added separate open_dir_dialog function.
 *
 * Revision 1.11  1996/01/10  13:58:08  daveb
 * Added open_file_dialog and save_as_dialog, for compatibility with Windows.
 *
 * Revision 1.10  1995/12/13  12:16:40  daveb
 * Added mask and file_type arguments.
 *
 * Revision 1.9  1995/07/27  11:02:58  matthew
 * Moved file_dialog to gui
 *
 * Revision 1.8  1995/07/26  13:59:54  matthew
 * Restructuring gui directories
 *
 *  Revision 1.7  1995/07/03  10:53:32  matthew
 *  Capification
 *
 *  Revision 1.6  1995/05/22  15:30:47  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.5  1995/04/13  17:53:28  daveb
 *  Xm.doInput is back to taking unit.
 *  
 *  Revision 1.4  1995/04/06  15:59:59  daveb
 *  Type of Xm.doInput has changed.
 *  
 *  Revision 1.3  1995/01/16  13:56:17  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *  
 *  Revision 1.2  1994/07/11  11:03:34  daveb
 *  Replaced TextString with DirSpec.
 *  
 *  Revision 1.1  1994/06/30  18:01:32  daveb
 *  new file
 *  
 *)

require "../utils/__terminal";

require "../motif/xm";
require "../main/info";
require "../basis/os";
require "../utils/__lists";

require "file_dialog";

functor FileDialog(
  structure Xm : XM
  structure Info : INFO
  structure OS : OS
) : FILE_DIALOG =
struct
  structure Location = Info.Location
  type Widget = Xm.widget

  datatype FileType = DIRECTORY | FILE 

  datatype exist = MUST_EXIST | MAY_EXIST

(* These two references store the last directory visited within the file
   selection box, and the last file system directory (ie. as set by 
   OSFileSys.chDir).  
   When the directory mask is set these references are used as follows: if
   the file system has recently changed use this new file system directory
   as the initial directory within the file selection box, otherwise use
   the last directory visited by the file selection box.  The last visited
   directory reference is only changed when the user clicks on OK. *)
  val last_visit_dir = ref "./"
  val last_filesys_dir = ref (OS.FileSys.getDir())
    handle OS.SysErr _ => ref "./"

  (* This function is copied from Capi *)
  fun send_message (parent,message) =
    let
      val dialog =
        Xm.Widget.createPopupShell ("messageDialog",
                                    Xm.Widget.DIALOG_SHELL,
                                    parent, [])
            
      val widget =
        Xm.Widget.create
        ("message", Xm.Widget.MESSAGE_BOX, dialog,
         [(Xm.MESSAGE_STRING, Xm.COMPOUND_STRING (Xm.CompoundString.createSimple message))])

      val _ =
        map 
         (fn c =>
           Xm.Widget.unmanageChild (Xm.MessageBox.getChild(widget,c)))
         [Xm.Child.CANCEL_BUTTON,
          Xm.Child.HELP_BUTTON]

      (* This really ought to reuse dialogs *)
      fun exit _ = Xm.Widget.destroy dialog
    in
      Xm.Callback.add (widget, Xm.Callback.OK, exit);
      Xm.Widget.manage widget
    end

  fun crash s =
    Info.default_error'
      (Info.FAULT,Location.UNKNOWN,s)

  fun find_files (parent, mask: string, file_type: FileType, exist, multi) =
    let
      val title = 
	case file_type of 
	  FILE      => "File Selection Dialog"
	| DIRECTORY => "Directory Selection Dialog"

      (*** Make the windows ***)
      val shell =
        Xm.Widget.createPopupShell ("fileDialog",
                                    Xm.Widget.DIALOG_SHELL,
                                    parent,
                                    [(Xm.TITLE, Xm.STRING title),
                                     (Xm.ICON_NAME, Xm.STRING title)])

      val filesys_dir = OS.FileSys.getDir()
	handle OS.SysErr _ => !last_filesys_dir

      val box = Xm.Widget.create
        ("selectionBox",
         Xm.Widget.FILE_SELECTION_BOX,
         shell, [])

      fun set_mask s =
        (Xm.Widget.valuesSet
         (box,
          [(Xm.DIR_MASK,
            Xm.COMPOUND_STRING
            (Xm.CompoundString.createSimple s))]))

      (* We now pass the complete directory in as the argument,
         so that file dialogs can be popped up in specific places. 
	 Note though that we only want the file dialog to pop up in 
	 the last visited directory when searching for files, because
	 when setting the current directory we want the file dialog
	 to initially show the current file system directory as 
	 opposed to the last visited directory. *)
      val setLastDir = (!last_filesys_dir <> filesys_dir) orelse
			((file_type = DIRECTORY) andalso (exist = MUST_EXIST))

      val _ = if setLastDir then 
	  (last_filesys_dir := filesys_dir;
	  last_visit_dir := filesys_dir;
	  set_mask(!last_filesys_dir ^ "/*" ^ mask))
	else
	  set_mask(!last_visit_dir ^ "/*" ^ mask)
      (* This used to call OS.FileSys.getDir(), but this seems to be
	 unnecessary.  If you reinstate OS.FileSys.getDir(), be sure
	 to add a handler of OS.SysErr. *)

      fun get_dir() = 
        (case Xm.Widget.valuesGet(box,[Xm.DIRECTORY]) of
           [Xm.COMPOUND_STRING filename] =>
              Xm.CompoundString.convertStringText filename
         | _ => crash "Bad values for valuesGet (get_dir)")

      val current_sel = ref NONE

      (* This pulls the selected filename out of the file selection box *)
      fun get_files () =
	if (multi) then 
	  getOpt (!current_sel, [])
	else
          (case Xm.Widget.valuesGet(box,[Xm.DIR_SPEC]) of
             [Xm.COMPOUND_STRING filename] =>
                [Xm.CompoundString.convertStringText filename]
           | _ => crash "Bad values for valuesGet (get_file)")

      (* Here we remove the Help button.  Don't remove the apply or ok buttons:
	 the behaviour of the file selection box breaks if you do. *)
      val _ =
        Xm.Widget.unmanageChild
	  (Xm.FileSelectionBox.getChild (box, Xm.Child.HELP_BUTTON))

      val _ =
	if file_type = DIRECTORY then
	  (app 
             Xm.Widget.unmanageChild
	     [Xm.Widget.parent
	        (Xm.FileSelectionBox.getChild(box,Xm.Child.LIST)),
	      Xm.FileSelectionBox.getChild(box,Xm.Child.LIST_LABEL)];
	   ())
	else if (multi) then
	  app
	    Xm.Widget.unmanageChild
	    [Xm.Widget.parent
		(Xm.FileSelectionBox.getChild(box,Xm.Child.TEXT)),
	     Xm.FileSelectionBox.getChild(box,Xm.Child.TEXT),
	     Xm.FileSelectionBox.getChild(box,Xm.Child.SELECTION_LABEL)]
	else ()

      fun filterChanged callback_data = 
	if (multi) then 
	  current_sel := NONE
	else
          let 
	    val text_w = Xm.FileSelectionBox.getChild (box, Xm.Child.TEXT)
	    val sel_text = #3 (Xm.Callback.convertList callback_data)
	  in
	    Xm.Text.setString (text_w, (Xm.CompoundString.convertStringText sel_text) ^ "/")
	  end

      fun selectionMade callback_data = 
	let 
	  val selection = 
	    map Xm.CompoundString.convertStringText (#6 (Xm.Callback.convertList callback_data))
	in
	  current_sel := SOME selection
	end

      val _ = 
	if file_type = DIRECTORY then
	  Xm.Callback.add 
	    (Xm.FileSelectionBox.getChild (box, Xm.Child.DIR_LIST),
	     Xm.Callback.BROWSE_SELECTION,
	     filterChanged)
	else if (multi) then
	  let 
	    val file_list_w = Xm.FileSelectionBox.getChild (box, Xm.Child.FILE_LIST)
	  in
	    Xm.Widget.valuesSet(file_list_w, [(Xm.SELECTION_POLICY, Xm.SELECTION_POLICY_VALUE Xm.EXTENDED_SELECT)]);
	    Xm.Callback.add
	      (Xm.FileSelectionBox.getChild (box, Xm.Child.DIR_LIST),
	       Xm.Callback.BROWSE_SELECTION,
	       fn _ => current_sel := NONE);
	    Xm.Callback.add
	      (file_list_w,
	       Xm.Callback.EXTENDED_SELECTION,
	       selectionMade)
	  end
	else ()

      val result = ref NONE
      val continue = ref true

    in
      (* Force the displayPolicy of the files list to be static, so that
       * the horizontal scroll bar is displayed correctly on Solaris.
       *)
      Xm.Widget.valuesSet
        (Xm.FileSelectionBox.getChild (box, Xm.Child.LIST),
         [(Xm.SCROLLBAR_DISPLAY_POLICY,
           Xm.SCROLLBAR_DISPLAY_POLICY_VALUE Xm.STATIC)]);
      Xm.Callback.add
        (box,
         Xm.Callback.CANCEL,
         fn _ => 
           (result := NONE;
	    continue := false;
            Xm.Widget.destroy shell));
      Xm.Callback.add
        (box,
         Xm.Callback.OK,
         fn _ => 
           let
	     val files = get_files ()
	     fun filename_ok filename =
	       ((if OS.FileSys.access(filename, []) then
		   (* The file exists, check it's correct type *)
		   case (file_type, OS.FileSys.isDir filename) of
		     (DIRECTORY, true) => true
		   | (FILE, false) => true
		   | (DIRECTORY, false) =>
		       (send_message(shell, "Directory " ^ filename ^
				     " is a file");
			false)
		   | _ =>
		       (send_message(shell, "File " ^ filename ^
				     " is a directory");
			false)
		 else
		   (* No file *)
		   case (file_type, exist) of
		     (_, MUST_EXIST) =>
		       (send_message(shell, "Path " ^ filename ^
				     " does not exist");
			false)
		   | (DIRECTORY, MAY_EXIST) =>
		       ((let 
			  val isDir = OS.FileSys.isDir filename
		        in
			  if not isDir then 
			    (send_message(shell, "Directory " ^
					  filename ^ " is a file");
			     false)
			  else 
			    true
			end)
			handle OS.SysErr _ => 
			  (OS.FileSys.mkDir filename; true))

		   | (FILE, _) =>
		       let
			 val path = OS.Path.dir filename
		       in
			 (if OS.FileSys.isDir path then
			    true
			  else
			    (send_message(shell, "Directory " ^
					  filename ^ " is a file");
			     false))
			    handle OS.SysErr _ =>
			      (send_message(shell, "Path " ^ path ^
					    " does not exist");
			       false)
		       end))
		   handle OS.SysErr _ =>
		     (send_message(shell, "Path " ^ filename ^
				   " does not exist");
		      false)
	     val ok = Lists_.forall filename_ok files
	   in
	     if ok then
		(result :=
		  SOME
		    (map OS.FileSys.fullPath files
		     handle OS.SysErr _ => files);
		     (* If the selection bos allows multiple selection this handler 
		      * is not needed as the user can not type in the selection, 
		      * otherwise this handler is needed when the file does not yet
		      * exist. *)
	        continue := false;
		last_visit_dir := get_dir();
                Xm.Widget.destroy shell)
	     else ()
	   end);
      Xm.Widget.manage box;
      Xm.Widget.manage shell;
      Xm.Widget.realize shell;
      while !continue do
        Xm.doInput ();
      !result
    end

  fun find_file (parent, mask, file_or_dir, existence) = 
    case (find_files(parent, mask, file_or_dir, existence, false)) of
      SOME [] => crash "Invalid return value from selection dialog"
    | SOME [s] => SOME s
    | SOME (a::rest) => crash "Multiple values returned from single selection box"
    | NONE => NONE

  fun open_file_dialog (parent, mask, multi) = find_files (parent, mask, FILE, MUST_EXIST, multi)
  fun open_dir_dialog parent = find_file (parent, "", DIRECTORY, MUST_EXIST)
  fun set_dir_dialog parent = find_file (parent, "", DIRECTORY, MAY_EXIST)
  fun save_as_dialog (parent, mask) = find_file (parent, mask, FILE, MAY_EXIST)
end;
@


1.38.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.38  1998/08/07  09:38:31  johnh
 * [Bug #50096]
 * When selecting a directory, the dialog title should be 'Directory selection dialog'.
 *
@


1.37
log
@[Bug #30369]
Replace source path with a list of files.
@
text
@d4 4
d204 4
a207 1
      val title = "File Selection Dialog"
@


1.36
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d133 2
d138 1
d194 5
a198 1
  fun find_file (parent, mask: string, file_type: FileType, exist) =
a217 4
      fun crash s =
        Info.default_error'
	  (Info.FAULT,Location.UNKNOWN,s)

d251 2
d254 8
a261 5
      fun get_file () =
        (case Xm.Widget.valuesGet(box,[Xm.DIR_SPEC]) of
           [Xm.COMPOUND_STRING filename] =>
              Xm.CompoundString.convertStringText filename
         | _ => crash "Bad values for valuesGet (get_file)")
d277 8
a284 2
	else
	  ()
d287 14
a300 3
        let 
	  val text_w = Xm.FileSelectionBox.getChild (box, Xm.Child.TEXT)
	  val sel_text = #3 (Xm.Callback.convertList callback_data)
d302 1
a302 1
	  Xm.Text.setString (text_w, (Xm.CompoundString.convertStringText sel_text) ^ "/")
d311 14
d350 2
a351 2
	     val filename = get_file ()
	     val filename_ok =
d405 1
d407 1
a407 1
	     if filename_ok then
d410 6
a415 4
		    (OS.FileSys.fullPath filename
		     handle OS.SysErr _ => filename);
		     (* The above handler is needed when the file does not
		        yet exist. *)
d429 8
a436 1
  fun open_file_dialog (parent, mask) = find_file (parent, mask, FILE, MUST_EXIST)
@


1.35
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d259 1
a259 1
	  (map 
@


1.34
log
@[Bug #30077]
Force the ScrollBarDisplayPolicy of the file list to be static, so that the
horizontal scrollbar is always displayed.  This is necessary for Sun's
implementation of Motif -- other implementations seem to get it right.
@
text
@d4 11
d221 4
a224 1
      val _ = if (!last_filesys_dir <> filesys_dir) orelse (file_type = DIRECTORY) then 
d320 2
a321 2
		   case exist of
		     MUST_EXIST =>
d325 15
a339 1
		   | _ =>
d353 1
a353 1
		       end)
d357 1
a357 1
		      false))
d381 1
@


1.33
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d270 7
@


1.33.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.33  1997/05/02  17:17:52  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.33.2.2
log
@[Bug #30071]
Implement new Project Workspace tool.
Allow non-existing directories to be created.
@
text
@d210 1
a210 4
      val setLastDir = (!last_filesys_dir <> filesys_dir) orelse
			((file_type = DIRECTORY) andalso (exist = MUST_EXIST))

      val _ = if setLastDir then 
d299 2
a300 2
		   case (file_type, exist) of
		     (_, MUST_EXIST) =>
d304 1
a304 15
		   | (DIRECTORY, MAY_EXIST) =>
		       ((let 
			  val isDir = OS.FileSys.isDir filename
		        in
			  if not isDir then 
			    (send_message(shell, "Directory " ^
					  filename ^ " is a file");
			     false)
			  else 
			    true
			end)
			handle OS.SysErr _ => 
			  (OS.FileSys.mkDir filename; true))

		   | (FILE, _) =>
d318 1
a318 1
		       end))
d322 1
a322 1
		      false)
a345 1
  fun set_dir_dialog parent = find_file (parent, "", DIRECTORY, MAY_EXIST)
@


1.33.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.33  1997/05/02  17:17:52  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.32
log
@[Bug #20024]
Fix saving images to files which don't exist yet.
Also give as good as possible warnings for other file access failures.
Remove all instances of silent failure where the dailog simply stays.
@
text
@d4 6
a123 2

  open MLWorks.Option
@


1.31
log
@[Bug #2024]
Using OS.FileSys.isDir to check for invalid paths.
@
text
@d4 4
d22 1
a22 2
 * Converted Xm.CompoundString.string_convert_text to standard identifier
 * convention.
d123 2
d164 1
a164 1
  fun find_file (parent, mask: string, file_type: FileType) =
a260 8
      fun is_file_type s =
	let
          val isDir = OS.FileSys.isDir s
	in
	  case file_type
	  of DIRECTORY => isDir
	  |  FILE => not isDir
	end
d275 40
a314 5
        (* The handler here catches the case of an illegal directory name *)
	     val filename_ok = is_file_type filename
	       handle OS.SysErr _ => 
		 (send_message(shell, "Path " ^ filename ^ " does not exist");
		  false)
d336 3
a338 3
  fun open_file_dialog (parent, mask) = find_file (parent, mask, FILE)
  fun open_dir_dialog parent = find_file (parent, "", DIRECTORY)
  fun save_as_dialog (parent, mask) = find_file (parent, mask, FILE)
@


1.31.1.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1997/04/04  13:10:02  johnh
 * [Bug #2024]
 * Using OS.FileSys.isDir to check for invalid paths.
 *
@


1.31.1.2
log
@[Bug #20024]
Fix saving images to files which don't exist yet.
Also give as good as possible warnings for other file access failures.
Remove all instances of silent failure where the dailog simply stays.
Also removed MLWorks.Option.
@
text
@a3 14
 *
 * Revision 1.31.1.1  1997/05/12  10:37:57  hope
 * branched from 1.31
 *
 * Revision 1.33  1997/05/02  17:17:52  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.32  1997/04/29  16:18:03  jont
 * [Bug #20024]
 * Fix saving images to files which don't exist yet.
 * Also give as good as possible warnings for other file access failures.
 * Remove all instances of silent failure where the dailog simply stays.
 *
d22 2
a23 1
 * Converted Xm.CompoundString.string_convert_text to standard convention.
d120 2
a123 2
  datatype exist = MUST_EXIST | MAY_EXIST

d163 1
a163 1
  fun find_file (parent, mask: string, file_type: FileType, exist) =
d260 8
d282 5
a286 40
	     val filename_ok =
	       ((if OS.FileSys.access(filename, []) then
		   (* The file exists, check it's correct type *)
		   case (file_type, OS.FileSys.isDir filename) of
		     (DIRECTORY, true) => true
		   | (FILE, false) => true
		   | (DIRECTORY, false) =>
		       (send_message(shell, "Directory " ^ filename ^
				     " is a file");
			false)
		   | _ =>
		       (send_message(shell, "File " ^ filename ^
				     " is a directory");
			false)
		 else
		   (* No file *)
		   case exist of
		     MUST_EXIST =>
		       (send_message(shell, "Path " ^ filename ^
				     " does not exist");
			false)
		   | _ =>
		       let
			 val path = OS.Path.dir filename
		       in
			 (if OS.FileSys.isDir path then
			    true
			  else
			    (send_message(shell, "Directory " ^
					  filename ^ " is a file");
			     false))
			    handle OS.SysErr _ =>
			      (send_message(shell, "Path " ^ path ^
					    " does not exist");
			       false)
		       end)
		   handle OS.SysErr _ =>
		     (send_message(shell, "Path " ^ filename ^
				   " does not exist");
		      false))
d308 3
a310 3
  fun open_file_dialog (parent, mask) = find_file (parent, mask, FILE, MUST_EXIST)
  fun open_dir_dialog parent = find_file (parent, "", DIRECTORY, MUST_EXIST)
  fun save_as_dialog (parent, mask) = find_file (parent, mask, FILE, MAY_EXIST)
@


1.31.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 7
 * Revision 1.31.1.2  1997/05/13  11:03:15  daveb
 * [Bug #20024]
 * Fix saving images to files which don't exist yet.
 * Also give as good as possible warnings for other file access failures.
 * Remove all instances of silent failure where the dailog simply stays.
 * Also removed MLWorks.Option.
 *
@


1.31.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 7
 * Revision 1.31.1.2  1997/05/13  11:03:15  daveb
 * [Bug #20024]
 * Fix saving images to files which don't exist yet.
 * Also give as good as possible warnings for other file access failures.
 * Remove all instances of silent failure where the dailog simply stays.
 * Also removed MLWorks.Option.
 *
@


1.31.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 7
 * Revision 1.31.1.2  1997/05/13  11:03:15  daveb
 * [Bug #20024]
 * Fix saving images to files which don't exist yet.
 * Also give as good as possible warnings for other file access failures.
 * Remove all instances of silent failure where the dailog simply stays.
 * Also removed MLWorks.Option.
 *
@


1.31.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.31.1.2.1.1  1997/07/28  18:23:05  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.30
log
@[Bug #1769]
Added a browse selection callback to get the selected text.
@
text
@d4 4
d132 27
d258 1
a258 1
	  val isDir = MLWorks.String.ordof (s, size s - 1) = ord #"/"
d278 5
d284 2
a285 2
	     if is_file_type filename then
               (result :=
d294 1
a294 2
	     else
	       ()
@


1.29
log
@[Bug #1300]
Reintroduced a bug fix concerning the directory changing.
@
text
@d4 4
d160 7
a166 2
         so that file dialogs can be popped up in specific places. *)
      val _ = if (!last_filesys_dir <> filesys_dir) then 
d205 16
@


1.28
log
@Undo last bug fixes as the Win32 equivalent fix didn't work.
Better to keep the functionality of the two platforms as similar as possible.
@
text
@d4 4
d112 12
d136 3
d155 1
a155 1
      (* We could probably pass the complete directory in as the argument,
d157 6
a162 1
      val _ = set_mask ("./*" ^ mask)
d167 6
d231 1
@


1.27
log
@[Bug #1300]
Store the directory once user clicks OK.
@
text
@a107 12
(* These two references store the last directory visited within the file
   selection box, and the last file system directory (ie. as set by 
   OSFileSys.chDir).  
   When the directory mask is set these references are used as follows: if
   the file system has recently changed use this new file system directory
   as the initial directory within the file selection box, otherwise use
   the last directory visited by the file selection box.  The last visited
   directory reference is only changed when the user clicks on OK. *)
  val last_visit_dir = ref "./"
  val last_filesys_dir = ref (OS.FileSys.getDir())
    handle OS.SysErr _ => ref "./"

a119 3
      val filesys_dir = OS.FileSys.getDir()
	handle OS.SysErr _ => !last_filesys_dir

d136 1
a136 1
      (* We now pass the complete directory in as the argument,
d138 1
a138 6
      val _ = if (!last_filesys_dir <> filesys_dir) then 
	  (last_filesys_dir := filesys_dir;
	  last_visit_dir := filesys_dir;
	  set_mask(!last_filesys_dir ^ "/*" ^ mask))
	else
	  set_mask(!last_visit_dir ^ "/*" ^ mask)
a142 6
      fun get_dir() = 
        (case Xm.Widget.valuesGet(box,[Xm.DIRECTORY]) of
           [Xm.COMPOUND_STRING filename] =>
              Xm.CompoundString.convertStringText filename
         | _ => crash "Bad values for valuesGet (get_dir)")

a200 1
		last_visit_dir := get_dir();
@


1.26
log
@[Bug #1694]
Converted Xm.CompoundString.string_convert_text to standard identifier
convention.
@
text
@d4 5
d106 13
a118 1
  datatype FileType = DIRECTORY | FILE
d132 3
d151 1
a151 1
      (* We could probably pass the complete directory in as the argument,
d153 6
a158 1
      val _ = set_mask ("./*" ^ mask)
d163 6
d227 1
@


1.26.4.1
log
@branched from 1.26
@
text
@a3 5
 * Revision 1.26  1996/11/01  17:47:48  daveb
 * [Bug #1694]
 * Converted Xm.CompoundString.string_convert_text to standard identifier
 * convention.
 *
@


1.26.3.1
log
@branched from 1.26
@
text
@a3 5
 * Revision 1.26  1996/11/01  17:47:48  daveb
 * [Bug #1694]
 * Converted Xm.CompoundString.string_convert_text to standard identifier
 * convention.
 *
@


1.26.3.1.1.1
log
@branched from 1.26.3.1
@
text
@a3 3
 * Revision 1.26.3.1  1996/12/17  17:51:14  hope
 * branched from 1.26
 *
@


1.26.2.1
log
@branched from 1.26
@
text
@a3 5
 * Revision 1.26  1996/11/01  17:47:48  daveb
 * [Bug #1694]
 * Converted Xm.CompoundString.string_convert_text to standard identifier
 * convention.
 *
@


1.26.1.1
log
@branched from 1.26
@
text
@a3 5
 * Revision 1.26  1996/11/01  17:47:48  daveb
 * [Bug #1694]
 * Converted Xm.CompoundString.string_convert_text to standard identifier
 * convention.
 *
@


1.26.1.1.1.1
log
@branched from 1.26.1.1
@
text
@a3 3
 * Revision 1.26.1.1  1996/11/14  12:53:52  hope
 * branched from 1.26
 *
@


1.25
log
@moving String from toplevel
@
text
@d4 3
d142 1
a142 1
              Xm.CompoundString.convert_string_text filename
@


1.24
log
@Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
now does what the former used to do.
@
text
@d4 4
d164 1
a164 1
	  val isDir = MLWorks.String.ordof (s, size s - 1) = String.ord "/"
@


1.24.3.1
log
@branched from 1.24
@
text
@a3 4
 * Revision 1.24  1996/05/23  12:17:16  stephenb
 * Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
 * now does what the former used to do.
 *
@


1.24.2.1
log
@branched from 1.24
@
text
@a3 4
 * Revision 1.24  1996/05/23  12:17:16  stephenb
 * Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
 * now does what the former used to do.
 *
@


1.24.1.1
log
@branched from 1.24
@
text
@a3 4
 * Revision 1.24  1996/05/23  12:17:16  stephenb
 * Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
 * now does what the former used to do.
 *
@


1.23
log
@Replaced  Os.FileSys.getDir with the string ".", added a handler for realPath
(needed for files that don't exist yet), and added a missing "*" to the mask.
@
text
@d4 4
d184 1
a184 1
		    (OS.FileSys.realPath filename
@


1.22
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d88 2
d122 4
a125 2
      val _ = set_mask (OS.FileSys.getDir() ^ "/" ^ mask)
      (* XXXEXCEPTION: Os.FileSys.getDir needs a handler for Os.SysErr *)
d151 1
a151 1
      val result = ref MLWorks.Option.NONE
d167 1
a167 1
           (result := MLWorks.Option.NONE;
d178 6
a183 2
               (* XXXEXCEPTION: OS.FileSys.realPath needs a handler *)
               (result := MLWorks.Option.SOME (OS.FileSys.realPath filename);
@


1.21
log
@initbasis moves to basis
@
text
@d4 3
d146 1
a146 1
	  val isDir = MLWorks.String.ordof (s, size s - 1) = ord "/"
@


1.20
log
@Rename Os -> OS to conform with latest basis revision.
@
text
@d4 3
d66 1
a66 1
require "../initbasis/os";
@


1.19
log
@Update in accordance with the latest revised basis.
@
text
@d4 3
d70 1
a70 1
  structure Os : OS
d108 1
a109 1
      val _ = set_mask (Os.FileSys.getDir() ^ "/" ^ mask)
d162 2
a163 2
               (* XXXEXCEPTION: Os.FileSys.realPath needs a handler *)
               (result := MLWorks.Option.SOME (Os.FileSys.realPath filename);
@


1.18
log
@Fixed use of Info.default_options.
@
text
@d4 3
d60 1
a60 2
require "../initbasis/filesys";
require "../unix/unixos";
d67 1
a67 2
  structure FileSys : FILE_SYS
  structure UnixOS : UNIXOS
d105 2
a106 1
      val _ = set_mask (UnixOS.getwd() ^ "/" ^ mask)
d159 2
a160 1
               (result := MLWorks.Option.SOME (FileSys.realPath filename);
@


1.17
log
@Fixed use of Info.default_options.
@
text
@@


1.16
log
@Removed file selection list from directory dialog.
@
text
@d4 3
d92 2
a93 1
        Info.error' Info.default_options (Info.FAULT,Location.UNKNOWN,s)
@


1.15
log
@Revisions to Xm library
@
text
@d4 3
d83 1
a83 1
      val box = Xm.Widget.createManaged
d112 13
a124 4
        map 
        (fn c =>
         Xm.Widget.unmanageChild (Xm.FileSelectionBox.getChild(box,c)))
        [Xm.Child.HELP_BUTTON]
d159 1
@


1.14
log
@OS reorganisation: parameterise functor with UnixOS since all
OS specific stuff has been removed from the pervasive library.
@
text
@d4 4
d64 1
a64 1
  type Widget = Xm.Widget
d74 2
a75 2
        Xm.Widget.createPopupShell (Xm.Widget.NAME "fileDialog",
                                    Xm.Widget.Class.DialogShell,
d77 2
a78 2
                                    [(Xm.Title, Xm.STRING title),
                                     (Xm.IconName, Xm.STRING title)])
d81 2
a82 2
        (Xm.Widget.NAME "selectionBox",
         Xm.Widget.Class.FileSelectionBox,
d91 2
a92 2
          [(Xm.DirMask,
            Xm.COMPOUNDSTRING
d101 2
a102 2
        (case Xm.Widget.valuesGet(box,[Xm.DirSpec]) of
           [Xm.COMPOUNDSTRING filename] =>
d111 2
a112 2
         Xm.Widget.unmanage (Xm.Widget.fileSelectionBoxGetChild(box,c)))
        [Xm.Widget.Child.HELP_BUTTON]
d126 1
a126 1
      Xm.Widget.callbackAdd
d128 1
a128 1
         Xm.Callback.Cancel,
d133 1
a133 1
      Xm.Widget.callbackAdd
d135 1
a135 1
         Xm.Callback.Ok,
@


1.13
log
@Moved file_dialog from gui to motif.
@
text
@d4 3
d48 1
d56 1
d93 1
a93 1
      val _ = set_mask (MLWorks.OS.Unix.getwd() ^ "/" ^ mask)
@


1.12
log
@Added separate open_dir_dialog function.
@
text
@d4 3
d46 1
a46 1
require "../gui/file_dialog";
@


1.11
log
@Added open_file_dialog and save_as_dialog, for compatibility with Windows.
@
text
@d4 3
d142 2
a143 2
  val open_file_dialog = find_file

@


1.10
log
@Added mask and file_type arguments.
@
text
@d4 3
d139 3
@


1.9
log
@Moved file_dialog to gui
@
text
@d4 3
d35 1
d42 1
d48 3
a50 1
  fun find_file parent =
d70 11
d85 1
a85 1
             Xm.CompoundString.convert_string_text filename
d99 8
a106 2
      fun normal_file s =
	MLWorks.String.ordof (s, size s - 1) <> ord "/"
d122 2
a123 2
	     if normal_file filename then
               (result := MLWorks.Option.SOME filename;
@


1.8
log
@Restructuring gui directories
@
text
@d4 3
d33 1
a33 1
require "../library/file_dialog";
@


1.7
log
@Capification
@
text
@d4 3
d27 1
a27 1
require "../library/xm";
d30 1
a30 1
require "file_dialog";
@


1.6
log
@Made contexts only visible if full_menus set.
@
text
@d4 3
d37 1
a37 1
  fun find_file (parent, applicationShell) =
@


1.5
log
@Xm.doInput is back to taking unit.
@
text
@d2 18
a19 15
 * Copyright (c) 1994 Harlequin Ltd.
$Log: _file_dialog.sml,v $
# Revision 1.4  1995/04/06  15:59:59  daveb
# Type of Xm.doInput has changed.
#
# Revision 1.3  1995/01/16  13:56:17  daveb
# Replaced Option structure with references to MLWorks.Option.
#
# Revision 1.2  1994/07/11  11:03:34  daveb
# Replaced TextString with DirSpec.
#
# Revision 1.1  1994/06/30  18:01:32  daveb
# new file
#
*)
@


1.4
log
@Type of Xm.doInput has changed.
@
text
@d4 3
d96 1
a96 1
        Xm.doInput applicationShell;
@


1.3
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d4 3
d28 1
a28 1
  fun find_file (parent) =
d93 1
a93 1
        Xm.doInput ();
@


1.2
log
@Replaced TextString with DirSpec.
@
text
@d4 3
a13 2
require "../utils/option";
require "../utils/filename";
a19 2
  structure Option : OPTION
  structure FileName : FILENAME
a21 1
  structure Option = Option
d60 1
a60 1
      val result = ref Option.ABSENT
d64 1
a64 2
        (FileName.parse_absolute s; true)
        handle FileName.Parse _ => false
d70 1
a70 1
           (result := Option.ABSENT;
d81 1
a81 1
               (result := Option.PRESENT filename;
@


1.1
log
@new file
@
text
@d3 4
a6 1
$Log$
d49 1
a49 1
        (case Xm.Widget.valuesGet(box,[Xm.TextString]) of
@
