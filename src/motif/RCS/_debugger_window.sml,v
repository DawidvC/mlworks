head	1.46;
access;
symbols
	ML_beta_release_12/08/94:1.30
	ML_beta_release_03/08/94:1.30
	ML_revised_beta_release_25/05/94:1.28
	ML_final_beta_release_02/03/94:1.26
	mlworks-28-01-1994:1.25
	Release:1.22
	mlworks-beta-01-09-1993:1.22;
locks; strict;
comment	@ * @;


1.46
date	95.07.07.14.58.28;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	95.07.04.14.31.13;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	95.06.28.13.07.36;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	95.06.15.15.01.21;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.06.08.13.44.11;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	95.06.08.09.45.42;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.06.01.13.28.58;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	95.05.26.15.52.17;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	95.05.22.15.20.50;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	95.04.27.11.09.11;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	95.04.24.15.06.26;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	95.04.24.11.04.58;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	95.04.19.14.41.36;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	95.04.13.17.10.43;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	95.04.06.15.31.12;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	95.01.13.15.38.20;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	94.07.27.16.12.07;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	94.07.12.16.17.02;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	94.04.06.15.30.13;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	94.03.15.14.11.43;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	94.02.28.08.55.55;	author nosa;	state Exp;
branches;
next	1.25;

1.25
date	93.12.10.16.52.08;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	93.12.10.10.32.11;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	93.09.09.09.34.01;	author nosa;	state Exp;
branches;
next	1.22;

1.22
date	93.08.28.17.59.07;	author daveb;	state Exp;
branches
	1.22.1.1;
next	1.21;

1.21
date	93.08.24.16.31.36;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.08.11.12.02.19;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.08.09.16.57.34;	author nosa;	state Exp;
branches;
next	1.18;

1.18
date	93.08.05.11.01.30;	author nosa;	state Exp;
branches;
next	1.17;

1.17
date	93.08.03.11.13.16;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.07.28.15.54.56;	author nosa;	state Exp;
branches;
next	1.15;

1.15
date	93.05.20.11.43.46;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.05.13.18.22.13;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	93.05.13.15.26.03;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	93.05.12.14.43.35;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.05.10.10.42.52;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.05.07.17.10.14;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.05.05.19.30.54;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	93.04.30.14.24.22;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.04.28.10.24.16;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	93.04.26.13.50.16;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	93.04.19.09.46.25;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.04.05.14.55.08;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	93.03.30.14.46.56;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.26.18.27.32;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.25.17.07.11;	author matthew;	state Exp;
branches;
next	;

1.22.1.1
date	93.08.28.17.59.07;	author jont;	state Exp;
branches;
next	;


desc
@Motif debugger window
@


1.46
log
@Minor changes to layout.
@
text
@(*  Copyright (c) 1993 Harlequin Ltd.
 *
 *  $Log: _debugger_window.sml,v $
 *  Revision 1.45  1995/07/04  14:31:13  matthew
 *  Capification
 *
 *  Revision 1.44  1995/06/28  13:07:36  daveb
 *  Made edit action disabled for functions defined in the listener.
 *
 *  Revision 1.43  1995/06/15  15:01:21  daveb
 *  Hid details of WINDOWING type in ml_debugger.
 *  Removed edit function from parameters of run_debugger, and hardwired it
 *  in this file.
 *
 *  Revision 1.42  1995/06/08  13:44:11  daveb
 *  InspectorTool no longer contains a Widget Type.
 *
 *  Revision 1.41  1995/06/08  09:45:42  daveb
 *  Types of the InspectorTool functions have changed.  Also corrected
 *  spelling of InspectorTool (from Inspector_Tool).
 *
 *  Revision 1.40  1995/06/01  13:28:58  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.39  1995/05/26  15:52:17  matthew
 *  Changing uses of substring
 *
 *  Revision 1.38  1995/05/22  15:20:50  daveb
 *  Made breakpoints menu visible to novices.
 *
 *  Revision 1.37  1995/04/27  11:09:11  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.36  1995/04/24  15:06:26  matthew
 *  Cosmetic debugger changes
 *
 *  Revision 1.35  1995/04/24  11:04:58  daveb
 *  Added call to Xm.ungrabPointer to event-handling subloop.
 *
 *  Revision 1.34  1995/04/19  14:41:36  matthew
 *  Added extra buttons for abort etc.
 *  First version of new stepping functionality
 *
 *  Revision 1.33  1995/04/13  17:10:43  daveb
 *  Xm.doInput is back to taking unit.
 *
 *  Revision 1.32  1995/04/06  15:31:12  daveb
 *  Type of Xm.doInput has changed.
 *
 *  Revision 1.31  1995/01/13  15:38:20  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *
 *  Revision 1.30  1994/07/27  16:12:07  daveb
 *  Cut-down menus for novices.
 *
 *  Revision 1.29  1994/07/12  16:17:02  daveb
 *  Changes to reflect minor changes in inspector_tool.
 *
 *  Revision 1.28  1994/04/06  15:30:13  daveb
 *  Disabled stepper and breakpoint actions when appropriate, and removed
 *  irrelevant entries ffrom inspect submenu.  Moved breakpoint menu into
 *  motif_utils, and into the menu bar.  Simplified stepper interface.
 *
 *  Revision 1.27  1994/03/15  14:11:43  matthew
 *  Changed resource names
 *
 *  Revision 1.26  1994/02/28  08:55:55  nosa
 *  Menus for Step and breakpoints Debugger.
 *
 *  Revision 1.25  1993/12/10  16:52:08  daveb
 *  Added exists_frame_info to disable frames menu entry when no frame info
 *  exists.
 *
 *  Revision 1.24  1993/12/10  10:32:11  daveb
 *  Added copyright notice.
 *
 *  Revision 1.23  1993/09/09  09:34:01  nosa
 *  Restricted strings in inspect frame info menu to 80 characters;
 *  Hiding instance-frames for polymorphic debugger.
 *
 *  Revision 1.22  1993/08/28  17:59:07  daveb
 *  Changed Options menu to Settings menu, to avoid confusion.
 *
 *  Revision 1.21  1993/08/24  16:31:36  matthew
 *  Improved label names etc.
 *
 *  Revision 1.20  1993/08/11  12:02:19  matthew
 *  create_dialog interface change
 *
 *  Revision 1.19  1993/08/09  16:57:34  nosa
 *  Inspector now invoked for values of local and closure variables;
 *  new action "InspectFrameInfo".
 *
 *  Revision 1.18  1993/08/05  11:01:30  nosa
 *  New option ShowFrameInfo in debugger window.
 *
 *  Revision 1.17  1993/08/03  11:13:16  matthew
 *  Combined frame and action menus. Renamed quit to abort
 *
 *  Revision 1.16  1993/07/28  15:54:56  nosa
 *  Reversed logic for frame filters.
 *  More user-friendly labels.
 *
 *  Revision 1.15  1993/05/20  11:43:46  matthew
 *  Fixed bug with item selection
 *
 *  Revision 1.14  1993/05/13  18:22:13  daveb
 *  Renamed file menu to action menu.
 *
 *  Revision 1.13  1993/05/13  15:26:03  daveb
 *  create_dialog now requires a title argument.
 *
 *  Revision 1.12  1993/05/12  14:43:35  matthew
 *  Added message function to debugger window
 *
 *  Revision 1.11  1993/05/10  10:42:52  matthew
 *  Change to termination protocol
 *
 *  Revision 1.10  1993/05/07  17:10:14  matthew
 *  Added Quit and Continue buttons
 *  Enter event handling loop before exitting.
 *
 *  Revision 1.9  1993/05/05  19:30:54  daveb
 *  Gave sensible names to the shell and form widgets.
 *
 *  Revision 1.8  1993/04/30  14:24:22  matthew
 *  Added menubar, frame suppression, editor interface
 *
 *  Revision 1.7  1993/04/28  10:24:16  daveb
 *  Changes to make_scrolllist.
 *
 *  Revision 1.6  1993/04/26  13:50:16  daveb
 *  Now uses MotifUtils.make_scrolllist.
 *
 *  Revision 1.5  1993/04/19  09:46:25  matthew
 *  Used Xm callback conversion function.
 *  
 *  Revision 1.4  1993/04/05  14:55:08  daveb
 *  Names of Callbacks have changed.
 *  
 *  Revision 1.3  1993/03/30  14:46:56  matthew
 *  Removed MENUSPEC data constructor
 *  
 *  Revision 1.2  1993/03/26  18:27:32  matthew
 *  Changed widget names
 *  
 *  Revision 1.1  1993/03/25  17:07:11  matthew
 *  Initial revision
 *  
 *  
 *)

require "../library/capi";
require "../utils/lists";
require "../main/preferences";
require "../debugger/newtrace";
require "tooldata";
require "inspector_tool";
require "menus";
require "motif_utils";
require "../interpreter/shell_utils";
require "debugger_window";

functor DebuggerWindow(
  structure Capi : CAPI
  structure Lists : LISTS
  structure Trace : TRACE
  structure InspectorTool : INSPECTORTOOL
  structure Menus : MENUS
  structure MotifUtils: MOTIF_UTILS
  structure ShellUtils: SHELL_UTILS
  structure ToolData: TOOL_DATA
  structure Preferences: PREFERENCES

  sharing type Menus.Widget = MotifUtils.Widget = ToolData.Widget = Capi.Widget
  sharing type Menus.ButtonSpec = MotifUtils.ButtonSpec
  sharing type ToolData.ToolData = InspectorTool.ToolData
  sharing type ToolData.ShellTypes.user_preferences =
	       Preferences.user_preferences
  sharing type ShellUtils.preferences = Preferences.preferences
) : DEBUGGERWINDOW =
  struct
    structure Option = MLWorks.Option
    structure Options = ShellUtils.Options

    type Widget = Capi.Widget
    type ToolData = InspectorTool.ToolData
    type Type = InspectorTool.Type

    local
      type part_of_a_frame =
        (string
         * (Type * MLWorks.Internal.Value.ml_value * string)
         ) list

      type frame_details =
        string
        * string
        * (Type * MLWorks.Internal.Value.ml_value * string)
        * (unit -> string * part_of_a_frame,
           string * part_of_a_frame)
          MLWorks.Option.union ref MLWorks.Option.option

      type frame =
	{name : string, loc : string, details: frame_details}
    in
      datatype Frame =
	FRAME of frame

      (* This type must be the same as that in _ml_debugger. *)
      type debugger_window =
        {parameter_details: string,
         frames: frame list,
         quit_fn: (unit -> unit) MLWorks.Option.option,
         continue_fn: (unit -> unit) MLWorks.Option.option}
        -> unit
    end

    fun make_debugger_window (parent,name,tooldata) =
      let 

	val ToolData.TOOLDATA
	      {args as ToolData.ShellTypes.LISTENER_ARGS
			{user_preferences as Preferences.USER_PREFERENCES
					  ({full_menus, ...}, _),
			 ...},
	       appdata as ToolData.APPLICATIONDATA {applicationShell, ...},
	       ...} =
	  tooldata

        (* Some state variables *)

        val show_debug_info : bool ref = ref true
        val show_variable_debug_info : bool ref = ref false

        val shell = Capi.make_popup_shell ("debuggerShell",parent,[])
        val form = Capi.make_widget ("debuggerForm",Capi.Form,shell,[])

        (* Controls local event handling loop *)
        val continue = ref true

        fun popup () = Capi.manage form;
        fun popdown () = Capi.unmanage form;

        (* Need to terminate main loop even if we are not popping window down *)

        fun maybe_popdown () = 
          (*
           if Trace.step_state () then continue := false else popdown ()
             *)
          continue := false

        val menuBar = Capi.make_managed_widget ("menuBar", Capi.RowColumn, form, [])
        val buttonPane = Capi.make_managed_widget ("buttonPane", Capi.RowColumn, form, [])
        val abortButton = Capi.make_managed_widget ("abortButton", Capi.PushButton, buttonPane, [])
        val continueButton = Capi.make_managed_widget ("continueButton", Capi.PushButton, buttonPane, [])
        val stepButton = Capi.make_managed_widget ("stepButton", Capi.PushButton, buttonPane, [])

        val debuggerFrame =
	  Capi.make_managed_widget
	    ("debuggerFrame", Capi.Paned, form, [Capi.PanedMargin true])

        val (_,text) = Capi.make_scrolled_text ("debuggerText",debuggerFrame,[])
        val (_,argsText) = Capi.make_scrolled_text ("debuggerArgsText",debuggerFrame,[])

        fun edit_fn s =
          (ShellUtils.edit_string
 	     (s, Preferences.new_preferences user_preferences); ())
          handle ShellUtils.EditFailed s =>
            Capi.send_message (shell, "Edit failed: " ^ s)

        fun find(_,[]) = ()
          | find(1,(_,a)::t) = Capi.Text.set_string(argsText,a)
          | find(n,_::t) = find(n-1,t)

        val frames_ref = ref [] : Frame list ref
        val displayed_frames = ref [] : Frame list ref
	val present_name = ref "";
        val present_frame_info : (InspectorTool.Type * MLWorks.Internal.Value.ml_value 
                                       * string) Option.option ref =
	  ref Option.NONE

        val present_variable_frame_info : 
          (unit -> string * ((string * (InspectorTool.Type * MLWorks.Internal.Value.ml_value 
                                       * string)) list),
           string * ((string * (InspectorTool.Type * MLWorks.Internal.Value.ml_value 
                               * string)) list)) Option.union ref ref = 
          ref(ref(Option.INR("",[])))

	fun select_fn _ frame =
	  let val FRAME
		    {name, details = (a,b,(ty,value,valuestr),info'),...} =
		frame
	  in
            (case valuestr of
               "" => ()
             | "_" => ()
             | _ => present_frame_info := Option.SOME(ty,value,valuestr));
	     present_name := name;
             Capi.Text.set_string
	       (argsText,
		b ^ (case info' of
                       Option.NONE => ""
                     | Option.SOME info' =>
                       (present_variable_frame_info := info';
                        if !show_variable_debug_info then 
                          case !info' of
                            Option.INL info => 
                            let
                               val info as (info'',_) = info()
                            in
                              (info' := Option.INR info;info'')
                            end
                          | Option.INR(info',_) => info'
                        else
		          "")))
	  end

        val (framesScroll, framesList, set_items) =
          Capi.make_scrolllist
	    {parent = debuggerFrame,
	     name = "debuggerFrames",
	     select_fn = select_fn,
	     action_fn = fn _ => fn FRAME{loc,...} => edit_fn loc, 
	     print_fn = fn _ => fn FRAME{details = (a,_,(_,_,info),_),...} => 
                                     a^(if !show_debug_info then info else "")}

        local
          val don'tshow_cframes = ref true
          val don'tshow_handlers = ref true
          val don'tshow_setups = ref true
          val don'tshow_anon = ref false
        in
          val settings_spec =
            Menus.OPTTOGGLE ("hideAnonymousFrames",
                              fn () => !don'tshow_anon,
                              fn b => don'tshow_anon := b)
            :: Menus.OPTTOGGLE ("hideHandlerFrames",
                              fn () => !don'tshow_handlers,
                              fn b => don'tshow_handlers := b)
            :: (if !full_menus then
		  [Menus.OPTTOGGLE ("hideSetupFrames",
                                    fn () => !don'tshow_setups,
                                    fn b => don'tshow_setups := b),
                   Menus.OPTTOGGLE ("hideCFrames",
                                    fn () => !don'tshow_cframes,
                                    fn b => don'tshow_cframes := b)]
		else
		  nil)

          fun filter_frames ([],acc) = rev acc
            | filter_frames ((f as FRAME{name,loc,details}) :: rest,acc) =
              let
                val don'tshowit =
                  case name of
                    "<handle>" => !don'tshow_handlers
                  | "<anon>" => !don'tshow_anon
                  | "<Cframe>" => !don'tshow_cframes
                  | "<Setup>" => !don'tshow_setups
                  | _ => false
              in
                filter_frames (rest, if don'tshowit then acc else (f::acc))
              end
        end

        val info_settings_spec =
          [Menus.OPTTOGGLE ("showDebugInfo",
                            fn () => !show_debug_info,
                            fn b => show_debug_info := b),
           Menus.OPTTOGGLE ("showVariableDebugInfo",
                            fn () => !show_variable_debug_info,
                            fn b => show_variable_debug_info := b)]

        fun update_items () =
          let
            val frame_list = filter_frames (!frames_ref,[])
          in
            displayed_frames := frame_list;
            set_items Options.default_print_options frame_list
          end

        fun clear_window () =
          (frames_ref := [];
           update_items ();
           Capi.Text.set_string(text,"");
           Capi.Text.set_string(argsText,""))
           
        fun item_selected _ = Vector.length (Capi.List.get_selected_pos framesList) = 1

        fun edit_callback _ =
          let
            val pos = Capi.List.get_selected_pos framesList
          in
            if Vector.length pos = 1
              then
                let
                  val index = Vector.sub (pos,0)
                  val FRAME{loc,...} = Lists.nth (index-1,!displayed_frames)
                in
                  edit_fn loc
                end
                handle Lists.Nth => ()
            else ()
          end

	fun is_editable _ =
          let
            val pos = Capi.List.get_selected_pos framesList
          in
            if Vector.length pos = 1
              then
                let
                  val index = Vector.sub (pos,0)
                  val FRAME{loc,...} = Lists.nth (index-1,!displayed_frames)
		  val location = ShellUtils.Info.Location.from_string loc
                in
                  ShellUtils.editable location
                end
                handle Lists.Nth => 
		  false
            else
	      false
          end

        val settings_popup =
          #1 (Menus.create_dialog (shell,
                                   "Debugger Settings",
                                   "debuggerDialog",
                                   update_items,
                                   settings_spec))
        val info_settings_popup =
          #1(Menus.create_dialog (shell,
                                  "Debugger Settings",
                                  "debuggerDialog",
                                  update_items,
                                  info_settings_spec))

        val quit_fn_ref = ref Option.NONE
        val continue_fn_ref = ref Option.NONE

	fun present (ref Option.NONE) = false
	|   present (ref (Option.SOME _)) = true

        val max_length = 80
        fun strip str = 
          if size str <= max_length then str
          else String.substring(str,0,max_length-3) ^ "..."

        fun fetch_frame_info (info' as ref(Option.INL info_fn)) = 
          let val info as (_,info'') = info_fn ()
          in
            info' := Option.INR info;
	    info''
          end
        |   fetch_frame_info (ref(Option.INR(_,info))) = info

	fun exists_frame_info () =
	  case (!present_frame_info,
		fetch_frame_info (!present_variable_frame_info))
	  of (Option.NONE, []) => false
	  |  _ => true

        fun inspect_frame_info () = 
          let
            val push_values = 
              map (fn (var,(ty,value,valuestr)) =>
                   Menus.PUSH (var^" = "^strip valuestr,
                          fn _ => InspectorTool.inspect_value
				    true
                                    (var,(value,ty),tooldata),
                          fn _ => true))

          in
             case !present_frame_info of
               Option.NONE =>
		 push_values (fetch_frame_info(!present_variable_frame_info))
             | Option.SOME(ty,value,valuestr) => 
                 Menus.PUSH ("frame argument"^" = "^strip valuestr,
                             fn _ =>
			       InspectorTool.inspect_value
				 true 
                                 ("frame argument",(value,ty),tooldata),
                             fn _ => true)
                 :: push_values
		      (fetch_frame_info(!present_variable_frame_info))
          end

        fun abort_present _ = present quit_fn_ref
        fun continue_present _ = present continue_fn_ref

        fun abort_action _ =
          case !quit_fn_ref of
            Option.NONE => ()
          | Option.SOME f => 
              (popdown();
               f ())

        fun set_active_buttons _ =
          (Capi.set_sensitivity (abortButton,abort_present());
           Capi.set_sensitivity (continueButton,continue_present());
           Capi.set_sensitivity (stepButton,continue_present()))

        fun continue_action _ =
          case !continue_fn_ref of
            Option.NONE => ()
          | Option.SOME f => 
              (Trace.set_stepping false;
               continue_fn_ref := Option.NONE;
                set_active_buttons ();
                maybe_popdown();
                clear_window ();
               f ())

        fun step_action _ = 
          case !continue_fn_ref of
            Option.NONE => ()
           | Option.SOME f => 
               (Trace.set_stepping true;
                continue_fn_ref := Option.NONE;
                set_active_buttons ();
                maybe_popdown();
                clear_window ();
                f ())

        val menuspec =
          [Menus.CASCADE ("action",
                         Menus.PUSH ("abort",abort_action,abort_present) ::
                         Menus.PUSH ("continue",continue_action,continue_present) ::
                         Menus.PUSH ("step",step_action,continue_present) ::
                         (if !full_menus then
                            [Menus.PUSH ("edit_frame",edit_callback,is_editable),
                             Menus.DYNAMIC ("inspectFrameInfo",
                                            inspect_frame_info,
                                            fn _ => exists_frame_info ())]
                          else
                            [Menus.PUSH ("edit_frame",
                                         edit_callback,
                                         is_editable)]),
                         fn _ => true),
           Menus.CASCADE ("settings",
                         Menus.PUSH ("filterFrames",
                                     fn _ => settings_popup (),
                                     fn _ => true) ::
                         (if !full_menus then
                            [Menus.PUSH ("showFrameInfo",
                                         fn _ => info_settings_popup (),
                                         fn _ => true)]
                          else
                            nil),
                         fn _ => true),
           MotifUtils.breakpoints_menu shell]

        fun run_debugger
	      {parameter_details, frames, quit_fn, continue_fn} =
          (frames_ref := map FRAME frames;
           continue := true;
           quit_fn_ref := quit_fn;
           continue_fn_ref := continue_fn;
           update_items ();
	   select_fn
	     (framesScroll, framesList, set_items)
	     (FRAME (Lists.nth (0,frames)));
           Capi.Text.set_string(text, parameter_details);
           set_active_buttons ();
           popup();
           (* Go into a local event loop while the window is displayed *)
           (* Loop terminated when window is unmapped *)
           Capi.event_loop continue)
      in
        Menus.make_submenus (menuBar, menuspec);
        (* Add a callback to terminate loop when popup is unmapped *)
        Capi.Callback.add (form,
                           Capi.Callback.Unmap,
                           fn _ => continue := false);
        (* Set callbacks for buttons *)
        Capi.Callback.add (abortButton, Capi.Callback.Activate,abort_action);
        Capi.Callback.add (continueButton, Capi.Callback.Activate,continue_action);
        Capi.Callback.add (stepButton, Capi.Callback.Activate,step_action);
        Capi.Layout.lay_out
        [Capi.Layout.MENUBAR menuBar,
         Capi.Layout.OTHER buttonPane,
         Capi.Layout.PANED debuggerFrame,
	 Capi.Layout.SPACE];
        Capi.manage text;
        Capi.manage argsText;
        run_debugger
      end
  end;
@


1.45
log
@Capification
@
text
@d4 3
d258 5
a262 1
        val debuggerFrame = Capi.make_managed_widget ("debuggerFrame", Capi.Pane, form,[])
d582 2
a583 2
         Capi.Layout.OTHER debuggerFrame,
         Capi.Layout.SPACE];
@


1.44
log
@Made edit action disabled for functions defined in the listener.
@
text
@d4 3
d35 1
a35 1
 *  Added call to Xm.ungrapPointer to event-handling subloop.
d150 1
a150 1
require "../library/xm";
d162 1
a162 1
  structure Xm : XM
d172 1
a172 2
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget = ToolData.Widget

d181 1
d183 1
a183 1
    type Widget = Xm.Widget
d233 2
a234 6
        val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME "debuggerShell",
                                                Xm.Widget.Class.DialogShell,
                                                parent, [])
        val form = Xm.Widget.create (Xm.Widget.NAME "debuggerForm",
                                            Xm.Widget.Class.Form,
                                            shell,[])
d237 1
a237 1
        val terminated = ref false
d239 2
a240 2
        fun popup () = Xm.Widget.manage form;
        fun popdown () = Xm.Widget.unmanage form;
d246 1
a246 1
           if Trace.step_state () then terminated := true else popdown ()
d248 1
a248 1
          terminated := true
d250 8
a257 32
        val menuBar =
          Xm.Widget.createManaged
	  (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, form, [])

        val buttonPane =
          Xm.Widget.createManaged
 	  (Xm.Widget.NAME "buttonPane", Xm.Widget.Class.RowColumn,
	   form, []);

        val abortButton =
          Xm.Widget.createManaged
 	  (Xm.Widget.NAME "abortButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

        val continueButton =
          Xm.Widget.createManaged
 	  (Xm.Widget.NAME "continueButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

        val stepButton =
          Xm.Widget.createManaged
 	  (Xm.Widget.NAME "stepButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

        val debuggerFrame =
	  Xm.Widget.createManaged (Xm.Widget.NAME "debuggerFrame",
                                   Xm.Widget.Class.PanedWindow,
                                   form,[])

        val text =
          Xm.Widget.createScrolledText
          (debuggerFrame,Xm.Widget.NAME "debuggerText",[])
a258 3
        val argsText = Xm.Widget.createScrolledText
	  (debuggerFrame,Xm.Widget.NAME "debuggerArgsText",[])

d263 1
a263 1
            MotifUtils.send_message (shell, "Edit failed: " ^ s)
d266 1
a266 1
          | find(1,(_,a)::t) = Xm.Text.setString(argsText,a)
d293 1
a293 1
             Xm.Text.setString
d313 1
a313 1
	   MotifUtils.make_scrolllist
d372 1
a372 1
            set_items MotifUtils.Options.default_print_options frame_list
d378 2
a379 2
           Xm.Text.setString(text,"");
           Xm.Text.setString(argsText,""))
d381 1
a381 1
        fun item_selected _ = Vector.length (Xm.List.getSelectedPos framesList) = 1
d385 1
a385 1
            val pos = Xm.List.getSelectedPos framesList
d401 1
a401 1
            val pos = Xm.List.getSelectedPos framesList
d492 3
a494 3
          (MotifUtils.set_sensitivity (abortButton,abort_present());
           MotifUtils.set_sensitivity (continueButton,continue_present());
           MotifUtils.set_sensitivity (stepButton,continue_present()))
d549 1
a549 1
           terminated := false;
d556 1
a556 1
           Xm.Text.setString(text, parameter_details);
d561 1
a561 2
           while not (!terminated) do (Xm.doInput ()))

d565 3
a567 3
        Xm.Widget.callbackAdd (form,
                               Xm.Callback.Unmap,
                               fn _ => terminated := true);
d569 10
a578 24
        Xm.Widget.callbackAdd (abortButton, Xm.Callback.Activate,abort_action);
        Xm.Widget.callbackAdd (continueButton, Xm.Callback.Activate,continue_action);
        Xm.Widget.callbackAdd (stepButton, Xm.Callback.Activate,step_action);
        

        (* set the form resources *)
        Xm.Widget.valuesSet (menuBar,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (buttonPane,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET menuBar),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
        Xm.Widget.valuesSet (debuggerFrame,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET buttonPane),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
        Xm.Widget.manage text;
        Xm.Widget.manage argsText;
@


1.43
log
@Hid details of WINDOWING type in ml_debugger.
Removed edit function from parameters of run_debugger, and hardwired it
in this file.
@
text
@d4 5
d427 19
d552 1
a552 1
                            [Menus.PUSH ("edit_frame",edit_callback,item_selected),
d559 1
a559 1
                                         item_selected)]),
@


1.42
log
@InspectorTool no longer contains a Widget Type.
@
text
@d4 3
d150 1
d160 1
d170 1
d178 29
a206 8
    datatype Frame = 
      FRAME of {name : string, loc : string, 
                details : string * string * (Type 
                                             * MLWorks.Internal.Value.ml_value * string) * 
                (unit -> string * ((string * (Type 
                                             * MLWorks.Internal.Value.ml_value * string)) list),
                 string * ((string * (Type * MLWorks.Internal.Value.ml_value 
                                            * string)) list)) Option.union ref Option.option}
d210 10
d282 5
a286 2
        exception NoEditFunction
        val edit_function_ref = ref (fn s : string => raise NoEditFunction)
d340 1
a340 1
	     action_fn = fn _ => fn FRAME{loc,...} => (!edit_function_ref) loc, 
a343 9
	val ToolData.TOOLDATA
	      {args as ToolData.ShellTypes.LISTENER_ARGS
			{user_preferences as Preferences.USER_PREFERENCES
					  ({full_menus, ...}, _),
			 ...},
	       appdata as ToolData.APPLICATIONDATA {applicationShell, ...},
	       ...} =
	  tooldata

d416 1
a416 1
                  (!edit_function_ref) loc
d550 3
a552 3
        fun run_debugger (exception_details, frames, edit_function,(quit_fn,continue_fn)) =
          (edit_function_ref := edit_function;
           frames_ref := map FRAME frames;
d560 1
a560 1
           Xm.Text.setString(text,exception_details);
a566 2
        fun send_message message =
          MotifUtils.send_message (shell,message)
d598 1
a598 1
        (run_debugger,send_message)
@


1.41
log
@Types of the InspectorTool functions have changed.  Also corrected
spelling of InspectorTool (from Inspector_Tool).
@
text
@d4 4
d159 1
a159 2
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget =
	       InspectorTool.Widget = ToolData.Widget
@


1.40
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d4 3
d149 1
a149 1
  structure Inspector_Tool : INSPECTORTOOL
d156 1
a156 1
	       Inspector_Tool.Widget = ToolData.Widget
d159 1
a159 1
  sharing type ToolData.ToolData = Inspector_Tool.ToolData
d167 2
a168 2
    type ToolData = Inspector_Tool.ToolData
    type Type = Inspector_Tool.Type
d252 1
a252 1
        val present_frame_info : (Inspector_Tool.Type * MLWorks.Internal.Value.ml_value 
d257 1
a257 1
          (unit -> string * ((string * (Inspector_Tool.Type * MLWorks.Internal.Value.ml_value 
d259 1
a259 1
           string * ((string * (Inspector_Tool.Type * MLWorks.Internal.Value.ml_value 
d431 1
a431 1
                          fn _ => Inspector_Tool.inspect_value
a432 1
				    make_debugger_window 
d443 2
a444 2
			       Inspector_Tool.inspect_value
				 true make_debugger_window 
@


1.39
log
@Changing uses of substring
@
text
@d4 3
d134 1
a134 1
require "../main/user_options";
d150 1
a150 1
  structure UserOptions: USER_OPTIONS
d157 2
a158 1
  sharing type ToolData.ShellTypes.user_options = UserOptions.user_options
d300 1
a300 1
			{user_options as UserOptions.USER_OPTIONS
d503 1
a503 1
                                     settings_popup,
d507 1
a507 1
                                         info_settings_popup,
@


1.38
log
@Made breakpoints menu visible to novices.
@
text
@d4 3
d335 1
a335 3
                  | _ => (String.substring(name,0,12) = "instance of " orelse
                          String.substring(name,0,26) = "Debugger exception handler")
                      handle String.Substring => false
d400 1
d402 2
a403 2
          String.substring(str,0,80)^"...."
          handle String.Substring => str
@


1.37
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d4 3
d481 1
a481 1
          Menus.CASCADE ("action",
d484 1
d486 1
a486 2
                            [Menus.PUSH ("step",step_action,continue_present),
                             Menus.PUSH ("edit_frame",edit_callback,item_selected),
d494 2
a495 2
                         fn _ => true) ::
          Menus.CASCADE ("settings",
d505 2
a506 2
                         fn _ => true) ::
          (if !full_menus then [MotifUtils.breakpoints_menu shell] else [])
@


1.36
log
@Cosmetic debugger changes
@
text
@d4 3
d520 1
a520 1
           while not (!terminated) do (Xm.ungrabPointer (); Xm.doInput ()))
@


1.35
log
@Added call to Xm.ungrapPointer to event-handling subloop.
@
text
@d4 3
d184 5
a188 1
        fun maybe_popdown () = if Trace.step_state () then terminated := true else popdown ()
d350 6
d447 5
d456 5
a460 2
              (maybe_popdown();
               Trace.set_stepping false;
d467 5
a471 2
               (maybe_popdown();
                Trace.set_stepping true;
a472 5

        fun set_active_buttons _ =
          (MotifUtils.set_sensitivity (abortButton,abort_present());
           MotifUtils.set_sensitivity (continueButton,continue_present());
           MotifUtils.set_sensitivity (stepButton,continue_present()))
@


1.34
log
@Added extra buttons for abort etc.
First version of new stepping functionality
@
text
@d4 4
d498 1
a498 1
           while not (!terminated) do Xm.doInput ())
@


1.33
log
@Xm.doInput is back to taking unit.
@
text
@d4 3
d116 1
d126 1
d141 2
d153 1
a153 1
                                            * string)) list)) MLWorks.Option.union ref MLWorks.Option.option}
d157 4
a160 2
        val show_debug_info : bool ref = ref(true)
        val show_variable_debug_info : bool ref = ref(false)
d169 3
d175 4
d183 20
d226 2
a227 2
                                       * string) MLWorks.Option.option ref =
	  ref(MLWorks.Option.NONE)
d233 2
a234 2
                               * string)) list)) MLWorks.Option.union ref ref = 
          ref(ref(MLWorks.Option.INR("",[])))
d244 1
a244 1
             | _ => present_frame_info := MLWorks.Option.SOME(ty,value,valuestr));
d249 2
a250 2
                       MLWorks.Option.NONE => ""
                     | MLWorks.Option.SOME(info') =>
d254 1
a254 1
                            MLWorks.Option.INL(info) => 
d258 1
a258 1
                              (info' := MLWorks.Option.INR(info);info'')
d260 1
a260 1
                          | MLWorks.Option.INR(info',_) => info'
d370 2
a371 2
        val quit_fn_ref = ref MLWorks.Option.NONE
        val continue_fn_ref = ref MLWorks.Option.NONE
d373 2
a374 2
	fun present (ref MLWorks.Option.NONE) = false
	|   present (ref (MLWorks.Option.SOME _)) = true
d380 1
a380 1
        fun fetch_frame_info (info' as ref(MLWorks.Option.INL(info_fn))) = 
d383 1
a383 1
            info' := MLWorks.Option.INR(info);
d386 1
a386 1
        |   fetch_frame_info (ref(MLWorks.Option.INR(_,info))) = info
d391 1
a391 1
	  of (MLWorks.Option.NONE, []) => false
d407 1
a407 1
               MLWorks.Option.NONE =>
d409 1
a409 1
             | MLWorks.Option.SOME(ty,value,valuestr) => 
d420 2
a421 7
        fun interval_stepper _ =
           case !continue_fn_ref of
             MLWorks.Option.NONE => ()
           | MLWorks.Option.SOME f => 
               (MLWorks.Debugger.set_step (1, !present_name);
		popdown();
		f ())
d423 27
a449 1
        val terminated = ref false
d453 25
a477 43
                         Menus.PUSH ("abort",
                                     fn _ =>
                                     (popdown();
                                      case !quit_fn_ref of
                                        MLWorks.Option.NONE => ()
                                      | MLWorks.Option.SOME f => f ()),
				     fn _ => present quit_fn_ref)
                         :: Menus.PUSH ("continue",
                                        fn _ =>
                                        (popdown();
                                         case !continue_fn_ref of
                                           MLWorks.Option.NONE => ()
                                         | MLWorks.Option.SOME f => 
                                             (MLWorks.Debugger.set_step (0,"");
                                              f ())),
				        fn _ => present continue_fn_ref)
                         :: (if !full_menus then
			       [Menus.PUSH ("step",
                                            interval_stepper,
                                            fn _ => present continue_fn_ref),
                                Menus.PUSH ("edit_frame",
                                            edit_callback,
                                            item_selected),
                                Menus.DYNAMIC ("inspectFrameInfo",
			  	               inspect_frame_info,
             			               fn _ => exists_frame_info ())]
			     else
                               [Menus.PUSH ("edit_frame",
                                            edit_callback,
                                            item_selected)]),
                         fn _ => true)
          :: Menus.CASCADE ("settings",
                            Menus.PUSH ("filterFrames",
                                         settings_popup,
                                         fn _ => true)
                            :: (if !full_menus then
			          [Menus.PUSH ("showFrameInfo",
                                               info_settings_popup,
                                               fn _ => true)]
			        else
			          nil),
                            fn _ => true)
	  :: (if !full_menus then [MotifUtils.breakpoints_menu shell] else [])
d490 1
d504 6
d516 5
d523 1
a523 1
                              (Xm.TopWidget, Xm.WIDGET menuBar),
@


1.32
log
@Type of Xm.doInput has changed.
@
text
@d4 3
d454 1
a454 1
           while not (!terminated) do Xm.doInput applicationShell)
@


1.31
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d4 3
d125 3
a127 1
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget = Inspector_Tool.Widget
d240 1
d451 1
a451 1
           while not (!terminated) do Xm.doInput())
@


1.30
log
@Cut-down menus for novices.
@
text
@d4 3
a127 2
    structure Option = Inspector_Tool.Option

d138 1
a138 1
                                            * string)) list)) Option.option ref Option.opt}
d182 3
a184 1
                                       * string) Option.opt ref = ref(Option.ABSENT)
d189 2
a190 2
                               * string)) list)) Option.option ref ref = 
          ref(ref(Option.SOME2("",[])))
d200 1
a200 1
             | _ => present_frame_info := Option.PRESENT(ty,value,valuestr));
d205 2
a206 2
                       Option.ABSENT => ""
                     | Option.PRESENT(info') =>
d210 1
a210 1
                            Option.SOME1(info) => 
d214 1
a214 1
                              (info' := Option.SOME2(info);info'')
d216 1
a216 1
                          | Option.SOME2(info',_) => info'
d325 2
a326 2
        val quit_fn_ref = ref Option.ABSENT
        val continue_fn_ref = ref Option.ABSENT
d328 2
a329 2
	fun present (ref Option.ABSENT) = false
	|   present (ref (Option.PRESENT _)) = true
d335 1
a335 1
        fun fetch_frame_info (info' as ref(Option.SOME1(info_fn))) = 
d338 1
a338 1
            info' := Option.SOME2(info);
d341 1
a341 1
        |   fetch_frame_info (ref(Option.SOME2(_,info))) = info
d346 1
a346 1
	  of (Option.ABSENT, []) => false
d362 1
a362 1
               Option.ABSENT =>
d364 1
a364 1
             | Option.PRESENT(ty,value,valuestr) => 
d377 2
a378 2
             Option.ABSENT => ()
           | Option.PRESENT f => 
d391 2
a392 2
                                        Option.ABSENT => ()
                                      | Option.PRESENT f => f ()),
d398 2
a399 2
                                           Option.ABSENT => ()
                                         | Option.PRESENT f => 
@


1.29
log
@Changes to reflect minor changes in inspector_tool.
@
text
@d4 3
d103 2
d116 2
d121 2
d189 29
d222 1
a222 22
	     select_fn = fn _ => 
             fn FRAME{name, details = (a,b,(ty,value,valuestr),info'),...} => 
             ((case valuestr of
                 "" => ()
               | "_" => ()
               | _ => present_frame_info := Option.PRESENT(ty,value,valuestr));
	      present_name := name;
              Xm.Text.setString(argsText,b
                                ^(case info' of
                                     Option.ABSENT => ""
                                   | Option.PRESENT(info') =>
                                       (present_variable_frame_info := info';
                                        if !show_variable_debug_info then 
                                          case !info' of
                                            Option.SOME1(info) => 
                                              let
                                                val info as (info'',_) = info()
                                              in
                                                (info' := Option.SOME2(info);info'')
                                              end
                                          | Option.SOME2(info',_) => info'
                                        else  "")))),
d227 8
d242 1
a242 1
            [Menus.OPTTOGGLE ("hideAnonymousFrames",
d244 2
a245 2
                              fn b => don'tshow_anon := b),
             Menus.OPTTOGGLE ("hideHandlerFrames",
d247 10
a256 7
                              fn b => don'tshow_handlers := b),
             Menus.OPTTOGGLE ("hideSetupFrames",
                              fn () => !don'tshow_setups,
                              fn b => don'tshow_setups := b),
             Menus.OPTTOGGLE ("hideCFrames",
                              fn () => !don'tshow_cframes,
                              fn b => don'tshow_cframes := b)]
d381 1
d383 44
a426 36
          [Menus.CASCADE ("action",
                          [Menus.PUSH ("abort",
                                       fn _ =>
                                       (popdown();
                                        case !quit_fn_ref of
                                          Option.ABSENT => ()
                                        | Option.PRESENT f => f ()),
				       fn _ => present quit_fn_ref),
                          Menus.PUSH ("continue",
                                       fn _ =>
                                       (popdown();
                                        case !continue_fn_ref of
                                          Option.ABSENT => ()
                                        | Option.PRESENT f => 
                                            (MLWorks.Debugger.set_step (0,"");
                                             f ())),
				       fn _ => present continue_fn_ref),
                          Menus.PUSH ("step",
                                      interval_stepper,
                                      fn _ => present continue_fn_ref),
                          Menus.PUSH ("edit_frame",
                                      edit_callback,
                                      item_selected),
                          Menus.DYNAMIC ("inspectFrameInfo",
			  	         inspect_frame_info,
             			         fn _ => exists_frame_info ())],
                         fn _ => true),
          Menus.CASCADE ("settings",
                         [Menus.PUSH ("filterFrames",
                                      settings_popup,
                                      fn _ => true),
                          Menus.PUSH ("showFrameInfo",
                                      info_settings_popup,
                                      fn _ => true)],
                         fn _ => true),
	  MotifUtils.breakpoints_menu shell]
d435 3
a438 1
           Xm.Text.setString(argsText,"");
d443 1
@


1.28
log
@Disabled stepper and breakpoint actions when appropriate, and removed
irrelevant entries ffrom inspect submenu.  Moved breakpoint menu into
motif_utils, and into the menu bar.  Simplified stepper interface.
@
text
@d4 5
d116 1
a116 1
    structure Option = Inspector_Tool.ToolData.ShellTypes.Option
d119 1
a119 1
    type ToolData = Inspector_Tool.ToolData.ToolData
@


1.27
log
@Changed resource names
@
text
@d4 3
d108 1
d165 1
d180 1
a180 1
             fn FRAME{details = (a,b,(ty,value,valuestr),info'),...} => 
d183 1
d185 1
d292 2
d299 14
d318 4
a321 2
                          fn _ => Inspector_Tool.inspect_value true make_debugger_window 
                                        (var,(value,ty),tooldata),
d323 1
a323 7
            fun fetch_frame_info (info' as ref(Option.SOME1(info))) = 
              let
                val info as (_,info'') = info()
              in
                (info' := Option.SOME2(info);info'')
              end
              | fetch_frame_info (ref(Option.SOME2(_,info))) = info
d325 3
a327 2
            (case !present_frame_info of
               Option.ABSENT => push_values (fetch_frame_info(!present_variable_frame_info))
d330 4
a333 2
                             fn _ => Inspector_Tool.inspect_value true make_debugger_window 
                             ("frame argument",(value,ty),tooldata),
d335 2
a336 1
                ::push_values (fetch_frame_info(!present_variable_frame_info)))
d339 1
a339 19
        val set_breakpoint = 
          #1(Menus.create_dialog 
             (shell,
              "Debugger Settings",
              "debuggerDialog",
              fn () => (),
              [Menus.OPTTEXT ("set breakpoint",
                              fn () => "",
                              fn breakpoint => 
                              MLWorks.Debugger.set_breakpoint (breakpoint))]))

        fun delete_breakpoint () =
          map (fn breakpoint=>
                Menus.PUSH (breakpoint,
                            fn _ => MLWorks.Debugger.delete_breakpoint (breakpoint),
                            fn _ => true))
          (MLWorks.Debugger.list_breakpoints ())

        fun interval_stepper name steps () =
d341 1
a341 1
             Option.ABSENT => nil
d343 3
a345 25
               map (fn step =>
                    Menus.PUSH("step "^MLWorks.Integer.makestring step,
                               fn _ => 
                               (MLWorks.Debugger.set_step (step,name);
                                popdown();
                                f()),
                               fn _ => true))
               steps

        fun function_stepper () =
             (map (fn FRAME{name,loc,...}=>
                   let
                     val fn_name = name^"["^loc^"]"
                   in
                     Menus.DYNAMIC (strip fn_name,
                                    interval_stepper fn_name [1,2,3,4,5,8,10,15],
                                    fn _ => true)
                   end)
             (!displayed_frames))
          

	fun exists_frame_info () =
	  case !present_frame_info
	  of Option.ABSENT => false
	  |  _ => true
d356 1
a356 4
                                       fn _ =>
                                       (case !quit_fn_ref of
                                          Option.ABSENT => false
                                        | _ => true)),
d365 4
a368 4
                                       fn _ =>
                                       (case !continue_fn_ref of
                                          Option.ABSENT => false
                                        | _ => true)),
d373 3
a375 21
                                         inspect_frame_info,
                                         fn _ => exists_frame_info ()),
                          Menus.CASCADE ("breakpoints",
                                         [Menus.PUSH ("setBreakpoint",
                                                      set_breakpoint,
                                                      fn _ => true),
                                          Menus.DYNAMIC ("deleteBreakpoint",
                                                         delete_breakpoint,
                                                         fn _ => true)],
                                         fn _ => true),
                          Menus.DYNAMIC 
                          ("intervalStepper",
                           interval_stepper "" [1,2,3,4,5,8,10,15,20,30,50,100,200,300,500],
                           fn _ => true),
                          Menus.DYNAMIC ("functionStepper",
                                         function_stepper,
                                         fn _ => true)],
                           fn _ =>
                           (case !continue_fn_ref of
                              Option.ABSENT => false
                            | _ => true)),
d383 3
a385 1
                         fn _ => true)]
@


1.26
log
@Menus for Step and breakpoints Debugger.
@
text
@d4 3
d396 1
a396 1
                                         [Menus.PUSH ("set breakpoint",
d399 1
a399 1
                                          Menus.DYNAMIC ("delete breakpoint",
d404 1
a404 1
                          ("interval stepper",
d407 1
a407 1
                          Menus.DYNAMIC ("function stepper",
@


1.25
log
@Added exists_frame_info to disable frames menu entry when no frame info
exists.
@
text
@d4 4
d113 4
a116 4
                (unit -> string * (string * (Type 
                                             * MLWorks.Internal.Value.ml_value * string)) list,
                 string * (string * (Type * MLWorks.Internal.Value.ml_value 
                                            * string)) list) Option.option ref Option.opt}
d161 4
a164 4
          (unit -> string * (string * (Inspector_Tool.Type * MLWorks.Internal.Value.ml_value 
                                       * string)) list,
           string * (string * (Inspector_Tool.Type * MLWorks.Internal.Value.ml_value 
                               * string)) list) Option.option ref ref = 
d224 3
a226 2
                  | _ => (String.substring(name,0,12) = "instance of "
                          handle String.Substring => false)
d283 4
a288 3
            fun strip str = 
              String.substring(str,0,80)^"...."
              handle String.Substring => str
d292 1
a292 1
                          fn _ => Inspector_Tool.inspect_value make_debugger_window 
d307 3
a309 3
                            fn _ => Inspector_Tool.inspect_value make_debugger_window 
                                        ("frame argument",(value,ty),tooldata),
                            fn _ => true)
d313 43
d379 3
a381 1
                                        | Option.PRESENT f => f ()),
d391 20
a410 2
                                         fn _ => exists_frame_info ())],
                          fn _ => true),
@


1.24
log
@Added copyright notice.
@
text
@d4 3
d307 5
d340 1
a340 1
                                         fn _ => true)],
@


1.23
log
@Restricted strings in inspect frame info menu to 80 characters;
Hiding instance-frames for polymorphic debugger.
@
text
@d1 2
a2 1
(*
d4 4
@


1.22
log
@Changed Options menu to Settings menu, to avoid confusion.
@
text
@d3 3
d212 2
a213 1
                  | _ => false
d272 3
d277 1
a277 1
                   Menus.PUSH (var^" = "^valuestr,
d292 1
a292 1
                 Menus.PUSH ("frame argument"^" = "^valuestr,
@


1.22.1.1
log
@Fork for bug fixing
@
text
@a2 3
 *  Revision 1.22  1993/08/28  17:59:07  daveb
 *  Changed Options menu to Settings menu, to avoid confusion.
 *
@


1.21
log
@Improved label names etc.
@
text
@d3 3
d186 1
a186 1
          val optionspec =
d215 1
a215 1
        val info_optionspec =
d249 1
a249 1
        val option_popup =
d251 1
a251 1
                                   "Debugger Options",
d254 2
a255 2
                                   optionspec))
        val info_option_popup =
d257 1
a257 1
                                  "Debugger Options",
d260 1
a260 1
                                  info_optionspec))
d322 1
a322 1
          Menus.CASCADE ("options",
d324 1
a324 1
                                      option_popup,
d327 1
a327 1
                                      info_option_popup,
@


1.20
log
@create_dialog interface change
@
text
@d3 3
d184 1
a184 1
            [Menus.OPTTOGGLE ("hide anonymous frames",
d187 1
a187 1
             Menus.OPTTOGGLE ("hide handler frames",
d190 1
a190 1
             Menus.OPTTOGGLE ("hide setup frames",
d193 1
a193 1
             Menus.OPTTOGGLE ("hide C frames",
d213 1
a213 1
          [Menus.OPTTOGGLE ("show debug info",
d216 1
a216 1
           Menus.OPTTOGGLE ("show variable debug info",
d315 1
a315 1
                          Menus.DYNAMIC ("InspectFrameInfo",
d323 1
a323 1
                          Menus.PUSH ("ShowFrameInfo",
@


1.19
log
@Inspector now invoked for values of local and closure variables;
new action "InspectFrameInfo".
@
text
@d3 4
d244 5
a248 5
          Menus.create_dialog_with_action (shell,
					   "Debugger Options",
                                           "debuggerDialog",
                                           optionspec,
                                           update_items)
d250 5
a254 5
          Menus.create_dialog_with_action (shell,
					   "Debugger Options",
                                           "debuggerDialog",
                                           info_optionspec,
                                           update_items)
@


1.18
log
@New option ShowFrameInfo in debugger window.
@
text
@d3 3
d64 1
a64 1
require "../utils/option";
d72 1
a72 1
  structure Option : OPTION
d76 1
a76 1
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget
d79 2
a80 1
    structure Option = Option
d82 10
a91 3

    datatype Frame = FRAME of {name : string, loc : string, 
                               details : string * string * string * (unit -> string) Option.opt}
d93 1
a93 1
    fun make_debugger_window (parent,name) =
d133 8
d147 4
a150 1
             fn FRAME{details = (a,b,info,info'),...} => 
d152 1
a152 2
                                ^(if !show_variable_debug_info then
                                   case info' of
d154 12
a165 2
                                   | Option.PRESENT(info') => info'()
                                  else  "")),
d167 1
a167 1
	     print_fn = fn _ => fn FRAME{details = (a,_,info,_),...} => 
d255 27
d307 5
a311 2
                                      item_selected)],
                         fn _ => true),
@


1.17
log
@Combined frame and action menus. Renamed quit to abort
@
text
@d3 3
d79 2
a80 1
    datatype Frame = FRAME of {name : string, loc : string, details : string * string}
d84 3
a115 8
        val (framesScroll, framesList, set_items) =
	  MotifUtils.make_scrolllist
	    {parent = debuggerFrame,
	     name = "debuggerFrames",
	     select_fn = fn _ => fn FRAME{details = (a,b),...} => Xm.Text.setString(argsText,b),
	     action_fn = fn _ => fn FRAME{loc,...} => (!edit_function_ref) loc, 
	     print_fn = fn _ => fn FRAME{details = (a,b),...} => a}

d123 16
d174 8
d214 6
d254 3
@


1.16
log
@Reversed logic for frame filters.
More user-friendly labels.
@
text
@d3 4
d198 1
a198 1
                          [Menus.PUSH ("quit",
d217 2
a218 4
                                        | _ => true))],
                          fn _ => true),
          Menus.CASCADE ("frame",
                         [Menus.PUSH ("edit",
@


1.15
log
@Fixed bug with item selection
@
text
@d3 3
d121 4
a124 4
          val show_cframes = ref false
          val show_handlers = ref false
          val show_setups = ref false
          val show_anon = ref true
d127 12
a138 4
            [Menus.OPTTOGGLE ("anon",fn () => !show_anon,fn b => show_anon := b),
             Menus.OPTTOGGLE ("handlers",fn () => !show_handlers,fn b => show_handlers := b),
             Menus.OPTTOGGLE ("setups",fn () => !show_setups,fn b => show_setups := b),
             Menus.OPTTOGGLE ("cframes",fn () => !show_cframes,fn b => show_cframes := b)]
d143 1
a143 1
                val showit =
d145 5
a149 5
                    "<handle>" => (!show_handlers)
                  | "<anon>" => (!show_anon)
                  | "<Cframe>" => (!show_cframes)
                  | "<Setup>" => (!show_setups)
                  | _ => true
d151 1
a151 1
                filter_frames (rest, if showit then (f::acc) else acc)
@


1.14
log
@Renamed file menu to action menu.
@
text
@d3 3
d162 1
a162 1
                  val FRAME{loc,...} = Lists.nth (index,!frames_ref)
@


1.13
log
@create_dialog now requires a title argument.
@
text
@d3 3
d179 1
a179 1
          [Menus.CASCADE ("file",
@


1.12
log
@Added message function to debugger window
@
text
@d3 3
d166 1
@


1.11
log
@Change to termination protocol
@
text
@d3 3
d204 15
d239 1
a239 13
        fn (exception_details, frames, edit_function,(quit_fn,continue_fn)) =>
        (edit_function_ref := edit_function;
         frames_ref := map FRAME frames;
         terminated := false;
         quit_fn_ref := quit_fn;
         continue_fn_ref := continue_fn;
         update_items ();
         Xm.Text.setString(text,exception_details);
         Xm.Text.setString(argsText,"");
         popup();
         (* Go into a local event loop while the window is displayed *)
         (* Loop terminated when window is unmapped *)
         while not (!terminated) do Xm.doInput())
@


1.10
log
@Added Quit and Continue buttons
Enter event handling loop before exitting.
@
text
@d3 4
d65 5
a69 2
                                     Xm.Widget.Class.Form,
                                     shell,[])
d172 1
a172 1
                                       (Xm.Widget.unmanage form;
d175 1
a175 2
                                        | Option.PRESENT f => f ();
                                        terminated := true),
d182 1
a182 1
                                       (Xm.Widget.unmanage form;
d185 1
a185 2
                                        | Option.PRESENT f => f ();
                                        terminated := true),
d203 4
d230 3
a232 1
         Xm.Widget.manage form;
@


1.9
log
@Gave sensible names to the shell and form widgets.
@
text
@d3 3
d35 1
d43 1
d50 1
d157 4
d163 22
a184 3
                          [Menus.PUSH ("close",
                                       fn _ => Xm.Widget.unmanage form,
                                       fn _ => true)],
d212 1
a212 1
        fn (exception_details, frames, edit_function) =>
d215 3
d221 2
a222 1
         Xm.Widget.manage form)
@


1.8
log
@Added menubar, frame suppression, editor interface
@
text
@d3 3
d51 1
a51 1
        val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME "dialogShell",
d54 1
a54 1
        val form = Xm.Widget.create (Xm.Widget.NAME "dialogForm",
@


1.7
log
@Changes to make_scrolllist.
@
text
@d3 3
d28 1
d35 1
d44 2
d55 4
d64 3
d71 3
d78 3
a80 7
	     select_fn = fn _ => fn (_,a) => Xm.Text.setString(argsText,a),
	     action_fn = fn _ => fn _ => (), 
	     print_fn = fn _ => fn (s,_) => s}

        val text =
          Xm.Widget.createScrolledText
          (debuggerFrame,Xm.Widget.NAME "debuggerText",[])
d86 2
d89 75
a163 18
        val separator = Xm.Widget.createManaged (Xm.Widget.NAME "dialogSep",
                                                 Xm.Widget.Class.Separator,
                                                 form,[])

        val optionsButtons =
	  Xm.Widget.createManaged (Xm.Widget.NAME "dialogButtons",
                                   Xm.Widget.Class.RowColumn,
                                   form,
                                   [])
        val buttons_update_fn = 
          Menus.make_submenus
          (optionsButtons,
           [Menus.PUSH ("ok",
                        fn _ => output(std_out,"Doing OK action\n"),
                        fn _ => true),
            Menus.PUSH ("quit",
                        fn _ => Xm.Widget.unmanage form,
                        fn _ => true)])
d165 1
d167 1
a167 1
        Xm.Widget.valuesSet (debuggerFrame,
d171 4
a174 10
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BottomWidget, Xm.WIDGET separator)]);
        Xm.Widget.valuesSet (separator,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.BottomWidget, Xm.WIDGET optionsButtons)]);
        Xm.Widget.valuesSet (optionsButtons,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
d180 7
a186 8
        fn (exception_details,
	    frame_args_list : (string * string) list,
	    lookup_function) =>
          (set_items MotifUtils.Options.default_print_options frame_args_list;
           Xm.Text.setString(text,exception_details);
           Xm.Text.setString(argsText,"");
           buttons_update_fn ();
           Xm.Widget.manage form)
@


1.6
log
@Now uses MotifUtils.make_scrolllist.
@
text
@d2 21
a22 3
 $Log: _debugger_window.sml,v $
Revision 1.5  1993/04/19  09:46:25  matthew
Used Xm callback conversion function.
a23 14
Revision 1.4  1993/04/05  14:55:08  daveb
Names of Callbacks have changed.

Revision 1.3  1993/03/30  14:46:56  matthew
Removed MENUSPEC data constructor

Revision 1.2  1993/03/26  18:27:32  matthew
Changed widget names

Revision 1.1  1993/03/25  17:07:11  matthew
Initial revision


*)
a24 1

d58 6
a63 4
	  MotifUtils.make_scrolllist (debuggerFrame, "debuggerFrames",
				      fn _ => fn (_,a) =>
						Xm.Text.setString(argsText,a),
				      fn _ => fn _ => (), fn (s,_) => s)
d116 1
a116 1
          (set_items frame_args_list;
@


1.5
log
@Used Xm callback conversion function.
@
text
@d3 3
a19 1

d23 1
d26 4
a29 2
functor DebuggerWindow(structure Xm : XM
                       structure Menus : MENUS
d31 2
a32 2
                       sharing type Menus.Widget = Xm.Widget
                         ) : DEBUGGERWINDOW =
a35 4
    fun set_items (widget,itemlist) =
      (Xm.List.deleteAllItems widget;
       Xm.List.addItems (widget, map Xm.CompoundString.createSimple itemlist,0))

d45 14
a58 3
        val debuggerFrame = Xm.Widget.createManaged (Xm.Widget.NAME "debuggerFrame",
                                                 Xm.Widget.Class.PanedWindow,
                                                 form,[])
d64 3
a66 8
        val framesScroll =
          Xm.Widget.createManaged(Xm.Widget.NAME "debuggerFrameScroll",
                                  Xm.Widget.Class.ScrolledWindow,
                                  debuggerFrame,[])
        
        val framesList = Xm.Widget.createManaged (Xm.Widget.NAME "debuggerFramesList",
                                                  Xm.Widget.Class.List,
                                                  framesScroll,[])
a67 3
        val argsText =
          Xm.Widget.createScrolledText
          (debuggerFrame,Xm.Widget.NAME "debuggerArgsText",[])
a71 11
        val optionsButtons = Xm.Widget.createManaged (Xm.Widget.NAME "dialogButtons",
                                                      Xm.Widget.Class.RowColumn,
                                                      form,
                                                      [])
        val arglistref = ref []

        fun get_selected_pos callback_data =
          let val (_,_,_,_,n,_,_,_,_) = Xm.Callback.convertList callback_data
          in
            n
          end
d73 5
a86 3
        fun find(_,[]) = ()
          | find(1,(_,a)::t) = Xm.Text.setString(argsText,a)
          | find(n,_::t) = find(n-1,t)
d108 8
a115 15
        Xm.Widget.callbackAdd (framesList,
                               Xm.Callback.SingleSelection,
                               (fn callback_data =>
                                let
                                  val pos = get_selected_pos callback_data
                                in
                                  find(pos,!arglistref)
                                end));
        fn (exception_details,frame_args_list : (string * string) list,lookup_function) =>
        (arglistref := frame_args_list;
         set_items (framesList,map #1 frame_args_list);
         Xm.Text.setString(text,exception_details);
         Xm.Text.setString(argsText,"");
         buttons_update_fn ();
         Xm.Widget.manage form)
@


1.4
log
@Names of Callbacks have changed.
@
text
@d3 3
a73 3
        fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
        val convert_callback = env "x convert ListCallbackStruct"

d75 1
a75 1
          let val (_,_,_,_,n,_,_,_,_) = convert_callback callback_data
d79 1
@


1.3
log
@Removed MENUSPEC data constructor
@
text
@d3 3
d113 1
a113 1
                               Xm.SingleSelectionCallback,
@


1.2
log
@Changed widget names
@
text
@d3 3
a78 1
           Menus.MENUSPEC
@


1.1
log
@Initial revision
@
text
@d3 2
d6 1
d28 1
a28 1
        val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME "mlDialogShell",
d31 1
a31 1
        val form = Xm.Widget.create (Xm.Widget.NAME "mlDialogForm",
d56 1
a56 1
        val separator = Xm.Widget.createManaged (Xm.Widget.NAME "mlDialogSep",
d59 1
a59 1
        val optionsButtons = Xm.Widget.createManaged (Xm.Widget.NAME "mlDialogButtons",
@
