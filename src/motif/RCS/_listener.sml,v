head	1.103;
access;
symbols
	ML_beta_release_12/08/94:1.78
	ML_beta_release_03/08/94:1.78
	ML_revised_beta_release_25/05/94:1.73
	ML_final_beta_release_02/03/94:1.69
	mlworks-28-01-1994:1.66
	Release:1.57
	mlworks-beta-01-09-1993:1.57;
locks; strict;
comment	@ * @;


1.103
date	95.07.19.13.10.03;	author matthew;	state Exp;
branches;
next	1.102;

1.102
date	95.07.17.11.48.21;	author matthew;	state Exp;
branches;
next	1.101;

1.101
date	95.07.14.17.24.01;	author io;	state Exp;
branches;
next	1.100;

1.100
date	95.07.07.15.31.47;	author daveb;	state Exp;
branches;
next	1.99;

1.99
date	95.07.04.17.17.16;	author daveb;	state Exp;
branches;
next	1.98;

1.98
date	95.07.04.10.41.19;	author matthew;	state Exp;
branches;
next	1.97;

1.97
date	95.06.15.13.01.10;	author daveb;	state Exp;
branches;
next	1.96;

1.96
date	95.06.14.13.22.54;	author daveb;	state Exp;
branches;
next	1.95;

1.95
date	95.06.08.14.44.40;	author daveb;	state Exp;
branches;
next	1.94;

1.94
date	95.06.05.13.23.44;	author daveb;	state Exp;
branches;
next	1.93;

1.93
date	95.06.01.10.32.23;	author daveb;	state Exp;
branches;
next	1.92;

1.92
date	95.05.23.14.15.44;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	95.05.23.09.26.52;	author daveb;	state Exp;
branches;
next	1.90;

1.90
date	95.05.16.09.52.33;	author matthew;	state Exp;
branches;
next	1.89;

1.89
date	95.05.04.09.41.00;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	95.04.28.15.03.04;	author daveb;	state Exp;
branches;
next	1.87;

1.87
date	95.04.19.10.57.52;	author daveb;	state Exp;
branches;
next	1.86;

1.86
date	95.04.13.17.45.13;	author daveb;	state Exp;
branches;
next	1.85;

1.85
date	95.04.06.15.37.17;	author daveb;	state Exp;
branches;
next	1.84;

1.84
date	95.03.17.12.29.42;	author daveb;	state Exp;
branches;
next	1.83;

1.83
date	95.03.16.11.50.43;	author daveb;	state Exp;
branches;
next	1.82;

1.82
date	95.03.15.17.42.01;	author daveb;	state Exp;
branches;
next	1.81;

1.81
date	95.03.10.15.34.41;	author daveb;	state Exp;
branches;
next	1.80;

1.80
date	95.01.13.15.48.40;	author daveb;	state Exp;
branches;
next	1.79;

1.79
date	94.09.21.16.37.13;	author brianm;	state Exp;
branches;
next	1.78;

1.78
date	94.08.01.10.50.40;	author daveb;	state Exp;
branches;
next	1.77;

1.77
date	94.07.27.14.05.13;	author daveb;	state Exp;
branches;
next	1.76;

1.76
date	94.07.12.15.51.20;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	94.06.23.10.06.01;	author matthew;	state Exp;
branches;
next	1.74;

1.74
date	94.06.20.17.13.57;	author daveb;	state Exp;
branches;
next	1.73;

1.73
date	94.04.20.15.57.28;	author daveb;	state Exp;
branches;
next	1.72;

1.72
date	94.04.06.12.53.03;	author daveb;	state Exp;
branches;
next	1.71;

1.71
date	94.03.15.11.29.14;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	94.03.11.15.35.13;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	94.02.17.15.07.38;	author matthew;	state Exp;
branches;
next	1.68;

1.68
date	94.02.02.11.57.21;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	94.01.28.18.06.34;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	94.01.28.10.35.19;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	93.12.22.10.52.25;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	93.12.01.16.37.28;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	93.11.26.12.25.24;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	93.11.22.17.49.31;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	93.11.18.12.19.09;	author nickh;	state Exp;
branches;
next	1.60;

1.60
date	93.10.22.17.02.58;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	93.10.08.16.39.22;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	93.09.13.09.16.08;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	93.08.31.15.26.36;	author matthew;	state Exp;
branches
	1.57.1.1;
next	1.56;

1.56
date	93.08.25.15.03.54;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	93.08.24.16.40.39;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	93.08.11.11.25.37;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	93.08.10.15.20.42;	author nosa;	state Exp;
branches;
next	1.52;

1.52
date	93.08.10.12.22.27;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	93.08.03.11.59.41;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	93.06.02.13.07.17;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	93.05.28.16.15.37;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	93.05.28.10.10.04;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	93.05.21.16.34.44;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	93.05.18.17.29.35;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	93.05.13.14.20.58;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	93.05.11.13.34.08;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	93.05.11.12.46.14;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	93.05.11.12.10.30;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	93.05.10.16.07.42;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	93.05.10.14.29.28;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	93.05.10.11.49.39;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	93.05.07.17.22.42;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	93.05.06.15.11.20;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	93.05.06.11.21.52;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	93.05.05.12.11.04;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	93.05.04.16.24.34;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	93.05.04.12.27.20;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.04.30.14.44.35;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	93.04.27.15.12.43;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	93.04.26.12.40.10;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.04.23.15.15.05;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.04.22.13.10.16;	author richard;	state Exp;
branches;
next	1.27;

1.27
date	93.04.21.14.49.46;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	93.04.21.13.46.57;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	93.04.20.16.10.57;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.04.16.17.35.40;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	93.04.16.17.13.49;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.04.15.16.06.42;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.04.14.11.17.11;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	93.04.13.09.54.12;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.04.08.12.11.31;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	93.04.08.08.36.11;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.04.07.13.40.06;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	93.04.06.10.10.39;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.04.05.10.55.13;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.04.02.15.15.30;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.03.31.13.52.25;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.03.30.11.39.23;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.03.26.18.08.56;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.03.24.10.14.03;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.03.18.18.08.55;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.03.18.09.56.56;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.03.17.16.18.38;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.03.15.17.13.35;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.03.15.14.34.51;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.11.42.44;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.03.09.15.57.55;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.04.16.40.19;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	93.03.02.19.18.28;	author daveb;	state Exp;
branches;
next	;

1.57.1.1
date	93.08.31.15.26.36;	author jont;	state Exp;
branches;
next	1.57.1.2;

1.57.1.2
date	93.09.10.11.14.01;	author daveb;	state Exp;
branches;
next	1.57.1.3;

1.57.1.3
date	93.10.08.15.07.33;	author matthew;	state Exp;
branches;
next	1.57.1.4;

1.57.1.4
date	93.10.22.15.19.33;	author daveb;	state Exp;
branches;
next	;


desc
@Listener window for motif.
@


1.103
log
@Adding "external listener" features
@
text
@(* Listener using Motif interface *)
(*
 *
 *  $Log: _listener.sml,v $
 *  Revision 1.102  1995/07/17  11:48:21  matthew
 *  Abstraction of text functionality
 *
 *  Revision 1.101  1995/07/14  17:24:01  io
 *  add searching capability
 *
 *  Revision 1.100  1995/07/07  15:31:47  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.99  1995/07/04  17:17:16  daveb
 *  Replaced ad-hoc handling of CTRL-D (which has stopped working)
 *  with an explicit function.
 *
 *  Revision 1.98  1995/07/04  10:41:19  matthew
 *  Stuff
 *
 *  Revision 1.97  1995/06/15  13:01:10  daveb
 *  Hid details of WINDOWING type in ml_debugger.
 *
 *  Revision 1.96  1995/06/14  13:22:54  daveb
 *  Type of Ml_Debugger.ml_debugger has changed.
 *
 *  Revision 1.95  1995/06/08  14:44:40  daveb
 *  Removed expansion of tabs.
 *
 *  Revision 1.94  1995/06/05  13:23:44  daveb
 *  Changed sensitivity argument of view_options to NO_SENSE_SELECTION,
 *  because the shell functions now set the current selection.
 *
 *  Revision 1.93  1995/06/01  10:32:23  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.92  1995/05/23  14:15:44  matthew
 *  Changing interface to list_select.
 *
 *  Revision 1.91  1995/05/23  09:26:52  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.90  1995/05/16  09:52:33  matthew
 *  Adding escape key functionality
 *
 *  Revision 1.89  1995/05/04  09:41:00  matthew
 *  Removed script from ml_debugger
 *
 *  Revision 1.88  1995/04/28  15:03:04  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.87  1995/04/19  10:57:52  daveb
 *  Changes to context_menu.
 *
 *  Revision 1.86  1995/04/13  17:45:13  daveb
 *  Xm.doInput is back to taking unit.
 *
 *  Revision 1.85  1995/04/06  15:37:17  daveb
 *  Type of Xm.doInput has changed.
 *
 *  Revision 1.84  1995/03/17  12:29:42  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 *
 *  Revision 1.83  1995/03/16  11:50:43  daveb
 *  Removed context_function from register when closing the window.
 *
 *  Revision 1.82  1995/03/15  17:42:01  daveb
 *  Changed to share current context with other tools..
 *
 *  Revision 1.81  1995/03/10  15:34:41  daveb
 *  MotifUtils.options_menu takes an extra argument.
 *
 *  Revision 1.80  1995/01/13  15:48:40  daveb
 *  Removed obsolete sharing constraint.
 *
 *  Revision 1.79  1994/09/21  16:37:13  brianm
 *  Adding value menu ...
 *
 *  Revision 1.78  1994/08/01  10:50:40  daveb
 *  Moved preferences to separate structure.
 *
 *  Revision 1.77  1994/07/27  14:05:13  daveb
 *  Cut-down menus for novices.
 *
 *  Revision 1.76  1994/07/12  15:51:20  daveb
 *  ToolData.works_menu takes different arguments.
 *
 *  Revision 1.75  1994/06/23  10:06:01  matthew
 *  Changed behaviour of Ctrl-E to go to end of input.
 *
 *  Revision 1.74  1994/06/20  17:13:57  daveb
 *  Changed context refs to user_contexts.  Filter out constant user_contexts
 *  from the selection menu.
 *
 *  Revision 1.72  1994/04/06  12:53:03  daveb
 *  Added breakpoints menu.
 *
 *  Revision 1.71  1994/03/15  11:29:14  matthew
 *  Changed Exit exn to Shell.Exit
 *  Cleaned up history mechanism so erroneous input is also recorded
 *
 *  Revision 1.70  1994/03/11  15:35:13  matthew
 *  Fixing bug with calling debugger
 *
 *  Revision 1.69  1994/02/17  15:07:38  matthew
 *  Fixed C-d
 *
 *  Revision 1.68  1994/02/02  11:57:21  daveb
 *  ActionQueue no longer has Incremental as a substructure.
 *
 *  Revision 1.67  1994/01/28  18:06:34  matthew
 *  Fixing locations in errors
 *
 *  Revision 1.66  1994/01/28  10:35:19  matthew
 *  Added support for C-a going to just after the prompt
 *
 *  Revision 1.65  1993/12/22  10:52:25  daveb
 *  Changed quit message for debugger, since it no longer raises Interrupt.
 *
 *  Revision 1.64  1993/12/01  16:37:28  matthew
 *  Added with_input_disabled to prevent commands being processed while in the debugger.
 *  A better solution should be possible.
 *
 *  Revision 1.63  1993/11/26  12:25:24  matthew
 *  Improvements to calling debugger.
 *
 *  Revision 1.62  1993/11/22  17:49:31  daveb
 *  Ml_Debugger.with_start_frame no longer needs a frame argument, removing
 *  the need for the call to MLWorks.Internal.Value.frame_call.
 *
 *  Revision 1.61  1993/11/18  12:19:09  nickh
 *  Change to instream arguments.
 *
 *  Revision 1.60  1993/10/22  17:02:58  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.59  1993/10/08  16:39:22  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.58  1993/09/13  09:16:08  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.57.1.4  1993/10/22  15:19:33  daveb
 *  Changed ToolData.works_menu to take a (unit -> bool) function that
 *  controls whether the Close menu option is enabled.
 *  Changed modify_verify to check for EOF, and changed input functions
 *  to deal with EOF.
 *
 *  Revision 1.57.1.3  1993/10/08  15:07:33  matthew
 *  Added destroy Callback to eg. quit from editor windows
 *  Uses history menu utilities
 *
 *  Revision 1.57.1.2  1993/09/10  11:14:01  daveb
 *  Added name parameter to MotifUtils.list_select.
 *
 *  Revision 1.57.1.1  1993/08/31  15:26:36  jont
 *  Fork for bug fixing
 *
 *  Revision 1.57  1993/08/31  15:26:36  matthew
 *  Force a new prompt when changing contexts.
 *
 *  Revision 1.56  1993/08/25  15:03:54  matthew
 *  Return quit function from ShellUtils.edit_string
 *
 *  Revision 1.55  1993/08/24  16:40:39  matthew
 *  >Improved editing error handling
 *
 *  Revision 1.54  1993/08/11  11:25:37  matthew
 *  Changes to user options
 *  Removed preferences menu
 *  Options update
 *
 *  Revision 1.53  1993/08/10  15:20:42  nosa
 *  tooldata passed to make_debugger_window for inspector invocation
 *  in debugger-window.
 *
 *  Revision 1.52  1993/08/10  12:22:27  matthew
 *  Get maximum history length from options
 *  Beep when no completion found
 *  Longest common prefix completion
 *  Pass stream name to Shell.shell
 *
 *  Revision 1.51  1993/08/03  11:59:41  matthew
 *  Added error editing operation
 *
 *  Revision 1.50  1993/06/02  13:07:17  daveb
 *  Removed value menu for the time being, since there's nothing on it.
 *
 *  Revision 1.49  1993/05/28  16:15:37  matthew
 *  Added tty_ok value to WINDOWING
 *
 *  Revision 1.48  1993/05/28  10:10:04  matthew
 *  Added completion
 *  Changed getline function
 *
 *  Revision 1.47  1993/05/21  16:34:44  matthew
 *  Added some very preliminary stuff for completion.
 *
 *  Revision 1.46  1993/05/18  17:29:35  jont
 *  Removed integer parameter
 *
 *  Revision 1.45  1993/05/13  14:20:58  daveb
 *  All tools now set their own titles and pass them to their options menus.
 *
 *  Revision 1.44  1993/05/11  13:34:08  daveb
 *  History no longer allows duplicate entries, nor very short entries,
 *  and is limited in length.
 *
 *  Revision 1.43  1993/05/11  12:46:14  daveb
 *  Added code to check state of meta keys.
 *
 *  Revision 1.42  1993/05/11  12:10:30  daveb
 *  Replaced creation of outstream with MotifUtils.make_outstream.
 *  Revised handling of contexts.
 *
 *  Revision 1.41  1993/05/10  16:07:42  daveb
 *  Changed type of ml_debugger.
 *
 *  Revision 1.40  1993/05/10  14:29:28  daveb
 *   Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *
 *  Revision 1.39  1993/05/10  11:49:39  matthew
 *  Added interrupt handler around debugger
 *  Added Ctrl-U handler and delete_current_line
 *
 *  Revision 1.38  1993/05/07  17:22:42  matthew
 *  Debugger changes
 *
 *  Revision 1.37  1993/05/06  15:11:20  matthew
 *  Simplified state_stack (now context_stack)
 *  ShellTypes revision
 *
 *  Revision 1.36  1993/05/06  11:21:52  daveb
 *  Removed inspector from values menu (It's now in the works menu).
 *  Removed old debugger code.
 *
 *  Revision 1.35  1993/05/05  12:11:04  daveb
 *  Added tools argument to works_menu(),
 *  removed exitApplication from TOOLDATA (works_menu now accesses it directly).
 *
 *  Revision 1.34  1993/05/04  16:24:34  matthew
 *  Added context selection
 *  Changed context ref handling
 *
 *  Revision 1.33  1993/05/04  12:27:20  matthew
 *  Added quit to windowing debugger.
 *  ,
 *
 *  Revision 1.32  1993/04/30  14:44:35  daveb
 *  Reorganised menus.
 *
 *  Revision 1.31  1993/04/27  15:12:43  daveb
 *  Moved options menu code to _motif_utils.
 *
 *  Revision 1.30  1993/04/26  12:40:10  matthew
 *  Indentation change & removed old tracing code
 *  Removed ML_Debugger.BASE_FRAME
 *
 *  Revision 1.29  1993/04/23  15:15:05  matthew
 *  Use Xm.Text.Replace function for replacing topdecs
 *  ModifyVerify takes note of modifications before the prompt
 *  Added yank current line
 *  Changed key bindings
 *
 *  Revision 1.28  1993/04/22  13:10:16  richard
 *  The editor interface is now implemented directly through
 *  Unix system calls, and is not part of the pervasive library
 *  or the runtime system.
 *
 *  Revision 1.27  1993/04/21  14:49:46  daveb
 *  Added browse context menu item.
 *
 *  Revision 1.26  1993/04/21  13:46:57  richard
 *  Commented out old tracing stuff..
 *
 *  Revision 1.25  1993/04/20  16:10:57  matthew
 *  Added debug function do_debug control variable
 *  Removed call to strip_prompt from getline
 *  Rewrite of do_return to handle input properly
 *
 *  Revision 1.24  1993/04/16  17:35:40  daveb
 *  Added history menu.
 *
 *  Revision 1.23  1993/04/16  17:13:49  matthew
 *  *** empty log message ***
 *
 *  Revision 1.22  1993/04/15  16:06:42  matthew
 *  Changed "text" widget name to "textIO";
 *
 *  Revision 1.21  1993/04/14  11:17:11  daveb
 *  Fixed the history mechanism.
 *
 *  Revision 1.20  1993/04/13  09:54:12  matthew
 *  Changed interface to file selection
 *
 *  Revision 1.19  1993/04/08  12:11:31  jont
 *  Added editor options menu and Editor menu
 *
 *  Revision 1.18  1993/04/08  08:36:11  daveb
 *  Fixed input to work with recent changes.  Added working lookahead.
 *  Reinstated change to location of user_options, which I accidentally erased
 *  in the previous revision.
 *
 *  Revision 1.17  1993/04/07  13:40:06  daveb
 *  Added a first stab at a history mechanism.  Buggy.  Lots of support work
 *  needed to get this far, so from here on it's plain sailing :-)
 *
 *  Revision 1.16  1993/04/06  10:10:39  jont
 *  Moved user_options and version from interpreter to main
 *  Added menu stuff for compatibility options
 *
 *  Revision 1.15  1993/04/05  10:55:13  matthew
 *  Changed ordof and MLWorks.String.ordof to String.ordof
 *  Changed interface to inspector tool
 *
 *  Revision 1.14  1993/04/02  15:15:30  matthew
 *  Structure changes
 *  Added File Selection tool
 *
 *  Revision 1.13  1993/03/31  13:52:25  matthew
 *  Added Options menus
 *
 *  Revision 1.12  1993/03/30  11:39:23  matthew
 *  Added state stack and push and pop operations thereon
 *
 *  Revision 1.10  1993/03/24  10:14:03  matthew
 *  Menu modifications
 *  Most of this is test code.
 *
 *  Revision 1.9  1993/03/18  18:08:55  matthew
 *  Added create_new_listener function
 *  Added output_fn field to shell_data
 *
 *  Revision 1.8  1993/03/18  09:56:56  matthew
 *  Add newline when using earlier line
 *
 *  Revision 1.7  1993/03/17  16:18:38  matthew
 *  Used Menus utilities to make menubar menus
 *
 *  Revision 1.6  1993/03/15  17:13:35  matthew
 *  Simplified ShellTypes types
 *
 *  Revision 1.5  1993/03/15  14:34:51  daveb
 *  Fixed problems with prompt and resizing.
 *
 *  Revision 1.4  1993/03/12  11:42:44  matthew
 *  Changed interface to shell.
 *  Haven't tested this
 *  
 *  Revision 1.3  1993/03/09  15:57:55  matthew
 *  Options & Info changes
 *  Changes for ShellData type
 *  
 *  Revision 1.2  1993/03/04  16:40:19  daveb
 *  Replaced mainWindow/text combination with rowColumn/scrolledText.
 *  Scrolling now works properly.
 *  
 *  Revision 1.1  1993/03/02  19:18:28  daveb
 *  Initial revision
 *  
 *  
 *  Copyright (c) 1993 Harlequin Ltd.
 *  
*)

(* Utilities *)
require "../utils/lists";
require "../utils/crash";

(* GUI stuff *)
require "../library/capi";
require "menus";
require "motif_utils";
require "tooldata";
require "debugger_window";

(* Environment *)
require "../main/preferences";
require "../main/user_options";

(* Compiler *)
require "../interpreter/shell";
require "../interpreter/shell_utils";
require "../interpreter/tty_listener";
require "../debugger/ml_debugger";

require "listener";
require "../interpreter/entry";

(* WARNING: Don't use std_out for error tracing when debugging this file.
   Usually you should use MLWorks.IO.terminal_out instead. *)

functor Listener (
  structure Lists: LISTS
  structure Crash : CRASH
  structure Capi: CAPI

  structure Preferences : PREFERENCES
  structure UserOptions : USER_OPTIONS

  structure Shell: SHELL
  structure ShellUtils : SHELL_UTILS
  structure TTYListener : TTY_LISTENER
  structure Ml_Debugger: ML_DEBUGGER
  structure ToolData : TOOL_DATA
  structure MotifUtils : MOTIF_UTILS
  structure Menus : MENUS
  structure DebuggerWindow : DEBUGGERWINDOW
  structure Entry : ENTRY
  sharing UserOptions.Options =
          Ml_Debugger.ValuePrinter.Options =
	  ShellUtils.Options =
    	  ToolData.ShellTypes.Options

  sharing type UserOptions.Options.print_options = Entry.PrintOptions

  sharing type ToolData.ShellTypes.user_options = UserOptions.user_tool_options =
	       MotifUtils.user_tool_options = ShellUtils.UserOptions 

  sharing type MotifUtils.user_context_options =
	       ToolData.UserContext.user_context_options

  sharing type MotifUtils.user_context = ToolData.ShellTypes.user_context

  sharing type Shell.Context = ShellUtils.Context = Entry.Context =
               ToolData.ShellTypes.Context

  sharing type Shell.ShellData = ToolData.ShellTypes.ShellData

  sharing type Menus.Widget = DebuggerWindow.Widget = ToolData.Widget =
    	       MotifUtils.Widget = Capi.Widget

  sharing type TTYListener.ListenerArgs = ToolData.ShellTypes.ListenerArgs
   
  sharing type Menus.ButtonSpec = MotifUtils.ButtonSpec = ToolData.ButtonSpec
  sharing type ToolData.ToolData = DebuggerWindow.ToolData
  sharing type Preferences.preferences = ToolData.ShellTypes.preferences =
	       Ml_Debugger.preferences = ShellUtils.preferences
  sharing type Preferences.user_preferences = ShellUtils.user_preferences =
	       ToolData.ShellTypes.user_preferences =
	       MotifUtils.user_preferences
  sharing type MotifUtils.MotifContext = ToolData.MotifContext
  sharing type Ml_Debugger.debugger_window = DebuggerWindow.debugger_window
): LISTENER =
struct
  structure Info = ShellUtils.Info
  structure Location = Info.Location
  structure Options = ShellUtils.Options
  structure ShellTypes = ToolData.ShellTypes
  structure UserContext = ToolData.UserContext
  structure Integer = MLWorks.Integer
  structure Option = MLWorks.Option
  structure IO = MLWorks.IO

  type ToolData = ToolData.ToolData

  val do_debug = false
  fun debug s = if do_debug then output(IO.terminal_out,s ^ "\n") else ()
  fun fdebug f = if do_debug then output(IO.terminal_out,f() ^ "\n") else ()
  fun ddebug s = output(IO.terminal_out,s ^ "\n")

  fun make_debugger_function (debugger_type,user_options,user_preferences,local_context) f x =
    Ml_Debugger.with_start_frame
    (fn base_frame =>
     (f x)
     handle
     exn as ShellTypes.DebuggerTrapped => raise exn
   |  exn as Shell.Exit _ => raise exn
   |  exn as Interrupt => raise exn
   |  exn as Info.Stop _ => raise exn
   |  exn as Capi.SubLoopTerminated => raise exn
   |  exn =>
        (Ml_Debugger.ml_debugger
         (debugger_type,
          ShellTypes.new_options
          (user_options,
           MotifUtils.get_user_context (!local_context)),
          Preferences.new_preferences user_preferences)
         (base_frame,
          Ml_Debugger.EXCEPTION exn,
          Ml_Debugger.POSSIBLE
          ("quit (return to listener)",
           Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
          Ml_Debugger.NOT_POSSIBLE);
         raise ShellTypes.DebuggerTrapped))


  (* Some dull utilities *)
  (* this should just look for a "prompt character" eg. a ">". *)
  fun strip_prompt(string) =
    let val chars = explode string
      fun strip [] = chars
        | strip (">"::(l as ">" :: _)) = strip l
        | strip (">":: " " :: l) = l
        | strip (">":: l) = l
        | strip (_::l) = strip l
    in
      implode (strip chars)
    end
  
  fun whitespacep x =
    case x of
      " " => true
    | "\n" => true
    | "\t" => true
    | "\012" => true
    | "\013" => true
    | _ => false
        
  fun trivial s = 
    let
      fun trivial' (~1, _) = true
        | trivial' (n, s) =
          if whitespacep (String.substring (s, n, 1))
            then trivial' (n-1, s)
          else false
    in
      trivial' (size s - 1, s)
    end
  
  fun strip_whitespace s =
    let
      fun strip [] = []
        | strip (l as (a::b)) =
          if whitespacep a then strip b else l
    in
      implode (rev (strip (rev (strip (explode s))))) (* Yuk Yuk *)
    end
  
  fun strip_trivia [] = []
    | strip_trivia (l as (a::b)) =
      if trivial a then strip_trivia b else l
        
  exception NoLocation
  fun get_location line =
    let
      val sz = size line
      fun aux index =
        if index < sz
          then
            if String.ordof(line,index) = ord ":"
              then index+1
            else
              aux (index+1)
        else
          raise NoLocation
      (* skip up to second ":" *)
      val result = String.substring(line,0,(aux (aux 0))-1)
    in
      result
    end
      
  val listener_number = ref 1

      (* TEXT UTILITIES *)

      fun get_current_line text =
        let
          val pos = Capi.Text.get_insertion_position text
        in
          Capi.Text.get_line (text, pos)
        end
        
      fun get_current_subline (text,start_pos) =
        let
          val (line,ix) = Capi.Text.get_line_and_index (text,start_pos)
          val line2 = strip_prompt line
          val ix2 = ix - (size line - size line2)
        in
          if ix2 > 0 then String.substring (line2,0,ix2) else ""
        end
          
      val (input_flag,input_string) = (ref false,ref "")

(*
      val (outstream,instream,clear_input) =
        if external
          then
            let
              val home = "/usr/users/matthew"
              val server_socket_name = ".my_socket"
              val s = MLWorks.OS.Unix.socket (1, 1, 0)
              val _ = MLWorks.OS.Unix.connect (s, MLWorks.OS.Unix.SOCKADDR_UNIX "/usr/users/matthew/my-server")
              val outstream = 
                MLWorks.IO.outstream {output = fn str => (MLWorks.OS.Unix.write (s,str);()),
                                      flush_out = fn _ => (),
                                      close_out = fn () => (),
                                      closed_out = fn () => false}
              fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

              val set_handler : (unit -> unit) -> unit = env "x register handler";

              fun readln s =
                let
                  fun aux acc =
                    let
                      val char = input(s,1)
                    in
                      case char of
                        "" => acc
                      | "\n" => "\n" :: acc
                      | s => aux (s :: acc)
                    end
                in
                  implode (rev (aux []))
                end

              fun getinput () =
                let
                  val str = open_in "/tmp/1234"
                  val line = readln str
                in
                  close_in str;
                  line
                end
              fun do_return () =
                do_line (getinput ())

              val _ = set_handler do_return;
            in
              (outstream)
            end
*)

      fun insert_at (text,pos,str) =
        (Capi.Text.insert (text,pos,str);
         Capi.Text.set_insertion_position (text, pos + size str))

      fun replace_current_input ((text,prompt_pos,write_pos),line) =
	let 
          val length = Capi.Text.get_last_position text
	in 
	  (* Capi.Text.replace doesn't always work properly for X. *)
          (* But setting the whole string causes ridiculous amounts of flicker. *)
          Capi.Text.replace (text,!prompt_pos,length,line);
	  Capi.Text.set_insertion_position (text, !prompt_pos + size line)
	end

      fun delete_current_line text_info =
        fn _ => replace_current_input (text_info,"")

      fun yank_current_line (text,prompt_pos,write_pos) =
        fn _ => 
	let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
        in
          if pos < !prompt_pos then
            let val line = strip_prompt (Capi.Text.get_line (text,pos))
            in
              Capi.Text.insert(text, last_pos, line);
              Capi.Text.set_insertion_position (text, last_pos+size line)
            end
          else
            ()
        end

      fun start_of_line (text,prompt_pos,write_pos) () =
        let
          val ppos = !prompt_pos
          val pos = Capi.Text.get_insertion_position text
          val new_pos =
            if pos < ppos
              then Capi.Text.current_line (text,pos)
            else ppos
        in
          Capi.Text.set_insertion_position (text,new_pos)
        end
          
      fun end_of_line (text,prompt_pos,write_pos) () =
        let
          val ppos = !prompt_pos
          val pos = Capi.Text.get_insertion_position text
          val new_pos =
            if pos < ppos
              then Capi.Text.end_line (text,pos)
            else Capi.Text.get_last_position text
        in
          Capi.Text.set_insertion_position (text,new_pos)
        end
          
      fun get_input_from_return (text,prompt_pos,write_pos) =
        let
          val pos = Capi.Text.get_insertion_position text
        in
          if pos < !prompt_pos then
            let
              val line = strip_prompt (Capi.Text.get_line (text, pos)) ^ "\n"
              val last_pos = Capi.Text.get_last_position text
            in
              Capi.Text.insert(text, last_pos, line);
              write_pos := last_pos + size line;
              Capi.Text.set_insertion_position (text, last_pos + size line);
              [line]
            end
          else
            let
              val length = Capi.Text.get_last_position text
                
              fun get_lines ([], current, acc, _) =
                map (implode o rev) (current :: acc)
                |   get_lines ("\n"::rest, current, acc, column) =
                    get_lines (rest, [], ("\n"::current)::acc, 1)
                |   get_lines (c::rest, current, acc, column) =
                    get_lines (rest, c::current, acc, column+1)

              val line = Capi.Text.substring (text, !write_pos,length - !write_pos)
              val lines = get_lines (explode line,[],[],0)
            in
              case lines of
                last :: rest =>
                  (Capi.Text.insert (text, length, "\n");
                   write_pos := length + 1;
                   Capi.Text.set_insertion_position (text, length+1);
                   last ^ "\n" :: rest)
              | _ => lines
            end
        end

      fun do_insert_text ((text,prompt_pos,write_pos),start_pos,end_pos,str) =
        (fdebug (fn _ =>
                 "Verify: start_pos is " ^ Integer.makestring start_pos ^
                 ", end_pos is " ^ Integer.makestring end_pos ^
                 ", write_pos is " ^ Integer.makestring (!write_pos) ^
                 ", prompt_pos is " ^ Integer.makestring (!prompt_pos) ^
                 ", string is '" ^ str ^ "'");
        if end_pos < !write_pos 
          then write_pos := (!write_pos) - end_pos + start_pos + size str
        else if start_pos < !write_pos then
          write_pos := start_pos + size str
	else ();
        if end_pos < !prompt_pos
          then prompt_pos := (!prompt_pos) - end_pos + start_pos + size str
        else if start_pos < !prompt_pos 
          then prompt_pos := start_pos + size str
        else ())

      (* END TEXT UTILITIES *)

  (* The main function *)
  fun create external (tooldata as ToolData.TOOLDATA {args,appdata,current_context,motif_context,tools}) =
    let
      val ShellTypes.LISTENER_ARGS {user_options,
                                    user_preferences,
                                    prompter,
                                    mk_xinterface_fn,
                                    ...} = args

      val ToolData.APPLICATIONDATA {applicationShell,...} = appdata

      val full_menus =
	case user_preferences
	of Preferences.USER_PREFERENCES ({full_menus, ...}, _) =>
	  !full_menus

      val title =
        let
          val n = !listener_number
        in
          listener_number := n+1;
          "Listener #" ^ Integer.makestring n
        end

      val location_title = "<"^title^">"

      (*** Make the windows ***)
      val (shell,mainWindow,menuBar,contextLabel) =
        Capi.make_main_window ("listener",title,applicationShell,full_menus)

      (*** IO functions ***)

      fun beep _ = Capi.beep shell
      fun message_fun s = Capi.send_message (shell,s)

      val local_context = ref motif_context

      (*** Debugger Functions ***)

      (* This creates the debugger window when the listener is being created *)
      (* Strange things happen if done at debugger entry time *)
      val debugger_type = 
        Ml_Debugger.WINDOWING
	  (DebuggerWindow.make_debugger_window (shell, "debugger", tooldata),
	   fn s => output (std_out, s),
	   true)

      val debugger_function =
        make_debugger_function (debugger_type,user_options,user_preferences,local_context)

      (* Options and contexts *)
      fun get_user_options () = user_options

      val shell_data = 
        ShellTypes.SHELL_DATA
        {get_user_context =
	   fn () => MotifUtils.get_user_context (!local_context),
         user_options = user_options,
	 user_preferences = user_preferences,
         prompter = prompter,
         debugger = debugger_function,
         exit_fn = fn n => raise Shell.Exit n,
         x_running = true,	(* Can't start X interface from an X listener *)
         mk_xinterface_fn = mk_xinterface_fn,
				(* for starting X from a saved image *)
         mk_tty_listener = TTYListener.listener
				(* for starting saved images *)
         }
      
      val quit_funs = ref []

      fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

      (* Text stuff *)
      val (scroll,text) = (Capi.make_scrolled_text ("textIO",mainWindow,[]))

      (* write_pos is the position new input should go in the buffer, usually the end.
         Also used as the position from which input is read. 
         Output from the program should go before this position.  Input is read
         from after it.
	 prompt_pos is the position just after the most recent prompt.
	 The current compiler input lies between prompt_pos and 
	 get_last_pos text *)

      val write_pos = ref 0
      val prompt_pos = ref 0

      val text_info = (text,prompt_pos,write_pos)

      fun insert_at_current s =
        Capi.Text.insert (text, Capi.Text.get_insertion_position text, s)

      local 
        (* Insert at the current write_pos *)
        fun insert_text str =
          (Capi.Text.insert (text, !write_pos, str);
           write_pos := size str + !write_pos;
           Capi.Text.set_insertion_position (text, !write_pos))

        val inbuff as (posref,strref) = (ref 0,ref "")
            
        fun input_fun () =
          (input_flag := true;
           Capi.event_loop input_flag;
           !input_string)

        fun refill_buff () =
          let val new_string = input_fun ()
          in
            posref := 0;
            strref := new_string
          end

	val eof_flag = ref false

        fun get_input n =
          let
            val string = !strref
            val pointer = !posref
            val len = size string
          in
            if !eof_flag then
              ""
            else if pointer + n > len then
              (refill_buff ();
               String.substring (string,pointer,len-pointer) ^
               get_input (n - len + pointer))
                 else
                   let val result = String.substring (string,pointer,n)
                   in
                     posref := (!posref + n);
                     result
                   end
          end

        fun do_lookahead () =
          (if !eof_flag then
             ""
          else if !posref >= size (!strref) then
             (refill_buff ();
              do_lookahead ())
               else 
                 String.substring (!strref, !posref, 1))
	       
	fun close_in () = eof_flag := true
	fun closed_in () = !eof_flag
	fun clear_eof () = eof_flag := false
      in
        val outstream = MotifUtils.make_outstream insert_text

        fun clear_input () =
	  (debug "Clearing input";
           posref := 0;
	   strref := "";
	   eof_flag := false)

        val instream = 
          IO.instream {input = get_input,
                       lookahead = do_lookahead,
                       end_of_stream = fn () => do_lookahead () = "",
                       clear_eof = clear_eof,
                       close_in = close_in,
                       closed_in = closed_in}

      end

      fun eof_or_delete (text,prompt_pos,write_pos) () =
        let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
        in
          if pos = last_pos andalso pos = !write_pos then
            (debug "eof";
             if !input_flag then
               (close_in instream;
                input_flag := false)
             else
               beep ())
          else
            (debug "delete";
             Capi.Text.replace (text, pos, pos + 1, ""))
        end

      fun edit_error _ =
        (let
          (* Get a location string from the current line *)
          val line = get_current_line text
          val locstring = get_location line
          val quit_fun = 
            ShellUtils.edit_string
	      (locstring, ShellTypes.get_current_preferences shell_data)
         in
           quit_funs := quit_fun :: (!quit_funs)
        end 
      handle ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
           | NoLocation => message_fun "Edit failed: no location info found"
           | Location.InvalidLocation => message_fun "Edit failed: no location info found")

      (* SYMBOL COMPLETION *)
      (* Necessary for popping down completion window *)
      val actions_after_input = ref []
      val popup_completion = MotifUtils.list_select (shell,"completions")

      (* name completion *)
      fun do_completion start_pos =
        let
          (* The current line up to pos *)
          val subline = get_current_subline (text,start_pos)
          val use_completion_menu =
            let
              val preferences = ShellTypes.get_current_preferences shell_data
              val Preferences.PREFERENCES
		{environment_options =
                 Preferences.ENVIRONMENT_OPTIONS {completion_menu,...},
		 ...} =
                preferences
            in
              !completion_menu
            end
          val options = ShellTypes.get_current_options shell_data
          val (sofar,completions) = 
            ShellUtils.get_completions
	      (subline, options,
	       UserContext.get_context
		 (MotifUtils.get_user_context (!local_context)))
          fun insert_fun a =
            insert_at (text,start_pos,String.substring (a, size sofar, size a - size sofar))
        in
          case completions of
            [] => beep ()
          | [a] => insert_fun a
          | l => 
              let val c = ShellUtils.find_common_completion l 
              in
                if c = sofar then
                  if (use_completion_menu) then
                    actions_after_input := 
                    popup_completion (l,insert_fun, fn x => x) :: !actions_after_input
                  else beep ()
                else insert_fun c
              end
        end

      val replace_current_input = fn s => replace_current_input (text_info,s)
      val get_input_from_return = fn () => get_input_from_return text_info

      val input_disabled = ref false

      fun with_input_disabled f =
        (input_disabled := true;
         let
           val result = f () handle exn => (input_disabled := false;raise exn)
         in
           input_disabled := false;
           result
         end)

      val (handler', make_prompt) = Shell.shell (shell_data,location_title)

      fun handler s =
        with_input_disabled
        (fn () => 
         IO.with_standard_output
         outstream
         (fn () =>
          IO.with_standard_input
          instream
          (fn () =>
           Ml_Debugger.with_debugger_type
           debugger_type
           (fn _ => 
            ShellTypes.with_toplevel_name location_title
            (fn _ => handler' s)))))

      fun output_prompt () =
        (output(outstream,make_prompt (MotifUtils.get_context_name (!local_context)));
         IO.flush_out outstream;
	 prompt_pos := !write_pos)

      fun force_prompt () =
        (handler "\n"; (* Forces something to happen? *)
         output (outstream,"\n");
         output_prompt())

      fun set_context_state (motif_context) =
	case contextLabel of
          MLWorks.Option.SOME w =>
            (local_context := motif_context;
             Capi.set_label_string (w,"Context: " ^ MotifUtils.get_context_name motif_context))
	|  MLWorks.Option.NONE => ()
              
      val _ = set_context_state motif_context

      fun set_state context = (set_context_state context; force_prompt ())

      val context_key =
	ToolData.add_context_fn
          (current_context, (set_state, get_user_options, ToolData.WRITABLE))

      val _ =
	quit_funs :=
	  (fn () => ToolData.remove_context_fn (current_context, context_key))
	  :: !quit_funs

      fun select_context motif_context =
        (set_state motif_context;
         ToolData.set_current
           (current_context, context_key, user_options, motif_context))

      val current_topdec = ref [];

      fun add_line line =
        let val topdec =
          case !current_topdec of
            [] => if trivial line then [] else [line]
          | lines => line :: lines
        in
          current_topdec := topdec
        end

      (* HISTORY *)
      (* The history is a list of topdecs, combined with an index number. *)
      (* The index is used to set the current_index ref when a topdec is *)
      (* selected from the menu. *)
      val history = ref []: (string * int) list ref;
      val history_size = ref 0;
      val initial_index = ~1;
      val history_index = ref initial_index;

      fun add_history_entry new_entry =
        if size new_entry > 4 then
          (history_size := !history_size + 1;
           ShellUtils.add_history_item ((new_entry, !history_size),
                                        history,
                                        (fn ((s,_),(s',_))=>s=s'),
                                        user_preferences))
        else ()
        
      fun do_history_entry () =
        let 
          val topdec = strip_trivia (!current_topdec)
          val new_entry = implode (rev topdec)
        in
          add_history_entry (strip_whitespace new_entry);
          current_topdec := []
        end

      fun update_history (([], false), line) =
        (add_line line;
         do_history_entry ())
        | update_history (([], true), line) =
          add_line line
        | update_history ((h::t, still_valid), line) =
          let 
            val newbit = String.substring (line, 0, h)
            val rest_of_line =
              String.substring (line, h, size line - h)
          in
            (add_line newbit;
             do_history_entry ();
             update_history ((map (fn x => x-h) t, still_valid), rest_of_line))
          end

      fun pop_history () = 
	let val _ = history_index := !history_index + 1
	    val line = #1 (Lists.nth (!history_index, !history))
	in 
	  replace_current_input line
	end
	handle Lists.Nth => history_index := !history_index - 1;

      fun push_history () = 
	let val _ = history_index := !history_index - 1;
	    val line = #1 (Lists.nth (!history_index, !history))
	               handle
	  		 Lists.Nth =>
			   (history_index := initial_index;
			    ""	(* empty input *))
	in 
	  replace_current_input line
	end

      fun warp_history string =
        ShellUtils.trim_history_string (string, user_preferences)

      fun finish_up () =
        (output_prompt ();
	 history_index := initial_index;
	 (* Clear waiting input from std_in. *)
	 clear_input ())

      fun do_return () =
	let
          val lines = get_input_from_return ()
        in
          if !input_flag
            then
              (input_string := implode (rev lines);
               input_flag := false)
          else
            if !input_disabled
              then beep ()
            else
              (Lists.iterate
               (fn line => update_history (handler line, line))
               (rev lines);
               finish_up ())
        end

      (* More text stuff *)
      (* A flag to indicate whether escape has just been pressed *)
      val escape_pressed = ref false

      fun do_escape () = escape_pressed := true

      val meta_bindings =
        [("p", pop_history),
         ("n", push_history),
         ("w", fn _ => MotifUtils.copySelection text)]

      val normal_bindings =
        [("\^A", start_of_line text_info),
         ("\^D", eof_or_delete text_info),
         ("\^E", end_of_line text_info),
         ("\^W", fn _ => MotifUtils.cutSelection text),
         ("\^Y", fn _ => MotifUtils.pasteSelection text),
         ("\^U", delete_current_line text_info),
         ("\^J", yank_current_line text_info),
         ("\013",do_return),
         ("\027",do_escape)]

      fun despatch_key bindings key =
        let
          fun loop [] = beep ()
            | loop ((key',action)::rest) =
              if key = key' then action ()
              else loop rest
        in
          loop bindings
        end

      val despatch_meta = despatch_key meta_bindings
      val despatch_normal = despatch_key normal_bindings

      fun modifyVerify callback_data =
        let
          val _ =
            (Lists.iterate (fn f => f ()) (!actions_after_input);
             actions_after_input := [])
          val (event,start_pos,end_pos,str,set_fn) =
            Capi.Callback.convert_verify_data callback_data
        in
          if !escape_pressed andalso size str = 1 
            then 
              (escape_pressed := false;
               set_fn false;
               despatch_meta str)
          else if str = "\t"
            then
              (do_completion start_pos;
               set_fn false)
          else
            (do_insert_text (text_info,start_pos,end_pos,str);
             set_fn true)
        end
	handle Shell.Exit _ => Capi.destroy shell

      fun activate callback_data =
	let 
          val event = Capi.Callback.get_event callback_data
        in
          case Capi.Event.get_key_data event of
            MLWorks.Option.SOME (key,modifiers) =>
              if Lists.member (Capi.Event.meta_modifier, modifiers)
                then despatch_meta key
              else despatch_normal key
          | _ => (debug("activate: non-key event");
                  beep ())
        end
      handle Shell.Exit _ => Capi.destroy shell

      fun mk_tooldata () =
	ToolData.TOOLDATA {args = ShellTypes.get_listener_args shell_data,
                           appdata = appdata,
			   current_context = current_context,
			   motif_context = !local_context,
                           tools = tools}

      fun close_window _ =
        (do_quit_funs ();
         Capi.destroy shell)

      val value_menu =
          MotifUtils.value_menu
              (shell,
	       MotifUtils.get_user_context (!local_context),
	       user_options,
	       user_preferences,
	       [text]
              )
      (* added search stuff here *)
      fun get_print_options () = UserOptions.new_print_options (get_user_options ())

      fun flat (x::xs) = ((implode x)^"\n") :: (flat xs)
	| flat [] = []
	      
      fun grep regexp line = let
	fun startsWith [] ys = true
	  | startsWith xs [] = false
	  | startsWith (x::xs) (y::ys) = (x=y) andalso (startsWith xs ys)
	fun check [] ys = false
	  | check xs [] = false
	  | check xs (y::ys) = startsWith xs (y::ys) orelse check xs ys
      in
	check (explode regexp) (explode line)
      end (* grep *)
	
      fun collect f xs = let
	fun collect f acc [] = rev acc
	  | collect f acc (x::xs) =
	    if f x then collect f (x::acc) xs
	    else collect f acc xs
      in (* let *)
	collect f [] xs
      end (* collect *)

      val searchOptions = ref
	{showSig = true,
	 showStr = true,
	 showFun = true,
	 searchInitial = false,
	 showType = true}
	 
      fun search s = let
	fun getItemsFromContext c = let
	  val context = #2(UserContext.get_context_info
			   (MotifUtils.get_user_context c))
	in
	  Entry.context2entry context
	end
      			    
	val context =
	  if (#searchInitial (!searchOptions)) then
	    getItemsFromContext(MotifUtils.getInitialContext())
	  else
	    getItemsFromContext (!local_context)

	val printOptions = get_print_options()

	(* datatype Entry is a linear structure, munge to tree like form *)
	val entrys = map Entry.massage context
	val entrys' = Entry.printEntry1 (!searchOptions) printOptions entrys
	val entrys' = map implode entrys'
	(*
          val _ = debug_output
	  ("search on \""^s^"\" with options..."^Entry.printSearchOptions (!searchOptions))
	  val _ = map debug_output entrys'
	  val _ = debug_output ("applying search now...")
	 *)
	val found = collect (grep s) entrys'
	val _ = MotifUtils.list_select
	  (shell, "ListSelect Name")
	  (found,
	   insert_at_current,
	   fn x => x)
      in
	()
      end (* search *)
	    
      val searchSpec =
	[Menus.OPTLABEL "Search inside...",
	 Menus.OPTSEPARATOR,
	 Menus.OPTTOGGLE ("signatures", fn ()=> #showSig (!searchOptions),
			  fn b=>searchOptions:=Entry.update ("showSig", b, !searchOptions)),
	 Menus.OPTTOGGLE ("structures", fn ()=> #showStr (!searchOptions),
			  fn b=>searchOptions:=Entry.update ("showStr", b, !searchOptions)),
	 Menus.OPTTOGGLE ("functors",   fn ()=> #showFun (!searchOptions),
			  fn b=>searchOptions:=Entry.update ("showFun", b, !searchOptions)),
	 Menus.OPTSEPARATOR,
	 Menus.OPTTOGGLE ("Display their types", fn ()=> #showType (!searchOptions),
			  fn b=>searchOptions:=Entry.update ("showType", b, !searchOptions)),
	 Menus.OPTSEPARATOR,
	 Menus.OPTTOGGLE ("Search in Initial Context", fn ()=> #searchInitial (!searchOptions),
			  fn b=>searchOptions := Entry.update ("searchInitial", b, !searchOptions)),
	 Menus.OPTSEPARATOR,
	 Menus.OPTTEXT ("Search for Item", fn () => "" , fn s =>search s)
	 ]
      fun searchPopup _ =
	((#1 (Menus.create_dialog
	    (shell, "Search Window", "browserDialog", fn ()=>(), searchSpec))) ())
	  
      val tailmenuspec =
	[MotifUtils.breakpoints_menu shell,
	 Menus.CASCADE
	 ("Search",
	  [Menus.PUSH ("search", searchPopup, fn _=>true)],
	  fn _=>true),
	 Menus.DYNAMIC ("history",
			fn () =>
			map (fn (s,i) =>
                             Menus.PUSH (warp_history s,
                                         fn _ => (replace_current_input s;
                                                  history_index :=
                                                  !history_size - i),
                                         fn _ => true))
                        (!history),
                        fn _ => !history <> [])]

      val view_options =
	MotifUtils.view_options
	{parent = shell, title = title, user_options = user_options,
	 user_preferences = user_preferences,
	 caller_update_fn = fn _ => (),
	 sensitivity = MotifUtils.NO_SENSE_SELECTION,
	 view_type = MotifUtils.VIEW_ALL}
	
      val menuspec =
	ToolData.works_menu
	(mk_tooldata, close_window,
	 fn _ => not (!input_flag),
	 fn () => MotifUtils.get_user_context (!local_context))
        :: Menus.CASCADE ("view", view_options, fn () => true)
        :: value_menu
	:: MotifUtils.context_menu
	{set_state = select_context,
	 get_context = fn _ => !local_context,
	 writable = MotifUtils.WRITABLE,
	 applicationShell = applicationShell,
	 user_preferences = user_preferences}
	:: (if full_menus then
	      Menus.CASCADE
	      ("error", [Menus.PUSH ("edit", edit_error, fn _ => true)],
	       fn _ => true)
	      :: tailmenuspec
	    else
	      tailmenuspec)
    in
      Menus.make_submenus (menuBar,menuspec);
      Capi.Layout.lay_out
      ([Capi.Layout.MENUBAR menuBar] @@
       (case contextLabel of
          MLWorks.Option.SOME w => [Capi.Layout.OTHER w]
        | _ => [Capi.Layout.SPACE]) @@
       [Capi.Layout.TEXT scroll,
        Capi.Layout.SPACE]);
      Capi.Callback.add (text, Capi.Callback.Activate, activate);
      Capi.Callback.add (text, Capi.Callback.ModifyVerify, modifyVerify);
      Capi.Callback.add (shell, Capi.Callback.Destroy,do_quit_funs);
      Capi.manage menuBar;
      Capi.manage text;
      Capi.manage shell;
      Capi.realize shell;
      output_prompt()
    end
end;
@


1.102
log
@Abstraction of text functionality
@
text
@d5 3
a554 38
  (* The main function *)
  fun create (tooldata as ToolData.TOOLDATA
              {args,appdata,current_context,motif_context,tools}) =
    let
      val ShellTypes.LISTENER_ARGS {user_options,
                                    user_preferences,
                                    prompter,
                                    mk_xinterface_fn,
                                    ...} = args

      val ToolData.APPLICATIONDATA {applicationShell,...} = appdata

      val full_menus =
	case user_preferences
	of Preferences.USER_PREFERENCES ({full_menus, ...}, _) =>
	  !full_menus

      val title =
        let
          val n = !listener_number
        in
          listener_number := n+1;
          "Listener #" ^ Integer.makestring n
        end

      val location_title = "<"^title^">"

      (*** Make the windows ***)
      val (shell,mainWindow,menuBar,contextLabel) =
        Capi.make_main_window ("listener",title,applicationShell,full_menus)

      val (scroll,text) = Capi.make_scrolled_text ("textIO",mainWindow,[])

      (*** IO functions ***)

      fun beep _ = Capi.beep shell
      fun message_fun s = Capi.send_message (shell,s)

d557 1
a557 12
      (* write_pos is the position new input should go in the buffer, usually the end.
         Also used as the position from which input is read. 
         Output from the program should go before this position.  Input is read
         from after it.
	 prompt_pos is the position just after the most recent prompt.
	 The current compiler input lies between prompt_pos and 
	 get_last_pos text *)

      val write_pos = ref 0
      val prompt_pos = ref 0

      fun get_current_line (text) =
d575 43
a617 6
      local 
        (* Insert at the current write_pos *)
        fun insert_text str =
          (Capi.Text.insert (text, !write_pos, str);
           write_pos := size str + !write_pos;
           Capi.Text.set_insertion_position (text, !write_pos))
d619 5
a623 66
        val inbuff as (posref,strref) = (ref 0,ref "")
            
        fun input_fun () =
          (input_flag := true;
           Capi.event_loop input_flag;
           !input_string)

        fun refill_buff () =
          let val new_string = input_fun ()
          in
            posref := 0;
            strref := new_string
          end

	val eof_flag = ref false

        fun get_input n =
          let
            val string = !strref
            val pointer = !posref
            val len = size string
          in
            if !eof_flag then
              ""
            else if pointer + n > len then
              (refill_buff ();
               String.substring (string,pointer,len-pointer) ^
               get_input (n - len + pointer))
                 else
                   let val result = String.substring (string,pointer,n)
                   in
                     posref := (!posref + n);
                     result
                   end
          end

        fun do_lookahead () =
          (if !eof_flag then
             ""
          else if !posref >= size (!strref) then
             (refill_buff ();
              do_lookahead ())
               else 
                 String.substring (!strref, !posref, 1))
	       
	fun close_in () = eof_flag := true
	fun closed_in () = !eof_flag
	fun clear_eof () = eof_flag := false
      in
        val outstream = MotifUtils.make_outstream insert_text

        fun clear_input () =
	  (debug "Clearing input";
           posref := 0;
	   strref := "";
	   eof_flag := false)

        val instream = 
          IO.instream {input = get_input,
                       lookahead = do_lookahead,
                       end_of_stream = fn () => do_lookahead () = "",
                       clear_eof = clear_eof,
                       close_in = close_in,
                       closed_in = closed_in}

      end
d629 1
a629 1
      fun replace_current_input (text,line) =
d639 2
a640 2
      fun delete_current_line () =
        replace_current_input (text,"")
d642 2
a643 1
      fun yank_current_line () =
d658 1
a658 1
      fun start_of_line () =
d670 1
a670 1
      fun end_of_line () =
d682 1
a682 18
      fun eof_or_delete () =
        let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
        in
          if pos = last_pos andalso pos = !write_pos then
            (debug "eof";
             if !input_flag then
               (close_in instream;
                input_flag := false)
             else
               beep ())
          else
            (debug "delete";
             Capi.Text.replace (text, pos, pos + 1, ""))
        end

      fun get_input_from_return () =
d720 1
a720 1
      fun do_insert_text (start_pos,end_pos,str) =
d740 35
d813 110
d983 3
d1107 1
a1107 1
	  replace_current_input (text,line)
d1119 1
a1119 1
	  replace_current_input (text,line)
d1149 1
d1161 3
a1163 3
        [("\^A", start_of_line),
         ("\^D", eof_or_delete),
         ("\^E", end_of_line),
d1166 2
a1167 2
         ("\^U", delete_current_line),
         ("\^J", yank_current_line),
d1202 1
a1202 1
            (do_insert_text (start_pos,end_pos,str);
d1303 2
a1304 2
	   fn x=>Capi.Text.insert(text, Capi.Text.get_insertion_position text, x),
	   fn x=>x)
d1341 1
a1341 1
                                         fn _ => (replace_current_input (text,s);
@


1.101
log
@add searching capability
@
text
@d5 3
d363 1
a363 1
require "../library/capi";
d366 10
d377 2
a378 1
require "../main/preferences";
a382 4
require "tooldata";
require "motif_utils";
require "menus";
require "debugger_window";
d385 1
a385 1
require "entry";
a390 1
  structure Capi: CAPI
d393 2
d397 1
d400 1
a400 1
  structure TTYListener: TTY_LISTENER
d410 3
a412 1
    	  ToolData.ShellTypes.Options = Entry.Options
d414 1
a414 2
  sharing type ToolData.ShellTypes.user_options =
	       UserOptions.user_tool_options =
d418 1
a418 2
	       ToolData.UserContext.user_context_options =
	       UserOptions.user_context_options
d422 2
a423 3
  sharing type Shell.Context = ShellUtils.Context = 
               ToolData.ShellTypes.Context =
	       Ml_Debugger.Incremental.Context
a435 1
  sharing type Entry.Basis.BasisTypes.Basis = Ml_Debugger.ValuePrinter.TypeBasis
d443 1
a443 2
  structure Incremental = Ml_Debugger.Incremental
  structure Info = Incremental.InterMake.Compiler.Info
a458 2
  val sep_size = 10

d484 66
d588 1
d590 1
a590 2
      fun message_fun s =
        Capi.send_message (shell,s)
a591 12
      (* this should just look for a "prompt character" eg. a ">". *)
      fun strip_prompt(string) =
        let val chars = explode string
          fun strip [] = chars
            | strip (">"::(l as ">" :: _)) = strip l
            | strip (">":: " " :: l) = l
            | strip (">":: l) = l
            | strip (_::l) = strip l
        in
          implode (strip chars)
        end

d598 1
a598 1
	 (size (getString text)). *)
d603 220
a822 4
      fun insert_text str =
	(Capi.Text.insert (text, !write_pos, str);
         write_pos := size str + !write_pos;
         Capi.Text.set_insertion_position (text, !write_pos))
d824 2
a825 1
      val outstream = MotifUtils.make_outstream insert_text
a837 2
      fun get_user_options () = user_options

d841 3
a859 30
      fun set_state1 (motif_context) =
	case contextLabel of
          MLWorks.Option.SOME w =>
            (local_context := motif_context;
             Capi.set_label_string (w,"Context: " ^ MotifUtils.get_context_name motif_context))
	|  MLWorks.Option.NONE => ()
              
      val _ = set_state1 motif_context

      val (handler', do_prompt) = Shell.shell (shell_data,location_title)

      exception NoLocation
      fun get_location line =
        let
          val sz = size line
          fun aux index =
            if index < sz
              then
                if String.ordof(line,index) = ord ":"
                  then index+1
                else
                  aux (index+1)
            else
              raise NoLocation
          (* skip up to second ":" *)
          val result = String.substring(line,0,(aux (aux 0))-1)
        in
          result
        end
      
d866 2
a867 2
          val pos = Capi.Text.get_insertion_position text
          val line = Capi.Text.get_line (text, pos)
d878 2
a879 1
           
d881 1
a881 2
      val exitter_ref = ref Option.NONE

d888 1
a888 8
          val subline =
            let
              val (line,ix) = Capi.Text.get_line_and_index (text,start_pos)
              val line2 = strip_prompt line
              val ix2 = ix - (size line - size line2)
            in
              if ix2 > 0 then String.substring (line2,0,ix2) else ""
            end
d907 1
a907 2
            (Capi.Text.insert (text, start_pos,String.substring (a, size sofar, size a - size sofar));
             Capi.Text.set_insertion_position (text, start_pos + size a - size sofar))
d917 2
a918 1
                    exitter_ref := Option.SOME (popup_completion (l,insert_fun, fn x => x))
a923 69
      val (input_flag,input_string) = (ref false,ref "")

      fun input_fun () =
        (input_flag := true;
         Capi.event_loop (input_flag);
         !input_string)

      local 
        val inbuff as (posref,strref) = (ref 0,ref "")
            
        fun refill_buff () =
          let val new_string = input_fun ()
          in
            posref := 0;
            strref := new_string
          end

	val eof_flag = ref false
      in
        fun get_input n =
          let
            val string = !strref
            val pointer = !posref
            val len = size string
          in
            if !eof_flag then
              ""
            else if pointer + n > len then
              (refill_buff ();
               String.substring (string,pointer,len-pointer) ^
               get_input (n - len + pointer))
                 else
                   let val result = String.substring (string,pointer,n)
                   in
                     posref := (!posref + n);
                     result
                   end
          end

        fun clear_input () =
	  (debug "Clearing input";
           posref := 0;
	   strref := "";
	   eof_flag := false)
	  
        fun do_lookahead () =
          (if !eof_flag then
             ""
          else if !posref >= size (!strref) then
             (refill_buff ();
              do_lookahead ())
               else 
                 String.substring (!strref, !posref, 1))
	       
	fun close_in () = eof_flag := true
	  
	fun closed_in () = !eof_flag
	  
	fun clear_eof () = eof_flag := false
      end;
	  
      val instream = 
        IO.instream {input = get_input,
                             lookahead = do_lookahead,
                             end_of_stream = fn () => do_lookahead () = "",
                             clear_eof = clear_eof,
                             close_in = close_in,
			     closed_in = closed_in}

d935 2
d952 2
a953 5
      fun force_prompt () =
        (handler "\n";
         output(outstream,
		"\n" ^
		do_prompt(MotifUtils.get_context_name (!local_context)));
d957 15
a971 1
      fun set_state c = (set_state1 c; force_prompt ())
d987 15
a1001 3
      (* The history is a list of topdecs, combined with an index number.
	 The index is used to set the current_index ref when a topdec is
	 selected from the menu. *)
a1006 35
      fun whitespacep x =
        case x of
          " " => true
        | "\n" => true
        | "\t" => true
        | "\012" => true
        | "\013" => true
        | _ => false
          
      fun trivial s = 
        let
          fun trivial' (~1, _) = true
            | trivial' (n, s) =
              if whitespacep (String.substring (s, n, 1))
                then trivial' (n-1, s)
              else false
        in
          trivial' (size s - 1, s)
        end

      fun strip_whitespace s =
        let
          fun strip [] = []
            | strip (l as (a::b)) =
              if whitespacep a then strip b else l
        in
          implode (rev (strip (rev (strip (explode s))))) (* Yuk Yuk *)
        end

      fun strip_trivia [] = []
        | strip_trivia (l as (a::b)) =
          if trivial a then strip_trivia b else l

      val current_topdec = ref [];

a1015 9
      fun add_line line =
        let val topdec =
          case !current_topdec of
            [] => if trivial line then [] else [line]
          | lines => line :: lines
        in
          current_topdec := topdec
        end

a1040 13
      fun replace_current_topdec line =
	let 
          val length = Capi.Text.get_last_position text
	in 
	  (* Capi.Text.replace doesn't always work properly for X.
           But setting the whole string causes ridiculous amounts of flicker. *)
          Capi.Text.replace (text,!prompt_pos,length,line);
	  Capi.Text.set_insertion_position (text, !prompt_pos + size line)
	end

      fun delete_current_line () =
        replace_current_topdec ""

d1045 1
a1045 1
	  replace_current_topdec line
d1047 1
a1047 3
	handle
	  Lists.Nth =>
	    history_index := !history_index - 1;
d1057 1
a1057 1
	  replace_current_topdec line
d1060 3
d1064 1
a1064 4
        (output (outstream,
		 do_prompt(MotifUtils.get_context_name (!local_context)));
         IO.flush_out outstream;
	 prompt_pos := !write_pos;
a1068 56
      fun yank_current_line () =
	let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
        in
          if pos < !prompt_pos then
            let val line = strip_prompt (Capi.Text.get_line (text,pos))
            in
              Capi.Text.insert(text, last_pos, line);
              Capi.Text.set_insertion_position (text, last_pos+size line)
            end
          else
            ()
        end

      fun start_of_line () =
        let
          val ppos = !prompt_pos
          val pos = Capi.Text.get_insertion_position text
          val new_pos =
            if pos < ppos
              then Capi.Text.current_line (text,pos)
            else ppos
        in
          Capi.Text.set_insertion_position (text,new_pos)
        end
          
      fun end_of_line () =
        let
          val ppos = !prompt_pos
          val pos = Capi.Text.get_insertion_position text
          val new_pos =
            if pos < ppos
              then Capi.Text.end_line (text,pos)
            else Capi.Text.get_last_position text
        in
          Capi.Text.set_insertion_position (text,new_pos)
        end
          
      fun eof_or_delete () =
        let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
        in
          if pos = last_pos andalso pos = !write_pos then
            (debug "eof";
             if !input_flag then
               (close_in ();
                input_flag := false)
             else
               beep ())
          else
            (debug "delete";
             Capi.Text.replace (text, pos, pos + 1, ""))
        end

d1071 1
a1071 34
          val pos = Capi.Text.get_insertion_position text
          val lines =
            if pos < !prompt_pos then
              let
                val line = strip_prompt (Capi.Text.get_line (text, pos)) ^ "\n"
                val last_pos = Capi.Text.get_last_position text
              in
                Capi.Text.insert(text, last_pos, line);
                write_pos := last_pos + size line;
                Capi.Text.set_insertion_position (text, last_pos + size line);
                [line]
              end
            else
              let
                val length = Capi.Text.get_last_position text

                fun get_lines ([], current, acc, _) =
		  map (implode o rev) (current :: acc)
                |   get_lines ("\n"::rest, current, acc, column) =
		  get_lines (rest, [], ("\n"::current)::acc, 1)
                |   get_lines (c::rest, current, acc, column) =
		  get_lines (rest, c::current, acc, column+1)

                val line = Capi.Text.substring (text, !write_pos,length - !write_pos)
                val lines = get_lines (explode line,[],[],0)
              in
                case lines of
                  last :: rest =>
                    (Capi.Text.insert (text, length, "\n");
                     write_pos := length + 1;
                     Capi.Text.set_insertion_position (text, length+1);
                     last ^ "\n" :: rest)
                | _ => lines
              end
a1120 14
      fun activate callback_data =
	let 
          val event = Capi.Callback.get_event callback_data
        in
          case Capi.Event.get_key_data event of
            MLWorks.Option.SOME (key,modifiers) =>
              if Lists.member (Capi.Event.meta_modifier, modifiers)
                then despatch_meta key
              else despatch_normal key
          | _ => (debug("activate: non-key event");
                  beep ())
        end
      handle Shell.Exit _ => Capi.destroy shell

d1124 2
a1125 4
            case !exitter_ref of
              Option.NONE => ()
            | Option.SOME f => (f (); exitter_ref := Option.NONE)

d1139 1
a1139 16
            (fdebug (fn _ =>
                     "Verify: start_pos is " ^ Integer.makestring start_pos ^
                     ", end_pos is " ^ Integer.makestring end_pos ^
                     ", write_pos is " ^ Integer.makestring (!write_pos) ^
                     ", prompt_pos is " ^ Integer.makestring (!prompt_pos) ^
                     ", string is '" ^ str ^ "'");
             if end_pos < !write_pos then
	       write_pos := (!write_pos) - end_pos + start_pos + size str
             else if start_pos < !write_pos then
	       write_pos := start_pos + size str
	     else ();
             if end_pos < !prompt_pos then
	       prompt_pos := (!prompt_pos) - end_pos + start_pos + size str
             else if start_pos < !prompt_pos then
	       prompt_pos := start_pos + size str
             else ();
d1144 13
a1156 2
      fun warp_history string =
        ShellUtils.trim_history_string (string, user_preferences)
a1164 2
      fun get_user_options () = user_options

d1215 1
a1215 1
	  Entry.basis2entry (Incremental.type_basis context)
d1277 8
a1284 8
			     Menus.PUSH (warp_history s,
					 fn _ => (replace_current_topdec s;
						  history_index :=
						  !history_size - i),
					 fn _ => true))
			(!history),
			fn _ => !history <> [])]
	
d1329 1
a1329 4
      output
      (outstream, do_prompt(MotifUtils.get_context_name (!local_context)));
      IO.flush_out outstream;
      prompt_pos := !write_pos
@


1.100
log
@Minor changes to layout.
@
text
@d5 3
d375 1
d394 3
a396 2

  sharing Ml_Debugger.ValuePrinter.Options =
d398 1
a398 1
    	  ToolData.ShellTypes.Options
d425 1
a547 1

d1149 2
d1152 88
d1242 5
a1246 1
         Menus.DYNAMIC ("history",
d1249 8
a1256 8
                             Menus.PUSH (warp_history s,
                                         fn _ => (replace_current_topdec s;
                                                  history_index :=
                                                  !history_size - i),
                                         fn _ => true))
                        (!history),
                        fn _ => !history <> [])]

d1259 6
a1264 6
	  {parent = shell, title = title, user_options = user_options,
	   user_preferences = user_preferences,
	   caller_update_fn = fn _ => (),
	   sensitivity = MotifUtils.NO_SENSE_SELECTION,
	   view_type = MotifUtils.VIEW_ALL}

d1266 4
a1269 4
        ToolData.works_menu
	  (mk_tooldata, close_window,
	   fn _ => not (!input_flag),
	   fn () => MotifUtils.get_user_context (!local_context))
d1273 5
a1277 5
	     {set_state = select_context,
	      get_context = fn _ => !local_context,
	      writable = MotifUtils.WRITABLE,
	      applicationShell = applicationShell,
	      user_preferences = user_preferences}
d1280 2
a1281 2
		("error", [Menus.PUSH ("edit", edit_error, fn _ => true)],
                 fn _ => true)
d1302 1
a1302 1
	(outstream, do_prompt(MotifUtils.get_context_name (!local_context)));
@


1.99
log
@Replaced ad-hoc handling of CTRL-D (which has stopped working)
with an explicit function.
@
text
@d5 4
d1191 2
a1192 2
          MLWorks.Option.SOME w => [Capi.Layout.OTHER w,Capi.Layout.SPACE]
        | _ => []) @@
@


1.98
log
@Stuff
@
text
@d5 3
d960 17
d1040 1
a1105 13
             else if str = "" andalso start_pos = end_pos andalso
		     start_pos = !write_pos then
	       (* str = "" => deletion,
	          start_pos = end_pos => at end or beginning of text
		  start_pos = !write_pos => at beginning of input line *)
	       case Capi.Event.get_key_data event of
	         MLWorks.Option.SOME ("\^D",_) =>
	           if !input_flag then
	             (close_in ();
		      input_flag := false)
	           else
		     beep ()
	       | _ => ()
@


1.97
log
@Hid details of WINDOWING type in ml_debugger.
@
text
@d5 3
d350 1
a350 1
require "../library/xm";
d370 1
a370 1
  structure Xm: XM
d404 2
a405 3
  sharing type Menus.Widget = Xm.Widget =
    	       DebuggerWindow.Widget = ToolData.Widget =
    	       MotifUtils.Widget
a429 4
  type Widget = Xm.Widget
  type Context = Incremental.Context
  type UserOptions = MotifUtils.user_tool_options

d439 25
d466 1
d468 1
a468 1
		{args,appdata,current_context,motif_context,tools}) =
d494 4
a497 54
      val shell =
        Xm.Widget.create (Xm.Widget.NAME "shell",
                                 Xm.Widget.Class.TopLevelShell,
                                 applicationShell,
                                 [(Xm.Title, Xm.STRING title),
                                  (Xm.IconName, Xm.STRING title)])

      val mainWindow =
        Xm.Widget.createManaged (Xm.Widget.NAME "main",
				 Xm.Widget.Class.Form,
				 shell, [])

      val menuBar =
        Xm.Widget.createMenuBar
	  (mainWindow,Xm.Widget.NAME "menuBar",
	   [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)
	   ])

      val contextLabel =
	if full_menus then
	  MLWorks.Option.SOME
	    (Xm.Widget.createManaged
               (Xm.Widget.NAME "contextLabel", Xm.Widget.Class.Label,mainWindow,
	        [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                 (Xm.TopWidget, Xm.WIDGET menuBar),
	         (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	         (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                 (Xm.LeftOffset, Xm.INT sep_size),
                 (Xm.RightOffset, Xm.INT sep_size),
	         (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]))
	else
	  MLWorks.Option.NONE


      (* This layout stuff should be done by a general-purpose function *)
      val text =
        Xm.Widget.createScrolledText (
	  mainWindow, Xm.Widget.NAME "textIO",
	  [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
	   (Xm.TopWidget,
	    case contextLabel
	    of MLWorks.Option.SOME w => Xm.WIDGET w
	    |  MLWorks.Option.NONE => Xm.WIDGET menuBar),
           (Xm.TopOffset, Xm.INT sep_size),
	   (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	   (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
           (Xm.LeftOffset, Xm.INT sep_size),
           (Xm.RightOffset, Xm.INT sep_size),
	   (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
           (Xm.BottomOffset, Xm.INT sep_size)
	  ])
d501 1
a501 1
      fun beep _ = MotifUtils.beep shell
d504 1
a504 1
        MotifUtils.send_message (shell,s)
d524 2
a525 1
	 (size (Xm.Text.getString text)). *)
d530 3
a532 4
	( Xm.Text.insert(text, !write_pos, str);
          write_pos := size str + !write_pos;
	  Xm.Text.setInsertionPosition (text, !write_pos)
	)
d540 1
a540 1
      (* This creates the debugger window when the inspector is being created *)
d550 3
a552 25
      fun debugger_function f x =
        Ml_Debugger.with_start_frame
          (fn base_frame =>
             (f x)
             handle
	        exn as ShellTypes.DebuggerTrapped => raise exn
             |  exn as Shell.Exit _ => raise exn
             |  exn as Interrupt => raise exn
             |  exn as Info.Stop _ => raise exn
             |  exn as Xm.SubLoopTerminated => raise exn
             |  exn =>
               (Ml_Debugger.ml_debugger
                  (debugger_type,
                   ShellTypes.new_options
		     (user_options,
		      MotifUtils.get_user_context (!local_context)),
                   Preferences.new_preferences user_preferences)
                  (base_frame,
                   Ml_Debugger.EXCEPTION exn,
                   Ml_Debugger.POSSIBLE
                     ("quit (return to listener)",
                      Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
                   Ml_Debugger.NOT_POSSIBLE);
                raise ShellTypes.DebuggerTrapped))
   
d570 4
a573 11
	case contextLabel
	of MLWorks.Option.SOME w =>
          (local_context := motif_context;
           let
             val cstring =
	       Xm.CompoundString.createSimple
	         ("Context: " ^ MotifUtils.get_context_name motif_context)
           in
             Xm.Widget.valuesSet
	       (w, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
            end)
a579 46
      (* some command functions *)

      fun lastline str ~1 = 0
        | lastline str n =
          if String.ordof (str, n) = ord "\n"
            then n+1
          else lastline str (n-1)

      fun get_line_and_index (text,pos) =
	let
          val str = Xm.Text.getString text
          val length = size str

          fun nextline n =
            if n = length orelse String.ordof (str, n) = ord "\n" then
              n
            else
              nextline (n+1)
          val start = lastline str (pos-1)
          val finish = nextline pos
          val result = String.substring (str, start, finish - start)
	in
          fdebug (fn _ => "Getline returns:" ^ result ^ ":");
          (result,pos - start)
	end

      fun current_line (text,pos) =
        lastline (Xm.Text.getString text) (pos-1)

      fun end_line (text,pos) =
        let
          val str = Xm.Text.getString text
          val length = size str
          fun aux n = 
            if n = length orelse String.ordof (str, n) = ord "\n" then
              n
            else
              aux (n+1)
        in
          if pos = length 
            then pos 
          else aux (pos + 1)
        end

      val getline = #1 o get_line_and_index

d605 2
a606 2
          val pos = Xm.Text.getInsertionPosition text
          val line = getline (text, pos)
d626 13
a638 6
          val (line,ix) = get_line_and_index (text,start_pos)
          val line2 = strip_prompt line
          val ix2 = ix - (size line - size line2)
          val subline = if ix2 > 0 then String.substring (strip_prompt line,0,ix2) else ""
          val preferences = ShellTypes.get_current_preferences shell_data
          val Preferences.PREFERENCES
d640 1
a640 1
		   Preferences.ENVIRONMENT_OPTIONS {completion_menu,...},
d642 4
a645 1
            preferences
d653 2
a654 5
            ( Xm.Text.insert
             (text, start_pos,
              String.substring (a, size sofar, size a - size sofar));
             Xm.Text.setInsertionPosition
             (text, start_pos + size a - size sofar))
d663 1
a663 1
                  if (!completion_menu) then
d674 1
a674 2
         while (!input_flag) do Xm.doInput ();
         fdebug(fn _ => "Input line is:" ^ (!input_string)^":");
d876 2
a877 3
	let val str = Xm.Text.getString text
	    val length = size str
	    val const_str = String.substring (str, 0, !prompt_pos);
d879 4
a882 4
	  (* Xm.Text.replace doesn't always work properly.  But setting the
	     whole string causes ridiculous amounts of flicker. *)
          Xm.Text.replace (text,!prompt_pos,length,line);
	  Xm.Text.setInsertionPosition (text, !prompt_pos + size line)
a883 1
	  
d920 2
a921 2
          val pos = Xm.Text.getInsertionPosition text
          val last_pos = Xm.Text.getLastPosition text
d924 1
a924 1
            let val line = strip_prompt (getline (text,pos))
d926 2
a927 2
              Xm.Text.insert(text, last_pos, line);
              Xm.Text.setInsertionPosition (text, last_pos+size line)
d936 1
a936 1
          val pos = Xm.Text.getInsertionPosition text
d939 1
a939 1
              then current_line (text,pos)
d942 1
a942 1
          Xm.Text.setInsertionPosition (text,new_pos)
d948 1
a948 1
          val pos = Xm.Text.getInsertionPosition text
d951 2
a952 2
              then end_line (text,pos)
            else Xm.Text.getLastPosition text
d954 1
a954 1
          Xm.Text.setInsertionPosition (text,new_pos)
d959 1
a959 1
          val pos = Xm.Text.getInsertionPosition text
d963 2
a964 2
                val line = strip_prompt (getline (text, pos)) ^ "\n"
                val last_pos = Xm.Text.getLastPosition text
d966 1
a966 1
                Xm.Text.insert(text, last_pos, line);
d968 1
a968 1
                Xm.Text.setInsertionPosition (text, last_pos + size line);
d973 1
a973 2
                val str = Xm.Text.getString text
                val length = size str
d982 1
a982 2
                val line = String.substring (str, !write_pos,
                                             length - !write_pos)
d987 1
a987 1
                    (Xm.Text.insert(text, length, "\n");
d989 1
a989 1
                     Xm.Text.setInsertionPosition (text, length+1);
d1043 1
a1043 1
          val (_, event) = Xm.Callback.convertAny callback_data
d1045 5
a1049 9
          case event of
            Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key,state,...}) =>
              let
                val modifiers = Xm.Event.convertState state
              in
                case modifiers of
                  [Xm.Event.MOD1] => despatch_meta key
                | _ => despatch_normal key
              end
d1053 1
a1053 1
      handle Shell.Exit _ => Xm.Widget.destroy shell
d1062 2
a1063 2
          val (_,event,doit,_,_,start_pos,end_pos,str) =
            Xm.Callback.convertTextVerify callback_data
d1068 1
a1068 1
               Xm.Boolean.set (doit,false);
d1073 1
a1073 1
               Xm.Boolean.set (doit,false))
d1090 2
a1091 2
	       case event of
	         Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^D", ...}) =>
d1104 1
a1104 1
             Xm.Boolean.set (doit, true))
d1106 1
a1106 1
	handle Shell.Exit _ => Xm.Widget.destroy shell
d1122 1
a1122 1
         Xm.Widget.destroy shell)
d1176 14
a1189 7
      Xm.Widget.callbackAdd (text, Xm.Callback.Activate, activate);
      Xm.Widget.callbackAdd (text, Xm.Callback.ModifyVerify, modifyVerify);
      Xm.Widget.callbackAdd (shell, Xm.Callback.Destroy,do_quit_funs);
      Xm.Widget.manage menuBar;
      Xm.Widget.manage text;
      Xm.Widget.manage shell;
      Xm.Widget.realize shell;
@


1.96
log
@Type of Ml_Debugger.ml_debugger has changed.
@
text
@d5 3
a408 1
  sharing type Ml_Debugger.ValuePrinter.Type = DebuggerWindow.Type
d415 1
d570 3
a572 1
	  (DebuggerWindow.make_debugger_window (shell,"debugger",tooldata),true)
d592 1
a592 2
                   Preferences.new_preferences user_preferences,
		   fn s => output (std_out, s))
@


1.95
log
@Removed expansion of tabs.
@
text
@d5 3
d573 23
a595 25
        (fn base_frame =>
         (f x)
         handle exn as ShellTypes.DebuggerTrapped => raise exn
              | exn as Shell.Exit _ => raise exn
              | exn as Interrupt => raise exn
              | exn as Info.Stop _ => raise exn
              | exn as Xm.SubLoopTerminated => raise exn
              | exn =>
                  (Ml_Debugger.ml_debugger
                   debugger_type
                   (ShellTypes.new_options
		      (user_options,
		       MotifUtils.get_user_context (!local_context)),
                    Preferences.new_preferences user_preferences,
                    UserContext.get_context
		      (MotifUtils.get_user_context (!local_context)))
                   (fn _ => output(std_out,
                                   "Debugger shell not defined yet\n"))
                   base_frame
                   (Ml_Debugger.EXCEPTION exn,
                    Ml_Debugger.POSSIBLE
                    ("quit (return to listener)",
                     Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
                    Ml_Debugger.NOT_POSSIBLE);
                   raise ShellTypes.DebuggerTrapped))
d707 1
a707 4
	      (locstring,
               UserContext.get_context
		 (MotifUtils.get_user_context (!local_context)),
               ShellTypes.get_current_preferences shell_data)
@


1.94
log
@Changed sensitivity argument of view_options to NO_SENSE_SELECTION,
because the shell functions now set the current selection.
@
text
@d5 4
a1070 12
		fun spaces column =
		  case column mod 8 
		  of 1 => "        "
		  |  2 => "       "
		  |  3 => "      "
		  |  4 => "     "
		  |  5 => "    "
		  |  6 => "   "
		  |  7 => "  "
		  |  0 => " "
		  |  _ => Crash.impossible "n mod 8 failed!"

a1072 2
                |   get_lines ("\t"::rest, current, acc, column) =
		  get_lines (rest, (spaces column :: current), acc, column)
@


1.93
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d5 3
d1262 1
a1262 1
	   sensitivity = MotifUtils.CONTEXT_ONLY,
@


1.92
log
@Changing interface to list_select.
@
text
@d5 3
d357 1
a358 1
  structure Preferences : PREFERENCES
d368 1
a368 2
  sharing UserOptions.Options =
	  Ml_Debugger.ValuePrinter.Options =
d372 7
a378 2
  sharing type UserOptions.user_options = ToolData.ShellTypes.user_options =
	       MotifUtils.UserOptions = ShellUtils.UserOptions
d398 5
a402 2
	       Ml_Debugger.preferences = ShellUtils.preferences =
	       UserOptions.preferences
d408 1
a408 1
  structure Options = UserOptions.Options
d417 1
a417 1
  type UserOptions = UserOptions.user_options
d431 1
a431 1
		{args,appdata,current_context,tools}) =
d433 2
a434 2
      val ShellTypes.LISTENER_ARGS {user_context,
                                    user_options,
d441 4
a444 4
      val (full_menus, update_fns) =
	case user_options
	of UserOptions.USER_OPTIONS ({full_menus, ...}, update_fns) =>
	  (!full_menus, update_fns)
d549 1
a549 1
      (*** Context stack ***)
a550 2
      val local_context = ref user_context

d556 2
a557 1
        Ml_Debugger.WINDOWING (DebuggerWindow.make_debugger_window(shell,"debugger",tooldata),true)
d573 6
a578 3
                   (UserOptions.new_options user_options,
                    UserOptions.new_preferences user_options,
                    UserContext.get_context (!local_context))
d591 2
a592 1
        {user_context = local_context,
d594 1
d605 1
a605 1
      fun set_state1 (user_context) =
d608 1
a608 1
          (local_context := user_context;
d612 1
a612 1
	         ("Context: " ^ UserContext.get_context_name user_context)
d619 1
a619 1
      val _ = set_state1 user_context
d700 2
a701 1
               UserContext.get_context (!local_context),
d731 3
a733 1
	      (subline, options, UserContext.get_context (!local_context))
d855 1
a855 1
		do_prompt(UserContext.get_context_name (!local_context)));
d870 2
a871 2
      fun select_context user_context =
        (set_state user_context;
d873 1
a873 1
           (current_context, context_key, user_options, user_context))
d919 6
a924 7
        if size new_entry > 4 
          then
            (history_size := !history_size + 1;
             ShellUtils.add_history_item ((new_entry, !history_size),
                                          history,
                                          (fn ((s,_),(s',_))=>s=s'),
                                          get_user_options()))
d999 1
a999 1
		 do_prompt(UserContext.get_context_name (!local_context)));
d1217 1
a1217 1
        ShellUtils.trim_history_string (string,get_user_options())
d1223 1
a1226 4
        
      val (options_menu,update) =
	MotifUtils.options_menu (shell, title, get_user_options, fn _ => ())
      val _ = update_fns := update :: (!update_fns)
d1235 1
a1235 1
	       !local_context,
d1237 1
a1242 1
         options_menu,
d1254 8
d1265 3
a1267 1
	   fn _ => not (!input_flag), fn () => !local_context)
d1269 6
a1278 2
	      :: MotifUtils.context_menu
	           (select_context, fn _ => !local_context, MotifUtils.WRITABLE)
d1292 1
a1292 1
	(outstream, do_prompt(UserContext.get_context_name (!local_context)));
@


1.91
log
@Made contexts only visible if full_menus set.
@
text
@d5 3
d402 2
d412 3
a414 3
  fun debug s = if do_debug then output(MLWorks.IO.terminal_out,s ^ "\n") else ()
  fun fdebug f = if do_debug then output(MLWorks.IO.terminal_out,f() ^ "\n") else ()
  fun ddebug s = output(MLWorks.IO.terminal_out,s ^ "\n")
d695 2
a696 1
      datatype Exitter = NONE | SOME of (unit -> unit)
d698 1
a698 1
      val exitter_ref = ref NONE
a716 1

d718 5
a722 5
	    ( Xm.Text.insert
		(text, start_pos,
		 String.substring (a, size sofar, size a - size sofar));
	      Xm.Text.setInsertionPosition
		(text, start_pos + size a - size sofar))
d732 1
a732 3
                    exitter_ref :=
		      SOME (MotifUtils.list_select
			      (shell,"completions",l,insert_fun, fn x => x))
d801 1
a801 1
        MLWorks.IO.instream {input = get_input,
d822 1
a822 1
         MLWorks.IO.with_standard_output
d825 1
a825 1
          MLWorks.IO.with_standard_input
d839 1
a839 1
         MLWorks.IO.flush_out outstream;
d984 1
a984 1
         MLWorks.IO.flush_out outstream;
d1151 2
a1152 2
              NONE => ()
            | SOME f => (f();exitter_ref := NONE)
d1168 4
a1171 4
                     "Verify: start_pos is " ^ MLWorks.Integer.makestring start_pos ^
                     ", end_pos is " ^ MLWorks.Integer.makestring end_pos ^
                     ", write_pos is " ^ MLWorks.Integer.makestring (!write_pos) ^
                     ", prompt_pos is " ^ MLWorks.Integer.makestring (!prompt_pos) ^
d1266 1
a1266 1
      MLWorks.IO.flush_out outstream;
@


1.90
log
@Adding escape key functionality
@
text
@d5 3
d426 5
d464 14
a477 10
        Xm.Widget.createManaged
        (Xm.Widget.NAME "contextLabel", Xm.Widget.Class.Label,mainWindow,
	   [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
	    (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
	    (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)
	   ])
d484 5
a488 1
	   (Xm.TopWidget, Xm.WIDGET contextLabel),
d587 12
a598 9
        (local_context := user_context;
         let
           val cstring =
	     Xm.CompoundString.createSimple
	       ("Context: " ^ UserContext.get_context_name user_context)
         in
           Xm.Widget.valuesSet
	     (contextLabel, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
          end)
a1209 1
      val UserOptions.USER_OPTIONS({full_menus,...},update_fns) = user_options
d1225 2
a1226 1
        [options_menu,
d1243 1
a1243 3
	:: MotifUtils.context_menu
	     (select_context, fn _ => !local_context, MotifUtils.WRITABLE)
	:: (if !full_menus then
d1247 2
a1248 1
	      :: MotifUtils.breakpoints_menu shell
@


1.89
log
@Removed script from ml_debugger
@
text
@d5 3
d331 1
a332 1
require "../interpreter/shell_utils";
d335 2
d338 1
a338 2
require "menus";
require "motif_utils";
d355 1
a356 1
  structure MotifUtils : MOTIF_UTILS
d395 1
a402 2
  val listener_number = ref 1

d405 4
d410 2
d420 1
a425 2
          fun p (s, 0) = s
            | p (s, n) = p (chr (48+(n mod 10)) ^ s, n div 10)
d428 1
a428 1
          "Listener #" ^ p ("", n)
d462 2
d466 2
d475 4
a478 1
	   (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)
d483 5
d607 1
a607 1
          debug("Getline returns:" ^ result ^ ":");
a630 3
      fun message_fun s =
        MotifUtils.send_message (shell,s)

d701 1
a701 1
            [] => MotifUtils.beep shell
d711 1
a711 1
                  else MotifUtils.beep shell
d721 1
a721 1
         debug("Input line is:" ^ (!input_string)^":");
d856 5
a860 5
            |   trivial' (n, s) =
                if whitespacep (String.substring (s, n, 1))
                  then trivial' (n-1, s)
                else false
        in 
d873 4
a897 4
      fun strip_trivia [] = []
        | strip_trivia (l as (a::b)) =
          if trivial a then strip_trivia b else l

a910 1

d912 10
a921 10
      |   update_history ((h::t, still_valid), line) =
	    let 
              val newbit = String.substring (line, 0, h)
              val rest_of_line =
                String.substring (line, h, size line - h)
            in
              (add_line newbit;
               do_history_entry ();
               update_history ((map (fn x => x-h) t, still_valid), rest_of_line))
	    end
a958 47
      fun modifyVerify callback_data =
        let
          val _ =
            case !exitter_ref of
              NONE => ()
            | SOME f => (f();exitter_ref := NONE)

          val (_,event,doit,_,_,start_pos,end_pos,str) =
            Xm.Callback.convertTextVerify callback_data
        in
          if str = "\t"
            then
              (do_completion start_pos;
               Xm.Boolean.set (doit,false))
          else
            (debug ("Verify: start_pos is " ^ MLWorks.Integer.makestring start_pos ^
		    ", end_pos is " ^ MLWorks.Integer.makestring end_pos ^
		    ", write_pos is " ^ MLWorks.Integer.makestring (!write_pos) ^
		    ", prompt_pos is " ^ MLWorks.Integer.makestring (!prompt_pos) ^
		    ", string is '" ^ str ^ "'");
             if end_pos < !write_pos then
	       write_pos := (!write_pos) - end_pos + start_pos + size str
             else if start_pos < !write_pos then
	       write_pos := start_pos + size str
             else if str = "" andalso start_pos = end_pos andalso
		     start_pos = !write_pos then
	       (* str = "" => deletion,
	          start_pos = end_pos => at end or beginning of text
		  start_pos = !write_pos => at beginning of input line *)
	       case event of
	         Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^D", ...}) =>
	           if !input_flag then
	             (close_in ();
		      input_flag := false)
	           else
		     (MotifUtils.beep shell; ())
	       | _ => ()
	     else ();
             if end_pos < !prompt_pos then
	       prompt_pos := (!prompt_pos) - end_pos + start_pos + size str
             else if start_pos < !prompt_pos then
	       prompt_pos := start_pos + size str
             else ();
             Xm.Boolean.set (doit, true))
        end
	handle Shell.Exit _ => Xm.Widget.destroy shell

d1066 1
a1066 1
              then MotifUtils.beep shell
d1074 33
d1108 68
a1175 46
	let val (_, event) =
	      Xm.Callback.convertAny callback_data
	in
	  case event of
	    Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "p", state, ...}) =>
	      if Xm.Event.convertState state = [Xm.Event.MOD1] then
		(* meta-p *)
	        pop_history ()
	      else
		()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "n", state, ...}) =>
	      if Xm.Event.convertState state = [Xm.Event.MOD1] then
		(* meta-n *)
	        push_history ()
	      else
		()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "w", state, ...}) =>
	      if Xm.Event.convertState state = [Xm.Event.MOD1] then
		(* meta-n *)
                MotifUtils.copySelection text
	      else
		()
(*
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^D", ...}) =>
	      eof ()			(* EOF - possibly ends topdec *)
*)
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^A", ...}) =>
              start_of_line ()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^E", ...}) =>
              end_of_line ()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^W", ...}) =>
              MotifUtils.cutSelection text
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^Y", ...}) =>
              MotifUtils.pasteSelection text
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^U", ...}) =>
              delete_current_line ()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^J", ...}) =>
              yank_current_line ()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\013", ...}) =>
	      do_return()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key, ...}) =>
	      debug ("key press: key = " ^ MLWorks.Integer.makestring (ord key))
	  | Xm.Event.KeyRelease (Xm.Event.KEY_EVENT {key, ...}) =>
	      debug ("key release: key = " ^ MLWorks.Integer.makestring (ord key))
	  | _ => debug("activate: non-key event")
	end
@


1.88
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d5 3
d427 5
a431 5
        Xm.Widget.createPopupShell (Xm.Widget.NAME "shell",
				    Xm.Widget.Class.TopLevelShell,
                                    applicationShell,
                                    [(Xm.Title, Xm.STRING title),
                                     (Xm.IconName, Xm.STRING title)])
d439 2
a440 2
        Xm.Widget.createManaged
	  (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, mainWindow,
d533 1
a533 2
                    Ml_Debugger.NOT_POSSIBLE)
                   [];
d1215 1
@


1.87
log
@Changes to context_menu.
@
text
@d5 3
a351 3
  sharing ToolData.ShellTypes.Info =
	  Ml_Debugger.Incremental.InterMake.Compiler.Info

d362 1
a362 2
  sharing type Shell.Context =
               ShellUtils.Context =
d387 2
d522 1
a522 1
                    ShellTypes.get_context (!local_context))
d553 1
a553 1
	       ("Context: " ^ ShellTypes.get_context_name user_context)
d643 1
a643 1
               ShellTypes.get_context (!local_context),
d671 3
a673 3
            ShellUtils.get_completions (subline,
                                        options,
                                        ShellTypes.get_context (!local_context))
d796 2
a797 1
		"\n" ^ do_prompt(ShellTypes.get_context_name (!local_context)));
d990 1
a990 1
		 do_prompt(ShellTypes.get_context_name (!local_context)));
d1216 2
a1217 1
      output(outstream,do_prompt(ShellTypes.get_context_name (!local_context)));
@


1.86
log
@Xm.doInput is back to taking unit.
@
text
@d5 3
d552 1
a552 1
	       ("Context: " ^ ShellTypes.context_name user_context)
d795 1
a795 1
		"\n" ^ do_prompt(ShellTypes.context_name (!local_context)));
a814 11
      fun push_state _ =
        select_context (ShellTypes.copyUserContext (!local_context))

      fun initialContext _ =
        let
          val context = ShellTypes.getNewInitialContext()
        in
          select_context (context)
        end


d988 1
a988 1
		 do_prompt(ShellTypes.context_name (!local_context)));
d1196 8
a1203 19
        :: Menus.CASCADE ("context",
                          [Menus.PUSH ("pushContext",
                                       push_state,
                                       fn _ => true),
                           Menus.PUSH ("initialContext",
                                       initialContext,
                                       fn _ => true),
                           Menus.SEPARATOR,
			   MotifUtils.context_menu
			     (select_context, MotifUtils.WRITABLE)],
                          fn _ => true)
	 :: (if !full_menus then
	       Menus.CASCADE ("error",
                              [Menus.PUSH ("edit",
                                           edit_error,
                                           fn _ => true)],
                              fn _ => true)
	       :: MotifUtils.breakpoints_menu shell
	       :: tailmenuspec
d1214 1
a1214 1
      output(outstream,do_prompt(ShellTypes.context_name (!local_context)));
@


1.85
log
@Type of Xm.doInput has changed.
@
text
@d5 3
d697 1
a697 1
         while (!input_flag) do Xm.doInput applicationShell;
@


1.84
log
@Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
@
text
@d5 3
d694 1
a694 1
         while (!input_flag) do Xm.doInput ();
@


1.83
log
@Removed context_function from register when closing the window.
@
text
@d5 3
a537 4
      fun context_name user_context =
        ShellTypes.string_context_name
	  (ShellTypes.get_context_name user_context)

d543 1
a543 1
	       ("Context: " ^ context_name user_context)
d785 2
a786 1
         output(outstream,"\n" ^ do_prompt(context_name (!local_context)));
d794 1
a794 1
                (current_context, (set_state, get_user_options))
d813 1
a813 1
          set_state (context)
d989 2
a990 1
        (output (outstream, do_prompt(context_name (!local_context)));
d1195 2
a1196 1
	  (mk_tooldata, close_window, fn _ => not (!input_flag))
d1206 2
a1207 1
			   MotifUtils.context_menu select_context],
d1227 1
a1227 1
      output(outstream,do_prompt(context_name (!local_context)));
@


1.82
log
@Changed to share current context with other tools..
@
text
@d5 3
d796 5
d1167 3
d1194 1
a1194 2
	  (mk_tooldata, fn _ => Xm.Widget.destroy shell,
	   fn _ => not (!input_flag))
@


1.81
log
@MotifUtils.options_menu takes an extra argument.
@
text
@d5 3
d384 2
a385 1
  fun create (tooldata as ToolData.TOOLDATA {args,appdata,tools}) =
d481 1
a481 1
      val context_stack = ref []
d506 1
a506 1
                    ShellTypes.get_context user_context)
d520 1
a520 1
        {context_stack = context_stack,
d532 14
a545 14
      fun set_state1 (context_list) =
        (context_stack := context_list;
         case context_list of
           [] => ()
        | (context_ref :: _) =>
            let
              val context_name =
                ShellTypes.string_context_name(ShellTypes.get_context_name context_ref)
              val cstring = Xm.CompoundString.createSimple("Context: " ^ context_name)
            in
              Xm.Widget.valuesSet(contextLabel,
                                  [(Xm.LabelString, 
                                    Xm.COMPOUNDSTRING cstring)])
            end)
d547 1
a547 1
      val _ = set_state1 [user_context]
d631 1
a631 1
               ShellTypes.get_current_context shell_data,
d661 1
a661 1
                                        ShellTypes.get_current_context shell_data)
d783 1
a783 1
         output(outstream,"\n" ^ do_prompt());
d787 1
a787 6
      fun set_state cl = (set_state1 cl; force_prompt ())

      fun can_pop_state _ =
        case !context_stack of
          (_::_::_) => true
        | _ => false
d789 8
a796 4
      fun pop_state _ =
        case !context_stack of
          _::(b as (_::_)) => set_state b
        | _ => ()
d799 1
a799 13
        let
          val statelist = !context_stack
        in
            case statelist of
              (c::_) => set_state((ShellTypes.copyUserContext c) :: statelist)
              | _ => ()
        end

      fun get_current_state () =
        case !context_stack
          of
          (state :: _) => state
        | _ => Crash.impossible "Empty state stack in get_current_state"
d805 1
a805 1
          set_state (context :: !context_stack)
d981 1
a981 1
        (output (outstream, do_prompt());
d1149 1
a1153 17
      fun select_menu () =
	let val context_name =
              ShellTypes.string_context_name o ShellTypes.get_context_name
	in
	    map (fn c =>
		   let val name = context_name c
		   in
                     Menus.PUSH (name,
				 fn _ =>
              			   set_state (c :: !context_stack),
				 fn _ => true)
		   end)
                (Lists.filter_outp
                   ShellTypes.is_const_context
                   (ShellTypes.getCurrentContexts()))
	end

d1163 1
a1163 1
	       user_context,
a1189 3
                           Menus.PUSH ("popContext",
                                       pop_state,
                                       can_pop_state),
d1194 1
a1194 3
                           Menus.DYNAMIC ("selectContext",
                                          select_menu,
                                          fn _ => true)],
d1214 1
a1214 1
      output(outstream,do_prompt());
@


1.80
log
@Removed obsolete sharing constraint.
@
text
@d5 3
d1179 2
a1180 1
      val (options_menu,update) = MotifUtils.options_menu (shell, title,get_user_options)
@


1.79
log
@Adding value menu ...
@
text
@d5 3
a329 3
  sharing ToolData.ShellTypes.Option =
	  Ml_Debugger.Incremental.InterMake.Option =
	  DebuggerWindow.Option
@


1.78
log
@Moved preferences to separate structure.
@
text
@d5 3
d339 2
d1180 9
d1206 1
@


1.77
log
@Cut-down menus for novices.
@
text
@d5 3
d293 1
d312 1
d352 3
d492 2
a493 1
                   (UserOptions.new_options(user_options),
d617 4
a620 3
            ShellUtils.edit_string (locstring,
                                    ShellTypes.get_current_context shell_data,
                                    ShellTypes.get_current_options shell_data)
d639 6
a645 2
          val Options.OPTIONS{environment_options = Options.ENVIRONMENT_OPTIONS {completion_menu,...},...} =
            options
@


1.76
log
@ToolData.works_menu takes different arguments.
@
text
@d5 3
d1158 1
a1158 1
      val UserOptions.USER_OPTIONS(_,update_fns) = user_options
d1160 3
a1162 26
      val menuspec =
        [ToolData.works_menu
	   (mk_tooldata, fn _ => Xm.Widget.destroy shell,
	    fn _ => not (!input_flag)),
         Menus.CASCADE ("context",
                        [Menus.PUSH ("pushContext",
                                     push_state,
                                     fn _ => true),
                         Menus.PUSH ("popContext",
                                     pop_state,
                                     can_pop_state),
                         Menus.PUSH ("initialContext",
                                     initialContext,
                                     fn _ => true),
                         Menus.SEPARATOR,
                         Menus.DYNAMIC ("selectContext",
                                        select_menu,
                                        fn _ => true)],
                        fn _ => true),
         Menus.CASCADE ("error",
                        [Menus.PUSH ("edit",
                                     edit_error,
                                     fn _ => true)],
                        fn _ => true),
	 MotifUtils.breakpoints_menu shell,
         options_menu,
d1173 30
@


1.75
log
@Changed behaviour of Ctrl-E to go to end of input.
@
text
@d5 3
d1159 2
a1160 1
	   (shell, tools, mk_tooldata, fn _ => not (!input_flag)),
@


1.74
log
@Changed context refs to user_contexts.  Filter out constant user_contexts
from the selection menu.
@
text
@d5 4
a450 13
      fun to_top () =
	( write_pos := 0;
	  Xm.Text.setInsertionPosition (text,0)
	)

      fun to_bottom () =
        let
          val pos = Xm.Text.getLastPosition text
        in
          write_pos := pos;
	  Xm.Text.setInsertionPosition (text, pos)
        end

d543 1
a543 1
          val finish = nextline (pos)
d553 15
d993 13
a1005 2
          (write_pos := new_pos;
           Xm.Text.setInsertionPosition (text,new_pos))
d1104 2
@


1.73
log
@Fixed pasting of tabs - used to cause Substring exception in update_history.
Also fixed setting of insertion point after completion.
@
text
@d357 1
a357 1
      val ShellTypes.LISTENER_ARGS {context_ref,
d488 1
a488 1
                    ShellTypes.get_context_ref context_ref)
d529 1
a529 1
      val _ = set_state1 [context_ref]
d766 1
a766 1
              (c::_) => set_state((ShellTypes.copyContextRef c) :: statelist)
d1127 3
a1129 1
        	(ShellTypes.getCurrentContexts())
@


1.72
log
@Added breakpoints menu.
@
text
@d5 3
d625 5
a629 1
            Xm.Text.insert (text,start_pos,String.substring(a,size sofar,size a - size sofar))
a871 21
(*
      fun update_history ((_, true), line) =
        current_topdec := add_line line
        
        | update_history ((_, false), line) =
          let
            val topdec = (strip_trivia (add_line line))
            val new_entry = remove_newline (implode (rev topdec))
          in
            if size new_entry > 4 
              then
                (history_size := !history_size + 1;
                 ShellUtils.add_history_item ((new_entry, !history_size),
                                              history,
                                              (fn ((s,_),(s',_))=>s=s'),
                                              get_user_options()))
            else ();
	    current_topdec := []
          end
*)

d935 1
a935 1
		  start_pos = end_pos => at end or beginning of text
d940 1
a940 1
		     (close_in ();
d1009 22
a1030 3
                fun get_lines ([],current,acc) = map (implode o rev) (current :: acc)
                  | get_lines ("\n"::rest,current,acc) = get_lines(rest,[],("\n"::current)::acc)
                  | get_lines (c::rest,current,acc) = get_lines(rest,c::current,acc)
d1033 1
a1033 1
                val lines = get_lines (explode line,[],[])
@


1.71
log
@Changed Exit exn to Shell.Exit
Cleaned up history mechanism so erroneous input is also recorded
@
text
@d5 4
d1151 1
a1151 1
         (* MotifUtils.setup_menu (shell, get_user_options), *)
@


1.70
log
@Fixing bug with calling debugger
@
text
@d5 3
a341 1
  exception Exit
d473 1
a473 1
              | exn as Exit => raise exn
d499 1
a499 1
         exit_fn = fn _ => raise Exit,
a777 1
      val current_topdec = ref [];
d781 62
a842 6
      fun update_history (([], false),  _) = ()
      |   update_history (([], true), line) =
	    current_topdec := line :: !current_topdec
      |   update_history ((h::t, still_valid), line) =
	    let val topdec = 
	          String.substring (line, 0, h) :: !current_topdec
d844 4
a847 2
		val rest_of_line =
		  String.substring (line, h, size line - h)
d849 10
a858 30
		fun trivial' (~1, _) = true
		|   trivial' (n, s) =
		  case String.substring (s, n, 1) of
		    " " => trivial' (n-1, s)
		  | "\n" => trivial' (n-1, s)
		  | "\t" => trivial' (n-1, s)
		  | "\012" => trivial' (n-1, s)
		  | "\013" => trivial' (n-1, s)
		  | _ => false

		fun trivial s = trivial' (size s - 1, s)

		val new_entry = implode (rev topdec)
	    in
	      if size new_entry > 4 
                then
                  (history_size := !history_size + 1;
                   ShellUtils.add_history_item ((new_entry, !history_size),
                                                history,
                                                (fn ((s,_),(s',_))=>s=s'),
                                                get_user_options()))
	      else ();
	      current_topdec := [];
	      (* ignore white space at the end of a line following a topdec *)
	      (* actually, should probably ignore white space between topdecs
		 as well *)
	      if t = [] andalso trivial (rest_of_line) then
		()
	      else
	        update_history ((map (fn x => x-h) t, still_valid), rest_of_line)
d861 21
d963 1
a963 1
	handle Exit => Xm.Widget.destroy shell
d965 2
a966 4
      fun do_line line =
        (debug("Doing line:" ^ line ^ ":");
         update_history (handler line, line);
         output(outstream,do_prompt());
d1043 4
a1046 7
              case lines of
                last :: rest =>
                  (Lists.iterate
                   (fn line => update_history (handler line, line))
                   (rev rest);
                   do_line last)
              | _ => ()
d1094 1
a1094 1
	handle Exit => Xm.Widget.destroy shell
@


1.69
log
@Fixed C-d
@
text
@d5 3
d487 2
a488 1
                    Ml_Debugger.NOT_POSSIBLE);
@


1.68
log
@ActionQueue no longer has Incremental as a substructure.
@
text
@d5 3
a648 2
	val closed_flag = ref false
	exception Closed
d656 12
a667 14
	    if !closed_flag then raise Closed
	    else
	      if !eof_flag then
		""
	      else if pointer + n > len then
		(refill_buff ();
		 String.substring (string,pointer,len-pointer) ^
                 get_input (n - len + pointer))
		   else
		     let val result = String.substring (string,pointer,n)
		     in
		       posref := (!posref + n);
		       result
		     end
d677 7
a683 9
	  if !closed_flag then raise Closed
	  else
	    (if !eof_flag then
	       ""
	     else if !posref >= size (!strref) then
	       (refill_buff ();
		do_lookahead ())
		  else 
		    String.substring (!strref, !posref, 1))
d685 1
a685 2
	fun close_in () = (eof_flag := true;
			   closed_flag := true)
d687 1
a687 1
	fun closed_in () = !closed_flag
d889 1
a889 1
		     (handler ""; ())
@


1.67
log
@Fixing locations in errors
@
text
@d5 3
a263 1
require "../interpreter/action_queue";
a281 1
  structure ActionQueue: ACTION_QUEUE
d291 10
a300 8
  sharing ActionQueue.Incremental =
	  Ml_Debugger.Incremental

  sharing ToolData.ShellTypes.Info = ActionQueue.Incremental.InterMake.Compiler.Info
  sharing ToolData.ShellTypes.Option = ActionQueue.Incremental.InterMake.FileName.Option = DebuggerWindow.Option

  sharing UserOptions.Options = Ml_Debugger.ValuePrinter.Options = ShellUtils.Options =
    ToolData.ShellTypes.Options
d308 1
a308 1
	       ActionQueue.Incremental.Context
d323 1
a323 1
  structure Incremental = ActionQueue.Incremental
@


1.66
log
@Added support for C-a going to just after the prompt
@
text
@d5 3
d356 2
d512 1
a512 1
      val (handler', do_prompt) = Shell.shell (shell_data,"<"^title^">")
d723 3
a725 1
           (fn _ => handler' s))))
@


1.65
log
@Changed quit message for debugger, since it no longer raises Interrupt.
@
text
@d5 3
d424 13
d511 6
a520 5
          fun lastline ~1 = 0
	    | lastline n =
              if String.ordof (str, n) = ord "\n"
                then n+1
              else lastline (n-1)
d527 1
a527 1
          val start = lastline (pos-1)
d535 3
d920 13
d1001 6
d1011 2
@


1.64
log
@Added with_input_disabled to prevent commands being processed while in the debugger.
A better solution should be possible.
@
text
@d5 4
d455 1
a455 1
                    ("Raise Interrupt",
@


1.63
log
@Improvements to calling debugger.
@
text
@d5 3
d672 11
d684 11
a694 9
        MLWorks.IO.with_standard_output
	  outstream
	  (fn () =>
           MLWorks.IO.with_standard_input
           instream
           (fn () =>
            Ml_Debugger.with_debugger_type
            debugger_type
            (fn _ => handler' s)))
d935 10
a944 7
            case lines of
              last :: rest =>
                (Lists.iterate
                 (fn line => update_history (handler line, line))
                 (rev rest);
                 do_line last)
            | _ => ()
@


1.62
log
@Ml_Debugger.with_start_frame no longer needs a frame argument, removing
the need for the call to MLWorks.Internal.Value.frame_call.
@
text
@d5 4
d422 2
d425 1
a425 2
        Ml_Debugger.WINDOWING (DebuggerWindow.make_debugger_window(shell,
                                                                   "debugger",tooldata),true)
d430 22
a451 21
           (Ml_Debugger.with_start_frame
            (fn base_frame =>
             (f x)
             handle Shell.DebuggerTrapped => raise Shell.DebuggerTrapped
                  | exn as Exit => raise exn
                  | exn as Interrupt => raise exn
                  | exn as Info.Stop _ => raise exn
                  | exn =>
                      (Ml_Debugger.ml_debugger
                       debugger_type
                       (UserOptions.new_options(user_options),
                        ShellTypes.get_context_ref context_ref)
                       (fn _ => output(std_out,
				       "Debugger shell not defined yet\n"))
                       base_frame
                       (Ml_Debugger.EXCEPTION exn,
                        Ml_Debugger.POSSIBLE
                        ("Raise Interrupt",
                         Ml_Debugger.DO_RAISE Shell.DebuggerTrapped),
                        Ml_Debugger.NOT_POSSIBLE);
                       raise Shell.DebuggerTrapped)))
@


1.61
log
@Change to instream arguments.
@
text
@d5 3
a424 2
          MLWorks.Internal.Value.frame_call
          (fn base_frame =>
d426 1
a426 2
            base_frame
            (fn () =>
d445 1
a445 1
                       raise Shell.DebuggerTrapped))))
d672 1
a672 1
            (fn () => handler' s)))
@


1.60
log
@Merged in bug fix.
@
text
@d5 3
d605 2
d614 7
a620 5
	    if !eof_flag then
	      ""
            else if pointer + n > len then
              (refill_buff ();
               String.substring (string,pointer,len-pointer) ^
d622 6
a627 6
            else
              let val result = String.substring (string,pointer,n)
              in
                posref := (!posref + n);
                result
              end
d635 1
a635 1
  
d637 15
a651 10
	  (if !eof_flag then
	     ""
	   else if !posref >= size (!strref) then
	     (refill_buff ();
	      do_lookahead ())
	   else 
	     String.substring (!strref, !posref, 1))

	fun close_in () = eof_flag := true

d660 2
a661 1
                             close_in = close_in}
@


1.59
log
@Merging in bug fixes
@
text
@d5 3
d11 6
d18 1
a18 1
 *  Added destroy callback to eg. quit from editor windows
d600 2
d609 3
a611 1
            if pointer + n > len then
d626 2
a627 1
	   strref := "")
d630 3
a632 1
	  (if !posref >= size (!strref) then
d637 4
d647 2
a648 2
                             clear_eof = fn () => (),
                             close_in = fn () => ()}
d796 1
a796 1
          val (_,_,doit,_,_,start_pos,end_pos,str) =
d804 29
a832 14
            (debug ("Verify string is:" ^ str ^ ":");
             if end_pos < !write_pos
               then write_pos := (!write_pos) - end_pos + start_pos + size str
             else
               if start_pos < !write_pos
                 then write_pos := start_pos + size str
               else ();
                 if end_pos < !prompt_pos
                   then prompt_pos := (!prompt_pos) - end_pos + start_pos + size str
                 else
                   if start_pos < !prompt_pos
                     then prompt_pos := start_pos + size str
                   else ();
                     Xm.Boolean.set (doit, true))
d834 1
a835 9
      fun eof () =
	let val pos = Xm.Text.getInsertionPosition text
	in
	  if !prompt_pos = pos then
	    (handler ""; ())
	  else
	    ()
	end
       
d977 2
a978 1
        [ToolData.works_menu (shell, tools, mk_tooldata),
@


1.58
log
@Merged in bug fix.
@
text
@d5 7
d268 1
a268 1
	       MotifUtils.UserOptions
d406 3
d466 1
a466 1
      val (handler', do_prompt) = Shell.shell (shell_data,title)
d498 20
a517 18
        exception NoLocation
        fun get_location line =
          let
            val sz = size line
            fun aux index =
              if index < sz
                then
                  if String.ordof(line,index) = ord ":"
                    then index+1
                  else
                    aux (index+1)
              else
                raise NoLocation
            (* skip up to second ":" *)
            val result = String.substring(line,0,(aux (aux 0))-1)
          in
            result
          end
d519 1
a519 14
        fun edit_error _ =
          (let
	    val pos = Xm.Text.getInsertionPosition text
            val line = getline (text, pos)
            val locstring = get_location line
          in
             (ShellUtils.edit_string (locstring,
                                      ShellTypes.get_current_context shell_data,
                                      ShellTypes.get_current_options shell_data);
              ())
            handle ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
          end 
          handle NoLocation => message_fun "Edit failed: no location info found"
               | Location.InvalidLocation => message_fun "Edit failed: no location info found")
d521 16
a540 18
      fun find_common_completion [] = ""
        | find_common_completion (target::l) =
          let
            fun min (m,n) = if m < n then m else n
            fun check (s,m,n) =
              if m = n 
                then n
              else if String.ordof(s,m) = String.ordof(target,m)
                     then check (s,m+1,n)
                   else m
            fun aux ([],n) = n
              | aux ((a::l),n) =
                aux (l,check(a,0,(min (size a,n))))
            val result = String.substring (target,0,aux(l,size target))
          in
            result
          end

a547 1
          val _ = debug ("Subline is:" ^ subline ^ "\n")
a556 1
          fun beep () = Xm.Display.bell (Xm.Widget.display shell,100)
d559 1
a559 1
            [] => beep ()
d562 1
a562 1
              let val c = find_common_completion l 
d569 1
a569 1
                  else beep ()
d685 1
a685 1
      val current_history = ref []: (string * int) list ref;
a690 19
      fun ministry_of_truth ([], _, _) = []
        | ministry_of_truth ((x as (s, _))::l, new_factoid, finish) =
          if finish > 0
            then 
            if s = new_factoid then
              l
            else
              x :: ministry_of_truth (l, new_factoid, finish - 1)
          else []

      fun get_history_size () =
        let
          val options = ShellTypes.get_current_options shell_data
          val Options.OPTIONS{environment_options = Options.ENVIRONMENT_OPTIONS {history_length,...},...} =
            options
        in
          !history_length
        end

d715 7
a721 6
	      if size new_entry > 4 then
	        (history_size := !history_size + 1;
	         current_history := (new_entry, !history_size)
		 		      :: ministry_of_truth (!current_history,
							    new_entry,
                                                            get_history_size ()))
d750 1
a750 1
	    val line = #1 (Lists.nth (!history_index, !current_history))
d760 1
a760 1
	    val line = #1 (Lists.nth (!history_index, !current_history))
a797 9
        (* Don't really have to do this - it's the default. *)
        (*
         if end_pos < !write_pos
            then Xm.Boolean.set (doit, false)
          else
            if start_pos < !write_pos
              then Xm.Boolean.set (doit, false)
            else Xm.Boolean.set (doit, true)
        *)
d903 4
d921 3
a923 9
      fun warp_history str =
	let fun subst ([], _) = []
	    |   subst (_, 0)  = []
	    |   subst ("\n"::t, n) = " " :: subst (t, n-1)
	    |   subst (h::t, n) = h :: subst (t, n-1)
	in
	  implode (subst (explode str, 30))
	end
		  
d951 23
a973 23
        Menus.CASCADE ("context",
                       [Menus.PUSH ("pushContext",
                                    push_state,
                                    fn _ => true),
                        Menus.PUSH ("popContext",
                                    pop_state,
                                    can_pop_state),
			Menus.PUSH ("initialContext",
				    initialContext,
				    fn _ => true),
			Menus.SEPARATOR,
			Menus.DYNAMIC ("selectContext",
				       select_menu,
                                       fn _ => true)],
                       fn _ => true),
        Menus.CASCADE ("error",
                       [Menus.PUSH ("edit",
                                    edit_error,
                                    fn _ => true)],
                       fn _ => true),
	(* MotifUtils.setup_menu (shell, get_user_options), *)
	options_menu,
        Menus.DYNAMIC ("history",
d976 7
a982 7
			       Menus.PUSH (warp_history s,
					   fn _ => (replace_current_topdec s;
						    history_index :=
						      !history_size - i),
					   fn _ => true))
			    (!current_history),
                       fn _ => !current_history <> [])]
d987 1
@


1.57
log
@Force a new prompt when changing contexts.
@
text
@d5 9
d569 6
a574 6
                if c = sofar
                  then
                    if (!completion_menu)
                      then
                        exitter_ref := SOME (MotifUtils.list_select (shell,l,insert_fun, fn x => x))
                    else beep ()
@


1.57.1.1
log
@Fork for bug fixing
@
text
@a4 3
 *  Revision 1.57  1993/08/31  15:26:36  matthew
 *  Force a new prompt when changing contexts.
 *
@


1.57.1.2
log
@Added name parameter to MotifUtils.list_select.
@
text
@a4 3
 *  Revision 1.57.1.1  1993/08/31  15:26:36  jont
 *  Fork for bug fixing
 *
d563 6
a568 6
                if c = sofar then
                  if (!completion_menu) then
                    exitter_ref :=
		      SOME (MotifUtils.list_select
			      (shell,"completions",l,insert_fun, fn x => x))
                  else beep ()
@


1.57.1.3
log
@Added destroy callback to eg. quit from editor windows
Uses history menu utilities
@
text
@a4 3
 *  Revision 1.57.1.2  1993/09/10  11:14:01  daveb
 *  Added name parameter to MotifUtils.list_select.
 *
d258 1
a258 1
	       MotifUtils.UserOptions = ShellUtils.UserOptions
a395 3

      fun get_user_options () = user_options

d453 1
a453 1
      val (handler', do_prompt) = Shell.shell (shell_data,"<"^title^">")
d485 18
a502 20
      exception NoLocation
      fun get_location line =
        let
          val sz = size line
          fun aux index =
            if index < sz
              then
                if String.ordof(line,index) = ord ":"
                  then index+1
                else
                  aux (index+1)
            else
              raise NoLocation
          (* skip up to second ":" *)
          val result = String.substring(line,0,(aux (aux 0))-1)
        in
          result
        end
      
      val quit_funs = ref []
d504 14
a517 1
      fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)
a518 16
      fun edit_error _ =
        (let
          val pos = Xm.Text.getInsertionPosition text
          val line = getline (text, pos)
          val locstring = get_location line
          val quit_fun = 
            ShellUtils.edit_string (locstring,
                                    ShellTypes.get_current_context shell_data,
                                    ShellTypes.get_current_options shell_data)
         in
           quit_funs := quit_fun :: (!quit_funs)
        end 
      handle ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
           | NoLocation => message_fun "Edit failed: no location info found"
           | Location.InvalidLocation => message_fun "Edit failed: no location info found")
           
d523 18
d548 1
d558 1
d561 1
a561 1
            [] => MotifUtils.beep shell
d564 1
a564 1
              let val c = ShellUtils.find_common_completion l 
d571 1
a571 1
                  else MotifUtils.beep shell
d687 1
a687 1
      val history = ref []: (string * int) list ref;
d693 19
d736 6
a741 7
	      if size new_entry > 4 
                then
                  (history_size := !history_size + 1;
                   ShellUtils.add_history_item ((new_entry, !history_size),
                                                history,
                                                (fn ((s,_),(s',_))=>s=s'),
                                                get_user_options()))
d770 1
a770 1
	    val line = #1 (Lists.nth (!history_index, !history))
d780 1
a780 1
	    val line = #1 (Lists.nth (!history_index, !history))
d818 9
a931 4
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^W", ...}) =>
              MotifUtils.cutSelection text
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^Y", ...}) =>
              MotifUtils.pasteSelection text
d946 9
a954 3
      fun warp_history string =
        ShellUtils.trim_history_string (string,get_user_options())

d982 23
a1004 23
         Menus.CASCADE ("context",
                        [Menus.PUSH ("pushContext",
                                     push_state,
                                     fn _ => true),
                         Menus.PUSH ("popContext",
                                     pop_state,
                                     can_pop_state),
                         Menus.PUSH ("initialContext",
                                     initialContext,
                                     fn _ => true),
                         Menus.SEPARATOR,
                         Menus.DYNAMIC ("selectContext",
                                        select_menu,
                                        fn _ => true)],
                        fn _ => true),
         Menus.CASCADE ("error",
                        [Menus.PUSH ("edit",
                                     edit_error,
                                     fn _ => true)],
                        fn _ => true),
         (* MotifUtils.setup_menu (shell, get_user_options), *)
         options_menu,
         Menus.DYNAMIC ("history",
d1007 7
a1013 7
                             Menus.PUSH (warp_history s,
                                         fn _ => (replace_current_topdec s;
                                                  history_index :=
                                                  !history_size - i),
                                         fn _ => true))
                        (!history),
                        fn _ => !history <> [])]
a1017 1
      Xm.Widget.callbackAdd (shell, Xm.Callback.Destroy,do_quit_funs);
@


1.57.1.4
log
@Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.
Changed modify_verify to check for EOF, and changed input functions
to deal with EOF.
@
text
@a4 4
 *  Revision 1.57.1.3  1993/10/08  15:07:33  matthew
 *  Added destroy Callback to eg. quit from editor windows
 *  Uses history menu utilities
 *
a583 2

	val eof_flag = ref false
d591 1
a591 3
	    if !eof_flag then
	      ""
            else if pointer + n > len then
d606 1
a606 2
	   strref := "";
	   eof_flag := false)
d609 1
a609 3
	  (if !eof_flag then
	     ""
	   else if !posref >= size (!strref) then
a613 4

	fun close_in () = eof_flag := true

	fun clear_eof () = eof_flag := false
d620 2
a621 2
                             clear_eof = clear_eof,
                             close_in = close_in}
d769 1
a769 1
          val (_,event,doit,_,_,start_pos,end_pos,str) =
d777 14
a790 29
            (debug ("Verify: start_pos is " ^ MLWorks.Integer.makestring start_pos ^
		    ", end_pos is " ^ MLWorks.Integer.makestring end_pos ^
		    ", write_pos is " ^ MLWorks.Integer.makestring (!write_pos) ^
		    ", prompt_pos is " ^ MLWorks.Integer.makestring (!prompt_pos) ^
		    ", string is '" ^ str ^ "'");
             if end_pos < !write_pos then
	       write_pos := (!write_pos) - end_pos + start_pos + size str
             else if start_pos < !write_pos then
	       write_pos := start_pos + size str
             else if str = "" andalso start_pos = end_pos andalso
		     start_pos = !write_pos then
	       (* str = "" => deletion,
		  start_pos = end_pos => at end or beginning of text
		  start_pos = !write_pos => at beginning of input line *)
	       case event of
	         Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^D", ...}) =>
	           if !input_flag then
		     (close_in ();
		      input_flag := false)
	           else
		     (handler ""; ())
	       | _ => ()
	     else ();
             if end_pos < !prompt_pos then
	       prompt_pos := (!prompt_pos) - end_pos + start_pos + size str
             else if start_pos < !prompt_pos then
	       prompt_pos := start_pos + size str
             else ();
             Xm.Boolean.set (doit, true))
a791 1
	handle Exit => Xm.Widget.destroy shell
d793 9
d943 1
a943 2
        [ToolData.works_menu
	   (shell, tools, mk_tooldata, fn _ => not (!input_flag)),
@


1.56
log
@Return quit function from ShellUtils.edit_string
@
text
@d5 3
d381 1
a381 1
      (*** State stack ***)
a384 49
      fun set_state (context_list) =
        (context_stack := context_list;
         case context_list of
           [] => ()
        | (context_ref :: _) =>
            let
              val context_name =
                ShellTypes.string_context_name(ShellTypes.get_context_name context_ref)
              val cstring = Xm.CompoundString.createSimple("Context: " ^ context_name)
            in
              Xm.Widget.valuesSet(contextLabel,
                                  [(Xm.LabelString, 
                                    Xm.COMPOUNDSTRING cstring)])
            end)
              
      val _ = set_state [context_ref]

      fun can_pop_state _ =
        case !context_stack of
          (_::_::_) => true
        | _ => false

      fun pop_state _ =
        case !context_stack of
          _::(b as (_::_)) => set_state b
        | _ => ()

      fun push_state _ =
        let
          val statelist = !context_stack
        in
            case statelist of
              (c::_) => set_state((ShellTypes.copyContextRef c) :: statelist)
              | _ => ()
        end

      fun get_current_state () =
        case !context_stack
          of
          (state :: _) => state
        | _ => Crash.impossible "Empty state stack in get_current_state"

      fun initialContext _ =
        let
          val context = ShellTypes.getNewInitialContext()
        in
          set_state (context :: !context_stack)
        end

d430 17
d636 41
@


1.55
log
@>Improved editing error handling
@
text
@d5 3
d533 4
a536 3
            ShellUtils.edit_string (locstring,
                                    ShellTypes.get_current_context shell_data,
                                    ShellTypes.get_current_options shell_data)
@


1.54
log
@Changes to user options
Removed preferences menu
Options update
@
text
@d5 5
d502 3
d533 1
a533 2
            handle ShellUtils.EditFailed s =>
              MotifUtils.send_message (shell,s)
d535 2
a536 2
          handle NoLocation => (output(std_out,"No location info found\n"))
               | Location.InvalidLocation => (output(std_out,"No location info found\n")))
@


1.53
log
@tooldata passed to make_debugger_window for inspector invocation
in debugger-window.
@
text
@d5 4
d948 3
d973 2
a974 2
	MotifUtils.setup_menu (shell, get_user_options),
	MotifUtils.options_menu (shell, title, get_user_options),
@


1.52
log
@Get maximum history length from options
Beep when no completion found
Longest common prefix completion
Pass stream name to Shell.shell
@
text
@d5 6
d253 2
d421 3
a423 5
      val (debugger_window_fn,message_fn) =
        DebuggerWindow.make_debugger_window(shell,"debugger")

      val debugger_type = Ml_Debugger.WINDOWING (debugger_window_fn,message_fn,true)

@


1.51
log
@Added error editing operation
@
text
@d5 3
d252 1
a252 1

d458 1
a458 1
      val (handler', do_prompt) = Shell.shell shell_data
d525 18
d551 3
d556 1
a556 1
                                        ShellTypes.get_current_options shell_data,
d560 1
a561 6
          debug (sofar^"\n");
          if do_debug
            then
              Lists.iterate(fn s => output(MLWorks.IO.terminal_out,s^"\n")) completions
          else
            ();
d563 1
a563 1
            [] => ()
d565 11
a575 1
          | l => exitter_ref := SOME (MotifUtils.list_select (shell,l,insert_fun, fn x => x))
d654 4
a657 3
      fun ministry_of_truth (_, _, 0) = []
      |   ministry_of_truth ([], _, _) = []
      |   ministry_of_truth ((x as (s, _))::l, new_factoid, finish) =
d662 10
d702 1
a702 1
							    25))
@


1.50
log
@Removed value menu for the time being, since there's nothing on it.
@
text
@d5 3
d248 1
d484 34
d530 4
a533 3
          val (sofar,completions) = ShellUtils.get_completions (subline,
                                                         ShellTypes.get_current_options shell_data,
                                                         ShellTypes.get_current_context shell_data)
d914 5
@


1.49
log
@Added tty_ok value to WINDOWING
@
text
@d5 3
a860 5
        Menus.CASCADE ("value",
                       [Menus.PUSH ("trace",
                                    fn _ => output(std_out,"Trace not defined\n"),
                                    fn _ => false)],
                        fn _ => true),
@


1.48
log
@Added completion
Changed getline function
@
text
@d5 4
d403 1
a403 1
      val debugger_window_fn =
d406 1
a406 1
      val debugger_type = Ml_Debugger.WINDOWING debugger_window_fn
@


1.47
log
@Added some very preliminary stuff for completion.
@
text
@d5 3
d182 1
d200 1
d214 2
a215 1
  sharing UserOptions.Options = Ml_Debugger.ValuePrinter.Options
d221 1
a445 1

d448 18
a465 16
      fun getline (str, pos, length) =
	let fun lastline ~1 = 0
	    |   lastline n = if String.ordof (str, n) = ord "\n" then
			  n+1
			else
			  lastline (n-1)

	    fun nextline n =
	      if n = length orelse String.ordof (str, n) = ord "\n" then
		n
	      else
		nextline (n+1)

	    val start = lastline (pos-1)
	    val finish = nextline (pos)
	    val result = String.substring (str, start, finish - start)
d468 1
a468 1
          result
d471 32
d665 8
a672 2
        let val (_,_,doit,_,_,start_pos,end_pos,str) =
	      Xm.Callback.convertTextVerify callback_data
d676 1
a676 1
              (Xm.Text.insert (text,start_pos,"foo");
a724 1
          val str = Xm.Text.getString text
d726 1
a726 1
          val length = size str
d729 1
a729 1
            let val line = strip_prompt (getline (str, pos, length))
d731 2
a732 2
              Xm.Text.insert(text, length, line);
              Xm.Text.setInsertionPosition (text, length+size line)
a739 1
          val str = Xm.Text.getString text
a740 1
          val length = size str
d743 3
a745 1
              let val line = strip_prompt (getline (str, pos, length)) ^ "\n"
d747 3
a749 3
                Xm.Text.insert(text, length, line);
                write_pos := length + size line;
                Xm.Text.setInsertionPosition (text, length+size line);
d754 2
@


1.46
log
@Removed integer parameter
@
text
@d5 3
d628 4
a631 9
          debug ("Verify string is:" ^ str ^ ":");
          if end_pos < !write_pos
            then write_pos := (!write_pos) - end_pos + start_pos + size str
          else
            if start_pos < !write_pos
              then write_pos := start_pos + size str
            else ();
          if end_pos < !prompt_pos
            then prompt_pos := (!prompt_pos) - end_pos + start_pos + size str
d633 17
a649 7
            if start_pos < !prompt_pos
              then prompt_pos := start_pos + size str
            else ();
	  Xm.Boolean.set (doit, true)
	  (* Don't really have to do this - it's the default. *)
(*
          if end_pos < !write_pos
d655 1
a655 1
*)
@


1.45
log
@All tools now set their own titles and pass them to their options menus.
@
text
@d5 3
a170 1
require "../utils/integer";
a188 1
  structure Integer: INTEGER
d759 1
a759 1
	      debug ("key press: key = " ^ Integer.makestring (ord key))
d761 1
a761 1
	      debug ("key release: key = " ^ Integer.makestring (ord key))
@


1.44
log
@History no longer allows duplicate entries, nor very short entries,
and is limited in length.
@
text
@d5 4
d819 1
a819 1
	MotifUtils.options_menu (shell, get_user_options),
@


1.43
log
@Added code to check state of meta keys.
@
text
@d5 3
d253 1
a253 1
          "listener #" ^ p ("", n)
d531 8
d560 2
d563 7
a569 3
	      history_size := !history_size + 1;
	      current_history := (implode (rev topdec), !history_size)
				   :: !current_history;
@


1.42
log
@Replaced creation of outstream with MotifUtils.make_outstream.
Revised handling of contexts.
@
text
@d5 4
a708 4
(*
      fun meta c = chr (ord c + 128)
*)

a712 2
          (* WARNING : the handlers for meta characters ignore the modifier keys *)
          (* THIS IS WRONG and should be fixed, MLA *)
d714 12
a725 4
	    Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "p", ...}) => (* meta-p *)
	      pop_history ()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "n", ...}) => (* meta-n *)
	      push_history ()
@


1.41
log
@Changed type of ml_debugger.
@
text
@d5 3
d320 1
a320 27
      val outbuff = ref [] : string list ref

      fun flush_buffer () =
        let val result = !outbuff
        in
          outbuff := [];
          insert_text (implode(rev(result)))
        end

      fun output_fn s =
        let
          fun has_nl 0 = false
            | has_nl n =
              if String.ordof (s,n-1) = ord"\n"
                then true
              else
                has_nl (n-1)
        in
          outbuff := s :: !outbuff;
          if has_nl (size s) then
            flush_buffer()
          else ()
        end
          
      val outstream = MLWorks.IO.outstream {output = output_fn,
                                            flush_out = flush_buffer,
                                            close_out = fn () => ()}
d368 1
a368 1
      fun selectContext _ =
d370 1
a370 3
          val contextlist = ShellTypes.getCurrentContexts()
          fun set_context context_ref =
              set_state (context_ref :: !context_stack)
d372 1
a372 5
          MotifUtils.list_select
          (shell,
           contextlist,
           set_context,
           ShellTypes.string_context_name o ShellTypes.get_context_name)
d564 2
a565 1
	  (* tried using Xm.Text.replace here, but it didn't work properly. *)
d567 1
a567 5
	  Xm.Text.setInsertionPosition (text, !prompt_pos + size line) (* write_pos) *)
(*
	  Xm.Text.setString (text, const_str ^ line);
(*	  write_pos := !prompt_pos + size line; *)
*)
d613 1
a621 1
	  (* Don't really have to do this - it's the default. *)
d754 15
d783 7
a789 3
                        Menus.PUSH ("selectContext",
                                    selectContext,
                                    fn _ => true)],
@


1.40
log
@ Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d5 3
d425 1
a425 3
                       (Incremental.OPTIONS
		          {options = UserOptions.new_options(user_options),
                           debugger = debugger_function},
@


1.39
log
@Added interrupt handler around debugger
Added Ctrl-U handler and delete_current_line
@
text
@d5 4
a227 1
                                    error_info,
d422 3
a424 3
                       (Incremental.OPTIONS{error_info = error_info,
                                            options = UserOptions.new_options(user_options),
                                            debugger = debugger_function},
d426 2
a427 1
                       (fn _ => output(std_out,"Debugger shell not defined yet|\n"))
a439 2
         output_fn = output_fn,
         error_info = error_info,
@


1.38
log
@Debugger changes
@
text
@d5 3
d205 1
d412 4
a415 1
             handle exn as Exit => raise exn
d598 5
a602 1
	    
d749 1
d752 3
@


1.37
log
@Simplified state_stack (now context_stack)
ShellTypes revision
@
text
@d5 4
d179 1
a179 1
  sharing ToolData.ShellTypes.Option = ActionQueue.Incremental.InterMake.FileName.Option
d399 2
d404 3
d411 1
a411 1
                       (Ml_Debugger.WINDOWING debugger_window_fn)
d423 1
a423 1
                       raise Shell.DebuggerTrapped))
d529 4
a532 1
           (fn () => handler' s))
@


1.36
log
@Removed inspector from values menu (It's now in the works menu).
Removed old debugger code.
@
text
@d5 4
a181 7
  sharing type ActionQueue.print_method_table =
	       ToolData.ShellTypes.print_method_table =
	       Ml_Debugger.ValuePrinter.print_method_table

  sharing type Ml_Debugger.ValuePrinter.printer_descriptor =
    	       ToolData.ShellTypes.printer_descriptor

a202 1
  type print_method_table = ShellTypes.print_method_table
a214 1
                                    print_method_table_ref,
a216 1
                                    name_monitor,
d333 1
a333 1
      val state_stack = ref []
d335 3
a337 3
      fun set_state (state_list) =
        (state_stack := state_list;
         case state_list of
d339 1
a339 1
        | (ShellTypes.SHELL_STATE {context_ref,...} :: _) =>
d350 1
a350 4
      val _ = set_state [ShellTypes.SHELL_STATE
                         {context_ref = context_ref,
                          user_options = user_options,
                          print_method_table_ref = print_method_table_ref}]
d353 1
a353 1
        case !state_stack of
d358 1
a358 1
        case !state_stack of
d364 1
a364 1
          val statelist = !state_stack
d367 1
a367 1
              (state::_) => set_state((ShellTypes.copy_shell_state state) :: statelist)
d372 1
a372 1
        case !state_stack
d381 1
a381 8
            let
              val ShellTypes.SHELL_STATE{user_options,print_method_table_ref,...} = get_current_state()
            in
              set_state (ShellTypes.SHELL_STATE{context_ref = context_ref,
                                                user_options = user_options,
                                                print_method_table_ref = print_method_table_ref} ::
              !state_stack)
            end
d403 1
a403 2
                       (!print_method_table_ref,
                        Incremental.OPTIONS{error_info = error_info,
a404 1
                                            name_monitor = name_monitor,
a415 16
      fun make_new_listener_args () =
        let
          val (ShellTypes.SHELL_STATE{context_ref,
                                      user_options,
                                      print_method_table_ref}) = get_current_state()
        in
          ShellTypes.LISTENER_ARGS
          {context_ref = context_ref,
           print_method_table_ref = print_method_table_ref,
           user_options = user_options,
           error_info = error_info,
           name_monitor = name_monitor,
           prompter = prompter,
           mk_xinterface_fn = mk_xinterface_fn}
        end

d418 2
a419 1
        {state_stack = state_stack,
a421 1
         name_monitor = name_monitor,
d750 1
a750 1
	ToolData.TOOLDATA {args = make_new_listener_args (),
d753 2
a755 5
      fun get_user_options () = 
	case get_current_state() of
	  ShellTypes.SHELL_STATE
	    {user_options, ...} => user_options

@


1.35
log
@Added tools argument to works_menu(),
removed exitApplication from TOOLDATA (works_menu now accesses it directly).
@
text
@d5 4
a144 1
require "inspector_tool";
a165 1
  structure InspectorTool : INSPECTORTOOL
d183 1
a183 1
    ToolData.ShellTypes.printer_descriptor
d189 1
a189 2
  sharing type Shell.ShellData = ToolData.ShellTypes.ShellData =
    	       InspectorTool.ShellData
d191 1
a191 1
  sharing type Menus.Widget = Xm.Widget = InspectorTool.Widget =
d216 1
a216 1
  fun create (ToolData.TOOLDATA {args,appdata,tools}) =
a411 28
        let
          val call_debugger =
            Ml_Debugger.ml_debugger
              Ml_Debugger.TERMINAL
              (!print_method_table_ref,
               Incremental.OPTIONS{error_info = error_info,
                                   options = UserOptions.new_options(user_options),
                                   name_monitor = name_monitor,
                                   debugger = debugger_function},
               ShellTypes.get_context_ref context_ref)
              (fn _ =>
               let
                 val (ShellTypes.SHELL_STATE{context_ref,
                                             user_options,
                                             print_method_table_ref}) = get_current_state()
               in
                 TTYListener.listener
                 (ShellTypes.LISTENER_ARGS
                  {context_ref = context_ref,
                   print_method_table_ref = print_method_table_ref,
                   user_options = user_options,
                   error_info = error_info,
                   name_monitor = name_monitor,
                   prompter = prompter,
                   mk_xinterface_fn = mk_xinterface_fn});
                 ()
               end)
        in
a432 1
        end
a470 3
      fun inspect_it _ =
        InspectorTool.inspect (shell_data,applicationShell)

d796 1
a796 4
                       [Menus.PUSH ("inspect",
                                    inspect_it,
                                    fn _ => true),
                        Menus.PUSH ("trace",
@


1.34
log
@Added context selection
Changed context ref handling
@
text
@d5 4
d825 1
a825 1
        [ToolData.works_menu (shell, mk_tooldata),
@


1.33
log
@Added quit to windowing debugger.
,
@
text
@d5 4
d255 9
d268 1
a268 1
	   (Xm.TopWidget, Xm.WIDGET menuBar),
d334 21
a354 4
      val state_stack = ref [ShellTypes.SHELL_STATE
                             {context_ref = context_ref,
                              user_options = user_options,
                              print_method_table_ref = print_method_table_ref}]
d363 1
a363 1
          _::(b as (_::_)) => state_stack := b
d371 1
a371 1
              (state::_) => state_stack := (ShellTypes.copy_shell_state state) :: statelist
d381 19
d416 1
a416 1
               context_ref)
d447 1
a447 1
                        context_ref)
d838 2
a839 2
                                    fn _ => (),
                                    fn _ => false)],
@


1.32
log
@Reorganised menus.
@
text
@d5 3
d402 3
a404 1
                        Ml_Debugger.NOT_POSSIBLE,
@


1.31
log
@Moved options menu code to _motif_utils.
@
text
@d5 3
a130 1
require "browser_tool";
a152 1
  structure BrowserTool : BROWSERTOOL
d177 1
a177 1
    	       InspectorTool.ShellData = BrowserTool.ShellData
d180 1
a180 1
    	       DebuggerWindow.Widget = ToolData.Widget = BrowserTool.Widget =
d185 1
a185 1
  sharing type Menus.ButtonSpec = MotifUtils.ButtonSpec
d214 2
a215 1
      val ToolData.APPLICATIONDATA {exitApplication,applicationShell,...} = appdata
a443 5
      fun browse_it _ =
	BrowserTool.browse (shell_data,applicationShell)

      fun close_listener _ =  Xm.Widget.destroy shell

d756 4
a759 10
      val tools_buttons =
        map
        (fn (name,toolfun) =>
         Menus.PUSH (name,
                     fn _ =>
                     toolfun (ToolData.TOOLDATA {args = make_new_listener_args (),
                                                 appdata = appdata,
                                                 tools = tools}),
                     fn _ => true))
        tools
d767 1
a767 12
        [Menus.CASCADE ("file",
                        [Menus.PUSH ("close",
                                     close_listener,
                                     fn _ => true),
                         Menus.SEPARATOR,
                         Menus.PUSH ("exit",
                                     fn _ => exitApplication(),
                                     fn _ => true)],
                        fn _ => true),
        Menus.CASCADE ("tools",
                       tools_buttons,
                       fn _ => true),
a775 3
	Menus.CASCADE ("editor",
		       [],
		       fn _ => true),
d777 1
a777 4
                       [Menus.PUSH ("browseContext",
				    browse_it,
                                    fn _ => true),
                        Menus.PUSH ("pushContext",
d787 1
@


1.30
log
@Indentation change & removed old tracing code
Removed ML_Debugger.BASE_FRAME
@
text
@d5 4
d130 1
d148 1
d161 2
a162 1
  sharing type UserOptions.user_options = ToolData.ShellTypes.user_options
d175 2
a176 1
  sharing type Shell.ShellData = ToolData.ShellTypes.ShellData = InspectorTool.ShellData = BrowserTool.ShellData
d179 2
a180 1
    DebuggerWindow.Widget = ToolData.Widget = BrowserTool.Widget
d183 2
a345 28
      (*** Options Menus ***)
      (* Trial version *)

      local
        fun set_option_fun f a =
          let
            val
              ShellTypes.SHELL_STATE
              {user_options = UserOptions.USER_OPTIONS options,...} =
              get_current_state()
          in
            (f options) := a
          end
        fun get_option_fun f () =
          let
            val
              ShellTypes.SHELL_STATE
              {user_options = UserOptions.USER_OPTIONS options,...} =
              get_current_state()
          in
            !(f options)
          end

        fun int_widget (name,accessor) =
          Menus.OPTINT(name,get_option_fun accessor,set_option_fun accessor)
          
        fun bool_widget (name,accessor) =
          Menus.OPTTOGGLE(name,get_option_fun accessor,set_option_fun accessor)
a346 97
      in
        val popup_print_options =
          Menus.create_dialog
          (shell,
           "valuePrinterOptions",
           [Menus.OPTLABEL "valuePrinterOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_widget("showEqInfo",#show_eq_info),
            bool_widget("showIdClass",#show_id_class),
            bool_widget("showFnDetails",#show_fn_details),
            bool_widget("showExnDetails",#show_exn_details),
            int_widget("maximumListSize",#maximum_list_size),
            int_widget("maximumDepth",#maximum_depth),
            int_widget("maximumShapeDepth",#maximum_shape_depth),
            int_widget("maximumRefDepth",#maximum_ref_depth)
            ])

        val popup_environment_options =
          Menus.create_dialog
          (shell,
           "environmentOptions",
           [Menus.OPTLABEL "environmentOptionsLabel",
            Menus.OPTSEPARATOR])

        val popup_compiler_options =
          Menus.create_dialog
          (shell,
           "compilerOptions",
           [Menus.OPTLABEL "compilerOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_widget("generateTracingCode", #generate_tracing_code),
            bool_widget("generateProfilingCode", #generate_profiling_code),
            bool_widget("generateDebugInfo", #generate_debug_info),
            bool_widget("showDebugWarnings", #show_debug_warnings),
            bool_widget("optimiseLeafFns", #optimise_leaf_fns),
            bool_widget("optimiseTailCalls", #optimise_tail_calls),
            bool_widget("optimiseSelfTailCalls",#optimise_self_tail_calls)])

        val popup_internals_options =
          Menus.create_dialog
          (shell,
           "internalsOptions",
           [Menus.OPTLABEL "internalsOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_widget("showAbsyn",#show_absyn),
            bool_widget("showLambda",#show_lambda),
            bool_widget("showOptLambda",#show_opt_lambda),
            bool_widget("showEnviron",#show_environ),
            bool_widget("showMir",#show_mir),
            bool_widget("showOptMir",#show_opt_mir),
            bool_widget("showMach",#show_mach)])

        val popup_compatibility_options =
          Menus.create_dialog
          (shell,
           "compatibilityOptions",
           [Menus.OPTLABEL "compatibilityOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_widget("stringInequalities", #string_inequalities),
            bool_widget("polyMakestring", #poly_makestring),
            bool_widget("infixrAssoc", #infixr_assoc),
            bool_widget("opInDatatype", #op_in_datatype),
            bool_widget("njInclude", #nj_include),
            bool_widget("njOpen", #nj_local_open),
            bool_widget("semiColons", #semicolons),
            bool_widget("derivedRedef", #derived_redef)
	    ])

        val popup_extensions_options =
          Menus.create_dialog
          (shell,
           "extensionsOptions",
           [Menus.OPTLABEL "extensionsOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_widget("requireKeyword",#require_keyword),
            bool_widget("typeDynamic",#type_dynamic)])

	val popup_editor_options =
	  Menus.create_dialog
	  (shell,
	   "editorOptions",
	   [Menus.OPTLABEL "editorOptionsLabel",
	    Menus.OPTSEPARATOR,
	    Menus.OPTTOGGLE ("select_emacs",
			     fn () => case get_option_fun (#editor) () of
                               "emacs" => true
			     | _ => false,
			     fn false => set_option_fun (#editor) "vi"
			     | true => set_option_fun (#editor) "emacs"),
	    Menus.OPTTOGGLE ("select_vi",
			     fn () => case get_option_fun (#editor) () of
                             "vi" => true
			     | _ => false,
			     fn true => set_option_fun (#editor) "vi"
			     | false => set_option_fun (#editor) "emacs")])
      end
              
d770 5
d813 1
a813 23
        Menus.CASCADE ("options",
                       [Menus.PUSH ("environment",
                                    popup_environment_options,
                                    fn _ => true),
                        Menus.PUSH ("compiler",
                                    popup_compiler_options,
                                    fn _ => true),
                        Menus.PUSH ("valueprinter",
                                    popup_print_options,
                                    fn _ => true),
                        Menus.PUSH ("internals",
                                    popup_internals_options,
                                    fn _ => true),
                        Menus.PUSH ("compatibility",
                                    popup_compatibility_options,
                                    fn _ => true),
                        Menus.PUSH ("extensions",
                                    popup_extensions_options,
                                    fn _ => true),
			Menus.PUSH ("editor",
				    popup_editor_options,
				    fn _ => true)],
                       fn _ => true),
@


1.29
log
@Use Xm.Text.Replace function for replacing topdecs
ModifyVerify takes note of modifications before the prompt
Added yank current line
Changed key bindings
@
text
@d5 6
d496 1
a496 12
            (fn base_frame =>
             ((
(*
  (MLWorks.Internal.Tracing.with_tracing
                (fn in_value =>
                 call_debugger
                 Ml_Debugger.NO_BASE_FRAME
                 (Ml_Debugger.TRACE in_value,
                  Ml_Debugger.NOT_POSSIBLE,
                  Ml_Debugger.NOT_POSSIBLE
                  )) f x)
*)
d498 16
a513 17
               handle exn as Exit => raise exn
                    | exn =>
                        (Ml_Debugger.ml_debugger
                         (Ml_Debugger.WINDOWING debugger_window_fn)
                         (!print_method_table_ref,
                          Incremental.OPTIONS{error_info = error_info,
                                              options = UserOptions.new_options(user_options),
                                              name_monitor = name_monitor,
                                              debugger = debugger_function},
                          context_ref)
                         (fn _ => output(std_out,"Debugger shell not defined yet|\n"))
                         (Ml_Debugger.BASE_FRAME base_frame)
                         (Ml_Debugger.EXCEPTION exn,
                          Ml_Debugger.NOT_POSSIBLE,
                          Ml_Debugger.NOT_POSSIBLE);
                         raise Shell.DebuggerTrapped)
                         )))
@


1.28
log
@The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.
@
text
@d5 5
d702 3
d707 1
a707 1
	  Xm.Text.setInsertionPosition (text, !prompt_pos + size line) (* write_pos) *)
d732 1
a732 1
        let val (_,_,doit,_,_,_,_,str) =
d735 13
d749 8
d779 16
d841 4
d849 2
d852 1
a852 1
	    Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^P", ...}) =>
d854 1
a854 1
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^N", ...}) =>
d858 2
@


1.27
log
@Added browse context menu item.
@
text
@d5 3
d438 1
a438 1
			       MLWorks.Editor.EMACS => true
d440 2
a441 2
			     fn false => set_option_fun (#editor) MLWorks.Editor.VI
			     | true => set_option_fun (#editor) MLWorks.Editor.EMACS),
d444 1
a444 1
			       MLWorks.Editor.VI => true
d446 2
a447 2
			     fn true => set_option_fun (#editor) MLWorks.Editor.VI
			     | false => set_option_fun (#editor) MLWorks.Editor.EMACS)])
@


1.26
log
@Commented out old tracing stuff..
@
text
@d5 3
d110 1
d131 1
d154 1
a154 1
  sharing type Shell.ShellData = ToolData.ShellTypes.ShellData = InspectorTool.ShellData
d157 1
a157 1
    DebuggerWindow.Widget = ToolData.Widget
d554 3
d859 4
a862 1
                       [Menus.PUSH ("pushContext",
d904 1
a904 1
                       fn _ => !current_history = [])]
@


1.25
log
@Added debug function do_debug control variable
Removed call to strip_prompt from getline
Rewrite of do_return to handle input properly
@
text
@d5 5
d478 12
a489 11
             (((MLWorks.Internal.Tracing.with_tracing
               ( fn in_value =>
                   call_debugger
                     Ml_Debugger.NO_BASE_FRAME
                     ( Ml_Debugger.TRACE in_value,
                       Ml_Debugger.NOT_POSSIBLE,
                       Ml_Debugger.NOT_POSSIBLE
                     )
               )
               f
               x)
@


1.24
log
@Added history menu.
@
text
@d5 3
d165 3
d235 4
a238 5
      (* write_pos is a local copy of the position of the end of the buffer.
	 It saves getting the length of the text every time we want to
	 insert something.  We can only use it when writing to the buffer.
	 We don't know about the user's changes to the buffer without
	 getting the string explicitly.
d560 1
a560 1
	    val all = String.substring (str, start, finish - start)
d562 2
a563 1
	    ((* finish = length, *) strip_prompt all)
d571 1
d603 2
a604 1
	  (posref := 0;
d681 2
a682 2
	  write_pos := !prompt_pos + size line;
	  Xm.Text.setInsertionPosition (text, !write_pos)
d724 2
a725 1
        (update_history (handler line, line);
d734 44
a777 40
	let val str = Xm.Text.getString text
	    val pos = Xm.Text.getInsertionPosition text
	    val length = size str
	in
	    if pos < !prompt_pos then
	      let val line = getline (str, pos, length) ^ "\n"
	      in
	          (Xm.Text.insert(text, length, line);
	           write_pos := length + size line;
	           Xm.Text.setInsertionPosition (text, length);
		   do_line line)
	      end
	    else if !input_flag then
	      (* should really check that we're at the end of the buffer *)
	      let val line = getline (str, pos, length) ^ "\n"
	      in
	         Xm.Text.insert(text, length, "\n");
	         write_pos := length + 1;
                 input_string := line;
                 input_flag := false
	      end
	    else
	      let val topdec = String.substring (str, !prompt_pos,
					         length - !prompt_pos)
		  fun read_topdec i =
	            let val line = getline (str, i, length)
			val new_pos = i + size line
		    in
		      if new_pos = length then
	                (Xm.Text.insert(text, length, "\n");
	                 write_pos := length + 1;
			 do_line (line ^ "\n"))
		      else
			(update_history (handler line, line);
			 read_topdec (new_pos + 1))
		    end
	      in
		read_topdec (!prompt_pos)
	      end
	 end 
d793 1
a793 1
	      output (MLWorks.IO.terminal_out, "key press: key = " ^ Integer.makestring (ord key) ^ "\n")
d795 2
a796 2
	      output (MLWorks.IO.terminal_out, "key release: key = " ^ Integer.makestring (ord key) ^ "\n")
	  | _ => output (MLWorks.IO.terminal_out, "activate: non-key event\n")
@


1.23
log
@*** empty log message ***
@
text
@d5 3
d622 5
a626 1
      val current_history = ref [];
d653 3
a655 1
	      current_history := implode (rev topdec) :: !current_history;
d666 1
a666 1
      fun pop_history () = 
a668 2
	    val _ = history_index := !history_index + 1
	    val line = Lists.nth (!history_index, !current_history)
d671 1
d676 7
d688 2
a689 4
	let val str = Xm.Text.getString text
	    val length = size str
	    val _ = history_index := !history_index - 1;
	    val line = Lists.nth (!history_index, !current_history)
a693 1
	    val const_str = String.substring (str, 0, !prompt_pos);
d695 1
a695 4
	  (* tried using Xm.Text.replace here, but it didn't work properly. *)
	  Xm.Text.setString (text, const_str ^ line);
	  write_pos := !prompt_pos + size line;
	  Xm.Text.setInsertionPosition (text, !write_pos)
d787 9
d864 11
a874 1
                       fn _ => true)]
@


1.22
log
@Changed "text" widget name to "textIO";
@
text
@d5 3
a90 1
require "../interpreter/shell_types";
d93 1
a93 1
require "fileselect";
a109 1
  structure ShellTypes: SHELL_TYPES
d112 1
a112 1
  structure FileSelect : FILE_SELECT
d120 2
a121 2
  sharing ShellTypes.Info = ActionQueue.Incremental.InterMake.Compiler.Info
  sharing ShellTypes.Option = ActionQueue.Incremental.InterMake.FileName.Option
d125 1
a125 1
  sharing type UserOptions.user_options = ShellTypes.user_options
d128 1
a128 1
	       ShellTypes.print_method_table =
d132 1
a132 1
    ShellTypes.printer_descriptor
d135 1
a135 1
               ShellTypes.Context =
d138 1
a138 1
  sharing type Shell.ShellData = ShellTypes.ShellData = InspectorTool.ShellData
d141 1
a141 1
    DebuggerWindow.Widget = FileSelect.Widget
d143 1
a143 1
  sharing type TTYListener.ListenerArgs = ShellTypes.ListenerArgs
d148 1
d154 1
a154 1
  type Args = ShellTypes.ListenerArgs
d159 1
a159 10
  fun create
    (args as ShellTypes.LISTENER_ARGS {context_ref,
                                       print_method_table_ref,
                                       user_options,
                                       error_info,
                                       name_monitor,
                                       prompter,
                                       mk_xinterface_fn},
     exit_application,
     applicationShell) =
d161 9
a169 1

d495 1
a495 1
      fun make_new_listener _ =
d501 8
a508 10
          create(ShellTypes.LISTENER_ARGS
                 {context_ref = context_ref,
                  print_method_table_ref = print_method_table_ref,
                  user_options = user_options,
                  error_info = error_info,
                  name_monitor = name_monitor,
                  prompter = prompter,
                  mk_xinterface_fn = mk_xinterface_fn},
                 exit_application,
                 applicationShell)
a536 2
      fun make_file_browser _ = FileSelect.make_selector applicationShell
        
d778 11
d796 1
a796 1
                                     fn _ => exit_application(),
d799 3
a809 12
        Menus.CASCADE ("tools",
                       [Menus.PUSH ("listener",
                                    make_new_listener,
                                    fn _ => true),
                        Menus.PUSH ("fileBrowser",
                                    make_file_browser,
                                    fn _ => true),
                        Menus.PUSH ("contextBrowser",
                                    fn _ => output(std_out,"No context browser yet\n"),
                                    fn _ => false)],
                        
                       fn _ => true),
@


1.21
log
@Fixed the history mechanism.
@
text
@d5 3
d203 1
a203 1
	  mainWindow, Xm.Widget.NAME "text",
d538 1
a538 1
      fun make_file_browser _ = FileSelect.make_selector shell
@


1.20
log
@Changed interface to file selection
@
text
@d5 3
d79 1
d99 1
d554 1
a554 1
	    (finish = length, strip_prompt all)
d621 2
d624 1
a624 1
      fun update_history (([], false), _) = ()
d629 2
a630 1
	          MLWorks.String.substring (line, 0, h) :: !current_topdec
d632 13
a644 1
		  MLWorks.String.substring (line, h, size line - h)
d647 8
a654 1
	      update_history ((t, still_valid), rest_of_line)
a656 1
      exception Virgin
d660 22
a681 3
	    val line = case !current_history of
			 [] => raise Virgin
		       | (h::t) => (current_history := t; h)
d683 4
a686 2
	  Xm.Text.replace(text, !prompt_pos, length, line);
	  write_pos := !prompt_pos + size line
d697 19
a715 1
      fun do_line () =
d719 37
a755 30
	    val (is_last, line') =
	      if not (!input_flag) andalso pos > !prompt_pos then
		(true, String.substring (str, !prompt_pos,
					 length - !prompt_pos))
	      else
	        getline (str, pos, length)
	    val line = line' ^ "\n"
	    val new_length = 
	      if not(is_last) then (
	        Xm.Text.insert(text, length, line);
	        length + size line + 1
	      )
	      else (
	        Xm.Text.insert(text, length, "\n");
	        length + 1
	      )
	in 
	   write_pos := new_length;
           if !input_flag then
             (input_string := line ^ "\n";
              input_flag := false)
           else
             (update_history (handler line, line);
              output(outstream,do_prompt());
              MLWorks.IO.flush_out outstream;
	      prompt_pos := !write_pos;
	      (* Clear waiting input from std_in. *)
	      clear_input ())
	end
	handle Exit => Xm.Widget.destroy shell
d764 4
d769 1
a769 1
	      do_line()
d776 1
@


1.19
log
@Added editor options menu and Editor menu
@
text
@d5 3
d530 1
a530 5
      val file_browser_fn = 
        FileSelect.select_file
	  (shell, fn s => output(std_out,"File \"" ^ s ^ "\" selected\n"))

      fun make_file_browser _ = file_browser_fn ()
@


1.18
log
@Fixed input to work with recent changes.  Added working lookahead.
Reinstated change to location of user_options, which I accidentally erased
in the previous revision.
@
text
@d5 5
d396 19
d732 3
d764 4
a767 1
                                    fn _ => true)],
@


1.17
log
@Added a first stab at a history mechanism.  Buggy.  Lots of support work
needed to get this far, so from here on it's plain sailing :-)
@
text
@d5 4
d70 1
a70 1
require "../interpreter/user_options";
d221 1
a221 2
	( output (MLWorks.IO.terminal_out, "inserting ...\n");
	  Xm.Text.insert(text, !write_pos, str);
d512 1
a512 1
			  n
d536 2
a537 1
      val inbuff = (ref 0,ref "")
d539 14
a552 14
      fun get_input (n,inbuff as (posref,strref)) =
        let
          fun refill_buff () =
            let val new_string = input_fun ()
            in
              posref := 0;
              strref := new_string
            end
          val string = !strref
          val pointer = !posref
          val len = size string
        in
          if pointer + n > len
            then
d555 8
a562 8
               get_input (n - len + pointer,inbuff))
          else
            let val result = String.substring (string,pointer,n)
            in
              posref := (!posref + n);
              result
            end
        end
d564 12
d577 3
a579 3
        MLWorks.IO.instream {input = fn n => get_input(n,inbuff),
                             lookahead = fn () => "",
                             end_of_stream = fn () => false,
d620 1
a620 2
        let val _ = output (MLWorks.IO.terminal_out, "in modifyVerify\n")
	    val (_,_,doit,_,_,_,_,str) =
d631 2
a632 3
	    val (is_last, line) =
	      if pos > !prompt_pos then
		(output(MLWorks.IO.terminal_out, "prompt_pos = " ^ Integer.makestring (!prompt_pos) ^ ", length = " ^ Integer.makestring length ^ "\n");
d634 1
a634 1
					 length - !prompt_pos)))
d637 1
a637 1
	    val _ = output(MLWorks.IO.terminal_out, "line = " ^ line ^ "\n")
d640 1
a640 1
	        Xm.Text.insert(text, length, line ^ "\n");
d649 3
a651 4
           if (!input_flag)
             then
               (input_string := line ^ "\n";
                input_flag := false)
d656 3
a658 1
	      prompt_pos := !write_pos)
d663 1
a663 2
	let val _ = output (MLWorks.IO.terminal_out, "in activate callback\n");
	    val (_, event) =
d668 1
a668 2
	      (output (MLWorks.IO.terminal_out, "calling pop_history\n");
	       pop_history ())
d670 1
a670 2
	      (output (MLWorks.IO.terminal_out, "calling do_line\n");
	       do_line())
@


1.16
log
@Moved user_options and version from interpreter to main
Added menu stuff for compatibility options
@
text
@d3 6
a8 2

$Log: _listener.sml,v $
d21 1
a21 1
 *   Added state stack and push and pop operations thereon
d43 18
a60 18
Revision 1.4  1993/03/12  11:42:44  matthew
Changed interface to shell.
Haven't tested this

Revision 1.3  1993/03/09  15:57:55  matthew
Options & Info changes
Changes for ShellData type

Revision 1.2  1993/03/04  16:40:19  daveb
Replaced mainWindow/text combination with rowColumn/scrolledText.
Scrolling now works properly.

Revision 1.1  1993/03/02  19:18:28  daveb
Initial revision


Copyright (c) 1993 Harlequin Ltd.

d78 3
d198 2
a199 1
            | strip (">"::l) = l
d205 14
a218 5
      (* first is write_pos, second is read_pos *)
      val positions as (write_pos, read_pos) = (ref 0, ref 0)

      fun insert_before_insertion_point((write_pos, read_pos), str) =
	( Xm.Text.insert(text, !write_pos, str);
d229 1
a229 1
          insert_before_insertion_point (positions, implode(rev(result)))
d370 8
a377 8
	    bool_widget("stringInequalities", #string_inequalities),
	    bool_widget("polyMakestring", #poly_makestring),
	    bool_widget("infixrAssoc", #infixr_assoc),
	    bool_widget("opInDatatype", #op_in_datatype),
	    bool_widget("njInclude", #nj_include),
	    bool_widget("njOpen", #nj_local_open),
	    bool_widget("semiColons", #semicolons),
	    bool_widget("derivedRedef", #derived_redef)
d483 5
a487 3
         x_running = true,		(* Can't start X interface from an X listener *)
         mk_xinterface_fn = mk_xinterface_fn,		(* for starting X from a saved image *)
         mk_tty_listener = TTYListener.listener	(* for starting saved images *)
d501 2
a502 2
        FileSelect.select_file (shell,
                                fn s => output(std_out,"File \"" ^ s ^ "\" selected\n"))
d575 18
a592 1
      fun activate _ =
d594 20
d616 8
a623 1
	    val (is_last, line) = getline (str, pos, length)
d640 1
a640 1
             (handler line;
d642 2
a643 1
              MLWorks.IO.flush_out outstream)
d647 19
d729 2
a730 1
      Xm.Widget.callbackAdd (text, Xm.ActivateCallback, activate);
d735 2
a736 1
      MLWorks.IO.flush_out outstream
@


1.15
log
@Changed ordof and MLWorks.String.ordof to String.ordof
Changed interface to inspector tool
@
text
@d5 4
d352 10
a361 1
            Menus.OPTSEPARATOR])
@


1.14
log
@Structure changes
Added File Selection tool
@
text
@d5 4
d93 1
a93 1
  sharing type UserOptions.user_options = ShellTypes.user_options = InspectorTool.UserOptions
d104 1
a104 2
	       ActionQueue.Incremental.Context =
               InspectorTool.Context
d106 1
a106 1
  sharing type Shell.ShellData = ShellTypes.ShellData
d215 1
a215 1
              if MLWorks.String.ordof (s,n-1) = ord"\n"
a425 18
      (* some command functions *)

      fun inspect_it _ =
        let
          val ShellTypes.SHELL_STATE{context_ref,user_options,...} =
            get_current_state()
        in
          InspectorTool.inspect (user_options,context_ref,applicationShell)
        end

      fun close_listener _ =  Xm.Widget.destroy shell

      val file_browser_fn = 
        FileSelect.select_file (shell,
                                fn s => output(std_out,"File \"" ^ s ^ "\" selected\n"))

      fun make_file_browser _ = file_browser_fn ()
        
d444 27
a470 14
      val (handler', do_prompt) =
	Shell.shell
        (ShellTypes.SHELL_DATA
         {state_stack = state_stack,
          output_fn = output_fn,
          error_info = error_info,
          name_monitor = name_monitor,
          prompter = prompter,
          debugger = debugger_function,
          exit_fn = fn _ => raise Exit,
          x_running = true,		(* Can't start X interface from an X listener *)
          mk_xinterface_fn = mk_xinterface_fn,		(* for starting X from a saved image *)
          mk_tty_listener = TTYListener.listener	(* for starting saved images *)
          })
d472 2
d476 1
a476 1
	    |   lastline n = if ordof (str, n) = ord "\n" then
d482 1
a482 1
	      if n = length orelse ordof (str, n) = ord "\n" then
d489 1
a489 1
	    val all = MLWorks.String.substring (str, start, finish - start)
@


1.13
log
@Added Options menus
@
text
@d5 3
d60 1
d76 1
a81 1
	  ShellTypes.Incremental =
d84 4
a87 2
  sharing UserOptions.Options = Ml_Debugger.ValuePrinter.Debugger_Types.Options
  sharing type UserOptions.user_options = ShellTypes.user_options
d89 2
d99 2
a100 1
	       ShellTypes.Incremental.Context =
d106 1
a106 1
    DebuggerWindow.Widget
d111 1
a111 1
  structure Incremental = ShellTypes.Incremental
d426 6
a431 1
        InspectorTool.inspect (context_ref,applicationShell)
d435 6
d593 2
a594 2
                                    fn _ => output(std_out,"No file browser yet\n"),
                                    fn _ => false),
@


1.12
log
@ Added state stack and push and pop operations thereon
@
text
@d5 3
d250 98
a550 1
        Menus.MENUSPEC
d552 7
a558 7
                        Menus.MENUSPEC [Menus.PUSH ("close",
                                                    close_listener,
                                                    fn _ => true),
                                        Menus.SEPARATOR,
                                        Menus.PUSH ("exit",
                                                    fn _ => exit_application(),
                                                    fn _ => true)],
a560 1
                       Menus.MENUSPEC
a568 1
                       Menus.MENUSPEC
a580 1
                       Menus.MENUSPEC
a591 1
                       Menus.MENUSPEC
d593 2
a594 2
                                    fn _ => output(std_out,"No options tool defined yet\n"),
                                    fn _ => false),
d596 2
a597 2
                                    fn _ => output(std_out,"No options tool defined yet\n"),
                                    fn _ => false),
d599 2
a600 2
                                    fn _ => output(std_out,"No options tool defined yet\n"),
                                    fn _ => false),
d602 2
a603 2
                                    fn _ => output(std_out,"No options tool defined yet\n"),
                                    fn _ => false),
d605 2
a606 2
                                    fn _ => output(std_out,"No options tool defined yet\n"),
                                    fn _ => false),
d608 2
a609 2
                                    fn _ => output(std_out,"No options tool defined yet\n"),
                                    fn _ => false)],
@


1.11
log
@Removed options stuff
Changed menus
Added inspector and debugger
Added pushing and popping of contexts
@
text
@d47 1
d62 1
d91 1
a91 1
  sharing type Shell.Args = ShellTypes.ShellData
d96 1
a96 1
  sharing type TTYListener.Args = ShellTypes.ListenerArgs
d112 1
a112 2
    (args as ShellTypes.LISTENER_ARGS {options_ref,
                                       context_ref,
a121 1
      (* some callback functions *)
a122 3
      fun inspect_it _ =
        InspectorTool.inspect (context_ref,applicationShell)

d133 1
d165 1
a165 80
      fun close_listener _ =  Xm.Widget.destroy shell

      val debugger_window_fn =
        DebuggerWindow.make_debugger_window(shell,"debugger")

      fun debugger_function current_module f x =
        let
          val call_debugger =
            Ml_Debugger.ml_debugger
              Ml_Debugger.TERMINAL
              (!print_method_table_ref,
               Incremental.OPTIONS{error_info = error_info,
                                   options = !options_ref,
                                   name_monitor = name_monitor,
                                   debugger = debugger_function},
               context_ref,
               current_module)
              (fn _ => output(std_out,"Debugger shell not defined yet|\n"))
        in
          MLWorks.Internal.Value.frame_call
            (fn base_frame =>
             (((MLWorks.Internal.Tracing.with_tracing
               ( fn in_value =>
                   call_debugger
                     Ml_Debugger.NO_BASE_FRAME
                     ( Ml_Debugger.TRACE in_value,
                       Ml_Debugger.NOT_POSSIBLE,
                       Ml_Debugger.NOT_POSSIBLE
                     )
               )
               f
               x)
               handle exn as Exit => raise exn
                    | exn =>
                        (Ml_Debugger.ml_debugger
                         (Ml_Debugger.WINDOWING debugger_window_fn)
                         (!print_method_table_ref,
                          Incremental.OPTIONS{error_info = error_info,
                                              options = !options_ref,
                                              name_monitor = name_monitor,
                                              debugger = debugger_function},
                          context_ref,
                          current_module)
                         (fn _ => output(std_out,"Shell not defined yet|\n"))
                         (Ml_Debugger.BASE_FRAME base_frame)
                         (Ml_Debugger.EXCEPTION exn,
                          Ml_Debugger.NOT_POSSIBLE,
                          Ml_Debugger.NOT_POSSIBLE);
                         raise Shell.DebuggerTrapped)
                         )))
        end
   
      val break_function =
        let
          val call_debugger =
            Ml_Debugger.ml_debugger 
            Ml_Debugger.TERMINAL
            (!print_method_table_ref,
             Incremental.OPTIONS{error_info = error_info,
                                 options = !options_ref,
                                 name_monitor = name_monitor,
                                 debugger = debugger_function},
             context_ref,
             "")
            (fn context' => (output(std_out,"Shell not defined yet!\n")))
        in
          MLWorks.Internal.Value.frame_call
          (fn base_frame =>
           (fn s => (call_debugger 
                     (Ml_Debugger.BASE_FRAME base_frame)
                     (Ml_Debugger.BREAK s,
                      Ml_Debugger.POSSIBLE (
                                            "Return to TopLevel by raising Interrupt",
                                            Ml_Debugger.DO_RAISE Interrupt),
                      Ml_Debugger.POSSIBLE (
                                            "Continue interrupted code",
                                            Ml_Debugger.NORMAL_RETURN
                                            ));
                     ())))
        end
d196 1
a196 1
      fun do_output s =
d211 1
a211 1
      val outstream = MLWorks.IO.outstream {output = do_output,
d215 1
a215 1
      val contexts = ref [context_ref]
d217 14
a230 11
      fun can_pop_context _ =
        case !contexts of
          [] => false
        | [_] => false
        | _ => true

      fun pop_context _ =
        case !contexts of
          [] => ()
        | [_] => ()
        | _::b => contexts := b
d232 1
a232 1
      fun push_context _ =
d234 1
a234 1
          val clist = !contexts
d236 2
a237 2
            case clist of
              (ref context::_) => contexts := (ref context) :: clist
d241 79
d322 3
a324 1
          val (context_ref::_) = !contexts
d327 1
a327 2
                 {options_ref = options_ref,
                  context_ref = context_ref,
d341 2
a342 5
         {options_ref = options_ref,
          contexts = contexts,
          print_method_table_ref = print_method_table_ref,
          output_fn = do_output,
          user_options=user_options,
a345 1
          break_function = break_function,
d420 1
a420 1
           (fn () => handler'(fn s => (output(std_out,s)),s)))
d485 1
a485 1
                                    push_context,
d488 2
a489 2
                                    pop_context,
                                    can_pop_context),
a520 1
      output (std_out, "returning from new\n");
@


1.10
log
@Menu modifications
Most of this is test code.
@
text
@d5 4
d53 2
d68 2
d86 2
a87 1
	       ShellTypes.Incremental.Context
d91 2
a92 1
  sharing type Menus.Widget = Xm.Widget
a104 1

a108 93
(*
  fun prompt_for_string applicationShell prompt =
    let
      val dialogshell =
        Xm.Widget.createPopupShell (Xm.Widget.NAME "promptDialog",
                                    Xm.Widget.Class.DialogShell,
                                    applicationShell,
                                    [])
      val bboard =
        Xm.Widget.create
        (Xm.Widget.NAME "bboard",Xm.Widget.Class.BulletinBoard,dialogshell,[])
      val text =
        Xm.Widget.createManaged
        (Xm.Widget.NAME "prompter", Xm.Widget.Class.Text, bboard,
         [])
      val flag = ref true
    in
      Xm.Widget.callbackAdd(text,
                            Xm.ActivateCallback,
                            fn _ => (flag := false;
                                     Xm.Widget.unmanage bboard));
      Xm.Widget.manage bboard;
      output(std_out,"Entering event loop..\n");
      while (!flag) do Xm.doInput ();
      Xm.Text.getString text
    end
*)

  fun create_options_dialog applicationShell =
    let
      val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME "optionsDialog",
                                              Xm.Widget.Class.DialogShell,
                                              applicationShell, [])
      val form = Xm.Widget.create (Xm.Widget.NAME "optionsForm",
                                   Xm.Widget.Class.Form,
                                   shell,[])
      val rowcolumn = Xm.Widget.createManaged (Xm.Widget.NAME "options",
                                               Xm.Widget.Class.RowColumn,
                                               form,
                                               [])
      val separator = Xm.Widget.createManaged (Xm.Widget.NAME "optionsSep",
                                               Xm.Widget.Class.Separator,
                                               form,[])
      val optionsButtons = Xm.Widget.createManaged (Xm.Widget.NAME "optionsButtons",
                                                    Xm.Widget.Class.RowColumn,
                                                    form,
                                                    [])
      val buttons_updatefn = 
        Menus.make_submenus
        (optionsButtons,
         Menus.MENUSPEC
         [Menus.PUSH ("ok",
                      fn _ => output(std_out,"Doing OK action\n"),
                      fn _ => true),
          Menus.PUSH ("quit",
                      fn _ => Xm.Widget.unmanage form,
                      fn _ => true)])
      val options_updatefn = 
        Menus.make_submenus
        (rowcolumn,
         Menus.MENUSPEC
         [Menus.TEXT ("Foo",
                      fn _ => "foo",
                      fn s => output(std_out,s ^ "\n")),
          Menus.INT ("Bar",
                     fn _ => 3,
                     fn s => ()),
          Menus.TOGGLE ("Thing",fn _ => (),fn _ => true,fn _ => false),
          Menus.TOGGLE ("AnotherThing",fn _ => (),fn _ => false,
                        (let val foo = ref true in fn _ => (foo := not (!foo); !foo) end))
          ])
    in

      Xm.Widget.valuesSet (rowcolumn,
                           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                            (Xm.BottomWidget, Xm.WIDGET separator)]);
      Xm.Widget.valuesSet (separator,
                           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                            (Xm.BottomWidget, Xm.WIDGET optionsButtons)]);
      Xm.Widget.valuesSet (optionsButtons,
                           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
      (form,options_updatefn)
    end

d123 2
a124 6
      fun make_new_listener () =
        create
        (ShellTypes.copy_listener_args args,exit_application,applicationShell)

      fun make_new_shared_listener () =
        create(args,exit_application,applicationShell)
a125 1

a142 8
      local
        val (optionswidget,updatefn) = create_options_dialog shell
      in
        fun do_options () =
          (updatefn ();
           Xm.Widget.manage optionswidget)
      end

d167 1
a167 2
      fun close_listener _ =
        Xm.Widget.destroy shell
d169 3
d188 1
a188 1
             ((MLWorks.Internal.Tracing.with_tracing
d198 1
a198 2
               x
   		(*
d201 16
a216 13
                      (Ml_Debugger.ml_debugger
                        (Ml_Debugger.WINDOWING window_fn)
                        error_info,
                        (print_options', a, b,current_module)
                        (fn _ => output(std_out,"Shell not defined yet|\n"))
                        (Ml_Debugger.BASE_FRAME base_frame)
                        (Ml_Debugger.EXCEPTION exn,
                         Ml_Debugger.NOT_POSSIBLE,
                         Ml_Debugger.NOT_POSSIBLE);
                       raise DebuggerTrapped
                      )
   		*)
   	    )))
d219 28
a246 3
(*
        (DebuggerWindow.make_debugger_window(shell,"debugger"))
*)
d296 40
d340 1
a340 1
          context_ref = context_ref,
d347 1
a354 5
      fun handler s =
        MLWorks.IO.with_standard_output
	  outstream
	  (fn () => handler'(fn s => (output(std_out,s)),s))

d375 50
a424 1
      fun activate () =
d440 8
a447 7
	   output (std_out, "Callback activated\n");
	   output (std_out, "pos = " ^ Integer.makestring pos ^ "\n");
	   output (std_out, line);
           output (std_out, "\n");
	   handler line;
           output(outstream,do_prompt());
	   MLWorks.IO.flush_out outstream
d451 66
a516 23
(*
      val fileButton =
        Xm.Widget.createManaged (Xm.Widget.NAME "file", 
				 Xm.Widget.Class.CascadeButton,
				 menuBar, [])

      val fileMenu =
        Xm.Widget.createPulldownMenu (menuBar, Xm.Widget.NAME "fileMenu", [])

      val saveButton =
        Xm.Widget.createManaged (Xm.Widget.NAME "save",
				 Xm.Widget.Class.PushButton,
				 fileMenu, [])
*)

(*
      fun prompt_cb _ =
        let val result = prompt_for_string applicationShell ""
        in
          output(std_out,result ^ "\n")
        end
*)
        
d518 1
a518 47
(*
      Xm.Widget.valuesSet (fileButton, [(Xm.SubMenuId, Xm.WIDGET fileMenu)]);
*)
      Menus.make_submenus (menuBar,
                           Menus.MENUSPEC
                           [Menus.CASCADE ("file",
                                           Menus.MENUSPEC [Menus.PUSH ("Close",
                                                                       close_listener,
                                                                       fn _ => true),
                                                           Menus.PUSH ("Save",
                                                                       fn () => output(std_out,"Saving..\n"),
                                                                       fn _ => false),
                                                           Menus.PUSH ("Compile",
                                                                       fn () => output(std_out,"Compiling..\n"),
                                                                       fn _ => false),
                                                           Menus.SEPARATOR,
                                                           Menus.PUSH ("Exit",
                                                                       exit_application,
                                                                       fn _ => true)],
                                           fn _ => true),
                           Menus.CASCADE ("New",
                                          Menus.MENUSPEC [Menus.PUSH ("Listener",
                                                                      make_new_listener,
                                                                      fn _ => true),
                                                          Menus.PUSH ("Shared Context Listener",
                                                                      make_new_shared_listener,
                                                                      fn _ => true)],
                                          fn _ => true),
                           Menus.CASCADE ("options",
                                          Menus.MENUSPEC
                                          [Menus.CASCADE ("more options",
                                                          Menus.MENUSPEC
                                                          [Menus.LABEL "Menu3",
                                                           (* Menus.ARROW ("arrow",fn _ => ()), *)
                                                           Menus.CASCADE ("Foo",
                                                                          Menus.MENUSPEC
                                                                          [Menus.TOGGLE("Subfoo",
                                                                                        do_options,
                                                                                        fn _ => true,
                                                                                        fn _ => true)],
                                                                          fn _ => false),
                                                           Menus.SEPARATOR,
                                                           Menus.PUSH ("Bar",
                                                                       do_options,
                                                                       fn _ => true)],
                                                          fn _ => true)],
                                          fn _ => true)]);
@


1.9
log
@Added create_new_listener function
Added output_fn field to shell_data
@
text
@d5 4
d100 93
d194 9
a202 8
    (ShellTypes.LISTENER_ARGS {options_ref,
                               context_ref,
                               print_method_table_ref,
                               user_options,
                               error_info,
                               name_monitor,
                               prompter,
                               mk_xinterface_fn},
d205 1
d209 5
a213 10
        (ShellTypes.LISTENER_ARGS
         {options_ref = ref (!options_ref),
          context_ref = ref (!context_ref),
          print_method_table_ref = ref (!print_method_table_ref),
          user_options = UserOptions.make_user_options (!options_ref),
          error_info = error_info,
          name_monitor = name_monitor,
          prompter = prompter,
          mk_xinterface_fn = mk_xinterface_fn},
         applicationShell)
d232 8
d264 3
d447 9
a459 1

d463 14
a476 4
                                           Menus.MENUSPEC [Menus.SIMPLE ("save",
                                                                         fn () => output(std_out,"Saving..\n")),
                                                           Menus.SIMPLE ("compile",
                                                                         fn () => output(std_out,"Compiling..\n"))]),
d478 7
a484 2
                                          Menus.MENUSPEC [Menus.SIMPLE ("Listener",
                                                                        make_new_listener)]),
d489 9
a497 2
                                                          [Menus.SIMPLE ("foo",
                                                                         fn () => output (std_out,"Foo\n")),
d499 5
a503 4
                                                           Menus.SIMPLE ("bar",
                                                                         fn () => output (std_out,"Bar\n"))])])]);

                                                       
@


1.8
log
@Add newline when using earlier line
@
text
@d5 3
d39 1
d51 1
d63 3
d87 1
a87 1
  type UserOptions = ShellTypes.user_options
d107 14
a206 16
      val (handler', do_prompt) =
	Shell.shell
        (ShellTypes.SHELL_DATA
         {options_ref = options_ref,
          context_ref = context_ref,
          print_method_table_ref = print_method_table_ref,
          user_options=user_options,
          error_info = error_info,
          name_monitor = name_monitor,
          prompter = prompter,
          debugger = debugger_function,
          exit_fn = fn _ => raise Exit,
          x_running = true,		(* Can't start X interface from an X listener *)
          mk_xinterface_fn = mk_xinterface_fn,		(* for starting X from a saved image *)
          mk_tty_listener = TTYListener.listener	(* for starting saved images *)
          })
d259 18
d354 3
@


1.7
log
@Used Menus utilities to make menubar menus
@
text
@d5 3
d285 2
a286 2
	        Xm.Text.insert(text, length, line);
	        length + size line
@


1.6
log
@Simplified ShellTypes types
@
text
@d5 3
d38 1
d49 1
d67 2
d301 1
d314 1
d316 1
d318 20
@


1.5
log
@Fixed problems with prompt and resizing.
@
text
@d5 3
d60 1
a60 2
  sharing type Shell.Args =
	       ShellTypes.ShellArgs
d62 1
a62 2
  sharing type TTYListener.Args =
	       ShellTypes.ListenerArgs
d72 1
a72 1
  type ShellData = ShellTypes.ShellData
d79 9
a87 10
    (shell_data as ShellTypes.SHELL_DATA{options_ref,
                                         context_ref,
                                         print_method_table_ref,
                                         user_options,
                                         error_info,
                                         name_monitor,
                                         debugger,
                                         prompter},
     applicationShell,
     xinterface) =
d135 6
a140 3
              (ShellTypes.get_current_print_method_table shell_data,
               ShellTypes.make_incremental_options shell_data,
               ShellTypes.get_context_ref shell_data,
d142 1
a142 1
              (fn _ => output(std_out,"Shell not defined yet|\n"))
d177 14
a190 16
          (ShellTypes.SHELL_ARGS
           (ShellTypes.SHELL_DATA
            {options_ref = options_ref,
             context_ref = context_ref,
             print_method_table_ref = print_method_table_ref,
             user_options=user_options,
             error_info = error_info,
             name_monitor = name_monitor,
             debugger = debugger_function,
             prompter = prompter},
            fn _ => raise Exit,
            true,		(* Can't start X interface from an X listener *)
            xinterface,		(* for starting X from a saved image *)
            TTYListener.listener	(* for starting saved images *)
            ))

@


1.4
log
@Changed interface to shell.
Haven't tested this
@
text
@d5 4
d108 1
a108 1
				 Xm.Widget.Class.RowColumn,
d112 7
a118 3
        Xm.Widget.createManaged (Xm.Widget.NAME "menuBar",
				 Xm.Widget.Class.RowColumn,
				 mainWindow, [])
d121 8
a128 1
        Xm.Widget.createScrolledText (mainWindow, Xm.Widget.NAME "text", [])
a171 1
      (* ignore most of this for now *)
d243 3
a245 1
        MLWorks.IO.with_standard_output outstream (fn () => handler'(fn s => (output(std_out,s)),s))
d274 2
a275 2
	        Xm.Text.insert(text, length, "\n" ^ line);
	        length + size line + 1
d288 2
a289 1
           output(outstream,do_prompt())
d312 2
a313 1
      output(outstream,do_prompt())
@


1.3
log
@Options & Info changes
Changes for ShellData type
@
text
@d5 4
d74 3
a76 3
    (shell_data as ShellTypes.SHELL_DATA{options_ref = ref options,
                                         context_ref = ref context,
                                         print_method_table_ref = ref print_method_table,
d115 1
a115 1
      fun debugger_function (a,b,current_module) f x =
d158 1
a158 1
      val (handler', reset_prompt) =
d162 3
a164 3
            {options_ref = ref options,
             context_ref = ref context,
             print_method_table_ref = ref print_method_table,
d229 1
a229 1
        MLWorks.IO.with_standard_output outstream (fn () => handler' s)
d271 2
a272 5
	   let val result = handler line
	   in
	     Xm.Text.insert(text, !write_pos, result);
	     Xm.Text.setInsertionPosition (text, !write_pos + size result)
	   end
d294 2
a295 1
      output (std_out, "returning from new\n")
@


1.2
log
@Replaced mainWindow/text combination with rowColumn/scrolledText.
Scrolling now works properly.
@
text
@d5 4
d39 6
a44 3
  sharing type ActionQueue.printer_descriptor =
	       ShellTypes.printer_descriptor =
	       Ml_Debugger.ValuePrinter.printer_descriptor
d47 1
a47 1
	       ShellTypes.Incremental.context
d59 1
a59 1
  type Context = Incremental.context
d61 3
a63 1
  type PrinterDescriptor = ShellTypes.printer_descriptor
d69 11
a79 2
  fun create (user_options, print_options, shell_options,
	      info_options, context, prompter, applicationShell, xinterface) =
d116 4
a119 2
              info_options
              (print_options, a, b, current_module)
d140 1
a140 1
                        info_opts'
a152 7
      fun copy_options (Incremental.OPTIONS x) =
           Incremental.OPTIONS {
   	  compiler_options = #compiler_options x,
             make_options = #make_options x,
             debugger = debugger_function
   	}
   
d155 17
a171 12
	Shell.shell (
	  context,
	  ShellTypes.SHELL_ARGS (
	    prompter,
	    copy_options shell_options,
	    print_options,
	    user_options,
	    fn _ => raise Exit,
	    true,		(* Can't start X interface from an X listener *)
	    xinterface,		(* for starting X from a saved image *)
	    TTYListener.listener	(* for starting saved images *)
	  ))
@


1.1
log
@Initial revision
@
text
@d4 3
a6 1
$Log$
d8 1
d74 1
a74 1
        Xm.Widget.createPopupShell (Xm.Widget.NAME "buffer",
d81 2
a82 2
        Xm.Widget.createManaged (Xm.Widget.NAME "mainWindow",
				 Xm.Widget.Class.MainWindow,
d85 5
d91 28
a118 30
        Xm.Widget.createManaged (Xm.Widget.NAME "text",
                                 Xm.Widget.Class.Text,
                                 mainWindow, [])

         fun debugger_function (a,b,current_module) f x =
           let
             val call_debugger =
               Ml_Debugger.ml_debugger
               Ml_Debugger.TERMINAL
               info_options
               (print_options, a, b, current_module)
               (fn _ => output(std_out,"Shell not defined yet|\n"))
           in
             MLWorks.Internal.Value.frame_call
             (fn base_frame =>
              ((MLWorks.Internal.Tracing.with_tracing
                ( fn in_value =>
                    call_debugger
                      Ml_Debugger.NO_BASE_FRAME
                      ( Ml_Debugger.TRACE in_value,
                        Ml_Debugger.NOT_POSSIBLE,
                        Ml_Debugger.NOT_POSSIBLE
                      )
                )
                f
                x
		(*
                handle exn as Exit => raise exn
                     | exn =>
                       (Ml_Debugger.ml_debugger
d127 13
a139 13
                        raise DebuggerTrapped
                       )
		*)
		)))
           end

         fun copy_options (Incremental.OPTIONS x) =
           Incremental.OPTIONS
           {compiler_options = #compiler_options x,
            make_options = #make_options x,
            debugger = debugger_function
           }

a256 5
      val menuBar =
        Xm.Widget.createManaged (Xm.Widget.NAME "menuBar",
				 Xm.Widget.Class.RowColumn,
				 mainWindow, [])

a270 2
      Xm.Widget.valuesSet (mainWindow, [(Xm.WorkWindow, Xm.WIDGET text),
                                        (Xm.MenuBar, Xm.WIDGET menuBar)]);
d272 2
a274 1
      Xm.Widget.manage shell;
@
