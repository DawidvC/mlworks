head	1.59;
access;
symbols
	ML_beta_release_12/08/94:1.17
	ML_beta_release_03/08/94:1.14;
locks; strict;
comment	@ * @;


1.59
date	95.07.13.11.16.33;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	95.07.07.15.25.24;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	95.07.04.15.10.41;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	95.07.04.10.28.39;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	95.06.30.09.30.11;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	95.06.19.14.17.40;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	95.06.16.10.31.38;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	95.06.15.15.58.15;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	95.06.15.13.14.52;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	95.06.14.13.54.17;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	95.06.12.15.03.07;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	95.06.06.14.17.17;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	95.06.05.13.55.26;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	95.06.05.13.10.54;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	95.06.01.11.37.21;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	95.05.23.14.09.44;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	95.05.23.08.57.23;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.05.16.09.46.35;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	95.05.04.09.46.13;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	95.04.28.16.58.40;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	95.04.24.14.21.52;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	95.04.19.10.57.28;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	95.04.13.11.28.08;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	95.04.06.15.47.21;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	95.03.31.14.51.04;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	95.03.31.13.35.26;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	95.03.30.13.49.36;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	95.03.17.12.27.36;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	95.03.16.15.49.09;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	95.03.15.17.42.31;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	95.03.10.17.01.42;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	95.03.06.12.29.18;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	95.03.02.13.31.24;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	95.03.01.15.14.26;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	95.02.27.14.05.44;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	95.02.20.15.31.38;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	95.02.20.14.21.11;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	95.02.16.16.49.59;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	95.02.16.15.02.45;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	95.01.13.16.17.47;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	94.11.30.18.30.21;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	94.09.21.12.29.15;	author brianm;	state Exp;
branches;
next	1.17;

1.17
date	94.08.11.11.11.06;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	94.08.11.10.53.58;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	94.08.09.12.55.02;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	94.08.02.16.55.52;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	94.08.02.09.20.37;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	94.08.01.15.16.00;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	94.07.28.11.41.39;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	94.07.28.10.24.12;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	94.07.27.14.32.52;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	94.07.19.13.20.42;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	94.07.12.16.03.57;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	94.07.11.17.51.04;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	94.07.05.19.05.23;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	94.06.30.17.39.36;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	94.06.23.10.55.32;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.06.23.10.36.04;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	94.06.21.18.50.43;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.59
log
@Removing Incremental from Ml_Debugger
@
text
@(* Replacement for Listener *)
(*
 *  $Log: _evaluator.sml,v $
 *  Revision 1.58  1995/07/07  15:25:24  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.57  1995/07/04  15:10:41  matthew
 *  Capification
 *
 *  Revision 1.56  1995/07/04  10:28:39  daveb
 *  Replaced input and output windows with a console window.
 *
 *  Revision 1.55  1995/06/30  09:30:11  daveb
 *  Replaced explicit setting of constraint resources with Layout functions.
 *
 *  Revision 1.53  1995/06/16  10:31:38  daveb
 *  Added Time button.
 *
 *  Revision 1.52  1995/06/15  15:58:15  daveb
 *  Moved code that resets state to outside the exception handlers (in
 *  the evaluate function).
 *
 *  Revision 1.51  1995/06/15  13:14:52  daveb
 *  Hid details of WINDOWING type in ml_debugger.
 *
 *  Revision 1.50  1995/06/14  13:54:17  daveb
 *  Made use of error browser depend on preferences.
 *  Type of Ml_Debugger.ml_debugger, ShellUtils.edit_* and OutputWindow.create
 *  have changed.
 *
 *  Revision 1.49  1995/06/12  15:03:07  daveb
 *  Ensured that the result strings are not overwritten by the
 *  selection mechanism.
 *
 *  Revision 1.48  1995/06/06  14:17:17  daveb
 *  Added history commands.
 *
 *  Revision 1.47  1995/06/05  13:55:26  daveb
 *  Changed sensitivity argument of view_options to SENSE_ALL, because
 *  the shell functions now set the current selection.
 *
 *  Revision 1.46  1995/06/05  13:10:54  daveb
 *  Made evaluator sensitive to current selection.  The current definition
 *  is preserved when necessary.
 *
 *  Revision 1.45  1995/06/01  11:37:21  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.44  1995/05/23  14:09:44  matthew
 *  Changing interface to list_select.
 *
 *  Revision 1.43  1995/05/23  08:57:23  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.42  1995/05/16  09:46:35  matthew
 *  Adding escape key functionality
 *
 *  Revision 1.41  1995/05/04  09:46:13  matthew
 *  Removed script from ml_debugger
 *
 *  Revision 1.40  1995/04/28  16:58:40  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.39  1995/04/24  14:21:52  daveb
 *  Added breakpoint menu.  Removed value menu.
 *
 *  Revision 1.38  1995/04/19  10:57:28  daveb
 *  Changes to context_menu.
 *
 *  Revision 1.37  1995/04/13  11:28:08  daveb
 *  Added catch for ShellTypes.DebuggerTrapped in evaluate function.
 *
 *  Revision 1.36  1995/04/06  15:47:21  daveb
 *  Input widget now takes an applicationShell argument.
 *
 *  Revision 1.35  1995/03/31  14:51:04  daveb
 *  Ensured that we always use a windowing debugger.
 *
 *  Revision 1.34  1995/03/31  13:35:26  daveb
 *  Removed unimplemented menu items.
 *
 *  Revision 1.33  1995/03/30  13:49:36  daveb
 *  Removed the history pane to the new context tool.
 *
 *  Revision 1.32  1995/03/17  12:27:36  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 * 
 *  Revision 1.31  1995/03/16  15:49:09  daveb
 *  Removed context_function from register when closing the window.
 * 
 *  Revision 1.30  1995/03/15  17:42:31  daveb
 *  Changed to share current context with other tools..
 * 
 *  Revision 1.29  1995/03/10  17:01:42  daveb
 *  Replaced "inspect" command with automatic updating of context selection.
 * 
 *  Revision 1.28  1995/03/06  12:29:18  daveb
 *  Added contexts to history info.  Also replaced evaluation sequence
 *  with ShellTypes.process_result.
 * 
 *  Revision 1.27  1995/03/02  13:31:24  matthew
 *  Changes to Parser & Lexer structures
 * 
 *  Revision 1.26  1995/03/01  15:14:26  daveb
 *  Removed redundant code.
 * 
 *  Revision 1.25  1995/02/27  14:05:44  daveb
 *  Fixed timing of call to ActionQueue.do_actions.
 * 
 *  Revision 1.24  1995/02/20  15:31:38  daveb
 *  Changed name of output pane so that resources can make it read-only.
 * 
 *  Revision 1.23  1995/02/20  14:21:11  daveb
 *  Made use update the history of the context, and regenerated the
 *  history from the context every time.
 * 
 *  Revision 1.22  1995/02/16  16:49:59  daveb
 *  Added shortcuts for the buttons.
 * 
 *  Revision 1.21  1995/02/16  15:02:45  daveb
 *  Removed the augment button, and all that depended on it.
 * 
 *  Revision 1.20  1995/01/13  16:17:47  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 * 
 *  Revision 1.19  1994/11/30  18:30:21  daveb
 *  Fixed bug in form layout code for MIPS.  Also simplified this code
 *  by replacing separator widgets with Xm.*Offset values.  Also added
 *  an initial call to Xm.Widget.processTraversal for correct
 *  behaviour on the MIPS.
 * 
 *  Revision 1.18  1994/09/21  12:29:15  brianm
 *  Adding value menu (Edit/Trace/Untrace)
 * 
 *  Revision 1.17  1994/08/11  11:11:06  daveb
 *  Ensured that accept function augmented the correct context.
 * 
 *  Revision 1.16  1994/08/11  10:53:58  daveb
 *  Added semicolons when saving history.
 * 
 *  Revision 1.15  1994/08/09  12:55:02  daveb
 *  Changed type of InterPrint.strings.  Renamed source_result to result.
 *  A minor change to how results are used.
 * 
 *  Revision 1.14  1994/08/02  16:55:52  daveb
 *  Made error browser handle edit operation correctly.
 * 
 *  Revision 1.13  1994/08/02  09:20:37  daveb
 *  Passed token_stream to Incremental.compile_source instead of a parsed
 *  topdec, thus ensuring correct error handling.  Also made errors from
 *  the action queue invoke an error browser.
 * 
 *  Revision 1.11  1994/07/28  11:41:39  daveb
 *  Corrected sensitivity of history menu items.  Removed edit and inspect
 *  entries until they actually work.
 * 
 *  Revision 1.10  1994/07/28  10:24:12  daveb
 *  Excised unimplemented parts of user-interface.
 * 
 *  Revision 1.9  1994/07/27  14:32:52  daveb
 *  Cut-down menus for novices.
 * 
 *  Revision 1.8  1994/07/19  13:20:42  daveb
 *  Corrected misnamed "print_options" to the correct "options".
 * 
 *  Revision 1.7  1994/07/12  16:03:57  daveb
 *  ToolData.works_menu takes different arguments.
 * 
 *  Revision 1.6  1994/07/11  17:51:04  daveb
 *  Made accept button insensitive when there is no current result.
 * 
 *  Revision 1.5  1994/07/05  19:05:23  daveb
 *  Added input widget.
 * 
 *  Revision 1.4  1994/06/30  17:39:36  daveb
 *  Ensured that source is saved in user contexts.  Set history from user
 *  contexts.  Added facility to save the source of the current context.
 *  Also disabled entries in Output menu as appropriate.
 * 
 *  Revision 1.3  1994/06/23  10:55:32  jont
 *  Update debugger information production
 * 
 *  Revision 1.2  1994/06/23  10:36:04  daveb
 *  Added calls to Xm.Widget.processTraversal.  Also cleared output window
 *  before evaluating.
 * 
 *  Revision 1.1  1994/06/21  18:50:43  daveb
 *  new file
 *  
 *  Copyright (c) 1994 Harlequin Ltd.
 *  
*)

require "../utils/lists";
require "../main/preferences";
require "../main/user_options";
require "../interpreter/shell";
require "../interpreter/tty_listener";
require "../interpreter/shell_utils";
require "../interpreter/action_queue";
require "../debugger/ml_debugger";
require "tooldata";
require "debugger_window";
require "menus";
require "motif_utils";
require "../library/capi";
require "console";
require "error_browser";
require "evaluator";

functor Evaluator (
  structure Lists: LISTS
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure Shell: SHELL
  structure ShellUtils : SHELL_UTILS
  structure TTYListener: TTY_LISTENER
  structure Ml_Debugger: ML_DEBUGGER
  structure ToolData : TOOL_DATA
  structure Menus : MENUS
  structure MotifUtils : MOTIF_UTILS
  structure DebuggerWindow : DEBUGGERWINDOW
  structure Capi : CAPI
  structure Console : CONSOLE
  structure ActionQueue: ACTION_QUEUE
  structure ErrorBrowser: ERROR_BROWSER

  sharing ActionQueue.Info = ShellUtils.Info

  sharing Ml_Debugger.ValuePrinter.Options = ShellUtils.Options = ToolData.ShellTypes.Options

  sharing type Preferences.user_preferences =
	       ToolData.ShellTypes.user_preferences =
	       MotifUtils.user_preferences =
	       Console.user_preferences

  sharing type MotifUtils.user_context_options =
	       ToolData.UserContext.user_context_options =
	       UserOptions.user_context_options

  sharing type ToolData.ShellTypes.user_options =
	       MotifUtils.user_tool_options = ShellUtils.UserOptions =
	       ActionQueue.UserOptions = UserOptions.user_tool_options

  sharing type Shell.Context = ShellUtils.Context = ToolData.ShellTypes.Context

  sharing type Shell.ShellData = ToolData.ShellTypes.ShellData

  sharing type ToolData.UserContext.Result = ShellUtils.Result

  sharing type Menus.Widget = Console.Widget = DebuggerWindow.Widget =
	       ToolData.Widget = MotifUtils.Widget =
	       ErrorBrowser.Widget = Console.Widget = Capi.Widget

  sharing type TTYListener.ListenerArgs = ToolData.ShellTypes.ListenerArgs
   
  sharing type Menus.ButtonSpec = MotifUtils.ButtonSpec = ToolData.ButtonSpec

  sharing type ToolData.ToolData = DebuggerWindow.ToolData

  sharing type ErrorBrowser.error = ActionQueue.Info.error

  sharing type ActionQueue.user_context = ToolData.ShellTypes.user_context =
	       MotifUtils.user_context = ShellUtils.user_context

  sharing type Preferences.preferences = ShellUtils.preferences =
               Ml_Debugger.preferences = ToolData.ShellTypes.preferences

  sharing type ErrorBrowser.location = ShellUtils.Info.Location.T

  sharing type MotifUtils.MotifContext = ToolData.MotifContext

  sharing type Ml_Debugger.debugger_window = DebuggerWindow.debugger_window
): EVALUATOR =
struct
  structure Info = ShellUtils.Info
  structure Location = Info.Location
  structure Options = ShellUtils.Options
  structure ShellTypes = ToolData.ShellTypes
  structure UserContext = ToolData.UserContext
  structure Integer = MLWorks.Integer

  type Widget = Capi.Widget
  type Context = ShellUtils.Context
  type UserOptions = ShellUtils.UserOptions

  type ToolData = ToolData.ToolData

  val evaluator_number = ref 1

  val do_debug = false
  fun debug s = if do_debug then output(MLWorks.IO.terminal_out,s ^ "\n") else ()

  fun create (tooldata as ToolData.TOOLDATA
		{args,appdata,current_context,motif_context,tools}) =
    let
      val ShellTypes.LISTENER_ARGS {user_options,
                                    user_preferences,
                                    prompter,
                                    mk_xinterface_fn,
                                    ...} = args
      val ToolData.APPLICATIONDATA {applicationShell,...} = appdata

      val (full_menus, update_fns) =
	case user_preferences
	of Preferences.USER_PREFERENCES ({full_menus, ...}, update_fns) =>
	  (!full_menus, update_fns)

      val title =
        let
          val n = !evaluator_number
        in
          evaluator_number := n+1;
          "Evaluator #" ^ Integer.makestring n
        end

      val location_title = "<"^title^">"

      (*** Make the windows ***)
      val (shell,frame,menuBar,contextLabel) =
        Capi.make_main_window ("evaluator",title,applicationShell,full_menus)

      val paned =
        Capi.make_managed_widget ("paned", Capi.Paned, frame, [])

      val inputPane =
  	Capi.make_managed_widget ("inputPane", Capi.Form, paned,[]);

      val inputTitleLabel =
  	Capi.make_managed_widget ("inputTitleLabel", Capi.Label, inputPane, [])

      val (inputScroll,inputText) = Capi.make_scrolled_text ("textIO", inputPane, [])

      val buttonPane =
  	Capi.make_managed_widget ("buttonPane", Capi.RowColumn,inputPane, []);

      val outputPane = Capi.make_managed_widget ("outputPane", Capi.Form, paned, [])

      val outputTitleLabel =
  	Capi.make_managed_widget ("outputTitleLabel", Capi.Label,outputPane, [])

      val (outputScroll,outputText) = Capi.make_scrolled_text ("resultText",outputPane, [])

      val _ = Capi.manage inputText
      val _ = Capi.manage outputText

      (*** Local Motif Context ***)

      val local_context = ref motif_context

      fun get_user_context () = MotifUtils.get_user_context (!local_context)
      fun get_context () = UserContext.get_context (get_user_context ())

      fun print_result s =
	Capi.Text.insert (outputText, Capi.Text.get_insertion_position outputText, s);

      (*** Debugger Functions ***)

      (* This creates the debugger window when the evaluator is being created *)
      (* Strange things happen if done at debugger entry time *)
      val debugger_type = 
        Ml_Debugger.WINDOWING
	  (DebuggerWindow.make_debugger_window (shell, "debugger",tooldata),
	   print_result,
	   false)

      fun get_user_options () = user_options

      fun beep _ = Capi.beep shell

      fun debugger_function f x =
        Ml_Debugger.with_start_frame
        (fn base_frame =>
         (f x)
         handle
	    exn as ShellTypes.DebuggerTrapped => raise exn
         |  exn as Shell.Exit _ => raise exn
         |  exn as Interrupt => raise exn
         |  exn as Info.Stop _ => raise exn
         |  exn as Capi.SubLoopTerminated => raise exn
         |  exn =>
           (Ml_Debugger.ml_debugger
              (debugger_type,
               ShellTypes.new_options (user_options, get_user_context ()),
               Preferences.new_preferences user_preferences)
              (base_frame,
               Ml_Debugger.EXCEPTION exn,
               Ml_Debugger.POSSIBLE
                 ("quit (return to evaluator)",
                  Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
               Ml_Debugger.NOT_POSSIBLE);
            raise ShellTypes.DebuggerTrapped))
   
      val shell_data = 
        ShellTypes.SHELL_DATA
        {get_user_context = get_user_context,
         user_options = user_options,
	 user_preferences = user_preferences,
         prompter = prompter,
         debugger = debugger_function,
         exit_fn = fn n => raise Shell.Exit n,
         x_running = true,	(* Can't start X interface from an evaluator *)
         mk_xinterface_fn = mk_xinterface_fn,
				(* for starting X from a saved image *)
         mk_tty_listener = TTYListener.listener
				(* for starting saved images *)
         }
      
      fun set_state (motif_context) =
	case contextLabel
	of MLWorks.Option.SOME w =>
          (local_context := motif_context;
           let
              val context_name = MotifUtils.get_context_name motif_context

              val cstring = "Context: " ^ context_name
            in
              Capi.set_label_string (w, cstring)
            end)
	|  MLWorks.Option.NONE => ()
              
      val _ = set_state (!local_context)

      val current_definition =
	ref MLWorks.Option.NONE: (string * string) MLWorks.Option.option ref
      (* This reference stores the current definition when the display
	 is showing something else (such as an entry on the history list).
	 If the current definition is being displayed, then this reference
	 contains NONE. *)

      val current_history =
        ref MLWorks.Option.NONE: int MLWorks.Option.option ref
      (* This reference stores the index of the current item in the history.
	 It is set by the history commands and by setting the selection. *)

      fun show_current _ =
	case !current_definition
	of MLWorks.Option.SOME (src, res) =>
	  (* Restore saved definition *)
	  (Capi.Text.set_string (inputText, src);
	   Capi.Text.set_string (outputText, res);
	   current_definition := MLWorks.Option.NONE;
	   current_history := MLWorks.Option.NONE)
	|  MLWorks.Option.NONE =>
	  current_history := MLWorks.Option.NONE
	
      fun prev_hist () =
	case !current_history
	of MLWorks.Option.NONE =>
	  (current_definition :=
	     MLWorks.Option.SOME
	       (Capi.Text.get_string inputText, Capi.Text.get_string outputText);
	   case UserContext.get_latest (get_user_context ())
	   of MLWorks.Option.NONE =>
	     current_definition := MLWorks.Option.NONE
	   |  MLWorks.Option.SOME (UserContext.ITEM (n, _, _, result, src)) =>
	     (current_history := MLWorks.Option.SOME n;
	      Capi.Text.set_string (inputText, src);
	      Capi.Text.set_string (outputText, result)))
	|  MLWorks.Option.SOME n =>
	  case UserContext.get_nth (get_user_context (), n-1)
	  of MLWorks.Option.NONE =>
	    ()
	  |  MLWorks.Option.SOME (UserContext.ITEM (_, _, _, result, src)) =>
	    (current_history := MLWorks.Option.SOME (n-1);
	     Capi.Text.set_string (inputText, src);
	     Capi.Text.set_string (outputText, result))

      fun next_hist () =
	case !current_history
	of MLWorks.Option.NONE =>
	  ()
	|  MLWorks.Option.SOME n =>
	  case UserContext.get_nth (get_user_context (), n+1)
	  of MLWorks.Option.NONE =>
	    (show_current ())
	  |  MLWorks.Option.SOME (UserContext.ITEM (_, _, _, result, src)) =>
	    (current_history := MLWorks.Option.SOME (n+1);
	     Capi.Text.set_string (inputText, src);
	     Capi.Text.set_string (outputText, result))
	    
      fun select (UserContext.ITEM (n, _, _, result, src)) =
	(case !current_definition
	 of MLWorks.Option.SOME _ => ()
	 |  MLWorks.Option.NONE =>
	   current_definition :=
	     MLWorks.Option.SOME
	       (Capi.Text.get_string inputText, Capi.Text.get_string outputText);
	 current_history := MLWorks.Option.SOME n;
	 Capi.Text.set_string (inputText, src);
	 Capi.Text.set_string (outputText, result))
	
      fun sense_select user_options =
        case UserContext.get_selected (get_user_context (), user_options)
        of MLWorks.Option.NONE => ()
        |  MLWorks.Option.SOME entry => select entry

      val context_key =
	ToolData.add_context_fn
          (current_context, (set_state, get_user_options, ToolData.WRITABLE))

      val select_key =
	UserContext.add_select_fn
	  (get_user_context (), (select, get_user_options))

      val {instream, outstream, console_widget, console_visible, show_console,
	   clear_input} =
	Console.create (shell, title, user_preferences)

      val quit_funs = ref []

      fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

      (*** IO functions ***)

      fun to_top () = Capi.Text.set_insertion_position (inputText,0)

      fun to_bottom () =
        let
          val pos = Capi.Text.get_last_position inputText
        in
	  Capi.Text.set_insertion_position (inputText, pos)
        end

      fun clear text =
	Capi.Text.set_string (text, "");

      fun message_fun s =
        Capi.send_message (shell,s)

      exception NoLocation
      fun get_location line =
        let
          val sz = size line
          fun aux index =
            if index < sz
              then
                if String.ordof(line,index) = ord ":"
                  then index+1
                else
                  aux (index+1)
            else
              raise NoLocation
          (* skip up to second ":" *)
          val result = String.substring(line,0,(aux (aux 0))-1)
        in
          result
        end
      
      val _ =
	quit_funs :=
	  (fn _ => 
	     (ToolData.remove_context_fn (current_context, context_key);
	      UserContext.remove_select_fn (get_user_context (), select_key)))
	  :: !quit_funs

      datatype Exitter = NONE | SOME of (unit -> unit)

      val exitter_ref = ref NONE

      val completion_popup = MotifUtils.list_select (shell,"completions")

      (* name completion *)
      fun do_completion start_pos =
        let
          val (line,ix) = Capi.Text.get_line_and_index (inputText,start_pos)
          val line2 = line
          val ix2 = ix - (size line - size line2)
          val subline = if ix2 > 0 then String.substring (line,0,ix2) else ""

          val Preferences.PREFERENCES
		{environment_options =
		   Preferences.ENVIRONMENT_OPTIONS {completion_menu, ...},
		 ...} =
            ShellTypes.get_current_preferences shell_data

          val options = ShellTypes.get_current_options shell_data

          val (sofar,completions) = 
            ShellUtils.get_completions
	      (subline, options, get_context ())

          fun insert_fun a =
	    ( Capi.Text.insert
		(inputText, start_pos,
		 String.substring (a, size sofar, size a - size sofar));
	      Capi.Text.set_insertion_position
		(inputText, start_pos + size a - size sofar))
        in
          case completions of
            [] => beep ()
          | [a] => insert_fun a
          | l => 
              let val c = ShellUtils.find_common_completion l 
              in
                if c = sofar then
                  if (!completion_menu) then
                    exitter_ref :=
		      SOME (completion_popup (l,insert_fun, fn x => x))
                  else beep ()
                else insert_fun c
              end
        end

      fun error_handler
	    (error, error_list, header, preferences_fn, redo_action) =
        let
          fun edit_action location =
             ShellUtils.edit_source (location, preferences_fn())

          val Preferences.PREFERENCES
		{environment_options =
		   Preferences.ENVIRONMENT_OPTIONS {use_error_browser, ...},
		 ...} =
	    preferences_fn ()

	  fun show_full_message (Info.ERROR(_,_,message)) =
	    print_result message
        in
	  if !use_error_browser then
            ErrorBrowser.create
              {parent = applicationShell,
	       errors = rev error_list,
	       action_message = header,
	       file_message = "Error in: " ^ location_title,
	       edit_action = edit_action,
               redo_action = redo_action}
	  else
	    Lists.iterate show_full_message error_list
        end

      val UserOptions.USER_TOOL_OPTIONS ({sense_selection, ...}, _) =
	user_options

      fun with_sense_selection b f x =
	let val old = ref (!sense_selection)
	in
	  sense_selection := b;
	  f x
	  handle e => (sense_selection := !old; raise e);
	  sense_selection := !old
	end

      val error_info = Info.default_options

      fun compile src =
        let
          (* compile the source in the parsing context *)
          val result = ShellUtils.compile_string error_info (src,location_title,get_user_context,user_options,debugger_function)
	  val _ =
	    with_sense_selection
	      false
	      UserContext.process_result
	      (src, result, get_user_context (),
               ShellTypes.get_current_options shell_data, user_options,
	       print_result);
        in
          ActionQueue.do_actions
            (get_user_context (),
             ShellTypes.get_user_options shell_data,
             debugger_function,
	     print_result,
             fn s => output (std_out, "Make: compiling " ^ s))
 	end

      fun handler s =
        MLWorks.IO.with_standard_input
          instream
	  (fn () =>
             MLWorks.IO.with_standard_output
               outstream
               (fn () =>
                  Ml_Debugger.with_debugger_type
                    debugger_type
                    (fn _ => 
                       ShellTypes.with_toplevel_name location_title
                       (fn _ =>
			  ShellTypes.with_shell_data shell_data
			     (fn _ => (compile s;
				       MLWorks.IO.flush_out std_out))))))

      (* The following functions change the state during the evaluation of
	 an expression.  All the buttons are made insensitive and the cursor
	 is changed to a busy cursor.  The in_evaluation flag is set; this
	 is tested in the evaluate function to prevent further evaluations
	 being started from this tool if one evaluation enters a recursive
	 input loop. *)
      val in_evaluation = ref false

      fun buttons_sensitive () = not (!in_evaluation)

      val buttons_update_fn_ref = ref (fn () => ())
      fun buttons_update_fn () = (!buttons_update_fn_ref) ()

      fun set_evaluation () =
	(in_evaluation := true;
         buttons_update_fn ();
	 Capi.set_busy shell)

      fun unset_evaluation () =
	(in_evaluation := false;
         buttons_update_fn();
	 Capi.unset_busy shell)

      (* The parameter is an internal mlval.  It is not used, except as the
	 argument of the recursive calls. *)
      fun evaluate x =
	if !in_evaluation then
	  ()
	else
	  (clear outputText;
	   clear_input ();
	   set_evaluation ();
	   Capi.set_focus inputText;
	   handler (Capi.Text.get_string inputText)
	   handle
	     ActionQueue.Error(message, error, error_list) =>
	        error_handler
                  (error, error_list, "Evaluate",
                   fn () => ShellTypes.get_current_preferences shell_data,
                   fn () => evaluate x)
           | ActionQueue.Handled => ()
	   | ShellTypes.DebuggerTrapped => ()
	   | Info.Stop (error,error_list) =>
              error_handler 
                (error, error_list, "Evaluate",
                 fn () => ShellTypes.get_current_preferences shell_data,
                 fn () => evaluate x);
	   current_definition := MLWorks.Option.NONE;
	   current_history := MLWorks.Option.NONE;
	   unset_evaluation ())

      fun time_eval x =
	let
	  val start = MLWorks.Time.Elapsed.elapsed ()

	  fun print_time () =
	    let
	      val elapsed = MLWorks.Time.Elapsed.elapsed_since start
	    in
	      print_result (MLWorks.Time.Elapsed.format elapsed ^ "\n")
	    end

	  val result =
	    evaluate x
	    handle
	      exn => (print_time (); raise exn)
	in
	  print_time ();
	  result
	end

      fun select_state motif_context =
        (set_state motif_context;
	 ToolData.set_current
	   (current_context, context_key, user_options, motif_context))

      fun start_of_line () =
        let
	  val pos = Capi.Text.get_insertion_position inputText
          val new_pos = Capi.Text.current_line (inputText,pos)
        in
          Capi.Text.set_insertion_position (inputText,new_pos)
        end
          
      val escape_pressed = ref false

      fun do_escape () = escape_pressed := true

      fun despatch_key bindings key =
        let
          fun loop [] = (debug key; beep ())
            | loop ((key',action)::rest) =
              if key = key' then action ()
              else loop rest
        in
          loop bindings
        end

      val meta_bindings =
        [("w", fn _ => MotifUtils.copySelection inputText),
         ("p", fn _ => prev_hist ()),
         ("n", fn _ => next_hist ())]

      val normal_bindings =
        [("\173", evaluate), 	(* control-return *)
         ("\159", fn _ => (clear inputText; clear outputText)),
		  		(* control-delete *)
         ("\^A",  start_of_line),
         ("\^W",  fn _ => MotifUtils.cutSelection inputText),
         ("\^Y",  fn _ => MotifUtils.pasteSelection inputText)]

      val despatch_meta = despatch_key meta_bindings
      val despatch_normal = despatch_key normal_bindings

      fun activate callback_data =
	let 
          val event = Capi.Callback.get_event callback_data
        in
          case Capi.Event.get_key_data event of
            MLWorks.Option.SOME (key,modifiers) =>
              if Lists.member (Capi.Event.meta_modifier, modifiers)
                then despatch_meta key
              else despatch_normal key
          | _ => (debug("activate: non-key event");
                  beep ())
        end
        handle Shell.Exit _ => Capi.destroy shell

      fun handle_key str =
        despatch_meta str

      fun modifyVerify callback_data =
        let
          val _ =
            case !exitter_ref of
              NONE => ()
            | SOME f => (f(); exitter_ref := NONE)

          val (event,start_pos,end_pos,str,set_fn) =
            Capi.Callback.convert_verify_data callback_data
        in
          if !escape_pressed andalso size str = 1 
            then 
              (escape_pressed := false;
               set_fn false;
               handle_key str)
          else if str = "\t"
            then
              (do_completion start_pos;
               set_fn false)
          else
             set_fn true
        end
	handle Shell.Exit _ => Capi.destroy shell

      fun mk_tooldata () =
	ToolData.TOOLDATA {args = ShellTypes.get_listener_args shell_data,
			   appdata = appdata,
			   current_context = current_context,
			   motif_context = !local_context,
                           tools = tools}

      fun get_user_options () = user_options

      fun close_window _ =
	(do_quit_funs ();
	 Capi.destroy shell)

      val view_options =
	MotifUtils.view_options
	  {parent = shell, title = title, user_options = user_options,
	   user_preferences = user_preferences,
	   caller_update_fn = sense_select,
	   sensitivity = MotifUtils.SENSE_ALL,
	   view_type = MotifUtils.VIEW_ALL}

      val view_menu =
	Menus.CASCADE
	  ("view",
	   view_options
	   @@ [Menus.TOGGLE
		("console", console_visible, show_console, fn () => true)],
	   fn _ => true)

      val menuspec =
        [ToolData.works_menu
	  (mk_tooldata, close_window, fn _ => true, get_user_context),
	 view_menu,
	 MotifUtils.breakpoints_menu shell,
	 MotifUtils.context_menu
	   {set_state = select_state,
	    get_context = fn _ => !local_context,
	    writable = MotifUtils.WRITABLE,
	    applicationShell = applicationShell,
	    user_preferences = user_preferences}]

      val sep_size = 10
    in
      buttons_update_fn_ref :=
      Menus.make_submenus
      (buttonPane,
       [Menus.PUSH ("evaluateButton",
                    evaluate,
                    buttons_sensitive),                    
        Menus.PUSH ("clearButton",
                    fn _ => (clear inputText; clear outputText;
                             Capi.set_focus inputText),
                    buttons_sensitive),
        Menus.PUSH ("currentButton",
                    fn _ => (show_current ();
                             Capi.set_focus inputText),
                    buttons_sensitive),
        Menus.PUSH ("prevButton",
                    fn _ => (prev_hist ();
                             Capi.set_focus inputText),
                    buttons_sensitive),
        Menus.PUSH ("nextButton",
                    fn _ => (next_hist ();
                             Capi.set_focus inputText),
                    buttons_sensitive),
        Menus.PUSH ("timeButton",
                    fn _ => (time_eval ();
                             Capi.set_focus inputText),
                    buttons_sensitive)]);
      Menus.make_submenus (menuBar,menuspec);
      case contextLabel
      of MLWorks.Option.SOME w =>
        Capi.Layout.lay_out
	  [Capi.Layout.MENUBAR menuBar,
	   Capi.Layout.OTHER w,
	   Capi.Layout.PANED paned]
      |  MLWorks.Option.NONE => 
        Capi.Layout.lay_out
	  [Capi.Layout.MENUBAR menuBar,
	   Capi.Layout.SPACE,
	   Capi.Layout.PANED paned];
      Capi.Layout.lay_out
	[Capi.Layout.OTHER inputTitleLabel,
	 Capi.Layout.TEXT inputScroll,
	 Capi.Layout.SPACE,
	 Capi.Layout.OTHER buttonPane];
      Capi.Layout.lay_out
	[Capi.Layout.OTHER outputTitleLabel,
	 Capi.Layout.TEXT outputScroll,
	 Capi.Layout.SPACE];
      Capi.Callback.add (inputText, Capi.Callback.Activate, activate);
      Capi.Callback.add (inputText, Capi.Callback.ModifyVerify, modifyVerify);
      Capi.Callback.add (shell, Capi.Callback.Destroy,do_quit_funs);
      Capi.manage shell;
      Capi.realize shell;
      Capi.set_focus inputText;
      Capi.realize console_widget
    end
end;
@


1.58
log
@Minor changes to layout.
@
text
@d4 3
a201 1
require "../parser/parser";
a224 1
  structure Parser : PARSER
d228 1
a228 2
  sharing Parser.Lexer.Info = ActionQueue.Info =
	  Ml_Debugger.Incremental.InterMake.Compiler.Info
d230 1
a230 2
  sharing Ml_Debugger.ValuePrinter.Options =
	  ShellUtils.Options = ToolData.ShellTypes.Options
d245 1
a245 2
  sharing type Shell.Context = ShellUtils.Context =
               ToolData.ShellTypes.Context = Ml_Debugger.Incremental.Context
d249 1
a249 3
  sharing type ToolData.UserContext.Result = Ml_Debugger.Incremental.Result

  sharing type ShellUtils.Options.options = Parser.Lexer.Options
d264 1
a264 7
	       MotifUtils.user_context

  sharing type ToolData.UserContext.identifier =
	       Ml_Debugger.Incremental.InterMake.Compiler.identifier

  sharing type Ml_Debugger.Incremental.Datatypes.NewMap.T =
	       ToolData.UserContext.map
a268 3
  sharing type Ml_Debugger.Incremental.InterMake.Compiler.tokenstream =
	       Parser.Lexer.TokenStream

d276 1
a276 4
  structure Incremental = Ml_Debugger.Incremental
  structure Compiler = Incremental.InterMake.Compiler
  structure Lexer = Parser.Lexer
  structure Info = Incremental.InterMake.Compiler.Info
a280 1
  structure Map = Ml_Debugger.Incremental.Datatypes.NewMap
d284 1
a284 1
  type Context = Incremental.Context
a513 2
      val error_info = Info.default_options

d644 2
a647 9
          val input_function =
            let val buff = ref src
            in
              fn _ => (let val out = !buff in buff := ""; out end)
            end
              
          val token_stream =
	    Lexer.mkTokenStream (input_function, location_title)

d649 1
a649 10
          val result =
            Incremental.compile_source
              error_info
	      (Incremental.OPTIONS
		 {options =
		    ShellTypes.new_options (user_options, get_user_context ()),
		  debugger=debugger_function},
	       get_context (),
	       Compiler.TOKENSTREAM token_stream)

@


1.57
log
@Capification
@
text
@d4 3
d341 1
a341 1
        Capi.make_managed_widget ("paned", Capi.Pane, frame, [])
d959 1
a959 2
	[Capi.Layout.SPACE,
	 Capi.Layout.OTHER outputTitleLabel,
@


1.56
log
@Replaced input and output windows with a console window.
@
text
@d4 3
a187 1
require "../library/xm";
a206 1
  structure Xm: XM
d228 1
a228 2
	  ShellUtils.Options = ToolData.ShellTypes.Options =
	  MotifUtils.Options
d252 1
a252 1
  sharing type Menus.Widget = Xm.Widget = DebuggerWindow.Widget =
d297 1
a297 1
  type Widget = Xm.Widget
d334 2
a335 10
      val shell =
        Xm.Widget.create
        (Xm.Widget.NAME "evaluatorShell",
         Xm.Widget.Class.TopLevelShell,
         applicationShell,
         [(Xm.Title, Xm.STRING title), (Xm.IconName, Xm.STRING title)])

      val frame =
        Xm.Widget.createManaged
	  (Xm.Widget.NAME "main", Xm.Widget.Class.Form, shell, [])
d338 1
a338 15
        Xm.Widget.createManaged
          (Xm.Widget.NAME "paned", Xm.Widget.Class.PanedWindow, frame, [])

      val menuBar =
        Xm.Widget.createManaged
	  (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, frame, [])

      val contextLabel =
	if full_menus then
	  MLWorks.Option.SOME
	    (Xm.Widget.createManaged
               (Xm.Widget.NAME "contextLabel",
		Xm.Widget.Class.Label, frame, []))
	else
	  MLWorks.Option.NONE
d341 1
a341 3
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "inputPane", Xm.Widget.Class.Form, paned,
	   [(Xm.Packing, Xm.PACKING Xm.PACK_NONE)]);
d344 1
a344 3
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "inputTitleLabel", Xm.Widget.Class.Label,
	   inputPane, [])
d346 1
a346 2
      val inputText =
        Xm.Widget.createScrolledText (inputPane, Xm.Widget.NAME "textIO", [])
d349 1
a349 37
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "buttonPane", Xm.Widget.Class.RowColumn,
	   inputPane, []);

      val evaluateButton =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "evaluateButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

      val clearButton =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "clearButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

      val currentButton =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "currentButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

      val prevButton =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "prevButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

      val nextButton =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "nextButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

      val timeButton =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "timeButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

      val outputPane =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "outputPane", Xm.Widget.Class.Form, paned, [])
d351 2
d354 1
a354 3
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "outputTitleLabel", Xm.Widget.Class.Label,
	   outputPane, [])
d356 1
a356 2
      val outputText =
        Xm.Widget.createScrolledText (outputPane, Xm.Widget.NAME "resultText", [])
d358 2
a359 2
      val _ = Xm.Widget.manage inputText
      val _ = Xm.Widget.manage outputText
d369 1
a369 1
	Xm.Text.insert (outputText, Xm.Text.getInsertionPosition outputText, s);
d383 1
a383 1
      fun beep _ = MotifUtils.beep shell
d394 1
a394 1
         |  exn as Xm.SubLoopTerminated => raise exn
d430 1
a430 2
              val cstring =
	        Xm.CompoundString.createSimple("Context: " ^ context_name)
d432 1
a432 2
              Xm.Widget.valuesSet
	        (w, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
d454 2
a455 2
	  (Xm.Text.setString (inputText, src);
	   Xm.Text.setString (outputText, res);
d466 1
a466 1
	       (Xm.Text.getString inputText, Xm.Text.getString outputText);
d472 2
a473 2
	      Xm.Text.setString (inputText, src);
	      Xm.Text.setString (outputText, result)))
d480 2
a481 2
	     Xm.Text.setString (inputText, src);
	     Xm.Text.setString (outputText, result))
d493 2
a494 2
	     Xm.Text.setString (inputText, src);
	     Xm.Text.setString (outputText, result))
d502 1
a502 1
	       (Xm.Text.getString inputText, Xm.Text.getString outputText);
d504 2
a505 2
	 Xm.Text.setString (inputText, src);
	 Xm.Text.setString (outputText, result))
d532 1
a532 1
      fun to_top () = Xm.Text.setInsertionPosition (inputText,0)
d536 1
a536 1
          val pos = Xm.Text.getLastPosition inputText
d538 1
a538 1
	  Xm.Text.setInsertionPosition (inputText, pos)
d542 1
a542 1
	Xm.Text.setString (text, "");
d545 1
a545 32
        MotifUtils.send_message (shell,s)

      (* some command functions *)

      fun lastline str ~1 = 0
        | lastline str n =
          if String.ordof (str, n) = ord "\n"
            then n+1
          else lastline str (n-1)

      fun get_line_and_index (text,pos) =
	let
          val str = Xm.Text.getString text
          val length = size str

          fun nextline n =
            if n = length orelse String.ordof (str, n) = ord "\n" then
              n
            else
              nextline (n+1)
          val start = lastline str (pos-1)
          val finish = nextline (pos)
          val result = String.substring (str, start, finish - start)
	in
          debug("Getline returns:" ^ result ^ ":");
          (result,pos - start)
	end

      fun current_line (text,pos) =
        lastline (Xm.Text.getString text) (pos-1)

      val getline = #1 o get_line_and_index
d582 1
a582 1
          val (line,ix) = get_line_and_index (inputText,start_pos)
d600 1
a600 1
	    ( Xm.Text.insert
d603 1
a603 1
	      Xm.Text.setInsertionPosition
d607 1
a607 1
            [] => MotifUtils.beep shell
d616 1
a616 1
                  else MotifUtils.beep shell
d722 5
d729 2
a730 7
	 Xm.Widget.valuesSet (evaluateButton, [(Xm.Sensitive, Xm.BOOL false)]);
         Xm.Widget.valuesSet (clearButton, [(Xm.Sensitive, Xm.BOOL false)]);
	 Xm.Widget.valuesSet (currentButton, [(Xm.Sensitive, Xm.BOOL false)]);
         Xm.Widget.valuesSet (prevButton, [(Xm.Sensitive, Xm.BOOL false)]);
	 Xm.Widget.valuesSet (nextButton, [(Xm.Sensitive, Xm.BOOL false)]);
         Xm.Widget.valuesSet (timeButton, [(Xm.Sensitive, Xm.BOOL false)]);
	 Xm.Widget.setBusy shell)
d734 2
a735 7
	 Xm.Widget.valuesSet (evaluateButton, [(Xm.Sensitive, Xm.BOOL true)]);
         Xm.Widget.valuesSet (clearButton, [(Xm.Sensitive, Xm.BOOL true)]);
	 Xm.Widget.valuesSet (currentButton, [(Xm.Sensitive, Xm.BOOL true)]);
         Xm.Widget.valuesSet (prevButton, [(Xm.Sensitive, Xm.BOOL true)]);
	 Xm.Widget.valuesSet (nextButton, [(Xm.Sensitive, Xm.BOOL true)]);
         Xm.Widget.valuesSet (timeButton, [(Xm.Sensitive, Xm.BOOL true)]);
	 Xm.Widget.unSetBusy shell)
d746 2
a747 2
	   Xm.Widget.processTraversal (inputText, Xm.Widget.TRAVERSE_CURRENT);
	   handler (Xm.Text.getString inputText)
d792 2
a793 2
	  val pos = Xm.Text.getInsertionPosition inputText
          val new_pos = current_line (inputText,pos)
d795 1
a795 1
          Xm.Text.setInsertionPosition (inputText,new_pos)
d830 1
a830 1
          val (_, event) = Xm.Callback.convertAny callback_data
d832 5
a836 9
          case event of
            Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key,state,...}) =>
              let
                val modifiers = Xm.Event.convertState state
              in
                case modifiers of
                  [Xm.Event.MOD1] => despatch_meta key
                | _ => despatch_normal key
              end
d840 1
a840 1
      handle Shell.Exit _ => Xm.Widget.destroy shell
d852 2
a853 2
          val (_,event,doit,_,_,start_pos,end_pos,str) =
            Xm.Callback.convertTextVerify callback_data
d858 1
a858 1
               Xm.Boolean.set (doit,false);
d863 1
a863 1
               Xm.Boolean.set (doit,false))
d865 1
a865 1
             Xm.Boolean.set (doit, true)
d867 1
a867 1
	handle Shell.Exit _ => Xm.Widget.destroy shell
d880 1
a880 1
	 Xm.Widget.destroy shell)
d912 26
d952 1
a952 1
	 Capi.Layout.TEXT (Xm.Widget.parent inputText),
d958 1
a958 1
	 Capi.Layout.TEXT (Xm.Widget.parent outputText),
d960 7
a966 39
      Xm.Widget.callbackAdd (evaluateButton, Xm.Callback.Activate, evaluate);
      Xm.Widget.callbackAdd
	(clearButton, Xm.Callback.Activate,
	 fn _ => (clear inputText; clear outputText;
	          Xm.Widget.processTraversal
		    (inputText, Xm.Widget.TRAVERSE_CURRENT);
		  ()));
      Xm.Widget.callbackAdd
	(currentButton, Xm.Callback.Activate,
	 fn _ => (show_current ();
	          Xm.Widget.processTraversal
		    (inputText, Xm.Widget.TRAVERSE_CURRENT);
		  ()));
      Xm.Widget.callbackAdd
	(prevButton, Xm.Callback.Activate,
	 fn _ => (prev_hist ();
	          Xm.Widget.processTraversal
		    (inputText, Xm.Widget.TRAVERSE_CURRENT);
		  ()));
      Xm.Widget.callbackAdd
	(nextButton, Xm.Callback.Activate,
	 fn _ => (next_hist ();
	          Xm.Widget.processTraversal
		    (inputText, Xm.Widget.TRAVERSE_CURRENT);
		  ()));
      Xm.Widget.callbackAdd
	(timeButton, Xm.Callback.Activate,
	 fn _ => (time_eval ();
	          Xm.Widget.processTraversal
		    (inputText, Xm.Widget.TRAVERSE_CURRENT);
		  ()));
      Xm.Widget.callbackAdd
	(shell, Xm.Callback.Destroy, fn _ => show_console false);
      Xm.Widget.callbackAdd (inputText, Xm.Callback.Activate, activate);
      Xm.Widget.callbackAdd (inputText, Xm.Callback.ModifyVerify, modifyVerify);
      Xm.Widget.manage shell;
      Xm.Widget.realize shell;
      Xm.Widget.processTraversal (inputText, Xm.Widget.TRAVERSE_CURRENT);
      Xm.Widget.realize console_widget
@


1.55
log
@Replaced explicit setting of constraint resources with Layout functions.
@
text
@d4 3
d200 1
a200 2
require "input";
require "output";
d218 1
a218 2
  structure InputWindow : INPUT_WINDOW
  structure OutputWindow : OUTPUT_WINDOW
d232 2
a233 1
	       MotifUtils.user_preferences 
d253 2
a254 2
	       ToolData.Widget = MotifUtils.Widget = OutputWindow.Widget =
	       ErrorBrowser.Widget = InputWindow.Widget = Capi.Widget
d273 2
a274 3
  sharing type Preferences.preferences =
               Ml_Debugger.preferences = ToolData.ShellTypes.preferences =
	       OutputWindow.preferences = ShellUtils.preferences
d586 3
a588 9
      val {instream, input_widget, input_visible,
	   show_input, clear_input} =
	InputWindow.create (shell, title, applicationShell)

      val {outstream, output_widget, output_visible, show_output} =
	OutputWindow.create
	  {parent = shell, title = title,
	   get_preferences =
	     fn () => Preferences.new_preferences user_preferences}
d846 1
d1000 2
a1001 3
	   @@ [Menus.TOGGLE ("input", input_visible, show_input, fn () => true),
	      Menus.TOGGLE
		("output", output_visible, show_output, fn () => true)],
d1071 2
a1074 1
      Xm.Widget.callbackAdd (shell, Xm.Callback.Destroy,do_quit_funs);
d1078 1
a1078 2
      Xm.Widget.realize input_widget;
      Xm.Widget.realize output_widget
@


1.54
log
@Prevented further evaluations from starting while one is in progress
(e.g. if an input loop is entered in the input tool or debugger).
@
text
@d196 1
d215 1
d252 1
a252 1
	       ErrorBrowser.Widget = InputWindow.Widget
a1023 6
      Xm.Widget.valuesSet
        (menuBar,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
d1026 19
a1044 75
        Xm.Widget.valuesSet
          (w,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)])
      |  MLWorks.Option.NONE => ();
      (* The offset 2 is to allow room for the 3D border in the parent *)
      Xm.Widget.valuesSet
        (paned,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget,
	   case contextLabel 
	   of MLWorks.Option.SOME w => Xm.WIDGET w
	   |  MLWorks.Option.NONE => Xm.WIDGET menuBar),
          (Xm.TopOffset,
	   case contextLabel 
	   of MLWorks.Option.SOME w => Xm.INT 0
	   |  MLWorks.Option.NONE => Xm.INT sep_size),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT 2),
          (Xm.RightOffset, Xm.INT 2),
	  (Xm.BottomOffset, Xm.INT sep_size),
	  (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
      Xm.Widget.valuesSet
        (inputTitleLabel,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
      Xm.Widget.valuesSet
        (Xm.Widget.parent inputText,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET inputTitleLabel),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.BottomWidget, Xm.WIDGET buttonPane),
          (Xm.BottomOffset, Xm.INT sep_size)]);
      Xm.Widget.valuesSet
        (buttonPane,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);

      Xm.Widget.valuesSet
        (outputTitleLabel,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.TopOffset, Xm.INT sep_size),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
      Xm.Widget.valuesSet
        (Xm.Widget.parent outputText,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET outputTitleLabel),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
	  (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);

@


1.53
log
@Added Time button.
@
text
@d4 3
d814 28
d845 17
a861 6
	(clear outputText;
	 Xm.Widget.processTraversal (inputText, Xm.Widget.TRAVERSE_CURRENT);
	 handler (Xm.Text.getString inputText)
	 handle
	   ActionQueue.Error(message, error, error_list) =>
	      error_handler
d864 4
a867 10
                 fn () => evaluate x)
         | ActionQueue.Handled => ()
	 | ShellTypes.DebuggerTrapped => ()
	 | Info.Stop (error,error_list) =>
            error_handler 
              (error, error_list, "Evaluate",
               fn () => ShellTypes.get_current_preferences shell_data,
               fn () => evaluate x);
	 current_definition := MLWorks.Option.NONE;
	 current_history := MLWorks.Option.NONE)
@


1.52
log
@Moved code that resets state to outside the exception handlers (in
the evaluate function).
@
text
@d4 4
d399 5
d833 20
d1091 6
@


1.51
log
@Hid details of WINDOWING type in ml_debugger.
@
text
@d4 3
a805 1
	 handler (Xm.Text.getString inputText);
d807 3
a809 4
	 current_definition := MLWorks.Option.NONE;
	 current_history := MLWorks.Option.NONE)
	handle
	  ActionQueue.Error(message, error, error_list) =>
d814 3
a816 3
        | ActionQueue.Handled => ()
	| ShellTypes.DebuggerTrapped => ()
	| Info.Stop (error,error_list) =>
d820 3
a822 1
               fn () => evaluate x)
@


1.50
log
@Made use of error browser depend on preferences.
Type of Ml_Debugger.ml_debugger, ShellUtils.edit_* and OutputWindow.create
have changed.
@
text
@d4 5
a247 2
  sharing type Ml_Debugger.ValuePrinter.Type = DebuggerWindow.Type

d269 2
d414 3
d424 1
a430 3
      fun print_result s =
	Xm.Text.insert (outputText, Xm.Text.getInsertionPosition outputText, s);

d445 1
a445 2
               Preferences.new_preferences user_preferences,
	       print_result)
@


1.49
log
@Ensured that the result strings are not overwritten by the
selection mechanism.
@
text
@d4 4
d224 1
a224 1
  sharing type Shell.Context = ShellUtils.Context = OutputWindow.Context =
d422 3
d429 19
a447 20
         handle exn as ShellTypes.DebuggerTrapped => raise exn
              | exn as Shell.Exit _ => raise exn
              | exn as Interrupt => raise exn
              | exn as Info.Stop _ => raise exn
              | exn as Xm.SubLoopTerminated => raise exn
              | exn =>
                  (Ml_Debugger.ml_debugger
                   debugger_type
                   (ShellTypes.new_options (user_options, get_user_context ()),
                    Preferences.new_preferences user_preferences,
		    get_context ())
                   (fn _ => output(std_out,
                                   "Debugger shell not defined yet\n"))
                   base_frame
                   (Ml_Debugger.EXCEPTION exn,
                    Ml_Debugger.POSSIBLE
                    ("quit (return to evaluator)",
                     Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
                    Ml_Debugger.NOT_POSSIBLE);
                   raise ShellTypes.DebuggerTrapped))
a569 1
	   get_context = get_context,
a589 3
      fun print_result s =
	Xm.Text.insert (outputText, Xm.Text.getInsertionPosition outputText, s);

d666 1
d669 1
a669 1
		   Preferences.ENVIRONMENT_OPTIONS {completion_menu,...},
d702 1
a702 2
	    (error, error_list, header, context_fn, preferences_fn,
	     redo_action) =
d705 10
a714 1
             ShellUtils.edit_source (location, context_fn(), preferences_fn())
d716 10
a725 7
          ErrorBrowser.create
            {parent = applicationShell,
	     errors = rev error_list,
	     action_message = header,
	     file_message = "Error in: " ^ location_title,
	     edit_action = edit_action,
             redo_action = redo_action}
d805 1
a805 1
                (error, error_list, "Evaluate", get_context,
d812 1
a812 1
              (error, error_list, "Evaluate", get_context,
@


1.48
log
@Added history commands.
@
text
@d4 3
d166 1
d185 1
d213 2
a214 1
	       ToolData.UserContext.user_context_options
d218 1
a218 1
	       ActionQueue.UserOptions
d714 12
d749 3
a751 1
	    UserContext.process_result
@


1.47
log
@Changed sensitivity argument of view_options to SENSE_ALL, because
the shell functions now set the current selection.
@
text
@d4 4
a161 1
require "../utils/crash";
a180 1
  structure Crash : CRASH
d367 10
d470 1
a470 1
	ref MLWorks.Option.NONE: string MLWorks.Option.option ref
d476 4
a479 12
      fun new_definition _ =
	case !current_definition
	of MLWorks.Option.SOME s =>
	  (Xm.Text.setString (inputText, s);
	   current_definition := MLWorks.Option.NONE)
	|  MLWorks.Option.NONE =>
	  ()

      fun is_current _ =
	case !current_definition
	of MLWorks.Option.SOME _ => false
	|  MLWorks.Option.NONE => true
d483 1
a483 1
	of MLWorks.Option.SOME s =>
d485 4
a488 2
	  (Xm.Text.setString (inputText, s);
	   current_definition := MLWorks.Option.NONE)
d490 27
d518 10
a527 2
	
      fun select (UserContext.ITEM (_, _, _, result, src)) =
d532 3
a534 1
	     MLWorks.Option.SOME (Xm.Text.getString inputText);
d766 2
a767 1
	 current_definition := MLWorks.Option.NONE)
d810 3
a812 1
        [("w", fn _ => MotifUtils.copySelection inputText)]
d1008 12
@


1.46
log
@Made evaluator sensitive to current selection.  The current definition
is preserved when necessary.
@
text
@d4 4
d689 2
a690 3
	      (src, result,
	       get_user_context (),
               ShellTypes.get_current_options shell_data,
d842 1
a842 1
	   sensitivity = MotifUtils.NO_SET_SELECTION,
@


1.45
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d4 3
d356 5
d380 2
a381 2
      fun get_context () =
	UserContext.get_context (MotifUtils.get_user_context (!local_context))
d408 1
a408 3
                   (ShellTypes.new_options
		      (user_options,
		       MotifUtils.get_user_context (!local_context)),
d423 1
a423 2
        {get_user_context = 
	   fn () => MotifUtils.get_user_context (!local_context),
d453 43
d500 4
a534 5
      fun add_strings [] = ()
      |   add_strings ((_, s)::t) =
	(print_result s;
	 add_strings t)

d593 3
a595 1
	  (fn _ => ToolData.remove_context_fn (current_context, context_key))
d678 1
a678 3
		    ShellTypes.new_options
		      (user_options,
		       MotifUtils.get_user_context (!local_context)),
d686 1
a686 1
	       MotifUtils.get_user_context (!local_context),
d691 1
a691 1
            (MotifUtils.get_user_context (!local_context),
d695 1
a695 3
             fn s => output (std_out, "Make: compiling " ^ s));
	  Xm.Widget.processTraversal (inputText, Xm.Widget.TRAVERSE_CURRENT);
	  ()
d714 2
a715 1
      (* The parameter doesn't seem to be used *)
d720 1
a720 1
	 ())
d766 3
a768 2
        [("\173", evaluate), (* control-return *)
         ("\159", fn _ => clear inputText), (* control-delete *)
d802 1
a802 1
            | SOME f => (f();exitter_ref := NONE)
d838 2
a839 2
	   caller_update_fn = fn _ => (),
	   sensitivity = MotifUtils.CONTEXT_ONLY,
d853 1
a853 2
	  (mk_tooldata, close_window, fn _ => true,
	   fn () => MotifUtils.get_user_context (!local_context)),
d953 6
@


1.44
log
@Changing interface to list_select.
@
text
@d4 3
a151 1
require "../main/user_options";
a171 1
  structure UserOptions : USER_OPTIONS
d190 1
a190 1
  sharing UserOptions.Options = Ml_Debugger.ValuePrinter.Options =
d194 9
a202 2
  sharing type UserOptions.user_options = ToolData.ShellTypes.user_options =
	       MotifUtils.UserOptions = ShellUtils.UserOptions =
d212 1
a212 1
  sharing type UserOptions.Options.options = Parser.Lexer.Options
d237 1
a237 1
  sharing type UserOptions.preferences = Preferences.preferences =
d245 2
d254 1
a254 1
  structure Options = UserOptions.Options
d262 1
a262 1
  type UserOptions = UserOptions.user_options
d272 1
a272 1
		{args,appdata,current_context,tools}) =
d274 2
a275 2
      val ShellTypes.LISTENER_ARGS {user_context,
                                    user_options,
d282 2
a283 2
	case user_options
	of UserOptions.USER_OPTIONS({full_menus, ...}, update_fns) =>
d368 1
a368 2
      fun null [] = true
      |   null _ = false
d370 1
a370 3
      fun beep _ = MotifUtils.beep shell

      (*** Local Context ***)
d372 2
a373 1
      val local_context = ref user_context
d386 2
d400 5
a404 3
                   (UserOptions.new_options user_options,
                    UserOptions.new_preferences user_options,
                    UserContext.get_context (!local_context))
d417 2
a418 1
        {user_context = local_context,
d420 1
d431 1
a431 1
      fun set_state (user_context) =
d434 1
a434 1
          (local_context := user_context;
d436 1
a436 1
              val context_name = UserContext.get_context_name user_context
d453 1
a453 1
	   show_input, hide_input, clear_input} =
d456 1
a456 2
      val {outstream, output_widget, output_visible,
	   show_output, hide_output} =
d459 3
a461 2
	   get_context = fn () => UserContext.get_context (!local_context),
	   get_preferences = fn () => UserOptions.new_preferences user_options}
d567 1
d569 1
d572 2
a573 1
	      (subline, options, UserContext.get_context (!local_context))
a595 2
      fun get_context () = UserContext.get_context (!local_context)

d628 4
a631 1
		 {options = UserOptions.new_options user_options,
d633 1
a633 1
               UserContext.get_context (!local_context),
d639 1
a639 1
	       !local_context,
d644 1
a644 1
            (!local_context,
d664 4
a667 1
                       (fn _ => (compile s; MLWorks.IO.flush_out std_out)))))
d689 2
a690 2
      fun select_state user_context =
        (set_state user_context;
d692 1
a692 1
	   (current_context, context_key, user_options, user_context))
d708 1
a708 1
          fun loop [] = (debug key;beep ())
d778 1
a782 4
      val (options_menu,update) =
	MotifUtils.options_menu (shell, title, get_user_options, fn _ => ())
      val _ = update_fns := update :: (!update_fns)

d787 17
d805 11
a815 20
        ToolData.works_menu
	  (mk_tooldata, close_window, fn _ => true, fn () => !local_context)
        :: Menus.CASCADE
	     ("input",
              [Menus.PUSH ("show", show_input, fn _ => not (input_visible ())),
               Menus.PUSH ("hide", hide_input, fn _ => input_visible ()),
               Menus.PUSH ("clear", fn _ => clear_input (), fn _ => true)],
              fn _ => true)
        :: Menus.CASCADE
	     ("output",
              [Menus.PUSH ("show", show_output, fn _ => not (output_visible ())),
               Menus.PUSH ("hide", hide_output, fn _ => output_visible ())],
              fn _ => true)
	:: MotifUtils.breakpoints_menu shell
	:: (if full_menus then
	      [MotifUtils.context_menu
	         (select_state, fn _ => !local_context, MotifUtils.WRITABLE),
	       options_menu]
	    else
              [options_menu])
@


1.43
log
@Made contexts only visible if full_menus set.
@
text
@d4 3
d539 2
d573 1
a573 2
		      SOME (MotifUtils.list_select
			      (shell,"completions",l,insert_fun, fn x => x))
@


1.42
log
@Adding escape key functionality
@
text
@d4 3
d268 5
d304 7
a310 2
        Xm.Widget.createManaged
        (Xm.Widget.NAME "contextLabel", Xm.Widget.Class.Label, frame, [])
d415 13
a427 10
        (local_context := user_context;
         let
            val context_name = UserContext.get_context_name user_context

            val cstring =
	      Xm.CompoundString.createSimple("Context: " ^ context_name)
          in
            Xm.Widget.valuesSet
	      (contextLabel, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
          end)
a758 1
      val UserOptions.USER_OPTIONS(_, update_fns) = user_options
d780 6
a785 3
	:: MotifUtils.context_menu
	     (select_state, fn _ => !local_context, MotifUtils.WRITABLE)
        :: [options_menu]
d796 12
a807 9
      Xm.Widget.valuesSet
        (contextLabel,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET menuBar),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
d812 8
a819 1
          (Xm.TopWidget, Xm.WIDGET contextLabel),
d859 1
@


1.41
log
@Removed script from ml_debugger
@
text
@d4 3
d242 1
a267 2
          fun p (s, 0) = s
            | p (s, n) = p (chr (48+(n mod 10)) ^ s, n div 10)
d270 1
a270 1
          "Evaluator #" ^ p ("", n)
d345 2
a564 7
	  (*
          val file_message =
            case error_location error of
              Location.UNKNOWN => ""
            | loc => "Error in: " ^ location_file loc
	  *)

d628 1
d653 56
d719 6
a724 1
          if str = "\t"
a732 39
      fun start_of_line () =
        let
	  val pos = Xm.Text.getInsertionPosition inputText
          val new_pos = current_line (inputText,pos)
        in
          Xm.Text.setInsertionPosition (inputText,new_pos)
        end
          
      fun activate callback_data =
	let val (_, event) =
	      Xm.Callback.convertAny callback_data
	in
	  case event of
	    Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\173", state, ...}) =>
		(* control-return *)
	        evaluate callback_data
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\159", state, ...}) =>
		(* control-delete *)
	        clear inputText
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "w", state, ...}) =>
	      if Xm.Event.convertState state = [Xm.Event.MOD1] then
		(* meta-n *)
                MotifUtils.copySelection inputText
	      else
		()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^A", ...}) =>
              start_of_line ()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^W", ...}) =>
              MotifUtils.cutSelection inputText
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^Y", ...}) =>
              MotifUtils.pasteSelection inputText
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key, ...}) =>
	      debug ("key press: key = " ^ MLWorks.Integer.makestring (ord key))
	  | Xm.Event.KeyRelease (Xm.Event.KEY_EVENT {key, ...}) =>
	      debug ("key release: key = " ^ MLWorks.Integer.makestring (ord key))
	  | _ => debug("activate: non-key event")
	end
	handle Shell.Exit _ => Xm.Widget.destroy shell

d787 1
d794 2
a797 1
      
@


1.40
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d4 3
d275 5
a279 5
        Xm.Widget.createPopupShell
	  (Xm.Widget.NAME "evaluatorShell",
	   Xm.Widget.Class.TopLevelShell,
           applicationShell,
           [(Xm.Title, Xm.STRING title), (Xm.IconName, Xm.STRING title)])
d380 1
a380 2
                    Ml_Debugger.NOT_POSSIBLE)
                   [];
@


1.39
log
@Added breakpoint menu.  Removed value menu.
@
text
@d4 3
d174 1
a174 1
  sharing ToolData.ShellTypes.Info = Parser.Lexer.Info =
d190 1
a190 1
  sharing type ToolData.ShellTypes.Result = Ml_Debugger.Incremental.Result
d206 1
a206 5
  sharing type ToolData.ShellTypes.IncrementalOptions =
	       Ml_Debugger.Incremental.options

  sharing type ErrorBrowser.error = ToolData.ShellTypes.Info.error =
	       ActionQueue.Info.error
d208 2
a209 2
  sharing type ActionQueue.user_context = ToolData.ShellTypes.user_context
                                        = MotifUtils.user_context
d211 1
a211 1
  sharing type ToolData.ShellTypes.identifier =
d215 1
a215 1
	       ToolData.ShellTypes.map
d234 1
d369 1
a369 1
                    ShellTypes.get_context (!local_context))
d398 1
a398 1
            val context_name = ShellTypes.get_context_name user_context
d421 1
a421 1
	   get_context = fn () => ShellTypes.get_context (!local_context),
d528 2
a529 3
            ShellUtils.get_completions (subline,
                                        options,
					ShellTypes.get_context (!local_context))
d553 1
a553 1
      fun get_context () = ShellTypes.get_context (!local_context)
d593 4
a596 2
              (ShellTypes.make_incremental_options shell_data,
               ShellTypes.get_context (!local_context),
d600 1
a600 1
	    ShellTypes.process_result
@


1.38
log
@Changes to context_menu.
@
text
@d4 3
a722 8
      val value_menu =
          MotifUtils.value_menu
              (shell,
	       !local_context,
	       user_options,
	       [inputText,outputText]
              )

a729 1
        :: value_menu
d741 1
@


1.37
log
@Added catch for ShellTypes.DebuggerTrapped in evaluate function.
@
text
@d4 3
d395 1
a395 1
            val context_name = ShellTypes.context_name user_context
a648 10
      fun push_state _ =
        select_state (ShellTypes.copyUserContext (!local_context))

      fun initialContext _ =
        let
          val context = ShellTypes.getNewInitialContext()
        in
          select_state (context)
        end

d747 2
a748 7
        :: Menus.CASCADE
	     ("context",
              [Menus.PUSH ("pushContext", push_state, fn _ => true),
               Menus.PUSH ("initialContext", initialContext, fn _ => true),
               Menus.SEPARATOR,
	       MotifUtils.context_menu (select_state, MotifUtils.WRITABLE)],
              fn _ => true)
@


1.36
log
@Input widget now takes an applicationShell argument.
@
text
@d4 3
d634 1
@


1.35
log
@Ensured that we always use a windowing debugger.
@
text
@d4 3
d406 1
a406 1
	InputWindow.create (shell, title)
@


1.34
log
@Removed unimplemented menu items.
@
text
@d4 3
d337 3
a339 1
        Ml_Debugger.WINDOWING (DebuggerWindow.make_debugger_window(shell,"debugger",tooldata),true)
@


1.33
log
@Removed the history pane to the new context tool.
@
text
@d4 3
d712 1
a712 1
      val UserOptions.USER_OPTIONS({full_menus,...},update_fns) = user_options
d749 1
a749 16
        :: (if !full_menus then
	      Menus.CASCADE
	        ("module",
                 [Menus.PUSH ("structure", fn _ => (), fn _ => true),
                  Menus.PUSH ("signature", fn _ => (), fn _ => true),
                  Menus.PUSH ("functor", fn _ => (), fn _ => true),
                  Menus.PUSH ("local", fn _ => (), fn _ => true),
                  Menus.PUSH ("group", fn _ => (), fn _ => true),
                  Menus.PUSH ("unit", fn _ => (), fn _ => true),
	          Menus.SEPARATOR,
                  Menus.PUSH ("clear", fn _ => (), fn _ => true)],
                 fn _ => true)
	      :: MotifUtils.breakpoints_menu shell
              :: [options_menu]
	    else
              [options_menu])
@


1.32
log
@Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
@
text
@d4 102
a105 99
# Revision 1.31  1995/03/16  15:49:09  daveb
# Removed context_function from register when closing the window.
#
# Revision 1.30  1995/03/15  17:42:31  daveb
# Changed to share current context with other tools..
#
# Revision 1.29  1995/03/10  17:01:42  daveb
# Replaced "inspect" command with automatic updating of context selection.
#
# Revision 1.28  1995/03/06  12:29:18  daveb
# Added contexts to history info.  Also replaced evaluation sequence
# with ShellTypes.process_result.
#
# Revision 1.27  1995/03/02  13:31:24  matthew
# Changes to Parser & Lexer structures
#
# Revision 1.26  1995/03/01  15:14:26  daveb
# Removed redundant code.
#
# Revision 1.25  1995/02/27  14:05:44  daveb
# Fixed timing of call to ActionQueue.do_actions.
#
# Revision 1.24  1995/02/20  15:31:38  daveb
# Changed name of output pane so that resources can make it read-only.
#
# Revision 1.23  1995/02/20  14:21:11  daveb
# Made use update the history of the context, and regenerated the
# history from the context every time.
#
# Revision 1.22  1995/02/16  16:49:59  daveb
# Added shortcuts for the buttons.
#
# Revision 1.21  1995/02/16  15:02:45  daveb
# Removed the augment button, and all that depended on it.
#
# Revision 1.20  1995/01/13  16:17:47  daveb
# Replaced Option structure with references to MLWorks.Option.
#
# Revision 1.19  1994/11/30  18:30:21  daveb
# Fixed bug in form layout code for MIPS.  Also simplified this code
# by replacing separator widgets with Xm.*Offset values.  Also added
# an initial call to Xm.Widget.processTraversal for correct
# behaviour on the MIPS.
#
# Revision 1.18  1994/09/21  12:29:15  brianm
# Adding value menu (Edit/Trace/Untrace)
#
# Revision 1.17  1994/08/11  11:11:06  daveb
# Ensured that accept function augmented the correct context.
#
# Revision 1.16  1994/08/11  10:53:58  daveb
# Added semicolons when saving history.
#
# Revision 1.15  1994/08/09  12:55:02  daveb
# Changed type of InterPrint.strings.  Renamed source_result to result.
# A minor change to how results are used.
#
# Revision 1.14  1994/08/02  16:55:52  daveb
# Made error browser handle edit operation correctly.
#
# Revision 1.13  1994/08/02  09:20:37  daveb
# Passed token_stream to Incremental.compile_source instead of a parsed
# topdec, thus ensuring correct error handling.  Also made errors from
# the action queue invoke an error browser.
#
# Revision 1.11  1994/07/28  11:41:39  daveb
# Corrected sensitivity of history menu items.  Removed edit and inspect
# entries until they actually work.
#
# Revision 1.10  1994/07/28  10:24:12  daveb
# Excised unimplemented parts of user-interface.
#
# Revision 1.9  1994/07/27  14:32:52  daveb
# Cut-down menus for novices.
#
# Revision 1.8  1994/07/19  13:20:42  daveb
# Corrected misnamed "print_options" to the correct "options".
#
# Revision 1.7  1994/07/12  16:03:57  daveb
# ToolData.works_menu takes different arguments.
#
# Revision 1.6  1994/07/11  17:51:04  daveb
# Made accept button insensitive when there is no current result.
#
# Revision 1.5  1994/07/05  19:05:23  daveb
# Added input widget.
#
# Revision 1.4  1994/06/30  17:39:36  daveb
# Ensured that source is saved in user contexts.  Set history from user
# contexts.  Added facility to save the source of the current context.
# Also disabled entries in Output menu as appropriate.
#
# Revision 1.3  1994/06/23  10:55:32  jont
# Update debugger information production
#
# Revision 1.2  1994/06/23  10:36:04  daveb
# Added calls to Xm.Widget.processTraversal.  Also cleared output window
# before evaluating.
#
a130 1
require "file_dialog";
a151 1
  structure FileDialog: FILE_DIALOG
d175 1
a175 1
	       ErrorBrowser.Widget = FileDialog.Widget = InputWindow.Widget
a275 9
      val historyPane =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "historyPane", Xm.Widget.Class.Form, paned, [])

      val historyTitleLabel =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "historyTitleLabel", Xm.Widget.Class.Label,
	   historyPane, [])

a318 14
      (* The history is a list of topdecs, combined with an index number.
	 The index is used to set the current_index ref when a topdec is
	 selected from the menu. *)
      type hist_entry =
	ShellTypes.history_entry * int
	(*
	ITEM of {source: string, result: string, index: int}
	*)

      val history = ref []: hist_entry list ref;
      val history_size = ref 0;
      val initial_index = ~1;
      val history_index = ref initial_index;

d322 1
a322 2
      val current_history =
	ref (Compiler.dummy_identifier, Incremental.empty_context, "", "")
a323 2
      (*** Context stack ***)

a374 48
      fun select_fn _ 
		    (entry as ShellTypes.ITEM (item as (_, _, result, _)), _) =
	(current_history := item;
	 ShellTypes.set_selected
	   (!local_context,
            ShellTypes.get_user_options shell_data,
	    entry);
	 Xm.Text.setString (outputText, result))

      val (winScroll, winList, set_items) =
        MotifUtils.make_scrolllist
          {parent = historyPane, name = "evaluator",
	   print_fn =
	     fn _ => fn (ShellTypes.ITEM (_, _, result, _), _) => result,
           select_fn = select_fn,
	   action_fn = fn _ => fn _ => ()}

      fun set_history_from_context print_options user_context  =
	let
	  val (_, _, hist, _) =
	    ShellTypes.get_context_info user_context

	  fun aux ([], n) =
	    (history_size := n;
	     [])
	  |   aux (item :: t, n) =
	    (item, n) :: aux (t, n+1)

	  val new_hist = aux (hist, 0)
	in
	  history := new_hist;
	  set_items print_options (rev (new_hist))
	end

      fun update_fn () =
	set_history_from_context
	  (ShellTypes.get_current_print_options shell_data)
	  (ShellTypes.get_user_context shell_data)

      fun copy_history () = 
	Xm.Text.insert
	  (inputText,
	   Xm.Text.getInsertionPosition inputText,
	   #3 (!current_history))

      val update_register_key = 
	ref (ShellTypes.add_update_fn (!local_context, update_fn))

a382 2
	    ShellTypes.remove_update_fn
	      (!local_context, !update_register_key);
d384 1
a384 7
	      (contextLabel, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)]);
	    set_history_from_context
	      (ShellTypes.get_current_print_options shell_data)
	      user_context;
	    update_register_key := 
	      ShellTypes.add_update_fn (user_context, update_fn);
      	    history_index := initial_index
a434 34
      fun save_history prompt =
	let
	  val user_context = !local_context

	  val context_name = ShellTypes.context_name user_context

	  val filename_opt =
	    if prompt then
	      FileDialog.find_file shell 
	    else
	      case ShellTypes.get_saved_file_name user_context of
	        MLWorks.Option.NONE =>
		  FileDialog.find_file shell
	      | x => x
	in
	  case filename_opt of
	    MLWorks.Option.NONE => ()
	  | MLWorks.Option.SOME filename =>
	    let
	      val file = open_out filename
  
	      fun write_hist (ShellTypes.ITEM (_, _, _, source), _) =
	        (output (file, source);
	         output (file, ";\n"))
	    in
	      Lists.iterate write_hist (rev (!history));
	      MLWorks.IO.flush_out file;
	      close_out file;
	      message_fun ("Saved " ^ context_name ^ " to " ^ filename);
	      ShellTypes.set_saved_file_name (user_context, filename)
	    end
	    handle Io _ => ()
        end

a487 2
	  :: (fn _ => ShellTypes.remove_select_fn
			(!local_context, !update_register_key))
a590 3
	  set_history_from_context
	    (ShellTypes.get_current_print_options shell_data)
	    (!local_context);
a659 3
      fun finish_up () =
        (history_index := initial_index)

a711 34
      fun is_selection _ = Vector.length (Xm.List.getSelectedPos winList) = 1

      val menuspec_tail =
        [options_menu,
         Menus.CASCADE
	   ("history",
            Menus.PUSH
	      ("save",
	       fn _ => save_history false,
	       fn _ => not (null (!history)))
            :: Menus.PUSH
	         ("saveAs",
		  fn _ => save_history true,
		  fn _ => not (null (!history)))
            :: Menus.PUSH ("copy", fn _ => copy_history (), is_selection)
	    (*
            :: Menus.PUSH ("edit", fn _ => (), is_selection)
	    *)
 	    :: (if !full_menus then
		  [Menus.SEPARATOR,
                   Menus.CASCADE
	             ("internals",
                      [Menus.PUSH ("abSyn", fn _ => (), fn _ => true),
                       Menus.PUSH ("lambda", fn _ => (), fn _ => true),
                       Menus.PUSH ("optLambda", fn _ => (), fn _ => true),
                       Menus.PUSH ("lambdaEnv", fn _ => (), fn _ => true),
                       Menus.PUSH ("mir", fn _ => (), fn _ => true),
                       Menus.PUSH ("optMir", fn _ => (), fn _ => true),
                       Menus.PUSH ("object", fn _ => (), fn _ => true)],
                      fn _ => not (null (!history)))]
		else
		  nil),
	    fn _ => true)]

d759 1
a759 1
	      :: menuspec_tail
d761 1
a761 1
	      menuspec_tail)
a789 19
      Xm.Widget.valuesSet
        (historyTitleLabel,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
      Xm.Widget.valuesSet
        (winScroll,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET historyTitleLabel),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);

@


1.31
log
@Removed context_function from register when closing the window.
@
text
@d4 3
d388 1
a388 1
        {user_context = ref user_context,
d451 1
a451 3
            val context_name =
              ShellTypes.string_context_name
		(ShellTypes.get_context_name user_context)
d472 1
a472 1
          (current_context, (set_state, get_user_options))
d520 1
a520 3
	  val context_name =
	    ShellTypes.string_context_name
	      (ShellTypes.get_context_name user_context)
d758 1
a758 1
          set_state (context)
d883 1
a883 1
	  (mk_tooldata, close_window, fn _ => true)
d901 1
a901 1
	       MotifUtils.context_menu select_state],
@


1.30
log
@Changed to share current context with other tools..
@
text
@d4 3
d473 4
d484 3
a486 3
      val {instream, input_widget, input_visible,
	   show_input, hide_input, clear_input} =
	InputWindow.create (shell, title)
d601 6
a606 1
      val quit_funs = ref []
a607 2
      fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

d878 4
d884 1
a884 1
	  (mk_tooldata, fn _ => Xm.Widget.destroy shell, fn _ => true)
@


1.29
log
@Replaced "inspect" command with automatic updating of context selection.
@
text
@d4 3
d223 2
a224 1
  fun create (tooldata as ToolData.TOOLDATA {args,appdata,tools}) =
d343 1
a343 1
      val context_stack = ref []
d368 1
a368 1
                    ShellTypes.get_context user_context)
d382 1
a382 1
        {context_stack = context_stack,
d398 1
a398 1
	   (ShellTypes.get_user_context shell_data,
d440 1
a440 1
	ref (ShellTypes.add_update_fn (user_context, update_fn))
d442 23
a464 15
      fun get_current_state () =
        case !context_stack
          of
          (state :: _) => state
        | _ => Crash.impossible "Empty state stack in get_current_state"

      fun set_state (context_list) =
        (context_stack := context_list;
         case context_list of
           [] => ()
         | (user_context :: _) =>
           let
              val context_name =
                ShellTypes.string_context_name
		  (ShellTypes.get_context_name user_context)
d466 3
a468 17
              val cstring =
		Xm.CompoundString.createSimple("Context: " ^ context_name)
            in
	      ShellTypes.remove_update_fn
		(get_current_state (), !update_register_key);
              Xm.Widget.valuesSet(contextLabel,
                                  [(Xm.LabelString, 
                                    Xm.COMPOUNDSTRING cstring)]);
	      set_history_from_context
	        (ShellTypes.get_current_print_options shell_data)
	        user_context;
	      update_register_key := 
		ShellTypes.add_update_fn (user_context, update_fn);
      	      history_index := initial_index
            end)
              
      val _ = set_state [user_context]
d474 1
a474 1
	   get_context = fn () => ShellTypes.get_context user_context,
d510 1
a510 1
	  val user_context = ShellTypes.get_user_context shell_data
d618 1
a618 1
                                        ShellTypes.get_current_context shell_data)
d642 1
a642 1
      fun get_context () = ShellTypes.get_current_context shell_data
d683 1
a683 1
               ShellTypes.get_current_context shell_data,
d689 1
a689 1
	       ShellTypes.get_user_context shell_data,
d694 1
a694 1
            (ShellTypes.get_user_context shell_data,
d701 1
a701 1
	    (ShellTypes.get_user_context shell_data);
d737 4
a740 9
      fun can_pop_state _ =
        case !context_stack of
          (_::_::_) => true
        | _ => false

      fun pop_state _ =
        case !context_stack of
          _::(b as (_::_)) => set_state b
        | _ => ()
d743 1
a743 7
        let
          val statelist = !context_stack
        in
            case statelist of
              (c::_) => set_state((ShellTypes.copyUserContext c) :: statelist)
              | _ => ()
        end
d749 1
a749 1
          set_state (context :: !context_stack)
d815 2
a816 1
                           appdata = appdata,
a819 17
        
      fun select_menu () =
	let val context_name =
              ShellTypes.string_context_name o ShellTypes.get_context_name
	in
	    map (fn c =>
		   let val name = context_name c
		   in
                     Menus.PUSH (name,
				 fn _ =>
              			   set_state (c :: !context_stack),
				 fn _ => true)
		   end)
        	(Lists.filter_outp
		   ShellTypes.is_const_context
		   (ShellTypes.getCurrentContexts()))
	end
d863 1
a863 1
	       user_context,
a885 1
               Menus.PUSH ("popContext", pop_state, can_pop_state),
d888 1
a888 1
               Menus.DYNAMIC ("selectContext", select_menu, fn _ => true)],
@


1.28
log
@Added contexts to history info.  Also replaced evaluation sequence
with ShellTypes.process_result.
@
text
@d4 4
a113 1
require "inspector_tool";
a131 1
  structure InspectorTool: INSPECTORTOOL
d155 1
a155 2
               ToolData.ShellTypes.Context = Ml_Debugger.Incremental.Context =
	       InspectorTool.Context
d165 1
a165 2
	       ErrorBrowser.Widget = FileDialog.Widget = InputWindow.Widget =
	       InspectorTool.Widget
d171 1
a171 2
  sharing type ToolData.ToolData = DebuggerWindow.ToolData =
	       InspectorTool.ToolData
d173 1
a173 2
  sharing type Ml_Debugger.ValuePrinter.Type = DebuggerWindow.Type =
	       InspectorTool.Type
a336 70
      fun select_fn _ (ShellTypes.ITEM (item as (_, _, result, _)), _) =
	(current_history := item;
	 Xm.Text.setString (outputText, result))

      val (winScroll, winList, set_items) =
        MotifUtils.make_scrolllist
          {parent = historyPane, name = "evaluator",
	   print_fn =
	     fn _ => fn (ShellTypes.ITEM (_, _, result, _), _) => result,
           select_fn = select_fn,
	   action_fn = fn _ => fn _ => ()}

      fun set_history_from_context print_options user_context  =
	let
	  val (_, _, hist, _) =
	    ShellTypes.get_context_info user_context

	  fun aux ([], n) =
	    (history_size := n;
	     [])
	  |   aux (item :: t, n) =
	    (item, n) :: aux (t, n+1)

	  val new_hist = aux (hist, 0)
	in
	  history := new_hist;
	  set_items print_options (rev (new_hist))
	end

      fun copy_history () = 
	Xm.Text.insert
	  (inputText,
	   Xm.Text.getInsertionPosition inputText,
	   #3 (!current_history))

      val {outstream, output_widget, output_visible,
	   show_output, hide_output} =
	OutputWindow.create
	  {parent = shell, title = title,
	   get_context = fn () => ShellTypes.get_context user_context,
	   get_preferences = fn () => UserOptions.new_preferences user_options}

      val {instream, input_widget, input_visible,
	   show_input, hide_input, clear_input} =
	InputWindow.create (shell, title)

      val error_info = Info.default_options

      (*** IO functions ***)

      fun to_top () = Xm.Text.setInsertionPosition (inputText,0)

      fun to_bottom () =
        let
          val pos = Xm.Text.getLastPosition inputText
        in
	  Xm.Text.setInsertionPosition (inputText, pos)
        end

      fun print_result s =
	Xm.Text.insert (outputText, Xm.Text.getInsertionPosition outputText, s);

      fun add_strings [] = ()
      |   add_strings ((_, s)::t) =
	(print_result s;
	 add_strings t)

      fun clear text =
	Xm.Text.setString (text, "");

d390 54
d457 2
d465 2
d472 35
a757 6
      fun get_current_state () =
        case !context_stack
          of
          (state :: _) => state
        | _ => Crash.impossible "Empty state stack in get_current_state"

d851 1
a851 1
	MotifUtils.options_menu (shell, title,get_user_options)
a854 17
      fun inspect_it _ =
	let
	  val (id, context, _, _) = !current_history
	in
	  case id of
	    Compiler.VALUE (Compiler.Absyn.Ident.VAR s) =>
	      InspectorTool.inspect_variable
	        (DebuggerWindow.make_debugger_window)
	        (Compiler.Absyn.Ident.Symbol.symbol_name s, context, tooldata)
	  | _ => ()
	end

      fun can_inspect _ =
	case #1 (!current_history)
	of Compiler.VALUE _ => true
	|  _ => false
	
a872 1
            :: Menus.PUSH ("inspect", inspect_it, can_inspect)
@


1.27
log
@Changes to Parser & Lexer structures
@
text
@d4 3
a105 1
require "../interpreter/interprint";
d110 1
d129 1
a136 1
  structure InterPrint : INTERPRINT
d146 1
a146 3
	  InterPrint.Compiler.Options = MotifUtils.Options

  sharing InterPrint.Compiler = Ml_Debugger.Incremental.InterMake.Compiler
a147 2
  sharing Parser.Absyn = InterPrint.Compiler.Absyn

d154 1
a154 1
	       InterPrint.Context
d158 2
d164 2
a165 1
	       ErrorBrowser.Widget = FileDialog.Widget = InputWindow.Widget
d171 2
a172 1
  sharing type ToolData.ToolData = DebuggerWindow.ToolData
d174 2
a175 1
  sharing type Ml_Debugger.ValuePrinter.Type = DebuggerWindow.Type
a179 2
  sharing type Parser.ParserBasis = InterPrint.Compiler.ParserBasis

d322 3
a324 1
      datatype hist_entry =
d326 2
d333 2
a334 1
      val current_history = ref "";
d336 5
a340 2
      fun select_fn _ (ITEM {source, result, index}) =
	(current_history := source;
d346 2
a347 1
	   print_fn = fn _ => fn (ITEM {result, ...}) => result,
d359 2
a360 2
	  |   aux (ShellTypes.ITEM (_, res, src) :: t, n) =
	    ITEM {source = src, result = res, index = n} :: aux (t, n+1)
d370 3
a372 1
	  (inputText, Xm.Text.getInsertionPosition inputText, !current_history)
d512 1
a512 1
	      fun write_hist (ITEM {source, ...}) =
a658 3
	  val (current_context, current_delta, hist, ShellTypes.MAP smap) =
	    ShellTypes.get_user_context_info shell_data

d660 1
a660 1
          val (result, identifiers) =
d667 6
a672 25
	  val (current_context, current_delta, hist, ShellTypes.MAP smap) =
	    ShellTypes.get_user_context_info shell_data

          val options = ShellTypes.get_current_options shell_data

          val new_context =
	    Incremental.add_definitions
	      (options, current_context, result)

	  val new_delta =
	    Incremental.add_definitions
	      (ShellTypes.get_current_options shell_data, current_delta, result)

          val result_strings = 
            InterPrint.strings
              (new_context, Incremental.pb_from_result result,
	       options, 0, identifiers)

          val new_hist =
            map (fn (i, s) => ShellTypes.ITEM (i, s, src)) result_strings

	  val new_smap =
	    Lists.reducel
	      (fn (map, (id, _)) => Map.define (map, id, src))
	      (smap, result_strings)
a673 5
	  add_strings result_strings;
          ShellTypes.set_user_context_info
	    (shell_data,
	     (new_context, new_delta, new_hist @@ hist,
	      ShellTypes.MAP new_smap));
d840 17
d864 3
a866 1
	      ("save", fn _ => save_history false, fn _ => !history <> [])
d868 3
a870 2
	         ("saveAs", fn _ => save_history true,
		  fn _ => !history <> [])
a873 1
            :: Menus.PUSH ("inspect", fn _ => (), is_selection)
d875 1
d887 1
a887 1
                      fn _ => !history <> [])]
@


1.26
log
@Removed redundant code.
@
text
@d4 3
d159 1
a159 1
  sharing type UserOptions.Options.options = Parser.Lexer.options
@


1.25
log
@Fixed timing of call to ActionQueue.do_actions.
@
text
@d4 3
a323 21
      fun whitespacep x =
        case x of
          " " => true
        | "\n" => true
        | "\t" => true
        | "\012" => true
        | "\013" => true
        | _ => false
          
      fun strip_whitespace s =
        let
          fun strip [] = []
            | strip (l as (a::b)) =
              if whitespacep a then strip b else l
        in
          implode (rev (strip (rev (strip (explode s))))) (* Yuk Yuk *)
        end

      fun flatten s =
	implode (map (fn "\n" => " " | x => x) (explode s))
	
d333 1
a333 1
	   print_fn = fn _ => fn (ITEM {result, ...}) => flatten result,
a336 11
      fun add_history_entry print_options (source, result) =
        (history_size := !history_size + 1;
	 history := 
	   (ITEM
	      {source = strip_whitespace source,
	       result = strip_whitespace result,
	       index = !history_size})
	   :: !history;
	 (* Should use add_item instead of this. *)
	 set_items print_options (rev (!history)))

a760 27

      fun pop_history () = ()
      fun push_history () = ()

      (*
      fun pop_history () = 
	let val _ = history_index := !history_index + 1
	    val line = #1 (Lists.nth (!history_index, !history))
	in 
	  replace_current_topdec line
	end
	handle
	  Lists.Nth =>
	    history_index := !history_index - 1;

      fun push_history () = 
	let val _ = history_index := !history_index - 1;
	    val line = #1 (Lists.nth (!history_index, !history))
	               handle
	  		 Lists.Nth =>
			   (history_index := initial_index;
			    ""	(* empty input *))
	in 
	  replace_current_topdec line
	end
      *)

d796 1
a796 13
	    Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "p", state, ...}) =>
	      if Xm.Event.convertState state = [Xm.Event.MOD1] then
		(* meta-p *)
	        pop_history ()
	      else
		()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "n", state, ...}) =>
	      if Xm.Event.convertState state = [Xm.Event.MOD1] then
		(* meta-n *)
	        push_history ()
	      else
		()
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\173", state, ...}) =>
@


1.24
log
@Changed name of output pane so that resources can make it read-only.
@
text
@d4 3
a682 8
	  val _ = 
            ActionQueue.do_actions
              (ShellTypes.get_user_context shell_data,
               ShellTypes.get_user_options shell_data,
               debugger_function,
	       print_result,
               fn s => output (std_out, "Make: compiling " ^ s))

d714 6
a722 8
	  (*
	  Lists.iterate
	    (fn (_, res) =>
	       add_history_entry
	         (ShellTypes.get_current_print_options shell_data)
	         (src, res))
	         result_strings;
	  *)
@


1.23
log
@Made use update the history of the context, and regenerated the
history from the context every time.
@
text
@d4 4
d303 1
a303 1
        Xm.Widget.createScrolledText (outputPane, Xm.Widget.NAME "textIO", [])
@


1.22
log
@Added shortcuts for the buttons.
@
text
@d4 3
d359 1
a359 1
      fun set_history_from_context print_options user_context =
d404 3
d409 1
a409 1
	(Xm.Text.insert (outputText, Xm.Text.getInsertionPosition outputText, s);
d681 1
d715 4
d725 1
@


1.21
log
@Removed the augment button, and all that depended on it.
@
text
@d4 3
a837 61
      (*
      fun do_return () =
	let
          val pos = Xm.Text.getInsertionPosition text
          val lines =
            if pos < !prompt_pos then
              let
                val line = (getline (text, pos)) ^ "\n"
                val last_pos = Xm.Text.getLastPosition text
              in
                Xm.Text.insert(text, last_pos, line);
                write_pos := last_pos + size line;
                Xm.Text.setInsertionPosition (text, last_pos + size line);
                [line]
              end
            else
              let
                val str = Xm.Text.getString text
                val length = size str

		fun spaces column =
		  case column mod 8 
		  of 1 => "        "
		  |  2 => "       "
		  |  3 => "      "
		  |  4 => "     "
		  |  5 => "    "
		  |  6 => "   "
		  |  7 => "  "
		  |  0 => " "
		  |  _ => Crash.impossible "n mod 8 failed!"

                fun get_lines ([], current, acc, _) =
		  map (implode o rev) (current :: acc)
                |   get_lines ("\t"::rest, current, acc, column) =
		  get_lines (rest, (spaces column :: current), acc, column)
                |   get_lines ("\n"::rest, current, acc, column) =
		  get_lines (rest, [], ("\n"::current)::acc, 1)
                |   get_lines (c::rest, current, acc, column) =
		  get_lines (rest, c::current, acc, column+1)

                val line = String.substring (str, !write_pos,
                                             length - !write_pos)
                val lines = get_lines (explode line,[],[],0)
              in
                case lines of
                  last :: rest =>
                    (Xm.Text.insert(text, length, "\n");
                     write_pos := length + 1;
                     Xm.Text.setInsertionPosition (text, length+1);
                     last ^ "\n" :: rest)
                | _ => lines
              end
        in
          (Lists.iterate
             (fn line => update_history (handler line, line))
             (rev lines);
             finish_up ())
        end
      *)

d855 6
a866 4
(*
	  | Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key = "\^D", ...}) =>
	      eof ()			(* EOF - possibly ends topdec *)
*)
@


1.20
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d4 3
a282 5
      val acceptButton =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "acceptButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

a619 6
      val current_result =
	ref MLWorks.Option.NONE:
  	  (Incremental.Context
	   * Incremental.Context
	   * (Compiler.identifier * string) list) MLWorks.Option.option ref

d645 1
a645 1
      fun compile s =
d648 1
a648 1
            let val buff = ref s
d691 8
d700 13
a712 4
	  current_result :=
	    MLWorks.Option.SOME (new_delta, new_context, result_strings);
	  Xm.Widget.valuesSet (acceptButton, [(Xm.Sensitive, Xm.BOOL true)]);
	  add_strings result_strings
a714 41
      fun accept_result _ =
	case !current_result of
	  MLWorks.Option.NONE =>
	  (* This case should be impossible. *)
	  (Xm.Widget.processTraversal (inputText, Xm.Widget.TRAVERSE_CURRENT);
	   ())
	| MLWorks.Option.SOME (new_delta, new_context, strings) =>
	  let
	    val (_, _, hist, ShellTypes.MAP smap) =
	      ShellTypes.get_user_context_info shell_data


	    val src = Xm.Text.getString inputText

            val new_hist =
              map (fn (i, s) => ShellTypes.ITEM (i, s, src)) strings

	    val new_smap =
	      Lists.reducel
		(fn (map, (id, _)) => Map.define (map, id, src))
		(smap, strings)
	  in
            ShellTypes.set_user_context_info
	      (shell_data,
	       (new_context, new_delta, new_hist @@ hist,
		ShellTypes.MAP new_smap));
	    Lists.iterate
	      (fn (_, res) =>
		 add_history_entry
	           (ShellTypes.get_current_print_options shell_data)
	           (src, res))
	      strings;
	    current_result := MLWorks.Option.NONE;
	    Xm.Widget.valuesSet
	      (acceptButton, [(Xm.Sensitive, Xm.BOOL false)]);
	    clear inputText;
	    clear outputText;
	    Xm.Widget.processTraversal (inputText, Xm.Widget.TRAVERSE_CURRENT);
	    ()
	  end;

a1138 1
      Xm.Widget.callbackAdd (acceptButton, Xm.Callback.Activate, accept_result);
a1148 1
      Xm.Widget.valuesSet (acceptButton, [(Xm.Sensitive, Xm.BOOL false)]);
@


1.19
log
@Fixed bug in form layout code for MIPS.  Also simplified this code
by replacing separator widgets with Xm.*Offset values.  Also added
an initial call to Xm.Widget.processTraversal for correct
behaviour on the MIPS.
@
text
@d4 6
a118 3
  sharing ToolData.ShellTypes.Option =
	  Ml_Debugger.Incremental.InterMake.Option = DebuggerWindow.Option

a177 1
  structure Option = DebuggerWindow.Option
d501 1
a501 1
	        ShellTypes.Option.ABSENT =>
d503 1
a503 2
	      | ShellTypes.Option.PRESENT s =>
		  FileDialog.Option.PRESENT s
d506 2
a507 2
	    FileDialog.Option.ABSENT => ()
	  | FileDialog.Option.PRESENT filename =>
d623 1
a623 1
	ref Option.ABSENT:
d626 1
a626 1
	   * (Compiler.identifier * string) list) Option.opt ref
d701 1
a701 1
	    Option.PRESENT (new_delta, new_context, result_strings);
d708 1
a708 1
	  Option.ABSENT =>
d712 1
a712 1
	| Option.PRESENT (new_delta, new_context, strings) =>
d738 1
a738 1
	    current_result := Option.ABSENT;
@


1.18
log
@Adding value menu (Edit/Trace/Untrace)
@
text
@d4 3
d229 4
d241 3
a243 2
      val inputText =
        Xm.Widget.createScrolledText (frame, Xm.Widget.NAME "textIO", [])
d245 4
a248 5
      val outputText =
        Xm.Widget.createScrolledText (frame, Xm.Widget.NAME "textIO", [])

      val _ = Xm.Widget.manage inputText
      val _ = Xm.Widget.manage outputText
d250 1
a250 1
      val historyTitleLabel =
d252 2
a253 1
 	  (Xm.Widget.NAME "historyTitleLabel", Xm.Widget.Class.Label, frame, [])
d257 2
a258 1
 	  (Xm.Widget.NAME "inputTitleLabel", Xm.Widget.Class.Label, frame, [])
d260 2
a261 3
      val outputTitleLabel =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "outputTitleLabel", Xm.Widget.Class.Label, frame, [])
d265 2
a266 1
 	  (Xm.Widget.NAME "buttonPane", Xm.Widget.Class.RowColumn, frame, [])
d283 15
d337 1
a337 1
          {parent = frame, name = "evaluator",
d672 1
a672 1
	       Compiler.TOKENSTREAM1 token_stream)
d1096 1
a1096 1
        (historyTitleLabel,
d1099 8
a1106 1
          (Xm.TopOffset, Xm.INT sep_size),
d1120 3
a1122 1
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
d1125 1
a1125 3
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET winScroll),
          (Xm.TopOffset, Xm.INT sep_size),
d1140 2
a1141 2
	  (Xm.BottomOffset, Xm.INT sep_size),
	  (Xm.BottomWidget, Xm.WIDGET buttonPane)]);
d1149 2
a1150 1
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
d1153 1
a1153 3
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET buttonPane),
          (Xm.TopOffset, Xm.INT sep_size),
a1166 1
	  (Xm.BottomOffset, Xm.INT sep_size),
d1168 1
d1183 1
@


1.17
log
@Ensured that accept function augmented the correct context.
@
text
@d4 3
d154 1
d1005 8
d1016 1
@


1.16
log
@Added semicolons when saving history.
@
text
@d4 3
d643 1
a643 1
               current_context,
d646 10
d674 1
a674 6
	  add_strings result_strings;
          ActionQueue.do_actions
            (ShellTypes.get_user_context shell_data,
             ShellTypes.get_user_options shell_data,
             debugger_function,
             fn s => output (std_out, "Make: compiling " ^ s))
@


1.15
log
@Changed type of InterPrint.strings.  Renamed source_result to result.
A minor change to how results are used.
@
text
@d4 4
d481 1
a481 1
	         output (file, "\n"))
@


1.14
log
@Made error browser handle edit operation correctly.
@
text
@d4 3
a142 2
  sharing type Ml_Debugger.Incremental.SourceResult = InterPrint.SourceResult

d588 1
a588 1
  	  (Incremental.SourceResult
d628 2
a629 1
          val current_context = ShellTypes.get_current_context shell_data
d632 1
a632 1
          val (source_result, identifiers) =
d643 5
a647 1
	      (options, current_context, source_result)
d651 2
a652 1
              (new_context, source_result, options, 0, identifiers)
d655 1
a655 1
	    Option.PRESENT (source_result, new_context, result_strings);
d671 1
a671 1
	| Option.PRESENT (result, new_context, strings) =>
d673 1
a673 1
	    val (_, delta, hist, ShellTypes.MAP smap) =
a675 3
	    val new_delta =
	      Incremental.add_definitions(ShellTypes.get_current_options shell_data,
					  delta, result)
@


1.13
log
@Passed token_stream to Incremental.compile_source instead of a parsed
topdec, thus ensuring correct error handling.  Also made errors from
the action queue invoke an error browser.
@
text
@d4 5
d152 1
a152 1
	       OutputWindow.preferences
d156 2
d594 2
a595 1
	    (error, error_list, header, context_fn, options_fn, redo_action) =
d603 3
d612 1
a612 1
	     edit_action = fn _ => fn () => (),
d724 1
a724 1
                 fn () => ShellTypes.get_user_options shell_data,
d730 1
a730 1
               fn () => ShellTypes.get_user_options shell_data,
@


1.12
log
@Moved preferences to separate structure.
@
text
@d132 2
a133 1
  sharing type ErrorBrowser.error = ToolData.ShellTypes.Info.error
d148 3
d586 19
a617 12
          val (topdec, new_PB) =
 	    Parser.parse_topdec
	      error_info
	      (ShellTypes.get_current_options shell_data,
	       token_stream,
	       Incremental.parser_basis current_context)
            handle
  	      Parser.SyntaxError(token,location) =>
                Info.error'
		  error_info
		  (Info.FATAL, location, "Unexpected " ^ token)
          
d623 2
a624 2
               ShellTypes.get_current_context shell_data,
               Compiler.TOPDEC (location_title, topdec, new_PB))
a644 4
          handle
	    ActionQueue.Error(s,_,_) =>
              output (std_out, s ^ "\n")
          | ActionQueue.Handled => ()
a703 19
      fun error_handler
	    (error, error_list, header, context_fn, options_fn, redo_action) =
        let
	  (*
          val file_message =
            case error_location error of
              Location.UNKNOWN => ""
            | loc => "Error in: " ^ location_file loc
	  *)
        in
          ErrorBrowser.create
            {parent = applicationShell,
	     errors = rev error_list,
	     action_message = header,
	     file_message = "Error in: " ^ location_title,
	     edit_action = fn _ => fn () => (),
             redo_action = redo_action}
        end

d710 7
a716 1
	  Info.Stop (error,error_list) =>
d719 1
a719 1
               fn () => UserOptions.new_options (user_options),
@


1.11
log
@Corrected sensitivity of history menu items.  Removed edit and inspect
entries until they actually work.
@
text
@d4 4
d49 1
d72 1
d113 1
a113 2
  sharing type UserOptions.Options.options = OutputWindow.options =
	       Parser.Lexer.options
d143 4
d332 1
a332 1
	   get_options = fn () => UserOptions.new_options user_options}
d384 2
a385 1
                   (UserOptions.new_options(user_options),
d541 5
a546 2
          val Options.OPTIONS{environment_options = Options.ENVIRONMENT_OPTIONS {completion_menu,...},...} =
            options
a573 4
      val current_PB =
	ref (Incremental.parser_basis
	       (ShellTypes.get_current_context shell_data));

d593 2
d600 1
a600 1
	       !current_PB)
d617 3
a619 2
          val new_context = Incremental.add_definitions
	    (options, ShellTypes.get_current_context shell_data, source_result)
@


1.10
log
@Excised unimplemented parts of user-interface.
@
text
@d4 3
d936 2
d947 5
a951 3
            :: Menus.PUSH ("edit", fn _ => (), fn _ => true)
            :: Menus.PUSH ("copy", fn _ => copy_history (), fn _ => true)
            :: Menus.PUSH ("inspect", fn _ => (), fn _ => true)
d963 1
a963 1
                      fn _ => true)]
@


1.9
log
@Cut-down menus for novices.
@
text
@d4 3
a211 8
      val modLabel =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "moduleLabel", Xm.Widget.Class.Label, frame, [])

      val modTitleLabel =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "moduleTitleLabel", Xm.Widget.Class.Label, frame, [])

a223 5
      val typeCheckButton =
  	Xm.Widget.createManaged
 	  (Xm.Widget.NAME "typeCheckButton", Xm.Widget.Class.PushButton,
	   buttonPane, [])

d701 1
a701 1
      fun type_check x =
d711 1
a711 3
               fn () => type_check x)

      val evaluate = type_check
a964 6
	     ("action",
              [Menus.PUSH ("typeCheck", type_check, fn _ => true),
               Menus.PUSH ("evaluate", evaluate, fn _ => true),
               Menus.PUSH ("toggleMode", fn _ => (), fn _ => true)],
              fn _ => true)
        :: Menus.CASCADE
d1038 1
a1038 1
        (modTitleLabel,
a1040 19
	  (Xm.TopOffset, Xm.INT 10),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
      Xm.Widget.valuesSet
        (modLabel,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET modTitleLabel),
          (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
          (Xm.LeftOffset, Xm.INT sep_size),
          (Xm.RightOffset, Xm.INT sep_size),
          (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
      Xm.Widget.valuesSet
        (inputTitleLabel,
         [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
          (Xm.TopWidget, Xm.WIDGET modLabel),
a1085 1
      Xm.Widget.callbackAdd (typeCheckButton, Xm.Callback.Activate, type_check);
@


1.8
log
@Corrected misnamed "print_options" to the correct "options".
@
text
@d4 3
d942 1
a942 1
      val UserOptions.USER_OPTIONS(_,update_fns) = user_options
d945 2
a946 20
      val menuspec =
        [ToolData.works_menu
	   (mk_tooldata, fn _ => Xm.Widget.destroy shell, fn _ => true),
         Menus.CASCADE
	   ("action",
            [Menus.PUSH ("typeCheck", type_check, fn _ => true),
             Menus.PUSH ("evaluate", evaluate, fn _ => true),
             Menus.PUSH ("toggleMode", fn _ => (), fn _ => true)],
            fn _ => true),
         Menus.CASCADE
	   ("input",
            [Menus.PUSH ("show", show_input, fn _ => not (input_visible ())),
             Menus.PUSH ("hide", hide_input, fn _ => input_visible ()),
             Menus.PUSH ("clear", fn _ => clear_input (), fn _ => true)],
            fn _ => true),
         Menus.CASCADE
	   ("output",
            [Menus.PUSH ("show", show_output, fn _ => not (output_visible ())),
             Menus.PUSH ("hide", hide_output, fn _ => output_visible ())],
            fn _ => true),
a947 19
	   ("context",
            [Menus.PUSH ("pushContext", push_state, fn _ => true),
             Menus.PUSH ("popContext", pop_state, can_pop_state),
             Menus.PUSH ("initialContext", initialContext, fn _ => true),
             Menus.SEPARATOR,
             Menus.DYNAMIC ("selectContext", select_menu, fn _ => true)],
            fn _ => true),
         Menus.CASCADE
	   ("module",
            [Menus.PUSH ("structure", fn _ => (), fn _ => true),
             Menus.PUSH ("signature", fn _ => (), fn _ => true),
             Menus.PUSH ("functor", fn _ => (), fn _ => true),
             Menus.PUSH ("local", fn _ => (), fn _ => true),
             Menus.PUSH ("group", fn _ => (), fn _ => true),
             Menus.PUSH ("unit", fn _ => (), fn _ => true),
	     Menus.SEPARATOR,
             Menus.PUSH ("clear", fn _ => (), fn _ => true)],
            fn _ => true),
         Menus.CASCADE
d949 68
a1016 21
            [Menus.PUSH
	       ("save", fn _ => save_history false, fn _ => !history <> []),
             Menus.PUSH
	       ("saveAs", fn _ => save_history true, fn _ => !history <> []),
             Menus.PUSH ("edit", fn _ => (), fn _ => true),
             Menus.PUSH ("copy", fn _ => copy_history (), fn _ => true),
             Menus.PUSH ("inspect", fn _ => (), fn _ => true),
 	     Menus.SEPARATOR,
             Menus.CASCADE
	       ("internals",
                [Menus.PUSH ("abSyn", fn _ => (), fn _ => true),
                 Menus.PUSH ("lambda", fn _ => (), fn _ => true),
                 Menus.PUSH ("optLambda", fn _ => (), fn _ => true),
                 Menus.PUSH ("lambdaEnv", fn _ => (), fn _ => true),
                 Menus.PUSH ("mir", fn _ => (), fn _ => true),
                 Menus.PUSH ("optMir", fn _ => (), fn _ => true),
                 Menus.PUSH ("object", fn _ => (), fn _ => true)],
                fn _ => true)],
            fn _ => true),
	 MotifUtils.breakpoints_menu shell,
         options_menu]
@


1.7
log
@ToolData.works_menu takes different arguments.
@
text
@d4 3
d608 1
a608 1
          val print_options = ShellTypes.get_current_options shell_data
d611 1
a611 1
	    (print_options, ShellTypes.get_current_context shell_data, source_result)
d615 1
a615 1
              (new_context, source_result, print_options, 0, identifiers)
@


1.6
log
@Made accept button insensitive when there is no current result.
@
text
@d4 3
d941 1
a941 1
	   (shell, tools, mk_tooldata, fn _ => true),
@


1.5
log
@Added input widget.
@
text
@d4 3
d613 1
d629 1
d661 3
a665 1
	    current_result := Option.ABSENT;
d1117 1
@


1.4
log
@Ensured that source is saved in user contexts.  Set history from user
contexts.  Added facility to save the source of the current context.
Also disabled entries in Output menu as appropriate.
@
text
@d4 5
d38 1
d57 1
d94 1
a94 1
	       ErrorBrowser.Widget = FileDialog.Widget
d320 4
d664 11
a674 9
        MLWorks.IO.with_standard_output
          outstream
          (fn () =>
             Ml_Debugger.with_debugger_type
               debugger_type
               (fn _ => 
                  ShellTypes.with_toplevel_name location_title
                  (fn _ => (compile s; MLWorks.IO.flush_out std_out))))

d939 6
d1111 1
@


1.3
log
@Update debugger information production
@
text
@d4 3
d35 1
d56 1
d87 1
a87 1
	       ErrorBrowser.Widget
d110 3
d123 2
d285 17
d390 2
a391 2
        | (context_ref :: _) =>
            let
d393 5
a397 2
                ShellTypes.string_context_name(ShellTypes.get_context_name context_ref)
              val cstring = Xm.CompoundString.createSimple("Context: " ^ context_name)
d401 5
a405 1
                                    Xm.COMPOUNDSTRING cstring)])
d410 40
a480 3
      fun message_fun s =
        MotifUtils.send_message (shell,s)

d613 3
a615 1
	  Option.ABSENT => ()
d618 1
a618 1
	    val (_, delta, hist, smap) =
d625 2
d628 6
a633 1
              map (fn (i, s) => ShellTypes.ITEM (i, s, "")) strings
d637 8
a644 6
	       (new_context, new_delta, new_hist @@ hist, smap));
	    (* This choice of strings is not very secure, and is also
	       wrong. *)
	    add_history_entry
	      (ShellTypes.get_current_print_options shell_data)
	      (Xm.Text.getString inputText, Xm.Text.getString outputText);
d927 2
a928 2
            [Menus.PUSH ("show", show_output, fn _ => true),
             Menus.PUSH ("hide", hide_output, fn _ => true)],
d951 5
a955 1
            [Menus.PUSH ("edit", fn _ => (), fn _ => true),
@


1.2
log
@Added calls to Xm.Widget.processTraversal.  Also cleared output window
before evaluating.
@
text
@d4 4
d520 1
a520 1
	    (ShellTypes.get_current_context shell_data, source_result)
d548 3
a550 1
	    val new_delta = Incremental.add_definitions (delta, result)
@


1.1
log
@new file
@
text
@d3 3
a5 1
 *  $Log$
d559 3
a561 1
	    current_result := Option.ABSENT
d595 4
a598 1
	handler (Xm.Text.getString inputText)
d991 4
a994 1
	 fn _ => (clear inputText; clear outputText));
@
