head	1.108;
access;
symbols
	MLW_daveb_inline_1_4_99:1.107.1
	MLWorks_21c0_1999_03_25:1.107
	MLWorks_20c1_1998_08_20:1.104
	MLWorks_20c0_1998_08_04:1.104
	MLWorks_20b2c2_1998_06_19:1.100
	MLWorks_20b2_Windows_1998_06_12:1.97
	MLWorks_20b1c1_1998_05_07:1.92
	MLWorks_20b0_1998_04_07:1.92
	MLWorks_20b0_1998_03_20:1.90
	MLWorks_20m2_1998_02_16:1.88
	MLWorks_20m1_1997_10_23:1.86
	MLWorks_11r1:1.73.1.1.1.3.1
	MLWorks_workspace_97:1.85.2
	MLWorks_dt_wizard:1.85.1
	MLWorks_11c0_1997_09_09:1.73.1.1.1.3
	MLWorks_10r3:1.73.1.1.3
	MLWorks_10r2_551:1.73.1.1.2
	MLWorks_11:1.73.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.73.1.1
	MLWorks_20m0_1997_06_20:1.80
	MLWorks_1_0_r2c2_1997_06_14:1.73.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.73.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.73.1
	MLWorks_BugFix_1997_04_24:1.73
	MLWorks_1_0_r2_Win32_1997_04_11:1.73
	MLWorks_1_0_r2_Unix_1997_04_04:1.73
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.71.1.1.1
	MLWorks_gui_1996_12_18:1.71.2
	MLWorks_1_0_Win32_1996_12_17:1.71.1
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.68.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.68.1.1
	MLWorks_1_0_Irix_1996_11_28:1.68.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.70.1
	MLWorks_1_0_Unix_1996_11_14:1.68.1
	MLWorks_Open_Beta2_1996_10_11:1.60.2
	MLWorks_License_dev:1.60.1
	MLWorks_1_open_beta_1996_09_13:1.58.1
	MLWorks_Open_Beta_1996_08_22:1.58
	MLWorks_Beta_1996_07_02:1.52
	MLWorks_Beta_1996_06_07:1.52
	MLWorks_Beta_1996_06_06:1.52
	MLWorks_Beta_1996_06_05:1.52
	MLWorks_Beta_1996_06_03:1.52
	MLWorks_Beta_1996_05_31:1.51
	MLWorks_Beta_1996_05_30:1.51;
locks; strict;
comment	@ * @;


1.108
date	99.05.13.13.59.01;	author daveb;	state Exp;
branches;
next	1.107;

1.107
date	99.03.19.10.27.56;	author mitchell;	state Exp;
branches
	1.107.1.1;
next	1.106;

1.106
date	99.03.09.16.01.04;	author mitchell;	state Exp;
branches;
next	1.105;

1.105
date	99.03.09.12.36.41;	author mitchell;	state Exp;
branches;
next	1.104;

1.104
date	98.07.30.16.30.00;	author jkbrook;	state Exp;
branches;
next	1.103;

1.103
date	98.07.17.14.59.23;	author jkbrook;	state Exp;
branches;
next	1.102;

1.102
date	98.07.15.11.10.09;	author jkbrook;	state Exp;
branches;
next	1.101;

1.101
date	98.07.02.14.34.47;	author johnh;	state Exp;
branches;
next	1.100;

1.100
date	98.06.24.14.52.36;	author johnh;	state Exp;
branches;
next	1.99;

1.99
date	98.06.24.13.21.12;	author johnh;	state Exp;
branches;
next	1.98;

1.98
date	98.06.15.15.24.14;	author johnh;	state Exp;
branches;
next	1.97;

1.97
date	98.06.12.11.19.37;	author jkbrook;	state Exp;
branches;
next	1.96;

1.96
date	98.06.11.18.21.30;	author jkbrook;	state Exp;
branches;
next	1.95;

1.95
date	98.06.11.15.20.34;	author johnh;	state Exp;
branches;
next	1.94;

1.94
date	98.05.15.10.48.44;	author johnh;	state Exp;
branches;
next	1.93;

1.93
date	98.05.14.11.30.09;	author johnh;	state Exp;
branches;
next	1.92;

1.92
date	98.04.01.12.16.42;	author johnh;	state Exp;
branches;
next	1.91;

1.91
date	98.03.26.11.38.48;	author johnh;	state Exp;
branches;
next	1.90;

1.90
date	98.02.19.11.01.55;	author mitchell;	state Exp;
branches;
next	1.89;

1.89
date	98.02.17.17.36.24;	author johnh;	state Exp;
branches;
next	1.88;

1.88
date	98.01.27.16.47.26;	author johnh;	state Exp;
branches;
next	1.87;

1.87
date	97.11.06.13.00.20;	author johnh;	state Exp;
branches;
next	1.86;

1.86
date	97.10.06.10.40.17;	author johnh;	state Exp;
branches;
next	1.85;

1.85
date	97.09.05.11.12.44;	author johnh;	state Exp;
branches
	1.85.1.1
	1.85.2.1;
next	1.84;

1.84
date	97.08.06.14.52.25;	author brucem;	state Exp;
branches;
next	1.83;

1.83
date	97.07.23.14.25.44;	author johnh;	state Exp;
branches;
next	1.82;

1.82
date	97.07.18.09.46.24;	author johnh;	state Exp;
branches;
next	1.81;

1.81
date	97.06.18.08.27.35;	author johnh;	state Exp;
branches;
next	1.80;

1.80
date	97.06.16.14.04.38;	author johnh;	state Exp;
branches;
next	1.79;

1.79
date	97.06.13.09.50.50;	author johnh;	state Exp;
branches;
next	1.78;

1.78
date	97.05.20.15.57.11;	author johnh;	state Exp;
branches;
next	1.77;

1.77
date	97.05.19.11.29.29;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	97.05.13.16.28.11;	author johnh;	state Exp;
branches;
next	1.75;

1.75
date	97.05.09.11.22.21;	author daveb;	state Exp;
branches;
next	1.74;

1.74
date	97.05.02.17.22.18;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	97.03.17.14.41.34;	author johnh;	state Exp;
branches
	1.73.1.1;
next	1.72;

1.72
date	97.03.06.17.50.06;	author daveb;	state Exp;
branches;
next	1.71;

1.71
date	96.12.11.16.40.34;	author daveb;	state Exp;
branches
	1.71.1.1
	1.71.2.1;
next	1.70;

1.70
date	96.11.21.12.25.17;	author jont;	state Exp;
branches
	1.70.1.1;
next	1.69;

1.69
date	96.11.15.15.28.42;	author daveb;	state Exp;
branches;
next	1.68;

1.68
date	96.11.12.11.44.52;	author daveb;	state Exp;
branches
	1.68.1.1;
next	1.67;

1.67
date	96.11.12.11.44.52;	author daveb;	state Exp;
branches;
next	1.66;

1.66
date	96.11.06.11.17.18;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	96.11.04.12.55.22;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	96.11.01.17.42.55;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	96.11.01.13.50.07;	author johnh;	state Exp;
branches;
next	1.62;

1.62
date	96.10.31.10.21.15;	author johnh;	state Exp;
branches;
next	1.61;

1.61
date	96.10.09.15.43.31;	author io;	state Exp;
branches;
next	1.60;

1.60
date	96.09.23.14.03.37;	author matthew;	state Exp;
branches
	1.60.1.1
	1.60.2.1;
next	1.59;

1.59
date	96.09.19.13.06.04;	author johnh;	state Exp;
branches;
next	1.58;

1.58
date	96.08.14.11.46.34;	author daveb;	state Exp;
branches
	1.58.1.1;
next	1.57;

1.57
date	96.08.06.16.41.43;	author daveb;	state Exp;
branches;
next	1.56;

1.56
date	96.07.30.14.37.56;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	96.07.29.09.24.48;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	96.07.05.14.41.36;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	96.07.04.09.28.11;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	96.05.31.16.16.04;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	96.05.28.13.04.20;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	96.05.28.09.39.47;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	96.05.24.10.30.24;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	96.05.16.11.00.01;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	96.05.09.14.27.34;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	96.05.01.10.38.59;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	96.04.30.09.58.03;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	96.04.18.15.00.51;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	96.04.18.10.26.39;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	96.03.15.10.25.51;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	96.03.12.10.54.31;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	96.02.26.15.25.56;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	96.02.09.11.28.33;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	96.01.31.17.23.49;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	96.01.25.17.10.54;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	96.01.15.09.40.18;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	96.01.12.16.13.16;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	96.01.12.12.16.48;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	96.01.10.14.00.21;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	96.01.10.12.33.51;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	96.01.09.13.55.28;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	96.01.05.14.57.46;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	95.12.13.10.15.59;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	95.12.07.14.06.32;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	95.11.29.14.52.31;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	95.11.21.14.44.26;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	95.11.17.11.16.58;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	95.11.15.15.18.12;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	95.11.14.14.52.20;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	95.10.26.16.12.22;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	95.10.17.10.27.48;	author nickb;	state Exp;
branches;
next	1.20;

1.20
date	95.10.10.12.18.25;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	95.10.08.23.31.30;	author brianm;	state Exp;
branches;
next	1.18;

1.18
date	95.10.05.15.49.22;	author brianm;	state Exp;
branches;
next	1.17;

1.17
date	95.10.05.10.17.26;	author brianm;	state Exp;
branches;
next	1.16;

1.16
date	95.10.04.12.09.03;	author brianm;	state Exp;
branches;
next	1.15;

1.15
date	95.10.04.10.56.13;	author brianm;	state Exp;
branches;
next	1.14;

1.14
date	95.09.27.15.40.43;	author brianm;	state Exp;
branches;
next	1.13;

1.13
date	95.09.22.11.11.51;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	95.09.21.15.55.40;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	95.09.18.13.22.19;	author brianm;	state Exp;
branches;
next	1.10;

1.10
date	95.09.11.13.23.24;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	95.09.04.15.13.33;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.08.30.13.19.45;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.08.25.11.21.33;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.08.15.15.07.20;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.08.14.10.44.12;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.10.12.26.01;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.02.15.56.48;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.11.05.35;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.01.03;	author matthew;	state Exp;
branches;
next	;

1.58.1.1
date	96.09.13.11.19.57;	author hope;	state Exp;
branches;
next	;

1.60.1.1
date	96.10.07.16.09.51;	author hope;	state Exp;
branches;
next	;

1.60.2.1
date	96.10.17.11.28.11;	author hope;	state Exp;
branches;
next	;

1.68.1.1
date	96.11.14.12.53.50;	author hope;	state Exp;
branches
	1.68.1.1.1.1;
next	;

1.68.1.1.1.1
date	96.11.28.15.04.45;	author hope;	state Exp;
branches;
next	;

1.70.1.1
date	96.11.22.18.12.43;	author hope;	state Exp;
branches;
next	;

1.71.1.1
date	96.12.17.17.51.12;	author hope;	state Exp;
branches
	1.71.1.1.1.1;
next	;

1.71.1.1.1.1
date	97.02.24.11.41.41;	author hope;	state Exp;
branches;
next	;

1.71.2.1
date	96.12.18.09.45.26;	author hope;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	96.12.18.14.41.50;	author johnh;	state Exp;
branches;
next	;

1.73.1.1
date	97.05.12.10.37.56;	author hope;	state Exp;
branches
	1.73.1.1.1.1
	1.73.1.1.2.1
	1.73.1.1.3.1;
next	;

1.73.1.1.1.1
date	97.07.28.18.23.02;	author daveb;	state Exp;
branches;
next	1.73.1.1.1.2;

1.73.1.1.1.2
date	97.08.05.09.19.47;	author johnh;	state Exp;
branches;
next	1.73.1.1.1.3;

1.73.1.1.1.3
date	97.08.05.11.21.00;	author johnh;	state Exp;
branches
	1.73.1.1.1.3.1.1;
next	;

1.73.1.1.1.3.1.1
date	97.10.07.11.48.46;	author jkbrook;	state Exp;
branches;
next	;

1.73.1.1.2.1
date	97.09.08.17.16.27;	author daveb;	state Exp;
branches;
next	;

1.73.1.1.3.1
date	97.09.09.14.12.26;	author daveb;	state Exp;
branches;
next	;

1.85.1.1
date	97.09.10.19.28.32;	author brucem;	state Exp;
branches;
next	;

1.85.2.1
date	97.09.11.20.58.30;	author daveb;	state Exp;
branches;
next	1.85.2.2;

1.85.2.2
date	97.09.12.14.44.13;	author johnh;	state Exp;
branches;
next	1.85.2.3;

1.85.2.3
date	97.11.19.13.28.58;	author johnh;	state Exp;
branches;
next	1.85.2.4;

1.85.2.4
date	98.01.09.11.11.10;	author johnh;	state Exp;
branches;
next	;

1.107.1.1
date	99.04.01.17.59.01;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.108
log
@[Bug #190553]
Replaced use of basis/exit with utils/mlworks_exit.
@
text
@(*  ==== CAPI IMPLEMENTATION : X/MOTIF  ====
 *
 *  Copyright (C) 1995 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 * $Log: _capi.sml,v $
 * Revision 1.107  1999/03/19  10:27:56  mitchell
 * [Bug #190512]
 * Suppress countdown on splash screen advert
 *
 * Revision 1.106  1999/03/09  16:01:04  mitchell
 * [Bug #190509]
 * Update version strings to 2.1
 *
 * Revision 1.105  1999/03/09  12:36:41  mitchell
 * [Bug #190512]
 * Display Professional advert when starting Personal Edition
 *
 * Revision 1.104  1998/07/30  16:30:00  jkbrook
 * [Bug #30456]
 * Update version to 2.0c0
 *
 * Revision 1.103  1998/07/17  14:59:23  jkbrook
 * [Bug #30436]
 * PERSONAL replaces FREE and STUDENT editions
 *
 * Revision 1.102  1998/07/15  11:10:09  jkbrook
 * [Bug #30435]
 * Remove license-prompting code
 *
 * Revision 1.101  1998/07/02  14:34:47  johnh
 * [Bug #30431]
 * Extend Capi by adding more window attributes to change.
 *
 * Revision 1.100  1998/06/24  14:52:36  johnh
 * [Bug #30433]
 * Use new splash screen.
 *
 * Revision 1.99  1998/06/24  13:21:12  johnh
 * [Bug #30411]
 * Fix problems checking edition and setting time out of spalsh screen.
 *
 * Revision 1.98  1998/06/15  15:24:14  johnh
 * [Bug #30411]
 * Fix path problem in finding splash screen.
 *
 * Revision 1.97  1998/06/12  11:19:37  jkbrook
 * [Bug #30415]
 * Update version info for 2.0b2
 *
 * Revision 1.96  1998/06/11  18:21:30  jkbrook
 * [Bug #30411]
 * Include Free edition
 *
 * Revision 1.95  1998/06/11  15:20:34  johnh
 * [Bug #30411]
 * Add support for free edition splash screen.
 *
 * Revision 1.94  1998/05/15  10:48:44  johnh
 * [Bug #30384]
 * Make sure cancel button is visible on yesno dialog.
 *
 * Revision 1.93  1998/05/14  11:30:09  johnh
 * [Bug #50072]
 * Disable positioning of windows.
 *
 * Revision 1.92  1998/04/01  12:16:42  johnh
 * [Bug #30346]
 * Add Capi.getNextWindowPos().
 *
 * Revision 1.91  1998/03/26  11:38:48  johnh
 * [Bug #50035]
 * Keyboard accelerators now platform specific.
 *
 * Revision 1.90  1998/02/19  11:01:55  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.89  1998/02/17  17:36:24  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.88  1998/01/27  16:47:26  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.87  1997/11/06  13:00:20  johnh
 * [Bug #30125]
 * Move implementation of send_message to Menus.
 *
 * Revision 1.86  1997/10/06  10:40:17  johnh
 * [Bug #30137]
 * Add make_messages_popup.
 *
 * Revision 1.85.2.4  1998/01/09  11:11:10  johnh
 * [Bug #30071]
 * Add Callback.VALUE_CHANGED.
 *
 * Revision 1.85.2.3  1997/11/19  13:28:58  johnh
 * [Bug #30071]
 * Set popup shell attribute DELETE_RESPONSE to DESTROY.
 *
 * Revision 1.85.2.2  1997/09/12  14:44:13  johnh
 * [Bug #30071]
 * Implement new Project Workspace tool.
 *
 * Revision 1.85  1997/09/05  11:12:44  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
 * Revision 1.84  1997/08/06  14:52:25  brucem
 * [Bug #30202]
 * Change utils.lists to basis.list.  Fix bug in GraphicsPort.setAttributes.
 * Added function makeYesNo.  Changed implementation of GraphicsPort.clear_rectangle.
 *
 * Revision 1.83  1997/07/23  14:25:44  johnh
 * [Bug #30182]
 * Add dummy add_del_handler function - used only on Win32.
 *
 * Revision 1.82  1997/07/18  09:46:24  johnh
 * [Bug #20074]
 * Improve license dialog.
 *
 * Revision 1.81  1997/06/18  08:27:35  johnh
 * [Bug #30181]
 * Tidy interrupt button code.
 *
 * Revision 1.80  1997/06/16  14:04:38  johnh
 * [Bug #30174]
 * Set application title from resource file - not here.
 *
 * Revision 1.79  1997/06/13  09:50:50  johnh
 * [Bug #30175]
 * Add all windows to dynamic menu, except top level tools.
 *
 * Revision 1.78  1997/05/20  15:57:11  johnh
 * Adding make_interrupt_button.
 *
 * Revision 1.77  1997/05/19  11:29:29  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.76  1997/05/13  16:28:11  johnh
 * Re-organising menus for Motif.
 *
 * Revision 1.75  1997/05/09  11:22:21  daveb
 * [Bug #30020]
 * Added call to Xm.checkMLWorksResources.
 *
 * Revision 1.74  1997/05/02  17:22:18  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.73  1997/03/17  14:41:34  johnh
 * [Bug #1954]
 * Added dummy function set_min_window_size.
 *
 * Revision 1.72  1997/03/06  17:50:06  daveb
 * [Bug #1083]
 * Changed make_main_popup to use Xm.createPopupShell.
 *
 * Revision 1.71  1996/12/11  16:40:34  daveb
 * Fixed license dialog to work correctly on Irix 5.3.
 *
 * Revision 1.70  1996/11/21  12:25:17  jont
 * [Bug #1799]
 * Modify check_insertion to return its string argument
 * This is for compatibility with windows
 *
 * Revision 1.69  1996/11/15  15:28:42  daveb
 * Added dummy function for splash sreen which is implemented on Windows.
 *
 * Revision 1.68  1996/11/12  11:44:52  daveb
 * Added license_prompt and license_complain.
 *
 * Revision 1.66  1996/11/06  11:17:18  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.65  1996/11/04  12:55:22  daveb
 * [Bug #1699]
 * Type of Xm.GC.copy has changed.
 *
 * Revision 1.64  1996/11/01  17:42:55  daveb
 * [Bug #1694]
 * Removed Xm.widget_eq and converted Xm.CompoundString.string_convert_text
 * to standard identifier convention.
 *
 * Revision 1.63  1996/11/01  13:50:07  johnh
 * Enabling close from control box on top left of window.
 *
 * Revision 1.62  1996/10/31  10:21:15  johnh
 * Add interrupt button to Windows.
 *
 * Revision 1.61  1996/10/09  15:43:31  io
 * moving String from toplevel
 *
 * Revision 1.60  1996/09/23  14:03:37  matthew
 * Attempting to add a interrupt button handler thing
 *
 * Revision 1.59  1996/09/19  13:06:04  johnh
 * [Bug #1583]
 * passing has_controlling_tty to exit_mlworks instead of passing false.
 *
 * Revision 1.58  1996/08/14  11:46:34  daveb
 * [Bug #1539]
 * Restored the destroy callback for make_main_window.  This removes a destroyed
 * window from the list of windows.
 *
 * Revision 1.57  1996/08/06  16:41:43  daveb
 * [Bug #1517]
 * Changed definition of Text.end_line to return the current position if it
 * is already at the end of a line.
 *
 * Revision 1.56  1996/07/30  14:37:56  jont
 * Provide a system dependent line terminator
 *
 * Revision 1.55  1996/07/29  09:24:48  daveb
 * [Bug #1478]
 * Set DELETE_RESPONSE of top level tools to do_nothing, and those of popups
 * to unmap.  This prevents users from deleting stack browsers or their parent
 * windows in the middle of an evaluation.
 *
 * Revision 1.54  1996/07/05  14:41:36  daveb
 * [Bug #1260]
 * Changed the Capi layout datatype so that the PANED constructor takes the
 * layout info for its sub-panes.  This enables the Windows layout code to
 * calculate the minimum size of each window.
 *
 * Revision 1.53  1996/07/04  09:28:11  daveb
 * Bug 1378: The Windows menu needs to be cleared when entering or leaving the
 * GUI.  I've changed initialize_application to clear the list of main windows.
 *
 * Revision 1.52  1996/05/31  16:16:04  daveb
 * Bug 1074: Capi.list_select now takes a function to be called on any key
 * press handled by the list widget itself.  In the listener, this pops the
 * completions widget down as if the key had been typed at the listener.
 *
 * Revision 1.51  1996/05/28  13:04:20  matthew
 * Adding reset function
 *
 * Revision 1.50  1996/05/28  09:39:47  daveb
 * Removed unused debugging code (that referenced MLWorks.RawIO).
 *
 * Revision 1.49  1996/05/24  10:30:24  daveb
 * Changed highlight mode used in text widgets to reverse video.
 *
 * Revision 1.48  1996/05/16  11:00:01  matthew
 * Adding Text.convert_text
 *
 * Revision 1.47  1996/05/09  14:27:34  daveb
 * Made read_only_before_prompt true.
 *
 * Revision 1.46  1996/05/01  10:38:59  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.45  1996/04/30  09:58:03  matthew
 * Use basis integer stuff
 *
 * Revision 1.44  1996/04/18  15:00:51  daveb
 * Improved the scrolling behaviour of set_highlight.
 *
 * Revision 1.43  1996/04/18  10:26:39  matthew
 * Adding initialize_graphics and finalize_graphics functions
 *
 * Revision 1.42  1996/03/15  10:25:51  daveb
 * add_items wasn't handling empty lists correctly.
 *
 * Revision 1.41  1996/03/12  10:54:31  matthew
 * Position completion windows not to be under pointer
 *
 * Revision 1.40  1996/02/26  15:25:56  matthew
 * Revisions to Xm library
 *
 * Revision 1.39  1996/02/09  11:28:33  daveb
 * Changed return type of make_scrolllist to a record, with an extra element
 * add_items.  Replaced set_bottom_pos with set_pos (which can be implemented
 * on windows).  Added add_items to the List structure.
 *
 * Revision 1.38  1996/01/31  17:23:49  matthew
 * Adding clear_rectangle again
 *
 * Revision 1.37  1996/01/25  17:10:54  matthew
 * Adding set_selection for text widgets
 *
 * Revision 1.36  1996/01/15  09:40:18  matthew
 * Fixing bungle in last change
 *
 * Revision 1.35  1996/01/12  16:13:16  matthew
 * Adding check_insertion to Text structure
 *
 * Revision 1.34  1996/01/12  12:16:48  daveb
 * Moved file_dialog from gui to motif.
 *
 * Revision 1.33  1996/01/10  14:00:21  daveb
 * Moved definitions of open_file_dialog and save_as_dialog to FileDialog.
 *
 * Revision 1.32  1996/01/10  12:33:51  daveb
 * Replaced find_file with save_as_dialog and open_file_dialog, for Windows.
 *
 * Revision 1.31  1996/01/09  13:55:28  matthew
 * Moving list_select to capi
 *
 * Revision 1.30  1996/01/05  14:57:46  matthew
 * Extra stuff for finding fonts
 *
 * Revision 1.29  1995/12/13  10:15:59  daveb
 * FileDialog now includes a datatype that also needs to be included here.
 *
 * Revision 1.28  1995/12/07  14:06:32  matthew
 * Changing interface to clipboard functions
 *
 * Revision 1.27  1995/11/29  14:52:31  matthew
 * Setting right volume for bell.
 *
 * Revision 1.26  1995/11/21  14:44:26  matthew
 * Adding dummy transfer focus function
 *
 * Revision 1.25  1995/11/17  11:16:58  matthew
 * Adding some stuff for listeners
 *
 * Revision 1.24  1995/11/15  15:18:12  matthew
 * Windows menu
 *
 * Revision 1.23  1995/11/14  14:52:20  matthew
 * Adding add_input_handler
 *
 * Revision 1.22  1995/10/26  16:12:22  daveb
 * Added width resource in make_subwindow.
 *
 * Revision 1.21  1995/10/17  10:27:48  nickb
 * Fix brain-dead X behaviour on filled rectangles.
 *
 * Revision 1.20  1995/10/10  12:18:25  nickb
 * Add Resize callback.
 *
 * Revision 1.19  1995/10/08  23:31:30  brianm
 * Modifying protocol for make_graphics set_position function - negative
 * coordinates signify no change.
 *
 * Revision 1.18  1995/10/05  15:49:22  brianm
 * Providing user-controlled graphics positioning.
 *
 * Revision 1.17  1995/10/05  10:17:26  brianm
 * Minor modification ...
 *
 * Revision 1.16  1995/10/04  12:09:03  brianm
 * Removing fix for scrolling increment in graphics - this has been fixed in
 * the app-defaults files (i.e. the proper place).
 *
 * Revision 1.15  1995/10/04  10:56:13  brianm
 * Improved scrolling in graphics objects (e.g. graph widget)
 *
 * Revision 1.14  1995/09/27  15:40:43  brianm
 * Adding `with_graphics_port' and related facilities.
 *
 * Revision 1.13  1995/09/22  11:11:51  daveb
 * Added Capi.Text.set_highlight.
 *
 * Revision 1.12  1995/09/21  15:55:40  nickb
 * Make scroll bars on graphics ports optional.
 *
 * Revision 1.11  1995/09/18  13:22:19  brianm
 * Updating by adding Capi Point/Region datatypes.
 *
 * Revision 1.10  1995/09/11  13:23:24  matthew
 * Changing top level window initialization
 *
 * Revision 1.9  1995/09/04  15:13:33  matthew
 * Adding make_message_text
 *
 * Revision 1.8  1995/08/30  13:19:45  matthew
 * Updating for windows stuff
 *
 * Revision 1.7  1995/08/25  11:21:33  matthew
 * Updating for Windows changes
 *
 * Revision 1.6  1995/08/15  15:07:20  matthew
 * Removing PushButton class
 *
 * Revision 1.5  1995/08/14  10:44:12  matthew
 * make_main_subwindows shouldn't manage the form.
 *
 * Revision 1.4  1995/08/10  12:26:01  matthew
 * Modifications for PC port
 *
 * Revision 1.3  1995/08/02  15:56:48  matthew
 * Adding event handler stuff
 *
 * Revision 1.2  1995/07/27  11:05:35  matthew
 * Moved capi to gui
 *
 * Revision 1.1  1995/07/26  14:01:03  matthew
 * new unit
 * New unit
 *
 *  Revision 1.6  1995/07/26  13:19:17  matthew
 *  Adding support for font dimensions etc.
 *
 *  Revision 1.5  1995/07/18  09:13:46  matthew
 *  Removing real constant for pi so we can compile in a lambda
 *
 *  Revision 1.4  1995/07/14  14:41:01  matthew
 *  Adding new stuff, including preliminary graphics ports
 *
 *  Revision 1.3  1995/07/07  15:21:55  daveb
 *  Minor changes to paned windows.
 *
 *  Revision 1.2  1995/07/04  14:50:57  matthew
 *  More stuff
 *
 *  Revision 1.1  1995/06/29  15:57:06  matthew
 *  new unit
 *  New "window system independent" interface
 *
 *
 * Copyright (c) 1995 Harlequin Ltd.
 *
 *)


require "../basis/__int";
require "../basis/__os";
require "../basis/__command_line";

require "xm";
require "file_dialog";
require "^.gui.menus";
require "^.utils.crash";
require "^.utils.lists";
require "^.basis.__list";
require "^.utils.lisp";
require "^.utils.getenv";
require "^.main.version";

require "^.gui.capi";

functor Capi (structure Xm: XM 
              structure FileDialog : FILE_DIALOG
              structure Menus : MENUS
              structure Crash : CRASH
              structure Lists : LISTS
              structure LispUtils : LISP_UTILS
	      structure Getenv : GETENV
	      structure Version : VERSION
              sharing type Xm.widget = FileDialog.Widget = Menus.Widget
                ): CAPI =
struct

  structure BasisList = List (* having a List structure in this 
                                would otherwise prevent us from
                                using the basis. *)

  (* Some things are now pulled directly out from the runtime *)
  val cast = MLWorks.Internal.Value.cast
  fun env s = cast (MLWorks.Internal.Runtime.environment s)

  val N = Int.toString

  datatype Point = POINT of { x : int, y : int }

  val origin = POINT{x=0,y=0}

  datatype Region = REGION of { x : int, y :int, width : int, height :int }

  type Widget = Xm.widget
  type Font = Xm.font

  (* This exn can be raised when an inner event loop is terminated *)
  exception SubLoopTerminated = Xm.SubLoopTerminated
  exception WindowSystemError = Xm.XSystemError

  val sep_size = 10

  val main_windows : (Widget * string) list ref = ref []

  fun push (a,r) = r := a :: !r

  fun delete (a:Widget,[]) = []
    | delete (a,((item as (a',_))::rest)) =
    if a = a' then delete (a,rest) else item::delete (a,rest)

  fun add_main_window (w, title) = push ((w, title), main_windows)
  fun remove_main_window w = main_windows := delete (w,!main_windows)

  fun get_main_windows _ = !main_windows

  fun restart () =
    main_windows := []

  val next_window = ref (100,100)

  fun getNextWindowPos () = 
    let 
      val (curX, curY) = !next_window
      val inc = 30
    in
      if (curX < (100 + inc * 6)) then
	next_window := (curX + inc, curY + inc)
      else
	next_window := (100, curY - inc * 6);
      (curX, curY)
    end

  fun initialize_application (name, title, has_controlling_tty) =
    let
      val applicationShell =
        Xm.initialize (name, title, [(Xm.ICON_NAME, Xm.STRING title)])
    in
      push ((applicationShell, title), main_windows);
      ignore(Xm.checkMLWorksResources ());
      restart ();
      applicationShell
    end

  datatype WidgetAttribute = 
      PanedMargin of bool
    | Position of    int * int
    | Size of        int * int
    | ReadOnly of    bool

  datatype WidgetClass = Frame | Graphics | Label | Button | Text | RowColumn | Paned | Form
    
  fun convert_widget_class class =
    case class of
      Frame => (Xm.Widget.FRAME,[])
    | Graphics => (Xm.Widget.DRAWING_AREA,[])
    | Label => (Xm.Widget.LABEL_GADGET,[])
    | Button => (Xm.Widget.PUSH_BUTTON,[])
    | Text => (Xm.Widget.TEXT,[])
    | RowColumn => (Xm.Widget.ROW_COLUMN,[])
    | Paned => (Xm.Widget.PANED_WINDOW, [(Xm.SPACING, Xm.INT 20)])
    | Form => (Xm.Widget.FORM,[])

  fun convert_widget_attributes (PanedMargin true) =
      [(Xm.MARGIN_WIDTH, Xm.INT sep_size)]
    | convert_widget_attributes (PanedMargin false) =
      [(Xm.MARGIN_WIDTH, Xm.INT 0)]
    | convert_widget_attributes (Position (x,y)) = 
      [(Xm.X, Xm.INT x), (Xm.Y, Xm.INT y)]
    | convert_widget_attributes (Size (w,h)) = 
      [(Xm.WIDTH, Xm.INT w), (Xm.HEIGHT, Xm.INT h)]
    | convert_widget_attributes (ReadOnly tf) = 
      [(Xm.EDITABLE, Xm.BOOL (not tf))]

  fun setAttribute (widg, attrib) = 
    Xm.Widget.valuesSet (widg, convert_widget_attributes attrib)

  fun make_widget (name,class,parent,attributes) =
    let
      val (xm_class, fixed_attributes) = convert_widget_class class 
      val parameter_attributes = 
	foldl (op @@) [] (map convert_widget_attributes attributes)
    in
      Xm.Widget.create
	(name, xm_class, parent,
	 fixed_attributes @@ parameter_attributes)
    end

  fun make_managed_widget (name,class,parent,attributes) =
    let
      val (xm_class, fixed_attributes) = convert_widget_class class 
      val parameter_attributes = 
	foldl (op @@) [] (map convert_widget_attributes attributes)
    in
      Xm.Widget.createManaged
	(name, xm_class, parent,
	 fixed_attributes @@ parameter_attributes)
    end

  (* Utility functions for creating the main window of a tool *)

  fun make_main_subwindows (parent,has_context_label) =
    let
      val mainWindow =
        Xm.Widget.create ("main",
                          Xm.Widget.FORM,
                          parent, [])
      val menuBar =
        Xm.Widget.createManaged
        ("menuBar", Xm.Widget.ROW_COLUMN, mainWindow, [])

      val contextLabel =
        if has_context_label then
          SOME
          (Xm.Widget.createManaged
           ("contextLabel", Xm.Widget.LABEL,mainWindow,
            []))
        else
          NONE
    in
      (mainWindow,menuBar,contextLabel)
    end

  fun make_subwindow parent =
    Xm.Widget.create ("main",
                      Xm.Widget.FORM,
                      parent, [(Xm.WIDTH, Xm.INT 300)])

  (* N.B. pos argument ignored as this would interfere with some window managers *)
  fun make_main_window {name, title, parent, contextLabel, winMenu, pos: int * int} =
    let
      val shell =
        Xm.Widget.create
	  (name ^ "Shell",
           Xm.Widget.TOP_LEVEL_SHELL,
           parent,
           [(Xm.TITLE, Xm.STRING title),
            (Xm.ICON_NAME, Xm.STRING title),
	    (Xm.DELETE_RESPONSE, Xm.DELETE_RESPONSE_VALUE Xm.DO_NOTHING)])
      (* Set the deleteResponse attribute to do_nothing.  This prevents
	 users from killing the tool.  If they did this in the middle of
	 an evaluation, it could cause problems. *)

      val (main,menu,label) = make_main_subwindows (shell, contextLabel)
    in
      (* The windows contained in the tools menu do not need to be added to the 
       * dynamic list of windows, but other windows are created by this function,
       * so a distinction is needed.
       *)
      if winMenu then 
	push((shell, title), main_windows) 
      else ();
      Xm.Callback.add
	(shell, Xm.Callback.DESTROY, fn _ => remove_main_window shell);
      Xm.Widget.manage main;
      (shell,main,menu,label)
    end

  (* pos argument ignored as this interferes with some window managers. *)
  fun make_main_popup {name, title, parent, contextLabel, visibleRef, pos: int * int} =
    let
      val shell =
	Xm.Widget.createPopupShell
	  (name ^ "Shell",
           Xm.Widget.DIALOG_SHELL,
           parent,
           [(Xm.TITLE, Xm.STRING title),
            (Xm.ICON_NAME, Xm.STRING title),
	    (Xm.DELETE_RESPONSE, Xm.DELETE_RESPONSE_VALUE Xm.UNMAP)])
      (* Set the deleteResponse attribute to unmap, so that users cannot
	 destroy the window. *)

      val (main,menu,label) = make_main_subwindows (shell,contextLabel)
    in
      (* If the window is initially hidden (eg. stack browser) then don't 
       * add the window name to the windows menu - this will be done when 
       * is brought up.
       *)
      if (!visibleRef) then 
	push ((shell, title), main_windows) 
      else ();
      (shell,main,menu,label)
    end

  fun make_messages_popup (parent, visible) = 
    make_main_popup {name = "messages", 
		     title = "System Messages", 
		     parent = parent, 
		     contextLabel = false, 
		     visibleRef = visible,
		     pos = getNextWindowPos()}

  fun make_popup_shell (name,parent,attributes,visible) =
    let 
      val parameter_attributes = 
	foldl (op @@) [] (map convert_widget_attributes attributes)
    in
      Xm.Widget.createPopupShell 
	(name,
         Xm.Widget.DIALOG_SHELL,
         parent, 
	 [(Xm.DELETE_RESPONSE, Xm.DELETE_RESPONSE_VALUE Xm.DESTROY)] @@ 
	   parameter_attributes)
    end

  fun make_toplevel_shell (name,title,parent,attributes) =
    let 
      val parameter_attributes = 
	foldl (op @@) [] (map convert_widget_attributes attributes)
    in
      Xm.Widget.create (name,
                        Xm.Widget.TOP_LEVEL_SHELL,
                        parent,
                        [(Xm.TITLE, Xm.STRING title),
                         (Xm.ICON_NAME, Xm.STRING title)] @@ 
			parameter_attributes)
    end

  fun make_scrolled_text (name,parent,attributes) =
    let
      val parameter_attributes = 
	foldl (op @@) [] (map convert_widget_attributes attributes)
      val text =
        Xm.Widget.createScrolledText (parent, name, parameter_attributes)
    in
      Xm.Widget.manage text;
      (Xm.Widget.parent text,text)
    end

(* Dummy function used in Win32 only.  To set minimum window sizes in Moitf, 
 * use the resources in app-defaults. *)
  fun set_min_window_size _ = ()

  fun make_scrolllist {parent, name, select_fn, action_fn, print_fn} =
    let
      val listScroll = Xm.Widget.createManaged("scroll",
                                               Xm.Widget.SCROLLED_WINDOW,
                                               parent,[])
      val listList =
        Xm.Widget.createManaged ("list",
                                 Xm.Widget.LIST,
                                 listScroll,
                                 [])

      val itemlistref = ref []

      fun get_selected_pos callback_data =
        let
          val (_,_,_,_,n,_,_,_,_) = Xm.Callback.convertList callback_data
        in
          n
        end

      fun set_items print_options [] =
        (itemlistref := [];
         Xm.List.deleteAllItems listList;
         Xm.List.addItems
	   (listList, [Xm.CompoundString.createSimple "<empty>"], 0))
      |   set_items print_options items =
        (itemlistref := items;
         Xm.List.deleteAllItems listList;
         Xm.List.addItems
	   (listList,
            map (Xm.CompoundString.createSimple o
		   (print_fn print_options))
		 items,
            0))

      fun add_items print_options items =
	(case !itemlistref
	 of [] =>
	   (* The list widget displays "<empty>"; we must delete this. *)
           Xm.List.deleteAllItems listList
	 |  _ => ();
         itemlistref := !itemlistref @@ items;
         Xm.List.addItems
	   (listList,
            map (Xm.CompoundString.createSimple o
		   (print_fn print_options))
		items,
            0))

      val select_fn' = select_fn (listScroll, listList, set_items, add_items)
      val action_fn' = action_fn (listScroll, listList, set_items, add_items)

      fun select_callback_fn callback_data =
        let
          val pos = get_selected_pos callback_data
        in
          select_fn' (Lists.nth (pos-1,!itemlistref))
          handle Lists.Nth => ()
        end

      fun action_callback_fn callback_data =
        let
          val pos = get_selected_pos callback_data
        in
          action_fn' (Lists.nth (pos-1,!itemlistref))
          handle Lists.Nth => ()
        end
    in
      Xm.Callback.add (listList,
                             Xm.Callback.SINGLE_SELECTION,
                             select_callback_fn);
      Xm.Callback.add (listList,
                             Xm.Callback.DEFAULT_ACTION,
                             action_callback_fn);
      {scroll=listScroll, list=listList,
       set_items=set_items, add_items=add_items}
    end

  fun make_file_selection_box (name,parent,attributes) =
    let
      val box = Xm.Widget.createManaged
        (name,
         Xm.Widget.FILE_SELECTION_BOX,
         parent, [])
      val filter_text =
        Xm.FileSelectionBox.getChild(box, Xm.Child.FILTER_TEXT)

      (* This pulls the selected filename out of the file selection box *)
      fun get_file () =
        (case Xm.Widget.valuesGet(box,[Xm.DIR_SPEC]) of
           [Xm.COMPOUND_STRING filename] =>
             Xm.CompoundString.convertStringText filename
         | _ => Crash.impossible "Bad values for valuesGet (get_file)")

      fun get_directory () = Xm.Text.getString filter_text
      fun set_directory s = 
        Xm.Widget.valuesSet (box, [(Xm.DIRECTORY, Xm.COMPOUND_STRING (Xm.CompoundString.createSimple s))])
      fun set_mask s =
        (Xm.Widget.valuesSet
         (box, [(Xm.DIR_MASK, Xm.COMPOUND_STRING (Xm.CompoundString.createSimple s))]))
      fun get_mask () =
        (case Xm.Widget.valuesGet(box,[Xm.DIR_MASK]) of
           [Xm.COMPOUND_STRING mask] => mask
         | _ => Crash.impossible "Bad values for valuesGet (get_dir_mask)")
      val dir_list = Xm.FileSelectionBox.getChild(box, Xm.Child.DIR_LIST)
    in
      (* Remove the buttons *)
      app 
      (fn c =>
       Xm.Widget.unmanageChild (Xm.FileSelectionBox.getChild(box,c)))
      [Xm.Child.CANCEL_BUTTON,
       Xm.Child.OK_BUTTON,
       Xm.Child.APPLY_BUTTON,
       Xm.Child.SEPARATOR,
       Xm.Child.HELP_BUTTON];
	(* Removing the OK and APPLY buttons does interesting things to
	   the behaviour of the file selection box.  Some thing stop
	   working, so here we recreate them by hand.  *)
      Xm.Callback.add
      (dir_list,
       Xm.Callback.DEFAULT_ACTION,
       fn x => 
       let val item = #3 (Xm.Callback.convertList x)
       in
         Xm.Widget.valuesSet
         (box, [(Xm.DIRECTORY, Xm.COMPOUND_STRING item)])
       end);
      Xm.Callback.add
      (filter_text,
       Xm.Callback.ACTIVATE,
       fn _ => Xm.FileSelectionBox.doSearch (box, get_mask ()));
      (box,
       {get_file = get_file,
        set_directory = set_directory,
        get_directory = get_directory,
        set_mask = set_mask})
    end

  (* Widget functions *)
  val destroy = Xm.Widget.destroy

  val remove_menu = destroy

  fun initialize_toplevel shell= 
    (Xm.Widget.realize shell;
     Xm.Widget.map shell)

  fun initialize_application_shell shell =
    Xm.Widget.realize shell

  val reveal = Xm.Widget.manage
  val hide = Xm.Widget.unmanageChild
  val to_front = Xm.Widget.toFront

  (* This doesn't seem necessary for Motif *)
  (* perhaps it should do something though *)
  fun transfer_focus _ = ()

  fun set_sensitivity (widget,sensitivity) =
    Xm.Widget.valuesSet (widget,[(Xm.SENSITIVE, Xm.BOOL sensitivity)])

  (* set the label string of a label widget *)  
  fun set_label_string (label,s) =
    let
      val cstring = Xm.CompoundString.createSimple s
    in
      Xm.Widget.valuesSet (label, 
                           [(Xm.LABEL_STRING, Xm.COMPOUND_STRING cstring)])
    end
  
  fun set_focus w = 
    (ignore(Xm.Widget.processTraversal (w, Xm.Widget.TRAVERSE_CURRENT));
     ())

  val parent = Xm.Widget.parent

  fun widget_size widget =
    case Xm.Widget.valuesGet (widget,[Xm.WIDTH,Xm.HEIGHT]) of
      [Xm.INT width,Xm.INT height] => (width,height) 
    | _ => Crash.impossible "Capi:widget_size:bad result from valuesGet"

  fun widget_pos widget =
    case Xm.Widget.valuesGet (widget,[Xm.X,Xm.Y]) of
      [Xm.INT horz,Xm.INT vert] => (horz,vert) 
    | _ => Crash.impossible "Capi:widget_pos:bad result from valuesGet"

  val set_message_widget : Widget -> unit = env "x text set message widget"
  val no_message_widget : unit -> unit = env "x text no message widget"
  val set_busy : Widget -> unit = env "x widget set busy"
  val unset_busy : Widget -> unit = env "x widget unset busy"

  fun event_loop continue = while (!continue) do Xm.doInput ();
  fun main_loop () = Xm.mainLoop ()

  open FileDialog
  (* This defines the FileType datatype and the find_file, open_file_dialog
     and save_as_dialog functions. *)

  val send_message = Menus.send_message

  fun with_message (parent,message) f =
    let
      val _ = set_busy parent
      val result = f () 
        handle exn as Xm.SubLoopTerminated => raise exn
             | exn => (unset_busy parent; raise exn)
    in
      unset_busy parent;
      result
    end

  fun beep widget = Xm.Display.bell (Xm.Widget.display widget,0)

  structure Event = 
    struct
      type Modifier = Xm.Event.modifier
      val meta_modifier = Xm.Event.MOD1
      datatype Button = LEFT | RIGHT | OTHER
      fun get_key_data event =
        case event of
          Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key,state,...}) =>
            SOME (key, Xm.Event.convertState state)
        | _ => NONE
      fun convert_button buttondata =
        case Xm.Event.convertButton buttondata of
          Xm.Event.BUTTON1 => LEFT
        | Xm.Event.BUTTON3 => RIGHT
        | _ => OTHER
      fun get_button_data event =
        case event of
          Xm.Event.BUTTON_PRESS (Xm.Event.BUTTON_EVENT {x,y,button,...}) =>
            SOME (POINT {x=x,y=y}, convert_button button)
        | _ => NONE
      datatype EventType = KeyPress | ButtonPress | Other
      fun get_event_type event =
        case event of
          Xm.Event.KEY_PRESS _ => KeyPress
        | Xm.Event.BUTTON_PRESS _ => ButtonPress
        | _ => Other
    end

  structure Callback =
    struct
      datatype Type =
	Activate
      | Destroy
      | Unmap
      | Resize
      | ValueChange

      fun add (w,t,f) =
        let
          val xt =
            case t of
              Activate => Xm.Callback.ACTIVATE
            | Destroy => Xm.Callback.DESTROY
            | Unmap => Xm.Callback.UNMAP
	    | Resize => Xm.Callback.RESIZE
	    | ValueChange => Xm.Callback.VALUE_CHANGED
        in
          Xm.Callback.add (w,xt,fn _ => f ())
        end
      fun get_event data =
        #2 (Xm.Callback.convertAny data)
      end

(* set_close_callback not used in Motif *)
  fun set_close_callback _ = ()

  structure List =
    struct
      val get_selected_pos = Xm.List.getSelectedPos
      val select_pos = Xm.List.selectPos
      val set_pos = Xm.List.setPos
      fun add_items (w, l) = 
	Xm.List.addItems (w, map Xm.CompoundString.createSimple l, 0)
    end

  fun move_window (widget, x, y) = ()
  fun size_window (widget, w, h) = 
    Xm.Widget.valuesSet (widget, [(Xm.WIDTH, Xm.INT w),
				  (Xm.HEIGHT, Xm.INT h)])

  structure Text =
    struct
      (* add_del_handler only used on Win32 *)
      fun add_del_handler _ = ()

      (* Interface to various Xm functions *)
      (* insert str at pos in text *)
      fun insert (text,pos,str) =
        Xm.Text.insert (text,pos,str)
        
      fun replace (text,from,to,str) =
        Xm.Text.replace (text,from,to,str)
        
      (* set and get the "insertion position" *)
      fun set_insertion_position (text,pos) =
        Xm.Text.setInsertionPosition (text, pos)
        
      fun get_insertion_position text =
        Xm.Text.getInsertionPosition text
        
      (* get the "last" position *)
      fun get_last_position text =
        Xm.Text.getLastPosition text
        
      (* substring of the text contents *)
      fun substring (text,from,size) =
        let
          val str = Xm.Text.getString text
        in
          MLWorks.String.substring (str,from,size)
        end

      val get_string = Xm.Text.getString
      val set_string = Xm.Text.setString

      local
	fun showPosition (w, s) =
	  case Xm.Text.posToXY (w, s)
	  of SOME _ => ()
	  |  NONE =>
	    Xm.Text.setTopCharacter (w, s)
      in
        fun set_highlight (w, s, e, true) =
	  (Xm.Text.setHighlight (w, s, e, Xm.HIGHLIGHT_SELECTED);
	   showPosition (w, s))
        |   set_highlight (w, s, e, false) =
	  (Xm.Text.setHighlight (w, s, e, Xm.HIGHLIGHT_NORMAL);
	   showPosition (w, s))
      end

      val get_selection = Xm.Text.getSelection
      val set_selection = Xm.Text.setSelection
      val remove_selection = Xm.Text.remove

      (* some more complex utility functions *)
    
      local
        fun lastline (str, ~1) = 0
          | lastline (str,n) =
            if MLWorks.String.ordof (str, n) = ord #"\n"
              then n+1
            else lastline (str,n-1)
      in
        (* Return the line containing pos, and the index of its first character *)
        fun get_line_and_index (text,pos) =
          let
            val str = Xm.Text.getString text
            val length = size str
              
            fun nextline n =
              if n = length orelse MLWorks.String.ordof (str, n) = ord #"\n" then
                n
              else
                nextline (n+1)
            val start = lastline (str,pos-1)
            val finish = nextline pos
            val result = MLWorks.String.substring (str, start, finish - start)
          in
            (result,pos - start)
          end
        
        (* Returns the index of the line containing pos *)
        fun current_line (text,pos) =
          lastline (Xm.Text.getString text,pos-1)
          
        (* Returns the index of the line after the line containing pos *)
        fun end_line (text,pos) =
          let
            val str = Xm.Text.getString text
            val length = size str
            fun aux n = 
              if n = length orelse MLWorks.String.ordof (str, n) = ord #"\n" then
                n
              else
                aux (n+1)
          in
	    if pos > length then pos else aux pos
          end
        
        val get_line = #1 o get_line_and_index

        fun convert_verify_data data =
          let
            val (_,_,doit,_,_,start_pos,end_pos,str) =
              Xm.Callback.convertTextVerify data
          in
            (start_pos,end_pos,str,fn b => Xm.Boolean.set (doit,b))
          end

        fun add_modify_verify (widget,f) =
          Xm.Callback.add (widget,Xm.Callback.MODIFY_VERIFY,
                                 fn data => f (convert_verify_data data))

        val cut_selection : Widget -> unit = Xm.Text.cut
        val paste_selection : Widget -> unit = Xm.Text.paste
        val delete_selection : Widget -> unit = Xm.Text.remove
        val copy_selection : Widget -> unit = Xm.Text.copy

      end

      (* nasty hack *)
      val read_only_before_prompt = true

      (* Just here for Windows *)
      fun check_insertion (text, str, current, marks) = str

          fun activate (text, handler) callback_data =
            let 
              val event = Callback.get_event callback_data
            in
              case Event.get_key_data event of
                SOME (key,modifiers) =>
                  if handler (key,modifiers)
                    then ()
                  else beep text
              | _ => beep text
            end

      fun add_handler (text,handler) =
        Xm.Callback.add (text,Xm.Callback.ACTIVATE,activate (text, handler))

      fun get_key_bindings {startOfLine, endOfLine, backwardChar, forwardChar, 
			    previousLine, nextLine, eofOrDelete, abandon,
			    deleteToEnd, newLine, delCurrentLine, checkCutSel,
			    checkPasteSel} = 
	 [("\^A", startOfLine), 
	  ("\^B", backwardChar),
	  ("\^D", eofOrDelete),
	  ("\^E", endOfLine),
	  ("\^F", forwardChar),
	  ("\^G", abandon),
	  ("\^K", deleteToEnd),
	  ("\^N", nextLine),
	  ("\^O", newLine),
	  ("\^P", previousLine),
	  ("\^U", delCurrentLine),
	  ("\^W", checkCutSel),
	  ("\^Y", checkPasteSel)]

      fun text_size s = size s
      fun convert_text s = s
    end

  structure Layout =
    struct
      datatype Class =
        MENUBAR of Widget
      | FLEX of Widget
      | FIXED of Widget
      | FILEBOX of Widget
      | PANED of Widget * (Widget * Class list) list
      | SPACE

      (* Some abbreviations. *)

      val top_none = [(Xm.TOP_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_NONE)]
      val bottom_none = [(Xm.BOTTOM_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_NONE)]
      val top_form = [(Xm.TOP_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM)]
      val bottom_form = [(Xm.BOTTOM_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM)]
      val lr_form = [(Xm.LEFT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
                     (Xm.RIGHT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM)]

      val top_offset = (Xm.TOP_OFFSET, Xm.INT sep_size)
      val bottom_offset = (Xm.BOTTOM_OFFSET, Xm.INT sep_size)
      val lr_offsets = [(Xm.LEFT_OFFSET, Xm.INT sep_size),
                        (Xm.RIGHT_OFFSET, Xm.INT sep_size)]

      (* top_widget/bottom_widget return a top/bottom attachment to the widget *)
      (* in the specified class. *)
      fun top_widget c =
        let
          fun aux w =
            [(Xm.TOP_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
             (Xm.TOP_WIDGET, Xm.WIDGET w)]
        in
          case c
            of MENUBAR w => aux w
             |  FLEX w => aux w
             |  FILEBOX w => aux w
             |  FIXED w => aux w
             |  PANED (w, _) => aux w
             |  SPACE => Crash.impossible "SPACE argument to top_widget"
        end
    
      fun bottom_widget c =
        let
          fun aux w =
            [(Xm.BOTTOM_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
             (Xm.BOTTOM_WIDGET, Xm.WIDGET w)]
        in
          case c
            of MENUBAR w => aux w
             |  FLEX w => aux w
             |  FILEBOX w => aux w
             |  FIXED w => aux w
             |  PANED (w, _) => aux w
             |  SPACE => Crash.impossible "SPACE argument to bottom_widget"
        end
      
  (* find_flex splits a list into those elements before the first flex 
   widget and the rest. *)
  local 
    fun find_flex' (acc, []) = (rev acc, [])
      |   find_flex' (acc, l as FLEX flex :: _) = (rev acc, l)
      |   find_flex' (acc, c :: rest) = find_flex' (c::acc, rest)
  in
    fun find_flex l = find_flex' ([], l)
  end

  (* The trim_spaces function removes duplicate and trailing SPACE specifiers.
     It returns the modified list and a boolean which is true iff there were
     trailing SPACE specifiers.
   *)
  fun trim_spaces [] = ([], false)
    |   trim_spaces [SPACE] = ([], true)
    |   trim_spaces (SPACE :: (rest as SPACE :: _)) = trim_spaces rest
    |   trim_spaces (spec :: rest) =
        let
          val (rest', b) = trim_spaces rest
        in
          (spec :: rest', b)
        end
      
  (* lay_out_one sets the constraints for an individual widget.  The left
     and right constraints depend only on the type of the widget.  The top
     and/or bottom constraints are passed as an argument.
     This now includes a recursive call to the topmost lay_out function,
     which makes all the following functions mutually recursive.
   *)
  fun lay_out_one (MENUBAR w, attach) =
    Xm.Widget.valuesSet (w, attach @@ lr_form)
  |   lay_out_one (SPACE, _) =
    Crash.impossible "SPACE argument to lay_out_one"
  |   lay_out_one (PANED (w, sub_classes), attach) =
    (app lay_out (map (fn (a,b) => (a,NONE,b)) sub_classes);
     Xm.Widget.valuesSet
     (* The offset 2 is to allow room for the 3D border in the parent *)
       (w, attach @@ lr_form @@
           [(Xm.LEFT_OFFSET, Xm.INT 2), (Xm.RIGHT_OFFSET, Xm.INT 2)]))
  |   lay_out_one (FILEBOX w, attach) =
    (* No offsets *)
    Xm.Widget.valuesSet (w, attach @@ lr_form)
  |   lay_out_one (FLEX w, attach) =
    Xm.Widget.valuesSet (w, attach @@ lr_form @@ lr_offsets)
  |   lay_out_one (FIXED w, attach) =
    Xm.Widget.valuesSet (w, attach @@ lr_form @@ lr_offsets)
        
  (* lay_out_from_top is the basic lay_out function.  It traverses a 
     (pre-processed) list of classes, calling lay_out_one with appropriate
     top/bottom attachments for each class.  It returns a top_attachment
     that can be used to tie a further widget to the last in the list. *)
  and lay_out_from_top ([], top_attach, _) =
    top_attach
    |   lay_out_from_top ([SPACE], top_attach, _) =
        Crash.impossible "final SPACE argument to lay_out_from_top"
    |   lay_out_from_top ([w], top_attach, bottom_attach) =
        (lay_out_one (w, top_attach @@ bottom_attach);
         top_widget w)
    |   lay_out_from_top (SPACE :: rest, top_attach, bottom_attach) =
        lay_out_from_top (rest, top_offset :: top_attach, bottom_attach)
    |   lay_out_from_top (w :: rest, top_attach, bottom_attach) =
        (lay_out_one (w, top_attach);
         lay_out_from_top (rest, top_widget w, bottom_attach))
        
  (* lay_out_from_bottom is equivalent to lay_out_from_top, but starts at
     the bottom of the form instead of the top.  It expects its list argument
     to be already reversed. *)
  and lay_out_from_bottom ([], bottom_attach, _) =
    bottom_attach
    |   lay_out_from_bottom ([SPACE], bottom_attach, _) =
        Crash.impossible "SPACE argument to lay_out_from_bottom"
    |   lay_out_from_bottom ([w], bottom_attach, top_attach) =
        (lay_out_one (w, bottom_attach @@ top_attach);
         bottom_widget w)
    |   lay_out_from_bottom (SPACE :: rest, bottom_attach, top_attach) =
        lay_out_from_bottom (rest, bottom_offset :: bottom_attach, top_attach)
    |   lay_out_from_bottom (w :: rest, bottom_attach, top_attach) =
        (lay_out_one (w, bottom_attach);
         lay_out_from_bottom (rest, bottom_widget w, top_attach))
        
  (* lay_out_simple is used for any list that doesn't contain a flex widget.
     It calls lay_out_from_top to do most of the work. *)
  and lay_out_simple [] = ()
    |   lay_out_simple l =
        let
          val (l', b) = trim_spaces l
          val bottom_attach =
            if b then bottom_offset :: bottom_form else bottom_form
        in
          ignore(lay_out_from_top (l', top_form, bottom_attach));
          ()
        end
      
  (* lay_out_flex is used for any list that includes a flex widget.  It
     divides the list into those widgets above the flex widget and those
     below, and processes these parts with lay_out_from_top and
     lay_out_from_bottom respectively.  The flex widget is then linked to
     its immediately adjoining widgets.  This ensures correct resizing of
     the flex widget.  Unfortunately this process cannot be extended to
     multiple flex widgets in Motif. *)
  and lay_out_flex (above, flex, below) =
    let
      val (above', space_above) = trim_spaces above
      val top_attach =
	lay_out_from_top (above', top_form, bottom_none)
      val top_attach' =
	if space_above then top_offset :: top_attach else top_attach
          
      val (below', space_below) = trim_spaces (rev below)
      val bottom_attach =
	lay_out_from_bottom (below', bottom_form, top_none)
      val bottom_attach' =
	if space_below then bottom_offset :: bottom_attach else bottom_attach
    in
      Xm.Widget.valuesSet
      (flex,
       top_attach' @@ bottom_attach' @@
       [(Xm.LEFT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
        (Xm.RIGHT_ATTACHMENT, Xm.ATTACHMENT Xm.ATTACH_FORM),
        (Xm.LEFT_OFFSET, Xm.INT sep_size),
        (Xm.RIGHT_OFFSET, Xm.INT sep_size)])
    end
  
  (* lay_out is the user_visible layout function.  It tests for the
     existence of a flex widget and calls the appropriate function to
     process the list. *)
  and lay_out (_,posOpt,[]) = ()
    | lay_out (_,posOpt,l) =
      let
        val (above, rest) = find_flex l
      in
        case rest 
          of [] => lay_out_simple above
           |  (FLEX flex::below) => (lay_out_flex (above, flex, below); ())
           |  _ => Crash.impossible "non-flex class returned from find_flex"
      end
    end

  fun list_select (parent, name, key_action) =
    let
      val shell = make_popup_shell (name,parent, [], ref true)
      val form = make_subwindow shell
      exception ListSelect
      val select_fn_ref = ref (fn _ => raise ListSelect)
      val print_fn_ref = ref (fn _ => raise ListSelect)

      val exited = ref false;
      fun exit _ = if !exited then () else (destroy shell; exited := true)

      val {scroll, set_items, add_items, list} =
        make_scrolllist
        {parent = form,
         name = "listSelect",
         select_fn = fn _ => fn x => (exit();(!select_fn_ref) x),
         action_fn = fn _ => fn _ => (),
         print_fn = fn _ => (!print_fn_ref)}

      val dialogButtons =
	make_managed_widget ("dialogButtons", RowColumn,form,[])

      val {update = buttons_updatefn, ...} = 
        Menus.make_buttons
        (dialogButtons,
         [Menus.PUSH ("cancel",
                      exit,
                      fn _ => true)])

      fun key_handler event_data =
        case Xm.Event.convertEvent event_data
        of Xm.Event.KEY_PRESS (Xm.Event.KEY_EVENT {key, ...}) =>
          if ("A" <= key andalso key <= "Z") orelse
             ("a" <= key andalso key <= "z") then
            key_action key
          else
  	    ()
        |  _ =>
  	  ()

      fun popup (items,select_fn,print_fn) =
        (select_fn_ref := select_fn;
         print_fn_ref := print_fn;
         set_items () items;
         (* This next call doesn't have any effect *)
(*
         moveit ();
*)
         reveal form;
         exit)
    in
      Layout.lay_out
        (form, NONE,
         [Layout.FLEX scroll,
          Layout.SPACE,
          Layout.FIXED dialogButtons,
          Layout.SPACE]);
      Xm.Event.addHandler
        (list, [Xm.Event.KEY_PRESS_MASK], false (* maskable events only *),
         key_handler);
      popup
    end

    fun license_complain parent message =
      let
        val continue = ref true
        val personal = ref false
        val gui_message = message^"\n\nYou need to reinstall your license information.\n\nClick `Continue' now to run a restricted session\nor `Exit' to exit MLWorks."

        val dialog =
          Xm.Widget.createPopupShell ("messageDialog",
                                    Xm.Widget.DIALOG_SHELL,
                                    parent, [])
      val widget =
        Xm.Widget.create
          ("message", Xm.Widget.MESSAGE_BOX, dialog,
           [(Xm.MESSAGE_STRING,
             Xm.COMPOUND_STRING
               (Xm.CompoundString.createLtoR
                  (gui_message, Xm.CHAR_SET "")))])

        val _ =
          map
           (fn c =>
             Xm.Widget.unmanageChild (Xm.MessageBox.getChild(widget,c)))
           [Xm.Child.HELP_BUTTON]

        fun continueCB _ =
          (personal := true;
          continue := false;
          Xm.Widget.destroy dialog)

        fun exit _ =
          (personal := false;
          continue := false;
          Xm.Widget.destroy parent)
      in
        set_label_string(Xm.MessageBox.getChild(widget, Xm.Child.OK_BUTTON), "Continue");
        set_label_string(Xm.MessageBox.getChild(widget, Xm.Child.CANCEL_BUTTON), "Exit");
        Xm.Callback.add (widget, Xm.Callback.OK, continueCB);
        Xm.Callback.add (widget, Xm.Callback.CANCEL, exit);
        Xm.Widget.manage widget;
        to_front dialog;
        event_loop continue;
        (if !personal then (SOME false) else NONE)
      end



  local
    val ref_show_splash = ref true

    val addTimer: Widget * int * (unit -> unit) -> int = env "x add timer"
    val removeTimer: int -> unit = env "x remove timer"

    fun show_splash (applicationShell, pix_file, time, isFree) = 
      let 
	val countdown = ref time

        val splash =
	  Xm.Widget.createPopupShell
	    ("splash",
             Xm.Widget.DIALOG_SHELL,
             applicationShell,
             [(Xm.TITLE, Xm.STRING "MLWorks Splash Screen"),
	      (Xm.DELETE_RESPONSE, Xm.DELETE_RESPONSE_VALUE Xm.DO_NOTHING),
	      (Xm.ALLOW_SHELL_RESIZE, Xm.BOOL false)])

        val mainWindow =
          Xm.Widget.create ("mainform",
                            Xm.Widget.FORM,
                            splash, [])

	val cast = MLWorks.Internal.Value.cast
	val read_pixmap : Widget * string -> Xm.drawable = env "x read pixmap file"

	val runtime = 
	  let val typed_name = CommandLine.name()
	  in
	    if OS.Path.isRelative(typed_name) then
	      OS.Path.concat [OS.FileSys.getDir(), typed_name]
	    else
	      typed_name
	  end
	val start_dir = OS.Path.dir (OS.Path.mkCanonical runtime)

	val file = OS.Path.concat [start_dir, pix_file]
	val p = read_pixmap (mainWindow, file)

	val pixmap_ok = (p <> (cast 0))

	val bitmap_label = 
	  make_managed_widget ("splashLabel", Label, mainWindow, [])

        val draw_labels =
          if pix_file = "splash_advert.xpm"
          then fn () => ()
          else
            let val time_label = 
 	          make_managed_widget ("timeLabel", Label, mainWindow, [])
                val version_label =
                  make_managed_widget ("versionLabel", Label, mainWindow, [])
             in fn () => 
                  (set_label_string (time_label, 
                               "Time left: " ^ Int.toString(!countdown));
                   set_label_string (version_label, "Version 2.1"))
            end

	fun close_cb _ = 
	  (Xm.Widget.destroy splash;
	   ref_show_splash := false)

	fun timer_cb _ = 
	  if ((!countdown) = 1) then 
	    close_cb()
	  else
	    (countdown := (!countdown) - 1;
	     ignore(addTimer(mainWindow, 1000, timer_cb));
	     draw_labels())
      in
	if (pixmap_ok) then
	  (Xm.Widget.valuesSet (bitmap_label, 
				[(Xm.LABEL_TYPE, Xm.LABEL_TYPE_VALUE Xm.PIXMAP_LABEL),
				 (Xm.LABEL_PIXMAP, Xm.PIXMAP p)]);
	   draw_labels();
	   ignore(addTimer(mainWindow, 1000, timer_cb));
	   reveal mainWindow;
	   to_front splash;
	   event_loop ref_show_splash)
	else 
	   if isFree then 
	     (send_message (applicationShell, "Splash screen pixmap not found.");
	      OS.Process.terminate OS.Process.failure)
	   else
	     ()
      end (* fun show_splash *)

  in
    fun show_splash_screen applicationShell = 
      let 
	val isFree =
          let
            val edition = Version.edition() 
          in
            edition = Version.PERSONAL 
          end
      in
        if isFree
        then
          ( show_splash(applicationShell, "splash_free.xpm", 5, true);
            ref_show_splash := true;
            show_splash(applicationShell, "splash_advert.xpm", 5, false) )
        else
          show_splash(applicationShell, "splash.xpm", 3, false) 
      end (* fun show_splash_screen *)
  end (* local *)

  structure GraphicsPorts =
    struct
      (* Graphics ports *)

      val unwind_protect = LispUtils.unwind_protect'
      fun max (x:int,y) = if x > y then x else y
      fun min (x:int,y) = if x < y then x else y

      datatype GraphicsPort = 
        GP of {widget: Xm.widget,
               name : string,
               title : string,
               display: Xm.display,
               info: {window: Xm.drawable,
                      gc: Xm.gc ref,
                      fontstruct:Xm.font_struct ref} option ref,
               x_offset: int ref,
               y_offset: int ref}
        
      fun gp_widget (GP {widget,...}) = widget

      val get_widget_resource : string * string -> Xm.font =
          env "x get application resource"

      fun initialize_gp (GP {widget,display,info,name,title,...}) =
        case !info of
          NONE =>
            let
              val window = Xm.Widget.window widget
              val display = Xm.Widget.display widget
              val (background,foreground) =
                case Xm.Widget.valuesGet (widget,[Xm.BACKGROUND,Xm.FOREGROUND]) of
                  [Xm.PIXEL background,Xm.PIXEL foreground] => 
                    (background,foreground)
                | _ => Crash.impossible "bad colour values"
              val (font,fontstruct) = 
                let
                  val font = get_widget_resource (name ^ "Font",title ^ "GPFont")                  
                in
                  (font,Xm.Font.query (display,font))
                end
              handle _ =>
                let
                  val _ = print"Using default font\n"
                  val font = Xm.Font.load (display,"fixed")
                in
                  (font,Xm.Font.query (display,font))
                end
              val gc = Xm.GC.create (display,window,
				     [Xm.GC.FONT font,
				      Xm.GC.FOREGROUND foreground,
				      Xm.GC.BACKGROUND background
				     ]
                                    )
            in
              info := SOME {window=window,gc=ref gc,fontstruct=ref fontstruct}
            end
        | _ => ()

      fun start_graphics gp = ()
      fun stop_graphics gp = ()
      fun with_graphics gp f x = f x

      fun with_highlighting (GP {display,info = ref (SOME {gc,...}),...}, f, a) =
        let
          val req_fg_bg  = [Xm.GC.REQUEST_FOREGROUND,Xm.GC.REQUEST_BACKGROUND]
          val cur_fg_bg  = Xm.GC.getValues(display,!gc,req_fg_bg)
        in
           case cur_fg_bg of
             [Xm.GC.FOREGROUND(fg),Xm.GC.BACKGROUND(bg)] =>
               let fun reset (_) = Xm.GC.change(display,!gc,cur_fg_bg)
                   val new_fg_bg = [Xm.GC.FOREGROUND(bg),Xm.GC.BACKGROUND(fg)]
	       in
		  Xm.GC.change(display,!gc,new_fg_bg);
		  unwind_protect (f) (reset) (a)
	       end
           |  _ => f a
        end
      | with_highlighting (gp,f,a) = f a

      fun is_initialized (GP {info = ref (SOME _),...}) = true
        | is_initialized _ = false

      exception UnInitialized

      fun get_offset (GP {x_offset,y_offset,...}) = POINT{x= !x_offset,y= !y_offset}
      fun set_offset (GP {x_offset,y_offset,...},POINT{x,y}) =
          (x_offset := max (x,0); y_offset:= max (y,0))
        
      fun clear_clip_region (GP{display,info,...}) =
        case !info of
          SOME {gc,...} =>
            Xm.GC.change (display,!gc,[(Xm.GC.CLIP_MASK Xm.GC.NO_CLIP_SPEC)])
        | _ => raise UnInitialized
            
      fun set_clip_region (GP{display,info,...},REGION{x,y,width,height}) =
        case !info of
          SOME {gc,...} =>
            Xm.GC.setClipRectangles (display,!gc,0,0,[(x,y,width,height)],Xm.GC.UNSORTED)
        | _ => raise UnInitialized
            
      fun redisplay (GP {display,info,...}) =
        case !info of
          SOME {window,...} =>
            Xm.Draw.clearArea (display,window,0,0,0,0,true)
        | _ => ()

      (* Something of a hack!! *)
      fun reexpose (GP {display,info,...}) =
        case !info of
          SOME {window,...} =>
            Xm.Draw.clearArea (display,window,0,0,1,1,true)
        | _ => ()
            
      fun copy_gp_region
            ( GP{display,info=info1,...}, GP{info=info2,...},
              REGION{x=x1,y=y1,width,height},
              POINT{x=x2,y=y2}
            ) =
        case (!info1,!info2) of
          (SOME {window=window1,gc=gc1,...},SOME {window=window2,...}) =>
            Xm.Draw.copyArea (display,window1,window2,!gc1,x1,y1,width,height,x2,y2)
        | _ => raise UnInitialized
            
      fun make_gp (name,title,widget) = 
        GP {widget=widget,
            name=name,
            title=title,
            display=Xm.Widget.display widget,
            info=ref NONE,
            x_offset= ref 0,
            y_offset = ref 0}

      fun text_extent (gp,string) =
        case gp of
          GP {display,info = ref (SOME {fontstruct,...}),...} =>
            Xm.Font.textExtents (!fontstruct,string)
        | _ => raise UnInitialized

      fun draw_point (gp,POINT{x,y}) =
        case gp of
          GP {display,info as ref (SOME {window,gc,...}), x_offset,y_offset,...} =>
            Xm.Draw.point (display,window,!gc,x - !x_offset,y - !y_offset)
        | _ => raise UnInitialized

      fun draw_line (gp,POINT{x,y},POINT{x=x',y=y'}) =
        case gp of
          GP {display,info as ref (SOME {window,gc,...}), x_offset,y_offset,...} =>
            Xm.Draw.line (display,window,!gc,x - !x_offset,y - !y_offset,x' - !x_offset,y' - !y_offset)
        | _ => raise UnInitialized
            
      fun draw_rectangle (gp, REGION{x, y, width, height}) =
        case gp of
          GP {display, info as ref (SOME {window, gc, ... }),
              x_offset, y_offset, ... } =>
            Xm.Draw.rectangle (display, window, !gc,
                               x - !x_offset, y - !y_offset, width, height)
	    (* X draws rectangles 1 pixel deeper and wider than asked *)
        | _ => raise UnInitialized
            
      fun fill_rectangle (gp,REGION{x, y, width, height}) =
        case gp of
          GP {display, info as ref (SOME {window,gc, ... }),
              x_offset, y_offset,...} =>
            Xm.Draw.fillRectangle (display, window, !gc, 
                                   x - !x_offset, y - !y_offset, width, height)
        | _ => raise UnInitialized

      (* This should fill in the rectangle with the background *)
      fun clear_rectangle (gp, reg) =
        with_highlighting(gp, fill_rectangle, (gp, reg))

      (* This version does not work when scrolling the gp, 
         included here as it uses a more obvious function
         (clearArea) and someone may wish to use it at a
         later date. *)
     (* 
      fun clear_rectangle (gp,REGION{x, y, width, height}) =
        case gp of
          GP {display, info as ref (SOME {window, gc, ... }),
              x_offset, y_offset,...} =>
            Xm.Draw.clearArea (display, window,
                               x - !x_offset, y - !y_offset, width, height,
                               false)
        | _ => raise UnInitialized
      *)

      fun draw_image_string (gp, string, POINT{x, y}) =
        case gp of 
          GP {display, info as ref (SOME {window, gc, ... }),
              x_offset, y_offset, ... } => 
            Xm.Draw.imageString (display, window, !gc,
                                 x - !x_offset, y - !y_offset, string)
        | _ => raise UnInitialized

      val pi = (real 314159) / (real 100000)
      val two_pi = pi + pi
      fun draw_arc (gp,REGION{x,y,width,height},theta1,theta2) =
        case gp of 
          GP {display,info as ref (SOME {window,gc,...}),x_offset,y_offset,...} =>
            let
              fun convert_theta theta = floor (theta * (real 360) * (real 64) /two_pi)
            in
              Xm.Draw.arc (display, window, !gc,
                           x, y, width, height,
                           convert_theta theta1, convert_theta theta2
                          )
            end
        | _ => raise UnInitialized

      local
        val sync_graphics_exposures : unit -> unit = env "x sync graphics exposures"
      in
        fun make_graphics (name,title,draw,get_extents,
			   (want_hscroll,want_vscroll),parent) =
          let
            (* Make the windows *)
            (* perchance this shouldn't be managed, but then we get a nice effect if it is *)
            val scroll = Xm.Widget.createManaged ("drawScroll",Xm.Widget.SCROLLED_WINDOW,parent,[])
            val frame = make_managed_widget ("drawFrame",Frame,scroll,[])
            val main = make_managed_widget ("drawPane", Graphics, frame,[])
	    val (hscroll_values, hscroll_add_callbacks, hscroll_set) =
	      if want_hscroll then
		let
		  val hscroll = 
		    Xm.Widget.createManaged 
		    ("drawHScroll",
		     Xm.Widget.SCROLLBAR,scroll,
		     [(Xm.ORIENTATION, Xm.ORIENTATION_VALUE Xm.HORIZONTAL)])
		  fun horizontal_scroll_callback gp data =
		    let
		      val new_xi = 
			case Xm.Widget.valuesGet (hscroll,[Xm.VALUE]) of
			  [Xm.INT new_xi] => new_xi
			| _ => raise Div
		      val (w,h) = widget_size main
		      val POINT{x=old_xi,y=old_yi} = get_offset gp
		      val delta = new_xi-old_xi
		    in
		      set_offset (gp,POINT{x=new_xi,y=old_yi});
		      copy_gp_region (gp,gp,REGION{x=delta,y=0,width=w,height=h},
			              origin);
                      sync_graphics_exposures()
		    end
		in
		  ([(Xm.HORIZONTAL_SCROLLBAR,Xm.WIDGET hscroll)],
		   fn gp =>
		   let val callback = horizontal_scroll_callback gp
		   in (Xm.Callback.add (hscroll, Xm.Callback.DRAG,
					      callback);
		       Xm.Callback.add (hscroll,Xm.Callback.VALUE_CHANGED,
					      callback))
		   end,
		   fn (new_xi, xextent, ww) =>
		   Xm.Widget.valuesSet (hscroll,
					[(Xm.VALUE, Xm.INT new_xi),
					 (Xm.MAXIMUM, Xm.INT xextent),
					 (Xm.SLIDER_SIZE,
					  Xm.INT (min (ww,xextent)))]))
		end
	      else ([],fn _ => (), fn _ => ())
	    val (vscroll_values, vscroll_add_callbacks, vscroll_set) = 
	      if want_vscroll then
		let
		  val vscroll = 	      
		    Xm.Widget.createManaged 
		    ("drawVScroll", 
		     Xm.Widget.SCROLLBAR,scroll,
		     [(Xm.ORIENTATION, Xm.ORIENTATION_VALUE Xm.VERTICAL)])
		  fun vertical_scroll_callback gp data =
		    let
		      val new_yi = 
			case Xm.Widget.valuesGet (vscroll,[Xm.VALUE]) of
			  [Xm.INT new_yi] => new_yi
			| _ => raise Div
		      val (w,h) = widget_size main
		      val POINT{x=old_xi,y=old_yi} = get_offset gp
		      val delta = new_yi-old_yi
		    in
		      set_offset (gp,POINT{x=old_xi,y=new_yi});
		      copy_gp_region (gp,gp,REGION{x=0,y=delta,width=w,height=h},
			              origin);
                      sync_graphics_exposures()
		    end
		in
		  ([(Xm.VERTICAL_SCROLLBAR,Xm.WIDGET vscroll)],
		   fn gp => 
		   let val callback = vertical_scroll_callback gp
		   in (Xm.Callback.add (vscroll,Xm.Callback.VALUE_CHANGED,
					      callback);
		       Xm.Callback.add (vscroll,Xm.Callback.DRAG,
					      callback))
		   end,
		   fn (new_yi, yextent, wh) =>
		   Xm.Widget.valuesSet (vscroll,
					[(Xm.VALUE, Xm.INT new_yi),
					 (Xm.MAXIMUM, Xm.INT yextent),
					 (Xm.SLIDER_SIZE,
					  Xm.INT (min (wh,yextent)))]))
		 end
	      else ([], fn _ => (), fn _ => ())

	    val _ = Xm.Widget.valuesSet (scroll,
					 vscroll_values @@ hscroll_values @@
					 [(Xm.WORK_WINDOW,Xm.WIDGET frame)])
              
            val gp = make_gp (name,title,main)
              
            (* These need to be a little careful about the way the copy area is done *)

            fun set_position (POINT{x=xi',y=yi'}) = 
              let
                val POINT{x=cur_xi,y=cur_yi}  = get_offset gp

                val xi = if (xi' < 0) then cur_xi else xi'
                val yi = if (yi' < 0) then cur_yi else yi'

                val (ww,wh) = widget_size main
                val (xextent,yextent) = get_extents()
                val new_xi = max (min (xi,xextent-ww),0)
                val new_yi = max (min (yi,yextent-wh),0)
              in
		hscroll_set (new_xi, xextent, ww);
		vscroll_set (new_yi, yextent, wh);
                set_offset (gp,POINT{x=new_xi,y=new_yi});
                redisplay gp
              end
            
            fun resize_callback data = 
              let
                val (ww,wh) = widget_size main
                val (xextent,yextent) = get_extents()
                val POINT{x=xi,y=yi}  = get_offset gp
                val new_xi = max (min (xi,xextent-ww),0)
                val new_yi = max (min (yi,yextent-wh),0)
              in
		hscroll_set (new_xi, xextent, ww);
		vscroll_set (new_yi, yextent, wh);
                set_offset (gp,POINT{x=new_xi,y=new_yi});
                redisplay gp
              end
            
            fun do_expose (Xm.Event.EXPOSE_EVENT {common,x,y,width=w,height=h,count}) =
              draw (gp,REGION {x=x,y=y,width=w,height=h})
              
            fun expose_handler data =
              let
                val event = Xm.Event.convertEvent data
              in
                case event of
                  Xm.Event.EXPOSE expose_event => do_expose expose_event
                | Xm.Event.GRAPHICS_EXPOSE expose_event => do_expose expose_event
                (* Could be a NoExpose event *)
                | _ => ()
              end
          in
            Xm.Event.addHandler (main,[Xm.Event.EXPOSURE_MASK],true,expose_handler);
            Xm.Callback.add (main,Xm.Callback.RESIZE,resize_callback);
	    hscroll_add_callbacks gp;
	    vscroll_add_callbacks gp;
            (scroll,gp,resize_callback,set_position)
          end
      end

      fun add_input_handler (gp,handler) =
        let
          fun input_callback data =
            let
              val event = Callback.get_event data
              val event_type = Event.get_event_type event
            in
              if event_type = Event.ButtonPress
                then
                  case Event.get_button_data event of
                    SOME (POINT{x,y},button) =>
                      let
                        val POINT{x=xi,y=yi} = get_offset gp
                        val new_x = x + xi
                        val new_y = y + yi
                      in
                        handler (button,POINT {x=new_x,y=new_y})
                      end
                  | _ => ()
              else ()
            end
        in
          Xm.Callback.add
          (gp_widget gp,
           Xm.Callback.INPUT,
           input_callback)
        end

      type PixMap = Xm.pixel

      datatype LineStyle = LINESOLID | LINEONOFFDASH | LINEDOUBLEDASH
      
      datatype Attribute =
         FONT of Font
      |  LINE_STYLE of LineStyle
      |  LINE_WIDTH of int  
      |  FOREGROUND of PixMap
      |  BACKGROUND of PixMap

      datatype Request =
         REQUEST_FONT
      |  REQUEST_LINE_STYLE
      |  REQUEST_LINE_WIDTH
      |  REQUEST_FOREGROUND
      |  REQUEST_BACKGROUND

      local

        fun translate_request (REQUEST_FONT)       = Xm.GC.REQUEST_FONT
          | translate_request (REQUEST_LINE_STYLE) = Xm.GC.REQUEST_LINE_STYLE
          | translate_request (REQUEST_LINE_WIDTH) = Xm.GC.REQUEST_LINE_WIDTH
          | translate_request (REQUEST_FOREGROUND) = Xm.GC.REQUEST_FOREGROUND
          | translate_request (REQUEST_BACKGROUND) = Xm.GC.REQUEST_BACKGROUND

        val translate_gc_font : Xm.font -> Font = cast
        val translate_gc_line_style : Xm.GC.line_style -> LineStyle = cast

        val translate_font : Font -> Xm.font = cast
        val translate_line_style : LineStyle -> Xm.GC.line_style = cast

        fun translate_gc_value (Xm.GC.FONT f)        = FONT(translate_gc_font f)
          | translate_gc_value (Xm.GC.LINE_STYLE ls) =
               LINE_STYLE(translate_gc_line_style ls)
          | translate_gc_value (Xm.GC.LINE_WIDTH(i)) = LINE_WIDTH(i)
          | translate_gc_value (Xm.GC.FOREGROUND(p))  = FOREGROUND(p)
          | translate_gc_value (Xm.GC.BACKGROUND(p)) = BACKGROUND(p)
          | translate_gc_value (_) = Crash.impossible "translate_gc_value"


        fun translate_attribute (FONT f) =
            Xm.GC.FONT(translate_font f)
          | translate_attribute (LINE_STYLE ls) =
            Xm.GC.LINE_STYLE(translate_line_style ls)
          | translate_attribute (LINE_WIDTH(i)) = Xm.GC.LINE_WIDTH(i)
          | translate_attribute (FOREGROUND(p))  = Xm.GC.FOREGROUND(p)
          | translate_attribute (BACKGROUND(p)) = Xm.GC.BACKGROUND(p)

         fun is_font_attr (FONT(_)) = true
           | is_font_attr (_)       = false
      in

         fun getAttributes (GP{display,info as ref(SOME{gc,...}), ...},req_l) =
             let val gc_req_l = map translate_request req_l
                 val gc_val_l = Xm.GC.getValues(display,!gc,gc_req_l)
             in
                 map translate_gc_value gc_val_l
             end
           | getAttributes(_,_) = raise UnInitialized

         fun setAttributes (GP{display,info as ref(SOME{gc,fontstruct,...}),...},attr_l) =
             let val gc_val_l = map translate_attribute attr_l
             in
	         Xm.GC.change(display,!gc,gc_val_l);
                 case  BasisList.find is_font_attr attr_l of
                   SOME(FONT(font)) =>
                     ( fontstruct := (Xm.Font.query (display,font) ))
                 | _ => ()
             end
           | setAttributes(_,_) = raise UnInitialized

         fun with_graphics_port (GP{display,info as ref(SOME{window,gc,fontstruct,...}),...}, body_fn, arg) =
	     let val cur_gc = !gc
		 val cur_fontstruct = !fontstruct

		 fun reset_fn(_) =
		   ( gc := cur_gc;
		     fontstruct := cur_fontstruct
		   )

                 val gc_values =
                   Xm.GC.getValues (display,!gc,
                                    [Xm.GC.REQUEST_FONT,
                                     Xm.GC.REQUEST_FOREGROUND,
                                     Xm.GC.REQUEST_BACKGROUND])

                 val new_gc_obj = Xm.GC.create(display,window,gc_values)
	     in
		gc := new_gc_obj; 
		unwind_protect (body_fn)(reset_fn)(arg)
	     end
           | with_graphics_port(_,_,_) = raise UnInitialized
      end
    end

  (* CLIPBOARD INTERFACE *)
  (* this just deals with text right now *)
  (* temporary hack *)

  local
    fun env s = MLWorks.Internal.Runtime.environment s
  in
    val set_selection : Widget * string -> unit = env "x set selection"
    val get_selection : Widget * (string -> unit) -> unit = env "x get selection"
  end

  fun clipboard_set (widget,s) = set_selection (widget,s)
  fun clipboard_get (widget,handler) = get_selection (widget,handler)
  (* I don't see how to implement this *)
  fun clipboard_empty widget = false

  val terminator = "\n"

  val register_interrupt_widget : Widget -> unit = 
    MLWorks.Internal.Runtime.environment "x set interrupt window" 

(* Dummy function - nothing needs to be done on Motif. 
 * This function is not used. *)
  fun with_window_updates f = f ()

  val evaluating = ref false;

  (* makeYesNo(parent, question) creates a question of type unit->bool *)
  (* The question asks the user a simple question requiring either
     Yes or No as answer, or optionally (if enabled) the user can click Cancel.
     Waits for user response and returns:
	SOME true indicating that the user clicked YES,
	SOME false indicating that the user clicked NO,
	NONE indicating that the user clicked CANCEL.
   *)
  fun makeYesNoCancel (parent, question, cancelButton) =
    let 
      val waitRef = ref true  
      val answerRef = ref NONE
      val dialog = Xm.Widget.createPopupShell
                     ("Question",
                      Xm.Widget.DIALOG_SHELL,
                      parent,
                      [(Xm.DELETE_RESPONSE ,
                        Xm.DELETE_RESPONSE_VALUE Xm.DO_NOTHING )])
      val form = make_subwindow dialog

      val buttonRow = Xm.Widget.createManaged
                      ("buttonRow", Xm.Widget.ROW_COLUMN, form,
                       [(Xm.ORIENTATION, Xm.ORIENTATION_VALUE Xm.HORIZONTAL)])

      val questionBox = make_managed_widget ("msgLabel", Label, form, [])

      fun callback a _ =
            (answerRef := a;
             waitRef := false;
             hide dialog)

      val yesButton = Xm.Widget.createManaged
                       ("       Yes      ", 
                        Xm.Widget.PUSH_BUTTON, buttonRow, [])
      val noButton = Xm.Widget.createManaged
                       ("       No       ",
                        Xm.Widget.PUSH_BUTTON, buttonRow, [])

    in
      Xm.Callback.add (yesButton, Xm.Callback.ACTIVATE, callback (SOME true));
      Xm.Callback.add (noButton, Xm.Callback.ACTIVATE, callback (SOME false));

      if cancelButton then 
	let val cancel = Xm.Widget.createManaged
                       ("     Cancel     ", 
                        Xm.Widget.PUSH_BUTTON, buttonRow, [])
	in
	  Xm.Callback.add (cancel, Xm.Callback.ACTIVATE, callback NONE)
	end
      else ();

      set_label_string (questionBox, question);
      Layout.lay_out (form, NONE, [Layout.FIXED questionBox,
                                     Layout.SPACE,
                                     Layout.FIXED buttonRow]);

      fn () =>
        (reveal form;
         reveal dialog;
         waitRef := true;
         event_loop waitRef;
         !answerRef )
    end (* of fun makeYesNoCancel *)

  fun find_dialog (parent, searchFn, spec) = 
    let
      val dialog = 
	Xm.Widget.createPopupShell ("Find",
				    Xm.Widget.DIALOG_SHELL,
				    parent,
	                      	    [(Xm.DELETE_RESPONSE ,
	                              Xm.DELETE_RESPONSE_VALUE Xm.DO_NOTHING )])
      val form = make_subwindow dialog

      val searchRow = Xm.Widget.createManaged
                      ("searchRow", Xm.Widget.ROW_COLUMN, form,
                       [(Xm.ORIENTATION, Xm.ORIENTATION_VALUE Xm.HORIZONTAL)])

      val label = make_managed_widget("findLabel", Label, searchRow, [])
      val findText = make_managed_widget("findText", Text, searchRow, [])

      val {downOpt, caseOpt, findStr, wordOpt} = spec

      val wholeWord = ref (getOpt(wordOpt, false))
      val matchCase = ref (getOpt(caseOpt, false))
      val searchDown = ref (getOpt(downOpt, false))

      fun create_opt s storeRef =
	let 
	  val buttonRC = make_managed_widget("buttonRC", RowColumn, form, [])
	  val {update, ...} = 
	    Menus.make_buttons (buttonRC, 
	      [Menus.TOGGLE (s, fn () => (!storeRef), fn tf => (storeRef := tf), fn _ => true)])
	in
	  (buttonRC, update)
	end

      val testWord = isSome(wordOpt)
      val testCase = isSome(caseOpt)
      val testDown = isSome(caseOpt)

      val (matchCaseRC, updateCase) = 
	if testCase then (create_opt "matchCase" matchCase) else (form, fn () => ())
      val (wholeWordRC, updateWord) = 
	if testWord then (create_opt "wholeWord" wholeWord) else (form, fn () => ())

      val (downRC, updateDownButtons) = 
	if testDown then 
	  let 
	    val downRC = make_managed_widget("downRC", RowColumn, form, [])
	    val searchDir = make_managed_widget("searchDir", Label, downRC, [])
	    val {update, ...} = 
		Menus.make_buttons(downRC,
		  [Menus.RADIO ("up", fn () => not (!searchDown),
				      fn tf => searchDown := not tf, 
				      fn () => true),
		   Menus.RADIO ("down", fn () => (!searchDown),
				      fn tf => searchDown := tf, 
				      fn () => true)])
	  in
	    (downRC, update)
	  end
	else
	  (form, fn () => ())

      fun findnext () = 
	searchFn {searchStr = Text.get_string findText,
		  matchCase = (!matchCase),
		  wholeWord = (!wholeWord),
		  searchDown = (!searchDown)}

      val buttonsRC = make_managed_widget("buttonsRC", RowColumn, form, [])
      val {update, ...} = 
	Menus.make_buttons(buttonsRC,
	  [Menus.PUSH ("findNext", findnext, fn _ => true),
	   Menus.PUSH ("cancel", fn () => hide dialog, fn _ => true)])

    in
      Layout.lay_out (form, NONE,
	[Layout.FIXED searchRow] @@ 
	(if testCase then [Layout.FIXED matchCaseRC] else []) @@ 
	(if testWord then [Layout.FIXED wholeWordRC] else []) @@
	(if testDown then [Layout.FIXED downRC] else []) @@
	[Layout.SPACE,
	 Layout.FIXED buttonsRC]);
      fn () => (reveal form;
	  	reveal dialog; 
		Text.set_string(findText, findStr);
		updateCase();
		updateWord();
		updateDownButtons();
		dialog)

    end  (* find_dialog *)

end

@


1.107
log
@[Bug #190512]
Suppress countdown on splash screen advert
@
text
@d8 4
a426 1
require "../basis/__exit";
d1542 1
a1542 1
	      Exit_.terminate Exit_.failure)
@


1.107.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
 * Revision 1.107  1999/03/19  10:27:56  mitchell
 * [Bug #190512]
 * Suppress countdown on splash screen advert
 *
@


1.106
log
@[Bug #190509]
Update version strings to 2.1
@
text
@d8 4
d1501 13
a1513 8
	val time_label = 
	  make_managed_widget ("timeLabel", Label, mainWindow, [])
	val version_label =
	  make_managed_widget ("versionLabel", Label, mainWindow, [])

	fun draw_labels () = 
	  (set_label_string (time_label, "Time left: " ^ Int.toString(!countdown));
	   set_label_string (version_label, "Version 2.1"))
d1558 1
a1558 1
            show_splash(applicationShell, "splash_advert.xpm", 5, true) )
@


1.105
log
@[Bug #190512]
Display Professional advert when starting Personal Edition
@
text
@d8 4
d1504 1
a1504 1
	   set_label_string (version_label, "Version 2.0"))
@


1.104
log
@[Bug #30456]
Update version to 2.0c0
@
text
@d8 4
d1454 1
a1454 2
  in
    fun show_splash_screen applicationShell = 
d1456 1
a1456 8
	val isFree =
          let
            val edition = Version.edition() 
          in
            edition = Version.PERSONAL 
          end

	val countdown = ref (if isFree then 10 else 3)
a1474 1
	val pix_file = if isFree then "splash_free.xpm" else "splash.xpm"
d1529 19
a1548 1

@


1.103
log
@[Bug #30436]
PERSONAL replaces FREE and STUDENT editions
@
text
@d8 4
d1505 1
a1505 1
	   set_label_string (version_label, "Version 2.0b2"))
@


1.102
log
@[Bug #30435]
Remove license-prompting code
@
text
@d8 4
d1453 1
a1453 1
            (edition = Version.STUDENT) orelse (edition = Version.FREE)
@


1.101
log
@[Bug #30431]
Extend Capi by adding more window attributes to change.
@
text
@d8 4
d1390 5
a1394 45
  local 
    val namestr = ref ""
    val numstr = ref ""

    fun make_license_dialog (parent) = let 
      val continue = ref true
      val l_dialog = make_toplevel_shell ("Licensing", "Licensing", parent, []);
      val form = make_subwindow l_dialog
      val msg_label = make_managed_widget ("msgLabel", Label, form, [])
      val _ = set_label_string
	        (msg_label, "You must register your copy of MLWorks.");
      val name_label = make_managed_widget ("nameLabel", Label, form, [])
      val name_text = make_managed_widget ("nameText", Text, form, [])
      val lic_no_label =
	make_managed_widget ("codeLabel", Label, form, [])
      val lic_no = make_managed_widget ("codeText", Text, form, [])

      fun ok_callback _ =
	(continue := false;
         namestr := Text.get_string name_text;
         numstr := Text.get_string lic_no;
	 Xm.Widget.destroy l_dialog)

      val ok_button = make_managed_widget ("Continue", Button, form, [])
      val _ = Xm.Callback.add(ok_button, Xm.Callback.ACTIVATE, ok_callback)  
    in
      Layout.lay_out (form, NONE,
			    [Layout.FIXED msg_label,
			     Layout.SPACE,
                             Layout.FIXED name_label, Layout.FIXED name_text,
                             Layout.FIXED lic_no_label, Layout.FIXED lic_no,
                             Layout.SPACE,
                             Layout.FIXED ok_button]);
      Text.set_string(name_text, !namestr);
      Text.set_string(lic_no, !numstr);
      reveal form;
      initialize_toplevel l_dialog;
      event_loop continue
    end

  in
    fun license_prompt parent () =
      (make_license_dialog parent; 
       (!namestr, !numstr))
  end    
d1396 2
a1397 6
  fun license_complain parent message =
    let
      val continue = ref true
      val retry = ref true
      val dialog =
        Xm.Widget.createPopupShell ("messageDialog",
a1399 1
            
d1404 30
a1433 19
	     Xm.COMPOUND_STRING
	       (Xm.CompoundString.createLtoR
		  (message, Xm.CHAR_SET "")))])
  
      val _ =
        map 
         (fn c =>
           Xm.Widget.unmanageChild (Xm.MessageBox.getChild(widget,c)))
         [Xm.Child.HELP_BUTTON]

      fun retryCB _ = 
	(continue := false;
	retry := true;
	Xm.Widget.destroy dialog)

      fun exit _ =
	(continue := false;
	 retry := false;
	 Xm.Widget.destroy parent)
a1434 9
    in
      set_label_string(Xm.MessageBox.getChild(widget, Xm.Child.OK_BUTTON), "Retry");
      Xm.Callback.add (widget, Xm.Callback.OK, retryCB);
      Xm.Callback.add (widget, Xm.Callback.CANCEL, exit);
      Xm.Widget.manage widget;
      to_front dialog;
      event_loop continue;
      !retry
    end
@


1.100
log
@[Bug #30433]
Use new splash screen.
@
text
@d8 4
d494 4
a497 1
    PanedMargin of bool
d513 12
a524 3
    (Xm.MARGIN_WIDTH, Xm.INT sep_size)
  |   convert_widget_attributes (PanedMargin false) =
    (Xm.MARGIN_WIDTH, Xm.INT 0)
d529 2
a530 1
      val parameter_attributes = map convert_widget_attributes attributes
d540 2
a541 1
      val parameter_attributes = map convert_widget_attributes attributes
d642 5
a646 1
    Xm.Widget.createPopupShell 
d650 3
a652 1
	 [(Xm.DELETE_RESPONSE, Xm.DELETE_RESPONSE_VALUE Xm.DESTROY)])
d655 11
a665 5
    Xm.Widget.create (name,
                      Xm.Widget.TOP_LEVEL_SHELL,
                      parent,
                      [(Xm.TITLE, Xm.STRING title),
                       (Xm.ICON_NAME, Xm.STRING title)])
d669 2
d672 1
a672 1
        Xm.Widget.createScrolledText (parent, name,[])
a676 2

  val make_message_text = make_scrolled_text
@


1.99
log
@[Bug #30411]
Fix problems checking edition and setting time out of spalsh screen.
@
text
@d8 4
d1501 2
a1502 7

	val copyright1 = 
	  make_managed_widget ("copyright1", Label, mainWindow, [])
	val copyright2 = 
	  make_managed_widget ("copyright2", Label, mainWindow, [])
	val copyright3 = 
	  make_managed_widget ("copyright3", Label, mainWindow, [])
d1506 1
a1506 3
	  set_label_string(copyright1, "MLWorks 2.0b2");
	  set_label_string(copyright2, "Copyright (C) 1998 Harlequin Group plc.  All rights reserved.");
	  set_label_string(copyright3, "MLWorks is a registered trademark of Harlequin Group plc."))
@


1.98
log
@[Bug #30411]
Fix path problem in finding splash screen.
@
text
@d8 4
a1446 8
    val isFree = fn () => 
        let
          val edition = Version.edition() 
        in
          (edition = Version.STUDENT) orelse (edition = Version.FREE)
        end

    val countdown = ref (if isFree() then 10 else 3)
d1450 9
d1476 1
a1476 1
	val pix_file = if isFree() then "splash_free.xpm" else "splash.xpm"
d1533 1
a1533 1
	   if isFree() then 
@


1.97
log
@[Bug #30415]
Update version info for 2.0b2
@
text
@d8 4
d1473 8
a1480 2
	  OS.Path.mkCanonical (OS.Path.concat [OS.FileSys.getDir(), CommandLine.name()])
	val start_dir = OS.Path.dir runtime 
@


1.96
log
@[Bug #30411]
Include Free edition
@
text
@d8 4
d1492 1
a1492 1
	  set_label_string(copyright1, "MLWorks 2.0b0");
@


1.95
log
@[Bug #30411]
Add support for free edition splash screen.
@
text
@d8 4
d1435 6
a1440 1
    val isFree = fn () => (Version.editionStr = "Student")
@


1.94
log
@[Bug #30384]
Make sure cancel button is visible on yesno dialog.
@
text
@d8 4
d376 2
d386 2
d397 2
d1425 88
a1512 2
(* Dummy splash screen function which is implemented on Windows. *)
  fun show_splash_screen W = ();
@


1.93
log
@[Bug #50072]
Disable positioning of windows.
@
text
@d8 4
d1965 1
a1965 1
                       ("        Yes        ", 
d1968 1
a1968 1
                       ("        No         ",
d1977 1
a1977 1
                       ("      Cancel       ", 
@


1.92
log
@[Bug #30346]
Add Capi.getNextWindowPos().
@
text
@d8 4
d525 2
a526 1
  fun make_main_window {name, title, parent, contextLabel, winMenu, pos = (xpos, ypos)} =
a534 2
	    (Xm.X, Xm.INT xpos),
	    (Xm.Y, Xm.INT ypos),
a551 1
	Xm.Widget.valuesSet (shell, [(Xm.X, Xm.INT xpos), (Xm.Y, Xm.INT ypos)]);
d555 1
@


1.91
log
@[Bug #50035]
Keyboard accelerators now platform specific.
@
text
@d8 4
d424 15
a438 2
    (main_windows := []
     )
d584 1
a584 1
		     pos = (100,100)}
@


1.90
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d8 4
d1007 1
a1007 3
      fun add_handler (text,handler) =
        let
          fun activate callback_data =
d1018 21
a1038 3
        in
          Xm.Callback.add (text,Xm.Callback.ACTIVATE,activate)
        end
@


1.89
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d8 4
d425 1
a425 1
      Xm.checkMLWorksResources ();
d701 1
a701 1
      map 
d765 1
a765 1
    (Xm.Widget.processTraversal (w, Xm.Widget.TRAVERSE_CURRENT);
d1115 1
a1115 1
    (map lay_out (map (fn (a,b) => (a,NONE,b)) sub_classes);
d1170 1
a1170 1
          lay_out_from_top (l', top_form, bottom_attach);
@


1.88
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d8 4
d496 1
a496 1
  fun make_main_window (name,title,parent,has_context_label, in_windows_menu) =
d505 2
d512 1
a512 1
      val (main,menu,label) = make_main_subwindows (shell,has_context_label)
d518 1
a518 1
      if in_windows_menu then 
d524 1
d528 1
a528 1
  fun make_main_popup (name,title,parent,has_context_label,visible) =
d541 1
a541 1
      val (main,menu,label) = make_main_subwindows (shell,has_context_label)
d547 1
a547 1
      if (!visible) then 
d554 6
a559 1
    make_main_popup ("messages", "System Messages", parent, false, visible)
d771 5
d1111 1
a1111 1
    (map lay_out sub_classes;
d1203 2
a1204 2
  and lay_out (_,[]) = ()
    | lay_out (_,l) =
d1267 1
a1267 1
        (form,
d1304 2
a1305 1
      Layout.lay_out (form, [Layout.FIXED msg_label,
d1937 1
a1937 1
      Layout.lay_out (form, [Layout.FIXED questionBox,
d2023 1
a2023 1
      Layout.lay_out (form, 
@


1.87
log
@[Bug #30125]
Move implementation of send_message to Menus.
@
text
@d8 4
d16 12
d550 5
a554 3
    Xm.Widget.createPopupShell (name,
                                Xm.Widget.DIALOG_SHELL,
                                parent, [])
d719 2
d821 1
d831 1
d851 5
d1869 7
a1875 3
     Yes or No as answer.
     Waits for user response and returns true or false. *)
  fun makeYesNo (parent, question) =
d1877 2
a1878 1
      val waitRef = ref true  val answerRef = ref false
a1900 2

      val _ = Xm.Callback.add (yesButton, Xm.Callback.ACTIVATE, callback true);
a1903 1
      val _ = Xm.Callback.add (noButton, Xm.Callback.ACTIVATE, callback false);
d1905 12
a1916 1
      val _ = set_label_string (questionBox, question);
d1918 2
a1919 1
      val _ = Layout.lay_out (form, [Layout.FIXED questionBox,
d1921 2
a1922 2
                                     Layout.FIXED buttonRow])
    in
d1929 1
a1929 1
    end (* of fun makeYesNo *)
@


1.86
log
@[Bug #30137]
Add make_messages_popup.
@
text
@d8 4
d751 1
a751 25
  fun send_message (parent,message) =
    let
      val dialog =
        Xm.Widget.createPopupShell ("messageDialog",
                                    Xm.Widget.DIALOG_SHELL,
                                    parent, [])
            
      val widget =
        Xm.Widget.create
        ("message", Xm.Widget.MESSAGE_BOX, dialog,
         [(Xm.MESSAGE_STRING, Xm.COMPOUND_STRING (Xm.CompoundString.createSimple message))])

      val _ =
        map 
         (fn c =>
           Xm.Widget.unmanageChild (Xm.MessageBox.getChild(widget,c)))
         [Xm.Child.CANCEL_BUTTON,
          Xm.Child.HELP_BUTTON]

      (* This really ought to reuse dialogs *)
      fun exit _ = Xm.Widget.destroy dialog
    in
      Xm.Callback.add (widget, Xm.Callback.OK, exit);
      Xm.Widget.manage widget
    end
@


1.85
log
@[Bug #30241]
Implementing proper Find Dialog.
@
text
@d8 4
d525 3
@


1.85.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
 * Revision 1.85  1997/09/05  11:12:44  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
@


1.85.2.2
log
@[Bug #30071]
Implement new Project Workspace tool.
@
text
@a693 2
  val remove_menu = destroy

a845 5
  fun move_window (widget, x, y) = ()
  fun size_window (widget, w, h) = 
    Xm.Widget.valuesSet (widget, [(Xm.WIDTH, Xm.INT w),
				  (Xm.HEIGHT, Xm.INT h)])

d1859 3
a1861 7
     Yes or No as answer, or optionally (if enabled) the user can click Cancel.
     Waits for user response and returns:
	SOME true indicating that the user clicked YES,
	SOME false indicating that the user clicked NO,
	NONE indicating that the user clicked CANCEL.
   *)
  fun makeYesNoCancel (parent, question, cancelButton) =
d1863 1
a1863 2
      val waitRef = ref true  
      val answerRef = ref NONE
d1886 2
d1891 1
d1893 1
a1893 3
    in
      Xm.Callback.add (yesButton, Xm.Callback.ACTIVATE, callback (SOME true));
      Xm.Callback.add (noButton, Xm.Callback.ACTIVATE, callback (SOME false));
d1895 1
a1895 11
      if cancelButton then 
	let val cancel = Xm.Widget.createManaged
                       ("      Cancel       ", 
                        Xm.Widget.PUSH_BUTTON, buttonRow, [])
	in
	  Xm.Callback.add (cancel, Xm.Callback.ACTIVATE, callback NONE)
	end
      else ();

      set_label_string (questionBox, question);
      Layout.lay_out (form, [Layout.FIXED questionBox,
d1897 2
a1898 2
                                     Layout.FIXED buttonRow]);

d1905 1
a1905 1
    end (* of fun makeYesNoCancel *)
@


1.85.2.3
log
@[Bug #30071]
Set popup shell attribute DELETE_RESPONSE to DESTROY.
@
text
@a7 4
 * Revision 1.85.2.2  1997/09/12  14:44:13  johnh
 * [Bug #30071]
 * Implement new Project Workspace tool.
 *
d527 3
a529 5
    Xm.Widget.createPopupShell 
	(name,
         Xm.Widget.DIALOG_SHELL,
         parent, 
	 [(Xm.DELETE_RESPONSE, Xm.DELETE_RESPONSE_VALUE Xm.DESTROY)])
@


1.85.2.4
log
@[Bug #30071]
Add Callback.VALUE_CHANGED.
@
text
@a7 4
 * Revision 1.85.2.3  1997/11/19  13:28:58  johnh
 * [Bug #30071]
 * Set popup shell attribute DELETE_RESPONSE to DESTROY.
 *
a825 1
      | ValueChange
a834 1
	    | ValueChange => Xm.Callback.VALUE_CHANGED
@


1.85.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
 * Revision 1.85  1997/09/05  11:12:44  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
@


1.84
log
@[Bug #30202]
Change utils.lists to basis.list.  Fix bug in GraphicsPort.setAttributes.
Added function makeYesNo.  Changed implementation of GraphicsPort.clear_rectangle.
@
text
@d8 5
d1902 91
@


1.83
log
@[Bug #30182]
Add dummy add_del_handler function - used only on Win32.
@
text
@d8 4
d325 1
d340 4
d1484 1
a1484 1
      fun draw_rectangle (gp,REGION{x,y,width,height}) =
d1486 4
a1489 2
          GP {display,info as ref (SOME {window,gc,...}), x_offset,y_offset,...} =>
            Xm.Draw.rectangle (display,window,!gc,x - !x_offset,y - !y_offset,width,height)
d1493 1
a1493 1
      fun fill_rectangle (gp,REGION{x,y,width,height}) =
d1495 4
a1498 2
          GP {display,info as ref (SOME {window,gc,...}), x_offset,y_offset,...} =>
            Xm.Draw.fillRectangle (display,window,!gc,x - !x_offset,y - !y_offset,width,height)
d1502 9
a1510 1
      fun clear_rectangle (gp,REGION{x,y,width,height}) =
d1512 5
a1516 2
          GP {display,info as ref (SOME {window,gc,...}), x_offset,y_offset,...} =>
            Xm.Draw.clearArea (display,window,x - !x_offset,y - !y_offset,width,height,false)
d1518 3
a1520 2
            
      fun draw_image_string (gp,string,POINT{x,y}) =
d1522 4
a1525 2
          GP {display,info as ref (SOME {window,gc,...}),x_offset,y_offset,...} =>
            Xm.Draw.imageString (display,window,!gc,x - !x_offset,y - !y_offset,string)
d1790 2
a1791 2
                 case  Lists.findp is_font_attr attr_l of
                   FONT(font) =>
d1847 50
@


1.82
log
@[Bug #20074]
Improve license dialog.
@
text
@d8 4
d830 3
@


1.81
log
@[Bug #30181]
Tidy interrupt button code.
@
text
@d8 4
d1226 1
a1226 1
  local
d1258 2
d1274 1
d1292 6
a1297 2
         [Xm.Child.CANCEL_BUTTON,
          Xm.Child.HELP_BUTTON]
d1301 3
a1303 2
	 Xm.Widget.destroy parent;
	 Exit_.terminate 1)
d1305 3
a1307 1
      Xm.Callback.add (widget, Xm.Callback.OK, exit);
d1311 1
a1311 1
      ()
@


1.80
log
@[Bug #30174]
Set application title from resource file - not here.
@
text
@d8 4
a1792 7

  fun make_interrupt_button mainWindow = 
    let val button = make_managed_widget ("interruptButton", Button, mainWindow, [])
    in
      register_interrupt_widget button;
      button
    end
@


1.79
log
@[Bug #30175]
Add all windows to dynamic menu, except top level tools.
@
text
@d8 4
d361 1
a361 1
  fun initialize_application (name,title,has_controlling_tty) =
d364 1
a364 4
        Xm.initialize
        (name, title,
         [(Xm.TITLE, Xm.STRING title),
          (Xm.ICON_NAME, Xm.STRING title)])
@


1.78
log
@Adding make_interrupt_button.
@
text
@d8 3
d348 1
d365 1
a367 1
      push ((applicationShell,title),main_windows);
d441 1
a441 1
  fun make_main_window (name,title,parent,has_context_label) =
d457 7
a463 1
      push ((shell,title),main_windows);
d485 7
@


1.77
log
@[Bug #30090]
Translate output std_out to print
@
text
@d8 4
d1769 9
a1777 1
  val register_interrupt_widget : Widget -> unit = MLWorks.Internal.Runtime.environment "x set interrupt window"
@


1.76
log
@Re-organising menus for Motif.
@
text
@d8 3
a315 1
  val debug_out = MLWorks.IO.terminal_out
a1161 17
(*
      fun moveit _ =
        let
          val (x,y) = 
            let
              val (root,win,_,_,x,y) = Xm.Display.queryPointer (Xm.Widget.display parent,
                                                                Xm.Widget.window parent)
            in
              (x,y)
            end
        in
          output (debug_out,"Setting pos to " ^ N x ^ " " ^ N y ^ "\n");
          set_pos (shell,x,y);
          ()
        end
*)

d1320 1
a1320 1
                  val _ = MLWorks.IO.output (MLWorks.IO.std_out,"Using default font\n")
@


1.75
log
@[Bug #30020]
Added call to Xm.checkMLWorksResources.
@
text
@d8 4
d454 1
a454 1
  fun make_main_popup (name,title,parent,has_context_label) =
d472 1
a472 1
  fun make_popup_shell (name,parent,attributes) =
d1133 1
a1133 1
      val shell = make_popup_shell (name,parent, [])
@


1.74
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d8 4
d351 1
@


1.73
log
@[Bug #1954]
Added dummy function set_min_window_size.
@
text
@d8 4
d1375 1
a1375 1
            Xm.GC.change (display,!gc,[(Xm.GC.CLIP_MASK Xm.GC.NONE)])
@


1.73.1.1
log
@branched from 1.73
@
text
@a7 4
 * Revision 1.73  1997/03/17  14:41:34  johnh
 * [Bug #1954]
 * Added dummy function set_min_window_size.
 *
@


1.73.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.73.1.1  1997/05/12  10:37:56  hope
 * branched from 1.73
 *
@


1.73.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.73.1.1  1997/05/12  10:37:56  hope
 * branched from 1.73
 *
@


1.73.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.73.1.1  1997/05/12  10:37:56  hope
 * branched from 1.73
 *
@


1.73.1.1.1.2
log
@[Bug #20074]
Merging - improving license dialog.
@
text
@a7 4
 *
 * Revision 1.73.1.1.1.1  1997/07/28  18:23:02  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d1205 1
a1205 1
  local 
a1236 2
      Text.set_string(name_text, !namestr);
      Text.set_string(lic_no, !numstr);
a1250 1
      val retry = ref true
d1268 2
a1269 6
         [Xm.Child.HELP_BUTTON]

      fun retryCB _ = 
	(continue := false;
	retry := true;
	Xm.Widget.destroy dialog)
d1273 2
a1274 3
	 retry := false;
	 Xm.Widget.destroy parent)

d1276 1
a1276 3
      set_label_string(Xm.MessageBox.getChild(widget, Xm.Child.OK_BUTTON), "Retry");
      Xm.Callback.add (widget, Xm.Callback.OK, retryCB);
      Xm.Callback.add (widget, Xm.Callback.CANCEL, exit);
d1280 1
a1280 1
      !retry
@


1.73.1.1.1.3
log
@[Bug #30182]
Merging - Add dummy add_del_handler function - used only on Win32.
@
text
@a8 4
 * Revision 1.73.1.1.1.2  1997/08/05  09:19:47  johnh
 * [Bug #20074]
 * Merging - improving license dialog.
 *
a791 3
      (* add_del_handler only used on Win32 *)
      fun add_del_handler _ = ()

@


1.73.1.1.1.3.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 4
 * Revision 1.73.1.1.1.3  1997/08/05  11:21:00  johnh
 * [Bug #30182]
 * Merging - Add dummy add_del_handler function - used only on Win32.
 *
@


1.72
log
@[Bug #1083]
Changed make_main_popup to use Xm.createPopupShell.
@
text
@d8 4
d481 4
@


1.71
log
@Fixed license dialog to work correctly on Irix 5.3.
@
text
@d8 3
d440 1
a440 1
        Xm.Widget.create
@


1.71.2.1
log
@branched from 1.71
@
text
@a7 3
 * Revision 1.71  1996/12/11  16:40:34  daveb
 * Fixed license dialog to work correctly on Irix 5.3.
 *
@


1.71.2.2
log
@Added dummy function (to be implemented later) for make_podium_toolbar.
@
text
@a7 3
 * Revision 1.71.2.1  1996/12/18  09:45:26  hope
 * branched from 1.71
 *
a706 3

  fun make_podium_toolbar (parent, _) = 
    Xm.Widget.createManaged("toolbar", Xm.Widget.FORM, parent, [])
@


1.71.1.1
log
@branched from 1.71
@
text
@a7 3
 * Revision 1.71  1996/12/11  16:40:34  daveb
 * Fixed license dialog to work correctly on Irix 5.3.
 *
@


1.71.1.1.1.1
log
@branched from 1.71.1.1
@
text
@a7 3
 * Revision 1.71.1.1  1996/12/17  17:51:12  hope
 * branched from 1.71
 *
@


1.70
log
@[Bug #1799]
Modify check_insertion to return its string argument
This is for compatibility with windows
@
text
@d8 5
d615 1
d619 1
d621 1
a621 1
    (Xm.Widget.realize shell)
d1190 1
d1193 1
a1193 1
      val l_dialog = make_popup_shell("Licensing", parent, [])
d1197 1
a1197 2
	        (msg_label,
	         "You must register your copy of MLWorks.");
d1203 1
d1207 3
a1209 1
         numstr := Text.get_string lic_no; ())
d1212 11
a1222 12
      in
      (Layout.lay_out (form, [Layout.FIXED msg_label,
			      Layout.SPACE,
                              Layout.FIXED name_label, Layout.FIXED name_text,
                              Layout.FIXED lic_no_label, Layout.FIXED lic_no,
                              Layout.SPACE,
                              Layout.FIXED ok_button]);
      reveal (form);
      to_front l_dialog;
      event_loop continue;
      l_dialog)
      end
@


1.70.1.1
log
@branched from 1.70
@
text
@a7 5
 * Revision 1.70  1996/11/21  12:25:17  jont
 * [Bug #1799]
 * Modify check_insertion to return its string argument
 * This is for compatibility with windows
 *
@


1.69
log
@Added dummy function for splash screen on which is implemented on Windows,.
@
text
@d8 3
d12 1
a12 1
 * Adeded license_prompt and license_compaillain.
d882 1
a882 1
      fun check_insertion _ = ()
@


1.68
log
@Adeded license_prompt and license_compaillain.
@
text
@d8 3
d1252 3
@


1.68.1.1
log
@branched from 1.68
@
text
@a7 3
 * Revision 1.68  1996/11/12  11:44:52  daveb
 * Adeded license_prompt and license_compaillain.
 *
@


1.68.1.1.1.1
log
@branched from 1.68.1.1
@
text
@a7 3
 * Revision 1.68.1.1  1996/11/14  12:53:50  hope
 * branched from 1.68
 *
@


1.67
log
@Adeded license_prompt and license_compaillain.
@
text
@@


1.66
log
@[Bug #1728]
__integer becomes __int
@
text
@d8 4
a17 1
 * [Bug #1694]
d35 1
a35 1
 * passing has_controlling_tty to exit_mlworks instead of passed ing false.
d258 1
d1174 75
@


1.65
log
@[Bug #1699]
Type of Xm.GC.copy has changed.
@
text
@d8 4
d254 1
a254 1
require "../basis/__integer";
@


1.64
log
@[Bug #1694]
[Bug #1694]
Removed Xm.widget_eq and converted Xm.CompoundString.string_convert_text
to standard identifier convention.
@
text
@d8 6
d1622 7
a1628 1
		 val new_gc_obj = Xm.GC.copy(display,window,!gc)
@


1.63
log
@Enabling close from control box on top left of window.
@
text
@d8 3
d288 1
d290 5
a294 2
  fun delete (a,[]) = []
    | delete (a,((item as (a',_))::rest)) = if Xm.widget_eq (a,a') then delete (a,rest) else item::delete (a,rest)
d296 1
d536 1
d541 1
a541 1
             Xm.CompoundString.convert_string_text filename
d543 1
@


1.62
log
@Add interrupt button to Windows.
@
text
@d8 3
d719 3
d1639 2
d1642 1
@


1.61
log
@moving String from toplevel
@
text
@d8 3
d1628 5
@


1.60
log
@Attempting to add a interrupt button handler thing
@
text
@d8 3
a255 2
  structure Option = MLWorks.Option

d357 1
a357 1
          Option.SOME
d362 1
a362 1
          Option.NONE
d670 2
a671 2
            Option.SOME (key, Xm.Event.convertState state)
        | _ => Option.NONE
d680 2
a681 2
            Option.SOME (POINT {x=x,y=y}, convert_button button)
        | _ => Option.NONE
d748 1
a748 1
          String.substring (str,from,size)
d757 2
a758 2
	  of Option.SOME _ => ()
	  |  Option.NONE =>
d778 1
a778 1
            if String.ordof (str, n) = String.ord "\n"
d789 1
a789 1
              if n = length orelse String.ordof (str, n) = String.ord "\n" then
d795 1
a795 1
            val result = String.substring (str, start, finish - start)
d810 1
a810 1
              if n = length orelse String.ordof (str, n) = String.ord "\n" then
d852 1
a852 1
                MLWorks.Option.SOME (key,modifiers) =>
d1157 1
a1157 1
                      fontstruct:Xm.font_struct ref} Option.option ref,
d1168 1
a1168 1
          Option.NONE =>
d1197 1
a1197 1
              info := Option.SOME {window=window,gc=ref gc,fontstruct=ref fontstruct}
d1205 1
a1205 1
      fun with_highlighting (GP {display,info = ref (Option.SOME {gc,...}),...}, f, a) =
d1222 1
a1222 1
      fun is_initialized (GP {info = ref (Option.SOME _),...}) = true
d1233 1
a1233 1
          Option.SOME {gc,...} =>
d1239 1
a1239 1
          Option.SOME {gc,...} =>
d1245 1
a1245 1
          Option.SOME {window,...} =>
d1252 1
a1252 1
          Option.SOME {window,...} =>
d1262 1
a1262 1
          (Option.SOME {window=window1,gc=gc1,...},Option.SOME {window=window2,...}) =>
d1271 1
a1271 1
            info=ref Option.NONE,
d1277 1
a1277 1
          GP {display,info = ref (Option.SOME {fontstruct,...}),...} =>
d1283 1
a1283 1
          GP {display,info as ref (Option.SOME {window,gc,...}), x_offset,y_offset,...} =>
d1289 1
a1289 1
          GP {display,info as ref (Option.SOME {window,gc,...}), x_offset,y_offset,...} =>
d1295 1
a1295 1
          GP {display,info as ref (Option.SOME {window,gc,...}), x_offset,y_offset,...} =>
d1302 1
a1302 1
          GP {display,info as ref (Option.SOME {window,gc,...}), x_offset,y_offset,...} =>
d1309 1
a1309 1
          GP {display,info as ref (Option.SOME {window,gc,...}), x_offset,y_offset,...} =>
d1315 1
a1315 1
          GP {display,info as ref (Option.SOME {window,gc,...}),x_offset,y_offset,...} =>
d1323 1
a1323 1
          GP {display,info as ref (Option.SOME {window,gc,...}),x_offset,y_offset,...} =>
d1498 1
a1498 1
                    Option.SOME (POINT{x,y},button) =>
d1569 1
a1569 1
         fun getAttributes (GP{display,info as ref(Option.SOME{gc,...}), ...},req_l) =
d1577 1
a1577 1
         fun setAttributes (GP{display,info as ref(Option.SOME{gc,fontstruct,...}),...},attr_l) =
d1588 1
a1588 1
         fun with_graphics_port (GP{display,info as ref(Option.SOME{window,gc,fontstruct,...}),...}, body_fn, arg) =
@


1.60.2.1
log
@branched from 1.60
@
text
@a7 3
 * Revision 1.60  1996/09/23  14:03:37  matthew
 * Attempting to add a interrupt button handler thing
 *
@


1.60.1.1
log
@branched from 1.60
@
text
@a7 3
 * Revision 1.60  1996/09/23  14:03:37  matthew
 * Attempting to add a interrupt button handler thing
 *
@


1.59
log
@[Bug #1583]
passing has_controlling_tty to exit_mlworks instead of passed ing false.
@
text
@d8 4
d304 1
a304 1
  datatype WidgetClass = Frame | Graphics | Label | Text | RowColumn | Paned | Form
d311 1
d1610 1
a1610 2
    val cast = MLWorks.Internal.Value.cast
    fun env s = cast (MLWorks.Internal.Runtime.environment s)
d1623 1
@


1.58
log
@[Bug #1539]
Restored the destroy callback for make_main_window.  This removes a destroyed
window from the list of windows.
@
text
@d8 5
d284 1
a284 1
  fun initialize_application (name,title) =
@


1.58.1.1
log
@branched from 1.58
@
text
@a7 5
 * Revision 1.58  1996/08/14  11:46:34  daveb
 * [Bug #1539]
 * Restored the destroy callback for make_main_window.  This removes a destroyed
 * window from the list of windows.
 *
@


1.57
log
@[Bug #1517]
Changed definition of Text.end_line to return the current position if it
is already at the end of a line.
@
text
@d8 5
d378 2
@


1.56
log
@Provide a system dependent line terminator
@
text
@d8 3
d797 1
a797 3
            if pos = length 
              then pos 
            else aux (pos + 1)
@


1.55
log
@[Bug #1478]
Set DELETE_RESPONSE of top level tools to do_nothing, and those of popups
to unmap.  This prevents users from deleting stack browsers or their parent
windows in the middle of an evaluation.
@
text
@d8 6
d1603 3
@


1.54
log
@[Bug #1260]
Changed the Capi layout datatype so that the PANED constructor takes the
layout info for its sub-panes.  This enables the Windows layout code to
calculate the minimum size of each window.
@
text
@d8 6
d350 11
a360 5
        Xm.Widget.create (name ^ "Shell",
                          Xm.Widget.TOP_LEVEL_SHELL,
                          parent,
                          [(Xm.TITLE, Xm.STRING title),
                           (Xm.ICON_NAME, Xm.STRING title)])
a363 1
      Xm.Callback.add (shell, Xm.Callback.DESTROY, fn _ => remove_main_window shell);
d371 10
a380 5
        Xm.Widget.create (name ^ "Shell",
                          Xm.Widget.DIALOG_SHELL,
                          parent,
                          [(Xm.TITLE, Xm.STRING title),
                           (Xm.ICON_NAME, Xm.STRING title)])
d670 1
@


1.53
log
@Bug 1378: The Windows menu needs to be cleared when entering or leaving the
GUI.  I've changed initialize_application to clear the list of main windows.
@
text
@d8 4
d831 1
a831 1
      | PANED of Widget
d861 1
a861 1
             |  PANED w => aux w
d876 1
a876 1
             |  PANED w => aux w
d880 30
a909 3
      (* lay_out_one sets the constraints for an individual widget.  The left *)
      (* and right constraints depend only on the type of the widget.  The top *)
      (* and/or bottom constraints are passed as an argument. *)
d914 6
a919 5
  |   lay_out_one (PANED w, attach) =
    Xm.Widget.valuesSet
    (* The offset 2 is to allow room for the 3D border in the parent *)
      (w, attach @@ lr_form @@
          [(Xm.LEFT_OFFSET, Xm.INT 2), (Xm.RIGHT_OFFSET, Xm.INT 2)])
d929 4
a932 4
   (pre-processed) list of classes, calling lay_out_one with appropriate
   top/bottom attachments for each class.  It returns a top_attachment
   that can be used to tie a further widget to the last in the list. *)
  fun lay_out_from_top ([], top_attach, _) =
d946 3
a948 3
   the bottom of the form instead of the top.  It expects its list argument
   to be already reversed. *)
  fun lay_out_from_bottom ([], bottom_attach, _) =
a960 13
  (* The trim_spaces function removes duplicate and trailing SPACE specifiers.
   It returns the modified list and a boolean which is true iff there were
   trailing SPACE specifiers. *)
  fun trim_spaces [] = ([], false)
    |   trim_spaces [SPACE] = ([], true)
    |   trim_spaces (SPACE :: (rest as SPACE :: _)) = trim_spaces rest
    |   trim_spaces (spec :: rest) =
        let
          val (rest', b) = trim_spaces rest
        in
          (spec :: rest', b)
        end
      
d962 2
a963 2
   It calls lay_out_from_top to do most of the work. *)
  fun lay_out_simple [] = ()
d975 7
a981 7
   divides the list into those widgets above the flex widget and those
   below, and processes these parts with lay_out_from_top and
   lay_out_from_bottom respectively.  The flex widget is then linked to
   its immediately adjoining widgets.  This ensures correct resizing of
   the flex widget.  Unfortunately this process cannot be extended to
   multiple flex widgets in Motif. *)
  fun lay_out_flex (above, flex, below) =
a1003 10
  (* find_flex splits a list into those elements before the first flex 
   widget and the rest. *)
  local 
    fun find_flex' (acc, []) = (rev acc, [])
      |   find_flex' (acc, l as FLEX flex :: _) = (rev acc, l)
      |   find_flex' (acc, c :: rest) = find_flex' (c::acc, rest)
  in
    fun find_flex l = find_flex' ([], l)
  end

d1005 3
a1007 3
   existence of a flex widget and calls the appropriate function to
   process the list. *)
  fun lay_out (_,[]) = ()
@


1.52
log
@Bug 1074: Capi.list_select now takes a function to be called on any key
press handled by the list widget itself.  In the listener, this pops the
completions widget down as if the key had been typed at the listener.
@
text
@d8 5
d251 4
d263 1
a1570 4

  fun restart () =
    (main_windows := []
     )
@


1.51
log
@Adding reset function
@
text
@d8 3
d1000 1
a1000 1
  fun list_select (parent,name) =
d1011 1
a1011 1
      val {scroll, set_items, add_items, ...} =
d1046 11
d1069 8
a1076 5
      (form,
       [Layout.FLEX scroll,
        Layout.SPACE,
        Layout.FIXED dialogButtons,
        Layout.SPACE]);
@


1.50
log
@Removed unused debugging code (that referenced MLWorks.RawIO).
@
text
@d8 3
d1544 4
@


1.49
log
@Changed highlight mode used in text widgets to reverse video.
@
text
@d8 3
a229 20

  local
     structure IO = MLWorks.RawIO 

     val std_out = IO.std_out
     val output  = IO.output

     structure Value = MLWorks.Internal.Value
     val DEFAULT = Value.DEFAULT
     val print = Value.print
  in
     fun debugP s v =
	 ( output(std_out, s);
	   print(DEFAULT,std_out,v);
	   output(std_out, "\n");
	   v
	 )
  end

  fun debug_output s = MLWorks.IO.output(MLWorks.IO.terminal_out,s ^"\n")
@


1.48
log
@Adding Text.convert_text
@
text
@d8 3
d715 1
a715 1
	  (Xm.Text.setHighlight (w, s, e, Xm.HIGHLIGHT_SECONDARY_SELECTED);
@


1.47
log
@Made read_only_before_prompt true.
@
text
@d8 3
d815 1
@


1.46
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d8 6
d789 1
a789 1
      val read_only_before_prompt = false
@


1.45
log
@Use basis integer stuff
@
text
@d8 3
d234 1
a234 1
  fun debug_output s = output(MLWorks.IO.terminal_out,s ^"\n")
d719 1
a719 1
            if String.ordof (str, n) = ord "\n"
d730 1
a730 1
              if n = length orelse String.ordof (str, n) = ord "\n" then
d751 1
a751 1
              if n = length orelse String.ordof (str, n) = ord "\n" then
d1108 1
a1108 1
                  val _ = output (std_out,"Using default font\n")
@


1.44
log
@Improved the scrolling behaviour of set_highlight.
@
text
@d8 3
d170 2
d198 1
a198 1
  val N = MLWorks.Integer.makestring
@


1.43
log
@Adding initialize_graphics and finalize_graphics functions
@
text
@d8 3
d687 14
a700 6
      fun set_highlight (w, s, e, true) =
	(Xm.Text.setHighlight (w, s, e, Xm.HIGHLIGHT_SECONDARY_SELECTED);
	 Xm.Text.showPosition (w, s))
      |   set_highlight (w, s, e, false) =
	(Xm.Text.setHighlight (w, s, e, Xm.HIGHLIGHT_NORMAL);
	 Xm.Text.showPosition (w, s))
@


1.42
log
@add_items wasn't handling empty lists correctly.
@
text
@d8 3
d1104 4
@


1.41
log
@Position completion windows not to be under pointer
@
text
@d8 3
d400 6
a405 1
        (itemlistref := !itemlistref @@ items;
d410 1
a410 1
		 items,
@


1.40
log
@Revisions to Xm library
@
text
@d8 3
d183 3
d997 17
d1018 4
@


1.39
log
@Changed return type of make_scrolllist to a record, with an extra element
add_items.  Replaced set_bottom_pos with set_pos (which can be implemented
on windows).  Added add_items to the List structure.
@
text
@d8 5
d170 1
a170 1
              sharing type Xm.Widget = FileDialog.Widget = Menus.Widget
d176 4
d186 2
a187 2
  type Widget = Xm.Widget
  type Font = Xm.Font
d191 1
a191 1
  exception WindowSystemError = Xm.X_system_error
d226 3
a228 2
        (Xm.Widget.NAME name, Xm.APP_CLASS title,
         [(Xm.Title, Xm.STRING title), (Xm.IconName, Xm.STRING title)])
d241 7
a247 7
      Frame => (Xm.Widget.Class.Frame,[])
    | Graphics => (Xm.Widget.Class.DrawingArea,[])
    | Label => (Xm.Widget.Class.LabelGadget,[])
    | Text => (Xm.Widget.Class.Text,[])
    | RowColumn => (Xm.Widget.Class.RowColumn,[])
    | Paned => (Xm.Widget.Class.PanedWindow, [(Xm.Spacing, Xm.INT 20)])
    | Form => (Xm.Widget.Class.Form,[])
d250 1
a250 1
    (Xm.MarginWidth, Xm.INT sep_size)
d252 1
a252 1
    (Xm.MarginWidth, Xm.INT 0)
d260 1
a260 1
	(Xm.Widget.NAME name, xm_class, parent,
d270 1
a270 1
	(Xm.Widget.NAME name, xm_class, parent,
d279 2
a280 2
        Xm.Widget.create (Xm.Widget.NAME "main",
                          Xm.Widget.Class.Form,
d284 1
a284 1
        (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, mainWindow, [])
d290 1
a290 1
           (Xm.Widget.NAME "contextLabel", Xm.Widget.Class.Label,mainWindow,
d299 3
a301 3
    Xm.Widget.create (Xm.Widget.NAME "main",
                      Xm.Widget.Class.Form,
                      parent, [(Xm.Width, Xm.INT 300)])
d306 2
a307 2
        Xm.Widget.create (Xm.Widget.NAME (name ^ "Shell"),
                          Xm.Widget.Class.TopLevelShell,
d309 2
a310 2
                          [(Xm.Title, Xm.STRING title),
                           (Xm.IconName, Xm.STRING title)])
d314 1
a314 1
      Xm.Widget.callbackAdd (shell, Xm.Callback.Destroy, fn _ => remove_main_window shell);
d322 2
a323 2
        Xm.Widget.create (Xm.Widget.NAME (name ^ "Shell"),
                          Xm.Widget.Class.DialogShell,
d325 2
a326 2
                          [(Xm.Title, Xm.STRING title),
                           (Xm.IconName, Xm.STRING title)])
d333 2
a334 2
    Xm.Widget.createPopupShell (Xm.Widget.NAME name,
                                Xm.Widget.Class.DialogShell,
d338 2
a339 2
    Xm.Widget.create (Xm.Widget.NAME name,
                      Xm.Widget.Class.TopLevelShell,
d341 2
a342 2
                      [(Xm.Title, Xm.STRING title),
                       (Xm.IconName, Xm.STRING title)])
d347 1
a347 1
        Xm.Widget.createScrolledText (parent, Xm.Widget.NAME name,[])
d357 2
a358 2
      val listScroll = Xm.Widget.createManaged(Xm.Widget.NAME ("scroll"),
                                               Xm.Widget.Class.ScrolledWindow,
d361 2
a362 2
        Xm.Widget.createManaged (Xm.Widget.NAME ("list"),
                                 Xm.Widget.Class.List,
d418 2
a419 2
      Xm.Widget.callbackAdd (listList,
                             Xm.Callback.SingleSelection,
d421 2
a422 2
      Xm.Widget.callbackAdd (listList,
                             Xm.Callback.DefaultAction,
d431 2
a432 2
        (Xm.Widget.NAME name,
         Xm.Widget.Class.FileSelectionBox,
d435 1
a435 1
        Xm.Widget.fileSelectionBoxGetChild(box, Xm.Widget.Child.FILTER_TEXT)
d438 2
a439 2
        (case Xm.Widget.valuesGet(box,[Xm.DirSpec]) of
           [Xm.COMPOUNDSTRING filename] =>
d442 3
a444 8
      fun get_directory () =
        Xm.Text.getString filter_text
      fun set_directory s =
        (Xm.Widget.valuesSet
         (box,
          [(Xm.Directory,
            Xm.COMPOUNDSTRING
            (Xm.CompoundString.createSimple s))]))
d447 1
a447 4
         (box,
          [(Xm.DirMask,
            Xm.COMPOUNDSTRING
            (Xm.CompoundString.createSimple s))]))
d449 2
a450 2
        (case Xm.Widget.valuesGet(box,[Xm.DirMask]) of
           [Xm.COMPOUNDSTRING mask] => mask
d452 1
a452 2
      val dir_list =
        Xm.Widget.fileSelectionBoxGetChild(box, Xm.Widget.Child.DIR_LIST)
d457 6
a462 6
       Xm.Widget.unmanage (Xm.Widget.fileSelectionBoxGetChild(box,c)))
      [Xm.Widget.Child.CANCEL_BUTTON,
       Xm.Widget.Child.OK_BUTTON,
       Xm.Widget.Child.APPLY_BUTTON,
       Xm.Widget.Child.SEPARATOR,
       Xm.Widget.Child.HELP_BUTTON];
d466 1
a466 1
      Xm.Widget.callbackAdd
d468 1
a468 1
       Xm.Callback.DefaultAction,
d473 1
a473 1
         (box, [(Xm.Directory, Xm.COMPOUNDSTRING item)])
d475 1
a475 1
      Xm.Widget.callbackAdd
d477 2
a478 2
       Xm.Callback.Activate,
       fn _ => Xm.Widget.fileSelectionDoSearch (box, get_mask ()));
d495 1
a495 1
  val hide = Xm.Widget.unmanage
d503 1
a503 1
    Xm.Widget.valuesSet (widget,[(Xm.Sensitive, Xm.BOOL sensitivity)])
d511 1
a511 1
                           [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
a518 2
  val set_busy = Xm.Widget.setBusy
  val unset_busy = Xm.Widget.unSetBusy
d521 1
a521 1
    case Xm.Widget.valuesGet (widget,[Xm.Width,Xm.Height]) of
d525 4
a528 2
  val set_message_widget = Xm.Text.setMessageWidget
  val no_message_widget = Xm.Text.noMessageWidget
d540 2
a541 2
        Xm.Widget.createPopupShell (Xm.Widget.NAME "messageDialog",
                                    Xm.Widget.Class.DialogShell,
d546 2
a547 2
        (Xm.Widget.NAME "message", Xm.Widget.Class.MessageBox, dialog,
         [(Xm.MessageString, Xm.COMPOUNDSTRING (Xm.CompoundString.createSimple message))])
d552 3
a554 3
           Xm.Widget.unmanage (Xm.Widget.messageBoxGetChild(widget,c)))
         [Xm.Widget.Child.CANCEL_BUTTON,
          Xm.Widget.Child.HELP_BUTTON]
d559 1
a559 1
      Xm.Widget.callbackAdd (widget, Xm.Callback.Ok, exit);
d565 1
a565 1
      val _ = Xm.Widget.setBusy parent
d568 1
a568 1
             | exn => (Xm.Widget.unSetBusy parent; raise exn)
d570 1
a570 1
      Xm.Widget.unSetBusy parent;
d578 1
a578 1
      type Modifier = Xm.Event.Modifier
d583 1
a583 1
          Xm.Event.KeyPress (Xm.Event.KEY_EVENT {key,state,...}) =>
d593 1
a593 1
          Xm.Event.ButtonPress (Xm.Event.BUTTON_EVENT {x,y,button,...}) =>
d599 2
a600 2
          Xm.Event.KeyPress _ => KeyPress
        | Xm.Event.ButtonPress _ => ButtonPress
d615 4
a618 4
              Activate => Xm.Callback.Activate
            | Destroy => Xm.Callback.Destroy
            | Unmap => Xm.Callback.Unmap
	    | Resize => Xm.Callback.Resize
d620 1
a620 1
          Xm.Widget.callbackAdd (w,xt,fn _ => f ())
d676 1
a676 1
      val remove_selection = Xm.Text.removeSelection
d736 1
a736 1
          Xm.Widget.callbackAdd (widget,Xm.Callback.ModifyVerify,
d739 4
a742 4
        val cut_selection : Widget -> unit = Xm.Text.cut_selection
        val paste_selection : Widget -> unit = Xm.Text.paste_selection
        val delete_selection : Widget -> unit = Xm.Text.delete_selection
        val copy_selection : Widget -> unit = Xm.Text.copy_selection
d766 1
a766 1
          Xm.Widget.callbackAdd (text,Xm.Callback.Activate,activate)
d784 11
a794 11
      val top_none = [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]
      val bottom_none = [(Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]
      val top_form = [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]
      val bottom_form = [(Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]
      val lr_form = [(Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                     (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]

      val top_offset = (Xm.TopOffset, Xm.INT sep_size)
      val bottom_offset = (Xm.BottomOffset, Xm.INT sep_size)
      val lr_offsets = [(Xm.LeftOffset, Xm.INT sep_size),
                        (Xm.RightOffset, Xm.INT sep_size)]
d801 2
a802 2
            [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
             (Xm.TopWidget, Xm.WIDGET w)]
d816 2
a817 2
            [(Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
             (Xm.BottomWidget, Xm.WIDGET w)]
d839 1
a839 1
          [(Xm.LeftOffset, Xm.INT 2), (Xm.RightOffset, Xm.INT 2)])
d931 4
a934 4
       [(Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
        (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
        (Xm.LeftOffset, Xm.INT sep_size),
        (Xm.RightOffset, Xm.INT sep_size)])
a1012 3
      val cast = MLWorks.Internal.Value.cast
      fun env s = cast (MLWorks.Internal.Runtime.environment s)

d1017 1
a1017 1
        GP of {widget: Xm.Widget,
d1020 4
a1023 4
               display: Xm.Display,
               info: {window: Xm.Drawable,
                      gc: Xm.GC ref,
                      fontstruct:Xm.FontStruct ref} Option.option ref,
d1029 1
a1029 1
      val get_widget_resource : string * string -> Xm.Font =
d1039 1
a1039 1
                case Xm.Widget.valuesGet (widget,[Xm.Background,Xm.Foreground]) of
d1204 1
a1204 1
            val scroll = Xm.Widget.createManaged (Xm.Widget.NAME "drawScroll",Xm.Widget.Class.ScrolledWindow,parent,[])
d1212 3
a1214 3
		    (Xm.Widget.NAME "drawHScroll",
		     Xm.Widget.Class.ScrollBar,scroll,
		     [(Xm.Orientation, Xm.ORIENTATION Xm.HORIZONTAL)])
d1218 1
a1218 1
			case Xm.Widget.valuesGet (hscroll,[Xm.Value]) of
d1231 1
a1231 1
		  ([(Xm.HorizontalScrollBar,Xm.WIDGET hscroll)],
d1234 1
a1234 1
		   in (Xm.Widget.callbackAdd (hscroll, Xm.Callback.Drag,
d1236 1
a1236 1
		       Xm.Widget.callbackAdd (hscroll,Xm.Callback.ValueChanged,
d1241 3
a1243 3
					[(Xm.Value, Xm.INT new_xi),
					 (Xm.Maximum, Xm.INT xextent),
					 (Xm.SliderSize,
d1252 3
a1254 3
		    (Xm.Widget.NAME "drawVScroll", 
		     Xm.Widget.Class.ScrollBar,scroll,
		     [(Xm.Orientation, Xm.ORIENTATION Xm.VERTICAL)])
d1258 1
a1258 1
			case Xm.Widget.valuesGet (vscroll,[Xm.Value]) of
d1271 1
a1271 1
		  ([(Xm.VerticalScrollBar,Xm.WIDGET vscroll)],
d1274 1
a1274 1
		   in (Xm.Widget.callbackAdd (vscroll,Xm.Callback.ValueChanged,
d1276 1
a1276 1
		       Xm.Widget.callbackAdd (vscroll,Xm.Callback.Drag,
d1281 3
a1283 3
					[(Xm.Value, Xm.INT new_yi),
					 (Xm.Maximum, Xm.INT yextent),
					 (Xm.SliderSize,
d1290 1
a1290 1
					 [(Xm.WorkWindow,Xm.WIDGET frame)])
d1336 2
a1337 2
                  Xm.Event.Expose expose_event => do_expose expose_event
                | Xm.Event.GraphicsExpose expose_event => do_expose expose_event
d1342 2
a1343 2
            Xm.Event.addHandler (main,[Xm.Event.EXPOSURE],true,expose_handler);
            Xm.Widget.callbackAdd (main,Xm.Callback.Resize,resize_callback);
d1372 1
a1372 1
          Xm.Widget.callbackAdd
d1374 1
a1374 1
           Xm.Callback.Input,
d1378 1
a1378 1
      type PixMap = Xm.Pixel
d1404 2
a1405 2
        val translate_gc_font : Xm.Font -> Font = cast
        val translate_gc_line_style : Xm.GC.LineStyle -> LineStyle = cast
d1407 2
a1408 2
        val translate_font : Font -> Xm.Font = cast
        val translate_line_style : LineStyle -> Xm.GC.LineStyle = cast
@


1.38
log
@Adding clear_rectangle again
@
text
@d8 3
d380 11
a390 2
      val select_fn' = select_fn (listScroll, listList,  set_items)
      val action_fn' = action_fn (listScroll, listList,  set_items)
d414 2
a415 1
      (listScroll,listList,set_items)
d629 3
a631 1
      val set_bottom_pos = Xm.List.setBottomPos
d972 1
a972 1
      val (scroll,_,setitems) =
d979 4
a982 1
      val dialogButtons = make_managed_widget ("dialogButtons", RowColumn,form,[])
d989 1
d993 1
a993 1
         setitems () items;
a995 1
        
@


1.37
log
@Adding set_selection for text widgets
@
text
@d8 3
a1151 1
(*
a1157 1
*)
@


1.36
log
@Fixing bungle in last change
@
text
@d8 3
d656 1
@


1.35
log
@Adding check_insertion to Text structure
@
text
@d8 3
d727 1
a727 1
      fun check_insertion = ()
@


1.34
log
@Moved file_dialog from gui to motif.
@
text
@d8 3
d722 3
@


1.33
log
@Moved definitions of open_file_dialog and save_as_dialog to FileDialog.
@
text
@d8 3
d136 1
a136 1
require "^.gui.file_dialog";
@


1.32
log
@Replaced find_file with save_as_dialog and open_file_dialog, for Windows.
@
text
@d8 3
d505 2
a506 4
  (* This defines the FileType datatype and the find_file function. *)

  val open_file_dialog = find_file
  fun save_as_dialog (parent, filter) = find_file (parent, filter, FILE)
@


1.31
log
@Moving list_select to capi
@
text
@d8 3
d503 3
@


1.30
log
@Extra stuff for finding fonts
@
text
@d8 3
d128 1
d137 1
d141 1
a141 1
              sharing type Xm.Widget = FileDialog.Widget
d919 44
@


1.29
log
@FileDialog now includes a datatype that also needs to be included here.
@
text
@d8 3
d952 13
a964 1
              val font = get_widget_resource (name ^ "Font",title ^ "GPFont")
a970 1
              val fontstruct = Xm.Font.query (display,font)
d1356 1
a1356 1
                     ( fontstruct := Xm.Font.query (display,font) )
@


1.28
log
@Changing interface to clipboard functions
@
text
@d8 3
d490 2
a491 1
  val find_file = FileDialog.find_file
@


1.27
log
@Setting right volume for bell.
@
text
@d8 3
d687 6
d1365 12
a1376 4
  val clipboard_ref = ref ""
  fun clipboard_set s = clipboard_ref := s
  fun clipboard_get _ = !clipboard_ref
  fun clipboard_empty _ = !clipboard_ref = ""
@


1.26
log
@Adding dummy transfer focus function
@
text
@d8 3
d523 1
a523 1
  fun beep widget = Xm.Display.bell (Xm.Widget.display widget,100)
@


1.25
log
@Adding some stuff for listeners
@
text
@d8 3
d446 4
d1047 1
d1054 1
@


1.24
log
@Windows menu
@
text
@d8 3
d675 3
@


1.23
log
@Adding add_input_handler
@
text
@d8 3
d159 7
d167 9
a175 3
    Xm.initialize
    (Xm.Widget.NAME name, Xm.APP_CLASS title,
     [(Xm.Title, Xm.STRING title), (Xm.IconName, Xm.STRING title)]);
d256 2
d1333 9
@


1.22
log
@Added width resource in make_subwindow.
@
text
@d8 3
a495 1
      type Event = Xm.Event.Event
d498 1
a503 1
      datatype Button = LEFT | RIGHT | OTHER
a523 1
      type CallbackData = MLWorks.Internal.Value.T
a526 1
      | ModifyVerify
a527 1
      | Input
a528 9
      fun convert_verify_data data =
        let
          val (_,event,doit,_,_,start_pos,end_pos,str) =
            Xm.Callback.convertTextVerify data
        in
          (event,start_pos,end_pos,str,fn b => Xm.Boolean.set (doit,b))
        end
      fun get_event data =
        #2 (Xm.Callback.convertAny data)
a534 1
            | ModifyVerify => Xm.Callback.ModifyVerify
a535 1
            | Input => Xm.Callback.Input
d538 1
a538 1
          Xm.Widget.callbackAdd (w,xt,f)
d540 3
a542 1
    end
d641 12
d669 1
a669 1
          Callback.add (text,Callback.Activate, activate)
d958 7
d1007 1
d1010 1
a1010 1
      fun draw_fill_rectangle (gp,REGION{x,y,width,height}) =
d1013 8
a1020 2
            Xm.Draw.fillRectangle (display,window,!gc,x - !x_offset,y - !y_offset,width+1,height+1)
	    (* X fills rectangles 1 pixel shallower and narrower than asked *)
d1197 29
a1225 1
    
@


1.21
log
@Fix brain-dead X behaviour on filled rectangles.
@
text
@d8 3
d225 1
a225 1
                      parent, [])
@


1.20
log
@Add Resize callback.
@
text
@d8 3
d1000 2
a1001 1
            Xm.Draw.fillRectangle (display,window,!gc,x - !x_offset,y - !y_offset,width,height)
@


1.19
log
@Modifying protocol for make_graphics set_position function - negative
coordinates signify no change.
@
text
@d8 4
d517 7
a523 1
      datatype Type = Activate | Destroy | ModifyVerify | Unmap | Input
d542 1
@


1.18
log
@Providing user-controlled graphics positioning.
@
text
@d8 3
d141 1
a141 1
 val sep_size = 10
d1109 2
a1110 2
            
            fun set_position (POINT{x=xi,y=yi}) = 
d1112 5
@


1.17
log
@Minor modification ...
@
text
@d8 3
d138 1
a138 1
  val sep_size = 10
d1107 13
d1152 1
a1152 1
            (scroll,gp,resize_callback)
@


1.16
log
@Removing fix for scrolling increment in graphics - this has been fixed in
the app-defaults files (i.e. the proper place).
@
text
@d8 4
d1036 1
a1036 1
                      sync_graphics_exposures();
d1076 1
a1076 1
                      sync_graphics_exposures();
@


1.15
log
@Improved scrolling in graphics objects (e.g. graph widget)
@
text
@d8 3
a1010 1
            val scroll_increment = 10  (* The number of pixels scrolled on a scrollbar click *)
d1018 1
a1018 3
		     [(Xm.Orientation, Xm.ORIENTATION Xm.HORIZONTAL),
                      (Xm.Increment, Xm.INT scroll_increment)
                     ])
d1058 1
a1058 3
		     [(Xm.Orientation, Xm.ORIENTATION Xm.VERTICAL),
                      (Xm.Increment, Xm.INT scroll_increment)
                     ])
@


1.14
log
@Adding `with_graphics_port' and related facilities.
@
text
@d8 3
a92 13

  local
     open MLWorks.Internal.Value
     open MLWorks.RawIO 
  in
     fun debugP s v =
	 ( output(std_out, s);
	   print(DEFAULT,std_out,v);
	   output(std_out, "\n");
	   v
	 )
  end

d108 20
d1008 1
d1016 3
a1018 1
		     [(Xm.Orientation, Xm.ORIENTATION Xm.HORIZONTAL)])
d1032 1
a1032 1
		      sync_graphics_exposures()
d1058 3
a1060 2
		     [(Xm.Orientation, Xm.ORIENTATION Xm.VERTICAL)])

d1074 1
a1074 1
		      sync_graphics_exposures()
@


1.13
log
@Added Capi.Text.set_highlight.
@
text
@d1 6
a6 1
(*
d8 3
a71 4
require "../motif/xm";
require "../gui/file_dialog";
require "../utils/crash";
require "../utils/lists";
d73 7
a79 1
require "../gui/capi";
d85 1
d89 14
d112 1
d826 4
d839 2
a840 3
                      gc: Xm.GC,
                      highlight_gc: Xm.GC,
                      fontstruct:Xm.FontStruct} Option.option ref,
d846 2
a847 2
      fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
      val get_widget_resource : string * string -> Xm.Font = env "x get application resource"
d861 6
a866 6
              val gc = Xm.GC.create (display,window,[Xm.GC.FONT font,
                                                     Xm.GC.FOREGROUND foreground,
                                                     Xm.GC.BACKGROUND background])
              val highlight_gc = Xm.GC.create (display,window,[Xm.GC.FONT font,
                                                               Xm.GC.FOREGROUND background,
                                                               Xm.GC.BACKGROUND foreground])
d869 1
a869 1
              info := Option.SOME {window=window,gc=gc,highlight_gc=highlight_gc,fontstruct=fontstruct}
d872 2
a873 3
            
      (* This is disgusting, I should be ashamed *)
      fun with_highlighting (GP {info = info as ref (Option.SOME data),...}, f, a) =
d875 2
a876 4
          fun reset () = info := Option.SOME data
          val {window,gc,highlight_gc,fontstruct} = data
          val _ = info := Option.SOME {window=window,gc=highlight_gc,highlight_gc=gc,fontstruct=fontstruct}
          val res = f a handle exn => (reset (); raise exn)
d878 9
a886 2
          reset ();
          res
d902 1
a902 1
            Xm.GC.change (display,gc,[(Xm.GC.CLIP_MASK Xm.GC.NONE)])
d908 1
a908 1
            Xm.GC.setClipRectangles (display,gc,0,0,[(x,y,width,height)],Xm.GC.UNSORTED)
d913 1
a913 1
          Option.SOME {window,gc,...} =>
d917 5
a921 4
      fun copy_gp (GP{display,info=info1,...},GP{info=info2,...},
                   REGION{x=x1,y=y1,width,height},
                   POINT{x=x2,y=y2}
                  ) =
d924 1
a924 1
            Xm.Draw.copyArea (display,window1,window2,gc1,x1,y1,width,height,x2,y2)
d939 1
a939 1
            Xm.Font.textExtents (fontstruct,string)
d945 1
a945 1
            Xm.Draw.point (display,window,gc,x - !x_offset,y - !y_offset)
d951 1
a951 1
            Xm.Draw.line (display,window,gc,x - !x_offset,y - !y_offset,x' - !x_offset,y' - !y_offset)
d957 1
a957 1
            Xm.Draw.rectangle (display,window,gc,x - !x_offset,y - !y_offset,width,height)
d963 1
a963 1
            Xm.Draw.fillRectangle (display,window,gc,x - !x_offset,y - !y_offset,width,height)
d969 1
a969 1
            Xm.Draw.imageString (display,window,gc,x - !x_offset,y - !y_offset,string)
d980 1
a980 1
              Xm.Draw.arc (display, window, gc,
a987 1
        fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
d1017 2
a1018 2
		      copy_gp (gp,gp,REGION{x=delta,y=0,width=w,height=h},
			       origin);
d1058 2
a1059 2
		      copy_gp (gp,gp,REGION{x=0,y=delta,width=w,height=h},
			       origin);
d1124 88
@


1.12
log
@Make scroll bars on graphics ports optional.
@
text
@d3 3
d526 7
@


1.11
log
@Updating by adding Capi Point/Region datatypes.
@
text
@d3 3
d947 2
a948 1
        fun make_scrolled_graphics (name,title,draw,get_extents,parent) =
d955 85
a1039 13
            val vscroll = 
              Xm.Widget.createManaged 
              (Xm.Widget.NAME "drawVScroll", Xm.Widget.Class.ScrollBar,scroll,
               [(Xm.Orientation, Xm.ORIENTATION Xm.VERTICAL)])
            val hscroll = 
              Xm.Widget.createManaged 
              (Xm.Widget.NAME "drawVScroll", Xm.Widget.Class.ScrollBar,scroll,
               [(Xm.Orientation, Xm.ORIENTATION Xm.HORIZONTAL)])
            val _ = Xm.Widget.valuesSet
              (scroll,
               [(Xm.VerticalScrollBar,Xm.WIDGET vscroll),
                (Xm.HorizontalScrollBar,Xm.WIDGET hscroll),
                (Xm.WorkWindow,Xm.WIDGET frame)])
a1043 29
            fun horizontal_scroll_callback data =
              let
                val new_xi = 
                  case Xm.Widget.valuesGet (hscroll,[Xm.Value]) of
                    [Xm.INT new_xi] => new_xi
                  | _ => raise Div
                val (w,h) = widget_size main
                val POINT{x=old_xi,y=old_yi} = get_offset gp
                val delta = new_xi-old_xi
              in
                set_offset (gp,POINT{x=new_xi,y=old_yi});
                copy_gp (gp,gp,REGION{x=delta,y=0,width=w,height=h},origin);
                sync_graphics_exposures()
              end
            
            fun vertical_scroll_callback data =
              let
                val new_yi = 
                  case Xm.Widget.valuesGet (vscroll,[Xm.Value]) of
                    [Xm.INT new_yi] => new_yi
                  | _ => raise Div
                val (w,h) = widget_size main
                val POINT{x=old_xi,y=old_yi} = get_offset gp
                val delta = new_yi-old_yi
              in
                set_offset (gp,POINT{x=old_xi,y=new_yi});
                copy_gp (gp,gp,REGION{x=0,y=delta,width=w,height=h},origin);
                sync_graphics_exposures()
              end
d1053 2
a1054 8
                
                (* motif scrollbars are a little fussy about allowable values *)
                Xm.Widget.valuesSet (hscroll, [(Xm.Value, Xm.INT new_xi),
                                               (Xm.Maximum, Xm.INT xextent),
                                               (Xm.SliderSize, Xm.INT (min (ww,xextent)))]);
                Xm.Widget.valuesSet (vscroll, [(Xm.Value, Xm.INT new_yi),
                                               (Xm.Maximum, Xm.INT yextent),
                                               (Xm.SliderSize, Xm.INT (min (wh,yextent)))]);
d1075 2
a1076 4
            Xm.Widget.callbackAdd (hscroll,Xm.Callback.ValueChanged,horizontal_scroll_callback);
            Xm.Widget.callbackAdd (vscroll,Xm.Callback.ValueChanged,vertical_scroll_callback);
            Xm.Widget.callbackAdd (hscroll,Xm.Callback.Drag,horizontal_scroll_callback);
            Xm.Widget.callbackAdd (vscroll,Xm.Callback.Drag,vertical_scroll_callback);
@


1.10
log
@Changing top level window initialization
@
text
@d3 3
d74 6
d445 1
a445 1
            Option.SOME (x,y,convert_button button)
d789 1
a789 1
          
d849 3
a851 2
      fun get_offset (GP {x_offset,y_offset,...}) = (!x_offset,!y_offset)
      fun set_offset (GP {x_offset,y_offset,...},x,y) = (x_offset := max (x,0); y_offset:= max (y,0))
d859 1
a859 1
      fun set_clip_region (GP{display,info,...},(x,y,width,height)) =
d871 4
a874 1
      fun copy_gp (GP{display,info=info1,...},GP{info=info2,...},x1,y1,width,height,x2,y2) =
d876 1
a876 1
          (Option.SOME {window=window1,gc=gc1,...},Option.SOME {window=window2,gc=gc2,...}) =>
d895 1
a895 1
      fun draw_point (gp,x,y) =
d901 1
a901 1
      fun draw_line (gp,x,y,x',y') =
d907 1
a907 1
      fun draw_rectangle (gp,x,y,w,h) =
d910 1
a910 1
            Xm.Draw.rectangle (display,window,gc,x - !x_offset,y - !y_offset,w,h)
d913 1
a913 1
      fun draw_fill_rectangle (gp,x,y,w,h) =
d916 1
a916 1
            Xm.Draw.fillRectangle (display,window,gc,x - !x_offset,y - !y_offset,w,h)
d919 1
a919 1
      fun draw_image_string (gp,string,x,y) =
d927 1
a927 1
      fun draw_arc (gp,x,y,width,height,theta1,theta2) =
d933 4
a936 1
              Xm.Draw.arc (display,window,gc,x,y,width,height,convert_theta theta1, convert_theta theta2)
d974 2
a975 2
                val (width,height) = widget_size main
                val (old_xi,old_yi) = get_offset gp
d978 2
a979 2
                set_offset (gp,new_xi,old_yi);
                copy_gp (gp,gp,delta,0,width,height,0,0);
d989 2
a990 2
                val (width,height) = widget_size main
                val (old_xi,old_yi) = get_offset gp
d993 2
a994 2
                set_offset (gp,old_xi,new_yi);
                copy_gp (gp,gp,0,delta,width,height,0,0);
d1002 1
a1002 1
                val (xi,yi) = get_offset gp
d1014 1
a1014 1
                set_offset (gp,new_xi,new_yi);
d1018 2
a1019 2
            fun do_expose (Xm.Event.EXPOSE_EVENT {common,x,y,width,height,count}) =
              draw (gp,x,y,width,height)
@


1.9
log
@Adding make_message_text
@
text
@d3 3
d335 6
a340 1
  val initialize = Xm.Widget.realize
@


1.8
log
@Updating for windows stuff
@
text
@d3 3
d197 2
@


1.7
log
@Updating for Windows changes
@
text
@d3 3
d142 6
a147 1
  fun make_main_window (name,title,applicationShell,has_context_label) =
d150 1
a150 1
        Xm.Widget.create (Xm.Widget.NAME (name^"Shell"),
d152 1
a152 1
                          applicationShell,
d161 13
d191 1
d327 3
a329 3
  val realize = Xm.Widget.realize
  val manage = Xm.Widget.manage
  val unmanage = Xm.Widget.unmanage
d576 2
a577 1
      | TEXT of Widget
a578 1
      | OTHER of Widget
d606 1
a606 1
             |  TEXT w => aux w
d608 1
a608 1
             |  OTHER w => aux w
d621 1
a621 1
             |  TEXT w => aux w
d623 1
a623 1
             |  OTHER w => aux w
d643 1
a643 1
  |   lay_out_one (TEXT w, attach) =
d645 1
a645 1
  |   lay_out_one (OTHER w, attach) =
d694 1
a694 1
  (* lay_out_simple is used for any list that doesn't contain a text widget.
d707 2
a708 2
  (* lay_out_text is used for any list that includes a text widget.  It
   divides the list into those widgets above the text widget and those
d710 1
a710 1
   lay_out_from_bottom respectively.  The text widget is then linked to
d712 3
a714 3
   the text widget.  Unfortunately this process cannot be extended to
   multiple text widgets in Motif. *)
  fun lay_out_text (above, text, below) =
d729 1
a729 1
      (text,
d737 1
a737 1
  (* find_text splits a list into those elements before the first text 
d740 3
a742 3
    fun find_text' (acc, []) = (rev acc, [])
      |   find_text' (acc, l as TEXT text :: _) = (rev acc, l)
      |   find_text' (acc, c :: rest) = find_text' (c::acc, rest)
d744 1
a744 1
    fun find_text l = find_text' ([], l)
d748 1
a748 1
   existence of a text widget and calls the appropriate function to
d753 1
a753 1
        val (above, rest) = find_text l
d757 2
a758 2
           |  (TEXT text::below) => (lay_out_text (above, text, below); ())
           |  _ => Crash.impossible "non-text class returned from find_text"
@


1.6
log
@Removing PushButton class
@
text
@d3 3
a329 39
  (* This function should only be called for the special purpose of quitting *)
  (* So I haven't put it in xm.sml *)
  local 
    fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
  in
    val quit_on_exit : unit -> unit = env "x quit on exit"
  end

  fun exit_dialog (parent,applicationShell,has_controlling_tty) =
    let
      val shell =
        Xm.Widget.createPopupShell (Xm.Widget.NAME "quitDialog",
                                    Xm.Widget.Class.DialogShell,
                                    parent, [])

      (* To make life easy, we use a standard MessageBox widget and
       change the labels and actions around.  *)
      val message =
        Xm.Widget.create
        (Xm.Widget.NAME "message", Xm.Widget.Class.MessageBox, shell,
         [])
                
      fun tty _ = Xm.Widget.destroy applicationShell
      fun exit _ = (quit_on_exit(); Xm.Widget.destroy applicationShell);
      fun cancel _ = Xm.Widget.destroy shell
    in
      if not has_controlling_tty then
        Xm.Widget.unmanage
        (Xm.Widget.messageBoxGetChild
         (message, Xm.Widget.Child.OK_BUTTON))
      else 
        ();
      Xm.Widget.callbackAdd (message, Xm.Callback.Ok, tty);
      Xm.Widget.callbackAdd (message, Xm.Callback.Help, cancel);
      Xm.Widget.callbackAdd (message, Xm.Callback.Cancel, exit);
      Xm.Widget.manage message
    end


d529 19
@


1.5
log
@make_main_subwindows shouldn't manage the form.
@
text
@d3 3
d75 1
a75 1
  datatype WidgetClass = Frame | Graphics | Label | PushButton | Text | RowColumn | Paned | Form
a81 1
    | PushButton => (Xm.Widget.Class.PushButtonGadget,[])
@


1.4
log
@Modifications for PC port
@
text
@d3 3
d115 3
a117 3
        Xm.Widget.createManaged (Xm.Widget.NAME "main",
                                 Xm.Widget.Class.Form,
                                 parent, [])
d144 1
@


1.3
log
@Adding event handler stuff
@
text
@d3 3
d422 1
a422 1
      datatype button = LEFT | RIGHT | OTHER
d739 10
a748 10
  fun lay_out [] = ()
    |   lay_out l =
        let
          val (above, rest) = find_text l
        in
          case rest 
            of [] => lay_out_simple above
             |  (TEXT text::below) => (lay_out_text (above, text, below); ())
             |  _ => Crash.impossible "non-text class returned from find_text"
        end
@


1.2
log
@Moved capi to gui
@
text
@d3 3
d118 1
a118 1
          MLWorks.Option.SOME
d123 1
a123 1
          MLWorks.Option.NONE
d417 8
a424 2
            MLWorks.Option.SOME (key, Xm.Event.convertState state)
        | _ => MLWorks.Option.NONE
d427 3
a429 3
          Xm.Event.ButtonPress (Xm.Event.BUTTON_EVENT {x,y,...}) =>
            MLWorks.Option.SOME (x,y)
        | _ => MLWorks.Option.NONE
d759 4
a762 1
               info: {window: Xm.Drawable,gc: Xm.GC,fontstruct:Xm.FontStruct} Option.option ref,
d786 3
d791 1
a791 1
              info := MLWorks.Option.SOME {window=window,gc=gc,fontstruct=fontstruct}
d794 13
d808 1
a808 1
      fun is_initialized (GP {info = ref (MLWorks.Option.SOME _),...}) = true
@


1.1
log
@new unit
New unit
@
text
@d3 4
d32 1
a32 1
require "../library/file_dialog";
d35 2
a36 1
require "../library/capi";
@
