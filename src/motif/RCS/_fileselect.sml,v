head	1.93;
access;
symbols
	ML_beta_release_12/08/94:1.68
	ML_beta_release_03/08/94:1.68
	ML_revised_beta_release_25/05/94:1.62
	ML_final_beta_release_02/03/94:1.57
	mlworks-28-01-1994:1.54
	Release:1.38
	mlworks-beta-01-09-1993:1.38;
locks; strict;
comment	@ * @;


1.93
date	95.07.12.14.30.58;	author matthew;	state Exp;
branches;
next	1.92;

1.92
date	95.07.07.15.32.06;	author daveb;	state Exp;
branches;
next	1.91;

1.91
date	95.07.04.15.40.22;	author matthew;	state Exp;
branches;
next	1.90;

1.90
date	95.07.04.12.50.18;	author daveb;	state Exp;
branches;
next	1.89;

1.89
date	95.06.15.13.00.27;	author daveb;	state Exp;
branches;
next	1.88;

1.88
date	95.06.14.13.29.36;	author daveb;	state Exp;
branches;
next	1.87;

1.87
date	95.06.13.16.38.06;	author daveb;	state Exp;
branches;
next	1.86;

1.86
date	95.06.09.09.43.16;	author daveb;	state Exp;
branches;
next	1.85;

1.85
date	95.06.05.13.23.47;	author daveb;	state Exp;
branches;
next	1.84;

1.84
date	95.06.01.10.32.54;	author daveb;	state Exp;
branches;
next	1.83;

1.83
date	95.05.23.09.10.10;	author daveb;	state Exp;
branches;
next	1.82;

1.82
date	95.05.16.09.20.05;	author matthew;	state Exp;
branches;
next	1.81;

1.81
date	95.05.04.09.46.35;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	95.04.28.16.53.29;	author daveb;	state Exp;
branches;
next	1.79;

1.79
date	95.04.20.15.51.46;	author daveb;	state Exp;
branches;
next	1.78;

1.78
date	95.04.19.10.58.43;	author daveb;	state Exp;
branches;
next	1.77;

1.77
date	95.03.17.12.28.00;	author daveb;	state Exp;
branches;
next	1.76;

1.76
date	95.03.16.14.32.30;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	95.03.15.16.33.06;	author daveb;	state Exp;
branches;
next	1.74;

1.74
date	95.03.10.15.38.01;	author daveb;	state Exp;
branches;
next	1.73;

1.73
date	95.02.20.14.53.48;	author daveb;	state Exp;
branches;
next	1.72;

1.72
date	95.01.16.14.22.47;	author daveb;	state Exp;
branches;
next	1.71;

1.71
date	94.11.30.15.27.13;	author daveb;	state Exp;
branches;
next	1.70;

1.70
date	94.08.17.17.32.36;	author daveb;	state Exp;
branches;
next	1.69;

1.69
date	94.08.17.16.13.49;	author daveb;	state Exp;
branches;
next	1.68;

1.68
date	94.08.01.11.21.28;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	94.07.27.16.20.32;	author daveb;	state Exp;
branches;
next	1.66;

1.66
date	94.07.12.15.57.13;	author daveb;	state Exp;
branches;
next	1.65;

1.65
date	94.07.11.11.51.33;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	94.06.30.17.41.24;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	94.06.21.15.13.13;	author daveb;	state Exp;
branches;
next	1.62;

1.62
date	94.05.13.15.37.07;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	94.03.30.17.39.58;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	94.03.28.15.40.16;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	94.03.17.17.47.28;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	94.03.15.16.40.17;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	94.02.23.17.03.02;	author nosa;	state Exp;
branches;
next	1.56;

1.56
date	94.02.08.18.08.59;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	94.02.02.11.47.36;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	94.01.26.18.09.54;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	93.12.22.10.59.43;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	93.12.20.12.48.43;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	93.12.10.16.00.11;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	93.12.09.19.34.38;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	93.12.08.14.28.26;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	93.12.06.12.58.44;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	93.11.26.12.13.23;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	93.11.18.17.59.00;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	93.11.04.19.02.20;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	93.11.04.17.41.18;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	93.11.02.16.33.50;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	93.11.02.15.27.22;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	93.10.27.12.52.21;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	93.10.22.16.58.09;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	93.10.08.16.30.04;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	93.08.31.15.44.34;	author matthew;	state Exp;
branches
	1.38.1.1;
next	1.37;

1.37
date	93.08.29.20.33.52;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	93.08.28.17.06.27;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	93.08.27.16.36.11;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.08.20.10.41.23;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	93.08.20.08.08.34;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	93.08.17.18.38.41;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	93.08.11.11.24.54;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	93.08.10.14.46.06;	author nosa;	state Exp;
branches;
next	1.29;

1.29
date	93.08.10.14.02.23;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.08.03.16.47.56;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.07.29.16.08.45;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.06.16.13.04.14;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.06.04.15.21.24;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	93.06.03.15.51.40;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.05.28.16.17.54;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.05.27.10.13.15;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.05.25.16.41.52;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.05.18.17.28.06;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	93.05.13.14.22.30;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	93.05.12.16.14.02;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.05.11.17.03.55;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.05.06.14.10.08;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	93.05.05.12.10.51;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	93.05.04.15.47.43;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.05.04.12.26.50;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.04.30.16.03.45;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.04.28.10.44.36;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	93.04.27.14.43.28;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	93.04.22.13.30.57;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	93.04.20.16.12.02;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	93.04.19.17.00.51;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.04.16.17.05.35;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.04.15.16.13.59;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.04.14.17.23.01;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.04.08.18.42.34;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.04.05.14.50.21;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	93.04.01.17.18.05;	author matthew;	state Exp;
branches;
next	;

1.38.1.1
date	93.08.31.15.44.34;	author jont;	state Exp;
branches;
next	1.38.1.2;

1.38.1.2
date	93.10.07.16.36.54;	author matthew;	state Exp;
branches;
next	1.38.1.3;

1.38.1.3
date	93.10.21.14.03.38;	author daveb;	state Exp;
branches;
next	1.38.1.4;

1.38.1.4
date	93.10.27.16.24.06;	author daveb;	state Exp;
branches;
next	1.38.1.5;

1.38.1.5
date	93.11.01.15.16.30;	author daveb;	state Exp;
branches;
next	1.38.1.6;

1.38.1.6
date	93.11.02.16.28.09;	author daveb;	state Exp;
branches;
next	1.38.1.7;

1.38.1.7
date	93.11.04.17.29.50;	author daveb;	state Exp;
branches;
next	1.38.1.8;

1.38.1.8
date	93.11.04.18.55.20;	author daveb;	state Exp;
branches;
next	;


desc
@Motif file selection box
@


1.93
log
@Removing Incremental from Ml_Debugger
@
text
@(*
 * Copyright (c) 1993 Harlequin Ltd.
 *  $Log: _fileselect.sml,v $
 *  Revision 1.92  1995/07/07  15:32:06  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.91  1995/07/04  15:40:22  matthew
 *  Capification
 *
 *  Revision 1.90  1995/07/04  12:50:18  daveb
 *  Replaced input and output windows with a single console window.
 *
 *  Revision 1.89  1995/06/15  13:00:27  daveb
 *  Hid details of WINDOWING type in ml_debugger.
 *
 *  Revision 1.88  1995/06/14  13:29:36  daveb
 *  Type of Ml_Debugger.ml_debugger has changed.
 *  ShellUtils.edit_* functions no longer require a context argument.
 *
 *  Revision 1.87  1995/06/13  16:38:06  daveb
 *  Added an input tool.
 *
 *  Revision 1.86  1995/06/09  09:43:16  daveb
 *  ensure_output is now done by the output widget.
 *
 *  Revision 1.85  1995/06/05  13:23:47  daveb
 *  Changed sensitivity argument of view_options to NO_SENSE_SELECTION,
 *  because the shell functions now set the current selection.
 *
 *  Revision 1.84  1995/06/01  10:32:54  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.83  1995/05/23  09:10:10  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.82  1995/05/16  09:20:05  matthew
 *  Removing Toplevel structure
 *
 *  Revision 1.81  1995/05/04  09:46:35  matthew
 *  Removed script from ml_debugger
 *
 *  Revision 1.80  1995/04/28  16:53:29  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.79  1995/04/20  15:51:46  daveb
 *  filesys and path moved from utils to initbasis.
 *  
 *  Revision 1.78  1995/04/19  10:58:43  daveb
 *  Changes to context_menu.
 *  
 *  Revision 1.77  1995/03/17  12:28:00  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 *  
 *  Revision 1.76  1995/03/16  14:32:30  daveb
 *  Removed context_function from register when closing the window.
 *  
 *  Revision 1.75  1995/03/15  16:33:06  daveb
 *  Changed to share current context with other tools..
 *  
 *  Revision 1.74  1995/03/10  15:38:01  daveb
 *  MotifUtils.options_menu now takes an extra argument.
 *  
 *  Revision 1.73  1995/02/20  14:53:48  daveb
 *  ActionQueue.do_actions now takes an output function argument.
 *  
 *  Revision 1.72  1995/01/16  14:22:47  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *  Replaced FileName parameter with Path.
 *  Removed obsolete sharing constraints.
 *  
 *  Revision 1.71  1994/11/30  15:27:13  daveb
 *  Fixed bug in form layout code for MIPS.  Also simplified this code
 *  by replacing separator widgets with Xm.*Offset values.
 *  
 *  Revision 1.70  1994/08/17  17:32:36  daveb
 *  Removed unused Module and Crash arguments of functor.
 *  
 *  Revision 1.69  1994/08/17  16:13:49  daveb
 *  Ensured that paths are expanded before being added to source path.
 *  
 *  Revision 1.68  1994/08/01  11:21:28  daveb
 *  Moved preferences to a separate structure.
 *  
 *  Revision 1.67  1994/07/27  16:20:32  daveb
 *  Cut-down menus for novices.  Also reorganised the make and compile
 *  menus into submenus of an action menu in the full_menus case.
 *  
 *  Revision 1.66  1994/07/12  15:57:13  daveb
 *  ToolData.works_menu takes different arguments.
 *  
 *  Revision 1.65  1994/07/11  11:51:33  daveb
 *  Replaced TextString with DirSpec.
 *  
 *  Revision 1.64  1994/06/30  17:41:24  daveb
 *  Added a comment about the buttons in the file selection box (old code).
 *  
 *  Revision 1.63  1994/06/21  15:13:13  daveb
 *  Moved output window code into separate file.
 *  Types of ActionQueue.Error, ErrorBrowser.create and ActionQueue.do_actions
 *  have changed.
 *  
 *  Revision 1.62  1994/05/13  15:37:07  daveb
 *  Moved error browser to separate file.
 *  
 *  Revision 1.61  1994/03/30  17:39:58  daveb
 *  Implemented touch_compile_{module,file}.
 *  
 *  Revision 1.60  1994/03/28  15:40:16  daveb
 *  Replaced Actions menu with Make and Compile menus.
 *  
 *  Revision 1.59  1994/03/17  17:47:28  matthew
 *  Added check make dependencies
 *  
 *  Revision 1.58  1994/03/15  16:40:17  matthew
 *  Changed printing of locations
 *  Split title into two parts, one the file being made, the other the file in which the error occurred.
 *  Fixed problem with redo action
 *  Cleaned up error_handler function
 *  
 *  Revision 1.57  1994/02/23  17:03:02  nosa
 *  Debugger scripts for tracing tool using debugger.
 *  
 *  Revision 1.56  1994/02/08  18:08:59  daveb
 *  IO.get_source_path can no longer raise an exception.
 *  
 *  Revision 1.55  1994/02/02  11:47:36  daveb
 *  MOved check_search_path to Module, and stopped using it here anyway.
 *  
 *  Revision 1.54  1994/01/26  18:09:54  matthew
 *  Protect change to no_execute with handler
 *  
 *  Revision 1.53  1993/12/22  10:59:43  daveb
 *  Changed quit message for debugger, since it no longer raises Interrupt.
 *  
 *  Revision 1.52  1993/12/20  12:48:43  matthew
 *  Changed output and error browser to be toplevel shells
 *  Started putting in warning browser stuff
 *  
 *  Revision 1.51  1993/12/10  16:00:11  daveb
 *  Added context menu, ensured that changes do the right thing, ensured that
 *  new selection is passed on to child tools.
 *  
 *  Revision 1.50  1993/12/09  19:34:38  jont
 *  Added copyright message
 *  
 *  Revision 1.49  1993/12/08  14:28:26  daveb
 *  Changed class of Output window shell to DialogShell, so that the Motif close
 *  button unmanges it rather than destroying it.  Explicitly managed its form
 *  widget, 'cos otherwise it doesn't work.  Added Unmap callbacks to the
 *  output window and the error browser.
 *  
 *  Revision 1.48  1993/12/06  12:58:44  daveb
 *  Changed "Recompile" command to "compile", losing the old "compile" command.
 *  Changed remake to force_make in history, and also in internal datatype.
 *  
 *  Revision 1.47  1993/11/26  12:13:23  matthew
 *  Improvements to debugger calling.
 *  
 *  Revision 1.46  1993/11/18  17:59:00  daveb
 *  The argument to Ml_Debugger.with_debugger_type now takesa frame argument
 *  instead of unit.
 *  
 *  Revision 1.45  1993/11/04  19:02:20  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.44  1993/11/04  17:41:18  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.43  1993/11/02  16:33:50  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.42  1993/11/02  15:27:22  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.38.1.8  1993/11/04  18:55:20  daveb
 *  Disabled menu items when they are inappropriate.  Also selected the
 *  first entry in the error browser when it is mapped.
 *  
 *  Revision 1.38.1.7  1993/11/04  17:29:50  daveb
 *  Redo was invoking the action from the top of the history, but the history
 *  can be extended in the meantime.  This version redoes the action that
 *  caused the error.  The implementation is slightly simpler too.
 *  
 *  Revision 1.38.1.6  1993/11/02  16:28:09  daveb
 *  Fixed bug in delete_from_source_path.
 *  
 *  Revision 1.38.1.5  1993/11/01  15:16:30  daveb
 *  Added redo action to error browser.
 *  
 *  Revision 1.38.1.4  1993/10/27  16:24:06  daveb
 *  Merged bug fix into the bug fixing branch.
 *  
 *  Revision 1.41  1993/10/27  12:52:21  daveb
 *  Prevented duplicate or null entries in source path.
 *  Allowed selected directory to be added to source path without having
 *  to move into that directory.
 *  
 *  Revision 1.40  1993/10/22  16:58:09  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.39  1993/10/08  16:30:04  matthew
 *  Merging in bug fixes
 *  
 *  Revision 1.38.1.3  1993/10/21  14:03:38  daveb
 *  Changed ToolData.works_menu to take a (unit -> bool) function that
 *  controls whether the Close menu option is enabled.
 *  
 *  Revision 1.38.1.2  1993/10/07  16:36:54  matthew
 *  Added destroy callback to do quit functions
 *  
 *  Revision 1.38.1.1  1993/08/31  15:44:34  jont
 *  Fork for bug fixing
 *  
 *  Revision 1.38  1993/08/31  15:44:34  matthew
 *  Added Context label widget
 *  
 *  Revision 1.37  1993/08/29  20:33:52  daveb
 *  Removed filter button.  Added source path pane.  Tidied up a bit.
 *  Source path isn't properly integrated with compilation yet.
 *  
 *  Revision 1.36  1993/08/28  17:06:27  daveb
 *  Recompile.recompile and TopLevel.compile_file now take list arguments.
 *  
 *  Revision 1.35  1993/08/27  16:36:11  matthew
 *  Improved messages
 *  Renamed message to message_fun.
 *  
 *  Revision 1.34  1993/08/20  10:41:23  daveb
 *  Improved layout of error browser.
 *  
 *  Revision 1.33  1993/08/20  08:08:34  daveb
 *  Added "Check dependencies" action.
 *  
 *  Revision 1.32  1993/08/17  18:38:41  daveb
 *  Make, remake, compile and recompile check whether the file is on the
 *  search path.
 *  
 *  Revision 1.31  1993/08/11  11:24:54  matthew
 *  Changes to user options
 *  Removed preferences menu
 *  Options update
 *  
 *  Revision 1.30  1993/08/10  14:46:06  nosa
 *  tooldata passed to make_debugger_window for inspector invocation
 *  in debugger-window.
 *  
 *  Revision 1.29  1993/08/10  14:02:23  matthew
 *  Changed name to File Tool
 *  Get maximum history length from options
 *  Auto popup of output windows
 *  
 *  Revision 1.28  1993/08/03  16:47:56  matthew
 *  Operation to bring output window to front
 *  Added "Line" to error output
 *  
 *  Revision 1.27  1993/07/29  16:08:45  matthew
 *  Changed printing of Location.FILE in error browser
 *  Added Interrupt handler to mk_action
 *  Added call to MotifUtils.with_message, this actually uses a busy cursor
 *  Changed Info.default_options to Info.make_default_options
 *  
 *  Revision 1.26  1993/06/16  13:04:14  matthew
 *  Added remake function
 *  
 *  Revision 1.25  1993/06/04  15:21:24  daveb
 *  edit functions now return a single string in the errorneous case.
 *  
 *  Revision 1.24  1993/06/03  15:51:40  matthew
 *  More informative messages
 *  
 *  Revision 1.23  1993/05/28  16:17:54  matthew
 *  Added tty_ok value to WINDOWINF
 *  
 *  Revision 1.22  1993/05/27  10:13:15  matthew
 *  Changed error handling for make, use etc.
 *  
 *  Revision 1.21  1993/05/25  16:41:52  matthew
 *  Added history and removed some of the buttons
 *  
 *  Revision 1.20  1993/05/18  17:28:06  jont
 *  Removed integer parameter
 *  
 *  Revision 1.19  1993/05/13  14:22:30  daveb
 *  All tools now set their own titles and pass them to their options menus.
 *  
 *  Revision 1.18  1993/05/12  16:14:02  matthew
 *  Added use.  Changed make.  Uses ShellUtils more.
 *  
 *  Revision 1.17  1993/05/11  17:03:55  matthew
 *  Added make command
 *  
 *  Revision 1.16  1993/05/06  14:10:08  daveb
 *  Changed to use MotifUtils.make_outstream
 *  
 *  Revision 1.15  1993/05/05  12:10:51  daveb
 *  Added tools argument to works_menu(),
 *  removed exitApplication from TOOLDATA (works_menu now accesses it directly).
 *  
 *  Revision 1.14  1993/05/04  15:47:43  matthew
 *  Fixed bug with options used by error browser.
 *  
 *  Revision 1.13  1993/05/04  12:26:50  matthew
 *  Added facility to show and hide output widget.
 *  
 *  Revision 1.12  1993/04/30  16:03:45  daveb
 *  Reorganised menus.
 *  
 *  Revision 1.11  1993/04/28  10:44:36  daveb
 *  Now uses MotifUtils.scrolllist.
 *  
 *  Revision 1.10  1993/04/27  14:43:28  daveb
 *  Moved options menu code to _motif_utils.
 *  
 *  Revision 1.9  1993/04/22  13:30:57  richard
 *  The editor interface is now implemented directly through
 *  Unix system calls, and is not part of the pervasive library
 *  or the runtime system.
 *  
 *  Revision 1.8  1993/04/20  16:12:02  richard
 *  Incorrect use of ordof().
 *  
 *  Revision 1.7  1993/04/19  17:00:51  matthew
 *  Added error selection dialog
 *  Start of "Default action" stuff
 *  
 *  Revision 1.6  1993/04/16  17:05:35  matthew
 *  Changed to ToolData interface
 *  
 *  Revision 1.5  1993/04/15  16:13:59  matthew
 *  Added proper interface to editor
 *  and an output window.  Much code duplicated from _listener.
 *  
 *  Revision 1.4  1993/04/14  17:23:01  matthew
 *  Much changed.  Added options and proper recompile etc. function.
 *  
 *  Revision 1.3  1993/04/08  18:42:34  matthew
 *  More hackery, still doesn't work
 *  
 *  Revision 1.2  1993/04/05  14:50:21  daveb
 *  Names of Callbacks have changed.
 *  
 *  Revision 1.1  1993/04/01  17:18:05  matthew
 *  Initial revision
 *  
 *)

require "../utils/lists";
require "../initbasis/path";
require "../make/recompile";
require "../main/io";
require "../editor/editor";
require "../main/user_options";
require "../main/preferences";
require "../library/capi";
require "../debugger/ml_debugger";
require "motif_utils";
require "../interpreter/shell_utils";
require "../interpreter/action_queue";
require "console";
require "debugger_window";
require "tooldata";
require "menus";
require "error_browser";

require "fileselect";

functor FileSelect(
  structure DebuggerWindow : DEBUGGERWINDOW
  structure Ml_Debugger : ML_DEBUGGER
  structure ErrorBrowser : ERROR_BROWSER
  structure Lists : LISTS
  structure Capi : CAPI
  structure Menus : MENUS
  structure Editor : EDITOR
  structure Recompile : RECOMPILE
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure ToolData : TOOL_DATA
  structure MotifUtils : MOTIF_UTILS
  structure ShellUtils : SHELL_UTILS
  structure ActionQueue : ACTION_QUEUE
  structure Io: IO
  structure Path: PATH
  structure Console: CONSOLE

  sharing Recompile.Info = ShellUtils.Info = ActionQueue.Info
  sharing UserOptions.Options = Recompile.Options =
          ShellUtils.Options =
	  ToolData.ShellTypes.Options = Ml_Debugger.ValuePrinter.Options
  sharing Recompile.Info.Location = Editor.Location

  sharing type Preferences.user_preferences = MotifUtils.user_preferences =
	       ToolData.ShellTypes.user_preferences = Console.user_preferences
  sharing type UserOptions.user_context_options =
	       ToolData.UserContext.user_context_options =
	       MotifUtils.user_context_options
  sharing type ToolData.ShellTypes.Context = ShellUtils.Context
  sharing type Menus.Widget = ToolData.Widget =
	       MotifUtils.Widget = DebuggerWindow.Widget =
	       ErrorBrowser.Widget = Capi.Widget = Console.Widget
  sharing type Menus.ButtonSpec = MotifUtils.ButtonSpec = ToolData.ButtonSpec
  sharing type UserOptions.user_tool_options = ShellUtils.UserOptions =
	       ToolData.ShellTypes.user_options =
	       MotifUtils.user_tool_options = ActionQueue.UserOptions
  sharing type ToolData.ToolData = DebuggerWindow.ToolData
  sharing type MotifUtils.user_context = ToolData.ShellTypes.user_context =
	       ActionQueue.user_context
  sharing type ErrorBrowser.error = Recompile.Info.error
  sharing type ErrorBrowser.location = Recompile.Info.Location.T
  sharing type Ml_Debugger.preferences = ShellUtils.preferences =
	       Editor.preferences = Preferences.preferences
  sharing type MotifUtils.MotifContext = ToolData.MotifContext            
  sharing type Ml_Debugger.debugger_window = DebuggerWindow.debugger_window
) : FILE_SELECT =
  struct

    type Widget = Capi.Widget

    structure ShellTypes = ToolData.ShellTypes
    structure UserContext = ToolData.UserContext
    structure Options = UserOptions.Options
    structure Info = Recompile.Info
    structure Location = Info.Location

    structure Integer = MLWorks.Integer

    (* This is some test code that should be combined with the listener *)

    type ToolData = ToolData.ToolData

    (* This should be a utility *)
    local
    fun first_line message =
      let
        fun aux ([],acc) = acc
          | aux ("\n" :: _,acc) = acc
          | aux (c::l,acc) = aux(l,c::acc)
      in
        implode (rev (aux (explode message,[])))
      end
        
    fun location_line location =
      case location of
        Location.UNKNOWN => ""
      | Location.FILE s => ""
      | Location.LINE(_,l) => "Line " ^ MLWorks.Integer.makestring l
      | Location.POSITION (_,l,_) => "Line " ^ MLWorks.Integer.makestring l
      | Location.EXTENT {s_line,e_line,...} =>
          if s_line = e_line
            then "Line " ^ MLWorks.Integer.makestring s_line
          else "Line " ^ MLWorks.Integer.makestring s_line ^ " to " ^ MLWorks.Integer.makestring e_line
                
    in

    fun error_to_string _ (Info.ERROR(severity,location,message)) =
      (case location_line location of
         "" => first_line message
       | l => l ^ ": " ^ first_line message)

    end

    (* Should be a util *)
    fun location_file (Info.ERROR(_,location,message)) =
      case location of
        Location.UNKNOWN => MLWorks.Option.NONE
      | Location.FILE f => MLWorks.Option.SOME f
      | Location.LINE(f,l) => MLWorks.Option.SOME f
      | Location.POSITION (f,l,_) => MLWorks.Option.SOME f
      | Location.EXTENT {name,...} => MLWorks.Option.SOME name

    val browser_number = ref 1

    fun create (tooldata as ToolData.TOOLDATA
		  {args, appdata, current_context, motif_context, tools}) =
      let
        val ShellTypes.LISTENER_ARGS
	      {user_options, user_preferences,
	       mk_xinterface_fn, prompter, ...} = args

        val (full_menus, update_fns) =
	  case user_preferences
	  of Preferences.USER_PREFERENCES ({full_menus,...}, update_fns) =>
	    (!full_menus, update_fns)

        val title =
          let
            val n = !browser_number
          in
            browser_number := n+1;
            "File Tool #" ^ Integer.makestring n
        end

	val local_context = ref motif_context

        val ToolData.APPLICATIONDATA {applicationShell,...} = appdata

        val name = "compilationTool"

        (*** Make the windows ***)
        val (shell,form,menuBar,contextLabel) =
          Capi.make_main_window (name,title,applicationShell,full_menus)

	fun set_context_label c =
	  case contextLabel
	  of MLWorks.Option.SOME w =>
            let
              val context_name = MotifUtils.get_context_name c

              val string = "Context: " ^ context_name
            in
              Capi.set_label_string (w, string)
	    end
	  |  MLWorks.Option.NONE => ()

	val _ = set_context_label (!local_context)
	  
	fun set_context c =
	  (set_context_label c;
	   local_context := c)

	fun get_user_options () = user_options

        val context_key =
	  ToolData.add_context_fn
            (current_context,
	     (set_context, get_user_options, ToolData.WRITABLE))

	val quit_funs = ref [];

	fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

	val _ =
	  quit_funs :=
	    (fn _ => ToolData.remove_context_fn (current_context, context_key))
	    :: !quit_funs

        fun select_context c =
          (set_context c;
	   ToolData.set_current
	     (current_context, context_key, user_options, c))

        val (box,{get_file,get_directory,set_directory,set_mask,...}) =
          Capi.make_file_selection_box ("selectionBox",form,[])

        val pathLabel = Capi.make_managed_widget ("pathLabel",Capi.Label,form,[])

	fun disable_commands _ = ()
	fun enable_commands _ = ()

	fun number_entries ([], _) = []
	|   number_entries (h::t, n) = (h, n) :: number_entries (t, n + 1)
	  
	val entries = ref (number_entries (Io.get_source_path (), 1))

	val current_pos = ref (if !entries = [] then 0 else 1)

	val current_entry_selected = ref true;

	fun print_entry print_options (s, _) = s;

	fun select_fn _ (_, n) =
	  if !current_pos <> n then
	    (current_pos := n;
	     current_entry_selected := false)
	  else
	    ()

	fun action_fn _ (s, _) =
          (set_directory s;
	   current_entry_selected := true;
	   enable_commands ())

	val (scroll, list, set_items) =
	  Capi.make_scrolllist 
	    {parent = form, name = "sourcePath", select_fn = select_fn,
	     action_fn = action_fn, print_fn = print_entry}

	val _ =
	  let val init_dir =
		    case !entries
		    of [] => MLWorks.OS.Unix.getwd()
		    |  ((dir, _) :: _) => dir
	  in
	    set_items ShellUtils.Options.default_print_options (!entries);
	    if !current_pos <> 0 then
	      Capi.List.select_pos (list, 1, false)
	    else ();
            set_mask (init_dir ^ "/*.sml")
	  end

	fun renumber_up (s, n) = (s, n + 1)

	fun renumber_down (s, n) = (s, n - 1)

	fun is_in (n:string, []) = false
	|   is_in (n, (n', _)::t) = n = n' orelse is_in (n, t)
	infix is_in

	fun add_nth ([], s, n) = [(s, n)] 
	|   add_nth (l as h::t, s, n) =
	  if n = #2 h then
	    (s, n) :: map renumber_up l
	  else
	    h :: add_nth (t, s, n) 

	fun remove_nth ([], _) = []
	|   remove_nth (h::t, n) =
	  if n = #2 h then
	    map renumber_down t
	  else
	    h :: remove_nth (t, n)

        fun crash s =
	  Info.error' Info.default_options (Info.FAULT,Location.UNKNOWN,s)

        fun get_directory_path () =
          Path.dir (get_directory ())

	fun delete_from_source_path _ =
	  let val new_entries =
		remove_nth (!entries, !current_pos)
	      val new_source_path = map #1 new_entries
	  in
	    if !current_entry_selected then
	      disable_commands()
	    else ();
	    entries := new_entries;
	    Io.set_source_path new_source_path;
	    current_entry_selected := false;
	    set_items ShellUtils.Options.default_print_options new_entries;
	    if !current_pos > Lists.length new_entries then
	      current_pos := Lists.length new_entries
	    else ();
	    if !current_pos <> 0 then
	      Capi.List.select_pos (list, !current_pos, false)
	    else ()
	  end

	fun insert_into_source_path _ =
	  let val dir = get_directory_path ()
	  in
	    if dir = "" orelse dir is_in !entries then
	      ()
	    else let
	      val new_entries =
		add_nth
		  (!entries, dir, if !current_pos = 0 then 1 else !current_pos)
	      val new_source_path = map #1 new_entries
	    in
	      current_pos := !current_pos + 1;
	      entries := new_entries;
	      Io.set_source_path new_source_path;
	      set_items ShellUtils.Options.default_print_options new_entries;
	      Capi.List.select_pos (list, !current_pos, false)
	    end
	  end

	fun append_into_source_path _ =
	  let val dir = get_directory_path ()
	  in
	    if dir = "" orelse dir is_in !entries then
	      ()
	    else let
	      val new_entries =
		add_nth (!entries, dir, !current_pos + 1)
	      val new_source_path = map #1 new_entries
	    in
	      if !current_pos = 0 then current_pos := 1 else ();
	      Io.set_source_path new_source_path;
	      entries := new_entries;
	      set_items ShellUtils.Options.default_print_options new_entries;
	      Capi.List.select_pos (list, !current_pos, false)
	    end
	  end

	fun cd_to_source_path _ =
	  (set_directory (#1 (Lists.nth (!current_pos - 1, !entries)));
	   current_entry_selected := true;
	   enable_commands ())

        val {instream, outstream, console_widget, console_visible,
             show_console, clear_input} =
          Console.create (shell, title, user_preferences)

        fun message_fun s = Capi.send_message(shell,s)

        (* This creates the debugger window when the inspector is being created *)
        (* Strange things happen if done at debugger entry time *)
        val debugger_type = 
          Ml_Debugger.WINDOWING
	    (DebuggerWindow.make_debugger_window (shell, "debugger", tooldata),
	     message_fun,
	     false)

        fun debugger_function f x =
          Ml_Debugger.with_start_frame
            (fn base_frame =>
               (f x)
               handle
		 exn as Capi.SubLoopTerminated => raise exn
               | exn as ShellTypes.DebuggerTrapped => raise exn
               | exn as Interrupt => raise exn
               | exn as Info.Stop _ => raise exn
               | exn =>
                  (Ml_Debugger.ml_debugger
                     (debugger_type,
                      ShellTypes.new_options
			(user_options,
			 MotifUtils.get_user_context (!local_context)),
                      Preferences.new_preferences user_preferences)
                     (base_frame,
                      Ml_Debugger.EXCEPTION exn,
                      Ml_Debugger.POSSIBLE
                        ("quit (return to file tool)",
                         Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
                      Ml_Debugger.NOT_POSSIBLE);
                   raise ShellTypes.DebuggerTrapped))

	fun is_file_name s =
	  MLWorks.String.ordof (s, size s - 1) <> ord "/"
		
        fun mk_action f filename =
	  if is_file_name filename then
	    (clear_input ();
             MLWorks.IO.with_standard_input
               instream
	       (fn () =>
                MLWorks.IO.with_standard_output
                  outstream
                  (fn () =>
                     (Ml_Debugger.with_debugger_type
                        debugger_type
                        (fn _ => f filename))))
	     handle
               Interrupt => ())
	  else
	    message_fun "Normal file not selected"

        val edit_file =
          mk_action
          (fn s =>
           (case Editor.edit
		   (Preferences.new_preferences user_preferences)
		   (s,0)
	    of (MLWorks.Option.NONE,_) => ()
            |  (MLWorks.Option.SOME s,_) => message_fun s))

        fun error_handler
	      (filename, error, error_list, header,
	       preferences_fn, redo_action) =
          let
            val action_message =
              header ^ ": " ^ filename

            val file_message =
              case location_file error of
                MLWorks.Option.NONE => ""
              | MLWorks.Option.SOME s => 
                  "Error in: " ^ s

	    fun edit_action location =
	       ShellUtils.edit_source (location, preferences_fn())
          in
            (output(std_out,header ^ ": " ^ file_message ^ "\n");
	     ErrorBrowser.create
               {parent = applicationShell, errors = rev error_list,
		action_message = action_message, file_message = file_message,
                edit_action = edit_action, redo_action = redo_action})
          end

        val compile_file =
	  let fun f s =
            let val options =
		  ShellTypes.new_options
		    (get_user_options(),
		     MotifUtils.get_user_context (!local_context))
                val str = "Compiling " ^ s
            in
              (output(std_out,str ^ "\n");
               Capi.with_message 
                 (shell,str)
                 (fn () => 
                    Recompile.recompile_files
		      (Info.make_default_options()) options [s]);
               message_fun ("Compilation of " ^ s ^ " finished"))
              handle Info.Stop (error,error_list) =>
                error_handler 
                (s,
                 error,
                 error_list,
                 "Compile",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f s)
            end
	  in
            mk_action f
	  end

	val check_compile_file =
	  let
	    fun f s =
	      let
		val user_context_options =
		  UserContext.get_user_options
		    (MotifUtils.get_user_context (!local_context))

	        val UserOptions.USER_CONTEXT_OPTIONS ({no_execute,...},_) =
		  user_context_options

	        val _ = no_execute := true;

	        val options =
		  UserOptions.new_options (user_options, user_context_options)

                val str = "Checking dependencies for " ^ s
              in
                (output(std_out,str ^ "\n");
                 (Capi.with_message 
                  (shell,str)
                  (fn () => 
                   Recompile.recompile_files
                   (Info.make_default_options()) options [s]))
                 handle exn => (no_execute := false;raise exn);
                 message_fun ("All dependencies of " ^ s ^ " checked");
	         no_execute := false)
                handle Info.Stop (error,error_list) =>
	          (* I'm not sure that this can actually happen *)
                  error_handler 
                  (s,
                   error,
                   error_list,
                   "Check Compile",
                   fn () => Preferences.new_preferences user_preferences,
                   fn () => mk_action f s)
              end
	  in
	    mk_action f
	  end

        val touch_compile_file =
	  let
            fun f s =
	      (MLWorks.IO.set_file_modified (s, MLWorks.IO.NOW);
               Capi.send_message (shell, "Touched " ^ s))
	      handle Io _ =>
		message_fun ("Can't touch " ^ s)
	  in
            mk_action f
	  end

        val make_file =
	  let
            fun f s =
              let
                val error_info = Info.make_default_options()
              in
                Capi.with_message (shell,"Making " ^ s)
                  (fn () =>
                     (ActionQueue.add_make_file (s,error_info);
                      ActionQueue.do_actions
			(MotifUtils.get_user_context (!local_context),
			 user_options, debugger_function,
			 fn s => output(std_out, s),
                         fn s => output(std_out,"Make: compiling " ^ s))));
                message_fun ("Make of " ^ s ^ " finished")
              end
              handle
                ActionQueue.Error (_,error,error_list) =>
                  error_handler
                  (s,
                   error,
                   error_list,
                   "Make",
                   fn () => Preferences.new_preferences user_preferences,
                   fn () => mk_action f s)
              | ActionQueue.Handled => ()
	  in
            mk_action f
	  end

        val check_make_file =
	  let
            fun f s =
              let
                val error_info = Info.make_default_options()
              in
                Capi.with_message (shell,"Making " ^ s)
                  (fn () =>
                     (ActionQueue.add_check_file (s,error_info);
                      ActionQueue.do_actions
			(MotifUtils.get_user_context (!local_context),
			 user_options, debugger_function,
			 fn s => output(std_out, s),
                         fn s => output(std_out,"Make: compiling " ^ s))));
                message_fun ("Check Make Dependencies of " ^ s ^ " finished")
              end
              handle
                ActionQueue.Error (_,error,error_list) =>
                  error_handler
                  (s,
                   error,
                   error_list,
                   "Check Make",
                   fn () => Preferences.new_preferences user_preferences,
                   fn () => mk_action f s)
              | ActionQueue.Handled => ()
	  in
            mk_action f
	  end

        val touch_make_file =
	  let
            fun f s =
              let
                val error_info = Info.make_default_options()
              in
                ActionQueue.add_touch_file (s,error_info);
                ActionQueue.do_actions
		  (MotifUtils.get_user_context (!local_context),
		   user_options, debugger_function,
		   fn s => output(std_out, s),
                   fn s => output(std_out, "Make: touching " ^ s))
              end
              handle
                ActionQueue.Error (_,error,error_list) =>
                  error_handler
		    (s, error, error_list, "Touch Make",
                     fn () => Preferences.new_preferences user_preferences,
                     fn () => mk_action f s)
              | ActionQueue.Handled => ()
	  in
            mk_action f
	  end

        val load_file =
	  let
            fun f s =
              let
                val error_info = Info.make_default_options()
              in
                Capi.with_message (shell,"Loading " ^ s)
                  (fn () =>
                     (ActionQueue.add_load_file (s,error_info);
                      ActionQueue.do_actions
			(MotifUtils.get_user_context (!local_context),
			 user_options, debugger_function,
			 fn s => output(std_out, s),
                         fn s => output(std_out,"Loading: " ^ s))));
                message_fun ("Make of " ^ s ^ " finished")
              end
              handle
                ActionQueue.Error (_,error,error_list) =>
                  error_handler
                  (s,
                   error,
                   error_list,
                   "Load",
                   fn () => Preferences.new_preferences user_preferences,
                   fn () => mk_action f s)
              | ActionQueue.Handled => ()
	  in
            mk_action f
	  end

(* This version attempts to do something sensible with warnings *)
(*  
        val use_file =
	  let
            fun f filename =
              let
                fun do_error (error,error_list) =
                  error_handler
                  (filename,
                  error,
                  error_list,
                   "Use",
                   fn () => Preferences.new_preferences user_preferences,
                   fn () => mk_action f s)
                val error_info = Info.make_default_options ()
              in
                (case 
                  Info.with_error_list
                  (Capi.with_message (shell,"Using " ^ filename))
                  (fn () =>
                     (ActionQueue.add_use (filename,error_info);
                      ActionQueue.do_actions
			(MotifUtils.get_user_context (!local_context),
			 user_options, debugger_function,
			 fn s => output(std_out, s),
                         fn s => output(std_out,"Use: compiling " ^ s))))
                  of
                    (_,[]) => message_fun ("Use of " ^ filename ^ " finished")
                  | (_,error_list as (error::_)) => do_error (error,error_list))
                 handle
                 ActionQueue.Error (_,error,error_list) => do_error (error,error_list)
              end
            handle ActionQueue.Handled => ()
	  in
            mk_action f
	  end
*)
        val use_file =
	  let
            fun f s =
              let
                fun do_error (error,error_list) =
                  error_handler
                  (s,
                   error,
                   error_list,
                   "Use",
                   fn () => Preferences.new_preferences user_preferences,
                   fn () => mk_action f s)
                val error_info = Info.make_default_options ()
              in
                (Capi.with_message 
                 (shell,"Using " ^ s)
                 (fn () =>
                  (ActionQueue.add_use (s,error_info);
                   ActionQueue.do_actions
                   (MotifUtils.get_user_context (!local_context),
		    user_options, debugger_function,
		    fn s => output(std_out, s),
                    fn s => output(std_out, "Use: compiling " ^ s))));
                 message_fun ("Use of " ^ s ^ " finished"))
                handle
                ActionQueue.Error (_,error,error_list) =>
		  do_error (error,error_list)
              end
            handle ActionQueue.Handled => ()
	  in
            mk_action f
	  end

        val history = ref []
          
        datatype action =
	  EDIT | MAKE | CHECK_MAKE | TOUCH_MAKE | USE | COMPILE |
	  CHECK_COMPILE | TOUCH_COMPILE | LOAD

        fun get_action EDIT = edit_file
          | get_action MAKE = make_file
          | get_action CHECK_MAKE = check_make_file
          | get_action TOUCH_MAKE = touch_make_file
          | get_action LOAD = load_file
          | get_action USE = use_file
          | get_action COMPILE = compile_file
          | get_action TOUCH_COMPILE = touch_compile_file
          | get_action CHECK_COMPILE = check_compile_file

        (* There is no need to go through an options structure for this. *)
        fun get_max_history () =
          let
            val Preferences.USER_PREFERENCES ({history_length,...},_) =
	      user_preferences
          in
            !history_length
          end
          

        fun ministry_of_truth ([], _, _) = []
          | ministry_of_truth (s::l, new_factoid, finish) =
            if finish > 0
              then
                if s = new_factoid then
                  l
                else
                  s :: ministry_of_truth (l, new_factoid, finish - 1)
            else []

        fun add_action a =
          history := a :: (ministry_of_truth (!history,a,get_max_history()))

        fun do_action (action,filename) =
          (add_action (action,filename);
           (get_action action) filename)

        fun make_callback action _ =
          let val filename = get_file ()
          in
            do_action(action,filename)
          end

        fun string_action action =
          case action of
            EDIT => "Edit"
          | MAKE => "Make"
          | CHECK_MAKE => "Make.Check"
          | TOUCH_MAKE => "Make.Touch"
          | LOAD => "Load"
          | USE => "Use"
          | COMPILE => "Compile"
          | TOUCH_COMPILE => "Compile.Touch"
          | CHECK_COMPILE => "Compile.Check"

        fun get_history_menu () =
          map
          (fn (action,filename) =>
           Menus.PUSH (string_action action ^ " " ^ filename,
                       fn _ => do_action(action,filename),
                       fn _ => true))
          (!history)

	fun mk_tooldata () =
          ToolData.TOOLDATA
            {args = ShellTypes.LISTENER_ARGS
                      {user_options = user_options,
		       user_preferences = user_preferences,
                       user_context =
			 MotifUtils.get_user_context (!local_context),
                       prompter = prompter,
                       mk_xinterface_fn = mk_xinterface_fn},
             appdata = appdata,
	     motif_context = !local_context,
	     current_context = current_context,
             tools = tools}

	fun close_window _ =
	  (do_quit_funs ();
	   Capi.destroy shell)

        val view_options =
          MotifUtils.view_options
            {parent = shell, title = title, user_options = user_options,
	     user_preferences = user_preferences,
             caller_update_fn = fn _ => (),
	     sensitivity = MotifUtils.NO_SENSE_SELECTION,
	     view_type = MotifUtils.VIEW_ALL}

        val view_menu =
          Menus.CASCADE
            ("view",
             view_options
             @@ [Menus.TOGGLE
                  ("console", console_visible, show_console, fn () => true)],
             fn _ => true)

        val menuspec =
          [ToolData.works_menu
	     (mk_tooldata, close_window, fn () => true,
	      fn () => MotifUtils.get_user_context (!local_context)),
 	   view_menu,
	   Menus.CASCADE ("sourcepath",
			  let
			    fun on_source_path () =
 			      let val dir = get_directory_path ()
          		      in dir = "" orelse dir is_in !entries
          		      end
 			  in
			    [Menus.PUSH ("moveto",
				         cd_to_source_path,
				         fn _ => !current_pos <> 0),
                             Menus.PUSH ("insert",
				         insert_into_source_path,
				         fn _ => not (on_source_path ())),
                             Menus.PUSH ("append",
				         append_into_source_path,
				         fn _ => not (on_source_path ())),
                             Menus.PUSH ("delete",
				         delete_from_source_path,
				         fn _ => !current_pos <> 0)]
			  end,
                          fn _ => true),
           Menus.CASCADE
	     ("action",
              let
		val make_buttons =
                  [Menus.PUSH ("make",
                               make_callback MAKE,
                               fn _ => is_file_name (get_file ())),
                   Menus.PUSH ("check",
                               make_callback CHECK_MAKE,
                               fn _ => is_file_name (get_file ())),
                   Menus.PUSH ("touch",
                               make_callback TOUCH_MAKE,
                               fn _ => is_file_name (get_file ()))]
              in
		(if full_menus then
                  [Menus.CASCADE
		     ("makefull",
		      make_buttons,
                      fn _ => is_file_name (get_file ())),
                   Menus.CASCADE
		     ("compile",
                      [Menus.PUSH ("compile",
                                   make_callback COMPILE,
                                   fn _ => is_file_name (get_file ())),
                       Menus.PUSH ("check",
                                   make_callback CHECK_COMPILE,
                                   fn _ => is_file_name (get_file ())),
                       Menus.PUSH ("touch",
                                   make_callback TOUCH_COMPILE,
                                   fn _ => is_file_name (get_file ()))],
                      fn _ => is_file_name (get_file ()))]
		else
		  make_buttons)
		@@ [Menus.PUSH ("load",
                               make_callback LOAD,
                               fn _ => is_file_name (get_file ())),
                   Menus.PUSH ("edit",
                               make_callback EDIT,
                               fn _ => is_file_name (get_file ())),
                   Menus.PUSH ("use",
                               make_callback USE,
                               fn _ => is_file_name (get_file ()))]
	      end,
              fn _ => true),
           MotifUtils.context_menu
	     {set_state = select_context,
	      get_context = fn _ => !local_context,
	      writable = MotifUtils.WRITABLE,
	      applicationShell = applicationShell,
	      user_preferences = user_preferences},
	   Menus.DYNAMIC ("history", get_history_menu, fn _ => true)]

	val sep_size = 10
      in
          Menus.make_submenus (menuBar,menuspec);
          Capi.Layout.lay_out
          ([Capi.Layout.MENUBAR menuBar] @@
           (case contextLabel of 
              MLWorks.Option.SOME w => [Capi.Layout.OTHER w]
            | _ => [Capi.Layout.SPACE]) @@
           [Capi.Layout.OTHER pathLabel,
            Capi.Layout.OTHER scroll,
	    Capi.Layout.PANED box,
            Capi.Layout.SPACE]);
          Capi.Callback.add (shell, Capi.Callback.Destroy,do_quit_funs);
          Capi.manage shell;
          Capi.realize shell;
          Capi.realize console_widget
      end

  end;
@


1.92
log
@Minor changes to layout.
@
text
@d4 3
d386 1
a386 3
  sharing Recompile.Info = ShellUtils.Info =
          Ml_Debugger.Incremental.InterMake.Compiler.Info =
	  ActionQueue.Info
d397 1
a397 2
  sharing type Ml_Debugger.Incremental.Context =
	       ToolData.ShellTypes.Context = ShellUtils.Context
@


1.91
log
@Capification
@
text
@d4 3
d1223 1
a1223 1
            | _ => []) @@
d1226 1
a1226 1
	    Capi.Layout.OTHER box,
@


1.90
log
@Replaced input and output windows with a single console window.
@
text
@d4 3
d348 1
a348 1
require "../library/xm";
d366 1
a366 1
  structure Xm : XM
d395 1
a395 1
  sharing type Xm.Widget = Menus.Widget = ToolData.Widget =
d397 1
a397 1
	       ErrorBrowser.Widget = Console.Widget
d414 1
a414 1
    type Widget = Xm.Widget
d497 2
a498 24
        val shell =
          Xm.Widget.create (Xm.Widget.NAME name,
                            Xm.Widget.Class.TopLevelShell,
                            applicationShell,
                            [(Xm.Title, Xm.STRING title),
                             (Xm.IconName, Xm.STRING title)])

        val form =
          Xm.Widget.createManaged (Xm.Widget.NAME "main",
                                   Xm.Widget.Class.Form,
                                   shell, [])

        val menuBar =
          Xm.Widget.createManaged
	  (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, form, [])

        val contextLabel =
	  if full_menus then
	    MLWorks.Option.SOME
	      (Xm.Widget.createManaged
                 (Xm.Widget.NAME "contextLabel",
		  Xm.Widget.Class.Label,form, []))
	  else
	    MLWorks.Option.NONE
d506 1
a506 2
              val cstring = Xm.CompoundString.createSimple
			      ("Context: " ^ context_name)
d508 1
a508 2
              Xm.Widget.valuesSet
	        (w, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
d539 4
a542 22
        val box = Xm.Widget.createManaged
          (Xm.Widget.NAME "selectionBox",
           Xm.Widget.Class.FileSelectionBox,
           form, [])

	(* The seperators created by the Xm.OFFSET specifications cast a
	   shadow (even set to no_line), which looks odd when it only
	   stretches partway down a window.  So I've added zero-width
	   seperators the rest of the way so that there's a shadow all
	   the way down. *)

        val leftDummySep = Xm.Widget.createManaged
			     (Xm.Widget.NAME "leftDummySep",
                              Xm.Widget.Class.SeparatorGadget, form, [])

        val rightDummySep = Xm.Widget.createManaged
			      (Xm.Widget.NAME "rightDummySep",
                               Xm.Widget.Class.SeparatorGadget, form, [])

        val pathLabel = Xm.Widget.createManaged
 			  (Xm.Widget.NAME "pathLabel",
                           Xm.Widget.Class.LabelGadget, form, [])
d566 1
a566 5
	  (Xm.Widget.valuesSet
	     (box,
	      [(Xm.Directory,
		Xm.COMPOUNDSTRING
		  (Xm.CompoundString.createSimple s))]);
d571 1
a571 1
	  MotifUtils.make_scrolllist 
d581 1
a581 1
	    set_items MotifUtils.Options.default_print_options (!entries);
d583 1
a583 1
	      Xm.List.selectPos (list, 1, false)
d585 1
a585 5
	    Xm.Widget.valuesSet
	      (box,
               [(Xm.DirMask,
                 Xm.COMPOUNDSTRING
 	           (Xm.CompoundString.createSimple (init_dir ^ "/*.sml")))])
d613 2
a614 17
        val filter_text =
          Xm.Widget.fileSelectionBoxGetChild(box, Xm.Widget.Child.FILTER_TEXT)

        (* This pulls the selected filename out of the file selection box *)
        fun get_file () =
          (case Xm.Widget.valuesGet(box,[Xm.DirSpec]) of
             [Xm.COMPOUNDSTRING filename] =>
               Xm.CompoundString.convert_string_text filename
           | _ => crash "Bad values for valuesGet (get_file)")

        fun get_dir_mask () =
          (case Xm.Widget.valuesGet(box,[Xm.DirMask]) of
             [Xm.COMPOUNDSTRING mask] => mask
           | _ => crash "Bad values for valuesGet (get_dir_mask)")

        fun get_directory () =
	    Path.dir (Xm.Text.getString filter_text)
d627 1
a627 1
	    set_items MotifUtils.Options.default_print_options new_entries;
d632 1
a632 1
	      Xm.List.selectPos (list, !current_pos, false)
d637 1
a637 1
	  let val dir = get_directory ()
d650 2
a651 2
	      set_items MotifUtils.Options.default_print_options new_entries;
	      Xm.List.selectPos (list, !current_pos, false)
d656 1
a656 1
	  let val dir = get_directory ()
d668 2
a669 2
	      set_items MotifUtils.Options.default_print_options new_entries;
	      Xm.List.selectPos (list, !current_pos, false)
d674 1
a674 6
	  (Xm.Widget.valuesSet
	     (box,
	      [(Xm.Directory,
		Xm.COMPOUNDSTRING
		  (Xm.CompoundString.createSimple
		    (#1 (Lists.nth (!current_pos - 1, !entries)))))]);
a677 33
        val _ =
          map 
          (fn c =>
           Xm.Widget.unmanage (Xm.Widget.fileSelectionBoxGetChild(box,c)))
          [Xm.Widget.Child.CANCEL_BUTTON,
           Xm.Widget.Child.OK_BUTTON,
           Xm.Widget.Child.APPLY_BUTTON,
           Xm.Widget.Child.SEPARATOR,
           Xm.Widget.Child.HELP_BUTTON]

	(* Removing the OK and APPLY buttons does interesting things to
	   the behaviour of the file selection box.  Some thing stop
	   working, so here we recreate them by hand.  *)
	val dir_list =
	  Xm.Widget.fileSelectionBoxGetChild(box, Xm.Widget.Child.DIR_LIST)

	val _ =
	  Xm.Widget.callbackAdd
	    (dir_list,
	     Xm.Callback.DefaultAction,
	     fn x => 
	       let val item = #3 (Xm.Callback.convertList x)
	       in
		 Xm.Widget.valuesSet
		   (box, [(Xm.Directory, Xm.COMPOUNDSTRING item)])
	       end)

        val _ =
          Xm.Widget.callbackAdd
            (filter_text,
             Xm.Callback.Activate,
             fn _ => Xm.Widget.fileSelectionDoSearch (box, get_dir_mask ()))

d682 1
a682 1
        fun message_fun s = MotifUtils.send_message(shell,s)
d697 1
a697 1
		 exn as Xm.SubLoopTerminated => raise exn
d777 1
a777 1
               MotifUtils.with_message 
d815 1
a815 1
                 (MotifUtils.with_message 
d841 1
a841 1
               MotifUtils.send_message (shell, "Touched " ^ s))
d854 1
a854 1
                MotifUtils.with_message (shell,"Making " ^ s)
d884 1
a884 1
                MotifUtils.with_message (shell,"Making " ^ s)
d938 1
a938 1
                MotifUtils.with_message (shell,"Loading " ^ s)
d980 1
a980 1
                  (MotifUtils.with_message (shell,"Using " ^ filename))
d1013 1
a1013 1
                (MotifUtils.with_message 
d1117 1
a1117 1
	   Xm.Widget.destroy shell)
d1143 1
a1143 1
 			      let val dir = get_directory ()
d1216 13
a1228 71
          (* set the form resources *)
          Xm.Widget.valuesSet
	    (menuBar,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
	  case contextLabel
	  of MLWorks.Option.SOME w =>
            Xm.Widget.valuesSet
              (w,
               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                (Xm.TopWidget, Xm.WIDGET menuBar),
                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.LeftOffset, Xm.INT sep_size),
                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.RightOffset, Xm.INT sep_size),
                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)])
	  |  MLWorks.Option.NONE => ();
          Xm.Widget.valuesSet
	    (pathLabel,
	     [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
	      (Xm.TopWidget,
	       case contextLabel
	       of MLWorks.Option.SOME w => Xm.WIDGET w
	       |  MLWorks.Option.NONE => Xm.WIDGET menuBar),
	      (Xm.TopOffset,
	       case contextLabel
	       of MLWorks.Option.SOME w => Xm.INT 0
	       |  MLWorks.Option.NONE => Xm.INT sep_size),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.LeftOffset, Xm.INT sep_size),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.RightOffset, Xm.INT sep_size),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
          Xm.Widget.valuesSet
	    (scroll,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET pathLabel),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.LeftOffset, Xm.INT sep_size),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.RightOffset, Xm.INT sep_size),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
          Xm.Widget.valuesSet
	    (leftDummySep,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET scroll),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
          Xm.Widget.valuesSet
	    (rightDummySep,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET scroll),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
          Xm.Widget.valuesSet
	    (box,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET scroll),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.LeftWidget, Xm.WIDGET leftDummySep),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.RightWidget, Xm.WIDGET rightDummySep),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
	  Xm.Widget.callbackAdd (shell, Xm.Callback.Destroy,do_quit_funs);
          Xm.Widget.manage shell;
          Xm.Widget.realize shell;
          Xm.Widget.realize console_widget
@


1.89
log
@Hid details of WINDOWING type in ml_debugger.
@
text
@d4 3
d350 1
a350 2
require "output";
require "input";
d375 1
a375 2
  structure Output: OUTPUT_WINDOW
  structure Input: INPUT_WINDOW
d386 1
a386 1
	       ToolData.ShellTypes.user_preferences
d392 1
a392 1
  sharing type Xm.Widget = Menus.Widget = ToolData.Widget = Output.Widget =
d394 1
a394 1
	       ErrorBrowser.Widget = Input.Widget
d404 2
a405 3
  sharing type Output.preferences = Ml_Debugger.preferences =
	       ShellUtils.preferences = Editor.preferences =
	       Preferences.preferences
d778 3
a780 9
        val {instream, input_widget, input_visible,
             show_input, clear_input} =
          Input.create (shell, title, applicationShell)

        val {outstream, output_widget, output_visible, show_output} =
          Output.create
	    {parent = shell, title = title,
             get_preferences =
	       fn () => Preferences.new_preferences user_preferences}
d821 1
d832 1
a832 1
               Interrupt => ()
d1232 1
a1232 3
                  ("input", input_visible, show_input, fn () => true),
                Menus.TOGGLE
                  ("output", output_visible, show_output, fn () => true)],
d1386 1
a1386 2
          Xm.Widget.realize input_widget;
          Xm.Widget.realize output_widget
@


1.88
log
@Type of Ml_Debugger.ml_debugger has changed.
ShellUtils.edit_* functions no longer require a context argument.
@
text
@d4 4
a398 1
  sharing type Ml_Debugger.ValuePrinter.Type = DebuggerWindow.Type
d407 1
d793 4
a796 2
          Ml_Debugger.WINDOWING (DebuggerWindow.make_debugger_window
	       			   (shell, "debugger", tooldata), false)
d813 1
a813 2
                      Preferences.new_preferences user_preferences,
                      message_fun)
@


1.87
log
@Added an input tool.
@
text
@d4 3
d385 1
a385 1
  sharing type Ml_Debugger.Incremental.Context = Output.Context =
a484 4
        fun get_context () =
	  UserContext.get_context
	    (MotifUtils.get_user_context (!local_context))

a780 1
	     get_context = get_context,
d784 2
d794 11
a804 10
          (fn base_frame =>
           (f x)
           handle exn as Xm.SubLoopTerminated => raise exn
                | exn as ShellTypes.DebuggerTrapped => raise exn
                | exn as Interrupt => raise exn
                | exn as Info.Stop _ => raise exn
                | exn =>
                    (Ml_Debugger.ml_debugger
                     debugger_type
                     (ShellTypes.new_options
d808 3
a810 4
                      get_context ())
                     (fn _ => output(std_out,"Debugger shell not defined yet\n"))
                     base_frame
                     (Ml_Debugger.EXCEPTION exn,
d812 2
a813 2
                      ("quit (return to file tool)",
                       Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
d815 1
a815 3
                     raise ShellTypes.DebuggerTrapped))

        fun message_fun s = MotifUtils.send_message(shell,s)
d846 1
a846 1
	      (filename, error, error_list, header, context_fn,
d859 1
a859 1
	       ShellUtils.edit_source (location, context_fn(), preferences_fn())
a888 1
                 get_context,
a929 1
                   get_context,
a970 1
                   get_context,
a1000 1
                   get_context,
d1024 1
a1024 1
		    (s, error, error_list, "Touch Make", get_context,
a1054 1
                   get_context,
a1073 1
                   get_context,
a1108 1
                   get_context,
@


1.86
log
@ensure_output is now done by the output widget.
@
text
@d4 3
d341 1
d367 1
d385 2
a386 1
	       MotifUtils.Widget = DebuggerWindow.Widget = ErrorBrowser.Widget
d775 4
d824 9
a832 6
             MLWorks.IO.with_standard_output
               outstream
               (fn () =>
                  (Ml_Debugger.with_debugger_type
                     debugger_type
                     (fn _ => f filename)))
d1241 2
d1397 1
@


1.85
log
@Changed sensitivity argument of view_options to NO_SENSE_SELECTION,
because the shell functions now set the current selection.
@
text
@d4 4
a808 8
        fun ensure_output () =
          let
            val Preferences.USER_PREFERENCES ({auto_output_window,...},_) =
              user_preferences
          in
            if (!auto_output_window) then show_output true else ()
          end
              
d865 1
a865 2
              (ensure_output();
               output(std_out,str ^ "\n");
d867 4
a870 4
               (shell,str)
               (fn () => 
                  Recompile.recompile_files
		    (Info.make_default_options()) options [s]);
d904 1
a904 2
                (ensure_output();
                 output(std_out,str ^ "\n");
a944 1
                ensure_output();
a975 1
                ensure_output();
a1030 1
                ensure_output();
a1072 1
                ensure_output();
a1108 1
                ensure_output();
@


1.84
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d4 3
d1231 1
a1231 1
	     sensitivity = MotifUtils.CONTEXT_ONLY,
@


1.83
log
@Made contexts only visible if full_menus set.
@
text
@d4 3
d324 1
d348 1
d365 5
d375 3
a377 3
  sharing type UserOptions.user_options =
	       ToolData.ShellTypes.user_options = MotifUtils.UserOptions =
	       ShellUtils.UserOptions = ActionQueue.UserOptions
d384 4
a387 4
  sharing type UserOptions.preferences = Output.preferences =
	       Ml_Debugger.preferences = ShellUtils.preferences =
	       Editor.preferences
               
d448 1
a448 1
		  {args, appdata, current_context, tools}) =
d451 2
a452 1
	      {user_options, user_context, mk_xinterface_fn, prompter} = args
d455 2
a456 2
	  case user_options
	  of UserOptions.USER_OPTIONS({full_menus,...}, update_fns) =>
d467 1
a467 1
	val local_context = ref user_context
d469 3
a471 1
        fun get_context () = UserContext.get_context (!local_context)
d507 1
a507 1
              val context_name = UserContext.get_context_name c
d762 1
a762 1
        val {outstream,output_widget,output_visible,show_output,hide_output} =
d767 1
a767 1
	       fn () => UserOptions.new_preferences (get_user_options())}
d786 4
a789 2
                     (UserOptions.new_options user_options,
                      UserOptions.new_preferences user_options,
d804 2
a805 2
            val UserOptions.USER_OPTIONS({auto_output_window,...},_) =
              get_user_options()
d807 1
a807 1
            if (!auto_output_window) then show_output () else ()
d830 1
a830 1
		   (UserOptions.new_preferences (get_user_options()))
d860 4
a863 1
            let val options = UserOptions.new_options (get_user_options())
d881 1
a881 1
                 fn () => UserOptions.new_preferences (get_user_options()),
d891 14
a904 5
	      let val UserOptions.USER_OPTIONS({no_execute,...},_) =
		    get_user_options()
	          val _ = no_execute := true;
	          val options = UserOptions.new_options (get_user_options())
                  val str = "Checking dependencies for " ^ s
d924 1
a924 1
                   fn () => UserOptions.new_preferences (get_user_options()),
d953 2
a954 1
			(!local_context, user_options, debugger_function,
d967 1
a967 1
                   fn () => UserOptions.new_preferences (get_user_options()),
d985 2
a986 1
			(!local_context, user_options, debugger_function,
d999 1
a999 1
                   fn () => UserOptions.new_preferences (get_user_options()),
d1014 2
a1015 1
		  (!local_context, user_options, debugger_function,
d1021 4
a1024 7
                  error_handler (s,
                                 error,
                                 error_list,
                                 "Touch Make",
                                 get_context,
                                 fn () => UserOptions.new_preferences (get_user_options()),
                                 fn () => mk_action f s)
d1041 2
a1042 1
			(!local_context, user_options, debugger_function,
d1055 1
a1055 1
                   fn () => UserOptions.new_preferences (get_user_options()),
d1075 1
a1075 1
                   fn () => UserOptions.new_preferences (get_user_options()),
d1086 2
a1087 1
			(!local_context, user_options, debugger_function,
d1112 1
a1112 1
                   fn () => UserOptions.new_preferences (get_user_options()),
d1122 2
a1123 1
                   (!local_context, user_options, debugger_function,
d1155 2
a1156 2
            val UserOptions.USER_OPTIONS({history_length,...},_) =
	      get_user_options()
a1204 6
        val (options_menu,update) =
	  MotifUtils.options_menu
	    (shell, title, fn () => user_options, fn _ => ())

        val _ = update_fns := update :: (!update_fns)

d1209 3
a1211 1
                       user_context = !local_context,
d1215 1
d1223 15
a1237 3
	val menuTail =
	  [options_menu,
           Menus.DYNAMIC ("history", get_history_menu, fn _ => true)]
d1241 3
a1243 9
	     (mk_tooldata, close_window, fn () => true, fn () => !local_context),
           Menus.CASCADE ("output",
                          [Menus.PUSH ("show",
                                       show_output,
                                       fn _ => true), (* Can always bring to front *)
                           Menus.PUSH ("hide",
                                       hide_output,
                                       output_visible)],
                          fn _ => true),
d1308 8
a1315 7
              fn _ => true)] @@
	  (if full_menus then
             MotifUtils.context_menu
	       (select_context, fn _ => !local_context, MotifUtils.WRITABLE)
	     :: menuTail
	   else
	     menuTail)
@


1.82
log
@Removing Toplevel structure
@
text
@d4 3
d443 5
d482 7
a488 2
          Xm.Widget.createManaged
            (Xm.Widget.NAME "contextLabel", Xm.Widget.Class.Label,form, [])
d491 4
a494 2
          let
            val context_name = UserContext.get_context_name c
d496 7
a502 6
            val cstring = Xm.CompoundString.createSimple
			    ("Context: " ^ context_name)
          in
            Xm.Widget.valuesSet
	      (contextLabel, [(Xm.LabelString, Xm.COMPOUNDSTRING cstring)])
	  end
a1178 2
        val UserOptions.USER_OPTIONS({full_menus,...},update_fns) = user_options

d1196 4
d1246 1
a1246 1
		(if !full_menus then
d1275 7
a1281 7
              fn _ => true),
          MotifUtils.context_menu
	    (select_context, fn _ => !local_context, MotifUtils.WRITABLE),
	  options_menu,
          Menus.DYNAMIC ("history",
                         get_history_menu,
                         fn _ => true)]
d1283 2
a1284 2
	  val sep_size = 10
        in
d1293 12
a1304 10
          Xm.Widget.valuesSet
            (contextLabel,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET menuBar),
              (Xm.TopOffset, Xm.INT sep_size),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.LeftOffset, Xm.INT sep_size),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.RightOffset, Xm.INT sep_size),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
d1308 8
a1315 1
	      (Xm.TopWidget, Xm.WIDGET contextLabel),
@


1.81
log
@Removed script from ml_debugger
@
text
@d4 3
a314 1
require "../main/toplevel";
a339 1
  structure TopLevel : TOPLEVEL
d349 1
a349 1
  sharing TopLevel.Info = Recompile.Info = ShellUtils.Info =
d353 1
a353 1
 	  TopLevel.Options = ShellUtils.Options =
d369 1
a369 1
  sharing type ErrorBrowser.error = TopLevel.Info.error
d386 2
d392 10
a401 8
        fun first_line message =
          let
            fun aux ([],acc) = acc
              | aux ("\n" :: _,acc) = acc
              | aux (c::l,acc) = aux(l,c::acc)
          in
            implode (rev (aux (explode message,[])))
          end
d403 10
a412 10
        fun location_line location =
          case location of
            Location.UNKNOWN => ""
          | Location.FILE s => ""
          | Location.LINE(_,l) => "Line " ^ MLWorks.Integer.makestring l
          | Location.POSITION (_,l,_) => "Line " ^ MLWorks.Integer.makestring l
          | Location.EXTENT {s_line,e_line,...} =>
              if s_line = e_line
                then "Line " ^ MLWorks.Integer.makestring s_line
              else "Line " ^ MLWorks.Integer.makestring s_line ^ " to " ^ MLWorks.Integer.makestring e_line
d414 1
a414 1
        fun error_location (Info.ERROR(_,location,message)) = location
d416 15
a430 12
        fun location_file location =
          case location of
            Location.UNKNOWN => ""
          | Location.FILE f => f
          | Location.LINE(f,l) => f
          | Location.POSITION (f,l,_) => f
          | Location.EXTENT {name,...} => name

        fun error_to_string _ (Info.ERROR(severity,location,message)) =
          (case location_line location of
             "" => first_line message
           | l => l ^ ": " ^ first_line message)
a442 2
            fun p (s, 0) = s
              | p (s, n) = p (chr (48+(n mod 10)) ^ s, n div 10)
d445 1
a445 1
              "File Tool #" ^ p ("", n)
d812 4
a815 3
              case error_location error of
                Location.UNKNOWN => ""
              | loc => "Error in: " ^ location_file loc
@


1.80
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d4 3
d452 5
a456 5
          Xm.Widget.createPopupShell (Xm.Widget.NAME name,
                                      Xm.Widget.Class.TopLevelShell,
                                      applicationShell,
                                      [(Xm.Title, Xm.STRING title),
                                       (Xm.IconName, Xm.STRING title)])
d760 1
a760 1
                      Ml_Debugger.NOT_POSSIBLE) [];
@


1.79
log
@filesys and path moved from utils to initbasis.
@
text
@d3 302
a304 3
$Log: _fileselect.sml,v $
Revision 1.78  1995/04/19  10:58:43  daveb
Changes to context_menu.
a305 297
Revision 1.77  1995/03/17  12:28:00  daveb
Merged ShellTypes.get_context_name and ShellTypes.string_context_name.

Revision 1.76  1995/03/16  14:32:30  daveb
Removed context_function from register when closing the window.

Revision 1.75  1995/03/15  16:33:06  daveb
Changed to share current context with other tools..

Revision 1.74  1995/03/10  15:38:01  daveb
MotifUtils.options_menu now takes an extra argument.

Revision 1.73  1995/02/20  14:53:48  daveb
ActionQueue.do_actions now takes an output function argument.

Revision 1.72  1995/01/16  14:22:47  daveb
Replaced Option structure with references to MLWorks.Option.
Replaced FileName parameter with Path.
Removed obsolete sharing constraints.

Revision 1.71  1994/11/30  15:27:13  daveb
Fixed bug in form layout code for MIPS.  Also simplified this code
by replacing separator widgets with Xm.*Offset values.

Revision 1.70  1994/08/17  17:32:36  daveb
Removed unused Module and Crash arguments of functor.

Revision 1.69  1994/08/17  16:13:49  daveb
Ensured that paths are expanded before being added to source path.

Revision 1.68  1994/08/01  11:21:28  daveb
Moved preferences to a separate structure.

Revision 1.67  1994/07/27  16:20:32  daveb
Cut-down menus for novices.  Also reorganised the make and compile
menus into submenus of an action menu in the full_menus case.

Revision 1.66  1994/07/12  15:57:13  daveb
ToolData.works_menu takes different arguments.

Revision 1.65  1994/07/11  11:51:33  daveb
Replaced TextString with DirSpec.

Revision 1.64  1994/06/30  17:41:24  daveb
Added a comment about the buttons in the file selection box (old code).

Revision 1.63  1994/06/21  15:13:13  daveb
Moved output window code into separate file.
Types of ActionQueue.Error, ErrorBrowser.create and ActionQueue.do_actions
have changed.

Revision 1.62  1994/05/13  15:37:07  daveb
Moved error browser to separate file.

Revision 1.61  1994/03/30  17:39:58  daveb
Implemented touch_compile_{module,file}.

Revision 1.60  1994/03/28  15:40:16  daveb
Replaced Actions menu with Make and Compile menus.

Revision 1.59  1994/03/17  17:47:28  matthew
Added check make dependencies

Revision 1.58  1994/03/15  16:40:17  matthew
Changed printing of locations
Split title into two parts, one the file being made, the other the file in which the error occurred.
Fixed problem with redo action
Cleaned up error_handler function

Revision 1.57  1994/02/23  17:03:02  nosa
Debugger scripts for tracing tool using debugger.

Revision 1.56  1994/02/08  18:08:59  daveb
IO.get_source_path can no longer raise an exception.

Revision 1.55  1994/02/02  11:47:36  daveb
MOved check_search_path to Module, and stopped using it here anyway.

Revision 1.54  1994/01/26  18:09:54  matthew
Protect change to no_execute with handler

Revision 1.53  1993/12/22  10:59:43  daveb
Changed quit message for debugger, since it no longer raises Interrupt.

Revision 1.52  1993/12/20  12:48:43  matthew
Changed output and error browser to be toplevel shells
Started putting in warning browser stuff

Revision 1.51  1993/12/10  16:00:11  daveb
Added context menu, ensured that changes do the right thing, ensured that
new selection is passed on to child tools.

Revision 1.50  1993/12/09  19:34:38  jont
Added copyright message

Revision 1.49  1993/12/08  14:28:26  daveb
Changed class of Output window shell to DialogShell, so that the Motif close
button unmanges it rather than destroying it.  Explicitly managed its form
widget, 'cos otherwise it doesn't work.  Added Unmap callbacks to the
output window and the error browser.

Revision 1.48  1993/12/06  12:58:44  daveb
Changed "Recompile" command to "compile", losing the old "compile" command.
Changed remake to force_make in history, and also in internal datatype.

Revision 1.47  1993/11/26  12:13:23  matthew
Improvements to debugger calling.

Revision 1.46  1993/11/18  17:59:00  daveb
The argument to Ml_Debugger.with_debugger_type now takesa frame argument
instead of unit.

Revision 1.45  1993/11/04  19:02:20  daveb
Merged in bug fix.

Revision 1.44  1993/11/04  17:41:18  daveb
Merged in bug fix.

Revision 1.43  1993/11/02  16:33:50  daveb
Merged in bug fix.

Revision 1.42  1993/11/02  15:27:22  daveb
Merged in bug fix.

Revision 1.38.1.8  1993/11/04  18:55:20  daveb
Disabled menu items when they are inappropriate.  Also selected the
first entry in the error browser when it is mapped.

Revision 1.38.1.7  1993/11/04  17:29:50  daveb
Redo was invoking the action from the top of the history, but the history
can be extended in the meantime.  This version redoes the action that
caused the error.  The implementation is slightly simpler too.

Revision 1.38.1.6  1993/11/02  16:28:09  daveb
Fixed bug in delete_from_source_path.

Revision 1.38.1.5  1993/11/01  15:16:30  daveb
Added redo action to error browser.

Revision 1.38.1.4  1993/10/27  16:24:06  daveb
Merged bug fix into the bug fixing branch.

Revision 1.41  1993/10/27  12:52:21  daveb
Prevented duplicate or null entries in source path.
Allowed selected directory to be added to source path without having
to move into that directory.

Revision 1.40  1993/10/22  16:58:09  daveb
Merged in bug fix.

Revision 1.39  1993/10/08  16:30:04  matthew
Merging in bug fixes

Revision 1.38.1.3  1993/10/21  14:03:38  daveb
Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.

Revision 1.38.1.2  1993/10/07  16:36:54  matthew
Added destroy callback to do quit functions

Revision 1.38.1.1  1993/08/31  15:44:34  jont
Fork for bug fixing

Revision 1.38  1993/08/31  15:44:34  matthew
Added Context label widget

Revision 1.37  1993/08/29  20:33:52  daveb
Removed filter button.  Added source path pane.  Tidied up a bit.
Source path isn't properly integrated with compilation yet.

Revision 1.36  1993/08/28  17:06:27  daveb
Recompile.recompile and TopLevel.compile_file now take list arguments.

Revision 1.35  1993/08/27  16:36:11  matthew
Improved messages
Renamed message to message_fun.

Revision 1.34  1993/08/20  10:41:23  daveb
Improved layout of error browser.

Revision 1.33  1993/08/20  08:08:34  daveb
Added "Check dependencies" action.

Revision 1.32  1993/08/17  18:38:41  daveb
Make, remake, compile and recompile check whether the file is on the
search path.

Revision 1.31  1993/08/11  11:24:54  matthew
Changes to user options
Removed preferences menu
Options update

Revision 1.30  1993/08/10  14:46:06  nosa
tooldata passed to make_debugger_window for inspector invocation
in debugger-window.

Revision 1.29  1993/08/10  14:02:23  matthew
Changed name to File Tool
Get maximum history length from options
Auto popup of output windows

Revision 1.28  1993/08/03  16:47:56  matthew
Operation to bring output window to front
Added "Line" to error output

Revision 1.27  1993/07/29  16:08:45  matthew
Changed printing of Location.FILE in error browser
Added Interrupt handler to mk_action
Added call to MotifUtils.with_message, this actually uses a busy cursor
Changed Info.default_options to Info.make_default_options

Revision 1.26  1993/06/16  13:04:14  matthew
Added remake function

Revision 1.25  1993/06/04  15:21:24  daveb
edit functions now return a single string in the errorneous case.

Revision 1.24  1993/06/03  15:51:40  matthew
More informative messages

Revision 1.23  1993/05/28  16:17:54  matthew
Added tty_ok value to WINDOWINF

Revision 1.22  1993/05/27  10:13:15  matthew
Changed error handling for make, use etc.

Revision 1.21  1993/05/25  16:41:52  matthew
Added history and removed some of the buttons

Revision 1.20  1993/05/18  17:28:06  jont
Removed integer parameter

Revision 1.19  1993/05/13  14:22:30  daveb
All tools now set their own titles and pass them to their options menus.

Revision 1.18  1993/05/12  16:14:02  matthew
Added use.  Changed make.  Uses ShellUtils more.

Revision 1.17  1993/05/11  17:03:55  matthew
Added make command

Revision 1.16  1993/05/06  14:10:08  daveb
Changed to use MotifUtils.make_outstream

Revision 1.15  1993/05/05  12:10:51  daveb
Added tools argument to works_menu(),
removed exitApplication from TOOLDATA (works_menu now accesses it directly).

Revision 1.14  1993/05/04  15:47:43  matthew
Fixed bug with options used by error browser.

Revision 1.13  1993/05/04  12:26:50  matthew
Added facility to show and hide output widget.

Revision 1.12  1993/04/30  16:03:45  daveb
Reorganised menus.

Revision 1.11  1993/04/28  10:44:36  daveb
Now uses MotifUtils.scrolllist.

Revision 1.10  1993/04/27  14:43:28  daveb
Moved options menu code to _motif_utils.

Revision 1.9  1993/04/22  13:30:57  richard
The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.

Revision 1.8  1993/04/20  16:12:02  richard
Incorrect use of ordof().

Revision 1.7  1993/04/19  17:00:51  matthew
Added error selection dialog
Start of "Default action" stuff

Revision 1.6  1993/04/16  17:05:35  matthew
Changed to ToolData interface

Revision 1.5  1993/04/15  16:13:59  matthew
Added proper interface to editor
and an output window.  Much code duplicated from _listener.

Revision 1.4  1993/04/14  17:23:01  matthew
Much changed.  Added options and proper recompile etc. function.

Revision 1.3  1993/04/08  18:42:34  matthew
More hackery, still doesn't work
,

Revision 1.2  1993/04/05  14:50:21  daveb
Names of Callbacks have changed.

Revision 1.1  1993/04/01  17:18:05  matthew
Initial revision

*)

d359 2
a360 3
	       ToolData.ShellTypes.user_options =
	       MotifUtils.UserOptions = ShellUtils.UserOptions =
	       ActionQueue.UserOptions
d377 1
d441 1
a441 1
        fun get_context () = ShellTypes.get_context (!local_context)
d470 1
a470 1
            val context_name = ShellTypes.get_context_name c
@


1.78
log
@Changes to context_menu.
@
text
@d4 3
d305 1
a305 1
require "../utils/path";
@


1.77
log
@Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
@
text
@d4 3
d465 1
a465 1
            val context_name = ShellTypes.context_name c
a500 10
        fun copy_context _ =
          select_context (ShellTypes.copyUserContext (!local_context))

        fun initialContext _ =
          let
            val context = ShellTypes.getNewInitialContext()
          in
            select_context (context)
          end

d1243 2
a1244 7
          Menus.CASCADE
            ("context",
             [Menus.PUSH ("pushContext", copy_context, fn _ => true),
              Menus.PUSH ("initialContext", initialContext, fn _ => true),
              Menus.SEPARATOR,
              MotifUtils.context_menu (select_context, MotifUtils.WRITABLE)],
             fn _ => true),
@


1.76
log
@Removed context_function from register when closing the window.
@
text
@d4 3
d462 1
a462 3
            val context_name =
              ShellTypes.string_context_name
		(ShellTypes.get_context_name c)
d481 2
a482 1
            (current_context, (set_context, get_user_options))
d498 10
d1176 1
a1176 1
	     (mk_tooldata, close_window, fn () => true),
d1250 7
a1256 1
	  MotifUtils.context_menu select_context,
@


1.75
log
@Changed to share current context with other tools..
@
text
@d4 3
d482 9
d716 2
a717 1
	    {parent = shell, title = title, get_context = get_context,
a720 1

d1158 4
d1164 1
a1164 1
	     (mk_tooldata, fn () => Xm.Widget.destroy shell, fn () => true),
d1305 1
@


1.74
log
@MotifUtils.options_menu now takes an extra argument.
@
text
@d4 3
d409 2
a410 1
    fun create (tooldata as ToolData.TOOLDATA {args, appdata, tools}) =
d425 1
a425 1
	val current_context = ref user_context
d427 1
a427 1
        fun get_context () = ShellTypes.get_context (!current_context)
d467 1
a467 1
	val _ = set_context_label (!current_context)
d471 3
a473 1
	   current_context := c)
d475 9
a701 2
	fun get_user_options () = user_options

d878 1
a878 1
			(!current_context, user_options, debugger_function,
d909 1
a909 1
			(!current_context, user_options, debugger_function,
d937 1
a937 1
		  (!current_context, user_options, debugger_function,
d966 1
a966 1
			(!current_context, user_options, debugger_function,
d1010 1
a1010 1
			(!current_context, user_options, debugger_function,
d1045 1
a1045 1
                   (!current_context, user_options, debugger_function,
d1139 1
a1139 1
                       user_context = !current_context,
d1143 1
d1222 1
a1222 1
	  MotifUtils.context_menu set_context,
@


1.73
log
@ActionQueue.do_actions now takes an output function argument.
@
text
@d4 3
d1115 2
a1116 1
	  MotifUtils.options_menu (shell, title, fn () => user_options)
@


1.72
log
@Replaced Option structure with references to MLWorks.Option.
Replaced FileName parameter with Path.
Removed obsolete sharing constraints.
@
text
@d4 5
d863 1
d894 1
d922 1
d951 1
d995 1
d1030 1
@


1.71
log
@Fixed bug in form layout code for MIPS.  Also simplified this code
by replacing separator widgets with Xm.*Offset values.
@
text
@d4 4
d282 1
a282 1
require "../utils/filename";
d317 1
a317 1
  structure FileName: FILENAME
a326 1
  sharing Ml_Debugger.Incremental.InterMake.Option = DebuggerWindow.Option
a338 1
  sharing type Io.Directory = string
a353 1
    structure Option = Editor.Option
d577 1
a577 14
	  let
	    val path = Xm.Text.getString filter_text

	    fun find_slash 0 = 0
	    |   find_slash i = 
	      if String.ordof (path, i - 1) = ord "/" then
		i
	      else
		find_slash (i - 1)

	    val index = find_slash (size path)
	  in
	    FileName.expand_path (String.substring (path, 0, index))
	  end
d727 3
d731 11
a741 9
          (FileName.parse_absolute filename;
           MLWorks.IO.with_standard_output
           outstream
           (fn () =>
            (Ml_Debugger.with_debugger_type
             debugger_type
             (fn _ => f filename))))
          handle FileName.Parse _ => message_fun "Normal file not selected"
               | Interrupt => ()
d749 2
a750 2
	    of (Option.ABSENT,_) => ()
            |  (Option.PRESENT s,_) => message_fun s))
a1151 4
		fun is_file_name s =
          	  (FileName.parse_absolute s; true)
          	   handle FileName.Parse _ => false
		
@


1.70
log
@Removed unused Module and Crash arguments of functor.
@
text
@d4 3
d465 5
a469 16
        val topSep = Xm.Widget.createManaged
		       (Xm.Widget.NAME "topSep",
                        Xm.Widget.Class.SeparatorGadget, form, [])

        val leftSep = Xm.Widget.createManaged
			(Xm.Widget.NAME "leftSep",
                         Xm.Widget.Class.SeparatorGadget, form, [])

        val rightSep = Xm.Widget.createManaged
			 (Xm.Widget.NAME "rightSep",
                          Xm.Widget.Class.SeparatorGadget, form, [])

	(* The seperators cast a shadow (even set to no_line), which looks
	   odd when it only stretches partway down a window.  So I've added
	   zero-width seperators the rest of the way so that there's a
	   shadow all the way down. *)
d1209 2
d1221 1
a1221 17
	    (leftSep,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET menuBar),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
	      (Xm.BottomWidget, Xm.WIDGET scroll)]);
          Xm.Widget.valuesSet
	    (rightSep,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET menuBar),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
	      (Xm.BottomWidget, Xm.WIDGET scroll)]);
          Xm.Widget.valuesSet
	    (topSep,
d1224 1
d1226 1
d1228 1
a1230 10
            (contextLabel,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET topSep),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.LeftWidget, Xm.WIDGET leftSep),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.RightWidget, Xm.WIDGET rightSep),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)
              ]);
          Xm.Widget.valuesSet
d1234 4
a1237 4
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.LeftWidget, Xm.WIDGET leftSep),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.RightWidget, Xm.WIDGET rightSep),
d1243 4
a1246 4
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.LeftWidget, Xm.WIDGET leftSep),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.RightWidget, Xm.WIDGET rightSep),
d1251 1
a1251 1
              (Xm.TopWidget, Xm.WIDGET leftSep),
d1258 1
a1258 1
              (Xm.TopWidget, Xm.WIDGET rightSep),
@


1.69
log
@Ensured that paths are expanded before being added to source path.
@
text
@d4 3
a274 1
require "../utils/crash";
a275 1
require "../basics/module";
a309 1
  structure Module: MODULE
a310 1
  structure Crash: CRASH
@


1.68
log
@Moved preferences to a separate structure.
@
text
@d4 3
d597 1
a597 1
	    String.substring (path, 0, index)
@


1.67
log
@Cut-down menus for novices.  Also reorganised the make and compile
menus into submenus of an action menu in the full_menus case.
@
text
@d4 4
d315 1
a315 1
 	  TopLevel.Options = Editor.Options = ShellUtils.Options =
a328 1
  sharing type UserOptions.Options.options = Output.options
d336 3
d702 2
a703 1
             get_options = fn () => UserOptions.new_options(get_user_options())}
d723 2
a724 1
                     (UserOptions.new_options(user_options),
d759 9
a767 5
           (case Editor.edit (UserOptions.new_options (get_user_options())) (s,0) of
              (Option.ABSENT,_) => ()
            | (Option.PRESENT s,_) => message_fun s))

        fun error_handler (filename,error,error_list,header, context_fn, options_fn,redo_action) =
d778 1
a778 1
	       ShellUtils.edit_source (location, context_fn(), options_fn())
d807 1
a807 1
                 fn () => UserOptions.new_options (get_user_options()),
d841 1
a841 1
                   fn () => UserOptions.new_options (get_user_options()),
d882 1
a882 1
                   fn () => UserOptions.new_options (get_user_options()),
d912 1
a912 1
                   fn () => UserOptions.new_options (get_user_options()),
d937 1
a937 1
                                 fn () => UserOptions.new_options (get_user_options()),
d967 1
a967 1
                   fn () => UserOptions.new_options (get_user_options()),
d987 1
a987 1
                   fn () => UserOptions.new_options (get_user_options()),
d1022 1
a1022 1
                   fn () => UserOptions.new_options (get_user_options()),
@


1.66
log
@ToolData.works_menu takes different arguments.
@
text
@d4 3
d1104 1
a1104 1
        val UserOptions.USER_OPTIONS(_,update_fns) = user_options
d1150 48
a1197 46
           Menus.CASCADE ("make",
                         let
			   fun normal_file s =
          		     (FileName.parse_absolute s; true)
          		     handle FileName.Parse _ => false
                         in
                           [Menus.PUSH ("make",
                                        make_callback MAKE,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("check",
                                        make_callback CHECK_MAKE,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("touch",
                                        make_callback TOUCH_MAKE,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("load",
                                        make_callback LOAD,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("edit",
                                        make_callback EDIT,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("use",
                                        make_callback USE,
                                        fn _ => normal_file (get_file ()))]
		         end,
                         fn _ => true),
           Menus.CASCADE ("compile",
                         let
			   fun normal_file s =
          		     (FileName.parse_absolute s; true)
          		     handle FileName.Parse _ => false
                         in
                           [Menus.PUSH ("compile",
                                        make_callback COMPILE,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("check",
                                        make_callback CHECK_COMPILE,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("touch",
                                        make_callback TOUCH_COMPILE,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("edit",
                                        make_callback EDIT,
                                        fn _ => normal_file (get_file ()))]
		         end,
                         fn _ => true),
@


1.65
log
@Replaced TextString with DirSpec.
@
text
@d4 3
d1116 2
a1117 1
          [ToolData.works_menu (shell, tools, mk_tooldata, fn () => true),
@


1.64
log
@Added a comment about the buttons in the file selection box (old code).
@
text
@d4 3
d559 1
a559 1
          (case Xm.Widget.valuesGet(box,[Xm.TextString]) of
@


1.63
log
@Moved output window code into separate file.
Types of ActionQueue.Error, ErrorBrowser.create and ActionQueue.do_actions
have changed.
@
text
@d4 5
d659 3
@


1.62
log
@Moved error browser to separate file.
@
text
@d4 3
d264 1
d291 1
d302 3
a304 4
  sharing type Ml_Debugger.Incremental.Context =
	       ToolData.ShellTypes.Context = ShellUtils.Context =
	       ErrorBrowser.Context = ActionQueue.Context
  sharing type Xm.Widget = Menus.Widget = ToolData.Widget =
d311 1
a311 1
  sharing type UserOptions.Options.options = ErrorBrowser.options
d315 2
a316 1
  sharing type MotifUtils.ContextRef = ToolData.ShellTypes.ContextRef
d318 1
a334 138
    fun make_text_output (parent,title,get_context,get_options) =
      let
        val shell =
          Xm.Widget.createPopupShell (Xm.Widget.NAME "textOutputShell",
                                      Xm.Widget.Class.TopLevelShell,
                                      parent,
                                      [(Xm.Title, Xm.STRING (title ^ " Output")),
                                       (Xm.IconName, Xm.STRING (title ^ " Output"))])

        val mainWindow =
          Xm.Widget.createManaged (Xm.Widget.NAME "main",
                                   Xm.Widget.Class.Form,
                                   shell, [])

        val menuBar =
          Xm.Widget.createManaged
	  (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, mainWindow,
	   [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)
            ])

        val text =
          Xm.Widget.createScrolledText
          (mainWindow, Xm.Widget.NAME "textIO",
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)
            ])

        val write_pos = ref 0

        fun insert_text str =
          ( Xm.Text.insert(text, !write_pos, str);
           write_pos := size str + !write_pos;
           Xm.Text.setInsertionPosition (text, !write_pos)
           )

	val outstream = MotifUtils.make_outstream insert_text

        fun getline (str, pos, length) =
	let fun lastline ~1 = 0
	    |   lastline n = if String.ordof (str, n) = ord "\n" then
			  n+1
			else
			  lastline (n-1)

	    fun nextline n =
	      if n = length orelse String.ordof (str, n) = ord "\n" then
		n
	      else
		nextline (n+1)

	    val start = lastline (pos-1)
	    val finish = nextline (pos)
	    val all = String.substring (str, start, finish - start)
	in
          all
	end

        exception NoLocation
        fun get_location line =
          let
            val sz = size line
            fun aux index =
              if index < sz
                then
                  if String.ordof(line,index) = ord ":"
                    then index+1
                  else
                    aux (index+1)
              else
                raise NoLocation
            (* skip up to second ":" *)
            val result = String.substring(line,0,(aux (aux 0))-1)
          in
            result
          end

        val quit_funs = ref []

        fun do_quit_funs _ =
	  (Lists.iterate (fn f => f ()) (!quit_funs);
	   quit_funs := [])

        fun edit_error _ =
          (let
            val str = Xm.Text.getString text
	    val pos = Xm.Text.getInsertionPosition text
	    val length = size str
            val line = getline (str, pos, length)
            val locstring = get_location line
            val quit_fun = ShellUtils.edit_string (locstring,get_context(),get_options())

          in
            quit_funs := quit_fun :: (!quit_funs)
          end 
          handle  ShellUtils.EditFailed s => MotifUtils.send_message (shell,s)
               | NoLocation => (output(std_out,"No location info found\n"))
               | Location.InvalidLocation => (output(std_out,"No location info found\n")))

        val output_visible_ref = ref false
        
        fun output_visible _ = !output_visible_ref

        fun hide_output _ = (output_visible_ref := false;
                             do_quit_funs();
                             Xm.Widget.unmap shell)

        fun show_output _ = (output_visible_ref := true;
                             Xm.Widget.map shell;
                             Xm.Widget.toFront shell)

        val menuspec =
          [Menus.CASCADE ("window",
                          [Menus.PUSH ("close",
                                       hide_output,
                                       fn _ => true)],
                          fn _ => true),
          Menus.CASCADE ("error",
                         [Menus.PUSH ("edit",
                                      edit_error,
                                      fn _ => true)],
                         fn _ => true)]
      in
        Menus.make_submenus (menuBar,menuspec);
        Xm.Widget.callbackAdd (text, Xm.Callback.Activate, edit_error);
        Xm.Widget.callbackAdd (mainWindow, Xm.Callback.Unmap,
			       fn _ => (output_visible_ref := false;
			       		do_quit_funs ()));
        Xm.Widget.callbackAdd (shell, Xm.Callback.Destroy,do_quit_funs);
        Xm.Widget.manage text;
        (outstream,shell,output_visible,show_output,hide_output)
      end
          
d375 1
a375 1
	      {user_options, context_ref, mk_xinterface_fn, prompter} = args
d387 1
a387 4
	val current_context = ref context_ref

        (* This may be confusing *)
	fun get_context_ref () = ShellTypes.get_context_ref (!current_context)
d389 1
a389 1
        fun get_context () = !(get_context_ref ())
d676 4
a679 5
        val (outstream,text_output_widget,output_visible,show_output,hide_output) =
          make_text_output (shell,
			    title,
                            get_context,
                            fn () => UserOptions.new_options(get_user_options()))
d700 1
a700 1
                      get_context_ref ())
d742 1
d747 3
d753 3
a755 2
               (applicationShell,rev error_list, action_message, file_message,
                context_fn, options_fn, redo_action))
d841 1
a841 1
			(get_context_ref (), user_options, debugger_function,
d846 1
a846 1
                ActionQueue.Error (_,context,error,error_list) =>
d871 1
a871 1
			(get_context_ref (), user_options, debugger_function,
d876 1
a876 1
                ActionQueue.Error (_,context,error,error_list) =>
d898 1
a898 1
		  (get_context_ref (), user_options, debugger_function,
d902 1
a902 1
                ActionQueue.Error (_,context,error,error_list) =>
d926 1
a926 1
			(get_context_ref (), user_options, debugger_function,
d931 1
a931 1
                ActionQueue.Error (_,context,error,error_list) =>
d969 1
a969 1
			(get_context_ref(), user_options, debugger_function,
d975 1
a975 1
                 ActionQueue.Error (_,context,error,error_list) => do_error (error,error_list)
d1003 1
a1003 1
                   (get_context_ref(), user_options, debugger_function,
d1007 1
a1007 1
                ActionQueue.Error (_,context,error,error_list) =>
d1095 1
a1095 1
                       context_ref = !current_context,
d1268 1
a1268 1
          Xm.Widget.realize text_output_widget
@


1.61
log
@Implemented touch_compile_{module,file}.
@
text
@d4 3
d264 1
d271 1
d298 2
a299 1
	       ToolData.ShellTypes.Context = ShellUtils.Context
d301 1
a301 1
	       MotifUtils.Widget = DebuggerWindow.Widget
d307 1
a307 1
  sharing type ActionQueue.Context = ToolData.ShellTypes.Context
d312 1
a501 139
        fun make_error_dialog (parent, error_list, action_message, file_message,
                               context_fn, options_fn, redo_action) =
          let 
            val shell = Xm.Widget.createPopupShell (Xm.Widget.NAME "errorBrowserShell",
                                                    Xm.Widget.Class.TopLevelShell,
                                                    parent, [])
            val form = Xm.Widget.createManaged (Xm.Widget.NAME "errorBrowserForm",
                                                Xm.Widget.Class.Form,
                                                shell,[])

            val menuBar = Xm.Widget.createManaged (Xm.Widget.NAME "menuBar",
                                                   Xm.Widget.Class.RowColumn,
                                                   form,[])

            val title = Xm.Widget.createManaged (Xm.Widget.NAME "errorBrowserTitle",
                                                Xm.Widget.Class.Text,form,[])

            val title2 = Xm.Widget.createManaged (Xm.Widget.NAME "errorBrowserTitle",
                                                Xm.Widget.Class.Text,form,[])

            val frame = Xm.Widget.createManaged (Xm.Widget.NAME "errorBrowserFrame",
                                                 Xm.Widget.Class.PanedWindow,
                                                 form,[])

            val separator = Xm.Widget.createManaged (Xm.Widget.NAME "errorBrowserSeparator",
                                                     Xm.Widget.Class.Separator,
                                                     form,[])

            val text = Xm.Widget.createScrolledText(frame,Xm.Widget.NAME "errorBrowserText",[])

            fun message_fun s = MotifUtils.send_message (shell,s)
            val quit_funs = ref []

            fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

            fun edit_error _ (Info.ERROR(_,location,_)) =
              let
                val quit_fun = ShellUtils.edit_source (location,context_fn(),options_fn())
              in
                quit_funs := quit_fun :: (!quit_funs)
              end
            handle ShellUtils.EditFailed s =>
              message_fun ("Edit failed: " ^ s)

            fun show_full_message _ (Info.ERROR(_,_,message)) =
              Xm.Text.setString(text,message)

            val (scroll,list,set_items) =
	      MotifUtils.make_scrolllist
		{parent = frame, name = "errorBrowser",
		 select_fn = show_full_message,
                 action_fn = edit_error,
                 print_fn = error_to_string}

            fun edit_fun _ =
              let
                val selected_items = Xm.List.getSelectedPos list
              in
                case Vector.length selected_items of
                  0 => message_fun "No item selected"
                | 1 =>
                    let val index = Vector.sub(selected_items,0)
                    in
                      edit_error (scroll,list,set_items) 
				 (Lists.nth (index-1,error_list))
                    end
                | _ => message_fun "Multiple selections"
              end

	    fun quit_fun _ =
              (* Widget should be reused *)
              (* Though we would like to have more than one at once *)
	      (do_quit_funs();
	       Xm.Widget.destroy shell);

	    fun redo_fun _ =
	      (quit_fun ();
	       redo_action ())

            val menuspec =
	      Menus.CASCADE ("action",
              		     [Menus.PUSH ("close",
                           		  quit_fun,
                           		  fn _ => true),
               		      Menus.PUSH ("redo",
                           		   redo_fun,
                           		   fn _ => true),
               		      Menus.PUSH ("edit",
                           		   edit_fun,
                           		   fn _ => true)],
			      fn _ => true)
          in
            Xm.Widget.valuesSet
 	      (menuBar,
               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
            Xm.Widget.valuesSet
 	      (title,
               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                (Xm.TopWidget, Xm.WIDGET menuBar),
                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
            Xm.Widget.valuesSet
 	      (title2,
               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                (Xm.TopWidget, Xm.WIDGET title),
                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
            Xm.Widget.valuesSet
	      (separator,
               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                (Xm.TopWidget, Xm.WIDGET title2),
                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
            Xm.Widget.valuesSet
	      (frame,
               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                (Xm.TopWidget, Xm.WIDGET separator),
                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
            Menus.make_submenus(menuBar,[menuspec]);
            (* Note the destroy method is added to the parent of the popup shell *)
            Xm.Widget.callbackAdd (form, Xm.Callback.Unmap, do_quit_funs);
            Xm.Widget.callbackAdd (Xm.Widget.parent shell, Xm.Callback.Destroy,do_quit_funs);
            set_items MotifUtils.Options.default_print_options error_list;
            Xm.Widget.manage text;
            Xm.Text.setString (title, action_message);
            Xm.Text.setString (title2,file_message);
            Xm.Widget.manage shell;
            Xm.Widget.realize shell;
	    Xm.List.selectPos (list, 1, false)
          end

d884 3
a886 3
             make_error_dialog
             (applicationShell,rev error_list, action_message, file_message,
              context_fn, options_fn, redo_action))
@


1.60
log
@Replaced Actions menu with Make and Compile menus.
@
text
@d4 3
d1085 4
a1088 7
              let
                val error_info = Info.make_default_options()
              in
                ensure_output();
                MotifUtils.send_message
		  (shell, "touch_compile_file not implemented ")
              end
@


1.59
log
@Added check make dependencies
@
text
@d4 3
d1028 1
a1028 1
                  Recompile.recompile
d1036 1
a1036 1
                 "Recompilation",
d1045 1
a1045 1
	val check_dependencies =
d1059 1
a1059 1
                   Recompile.recompile
d1070 1
a1070 1
                   "Check Compile Dependencies",
d1079 14
d1102 1
a1102 1
                     (ActionQueue.add_make (s,error_info);
d1132 1
a1132 1
                     (ActionQueue.add_check_make (s,error_info);
d1144 1
a1144 1
                   "Check Make Dependencies",
d1153 1
a1153 1
        val remake_file =
d1159 4
a1162 8
                ensure_output();
                MotifUtils.with_message (shell,"Remaking " ^ s)
                (fn () =>
                   (ActionQueue.add_remake (s,error_info);
                    ActionQueue.do_actions
		      (get_context_ref (), user_options, debugger_function,
                       fn s => output(std_out,"Make: compiling " ^ s))));
                message_fun ("Remake of " ^ s ^ " finished")
d1169 1
a1169 1
                                 "Remake",
d1178 30
d1270 2
a1271 1
                ActionQueue.Error (_,context,error,error_list) => do_error (error,error_list)
d1281 2
a1282 1
	  EDIT | MAKE | CHECK_MAKE | FORCE_MAKE | USE | COMPILE | DEPENDENCIES
d1287 2
a1288 1
          | get_action FORCE_MAKE = remake_file
d1291 2
a1292 1
          | get_action DEPENDENCIES = check_dependencies
d1294 1
a1294 1
        (* There is no need to go throught an options structure for this. *)
d1297 2
a1298 1
            val UserOptions.USER_OPTIONS({history_length,...},_) = get_user_options()
d1331 3
a1333 2
          | CHECK_MAKE => "Check Make dependencies"
          | FORCE_MAKE => "Force make"
d1336 2
a1337 1
          | DEPENDENCIES => "Check Compile dependencies"
d1395 1
a1395 1
           Menus.CASCADE ("file",
d1401 1
a1401 4
                           [Menus.PUSH ("edit",
                                        make_callback EDIT,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("make",
d1404 1
a1404 1
                            Menus.PUSH ("make_dependencies",
d1407 8
a1414 2
                            Menus.PUSH ("remake",
                                        make_callback FORCE_MAKE,
d1418 11
d1430 2
a1431 2
                            Menus.PUSH ("compile_dependencies",
                                        make_callback DEPENDENCIES,
d1433 5
a1437 2
                            Menus.PUSH ("compile",
                                        make_callback COMPILE,
@


1.58
log
@Changed printing of locations
Split title into two parts, one the file being made, the other the file in which the error occurred.
Fixed problem with redo action
Cleaned up error_handler function
@
text
@d4 6
d1067 1
a1067 1
                   "Check Dependencies",
d1106 30
d1237 1
a1237 1
	  EDIT | MAKE | FORCE_MAKE | USE | COMPILE | DEPENDENCIES
d1241 1
d1283 1
d1287 1
a1287 1
          | DEPENDENCIES => "Check dependencies"
d1357 3
d1366 1
a1366 1
                            Menus.PUSH ("dependencies",
@


1.57
log
@Debugger scripts for tracing tool using debugger.
@
text
@d4 3
d459 2
a460 2
            Location.UNKNOWN => "Unknown Location"
          | Location.FILE s => "_"
d468 2
d472 1
a472 1
            Location.UNKNOWN => "Unknown file"
a477 3
        fun error_file (Info.ERROR(_,location,message)) =
          location_file location

d479 3
a481 2
          (* location_file location ^ " " ^ *) 
          location_line location ^ ":" ^ first_line message
d483 2
a484 3
        fun make_error_dialog
	      (parent, filename, error_list, message,
	       context_fn, options_fn, redo_action) =
d500 3
d560 1
a560 1
	       redo_action filename)
d589 7
d598 1
a598 1
                (Xm.TopWidget, Xm.WIDGET title),
d615 2
a616 1
            Xm.Text.setString (title,message);
d932 1
a932 1
          make_text_output (applicationShell,
d994 14
a1007 7
        fun error_handler
	      (filename,error_list, message, context_fn, options_fn,
	       redo_action) =
          (output(std_out,message ^ "\n");
           make_error_dialog
           (applicationShell, filename,rev error_list, message,
            context_fn, options_fn, redo_action))
d1023 8
a1030 9
                let val filename = error_file error
                in
                  error_handler 
		    (filename, error_list,
                     "Recompilation of " ^ filename,
                     get_context,
                     fn () => UserOptions.new_options (get_user_options()),
		     mk_action f)
                end
d1057 8
a1064 9
                  let val filename = error_file error
                  in
                    error_handler 
		      (filename, error_list,
                       "Error while checking dependencies of " ^ filename,
                       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
d1087 8
a1094 9
                  let val filename = error_file error
                  in
                    error_handler
		      (filename, error_list,
		       "Make of " ^ filename,
                       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
d1117 4
a1120 2
                  error_handler (s, error_list,
                                 "Remake of " ^ s,
d1123 1
a1123 1
                                 mk_action f)
d1137 4
a1140 2
                  (filename, error_list,
                   "Use of " ^ filename,
d1143 1
a1143 1
                   mk_action f)
d1168 1
a1168 1
            fun f filename =
d1172 4
a1175 2
                  (filename, error_list,
                   "Use of " ^ filename,
d1178 1
a1178 1
                   mk_action f)
d1183 1
a1183 1
                 (shell,"Using " ^ filename)
d1185 1
a1185 1
                  (ActionQueue.add_use (filename,error_info);
d1188 2
a1189 2
                    fn s => output(std_out,"Use: compiling " ^ s))));
                 message_fun ("Use of " ^ filename ^ " finished"))
@


1.56
log
@IO.get_source_path can no longer raise an exception.
@
text
@d4 3
d950 1
a950 1
                      Ml_Debugger.NOT_POSSIBLE);
@


1.55
log
@MOved check_search_path to Module, and stopped using it here anyway.
@
text
@d4 3
d714 1
a714 3
	val entries =
	      ref (number_entries
		     (Io.get_source_path () handle Io.NotSet _ => [], 1))
a1285 7
			  
			   (*
			   fun on_search_path s =
			     normal_file s andalso
			     (Module.check_search_path s; true)
			     handle Module.NotOnSearchPath => false
			   *)
@


1.54
log
@Protect change to no_execute with handler
@
text
@d4 3
d225 2
d258 2
d263 2
a264 1
    Ml_Debugger.Incremental.InterMake.Compiler.Info
d269 1
a269 2
  sharing ActionQueue.Incremental = Ml_Debugger.Incremental
  sharing Ml_Debugger.Incremental.InterMake.FileName.Option = DebuggerWindow.Option
a295 1
    structure Filename = Ml_Debugger.Incremental.InterMake.FileName
d960 1
a960 1
          (Filename.parse_absolute filename;
d967 1
a967 1
          handle Filename.Parse _ => message_fun "Normal file not selected"
a976 39
	fun prefix (s, s') =
	  let val len = size s
	  in
	    size s' > len andalso s = MLWorks.String.substring (s', 0, len)
	  end

        exception NotOnSearchPath

	fun check_search_path s =
	  let val path = Io.get_source_path ()
			 handle Io.NotSet _ => []

	      fun module_name n =
		if MLWorks.String.substring (s, n, 1) = "/" then
		  module_name (n + 1)
		else
		  let val n' =
		    if size s > 4 andalso
		       MLWorks.String.substring (s, size s - 4, 4) = ".sml" then
		      size s - 4
		    else
		      size s
		  in
		    implode
		      (map
		        (fn "/" => "." | x => x)
		        (explode (MLWorks.String.substring (s, n, n' - n))))
		  end

	      fun check [] = raise NotOnSearchPath
	      |   check (h::t) =
		if prefix (h, s) then
		  module_name (size h)
		else 
		  check t
	  in 
	    check path
	  end

d986 1
a986 1
	  let fun f filename =
a987 1
	        val s = check_search_path filename
a1008 2
	    handle NotOnSearchPath =>
	      message_fun (filename ^ " not on search path")
d1015 2
a1016 3
	    fun f filename =
	      let val s = check_search_path filename
                  val UserOptions.USER_OPTIONS({no_execute,...},_) =
a1043 2
	      handle NotOnSearchPath =>
	        message_fun (filename ^ " not on search path")
d1050 1
a1050 1
            fun f filename =
a1052 1
	        val s = check_search_path filename
d1064 1
a1064 3
	        NotOnSearchPath =>
	          message_fun (filename ^ " not on search path")
              | ActionQueue.Error (_,context,error,error_list) =>
d1069 1
a1069 1
                       "Make of " ^ filename,
d1081 1
a1081 1
            fun f filename =
a1083 1
	        val s = check_search_path filename
d1095 3
a1097 5
	        NotOnSearchPath =>
	          message_fun (filename ^ " not on search path")
              | ActionQueue.Error (_,context,error,error_list) =>
                  error_handler (filename, error_list,
                                 "Remake of " ^ filename,
d1283 2
a1284 2
          		     (Filename.parse_absolute s; true)
          		     handle Filename.Parse _ => false
d1286 1
d1289 3
a1291 2
			     (check_search_path s; true)
			     handle NotOnSearchPath => false
d1298 1
a1298 1
                                        fn _ => on_search_path (get_file ())),
d1301 1
a1301 1
                                        fn _ => on_search_path (get_file ())),
d1307 1
a1307 1
                                        fn _ => on_search_path (get_file ())),
d1310 1
a1310 1
                                        fn _ => on_search_path (get_file ()))]
@


1.53
log
@Changed quit message for debugger, since it no longer raises Interrupt.
@
text
@d4 3
d1061 6
a1066 5
                 MotifUtils.with_message 
                   (shell,str)
                   (fn () => 
                      Recompile.recompile
		        (Info.make_default_options()) options [s]);
a1072 1
		    no_execute := false;
@


1.52
log
@Changed output and error browser to be toplevel shells
Started putting in warning browser stuff
@
text
@d4 4
d915 2
a916 1
          Ml_Debugger.WINDOWING (DebuggerWindow.make_debugger_window(shell,"debugger",tooldata),true)
d935 1
a935 1
                      ("Raise Interrupt",
@


1.51
log
@Added context menu, ensured that changes do the right thing, ensured that
new selection is passed on to child tools.
@
text
@d4 4
d291 2
a292 2
          Xm.Widget.createPopupShell (Xm.Widget.NAME "shell",
                                      Xm.Widget.Class.DialogShell,
d298 1
a298 1
          Xm.Widget.create (Xm.Widget.NAME "main",
d396 7
a402 9
        fun unmanage_output _ = (output_visible_ref := false;
                                 do_quit_funs();
                                 Xm.Widget.unmanage shell;
				 Xm.Widget.unmanage mainWindow)

        fun manage_output _ = (output_visible_ref := true;
			       Xm.Widget.manage mainWindow;
                               Xm.Widget.manage shell;
                               Xm.Widget.toFront shell)
d407 1
a407 1
                                       unmanage_output,
d423 1
a423 1
        (outstream,shell,output_visible,manage_output,unmanage_output)
a453 1

d458 1
a460 1

d462 1
a462 1
	      (parent, filename, error, error_list, message,
d466 1
a466 1
                                                    Xm.Widget.Class.DialogShell,
d468 3
a470 3
            val form = Xm.Widget.create (Xm.Widget.NAME "errorBrowserForm",
                                         Xm.Widget.Class.Form,
                                         shell,[])
d529 2
a530 1
              (* Widget should be destroyed *)
d532 1
a532 1
	       Xm.Widget.unmanage form);
d585 2
a586 1
            Xm.Widget.manage form;
d901 2
a902 2
        val (outstream,text_output_widget,output_visible,manage_output,unmanage_output) =
          make_text_output (shell,
d942 1
a942 1
            if (!auto_output_window) then manage_output () else ()
d1003 1
a1003 1
	      (filename, error, error_list, message, context_fn, options_fn,
d1007 2
a1008 2
	     (shell, filename, error, rev error_list, message,
	      context_fn, options_fn, redo_action))
d1028 2
a1029 2
		    (filename, error, error_list,
                     "Error during recompilation of " ^ filename,
d1066 1
a1066 1
		      (filename, error, error_list,
d1102 2
a1103 2
		      (filename, error, error_list,
                       "Error during make of " ^ filename,
d1133 5
a1137 9
                  let val filename = error_file error
                  in
                    error_handler
		      (filename, error, error_list,
                       "Error during make of " ^ filename,
                       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
d1143 2
d1149 7
d1159 3
a1161 1
                MotifUtils.with_message (shell,"Using " ^ filename)
d1165 37
a1201 3
			(get_context_ref (), user_options, debugger_function,
                         fn s => output(std_out,"Make: compiling " ^ s))));
                message_fun ("Use of " ^ filename ^ " finished")
d1203 1
a1203 13
              handle
                ActionQueue.Error (_,context,error,error_list) =>
                  let val filename = error_file error
                  in
                    error_handler
		      (filename, error, error_list,
		       "Error during use of " ^ filename,
		       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
            | ActionQueue.Handled => ()
            | exn => raise exn
d1290 2
a1291 2
                                       manage_output,
                                       fn _ => true (* not(output_visible ()) *)),
d1293 1
a1293 1
                                       unmanage_output,
@


1.50
log
@Added copyright message
@
text
@d4 3
d266 1
d589 1
a589 1
    fun create (tooldata as ToolData.TOOLDATA {args,appdata,tools,...}) =
d591 2
a592 3
        val ShellTypes.LISTENER_ARGS {user_options,
                                      context_ref,
                                      ...} = args
d604 1
a604 1
        fun get_context () = !(ShellTypes.get_context_ref context_ref)
d607 3
a609 2
        val real_context_ref = context_ref
        val context_ref = ShellTypes.get_context_ref context_ref
d633 4
d639 5
a643 2
                ShellTypes.string_context_name(ShellTypes.get_context_name real_context_ref)
              val cstring = Xm.CompoundString.createSimple("Context: " ^ context_name)
d645 9
a653 5
            Xm.Widget.createManaged
            (Xm.Widget.NAME "contextLabel", Xm.Widget.Class.Label,form,
             [(Xm.LabelString, 
               Xm.COMPOUNDSTRING cstring)])
          end
d922 1
a922 1
                      context_ref)
d1088 1
a1088 1
			(context_ref, user_options, debugger_function,
d1122 1
a1122 1
		      (context_ref, user_options, debugger_function,
d1155 1
a1155 1
			(context_ref, user_options, debugger_function,
d1239 1
d1241 1
d1243 11
d1255 1
a1255 1
          [ToolData.works_menu (shell, tools, fn _ => tooldata, fn () => true),
d1316 1
@


1.49
log
@Changed class of Output window shell to DialogShell, so that the Motif close
button unmanges it rather than destroying it.  Explicitly managed its form
widget, 'cos otherwise it doesn't work.  Added Unmap callbacks to the
output window and the error browser.
@
text
@d2 1
d4 6
@


1.48
log
@Changed "Recompile" command to "compile", losing the old "compile" command.
Changed remake to force_make in history, and also in internal datatype.
@
text
@d3 4
d277 1
a277 1
                                      Xm.Widget.Class.TopLevelShell,
d283 1
a283 1
          Xm.Widget.createManaged (Xm.Widget.NAME "main",
d357 3
a359 1
        fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)
d383 2
a384 1
                                 Xm.Widget.unmanage shell)
d387 1
d405 3
d567 1
@


1.47
log
@Improvements to debugger calling.
@
text
@d3 3
d973 1
a973 1
        val recompile_file =
d977 1
a977 1
                val str = "Recompiling " ^ s
d986 1
a986 1
               message_fun ("Recompilation of " ^ s ^ " finished"))
a1041 33
        val compile_file = 
	  let
	    fun f filename =
              let 
                val options = UserOptions.new_options (get_user_options())
	        val s = check_search_path filename
                val str = "Compiling " ^ s
              in
                (ensure_output();
                 output(std_out,str ^ "\n");
                 MotifUtils.with_message 
                 (shell,str)
                 (fn () =>
                    TopLevel.compile_file
		      (Info.make_default_options()) options [s]);
                 message_fun ("Compilation of " ^ s ^ " finished"))
                handle Info.Stop (error,error_list) => 
                  let val filename = error_file error
                  in
                    error_handler
		      (filename, error, error_list,
                       "Error during compilation of " ^ filename,
                       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
              end
	      handle NotOnSearchPath =>
	        message_fun (filename ^ " not on search path")
	  in
            mk_action f
	  end
          
d1145 1
a1145 1
	  EDIT | MAKE | REMAKE | USE | COMPILE | RECOMPILE | DEPENDENCIES
d1149 1
a1149 1
          | get_action REMAKE = remake_file
a1151 1
          | get_action RECOMPILE = recompile_file
d1190 1
a1190 1
          | REMAKE => "Remake"
a1192 1
          | RECOMPILE => "Recompile"
d1256 1
a1256 1
                                      make_callback REMAKE,
a1262 3
                                        fn _ => on_search_path (get_file ())),
                            Menus.PUSH ("recompile",
                                        make_callback RECOMPILE,
@


1.46
log
@The argument to Ml_Debugger.with_debugger_type now takesa frame argument
instead of unit.
@
text
@d3 4
d868 2
a869 2
        exception Trapped

d871 1
a871 2
          Ml_Debugger.WINDOWING (DebuggerWindow.make_debugger_window(shell,
                                                                     "debugger",tooldata),true)
d874 1
a874 1
          MLWorks.Internal.Value.frame_call
d877 17
a893 13
           handle exn =>
             (Ml_Debugger.ml_debugger
              debugger_type
              (UserOptions.new_options(user_options),
               context_ref)
              (fn _ => output(std_out,"Debugger shell not defined yet\n"))
              base_frame
              (Ml_Debugger.EXCEPTION exn,
               Ml_Debugger.POSSIBLE
               ("Raise Interrupt",
                Ml_Debugger.DO_RAISE Trapped),
               Ml_Debugger.NOT_POSSIBLE);
              raise Div))
d1167 1
@


1.45
log
@Merged in bug fix.
@
text
@d3 3
d905 1
a905 1
             (fn () => f filename))))
@


1.44
log
@Merged in bug fix.
@
text
@d3 3
d12 4
d550 2
a551 1
            Xm.Widget.manage form
d916 1
a916 1
	    size s' >= len andalso s = MLWorks.String.substring (s', 0, len)
d1239 19
a1257 12
			 [Menus.PUSH ("moveto",
				      cd_to_source_path,
				      fn _ => !current_pos <> 0),
                          Menus.PUSH ("insert",
				      insert_into_source_path,
				      fn _ => true),
                          Menus.PUSH ("append",
				      append_into_source_path,
				      fn _ => true),
                          Menus.PUSH ("delete",
				      delete_from_source_path,
				      fn _ => !current_pos <> 0)],
d1260 17
a1276 7
                         [Menus.PUSH ("edit",
                                      make_callback EDIT,
                                      fn _ => true),
                          Menus.PUSH ("make",
                                      make_callback MAKE,
                                      fn _ => true),
                          Menus.PUSH ("remake",
d1278 14
a1291 13
                                      fn _ => true),
                          Menus.PUSH ("use",
                                      make_callback USE,
                                      fn _ => true),
                          Menus.PUSH ("dependencies",
                                      make_callback DEPENDENCIES,
                                      fn _ => true),
                          Menus.PUSH ("recompile",
                                      make_callback RECOMPILE,
                                      fn _ => true),
                          Menus.PUSH ("compile",
                                      make_callback COMPILE,
                                      fn _ => true)],
@


1.43
log
@Merged in bug fix.
@
text
@d2 4
a5 1
 $Log: _fileselect.sml,v $
d9 5
a33 1

d495 1
a495 1
	       redo_action ())
d944 38
a981 26
        fun recompile_file error_handler =
          mk_action
          (fn s => 
           let val options = UserOptions.new_options (get_user_options())
	       val s' = check_search_path s
               val str = "Recompiling " ^ s'
           in
             (ensure_output();
              output(std_out,str ^ "\n");
              MotifUtils.with_message 
              (shell,str)
              (fn () => 
               Recompile.recompile (Info.make_default_options()) options [s']);
              message_fun ("Recompilation of " ^ s' ^ " finished"))
             handle Info.Stop (error,error_list) =>
               let val filename = error_file error
               in
                 error_handler 
		   (filename, error, error_list,
                    "Error during recompilation of " ^ filename,
                    get_context,
                    fn () => UserOptions.new_options (get_user_options()))
               end
           end
	   handle NotOnSearchPath =>
	     message_fun (s ^ " not on search path"))
d983 37
a1019 32
	fun check_dependencies error_handler =
          mk_action
          (fn s => 
	   let val s' = check_search_path s
               val UserOptions.USER_OPTIONS({no_execute,...},_) =
		 get_user_options()
	       val _ = no_execute := true;
	       val options = UserOptions.new_options (get_user_options())
               val str = "Checking dependencies for " ^ s'
           in
             (ensure_output();
              output(std_out,str ^ "\n");
              MotifUtils.with_message 
              (shell,str)
              (fn () => 
               Recompile.recompile (Info.make_default_options()) options [s']);
              message_fun ("All dependencies of " ^ s' ^ " checked");
	      no_execute := false)
             handle Info.Stop (error,error_list) =>
	       (* I'm not sure that this can actually happen *)
               let val filename = error_file error
               in
		 no_execute := false;
                 error_handler 
		   (filename, error, error_list,
                    "Error while checking dependencies of " ^ filename,
                    get_context,
                    fn () => UserOptions.new_options (get_user_options()))
               end
           end
	   handle NotOnSearchPath =>
	     message_fun (s ^ " not on search path"))
d1021 32
a1052 28
        fun compile_file error_handler = 
          mk_action
          (fn s =>
           let 
             val options = UserOptions.new_options (get_user_options())
	     val s' = check_search_path s
             val str = "Compiling " ^ s'
           in
             (ensure_output();
              output(std_out,str ^ "\n");
              MotifUtils.with_message 
              (shell,str)
              (fn () =>
               TopLevel.compile_file (Info.make_default_options()) options [s']);
              message_fun ("Compilation of " ^ s' ^ " finished"))
             handle Info.Stop (error,error_list) => 
               let val filename = error_file error
               in
                 error_handler(filename,
                               error,
                               error_list,
                               "Error during compilation of " ^ filename,
                               get_context,
                               fn () => UserOptions.new_options (get_user_options()))
               end
           end
	   handle NotOnSearchPath =>
	     message_fun (s ^ " not on search path"))
d1054 33
a1086 30
        fun make_file error_handler =
          mk_action
          (fn filename =>
           let
             val error_info = Info.make_default_options()
	     val s = check_search_path filename
           in
             ensure_output();
             MotifUtils.with_message (shell,"Making " ^ s)
             (fn () =>
              (ActionQueue.add_make (s,error_info);
               ActionQueue.do_actions (context_ref,
                                       user_options,
                                       debugger_function,
                                       fn s => output(std_out,"Make: compiling " ^ s))));
            message_fun ("Make of " ^ s ^ " finished")
           end
           handle
	     NotOnSearchPath =>
	       message_fun (filename ^ " not on search path")
           | ActionQueue.Error (_,context,error,error_list) =>
               let val filename = error_file error
               in
                 error_handler
		   (filename, error, error_list,
                    "Error during make of " ^ filename,
                    get_context,
                    fn () => UserOptions.new_options (get_user_options()))
               end
           | ActionQueue.Handled => ())
d1088 33
a1120 29
        fun remake_file error_handler =
          mk_action
          (fn filename =>
           let
             val error_info = Info.make_default_options()
	     val s = check_search_path filename
           in
             ensure_output();
             MotifUtils.with_message (shell,"Remaking " ^ s)
             (fn () =>
                (ActionQueue.add_remake (s,error_info);
                 ActionQueue.do_actions
		   (context_ref, user_options, debugger_function,
                    fn s => output(std_out,"Make: compiling " ^ s))));
             message_fun ("Remake of " ^ s ^ " finished")
           end
           handle
	     NotOnSearchPath =>
	       message_fun (filename ^ " not on search path")
           | ActionQueue.Error (_,context,error,error_list) =>
               let val filename = error_file error
               in
                 error_handler
		   (filename, error, error_list,
                    "Error during make of " ^ filename,
                    get_context,
                    fn () => UserOptions.new_options (get_user_options()))
               end
           | ActionQueue.Handled => ())
d1122 30
a1151 28
        fun use_file error_handler =
          mk_action
          (fn filename =>
           let
             val error_info = Info.make_default_options ()
           in
             ensure_output();
             MotifUtils.with_message (shell,"Using " ^ filename)
             (fn () =>
              (ActionQueue.add_use (filename,error_info);
               ActionQueue.do_actions (context_ref,
                                       user_options,
                                       debugger_function,
                                       fn s => output(std_out,"Make: compiling " ^ s))));
             message_fun ("Use of " ^ filename ^ " finished")
           end
           handle
           ActionQueue.Error (_,context,error,error_list) =>
               let val filename = error_file error
               in
                 error_handler(filename,
                               error,
                               error_list,
                               "Error during use of " ^ filename,
                               get_context,
                               fn () => UserOptions.new_options (get_user_options()))
               end
         | ActionQueue.Handled => ())
d1159 6
a1164 19
          | get_action MAKE = make_file error_handler
          | get_action REMAKE = remake_file error_handler
          | get_action USE = use_file error_handler
          | get_action COMPILE = compile_file error_handler
          | get_action RECOMPILE = recompile_file error_handler
          | get_action DEPENDENCIES = check_dependencies error_handler

        and error_handler
	  (filename, error, error_list, message, context_fn, options_fn) =
          (output(std_out,message ^ "\n");
           make_error_dialog
	     (shell, filename, error, rev error_list, message,
	      context_fn, options_fn, redo_action))

	and redo_action () =
	  case !history of
	    [] => Crash.impossible "redo action"
	  | (action,filename)::_ =>
	      (get_action action) filename
d1216 2
a1217 1
        val (options_menu,update) = MotifUtils.options_menu (shell, title, fn () => user_options)
@


1.42
log
@Merged in bug fix.
@
text
@d3 6
d684 3
a686 1
	fun renumber_entry (s, n) = (s, n + 1)
d695 1
a695 1
	    (s, n) :: map renumber_entry l
d699 7
d742 1
a742 1
		Lists.filter_outp (fn (_, n) => n = !current_pos) (!entries)
@


1.41
log
@Prevented duplicate or null entries in source path.
Allowed selected directory to be added to source path without having
to move into that directory.
@
text
@d3 11
d166 1
d198 1
d409 2
a410 1
	      (parent,filename,error,error_list,message,context_fn,options_fn) =
d475 9
d487 1
a487 3
                           		  (* Widget should be destroyed *)
                           		  fn _ => (do_quit_funs();
                                                   Xm.Widget.unmanage form),
d489 3
a875 4
        fun error_handler (filename,error,error_list,message,context_fn,options_fn) =
          (output(std_out,message ^ "\n");
           make_error_dialog (shell,filename,error,rev error_list,message,context_fn,options_fn))

d922 1
a922 1
        val recompile_file =
d949 1
a949 1
	val check_dependencies =
d982 1
a982 1
        val compile_file = 
d1011 1
a1011 1
        val make_file =
d1042 1
a1042 1
        val remake_file =
d1072 1
a1072 1
        val use_file =
d1101 2
d1107 6
a1112 6
          | get_action MAKE = make_file
          | get_action REMAKE = remake_file
          | get_action USE = use_file
          | get_action COMPILE = compile_file
          | get_action RECOMPILE = recompile_file
          | get_action DEPENDENCIES = check_dependencies
d1114 12
a1135 2
        val history = ref []
          
@


1.40
log
@Merged in bug fix.
@
text
@d3 3
d656 4
d670 3
d686 9
a694 4
          (case Xm.Widget.valuesGet(box,[Xm.Directory]) of
             [Xm.COMPOUNDSTRING dir] =>
	       Xm.CompoundString.convert_string_text dir
           | _ => crash "Bad values for valuesGet (get_directory)")
d696 5
d723 4
d731 7
a737 6
	  in
	    current_pos := !current_pos + 1;
	    entries := new_entries;
	    Io.set_source_path new_source_path;
	    set_items MotifUtils.Options.default_print_options new_entries;
	    Xm.List.selectPos (list, !current_pos, false)
d742 4
d749 7
a755 6
	  in
	    if !current_pos = 0 then current_pos := 1 else ();
	    Io.set_source_path new_source_path;
	    entries := new_entries;
	    set_items MotifUtils.Options.default_print_options new_entries;
	    Xm.List.selectPos (list, !current_pos, false)
a790 3

        val filter_text =
          Xm.Widget.fileSelectionBoxGetChild(box, Xm.Widget.Child.FILTER_TEXT)
@


1.39
log
@Merging in bug fixes
@
text
@d3 8
d1122 1
a1122 1
          [ToolData.works_menu (shell, tools, fn _ => tooldata),
@


1.38
log
@Added Context label widget
@
text
@d3 9
d258 1
a258 1
      fun getline (str, pos, length) =
d299 1
a299 1
        fun do_quit_funs () = map (fn f => f ()) (!quit_funs)
d343 1
d356 1
a356 1

d364 4
a367 4
            if s_line = e_line
              then "Line " ^ MLWorks.Integer.makestring s_line
            else "Line " ^ MLWorks.Integer.makestring s_line ^ " to " ^ MLWorks.Integer.makestring e_line

d414 1
a414 1
            fun do_quit_funs () = map (fn f => f ()) (!quit_funs)
d490 2
@


1.38.1.1
log
@Fork for bug fixing
@
text
@a2 3
Revision 1.38  1993/08/31  15:44:34  matthew
Added Context label widget

@


1.38.1.2
log
@Added destroy callback to do quit functions
@
text
@a2 3
Revision 1.38.1.1  1993/08/31  15:44:34  jont
Fork for bug fixing

d252 1
a252 1
        fun getline (str, pos, length) =
d293 1
a293 1
        fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)
a336 1
        Xm.Widget.callbackAdd (shell, Xm.Callback.Destroy,do_quit_funs);
d349 1
a349 1
        
d357 4
a360 4
              if s_line = e_line
                then "Line " ^ MLWorks.Integer.makestring s_line
              else "Line " ^ MLWorks.Integer.makestring s_line ^ " to " ^ MLWorks.Integer.makestring e_line
                
d407 1
a407 1
            fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)
a482 2
            (* Note the destroy method is added to the parent of the popup shell *)
            Xm.Widget.callbackAdd (Xm.Widget.parent shell, Xm.Callback.Destroy,do_quit_funs);
@


1.38.1.3
log
@Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.
@
text
@a2 3
Revision 1.38.1.2  1993/10/07  16:36:54  matthew
Added destroy callback to do quit functions

d1111 1
a1111 1
          [ToolData.works_menu (shell, tools, fn _ => tooldata, fn () => true),
@


1.38.1.4
log
@Merged bug fix into the bug fixing branch.
@
text
@a2 15
Revision 1.41  1993/10/27  12:52:21  daveb
Prevented duplicate or null entries in source path.
Allowed selected directory to be added to source path without having
to move into that directory.

Revision 1.40  1993/10/22  16:58:09  daveb
Merged in bug fix.

Revision 1.39  1993/10/08  16:30:04  matthew
Merging in bug fixes

Revision 1.38.1.3  1993/10/21  14:03:38  daveb
Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.

a644 4
	fun is_in (n:string, []) = false
	|   is_in (n, (n', _)::t) = n = n' orelse is_in (n, t)
	infix is_in

a654 3
        val filter_text =
          Xm.Widget.fileSelectionBoxGetChild(box, Xm.Widget.Child.FILTER_TEXT)

d668 4
a671 9
	  let
	    val path = Xm.Text.getString filter_text

	    fun find_slash 0 = 0
	    |   find_slash i = 
	      if String.ordof (path, i - 1) = ord "/" then
		i
	      else
		find_slash (i - 1)
a672 5
	    val index = find_slash (size path)
	  in
	    String.substring (path, 0, index)
	  end

a694 4
	  in
	    if dir = "" orelse dir is_in !entries then
	      ()
	    else let
d699 6
a704 7
	    in
	      current_pos := !current_pos + 1;
	      entries := new_entries;
	      Io.set_source_path new_source_path;
	      set_items MotifUtils.Options.default_print_options new_entries;
	      Xm.List.selectPos (list, !current_pos, false)
	    end
a708 4
	  in
	    if dir = "" orelse dir is_in !entries then
	      ()
	    else let
d712 6
a717 7
	    in
	      if !current_pos = 0 then current_pos := 1 else ();
	      Io.set_source_path new_source_path;
	      entries := new_entries;
	      set_items MotifUtils.Options.default_print_options new_entries;
	      Xm.List.selectPos (list, !current_pos, false)
	    end
d753 3
@


1.38.1.5
log
@Added redo action to error browser.
@
text
@a2 3
Revision 1.38.1.4  1993/10/27  16:24:06  daveb
Merged bug fix into the bug fixing branch.

a158 1
require "../utils/crash";
a189 1
  structure Crash: CRASH
d400 1
a400 2
	      (parent, filename, error, error_list, message,
	       context_fn, options_fn, redo_action) =
a464 9
	    fun quit_fun _ =
              (* Widget should be destroyed *)
	      (do_quit_funs();
	       Xm.Widget.unmanage form);

	    fun redo_fun _ =
	      (quit_fun ();
	       redo_action ())

d468 3
a470 1
                           		  quit_fun,
a471 3
               		      Menus.PUSH ("redo",
                           		   redo_fun,
                           		   fn _ => true),
d856 4
d906 1
a906 1
        fun recompile_file error_handler =
d933 1
a933 1
	fun check_dependencies error_handler =
d966 1
a966 1
        fun compile_file error_handler = 
d995 1
a995 1
        fun make_file error_handler =
d1026 1
a1026 1
        fun remake_file error_handler =
d1056 1
a1056 1
        fun use_file error_handler =
a1084 2
        val history = ref []
          
d1089 6
a1094 6
          | get_action MAKE = make_file error_handler
          | get_action REMAKE = remake_file error_handler
          | get_action USE = use_file error_handler
          | get_action COMPILE = compile_file error_handler
          | get_action RECOMPILE = recompile_file error_handler
          | get_action DEPENDENCIES = check_dependencies error_handler
a1095 12
        and error_handler
	  (filename, error, error_list, message, context_fn, options_fn) =
          (output(std_out,message ^ "\n");
           make_error_dialog
	     (shell, filename, error, rev error_list, message,
	      context_fn, options_fn, redo_action))

	and redo_action () =
	  case !history of
	    [] => Crash.impossible "redo action"
	  | (action,filename)::_ =>
	      (get_action action) filename
d1106 2
@


1.38.1.6
log
@Fixed bug in delete_from_source_path.
@
text
@a2 3
Revision 1.38.1.5  1993/11/01  15:16:30  daveb
Added redo action to error browser.

d674 1
a674 3
	fun renumber_up (s, n) = (s, n + 1)

	fun renumber_down (s, n) = (s, n - 1)
d683 1
a683 1
	    (s, n) :: map renumber_up l
a686 7
	fun remove_nth ([], _) = []
	|   remove_nth (h::t, n) =
	  if n = #2 h then
	    map renumber_down t
	  else
	    h :: remove_nth (t, n)

d723 1
a723 1
		remove_nth (!entries, !current_pos)
@


1.38.1.7
log
@Redo was invoking the action from the top of the history, but the history
can be extended in the meantime.  This version redoes the action that
caused the error.  The implementation is slightly simpler too.
@
text
@d2 1
a2 4
$Log: _fileselect.sml,v $
Revision 1.38.1.6  1993/11/02  16:28:09  daveb
Fixed bug in delete_from_source_path.

d481 1
a481 1
	       redo_action filename)
d930 26
a955 7
        fun error_handler
	      (filename, error, error_list, message, context_fn, options_fn,
	       redo_action) =
          (output(std_out,message ^ "\n");
           make_error_dialog
	     (shell, filename, error, rev error_list, message,
	      context_fn, options_fn, redo_action))
d957 32
a988 30
        val recompile_file =
	  let fun f filename =
            let val options = UserOptions.new_options (get_user_options())
	        val s = check_search_path filename
                val str = "Recompiling " ^ s
            in
              (ensure_output();
               output(std_out,str ^ "\n");
               MotifUtils.with_message 
               (shell,str)
               (fn () => 
                  Recompile.recompile
		    (Info.make_default_options()) options [s]);
               message_fun ("Recompilation of " ^ s ^ " finished"))
              handle Info.Stop (error,error_list) =>
                let val filename = error_file error
                in
                  error_handler 
		    (filename, error, error_list,
                     "Error during recompilation of " ^ filename,
                     get_context,
                     fn () => UserOptions.new_options (get_user_options()),
		     mk_action f)
                end
            end
	    handle NotOnSearchPath =>
	      message_fun (filename ^ " not on search path")
	  in
            mk_action f
	  end
d990 28
a1017 70
	val check_dependencies =
	  let
	    fun f filename =
	      let val s = check_search_path filename
                  val UserOptions.USER_OPTIONS({no_execute,...},_) =
		    get_user_options()
	          val _ = no_execute := true;
	          val options = UserOptions.new_options (get_user_options())
                  val str = "Checking dependencies for " ^ s
              in
                (ensure_output();
                 output(std_out,str ^ "\n");
                 MotifUtils.with_message 
                   (shell,str)
                   (fn () => 
                      Recompile.recompile
		        (Info.make_default_options()) options [s]);
                 message_fun ("All dependencies of " ^ s ^ " checked");
	         no_execute := false)
                handle Info.Stop (error,error_list) =>
	          (* I'm not sure that this can actually happen *)
                  let val filename = error_file error
                  in
		    no_execute := false;
                    error_handler 
		      (filename, error, error_list,
                       "Error while checking dependencies of " ^ filename,
                       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
              end
	      handle NotOnSearchPath =>
	        message_fun (filename ^ " not on search path")
	  in
	    mk_action f
	  end

        val compile_file = 
	  let
	    fun f filename =
              let 
                val options = UserOptions.new_options (get_user_options())
	        val s = check_search_path filename
                val str = "Compiling " ^ s
              in
                (ensure_output();
                 output(std_out,str ^ "\n");
                 MotifUtils.with_message 
                 (shell,str)
                 (fn () =>
                    TopLevel.compile_file
		      (Info.make_default_options()) options [s]);
                 message_fun ("Compilation of " ^ s ^ " finished"))
                handle Info.Stop (error,error_list) => 
                  let val filename = error_file error
                  in
                    error_handler
		      (filename, error, error_list,
                       "Error during compilation of " ^ filename,
                       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
              end
	      handle NotOnSearchPath =>
	        message_fun (filename ^ " not on search path")
	  in
            mk_action f
	  end
d1019 30
a1048 33
        val make_file =
	  let
            fun f filename =
              let
                val error_info = Info.make_default_options()
	        val s = check_search_path filename
              in
                ensure_output();
                MotifUtils.with_message (shell,"Making " ^ s)
                  (fn () =>
                     (ActionQueue.add_make (s,error_info);
                      ActionQueue.do_actions
			(context_ref, user_options, debugger_function,
                         fn s => output(std_out,"Make: compiling " ^ s))));
                message_fun ("Make of " ^ s ^ " finished")
              end
              handle
	        NotOnSearchPath =>
	          message_fun (filename ^ " not on search path")
              | ActionQueue.Error (_,context,error,error_list) =>
                  let val filename = error_file error
                  in
                    error_handler
		      (filename, error, error_list,
                       "Error during make of " ^ filename,
                       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
              | ActionQueue.Handled => ()
	  in
            mk_action f
	  end
d1050 29
a1078 33
        val remake_file =
	  let
            fun f filename =
              let
                val error_info = Info.make_default_options()
	        val s = check_search_path filename
              in
                ensure_output();
                MotifUtils.with_message (shell,"Remaking " ^ s)
                (fn () =>
                   (ActionQueue.add_remake (s,error_info);
                    ActionQueue.do_actions
		      (context_ref, user_options, debugger_function,
                       fn s => output(std_out,"Make: compiling " ^ s))));
                message_fun ("Remake of " ^ s ^ " finished")
              end
              handle
	        NotOnSearchPath =>
	          message_fun (filename ^ " not on search path")
              | ActionQueue.Error (_,context,error,error_list) =>
                  let val filename = error_file error
                  in
                    error_handler
		      (filename, error, error_list,
                       "Error during make of " ^ filename,
                       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
              | ActionQueue.Handled => ()
	  in
            mk_action f
	  end
d1080 28
a1107 30
        val use_file =
	  let
            fun f filename =
              let
                val error_info = Info.make_default_options ()
              in
                ensure_output();
                MotifUtils.with_message (shell,"Using " ^ filename)
                  (fn () =>
                     (ActionQueue.add_use (filename,error_info);
                      ActionQueue.do_actions
			(context_ref, user_options, debugger_function,
                         fn s => output(std_out,"Make: compiling " ^ s))));
                message_fun ("Use of " ^ filename ^ " finished")
              end
              handle
                ActionQueue.Error (_,context,error,error_list) =>
                  let val filename = error_file error
                  in
                    error_handler
		      (filename, error, error_list,
		       "Error during use of " ^ filename,
		       get_context,
                       fn () => UserOptions.new_options (get_user_options()),
		       mk_action f)
                  end
            | ActionQueue.Handled => ()
	  in
            mk_action f
	  end
d1115 19
a1133 6
          | get_action MAKE = make_file
          | get_action REMAKE = remake_file
          | get_action USE = use_file
          | get_action COMPILE = compile_file
          | get_action RECOMPILE = recompile_file
          | get_action DEPENDENCIES = check_dependencies
d1185 1
a1185 2
        val (options_menu,update) =
	  MotifUtils.options_menu (shell, title, fn () => user_options)
@


1.38.1.8
log
@Disabled menu items when they are inappropriate.  Also selected the
first entry in the error browser when it is mapped.
@
text
@a2 5
Revision 1.38.1.7  1993/11/04  17:29:50  daveb
Redo was invoking the action from the top of the history, but the history
can be extended in the meantime.  This version redoes the action that
caused the error.  The implementation is slightly simpler too.

d532 1
a532 2
            Xm.Widget.manage form;
	    Xm.List.selectPos (list, 1, false)
d897 1
a897 1
	    size s' > len andalso s = MLWorks.String.substring (s', 0, len)
d1220 12
a1231 19
			  let
			    fun on_source_path () =
 			      let val dir = get_directory ()
          		      in dir = "" orelse dir is_in !entries
          		      end
 			  in
			    [Menus.PUSH ("moveto",
				         cd_to_source_path,
				         fn _ => !current_pos <> 0),
                             Menus.PUSH ("insert",
				         insert_into_source_path,
				         fn _ => not (on_source_path ())),
                             Menus.PUSH ("append",
				         append_into_source_path,
				         fn _ => not (on_source_path ())),
                             Menus.PUSH ("delete",
				         delete_from_source_path,
				         fn _ => !current_pos <> 0)]
			  end,
d1234 7
a1240 17
                         let
			   fun normal_file s =
          		     (Filename.parse_absolute s; true)
          		     handle Filename.Parse _ => false
			  
			   fun on_search_path s =
			     normal_file s andalso
			     (check_search_path s; true)
			     handle NotOnSearchPath => false
                         in
                           [Menus.PUSH ("edit",
                                        make_callback EDIT,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("make",
                                        make_callback MAKE,
                                        fn _ => on_search_path (get_file ())),
                            Menus.PUSH ("remake",
d1242 13
a1254 14
                                        fn _ => on_search_path (get_file ())),
                            Menus.PUSH ("use",
                                        make_callback USE,
                                        fn _ => normal_file (get_file ())),
                            Menus.PUSH ("dependencies",
                                        make_callback DEPENDENCIES,
                                        fn _ => on_search_path (get_file ())),
                            Menus.PUSH ("recompile",
                                        make_callback RECOMPILE,
                                        fn _ => on_search_path (get_file ())),
                            Menus.PUSH ("compile",
                                        make_callback COMPILE,
                                        fn _ => on_search_path (get_file ()))]
		         end,
@


1.37
log
@Removed filter button.  Added source path pane.  Tidied up a bit.
Source path isn't properly integrated with compilation yet.
@
text
@d3 4
d507 1
d531 12
d1185 10
d1197 1
a1197 1
	      (Xm.TopWidget, Xm.WIDGET topSep),
@


1.36
log
@Recompile.recompile and TopLevel.compile_file now take list arguments.
@
text
@d3 3
d317 1
a317 1
          [Menus.CASCADE ("file",
d524 1
a524 6
	  (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, form,
	   [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)
	   ])
d529 134
a662 3
           form,
           [(Xm.DirMask,
             Xm.COMPOUNDSTRING(Xm.CompoundString.createSimple (MLWorks.OS.Unix.getwd() ^ "/*.sml")))])
d664 37
d707 2
a708 1
           (* Xm.Widget.Child.APPLY_BUTTON, *)
d711 13
a723 1
        fun crash s = Info.error' Info.default_options (Info.FAULT,Location.UNKNOWN,s)
d725 2
a726 1
        (* This pulls the selected filename out of the widget *)
d728 5
a732 9
        fun get_file () =
          (case Xm.Widget.valuesGet(box,[Xm.TextString]) of
             [Xm.COMPOUNDSTRING filename] =>
               let
                 val filestring = Xm.CompoundString.convert_string_text filename
               in
                 filestring
               end
           | _ => crash "Bad values for valuesGet (get_file)")
d1086 23
a1108 9
          Menus.CASCADE ("output",
                         [Menus.PUSH ("show",
                                      manage_output,
                                      fn _ => true (* not(output_visible ()) *)),
                          Menus.PUSH ("hide",
                                      unmanage_output,
                                      output_visible)],
                         fn _ => true),
           Menus.CASCADE ("action",
d1138 70
a1207 11
          Xm.Widget.valuesSet (menuBar,
                               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
          Xm.Widget.valuesSet (box,
                               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                                (Xm.TopWidget, Xm.WIDGET menuBar),
                                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
@


1.35
log
@Improved messages
Renamed message to message_fun.
@
text
@d3 4
d674 1
a674 1
               Recompile.recompile (Info.make_default_options()) options s');
d704 1
a704 1
               Recompile.recompile (Info.make_default_options()) options s');
d735 1
a735 1
               TopLevel.compile_file (Info.make_default_options()) options s');
@


1.34
log
@Improved layout of error browser.
@
text
@d3 3
d277 4
d288 2
d291 1
a291 3
            ShellUtils.edit_string (locstring,get_context(),get_options())
            handle ShellUtils.EditFailed s =>
              MotifUtils.send_message (shell,s)
d293 2
a294 1
          handle NoLocation => (output(std_out,"No location info found\n"))
d302 1
d390 5
d396 7
a402 3
              ShellUtils.edit_source (location,context_fn(),options_fn())
              handle ShellUtils.EditFailed s =>
                MotifUtils.send_message (shell,s)
d419 1
a419 1
                  0 => (output(std_out,"No item selected\n"))
d426 1
a426 1
                | _ => (output(std_out,"Multiple selections - strange!\n"))
d433 2
a434 1
                           		  fn _ => Xm.Widget.unmanage form,
d587 1
a587 1
        fun message s = MotifUtils.send_message(shell,s)
d605 1
a605 1
          handle Filename.Parse _ => message "Normal file not selected"
d616 2
a617 2
              Option.ABSENT => ()
            | Option.PRESENT s => message s))
d671 1
a671 1
              message ("Recompilation of " ^ s' ^ " finished"))
d683 1
a683 1
	     message (s ^ " not on search path"))
d701 1
a701 1
              message ("All dependencies of " ^ s' ^ " checked");
d716 1
a716 1
	     message (s ^ " not on search path"))
d732 1
a732 1
              message ("Compilation of " ^ s' ^ " finished"))
d745 1
a745 1
	     message (s ^ " not on search path"))
d762 1
a762 1
            message ("Make of " ^ s ^ " finished")
d766 1
a766 1
	       message (filename ^ " not on search path")
d792 1
a792 1
             message ("Remake of " ^ s ^ " finished")
d796 1
a796 1
	       message (filename ^ " not on search path")
d822 1
a822 1
             message ("Use of " ^ filename ^ " finished")
@


1.33
log
@Added "Check dependencies" action.
@
text
@d3 3
a352 25
        fun set_dialog_form (top,workarea,separator,buttonPane) =
          (* set the form resources *)
          (Xm.Widget.valuesSet (top,
                                [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                 (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                 (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                 (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
          Xm.Widget.valuesSet (workarea,
                                [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                                 (Xm.TopWidget, Xm.WIDGET top),
                                 (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                 (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                 (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                                 (Xm.BottomWidget, Xm.WIDGET separator)]);
          Xm.Widget.valuesSet (separator,
                               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                                (Xm.BottomWidget, Xm.WIDGET buttonPane)]);
          Xm.Widget.valuesSet (buttonPane,
                               [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
                                (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                                (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]))
d354 2
a355 1
        fun make_error_dialog (parent,filename,error,error_list,message,context_fn,options_fn) =
d364 4
a374 2
            val text = Xm.Widget.createScrolledText(frame,Xm.Widget.NAME "errorBrowserText",[])

d378 2
a379 4
            val buttonPane = Xm.Widget.createManaged (Xm.Widget.NAME "dialogButtons",
                                                      Xm.Widget.Class.RowColumn,
                                                      form,
                                                      [])
d412 9
a420 7
              [Menus.PUSH ("ok",
                           (* Widget should be destroyed *)
                           fn _ => Xm.Widget.unmanage form,
                           fn _ => true),
               Menus.PUSH ("edit",
                           edit_fun,
                           fn _ => true)]
d422 28
a449 2
            Menus.make_submenus(buttonPane,menuspec);
            set_dialog_form (title,frame,separator,buttonPane);
@


1.32
log
@make, remake, compile and recompile check whether the file is on the
search path.
@
text
@d3 4
d659 33
d811 2
a812 1
        datatype action = EDIT | MAKE | REMAKE | USE | COMPILE | RECOMPILE
d820 1
d865 1
d901 3
d909 1
a909 19
                                      fn _ => true) (* ,
                          Menus.SEPARATOR,
                          Menus.CASCADE ("setDefault",
                                         [Menus.TOGGLE ("edit",
                                                        fn () => (!default_action) = EDIT,
                                                        (fn true => default_action := EDIT
                                                           | _ => ()),
                                                        fn _ => true),
                                         Menus.TOGGLE ("compiler",
                                                        fn () => (!default_action) = COMPILE,
                                                        (fn true => default_action := COMPILE
                                                      | _ => ()),
                                                        fn _ => true),
                                         Menus.TOGGLE ("recompile",
                                                        fn () => (!default_action) = RECOMPILE,
                                                        (fn true => default_action := RECOMPILE
                                                           | _ => ()),
                                                        fn _ => true)],
                                         fn _ => true) *) ],
a910 1
          (* MotifUtils.setup_menu (shell, fn () => user_options), *)
@


1.31
log
@Changes to user options
Removed preferences menu
Options update
@
text
@d3 5
d116 1
d144 1
d155 2
a156 1
  sharing type Ml_Debugger.Incremental.Context = ToolData.ShellTypes.Context = ShellUtils.Context
d162 2
a163 1
	       MotifUtils.UserOptions = ShellUtils.UserOptions = ActionQueue.UserOptions
d167 1
d589 39
d632 2
a633 1
             val str = "Recompiling " ^ s
d640 2
a641 2
               Recompile.recompile (Info.make_default_options()) options s);
              message ("Recompilation of " ^ s ^ " finished"))
d645 5
a649 6
                 error_handler(filename,
                               error,
                               error_list,
                               "Error during recompilation of " ^ filename,
                               get_context,
                               fn () => UserOptions.new_options (get_user_options()))
d651 3
a653 1
           end)
d660 2
a661 1
             val str = "Compiling " ^ s
d668 2
a669 2
               TopLevel.compile_file (Info.make_default_options()) options s);
              message ("Compilation of " ^ s ^ " finished"))
d680 3
a682 1
           end)
d689 1
d692 1
a692 1
             MotifUtils.with_message (shell,"Making " ^ filename)
d694 1
a694 1
              (ActionQueue.add_make (filename,error_info);
d699 1
a699 1
            message ("Make of " ^ filename ^ " finished")
d702 3
a704 1
           ActionQueue.Error (_,context,error,error_list) =>
d707 7
a713 6
                 error_handler(filename,
                               error,
                               error_list,
                               "Error during make of " ^ filename,
                               get_context,
                               fn () => UserOptions.new_options (get_user_options()))
a714 2
               end
         | ActionQueue.Handled => ())
d720 1
d723 1
a723 1
             MotifUtils.with_message (shell,"Remaking " ^ filename)
d725 5
a729 6
              (ActionQueue.add_remake (filename,error_info);
               ActionQueue.do_actions (context_ref,
                                       user_options,
                                       debugger_function,
                                       fn s => output(std_out,"Make: compiling " ^ s))));
            message ("Remake of " ^ filename ^ " finished")
d732 3
a734 1
           ActionQueue.Error (_,context,error,error_list) =>
d737 5
a741 6
                 error_handler(filename,
                               error,
                               error_list,
                               "Error during make of " ^ filename,
                               get_context,
                               fn () => UserOptions.new_options (get_user_options()))
d743 2
a744 1
         | ActionQueue.Handled => ())
@


1.30
log
@tooldata passed to make_debugger_window for inspector invocation
in debugger-window.
@
text
@d3 4
d551 1
a551 1
            val UserOptions.USER_OPTIONS{auto_output_window,...} =
d729 1
a729 1
            val UserOptions.USER_OPTIONS{history_length,...} = get_user_options()
d777 3
d828 2
a829 2
	  MotifUtils.setup_menu (shell, fn () => user_options),
	  MotifUtils.options_menu (shell, title, fn () => user_options),
@


1.29
log
@Changed name to File Tool
Get maximum history length from options
Auto popup of output windows
@
text
@d3 5
a110 1
require "debugger_window";
d152 2
a517 2
        val (debugger_window_fn,message_fn) =
          DebuggerWindow.make_debugger_window(shell,"debugger")
d521 3
a523 1
        val debugger_type = Ml_Debugger.WINDOWING (debugger_window_fn,message_fn,true)
@


1.28
log
@Operation to bring output window to front
Added "Line" to error output
@
text
@d3 4
d440 1
a440 1
              "Batch Tool #" ^ p ("", n)
d538 9
a546 1
        
d575 2
a576 1
             (output(std_out,str ^ "\n");
d601 2
a602 1
             (output(std_out,str ^ "\n");
d626 1
d655 1
d683 1
d715 10
a724 1
        val max_history = 20
d727 9
a735 7
        fun ministry_of_truth (_, _, 0) = []
          |   ministry_of_truth ([], _, _) = []
          |   ministry_of_truth (s::l, new_factoid, finish) =
              if s = new_factoid then
                l
              else
                s :: ministry_of_truth (l, new_factoid, finish - 1)
d738 1
a738 1
          history := a :: (ministry_of_truth (!history,a,max_history))
@


1.27
log
@Changed printing of Location.FILE in error browser
Added Interrupt handler to mk_action
Added call to MotifUtils.with_message, this actually uses a busy cursor
Changed Info.default_options to Info.make_default_options
@
text
@d3 6
d266 2
a267 1
                               Xm.Widget.manage shell)
d300 2
a301 2
          | Location.LINE(_,l) => MLWorks.Integer.makestring l
          | Location.POSITION (_,l,_) => MLWorks.Integer.makestring l
d304 2
a305 2
              then MLWorks.Integer.makestring s_line
            else MLWorks.Integer.makestring s_line ^ " to " ^ MLWorks.Integer.makestring e_line
d744 1
a744 1
                                      fn _ => not(output_visible ())),
@


1.26
log
@Added remake function
@
text
@d3 3
d292 1
a292 1
          | Location.FILE _ => "Unknown Location"
d536 2
a537 2
          handle
          Filename.Parse _ => message "Normal file not selected"
d554 1
d556 5
a560 2
             (output(std_out,"Recompiling " ^ s ^ "\n");
              Recompile.recompile Info.default_options options s;
d577 3
a579 1
           let val options = UserOptions.new_options (get_user_options())
d581 5
a585 2
             (output(std_out,"Compiling " ^ s ^ "\n");
              TopLevel.compile_file Info.default_options options s;
d603 1
a603 1
             val error_info = Info.default_options
d605 7
a611 5
             ActionQueue.add_make (filename,error_info);
             ActionQueue.do_actions (context_ref,
                                     user_options,
                                     debugger_function,
                                     fn s => output(std_out,"Make: compiling " ^ s));
d624 1
d631 1
a631 1
             val error_info = Info.default_options
d633 7
a639 5
             ActionQueue.add_remake (filename,error_info);
             ActionQueue.do_actions (context_ref,
                                     user_options,
                                     debugger_function,
                                     fn s => output(std_out,"Make: compiling " ^ s));
d658 1
a658 1
             val error_info = Info.default_options
d660 7
a666 5
             ActionQueue.add_use (filename,error_info);
             ActionQueue.do_actions (context_ref,
                                     user_options,
                                     debugger_function,
                                     fn s => output(std_out,"Make: compiling " ^ s));
@


1.25
log
@edit functions now return a single string in the errorneous case.
@
text
@d3 3
d612 25
d663 1
a663 1
        datatype action = EDIT | MAKE | USE | COMPILE | RECOMPILE
d667 1
d700 1
d729 3
@


1.24
log
@More informative messages
@
text
@d3 3
d542 1
a542 1
            | Option.PRESENT(s,t) => message(s ^ ":" ^ t)))
@


1.23
log
@Added tty_ok value to WINDOWINF
@
text
@d3 3
d548 1
a548 1
              message "Recompilation finished")
d568 1
a568 1
              message "Compilation finished")
d591 2
a592 2
                                     fn s => output(std_out,s));
             message "Make finished"
d616 2
a617 2
                                     fn s => output(std_out,s));
             message "Use finished"
@


1.22
log
@Changed error handling for make, use etc.
@
text
@d3 3
d489 1
a489 1
        val debugger_window_fn =
d494 1
a494 1
        val debugger_type = Ml_Debugger.WINDOWING debugger_window_fn
@


1.21
log
@Added history and removed some of the buttons
@
text
@a0 1

d3 3
d285 12
d544 9
a552 6
               error_handler(s,
                             error,
                             error_list,
                             "Error during recompilation of " ^ s,
                             get_context,
                             fn () => UserOptions.new_options (get_user_options()))
d564 9
a572 6
               error_handler(s,
                             error,
                             error_list,
                             "Error during recompilation of " ^ s,
                             get_context,
                             fn () => UserOptions.new_options (get_user_options()))
d589 11
a599 19
           ActionQueue.Error (s,context) =>
             (message ("Error in make: " ^ s))
         | Info.Stop (error,error_list) =>
             error_handler(filename,
                           error,
                           error_list,
                           "Error during use of " ^ filename,
                           get_context,
                           fn () => UserOptions.new_options (get_user_options()))
         | Trapped => ()
         | ShellUtils.Error (context,error,error_list) =>
             (context_ref := context;
              error_handler(filename,
                            error,
                            error_list,
                            "Error during make of " ^ filename,
                            fn () => context,
                            fn () => UserOptions.new_options (get_user_options()))))

d614 11
a624 10
           ActionQueue.Error (s,context) =>
             (message ("Error in use: " ^ s))
         | Info.Stop (error,error_list) =>
             error_handler(filename,
                           error,
                           error_list,
                           "Error during use of " ^ filename,
                           get_context,
                           fn () => UserOptions.new_options (get_user_options()))
         | Trapped => ())
@


1.20
log
@Removed integer parameter
@
text
@d4 3
d132 1
d441 11
d455 8
a462 6
          let
            val [Xm.COMPOUNDSTRING filename] = Xm.Widget.valuesGet(box,[Xm.TextString])
            val filestring = Xm.CompoundString.convert_string_text filename
          in
            filestring
          end
d496 2
d499 10
a508 10
        fun mk_action f _ =
          let val filename = get_file ()
          in
            MLWorks.IO.with_standard_output
            outstream
            (fn () =>
             (Ml_Debugger.with_debugger_type
              debugger_type
              (fn () => f filename)))
          end
a513 1
        fun message s = MotifUtils.send_message(shell,s)
d613 1
d615 46
d673 1
a673 1
                                      edit_file,
d676 1
a676 1
                                      make_file,
d679 1
a679 1
                                      use_file,
d682 1
a682 1
                                      recompile_file,
d685 1
a685 1
                                      compile_file,
d707 4
a710 1
	  MotifUtils.options_menu (shell, title, fn () => user_options)]
@


1.19
log
@All tools now set their own titles and pass them to their options menus.
@
text
@d4 3
a68 1
require "../utils/integer";
a88 1
  structure Integer : INTEGER
d272 2
a273 2
          | Location.LINE(_,l) => Integer.makestring l
          | Location.POSITION (_,l,_) => Integer.makestring l
d276 2
a277 2
              then Integer.makestring s_line
            else Integer.makestring s_line ^ " to " ^ Integer.makestring e_line
@


1.18
log
@Added use.  Changed make.  Uses ShellUtils more.
@
text
@d4 3
d133 1
a133 1
    fun make_text_output (parent,get_context,get_options) =
d139 2
a140 2
                                      [(Xm.Title, Xm.STRING "File Browser Output"),
                                       (Xm.IconName, Xm.STRING "File Browser Output")])
d380 2
d388 10
d412 2
a413 1
                                      [])
d450 1
a594 7
(*
        datatype ActionType = EDIT | RECOMPILE | COMPILE

        val default_action = ref EDIT

        fun do_default_action _ = ()
*)
d641 1
a641 1
	  MotifUtils.options_menu (shell, fn () => user_options)]
@


1.17
log
@Added make command
@
text
@d1 1
d4 3
d74 1
d88 1
a88 1
 structure Editor : EDITOR
d95 1
d97 2
a98 1
  sharing TopLevel.Info = Recompile.Info = ShellUtils.Info
d103 1
d112 2
a113 1
	       MotifUtils.UserOptions
d130 1
a130 1
    fun make_text_output (parent,get_options) =
a208 1
            output(std_out,"Location is " ^ result ^ "\n");
a211 6
        fun get_filename (Location.UNKNOWN) = raise NoLocation
          | get_filename (Location.FILE f) = f
          | get_filename (Location.LINE (f,_)) = f
          | get_filename (Location.POSITION(f,_,_)) = f
          | get_filename (Location.EXTENT {name,...}) = name

a218 2
            val location = Location.from_string locstring
            val filename = get_filename location
d220 3
a222 5
            case Editor.edit_from_location
              (get_options())
              (filename,location) of
              Option.ABSENT => ()
            | Option.PRESENT(s,t) => output (std_out,s ^ ":" ^ t ^ "\n")
d304 1
a304 1
        fun make_error_dialog (parent,filename,error,error_list,message,options_fn) =
d331 3
a333 3
              case Editor.edit_from_location (options_fn()) (filename,location) of
                Option.ABSENT => ()
              | Option.PRESENT(s,t) => output (std_out,s ^ ":" ^ t ^ "\n")
d382 6
d390 2
d394 1
a394 1
          Xm.Widget.createPopupShell (Xm.Widget.NAME "name",
d433 3
a435 1
          make_text_output (shell,fn () => UserOptions.new_options(get_user_options()))
d437 25
d467 4
a470 1
            (fn () => f filename)
d473 1
a473 1
        fun error_handler (filename,error,error_list,message,options_fn) =
d475 1
a475 1
           make_error_dialog (shell,filename,error,rev error_list,message,options_fn))
d477 1
d483 1
a483 1
            | Option.PRESENT(s,t) => output (std_out,s ^ ":" ^ t ^ "\n")))
d492 1
a492 1
              output(std_out,"Recompilation successful\n"))
d498 1
d509 1
a509 1
              output(std_out,"Compilation successful\n"))
d515 1
a517 1

d519 32
a550 4
        val debugger_window_fn =
          DebuggerWindow.make_debugger_window(shell,"debugger")

        exception Trapped
d552 1
a552 19
        fun debugger_function f x =
          MLWorks.Internal.Value.frame_call
          (fn base_frame =>
           (f x)
           handle exn =>
             (Ml_Debugger.ml_debugger
              (Ml_Debugger.WINDOWING debugger_window_fn)
              (UserOptions.new_options(user_options),
               ShellTypes.get_context_ref context_ref)
              (fn _ => output(std_out,"Debugger shell not defined yet\n"))
              base_frame
              (Ml_Debugger.EXCEPTION exn,
               Ml_Debugger.POSSIBLE
               ("Raise Interrupt",
                Ml_Debugger.DO_RAISE Trapped),
               Ml_Debugger.NOT_POSSIBLE);
              raise Div))
        
        val make_file =
a555 1
             val options = UserOptions.new_options user_options
a556 1
             val pathname = ShellUtils.parse_absolute (filename,error_info)
d558 18
a575 15
             ShellUtils.make_file
             (pathname,
              ShellTypes.get_context_ref context_ref,
              fn s => output(std_out,s),
              options,
              debugger_function,
              fn s => output(std_out,s))
             handle ShellUtils.Error (context,error,error_list) =>
               error_handler(filename,
                             error,
                             error_list,
                             "Error during make of " ^ filename,
                             fn () => UserOptions.new_options (get_user_options()))
                  | Trapped => ()
           end)
d601 3
@


1.16
log
@Changed to use MotifUtils.make_outstream
@
text
@d3 3
d66 2
a67 1

d69 2
d77 2
d83 1
a83 1
  structure Editor : EDITOR
d89 1
d91 1
a91 1
  sharing TopLevel.Info = Recompile.Info
d93 2
a94 2
 	  TopLevel.Options = Editor.Options =
	  ToolData.ShellTypes.Options
d96 3
d100 1
a100 1
	       MotifUtils.Widget
d105 1
d116 1
a256 57
    fun create (tooldata as ToolData.TOOLDATA {args,appdata,tools,...}) =
      let
        val ShellTypes.LISTENER_ARGS {user_options,
                                      ...} = args
        val ToolData.APPLICATIONDATA {applicationShell,...} = appdata

        (*** Make the windows ***)
        val shell =
          Xm.Widget.createPopupShell (Xm.Widget.NAME "fileSelection",
                                      Xm.Widget.Class.TopLevelShell,
                                      applicationShell,
                                      [])

        val form =
          Xm.Widget.createManaged (Xm.Widget.NAME "main",
                                   Xm.Widget.Class.Form,
                                   shell, [])

        val menuBar =
          Xm.Widget.createManaged
	  (Xm.Widget.NAME "menuBar", Xm.Widget.Class.RowColumn, form,
	   [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
	    (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)
	   ])

        val box = Xm.Widget.createManaged
          (Xm.Widget.NAME "selectionBox",
           Xm.Widget.Class.FileSelectionBox,
           form,
           [(Xm.DirMask,
             Xm.COMPOUNDSTRING(Xm.CompoundString.createSimple (MLWorks.OS.Unix.getwd() ^ "/*.sml")))])

        (* This pulls the selected filename out of the widget *)

        fun get_file () =
          let
            val [Xm.COMPOUNDSTRING filename] = Xm.Widget.valuesGet(box,[Xm.TextString])
            val filestring = Xm.CompoundString.convert_string_text filename
          in
            filestring
          end

	fun get_user_options () = user_options

        val (outstream,text_output_widget,output_visible,manage_output,unmanage_output) =
          make_text_output (shell,fn () => UserOptions.new_options(get_user_options()))

        fun mk_action f _ =
          let val filename = get_file ()
          in
            MLWorks.IO.with_standard_output
            outstream
            (fn () => f filename)
          end

d306 1
a306 1
        fun make_error_dialog (filename,error,error_list,message,options_fn) =
d310 1
a310 1
                                                    shell, [])
d379 58
d439 1
a439 1
           make_error_dialog (filename,error,rev error_list,message,options_fn))
d480 50
d535 1
a535 1

d550 3
d558 1
a558 1
                                      fn _ => true),
d576 1
a576 1
                                         fn _ => true)],
@


1.15
log
@Added tools argument to works_menu(),
removed exitApplication from TOOLDATA (works_menu now accesses it directly).
@
text
@d3 4
a140 1
        val prompt_pos = ref 0
d148 1
a148 27
        val outbuff = ref [] : string list ref

        fun flush_buffer () =
          let val result = !outbuff
          in
            outbuff := [];
            insert_text (implode(rev(result)))
          end

        fun output_fn s =
          let
            fun has_nl 0 = false
              | has_nl n =
                if String.ordof (s,n-1) = ord"\n"
                  then true
                else
                  has_nl (n-1)
          in
            outbuff := s :: !outbuff;
            if has_nl (size s) then
              flush_buffer()
            else ()
          end
          
        val outstream = MLWorks.IO.outstream {output = output_fn,
                                              flush_out = flush_buffer,
                                              close_out = fn () => ()}
@


1.14
log
@Fixed bug with options used by error browser.
@
text
@d3 3
d266 1
a266 1
    fun create (tooldata as ToolData.TOOLDATA {args,appdata,...}) =
d495 1
a495 1
          [ToolData.works_menu (shell, fn _ => tooldata),
@


1.13
log
@Added facility to show and hide output widget.
@
text
@d3 3
d369 1
a369 1
        fun make_error_dialog (filename,error,error_list,message,options) =
d396 1
a396 1
              case Editor.edit_from_location options (filename,location) of
d442 1
a442 1
        fun error_handler (filename,error,error_list,message,options) =
d444 1
a444 1
           make_error_dialog (filename,error,rev error_list,message,options))
d462 5
a466 1
               error_handler(s,error,error_list,"Error during recompilation of " ^ s,options)
d478 5
a482 1
               error_handler(s,error,error_list,"Error during recompilation of " ^ s,options)
@


1.12
log
@Reorganised menus.
@
text
@d3 3
d232 10
d245 1
a245 1
                                       fn _ => (),
d257 1
a257 1
        (outstream,shell)
d306 1
a306 1
        val (outstream,text_output_widget) =
d403 2
a404 1
		 select_fn = show_full_message, action_fn = edit_error,
d482 8
a536 1
          Xm.Widget.manage text_output_widget;
@


1.11
log
@Now uses MotifUtils.scrolllist.
@
text
@d3 3
d57 23
a79 22
functor FileSelect(structure Integer : INTEGER
                   structure Lists : LISTS
                   structure Xm : XM
                   structure Menus : MENUS
                   structure Editor : EDITOR
                   structure Recompile : RECOMPILE
                   structure TopLevel : TOPLEVEL
                   structure UserOptions : USER_OPTIONS
                   structure ToolData : TOOL_DATA
                   structure MotifUtils : MOTIF_UTILS

                   sharing TopLevel.Info = Recompile.Info
                   sharing UserOptions.Options = Recompile.Options =
                     TopLevel.Options = Editor.Options =
		     ToolData.ShellTypes.Options
                   sharing Recompile.Info.Location = Editor.Location
                   sharing type Xm.Widget = Menus.Widget = ToolData.Widget =
		     MotifUtils.Widget
		   sharing type Menus.ButtonSpec = MotifUtils.ButtonSpec
                   sharing type UserOptions.user_options =
		     ToolData.ShellTypes.user_options =
		     MotifUtils.UserOptions
d247 1
a247 1
    fun create (ToolData.TOOLDATA {args,appdata,tools}) =
d251 1
a251 1
        val ToolData.APPLICATIONDATA {exitApplication,applicationShell,...} = appdata
a259 2
        fun close_tool _ = Xm.Widget.destroy shell

a459 12

        val tools_buttons =
          map
          (fn (name,toolfun) =>
           Menus.PUSH (name,
                       fn _ =>
                       toolfun (ToolData.TOOLDATA {args = args,
                                                   appdata = appdata,
                                                   tools = tools}),
                       fn _ => true))
          tools

d467 2
a468 13
          [Menus.CASCADE ("file",
                          [Menus.PUSH ("close",
                                       close_tool,
                                       fn _ => true),
                           Menus.SEPARATOR,
                           Menus.PUSH ("exit",
                                       fn _ => exitApplication(),
                                       fn _ => true)],
                          fn _ => true),
          Menus.CASCADE ("tools",
                         tools_buttons,
                         fn _ => true),
          Menus.CASCADE ("action",
d497 1
@


1.10
log
@Moved options menu code to _motif_utils.
@
text
@d3 3
a301 50
        fun make_scrolllist (parent,name,select_fun,action_fun,print_fun) =
          let
            val listScroll = Xm.Widget.createManaged(Xm.Widget.NAME (name ^ "Scroll"),
                                                     Xm.Widget.Class.ScrolledWindow,
                                                     parent,[])
            val listList = Xm.Widget.createManaged (Xm.Widget.NAME (name ^ "List"),
                                                    Xm.Widget.Class.List,
                                                    listScroll,
                                                    [])
            val itemlistref = ref []

            fun get_selected_pos callback_data =
              let
                val (_,_,_,_,n,_,_,_,_) = Xm.Callback.convertList callback_data
              in
                n
              end

            fun select_callback_fun callback_data =
              let
                val pos = get_selected_pos callback_data
              in
                select_fun (Lists.nth (pos-1,!itemlistref))
                handle Lists.Nth => ()
              end

            fun action_callback_fun callback_data =
              let
                val pos = get_selected_pos callback_data
              in
                action_fun (Lists.nth (pos-1,!itemlistref))
                handle Lists.Nth => ()
              end

            fun set_items items =
              (itemlistref := items;
               Xm.List.deleteAllItems listList;
               Xm.List.addItems (listList,
                                 map (Xm.CompoundString.createSimple o print_fun) items,
                                 0))
          in
            Xm.Widget.callbackAdd (listList,
                                   Xm.Callback.SingleSelection,
                                   select_callback_fun);
            Xm.Widget.callbackAdd (listList,
                                   Xm.Callback.DefaultAction,
                                   action_callback_fun);
            (listScroll,listList,set_items)
          end

d322 1
a322 1
        fun error_to_string (Info.ERROR(severity,location,message)) =
d377 1
a377 1
            fun edit_error (Info.ERROR(_,location,_)) =
d382 1
a382 1
            fun show_full_message (Info.ERROR(_,_,message)) =
d385 6
a390 5
            val (scroll,list,set_items) = make_scrolllist (frame,
                                                           "errorBrowser",
                                                           show_full_message,
                                                           edit_error,
                                                           error_to_string)
d400 2
a401 1
                      edit_error (Lists.nth (index-1,error_list))
d417 1
a417 1
            set_items error_list;
@


1.9
log
@The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.
@
text
@d3 5
d43 1
d45 1
a46 1
require "../library/xm";
a54 1

d60 2
d64 2
a65 1
                     TopLevel.Options = Editor.Options = ToolData.ShellTypes.Options
d67 7
a73 3
                   sharing type Xm.Widget = Menus.Widget = ToolData.Widget
                   sharing type UserOptions.user_options = ToolData.ShellTypes.user_options
                     ) : FILE_SELECT =
d286 1
a286 3
        (* currently use the user_options passed in on creation *)

        fun get_user_options () = user_options
a287 1
        val _ = output(std_out,"Making text output\n")
a290 119
        (* This should be shared with _listener *)
        local
          fun set_option_fun f a =
            let
              val UserOptions.USER_OPTIONS options = get_user_options()
            in
              (f options) := a
            end
          
          fun get_option_fun f () =
            let
              val UserOptions.USER_OPTIONS options = get_user_options()
            in
              !(f options)
            end
          
          fun int_widget (name,accessor) =
            Menus.OPTINT(name,get_option_fun accessor,set_option_fun accessor)
            
          fun bool_widget (name,accessor) =
            Menus.OPTTOGGLE(name,get_option_fun accessor,set_option_fun accessor)
            
        in
          val popup_print_options =
            Menus.create_dialog
            (shell,
             "valuePrinterOptions",
             [Menus.OPTLABEL "valuePrinterOptionsLabel",
              Menus.OPTSEPARATOR,
              bool_widget("showEqInfo",#show_eq_info),
              bool_widget("showIdClass",#show_id_class),
              bool_widget("showFnDetails",#show_fn_details),
              bool_widget("showExnDetails",#show_exn_details),
              int_widget("maximumListSize",#maximum_list_size),
              int_widget("maximumDepth",#maximum_depth),
              int_widget("maximumShapeDepth",#maximum_shape_depth),
              int_widget("maximumRefDepth",#maximum_ref_depth)
              ])
            
          val popup_environment_options =
            Menus.create_dialog
            (shell,
             "environmentOptions",
             [Menus.OPTLABEL "environmentOptionsLabel",
              Menus.OPTSEPARATOR])
            
          val popup_compiler_options =
            Menus.create_dialog
            (shell,
             "compilerOptions",
             [Menus.OPTLABEL "compilerOptionsLabel",
              Menus.OPTSEPARATOR,
              bool_widget("generateTracingCode", #generate_tracing_code),
              bool_widget("generateProfilingCode", #generate_profiling_code),
              bool_widget("generateDebugInfo", #generate_debug_info),
              bool_widget("showDebugWarnings", #show_debug_warnings),
              bool_widget("optimiseLeafFns", #optimise_leaf_fns),
              bool_widget("optimiseTailCalls", #optimise_tail_calls),
              bool_widget("optimiseSelfTailCalls",#optimise_self_tail_calls)])
            
          val popup_internals_options =
            Menus.create_dialog
            (shell,
             "internalsOptions",
             [Menus.OPTLABEL "internalsOptionsLabel",
              Menus.OPTSEPARATOR,
              bool_widget("showAbsyn",#show_absyn),
              bool_widget("showLambda",#show_lambda),
              bool_widget("showOptLambda",#show_opt_lambda),
              bool_widget("showEnviron",#show_environ),
              bool_widget("showMir",#show_mir),
              bool_widget("showOptMir",#show_opt_mir),
              bool_widget("showMach",#show_mach)])
            
          val popup_compatibility_options =
            Menus.create_dialog
            (shell,
             "compatibilityOptions",
             [Menus.OPTLABEL "compatibilityOptionsLabel",
              Menus.OPTSEPARATOR,
              bool_widget("stringInequalities", #string_inequalities),
              bool_widget("polyMakestring", #poly_makestring),
              bool_widget("infixrAssoc", #infixr_assoc),
              bool_widget("opInDatatype", #op_in_datatype),
              bool_widget("njInclude", #nj_include),
              bool_widget("njOpen", #nj_local_open),
              bool_widget("semiColons", #semicolons),
              bool_widget("derivedRedef", #derived_redef)
              ])
            
          val popup_extensions_options =
            Menus.create_dialog
            (shell,
             "extensionsOptions",
             [Menus.OPTLABEL "extensionsOptionsLabel",
              Menus.OPTSEPARATOR,
              bool_widget("requireKeyword",#require_keyword),
              bool_widget("typeDynamic",#type_dynamic)])
            
          val popup_editor_options =
            Menus.create_dialog
            (shell,
             "editorOptions",
             [Menus.OPTLABEL "editorOptionsLabel",
              Menus.OPTSEPARATOR,
              Menus.OPTTOGGLE ("select_emacs",
                               fn () => case get_option_fun (#editor) () of
                               "emacs" => true
			     | _ => false,
                                 fn false => set_option_fun (#editor) "vi"
                                  | true => set_option_fun (#editor) "emacs"),
              Menus.OPTTOGGLE ("select_vi",
                               fn () => case get_option_fun (#editor) () of
			       "vi" => true
			     | _ => false,
                                 fn true => set_option_fun (#editor) "vi"
                                  | false => set_option_fun (#editor) "emacs")])
        end
            
d470 1
a470 1
           make_error_dialog (filename,error,error_list,message,options))
d563 1
a563 20
          Menus.CASCADE ("options",
                         [Menus.PUSH ("compiler",
                                      popup_compiler_options,
                                      fn _ => true),
                          Menus.PUSH ("valueprinter",
                                      popup_print_options,
                                      fn _ => true),
                          Menus.PUSH ("internals",
                                      popup_internals_options,
                                      fn _ => true),
                          Menus.PUSH ("compatibility",
                                      popup_compatibility_options,
                                      fn _ => true),
                          Menus.PUSH ("extensions",
                                      popup_extensions_options,
                                      fn _ => true),
                          Menus.PUSH ("editor",
                                      popup_editor_options,
                                      fn _ => true)],
                         fn _ => true)]
@


1.8
log
@Incorrect use of ordof().
@
text
@d3 3
d389 1
a389 1
			       MLWorks.Editor.EMACS => true
d391 2
a392 2
                                 fn false => set_option_fun (#editor) MLWorks.Editor.VI
                                  | true => set_option_fun (#editor) MLWorks.Editor.EMACS),
d395 1
a395 1
			       MLWorks.Editor.VI => true
d397 2
a398 2
                                 fn true => set_option_fun (#editor) MLWorks.Editor.VI
                                  | false => set_option_fun (#editor) MLWorks.Editor.EMACS)])
@


1.7
log
@Added error selection dialog
Start of "Default action" stuff
@
text
@d3 4
d169 1
a169 1
                  if ordof(line,index) = ord ":"
@


1.6
log
@Changed to ToolData interface
@
text
@d3 7
d25 2
d38 3
a40 1
functor FileSelect(structure Xm : XM
d402 170
a571 24
        local
          val error_list_ref = ref []
          val dialogShell =
            Xm.Widget.createPopupShell (Xm.Widget.NAME "errorMessageShell",
                                        Xm.Widget.Class.DialogShell,
                                        shell, [])
            
          val dialog =
            Xm.Widget.create(Xm.Widget.NAME "errorMessageDialog",
                             Xm.Widget.Class.MessageBox,
                             dialogShell,[])
          fun exit _ = Xm.Widget.unmanage dialog
          fun browse_errors _ = (Xm.Widget.unmanage dialog)
          val _ = Xm.Widget.callbackAdd (dialog, Xm.Callback.Ok, exit);
          val _ = Xm.Widget.callbackAdd (dialog, Xm.Callback.Cancel, browse_errors);
        in
          fun make_error_dialog (filename,error,error_list,message) =
            (error_list_ref := error_list;
             Xm.Widget.valuesSet(dialog,[(Xm.MessageString,
                                          Xm.COMPOUNDSTRING (Xm.CompoundString.createSimple message))]);
             Xm.Widget.manage dialog)
        end
            
        fun error_handler (filename,error,error_list,message) =
d573 1
a573 1
           make_error_dialog (filename,error,error_list,message))
d585 8
a592 5
           (output(std_out,"Recompiling " ^ s ^ "\n");
            Recompile.recompile Info.default_options (UserOptions.new_options (get_user_options())) s;
            output(std_out,"Recompilation successful\n"))
           handle Info.Stop (error,error_list) =>
             error_handler(s,error,error_list,"Error during recompilation of " ^ s))
d597 8
a604 5
           (output(std_out,"Compiling " ^ s ^ "\n");
            TopLevel.compile_file Info.default_options (UserOptions.new_options (get_user_options())) s;
            output(std_out,"Compilation successful\n"))
           handle Info.Stop (error,error_list) => 
             error_handler(s,error,error_list,"Error during recompilation of " ^ s))
d617 7
a623 1
        
d646 19
a664 1
                                      fn _ => true)],
@


1.5
log
@Added proper interface to editor
and an output window.  Much code duplicated from _listener.
@
text
@d23 1
d36 1
a36 1

d39 1
a39 1
                     TopLevel.Options = Editor.Options
d41 2
a42 1
                   sharing type Xm.Widget = Menus.Widget
d48 1
d55 2
d210 1
a210 1
    fun make_selector parent =
d212 4
a215 2
        (* this should be a parameter *)
        val initial_options = Options.default_options
d220 1
a220 1
                                      parent,
d223 1
a223 1
        fun close_application _ = Xm.Widget.destroy shell
d256 1
a256 3
        (* options stuff *)

        val user_options = UserOptions.make_user_options initial_options
d391 27
d421 1
a421 1
           (case Editor.edit (UserOptions.new_options user_options) (s,0) of
d429 1
a429 1
            Recompile.recompile Info.default_options (UserOptions.new_options user_options) s;
d431 2
a432 2
           handle Info.Stop _ =>
             (output(std_out,"Error during recompilation of " ^ s ^ "\n")))
d438 1
a438 1
            TopLevel.compile_file Info.default_options (UserOptions.new_options user_options) s;
d440 2
a441 2
           handle Info.Stop _ => 
             (output(std_out,"Error during recompilation of " ^ s ^ "\n")))
d444 11
d458 5
a462 1
                                       close_application,
d465 3
@


1.4
log
@Much changed.  Added options and proper recompile etc. function.
@
text
@d3 3
d31 1
d37 3
a39 1
                   sharing UserOptions.Options = Recompile.Options = TopLevel.Options
d47 1
d49 112
d162 24
a185 1
    fun select_file _ = fn _ => ()
d187 18
d255 4
d378 7
a384 1
        fun mk_action s _ = s (get_file ())
d386 6
a391 1
        val edit_file = mk_action (fn s => output(std_out,"Editing " ^ s ^ "\n"))
d444 3
a462 5
(*
        Xm.Widget.callbackAdd(box,
                              Xm.Callback.Apply,
                              activate);
*)
d464 3
a466 1
          Xm.Widget.realize shell
@


1.3
log
@More hackery, still doesn't work
,
@
text
@d3 4
d15 5
d21 2
d26 9
d40 3
d46 3
a48 1
      let      
d56 1
a56 1
        fun popdown _ = Xm.Widget.destroy shell
d79 1
a79 2
        (* This should pull the selected string out of the widget *)
        (* and apply the selection function *)
d81 1
a81 1
        fun activate _ =
a84 1
            val filestring = "/usr/users/matthew/ml/src/images/test.sml"
d86 1
a86 1
            output(std_out,"Selected: " ^ filestring ^ "\n")
d88 198
a285 13
      in
        (* set the form resources *)
        Xm.Widget.valuesSet (menuBar,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (box,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET menuBar),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
d289 3
a291 5
        Xm.Widget.callbackAdd(box,
                              Xm.Callback.Cancel,
                              popdown);
        Xm.Widget.manage shell;
        Xm.Widget.realize shell
@


1.2
log
@Names of Callbacks have changed.
@
text
@d3 3
a8 1

d20 3
a22 1
    fun select_file(parent,selection_function) =
d24 1
d26 2
a27 2
          Xm.Widget.createPopupShell (Xm.Widget.NAME "Selection",
                                      Xm.Widget.Class.DialogShell,
d31 17
a47 1
        val box = Xm.Widget.create
d50 1
a50 1
           shell,
a53 6
        fun popdown _ = 
          Xm.Widget.unmanage box

        fun popup () =
          Xm.Widget.manage box

d59 2
a60 4
(*
            val [filename] = Xm.Widgets.valuesGet(box,[Xm.TextString])
            val filestring = convert_string filename
*)
d63 1
a63 1
            selection_function filestring
d66 12
a77 3
        Xm.Widget.callbackAdd(box,
                              Xm.Callback.Ok,
                              fn _ =>(activate ();popdown ()));
d84 2
a85 1
        popup
@


1.1
log
@Initial revision
@
text
@d3 2
d6 1
d54 1
a54 1
                              Xm.OkCallback,
d57 1
a57 1
                              Xm.ApplyCallback,
d60 1
a60 1
                              Xm.CancelCallback,
@
