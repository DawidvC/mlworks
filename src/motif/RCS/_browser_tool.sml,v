head	1.63;
access;
symbols
	ML_beta_release_12/08/94:1.37
	ML_beta_release_03/08/94:1.36
	ML_revised_beta_release_25/05/94:1.33
	ML_final_beta_release_02/03/94:1.32
	mlworks-28-01-1994:1.31
	Release:1.23
	mlworks-beta-01-09-1993:1.23;
locks; strict;
comment	@ * @;


1.63
date	95.07.26.13.20.39;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	95.07.20.16.17.04;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	95.07.17.11.47.52;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	95.07.14.16.49.34;	author io;	state Exp;
branches;
next	1.59;

1.59
date	95.07.07.15.42.54;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	95.07.04.14.01.27;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	95.06.13.14.19.55;	author daveb;	state Exp;
branches;
next	1.56;

1.56
date	95.06.01.10.31.22;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	95.05.22.14.42.00;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	95.05.22.09.54.00;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	95.05.04.09.51.33;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	95.04.28.16.56.05;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	95.04.19.11.57.11;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	95.04.18.15.09.03;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	95.04.06.12.35.32;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	95.03.31.16.52.58;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	95.03.31.08.55.32;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	95.03.17.11.28.26;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	95.03.16.11.46.58;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	95.03.15.16.41.09;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	95.03.10.15.44.13;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.03.02.13.30.32;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	95.02.24.16.51.19;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.02.24.15.29.32;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	94.11.30.16.26.17;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	94.09.21.16.19.16;	author brianm;	state Exp;
branches;
next	1.37;

1.37
date	94.08.09.17.02.24;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	94.07.19.08.34.25;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	94.07.12.16.04.16;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	94.06.20.15.25.19;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	94.05.05.16.37.05;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	94.02.22.00.44.22;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	93.12.15.15.35.12;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	93.12.10.15.34.44;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	93.12.09.19.34.19;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	93.11.30.14.07.23;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.11.25.14.25.31;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	93.10.22.16.59.01;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	93.10.08.16.28.40;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.09.16.16.06.03;	author nosa;	state Exp;
branches;
next	1.23;

1.23
date	93.08.11.11.05.10;	author matthew;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	93.08.10.10.27.23;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.07.30.13.57.37;	author nosa;	state Exp;
branches;
next	1.20;

1.20
date	93.06.30.16.47.56;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	93.05.18.19.05.42;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	93.05.14.14.27.42;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.05.13.12.48.19;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	93.05.12.16.25.33;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	93.05.12.15.38.16;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	93.05.12.15.32.14;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	93.05.11.15.58.12;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.05.05.12.10.17;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.05.04.17.24.52;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.05.04.15.19.51;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	93.04.30.14.45.58;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	93.04.29.13.49.09;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	93.04.28.15.09.55;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	93.04.28.10.39.02;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	93.04.27.11.21.25;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	93.04.26.18.53.45;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	93.04.22.08.49.55;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	93.04.21.16.34.34;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	93.04.21.14.15.43;	author daveb;	state Exp;
branches;
next	;

1.23.1.1
date	93.08.11.11.05.10;	author jont;	state Exp;
branches;
next	1.23.1.2;

1.23.1.2
date	93.10.07.15.43.12;	author matthew;	state Exp;
branches;
next	1.23.1.3;

1.23.1.3
date	93.10.21.14.03.54;	author daveb;	state Exp;
branches;
next	;


desc
@Context Browser.
@


1.63
log
@Adding support for font dimensions etc.
@
text
@(*
 * Copyright (c) 1993 Harlequin Ltd.
 *  $Log: _browser_tool.sml,v $
 *  Revision 1.62  1995/07/20  16:17:04  matthew
 *  Adding scroll_to functions
 *
 *  Revision 1.61  1995/07/17  11:47:52  matthew
 *  Graphics functions abstraction
 *
 *  Revision 1.60  1995/07/14  16:49:34  io
 *  add searching, offload bits to entry for listener use.
 *
 *  Revision 1.59  1995/07/07  15:42:54  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.58  1995/07/04  14:01:27  matthew
 *  Adding graphing functionality
 *
 *  Revision 1.57  1995/06/13  14:19:55  daveb
 *  Made value constructors be displayed with the "con" pseudo-keyword.
 *
 *  Revision 1.56  1995/06/01  10:31:22  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.55  1995/05/22  14:42:00  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.54  1995/05/22  09:54:00  daveb
 *  Added create_initial.
 *
 *  Revision 1.53  1995/05/04  09:51:33  matthew
 *  Changing createPopupShell to create
 *
 *  Revision 1.52  1995/04/28  16:56:05  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.51  1995/04/19  11:57:11  daveb
 *  A new tool is now passed the right user context.
 *
 *  Revision 1.49  1995/04/06  12:35:32  matthew
 *  Replacing Tyfun_id etc. with Stamp
 *
 *  Revision 1.48  1995/03/31  16:52:58  daveb
 *  Added the history number to items in the history.
 *
 *  Revision 1.47  1995/03/31  08:55:32  daveb
 *  Empty lists are now handled automatically by MotifUtils.make_scrolllist.
 *
 *  Revision 1.46  1995/03/17  11:28:26  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 *
 *  Revision 1.45  1995/03/16  11:46:58  daveb
 *  Removed context_function from register when closing the window.
 *
 *  Revision 1.44  1995/03/15  16:41:09  daveb
 *  Changed to share current context with other tools..
 *
 *  Revision 1.43  1995/03/10  15:44:13  daveb
 *  Registered select function with current context.
 *  Also simplified manipulation of pathStack slightly - no need to store
 *  toplevel items on the stack, as they're always calculated anew.
 *
 *  Revision 1.42  1995/03/02  13:30:32  matthew
 *  Parser and Lexer revisions
 *
 *  Revision 1.41  1995/02/24  16:51:19  daveb
 *  Moved parent and toplevel buttons from the history menu to the main window.
 *
 *  Revision 1.40  1995/02/24  15:29:32  daveb
 *  Added View menu and Filter dialog box.  Made empty structures display
 *  the word "<empty">.
 *
 *  Revision 1.39  1994/11/30  16:26:17  daveb
 *  Simplified Form constraints.
 *
 *  Revision 1.38  1994/09/21  16:19:16  brianm
 *  Adding value menu ...
 *
 *  Revision 1.37  1994/08/09  17:02:24  daveb
 *  Fixed bugs with toplevel command and update behaviour.
 *
 *  Revision 1.36  1994/07/19  08:34:25  daveb
 *  Added automatic updates.
 *
 *  Revision 1.35  1994/07/12  16:04:16  daveb
 *  ToolData.works_menu now takes different arguments.
 *
 *  Revision 1.34  1994/06/20  15:25:19  daveb
 *  Changed context refs to user_contexts.
 *
 *  Revision 1.33  1994/05/05  16:37:05  daveb
 *  Overloaded schemes now include the type variable being overloaded.
 *
 *  Revision 1.32  1994/02/22  00:44:22  nosa
 *  TYCON' for type function functions in lambda code for Modules Debugger;
 *  Extra TYNAME valenv for Modules Debugger.
 *
 *  Revision 1.31  1993/12/15  15:35:12  matthew
 *  Added level field to Basis.
 *
 *  Revision 1.30  1993/12/10  15:34:44  daveb
 *  Added context menu, ensured that changes do the right thing, ensured that
 *  new selection is passed on to child tools.
 *
 *  Revision 1.29  1993/12/09  19:34:19  jont
 *  Added copyright message
 *
 *  Revision 1.28  1993/11/30  14:07:23  matthew
 *  Added is_abs field to TYNAME and METATYNAME
 *
 *  Revision 1.27  1993/11/25  14:25:31  daveb
 *  Changed the way constructors are displayed, so that selecting and pasting
 *  them makes sense.  This involved making two factors orthogonal: namely
 *  whether a component is the last component on a path and whether it has
 *  any entries (a datatype satisfies both of these conditions).
 *
 *  Revision 1.26  1993/10/22  16:59:01  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.25  1993/10/08  16:28:40  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.24  1993/09/16  16:06:03  nosa
 *  Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
 *
 *  Revision 1.23.1.3  1993/10/21  14:03:54  daveb
 *  Changed ToolData.works_menu to take a (unit -> bool) function that
 *  controls whether the Close menu option is enabled.
 *
 *  Revision 1.23.1.2  1993/10/07  15:43:12  matthew
 *  Uses history utilities in ShellUtils
 *
 *  Revision 1.23.1.1  1993/08/11  11:05:10  jont
 *  Fork for bug fixing
 *
 *  Revision 1.23  1993/08/11  11:05:10  matthew
 *  Get update function from options_menu and put in user_options
 *  Removed preferences menu
 *
 *  Revision 1.22  1993/08/10  10:27:23  matthew
 *  Get maximum history length from options
 *
 *  Revision 1.21  1993/07/30  13:57:37  nosa
 *  Changed type of constructor NULL_TYFUN for value printing in
 *  local and closure variable inspection in the debugger.
 *
 *  Revision 1.20  1993/06/30  16:47:56  daveb
 *  Removed exception environments.
 *
 *  Revision 1.19  1993/05/18  19:05:42  jont
 *  Removed integer parameter
 *
 *  Revision 1.18  1993/05/14  14:27:42  daveb
 *  Changed names of history menu buttons.
 *
 *  Revision 1.17  1993/05/13  12:48:19  daveb
 *  All tools now set their own titles and pass them to their options menus.
 *
 *  Revision 1.16  1993/05/12  16:25:33  daveb
 *  Added pop_history command.
 *
 *  Revision 1.15  1993/05/12  15:38:16  daveb
 *  Added previous fix to update function as well.
 *
 *  Revision 1.14  1993/05/12  15:32:14  daveb
 *  Fixed bug in display of current selection.  Set max history to sensible
 *  number.
 *
 *  Revision 1.13  1993/05/11  15:58:12  matthew
 *  Change to layout resources
 *
 *  Revision 1.12  1993/05/05  12:10:17  daveb
 *  Added tools argument to works_menu(),
 *  removed exitApplication from TOOLDATA (works_menu now accesses it directly).
 *
 *  Revision 1.11  1993/05/04  17:24:52  matthew
 *  Added label with context name
 *  Changed context ref handling
 *
 *  Revision 1.10  1993/05/04  15:19:51  daveb
 *  Removed duplicates from history and restricted history length.
 *  Added selected values (etc.) to the selection display.
 *
 *  Revision 1.9  1993/04/30  14:45:58  daveb
 *  Reorganised menus.
 *
 *  Revision 1.8  1993/04/29  13:49:09  daveb
 *  Added dynamic history and update facility.
 *  Corrected reversed ordering of variables and exceptions.
 *
 *  Revision 1.7  1993/04/28  15:09:55  daveb
 *  Added selection text widget and improved the layout.
 *
 *  Revision 1.6  1993/04/28  10:39:02  daveb
 *  Changes to make_scrolllist.
 *
 *  Revision 1.5  1993/04/27  11:21:25  daveb
 *  Fixed printing of exceptions.  Filtered out value constructors from list.
 *
 *  Revision 1.4  1993/04/26  18:53:45  daveb
 *  Fixed printing of type variables.
 *
 *  Revision 1.3  1993/04/22  08:49:55  daveb
 *  Removed now spurious reference to Valenv.Options.  That version of valenv
 *  was never checked in, as it turned out not to be needed.
 *
 *  Revision 1.2  1993/04/21  16:34:34  daveb
 *  Now browses datatypes, and ignores types and vals.
 *
 *  Revision 1.1  1993/04/21  14:15:43  daveb
 *  Initial revision
 *  
 *  
 *)

require "../library/capi";
require "../library/graph_widget";
require "../utils/lists";
require "../main/user_options";
require "../main/preferences";
require "../utils/crash";
require "../interpreter/shell_utils";
require "menus";
require "motif_utils";
require "tooldata";
require "../interpreter/entry";
require "browser_tool";

functor BrowserTool (
  structure Capi : CAPI
  structure GraphWidget : GRAPH_WIDGET
  structure Crash : CRASH
  structure Lists : LISTS
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure Menus : MENUS
  structure MotifUtils : MOTIF_UTILS
  structure ToolData : TOOL_DATA
  structure ShellUtils : SHELL_UTILS
  structure Entry : ENTRY

  sharing UserOptions.Options = 
	  ToolData.ShellTypes.Options =
          ShellUtils.Options
  sharing type Entry.PrintOptions = UserOptions.Options.print_options
  sharing type ToolData.UserContext.identifier = Entry.Identifier
  sharing type UserOptions.user_tool_options =
	       ToolData.UserContext.user_tool_options =
	       ToolData.ShellTypes.user_options =
	       MotifUtils.user_tool_options = ShellUtils.UserOptions
  sharing type Menus.Widget = MotifUtils.Widget = ToolData.Widget = Capi.Widget =
               GraphWidget.Widget
  sharing type Capi.GraphicsPorts.GraphicsPort = GraphWidget.GraphicsPort
  sharing type Menus.ButtonSpec = MotifUtils.ButtonSpec = ToolData.ButtonSpec
  sharing type ToolData.ShellTypes.Context =
               Entry.Context = ShellUtils.Context
  sharing type ToolData.ShellTypes.user_context = MotifUtils.user_context
  sharing type MotifUtils.user_context_options =
	       ToolData.UserContext.user_context_options
  sharing type ShellUtils.user_preferences =
	       ToolData.ShellTypes.user_preferences =
	       Preferences.user_preferences =
	       MotifUtils.user_preferences
  sharing type MotifUtils.MotifContext = ToolData.MotifContext
) : BROWSERTOOL =
struct
    structure UserContext = ToolData.UserContext
    structure Options = UserOptions.Options
    structure Option = MLWorks.Option

    type Widget = Capi.Widget
    type UserOptions = UserOptions.user_tool_options
    type ShellData = ToolData.ShellTypes.ShellData
    type ToolData = ToolData.ToolData

    val browser_number = ref 1

    (* create : ToolData -> unit *)
    fun create (tooldata as ToolData.TOOLDATA
		{args,appdata,current_context,motif_context,tools}) =
      let
	val ToolData.ShellTypes.LISTENER_ARGS
	      {user_options, user_preferences,
	       mk_xinterface_fn, prompter, ...} = args

	val ToolData.APPLICATIONDATA {applicationShell,...} =
	  appdata

	val full_menus =
	  case user_preferences
	  of Preferences.USER_PREFERENCES ({full_menus, ...}, _) =>
	    !full_menus

        val title = let
	  val n = !browser_number
	in
	  browser_number := n + 1;
	  "Context Browser #" ^ (MLWorks.Integer.makestring n)
	end (* title *)

	val local_context = ref motif_context

	fun getItemsFromContext () = let
	  val context = #2(UserContext.get_context_info
			   (MotifUtils.get_user_context (!local_context)))
	in
	  Entry.context2entry context
	end
      
        val (shell,frame,menuBar,contextLabel) =
          Capi.make_main_window ("browser",title,applicationShell,full_menus)

	val listLabel = Capi.make_managed_widget ("listLabel",Capi.Label,frame,[])
	val pathLabel = Capi.make_managed_widget ("pathLabel",Capi.Label,frame,[])
	val pathText = Capi.make_managed_widget ("pathText",Capi.Text,frame,[])
        val buttonPane = Capi.make_managed_widget ("buttonPane", Capi.RowColumn, frame, []);

	fun get_context () =
	  UserContext.get_context
	    (MotifUtils.get_user_context (!local_context))

        fun set_context_label motif_context =
	  case contextLabel
	  of MLWorks.Option.SOME w =>
            let
              val context_name =
	        MotifUtils.get_context_name motif_context

              val string = "Context: " ^ context_name
            in
              Capi.set_label_string (w,string)
            end
	  |  MLWorks.Option.NONE => ()

	local 
          val browse_options = Entry.new_options ()
          val Entry.BROWSE_OPTIONS 
            {show_vars,
             show_cons,
             show_exns,
             show_types,
             show_strs,
             show_sigs,
             show_funs,
             show_conenvs} = browse_options
        in
	  val filter_entries = 
            Entry.filter_entries browse_options

	  fun map_selected f print_options l =
	    f print_options (filter_entries l)
	    
	  fun get_user_options () = user_options

	  fun get_print_options () =
	    UserOptions.new_print_options (get_user_options ())

	  fun grep regexp line = let
	    fun startsWith [] ys = true
	      | startsWith xs [] = false
	      | startsWith (x::xs) (y::ys) = (x=y) andalso (startsWith xs ys)
	    fun check [] ys = false
	      | check xs [] = false
	      | check xs (y::ys) = startsWith xs (y::ys) orelse check xs ys
	  in
	    check (explode regexp) (explode line)
	  end (* grep *)
	
	  fun collect f xs = let
	    fun collect f acc [] = rev acc
	      | collect f acc (x::xs) =
		if f x then collect f (x::acc) xs
		else collect f acc xs
	  in (* let *)
	    collect f [] xs
	  end (* collect *)

	  val searchOptions = ref
	    {showSig = true,
	     showStr = true,
	     showFun = true,
	     searchInitial = true,
	     showType = true}
	  
	  fun search s = let
	    val context = getItemsFromContext ()
	    val printOptions = get_print_options()
	    (* datatype Entry is a linear structure, munge to tree like form *)
	    val entrys = map Entry.massage context
	    val entrys' = Entry.printEntry1 (!searchOptions) printOptions entrys
	    val entrys' = map implode entrys'
	    (* val _ = map debug_output entrys' *)
	    val found = collect (grep s) entrys'
	    (* val _ = map debug_output found *)
	    val _ = MotifUtils.list_select
	      (shell, "ListSelect Name") (found, fn x=>(), fn x=>x)
	  in
	    ()
	  end (* search *)
	  
	val search_spec =
	  [
	   Menus.OPTLABEL "Search inside...",
	   Menus.OPTSEPARATOR,
	   Menus.OPTTOGGLE ("signatures", fn ()=> #showSig (!searchOptions),
			    fn b=>searchOptions:=Entry.update ("showSig", b, !searchOptions)),
	   Menus.OPTTOGGLE ("structures", fn ()=> #showStr (!searchOptions),
			    fn b=>searchOptions:=Entry.update ("showStr", b, !searchOptions)),
	   Menus.OPTTOGGLE ("functors",   fn ()=> #showFun (!searchOptions),
			    fn b=>searchOptions:=Entry.update ("showFun", b, !searchOptions)),
	   Menus.OPTSEPARATOR,
	   Menus.OPTTOGGLE ("Display their types", fn ()=> #showType (!searchOptions),
			    fn b=>searchOptions:=Entry.update ("showType", b, !searchOptions)),
	   Menus.OPTSEPARATOR,
	   Menus.OPTTEXT ("Search for Item", fn () => "" , fn s =>search s)
	   ]

	val filter_spec =
	  [Menus.OPTTOGGLE ("show_sigs",
			      fn () => !show_sigs,
			      fn b => show_sigs := b),
	   Menus.OPTTOGGLE ("show_funs",
			    fn () => !show_funs,
			    fn b => show_funs := b),
	   Menus.OPTTOGGLE ("show_strs",
			    fn () => !show_strs,
			    fn b => show_strs := b),
	   Menus.OPTTOGGLE ("show_types",
			    fn () => !show_types,
			    fn b => show_types := b),
	   Menus.OPTTOGGLE ("show_conenvs",
			    fn () => !show_conenvs,
			    fn b => show_conenvs := b),
	   Menus.OPTTOGGLE ("show_exns",
			    fn () => !show_exns,
			    fn b => show_exns := b),
	   Menus.OPTTOGGLE ("show_cons",
			    fn () => !show_cons,
			    fn b => show_cons := b),
	   Menus.OPTTOGGLE ("show_vars",
			    fn () => !show_vars,
			    fn b => show_vars := b)]
	end (* local *)
      
        val pathStack = ref []
	(* pathStack records each entry on the path, so that we can go to
	 the parent structure *)
	val history = ref []
	val pathLength = ref 0;
	val pathStr = ref ""
	  
	fun add_to_path (str, new_items, false) =
	  (* structures or signatures *)
	  (pathLength := !pathLength + size str;
	   pathStr := !pathStr ^ str;
	   pathStack := (!pathLength, "", new_items) :: (!pathStack))
	  |   add_to_path (str, new_items, true) =
	      (* datatypes - display of entries overwrites the type name itself *)
	      (pathStack := (!pathLength, str, new_items) :: (!pathStack);
	       pathStr := !pathStr ^ str)
	      
	fun shorten_path pos =
	  (Capi.Text.replace (pathText, pos, !pathLength, "");
	   pathLength := pos)

	val length_of_last_component = ref 0;
	  
        fun select_fn (_,_, set_items) entry =
	  let 
	    val (str, last_component) = Entry.get_id entry
	    val str' =
	      if !pathLength = 0 orelse str = "" then str else "." ^ str
	    val old_str = !pathStr
            val new_items = Entry.browse_entry true entry
	  in
	    (* The behaviour of this function is determined by two values.
	     If last_component is true, the selection is the last component
	     of a long id, and so the path in the selection box should not
	       be extended beyond this point.
	       If in addition new_items is empty, then the list of items should
	       not be changed. *)
	    
	    (* Update the selection box. *)
	    Capi.Text.replace
	      (pathText, !pathLength,
	       !pathLength + !length_of_last_component, str');

	    if last_component then
	      length_of_last_component := size str'
	    else
	      length_of_last_component := 0;
	      
	      (* Push the stacks and display the components of the
	       selected entry. *)
	    case (last_component, new_items)
	    of (true, []) =>
	      ()
	    | _ =>
	      (add_to_path (str', new_items, last_component);
	       ShellUtils.add_history_item
	         ((!pathStr, !pathStack), history,
                  (fn ((s,_),(s',_))=>s=s'), user_preferences);
               map_selected set_items (get_print_options ()) new_items)
          end

        val subwindow = Capi.make_managed_widget ("subwindow", Capi.Paned, frame, [Capi.PanedMargin true])

        datatype Node = ROOT | NODE of Entry.Entry

        fun print_node item =
          let
            val printOptions = get_print_options ()
          in
            case item of
              ROOT => "Context"
            | NODE entry => Entry.printEntry printOptions entry
          end

        val baseline_height = 3
        fun max (x,y) = if x > y then x else y

        datatype Item = ITEM of Node * (string * int * int * int) Option.option ref

        fun get_item_data (ITEM (entry,extents),gp) =
          case !extents of
            Option.SOME data => data
          | _ =>
              let
                val s = print_node entry
                val {font_ascent,font_descent,width,...} = Capi.GraphicsPorts.text_extent (gp,s)
                val data = (s,font_ascent,font_descent,width)
              in
                extents := Option.SOME data;
                data
              end

        fun entry_draw_item (item,gp,x,y) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
          in 
	    Capi.GraphicsPorts.draw_fill_rectangle (gp,
                                                    x-left-1,
                                                    y-font_ascent-baseline_height-1,
                                                    left+right+4,
                                                    font_ascent + font_descent + 4);
            Capi.GraphicsPorts.draw_image_string (gp,s,
                                                  x - left,
                                                  y - baseline_height)
          end

        fun entry_extent (item,gp) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
          in
            (left,
             right+2,
             baseline_height + font_ascent+1,
             max (0,font_descent+3-baseline_height))
          end
    
        fun make_context_graph () =
          let
            fun entryfun entry = ITEM (NODE entry,ref MLWorks.Option.NONE)
            val items = map entryfun (getItemsFromContext ())
            fun get_children (ITEM (ROOT,_)) = items
              | get_children (ITEM (NODE entry,_)) = map entryfun(Entry.browse_entry true entry)
          in
            (ITEM (ROOT,ref MLWorks.Option.NONE),
             get_children,
             Option.NONE) (* No equality function as this is going to be drawn as a tree *)
          end

        val graph_spec =
          GraphWidget.GRAPH_SPEC {child_position = GraphWidget.BELOW,
                                  parent_position = GraphWidget.TOP,
                                  orientation = GraphWidget.HORIZONTAL,
                                  line_style = GraphWidget.STEP,
                                  horizontal_delta = 20,
                                  vertical_delta = 1}

        val (graph_window,initialize_graph,update_graph) = 
          GraphWidget.make ("browserGraph","BrowserGraph",
                            graph_spec,entry_draw_item,entry_extent,make_context_graph,subwindow)

	val (scroll, list, set_items') =
	  Capi.make_scrolllist 
	    {parent = subwindow, name = "contextBrowser", select_fn = select_fn,
	     action_fn = fn _ => fn _ => (), print_fn = Entry.printEntry}

        val list_visible = ref true
        val graph_visible = ref true

        fun toggle_visible (visible,window) b =
          (visible := b;
           if b then Capi.manage window
           else Capi.unmanage window)

	(* Massage set_items so that it prints the empty element in the
	 nil case. *)

	(* all instances of map_selected is used in set_items
	 There is some dodgy imperative stuff going on here
	 Commented out set_items and see what happens with new version *)
	(* 
        val set_items = map_selected set_items'
        fun map_selected f print_options l = f print_options (filter_entries l)
	 *)
	fun set_items print_options l = set_items' print_options (filter_entries l)
	  
	fun select (UserContext.ITEM (_, id, context, _, _)) =
	  let
            val entry_opt = Entry.get_entry (id,context)
	  in
	    case entry_opt
	      of MLWorks.Option.NONE => ()
	    |  MLWorks.Option.SOME entry =>
	      let
		val (str, last_component) = Entry.get_id entry
		val new_items = Entry.browse_entry true entry
	      in
                case (last_component, new_items)
                of (true, []) =>
                  ()
                | _ =>
                  (* Push the stacks and display the components of the
                     selected entry. *)
                  (Capi.Text.replace (pathText, 0, !pathLength, str);
		   (* Set pathStack to the top level, then add this item. *)
		   pathStack := [];
		   pathStr := "";
		   pathLength := 0;
		   add_to_path (str, new_items, last_component);
		   if last_component then
                     length_of_last_component := size str
		   else 
		     length_of_last_component := 0;
                   ShellUtils.add_history_item
                     ((!pathStr, !pathStack), history,
                      (fn ((s,_),(s',_))=>s=s'), user_preferences);
                   map_selected set_items (get_print_options ()) new_items)
	      end
	  end

	fun sense_select user_options =
	  case UserContext.get_selected
	    (MotifUtils.get_user_context (!local_context), user_options)
	    of
	      MLWorks.Option.NONE => ()
	    | MLWorks.Option.SOME entry => select entry
	       
	fun do_history (s, new_path) =
	  (Capi.Text.replace (pathText, 0,
			    !pathLength + !length_of_last_component, s);
	   pathLength := size s;
	   length_of_last_component := 0;
	   pathStr := s;
	   pathStack := new_path;
	   case new_path 
	     of (_, _, new_items) :: _ =>
	       set_items (get_print_options ()) new_items
	   | [] =>
	       set_items (get_print_options ()) (getItemsFromContext ()))
	  
	fun can_pop () =
	  case !pathStack of
	    [] => false
	  | _  => true
	      
	fun toplevel _ =
	  (* Context may have changed, so get current items. *)
	  (do_history ("", []);
	   Capi.set_focus list)
	  
	fun pop_history _ =
	  case !pathStack of
	    [_] =>
	      (* Parent is toplevel, so need to get current context *)
	      toplevel ()
	  | _ :: tail as ((n, s, items) :: _) =>
	      (pathStack := tail;
	       pathStr := MLWorks.String.substring (!pathStr, 0, n) ^ s;
	       Capi.Text.replace (pathText, 0,
                             !pathLength + !length_of_last_component,
                             !pathStr);
	       length_of_last_component := 0;
	       pathLength := n;
	       set_items (get_print_options ()) items;
               Capi.set_focus list)
	  | _ =>
	      Capi.set_focus list

	fun redisplay () = 
	  case !pathStack
	    of (_, _, items) :: _ =>
	      set_items (get_print_options ()) items
	  | _ =>
	      (* We could store the current toplevel items in a reference,
	       but this function is called so rarely that it doesn't seem
	       worth it.  The state in this module is complicated enough
	       already. *)
	      set_items (get_print_options ()) (getItemsFromContext ())
	      
	      
	fun search_popup _ =
	  (
	   (#1 (Menus.create_dialog
		(shell, "Search Window", "browserDialog", fn ()=>(), search_spec))) ()
	   )
	  
	fun filter_popup _ =
	  (
	   (#1 (Menus.create_dialog
	      (shell, "Context Browser Settings", "browserDialog",
	       fn ()=>(), filter_spec))) ()
	   )
	  
	val _ = redisplay ()
	  
	fun update () =
	  (* Update contents if at top level, otherwise leave it alone.
	   Users can't update existing substructures. *)
	  case !pathStack of
	    [] => toplevel ()
	  | _ => ()
	      
	val quit_funs = ref []
	  
	fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)
	  
	(* Add the update function to the current context, so that changes
	 to the context are reflected in the browser. *)
	val update_fn_key =
	  ref (UserContext.add_update_fn
	       (MotifUtils.get_user_context (!local_context), update));

	val select_fn_key =
	  ref (UserContext.add_select_fn
	       (MotifUtils.get_user_context (!local_context),
		(select, get_user_options)))

	fun set_context c =
	  let
	    val old_user_context = MotifUtils.get_user_context (!local_context)
	    val new_user_context = MotifUtils.get_user_context c
	  in
	    UserContext.remove_update_fn
	      (old_user_context, !update_fn_key);
	    UserContext.remove_select_fn
	      (old_user_context, !select_fn_key);
	    local_context := c;
	    set_context_label c;
	    update_fn_key :=
	      UserContext.add_update_fn (new_user_context, update);
	    select_fn_key :=
	      UserContext.add_select_fn
		(new_user_context, (select, get_user_options));
	    (* Delete the history.  If you don't do this, then if users select
	       an entry in another context and move through its parents until
	       they reach the top level, they will be surprised when the
	       browser shows the top level of the current context.  The only
	       sane alternative to deleting the history is to add context
	       information to each entry on the history. *)
	    history := [];
            update_graph ();
	    toplevel ()
	  end
	   
	val context_key =
	  ToolData.add_context_fn
	  (current_context, (set_context, get_user_options, ToolData.ALL))
	  
	val _ =
	  quit_funs :=
	  (fn _ =>
	   let
	     val user_context = MotifUtils.get_user_context (!local_context)
	   in
	     UserContext.remove_update_fn
	     (user_context, !update_fn_key);
	     UserContext.remove_select_fn
	     (user_context, !select_fn_key);
	     ToolData.remove_context_fn
	     (current_context, context_key)
	   end)
	  :: !quit_funs

        fun select_context user_context =
          (set_context user_context;
           ToolData.set_current
	   (current_context, context_key, user_options, user_context))

        fun close_window _ =
          (do_quit_funs ();
           Capi.destroy shell)

        fun mk_tooldata () =
          ToolData.TOOLDATA
            {args = ToolData.ShellTypes.LISTENER_ARGS
                      {user_options = user_options,
		       user_preferences = user_preferences,
                       user_context =
			 MotifUtils.get_user_context (!local_context),
                       prompter = prompter,
                       mk_xinterface_fn = mk_xinterface_fn},
             appdata = appdata,
             current_context = current_context,
	     motif_context = !local_context,
             tools = tools}

        fun get_string_nm () = Capi.Text.get_string pathText

	val sep_size = 10

        val view_options =
          MotifUtils.view_options
            {parent = shell, title = title, user_options = user_options,
	     user_preferences = user_preferences,
	     caller_update_fn = sense_select,
	     sensitivity = MotifUtils.NO_SET_SELECTION,
	     view_type = MotifUtils.SENSE_ONLY}

        val view_menu =
          Menus.CASCADE
            ("view",
             view_options
             @@ [Menus.PUSH ("filter", filter_popup, fn () => true)],
             fn _ => true)
      in
        Menus.make_submenus
        (buttonPane,
         [Menus.PUSH ("parentButton",
                      pop_history,
                      fn _ => true),
          Menus.PUSH ("toplevelButton",
                      toplevel,
                      fn _ => true)]);
        Menus.make_submenus
        (menuBar,
         [ToolData.works_menu
          (mk_tooldata, close_window, fn () => true,
           fn () => MotifUtils.get_user_context (!local_context)),
          view_menu,
          MotifUtils.value_menu_strfun
          (shell, MotifUtils.get_user_context (!local_context),
           user_options, user_preferences, get_string_nm),
          MotifUtils.context_menu
          {set_state = select_context,
           get_context = fn () => !local_context,
           writable = MotifUtils.ALL,
           applicationShell = applicationShell,
           user_preferences = user_preferences},
	  Menus.CASCADE
	  ("view",
	   [Menus.PUSH ("filter", filter_popup, fn _=> true)],
	   fn _=> true),
	  Menus.CASCADE
	  ("Search",
	   [Menus.PUSH ("search", search_popup, fn _=> true)],
	   fn _=> true),
          Menus.DYNAMIC
          ("history",
           fn () =>
           map
           (fn (s,i) =>
            Menus.PUSH (s, fn _ => do_history (s,i), fn _ => true))
           (!history),
           fn _ => true),
          Menus.CASCADE
          ("stuff",
           [Menus.TOGGLE ("list",
                          fn _ => !list_visible,
                          toggle_visible (list_visible,scroll),
                          fn _ => true),
            Menus.TOGGLE ("graph",
                          fn _ => !graph_visible,
                          toggle_visible (graph_visible,graph_window),
                          fn _ => true)
            ],
           fn _ => true)]);

        Capi.Layout.lay_out
        ([Capi.Layout.MENUBAR menuBar] @@
         (case contextLabel of
            MLWorks.Option.SOME w => [Capi.Layout.OTHER w]
          | _ => [Capi.Layout.SPACE]) @@
         [Capi.Layout.OTHER pathLabel,
          Capi.Layout.OTHER pathText,
          Capi.Layout.OTHER buttonPane,
          Capi.Layout.OTHER listLabel,
          Capi.Layout.PANED subwindow,
          Capi.Layout.SPACE]);
        Capi.Callback.add (frame, Capi.Callback.Destroy, do_quit_funs);
        set_context_label (!local_context);
        Capi.manage shell;
        Capi.realize shell;
        initialize_graph ()
      end

    fun create_initial
	  (ToolData.TOOLDATA
	     {args = ToolData.ShellTypes.LISTENER_ARGS
		{user_context, user_options, user_preferences, prompter,
		 mk_xinterface_fn},
	      appdata, tools, ...}) =
      let
	val initial = MotifUtils.getInitialContext ()
      in
	case user_options
	of UserOptions.USER_TOOL_OPTIONS
	     ({set_selection, sense_selection, set_context, sense_context, ...},
	      _) =>
	  (set_selection := false;
	   sense_selection := false;
	   set_context := false;
	   sense_context := false);

        create
	  (ToolData.TOOLDATA
	     {args =
		ToolData.ShellTypes.LISTENER_ARGS
		  {user_context = MotifUtils.get_user_context initial,
		   user_preferences = user_preferences,
		   user_options = user_options,
		   prompter = prompter,
		   mk_xinterface_fn = mk_xinterface_fn},
	      appdata = appdata,
	      motif_context = initial,
	      current_context = ToolData.make_current (initial),
	      tools = tools})
      end
  end
@


1.62
log
@Adding scroll_to functions
@
text
@d4 3
d519 18
d539 3
a541 7
            val s = print_node item
            val ss = size s
            val left = (3 * ss) + 1
            val right = (3 * ss) + 2
            val up = 14
            val down = 2
            val fontheight = 12
d543 8
a550 2
	    Capi.GraphicsPorts.draw_fill_rectangle (gp,x-left,y-up,left+right,fontheight + 4);
            Capi.GraphicsPorts.draw_image_string (gp,s,x - left + 1,y-up+fontheight)
d555 3
a557 1
            val s = print_node item
d559 4
a562 1
            ((3 * size s) + 1,(3 * size s) + 2,14,2)
d567 4
a570 4
            val items = map NODE (getItemsFromContext ())
            fun get_children ROOT = items
              | get_children (NODE entry) = map NODE (Entry.browse_entry true entry)
            fun eq (x,y) = print_node x = print_node y
d572 1
a572 1
            (ROOT,
d586 2
a587 1
          GraphWidget.make (graph_spec,entry_draw_item,entry_extent,make_context_graph,subwindow)
@


1.61
log
@Graphics functions abstraction
@
text
@d4 3
d214 1
d228 1
d248 3
a250 1
  sharing type Menus.Widget = MotifUtils.Widget = ToolData.Widget = Capi.Widget
a272 418
local
  val left_margin = 0
  val right_margin = 0
  val top_margin = 0
  val bottom_margin = 0
  val horizontal_delta = 10
  val vertical_delta = 10

  val do_debug = false
  fun iterate f [] = ()
    | iterate f (a::b) =
      (f a; iterate f b)
  fun ++ x = x := !x + 1;
  fun -- x = x := !x - 1;

  datatype 'a node =
    NODE of {node : 'a,
             hide_children : bool ref,
             hidden : bool ref,
             id : int,
             level : int ref,
             parent_count : int ref, (* internal use only *)
             children : int list,
             x : int ref,
             y : int ref,
             extent : (int * int * int * int) ref }

  fun node_node (NODE {node,...}) = node

(*
  fun massage0 (root,get_children,eq) =
    let
      (* return a list of nodes *)
      fun list_nodes root =
        let
          val nodes = ref []
          fun add node =
            let
              fun lookup (node,[]) =
                (nodes := node :: !nodes;
                 true)
                | lookup (node,a::b) =
                  if eq (node,a) then false
                  else lookup (node,b)
            in
              lookup (node,!nodes)
            end
          fun scan node =
            (if add node
               then iterate scan (get_children node)
             else ())
        in
          scan root;
          rev (!nodes)
        end

      (* Annotate them *)
      fun transform_nodes nodelist =
        let
          exception Index
          fun index' (node,[],n) = raise Index
            | index' (node,node'::rest,n) =
              if eq(node,node') then n
              else index' (node,rest,n+1)
          fun index node = index' (node,nodelist,0)
        in
          Array.arrayoflist
          (map 
           (fn node =>
            NODE {node = node,
                  hide_children = ref true,
                  hidden = ref true,
                  id = index node,
                  level = ref 0,
                  parent_count = ref 0,
                  children = map index (get_children node),
                  x = ref 0,
                  y = ref 0,
                  extent = ref (0,0,0,0)})
           nodelist)
        end
      val nodelist = list_nodes root
      val nodes = transform_nodes nodelist
    in
      nodes
    end
*)

  fun massage0 (root,get_children,eq) =
  (* This version just does trees, ie. the eq function is ignored *)
    let
      val count = ref 0
      val nodes = ref []
      fun make_node (node,children,id) =
        NODE {node = node,
              hide_children = ref true,
              hidden = ref true,
              id = id,
              level = ref 0,
              parent_count = ref 0,
              children = children,
              x = ref 0,
              y = ref 0,
              extent = ref (0,0,0,0)}
      fun scan node =
        let
          val id = !count
          val _ = ++count
          val children = map scan (get_children node)
        in
          nodes := make_node (node,children,id) :: !nodes;
          id
        end
      val _ = scan root
      val dummy_node = make_node (root,[],0)
      val nodearray = Array.array (!count,dummy_node)
      val _ = 
        Lists.iterate 
        (fn (node as NODE {id,...}) => 
         Array.update (nodearray,id,node)) 
        (!nodes)
    in
      nodearray
    end
    
  fun massage_graph nodes =
    let
      val get_node = Array.sub;
      fun set_levels nodes =
        let
          val root = get_node (nodes,0)
          fun set_parent_count (NODE {children,...}) =
            iterate 
            (fn id =>
             let
               val node = get_node (nodes,id)
               val NODE {parent_count,...} = node
             in
               ++parent_count
             end)
            children
          fun member (x,[]) = false
            | member (x,(a:int) :: b) = x = a orelse member (x,b)
          fun adjust_counts () =
            let
              val seen = ref []
              fun aux (path,node) =
                if member (node,!seen) then ()
                else
                  let
                    val _ = seen := node :: !seen
                    val NODE {children,...} = get_node (nodes,node)
                    val path' = node :: path
                    fun do_child child =
                      if member (child,path)
                        then
                          let
                            val NODE {parent_count,...} = get_node (nodes,child)
                          in
                            --parent_count
                          end
                      else
                        aux (path',child)
                  in
                    iterate do_child children
                  end
            in
              aux ([],0)
            end
          fun set_level ([],n) = ()
            | set_level (nodeset,n) =
            let
              fun get_children (NODE {children,...}) =
                map (fn id => get_node (nodes,id)) children
              val nextnodes = ref []
              fun do_node node =
                (* Node level already set *)
                let
                  val children = get_children node
                in
                  iterate
                  (fn node as NODE {level,parent_count,children,...} =>
                   (--parent_count;
                    if !parent_count = 0
                      then
                        (level := n;
                         nextnodes := node :: !nextnodes)
                    else ()))
                  children
                end
            in
              iterate do_node nodeset;
              set_level (!nextnodes,n+1)
            end
        in
          ExtendedArray.iterate set_parent_count nodes;
          adjust_counts ();
          set_level ([root],1)
        end
      fun node_level (NODE {level,...}) = !level
      fun node_id (NODE {id,...}) = id
      fun get_children (NODE {children,level,...}) =
        map (fn id => Array.sub (nodes,id)) children
      fun filter f [] = []
        | filter f (a::b) =
          if f a then a::filter f b
          else filter f b
      fun hide_children (NODE {hide_children,...}) = !hide_children
      fun get_layout_children node =
        if hide_children node then []
        else
        let
          val children = get_children node
          val level = node_level node
        in
          filter (fn node => node_level node = level + 1) children
        end
    in
      set_levels nodes;
      (nodes,
       Array.sub (nodes,0),
       get_children,
       get_layout_children,
       fn (node1,node2) => node_id node1 = node_id node2)
    end
  
    (* Layout utilities *)
    (* This function lays out items according to their size *)
    fun layout_items (gp,
                      nodes,
                      node_extent) =
      let
        
        datatype 'a Layout = LAYOUT of 'a * int * 'a Layout list

        val (nodes,root,get_children,get_layout_children,eq) =
          massage_graph nodes

        val _ = ExtendedArray.iterate (fn NODE {node,extent,...} => extent := node_extent (node,gp)) nodes
        val _ = ExtendedArray.iterate (fn NODE {hidden,...} => hidden := true) nodes

        fun get_node_extent (NODE {extent,...}) = !extent

        (* lays out children assuming root has position 0,0 *)
        fun layout (root as NODE {hidden,...}) =
          let
            val _ = hidden := false
            val children = get_layout_children root
            val (left,right,up,down) = get_node_extent root
          in
            case children of
              [] => LAYOUT (root,up+down,[])
            | _ =>
                let
                  val subtrees = map layout children
                  fun get_total_height ([],acc) = acc
                    | get_total_height ([LAYOUT (node,totalh,subtrees)],acc) = 
                      totalh + acc
                    | get_total_height (LAYOUT (node,totalh,subtrees)::rest,acc) = 
                      get_total_height (rest,totalh + vertical_delta + acc)
                  val total_height = get_total_height (subtrees,0)
                in
                  LAYOUT (root,total_height,subtrees)
                end
          end
        
        fun real_layout (x,y,LAYOUT (root,th,subtrees)) =
          (* x is the width so far of the tree *)
          (* y is the _top_ of the vertical space allocated *)
          let
            val NODE {x=x_ref,y=y_ref,...} = root
            val (left,right,up,down) = get_node_extent root
            fun dosubtrees ([],y) = ()
              | dosubtrees ((tree as LAYOUT (node,th,_))::rest,y) =
                (real_layout (x+left+right+horizontal_delta,y,tree);
                 dosubtrees (rest,y+th+vertical_delta))
          in
            x_ref := x+left;
            y_ref := y + (th div 2) + ((up+down) div 2);
            dosubtrees (subtrees,y)
          end

        fun dimensions (layout as LAYOUT (node,th,subtrees)) =
          let
            val height = top_margin + th + bottom_margin
            fun get_width (LAYOUT (node,th,[])) = 
              let 
                val (left,right,up,down) = get_node_extent node
              in
                left+right
              end
              | get_width (LAYOUT (node,th,subtrees)) =
                let
                  fun do_subtrees ([],max_width) = max_width
                    | do_subtrees (subtree::rest,max_width) =
                      let
                        val width = horizontal_delta + get_width subtree
                      in
                        do_subtrees (rest,if width > max_width then width else max_width)
                      end
                  val width = do_subtrees (subtrees,0)
                  val (left,right,up,down) = get_node_extent node
                in
                  left+ right + width
                end
          in
            (left_margin + get_width layout + right_margin,
             height)
          end
        val layout = layout root
        val (xextent,yextent) = dimensions layout
      in
        real_layout (left_margin,top_margin,layout);
        (nodes,xextent,yextent)
      end
in
fun make_toplevel (draw_item,item_extent,graph,widget) =
  let
        (*  The extent of the drawing area *)
        val layout_info = ref Option.NONE
        fun get_extent () = 
          case !layout_info of
            Option.SOME (layout,width,height) =>
              (width,height)
          | _ => (100,100)
        val nodes = massage0 graph
        fun do_layout gp =
          layout_info := Option.SOME (layout_items (gp,nodes,item_extent))
        fun draw_graph gp =
          case !layout_info of
            Option.SOME (layout,width,height) =>
              let
                fun do_node1 (NODE {node,x,y,hidden,children,level,...}) =
                  if !hidden then ()
                  else
                    (iterate
                     (fn id =>
                      let
                        val NODE {x=x',y=y',hidden=hidden',level=level',...} = Array.sub (layout,id)
                      in 
                        if !hidden' then ()
                        else
                          if !level < !level'
                            then Capi.GraphicsPorts.draw_line (gp,!x,!y,!x',!y')
                          else Capi.GraphicsPorts.draw_line (gp,!x,!y,!x',!y')
                      end)
                     children)
                fun do_node2 (NODE {node,x,y,hidden,children,level,...}) =
                  if !hidden then ()
                  else draw_item (gp,node,!x,!y)
              in
                ExtendedArray.iterate do_node1 layout;
                ExtendedArray.iterate do_node2 layout
              end
          | _ => ()
        fun draw (gp,x,y,width,height) =
          (Capi.GraphicsPorts.set_clip_region (gp,(x,y,width,height));
           draw_graph gp;
           Capi.GraphicsPorts.clear_clip_region gp)
        fun get_nodes () =
          case !layout_info of
            Option.SOME (layout,_,_) => layout
          | _ => raise Div
        val (scroll,gp,set_scrollbars) = Capi.GraphicsPorts.make_scrolled_graphics (draw,get_extent,widget)
        fun initialize () =
          (Capi.GraphicsPorts.initialize_gp gp;
           do_layout gp;
           set_scrollbars ())

        fun do_select (NODE {hide_children,...}) =
          (hide_children := not (!hide_children);
           do_layout gp;
           set_scrollbars ())
          
        fun do_press (x,y) =
          let
            val nodes = get_nodes ()
            fun find 0 = ()
              | find n =
                let
                  val (node as NODE {x = ref x',y = ref y',extent = ref (left,right,up,down),...}) =
                    Array.sub (nodes,n-1)
                in
                  if x >= x'-left andalso x < x' + right andalso y >= y'-up andalso y < y' + down
                    then
                      do_select node 
                  else find (n-1)
                end
          in
            find (Array.length nodes)
          end
        
        exception Halt
        fun input_callback data =
          let
            val event = Capi.Callback.get_event data
            val event_type = Capi.Event.get_event_type event
          in
            if event_type = Capi.Event.KeyPress
              then raise Halt (* Capi.exit_dialog (applicationShell,applicationShell,true) *)
            else if event_type = Capi.Event.ButtonPress
                   then
                     case Capi.Event.get_button_data event of
                       Option.SOME (x,y) =>
                         let
                           val (xi,yi) = Capi.GraphicsPorts.get_offset gp
                         in
                           do_press (x+xi,y+yi)
                         end
                     | _ => ()
                 else ()
          end
        val _ = Capi.Callback.add (Capi.GraphicsPorts.gp_widget gp,Capi.Callback.Input,input_callback)
      in
        (scroll,initialize)
      end
end

d507 1
a507 1
        fun entry_draw_item (gp,item,x,y) =
d510 9
a518 4
            val s =
              case item of
                ROOT => "Context"
              | NODE entry => Entry.printEntry printOptions entry
d520 1
a520 1
            val left = (3 * ss) + 2
d522 1
a522 1
            val up = 19
d526 2
a527 11
            Capi.GraphicsPorts.draw_fill_rectangle (gp,x-left,y-up,left+right+1,fontheight + 5);
            Capi.GraphicsPorts.draw_image_string (gp,s,x - left + 2,y-up+fontheight)
          end

        fun print_node item =
          let
            val printOptions = get_print_options ()
          in
            case item of
              ROOT => "Context"
            | NODE entry => Entry.printEntry printOptions entry
d534 1
a534 1
            ((3 * size s) + 2,(3 * size s) + 2,19,2)
d537 1
a537 1
        val context_graph =
d546 1
a546 1
             eq)
d549 10
a558 4
        val (other_window,initialize_graph) = make_toplevel (entry_draw_item,entry_extent,context_graph,subwindow)
          handle exn as Capi.WindowSystemError s => 
            (output (MLWorks.IO.terminal_out,"X error: " ^ s ^ "\n");
             raise exn)
d565 7
a571 13
        val window1 = ref other_window
        val window2 = ref scroll
          
        fun swap _ =
          let
            val w1 = !window1
            val w2 = !window2
          in
            Capi.unmanage w2;
            Capi.manage w1;
            window1 := w2;
            window2 := w1
          end
d579 3
a581 2
	(* val set_items = map_selected set_items'
          fun map_selected f print_options l = f print_options (filter_entries l)
d739 1
d844 10
a853 2
          ("swap",
           [Menus.PUSH ("swap", swap, fn _ => true)],
@


1.60
log
@add searching, offload bits to entry for listener use.
@
text
@d4 3
a209 7
require "../basics/identprint";
require "../interpreter/incremental";
require "../typechecker/basis";
require "../typechecker/types";
require "../typechecker/valenv";
require "../typechecker/scheme";
require "../library/xm";
d219 1
a219 1
require "entry";
a222 1
  structure Xm : XM
a225 2
  structure IdentPrint : IDENTPRINT
  structure Incremental : INCREMENTAL
a227 4
  structure Basis : BASIS
  structure Types : TYPES
  structure Valenv : VALENV
  structure Scheme : SCHEME
d234 1
a234 7
  sharing Incremental.InterMake.Inter_EnvTypes.EnvironTypes.LambdaTypes.Ident =
          Basis.BasisTypes.Datatypes.Ident = IdentPrint.Ident = Entry.Ident
  sharing Basis.BasisTypes.Datatypes = Types.Datatypes =
          Incremental.Datatypes = Scheme.Datatypes = Valenv.Datatypes =
	  Entry.Types.Datatypes
  sharing UserOptions.Options = Types.Options =
          Incremental.InterMake.Compiler.Options = 
d236 3
a238 5
          IdentPrint.Options = ShellUtils.Options = Entry.Options
  sharing Entry.Basis.BasisTypes = Basis.BasisTypes

  sharing type ToolData.UserContext.identifier =
	       Incremental.InterMake.Compiler.identifier
d243 1
a243 3
  sharing type Basis.BasisTypes.Datatypes.Type = ShellUtils.Type
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget = ToolData.Widget =
    Capi.Widget
a244 1
  sharing type Basis.BasisTypes.Basis = Incremental.InterMake.Compiler.TypeBasis
d246 1
a246 1
	       Incremental.Context = ShellUtils.Context
a257 3
    structure Ident = Basis.BasisTypes.Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Inter_EnvTypes = Incremental.InterMake.Inter_EnvTypes
d259 1
a259 1
    structure Compiler = Incremental.InterMake.Compiler
d261 1
a261 2
    type Widget = Xm.Widget
    type Context = Incremental.Context
d266 87
a352 1
    fun debug_output s = output(MLWorks.IO.terminal_out,s ^"\n")
d354 129
a482 3
    local
      fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
      val sync_graphics_exposures : unit -> unit = env "x sync graphics exposures"
d484 6
a489 230
      fun max (x:int,y) = if x > y then x else y
      fun min (x:int,y) = if x < y then x else y
	
      (* Layout utilities *)
      datatype 'a RealLayout = REALLAYOUT of 'a * int * int * 'a RealLayout list
	
      (* This function lays out items according to their size *)
      fun layout_items (root:'a,
			get_children :'a -> 'a list,
			get_size : 'a -> int * int) =
	let
	  fun get_height node = 30
	  fun get_width node = 80
	    
	  datatype 'a Layout = LAYOUT of 'a * int * int * int * 'a Layout list
	    
	  (* lays out children assuming root has position 0,0 *)
	  fun layout (root) =
	    let
	      val children = get_children root
	      val (w,h) = get_size root
	    in
	      case children of
		[] => LAYOUT (root,w,h,h,[])
	      | _ =>
		  let
		    val subtrees = map layout children
		    fun get_total_height ([],acc) = acc
		      | get_total_height (LAYOUT (node,w,h,totalh,subtrees)::rest,acc) = 
			get_total_height (rest,totalh + acc)
		    val total_height = get_total_height (subtrees,0)
		  in
		    LAYOUT (root,w,h,total_height,subtrees)
		  end
	    end
	  
	  fun real_layout (x,y,LAYOUT (root,w,h,th,subtrees)) =
	    (* x is the width so far of the tree *)
	    (* y is the _top_ of the vertical space allocated *)
	    let
	      fun dosubtrees ([],y,acc) = rev acc
		| dosubtrees ((tree as LAYOUT (_,w,h,th,_))::rest,y,acc) =
		  dosubtrees (rest,y+th,real_layout (x+w,y,tree)::acc)
	    in
	      REALLAYOUT(root,x,y + (th div 2),dosubtrees (subtrees,y,[]))
	    end
	  
	  fun dimensions (LAYOUT (_,w,h,th,[])) = (w,th)
	    | dimensions (LAYOUT (_,w,h,th,subtrees)) =
	      let
		fun do_subtrees ([],max_width,height) = (max_width,height)
		  | do_subtrees (subtree::rest,max_width,height) =
		    let
		      val (width,height') = dimensions subtree
		    in
		      do_subtrees (rest,if width > max_width then width else max_width,height+height')
		    end
		val (width,height) = do_subtrees (subtrees,0,0)
	      in
		(w + width,height)
	      end
	    
	  val layout = layout root
	  val (xextent,yextent) = dimensions layout
	in
	  (real_layout (0,0,layout),xextent,yextent)
	end
      
      fun make_toplevel (draw_item,graph) (parent) =
	let
	  (* Make the windows *)
	  (* perchance this shouldn't be managed, but then we get a nice effect if it is *)
	  val scroll = Capi.make_managed_widget ("drawScroll",Capi.ScrolledWindow,parent,[])
	    
	  val frame = Capi.make_managed_widget ("drawFrame",Capi.Frame,scroll,[])
	    
	  val main = Capi.make_managed_widget ("drawPane", Capi.Graphics, frame,[])
	    
	  val vscroll = Capi.make_managed_widget ("drawVScroll", Capi.VScrollBar,scroll,[])
	  val hscroll = Capi.make_managed_widget ("drawHScroll", Capi.HScrollBar,scroll,[])
	    
	  val _ = Xm.Widget.valuesSet
	    (scroll,
	     [(Xm.VerticalScrollBar,Xm.WIDGET vscroll),
	      (Xm.HorizontalScrollBar,Xm.WIDGET hscroll),
	      (Xm.WorkWindow,Xm.WIDGET frame)])
	    
	  val display = Xm.Widget.display main
	  val screen = Xm.Widget.screen main
	    
	  fun draw_graph (window,gc) (layout,draw_item,offset_x,offset_y) =
	    let
	      fun do_node (REALLAYOUT (root,x,y,children)) =
		let
		  val _ =
		    map 
		    (fn REALLAYOUT (_,x',y',_) => Xm.Draw.line (display,window,gc,x+offset_x,y+offset_y,x'+offset_x,y'+offset_y))
		    children
		  val _ = draw_item (display,window,gc,root,x+offset_x,y+offset_y)
		in
		  map do_node children;
		  ()
		end
	    in
	      do_node layout
	    end
	  
	  val window_info_ref = ref MLWorks.Option.NONE
	  fun set_window_info_ref () =
	    let
	      val window = Xm.Widget.window main
	      val gc = Xm.GC.create (display,window,[Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
						     Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
	    in
	      window_info_ref := MLWorks.Option.SOME (window,gc)
	    end
	  
	  val (layout,width,height) = layout_items graph
	    
	  (* Scrolling etc. *)
	  (*  The extent of the drawing area *)
	  val xextent_ref = ref width
	  val yextent_ref  = ref height
	    
	  (* offset of start of window *)
	  val xi_ref = ref 0
	  val yi_ref = ref 0
	    
	  fun draw_picture (x,y,width,height) =
	    case !window_info_ref of
	      MLWorks.Option.NONE => ()
	    | MLWorks.Option.SOME (w,gc) =>
		let
		  val (ww,wh) = Capi.widget_size main
		in
		  Xm.GC.setClipRectangles (display,gc,0,0,[(x,y,width,height)],Xm.GC.UNSORTED);
		  draw_graph (w,gc) (layout,draw_item,~(!xi_ref),~(!yi_ref))
		end
	      
	  (* These need to be a little careful about the way the copy area is done *)
	  fun horizontal_scroll_callback data =
	    let
	      val window = Xm.Widget.window main
	      val scroll_gc = Xm.GC.create (display,window,[])
	      val new_xi = 
		case Xm.Widget.valuesGet (hscroll,[Xm.Value]) of
		  [Xm.INT new_xi] => new_xi
		| _ => raise Div
	      val (width,height) = Capi.widget_size main
	      val old_xi = !xi_ref
	      val delta = old_xi-new_xi
	    in
	      xi_ref := new_xi;
	      if delta > 0
		then 
		  (Xm.Draw.copyArea (display,window,window,scroll_gc,~delta,0,width,height,0,0);
		   sync_graphics_exposures())
	      else 
		(Xm.Draw.copyArea (display,window,window,scroll_gc,~delta,0,width,height,0,0);
		 sync_graphics_exposures())
	    end
	  
	  fun vertical_scroll_callback data =
	    let
	      val window = Xm.Widget.window main
	      val scroll_gc = Xm.GC.create (display,window,[])
	      val new_yi = 
		case Xm.Widget.valuesGet (vscroll,[Xm.Value]) of
		  [Xm.INT new_yi] => new_yi
		| _ => raise Div
	      val (width,height) = Capi.widget_size main
	      val old_yi = !yi_ref
	      val delta = old_yi-new_yi
	    in
	      yi_ref := new_yi;
	      if delta > 0
		then 
		  (Xm.Draw.copyArea (display,window,window,scroll_gc,0,~delta,width,height+delta,0,0);
		   sync_graphics_exposures())
	      else 
		(Xm.Draw.copyArea (display,window,window,scroll_gc,0,0,width,height-delta,0,delta);
		 sync_graphics_exposures())
	    end
	  
	  fun clearit _ =
	    if Xm.Widget.is_realized main
	      then Xm.Draw.clearArea (display,Xm.Widget.window main,0,0,0,0,true)
	    else ()
	      
	  fun do_expose (Xm.Event.EXPOSE_EVENT {common,x,y,width,height,count}) =
	    draw_picture (x,y,width,height)
	    
	  fun expose_handler data =
	    let
	      val event = Xm.Event.convertEvent data
	    in
	      case event of
		Xm.Event.Expose expose_event => do_expose expose_event
	      | Xm.Event.GraphicsExpose expose_event => do_expose expose_event
	      (* Could be a NoExpose event *)
	      | _ => ()
	    end
	  
	  fun resize_callback data = 
	    let
	      val (ww,wh) = Capi.widget_size main
	      val xextent = !xextent_ref
	      val yextent = !yextent_ref
	    in
	      (* motif scrollbars are a little fussy about allowable values *)
	      xi_ref := max (min (!xi_ref,xextent-ww),0);
	      Xm.Widget.valuesSet (hscroll, [(Xm.Value, Xm.INT (!xi_ref)),
					     (Xm.Maximum, Xm.INT xextent),
					     (Xm.SliderSize, Xm.INT (min (ww,xextent)))]);
	      yi_ref := max (min (!yi_ref,yextent-wh),0);
	      Xm.Widget.valuesSet (vscroll, [(Xm.Value, Xm.INT (!yi_ref)),
					     (Xm.Maximum, Xm.INT yextent),
					     (Xm.SliderSize, Xm.INT (min (wh,yextent)))]);
	      
	      clearit ()
	    end
	in
	  Xm.Event.addHandler (main,[Xm.Event.EXPOSURE],true,expose_handler);
	  Xm.Widget.callbackAdd (main,Xm.Callback.Resize,resize_callback);
	  Xm.Widget.callbackAdd (hscroll,Xm.Callback.ValueChanged,horizontal_scroll_callback);
	  Xm.Widget.callbackAdd (vscroll,Xm.Callback.ValueChanged,vertical_scroll_callback);
	  Xm.Widget.callbackAdd (hscroll,Xm.Callback.Drag,horizontal_scroll_callback);
	  Xm.Widget.callbackAdd (vscroll,Xm.Callback.Drag,vertical_scroll_callback);
	  (scroll,set_window_info_ref)
	end
d491 192
d715 1
a715 1
	  Entry.basis2entry (Incremental.type_basis context)
d729 1
a729 1
	
d744 14
a757 32
	  (* These references control which entries are displayed.  *)
	  val show_sigs = ref true
	  val show_funs = ref true
	  val show_strs = ref true
	  val show_types = ref true
	  val show_exns = ref true
	  val show_vars = ref true
	  (* show_conenvs controls whether the bodies of datatypes are
	   displayed inline.  show_cons controls whether constructors
	   are included in the list of values. *)
	  val show_conenvs = ref true
	  val show_cons = ref false
	in
	  fun filter_entries entries = let
	    val isSelected = fn e=>
	      case e of
		Entry.VAR _ => !show_vars
	      | Entry.CONVAR _ => !show_cons
	      | Entry.CONENV _ => true
	      | Entry.EXN _ => !show_exns
	      | Entry.TYPE _ => !show_types
	      | Entry.STR _ => !show_strs
	      | Entry.SIG _ => !show_sigs
	      | Entry.FUN _ => !show_funs
	      | Entry.NSIG _ => !show_sigs
	      | Entry.NSTR _ => !show_strs
	      | Entry.NFUN _ => !show_funs
		  
	  in (* filter_entries *)
	    Lists.filterp isSelected entries
	  end (* filter_entries *)
  
d825 1
a825 1
		
a881 1
	      
d913 22
a934 4
        
        val subwindow =
	  Capi.make_managed_widget
	    ("subwindow", Capi.Paned, frame, [Capi.PanedMargin true])
d936 1
a936 1
        val g2 = 
d938 1
a938 14
            val items = 
              [(0,[1,5,30]),(1,[2,3,4]),(2,[6]),(3,[27,28]),(4,[10,12,13]),(5,[15,16]),(6,[7,9]),(7,[8]),(8,[]),
               (10,[11,20]),(11,[23,24]),(12,[25,26]),(13,[14,27,28]),(14,[17,18]),(15,[]),(16,[]),(17,[]),(18,[19]),
               (20,[21]),(21,[22,29]),(22 ,[25,26]),(23,[27]),(24,[28,29]),(25,[]),(26,[]),(27,[]),(28,[]),
               (30,[31,32,39,40]),(31,[33,34]),(32,[35,36,37,38]),(33,[]),(34,[]),(35,[]),(36,[]),(37,[]),(38,[])]
            fun get_children item =
              let
                fun aux [] = []
                  | aux ((item',children)::rest) =
                    if item = item' then children
                    else aux rest
                      in
                        aux items
              end
d940 3
a942 3
            (0,
             get_children,
             fn n => (20,20))
d945 6
a950 2
        fun int_draw_item (display,window,gc,item,x,y) =
          Xm.Draw.imageString (display,window,gc,x,y,MLWorks.Integer.makestring item);
a951 1
        datatype Node = ROOT | NODE of Entry.Entry
d957 1
d961 1
a961 12
             fn n => (180,20))
          end

        fun entry_draw_item (display,window,gc,item,x,y) =
          let
            val printOptions = get_print_options ()
            val string =
              case item of
                ROOT => "Context"
              | NODE entry => Entry.printEntry printOptions entry
          in
            Xm.Draw.imageString (display,window,gc,x,y+6,string)
d964 1
a964 1
        val (other_window,window_init) = make_toplevel (entry_draw_item,context_graph) (subwindow)
d1001 1
a1001 25
	    val Basis.BasisTypes.BASIS (_,_, Basis.BasisTypes.FUNENV fe,
			                Basis.BasisTypes.SIGENV ge, env) =
	      Incremental.type_basis (context)
	      
	    val (Types.Datatypes.ENV
		 (Types.Datatypes.SE se,
		  Types.Datatypes.TE te,
		  Types.Datatypes.VE (_, ve))) = env
	      
	    val entry_opt=
	      case id
		of Compiler.VALUE i =>
		  MLWorks.Option.NONE
	      |  Compiler.TYPE i =>
		   MLWorks.Option.SOME
		   (Entry.TYPE (i, Types.Datatypes.NewMap.apply' (te, i)))
	      |  Compiler.STRUCTURE i =>
		   MLWorks.Option.SOME
		   (Entry.STR (i, Types.Datatypes.NewMap.apply' (se, i)))
	      |  Compiler.SIGNATURE i =>
		   MLWorks.Option.SOME
		   (Entry.SIG (i, Types.Datatypes.NewMap.apply' (ge, i)))
	      |  Compiler.FUNCTOR i =>
		   MLWorks.Option.SOME
		   (Entry.FUN (i, Types.Datatypes.NewMap.apply' (fe, i)))
d1032 1
a1032 3
	handle Types.Datatypes.NewMap.Undefined =>
	  Crash.impossible "browser tool: select function"
	  
d1276 1
a1276 1
        window_init ()
@


1.59
log
@Minor changes to layout.
@
text
@d4 3
d223 1
a223 1

d243 1
d246 1
a246 1
          Basis.BasisTypes.Datatypes.Ident = IdentPrint.Ident
d248 2
a249 1
          Incremental.Datatypes = Scheme.Datatypes = Valenv.Datatypes
d253 2
a254 1
          IdentPrint.Options = ShellUtils.Options
a278 1

d292 1
a292 18
local
  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
  val sync_graphics_exposures : unit -> unit = env "x sync graphics exposures"

in
  fun max (x:int,y) = if x > y then x else y
  fun min (x:int,y) = if x < y then x else y

    (* Layout utilities *)
    datatype 'a RealLayout = REALLAYOUT of 'a * int * int * 'a RealLayout list

    (* This function lays out items according to their size *)
    fun layout_items (root:'a,
                      get_children :'a -> 'a list,
                      get_size : 'a -> int * int) =
      let
        fun get_height node = 30
        fun get_width node = 80
d294 71
a364 177
        datatype 'a Layout = LAYOUT of 'a * int * int * int * 'a Layout list

        (* lays out children assuming root has position 0,0 *)
        fun layout (root) =
          let
            val children = get_children root
            val (w,h) = get_size root
          in
            case children of
              [] => LAYOUT (root,w,h,h,[])
            | _ =>
                let
                  val subtrees = map layout children
                  fun get_total_height ([],acc) = acc
                    | get_total_height (LAYOUT (node,w,h,totalh,subtrees)::rest,acc) = 
                      get_total_height (rest,totalh + acc)
                  val total_height = get_total_height (subtrees,0)
                in
                  LAYOUT (root,w,h,total_height,subtrees)
                end
          end
        
        fun real_layout (x,y,LAYOUT (root,w,h,th,subtrees)) =
          (* x is the width so far of the tree *)
          (* y is the _top_ of the vertical space allocated *)
          let
            fun dosubtrees ([],y,acc) = rev acc
              | dosubtrees ((tree as LAYOUT (_,w,h,th,_))::rest,y,acc) =
                dosubtrees (rest,y+th,real_layout (x+w,y,tree)::acc)
          in
            REALLAYOUT(root,x,y + (th div 2),dosubtrees (subtrees,y,[]))
          end

        fun dimensions (LAYOUT (_,w,h,th,[])) = (w,th)
          | dimensions (LAYOUT (_,w,h,th,subtrees)) =
            let
              fun do_subtrees ([],max_width,height) = (max_width,height)
                | do_subtrees (subtree::rest,max_width,height) =
                  let
                    val (width,height') = dimensions subtree
                  in
                    do_subtrees (rest,if width > max_width then width else max_width,height+height')
                  end
              val (width,height) = do_subtrees (subtrees,0,0)
            in
              (w + width,height)
            end

        val layout = layout root
        val (xextent,yextent) = dimensions layout
      in
        (real_layout (0,0,layout),xextent,yextent)
      end

fun make_toplevel (draw_item,graph) (parent) =
  let
    (* Make the windows *)
    (* perchance this shouldn't be managed, but then we get a nice effect if it is *)
    val scroll = Capi.make_managed_widget ("drawScroll",Capi.ScrolledWindow,parent,[])

    val frame = Capi.make_managed_widget ("drawFrame",Capi.Frame,scroll,[])

    val main = Capi.make_managed_widget ("drawPane", Capi.Graphics, frame,[])

    val vscroll = Capi.make_managed_widget ("drawVScroll", Capi.VScrollBar,scroll,[])
    val hscroll = Capi.make_managed_widget ("drawHScroll", Capi.HScrollBar,scroll,[])

    val _ = Xm.Widget.valuesSet
      (scroll,
       [(Xm.VerticalScrollBar,Xm.WIDGET vscroll),
        (Xm.HorizontalScrollBar,Xm.WIDGET hscroll),
        (Xm.WorkWindow,Xm.WIDGET frame)])

    val display = Xm.Widget.display main
    val screen = Xm.Widget.screen main

    fun draw_graph (window,gc) (layout,draw_item,offset_x,offset_y) =
      let
        fun do_node (REALLAYOUT (root,x,y,children)) =
          let
            val _ =
              map 
              (fn REALLAYOUT (_,x',y',_) => Xm.Draw.line (display,window,gc,x+offset_x,y+offset_y,x'+offset_x,y'+offset_y))
              children
            val _ = draw_item (display,window,gc,root,x+offset_x,y+offset_y)
          in
            map do_node children;
            ()
          end
      in
        do_node layout
      end

    val window_info_ref = ref MLWorks.Option.NONE
    fun set_window_info_ref () =
      let
        val window = Xm.Widget.window main
        val gc = Xm.GC.create (display,window,[Xm.GC.FOREGROUND (Xm.Pixel.screenBlack screen),
                                               Xm.GC.BACKGROUND (Xm.Pixel.screenWhite screen)])
      in
        window_info_ref := MLWorks.Option.SOME (window,gc)
      end

    val (layout,width,height) = layout_items graph

    (* Scrolling etc. *)
    (*  The extent of the drawing area *)
    val xextent_ref = ref width
    val yextent_ref  = ref height

    (* offset of start of window *)
    val xi_ref = ref 0
    val yi_ref = ref 0

    fun draw_picture (x,y,width,height) =
      case !window_info_ref of
        MLWorks.Option.NONE => ()
      | MLWorks.Option.SOME (w,gc) =>
          let
            val (ww,wh) = Capi.widget_size main
          in
            Xm.GC.setClipRectangles (display,gc,0,0,[(x,y,width,height)],Xm.GC.UNSORTED);
            draw_graph (w,gc) (layout,draw_item,~(!xi_ref),~(!yi_ref))
          end

    (* These need to be a little careful about the way the copy area is done *)
    fun horizontal_scroll_callback data =
      let
        val window = Xm.Widget.window main
        val scroll_gc = Xm.GC.create (display,window,[])
        val new_xi = 
          case Xm.Widget.valuesGet (hscroll,[Xm.Value]) of
            [Xm.INT new_xi] => new_xi
          | _ => raise Div
        val (width,height) = Capi.widget_size main
        val old_xi = !xi_ref
        val delta = old_xi-new_xi
      in
        xi_ref := new_xi;
        if delta > 0
          then 
            (Xm.Draw.copyArea (display,window,window,scroll_gc,~delta,0,width,height,0,0);
             sync_graphics_exposures())
        else 
          (Xm.Draw.copyArea (display,window,window,scroll_gc,~delta,0,width,height,0,0);
           sync_graphics_exposures())
      end

    fun vertical_scroll_callback data =
      let
        val window = Xm.Widget.window main
        val scroll_gc = Xm.GC.create (display,window,[])
        val new_yi = 
          case Xm.Widget.valuesGet (vscroll,[Xm.Value]) of
            [Xm.INT new_yi] => new_yi
          | _ => raise Div
        val (width,height) = Capi.widget_size main
        val old_yi = !yi_ref
        val delta = old_yi-new_yi
      in
        yi_ref := new_yi;
        if delta > 0
          then 
            (Xm.Draw.copyArea (display,window,window,scroll_gc,0,~delta,width,height+delta,0,0);
             sync_graphics_exposures())
        else 
          (Xm.Draw.copyArea (display,window,window,scroll_gc,0,0,width,height-delta,0,delta);
           sync_graphics_exposures())
      end

    fun clearit _ =
      if Xm.Widget.is_realized main
        then Xm.Draw.clearArea (display,Xm.Widget.window main,0,0,0,0,true)
      else ()

    fun do_expose (Xm.Event.EXPOSE_EVENT {common,x,y,width,height,count}) =
      draw_picture (x,y,width,height)
d366 134
a499 188
    fun expose_handler data =
      let
        val event = Xm.Event.convertEvent data
      in
        case event of
          Xm.Event.Expose expose_event => do_expose expose_event
        | Xm.Event.GraphicsExpose expose_event => do_expose expose_event
        (* Could be a NoExpose event *)
        | _ => ()
      end

    fun resize_callback data = 
      let
        val (ww,wh) = Capi.widget_size main
        val xextent = !xextent_ref
        val yextent = !yextent_ref
      in
        (* motif scrollbars are a little fussy about allowable values *)
        xi_ref := max (min (!xi_ref,xextent-ww),0);
        Xm.Widget.valuesSet (hscroll, [(Xm.Value, Xm.INT (!xi_ref)),
                                       (Xm.Maximum, Xm.INT xextent),
                                       (Xm.SliderSize, Xm.INT (min (ww,xextent)))]);
        yi_ref := max (min (!yi_ref,yextent-wh),0);
        Xm.Widget.valuesSet (vscroll, [(Xm.Value, Xm.INT (!yi_ref)),
                                       (Xm.Maximum, Xm.INT yextent),
                                       (Xm.SliderSize, Xm.INT (min (wh,yextent)))]);

        clearit ()
      end
  in
    Xm.Event.addHandler (main,[Xm.Event.EXPOSURE],true,expose_handler);
    Xm.Widget.callbackAdd (main,Xm.Callback.Resize,resize_callback);
    Xm.Widget.callbackAdd (hscroll,Xm.Callback.ValueChanged,horizontal_scroll_callback);
    Xm.Widget.callbackAdd (vscroll,Xm.Callback.ValueChanged,vertical_scroll_callback);
    Xm.Widget.callbackAdd (hscroll,Xm.Callback.Drag,horizontal_scroll_callback);
    Xm.Widget.callbackAdd (vscroll,Xm.Callback.Drag,vertical_scroll_callback);
    (scroll,set_window_info_ref)
  end
end

(* foo *)
    datatype Entry =
      VAR of Ident.ValId * Types.Datatypes.Typescheme
    | CONVAR of Ident.ValId * Types.Datatypes.Typescheme
      (* Constructor in a structure or at top-level *)
    | CONENV of Ident.ValId * Types.Datatypes.Typescheme
      (* Constructor in a constructor environment *)
    | EXN of Ident.ValId * Types.Datatypes.Typescheme
    | TYPE of Ident.TyCon * Types.Datatypes.Tystr
    | STR of Ident.StrId * Types.Datatypes.Structure
    | SIG of Ident.SigId * Basis.BasisTypes.Sigma
    | FUN of Ident.FunId * Basis.BasisTypes.Phi
     
    (* get_id returns the string to print, and a boolean that indicates
       whether this is the last component of a name. *)
    fun get_id (VAR (id, _)) =
      (IdentPrint.printValId Options.default_print_options id, true)
    |   get_id (CONVAR (id, _)) =
      (IdentPrint.printValId Options.default_print_options id, true)
    |   get_id (CONENV (id, _)) =
      (IdentPrint.printValId Options.default_print_options id, true)
    |   get_id (EXN (id, _)) =
      (IdentPrint.printValId Options.default_print_options id, true)
    |   get_id (TYPE (id, _)) = (IdentPrint.printTyCon id ^ "<type>", true)
    |   get_id (STR (id, _)) = (IdentPrint.printStrId id, false)
    |   get_id (SIG (id, _)) = (IdentPrint.printSigId id ^ "<signature>", false)
    |   get_id (FUN (id, _)) = (IdentPrint.printFunId id ^ "<functor>", true)

    fun printOverloaded (Types.Datatypes.UNARY (_, tyvar)) =
	  let val olvar = IdentPrint.printTyVar tyvar
	  in
	    implode [olvar, " -> ", olvar]
	  end
    |   printOverloaded (Types.Datatypes.BINARY (_, tyvar)) =
	  let val olvar = IdentPrint.printTyVar tyvar
	  in
	    implode [olvar, " * ", olvar, " -> ", olvar]
	  end
    |   printOverloaded (Types.Datatypes.PREDICATE (_, tyvar)) =
	  let val olvar = IdentPrint.printTyVar tyvar
	  in
	    implode [olvar, " * ", olvar, " -> bool"]
	  end

    fun printConScheme print_options (Types.Datatypes.SCHEME (arity, (ty,_))) =
	  (case Types.apply (Types.Datatypes.TYFUN (ty, arity),
			     Types.make_tyvars arity) of
	     Types.Datatypes.FUNTYPE (arg, _) =>
               " of " ^ Types.print_type print_options arg
	   | _ => "")
    |   printConScheme print_options (Types.Datatypes.UNBOUND_SCHEME
		          	        (Types.Datatypes.FUNTYPE (arg, _),_)) =
          " of " ^ Types.print_type print_options arg
    |   printConScheme _ (Types.Datatypes.UNBOUND_SCHEME _) =
	  ""
    |   printConScheme _ (Types.Datatypes.OVERLOADED_SCHEME _) =
          " <strange overloaded scheme>"

    fun printValenv print_options (Types.Datatypes.VE (_,amap)) =
	  let fun printMember ((first, str), valid, typescheme) =
		(false,
		 implode
		   [str,
	    	    if first then "" else " | ",
	    	    IdentPrint.printValId print_options valid,
		    printConScheme print_options typescheme])
	  in
	    Types.Datatypes.NewMap.fold printMember ((true, ""), amap)
	  end

    fun printValScheme print_options (Types.Datatypes.SCHEME (arity, (ty,_))) =
	  Types.print_type print_options ty
    |   printValScheme print_options (Types.Datatypes.UNBOUND_SCHEME (ty,_)) =
	  Types.print_type print_options ty
    |   printValScheme _ (Types.Datatypes.OVERLOADED_SCHEME overloaded) =
	  printOverloaded overloaded

    fun print_tyvars n = Types.print_tyvars (Types.make_tyvars n)

    fun printTyFun (tycon, Types.Datatypes.TYFUN (ty, arity)) =
          print_tyvars arity ^ " " ^ IdentPrint.printTyCon tycon
    |   printTyFun (tycon, Types.Datatypes.ETA_TYFUN tyname) =
          print_tyvars (case tyname of
                          Types.Datatypes.TYNAME (_, _, n, _, _,_,_,_) => n
                        | Types.Datatypes.METATYNAME (_, _, n, _, _, _) => n) ^
	    " " ^ IdentPrint.printTyCon tycon
    |   printTyFun (tycon, Types.Datatypes.NULL_TYFUN (id,_)) =
        MLWorks.Integer.makestring (Types.stamp_num id)

    fun printEntry print_options (VAR (id, ts)) =
	  "val " ^ IdentPrint.printValId print_options id ^ " : " ^
	    printValScheme print_options ts
    |   printEntry print_options (CONVAR (id, ts)) =
	  "con " ^ IdentPrint.printValId print_options id ^ " : " ^
	    printValScheme print_options ts
    |   printEntry print_options (CONENV (id, ts)) =
	  "con " ^ IdentPrint.printValId print_options id ^ " : " ^
	    printValScheme print_options ts
    |   printEntry print_options (EXN (id, ts)) =
	  "exception " ^ IdentPrint.printValId print_options id ^
	    printConScheme print_options ts
    |   printEntry print_options
		   (TYPE (id, Types.Datatypes.TYSTR (tyfun, valenv))) =
	  if Valenv.empty_valenvp valenv then
	    if Types.equalityp tyfun then
	      "eqtype " ^ printTyFun (id, tyfun)
	    else
	      "type " ^ printTyFun (id, tyfun)
	  else
	    "datatype " ^ printTyFun (id, tyfun) ^ " = " ^
	      #2(printValenv print_options valenv)
    |   printEntry _ (STR (id, str)) =
	  "structure " ^ IdentPrint.printStrId id
    |   printEntry _ (SIG (id, sigma)) =
	  "signature " ^ IdentPrint.printSigId id
    |   printEntry _ (FUN (id, ts)) =
	  "functor " ^ IdentPrint.printFunId id

    fun browse_conenv (Types.Datatypes.VE (_, ve)) =
	  let val vallist = Types.Datatypes.NewMap.to_list_ordered ve
	  in map (fn (id, ts) => CONENV (id, ts)) vallist
	  end

    fun split_vallist ([], vars, exns) = (rev vars, rev exns)
    |   split_vallist ((pair as (Ident.VAR _, _)) :: l, vars, exns) =
	  split_vallist (l, VAR pair :: vars, exns)
    |   split_vallist ((pair as (Ident.CON _, _)) :: l, vars, exns) =
	  split_vallist (l, CONVAR pair :: vars, exns)
    |   split_vallist ((pair as (Ident.EXCON _, _)) :: l, vars, exns) =
	  split_vallist (l, vars, EXN pair :: exns)
    |   split_vallist _ = Crash.impossible "TYCON':split_vallist:browser_tool"

    fun browse_env
	  (Types.Datatypes.ENV
	     (Types.Datatypes.SE se,
	      Types.Datatypes.TE te,
	      Types.Datatypes.VE (_, ve))) =
      let
	val strlist = Types.Datatypes.NewMap.to_list_ordered se
        val tylist = Types.Datatypes.NewMap.to_list_ordered te
        val vallist = Types.Datatypes.NewMap.to_list_ordered ve

        val strlist' = map STR strlist
        val tylist' = map TYPE tylist
        val (varlist, exnlist) = split_vallist (vallist, [], [])
      in
        strlist' @@ tylist' @@ exnlist @@ varlist
      end
d501 28
a528 8

    fun browse_str (Types.Datatypes.STR (_, _, env)) =
      browse_env env
    |   browse_str (Types.Datatypes.COPYSTR (_, str)) =
      browse_str str

    fun browse_sigma (Basis.BasisTypes.SIGMA (_, str)) =
      browse_str str
d532 1
d534 1
a534 1
		  {args,appdata,current_context,motif_context,tools}) =
d548 8
a555 9
        val title =
	  let
            val n = !browser_number
            fun p (s, 0) = s
              | p (s, n) = p (chr (48+(n mod 10)) ^ s, n div 10)
          in
            browser_number := n+1;
              "Context Browser #" ^ p ("", n)
          end
d557 7
a570 1
	val local_context = ref motif_context
d590 1
a590 1
	  (* These references control which entries are displayed. *)
d598 2
a599 2
	     displayed inline.  show_cons controls whether constructors
	     are included in the list of values. *)
d602 19
a620 20
  	in
          fun filter_entries [] = []
          |   filter_entries (entry::entries) =
            let
	      val is_selected =
	        case entry
                of VAR _ => !show_vars
                |  CONVAR _ => !show_cons
                |  CONENV _ => true
                |  EXN _ => !show_exns
                |  TYPE _ => !show_types
                |  STR _ => !show_strs
                |  SIG _ => !show_sigs
                |  FUN _ => !show_funs
            in
	      if is_selected then
	        entry :: filter_entries entries
	      else
	        filter_entries entries
            end
d624 5
a628 14
  
          fun browse_entry (VAR _) = []
          |   browse_entry (CONVAR _) = []
          |   browse_entry (CONENV _) = []
          |   browse_entry (EXN _) = []
          |   browse_entry (TYPE (id, Types.Datatypes.TYSTR (_, conenv))) =
            if not (!show_conenvs) (* Valenv.empty_valenvp conenv *) then
	      []
            else
	      browse_conenv conenv
          |   browse_entry (STR (_, str)) = browse_str str
          |   browse_entry (SIG (_, sigma)) = browse_sigma sigma
          |   browse_entry (FUN (_, Basis.BasisTypes.PHI (_, (str, sigma)))) =
            browse_sigma sigma
d630 62
a691 2
	  val filter_spec =
	    [Menus.OPTTOGGLE ("show_sigs",
d694 23
a716 40
	     Menus.OPTTOGGLE ("show_funs",
			      fn () => !show_funs,
			      fn b => show_funs := b),
	     Menus.OPTTOGGLE ("show_strs",
			      fn () => !show_strs,
			      fn b => show_strs := b),
	     Menus.OPTTOGGLE ("show_types",
			      fn () => !show_types,
			      fn b => show_types := b),
	     Menus.OPTTOGGLE ("show_conenvs",
			      fn () => !show_conenvs,
			      fn b => show_conenvs := b),
	     Menus.OPTTOGGLE ("show_exns",
			      fn () => !show_exns,
			      fn b => show_exns := b),
	     Menus.OPTTOGGLE ("show_cons",
			      fn () => !show_cons,
			      fn b => show_cons := b),
	     Menus.OPTTOGGLE ("show_vars",
			      fn () => !show_vars,
			      fn b => show_vars := b)]
	end

	fun get_items_from_context () =
	  let
            val context =
	     #2 (UserContext.get_context_info
		   (MotifUtils.get_user_context (!local_context)))
	    val Basis.BasisTypes.BASIS (_,_, Basis.BasisTypes.FUNENV fe,
			                Basis.BasisTypes.SIGENV se, env) =
	      Incremental.type_basis (context)
	    val siglist = Types.Datatypes.NewMap.to_list_ordered se
	    val funlist = Types.Datatypes.NewMap.to_list_ordered fe
	    val funlist' = map (fn (id, phi) => FUN (id, phi)) funlist
	    val siglist' = map (fn (id, sigma) => SIG (id, sigma)) siglist
	    val envlist = browse_env env
	  in
	    siglist' @@ funlist' @@ envlist
	  end

d719 1
a719 1
	   the parent structure *)
d723 1
a723 3

	fun get_user_options () = user_options

d729 5
a733 5
	|   add_to_path (str, new_items, true) =
	  (* datatypes - display of entries overwrites the type name itself *)
	  (pathStack := (!pathLength, str, new_items) :: (!pathStack);
	   pathStr := !pathStr ^ str)

a737 3
	fun get_print_options () =
	  UserOptions.new_print_options (get_user_options ())

d739 1
a739 1

d742 1
a742 1
	    val (str, last_component) = get_id entry
d746 2
a747 2

            val new_items = browse_entry entry
d750 2
a751 2
	       If last_component is true, the selection is the last component
	       of a long id, and so the path in the selection box should not
d755 1
a755 1

d765 2
a766 2

	    (* Push the stacks and display the components of the
d778 1
a778 1

d808 1
a808 1
        datatype Node = ROOT | NODE of Entry
d811 1
a811 1
            val items = map NODE (get_items_from_context ())
d813 1
a813 1
              | get_children (NODE entry) = map NODE (browse_entry entry)
d826 1
a826 1
              | NODE entry => printEntry printOptions entry
d839 1
a839 1
	     action_fn = fn _ => fn _ => (), print_fn = printEntry}
d856 1
a856 2
	   nil case. *)
	val set_items = map_selected set_items'
d858 8
d871 1
a871 1

d873 4
a876 4
	           (Types.Datatypes.SE se,
	            Types.Datatypes.TE te,
	            Types.Datatypes.VE (_, ve))) = env

d879 2
a880 2
	      of Compiler.VALUE i =>
		MLWorks.Option.NONE
d882 2
a883 2
	        MLWorks.Option.SOME
		  (TYPE (i, Types.Datatypes.NewMap.apply' (te, i)))
d885 2
a886 2
	        MLWorks.Option.SOME
		  (STR (i, Types.Datatypes.NewMap.apply' (se, i)))
d888 2
a889 2
	        MLWorks.Option.SOME
		  (SIG (i, Types.Datatypes.NewMap.apply' (ge, i)))
d891 2
a892 2
	        MLWorks.Option.SOME
		  (FUN (i, Types.Datatypes.NewMap.apply' (fe, i)))
d895 1
a895 1
	    of MLWorks.Option.NONE => ()
d898 2
a899 2
		val (str, last_component) = get_id entry
		val new_items = browse_entry entry
d923 3
a925 3
	  handle Types.Datatypes.NewMap.Undefined =>
	    Crash.impossible "browser tool: select function"

d928 5
a932 4
		 (MotifUtils.get_user_context (!local_context), user_options)
	  of MLWorks.Option.NONE => ()
	  |  MLWorks.Option.SOME entry => select entry

d941 2
a942 2
	   of (_, _, new_items) :: _ =>
	     set_items (get_print_options ()) new_items
d944 2
a945 2
	     set_items (get_print_options ()) (get_items_from_context ()))

d950 1
a950 1

d955 1
a955 1

d973 1
a973 1
	  
d976 2
a977 2
	  of (_, _, items) :: _ =>
	    set_items (get_print_options ()) items
d979 1
a979 1
	    (* We could store the current toplevel items in a reference,
d983 16
a998 7
	    set_items (get_print_options ()) (get_items_from_context ())

	val filter_popup =
	  #1 (Menus.create_dialog
		(shell, "Context Browser Settings", "browserDialog",
		 redisplay, filter_spec))

d1000 1
a1000 1

d1003 1
a1003 1
	     Users can't update existing substructures. *)
d1007 1
a1007 1

d1009 1
a1009 1

d1011 1
a1011 1

d1013 1
a1013 1
	   to the context are reflected in the browser. *)
d1016 1
a1016 1
		 (MotifUtils.get_user_context (!local_context), update));
d1020 2
a1021 2
		 (MotifUtils.get_user_context (!local_context),
		  (select, get_user_options)))
d1051 2
a1052 2
	    (current_context, (set_context, get_user_options, ToolData.ALL))

d1055 12
a1066 12
	    (fn _ =>
	       let
		 val user_context = MotifUtils.get_user_context (!local_context)
	       in
		 UserContext.remove_update_fn
	      	   (user_context, !update_fn_key);
	         UserContext.remove_select_fn
		   (user_context, !select_fn_key);
	         ToolData.remove_context_fn
		   (current_context, context_key)
	       end)
	    :: !quit_funs
d1071 1
a1071 1
             (current_context, context_key, user_options, user_context))
d1107 1
a1107 1
             @@ [Menus.PUSH ("filter", fn _ => filter_popup (), fn _ => true)],
d1133 8
@


1.58
log
@Adding graphing functionality
@
text
@d4 3
d897 4
a900 1
        val subwindow = Capi.make_managed_widget ("subwindow", Capi.Pane, frame, [])
d1250 2
a1251 2
            MLWorks.Option.SOME w => [Capi.Layout.OTHER w,Capi.Layout.SPACE]
          | _ => []) @@
d1256 1
a1256 1
          Capi.Layout.OTHER subwindow,
@


1.57
log
@Made value constructors be displayed with the "con" pseudo-keyword.
@
text
@d4 3
d208 1
d222 1
d245 1
a245 1
          IdentPrint.Options = MotifUtils.Options = ShellUtils.Options
d254 2
a255 1
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget = ToolData.Widget
d284 236
d521 1
d706 2
a707 47
        val shell =
          Xm.Widget.create (Xm.Widget.NAME "browserShell",
                            Xm.Widget.Class.TopLevelShell,
                            applicationShell,
                            [(Xm.Title, Xm.STRING title),
                             (Xm.IconName, Xm.STRING title)])

        val frame = Xm.Widget.createManaged (Xm.Widget.NAME "browserFrame",
                                             Xm.Widget.Class.Form,
                                             shell,
                                             [])
        val menuBar = Xm.Widget.createManaged (Xm.Widget.NAME "menuBar",
                                               Xm.Widget.Class.RowColumn,
                                               frame,[])
        val contextLabel =
	  if full_menus then
	    MLWorks.Option.SOME
	      (Xm.Widget.createManaged
		 (Xm.Widget.NAME "contextLabel",
		  Xm.Widget.Class.Label, frame,[]))
	  else
	    MLWorks.Option.NONE

	val listLabel = Xm.Widget.createManaged (Xm.Widget.NAME "listLabel",
					         Xm.Widget.Class.LabelGadget,
					         frame,[])
	val pathLabel = Xm.Widget.createManaged (Xm.Widget.NAME "pathLabel",
					         Xm.Widget.Class.LabelGadget,
					         frame,[])
	val pathText = Xm.Widget.createManaged (Xm.Widget.NAME "pathText",
						Xm.Widget.Class.Text, 
						frame,[])

        val buttonPane =
          Xm.Widget.createManaged
            (Xm.Widget.NAME "buttonPane", Xm.Widget.Class.RowColumn,
             frame, []);

        val parentButton =
          Xm.Widget.createManaged
            (Xm.Widget.NAME "parentButton", Xm.Widget.Class.PushButton,
             buttonPane, [])

        val toplevelButton =
          Xm.Widget.createManaged
            (Xm.Widget.NAME "toplevelButton", Xm.Widget.Class.PushButton,
             buttonPane, [])
d709 4
d726 1
a726 2
              val cstring =
	        Xm.CompoundString.createSimple("Context: " ^ context_name)
d728 1
a728 3
              Xm.Widget.valuesSet (w,
                                   [(Xm.LabelString, 
                                     Xm.COMPOUNDSTRING cstring)])
a814 1

a817 1

a818 1

a819 1

a820 1

a821 1

d847 1
a847 1
	  (Xm.Text.replace (pathText, pos, !pathLength, "");
d872 1
a872 1
	    Xm.Text.replace
d894 54
d949 2
a950 2
	  MotifUtils.make_scrolllist 
	    {parent = frame, name = "contextBrowser", select_fn = select_fn,
d953 14
d1012 1
a1012 1
                  (Xm.Text.replace (pathText, 0, !pathLength, str);
d1038 1
a1038 1
	  (Xm.Text.replace (pathText, 0,
d1058 1
a1058 2
	   Xm.Widget.processTraversal (list, Xm.Widget.TRAVERSE_CURRENT);
	   ())
d1068 3
a1070 3
	       Xm.Text.replace (pathText, 0,
				!pathLength + !length_of_last_component,
				!pathStr);
d1074 1
a1074 2
	       Xm.Widget.processTraversal (list, Xm.Widget.TRAVERSE_CURRENT);
	       ())
d1076 1
a1076 2
	      (Xm.Widget.processTraversal (list, Xm.Widget.TRAVERSE_CURRENT);
	       ())
d1170 1
a1170 1
           Xm.Widget.destroy shell)
d1186 1
a1186 1
        fun get_string_nm () = Xm.Text.getString pathText
d1206 47
a1252 95
	  (menuBar,
           [ToolData.works_menu
	      (mk_tooldata, close_window, fn () => true,
	       fn () => MotifUtils.get_user_context (!local_context)),
	    view_menu,
	    MotifUtils.value_menu_strfun
	      (shell, MotifUtils.get_user_context (!local_context),
	       user_options, user_preferences, get_string_nm),
	    MotifUtils.context_menu
	      {set_state = select_context,
	       get_context = fn () => !local_context,
	       writable = MotifUtils.ALL,
	       applicationShell = applicationShell,
	       user_preferences = user_preferences},
            Menus.DYNAMIC
	      ("history",
	       fn () =>
	         map
	           (fn (s,i) =>
                      Menus.PUSH (s, fn _ => do_history (s,i), fn _ => true))
                   (!history),
               fn _ => true)]);

        Xm.Widget.valuesSet
	  (menuBar,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
	case contextLabel
	of MLWorks.Option.SOME w =>
          Xm.Widget.valuesSet
	    (w,
             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
              (Xm.TopWidget, Xm.WIDGET menuBar),
              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.LeftOffset, Xm.INT sep_size),
              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
              (Xm.RightOffset, Xm.INT sep_size),
              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)])
	|  MLWorks.Option.NONE => ();
        Xm.Widget.valuesSet
	  (pathLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget,
	     case contextLabel
	     of MLWorks.Option.SOME w => Xm.WIDGET w
	     |  MLWorks.Option.NONE => Xm.WIDGET menuBar),
            (Xm.TopOffset, Xm.INT sep_size),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (pathText,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET pathLabel),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (buttonPane,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET pathText),
            (Xm.TopOffset, Xm.INT sep_size),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (listLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET buttonPane),
            (Xm.TopOffset, Xm.INT sep_size),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (scroll,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET listLabel),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.BottomOffset, Xm.INT sep_size)]);
	Xm.Widget.callbackAdd
	  (frame, Xm.Callback.Destroy, do_quit_funs);
d1254 3
a1256 4
        Xm.Widget.callbackAdd (parentButton, Xm.Callback.Activate, pop_history);
        Xm.Widget.callbackAdd (toplevelButton, Xm.Callback.Activate, toplevel);
        Xm.Widget.manage shell;
        Xm.Widget.realize shell
@


1.56
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d4 3
d371 1
a371 1
	  "val " ^ IdentPrint.printValId print_options id ^ " : " ^
d374 1
a374 1
	  "val " ^ IdentPrint.printValId print_options id ^ " : " ^
@


1.55
log
@Made contexts only visible if full_menus set.
@
text
@d4 3
d204 1
d220 1
d241 4
a244 2
  sharing type UserOptions.user_options = ToolData.ShellTypes.user_options =
	       MotifUtils.UserOptions = ShellUtils.UserOptions
d252 7
d271 1
a271 1
    type UserOptions = UserOptions.user_options
d436 1
a436 1
		  {args,appdata,current_context,tools}) =
d439 3
a441 1
	      {user_options, user_context, mk_xinterface_fn, prompter} = args
d445 4
a448 4
	val (full_menus, update_fns) =
	  case user_options
	  of UserOptions.USER_OPTIONS ({full_menus, ...}, update_fns) =>
	    (!full_menus, update_fns)
d508 1
a508 1
	val local_context = ref user_context
d510 3
a512 1
	fun get_context () = UserContext.get_context (!local_context)
d514 1
a514 1
        fun set_context_label user_context =
d519 1
a519 1
	        UserContext.get_context_name user_context
d611 2
a612 1
	     #2 (UserContext.get_context_info (!local_context))
d655 1
a655 2
	  case UserOptions.new_options (get_user_options ()) of
	    Options.OPTIONS{print_options,...} => print_options
d694 1
a694 1
                  (fn ((s,_),(s',_))=>s=s'), get_user_options());
d760 1
a760 1
                      (fn ((s,_),(s',_))=>s=s'), get_user_options());
d769 1
a769 1
		 (!local_context, user_options)
d849 2
a850 1
	  ref (UserContext.add_update_fn (!local_context, update));
d854 2
a855 1
		 (!local_context, (select, get_user_options)))
d858 24
a881 17
	  (UserContext.remove_update_fn
	     (!local_context, !update_fn_key);
	   UserContext.remove_select_fn
	     (!local_context, !select_fn_key);
	   local_context := c;
	   set_context_label c;
	   update_fn_key := UserContext.add_update_fn (c, update);
	   select_fn_key :=
	     UserContext.add_select_fn (c, (select, get_user_options));
	   (* Delete the history.  If you don't do this, then if users select
	      an entry in another context and move through its parents until
	      they reach the top level, they will be surprised when the
	      browser shows the top level of the current context.  The only
	      sane alternative to deleting the history is to add context
	      information to each entry on the history. *)
	   history := [];
	   toplevel ())
d889 11
a899 6
	    (fn _ => UserContext.remove_update_fn
	      	       (!local_context, !update_fn_key))
	    :: (fn _ => UserContext.remove_select_fn
			  (!local_context, !select_fn_key))
	    :: (fn _ => ToolData.remove_context_fn
			  (current_context, context_key))
a906 1

a910 5
        val (options_menu, update_options) =
	  MotifUtils.options_menu (shell, title, get_user_options, sense_select)

        val _ = update_fns := update_options :: (!update_fns)

d915 3
a917 1
                       user_context = !local_context,
d922 1
d929 14
a942 14
	val menus_tail =
	  [options_menu,
	   Menus.CASCADE
	     ("view",
	      [Menus.PUSH ("filter", filter_popup, fn _ => true)],
	      fn _ => true),
           Menus.DYNAMIC
	     ("history",
	      fn () =>
	        map
	          (fn (s,i) =>
                     Menus.PUSH (s, fn _ => do_history (s,i), fn _ => true))
                  (!history),
              fn _ => true)]
d946 22
a967 11
           ToolData.works_menu
	     (mk_tooldata, close_window,
	      fn () => true, fn () => !local_context)
	   :: MotifUtils.value_menu_strfun
	        (shell, !local_context, user_options, get_string_nm)
	   :: (if full_menus then
		 MotifUtils.context_menu
	           (select_context, fn _ => !local_context, MotifUtils.ALL)
		 :: menus_tail
	       else
		 menus_tail));
d1040 1
a1040 1
        set_context_label(!local_context);
d1050 3
a1052 2
		{user_context, user_options, prompter, mk_xinterface_fn},
	      appdata,current_context,tools}) =
d1054 1
a1054 1
	val initial = UserContext.getInitialContext ()
d1057 1
a1057 1
	of UserOptions.USER_OPTIONS
d1069 2
a1070 1
		  {user_context = initial,
d1075 2
a1076 2
	      current_context =
	        ToolData.make_current (UserContext.getInitialContext ()),
@


1.54
log
@Added create_initial.
@
text
@d4 3
d429 5
d435 1
a435 1
          let
d458 9
a466 3
        val contextLabel = Xm.Widget.createManaged (Xm.Widget.NAME "contextLabel",
                                                    Xm.Widget.Class.Label,
                                                    frame,[])
d497 5
a501 3
          let
            val context_name =
	      UserContext.get_context_name user_context
d503 8
a510 7
            val cstring =
	      Xm.CompoundString.createSimple("Context: " ^ context_name)
          in
            Xm.Widget.valuesSet (contextLabel,
                                 [(Xm.LabelString, 
                                   Xm.COMPOUNDSTRING cstring)])
          end
a882 2
        val UserOptions.USER_OPTIONS(_, update_fns) = user_options

d899 15
d915 13
d934 12
a945 9
        Xm.Widget.valuesSet
	  (contextLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.LeftOffset, Xm.INT sep_size),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
            (Xm.RightOffset, Xm.INT sep_size),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
d949 4
a952 1
            (Xm.TopWidget, Xm.WIDGET contextLabel),
a999 22
        Menus.make_submenus
	  (menuBar,
           [ToolData.works_menu
	      (mk_tooldata, close_window,
	       fn () => true, fn () => !local_context),
	    MotifUtils.value_menu_strfun
	      (shell, !local_context, user_options, get_string_nm),
	    MotifUtils.context_menu
	      (select_context, fn _ => !local_context, MotifUtils.ALL),
	    options_menu,
	    Menus.CASCADE
	      ("view",
	       [Menus.PUSH ("filter", filter_popup, fn _ => true)],
	       fn _ => true),
            Menus.DYNAMIC (
	      "history",
	      fn () =>
		map
		  (fn (s,i) =>
                     Menus.PUSH (s, fn _ => do_history (s,i), fn _ => true))
                  (!history),
              fn _ => true)]);
@


1.53
log
@Changing createPopupShell to create
@
text
@d4 3
d980 30
@


1.52
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d4 3
d434 5
a438 5
          Xm.Widget.createPopupShell (Xm.Widget.NAME "browserShell",
                                      Xm.Widget.Class.TopLevelShell,
                                      applicationShell,
                                      [(Xm.Title, Xm.STRING title),
                                       (Xm.IconName, Xm.STRING title)])
@


1.51
log
@A new tool is now passed the right user context.
@
text
@d4 3
d217 1
a217 2
    Basis.BasisTypes.Datatypes.Ident =
    IdentPrint.Ident
d219 1
a219 1
    Incremental.Datatypes = Scheme.Datatypes = Valenv.Datatypes
d221 3
a223 3
    Incremental.InterMake.Compiler.Options = ToolData.ShellTypes.Options = 
    IdentPrint.Options = MotifUtils.Options = ShellUtils.Options
  sharing ToolData.ShellTypes.Info = ShellUtils.Info
d225 1
a225 1
  sharing type ToolData.ShellTypes.identifier =
d229 1
a229 2
  sharing type Basis.BasisTypes.Datatypes.Type =
	       ShellUtils.Type
a235 1
  sharing type ToolData.ShellTypes.IncrementalOptions = Incremental.options
d239 1
d474 1
a474 1
	fun get_context () = ToolData.ShellTypes.get_context (!local_context)
d479 1
a479 1
	      ToolData.ShellTypes.get_context_name user_context
d570 1
a570 1
	     #2 (ToolData.ShellTypes.get_context_info (!local_context))
d666 1
a666 1
	fun select (ToolData.ShellTypes.ITEM (_, id, context, _, _)) =
d727 1
a727 1
	  case ToolData.ShellTypes.get_selected
d808 1
a808 1
	  ref (ToolData.ShellTypes.add_update_fn (!local_context, update));
d811 1
a811 1
	  ref (ToolData.ShellTypes.add_select_fn
d815 1
a815 1
	  (ToolData.ShellTypes.remove_update_fn
d817 1
a817 1
	   ToolData.ShellTypes.remove_select_fn
d821 1
a821 1
	   update_fn_key := ToolData.ShellTypes.add_update_fn (c, update);
d823 1
a823 1
	     ToolData.ShellTypes.add_select_fn (c, (select, get_user_options));
d839 1
a839 1
	    (fn _ => ToolData.ShellTypes.remove_update_fn
d841 1
a841 1
	    :: (fn _ => ToolData.ShellTypes.remove_select_fn
@


1.50
log
@Changes to context_menu.
@
text
@d867 1
a867 1
                       user_context = user_context,
@


1.49
log
@Replacing Tyfun_id etc. with Stamp
@
text
@d4 3
d478 1
a478 1
	      ToolData.ShellTypes.context_name user_context
d951 2
a952 1
	    MotifUtils.context_menu (select_context, MotifUtils.ALL),
@


1.48
log
@Added the history number to items in the history.
@
text
@d4 3
d335 1
a335 1
          Types.Datatypes.Tyfun_id.string_tyfun_id id
@


1.47
log
@Empty lists are now handled automatically by MotifUtils.make_scrolllist.
@
text
@d4 3
d659 1
a659 1
	fun select (ToolData.ShellTypes.ITEM (id, context, _, _)) =
@


1.46
log
@Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
@
text
@d4 3
a253 1
    | EMPTY	(* dummy entry for empty structures, etc. *)
a268 1
    |   get_id (EMPTY) = ("", true)
a358 2
    |   printEntry _ EMPTY =
	  "<empty>"
a501 1
                |  EMPTY => true
d514 1
a514 3
	    case filter_entries l
	    of [] => f print_options [EMPTY]
	    |  l  => f print_options l
a519 1
          |   browse_entry EMPTY = []
@


1.45
log
@Removed context_function from register when closing the window.
@
text
@d4 3
d470 1
a470 4
	      ToolData.ShellTypes.get_context_name user_context

            val context_string =
	      ToolData.ShellTypes.string_context_name context_name
d473 1
a473 1
	      Xm.CompoundString.createSimple("Context: " ^ context_string)
d830 1
a830 1
	    (current_context, (set_context, get_user_options))
d943 2
a944 1
	      (mk_tooldata, close_window, fn () => true),
d947 1
a947 1
	    MotifUtils.context_menu select_context,
@


1.44
log
@Changed to share current context with other tools..
@
text
@d4 3
d796 4
d832 10
d847 5
d939 1
a939 3
	  (frame, Xm.Callback.Destroy,
	   fn _ => ToolData.ShellTypes.remove_update_fn
		     (!local_context, !update_fn_key));
d943 1
a943 1
	      (mk_tooldata, fn () => Xm.Widget.destroy shell, fn () => true),
@


1.43
log
@Registered select function with current context.
Also simplified manipulation of pathStack slightly - no need to store
toplevel items on the stack, as they're always calculated anew.
@
text
@d4 5
d397 2
a398 1
    fun create (tooldata as ToolData.TOOLDATA {args,appdata,tools}) =
d457 3
a459 1
	val current_context = ref user_context
d562 1
a562 1
	     #2 (ToolData.ShellTypes.get_context_info (!current_context))
d720 1
a720 1
		 (!current_context, user_options)
d796 1
a796 1
	  ref (ToolData.ShellTypes.add_update_fn (!current_context, update));
d800 1
a800 1
		 (!current_context, (select, get_user_options)))
d804 1
a804 1
	     (!current_context, !update_fn_key);
d806 2
a807 2
	     (!current_context, !select_fn_key);
	   current_context := c;
d821 9
d841 1
a841 1
                       user_context = !current_context,
d845 1
d919 1
a919 1
		     (!current_context, !update_fn_key));
d924 3
a926 2
	    MotifUtils.value_menu_strfun (shell, user_context, user_options, get_string_nm),
	    MotifUtils.context_menu set_context,
d940 1
a940 1
        set_context_label(!current_context);
@


1.42
log
@Parser and Lexer revisions
@
text
@d4 3
d200 2
d220 1
d573 1
a573 1
        val pathStack = ref [(0, "", get_items_from_context ())]
d650 67
a716 1
	fun do_history (s, new_path as (_, _, new_items) :: _) =
d723 5
a727 2
	   set_items (get_print_options ()) new_items)
	|   do_history _ = Crash.impossible "Context Browser: do_history"
d731 2
a732 2
	    _ :: _ :: _ => true
	  | _ => false
d736 1
a736 1
	  (do_history ("", [(0, "", get_items_from_context ())]);
d742 1
a742 1
	    [_, _] =>
d764 6
a769 1
	  | _ => Crash.impossible "Context Browser: redisplay"
d782 1
a782 1
	    [_] => toplevel ()
d790 4
d797 2
d802 2
d814 1
a814 1
	  MotifUtils.options_menu (shell, title, get_user_options)
@


1.41
log
@Moved parent and toplevel buttons from the history menu to the main window.
@
text
@d4 3
a155 1
require "../parser/parser";
a163 1
require "../debugger/value_printer";
a176 1
  structure Parser : PARSER
a181 1
  structure ValuePrinter : VALUE_PRINTER
d192 4
a195 6
  sharing ValuePrinter.Options = UserOptions.Options = Types.Options =
    Incremental.InterMake.Compiler.Options = Parser.Options =
    ToolData.ShellTypes.Options = IdentPrint.Options = MotifUtils.Options =
    ShellUtils.Options
  sharing Parser.Absyn = Incremental.InterMake.Compiler.Absyn
  sharing Parser.Lexer.Info = ToolData.ShellTypes.Info = ShellUtils.Info
a198 3
  sharing type Parser.ParserBasis = Incremental.InterMake.Compiler.ParserBasis
  sharing type ValuePrinter.DebugInformation =
    Incremental.InterMake.Compiler.DebugInformation
a199 1
	       ValuePrinter.Type =
@


1.40
log
@Added View menu and Filter dialog box.  Made empty structures display
the word "<empty">.
@
text
@d4 4
d437 15
d666 1
a666 1
	fun toplevel () =
d668 3
a670 1
	  do_history ("", [(0, "", get_items_from_context ())])
d672 1
a672 1
	fun pop_history () =
d685 6
a690 2
	       set_items (get_print_options ()) items)
	  | _ => Crash.impossible "Context Browser: pop_history"
d788 10
d800 1
a800 1
            (Xm.TopWidget, Xm.WIDGET pathText),
d835 4
a838 8
                Menus.PUSH
		  ("parent", fn _ => pop_history (), fn _ => can_pop ())
		:: Menus.PUSH ("topLevel", fn _ => toplevel (), fn _ => true)
		:: Menus.SEPARATOR
		:: map (fn (s,i) =>
                          Menus.PUSH
			    (s, fn _ => do_history (s,i), fn _ => true))
                       (!history),
d841 2
@


1.39
log
@Simplified Form constraints.
@
text
@d4 3
d228 4
d237 1
d243 4
d253 1
d319 6
d344 2
d349 1
a349 1
	  in map (fn (id, ts) => VAR (id, ts)) vallist
d354 3
a356 1
	  split_vallist (l, pair :: vars, exns)
d358 1
a358 3
	  split_vallist (l, vars, pair :: exns)
    |   split_vallist ((Ident.CON _, _) :: l, vars, exns) =
	  split_vallist (l, vars, exns)
d361 16
a376 14
    fun browse_env (Types.Datatypes.ENV (Types.Datatypes.SE se,
					 Types.Datatypes.TE te,
					 Types.Datatypes.VE (_, ve))) =
	  let val strlist = Types.Datatypes.NewMap.to_list_ordered se
	      val tylist = Types.Datatypes.NewMap.to_list_ordered te
	      val vallist = Types.Datatypes.NewMap.to_list_ordered ve
	      val (varlist, exnlist) = split_vallist (vallist, [], [])
	      val strlist' = map STR strlist
	      val tylist' = map TYPE tylist
	      val varlist' = map VAR varlist
	      val exnlist' = map EXN exnlist
	  in
	    strlist' @@ tylist' @@ exnlist' @@ varlist'
	  end
d380 1
a380 1
	  browse_env env
d382 1
a382 1
	  browse_str str
d385 1
a385 1
	  browse_str str
a386 14
    fun browse_entry (VAR _) = []
    |   browse_entry (EXN _) = []
    |   browse_entry (TYPE (id, Types.Datatypes.TYSTR (_, conenv))) =
	  if Valenv.empty_valenvp conenv then
	    []
	  else
	    browse_conenv conenv
    |   browse_entry (STR (_, str)) =
	  browse_str str
    |   browse_entry (SIG (_, sigma)) =
	  browse_sigma sigma
    |   browse_entry (FUN (_, Basis.BasisTypes.PHI (_, (str, sigma)))) =
	  browse_sigma sigma

d437 8
a444 3
            val context_name = ToolData.ShellTypes.get_context_name user_context
            val context_string = ToolData.ShellTypes.string_context_name context_name
            val cstring = Xm.CompoundString.createSimple("Context: " ^ context_string)
d451 82
d536 1
a536 1
	      #2 (ToolData.ShellTypes.get_context_info (!current_context))
d541 3
d545 1
a545 1
	    val siglist = Types.Datatypes.NewMap.to_list_ordered se
d547 1
d549 2
d552 1
a552 1
	    siglist' @@ funlist' @@ browse_env env
a571 3
	   (*
	   pathLength := !pathLength + size str;
	   *)
a573 1

d587 2
a588 2
	    val str' = if !pathLength = 0 then str else "." ^ str
            val new_items = (browse_entry entry)
d590 2
d593 7
d604 1
d609 12
a620 10
	    case new_items of
	      [] => ()
	    | _  =>
		(* Push the stacks and display the components of the
		   selected entry. *)
		(add_to_path (str', new_items, last_component);
		 ShellUtils.add_history_item
		   ((!pathStr, !pathStack), history,
                    (fn ((s,_),(s',_))=>s=s'), get_user_options());
                 set_items (get_print_options ()) new_items)
d623 1
a623 1
	val (scroll, list, set_items) =
d628 3
a630 1
	val _ = set_items (get_print_options ()) (get_items_from_context ())
a650 7
	fun update () =
	  (* Update display if at top level, otherwise leave it alone.
	     Users can't update existing substructures. *)
	  case !pathStack of
	    [_] => toplevel ()
	  | _ => ()

d667 20
d793 4
@


1.38
log
@Adding value menu ...
@
text
@d4 3
a413 6
	val leftSep = Xm.Widget.createManaged (Xm.Widget.NAME "leftSep",
					       Xm.Widget.Class.SeparatorGadget,
					       frame,[])
	val rightSep = Xm.Widget.createManaged (Xm.Widget.NAME "rightSep",
					       Xm.Widget.Class.SeparatorGadget,
					       frame,[])
a416 3
	val listSep = Xm.Widget.createManaged (Xm.Widget.NAME "listSep",
					       Xm.Widget.Class.SeparatorGadget,
					       frame,[])
a419 3
	val pathSep = Xm.Widget.createManaged (Xm.Widget.NAME "pathSep",
					       Xm.Widget.Class.SeparatorGadget,
					       frame,[])
a422 3
	val bottomSep = Xm.Widget.createManaged (Xm.Widget.NAME "bottomSep",
					       Xm.Widget.Class.SeparatorGadget,
					       frame,[])
d601 1
a602 1

d610 1
a610 1
	  (leftSep,
d614 1
a614 7
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
        Xm.Widget.valuesSet
	  (rightSep,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
d616 1
a616 9
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
        Xm.Widget.valuesSet
	  (contextLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET menuBar),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.LeftWidget, Xm.WIDGET leftSep),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.RightWidget, Xm.WIDGET rightSep),
d619 1
a619 1
	  (pathSep,
d622 5
a626 13
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.LeftWidget, Xm.WIDGET leftSep),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.RightWidget, Xm.WIDGET rightSep),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
	  (pathLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET pathSep),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.LeftWidget, Xm.WIDGET leftSep),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.RightWidget, Xm.WIDGET rightSep),
d632 4
a635 4
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.LeftWidget, Xm.WIDGET leftSep),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.RightWidget, Xm.WIDGET rightSep),
d638 1
a638 1
	  (listSep,
d641 5
a645 4
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.LeftWidget, Xm.WIDGET leftSep),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.RightWidget, Xm.WIDGET rightSep),
a647 9
	  (listLabel,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET listSep),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.LeftWidget, Xm.WIDGET leftSep),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.RightWidget, Xm.WIDGET rightSep),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet
d651 6
a656 14
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.LeftWidget, Xm.WIDGET leftSep),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.RightWidget, Xm.WIDGET rightSep),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.BottomWidget, Xm.WIDGET bottomSep)]);
        Xm.Widget.valuesSet
	  (bottomSep,
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE),
            (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.LeftWidget, Xm.WIDGET leftSep),
            (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.RightWidget, Xm.WIDGET rightSep),
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
@


1.37
log
@Fixed bugs with toplevel command and update behaviour.
@
text
@d4 3
d610 3
d614 1
d715 1
@


1.36
log
@Added automatic updates.
@
text
@d4 3
d544 11
d557 4
a560 1
	    _ :: tail as ((n, s, items) :: _) =>
d571 2
a572 13
	fun update () =
	  let val new_items = get_items_from_context ()
	  in
	    (Xm.Text.replace (pathText, 0,
			      !pathLength + !length_of_last_component, "");
	     pathStack := [(0, "", new_items)];
	     length_of_last_component := 0;
	     history := [];
	     pathLength := 0;
	     pathStr := "";
	     set_items (get_print_options ()) new_items)
	  end

d582 8
a589 1
	   update ())
d712 9
a720 15
	      let val toplevel_stack = !pathStack
	      in
	        fn () =>
                  Menus.PUSH ("parent",
                              fn _ => pop_history (),
                              fn _ => can_pop ()) ::
                  Menus.PUSH ("topLevel",
                              fn _ => do_history ("", toplevel_stack),
                              fn _ => true) ::
		  Menus.SEPARATOR ::
		  map (fn (s,i) =>
                         Menus.PUSH
			   (s, fn _ => do_history (s,i), fn _ => true))
                      (!history)
	      end,
@


1.35
log
@ToolData.works_menu takes different arguments.
@
text
@d4 3
d567 3
d571 3
a573 1
	  (current_context := c;
d575 1
d687 4
a694 1
	    (* MotifUtils.setup_menu (shell, get_user_options), *)
a707 3
                  Menus.PUSH ("update",
                              fn _ => update (),
                              fn _ => true) ::
d710 2
a711 4
                         Menus.PUSH ((* ShellUtils.trim_history_string (s,get_user_options()), *)
                                     s,
                                     fn _ => do_history (s,i),
                                     fn _ => true))
@


1.34
log
@Changed context refs to user_contexts.
@
text
@d4 3
d680 2
a681 1
           [ToolData.works_menu (shell, tools, mk_tooldata, fn () => true),
@


1.33
log
@Overloaded schemes now include the type variable being overloaded.
@
text
@d4 3
d191 1
a191 1
  sharing type ToolData.ShellTypes.ContextRef = MotifUtils.ContextRef
d368 1
a368 1
	      {user_options, context_ref, mk_xinterface_fn, prompter} = args
d424 1
a424 1
	val current_context = ref context_ref
d426 1
a426 1
        fun set_context_label context_ref =
d428 1
a428 1
            val context_name = ToolData.ShellTypes.get_context_name context_ref
d439 3
a441 1
            val context = !(ToolData.ShellTypes.get_context_ref (!current_context))
d577 1
a577 1
                       context_ref = !current_context,
@


1.32
log
@TYCON' for type function functions in lambda code for Modules Debugger;
Extra TYNAME valenv for Modules Debugger.
@
text
@d4 4
d224 15
a238 6
    fun printOverloaded (Types.Datatypes.UNARY _) =
	  "num -> num"
    |   printOverloaded (Types.Datatypes.BINARY _) =
	  "num * num -> num"
    |   printOverloaded (Types.Datatypes.PREDICATE _) =
	  "num * num -> bool"
@


1.31
log
@Added level field to Basis.
@
text
@d4 3
d266 2
a267 2
                          Types.Datatypes.TYNAME (_, _, n, _, _,_,_) => n
                        | Types.Datatypes.METATYNAME (_, _, n, _, _,_) => n) ^
d307 1
@


1.30
log
@Added context menu, ensured that changes do the right thing, ensured that
new selection is passed on to child tools.
@
text
@d4 4
d420 1
a420 1
	    val Basis.BasisTypes.BASIS (_, Basis.BasisTypes.FUNENV fe,
@


1.29
log
@Added copyright message
@
text
@d4 3
d169 3
a171 1
  sharing type Basis.BasisTypes.Datatypes.Type = ValuePrinter.Type = ShellUtils.Type
d175 3
a177 1
  sharing type ToolData.ShellTypes.Context = Incremental.Context = ShellUtils.Context
d344 1
a344 1
	      {user_options, context_ref, ...} = args
d400 3
a402 1
        fun set_context_label () =
d415 1
a415 1
            val context = !(ToolData.ShellTypes.get_context_ref context_ref)
d534 22
a555 3
        val (options_menu,update) = MotifUtils.options_menu (shell, title, get_user_options)
        val UserOptions.USER_OPTIONS(_,update_fns) = user_options
        val _ = update_fns := update :: (!update_fns)
d651 1
a651 1
           [ToolData.works_menu (shell, tools, fn _ => tooldata, fn () => true),
d653 1
d677 2
a678 2
              fn _ => true) ]);
        set_context_label();
@


1.28
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d2 1
d4 3
@


1.27
log
@Changed the way constructors are displayed, so that selecting and pasting
them makes sense.  This involved making two factors orthogonal: namely
whether a component is the last component on a path and whether it has
any entries (a datatype satisfies both of these conditions).
@
text
@d3 6
d248 2
a249 2
                          Types.Datatypes.TYNAME (_, _, n, _, _,_) => n
                        | Types.Datatypes.METATYNAME (_, _, n, _, _) => n) ^
@


1.26
log
@Merged in bug fix.
@
text
@d3 3
d185 2
d188 1
a188 1
      IdentPrint.printValId Options.default_print_options id
d190 5
a194 5
      IdentPrint.printValId Options.default_print_options id
    |   get_id (TYPE (id, _)) = IdentPrint.printTyCon id ^ "<type>"
    |   get_id (STR (id, _)) = IdentPrint.printStrId id
    |   get_id (SIG (id, _)) = IdentPrint.printSigId id ^ "<signature>"
    |   get_id (FUN (id, _)) = IdentPrint.printFunId id ^ "<functor>"
d408 3
a410 1
        val pathStack = ref [(0, get_items_from_context ())]
d417 2
a418 1
	fun add_to_path (str, new_items) =
d421 9
a429 1
	   pathStack := (!pathLength, new_items) :: (!pathStack))
d443 1
a443 1
	    val str = get_id entry
d446 1
d449 7
a455 2
	    Xm.Text.replace (pathText, !pathLength,
			     !pathLength + !length_of_last_component, str');
d457 1
a457 2
	      [] =>
	         length_of_last_component := size str'
d459 6
a464 8
		(* Push the stacks, set length_of_last_component to 0,
		   and display the components of the selected entry. *)
		(length_of_last_component := 0;
	         add_to_path (str', new_items);
                 ShellUtils.add_history_item ((!pathStr, !pathStack),
                                              history,
                                              (fn ((s,_),(s',_))=>s=s'),
                                              get_user_options());
d475 1
a475 1
	fun do_history (s, new_path as (_, new_items) :: _) =
d492 1
a492 1
	    _ :: tail as (n, items) :: _ =>
d494 1
a494 1
	       pathStr := MLWorks.String.substring (!pathStr, 0, n);
d508 1
a508 1
	     pathStack := [(0, new_items)];
@


1.25
log
@Merging in bug fixes
@
text
@d3 3
d9 4
d594 1
a594 1
           [ToolData.works_menu (shell, tools, fn _ => tooldata),
@


1.24
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d3 9
a102 1
require "../interpreter/shell_types";
d104 1
d127 1
d136 2
a137 1
    ToolData.ShellTypes.Options = IdentPrint.Options = MotifUtils.Options
d139 1
a139 1
  sharing Parser.Lexer.Info = ToolData.ShellTypes.Info
d142 1
a142 1
	       MotifUtils.UserOptions
d146 1
a146 2
  sharing type Basis.BasisTypes.Datatypes.Type =
      ValuePrinter.Type
d150 1
a150 1
  sharing type ToolData.ShellTypes.Context = Incremental.Context
a402 20
        fun get_max_history () =
          let
            val UserOptions.USER_OPTIONS({history_length,...},_) = get_user_options()
          in
            !history_length
          end

        fun ministry_of_truth ([], _, _) = []
        |   ministry_of_truth ((x as (s, _))::l, new_factoid, finish) =
            if finish > 0
              then
	      if s = new_factoid then
		l
	      else
		x :: ministry_of_truth (l, new_factoid, finish - 1)
            else []

	fun add_to_history (item as (str, _)) =
	  history := item :: ministry_of_truth (!history, str, get_max_history())

d435 4
a438 1
	         add_to_history (!pathStr, !pathStack);
d606 2
a607 1
                         Menus.PUSH (s,
@


1.23
log
@Get update function from options_menu and put in user_options
Removed preferences menu
@
text
@d3 4
d181 1
a181 1
    fun printConScheme print_options (Types.Datatypes.SCHEME (arity, ty)) =
d188 1
a188 1
		          	        (Types.Datatypes.FUNTYPE (arg, _))) =
d207 1
a207 1
    fun printValScheme print_options (Types.Datatypes.SCHEME (arity, ty)) =
d209 1
a209 1
    |   printValScheme print_options (Types.Datatypes.UNBOUND_SCHEME ty) =
@


1.23.1.1
log
@Fork for bug fixing
@
text
@a2 4
 *  Revision 1.23  1993/08/11  11:05:10  matthew
 *  Get update function from options_menu and put in user_options
 *  Removed preferences menu
 *
@


1.23.1.2
log
@Uses history utilities in ShellUtils
@
text
@a2 3
 *  Revision 1.23.1.1  1993/08/11  11:05:10  jont
 *  Fork for bug fixing
 *
d94 1
a95 1
require "../interpreter/shell_utils";
a117 1
  structure ShellUtils : SHELL_UTILS
d126 1
a126 2
    ToolData.ShellTypes.Options = IdentPrint.Options = MotifUtils.Options =
    ShellUtils.Options
d128 1
a128 1
  sharing Parser.Lexer.Info = ToolData.ShellTypes.Info = ShellUtils.Info
d131 1
a131 1
	       MotifUtils.UserOptions = ShellUtils.UserOptions
d135 2
a136 1
  sharing type Basis.BasisTypes.Datatypes.Type = ValuePrinter.Type = ShellUtils.Type
d140 1
a140 1
  sharing type ToolData.ShellTypes.Context = Incremental.Context = ShellUtils.Context
d393 20
d445 1
a445 4
                 ShellUtils.add_history_item ((!pathStr, !pathStack),
                                              history,
                                              (fn ((s,_),(s',_))=>s=s'),
                                              get_user_options());
d613 1
a613 2
                         Menus.PUSH ((* ShellUtils.trim_history_string (s,get_user_options()), *)
                                     s,
@


1.23.1.3
log
@Changed ToolData.works_menu to take a (unit -> bool) function that
controls whether the Close menu option is enabled.
@
text
@a2 3
 *  Revision 1.23.1.2  1993/10/07  15:43:12  matthew
 *  Uses history utilities in ShellUtils
 *
d581 1
a581 1
           [ToolData.works_menu (shell, tools, fn _ => tooldata, fn () => true),
@


1.22
log
@Get maximum history length from options
@
text
@d3 3
d391 1
a391 1
            val UserOptions.USER_OPTIONS{history_length,...} = get_user_options()
d492 3
a494 1
	
d591 2
a592 2
	    MotifUtils.setup_menu (shell, get_user_options),
	    MotifUtils.options_menu (shell, title, get_user_options),
@


1.21
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.
@
text
@d3 4
d384 10
a393 2
        fun ministry_of_truth (_, _, 0) = []
        |   ministry_of_truth ([], _, _) = []
d395 2
d401 1
d404 1
a404 1
	  history := item :: ministry_of_truth (!history, str, 15)
a413 2

	fun get_user_options () = user_options
@


1.20
log
@Removed exception environments.
@
text
@d3 3
d212 1
a212 1
    |   printTyFun (tycon, Types.Datatypes.NULL_TYFUN id) =
@


1.19
log
@Removed integer parameter
@
text
@d3 3
d250 1
a250 2
					 Types.Datatypes.VE (_, ve),
					 _)) =
@


1.18
log
@Changed names of history menu buttons.
@
text
@d3 3
a73 1
require "../utils/integer";
a86 1
  structure Integer : INTEGER
@


1.17
log
@All tools now set their own titles and pass them to their options menus.
@
text
@d3 3
d574 1
a574 1
                  Menus.PUSH ("Pop",
d577 1
a577 1
                  Menus.PUSH ("Top Level",
d580 1
a580 1
                  Menus.PUSH ("Update",
@


1.16
log
@Added pop_history command.
@
text
@d3 3
d280 1
d289 10
d303 3
a305 1
                                      [])
d565 1
a565 1
	    MotifUtils.options_menu (shell, get_user_options),
@


1.15
log
@Added previous fix to update function as well.
@
text
@d3 3
d421 18
d555 3
@


1.14
log
@Fixed bug in display of current selection.  Set max history to sensible
number.
@
text
@d3 4
d421 2
a422 1
	    (Xm.Text.replace (pathText, 0, !pathLength, "");
d424 1
@


1.13
log
@Change to layout resources
@
text
@d3 3
d357 1
a357 1
	  history := item :: ministry_of_truth (!history, str, 4)
d405 2
a406 1
	  (Xm.Text.replace (pathText, 0, !pathLength, s);
d408 1
@


1.12
log
@Added tools argument to works_menu(),
removed exitApplication from TOOLDATA (works_menu now accesses it directly).
@
text
@d3 4
d503 2
a504 1
            (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
d507 1
a507 2
           [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
            (Xm.TopWidget, Xm.WIDGET scroll),
@


1.11
log
@Added label with context name
Changed context ref handling
@
text
@d3 4
d511 1
a511 1
           [ToolData.works_menu (shell, fn _ => tooldata),
@


1.10
log
@Removed duplicates from history and restricted history length.
Added selected values (etc.) to the selection display.
@
text
@d3 4
d279 3
d307 11
d320 1
d323 1
a323 1
	      Incremental.type_basis (!context_ref)
d434 9
d445 1
a445 1
            (Xm.TopWidget, Xm.WIDGET menuBar),
d529 1
@


1.9
log
@Reorganised menus.
@
text
@d3 3
d318 11
d330 3
a332 8
	  if !pathLength = 0 then
	    (Xm.Text.insert (pathText, !pathLength, str);
	     pathLength := !pathLength + size str;
	     pathStr := str)
	  else
	    (Xm.Text.insert (pathText, !pathLength, "." ^ str);
	     pathLength := !pathLength + size str + 1;
	     pathStr := !pathStr ^ "." ^ str)
d344 2
d347 3
a349 1
          (let
d351 15
a365 9
           in
	     case new_items of
	       [] => ()
	     | _  =>
	       (add_to_path (get_id entry, new_items);
	        pathStack := (!pathLength, new_items) :: (!pathStack);
	        history := (!pathStr, !pathStack) :: !history;
                set_items (get_print_options ()) new_items)
           end)
@


1.8
log
@Added dynamic history and update facility.
Corrected reversed ordering of variables and exceptions.
@
text
@d3 4
d48 1
a66 1
  structure ShellTypes : SHELL_TYPES
d68 1
a70 1
    
d77 1
a77 1
    ShellTypes.Options = IdentPrint.Options = MotifUtils.Options
d79 1
a79 1
  sharing Parser.Lexer.Info = ShellTypes.Info
d81 1
a81 1
  sharing type UserOptions.user_options = ShellTypes.user_options =
d88 2
a89 2
  sharing type Menus.Widget = Xm.Widget = MotifUtils.Widget
  sharing type Menus.ButtonSpec = MotifUtils.ButtonSpec
d91 2
a92 2
  sharing type ShellTypes.Context = Incremental.Context
  sharing type ShellTypes.IncrementalOptions = Incremental.options
d104 2
a105 1
    type ShellData = ShellTypes.ShellData
d253 1
a253 1
    fun make_browser_window (shell_data, applicationShell) =
d255 5
a298 1
	    val context = ShellTypes.get_current_context shell_data
d301 1
a301 1
	      Incremental.type_basis context
d329 1
a329 1
	fun get_user_options () = ShellTypes.get_user_options shell_data
d373 1
d460 2
a461 12
           [Menus.CASCADE ("file",
                           [Menus.PUSH ("close",
                                        fn _ => Xm.Widget.destroy shell,
                                        fn _ => true)],
                           fn _ => true),
(*
            Menus.CASCADE ("history",
                           [Menus.PUSH ("popHistory",
                                        pop_path,
                                        can_pop)],
                           fn _ => true),
*)
a485 1
    val browse = make_browser_window;
@


1.7
log
@Added selection text widget and improved the layout.
@
text
@d3 3
d39 1
d50 1
d200 1
a200 1
    fun split_vallist ([], vars, exns) = (vars, exns)
d287 13
a299 9
	val context = ShellTypes.get_current_context shell_data
	val Basis.BasisTypes.BASIS (_, Basis.BasisTypes.FUNENV fe,
			            Basis.BasisTypes.SIGENV se, env) =
	  Incremental.type_basis context
	val funlist = Types.Datatypes.NewMap.to_list_ordered fe
	val siglist = Types.Datatypes.NewMap.to_list_ordered se
	val funlist' = map (fn (id, phi) => FUN (id, phi)) funlist
	val siglist' = map (fn (id, sigma) => SIG (id, sigma)) siglist
	val init_items = siglist' @@ funlist' @@ browse_env env
d301 2
a302 1
        val stack = ref [(0, init_items)]
d304 1
d306 1
a306 1
	fun add_path str =
d309 2
a310 1
	     pathLength := !pathLength + size str)
d313 2
a314 1
	     pathLength := !pathLength + size str + 1)
d333 4
a336 3
	       (add_path (get_id entry);
                set_items (get_print_options ()) new_items;
	        stack := (!pathLength, new_items) :: (!stack))
d344 1
a344 1
	val _ = set_items (get_print_options ()) init_items
d346 18
a363 12
        fun can_pop _ =
          (case !stack of 
             _ :: _ :: _ => true
           | _ => false)

        fun pop_stack _ =
          (case !stack of
             _ :: (l as ((pos, item_data) :: _)) =>
	       (stack := l;
		shorten_path pos;
                set_items (get_print_options ()) item_data)
           | _ => ())
d455 1
d458 1
a458 1
                                        pop_stack,
d461 21
a481 1
	    MotifUtils.options_menu (shell, get_user_options)]);
@


1.6
log
@Changes to make_scrolllist.
@
text
@d3 3
d106 9
a242 6
    fun selected_pos callback_data =
      let val (_,_,_,_,n,_,_,_,_) = Xm.Callback.convertList callback_data
      in
        n
      end

d250 1
a250 1
        val frame = Xm.Widget.createManaged (Xm.Widget.NAME "inspectorFrame",
d257 25
d292 14
a305 1
        val stack = ref [init_items]
d320 3
a322 2
               (stack := new_items :: (!stack);
                set_items (get_print_options ()) new_items)
d339 1
a339 1
             _ :: (l as (item_data :: _)) =>
d341 1
d345 96
a440 24
        Xm.Widget.valuesSet (menuBar,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_NONE)]);
        Xm.Widget.valuesSet (scroll,
                             [(Xm.TopAttachment, Xm.ATTACHMENT Xm.ATTACH_WIDGET),
                              (Xm.TopWidget, Xm.WIDGET menuBar),
                              (Xm.LeftAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.RightAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM),
                              (Xm.BottomAttachment, Xm.ATTACHMENT Xm.ATTACH_FORM)]);
        Menus.make_submenus (menuBar,
                             [Menus.CASCADE ("file",
                                             [Menus.PUSH ("close",
                                                          fn _ => Xm.Widget.destroy shell,
                                                          fn _ => true)],
                                             fn _ => true),
                              Menus.CASCADE ("history",
                                             [Menus.PUSH ("popHistory",
                                                          pop_stack,
                                                          can_pop)],
                                             fn _ => true),
			      MotifUtils.options_menu (shell, get_user_options)
                              ]);
@


1.5
log
@Fixed printing of exceptions.  Filtered out value constructors from list.
@
text
@d3 3
d65 1
a65 1
    ShellTypes.Options = IdentPrint.Options
d69 2
a70 1
  sharing type UserOptions.user_options = ShellTypes.user_options
d77 1
d263 6
d277 1
a277 1
                set_items new_items)
a279 3
        val Options.OPTIONS{print_options,...} =
          UserOptions.new_options (ShellTypes.get_user_options shell_data)

d281 3
a283 3
	  MotifUtils.make_scrolllist (frame, "contextBrowser", select_fn,
				      fn _ => fn _ => (),
				      printEntry print_options)
d285 1
a285 1
	val _ = set_items init_items
d294 3
a296 2
             _ :: (l as (item_data :: _)) => (stack := l;
                                              set_items item_data)
d320 2
a321 1
                                             fn _ => true)
@


1.4
log
@Fixed printing of type variables.
@
text
@d3 3
d91 2
a92 1
      VAL of Ident.ValId * Types.Datatypes.Typescheme
d105 14
d126 1
a126 14
	    	    case typescheme of
	      	      Types.Datatypes.SCHEME (arity, ty) =>
			(case Types.apply (Types.Datatypes.TYFUN (ty, arity),
					   Types.make_tyvars arity) of
			   Types.Datatypes.FUNTYPE (arg, _) =>
		             " of " ^ Types.print_type print_options arg
			 | _ => "")
	    	    | Types.Datatypes.UNBOUND_SCHEME
		        (Types.Datatypes.FUNTYPE (arg, _)) =>
		        " of " ^ Types.print_type print_options arg
	    	    | Types.Datatypes.UNBOUND_SCHEME _ =>
		       ""
	    	    | Types.Datatypes.OVERLOADED_SCHEME _ =>
		        " <strange overloaded scheme>"])
d131 1
a131 1
    fun printScheme print_options (Types.Datatypes.SCHEME (arity, ty)) =
d133 1
a133 1
    |   printScheme print_options (Types.Datatypes.UNBOUND_SCHEME ty) =
d135 1
a135 1
    |   printScheme _ (Types.Datatypes.OVERLOADED_SCHEME overloaded) =
d150 1
a150 1
    fun printEntry print_options (VAL (id, ts)) =
d152 4
a155 1
	    printScheme print_options ts
d173 1
a173 1
    fun browse_valenv (Types.Datatypes.VE (_, ve)) =
d175 1
a175 1
	  in map (fn (id, ts) => VAL (id, ts)) vallist
d178 8
d193 5
a197 3
	      val strlist' = map (fn (id, str) => STR (id, str)) strlist
	      val tylist' = map (fn (id, tystr) => TYPE (id, tystr)) tylist
	      val vallist' = map (fn (id, ts) => VAL (id, ts)) vallist
d199 1
a199 1
	    strlist' @@ tylist' @@ vallist'
d211 4
a214 3
    fun browse_entry (VAL _) = []
    |   browse_entry (TYPE (id, Types.Datatypes.TYSTR (_, valenv))) =
	  if Valenv.empty_valenvp valenv then
d217 1
a217 1
	    browse_valenv valenv
@


1.3
log
@Removed now spurious reference to Valenv.Options.  That version of valenv
was never checked in, as it turned out not to be needed.
@
text
@d3 4
d109 6
a114 5
	      	      Types.Datatypes.SCHEME
		        (_, Types.Datatypes.FUNTYPE (arg, _)) =>
		        " of " ^ Types.print_type print_options arg
	    	    | Types.Datatypes.SCHEME (arity,  _) =>
		        ""
d133 11
a143 6
    fun printTyfun print_options (Types.Datatypes.TYFUN (ty, _)) =
	  Types.print_type print_options ty
    |   printTyfun _ (Types.Datatypes.ETA_TYFUN tyname) =
	  ""
    |   printTyfun _ (Types.Datatypes.NULL_TYFUN id) =
	  Types.Datatypes.Tyfun_id.string_tyfun_id id
d149 1
a149 1
		   (TYPE (id, Types.Datatypes.TYSTR (_, valenv))) =
d151 4
a154 1
	    "type " ^ IdentPrint.printTyCon id
d156 1
a156 1
	    "datatype " ^ IdentPrint.printTyCon id ^ " = " ^
@


1.2
log
@Now browses datatypes, and ignores types and vals.
@
text
@d3 3
d55 1
a55 1
    ShellTypes.Options = IdentPrint.Options = Valenv.Options
@


1.1
log
@Initial revision
@
text
@d2 3
a4 1
 *  $Log$
d6 1
d149 5
d178 5
a182 1
    |   browse_entry (TYPE _) = []
d200 1
a200 1
          Xm.Widget.createPopupShell (Xm.Widget.NAME "inspectorShell",
a210 3
        val textInput = Xm.Widget.createManaged (Xm.Widget.NAME "inspectorTextInput",
                                                 Xm.Widget.Class.Text,
                                                 frame,[])
d227 5
a231 2
             stack := new_items :: (!stack);
             set_items new_items
d238 1
a238 1
	  MotifUtils.make_scrolllist (frame, "Context Browser", select_fn,
@
