head	1.64;
access;
symbols
	MLW_daveb_inline_1_4_99:1.63.1
	MLWorks_21c0_1999_03_25:1.63
	MLWorks_20c1_1998_08_20:1.63
	MLWorks_20c0_1998_08_04:1.63
	MLWorks_20b2c2_1998_06_19:1.62
	MLWorks_20b2_Windows_1998_06_12:1.62
	MLWorks_20b1c1_1998_05_07:1.61
	MLWorks_20b0_1998_04_07:1.61
	MLWorks_20b0_1998_03_20:1.61
	MLWorks_20m2_1998_02_16:1.61
	MLWorks_20m1_1997_10_23:1.61
	MLWorks_11r1:1.60.1.1.1.1.1
	MLWorks_workspace_97:1.61.2
	MLWorks_dt_wizard:1.61.1
	MLWorks_11c0_1997_09_09:1.60.1.1.1.1
	MLWorks_10r3:1.60.1.1.3
	MLWorks_10r2_551:1.60.1.1.2
	MLWorks_11:1.60.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.60.1.1
	MLWorks_20m0_1997_06_20:1.61
	MLWorks_1_0_r2c2_1997_06_14:1.60.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.60.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.60.1
	MLWorks_BugFix_1997_04_24:1.60
	MLWorks_1_0_r2_Win32_1997_04_11:1.60
	MLWorks_1_0_r2_Unix_1997_04_04:1.60
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.59.3.1.1
	MLWorks_gui_1996_12_18:1.59.4
	MLWorks_1_0_Win32_1996_12_17:1.59.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.59.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.59.1.1
	MLWorks_1_0_Irix_1996_11_28:1.59.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.59.2
	MLWorks_1_0_Unix_1996_11_14:1.59.1
	MLWorks_Open_Beta2_1996_10_11:1.58.3
	MLWorks_License_dev:1.58.2
	MLWorks_1_open_beta_1996_09_13:1.58.1
	MLWorks_Open_Beta_1996_08_22:1.58
	MLWorks_Beta_1996_07_02:1.57
	MLWorks_Beta_1996_06_07:1.57
	MLWorks_Beta_1996_06_06:1.57
	MLWorks_Beta_1996_06_05:1.57
	MLWorks_Beta_1996_06_03:1.57
	MLWorks_Beta_1996_05_31:1.57
	MLWorks_Beta_1996_05_30:1.56
	ML_beta_release_12/08/94:1.32
	ML_beta_release_03/08/94:1.31
	ML_revised_beta_release_25/05/94:1.27
	ML_final_beta_release_02/03/94:1.26
	mlworks-28-01-1994:1.24
	Release:1.20
	mlworks-beta-01-09-1993:1.20;
locks; strict;
comment	@ * @;


1.64
date	99.05.13.13.55.56;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	98.07.07.13.44.48;	author jont;	state Exp;
branches
	1.63.1.1;
next	1.62;

1.62
date	98.05.26.13.56.24;	author mitchell;	state Exp;
branches;
next	1.61;

1.61
date	97.06.16.09.22.08;	author johnh;	state Exp;
branches
	1.61.1.1
	1.61.2.1;
next	1.60;

1.60
date	97.01.08.11.43.26;	author andreww;	state Exp;
branches
	1.60.1.1;
next	1.59;

1.59
date	96.10.09.16.14.21;	author io;	state Exp;
branches
	1.59.1.1
	1.59.2.1
	1.59.3.1
	1.59.4.1;
next	1.58;

1.58
date	96.07.01.15.20.47;	author andreww;	state Exp;
branches
	1.58.1.1
	1.58.2.1
	1.58.3.1;
next	1.57;

1.57
date	96.05.30.13.20.19;	author daveb;	state Exp;
branches;
next	1.56;

1.56
date	96.05.16.13.08.07;	author stephenb;	state Exp;
branches;
next	1.55;

1.55
date	96.05.08.13.30.06;	author stephenb;	state Exp;
branches;
next	1.54;

1.54
date	96.05.01.11.27.21;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	96.04.17.14.08.21;	author stephenb;	state Exp;
branches;
next	1.52;

1.52
date	96.03.19.15.26.03;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	96.03.15.10.49.26;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	96.03.11.10.05.43;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	96.01.16.12.19.42;	author nickb;	state Exp;
branches;
next	1.48;

1.48
date	96.01.12.11.52.43;	author stephenb;	state Exp;
branches;
next	1.47;

1.47
date	96.01.08.16.28.16;	author nickb;	state Exp;
branches;
next	1.46;

1.46
date	95.09.12.12.38.59;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	95.07.26.14.59.41;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	95.07.13.10.32.36;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	95.07.12.13.25.07;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	95.06.15.13.24.03;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	95.06.14.13.57.00;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.06.02.14.11.26;	author nickb;	state Exp;
branches;
next	1.39;

1.39
date	95.05.30.17.44.34;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	95.05.11.10.43.10;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	95.05.02.15.24.15;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	95.04.28.14.05.02;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	95.04.06.09.30.41;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	95.01.17.16.45.46;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	94.12.07.11.33.08;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	94.08.11.13.27.06;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	94.08.01.12.34.45;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	94.07.28.11.50.41;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	94.07.08.10.15.51;	author nickh;	state Exp;
branches;
next	1.28;

1.28
date	94.06.20.13.12.40;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	94.03.21.18.03.21;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	94.02.24.00.02.29;	author nosa;	state Exp;
branches;
next	1.25;

1.25
date	94.02.02.11.11.19;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	94.01.19.10.17.42;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	94.01.06.13.07.43;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.11.09.15.33.09;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	93.10.12.16.30.35;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.06.16.11.55.38;	author matthew;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	93.06.11.14.06.24;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.06.03.17.55.05;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.05.18.15.22.44;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	93.05.10.17.08.09;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	93.05.10.16.21.18;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	93.05.10.14.34.51;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	93.05.10.09.42.08;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.05.07.15.34.00;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.05.06.14.27.06;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.05.04.16.47.34;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.04.26.12.11.47;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.04.08.08.39.43;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.04.06.16.31.45;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	93.04.02.15.32.46;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.03.30.12.56.42;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.03.15.17.36.03;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.03.11.14.50.03;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.15.48.10;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.02.19.45.11;	author daveb;	state Exp;
branches;
next	;

1.20.1.1
date	93.06.16.11.55.38;	author jont;	state Exp;
branches;
next	1.20.1.2;

1.20.1.2
date	93.10.12.16.26.42;	author matthew;	state Exp;
branches;
next	;

1.58.1.1
date	96.09.13.11.15.57;	author hope;	state Exp;
branches;
next	;

1.58.2.1
date	96.10.07.16.06.03;	author hope;	state Exp;
branches;
next	;

1.58.3.1
date	96.10.17.11.24.19;	author hope;	state Exp;
branches;
next	;

1.59.1.1
date	96.11.14.12.48.58;	author hope;	state Exp;
branches
	1.59.1.1.1.1;
next	;

1.59.1.1.1.1
date	96.11.28.15.00.22;	author hope;	state Exp;
branches;
next	;

1.59.2.1
date	96.11.22.18.08.45;	author hope;	state Exp;
branches;
next	;

1.59.3.1
date	96.12.17.17.47.24;	author hope;	state Exp;
branches
	1.59.3.1.1.1;
next	;

1.59.3.1.1.1
date	97.02.24.11.37.08;	author hope;	state Exp;
branches;
next	;

1.59.4.1
date	96.12.18.09.41.24;	author hope;	state Exp;
branches;
next	;

1.60.1.1
date	97.05.12.10.33.51;	author hope;	state Exp;
branches
	1.60.1.1.1.1
	1.60.1.1.2.1
	1.60.1.1.3.1;
next	;

1.60.1.1.1.1
date	97.07.28.18.19.20;	author daveb;	state Exp;
branches
	1.60.1.1.1.1.1.1;
next	;

1.60.1.1.1.1.1.1
date	97.10.07.11.44.27;	author jkbrook;	state Exp;
branches;
next	;

1.60.1.1.2.1
date	97.09.08.17.12.55;	author daveb;	state Exp;
branches;
next	;

1.60.1.1.3.1
date	97.09.09.14.08.34;	author daveb;	state Exp;
branches;
next	;

1.61.1.1
date	97.09.10.19.23.49;	author brucem;	state Exp;
branches;
next	;

1.61.2.1
date	97.09.11.20.54.44;	author daveb;	state Exp;
branches;
next	;

1.63.1.1
date	99.04.01.17.56.46;	author daveb;	state Exp;
branches;
next	;


desc
@Starts an interpreter, with the X interface loaded.
@


1.64
log
@[Bug #190553]
Replaced use of basis/exit with utils/mlworks_exit.
@
text
@(*  ==== RUN THE INTERPRETER ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Description
 *  -----------
 *  This is the file that starts the interpreter.  It is the last file
 *  loaded into the runtime system in order to create an interpreter image.
 *
 *  Notes
 *  -----
 *  It is a good idea to have your own copy of this file if you are
 *  developing, as you will be able to flip various switches without much
 *  recompilation.
 *
 *  Revision Log
 *  ------------
 *  $Log: xinterpreter.sml,v $
 * Revision 1.63  1998/07/07  13:44:48  jont
 * [Bug #20122]
 * Move pervasive signatures into __pervasive_library.sml
 *
 * Revision 1.62  1998/05/26  13:56:24  mitchell
 * [Bug #30413]
 * Use abstract exit status
 *
 * Revision 1.61  1997/06/16  09:22:08  johnh
 * [Bug #30174]
 * Making podium platform specific.
 *
 * Revision 1.60  1997/01/08  11:43:26  andreww
 * [Bug #1818]
 * increasing pervasive module count by one, to account for new
 * floatarray signature.
 *
 * Revision 1.59  1996/10/09  16:14:21  io
 * moving String from toplevel
 *
 * Revision 1.58  1996/07/01  15:20:47  andreww
 * expanding the pervasive library to include two more runtime modules.
 *
 * Revision 1.57  1996/05/30  13:20:19  daveb
 * The Interrupt exception is no longer at top level.
 *
 * Revision 1.56  1996/05/16  13:08:07  stephenb
 * Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
 *
 * Revision 1.55  1996/05/08  13:30:06  stephenb
 * Update wrt move of file "main" to basis.
 *
 * Revision 1.54  1996/05/01  11:27:21  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.53  1996/04/17  14:08:21  stephenb
 * Replace any use of MLWorks.exit by Exit.exit
 *
 * Revision 1.52  1996/03/19  15:26:03  daveb
 * Reinstated the code to keep the pervasive modules in the runtime modules
 * list.  This is needed for loading object files into the interpreter.
 *
 * Revision 1.51  1996/03/15  10:49:26  daveb
 * Added comment to show where to call Incremental.preload.
 *
 * Revision 1.50  1996/03/11  10:05:43  daveb
 * Runtime.modules list is now set to nil after loading.  The pervasives
 * are held on to by Incremental.project.
 *
 *  Revision 1.49  1996/01/16  12:19:42  nickb
 *  Change to StorageManager interface.
 *
 *  Revision 1.48  1996/01/12  11:52:43  stephenb
 *  handle_fatal_signal: reset fatal (signal) handler status when quitting.
 *
 *  Revision 1.47  1996/01/08  16:28:16  nickb
 *  Debugger SIGNAL changed to INTERRUPT
 *
 *  Revision 1.46  1995/09/12  12:38:59  matthew
 *  Improving messages
 *
 *  Revision 1.45  1995/07/26  14:59:41  matthew
 *  GUI directory restructuring
 *
 *  Revision 1.44  1995/07/13  10:32:36  matthew
 *  Changes to Ml_Debugger signature
 *
 *  Revision 1.43  1995/07/12  13:25:07  jont
 *  Add parameter to make_shell_structure to indicate image type (ie tty or motif)
 *
 *  Revision 1.42  1995/06/15  13:24:03  daveb
 *  Type of Ml_Debugger.ml_debugger has changed.
 *
 *  Revision 1.41  1995/06/14  13:57:00  daveb
 *  Type of Ml_Debugger.ml_debugger has changed.
 *
 *  Revision 1.40  1995/06/02  14:11:26  nickb
 *  Add fatal signal handling.
 *
 *  Revision 1.39  1995/05/30  17:44:34  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.38  1995/05/11  10:43:10  matthew
 *  Setting pervasive generalise function moved elsewhere
 *
 *  Revision 1.37  1995/05/02  15:24:15  matthew
 *  Remove script argument to ml_debugger
 *  Change use of cast (again)
 *
 *  Revision 1.36  1995/04/28  14:05:02  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.35  1995/04/06  09:30:41  matthew
 *  Removing Mod_rules.print_times
 *
 *  Revision 1.34  1995/01/17  16:45:46  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *
 *  Revision 1.33  1994/12/07  11:33:08  matthew
 *  Changing uses of cast
 *
 *  Revision 1.32  1994/08/11  13:27:06  matthew
 *  Interrupt handler raises wrong exception
 *
 *  Revision 1.31  1994/08/01  12:34:45  daveb
 *  Separated preferences from options.
 *
 *  Revision 1.30  1994/07/28  11:50:41  daveb
 *  Added comment about argument handling.
 *
 *  Revision 1.29  1994/07/08  10:15:51  nickh
 *  Change interrupt and stack overflow handling.
 *
 *  Revision 1.28  1994/06/20  13:12:40  daveb
 *  Replaced context_ref with user_contexts.
 *
 *  Revision 1.27  1994/03/21  18:03:21  matthew
 *  Stopped raising Interrupt on return from debugger.
 *
 *  Revision 1.26  1994/02/24  00:02:29  nosa
 *  Debugger scripts for tracing tool using debugger.
 *
 *  Revision 1.25  1994/02/02  11:11:19  daveb
 *  Minor changes in substructures.
 *
 *  Revision 1.24  1994/01/19  10:17:42  matthew
 *  Changed implementation of last function to avoid gc problem
 *
 *  Revision 1.24  1994/01/19  10:17:42  matthew
 *  Changed implementation of last function to avoid gc problem
 *
 *  Revision 1.23  1994/01/06  13:07:43  matthew
 *  Preserve pervasive modules.
 *
 *  Revision 1.22  1993/11/09  15:33:09  jont
 *  Changed initial value of user_options to have interrupt_tight_loops on
 *  by default
 *
 *  Revision 1.21  1993/10/12  16:30:35  matthew
 *  Merging bug fixes
 *
 *  Revision 1.20.1.2  1993/10/12  16:26:42  matthew
 *  Uncommented stack overflow handler
 *  Uses STACK_OVERFLOW mode in the debuggert
 *
 *  Revision 1.20.1.1  1993/06/16  11:55:38  jont
 *  Fork for bug fixing
 *
 *  Revision 1.20  1993/06/16  11:55:38  matthew
 *  Commented out SIGUSR1 handling for the moment
 *
 *  Revision 1.19  1993/06/11  14:06:24  matthew
 *  Added stack overflow function and SIGUSER1 handler
 *  l
 *
 *  Revision 1.18  1993/06/03  17:55:05  daveb
 *  Removed the context field from the prompter.
 *
 *  Revision 1.17  1993/05/18  15:22:44  jont
 *  Removed integer parameter
 *
 *  Revision 1.16  1993/05/10  17:08:09  daveb
 *  Interface to contextrefs has changed.
 *
 *  Revision 1.15  1993/05/10  16:21:18  daveb
 *  Changed type of ml_debugger.
 *
 *  Revision 1.14  1993/05/10  14:34:51  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *  
 *  Revision 1.13  1993/05/10  09:42:08  matthew
 *  Added interrupt handler
 *  
 *  Revision 1.12  1993/05/07  15:34:00  matthew
 *  Break function uses global start_frames and debugger type
 *  
 *  Revision 1.11  1993/05/06  14:27:06  matthew
 *  ShellTypes changes
 *  
 *  Revision 1.10  1993/05/04  16:47:34  matthew
 *  Changed context ref handling
 *  
 *  Revision 1.9  1993/04/26  12:11:47  matthew
 *  Removed ML_Debugger.BASE_FRAME
 *  
 *  Revision 1.8  1993/04/08  08:39:43  matthew
 *  Added MLWorks.Debugger structure
 *  Set up generalise function in pervasives
 *  
 *  Revision 1.7  1993/04/06  16:31:45  jont
 *  Moved user_options and version from interpreter to main
 *  
 *  Revision 1.6  1993/04/02  15:32:46  matthew
 *  Signature changes
 *  
 *  Revision 1.5  1993/03/30  12:56:42  matthew
 *  Added pervasive break function
 *  Sorted out a bit
 *  
 *  Revision 1.4  1993/03/15  17:36:03  matthew
 *  Simplified ShellTypes types
 *  
 *  Revision 1.3  1993/03/11  14:50:03  matthew
 *  Signature revisions
 *  
 *  Revision 1.2  1993/03/08  15:48:10  matthew
 *  Options & Info changes
 *  Changes for ShellData type
 *  
 *  Revision 1.1  1993/03/02  19:45:11  daveb
 *  Initial revision
 *  
 *)

require "../main/__toplevel";
require "../main/__info";
require "../debugger/__ml_debugger";
require "__shell_types";
require "__user_context";
require "../main/__user_options";
require "../main/__preferences";
require "__tty_listener";
require "__shell_structure";
require "__incremental";
require "__os";
require "../winsys/__podium";

(* require "__intermake"; InterMake_.Diagnostic.set 1; *)
(* require "../main/__compiler"; Compiler_.Diagnostic.set 2; *)

local

  structure Options = TopLevel_.Options
  structure UserContext = UserContext_
  structure ShellTypes = ShellTypes_
  structure Ml_Debugger = Ml_Debugger_
  structure Incremental = Incremental_
  structure Info = Info_

  (* This is getting too big *)

  fun default_prompter {name, topdec, line, subline} =
    concat [name, if subline > 0 then ">> " else "> "]

  exception NoDebugger

  val initial_context =
    ShellStructure_.make_shell_structure false
    (ShellTypes.shell_data_ref, Incremental.initial)

  (* Set up preloaded modules here. *)
  (*
  val _ = Incremental.preload (Incremental.initial, "utils.__lists")
  *)

  val user_context_options =
    UserOptions_.make_user_context_options Options.default_options 

  val user_preferences =
    Preferences_.make_user_preferences Preferences_.default_preferences

  val _ =
    case user_context_options
    of UserOptions_.USER_CONTEXT_OPTIONS
         {1={generate_interruptable_code, ...}, ...} =>
      generate_interruptable_code := true;
      (* want this on for the interpreter *)

  val _ = UserContext.makeInitialUserContext
	    (initial_context, "Initial", user_context_options)

(* Argument handling is actually done is the Shell.save function in
   interpreter/_shell_structure.sml.  The reason for this is that 
   main is run when building the motif.img, in the images Makefile.
   The Makefile pipes "Shell.save ..." into the interpreter, and it
   saves an image.  It is this image that the user runs, and that has
   to handle the user's arguments.
   
   An alternative approach would be to call MLWorks.save here.  Unfortunately
   this increases the size of the saved image.  I don't know why.  *)

  fun main arguments =
    TTYListener_.listener
      (ShellTypes_.LISTENER_ARGS
         {user_context = UserContext.getNewInitialContext(),
          user_options =
	    UserOptions_.make_user_tool_options Options.default_options,
          user_preferences = user_preferences,
          prompter=default_prompter,
          mk_xinterface_fn = Podium_.start_x_interface})
in

  (* MLWorks.Internal.Runtime.modules is a list of the modules that have
     been loaded in the building of this image.  Since we have now created
     the user's image, we don't need most of this list any more.  The only
     entries we need are the pervasives, for loading object files.  These
     are the last 2 entries on the list.
     
     This is not robust code.  It would be better if a module read from 
     an object file could be loaded using a similar mechanism to loading
     the result of compiling a source file. *)

  val _ = MLWorks.Internal.Runtime.modules :=
    (case rev(!MLWorks.Internal.Runtime.modules) of
       x :: y :: _ => [y, x]
     | _ => !MLWorks.Internal.Runtime.modules (* Impossible case *))

  fun handle_fatal_signal shell_data_ref s =
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
      val context = ShellTypes.get_current_context shell_data
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.FATAL_SIGNAL s,
         Ml_Debugger.POSSIBLE ("Return to top level",
			       Ml_Debugger.FUN
			        (fn _ =>
				 (MLWorks.Threads.Internal.reset_fatal_status();
				 raise MLWorks.Interrupt))),
         Ml_Debugger.NOT_POSSIBLE)
    end

  fun interrupt_function shell_data_ref s = 
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
      val context = ShellTypes.get_current_context shell_data
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.INTERRUPT,
         Ml_Debugger.POSSIBLE ("Return to top level",
                               Ml_Debugger.DO_RAISE MLWorks.Interrupt),
         Ml_Debugger.POSSIBLE ("Continue interrupted code",
                               Ml_Debugger.NORMAL_RETURN))
    end

  fun double_stack_limit () = 
    let val m = MLWorks.Internal.Runtime.Memory.max_stack_blocks
    in m := (!m * 2)
    end

  fun stack_overflow_function shell_data_ref s = 
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
      val context = ShellTypes.get_current_context shell_data
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.STACK_OVERFLOW,
         Ml_Debugger.POSSIBLE
	   ("Return to top level", Ml_Debugger.DO_RAISE MLWorks.Interrupt),
         Ml_Debugger.POSSIBLE
	   ("Continue with extended stack",
	    Ml_Debugger.FUN double_stack_limit))
    end

  val _ =
    MLWorks.Internal.Runtime.Event.stack_overflow_handler
    (stack_overflow_function ShellTypes.shell_data_ref)

  val _ =
    MLWorks.Internal.Runtime.Event.interrupt_handler
    (interrupt_function ShellTypes.shell_data_ref)

  val _ = 
    MLWorks.Threads.Internal.set_handler
    (handle_fatal_signal ShellTypes.shell_data_ref)

  fun break_function (shell_data_ref) s =
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
      val context = ShellTypes.get_current_context shell_data
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.BREAK s,
         Ml_Debugger.POSSIBLE ("Return to top level",
                               Ml_Debugger.DO_RAISE MLWorks.Interrupt),
         Ml_Debugger.POSSIBLE ("Continue interrupted code",
                               Ml_Debugger.NORMAL_RETURN))
    end
  
  val _ = MLWorks.Internal.Debugger.break_hook :=
	    break_function (ShellTypes.shell_data_ref)

  val _ = case main (MLWorks.arguments ()) of
            0 => OS.Process.exit (OS.Process.success)
          | _ => OS.Process.exit (OS.Process.failure);
end
@


1.63
log
@[Bug #20122]
Move pervasive signatures into __pervasive_library.sml
@
text
@d19 4
d246 1
a246 1
require "../basis/__exit";
a259 1
  structure Exit = Exit_
d429 2
a430 2
            0 => Exit.exit (Exit.success)
          | _ => Exit.exit (Exit.failure);
@


1.63.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a18 4
 * Revision 1.63  1998/07/07  13:44:48  jont
 * [Bug #20122]
 * Move pervasive signatures into __pervasive_library.sml
 *
@


1.62
log
@[Bug #30413]
Use abstract exit status
@
text
@d19 4
d315 1
a315 1
     are the last 11 entries on the list.
a320 12
  fun last(n,l) =
    let
      fun nthtail (0,l) = l
        | nthtail (_,[]) = []
        | nthtail (n,(a::l)) = nthtail (n-1,l)
      fun scan (l,[]) = l
        | scan ([],l) = [] (* impossible case, but there you go *)
        | scan (a::l,a'::l') = scan (l,l')
    in
      scan (l,nthtail (n,l))
    end

d322 3
a324 1
    last(11,!MLWorks.Internal.Runtime.modules)
@


1.61
log
@[Bug #30174]
Making podium platform specific.
@
text
@d19 4
d431 3
a433 2
  val _ = Exit.exit (main (MLWorks.arguments ()));
  
@


1.61.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a18 4
 * Revision 1.61  1997/06/16  09:22:08  johnh
 * [Bug #30174]
 * Making podium platform specific.
 *
@


1.61.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a18 4
 * Revision 1.61  1997/06/16  09:22:08  johnh
 * [Bug #30174]
 * Making podium platform specific.
 *
@


1.60
log
@[Bug #1818]
increasing pervasive module count by one, to account for new
floatarray signature.
@
text
@d19 5
d235 1
a235 1
require "../gui/__podium";
@


1.60.1.1
log
@branched from 1.60
@
text
@a18 5
 * Revision 1.60  1997/01/08  11:43:26  andreww
 * [Bug #1818]
 * increasing pervasive module count by one, to account for new
 * floatarray signature.
 *
@


1.60.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a18 3
 * Revision 1.60.1.1  1997/05/12  10:33:51  hope
 * branched from 1.60
 *
@


1.60.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a18 3
 * Revision 1.60.1.1  1997/05/12  10:33:51  hope
 * branched from 1.60
 *
@


1.60.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a18 3
 * Revision 1.60.1.1  1997/05/12  10:33:51  hope
 * branched from 1.60
 *
@


1.60.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a18 3
 * Revision 1.60.1.1.1.1  1997/07/28  18:19:20  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.59
log
@moving String from toplevel
@
text
@d19 3
d302 1
a302 1
     are the last 10 entries on the list.
d321 1
a321 1
    last(10,!MLWorks.Internal.Runtime.modules)
@


1.59.4.1
log
@branched from 1.59
@
text
@a18 3
 * Revision 1.59  1996/10/09  16:14:21  io
 * moving String from toplevel
 *
@


1.59.3.1
log
@branched from 1.59
@
text
@a18 3
 * Revision 1.59  1996/10/09  16:14:21  io
 * moving String from toplevel
 *
@


1.59.3.1.1.1
log
@branched from 1.59.3.1
@
text
@a18 3
 * Revision 1.59.3.1  1996/12/17  17:47:24  hope
 * branched from 1.59
 *
@


1.59.2.1
log
@branched from 1.59
@
text
@a18 3
 * Revision 1.59  1996/10/09  16:14:21  io
 * moving String from toplevel
 *
@


1.59.1.1
log
@branched from 1.59
@
text
@a18 3
 * Revision 1.59  1996/10/09  16:14:21  io
 * moving String from toplevel
 *
@


1.59.1.1.1.1
log
@branched from 1.59.1.1
@
text
@a18 3
 * Revision 1.59.1.1  1996/11/14  12:48:58  hope
 * branched from 1.59
 *
@


1.58
log
@expanding the pervasive library to include two more runtime modules.
@
text
@d19 3
d245 1
a245 1
    String.implode [name, if subline > 0 then ">> " else "> "]
@


1.58.3.1
log
@branched from 1.58
@
text
@a18 3
 * Revision 1.58  1996/07/01  15:20:47  andreww
 * expanding the pervasive library to include two more runtime modules.
 *
@


1.58.2.1
log
@branched from 1.58
@
text
@a18 3
 * Revision 1.58  1996/07/01  15:20:47  andreww
 * expanding the pervasive library to include two more runtime modules.
 *
@


1.58.1.1
log
@branched from 1.58
@
text
@a18 3
 * Revision 1.58  1996/07/01  15:20:47  andreww
 * expanding the pervasive library to include two more runtime modules.
 *
@


1.57
log
@The Interrupt exception is no longer at top level.
@
text
@d19 3
d296 1
a296 1
     are the last 8 entries on the list.
d315 1
a315 1
    last(8,!MLWorks.Internal.Runtime.modules)
@


1.56
log
@Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
@
text
@d19 3
d331 1
a331 1
				 raise Interrupt))),
d349 1
a349 1
                               Ml_Debugger.DO_RAISE Interrupt),
d373 1
a373 1
	   ("Return to top level", Ml_Debugger.DO_RAISE Interrupt),
d405 1
a405 1
                               Ml_Debugger.DO_RAISE Interrupt),
@


1.55
log
@Update wrt move of file "main" to basis.
@
text
@d19 3
d407 1
a407 1
  val _ = MLWorks.Debugger.break_hook :=
d410 1
a410 1
  val _ = Exit.exit (main (MLWorks.OS.arguments ()));
@


1.54
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d19 6
d214 1
a214 1
require "../main/__exit";
@


1.53
log
@Replace any use of MLWorks.exit by Exit.exit
@
text
@d19 3
d227 1
a227 1
    implode [name, if subline > 0 then ">> " else "> "]
@


1.52
log
@Reinstated the code to keep the pervasive modules in the runtime modules
list.  This is needed for loading object files into the interpreter.
@
text
@d19 4
d205 1
d219 1
d398 1
a398 1
  val _ = MLWorks.exit (main (MLWorks.OS.arguments ()));
@


1.51
log
@Added comment to show where to call Incremental.preload.
@
text
@d19 3
d270 22
a291 3
     the user's image, we don't need this list any more.  All necessary 
     code is reached from the relevant roots; the rest is garbage. *)
  val _ = MLWorks.Internal.Runtime.modules := []
@


1.50
log
@Runtime.modules list is now set to nil after loading.  The pervasives
are held on to by Incremental.project.
@
text
@d19 4
d222 5
@


1.49
log
@Change to StorageManager interface.
@
text
@d19 3
d256 5
a260 17
  (* This is a function for setting the module table to just *)
  (* the pervasive files.  This should be done by setting something *)
  (* pervasive after making the pervasive image *)

  fun last(n,l) =
    let
      fun nthtail (0,l) = l
        | nthtail (_,[]) = []
        | nthtail (n,(a::l)) = nthtail (n-1,l)
      fun scan (l,[]) = l
        | scan ([],l) = [] (* impossible case, but there you go *)
        | scan (a::l,a'::l') = scan (l,l')
    in
      scan (l,nthtail (n,l))
    end

  val _ = MLWorks.Internal.Runtime.modules := last(8,!MLWorks.Internal.Runtime.modules)
@


1.48
log
@handle_fatal_signal: reset fatal (signal) handler status when quitting.
@
text
@d19 3
d311 5
d333 1
a333 3
	    Ml_Debugger.FUN
	      (fn () =>
		 (MLWorks.Internal.Runtime.StorageManager.interface(40,2);()))))
@


1.47
log
@Debugger SIGNAL changed to INTERRUPT
@
text
@d19 3
d282 4
a285 1
                               Ml_Debugger.DO_RAISE Interrupt),
@


1.46
log
@Improving messages
@
text
@d19 3
d295 1
a295 1
         Ml_Debugger.SIGNAL s,
@


1.45
log
@GUI directory restructuring
@
text
@d19 3
d275 1
a275 1
         Ml_Debugger.POSSIBLE ("Return to TopLevel",
d293 1
a293 1
         Ml_Debugger.POSSIBLE ("Return to TopLevel",
d313 1
a313 1
	   ("Return to TopLevel", Ml_Debugger.DO_RAISE Interrupt),
d346 1
a346 1
         Ml_Debugger.POSSIBLE ("Return to TopLevel",
@


1.44
log
@Changes to Ml_Debugger signature
@
text
@d19 3
d179 1
a179 1
require "../motif/__podium";
@


1.43
log
@Add parameter to make_shell_structure to indicate image type (ie tty or motif)
@
text
@d19 3
d175 1
d187 1
a187 1
  structure Incremental = Ml_Debugger.Incremental
@


1.42
log
@Type of Ml_Debugger.ml_debugger has changed.
@
text
@d19 3
d193 3
a195 3
  val initial_context = ShellStructure_.make_shell_structure
			  (ShellTypes.shell_data_ref,
                           Incremental.initial)
@


1.41
log
@Type of Ml_Debugger.ml_debugger has changed.
@
text
@d19 3
d259 1
a259 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
d277 1
a277 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
d296 1
a296 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
d330 1
a330 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
@


1.40
log
@Add fatal signal handling.
@
text
@d19 3
d254 9
a262 10
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       context)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.FATAL_SIGNAL s,
       Ml_Debugger.POSSIBLE ("Return to TopLevel",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.NOT_POSSIBLE)
d273 10
a282 11
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       context)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.SIGNAL s,
       Ml_Debugger.POSSIBLE ("Return to TopLevel",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.POSSIBLE ("Continue interrupted code",
                             Ml_Debugger.NORMAL_RETURN))
d293 13
a305 11
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       context)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.STACK_OVERFLOW,
       Ml_Debugger.POSSIBLE ("Return to TopLevel",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.POSSIBLE ("Continue with extended stack",
                             Ml_Debugger.FUN (fn () => (MLWorks.Internal.Runtime.StorageManager.interface(40,2);()))))
d328 10
a337 11
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       context)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.BREAK s,
       Ml_Debugger.POSSIBLE ("Return to TopLevel",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.POSSIBLE ("Continue interrupted code",
                             Ml_Debugger.NORMAL_RETURN))
@


1.39
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d19 3
d243 19
d312 4
@


1.38
log
@Setting pervasive generalise function moved elsewhere
@
text
@d19 3
d167 30
a196 17
structure Options = TopLevel_.Options
structure UserContext = UserContext_
structure ShellTypes = ShellTypes_
structure Ml_Debugger = Ml_Debugger_
structure Incremental = Ml_Debugger.Incremental
structure Info = Info_

(* This is getting too big *)

fun default_prompter {name, topdec, line, subline} =
  implode [name, if subline > 0 then ">> " else "> "]

exception NoDebugger

val initial_context = ShellStructure_.make_shell_structure
			(ShellTypes.shell_data_ref,
                         Incremental.initial)
d198 2
a199 1
val _ = UserContext.makeInitialUserContext(initial_context,"Initial")
d211 1
a211 10
fun main arguments =
  let
    val user_options =
      UserOptions_.make_user_options
	(Options.default_options, Preferences_.default_preferences)
    val _ = case user_options of
      UserOptions_.USER_OPTIONS{1={generate_interruptable_code, ...}, ...} =>
	generate_interruptable_code := true
  (* want this on for the interpreter *)
  in
d213 7
a219 6
    (ShellTypes_.LISTENER_ARGS
     {user_context = UserContext.getNewInitialContext(),
      user_options = user_options,
      prompter=default_prompter,
      mk_xinterface_fn = Podium_.start_x_interface})
  end
@


1.37
log
@Remove script argument to ml_debugger
Change use of cast (again)
@
text
@d19 4
a161 2
require "../typechecker/__scheme";

a169 1
structure Scheme = Scheme_
a304 9

  val cast : 'a -> 'b = MLWorks.Internal.Value.cast

  val _ = MLWorks.Dynamic.generalises_ref :=
     (fn (ty,ty') =>
      (Scheme.generalises (cast ty,cast ty'))
      handle Scheme.MisMatch (t,t') => 
        raise MLWorks.Dynamic.Coerce(cast t,cast t'))
        
@


1.36
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d19 3
a249 1
      []
d270 1
a270 1
                             Ml_Debugger.FUN (fn () => (MLWorks.Internal.Runtime.StorageManager.interface(40,2);())))) []
a299 1
      (!MLWorks.Debugger.script)
d305 1
a305 1
  val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
d309 1
a309 1
      (Scheme.generalises (castit ty,castit ty'))
d311 1
a311 1
        raise MLWorks.Dynamic.Coerce(castit t,castit t'))
@


1.35
log
@Removing Mod_rules.print_times
@
text
@d19 3
a142 1
require "../debugger/__value_printer";
d145 1
d149 1
a149 1
require "../interpreter/__shell_structure";
d160 1
d178 1
a178 1
val _ = ShellTypes.makeInitialUserContext(initial_context,"Initial")
d202 1
a202 1
     {user_context = ShellTypes.getNewInitialContext(),
d301 2
a302 1
  val _ = MLWorks.Debugger.break_hook := break_function (ShellTypes.shell_data_ref)
@


1.34
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d19 3
a151 1
require "../typechecker/__mod_rules";
a155 2
val _ = Module_rules_.print_times := false;

a160 1
structure Module_rules = Module_rules_
d162 1
@


1.33
log
@Changing uses of cast
@
text
@d19 3
a159 1
structure Option = Incremental.InterMake.Option
@


1.32
log
@Interrupt handler raises wrong exception
@
text
@d19 3
d297 2
d301 3
a303 4
      (Scheme.generalises (MLWorks.Internal.Value.cast ty,
                           MLWorks.Internal.Value.cast ty'))
      handle Scheme.MisMatch (t,t') => raise MLWorks.Dynamic.Coerce(MLWorks.Internal.Value.cast t,
                                                                    MLWorks.Internal.Value.cast t'))
@


1.31
log
@Separated preferences from options.
@
text
@d19 3
d235 1
a235 1
                             Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
d257 1
a257 1
                             Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
d286 1
a286 1
                             Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
@


1.30
log
@Added comment about argument handling.
@
text
@d19 3
d132 1
d180 3
a182 1
    val user_options = UserOptions_.make_user_options(Options.default_options)
d225 3
a227 1
      (ShellTypes.get_current_options shell_data, context)
d247 3
a249 1
      (ShellTypes.get_current_options shell_data, context)
d276 3
a278 1
      (ShellTypes.get_current_options shell_data, context)
@


1.29
log
@Change interrupt and stack overflow handling.
@
text
@d19 3
d163 10
@


1.28
log
@Replaced context_ref with user_contexts.
@
text
@d19 3
d236 7
a242 3
  val _ = MLWorks.Internal.Runtime.Event.signal (30,stack_overflow_function ShellTypes.shell_data_ref)

  val _ = MLWorks.Internal.Runtime.Event.signal (2,interrupt_function ShellTypes.shell_data_ref)
@


1.27
log
@Stopped raising Interrupt on return from debugger.
@
text
@d19 3
d156 1
a156 1
val _ = ShellTypes.makeInitialContextRef(initial_context,"Initial")
d168 1
a168 1
     {context_ref = ShellTypes.getNewInitialContext(),
d199 1
a199 1
      val cref = ShellTypes.get_context_ref(ShellTypes.get_shell_context_ref shell_data)
d203 1
a203 1
      (ShellTypes.get_current_options shell_data, cref)
d219 1
a219 1
      val cref = ShellTypes.get_context_ref(ShellTypes.get_shell_context_ref shell_data)
d223 1
a223 1
      (ShellTypes.get_current_options shell_data, cref)
d242 1
a242 1
      val cref = ShellTypes.get_context_ref(ShellTypes.get_shell_context_ref shell_data)
d246 1
a246 1
      (ShellTypes.get_current_options shell_data, cref)
@


1.26
log
@Debugger scripts for tracing tool using debugger.
@
text
@d19 3
d204 2
a205 2
       Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
                             Ml_Debugger.DO_RAISE Interrupt),
d224 2
a225 2
       Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
                             Ml_Debugger.DO_RAISE Interrupt),
d247 2
a248 2
       Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
                             Ml_Debugger.DO_RAISE Interrupt),
@


1.25
log
@Minor changes in substructures.
@
text
@d19 3
d205 1
d224 1
a224 1
                             Ml_Debugger.FUN (fn () => (MLWorks.Internal.Runtime.StorageManager.interface(40,2);()))))
d248 1
@


1.24
log
@Changed implementation of last function to avoid gc problem
@
text
@d22 3
a113 1
require "../interpreter/__incremental";
a127 1
structure Info = Info_
a129 2
structure Incremental = Incremental_
structure Option = Incremental.InterMake.FileName.Option
d131 3
@


1.23
log
@Preserve pervasive modules.
@
text
@d19 6
d164 1
a164 1
  (* This is a ghastly function for setting the module table to just *)
d170 6
a175 3
      fun first (0,_,acc) = acc
        | first (_,[],acc) = acc
        | first (n,(a::b),acc) = first (n-1,b,a::acc)
d177 1
a177 1
      first (n,rev l,[])
@


1.22
log
@Changed initial value of user_options to have interrupt_tight_loops on
by default
@
text
@d19 4
d158 14
a171 1
  val _ = MLWorks.Internal.Runtime.modules := [];
@


1.21
log
@Merging bug fixes
@
text
@d19 3
d138 14
a151 7
  TTYListener_.listener
  (ShellTypes_.LISTENER_ARGS
   {context_ref = ShellTypes.getNewInitialContext(),
    user_options = UserOptions_.make_user_options Options.default_options,
    prompter=default_prompter,
    mk_xinterface_fn = Podium_.start_x_interface});
  
@


1.20
log
@Commented out SIGUSR1 handling for the moment
@
text
@d19 10
a165 2
(* Removed this bit until it's worked out properly *)
(*
d178 1
a178 1
      (Ml_Debugger.SIGNAL s,
d182 1
a182 1
                             Ml_Debugger.FUN (fn () => (MLWorks.Internal.Runtime.StorageManager.interface(40,0);()))))
a185 1
*)
@


1.20.1.1
log
@Fork for bug fixing
@
text
@a18 3
 *  Revision 1.20  1993/06/16  11:55:38  matthew
 *  Commented out SIGUSR1 handling for the moment
 *
@


1.20.1.2
log
@Uncommented stack overflow handler
Uses STACK_OVERFLOW mode in the debuggert
@
text
@a18 3
 *  Revision 1.20.1.1  1993/06/16  11:55:38  jont
 *  Fork for bug fixing
 *
d159 2
d173 1
a173 1
      (Ml_Debugger.STACK_OVERFLOW,
d177 1
a177 1
                             Ml_Debugger.FUN (fn () => (MLWorks.Internal.Runtime.StorageManager.interface(40,2);()))))
d181 1
@


1.19
log
@Added stack overflow function and SIGUSER1 handler
l
@
text
@d19 4
d156 2
d177 3
a180 2

  val _ = MLWorks.Internal.Runtime.Event.signal (30,stack_overflow_function ShellTypes.shell_data_ref)
@


1.18
log
@Removed the context field from the prompter.
@
text
@d19 3
d152 19
d172 2
@


1.17
log
@Removed integer parameter
@
text
@d19 3
d106 2
a107 11
fun default_prompter {name, topdec, line, subline, context} =
  let val context_name =
    ""
(*
    if context = 0
      then ""
    else "#" ^ MLWorks.Integer.makestring context
*)
  in
    implode [name,context_name, if subline > 0 then ">> " else "> "]
  end
@


1.16
log
@Interface to contextrefs has changed.
@
text
@d19 3
a71 1
require "../utils/__integer";
a92 1
structure Integer = Integer_
d109 1
a109 1
    else "#" ^ Integer.makestring context
@


1.15
log
@Changed type of ml_debugger.
@
text
@d19 3
d120 1
a120 1
val _ = ShellTypes.makeContextRef(initial_context,"Initial")
d125 4
a128 4
   {context_ref = ShellTypes.makeContextRef(initial_context,"MLWorks"),
   user_options = UserOptions_.make_user_options Options.default_options,
   prompter=default_prompter,
   mk_xinterface_fn = Podium_.start_x_interface});
@


1.14
log
@Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d19 3
d141 1
a141 2
      (ShellTypes.make_incremental_options shell_data,
       cref)
d162 1
a162 2
      (ShellTypes.make_incremental_options shell_data,
       cref)
@


1.13
log
@Added interrupt handler
@
text
@d19 42
a60 39
Revision 1.12  1993/05/07  15:34:00  matthew
Break function uses global start_frames and debugger type

Revision 1.11  1993/05/06  14:27:06  matthew
ShellTypes changes

Revision 1.10  1993/05/04  16:47:34  matthew
Changed context ref handling

Revision 1.9  1993/04/26  12:11:47  matthew
Removed ML_Debugger.BASE_FRAME

Revision 1.8  1993/04/08  08:39:43  matthew
Added MLWorks.Debugger structure
Set up generalise function in pervasives

Revision 1.7  1993/04/06  16:31:45  jont
Moved user_options and version from interpreter to main

Revision 1.6  1993/04/02  15:32:46  matthew
Signature changes

Revision 1.5  1993/03/30  12:56:42  matthew
Added pervasive break function
Sorted out a bit

Revision 1.4  1993/03/15  17:36:03  matthew
Simplified ShellTypes types

Revision 1.3  1993/03/11  14:50:03  matthew
Signature revisions

Revision 1.2  1993/03/08  15:48:10  matthew
Options & Info changes
Changes for ShellData type

Revision 1.1  1993/03/02  19:45:11  daveb
Initial revision

d110 3
a112 10
val initial_incremental_options =
  Incremental.OPTIONS
  {error_info = Info.default_options,
   options = Options.default_options,
   debugger = fn _ => raise NoDebugger
   }

val initial_context = ShellStructure_.make_shell_structure (ShellTypes.shell_data_ref,
                                                            Incremental.initial,
                                                            initial_incremental_options)
a120 1
   error_info = Info.default_options,
d131 1
a131 2
      val shell_data as ShellTypes.SHELL_DATA{error_info,
                                              prompter,
d153 1
a153 2
      val shell_data as ShellTypes.SHELL_DATA{error_info,
                                              prompter,
@


1.12
log
@Break function uses global start_frames and debugger type
@
text
@d19 3
d133 23
@


1.11
log
@ShellTypes changes
@
text
@d19 3
d131 20
a150 36
  fun break_function (shell_data_ref) =
    MLWorks.Internal.Value.frame_call
    (fn base_frame =>
     (fn s =>
      let
        val shell_data as ShellTypes.SHELL_DATA{error_info,
                                                prompter,
                                                mk_xinterface_fn,
                                                ...} = !shell_data_ref
        val cref = ShellTypes.get_context_ref(ShellTypes.get_shell_context_ref shell_data)
      in
        Ml_Debugger.ml_debugger 
        Ml_Debugger.TERMINAL
        (ShellTypes.make_incremental_options shell_data,
         cref)
        (fn context' => (output(std_out,"No shell in break debugger yet\n")))
(*         
         (listener 
          (ShellTypes.LISTENER_ARGS
           {context_ref = ref context',
            user_options =
            UserOptions.make_user_options (ShellTypes.get_current_options shell_data),
            error_info = error_info,
            prompter = prompter,
            mk_xinterface_fn = mk_xinterface_fn});
          ()))
*)
        base_frame
        (Ml_Debugger.BREAK s,
         Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
                               Ml_Debugger.DO_RAISE Interrupt),
         Ml_Debugger.POSSIBLE ("Continue interrupted code",
                               Ml_Debugger.NORMAL_RETURN
                               ));
        ()
      end))
@


1.10
log
@Changed context ref handling
@
text
@d19 3
a104 1
   name_monitor = Option.ABSENT,
a117 1
   print_method_table_ref = ref ValuePrinter_.default_print_method_table,
a119 1
   name_monitor = Option.PRESENT (fn s => output(std_out, "Make: compiling " ^ s)),
a133 1
                                                name_monitor,
d141 1
a141 2
        (ShellTypes.get_current_print_method_table shell_data,
         ShellTypes.make_incremental_options shell_data,
a147 2
            print_method_table_ref =
            ref (ShellTypes.get_current_print_method_table shell_data),
a150 1
            name_monitor = name_monitor,
@


1.9
log
@Removed ML_Debugger.BASE_FRAME
@
text
@d19 3
d86 2
d91 1
d109 3
d113 10
a122 9
  TTYListener_.listener (ShellTypes_.LISTENER_ARGS
                         {context_ref = ref initial_context,
                          print_method_table_ref = ref ValuePrinter_.default_print_method_table,
                          user_options = UserOptions_.make_user_options Options.default_options,
                          error_info = Info.default_options,
                          name_monitor = Option.PRESENT (fn s => output(std_out, "Make: compiling " ^ s)),
                          prompter=default_prompter,
                          mk_xinterface_fn = Podium_.start_x_interface});

d138 1
d144 1
a144 1
         ShellTypes.get_context_ref shell_data)
@


1.8
log
@Added MLWorks.Debugger structure
Set up generalise function in pervasives
@
text
@d19 4
d149 1
a149 1
        (Ml_Debugger.BASE_FRAME base_frame)
@


1.7
log
@Moved user_options and version from interpreter to main
@
text
@d19 3
d60 1
d73 2
a74 1

d155 10
a164 2
  val _ = MLWorks.Internal.Tracing.break_hook := break_function (ShellTypes.shell_data_ref)
  
@


1.6
log
@Signature changes
@
text
@d19 3
d47 1
a47 1
require "../interpreter/__user_options";
@


1.5
log
@Added pervasive break function
Sorted out a bit
@
text
@d19 4
d40 1
a40 3
require "__shell_types";
require "__tty_listener";
require "../motif/__podium";
d43 1
a43 1
require "../main/__info";
d45 2
d48 1
d63 1
a63 1
structure Incremental = ShellTypes.Incremental
@


1.4
log
@Simplified ShellTypes types
@
text
@d19 3
d34 1
d40 1
d43 1
d50 1
a50 4
Module_rules_.print_times := false;

fun default_prompter {name, topdec, line, subline} =
  implode [name, if subline > 0 then ">> " else "> "]
d52 1
d54 1
a56 1
structure Option = ShellTypes_.Incremental.InterMake.FileName.Option
d58 14
d75 11
d88 1
a88 2
                         {options_ref = ref Options.default_options,
                          context_ref = ref ShellTypes.Incremental.initial,
d96 4
a99 1
MLWorks.Internal.Runtime.modules := [];
d101 46
a146 1
MLWorks.exit (main (MLWorks.OS.arguments ()));
@


1.3
log
@Signature revisions
@
text
@d19 3
d59 8
a66 11
   (ShellTypes.SHELL_DATA
    {options_ref = ref Options.default_options,
     context_ref = ref ShellTypes.Incremental.initial,
     print_method_table_ref = ref ValuePrinter_.default_print_method_table,
     user_options = UserOptions_.make_user_options Options.default_options,
     error_info = Info.default_options,
     name_monitor = Option.PRESENT (fn s => output(std_out, "Make: compiling " ^ s)),
     debugger = fn _ => raise NoDebugger,
     prompter=default_prompter},
    fn args => fn () => Podium_.start_x_interface args
    ));
@


1.2
log
@Options & Info changes
Changes for ShellData type
@
text
@d19 4
d48 1
a48 1
structure Options = TopLevel_.Parser.Options
@


1.1
log
@Initial revision
@
text
@d18 4
a21 1
 *  $Log$
d29 2
d34 4
a37 1
require "../typechecker/__mod_rules"; Module_rules_.print_times := false;
d42 8
d51 10
a60 12
  TTYListener_.listener (ShellTypes_.LISTENER_ARGS(
    (TopLevel_.default_compiler_options,
     ShellTypes_.Incremental.InterMake.OPTIONS {
       name_monitor =
         ShellTypes_.Incremental.InterMake.FileName.Option.PRESENT (
           fn s => output(std_out, "Make: compiling " ^ s)
         ),
       compiler_options = TopLevel_.default_compiler_options
    }),
    ShellTypes_.Incremental.initial,
    default_prompter,
    ValuePrinter_.toplevel_default_print_descriptor,
d62 1
a62 1
  ));
@
