head	1.15;
access;
symbols
	MLW_daveb_inline_1_4_99:1.15.1
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.14
	MLWorks_20b2_Windows_1998_06_12:1.14
	MLWorks_20b1c1_1998_05_07:1.14
	MLWorks_20b0_1998_04_07:1.14
	MLWorks_20b0_1998_03_20:1.14
	MLWorks_20m2_1998_02_16:1.13
	MLWorks_20m1_1997_10_23:1.13
	MLWorks_11r1:1.13.5.1.1.1.1
	MLWorks_workspace_97:1.13.7
	MLWorks_dt_wizard:1.13.6
	MLWorks_11c0_1997_09_09:1.13.5.1.1.1
	MLWorks_10r3:1.13.5.1.3
	MLWorks_10r2_551:1.13.5.1.2
	MLWorks_11:1.13.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.13.5.1
	MLWorks_20m0_1997_06_20:1.13
	MLWorks_1_0_r2c2_1997_06_14:1.13.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.13.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.13.5
	MLWorks_BugFix_1997_04_24:1.13
	MLWorks_1_0_r2_Win32_1997_04_11:1.13
	MLWorks_1_0_r2_Unix_1997_04_04:1.13
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.13.3.1.1
	MLWorks_gui_1996_12_18:1.13.4
	MLWorks_1_0_Win32_1996_12_17:1.13.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.13.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.13.1.1
	MLWorks_1_0_Irix_1996_11_28:1.13.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.13.2
	MLWorks_1_0_Unix_1996_11_14:1.13.1
	MLWorks_Open_Beta2_1996_10_11:1.11.1
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.9
	MLWorks_Beta_1996_06_07:1.9
	MLWorks_Beta_1996_06_06:1.9
	MLWorks_Beta_1996_06_05:1.9
	MLWorks_Beta_1996_06_03:1.9
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.9;
locks; strict;
comment	@ * @;


1.15
date	99.02.02.16.00.01;	author mitchell;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	98.02.18.17.02.55;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.11.06.11.13.45;	author matthew;	state Exp;
branches
	1.13.1.1
	1.13.2.1
	1.13.3.1
	1.13.4.1
	1.13.5.1
	1.13.6.1
	1.13.7.1;
next	1.12;

1.12
date	96.10.09.11.56.30;	author io;	state Exp;
branches;
next	1.11;

1.11
date	96.10.02.15.01.53;	author andreww;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	96.08.06.16.13.52;	author andreww;	state Exp;
branches
	1.10.1.1
	1.10.2.1;
next	1.9;

1.9
date	96.05.01.10.41.01;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	96.04.30.09.40.09;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	96.01.11.12.15.33;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	96.01.10.14.09.29;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	96.01.10.13.12.17;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.10.06.14.10.12;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.09.29.00.01.50;	author brianm;	state Exp;
branches;
next	1.2;

1.2
date	95.07.24.15.53.32;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	95.07.17.11.48.06;	author matthew;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.15.28;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.05.44;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	96.10.17.11.24.01;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	96.11.14.12.48.28;	author hope;	state Exp;
branches
	1.13.1.1.1.1;
next	;

1.13.1.1.1.1
date	96.11.28.15.00.02;	author hope;	state Exp;
branches;
next	;

1.13.2.1
date	96.11.22.18.08.24;	author hope;	state Exp;
branches;
next	;

1.13.3.1
date	96.12.17.17.47.05;	author hope;	state Exp;
branches
	1.13.3.1.1.1;
next	;

1.13.3.1.1.1
date	97.02.24.11.36.45;	author hope;	state Exp;
branches;
next	;

1.13.4.1
date	96.12.18.09.41.05;	author hope;	state Exp;
branches;
next	;

1.13.5.1
date	97.05.12.10.33.31;	author hope;	state Exp;
branches
	1.13.5.1.1.1
	1.13.5.1.2.1
	1.13.5.1.3.1;
next	;

1.13.5.1.1.1
date	97.07.28.18.19.01;	author daveb;	state Exp;
branches
	1.13.5.1.1.1.1.1;
next	;

1.13.5.1.1.1.1.1
date	97.10.07.11.44.09;	author jkbrook;	state Exp;
branches;
next	;

1.13.5.1.2.1
date	97.09.08.17.12.38;	author daveb;	state Exp;
branches;
next	;

1.13.5.1.3.1
date	97.09.09.14.08.16;	author daveb;	state Exp;
branches;
next	;

1.13.6.1
date	97.09.10.19.23.21;	author brucem;	state Exp;
branches;
next	;

1.13.7.1
date	97.09.11.20.54.24;	author daveb;	state Exp;
branches;
next	;

1.15.1.1
date	99.04.01.17.56.35;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Moved from motif
@


1.15
log
@[Bug #190500]
Remove redundant require statements
@
text
@(*
 * Copyright (c) 1995 Harlequin Ltd.
 *
 * $Log: _entry.sml,v $
 * Revision 1.14  1998/02/18  17:02:55  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 * Revision 1.13  1996/11/06  11:13:45  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.12  1996/10/09  11:56:30  io
 * moving String from toplevel
 *
 * Revision 1.11  1996/10/02  15:01:53  andreww
 * [Bug #1592]
 * threading level info in tynames.
 *
 * Revision 1.10  1996/08/06  16:13:52  andreww
 * [Bug #1521]
 *
 * Propagating changes made to typechecker/_types.sml to print
 * imperative type vars with an underscore only if not using
 * value polymorphism.  This requires said flat to be passed to the
 * print functions.  For debugging, we allow underscores to be printed.
 *
 * Revision 1.9  1996/05/01  10:41:01  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.8  1996/04/30  09:40:09  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.7  1996/01/11  12:15:33  matthew
 * More improvements
 *
 *  Revision 1.6  1996/01/10  14:09:29  matthew
 *  More search improvements
 *
 *  Revision 1.5  1996/01/10  13:12:17  matthew
 *  Simplification
 *
 *  Revision 1.4  1995/10/06  14:10:12  daveb
 *  Made searchOptions be a datatype.   Added searchContext field.
 *  Removed update function.
 *
 *  Revision 1.3  1995/09/29  00:01:50  brianm
 *  Adding is_tip function ...
 *
 *  Revision 1.2  1995/07/24  15:53:32  daveb
 *  Corrected get_id's treatment of functors: they do have sub-components so the
 *  second part of get_id's result should be false.
 *
 *  Revision 1.1  1995/07/17  11:48:06  matthew
 *  new unit
 *  Moved from motif
 *
 *
 *)

require "../basis/__int";
require "^.utils.__terminal";

require "../main/user_options";
require "../utils/crash";
require "../basics/identprint";
require "../interpreter/incremental";
require "../typechecker/basistypes";
require "../typechecker/types";
require "../typechecker/valenv";
require "../typechecker/scheme";

require "entry";


functor Entry(
  structure IdentPrint : IDENTPRINT
  structure Incremental : INCREMENTAL
  structure BasisTypes : BASISTYPES
  structure Types : TYPES
  structure Valenv : VALENV
  structure Scheme : SCHEME
  structure Crash : CRASH
  structure UserOptions : USER_OPTIONS

  sharing IdentPrint.Ident = BasisTypes.Datatypes.Ident = Types.Datatypes.Ident
  sharing IdentPrint.Options = UserOptions.Options = Types.Options
  sharing Valenv.Datatypes = Types.Datatypes = BasisTypes.Datatypes

  sharing type Incremental.InterMake.Compiler.TypeBasis =  BasisTypes.Basis

) : ENTRY =
struct

  structure Datatypes = BasisTypes.Datatypes
  structure Ident = Datatypes.Ident
  structure Options = UserOptions.Options
  structure NewMap = Datatypes.NewMap

  type options = Options.options
  type Context = Incremental.Context
  type Identifier = Ident.Identifier


  fun print_options (Options.OPTIONS{print_options,...}) = print_options


  datatype Entry =
    VAR    of (Ident.ValId * Datatypes.Typescheme)
  | CONVAR of (Ident.ValId * Datatypes.Typescheme)
    (* Constructor in a structure or at top-level *)
  | CONENV of (Ident.ValId * Datatypes.Typescheme)
    (* Constructor in a constructor environment *)
  | EXN    of (Ident.ValId * Datatypes.Typescheme)
  | TYPE   of Ident.TyCon * Datatypes.Tystr
  (* unconverted *)
  | STR    of Ident.StrId * Datatypes.Structure
  | SIG    of Ident.SigId * BasisTypes.Sigma
  | FUN    of Ident.FunId * BasisTypes.Phi
  (* converted for search munging purposes   *)
  | NSIG   of Ident.SigId * (Entry list)
  | NSTR   of Ident.StrId * (Entry list)
  | NFUN   of Ident.FunId * (Entry list)

  fun fst (x,_) = x
    
  datatype SearchOptions =
    SEARCH_OPTIONS of
      {showSig : bool,        (* search inside signatures *)
       showStr : bool,        (* search inside structures *)
       showFun : bool,        (* search inside functors   *)
       searchInitial : bool,  (* search initial context, used in listener *)
       searchContext : bool,  (* search user context, used in listener *)
       showType : bool        (* show types of search results *)
       }

  (* Miscellaneous Utilities that should be separated out *)
  fun debug_output s = Terminal.output(s ^"\n")

  (* get_id returns the string to print, and a boolean that indicates
     whether this is the last component of a name. *)
  local
    val printValId = fn id => IdentPrint.printValId Options.default_print_options id
  in
    fun get_id e = case e of
      VAR (id,_)    => (printValId id, true)
    | CONVAR (id,_) => (printValId id, true)
    | CONENV (id,_) => (printValId id, true)
    | EXN (id,_)    => (printValId id, true)
    | TYPE (id,_)   => (IdentPrint.printTyCon id ^ "<type>", true)
    | STR (id,_)    => (IdentPrint.printStrId id, false)
    | SIG (id,_)    => (IdentPrint.printSigId id ^ "<signature>", false)
    | FUN (id,_)    => (IdentPrint.printFunId id ^ "<functor>", false)
    | NSIG _ => Crash.impossible "NSIG uncaught"
    | NSTR _ => Crash.impossible "NSTR uncaught"
    | NFUN _ => Crash.impossible "NFUN uncaught"
  end (* local *)

  (* splits up variable and exception names *)
  fun split_vallist e = let
    fun split_vallist ([], vars, exns) = (rev vars, rev exns)
      |   split_vallist ((pair as (Ident.VAR _, _)) :: l, vars, exns) =
	  split_vallist (l, VAR pair :: vars, exns)
      |   split_vallist ((pair as (Ident.CON _, _)) :: l, vars, exns) =
	  split_vallist (l, CONVAR pair :: vars, exns)
      |   split_vallist ((pair as (Ident.EXCON _, _)) :: l, vars, exns) =
	  split_vallist (l, vars, EXN pair :: exns)
      |   split_vallist _ = Crash.impossible "TYCON':split_vallist:browser_tool"
  in
    split_vallist (e,[],[])
  end (* let *)

  fun printOverloaded (Datatypes.UNARY (_, tyvar)) =
    let val olvar = IdentPrint.printTyVar tyvar
    in
      concat [olvar, " -> ", olvar]
    end
    | printOverloaded (Datatypes.BINARY (_, tyvar)) =
      let val olvar = IdentPrint.printTyVar tyvar
      in
	concat [olvar, " * ", olvar, " -> ", olvar]
      end
    | printOverloaded (Datatypes.PREDICATE (_, tyvar)) =
      let val olvar = IdentPrint.printTyVar tyvar
      in
	concat [olvar, " * ", olvar, " -> bool"]
      end

  fun printValScheme options (Datatypes.SCHEME (arity, (ty,_))) =
    Types.print_type options ty
    |   printValScheme options (Datatypes.UNBOUND_SCHEME (ty,_)) =
	Types.print_type options ty
    |   printValScheme _ (Datatypes.OVERLOADED_SCHEME overloaded) =
	printOverloaded overloaded
	
  fun print_tyvars options n = Types.print_tyvars options (Types.make_tyvars n)
    
  fun printTyFun options (tycon, Datatypes.TYFUN (ty, arity)) =
    print_tyvars options arity ^ " " ^ IdentPrint.printTyCon tycon
    |   printTyFun options (tycon, Datatypes.ETA_TYFUN tyname) =
	print_tyvars options (case tyname of
			Datatypes.TYNAME (_, _, n, _, _,_,_,_,_) => n
		      | Datatypes.METATYNAME (_, _, n, _, _, _) => n) ^
	" " ^ IdentPrint.printTyCon tycon
    |   printTyFun options (tycon, Datatypes.NULL_TYFUN (id,_)) =
        Int.toString (Types.stamp_num id)
	
  fun printConScheme options (Datatypes.SCHEME (arity, (ty,_))) =
    (case Types.apply (Datatypes.TYFUN (ty, arity),
		       Types.make_tyvars arity) of
       Datatypes.FUNTYPE (arg, _) =>
	 " of " ^ Types.print_type options arg
     | _ => "")
    |   printConScheme options (Datatypes.UNBOUND_SCHEME
				      (Datatypes.FUNTYPE (arg, _),_)) =
	" of " ^ Types.print_type options arg
    |   printConScheme _ (Datatypes.UNBOUND_SCHEME _) =
	""
    |   printConScheme _ (Datatypes.OVERLOADED_SCHEME _) =
	" <strange overloaded scheme>"
	
  fun printValenv options (Datatypes.VE (_,amap)) =
    let fun printMember ((first, str), valid, typescheme) =
      (false,
       concat
       [str,
	if first then "" else " | ",
	  IdentPrint.printValId (print_options options) valid,
	  printConScheme options typescheme])
    in
      NewMap.fold printMember ((true, ""), amap)
    end

  (* val printEntry : string Options.print_options -> Entry -> string *)
  fun printEntry options e = let
    val print_options = print_options options
    val printValId = fn id => IdentPrint.printValId print_options id
    val printValScheme = fn ts => printValScheme options ts
    val printStrId = fn id => IdentPrint.printStrId id
  in 
    case e of
      VAR (id,ts) =>    "val " ^ (printValId id) ^ " : " ^ (printValScheme ts)
    | CONVAR (id,ts) => "val " ^ (printValId id) ^ " : " ^ (printValScheme ts)
    | CONENV (id,ts) => "val " ^ (printValId id) ^ " : " ^ (printValScheme ts)
    | EXN    (id,ts) => "exception " ^ (printValId id) ^ (printConScheme options ts)
    | TYPE   (id,Datatypes.TYSTR (tyfun, valenv)) =>
	if Valenv.empty_valenvp valenv then
	  if Types.equalityp tyfun then
	    "eqtype " ^ (printTyFun options (id, tyfun))
	  else
	    "type " ^ (printTyFun options (id, tyfun))
	else
	  "datatype " ^ (printTyFun options (id, tyfun)) ^ " = " ^
	  #2(printValenv options valenv)
    | STR (id, str) => "structure " ^ (IdentPrint.printStrId id) 
    | SIG (id, ts)  => "signature " ^ (IdentPrint.printSigId id)
    | FUN (id, ts)  => "functor "   ^ (IdentPrint.printFunId id)
    | NSIG _ => Crash.impossible "printEntry NSIG unhandled"
    | NSTR _ => Crash.impossible "printEntry NSTR unhandled"
    | NFUN _ => Crash.impossible "printEntry NFUN unhandled"
  end

  (* This is my stupid fn to do a search, pick up the module qualifiers
     and do it for only sig, funct or structure and allow the matched
     entries to have their type be displayed
   *)

  fun printEntry1 (SEARCH_OPTIONS searchOptions, options, entry) =
  let
    val printValId = fn id => IdentPrint.printValId (print_options options) id
    val printValScheme = fn ts =>printValScheme options ts
    val printValenv = fn id => printValenv options id
    val printConScheme = fn ts =>printConScheme options ts
    val printStrId = fn id => IdentPrint.printStrId id

    fun printEntry1 (acc, prefix, []) = acc
      | printEntry1 (acc, prefix, e::es) =
        (case e of
           NSIG (id,si) =>
             if (#showSig searchOptions) then 
               let
                 val id = IdentPrint.printSigId id
                 val this = prefix ^ id
                 val entrys = printEntry1 ([], this ^ ".", si)
               in 
                 printEntry1 (("signature " ^ this, id) :: entrys @@ acc, prefix, es) 
               end
             else printEntry1 (acc,prefix, es)
         | NSTR (id,str) =>
             if (#showStr searchOptions) 
               then 
                 let
                   val id = IdentPrint.printStrId id
                   val this = prefix ^ id
                   val entrys = printEntry1 ([], this ^ ".", str)
                 in
                   printEntry1 (("structure " ^ this, id) :: entrys@@acc, prefix, es) 
                 end
             else printEntry1 (acc, prefix, es)
         | NFUN (id, ts) =>
             if (#showFun searchOptions) 
               then
                 let
                   val id = IdentPrint.printFunId id
                   val this = prefix ^ id
                   val entrys = printEntry1 ([], this^".", ts)
                 in 
                   printEntry1 (("functor " ^ this,id)::entrys@@acc, prefix, es)
                 end
             else printEntry1 (acc, prefix, es)
         | _ => 
             if (#showType searchOptions) 
               then
                 case e of
                   VAR (id, ts) => printEntry1
                     (("val "^ prefix^(printValId id)^" : "^(printValScheme ts),printValId id)::acc,
                      prefix, es)
                 | CONVAR (id, ts) => printEntry1
                     (("val "^prefix^(printValId id)^(printValScheme ts),printValId id)::acc,
                      prefix, es)
                 | CONENV (id, ts) => printEntry1
                     (("val " ^ prefix ^ (printValId id) ^ " : " ^ (printValScheme ts),printValId id) :: acc,
                      prefix, es)
                 | EXN (id,ts) => printEntry1
                     (("exception " ^ prefix ^ (printValId id) ^ (printConScheme ts),printValId id)::acc,
                      prefix, es)
                 | TYPE (id, Datatypes.TYSTR (tyfun, valenv)) => printEntry1
                     ((if Valenv.empty_valenvp valenv then
                         if Types.equalityp tyfun then
                           "eqtype " ^ prefix ^(printTyFun options (id, tyfun))
                         else
                           "type " ^ prefix ^ (printTyFun options (id, tyfun))
                       else
                         "datatype " ^ prefix ^ (printTyFun options (id, tyfun)) ^ " = " ^
                         #2(printValenv valenv),printTyFun options (id,tyfun)) :: acc,
                         prefix, es)
                 | e => Crash.impossible "unconverted SIG STR FUN unhandled"
             else
               let
                 val entry = fst (get_id e)
               in
                 printEntry1 ((prefix^entry,entry)::acc, prefix, es)
               end)
  in 
    printEntry1 ([], "", entry)
  end (* printEntry1 *)

  fun is_tip (STR(_)) = false  (* structure *)
    | is_tip (SIG(_)) = false  (* signature *)
    | is_tip (FUN(_)) = false  (* functor   *)
    | is_tip(_)       = true   (* otherwise *)


  fun browse_env
    (Datatypes.ENV
     (Datatypes.SE se,
      Datatypes.TE te,
      Datatypes.VE (_, ve))) = let

	val strlist = NewMap.to_list_ordered se
        val tylist = NewMap.to_list_ordered te
        val vallist = NewMap.to_list_ordered ve

        val strlist' = map STR strlist
        val tylist' = map TYPE tylist
        val (varlist, exnlist) = split_vallist vallist
      in
        strlist' @@ tylist' @@ exnlist @@ varlist
      end

  fun browse_str (Datatypes.STR(_,_,env))   = browse_env env
    | browse_str (Datatypes.COPYSTR(_,str)) = browse_str str

  fun browse_conenv (Datatypes.VE (_, ve)) =
    map CONENV (NewMap.to_list_ordered ve)
  fun browse_sigma (BasisTypes.SIGMA (_,str)) = browse_str str

  fun massage (SIG (id, sigma)) = NSIG (id, map massage (browse_sigma sigma))
    | massage (STR (id, str)) = NSTR (id, map massage (browse_str str))
    | massage (FUN (id, BasisTypes.PHI (_, (str, sigma)))) = NFUN (id, map massage (browse_sigma sigma))
    | massage e = e

  (* This is used by the context browser *)
  fun browse_entry showConEnv (VAR _) = []
    | browse_entry showConEnv (CONVAR _) = []
    | browse_entry showConEnv (CONENV _) = []
    | browse_entry showConEnv (EXN _) = []
    | browse_entry showConEnv (TYPE (id, Datatypes.TYSTR (_, conenv))) =
      if not showConEnv then
        [] else browse_conenv conenv
    | browse_entry showConEnv (STR (_, str)) = browse_str str
    | browse_entry showConEnv (SIG (_, sigma)) = browse_sigma sigma
    | browse_entry showConEnv (FUN (_, BasisTypes.PHI (_, (str, sigma)))) = browse_sigma sigma
    | browse_entry showConEnv x = Crash.impossible "browse_entry barfed"

  fun env2entry
    (Datatypes.ENV
     (Datatypes.SE se,
      Datatypes.TE te,
      Datatypes.VE (_, ve))) = let

	val strl = map STR (NewMap.to_list_ordered se)
	val tyl = map TYPE (NewMap.to_list_ordered te)
	val (exnl, vall) = split_vallist (NewMap.to_list_ordered ve)
      in
	strl @@ tyl @@ exnl @@ vall
      end (* env2entry *)

  fun context2entry context =
    let
      val (BasisTypes.BASIS
           (_,_, BasisTypes.FUNENV fune,
            BasisTypes.SIGENV sige, env)) = Incremental.type_basis context
      (*
      val sigl = NewMap.to_list_ordered se
      val funl = NewMap.to_list_ordered fe
      *)
      val sigl = map SIG (NewMap.to_list_ordered sige)
      val funl = map FUN (NewMap.to_list_ordered fune)
      val envl = env2entry env
    in
      sigl @@ funl @@ envl
    end (* context2entry *)

  (* These references control which entries are displayed. *)
  datatype BrowseOptions =
    BROWSE_OPTIONS of
    {show_sigs : bool ref,
     show_funs : bool ref,
     show_strs : bool ref,
     show_types : bool ref,
     show_exns : bool ref,
     show_vars : bool ref,
     (* show_conenvs controls whether the bodies of datatypes are
      displayed inline.  show_cons controls whether constructors
      are included in the list of values. *)
     show_conenvs : bool ref,
     show_cons : bool ref
     }

  fun new_options () =
    BROWSE_OPTIONS
    {show_sigs = ref true,
     show_funs = ref true,
     show_strs = ref true,
     show_types = ref true,
     show_exns = ref true,
     show_vars = ref true,
     show_conenvs = ref true,
     show_cons = ref false}

  fun filter_entries options entries =
    let
      val BROWSE_OPTIONS 
        {show_vars,
         show_cons,
         show_exns,
         show_types,
         show_strs,
         show_sigs,
         show_funs,
         ...} = options
      fun aux ([],acc) = rev acc
        | aux (entry::entries,acc) =
          let
            val is_selected =
              case entry
                of VAR _ => !show_vars
                 |  CONVAR _ => !show_cons
                 |  CONENV _ => true
                 |  EXN _ => !show_exns
                 |  TYPE _ => !show_types
                 |  STR _ => !show_strs
                 |  SIG _ => !show_sigs
                 |  FUN _ => !show_funs
                 |  NSTR _ => !show_strs
                 |  NSIG _ => !show_sigs
                 |  NFUN _ => !show_funs
          in
            if is_selected then
              aux (entries,entry :: acc)
            else
              aux (entries,acc)
          end
    in
      aux (entries,[])
    end

  fun get_entry (identifier,context) =
    let
      val BasisTypes.BASIS (_,_, BasisTypes.FUNENV fe,
                            BasisTypes.SIGENV ge, env) =
        Incremental.type_basis (context)
	      
      val (Datatypes.ENV
           (Datatypes.SE se,
            Datatypes.TE te,
            Datatypes.VE (_, ve))) = env
	      
    in 
      case identifier of
        Ident.VALUE i =>
          NONE
         |  Ident.TYPE i =>
              SOME
              (TYPE (i, NewMap.apply' (te, i)))
         |  Ident.STRUCTURE i =>
              SOME
              (STR (i, NewMap.apply' (se, i)))
         |  Ident.SIGNATURE i =>
              SOME
              (SIG (i, NewMap.apply' (ge, i)))
         |  Ident.FUNCTOR i =>
              SOME
              (FUN (i, NewMap.apply' (fe, i)))
    end
 
end (* functor *)	
@


1.15.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a4 4
 * Revision 1.15  1999/02/02  16:00:01  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.14
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d5 4
a74 1
require "../utils/lists";
@


1.13
log
@[Bug #1728]
__integer becomes __int
@
text
@d5 4
d61 1
d138 1
a138 1
  fun debug_output s = MLWorks.IO.output(MLWorks.IO.terminal_out, s ^"\n")
@


1.13.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a4 4
 * Revision 1.13  1996/11/06  11:13:45  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a4 4
 * Revision 1.13  1996/11/06  11:13:45  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.5.1
log
@branched from 1.13
@
text
@a4 4
 * Revision 1.13  1996/11/06  11:13:45  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a4 3
 * Revision 1.13.5.1  1997/05/12  10:33:31  hope
 * branched from 1.13
 *
@


1.13.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a4 3
 * Revision 1.13.5.1  1997/05/12  10:33:31  hope
 * branched from 1.13
 *
@


1.13.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a4 3
 * Revision 1.13.5.1  1997/05/12  10:33:31  hope
 * branched from 1.13
 *
@


1.13.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a4 3
 * Revision 1.13.5.1.1.1  1997/07/28  18:19:01  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.13.4.1
log
@branched from 1.13
@
text
@a4 4
 * Revision 1.13  1996/11/06  11:13:45  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.3.1
log
@branched from 1.13
@
text
@a4 4
 * Revision 1.13  1996/11/06  11:13:45  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.3.1.1.1
log
@branched from 1.13.3.1
@
text
@a4 3
 * Revision 1.13.3.1  1996/12/17  17:47:05  hope
 * branched from 1.13
 *
@


1.13.2.1
log
@branched from 1.13
@
text
@a4 4
 * Revision 1.13  1996/11/06  11:13:45  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.1.1
log
@branched from 1.13
@
text
@a4 4
 * Revision 1.13  1996/11/06  11:13:45  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.1.1.1.1
log
@branched from 1.13.1.1
@
text
@a4 3
 * Revision 1.13.1.1  1996/11/14  12:48:28  hope
 * branched from 1.13
 *
@


1.12
log
@moving String from toplevel
@
text
@d5 3
d56 1
a56 1
require "../basis/__integer";
@


1.11
log
@[Bug #1592]
threading level info in tynames.
@
text
@d5 4
d168 1
a168 1
      String.implode [olvar, " -> ", olvar]
d173 1
a173 1
	String.implode [olvar, " * ", olvar, " -> ", olvar]
d178 1
a178 1
	String.implode [olvar, " * ", olvar, " -> bool"]
d217 1
a217 1
       String.implode
d495 1
a495 1
          MLWorks.Option.NONE
d497 1
a497 1
              MLWorks.Option.SOME
d500 1
a500 1
              MLWorks.Option.SOME
d503 1
a503 1
              MLWorks.Option.SOME
d506 1
a506 1
              MLWorks.Option.SOME
@


1.11.1.1
log
@branched from 1.11
@
text
@a4 4
 * Revision 1.11  1996/10/02  15:01:53  andreww
 * [Bug #1592]
 * threading level info in tynames.
 *
@


1.10
log
@[Bug #1521]

Propagating changes made to typechecker/_types.sml to print
imperative type vars with an underscore only if not using
value polymorphism.  This requires said flat to be passed to the
print functions.  For debugging, we allow underscores to be printed.
@
text
@d5 8
d190 1
a190 1
			Datatypes.TYNAME (_, _, n, _, _,_,_,_) => n
@


1.10.2.1
log
@branched from 1.10
@
text
@a4 8
 * Revision 1.10  1996/08/06  16:13:52  andreww
 * [Bug #1521]
 *
 * Propagating changes made to typechecker/_types.sml to print
 * imperative type vars with an underscore only if not using
 * value polymorphism.  This requires said flat to be passed to the
 * print functions.  For debugging, we allow underscores to be printed.
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a4 8
 * Revision 1.10  1996/08/06  16:13:52  andreww
 * [Bug #1521]
 *
 * Propagating changes made to typechecker/_types.sml to print
 * imperative type vars with an underscore only if not using
 * value polymorphism.  This requires said flat to be passed to the
 * print functions.  For debugging, we allow underscores to be printed.
 *
@


1.9
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d5 6
d80 1
a80 1
  type PrintOptions = Options.print_options
d84 4
d169 4
a172 4
  fun printValScheme print_options (Datatypes.SCHEME (arity, (ty,_))) =
    Types.print_type print_options ty
    |   printValScheme print_options (Datatypes.UNBOUND_SCHEME (ty,_)) =
	Types.print_type print_options ty
d176 1
a176 1
  fun print_tyvars n = Types.print_tyvars (Types.make_tyvars n)
d178 4
a181 4
  fun printTyFun (tycon, Datatypes.TYFUN (ty, arity)) =
    print_tyvars arity ^ " " ^ IdentPrint.printTyCon tycon
    |   printTyFun (tycon, Datatypes.ETA_TYFUN tyname) =
	print_tyvars (case tyname of
d185 1
a185 1
    |   printTyFun (tycon, Datatypes.NULL_TYFUN (id,_)) =
d188 1
a188 1
  fun printConScheme print_options (Datatypes.SCHEME (arity, (ty,_))) =
d192 1
a192 1
	 " of " ^ Types.print_type print_options arg
d194 1
a194 1
    |   printConScheme print_options (Datatypes.UNBOUND_SCHEME
d196 1
a196 1
	" of " ^ Types.print_type print_options arg
d202 1
a202 1
  fun printValenv print_options (Datatypes.VE (_,amap)) =
d208 2
a209 2
	  IdentPrint.printValId print_options valid,
	  printConScheme print_options typescheme])
d215 2
a216 1
  fun printEntry print_options e = let
d218 1
a218 1
    val printValScheme = fn ts => printValScheme print_options ts
d225 1
a225 1
    | EXN    (id,ts) => "exception " ^ (printValId id) ^ (printConScheme print_options ts)
d229 1
a229 1
	    "eqtype " ^ (printTyFun (id, tyfun))
d231 1
a231 1
	    "type " ^ (printTyFun (id, tyfun))
d233 2
a234 2
	  "datatype " ^ (printTyFun (id, tyfun)) ^ " = " ^
	  #2(printValenv print_options valenv)
d248 1
a248 1
  fun printEntry1 (SEARCH_OPTIONS searchOptions, printOptions, entry) =
d250 4
a253 4
    val printValId = fn id => IdentPrint.printValId printOptions id
    val printValScheme = fn ts =>printValScheme printOptions ts
    val printValenv = fn id => printValenv printOptions id
    val printConScheme = fn ts =>printConScheme printOptions ts
d310 1
a310 1
                           "eqtype " ^ prefix ^ (printTyFun (id, tyfun))
d312 1
a312 1
                           "type " ^ prefix ^ (printTyFun (id, tyfun))
d314 2
a315 2
                         "datatype " ^ prefix ^ (printTyFun (id, tyfun)) ^ " = " ^
                         #2(printValenv valenv),printTyFun (id,tyfun)) :: acc,
@


1.8
log
@Removing MLWorks.Integer
@
text
@d5 3
d108 1
a108 1
  fun debug_output s = output(MLWorks.IO.terminal_out, s ^"\n")
d146 1
a146 1
      implode [olvar, " -> ", olvar]
d151 1
a151 1
	implode [olvar, " * ", olvar, " -> ", olvar]
d156 1
a156 1
	implode [olvar, " * ", olvar, " -> bool"]
d195 1
a195 1
       implode
@


1.7
log
@More improvements
@
text
@d5 3
d32 2
d173 1
a173 1
        MLWorks.Integer.makestring (Types.stamp_num id)
@


1.6
log
@More search improvements
@
text
@d5 6
d239 66
a304 76
	if (#showType searchOptions) then let in
	  case e of
	    VAR (id, ts) => printEntry1
	      (("val "^ prefix^(printValId id)^" : "^(printValScheme ts),printValId id)::acc,
	       prefix, es)
	  | CONVAR (id, ts) => printEntry1
	      (("val "^prefix^(printValId id)^(printValScheme ts),printValId id)::acc,
	       prefix, es)
	  | CONENV (id, ts) => printEntry1
	      (("val " ^ prefix ^ (printValId id) ^ " : " ^ (printValScheme ts),printValId id) :: acc,
	      prefix, es)
	  | EXN (id,ts) => printEntry1
	      (("exception " ^ prefix ^ (printValId id) ^ (printConScheme ts),printValId id)::acc,
	       prefix, es)
	  | TYPE (id, Datatypes.TYSTR (tyfun, valenv)) => printEntry1
	      ((if Valenv.empty_valenvp valenv then
		  if Types.equalityp tyfun then
		    "eqtype " ^ prefix ^ (printTyFun (id, tyfun))
		  else
		    "type " ^ prefix ^ (printTyFun (id, tyfun))
		else
		  "datatype " ^ prefix ^ (printTyFun (id, tyfun)) ^ " = " ^
		  #2(printValenv valenv),printTyFun (id,tyfun)) :: acc,
	      prefix, es)
	  | NSIG (id,si) =>
	      if (#showSig searchOptions) then 
                let
                  val entrys = printEntry1 ([], prefix^IdentPrint.printSigId id^".", si)
                in 
                  printEntry1 (entrys@@acc, prefix, es) 
                end
	      else printEntry1 (acc,prefix, es)
	  | NSTR (id,str) =>
	      if (#showStr searchOptions) then
                let
                  val entrys = printEntry1 ([], prefix ^ IdentPrint.printStrId id ^ ".", str)
                in 
                  printEntry1 (entrys@@acc, prefix, es) 
                end
	      else printEntry1 (acc, prefix, es)
	  | NFUN (id, ts) =>
	      if (#showFun searchOptions) then
                let
                  val entrys = printEntry1 ([], prefix ^ IdentPrint.printFunId id ^ ".", ts)
                in 
                  printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc, prefix, es)
	  | e => Crash.impossible "unconverted SIG STR FUN unhandled"
	end (* if *)
	else case e of
	  NSIG (id,si) =>
	      if (#showSig searchOptions) then let
		val entrys = printEntry1 ([], prefix^IdentPrint.printSigId id^".", si)
	      in printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc,prefix, es)
	  | NSTR (id,str) =>
	      if (#showStr searchOptions) then let
		val entrys = printEntry1 ([], prefix^IdentPrint.printStrId id^".", str)
	      in printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc, prefix, es)
	  | NFUN (id, ts) =>
	      if (#showFun searchOptions) then
                let
                  val entrys = printEntry1
                    ([], prefix^IdentPrint.printFunId id^".", ts)
                in 
                  printEntry1 (entrys@@acc, prefix, es) 
                end
	      else printEntry1 (acc, prefix, es)
          | _ => printEntry1
              let
                val entry = fst (get_id e)
              in
                ((prefix^entry,entry)::acc, prefix, es)
              end

@


1.5
log
@Simplification
@
text
@a128 17
  fun browse_env
    (Datatypes.ENV
     (Datatypes.SE se,
      Datatypes.TE te,
      Datatypes.VE (_, ve))) = let

	val strlist = NewMap.to_list_ordered se
        val tylist = NewMap.to_list_ordered te
        val vallist = NewMap.to_list_ordered ve

        val strlist' = map STR strlist
        val tylist' = map TYPE tylist
        val (varlist, exnlist) = split_vallist vallist
      in
        strlist' @@ tylist' @@ exnlist @@ varlist
      end

a221 77
(*
  fun printEntry1 (SEARCH_OPTIONS searchOptions, printOptions, entry) =
  let
    val printValId = fn id => IdentPrint.printValId printOptions id
    val printValScheme = fn ts =>printValScheme printOptions ts
    val printValenv = fn id => printValenv printOptions id
    val printConScheme = fn ts =>printConScheme printOptions ts
    val printStrId = fn id => IdentPrint.printStrId id

    fun printEntry1 (acc, prefix, []) = acc
      | printEntry1 (acc, prefix, e::es) =
	if (#showType searchOptions) then let in
	  case e of
	    VAR (id, ts) => printEntry1
	      (["val "^ prefix^(printValId id)^" : "^(printValScheme ts)]::acc,
	       prefix, es)
	  | CONVAR (id, ts) => printEntry1
	      (["val "^prefix^(printValId id)^(printValScheme ts)]::acc,
	       prefix, es)
	  | CONENV (id, ts) => printEntry1
	      (["val " ^ prefix ^ (printValId id) ^ " : " ^ (printValScheme ts) ] :: acc,
	      prefix, es)
	  | EXN (id,ts) => printEntry1
	      (["exception " ^ prefix ^ (printValId id) ^ (printConScheme ts)]::acc,
	       prefix, es)
	  | TYPE (id, Datatypes.TYSTR (tyfun, valenv)) => printEntry1
	      ([if Valenv.empty_valenvp valenv then
		  if Types.equalityp tyfun then
		    "eqtype " ^ prefix ^ (printTyFun (id, tyfun))
		  else
		    "type " ^ prefix ^ (printTyFun (id, tyfun))
		else
		  "datatype " ^ prefix ^ (printTyFun (id, tyfun)) ^ " = " ^
		  #2(printValenv valenv) ] :: acc,
	      prefix, es)
	  | NSIG (id,si) =>
	      if (#showSig searchOptions) then let
		val entrys = printEntry1 ([], prefix^IdentPrint.printSigId id^".", si)
	      in printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc,prefix, es)
	  | NSTR (id,str) =>
	      if (#showStr searchOptions) then let
		val entrys = printEntry1 ([], prefix^IdentPrint.printStrId id^".", str)
	      in printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc, prefix, es)
	  | NFUN (id, ts) =>
	      if (#showFun searchOptions) then let
		val entrys = printEntry1
		  ([], prefix^IdentPrint.printFunId id^".", ts)
	      in printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc, prefix, es)
	  | e => Crash.impossible "unconverted SIG STR FUN unhandled"
	end (* if *)
	else case e of
	  NSIG (id,si) =>
	      if (#showSig searchOptions) then let
		val entrys = printEntry1 ([], prefix^IdentPrint.printSigId id^".", si)
	      in printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc,prefix, es)
	  | NSTR (id,str) =>
	      if (#showStr searchOptions) then let
		val entrys = printEntry1 ([], prefix^IdentPrint.printStrId id^".", str)
	      in printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc, prefix, es)
	  | NFUN (id, ts) =>
	      if (#showFun searchOptions) then let
		val entrys = printEntry1
		  ([], prefix^IdentPrint.printFunId id^".", ts)
	      in printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc, prefix, es)
      | _ => printEntry1
	  ([prefix^(fst o get_id) e]::acc, prefix, es)

  in 
    printEntry1 ([], "", entry)
  end (* printEntry1 *)
*)
d258 6
a263 3
	      if (#showSig searchOptions) then let
		val entrys = printEntry1 ([], prefix^IdentPrint.printSigId id^".", si)
	      in printEntry1 (entrys@@acc, prefix, es) end
d266 6
a271 3
	      if (#showStr searchOptions) then let
		val entrys = printEntry1 ([], prefix^IdentPrint.printStrId id^".", str)
	      in printEntry1 (entrys@@acc, prefix, es) end
d274 5
a278 4
	      if (#showFun searchOptions) then let
		val entrys = printEntry1
		  ([], prefix^IdentPrint.printFunId id^".", ts)
	      in printEntry1 (entrys@@acc, prefix, es) end
d294 14
a307 11
	      if (#showFun searchOptions) then let
		val entrys = printEntry1
		  ([], prefix^IdentPrint.printFunId id^".", ts)
	      in printEntry1 (entrys@@acc, prefix, es) end
	      else printEntry1 (acc, prefix, es)
      | _ => printEntry1
          let
            val entry = fst (get_id e)
          in
            ((prefix^entry,entry)::acc, prefix, es)
          end
d319 17
a342 16
  local
    fun showConEnv printOptions = printOptions
  in (* local *)
    fun browse_entry printOptions (VAR _) = []
      | browse_entry printOptions (CONVAR _) = []
      | browse_entry printOptions (CONENV _) = []
      | browse_entry printOptions (EXN _) = []
      | browse_entry printOptions (TYPE (id, Datatypes.TYSTR (_, conenv))) =
	if not (showConEnv printOptions) (* Valenv.empty_valenvp conenv *) then
	  [] else browse_conenv conenv
      | browse_entry printOptions (STR (_, str)) = browse_str str
      | browse_entry printOptions (SIG (_, sigma)) = browse_sigma sigma
      | browse_entry printOptions (FUN (_, BasisTypes.PHI (_, (str, sigma)))) = browse_sigma sigma
      | browse_entry printOptions x = Crash.impossible "browse_entry barfed"
  end (* local *)

d345 1
a345 1
    | massage (FUN (id, BasisTypes.PHI (_, (str, sigma)))) = NFUN (id, browse_sigma sigma)
d347 13
@


1.4
log
@Made searchOptions be a datatype.   Added searchContext field.
Removed update function.
@
text
@d5 4
d239 1
d315 9
d325 71
@


1.3
log
@Adding is_tip function ...
@
text
@d5 3
d79 10
a88 48
  type SearchOptions =
    {showSig : bool,        (* search inside signatures *)
     showStr : bool,        (* search inside structures *)
     showFun : bool,        (* search inside functors   *)
     searchInitial : bool,  (* search initial context, used in listener *)
     showType : bool        (* show types of search results *)
     }

  fun update (s, value, x:SearchOptions) =
    case s of
      "showSig" =>
	{showSig = value,
	 showStr = #showStr x,
	 showFun = #showFun x,
	 searchInitial = #searchInitial x,
	 showType = #showType x}
    | "showStr" =>
	{showSig = #showSig x,
	 showStr = value,
	 showFun = #showFun x,
	 searchInitial = #searchInitial x,
	 showType = #showType x}
    | "showFun" =>
	{showSig = #showSig x,
	 showStr = #showStr x,
	 showFun = value,
	 searchInitial = #searchInitial x,
	 showType = #showType x}
    | "searchInitial" =>
	{showSig = #showSig x,
	 showStr = #showStr x,
	 showFun = #showFun x,
	 searchInitial = value,
	 showType = #showType x}
    | "showType" =>
      {showSig = #showSig x,
       showStr = #showStr x,
       showFun = #showFun x,
       searchInitial = #searchInitial x,
       showType = value}
    | s => Crash.impossible ("Entry.update failed on " ^ s)

  val new = {showSig = true,
	     showStr = true,
	     showFun = true,
	     searchInitial = true,
	     showType = true}
	
d235 2
a236 1
  fun printEntry1 (searchOptions:SearchOptions) printOptions entry = let
@


1.2
log
@Corrected get_id's treatment of functors: they do have sub-components so the
second part of get_id's result should be false.
@
text
@d5 4
d344 8
a351 1
      
@


1.1
log
@new unit
Moved from motif
@
text
@d5 4
d136 1
a136 1
    | FUN (id,_)    => (IdentPrint.printFunId id ^ "<functor>", true)
@
