head	1.219;
access;
symbols
	MLW_daveb_inline_1_4_99:1.218.1
	MLWorks_21c0_1999_03_25:1.218
	MLWorks_20c1_1998_08_20:1.209
	MLWorks_20c0_1998_08_04:1.208
	MLWorks_20b2c2_1998_06_19:1.202
	MLWorks_20b2_Windows_1998_06_12:1.200
	MLWorks_20b1c1_1998_05_07:1.198
	MLWorks_20b0_1998_04_07:1.194
	MLWorks_20b0_1998_03_20:1.193
	MLWorks_20m2_1998_02_16:1.191
	MLWorks_20m1_1997_10_23:1.188
	MLWorks_11r1:1.184.1.3.1.2.1
	MLWorks_workspace_97:1.187.2
	MLWorks_dt_wizard:1.187.1
	MLWorks_11c0_1997_09_09:1.184.1.3.1.2
	MLWorks_10r3:1.184.1.3.3
	MLWorks_10r2_551:1.184.1.3.2
	MLWorks_11:1.184.1.3.1
	MLWorks_1_0_r2c2_1997_07_28:1.184.1.3
	MLWorks_20m0_1997_06_20:1.187
	MLWorks_1_0_r2c2_1997_06_14:1.184.1.3
	MLWorks_1_0_r2c1_released_1997_05_23:1.184.1.3
	MLWorks_1_0_r2c1_1997_05_12:1.184.1
	MLWorks_BugFix_1997_04_24:1.185
	MLWorks_1_0_r2_Win32_1997_04_11:1.184
	MLWorks_1_0_r2_Unix_1997_04_04:1.184
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.179.3.1.1
	MLWorks_gui_1996_12_18:1.179.4
	MLWorks_1_0_Win32_1996_12_17:1.179.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.179.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.179.1.1
	MLWorks_1_0_Irix_1996_11_28:1.179.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.179.2
	MLWorks_1_0_Unix_1996_11_14:1.179.1
	MLWorks_Open_Beta2_1996_10_11:1.176.1
	MLWorks_License_dev:1.174.2
	MLWorks_1_open_beta_1996_09_13:1.174.1
	MLWorks_Open_Beta_1996_08_22:1.174
	MLWorks_Beta_1996_07_02:1.168
	MLWorks_Beta_1996_06_07:1.166
	MLWorks_Beta_1996_06_06:1.166
	MLWorks_Beta_1996_06_05:1.166
	MLWorks_Beta_1996_06_03:1.166
	MLWorks_Beta_1996_05_31:1.166
	MLWorks_Beta_1996_05_30:1.166
	ML_beta_release_12/08/94:1.85
	ML_beta_release_03/08/94:1.83
	ML_revised_beta_release_25/05/94:1.76
	ML_final_beta_release_02/03/94:1.67
	mlworks-28-01-1994:1.59
	Release:1.46
	mlworks-beta-01-09-1993:1.46;
locks; strict;
comment	@ * @;


1.219
date	99.05.12.11.17.37;	author daveb;	state Exp;
branches;
next	1.218;

1.218
date	99.03.18.10.20.13;	author mitchell;	state Exp;
branches
	1.218.1.1;
next	1.217;

1.217
date	99.02.05.14.30.09;	author mitchell;	state Exp;
branches;
next	1.216;

1.216
date	99.02.03.15.58.42;	author mitchell;	state Exp;
branches;
next	1.215;

1.215
date	99.02.02.16.00.17;	author mitchell;	state Exp;
branches;
next	1.214;

1.214
date	98.12.09.13.52.44;	author johnh;	state Exp;
branches;
next	1.213;

1.213
date	98.12.08.16.41.33;	author johnh;	state Exp;
branches;
next	1.212;

1.212
date	98.11.04.16.26.45;	author johnh;	state Exp;
branches;
next	1.211;

1.211
date	98.10.30.17.49.02;	author jont;	state Exp;
branches;
next	1.210;

1.210
date	98.10.30.14.24.13;	author jont;	state Exp;
branches;
next	1.209;

1.209
date	98.08.13.11.03.41;	author jont;	state Exp;
branches;
next	1.208;

1.208
date	98.08.03.12.42.53;	author johnh;	state Exp;
branches;
next	1.207;

1.207
date	98.07.30.15.53.34;	author johnh;	state Exp;
branches;
next	1.206;

1.206
date	98.07.30.11.11.07;	author mitchell;	state Exp;
branches;
next	1.205;

1.205
date	98.07.29.09.29.17;	author johnh;	state Exp;
branches;
next	1.204;

1.204
date	98.07.14.12.26.18;	author johnh;	state Exp;
branches;
next	1.203;

1.203
date	98.06.22.13.36.07;	author mitchell;	state Exp;
branches;
next	1.202;

1.202
date	98.06.17.16.27.07;	author johnh;	state Exp;
branches;
next	1.201;

1.201
date	98.06.16.11.34.35;	author mitchell;	state Exp;
branches;
next	1.200;

1.200
date	98.05.28.17.06.48;	author johnh;	state Exp;
branches;
next	1.199;

1.199
date	98.05.19.11.48.26;	author mitchell;	state Exp;
branches;
next	1.198;

1.198
date	98.05.07.09.19.45;	author mitchell;	state Exp;
branches;
next	1.197;

1.197
date	98.05.01.16.19.32;	author mitchell;	state Exp;
branches;
next	1.196;

1.196
date	98.05.01.14.02.45;	author mitchell;	state Exp;
branches;
next	1.195;

1.195
date	98.04.24.16.34.34;	author johnh;	state Exp;
branches;
next	1.194;

1.194
date	98.03.26.11.03.22;	author jont;	state Exp;
branches;
next	1.193;

1.193
date	98.03.02.15.07.22;	author mitchell;	state Exp;
branches;
next	1.192;

1.192
date	98.02.19.19.39.44;	author mitchell;	state Exp;
branches;
next	1.191;

1.191
date	98.01.29.14.52.48;	author johnh;	state Exp;
branches;
next	1.190;

1.190
date	97.11.09.09.19.50;	author jont;	state Exp;
branches;
next	1.189;

1.189
date	97.10.31.09.48.34;	author johnh;	state Exp;
branches;
next	1.188;

1.188
date	97.10.01.16.44.02;	author jkbrook;	state Exp;
branches;
next	1.187;

1.187
date	97.05.27.11.12.39;	author daveb;	state Exp;
branches
	1.187.1.1
	1.187.2.1;
next	1.186;

1.186
date	97.05.12.16.34.43;	author jont;	state Exp;
branches;
next	1.185;

1.185
date	97.04.11.12.03.57;	author jont;	state Exp;
branches;
next	1.184;

1.184
date	97.03.25.11.59.27;	author matthew;	state Exp;
branches
	1.184.1.1;
next	1.183;

1.183
date	97.03.21.12.04.50;	author johnh;	state Exp;
branches;
next	1.182;

1.182
date	97.03.19.17.03.30;	author matthew;	state Exp;
branches;
next	1.181;

1.181
date	97.01.24.11.06.33;	author matthew;	state Exp;
branches;
next	1.180;

1.180
date	97.01.02.15.09.00;	author matthew;	state Exp;
branches;
next	1.179;

1.179
date	96.11.06.13.28.12;	author andreww;	state Exp;
branches
	1.179.1.1
	1.179.2.1
	1.179.3.1
	1.179.4.1;
next	1.178;

1.178
date	96.11.06.11.14.15;	author matthew;	state Exp;
branches;
next	1.177;

1.177
date	96.10.30.15.21.37;	author io;	state Exp;
branches;
next	1.176;

1.176
date	96.10.10.14.36.38;	author andreww;	state Exp;
branches
	1.176.1.1;
next	1.175;

1.175
date	96.10.04.15.50.50;	author andreww;	state Exp;
branches;
next	1.174;

1.174
date	96.08.20.13.49.48;	author daveb;	state Exp;
branches
	1.174.1.1
	1.174.2.1;
next	1.173;

1.173
date	96.08.08.10.56.37;	author andreww;	state Exp;
branches;
next	1.172;

1.172
date	96.08.07.12.39.31;	author andreww;	state Exp;
branches;
next	1.171;

1.171
date	96.08.05.14.56.14;	author daveb;	state Exp;
branches;
next	1.170;

1.170
date	96.08.01.12.35.37;	author jont;	state Exp;
branches;
next	1.169;

1.169
date	96.07.19.15.00.43;	author jont;	state Exp;
branches;
next	1.168;

1.168
date	96.06.23.17.43.56;	author brianm;	state Exp;
branches;
next	1.167;

1.167
date	96.06.14.17.16.17;	author brianm;	state Exp;
branches;
next	1.166;

1.166
date	96.05.23.12.15.30;	author stephenb;	state Exp;
branches;
next	1.165;

1.165
date	96.05.22.13.02.46;	author daveb;	state Exp;
branches;
next	1.164;

1.164
date	96.05.21.16.12.41;	author daveb;	state Exp;
branches;
next	1.163;

1.163
date	96.05.20.15.57.09;	author daveb;	state Exp;
branches;
next	1.162;

1.162
date	96.05.20.14.08.19;	author daveb;	state Exp;
branches;
next	1.161;

1.161
date	96.05.16.12.54.24;	author stephenb;	state Exp;
branches;
next	1.160;

1.160
date	96.05.08.13.40.26;	author stephenb;	state Exp;
branches;
next	1.159;

1.159
date	96.05.03.09.50.53;	author daveb;	state Exp;
branches;
next	1.158;

1.158
date	96.05.01.10.25.33;	author jont;	state Exp;
branches;
next	1.157;

1.157
date	96.04.30.09.39.52;	author matthew;	state Exp;
branches;
next	1.156;

1.156
date	96.04.29.12.02.56;	author jont;	state Exp;
branches;
next	1.155;

1.155
date	96.04.18.15.03.37;	author jont;	state Exp;
branches;
next	1.154;

1.154
date	96.04.18.12.44.45;	author matthew;	state Exp;
branches;
next	1.153;

1.153
date	96.04.17.14.09.41;	author stephenb;	state Exp;
branches;
next	1.152;

1.152
date	96.04.02.11.48.34;	author daveb;	state Exp;
branches;
next	1.151;

1.151
date	96.03.27.11.25.00;	author stephenb;	state Exp;
branches;
next	1.150;

1.150
date	96.03.26.12.15.30;	author daveb;	state Exp;
branches;
next	1.149;

1.149
date	96.03.25.10.59.01;	author daveb;	state Exp;
branches;
next	1.148;

1.148
date	96.03.19.17.10.02;	author matthew;	state Exp;
branches;
next	1.147;

1.147
date	96.03.19.15.55.26;	author daveb;	state Exp;
branches;
next	1.146;

1.146
date	96.03.18.13.03.27;	author nickb;	state Exp;
branches;
next	1.145;

1.145
date	96.03.15.15.52.54;	author daveb;	state Exp;
branches;
next	1.144;

1.144
date	96.03.15.12.11.04;	author matthew;	state Exp;
branches;
next	1.143;

1.143
date	96.03.14.14.42.47;	author matthew;	state Exp;
branches;
next	1.142;

1.142
date	96.03.08.15.02.53;	author daveb;	state Exp;
branches;
next	1.141;

1.141
date	96.03.05.15.11.22;	author matthew;	state Exp;
branches;
next	1.140;

1.140
date	96.02.29.14.20.17;	author matthew;	state Exp;
branches;
next	1.139;

1.139
date	96.02.23.16.02.54;	author daveb;	state Exp;
branches;
next	1.138;

1.138
date	96.02.23.14.52.28;	author daveb;	state Exp;
branches;
next	1.137;

1.137
date	96.02.22.13.09.21;	author daveb;	state Exp;
branches;
next	1.136;

1.136
date	96.02.16.15.00.49;	author nickb;	state Exp;
branches;
next	1.135;

1.135
date	96.02.08.11.17.41;	author daveb;	state Exp;
branches;
next	1.134;

1.134
date	96.02.06.17.15.43;	author jont;	state Exp;
branches;
next	1.133;

1.133
date	96.01.25.14.58.22;	author jont;	state Exp;
branches;
next	1.132;

1.132
date	96.01.23.10.31.15;	author daveb;	state Exp;
branches;
next	1.131;

1.131
date	95.12.27.13.39.20;	author jont;	state Exp;
branches;
next	1.130;

1.130
date	95.12.11.17.21.13;	author daveb;	state Exp;
branches;
next	1.129;

1.129
date	95.12.11.16.31.08;	author daveb;	state Exp;
branches;
next	1.128;

1.128
date	95.12.11.15.17.23;	author daveb;	state Exp;
branches;
next	1.127;

1.127
date	95.12.11.10.40.25;	author daveb;	state Exp;
branches;
next	1.126;

1.126
date	95.12.05.10.18.43;	author daveb;	state Exp;
branches;
next	1.125;

1.125
date	95.12.04.16.49.12;	author daveb;	state Exp;
branches;
next	1.124;

1.124
date	95.11.29.16.59.29;	author jont;	state Exp;
branches;
next	1.123;

1.123
date	95.11.29.10.40.47;	author matthew;	state Exp;
branches;
next	1.122;

1.122
date	95.11.22.17.12.43;	author jont;	state Exp;
branches;
next	1.121;

1.121
date	95.10.26.11.28.45;	author jont;	state Exp;
branches;
next	1.120;

1.120
date	95.10.26.10.31.02;	author matthew;	state Exp;
branches;
next	1.119;

1.119
date	95.10.24.16.38.24;	author nickb;	state Exp;
branches;
next	1.118;

1.118
date	95.10.24.15.25.20;	author nickb;	state Exp;
branches;
next	1.117;

1.117
date	95.10.18.14.55.48;	author nickb;	state Exp;
branches;
next	1.116;

1.116
date	95.10.18.11.37.39;	author jont;	state Exp;
branches;
next	1.115;

1.115
date	95.10.17.13.57.37;	author matthew;	state Exp;
branches;
next	1.114;

1.114
date	95.10.06.11.09.43;	author daveb;	state Exp;
branches;
next	1.113;

1.113
date	95.10.04.10.06.09;	author daveb;	state Exp;
branches;
next	1.112;

1.112
date	95.10.04.09.56.28;	author daveb;	state Exp;
branches;
next	1.111;

1.111
date	95.09.13.13.48.36;	author jont;	state Exp;
branches;
next	1.110;

1.110
date	95.09.12.16.08.42;	author matthew;	state Exp;
branches;
next	1.109;

1.109
date	95.08.10.14.55.49;	author daveb;	state Exp;
branches;
next	1.108;

1.108
date	95.07.12.13.24.19;	author jont;	state Exp;
branches;
next	1.107;

1.107
date	95.06.30.16.18.41;	author daveb;	state Exp;
branches;
next	1.106;

1.106
date	95.06.20.12.59.37;	author daveb;	state Exp;
branches;
next	1.105;

1.105
date	95.06.20.12.36.55;	author daveb;	state Exp;
branches;
next	1.104;

1.104
date	95.06.14.14.11.18;	author daveb;	state Exp;
branches;
next	1.103;

1.103
date	95.06.13.14.30.57;	author daveb;	state Exp;
branches;
next	1.102;

1.102
date	95.06.01.15.53.27;	author matthew;	state Exp;
branches;
next	1.101;

1.101
date	95.05.31.10.06.40;	author daveb;	state Exp;
branches;
next	1.100;

1.100
date	95.05.15.15.08.41;	author matthew;	state Exp;
branches;
next	1.99;

1.99
date	95.05.10.11.05.16;	author matthew;	state Exp;
branches;
next	1.98;

1.98
date	95.05.04.16.59.25;	author jont;	state Exp;
branches;
next	1.97;

1.97
date	95.04.28.12.21.28;	author daveb;	state Exp;
branches;
next	1.96;

1.96
date	95.04.24.15.58.36;	author daveb;	state Exp;
branches;
next	1.95;

1.95
date	95.04.21.14.23.07;	author daveb;	state Exp;
branches;
next	1.94;

1.94
date	95.04.20.12.18.54;	author matthew;	state Exp;
branches;
next	1.93;

1.93
date	95.04.12.13.27.41;	author jont;	state Exp;
branches;
next	1.92;

1.92
date	95.03.24.15.24.28;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	95.03.02.12.16.32;	author matthew;	state Exp;
branches;
next	1.90;

1.90
date	95.03.02.10.52.33;	author daveb;	state Exp;
branches;
next	1.89;

1.89
date	95.01.30.11.29.00;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	95.01.24.17.44.20;	author daveb;	state Exp;
branches;
next	1.87;

1.87
date	94.12.07.11.33.59;	author matthew;	state Exp;
branches;
next	1.86;

1.86
date	94.09.22.15.58.58;	author matthew;	state Exp;
branches;
next	1.85;

1.85
date	94.08.10.14.38.15;	author daveb;	state Exp;
branches;
next	1.84;

1.84
date	94.08.09.17.56.35;	author daveb;	state Exp;
branches;
next	1.83;

1.83
date	94.08.02.14.01.54;	author daveb;	state Exp;
branches;
next	1.82;

1.82
date	94.08.01.09.47.01;	author daveb;	state Exp;
branches;
next	1.81;

1.81
date	94.07.27.12.44.08;	author daveb;	state Exp;
branches;
next	1.80;

1.80
date	94.07.14.16.16.16;	author daveb;	state Exp;
branches;
next	1.79;

1.79
date	94.06.23.11.38.02;	author jont;	state Exp;
branches;
next	1.78;

1.78
date	94.06.22.16.32.26;	author nickh;	state Exp;
branches;
next	1.77;

1.77
date	94.06.21.16.03.18;	author nickh;	state Exp;
branches;
next	1.76;

1.76
date	94.05.05.17.16.30;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	94.04.07.13.59.49;	author daveb;	state Exp;
branches;
next	1.74;

1.74
date	94.03.30.18.35.52;	author daveb;	state Exp;
branches;
next	1.73;

1.73
date	94.03.30.11.38.12;	author daveb;	state Exp;
branches;
next	1.72;

1.72
date	94.03.28.14.00.52;	author daveb;	state Exp;
branches;
next	1.71;

1.71
date	94.03.21.10.23.21;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	94.03.16.11.26.54;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	94.03.15.12.23.44;	author matthew;	state Exp;
branches;
next	1.68;

1.68
date	94.03.11.13.23.39;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	94.02.28.08.47.13;	author nosa;	state Exp;
branches;
next	1.66;

1.66
date	94.02.25.17.00.20;	author daveb;	state Exp;
branches;
next	1.65;

1.65
date	94.02.24.16.24.34;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	94.02.24.16.14.17;	author nickh;	state Exp;
branches;
next	1.63;

1.63
date	94.02.24.11.00.56;	author daveb;	state Exp;
branches;
next	1.62;

1.62
date	94.02.23.17.39.08;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	94.02.02.11.04.34;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	94.01.28.16.22.57;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	94.01.26.17.58.13;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	93.12.21.14.41.29;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	93.12.17.16.29.28;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	93.12.15.15.23.10;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	93.12.09.18.35.14;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	93.12.06.17.45.10;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	93.12.06.16.13.36;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	93.11.30.13.59.34;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	93.11.23.15.40.31;	author nickh;	state Exp;
branches;
next	1.50;

1.50
date	93.11.05.16.55.54;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	93.10.13.12.20.39;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	93.10.05.10.22.15;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	93.09.16.15.59.38;	author nosa;	state Exp;
branches;
next	1.46;

1.46
date	93.08.28.17.00.38;	author daveb;	state Exp;
branches
	1.46.1.1;
next	1.45;

1.45
date	93.08.25.14.32.35;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	93.08.24.15.24.46;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	93.08.19.17.45.30;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	93.08.12.16.01.39;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	93.08.10.16.26.01;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	93.08.10.15.36.41;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	93.08.04.09.10.30;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	93.07.30.13.52.43;	author nosa;	state Exp;
branches;
next	1.37;

1.37
date	93.07.29.16.48.20;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	93.06.30.16.42.35;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	93.06.04.14.55.34;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	93.06.02.14.04.07;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	93.05.26.16.11.40;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.05.19.16.21.18;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	93.05.19.10.06.55;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	93.05.14.16.46.04;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	93.05.13.16.14.35;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	93.05.11.18.15.50;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	93.05.11.16.15.54;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.05.10.14.14.40;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	93.05.07.10.47.05;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.05.06.13.23.55;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.04.28.10.26.57;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	93.04.22.11.45.29;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	93.04.21.16.33.12;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.04.21.13.45.47;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	93.04.20.15.48.25;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.04.15.09.29.02;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	93.04.13.15.39.31;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.04.13.09.52.30;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.04.08.15.18.07;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	93.04.06.16.33.46;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	93.04.02.15.48.28;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.03.30.10.36.39;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.03.29.16.16.24;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	93.03.26.17.02.31;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.03.25.10.15.52;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	93.03.19.19.36.35;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.03.18.18.05.30;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.03.15.17.56.57;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.03.12.12.09.36;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.03.10.18.08.57;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	93.03.09.15.48.32;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.04.10.25.30;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	93.03.02.19.21.07;	author daveb;	state Exp;
branches;
next	;

1.46.1.1
date	93.08.28.17.00.38;	author jont;	state Exp;
branches;
next	1.46.1.2;

1.46.1.2
date	93.10.12.14.34.39;	author daveb;	state Exp;
branches;
next	;

1.174.1.1
date	96.09.13.11.16.32;	author hope;	state Exp;
branches;
next	;

1.174.2.1
date	96.10.07.16.06.27;	author hope;	state Exp;
branches;
next	;

1.176.1.1
date	96.10.17.11.24.42;	author hope;	state Exp;
branches;
next	;

1.179.1.1
date	96.11.14.12.49.32;	author hope;	state Exp;
branches
	1.179.1.1.1.1;
next	;

1.179.1.1.1.1
date	96.11.28.15.00.47;	author hope;	state Exp;
branches;
next	;

1.179.2.1
date	96.11.22.18.09.08;	author hope;	state Exp;
branches;
next	;

1.179.3.1
date	96.12.17.17.47.47;	author hope;	state Exp;
branches
	1.179.3.1.1.1;
next	;

1.179.3.1.1.1
date	97.02.24.11.37.33;	author hope;	state Exp;
branches;
next	;

1.179.4.1
date	96.12.18.09.41.48;	author hope;	state Exp;
branches;
next	;

1.184.1.1
date	97.05.12.10.34.15;	author hope;	state Exp;
branches;
next	1.184.1.2;

1.184.1.2
date	97.05.12.15.27.32;	author daveb;	state Exp;
branches;
next	1.184.1.3;

1.184.1.3
date	97.05.19.18.21.21;	author daveb;	state Exp;
branches
	1.184.1.3.1.1
	1.184.1.3.2.1
	1.184.1.3.3.1;
next	;

1.184.1.3.1.1
date	97.07.28.18.18.54;	author daveb;	state Exp;
branches;
next	1.184.1.3.1.2;

1.184.1.3.1.2
date	97.08.08.17.14.07;	author daveb;	state Exp;
branches
	1.184.1.3.1.2.1.1;
next	;

1.184.1.3.1.2.1.1
date	97.10.07.11.44.02;	author jkbrook;	state Exp;
branches;
next	;

1.184.1.3.2.1
date	97.09.08.17.12.32;	author daveb;	state Exp;
branches;
next	;

1.184.1.3.3.1
date	97.09.09.14.08.09;	author daveb;	state Exp;
branches;
next	;

1.187.1.1
date	97.09.10.19.23.11;	author brucem;	state Exp;
branches;
next	;

1.187.2.1
date	97.09.11.20.54.17;	author daveb;	state Exp;
branches;
next	1.187.2.2;

1.187.2.2
date	97.11.17.16.54.37;	author daveb;	state Exp;
branches;
next	1.187.2.3;

1.187.2.3
date	97.11.20.16.59.10;	author daveb;	state Exp;
branches;
next	1.187.2.4;

1.187.2.4
date	97.11.26.11.36.40;	author daveb;	state Exp;
branches;
next	1.187.2.5;

1.187.2.5
date	97.12.03.16.05.10;	author daveb;	state Exp;
branches;
next	;

1.218.1.1
date	99.04.01.17.56.32;	author daveb;	state Exp;
branches;
next	;


desc
@Creates a user-visible structure.  Used to be in shell.
@


1.219
log
@[Bug #190554]
Type of Timer.checkCPUTimer has changed.
@
text
@(*  Shell structure; defined in terms of compiler datatypes so that
 *  we can add it to the initial context.
 *
 *  This is a nasty piece of work. types, values, exceptions and structures
 *  are built allowing connection of user input to builtin functions. There
 *  is no available type checking to ensure that this connection is consistent.
 *  At present, there is a convention that values within structure records
 *  should be annotated with their types as a consistency check that the
 *  externally visible type and the internal type they are connected to are the
 *  same. This is only a manual check, an automatic one is not currently
 *  available. Please stick to this convention until a better way is found.
 *
 *  Copyright (C) 1992,1993 Harlequin Ltd
 *
 *  $Log: _shell_structure.sml,v $
 * Revision 1.218  1999/03/18  10:20:13  mitchell
 * [Bug #190534]
 * Ensure projects created by Shell.Project have Debug and Release modes as default
 *
 * Revision 1.217  1999/02/05  14:30:09  mitchell
 * [Bug #190502]
 * Disable generation of .S files
 *
 * Revision 1.216  1999/02/03  15:58:42  mitchell
 * [Bug #50108]
 * Change ModuleId from an equality type
 *
 * Revision 1.215  1999/02/02  16:00:17  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.214  1998/12/09  13:52:44  johnh
 * [Bug #70240]
 * Remove project units for configuration files when current configuration changes.
 *
 * Revision 1.213  1998/12/08  16:41:33  johnh
 * [Bug #190494]
 * Check for duplicate module ids when adding new files and changing configurations.
 *
 * Revision 1.212  1998/11/04  16:26:45  johnh
 * reset project when opening an existing one to clear out units.
 *
 * Revision 1.211  1998/10/30  17:49:02  jont
 * [Bug #70204]
 * Do work for making exes
 *
 * Revision 1.210  1998/10/30  14:24:13  jont
 * [Bug #70204]
 * Add Shell.Project.makeDll
 *
 * Revision 1.209  1998/08/13  11:03:41  jont
 * [Bug #30468]
 * Change types of mkAbsolute and mkRelative to uses records with names fields
 *
 * Revision 1.208  1998/08/03  12:42:53  johnh
 * [Bug #30420]
 * Don't handle Info.Stop during compilation to bring up project error.
 *
 * Revision 1.207  1998/07/30  15:53:34  johnh
 * [Bug #30420]
 * Raise error when no targets exist in project.
 *
 * Revision 1.206  1998/07/30  11:11:07  mitchell
 * [Bug #30439]
 * Don't allow the user to save a non-existent project!
 * And make sure the project window gets updated with new project name when using saveAs
 *
 * Revision 1.205  1998/07/29  09:29:17  johnh
 * [Bug #30453]
 * Check for a new target being in the list of files.
 *
 * Revision 1.204  1998/07/14  12:26:18  johnh
 * [Bug #30417]
 * Add saveProjectAs and showName => showFilename
 *
 * Revision 1.203  1998/06/22  13:36:07  mitchell
 * [Bug #30429]
 * Warn when saving sessions with debugging information enabled
 *
 * Revision 1.202  1998/06/17  16:27:07  johnh
 * [Bug #30423]
 * Add call to Incremental.reset_project for a new project.
 *
 * Revision 1.201  1998/06/16  11:34:35  mitchell
 * [Bug #30422]
 * Make newProject take a working directory argument
 *
 * Revision 1.200  1998/05/28  17:06:48  johnh
 * [Bug #30369]
 * Replace source path with a list of files.
 *
 * Revision 1.199  1998/05/19  11:48:26  mitchell
 * [Bug #50071]
 * Replace touch* functions in Shell.Project by forceCompile* and forceLoad*
 *
 * Revision 1.198  1998/05/07  09:19:45  mitchell
 * [Bug #50071]
 * Add touchAllSources to Shell.Project
 *
 * Revision 1.197  1998/05/01  16:19:32  mitchell
 * [Bug #50071]
 * Remove debug printout
 *
 * Revision 1.196  1998/05/01  14:02:45  mitchell
 * [Bug #50071]
 * Flesh out Shell.Project interface
 *
 * Revision 1.195  1998/04/24  16:34:34  johnh
 * [Bug #30229]
 * Group compiler options to allow more flexibility.
 *
 * Revision 1.194  1998/03/26  11:03:22  jont
 * [Bug #30090]
 * Remove MLWorks.IO. Change spec of Shell.Timer.printTiming
 * to use a string->unit outputter function insteadm of an outstream
 *
 * Revision 1.193  1998/03/02  15:07:22  mitchell
 * [Bug #70074]
 * Add depth limit support for signature printing
 *
 * Revision 1.192  1998/02/19  19:39:44  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.191  1998/01/29  14:52:48  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.190  1997/11/09  09:19:50  jont
 * [Bug #30089]
 * Remove use of MLWorks.Time.Elapsed in favour of basis timer
 *
 * Revision 1.189  1997/10/31  09:48:34  johnh
 * [Bug #30233]
 * Change editor interface.
 *
 * Revision 1.188  1997/10/01  16:44:02  jkbrook
 * [Bug #20088]
 * Merging from MLWorks_11:
 * SML'96 should be SML'97
 *
 * Revision 1.187.2.5  1997/12/03  16:05:10  daveb
 * [Bug #30017]
 * Rationalised Shell.Project commands:
 * ShellUtils functions now take strings instead of module_ids, and
 * explicit location values.
 * Added functions for loadAll and showLoadAll.
 * Removed TopLevel.
 *
 * Revision 1.187.2.4  1997/11/26  11:36:40  daveb
 * [Bug #30071]
 * The action queue is no more, so ShellUtils.use_{file,string} and
 * ShellUtils.read_dot_mlworks no longer take queue functions.
 *
 * Revision 1.187.2.3  1997/11/20  16:59:10  daveb
 * [Bug #30326]
 *
 * Revision 1.187.2.2  1997/11/17  16:54:37  daveb
 * [Bug #30017]
 * Added Shell.Project.
 * Removed Shell.Build and Shell.File.
 * Removed all uses of the Action Queue.
 *
 * Revision 1.187.2.1  1997/09/11  20:54:17  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.187  1997/05/27  11:12:39  daveb
 * [Bug #30136]
 * Removed early-mips-r4000 option.
 *
 * Revision 1.186  1997/05/12  16:34:43  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
 * Revision 1.185  1997/04/11  12:03:57  jont
 * [Bug #2026]
 * Ensure setPervasive and setSourcePath handle OS.SysErr
 *
 * Revision 1.184  1997/03/25  11:59:27  matthew
 * Renaming R4000 option
 *
 * Revision 1.183  1997/03/21  12:04:50  johnh
 * [Bug #1965]
 * Handled Io.NotSet for getting paths.
 *
 * Revision 1.182  1997/03/19  17:03:30  matthew
 * Changing use to work properly
 *
 * Revision 1.181  1997/01/24  11:06:33  matthew
 * Adding platform dependent options
 *
 * Revision 1.180  1997/01/02  15:09:00  matthew
 * Adding local functions option
 *
 * Revision 1.179  1996/11/06  13:28:12  andreww
 * [Bug #1711]
 * adding side-effect to oldDefinition option: set equality attribute
 * on real_tyname.
 *
 * Revision 1.178  1996/11/06  11:14:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.177  1996/10/30  15:21:37  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.176  1996/10/10  14:36:38  andreww
 * [Bug #1654]
 * Shell.Dynamic.type -> Shell.Dynamic.type_rep
 *
 * Revision 1.175  1996/10/04  15:50:50  andreww
 * [Bug #1592]
 * threading extra level argument to make_tyname
 *
 * Revision 1.174  1996/08/20  13:49:48  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
 * Revision 1.173  1996/08/08  10:56:37  andreww
 * [Bug #714]
 * Introduce a new Debugger structure into Shell.Options that
 * interfaces the flags in debugger/__stack_frame.sml
 *
 * Revision 1.172  1996/08/07  12:39:31  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml and _types.sml
 *
 * Revision 1.171  1996/08/05  14:56:14  daveb
 * Removed Shell.Path.objectPath and Shell.Path.setObjectPath for the beta
 * release.
 *
 * Revision 1.170  1996/08/01  12:35:37  jont
 * [Bug #1503]
 * Add field to FUNINFO to say if arg actually saved
 *
 * Revision 1.169  1996/07/19  15:00:43  jont
 * Add print_messages to Shell.Options.Compiler
 *
 * Revision 1.168  1996/06/23  17:43:56  brianm
 * Correcting bungled definition of Shell.Editor.Custom ...
 *
 * Revision 1.166  1996/05/23  12:15:30  stephenb
 * Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
 * now does what the former used to do.
 *
 * Revision 1.165  1996/05/22  13:02:46  daveb
 * Reorganised the options menus.
 *
 * Revision 1.164  1996/05/21  16:12:41  daveb
 * Various renamings.
 *
 * Revision 1.163  1996/05/20  15:57:09  daveb
 * Commented out Shell.Module.save, as it is not implemented.
 *
 * Revision 1.162  1996/05/20  14:08:19  daveb
 * Moved the code for saving images, parsing command lines, etc. to a new file.
 *
 * Revision 1.161  1996/05/16  12:54:24  stephenb
 * Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
 *
 * Revision 1.160  1996/05/08  13:40:26  stephenb
 * Update wrt move of file "main" to basis.
 *
 * Revision 1.159  1996/05/03  09:50:53  daveb
 * Removed the ShellUtils.Error exception.
 *
 * Revision 1.158  1996/05/01  10:25:33  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.157  1996/04/30  09:39:52  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.156  1996/04/29  12:02:56  jont
 * Changes concerning MLWorks.save
 *
 * Revision 1.155  1996/04/18  15:03:37  jont
 * initbasis moved to basis
 *
 * Revision 1.154  1996/04/18  12:44:45  matthew
 * ** No reason given. **
 *
 * Revision 1.153  1996/04/17  14:09:41  stephenb
 * Rename Os -> OS to conform with latest basis revision.
 *
 * Revision 1.152  1996/04/02  11:48:34  daveb
 * Changing loadDependencies to readDependencies.
 *
 * Revision 1.151  1996/03/27  11:25:00  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
 * Revision 1.150  1996/03/26  12:15:30  daveb
 * I forgot to add the type for Shell.Module.delete.
 *
 * Revision 1.149  1996/03/25  10:59:01  daveb
 * Added Shell.Module.delete.
 *
 * Revision 1.148  1996/03/19  17:10:02  matthew
 * Removing some options
 *  .
 *
 * Removing some options
 *
 * Revision 1.147  1996/03/19  15:55:26  daveb
 * Added Shell.{File,Module}.queryLoadObject
 *
 * Revision 1.146  1996/03/18  13:03:27  nickb
 * Fix deliverFn to use the standard streams.
 *
 * Revision 1.145  1996/03/15  15:52:54  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.144  1996/03/15  12:11:04  matthew
 * Changing argument separato to hyphen from underscore
 *
 * Revision 1.143  1996/03/14  14:42:47  matthew
 * Adding compileAndLoad functionality
 *
 * Revision 1.142  1996/03/08  15:02:53  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
 * Revision 1.141  1996/03/05  15:11:22  matthew
 * Fixing problem with .mlworks_preferences and command line arguments\
 *
 * Revision 1.140  1996/02/29  14:20:17  matthew
 * Adding reading preferences file
 *
 * Revision 1.139  1996/02/23  16:02:54  daveb
 * Converted to new capitalisation scheme (sigh).
 *
 * Revision 1.138  1996/02/23  14:52:28  daveb
 * Moved Shell.Inspector.inspect to Shell.Dynamic.inspect.
 *
 * Revision 1.137  1996/02/22  13:09:21  daveb
 * Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
 * some functionality to the Shell structure.
 *
 * Revision 1.136  1996/02/16  15:00:49  nickb
 * Export becomes Deliver.
 *
 *  Revision 1.135  1996/02/08  11:17:41  daveb
 *  Removed the Shell.TopEnv structure.
 *
 *  Revision 1.134  1996/02/06  17:15:43  jont
 *  Ensure exportFn restores break_hook and generalises_ref
 *  even when it succeeds
 *
 *  Revision 1.133  1996/01/25  14:58:22  jont
 *  Fix breakpoint setting to use the correct types
 *  Added type constraints to all values in structure records
 *  for some consistency checking
 *
 *  Revision 1.132  1996/01/23  10:31:15  daveb
 *  Revised names of compilation functions.
 *
 *  Revision 1.131  1995/12/27  13:39:20  jont
 *  Removing Option in favour of MLWorks.Option
 *
 *  Revision 1.130  1995/12/11  17:21:13  daveb
 *  Revised previous log message.
 *
 *  Revision 1.129  1995/12/11  16:31:08  daveb
 *  Changed name of Debug.status_all to Debug.info_all
 *
 *  Revision 1.128  1995/12/11  15:17:23  daveb
 *  Reversing previous change.
 *
 *  Revision 1.127  1995/12/11  10:40:25  daveb
 *  Changed the arguments of add_debug_info to use Incremental.debugging_options.
 *
 *  Revision 1.126  1995/12/05  10:18:43  daveb
 *  Corrected previous log message.
 *
 *  Revision 1.125  1995/12/04  16:49:12  daveb
 *  The Shell.Compile structure has changed to match the new Compilation
 *  Manager.  The type of the ShellUtils.Error exception has changed.
 *
 *  Revision 1.124  1995/11/29  16:59:29  jont
 *  Ensure saved images don't believe the X interface is already running
 *  Modify the already running message not to refer to X
 *
 *  Revision 1.123  1995/11/29  10:40:47  matthew
 *  Adding switch for value polymorphism.
 *
 *  Revision 1.122  1995/11/22  17:12:43  jont
 *  Allow source_path and pervasive_dir as arguments to incremental systems
 *  Also add object_path for completeness
 *
 *  Revision 1.121  1995/10/26  11:28:45  jont
 *  Adding opt_handlers compiler option
 *
 *  Revision 1.120  1995/10/26  10:31:02  matthew
 *  Changing untrace_all function
 *
 *  Revision 1.119  1995/10/24  16:38:24  nickb
 *  Add Shell.Profile.profile_tool.
 *
 *  Revision 1.118  1995/10/24  15:25:20  nickb
 *  Add profiling functions.
 *
 *  Revision 1.117  1995/10/18  14:55:48  nickb
 *  Add Shell.Profile.
 *
 *  Revision 1.116  1995/10/18  11:37:39  jont
 *  Add exec_save to shell structure for saving executables
 *
 *  Revision 1.115  1995/10/17  13:57:37  matthew
 *  Simplifying trace interface
 *
 *  Revision 1.114  1995/10/06  11:09:43  daveb
 *  Changed -motif to -gui in usage message, and added -{debug,optimize}_mode.
 *  Also removed -full_menus and -short_menus from the user messages (the
 *  arguments still work, but we don't advertise them).
 *
 *  Revision 1.113  1995/10/04  10:06:09  daveb
 *  Changed -motif command line argument to -gui.
 *
 *  Revision 1.112  1995/10/04  09:56:28  daveb
 *  Added -debug_mode and -optimize_mode command line arguments.
 *
 *  Revision 1.111  1995/09/13  13:48:36  jont
 *  Add exportFn to shell structure
 *
 *  Revision 1.110  1995/09/12  16:08:42  matthew
 *  Adding Interrupt handler around start_x_interface
 *
 *  Revision 1.109  1995/08/10  14:55:49  daveb
 *  Replaced redundant construction of built-in types.
 *
 *  Revision 1.108  1995/07/12  13:24:19  jont
 *  Add parameter to make_shell_structure to indicate image type (ie tty or motif)
 *
 *  Revision 1.107  1995/06/30  16:18:41  daveb
 *  Added float_precision option to ValuePrinter options.
 *
 *  Revision 1.106  1995/06/20  12:59:37  daveb
 *  Context options were calling the wrong update functions.
 *
 *  Revision 1.105  1995/06/20  12:36:55  daveb
 *  Added variable info mode.
 *
 *  Revision 1.104  1995/06/14  14:11:18  daveb
 *  ShellUtils.edit_* functions no longer require a context argument.
 *  Added new preferences to the Shell.Preferences structure.
 *
 *  Revision 1.103  1995/06/13  14:30:57  daveb
 *  Removed show_id_class and show_eq_info value printer options from interface.
 *
 *  Revision 1.102  1995/06/01  15:53:27  matthew
 *  Adding Shell.Make.touch_all
 *
 *  Revision 1.101  1995/05/31  10:06:40  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.100  1995/05/15  15:08:41  matthew
 *  Renaming nj_semicolons
 *
 *  Revision 1.99  1995/05/10  11:05:16  matthew
 *  Removed debug_polyvariables and step options
 *
 *  Revision 1.98  1995/05/04  16:59:25  jont
 *  add capability to set object_path
 *
 *  Revision 1.97  1995/04/28  12:21:28  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.96  1995/04/24  15:58:36  daveb
 *  Removed stepper option, commented out poly_variable and moduler options.
 *  Also commented out default_overloads option.
 *
 *  Revision 1.95  1995/04/21  14:23:07  daveb
 *  Expansion of home dirs moved from FileSys to Getenv.
 *  Better error handling.
 *  filesys moved from utils to initbasis.
 *
 *  Revision 1.94  1995/04/20  12:18:54  matthew
 *  Changed most of the functions with dynamic arguments to look up type
 *  information in the debug information
 *  First version of new step and breakpoint stuff
 *
 *  Revision 1.93  1995/04/12  13:27:41  jont
 *  Change FILESYS to FILE_SYS
 *
 *  Revision 1.92  1995/03/24  15:24:28  matthew
 *  Replacing Tyfun_id etc. with Stamp
 *
 *  Revision 1.91  1995/03/02  12:16:32  matthew
 *  Added simple trace functions
 *
 *  Revision 1.90  1995/03/02  10:52:33  daveb
 *  Removed InterPrint, Crash and TopLevel parameters.
 *
 *  Revision 1.89  1995/01/30  11:29:00  matthew
 *  Added function for printing debug annotations
 *  This is for internal use only really.
 *
 *  Revision 1.88  1995/01/24  17:44:20  daveb
 *  Replaced FileName parameter with FileSys and Path.
 *
 *  Revision 1.87  1994/12/07  11:33:59  matthew
 *  Changing uses of cast
 *
 *  Revision 1.86  1994/09/22  15:58:58  matthew
 *  Changes to tycon lookup
 *
 *  Revision 1.85  1994/08/10  14:38:15  daveb
 *  Moved call to read_dot_mlworks here from _tty_listener.
 *
 *  Revision 1.84  1994/08/09  17:56:35  daveb
 *  Revised help message for startup.
 *
 *  Revision 1.83  1994/08/02  14:01:54  daveb
 *  Added new editor options.
 *
 *  Revision 1.82  1994/08/01  09:47:01  daveb
 *  Changes to editor selection.
 *
 *  Revision 1.81  1994/07/27  12:44:08  daveb
 *  Added -full_menus and -short_menus options.
 *
 *  Revision 1.80  1994/07/14  16:16:16  daveb
 *  Saved images now take arguments to select tty or motif mode.
 *  x_interface_fn takes a boolean that indicates whether it is called
 *  from the TTY interface or whether MLWorks invoked it on start-up.
 *
 *  Revision 1.79  1994/06/23  11:38:02  jont
 *  Update debugger information production
 *
 *  Revision 1.78  1994/06/22  16:32:26  nickh
 *  Add Shell.Trace.untrace_all.
 *
 *  Revision 1.77  1994/06/21  16:03:18  nickh
 *  Remove garbage collection performed before image save.
 *  (this is now done automatically in the runtime).
 *
 *  Revision 1.76  1994/05/05  17:16:30  daveb
 *  Added default_overloads option.
 *
 *  Revision 1.75  1994/04/07  13:59:49  daveb
 *  Made Shell.Options.Mode.{debugging,optimising} bool options.
 *
 *  Revision 1.74  1994/03/30  18:35:52  daveb
 *  Implemented touch_compile_{module,file}.
 *
 *  Revision 1.73  1994/03/30  11:38:12  daveb
 *  Revised Shell.Options.Compatibility
 *
 *  Revision 1.72  1994/03/28  14:00:52  daveb
 *  Moved some functions from Shell.Make into the new structures Shell.Path
 *  and Shell.Compile.  Added _module versions of make & compile functions.
 *
 *  Revision 1.71  1994/03/21  10:23:21  matthew
 *  Added ability to define exceptions.
 *  Used this to improve errors from eval, edit etc.
 *
 *  Revision 1.70  1994/03/16  11:26:54  matthew
 *  Added edit_function function to Shell.Editor
 *
 *  Revision 1.69  1994/03/15  12:23:44  matthew
 *  Tidying up - removing replace and gc functions
 *
 *  Revision 1.67  1994/02/28  08:47:13  nosa
 *  Deleted compiler option debug_polyvariables in Debugger_Types.INFO;
 *  Boolean indicator for Monomorphic debugger decapsulation;\ncompilation options for Step and Modules Debuggers.
 *
 *  Revision 1.66  1994/02/25  17:00:20  daveb
 *  Changing Shell.Debug structure.
 *
 *  Revision 1.64  1994/02/24  16:14:17  nickh
 *  Change to storage manager interface.
 *
 *  Revision 1.63  1994/02/24  11:00:56  daveb
 *  Fixed types of functions to set and get pervasive directory and source
 *  path, ensuring that all necessary expansion is done.
 *
 *  Revision 1.62  1994/02/23  17:39:08  matthew
 *  Changing inspector interface
 *
 *  Revision 1.61  1994/02/02  11:04:34  daveb
 *  ActionQueue no longer has Incremental as a substructure.  And the
 *  functionality of trans_home_name has been hidden.
 *
 *  Revision 1.60  1994/01/28  16:22:57  matthew
 *  Better locations in error messages
 *
 *  Revision 1.59  1994/01/26  17:04:40  matthew
 *  Added handler to reset no_execute
 *
 *  Revision 1.58  1993/12/21  14:41:29  matthew
 *  Added load function to Make structure
 *
 *  Revision 1.57  1993/12/17  16:29:28  matthew
 *  Added maximum_str_depth to options.
 *
 *  Revision 1.56  1993/12/15  15:23:10  matthew
 *  Added level field to Basis.
 *
 *  Revision 1.55  1993/12/09  18:35:14  matthew
 *  Added Shell.Dynamic.replace
 *
 *  Revision 1.54  1993/12/06  17:45:10  daveb
 *  Added Shell.Options.Preferences.
 *
 *  Revision 1.53  1993/12/06  16:13:36  daveb
 *  Changed Shell.Make.remake_file to Shell.Make.force_make, and
 *  Shell.Make.recompile to Shell.Make.compile (hiding old Shell.Make.compile).
 *
 *  Revision 1.52  1993/11/30  13:59:34  matthew
 *  Added is_abs field to TYNAME and METATYNAME
 *  Further work may be needed here.
 *
 *  Revision 1.51  1993/11/23  15:40:31  nickh
 *  Added Shell.Timer structure.
 *
 *  Revision 1.50  1993/11/05  16:55:54  jont
 *  Added shell structure support for requesting interruptable tight loops
 *
 *  Revision 1.49  1993/10/13  12:20:39  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.48  1993/10/05  10:22:15  jont
 *  Added Shell.Make.save function

 *  Revision 1.46.1.2  1993/10/12  14:34:39  daveb
 *  Changed print options.
 *
 *  Revision 1.47  1993/09/16  15:59:38  nosa
 *  Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
 *
 *  Revision 1.46.1.1  1993/08/28  17:00:38  jont
 *  Fork for bug fixing
 *
 *  Revision 1.46  1993/08/28  17:00:38  daveb
 *   Added source_path, set_pervasive, pervasive to Shell.Make.
 *
 *  Revision 1.45  1993/08/25  14:32:35  matthew
 *  Return quit function from ShellUtils.edit_string
 *
 *  Revision 1.44  1993/08/24  15:24:46  matthew
 *  Tidied up mode functions
 *
 *  Revision 1.43  1993/08/19  17:45:30  daveb
 *  Removed core-only and functional options, since they didn't do anything.
 *  Added Make.check_dependecies.
 *
 *  Revision 1.42  1993/08/12  16:01:39  daveb
 *  Changes to reflect changes in Io structure.
 *
 *  Revision 1.41  1993/08/10  16:26:01  matthew
 *  Changes to user_options to store update functions
 *
 *  Revision 1.40  1993/08/10  15:36:41  matthew
 *  Rationalization.  Added Trace, Dynamic and Inspector substructures.
 *
 *  Revision 1.39  1993/08/04  09:10:30  matthew
 *  Renamed strict option to standard.
 *
 *  Revision 1.38  1993/07/30  13:52:43  nosa
 *  new compiler option debug_variables for local and closure variable
 *  inspection in the debugger;
 *  structure Option.
 *
 *  Revision 1.37  1993/07/29  16:48:20  matthew
 *  Added call to trans_home_name for recompile and compile
 *
 *  Revision 1.36  1993/06/30  16:42:35  daveb
 *  Removed exception environments.
 *
 *  Revision 1.35  1993/06/04  14:55:34  daveb
 *  edit functions now return a single string in the errorneous case.
 *
 *  Revision 1.34  1993/06/02  14:04:07  matthew
 *  Added untrace function
 *
 *  Revision 1.33  1993/05/26  16:11:40  matthew
 *  Removed Parser added ShellUtils structure
 *  Uses ShellUtils.eval function
 *
 *  Revision 1.32  1993/05/19  16:21:18  daveb
 *  Changed type of Shell.Options.*.* to 'a Shell.Options.Option,
 *  and added Shell.Options.{set, get}
 *
 *  Revision 1.31  1993/05/19  10:06:55  daveb
 *  Rearranged some of the options.
 *
 *  Revision 1.30  1993/05/14  16:46:04  jont
 *  Added New Jersey interpretation of weak type variables under option control
 *
 *  Revision 1.29  1993/05/13  16:14:35  jont
 *  Added wide ranging option control for NJ flavour, Harlequin flavour,
 *  Strict flavour. These are in Shell.Options.flavour, I need a better name
 *
 *  Revision 1.28  1993/05/11  18:15:50  jont
 *  Added make -n control to shell.Options.Compiler
 *
 *  Revision 1.27  1993/05/11  16:15:54  matthew
 *  Changed eval_string function
 *  Changes to use
 *
 *  Revision 1.26  1993/05/10  14:14:40  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *
 *  Revision 1.25  1993/05/07  10:47:05  matthew
 *  Added Tracing
 *
 *  Revision 1.24  1993/05/06  13:23:55  matthew
 *  InterPrint signature changes
 *
 *  Revision 1.23  1993/04/28  10:26:57  richard
 *  Unified profiling and tracing options into `intercept'.
 *  Removed poly_makestring option.
 *
 *  Revision 1.22  1993/04/22  11:45:29  richard
 *  Removed pervasive editor.  Changed editor selection type to string.
 *
 *  Revision 1.21  1993/04/21  16:33:12  matthew
 *  Changed interface to tty inspector
 *
 *  Revision 1.20  1993/04/21  13:45:47  richard
 *  Removed old tracing stuff.
 *
 *  Revision 1.19  1993/04/20  15:48:25  matthew
 *  Removed trace functions
 *  Added add_inspect_method function
 *
 *  Revision 1.18  1993/04/15  09:29:02  jont
 *  Added editor options and editor to shell structure
 *
 *  Revision 1.17  1993/04/13  15:39:31  matthew
 *  Added Shell.lambda_switches for control of lambda optimisations
 *  This is probably not a permanent feature.
 *
 *  Revision 1.16  1993/04/13  09:52:30  matthew
 *  Added dynamic value and type printing functions
 *
 *  Revision 1.15  1993/04/08  15:18:07  jont
 *  Minor change to interface to editor
 *
 *  Revision 1.14  1993/04/06  16:33:46  jont
 *  Moved user_options and version from interpreter to main
 *
 *  Revision 1.13  1993/04/02  15:48:28  matthew
 *  Added Shell.eval and Shell.print functions
 *  Signature changes
 *
 *  Revision 1.12  1993/03/30  10:36:39  matthew
 *  Removed read_dot_mlworks
 *  Changed to use a shell_data ref so a shell structure is made only once and
 *  is shared between all shells
 *  Removed a lot on unnecessary casts and added some type constraints
 *
 *  Revision 1.11  1993/03/29  16:16:24  jont
 *  Removed get_pervasive_dir, using one in io instead
 *
 *  Revision 1.10  1993/03/26  17:02:31  matthew
 *  Removed debugger structure.  Break function comes from shell_data
 *
 *  Revision 1.9  1993/03/25  10:15:52  daveb
 *  Added Options.Extension.
 *  ActionQueue.do_actions now takes a single ShellData argument.
 *
 *  Revision 1.8  1993/03/19  19:36:35  matthew
 *  Pass context_ref to ActionQueue.do_actions
 *
 *  Revision 1.7  1993/03/18  18:05:30  matthew
 *   Added .mlworks facility
 *
 *  Revision 1.6  1993/03/15  17:56:57  matthew
 *  Simplified ShellType types
 *
 *  Revision 1.5  1993/03/12  12:09:36  matthew
 *  Added break and inspector functions
 *  Changed to use ShellData type
 *
 *  Revision 1.4  1993/03/10  18:08:57  jont
 *  Added Editor substructure to the shell
 *
 *  Revision 1.3  1993/03/09  15:48:32  matthew
 *  Options & Info changes
 *  Changes for ShellTypes.ShellData type
 *
 *  Revision 1.2  1993/03/04  10:25:30  daveb
 *  Types.empty_rec_type is now called Types._empty_rectype.
 *
 *  Revision 1.1  1993/03/02  19:21:07  daveb
 *  Initial revision
 *)

require "../basis/__int";
require "../basis/__list";
require "../basis/__timer";
require "../system/__time";

require "../utils/lists";
require "../basis/os";
require "../utils/getenv";
require "../basics/module_id";
require "../typechecker/types";
require "../typechecker/strenv";
require "../typechecker/tyenv";
require "../typechecker/environment";
require "../typechecker/valenv";
require "../typechecker/scheme";
require "../typechecker/basistypes";
require "../main/mlworks_io";
require "../debugger/debugger_utilities";
require "../debugger/value_printer";
require "../debugger/newtrace";
require "../debugger/stack_frame";
require "inspector";
require "inspector_values";
require "incremental";
require "shell_types";
require "user_context";
require "../main/user_options";
require "../main/preferences";
require "../main/proj_file";
require "../main/project";
require "../editor/custom";

require "shell_utils";
require "save_image";
require "shell_structure";

functor ShellStructure (
  structure Lists : LISTS
  structure OS : OS
  structure Getenv : GETENV
  structure ModuleId : MODULE_ID
  structure Types : TYPES
  structure Strenv : STRENV
  structure Tyenv : TYENV
  structure Valenv : VALENV
  structure Scheme : SCHEME
  structure BasisTypes : BASISTYPES
  structure Env : ENVIRONMENT
  structure DebuggerUtilities : DEBUGGER_UTILITIES
  structure ValuePrinter : VALUE_PRINTER
  structure Trace : TRACE
  structure Io : MLWORKS_IO
  structure ProjFile : PROJ_FILE
  structure Project : PROJECT
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure ShellTypes: SHELL_TYPES
  structure UserContext: USER_CONTEXT
  structure Inspector : INSPECTOR
  structure InspectorValues : INSPECTOR_VALUES
  structure Incremental: INCREMENTAL
  structure ShellUtils : SHELL_UTILS
  structure SaveImage : SAVE_IMAGE
  structure CustomEditor : CUSTOM_EDITOR
  structure StackFrame : STACK_FRAME

  sharing Types.Datatypes = Strenv.Datatypes = Tyenv.Datatypes =
          Valenv.Datatypes = Scheme.Datatypes = BasisTypes.Datatypes =
          Incremental.Datatypes = Env.Datatypes
  sharing Incremental.InterMake.Compiler.Info =
          ShellUtils.Info
  sharing UserOptions.Options =
          ValuePrinter.Options =
          ShellTypes.Options =
    	  Incremental.InterMake.Compiler.Options =
          Types.Options =
          ShellUtils.Options =
          DebuggerUtilities.Debugger_Types.Options
  sharing Types.Datatypes.Ident =
	  Incremental.InterMake.Compiler.Absyn.Ident
  sharing Types.Datatypes.NewMap =
	  Incremental.InterMake.Compiler.NewMap

  sharing type ModuleId.ModuleId = Incremental.ModuleId = Project.ModuleId
  sharing type DebuggerUtilities.Debugger_Types.information =
	       ValuePrinter.DebugInformation =
    	       Incremental.InterMake.Compiler.DebugInformation
  sharing type BasisTypes.Datatypes.Type = ValuePrinter.Type =
               InspectorValues.Type = Trace.Type = ShellUtils.Type =
               DebuggerUtilities.Debugger_Types.Type = Inspector.Type
  sharing type Incremental.InterMake.Compiler.TypeBasis =
    	       ValuePrinter.TypeBasis =
	       BasisTypes.Basis
  sharing type UserOptions.user_tool_options =
	       ShellTypes.user_options = Trace.UserOptions =
               ShellUtils.UserOptions
  sharing type ShellTypes.Context = Trace.Context =
	       Incremental.Context = ShellUtils.Context
  sharing type ShellTypes.ShellData = Inspector.ShellData =
               SaveImage.ShellData = ShellUtils.ShellData
  sharing type ShellUtils.preferences = ShellTypes.preferences = 
               Preferences.preferences
  sharing type ShellUtils.user_context =
	       ShellTypes.user_context = UserContext.user_context 
  sharing type UserOptions.user_context_options =
	       UserContext.user_context_options
  sharing type Preferences.user_preferences = ShellTypes.user_preferences
  sharing type Io.Location = Incremental.InterMake.Compiler.Info.Location.T =
	       ModuleId.Location = ProjFile.location
  sharing type ShellUtils.Info.options = ProjFile.error_info
  sharing type Project.Project = Incremental.InterMake.Project
): SHELL_STRUCTURE =
  struct
    structure InterMake = Incremental.InterMake
    structure Compiler = InterMake.Compiler
    structure Debugger_Types = DebuggerUtilities.Debugger_Types
    structure BasisTypes = BasisTypes
    structure Datatypes = Types.Datatypes
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Info = Compiler.Info
    structure Options = UserOptions.Options
    structure NewMap = Datatypes.NewMap
    structure Profile = MLWorks.Profile

    type ShellData = ShellTypes.ShellData
    type Context = Incremental.Context
    type IncrementalOptions = Incremental.options

    (* Utility functions *)
    (* Maybe these should be in a library somewhere *)

    val find_symbol = Symbol.find_symbol

    val cast = MLWorks.Internal.Value.cast

    (* Debugger stuff *)

    (* Take a function object, find its type from the debug information, and make *)
    (* a dynamic object *)

    exception MakeDynamic of string
    fun make_dynamic (f : 'a -> 'b) =
      let
        val debug_info = InterMake.current_debug_information ()
        val string = Trace.get_function_string f
        val t = (cast f) : MLWorks.Internal.Value.T
      in
        case Debugger_Types.lookup_debug_info (debug_info,string) of
          SOME (Debugger_Types.FUNINFO {ty,...}) =>
            (t,DebuggerUtilities.close_type ty)
        | _ => (print(string ^ "\n");
                raise MakeDynamic string)
      end


    (* This is a bit of a hack really. *)
    fun do_trace_error s = raise MLWorks.Internal.Trace.Trace s

    fun trace_full_dynamic (shell_data,(name,f2,f3)) =
      let
        val valtys = (name,make_dynamic f2,
                      make_dynamic f3)
      in
        Trace.trace_full valtys
      end
      handle MakeDynamic s => do_trace_error ("No debug information for " ^ s)

    fun print_dynamic (shell_data,dyn : MLWorks.Internal.Dynamic.dynamic) =
      let
        val print_options = ShellTypes.get_current_print_options shell_data
        val context = ShellTypes.get_current_context shell_data
        val debug_info = Incremental.debug_info context
        val (value,ty) = cast dyn
      in
        ValuePrinter.stringify_value false (print_options,
                                            value,
                                            ty,
                                            debug_info)
      end

    fun print_type (shell_data, tyrep : MLWorks.Internal.Dynamic.type_rep) =
      let
        val ty : Datatypes.Type = cast tyrep
        val options = ShellTypes.get_current_options shell_data
      in
        Types.print_type options ty
      end

    (* Here I try to make an exception constructor *)

    fun make_exn_tag s = s ^ "[<Shell>]"

    fun environment_error_exn label =
      (ref (),make_exn_tag label)

    fun make_environment_error_exn (exn : unit ref * string, s) : exn =
      cast (exn, s)

    fun env_error (exn, s) =
      raise (make_environment_error_exn (exn,s))

    (* Make the visible structures of the shell. This is called once to make
       a single shell_structure.  The data for each shell is obtained from a
       global reference.  This means that the shell_data_ref object should not
       be dereferences outside the shell functions. *)

    fun make_shell_structure is_a_tty_image (shell_data_ref, initial_context) =
      let
	val error_info = Info.make_default_options ()

        (* probably all access functions should be like this *)
        fun get_context () = ShellTypes.get_current_context (!shell_data_ref)

        fun shell_exit_fn n =
          let val (ShellTypes.SHELL_DATA{exit_fn,...}) = (!shell_data_ref)
          in
            exit_fn n
          end

        open Datatypes

        (* utilities for making the structures visible in shell *)

        (* make the types *)

        (* This won't quite work with abstypes, maybe *)

	fun get_runtime_type(longtycon as Ident.LONGTYCON(_, Ident.TYCON sy)) =
	  let
	    val Incremental.CONTEXT
	      {compiler_basis=Compiler.BASIS
	       {type_basis=BasisTypes.BASIS{5=env, ...}, ...}, ...} = initial_context
	    val TYSTR(tyfun, valenv) = Env.lookup_longtycon (longtycon,env)
	  in
	    CONSTYPE([], METATYNAME(ref tyfun, Symbol.symbol_name sy, 0,
				    ref(Types.equalityp tyfun), ref valenv, ref false))
	  end

        fun schemify ty = UNBOUND_SCHEME (ty,NONE)

	fun make_tyvar name = TYVAR (ref (0,NULLTYPE,NO_INSTANCE),
				     Ident.TYVAR (find_symbol name,
						  false,
						  false))

	fun mk_longtycon (p,s) =
	    let
	      val sym = find_symbol s
	      val symlist = map find_symbol p
	    in
	      Ident.LONGTYCON (Ident.mkPath symlist,
			       Ident.TYCON sym)
	    end


	fun mk_record l =
	  let
	    fun mk_record' (n,[],acc) = acc
	      | mk_record' (n,(lab,ty)::ls,acc) =
		let
		  val newacc =
		    Types.add_to_rectype (Ident.LAB (find_symbol lab),
					  ty,
					  acc)
		in
		  mk_record' (n+1, ls, newacc)
		end
	  in
	    mk_record' (1,l,Types.empty_rectype)
	  end

	fun make_tuple tylist =
	  let
	    val lab = ref 0
	  in
	    mk_record
	    (map
	     (fn x => (lab := (!lab +1);
		       (Int.toString (!lab),x)))
	      tylist)
	  end
			
        fun make_pair (a,b) =
	  make_tuple [a,b]

        fun make_triple (a,b,c) =
	  make_tuple [a,b,c]

        val string_pair =
          make_pair(Types.string_type,Types.string_type)

        val dynamic2 =
	  make_tuple [Types.dynamic_type,
		      Types.dynamic_type]

        val dynamic2_to_unit =
          FUNTYPE (dynamic2,Types.empty_rectype)

	val option_tyname =
	  Types.make_tyname (1, true, "option", NONE, 0)
                    (* top-level, so tyname gets level 0 *)

	val target_type_tyname =
	  Types.make_tyname (0, true, "targetType", NONE, 0)
                    (* top-level, so tyname gets level 0 *)


        val target_type = schemify(CONSTYPE([], target_type_tyname))


        fun build_record_type list =
          List.foldl
            (fn ((label, typ), rectype) =>
              Types.add_to_rectype(
                Types.Datatypes.Ident.LAB(
                  Types.Datatypes.Ident.Symbol.find_symbol label), 
                typ,
                rectype)) Types.empty_rectype
            list;

        val mode_details_type =
            build_record_type
            [("location", Types.string_type),
             ("generate_interruptable_code", Types.bool_type),
             ("generate_interceptable_code", Types.bool_type),
             ("generate_debug_info", Types.bool_type),
             ("generate_variable_debug_info", Types.bool_type),
             ("optimize_leaf_fns", Types.bool_type),
             ("optimize_tail_calls", Types.bool_type),
             ("optimize_self_tail_calls", Types.bool_type),
             ("mips_r4000", Types.bool_type),
             ("sparc_v7", Types.bool_type)];


        val configuration_details_type =
            build_record_type
            [("files", CONSTYPE([Types.string_type], Types.list_tyname)),
             ("library", CONSTYPE([Types.string_type], Types.list_tyname))];

        val location_details_type =
            build_record_type
            [("libraryPath", CONSTYPE([Types.string_type], Types.list_tyname)),
             ("objectsLoc", Types.string_type),
             ("binariesLoc", Types.string_type)];

        val about_details_type =
            build_record_type
            [("description", Types.string_type),
             ("version", Types.string_type)];

        val consumer_type =
          schemify (FUNTYPE(make_pair(Types.string_type,
                                      FUNTYPE(Types.string_type, Types.empty_rectype)),
                            Types.string_type))

        val show_type =
          schemify (FUNTYPE (Types.empty_rectype,CONSTYPE([Types.string_type], Types.list_tyname)))

        val string_to_dynamic =
          schemify (FUNTYPE (Types.string_type, Types.dynamic_type))

        val dynamic_to_string =
          schemify (FUNTYPE (Types.dynamic_type, Types.string_type))

        val dynamic_to_type =
          schemify (FUNTYPE (Types.dynamic_type, Types.typerep_type))

        val dynamic_to_unit =
          schemify (FUNTYPE (Types.dynamic_type, Types.empty_rectype))

        val type_to_string =
          schemify (FUNTYPE (Types.typerep_type, Types.string_type))

        val unit_to_unit =
          schemify (FUNTYPE (Types.empty_rectype, Types.empty_rectype))

        val int_to_unit =
          schemify (FUNTYPE (Types.int_type, Types.empty_rectype))

        val bool_to_unit =
          schemify (FUNTYPE (Types.bool_type, Types.empty_rectype))

        val string_to_unit =
          schemify (FUNTYPE (Types.string_type, Types.empty_rectype))

        val unit_to_string =
          schemify (FUNTYPE (Types.empty_rectype, Types.string_type))

	val string_cross_string_to_unit =
	  schemify(FUNTYPE (make_pair(Types.string_type, Types.string_type),
			     Types.empty_rectype))

	val string_cross_bool_to_unit =
	  schemify(FUNTYPE (make_pair(Types.string_type, Types.bool_type),
			     Types.empty_rectype))

        val string_to_exn_type =
	  FUNTYPE (Types.string_type, Types.exn_type)
        val string_to_exn = schemify string_to_exn_type

        val type_pair_to_exn_type =
	  FUNTYPE
	    (make_pair (Types.typerep_type, Types.typerep_type), Types.exn_type)
        val type_pair_to_exn = schemify type_pair_to_exn_type

	val string_cross_string_list_to_unit =
	  schemify(FUNTYPE(make_pair(Types.string_type, CONSTYPE([Types.string_type], Types.list_tyname)),
			   Types.empty_rectype))

	local
	  val alpha = make_tyvar "'a"
	  val beta  = make_tyvar "'b"
          fun make_alpha_beta_to_type ty =
	    let
	      val type_instance =
	        FUNTYPE (FUNTYPE (alpha,beta), ty)
	    in
	      Scheme.make_scheme([alpha,beta], (type_instance, NONE))
	    end

	in
	  val fun_to_bool = make_alpha_beta_to_type Types.bool_type
	  val fun_to_string = make_alpha_beta_to_type Types.string_type
	  val fun_to_unit = make_alpha_beta_to_type Types.empty_rectype
          val fun_to_fun =
            let
              val alpha = make_tyvar "'a"
              val beta  = make_tyvar "'b"
            in
              Scheme.make_scheme ([alpha,beta], (FUNTYPE (FUNTYPE (alpha,beta),FUNTYPE (alpha,beta)),NONE))
            end
          val trace_full_type =
            let
              val c = make_tyvar "'c"
              val d = make_tyvar "'d"
              val e = make_tyvar "'e"
              val f = make_tyvar "'f"
            in
              Scheme.make_scheme
              ([c,d,e,f],
               (FUNTYPE (make_tuple [Types.string_type,
                                     FUNTYPE (c,d),
                                     FUNTYPE (e,f)],
                         Types.empty_rectype),
                NONE))
            end
	end

        val string_list_to_unit =
          schemify (FUNTYPE (CONSTYPE([Types.string_type], Types.list_tyname),
                             Types.empty_rectype))

	val string_to_string_cross_string_list =
	  schemify (FUNTYPE (Types.string_type,
			make_pair (Types.string_type,
				   CONSTYPE([Types.string_type], Types.list_tyname))))

        val string_list_cross_string_list =
            make_pair(CONSTYPE([Types.string_type], Types.list_tyname),
                      CONSTYPE([Types.string_type], Types.list_tyname))

        val string_cross_string_cross_string_list =
            make_triple(Types.string_type,
                        Types.string_type,
                        CONSTYPE([Types.string_type], Types.list_tyname)
                       )

        val string_cross_target_type_to_unit =
          schemify (FUNTYPE (make_pair(Types.string_type,
                                       CONSTYPE([], target_type_tyname)),
                             Types.empty_rectype))

        val string_to_target_type =
          schemify (FUNTYPE (Types.string_type,
                             CONSTYPE([], target_type_tyname)))

        val string_to_mode_details =
          schemify (FUNTYPE (Types.string_type,
                             mode_details_type))

        val string_to_configuration_details =
          schemify (FUNTYPE (Types.string_type,
                             configuration_details_type))

        val string_cross_mode_details_to_unit =
          schemify (FUNTYPE (make_pair(Types.string_type,
                                       mode_details_type),
                             Types.empty_rectype))

        val string_cross_configuration_details_to_unit =
          schemify (FUNTYPE (make_pair(Types.string_type,
                                       configuration_details_type),
                             Types.empty_rectype))

        val unit_to_location_details =
          schemify (FUNTYPE (Types.empty_rectype, location_details_type))

        val location_details_to_unit =
          schemify (FUNTYPE (location_details_type, Types.empty_rectype))

        val unit_to_about_details =
          schemify (FUNTYPE (Types.empty_rectype, about_details_type))

        val about_details_to_unit =
          schemify (FUNTYPE (about_details_type, Types.empty_rectype))

        val string_cross_string_cross_string_list_to_unit =
          schemify (FUNTYPE (string_cross_string_cross_string_list,
                             Types.empty_rectype))

	val string_to_string =
	  schemify (FUNTYPE (Types.string_type, Types.string_type))

        val string_to_string_cross_string_cross_string_list =
          schemify (FUNTYPE (Types.string_type,
                             string_cross_string_cross_string_list))

        val unit_to_string_list =
          schemify (FUNTYPE (Types.empty_rectype,
                             CONSTYPE([Types.string_type], Types.list_tyname)))

        val unit_to_string_list_cross_string_list =
          schemify (FUNTYPE (Types.empty_rectype,
                             string_list_cross_string_list))

        val opt_switches_type =
          CONSTYPE([make_pair(Types.string_type,
                              CONSTYPE([Types.bool_type],Types.ref_tyname))],
                   Types.list_tyname)

	fun mk_valenv (vals,exns) =
          let val valvalenv =
            Lists.reducel
            (fn (ve, (name,scheme)) =>
             Valenv.add_to_ve
             (Ident.VAR(find_symbol name),scheme,ve))
            (empty_valenv, vals)
          in
            Lists.reducel
            (fn (ve, (name, scheme)) =>
             Valenv.add_to_ve
             (Ident.EXCON(find_symbol name),scheme,ve))
            (valvalenv, exns)
          end


	fun mk_tyenv l =
	  Lists.reducel
	  (fn (te, (name, tystr)) =>
	   Tyenv.add_to_te
	   (te,
	    Ident.TYCON(find_symbol name),
	    tystr))
	  (Tyenv.empty_tyenv, l)

	fun mk_strenv l =
	  Lists.reducel
	  (fn (se, (name, str)) =>
	   Strenv.add_to_se(
			    Ident.STRID(find_symbol name),
			    str,
			    se
			    )
	   )
	  (Strenv.empty_strenv, l)

	fun mk_mixed_structure(strs, tys, vals,exns) =
          STR
	    (STRNAME (Types.make_stamp ()),
	     ref NONE,
	     ENV(mk_strenv strs,
                 mk_tyenv tys,
	         mk_valenv (vals,exns)))

	fun mk_structure vals = mk_mixed_structure([], [], vals, [])
	fun mk_exn_structure (vals,exns) = mk_mixed_structure([], [], vals, exns)
	fun mk_option t = schemify (CONSTYPE([t], option_tyname))

	(* To make an exception that the user can handle, define the label
	   and exception value here, trap any internal exception and raise
	   the new one, and put the new one in the user-visible space. *)

        val edit_exn_label = "EditError"
        val eval_exn_label = "EvalError"
	val path_exn_label = "PathError"
        val inspect_exn_label = "InspectError"
        val project_exn_label = "ProjectError"

        val edit_exn = environment_error_exn edit_exn_label
        val eval_exn = environment_error_exn eval_exn_label
        val path_exn = environment_error_exn path_exn_label
        val inspect_exn = environment_error_exn inspect_exn_label
        val project_exn = environment_error_exn project_exn_label

        fun do_inspect_error s = env_error (inspect_exn,s)

        fun eval_string (shell_data,string) =
          let
            val context = ShellTypes.get_current_context shell_data
            val options = ShellTypes.get_current_options shell_data
            val error_info = Info.make_default_options ()
            val result =
              Info.with_report_fun
              error_info
              (fn _ => ())
              ShellUtils.eval
              (string,options,context)
          in
            (cast result) : MLWorks.Internal.Dynamic.dynamic
          end
        handle Info.Stop (e, _) =>
	  env_error (eval_exn, Info.string_error e)

        fun shell_eval_fn s =
          eval_string (!shell_data_ref,s)

        fun use_fun s =
          let
            val ShellTypes.SHELL_DATA {get_user_context,
                                       user_options,
                                       user_preferences,
                                       debugger,
                                       ...} = !shell_data_ref
            fun output_fn s = print s
            val error_info = Info.make_default_options ()
          in
            ShellUtils.use_file (!shell_data_ref, print, s)
          end

        fun use_string_fun s =
          let
            val ShellTypes.SHELL_DATA {get_user_context,
                                       user_options,
                                       user_preferences,
                                       debugger,
                                       ...} = !shell_data_ref
            fun output_fn s = print s
            val error_info = Info.make_default_options ()
          in
            ShellUtils.use_string (!shell_data_ref, print, s)
          end

        fun shell_dyn_trace_full d = trace_full_dynamic (!shell_data_ref,d)
        fun shell_dyn_print_val d = print_dynamic (!shell_data_ref,d)
        fun shell_dyn_print_type t = print_type (!shell_data_ref,t)

        fun add_inspect_method (f : 'a -> 'b) =
          InspectorValues.add_inspect_method (make_dynamic f)
          handle MakeDynamic s => do_inspect_error ("No debug information for " ^ s)

        fun delete_inspect_method (f : 'a -> 'b) =
          InspectorValues.delete_inspect_method (make_dynamic f)
          handle MakeDynamic s => do_inspect_error ("No debug information for " ^ s)

        fun delete_all_inspect_methods () =
          InspectorValues.delete_all_inspect_methods ()

        val inspect_it_fn  : unit -> unit =
          (fn () => Inspector.inspect_it (!shell_data_ref))

        val inspect_dyn_fn =
          (fn (d: MLWorks.Internal.Dynamic.dynamic) =>
	     Inspector.inspect_value (cast d,!shell_data_ref))

        val value_printer_structure = mk_structure
          [("showFnDetails",  mk_option Types.bool_type),
           ("showExnDetails",  mk_option Types.bool_type),
           ("floatPrecision",  mk_option Types.int_type),
           ("maximumSeqSize",  mk_option Types.int_type),
           ("maximumStringSize",  mk_option Types.int_type),
           ("maximumRefDepth",  mk_option Types.int_type),
           ("maximumStrDepth",  mk_option Types.int_type),
           ("maximumSigDepth",  mk_option Types.int_type),
           ("maximumDepth",  mk_option Types.int_type)
           ]

	type internal_exn_rep = unit ref * string

	type 'a option_rep = (unit -> 'a) * ('a -> unit)

        (* Make up the type 'a Option * 'a -> unit *)
        val set_option_type =
          let
            val aty = make_tyvar "'a"
	    val aty_option = CONSTYPE([aty], option_tyname)
          in
            Scheme.make_scheme ([aty],
                                (FUNTYPE(make_pair (aty_option, aty),
                                        Types.empty_rectype),NONE))
          end

	fun set_option ((_, setter), v) = setter v;

        (* Make up the type 'a Option -> 'a *)
        val get_option_type =
          let
            val aty = make_tyvar "'a"
	    val aty_option = CONSTYPE([aty], option_tyname)
          in
            Scheme.make_scheme ([aty], (FUNTYPE(aty_option, aty),NONE))
          end

	fun get_option (getter, _) = getter ();

        fun get_tool_option_fun f () =
	  let val UserOptions.USER_TOOL_OPTIONS (user_options,_) =
		ShellTypes.get_user_options (!shell_data_ref)
	  in !(f user_options)
	  end
	
	fun set_tool_option_fun f v =
	  let val UserOptions.USER_TOOL_OPTIONS (user_options,ref update_fns) =
		ShellTypes.get_user_options (!shell_data_ref)
	  in
            (f user_options) := v;
            app (fn f => f ()) update_fns
	  end

	fun make_tool_option_rep f =
	  (get_tool_option_fun f, set_tool_option_fun f)
	
        fun get_context_option_fun f () =
	  let val UserOptions.USER_CONTEXT_OPTIONS (user_options, _) =
		UserContext.get_user_options
		  (ShellTypes.get_user_context (!shell_data_ref))
	  in !(f user_options)
	  end
	
	fun set_context_option_fun f v =
	  let
	    val UserOptions.USER_CONTEXT_OPTIONS
		  (user_options, ref update_fns) =
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
	  in
            (f user_options) := v;
            app (fn f => f ()) update_fns
	  end

	fun make_context_option_rep f =
	  (get_context_option_fun f, set_context_option_fun f)

        (* changing oldDefinition option in Shell.Options.Language *)
        (* ought to affect the equality attribute on Types.real_tyname *)

	fun make_oldDefinition_option_rep f =
	  (get_context_option_fun f,
           (fn f => fn v => (Types.real_tyname_equality_attribute := v;
                             set_context_option_fun f v)) f)

	
        fun update_user_options () =
          let
            val user_context_options =
	      UserContext.get_user_options
                (ShellTypes.get_user_context (!shell_data_ref))
          in
            UserOptions.update_user_context_options user_context_options
          end

        fun get_preference_fun f () =
	  let val Preferences.USER_PREFERENCES (user_preferences, _) =
		ShellTypes.get_user_preferences (!shell_data_ref)
	  in !(f user_preferences)
	  end
	
	fun set_preference_fun f v =
	  let
	    val Preferences.USER_PREFERENCES
		  (user_preferences, ref update_fns) =
		ShellTypes.get_user_preferences (!shell_data_ref)
	  in
            (f user_preferences) := v;
            app (fn f => f ()) update_fns
	  end

	fun make_preference_rep f =
	  (get_preference_fun f, set_preference_fun f)
	
	val value_printer_record =
          cast
          {maximumDepth =
	     (make_tool_option_rep #maximum_depth) : int option_rep,
           maximumRefDepth =
	     (make_tool_option_rep #maximum_ref_depth) : int option_rep,
           maximumStrDepth =
	     (make_tool_option_rep #maximum_str_depth) : int option_rep,
           maximumSigDepth =
	     (make_tool_option_rep #maximum_sig_depth) : int option_rep,
           maximumSeqSize =
	     (make_tool_option_rep #maximum_seq_size) : int option_rep,
           maximumStringSize =
	     (make_tool_option_rep #maximum_string_size) : int option_rep,
           floatPrecision =
	     (make_tool_option_rep #float_precision) : int option_rep,
           showFnDetails =
	     (make_tool_option_rep #show_fn_details) : bool option_rep,
           showExnDetails =
	     (make_tool_option_rep #show_exn_details) : bool option_rep
           }

	val internals_structure = mk_structure
	  [("showAbsyn", mk_option Types.bool_type),
	   ("showLambda", mk_option Types.bool_type),
	   ("showOptLambda", mk_option Types.bool_type),
	   ("showEnviron", mk_option Types.bool_type),
	   ("showMir", mk_option Types.bool_type),
	   ("showOptMir", mk_option Types.bool_type),
	   ("showMach", mk_option Types.bool_type)]

	val internals_record =
          cast
	  {showAbsyn = (make_tool_option_rep #show_absyn) : bool option_rep,
	   showLambda = (make_tool_option_rep #show_lambda) : bool option_rep,
	   showOptLambda =
	     (make_tool_option_rep #show_opt_lambda) : bool option_rep,
	   showEnviron =
	     (make_tool_option_rep #show_environ) : bool option_rep,
	   showMir = (make_tool_option_rep #show_mir) : bool option_rep,
	   showOptMir =
	     (make_tool_option_rep #show_opt_mir) : bool option_rep,
	   showMach = (make_tool_option_rep #show_mach) : bool option_rep
	   }

	val preferences_structure = mk_structure
	  [
	   ("oneWayEditorName", mk_option Types.string_type),
	   ("twoWayEditorName", mk_option Types.string_type),
	   ("editor", mk_option Types.string_type),
	   ("externalEditorCommand", mk_option Types.string_type),
	   ("maximumHistorySize", mk_option Types.int_type),
	   ("maximumErrors", mk_option Types.int_type),
	   ("useCompletionMenu", mk_option Types.bool_type),
	   ("useDebugger",  mk_option Types.bool_type),
	   ("useErrorBrowser",  mk_option Types.bool_type),
	   ("useRelativePathname",  mk_option Types.bool_type),
	   ("useWindowDebugger",  mk_option Types.bool_type)]

	val preferences_record =
          cast
          {editor = (make_preference_rep #editor) : string option_rep,
           externalEditorCommand =
	     (make_preference_rep #externalEditorCommand) : string option_rep,
           oneWayEditorName =
	     (make_preference_rep #oneWayEditorName) : string option_rep,
           twoWayEditorName =
	     (make_preference_rep #twoWayEditorName) : string option_rep,
           maximumHistorySize =
             (make_preference_rep #history_length) : int option_rep,
           maximumErrors =
             (make_preference_rep #max_num_errors) : int option_rep,
           useCompletionMenu =
             (make_preference_rep #completion_menu) : bool option_rep,
           useDebugger =
	     (make_preference_rep #use_debugger) : bool option_rep,
           useErrorBrowser =
	     (make_preference_rep #use_error_browser) : bool option_rep,
           useRelativePathname =
	     (make_preference_rep #use_relative_pathname) : bool option_rep,
           useWindowDebugger =
	     (make_preference_rep #window_debugger) : bool option_rep
           }

	val compiler_structure = mk_structure
          [("generateTraceProfileCode", mk_option Types.bool_type),
	   ("generateDebugInfo", mk_option Types.bool_type),
	   ("generateLocalFunctions", mk_option Types.bool_type),
	   ("generateVariableDebugInfo", mk_option Types.bool_type),
	   (*
           ("generate_moduler", mk_option Types.bool_type),
	   *)
	   ("interruptTightLoops", mk_option Types.bool_type),
	   ("mipsR4000andLater", mk_option Types.bool_type),
	   ("optimizeHandlers", mk_option Types.bool_type),
	   ("optimizeLeafFns", mk_option Types.bool_type),
	   ("optimizeTailCalls", mk_option Types.bool_type),
	   ("optimizeSelfTailCalls", mk_option Types.bool_type),
	   ("printCompilerMessages", mk_option Types.bool_type),
	   ("sparcV7", mk_option Types.bool_type)
           ]

	val compiler_record =
          cast
          {generateTraceProfileCode =
             (make_context_option_rep #generate_interceptable_code) :
	       bool option_rep,
           generateDebugInfo =
             (make_context_option_rep #generate_debug_info) : bool option_rep,
           generateLocalFunctions =
             (make_context_option_rep #local_functions) : bool option_rep,
           generateVariableDebugInfo =
             (make_context_option_rep #generate_variable_debug_info) :
	       bool option_rep,
	   (*
           generate_moduler =
           (make_context_option_rep #generate_moduler) : bool option_rep,
	   *)
	   interruptTightLoops =
	   (make_context_option_rep #generate_interruptable_code) :
	   bool option_rep,
           mipsR4000andLater =
             (make_context_option_rep #mips_r4000) :
	       bool option_rep,
           optimizeHandlers = (make_context_option_rep #optimize_handlers) :
	   bool option_rep,
           optimizeLeafFns = (make_context_option_rep #optimize_leaf_fns) :
	   bool option_rep,
           optimizeTailCalls = (make_context_option_rep #optimize_tail_calls):
	   bool option_rep,
           optimizeSelfTailCalls = (make_context_option_rep #optimize_self_tail_calls):
	   bool option_rep,
	   printCompilerMessages = (make_context_option_rep #print_messages):
	   bool option_rep,
           sparcV7 = (make_context_option_rep #sparc_v7) : bool option_rep
           }

        val debugger_structure = mk_structure
          [("hideCFrames", mk_option Types.bool_type),
           ("hideSetupFrames", mk_option Types.bool_type),
           ("hideAnonymousFrames", mk_option Types.bool_type),
           ("hideHandlerFrames", mk_option Types.bool_type),
           ("hideDeliveredFrames", mk_option Types.bool_type),
           ("hideDuplicateFrames", mk_option Types.bool_type)]

	val debugger_record =
          let
            fun mkDebuggerOption flag =
              (fn ()=> !flag, fn v => (flag:=v))
          in
            cast
            {hideCFrames =
             (mkDebuggerOption StackFrame.hide_c_frames)
                                                   : bool option_rep,
	     hideSetupFrames =
             (mkDebuggerOption StackFrame.hide_setup_frames)
                                                    : bool option_rep,
             hideAnonymousFrames =
	     (mkDebuggerOption StackFrame.hide_anonymous_frames)
                                                    : bool option_rep,
             hideHandlerFrames =
	     (mkDebuggerOption StackFrame.hide_handler_frames)
                                                    : bool option_rep,
             hideDeliveredFrames =
	     (mkDebuggerOption StackFrame.hide_delivered_frames)
                                                    : bool option_rep,
             hideDuplicateFrames =
	     (mkDebuggerOption StackFrame.hide_duplicate_frames)
                                                    : bool option_rep}
          end


	val language_structure = mk_structure
	  [("oldDefinition", mk_option Types.bool_type),
	   ("opOptional", mk_option Types.bool_type),
	   ("limitedOpen", mk_option Types.bool_type),
	   ("weakTyvars", mk_option Types.bool_type),
	   ("fixityInSignatures", mk_option Types.bool_type),
	   ("fixityInOpen", mk_option Types.bool_type),
	   ("abstractions", mk_option Types.bool_type),
           ("requireReservedWord", mk_option Types.bool_type),
           ("typeDynamic", mk_option Types.bool_type)
	   (*
	   ("default_overloads", mk_option Types.bool_type),
	   *)
	   ]

	val language_record =
	  cast
	  {oldDefinition =
	     (make_oldDefinition_option_rep #old_definition) : bool option_rep,
	   opOptional =
	     (make_context_option_rep #nj_op_in_datatype) : bool option_rep,
	   limitedOpen =
	     (make_context_option_rep #nj_signatures) : bool option_rep,
	   weakTyvars =
	     (make_context_option_rep #weak_type_vars) : bool option_rep,
	   fixityInSignatures =
	     (make_context_option_rep #fixity_specs) : bool option_rep,
	   fixityInOpen =
	     (make_context_option_rep #open_fixity) : bool option_rep,
           abstractions =
	     (make_context_option_rep #abstractions) : bool option_rep,
           requireReservedWord =
	     (make_context_option_rep #require_keyword) : bool option_rep,
           typeDynamic =
	     (make_context_option_rep #type_dynamic) : bool option_rep
	   (*
	   default_overloads =
	     (make_context_option_rep #default_overloads) : bool option_rep,
	   *)}

	val mode_option_structure = mk_structure
	  [("compatibility", unit_to_unit),
	   ("sml'97", unit_to_unit),
	   ("sml'90", unit_to_unit),
	   ("optimizing", unit_to_unit),
	   ("quick_compile", unit_to_unit),
	   ("debugging", unit_to_unit)]

	fun select_compatibility () =
	  let
	    val user_context_options =
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
	  in
	    UserOptions.select_compatibility user_context_options;
	    UserOptions.update_user_context_options user_context_options
	  end
	
	fun select_sml'97 () =
	  let
	    val user_context_options =
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
            val _ = MLWorks.Internal.Dynamic.generalises_ref:=
              Scheme.SML96_dynamic_generalises
            val _ = Types.real_tyname_equality_attribute := false
	  in
	    UserOptions.select_sml'97 user_context_options;
	    UserOptions.update_user_context_options user_context_options
	  end

	fun select_sml'90 () =
	  let
	    val user_context_options =
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
            val _ = MLWorks.Internal.Dynamic.generalises_ref:=
              Scheme.SML90_dynamic_generalises
            val _ = Types.real_tyname_equality_attribute := true
    	  in
	    UserOptions.select_sml'90 user_context_options;
	    UserOptions.update_user_context_options user_context_options
	  end

	fun select_optimizing () =
	  let
	    val user_context_options =
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
	  in
	    UserOptions.select_optimizing user_context_options;
	    UserOptions.update_user_context_options user_context_options
	  end

	fun select_debugging () =
	  let
	    val user_context_options =
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
	  in
	    UserOptions.select_debugging user_context_options;
	    UserOptions.update_user_context_options user_context_options
	  end

	fun select_quick_compile () =
	  let
	    val user_context_options = 
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
	  in
	    UserOptions.select_quick_compile user_context_options;
	    UserOptions.update_user_context_options user_context_options
	  end

	val mode_option_record =
	  cast
	  {compatibility = select_compatibility : unit -> unit,
	   sml'97 = select_sml'97 : unit -> unit,
	   sml'90 = select_sml'90 : unit -> unit,
	   quick_compile = select_quick_compile : unit -> unit,
	   optimizing = select_optimizing : unit -> unit,
	   debugging = select_debugging : unit -> unit}

        val inspector_structure =
          mk_exn_structure
          ([("addInspectMethod",fun_to_unit),
            ("deleteInspectMethod",fun_to_unit),
            ("deleteAllInspectMethods",unit_to_unit),
            ("inspectIt",unit_to_unit)],
           [(inspect_exn_label,string_to_exn)])

        val inspector_record =
          cast
          {a_InspectError = inspect_exn : internal_exn_rep,
           a_inspectIt = inspect_it_fn : unit -> unit,
           a_addInspectMethod = add_inspect_method : ('a -> 'b) -> unit,
           a_deleteInspectMethod = delete_inspect_method : ('a -> 'b) -> unit,
           a_deleteAllInspectMethods =
	     delete_all_inspect_methods : unit -> unit}

        val dynamic_structure = mk_mixed_structure
          ([],
	   [("dynamic",
	     TYSTR (ETA_TYFUN Types.dynamic_tyname, empty_valenv)),
	    ("type_rep",
	     TYSTR (ETA_TYFUN Types.typerep_tyname, empty_valenv))],
	   [("eval", string_to_dynamic),
	    ("getType", dynamic_to_type),
            ("inspect",dynamic_to_unit),
            ("printValue",dynamic_to_string),
            ("printType",type_to_string)],
           [(eval_exn_label, string_to_exn),
	    ("Coerce", type_pair_to_exn)])

	val coerce_exn =
	  (* This gets the value of the Coerce exception *)
	  let
	    (* First we apply the function that constructs the exception
	       to some dummy arguments *)
	    val the_exn = MLWorks.Internal.Dynamic.Coerce (cast (0, 0))
	  in
	    (* Now we strip off the argument from the constructed exception *)
	    case cast the_exn
	    of (internal_rep, _) => internal_rep: internal_exn_rep
	  end

        val dynamic_record =
          cast
          {a_eval = shell_eval_fn : string -> MLWorks.Internal.Dynamic.dynamic,
           a_EvalError = eval_exn : internal_exn_rep,
	   a_Coerce = coerce_exn: internal_exn_rep,
	   a_getType = MLWorks.Internal.Value.cast (fn (a,b) => b),
           a_inspect =
	     inspect_dyn_fn : MLWorks.Internal.Dynamic.dynamic -> unit,
           a_printValue =
	     shell_dyn_print_val : MLWorks.Internal.Dynamic.dynamic -> string,
           a_printType =
	     shell_dyn_print_type : MLWorks.Internal.Dynamic.type_rep -> string}

        val trace_structure = mk_structure
          [("breakpoint",string_to_unit),
           ("trace",string_to_unit),
           ("unbreakpoint",string_to_unit),
           ("untrace",string_to_unit),
           ("traceFull",trace_full_type),
	   ("untraceAll",unit_to_unit),
	   ("unbreakAll",unit_to_unit)]

	fun break name = Trace.break{name=name, hits=0, max=1}

        val trace_record =
          cast
          {a_breakpoint = break : string-> unit,
           a_trace = Trace.trace : string-> unit,
           a_unbreakpoint = Trace.unbreak : string-> unit,
           a_untrace = Trace.untrace : string-> unit,
           a_traceFull =
	     shell_dyn_trace_full : (string * ('c -> 'd) * ('e -> 'f) -> unit),
           a_untraceAll = Trace.untrace_all : unit -> unit,
           a_unbreakAll = Trace.unbreak_all : unit -> unit}
           
        type mode_details =
          {location:				      string,
           generate_interruptable_code:               bool,
           generate_interceptable_code:               bool,
           generate_debug_info:                       bool,
           generate_variable_debug_info:              bool,
           optimize_leaf_fns:                         bool,
           optimize_tail_calls:                       bool,
           optimize_self_tail_calls:                  bool,
           mips_r4000:                                bool,
           sparc_v7:                                  bool}

        type configuration_details =
          {files:				      string list,
           library:                                   string list}


        type location_details =
           {libraryPath:	string list,
            objectsLoc:	        string,
            binariesLoc:	string}

        type about_details = 
           {description:	string,
            version:		string}

        val project_structure = mk_mixed_structure 
          ([],
           [(*("targetType",
               TYSTR (ETA_TYFUN target_type_tyname, empty_valenv)), *)
            ("mode_details", 
               TYSTR (TYFUN(mode_details_type,0), empty_valenv)),
            ("configuration_details", 
               TYSTR (TYFUN(configuration_details_type,0), empty_valenv)),
            ("location_details", 
               TYSTR (TYFUN(location_details_type,0), empty_valenv)),
            ("about_details", 
               TYSTR (TYFUN(about_details_type,0), empty_valenv))],
           [
           (*
           ("IMAGE", target_type),
           ("OBJECT_FILE", target_type),
           ("EXECUTABLE", target_type),
           ("LIBRARY", target_type),
           *)
           ("newProject", string_to_unit),
           ("openProject", string_to_unit),
           ("saveProject", unit_to_unit),
           ("saveProjectAs", string_to_unit),
           ("closeProject", unit_to_unit),
           ("setFiles", string_list_to_unit),
           ("showFiles", unit_to_string_list),
           
           ("setSubprojects", string_list_to_unit),
           ("showSubprojects", unit_to_string_list),
           ("setLocations", location_details_to_unit),
           ("showLocations", unit_to_location_details),
           ("setAboutInfo", about_details_to_unit),
           ("showAboutInfo", unit_to_about_details),
           ("showFilename", unit_to_string),
           
	   ("setConfiguration", string_to_unit),
	   ("removeConfiguration", string_to_unit),
	   ("setConfigurationDetails", string_cross_configuration_details_to_unit),
	   ("showAllConfigurations", unit_to_string_list),
	   ("showCurrentConfiguration", unit_to_string),
	   ("showConfigurationDetails", string_to_configuration_details),

	   ("setMode", string_to_unit),
	   ("removeMode", string_to_unit),
	   ("setModeDetails", string_cross_mode_details_to_unit),
	   ("showAllModes", unit_to_string_list),
	   ("showCurrentMode", unit_to_string),
	   ("showModeDetails", string_to_mode_details),

	   ("setTargets", string_list_to_unit),
           ("setTargetDetails", string_to_unit),
           ("removeTarget", string_to_unit),
           ("showAllTargets", unit_to_string_list),
           ("showCurrentTargets", unit_to_string_list),
           (* ("showTargetDetails", string_to_target_type), *)

	   ("compile", string_to_unit),
           ("showCompile", string_to_unit),
           ("forceCompile", string_to_unit),

           ("compileAll", unit_to_unit),
           ("showCompileAll", unit_to_unit),
	   ("forceCompileAll", unit_to_unit),

           ("load", string_to_unit),
           ("showLoad", string_to_unit),
           ("forceLoad", string_to_unit),

           ("loadAll", unit_to_unit),
           ("showLoadAll", unit_to_unit),
           ("forceLoadAll", unit_to_unit),

	   (* ("makeDll", string_cross_string_list_to_unit), *)
	   ("makeExe", string_cross_string_list_to_unit),
	   (*
           ("listObjects", unit_to_unit),
	   *)
           ("delete", string_to_unit),
           ("readDependencies", string_to_unit)],
           [(project_exn_label,string_to_exn)])

        fun refresh_project () =
          Incremental.set_project(Incremental.get_project())

	fun get_location () =
	  Info.Location.FILE (ShellTypes.get_current_toplevel_name ())


(* handling Info.Stop here to raise the ProjectError exception is not 
 * what we want because it then also catches compiler errors and reports
 * them as project errors.  Quick fix is needed for release but this 
 * still needs attention so that the case where no targets are selected
 * is reported by an exception being raised so that users of Shell.Project
 * can catch it in their programs.
 *)
	fun compile_all () =
	  (ShellUtils.compile_targets
	    (get_location (),
	     ShellTypes.get_current_options (!shell_data_ref))
	    error_info)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)
	fun show_compile_all () =
	  (ShellUtils.show_compile_targets
	    (get_location (), print)
	    error_info)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun compile filename =
          (ShellUtils.compile_file
            (get_location (),
	     ShellTypes.get_current_options (!shell_data_ref))
            error_info
            filename)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun show_compile filename =
          (ShellUtils.show_compile_file
            (get_location (), print)
            error_info
            filename)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun force_compile filename = 
          (ShellUtils.force_compile 
            (get_location (),
	     ShellTypes.get_current_options (!shell_data_ref))
            error_info
            filename)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun force_compile_all () = 
          (ShellUtils.force_compile_all
            (get_location (),
	     ShellTypes.get_current_options (!shell_data_ref))
            error_info)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun delete_from_project s =
	  ShellUtils.delete_from_project (s, get_location ())

	fun load filename =
          (ShellUtils.load_file
            (ShellTypes.get_user_context (!shell_data_ref),
	     get_location (),
	     ShellTypes.get_current_options (!shell_data_ref),
             ShellTypes.get_current_preferences (!shell_data_ref),
	     print)
            error_info
            filename)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun show_load filename =
          (ShellUtils.show_load_file
            (get_location (), print)
            error_info
            filename)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun load_targets () =
	  (ShellUtils.load_targets
	    (ShellTypes.get_user_context (!shell_data_ref),
	     get_location (),
	     ShellTypes.get_current_options (!shell_data_ref),
             ShellTypes.get_current_preferences (!shell_data_ref),
	     print)
            error_info)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun show_load_targets () =
          (ShellUtils.show_load_targets
            (get_location (), print)
            error_info)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun force_load filename =
          (let
            val module_id = ModuleId.from_string (filename, get_location ())
          in
	    Incremental.delete_module error_info module_id;
            load filename
          end)
(*
          handle Info.Stop (e, _) =>
	    env_error (project_exn, Info.string_error e)
*)

	fun read_dependencies filename =
          let
	    val toplevel_name = ShellTypes.get_current_toplevel_name ()

            val module_id =
                  ModuleId.from_string
                    (filename, Info.Location.FILE toplevel_name)
          in
	    Incremental.read_dependencies
	      toplevel_name
              error_info
              module_id
          end

        fun show_mode_details mode =
          let val (modes, details, _) = ProjFile.getModes()
           in if List.exists(fn m => m = mode) modes
              then let val {name, location, generate_interruptable_code,
                            generate_interceptable_code, generate_debug_info,
                            generate_variable_debug_info, optimize_leaf_fns,
                            optimize_tail_calls, optimize_self_tail_calls,
                            mips_r4000, sparc_v7} = ProjFile.getModeDetails(mode, details)
                    in {location = !location,
                        generate_interruptable_code = !generate_interruptable_code,
                        generate_interceptable_code = !generate_interceptable_code, 
                        generate_debug_info = !generate_debug_info,
                        generate_variable_debug_info = !generate_variable_debug_info,
                        optimize_leaf_fns = !optimize_leaf_fns,
                        optimize_tail_calls = !optimize_tail_calls, 
                        optimize_self_tail_calls = !optimize_self_tail_calls,
                        mips_r4000 = !mips_r4000, 
                        sparc_v7 = !sparc_v7}
                   end
                 else env_error (project_exn, "There is no mode called " ^ mode)
          end

        fun set_mode_details (mode, 
                              {location, generate_interruptable_code,
                               generate_interceptable_code, generate_debug_info,
                               generate_variable_debug_info, optimize_leaf_fns,
                               optimize_tail_calls, optimize_self_tail_calls,
                               mips_r4000, sparc_v7}) =
          let val (modes, details, _) = ProjFile.getModes()
              val (_, modes') = List.partition (fn m => m = mode) modes
              val (_, details') = List.partition (fn r => #name r = mode) details
              val details = 
                {name = mode,
                 location = ref location,
                 generate_interruptable_code = ref generate_interruptable_code,
                 generate_interceptable_code = ref generate_interceptable_code, 
                 generate_debug_info = ref generate_debug_info,
                 generate_variable_debug_info = ref generate_variable_debug_info,
                 optimize_leaf_fns = ref optimize_leaf_fns,
                 optimize_tail_calls = ref optimize_tail_calls, 
                 optimize_self_tail_calls = ref optimize_self_tail_calls,
                 mips_r4000 = ref mips_r4000, 
                 sparc_v7 = ref sparc_v7}
           in ProjFile.setModes (mode::modes', details::details');
              refresh_project()
          end

        fun remove_mode mode =
          let val (modes, details, current_mode) = ProjFile.getModes()
              val (_, modes') = List.partition (fn m => m = mode) modes
              val (mode_l, details') = List.partition (fn r => #name r = mode) details
           in 
              if mode_l = []
              then env_error (project_exn, "Cannot remove " ^ mode ^ " as it does not exist")
              else if mode = getOpt(current_mode,"")
              then env_error (project_exn, "Cannot remove " ^ mode ^ " as it is the current mode")
              else (ProjFile.setModes (modes', details'); refresh_project())
          end

        fun show_config_details config =
          let val (configs, details, _) = ProjFile.getConfigurations()
           in if List.exists(fn c => c = config) configs
              then let val {name, files, library} =
                              ProjFile.getConfigDetails(config, details)
                    in {files = files, library = library} end
              else env_error (project_exn, "There is no configuration called " ^ config)
          end

	fun duplicate_mod_ids [] ids = NONE
	  | duplicate_mod_ids (a::rest) ids =
	    let 
	      val filen = OS.Path.file a
	      val id = ModuleId.from_host (filen, get_location())
	    in
	      if (List.exists (fn id' => ModuleId.eq(id,id')) ids) then (SOME filen)
	      else duplicate_mod_ids rest (id :: ids)
	    end

	fun rem_old_config_units new_config =
          let
            val (configs, c_details, old_config) = ProjFile.getConfigurations()
            fun get_c_files config =
              (#files (ProjFile.getConfigDetails (config, c_details)))
              handle ProjFile.NoConfigDetailsFound c => []
            fun get_c_modules config =
              map (fn f => ModuleId.from_host(OS.Path.file f,
                                              Info.Location.FILE "Project Properties"))
                  (get_c_files config)
            fun remove_unit (mod_id, proj) = Project.delete(proj, mod_id, false)
            val init_proj = Incremental.get_project()
            val set = Incremental.set_project
          in
            case (old_config, new_config) of
              (NONE, _) => ()
	    | (SOME old, NONE) =>
		set (foldl remove_unit init_proj (get_c_modules old))
            | (SOME old, SOME new) =>
		if (old = new) then ()
		else
                  set (foldl remove_unit init_proj (get_c_modules old))
          end

	fun set_configuration config =
          let val (configs, configDetails, curConfig) = ProjFile.getConfigurations() 
          in 
	    if (List.exists (fn c => c = config) configs) then
              let
		val common_files = ProjFile.getFiles()
		val config_files = #files (ProjFile.getConfigDetails(config, configDetails))
	      in
		case (duplicate_mod_ids (common_files @@ config_files) []) of
		  NONE => 
		    (rem_old_config_units (SOME config);
		     ProjFile.setCurrentConfiguration
                       (error_info, get_location ())
                       (SOME config); 
                     refresh_project())
		| SOME f =>
		  env_error (project_exn,
			     "Cannot change to configuration; filename clash: " ^ f)
	      end
            else
              env_error (project_exn, 
                         "The configuration " ^ config ^ " is undefined")
          end

        fun set_config_details (config, {files, library}) =
          let 
	    val (configs, details, curConfig) = ProjFile.getConfigurations()
            val (_, configs') = List.partition (fn c => c = config) configs
            val (_, details') = List.partition (fn r => #name r = config) details
            val details = {name = config, files = files, library=library}
	    val com_files = ProjFile.getFiles()
          in 
	    case (duplicate_mod_ids (com_files @@ files) []) of
	      NONE => 
		(ProjFile.setConfigurations (config::configs', details::details');
              	 refresh_project())
	    | SOME f => 
		env_error (project_exn, 
		          "No duplicate filenames allowed. <" ^ f ^ "> already exists");
	    case curConfig of 
	      NONE => set_configuration config
	    | SOME c => if (List.exists (fn c' => c=c') configs') then () 
			else set_configuration config
          end

        fun remove_config config =
          let val (configs, details, current_config) = ProjFile.getConfigurations()
              val (_, configs') = List.partition (fn c => c = config) configs
              val (config_l, details') = List.partition (fn r => #name r = config) details
           in 
              if config_l = []
              then env_error (project_exn, "Cannot remove " ^ config ^ " as it does not exist") 
              else ();
              if config = getOpt(current_config,"") 
              then 
		(case configs' of 
		   [] => 
		     (rem_old_config_units NONE;
		      ProjFile.setCurrentConfiguration (error_info, get_location ()) NONE)
		 | (c::rest) => set_configuration c)
              else ();
              ProjFile.setConfigurations (configs', details'); 
              refresh_project()
          end

        fun show_location_details () =
          let val (libraryPath, objectsLoc, binariesLoc) = ProjFile.getLocations()
           in {libraryPath=libraryPath, objectsLoc=objectsLoc, binariesLoc=binariesLoc}
          end

        fun set_location_details {libraryPath, objectsLoc, binariesLoc} =
          ( ProjFile.setLocations(libraryPath, objectsLoc, binariesLoc);
            refresh_project() )

        fun show_about_details () =
          let val (description, version) = ProjFile.getAboutInfo()
           in {description=description, version=version}
          end

        fun set_about_details {description, version} =
          ( ProjFile.setAboutInfo(description, version);
            refresh_project() )

	val project_record =
	  cast
	    {(*
             a_IMAGE = ProjFile.IMAGE : ProjFile.target_type,
             a_OBJECT_FILE = ProjFile.OBJECT_FILE : ProjFile.target_type,
             a_EXECUTABLE = ProjFile.EXECUTABLE : ProjFile.target_type,
             a_LIBRARY = ProjFile.LIBRARY : ProjFile.target_type,
             *)
             a_ProjectError = project_exn : internal_exn_rep,
             a_openProject =
	       (fn file => (ProjFile.open_proj file; 
			    Incremental.reset_project();
			    refresh_project())
                  handle _ => env_error (project_exn, "Unable to open project file " ^ file)
               ): string -> unit,
	     a_newProject =
	       (fn dir => 
                  let val abs_dir = OS.Path.mkAbsolute{path=dir, relativeTo=OS.FileSys.getDir()}
                   in if (OS.FileSys.isDir abs_dir handle OS.SysErr _ => false)
                      then
 			(ProjFile.new_proj dir; 
			 Incremental.reset_project();
                         ProjFile.setInitialModes();
			 refresh_project())
                     else env_error (project_exn, 
                                      abs_dir ^ " is not a directory")
                  end) : string -> unit,
	     a_saveProject =
	       (fn () => 
                  case ProjFile.getProjectName() of
                    SOME "" => 
  		      env_error (project_exn, "New project has no name")
                  | SOME file => 
  		      ( ProjFile.save_proj file
                        handle _ => env_error (project_exn, 
                                               "Unable to save project file to " ^ file) )
                  | NONE =>
                      env_error (project_exn, "There is no current project to save")
               ): unit -> unit,
	     a_saveProjectAs =
	       (fn file => 
                  case ProjFile.getProjectName() of
                    SOME _ => 
                      ( (ProjFile.save_proj file; refresh_project())
                        handle _ => env_error (project_exn, 
                                               "Unable to save project file to " ^ file) )
                  | NONE =>
                      env_error (project_exn, "There is no current project to save")
               ): string -> unit,
	     a_closeProject =
	       (fn () => (ProjFile.close_proj(); refresh_project())) : unit -> unit,
	     a_setFiles =
	       (fn files => 
		  let
		    val (configs, c_details, curConfig) = ProjFile.getConfigurations()
		    val config_files = 
		      case curConfig of 
			NONE => []
		      | SOME c => #files (ProjFile.getConfigDetails(c, c_details))
		  in
		    case (duplicate_mod_ids (files @@ config_files) []) of
		      NONE => (ProjFile.setFiles files; refresh_project())
		    | SOME f => 
		        env_error (project_exn, 
				   "No duplicate filenames allowed. <" ^ f ^ "> already exists")
		  end
               ): string list -> unit,

	     a_showFiles =
	       (fn () => ProjFile.getFiles ()): unit -> string list,
	     a_setSubprojects =
	       (fn subs => (ProjFile.setSubprojects subs; refresh_project())
                           handle _ => env_error (project_exn, "Unable to open subprojects")
               ): string list -> unit,
	     a_showSubprojects =
	       (fn () => ProjFile.getSubprojects ()): unit -> string list,
             a_showLocations = 
	       show_location_details : unit -> location_details,
             a_setLocations = 
	       set_location_details : location_details -> unit,
             a_showAboutInfo = 
	       show_about_details : unit -> about_details,
             a_setAboutInfo = 
	       set_about_details : about_details -> unit,
             a_showFilename = 
	       (fn () => getOpt(ProjFile.getProjectName(), "")) : unit -> string,

	     a_setConfiguration =
               set_configuration : string -> unit,
             a_removeConfiguration = 
	       remove_config : string -> unit,
	     a_setTargets = 
	       (fn targets => 
                  let val (_, _, details) = ProjFile.getTargets()
                   in app (fn t => if List.exists(fn (t',_) => t = t') details
                                   then ()
                                   else env_error (project_exn, 
                                        "The target " ^ t ^ " is undefined"))
                          targets;

                      ProjFile.setCurrentTargets
                        (error_info, get_location ())
                        targets; 
                      refresh_project()
                  end
               ): string list -> unit,
             a_setTargetDetails =
               (fn target =>
                  let val c_target = OS.Path.mkCanonical target
		      val (enabled, disabled, details) = ProjFile.getTargets()
		      val t_file = OS.Path.file c_target
                      val (target1, enabled') = List.partition (fn t => t = t_file) enabled
                      val (target2, disabled') = List.partition (fn t => t = t_file) disabled
                      val details' = List.filter (fn (t,_) => t <> t_file) details
                   in 
		     (ProjFile.setTargets(t_file::enabled', disabled', 
                                          (t_file,ProjFile.OBJECT_FILE)::details');
                       refresh_project())
                      handle _ => env_error (project_exn, "Unable to set target details for " ^ target)
                  end): string -> unit,
             a_removeTarget =
               (fn target =>
                  (let val (enabled, disabled, details) = ProjFile.getTargets()
                       val (target1, enabled') = List.partition (fn t => t = target) enabled
                       val (target2, disabled') = List.partition (fn t => t = target) disabled
                       val details' = List.filter (fn (t,_) => t <> target) details
                    in if null target1
                       then if null target2
                            then env_error (project_exn, "There is no target called " ^ target)
                            else ProjFile.setTargets(enabled, disabled', details')
                       else ProjFile.setTargets(enabled', disabled, details')
                   end; refresh_project())): string -> unit,
             a_showAllTargets =
               (fn () =>
                  let val (enabled, disabled, _) = ProjFile.getTargets()
                   in enabled @@ disabled end): unit -> string list,
             a_showCurrentTargets =
               (fn () =>
                  let val (enabled, _, _) = ProjFile.getTargets()
                   in enabled end): unit -> string list,
             (*
             a_showTargetDetails =
               (fn target =>
                  let val (enabled, disabled, details) = ProjFile.getTargets()
                   in case List.find (fn (t,_) => t = target) details of
                        NONE => env_error (project_exn, "There is no target called " ^ target)
                      | SOME(_, target_type) => target_type
                  end) : string -> ProjFile.target_type,
	     *)
             a_setMode = 
	       (fn mode => 
                 let val (modes, _, _) = ProjFile.getModes() 
                  in if List.exists(fn m => m = mode) modes
                     then (ProjFile.setCurrentMode
                             (error_info, get_location ())
                             mode; refresh_project())
                     else
                       env_error (project_exn, 
                                  "The mode " ^ mode ^ " is undefined")
                 end
               ): string -> unit,
             a_removeMode = 
	       remove_mode : string -> unit,
             a_showAllModes = 
               (fn () => 
                 let val (modes, details, _) = ProjFile.getModes() in modes end)
               : unit -> string list,
             a_showCurrentMode = 
               (fn () => 
                 case ProjFile.getModes() of
                   (_, _, SOME s) => s
                 | _ => env_error (project_exn, "There is no current mode"))
               : unit -> string,
             a_showModeDetails = 
	       show_mode_details : string -> mode_details,
             a_setModeDetails = 
	       set_mode_details : string * mode_details -> unit,
             a_showAllConfigurations = 
               (fn () => 
                 let val (configs, _, _) = ProjFile.getConfigurations() in configs end)
               : unit -> string list,
             a_showCurrentConfiguration = 
               (fn () => 
                 case ProjFile.getConfigurations() of
                   (_, _, SOME s) => s
                 | _ => env_error (project_exn, "There is no current configuration"))
               : unit -> string,
             a_showConfigurationDetails = 
	       show_config_details : string -> configuration_details,
             a_setConfigurationDetails = 
	       set_config_details : string * configuration_details -> unit,

	     a_compile = compile: string -> unit,
	     a_showCompile = show_compile: string -> unit,
	     a_forceCompile = force_compile: string -> unit,

	     a_compileAll = compile_all: unit -> unit,
	     a_showCompileAll = show_compile_all: unit -> unit,
	     a_forceCompileAll = force_compile_all: unit -> unit,

	     a_load = load: string -> unit,
	     a_showLoad = show_load: string -> unit,
             a_forceLoad = force_load: string -> unit,

             a_loadAll = load_targets: unit -> unit,
	     a_showLoadAll = show_load_targets: unit -> unit,
             a_forceLoadAll =
	       (fn () => (Incremental.delete_all_modules true;
                          load_targets ())): unit -> unit,

	     (* a_makeDll =
  	      * (fn (target, libs) =>
	      * ShellUtils.make_dll_from_project(get_location(), error_info, target, libs) handle
	      * exn as OS.SysErr(s, _) => (print(s ^ "\n"); raise exn)) : string * string list -> unit, 
              *)
	     a_makeExe =
	       (fn (target, libs) =>
		ShellUtils.make_exe_from_project(get_location(), error_info, target, libs) handle
		exn as OS.SysErr(s, _) => (print(s ^ "\n"); raise exn)) : string * string list -> unit,
	     (*
	     a_listObjects =
	      (fn filename => 
		 TopLevel.list_objects
		   error_info
		   (ShellTypes.get_current_options (!shell_data_ref))
		   [filename]): string -> unit,
	     *)
	     a_delete = delete_from_project: string -> unit,
	     a_readDependencies = read_dependencies: string -> unit}

	val path_structure = mk_exn_structure
          ([("setSourcePath", string_list_to_unit),
            ("sourcePath", unit_to_string_list),
	    (*
            ("setObjectPath", string_to_unit),
            ("objectPath", unit_to_string),
	    *)
            ("setPervasive", string_to_unit),
            ("pervasive", unit_to_string)],
           [(path_exn_label,string_to_exn)])

	fun set_source_path l =
	  Io.set_source_path
	    (map
	     (fn x =>
	      (OS.FileSys.fullPath(Getenv.expand_home_dir x))
	      handle Getenv.BadHomeName s => env_error (path_exn, s)
		   | OS.SysErr(str, err) =>
		let
		  val str = case err of
		    NONE => str
		  | SOME err => OS.errorMsg err
		in
		  env_error(path_exn, str ^ ": " ^ x)
		end)
	     l)

	fun get_source_path () = Io.get_source_path ()

	(*
	fun set_object_path s =
	  Io.set_object_path(Getenv.expand_home_dir s, Info.Location.FILE"<Shell>")
          handle
	  Getenv.BadHomeName s => env_error (path_exn, s)

	val get_object_path = Io.get_object_path
	(* XXXEXCEPTION: should handle Io.NotSet *)
	*)

	fun set_pervasive_dir s =
	  Io.set_pervasive_dir
	    (OS.FileSys.fullPath (Getenv.expand_home_dir s),
	     Info.Location.FILE"<Shell>")
          handle
            Getenv.BadHomeName s => env_error (path_exn, s)
	  | OS.SysErr(str, err) =>
	      let
		val str = case err of
		  NONE => str
		| SOME err => OS.errorMsg err
	      in
		env_error(path_exn, str ^ ": " ^ s)
	      end

	fun get_pervasive_dir () =
	  Io.get_pervasive_dir ()
	  handle Io.NotSet s => env_error (path_exn, s)

	val path_record =
	   cast
	     {a_setSourcePath = set_source_path : string list -> unit,
	      a_sourcePath = get_source_path : unit -> string list,
	      a_setPervasive = set_pervasive_dir : string -> unit,
	      a_pervasive = get_pervasive_dir : unit -> string,
	      (*
	      a_setObjectPath = set_object_path : string -> unit,
	      a_objectPath = get_object_path : unit -> string,
	      *)
              a_Path = path_exn : internal_exn_rep}

        val custom_editor_structure =
(*
     val addCommand : string * string -> unit
     val addConnectDialog : string * string * string list -> unit
     val removeCommand : string -> string
     val removeDialog : string -> (string * string list)
     val commandNames  : unit -> string list
     val dialogNames  : unit -> string list
*)
	  mk_structure
	    ([("addCommand", string_cross_string_to_unit),
              ("addConnectDialog", string_cross_string_cross_string_list_to_unit),
              ("removeCommand", string_to_string),
              ("removeDialog", string_to_string_cross_string_list),
              ("commandNames", unit_to_string_list),
              ("dialogNames", unit_to_string_list)])

        val custom_editor_record = cast
          {a_addCommand = CustomEditor.addCommand : string * string -> unit,
           a_addConnectDialog = CustomEditor.addConnectDialog : (string * string * string list) -> unit,
	   a_removeCommand = CustomEditor.removeCommand :
		string -> string,
           a_removeDialog = CustomEditor.removeDialog :
		string -> (string * string list),
           a_commandNames = CustomEditor.commandNames : unit -> string list,
           a_dialogNames = CustomEditor.dialogNames : unit -> string list
          }

	fun edit_file string =
          (ignore(ShellUtils.edit_file
	     (string, ShellTypes.get_current_preferences (!shell_data_ref)));
           ())
          handle ShellUtils.EditFailed s => env_error (edit_exn, s)

	fun edit_definition (f : 'a -> 'b) =
          let
            val f : MLWorks.Internal.Value.T = cast f
	    val preferences =
	      ShellTypes.get_current_preferences (!shell_data_ref)
          in
            ignore(ShellUtils.edit_object (f, preferences));
            ()
          end
          handle ShellUtils.EditFailed s => env_error (edit_exn, s)

        val editor_structure =
	     (* Prefix "a_" for values, "b_" for exceptions,
	        and "c_" for structures, to ensure correct ordering.
	      *)
	  mk_mixed_structure
	    ([("Custom",custom_editor_structure)],
	     [],
	     [("editFile", string_to_unit),
              ("editDefinition",fun_to_unit)],
             [(edit_exn_label,string_to_exn)])

        val editor_record = cast
          {a_editFile = edit_file : string -> unit,
           a_editDefinition = edit_definition : ('a -> 'b) -> unit,
           a_EditError = edit_exn : internal_exn_rep,
           c_custom = custom_editor_record}

	val debug_structure =
	     STR (
	       STRNAME (Types.make_stamp ()),
               ref NONE,
	       ENV (
		 Strenv.empty_strenv,
		 Tyenv.empty_tyenv,
		 Lists.reducel
		   (fn (ve, (name, typescheme)) =>
		      Valenv.add_to_ve(
		        Ident.VAR(find_symbol name),
		        typescheme,
		        ve
		      )
		   )
		   (empty_valenv,
		    [("info", fun_to_string),
		     ("infoAll", unit_to_string_list),
                     ("status", fun_to_bool),
                     ("stepThrough", fun_to_fun),
		     ("clear", fun_to_unit),
		     ("clearAll", unit_to_unit)])
	       )
	     )

        fun debug_clear f =
          let
	    val name = ValuePrinter.function_name f
          in
	    UserContext.clear_debug_info
	      (ShellTypes.get_user_context (!shell_data_ref), name)
          end

        fun debug_clear_all () =
	  UserContext.clear_debug_all_info
	    (ShellTypes.get_user_context (!shell_data_ref))
    
        fun debug_status f =
          let
            val debug_info = Incremental.debug_info (get_context ())
	    val name = ValuePrinter.function_name f
          in
            case Debugger_Types.lookup_debug_info (debug_info,name) of
              SOME _ => true
            | _ => false
          end

        fun debug_info f =
          let
            val options = ShellTypes.get_current_options
                            (!ShellTypes.shell_data_ref)
            val debug_info = Incremental.debug_info (get_context ())
	    val name = ValuePrinter.function_name f
          in
	    Debugger_Types.print_function_information options
            (name,debug_info,true)
          end

        fun debug_info_all () =
          let
            val options = ShellTypes.get_current_options
                                 (!ShellTypes.shell_data_ref)
            val debug_info = Incremental.debug_info (get_context ())
          in
            Debugger_Types.print_information options (debug_info,true)
          end

	val debug_record =
             cast
             {a_clearAll = debug_clear_all : unit -> unit,
              a_clear = debug_clear : ('a -> 'b) -> unit,
              a_info = debug_info : ('a -> 'b) -> string,
              a_infoAll = debug_info_all : unit -> string list,
              a_status = debug_status : ('a -> 'b) -> bool,
              a_stepThrough = Trace.step_through : ('a -> 'b) -> ('a -> 'b)}

        val options_structure =
          STR (STRNAME (Types.make_stamp ()),
               ref NONE,
	       ENV(mk_strenv
		     [("Preferences", preferences_structure),
		      ("ValuePrinter", value_printer_structure),
	    	      ("Compiler", compiler_structure),
                      ("Debugger", debugger_structure),
	    	      ("Internals", internals_structure),
	    	      ("Language", language_structure),
		      ("Mode", mode_option_structure)],
                   mk_tyenv
		     [("option",
		       TYSTR (ETA_TYFUN option_tyname, empty_valenv))],
		   mk_valenv
                   ([("set", set_option_type),
                     ("get", get_option_type)],
                    [])))

	val options_record =
	     (* Prefix "a_" for values, "b_" for exceptions,
	        and "c_" for structures, to ensure correct ordering.
	      *)
             cast
             {a_set = set_option : 'a option_rep * 'a -> unit,
	      a_get = get_option : 'a option_rep -> 'a,
	      c_compiler = compiler_record,
              c_debugger = debugger_record,
              c_internals = internals_record,
              c_valuePrinter = value_printer_record,
	      c_language = language_record,
	      c_mode = mode_option_record,
	      c_preferences = preferences_record
	     }

	local
	  (* profiling functions for Shell.Profile *)
	  val time_space_profile_manner =
	    Profile.make_manner
	    {time = true,
	     space = true,
	     calls = false,
	     copies = false,
	     depth = 0,
	     breakdown = []}

	  val time_space_profile_options =
	    Profile.Options {scan = 10,
			     selector = fn _ => time_space_profile_manner}

	  val time_profile_manner =
	    Profile.make_manner
	    {time = true,
	     space = false,
	     calls = false,
	     copies = false,
	     depth = 0,
	     breakdown = []}

	  val time_profile_options =
	    Profile.Options {scan = 10,
			     selector = fn _ => time_profile_manner}

	  val space_profile_manner =
	    Profile.make_manner
	    {time = false,
	     space = true,
	     calls = false,
	     copies = false,
	     depth = 0,
	     breakdown = []}

	  val space_profile_options =
	    Profile.Options {scan = 10,
			     selector = fn _ => space_profile_manner}

	  fun profile_tool p =
	    ShellTypes.get_current_profiler (!shell_data_ref) p

	  fun profile_full opt f a =
	    let
	      val (r,p) = Profile.profile opt f a
	    in
	      (profile_tool p;
	       case r of
		 Profile.Result r => r
	       | Profile.Exception e => raise e)
	    end

	  val time_space_profile = profile_full time_space_profile_options
	  val time_profile = profile_full time_profile_options
	  val space_profile = profile_full space_profile_options

	  val profile_options_tycon = mk_longtycon(["MLWorks",
						    "Profile"],
						    "options")

	  val profile_tycon = mk_longtycon(["MLWorks",
					    "Profile"],
					   "profile")

	  val profile_options_type = get_runtime_type profile_options_tycon

	  val profile_type = get_runtime_type profile_tycon

	  (* profile has type ('a -> 'b) -> 'a -> 'b
	   * full has type options -> ('a -> 'b) -> 'a -> 'b *)

	  val (profiler_type, profile_full_type) =
	    let
	      val alpha = make_tyvar "'a"
	      val beta = make_tyvar "'b"
	      val profile_type_instance = FUNTYPE (FUNTYPE (alpha,beta),
						   FUNTYPE (alpha,beta))
	      val full_type_instance = FUNTYPE (profile_options_type,
						profile_type_instance)
	      val free_type_vars = [alpha,beta]
	    in
	      (Scheme.make_scheme(free_type_vars, (profile_type_instance,
						   NONE)),
	       Scheme.make_scheme(free_type_vars, (full_type_instance,
						   NONE)))
	    end

	  (* profile_tool has type profile -> unit *)
	  val profile_tool_type = schemify (FUNTYPE (profile_type,
						     Types.empty_rectype))

	in
	  val profile_structure =
	    STR(
		STRNAME(Types.make_stamp ()),
		ref NONE,
		ENV (Strenv.empty_strenv,
		     Tyenv.empty_tyenv,
		     Lists.reducel
		     (fn (ve, (name, typescheme)) =>
		      Valenv.add_to_ve
		      (Ident.VAR (find_symbol name),
		       typescheme,
		       ve))
		     (empty_valenv,
		      [("profile",profiler_type),
		       ("profileFull", profile_full_type),
		       ("profileSpace",profiler_type),
		       ("profileTime",profiler_type),
		       ("profileTool",profile_tool_type)])))
	  val profile_record =
	    cast
	    {a_profile = time_space_profile : ('a -> 'b) -> 'a -> 'b,
	     a_profileFull =
	       profile_full : Profile.options -> ('a -> 'b) -> 'a -> 'b,
	     a_profileSpace = space_profile : ('a -> 'b) -> 'a -> 'b,
	     a_profileTime = time_profile : ('a -> 'b) -> 'a -> 'b,
	     a_profileTool = profile_tool : Profile.profile -> unit}
	end

	local
	  (* various timing functions for Shell.Timer *)

	  fun time_iterations n f a =
	    let
	      fun time' 0 = ()
		| time' n = (ignore(f a);
			     time' (n-1))
	      val (cpu_timer, real_timer) =
		(Timer.startCPUTimer(), Timer.startRealTimer())
	    in
	      (time' n;
	       (Timer.checkCPUTimer cpu_timer,
		Timer.checkGCTime cpu_timer,
	        Timer.checkRealTimer real_timer))
	    end
	
	  val time = time_iterations 1
	
	  fun print_timing {outputter : string -> unit, name, function} arg =
	    let
	      val (cpu_timer, real_timer) =
		(Timer.startCPUTimer(), Timer.startRealTimer())
		
	      fun times_to_string({usr, sys}, gc, real_elapsed) =
		concat [Time.toString real_elapsed,
			" (user: ",
			Time.toString usr,
			"(gc: ",
			Time.toString gc,
			"), system: ",
			Time.toString sys,
			")"]

	      fun print_time () =
		let
		  val elapsed =
		    (Timer.checkCPUTimer cpu_timer,
		     Timer.checkGCTime cpu_timer,
		     Timer.checkRealTimer real_timer)
		in
		  outputter(concat ["Time for ", name, " : ",
				    times_to_string elapsed,
				    "\n"])
		end
	
	      val result =
		function arg
		handle exn => (print_time () ; raise exn)
	    in
	      (print_time () ; result)
	    end
	
	  (* change this if MLWorks.Internal.Types.time ever changes *)
	
	  val time_tycon = mk_longtycon (["MLWorks",
					  "Internal",
					  "Types"],
					 "time")

	  val time_type = get_runtime_type time_tycon

	  val cpu_time_type = mk_record[("usr", time_type),
					("sys", time_type)]

	  val elapsed_t_type = make_tuple[cpu_time_type, time_type, time_type]
	
	  type elapsed_type = ({sys: Time.time, usr: Time.time} * Time.time * Time.time)

	  val outputter_type = FUNTYPE(Types.string_type, Types.empty_rectype)
	
	  (* time has type ('a -> 'b) -> 'a -> elapsed_t_type *)
	
	  val time_type =
	    let
	      val alpha = make_tyvar "'a"
	      val beta  = make_tyvar "'b"
	      val time_type_instance = FUNTYPE (FUNTYPE (alpha,beta),
						FUNTYPE (alpha,elapsed_t_type))
	    in
	      Scheme.make_scheme([alpha,beta], (time_type_instance,
						NONE))
	    end
	
	  (* time_iterations has type int -> ('a -> 'b) -> 'a -> elapsed_t_type *)
	
	  val time_iterations_type =
	    let
	      val alpha = make_tyvar "'a"
	      val beta  = make_tyvar "'b"
	      val time_iterations_type_instance =
		FUNTYPE(Types.int_type,
			FUNTYPE (FUNTYPE (alpha,beta),
				 FUNTYPE (alpha,elapsed_t_type)))
	    in
	      Scheme.make_scheme([alpha,beta], (time_iterations_type_instance,
						NONE))
	    end
	
	  (*  print_timing has type
	   {outputter: string -> unit,
	    name: string,
	    function: ('a -> 'b)} -> 'a -> 'b
	   *)
	
	  val print_timing_type =
	    let
	      val alpha = make_tyvar "'a"
	      val beta  = make_tyvar "'b"
	      val print_timing_type_instance =
		FUNTYPE(mk_record [("outputter",outputter_type),
				   ("name",Types.string_type),
				   ("function",FUNTYPE (alpha, beta))],
			FUNTYPE (alpha,beta))
	    in
	      Scheme.make_scheme([alpha,beta], (print_timing_type_instance,
						NONE))
	    end
	in

	  val timer_structure =
	    STR(
		STRNAME (Types.make_stamp ()),
		ref NONE,
		ENV (Strenv.empty_strenv,
		     Tyenv.empty_tyenv,
		     Lists.reducel
		     (fn (ve, (name, typescheme)) =>
		      Valenv.add_to_ve
		      (Ident.VAR (find_symbol name),
		       typescheme,
		       ve))
		     (empty_valenv,
		      [("time",time_type),
		       ("timeIterations", time_iterations_type),
		       ("printTiming", print_timing_type)])))
	
	  val timer_record =
	    cast
	    {a_time = time : ('a -> 'b) -> 'a -> elapsed_type,
	     a_timeIterations =
	       time_iterations :
		 int -> ('a -> 'b) -> 'a -> elapsed_type,
	     a_printTiming = print_timing : {outputter: string -> unit,
					     name: string,
					     function: ('a -> 'b)} -> 'a -> 'b}
	end
	
        (* make the context itself *)
        val context =
          #1(Incremental.add_value
             (#1(Incremental.add_value
                 (initial_context,
                  "use",
                  UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rectype),
                                  NONE),
                  cast (use_fun : string -> unit)
                  )),
              "use_string",
              UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rectype),
                              NONE),
              cast (use_string_fun : string -> unit)
              ))

	local
          fun handler_fn msg =
            Info.default_error'
            (Info.FATAL,
             Info.Location.FILE (ShellTypes.get_current_toplevel_name ()),
             msg)

          val (context', identifiers) =
            Incremental.add_structure
              (context,
               "Shell",
               mk_mixed_structure
                 ([("Project", project_structure),
                   ("Path", path_structure),
		   ("Options", options_structure),
		   ("Debug", debug_structure),
		   ("Editor", editor_structure),
                   ("Trace", trace_structure),
                   ("Dynamic",dynamic_structure),
                   ("Inspector",inspector_structure),
		   ("Timer", timer_structure),
		   ("Profile", profile_structure)
		   ],
		  [],
		  [("exit", int_to_unit),
		   ("startGUI", unit_to_unit),
		   ("saveImage", string_cross_bool_to_unit)
		   ],
                  []),
	       (* Prefix "a_" for values, "b_" for exceptions,
	          and "c_" for structures, to ensure correct ordering.
	        *)
               cast{
                   a_exit = shell_exit_fn : int -> unit,
		   a_saveImage =
                     (fn (name, exe) => 
	               ( if (get_context_option_fun 
                              (#generate_debug_info) ()) orelse
                            (get_context_option_fun 
                              (#generate_variable_debug_info) ())
                         then print ("Warning: enabling the debug options " ^
                                     "may result in large saved images.\n")
                         else ();
                         SaveImage.saveImage
	                 (is_a_tty_image, handler_fn) (name, exe) ))
                     : string * bool -> unit,
		   a_startGUI =
		     (fn () =>
			SaveImage.startGUI
			  true
			  (!shell_data_ref)) : unit -> unit,
                   c_inspector = inspector_record,
                   c_dynamic = dynamic_record,
                   c_trace = trace_record,
		   c_project = project_record,
		   c_path = path_record,
		   c_debug = debug_record,
		   c_editor = editor_record,
		   c_options = options_record,
		   c_timer = timer_record,
		   c_profile = profile_record
		 })
        in
          val context = context'
	end


	(* Now add debug info for the Environment errors exception *)

	(* Note that labels must be unique -- so a better mechanism is needed
	 if we want two exceptions called "Error" for example *)
        val environment_debug_info =
          Lists.reducel
          (fn (debug_info,(label,exn_type)) =>
           (Debugger_Types.add_debug_info
            (debug_info,
             make_exn_tag label,
             Debugger_Types.FUNINFO {ty=exn_type,
                                     is_leaf=true,
				     has_saved_arg=false,
                                     annotations=[],
                                     runtime_env=Debugger_Types.RuntimeEnv.EMPTY,
                                     is_exn=true})))
          (Debugger_Types.empty_information,
           [(edit_exn_label,string_to_exn_type),
            (eval_exn_label,string_to_exn_type),
            (inspect_exn_label,string_to_exn_type),
            (project_exn_label,string_to_exn_type)])

        val context =
	  Incremental.add_debug_info
	    (Options.default_options, environment_debug_info,context)

      in
        context
      end (* of make_shell_structure *)

  end
@


1.218
log
@[Bug #190534]
Ensure projects created by Shell.Project have Debug and Release modes as default
@
text
@d16 4
d2994 3
a2996 1
	       (Timer.checkCPUTimer cpu_timer, Timer.checkRealTimer real_timer))
d3006 1
a3006 1
	      fun times_to_string({usr, sys, gc}, real_elapsed) =
d3010 3
a3012 1
			", system: ",
a3013 2
			", gc: ",
			Time.toString gc,
d3015 1
d3019 3
a3021 1
		    (Timer.checkCPUTimer cpu_timer, Timer.checkRealTimer real_timer)
d3041 1
d3044 2
a3045 4
	  val cpu_time_type = mk_record[("gc", time_type),
					 ("usr", time_type),
					 ("sys", time_type)]

d3047 1
a3047 1
	  val elapsed_t_type = make_tuple[cpu_time_type, time_type]
d3049 1
a3049 1
	  type elapsed_type = ({gc: Time.time, sys: Time.time, usr: Time.time} * Time.time)
@


1.218.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a15 4
 * Revision 1.218  1999/03/18  10:20:13  mitchell
 * [Bug #190534]
 * Ensure projects created by Shell.Project have Debug and Release modes as default
 *
@


1.217
log
@[Bug #190502]
Disable generation of .S files
@
text
@d16 4
d2405 1
@


1.216
log
@[Bug #50108]
Change ModuleId from an equality type
@
text
@d16 4
d2036 1
a2036 1
	   ("makeDll", string_cross_string_list_to_unit),
d2588 5
a2592 4
	     a_makeDll =
	       (fn (target, libs) =>
		ShellUtils.make_dll_from_project(get_location(), error_info, target, libs) handle
		exn as OS.SysErr(s, _) => (print(s ^ "\n"); raise exn)) : string * string list -> unit,
@


1.215
log
@[Bug #190500]
Remove redundant require statements
@
text
@d16 4
d2264 1
a2264 1
	      if (List.exists (fn id' => id = id') ids) then (SOME filen)
@


1.214
log
@[Bug #70240]
Remove project units for configuration files when current configuration changes.
@
text
@d16 4
a793 1
require "../main/toplevel";
@


1.213
log
@[Bug #190494]
Check for duplicate module ids when adding new files and changing configurations.
@
text
@d16 4
d803 1
d827 1
d857 1
a857 1
  sharing type ModuleId.ModuleId = Incremental.ModuleId
d884 1
d2261 24
d2295 2
a2296 1
		    (ProjFile.setCurrentConfiguration
d2341 3
a2343 1
		   [] => ProjFile.setCurrentConfiguration (error_info, get_location ()) NONE
@


1.212
log
@reset project when opening an existing one to clear out units.
@
text
@d16 3
d2244 33
d2278 18
a2295 7
          let val (configs, details, _) = ProjFile.getConfigurations()
              val (_, configs') = List.partition (fn c => c = config) configs
              val (_, details') = List.partition (fn r => #name r = config) details
              val details = 
                {name = config, files = files, library=library}
           in ProjFile.setConfigurations (config::configs', details::details');
              refresh_project()
d2307 4
a2310 1
              then ProjFile.setCurrentConfiguration (error_info, get_location ()) NONE 
d2385 14
a2398 1
	       (fn path => (ProjFile.setFiles path; refresh_project())
d2400 1
a2402 1

a2419 1

d2421 1
a2421 12
	       (fn config => 
                 let val (configs, _, _) = ProjFile.getConfigurations() 
                  in if List.exists(fn c => c = config) configs
                     then (ProjFile.setCurrentConfiguration
                             (error_info, get_location ())
                             (SOME config); 
                           refresh_project())
                     else
                       env_error (project_exn, 
                                  "The configuration " ^ config ^ " is undefined")
                 end
               ): string -> unit,
@


1.211
log
@[Bug #70204]
Do work for making exes
@
text
@d16 4
d2294 3
a2296 1
	       (fn file => (ProjFile.open_proj file; refresh_project())
@


1.210
log
@[Bug #70204]
Add Shell.Project.makeDll
@
text
@d16 4
d2012 1
d2489 4
@


1.209
log
@[Bug #30468]
Change types of mkAbsolute and mkRelative to uses records with names fields
@
text
@d16 4
d1162 4
d2007 1
d2013 1
a2013 1
           [(project_exn_label,string_to_exn)]);
d2481 4
@


1.208
log
@[Bug #30420]
Don't handle Info.Stop during compilation to bring up project error.
@
text
@d16 4
d2281 1
a2281 1
                  let val abs_dir = OS.Path.mkAbsolute(dir, OS.FileSys.getDir())
@


1.207
log
@[Bug #30420]
Raise error when no targets exist in project.
@
text
@d16 4
d2008 8
d2021 1
d2024 1
a2024 1

d2029 1
d2032 1
d2040 1
d2043 2
a2044 1
  
d2050 1
d2053 2
a2054 1
  
d2061 1
d2064 1
d2071 1
d2074 1
d2088 1
d2091 1
d2098 1
d2101 1
d2111 1
d2114 1
d2120 1
d2123 1
d2132 1
d2135 1
@


1.206
log
@[Bug #30439]
Don't allow the user to save a non-existent project!
And make sure the project window gets updated with new project name when using saveAs
@
text
@d16 5
d2005 1
a2005 1
	  ShellUtils.compile_targets
d2008 3
a2010 1
	    error_info
d2013 1
a2013 1
	  ShellUtils.show_compile_targets
d2015 3
a2017 1
	    error_info
d2020 1
a2020 1
          ShellUtils.compile_file
d2024 3
a2026 1
            filename
d2029 1
a2029 1
          ShellUtils.show_compile_file
d2032 3
a2034 1
            filename
d2037 1
a2037 1
          ShellUtils.force_compile 
d2041 3
a2043 1
            filename
d2046 1
a2046 1
          ShellUtils.force_compile_all
d2049 3
a2051 1
            error_info
d2057 1
a2057 1
          ShellUtils.load_file
d2064 3
a2066 1
            filename
d2069 1
a2069 1
          ShellUtils.show_load_file
d2072 3
a2074 1
            filename
d2077 1
a2077 1
	  ShellUtils.load_targets
d2083 3
a2085 1
            error_info
d2088 1
a2088 1
          ShellUtils.show_load_targets
d2090 3
a2092 1
            error_info
d2095 1
a2095 1
          let
d2100 3
a2102 1
          end
@


1.205
log
@[Bug #30453]
Check for a new target being in the list of files.
@
text
@d16 4
d2228 9
a2236 6
		  let val file = getOpt (ProjFile.getProjectName(), "")
		  in
		    ProjFile.save_proj file
                    handle _ => env_error (project_exn, 
                                         "Unable to save project file to " ^ file)
		  end
d2239 8
a2246 3
	       (fn file => ProjFile.save_proj file
                  handle _ => env_error (project_exn, 
                                         "Unable to save project file to " ^ file)
@


1.204
log
@[Bug #30417]
Add saveProjectAs and showName => showFilename
@
text
@d16 4
d2294 9
a2302 6
                  let val (enabled, disabled, details) = ProjFile.getTargets()
                      val (target1, enabled') = List.partition (fn t => t = target) enabled
                      val (target2, disabled') = List.partition (fn t => t = target) disabled
                      val details' = List.filter (fn (t,_) => t <> target) details
                   in (ProjFile.setTargets(target::enabled', disabled', 
                                           (target,ProjFile.OBJECT_FILE)::details');
@


1.203
log
@[Bug #30429]
Warn when saving sessions with debugging information enabled
@
text
@d16 4
d1927 2
a1928 1
           ("saveProject", string_to_unit),
d1939 1
a1939 1
           ("showName", unit_to_string),
d2219 9
d2254 1
a2254 1
             a_showName = 
@


1.202
log
@[Bug #30423]
Add call to Incremental.reset_project for a new project.
@
text
@d16 4
d2946 11
a2956 2
	             SaveImage.saveImage
	               (is_a_tty_image, handler_fn): string * bool -> unit,
@


1.201
log
@[Bug #30422]
Make newProject take a working directory argument
@
text
@d16 4
d2202 5
a2206 2
                      then (ProjFile.new_proj dir; refresh_project())
                      else env_error (project_exn, 
@


1.200
log
@[Bug #30369]
Replace source path with a list of files.
@
text
@d16 4
d1913 1
a1913 1
           ("newProject", unit_to_unit),
d2195 7
a2201 1
	       (fn () => (ProjFile.initialize(); refresh_project())): unit -> unit,
@


1.199
log
@[Bug #50071]
Replace touch* functions in Shell.Project by forceCompile* and forceLoad*
@
text
@d16 4
d1052 1
a1052 1
            [("source", CONSTYPE([Types.string_type], Types.list_tyname)),
d1877 1
a1877 1
          {source:				      string list,
d1913 2
a1914 2
           ("setSourcePath", string_list_to_unit),
           ("showSourcePath", unit_to_string_list),
d2128 1
a2128 1
              then let val {name, source, library} =
d2130 1
a2130 1
                    in {source = source, library = library} end
d2134 1
a2134 1
        fun set_config_details (config, {source, library}) =
d2139 1
a2139 1
                {name = config, source = source, library=library}
d2199 2
a2200 2
	     a_setSourcePath =
	       (fn path => (ProjFile.setSourcePath path; refresh_project())
d2202 2
a2203 2
	     a_showSourcePath =
	       (fn () => ProjFile.getSourcePath ()): unit -> string list,
@


1.198
log
@[Bug #50071]
Add touchAllSources to Shell.Project
@
text
@d16 4
d1943 2
d1947 2
a1948 4
	   ("touchSource", string_to_unit),
	   ("touchAllSources", unit_to_unit),
           ("touchLoaded", string_to_unit),
           ("touchAllLoaded", unit_to_unit),
d1951 2
d1955 2
d1994 6
a1999 1
	fun touch_source s = ShellUtils.touch_source (s, get_location ())
d2001 5
a2005 1
	fun touch_all_sources () = ShellUtils.touch_all_sources (get_location ())
d2040 1
a2040 1
	fun touch_loaded filename =
d2044 2
a2045 3
	    Incremental.delete_module
              error_info
              module_id
d2331 5
d2338 6
a2343 4
	     a_compile = compile: string -> unit,
	     a_showCompile = show_compile: string -> unit,
	     a_touchSource = touch_source: string -> unit,
	     a_touchAllSources = touch_all_sources: unit -> unit,
d2346 4
a2349 5
             a_touchLoaded = touch_loaded: string -> unit,
             a_touchAllLoaded =
	       (fn () => Incremental.delete_all_modules true): unit -> unit,
	     a_load = load: string -> unit,
	     a_showLoad = show_load: string -> unit,
@


1.197
log
@[Bug #50071]
Remove debug printout
@
text
@d16 4
d1942 1
d1988 2
d2320 1
@


1.196
log
@[Bug #50071]
Flesh out Shell.Project interface
@
text
@d16 4
a2002 1
	  (print "loading targets\n";
d2009 1
a2009 1
            error_info)
d2232 4
a2235 3
                   in ProjFile.setTargets(target::enabled', disabled', 
                                          (target,ProjFile.OBJECT_FILE)::details');
                      refresh_project()
@


1.195
log
@[Bug #30229]
Group compiler options to allow more flexibility.
@
text
@d16 4
d702 1
d1002 48
d1153 4
d1163 39
d1217 4
d1282 1
d1288 1
d1848 60
a1907 2
        val project_structure = mk_structure
          [("openProject", string_to_unit),
d1909 13
d1923 6
a1928 1
	   ("setMode", string_to_unit),
d1944 5
a1948 1
           ("readDependencies", string_to_unit)]
d2036 110
d2149 44
a2192 2
	    {a_openProject =
	       (fn file => ProjFile.open_proj file): string -> unit,
d2195 13
a2207 3
                  ProjFile.setCurrentConfiguration
                    (error_info, get_location ())
                    config): string -> unit,
d2210 53
a2262 4
                  ProjFile.setCurrentTargets
                    (error_info, get_location ())
                    targets): string list -> unit,
	     a_setMode = 
d2264 40
a2303 3
                  ProjFile.setCurrentMode
                    (error_info, get_location ())
                    mode): string -> unit,
d2929 2
a2930 1
            (inspect_exn_label,string_to_exn_type)])
@


1.194
log
@[Bug #30090]
Remove MLWorks.IO. Change spec of Shell.Timer.printTiming
to use a string->unit outputter function insteadm of an outstream
@
text
@d16 5
d1589 3
a1591 2
	   ("optimizing", mk_option Types.bool_type),
	   ("debugging", mk_option Types.bool_type)]
d1629 1
a1629 1
	fun select_optimizing b =
d1635 1
a1635 1
	    UserOptions.select_optimizing (user_context_options, b);
d1639 1
a1639 1
	fun select_debugging b =
d1645 1
a1645 1
	    UserOptions.select_debugging (user_context_options, b);
d1649 1
a1649 1
        fun is_debugging _ =
d1651 1
a1651 1
	    val user_context_options =
d1655 2
a1656 10
	    UserOptions.is_debugging user_context_options
	  end

        fun is_optimizing _ =
	  let
	    val user_context_options =
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
	  in
	    UserOptions.is_optimizing user_context_options
d1664 3
a1666 2
	   optimizing = (is_optimizing, select_optimizing) : bool option_rep,
	   debugging = (is_debugging, select_debugging) : bool option_rep}
@


1.193
log
@[Bug #70074]
Add depth limit support for signature printing
@
text
@d16 4
d840 1
a840 1
        | _ => (MLWorks.IO.output (MLWorks.IO.std_out,string ^ "\n");
d2280 1
a2280 1
	  fun print_timing {stream, name, function} arg =
d2299 3
a2301 4
		  MLWorks.IO.output(stream,
			 concat ["Time for ", name, " : ",
				  times_to_string elapsed,
				  "\n"])
d2328 1
a2328 5
	  val outstream_tycon = mk_longtycon (["MLWorks",
					       "IO"],
					      "outstream")
	
	  val outstream_type = get_runtime_type outstream_tycon
d2359 1
a2359 1
	   {stream: MLWorks.IO.outstream,
d2369 1
a2369 1
		FUNTYPE(mk_record [("stream",outstream_type),
d2402 3
a2404 3
	     a_printTiming = print_timing : {stream: MLWorks.IO.outstream,
					      name: string,
					      function: ('a -> 'b)} -> 'a -> 'b}
@


1.192
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d16 4
d1257 1
d1372 2
@


1.191
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d16 4
d1986 2
a1987 2
          (ShellUtils.edit_file
	     (string, ShellTypes.get_current_preferences (!shell_data_ref));
d1997 1
a1997 1
            ShellUtils.edit_object (f, preferences);
d2258 1
a2258 1
		| time' n = (f a;
@


1.190
log
@[Bug #30089]
Remove use of MLWorks.Time.Elapsed in favour of basis timer
@
text
@d16 4
d29 25
d687 1
a687 1
require "../basics/identprint";
d695 2
a696 1
require "../main/io";
a703 1
require "action_queue";
d708 1
d719 1
a719 1
  structure IdentPrint : IDENTPRINT
d731 1
a737 1
  structure ActionQueue: ACTION_QUEUE
d747 1
a747 4
  sharing Types.Datatypes.Ident =
	  IdentPrint.Ident
  sharing ActionQueue.Info =
    	  Incremental.InterMake.Compiler.Info =
d761 1
d773 1
a773 1
               ShellUtils.UserOptions = ActionQueue.UserOptions
d778 4
a781 4
  sharing type ShellUtils.preferences = ShellTypes.preferences =
               Preferences.preferences = ActionQueue.preferences
  sharing type ShellUtils.user_context = ActionQueue.user_context =
	       ShellTypes.user_context = UserContext.user_context
d785 3
a787 2
  sharing type Io.Location = Incremental.InterMake.Compiler.Info.Location.T

a1201 9
            fun queue level =
              ActionQueue.do_actions
              {user_context = get_user_context (),
               user_options = user_options,
               preferences = Preferences.new_preferences (user_preferences),
               error_info = error_info,
               debugger = debugger,
               output_fn = output_fn,
               monitor_fn = fn s => output_fn ("Make: compiling " ^ s)}
d1203 1
a1203 1
            ShellUtils.use_file (!shell_data_ref,print,queue,s)
a1214 9
            fun queue level =
              ActionQueue.do_actions
              {user_context = get_user_context (),
               user_options = user_options,
               preferences = Preferences.new_preferences (user_preferences),
               error_info = error_info,
               debugger = debugger,
               output_fn = output_fn,
               monitor_fn = fn s => output_fn ("Make: compiling " ^ s)}
d1216 1
a1216 1
            ShellUtils.use_string (!shell_data_ref,print,queue,s)
d1731 10
a1740 4

        val file_structure = mk_structure
          [("compile", string_to_unit),
           ("queryCompile", string_to_unit),
a1741 2
           ("loadSource", string_to_unit),
           ("queryLoadSource", string_to_unit),
d1744 4
a1747 11
           ("loadObject", string_to_unit),
           ("queryLoadObject", string_to_unit),
           ("compileAndLoad", string_to_unit),
           ("readDependencies", string_to_unit)]

        val build_structure = mk_structure
          [("compile", string_to_unit),
           ("queryCompile", string_to_unit),
	   ("touchSource", string_to_unit),
           ("loadSource", string_to_unit),
           ("queryLoadSource", string_to_unit),
d1749 1
a1749 1
           ("save", string_to_unit),
a1750 5
           ("touchLoaded", string_to_unit),
           ("touchAllLoaded", unit_to_unit),
           ("loadObject", string_to_unit),
           ("queryLoadObject", string_to_unit),
           ("compileAndLoad", string_to_unit),
d1754 28
a1781 7
	fun touch_source_module s =
	  ShellUtils.touch_source_module
	    (s, ShellTypes.get_current_toplevel_name ())

	fun touch_source_file s =
	  ShellUtils.touch_source_file
	    (s, ShellTypes.get_current_toplevel_name ())
d1784 56
a1839 2
	  ShellUtils.delete_from_project
	    (s, ShellTypes.get_current_toplevel_name ())
d1841 1
a1841 1
	val file_record =
d1843 25
a1867 22
	    {a_compile =
              (fn filename =>
               ActionQueue.add_compile_file
		 (filename, error_info)) : string -> unit,
	     a_queryCompile =
              (fn filename =>
               ActionQueue.add_check_compile_file
		 (filename, error_info)) : string -> unit,
	     a_touchSource =
	       touch_source_file: string -> unit,
             a_loadSource =
              (fn filename =>
               ActionQueue.add_load_source_file
		 (filename, error_info)) : string -> unit,
	     a_queryLoadSource =
              (fn filename =>
               ActionQueue.add_check_load_source_file
		 (filename, error_info)) : string -> unit,
             a_touchLoaded =
              (fn filename =>
		 ActionQueue.add_touch_loaded_file (filename, error_info))
		  : string -> unit,
d1869 3
a1871 40
              (fn () =>
		 ActionQueue.add_touch_all_loaded (error_info))
		  : unit -> unit,
	     a_loadObject =
              (fn filename =>
               ActionQueue.add_load_file
		 (filename, error_info)) : string -> unit,
	     a_queryLoadObject =
	      (fn filename =>
                 ActionQueue.add_check_load_file
		   (filename, error_info)) : string -> unit,
	     a_compileAndLoad =
	      (fn filename =>
                 ActionQueue.add_compile_and_load_file
		   (filename, error_info)) : string -> unit,
	     a_readDependencies =
	      (fn filename =>
                 ActionQueue.add_read_dependencies_file
		   (filename, error_info)) : string -> unit}

	val build_record =
	  cast
	    {a_compile =
              (fn filename =>
               ActionQueue.add_compile_module
		 (filename, error_info)) : string -> unit,
	     a_queryCompile =
              (fn filename =>
               ActionQueue.add_check_compile_module
		 (filename, error_info)) : string -> unit,
	     a_touchSource =
	       touch_source_module: string -> unit,
             a_loadSource =
              (fn module_name =>
               ActionQueue.add_load_source_module
		 (module_name, error_info)) : string -> unit,
	     a_queryLoadSource =
              (fn filename =>
               ActionQueue.add_check_load_source_module
		 (filename, error_info)) : string -> unit,
d1873 6
a1878 3
	     a_save =
              (fn module_name =>
               ActionQueue.add_save (module_name, error_info)) : string -> unit,
d1880 2
a1881 26
             a_touchLoaded =
              (fn module_name =>
		 ActionQueue.add_touch_loaded_module (module_name, error_info))
		  : string -> unit,
             a_touchAllLoaded =
              (fn () =>
		 ActionQueue.add_touch_all_loaded (error_info))
		  : unit -> unit,
	     a_loadObject =
              (fn module_name =>
               ActionQueue.add_load_module
		 (module_name, error_info)) : string -> unit,
	     a_queryLoadObject =
              (fn module_name =>
                 ActionQueue.add_check_load_module
		   (module_name, error_info)) : string -> unit,
	     a_compileAndLoad =
	      (fn module_name =>
                 ActionQueue.add_compile_and_load_module
		   (module_name, error_info)) : string -> unit,
	     a_delete =
	       delete_from_project: string -> unit,
	     a_readDependencies =
	      (fn module_name =>
                 ActionQueue.add_read_dependencies_module
		   (module_name, error_info)) : string -> unit}
d2044 2
a2045 1
	    ActionQueue.add_clear_debug name
d2048 4
d2084 1
a2084 1
             {a_clearAll = ActionQueue.add_clear_debug_all : unit -> unit,
d2425 1
a2425 2
                 ([("File", file_structure),
                   ("Build", build_structure),
d2458 1
a2458 2
		   c_file = file_record,
		   c_build = build_record,
@


1.189
log
@[Bug #30233]
Change editor interface.
@
text
@d16 4
d577 1
a577 1
 *  
d580 1
a580 1
 *  
d583 1
a583 1
 *  
d587 1
a587 1
 *  
d590 1
a590 1
 *  
d594 1
a594 1
 *  
d597 1
a597 1
 *  
d600 1
a600 1
 *  
d603 1
a603 1
 *  
d607 1
a607 1
 *  
d613 1
a613 1
 *  
d616 1
a616 1
 *  
d619 1
a619 1
 *  
d623 1
a623 1
 *  
d626 1
a626 1
 *  
d629 1
a629 1
 *  
d632 1
a632 1
 *  
d636 1
a636 1
 *  
d639 1
a639 1
 *  
d643 1
a643 1
 *  
d646 1
a646 1
 *  
d652 2
d750 1
a750 1
  sharing type ShellUtils.preferences = ShellTypes.preferences = 
d753 1
a753 1
	       ShellTypes.user_context = UserContext.user_context 
d797 1
a797 1
          SOME (Debugger_Types.FUNINFO {ty,...}) => 
d871 1
a871 1
          
d873 1
a873 1
          
d904 1
a904 1
	fun mk_record l = 
d920 1
a920 1
	fun make_tuple tylist = 
d925 1
a925 1
	    (map 
d930 2
a931 2
			     
        fun make_pair (a,b) = 
d934 1
a934 1
        fun make_triple (a,b,c) = 
d936 2
a937 2
          
        val string_pair = 
d951 1
a951 1
        val consumer_type = 
d956 1
a956 1
        val show_type = 
d958 1
a958 1
          
d974 1
a974 1
        val unit_to_unit = 
d976 2
a977 2
          
        val int_to_unit = 
d979 2
a980 2
          
        val bool_to_unit = 
d982 2
a983 2
          
        val string_to_unit = 
d986 1
a986 1
        val unit_to_string = 
d1016 1
a1016 1
            
d1035 1
a1035 1
              Scheme.make_scheme 
d1044 2
a1045 2
          
        val string_list_to_unit = 
d1049 3
a1051 3
	val string_to_string_cross_string_list = 
	  schemify (FUNTYPE (Types.string_type, 
			make_pair (Types.string_type, 
d1060 1
a1060 1
        val string_cross_string_cross_string_list_to_unit = 
d1064 1
a1064 1
	val string_to_string = 
d1067 1
a1067 1
        val string_to_string_cross_string_cross_string_list = 
d1070 2
a1071 2
          
        val unit_to_string_list = 
d1074 1
a1074 1
          
d1094 1
a1094 1
            
d1149 2
a1150 2
            val result = 
              Info.with_report_fun 
d1161 1
a1161 1
        fun shell_eval_fn s = 
d1164 1
a1164 1
        fun use_fun s = 
d1171 1
a1171 1
            fun output_fn s = print s 
d1174 1
a1174 1
              ActionQueue.do_actions 
d1186 1
a1186 1
        fun use_string_fun s = 
d1196 1
a1196 1
              ActionQueue.do_actions 
d1222 1
a1222 1
      
d1247 1
a1247 1
          let 
d1255 1
a1255 1
        
d1260 1
a1260 1
          let 
d1266 1
a1266 1
        
d1274 1
a1274 1
	  
d1278 1
a1278 1
	  in 
d1285 1
a1285 1
	     
d1292 1
a1292 1
	  
d1299 1
a1299 1
	  in 
d1311 1
a1311 1
	  (get_context_option_fun f, 
d1315 1
a1315 1
	     
d1317 1
a1317 1
          let 
d1321 1
a1321 1
          in 
d1324 1
a1324 1
          
d1330 1
a1330 1
	  
d1336 1
a1336 1
	  in 
d1343 1
a1343 1
	     
d1345 1
a1345 1
          cast 
d1363 1
a1363 1
          
d1374 1
a1374 1
          cast 
d1402 1
a1402 1
          cast 
d1410 1
a1410 1
           maximumHistorySize = 
d1412 1
a1412 1
           maximumErrors = 
d1414 1
a1414 1
           useCompletionMenu = 
d1425 1
a1425 1
          
d1443 1
a1443 1
          
d1445 2
a1446 2
          cast 
          {generateTraceProfileCode = 
d1449 1
a1449 1
           generateDebugInfo = 
d1451 1
a1451 1
           generateLocalFunctions = 
d1457 1
a1457 1
           generate_moduler = 
d1493 1
a1493 1
            {hideCFrames = 
d1570 1
a1570 1
	   
d1643 1
a1643 1
        val inspector_structure = 
d1662 1
a1662 1
	   [("dynamic", 
d1664 1
a1664 1
	    ("type_rep", 
d1691 1
a1691 1
	   a_getType = MLWorks.Internal.Value.cast (fn (a,b) => b), 
d1707 1
a1707 1
          
d1720 1
a1720 1
           
d1800 1
a1800 1
	      (fn filename => 
d1846 1
a1846 1
              (fn module_name => 
d1850 1
a1850 1
	      (fn module_name => 
d1950 1
a1950 1
	   a_removeCommand = CustomEditor.removeCommand : 
d1952 1
a1952 1
           a_removeDialog = CustomEditor.removeDialog : 
d1965 1
a1965 1
          let 
d2023 1
a2023 1
    
d2033 1
a2033 1
    
d2044 1
a2044 1
    
d2077 1
a2077 1
		   mk_valenv 
d2171 1
a2171 1
	  val (profiler_type, profile_full_type) = 
d2192 1
a2192 1
	  val profile_structure = 
d2210 1
a2210 1
	  val profile_record = 
d2228 2
a2229 1
	      val start = MLWorks.Time.Elapsed.elapsed ()
d2232 1
a2232 1
	       MLWorks.Time.Elapsed.elapsed_since start)
d2234 1
a2234 1
	  
d2236 1
a2236 1
	    
d2239 2
a2240 1
	      val start = MLWorks.Time.Elapsed.elapsed ()
d2242 9
d2252 3
a2254 1
		let val elapsed = MLWorks.Time.Elapsed.elapsed_since start
d2258 1
a2258 1
				  MLWorks.Time.Elapsed.format elapsed,
d2261 2
a2262 2
	      
	      val result = 
d2268 18
a2285 10
	      
	  (* change this if MLWorks.Time.Elapsed.T ever changes *)
	      
	  val elapsed_t_tycon = mk_longtycon (["MLWorks",
					       "Time",
					       "Elapsed"],
					      "T")
	    
	  val elapsed_t_type = get_runtime_type elapsed_t_tycon
	    
d2289 1
a2289 1
	    
d2291 3
a2293 3
	    
	  (* time has type ('a -> 'b) -> 'a -> Elapsed.T *)
	    
a2303 2
	  
	  (* time_iterations has type int -> ('a -> 'b) -> 'a -> Elapsed.T *)
d2305 3
a2307 1
	  val time_iterations_type = 
d2311 1
a2311 1
	      val time_iterations_type_instance = 
d2319 1
a2319 1
	  
d2325 2
a2326 2
	 
	  val print_timing_type = 
d2330 1
a2330 1
	      val print_timing_type_instance = 
d2357 1
a2357 1
	    
d2360 1
a2360 1
	    {a_time = time : ('a -> 'b) -> 'a -> MLWorks.Time.Elapsed.T,
d2363 1
a2363 1
		 int -> ('a -> 'b) -> 'a -> MLWorks.Time.Elapsed.T,
d2368 1
a2368 1
	    
d2420 1
a2420 1
		   a_saveImage = 
d2459 1
a2459 1
                                     runtime_env=Debugger_Types.RuntimeEnv.EMPTY, 
@


1.188
log
@[Bug #20088]
Merging from MLWorks_11:
SML'96 should be SML'97
@
text
@d16 5
d1043 5
d1058 3
d1383 2
a1384 1
	   ("customEditorName", mk_option Types.string_type),
d1400 4
a1403 2
           customEditorName =
	     (make_preference_rep #customEditorName) : string option_rep,
d1928 4
a1931 2
     val remove : string -> (string * string * string list)
     val names  : unit -> string list
d1936 4
a1939 2
              ("remove", string_to_string_cross_string_cross_string_list),
              ("names", unit_to_string_list)])
d1944 6
a1949 2
           a_remove = CustomEditor.remove : string -> (string * string * string list),
           a_names = CustomEditor.names : unit -> string list
@


1.187
log
@[Bug #30136]
Removed early-mips-r4000 option.
@
text
@d16 4
d1534 1
a1534 1
	   ("sml'96", unit_to_unit),
d1549 1
a1549 1
	fun select_sml'96 () =
d1558 1
a1558 1
	    UserOptions.select_sml'96 user_context_options;
d1616 1
a1616 1
	   sml'96 = select_sml'96 : unit -> unit,
@


1.187.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a15 4
 * Revision 1.187  1997/05/27  11:12:39  daveb
 * [Bug #30136]
 * Removed early-mips-r4000 option.
 *
@


1.187.2.2
log
@[Bug #30017]
Added Shell.Project.
Removed Shell.Build and Shell.File.
Removed all uses of the Action Queue.
@
text
@a15 3
 * Revision 1.187.2.1  1997/09/11  20:54:17  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d647 1
a647 1
require "../basics/module_id";
a655 1
require "../main/toplevel";
d663 1
a667 1
require "../main/proj_file";
d678 1
a678 1
  structure ModuleId : MODULE_ID
a689 2
  structure TopLevel : TOPLEVEL
  structure ProjFile : PROJ_FILE
d696 1
d706 5
a710 3
  sharing Incremental.InterMake.Compiler.Info =
          ShellUtils.Info =
	  TopLevel.Info
a716 1
          TopLevel.Options =
a722 2
  sharing type ModuleId.ModuleId = TopLevel.ModuleId = Incremental.ModuleId =
	       ShellUtils.ModuleId
d734 1
a734 1
               ShellUtils.UserOptions
d740 2
a741 2
               Preferences.preferences
  sharing type ShellUtils.user_context =
d746 1
a746 3
  sharing type Io.Location = Incremental.InterMake.Compiler.Info.Location.T =
	       ModuleId.Location = ProjFile.location
  sharing type TopLevel.Info.options = ProjFile.error_info
d1154 9
a1162 1
            fun queue level = ()
d1176 9
a1184 1
            fun queue level = ()
d1699 3
a1701 9
        val project_structure = mk_structure
          [("openProject", string_to_unit),
	   ("setConfiguration", string_to_unit),
	   ("setTargets", string_list_to_unit),
	   ("setMode", string_to_unit),
	   ("compile", string_to_unit),
           ("showCompile", string_to_unit),
           ("compileAll", unit_to_unit),
           ("showCompileAll", unit_to_unit),
d1703 2
d1707 19
a1725 5
           ("load", string_to_unit),
           ("showLoad", string_to_unit),
           ("loadAll", unit_to_unit),
           ("showLoadAll", unit_to_unit),
           ("listObjects", unit_to_unit),
d1729 3
a1731 15
	fun compile_all () =
	  TopLevel.build
	    error_info
	    (ShellTypes.get_current_options (!shell_data_ref))
	    ()

	fun show_compile_all () =
	  TopLevel.show_build
	    error_info
	    (ShellTypes.get_current_options (!shell_data_ref))
	    ()

	fun compile filename =
          let
	    val toplevel_name = ShellTypes.get_current_toplevel_name ()
d1733 2
a1734 30
	    val module_id =
                  ModuleId.from_string
                    (filename, Info.Location.FILE toplevel_name)
          in
            ShellUtils.compile_file
              (toplevel_name,
	       ShellTypes.get_current_options (!shell_data_ref),
               fn s => print s)
              error_info
              module_id
          end
  
	fun show_compile filename =
          let
	    val toplevel_name = ShellTypes.get_current_toplevel_name ()

	    val module_id =
                  ModuleId.from_string
                    (filename, Info.Location.FILE toplevel_name)
          in
            ShellUtils.check_compile_file
              (toplevel_name,
	       ShellTypes.get_current_options (!shell_data_ref),
               fn s => print s)
              error_info
              module_id
          end
  
	fun touch_source s =
	  ShellUtils.touch_source_module
d1741 44
a1784 3
	fun load filename =
          let
	    val toplevel_name = ShellTypes.get_current_toplevel_name ()
d1786 1
a1786 57
            val module_id =
                  ModuleId.from_string
                    (filename, Info.Location.FILE toplevel_name)
          in
            ShellUtils.load_file
              (ShellTypes.get_user_context (!shell_data_ref),
	       toplevel_name,
	       ShellTypes.get_current_options (!shell_data_ref),
               ShellTypes.get_current_preferences (!shell_data_ref),
	       print)
              error_info
              module_id
          end

	fun show_load filename =
          let
	    val toplevel_name = ShellTypes.get_current_toplevel_name ()

            val module_id =
                  ModuleId.from_string
                    (filename, Info.Location.FILE toplevel_name)
          in
            ShellUtils.check_load_file
              (toplevel_name, print)
              error_info
              module_id
          end

	fun touch_loaded filename =
          let
	    val toplevel_name = ShellTypes.get_current_toplevel_name ()

            val module_id =
                  ModuleId.from_string
                    (filename, Info.Location.FILE toplevel_name)
          in
	    Incremental.delete_module
              error_info
              module_id
          end

	fun read_dependencies filename =
          let
	    val toplevel_name = ShellTypes.get_current_toplevel_name ()

            val module_id =
                  ModuleId.from_string
                    (filename, Info.Location.FILE toplevel_name)
          in
	    Incremental.read_dependencies
	      toplevel_name
              error_info
              module_id
          end


	val project_record =
d1788 27
a1814 35
	    {a_openProject =
	       (fn file => ProjFile.open_proj file): string -> unit,
	     a_setConfiguration =
	       (fn config => 
                  ProjFile.setCurrentConfiguration
                    (error_info,
                     Info.Location.FILE
  		       (ShellTypes.get_current_toplevel_name ()))
                    config): string -> unit,
	     a_setTargets = 
	       (fn targets => 
                  ProjFile.setCurrentTargets
                    (error_info,
                     Info.Location.FILE
  		       (ShellTypes.get_current_toplevel_name ()))
                    targets): string list -> unit,
	     a_setMode = 
	       (fn mode => 
                  ProjFile.setCurrentMode
                    (error_info,
                     Info.Location.FILE
  		       (ShellTypes.get_current_toplevel_name ()))
                    mode): string -> unit,
	     a_compileAll = compile_all: unit -> unit,
	     a_showCompileAll = show_compile_all: unit -> unit,
	     a_compile = compile: string -> unit,
	     a_showCompile = show_compile: string -> unit,
	     a_touchSource = touch_source: string -> unit,
             a_loadAll =
              (fn () => ()): unit -> unit,
	      (* XXX needs wiring up *)
	     a_showLoadAll =
              (fn () => ()): unit -> unit,
	      (* XXX needs wiring up *)
             a_touchLoaded = touch_loaded: string -> unit,
d1816 21
a1836 11
	       (fn () => Incremental.delete_all_modules true): unit -> unit,
	     a_load = load: string -> unit,
	     a_showLoad = show_load: string -> unit,
	     a_listObjects =
	      (fn filename => 
		 TopLevel.list_objects
		   error_info
		   (ShellTypes.get_current_options (!shell_data_ref))
		   [filename]): string -> unit,
	     a_delete = delete_from_project: string -> unit,
	     a_readDependencies = read_dependencies: string -> unit}
d1991 1
a1991 2
	    UserContext.clear_debug_info
	      (ShellTypes.get_user_context (!shell_data_ref), name)
a1993 4
        fun debug_clear_all () =
	  UserContext.clear_debug_all_info
	    (ShellTypes.get_user_context (!shell_data_ref))
    
d2026 1
a2026 1
             {a_clearAll = debug_clear_all : unit -> unit,
d2346 2
a2347 1
                 ([("Project", project_structure),
d2380 2
a2381 1
		   c_project = project_record,
@


1.187.2.3
log
@[Bug #30326]
@
text
@a15 6
 * Revision 1.187.2.2  1997/11/17  16:54:37  daveb
 * [Bug #30017]
 * Added Shell.Project.
 * Removed Shell.Build and Shell.File.
 * Removed all uses of the Action Queue.
 *
d658 1
a658 1
require "../main/mlworks_io";
@


1.187.2.4
log
@[Bug #30071]
The action queue is no more, so ShellUtils.use_{file,string} and
ShellUtils.read_dot_mlworks no longer take queue functions.
@
text
@a15 3
 * Revision 1.187.2.3  1997/11/20  16:59:10  daveb
 * [Bug #30326]
 *
d1168 1
d1170 1
a1170 1
            ShellUtils.use_file (!shell_data_ref, print, s)
d1182 1
d1184 1
a1184 1
            ShellUtils.use_string (!shell_data_ref, print, s)
@


1.187.2.5
log
@[Bug #30017]
Rationalised Shell.Project commands:
ShellUtils functions now take strings instead of module_ids, and
explicit location values.
Added functions for loadAll and showLoadAll.
Removed TopLevel.
@
text
@a15 5
 * Revision 1.187.2.4  1997/11/26  11:36:40  daveb
 * [Bug #30071]
 * The action queue is no more, so ShellUtils.use_{file,string} and
 * ShellUtils.read_dot_mlworks no longer take queue functions.
 *
d703 1
d721 2
a722 1
          ShellUtils.Info
d729 1
d736 2
a737 1
  sharing type ModuleId.ModuleId = Incremental.ModuleId
d763 2
a764 1
  sharing type ShellUtils.Info.options = ProjFile.error_info
a1713 1
	   (*
a1714 1
	   *)
a1717 3
	fun get_location () =
	  Info.Location.FILE (ShellTypes.get_current_toplevel_name ())

d1719 1
a1719 3
	  ShellUtils.compile_targets
	    (get_location (),
	     ShellTypes.get_current_options (!shell_data_ref))
d1721 2
d1725 1
a1725 2
	  ShellUtils.show_compile_targets
	    (get_location (), print)
d1727 2
d1731 14
a1744 5
          ShellUtils.compile_file
            (get_location (),
	     ShellTypes.get_current_options (!shell_data_ref))
            error_info
            filename
d1747 14
a1760 4
          ShellUtils.show_compile_file
            (get_location (), print)
            error_info
            filename
d1762 3
a1764 1
	fun touch_source s = ShellUtils.touch_source (s, get_location ())
d1767 2
a1768 1
	  ShellUtils.delete_from_project (s, get_location ())
d1771 16
a1786 8
          ShellUtils.load_file
            (ShellTypes.get_user_context (!shell_data_ref),
	     get_location (),
	     ShellTypes.get_current_options (!shell_data_ref),
             ShellTypes.get_current_preferences (!shell_data_ref),
	     print)
            error_info
            filename
d1789 12
a1800 19
          ShellUtils.show_load_file
            (get_location (), print)
            error_info
            filename

	fun load_targets () =
	  (print "loading targets\n";
	  ShellUtils.load_targets
	    (ShellTypes.get_user_context (!shell_data_ref),
	     get_location (),
	     ShellTypes.get_current_options (!shell_data_ref),
             ShellTypes.get_current_preferences (!shell_data_ref),
	     print)
            error_info)

	fun show_load_targets () =
          ShellUtils.show_load_targets
            (get_location (), print)
            error_info
d1804 5
a1808 1
            val module_id = ModuleId.from_string (filename, get_location ())
d1837 3
a1839 1
                    (error_info, get_location ())
d1844 3
a1846 1
                    (error_info, get_location ())
d1851 3
a1853 1
                    (error_info, get_location ())
d1860 6
a1865 2
             a_loadAll = load_targets: unit -> unit,
	     a_showLoadAll = show_load_targets: unit -> unit,
a1870 1
	     (*
a1876 1
	     *)
@


1.187.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a15 4
 * Revision 1.187  1997/05/27  11:12:39  daveb
 * [Bug #30136]
 * Removed early-mips-r4000 option.
 *
@


1.186
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d16 4
a1409 1
	   ("earlyMipsR4000", mk_option Types.bool_type),
a1438 3
	       bool option_rep,
           earlyMipsR4000 =
             (make_context_option_rep #early_mips_r4000) :
@


1.185
log
@[Bug #2026]
Ensure setPervasive and setSourcePath handle OS.SysErr
@
text
@d16 4
d681 1
a681 1
  structure Io : IO
@


1.184
log
@Renaming R4000 option
@
text
@d16 3
d1843 13
a1855 4
	    (map (OS.FileSys.fullPath o Getenv.expand_home_dir) l)
          handle
            Getenv.BadHomeName s => env_error (path_exn, s)
            (* XXXEXCEPTION: should handle OS.SysErr *)
d1861 1
a1861 1
	  Io.set_object_path(Getenv.expand_home_dir s, Info.Location.UNKNOWN)
d1872 1
a1872 1
	     Info.Location.UNKNOWN)
d1875 8
a1882 1
            (* XXXEXCEPTION: should handle OS.SysErr *)
@


1.184.1.1
log
@branched from 1.184
@
text
@a15 3
 * Revision 1.184  1997/03/25  11:59:27  matthew
 * Renaming R4000 option
 *
@


1.184.1.2
log
@[Bug #2026]
Ensure setPervasive and setSourcePath handle OS.SysErr.
@
text
@a15 7
 * Revision 1.184.1.1  1997/05/12  10:34:15  hope
 * branched from 1.184
 *
 * Revision 1.185  1997/04/11  12:03:57  jont
 * [Bug #2026]
 * Ensure setPervasive and setSourcePath handle OS.SysErr
 *
d1843 4
a1846 13
	    (map
	     (fn x =>
	      (OS.FileSys.fullPath(Getenv.expand_home_dir x))
	      handle Getenv.BadHomeName s => env_error (path_exn, s)
		   | OS.SysErr(str, err) =>
		let
		  val str = case err of
		    NONE => str
		  | SOME err => OS.errorMsg err
		in
		  env_error(path_exn, str ^ ": " ^ x)
		end)
	     l)
d1852 1
a1852 1
	  Io.set_object_path(Getenv.expand_home_dir s, Info.Location.FILE"<Shell>")
d1863 1
a1863 1
	     Info.Location.FILE"<Shell>")
d1866 1
a1866 8
	  | OS.SysErr(str, err) =>
	      let
		val str = case err of
		  NONE => str
		| SOME err => OS.errorMsg err
	      in
		env_error(path_exn, str ^ ": " ^ s)
	      end
@


1.184.1.3
log
@[Bug #30136]
Hid early_mips_r4000 option from users.
@
text
@a15 4
 * Revision 1.184.1.2  1997/05/12  15:27:32  daveb
 * [Bug #2026]
 * Ensure setPervasive and setSourcePath handle OS.SysErr.
 *
d1409 1
d1439 3
@


1.184.1.3.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a15 4
 * Revision 1.184.1.3  1997/05/19  18:21:21  daveb
 * [Bug #30136]
 * Hid early_mips_r4000 option from users.
 *
@


1.184.1.3.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a15 4
 * Revision 1.184.1.3  1997/05/19  18:21:21  daveb
 * [Bug #30136]
 * Hid early_mips_r4000 option from users.
 *
@


1.184.1.3.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a15 4
 * Revision 1.184.1.3  1997/05/19  18:21:21  daveb
 * [Bug #30136]
 * Hid early_mips_r4000 option from users.
 *
@


1.184.1.3.1.2
log
@[Bug #20088]
Change sml'96 to sml'97.
@
text
@a15 3
 * Revision 1.184.1.3.1.1  1997/07/28  18:18:54  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d1537 1
a1537 1
	   ("sml'97", unit_to_unit),
d1552 1
a1552 1
	fun select_sml'97 () =
d1561 1
a1561 1
	    UserOptions.select_sml'97 user_context_options;
d1619 1
a1619 1
	   sml'97 = select_sml'97 : unit -> unit,
@


1.184.1.3.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a15 4
 * Revision 1.184.1.3.1.2  1997/08/08  17:14:07  daveb
 * [Bug #20088]
 * Change sml'96 to sml'97.
 *
@


1.183
log
@[Bug #1965]
Handled Io.NotSet for getting paths.
@
text
@d16 4
d1398 2
a1399 2
	   ("mips2", mk_option Types.bool_type),
	   ("mipsR4000", mk_option Types.bool_type),
d1427 2
a1428 2
           mips2 =
             (make_context_option_rep #mips2) :
d1430 2
a1431 2
           mipsR4000 =
             (make_context_option_rep #mips_r4000) :
@


1.182
log
@Changing use to work properly
@
text
@d16 3
d1850 1
d1863 1
@


1.181
log
@Adding platform dependent options
@
text
@d16 3
d716 3
a718 2
	       ActionQueue.ShellData = SaveImage.ShellData
  sharing type ShellUtils.preferences = ShellTypes.preferences
a1106 1
            val ShellTypes.SHELL_DATA{debugger,...} = shell_data
d1113 1
a1113 1
              (string,options,context,debugger)
d1123 44
d1266 2
a1267 2
          (* changing oldDefinition option in Shell.Options.Language
             ought to affect the equality attribute on Types.real_tyname*)
d1271 1
a1271 1
           (fn f => fn v => (Types.real_tyname_equality_attribute:=v;
d1355 3
a1357 2
	   ("useWindowDebugger",  mk_option Types.bool_type),
	   ("useErrorBrowser",  mk_option Types.bool_type)]
d1374 4
d1379 1
a1379 3
	     (make_preference_rep #window_debugger) : bool option_rep,
           useErrorBrowser =
	     (make_preference_rep #use_error_browser) : bool option_rep
d1538 1
d1551 1
d2284 13
a2296 13
          let
            val (context', identifiers) =
              Incremental.add_value
              (initial_context,
               "use",
               UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rectype),
                               NONE),
               cast
               ((fn filename => ActionQueue.add_use (filename,error_info)) : string -> unit)
               )
          in
            context'
          end
@


1.180
log
@Adding local functions option
@
text
@d16 3
d1341 2
d1347 2
a1348 1
	   ("printCompilerMessages", mk_option Types.bool_type)
d1370 6
d1385 2
a1386 1
	   bool option_rep
a1387 2
          

@


1.179
log
@[Bug #1711]
adding side-effect to oldDefinition option: set equality attribute
on real_tyname.
@
text
@d16 5
d1332 1
d1352 2
@


1.179.4.1
log
@branched from 1.179
@
text
@a15 5
 * Revision 1.179  1996/11/06  13:28:12  andreww
 * [Bug #1711]
 * adding side-effect to oldDefinition option: set equality attribute
 * on real_tyname.
 *
@


1.179.3.1
log
@branched from 1.179
@
text
@a15 5
 * Revision 1.179  1996/11/06  13:28:12  andreww
 * [Bug #1711]
 * adding side-effect to oldDefinition option: set equality attribute
 * on real_tyname.
 *
@


1.179.3.1.1.1
log
@branched from 1.179.3.1
@
text
@a15 3
 * Revision 1.179.3.1  1996/12/17  17:47:47  hope
 * branched from 1.179
 *
@


1.179.2.1
log
@branched from 1.179
@
text
@a15 5
 * Revision 1.179  1996/11/06  13:28:12  andreww
 * [Bug #1711]
 * adding side-effect to oldDefinition option: set equality attribute
 * on real_tyname.
 *
@


1.179.1.1
log
@branched from 1.179
@
text
@a15 5
 * Revision 1.179  1996/11/06  13:28:12  andreww
 * [Bug #1711]
 * adding side-effect to oldDefinition option: set equality attribute
 * on real_tyname.
 *
@


1.179.1.1.1.1
log
@branched from 1.179.1.1
@
text
@a15 3
 * Revision 1.179.1.1  1996/11/14  12:49:32  hope
 * branched from 1.179
 *
@


1.178
log
@[Bug #1728]
__integer becomes __int
@
text
@d16 4
d1210 9
d1423 1
a1423 1
	     (make_context_option_rep #old_definition) : bool option_rep,
@


1.177
log
@[Bug #1614]
removing toplevel String.
@
text
@d16 4
d605 1
a605 1
require "../basis/__integer";
@


1.176
log
@[Bug #1654]
Shell.Dynamic.type -> Shell.Dynamic.type_rep
@
text
@d16 4
d744 1
a744 1
          MLWorks.Option.SOME (Debugger_Types.FUNINFO {ty,...}) => 
d834 1
a834 1
        fun schemify ty = UNBOUND_SCHEME (ty,MLWorks.Option.NONE)
d895 1
a895 1
	  Types.make_tyname (1, true, "option", MLWorks.Option.NONE, 0)
d961 1
a961 1
	      Scheme.make_scheme([alpha,beta], (type_instance, MLWorks.Option.NONE))
d973 1
a973 1
              Scheme.make_scheme ([alpha,beta], (FUNTYPE (FUNTYPE (alpha,beta),FUNTYPE (alpha,beta)),MLWorks.Option.NONE))
d988 1
a988 1
                MLWorks.Option.NONE))
d1058 1
a1058 1
	     ref MLWorks.Option.NONE,
d1149 1
a1149 1
                                        Types.empty_rectype),MLWorks.Option.NONE))
d1160 1
a1160 1
            Scheme.make_scheme ([aty], (FUNTYPE(aty_option, aty),MLWorks.Option.NONE))
d1176 1
a1176 1
            Lists.iterate (fn f => f ()) update_fns
d1197 1
a1197 1
            Lists.iterate (fn f => f ()) update_fns
d1225 1
a1225 1
            Lists.iterate (fn f => f ()) update_fns
d1841 1
a1841 1
               ref MLWorks.Option.NONE,
d1876 1
a1876 1
              MLWorks.Option.SOME _ => true
d1911 1
a1911 1
               ref MLWorks.Option.NONE,
d2028 1
a2028 1
						   MLWorks.Option.NONE)),
d2030 1
a2030 1
						   MLWorks.Option.NONE)))
d2041 1
a2041 1
		ref MLWorks.Option.NONE,
d2090 1
a2090 1
			 String.implode ["Time for ", name, " : ",
d2127 1
a2127 1
						MLWorks.Option.NONE))
d2142 1
a2142 1
						MLWorks.Option.NONE))
d2162 1
a2162 1
						MLWorks.Option.NONE))
d2169 1
a2169 1
		ref MLWorks.Option.NONE,
d2202 1
a2202 1
                               MLWorks.Option.NONE),
@


1.176.1.1
log
@branched from 1.176
@
text
@a15 4
 * Revision 1.176  1996/10/10  14:36:38  andreww
 * [Bug #1654]
 * Shell.Dynamic.type -> Shell.Dynamic.type_rep
 *
@


1.175
log
@[Bug #1592]
threading extra level argument to make_tyname
@
text
@d16 4
d1532 1
a1532 1
	    ("type", 
@


1.174
log
@[Bug #1480]
Implemented compile-and-load properly.
@
text
@d16 4
d887 2
a888 1
	  Types.make_tyname (1, true, "option", MLWorks.Option.NONE)
@


1.174.2.1
log
@branched from 1.174
@
text
@a15 4
 * Revision 1.174  1996/08/20  13:49:48  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
@


1.174.1.1
log
@branched from 1.174
@
text
@a15 4
 * Revision 1.174  1996/08/20  13:49:48  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
@


1.173
log
@[Bug #714]
Introduce a new Debugger structure into Shell.Options that
interfaces the flags in debugger/__stack_frame.sml
@
text
@d16 5
d1660 2
a1661 2
               (ActionQueue.add_compile_file (filename,error_info);
                ActionQueue.add_load_file (filename,error_info))) : string -> unit,
d1710 2
a1711 2
               (ActionQueue.add_compile_module (module_name,error_info);
                ActionQueue.add_load_module (module_name,error_info))) : string -> unit,
@


1.172
log
@[Bug #1521]
Propagating changes made to typechecker/_scheme.sml and _types.sml
@
text
@d16 4
d601 1
d643 1
d1333 37
d1898 1
d1918 1
@


1.171
log
@Removed Shell.Path.objectPath and Shell.Path.setObjectPath for the beta
release.
@
text
@d16 4
d652 2
a653 1
          ShellUtils.Options
d756 1
a756 1
        val print_options = ShellTypes.get_current_print_options shell_data
d758 1
a758 1
        Types.print_type print_options ty
d1389 2
d1401 3
a1403 1
	  in
d1821 2
d1826 2
a1827 1
	    Debugger_Types.print_function_information (name,debug_info,true)
d1832 2
d1836 1
a1836 1
            Debugger_Types.print_information (debug_info,true)
@


1.170
log
@[Bug #1503]
Add field to FUNINFO to say if arg actually saved
@
text
@d16 4
d1665 1
d1668 1
d1682 1
d1689 1
d1708 1
d1711 1
@


1.169
log
@Add print_messages to Shell.Options.Compiler
@
text
@d16 3
d2183 1
a2183 1
      (* Now add debug info for the Environment errors exception *)
d2185 1
a2185 1
      (* Note that labels must be unique -- so a better mechanism is needed
d2195 1
@


1.168
log
@Correcting bungled definition of Shell.Editor.Custom ...
@
text
@d16 3
d1282 2
a1283 1
	   ("optimizeSelfTailCalls", mk_option Types.bool_type)
d1302 1
a1302 1
	      bool option_rep,
d1304 1
a1304 1
	      bool option_rep,
d1306 1
a1306 1
	      bool option_rep,
d1308 5
a1312 4
	      bool option_rep,
           optimizeSelfTailCalls =
	      (make_context_option_rep #optimize_self_tail_calls):
		 bool option_rep
@


1.167
log
@Modifications to add custom editor interface ...
@
text
@d1747 2
a1748 1
           a_EditError = edit_exn : internal_exn_rep}
@


1.166
log
@Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
now does what the former used to do.
@
text
@d16 4
d591 2
d623 1
d842 3
d894 7
d956 14
a969 3
          
        val unit_to_string = 
          schemify (FUNTYPE (Types.empty_rectype, Types.string_type))
d1236 4
a1239 3
	  [("editor", mk_option Types.string_type),
	   ("xtermEditorCommand", mk_option Types.string_type),
	   ("xEditorCommand", mk_option Types.string_type),
d1250 4
a1253 4
           xtermEditorCommand =
	     (make_preference_rep #xterm_editor_command) : string option_rep,
           xEditorCommand =
	     (make_preference_rep #x_editor_command) : string option_rep,
d1696 20
d1734 7
a1740 2
	  mk_exn_structure
	    ([("editFile", string_to_unit),
@


1.165
log
@Reorganised the options menus.
@
text
@d16 3
d1632 1
a1632 1
	    (map (OS.FileSys.realPath o Getenv.expand_home_dir) l)
d1648 1
a1648 1
	    (OS.FileSys.realPath (Getenv.expand_home_dir s),
@


1.164
log
@Various renamings.
@
text
@d16 3
d1278 1
a1278 14
	val extension_structure = mk_structure
          [("requireReservedWord", mk_option Types.bool_type),
           ("typeDynamic", mk_option Types.bool_type)
           ]
          
	val extension_record =
          cast
          {requireReservedWord =
	     (make_context_option_rep #require_keyword) : bool option_rep,
           typeDynamic =
	     (make_context_option_rep #type_dynamic) : bool option_rep
           }

	val compat_structure = mk_structure
d1285 3
a1287 1
	   ("abstractions", mk_option Types.bool_type)
d1293 1
a1293 1
	val compat_record =
d1308 5
a1312 1
	     (make_context_option_rep #abstractions) : bool option_rep
a1322 1
	   ("variableInfo", mk_option Types.bool_type),
a1374 10
	fun select_var_info b =
	  let
	    val user_context_options =
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
	  in
	    UserOptions.select_var_info (user_context_options, b);
	    UserOptions.update_user_context_options user_context_options
	  end

a1383 9
        fun is_var_info _ =
	  let
	    val user_context_options =
	      UserContext.get_user_options
	        (ShellTypes.get_user_context (!shell_data_ref))
	  in
	    UserOptions.is_var_info user_context_options
	  end

a1398 1
	   variableInfo = (is_var_info, select_var_info) : bool option_rep,
d1766 2
a1767 3
	    	      ("Extension", extension_structure),
	    	      ("Compatibility", compat_structure),
	    	      ("Mode", mode_option_structure)],
a1783 1
              c_extension = extension_record,
d1786 1
a1786 1
	      c_compat = compat_record,
@


1.163
log
@Commented out Shell.Module.save, as it is not implemented.
@
text
@d16 3
a1207 1
	   ("automaticOutputWindow", mk_option Types.bool_type),
a1224 2
	   automaticOutputWindow =
	     (make_preference_rep #auto_output_window) : bool option_rep,
d1276 2
a1277 3
          [("requireKeyword", mk_option Types.bool_type),
           ("typeDynamic", mk_option Types.bool_type),
	   ("abstractions", mk_option Types.bool_type)
d1282 1
a1282 1
          {requireKeyword =
d1285 1
a1285 3
	     (make_context_option_rep #type_dynamic) : bool option_rep,
           abstractions =
	     (make_context_option_rep #abstractions) : bool option_rep
d1291 1
a1291 1
	   ("njSignatures", mk_option Types.bool_type),
d1294 2
a1295 1
	   ("fixityInOpen", mk_option Types.bool_type)
d1307 1
a1307 1
	   njSignatures =
d1314 3
a1316 1
	     (make_context_option_rep #open_fixity) : bool option_rep
d1323 3
a1325 3
	  [("newJersey", unit_to_unit),
	   ("harlequin", unit_to_unit),
	   ("standard", unit_to_unit),
d1330 1
a1330 1
	fun select_new_jersey () =
d1336 1
a1336 1
	    UserOptions.select_new_jersey user_context_options;
d1340 1
a1340 1
	fun select_harlequin () =
d1346 1
a1346 1
	    UserOptions.select_harlequin user_context_options;
d1350 1
a1350 1
	fun select_standard () =
d1356 1
a1356 1
	    UserOptions.select_standard user_context_options;
d1419 3
a1421 3
	  {newJersey = select_new_jersey : unit -> unit,
	   harlequin = select_harlequin : unit -> unit,
	   standard = select_standard : unit -> unit,
d1517 1
a1517 1
        val module_structure = mk_structure
d1591 1
a1591 1
	val module_record =
d2097 1
a2097 1
                   ("Module", module_structure),
d2131 1
a2131 1
		   c_module = module_record,
@


1.162
log
@Moved the code for saving images, parsing command lines, etc. to a new file.
@
text
@d16 3
d1523 1
d1525 1
d1611 1
d1615 1
@


1.161
log
@Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
@
text
@d16 3
a553 1
require "../make/old_os";
a574 2
require "../main/version";
require "../basis/exit";
d576 1
a581 1
  structure OldOs : OLD_OS
a596 1
  structure Version : VERSION
d604 1
a604 1
  structure Exit : EXIT
d640 1
a640 1
	       ActionQueue.ShellData
a647 1
  sharing type OS.Process.status = Exit.status
a673 13
    (* Use the standard streams *)

      fun with_standard_streams f =
	MLWorks.IO.with_standard_output
	MLWorks.IO.terminal_out
	(fn () =>
	 MLWorks.IO.with_standard_error
	 MLWorks.IO.terminal_out
	 (fn () =>
	  MLWorks.IO.with_standard_input
	  MLWorks.IO.terminal_in
	  f))
      
a739 4
    fun get_mk_xinterface_fn (ShellTypes.SHELL_DATA{mk_xinterface_fn,...}) = mk_xinterface_fn
    fun get_x_running (ShellTypes.SHELL_DATA{x_running,...}) = x_running
    fun get_mk_tty_listener(ShellTypes.SHELL_DATA{mk_tty_listener,...}) = mk_tty_listener

d1126 1
a1126 1
            val UserOptions.USER_CONTEXT_OPTIONS (_, ref update_fns) =
d1130 1
a1130 1
            Lists.iterate (fn f => f ()) update_fns
a1132 16
	fun set_user_context_option f =
	     let val UserOptions.USER_CONTEXT_OPTIONS (user_options, _) =
		   UserContext.get_user_options
		     (ShellTypes.get_user_context (!shell_data_ref))
	     in 
               (f user_options) := true
	     end

	fun clear_user_context_option f =
	     let val UserOptions.USER_CONTEXT_OPTIONS (user_options, _) =
		   UserContext.get_user_options
		     (ShellTypes.get_user_context (!shell_data_ref))
	     in 
               (f user_options) := false
	     end

a1151 14
	fun set_user_preference f =
	     let val Preferences.USER_PREFERENCES (user_preferences, _) =
		   ShellTypes.get_user_preferences (!shell_data_ref)
	     in 
               (f user_preferences) := true
	     end

	fun clear_user_preference f =
	     let val Preferences.USER_PREFERENCES (user_preferences, _) =
		   ShellTypes.get_user_preferences (!shell_data_ref)
	     in 
               (f user_preferences) := false
	     end

d1328 8
a1335 8
	  (clear_user_context_option #require_keyword;
	   clear_user_context_option #type_dynamic;
	   set_user_context_option #nj_op_in_datatype;
	   set_user_context_option #nj_signatures;
	   set_user_context_option #weak_type_vars;
           set_user_context_option #abstractions;
	   set_user_context_option #old_definition;
           update_user_options ())
d1338 8
a1345 8
	  (set_user_context_option #require_keyword;
	   set_user_context_option #type_dynamic;
	   clear_user_context_option #nj_op_in_datatype;
	   clear_user_context_option #nj_signatures;
	   clear_user_context_option #weak_type_vars;
           set_user_context_option #abstractions;
	   clear_user_context_option #old_definition;
           update_user_options ())
d1348 38
a1385 38
	  (clear_user_context_option #require_keyword;
	   clear_user_context_option #type_dynamic;
	   clear_user_context_option #nj_op_in_datatype;
	   clear_user_context_option #nj_signatures;
	   clear_user_context_option #weak_type_vars;
           clear_user_context_option #abstractions;
	   clear_user_context_option #old_definition;
           update_user_options ())

	fun select_optimizing true =
	  (set_user_context_option #optimize_handlers;
	   set_user_context_option #optimize_leaf_fns;
	   set_user_context_option #optimize_tail_calls;
	   set_user_context_option #optimize_self_tail_calls;
           update_user_options ())
	  | select_optimizing false =
	    (clear_user_context_option #optimize_handlers;
	     clear_user_context_option #optimize_leaf_fns;
	     clear_user_context_option #optimize_tail_calls;
	     clear_user_context_option #optimize_self_tail_calls;
	     update_user_options ())

	fun select_debugging false =
	  (clear_user_context_option #generate_interceptable_code;
	   clear_user_context_option #generate_debug_info;
	   clear_user_context_option #generate_variable_debug_info;
           update_user_options ())
	|   select_debugging true =
	  (set_user_context_option #generate_interceptable_code;
	   set_user_context_option #generate_debug_info;
           update_user_options ())

	fun select_var_info false =
	  (clear_user_context_option #generate_variable_debug_info;
           update_user_options ())
	|   select_var_info true =
	  (set_user_context_option #generate_variable_debug_info;
	   select_debugging true)
d1388 7
a1394 2
          get_context_option_fun #generate_debug_info () andalso
          get_context_option_fun #generate_interceptable_code ()
d1397 7
a1403 2
	  is_debugging () andalso
          get_context_option_fun #generate_variable_debug_info ()
d1406 7
a1412 4
          get_context_option_fun #optimize_handlers () andalso
          get_context_option_fun #optimize_leaf_fns () andalso
          get_context_option_fun #optimize_tail_calls () andalso
          get_context_option_fun #optimize_self_tail_calls ()
a1810 2
	val x_message = "The MLWorks GUI is already running\n"

a2060 190
        val xinterface_fn : bool -> unit =
          fn has_controlling_tty =>
            let val shell_data = !shell_data_ref
            in
              if get_x_running shell_data then
		MLWorks.IO.output (MLWorks.IO.std_out, x_message)
	      else
		(get_mk_xinterface_fn shell_data)
		(ShellTypes.get_listener_args shell_data)
		has_controlling_tty
            end

        fun set_preferences (ShellTypes.SHELL_DATA {user_options,user_preferences,...}) =
          case ShellUtils.preference_file_name () of
            MLWorks.Option.NONE => ()
          | MLWorks.Option.SOME pathname =>
              (case OldOs.mtime pathname of
                 OldOs.NOT_EXIST => ()
               | OldOs.EXISTS _ =>
                   let
                     val user_options = 
                       UserContext.get_user_options
                       (ShellTypes.get_user_context (!shell_data_ref))

                     val instream = MLWorks.IO.open_in pathname
                     fun parse2 ([],acc) = String.implode (rev acc)
                       | parse2 ("\n"::rest,acc) = String.implode (rev acc)
                       | parse2 (a::rest,acc) = parse2 (rest,a::acc)
                     fun parse1 ([],acc) = (String.implode (rev acc),"")
                       | parse1 (" "::rest,acc) = (String.implode (rev acc),parse2 (rest,[]))
                       | parse1 (a::rest,acc) = parse1 (rest,a::acc)

                     fun loop acc =
                       let
                         val line = MLWorks.IO.input_line instream
                       in
                         if line = "" then rev acc
                         else loop (parse1 (String.explode line,[])::acc)
                       end
                     val items = loop [] handle exn => (MLWorks.IO.close_in instream; raise exn)
                   in
                     MLWorks.IO.close_in instream;
                     Preferences.set_from_list (user_preferences,items);
                     UserOptions.set_from_list (user_options,items)
                   end)
	local
	  fun message s =
	    (MLWorks.IO.output(MLWorks.IO.messages, s);
	     MLWorks.IO.output(MLWorks.IO.messages, "\n"));

	  (* Argument parsing.  The second parameter is the current set of
	   arguments, which is modified as the list is traversed. *)
	  fun parse ([], r) = r
	    | parse ("-tty" :: t, _) = parse (t, true)
	    | parse ("-gui" :: t, _) = parse (t, false)
	    | parse ("-full-menus" :: t, r) =
	      (set_user_preference #full_menus;
	       parse (t, r))
	    | parse ("-short-menus" :: t, r) =
	      (clear_user_preference #full_menus;
	       parse (t, r))
	    | parse ("-debug-mode" :: t, r) =
	      (select_var_info true;
	       select_optimizing false;
	       parse (t, r))
	    | parse ("-optimize-mode" :: t, r) =
	      (select_optimizing true;
	       select_var_info false;
	       parse (t, r))
	    | parse("-source-path" :: path :: rest, r) =
	      (Io.set_source_path_from_string(path, Info.Location.FILE "Command Line");
	       parse(rest, r))
	    | parse("-object-path" :: path :: rest, r) =
	      (Io.set_object_path(path, Info.Location.FILE "Command Line");
	       parse(rest, r))
	    | parse("-pervasive-dir" :: dir :: rest, r) =
	      (Io.set_pervasive_dir (dir, Info.Location.FILE "Command Line");
	       parse(rest, r))
	    | parse ("-help" :: _, r) =
	      (message (
" Usage:  mlworks [options]\n" ^
" Options:\n" ^
"   -gui  Start the MLWorks Graphical User Interface directly.  This is the\n" ^
"    default.\n" ^
"   -tty    Start MLWorks in text mode.\n" ^
(*
"   -short-menus\n" ^
"           When running the motif interface, hide advanced and experimental\n" ^
"           features.  This is the default.\n" ^
"   -full-menus\n" ^
"           When running the motif interface, make all features of the interface\n" ^
"           available, including advanced and experimental features.\n" ^
*)
"   -debug-mode\n" ^
"           Start MLWorks with debugging mode on and optimizing mode off.\n" ^
"   -optimize-mode\n" ^
"           Start MLWorks with optimizing mode on and debugging mode off.\n" ^
"   -help   Display this message and exit.");
	       Exit.exit Exit.failure;
	       false (* dummy value *))

	    | parse (s :: t, r) =
	      (message
	       ("Invalid argument " ^ s ^ ".\n" ^
		"Valid arguments are: -tty -gui -debug-mode -optimize-mode -help.");
	       Exit.exit Exit.failure;
	       false (* dummy value *));

	  fun main shell_data arguments =
	    let
	      (* Set things from env *)
	      val _ =
		Io.set_source_path_from_env
		(Info.Location.FILE "<Initialisation code>")
	      val _ =
		Io.set_pervasive_dir_from_env 
		(Info.Location.FILE "<Initialisation code>")
              (* Set the preferences before reading the command line args *)
              (* The fact that the option refs modified by this call to set_preferences and the option refs *)
              (* modified by parse are in fact _one and the same_ is obscure but true (as of now) *)
              val _ = set_preferences shell_data
	      (* Parse arguments.  Default is motif. *)
	      (* This may override some env stuff *)
	      val tty = parse (arguments, false) orelse is_a_tty_image
	      val _ = ActionQueue.read_dot_mlworks shell_data
	      val _ = shell_data_ref := shell_data
	      val mk_tty_listener = get_mk_tty_listener shell_data
	      val listener_args = ShellTypes.get_listener_args shell_data
	    in
	      with_standard_streams
	      (fn () =>
	       (if tty then
		  (message (Version.version_string);
		   mk_tty_listener listener_args)
		else
		  (xinterface_fn false;
		   0  (* exit status *))))
	    end
	  handle Interrupt => 0  (* Handle eg. interrupts during starting interface *)
	  fun handler_fn msg =
	    Info.error'
	    (error_info)
	    (Info.FATAL,
	     Info.Location.FILE (ShellTypes.get_current_toplevel_name ()),
	     msg)
	  fun make_new_shell_data
	    (ShellTypes.SHELL_DATA
	     {get_user_context,
	      user_options,
	      user_preferences,
	      prompter,
	      debugger,
	      profiler,
	      exit_fn,
	      x_running,
	      mk_xinterface_fn,
	      mk_tty_listener}) =
	    ShellTypes.SHELL_DATA
	    	     {get_user_context = get_user_context,
		      user_options = user_options,
		      user_preferences = user_preferences,
		      prompter = prompter,
		      debugger = debugger,
		      profiler = profiler,
		      exit_fn = exit_fn,
		      x_running = false,
		      mk_xinterface_fn = mk_xinterface_fn,
		      mk_tty_listener = mk_tty_listener}
	in
	  val save_fn : string * bool -> unit =
	    fn (filename, false) =>
	    let
	      val shell_data = make_new_shell_data(!shell_data_ref)
	      val main = main shell_data
	    in
	      MLWorks.Internal.save (filename, fn () => main (MLWorks.arguments ()))
	      handle MLWorks.Internal.Save msg => handler_fn msg;
		()
	    end
	     | (filename, true) =>
		 let
		   val shell_data = make_new_shell_data(!shell_data_ref)
		   val main = main shell_data
		 in
		   MLWorks.Internal.execSave (filename, fn () => main (MLWorks.arguments ()))
		   handle MLWorks.Internal.Save msg => handler_fn msg;
		     ()
		 end
	end

d2077 9
a2085 4
        val context =
          let
            val (context', identifiers) =
              Incremental.add_structure
d2112 8
a2119 2
		   a_saveImage = save_fn : string * bool -> unit,
		   a_startGUI = (fn () => xinterface_fn true) : unit -> unit,
d2132 4
a2135 3
          in
            context'
          end
@


1.160
log
@Update wrt move of file "main" to basis.
@
text
@d16 3
d2274 1
a2274 1
	      MLWorks.Internal.save (filename, fn () => main (MLWorks.OS.arguments ()))
d2283 1
a2283 1
		   MLWorks.Internal.execSave (filename, fn () => main (MLWorks.OS.arguments ()))
@


1.159
log
@Removed the ShellUtils.Error exception.
@
text
@d16 3
d571 1
a571 1
require "../main/exit";
@


1.158
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d16 6
d1032 1
a1032 1
        handle ShellUtils.Error (e,_) =>
@


1.157
log
@Removing MLWorks.Integer
@
text
@d16 3
d692 1
a692 1
        | _ => (output (std_out,string ^ "\n");
d1982 2
a1983 2
		  output(stream,
			 implode ["Time for ", name, " : ",
d2092 1
a2092 1
		output (std_out, x_message)
d2111 3
a2113 3
                     val instream = open_in pathname
                     fun parse2 ([],acc) = implode (rev acc)
                       | parse2 ("\n"::rest,acc) = implode (rev acc)
d2115 2
a2116 2
                     fun parse1 ([],acc) = (implode (rev acc),"")
                       | parse1 (" "::rest,acc) = (implode (rev acc),parse2 (rest,[]))
d2124 1
a2124 1
                         else loop (parse1 (explode line,[])::acc)
d2126 1
a2126 1
                     val items = loop [] handle exn => (close_in instream; raise exn)
d2128 1
a2128 1
                     close_in instream;
d2134 2
a2135 2
	    (output(MLWorks.IO.messages, s);
	     output(MLWorks.IO.messages, "\n"));
@


1.156
log
@Changes concerning MLWorks.save
@
text
@d16 3
d532 2
d821 1
a821 1
		       (MLWorks.Integer.makestring (!lab),x)))
@


1.155
log
@initbasis moved to basis
@
text
@d16 3
d871 3
a873 7
	val deliver_fn_type =
	  schemify
	    (FUNTYPE
	       (make_pair
		  (Types.string_type,
		   FUNTYPE(Types.empty_rectype, Types.empty_rectype)),
	        Types.empty_rectype))
a2090 13
	type deliverFnType = string * (unit -> unit) -> unit

	val deliver_fn : deliverFnType =
	  fn (filename, func) =>
	  with_standard_streams(fn () => MLWorks.deliver(filename, func)
				handle MLWorks.Save msg =>
				  Info.error'
				  (error_info)
				  (Info.FATAL,
				   Info.Location.FILE
				   (ShellTypes.get_current_toplevel_name ()),
				   msg))

d2248 2
a2249 12
	  val save_fn : string -> unit =
	    fn filename =>
	    let
	      val shell_data = make_new_shell_data(!shell_data_ref)
	      val main = main shell_data
	    in
	      MLWorks.save (filename, fn () => main (MLWorks.OS.arguments ()))
	      handle MLWorks.Save msg => handler_fn msg;
		()
	    end
	  val exec_save_fn : string -> unit =
	    fn filename =>
d2254 2
a2255 2
	      MLWorks.exec_save (filename, fn () => main (MLWorks.OS.arguments ()))
	      handle MLWorks.Save msg => handler_fn msg;
d2258 9
d2307 1
a2307 3
		   ("saveImage", string_to_unit),
		   ("execSave", string_to_unit),
		   ("deliverFn", deliver_fn_type)
a2313 1
		   a_execSave = exec_save_fn : string -> unit,
d2315 1
a2315 2
		   a_deliverFn = deliver_fn : deliverFnType,
		   a_save_image = save_fn : string -> unit,
@


1.154
log
@** No reason given. **
@
text
@d16 3
d527 1
a527 1
require "../initbasis/os";
@


1.153
log
@Rename Os -> OS to conform with latest basis revision.
@
text
@d16 3
d2318 1
a2318 1
		   ("xinterface", unit_to_unit),
d2328 1
d2330 1
a2330 1
		   a_xinterface = (fn () => xinterface_fn true) : unit -> unit,
d2332 1
a2332 2
		   a_deliverFn = deliver_fn : deliverFnType,
		   a_execSave = exec_save_fn : string -> unit,
@


1.152
log
@Changing loadDependencies to readDependencies.
@
text
@d16 3
d545 1
d551 1
a551 1
  structure Os : OS
d576 1
d620 2
d1658 1
a1658 1
	    (map (Os.FileSys.realPath o Getenv.expand_home_dir) l)
d1661 1
d1674 1
a1674 1
	    (Os.FileSys.realPath (Getenv.expand_home_dir s),
d1678 1
d2185 1
a2185 1
	       MLWorks.exit 1;
d2192 1
a2192 1
	       MLWorks.exit 2;
@


1.151
log
@Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
the deprecated OS interface.
@
text
@d16 4
d1516 1
a1516 1
           ("loadDepend", string_to_unit)]
d1531 1
a1531 1
           ("loadDepend", string_to_unit)]
d1585 4
a1588 2
	     a_loadDepend =
	      (fn _ => ()) : string -> unit}
d1635 4
a1638 2
	     a_loadDepend =
	      (fn _ => ()) : string -> unit}
@


1.150
log
@I forgot to add the type for Shell.Module.delete.
@
text
@d16 3
d514 2
a515 2
require "../initbasis/filesys";
require "../make/os";
a542 1
  structure FileSys : FILE_SYS
d544 1
d1643 1
a1643 1
	    (map (FileSys.realPath o Getenv.expand_home_dir) l)
d1658 1
a1658 1
	    (FileSys.realPath (Getenv.expand_home_dir s),
d2086 3
a2088 3
              (case Os.mtime pathname of
                 Os.NOT_EXIST => ()
               | Os.EXISTS _ =>
@


1.149
log
@Added Shell.Module.delete.
@
text
@d16 3
d1523 1
@


1.148
log
@Removing some options
 .

Removing some options
@
text
@d16 6
d1530 4
d1620 2
@


1.147
log
@Added Shell.{File,Module}.queryLoadObject
@
text
@d16 3
d622 1
a622 1
    val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
d647 1
a647 1
        val t = (castit f) : MLWorks.Internal.Value.T
d674 1
a674 1
        val (value,ty) = castit dyn
d684 1
a684 1
        val ty : Datatypes.Type = castit tyrep
d698 1
a698 1
      castit (exn, s)
d988 1
a988 1
            (castit result) : MLWorks.Internal.Dynamic.dynamic
d1016 1
a1016 1
	     Inspector.inspect_value (castit d,!shell_data_ref))
d1154 1
a1154 1
          castit 
d1183 1
a1183 1
          castit 
d1209 1
a1209 1
          castit 
d1246 1
a1246 1
          castit 
d1276 1
a1276 2
	   ("abstractions", mk_option Types.bool_type),
           ("topdecSemicolons", mk_option Types.bool_type)
d1280 1
a1280 1
          castit
d1286 1
a1286 3
	     (make_context_option_rep #abstractions) : bool option_rep,
	   topdecSemicolons =
	     (make_context_option_rep #topdec_semicolons) : bool option_rep
a1288 2
	(* Hide the derived_redef option for time being, as we haven't
	   implemented it. *)
d1290 1
a1290 2
	  [("stringInequalities", mk_option Types.bool_type),
	   ("infixrAssoc", mk_option Types.bool_type),
d1302 3
a1304 5
	  castit
	  {stringInequalities =
	     (make_context_option_rep #string_inequalities) : bool option_rep,
	   infixrAssoc =
	     (make_context_option_rep #infixr_assoc) : bool option_rep,
a1329 1
	   set_user_context_option #topdec_semicolons;
a1331 1
	   set_user_context_option #infixr_assoc;
d1335 1
a1335 1
	   set_user_context_option #string_inequalities;
a1339 1
	   set_user_context_option #topdec_semicolons;
a1341 1
	   clear_user_context_option #infixr_assoc;
d1345 1
a1345 1
	   set_user_context_option #string_inequalities;
a1349 1
	   clear_user_context_option #topdec_semicolons;
a1351 1
	   clear_user_context_option #infixr_assoc;
d1355 1
a1355 1
	   clear_user_context_option #string_inequalities;
d1403 1
a1403 1
	  castit
d1420 1
a1420 1
          castit
d1447 1
a1447 1
	    val the_exn = MLWorks.Internal.Dynamic.Coerce (castit (0, 0))
d1450 1
a1450 1
	    case castit the_exn
d1455 1
a1455 1
          castit
d1479 1
a1479 1
          castit
d1525 1
a1525 1
	  castit
d1568 1
a1568 1
	  castit
d1648 1
a1648 1
	   castit
d1665 1
a1665 1
            val f : MLWorks.Internal.Value.T = castit f
d1680 1
a1680 1
        val editor_record = castit
d1743 1
a1743 1
             castit
d1774 1
a1774 1
             castit
d1901 1
a1901 1
	    castit
d2028 1
a2028 1
	    castit
d2251 1
a2251 1
               castit
a2257 2
        fun set_value_polymorphism b = Scheme.use_value_polymorphism := b

d2278 1
a2278 2
		  [("setValuePolymorphism",bool_to_unit),
                   ("exit", int_to_unit),
d2288 1
a2288 1
               castit{
a2293 2
                   a_setValuePolymorphism =
		     set_value_polymorphism : bool -> unit,
@


1.146
log
@Fix deliverFn to use the standard streams.
@
text
@d16 3
d1568 3
a1570 1
	      (fn filename => ()) : string -> unit,
d1614 3
a1616 1
             (fn module_name => ()) : string -> unit,
@


1.145
log
@Fixed use of Info.default_options.
@
text
@d16 3
d617 13
d2058 8
a2065 7
	    MLWorks.deliver(filename, func)
	      handle MLWorks.Save msg =>
		Info.error'
		  (error_info)
		  (Info.FATAL,
		   Info.Location.FILE (ShellTypes.get_current_toplevel_name ()),
		   msg)
d2184 1
a2184 2
	      MLWorks.IO.with_standard_output
	      MLWorks.IO.terminal_out
d2186 6
a2191 12
	       MLWorks.IO.with_standard_error
	       MLWorks.IO.terminal_out
	       (fn () =>
		MLWorks.IO.with_standard_input
		MLWorks.IO.terminal_in
		(fn () =>
		 (if tty then
		    (message (Version.version_string);
		     mk_tty_listener listener_args)
		  else
		    (xinterface_fn false;
		     0  (* exit status *))))))
@


1.144
log
@Changing argument separato to hyphen from underscore
@
text
@d16 3
d692 1
a692 1
	val error_info = Info.default_options
@


1.143
log
@Adding compileAndLoad functionality
@
text
@d16 3
d2090 1
a2090 1
	    | parse ("-full_menus" :: t, r) =
d2093 1
a2093 1
	    | parse ("-short_menus" :: t, r) =
d2096 1
a2096 1
	    | parse ("-debug_mode" :: t, r) =
d2100 1
a2100 1
	    | parse ("-optimize_mode" :: t, r) =
d2104 1
a2104 1
	    | parse("-source_path" :: path :: rest, r) =
d2107 1
a2107 1
	    | parse("-object_path" :: path :: rest, r) =
d2110 1
a2110 1
	    | parse("-pervasive_dir" :: dir :: rest, r) =
d2121 1
a2121 1
"   -short_menus\n" ^
d2124 1
a2124 1
"   -full_menus\n" ^
d2128 1
a2128 1
"   -debug_mode\n" ^
d2130 1
a2130 1
"   -optimize_mode\n" ^
d2139 1
a2139 1
		"Valid arguments are: -tty -gui -debug_mode -optimize_mode -help.");
@


1.142
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@d16 3
a1485 1
           ("queryCompileAndLoad", string_to_unit),
a1499 1
           ("queryCompileAndLoad", string_to_unit),
d1543 1
a1543 1
	      (fn _ => ()) : string -> unit,
d1545 3
a1547 3
	      (fn _ => ()) : string -> unit,
	     a_queryCompileAndLoad =
	      (fn _ => ()) : string -> unit,
d1587 1
a1587 1
	      (fn _ => ()) : string -> unit,
d1589 3
a1591 3
	      (fn _ => ()) : string -> unit,
	     a_queryCompileAndLoad =
	      (fn _ => ()) : string -> unit,
@


1.141
log
@Fixing problem with .mlworks_preferences and command line arguments\
@
text
@d16 3
d638 1
a638 1
    fun print_dynamic (shell_data,dyn : MLWorks.Internal.Dynamic.Dynamic) =
d651 1
a651 1
    fun print_type (shell_data, tyrep : MLWorks.Internal.Dynamic.Type) =
d788 1
a788 1
          schemify (FUNTYPE (Types.dynamic_type, Types.type_type))
d794 1
a794 1
          schemify (FUNTYPE (Types.type_type, Types.string_type))
d821 2
a822 1
	  FUNTYPE (make_pair (Types.type_type, Types.type_type), Types.exn_type)
d957 1
a957 1
            (castit result) : MLWorks.Internal.Dynamic.Dynamic
d984 1
a984 1
          (fn (d: MLWorks.Internal.Dynamic.Dynamic) =>
d1416 1
a1416 1
	     TYSTR (ETA_TYFUN Types.type_tyname, empty_valenv))],
d1439 1
a1439 1
          {a_eval = shell_eval_fn : string -> MLWorks.Internal.Dynamic.Dynamic,
d1444 1
a1444 1
	     inspect_dyn_fn : MLWorks.Internal.Dynamic.Dynamic -> unit,
d1446 1
a1446 1
	     shell_dyn_print_val : MLWorks.Internal.Dynamic.Dynamic -> string,
d1448 1
a1448 1
	     shell_dyn_print_type : MLWorks.Internal.Dynamic.Type -> string}
@


1.140
log
@Adding reading preferences file
@
text
@d16 3
d2144 4
a2150 1
              val _ = set_preferences shell_data
@


1.139
log
@Converted to new capitalisation scheme (sigh).
@
text
@d16 3
d479 1
d508 1
d2036 33
d2144 1
@


1.138
log
@Moved Shell.Inspector.inspect to Shell.Dynamic.inspect.
@
text
@d16 3
d760 1
a760 1
	  Types.make_tyname (1, true, "Option", MLWorks.Option.NONE)
d976 8
a983 8
          [("show_fn_details",  mk_option Types.bool_type),
           ("show_exn_details",  mk_option Types.bool_type),
           ("float_precision",  mk_option Types.int_type),
           ("maximum_seq_size",  mk_option Types.int_type),
           ("maximum_string_size",  mk_option Types.int_type),
           ("maximum_ref_depth",  mk_option Types.int_type),
           ("maximum_str_depth",  mk_option Types.int_type),
           ("maximum_depth",  mk_option Types.int_type)
d1112 1
a1112 1
          {maximum_depth =
d1114 1
a1114 1
           maximum_ref_depth =
d1116 1
a1116 1
           maximum_str_depth =
d1118 1
a1118 1
           maximum_seq_size =
d1120 1
a1120 1
           maximum_string_size =
d1122 1
a1122 1
           float_precision =
d1124 1
a1124 1
           show_fn_details =
d1126 1
a1126 1
           show_exn_details =
d1131 7
a1137 7
	  [("show_absyn", mk_option Types.bool_type),
	   ("show_lambda", mk_option Types.bool_type),
	   ("show_opt_lambda", mk_option Types.bool_type),
	   ("show_environ", mk_option Types.bool_type),
	   ("show_mir", mk_option Types.bool_type),
	   ("show_opt_mir", mk_option Types.bool_type),
	   ("show_mach", mk_option Types.bool_type)]
d1141 3
a1143 3
	  {show_absyn = (make_tool_option_rep #show_absyn) : bool option_rep,
	   show_lambda = (make_tool_option_rep #show_lambda) : bool option_rep,
	   show_opt_lambda =
d1145 1
a1145 1
	   show_environ =
d1147 2
a1148 2
	   show_mir = (make_tool_option_rep #show_mir) : bool option_rep,
	   show_opt_mir =
d1150 1
a1150 1
	   show_mach = (make_tool_option_rep #show_mach) : bool option_rep
d1155 9
a1163 9
	   ("xterm_editor_command", mk_option Types.string_type),
	   ("x_editor_command", mk_option Types.string_type),
	   ("maximum_history_size", mk_option Types.int_type),
	   ("maximum_errors", mk_option Types.int_type),
	   ("use_completion_menu", mk_option Types.bool_type),
	   ("automatic_output_window", mk_option Types.bool_type),
	   ("use_debugger",  mk_option Types.bool_type),
	   ("use_window_debugger",  mk_option Types.bool_type),
	   ("use_error_browser",  mk_option Types.bool_type)]
d1168 1
a1168 1
           xterm_editor_command =
d1170 1
a1170 1
           x_editor_command =
d1172 1
a1172 1
           maximum_history_size = 
d1174 1
a1174 1
           maximum_errors = 
d1176 1
a1176 1
           use_completion_menu = 
d1178 1
a1178 1
	   automatic_output_window =
d1180 1
a1180 1
           use_debugger =
d1182 1
a1182 1
           use_window_debugger =
d1184 1
a1184 1
           use_error_browser =
d1189 3
a1191 3
          [("generate_trace_profile_code", mk_option Types.bool_type),
	   ("generate_debug_info", mk_option Types.bool_type),
	   ("generate_variable_debug_info", mk_option Types.bool_type),
d1195 5
a1199 5
	   ("interrupt_tight_loops", mk_option Types.bool_type),
	   ("optimize_handlers", mk_option Types.bool_type),
	   ("optimize_leaf_fns", mk_option Types.bool_type),
	   ("optimize_tail_calls", mk_option Types.bool_type),
	   ("optimize_self_tail_calls", mk_option Types.bool_type)
d1204 1
a1204 1
          {generate_trace_profile_code = 
d1207 1
a1207 1
           generate_debug_info = 
d1209 1
a1209 1
           generate_variable_debug_info =
d1216 1
a1216 1
	   interrupt_tight_loops =
d1219 1
a1219 1
           optimize_handlers = (make_context_option_rep #optimize_handlers) :
d1221 1
a1221 1
           optimize_leaf_fns = (make_context_option_rep #optimize_leaf_fns) :
d1223 1
a1223 1
           optimize_tail_calls = (make_context_option_rep #optimize_tail_calls):
d1225 1
a1225 1
           optimize_self_tail_calls =
d1231 2
a1232 2
          [("require_keyword", mk_option Types.bool_type),
           ("type_dynamic", mk_option Types.bool_type),
d1234 1
a1234 1
           ("topdec_semicolons", mk_option Types.bool_type)
d1239 1
a1239 1
          {require_keyword =
d1241 1
a1241 1
           type_dynamic =
d1245 1
a1245 1
	   topdec_semicolons =
d1252 7
a1258 7
	  [("string_inequalities", mk_option Types.bool_type),
	   ("infixr_assoc", mk_option Types.bool_type),
	   ("op_optional", mk_option Types.bool_type),
	   ("nj_signatures", mk_option Types.bool_type),
	   ("weak_tyvars", mk_option Types.bool_type),
	   ("fixity_in_signatures", mk_option Types.bool_type),
	   ("fixity_in_open", mk_option Types.bool_type)
d1266 1
a1266 1
	  {string_inequalities =
d1268 1
a1268 1
	   infixr_assoc =
d1270 1
a1270 1
	   op_optional =
d1272 1
a1272 1
	   nj_signatures =
d1274 1
a1274 1
	   weak_tyvars =
d1276 1
a1276 1
	   fixity_in_signatures =
d1278 1
a1278 1
	   fixity_in_open =
d1286 1
a1286 1
	  [("new_jersey", unit_to_unit),
d1290 1
a1290 1
	   ("variable_info", mk_option Types.bool_type),
d1375 1
a1375 1
	  {new_jersey = select_new_jersey : unit -> unit,
d1379 1
a1379 1
	   variable_info = (is_var_info, select_var_info) : bool option_rep,
d1384 4
a1387 4
          ([("add_inspect_method",fun_to_unit),
            ("delete_inspect_method",fun_to_unit),
            ("delete_all_inspect_methods",unit_to_unit),
            ("inspect_it",unit_to_unit)],
d1393 4
a1396 4
           a_inspect_it = inspect_it_fn : unit -> unit,
           a_add_inspect_method = add_inspect_method : ('a -> 'b) -> unit,
           a_delete_inspect_method = delete_inspect_method : ('a -> 'b) -> unit,
           a_delete_all_inspect_methods =
d1401 1
a1401 1
	   [("Dynamic", 
d1403 1
a1403 1
	    ("Type", 
d1406 1
a1406 1
	    ("get_type", dynamic_to_type),
d1408 2
a1409 2
            ("print_value",dynamic_to_string),
            ("print_type",type_to_string)],
d1430 1
a1430 1
	   a_get_type = MLWorks.Internal.Value.cast (fn (a,b) => b), 
d1433 1
a1433 1
           a_print_value =
d1435 1
a1435 1
           a_print_type =
d1443 3
a1445 3
           ("trace_full",trace_full_type),
	   ("untrace_all",unit_to_unit),
	   ("unbreak_all",unit_to_unit)]
d1455 1
a1455 1
           a_trace_full =
d1457 2
a1458 2
           a_untrace_all = Trace.untrace_all : unit -> unit,
           a_unbreak_all = Trace.unbreak_all : unit -> unit}
d1462 11
a1472 11
           ("query_compile", string_to_unit),
	   ("touch_source", string_to_unit),
           ("load_source", string_to_unit),
           ("query_load_source", string_to_unit),
           ("touch_loaded", string_to_unit),
           ("touch_all_loaded", unit_to_unit),
           ("load_object", string_to_unit),
           ("query_load_object", string_to_unit),
           ("compile_and_load", string_to_unit),
           ("query_compile_and_load", string_to_unit),
           ("load_depend", string_to_unit)]
d1476 4
a1479 4
           ("query_compile", string_to_unit),
	   ("touch_source", string_to_unit),
           ("load_source", string_to_unit),
           ("query_load_source", string_to_unit),
d1481 7
a1487 7
           ("touch_loaded", string_to_unit),
           ("touch_all_loaded", unit_to_unit),
           ("load_object", string_to_unit),
           ("query_load_object", string_to_unit),
           ("compile_and_load", string_to_unit),
           ("query_compile_and_load", string_to_unit),
           ("load_depend", string_to_unit)]
d1503 1
a1503 1
	     a_query_compile =
d1507 1
a1507 1
	     a_touch_source =
d1509 1
a1509 1
             a_load_source =
d1513 1
a1513 1
	     a_query_load_source =
d1517 1
a1517 1
             a_touch_loaded =
d1521 1
a1521 1
             a_touch_all_loaded =
d1525 1
a1525 1
	     a_load_object =
d1529 1
a1529 1
	     a_query_load_object =
d1531 1
a1531 1
	     a_compile_and_load =
d1533 1
a1533 1
	     a_query_compile_and_load =
d1535 1
a1535 1
	     a_load_depend =
d1544 1
a1544 1
	     a_query_compile =
d1548 1
a1548 1
	     a_touch_source =
d1550 1
a1550 1
             a_load_source =
d1554 1
a1554 1
	     a_query_load_source =
d1561 1
a1561 1
             a_touch_loaded =
d1565 1
a1565 1
             a_touch_all_loaded =
d1569 1
a1569 1
	     a_load_object =
d1573 1
a1573 1
	     a_query_load =
d1575 1
a1575 1
	     a_compile_and_load =
d1577 1
a1577 1
	     a_query_compile_and_load =
d1579 1
a1579 1
	     a_load_depend_module =
d1583 5
a1587 5
          ([("set_source_path", string_list_to_unit),
            ("source_path", unit_to_string_list),
            ("set_object_path", string_to_unit),
            ("object_path", unit_to_string),
            ("set_pervasive", string_to_unit),
d1618 3
a1620 3
	     {a_set_source_path = set_source_path : string list -> unit,
	      a_source_path = get_source_path : unit -> string list,
	      a_set_pervasive = set_pervasive_dir : string -> unit,
d1622 2
a1623 2
	      a_set_object_path = set_object_path : string -> unit,
	      a_get_object_path = get_object_path : unit -> string,
d1643 5
a1647 3
        val editor_structure = mk_exn_structure ([("edit_file", string_to_unit),
                                                  ("edit_definition",fun_to_unit)],
                                                 [(edit_exn_label,string_to_exn)])
d1650 3
a1652 7
          {
           a_edit_file = edit_file : string -> unit,
           a_edit_definition = edit_definition : ('a -> 'b) -> unit
,
           a_EditError = edit_exn : internal_exn_rep
           }

d1671 1
a1671 1
		     ("info_all", unit_to_string_list),
d1673 1
a1673 1
                     ("step_through", fun_to_fun),
d1675 1
a1675 1
		     ("clear_all", unit_to_unit)])
d1713 1
a1713 1
             {a_clear_all = ActionQueue.add_clear_debug_all : unit -> unit,
d1716 1
a1716 1
              a_info_all = debug_info_all : unit -> string list,
d1718 1
a1718 1
              a_step_through = Trace.step_through : ('a -> 'b) -> ('a -> 'b)}
d1732 1
a1732 1
		     [("Option",
d1749 1
a1749 1
              c_value_printer = value_printer_record,
d1865 4
a1868 4
		       ("profile_full", profile_full_type),
		       ("profile_space",profiler_type),
		       ("profile_time",profiler_type),
		       ("profile_tool",profile_tool_type)])))
d1872 5
a1876 4
	     a_profile_full = profile_full : Profile.options -> ('a -> 'b) -> 'a -> 'b,
	     a_profile_space = space_profile : ('a -> 'b) -> 'a -> 'b,
	     a_profile_time = time_profile : ('a -> 'b) -> 'a -> 'b,
	     a_profile_tool = profile_tool : Profile.profile -> unit}
d1993 2
a1994 2
		       ("time_iterations", time_iterations_type),
		       ("print_timing", print_timing_type)])))
d1999 4
a2002 2
	     a_time_iterations = time_iterations :  int -> ('a -> 'b) -> 'a -> MLWorks.Time.Elapsed.T,
	     a_print_timing = print_timing : {stream: MLWorks.IO.outstream,
a2004 1

d2218 1
a2218 1
		  [("set_value_polymorphism",bool_to_unit),
d2221 2
a2222 2
		   ("save_image", string_to_unit),
		   ("exec_save", string_to_unit),
d2234 3
a2236 2
		   a_exec_save = exec_save_fn : string -> unit,
                   a_set_value_polymorphism = set_value_polymorphism : bool -> unit,
@


1.137
log
@Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
some functionality to the Shell structure.
@
text
@d16 4
a1383 1
            ("inspect",dynamic_to_unit),
a1389 2
           a_inspect =
	     inspect_dyn_fn : MLWorks.Internal.Dynamic.Dynamic -> unit,
d1404 1
d1428 2
@


1.136
log
@Export becomes Deliver.
@
text
@d16 3
d620 1
a620 1
    fun print_dynamic (shell_data,dyn : MLWorks.Dynamic.Dynamic) =
d633 1
a633 1
    fun print_type (shell_data, tyrep : MLWorks.Dynamic.Type) =
d769 3
d791 6
a796 1
	  schemify(FUNTYPE(make_pair(Types.string_type, FUNTYPE(Types.empty_rectype, Types.empty_rectype)), Types.empty_rectype))
d798 2
a799 1
        val string_to_exn_type = FUNTYPE (Types.string_type, Types.exn_type)
d802 4
d938 1
a938 1
            (castit result) : MLWorks.Dynamic.Dynamic
d965 2
a966 1
          (fn (d: MLWorks.Dynamic.Dynamic) => Inspector.inspect_value (castit d,!shell_data_ref))
d1387 2
a1388 1
           a_inspect = inspect_dyn_fn : MLWorks.Dynamic.Dynamic -> unit,
d1392 2
a1393 1
           a_delete_all_inspect_methods = delete_all_inspect_methods : unit -> unit}
d1395 12
d1408 11
a1418 5
        val dynamic_structure = mk_exn_structure
          ([("eval", string_to_dynamic),
            ("print_val",dynamic_to_string),
            ("print_type",type_to_string)],
           [(eval_exn_label, string_to_exn)])
d1422 1
a1422 1
          {a_eval = shell_eval_fn : string -> MLWorks.Dynamic.Dynamic,
d1424 6
a1429 2
           a_print_val = shell_dyn_print_val : MLWorks.Dynamic.Dynamic -> string,
           a_print_type = shell_dyn_print_type : MLWorks.Dynamic.Type -> string}
d2016 1
a2016 6
	  let
	    val break_hook = !MLWorks.Debugger.break_hook
	    val _ = MLWorks.Debugger.break_hook := (fn _ => ())(*castit []*)
	    val generalises = !MLWorks.Dynamic.generalises_ref
	    val _ = MLWorks.Dynamic.generalises_ref := (fn _ => false)(*castit []*)
	    val _ = MLWorks.deliver(filename, func)
d2018 5
a2022 11
		(MLWorks.Debugger.break_hook := break_hook;
		 MLWorks.Dynamic.generalises_ref := generalises;
		 Info.error'
		 (error_info)
		 (Info.FATAL,
		  Info.Location.FILE (ShellTypes.get_current_toplevel_name ()),
		  msg))
	  in
	    MLWorks.Debugger.break_hook := break_hook;
	    MLWorks.Dynamic.generalises_ref := generalises
	  end
@


1.135
log
@Removed the Shell.TopEnv structure.
@
text
@d16 3
d784 1
a784 1
	val export_fn_type =
d1971 1
a1971 1
	type exportFnType = string * (unit -> unit) -> unit
d1973 1
a1973 1
	val export_fn : exportFnType =
d1980 1
a1980 1
	    val _ = MLWorks.fn_save(filename, func)
d2186 1
a2186 1
		   ("exportFn", export_fn_type)
d2196 1
a2197 1
		   a_exportFn = export_fn : exportFnType,
@


1.134
log
@Ensure exportFn restores break_hook and generalises_ref
even when it succeeds
@
text
@d16 4
a580 7

    (* Show environment functions *)

    fun show_signatures context =
      map
      IdentPrint.printSigId
      (NewMap.domain_ordered (Incremental.signatures context))
a581 53
    fun show_functors context =
      let
	val funmap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_,_, BasisTypes.FUNENV map, _, _) => map
      in
	map
        IdentPrint.printFunId
        (NewMap.domain_ordered funmap)
      end
    
    fun show_structures context =
      let
	val strmap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_,_, _, _, Datatypes.ENV(Datatypes.SE map, _, _)) =>
	      map
      in
	map
        IdentPrint.printStrId
        (NewMap.domain_ordered strmap)
      end
    
    fun show_types context =
      let
	val tymap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_,_, _, _, Datatypes.ENV(_, Datatypes.TE map, _)) =>
	      map
      in
	map
        IdentPrint.printTyCon
        (NewMap.domain_ordered tymap)
      end
    
    fun show_values p context =
      let
	val valmap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_,_, _, _,
			 Datatypes.ENV(_, _, Datatypes.VE(_, map))) =>
            map
            
	fun getsym (Ident.VAR s) = s
          |   getsym (Ident.CON s) = s
          |   getsym (Ident.EXCON s) = s
          |   getsym (Ident.TYCON' s) = s
      in
	map
        (Symbol.symbol_name o getsym)
        (Lists.filterp p (NewMap.domain_ordered valmap))
      end

a1354 43
        val topenv_structure = mk_structure
          [("signatures", show_type),
           ("functors", show_type),
           ("structures", show_type),
           ("types", show_type),
           ("exceptions", show_type),
           ("constructors", show_type),
           ("variables", show_type),
           ("values", show_type)
           ]

	val topenv_record =
	     castit
             {a_signatures =
              (fn () => show_signatures (get_context ())) : unit -> string list,
              a_functors =
              (fn () => show_functors (get_context ())) : unit -> string list,
              a_structures =
              (fn () => show_structures (get_context ())) : unit -> string list,
              a_types =
              (fn () => show_types (get_context ())) : unit -> string list,
              a_exceptions =
              (fn () =>
               show_values
               (fn (Ident.EXCON _) => true | _ => false)
               (get_context ())) : unit -> string list,
              a_constructors =
              (fn () =>
               show_values
               (fn (Ident.CON _) => true | _ => false)
               (get_context ())) : unit -> string list,
              a_variables =
              (fn () =>
               show_values
               (fn (Ident.VAR _) => true | _ => false)
               (get_context ())) : unit -> string list,
              a_values =
              (fn () =>
               show_values
               (fn _ => true)
               (get_context ())) : unit -> string list
              }

a2170 1
		   ("TopEnv", topenv_structure),
a2198 1
                   c_topenv = topenv_record,
@


1.133
log
@Fix breakpoint setting to use the correct types
Added type constraints to all values in structure records
for some consistency checking
@
text
@d16 5
d2076 9
d2086 2
a2087 9
	    MLWorks.fn_save(filename, func)
	    handle MLWorks.Save msg =>
	      (MLWorks.Debugger.break_hook := break_hook;
	       MLWorks.Dynamic.generalises_ref := generalises;
	       Info.error'
	       (error_info)
	       (Info.FATAL,
		Info.Location.FILE (ShellTypes.get_current_toplevel_name ()),
		msg))
@


1.132
log
@Revised names of compilation functions.
@
text
@d4 9
d16 3
d1010 2
d1460 1
a1460 1
          {a_InspectError = inspect_exn,
d1477 1
a1477 1
           a_EvalError = eval_exn,
d1490 2
d1494 4
a1497 4
          {a_breakpoint = Trace.break,
           a_trace = Trace.trace,
           a_unbreakpoint = Trace.unbreak,
           a_untrace = Trace.untrace,
d1667 1
a1667 1
              a_Path = path_exn}
d1695 1
a1695 1
           a_EditError = edit_exn
d1789 2
a1790 2
             {a_set = set_option,
	      a_get = get_option,
d1916 5
a1920 5
	    {a_profile = time_space_profile,
	     a_profile_full = profile_full,
	     a_profile_space = space_profile,
	     a_profile_time = time_profile,
	     a_profile_tool = profile_tool}
d1974 1
a1974 1
	  (* time has type ('a -> 'b) -> 'a -> elapsed *)
d1987 1
a1987 1
	  (* time_iterations has type int -> ('a -> 'b) -> 'a -> elapsed *)
d2042 5
a2046 3
	    {a_time = time,
	     a_time_iterations = time_iterations,
	     a_print_timing = print_timing}
@


1.131
log
@Removing Option in favour of MLWorks.Option
@
text
@d7 3
d1487 13
d1501 1
a1501 1
        val compile_structure = mk_structure
d1503 1
a1503 3
           ("compile_module", string_to_unit),
           ("check_compile", string_to_unit),
           ("check_compile_module", string_to_unit),
a1504 1
	   ("touch_source_module", string_to_unit),
d1506 2
a1507 4
           ("load_source_module", string_to_unit),
           ("check_load_source", string_to_unit),
           ("check_load_source_module", string_to_unit),
           ("save_module", string_to_unit),
a1508 1
           ("touch_loaded_module", string_to_unit),
d1510 2
a1511 4
           ("load", string_to_unit),
           ("load_module", string_to_unit),
           ("check_load", string_to_unit),
           ("check_load_module", string_to_unit),
d1513 2
a1514 5
           ("compile_and_load_module", string_to_unit),
           ("check_compile_and_load", string_to_unit),
           ("check_compile_and_load_module", string_to_unit),
           ("load_depend", string_to_unit),
           ("load_depend_module", string_to_unit)]
d1524 1
a1524 1
	val compile_record =
d1526 1
a1526 5
	    {a_compile_module =
              (fn filename =>
               ActionQueue.add_compile_module
		 (filename, error_info)) : string -> unit,
	     a_compile =
d1530 1
a1530 5
	     a_check_compile_module =
              (fn filename =>
               ActionQueue.add_check_compile_module
		 (filename, error_info)) : string -> unit,
	     a_check_compile =
a1533 2
	     a_touch_source_module =
	       touch_source_module: string -> unit,
d1540 38
a1577 1
             a_load_source_module =
d1581 1
a1581 5
	     a_check_load_source =
              (fn filename =>
               ActionQueue.add_check_load_source_file
		 (filename, error_info)) : string -> unit,
	     a_check_load_source_module =
d1585 1
a1585 1
	     a_save_module =
a1588 4
              (fn filename =>
		 ActionQueue.add_touch_loaded_file (filename, error_info))
		  : string -> unit,
             a_touch_loaded_module =
d1596 1
a1596 5
	     a_load =
              (fn filename =>
               ActionQueue.add_load_file
		 (filename, error_info)) : string -> unit,
	     a_load_module =
d1600 1
a1600 3
	     a_check_load =
	      (fn _ => ()) : string -> unit,
	     a_check_load_module =
d1604 1
a1604 7
	     a_compile_and_load_module =
	      (fn _ => ()) : string -> unit,
	     a_check_compile_and_load =
	      (fn _ => ()) : string -> unit,
	     a_check_compile_and_load_module =
	      (fn _ => ()) : string -> unit,
	     a_load_depend =
a1608 1

d2239 2
a2240 1
                 ([("Compile", compile_structure),
d2275 2
a2276 1
		   c_compile = compile_record,
@


1.130
log
@Revised previous log message.
@
text
@d7 3
a544 1
    structure Option = Datatypes.Option
d725 1
a725 1
        fun schemify ty = UNBOUND_SCHEME (ty,Option.ABSENT)
d783 1
a783 1
	  Types.make_tyname (1, true, "Option", Option.ABSENT)
d831 1
a831 1
	      Scheme.make_scheme([alpha,beta], (type_instance, Option.ABSENT))
d843 1
a843 1
              Scheme.make_scheme ([alpha,beta], (FUNTYPE (FUNTYPE (alpha,beta),FUNTYPE (alpha,beta)),Option.ABSENT))
d858 1
a858 1
                Option.ABSENT))
d917 1
a917 1
	     ref Option.ABSENT,
d1005 1
a1005 1
                                        Types.empty_rectype),Option.ABSENT))
d1016 1
a1016 1
            Scheme.make_scheme ([aty], (FUNTYPE(aty_option, aty),Option.ABSENT))
d1675 1
a1675 1
               ref Option.ABSENT,
d1740 1
a1740 1
               ref Option.ABSENT,
d1859 1
a1859 1
						   Option.ABSENT)),
d1861 1
a1861 1
						   Option.ABSENT)))
d1872 1
a1872 1
		ref Option.ABSENT,
d1957 1
a1957 1
						Option.ABSENT))
d1972 1
a1972 1
						Option.ABSENT))
d1992 1
a1992 1
						Option.ABSENT))
d1999 1
a1999 1
		ref Option.ABSENT,
d2211 1
a2211 1
                               Option.ABSENT),
@


1.129
log
@Changed name of Debug.status_all to Debug.status.info_all
@
text
@d7 3
@


1.128
log
@Reversing previous change.
@
text
@d7 3
d1684 1
a1685 1
		     ("status_all", unit_to_string_list),
d1717 1
a1717 1
        fun debug_status_all () =
d1729 1
a1730 1
              a_status_all = debug_status_all : unit -> string list,
@


1.127
log
@Changed the arguments of add_debug_info to use Incremental.debugging_options.
@
text
@d7 3
d2289 1
a2289 1
	    (Incremental.debugging_options, environment_debug_info,context)
@


1.126
log
@Corrected previous log message.
@
text
@d7 3
d2266 2
a2267 2
      (* Note that labels must be unique -- so a better mechanism is needed if we want two 
       exceptions called "Error" for example *)
d2285 2
a2286 1
	  Incremental.add_debug_info (Options.default_options, environment_debug_info,context)
@


1.125
log
@The type of the ShellUtils.Error exception has changed.
@
text
@d7 4
@


1.124
log
@Ensure saved images don't believe the X interface is already running
Modify the already running message not to refer to X
@
text
@d7 4
a429 1
require "../make/recompile";
a459 1
  structure Recompile : RECOMPILE
d477 1
a477 2
  sharing Recompile.Info =
	  ActionQueue.Info =
a480 1
	  Recompile.Options = 
d939 2
a940 1
        handle ShellUtils.Error (_,e,_) => env_error (eval_exn, Info.string_error e)
d1461 2
a1462 1
           a_trace_full = shell_dyn_trace_full : (string * ('c -> 'd) * ('e -> 'f) -> unit),
d1467 11
a1477 5
        val make_structure = mk_structure
          [("make_file", string_to_unit),
           ("make_module", string_to_unit),
           ("check_file", string_to_unit),
           ("check_module", string_to_unit),
d1479 17
a1495 5
           ("touch_file", string_to_unit),
           ("touch_module", string_to_unit),
           ("touch_all", unit_to_unit),
           ("load_file", string_to_unit),
           ("load_module", string_to_unit)]
d1497 5
a1501 1
	val make_record =
d1503 5
a1507 1
            {a_make_file =
d1509 1
a1509 1
               ActionQueue.add_make_file
d1511 17
a1527 1
             a_make_module =
d1529 1
a1529 1
               ActionQueue.add_make_module
d1531 1
a1531 1
	     a_check_file =
d1533 1
a1533 1
               ActionQueue.add_check_file
d1535 1
a1535 1
	     a_check_module =
d1537 1
a1537 1
               ActionQueue.add_check_module
d1542 13
a1554 1
	     a_load_file =
d1562 16
a1577 20
             a_touch_file =
              (fn filename =>
		 ActionQueue.add_touch_file (filename, error_info))
		  : string -> unit,
             a_touch_all =
              (fn () =>
		 ActionQueue.add_touch_all (error_info))
		  : unit -> unit,
             a_touch_module =
              (fn module_name =>
		 ActionQueue.add_touch_module (module_name, error_info))
		  : string -> unit}

        val compile_structure = mk_structure
          [("compile_file", string_to_unit),
           ("compile_module", string_to_unit),
           ("check_file", string_to_unit),
           ("check_module", string_to_unit),
	   ("touch_file", string_to_unit),
	   ("touch_module", string_to_unit)]
a1578 45
	fun touch_compile_module s =
	  ShellUtils.touch_compile_module
	    (s, ShellTypes.get_current_toplevel_name ())

	fun touch_compile_file s =
	  ShellUtils.touch_compile_file
	    (s, ShellTypes.get_current_toplevel_name ())

	val compile_record =
	  castit
            {a_compile_module =
              (fn module_name =>
               (Recompile.recompile_modules
                  error_info
                  (ShellTypes.get_current_options (!shell_data_ref))
                  [module_name])) : string -> unit,
             a_compile_file =
              (fn filename =>
               (Recompile.recompile_files
                  error_info
                  (ShellTypes.get_current_options (!shell_data_ref))
                  [filename])) : string -> unit,
             a_check_module =
              (fn module_name =>
	       (set_user_context_option #no_execute;
                Recompile.recompile_modules
                  error_info
                  (ShellTypes.get_current_options (!shell_data_ref))
                  [module_name]
                handle exn => (clear_user_context_option #no_execute;raise exn);
		clear_user_context_option #no_execute)) : string -> unit,
             a_check_file =
              (fn filename =>
	       (set_user_context_option #no_execute;
                Recompile.recompile_files
                  error_info
                  (ShellTypes.get_current_options (!shell_data_ref))
                  [filename]
                handle exn => (clear_user_context_option #no_execute;raise exn);
		clear_user_context_option #no_execute)) : string -> unit,
	     a_touch_module =
	       touch_compile_module: string -> unit,
	     a_touch_file =
	       touch_compile_file: string -> unit
             }
d2210 1
a2210 2
                 ([("Make", make_structure),
                   ("Compile", compile_structure),
a2244 1
		   c_make = make_record,
@


1.123
log
@Adding switch for value polymorphism.
@
text
@d7 3
d1748 1
a1748 1
	val x_message = "The X interface is already running\n"
d2132 23
d2159 1
a2159 3
	      val shell_data as
		ShellTypes.SHELL_DATA {user_options, ...} =
		!shell_data_ref
d2169 1
a2169 3
	      val shell_data as
		ShellTypes.SHELL_DATA {user_options, ...} =
		!shell_data_ref
@


1.122
log
@Allow source_path and pervasive_dir as arguments to incremental systems
Also add object_path for completeness
@
text
@d7 4
d790 3
d2172 2
d2195 2
a2196 1
		  [("exit", int_to_unit),
d2212 1
@


1.121
log
@Adding opt_handlers compiler option
@
text
@d7 3
d2043 9
d2084 7
d2092 1
d2108 1
a2108 5
		 (Io.set_source_path_from_env
		  (Info.Location.FILE "<Initialisation code>");
		  Io.set_pervasive_dir_from_env 
		  (Info.Location.FILE "<Initialisation code>");
		  if tty then
@


1.120
log
@Changing untrace_all function
@
text
@d7 3
d1171 1
d1194 2
d1305 2
a1306 1
	  (set_user_context_option #optimize_leaf_fns;
d1310 6
a1315 5
	|   select_optimizing false =
	  (clear_user_context_option #optimize_leaf_fns;
	   clear_user_context_option #optimize_tail_calls;
	   clear_user_context_option #optimize_self_tail_calls;
           update_user_options ())
d1343 1
@


1.119
log
@Add Shell.Profile.profile_tool.
@
text
@d7 3
d1429 2
a1430 1
	   ("untrace_all",unit_to_unit)]
d1439 3
a1441 1
           a_untrace_all = MLWorks.Internal.Trace.restore_all : unit -> unit}
@


1.118
log
@Add profiling functions.
@
text
@d7 3
d1763 3
a1768 1
	      val profiler = ShellTypes.get_current_profiler (!shell_data_ref)
d1770 1
a1770 1
	      (profiler p;
d1783 5
d1790 2
d1795 1
a1795 1
	  val (profile_type, profile_full_type) = 
d1810 5
d1829 1
a1829 1
		      [("profile",profile_type),
d1831 3
a1833 2
		       ("profile_space",profile_type),
		       ("profile_time",profile_type)])))
d1839 2
a1840 1
	     a_profile_time = time_profile}
@


1.117
log
@Add Shell.Profile.
@
text
@d7 3
d1721 1
a1721 1
	  val profile_manner =
d1730 27
a1756 1
	  val profile_options =
d1758 1
a1758 1
			     selector = fn _ => profile_manner}
d1771 3
a1773 1
	  val profile = profile_full profile_options
d1813 3
a1815 1
		       ("profile_full", profile_full_type)])))
d1818 4
a1821 2
	    {a_profile = profile,
	     a_profile_full = profile_full}
@


1.116
log
@Add exec_save to shell structure for saving executables
@
text
@d7 3
d505 1
d1717 73
d2097 2
a2098 1
		   ("Timer", timer_structure)
d2127 2
a2128 1
		   c_timer = timer_record
@


1.115
log
@Simplifying trace interface
@
text
@d7 3
d1870 11
a1880 17
	val save_fn : string -> unit =
          fn filename =>
          let
            val shell_data as
		  ShellTypes.SHELL_DATA {user_options, ...} =
	      !shell_data_ref

	    fun message s =
  	      (output(MLWorks.IO.messages, s);
   	       output(MLWorks.IO.messages, "\n"));

	    (* Argument parsing.  The second parameter is the current set of
	       arguments, which is modified as the list is traversed. *)
	    fun parse ([], r) = r
	    |   parse ("-tty" :: t, _) = parse (t, true)
	    |   parse ("-gui" :: t, _) = parse (t, false)
	    |   parse ("-full_menus" :: t, r) =
d1883 1
a1883 1
	    |   parse ("-short_menus" :: t, r) =
d1886 3
a1888 3
	    |   parse ("-debug_mode" :: t, r) =
	       (select_var_info true;
	        select_optimizing false;
d1890 3
a1892 3
	    |   parse ("-optimize_mode" :: t, r) =
	       (select_optimizing true;
	        select_var_info false;
d1894 1
a1894 1
	    |   parse ("-help" :: _, r) =
d1917 1
a1917 1
	    |   parse (s :: t, r) =
d1919 2
a1920 2
	         ("Invalid argument " ^ s ^ ".\n" ^
		  "Valid arguments are: -tty -gui -debug_mode -optimize_mode -help.");
d1924 62
a1985 40
            fun main arguments =
              let
                (* Parse arguments.  Default is motif. *)
                val tty = parse (arguments, false) orelse is_a_tty_image
		val _ = ActionQueue.read_dot_mlworks shell_data
		val _ = shell_data_ref := shell_data
                val mk_tty_listener = get_mk_tty_listener shell_data
                val listener_args = ShellTypes.get_listener_args shell_data
              in
                MLWorks.IO.with_standard_output
                  MLWorks.IO.terminal_out
                  (fn () =>
                   MLWorks.IO.with_standard_error
                   MLWorks.IO.terminal_out
                   (fn () =>
                    MLWorks.IO.with_standard_input
                    MLWorks.IO.terminal_in
                    (fn () =>
                     (Io.set_source_path_from_env
                      (Info.Location.FILE "<Initialisation code>");
                      Io.set_pervasive_dir_from_env 
                      (Info.Location.FILE "<Initialisation code>");
                      if tty then
                        (message (Version.version_string);
                         mk_tty_listener listener_args)
                      else
                        (xinterface_fn false;
                         0  (* exit status *))))))
              end
              handle Interrupt => 0  (* Handle eg. interrupts during starting interface *)
          in
            MLWorks.save (filename, fn () => main (MLWorks.OS.arguments ()))
            handle MLWorks.Save msg =>
              Info.error'
              (error_info)
              (Info.FATAL,
	       Info.Location.FILE (ShellTypes.get_current_toplevel_name ()),
	       msg);
              ()
          end
d2026 1
d2037 1
@


1.114
log
@Changed -motif to -gui in usage message, and added -{debug,optimize}_mode.
Also removed -full_menus and -short_menus from the user messages (the
arguments still work, but we don't advertise them).
@
text
@d7 5
a590 12
(* This is a nice idea, but interacts very badly with trace *)    
(*
    fun replace_dynamic (shell_data,dyns : (MLWorks.Dynamic.Dynamic * MLWorks.Dynamic.Dynamic)) =
      let
        val user_options = ShellTypes.get_user_options shell_data
        fun context_fn ()  = ShellTypes.get_current_context shell_data
        val (f,n) = castit dyns
      in
        Trace.replace (f,n,user_options,context_fn,fn s => output(std_out,s^"\n"))
      end
*)

d594 1
a594 22
    local
      fun make_dynamic_fn h =
        fn (shell_data, f: 'a -> 'b) =>
        let
          val user_options = ShellTypes.get_user_options shell_data
          fun context_fn ()  = ShellTypes.get_current_context shell_data
          val (value,ty) = make_dynamic f
        in
          h ((value,ty),user_options,context_fn,do_trace_error)
        end
        handle MakeDynamic s => do_trace_error ("No debug information for " ^ s)
    in
      val trace_dynamic = make_dynamic_fn Trace.trace
      val breakpoint_dynamic = make_dynamic_fn Trace.breakpoint
        
    end

    fun untrace_dynamic (shell_data, f : 'a -> 'b) =
      Trace.untrace (make_dynamic f, do_trace_error)
      handle MakeDynamic s => do_trace_error ("No debug information for " ^ s)

    fun trace_full_dynamic (shell_data,(f1,f2,f3)) =
d596 1
a596 4
        val user_options = ShellTypes.get_user_options shell_data
        fun context_fn ()  = ShellTypes.get_current_context shell_data
        val valtys = (make_dynamic f1,
                      make_dynamic f2,
d599 1
a599 1
        Trace.trace_full (valtys,user_options,context_fn,do_trace_error)
d795 1
a795 1
          val fun3_to_unit =
a796 2
              val a = make_tyvar "'a"
              val b = make_tyvar "'b"
d803 2
a804 2
              ([a,b,c,d,e,f],
               (FUNTYPE (make_tuple [FUNTYPE (a,b),
a911 4
        fun shell_dyn_trace d = trace_dynamic (!shell_data_ref,d)
        fun shell_dyn_untrace d = untrace_dynamic (!shell_data_ref,d)
        fun shell_dyn_breakpoint d = breakpoint_dynamic (!shell_data_ref,d)

d1408 5
a1412 8
          [("breakpoint",fun_to_unit),
           ("trace",fun_to_unit),
           ("simple_breakpoint",string_to_unit),
           ("simple_trace",string_to_unit),
           ("simple_unbreakpoint",string_to_unit),
           ("simple_untrace",string_to_unit),
           ("untrace",fun_to_unit),
           ("trace_full",fun3_to_unit),
d1417 5
a1421 8
          {a_breakpoint = shell_dyn_breakpoint : ('a -> 'b) -> unit,
           a_simple_breakpoint = Trace.simple_break,
           a_simple_trace = Trace.simple_trace,
           a_simple_unbreakpoint = Trace.simple_unbreak,
           a_simple_untrace = Trace.simple_untrace,
           a_trace = shell_dyn_trace : ('a -> 'b) -> unit,
           a_untrace = shell_dyn_untrace : ('a -> 'b) -> unit,
           a_trace_full = shell_dyn_trace_full : (('a -> 'b) * ('c -> 'd) * ('e -> 'f) -> unit),
@


1.113
log
@Changed -motif command line argument to -gui.
@
text
@d7 3
d1947 1
d1954 1
d1966 1
a1966 1
		  "Valid arguments are: -tty -motif -full_menus -short_menus -help.");
@


1.112
log
@Added -debug_mode and -optimize_mode command line arguments.
@
text
@d7 3
d1922 1
a1922 1
	    |   parse ("-motif" :: t, _) = parse (t, false)
d1941 2
a1942 1
"   -motif  Start the motif interface of MLWorks directly.  This is the default.\n" ^
@


1.111
log
@Add exportFn to shell structure
@
text
@d7 3
d1926 8
d1946 4
@


1.110
log
@Adding Interrupt handler around start_x_interface
@
text
@d7 3
d789 3
d1872 6
a1877 7
              if get_x_running shell_data
                then
                  output (std_out, x_message)
                else
                  (get_mk_xinterface_fn shell_data)
                  (ShellTypes.get_listener_args shell_data)
                  has_controlling_tty
d1880 21
d2025 2
a2026 1
		   ("save_image", string_to_unit)
d2036 1
@


1.109
log
@Replaced redundant construction of built-in types.
@
text
@d7 3
d1932 16
a1947 13
                     MLWorks.IO.with_standard_input
                     MLWorks.IO.terminal_in
                       (fn () =>
		          (Io.set_source_path_from_env
			     (Info.Location.FILE "<Initialisation code>");
			   Io.set_pervasive_dir_from_env 
			     (Info.Location.FILE "<Initialisation code>");
                           if tty then
                             (message (Version.version_string);
                              mk_tty_listener listener_args)
                           else
                             (xinterface_fn false;
                              0  (* exit status *)))))
d1949 1
@


1.108
log
@Add parameter to make_shell_structure to indicate image type (ie tty or motif)
@
text
@d7 3
d889 1
a889 1
	fun mk_option t = schemify (CONSTYPE([CONSTYPE([], t)], option_tyname))
d953 8
a960 8
          [("show_fn_details",  mk_option Types.bool_tyname),
           ("show_exn_details",  mk_option Types.bool_tyname),
           ("float_precision",  mk_option Types.int_tyname),
           ("maximum_seq_size",  mk_option Types.int_tyname),
           ("maximum_string_size",  mk_option Types.int_tyname),
           ("maximum_ref_depth",  mk_option Types.int_tyname),
           ("maximum_str_depth",  mk_option Types.int_tyname),
           ("maximum_depth",  mk_option Types.int_tyname)
d1106 7
a1112 7
	  [("show_absyn", mk_option Types.bool_tyname),
	   ("show_lambda", mk_option Types.bool_tyname),
	   ("show_opt_lambda", mk_option Types.bool_tyname),
	   ("show_environ", mk_option Types.bool_tyname),
	   ("show_mir", mk_option Types.bool_tyname),
	   ("show_opt_mir", mk_option Types.bool_tyname),
	   ("show_mach", mk_option Types.bool_tyname)]
d1129 10
a1138 10
	  [("editor", mk_option Types.string_tyname),
	   ("xterm_editor_command", mk_option Types.string_tyname),
	   ("x_editor_command", mk_option Types.string_tyname),
	   ("maximum_history_size", mk_option Types.int_tyname),
	   ("maximum_errors", mk_option Types.int_tyname),
	   ("use_completion_menu", mk_option Types.bool_tyname),
	   ("automatic_output_window", mk_option Types.bool_tyname),
	   ("use_debugger",  mk_option Types.bool_tyname),
	   ("use_window_debugger",  mk_option Types.bool_tyname),
	   ("use_error_browser",  mk_option Types.bool_tyname)]
d1164 3
a1166 3
          [("generate_trace_profile_code", mk_option Types.bool_tyname),
	   ("generate_debug_info", mk_option Types.bool_tyname),
	   ("generate_variable_debug_info", mk_option Types.bool_tyname),
d1168 1
a1168 1
           ("generate_moduler", mk_option Types.bool_tyname),
d1170 4
a1173 4
	   ("interrupt_tight_loops", mk_option Types.bool_tyname),
	   ("optimize_leaf_fns", mk_option Types.bool_tyname),
	   ("optimize_tail_calls", mk_option Types.bool_tyname),
	   ("optimize_self_tail_calls", mk_option Types.bool_tyname)
d1203 4
a1206 4
          [("require_keyword", mk_option Types.bool_tyname),
           ("type_dynamic", mk_option Types.bool_tyname),
	   ("abstractions", mk_option Types.bool_tyname),
           ("topdec_semicolons", mk_option Types.bool_tyname)
d1224 7
a1230 7
	  [("string_inequalities", mk_option Types.bool_tyname),
	   ("infixr_assoc", mk_option Types.bool_tyname),
	   ("op_optional", mk_option Types.bool_tyname),
	   ("nj_signatures", mk_option Types.bool_tyname),
	   ("weak_tyvars", mk_option Types.bool_tyname),
	   ("fixity_in_signatures", mk_option Types.bool_tyname),
	   ("fixity_in_open", mk_option Types.bool_tyname)
d1232 1
a1232 1
	   ("default_overloads", mk_option Types.bool_tyname),
d1261 3
a1263 3
	   ("optimizing", mk_option Types.bool_tyname),
	   ("variable_info", mk_option Types.bool_tyname),
	   ("debugging", mk_option Types.bool_tyname)]
@


1.107
log
@Added float_precision option to ValuePrinter options.
@
text
@d7 3
d659 1
a659 1
    fun make_shell_structure (shell_data_ref, initial_context) =
d1917 1
a1917 1
                val tty = parse (arguments, false)  
@


1.106
log
@Context options were calling the wrong update functions.
@
text
@d7 3
d949 1
d1091 2
@


1.105
log
@Added variable info mode.
@
text
@d7 3
a995 8
        fun update_user_options () =
          let 
            val UserOptions.USER_TOOL_OPTIONS (_, ref update_fns) =
              ShellTypes.get_user_options (!shell_data_ref)
          in 
            Lists.iterate (fn f => f ()) update_fns
          end
          
d1017 9
@


1.104
log
@ShellUtils.edit_* functions no longer require a context argument.
Added new preferences to the Shell.Preferences structure.
@
text
@d7 4
d1246 1
d1304 4
a1307 3
	   (*
	   set_user_context_option #generate_variable_debug_info;
	   *)
d1309 3
a1314 1
          (* get_option_fun #generate_variable_debug_info () andalso *)
d1317 4
d1332 1
@


1.103
log
@Removed show_id_class and show_eq_info value printer options from interface.
@
text
@d7 3
d1116 3
a1118 1
	   ("use_window_debugger",  mk_option Types.bool_tyname)]
d1135 2
d1138 3
a1140 1
	     (make_preference_rep #window_debugger) : bool option_rep
d1581 2
a1582 2
            val preferences = ShellTypes.get_current_preferences (!shell_data_ref)
            val context = get_context ()
d1584 1
a1584 1
            ShellUtils.edit_object (f, context, preferences);
@


1.102
log
@Adding Shell.Make.touch_all
@
text
@d7 3
a935 2
           ("show_id_class",  mk_option Types.bool_tyname),
           ("show_eq_info",  mk_option Types.bool_tyname),
d1079 1
a1079 5
	     (make_tool_option_rep #show_exn_details) : bool option_rep,
           show_id_class =
	     (make_tool_option_rep #show_id_class) : bool option_rep,
           show_eq_info =
	     (make_tool_option_rep #show_eq_info) : bool option_rep
@


1.101
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d7 3
d1422 1
d1459 4
@


1.100
log
@Renaming nj_semicolons
@
text
@d7 3
d362 1
d364 1
d387 1
d390 1
d427 1
a427 1
  sharing type UserOptions.user_options =
d436 4
a439 1
	       ShellTypes.user_context
d965 2
a966 2
        fun get_option_fun f () =
	  let val UserOptions.USER_OPTIONS (user_options,_) =
d971 2
a972 2
	fun set_option_fun f v =
	  let val UserOptions.USER_OPTIONS (user_options,ref update_fns) =
d979 2
a980 2
	fun make_option_rep f =
	  (get_option_fun f, set_option_fun f)
d984 1
a984 1
            val UserOptions.USER_OPTIONS (user_options,ref update_fns) =
d990 25
a1014 3
	fun set_user_option f =
	     let val UserOptions.USER_OPTIONS (user_options,ref update_fns) =
		   ShellTypes.get_user_options (!shell_data_ref)
d1019 4
a1022 3
	fun clear_user_option f =
	     let val UserOptions.USER_OPTIONS (user_options,ref update_fns) =
		   ShellTypes.get_user_options (!shell_data_ref)
d1027 33
d1062 18
a1079 9
          {maximum_depth =  (make_option_rep #maximum_depth) : int option_rep,
           maximum_ref_depth = (make_option_rep #maximum_ref_depth) : int option_rep,
           maximum_str_depth = (make_option_rep #maximum_str_depth) : int option_rep,
           maximum_seq_size = (make_option_rep #maximum_seq_size) : int option_rep,
           maximum_string_size = (make_option_rep #maximum_string_size) : int option_rep,
           show_fn_details = (make_option_rep #show_fn_details) : bool option_rep,
           show_exn_details = (make_option_rep #show_exn_details) : bool option_rep,
           show_id_class = (make_option_rep #show_id_class) : bool option_rep,
           show_eq_info = (make_option_rep #show_eq_info) : bool option_rep
d1093 10
a1102 8
	  {
	   show_absyn = (make_option_rep #show_absyn) : bool option_rep,
	   show_lambda = (make_option_rep #show_lambda) : bool option_rep,
	   show_opt_lambda = (make_option_rep #show_opt_lambda) : bool option_rep,
	   show_environ = (make_option_rep #show_environ) : bool option_rep,
	   show_mir = (make_option_rep #show_mir) : bool option_rep,
	   show_opt_mir = (make_option_rep #show_opt_mir) : bool option_rep,
	   show_mach = (make_option_rep #show_mach) : bool option_rep
d1117 1
a1117 1
          {editor = (make_option_rep #editor) : string option_rep,
d1119 1
a1119 1
	     (make_option_rep #xterm_editor_command) : string option_rep,
d1121 1
a1121 1
	     (make_option_rep #x_editor_command) : string option_rep,
d1123 1
a1123 1
             (make_option_rep #history_length) : int option_rep,
d1125 1
a1125 1
             (make_option_rep #max_num_errors) : int option_rep,
d1127 1
a1127 1
             (make_option_rep #completion_menu) : bool option_rep,
d1129 1
a1129 1
	     (make_option_rep #auto_output_window) : bool option_rep,
d1131 1
a1131 1
	     (make_option_rep #window_debugger) : bool option_rep
d1150 2
a1151 1
           (make_option_rep #generate_interceptable_code) : bool option_rep,
d1153 4
a1156 3
           (make_option_rep #generate_debug_info) : bool option_rep,
           generate_variable_debug_info = 
           (make_option_rep #generate_variable_debug_info) : bool option_rep,
d1159 1
a1159 1
           (make_option_rep #generate_moduler) : bool option_rep,
d1162 9
a1170 4
	   (make_option_rep #generate_interruptable_code) : bool option_rep,
           optimize_leaf_fns = (make_option_rep #optimize_leaf_fns) : bool option_rep,
           optimize_tail_calls = (make_option_rep #optimize_tail_calls) : bool option_rep,
           optimize_self_tail_calls = (make_option_rep #optimize_self_tail_calls) : bool option_rep
d1182 8
a1189 4
          {require_keyword = (make_option_rep #require_keyword) : bool option_rep,
           type_dynamic = (make_option_rep #type_dynamic) : bool option_rep,
           abstractions = (make_option_rep #abstractions) : bool option_rep,
	   topdec_semicolons = (make_option_rep #topdec_semicolons) : bool option_rep
d1209 10
a1218 5
	  {string_inequalities = (make_option_rep #string_inequalities) : bool option_rep,
	   infixr_assoc = (make_option_rep #infixr_assoc) : bool option_rep,
	   op_optional = (make_option_rep #nj_op_in_datatype) : bool option_rep,
	   nj_signatures = (make_option_rep #nj_signatures) : bool option_rep,
	   weak_tyvars = (make_option_rep #weak_type_vars) : bool option_rep,
d1220 3
a1222 2
	     	(make_option_rep #fixity_specs) : bool option_rep,
	   fixity_in_open = (make_option_rep #open_fixity) : bool option_rep
d1224 2
a1225 1
	   default_overloads = (make_option_rep #default_overloads) : bool option_rep,
d1236 9
a1244 9
	  (clear_user_option #require_keyword;
	   set_user_option #topdec_semicolons;
	   clear_user_option #type_dynamic;
	   set_user_option #nj_op_in_datatype;
	   set_user_option #infixr_assoc;
	   set_user_option #nj_signatures;
	   set_user_option #weak_type_vars;
           set_user_option #abstractions;
	   set_user_option #string_inequalities;
d1248 9
a1256 9
	  (set_user_option #require_keyword;
	   set_user_option #topdec_semicolons;
	   set_user_option #type_dynamic;
	   clear_user_option #nj_op_in_datatype;
	   clear_user_option #infixr_assoc;
	   clear_user_option #nj_signatures;
	   clear_user_option #weak_type_vars;
           set_user_option #abstractions;
	   set_user_option #string_inequalities;
d1260 9
a1268 9
	  (clear_user_option #require_keyword;
	   clear_user_option #topdec_semicolons;
	   clear_user_option #type_dynamic;
	   clear_user_option #nj_op_in_datatype;
	   clear_user_option #infixr_assoc;
	   clear_user_option #nj_signatures;
	   clear_user_option #weak_type_vars;
           clear_user_option #abstractions;
	   clear_user_option #string_inequalities;
d1272 3
a1274 3
	  (set_user_option #optimize_leaf_fns;
	   set_user_option #optimize_tail_calls;
	   set_user_option #optimize_self_tail_calls;
d1277 3
a1279 3
	  (clear_user_option #optimize_leaf_fns;
	   clear_user_option #optimize_tail_calls;
	   clear_user_option #optimize_self_tail_calls;
d1283 3
a1285 3
	  (clear_user_option #generate_interceptable_code;
	   clear_user_option #generate_debug_info;
	   clear_user_option #generate_variable_debug_info;
d1288 2
a1289 2
	  (set_user_option #generate_interceptable_code;
	   set_user_option #generate_debug_info;
d1291 1
a1291 1
	   set_user_option #generate_variable_debug_info;
d1296 1
a1296 1
          get_option_fun #generate_debug_info () andalso
d1298 1
a1298 1
          get_option_fun #generate_interceptable_code ()
d1301 3
a1303 3
          get_option_fun #optimize_leaf_fns () andalso
          get_option_fun #optimize_tail_calls () andalso
          get_option_fun #optimize_self_tail_calls ()
d1492 1
a1492 1
	       (set_user_option #no_execute;
d1497 2
a1498 2
                handle exn => (clear_user_option #no_execute;raise exn);
		clear_user_option #no_execute)) : string -> unit,
d1501 1
a1501 1
	       (set_user_option #no_execute;
d1506 2
a1507 2
                handle exn => (clear_user_option #no_execute;raise exn);
		clear_user_option #no_execute)) : string -> unit,
d1846 1
a1846 1
	      (set_user_option #full_menus;
d1849 1
a1849 1
	      (clear_user_option #full_menus;
@


1.99
log
@Removed debug_polyvariables and step options
@
text
@d7 3
d1092 2
a1093 1
	   ("abstractions", mk_option Types.bool_tyname)
d1100 2
a1101 1
           abstractions = (make_option_rep #abstractions) : bool option_rep
d1113 1
a1113 1
	   ("fixity_in_open", mk_option Types.bool_tyname),
d1117 1
a1117 1
	   ("nj_topdecs", mk_option Types.bool_tyname)]
d1128 1
a1128 1
	   fixity_in_open = (make_option_rep #open_fixity) : bool option_rep,
d1131 1
a1131 2
	   *)
	   nj_topdecs = (make_option_rep #nj_semicolons) : bool option_rep}
d1142 1
a1142 1
	   set_user_option #nj_semicolons;
d1154 1
a1154 1
	   clear_user_option #nj_semicolons;
d1166 1
a1166 1
	   clear_user_option #nj_semicolons;
@


1.98
log
@add capability to set object_path
@
text
@d7 3
a1058 1
	   ("generate_polyvariable_debug_info", mk_option Types.bool_tyname),
a1075 2
           generate_polyvariable_debug_info = 
           (make_option_rep #generate_polyvariable_debug_info) : bool option_rep,
a1186 1
	   clear_user_option #generate_polyvariable_debug_info;
a1192 1
	   set_user_option #generate_polyvariable_debug_info;
@


1.97
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d7 3
d1420 2
d1434 7
d1457 2
@


1.96
log
@Removed stepper option, commented out poly_variable and moduler options.
Also commented out default_overloads option.
@
text
@d7 4
a387 1
          ShellTypes.Info =
d402 2
a403 2
  sharing type Incremental.options = ShellTypes.IncrementalOptions
  sharing type DebuggerUtilities.Debugger_Types.information = ValuePrinter.DebugInformation =
@


1.95
log
@Expansion of home dirs moved from FileSys to Getenv.
Better error handling.
filesys moved from utils to initbasis.
@
text
@d7 5
d1049 1
a1050 2
           ("generate_stepper", mk_option Types.bool_tyname),
           ("generate_stepper_specific", mk_option Types.string_tyname),
d1052 1
d1067 1
a1069 4
           generate_stepper = 
           (make_option_rep #generate_stepper) : bool option_rep,
           generate_stepper_specific = 
           (make_option_rep #generate_stepper_specific) : string option_rep,
d1072 1
d1103 1
d1105 1
d1118 1
d1120 1
@


1.94
log
@Changed most of the functions with dynamic arguments to look up type
information in the debug information
First version of new step and breakpoint stuff
@
text
@d7 5
d321 2
a322 2
require "../utils/filesys";
require "../utils/path";
d349 1
a349 1
  structure Path : PATH
d413 1
d839 4
d845 1
d850 1
d1358 8
d1399 1
a1399 1
	       ShellUtils.touch_compile_module: string -> unit,
d1401 1
a1401 1
	       ShellUtils.touch_compile_file: string -> unit
d1404 6
a1409 11
	val path_structure = mk_structure
          [("set_source_path", string_list_to_unit),
           ("source_path", unit_to_string_list),
           ("set_pervasive", string_to_unit),
           ("pervasive", unit_to_string)]

	fun parse_directory s =
	  Path.mkAbsolute (FileSys.expand_path s, FileSys.getdir ())
	  (*
          FileSys.expand_path (Path.mkAbsolute (s, FileSys.getdir ()))
	  *)
d1412 2
a1413 1
	  Io.set_source_path (map parse_directory l)
d1415 1
a1415 6
            FileSys.BadHomeName s =>
              Info.error'
                Info.default_options
                (Info.FATAL, Info.Location.UNKNOWN,
                   "Problem expanding source path - " ^
                   "can't find home directory for " ^ s)
d1420 3
a1422 1
	  Io.set_pervasive_dir (parse_directory s)
d1424 1
a1424 6
            FileSys.BadHomeName s =>
              Info.error'
                Info.default_options
                (Info.FATAL, Info.Location.UNKNOWN,
                   "Problem expanding pervasive directory - " ^
                   "can't find home directory for " ^ s)
d1434 2
a1435 1
	      a_pervasive = get_pervasive_dir : unit -> string}
a1441 1
                                 
d1768 4
a1771 2
		          (Io.set_source_path_from_env ();
			   Io.set_pervasive_dir_from_env ();
@


1.93
log
@Change FILESYS to FILE_SYS
@
text
@d7 3
d328 1
a328 1
require "../debugger/debugger_types";
d353 1
a353 1
  structure Debugger_Types : DEBUGGER_TYPES
d390 1
a390 1
  sharing type Debugger_Types.information = ValuePrinter.DebugInformation =
d394 1
a394 1
               Debugger_Types.Type
d412 1
d433 1
a433 20
    fun is_a_substring(a,b) =
      if size a > size b
        then 
          false
      else
        let
          val length_a = size a
          val maximum_index = size b - length_a
          fun search x =
            if x < 0
              then
                false
            else
              if String.substring(b,x,length_a) = a
                then
                  true
              else search(x-1)
        in
          search maximum_index
        end
a434 5
    exception NotImplemented
        
    fun not_implemented () =
      raise NotImplemented
 
d493 20
d529 2
a530 2
      fun make_dynamic_fn f =
        fn (shell_data,dyn : MLWorks.Dynamic.Dynamic) =>
d534 1
a534 1
          val (value,ty) = castit dyn
d536 1
a536 1
          f ((value,ty),user_options,context_fn,do_trace_error)
d538 1
d542 1
d545 3
a547 2
    fun untrace_dynamic (dyn : MLWorks.Dynamic.Dynamic) =
      Trace.untrace (castit dyn,do_trace_error)
d549 1
a549 4
    fun trace_full_dynamic (shell_data,
                            dynamics : (MLWorks.Dynamic.Dynamic *
                                        MLWorks.Dynamic.Dynamic *
                                        MLWorks.Dynamic.Dynamic)) =
d553 3
a555 1
        val valtys = castit dynamics
d559 1
d636 2
a685 8
        val dynamic3 =
	  make_tuple [Types.dynamic_type,
		      Types.dynamic_type,
		      Types.dynamic_type]

        val dynamic3_to_unit =
          FUNTYPE (dynamic3,Types.empty_rectype)

d696 4
a699 1
	val option_type = CONSTYPE ([], option_tyname)
a700 5
        val consumer_type = 
          FUNTYPE(make_pair(Types.string_type,
                            FUNTYPE(Types.string_type, Types.empty_rectype)),
                  Types.string_type)
          
d702 1
a702 2
          FUNTYPE (Types.empty_rectype,
                   CONSTYPE([Types.string_type], Types.list_tyname))
d705 1
a705 1
          FUNTYPE (Types.string_type, Types.dynamic_type)
d708 1
a708 1
          FUNTYPE (Types.dynamic_type, Types.string_type)
d711 1
a711 1
          FUNTYPE (Types.dynamic_type, Types.empty_rectype)
d714 1
a714 1
          FUNTYPE (Types.type_type, Types.string_type)
d717 1
a717 1
          FUNTYPE (Types.empty_rectype, Types.empty_rectype)
d720 1
a720 1
          FUNTYPE (Types.int_type, Types.empty_rectype)
d723 1
a723 1
          FUNTYPE (Types.string_type, Types.empty_rectype)
d725 2
a726 2
        val string_to_exn = 
          FUNTYPE (Types.string_type, Types.exn_type)
d740 27
a766 3
	  val alpha_to_beta_to_bool = make_alpha_beta_to_type Types.bool_type
	  val alpha_to_beta_to_string = make_alpha_beta_to_type Types.string_type
	  val alpha_to_beta_to_unit = make_alpha_beta_to_type Types.empty_rectype
d770 2
a771 2
          FUNTYPE (CONSTYPE([Types.string_type], Types.list_tyname),
		   Types.empty_rectype)
d774 1
a774 1
          FUNTYPE (Types.empty_rectype, Types.string_type)
d777 2
a778 2
          FUNTYPE (Types.empty_rectype,
	  	   CONSTYPE([Types.string_type], Types.list_tyname))
a784 7
	fun mk_valenv_from_scheme l =
	  Lists.reducel
	  (fn (ve, (name, scheme)) =>
	   Valenv.add_to_ve
	   (Ident.VAR(find_symbol name), scheme, ve))
	  (empty_valenv, l)

d788 1
a788 1
            (fn (ve, (name, ty)) =>
d790 1
a790 3
             (Ident.VAR(find_symbol name),
              UNBOUND_SCHEME (ty,Option.ABSENT),
              ve))
d794 1
a794 1
            (fn (ve, (name, ty)) =>
d796 1
a796 3
             (Ident.EXCON(find_symbol name),
              UNBOUND_SCHEME (ty,Option.ABSENT),
              ve))
d831 1
a831 4
	  
	val unit_to_unit_fn = FUNTYPE(Types.empty_rectype, Types.empty_rectype)

	fun mk_option t = CONSTYPE([CONSTYPE([], t)], option_tyname)
d835 1
d839 1
d841 2
d864 1
d871 7
a877 5
        fun add_inspect_method (dyn : MLWorks.Dynamic.Dynamic) =
          InspectorValues.add_inspect_method (castit dyn)

        fun delete_inspect_method (dyn : MLWorks.Dynamic.Dynamic) =
          InspectorValues.delete_inspect_method (castit dyn)
d885 2
a886 2
        val inspect_dyn_fn  : MLWorks.Dynamic.Dynamic -> unit =
          (fn dyn => Inspector.inspect_value (castit dyn,!shell_data_ref))
d1105 3
a1107 3
	  [("new_jersey", unit_to_unit_fn),
	   ("harlequin", unit_to_unit_fn),
	   ("standard", unit_to_unit_fn),
d1234 8
a1241 6
        val inspector_structure = mk_structure
          [("add_inspect_method",dynamic_to_unit),
           ("delete_inspect_method",dynamic_to_unit),
           ("delete_all_inspect_methods",unit_to_unit),
           ("inspect",dynamic_to_unit),
           ("inspect_it",unit_to_unit)]
d1245 2
a1246 1
          {a_inspect = inspect_dyn_fn : MLWorks.Dynamic.Dynamic -> unit,
d1248 2
a1249 2
           a_add_inspect_method = add_inspect_method : MLWorks.Dynamic.Dynamic -> unit,
           a_delete_inspect_method = delete_inspect_method : MLWorks.Dynamic.Dynamic -> unit,
d1267 2
a1268 2
          [("breakpoint",dynamic_to_unit),
           ("trace",dynamic_to_unit),
d1273 2
a1274 2
           ("untrace",dynamic_to_unit),
           ("trace_full",dynamic3_to_unit),
d1279 1
a1279 1
          {a_breakpoint = shell_dyn_breakpoint : MLWorks.Dynamic.Dynamic -> unit,
d1284 4
a1287 6
           a_trace = shell_dyn_trace : MLWorks.Dynamic.Dynamic -> unit,
           a_untrace = untrace_dynamic : MLWorks.Dynamic.Dynamic -> unit,
           a_trace_full = shell_dyn_trace_full : (MLWorks.Dynamic.Dynamic *
                                                  MLWorks.Dynamic.Dynamic *
                                                  MLWorks.Dynamic.Dynamic) -> unit,
	   a_untrace_all = MLWorks.Internal.Trace.restore_all : unit -> unit}
d1435 1
a1435 1
	fun edit_definition (d : MLWorks.Dynamic.Dynamic) =
d1437 2
a1438 4
            val (f,t) : MLWorks.Internal.Value.T * Datatypes.Type = 
              castit d
            val preferences =
	      ShellTypes.get_current_preferences (!shell_data_ref)
d1447 1
a1447 1
                                                  ("edit_definition",dynamic_to_unit)],
d1453 1
a1453 1
           a_edit_definition = edit_definition : MLWorks.Dynamic.Dynamic -> unit
d1475 6
a1480 7
		    [("info", alpha_to_beta_to_string),
                     ("status", alpha_to_beta_to_bool),
		     ("status_all", UNBOUND_SCHEME (unit_to_string_list,
                                                             Option.ABSENT)),
		     ("clear", alpha_to_beta_to_unit),
		     ("clear_all", UNBOUND_SCHEME (unit_to_unit,
                                                          Option.ABSENT))])
d1522 2
a1523 1
              a_status_all = debug_status_all : unit -> string list}
d1539 4
a1542 3
		   mk_valenv_from_scheme 
	             [("set", set_option_type),
	              ("get", get_option_type)]))
d1844 1
a1844 1
        (* Now add debug info for the Environment errors exception *)
d1860 3
a1862 2
           [(edit_exn_label,string_to_exn),
            (eval_exn_label,string_to_exn)])
@


1.92
log
@Replacing Tyfun_id etc. with Stamp
@
text
@d7 3
d340 1
a340 1
  structure FileSys : FILESYS
@


1.91
log
@Added simple trace functions
@
text
@d7 3
d813 1
a813 1
	    (STRNAME (Strname_id.make_strname_id ()),
d1448 1
a1448 1
	       STRNAME (Strname_id.make_strname_id ()),
d1513 1
a1513 1
          STR (STRNAME (Strname_id.make_strname_id ()),
d1650 1
a1650 1
		STRNAME (Strname_id.make_strname_id ()),
@


1.90
log
@Removed InterPrint, Crash and TopLevel parameters.
@
text
@d7 3
a370 1
          Debugger_Types.Options =
a377 1
          Debugger_Types.NewMap =
d522 14
a535 8
    fun trace_dynamic (shell_data,dyn : MLWorks.Dynamic.Dynamic) =
      let
        val user_options = ShellTypes.get_user_options shell_data
        fun context_fn ()  = ShellTypes.get_current_context shell_data
        val (value,ty) = castit dyn
      in
        Trace.trace ((value,ty),user_options,context_fn,do_trace_error)
      end
d850 2
d1247 6
a1252 1
          [("trace",dynamic_to_unit),
d1259 6
a1264 1
          {a_trace = shell_dyn_trace : MLWorks.Dynamic.Dynamic -> unit,
d1478 1
a1478 2
            val Debugger_Types.INFO debug_info =
	          Incremental.debug_info (get_context ())
d1481 3
a1483 1
	    NewMap.exists (fn (from, _) => from = name) debug_info
d1832 13
a1844 19
          let 
            val Debugger_Types.INFO emptymap = Debugger_Types.empty_information
            val info_map = 
              Lists.reducel
              (fn (map,(label,exn_type)) =>
               (NewMap.define (map,
                               make_exn_tag label,
                               Debugger_Types.FUNINFO
                               {ty=exn_type,
                                is_leaf=true,
                                annotations=[],
                                runtime_env=Debugger_Types.RuntimeEnv.EMPTY, 
                                is_exn=true})))
              (emptymap,
               [(edit_exn_label,string_to_exn),
                (eval_exn_label,string_to_exn)])
          in
            Debugger_Types.INFO info_map
          end
@


1.89
log
@Added function for printing debug annotations
This is for internal use only really.
@
text
@d7 4
a303 1
require "../utils/crash";
a313 1
require "../main/toplevel";
a324 1
require "interprint";
a330 2
  structure Crash : CRASH
  structure InterPrint : INTERPRINT
a344 1
  structure TopLevel : TOPLEVEL
a361 1
    	  TopLevel.Info =
d365 1
a365 2
  sharing TopLevel.Options =
	  UserOptions.Options =
a386 1
	       TopLevel.TypeBasis =
@


1.88
log
@Replaced FileName parameter with FileSys and Path.
@
text
@d7 3
d729 1
a729 2
	in
	  val alpha_to_beta_to_bool =
d732 1
a732 1
	        FUNTYPE (FUNTYPE (alpha,beta), Types.bool_type)
d736 5
a740 8
          
	  val alpha_to_beta_to_unit =
	    let
	      val type_instance =
	        FUNTYPE (FUNTYPE (alpha,beta), Types.empty_rectype)
	    in
	      Scheme.make_scheme([alpha,beta], (type_instance, Option.ABSENT))
	    end
d1445 2
a1446 1
		    [("status", alpha_to_beta_to_bool),
d1471 8
d1481 1
a1481 2
            val Debugger_Types.INFO debug_info =
	      Incremental.debug_info (get_context ())
d1483 1
a1483 1
	    NewMap.domain_ordered debug_info
d1485 1
a1485 1
    
d1490 1
d1824 6
a1829 2
                               ((exn_type,true,[]),
                                Debugger_Types.RuntimeEnv.EMPTY, true))))
@


1.87
log
@Changing uses of cast
@
text
@d7 3
d298 2
a299 1
require "../utils/filename";
d329 2
a330 1
  structure FileName : FILENAME
a396 1
  sharing type Io.Directory = FileName.Directory
d1359 6
d1366 1
a1366 1
	  Io.set_source_path (map FileName.parse_directory l)
d1368 1
a1368 1
            FileName.BadHomeName s =>
d1375 1
a1375 2
	fun get_source_path () =
	  map FileName.directory_name (Io.get_source_path ())
d1378 1
a1378 1
	  Io.set_pervasive_dir (FileName.parse_directory s)
d1380 1
a1380 1
            FileName.BadHomeName s =>
d1388 1
a1388 1
	  FileName.directory_name (Io.get_pervasive_dir ())
@


1.86
log
@Changes to tycon lookup
@
text
@d7 3
d418 2
d510 1
a510 1
        val (f,n) = MLWorks.Internal.Value.cast dyns
d523 1
a523 1
        val (value,ty) = MLWorks.Internal.Value.cast dyn
d529 1
a529 1
      Trace.untrace (MLWorks.Internal.Value.cast dyn,do_trace_error)
d538 1
a538 1
        val valtys = MLWorks.Internal.Value.cast dynamics
d548 1
a548 1
        val (value,ty) = MLWorks.Internal.Value.cast dyn
d558 1
a558 1
        val ty : Datatypes.Type = MLWorks.Internal.Value.cast tyrep
d572 1
a572 1
      MLWorks.Internal.Value.cast (exn, s)
d837 1
a837 1
            (MLWorks.Internal.Value.cast result) : MLWorks.Dynamic.Dynamic
d850 1
a850 1
          InspectorValues.add_inspect_method (MLWorks.Internal.Value.cast dyn)
d853 1
a853 1
          InspectorValues.delete_inspect_method (MLWorks.Internal.Value.cast dyn)
d862 1
a862 1
          (fn dyn => Inspector.inspect_value (MLWorks.Internal.Value.cast dyn,!shell_data_ref))
d942 1
a942 1
          MLWorks.Internal.Value.cast 
d964 1
a964 1
          MLWorks.Internal.Value.cast 
d986 1
a986 1
          MLWorks.Internal.Value.cast 
d1019 1
a1019 1
          MLWorks.Internal.Value.cast 
d1048 1
a1048 1
          MLWorks.Internal.Value.cast
d1068 1
a1068 1
	  MLWorks.Internal.Value.cast
d1160 1
a1160 1
	  MLWorks.Internal.Value.cast
d1179 1
a1179 1
	     MLWorks.Internal.Value.cast
d1218 1
a1218 1
          MLWorks.Internal.Value.cast
d1233 1
a1233 1
          MLWorks.Internal.Value.cast
d1246 1
a1246 1
          MLWorks.Internal.Value.cast
d1266 1
a1266 1
	  MLWorks.Internal.Value.cast
d1312 1
a1312 1
	  MLWorks.Internal.Value.cast
d1382 1
a1382 1
	   MLWorks.Internal.Value.cast
d1398 1
a1398 1
              MLWorks.Internal.Value.cast d
d1412 1
a1412 1
        val editor_record = MLWorks.Internal.Value.cast
d1471 1
a1471 1
             MLWorks.Internal.Value.cast
d1499 1
a1499 1
             MLWorks.Internal.Value.cast
d1631 1
a1631 1
	    MLWorks.Internal.Value.cast
d1740 1
a1740 1
               MLWorks.Internal.Value.cast
d1775 1
a1775 1
               MLWorks.Internal.Value.cast{
@


1.85
log
@Moved call to read_dot_mlworks here from _tty_listener.
@
text
@d7 3
d602 1
a602 1
	fun get_runtime_type(Ident.LONGTYCON(path, tycon as Ident.TYCON sy)) =
d607 1
a607 2
	    val ENV{2=tyenv, ...} = Ident.followPath Env.find_env (path, env)
	    val TYSTR(tyfun, valenv) = Tyenv.lookup(tyenv, tycon)
d1803 1
a1803 1
                                Debugger_Types.Debugger_Env.EMPTY, true))))
@


1.84
log
@Revised help message for startup.
@
text
@d7 3
d381 1
a381 1
               ShellUtils.UserOptions
d384 2
a385 1
  sharing type ShellTypes.ShellData = Inspector.ShellData
d388 2
d573 4
a576 4
    (* make the visible structures of the shell. This is called once to make a single *)
    (* shell_structure.  The data for each shell is obtained from a global reference *)
    (* This means that the shell_data_ref object should not be dereferences outside *)
    (* the shell functions *)
d1693 1
@


1.83
log
@Added new editor options.
@
text
@d7 3
d1661 15
a1675 2
	      (message
	         "Valid arguments are: -tty -motif -full_menus -short_menus -help"; r)
d1678 3
a1680 3
	         ("Unknown argument " ^ s
		  ^ ".  Use -help for a complete list.");
	       MLWorks.exit 1;
@


1.82
log
@Changes to editor selection.
@
text
@d7 3
d961 2
d972 4
@


1.81
log
@Added -full_menus and -short_menus options.
@
text
@d7 3
d377 1
a1141 7
	val edit_option_structure = mk_structure
	  [("editor", mk_option Types.string_tyname)]

	val edit_option_record =
	  MLWorks.Internal.Value.cast
	  {editor = (make_option_rep #editor) : string option_rep}

d1364 2
a1365 1
          (ShellUtils.edit_file (string,ShellTypes.get_current_options (!shell_data_ref));
d1374 2
a1375 1
            val options = ShellTypes.get_current_options (!shell_data_ref)
d1378 1
a1378 1
            ShellUtils.edit_object (f,context,options);
d1383 1
a1383 1
	val editor_structure = mk_exn_structure ([("edit_file", string_to_unit),
d1387 5
a1391 4
	val editor_record = MLWorks.Internal.Value.cast
	  {
	   a_edit_file = edit_file : string -> unit,
           a_edit_definition = edit_definition : MLWorks.Dynamic.Dynamic -> unit,
d1393 2
a1394 1
	   }
a1461 1
	    	      ("Editor", edit_option_structure),
a1481 1
	      c_editor = edit_option_record,
@


1.80
log
@Saved images now take arguments to select tty or motif mode.
x_interface_fn takes a boolean that indicates whether it is called
from the TTY interface or whether MLWorks invoked it on start-up.
@
text
@d7 5
d1630 3
a1632 3
            val shell_data = !shell_data_ref
            val mk_tty_listener = get_mk_tty_listener shell_data
            val listener_args = ShellTypes.get_listener_args shell_data
d1641 11
a1651 2
	    |   parse ("-tty" :: t, r) = parse (t, true)
	    |   parse ("-motif" :: t, r) = parse (t, false)
d1655 1
a1655 1
		  ^ ".  Only -motif and -tty are recognised.");
d1663 3
@


1.79
log
@Update debugger information production
@
text
@d7 3
d1609 12
a1620 12
        val xinterface_fn : unit -> unit =
          fn () =>
          let val shell_data = !shell_data_ref
          in
            if get_x_running shell_data
              then
                output (std_out, x_message)
            else
              (get_mk_xinterface_fn shell_data)
              (ShellTypes.get_listener_args shell_data)
              ()
          end
d1628 37
d1666 2
a1667 14
            MLWorks.save (filename,
                          fn () =>
                          MLWorks.IO.with_standard_output
                          MLWorks.IO.terminal_out
                          (fn () =>
                           MLWorks.IO.with_standard_input
                           MLWorks.IO.terminal_in
                           (fn () =>
                            (output (std_out, Version.version_string ^ "\n");
			     Io.set_source_path_from_env ();
			     Io.set_pervasive_dir_from_env ();
                             mk_tty_listener listener_args
                            ))))
            handle MLWorks.Save message =>
d1670 3
a1672 1
              (Info.FATAL, Info.Location.FILE(ShellTypes.get_current_toplevel_name ()), message);
d1722 1
a1722 1
		   a_xinterface = xinterface_fn : unit -> unit,
@


1.78
log
@Add Shell.Trace.untrace_all.
@
text
@d7 3
d1723 1
a1723 1
                                Debugger_Types.Debugger_Env.EMPTY))))
d1731 2
a1732 1
        val context = Incremental.add_debug_info (environment_debug_info,context)
@


1.77
log
@Remove garbage collection performed before image save.
(this is now done automatically in the runtime).
@
text
@d7 4
d1209 2
a1210 1
           ("trace_full",dynamic3_to_unit)]
d1218 2
a1219 1
                                                  MLWorks.Dynamic.Dynamic) -> unit}
@


1.76
log
@Added default_overloads option.
@
text
@d7 3
a1612 5
            val old_level =
              !MLWorks.Internal.Runtime.StorageManager.gc_message_level
	    fun collect () =
	      (MLWorks.Internal.Runtime.StorageManager.interface (70,());
	       ())
a1616 3
            MLWorks.Internal.Runtime.StorageManager.gc_message_level := ~1;
            collect () handle MLWorks.Internal.Runtime.StorageManager.StorageManager _ => ();
            MLWorks.Internal.Runtime.StorageManager.gc_message_level := old_level;
@


1.75
log
@Made Shell.Options.Mode.{debugging,optimising} bool options.
@
text
@d7 3
d1017 1
d1030 1
@


1.74
log
@Implemented touch_compile_{module,file}.
@
text
@d7 3
d858 14
d873 1
a873 12
	  (fn () =>
	     let val UserOptions.USER_OPTIONS (user_options,_) =
		   ShellTypes.get_user_options (!shell_data_ref)
	     in !(f user_options)
	     end,
	   fn v => 
	     let val UserOptions.USER_OPTIONS (user_options,ref update_fns) =
		   ShellTypes.get_user_options (!shell_data_ref)
	     in 
               (f user_options) := v;
               Lists.iterate (fn f => f ()) update_fns
	     end)
d1032 2
a1033 2
	   ("optimizing", unit_to_unit_fn),
	   ("debugging", unit_to_unit_fn)]
d1071 1
a1071 1
	fun select_optimizing () =
d1076 5
d1082 7
a1088 1
	fun select_debugging () =
d1091 4
a1094 2
	   clear_user_option #generate_variable_debug_info;
	   clear_user_option #generate_polyvariable_debug_info;
d1097 10
d1112 2
a1113 2
	   optimizing = select_optimizing : unit -> unit,
	   debugging = select_debugging : unit -> unit}
@


1.73
log
@Revised Shell.Options.Compatibility
@
text
@d7 3
d1268 1
a1268 3
	       (fn filename =>
		  output
		    (std_out, "touch_file unimplemented\n")): string -> unit,
d1270 1
a1270 3
	       (fn filename =>
		  output
		    (std_out, "touch_file unimplemented\n")): string -> unit
@


1.72
log
@Moved some functions from Shell.Make into the new structures Shell.Path
and Shell.Compile.  Added _module versions of make & compile functions.
@
text
@d7 4
d1000 1
a1000 1
	   ("nj_optional_op", mk_option Types.bool_tyname),
d1003 3
a1005 1
	   ("nj_semicolons", mk_option Types.bool_tyname)]
d1011 1
a1011 1
	   nj_optional_op = (make_option_rep #nj_op_in_datatype) : bool option_rep,
d1014 4
a1017 1
	   nj_semicolons = (make_option_rep #nj_semicolons) : bool option_rep}
@


1.71
log
@Added ability to define exceptions.
Used this to improve errors from eval, edit etc.
@
text
@d7 4
d1167 103
a1269 12
          [("make", string_to_unit),
            ("check_make_dependencies", string_to_unit),
            ("save", string_to_unit),
            ("force_make", string_to_unit),
            ("compile", string_to_unit),
            ("load", string_to_unit),
            ("check_compile_dependencies", string_to_unit),
            ("set_source_path", string_list_to_unit),
            ("source_path", unit_to_string_list),
            ("set_pervasive", string_to_unit),
            ("pervasive", unit_to_string)
	    ]
d1297 3
a1299 19
	val make_record =
	     MLWorks.Internal.Value.cast
             {a_make =
              (fn filename =>
               ActionQueue.add_make (filename, error_info)) : string -> unit,
	      a_check_make_dependencies =
              (fn filename =>
               ActionQueue.add_check_make (filename, error_info)) : string -> unit,
	      a_save =
              (fn filename =>
               ActionQueue.add_save (filename, error_info)) : string -> unit,
	      a_load =
              (fn filename =>
               ActionQueue.add_load (filename, error_info)) : string -> unit,
              a_force_make =
              (fn filename =>
		 ActionQueue.add_remake (filename, error_info))
		  : string -> unit,
	      a_set_source_path = set_source_path : string list -> unit,
d1302 1
a1302 17
	      a_pervasive = get_pervasive_dir : unit -> string,
              a_compile =
              (fn filename =>
               (Recompile.recompile
                  error_info
                  (ShellTypes.get_current_options (!shell_data_ref))
                  [filename])) : string -> unit,
              a_check_compile_dependencies =
              (fn filename =>
	       (set_user_option #no_execute;
                Recompile.recompile
                  error_info
                  (ShellTypes.get_current_options (!shell_data_ref))
                  [filename]
                handle exn => (clear_user_option #no_execute;raise exn);
		clear_user_option #no_execute)) : string -> unit
              }
d1624 2
d1638 1
a1638 1
		   ("save", string_to_unit)
d1647 1
a1647 1
		   a_save = save_fn : string -> unit,
d1653 2
@


1.70
log
@Added edit_function function to Shell.Editor
@
text
@d7 3
a258 1
require "../editor/editor";
a286 1
  structure Editor : EDITOR
a314 1
	  Editor.Options =
a320 1
  sharing Editor.Option = Types.Datatypes.Option
d326 2
a327 1
               InspectorValues.Type = Trace.Type = ShellUtils.Type
d350 1
a350 1
    structure Option = Editor.Option
d505 12
a516 10
    fun eval_string (shell_data,string) =
      let
        val context = ShellTypes.get_current_context shell_data
        val options = ShellTypes.get_current_options shell_data
        val ShellTypes.SHELL_DATA{debugger,...} = shell_data
        val error_info = Info.default_options
        val result = ShellUtils.eval error_info (string,options,context,debugger)
      in
        (MLWorks.Internal.Value.cast result) : MLWorks.Dynamic.Dynamic
      end
a539 21
        fun shell_eval_fn s = eval_string (!shell_data_ref,s)
        fun shell_dyn_trace d = trace_dynamic (!shell_data_ref,d)
        fun shell_dyn_trace_full d = trace_full_dynamic (!shell_data_ref,d)
        fun shell_dyn_print_val d = print_dynamic (!shell_data_ref,d)
        fun shell_dyn_print_type t = print_type (!shell_data_ref,t)

        fun add_inspect_method (dyn : MLWorks.Dynamic.Dynamic) =
          InspectorValues.add_inspect_method (MLWorks.Internal.Value.cast dyn)

        fun delete_inspect_method (dyn : MLWorks.Dynamic.Dynamic) =
          InspectorValues.delete_inspect_method (MLWorks.Internal.Value.cast dyn)

        fun delete_all_inspect_methods () =
          InspectorValues.delete_all_inspect_methods ()
      
        val inspect_it_fn  : unit -> unit =
          (fn () => Inspector.inspect_it (!shell_data_ref))

        val inspect_dyn_fn  : MLWorks.Dynamic.Dynamic -> unit =
          (fn dyn => Inspector.inspect_value (MLWorks.Internal.Value.cast dyn,!shell_data_ref))

d658 3
d705 19
a723 8
	fun mk_valenv l =
	  Lists.reducel
	  (fn (ve, (name, ty)) =>
	   Valenv.add_to_ve
	   (Ident.VAR(find_symbol name),
	    UNBOUND_SCHEME (ty,Option.ABSENT),
	    ve))
	  (empty_valenv, l)
d745 1
a745 1
	fun mk_mixed_structure(strs, tys, vals) =
d751 1
a751 1
	         mk_valenv vals))
d753 2
a754 1
	fun mk_structure l = mk_mixed_structure([], [], l)
d759 47
a805 1
          
d1136 5
a1140 4
        val dynamic_structure = mk_structure
          [("eval", string_to_dynamic),
           ("print_val",dynamic_to_string),
           ("print_type",type_to_string)]
d1145 1
d1163 11
a1173 10
	    [("make", string_to_unit),
	     ("save", string_to_unit),
	     ("force_make", string_to_unit),
	     ("compile", string_to_unit),
	     ("load", string_to_unit),
	     ("check_compile_dependencies", string_to_unit),
	     ("set_source_path", string_list_to_unit),
	     ("source_path", unit_to_string_list),
	     ("set_pervasive", string_to_unit),
	     ("pervasive", unit_to_string)
d1207 3
d1242 4
a1245 8
          let val (result,_) = 
            Editor.edit (ShellTypes.get_current_options (!shell_data_ref)) (string, 0)
          in
            case result of 
              Option.ABSENT => ()
            | Option.PRESENT s =>
                output(std_out, s ^ "\n")
          end
d1257 1
d1259 3
a1261 2
	val editor_structure = mk_structure[("edit_file", string_to_unit),
                                            ("edit_definition",dynamic_to_unit)]
d1266 2
a1267 1
           a_edit_definition = edit_definition : MLWorks.Dynamic.Dynamic -> unit
d1552 1
a1552 1
        
d1574 2
a1575 1
		   ]),
d1596 24
@


1.69
log
@Tidying up - removing replace and gc functions
@
text
@d7 3
d648 3
a650 7
          FUNTYPE(
                  make_pair(
                            Types.string_type,
                            FUNTYPE(Types.string_type, Types.empty_rectype)
                            ),
                  Types.string_type
                  )
d653 2
a654 4
          FUNTYPE (
                   Types.empty_rectype,
                   CONSTYPE([Types.string_type], Types.list_tyname)
                   )
d676 1
a676 1
          
d710 2
a711 1
          CONSTYPE([make_pair(Types.string_type,CONSTYPE([Types.bool_type],Types.ref_tyname))],
d1193 1
a1193 1
	fun edit_function string =
d1203 13
a1215 1
	val editor_structure = mk_structure[("edit_file", string_to_unit)]
d1219 2
a1220 1
	   a_edit = edit_function : string -> unit
@


1.68
log
@Added inspector functions
@
text
@d387 1
a387 1
      (NewMap.domain (Incremental.signatures context))
d397 1
a397 1
        (NewMap.domain funmap)
d409 1
a409 1
        (NewMap.domain strmap)
d421 1
a421 1
        (NewMap.domain tymap)
d439 1
a439 1
        (Lists.filterp p (NewMap.domain valmap))
d441 3
a443 1
    
d452 4
d463 1
a463 1
        Trace.trace ((value,ty),user_options,context_fn,fn s => output(std_out,s^"\n"))
d467 1
a467 1
      Trace.untrace (MLWorks.Internal.Value.cast dyn,fn s => output(std_out,s^"\n"))
d478 1
a478 1
        Trace.trace_full (valtys,user_options,context_fn,fn s => output(std_out,s^"\n"))
a535 1
        fun shell_dyn_replace d = replace_dynamic (!shell_data_ref,d)
d1099 1
a1099 2
           ("print_type",type_to_string),
           ("replace",dynamic2_to_unit)]
d1105 1
a1105 3
           a_print_type = shell_dyn_print_type : MLWorks.Dynamic.Type -> string,
           a_replace = shell_dyn_replace : (MLWorks.Dynamic.Dynamic *
                                            MLWorks.Dynamic.Dynamic) -> unit}
d1126 1
a1126 1
	     ("check_dependencies", string_to_unit),
d1184 1
a1184 1
              a_check_dependencies =
a1478 15
        val gc_fn : unit -> unit =
          fn () =>
          let
            val old_level =
              !MLWorks.Internal.Runtime.StorageManager.gc_message_level

            fun collect 200 = ()
              | collect n = 
                (MLWorks.Internal.Runtime.StorageManager.interface (20,n);
                 collect(n+1)
                 )
          in
            collect 0 handle MLWorks.Internal.Runtime.StorageManager.StorageManager _ => ()
          end

d1515 1
a1515 2
		   ("save", string_to_unit),
		   ("gc", unit_to_unit)
a1523 1
                   a_gc = gc_fn : unit -> unit,
@


1.67
log
@Deleted compiler option debug_polyvariables in Debugger_Types.INFO;
Boolean indicator for Monomorphic debugger decapsulation;\ncompilation options for Step and Modules Debuggers.
@
text
@d7 4
a495 3
    fun add_inspect_method (shell_data, dyn : MLWorks.Dynamic.Dynamic) =
      InspectorValues.add_inspect_method (MLWorks.Internal.Value.cast dyn)

d535 3
a537 1
        fun shell_add_inspect_method d = add_inspect_method (!shell_data_ref,d)
d539 6
d1077 2
d1086 4
a1089 1
           a_add_inspect_method = shell_add_inspect_method : MLWorks.Dynamic.Dynamic -> unit}
@


1.66
log
@Changing Shell.Debug structure.
@
text
@d7 3
d379 1
a379 1
        
d431 1
d478 4
a481 4
        ValuePrinter.stringify_value(print_options,
                                     value,
                                     ty,
                                     debug_info)
d888 3
d907 6
d1230 1
a1230 1
            val Debugger_Types.INFO (debug_info,_) =
d1239 1
a1239 1
            val Debugger_Types.INFO (debug_info, _) =
d1463 15
d1514 2
a1515 1
		   ("save", string_to_unit)
d1524 1
@


1.65
log
@Changing name of nj_op_in_datatype option to nj_optional_op.
@
text
@a376 22
    fun show_debug_info_internal options (name,context,output_fn) =
      let
        val Debugger_Types.INFO (debug_info,_) = Incremental.debug_info context
        val Debugger_Types.INFO (empty_map,_) = Debugger_Types.empty_information
        val filtered_map =
          if name = ""
            then
              debug_info
          else
            NewMap.fold
            (fn (old_map,from,to) =>
             if is_a_substring (name,from) 
               then 
                 NewMap.define(old_map,from,to)
             else
               old_map)
            (empty_map,debug_info)
      in
        output_fn (Debugger_Types.string_information options 
                   (Debugger_Types.INFO (filtered_map,false)))
      end
    
d513 1
a515 4

	fun output_fn s = output(std_out, s)
	val error_info = Info.default_options

d558 5
d662 21
a761 6
	fun make_tyvar name = TYVAR (ref (0,NULLTYPE,NO_INSTANCE),
				     Ident.TYVAR (find_symbol name,
						  false,
						  false))


d1199 2
a1200 3
		    [("show_debug_info", UNBOUND_SCHEME (string_to_unit,
                                                         Option.ABSENT)),
		     ("show_all_debug_info", UNBOUND_SCHEME (unit_to_unit,
d1202 2
a1203 1
		     ("clear_debug_info", UNBOUND_SCHEME (unit_to_unit,
d1208 24
a1231 10
        fun show_debug_info name =
          show_debug_info_internal
          (ShellTypes.get_current_print_options (!shell_data_ref))
          (name,get_context (),output_fn)

        fun show_all_debug_info () =
          show_debug_info_internal
          (ShellTypes.get_current_print_options (!shell_data_ref))
          ("",get_context (),output_fn)

d1234 4
a1237 3
             {a_clear_debug_info = ActionQueue.add_clear_debug : unit -> unit,
              a_show_debug_info = show_debug_info : string -> unit,
              a_show_all_debug_info = show_all_debug_info : unit -> unit}
@


1.64
log
@Change to storage manager interface.
@
text
@d7 3
d930 1
a930 1
	   ("nj_op_in_datatype", mk_option Types.bool_tyname),
d939 1
a939 1
	   nj_op_in_datatype = (make_option_rep #nj_op_in_datatype) : bool option_rep,
@


1.63
log
@Fixed types of functions to set and get pervasive directory and source
path, ensuring that all necessary expansion is done.
@
text
@d7 4
d1407 3
a1409 6

            fun collect 200 = ()
              | collect n = 
                (MLWorks.Internal.Runtime.StorageManager.interface (20,n);
                 collect(n+1)
                 )
d1415 1
a1415 1
            collect 0 handle MLWorks.Internal.Runtime.StorageManager.StorageManager _ => ();
@


1.62
log
@Changing inspector interface
@
text
@d7 3
d222 1
d253 1
d319 3
a321 5
	       Incremental.Context =
               ShellUtils.Context
  sharing type ShellTypes.ShellData =
               Inspector.ShellData
  sharing type Io.Directory = string
d1102 26
d1143 4
a1146 4
	      a_set_source_path = Io.set_source_path : string list -> unit,
	      a_source_path = Io.get_source_path : unit -> string list,
	      a_set_pervasive = Io.set_pervasive_dir : string -> unit,
	      a_pervasive = Io.get_pervasive_dir : unit -> string,
@


1.61
log
@ActionQueue no longer has Incremental as a substructure.  And the
functionality of trans_home_name has been hidden.
@
text
@d7 4
d547 5
a551 2
        val inspect_fn  : unit -> unit =
          (fn () => Inspector.inspect_value (!shell_data_ref))
d1050 2
a1051 1
           ("inspect",unit_to_unit)]
d1055 2
a1056 1
          {a_inspect = inspect_fn : unit -> unit,
@


1.60
log
@Better locations in error messages
@
text
@d7 3
d232 1
d266 1
d271 1
a271 1
          ActionQueue.Incremental.Datatypes = Env.Datatypes
d275 1
a275 1
	  ActionQueue.Incremental.InterMake.Compiler.Info =
d278 1
d286 1
a286 1
    	  ActionQueue.Incremental.InterMake.Compiler.Options =
d291 1
a291 1
	  ActionQueue.Incremental.InterMake.Compiler.Absyn.Ident
d294 1
a294 1
	  ActionQueue.Incremental.InterMake.Compiler.NewMap
d297 1
a297 1
  sharing type ActionQueue.Incremental.options = ShellTypes.IncrementalOptions
d299 1
a299 1
    ActionQueue.Incremental.InterMake.Compiler.DebugInformation
d302 1
a302 1
  sharing type ActionQueue.Incremental.InterMake.Compiler.TypeBasis =
d310 1
a310 1
	       ActionQueue.Incremental.Context =
a316 1
    structure Incremental = ActionQueue.Incremental
d1112 3
a1114 3
                (error_info)
                (ShellTypes.get_current_options (!shell_data_ref))
                [Io.trans_home_name filename])) : string -> unit,
d1118 4
a1121 4
                (Recompile.recompile
                (error_info)
                (ShellTypes.get_current_options (!shell_data_ref))
                [Io.trans_home_name filename])
d1123 1
a1123 1
                clear_user_option #no_execute)) : string -> unit
@


1.59
log
@Protect change to no_execute with handler
@
text
@d7 3
d1389 1
a1389 1
              (Info.FATAL, Info.Location.UNKNOWN, message);
@


1.58
log
@Added load function to Make structure
@
text
@d7 3
d1110 1
a1110 1
                Recompile.recompile
d1113 3
a1115 2
                [Io.trans_home_name filename];
		clear_user_option #no_execute)) : string -> unit
@


1.57
log
@Added maximum_str_depth to options.
@
text
@d7 3
d1071 1
d1087 3
@


1.56
log
@Added level field to Basis.
@
text
@d7 3
d724 1
d800 1
@


1.55
log
@Added Shell.Dynamic.replace
@
text
@d7 3
d377 1
a377 1
	    BasisTypes.BASIS (_, BasisTypes.FUNENV map, _, _) => map
d388 1
a388 1
	    BasisTypes.BASIS (_, _, _, Datatypes.ENV(Datatypes.SE map, _, _)) =>
d400 1
a400 1
	    BasisTypes.BASIS (_, _, _, Datatypes.ENV(_, Datatypes.TE map, _)) =>
d412 1
a412 1
	    BasisTypes.BASIS (_, _, _,
d541 1
a541 1
	       {type_basis=BasisTypes.BASIS{4=env, ...}, ...}, ...} = initial_context
@


1.54
log
@Added Shell.Options.Preferences.
@
text
@d7 3
d422 9
d516 1
d597 7
d1031 2
a1032 1
           ("print_type",type_to_string)]
d1038 3
a1040 2
           a_print_type = shell_dyn_print_type : MLWorks.Dynamic.Type -> string}

@


1.53
log
@Changed Shell.Make.remake_file to Shell.Make.force_make, and
Shell.Make.recompile to Shell.Make.compile (hiding old Shell.Make.compile).
@
text
@d7 4
d802 23
d1139 2
a1140 1
		     [("ValuePrinter", value_printer_structure),
d1167 2
a1168 1
	      c_mode = mode_option_record
@


1.52
log
@Added is_abs field to TYNAME and METATYNAME
Further work may be needed here.
@
text
@d7 4
d526 1
a526 1
				    ref(Types.equalityp tyfun), ref valenv,ref false))
d1009 1
a1009 1
	     ("remake_file", string_to_unit),
a1010 1
	     ("recompile", string_to_unit),
d1026 1
a1026 1
              a_remake_file =
a1029 6
              a_compile =
              (fn filename =>
               (TopLevel.compile_file
                (error_info)
                (ShellTypes.get_current_options (!shell_data_ref))
                [Io.trans_home_name filename])) : string -> unit,
d1034 1
a1034 1
              a_recompile =
@


1.51
log
@Added Shell.Timer structure.
@
text
@d7 3
d511 2
d522 1
a522 1
				    ref(Types.equalityp tyfun), ref valenv))
@


1.50
log
@Added shell structure support for requesting interruptable tight loops
@
text
@d7 3
d520 37
d558 1
a558 8
          Types.add_to_rectype
          (Ident.LAB (find_symbol "1"),
           a,
           Types.add_to_rectype(
                                Ident.LAB (find_symbol "2"),
                                b,
                                Types.empty_rectype
                                ))
d564 3
a566 10
          Types.add_to_rectype
          (Ident.LAB (find_symbol "1"),
           Types.dynamic_type,
           Types.add_to_rectype
           (Ident.LAB (find_symbol "2"),
            Types.dynamic_type,
            Types.add_to_rectype
            (Ident.LAB (find_symbol "3"),
             Types.dynamic_type,
             Types.empty_rectype)))
d690 6
d699 1
a699 4
            val aty = TYVAR (ref (0,NULLTYPE,NO_INSTANCE),
			     Ident.TYVAR (find_symbol ("'a"),
					  false,
					  false))
d712 1
a712 4
            val aty = TYVAR (ref (0,NULLTYPE,NO_INSTANCE),
			     Ident.TYVAR (find_symbol ("'a"),
					  false,
					  false))
d1142 125
d1348 2
a1349 1
                   ("Inspector",inspector_structure)
d1370 2
a1371 1
		   c_options = options_record
@


1.49
log
@Merged in bug fix.
@
text
@d7 3
d768 1
d784 2
@


1.48
log
@Added Shell.Make.save function
@
text
@d7 6
d16 3
d653 2
a654 1
           ("maximum_list_size",  mk_option Types.int_tyname),
d731 2
a732 1
           maximum_list_size = (make_option_rep #maximum_list_size) : int option_rep,
@


1.47
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d7 3
d956 1
d971 4
a974 2
		 ActionQueue.add_make (filename, error_info))
		  : string -> unit,
@


1.46
log
@ Added source_path, set_pervasive, pervasive to Shell.Make.
@
text
@d7 3
d313 2
a314 2
        val Debugger_Types.INFO debug_info = Incremental.debug_info context
        val Debugger_Types.INFO empty_map = Debugger_Types.empty_information
d329 2
a330 1
        output_fn (Debugger_Types.string_information options (Debugger_Types.INFO filtered_map))
d598 1
a598 1
	    UNBOUND_SCHEME ty,
d651 1
a651 1
            val aty = TYVAR (ref (0),
d659 1
a659 1
                                        Types.empty_rectype)))
d667 1
a667 1
            val aty = TYVAR (ref (0),
d673 1
a673 1
            Scheme.make_scheme ([aty], (FUNTYPE(aty_option, aty)))
d750 1
d764 2
d856 1
d1032 6
a1037 3
		    [("show_debug_info", UNBOUND_SCHEME (string_to_unit)),
		     ("show_all_debug_info", UNBOUND_SCHEME (unit_to_unit)),
		     ("clear_debug_info", UNBOUND_SCHEME (unit_to_unit))])
d1151 2
a1152 1
               UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rectype)),
@


1.46.1.1
log
@Fork for bug fixing
@
text
@a6 3
 *  Revision 1.46  1993/08/28  17:00:38  daveb
 *   Added source_path, set_pervasive, pervasive to Shell.Make.
 *
@


1.46.1.2
log
@Changed print options.
@
text
@a6 3
 *  Revision 1.46.1.1  1993/08/28  17:00:38  jont
 *  Fork for bug fixing
 *
d640 1
a640 2
           ("maximum_seq_size",  mk_option Types.int_tyname),
           ("maximum_string_size",  mk_option Types.int_tyname),
d717 1
a717 2
           maximum_seq_size = (make_option_rep #maximum_seq_size) : int option_rep,
           maximum_string_size = (make_option_rep #maximum_string_size) : int option_rep,
@


1.45
log
@Return quit function from ShellUtils.edit_string
@
text
@d7 3
d258 1
d571 7
a577 3
	val string_ref =
	  CONSTYPE([Types.string_type], Types.ref_tyname)

d949 4
a952 1
	     ("set_source_path", string_list_to_unit)
d970 1
a970 1
                (Io.trans_home_name filename))) : string -> unit,
d972 3
d980 1
a980 1
                (Io.trans_home_name filename))) : string -> unit,
d987 1
a987 1
                (Io.trans_home_name filename);
@


1.44
log
@Tidied up mode functions
@
text
@d7 3
d978 8
a985 4
	  case Editor.edit (ShellTypes.get_current_options (!shell_data_ref)) (string, 0) of
	    Option.ABSENT => ()
	  | Option.PRESENT s =>
	      output(std_out, s ^ "\n")
@


1.43
log
@Removed core-only and functional options, since they didn't do anything.
Added Make.check_dependecies.
@
text
@d7 4
d385 1
a385 1
        Trace.trace ((value,ty),user_options,context_fn)
d389 1
a389 1
      Trace.untrace (MLWorks.Internal.Value.cast dyn)
d400 1
a400 1
        Trace.trace_full (valtys,user_options,context_fn)
d796 1
a796 1
	   clear_user_option #nj_op_in_datatype;
d808 1
a808 1
	   set_user_option #nj_op_in_datatype;
d812 1
a812 1
           clear_user_option #abstractions;
d820 1
a820 1
	   set_user_option #nj_op_in_datatype;
a831 3
	   clear_user_option #generate_interceptable_code;
	   clear_user_option #generate_debug_info;
	   clear_user_option #generate_variable_debug_info;
d835 1
a835 4
	  (clear_user_option #optimize_leaf_fns;
	   clear_user_option #optimize_tail_calls;
	   clear_user_option #optimize_self_tail_calls;
	   set_user_option #generate_interceptable_code;
d837 1
a837 1
	   set_user_option #generate_variable_debug_info;
@


1.42
log
@Changes to reflect changes in Io structure.
@
text
@d7 3
a767 1
	   (* ("derived_redef", mk_option Types.bool_tyname), *)
d770 1
a770 3
	   ("nj_semicolons", mk_option Types.bool_tyname),
	   ("core_only", mk_option Types.bool_tyname),
	   ("functional", mk_option Types.bool_tyname)]
a776 1
	   (* derived_redef = (make_option_rep #derived_redef) : bool option_rep, *)
d779 1
a779 3
	   nj_semicolons = (make_option_rep #nj_semicolons) : bool option_rep,
	   core_only = (make_option_rep #core_only) : bool option_rep,
	   functional = (make_option_rep #functional) : bool option_rep}
d789 1
a789 2
	  ((* clear_user_option #derived_redef; *)
	   clear_user_option #require_keyword;
d801 1
a801 2
	  ((* set_user_option #derived_redef; *)
	   set_user_option #require_keyword;
d813 1
a813 2
	  ((* set_user_option #derived_redef; *)
	   clear_user_option #require_keyword;
d939 1
d965 9
a973 1
                (Io.trans_home_name filename))) : string -> unit
d1104 1
@


1.41
log
@Changes to user_options to store update functions
@
text
@d7 3
d226 1
a226 1
  sharing Io.Option = Editor.Option = Types.Datatypes.Option
d553 4
d944 2
a945 1
	     ("recompile", string_to_unit)
d952 2
a953 1
               ActionQueue.add_make (filename, error_info)) : string -> unit,
d956 2
a957 1
               ActionQueue.add_remake (filename, error_info)) : string -> unit,
d964 1
d1100 3
a1102 6
                             (case Io.get_pervasive_dir(MLWorks.OS.Unix.environment ()) of
                                Option.PRESENT str =>
                                  TopLevel.pervasive_library_dir := str
                              | _ => ());
                               mk_tty_listener listener_args
                               ))))
@


1.40
log
@Rationalization.  Added Trace, Dynamic and Inspector substructures.
@
text
@d7 3
d651 1
a651 1
	     let val UserOptions.USER_OPTIONS user_options =
d656 1
a656 1
	     let val UserOptions.USER_OPTIONS user_options =
d658 3
a660 1
	     in (f user_options) := v
d663 8
d672 1
a672 1
	     let val UserOptions.USER_OPTIONS user_options =
d674 2
a675 1
	     in (f user_options) := true
d679 1
a679 1
	     let val UserOptions.USER_OPTIONS user_options =
d681 2
a682 1
	     in (f user_options) := false
d794 2
a795 1
	   set_user_option #string_inequalities)
d807 2
a808 1
	   set_user_option #string_inequalities)
d820 2
a821 1
	   clear_user_option #string_inequalities)
d829 2
a830 1
	   clear_user_option #generate_variable_debug_info)
d838 2
a839 1
	   set_user_option #generate_variable_debug_info)
@


1.39
log
@Renamed strict option to standard.
@
text
@d7 3
d457 3
d879 34
a1026 3
        val inspect_fn  : unit -> unit =
          (fn () => Inspector.inspect_value (!shell_data_ref))

d1108 4
a1111 1
		   ("TopEnv", topenv_structure)
d1116 1
a1116 10
                   ("lambda_switches", opt_switches_type),
                   ("inspect",unit_to_unit),
		   ("save", string_to_unit),
		   ("eval", string_to_dynamic),
                   ("print_val",dynamic_to_string),
                   ("print_type",type_to_string),
                   ("trace",dynamic_to_unit),
                   ("untrace",dynamic_to_unit),
                   ("trace_full",dynamic3_to_unit),
                   ("add_inspect_method",dynamic_to_unit)
a1121 10
                   a_eval = shell_eval_fn : string -> MLWorks.Dynamic.Dynamic,
                   a_trace = shell_dyn_trace : MLWorks.Dynamic.Dynamic -> unit,
                   a_untrace = untrace_dynamic : MLWorks.Dynamic.Dynamic -> unit,
                   a_trace_full = shell_dyn_trace_full : (MLWorks.Dynamic.Dynamic *
                                                          MLWorks.Dynamic.Dynamic *
                                                          MLWorks.Dynamic.Dynamic) -> unit,
                   a_print_val = shell_dyn_print_val : MLWorks.Dynamic.Dynamic -> string,
                   a_print_type = shell_dyn_print_type : MLWorks.Dynamic.Type -> string,
                   a_add_inspect_method = shell_add_inspect_method : MLWorks.Dynamic.Dynamic -> unit,
                   a_lambda_switches = TopLevel.lambda_optimisation_switches,
a1123 1
                   a_inspect = inspect_fn : unit -> unit,
d1125 3
@


1.38
log
@new compiler option debug_variables for local and closure variable
inspection in the debugger;
structure Option.
@
text
@d7 5
d759 1
a759 1
	   ("strict", unit_to_unit_fn),
d772 1
d784 1
d787 1
a787 1
	fun select_strict () =
d796 1
d819 1
a819 1
	   strict = select_strict : unit -> unit,
@


1.37
log
@Added call to trans_home_name for recompile and compile
@
text
@d7 3
d212 1
a212 1
  sharing Io.Option = Editor.Option
d496 1
a496 1
	  Types.make_tyname (1, true, "Option", ABSENT)
d582 1
a582 1
	     ref ABSENT,
d608 1
a608 1
            val aty = TYVAR (ref 0,
d615 2
a616 2
                                FUNTYPE(make_pair (aty_option, aty),
                                        Types.empty_rectype))
d624 1
a624 1
            val aty = TYVAR (ref 0,
d630 1
a630 1
            Scheme.make_scheme ([aty], FUNTYPE(aty_option, aty))
d694 1
d702 6
a707 2
          {generate_trace_profile_code = (make_option_rep #generate_interceptable_code) : bool option_rep,
           generate_debug_info = (make_option_rep #generate_debug_info) : bool option_rep,
d796 2
a797 1
	   clear_user_option #generate_debug_info)
d804 2
a805 1
	   set_user_option #generate_debug_info)
d910 1
a910 1
	       ref ABSENT,
d923 3
a925 3
		    [("show_debug_info", UNBOUND_SCHEME string_to_unit),
		     ("show_all_debug_info", UNBOUND_SCHEME unit_to_unit),
		     ("clear_debug_info", UNBOUND_SCHEME unit_to_unit)])
d947 1
a947 1
	       ref ABSENT,
@


1.36
log
@Removed exception environments.
@
text
@d7 3
d875 1
a875 1
                filename)) : string -> unit,
d881 1
a881 1
                filename)) : string -> unit
@


1.35
log
@edit functions now return a single string in the errorneous case.
@
text
@d7 3
d315 1
a315 1
	    BasisTypes.BASIS (_, _, _, Datatypes.ENV(Datatypes.SE map, _, _, _)) =>
d327 1
a327 1
	    BasisTypes.BASIS (_, _, _, Datatypes.ENV(_, Datatypes.TE map, _, _)) =>
d340 1
a340 1
			 Datatypes.ENV(_, _, Datatypes.VE(_, map), _)) =>
a351 16
    fun show_exceptions context =
      let
	val exnmap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_, _, _,
			 Datatypes.ENV(_, _, _, Datatypes.VE(_, map))) =>
            map
      in
	map
        (Symbol.symbol_name o
         (fn (Ident.EXCON s) => s
       | _ => Crash.impossible "non-exception in exception environment"
           ))
        (NewMap.domain exnmap)
      end

a552 9
	fun mk_exnenv l =
	  Lists.reducel
	  (fn (ve, (name, ty)) =>
	   Valenv.add_to_ve
	   (Ident.EXCON(find_symbol name),
	    UNBOUND_SCHEME ty,
	    ve))
	  (empty_valenv, l)

d573 7
a579 11
	fun mk_mixed_structure(strs, tys, vals, exns) =
          STR (
	       STRNAME (Strname_id.make_strname_id ()),
               ref ABSENT,
	       ENV(
                   mk_strenv strs,
                   mk_tyenv tys,
		   mk_valenv vals,
                   mk_exnenv exns
                   )
               )
d581 1
a581 1
	fun mk_structure l = mk_mixed_structure([], [], l, [])
d831 4
a834 1
              (fn () => show_exceptions (get_context ())) : unit -> string list,
d897 1
a897 1
               ref ABSENT,
d912 1
a912 2
		     ("clear_debug_info", UNBOUND_SCHEME unit_to_unit)]),
		 empty_valenv
d934 1
a934 1
               ref ABSENT,
d948 1
a948 2
	              ("get", get_option_type)],
                   mk_exnenv []))
d1065 1
a1065 2
		   ],
		  []),
@


1.34
log
@Added untrace function
@
text
@d7 3
d907 2
a908 2
	  | Option.PRESENT(s1, s2) =>
	      output(std_out, implode["Cannot edit '", s1, "' because ", s2, "\n"])
@


1.33
log
@Removed Parser added ShellUtils structure
Uses ShellUtils.eval function
@
text
@d7 4
d371 3
d1084 1
d1095 1
@


1.32
log
@Changed type of Shell.Options.*.* to 'a Shell.Options.Option,
and added Shell.Options.{set, get}
@
text
@d7 4
a119 1
require "../parser/parser";
d141 1
a148 1
  structure Parser : PARSER
d169 1
a177 1
          Parser.Lexer.Info =
d179 2
a180 1
          ShellTypes.Info
a181 1
          Parser.Options =
d189 2
a190 1
	  Editor.Options
a196 2
  sharing ActionQueue.Incremental.InterMake.Compiler.Absyn =
          Parser.Absyn
d202 1
a202 1
               InspectorValues.Type = Trace.Type
a206 2
  sharing type ActionQueue.Incremental.InterMake.Compiler.ParserBasis =
               Parser.ParserBasis
d208 2
a209 1
	       ShellTypes.user_options = Trace.UserOptions
d211 2
a212 1
	       ActionQueue.Incremental.Context
a404 20
        fun eval (string, options,context,debugger) = 
          let
            val error_info = Info.default_options
            val parser_basis = Incremental.parser_basis context
            val input_fn =
              let val sref = ref string
              in
                fn _ => let val result = !sref in sref := "" ; result end
              end
            val token_stream = Parser.Lexer.mkTokenStream (input_fn,"Eval input")
            val (topdec,_) = Parser.parse_topdec error_info (options,token_stream,parser_basis)
            val result =
              Incremental.evaluate_exp_topdec
              (Incremental.OPTIONS{options = options,
                                   debugger = debugger},
               context,
               topdec)
          in
            result
          end
d408 2
a409 4
(*
        val result = ShellUtils.eval (string,options,context,inc_options)
*)
        val result = eval (string,options,context,debugger)
@


1.31
log
@Rearranged some of the options.
@
text
@d7 3
d512 5
a525 23
        (* Make up the type ('a -> 'b) -> unit *)
        val alpha_beta_bool =
          let 
            val aty = TYVAR (ref 0,
			     Ident.TYVAR (find_symbol ("'a"),
					  false,
					  false
                                          )
                             )
            val bty = TYVAR (ref 0,
			     Ident.TYVAR (find_symbol ("'b"),
					  false,
					  false
                                          )
                             )
          in
            Scheme.make_scheme ([aty,bty],
                                FUNTYPE(
                                        FUNTYPE(aty,bty),
                                        CONSTYPE([],Types.bool_tyname)
                                        ))
          end
        
d560 7
d585 9
d605 1
a605 1
	fun mk_mixed_structure(strs, vals, exns) =
d611 1
a611 1
                   Tyenv.empty_tyenv,
d617 1
a617 1
	fun mk_structure l = mk_mixed_structure([], l, [])
d621 1
a621 4
	fun mk_ref_fun_from_type t =
	  FUNTYPE(Types.empty_rectype, CONSTYPE([t], Types.ref_tyname))

	fun mk_ref_fun t = mk_ref_fun_from_type(CONSTYPE([], t))
d624 7
a630 7
          [("show_fn_details",  mk_ref_fun Types.bool_tyname),
           ("show_exn_details",  mk_ref_fun Types.bool_tyname),
           ("show_id_class",  mk_ref_fun Types.bool_tyname),
           ("show_eq_info",  mk_ref_fun Types.bool_tyname),
           ("maximum_list_size",  mk_ref_fun Types.int_tyname),
           ("maximum_ref_depth",  mk_ref_fun Types.int_tyname),
           ("maximum_depth",  mk_ref_fun Types.int_tyname)
d633 17
a649 3
        fun make_options_fun f () =
          f ((fn (UserOptions.USER_OPTIONS x) => x)
             (ShellTypes.get_user_options (!shell_data_ref)))
d651 13
a663 1
	fun set_option f = make_options_fun f () := true
d665 23
a687 1
	fun clear_option f = make_options_fun f () := false
d691 7
a697 7
          {maximum_depth =  (make_options_fun #maximum_depth) : unit -> int ref,
           maximum_ref_depth = (make_options_fun #maximum_ref_depth) : unit -> int ref,
           maximum_list_size = (make_options_fun #maximum_list_size) : unit -> int ref,
           show_fn_details = (make_options_fun #show_fn_details) : unit -> bool ref,
           show_exn_details = (make_options_fun #show_exn_details) : unit -> bool ref,
           show_id_class = (make_options_fun #show_id_class) : unit -> bool ref,
           show_eq_info = (make_options_fun #show_eq_info) : unit -> bool ref
d701 7
a707 7
	  [("show_absyn", mk_ref_fun Types.bool_tyname),
	   ("show_lambda", mk_ref_fun Types.bool_tyname),
	   ("show_opt_lambda", mk_ref_fun Types.bool_tyname),
	   ("show_environ", mk_ref_fun Types.bool_tyname),
	   ("show_mir", mk_ref_fun Types.bool_tyname),
	   ("show_opt_mir", mk_ref_fun Types.bool_tyname),
	   ("show_mach", mk_ref_fun Types.bool_tyname)]
d712 7
a718 7
	   show_absyn = (make_options_fun #show_absyn) : unit -> bool ref,
	   show_lambda = (make_options_fun #show_lambda) : unit -> bool ref,
	   show_opt_lambda = (make_options_fun #show_opt_lambda) : unit -> bool ref,
	   show_environ = (make_options_fun #show_environ) : unit -> bool ref,
	   show_mir = (make_options_fun #show_mir) : unit -> bool ref,
	   show_opt_mir = (make_options_fun #show_opt_mir) : unit -> bool ref,
	   show_mach = (make_options_fun #show_mach) : unit -> bool ref
d722 5
a726 5
          [("generate_trace_profile_code", mk_ref_fun Types.bool_tyname),
	   ("generate_debug_info", mk_ref_fun Types.bool_tyname),
	   ("optimize_leaf_fns", mk_ref_fun Types.bool_tyname),
	   ("optimize_tail_calls", mk_ref_fun Types.bool_tyname),
	   ("optimize_self_tail_calls", mk_ref_fun Types.bool_tyname)
d731 5
a735 5
          {generate_trace_profile_code = (make_options_fun #generate_interceptable_code) : unit -> bool ref,
           generate_debug_info = (make_options_fun #generate_debug_info) : unit -> bool ref,
           optimize_leaf_fns = (make_options_fun #optimize_leaf_fns) : unit -> bool ref,
           optimize_tail_calls = (make_options_fun #optimize_tail_calls) : unit -> bool ref,
           optimize_self_tail_calls = (make_options_fun #optimize_self_tail_calls) : unit -> bool ref
d739 3
a741 3
          [("require_keyword", mk_ref_fun Types.bool_tyname),
           ("type_dynamic", mk_ref_fun Types.bool_tyname),
	   ("abstractions", mk_ref_fun Types.bool_tyname)
d746 3
a748 3
          {require_keyword = (make_options_fun #require_keyword) : unit -> bool ref,
           type_dynamic = (make_options_fun #type_dynamic) : unit -> bool ref,
           abstractions = (make_options_fun #abstractions) : unit -> bool ref
d754 9
a762 9
	  [("string_inequalities", mk_ref_fun Types.bool_tyname),
	   ("infixr_assoc", mk_ref_fun Types.bool_tyname),
	   ("nj_op_in_datatype", mk_ref_fun Types.bool_tyname),
	   (* ("derived_redef", mk_ref_fun Types.bool_tyname), *)
	   ("nj_signatures", mk_ref_fun Types.bool_tyname),
	   ("weak_tyvars", mk_ref_fun Types.bool_tyname),
	   ("nj_semicolons", mk_ref_fun Types.bool_tyname),
	   ("core_only", mk_ref_fun Types.bool_tyname),
	   ("functional", mk_ref_fun Types.bool_tyname)]
d766 9
a774 9
	  {string_inequalities = (make_options_fun #string_inequalities) : unit -> bool ref,
	   infixr_assoc = (make_options_fun #infixr_assoc) : unit -> bool ref,
	   nj_op_in_datatype = (make_options_fun #nj_op_in_datatype) : unit -> bool ref,
	   (* derived_redef = (make_options_fun #derived_redef) : unit -> bool ref, *)
	   nj_signatures = (make_options_fun #nj_signatures) : unit -> bool ref,
	   weak_tyvars = (make_options_fun #weak_type_vars) : unit -> bool ref,
	   nj_semicolons = (make_options_fun #nj_semicolons) : unit -> bool ref,
	   core_only = (make_options_fun #core_only) : unit -> bool ref,
	   functional = (make_options_fun #functional) : unit -> bool ref}
d784 9
a792 9
	  ((* clear_option #derived_redef; *)
	   clear_option #require_keyword;
	   set_option #nj_semicolons;
	   clear_option #type_dynamic;
	   clear_option #nj_op_in_datatype;
	   set_option #infixr_assoc;
	   set_option #nj_signatures;
	   set_option #weak_type_vars;
	   set_option #string_inequalities)
d795 9
a803 9
	  ((* set_option #derived_redef; *)
	   set_option #require_keyword;
	   clear_option #nj_semicolons;
	   set_option #type_dynamic;
	   set_option #nj_op_in_datatype;
	   clear_option #infixr_assoc;
	   clear_option #nj_signatures;
	   clear_option #weak_type_vars;
	   set_option #string_inequalities)
d806 9
a814 9
	  ((* set_option #derived_redef; *)
	   clear_option #require_keyword;
	   clear_option #nj_semicolons;
	   clear_option #type_dynamic;
	   set_option #nj_op_in_datatype;
	   clear_option #infixr_assoc;
	   clear_option #nj_signatures;
	   clear_option #weak_type_vars;
	   clear_option #string_inequalities)
d817 5
a821 5
	  (set_option #optimize_leaf_fns;
	   set_option #optimize_tail_calls;
	   set_option #optimize_self_tail_calls;
	   clear_option #generate_interceptable_code;
	   clear_option #generate_debug_info)
d824 5
a828 5
	  (clear_option #optimize_leaf_fns;
	   clear_option #optimize_tail_calls;
	   clear_option #optimize_self_tail_calls;
	   set_option #generate_interceptable_code;
	   set_option #generate_debug_info)
d839 1
a839 1
	  [("editor", mk_ref_fun Types.string_tyname)]
d843 1
a843 1
	  {editor = (make_options_fun #editor) : unit -> string ref}
d966 18
a983 9
        val options_structure = mk_mixed_structure
	  ([("ValuePrinter", value_printer_structure),
	    ("Compiler", compiler_structure),
	    ("Internals", internals_structure),
	    ("Extension", extension_structure),
	    ("Compatibility", compat_structure),
	    ("Editor", edit_option_structure),
	    ("Mode", mode_option_structure)
	    ], [], [])
d990 3
a992 1
             {c_compiler = compiler_record,
d1081 1
a1081 2
               (
		  [("Make", make_structure),
d1087 1
d1101 4
a1104 4
	         (* Prefix "a_" for values, "b_" for exceptions,
		    and "c_" for structures, to ensure correct ordering.
	          *)
                 MLWorks.Internal.Value.cast{
@


1.30
log
@Added New Jersey interpretation of weak type variables under option control
@
text
@d7 3
a631 1
           ("maximum_shape_depth",  mk_ref_fun Types.int_tyname),
a645 1
           maximum_shape_depth = (make_options_fun #maximum_shape_depth) : unit -> int ref,
d676 1
a676 1
          [("generate_interceptable_code", mk_ref_fun Types.bool_tyname),
d678 3
a680 5
	   ("show_debug_warnings", mk_ref_fun Types.bool_tyname),
	   ("show_recompilations_only", mk_ref_fun Types.bool_tyname),
	   ("optimise_leaf_fns", mk_ref_fun Types.bool_tyname),
	   ("optimise_tail_calls", mk_ref_fun Types.bool_tyname),
	   ("optimise_self_tail_calls", mk_ref_fun Types.bool_tyname)
d685 1
a685 1
          {generate_interceptable_code = (make_options_fun #generate_interceptable_code) : unit -> bool ref,
d687 3
a689 5
           show_debug_warnings = (make_options_fun #show_debug_warnings) : unit -> bool ref,
           show_recompilations_only = (make_options_fun #no_execute) : unit -> bool ref,
           optimise_leaf_fns = (make_options_fun #optimise_leaf_fns) : unit -> bool ref,
           optimise_tail_calls = (make_options_fun #optimise_tail_calls) : unit -> bool ref,
           optimise_self_tail_calls = (make_options_fun #optimise_self_tail_calls) : unit -> bool ref
d694 2
a695 1
           ("type_dynamic", mk_ref_fun Types.bool_tyname)
d701 2
a702 1
           type_dynamic = (make_options_fun #type_dynamic) : unit -> bool ref
d705 2
d710 3
a712 4
	   ("op_in_datatype", mk_ref_fun Types.bool_tyname),
	   ("derived_redef", mk_ref_fun Types.bool_tyname),
	   ("nj_include", mk_ref_fun Types.bool_tyname),
	   ("nj_local_open", mk_ref_fun Types.bool_tyname),
d714 3
a716 1
	   ("semicolons", mk_ref_fun Types.bool_tyname)]
d722 3
a724 4
	   op_in_datatype = (make_options_fun #op_in_datatype) : unit -> bool ref,
	   derived_redef = (make_options_fun #derived_redef) : unit -> bool ref,
	   nj_include = (make_options_fun #nj_include) : unit -> bool ref,
	   nj_local_open = (make_options_fun #nj_local_open) : unit -> bool ref,
d726 10
a735 6
	   semicolons = (make_options_fun #semicolons) : unit -> bool ref}

	val flavour_option_structure = mk_structure
	  [("NewJersey", unit_to_unit_fn),
	   ("Harlequin", unit_to_unit_fn),
	   ("Strict", unit_to_unit_fn)]
d738 1
a738 1
	  (clear_option #derived_redef;
d740 1
a740 1
	   clear_option #semicolons;
d742 1
a742 1
	   clear_option #op_in_datatype;
d744 2
a745 3
	   set_option #nj_include;
	   set_option #nj_local_open;
	   set_option # weak_type_vars;
d749 1
a749 1
	  (set_option #derived_redef;
d751 1
a751 1
	   set_option #semicolons;
d753 1
a753 1
	   set_option #op_in_datatype;
d755 1
a755 2
	   clear_option #nj_include;
	   clear_option #nj_local_open;
d760 1
a760 1
	  (set_option #derived_redef;
d762 1
a762 1
	   set_option #semicolons;
d764 1
a764 1
	   set_option #op_in_datatype;
d766 1
a766 2
	   clear_option #nj_include;
	   clear_option #nj_local_open;
d770 15
a784 1
	val flavour_option_record =
d786 5
a790 3
	  {NewJersey = select_new_jersey : unit -> unit,
	   Harlequin = select_harlequin : unit -> unit,
	   Strict = select_strict : unit -> unit}
d927 1
a927 1
	    ("Flavour", flavour_option_structure)
d941 1
a941 1
	      c_falvour = flavour_option_record
@


1.29
log
@Added wide ranging option control for NJ flavour, Harlequin flavour,
Strict flavour. These are in Shell.Options.flavour, I need a better name
@
text
@d7 4
d713 1
d724 1
d741 1
d753 1
d765 1
@


1.28
log
@Added make -n control to shell.Options.Compiler
@
text
@d7 3
d21 1
a21 1
 *  > InterPrint signature changes
d611 2
d633 4
d721 44
d899 2
a900 1
	    ("Editor", edit_option_structure)
d913 2
a914 1
	      c_editor = edit_option_record
@


1.27
log
@Changed eval_string function
Changes to use
@
text
@d7 4
d665 1
d676 1
@


1.26
log
@Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d7 3
d386 20
a406 1
        val error_info = Info.default_options
d408 5
a412 10
        val parser_basis = Incremental.parser_basis context
        val inc_options = ShellTypes.make_incremental_options shell_data
        val input_fn =
          let val sref = ref string
          in
            fn _ => let val result = !sref in sref := "" ; result end
          end
        val token_stream = Parser.Lexer.mkTokenStream (input_fn,"Eval input")
        val (topdec,_) = Parser.parse_topdec error_info (options,token_stream,parser_basis)
        val result = Incremental.evaluate_exp_topdec (inc_options,context,topdec)
d923 1
a923 1
               ((fn filename => ActionQueue.add_use (filename)) : string -> unit)
@


1.25
log
@Added Tracing
@
text
@d7 3
d384 1
a384 1
        val error_info = ShellTypes.get_error_info shell_data
d409 1
a409 1
    fun make_shell_structure (shell_data_ref,initial_context,incremental_options) =
d414 3
a418 12
        fun get_error_info () =
          let val (ShellTypes.SHELL_DATA{error_info,...}) = !shell_data_ref
          in 
            error_info
          end

        fun get_output_fn () =
          let val (ShellTypes.SHELL_DATA{output_fn,...}) = !shell_data_ref
          in 
            output_fn
          end

d747 1
a747 1
               ActionQueue.add_make (filename, get_error_info ())) : string -> unit,
d750 1
a750 1
               ActionQueue.add_remake (filename, get_error_info ())) : string -> unit,
d754 1
a754 1
                (get_error_info ())
d760 1
a760 1
                (get_error_info ())
d804 1
a804 1
          (name,get_context (),get_output_fn ())
d809 1
a809 1
          ("",get_context (),get_output_fn ())
d892 1
a892 1
              (get_error_info ())
a901 1
              incremental_options
a915 1
              incremental_options
@


1.24
log
@> InterPrint signature changes
@
text
@d7 3
d106 1
d132 1
d177 1
a177 1
               InspectorValues.Type
d185 2
a186 2
	       ShellTypes.user_options
  sharing type ShellTypes.Context =
d333 21
d432 2
d469 15
d942 2
d952 4
@


1.23
log
@Unified profiling and tracing options into `intercept'.
Removed poly_makestring option.
@
text
@d7 4
d102 1
d127 1
d153 1
a153 1
          InterPrint.ValuePrinter.Options =
d169 1
a169 1
  sharing type Debugger_Types.information = InterPrint.ValuePrinter.DebugInformation =
d171 1
a171 1
  sharing type BasisTypes.Datatypes.Type = InterPrint.ValuePrinter.Type =
a172 2
  sharing type InterPrint.ValuePrinter.printer_descriptor =
               ShellTypes.printer_descriptor
d174 1
a174 1
    	       InterPrint.ValuePrinter.TypeBasis =
a178 2
  sharing type InterPrint.ValuePrinter.print_method_table =
    	       ShellTypes.print_method_table
d183 1
a183 2
  sharing type ActionQueue.ShellData =
	       ShellTypes.ShellData =
a194 1
    structure ValuePrinter = InterPrint.ValuePrinter
d330 1
a330 1
        val printer_descriptor = ShellTypes.make_printer_descriptor shell_data
d335 1
a335 1
        ValuePrinter.stringify_value(printer_descriptor,
@


1.22
log
@Removed pervasive editor.  Changed editor selection type to string.
@
text
@d7 74
a80 72
Revision 1.21  1993/04/21  16:33:12  matthew
Changed interface to tty inspector

Revision 1.20  1993/04/21  13:45:47  richard
Removed old tracing stuff.

Revision 1.19  1993/04/20  15:48:25  matthew
Removed trace functions
Added add_inspect_method function

Revision 1.18  1993/04/15  09:29:02  jont
Added editor options and editor to shell structure

Revision 1.17  1993/04/13  15:39:31  matthew
Added Shell.lambda_switches for control of lambda optimisations
This is probably not a permanent feature.

Revision 1.16  1993/04/13  09:52:30  matthew
Added dynamic value and type printing functions

Revision 1.15  1993/04/08  15:18:07  jont
Minor change to interface to editor

Revision 1.14  1993/04/06  16:33:46  jont
Moved user_options and version from interpreter to main

Revision 1.13  1993/04/02  15:48:28  matthew
Added Shell.eval and Shell.print functions
Signature changes

Revision 1.12  1993/03/30  10:36:39  matthew
Removed read_dot_mlworks
Changed to use a shell_data ref so a shell structure is made only once and
is shared between all shells
Removed a lot on unnecessary casts and added some type constraints

Revision 1.11  1993/03/29  16:16:24  jont
Removed get_pervasive_dir, using one in io instead

Revision 1.10  1993/03/26  17:02:31  matthew
Removed debugger structure.  Break function comes from shell_data

Revision 1.9  1993/03/25  10:15:52  daveb
Added Options.Extension.
ActionQueue.do_actions now takes a single ShellData argument.

Revision 1.8  1993/03/19  19:36:35  matthew
Pass context_ref to ActionQueue.do_actions

Revision 1.7  1993/03/18  18:05:30  matthew
 Added .mlworks facility

Revision 1.6  1993/03/15  17:56:57  matthew
Simplified ShellType types

Revision 1.5  1993/03/12  12:09:36  matthew
Added break and inspector functions
Changed to use ShellData type

Revision 1.4  1993/03/10  18:08:57  jont
Added Editor substructure to the shell

Revision 1.3  1993/03/09  15:48:32  matthew
Options & Info changes
Changes for ShellTypes.ShellData type

Revision 1.2  1993/03/04  10:25:30  daveb
Types.empty_rec_type is now called Types._empty_rectype.

Revision 1.1  1993/03/02  19:21:07  daveb
Initial revision

d604 1
a604 2
          [("generate_tracing_code", mk_ref_fun Types.bool_tyname),
           ("generate_profiling_code", mk_ref_fun Types.bool_tyname),
d614 1
a614 2
          {generate_tracing_code = (make_options_fun #generate_tracing_code) : unit -> bool ref,
           generate_profiling_code = (make_options_fun #generate_profiling_code) : unit -> bool ref,
a634 1
	   ("poly_makestring", mk_ref_fun Types.bool_tyname),
a644 1
	   poly_makestring = (make_options_fun #poly_makestring) : unit -> bool ref,
@


1.21
log
@Changed interface to tty inspector
@
text
@d7 3
d655 1
a655 7
	  [("editor", mk_ref_fun_from_type
	    (get_runtime_type
	     (Ident.LONGTYCON
	      (Ident.PATH
	       (find_symbol"MLWorks",
		Ident.PATH(find_symbol"Editor", Ident.NOPATH)),
	       Ident.TYCON(find_symbol"Editor")))))]
d659 1
a659 1
	  {editor = (make_options_fun #editor) : unit -> MLWorks.Editor.Editor ref}
@


1.20
log
@Removed old tracing stuff.
@
text
@d7 3
d174 1
a174 2
  sharing type Inspector.Context =
               ShellTypes.Context =
d177 2
a178 1
	       ShellTypes.ShellData
d808 1
a808 1
          (fn () => Inspector.inspect_value (ShellTypes.get_context_ref (!shell_data_ref)))
@


1.19
log
@Removed trace functions
Added add_inspect_method function
@
text
@d7 4
d761 1
a761 2
		     ("clear_debug_info", UNBOUND_SCHEME unit_to_unit)
		   ]),
d778 3
a780 4
             { a_clear_debug_info = ActionQueue.add_clear_debug : unit -> unit,
	       a_show_debug_info = show_debug_info : string -> unit,
	       a_show_all_debug_info = show_all_debug_info : unit -> unit
	    }
@


1.18
log
@Added editor options and editor to shell structure
@
text
@d7 3
d87 1
d118 1
d153 2
a154 1
  sharing type BasisTypes.Datatypes.Type = InterPrint.ValuePrinter.Type
d337 3
d396 1
d473 3
d755 1
a755 3
		    [("trace", alpha_beta_bool),
		     ("untrace", alpha_beta_bool),
		     ("show_debug_info", UNBOUND_SCHEME string_to_unit),
d775 1
a775 3
             {a_trace = MLWorks.Internal.Tracing.add_trace : ('a -> 'b) -> bool,
              a_untrace = MLWorks.Internal.Tracing.remove_trace : ('a -> 'b) -> bool,
	       a_clear_debug_info = ActionQueue.add_clear_debug : unit -> unit,
d898 2
a899 1
                   ("print_type",type_to_string)
d909 1
@


1.17
log
@Added Shell.lambda_switches for control of lambda optimisations
This is probably not a permanent feature.
@
text
@d7 4
d75 1
d104 1
d118 1
a118 1
          ActionQueue.Incremental.Datatypes
d174 1
d188 2
d290 1
a290 1
        (Ident.Symbol.symbol_name o getsym)
d303 1
a303 1
        (Ident.Symbol.symbol_name o
d394 12
d408 1
a408 1
          (Ident.LAB (Ident.Symbol.find_symbol "1"),
d411 1
a411 1
                                Ident.LAB (Ident.Symbol.find_symbol "2"),
d432 1
a432 1
			     Ident.TYVAR (Ident.Symbol.find_symbol ("'a"),
d438 1
a438 1
			     Ident.TYVAR (Ident.Symbol.find_symbol ("'b"),
d486 1
a486 1
	   (Ident.VAR(Ident.Symbol.find_symbol name),
d495 1
a495 1
	   (Ident.EXCON(Ident.Symbol.find_symbol name),
d504 1
a504 1
			    Ident.STRID(Ident.Symbol.find_symbol name),
d525 4
a528 1
	fun mk_ref_fun t = FUNTYPE(Types.empty_rectype,CONSTYPE([CONSTYPE([], t)], Types.ref_tyname))
d605 1
a605 1
          MLWorks.Internal.Value.cast 
d609 35
a643 1
          
d736 1
a736 1
		        Ident.VAR(Ident.Symbol.find_symbol name),
d775 3
a777 1
	    ("Extension", extension_structure)
d788 3
a790 1
              c_value_printer = value_printer_record
@


1.16
log
@Added dynamic value and type printing functions
@
text
@d7 3
d456 5
a460 1
          
d822 1
d837 1
@


1.15
log
@Minor change to interface to editor
@
text
@d7 3
d125 1
d298 1
a298 1
    fun print_dynamic (shell_data,dyn : MLWorks.Internal.TypeRep.Dynamic) =
d311 7
d335 1
a335 1
        (MLWorks.Internal.Value.cast result) : MLWorks.Internal.TypeRep.Dynamic
d373 2
a374 1
        fun shell_dyn_print d = print_dynamic (!shell_data_ref,d)
d439 3
d818 2
a819 1
                   ("print",dynamic_to_string)
d826 3
a828 2
                   a_eval = shell_eval_fn : string -> MLWorks.Internal.TypeRep.Dynamic,
                   a_print = shell_dyn_print : MLWorks.Internal.TypeRep.Dynamic -> string,
@


1.14
log
@Moved user_options and version from interpreter to main
@
text
@d7 3
d121 2
a122 1
    	  ActionQueue.Incremental.InterMake.Compiler.Options
d634 1
a634 1
	  case Editor.edit(string, 0) of
@


1.13
log
@Added Shell.eval and Shell.print functions
Signature changes
@
text
@d7 4
d73 1
a73 1
require "user_options";
d75 1
a75 1
require "version";
@


1.12
log
@Removed read_dot_mlworks
Changed to use a shell_data ref so a shell structure is made only once and
is shared between all shells
Removed a lot on unnecessary casts and added some type constraints
@
text
@d7 6
d52 1
d54 1
a54 1
require "../utils/crash";
d64 1
d75 2
d79 1
d86 1
a86 1
  structure Lists : LISTS
a91 1
  structure Crash : CRASH
d99 1
a99 1
          ShellTypes.Incremental.Datatypes
d103 4
a106 2
	  ShellTypes.Incremental.InterMake.Compiler.Info =
    	  TopLevel.Info
d108 1
d111 4
a114 3
    	  ShellTypes.Incremental.InterMake.Compiler.Debugger_Types.Options
  sharing ShellTypes.Incremental =
	  ActionQueue.Incremental
d116 1
a116 1
	  ShellTypes.Incremental.InterMake.Compiler.Absyn.Ident
d118 2
a119 1
	  ShellTypes.Incremental.InterMake.Compiler.Debugger_Types.NewMap
d121 2
d124 7
a130 1
  sharing type ShellTypes.Incremental.InterMake.Compiler.TypeBasis =
d134 2
d141 2
a142 1
	       ShellTypes.Incremental.Context
d147 1
a147 1
    structure Incremental = ShellTypes.Incremental
a153 1
    structure Debugger_Types = Compiler.Debugger_Types
d285 34
a318 1
    
d353 3
d374 1
a374 1
          
d413 6
d793 3
a795 1
		   ("save", string_to_unit)
d802 2
@


1.11
log
@Removed get_pervasive_dir, using one in io instead
@
text
@d7 3
d136 25
d167 1
a167 1
    fun show_debug_info options (name,context) =
a168 20
        fun is_a_substring(a,b) =
          if size a > size b
            then 
              false
          else
            let
              val length_a = size a
              val maximum_index = size b - length_a
              fun search x =
                if x < 0
                  then
                    false
                else
                  if String.substring(b,x,length_a) = a
                    then
                      true
                  else search(x-1)
            in
              search maximum_index
            end
d185 1
a185 2
        output(std_out,Debugger_Types.string_information options (Debugger_Types.INFO filtered_map));
        ()
d261 21
a281 1
    fun get_user_options (ShellTypes.SHELL_DATA{user_options,...}) = user_options
d283 11
a293 1
    fun get_error_info (ShellTypes.SHELL_DATA{error_info,...}) = error_info
a294 9
    fun get_print_options (ShellTypes.SHELL_DATA{options_ref= ref (Options.OPTIONS{print_options,...}),
                                                 ...})
      = print_options

    (* make the visible structures of the shell. This is called each time
     a shell is made *)
   
    fun make_shell_structure (shell_data as ShellTypes.SHELL_DATA data) =
      let
d312 1
a312 4
          make_pair(
                    CONSTYPE([],Types.string_tyname),
                    CONSTYPE([],Types.string_tyname)
                    )
d317 1
a317 1
                            CONSTYPE([],Types.string_tyname),
d349 1
a349 1
                   CONSTYPE([CONSTYPE([],Types.string_tyname)], Types.list_tyname)
d362 1
a362 1
	  CONSTYPE([CONSTYPE([], Types.string_tyname)], Types.ref_tyname)
a363 10
	val x_message = "The X interface is already running\n"

        val xinterface_fn =
	  if (#x_running data) then
	    fn () => (output (std_out, x_message); ())
	  else
            MLWorks.Internal.Value.cast
            (((#mk_xinterface_fn data)
              (ShellTypes.get_listener_args shell_data)) : unit -> unit)

d420 3
a422 2
        fun make_options_fun f =
          MLWorks.Internal.Value.cast (fn () => f ((fn (UserOptions.USER_OPTIONS x) => x)(get_user_options shell_data)))
d426 8
a433 8
          {maximum_depth =  make_options_fun #maximum_depth,
           maximum_shape_depth = make_options_fun #maximum_shape_depth,
           maximum_ref_depth = make_options_fun #maximum_ref_depth,
           maximum_list_size = make_options_fun #maximum_list_size,
           show_fn_details = make_options_fun #show_fn_details,
           show_exn_details = make_options_fun #show_exn_details,
           show_id_class = make_options_fun #show_id_class,
           show_eq_info = make_options_fun #show_eq_info
d436 1
a436 1
	val listing_structure = mk_structure
d445 1
a445 1
	val listing_record =
d448 7
a454 14
	   show_absyn =
	   make_options_fun #show_absyn,
	   show_lambda =
	   make_options_fun #show_lambda,
	   show_opt_lambda =
	   make_options_fun #show_opt_lambda,
	   show_environ =
	   make_options_fun #show_environ,
	   show_mir =
	   make_options_fun #show_mir,
	   show_opt_mir =
	   make_options_fun #show_opt_mir,
	   show_mach =
	   make_options_fun #show_mach
d469 7
a475 14
          {generate_tracing_code =
           make_options_fun #generate_tracing_code,
           generate_profiling_code =
           make_options_fun #generate_profiling_code,
           generate_debug_info =
           make_options_fun #generate_debug_info,
           show_debug_warnings =
           make_options_fun #show_debug_warnings,
           optimise_leaf_fns =
           make_options_fun #optimise_leaf_fns,
           optimise_tail_calls =
           make_options_fun #optimise_tail_calls,
           optimise_self_tail_calls =
           make_options_fun #optimise_self_tail_calls
d485 2
a486 4
          {require_keyword =
           make_options_fun #require_keyword,
           type_dynamic =
           make_options_fun #type_dynamic
d499 1
a499 1
          
d501 27
a527 37
	     MLWorks.Internal.Value.cast {
	       a_signatures =
	         MLWorks.Internal.Value.cast(
	           fn () => show_signatures (ShellTypes.get_current_context shell_data)
	         ),
	       a_functors =
	         MLWorks.Internal.Value.cast(
	           fn () => show_functors (ShellTypes.get_current_context shell_data)
	         ),
	       a_structures =
	         MLWorks.Internal.Value.cast(
	           fn () => show_structures (ShellTypes.get_current_context shell_data)
	         ),
	       a_types =
	         MLWorks.Internal.Value.cast(
	           fn () => show_types (ShellTypes.get_current_context shell_data)
	         ),
	       a_exceptions =
               MLWorks.Internal.Value.cast(fn () => show_exceptions (ShellTypes.get_current_context shell_data)),
	       a_constructors =
	         MLWorks.Internal.Value.cast(
	           fn () => show_values
	    		  (fn (Ident.CON _) => true | _ => false)
                                             (ShellTypes.get_current_context shell_data)
	         ),
	       a_variables =
	         MLWorks.Internal.Value.cast(
	           fn () => show_values
	    		  (fn (Ident.VAR _) => true | _ => false)
	    		  (ShellTypes.get_current_context shell_data)
	         ),
	       a_values =
	         MLWorks.Internal.Value.cast(
	           fn () => show_values
	    		  (fn _ => true)
	    		  (ShellTypes.get_current_context shell_data))
	    }
d537 20
a556 28
	     MLWorks.Internal.Value.cast{
	       a_make =
	         MLWorks.Internal.Value.cast(
	           fn filename =>
		     ActionQueue.add_make (filename, get_error_info shell_data)
	         ),
	       a_remake_file =
                 MLWorks.Internal.Value.cast(
                   fn filename =>
		     ActionQueue.add_remake (filename, get_error_info shell_data)
	         ),
	       a_compile =
	         MLWorks.Internal.Value.cast
                 (fn filename =>
                  (ShellTypes.update_options shell_data;
                   TopLevel.compile_file
                   (get_error_info shell_data)
                   (ShellTypes.get_current_options shell_data)
                   filename)),
	       a_recompile =
	         MLWorks.Internal.Value.cast
                 (fn filename =>
                  (ShellTypes.update_options shell_data;
                   Recompile.recompile
                   (get_error_info shell_data)
                   (ShellTypes.get_current_options shell_data)
                   filename))
                 }
d568 1
a568 1
	   a_edit = MLWorks.Internal.Value.cast(edit_function)
d597 10
d608 6
a613 16
             MLWorks.Internal.Value.cast{
               a_trace =
                 MLWorks.Internal.Value.cast
                   MLWorks.Internal.Tracing.add_trace,
               a_untrace =
                 MLWorks.Internal.Value.cast
                   MLWorks.Internal.Tracing.remove_trace,
	       a_clear_debug_info =
	         MLWorks.Internal.Value.cast
		   (fn () => ActionQueue.add_clear_debug ()),
	       a_show_debug_info =
	         MLWorks.Internal.Value.cast
                   (fn name => show_debug_info (get_print_options shell_data) (name,ShellTypes.get_current_context shell_data)),
	       a_show_all_debug_info =
	         MLWorks.Internal.Value.cast
                   (fn () => show_debug_info (get_print_options shell_data) ("",ShellTypes.get_current_context shell_data))
d619 1
a619 1
	    ("Listing", listing_structure),
d627 5
a631 4
             MLWorks.Internal.Value.cast{
	       c_value_printer = value_printer_record,
	       c_compiler = compiler_record,
	       c_extension = extension_record
d634 57
a690 51
        val break_fn =
          MLWorks.Internal.Value.cast
          ((#break_function data) : string -> unit)

        val inspect_fn =
          (fn () => Inspector.inspect_value (ShellTypes.get_context_ref shell_data)) : unit -> unit

	val save_fn =
              MLWorks.Internal.Value.cast (
	        fn filename =>
		  let
                    val old_level =
		      !MLWorks.Internal.Runtime.StorageManager.gc_message_level

		    val _ = ShellTypes.update_options shell_data

                    fun collect 200 = ()
                      | collect n = 
                        (MLWorks.Internal.Runtime.StorageManager.interface (20,n);
                         collect(n+1)
                         )
                  in
                    MLWorks.Internal.Runtime.StorageManager.gc_message_level :=
		      ~1;
                    collect 0
                    handle MLWorks.Internal.Runtime.StorageManager.StorageManager _ => ();
                    MLWorks.Internal.Runtime.StorageManager.gc_message_level :=
		      old_level;
                    MLWorks.save (
		      filename,
		      fn () =>
                        MLWorks.IO.with_standard_output
                        MLWorks.IO.terminal_out
                        (fn () =>
                         MLWorks.IO.with_standard_input
                         MLWorks.IO.terminal_in
                         (fn () =>
                          (output (std_out, Version.version_string ^ "\n");
                           (case Io.get_pervasive_dir(
				   MLWorks.OS.Unix.environment ()) of
			      Option.PRESENT str =>
				TopLevel.pervasive_library_dir := str
                            | _ => ());
                              (#mk_tty_listener data)
                              (ShellTypes.get_listener_args shell_data)))))
                    handle MLWorks.Save message =>
                      Info.error'
                      (get_error_info shell_data)
                      (Info.FATAL, Info.Location.UNKNOWN, message);
                    ()
		end)
d697 7
a703 7
                (ShellTypes.make_incremental_options shell_data)
                (ShellTypes.get_current_context shell_data,
                 "use",
                 UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rectype)),
                 MLWorks.Internal.Value.cast
                 (fn filename => ActionQueue.add_use (filename))
	      )
d712 5
a716 5
              (ShellTypes.make_incremental_options shell_data)
                (context,
	         "Shell",
		 mk_mixed_structure
		 (
a724 1
                   ("break",string_to_unit),
d733 4
a736 5
		   a_exit = #exit_fn data,
		   a_xinterface = xinterface_fn,
		   a_break = break_fn,
                   a_inspect = inspect_fn,
		   a_save = save_fn,
a745 35

        fun read_dot_mlworks context =
          let
            val output_fn = #output_fn data
            exception NoHome
            fun do_use (filename,context) =
              let val context_ref = ref context
              in
                ActionQueue.add_use filename;
                ActionQueue.do_actions shell_data;
                !context_ref
              end

            fun get_shell_variable (varname) =
              let
                val testsize = (size varname) + 1
                val teststring = varname ^ "="
                fun find_var [] = raise NoHome
                  | find_var (binding :: l) =
                    if (size binding >= testsize
                        andalso
                        (String.substring (binding,0,testsize) = teststring))
                      then
                        String.substring (binding,testsize,(size binding) - testsize)
                    else
                      find_var l
              in
                find_var (MLWorks.OS.Unix.environment ())
              end
          in
            do_use (get_shell_variable "HOME" ^ "/.mlworks",context)
            handle NoHome => (output_fn "No HOME variable set\n"; context)
                 | Io _ => (output_fn "No .mlworks found\n"; context)
                 | exn => (output_fn "Error occured using MLWorks"; context)
          end
d747 1
a747 1
	read_dot_mlworks context
@


1.10
log
@Removed debugger structure.  Break function comes from shell_data
@
text
@d7 3
d52 1
d75 1
d102 1
d129 1
d578 2
a579 2
	    Editor.Option.ABSENT => ()
	  | Editor.Option.PRESENT(s1, s2) =>
d689 1
a689 1
                           (case Incremental.get_pervasive_dir(
d691 1
a691 1
			      InterMake.FileName.Option.PRESENT str =>
@


1.9
log
@Added Options.Extension.
ActionQueue.do_actions now takes a single ShellData argument.
@
text
@d7 4
a49 1
require "../debugger/ml_debugger";
a76 1
  structure Ml_Debugger : ML_DEBUGGER
a91 1
	  Ml_Debugger.Incremental =
a92 2
  sharing Ml_Debugger.ValuePrinter =
	  InterPrint.ValuePrinter
d97 1
a643 47
        fun break_function (shell_data as ShellTypes.SHELL_DATA{options_ref,
                                                                context_ref,
                                                                print_method_table_ref,
                                                                user_options,
                                                                error_info,
                                                                name_monitor,
                                                                debugger,
                                                                prompter,
                                                                mk_xinterface_fn,
                                                                mk_tty_listener,
                                                                ...}) =
          let
            val call_debugger =
              Ml_Debugger.ml_debugger 
              Ml_Debugger.TERMINAL
              (!print_method_table_ref,
               ShellTypes.make_incremental_options shell_data,
               context_ref,
               "")
              (fn context' =>
               (mk_tty_listener 
               (ShellTypes.LISTENER_ARGS
                {options_ref = ref (!options_ref),
                 context_ref = ref context',
                 print_method_table_ref = ref (!print_method_table_ref),
                 user_options = UserOptions.make_user_options (!options_ref),
                 error_info = error_info,
                 name_monitor = name_monitor,
                 prompter = prompter,
                 mk_xinterface_fn = mk_xinterface_fn});
               ()))
        in
          MLWorks.Internal.Value.frame_call
            (fn base_frame =>
             (fn s => (call_debugger 
                       (Ml_Debugger.BASE_FRAME base_frame)
                       (Ml_Debugger.BREAK s,
                        Ml_Debugger.POSSIBLE (
                          "Return to TopLevel by raising Interrupt",
                          Ml_Debugger.DO_RAISE Interrupt),
                        Ml_Debugger.POSSIBLE (
                          "Continue interrupted code",
                          Ml_Debugger.NORMAL_RETURN
                        ));
                       ())))
          end

d646 1
a646 1
          ((fn s => break_function shell_data s) : string -> unit)
@


1.8
log
@Pass context_ref to ActionQueue.do_actions
@
text
@d7 3
a69 1
  structure ShellTypes: SHELL_TYPES
d72 1
d80 18
a97 9
  sharing Types.Datatypes.Ident = IdentPrint.Ident
  sharing Recompile.Info = ShellTypes.Incremental.InterMake.Compiler.Info =
    TopLevel.Info
  sharing TopLevel.Options = UserOptions.Options = Recompile.Options = 
    ShellTypes.Incremental.InterMake.Compiler.Debugger_Types.Options
  sharing ShellTypes.Incremental = ActionQueue.Incremental = Ml_Debugger.Incremental
  sharing Ml_Debugger.ValuePrinter = InterPrint.ValuePrinter
  sharing Types.Datatypes.Ident = ShellTypes.Incremental.InterMake.Compiler.Absyn.Ident
  sharing Types.Datatypes.NewMap = ShellTypes.Incremental.InterMake.Compiler.Debugger_Types.NewMap
d99 3
a101 1
    InterPrint.ValuePrinter.TypeBasis = TopLevel.TypeBasis = BasisTypes.Basis
d103 7
a109 4
    ShellTypes.print_method_table = ActionQueue.print_method_table
  sharing type UserOptions.user_options = ShellTypes.user_options
  sharing type Inspector.Context = ShellTypes.Incremental.Context

d413 1
a413 1
	val internals_structure = mk_structure
d422 1
a422 1
	val internals_record =
d444 6
a449 6
	     ("generate_debug_info", mk_ref_fun Types.bool_tyname),
	     ("show_debug_warnings", mk_ref_fun Types.bool_tyname),
	     ("optimise_leaf_fns", mk_ref_fun Types.bool_tyname),
	     ("optimise_tail_calls", mk_ref_fun Types.bool_tyname),
	     ("optimise_self_tail_calls", mk_ref_fun Types.bool_tyname)
             ]
d469 13
d630 2
a631 1
	    ("Internals", internals_structure)
d641 1
a641 1
	       c_internals = internals_record
d808 1
a808 5
                ActionQueue.do_actions(0,
                                       context_ref,
                                       output_fn,
                                       ShellTypes.make_incremental_options shell_data,
                                       ShellTypes.get_current_print_method_table shell_data);
@


1.7
log
@ Added .mlworks facility
@
text
@d7 3
d322 2
a323 1
            (((#mk_xinterface_fn data) (ShellTypes.get_listener_args shell_data)) : unit -> unit)
d774 10
a783 6
              (ActionQueue.add_use filename;
               ActionQueue.do_actions(0,
                                      context,
                                      output_fn,
                                      ShellTypes.make_incremental_options shell_data,
                                      ShellTypes.get_current_print_method_table shell_data))
a806 2


@


1.6
log
@Simplified ShellType types
@
text
@d7 3
d764 37
d802 1
a802 1
	context
@


1.5
log
@Added break and inspector functions
Changed to use ShellData type
@
text
@d7 4
d101 1
a101 1
    type ShellArgs = ShellTypes.ShellArgs
d235 1
a235 7
    fun make_shell_structure
      (ShellTypes.SHELL_ARGS(shell_data,
                             exit_fn,
                             x_running,
                             mk_xinterface_fn,
                             tty_listener	(* for save option *)
                             )) =
d312 1
a312 1
	  if x_running then
d316 2
a317 1
            (mk_xinterface_fn shell_data)
d613 7
a619 4
                                                                prompter}) =
        let
          val call_debugger =
            Ml_Debugger.ml_debugger 
d626 1
a626 1
               (tty_listener 
d628 8
a635 9
                (ShellTypes.SHELL_DATA {options_ref = ref (!options_ref),
                                       context_ref = ref context',
                                       print_method_table_ref = ref (!print_method_table_ref),
                                       user_options = UserOptions.make_user_options (!options_ref),
                                       error_info = error_info,
                                       name_monitor = name_monitor,
                                       debugger = debugger,
                                       prompter = prompter},
               mk_xinterface_fn));
d696 2
a697 4
                            tty_listener(ShellTypes.LISTENER_ARGS
                                         (ShellTypes.copy_shell_data shell_data,
                                          mk_xinterface_fn))
                            ))))
d701 2
a702 1
                      (Info.FATAL, Info.Location.UNKNOWN, message)
d747 1
a747 1
		   a_exit = exit_fn,
@


1.4
log
@Added Editor substructure to the shell
@
text
@d7 3
d30 1
d33 2
d51 1
d60 2
d65 2
a66 2
          Valenv.Datatypes = Scheme.Datatypes = TopLevel.BasisTypes.Datatypes

a67 4

  sharing TopLevel.MirTypes =
	  ShellTypes.Incremental.InterMake.Compiler.MirTypes

d69 5
a73 7
    TopLevel.Parser.Lexer.Info

  sharing TopLevel.MirTypes.Debugger_Types.Options =
    UserOptions.Options = Recompile.Options

  sharing ShellTypes.Incremental = ActionQueue.Incremental

d75 1
a75 1

d77 1
a77 1
    InterPrint.ValuePrinter.TypeBasis
d80 2
a81 3
  sharing type UserOptions.user_options =
	       ShellTypes.user_options
  sharing type TopLevel.BasisTypes.Basis = InterPrint.ValuePrinter.TypeBasis
d88 1
a88 1
    structure BasisTypes = TopLevel.BasisTypes
d92 1
a92 1
    structure Debugger_Types = Compiler.MirTypes.Debugger_Types
d95 1
d134 1
a134 1
            Debugger_Types.Datatypes.NewMap.fold
d138 1
a138 1
                 Debugger_Types.Datatypes.NewMap.define(old_map,from,to)
d150 1
a150 1
      (Datatypes.NewMap.domain (Incremental.signatures context))
d160 1
a160 1
        (Datatypes.NewMap.domain funmap)
d172 1
a172 1
        (Datatypes.NewMap.domain strmap)
d184 1
a184 1
        (Datatypes.NewMap.domain tymap)
d201 1
a201 1
        (Lists.filterp p (Datatypes.NewMap.domain valmap))
d217 1
a217 1
        (Datatypes.NewMap.domain exnmap)
d224 1
a224 1
    fun get_print_options (ShellTypes.SHELL_DATA{options_ref= ref (Options.OPTIONS(_,_,print_options)),
d607 8
a614 10
(*
      fun break_function(options as
			   Incremental.OPTIONS{
			     make_options,
                             compiler_options as
			       Compiler.MirTypes.OPTIONS{error_info,...},
			   ...},
                         context,
                         current_module
                        ) =
a615 1
          val _ = ShellTypes.update_options shell_data
d619 4
a622 5
              (get_error_info shell_data)
              (get_print_options shell_data,
               get_current_options shell_data,
               get_current_context shell_data,
               current_module)
d626 10
a635 6
               (ShellTypes.SHELL_DATA {options = options',
                                       context_ref = ref context'
                                       prompter = prompter,
                                       print_method_table = print_method_table
                                       user_options = UserOptions.make_user_options options'},
               mk_xinterface_fn))))
d654 4
a657 8
          ((fn s =>
            break_function (#2(UserOptions.new_shell_options (UserOptions.USER_OPTIONS user_options,
						  get_error_info shell_data,
					          shell_options)),
                            ShellTypes.get_current_context shell_data,
                            "Foo")
            s) : string -> unit)
*)
d695 4
a698 7
                            let val ShellTypes.SHELL_DATA(data) = shell_data
                            in
                              tty_listener(ShellTypes.LISTENER_ARGS
                                           (ShellTypes.copy_shell_data shell_data,
                                            mk_xinterface_fn))
                            end
                          ))))
a737 1
		   (*
d739 1
a739 1
		   *)
d748 3
a751 4
		   (*
		   a_break = break_fn,
		   *)
		   a_xinterface = xinterface_fn,
@


1.3
log
@Options & Info changes
Changes for ShellTypes.ShellData type
@
text
@d7 4
d29 1
d48 1
a499 1

d530 13
d737 1
d761 1
@


1.2
log
@Types.empty_rec_type is now called Types._empty_rectype.
@
text
@d7 3
a48 13
  sharing InterPrint.Incremental =
	  ShellTypes.Incremental =
	  UserOptions.Incremental =
	  ActionQueue.Incremental

  sharing type InterPrint.ValuePrinter.printer_descriptor =
  	       UserOptions.printer_descriptor =
  	       ShellTypes.printer_descriptor =
	       ActionQueue.printer_descriptor

  sharing type UserOptions.user_options =
	       ShellTypes.user_options

d55 20
a74 2
	  InterPrint.Incremental.InterMake.Compiler.MirTypes =
	  Recompile.MirTypes
d77 1
a77 1
    structure Incremental = InterPrint.Incremental
d80 1
a80 3
    structure Parser = Compiler.Parser
    structure Lexer = Parser.Lexer
    structure BasisTypes = InterMake.Compiler.BasisTypes
d83 1
a83 1
    structure Info = Lexer.Info
d85 2
d89 1
a89 1
    type Context = Incremental.context
d211 8
d222 6
a227 17
    fun make_shell_structure (current_context,
			      ShellTypes.SHELL_ARGS (
                              prompter,
                              shell_options as Incremental.OPTIONS
                              {make_options,
                               compiler_options as Compiler.MirTypes.OPTIONS
                               {info_opts = info_opts as Info.OPTIONS info_rec,
                                ...
                                },
                               ...
                               },
                              print_options,
                              UserOptions.USER_OPTIONS user_options,
                              exit_fn,
			      x_running,
                              mk_xinterface_fn,
			      tty_listener	(* for save option *)
d231 1
a231 1
          
a235 2
	val context = !current_context

d309 1
a309 4
              ( mk_xinterface_fn (UserOptions.USER_OPTIONS user_options,
				  print_options, shell_options,
			          info_opts, current_context, prompter) )
          
d353 1
a353 1
	fun mk_ref t = CONSTYPE([CONSTYPE([], t)], Types.ref_tyname)
d356 8
a363 8
          [("show_fn_details",  mk_ref Types.bool_tyname),
           ("show_exn_details",  mk_ref Types.bool_tyname),
           ("show_id_class",  mk_ref Types.bool_tyname),
           ("show_eq_info",  mk_ref Types.bool_tyname),
           ("maximum_list_size",  mk_ref Types.int_tyname),
           ("maximum_ref_depth",  mk_ref Types.int_tyname),
           ("maximum_shape_depth",  mk_ref Types.int_tyname),
           ("maximum_depth",  mk_ref Types.int_tyname)
d366 3
d371 8
a378 31
          {maximum_depth =
           MLWorks.Internal.Value.cast
           (#maximum_depth user_options),
           maximum_shape_depth =
           MLWorks.Internal.Value.cast(
                                       #maximum_shape_depth user_options
                                       ),
           maximum_ref_depth =
           MLWorks.Internal.Value.cast(
                                       #maximum_ref_depth user_options
                                       ),
           maximum_list_size =
           MLWorks.Internal.Value.cast(
                                       #maximum_list_size user_options
                                       ),
           show_fn_details =
           MLWorks.Internal.Value.cast(
                                       #show_fn_details user_options
                                       ),
           show_exn_details =
           MLWorks.Internal.Value.cast(
                                       #show_exn_details user_options
                                       ),
           show_id_class =
           MLWorks.Internal.Value.cast(
                                       #show_id_class user_options
                                       ),
           show_eq_info =
           MLWorks.Internal.Value.cast(
                                       #show_eq_info user_options
                                       )
d382 7
a388 7
	  [("show_absyn", mk_ref Types.bool_tyname),
	   ("show_lambda", mk_ref Types.bool_tyname),
	   ("show_opt_lambda", mk_ref Types.bool_tyname),
	   ("show_environ", mk_ref Types.bool_tyname),
	   ("show_mir", mk_ref Types.bool_tyname),
	   ("show_opt_mir", mk_ref Types.bool_tyname),
	   ("show_mach", mk_ref Types.bool_tyname)]
d394 1
a394 1
	   MLWorks.Internal.Value.cast(#show_absyn user_options),
d396 1
a396 1
	   MLWorks.Internal.Value.cast(#show_lambda user_options),
d398 1
a398 1
	   MLWorks.Internal.Value.cast(#show_opt_lambda user_options),
d400 1
a400 1
	   MLWorks.Internal.Value.cast(#show_environ user_options),
d402 1
a402 1
	   MLWorks.Internal.Value.cast(#show_mir user_options),
d404 1
a404 1
	   MLWorks.Internal.Value.cast(#show_opt_mir user_options),
d406 1
a406 1
	   MLWorks.Internal.Value.cast(#show_mach user_options)
d410 7
a416 7
          [("generate_tracing_code", mk_ref Types.bool_tyname),
           ("generate_profiling_code", mk_ref Types.bool_tyname),
	     ("generate_debug_info", mk_ref Types.bool_tyname),
	     ("show_debug_warnings", mk_ref Types.bool_tyname),
	     ("optimise_leaf_fns", mk_ref Types.bool_tyname),
	     ("optimise_tail_calls", mk_ref Types.bool_tyname),
	     ("optimise_self_tail_calls", mk_ref Types.bool_tyname)
d422 1
a422 3
           MLWorks.Internal.Value.cast(
                                       #generate_tracing_code user_options
                                       ),
d424 1
a424 2
           MLWorks.Internal.Value.cast
           (#generate_profiling_code user_options),
d426 1
a426 3
           MLWorks.Internal.Value.cast(
                                       #generate_debug_info user_options
                                       ),
d428 1
a428 3
           MLWorks.Internal.Value.cast(
                                       #show_debug_warnings user_options
                                       ),
d430 1
a430 3
           MLWorks.Internal.Value.cast(
                                       #optimise_leaf_fns user_options
                                       ),
d432 1
a432 3
           MLWorks.Internal.Value.cast(
                                       #optimise_tail_calls user_options
	         ),
d434 1
a434 3
           MLWorks.Internal.Value.cast(
                                       #optimise_self_tail_calls user_options
                                       )
d452 1
a452 1
	           fn () => show_signatures (context)
d456 1
a456 1
	           fn () => show_functors (context)
d460 1
a460 1
	           fn () => show_structures (context)
d464 1
a464 1
	           fn () => show_types (context)
d467 1
a467 3
	         MLWorks.Internal.Value.cast(
	           fn () => show_exceptions (context)
	         ),
d472 1
a472 1
	    		  (context)
d478 1
a478 1
	    		  (context)
d484 1
a484 2
	    		  (context)
	         )
d500 1
a500 1
		     ActionQueue.add_make (filename, info_opts)
d505 1
a505 1
		     ActionQueue.add_remake (filename, info_opts)
d508 7
a514 21
	         MLWorks.Internal.Value.cast (
		   fn filename =>
		     let
		       val info_options' =
			 UserOptions.new_info_options (
			   UserOptions.USER_OPTIONS user_options,
			   info_opts
			 )

		       val compiler_options' =
			 UserOptions.new_compiler_options (
			   UserOptions.USER_OPTIONS user_options,
			   info_options'
			 )
		     in
		       TopLevel.compile_file
		         info_options'
		         compiler_options'
		         filename
		     end
		 ),
d516 8
a523 22
	         MLWorks.Internal.Value.cast (
		   fn filename =>
		     let
		       val info_options' =
			 UserOptions.new_info_options (
			   UserOptions.USER_OPTIONS user_options,
			   info_opts
			 )

		       val compiler_options' =
			 UserOptions.new_compiler_options (
			   UserOptions.USER_OPTIONS user_options,
			   info_options'
			 )
		     in
		       Recompile.recompile
		         info_options'
		         compiler_options'
		         filename
		     end
		 )
	    }
d564 1
a564 1
                   (fn name => show_debug_info info_opts (name,context)),
d567 1
a567 1
                   (fn () => show_debug_info info_opts ("",context))
d591 1
a591 1
			       Compiler.MirTypes.OPTIONS{info_opts,...},
d597 1
a597 8
          val print_options' = UserOptions.new_pr_options (UserOptions.USER_OPTIONS user_options, print_options)
          val (info_opts',
               options' as Incremental.OPTIONS {
                 compiler_options = compiler_options',
                 make_options = make_options',
                 ...
              }) = 
            UserOptions.new_shell_options (UserOptions.USER_OPTIONS user_options, info_opts, options)
d601 5
a605 2
              info_opts'
              (print_options', options', context,current_module)
d607 8
a614 10
               (tty_listener (ShellTypes.LISTENER_ARGS(
                 (compiler_options',
                  make_options'
                 ),
                 context',
                 prompter,
                 print_options'
                ));
                ()
            ))
d635 1
a635 1
						  info_opts,
d637 1
a637 1
                            !current_context,
d649 1
a649 11
		    val (info_options',
			 Incremental.OPTIONS {
			   compiler_options = compiler_options',
			   make_options = make_options',
			   ...
			}) =
		      UserOptions.new_shell_options (
			UserOptions.USER_OPTIONS user_options,
			info_opts,
			shell_options
		      )
d678 6
a683 7
                           tty_listener (ShellTypes.LISTENER_ARGS(
                                  (compiler_options', make_options'),
                                  !current_context,
				  prompter,
                                  UserOptions.new_pr_options (UserOptions.USER_OPTIONS user_options, print_options),
				  mk_xinterface_fn
                                  ))
d687 2
a688 2
		        info_opts
		        (Info.FATAL, Lexer.Info.Location.UNKNOWN, message)
d695 6
a700 7
              Incremental.add_value shell_options
              (context,
               "use",
               UNBOUND_SCHEME (
                              FUNTYPE (Types.string_type, Types.empty_rectype)
                               ),
               MLWorks.Internal.Value.cast
d711 1
a711 1
	        shell_options
a747 1
	current_context := context;
@


1.1
log
@Initial revision
@
text
@d6 4
a9 1
 *  $Log$
d240 1
a240 1
                                Types.empty_rec_type
d253 1
a253 1
                            FUNTYPE(Types.string_type, Types.empty_rec_type)
d283 1
a283 1
                   Types.empty_rec_type,
d288 1
a288 1
          FUNTYPE (Types.empty_rec_type, Types.empty_rec_type)
d291 1
a291 1
          FUNTYPE (Types.int_type, Types.empty_rec_type)
d294 1
a294 1
          FUNTYPE (Types.string_type, Types.empty_rec_type)
d780 1
a780 1
                              FUNTYPE (Types.string_type, Types.empty_rec_type)
@
