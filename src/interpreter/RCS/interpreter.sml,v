head	1.61;
access;
symbols
	MLW_daveb_inline_1_4_99:1.60.1
	MLWorks_21c0_1999_03_25:1.60
	MLWorks_20c1_1998_08_20:1.59
	MLWorks_20c0_1998_08_04:1.59
	MLWorks_20b2c2_1998_06_19:1.58
	MLWorks_20b2_Windows_1998_06_12:1.58
	MLWorks_20b1c1_1998_05_07:1.57
	MLWorks_20b0_1998_04_07:1.57
	MLWorks_20b0_1998_03_20:1.57
	MLWorks_20m2_1998_02_16:1.57
	MLWorks_20m1_1997_10_23:1.57
	MLWorks_11r1:1.56.1.1.1.1.1
	MLWorks_workspace_97:1.57.2
	MLWorks_dt_wizard:1.57.1
	MLWorks_11c0_1997_09_09:1.56.1.1.1.1
	MLWorks_10r3:1.56.1.1.3
	MLWorks_10r2_551:1.56.1.1.2
	MLWorks_11:1.56.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.56.1.1
	MLWorks_20m0_1997_06_20:1.57
	MLWorks_1_0_r2c2_1997_06_14:1.56.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.56.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.56.1
	MLWorks_BugFix_1997_04_24:1.56
	MLWorks_1_0_r2_Win32_1997_04_11:1.56
	MLWorks_1_0_r2_Unix_1997_04_04:1.56
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.55.3.1.1
	MLWorks_gui_1996_12_18:1.55.4
	MLWorks_1_0_Win32_1996_12_17:1.55.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.55.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.55.1.1
	MLWorks_1_0_Irix_1996_11_28:1.55.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.55.2
	MLWorks_1_0_Unix_1996_11_14:1.55.1
	MLWorks_Open_Beta2_1996_10_11:1.54.3
	MLWorks_License_dev:1.54.2
	MLWorks_1_open_beta_1996_09_13:1.54.1
	MLWorks_Open_Beta_1996_08_22:1.54
	MLWorks_Beta_1996_07_02:1.53
	MLWorks_Beta_1996_06_07:1.53
	MLWorks_Beta_1996_06_06:1.53
	MLWorks_Beta_1996_06_05:1.53
	MLWorks_Beta_1996_06_03:1.53
	MLWorks_Beta_1996_05_31:1.53
	MLWorks_Beta_1996_05_30:1.51
	ML_beta_release_12/08/94:1.30
	ML_beta_release_03/08/94:1.30
	ML_revised_beta_release_25/05/94:1.26
	ML_final_beta_release_02/03/94:1.26
	mlworks-28-01-1994:1.24
	Release:1.23
	mlworks-beta-01-09-1993:1.23
	MLWorks-1-0-4-29/01/1993:1.5
	MLWorks-1-0-3-21/12/1992:1.5
	MLWorks-1-0-2-15/12/1992:1.5
	MLWorks-1-0-1-04/12/1992:1.4;
locks; strict;
comment	@ * @;


1.61
date	99.05.13.13.51.02;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	99.02.02.16.00.27;	author mitchell;	state Exp;
branches
	1.60.1.1;
next	1.59;

1.59
date	98.07.07.13.46.16;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	98.05.26.13.56.24;	author mitchell;	state Exp;
branches;
next	1.57;

1.57
date	97.05.19.10.49.09;	author jont;	state Exp;
branches
	1.57.1.1
	1.57.2.1;
next	1.56;

1.56
date	96.12.18.17.17.01;	author andreww;	state Exp;
branches
	1.56.1.1;
next	1.55;

1.55
date	96.10.30.15.29.33;	author io;	state Exp;
branches
	1.55.1.1
	1.55.2.1
	1.55.3.1
	1.55.4.1;
next	1.54;

1.54
date	96.07.03.11.58.39;	author andreww;	state Exp;
branches
	1.54.1.1
	1.54.2.1
	1.54.3.1;
next	1.53;

1.53
date	96.05.30.15.44.41;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	96.05.30.13.20.05;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	96.05.16.13.07.53;	author stephenb;	state Exp;
branches;
next	1.50;

1.50
date	96.05.08.13.29.54;	author stephenb;	state Exp;
branches;
next	1.49;

1.49
date	96.05.01.10.31.54;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	96.04.17.14.51.58;	author stephenb;	state Exp;
branches;
next	1.47;

1.47
date	96.04.04.10.17.12;	author stephenb;	state Exp;
branches;
next	1.46;

1.46
date	96.01.16.12.19.02;	author nickb;	state Exp;
branches;
next	1.45;

1.45
date	96.01.15.14.04.11;	author stephenb;	state Exp;
branches;
next	1.44;

1.44
date	96.01.12.12.09.27;	author stephenb;	state Exp;
branches;
next	1.43;

1.43
date	96.01.08.16.28.06;	author nickb;	state Exp;
branches;
next	1.42;

1.42
date	95.07.12.13.24.41;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	95.06.15.13.24.30;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.06.14.13.06.10;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	95.06.02.15.01.53;	author nickb;	state Exp;
branches;
next	1.38;

1.38
date	95.05.26.16.38.04;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	95.05.11.10.42.59;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	95.05.02.15.24.40;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	95.05.01.11.13.12;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	95.04.06.09.30.22;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	95.03.01.11.54.48;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	95.01.27.10.23.57;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	94.12.07.11.32.18;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	94.08.01.12.39.17;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	94.07.18.09.35.25;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	94.07.08.10.16.14;	author nickh;	state Exp;
branches;
next	1.27;

1.27
date	94.06.22.09.48.28;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	94.03.01.15.34.14;	author nosa;	state Exp;
branches;
next	1.25;

1.25
date	94.03.01.15.10.49;	author nosa;	state Exp;
branches;
next	1.24;

1.24
date	93.11.09.15.49.00;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	93.06.03.17.55.52;	author daveb;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	93.05.18.15.21.57;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	93.05.11.09.50.12;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	93.05.10.16.27.01;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	93.05.10.14.21.35;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	93.05.10.12.03.29;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.05.06.15.32.33;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.05.04.17.23.11;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.04.26.12.11.32;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.04.13.16.16.16;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.04.06.16.10.24;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	93.04.02.19.03.01;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.03.30.15.55.36;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.03.30.12.59.25;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.03.15.16.52.08;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.03.11.14.49.51;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.03.08.14.53.40;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.03.01.17.51.28;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	92.12.08.15.15.59;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.12.04.15.32.00;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.11.12.16.49.40;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.11.07.15.13.17;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.10.15.07.16.05;	author richard;	state Exp;
branches;
next	;

1.23.1.1
date	93.06.03.17.55.52;	author jont;	state Exp;
branches;
next	;

1.54.1.1
date	96.09.13.11.15.31;	author hope;	state Exp;
branches;
next	;

1.54.2.1
date	96.10.07.16.05.46;	author hope;	state Exp;
branches;
next	;

1.54.3.1
date	96.10.17.11.24.03;	author hope;	state Exp;
branches;
next	;

1.55.1.1
date	96.11.14.12.48.32;	author hope;	state Exp;
branches
	1.55.1.1.1.1;
next	;

1.55.1.1.1.1
date	96.11.28.15.00.04;	author hope;	state Exp;
branches;
next	;

1.55.2.1
date	96.11.22.18.08.25;	author hope;	state Exp;
branches;
next	;

1.55.3.1
date	96.12.17.17.47.07;	author hope;	state Exp;
branches
	1.55.3.1.1.1;
next	;

1.55.3.1.1.1
date	97.02.24.11.36.48;	author hope;	state Exp;
branches;
next	;

1.55.4.1
date	96.12.18.09.41.07;	author hope;	state Exp;
branches;
next	;

1.56.1.1
date	97.05.12.10.33.33;	author hope;	state Exp;
branches
	1.56.1.1.1.1
	1.56.1.1.2.1
	1.56.1.1.3.1;
next	;

1.56.1.1.1.1
date	97.07.28.18.19.28;	author daveb;	state Exp;
branches
	1.56.1.1.1.1.1.1;
next	;

1.56.1.1.1.1.1.1
date	97.10.07.11.44.37;	author jkbrook;	state Exp;
branches;
next	;

1.56.1.1.2.1
date	97.09.08.17.13.04;	author daveb;	state Exp;
branches;
next	;

1.56.1.1.3.1
date	97.09.09.14.08.42;	author daveb;	state Exp;
branches;
next	;

1.57.1.1
date	97.09.10.19.24.02;	author brucem;	state Exp;
branches;
next	;

1.57.2.1
date	97.09.11.20.54.52;	author daveb;	state Exp;
branches;
next	;

1.60.1.1
date	99.04.01.17.56.52;	author daveb;	state Exp;
branches;
next	;


desc
@Interpreter invocation.
@


1.61
log
@[Bug #190553]
Replaced use of basis/exit with utils/mlworks_exit.
@
text
@(*
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Description
 *  -----------
 *  This is the file that starts the interpreter.  It is the last file
 *  loaded into the runtime system in order to create an interpreter image.
 *
 *  Notes
 *  -----
 *  It is a good idea to have your own copy of this file if you are
 *  developing, as you will be able to flip various switches without much
 *  recompilation.
 *
 *  Revision Log
 *  ------------
 *  $Log: interpreter.sml,v $
 * Revision 1.60  1999/02/02  16:00:27  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.59  1998/07/07  13:46:16  jont
 * [Bug #20122]
 * Move pervasive signatures into __pervasive_library.sml
 *
 * Revision 1.58  1998/05/26  13:56:24  mitchell
 * [Bug #30413]
 * Use abstract exit status
 *
 * Revision 1.57  1997/05/19  10:49:09  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.56  1996/12/18  17:17:01  andreww
 * [Bug #1818]
 * increasing pervasive module count by one, to account for new
 * floatarray signature.
 *
 * Revision 1.55  1996/10/30  15:29:33  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.54  1996/07/03  11:58:39  andreww
 * Altering MLWorks.Internal.Runtime.modules to include some of the
 * changes to the pervasive library (i.e., to be able to see MLWorks.General).
 *
 * Revision 1.53  1996/05/30  15:44:41  jont
 * interrupt has moved into MLWorks
 *
 * Revision 1.52  1996/05/30  13:20:05  daveb
 * The Interrupt exception is no longer at top level.
 *
 * Revision 1.51  1996/05/16  13:07:53  stephenb
 * Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
 *
 * Revision 1.50  1996/05/08  13:29:54  stephenb
 * Update wrt move of file "main" to basis.
 *
 * Revision 1.49  1996/05/01  10:31:54  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.48  1996/04/17  14:51:58  stephenb
 * Replace any use of MLWorks.exit by Exit.exit
 *
 * Revision 1.47  1996/04/04  10:17:12  stephenb
 * Change the messages in the debugger calls so that they are the same
 * as those used by the gui version (see ./xinterpreter.sml).
 *
 * Revision 1.46  1996/01/16  12:19:02  nickb
 * Change to StorageManager interface.
 *
 *  Revision 1.45  1996/01/15  14:04:11  stephenb
 *  Fix the error I introduced in the previous fix!
 *
 *  Revision 1.44  1996/01/12  12:09:27  stephenb
 *  Ensure that handle_fatal_signal resets the fatal (signal) handler status
 *  before it returns.
 *
 *  Revision 1.43  1996/01/08  16:28:06  nickb
 *  Debugger SIGNAL changed to INTERRUPT
 *
 *  Revision 1.42  1995/07/12  13:24:41  jont
 *  Add parameter to make_shell_structure to indicate image type (ie tty or motif)
 *
 *  Revision 1.41  1995/06/15  13:24:30  daveb
 *  Type of Ml_Debugger.ml_debugger has changed.
 *
 *  Revision 1.40  1995/06/14  13:06:10  daveb
 *  Type of Ml_Debugger.ml_debugger has changed.
 *
 *  Revision 1.39  1995/06/02  15:01:53  nickb
 *  Add fatal signal handling.
 *
 *  Revision 1.38  1995/05/26  16:38:04  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.37  1995/05/11  10:42:59  matthew
 *  Setting pervasive generalise function moved elsewhere
 *
 *  Revision 1.36  1995/05/02  15:24:40  matthew
 *  Remove script argument to ml_debugger
 *  Change use of cast (again)
 *
 *  Revision 1.35  1995/05/01  11:13:12  daveb
 *  Moved the user context stuff into a separate file from shelltypes.sml.
 *
 *  Revision 1.34  1995/04/06  09:30:22  matthew
 *  Removing Mod_rules.print_times
 *
 *  Revision 1.33  1995/03/01  11:54:48  matthew
 *  Removing use of frame_call
 *  in break function
 *
 *  Revision 1.32  1995/01/27  10:23:57  daveb
 *  Removed reference to ShellTypes.Option.
 *
 *  Revision 1.31  1994/12/07  11:32:18  matthew
 *  Changing uses of cast
 *
 *  Revision 1.30  1994/08/01  12:39:17  daveb
 *  Separated preferences from options.
 *
 *  Revision 1.29  1994/07/18  09:35:25  daveb
 *  Type of mk_xinterface_fn in ShellTypes.ListenerArgs has changed.
 *
 *  Revision 1.28  1994/07/08  10:16:14  nickh
 *  Change interrupt handling.
 *
 *  Revision 1.27  1994/06/22  09:48:28  daveb
 *  Repaced context refs with user_contexts.
 *
 *  Revision 1.26  1994/03/01  15:34:14  nosa
 *  Pass debugger scripts to ml_debugger.
 *
 *  Revision 1.25  1994/03/01  15:10:49  nosa
 *  Pass debugger scripts to ml_debugger.
 *
 *  Revision 1.24  1993/11/09  15:49:00  jont
 *  Changed initial value of user_options to have interrupt_tight_loops on
 *  by default
 *
 *  Revision 1.23  1993/06/03  17:55:52  daveb
 *  Removed the context field from the prompter.
 *
 *  Revision 1.22  1993/05/18  15:21:57  jont
 *  Removed integer parameter
 *
 *  Revision 1.21  1993/05/11  09:50:12  daveb
 *  Interface to contextrefs has changed.
 *
 *  Revision 1.20  1993/05/10  16:27:01  daveb
 *  Changed type of ml_debugger.
 *
 *  Revision 1.19  1993/05/10  14:21:35  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *
 *  Revision 1.18  1993/05/10  12:03:29  matthew
 *  Added interrupt handler
 *
 *  Revision 1.17  1993/05/06  15:32:33  matthew
 *  ShellTypes simplification
 *
 *  Revision 1.16  1993/05/04  17:23:11  matthew
 *  Changed context ref handling
 *
 *  Revision 1.15  1993/04/26  12:11:32  matthew
 *  Removed ML_Debugger.BASE_FRAME
 *
 *  Revision 1.14  1993/04/13  16:16:16  matthew
 *  Changes to pervasive dyamics
 *  Changes to pervasive break functions
 *
 *  Revision 1.13  1993/04/06  16:10:24  jont
 *  Moved user_options and version from interpreter to main
 *
 *  Revision 1.12  1993/04/02  19:03:01  daveb
 *  Changed to reflect Matthew's signature changes.
 *
 *  Revision 1.11  1993/03/30  15:55:36  matthew
 *  Set initial context properly.
 *
 *  Revision 1.10  1993/03/30  12:59:25  matthew
 *  Added pervasive break function
 *  Prompter changess
 *
 *  Revision 1.9  1993/03/15  16:52:08  matthew
 *  Simplified ShellTypes types
 *
 *  Revision 1.8  1993/03/11  14:49:51  matthew
 *  Signature revisions
 *
 *  Revision 1.7  1993/03/08  14:53:40  matthew
 *  Options & Info changes
 *  Changes for ShellData type
 *
 *  Revision 1.6  1993/03/01  17:51:28  daveb
 *  Revised to use new TTY listener.  This version doesn't load the X interface.
 *  See xinterpreter.sml.
 *
 *  Revision 1.5  1992/12/08  15:15:59  clive
 *  Don't override error_notify in the value_printer
 *
 *  Revision 1.4  1992/12/04  15:32:00  richard
 *  Commented out diagnostic settings in preparation for release.
 *
 *  Revision 1.3  1992/11/12  16:49:40  richard
 *  Added instruction to delete the loaded modules from the runtime
 *  system's root and so free the setup procedures and unwanted stuff.
 *
 *  Revision 1.2  1992/11/07  15:13:17  richard
 *  Changes to the pervasives.
 *
 *  Revision 1.1  1992/10/15  07:16:05  richard
 *  Initial revision
 *
 *)

require "../main/__toplevel";
require "../debugger/__ml_debugger";
require "__shell_structure";
require "__tty_listener";
require "__shell_types";
require "__user_context";
require "__incremental";
require "__os";
require "../main/__user_options";
require "../main/__preferences";

(* This is getting too big *)

local
structure UserContext = UserContext_
structure ShellTypes = ShellTypes_
structure Info = TopLevel_.Info
structure Options = TopLevel_.Options
structure Incremental = Incremental_
structure Ml_Debugger = Ml_Debugger_

in

val x_message = "This version of MLWorks was compiled without the X interface\n"

fun default_prompter {name, topdec, line, subline} =
  concat [name, if subline > 0 then ">> " else "> "]

  fun handle_fatal_signal shell_data_ref s = 
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
      val c = ShellTypes.get_current_context shell_data
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.FATAL_SIGNAL s,
         Ml_Debugger.POSSIBLE ("Return to top level",
			       Ml_Debugger.FUN
			        (fn _ =>
				 (MLWorks.Threads.Internal.reset_fatal_status();
				  raise MLWorks.Interrupt))),
         Ml_Debugger.NOT_POSSIBLE)
    end

  fun interrupt_function shell_data_ref s = 
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
      val c = ShellTypes.get_current_context shell_data
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.INTERRUPT,
         Ml_Debugger.POSSIBLE ("Return to top level",
                               Ml_Debugger.DO_RAISE MLWorks.Interrupt),
         Ml_Debugger.POSSIBLE ("Continue interrupted code",
                               Ml_Debugger.NORMAL_RETURN))
    end

  fun double_stack_limit () = 
    let val m = MLWorks.Internal.Runtime.Memory.max_stack_blocks
    in m := (!m * 2)
    end

  fun stack_overflow_function shell_data_ref s = 
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.STACK_OVERFLOW,
         Ml_Debugger.POSSIBLE
	   ("Return to top level", Ml_Debugger.DO_RAISE MLWorks.Interrupt),
         Ml_Debugger.POSSIBLE
	   ("Continue with extended stack",
            Ml_Debugger.FUN double_stack_limit))
    end

  val _ =
    MLWorks.Internal.Runtime.Event.stack_overflow_handler
    (stack_overflow_function ShellTypes.shell_data_ref)

  val _ =
    MLWorks.Internal.Runtime.Event.interrupt_handler
    (interrupt_function ShellTypes.shell_data_ref)

  val _ =
    MLWorks.Threads.Internal.set_handler
    (handle_fatal_signal ShellTypes.shell_data_ref)

  fun break_function (shell_data_ref) s =
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.BREAK s,
         Ml_Debugger.POSSIBLE ("Return to top level",
                               Ml_Debugger.DO_RAISE MLWorks.Interrupt),
         Ml_Debugger.POSSIBLE ("Continue interrupted code",
                               Ml_Debugger.NORMAL_RETURN)) 
    end
  
  val _ = MLWorks.Internal.Debugger.break_hook := break_function (ShellTypes.shell_data_ref)

  exception NoDebugger

  val initial_context =
    ShellStructure_.make_shell_structure true
      (ShellTypes.shell_data_ref, Incremental.initial)

  val user_context_options =
    UserOptions_.make_user_context_options Options.default_options

  val _ =
    case user_context_options
    of UserOptions_.USER_CONTEXT_OPTIONS
         {1={generate_interruptable_code, ...}, ...} =>
      generate_interruptable_code := true
      (* want this on for the interpreter *)

  fun main arguments =
    let
    in
      TTYListener_.listener
      (ShellTypes.LISTENER_ARGS
       {user_context =
	  UserContext.makeInitialUserContext
	    (initial_context, "MLWorks", user_context_options),
        user_options =
          UserOptions_.make_user_tool_options Options.default_options,
	user_preferences =
	  Preferences_.make_user_preferences Preferences_.default_preferences,
        prompter=default_prompter,
        mk_xinterface_fn = fn _ =>  fn _ => (print x_message; ())})
    end
end;

  (* MLWorks.Internal.Runtime.modules is a list of the modules that have
     been loaded in the building of this image.  Since we have now created
     the user's image, we don't need most of this list any more.  The only
     entries we need are the pervasives, for loading object files.  These
     are the last 2 entries on the list.
     
     This is not robust code.  It would be better if a module read from 
     an object file could be loaded using a similar mechanism to loading
     the result of compiling a source file. *)

  val _ = MLWorks.Internal.Runtime.modules :=
    (case rev(!MLWorks.Internal.Runtime.modules) of
       x :: y :: _ => [y, x]
     | _ => !MLWorks.Internal.Runtime.modules (* Impossible case *))

(* previously: MLWorks.Internal.Runtime.modules := []; *)

val _ = case main (MLWorks.arguments ()) of
          0 => OS.Process.exit (OS.Process.success)
        | _ => OS.Process.exit (OS.Process.failure);


@


1.60
log
@[Bug #190500]
Remove redundant require statements
@
text
@d19 4
d229 1
a229 1
require "../basis/__exit";
d397 2
a398 2
          0 => Exit_.exit (Exit_.success)
        | _ => Exit_.exit (Exit_.failure);
@


1.60.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a18 4
 * Revision 1.60  1999/02/02  16:00:27  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.59
log
@[Bug #20122]
Move pervasive signatures into __pervasive_library.sml
@
text
@d19 4
a218 1
require "../debugger/__value_printer";
@


1.58
log
@[Bug #30413]
Use abstract exit status
@
text
@d19 4
d376 1
a376 1
     are the last 10 entries on the list.
a381 12
  fun last(n,l) =
    let
      fun nthtail (0,l) = l
        | nthtail (_,[]) = []
        | nthtail (n,(a::l)) = nthtail (n-1,l)
      fun scan (l,[]) = l
        | scan ([],l) = [] (* impossible case, but there you go *)
        | scan (a::l,a'::l') = scan (l,l')
    in
      scan (l,nthtail (n,l))
    end;

d383 3
a385 1
    last(11,!MLWorks.Internal.Runtime.modules);
@


1.57
log
@[Bug #30090]
Translate output std_out to print
@
text
@d19 4
d395 5
a399 1
val _ = Exit_.exit (main (MLWorks.arguments ()));
@


1.57.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a18 4
 * Revision 1.57  1997/05/19  10:49:09  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.57.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a18 4
 * Revision 1.57  1997/05/19  10:49:09  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.56
log
@[Bug #1818]
increasing pervasive module count by one, to account for new
floatarray signature.
@
text
@d19 5
d360 1
a360 1
        mk_xinterface_fn = fn _ =>  fn _ => (MLWorks.IO.output (MLWorks.IO.std_out, x_message); ())})
@


1.56.1.1
log
@branched from 1.56
@
text
@a18 5
 * Revision 1.56  1996/12/18  17:17:01  andreww
 * [Bug #1818]
 * increasing pervasive module count by one, to account for new
 * floatarray signature.
 *
@


1.56.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a18 3
 * Revision 1.56.1.1  1997/05/12  10:33:33  hope
 * branched from 1.56
 *
@


1.56.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a18 3
 * Revision 1.56.1.1  1997/05/12  10:33:33  hope
 * branched from 1.56
 *
@


1.56.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a18 3
 * Revision 1.56.1.1  1997/05/12  10:33:33  hope
 * branched from 1.56
 *
@


1.56.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a18 3
 * Revision 1.56.1.1.1.1  1997/07/28  18:19:28  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.55
log
@[Bug #1614]
removing toplevel String.
@
text
@d19 4
d382 1
a382 1
    last(10,!MLWorks.Internal.Runtime.modules);
@


1.55.4.1
log
@branched from 1.55
@
text
@a18 4
 * Revision 1.55  1996/10/30  15:29:33  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.55.3.1
log
@branched from 1.55
@
text
@a18 4
 * Revision 1.55  1996/10/30  15:29:33  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.55.3.1.1.1
log
@branched from 1.55.3.1
@
text
@a18 3
 * Revision 1.55.3.1  1996/12/17  17:47:07  hope
 * branched from 1.55
 *
@


1.55.2.1
log
@branched from 1.55
@
text
@a18 4
 * Revision 1.55  1996/10/30  15:29:33  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.55.1.1
log
@branched from 1.55
@
text
@a18 4
 * Revision 1.55  1996/10/30  15:29:33  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.55.1.1.1.1
log
@branched from 1.55.1.1
@
text
@a18 3
 * Revision 1.55.1.1  1996/11/14  12:48:32  hope
 * branched from 1.55
 *
@


1.54
log
@Altering MLWorks.Internal.Runtime.modules to include some of the
changes to the pervasive library (i.e., to be able to see MLWorks.General).
@
text
@d19 4
d224 1
a224 1
  String.implode [name, if subline > 0 then ">> " else "> "]
@


1.54.3.1
log
@branched from 1.54
@
text
@a18 4
 * Revision 1.54  1996/07/03  11:58:39  andreww
 * Altering MLWorks.Internal.Runtime.modules to include some of the
 * changes to the pervasive library (i.e., to be able to see MLWorks.General).
 *
@


1.54.2.1
log
@branched from 1.54
@
text
@a18 4
 * Revision 1.54  1996/07/03  11:58:39  andreww
 * Altering MLWorks.Internal.Runtime.modules to include some of the
 * changes to the pervasive library (i.e., to be able to see MLWorks.General).
 *
@


1.54.1.1
log
@branched from 1.54
@
text
@a18 4
 * Revision 1.54  1996/07/03  11:58:39  andreww
 * Altering MLWorks.Internal.Runtime.modules to include some of the
 * changes to the pervasive library (i.e., to be able to see MLWorks.General).
 *
@


1.53
log
@interrupt has moved into MLWorks
@
text
@d19 3
d351 26
a376 1
MLWorks.Internal.Runtime.modules := [];
@


1.52
log
@The Interrupt exception is no longer at top level.
@
text
@d19 3
d308 1
a308 1
                               Ml_Debugger.DO_RAISE Interrupt),
@


1.51
log
@Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
@
text
@d19 3
d233 1
a233 1
				  raise Interrupt))),
d251 1
a251 1
                               Ml_Debugger.DO_RAISE Interrupt),
d274 1
a274 1
	   ("Return to top level", Ml_Debugger.DO_RAISE Interrupt),
@


1.50
log
@Update wrt move of file "main" to basis.
@
text
@d19 3
d307 1
a307 1
  val _ = MLWorks.Debugger.break_hook := break_function (ShellTypes.shell_data_ref)
d344 1
a344 1
val _ = Exit_.exit (main (MLWorks.OS.arguments ()));
@


1.49
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d19 6
d189 1
a189 1
require "../main/__exit";
@


1.48
log
@Replace any use of MLWorks.exit by Exit.exit
@
text
@d19 3
d202 1
a202 1
  implode [name, if subline > 0 then ">> " else "> "]
d329 1
a329 1
        mk_xinterface_fn = fn _ =>  fn _ => (output (std_out, x_message); ())})
@


1.47
log
@Change the messages in the debugger calls so that they are the same
as those used by the gui version (see ./xinterpreter.sml).
@
text
@d19 4
d180 1
d332 1
a332 1
MLWorks.exit (main (MLWorks.OS.arguments ()));
@


1.46
log
@Change to StorageManager interface.
@
text
@d19 3
d209 1
a209 1
         Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
d230 1
a230 1
         Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
d254 1
a254 1
	   ("Return to TopLevel", Ml_Debugger.DO_RAISE Interrupt),
d284 1
a284 1
         Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
@


1.45
log
@Fix the error I introduced in the previous fix!
@
text
@d19 3
d233 5
d254 1
a254 3
            Ml_Debugger.FUN
	      (fn () =>
		 (MLWorks.Internal.Runtime.StorageManager.interface(40,2);()))))
@


1.44
log
@Ensure that handle_fatal_signal resets the fatal (signal) handler status
before it returns.
@
text
@d19 4
d204 4
a207 3
			       (fn _ =>
				(MLWorks.Threads.Internal.reset_fatal_status();
				 raise Interrupt))),
@


1.43
log
@Debugger SIGNAL changed to INTERRUPT
@
text
@d19 3
d200 3
a202 1
                               Ml_Debugger.DO_RAISE Interrupt),
@


1.42
log
@Add parameter to make_shell_structure to indicate image type (ie tty or motif)
@
text
@d19 3
d213 1
a213 1
         Ml_Debugger.SIGNAL s,
@


1.41
log
@Type of Ml_Debugger.ml_debugger has changed.
@
text
@d19 3
d273 1
a273 1
    ShellStructure_.make_shell_structure
@


1.40
log
@Type of Ml_Debugger.ml_debugger has changed.
@
text
@d19 3
d187 1
a187 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
d205 1
a205 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
d223 1
a223 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
d256 1
a256 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
@


1.39
log
@Add fatal signal handling.
@
text
@d19 3
d182 9
a190 10
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       c)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.FATAL_SIGNAL s,
       Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.NOT_POSSIBLE)
d201 10
a210 11
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       c)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.SIGNAL s,
       Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.POSSIBLE ("Continue interrupted code",
                             Ml_Debugger.NORMAL_RETURN))
a217 1
      val context = ShellTypes.get_current_context shell_data
d220 13
a232 11
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       context)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.STACK_OVERFLOW,
       Ml_Debugger.POSSIBLE ("Return to TopLevel",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.POSSIBLE ("Continue with extended stack",
                             Ml_Debugger.FUN (fn () => (MLWorks.Internal.Runtime.StorageManager.interface(40,2);()))))
d254 10
a263 12
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       ShellTypes.get_current_context shell_data)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.BREAK s,
       Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.POSSIBLE ("Continue interrupted code",
                             Ml_Debugger.NORMAL_RETURN
                             )) 
@


1.38
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d19 3
d171 20
d212 21
d234 4
d240 4
@


1.37
log
@Setting pervasive generalise function moved elsewhere
@
text
@d19 3
d218 29
a246 20
  val initial_context = ShellStructure_.make_shell_structure
			  (ShellTypes.shell_data_ref,
                           Incremental.initial)
fun main arguments =
  let
    val user_options =
      UserOptions_.make_user_options
	(Options.default_options, Preferences_.default_preferences)
    val _ = case user_options of
      UserOptions_.USER_OPTIONS{1={generate_interruptable_code, ...}, ...} =>
	generate_interruptable_code := true
  (* want this on for the interpreter *)
  in
    TTYListener_.listener
    (ShellTypes.LISTENER_ARGS
     {user_context = UserContext.makeInitialUserContext(initial_context,"MLWorks"),
      user_options = user_options,
      prompter=default_prompter,
      mk_xinterface_fn = fn _ =>  fn _ => (output (std_out, x_message); ())})
  end
@


1.36
log
@Remove script argument to ml_debugger
Change use of cast (again)
@
text
@d19 4
a144 1
require "../typechecker/__scheme";
a156 1
structure Scheme = Scheme_
a211 10

  val cast : 'a -> 'b = MLWorks.Internal.Value.cast

  val _ = MLWorks.Dynamic.generalises_ref :=
     (fn (ty,ty') =>
      (Scheme.generalises (cast ty,
                           cast ty'))
      handle Scheme.MisMatch (t,t') => raise MLWorks.Dynamic.Coerce(cast t,
                                                                    cast t'))
        
@


1.35
log
@Moved the user context stuff into a separate file from shelltypes.sml.
@
text
@d19 3
a181 1
      []
a206 1
      (!MLWorks.Debugger.script)
d211 1
a211 1
  val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
d215 4
a218 4
      (Scheme.generalises (castit ty,
                           castit ty'))
      handle Scheme.MisMatch (t,t') => raise MLWorks.Dynamic.Coerce(castit t,
                                                                    castit t'))
@


1.34
log
@Removing Mod_rules.print_times
@
text
@d19 3
d136 1
d145 1
d237 1
a237 1
     {user_context = ShellTypes.makeInitialUserContext(initial_context,"MLWorks"),
@


1.33
log
@Removing use of frame_call
in break function
@
text
@d19 4
a134 1
require "../typechecker/__mod_rules"; 
a136 2

Module_rules_.print_times := false;
@


1.32
log
@Removed reference to ShellTypes.Option.
@
text
@d19 3
d180 21
a200 24
  fun break_function (shell_data_ref) =
    MLWorks.Internal.Value.frame_call
    (fn base_frame =>
     (fn s =>
      let
        val shell_data as ShellTypes.SHELL_DATA{prompter,
                                                mk_xinterface_fn,
                                                ...} = !shell_data_ref
      in
        Ml_Debugger.ml_debugger 
        Ml_Debugger.TERMINAL
        (ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data,
         ShellTypes.get_current_context shell_data)
        (fn context' => (output(std_out,"No shell in break debugger yet\n")))
        base_frame
        (Ml_Debugger.BREAK s,
         Ml_Debugger.POSSIBLE ("Return to TopLevel by raising Interrupt",
                               Ml_Debugger.DO_RAISE Interrupt),
         Ml_Debugger.POSSIBLE ("Continue interrupted code",
                               Ml_Debugger.NORMAL_RETURN
                               )) (!MLWorks.Debugger.script);
        ()
      end))
@


1.31
log
@Changing uses of cast
@
text
@d19 3
a139 1
structure Option = ShellTypes.Option
@


1.30
log
@Separated preferences from options.
@
text
@d19 3
d201 3
a203 1
  
d206 4
a209 4
      (Scheme.generalises (MLWorks.Internal.Value.cast ty,
                           MLWorks.Internal.Value.cast ty'))
      handle Scheme.MisMatch (t,t') => raise MLWorks.Dynamic.Coerce(MLWorks.Internal.Value.cast t,
                                                                    MLWorks.Internal.Value.cast t'))
@


1.29
log
@Type of mk_xinterface_fn in ShellTypes.ListenerArgs has changed.
@
text
@d19 3
d124 1
d155 3
a157 1
      (ShellTypes.get_current_options shell_data, c)
d184 1
d214 3
a216 1
    val user_options = UserOptions_.make_user_options(Options.default_options)
@


1.28
log
@Change interrupt handling.
@
text
@d19 3
d218 1
a218 1
      mk_xinterface_fn = fn _ =>  fn () => (output (std_out, x_message); ())})
@


1.27
log
@Repaced context refs with user_contexts.
@
text
@d19 3
d159 3
a161 1
  val _ = MLWorks.Internal.Runtime.Event.signal (2,interrupt_function ShellTypes.shell_data_ref)
@


1.26
log
@Pass debugger scripts to ml_debugger.
@
text
@d19 3
d141 1
a141 1
      val cref = ShellTypes.get_context_ref(ShellTypes.get_shell_context_ref shell_data)
d145 1
a145 1
      (ShellTypes.get_current_options shell_data, cref)
d170 1
a170 1
         ShellTypes.get_context_ref (ShellTypes.get_shell_context_ref shell_data))
d207 1
a207 1
     {context_ref = ShellTypes.makeInitialContextRef(initial_context,"MLWorks"),
@


1.25
log
@Pass debugger scripts to ml_debugger.
@
text
@d19 3
d175 1
a175 1
                               )) [];
@


1.24
log
@Changed initial value of user_options to have interrupt_tight_loops on
by default
@
text
@d19 4
d147 1
d172 1
a172 1
                               ));
@


1.23
log
@Removed the context field from the prompter.
@
text
@d19 3
d187 14
a200 7
  TTYListener_.listener
  (ShellTypes.LISTENER_ARGS
   {context_ref = ShellTypes.makeInitialContextRef(initial_context,"MLWorks"),
    user_options = UserOptions_.make_user_options Options.default_options,
    prompter=default_prompter,
    mk_xinterface_fn = fn _ =>  fn () => (output (std_out, x_message); ())})

a205 2


@


1.23.1.1
log
@Fork for bug fixing
@
text
@a18 3
 *  Revision 1.23  1993/06/03  17:55:52  daveb
 *  Removed the context field from the prompter.
 *
@


1.22
log
@Removed integer parameter
@
text
@d19 3
d120 2
a121 8
fun default_prompter {name, topdec, line, subline, context} =
  let val context_name =
    if context = 0
      then ""
    else "#" ^ MLWorks.Integer.makestring context
  in
    implode [name,context_name, if subline > 0 then ">> " else "> "]
  end
@


1.21
log
@Interface to contextrefs has changed.
@
text
@d19 3
a88 1
require "../utils/__integer";
a104 1
structure Integer = Integer_
d121 1
a121 1
    else "#" ^ Integer.makestring context
@


1.20
log
@Changed type of ml_debugger.
@
text
@d19 3
d188 1
a188 1
   {context_ref = ShellTypes.makeContextRef(initial_context,"MLWorks"),
@


1.19
log
@Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d1 1
a1 1
(*  ==== RUN THE INTERPRETER ====
d19 3
d131 1
a131 2
      (ShellTypes.make_incremental_options shell_data,
       cref)
d154 1
a154 1
        (ShellTypes.make_incremental_options shell_data,
@


1.18
log
@Added interrupt handler
@
text
@d19 3
d121 1
a121 2
      val shell_data as ShellTypes.SHELL_DATA{error_info,
                                              prompter,
d146 1
a146 2
        val shell_data as ShellTypes.SHELL_DATA{error_info,
                                                prompter,
d177 3
a179 10
  val initial_incremental_options =
    Incremental.OPTIONS
    {error_info = Info.default_options,
     options = Options.default_options,
     debugger = fn _ => raise NoDebugger
     }

  val initial_context = ShellStructure_.make_shell_structure (ShellTypes.shell_data_ref,
                                                              Incremental.initial,
                                                              initial_incremental_options)
a184 1
    error_info = Info.default_options,
@


1.17
log
@ShellTypes simplification
@
text
@d19 3
d115 23
@


1.16
log
@Changed context ref handling
@
text
@d19 3
a118 1
                                                name_monitor,
d125 1
a125 2
        (ShellTypes.get_current_print_method_table shell_data,
         ShellTypes.make_incremental_options shell_data,
a153 1
     name_monitor = Option.ABSENT,
a163 1
    print_method_table_ref = ref ValuePrinter_.default_print_method_table,
a165 1
    name_monitor = Option.PRESENT (fn s => output(std_out, "Make: compiling " ^ s)),
@


1.15
log
@Removed ML_Debugger.BASE_FRAME
@
text
@d19 3
d125 1
a125 1
         ShellTypes.get_context_ref shell_data)
d163 1
a163 1
   {context_ref = ref initial_context,
@


1.14
log
@Changes to pervasive dyamics
Changes to pervasive break functions
@
text
@d19 4
d124 1
a124 1
        (Ml_Debugger.BASE_FRAME base_frame)
@


1.13
log
@Moved user_options and version from interpreter to main
@
text
@d19 3
d72 1
d88 1
d130 1
a130 1
  val _ = MLWorks.Internal.Tracing.break_hook := break_function (ShellTypes.shell_data_ref)
d132 8
@


1.12
log
@Changed to reflect Matthew's signature changes.
@
text
@d19 3
a68 3

(* require "__intermake"; InterMake_.Diagnostic.set 1; *)
(* require "../main/__compiler"; Compiler_.Diagnostic.set 2; *)
d70 1
a70 2
require "../debugger/__value_printer"; 
require "__user_options";
@


1.11
log
@Set initial context properly.
@
text
@d19 3
d65 1
d82 2
a83 2
structure Option = ShellTypes.Incremental.InterMake.FileName.Option
structure Incremental = ShellTypes.Incremental
@


1.10
log
@Added pervasive break function
Prompter changess
@
text
@d19 4
d59 1
d79 1
d124 13
a136 1
exception NoDebugger
d140 1
a140 1
   {context_ref = ref ShellTypes.Incremental.initial,
@


1.9
log
@Simplified ShellTypes types
@
text
@d19 3
d51 1
d54 1
d66 1
a66 4
val x_message = "This version of MLWorks was compiled without the X interface\n"

fun default_prompter {name, topdec, line, subline} =
  implode [name, if subline > 0 then ">> " else "> "]
d69 1
d74 1
d78 40
d122 1
a122 2
   {options_ref = ref Options.default_options,
    context_ref = ref ShellTypes.Incremental.initial,
d135 2
@


1.8
log
@Signature revisions
@
text
@d19 3
d78 9
a86 11
   (ShellTypes.SHELL_DATA
    {options_ref = ref Options.default_options,
     context_ref = ref ShellTypes.Incremental.initial,
     print_method_table_ref = ref ValuePrinter_.default_print_method_table,
     user_options = UserOptions_.make_user_options Options.default_options,
     error_info = Info.default_options,
     name_monitor = Option.PRESENT (fn s => output(std_out, "Make: compiling " ^ s)),
     debugger = fn _ => raise NoDebugger,
     prompter=default_prompter},
    fn _ =>  fn () => (output (std_out, x_message); ())
    ))
@


1.7
log
@Options & Info changes
Changes for ShellData type
@
text
@d19 4
d65 2
a66 2
structure Info = TopLevel_.Parser.Lexer.Info
structure Options = TopLevel_.Parser.Options
@


1.6
log
@Revised to use new TTY listener.  This version doesn't load the X interface.
See xinterpreter.sml.
@
text
@d19 4
d48 1
a48 1
require "../typechecker/__mod_rules"; Module_rules_.print_times := false;
d50 3
d59 9
d69 11
a79 12
  TTYListener_.listener (ShellTypes_.LISTENER_ARGS (
    (TopLevel_.default_compiler_options,
     ShellTypes_.Incremental.InterMake.OPTIONS {
       name_monitor =
         ShellTypes_.Incremental.InterMake.FileName.Option.PRESENT (
           fn s => output(std_out, "Make: compiling " ^ s)
         ),
       compiler_options = TopLevel_.default_compiler_options
    }),
    ShellTypes_.Incremental.initial,
    default_prompter,
    ValuePrinter_.toplevel_default_print_descriptor,
d81 2
a82 1
  ));
@


1.5
log
@Don't override error_notify in the value_printer
@
text
@d19 3
d37 4
a40 1
require "__shell";
d47 21
d70 1
a70 1
MLWorks.exit (Shell_.main (MLWorks.OS.arguments ()));
@


1.4
log
@Commented out diagnostic settings in preparation for release.
@
text
@d19 3
d39 1
a39 1
require "../debugger/__value_printer"; ValuePrinter_.error_notify := true;
@


1.3
log
@Added instruction to delete the loaded modules from the runtime
system's root and so free the setup procedures and unwanted stuff.
@
text
@d19 4
d33 1
a33 1
require "__intermake"; InterMake_.Diagnostic.set 1;
@


1.2
log
@Changes to the pervasives.
@
text
@d19 3
d33 2
@


1.1
log
@Initial revision
@
text
@d18 4
a21 1
 *  $Log$
d28 2
d31 1
a31 1
MLWorks.Internal.Debugger.exit (Shell_.main (MLWorks.OS.arguments ()));
@
