head	1.136;
access;
symbols
	MLW_daveb_inline_1_4_99:1.136.1
	MLWorks_21c0_1999_03_25:1.136
	MLWorks_20c1_1998_08_20:1.124
	MLWorks_20c0_1998_08_04:1.123
	MLWorks_20b2c2_1998_06_19:1.123
	MLWorks_20b2_Windows_1998_06_12:1.123
	MLWorks_20b1c1_1998_05_07:1.122
	MLWorks_20b0_1998_04_07:1.118
	MLWorks_20b0_1998_03_20:1.118
	MLWorks_20m2_1998_02_16:1.115
	MLWorks_20m1_1997_10_23:1.114
	MLWorks_11r1:1.109.1.1.1.2.1
	MLWorks_workspace_97:1.113.2
	MLWorks_dt_wizard:1.113.1
	MLWorks_11c0_1997_09_09:1.109.1.1.1.2
	MLWorks_10r3:1.109.1.1.3
	MLWorks_10r2_551:1.109.1.1.2
	MLWorks_11:1.109.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.109.1.1
	MLWorks_20m0_1997_06_20:1.112
	MLWorks_1_0_r2c2_1997_06_14:1.109.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.109.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.109.1
	MLWorks_BugFix_1997_04_24:1.110
	MLWorks_1_0_r2_Win32_1997_04_11:1.109
	MLWorks_1_0_r2_Unix_1997_04_04:1.109
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.103.3.1.1
	MLWorks_gui_1996_12_18:1.103.4
	MLWorks_1_0_Win32_1996_12_17:1.103.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.103.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.103.1.1
	MLWorks_1_0_Irix_1996_11_28:1.103.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.103.2
	MLWorks_1_0_Unix_1996_11_14:1.103.1
	MLWorks_Open_Beta2_1996_10_11:1.100.3
	MLWorks_License_dev:1.100.2
	MLWorks_1_open_beta_1996_09_13:1.100.1
	MLWorks_Open_Beta_1996_08_22:1.100
	MLWorks_Beta_1996_07_02:1.97
	MLWorks_Beta_1996_06_07:1.95
	MLWorks_Beta_1996_06_06:1.95
	MLWorks_Beta_1996_06_05:1.95
	MLWorks_Beta_1996_06_03:1.95
	MLWorks_Beta_1996_05_31:1.95
	MLWorks_Beta_1996_05_30:1.94
	ML_beta_release_12/08/94:1.39
	ML_beta_release_03/08/94:1.38
	ML_revised_beta_release_25/05/94:1.29
	ML_final_beta_release_02/03/94:1.24
	mlworks-28-01-1994:1.20
	Release:1.13
	mlworks-beta-01-09-1993:1.13;
locks; strict;
comment	@ * @;


1.136
date	99.03.25.18.53.03;	author mitchell;	state Exp;
branches
	1.136.1.1;
next	1.135;

1.135
date	99.03.23.17.37.55;	author mitchell;	state Exp;
branches;
next	1.134;

1.134
date	99.03.18.12.17.35;	author daveb;	state Exp;
branches;
next	1.133;

1.133
date	99.03.18.09.07.04;	author mitchell;	state Exp;
branches;
next	1.132;

1.132
date	99.02.19.10.45.36;	author mitchell;	state Exp;
branches;
next	1.131;

1.131
date	99.02.09.09.50.01;	author mitchell;	state Exp;
branches;
next	1.130;

1.130
date	99.02.03.15.53.44;	author mitchell;	state Exp;
branches;
next	1.129;

1.129
date	99.02.02.16.00.24;	author mitchell;	state Exp;
branches;
next	1.128;

1.128
date	98.11.26.12.20.46;	author mitchell;	state Exp;
branches;
next	1.127;

1.127
date	98.11.03.13.27.08;	author jont;	state Exp;
branches;
next	1.126;

1.126
date	98.11.02.13.30.38;	author jont;	state Exp;
branches;
next	1.125;

1.125
date	98.10.30.16.20.39;	author jont;	state Exp;
branches;
next	1.124;

1.124
date	98.08.13.10.58.15;	author jont;	state Exp;
branches;
next	1.123;

1.123
date	98.05.19.11.49.02;	author mitchell;	state Exp;
branches;
next	1.122;

1.122
date	98.05.07.09.19.16;	author mitchell;	state Exp;
branches;
next	1.121;

1.121
date	98.05.01.16.16.56;	author mitchell;	state Exp;
branches;
next	1.120;

1.120
date	98.04.24.15.03.58;	author mitchell;	state Exp;
branches;
next	1.119;

1.119
date	98.04.02.12.46.51;	author jont;	state Exp;
branches;
next	1.118;

1.118
date	98.02.19.20.22.26;	author mitchell;	state Exp;
branches;
next	1.117;

1.117
date	98.02.18.17.40.29;	author jont;	state Exp;
branches;
next	1.116;

1.116
date	98.02.10.15.39.39;	author jont;	state Exp;
branches;
next	1.115;

1.115
date	98.02.06.14.04.00;	author johnh;	state Exp;
branches;
next	1.114;

1.114
date	97.09.17.16.06.41;	author brucem;	state Exp;
branches;
next	1.113;

1.113
date	97.07.31.12.37.34;	author johnh;	state Exp;
branches
	1.113.1.1
	1.113.2.1;
next	1.112;

1.112
date	97.05.28.13.53.21;	author daveb;	state Exp;
branches;
next	1.111;

1.111
date	97.05.12.16.25.26;	author jont;	state Exp;
branches;
next	1.110;

1.110
date	97.04.23.15.54.21;	author jont;	state Exp;
branches;
next	1.109;

1.109
date	97.04.02.15.15.26;	author matthew;	state Exp;
branches
	1.109.1.1;
next	1.108;

1.108
date	97.03.21.11.59.17;	author matthew;	state Exp;
branches;
next	1.107;

1.107
date	97.03.21.11.50.04;	author matthew;	state Exp;
branches;
next	1.106;

1.106
date	97.03.20.17.11.26;	author johnh;	state Exp;
branches;
next	1.105;

1.105
date	97.03.20.13.54.56;	author johnh;	state Exp;
branches;
next	1.104;

1.104
date	97.02.11.18.15.39;	author daveb;	state Exp;
branches;
next	1.103;

1.103
date	96.11.06.11.38.15;	author matthew;	state Exp;
branches
	1.103.1.1
	1.103.2.1
	1.103.3.1
	1.103.4.1;
next	1.102;

1.102
date	96.11.04.16.36.31;	author jont;	state Exp;
branches;
next	1.101;

1.101
date	96.10.30.13.42.51;	author io;	state Exp;
branches;
next	1.100;

1.100
date	96.08.15.14.52.37;	author daveb;	state Exp;
branches
	1.100.1.1
	1.100.2.1
	1.100.3.1;
next	1.99;

1.99
date	96.08.05.15.52.23;	author stephenb;	state Exp;
branches;
next	1.98;

1.98
date	96.07.04.15.36.37;	author jont;	state Exp;
branches;
next	1.97;

1.97
date	96.06.20.10.38.13;	author daveb;	state Exp;
branches;
next	1.96;

1.96
date	96.06.19.13.36.14;	author daveb;	state Exp;
branches;
next	1.95;

1.95
date	96.05.30.13.04.06;	author daveb;	state Exp;
branches;
next	1.94;

1.94
date	96.05.23.12.16.00;	author stephenb;	state Exp;
branches;
next	1.93;

1.93
date	96.05.21.11.17.36;	author stephenb;	state Exp;
branches;
next	1.92;

1.92
date	96.05.20.12.12.38;	author daveb;	state Exp;
branches;
next	1.91;

1.91
date	96.05.15.15.18.12;	author matthew;	state Exp;
branches;
next	1.90;

1.90
date	96.05.08.11.13.37;	author daveb;	state Exp;
branches;
next	1.89;

1.89
date	96.05.03.11.49.48;	author daveb;	state Exp;
branches;
next	1.88;

1.88
date	96.05.03.09.28.10;	author daveb;	state Exp;
branches;
next	1.87;

1.87
date	96.05.01.10.06.36;	author jont;	state Exp;
branches;
next	1.86;

1.86
date	96.04.23.12.47.21;	author daveb;	state Exp;
branches;
next	1.85;

1.85
date	96.04.18.15.03.46;	author jont;	state Exp;
branches;
next	1.84;

1.84
date	96.04.17.09.34.28;	author stephenb;	state Exp;
branches;
next	1.83;

1.83
date	96.04.16.15.43.40;	author brianm;	state Exp;
branches;
next	1.82;

1.82
date	96.04.09.17.06.59;	author daveb;	state Exp;
branches;
next	1.81;

1.81
date	96.04.02.11.42.52;	author daveb;	state Exp;
branches;
next	1.80;

1.80
date	96.03.27.11.52.58;	author stephenb;	state Exp;
branches;
next	1.79;

1.79
date	96.03.25.15.39.52;	author daveb;	state Exp;
branches;
next	1.78;

1.78
date	96.03.19.12.25.49;	author daveb;	state Exp;
branches;
next	1.77;

1.77
date	96.03.18.17.50.10;	author daveb;	state Exp;
branches;
next	1.76;

1.76
date	96.03.15.17.05.55;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	96.03.15.12.38.37;	author daveb;	state Exp;
branches;
next	1.74;

1.74
date	96.03.11.10.33.39;	author daveb;	state Exp;
branches;
next	1.73;

1.73
date	96.03.11.10.22.47;	author daveb;	state Exp;
branches;
next	1.72;

1.72
date	96.03.04.15.14.16;	author daveb;	state Exp;
branches;
next	1.71;

1.71
date	96.02.29.12.22.18;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	96.02.05.17.36.56;	author daveb;	state Exp;
branches;
next	1.69;

1.69
date	96.01.22.16.37.31;	author matthew;	state Exp;
branches;
next	1.68;

1.68
date	96.01.22.11.20.37;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	96.01.19.10.43.05;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	96.01.17.17.12.30;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	96.01.16.10.07.45;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	96.01.15.16.27.46;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	95.12.13.13.30.45;	author daveb;	state Exp;
branches;
next	1.62;

1.62
date	95.12.13.11.22.17;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	95.12.05.15.17.02;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	95.12.04.17.21.00;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	95.12.04.16.56.54;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	95.10.20.10.21.22;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	95.10.17.13.56.38;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	95.09.11.14.32.22;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	95.07.19.12.09.12;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	95.07.13.12.16.23;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	95.06.14.12.19.30;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	95.06.05.14.12.21;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	95.05.26.11.33.36;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	95.05.01.15.29.17;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	95.05.01.09.20.25;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	95.04.28.14.57.37;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	95.04.24.16.25.33;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	95.04.21.13.58.51;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	95.04.12.13.28.01;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	95.03.20.11.47.34;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	95.03.06.12.00.44;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.03.02.12.20.24;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	95.02.20.14.24.30;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.01.16.14.22.40;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	94.08.09.15.05.20;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	94.08.02.10.19.45;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	94.07.29.16.23.39;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	94.07.28.14.52.52;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	94.07.26.11.13.19;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	94.07.25.15.17.36;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	94.06.23.17.02.24;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	94.06.22.15.29.17;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	94.06.21.14.53.07;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	94.06.09.16.02.08;	author nickh;	state Exp;
branches;
next	1.29;

1.29
date	94.05.06.16.31.02;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	94.03.30.18.50.11;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	94.03.25.17.53.56;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	94.03.17.17.25.31;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	94.03.15.15.55.43;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	94.02.21.23.51.54;	author nosa;	state Exp;
branches;
next	1.23;

1.23
date	94.02.08.14.52.58;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	94.02.02.10.24.10;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	94.01.28.16.26.37;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	94.01.26.17.56.50;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	94.01.06.16.14.57;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.12.15.13.43.42;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.11.02.17.44.42;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	93.10.08.16.20.37;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.10.05.10.23.49;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	93.09.16.15.42.35;	author nosa;	state Exp;
branches;
next	1.13;

1.13
date	93.08.29.13.31.19;	author daveb;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	93.08.25.14.51.26;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.08.17.18.29.28;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	93.08.03.11.23.43;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.07.29.11.14.04;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.06.30.16.34.15;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	93.06.17.10.52.42;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.06.04.14.35.43;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	93.06.01.11.42.14;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.05.27.15.57.53;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.05.12.14.30.11;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.05.11.14.59.38;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.04.30.10.57.10;	author matthew;	state Exp;
branches;
next	;

1.13.1.1
date	93.08.29.13.31.19;	author jont;	state Exp;
branches;
next	1.13.1.2;

1.13.1.2
date	93.10.08.15.27.26;	author matthew;	state Exp;
branches;
next	1.13.1.3;

1.13.1.3
date	93.11.02.17.32.03;	author daveb;	state Exp;
branches;
next	;

1.100.1.1
date	96.09.13.11.15.51;	author hope;	state Exp;
branches;
next	;

1.100.2.1
date	96.10.07.16.05.58;	author hope;	state Exp;
branches;
next	;

1.100.3.1
date	96.10.17.11.24.16;	author hope;	state Exp;
branches;
next	;

1.103.1.1
date	96.11.14.12.48.52;	author hope;	state Exp;
branches
	1.103.1.1.1.1;
next	;

1.103.1.1.1.1
date	96.11.28.15.00.18;	author hope;	state Exp;
branches;
next	;

1.103.2.1
date	96.11.22.18.08.39;	author hope;	state Exp;
branches;
next	;

1.103.3.1
date	96.12.17.17.47.20;	author hope;	state Exp;
branches
	1.103.3.1.1.1;
next	;

1.103.3.1.1.1
date	97.02.24.11.37.03;	author hope;	state Exp;
branches;
next	;

1.103.4.1
date	96.12.18.09.41.20;	author hope;	state Exp;
branches;
next	;

1.109.1.1
date	97.05.12.10.33.47;	author hope;	state Exp;
branches
	1.109.1.1.1.1
	1.109.1.1.2.1
	1.109.1.1.3.1;
next	;

1.109.1.1.1.1
date	97.07.28.18.19.16;	author daveb;	state Exp;
branches;
next	1.109.1.1.1.2;

1.109.1.1.1.2
date	97.08.04.15.31.46;	author johnh;	state Exp;
branches
	1.109.1.1.1.2.1.1;
next	;

1.109.1.1.1.2.1.1
date	97.10.07.11.44.24;	author jkbrook;	state Exp;
branches;
next	;

1.109.1.1.2.1
date	97.09.08.17.12.52;	author daveb;	state Exp;
branches;
next	;

1.109.1.1.3.1
date	97.09.09.14.08.30;	author daveb;	state Exp;
branches;
next	;

1.113.1.1
date	97.09.10.19.23.45;	author brucem;	state Exp;
branches;
next	;

1.113.2.1
date	97.09.11.20.54.40;	author daveb;	state Exp;
branches;
next	1.113.2.2;

1.113.2.2
date	97.11.11.16.14.58;	author johnh;	state Exp;
branches;
next	1.113.2.3;

1.113.2.3
date	97.11.20.16.59.23;	author daveb;	state Exp;
branches;
next	1.113.2.4;

1.113.2.4
date	97.11.26.12.19.54;	author daveb;	state Exp;
branches;
next	1.113.2.5;

1.113.2.5
date	97.11.26.16.50.46;	author daveb;	state Exp;
branches;
next	1.113.2.6;

1.113.2.6
date	97.12.02.16.31.29;	author daveb;	state Exp;
branches;
next	1.113.2.7;

1.113.2.7
date	97.12.04.15.19.27;	author daveb;	state Exp;
branches;
next	;

1.136.1.1
date	99.04.01.17.56.45;	author daveb;	state Exp;
branches;
next	;


desc
@Utilities for shell code
@


1.136
log
@[Bug #190532]
Don't apply map_dag when loading
@
text
@(*  Utilities for shell etc.
 *
 *  Copyright (C) 1996 The Harlequin Group Limited.  All rights reserved.
 *
 *  $Log: _shell_utils.sml,v $
 * Revision 1.135  1999/03/23  17:37:55  mitchell
 * [Bug #190532]
 * Ensure update_dependencies is called on subprojects first
 *
 * Revision 1.134  1999/03/18  12:17:35  daveb
 * [Bug #190521]
 * OS.FileSys.readDir now returns an option type.
 *
 * Revision 1.133  1999/03/18  09:07:04  mitchell
 * [Bug #190532]
 * Use Project.map_dag when compiling a project
 *
 * Revision 1.132  1999/02/19  10:45:36  mitchell
 * [Bug #190507]
 * Change dependency checking messages to diagnostic messages
 *
 * Revision 1.131  1999/02/09  09:50:01  mitchell
 * [Bug #190505]
 * Support for precompilation of subprojects
 *
 * Revision 1.130  1999/02/03  15:53:44  mitchell
 * [Bug #50108]
 * Change ModuleId from an equality type
 *
 * Revision 1.129  1999/02/02  16:00:24  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.128  1998/11/26  12:20:46  mitchell
 * [Bug #190493]
 * Make calls to eval originating from the history mechanism distinguishable
 *
 * Revision 1.127  1998/11/03  13:27:08  jont
 * [Bug #70204]
 * Add subprojects into linking process, and place binaries in the right place
 *
 * Revision 1.126  1998/11/02  13:30:38  jont
 * [Bug #70204]
 * Do work for making exes
 *
 * Revision 1.125  1998/10/30  16:20:39  jont
 * [Bug #70198]
 * Add functions to make dlls and exes from a project
 *
 * Revision 1.124  1998/08/13  10:58:15  jont
 * [Bug #30468]
 * Change types of mkAbsolute and mkRelative to uses records with names fields
 *
 * Revision 1.123  1998/05/19  11:49:02  mitchell
 * [Bug #50071]
 * Add support for force compiles and loads
 *
 * Revision 1.122  1998/05/07  09:19:16  mitchell
 * [Bug #50071]
 * Add support for touch_all_sources
 *
 * Revision 1.121  1998/05/01  16:16:56  mitchell
 * [Bug #50071]
 * Remove debug printout
 *
 * Revision 1.120  1998/04/24  15:03:58  mitchell
 * [Bug #30389]
 * Keep projects more in step with projfiles
 *
 * Revision 1.119  1998/04/02  12:46:51  jont
 * [Bug #30312]
 * Replacing OS.FileSys.modTime with system dependent version to sort out
 * MS time stamp problems.
 *
 * Revision 1.118  1998/02/19  20:22:26  mitchell
 * [Bug #30337]
 * Change uses of OS.Path.concat to take a string list, instead of a pair of strings.
 *
 * Revision 1.117  1998/02/18  17:40:29  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 * Revision 1.116  1998/02/10  15:39:39  jont
 * [Bug #70065]
 * Remove uses of MLWorks.IO.messages and use the Messages structure
 *
 * Revision 1.115  1998/02/06  14:04:00  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.113.2.7  1997/12/04  15:19:27  daveb
 * [Bug #30017]
 * Rationalised Shell.Project commands:
 * Removed touch_source_file.
 * Added {,show_}{compile,load}_targets.
 * Made load/compile functions take strings instead of module_ids, and
 * explicit location values.
 *
 * Revision 1.113.2.6  1997/12/02  16:31:29  daveb
 * [Bug #30071]
 * Removed functions for loading from source files.
 *
 * Revision 1.113.2.5  1997/11/26  16:50:46  daveb
 * [Bug #30071]
 *
 * Revision 1.113.2.4  1997/11/26  12:19:54  daveb
 * [Bug #30071]
 * The action queue is no more, so ShellUtils.use_{file,string} and
 * ShellUtils.read_dot_mlworks no longer take queue functions.
 *
 * Revision 1.113.2.3  1997/11/20  16:59:23  daveb
 * [Bug #30326]
 *
 * Revision 1.113.2.2  1997/11/11  16:14:58  johnh
 * [Bug #30203]
 * Merging - checking files to be recompiled.
 *
 * Revision 1.113.2.1  1997/09/11  20:54:40  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.114  1997/09/17  16:06:41  brucem
 * [Bug #30203]
 * Incremental.check_mo (and check_module) return module ids
 * , instead of strings.
 *
 * Revision 1.113  1997/07/31  12:37:34  johnh
 * [Bug #50019]
 * Modify process_result to take a UserContext.source_reference type for src.
 *
 * Revision 1.112  1997/05/28  13:53:21  daveb
 * [Bug #30090]
 * Converted lexer to Basis IO.
 * Converted MLWorks.IO.set_modified to OS.FileSys.setTime.
 *
 * Revision 1.111  1997/05/12  16:25:26  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
 * Revision 1.110  1997/04/23  15:54:21  jont
 * [Bug #20013]
 * Put Use: message under control of print_messages
 *
 * Revision 1.109  1997/04/02  15:15:26  matthew
 * Fixing uncaught SysErr in completion
 *
 * Revision 1.108  1997/03/21  11:59:17  matthew
 * Fixing merge bungle with last change
 *
 * Revision 1.107  1997/03/21  11:50:04  matthew
 * Adding use function
 *
 * Revision 1.106  1997/03/20  17:11:26  johnh
 * [Bug #1849]
 * Added a check to avoid Syserr exception being raised on Win32.
 *
 * Revision 1.105  1997/03/20  13:54:56  johnh
 * [Bug #1986]
 * Changed from using Path to OSPath.
 *
 * Revision 1.104  1997/02/11  18:15:39  daveb
 * Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
 * -- Changed name and type of Module.find_sml and Module.sml_name.
 *
 * Revision 1.103  1996/11/06  11:38:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.102  1996/11/04  16:36:31  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.101  1996/10/30  13:42:51  io
 * moving String from toplevel
 *
 * Revision 1.100  1996/08/15  14:52:37  daveb
 * [Bug #1519]
 * Type of UserContext.ITEM has changed.
 *
 * Revision 1.99  1996/08/05  15:52:23  stephenb
 * Replace the call to OldOS.mtime with one to OS.FileSys.access
 * since OldOs is deprecated and the mtime call is only being used
 * to determine if the file actually exists.
 *
 * Revision 1.98  1996/07/04  15:36:37  jont
 * Remove debug info saying processing result
 *
 * Revision 1.97  1996/06/20  10:38:13  daveb
 * Bug 1424: Made object_traceable check the trace status of the object.
 *
 * Revision 1.96  1996/06/19  13:36:14  daveb
 * Corrected definition of is_closure.
 *
 * Revision 1.95  1996/05/30  13:04:06  daveb
 * The Io exception is no longer at top level.
 *
 * Revision 1.94  1996/05/23  12:16:00  stephenb
 * Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
 * now does what the former used to do.
 *
 * Revision 1.93  1996/05/21  11:17:36  stephenb
 * Change to pull in Path directly rather than OS.Path since the latter
 * now conforms to the latest basis and it is too much effort to update
 * the code to OS.Path at this point.
 *
 * Revision 1.92  1996/05/20  12:12:38  daveb
 * Moved preferences_file_name to new save_image module.
 *
 * Revision 1.91  1996/05/15  15:18:12  matthew
 * Fixing problem with filename completion on Windows
 *
 * Revision 1.90  1996/05/08  11:13:37  daveb
 * Added Info.options argument to use_file.
 *
 * Revision 1.89  1996/05/03  11:49:48  daveb
 * Removed the ShellUtils.Error exception.
 *
 * Revision 1.88  1996/05/03  09:28:10  daveb
 * Removed the Incremental.Error exception.
 *
 * Revision 1.87  1996/05/01  10:06:36  jont
 * String functions explode, implode, chr and ord now only available from
 * String io functions and types instream, oustream, open_in, open_out,
 * close_in, close_out, input, output and end_of_stream 
 * now only available from MLWorks.IO
 *
 * Revision 1.86  1996/04/23  12:47:21  daveb
 * show_source no longer returns a destroy function.
 *
 * Revision 1.85  1996/04/18  15:03:46  jont
 * initbasis moved to basis
 *
 * Revision 1.84  1996/04/17  09:34:28  stephenb
 * Rename Os -> OS to conform with latest basis revision.
 *
 * Revision 1.83  1996/04/16  15:43:40  brianm
 * Added exception wrapper to close input stream in use_file().
 *
 * Revision 1.82  1996/04/09  17:06:59  daveb
 * Added preferences argument to load_source, load_file and use_file, 
 * because UserContext.process_result now requires this.
 *
 * Revision 1.81  1996/04/02  11:42:52  daveb
 * Changed Project.load_dependencies to Project.read_dependencies.
 *
 * Revision 1.80  1996/03/27  11:52:58  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
 * Revision 1.79  1996/03/25  15:39:52  daveb
 * Added delete_from_project.
 * Modified types of some other functions to suit Incremental.match_*_path.
 *
 * Revision 1.78  1996/03/19  12:25:49  daveb
 * Added check_load_file.
 *
 * Revision 1.77  1996/03/18  17:50:10  daveb
 * Incremental.load_mo and Incremental.add_module now return option types.
 *
 * Revision 1.76  1996/03/15  17:05:55  daveb
 * Module.find_sml now takes an Info.options parameter.
 *
 * Revision 1.75  1996/03/15  12:38:37  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.74  1996/03/11  10:33:39  daveb
 * Removed compile_string and default_dynamic.
 *
 * Revision 1.73  1996/03/11  10:22:47  daveb
 * compile_file was passed the wrong project.
 *
 * Revision 1.72  1996/03/04  15:14:16  daveb
 * Renamed Project.check_objects to Project.check_compiled.
 *
 * Revision 1.71  1996/02/29  12:22:18  matthew
 * Adding preference_file_name function
 *
 * Revision 1.70  1996/02/05  17:36:56  daveb
 * Removed commented-out save function.
 * Interface of UserContext has changed.
 *
 *  Revision 1.69  1996/01/22  16:37:31  matthew
 *  Using Info.null_options in call to eval
 *
 *  Revision 1.68  1996/01/22  11:20:37  daveb
 *  Removed history functions (replaced by more complete functionality in
 *  gui_utils).
 *
 *  Revision 1.67  1996/01/19  10:43:05  matthew
 *  Adding catch all handler around call to eval.
 *
 *  Revision 1.66  1996/01/17  17:12:30  matthew
 *  Adding value_from_user_context function
 *
 *  Revision 1.65  1996/01/16  10:07:45  matthew
 *  Fixing bungle with last change.
 *
 *  Revision 1.64  1996/01/15  16:27:46  matthew
 *  Some stuff in completion to deal with stupid NT backslashes in filenames
 *
 *  Revision 1.63  1995/12/13  13:30:45  daveb
 *  Improved wording of check_load_source message.
 *
 *  Revision 1.62  1995/12/13  11:22:17  daveb
 *  Corrected "make" to "load source" in message.
 *
 *  Revision 1.61  1995/12/05  15:17:02  daveb
 *  Removed Module.Cache type.
 *
 *  Revision 1.60  1995/12/04  17:21:00  daveb
 *  Incremental and InterMake have been changed to use Project.
 *
 *  Revision 1.59  1995/12/04  16:56:54  matthew
 *  Thinking about filename completion
 *
 *  Revision 1.58  1995/10/20  10:21:22  daveb
 *  Added show_source.
 *
 *  Revision 1.57  1995/10/17  13:56:38  matthew
 *  Changing interface to tracing
 *
 *  Revision 1.56  1995/09/11  14:32:22  matthew
 *  Adding check on file existing before invoking editor
 *
 *  Revision 1.55  1995/07/19  12:09:12  matthew
 *  Changing parser error reporting.
 *
 *  Revision 1.54  1995/07/13  12:16:23  matthew
 *  Adding compile functions for use by evaluator.
 *
 *  Revision 1.53  1995/06/14  12:19:30  daveb
 *  Removed redundant Context parameter from edit functions.
 *
 *  Revision 1.52  1995/06/05  14:12:21  daveb
 *  UserContext.process_result now takes a user_options argument.
 *
 *  Revision 1.51  1995/05/26  11:33:36  daveb
 *  Split user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.50  1995/05/01  15:29:17  matthew
 *  Changing exception raised by EditObject
 *
 *  Revision 1.49  1995/05/01  09:20:25  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.48  1995/04/28  14:57:37  jont
 *  New module naming stuff
 *
 *  Revision 1.47  1995/04/24  16:25:33  daveb
 *  Added Shell.Make prefix to source strings for load and make.
 *
 *  Revision 1.46  1995/04/21  13:58:51  daveb
 *  Expansion of home dirs moved from FileSys to Getenv.
 *  filesys and path moved from utils to initbasis.
 *  Better error handling.
 *
 *  Revision 1.45  1995/04/12  13:28:01  jont
 *  Change FILESYS to FILE_SYS
 *
 *  Revision 1.44  1995/03/20  11:47:34  matthew
 *  Lexer uses ints as character representation
 *
 *  Revision 1.43  1995/03/06  12:00:44  daveb
 *  Replaced evaluation sequences with calls to ShellTypes.process_result.
 *  Also minor changes as a result of new Path signature.
 *
 *  Revision 1.42  1995/03/02  12:20:24  matthew
 *  Changes to lexer structure
 *
 *  Revision 1.41  1995/02/20  14:24:30  daveb
 *  Made use_file update the context history.
 *
 *  Revision 1.40  1995/01/16  14:22:40  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *  Replaced FileName parameter with FileSys and Path.
 *
 *  Revision 1.39  1994/08/09  15:05:20  daveb
 *  Made use_file return the current modules table when an error occurs.
 *  Renamed source_result to result, added some comments.
 *
 *  Revision 1.38  1994/08/02  10:19:45  daveb
 *  Added editable function.
 *
 *  Revision 1.37  1994/07/29  16:23:39  daveb
 *  Moved preferences out of Options structure.
 *
 *  Revision 1.36  1994/07/28  14:52:52  daveb
 *  Changed uses of InterPrint.definitions to InterPrint.strings.
 *
 *  Revision 1.35  1994/07/26  11:13:19  daveb
 *  Moved set_no_execute to _incremental, so that add_module and
 *  check_module in _incremental don't have to check that the option
 *  is set correctly.
 *
 *  Revision 1.34  1994/07/25  15:17:36  daveb
 *  make_file now updates the delta context correctly.
 *
 *  Revision 1.33  1994/06/23  17:02:24  daveb
 *  Brought use_file up to date with the new context arrangements.
 *
 *  Revision 1.32  1994/06/22  15:29:17  jont
 *  Update debugger information production
 *
 *  Revision 1.31  1994/06/21  14:53:07  daveb
 *  Replaced Context Refs by user_contexts.  Replaced the Context argument
 *  of the Error exception with a list of new modules, for updating the
 *  user_context appropriately.
 *
 *  Revision 1.30  1994/06/09  16:02:08  nickh
 *  New runtime directory structure.
 *
 *  Revision 1.29  1994/05/06  16:31:02  jont
 *  Add incremental parser basis to stuff passed to interprint
 *
 *  Revision 1.28  1994/03/30  18:50:11  daveb
 *  Added touch_compile_module and touch_compile_file.
 *
 *  Revision 1.27  1994/03/25  17:53:56  daveb
 *  Revised functions to work with ActionQueue.with_source_path.
 *
 *  Revision 1.26  1994/03/17  17:25:31  matthew
 *  Added check_make_file and edit_file
 *
 *  Revision 1.25  1994/03/15  15:55:43  matthew
 *  Added untrace function
 *  Fixed a problem with Error exceptions.  These should all be converted to
 * Incremental.Errors 
 *
 *  Revision 1.24  1994/02/21  23:51:54  nosa
 *  Boolean indicator for Monomorphic debugger decapsulation.
 *
 *  Revision 1.23  1994/02/08  14:52:58  daveb
 *   Module.module_and_path is now Module.find_file and is functional.
 *
 *  Revision 1.22  1994/02/02  10:24:10  daveb
 *  make and ad_module now take Modules instead of file names.
 *
 *  Revision 1.21  1994/01/28  16:26:37  matthew
 *
 *  Revision 1.20  1994/01/26  17:56:50  matthew
 *  Added space to error messge
 *
 *  Revision 1.19  1994/01/06  16:14:57  matthew
 *  Added load_file function for loading an mo
 *
 *  Revision 1.18  1993/12/15  13:43:42  matthew
 *  Added level field to Basis.
 *
 *  Revision 1.17  1993/11/02  17:44:42  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.16  1993/10/08  16:20:37  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.15  1993/10/05  10:23:49  jont
 *  Added save_file function
 *
 *  Revision 1.14  1993/09/16  15:42:35  nosa
 *  Pass options to InterPrint.definitions instead of print_options.
 *
 *  Revision 1.13.1.3  1993/11/02  17:32:03  daveb
 *  Minor fixes to use_file.
 *
 *  Revision 1.13.1.2  1993/10/08  15:27:26  matthew
 *  Check for editability of defininitions
 *  Predicates for editability and traceability
 *  Utilities for history menus
 *
 *  Revision 1.13.1.1  1993/08/29  13:31:19  jont
 *  Fork for bug fixing
 *
 *  Revision 1.13  1993/08/29  13:31:19  daveb
 *  Removed "compiling" from message, because I think it's confusing.
 *
 *  Revision 1.12  1993/08/25  14:51:26  matthew
 *  Return quit function from ShellUtils.edit_string
 *
 *  Revision 1.11  1993/08/17  18:29:28  daveb
 *  Changes to reflect use of moduleids.
 *  I think some more work is needed here - e.g. with the edit functions.
 *
 *  Revision 1.10  1993/08/03  11:23:43  matthew
 *  Added filter_completions function to sort and remove duplicates from
 *  completions.
 *
 *  Revision 1.9  1993/07/29  11:14:04  matthew
 *  Use Info.make_default_options rather than Info.default_options
 *  Changed use message
 *  Insert ; after a string to be evaluated
 *  
 *  Revision 1.8  1993/06/30  16:34:15  daveb
 *  Removed exception environments.
 *  
 *  Revision 1.7  1993/06/17  10:52:42  matthew
 *  Added edit_object and trace functions
 *  
 *  Revision 1.6  1993/06/04  14:35:43  daveb
 *  edit functions now return a single string in the erroneous case.
 *  
 *  Revision 1.5  1993/06/01  11:42:14  matthew
 *  Added handler for Io on opening file for use
 *  
 *  Revision 1.4  1993/05/27  15:57:53  matthew
 *  Added error_info parameter to eval
 *  Added completion functions
 *  Changes to error handling
 *  
 *  Revision 1.3  1993/05/12  14:30:11  matthew
 *  Added make, use  and eval functions
 *  
 *  Revision 1.2  1993/05/11  14:59:38  matthew
 *  Added make_file an parse_absolute functions
 *  
 *  Revision 1.1  1993/04/30  10:57:10  matthew
 *  Initial revision
 *  
 *)

require "^.basis.__int";
require "^.basis.__string";
require "^.basis.__list";
require "^.basis.__list_pair";
require "^.basis.__text_io";
require "^.basis.__io";

require "../utils/lists";
require "^.utils.__messages";
require "^.utils.__terminal";
require "../rts/gen/tags";
require "../basis/os";
require "../basis/os_path";
require "../utils/getenv";
require "../basics/module_id";
require "incremental";
require "shell_types";
require "user_context";
require "../parser/parser";
require "../typechecker/types";
require "../typechecker/basis";
require "../typechecker/completion";
require "../main/toplevel";
require "../main/project";
require "../main/proj_file";
require "../main/link_support";
require "../main/object_output";
require "../main/encapsulate";
require "../debugger/value_printer";
require "../debugger/newtrace";
require "../editor/editor";
require "../main/mlworks_io";
require "../main/user_options";
require "../main/preferences";
require "../utils/diagnostic";

require "shell_utils";

functor ShellUtils
  (structure Lists : LISTS
   structure Tags : TAGS
   structure Incremental : INCREMENTAL
   structure Editor : EDITOR
   structure Parser : PARSER
   structure Types : TYPES
   structure Basis : BASIS
   structure Completion : COMPLETION
   structure ValuePrinter : VALUE_PRINTER
   structure TopLevel : TOPLEVEL
   structure Project : PROJECT
   structure ProjFile : PROJ_FILE
   structure Diagnostic: DIAGNOSTIC;
   structure LinkSupport : LINK_SUPPORT
   structure Encapsulate : ENCAPSULATE
   structure Object_Output : OBJECT_OUTPUT
   structure Trace : TRACE
   structure Io : MLWORKS_IO
   structure OS : OS
   structure OSPath : OS_PATH
   structure Getenv : GETENV
   structure ModuleId : MODULE_ID
   structure Preferences : PREFERENCES
   structure UserOptions : USER_OPTIONS
   structure UserContext : USER_CONTEXT
   structure ShellTypes : SHELL_TYPES

   sharing Incremental.InterMake.Compiler.Options = UserOptions.Options =
     	   Completion.Options = ValuePrinter.Options = UserContext.Options =
     	   ShellTypes.Options = TopLevel.Options
     
   sharing Incremental.InterMake.Compiler.Info = Parser.Lexer.Info =
	   Project.Info = TopLevel.Info
   sharing Completion.Datatypes = Basis.BasisTypes.Datatypes =
	   Incremental.Datatypes = Types.Datatypes
   sharing Editor.Location = Parser.Lexer.Info.Location
   sharing Incremental.InterMake.Compiler.Absyn = Parser.Absyn
   sharing Basis.BasisTypes.Datatypes.Ident.Symbol = 
     Parser.Lexer.Token.Symbol
   sharing Incremental.InterMake.Inter_EnvTypes.EnvironTypes.LambdaTypes.Ident =
	   Basis.BasisTypes.Datatypes.Ident

   sharing type Incremental.Result = UserContext.Result
   sharing type Incremental.InterMake.Compiler.TypeBasis =
		Basis.BasisTypes.Basis
   sharing type Incremental.InterMake.Compiler.DebugInformation =
		ValuePrinter.DebugInformation
   sharing type Incremental.InterMake.Compiler.ParserBasis = 
                Parser.ParserBasis
   sharing type Parser.Lexer.Options =
		Incremental.InterMake.Compiler.Options.options
   sharing type Editor.preferences = Preferences.preferences =
		UserContext.preferences = ShellTypes.preferences
   sharing type Preferences.user_preferences = ShellTypes.user_preferences
   sharing type UserOptions.user_context_options =
		UserContext.user_context_options
   sharing type UserContext.user_context = ShellTypes.user_context
   sharing type Trace.UserOptions = UserOptions.user_tool_options =
		ShellTypes.user_options
   sharing type Incremental.Context = Trace.Context = UserContext.Context =
		ShellTypes.Context
   sharing type ValuePrinter.Type = Incremental.Datatypes.Type = Trace.Type
   sharing type Parser.Lexer.TokenStream =
		Incremental.InterMake.Compiler.tokenstream
   sharing type Editor.Location.T = ModuleId.Location
   sharing type ModuleId.ModuleId = Incremental.ModuleId = 
		Project.ModuleId = TopLevel.ModuleId = Object_Output.ModuleId
   sharing type UserContext.identifier =
		Basis.BasisTypes.Datatypes.Ident.Identifier
   sharing type Project.Project = Incremental.InterMake.Project =
		TopLevel.Project = Object_Output.Project
   sharing type Encapsulate.Module = Object_Output.Module
  ) : SHELL_UTILS =
struct
  structure InterMake = Incremental.InterMake
  structure Inter_EnvTypes = InterMake.Inter_EnvTypes
  structure Options = UserOptions.Options
  structure Location = Editor.Location
  structure Info = InterMake.Compiler.Info
  structure Lexer = Parser.Lexer
  structure Token = Lexer.Token
  structure Compiler = InterMake.Compiler
  structure BasisTypes = Basis.BasisTypes
  structure Datatypes = BasisTypes.Datatypes
  structure NewMap = Datatypes.NewMap
  structure Ident = Datatypes.Ident
  structure Symbol = Ident.Symbol

  type user_preferences = Preferences.user_preferences
  type UserOptions = UserOptions.user_tool_options
  type Context = Incremental.Context
  type Type = Incremental.Datatypes.Type
  type ModuleId = Incremental.ModuleId
  type ShellData = ShellTypes.ShellData
  type user_context = UserContext.user_context
  type preferences = Preferences.preferences
  type history_entry = UserContext.history_entry
  type Project = Project.Project

  val _ = Diagnostic.set 0

  fun diagnostic (level, output_function) =
    Diagnostic.output
      level
      (fn verbosity => output_function verbosity)

 val do_debug = false
  fun debug_out s =
    if do_debug then
      Terminal.output("ShellUtils: " ^ s ^ "\n")
    else
      ()

    (* This should use some location function *)
    fun find_source_file (locdata:string) = 
      let
	val sz = size locdata
	fun scan i = 
	  if i < sz then
	    if String.sub(locdata, i) = #":" then
	      substring(locdata, 0, i)
	    else
	      scan(i+1)
	  else
	    locdata
      in
	scan 0
      end
	  
    exception FileFromLocation of string

    (* uneditable filenames are of the form "<...>" *)
    fun uneditable_file s =
      size s = 0 orelse
      (MLWorks.String.ordof(s,0) = ord #"<"
       andalso 
       MLWorks.String.ordof(s,(size s)-1) = ord #">")

    fun file_from_location location =
      let
        fun get_filename Location.UNKNOWN =
	  raise FileFromLocation "Unknown location"
          | get_filename (Location.FILE s) = s
          | get_filename (Location.LINE (s,_)) = s
          | get_filename (Location.POSITION (s,_,_)) = s
          | get_filename (Location.EXTENT {name,...}) = name

        val filename = get_filename location
      in
        if uneditable_file filename
          then raise FileFromLocation (filename^" not a real file")
        else filename
      end

    fun editable location =
      (ignore(file_from_location location);
       true)
      handle FileFromLocation _ => false
      
    exception EditFailed of string

    (* I guess this should be an absolute pathname by this point *)
    fun check_exists s =
      if OS.FileSys.access (s, []) then
        ()
      else
        raise EditFailed ("File " ^ s ^ " does not exist")

    fun show_source (s, preferences) =
      let
        val location = Location.from_string s
	val full_name = file_from_location location
        val _ = check_exists full_name
        val (edit_result, _) =
	  Editor.show_location preferences (full_name,location)
      in
        case edit_result of
          NONE => ()
        | SOME s => raise EditFailed s
      end
      handle FileFromLocation s => raise EditFailed s

    fun edit_location (location, preferences) =
      let
	val full_name = file_from_location location
        val _ = check_exists full_name
        val (edit_result,quitfun) =
	  Editor.edit_from_location preferences (full_name,location)
      in
        case edit_result of
          NONE => quitfun
        | SOME s => raise EditFailed s
      end
      handle FileFromLocation s => raise EditFailed s

    fun edit_file (filename, preferences) =
      let
        val full_name = Getenv.expand_home_dir filename
        val _ = check_exists full_name
        val (result,quitfun) = 
          Editor.edit preferences (full_name, 0)
      in
        case result of 
          NONE => quitfun
        | SOME s => raise EditFailed s
      end
    handle Getenv.BadHomeName s => raise EditFailed s

    fun edit_source (s, preferences) =
      let
        val location = Location.from_string s
      in
        edit_location (location, preferences)
      end

    fun is_code_item object =
      let
        val header = MLWorks.Internal.Value.primary object
      in
        header = Tags.POINTER andalso
        #1 (MLWorks.Internal.Value.header object) = Tags.BACKPTR
      end
          
    fun is_closure object = 
      let
        val header = MLWorks.Internal.Value.primary object
      in
        if header = Tags.POINTER then 
	  case MLWorks.Internal.Value.header object
          of (0, 0) =>
            is_code_item (MLWorks.Internal.Value.sub (object,1))
	  |  (secondary, length) =>
            secondary = Tags.RECORD andalso
            length > 0 andalso
            is_code_item (MLWorks.Internal.Value.sub (object,1))
        else
          header = Tags.PAIRPTR andalso
          is_code_item (MLWorks.Internal.Value.sub (object,0))
      end

    val object_editable = is_closure

    fun edit_object (object, preferences) =
      let
        fun get_location code_name =
          let
            fun aux2((#"]" ::_),acc) = acc
              | aux2(c::l,acc) = aux2(l,c::acc)
              | aux2([],acc) = acc
            fun aux1(#"["::l) = aux2 (l,[])
              | aux1(c::l) = aux1 l
              | aux1 [] = []
            val locchars = aux1 (explode code_name)
          in
            implode (rev locchars)
          end
        fun closure_code_name closure =
          let
            val primary = MLWorks.Internal.Value.primary closure
            val index = if primary = Tags.POINTER then 1 else 0
          in
            MLWorks.Internal.Value.code_name
            (MLWorks.Internal.Value.sub (closure, index))
          end
      in
        if object_editable object
          then 
            let
              val locstring = get_location (closure_code_name object ^ "\n")
            in
              edit_source (locstring, preferences)
            end
        else raise EditFailed "not a function object"
      end

    val cast = MLWorks.Internal.Value.cast

    fun object_traceable object =
      is_closure object andalso
      MLWorks.Internal.Trace.status (cast object) <>
      MLWorks.Internal.Trace.UNTRACEABLE

    fun trace f =
      Trace.trace (Trace.get_function_name (cast f))

    fun untrace f =
      Trace.untrace (Trace.get_function_name (cast f))


  fun make_incremental_options (options,debugger) =
    Incremental.OPTIONS
    {options = options,
     debugger = debugger}


  fun delete_from_project (mod_name, location) =
    let
      val module_id = ModuleId.from_string (mod_name, location)
    in
      Incremental.delete_from_project module_id
    end

  (* Functions to make executables/dlls/sos from the current project *)
  (* At some stage the glue files will need to go into a system specific place *)
  (* as they are specific to the i386 *)
  fun make_exe_from_project(location, options, target, libs) =
    let
      val project = Incremental.get_project()
      val project_name = case ProjFile.getProjectName() of
	NONE => raise OS.SysErr("Project unnamed so can't infer dll name", NONE)
      | SOME name => #base(OS.Path.splitBaseExt(#file(OS.Path.splitDirFile name)))
      (* Check target valid *)
      val targets = Project.currentTargets project
      val _ =
	if not(List.exists (fn t => t = target) targets) then
	  raise OS.SysErr("'" ^ target ^ "' is not a target for the project", NONE)
	else
	  ()
      val libs = OS.Path.joinBaseExt{base=project_name, ext=SOME"lib"} :: libs
      (* Now create the glue *)
      val target = #base(OS.Path.splitBaseExt target)
      val declare = target ^ "$closure$declare"
      val setup = target ^ "$closure$setup$get"
      val glue =
	"\t.text\n" ^
	"\t.align\t4\n" ^
	"\t.globl\t_main\n" ^
	"\t.globl\t_trampoline\n" ^
	"\t.globl\t" ^ setup ^ "\n" ^
	"\t.globl\t" ^ declare ^ "\n" ^
	"_main:\n" ^
	"\tpushl\t%ebp\n" ^
	"\tmovl\t%esp,%ebp\n" ^
	"\tlea\t" ^ declare ^ ",%edx\t/* Get all the global declarations done first */\n" ^
	"\tcall\t" ^ setup ^ "\n" ^
	"\tpush\t%edx\n" ^
	"\tpush\t%eax\n" ^
	"\tcall\t_trampoline\n" ^
	"\tadd\t$8,%esp\n" ^
	"\tmov\t%ebx,%eax\n" ^
	"\tleave\n" ^
	"\tret\n" ^
	"\t.align\t8\n"
      (* Now put the glue in a file *)
      val _ =
	let
	  val stream = TextIO.openOut "exe_glue.S"
	in
	  TextIO.output(stream, glue);
	  TextIO.closeOut stream
	 end
      (* Now assemble the glue *)
      val _ = LinkSupport.gcc "exe_glue.S"
      (* Now make the object name *)
    in
      LinkSupport.link
      {objects=["exe_glue.o"],
       libs=libs,
       target=target,
       target_path = ".",
       dll_or_exe=LinkSupport.EXE,
       base=0wx10000000,
       make_map=true,
       linker=LinkSupport.LOCAL}
    end

  fun is_pervasive_unit s = String.sub(s, 0) = #" "

  fun filter_eq eq [] = []
    | filter_eq eq (arg as [_]) = arg
    | filter_eq eq (x :: xs) = 
        let 
          fun adjoin(a,l) =  
            case List.find (fn b => eq(a,b)) l of
              SOME _ => l
            | _ => a::l

          fun adjoin2(a,b,acc) = if eq(a, b) then acc else adjoin(a,acc)

          fun filter_sub([],acc) = acc
            | filter_sub([a],acc) = adjoin(a,acc)
            | filter_sub(a::(l as b :: _),acc) = filter_sub(l,adjoin2(a,b,acc))

         in filter_sub(xs, [x])
        end

  fun make_dll_from_project(location, options, target, libs) =
    let
      val project = Incremental.get_project()
      val object_name = Project.objectName(options, location)
      (* Get all the units *)
      val targets = Project.currentTargets project
      val targets =
	map
	(fn name => ModuleId.from_string(name, location))
	targets
      val units =
	filter_eq ModuleId.eq
	(List.foldr
	 op@@
	 []
	 (map
	  (fn name =>
	   Project.allObjects (options, location)
	   (project, name)
	   )
	  targets))
      val units = List.filter (fn m => String.sub(ModuleId.string m, 0) <> #" ") units
      (* Make sure we have the proper names *)
      val names = map (fn m => Project.get_name(project, m)) units
	handle _ => raise OS.SysErr("Project system has bad unit", NONE)
      (* Now get the mo filenames *)
      val object_names =
	map
	(fn name => object_name(project, name))
	names
      (* Now make the mo archive *)
      val _ = LinkSupport.archive
	{archive=OS.Path.joinBaseExt{base=target, ext=SOME"moa"}, files=object_names}
      (* Now make the stamp file *)
      val stamp_source = LinkSupport.make_stamp target
      (* Now the glue *)
      val glue =
	"\t.text\n" ^
	"\t.globl\t_MLWDLLmain@@12\n" ^
	"\t.globl\tml_register_time_stamp\n" ^
	"\t.globl\tuid\n" ^
	"_MLWDLLmain@@12:\n" ^
	"\tcmpl\t$1,8(%esp)\n" ^
	"\tjne\tl1\t\t/* Branch if not load */\n" ^
	"\tpushl\t%ebp\n" ^
	"\tmovl\t%esp,%ebp\n" ^
	"\tlea\tuid,%eax\n" ^
	"\tcall\tml_register_time_stamp\t/* Declare us to the runtime system */\n" ^
	"\tleave\n" ^
	"l1:\n" ^
	"\tmov\t$1,%eax\n" ^
	"\tret\t$12\n"
      (* Now make the text/data start/end files *)
      val text_start =
	"\t.text\n" ^
	"\t.globl\ttext_start\n" ^
	"\t.align\t4\n" ^
	"text_start:\n"
      val text_end =
	"\t.text\n" ^
	"\t.globl\ttext_end\n" ^
	"\t.align\t4\n" ^
	"text_end:\n"
      val data_start =
	"\t.data\n" ^
	"\t.globl\tdata_start\n" ^
	"\t.align\t4\n" ^
	"data_start:\n"
      val data_end =
	"\t.data\n" ^
	"\t.globl\tdata_end\n" ^
	"\t.align\t4\n" ^
	"data_end:\n"
      (* This stuff should go away *)
      (* when we start creating our own object files *)
      (* Now deal with creating the sources. *)
      val ids_and_objects = Lists.zip(names, object_names)
      val _ =
	(app
	 (fn (module_id, mo_name) =>
	  ((*print("Creating asm for '" ^ mo_name ^ "'\n");*)
	  Object_Output.output_object_code
	  (Object_Output.ASM, module_id, mo_name, project)
	  (Encapsulate.input_code mo_name)))
	 ids_and_objects)
	handle Encapsulate.BadInput s => raise OS.SysErr(s, NONE)
      (* Now deal with the tacky _text.S and _data.S stuff, which should go away in the future *)
      val (text_names, data_names) =
	ListPair.unzip
	(map
	 (fn object_name =>
	  let
	    val {base, ext} = OS.Path.splitBaseExt object_name
	    val {dir, file} = OS.Path.splitDirFile base
	    val text = OS.Path.joinBaseExt{base=OS.Path.joinDirFile{dir=dir, file = file ^ "_text"},
					   ext = SOME"S"}
	    val data = OS.Path.joinBaseExt{base=OS.Path.joinDirFile{dir=dir, file = file ^ "_data"},
					   ext = SOME"S"}
	  in
	    (text, data)
	  end)
	 object_names)
      val source_names = text_names @@ data_names
      (* Now put them all through gcc *)
      (* Since this is only temporary (pending the inclusion of the object file outputter) *)
      (* we'll put the derived files in the current directory *)
      (* These are the glue, the start and end files, and the stamp file *)
      val names_and_contents =
	[("glue.S", glue),
	 ("text_start.S", text_start),
	 ("text_end.S", text_end),
	 ("data_start.S", data_start),
	 ("data_end.S", data_end),
	 ("stamp.S", stamp_source)]
      val _ =
	app
	(fn (name, contents) =>
	 let
	   val stream = TextIO.openOut name
	 in
	   TextIO.output(stream, contents);
	   TextIO.closeOut stream
	 end)
	names_and_contents
      val temp_names = map #1 names_and_contents
      val source_names = temp_names @@ source_names
      (* Now put it all through gcc *)
      val _ =
	app
	LinkSupport.gcc
	source_names
      (* Now link it all *)
      val object_names =
	map
	(fn name => OS.Path.joinBaseExt{base= #base(OS.Path.splitBaseExt name), ext=SOME"o"})
	source_names
      val sub_projects = ProjFile.getSubprojects()
      val extra_libs = 
	map
	(fn name => OS.Path.joinBaseExt{base= #base (OS.Path.splitBaseExt name), ext=SOME"lib"})
	sub_projects
    in
      LinkSupport.link
      {objects=object_names,
       libs=libs @@ extra_libs,
       target=target,
       target_path = ".",
       dll_or_exe=LinkSupport.DLL,
       base=0wx10000000,
       make_map=true,
       linker=LinkSupport.LOCAL}
    end

  (* All these compile and load commands share the same pattern.  
     A higher-order function seems called for. *)
  fun compile_file
	(location, options)
	error_info
	filename =
    let
      val module_id =
        ModuleId.from_string (filename, location)

      val (project', _) =
        Project.read_dependencies
          (error_info, location)
          (Incremental.get_project (), module_id, Project.empty_map)

      val out_of_date =
        Project.check_compiled
          (error_info, location)
          (project', module_id)
   
    in
      Incremental.set_project
        (TopLevel.compile_file'
	   error_info
	   (options, project', out_of_date))
    end


    (* There should be a more direct way of obtaining the object path 
     * from the project interface. *)

    fun object_path (file_name, location) =
        let 
          val module_id = ModuleId.from_string (file_name, location)
          val project_dir = ProjFile.getProjectDir()
          val (_, objects_dir, _) = ProjFile.getLocations()
	  val (_, modeDetails, curMode) = ProjFile.getModes()
	  val (_, _, curConfig) = ProjFile.getConfigurations()
	  val mode_prefix = 
	    if isSome(curMode) 
            then
	      !(#location(ProjFile.getModeDetails(valOf(curMode),modeDetails)))
	    else ""
	  val config_prefix = getOpt(curConfig, "")
          val path = OS.Path.concat
                     [ objects_dir, config_prefix, mode_prefix, 
                       ModuleId.module_unit_to_string(module_id, "mo") ]
	in	
          OS.Path.mkAbsolute{path=OS.Path.fromUnixPath path, relativeTo=project_dir}
	end
  

  fun force_compile (lo as (location, options)) error_info file_name =
    let val module_id = ModuleId.from_string (file_name, location)
        val path = object_path (file_name, location)
     in OS.FileSys.remove path handle OS.SysErr (s,e) => ();
        Project.set_object_info(Incremental.get_project (), module_id, NONE);
        compile_file lo error_info file_name
    end

  fun get_units (error_info, location) =
    let val _ = Incremental.reset_project()
        val proj = Incremental.get_project ()
        val proj' = Project.map_dag 
                      (Project.update_dependencies (error_info, location))
                      proj
        val _ = Incremental.set_project proj'
     in List.filter
	  (fn (s, _) => String.sub (s, 0) <> #" ")
	  (Project.list_units proj')
    end

  fun force_compile_all (lo as (location, options)) error_info  =
    let fun remove_mo (file_name, module_id) =
            let val path = object_path (file_name, location)
             in OS.FileSys.remove path handle OS.SysErr (s,e) => ();
                Project.set_object_info(Incremental.get_project (), 
                                        module_id, NONE)
            end
     in app remove_mo (get_units (error_info, location));
        app (compile_file lo error_info) (#1 (ProjFile.getTargets()))
    end

  fun show_compile_file
	(location, output_fn)
	error_info
	filename =
    let
      val module_id =
        ModuleId.from_string
          (filename, location)

      val (project', _) =
        Project.read_dependencies
          (error_info, location)
          (Incremental.get_project (), module_id, Project.empty_map)

      val out_of_date =
        Project.check_compiled
          (error_info, location)
          (Incremental.get_project (), module_id)

      val _ = Incremental.set_project project'
    in
      case out_of_date of
        [] => output_fn "No files need compiling\n"
      | _ => (output_fn "Files to compile:\n";
              app
               (fn s => output_fn (" " ^ ModuleId.string s ^ "\n"))
                out_of_date)
    end

  fun load_file
	(user_context, location, options, preferences, output_fn)
	error_info
	filename =
    let
      val module_id = ModuleId.from_string (filename, location)

      val (project', _) =
        Project.read_dependencies
          (error_info, location)
          (Incremental.get_project(), module_id, Project.empty_map)

      val out_of_date =
        Project.check_load_objects
          (error_info, location)
          (project', module_id)

      val _ = Incremental.set_project project'
    in
      case Incremental.load_mos
	     error_info
	     (options, UserContext.get_context user_context,
	      project', module_id, out_of_date, location) of
        NONE =>
	  (* Surely this isn't the best action in a GUI? *)
	  output_fn "up to date\n"
      | SOME result =>
	  UserContext.process_result
	    {src = UserContext.COPY ("Shell.Build.loadObject \"" ^ 
                   ModuleId.string module_id ^ "\""),
	     result = result,
	     user_context = user_context,
	     options = options,
	     preferences = preferences,
	     output_fn = output_fn}
    end
     
  fun show_load_file
	(location, output_fn)
	error_info
	filename =
    let
      val module_id = ModuleId.from_string (filename, location)

      val (project', _) =
        Project.read_dependencies
          (error_info, location)
          (Incremental.get_project (), module_id, Project.empty_map)

      val out_of_date =
        Project.check_load_objects
          (error_info, location)
          (project', module_id)

      val _ = Incremental.set_project project'

      val filelist = map ModuleId.string out_of_date

    in
      case filelist
      of [] =>
        output_fn "No files need loading\n"
      |  _ =>
        (output_fn "Files to load\n";
	 app
           (fn s => output_fn (" " ^ s ^ "\n"))
            filelist)
    end

  (* Much of this code is taken from TopLevel.build.  The differences
     are:  the initial project, and what to do at the end. *)
  fun compile_targets_for 
	(location, options, error_info)
	project =
    let
      val initProject =
	Project.update_dependencies (error_info, location) project

      fun recompile_one
            ((project, depend_map, compile_map), module) =
        let
          fun do_recompile_one mod_id =
            let
              val (project, depend_map) =
                Project.read_dependencies
                  (error_info, location)
                  (project, mod_id, depend_map);

              val (out_of_date, compile_map) =
                Project.check_compiled'
                  (error_info, location)
                  (project, mod_id)
                  ([], compile_map)

              val project =
                TopLevel.compile_file'
                  error_info
                  (options, project, out_of_date);

              val status_map =
                Lists.reducel Project.mark_compiled (compile_map, out_of_date)
            in
              (project, depend_map, compile_map)
            end
        in
          do_recompile_one (ModuleId.from_host (OS.Path.file module, location))
        end

      val (finalProject, _, _) =
        Lists.reducel
          recompile_one
          ((initProject, Project.empty_map, Project.visited_pervasives),
           Project.currentTargets initProject);
    in
      finalProject
    end

  fun compile_targets 
	(location, options)
	error_info =
      Incremental.set_project
        (Project.map_dag (compile_targets_for 
                             (location,options,error_info))
                         (Incremental.get_project ())) 

  fun show_compile_targets_for
	(location, output_fn, error_info) project =
    let
      val name = Project.get_project_name project
      val initProject =
	Project.update_dependencies (error_info, location) project

      fun check_one
            ((project, out_of_date, depend_map, compile_map),
             module) =
        let
          fun do_check_one mod_id =
            let
              val (project, depend_map) =
                Project.read_dependencies
                  (error_info, location)
                  (project, mod_id, depend_map)

              val (out_of_date_now, compile_map) =
                Project.check_compiled'
                  (error_info, location)
                  (project, mod_id)
                  (out_of_date, compile_map)
            in
              (project, out_of_date_now, depend_map, compile_map)
            end
        in
          do_check_one (ModuleId.from_host (OS.Path.file module, location))
        end

      val (finalProject, out_of_date, _, _) =
        Lists.reducel
          check_one
          ((initProject, [], Project.empty_map, Project.visited_pervasives),
           Project.currentTargets initProject)

    in
      case out_of_date of
        [] => output_fn ("No files need compiling for " ^ name ^ "\n")
      | _ => (output_fn ("Files to compile for " ^ name ^ ":\n");
              app
               (fn s => output_fn (" " ^ ModuleId.string s ^ "\n"))
                out_of_date);
      finalProject
    end

  fun show_compile_targets
	(location, output_fn)
	error_info =
      Incremental.set_project
        (Project.map_dag (show_compile_targets_for 
                             (location,output_fn,error_info))
                         (Incremental.get_project ()))

  fun load_targets_for
	(user_context, location, options, preferences, output_fn, error_info) 
        project =
    let
      val initProject =
	Project.update_dependencies (error_info, location) project

      fun reload_one ((project, depend_map), module) =
        let
          fun do_reload_one mod_id =
            let
              val (project', depend_map) =
                Project.read_dependencies
                  (error_info, location)
                  (project, mod_id, depend_map);

	      (* Probably need a check_load_objects', to preserve
		 existing out_of_date list, if not compile_map. *)
              val out_of_date =
                Project.check_load_objects
                  (error_info, location)
                  (project', mod_id)

              val _ = Incremental.set_project project'
            in
              case Incremental.load_mos
                     error_info
                     (options, UserContext.get_context user_context, project',
		      mod_id, out_of_date, location) of
                NONE =>
                  output_fn ("Project " ^ (Project.get_project_name project) 
                                        ^ " is up to date\n")
              | SOME result =>
                  UserContext.process_result
                    {src = UserContext.COPY ("Shell.Build.loadObject \"" ^
                           		     ModuleId.string mod_id ^ "\""),
                     result = result,
                     user_context = user_context,
                     options = options,
                     preferences = preferences,
                     output_fn = output_fn};
              (project', depend_map)
            end
        in
          do_reload_one (ModuleId.from_host (OS.Path.file module, location))
        end

      val (finalProject, _) =
        Lists.reducel
          reload_one
          ((initProject, Project.empty_map),
           Project.currentTargets initProject);
    in
      finalProject
    end


  fun load_targets
	(user_context, location, options, preferences, output_fn)
	error_info =
      Incremental.set_project
        ((*Project.map_dag*) (load_targets_for 
                            (user_context, location, options, preferences, 
                             output_fn, error_info))
                         (Incremental.get_project ()))

  fun show_load_targets_for
	(location, output_fn, error_info) project =
    let
      val initProject =
	Project.update_dependencies (error_info, location) project

      fun check_one
            ((project, out_of_date, depend_map),
             module) =
        let
          fun do_check_one mod_id =
            let
              val (project', depend_map) =
                Project.read_dependencies
                  (error_info, location)
                  (project, mod_id, depend_map)

	      (* Probably need a check_load_objects', to preserve
		 existing out_of_date list, if not compile_map. *)
              val (out_of_date_now) =
                Project.check_load_objects
                  (error_info, location)
                  (project', mod_id)
            in
              (project, out_of_date_now, depend_map)
            end
        in
          do_check_one (ModuleId.from_host (OS.Path.file module, location))
        end

      val (finalProject, out_of_date, _) =
        Lists.reducel
          check_one
          ((initProject, [], Project.empty_map),
           Project.currentTargets initProject)

      val _ = Incremental.set_project finalProject
      val name = Project.get_project_name project
    in
      case out_of_date of
        [] => output_fn ("No files need loading for " ^ name ^ "\n")
      | _ => (output_fn ("Files to load for " ^ name ^ ":\n");
              app
               (fn s => output_fn (" " ^ ModuleId.string s ^ "\n"))
                out_of_date);
      finalProject
    end


  fun show_load_targets
	(location, output_fn)
	error_info =
      Incremental.set_project
        ((*Project.map_dag*) (show_load_targets_for 
                            (location, output_fn, error_info))
                         (Incremental.get_project ()))


  (**** The use functions ****)
  (* This section defines use_file, use_string, and read_dot_mlworks *)

  (* Use taking input from a token stream *)
  fun use_stream
	{token_stream, filename, user_context, toplevel_name, 
         user_options, preferences, debugger, error_info, output_fn, level} =
    let
      fun make_options () =
        ShellTypes.new_options (user_options, user_context)

      fun make_incremental_options () =
        Incremental.OPTIONS
        {options = make_options (),
         debugger = debugger}

      fun next () =
        if Lexer.eof token_stream then ()
        else
          let
            val result =
              Incremental.compile_source
              error_info
              (make_incremental_options(),
               UserContext.get_context user_context,
               Compiler.TOKENSTREAM1 token_stream)
          in
            UserContext.process_result
            {src = UserContext.COPY ("use \"" ^ String.toString filename ^ "\""),
             result = result,
             user_context = user_context,
             options = make_options (),
             preferences = preferences,
             output_fn = output_fn};
            next()
          end

    in
      ShellTypes.with_toplevel_name filename (fn _ => next ())
    end
  handle IO.Io {name = rdr, cause, ...} =>
    let
      val s = exnMessage cause ^ " in: " ^ rdr
    in
      Info.default_error'
        (Info.FATAL, Info.Location.FILE toplevel_name, s)
    end

  fun trim_spaces s =
    let
      fun trim (#" " :: rest) = trim rest
        | trim l = l
    in
      implode (rev (trim (rev (trim (explode s)))))
    end

  fun resolve_file_name (filename,pathname,relative) =
    let
      val expanded_path = 
        OS.FileSys.fullPath (if relative then pathname else ".")
      val expanded_file = 
        Getenv.expand_home_dir (trim_spaces filename)
      val new_name = 
        OSPath.mkCanonical (OSPath.mkAbsolute {path=expanded_file, relativeTo=expanded_path})
    in
      (new_name,OSPath.dir new_name)
    end

  (* A convenient function to wrap an error handler around *)
  fun sub_use_file
	{filename, user_context, toplevel_name, user_options, preferences,
	 debugger, error_info, output_fn, level} =
    let
      (* Unlike make, compile or recompile, use can read a file without a *)
      (* ".sml" extension, for compatibility with other compilers.  Also, *)
      (* the filename argument has already had home directories expanded. *)
      val Options.OPTIONS{compiler_options=Options.COMPILEROPTIONS{print_messages, ...}, ...} =
	ShellTypes.new_options(user_options, user_context)
      val (stream, filename) =
        (TextIO.openIn filename, filename)
        handle IO.Io {name = rdr, cause, ...} =>
          let
	    val s = exnMessage cause ^ " in: " ^ rdr
            val {base, ext} = OSPath.splitBaseExt filename
          in
            if not (isSome ext) then
              let
                val sml_name =
                  OSPath.joinBaseExt {base = base, ext = SOME "sml"}

              in
                (TextIO.openIn sml_name, sml_name)
                handle IO.Io _ =>
                  Info.error'
                  error_info
                  (Info.FATAL, Location.FILE toplevel_name, s)
              end
            else
              Info.error'
              error_info
              (Info.FATAL, Location.FILE toplevel_name, s)
          end
      val _ =
	if print_messages then
	  let
	    fun spaces y =
	      if y <= 0 then "Use: " ^ filename else ("   " ^ spaces (y-1))
	  in
	    output_fn (spaces level ^ "\n")
	  end
	else
	  ()

      val token_stream =
        Lexer.mkFileTokenStream (stream, filename)
    in
      use_stream {token_stream = token_stream,
                  filename = filename,
                  user_context = user_context,
                  toplevel_name = toplevel_name,
                  user_options = user_options,
                  preferences = preferences,
                  debugger = debugger,
                  error_info = error_info,
                  output_fn = output_fn,
                  level = level}
      handle exn => (TextIO.closeIn stream; raise exn);
      TextIO.closeIn stream
    end

  (* We could move these into shell_data if we don't like the globality *)
  val use_level = ref 0
  val use_pathname = ref "."

  (* we need to be careful with the debugger function that is *)
  (* passed in to internal_use_file.   For a normal use, we pass in the *)
  (* identity function.  This means that any exceptions get handled only *)
  (* by the outermost debugger handler and the user can write "use <foo> *)
  (* handle Div => ..." and have it behave correctly. *)

  fun internal_use_file (shell_data, debugger, output_fn, filename) = 
    let
      val ShellTypes.SHELL_DATA {get_user_context,
                                 user_options,
                                 user_preferences,
                                 ...} =
        shell_data
      (* Do we resolve pathnames relative to the pathnames of any uses we *)
      (* are already in or relative to the current working directory? *)
      val Preferences.USER_PREFERENCES 
        ({use_relative_pathname = ref relative,...},_) = user_preferences
      val toplevel_name = ShellTypes.get_current_toplevel_name()
      val (new_name,new_path) = 
        resolve_file_name (filename,!use_pathname,relative)
        handle Getenv.BadHomeName s =>
          Info.default_error'
          (Info.FATAL, Info.Location.FILE toplevel_name,
           "Invalid home name: " ^ s)
             | OS.SysErr _ => 
          Info.default_error'
          (Info.FATAL, Info.Location.FILE toplevel_name,
           "No such file: `" ^ filename ^ "'")

      val error_info = Info.make_default_options ()
      val level = !use_level
      val old_pathname = !use_pathname
    in
      use_level := level + 1;
      use_pathname := new_path;
      sub_use_file {filename = new_name,
                    user_context = get_user_context (),
                    error_info = error_info,
                    toplevel_name = ShellTypes.get_current_toplevel_name(),
                    user_options = user_options,
                    preferences = 
                      Preferences.new_preferences user_preferences,
                    debugger = debugger,
                    output_fn = output_fn,
                    level = level
                    } 
      handle exn => (use_level := level; 
                     use_pathname := old_pathname;
                     raise exn);
      use_level := level;
      use_pathname := old_pathname
    end

  (* Normally when we do a use, we are in the dynamic scope of a debugger *)
  (* function *)
  fun use_file (shell_data, output_fn, pathname) =
    internal_use_file (shell_data, fn x => x, output_fn, pathname)

  fun use_string (shell_data, output_fn, string) =
    let
      val toplevel_name = ShellTypes.get_current_toplevel_name()
      val error_info = Info.make_default_options ()
      val ShellTypes.SHELL_DATA {get_user_context,
                                 user_options,
                                 user_preferences,
                                 ...} =
        shell_data
      val level = !use_level
      val name = "<use_string input>"
      val r = ref string
      val token_stream = 
        Lexer.mkTokenStream 
        (fn _ => let val s = !r in  r := "" ; s end,name)
    in
      use_level := level + 1;
      use_stream {filename = name,
                  token_stream = token_stream,
                  user_context = get_user_context (),
                  error_info = error_info,
                  toplevel_name = ShellTypes.get_current_toplevel_name(),
                  user_options = user_options,
                  preferences = 
                    Preferences.new_preferences user_preferences,
                  debugger = fn x => x,
                  output_fn = output_fn,
                  level = level
                  }
      handle exn => (use_level := level; raise exn);
      use_level := level
    end

  (* Need to handle Info.Stop exceptions ourselves here as this function *)
  (* isn't called eg. within a listener evaluation *)
  (* Ditto for interrupt and return from debugger functions *)

  (* Also pass a proper debugger in here as there isn't a proper one in the *)
  (* evaluation context when this gets called *)

  fun read_dot_mlworks shell_data =
    let
      fun output_fn s = Messages.output s;
      val ShellTypes.SHELL_DATA{debugger,...} = shell_data
    in
      case Getenv.get_startup_filename () of
        NONE => ()
      | SOME pathname =>
          if OS.FileSys.access (pathname, []) handle OS.SysErr _ => false 
            then
              internal_use_file (shell_data, debugger, output_fn, pathname)
              handle Info.Stop _ => ()
                   | MLWorks.Interrupt => ()
                   | ShellTypes.DebuggerTrapped => ()
          else ()
    end 

  exception NotAnExpression = Incremental.NotAnExpression

  fun eval error_info (string, options, context) = 
    let
      val parser_basis = Incremental.parser_basis context
      val input_fn =
        let val sref = ref (string ^ ";")
        in
          fn _ => let val result = !sref in sref := "" ; result end
        end

      (* need to wrap the parser so that we stop on errors *)
      fun error_wrap f a =
        let val result = Info.wrap
          error_info
          (Info.WARNING, Info.RECOVERABLE, 
           Info.FAULT,Location.FILE "Eval Input")
          f
          a
        in
          result
        end

      val token_stream = 
        Parser.Lexer.mkTokenStream (input_fn,"<Eval input>")

      fun doit error_info () =
        let
          fun get_topdec () =
            (let val _ =
               Parser.parse_incrementally
               error_info
               (options,
                token_stream,
                parser_basis,
                Parser.initial_parser_state,
                Parser.Lexer.Token.PLAIN_STATE)
            in
              Info.error' error_info
              (Info.FATAL, Location.FILE "Eval Input", 
               "Unexpected end of line")
            end
            handle
            Parser.FoundTopDec(topdec,newpB,loc) =>
              topdec
          | Parser.SyntaxError(message,location) =>
              Info.error' error_info (Info.FATAL, location, message))
                   
          val topdec = get_topdec ()

        in
          Incremental.evaluate_exp_topdec
          error_info
          (Incremental.OPTIONS{options = options,
                               debugger = fn x => x},
           context,
           topdec)
        end
    in
      error_wrap doit ()
    end

  fun print_value ((object,ty),print_options,context) =
    let
      val debug_info = Incremental.debug_info context
    in
      ValuePrinter.stringify_value false
      (print_options, object, ty, debug_info)
    end

  fun print_type (ty,print_options,context) =
    let
      val completion_env =
        let
          val type_basis = Incremental.type_basis context
          val BasisTypes.BASIS(_,_,_,_,env) = type_basis
        in
          env
        end
    in        
      Completion.print_type (print_options,completion_env,ty)
    end

  datatype COMPLETION = 
    TOKEN of Token.Token |
    STRING of string | 
    NO_COMPLETION

  (* Should do this without allocating *)
  fun prefixp (string1,string2) =
    (size string1 <= size string2) andalso
    (string1 = 
     substring (* could raise Substring *)(string2,0,size string1))

    
  fun do_map (map,to_string,string) =
    NewMap.fold_in_rev_order
    (fn (acc,name,_) =>
     let val string' = to_string name
     in
       if prefixp (string,string')
         then string' :: acc
       else acc
     end)
    ([],map)

  fun get_valid_symbol (Ident.VAR s) = s
    | get_valid_symbol (Ident.CON s) = s
    | get_valid_symbol (Ident.EXCON s) = s
    | get_valid_symbol (Ident.TYCON' s) = s

  fun get_env_names (Datatypes.ENV (Datatypes.SE strmap,
                                    Datatypes.TE tymap,
                                    Datatypes.VE (_,valmap)),
                     id) =
    do_map (strmap,(fn Ident.STRID s => Symbol.symbol_name s),id) @@    
    do_map (tymap,(fn Ident.TYCON s => Symbol.symbol_name s),id) @@    
    do_map (valmap,(Symbol.symbol_name o get_valid_symbol),id)

  fun get_basis_names (BasisTypes.BASIS(_,
                                        nameset,
                                        BasisTypes.FUNENV funmap,
                                        BasisTypes.SIGENV sigmap,
                                        env),
                       id) =
    get_env_names (env,id) @@
    do_map (funmap,(fn Ident.FUNID s => Symbol.symbol_name s),id) @@
    do_map (sigmap,(fn Ident.SIGID s => Symbol.symbol_name s),id)

  exception NoEnv

  fun get_env (path,BasisTypes.BASIS(_,_,_,_,env)) =
    let
      fun get_env_env ([],env) = env
        | get_env_env (sym::path,Datatypes.ENV(Datatypes.SE strmap,_,_)) =
          let
            val strid = Ident.STRID(sym)
            val str = NewMap.apply'(strmap,strid)
            fun get_str_env (Datatypes.COPYSTR(_,str)) = get_str_env str
              | get_str_env (Datatypes.STR (_,_,env)) = env
          in
            get_env_env(path,get_str_env str)
          end
    in
      get_env_env (path,env)
    end
    handle NewMap.Undefined => raise NoEnv

  fun split_filename s = 
    (OSPath.dir s, OSPath.file s)

  (* We should review this lot if and when FileSys gets implemented *)
  (* properly. In particular, ensure that the right exceptions are *)
  (* handled *)

  fun find_matches (dir,s) = 
    let
      val names = ref []
      val _ = debug_out ("Opening " ^ dir)

      (* On Win32 if dir is an empty string then Syserr exception is raised. *)
      val directory = if (dir = "") then "." else dir

      (* On Win32 raises an exception if the parameter passed to OS.FileSys.fullPath
       * contains only the drive letter. *)
      val full_path = OS.FileSys.fullPath (Getenv.expand_home_dir directory)
	handle OS.SysErr _ => directory

      val d = OS.FileSys.openDir (full_path)

      fun get_names () = 
        case OS.FileSys.readDir d of
          NONE => ()
        | SOME next =>  
            (if size next >= size s andalso
               substring (next,0,size s) = s
               then names := next :: !names
             else ();
             get_names ())
    in
      get_names ();
      OS.FileSys.closeDir d; (* Should be an exn handler for this too *)
      !names
    end
    (* This shouldn't be a catchall, but we should sort out exactly what *)
    (* exceptions can be raised *)
    (* XXXEXCEPTION: should handle OS.SysErr *)
    handle _ => []

  fun complete_token (sofar,TOKEN (token as Token.RESERVED _),context) =
    complete_token (sofar,
                    TOKEN 
                    (Token.LONGID ([],
                                   Symbol.find_symbol
                                   (Token.makestring token))),
                    context)
    | complete_token (sofar,
                      TOKEN (token as Token.LONGID (path,id)), 
                      context) =
      let
        val type_basis = Incremental.type_basis context
        val string = Symbol.symbol_name id

        val completions = 
          case path of
            [] => get_basis_names (type_basis,string)
          | _ =>
              (let
                val env = get_env (path,type_basis)
                val pathname =
		  concat
                  (rev (Lists.reducel
                        (fn (acc,s) => "." :: Symbol.symbol_name s :: acc)
                        ([],path)))
              in
                map (fn s => pathname ^ s) (get_env_names (env,string))
              end
            handle NoEnv => [])

        fun is_structure_path path =
          (ignore(get_env (path,type_basis)); true) handle NoEnv => false
      in
        case completions of 
          [s] => 
            if s = sofar andalso is_structure_path (path @@ [id])
              then [s ^ "."]
            else completions
        | _ => completions
      end


    | complete_token (sofar,STRING s,context) =
      (* s is a filename *)
      let
        (* For this to work on the PC, we need to convert back and forth *)
        (* between double and single backslashes *)
        (* This really is horrible though *)
        fun munge1 ([],acc) = implode (rev acc)
          | munge1 (#"\\" :: #"\\" ::rest,acc) = munge1 (rest, #"\\" ::acc)
          | munge1 (a::rest,acc) = munge1 (rest,a::acc)
        fun munge2 ([],acc) = implode (rev acc)
          | munge2 (#"\\" ::rest,acc) = munge2 (rest, #"\\" :: #"\\" :: acc)
          | munge2 (a::rest,acc) = munge2 (rest,a::acc)
        val munged_sofar = munge1 (explode sofar,[])
        val (dir,fname) = split_filename (munge1 (explode s,[]))
        val names = find_matches (dir,fname)
        val completions' =
          (if dir ="" then names
           else map (fn n => OSPath.concat [dir,n]) names)
 	val completions = map (fn s => munge1 (explode s, [])) completions'
        fun isDir s =
          let
            val s = Getenv.expand_home_dir s
              handle Getenv.BadHomeName _ => s
            val s = OS.FileSys.fullPath s
            val result = OS.FileSys.isDir s
          in
            result
          end
          handle OS.SysErr _ => false
      in
        map (fn s => munge2 (explode s,[]))
        (case completions of 
           [s] => 
             (if s = munged_sofar andalso isDir s
               then [OSPath.concat [s,""]]
               (* XXXEXCEPTION: should handle OS.SysErr *)
             else completions)
         | _ => completions)
      end

    | complete_token _ = []

  fun filter_completions l =
    let
      fun remove_duplicates ([],acc) = acc
        | remove_duplicates ([a],acc) = a :: acc
        | remove_duplicates (a :: (rest as (b :: l)), acc) =
          if a = b 
            then remove_duplicates (rest,acc)
          else remove_duplicates (rest,a::acc)
    in
      remove_duplicates (Lists.qsort ((op>):string*string->bool) l, [])
    end

  fun find_string (s:string) =
    let
      val chars = explode s
      fun strip [] = NO_COMPLETION
        | strip (a::b) =
          if a = #"\"" then (* \" *)
	    find_string (b,[])
          else strip b
      and find_string ([],acc) =
        STRING (implode (rev acc))
        | find_string (a::b,acc) =
          if a = #"\"" then (* \" *)
            strip b
          else 
	    find_string (b,a::acc)
    in
      strip chars
    end
      
  fun get_completions (s,options,context) =
    let
      fun get_token s =
        case find_string s of
          STRING s => STRING s
        | _ => 
            let
              val error_info = Info.make_default_options ()
              fun doit error_info () =
                let
                  val x = ref s
                  fun input_fn _ = 
                    (let val result = !x in x := ""; result end)
                  val ts = Lexer.mkTokenStream (input_fn,"")
                  fun get_token tok =
                    case Lexer.getToken error_info (options,
                                                    Lexer.Token.PLAIN_STATE,
                                                    ts) of
                      Token.EOF (state) => tok
                    | new_tok => get_token (TOKEN new_tok)
                in
                  get_token NO_COMPLETION
                end
            in
              Info.with_report_fun
              error_info
              (fn _ => ())
              doit 
              ()
            end
      val to_complete = get_token s
      val sofar =
        case to_complete of
          NO_COMPLETION => ""
        | TOKEN tok => Token.makestring tok
        | STRING string => string
    in
      (sofar,
       filter_completions (complete_token (sofar,to_complete,context)))
    end

  (* find a common completion *)

  fun find_common_completion [] = ""
    | find_common_completion (target::l) =
      let
        fun check (s,m,n) =
          if m = n 
            then n
          else if MLWorks.String.ordof(s,m) = MLWorks.String.ordof(target,m)
                 then check (s,m+1,n)
               else m
        fun aux ([],n) = n
          | aux ((a::l),n) =
            aux (l,check(a,0,(Int.min (size a,n))))
        val result = (* could raise Substring *)
          substring (target,0,aux(l,size target))
      in
        result
      end

    (* This should evaluate an identifier *)
    fun lookup_name (name,context,default) =
      let
        val tycontext = 
          Basis.basis_to_context (Incremental.type_basis context)
        val valid = Ident.VAR(Symbol.find_symbol name)
        val valtype =
	  #1(Basis.lookup_val (Ident.LONGVALID (Ident.NOPATH, valid),
                               tycontext,
                               Ident.Location.UNKNOWN,
                               false))
        val mlval = Inter_EnvTypes.lookup_val(valid,
                                              Incremental.inter_env context)
      in
        (mlval,valtype)
      end
    handle _ => default (* !!!!!! *)


  fun value_from_history_entry
	(UserContext.ITEM {id, context, source, ...}, options) =
      (* We switch off all the compiler options when calling eval here, 
         which amongst other things enables us to detect that we are compiling
         code associated with the history mechanism.  I suppose we could 
         introduce another option for this, but that seems overkill.  

         At the moment every time we switch focus the menu is refreshed, 
         multiple times, which in turn forces the history to be calculated 
         frequently, as the menu items are not computed lazily.  This then 
         forces the optimiser to be called multiple times whenever we switch 
         windows.  Debugging the optimiser is made very difficult in such a 
         setting, as it is being called all over the place.  If we make the 
         "spurious" calls to the optimiser stand out from the "genuine" ones
         then this simplifies the debugging output.  I'm not totally convinced
         that the event handling, menus and history mechanisms are interacting
         in the way that was originally expected, but the performance hit 
         probably isn't too much at the moment.  
       *)

    let val Options.OPTIONS 
            {listing_options, print_options, compat_options, extension_options,
             compiler_options =
               Options.COMPILEROPTIONS {mips_r4000, sparc_v7, ...} } = options
        val options' = 
            Options.OPTIONS 
            {listing_options=listing_options, print_options=print_options, 
             compat_options=compat_options, 
             extension_options=extension_options,
             compiler_options =
               Options.COMPILEROPTIONS 
               {generate_debug_info=false, debug_variables=false,
                generate_moduler=false, intercept=false, interrupt=false, 
                opt_handlers=false, opt_leaf_fns=false, opt_tail_calls=false,
                opt_self_calls=false, local_functions=false, 
                print_messages=false,
                mips_r4000=mips_r4000, sparc_v7=sparc_v7} }
     in 
      case id of
        Ident.VALUE (Ident.VAR s) =>
	  (let
	    val value =
	      eval Info.null_options
              (Ident.Symbol.symbol_name s,
               options', context)
	  in
            (* This should be done by with_standard_output *)
            TextIO.flushOut TextIO.stdOut;
	    case source of
	      UserContext.STRING str => SOME (str, value)
	    | UserContext.COPY str => SOME (str, value)
	  end
          handle _ => NONE)
      |  _ =>
           NONE
    end

  fun value_from_user_context (user_context, user_options) =
    case UserContext.get_latest user_context
    of NONE => NONE
    |  SOME item =>
      value_from_history_entry
	(item, ShellTypes.new_options (user_options, user_context))
 end
@


1.136.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.136  1999/03/25  18:53:03  mitchell
 * [Bug #190532]
 * Don't apply map_dag when loading
 *
@


1.135
log
@[Bug #190532]
Ensure update_dependencies is called on subprojects first
@
text
@d6 4
d1448 1
a1448 1
        (Project.map_dag (load_targets_for 
d1506 1
a1506 1
        (Project.map_dag (show_load_targets_for 
@


1.134
log
@[Bug #190521]
OS.FileSys.readDir now returns an option type.
@
text
@d6 4
d1155 3
a1157 2
        val proj' = Project.update_dependencies 
                      (error_info, location) proj
d1383 3
a1385 3
  fun load_targets
	(user_context, location, options, preferences, output_fn)
	error_info =
d1388 1
a1388 3
	Project.update_dependencies
	  (error_info, location) 
          (Incremental.get_project ())
d1413 2
a1414 1
                  output_fn "up to date\n"
d1436 1
a1436 1
      Incremental.set_project finalProject
d1439 3
a1441 2
  fun show_load_targets
	(location, output_fn)
d1443 8
d1453 1
a1453 3
	Project.update_dependencies
	  (error_info, location) 
          (Incremental.get_project ())
d1486 1
d1489 2
a1490 2
        [] => output_fn "No files need load\n"
      | _ => (output_fn "Files to load:\n";
d1493 2
a1494 1
                out_of_date)
d1496 9
@


1.133
log
@[Bug #190532]
Use Project.map_dag when compiling a project
@
text
@d6 4
d1901 1
d1903 1
d1905 3
a1907 5
        let
          val next = OS.FileSys.readDir d
        in
          if next = "" then ()
          else
d1909 1
a1909 1
               substring (* could raise Substring *) (next,0,size s) = s
a1912 1
        end
@


1.132
log
@[Bug #190507]
Change dependency checking messages to diagnostic messages
@
text
@d6 4
d1266 3
a1268 3
  fun compile_targets_for project 
	(location, options)
	error_info =
a1269 3
      val initProject = compile_subprojects_for project 
                          (location,options) error_info

d1271 1
a1271 2
	Project.update_dependencies
	  (error_info, location) initProject
a1311 17
  and compile_subprojects_for project 
	(location, options)
	error_info =
    let val subprojects = Project.get_subprojects project 
        val _ = case subprojects of
                  [] => ()
                | _ => 
                    diagnostic (1,
                      fn _ => ["Bringing subprojects of ", 
                               Project.get_project_name project,
                               " up to date."]);
        val subprojects' = map (fn p => compile_targets_for p
                                        (location, options) error_info)
                               subprojects
     in Project.set_subprojects(project, subprojects')
    end

d1316 3
a1318 2
        (compile_targets_for (Incremental.get_project ())
                             (location,options) error_info)
d1320 2
a1321 3
  fun show_compile_targets
	(location, output_fn)
	error_info =
d1323 1
d1325 1
a1325 3
	Project.update_dependencies
	  (error_info, location)
          (Incremental.get_project ())
a1355 1
      val _ = Incremental.set_project finalProject
d1358 2
a1359 2
        [] => output_fn "No files need compiling\n"
      | _ => (output_fn "Files to compile:\n";
d1362 2
a1363 1
                out_of_date)
d1365 8
@


1.131
log
@[Bug #190505]
Support for precompilation of subprojects
@
text
@d6 4
d536 1
d553 1
d640 8
a647 1
  val do_debug = false
d1318 5
a1322 3
                | _ => print("Bringing subprojects of " 
                     ^ (Project.get_project_name project)
                     ^ " up to date.\n")
@


1.130
log
@[Bug #50108]
Change ModuleId from an equality type
@
text
@d6 4
a1086 4
      fun compile_one (proj, m) =
        TopLevel.compile_file'
	  error_info
	  (options, proj, m, false)
d1089 3
a1091 1
        (Lists.reducel compile_one (project', out_of_date))
d1130 2
a1131 1
        val proj' = Project.update_dependencies (error_info, location) proj
d1249 1
a1249 1
  fun compile_targets
d1253 3
d1258 1
a1258 2
	  (error_info, location)
	  (Incremental.get_project ())
a1262 5
          fun compile_one (proj, m) =
            TopLevel.compile_file'
              error_info
              (options, proj, m, false);

d1277 3
a1279 1
                Lists.reducel compile_one (project, out_of_date);
d1296 16
a1311 1
      Incremental.set_project finalProject
d1314 7
d1328 1
a1328 1
	  (Incremental.get_project ())
d1375 2
a1376 2
	  (error_info, location)
	  (Incremental.get_project ())
d1432 2
a1433 2
	  (error_info, location)
	  (Incremental.get_project ())
a2173 6






@


1.129
log
@[Bug #190500]
Remove redundant require statements
@
text
@d6 4
d892 18
d921 1
a921 1
	Lists.filter
@


1.128
log
@[Bug #190493]
Make calls to eval originating from the history mechanism distinguishable
@
text
@d6 4
a495 1
require "^.system.__file_time";
@


1.127
log
@[Bug #70204]
Add subprojects into linking process, and place binaries in the right place
@
text
@d6 4
d2063 54
a2116 17
    case id of
      Ident.VALUE (Ident.VAR s) =>
	(let
	  val value =
	    eval Info.null_options
            (Ident.Symbol.symbol_name s,
             options, context)
	in
          (* This should be done by with_standard_output *)
          TextIO.flushOut TextIO.stdOut;
	  case source of
	    UserContext.STRING str => SOME (str, value)
	  | UserContext.COPY str => SOME (str, value)
	end
        handle _ => NONE)
    |  _ =>
         NONE
d2125 6
@


1.126
log
@[Bug #70204]
Do work for making exes
@
text
@d6 4
d892 11
a902 9
	List.foldr
	op@@
	[]
	(map
	 (fn name =>
	  Project.allObjects (options, location)
	  (project, name)
	  )
	 targets)
d911 3
d1017 5
d1025 1
a1025 1
       libs=libs,
@


1.125
log
@[Bug #70198]
Add functions to make dlls and exes from a project
@
text
@d6 4
d812 2
d817 3
d827 36
a863 1
(*
d865 1
a865 1
      {objects=,
d869 2
a870 2
       dll_or_exe=LinkSupport.EXE
       base=,
d872 1
a872 3
       linker=LOCAL}
*)
      ()
@


1.124
log
@[Bug #30468]
Change types of mkAbsolute and mkRelative to uses records with names fields
@
text
@d6 4
d477 1
d500 3
d525 3
d578 1
a578 1
		Project.ModuleId = TopLevel.ModuleId
d582 2
a583 1
		TopLevel.Project
d609 1
d805 171
@


1.123
log
@[Bug #50071]
Add support for force compiles and loads
@
text
@d6 4
d844 1
a844 1
          OS.Path.mkAbsolute(OS.Path.fromUnixPath path, project_dir)
d1246 1
a1246 1
        OSPath.mkCanonical (OSPath.mkAbsolute (expanded_file, expanded_path))
@


1.122
log
@[Bug #50071]
Add support for touch_all_sources
@
text
@d6 4
a782 37
  fun touch location (mod_name, module_id) =
    let
      val error_options = Info.make_default_options ()

      val project = Incremental.get_project ()
    in
      case Project.get_source_info (project, module_id) of
        SOME (file, _) =>
          ((OS.FileSys.setTime (file, NONE);
            Project.set_source_info
              (project, module_id, SOME (file, FileTime.modTime file)))
           handle OS.SysErr _ =>
	     Info.error'
               error_options
               (Info.FATAL, location,
                concat ["can't touch `", file, "' "]))
      | NONE =>
	  Info.error'
            error_options
            (Info.FATAL, location,
             concat ["can't find file `", mod_name, "'"])
    end

  fun touch_source (mod_name, location) =
    touch location (mod_name, ModuleId.from_string (mod_name, location))

  fun touch_all_sources location =
    let val _ = Incremental.reset_project()
        val proj = Incremental.get_project ()
        val proj' = Project.update_dependencies(Info.make_default_options (), location) proj
        val _ = Incremental.set_project proj'
        val units =
	    List.filter
	      (fn (s, _) => String.sub (s, 0) <> #" ")
	      (Project.list_units proj')
     in app (touch location) units end

d817 54
@


1.121
log
@[Bug #50071]
Remove debug printout
@
text
@d6 4
d464 1
d778 2
a779 1
  fun touch_source (mod_name, location) =
a780 3
      val module_id =
	ModuleId.from_string (mod_name, location)

d801 14
@


1.120
log
@[Bug #30389]
Keep projects more in step with projfiles
@
text
@d6 4
a1042 2
      val _ = print "in load_targets\n"

a1080 5

      val _ =
	map
	  (fn s => (print s; print "\n"))
	  (Project.currentTargets initProject)
@


1.119
log
@[Bug #30312]
Replacing OS.FileSys.modTime with system dependent version to sort out
MS time stamp problems.
@
text
@d6 5
d477 1
d499 1
d870 1
a870 1
          (Incremental.get_project (), module_id, Project.empty_map)
d936 1
a936 1
	Project.fromFileInfo
d987 1
a987 1
	Project.fromFileInfo
d1035 1
a1035 1
	Project.fromFileInfo
d1099 1
a1099 1
	Project.fromFileInfo
@


1.118
log
@[Bug #30337]
Change uses of OS.Path.concat to take a string list, instead of a pair of strings.
@
text
@d6 4
d453 1
d775 1
a775 1
              (project, module_id, SOME (file, OS.FileSys.modTime file)))
@


1.117
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d6 4
d618 1
a618 1
      (file_from_location location;
d1602 1
a1602 1
          (get_env (path,type_basis); true) handle NoEnv => false
d1630 1
a1630 1
           else map (fn n => OSPath.concat (dir,n)) names)
d1647 1
a1647 1
               then [OSPath.concat (s,"")]
@


1.116
log
@[Bug #70065]
Remove uses of MLWorks.IO.messages and use the Messages structure
@
text
@d6 4
d448 1
d568 1
a568 1
      MLWorks.IO.output (MLWorks.IO.terminal_out,"ShellUtils: " ^ s ^ "\n")
d1642 1
a1642 2
             ((* MLWorks.IO.output (MLWorks.IO.terminal_out,"Stuff:" ^ munged_sofar ^ ":" ^ s ^ ":" ^ "\n"); *)
              if s = munged_sofar andalso isDir s
@


1.115
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d6 4
d443 1
d1357 1
a1357 1
      fun output_fn s = MLWorks.IO.output (MLWorks.IO.messages, s);
@


1.114
log
@[Bug #30203]
Incremental.check_mo (and check_module) return module ids
, instead of strings.
@
text
@d6 35
a442 1
require "../basics/module";
d456 1
a456 1
require "../main/io";
a478 1
   structure Module : MODULE
d522 2
a523 2
   sharing type Editor.Location.T = Module.Location = ModuleId.Location
   sharing type ModuleId.ModuleId = Incremental.ModuleId = Module.ModuleId =
a528 2
   sharing type Incremental.InterMake.Compiler.Info.options = 
                Module.InfoOptions
a530 1
  structure Incremental = Incremental
a544 1
  type Result = Incremental.Result
d743 1
a743 1
  fun touch_source_module (mod_name, toplevel_name) =
d746 1
a746 1
	ModuleId.from_string (mod_name, Info.Location.FILE toplevel_name)
d749 2
d752 11
a762 4
      case Module.findSource
	     (error_options, Info.Location.FILE toplevel_name)
	     module_id of
	NONE =>
d765 2
a766 28
            (Info.FATAL, Info.Location.FILE toplevel_name,
             concat ["can't find module `", mod_name, "' on source path"])
      | SOME (_, m, _) =>
	  OS.FileSys.setTime (Module.sourceName m, NONE)
	  handle OS.SysErr _ =>
	    Info.error'
              error_options
              (Info.FATAL, Info.Location.FILE toplevel_name,
               concat ["can't touch `", Module.sourceName m, "' "])
    end

  fun touch_source_file (filename, toplevel_name) =
    let 
      val expanded = Getenv.expand_home_dir filename

      val {base, ext} = OSPath.splitBaseExt expanded

      val sml_name =
        if (not (isSome ext)) then
	  OSPath.joinBaseExt {base = base, ext = SOME "sml"}
	else
	  expanded
    in
      OS.FileSys.setTime (sml_name, NONE)
      handle OS.SysErr _ =>
        Info.default_error'
          (Info.FATAL, Info.Location.FILE toplevel_name, 
	   concat ["can't touch `", sml_name, "' "])
a767 4
    handle Getenv.BadHomeName s =>
      Info.default_error'
        (Info.FATAL, Info.Location.FILE toplevel_name,
	 "Invalid home name: " ^ s)
d769 1
a769 1
  fun delete_from_project (mod_name, toplevel_name) =
d771 1
a771 2
      val module_id =
	ModuleId.from_string (mod_name, Info.Location.FILE toplevel_name)
d776 4
a779 3
  fun load_source_file
	(user_context, toplevel_name, options, user_options, preferences,
	 debugger, output_fn)
d781 1
a781 1
	module_id =
d783 2
a784 36
      val inc_options = make_incremental_options(options,debugger)
    in
      case Incremental.add_module
	     error_info
	     inc_options
	     (UserContext.get_context user_context, module_id,
              toplevel_name)
      of NONE => ()
      |  SOME result =>
        UserContext.process_result
	  {src =
	     UserContext.COPY ("Shell.Build.loadSource \"" ^
                               (ModuleId.string module_id) ^ "\""),
	   result = result,
	   user_context = user_context,
	   options = options,
	   preferences = preferences,
	   output_fn = output_fn}
    end

  fun check_load_source_file
	(context,toplevel_name,options,debugger,output_fn)
	error_info
	module_id =
    let
      val filelist =
        map ModuleId.string
	(Incremental.check_module error_info (module_id, toplevel_name))
    in
      case filelist of
        [] => output_fn "No units need loading from source\n"
      | _ => (output_fn "Units to load from source:\n";
              app
               (fn s => output_fn (" " ^ s ^ "\n"))
                filelist)
    end
a785 5
  fun compile_file
	(toplevel_name, options, output_fn)
	error_info
	module_id =
    let
d788 1
a788 1
          (error_info, Location.FILE toplevel_name)
d793 1
a793 1
          (error_info, Location.FILE toplevel_name)
d805 2
a806 2
  fun check_compile_file
	(toplevel_name, options, output_fn)
d808 1
a808 1
	module_id =
d810 4
d816 1
a816 1
          (error_info, Location.FILE toplevel_name)
d821 1
a821 1
          (error_info, Location.FILE toplevel_name)
d824 1
a824 2
      val _ =
        Incremental.set_project project'
d827 2
a828 2
        [] => output_fn "No units need compiling\n"
      | _ => (output_fn "Units to compile:\n";
d835 1
a835 1
	(user_context, toplevel_name, options, preferences, output_fn)
d837 36
a872 19
	module_id =
    case Incremental.load_mo
	   error_info
	   (options, UserContext.get_context user_context,
	    module_id, Location.FILE toplevel_name) of
	   NONE =>
	     print "up to date\n"
	 | SOME result =>
	     (UserContext.process_result
	      {src = UserContext.COPY ("Shell.Build.loadObject \"" ^ 
                      ModuleId.string module_id ^ "\""),
	       result = result,
	       user_context = user_context,
	       options = options,
	       preferences = preferences,
	       output_fn = output_fn})
      
  fun check_load_file
	(toplevel_name, output_fn)
d874 1
a874 1
	module_id =
d876 16
a891 4
      val filelist =
        map ModuleId.string
        (Incremental.check_mo error_info
         (module_id, Location.FILE toplevel_name))
d895 1
a895 1
        print "No units need loading\n"
d897 1
a897 1
        (print "Units to load\n";
d903 215
d1124 1
a1124 2
         user_options, preferences, debugger, error_info, output_fn, 
         level, queue_function} =
a1151 1
            queue_function (level+1);
d1189 1
a1189 1
	 debugger, error_info, output_fn, level, queue_function} =
d1243 1
a1243 2
                  level = level,
                  queue_function = queue_function}
d1258 1
a1258 5
  fun internal_use_file (shell_data,
                         debugger,
                         output_fn,
                         queue_function,
                         filename) = 
d1296 1
a1296 2
                    level = level,
                    queue_function = queue_function
d1307 2
a1308 6
  fun use_file (shell_data,output_fn,queue_function, pathname) =
    internal_use_file (shell_data,
                       fn x => x,
                       output_fn,
                       queue_function, 
                       pathname)
d1310 1
a1310 1
  fun use_string (shell_data,output_fn,queue_function,string) =
d1337 1
a1337 2
                  level = level,
                  queue_function = queue_function
d1349 2
a1350 1
  fun read_dot_mlworks (shell_data,queue_function) =
d1360 1
a1360 2
              internal_use_file (shell_data,debugger,output_fn,
                                 queue_function, pathname)
@


1.113
log
@[Bug #50019]
Modify process_result to take a UserContext.source_reference type for src.
@
text
@d6 4
d786 2
a787 1
	     UserContext.COPY ("Shell.Build.loadSource \"" ^ ModuleId.string module_id ^ "\""),
d801 2
a802 1
	Incremental.check_module error_info (module_id, toplevel_name)
d888 3
a890 2
        Incremental.check_mo error_info (module_id, 
                                         Location.FILE toplevel_name)
@


1.113.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 * Revision 1.113  1997/07/31  12:37:34  johnh
 * [Bug #50019]
 * Modify process_result to take a UserContext.source_reference type for src.
 *
@


1.113.2.2
log
@[Bug #30203]
Merging - checking files to be recompiled.
@
text
@a5 8
 * Revision 1.113.2.1  1997/09/11  20:54:40  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.114  1997/09/17  16:06:41  brucem
 * [Bug #30203]
 * Incremental.check_mo (and check_module) return module ids
 * , instead of strings.
 *
d786 1
a786 2
	     UserContext.COPY ("Shell.Build.loadSource \"" ^
                               (ModuleId.string module_id) ^ "\""),
d800 1
a800 2
        map ModuleId.string
	(Incremental.check_module error_info (module_id, toplevel_name))
d886 2
a887 3
        map ModuleId.string
        (Incremental.check_mo error_info
         (module_id, Location.FILE toplevel_name))
@


1.113.2.3
log
@[Bug #30326]
@
text
@a5 4
 * Revision 1.113.2.2  1997/11/11  16:14:58  johnh
 * [Bug #30203]
 * Merging - checking files to be recompiled.
 *
d430 1
a430 1
require "../main/mlworks_io";
@


1.113.2.4
log
@[Bug #30071]
The action queue is no more, so ShellUtils.use_{file,string} and
ShellUtils.read_dot_mlworks no longer take queue functions.
@
text
@a5 3
 * Revision 1.113.2.3  1997/11/20  16:59:23  daveb
 * [Bug #30326]
 *
d920 2
a921 1
         user_options, preferences, debugger, error_info, output_fn, level} =
d949 1
d987 1
a987 1
	 debugger, error_info, output_fn, level} =
d1041 2
a1042 1
                  level = level}
d1057 5
a1061 1
  fun internal_use_file (shell_data, debugger, output_fn, filename) = 
d1099 2
a1100 1
                    level = level
d1111 6
a1116 2
  fun use_file (shell_data, output_fn, pathname) =
    internal_use_file (shell_data, fn x => x, output_fn, pathname)
d1118 1
a1118 1
  fun use_string (shell_data, output_fn, string) =
d1145 2
a1146 1
                  level = level
d1158 1
a1158 2

  fun read_dot_mlworks shell_data =
d1168 2
a1169 1
              internal_use_file (shell_data, debugger, output_fn, pathname)
@


1.113.2.5
log
@[Bug #30071]
@
text
@a5 5
 * Revision 1.113.2.4  1997/11/26  12:19:54  daveb
 * [Bug #30071]
 * The action queue is no more, so ShellUtils.use_{file,string} and
 * ShellUtils.read_dot_mlworks no longer take queue functions.
 *
d423 1
d460 1
d504 2
a505 2
   sharing type Editor.Location.T = ModuleId.Location
   sharing type ModuleId.ModuleId = Incremental.ModuleId = 
d511 2
a734 2

      val project = Incremental.get_project ()
d736 4
a739 11
      case Project.get_source_info (project, module_id) of
        SOME (file, _) =>
          ((OS.FileSys.setTime (file, NONE);
            Project.set_source_info
              (project, module_id, SOME (file, OS.FileSys.modTime file)))
           handle OS.SysErr _ =>
	     Info.error'
               error_options
               (Info.FATAL, Info.Location.FILE toplevel_name,
                concat ["can't touch `", file, "' "]))
      | NONE =>
d743 8
a750 1
             concat ["can't find file `", mod_name, "'"])
@


1.113.2.6
log
@[Bug #30071]
Removed functions for loading from source files.
@
text
@a5 3
 * Revision 1.113.2.5  1997/11/26  16:50:46  daveb
 * [Bug #30071]
 *
d516 1
d531 1
d785 43
@


1.113.2.7
log
@[Bug #30017]
Rationalised Shell.Project commands:
Removed touch_source_file.
Added {,show_}{compile,load}_targets.
Made load/compile functions take strings instead of module_ids, and
explicit location values.
@
text
@a5 4
 * Revision 1.113.2.6  1997/12/02  16:31:29  daveb
 * [Bug #30071]
 * Removed functions for loading from source files.
 *
d731 1
a731 1
  fun touch_source (mod_name, location) =
d734 1
a734 1
	ModuleId.from_string (mod_name, location)
d748 1
a748 1
               (Info.FATAL, location,
d753 1
a753 1
            (Info.FATAL, location,
d757 24
a780 1
  fun delete_from_project (mod_name, location) =
d782 2
a783 1
      val module_id = ModuleId.from_string (mod_name, location)
a787 3

  (* All these compile and load commands share the same pattern.  
     A higher-order function seems called for. *)
d789 1
a789 1
	(location, options)
d791 1
a791 1
	filename =
a792 3
      val module_id =
        ModuleId.from_string (filename, location)

d795 1
a795 1
          (error_info, location)
d800 1
a800 1
          (error_info, location)
d812 2
a813 2
  fun show_compile_file
	(location, output_fn)
d815 1
a815 1
	filename =
a816 4
      val module_id =
        ModuleId.from_string
          (filename, location)

d819 1
a819 1
          (error_info, location)
d824 1
a824 1
          (error_info, location)
d827 2
a828 1
      val _ = Incremental.set_project project'
d831 2
a832 2
        [] => output_fn "No files need compiling\n"
      | _ => (output_fn "Files to compile:\n";
d839 1
a839 1
	(user_context, location, options, preferences, output_fn)
d841 19
a859 36
	filename =
    let
      val module_id = ModuleId.from_string (filename, location)

      val (project', _) =
        Project.read_dependencies
          (error_info, location)
          (Incremental.get_project (), module_id, Project.empty_map)

      val out_of_date =
        Project.check_load_objects
          (error_info, location)
          (project', module_id)

      val _ = Incremental.set_project project'
    in
      case Incremental.load_mos
	     error_info
	     (options, UserContext.get_context user_context,
	      project', module_id, out_of_date, location) of
        NONE =>
	  (* Surely this isn't the best action in a GUI? *)
	  output_fn "up to date\n"
      | SOME result =>
	  UserContext.process_result
	    {src = UserContext.COPY ("Shell.Build.loadObject \"" ^ 
                   ModuleId.string module_id ^ "\""),
	     result = result,
	     user_context = user_context,
	     options = options,
	     preferences = preferences,
	     output_fn = output_fn}
    end
     
  fun show_load_file
	(location, output_fn)
d861 1
a861 1
	filename =
d863 4
a866 15
      val module_id = ModuleId.from_string (filename, location)

      val (project', _) =
        Project.read_dependencies
          (error_info, location)
          (Incremental.get_project (), module_id, Project.empty_map)

      val out_of_date =
        Project.check_load_objects
          (error_info, location)
          (project', module_id)

      val _ = Incremental.set_project project'

      val filelist = map ModuleId.string out_of_date
d870 1
a870 1
        output_fn "No files need loading\n"
d872 1
a872 1
        (output_fn "Files to load\n";
a876 215

  (* Much of this code is taken from TopLevel.build.  The differences
     are:  the initial project, and what to do at the end. *)
  fun compile_targets
	(location, options)
	error_info =
    let
      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Incremental.get_project ())

      fun recompile_one
            ((project, depend_map, compile_map), module) =
        let
          fun compile_one (proj, m) =
            TopLevel.compile_file'
              error_info
              (options, proj, m, false);

          fun do_recompile_one mod_id =
            let
              val (project, depend_map) =
                Project.read_dependencies
                  (error_info, location)
                  (project, mod_id, depend_map);

              val (out_of_date, compile_map) =
                Project.check_compiled'
                  (error_info, location)
                  (project, mod_id)
                  ([], compile_map)

              val project =
                Lists.reducel compile_one (project, out_of_date);

              val status_map =
                Lists.reducel Project.mark_compiled (compile_map, out_of_date)
            in
              (project, depend_map, compile_map)
            end
        in
          do_recompile_one (ModuleId.from_host (OS.Path.file module, location))
        end

      val (finalProject, _, _) =
        Lists.reducel
          recompile_one
          ((initProject, Project.empty_map, Project.visited_pervasives),
           Project.currentTargets initProject);
    in
      Incremental.set_project finalProject
    end

  fun show_compile_targets
	(location, output_fn)
	error_info =
    let
      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Incremental.get_project ())

      fun check_one
            ((project, out_of_date, depend_map, compile_map),
             module) =
        let
          fun do_check_one mod_id =
            let
              val (project, depend_map) =
                Project.read_dependencies
                  (error_info, location)
                  (project, mod_id, depend_map)

              val (out_of_date_now, compile_map) =
                Project.check_compiled'
                  (error_info, location)
                  (project, mod_id)
                  (out_of_date, compile_map)
            in
              (project, out_of_date_now, depend_map, compile_map)
            end
        in
          do_check_one (ModuleId.from_host (OS.Path.file module, location))
        end

      val (finalProject, out_of_date, _, _) =
        Lists.reducel
          check_one
          ((initProject, [], Project.empty_map, Project.visited_pervasives),
           Project.currentTargets initProject)

      val _ = Incremental.set_project finalProject
    in
      case out_of_date of
        [] => output_fn "No files need compiling\n"
      | _ => (output_fn "Files to compile:\n";
              app
               (fn s => output_fn (" " ^ ModuleId.string s ^ "\n"))
                out_of_date)
    end

  fun load_targets
	(user_context, location, options, preferences, output_fn)
	error_info =
    let
      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Incremental.get_project ())

      val _ = print "in load_targets\n"

      fun reload_one ((project, depend_map), module) =
        let
          fun do_reload_one mod_id =
            let
              val (project', depend_map) =
                Project.read_dependencies
                  (error_info, location)
                  (project, mod_id, depend_map);

	      (* Probably need a check_load_objects', to preserve
		 existing out_of_date list, if not compile_map. *)
              val out_of_date =
                Project.check_load_objects
                  (error_info, location)
                  (project', mod_id)

              val _ = Incremental.set_project project'
            in
              case Incremental.load_mos
                     error_info
                     (options, UserContext.get_context user_context, project',
		      mod_id, out_of_date, location) of
                NONE =>
                  output_fn "up to date\n"
              | SOME result =>
                  UserContext.process_result
                    {src = UserContext.COPY ("Shell.Build.loadObject \"" ^
                           		     ModuleId.string mod_id ^ "\""),
                     result = result,
                     user_context = user_context,
                     options = options,
                     preferences = preferences,
                     output_fn = output_fn};
              (project', depend_map)
            end
        in
          do_reload_one (ModuleId.from_host (OS.Path.file module, location))
        end

      val _ =
	map
	  (fn s => (print s; print "\n"))
	  (Project.currentTargets initProject)

      val (finalProject, _) =
        Lists.reducel
          reload_one
          ((initProject, Project.empty_map),
           Project.currentTargets initProject);
    in
      Incremental.set_project finalProject
    end

  fun show_load_targets
	(location, output_fn)
	error_info =
    let
      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Incremental.get_project ())

      fun check_one
            ((project, out_of_date, depend_map),
             module) =
        let
          fun do_check_one mod_id =
            let
              val (project', depend_map) =
                Project.read_dependencies
                  (error_info, location)
                  (project, mod_id, depend_map)

	      (* Probably need a check_load_objects', to preserve
		 existing out_of_date list, if not compile_map. *)
              val (out_of_date_now) =
                Project.check_load_objects
                  (error_info, location)
                  (project', mod_id)
            in
              (project, out_of_date_now, depend_map)
            end
        in
          do_check_one (ModuleId.from_host (OS.Path.file module, location))
        end

      val (finalProject, out_of_date, _) =
        Lists.reducel
          check_one
          ((initProject, [], Project.empty_map),
           Project.currentTargets initProject)

      val _ = Incremental.set_project finalProject
    in
      case out_of_date of
        [] => output_fn "No files need load\n"
      | _ => (output_fn "Files to load:\n";
              app
               (fn s => output_fn (" " ^ ModuleId.string s ^ "\n"))
                out_of_date)
    end

@


1.113.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 4
 * Revision 1.113  1997/07/31  12:37:34  johnh
 * [Bug #50019]
 * Modify process_result to take a UserContext.source_reference type for src.
 *
@


1.112
log
@[Bug #30090]
Converted lexer to Basis IO.
Converted MLWorks.IO.set_modified to OS.FileSys.setTime.
@
text
@d6 5
d782 1
a782 1
	     "Shell.Build.loadSource \"" ^ ModuleId.string module_id ^ "\"",
d868 2
a869 2
	      {src = "Shell.Build.loadObject \"" ^ 
                      ModuleId.string module_id ^ "\"",
d924 1
a924 1
            {src = "use \"" ^ filename ^ "\"",
@


1.111
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d6 4
d391 3
d721 2
a722 2
	  MLWorks.IO.set_file_modified (Module.sourceName m, MLWorks.IO.NOW)
	  handle MLWorks.IO.Io _ =>
d741 5
a745 1
      MLWorks.IO.set_file_modified (sml_name,  MLWorks.IO.NOW)
d747 1
a747 4
    handle MLWorks.IO.Io s =>
      Info.default_error'
        (Info.FATAL, Info.Location.FILE toplevel_name, s)
    | Getenv.BadHomeName s =>
d860 1
a860 1
	     MLWorks.IO.output (MLWorks.IO.std_out, "up to date\n")
d882 1
a882 1
        MLWorks.IO.output (MLWorks.IO.std_out, "No units need loading\n")
d884 1
a884 1
        (MLWorks.IO.output (MLWorks.IO.std_out, "Units to load\n");
d932 7
a938 3
  handle MLWorks.IO.Io s =>
    Info.default_error'
    (Info.FATAL, Info.Location.FILE toplevel_name, s)
d971 2
a972 2
        (MLWorks.IO.open_in filename, filename)
        handle MLWorks.IO.Io s =>
d974 1
d983 2
a984 2
                (MLWorks.IO.open_in sml_name, sml_name)
                handle MLWorks.IO.Io s' =>
d1004 1
d1019 2
a1020 2
      handle exn => (MLWorks.IO.close_in stream; raise exn);
      MLWorks.IO.close_in stream
d1549 1
a1549 1
          MLWorks.IO.flush_out MLWorks.IO.std_out;
@


1.110
log
@[Bug #20013]
Put Use: message under control of print_messages
@
text
@d6 4
d425 1
a425 1
   structure Io : IO
@


1.109
log
@Fixing uncaught SysErr in completion
@
text
@d6 3
d952 2
d978 9
a986 4
        let fun spaces y =
          if y <= 0 then "Use: " ^ filename else ("   " ^ spaces (y-1))
        in output_fn (spaces level ^ "\n")
        end
@


1.109.1.1
log
@branched from 1.109
@
text
@a5 3
 * Revision 1.109  1997/04/02  15:15:26  matthew
 * Fixing uncaught SysErr in completion
 *
@


1.109.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.109.1.1  1997/05/12  10:33:47  hope
 * branched from 1.109
 *
@


1.109.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.109.1.1  1997/05/12  10:33:47  hope
 * branched from 1.109
 *
@


1.109.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.109.1.1  1997/05/12  10:33:47  hope
 * branched from 1.109
 *
@


1.109.1.1.1.2
log
@[Bug #50019]
Merging - changing type of src field in UserContext.process_result.
@
text
@a5 4
 *
 * Revision 1.109.1.1.1.1  1997/07/28  18:19:16  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d768 1
a768 1
	     UserContext.COPY ("Shell.Build.loadSource \"" ^ ModuleId.string module_id ^ "\""),
d854 2
a855 2
	      {src = UserContext.COPY ("Shell.Build.loadObject \"" ^ 
                      ModuleId.string module_id ^ "\""),
d910 1
a910 1
            {src = UserContext.COPY ("use \"" ^ String.toString filename ^ "\""),
@


1.109.1.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 4
 * Revision 1.109.1.1.1.2  1997/08/04  15:31:46  johnh
 * [Bug #50019]
 * Merging - changing type of src field in UserContext.process_result.
 *
@


1.108
log
@Fixing merge bungle with last change
@
text
@d6 6
d1377 3
a1381 4
(*
            MLWorks.IO.output (MLWorks.IO.terminal_out,
                               "IsDir : " ^ s ^ (if result then " : true\n" else " : false\n"));
*)
d1384 1
d1390 1
a1390 1
              if s = munged_sofar andalso isDir (OS.FileSys.fullPath s)
d1396 1
@


1.107
log
@Adding use function
@
text
@d930 1
a930 1
        Path.mkCanonical (Path.mkAbsolute (expanded_file, expanded_path))
d932 1
a932 1
      (new_name,Path.dir new_name)
d949 1
a949 1
            if not (isSome ext)) then
a1276 4
<<<<<<< /amd/dedekind/u/ldisk/matthew/ml/MLW/src/interpreter/_shell_utils.sml
      val d = 
        OS.FileSys.openDir(OS.FileSys.fullPath (Getenv.expand_home_dir dir))
=======
a1285 1
>>>>>>> 1.106
a1366 4
<<<<<<< /amd/dedekind/u/ldisk/matthew/ml/MLW/src/interpreter/_shell_utils.sml
           else map (fn n => Path.concatPath (dir,n)) names)
        val isDir = OS.FileSys.isDir
=======
a1378 1
>>>>>>> 1.106
a1382 4
<<<<<<< /amd/dedekind/u/ldisk/matthew/ml/MLW/src/interpreter/_shell_utils.sml
             (if s = munged_sofar andalso isDir (OS.FileSys.fullPath s)
               then [Path.concatPath (s,"")]
=======
a1385 1
>>>>>>> 1.106
@


1.106
log
@[Bug #1849]
Added a check to avoid Syserr exception being raised on Win32.
@
text
@d6 4
d75 3
a77 3
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
d93 2
a94 2
 * Added preferences argument to load_source, load_file and use_file, because
 * UserContext.process_result now requires this.
d279 2
a280 1
 *  Fixed a problem with Error exceptions.  These should all be converted to Incremental.Errors
a291 1
 *   -unit _shell_utils.sml -unit _tty_listener.sml -unit incremental.sml -unit intermake.sml -unit shell_types.sml -unit shell_utils.sml
d351 1
a351 1
 *  edit functions now return a single string in the errorneous case.
d433 2
a434 1
   sharing Basis.BasisTypes.Datatypes.Ident.Symbol = Parser.Lexer.Token.Symbol
d443 2
a444 1
   sharing type Incremental.InterMake.Compiler.ParserBasis = Parser.ParserBasis
d448 2
a449 1
		UserContext.preferences
d467 2
a468 1
   sharing type Incremental.InterMake.Compiler.Info.options = Module.InfoOptions
d492 1
d666 2
d670 2
a671 3
      MLWorks.Internal.Trace.status
	(MLWorks.Internal.Value.cast object) <>
	MLWorks.Internal.Trace.UNTRACEABLE
d674 1
a674 1
      Trace.trace (Trace.get_function_name (MLWorks.Internal.Value.cast f))
d677 1
a677 1
      Trace.untrace (Trace.get_function_name (MLWorks.Internal.Value.cast f))
d750 2
a751 1
	     (UserContext.get_context user_context, module_id, toplevel_name)
d841 3
a843 4
	     ((*MLWorks.IO.output (MLWorks.IO.std_out, "processing result\n");*)
	      UserContext.process_result
	      {src =
		 "Shell.Build.loadObject \"" ^ ModuleId.string module_id ^ "\"",
d856 2
a857 1
        Incremental.check_mo error_info (module_id, Location.FILE toplevel_name)
d868 69
a936 2
      
  fun use_file
d938 1
a938 1
	 error_info, debugger, output_fn, level, queue_function} =
d940 13
a952 43
	  (* Unlike make, compile or recompile, use can read a file without a
	     ".sml" extension, for compatibility with other compilers.
	     Also, the filename argument has already had home directories expanded.
	   *)
	  val (stream, filename) =
	    (MLWorks.IO.open_in filename, filename)
	    handle MLWorks.IO.Io s =>
	      let
		val {base, ext} = OSPath.splitBaseExt filename
	      in
		if (not (isSome ext)) then 
		  let
		    val sml_name =
		      OSPath.joinBaseExt {base = base, ext = SOME "sml"}
		  in
		    (MLWorks.IO.open_in sml_name, sml_name)
		    handle MLWorks.IO.Io s' =>
		      Info.error'
			error_info
			(Info.FATAL, Location.FILE toplevel_name, s)
		  end
		else
		  Info.error'
		    error_info
		    (Info.FATAL, Location.FILE toplevel_name, s)
	      end

	  val _ =
	    let fun spaces y =
	      if y <= 0 then "Use: " ^ filename else ("   " ^ spaces (y-1))
	    in output_fn (spaces level ^ "\n")
	    end

	  val token_stream =
	    Lexer.mkFileTokenStream (stream, filename)

	  fun make_options () =
	    ShellTypes.new_options (user_options, user_context)

	  fun make_incremental_options () =
	    Incremental.OPTIONS
	    {options = make_options (),
	     debugger = debugger}
a953 26
	  fun next () =
	    if Lexer.eof token_stream then ()
	    else
	      let
		val result =
		  Incremental.compile_source
		  error_info
		  (make_incremental_options(),
		   UserContext.get_context user_context,
		   Compiler.TOKENSTREAM1 token_stream)
	      in
		UserContext.process_result
		  {src = "use \"" ^ filename ^ "\"",
		   result = result,
		   user_context = user_context,
		   options = make_options (),
		   preferences = preferences,
		   output_fn = output_fn};
		queue_function (level+1);
		next()
	      end

          fun doit () =
              let val _ =
                     ShellTypes.with_toplevel_name filename
                         (fn _ => next ())
d955 5
a959 1
                  MLWorks.IO.close_in stream
d961 156
a1116 8
              handle
	      exn => (MLWorks.IO.close_in stream; raise exn)
       in
          doit ()
       end
       handle MLWorks.IO.Io s =>
	 Info.default_error'
	   (Info.FATAL, Info.Location.FILE toplevel_name, s)
d1120 1
a1120 1
  fun eval error_info (string, options, context, debugger) = 
d1133 2
a1134 1
          (Info.WARNING, Info.RECOVERABLE, Info.FAULT,Location.FILE "Eval Input")
d1141 2
a1142 1
      val token_stream = Parser.Lexer.mkTokenStream (input_fn,"<Eval input>")
d1157 2
a1158 1
              (Info.FATAL, Location.FILE "Eval Input", "Unexpected end of line")
d1172 1
a1172 1
                               debugger = debugger},
d1209 2
a1210 1
    (string1 = substring (* could raise Substring *)(string2,0,size string1))
d1269 3
a1271 2
  (* We should review this lot if and when FileSys gets implemented properly *)
  (* In particular, ensure that the right exceptions are handled *)
d1277 4
d1290 1
d1314 9
a1322 2
    complete_token (sofar,TOKEN (Token.LONGID ([],Symbol.find_symbol(Token.makestring token))),context)
    | complete_token (sofar,TOKEN (token as Token.LONGID (path,id)), context) =
d1335 3
a1337 3
		    (rev (Lists.reducel
			    (fn (acc,s) => "." :: Symbol.symbol_name s :: acc)
			    ([],path)))
d1372 4
d1388 1
d1393 4
d1400 1
d1449 2
a1450 1
                  fun input_fn _ = (let val result = !x in x := ""; result end)
d1453 3
a1455 1
                    case Lexer.getToken error_info (options,Lexer.Token.PLAIN_STATE,ts) of
d1475 2
a1476 1
      (sofar,filter_completions (complete_token (sofar,to_complete,context)))
d1493 2
a1494 1
        val result = substring (* could raise Substring *) (target,0,aux(l,size target))
d1502 2
a1503 1
        val tycontext = Basis.basis_to_context (Incremental.type_basis context)
d1510 2
a1511 1
        val mlval = Inter_EnvTypes.lookup_val(valid,Incremental.inter_env context)
d1526 1
a1526 1
             options, context, fn f => fn a => f a)
@


1.105
log
@[Bug #1986]
Changed from using Path to OSPath.
@
text
@d6 4
d1098 9
a1106 1
      val d = OS.FileSys.openDir (OS.FileSys.fullPath (Getenv.expand_home_dir dir))
d1179 1
a1179 1
        val completions =
d1182 1
@


1.104
log
@Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
-- Changed name and type of Module.find_sml and Module.sml_name.
@
text
@d6 4
d369 1
a369 1
require "../basis/path";
d406 1
a406 1
   structure Path : PATH
d699 1
a699 1
      val {name, ext} = Path.splitExt expanded
d702 2
a703 2
        if ext = Path.NOEXT then
	  Path.addExt {name = name, ext = Path.EXT "sml"}
d866 1
a866 1
		val {name, ext} = Path.splitExt filename
d868 1
a868 1
		if ext = Path.NOEXT then
d871 1
a871 1
		      Path.addExt {name = name, ext = Path.EXT "sml"}
d1085 1
a1085 1
    (Path.dir s, Path.last s)
d1169 1
a1169 1
           else map (fn n => Path.concatPath (dir,n)) names)
d1186 1
a1186 1
               then [Path.concatPath (s,"")]
@


1.103
log
@[Bug #1728]
__integer becomes __int
@
text
@d2 2
a3 1
 *  Copyright (C) 1993 Harlequin Ltd
d6 4
d674 3
a676 1
      case Module.find_sml error_options module_id of
d683 1
a683 1
	  MLWorks.IO.set_file_modified (Module.sml_name m, MLWorks.IO.NOW)
d688 1
a688 1
               concat ["can't touch `", Module.sml_name m, "' "])
@


1.103.4.1
log
@branched from 1.103
@
text
@a4 4
 * Revision 1.103  1996/11/06  11:38:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.103.3.1
log
@branched from 1.103
@
text
@a4 4
 * Revision 1.103  1996/11/06  11:38:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.103.3.1.1.1
log
@branched from 1.103.3.1
@
text
@a4 3
 * Revision 1.103.3.1  1996/12/17  17:47:20  hope
 * branched from 1.103
 *
@


1.103.2.1
log
@branched from 1.103
@
text
@a4 4
 * Revision 1.103  1996/11/06  11:38:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.103.1.1
log
@branched from 1.103
@
text
@a4 4
 * Revision 1.103  1996/11/06  11:38:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.103.1.1.1.1
log
@branched from 1.103.1.1
@
text
@a4 3
 * Revision 1.103.1.1  1996/11/14  12:48:52  hope
 * branched from 1.103
 *
@


1.102
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d5 4
d355 1
a355 1
require "^.basis.__integer";
@


1.101
log
@moving String from toplevel
@
text
@d5 3
d352 1
d484 2
a485 2
	    if MLWorks.Internal.Value.unsafe_string_sub (locdata, i) = ord #":" then
	      substring (locdata, 0, i)
d487 1
a487 1
	      scan (i+1)
@


1.100
log
@[Bug #1519]
Type of UserContext.ITEM has changed.
@
text
@d5 4
d348 1
d475 1
a475 1
    fun find_source_file locdata =
d477 9
a485 3
        fun aux1(":"::l,acc) = String.implode(rev acc)
          | aux1(c::l,acc) = aux1(l,c::acc)
          | aux1([],acc) = String.implode(rev acc)
d487 1
a487 1
        aux1(String.explode locdata,[])
d489 1
a489 1

d495 1
a495 1
      (String.ordof(s,0) = String.ord "<"
d497 1
a497 1
       String.ordof(s,(size s)-1) = String.ord ">")
d607 1
a607 1
            fun aux2(("]"::_),acc) = acc
d610 1
a610 1
            fun aux1("["::l) = aux2 (l,[])
d613 1
a613 1
            val locchars = aux1 (String.explode code_name)
d615 1
a615 1
            String.implode(rev locchars)
d666 1
a666 1
             String.implode ["can't find module `", mod_name, "' on source path"])
d673 1
a673 1
               String.implode ["can't touch `", Module.sml_name m, "' "])
d741 1
a741 1
              Lists.iterate
d791 1
a791 1
              Lists.iterate
d830 1
a830 1
         Lists.iterate
d1009 1
a1009 1
    (string1 = String.substring(string2,0,size string1))
d1083 1
a1083 1
               String.substring (next,0,size s) = s
d1112 1
a1112 1
		  String.implode
d1139 2
a1140 2
        fun munge1 ([],acc) = String.implode (rev acc)
          | munge1 ("\\"::"\\"::rest,acc) = munge1 (rest,"\\"::acc)
d1142 2
a1143 2
        fun munge2 ([],acc) = String.implode (rev acc)
          | munge2 ("\\"::rest,acc) = munge2 (rest,"\\"::"\\" :: acc)
d1145 2
a1146 2
        val munged_sofar = munge1 (String.explode sofar,[])
        val (dir,fname) = split_filename (munge1 (String.explode s,[]))
d1162 1
a1162 1
        map (fn s => munge2 (String.explode s,[]))
d1183 1
a1183 1
      remove_duplicates (Lists.qsort (String.>) l, [])
d1186 1
a1186 1
  fun find_string s =
d1188 1
a1188 1
      val chars = String.explode s
d1191 2
a1192 1
          if a = "\"" then find_string (b,[])
d1195 1
a1195 1
        STRING (String.implode (rev acc))
d1197 4
a1200 3
          if a = "\""
            then strip b
          else find_string (b,a::acc)
a1246 1
        fun min (m,n) = if m < n then m else n
d1250 1
a1250 1
          else if String.ordof(s,m) = String.ordof(target,m)
d1255 2
a1256 2
            aux (l,check(a,0,(min (size a,n))))
        val result = String.substring (target,0,aux(l,size target))
@


1.100.3.1
log
@branched from 1.100
@
text
@a4 4
 * Revision 1.100  1996/08/15  14:52:37  daveb
 * [Bug #1519]
 * Type of UserContext.ITEM has changed.
 *
@


1.100.2.1
log
@branched from 1.100
@
text
@a4 4
 * Revision 1.100  1996/08/15  14:52:37  daveb
 * [Bug #1519]
 * Type of UserContext.ITEM has changed.
 *
@


1.100.1.1
log
@branched from 1.100
@
text
@a4 4
 * Revision 1.100  1996/08/15  14:52:37  daveb
 * [Bug #1519]
 * Type of UserContext.ITEM has changed.
 *
@


1.99
log
@Replace the call to OldOS.mtime with one to OS.FileSys.access
since OldOs is deprecated and the mtime call is only being used
to determine if the file actually exists.
@
text
@d5 5
a450 1
  structure Option = MLWorks.Option
d460 1
d527 2
a528 2
          Option.NONE => ()
        | Option.SOME s => raise EditFailed s
d540 2
a541 2
          Option.NONE => quitfun
        | Option.SOME s => raise EditFailed s
d553 2
a554 2
          Option.NONE => quitfun
        | Option.SOME s => raise EditFailed s
d651 1
a651 1
	Option.NONE =>
d656 1
a656 1
      | Option.SOME (_, m, _) =>
d707 2
a708 2
      of Option.NONE => ()
      |  Option.SOME result =>
d711 1
a711 1
	     "<Shell.Compile.load_source " ^ ModuleId.string module_id ^ ">",
d793 1
a793 1
	   Option.NONE =>
d795 1
a795 1
	 | Option.SOME result =>
d798 2
a799 1
	      {src = "<Shell.Compile.load " ^ ModuleId.string module_id ^ ">",
d884 1
a884 1
		  {src = "<use " ^ filename ^ ">",
d993 1
a993 1
    NONE
d1178 1
a1178 1
      fun strip [] = NONE
d1210 1
a1210 1
                  get_token NONE
d1222 1
a1222 1
          NONE => ""
d1266 2
a1267 1
  fun value_from_item (UserContext.ITEM (_, id, context, _, src), options) =
d1278 3
a1280 1
          Option.SOME (src, value)
d1282 1
a1282 1
        handle _ => Option.NONE)
d1284 1
a1284 1
         Option.NONE
d1288 3
a1290 3
    of Option.NONE => Option.NONE
    |  Option.SOME item =>
      value_from_item
@


1.98
log
@Remove debug info saying processing result
@
text
@d5 3
a343 1
require "../make/old_os"; 
a380 1
   structure OldOs : OLD_OS
d508 4
a511 3
      case OldOs.mtime s of
        OldOs.EXISTS _ => ()
      | _ => raise EditFailed ("File " ^ s ^ " does not exist")
@


1.97
log
@Bug 1424: Made object_traceable check the trace status of the object.
@
text
@d5 3
d785 12
a796 12
	    module_id, Location.FILE toplevel_name)
    of Option.NONE =>
      MLWorks.IO.output (MLWorks.IO.std_out, "up to date\n")
    |  Option.SOME result =>
      (MLWorks.IO.output (MLWorks.IO.std_out, "processing result\n");
       UserContext.process_result
	 {src = "<Shell.Compile.load " ^ ModuleId.string module_id ^ ">",
	  result = result,
	  user_context = user_context,
	  options = options,
	  preferences = preferences,
	  output_fn = output_fn})
@


1.96
log
@Corrected definition of is_closure.
@
text
@d5 3
d615 5
a619 1
    val object_traceable = is_closure
@


1.95
log
@The Io exception is no longer at top level.
@
text
@d5 3
d552 1
a552 1
    fun is_code_vector object =
d556 2
a557 5
        header = Tags.POINTER
        andalso
        (#1 (MLWorks.Internal.Value.header object) = Tags.CODE
         orelse
         #1 (MLWorks.Internal.Value.header object) = Tags.BACKPTR)
d560 1
a560 1
    fun is_closure object =
d564 8
a571 9
        if header = Tags.POINTER
          then 
            let
              val (secondary, length) = MLWorks.Internal.Value.header object
            in
              secondary = Tags.RECORD andalso
              length > 0 andalso
              is_code_vector (MLWorks.Internal.Value.sub (object,1))
            end
d574 1
a574 1
          is_code_vector (MLWorks.Internal.Value.sub (object,0))
d577 2
d602 1
a602 1
        if is_closure object
d612 1
a612 1
    val object_editable = is_closure
d614 2
a615 1
    fun trace f = Trace.trace (Trace.get_function_name (MLWorks.Internal.Value.cast f))
d617 2
a618 1
    fun untrace f = Trace.untrace (Trace.get_function_name (MLWorks.Internal.Value.cast f))
a619 1
    val object_traceable = is_closure
@


1.94
log
@Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
now does what the former used to do.
@
text
@d5 4
d639 1
a639 1
	  handle Io _ =>
d660 1
a660 1
    handle Io s =>
d814 1
a814 1
	    handle Io s =>
d824 1
a824 1
		    handle Io s' =>
d886 1
a886 1
       handle Io s =>
@


1.93
log
@Change to pull in Path directly rather than OS.Path since the latter
now conforms to the latest basis and it is too much effort to update
the code to OS.Path at this point.
@
text
@d5 5
d1040 1
a1040 1
      val d = OS.FileSys.openDir (OS.FileSys.realPath (Getenv.expand_home_dir dir))
d1131 1
a1131 1
              if s = munged_sofar andalso isDir (OS.FileSys.realPath s)
@


1.92
log
@Moved preferences_file_name to new save_image module.
@
text
@d5 3
d321 1
d359 1
d641 1
a641 1
      val {name, ext} = OS.Path.splitExt expanded
d644 2
a645 2
        if ext = OS.Path.NOEXT then
	  OS.Path.addExt {name = name, ext = OS.Path.EXT "sml"}
d807 1
a807 1
		val {name, ext} = OS.Path.splitExt filename
d809 1
a809 1
		if ext = OS.Path.NOEXT then
d812 1
a812 1
		      OS.Path.addExt {name = name, ext = OS.Path.EXT "sml"}
d1026 1
a1026 1
    (OS.Path.dir s, OS.Path.last s)
d1110 1
a1110 1
           else map (fn n => OS.Path.concatPath (dir,n)) names)
d1127 1
a1127 1
               then [OS.Path.concatPath (s,"")]
@


1.91
log
@Fixing problem with filename completion on Windows
@
text
@d5 3
a1254 7

  fun preference_file_name () =
    case Getenv.get_home_dir () of
      Option.NONE => Option.NONE
    | Option.SOME dir => 
        Option.SOME (dir ^ "/.mlworks_preferences")

@


1.90
log
@Added Info.options argument to use_file.
@
text
@d5 3
d1097 1
d1103 10
d1117 2
a1118 1
             if s = sofar andalso OS.FileSys.isDir (OS.FileSys.realPath s)
d1121 1
a1121 1
             else completions
@


1.89
log
@Removed the ShellUtils.Error exception.
@
text
@d5 3
d785 3
a787 4
	(filename, user_context, toplevel_name, user_options, preferences,
	 debugger, output_fn, level, queue_function) =
      let val error_info = Info.make_default_options ()
 
@


1.88
log
@Removed the Incremental.Error exception.
@
text
@d5 3
a430 2
  exception Error of Info.error * Info.error list

a866 2
       | Info.Stop (error,error_list) =>
	 raise Error(error, error_list)
a925 2
    handle Info.Stop (error,error_list) =>
      raise Error (error,error_list)
@


1.87
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d5 6
d422 5
a426 1
  fun debug_out s = if do_debug then MLWorks.IO.output (MLWorks.IO.terminal_out,"ShellUtils: " ^ s ^ "\n") else ()
d428 1
a428 4
  exception Error = Incremental.Error
  (* _actionqueue.sml (etc.) handles ShellUtils.Error, so if you change this
     definition you will have to add explicit handlers in this file to catch
     Incremental.Error and raise the new Error exception instead. *)
a866 15
	 (*
	 let
	 (* We could let the function that called use_file handle the Info.Stop
	    exception, but for the sake of a uniform interface, we handle it
	    here.  This context will eventually be updated with the modules
	    argument of the exception.  In fact we want it to be unchanged, so
	    we extract the modules here, which makes the later "update" have no
	    effect.  Perhaps slightly clumsy, but better than treating "use" as
	    a special case throughout the code. *)
	   val (Incremental.CONTEXT {modules, ...}, _, _, _) =
	     UserContext.get_context_info user_context
	 in
	   raise Error(modules, error, error_list)
	 end
	 *)
@


1.86
log
@show_source no longer returns a destroy function.
@
text
@d5 3
d416 1
a416 1
  fun debug_out s = if do_debug then output (MLWorks.IO.terminal_out,"ShellUtils: " ^ s ^ "\n") else ()
d426 1
a426 1
        fun aux1(":"::l,acc) = implode(rev acc)
d428 1
a428 1
          | aux1([],acc) = implode(rev acc)
d430 1
a430 1
        aux1(explode locdata,[])
d438 1
a438 1
      (String.ordof(s,0) = ord "<"
d440 1
a440 1
       String.ordof(s,(size s)-1) = ord ">")
d557 1
a557 1
            val locchars = aux1 (explode code_name)
d559 1
a559 1
            implode(rev locchars)
d605 1
a605 1
             implode ["can't find module `", mod_name, "' on source path"])
d612 1
a612 1
               implode ["can't touch `", Module.sml_name m, "' "])
d744 1
a744 1
      output (std_out, "up to date\n")
d746 1
a746 1
      (output (std_out, "processing result\n");
d765 1
a765 1
        output (std_out, "No units need loading\n")
d767 1
a767 1
        (output (std_out, "Units to load\n");
d783 1
a783 1
	    (open_in filename, filename)
d793 1
a793 1
		    (open_in sml_name, sml_name)
d849 1
a849 1
                  close_in stream
d852 1
a852 1
	      exn => (close_in stream; raise exn)
d1070 1
a1070 1
		  implode
d1097 1
a1097 1
        fun munge1 ([],acc) = implode (rev acc)
d1100 1
a1100 1
        fun munge2 ([],acc) = implode (rev acc)
d1103 1
a1103 1
        val (dir,fname) = split_filename (munge1 (explode s,[]))
d1109 1
a1109 1
        map (fn s => munge2 (explode s,[]))
d1134 1
a1134 1
      val chars = explode s
d1140 1
a1140 1
        STRING (implode (rev acc))
d1233 1
a1233 1
          MLWorks.IO.flush_out std_out;
@


1.85
log
@initbasis moved to basis
@
text
@d5 3
d473 1
a473 1
        val (edit_result,quitfun) =
d477 1
a477 1
          Option.NONE => quitfun
@


1.84
log
@Rename Os -> OS to conform with latest basis revision.
@
text
@d5 3
d293 1
a293 1
require "../initbasis/os";
@


1.83
log
@Added exception wrapper to close input stream in use_file().
@
text
@d5 3
d327 1
a327 1
   structure Os : OS
d610 1
a610 1
      val {name, ext} = Os.Path.splitExt expanded
d613 2
a614 2
        if ext = Os.Path.NOEXT then
	  Os.Path.addExt {name = name, ext = Os.Path.EXT "sml"}
d777 1
a777 1
		val {name, ext} = Os.Path.splitExt filename
d779 1
a779 1
		if ext = Os.Path.NOEXT then
d782 1
a782 1
		      Os.Path.addExt {name = name, ext = Os.Path.EXT "sml"}
d1015 1
a1015 1
    (Os.Path.dir s, Os.Path.last s)
d1024 1
a1024 1
      val d = Os.FileSys.openDir (Os.FileSys.realPath (Getenv.expand_home_dir dir))
d1027 1
a1027 1
          val next = Os.FileSys.readDir d
d1039 1
a1039 1
      Os.FileSys.closeDir d; (* Should be an exn handler for this too *)
d1044 1
d1098 1
a1098 1
           else map (fn n => Os.Path.concatPath (dir,n)) names)
d1103 3
a1105 2
             if s = sofar andalso Os.FileSys.isDir (Os.FileSys.realPath s)
               then [Os.Path.concatPath (s,"")]
@


1.82
log
@Added preferences argument to load_source, load_file and use_file, because
UserContext.process_result now requires this.
@
text
@d5 4
d764 9
a772 14
    let
      val error_info = Info.make_default_options ()

      (* Unlike make, compile or recompile, use can read a file without a
	 ".sml" extension, for compatibility with other compilers.
	 Also, the filename argument has already had home directories expanded.
       *)
      val (stream, filename) =
        (open_in filename, filename)
        handle Io s =>
	  let
	    val {name, ext} = Os.Path.splitExt filename
	  in
	    if ext = Os.Path.NOEXT then
d774 1
a774 2
		val sml_name =
		  Os.Path.addExt {name = name, ext = Os.Path.EXT "sml"}
d776 13
a788 3
                (open_in sml_name, sml_name)
                handle Io s' =>
                  Info.error'
d792 20
d813 51
a863 68
              Info.error'
		error_info
		(Info.FATAL, Location.FILE toplevel_name, s)
	  end
          
      val _ =
        let fun spaces y =
          if y <= 0 then "Use: " ^ filename else ("   " ^ spaces (y-1))
        in output_fn (spaces level ^ "\n")
        end
      
      val token_stream =
        Lexer.mkFileTokenStream (stream, filename)
        
      fun make_options () =
	ShellTypes.new_options (user_options, user_context)

      fun make_incremental_options () =
        Incremental.OPTIONS
        {options = make_options (),
         debugger = debugger}
        
      fun next () =
        if Lexer.eof token_stream then
          close_in stream
        else
          let
            val result =
              Incremental.compile_source
              error_info
              (make_incremental_options(),
               UserContext.get_context user_context,
               Compiler.TOKENSTREAM1 token_stream)
          in
            UserContext.process_result
	      {src = "<use " ^ filename ^ ">",
	       result = result,
	       user_context = user_context,
	       options = make_options (),
	       preferences = preferences,
	       output_fn = output_fn};
            queue_function (level+1);
            next()
          end
    in
      ShellTypes.with_toplevel_name filename
        (fn _ => next ())
    end
    handle Io s =>
      Info.default_error'
        (Info.FATAL, Info.Location.FILE toplevel_name, s)
    | Info.Stop (error,error_list) =>
      (*
      let
      (* We could let the function that called use_file handle the Info.Stop
	 exception, but for the sake of a uniform interface, we handle it
	 here.  This context will eventually be updated with the modules
	 argument of the exception.  In fact we want it to be unchanged, so
	 we extract the modules here, which makes the later "update" have no
	 effect.  Perhaps slightly clumsy, but better than treating "use" as
	 a special case throughout the code. *)
        val (Incremental.CONTEXT {modules, ...}, _, _, _) =
	  UserContext.get_context_info user_context
      in
        raise Error(modules, error, error_list)
      end
      *)
      raise Error(error, error_list)
@


1.81
log
@Changed Project.load_dependencies to Project.read_dependencies.
@
text
@d5 3
d352 2
a353 1
   sharing type Editor.preferences = Preferences.preferences
d630 1
a630 1
	(user_context, toplevel_name, options, user_options,
d644 7
a650 2
	  ("<Shell.Compile.load_source " ^ ModuleId.string module_id ^ ">",
	   result, user_context, options, output_fn)
d720 1
a720 1
	(user_context, toplevel_name, options, output_fn)
d732 6
a737 2
	 ("<Shell.Compile.load " ^ ModuleId.string module_id ^ ">",
	  result, user_context, options, output_fn))
d757 3
a759 2
  fun use_file (filename,user_context,toplevel_name,user_options,debugger,
		output_fn,level,queue_function) =
d820 6
a825 2
	      ("<use " ^ filename ^ ">", result,
	       user_context, make_options (), output_fn);
@


1.80
log
@Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
the deprecated OS interface.
@
text
@d5 4
d666 1
a666 1
        Project.load_dependencies
d690 1
a690 1
        Project.load_dependencies
@


1.79
log
@Added delete_from_project.
Modified types of some other functions to suit Incremental.match_*_path.
@
text
@d5 4
d276 1
a276 2
require "../initbasis/filesys";
require "../initbasis/path";
d278 1
a278 1
require "../make/os"; 
d313 1
a313 1
   structure Path : PATH
d315 1
a315 2
   structure Os : OS
   structure FileSys : FILE_SYS
d443 2
a444 2
      case Os.mtime s of
        Os.EXISTS _ => ()
d595 1
a595 1
      val {name, ext} = Path.splitExt expanded
d598 2
a599 2
        if ext = Path.NOEXT then
	  Path.addExt {name = name, ext = Path.EXT "sml"}
d753 1
a753 1
	    val {name, ext} = Path.splitExt filename
d755 1
a755 1
	    if ext = Path.NOEXT then
d758 1
a758 1
		  Path.addExt {name = name, ext = Path.EXT "sml"}
d979 1
a979 1
    (Path.dir s,Path.last s)
d988 1
a988 1
      val d = FileSys.openDir (FileSys.realPath (Getenv.expand_home_dir dir))
d991 1
a991 1
          val next = FileSys.readDir d
d1003 1
a1003 1
      FileSys.closeDir d; (* Should be an exn handler for this too *)
d1061 1
a1061 1
           else map (fn n => Path.concatPath (dir,n)) names)
d1066 2
a1067 2
             if s = sofar andalso FileSys.isDir (FileSys.realPath s)
               then [Path.concatPath (s,"")]
@


1.78
log
@Added check_load_file.
@
text
@d5 3
d611 8
d622 1
d628 1
d640 1
d643 2
a644 1
      val filelist = Incremental.check_module (module_id, toplevel_name)
d654 4
a657 1
  fun compile_file (toplevel_name, options, output_fn) module_id =
d661 1
a661 1
          (Info.make_default_options (), Location.FILE toplevel_name)
d666 1
a666 1
          (Info.make_default_options (), Location.FILE toplevel_name)
d671 1
a671 1
	  (Info.make_default_options ())
d678 4
a681 1
  fun check_compile_file (toplevel_name, options, output_fn) module_id =
d685 1
a685 1
          (Info.make_default_options (), Location.FILE toplevel_name)
d690 1
a690 1
          (Info.make_default_options (), Location.FILE toplevel_name)
d706 1
d709 1
d722 1
d726 1
a726 1
        Incremental.check_mo (module_id, Location.FILE toplevel_name)
@


1.77
log
@Incremental.load_mo and Incremental.add_module now return option types.
@
text
@d5 3
d629 1
a629 4
      val filelist =
        Incremental.check_module
          (make_incremental_options (options,debugger))
          (module_id, toplevel_name)
d684 1
a684 1
	(user_context, toplevel_name, options, user_options, output_fn)
d696 17
@


1.76
log
@Module.find_sml now takes an Info.options parameter.
@
text
@d5 3
a610 5

      val result =
        Incremental.add_module
	  inc_options
	  (UserContext.get_context user_context, module_id, toplevel_name)
d612 8
a619 3
      UserContext.process_result
	("<Shell.Compile.load_source " ^ ModuleId.string module_id ^ ">",
	 result, user_context, options, output_fn)
d686 10
a695 11
    let
      val result =
        Incremental.load_mo
	  (options, UserContext.get_context user_context,
	   module_id, Location.FILE toplevel_name)
    in
      output (std_out, "processing result\n");
      UserContext.process_result
	("<Shell.Compile.load " ^ ModuleId.string module_id ^ ">",
	 result, user_context, options, output_fn)
    end
@


1.75
log
@Fixed use of Info.default_options.
@
text
@d5 3
d352 1
d562 2
d565 1
a565 1
      case Module.find_sml module_id of
d568 3
a570 3
          (Info.make_default_options ())
          (Info.FATAL, Info.Location.FILE toplevel_name,
           implode ["can't find module `", mod_name, "' on source path"])
d575 3
a577 3
            (Info.make_default_options ())
            (Info.FATAL, Info.Location.FILE toplevel_name,
             implode ["can't touch `", Module.sml_name m, "' "])
@


1.74
log
@Removed compile_string and default_dynamic.
@
text
@d5 3
d589 1
a589 2
      Info.error'
        Info.default_options
d592 1
a592 2
      Info.error'
        Info.default_options
d634 1
a634 1
          (Info.default_options, Location.FILE toplevel_name)
d639 1
a639 1
          (Info.default_options, Location.FILE toplevel_name)
d643 3
a645 1
        TopLevel.compile_file' Info.default_options (options, proj, m, false)
d655 1
a655 1
          (Info.default_options, Location.FILE toplevel_name)
d660 1
a660 1
          (Info.default_options, Location.FILE toplevel_name)
d761 1
a761 2
      Info.error'
        Info.default_options
@


1.73
log
@compile_file was passed the wrong project.
@
text
@d5 3
a778 19
  fun compile_string error_info (src,location_title,get_user_context,user_options,debugger) =
    let
      val input_function =
        let val buff = ref src
        in
          fn _ => (let val out = !buff in buff := ""; out end)
        end
      val token_stream =
        Lexer.mkTokenStream (input_function, location_title)
    in
      Incremental.compile_source
      error_info
      (Incremental.OPTIONS
       {options = ShellTypes.new_options (user_options, get_user_context ()),
        debugger = debugger},
       UserContext.get_context (get_user_context ()),
       Compiler.TOKENSTREAM token_stream)
    end

a838 2

  val default_dynamic = (MLWorks.Internal.Value.cast (),Types.empty_rectype)
@


1.72
log
@Renamed Project.check_objects to Project.check_compiled.
@
text
@d5 3
d642 1
a642 1
        (Lists.reducel compile_one (Incremental.get_project (), out_of_date))
@


1.71
log
@Adding preference_file_name function
@
text
@d5 3
d631 1
a631 1
        Project.check_objects
d650 1
a650 1
        Project.check_objects
@


1.70
log
@Removed commented-out save function.
Interface of UserContext has changed.
@
text
@d5 4
d1158 8
a1165 1
end
@


1.69
log
@Using Info.null_options in call to eval
@
text
@d5 3
d320 1
a320 1
		ShellTypes.user_options = UserContext.user_tool_options
a328 1
   sharing type UserContext.map = Basis.BasisTypes.Datatypes.NewMap.T
d364 1
a364 1
  (* _actionqueue.sml (etc.) handle ShellUtils.Error, so if you change this
d596 1
a596 1
	 result, user_context, options, user_options, output_fn)
a657 12
  (*
  fun save_file (filename, context, toplevel_name, options) =
    let
      val Options.OPTIONS{print_options,...} = options
      val Incremental.CONTEXT {topdec, compiler_basis, inter_env, signatures} =
	context
      val error_info = Info.make_default_options ()
    in
      InterMake.save error_info (filename, Location.FILE toplevel_name)
    end

  *)
d670 1
a670 1
	 result, user_context, options, user_options, output_fn)
d736 1
a736 1
	       user_context, make_options (), user_options, output_fn);
d1149 2
a1150 2
    case UserContext.get_selected (user_context, user_options) of 
      Option.NONE => Option.NONE
d1152 2
a1153 2
         value_from_item (item,
                          ShellTypes.new_options (user_options, user_context))
@


1.68
log
@Removed history functions (replaced by more complete functionality in
gui_utils).
@
text
@d5 4
d1146 1
a1146 1
	    eval Info.default_options
@


1.67
log
@Adding catch all handler around call to eval.
@
text
@d5 3
a1135 68

  (* Utilities for controlling histories *)

  (* One day we will have an option for this *)
  fun get_max_history_width user_options = 30

  fun contains_nasty_chars s =
    let
      fun aux n =
        if n = 0 then false
          else
            let val chr = String.ordof(s,n-1)
            in
              if chr = ord "\n" orelse chr = ord "\t"
                then true
              else aux (n-1)
            end
    in
      aux (size s)
    end

  fun remove_nasty_chars s =
    let fun subst "\n" = " "
          | subst "\t" = " "
          | subst c = c
    in
      implode (map subst (explode s))
    end
		  

  fun trim_history_string (s,user_options) =
    let
      val max_width = get_max_history_width user_options
      val trim_string =
        if size s > max_width
          then String.substring(s,0,max_width - 2) ^ ".."
        else s
    in
      if contains_nasty_chars trim_string
        then remove_nasty_chars trim_string
      else trim_string
    end
  
  (* There is no need to go throught an options structure for this. *)
  fun get_max_history_length user_preferences =
    let
      val Preferences.USER_PREFERENCES ({history_length,...}, _) =
	user_preferences
    in
      !history_length
    end
      
  fun ministry_of_truth (items,new_factoid,eq,user_options) =
    let
      fun aux ([],_) = []
        | aux (s::l,ix) =
          if ix > 1
            then
              if eq (s,new_factoid) then l
              else
                s :: (aux (l,ix - 1))
          else []
    in
      aux (items,get_max_history_length user_options)
    end

  fun add_history_item (item,history,eq,user_options) =
    history := item :: ministry_of_truth (!history,item,eq,user_options)
@


1.66
log
@Adding value_from_user_context function
@
text
@d5 3
d340 1
d416 2
a417 2
          MLWorks.Option.NONE => quitfun
        | MLWorks.Option.SOME s => raise EditFailed s
d429 2
a430 2
          MLWorks.Option.NONE => quitfun
        | MLWorks.Option.SOME s => raise EditFailed s
d442 2
a443 2
          MLWorks.Option.NONE => quitfun
        | MLWorks.Option.SOME s => raise EditFailed s
d535 1
a535 1
	MLWorks.Option.NONE =>
d540 1
a540 1
      | MLWorks.Option.SOME (_, m, _) =>
d964 3
a966 1
    handle Getenv.BadHomeName _ => []
d1205 1
a1205 1
	let
d1213 1
a1213 1
          MLWorks.Option.SOME (src, value)
d1215 1
d1217 1
a1217 1
         MLWorks.Option.NONE
d1221 2
a1222 2
      MLWorks.Option.NONE => MLWorks.Option.NONE
    |  MLWorks.Option.SOME item =>
@


1.65
log
@Fixing bungle with last change.
@
text
@d5 3
d1196 22
@


1.64
log
@Some stuff in completion to deal with stupid NT backslashes in filenames
@
text
@d5 3
d1006 1
a1006 1
        val (dir,fname) = split_filename (munge2 (explode s,[]))
@


1.63
log
@Improved wording of check_load_source message.
@
text
@d5 3
d989 2
d994 10
a1003 1
        val (dir,fname) = split_filename s
d1005 11
a1015 9
        val completions = 
          map (fn n => Path.concatPath (dir,n)) names
      in
        case completions of 
          [s] => 
            if s = sofar andalso FileSys.isDir (FileSys.realPath s)
              then [Path.concatPath (s,"")]
            else completions
        | _ => completions
@


1.62
log
@Corrected "make" to "load source" in message.
@
text
@d5 3
d587 2
a588 2
        [] => output_fn "No files need compiling\n"
      | _ => (output_fn "Files to compile:\n";
d629 2
a630 2
        [] => output_fn "No files need compiling\n"
      | _ => (output_fn "Files to compile:\n";
@


1.61
log
@Removed Module.Cache type.
@
text
@d5 3
d570 1
a570 1
	("<Shell.Make.make_module " ^ ModuleId.string module_id ^ ">",
d656 1
a656 1
	("<Shell.Make.load_module " ^ ModuleId.string module_id ^ ">",
@


1.60
log
@Incremental and InterMake have been changed to use Project.
@
text
@d5 3
d515 1
a515 1
      case #1 (Module.find_sml (module_id, Module.empty_cache)) of
@


1.59
log
@Thinking about filename completion
@
text
@d5 3
d226 2
d247 2
d264 1
a264 1
     	   ShellTypes.Options
d266 2
a267 1
   sharing Incremental.InterMake.Compiler.Info = Parser.Lexer.Info
d273 3
a275 1
   sharing Incremental.InterMake.Inter_EnvTypes.EnvironTypes.LambdaTypes.Ident = Basis.BasisTypes.Datatypes.Ident
d277 2
a278 1
   sharing type Incremental.InterMake.Compiler.TypeBasis = Basis.BasisTypes.Basis
d296 2
a297 1
   sharing type ModuleId.ModuleId = Incremental.ModuleId = Module.ModuleId
d299 4
a302 1
   sharing type UserContext.identifier = Basis.BasisTypes.Datatypes.Ident.Identifier
a326 1
  type modules = InterMake.modules
d507 1
a507 1
  fun touch_compile_module (mod_name, toplevel_name) =
d527 1
a527 1
  fun touch_compile_file (filename, toplevel_name) =
d551 2
a552 2
  fun make_file
	(user_context, toplevel_name, monitor_fn, options, user_options,
a560 1
	  monitor_fn
d568 2
a569 2
  fun check_make_file
	(context,toplevel_name,monitor_fn,options,debugger,output_fn)
d575 1
a575 2
          monitor_fn
          (context, module_id, toplevel_name)
d585 44
a628 1
  fun save_file (filename, context, toplevel_name, monitor_fn, options, debugger, output_fn) =
d631 2
a632 1
      val Incremental.CONTEXT {topdec, compiler_basis, inter_env, signatures, modules} = context
d635 1
a635 1
      InterMake.save error_info (modules, filename,Location.FILE toplevel_name)
d638 1
d648 1
d730 1
d744 2
d825 1
a825 1
      raise Error (InterMake.empty_modules,error,error_list)
d950 1
d957 5
a961 1
                val pathname = implode (rev (Lists.reducel (fn (acc,s) => "." :: Symbol.symbol_name s :: acc) ([],path)))
d966 1
@


1.58
log
@Added show_source.
@
text
@d5 3
d247 1
d315 3
d853 33
a885 3
  fun complete_token (TOKEN (token as Token.RESERVED _),context) =
    complete_token (TOKEN (Token.LONGID ([],Symbol.find_symbol(Token.makestring token))),context)
    | complete_token (TOKEN (token as Token.LONGID (path,id)), context) =
d889 35
a923 11
      in
        case path of
          [] => get_basis_names (type_basis,string)
        | _ =>
            (let
               val env = get_env (path,type_basis)
               val pathname = implode (rev (Lists.reducel (fn (acc,s) => "." :: Symbol.symbol_name s :: acc) ([],path)))
             in
               map (fn s => pathname ^ s) (get_env_names (env,string))
             end
               handle NoEnv => [])
d939 17
d958 31
a988 22
      val error_info = Info.make_default_options ()
      fun doit error_info () =
        let
          val x = ref s
          fun input_fn _ = (let val result = !x in x := ""; result end)
          val ts = Lexer.mkTokenStream (input_fn,"")
          fun get_token tok =
            case Lexer.getToken error_info (options,Lexer.Token.PLAIN_STATE,ts) of
              Token.EOF (state) =>
                (case state of
                   Token.IN_STRING (char_list) => STRING (MLWorks.String.implode_char char_list)
                 | _ => tok)
            | new_tok => get_token (TOKEN new_tok)
          val to_complete = get_token NONE
          val sofar =
            case to_complete of
              NONE => ""
            | TOKEN tok => Token.makestring tok
            | STRING string => string
        in
          (sofar,filter_completions (complete_token (to_complete,context)))
        end
d990 1
a990 5
      Info.with_report_fun
      error_info
      (fn _ => ())
      doit
      ()
@


1.57
log
@Changing interface to tracing
@
text
@d5 3
d364 15
a378 1
    fun edit_source (location, preferences) =
d404 1
a404 1
    fun edit_string (s, preferences) =
d408 1
a408 1
        edit_source (location, preferences)
d468 1
a468 1
              edit_string (locstring, preferences)
@


1.56
log
@Adding check on file existing before invoking editor
@
text
@d5 3
d458 1
a458 1
    val trace = Trace.trace
d460 1
a460 1
    fun untrace (x,_,_,f) = Trace.untrace(x,f)
@


1.55
log
@Changing parser error reporting.
@
text
@d5 3
d204 1
d237 1
d352 6
d361 1
d374 1
a374 1

@


1.54
log
@Adding compile functions for use by evaluator.
@
text
@d5 3
d708 2
a709 3
          | Parser.SyntaxError(token,location) =>
              Info.error' error_info
              (Info.FATAL, location, "Unexpected " ^ token))
@


1.53
log
@Removed redundant Context parameter from edit functions.
@
text
@d5 3
d205 1
a205 1
require "../typechecker/basistypes";
d223 1
a223 1
   structure BasisTypes : BASISTYPES
d242 1
a242 1
   sharing Completion.Datatypes = BasisTypes.Datatypes =
d246 2
a247 2
   sharing BasisTypes.Datatypes.Ident.Symbol = Parser.Lexer.Token.Symbol

d249 1
a249 1
   sharing type Incremental.InterMake.Compiler.TypeBasis = BasisTypes.Basis
d268 2
a269 3
   sharing type UserContext.map = BasisTypes.Datatypes.NewMap.T
   sharing type UserContext.identifier =
		Incremental.InterMake.Compiler.identifier
d274 1
d281 1
d287 1
d643 20
a662 1
                
d895 17
@


1.52
log
@UserContext.process_result now takes a user_options argument.
@
text
@d5 3
d339 1
a339 1
    fun edit_source (location, context, preferences) =
d364 1
a364 1
    fun edit_string (s, context, preferences) =
d368 1
a368 1
        edit_source (location, context, preferences)
d400 1
a400 1
    fun edit_object (object, context, preferences) =
d428 1
a428 1
              edit_string (locstring, context, preferences)
@


1.51
log
@Split user_options into tool-specific and context-specific parts.
@
text
@d5 3
d254 1
a254 1
		ShellTypes.user_options
d488 2
a489 1
	(user_context,toplevel_name,monitor_fn,options,debugger,output_fn)
d502 1
a502 1
	 result, user_context, options, output_fn)
d532 3
a534 1
  fun load_file (user_context,toplevel_name,options,output_fn) module_id =
d543 1
a543 1
	 result, user_context, options, output_fn)
d609 1
a609 1
	       user_context, make_options (), output_fn);
@


1.50
log
@Changing exception raised by EditObject
@
text
@d5 3
d203 1
d223 1
d246 5
a250 2
   sharing type Editor.preferences = UserOptions.preferences
   sharing type Trace.UserOptions = UserOptions.user_options =
d277 2
a278 1
  type UserOptions = UserOptions.user_options
d284 1
a284 1
  type preferences = UserOptions.preferences
d581 3
d586 1
a586 1
        {options = UserOptions.new_options user_options,
a588 2
      fun make_options () = UserOptions.new_options user_options

d906 1
a906 1
  fun get_max_history_length user_options =
d908 2
a909 1
      val UserOptions.USER_OPTIONS({history_length,...},_) = user_options
@


1.49
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d5 3
a384 1
    exception EditObject
d415 1
a415 1
        else raise EditObject
@


1.48
log
@New module naming stuff
@
text
@d5 3
d187 1
a203 1
   structure ShellTypes : SHELL_TYPES
d217 2
d221 2
a222 1
     Completion.Options = ValuePrinter.Options = ShellTypes.Options
d231 1
a231 1
   sharing type Incremental.Result = ShellTypes.Result
d236 2
a237 1
   sharing type Parser.Lexer.Options = Incremental.InterMake.Compiler.Options.options
d239 4
a242 3
   sharing type Trace.UserOptions = UserOptions.user_options
   sharing type ShellTypes.IncrementalOptions = Incremental.options
   sharing type Incremental.Context = Trace.Context = ShellTypes.Context
d248 2
a249 2
   sharing type ShellTypes.map = BasisTypes.Datatypes.NewMap.T
   sharing type ShellTypes.identifier =
d270 1
a270 1
  type user_context = ShellTypes.user_context
d483 1
a483 1
	  (ShellTypes.get_context user_context, module_id, toplevel_name)
d485 1
a485 1
      ShellTypes.process_result
d521 1
a521 1
	  (options, ShellTypes.get_context user_context,
d524 1
a524 1
      ShellTypes.process_result
d586 1
a586 1
               ShellTypes.get_context user_context,
d589 1
a589 1
            ShellTypes.process_result
d613 1
a613 1
	  ShellTypes.get_context_info user_context
@


1.47
log
@Added Shell.Make prefix to source strings for load and make.
@
text
@d5 3
d422 3
a424 2
    let val module_id =
	  ModuleId.from_string (mod_name, Info.Location.FILE toplevel_name)
d426 3
a428 3
      case #1 (Module.find_sml (module_id, Module.empty_cache))
      of MLWorks.Option.NONE =>
        Info.error'
d432 4
a435 4
      |  MLWorks.Option.SOME (m, _) =>
        MLWorks.IO.set_file_modified (Module.sml_name m, MLWorks.IO.NOW)
	handle Io _ =>
          Info.error'
@


1.46
log
@Expansion of home dirs moved from FileSys to Getenv.
filesys and path moved from utils to initbasis.
Better error handling.
@
text
@d5 5
d474 1
a474 1
	("<make " ^ ModuleId.string module_id ^ ">",
d513 1
a513 1
	("<load " ^ ModuleId.string module_id ^ ">",
@


1.45
log
@Change FILESYS to FILE_SYS
@
text
@d5 3
d169 3
a171 2
require "../utils/filesys";
require "../utils/path";
a200 1
   structure FileSys : FILE_SYS
d202 1
d319 1
a319 1
        val full_name = FileSys.expand_path filename
d328 1
a328 2
    handle 
    FileSys.BadHomeName s => raise EditFailed ("Invalid home name: " ^ s)
d413 3
a415 2
  fun touch_compile_module mod_name =
    let val module_id = ModuleId.from_string (mod_name, Info.Location.UNKNOWN)
d421 1
a421 1
          (Info.FATAL, Info.Location.UNKNOWN,
d428 1
a428 1
            (Info.FATAL, Info.Location.UNKNOWN,
d432 1
a432 1
  fun touch_compile_file filename =
d434 1
a434 1
      val expanded = FileSys.expand_path filename
d449 2
a450 2
        (Info.FATAL, Info.Location.UNKNOWN, s)
    | FileSys.BadHomeName s =>
d453 2
a454 1
        (Info.FATAL, Info.Location.UNKNOWN, "Invalid home name: " ^ s)
a514 4
      (* USE is more generous than make, compile or recompile.
       It can read a file without a ".sml" extension!
       For compatibility with other compilers.
       *)
d517 4
a520 2
      val expanded = FileSys.expand_path filename

d522 1
a522 1
        (open_in expanded, expanded)
d525 1
a525 1
	    val {name, ext} = Path.splitExt expanded
d536 1
a536 1
		    (Info.FATAL, Location.FILE toplevel_name, s')
d582 5
a586 2
    handle
      Info.Stop (error,error_list) =>
@


1.44
log
@Lexer uses ints as character representation
@
text
@d5 3
d197 1
a197 1
   structure FileSys : FILESYS
@


1.43
log
@Replaced evaluation sequences with calls to ShellTypes.process_result.
Also minor changes as a result of new Path signature.
@
text
@d5 4
d785 1
a785 1
                   Token.IN_STRING (string_list) => STRING (implode string_list)
@


1.42
log
@Changes to lexer structure
@
text
@d5 3
a164 1
require "interprint";
a180 1
   structure InterPrint : INTERPRINT
d197 1
a197 1
     Completion.Options = ValuePrinter.Options
a199 2
   sharing InterPrint.Compiler = Incremental.InterMake.Compiler
   sharing InterPrint.Compiler.Absyn = Parser.Absyn
d203 2
d206 5
a213 4
   sharing type InterPrint.Compiler.DebugInformation =
     		ValuePrinter.DebugInformation
   sharing type BasisTypes.Basis = InterPrint.Compiler.TypeBasis
   sharing type Parser.ParserBasis = InterPrint.Compiler.ParserBasis
d215 1
a215 2
   sharing type InterPrint.Context = Incremental.Context = Trace.Context =
		ShellTypes.Context
d425 1
a425 1
      val {dir, name, ext} = Path.splitPath expanded
d429 1
a429 1
	  Path.makePath {dir = dir, name = name, ext = Path.EXT "sml"}
a447 3
      val (c, delta, hist, smap) =
	ShellTypes.get_context_info user_context
	
d450 1
a450 1
      val (result, identifiers) =
d454 1
a454 10
	  (c, module_id, toplevel_name)

      val new_delta = Incremental.add_definitions(options, delta, result)

      val new_context = Incremental.add_definitions (options, c, result)

      val result_strings =
        InterPrint.strings
	  (new_context, Incremental.pb_from_result result,
	   options, 0, identifiers);
d456 3
a458 4
      Lists.iterate (fn (_, s) => output (std_out, s)) result_strings;
      ShellTypes.set_context_info
	(user_context,
	 (new_context, new_delta, hist, smap))
d490 4
a493 15
      val (c, delta, hist, smap) =
	ShellTypes.get_context_info user_context

      val (result, identifiers) =
        Incremental.load_mo (options, c, module_id, Location.FILE toplevel_name)

      val new_context = Incremental.add_definitions (options, c, result)

      val new_delta =
	Incremental.add_definitions (options, delta, result)

      val result_strings =
        InterPrint.strings
          (new_context, Incremental.pb_from_result result,
	   options, 0, identifiers)
d495 3
a497 4
      Lists.iterate (fn (_, s) => output (std_out, s)) result_strings;
      ShellTypes.set_context_info
	(user_context,
	 (new_context, new_delta, hist, smap))
d515 1
a515 1
	    val {dir, name, ext} = Path.splitPath expanded
d520 1
a520 1
		  Path.makePath {dir = dir, name = name, ext = Path.EXT "sml"}
d555 1
a555 4
            val (context, delta, hist, ShellTypes.MAP smap) =
	      ShellTypes.get_context_info user_context

            val (result, identifiers) =
d559 1
a559 1
               context,
a560 25

	    val options = make_options()

            val new_context =
              Incremental.add_definitions
                (options, context, result)
	   
	    val new_delta =
	      Incremental.add_definitions (options, delta, result)

            val result_strings =
	      InterPrint.strings
                (new_context, Incremental.pb_from_result result,
		 options, 0, identifiers)

	  val src = "use " ^ filename

          val new_hist =
            map (fn (i, s) => ShellTypes.ITEM (i, s, src)) result_strings

          val new_smap =
            Lists.reducel
              (fn (map, (id, _)) => NewMap.define (map, id, src))
              (smap, result_strings)

d562 3
a564 4
            Lists.iterate (fn (_, s) => output_fn s) result_strings;
	    ShellTypes.set_context_info
	      (user_context,
	       (new_context, new_delta, new_hist, ShellTypes.MAP new_smap));
@


1.41
log
@Made use_file update the context history.
@
text
@d5 3
d195 3
a197 3
   sharing Incremental.InterMake.Compiler.Options =
	   Parser.Options = Completion.Options = ValuePrinter.Options =
     	   UserOptions.Options
d205 1
@


1.40
log
@Replaced Option structure with references to MLWorks.Option.
Replaced FileName parameter with FileSys and Path.
@
text
@d5 4
d216 3
d575 1
a575 1
            val (context, delta, hist, smap) =
d598 11
d610 1
a610 1
            Lists.iterate (fn (_, s) => output (std_out, s)) result_strings;
d613 1
a613 1
	       (new_context, new_delta, hist, smap));
@


1.39
log
@Made use_file return the current modules table when an error occurs.
Renamed source_result to result, added some comments.
@
text
@d5 4
d149 2
a150 1
require "../utils/filename";
d182 2
a183 1
   structure Filename : FILENAME
a196 1
   sharing Filename.Option = Incremental.InterMake.Option
a210 1
   sharing type Module.Directory = Io.Directory
a215 1
  structure Option = InterMake.Option
d289 2
a290 2
          Editor.Option.ABSENT => quitfun
        | Editor.Option.PRESENT s => raise EditFailed s
d296 2
a297 1
        val full_name = Filename.absolute_name (Filename.parse_absolute filename)
d302 2
a303 2
          Editor.Option.ABSENT => quitfun
        | Editor.Option.PRESENT s => raise EditFailed s
d306 1
a306 2
    Filename.Parse s => raise EditFailed ("Invalid Pathname: " ^ s)
  | Filename.BadHomeName s => raise EditFailed ("Invalid home name: " ^ s)
d395 1
a395 1
      of Module.Option.ABSENT =>
d400 1
a400 1
      |  Module.Option.PRESENT (m, _) =>
d410 2
a411 8
    let
      val absolute =
        Filename.parse_absolute filename
        handle (Filename.Parse _) =>
          Info.error'
          (Info.make_default_options ())
          (Info.FATAL, Info.Location.UNKNOWN,
           "Invalid Filename : " ^ filename)
d413 1
a413 5
      val sml_abs =
        case absolute
        of Filename.ABSOLUTE (d, m, Filename.Option.ABSENT) =>
          Filename.ABSOLUTE (d, m, Filename.Option.PRESENT "sml")
        |  _ => absolute
d415 5
a419 1
      val sml_name = Filename.absolute_name sml_abs
d421 1
a421 8
      MLWorks.IO.set_file_modified (filename,  MLWorks.IO.NOW)
      handle Io _ =>
        MLWorks.IO.set_file_modified (sml_name,  MLWorks.IO.NOW)
        handle Io _ =>
          Info.error'
            Info.default_options
            (Info.FATAL, Info.Location.UNKNOWN,
             "can't touch `" ^ filename ^ "'")
d423 8
d522 1
a522 20
      val source as Filename.ABSOLUTE(loc, name, extension) =
        Filename.parse_absolute filename
	handle (exn as Filename.Parse _) => 
	  Info.error'
	    error_info
	    (Info.FATAL, Info.Location.FILE toplevel_name,
	     "Invalid Filename : " ^ filename)

      val filename_sml =
        let
          val sml_source = 
            case extension of
              Filename.Option.PRESENT _ => source
            | _ => Filename.ABSOLUTE (loc,name,Filename.Option.PRESENT "sml")
        in
          Filename.absolute_name sml_source
        end
      
      val filename = Filename.absolute_name source
	(* ~ expansion has been done on source *)
d525 21
a545 7
        (open_in filename, filename)
        handle Io _ =>
          ((open_in filename_sml, filename_sml)
           handle Io s =>
             Info.error' error_info (Info.FATAL,
                                     Location.FILE toplevel_name, 
                                     s))
d603 3
a605 2
  handle Info.Stop (error,error_list) =>
    let
d613 6
a618 7
      val (Incremental.CONTEXT {modules, ...}, _, _, _) =
	ShellTypes.get_context_info user_context
    in
      raise Error(modules, error, error_list)
    end
              

@


1.38
log
@Added editable function.
@
text
@d5 3
a207 1
   sharing type InterPrint.SourceResult = Incremental.SourceResult
d233 3
d443 1
a443 1
      val (source_result, identifiers) =
d449 1
a449 1
      val new_delta = Incremental.add_definitions(options, delta, source_result)
d451 1
a451 1
      val new_context = Incremental.add_definitions (options, c, source_result)
d454 3
a456 1
        InterPrint.strings (new_context, source_result, options, 0, identifiers);
a462 4
    (*
    handle Info.Stop (error,error_list) =>
      raise Error(context,error,error_list)
    *)
a480 4
    (*
    handle Info.Stop (error,error_list) =>
      raise Error(context,error,error_list)
    *)
d496 1
a496 1
      val (source_result, identifiers) =
d499 1
a499 1
      val new_context = Incremental.add_definitions (options, c, source_result)
d502 1
a502 1
	Incremental.add_definitions (options, delta, source_result)
d506 2
a507 1
          (new_context, source_result, options, 0, identifiers)
d578 1
a578 1
            val (source_result, identifiers) =
d589 1
a589 1
                (options, context, source_result)
d592 1
a592 2
	      Incremental.add_definitions
                (options, delta, source_result)
d596 2
a597 1
                (new_context, source_result, options, 0, identifiers)
d611 13
a623 1
    raise Error(InterMake.empty_modules, error, error_list)
@


1.37
log
@Moved preferences out of Options structure.
@
text
@d5 3
d245 1
a245 1
    fun uneditable s =
d251 1
a251 1
    fun file_from_location (location,Incremental.CONTEXT {modules,...})  =
d253 2
a254 1
        fun get_filename Location.UNKNOWN = raise FileFromLocation "Unknown location"
d259 1
a260 13
	(*
        val pathname =
          Filename.parse_absolute filename
          handle Filename.Parse _ =>
            (let
              val pname = Filename.parse_relative filename
              val Filename.RELATIVE(_,module_name,_) = pname
              val result = InterMake.lookup_module (modules,module_name)
              val InterMake.RESULT{source,...} = result
            in
              source
            end)
	*)
d262 1
a262 4
	(*
        pathname
	*)
        if uneditable filename
a265 2
      handle (* Filename.Parse _ => raise FileFromLocation "Invalid pathname"
           | *) InterMake.Lookup _ => raise FileFromLocation "Can't find file"
d267 5
d276 1
a276 1
	val full_name = file_from_location (location,context)
@


1.36
log
@Changed uses of InterPrint.definitions to InterPrint.strings.
@
text
@d5 3
d176 1
a176 1
   sharing Incremental.InterMake.Compiler.Options = Editor.Options =
d187 1
d208 1
a208 1
  structure Options = Editor.Options
d225 1
d282 1
a282 1
    fun edit_source (location,context,options) =
d285 2
a286 1
        val (edit_result,quitfun) = Editor.edit_from_location options (full_name,location)
d294 1
a294 1
    fun edit_file (filename,options) =
d298 1
a298 1
          Editor.edit options (full_name, 0)
d308 1
a308 1
    fun edit_string (s,context,options) =
d312 1
a312 1
        edit_source (location,context,options)
d345 1
a345 1
    fun edit_object (object,context,options) =
d373 1
a373 1
              edit_string (locstring,context,options)
@


1.35
log
@Moved set_no_execute to _incremental, so that add_module and
check_module in _incremental don't have to check that the option
is set correctly.
@
text
@d5 5
d499 11
a509 3
      val (new_context,identifiers,
	   Incremental.InterMake.Compiler.BASIS{parser_basis, ...}) =
        Incremental.load_mo (options, c,module_id,Location.FILE toplevel_name)
d511 1
a511 6
      InterPrint.definitions
      output_fn
      (new_context,
       options,
       0,
       identifiers, parser_basis);
d514 1
a514 1
	 (new_context, delta, hist, smap))
d596 4
d601 1
a601 5
            InterPrint.definitions
            output_fn
            (new_context,
             options,
             0, identifiers, Incremental.pb_from_result source_result);
@


1.34
log
@make_file now updates the delta context correctly.
@
text
@d5 3
a457 47
  (* This is horrible *)
  fun set_no_execute (Options.OPTIONS{listing_options,
                                      compiler_options,
                                      print_options,
                                      compat_options,
                                      extension_options,
                                      editor_options,
                                      environment_options
                                      }) =
    let val Options.COMPILEROPTIONS {debug,
                                     debug_variables,
                                     debug_polyvariables,
                                     generate_stepper,
                                     generate_moduler,
                                     generate_stepper_specific,
                                     no_execute,
                                     intercept,
                                     interrupt,
                                     opt_leaf_fns,
                                     opt_tail_calls,
                                     opt_self_calls} = compiler_options
      val new_compiler_options = 
        Options.COMPILEROPTIONS
        {debug = debug,
         debug_variables = debug_variables,
         debug_polyvariables = debug_polyvariables,
         generate_stepper = generate_stepper,
         generate_moduler = generate_moduler,
         generate_stepper_specific = generate_stepper_specific,
         no_execute = true,  (* Aha!! *)
         intercept = intercept,
         interrupt = interrupt,
         opt_leaf_fns = opt_leaf_fns,
         opt_tail_calls = opt_tail_calls,
         opt_self_calls = opt_self_calls} 
    in
      Options.OPTIONS
      {listing_options = listing_options,
       compiler_options = new_compiler_options,
       print_options = print_options,
       compat_options = compat_options,
       extension_options = extension_options,
       editor_options = editor_options,
       environment_options = environment_options
       }
    end

d464 1
a464 1
          (make_incremental_options(set_no_execute options,debugger))
@


1.33
log
@Brought use_file up to date with the new context arrangements.
@
text
@d5 3
d190 1
d430 3
a432 2
      val (new_context, identifiers,_,
	   Incremental.InterMake.Compiler.BASIS{parser_basis, ...}) =
d434 10
a443 3
          (make_incremental_options(options,debugger))
          monitor_fn
          (c, module_id, toplevel_name)
d445 1
a445 5
      InterPrint.definitions
        output_fn
        (new_context,
         options,
         0, identifiers, parser_basis);
d448 1
a448 1
	 (new_context, delta, hist, smap))
d506 2
a507 2
      val (_,_,filelist, _) =
        Incremental.add_module
@


1.32
log
@Update debugger information production
@
text
@d5 3
a599 3
      val (c, delta, hist, smap) =
	ShellTypes.get_context_info user_context

d605 3
d612 1
a612 1
               c,
d614 1
d616 1
d619 5
a623 1
              (options, c, source_result)
d632 1
a632 1
	       (new_context, delta, hist, smap));
d638 1
a638 1
      (fn _ => next ())
@


1.31
log
@Replaced Context Refs by user_contexts.  Replaced the Context argument
of the Error exception with a list of new modules, for updating the
user_context appropriately.
@
text
@d5 5
d529 1
a529 1
        Incremental.load_mo (c,module_id,Location.FILE toplevel_name)
d611 1
d614 1
a614 1
              (c, source_result)
d619 1
a619 1
             make_options(),
@


1.30
log
@New runtime directory structure.
@
text
@d5 3
d171 2
a172 1
   sharing type InterPrint.Context = Incremental.Context = Trace.Context
d199 2
d412 1
a412 1
	(context_ref,toplevel_name,monitor_fn,options,debugger,output_fn)
d415 3
d423 1
a423 1
          (!context_ref, module_id, toplevel_name)
d430 3
a432 1
      context_ref := new_context
d434 1
d436 2
a437 1
      raise Error(!context_ref,error,error_list)
d487 1
a487 1
	(context_ref,toplevel_name,monitor_fn,options,debugger,output_fn)
d494 1
a494 1
          (!context_ref, module_id, toplevel_name)
d503 1
d505 2
a506 1
      raise Error(!context_ref,error,error_list)
d508 1
a508 1
  fun save_file (filename,ref context, toplevel_name, monitor_fn, options, debugger, output_fn) =
d517 1
a517 1
  fun load_file (context_ref,toplevel_name,options,output_fn) module_id =
d519 3
d524 1
a524 1
        Incremental.load_mo (!context_ref,module_id,Location.FILE toplevel_name)
d532 3
a534 1
      context_ref := new_context
d537 2
a538 1
  fun use_file (filename,context_ref,toplevel_name,user_options,debugger,output_fn,level,queue_function) =
d592 3
d604 1
a604 1
               !context_ref,
d608 1
a608 1
              (!context_ref, source_result)
d615 3
a617 1
            context_ref := new_context;
d626 1
a626 1
    raise Error(!context_ref,error,error_list)
d631 1
a631 1
  fun eval error_info (string, options,context,debugger) = 
d689 1
a689 1
      raise Error (context,error,error_list)
@


1.29
log
@Add incremental parser basis to stuff passed to interprint
@
text
@d5 3
d113 1
a113 1
require "../rts/tags";
@


1.28
log
@Added touch_compile_module and touch_compile_file.
@
text
@d5 3
d406 2
a407 1
      val (new_context, identifiers,_) =
d417 1
a417 1
         0, identifiers);
d474 1
a474 1
      val (_,_,filelist) =
d501 2
a502 1
      val (new_context,identifiers) =
d510 1
a510 1
       identifiers);
d587 1
a587 1
             0, identifiers);
@


1.27
log
@Revised functions to work with ActionQueue.with_source_path.
@
text
@d5 3
d110 1
d142 1
d166 1
a166 1
   sharing type Editor.Location.T = Module.Location
d168 1
d352 46
@


1.26
log
@Added check_make_file and edit_file
@
text
@d5 3
a160 1
   sharing type Incremental.Module = Module.Module
d182 1
d347 3
a349 1
  fun make_file (filename,context_ref,toplevel_name,monitor_fn,options,debugger,output_fn) =
d351 5
a355 9
      val old_source_path = Io.get_source_path ()

      val (on_path, module) =
	Module.find_file (filename, Info.Location.UNKNOWN)
        handle
	  Module.NoSuchFile s =>
	    Info.error'
            (Info.make_default_options ())
            (Info.FATAL, Info.Location.UNKNOWN, "No such file: `" ^ s ^ "'")
d357 1
a357 13
      if not on_path then
	Io.set_source_path (Module.module_dir module :: old_source_path)
      else
	();
      let
	val (new_context, identifiers,_) =
          Incremental.add_module
            (make_incremental_options(options,debugger))
            monitor_fn
            (!context_ref, module, toplevel_name)
      in
        Io.set_source_path old_source_path;
        InterPrint.definitions
d362 1
a362 5
        context_ref := new_context
      end
      handle x =>
        (Io.set_source_path old_source_path;
         raise x)
d364 2
a365 2
  handle Info.Stop (error,error_list) =>
    raise Error(!context_ref,error,error_list)
d414 3
a416 1
  fun check_make_file (filename,context_ref,toplevel_name,monitor_fn,options,debugger,output_fn) =
d418 5
a422 9
      val old_source_path = Io.get_source_path ()

      val (on_path, module) =
	Module.find_file (filename, Info.Location.UNKNOWN)
        handle
	  Module.NoSuchFile s =>
	    Info.error'
            (Info.make_default_options ())
            (Info.FATAL, Info.Location.UNKNOWN, "No such file: `" ^ s ^ "'")
d424 5
a428 17
      if not on_path then
	Io.set_source_path (Module.module_dir module :: old_source_path)
      else
	();
      let
	val (_,_,filelist) =
          Incremental.add_module
            (make_incremental_options(set_no_execute options,debugger))
            monitor_fn
            (!context_ref, module, toplevel_name)
      in
        Io.set_source_path old_source_path;
        case filelist of
          [] => output_fn "No files need compiling\n"
        | _ => (output_fn "Files to compile:\n";
                Lists.iterate
                (fn s => output_fn (" " ^ s ^ "\n"))
a429 4
      end
      handle x =>
        (Io.set_source_path old_source_path;
         raise x)
d431 2
a432 3
  handle Info.Stop (error,error_list) =>
    raise Error(!context_ref,error,error_list)

a433 1
    
d443 1
a443 1
  fun load_file (filename,context_ref,toplevel_name,options,output_fn) =
d446 1
a446 1
        Incremental.load_mo (!context_ref,filename,Location.FILE toplevel_name)
@


1.25
log
@Added untrace function
Fixed a problem with Error exceptions.  These should all be converted to Incremental.Errors
@
text
@d5 4
d247 14
d361 1
a361 1
	val (new_context, identifiers) =
d382 87
@


1.24
log
@Boolean indicator for Monomorphic debugger decapsulation.
@
text
@d5 3
d317 2
d335 2
a336 2
	      Info.default_options
	      (Info.FATAL, Info.Location.UNKNOWN, "No such File `" ^ s ^ "'")
d361 2
a362 1

d423 1
a423 1
                                     "Use : " ^ s))
a451 3
              handle Info.Stop (error,error_list) =>
                raise Error(!context_ref,error,error_list)
              
d469 3
d760 1
a760 1
          if ix > 0
@


1.23
log
@ Module.module_and_path is now Module.find_file and is functional.
@
text
@d5 3
d535 1
a535 1
      ValuePrinter.stringify_value
d577 1
@


1.22
log
@make and ad_module now take Modules instead of file names.
@
text
@d5 3
d150 1
d320 9
a328 2
      val (module, old_source_path) =
	Module.module_and_path (filename, Info.Location.UNKNOWN)
d330 4
a352 5
    handle
      Module.NoSuchFile s =>
	Info.error'
	  Info.default_options
	  (Info.FATAL, Info.Location.UNKNOWN, "No such File: " ^ s)
@


1.21
log
@ -unit _shell_utils.sml -unit _tty_listener.sml -unit incremental.sml -unit intermake.sml -unit shell_types.sml -unit shell_utils.sml
@
text
@d5 3
d89 2
d120 2
d133 1
d145 2
d151 1
a151 2
  structure Filename = Incremental.InterMake.FileName
  structure Option = Filename.Option
d217 2
a218 2
      handle Filename.Parse _ => raise FileFromLocation "Invalid pathname"
           | InterMake.Lookup _ => raise FileFromLocation "Can't find file"
a308 21
  fun parse_home_name filename =
    Io.trans_home_name filename handle Io.BadHomeName s => s

  fun parse_filename filename = 
    Filename.parse_absolute filename
    handle Filename.Parse _ => 
      (Filename.parse_absolute(MLWorks.OS.Unix.getwd() ^ "/" ^ filename))

  fun parse_absolute (filename, error_info, location) =
    let
      val filename = parse_home_name filename
    in
      Filename.parse_absolute filename
      handle Filename.Parse _ => 
	(Filename.parse_absolute(MLWorks.OS.Unix.getwd() ^ "/" ^ filename)
	 handle (exn as Filename.Parse _) => 
	   Info.error' error_info (Info.FATAL,
				   location,
				   "Invalid Filename : " ^ filename))
    end

d316 2
a317 5
      val (new_context, identifiers) =
        Incremental.add_module
          (make_incremental_options(options,debugger))
          monitor_fn
          (!context_ref, filename, toplevel_name)
d319 18
a336 6
      InterPrint.definitions
      output_fn
      (new_context,
       options,
       0, identifiers);
      context_ref :=  new_context
d338 6
d376 7
a382 2
      val source as Filename.ABSOLUTE(loc,name,extension) =
	parse_absolute (filename, error_info, Location.FILE toplevel_name)
@


1.20
log
@Added space to error messge
@
text
@d5 3
d308 1
a308 1
  fun parse_absolute (filename, error_info) =
d317 1
a317 1
				   Info.Location.UNKNOWN, 
d326 1
a326 1
  fun make_file (filename,context_ref,monitor_fn,options,debugger,output_fn) =
d332 1
a332 1
          (!context_ref, filename)
d342 1
a342 1
  fun save_file (filename,ref context, monitor_fn, options, debugger, output_fn) =
d348 1
a348 1
      InterMake.save error_info (modules, filename)
d351 1
a351 1
  fun load_file (filename,context_ref,options,output_fn) =
d354 1
a354 1
        Incremental.load_mo (!context_ref,filename)
d365 1
a365 1
  fun use_file (filename,context_ref,user_options,debugger,output_fn,level,queue_function) =
d374 1
a374 1
	parse_absolute (filename, error_info)
d395 1
a395 1
                                     Info.Location.UNKNOWN, 
d442 2
a443 1
      next()
@


1.19
log
@Added load_file function for loading an mo
@
text
@d5 3
d202 1
a202 1
          then raise FileFromLocation (filename^"not a real file")
@


1.18
log
@Added level field to Basis.
@
text
@d5 3
d345 14
@


1.17
log
@Merged in bug fix.
@
text
@d5 3
d499 1
a499 1
          val BasisTypes.BASIS(_,_,_,env) = type_basis
d541 2
a542 1
  fun get_basis_names (BasisTypes.BASIS(nameset,
d553 1
a553 1
  fun get_env (path,BasisTypes.BASIS(_,_,_,env)) =
@


1.16
log
@Merging in bug fixes
@
text
@d5 3
d14 3
d360 3
d364 1
a364 1
        (open_in filename_sml, filename_sml)
d366 1
a366 1
          ((open_in filename, filename)
@


1.15
log
@Added save_file function
@
text
@d5 3
d11 8
d154 7
d186 3
a188 1
	filename
a196 4
	(*
        val pathname = file_from_location (location,context)
        val full_name = Filename.absolute_name pathname
	*)
d213 29
a256 29
        fun is_code_vector object =
          let
            val header = MLWorks.Internal.Value.primary object
          in
            header = Tags.POINTER
            andalso
            (#1 (MLWorks.Internal.Value.header object) = Tags.CODE
             orelse
             #1 (MLWorks.Internal.Value.header object) = Tags.BACKPTR)
          end
          
        fun is_closure object =
          let
            val header = MLWorks.Internal.Value.primary object
          in
            if header = Tags.POINTER
              then 
                let
                  val (secondary, length) = MLWorks.Internal.Value.header object
                in
                  secondary = Tags.RECORD andalso
                  length > 0 andalso
                  is_code_vector (MLWorks.Internal.Value.sub (object,1))
                end
            else
              header = Tags.PAIRPTR andalso
              is_code_vector (MLWorks.Internal.Value.sub (object,0))
          end

d276 2
d280 2
d432 1
a432 1
      val token_stream = Parser.Lexer.mkTokenStream (input_fn,"Eval input")
d620 89
a708 1
  end
@


1.14
log
@Pass options to InterPrint.definitions instead of print_options.
@
text
@d5 3
d296 15
a310 6
         InterPrint.definitions
         output_fn
         (new_context,
          options,
          0, identifiers);
         context_ref :=  new_context
@


1.13
log
@Removed "compiling" from message, because I think it's confusing.
@
text
@d5 3
a286 1
      val Options.OPTIONS{print_options,...} = options
d296 1
a296 1
          print_options,
d345 1
a345 5
      fun make_print_options () =
        let val Options.OPTIONS{print_options,...} = UserOptions.new_options user_options
        in
          print_options
        end
d368 1
a368 1
             make_print_options(),
@


1.13.1.1
log
@Fork for bug fixing
@
text
@a4 3
 *  Revision 1.13  1993/08/29  13:31:19  daveb
 *  Removed "compiling" from message, because I think it's confusing.
 *
@


1.13.1.2
log
@Check for editability of defininitions
Predicates for editability and traceability
Utilities for history menus
@
text
@a4 3
 *  Revision 1.13.1.1  1993/08/29  13:31:19  jont
 *  Fork for bug fixing
 *
a139 7
    (* uneditable filenames are of the form "<...>" *)
    fun uneditable s =
      size s = 0 orelse
      (String.ordof(s,0) = ord "<"
       andalso 
       String.ordof(s,(size s)-1) = ord ">")

d165 1
a165 3
        if uneditable filename
          then raise FileFromLocation (filename^"not a real file")
        else filename
d174 4
a193 29
    fun is_code_vector object =
      let
        val header = MLWorks.Internal.Value.primary object
      in
        header = Tags.POINTER
        andalso
        (#1 (MLWorks.Internal.Value.header object) = Tags.CODE
         orelse
         #1 (MLWorks.Internal.Value.header object) = Tags.BACKPTR)
      end
          
    fun is_closure object =
      let
        val header = MLWorks.Internal.Value.primary object
      in
        if header = Tags.POINTER
          then 
            let
              val (secondary, length) = MLWorks.Internal.Value.header object
            in
              secondary = Tags.RECORD andalso
              length > 0 andalso
              is_code_vector (MLWorks.Internal.Value.sub (object,1))
            end
        else
          header = Tags.PAIRPTR andalso
          is_code_vector (MLWorks.Internal.Value.sub (object,0))
      end

d209 29
a256 2
    val object_editable = is_closure

a258 2
    val object_traceable = is_closure

d405 1
a405 1
      val token_stream = Parser.Lexer.mkTokenStream (input_fn,"<Eval input>")
d593 1
a593 89

  (* find a common completion *)

  fun find_common_completion [] = ""
    | find_common_completion (target::l) =
      let
        fun min (m,n) = if m < n then m else n
        fun check (s,m,n) =
          if m = n 
            then n
          else if String.ordof(s,m) = String.ordof(target,m)
                 then check (s,m+1,n)
               else m
        fun aux ([],n) = n
          | aux ((a::l),n) =
            aux (l,check(a,0,(min (size a,n))))
        val result = String.substring (target,0,aux(l,size target))
      in
        result
      end

  (* Utilities for controlling histories *)

  (* One day we will have an option for this *)
  fun get_max_history_width user_options = 30

  fun contains_nasty_chars s =
    let
      fun aux n =
        if n = 0 then false
          else
            let val chr = String.ordof(s,n-1)
            in
              if chr = ord "\n" orelse chr = ord "\t"
                then true
              else aux (n-1)
            end
    in
      aux (size s)
    end

  fun remove_nasty_chars s =
    let fun subst "\n" = " "
          | subst "\t" = " "
          | subst c = c
    in
      implode (map subst (explode s))
    end
		  

  fun trim_history_string (s,user_options) =
    let
      val max_width = get_max_history_width user_options
      val trim_string =
        if size s > max_width
          then String.substring(s,0,max_width - 2) ^ ".."
        else s
    in
      if contains_nasty_chars trim_string
        then remove_nasty_chars trim_string
      else trim_string
    end
  
  (* There is no need to go throught an options structure for this. *)
  fun get_max_history_length user_options =
    let
      val UserOptions.USER_OPTIONS({history_length,...},_) = user_options
    in
      !history_length
    end
      
  fun ministry_of_truth (items,new_factoid,eq,user_options) =
    let
      fun aux ([],_) = []
        | aux (s::l,ix) =
          if ix > 0
            then
              if eq (s,new_factoid) then l
              else
                s :: (aux (l,ix - 1))
          else []
    in
      aux (items,get_max_history_length user_options)
    end

  fun add_history_item (item,history,eq,user_options) =
    history := item :: ministry_of_truth (!history,item,eq,user_options)

end
@


1.13.1.3
log
@Minor fixes to use_file.
@
text
@a4 5
 *  Revision 1.13.1.2  1993/10/08  15:27:26  matthew
 *  Check for editability of defininitions
 *  Predicates for editability and traceability
 *  Utilities for history menus
 *
a334 3
      val filename = Filename.absolute_name source
	(* ~ expansion has been done on source *)

d336 1
a336 1
        (open_in filename, filename)
d338 1
a338 1
          ((open_in filename_sml, filename_sml)
@


1.12
log
@Return quit function from ShellUtils.edit_string
@
text
@d5 3
d331 1
a331 1
          if y <= 0 then "Use: compiling " ^ filename else ("   " ^ spaces (y-1))
@


1.11
log
@Changes to reflect use of moduleids.
I think some more work is needed here - e.g. with the edit functions.
@
text
@d5 4
d173 1
a173 1
        val edit_result = Editor.edit_from_location options (full_name,location)
d176 1
a176 1
          Editor.Option.ABSENT => ()
@


1.10
log
@Added filter_completions function to sort and remove duplicates from
completions.
@
text
@d5 4
d13 27
a39 28
 *
Revision 1.8  1993/06/30  16:34:15  daveb
Removed exception environments.

Revision 1.7  1993/06/17  10:52:42  matthew
Added edit_object and trace functions

Revision 1.6  1993/06/04  14:35:43  daveb
edit functions now return a single string in the errorneous case.

Revision 1.5  1993/06/01  11:42:14  matthew
Added handler for Io on opening file for use

Revision 1.4  1993/05/27  15:57:53  matthew
Added error_info parameter to eval
Added completion functions
Changes to error handling

Revision 1.3  1993/05/12  14:30:11  matthew
Added make, use  and eval functions

Revision 1.2  1993/05/11  14:59:38  matthew
Added make_file an parse_absolute functions

Revision 1.1  1993/04/30  10:57:10  matthew
Initial revision

 *
d59 56
a114 55
functor ShellUtils (structure Lists : LISTS
                    structure Tags : TAGS
                    structure Incremental : INCREMENTAL
                    structure InterPrint : INTERPRINT
                    structure ShellTypes : SHELL_TYPES
                    structure Editor : EDITOR
                    structure Parser : PARSER
                    structure Types : TYPES
                    structure BasisTypes : BASISTYPES
                    structure Completion : COMPLETION
                    structure ValuePrinter : VALUE_PRINTER
                    structure Trace : TRACE
                    structure Io : IO
                    structure UserOptions : USER_OPTIONS

                    sharing Incremental.InterMake.Compiler.Options =
                      Editor.Options = Parser.Options = Completion.Options = ValuePrinter.Options =
                      UserOptions.Options
                    sharing Incremental.InterMake.Compiler.Info = Parser.Lexer.Info
                    sharing InterPrint.Compiler = Incremental.InterMake.Compiler
                    sharing Editor.Option = Incremental.InterMake.FileName.Option
                    sharing InterPrint.Compiler.Absyn = Parser.Absyn
                    sharing Completion.Datatypes = BasisTypes.Datatypes = Incremental.Datatypes
                      = Types.Datatypes
                    sharing Editor.Location = Parser.Lexer.Info.Location

                    sharing type Trace.UserOptions = UserOptions.user_options
                    sharing type InterPrint.Compiler.DebugInformation =
                      ValuePrinter.DebugInformation
                    sharing type BasisTypes.Basis = InterPrint.Compiler.TypeBasis
                    sharing type Parser.ParserBasis = InterPrint.Compiler.ParserBasis
                    sharing type ShellTypes.IncrementalOptions = Incremental.options
                    sharing type InterPrint.Context = Incremental.Context = Trace.Context
                    sharing type ValuePrinter.Type = Incremental.Datatypes.Type = Trace.Type
                    sharing type Parser.Lexer.TokenStream = Incremental.InterMake.Compiler.tokenstream
                      ) : SHELL_UTILS =
  struct
    structure Incremental = Incremental
    structure InterMake = Incremental.InterMake
    structure Filename = Incremental.InterMake.FileName
    structure Option = Filename.Option
    structure Options = Editor.Options
    structure Location = Editor.Location
    structure Info = InterMake.Compiler.Info
    structure Lexer = Parser.Lexer
    structure Token = Lexer.Token
    structure Compiler = InterMake.Compiler
    structure Datatypes = BasisTypes.Datatypes
    structure NewMap = Datatypes.NewMap
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol

    type UserOptions = UserOptions.user_options
    type Context = Incremental.Context
    type Type = Incremental.Datatypes.Type
d116 1
a116 1
    exception Error = Incremental.Error
d138 1
d150 1
d152 1
d154 2
d164 1
d167 2
d172 2
a173 2
          Option.ABSENT => ()
        | Option.PRESENT s => raise EditFailed s
d250 1
a250 1
    Io.trans_home_name filename handle Io.bad_home_name s => s
d280 3
a282 3
        (make_incremental_options(options,debugger))
        monitor_fn
        (!context_ref, filename)
d292 1
a292 1
  fun use_file (pathname,context_ref,user_options,debugger,output_fn,level,queue_function) =
d299 4
a302 2
      val Filename.ABSOLUTE(loc,name,extension) = pathname
        
d305 1
a305 1
          val sml_pathname = 
d307 1
a307 1
              Filename.Option.PRESENT _ => pathname
d310 1
a310 1
          Filename.absolute_name sml_pathname
a312 2
      val filename = Filename.absolute_name pathname
        
@


1.9
log
@Use Info.make_default_options rather than Info.default_options
Changed use message
Insert ; after a string to be evaluated
@
text
@d5 5
d528 12
d562 1
a562 1
          (sofar,complete_token (to_complete,context))
@


1.8
log
@Removed exception environments.
@
text
@d5 3
a259 1
      val error_info = Info.default_options
a268 1
         error_info
d281 1
a281 1
      val error_info = Info.default_options
d307 1
a307 1
          if y <= 0 then filename else ("   " ^ spaces (y-1))
a344 1
            error_info
d362 1
a362 1
        let val sref = ref string
d525 1
a525 1
      val error_info = Info.default_options
@


1.7
log
@Added edit_object and trace functions
@
text
@d5 3
d469 1
a469 2
                                    Datatypes.VE (_,valmap),
                                    _),
d489 1
a489 1
        | get_env_env (sym::path,Datatypes.ENV(Datatypes.SE strmap,_,_,_)) =
@


1.6
log
@edit functions now return a single string in the errorneous case.
@
text
@d5 3
d29 1
d38 1
d46 1
d56 1
d71 1
d77 2
a78 2
                    sharing type InterPrint.Context = Incremental.Context
                    sharing type ValuePrinter.Type = Incremental.Datatypes.Type
d160 65
@


1.5
log
@Added handler for Io on opening file for use
@
text
@d5 3
d142 1
a142 1
        | Option.PRESENT (s,t) => raise EditFailed (s ^ t)
@


1.4
log
@Added error_info parameter to eval
Added completion functions
Changes to error handling
@
text
@d5 5
d218 6
a223 1
        handle Io _ => (open_in filename, filename)
@


1.3
log
@Added make, use  and eval functions
@
text
@d5 3
d17 1
d32 2
a33 1
functor ShellUtils (structure Incremental : INCREMENTAL
d74 1
d76 4
a79 1

d242 6
a247 2
              (make_incremental_options())
              (!context_ref, Compiler.TOKENSTREAM1 token_stream)
d269 1
a269 1
  fun eval (string, options,context,debugger) = 
a270 1
      val error_info = Info.default_options
d277 12
d290 33
a322 7
      val (topdec,_) = Parser.parse_topdec error_info (options,token_stream,parser_basis)
      val result =
        Incremental.evaluate_exp_topdec
        (Incremental.OPTIONS{options = options,
                             debugger = debugger},
         context,
         topdec)
d324 1
a324 1
      result
d326 2
d350 115
@


1.2
log
@Added make_file an parse_absolute functions
@
text
@d5 3
d17 5
d24 1
d32 5
d38 1
d41 3
a43 1
                      Editor.Options
d46 9
d57 2
d68 3
d72 1
d74 1
d88 1
a88 1
    exception EditFailed of string
d90 1
a90 1
    fun lookup_function (filename,Incremental.CONTEXT {modules,...})  =
d92 6
d110 1
a110 1
        Filename.absolute_name pathname
d112 4
a115 2
      handle Filename.Parse _ => raise EditFailed "Invalid pathname"
           | InterMake.Lookup _ => raise EditFailed "Can't find file"
d117 1
a117 1
    fun edit_source (location_string, context,options) =
d119 2
a120 3
        val source = find_source_file location_string
        val full_name = lookup_function (source,context)
        val location = Location.from_string location_string
d127 9
a135 1
      
d180 25
d206 93
@


1.1
log
@Initial revision
@
text
@d4 4
a7 1
 *  $Log: __shell_utils,v $
d13 1
d15 2
d20 1
d23 1
d25 3
d30 1
d35 2
a36 2
    structure FileName = Incremental.InterMake.FileName
    structure Option = FileName.Option
d39 1
d43 2
d60 2
a61 2
          FileName.parse_absolute filename
          handle FileName.Parse _ =>
d63 2
a64 2
              val pname = FileName.parse_relative filename
              val FileName.RELATIVE(_,module_name,_) = pname
d71 1
a71 1
        FileName.absolute_name pathname
d73 1
a73 1
      handle FileName.Parse _ => raise EditFailed "Invalid pathname"
d88 45
@
