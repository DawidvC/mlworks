head	1.20;
access;
symbols
	MLW_daveb_inline_1_4_99:1.20.1
	MLWorks_21c0_1999_03_25:1.20
	MLWorks_20c1_1998_08_20:1.20
	MLWorks_20c0_1998_08_04:1.20
	MLWorks_20b2c2_1998_06_19:1.20
	MLWorks_20b2_Windows_1998_06_12:1.20
	MLWorks_20b1c1_1998_05_07:1.20
	MLWorks_20b0_1998_04_07:1.20
	MLWorks_20b0_1998_03_20:1.20
	MLWorks_20m2_1998_02_16:1.20
	MLWorks_20m1_1997_10_23:1.20
	MLWorks_11r1:1.18.5.1.1.1.1
	MLWorks_workspace_97:1.19.2
	MLWorks_dt_wizard:1.19.1
	MLWorks_11c0_1997_09_09:1.18.5.1.1.1
	MLWorks_10r3:1.18.5.1.3
	MLWorks_10r2_551:1.18.5.1.2
	MLWorks_11:1.18.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.18.5.1
	MLWorks_20m0_1997_06_20:1.19
	MLWorks_1_0_r2c2_1997_06_14:1.18.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.18.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.18.5
	MLWorks_BugFix_1997_04_24:1.18
	MLWorks_1_0_r2_Win32_1997_04_11:1.18
	MLWorks_1_0_r2_Unix_1997_04_04:1.18
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.18.3.1.1
	MLWorks_gui_1996_12_18:1.18.4
	MLWorks_1_0_Win32_1996_12_17:1.18.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.18.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.18.1.1
	MLWorks_1_0_Irix_1996_11_28:1.18.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.18.2
	MLWorks_1_0_Unix_1996_11_14:1.18.1
	MLWorks_Open_Beta2_1996_10_11:1.16.3
	MLWorks_License_dev:1.16.2
	MLWorks_1_open_beta_1996_09_13:1.16.1
	MLWorks_Open_Beta_1996_08_22:1.16
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.15
	MLWorks_Beta_1996_06_06:1.15
	MLWorks_Beta_1996_06_05:1.15
	MLWorks_Beta_1996_06_03:1.15
	MLWorks_Beta_1996_05_31:1.15
	MLWorks_Beta_1996_05_30:1.15
	ML_beta_release_12/08/94:1.10
	ML_beta_release_03/08/94:1.10
	ML_revised_beta_release_25/05/94:1.10
	ML_final_beta_release_02/03/94:1.9
	mlworks-28-01-1994:1.7
	Release:1.6
	mlworks-beta-01-09-1993:1.6;
locks; strict;
comment	@ * @;


1.20
date	97.09.18.15.41.58;	author brucem;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	97.05.22.13.56.17;	author jont;	state Exp;
branches
	1.19.1.1
	1.19.2.1;
next	1.18;

1.18
date	96.11.08.13.52.44;	author matthew;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1
	1.18.4.1
	1.18.5.1;
next	1.17;

1.17
date	96.10.09.14.42.12;	author io;	state Exp;
branches;
next	1.16;

1.16
date	96.08.06.15.29.47;	author andreww;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1;
next	1.15;

1.15
date	96.05.01.10.20.12;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	95.05.25.10.37.53;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	95.04.28.12.15.39;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	95.02.14.14.06.24;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	94.09.26.09.25.36;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	94.05.05.10.11.11;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	94.02.28.06.52.25;	author nosa;	state Exp;
branches;
next	1.8;

1.8
date	94.02.23.17.36.13;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.08.12.20.09.23;	author nosa;	state Exp;
branches;
next	1.6;

1.6
date	93.05.18.18.46.52;	author jont;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	93.05.06.13.12.05;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.04.21.15.50.43;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.04.20.10.24.51;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.04.01.12.10.05;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.12.15.24.58;	author matthew;	state Exp;
branches;
next	;

1.6.1.1
date	93.05.18.18.46.52;	author jont;	state Exp;
branches;
next	;

1.16.1.1
date	96.09.13.11.16.08;	author hope;	state Exp;
branches;
next	;

1.16.2.1
date	96.10.07.16.06.11;	author hope;	state Exp;
branches;
next	;

1.16.3.1
date	96.10.17.11.24.27;	author hope;	state Exp;
branches;
next	;

1.18.1.1
date	96.11.14.12.49.10;	author hope;	state Exp;
branches
	1.18.1.1.1.1;
next	;

1.18.1.1.1.1
date	96.11.28.15.00.30;	author hope;	state Exp;
branches;
next	;

1.18.2.1
date	96.11.22.18.08.54;	author hope;	state Exp;
branches;
next	;

1.18.3.1
date	96.12.17.17.47.32;	author hope;	state Exp;
branches
	1.18.3.1.1.1;
next	;

1.18.3.1.1.1
date	97.02.24.11.37.16;	author hope;	state Exp;
branches;
next	;

1.18.4.1
date	96.12.18.09.41.33;	author hope;	state Exp;
branches;
next	;

1.18.5.1
date	97.05.12.10.33.59;	author hope;	state Exp;
branches
	1.18.5.1.1.1
	1.18.5.1.2.1
	1.18.5.1.3.1;
next	;

1.18.5.1.1.1
date	97.07.28.18.19.29;	author daveb;	state Exp;
branches
	1.18.5.1.1.1.1.1;
next	;

1.18.5.1.1.1.1.1
date	97.10.07.11.44.38;	author jkbrook;	state Exp;
branches;
next	;

1.18.5.1.2.1
date	97.09.08.17.13.05;	author daveb;	state Exp;
branches;
next	;

1.18.5.1.3.1
date	97.09.09.14.08.43;	author daveb;	state Exp;
branches;
next	;

1.19.1.1
date	97.09.10.19.24.03;	author brucem;	state Exp;
branches;
next	;

1.19.2.1
date	97.09.11.20.54.53;	author daveb;	state Exp;
branches;
next	;

1.20.1.1
date	99.04.01.17.56.53;	author daveb;	state Exp;
branches;
next	;


desc
@tty inspector
@


1.20
log
@[Bug #30153]
Remove references to Old.
@
text
@(* tty inspector
 *
 * Copyright (C) 1993 Harlequin Ltd.
 *
 * $Log: _inspector.sml,v $
 * Revision 1.19  1997/05/22  13:56:17  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.18  1996/11/08  13:52:44  matthew
 * [Bug #1672]
 * Adding handler for LookupValid exn
 *
 * Revision 1.17  1996/10/09  14:42:12  io
 * moving String from toplevel
 *
 * Revision 1.16  1996/08/06  15:29:47  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml and _types.sml
 *
 * Revision 1.15  1996/05/01  10:20:12  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.14  1995/05/25  10:37:53  daveb
 * Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.13  1995/04/28  12:15:39  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.12  1995/02/14  14:06:24  matthew
 *  Lexer structure changes
 *  
 *  Revision 1.11  1994/09/26  09:25:36  matthew
 *  Change to Basis.lookup_val
 *  
 *  Revision 1.10  1994/05/05  10:11:11  daveb
 *  Basis.lookup_val now has an extra argument.
 *  Also added sharing constraint.
 *  
 *  Revision 1.9  1994/02/28  06:52:25  nosa
 *  Boolean indicators for Modules Debugger and Monomorphic debugger decapsulation.
 *  
 *  Revision 1.8  1994/02/23  17:36:13  matthew
 *  Added function to inspect a dynamic value
 *  
 *  Revision 1.7  1993/08/12  20:09:23  nosa
 *  lookup_val now returns runtime_instance for polymorphic debugger.
 *  
 *  Revision 1.6  1993/05/18  18:46:52  jont
 *  Removed integer parameter
 *  
 *  Revision 1.5  1993/05/06  13:12:05  matthew
 *  Removed printer_descriptors
 *  
 *  Revision 1.4  1993/04/21  15:50:43  matthew
 *  Got working with new InspectorValues
 *  
 *  Revision 1.3  1993/04/20  10:24:51  matthew
 *  Renamed Inspector_Values to InspectorValues
 *  
 *  Revision 1.2  1993/04/01  12:10:05  matthew
 *  Changed interface to InspectorValues.
 *  This is currently broken
 *  
 *  Revision 1.1  1993/03/12  15:24:58  matthew
 *  Initial revision
 *  
 *)

require "^.basis.__text_io";
require "../utils/lists";

require "../interpreter/incremental";
require "../typechecker/basis";
require "../typechecker/types";
require "../interpreter/inspector_values";
require "../main/user_options";
require "../interpreter/shell_types";
require "../debugger/value_printer";

require "inspector";

functor Inspector (
  structure Lists : LISTS
  structure Incremental : INCREMENTAL
  structure UserOptions : USER_OPTIONS
  structure Basis : BASIS
  structure Types : TYPES
  structure InspectorValues : INSPECTOR_VALUES
  structure ValuePrinter : VALUE_PRINTER
  structure ShellTypes : SHELL_TYPES
                     
  sharing Incremental.InterMake.Inter_EnvTypes.EnvironTypes.LambdaTypes.Ident =
          Basis.BasisTypes.Datatypes.Ident
  sharing Basis.BasisTypes.Datatypes = Types.Datatypes =
          Incremental.Datatypes
  sharing ValuePrinter.Options = UserOptions.Options = Types.Options =
          Incremental.InterMake.Compiler.Options = ShellTypes.Options
    
  sharing type UserOptions.user_tool_options = ShellTypes.user_options
  sharing type ValuePrinter.DebugInformation =
               Incremental.InterMake.Compiler.DebugInformation
  sharing type Basis.BasisTypes.Datatypes.Type = InspectorValues.Type =
               ValuePrinter.Type
  sharing type Types.Options.options = InspectorValues.options
  sharing type Basis.BasisTypes.Basis = Incremental.InterMake.Compiler.TypeBasis
  sharing type ShellTypes.Context = Incremental.Context
) : INSPECTOR =
  struct
    structure Incremental = Incremental
    structure Ident = Basis.BasisTypes.Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Inter_EnvTypes = Incremental.InterMake.Inter_EnvTypes
    structure Options = Inter_EnvTypes.Options

    type Context = Incremental.Context
    type ShellData = ShellTypes.ShellData

    type Type = Types.Datatypes.Type

    fun get_name () = "it"

    fun printname (Ident.VAR s) = Symbol.symbol_name s
      | printname (Ident.CON s) = Symbol.symbol_name s
      | printname (Ident.EXCON s) = Symbol.symbol_name s
      | printname (Ident.TYCON' s) = Symbol.symbol_name s

    (* This should evaluate an arbitrary expression *)
    fun lookup_name (name,context) =
      let
        val tycontext = Basis.basis_to_context (Incremental.type_basis context)
        val valid = Ident.VAR(Symbol.find_symbol name)
        val valtype =
	  #1(Basis.lookup_val (Ident.LONGVALID (Ident.NOPATH, valid),
                               tycontext,
                               Ident.Location.FILE "Inspector", 
                               false))
        val mlval = Inter_EnvTypes.lookup_val(valid,Incremental.inter_env context)
      in
        (mlval,valtype)
      end

    val show_them =
      Lists.iterate
      (fn (tag,string) => 
       print(concat [tag,": ",string,"\n"]))

    (* This should be shared with _inspector_tool *)

    fun getreps (item as (value,ty),subitems,shelldata) =
      let
        val options = ShellTypes.get_current_options shelldata
        val Options.OPTIONS{print_options,...} = options
        val debug_info = Incremental.debug_info (ShellTypes.get_current_context shelldata)

        fun print_value (object,ty) =
          ValuePrinter.stringify_value false (print_options,
                                              object,
                                              ty,
                                              debug_info)

        val print_type = Types.print_type options
      in
        ((print_value item,print_type ty),
         map (fn (x,y) => (x,print_value y)) subitems)
      end

    fun lookup (tag,list) =
      Lists.assoc(tag,list)

    fun inspect (arg as (valtype,mlval),stack,shelldata) =
      let
        val options = ShellTypes.get_current_options shelldata
        val subobjects = InspectorValues.get_inspector_values options false arg
        val ((valuestring,typestring),items) = getreps (arg,subobjects,shelldata)
        fun show_help () =
          print (concat (["Commands:\n",
                           " p        - inspect the object containing this one\n",
                           " q        - quit the inspector\n",
                           " <field name> - inspect the named field\n",
                           " ?        - print this message\n"]))
        fun doit () =
          let
            val _ = print("Value: " ^ valuestring ^ "\n")
            val _ = print("Type: " ^ typestring ^ "\n")
            val _ = show_them items;
            val _ = print "Inspector> "
            val _ = TextIO.flushOut TextIO.stdOut;
          in
            case rev (explode (TextIO.inputLine(TextIO.stdIn))) of
              [] => ()
            | (_::tagl) =>
                let
                  val tag = implode (rev tagl)
                in
                  case tag of
                    "q" => ()
                  | "?" => (show_help (); doit())
                  | "p" => (case stack of [] => doit () | (arg'::stack') => inspect(arg',stack',shelldata))
                  | _ =>  inspect (lookup (tag,subobjects),arg::stack,shelldata)
                      handle Lists.Assoc => (print("Enter ? for help\n");
                                             doit())
                end
          end
      in
        doit ()
      end

    fun inspect_value (typed_object,shelldata) =
      (print "Entering TTY inspector - enter ? for help\n"; 
       inspect (typed_object,[],shelldata))

    fun inspect_it (shelldata) =
      let
        val name = get_name ()
        val typed_object = lookup_name (name,ShellTypes.get_current_context shelldata)
      in
        print "Entering TTY inspector - enter ? for help\n";
        inspect (typed_object,[],shelldata)
      end
    handle Basis.LookupValId valid =>
      print ("Error: variable " ^ printname valid ^ " not defined\n")

  end
@


1.20.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.20  1997/09/18  15:41:58  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
@


1.19
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d6 4
a73 1
(*require "^.basis.__old";*)
@


1.19.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 * Revision 1.19  1997/05/22  13:56:17  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.19.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 4
 * Revision 1.19  1997/05/22  13:56:17  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.18
log
@[Bug #1672]
Adding handler for LookupValid exn
@
text
@d6 4
d69 2
d72 1
a81 1
require "^.basis.__old";
d146 1
a146 1
       MLWorks.IO.output (MLWorks.IO.std_out,concat [tag,": ",string,"\n"]))
a170 2
    fun print s = MLWorks.IO.output(MLWorks.IO.std_out, s)

d188 1
a188 1
            val _ = MLWorks.IO.flush_out MLWorks.IO.std_out;
d190 1
a190 1
            case rev (explode (MLWorks.IO.input_line(MLWorks.IO.std_in))) of
@


1.18.5.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/08  13:52:44  matthew
 * [Bug #1672]
 * Adding handler for LookupValid exn
 *
@


1.18.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.18.5.1  1997/05/12  10:33:59  hope
 * branched from 1.18
 *
@


1.18.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.18.5.1  1997/05/12  10:33:59  hope
 * branched from 1.18
 *
@


1.18.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.18.5.1  1997/05/12  10:33:59  hope
 * branched from 1.18
 *
@


1.18.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.18.5.1.1.1  1997/07/28  18:19:29  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.18.4.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/08  13:52:44  matthew
 * [Bug #1672]
 * Adding handler for LookupValid exn
 *
@


1.18.3.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/08  13:52:44  matthew
 * [Bug #1672]
 * Adding handler for LookupValid exn
 *
@


1.18.3.1.1.1
log
@branched from 1.18.3.1
@
text
@a5 3
 * Revision 1.18.3.1  1996/12/17  17:47:32  hope
 * branched from 1.18
 *
@


1.18.2.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/08  13:52:44  matthew
 * [Bug #1672]
 * Adding handler for LookupValid exn
 *
@


1.18.1.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/08  13:52:44  matthew
 * [Bug #1672]
 * Adding handler for LookupValid exn
 *
@


1.18.1.1.1.1
log
@branched from 1.18.1.1
@
text
@a5 3
 * Revision 1.18.1.1  1996/11/14  12:49:10  hope
 * branched from 1.18
 *
@


1.17
log
@moving String from toplevel
@
text
@d6 3
d117 5
d217 2
@


1.16
log
@[Bug #1521]
Propagating changes made to typechecker/_scheme.sml and _types.sml
@
text
@d6 4
d72 1
d132 1
a132 1
       MLWorks.IO.output (MLWorks.IO.std_out,String.implode [tag,": ",string,"\n"]))
d165 1
a165 1
          print (String.implode (["Commands:\n",
d178 1
a178 1
            case rev (String.explode (MLWorks.IO.input_line(MLWorks.IO.std_in))) of
d182 1
a182 1
                  val tag = String.implode(rev tagl)
@


1.16.3.1
log
@branched from 1.16
@
text
@a5 4
 * Revision 1.16  1996/08/06  15:29:47  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml and _types.sml
 *
@


1.16.2.1
log
@branched from 1.16
@
text
@a5 4
 * Revision 1.16  1996/08/06  15:29:47  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml and _types.sml
 *
@


1.16.1.1
log
@branched from 1.16
@
text
@a5 4
 * Revision 1.16  1996/08/06  15:29:47  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml and _types.sml
 *
@


1.15
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d6 6
d91 1
d133 2
a134 1
        val print_options = ShellTypes.get_current_print_options shelldata
d136 1
d143 1
a143 1
        val print_type = Types.print_type print_options
d156 2
a157 1
        val subobjects = InspectorValues.get_inspector_values false arg
@


1.14
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d6 3
d120 1
a120 1
       output (std_out,implode [tag,": ",string,"\n"]))
d143 1
a143 1
    fun print s = output(std_out, s)
d150 1
a150 1
          print (implode (["Commands:\n",
d161 1
a161 1
            val _ = MLWorks.IO.flush_out std_out;
d163 1
a163 1
            case rev (explode (MLWorks.IO.input_line(std_in))) of
d167 1
a167 1
                  val tag = implode(rev tagl)
@


1.13
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d6 3
d77 1
a77 1
  sharing type UserOptions.user_options = ShellTypes.user_options
@


1.12
log
@Lexer structure changes
@
text
@d6 38
a43 35
Revision 1.11  1994/09/26  09:25:36  matthew
Change to Basis.lookup_val

Revision 1.10  1994/05/05  10:11:11  daveb
Basis.lookup_val now has an extra argument.
Also added sharing constraint.

Revision 1.9  1994/02/28  06:52:25  nosa
Boolean indicators for Modules Debugger and Monomorphic debugger decapsulation.

Revision 1.8  1994/02/23  17:36:13  matthew
Added function to inspect a dynamic value

Revision 1.7  1993/08/12  20:09:23  nosa
lookup_val now returns runtime_instance for polymorphic debugger.

Revision 1.6  1993/05/18  18:46:52  jont
Removed integer parameter

Revision 1.5  1993/05/06  13:12:05  matthew
Removed printer_descriptors

Revision 1.4  1993/04/21  15:50:43  matthew
Got working with new InspectorValues

Revision 1.3  1993/04/20  10:24:51  matthew
Renamed Inspector_Values to InspectorValues

Revision 1.2  1993/04/01  12:10:05  matthew
Changed interface to InspectorValues.
This is currently broken

Revision 1.1  1993/03/12  15:24:58  matthew
Initial revision

d58 8
a65 15
                   structure Lists : LISTS
                   structure Incremental : INCREMENTAL
                   structure UserOptions : USER_OPTIONS
                   structure Basis : BASIS
                   structure Types : TYPES
                   structure InspectorValues : INSPECTOR_VALUES
                   structure ValuePrinter : VALUE_PRINTER
                   structure ShellTypes : SHELL_TYPES
                     
                   sharing Incremental.InterMake.Inter_EnvTypes.EnvironTypes.LambdaTypes.Ident =
                     Basis.BasisTypes.Datatypes.Ident
                   sharing Basis.BasisTypes.Datatypes = Types.Datatypes =
                     Incremental.Datatypes
                   sharing ValuePrinter.Options = UserOptions.Options = Types.Options =
                     Incremental.InterMake.Compiler.Options = ShellTypes.Options
d67 15
a81 11
		   sharing ShellTypes.Info.Location =
			   Basis.BasisTypes.Datatypes.Ident.Location
                   sharing type UserOptions.user_options = ShellTypes.user_options
                   sharing type ValuePrinter.DebugInformation =
                     Incremental.InterMake.Compiler.DebugInformation
                   sharing type Basis.BasisTypes.Datatypes.Type = InspectorValues.Type =
                     ValuePrinter.Type
                   sharing type Basis.BasisTypes.Basis = Incremental.InterMake.Compiler.TypeBasis
                   sharing type ShellTypes.Context = Incremental.Context
                   sharing type ShellTypes.IncrementalOptions = Incremental.options
                                                                             ) : INSPECTOR =
@


1.11
log
@Change to Basis.lookup_val
@
text
@d6 3
a44 1
require "../parser/parser";
a56 1
                   structure Parser : PARSER
d69 1
a69 3
                     Incremental.InterMake.Compiler.Options = Parser.Options = ShellTypes.Options
                   sharing Parser.Absyn = Incremental.InterMake.Compiler.Absyn
                   sharing Parser.Lexer.Info = ShellTypes.Info
a73 1
                   sharing type Parser.ParserBasis = Incremental.InterMake.Compiler.ParserBasis
@


1.10
log
@Basis.lookup_val now has an extra argument.
Also added sharing constraint.
@
text
@d6 4
d104 4
a107 3
	  #1(Basis.lookup_val
	       (Ident.NOPATH, valid, tycontext,
		Ident.Location.FILE "Inspector", false))
@


1.9
log
@Boolean indicators for Modules Debugger and Monomorphic debugger decapsulation.
@
text
@d6 3
d68 2
d99 4
a102 1
        val valtype = #1(Basis.lookup_val (Ident.NOPATH,valid,tycontext,false))
@


1.8
log
@Added function to inspect a dynamic value
@
text
@d6 3
d94 1
a94 1
        val valtype = #1(Basis.lookup_val (Ident.NOPATH,valid,tycontext))
d112 4
a115 4
          ValuePrinter.stringify_value(print_options,
                                       object,
                                       ty,
                                       debug_info)
d130 1
a130 1
        val subobjects = InspectorValues.get_inspector_values arg
@


1.7
log
@lookup_val now returns runtime_instance for polymorphic debugger.
@
text
@d6 3
d82 2
d123 3
a125 1
    fun inspect_it (arg as (valtype,mlval),stack,shelldata) =
d129 6
d137 2
a138 2
            val _ = output(std_out,valuestring ^ "\n")
            val _ = output(std_out,typestring ^ "\n")
d140 2
a141 2
            val (_::tagl) = rev (explode (MLWorks.IO.input_line(std_in)))
            val tag = implode(rev tagl)
d143 14
a156 5
            case tag of
              "q" => ()
            | "b" => (case stack of [] => doit () | (arg'::stack') => inspect_it(arg',stack',shelldata))
            | _ => inspect_it (lookup (tag,subobjects),arg::stack,shelldata)
                   handle Lists.Assoc => doit()
d162 5
a166 1
    fun inspect_value (shelldata) =
d171 2
a172 1
        inspect_it (typed_object,[],shelldata)
@


1.6
log
@Removed integer parameter
@
text
@d6 3
d86 1
a86 1
        val valtype = Basis.lookup_val (Ident.NOPATH,valid,tycontext)
@


1.6.1.1
log
@Fork for bug fixing
@
text
@a5 3
Revision 1.6  1993/05/18  18:46:52  jont
Removed integer parameter

@


1.5
log
@Removed printer_descriptors
@
text
@d6 3
a23 1
require "../utils/integer";
d36 1
a36 1
functor Inspector (structure Integer : INTEGER
@


1.4
log
@Got working with new InspectorValues
@
text
@d6 3
a53 1
                   sharing type ValuePrinter.printer_descriptor = ShellTypes.printer_descriptor
d96 1
a96 2
        val printer_descriptor = ShellTypes.make_printer_descriptor shelldata
        val ValuePrinter.PRINTER_DESCRIPTOR{print_options,...} = printer_descriptor
d99 1
a99 1
          ValuePrinter.stringify_value(printer_descriptor,
@


1.3
log
@Renamed Inspector_Values to InspectorValues
@
text
@d6 3
d18 2
d21 1
d23 6
a28 2
require "../utils/integer";
require "inspector_values";
d31 7
a37 2
functor Inspector (structure Incremental : INCREMENTAL
                   structure Integer : INTEGER
d39 3
a41 2
                   structure Basis : BASIS

d44 14
a57 3

                   sharing type Basis.BasisTypes.Datatypes.Type = InspectorValues.Type

d59 3
a61 2

                 ) : INSPECTOR =
d70 1
d72 1
a72 1
    fun get_name context = "it"
d74 1
d85 48
a132 33
    (* this is the crucial function
     This should create a display window with appropriate callbacks.
     Need a static "inspect method" mechanism
     This should be of form (type,mlval) -> (label * string) list * (label -> (type,mlval))
     or something


     *)

   fun show_them [] = ()
     | show_them ((tag,string)::l) =
       (output (std_out,implode [tag,": ",string,"\n"]);
        show_them l)

   fun inspect_it (arg as (valtype,mlval),stack) =
     let
       val (title,_,taglist,f) = ("","",[],fn _ => raise Div)
         (* InspectorValues.get_inspector_values (Options.default_options,(valtype,mlval)) *)
       fun doit () =
         let
           val _ = output(std_out,title ^ "\n")
           val _ = show_them taglist;
           val (_::tagl) = rev (explode (MLWorks.IO.input_line(std_in)))
           val tag = implode(rev tagl)
         in
           case tag of
             "q" => ()
           | "b" => (case stack of [] => doit () | (arg'::stack') => inspect_it(arg',stack'))
           | _ => inspect_it ((f tag),arg::stack)
         end
     in
       doit ()
     end
d134 1
a134 1
    fun inspect_value (ref context) =
d136 2
a137 2
        val name = get_name context
        val typed_object = lookup_name (name,context)
d139 1
a139 1
        inspect_it (typed_object,[])
@


1.2
log
@Changed interface to InspectorValues.
This is currently broken
@
text
@d6 4
d23 1
a23 1
                   structure Inspector_Values : INSPECTOR_VALUES
d29 1
a29 1
                   sharing type Basis.BasisTypes.Datatypes.Type = Inspector_Values.Type
d72 1
a72 1
         (* Inspector_Values.get_inspector_values (Options.default_options,(valtype,mlval)) *)
@


1.1
log
@Initial revision
@
text
@d6 3
d24 3
a26 1
                   sharing Basis.BasisTypes.Datatypes = Inspector_Values.Datatypes
d35 1
d67 2
a68 1
       val (title,taglist,f) = Inspector_Values.get_inspector_values (valtype,mlval)
d79 1
a79 10
           | _ =>
               (* note non-tail recursion *)
               (inspect_it ((f tag),arg::stack)
                handle Inspector_Values.BadLabel =>
                  (output(std_out,"Invalid label\n");
                   doit ())
                     | Inspector_Values.CantInspect =>
                         (output(std_out,"Can't inspect subobject\n");
                          doit ()))

a90 48
        handle
        Inspector_Values.BadLabel => ()
      | Inspector_Values.CantInspect => ()
      end

(*
    (* Here bygynneth ye window inspector *)

    exception Error

    fun make_item_list l =
      map (fn (x,y) => implode[x,": ",y]) l

    fun make_inspector_window (typedobject,parent) =
      let
        val (title,items,cfn) = Inspector_Values.get_inspector_values typedobject
        val shell = Widgets.create_toplevel_shell (parent,"Inspector",[])
        val frame = Widgets.create_paned_window(shell,"mlworks_inspector_pane",[])
        val win = Widgets.create_list (frame,"Inspector Pain",
                                       [ClmTypes.CLMSYMBOL "SELECTION-POLICY", ClmTypes.CLMSYMBOL "SINGLE"])
        val callback_fun = ref cfn
      in
        (ClmList.set_items (win,make_item_list items);
         Clm.add_callback
         (win,
          "SINGLE-SELECTION",
          (fn (_, _ :: ClmTypes.CLMINT pos :: _) =>
           (let
             val new_typedobject = (!callback_fun) (Integer.makestring (pos-1))
             val (title,newitems,newcfn) = Inspector_Values.get_inspector_values new_typedobject
            in
              callback_fun := newcfn;
              ClmList.set_items (win,make_item_list newitems)
            end
            handle Inspector_Values.CantInspect => ())
              | _ => raise Error));
         Widgets.realize_widget shell;
         Dialogs.popup shell)
      end
      handle Inspector_Values.CantInspect => ()

    fun win_inspect_value (ref context,widget) =
      let
        val name = get_name context
        val typed_object = lookup_name (name,context)
      in
        (make_inspector_window (typed_object,widget);
         ())
a91 1
*)
@
