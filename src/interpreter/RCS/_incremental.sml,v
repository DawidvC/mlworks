head	1.143;
access;
symbols
	MLW_daveb_inline_1_4_99:1.143.1
	MLWorks_21c0_1999_03_25:1.143
	MLWorks_20c1_1998_08_20:1.142
	MLWorks_20c0_1998_08_04:1.142
	MLWorks_20b2c2_1998_06_19:1.142
	MLWorks_20b2_Windows_1998_06_12:1.142
	MLWorks_20b1c1_1998_05_07:1.141
	MLWorks_20b0_1998_04_07:1.139
	MLWorks_20b0_1998_03_20:1.139
	MLWorks_20m2_1998_02_16:1.139
	MLWorks_20m1_1997_10_23:1.138
	MLWorks_11r1:1.132.1.2.1.1.1
	MLWorks_workspace_97:1.137.2
	MLWorks_dt_wizard:1.137.1
	MLWorks_11c0_1997_09_09:1.132.1.2.1.1
	MLWorks_10r3:1.132.1.2.3
	MLWorks_10r2_551:1.132.1.2.2
	MLWorks_11:1.132.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.132.1.2
	MLWorks_20m0_1997_06_20:1.137
	MLWorks_1_0_r2c2_1997_06_14:1.132.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.132.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.132.1
	MLWorks_BugFix_1997_04_24:1.133
	MLWorks_1_0_r2_Win32_1997_04_11:1.132
	MLWorks_1_0_r2_Unix_1997_04_04:1.132
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.130.3.1.1
	MLWorks_gui_1996_12_18:1.130.4
	MLWorks_1_0_Win32_1996_12_17:1.130.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.130.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.130.1.1
	MLWorks_1_0_Irix_1996_11_28:1.130.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.130.2
	MLWorks_1_0_Unix_1996_11_14:1.130.1
	MLWorks_Open_Beta2_1996_10_11:1.128.3
	MLWorks_License_dev:1.128.2
	MLWorks_1_open_beta_1996_09_13:1.128.1
	MLWorks_Open_Beta_1996_08_22:1.128
	MLWorks_Beta_1996_07_02:1.126
	MLWorks_Beta_1996_06_07:1.124
	MLWorks_Beta_1996_06_06:1.124
	MLWorks_Beta_1996_06_05:1.124
	MLWorks_Beta_1996_06_03:1.124
	MLWorks_Beta_1996_05_31:1.124
	MLWorks_Beta_1996_05_30:1.124
	ML_beta_release_12/08/94:1.80
	ML_beta_release_03/08/94:1.79
	ML_revised_beta_release_25/05/94:1.71
	ML_final_beta_release_02/03/94:1.66
	mlworks-28-01-1994:1.62
	Release:1.55
	mlworks-beta-01-09-1993:1.55
	MLWorks-1-0-4-29/01/1993:1.31
	MLWorks-1-0-3-21/12/1992:1.29
	MLWorks-1-0-2-15/12/1992:1.28
	MLWorks-1-0-1-04/12/1992:1.25;
locks; strict;
comment	@ * @;


1.143
date	98.11.26.10.47.33;	author johnh;	state Exp;
branches
	1.143.1.1;
next	1.142;

1.142
date	98.06.08.10.00.52;	author jont;	state Exp;
branches;
next	1.141;

1.141
date	98.05.07.09.20.02;	author mitchell;	state Exp;
branches;
next	1.140;

1.140
date	98.04.24.15.49.25;	author mitchell;	state Exp;
branches;
next	1.139;

1.139
date	98.01.29.16.16.18;	author johnh;	state Exp;
branches;
next	1.138;

1.138
date	97.09.17.15.49.11;	author brucem;	state Exp;
branches;
next	1.137;

1.137
date	97.05.28.08.56.42;	author johnh;	state Exp;
branches
	1.137.1.1
	1.137.2.1;
next	1.136;

1.136
date	97.05.21.17.09.25;	author jont;	state Exp;
branches;
next	1.135;

1.135
date	97.05.12.16.18.57;	author jont;	state Exp;
branches;
next	1.134;

1.134
date	97.05.02.16.55.26;	author jont;	state Exp;
branches;
next	1.133;

1.133
date	97.04.09.16.25.35;	author jont;	state Exp;
branches;
next	1.132;

1.132
date	97.03.21.11.28.21;	author johnh;	state Exp;
branches
	1.132.1.1;
next	1.131;

1.131
date	97.02.11.18.13.05;	author daveb;	state Exp;
branches;
next	1.130;

1.130
date	96.10.30.14.54.56;	author io;	state Exp;
branches
	1.130.1.1
	1.130.2.1
	1.130.3.1
	1.130.4.1;
next	1.129;

1.129
date	96.10.25.14.41.08;	author andreww;	state Exp;
branches;
next	1.128;

1.128
date	96.08.16.14.01.34;	author jont;	state Exp;
branches
	1.128.1.1
	1.128.2.1
	1.128.3.1;
next	1.127;

1.127
date	96.07.02.09.40.47;	author daveb;	state Exp;
branches;
next	1.126;

1.126
date	96.06.24.10.41.45;	author stephenb;	state Exp;
branches;
next	1.125;

1.125
date	96.06.21.12.28.35;	author stephenb;	state Exp;
branches;
next	1.124;

1.124
date	96.05.03.10.56.59;	author daveb;	state Exp;
branches;
next	1.123;

1.123
date	96.05.03.09.15.49;	author daveb;	state Exp;
branches;
next	1.122;

1.122
date	96.05.01.09.47.24;	author jont;	state Exp;
branches;
next	1.121;

1.121
date	96.04.16.14.59.15;	author daveb;	state Exp;
branches;
next	1.120;

1.120
date	96.04.16.12.05.04;	author jont;	state Exp;
branches;
next	1.119;

1.119
date	96.04.02.11.37.05;	author daveb;	state Exp;
branches;
next	1.118;

1.118
date	96.03.27.11.43.08;	author stephenb;	state Exp;
branches;
next	1.117;

1.117
date	96.03.26.17.15.34;	author matthew;	state Exp;
branches;
next	1.116;

1.116
date	96.03.26.11.47.25;	author jont;	state Exp;
branches;
next	1.115;

1.115
date	96.03.26.09.44.30;	author daveb;	state Exp;
branches;
next	1.114;

1.114
date	96.03.19.16.33.09;	author matthew;	state Exp;
branches;
next	1.113;

1.113
date	96.03.19.12.18.25;	author daveb;	state Exp;
branches;
next	1.112;

1.112
date	96.03.19.10.34.27;	author daveb;	state Exp;
branches;
next	1.111;

1.111
date	96.03.19.10.20.10;	author daveb;	state Exp;
branches;
next	1.110;

1.110
date	96.03.19.10.02.40;	author daveb;	state Exp;
branches;
next	1.109;

1.109
date	96.03.18.16.12.35;	author daveb;	state Exp;
branches;
next	1.108;

1.108
date	96.03.18.14.12.11;	author daveb;	state Exp;
branches;
next	1.107;

1.107
date	96.03.14.17.47.11;	author daveb;	state Exp;
branches;
next	1.106;

1.106
date	96.03.14.16.19.38;	author daveb;	state Exp;
branches;
next	1.105;

1.105
date	96.03.04.14.57.08;	author daveb;	state Exp;
branches;
next	1.104;

1.104
date	96.02.27.13.43.35;	author daveb;	state Exp;
branches;
next	1.103;

1.103
date	96.02.23.17.54.32;	author jont;	state Exp;
branches;
next	1.102;

1.102
date	95.12.27.14.57.41;	author jont;	state Exp;
branches;
next	1.101;

1.101
date	95.12.11.16.49.41;	author daveb;	state Exp;
branches;
next	1.100;

1.100
date	95.12.11.16.15.52;	author daveb;	state Exp;
branches;
next	1.99;

1.99
date	95.12.11.15.18.12;	author daveb;	state Exp;
branches;
next	1.98;

1.98
date	95.12.11.10.27.52;	author daveb;	state Exp;
branches;
next	1.97;

1.97
date	95.12.06.18.39.34;	author daveb;	state Exp;
branches;
next	1.96;

1.96
date	95.11.29.14.39.33;	author daveb;	state Exp;
branches;
next	1.95;

1.95
date	95.07.28.12.27.38;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	95.07.13.12.01.20;	author matthew;	state Exp;
branches;
next	1.93;

1.93
date	95.06.01.16.20.59;	author matthew;	state Exp;
branches;
next	1.92;

1.92
date	95.05.11.13.48.49;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	95.05.02.16.07.54;	author jont;	state Exp;
branches;
next	1.90;

1.90
date	95.04.20.14.52.17;	author daveb;	state Exp;
branches;
next	1.89;

1.89
date	95.03.30.13.22.32;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	95.03.06.11.47.19;	author daveb;	state Exp;
branches;
next	1.87;

1.87
date	95.02.13.17.11.14;	author matthew;	state Exp;
branches;
next	1.86;

1.86
date	95.02.08.12.23.16;	author matthew;	state Exp;
branches;
next	1.85;

1.85
date	95.01.30.16.13.05;	author daveb;	state Exp;
branches;
next	1.84;

1.84
date	95.01.30.15.16.37;	author matthew;	state Exp;
branches;
next	1.83;

1.83
date	95.01.16.17.32.33;	author daveb;	state Exp;
branches;
next	1.82;

1.82
date	94.12.06.10.29.46;	author matthew;	state Exp;
branches;
next	1.81;

1.81
date	94.09.22.16.29.19;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	94.08.09.13.51.32;	author daveb;	state Exp;
branches;
next	1.79;

1.79
date	94.08.01.08.27.34;	author daveb;	state Exp;
branches;
next	1.78;

1.78
date	94.07.29.11.49.40;	author daveb;	state Exp;
branches;
next	1.77;

1.77
date	94.07.26.11.11.58;	author daveb;	state Exp;
branches;
next	1.76;

1.76
date	94.07.26.10.17.07;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	94.07.25.15.01.59;	author daveb;	state Exp;
branches;
next	1.74;

1.74
date	94.06.22.15.11.04;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	94.06.21.16.22.26;	author daveb;	state Exp;
branches;
next	1.72;

1.72
date	94.06.06.12.49.00;	author nosa;	state Exp;
branches;
next	1.71;

1.71
date	94.05.12.15.04.29;	author daveb;	state Exp;
branches;
next	1.70;

1.70
date	94.05.06.16.28.38;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	94.03.25.17.13.16;	author daveb;	state Exp;
branches;
next	1.68;

1.68
date	94.03.18.14.27.28;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	94.03.15.17.05.25;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	94.02.28.06.50.16;	author nosa;	state Exp;
branches;
next	1.65;

1.65
date	94.02.25.15.51.23;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	94.02.01.16.46.15;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	94.01.28.16.21.35;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	94.01.26.17.59.52;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	94.01.10.14.21.44;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	93.12.15.13.42.20;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	93.11.22.14.59.14;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	93.10.05.10.13.49;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	93.09.03.10.45.37;	author nosa;	state Exp;
branches;
next	1.56;

1.56
date	93.09.02.17.08.14;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	93.08.16.11.38.08;	author daveb;	state Exp;
branches
	1.55.1.1;
next	1.54;

1.54
date	93.07.30.14.18.55;	author nosa;	state Exp;
branches;
next	1.53;

1.53
date	93.07.29.16.00.08;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	93.07.05.14.21.17;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	93.06.04.15.58.39;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	93.05.26.17.09.09;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	93.05.14.11.59.18;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	93.05.12.10.42.39;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	93.05.11.12.50.03;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	93.05.10.14.08.31;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	93.05.06.13.53.21;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	93.04.26.16.44.28;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	93.04.02.13.40.52;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	93.03.29.17.48.39;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	93.03.29.16.14.06;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	93.03.19.11.54.22;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	93.03.17.12.20.33;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	93.03.11.13.35.53;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	93.03.09.15.07.04;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	93.03.04.10.40.55;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	93.02.22.09.48.34;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.02.19.18.56.44;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	93.02.09.10.23.30;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.02.04.16.56.49;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	93.01.28.09.49.20;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	93.01.05.10.53.47;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	92.12.18.10.11.31;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.12.09.14.20.09;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.12.08.17.17.30;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.12.08.12.26.38;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	92.12.04.13.00.35;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	92.12.03.20.31.35;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	92.12.03.12.09.17;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.12.02.17.05.52;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	92.12.01.16.33.52;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	92.11.30.17.39.57;	author clive;	state Exp;
branches;
next	1.19;

1.19
date	92.11.26.19.20.59;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	92.11.26.17.23.16;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.11.23.09.32.52;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.11.20.16.22.48;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.11.19.09.55.47;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.11.18.17.44.14;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.11.17.17.35.16;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.11.11.17.52.16;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	92.10.26.15.43.48;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.10.22.09.39.13;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.10.16.11.23.40;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.10.14.15.10.24;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.10.08.11.43.52;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	92.10.08.08.54.00;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.10.07.16.17.05;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.10.06.15.52.44;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.10.06.10.38.37;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.10.02.07.40.32;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.10.01.17.26.19;	author richard;	state Exp;
branches;
next	;

1.55.1.1
date	93.08.16.11.38.08;	author jont;	state Exp;
branches;
next	1.55.1.2;

1.55.1.2
date	93.09.01.15.04.11;	author matthew;	state Exp;
branches;
next	;

1.128.1.1
date	96.09.13.11.16.04;	author hope;	state Exp;
branches;
next	;

1.128.2.1
date	96.10.07.16.06.08;	author hope;	state Exp;
branches;
next	;

1.128.3.1
date	96.10.17.11.24.24;	author hope;	state Exp;
branches;
next	;

1.130.1.1
date	96.11.14.12.49.07;	author hope;	state Exp;
branches
	1.130.1.1.1.1;
next	;

1.130.1.1.1.1
date	96.11.28.15.00.27;	author hope;	state Exp;
branches;
next	;

1.130.2.1
date	96.11.22.18.08.51;	author hope;	state Exp;
branches;
next	;

1.130.3.1
date	96.12.17.17.47.29;	author hope;	state Exp;
branches
	1.130.3.1.1.1;
next	;

1.130.3.1.1.1
date	97.02.24.11.37.13;	author hope;	state Exp;
branches;
next	;

1.130.4.1
date	96.12.18.09.41.29;	author hope;	state Exp;
branches;
next	;

1.132.1.1
date	97.05.12.10.33.56;	author hope;	state Exp;
branches;
next	1.132.1.2;

1.132.1.2
date	97.06.10.15.26.26;	author daveb;	state Exp;
branches
	1.132.1.2.1.1
	1.132.1.2.2.1
	1.132.1.2.3.1;
next	;

1.132.1.2.1.1
date	97.07.28.18.19.25;	author daveb;	state Exp;
branches
	1.132.1.2.1.1.1.1;
next	;

1.132.1.2.1.1.1.1
date	97.10.07.11.44.34;	author jkbrook;	state Exp;
branches;
next	;

1.132.1.2.2.1
date	97.09.08.17.13.01;	author daveb;	state Exp;
branches;
next	;

1.132.1.2.3.1
date	97.09.09.14.08.39;	author daveb;	state Exp;
branches;
next	;

1.137.1.1
date	97.09.10.19.23.57;	author brucem;	state Exp;
branches;
next	;

1.137.2.1
date	97.09.11.20.54.49;	author daveb;	state Exp;
branches;
next	1.137.2.2;

1.137.2.2
date	97.09.17.15.50.49;	author daveb;	state Exp;
branches;
next	1.137.2.3;

1.137.2.3
date	97.11.11.16.13.06;	author johnh;	state Exp;
branches;
next	1.137.2.4;

1.137.2.4
date	97.11.20.16.56.30;	author daveb;	state Exp;
branches;
next	1.137.2.5;

1.137.2.5
date	97.11.26.12.17.11;	author daveb;	state Exp;
branches;
next	1.137.2.6;

1.137.2.6
date	97.12.02.16.37.35;	author daveb;	state Exp;
branches;
next	1.137.2.7;

1.137.2.7
date	97.12.04.16.47.36;	author daveb;	state Exp;
branches;
next	;

1.143.1.1
date	99.04.01.17.56.50;	author daveb;	state Exp;
branches;
next	;


desc
@Incremental compiler.
Functor.
@


1.143
log
@[Bug #70240]
Change spec of Project.delete
@
text
@(*  ==== INCREMENTAL COMPILER ====
 *
 *  Copyright (C) 1996 The Harlequin Group Limited.  All rights reserved.
 *
 *  Implementation
 *  --------------
 *
 *  Revision Log
 *  ------------
 *  $Log: _incremental.sml,v $
 * Revision 1.142  1998/06/08  10:00:52  jont
 * [Bug #50071]
 * Fix compiler warning
 *
 * Revision 1.141  1998/05/07  09:20:02  mitchell
 * [Bug #50071]
 * Fix reset project to reread from the project file
 *
 * Revision 1.140  1998/04/24  15:49:25  mitchell
 * [Bug #30389]
 * Keep projects more in step with projfiles
 *
 * Revision 1.139  1998/01/29  16:16:18  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.137.2.7  1997/12/04  16:47:36  daveb
 * [Bug #30017]
 * Rationalised Shell/GUI Project commands:
 * Moved check_mo to ShellUtils, ditto for Project manipulation part of
 * load_mo.  Left the core part as load_mos, which loads all files in a list.
 *
 * Revision 1.137.2.6  1997/12/02  16:37:35  daveb
 * [Bug #30071]
 * Removed functions for loading from source files.
 *
 * Revision 1.137.2.5  1997/11/26  12:17:11  daveb
 * [Bug #30071]
 * match_{source,object}_path are no longer needed.
 *
 * Revision 1.137.2.4  1997/11/20  16:56:30  daveb
 * [Bug #30326]
 *
 * Revision 1.137.2.3  1997/11/11  16:13:06  johnh
 * [Bug #30203]
 * Merging - checking files to be recompiled.
 *
 * Revision 1.137.2.2  1997/09/17  15:50:49  daveb
 * [Bug #30071]
 * Converted build system to project workspace.
 *
 * Revision 1.137.2.1  1997/09/11  20:54:49  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.138  1997/09/17  15:49:11  brucem
 * [Bug #30203]
 * make check_mo and check_module return module ids.
 *
 * Revision 1.137  1997/05/28  08:56:42  johnh
 * [Bug #20033]
 * Pass extra arg to set_source_path to indicate -silent option.
 *
 * Revision 1.136  1997/05/21  17:09:25  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.135  1997/05/12  16:18:57  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
 * Revision 1.134  1997/05/02  16:55:26  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.133  1997/04/09  16:25:35  jont
 * [Bug #2040]
 * Make InterMake.load take an options argument
 *
 * Revision 1.132  1997/03/21  11:28:21  johnh
 * [Bug #1965]
 * Handling Io.NotSet for objectName.
 *
 * Revision 1.131  1997/02/11  18:13:05  daveb
 * Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
 * -- Changed name and type of Module.mo_name and Module.sml_name.
 *
 * Revision 1.130  1996/10/30  14:54:56  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.129  1996/10/25  14:41:08  andreww
 * [Bug #1686]
 * propagating change made to parserenv: type constructor environment
 * added to parser env, for datatype replication.
 *
 * Revision 1.128  1996/08/16  14:01:34  jont
 * [Bug #1553]
 * Make match_object_path convert .sml into .mo, rather than adding it
 *
 * Revision 1.127  1996/07/02  09:40:47  daveb
 * Bug 1448/Support Call 35: Added remove_file_info to project and incremental,
 * and called it from _save_image.
 *
 * Revision 1.126  1996/06/24  10:41:45  stephenb
 * Fix #1330 - Shell.File.loadObject doesn't look for .mo extension
 *
 * Revision 1.125  1996/06/21  12:28:35  stephenb
 * Out with the old in with the new -- replaced OldOS and Lists by OS and List
 * respectively.  This was done to simplify fixing #1330.
 *
 * Revision 1.124  1996/05/03  10:56:59  daveb
 * Improved error messages from match_source_path and match_object_path.
 *
 * Revision 1.123  1996/05/03  09:15:49  daveb
 * Ensured that all changes to the project update the global project, even
 * when errors occur.
 * Removed Error exception.
 *
 * Revision 1.122  1996/05/01  09:47:24  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.121  1996/04/16  14:59:15  daveb
 * Removed some extraneous debugging statements.
 *
 * Revision 1.120  1996/04/16  12:05:04  jont
 * Add a call to Compiler.make_external on the result of compiling a module
 * which has already been compiled but is not visible at top level.
 * Made the same fix for loading object files
 *
 * Revision 1.119  1996/04/02  11:37:05  daveb
 * Added read_dependencies.
 *
 * Revision 1.118  1996/03/27  11:43:08  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
 * Revision 1.117  1996/03/26  17:15:34  matthew
 * New field in VALdec
 *
 * Revision 1.116  1996/03/26  11:47:25  jont
 * Set the lambda environment after compilation of the builtin library correctly
 * Remove debugging messages when loading mo files
 *
 * Revision 1.115  1996/03/26  09:44:30  daveb
 * Added match_source_path and match_object_path, which do some of the work
 * that Module.with_source_path used to do, plus checking for attempts to use
 * different files with the same unit name.
 * Changed type of some other functions for use with these new ones.
 *
 * Revision 1.114  1996/03/19  16:33:09  matthew
 * Replace Map.merge by Map.union
 *
 * Revision 1.113  1996/03/19  12:18:25  daveb
 * Added check_mo.
 *
 * Revision 1.112  1996/03/19  10:34:27  daveb
 * When a module is up to date, add_module and load_mo no longer read the
 * signatures from the file on disk.  They use whatever info is stored in
 * the project.
 *
 * Revision 1.111  1996/03/19  10:20:10  daveb
 * Removed filename field from result type.
 *
 * Revision 1.110  1996/03/19  10:02:40  daveb
 * Made load_mo and add_module return NONE if the module is both up to date
 * and visible.
 *
 * Revision 1.109  1996/03/18  16:12:35  daveb
 * Changed implementation of identifiers_from_result to extract identifiers
 * from the type basis.
 *
 * Revision 1.108  1996/03/18  14:12:11  daveb
 * Added call to set object path from the environment.  This is needed for
 * the call to Project.reset_pervasives.
 *
 * Revision 1.107  1996/03/14  17:47:11  daveb
 * Added support for loading libraries that share compiler code.
 *
 * Revision 1.106  1996/03/14  16:19:38  daveb
 * Reduced amount of information stored in projects for loaded units.
 *
 * Revision 1.105  1996/03/04  14:57:08  daveb
 * Changed information stored in project for loaded compilation units.
 *
 * Revision 1.104  1996/02/27  13:43:35  daveb
 * Hid implementation of Project.Unit type.
 *
 * Revision 1.103  1996/02/23  17:54:32  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.102  1995/12/27  14:57:41  jont
 * Removing Option in favour of MLWorks.Option
 *
 *  Revision 1.101  1995/12/11  16:49:41  daveb
 *  Now passes debug info around as accumulated info instead of a basis.
 *
 *  Revision 1.100  1995/12/11  16:15:52  daveb
 *  Fixed propagation of debug information.
 *
 *  Revision 1.99  1995/12/11  15:18:12  daveb
 *  Reversing previous change.
 *
 *  Revision 1.98  1995/12/11  10:27:52  daveb
 *  Changed compilation of pervasives to generate debug_info.
 *
 *  Revision 1.97  1995/12/06  18:39:34  daveb
 *  Reinstated delete_module and delete_all_modules.
 *
 *  Revision 1.96  1995/11/29  14:39:33  daveb
 *  Modifications to use new project stuff.
 *
 *  Revision 1.95  1995/07/28  12:27:38  matthew
 *  Adding error handlers for load_file etc.
 *
 *  Revision 1.94  1995/07/13  12:01:20  matthew
 *  Moved identifier to Ident
 *
 *  Revision 1.93  1995/06/01  16:20:59  matthew
 *  Adding delete_all_modules
 *
 *  Revision 1.92  1995/05/11  13:48:49  matthew
 *  Removing crash function
 *
 *  Revision 1.91  1995/05/02  16:07:54  jont
 *  Make mo loading use object_path
 *
 *  Revision 1.90  1995/04/20  14:52:17  daveb
 *  Io.set_source_path_from_env now takes a location.
 *
 *  Revision 1.89  1995/03/30  13:22:32  matthew
 *  Replacing Tyfun_id etc. with Stamp
 *
 *  Revision 1.88  1995/03/06  11:47:19  daveb
 *  Merged identifier list with Result type.
 *
 *  Revision 1.87  1995/02/13  17:11:14  matthew
 *  Removing (some) stepper variables
 *
 *  Revision 1.86  1995/02/08  12:23:16  matthew
 *  Improvements to interface to typechecker
 *
 *  Revision 1.85  1995/01/30  16:13:05  daveb
 *  Removed horrible UNIX-dependent hack of module names.
 *
 *  Revision 1.84  1995/01/30  15:16:37  matthew
 *  Debugger changes
 *
 *  Revision 1.83  1995/01/16  17:32:33  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *
 *  Revision 1.82  1994/12/06  10:29:46  matthew
 *  Changing uses of cast
 *
 *  Revision 1.81  1994/09/22  16:29:19  matthew
 *  Change to Basis.lookup_val
 *
 *  Revision 1.80  1994/08/09  13:51:32  daveb
 *  Renamed SourceResult to Result, and made it a datatype with a record
 *  argument instead of a tuple.  Added a modules field for returning the
 *  updated modules table, which fixed a bug in the behaviour of make.
 *
 *  Revision 1.79  1994/08/01  08:27:34  daveb
 *  Moved preferences out of options structures.
 *
 *  Revision 1.78  1994/07/29  11:49:40  daveb
 *  Made load_mo return a SourceResult value.
 *
 *  Revision 1.77  1994/07/26  11:11:58  daveb
 *  Moved set_no_execute here from _shell_utils, so that add_module and
 *  check_module don't have to check that the option is set correctly.
 *
 *  Revision 1.76  1994/07/26  10:17:07  daveb
 *  Removed inter_env component of InterMake.Result type.
 *
 *  Revision 1.75  1994/07/25  15:01:59  daveb
 *  Changed add_module to return a SourceResult, so that it can be used to
 *  build both a full context and a delta context.  Took the no_execute
 *  functionality out of add_module and put it in a separate function
 *  (check_module).  Made some of the debugger code readable.
 *
 *  Revision 1.74  1994/06/22  15:11:04  jont
 *  Update debugger information production
 *
 *  Revision 1.73  1994/06/21  16:22:26  daveb
 *   Added empty context (initial contexts aren't empty).
 *  Changed Context components of Error and Interrupted exceptions to a set
 *  of new modules, so that the user_context can be updated appropriately.
 *  Added update_modules to aid this task.
 *
 *  Revision 1.72  1994/06/06  12:49:00  nosa
 *  Breakpoint settings on function exits.
 *
 *  Revision 1.71  1994/05/12  15:04:29  daveb
 *  Basis.lookup_val now takes an extra argument.
 *  Also added a sharing constraint.
 *
 *  Revision 1.70  1994/05/06  16:28:38  jont
 *  Add function to give parser basis from source result
 *
 *  Revision 1.69  1994/03/25  17:13:16  daveb
 *  Changed add_module and delete_module and load_mo to take ModuleIds.
 *
 *  Revision 1.68  1994/03/18  14:27:28  matthew
 *  Added add_debug_info
 *  add_module returns a file list
 *
 *  Revision 1.67  1994/03/15  17:05:25  matthew
 *  Put load_time back in InterMake.Result
 *
 *  Revision 1.66  1994/02/28  06:50:16  nosa
 *  Debugger environments for Modules Debugger.
 *
 *  Revision 1.65  1994/02/25  15:51:23  daveb
 *  Adding clear_debug functionality.
 *
 *  Revision 1.64  1994/02/01  16:46:15  daveb
 *  _add_module now takes a Module argument instead of a file name.
 *
 *  Revision 1.63  1994/01/28  16:21:35  matthew
 *  Better locations in error messages
 *
 *  Revision 1.62  1994/01/26  14:47:40  matthew
 *  Numerous changes and simplifications:
 *  Removed load_time
 *  Made various accumulators refs within make
 *  Simplified interface to compiler.
 *
 *  Revision 1.61  1994/01/10  14:21:44  matthew
 *  Added function for loading an mo file.
 *
 *  Revision 1.60  1993/12/15  13:42:20  matthew
 *  Added level field to Basis.
 *
 *  Revision 1.59  1993/11/22  14:59:14  jont
 *  Changed use of runtime system modules to remove the time stamp field
 *
 *  Revision 1.58  1993/10/05  10:13:49  jont
 *  Changes to do with remembering whether compilations are of pervasives
 *
 *  Revision 1.57  1993/09/03  10:45:37  nosa
 *  lookup_val now returns runtime_instance for polymorphic debugger.
 *
 *  Revision 1.56  1993/09/02  17:08:14  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.55.1.2  1993/09/01  15:04:11  matthew
 *  Simplified debugger interface to InterMake.make
 *  Use InterMake.with_debug_info to set the debug information for the debugger
 *
 *  Revision 1.55  1993/08/16  11:38:08  daveb
 *  Changes to support moduleids and reflect changes to Io signature.
 *
 *  Revision 1.54  1993/07/30  14:18:55  nosa
 *  structure Option.
 *
 *  Revision 1.53  1993/07/29  16:00:08  matthew
 *  Changed Info.default_options to Info.make_default_options, which creates a new
 *  options object.
 *  Added Interrupted exceptions and handlers.
 *
 *  Revision 1.52  1993/07/05  14:21:17  daveb
 *  Removed exception environments.
 *
 *  Revision 1.51  1993/06/04  15:58:39  daveb
 *  Deleted the name component of the context type.
 *
 *  Revision 1.50  1993/05/26  17:09:09  matthew
 *  Changes to Error handling
 *
 *  Revision 1.49  1993/05/14  11:59:18  jont
 *  Added Crash parameter to functor parameter
 *
 *  Revision 1.48  1993/05/12  10:42:39  matthew
 *  Added is_an_expression function
 *
 *  Revision 1.47  1993/05/11  12:50:03  matthew
 *  Added error_list to Error exception
 *
 *  Revision 1.46  1993/05/10  14:08:31  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *
 *  Revision 1.45  1993/05/06  13:53:21  matthew
 *  add_module takes an explicit monitor function argument
 *
 *  Revision 1.44  1993/04/26  16:44:28  jont
 *  Added code to remove FullPervasiveLibrary_ from initial environment
 *
 *  Revision 1.43  1993/04/02  13:40:52  matthew
 *  Added evaluate_exp_topdec
 *
 *  Revision 1.42  1993/03/29  17:48:39  matthew
 *  removed string parameter from debugger function
 *
 *  Revision 1.41  1993/03/29  16:14:06  jont
 *  Removed get_pervasive_dir, using one in io instead
 *
 *  Revision 1.40  1993/03/19  11:54:22  matthew
 *  Removed add_source which is split up into compile_source and add_definitions
 *
 *  Revision 1.39  1993/03/17  12:20:33  matthew
 *  Added parserbasis field to Compiler.TOPDEC source
 *
 *  Revision 1.38  1993/03/11  13:35:53  matthew
 *  Simplified debugger function
 *  Signature revisions
 *
 *  Revision 1.37  1993/03/09  15:07:04  matthew
 *  Options & Info changes
 *  Changed options type
 *
 *  Revision 1.36  1993/03/04  10:40:55  daveb
 *  Added newlines to build messages.
 *
 *  Revision 1.35  1993/02/22  09:48:34  matthew
 *  Added code to update parser environment when adding a structure to a context.
 *
 *  Revision 1.34  1993/02/19  18:56:44  jont
 *  Fixed sharing problem between Option and InterMake.FileName.Option
 *
 *  Revision 1.33  1993/02/09  10:23:30  matthew
 *  Typechecker structure changes
 *
 *  Revision 1.32  1993/02/04  16:56:49  matthew
 *  Signature Changes.
 *
 *  Revision 1.31  1993/01/28  09:49:20  jont
 *  Changed default make options to turn off debug, tracing and profiling
 *
 *  Revision 1.30  1993/01/05  10:53:47  jont
 *  Modified to deal with new code printing options
 *
 *  Revision 1.29  1992/12/18  10:11:31  clive
 *  We also pass the current module forward for the source_displayer
 *
 *  Revision 1.28  1992/12/09  14:20:09  clive
 *  Changes propagated from the lower levels
 *
 *  Revision 1.27  1992/12/08  17:17:30  clive
 *  Added find_module for the source_displayer
 *
 *  Revision 1.26  1992/12/08  12:26:38  daveb
 *  Removed some sharing constraints.
 *
 *  Revision 1.25  1992/12/04  13:00:35  richard
 *  Added module list parameter to make of pervasive files.
 *
 *  Revision 1.24  1992/12/03  20:31:35  daveb
 *  Changes to support the PERVASIVE_DIR Unix environment variable.
 *  Removed a sharing constraint.
 *
 *  Revision 1.23  1992/12/03  12:09:17  clive
 *  Added the delete_module function
 *
 *  Revision 1.22  1992/12/02  17:05:52  daveb
 *  Changes to propagate compiler options as parameters instead of references.
 *
 *  Revision 1.21  1992/12/01  16:33:52  matthew
 *  Added a comment.
 *
 *  Revision 1.20  1992/11/30  17:39:57  clive
 *  Debugger now takes a more up-to-date environment
 *
 *  Revision 1.19  1992/11/26  19:20:59  daveb
 *  Changes to make show_id_class and show_eq_info part of Info structure
 *  instead of references.
 *
 *  Revision 1.18  1992/11/26  17:23:16  clive
 *  Added clear_debug_info function
 *
 *  Revision 1.17  1992/11/23  09:32:52  clive
 *  Dealt with the fact that the code slot is now optional (we can throw it away
 *  after loading)
 *
 *  Revision 1.16  1992/11/20  16:22:48  jont
 *  Modified sharing constraints to remove superfluous structures
 *
 *  Revision 1.15  1992/11/19  09:55:47  clive
 *  Changed intermake to wrap a debugger around the loading operation
 *
 *  Revision 1.14  1992/11/18  17:44:14  matthew
 *  More Error -> Info revision
 *
 *  Revision 1.13  1992/11/17  17:35:16  matthew
 *  Changed Error structure to Info
 *
 *  Revision 1.12  1992/11/11  17:52:16  daveb
 *  Added env function to extract th environment from a context.
 *
 *  Revision 1.11  1992/10/26  15:43:48  clive
 *  Got exit working, and passed through enough for debugger to bind frame arguments to it
 *  on invoking a sub-shell
 *
 *  Revision 1.10  1992/10/22  09:39:13  richard
 *  Added make options as distinct from compiler options.
 *  Dealt with a make error which might return a partially updated module table.
 *
 *  Revision 1.10  1992/10/20  14:09:15  richard
 *  Added make options as distinct from compiler options.
 *  Dealt with a make error which might return a partially updated module table.
 *
 *  Revision 1.9  1992/10/16  11:23:40  clive
 *  Changes for windowing listener
 *
 *  Revision 1.8  1992/10/14  15:10:24  richard
 *  Incorporated the make system.
 *
 *  Revision 1.7  1992/10/08  11:43:52  richard
 *  Changed add_topdec to add_source of compiler source type.
 *
 *  Revision 1.6  1992/10/08  08:54:00  richard
 *  Added return of identifiers from add_value and add_structure.
 *
 *  Revision 1.5  1992/10/07  16:17:05  richard
 *  The incremental compiler now uses the generalised Compiler structure.
 *
 *  Revision 1.4  1992/10/06  15:52:44  richard
 *  Removed inadequate add_source_file.
 *
 *  Revision 1.3  1992/10/06  10:38:37  clive
 *  Change to NewMap.empty which now takes < and = functions instead of the single-function
 *
 *  Revision 1.2  1992/10/02  07:40:32  richard
 *  add_topdec was returning the wrong context.
 *
 *  Revision 1.1  1992/10/01  17:26:19  richard
 *  Initial revision
 *
 *)

require "^.basis.list";
require "^.basis.__text_io";

require "../utils/diagnostic";
require "../utils/crash";
require "../basics/module_id";
require "../main/project";
require "../main/proj_file";
require "../main/encapsulate";
require "../lambda/environ";
require "../typechecker/basis";
require "../typechecker/stamp";
require "../lexer/lexer";
require "../parser/parserenv";
require "../main/mlworks_io";
require "interload";
require "intermake";
require "incremental";

functor Incremental
  (structure Environ : ENVIRON
   structure InterLoad : INTERLOAD
   structure InterMake : INTERMAKE
   structure Basis : BASIS
   structure Stamp : STAMP
   structure Lexer : LEXER
   structure ParserEnv : PARSERENV
   structure List : LIST
   structure Diagnostic : DIAGNOSTIC
   structure Io : MLWORKS_IO
   structure ModuleId : MODULE_ID
   structure Project : PROJECT
   structure ProjFile : PROJ_FILE
   structure Encapsulate : ENCAPSULATE
   structure Crash : CRASH

   sharing Environ.EnvironTypes = InterMake.Inter_EnvTypes.EnvironTypes
   sharing InterLoad.Inter_EnvTypes = InterMake.Inter_EnvTypes
   sharing ParserEnv.Map = Basis.BasisTypes.Datatypes.NewMap
   sharing ParserEnv.Ident = Basis.BasisTypes.Datatypes.Ident =
	   InterMake.Compiler.Absyn.Ident =
	   Environ.EnvironTypes.LambdaTypes.Ident
   sharing Environ.EnvironTypes.NewMap = Basis.BasisTypes.Datatypes.NewMap =
	   InterMake.Compiler.NewMap
   sharing ParserEnv.Ident.Location = InterMake.Compiler.Info.Location
   sharing InterMake.Compiler.Info = Project.Info

   sharing type Project.Project = InterMake.Project
   sharing type InterMake.Compiler.Module = InterLoad.Module
   sharing type Environ.Structure = Basis.BasisTypes.Datatypes.Structure
   sharing type Environ.EnvironTypes.LambdaTypes.Type =
		Basis.BasisTypes.Datatypes.Type
   sharing type InterMake.Compiler.TypeBasis = Basis.BasisTypes.Basis
   sharing type Lexer.TokenStream = InterMake.Compiler.tokenstream
   sharing type InterMake.Compiler.ParserBasis = ParserEnv.pB
   sharing type Io.ModuleId = Project.ModuleId =
		InterMake.ModuleId = ModuleId.ModuleId
   sharing type InterMake.Compiler.DebuggerEnv =
		Environ.EnvironTypes.DebuggerEnv
   sharing type ParserEnv.Ident.Location.T = ModuleId.Location = Io.Location
   sharing type Basis.BasisTypes.Datatypes.Stamp = Stamp.Stamp
   sharing type Basis.BasisTypes.Datatypes.StampMap = Stamp.Map.T
   sharing type InterMake.Compiler.basis = Project.CompilerBasis
   sharing type InterMake.Compiler.id_cache = Project.IdCache
) : INCREMENTAL =
  struct
    structure Compiler = InterMake.Compiler
    structure PE = ParserEnv
    structure Lexer = Lexer
    structure Info = Compiler.Info
    structure EnvironTypes = Environ.EnvironTypes
    structure BasisTypes = Basis.BasisTypes
    structure Datatypes = BasisTypes.Datatypes
    structure Map = Datatypes.NewMap
    structure Diagnostic = Diagnostic
    structure Absyn = Compiler.Absyn
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure LambdaTypes = EnvironTypes.LambdaTypes
    structure Inter_EnvTypes = InterMake.Inter_EnvTypes
    structure InterMake = InterMake
    structure Options = Inter_EnvTypes.Options

    type ModuleId = ModuleId.ModuleId

    val empty_compiler_basis =
      case InterMake.Compiler.initial_basis of
        InterMake.Compiler.BASIS
          {parser_basis,
           type_basis,
           lambda_environment,
           debugger_environment,
           debug_info} =>
      InterMake.Compiler.BASIS
        {parser_basis = ParserEnv.empty_pB,
         type_basis = type_basis,
         lambda_environment = lambda_environment,
         debugger_environment = debugger_environment,
         debug_info = debug_info}

    fun diagnostic (level, output_function) =
      Diagnostic.output level
      (fn verbosity => "Incremental: " :: (output_function verbosity))

    fun diagnostic_fn (level, output_function) =
      Diagnostic.output_fn level
      (fn (verbosity, stream) => (TextIO.output (stream, "Incremental: ");
				  output_function (verbosity, stream)))

    fun fatality (location, message) =
      Info.error'
      (Info.make_default_options ())
      (Info.FATAL, location, message)

    datatype Context =
      CONTEXT of {topdec		: int,
                  compiler_basis	: Compiler.basis,
                  inter_env		: Inter_EnvTypes.inter_env,
                  signatures		: (Ident.SigId, Absyn.SigExp) Map.map}

    datatype options =
      OPTIONS of
      {options	        : Options.options,
       debugger		: (MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T) ->
                          (MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T)}

    val default_error_info = Info.make_default_options ()


    val cast = MLWorks.Internal.Value.cast

    (*  === THE INITIAL CONTEXT ===  *)

    (* When we apply _incremental, it sets up the builtin and pervasive
       libraries.  This involves assorted low-level hackery.  The type
       bases are obtained by compiling the files.  The actual code is
       obtained from the run-time. *)

    (* First set the relevant global values. *)

    (* The boolean parameter refers to whether the -silent option was specified, 
     * but this is not needed here. *)
    val _ = Io.set_source_path_from_env
		((Info.Location.FILE "Initial Context"), false);
    val _ = Io.set_object_path_from_env
		(Info.Location.FILE "Initial Context");

    val _ = Stamp.reset_counter Basis.pervasive_stamp_count

    type register_key = int
    val key_count = ref 0;
    val register_map = ref (Map.empty' (op< : int * int -> bool))

    fun add_update_fn f =
      (key_count := !key_count + 1;
       register_map := Map.define (!register_map, !key_count, f);
       !key_count)

    fun remove_update_fn c =
      register_map := Map.undefine (!register_map, c)


    (**********************
      This is the global project, used by the all versions and instances
      of the interpreter build system.
      All functions in this file should ensure that this is up to date,
      including cases when they raise exceptions.
     **********************)

    val inf_loc = (default_error_info, Info.Location.FILE "_incremental");

    val project =
      ref (Project.initialize inf_loc);

    fun set_project p =
      (project := p;
       Map.iterate (fn (_, f) => f()) (!register_map))

    fun get_project () = 
      if ProjFile.changed()
      then 
	let val p = Project.fromFileInfo inf_loc (!project)
         in project := p; p 
        end
      else
        !project
      
    fun delete_from_project m =
      set_project (Project.delete (!project, m, true))

    local
      val _ = diagnostic_fn (0, fn (_, stream) =>
				TextIO.output (stream, "making the builtin library\n"))

      val runtime_modules =
	map (fn (str, value, _) => (str, value))
	    (!MLWorks.Internal.Runtime.modules)

      (* Now recompile the built-in library. *)
      val (builtin_library_result, builtin_module, _) =
	InterMake.compile
	  (fn y => y)
	  (Compiler.initial_basis_for_builtin_library, Inter_EnvTypes.empty_env)
	  (default_error_info,
	   Info.Location.FILE "Making BuiltIn Library",
	   Options.default_options)
	  (SOME runtime_modules)
	  (!project, Io.builtin_library_id, 
	   Compiler.get_basis_debug_info
	     Compiler.initial_basis_for_builtin_library)

      (* Now munge the result to set the lambda environment to the built-in
	 lambda environment.  This would be simpler if SML supported
	 record updating. *)
      val debugger_environment =
        case Project.get_loaded_info
 	       (!project, Io.builtin_library_id)
	of NONE =>
	  Crash.impossible "Can't find loaded information for builtin library"
	|  SOME {file_time, load_time, basis, id_cache, module, dependencies} =>
	  let
            val Compiler.BASIS
		  {parser_basis, type_basis, debugger_environment, debug_info,
		   ...} = basis

	    val new_basis =
              Compiler.BASIS
                {parser_basis = parser_basis,
		 type_basis = type_basis,
                 debug_info = debug_info,
                 lambda_environment = Compiler.builtin_lambda_environment,
                 debugger_environment = debugger_environment}
	  in
            Project.set_loaded_info
              (!project,
               Io.builtin_library_id,
               SOME
		 {file_time = file_time,
		  load_time = load_time,
		  id_cache = id_cache,
		  basis = new_basis,
		  module = module,
		  dependencies = dependencies});
	    debugger_environment
	  end

      (* Now do the same thing for the pervasive library.  Begin by
	 getting the list of dependencies from the project. *)
      val _ =
	diagnostic_fn (0, fn (_, stream) =>
			  TextIO.output (stream, "making the pervasive library\n"))

      val out_of_date =
	Project.check_perv_loaded
	  (default_error_info,
	   Info.Location.FILE "Making Pervasive Library")
	  (!project)

      fun compile_perv (module_id, (_, _, accumulated_info)) =
	(* returns (compiler_result, module, accumulated_info') *)
	  InterMake.compile
	    (fn y => y)
	    (Compiler.initial_basis, Inter_EnvTypes.empty_env)
	    (default_error_info,
	     Info.Location.FILE "Making Pervasive Library",
	     Options.default_options)
	    (SOME runtime_modules)
	    (!project, module_id, accumulated_info)

      val (pervasive_library_result, pervasive_module, _) =
	(* The builtin_library_result and builtin_module are used here as
	   dummy values. *)
	List.foldl
	  compile_perv
	  (builtin_library_result, builtin_module,
	   Compiler.get_basis_debug_info Compiler.initial_basis)
	   out_of_date
	
      val Compiler.RESULT {basis, signatures, ...} =
        pervasive_library_result

      val Compiler.BASIS {lambda_environment, parser_basis, ...} = basis

        (* we need to propagate the parser type constructor environment
           out of the pervasive library into the main basis.  Otherwise
           we won't be able to replicated pervasive datastructures. *)

      val ParserEnv.B(_,_,ParserEnv.E(_,_,pervasive_pTE,_)) = parser_basis

      val inter_env =
        Inter_EnvTypes.augment_with_module
          (Inter_EnvTypes.empty_env, lambda_environment, pervasive_module)
        handle Inter_EnvTypes.Augment =>
          Crash.impossible "Module does not match generated environment"

      val strid = Ident.STRID(Symbol.find_symbol "FullPervasiveLibrary_")

      val inter_env = Inter_EnvTypes.remove_str(inter_env, strid)
    in
      val initial_basis =
        let
          val Compiler.BASIS{parser_basis,
                             type_basis,
                             lambda_environment,
			     debug_info,
                             ...} = Compiler.initial_basis

          val augmented_parser_basis =
               ParserEnv.augment_pB
               (ParserEnv.B(ParserEnv.empty_pF,
                            ParserEnv.empty_pG,
                            ParserEnv.E(ParserEnv.empty_pFE,
                                        ParserEnv.empty_pVE,
                                        pervasive_pTE,
                                        ParserEnv.empty_pSE)),
               parser_basis)
        in
          Compiler.BASIS{parser_basis=augmented_parser_basis,
                         type_basis=type_basis,
                         lambda_environment=lambda_environment,
                         debugger_environment=debugger_environment,
                         debug_info=debug_info}
        end

      val basis = Compiler.remove_str(basis, strid)

      val initial_compiler_basis =
        Compiler.make_external
	  (Compiler.augment (Options.default_options, initial_basis, basis))

      val initial_inter_env = inter_env

      val initial =
        CONTEXT {topdec = 0,
                 compiler_basis = initial_compiler_basis,
                 inter_env = inter_env,
                 signatures = signatures}
    end

    (* The following call removes all information about the pervasive files
       from the project, leaving only the information about the loaded
       modules.  This enables batch compilation using a different set of
       pervasives.  *)
    val _ = Project.reset_pervasives (!project)

    fun clear_debug_all_info
	  (CONTEXT {compiler_basis, topdec, inter_env, signatures}) =
      CONTEXT{topdec=topdec, 
              inter_env=inter_env,
              signatures=signatures, 
              compiler_basis = Compiler.clear_debug_all_info compiler_basis}
      
    fun clear_debug_info
	  (name,
	   CONTEXT {compiler_basis, topdec, inter_env, signatures}) =
      CONTEXT{topdec=topdec, 
              inter_env=inter_env,
              signatures=signatures, 
              compiler_basis =
		Compiler.clear_debug_info (name, compiler_basis)}

    fun add_debug_info
	  (options, debug_info,
	   CONTEXT {compiler_basis, topdec, inter_env, signatures}) =
      CONTEXT{topdec=topdec, 
              inter_env=inter_env,
              signatures=signatures, 
              compiler_basis =
              Compiler.add_debug_info
		(options, debug_info, compiler_basis)}

    fun topdec (CONTEXT record) = #topdec record
    fun compiler_basis (CONTEXT record) = #compiler_basis record
    fun parser_basis (CONTEXT {compiler_basis =
       Compiler.BASIS {parser_basis, ...}, ...}) = parser_basis
    fun type_basis (CONTEXT {compiler_basis = Compiler.BASIS {type_basis, ...}, ...}) = type_basis
    fun lambda_environment (CONTEXT {compiler_basis = Compiler.BASIS {lambda_environment, ...}, ...}) = lambda_environment
    fun debug_info (CONTEXT {compiler_basis = Compiler.BASIS {debug_info, ...}, ...}) = debug_info
    fun inter_env (CONTEXT record) = #inter_env record
    fun signatures (CONTEXT record) = #signatures record

    val empty_context =
      CONTEXT
	{topdec = 0,
	 compiler_basis = InterMake.Compiler.empty_basis,
	 inter_env = Inter_EnvTypes.empty_env,
	 signatures = Map.empty' Ident.sigid_lt}

    (* The result type for compile_source and load_mo; pass to
       add_definitions to extend a context.  delta_basis and delta_signatures
       contain the definitions from the compiled source or mo file.
       new_module is a new loaded module. *)

    datatype Result = 
      RESULT of
        {delta_basis: Compiler.basis,
         delta_signatures: (Ident.SigId,Absyn.SigExp) Map.map,
         new_module: MLWorks.Internal.Value.T}

    val empty_signatures = Map.empty' Datatypes.Ident.sigid_lt

    fun identifiers_from_result
        (RESULT {delta_basis = Compiler.BASIS {type_basis, ...}, ...}) =
      Compiler.extract_identifiers ([], type_basis)

    fun pb_from_result
	  (RESULT {delta_basis = Compiler.BASIS {parser_basis, ...}, ...}) =
      parser_basis

    (*  === COMPILE SOURCE CODE INTO A CONTEXT ===  *)

    fun compile_source
      error_info
      (inc_options as OPTIONS {options,debugger,...},
       (CONTEXT {compiler_basis, inter_env, ...}),
       source) =
      let
        val filename =
          case source of
            Compiler.TOKENSTREAM token_stream => Lexer.associated_filename token_stream
          | Compiler.TOKENSTREAM1 token_stream => Lexer.associated_filename token_stream
          | Compiler.TOPDEC (filename,_,_) => filename

        val _ = diagnostic_fn
          (2, fn (_, stream) =>
           (TextIO.output (stream, "Compiling topdec from ");
            TextIO.output (stream, filename)))

        val (_, Compiler.RESULT {basis = topdec_compiler_basis,
                                 signatures = aug_signatures,
                                 id_cache,
                                 code}) =
          Compiler.compile
          (error_info, options)
          (fn (_, _, location) =>
           Info.error'
           error_info
           (Info.FATAL, location, "require used at top level")
           (* maybe this should generate a warning, not an error *)
           )
          ((), compiler_basis, false)
          (false, source)

        (* Replace the values bound in the lambda environment with *)
        (* external references. *)

        val aug_compiler_basis = Compiler.make_external topdec_compiler_basis

        val Compiler.BASIS{debug_info,...} =
	  Compiler.augment (options, compiler_basis, topdec_compiler_basis)

        (* Create a callable function from the generated code and invoke it, *)
        (* giving an untyped module. *)
        val module =
          let
            fun module_map module_name =
	      case Project.get_loaded_info
		     (!project,
		      ModuleId.from_mo_string
		        (module_name, Info.Location.UNKNOWN))
	      of SOME {module, ...} => module
	      |  NONE =>
		Crash.impossible
		  ("can't find module " ^ module_name ^ " in project")
          in
            case code of
              NONE =>
                Info.error'
                error_info
                (Info.FAULT, Info.Location.FILE filename,
                 concat ["`", filename, "' database entry has no code recorded. "])
            | SOME code' => 
                InterMake.with_debug_information
                debug_info
                (fn () =>
                 InterLoad.load
                 debugger
                 (inter_env, module_map)
                 code')
          end
      in
        RESULT
	  {delta_basis = aug_compiler_basis,
 	   delta_signatures = aug_signatures,
	   new_module = module}
      end

    exception NotAnExpression

    fun evaluate_exp_topdec error_info (inc_options,context,topdec) =
      let
        open Absyn
        fun is_an_expression (STRDECtopdec (strdec,_)) =
          (case strdec of
             (DECstrdec (VALdec ([(pat,_,_)],[],_,_))) =>
               (case pat of
                  VALpat ((valid,_),_) =>
                    (case valid of
                       Ident.LONGVALID (Ident.NOPATH,Ident.VAR sym) =>
                         Symbol.symbol_name sym = "it"
                     | _ => false)
                | _ => false)
           | _ => false)
          | is_an_expression _ = false
      in 
        if not(is_an_expression topdec)
          then raise NotAnExpression
        else
          let
            val (RESULT {delta_basis, new_module, ...}) =
              compile_source
              error_info
              (inc_options,
               context,
               Compiler.TOPDEC("",topdec,PE.empty_pB))
            val Compiler.BASIS{type_basis,...} = delta_basis
            val ittype = #1(Basis.lookup_val (Ident.LONGVALID (Ident.NOPATH,Ident.VAR(Symbol.find_symbol"it")),
                                              Basis.basis_to_context type_basis,
                                              Info.Location.UNKNOWN,
                                              false))
            val val_list : MLWorks.Internal.Value.T list = cast new_module
          in
            case val_list of
              [itval] => (itval,ittype)
            | _ => Crash.impossible "Wrong number of bindings in evaluate_exp_topdec"
          end
      end

    fun add_definitions
	  (options,
	   CONTEXT{topdec, compiler_basis, signatures, inter_env, ...},
           RESULT
	     {delta_basis, delta_signatures, new_module, ...}) =
      let
        val new_compiler_basis =
	  Compiler.augment (options, compiler_basis, delta_basis)

        val new_signatures =
	  Map.union (signatures, delta_signatures)

        (* Incorporate the results of the loading into the interpreter *)
        (* environment to form the result context. *)
        val new_inter_env =
          let
            val Compiler.BASIS {lambda_environment, ...} = delta_basis
          in
            Inter_EnvTypes.augment_with_module
	      (inter_env, lambda_environment, new_module)
            handle Inter_EnvTypes.Augment =>
              Crash.impossible "Module does not match generated environment"
          end
      in
        CONTEXT {topdec = topdec+1,
                 compiler_basis = new_compiler_basis,
                 signatures = new_signatures,
                 inter_env = new_inter_env}
      end

   fun load_mos
         error_info
         (options, CONTEXT {compiler_basis, ...}, project,
          moduleid, mod_id_list, location) =
     (* mod_id_list is a list of modules to be loaded.
	module_id is the "top-level" one, which must be made visible.  *)
     let
       fun load_one (module_id, _) =
         SOME (InterMake.load
               options
               (project, location)
               module_id)
     in
       case List.foldl load_one NONE mod_id_list
       of SOME (compiler_result, new_module) =>
         let
           val result =
             case compiler_result
             of Compiler.RESULT
                  {basis = new_basis, signatures = new_signatures, ...} =>
               RESULT
                 {delta_basis = Compiler.make_external new_basis,
                  delta_signatures = new_signatures,
                  new_module = new_module}
         in
           Project.set_visible (project, moduleid, true);
           SOME result
         end
       |  NONE =>
         (* For this case to be reached, mod_id_list must be empty.
            We need to get the previously compiled module and basis,
            and compile the current file to get the signature
            field of the result value. *)
	 (* XXX we don't seem to compile the file after all? 
	    daveb 3/12/97 *)
         if Project.is_visible (project, moduleid) then
           NONE
         else
           case Project.get_loaded_info (project, moduleid)
           of SOME {basis, id_cache, module, ...} =>
             let
               val _ = Project.set_visible (project, moduleid, true);

               val result =
                 RESULT
                   {delta_basis = Compiler.make_external basis,
                    delta_signatures = empty_signatures,
                    new_module = module}
             in
               SOME result
             end
           |  NONE =>
             Crash.impossible "impossible NONE returned in Incremental.load.mos"
      end

    fun delete_module error_info module_id =
      Project.set_loaded_info (!project, module_id, NONE)

    fun delete_all_modules true =
      Project.clear_all_loaded_info (!project, not o ModuleId.is_pervasive)
    |   delete_all_modules false =
      Project.clear_all_loaded_info (!project, fn _ => true)

    fun remove_file_info () = Project.remove_file_info (!project)

    (* The name here should be consistent with the one used in _lambda *)
    (* Should be defined in a common module really *)
    val overload_var =
      Ident.VAR (Ident.Symbol.find_symbol "<overload function>")

    fun read_dependencies toplevel_name error_info module_id =
      project :=
        (#1 (Project.read_dependencies
               (error_info, Info.Location.FILE toplevel_name)
               (!project, module_id, Project.empty_map)))

    fun check_module error_info (module_id, toplevel_name) =
      let
	val _ =
	  diagnostic
	    (2, fn _ =>
		  ["Checking load source `", ModuleId.string module_id, "'"])

        val (new_project, _) =
	  Project.read_dependencies
	    (error_info, Info.Location.FILE toplevel_name)
	    (!project, module_id, Project.empty_map)

	val _ = set_project new_project

	val module_ids =
	  Project.check_load_source
	    (error_info, Info.Location.FILE toplevel_name)
	    (new_project, module_id)
      in
	module_ids
      end

    (* This currently isn't used -- but I want to keep it around in case
       we resurrect the preloading code.
    fun add_module'
	  preloaded
	  error_info
	  (OPTIONS {options, debugger, ...})
          (CONTEXT {compiler_basis, inter_env, ...}, moduleid, toplevel_name) =
      let
        val _ =
	  diagnostic
	    (2, fn _ =>
		  ["Adding make module `", ModuleId.string moduleid, "'"])

	val generate_moduler =
	  case options
	  of Options.OPTIONS
	       {compiler_options =
		  Options.COMPILEROPTIONS {generate_moduler, ...},
		...} => generate_moduler

        (* Here we set up overload_var for the generate_moduler case *)
        val initial_compiler_basis as Compiler.BASIS
	      {parser_basis, type_basis, lambda_environment,
	       debugger_environment, debug_info} =
	  if generate_moduler then
            let
              val Compiler.BASIS
		    {parser_basis, type_basis, lambda_environment,
                     debugger_environment, debug_info} =
		initial_compiler_basis
            in
              Compiler.BASIS
		{parser_basis=parser_basis,
                 type_basis=type_basis,
                 lambda_environment =
		   Environ.augment_top_env
		     (lambda_environment,
                      EnvironTypes.TOP_ENV
			(Environ.add_valid_env
			   (Environ.empty_env,
			    (overload_var, EnvironTypes.EXTERNAL)),
			 Environ.empty_fun_env)),
                 debugger_environment=debugger_environment,
                 debug_info=debug_info}
            end
          else
	    initial_compiler_basis 

	val initial_inter_env =
          if generate_moduler then
            Inter_EnvTypes.add_val
	      (initial_inter_env,
               (overload_var,
                Inter_EnvTypes.lookup_val (overload_var,inter_env)))
            (* Catch overload_var not being defined *)
            handle Map.Undefined =>
	      Crash.impossible "<overload function> not defined"
          else 
	    initial_inter_env
 
        val (new_project, _) =
	  Project.read_dependencies
	    (error_info, Info.Location.FILE toplevel_name)
	    (!project, moduleid, Project.empty_map)

	val _ = set_project new_project

        val out_of_date =
	  Project.check_load_source
	    (error_info, Info.Location.FILE toplevel_name)
	    (new_project, moduleid)

        fun compile_one (module_id, NONE) =
	  (* NONE => first call.  Use initial compiler_basis. *)
	  SOME (InterMake.compile
	          debugger
	            (initial_compiler_basis, initial_inter_env)
	            (error_info,
		     Info.Location.FILE toplevel_name, options)
	            preloaded
	            (new_project, module_id,
		     Compiler.get_basis_debug_info compiler_basis))
        |   compile_one (module_id, SOME (_, _, accumulated_info)) =
	  SOME (InterMake.compile
	          debugger
	            (initial_compiler_basis, initial_inter_env)
	            (error_info, 
		     Info.Location.FILE toplevel_name,
		     options)
	            preloaded
	            (new_project, module_id, accumulated_info))

        val result =
	  case List.foldl compile_one NONE out_of_date
	  of SOME 
	       (compiler_result, new_module, accumulated_info) =>
	    let
	      val result =
	        case compiler_result
	        of Compiler.RESULT
	             {basis = new_basis, signatures = new_signatures, ...} =>
	          RESULT
	            {delta_basis =
	               Compiler.make_external
		         (Compiler.adjust_compiler_basis_debug_info
		            (new_basis, accumulated_info)),
	             delta_signatures = new_signatures,
	             new_module = new_module}
	    in
	      Project.set_visible (new_project, moduleid, true);
	      SOME result
	    end
	  |  NONE =>
            (* For this case to be reached, out_of_date must be empty.
               We need to get the previously compiled module and basis,
               and compile the current file to get the signature
               field of the result value. *)
	    if Project.is_visible (new_project, moduleid) then
	      NONE
	    else
	      case Project.get_loaded_info (new_project, moduleid)
	      of SOME {basis, module, ...} =>
	        let
	          val result =
	            RESULT
	              {delta_basis = Compiler.make_external basis,
	               delta_signatures = empty_signatures,
	               new_module = module}
	        in
	          Project.set_visible (new_project, moduleid, true);
	          SOME result
	        end
	      |  NONE => 
	        Crash.impossible
		  "impossible NONE returned in Incremental.compile"
      in
	result
      end

    local
      (* This reference holds the project that the compilation manager
         uses when it resets itself. *)
      val preloaded = ref NONE
    in
      fun preload (context, mod_name) =
        let
          val runtime_modules =
            map (fn (str, value, _) => (str, value))
            (!MLWorks.Internal.Runtime.modules)
  
          val module_id =
            ModuleId.from_string (mod_name, Info.Location.FILE "_incremental")

          val _ =
            diagnostic_fn (0, fn (_, stream) =>
                            TextIO.output (stream, "making " ^ mod_name ^ "\n"))

          val options =
            OPTIONS {options = Options.default_options,
                     debugger = fn x => x}

          val result =
            add_module'
              (SOME runtime_modules)
	      default_error_info
              options
              (context, module_id, "Loading" ^ mod_name)
        in
	  Project.set_visible (!project, module_id, false);
          Project.reset_pervasives (!project);
          pervasive_project := !project;
	  preloaded := result
        end

      fun get_preload () =
	case !preloaded 
	of SOME r => r
	|  NONE => Crash.impossible "get_preloaded"
    end
    *)

   local
      val pervasive_project = !project
   in
      (* This allows the compilation manager to clear all entries. *)
      fun reset_project () = 
        (ignore(ProjFile.changed());
	 (* Sets flag to false as we are going to reread it anyway *)
         set_project (Project.fromFileInfo inf_loc (pervasive_project)))
   end


    (*  === ADD BINDINGS TO EXISTING VALUES ===  *)

    fun add_value (context, identifier, scheme, value) =
      let
        val
          CONTEXT {topdec,
                   compiler_basis =
                     Compiler.BASIS
                     {parser_basis,
                      type_basis,
                      lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
                      debugger_environment = debugger_env,
                      debug_info},
                   inter_env,
                   signatures} = context
	val ident = Ident.VAR
		      (Ident.Symbol.find_symbol identifier)
        val new_lambda_env =
	  Environ.add_valid_env (lambda_env,
				 (ident, EnvironTypes.EXTERNAL))
        val new_debugger_env =
	  Environ.add_valid_denv (debugger_env,
				 (ident, EnvironTypes.NULLEXP))
        val new_inter_env = Inter_EnvTypes.add_val (inter_env, (ident, value))
        local val PE.B(pF,pG,PE.E(pFE,pVE,pTE,pSE)) = parser_basis
        in
          (* this isn't really necessary if its only a VAR *)
          val new_parser_basis = 
            PE.B(pF,pG,PE.E(pFE,PE.addValId(fn (_,_,x) => x,ident,pVE),
                            pTE,pSE))
        end
      in
        (CONTEXT {topdec = topdec+1,
                  compiler_basis =
                    Compiler.BASIS
                    {parser_basis = new_parser_basis,
                     type_basis = Basis.add_val (type_basis,ident,scheme),
                     lambda_environment = EnvironTypes.TOP_ENV (new_lambda_env,
                                                                lambda_functor_env),
                     debugger_environment = new_debugger_env,
                     debug_info = debug_info},
                  inter_env = new_inter_env,
                  signatures = signatures},
        [Ident.VALUE ident])
      end

    fun env (CONTEXT{
	       compiler_basis =
                 Compiler.BASIS{
                   type_basis =
		     BasisTypes.BASIS(_,_, _, _, env),
                   ...
		 },
	       ...
	    }) = env

    fun extend_parser_basis (strid,str,PE.B(pF,pG,PE.E(pFE,pVE,pTE,pSE))) =
      let
        fun make_pVE valenv =
          Map.fold
          (fn (pVE,valid,_) => PE.addValId(fn (_,_,x) => x,valid,pVE))
          (PE.empty_pVE,valenv)

        fun make_str_pE(Datatypes.COPYSTR(_,str)) = make_str_pE(str)
          | make_str_pE(Datatypes.STR(_,_,env)) = make_env_pE env
        and make_env_pE (Datatypes.ENV(Datatypes.SE strenv,
                                       _,
                                       Datatypes.VE(_,valenv))) =
          PE.E(PE.empty_pFE,
               make_pVE valenv, pTE,
               PE.SE (Map.map (fn (_,str) => make_str_pE (str)) strenv))
      in
        PE.B(pF,
             pG,
             PE.E(pFE,pVE,pTE,PE.addStrId(fn (_,_,pE) => pE,
                                          strid,make_str_pE str,
                                          pSE)))
      end

    fun add_structure (context, identifier, str, value) =
      let
        val
          CONTEXT {topdec,
                   compiler_basis =
                     Compiler.BASIS
                     {parser_basis,
                      type_basis,
                      lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
                      debugger_environment = debugger_env,
                      debug_info = debug_info},
                   inter_env, signatures} = context
        val ident = Ident.STRID (Ident.Symbol.find_symbol identifier)
        val new_lambda_env = Environ.add_strid_env (lambda_env, 
                                                    (ident, 
                                                     (Environ.make_str_env (str,false), 
                                                      EnvironTypes.EXTERNAL,false)))
        val new_debugger_env = Environ.add_strid_denv (debugger_env, (ident, Environ.make_str_dexp str))
        val new_inter_env = Inter_EnvTypes.add_str (inter_env, (ident, value))
        val new_parser_basis = extend_parser_basis (ident,str,parser_basis)
      in
        (CONTEXT {topdec = topdec+1,
                  compiler_basis =
                    Compiler.BASIS
                    {parser_basis = new_parser_basis,
                     type_basis = Basis.add_str (type_basis,ident,str),
                     lambda_environment = EnvironTypes.TOP_ENV (new_lambda_env, lambda_functor_env),
                     debugger_environment = new_debugger_env,
                     debug_info = debug_info},
                  inter_env = new_inter_env,
                  signatures = signatures},
        [Ident.STRUCTURE ident])
      end

  end
@


1.143.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.143  1998/11/26  10:47:33  johnh
 * [Bug #70240]
 * Change spec of Project.delete
 *
@


1.142
log
@[Bug #50071]
Fix compiler warning
@
text
@d11 4
d721 1
a721 1
      set_project (Project.delete (!project, m))
@


1.141
log
@[Bug #50071]
Fix reset project to reread from the project file
@
text
@d11 4
d1371 2
a1372 1
        (ProjFile.changed(); (* Sets flag to false as we are going to reread it anyway *)
@


1.140
log
@[Bug #30389]
Keep projects more in step with projfiles
@
text
@d11 4
d1363 1
a1363 1
      val pervasive_project = ref (!project)
d1366 3
a1368 1
      fun reset_project () = set_project (!pervasive_project)
@


1.139
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d11 4
d528 1
d553 1
d690 2
d693 1
a693 4
      ref (Project.initialize
	     (default_error_info, Info.Location.FILE "_incremental"));

    fun get_project () = !project
d699 9
@


1.138
log
@[Bug #30203]
make check_mo and check_module return module ids.
@
text
@d11 32
a521 2
require "../utils/getenv";
require "../basics/module";
a524 1
require "^.basis.os";
d530 1
a530 1
require "../main/io";
a545 3
   structure OS : OS
   structure Getenv : GETENV
   structure Module : MODULE
a561 1
   sharing type Project.Info.options = Module.InfoOptions
a563 1
   sharing type Project.Module = Module.Module
d570 1
a570 1
   sharing type Io.ModuleId = Module.ModuleId = Project.ModuleId =
d574 1
a574 2
   sharing type ParserEnv.Ident.Location.T = ModuleId.Location = Io.Location =
		Module.Location
d895 1
a895 1
    (* The result type for compile_source, add_module, and load_mo; pass to
d1065 53
a1117 82
    fun check_mo error_info (moduleid, location) =
      let
        val (new_project, _) =
	  Project.read_dependencies
	    (error_info, location)
	    (!project, moduleid, Project.empty_map)

	val _ = set_project new_project

        val out_of_date =
	  Project.check_load_objects
	    (error_info, location)
	    (new_project, moduleid)
      in
	out_of_date
      end

    fun load_mo
	  error_info
	  (options, CONTEXT {compiler_basis, ...}, moduleid, location) =
      let
        val (new_project, _) =
	  Project.read_dependencies
	    (error_info, location)
	    (!project, moduleid, Project.empty_map)

	val _ = set_project new_project

        val out_of_date =
	  Project.check_load_objects
	    (error_info, location)
	    (new_project, moduleid)

        fun load_one (module_id, _) =
	  SOME (InterMake.load
		options
		(new_project, location)
		module_id)
      in
	  case List.foldl load_one NONE out_of_date
	  of SOME (compiler_result, new_module) =>
	    let 
	      val result =
	        case compiler_result
	        of Compiler.RESULT
	             {basis = new_basis, signatures = new_signatures, ...} =>
	          RESULT
	            {delta_basis = Compiler.make_external new_basis,
	             delta_signatures = new_signatures,
	             new_module = new_module}

	    in
	      Project.set_visible (new_project, moduleid, true);
	      (*
	      set_project new_project';
	      *)
	      SOME result
	    end
	  |  NONE =>
            (* For this case to be reached, out_of_date must be empty.
               We need to get the previously compiled module and basis,
               and compile the current file to get the signature
               field of the result value. *)
	    if Project.is_visible (new_project, moduleid) then
	      NONE
	    else
	      case Project.get_loaded_info (new_project, moduleid)
	      of SOME {basis, id_cache, module, ...} =>
	        let
	          val _ = Project.set_visible (new_project, moduleid, true);
	          val _ = set_project new_project
  
	          val result =
	            RESULT
	              {delta_basis = Compiler.make_external basis,
	               delta_signatures = empty_signatures,
	               new_module = module}
	        in
	          SOME result
	        end
	      |  NONE => 
	        Crash.impossible "impossible NONE returned in Incremental.load"
d1163 2
a1301 2
    val add_module = add_module' NONE

a1304 2
      val pervasive_project = ref (!project)

d1341 2
d1344 3
d1348 3
a1350 3
      fun reset_project () =
        set_project (!pervasive_project)
    end
a1463 156

    fun match_source_path (f, error_info, location, filename, reason) =
      let
        val (on_path, module) =
          Module.find_file (filename, location)
          handle
            Module.NoSuchFile s =>
              Info.error'
		error_info
                (Info.FATAL, location, "No such file: `" ^ s ^ "'")
          | Module.BadHomeName s =>
              Info.error'
		error_info
                (Info.FATAL, location, "Invalid home name: " ^ s)
 
	val module_id = Module.module_id module
	val mod_name = ModuleId.string module_id

	val _ =
	  case Project.get_source_info (!project, module_id)
	  of SOME (filename', _, _) =>
	    if filename' = Module.sourceName module then
	      ()
	    else
              Info.error'
		error_info
                (Info.FATAL, location,
		 "The system already has an entry for a unit called:\n`"
		 ^ mod_name ^ "', with source file:\n"
		 ^ Module.sourceName module)
	  |  NONE =>
	    (case Project.get_object_info (!project, module_id)
	     of SOME {file, ...} =>
	       let
	         val mo_name =
		   Module.objectName (error_info, location) module
		   handle Io.NotSet _ => 
		     Info.error' 
		       error_info 
		       (Info.FATAL, 
			Info.Location.UNKNOWN,
			"Object path not set")
	       in
		 if mo_name = file then
	           ()
	         else
                   Info.error'
		     error_info
                     (Info.FATAL, location,
		      "The system already has an entry for a unit called:\n`"
		      ^ mod_name ^ "', with object file:\n" ^ file
		      ^ ".\nThe object file that corresponds to the argument "
		      ^ "that you have given is:\n" ^ mo_name)
	       end
	     |  NONE =>
	       (* Check for a preloaded module *)
	       (case Project.get_loaded_info (!project, module_id)
		of SOME _ =>
                   Info.error'
		     error_info
                     (Info.FATAL, location,
		      "The system already has a preloaded unit called:\n`"
		      ^ mod_name ^ "'")
	        |  NONE => ()))
      in
	if not on_path then
	  Module.with_source_path (module, reason) (f error_info)
	else
	  (f error_info) module_id
      end


    fun fileExists fileName =
      OS.FileSys.access (fileName, [])  handle OS.SysErr _ => false


    fun match_object_path (f, error_info, location, filename) =
      let
        val extended = 
          case OS.Path.splitBaseExt filename of
            {base=_, ext=SOME "mo"} => filename
	  | {base=name, ext=SOME "sml"} =>
	      OS.Path.joinBaseExt {base=name, ext=SOME "mo"}
          | _ => OS.Path.joinBaseExt {base=filename, ext=SOME "mo"}
        
        val absolute = OS.FileSys.fullPath (Getenv.expand_home_dir extended)
          handle
            OS.SysErr _ =>
              Info.error'
		error_info
                (Info.FATAL, location, "No such file: `" ^ filename ^ "'")
          | Getenv.BadHomeName s =>
              Info.error'
		error_info
                (Info.FATAL, location, "Invalid home name: " ^ s)

	val {mod_name, ...} =
          if fileExists absolute then
	    Encapsulate.input_info absolute
	    handle Encapsulate.BadInput _ =>
              Info.error'
		error_info
                (Info.FATAL, location, "Bad object format: " ^ absolute)
          else
            Info.error'
	      error_info
              (Info.FATAL, location, "No such file: " ^ absolute)


	val module_id = ModuleId.from_string (mod_name, location)

	val _ =
	  case Project.get_object_info (!project, module_id) of
            SOME {file, ...} =>
	    if absolute = file then
	      ()
	    else
              Info.error'
		error_info
                (Info.FATAL, location,
		 "The system already has an entry for a unit called:\n`"
		 ^ mod_name ^ "', with object file:\n" ^ file)
	  |  NONE =>
	    (case Project.get_source_info (!project, module_id)
	     of SOME (src_file, module, _) =>
	       let
	         val mo_name =
		   Module.objectName (error_info, location) module
		   handle Io.NotSet _ => 
		     Info.error' 
		       error_info 
		       (Info.FATAL, 
			Info.Location.UNKNOWN,
			"Object path not set")
	       in
                 Info.error'
		   error_info
                   (Info.FATAL, location,
		    "The system already has an entry for a unit called:\n`"
		    ^ mod_name ^ "', with source file:\n" ^ src_file
		    ^ ".\nThe corresponding object file would be:\n" ^ mo_name)
	       end
	     |  NONE =>
	       (* Check for a preloaded module *)
	       (case Project.get_loaded_info (!project, module_id)
		of SOME _ =>
                   Info.error'
		     error_info
                     (Info.FATAL, location,
		      "The system already has a preloaded unit called:\n`"
		      ^ mod_name ^ "'")
	        |  NONE => ()))
      in
        f error_info module_id
      end

@


1.137
log
@[Bug #20033]
Pass extra arg to set_source_path to indicate -silent option.
@
text
@d11 4
d1056 1
a1056 1
	map ModuleId.string out_of_date
d1166 1
a1166 1
	map ModuleId.string module_ids
@


1.137.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 4
 * Revision 1.137  1997/05/28  08:56:42  johnh
 * [Bug #20033]
 * Pass extra arg to set_source_path to indicate -silent option.
 *
@


1.137.2.2
log
@[Bug #30071]
Converted build system to project workspace.
@
text
@a10 3
 * Revision 1.137.2.1  1997/09/11  20:54:49  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d1487 1
a1487 1
	  of SOME (filename', _) =>
d1591 1
a1591 1
	     of SOME (src_file, _) =>
d1594 7
a1600 3
		   Project.objectName
		     (error_info, location)
		     (!project, module_id)
@


1.137.2.3
log
@[Bug #30203]
Merging - checking files to be recompiled.
@
text
@a10 4
 * Revision 1.137.2.2  1997/09/17  15:50:49  daveb
 * [Bug #30071]
 * Converted build system to project workspace.
 *
a13 4
 * Revision 1.138  1997/09/17  15:49:11  brucem
 * [Bug #30203]
 * make check_mo and check_module return module ids.
 *
d1059 1
a1059 1
	out_of_date
d1169 1
a1169 1
	module_ids
@


1.137.2.4
log
@[Bug #30326]
@
text
@a10 4
 * Revision 1.137.2.3  1997/11/11  16:13:06  johnh
 * [Bug #30203]
 * Merging - checking files to be recompiled.
 *
d512 1
a512 1
require "../main/mlworks_io";
@


1.137.2.5
log
@[Bug #30071]
match_{source,object}_path are no longer needed.
@
text
@a10 3
 * Revision 1.137.2.4  1997/11/20  16:56:30  daveb
 * [Bug #30326]
 *
d505 2
d510 1
d532 3
d551 1
d554 1
d561 1
a561 1
   sharing type Io.ModuleId = Project.ModuleId =
d565 2
a566 1
   sharing type ParserEnv.Ident.Location.T = ModuleId.Location = Io.Location
d1482 152
@


1.137.2.6
log
@[Bug #30071]
Removed functions for loading from source files.
@
text
@a10 4
 * Revision 1.137.2.5  1997/11/26  12:17:11  daveb
 * [Bug #30071]
 * match_{source,object}_path are no longer needed.
 *
d881 1
a881 1
    (* The result type for compile_source and load_mo; pass to
a1177 2
    (* This currently isn't used -- but I want to keep it around in case
       we resurrect the preloading code.
d1315 2
d1320 2
a1357 2
    end
    *)
a1358 3
   local
      val pervasive_project = ref (!project)
   in
d1360 3
a1362 3
      fun reset_project () = set_project (!pervasive_project)
   end

@


1.137.2.7
log
@[Bug #30017]
Rationalised Shell/GUI Project commands:
Moved check_mo to ShellUtils, ditto for Project manipulation part of
load_mo.  Left the core part as load_mos, which loads all files in a list.
@
text
@a10 4
 * Revision 1.137.2.6  1997/12/02  16:37:35  daveb
 * [Bug #30071]
 * Removed functions for loading from source files.
 *
d1055 82
a1136 53
   fun load_mos
         error_info
         (options, CONTEXT {compiler_basis, ...}, project,
          moduleid, mod_id_list, location) =
     (* mod_id_list is a list of modules to be loaded.
	module_id is the "top-level" one, which must be made visible.  *)
     let
       fun load_one (module_id, _) =
         SOME (InterMake.load
               options
               (project, location)
               module_id)
     in
       case List.foldl load_one NONE mod_id_list
       of SOME (compiler_result, new_module) =>
         let
           val result =
             case compiler_result
             of Compiler.RESULT
                  {basis = new_basis, signatures = new_signatures, ...} =>
               RESULT
                 {delta_basis = Compiler.make_external new_basis,
                  delta_signatures = new_signatures,
                  new_module = new_module}
         in
           Project.set_visible (project, moduleid, true);
           SOME result
         end
       |  NONE =>
         (* For this case to be reached, mod_id_list must be empty.
            We need to get the previously compiled module and basis,
            and compile the current file to get the signature
            field of the result value. *)
	 (* XXX we don't seem to compile the file after all? 
	    daveb 3/12/97 *)
         if Project.is_visible (project, moduleid) then
           NONE
         else
           case Project.get_loaded_info (project, moduleid)
           of SOME {basis, id_cache, module, ...} =>
             let
               val _ = Project.set_visible (project, moduleid, true);

               val result =
                 RESULT
                   {delta_basis = Compiler.make_external basis,
                    delta_signatures = empty_signatures,
                    new_module = module}
             in
               SOME result
             end
           |  NONE =>
             Crash.impossible "impossible NONE returned in Incremental.load.mos"
@


1.137.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 4
 * Revision 1.137  1997/05/28  08:56:42  johnh
 * [Bug #20033]
 * Pass extra arg to set_source_path to indicate -silent option.
 *
@


1.136
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d11 4
d628 2
d631 1
a631 1
		(Info.Location.FILE "Initial Context");
@


1.135
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d11 4
d477 3
a480 1
require "^.basis.list";
d590 1
a590 1
      (fn (verbosity, stream) => (MLWorks.IO.output (stream, "Incremental: ");
d666 1
a666 1
				MLWorks.IO.output (stream, "making the builtin library\n"))
d724 1
a724 1
			  MLWorks.IO.output (stream, "making the pervasive library\n"))
d899 2
a900 2
           (MLWorks.IO.output (stream, "Compiling topdec from ");
            MLWorks.IO.output (stream, filename)))
d1316 1
a1316 1
                            MLWorks.IO.output (stream, "making " ^ mod_name ^ "\n"))
@


1.134
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d11 4
d502 1
a502 1
   structure Io : IO
@


1.133
log
@[Bug #2040]
Make InterMake.load take an options argument
@
text
@d11 4
a555 2

    open MLWorks.Option
@


1.132
log
@[Bug #1965]
Handling Io.NotSet for objectName.
@
text
@d11 4
d1055 3
a1057 12
	          (new_project, location)
	          module_id)
	  (*
	  (* NONE => first call.  Use new_project. *)
	  SOME (InterMake.load
		    (new_project, location)
		    module_id)
        |   load_one (SOME (_, _), module_id) =
	  SOME (InterMake.load
		    (new_project, location)
		    module_id)
	  *)
@


1.132.1.1
log
@branched from 1.132
@
text
@a10 4
 * Revision 1.132  1997/03/21  11:28:21  johnh
 * [Bug #1965]
 * Handling Io.NotSet for objectName.
 *
@


1.132.1.2
log
@[Bug #02040]
InterMake.load now takes an options argument.
@
text
@a10 3
 * Revision 1.132.1.1  1997/05/12  10:33:56  hope
 * branched from 1.132
 *
a1054 1
		  options
d1057 10
@


1.132.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 4
 * Revision 1.132.1.2  1997/06/10  15:26:26  daveb
 * [Bug #02040]
 * InterMake.load now takes an options argument.
 *
@


1.132.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 4
 * Revision 1.132.1.2  1997/06/10  15:26:26  daveb
 * [Bug #02040]
 * InterMake.load now takes an options argument.
 *
@


1.132.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 4
 * Revision 1.132.1.2  1997/06/10  15:26:26  daveb
 * [Bug #02040]
 * InterMake.load now takes an options argument.
 *
@


1.132.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 3
 * Revision 1.132.1.2.1.1  1997/07/28  18:19:25  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.131
log
@Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
-- Changed name and type of Module.mo_name and Module.sml_name.
@
text
@d11 4
d1486 6
d1578 6
@


1.130
log
@[Bug #1614]
removing toplevel String.
@
text
@d3 1
a3 1
 *  Copyright (C) 1992 Harlequin Ltd
d11 4
d1467 1
a1467 1
	    if filename' = Module.sml_name module then
d1475 1
a1475 1
		 ^ Module.sml_name module)
d1480 2
a1481 1
	         val mo_name = Module.mo_name error_info module
d1566 2
a1567 1
	         val mo_name = Module.mo_name error_info module
@


1.130.4.1
log
@branched from 1.130
@
text
@a10 4
 * Revision 1.130  1996/10/30  14:54:56  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.130.3.1
log
@branched from 1.130
@
text
@a10 4
 * Revision 1.130  1996/10/30  14:54:56  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.130.3.1.1.1
log
@branched from 1.130.3.1
@
text
@a10 3
 * Revision 1.130.3.1  1996/12/17  17:47:29  hope
 * branched from 1.130
 *
@


1.130.2.1
log
@branched from 1.130
@
text
@a10 4
 * Revision 1.130  1996/10/30  14:54:56  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.130.1.1
log
@branched from 1.130
@
text
@a10 4
 * Revision 1.130  1996/10/30  14:54:56  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.130.1.1.1.1
log
@branched from 1.130.1.1
@
text
@a10 3
 * Revision 1.130.1.1  1996/11/14  12:49:07  hope
 * branched from 1.130
 *
@


1.129
log
@[Bug #1686]
propagating change made to parserenv: type constructor environment
added to parser env, for datatype replication.
@
text
@d11 5
d916 1
a916 1
              MLWorks.Option.NONE =>
d920 2
a921 2
                 String.implode ["`", filename, "' database entry has no code recorded. "])
            | MLWorks.Option.SOME code' => 
@


1.128
log
@[Bug #1553]
Make match_object_path convert .sml into .mo, rather than adding it
@
text
@d11 4
d726 7
a732 1
      val Compiler.BASIS {lambda_environment, ...} = basis
d751 10
d762 1
a762 1
          Compiler.BASIS{parser_basis=parser_basis,
d1349 1
a1349 1
        local val PE.B(pF,pG,PE.E(pFE,pVE,pSE)) = parser_basis
d1352 3
a1354 1
          val new_parser_basis = PE.B(pF,pG,PE.E(pFE,PE.addValId(fn (_,_,x) => x,ident,pVE),pSE))
d1381 1
a1381 1
    fun extend_parser_basis (strid,str,PE.B(pF,pG,PE.E(pFE,pVE,pSE))) =
d1394 1
a1394 1
               make_pVE valenv,
d1399 3
a1401 1
             PE.E(pFE,pVE,PE.addStrId(fn (_,_,pE) => pE,strid,make_str_pE str,pSE)))
@


1.128.3.1
log
@branched from 1.128
@
text
@a10 4
 * Revision 1.128  1996/08/16  14:01:34  jont
 * [Bug #1553]
 * Make match_object_path convert .sml into .mo, rather than adding it
 *
@


1.128.2.1
log
@branched from 1.128
@
text
@a10 4
 * Revision 1.128  1996/08/16  14:01:34  jont
 * [Bug #1553]
 * Make match_object_path convert .sml into .mo, rather than adding it
 *
@


1.128.1.1
log
@branched from 1.128
@
text
@a10 4
 * Revision 1.128  1996/08/16  14:01:34  jont
 * [Bug #1553]
 * Make match_object_path convert .sml into .mo, rather than adding it
 *
@


1.127
log
@Bug 1448/Support Call 35: Added remove_file_info to project and incremental,
and called it from _save_image.
@
text
@d11 4
d1487 2
@


1.126
log
@Fix #1330 - Shell.File.loadObject doesn't look for .mo extension
@
text
@d11 3
d1079 2
@


1.125
log
@Out with the old in with the new -- replaced OldOS and Lists by OS and List
respectively.  This was done to simplify fixing #1330.
@
text
@d11 4
d440 1
d468 1
d1475 16
d1492 2
a1493 2
          if fileExists filename then
	    Encapsulate.input_info filename
d1497 1
a1497 1
                (Info.FATAL, location, "Bad object format: " ^ filename)
d1501 1
a1501 1
              (Info.FATAL, location, "No such file: " ^ filename)
d1507 3
a1509 3
	  case Project.get_object_info (!project, module_id)
	  of SOME {file, ...} =>
	    if filename = file then
@


1.124
log
@Improved error messages from match_source_path and match_object_path.
@
text
@d11 3
d434 1
a434 1
require "../utils/lists";
d440 1
a440 1
require "../make/old_os";
d459 1
a459 1
   structure Lists : LISTS
d462 1
a462 1
   structure OldOs : OLD_OS
d686 1
a686 1
      fun compile_perv ((_, _, accumulated_info), module_id) =
d700 1
a700 1
	Lists.reducel
d702 3
a704 3
	  ((builtin_library_result, builtin_module,
	   Compiler.get_basis_debug_info Compiler.initial_basis),
	   out_of_date)
d1003 1
a1003 1
        fun load_one (_, module_id) =
d1018 1
a1018 3
	  case Lists.reducel
		 load_one
		 (NONE, out_of_date)
d1174 1
a1174 1
        fun compile_one (NONE, module_id) =
d1184 1
a1184 1
        |   compile_one (SOME (_, _, accumulated_info), module_id) =
d1195 1
a1195 1
	  case Lists.reducel compile_one (NONE, out_of_date)
d1462 5
d1470 1
a1470 6
          case OldOs.mtime filename
          of OldOs.NOT_EXIST =>
            Info.error'
	      error_info
              (Info.FATAL, location, "No such file: " ^ filename)
          |  OldOs.EXISTS _ =>
d1476 5
@


1.123
log
@Ensured that all changes to the project update the global project, even
when errors occur.
Removed Error exception.
@
text
@d11 5
d1424 3
a1426 2
		 "The system already has an entry for a unit called : "
		 ^ mod_name)
d1439 4
a1442 2
		      "The system already has an entry for a unit called : "
		      ^ mod_name)
d1451 2
a1452 2
		      "The system already has an entry for a unit called : "
		      ^ mod_name)
d1487 2
a1488 2
		 "The system already has an entry for a unit called : "
		 ^ mod_name)
d1491 1
a1491 1
	     of SOME (_, module, _) =>
d1498 3
a1500 2
		    "The system already has an entry for a unit called : "
		    ^ mod_name)
d1509 2
a1510 2
		      "The system already has an entry for a unit called : "
		      ^ mod_name)
@


1.122
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d11 6
a543 2
    exception Error of Info.error * Info.error list

d589 8
d619 1
a619 1
      val (new_project, builtin_library_result, builtin_module, _) =
d636 1
a636 1
 	       (new_project, Io.builtin_library_id)
d654 1
a654 1
              (new_project,
d676 1
a676 1
	  new_project
d678 2
a679 2
      fun compile_perv ((project, _, _, accumulated_info), module_id) =
	(* returns (project', compiler_result, module, accumulated_info') *)
d687 1
a687 1
	    (project, module_id, accumulated_info)
d689 1
a689 1
      val (new_project', pervasive_library_result, pervasive_module, _) =
d694 1
a694 1
	  ((new_project, builtin_library_result, builtin_module,
a711 2

      val _ = project := new_project'
d969 2
a975 1
	set_project new_project;
d988 2
d995 5
a999 1
        fun load_one (NONE, module_id) =
d1004 1
a1004 1
        |   load_one (SOME (project, _, _), module_id) =
d1006 1
a1006 1
		    (project, location)
d1008 1
a1008 1

d1013 1
a1013 1
	  of SOME (new_project', compiler_result, new_module) =>
d1025 2
a1026 1
	      Project.set_visible (new_project', moduleid, true);
d1028 1
a1055 10
      handle
	InterMake.Error (project', error, error_list) =>
          (diagnostic
	     (2,
	      fn _ => ["Make failed.  Returning partially updated context."]);
	   set_project project';
           raise Error (error, error_list))
      | InterMake.Interrupted project' =>
	  (set_project project';
           raise Interrupt)
d1088 2
a1094 1
	set_project new_project;
d1161 2
d1169 1
a1169 1
	  (* NONE => first call.  Use new_project and initial compiler_basis. *)
d1178 1
a1178 1
        |   compile_one (SOME (project, _, _, accumulated_info), module_id) =
d1186 1
a1186 1
	            (project, module_id, accumulated_info))
d1188 1
a1188 1
        val (new_project', result) =
d1191 1
a1191 1
	       (new_project', compiler_result, new_module, accumulated_info) =>
d1205 2
a1206 2
	      Project.set_visible (new_project', moduleid, true);
	      (new_project', SOME result)
d1214 1
a1214 1
	      (new_project, NONE)
d1226 1
a1226 1
	          (new_project, SOME result)
a1230 2

	val _ = set_project new_project'
a1233 10
      handle
	InterMake.Error (project', error, error_list) =>
          (diagnostic
	     (2,
	      fn _ => ["Make failed.  Returning partially updated context."]);
	   set_project project';
           raise Error (error, error_list))
      | InterMake.Interrupted project' =>
	  (set_project project';
           raise Interrupt)
a1415 2
	      (MLWorks.IO.output (MLWorks.IO.std_out, "This file = `" ^ Module.sml_name module ^ "'\n");
	       MLWorks.IO.output (MLWorks.IO.std_out, "Existing file = `" ^ filename' ^ "'\n");
d1420 1
a1420 1
		 ^ mod_name))
a1429 2
	           MLWorks.IO.output (MLWorks.IO.std_out, "This file = `" ^ mo_name ^ "'\n");
	           MLWorks.IO.output (MLWorks.IO.std_out, "Existing file = `" ^ file ^ "'\n");
@


1.121
log
@Removed some extraneous debugging statements.
@
text
@d11 3
d530 1
a530 1
      (fn (verbosity, stream) => (output (stream, "Incremental: ");
d600 1
a600 1
				output (stream, "making the builtin library\n"))
d658 1
a658 1
			  output (stream, "making the pervasive library\n"))
d819 2
a820 2
           (output (stream, "Compiling topdec from ");
            output (stream, filename)))
d864 1
a864 1
                 implode ["`", filename, "' database entry has no code recorded. "])
d1255 1
a1255 1
                            output (stream, "making " ^ mod_name ^ "\n"))
d1416 2
a1417 2
	      (output (std_out, "This file = `" ^ Module.sml_name module ^ "'\n");
	       output (std_out, "Existing file = `" ^ filename' ^ "'\n");
d1432 2
a1433 2
	           output (std_out, "This file = `" ^ mo_name ^ "'\n");
	           output (std_out, "Existing file = `" ^ file ^ "'\n");
@


1.120
log
@Add a call to Compiler.make_external on the result of compiling a module
which has already been compiled but is not visible at top level.
Made the same fix for loading object files
@
text
@d11 5
a1476 2
	      (output (std_out, "This file = `" ^ filename ^ "'\n");
	       output (std_out, "Existing file = `" ^ file ^ "'\n");
d1481 1
a1481 1
		 ^ mod_name))
d1488 5
a1492 10
		 if mo_name = filename then
	           ()
	         else
	           output (std_out, "This file = `" ^ filename ^ "'\n");
	           output (std_out, "Existing file = `" ^ mo_name ^ "'\n");
                   Info.error'
		     error_info
                     (Info.FATAL, location,
		      "The system already has an entry for a unit called : "
		      ^ mod_name)
@


1.119
log
@Added read_dependencies.
@
text
@d11 3
d1020 1
a1020 1
	              {delta_basis = basis,
d1201 1
a1201 1
	              {delta_basis = basis,
@


1.118
log
@Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
the deprecated OS interface.
@
text
@d11 4
d944 1
a944 1
	  Project.load_dependencies
d962 1
a962 1
	  Project.load_dependencies
d1050 6
d1061 1
a1061 1
		  ["Checking make module `", ModuleId.string module_id, "'"])
d1064 1
a1064 1
	  Project.load_dependencies
d1136 1
a1136 1
	  Project.load_dependencies
@


1.117
log
@New field in VALdec
@
text
@d11 3
d411 1
a411 1
require "../make/os";
d433 1
a433 1
   structure Os : OS
d1439 2
a1440 2
          case Os.mtime filename
          of Os.NOT_EXIST =>
d1444 1
a1444 1
          |  Os.EXISTS _ =>
@


1.116
log
@Set the lambda environment after compilation of the builtin library correctly
Remove debugging messages when loading mo files
@
text
@d11 4
d870 1
a870 1
             (DECstrdec (VALdec ([(pat,_,_)],[],_))) =>
@


1.115
log
@Added match_source_path and match_object_path, which do some of the work
that Module.with_source_path used to do, plus checking for attempts to use
different files with the same unit name.
Changed type of some other functions for use with these new ones.
@
text
@d11 6
d626 1
a626 1
		  basis = basis,
a949 2
	val _ = output (std_out, "loading dependencies\n");

a953 2

	val _ = output (std_out, "checking dependencies\n");
@


1.114
log
@Replace Map.merge by Map.union
@
text
@d11 3
d397 2
d420 1
d424 1
d438 1
d441 1
d452 2
a453 1
   sharing type ParserEnv.Ident.Location.T = ModuleId.Location = Io.Location
d567 3
d924 1
a924 1
    fun check_mo (moduleid, location) =
d928 1
a928 1
	    (default_error_info, location)
d933 1
a933 1
	    (default_error_info, location)
d941 1
d948 1
a948 1
	    (default_error_info, location)
d955 1
a955 1
	    (default_error_info, location)
d1024 1
a1024 1
    fun delete_module module_id =
d1037 1
a1037 1
    fun check_module (module_id, toplevel_name) =
d1046 1
a1046 1
	    (default_error_info, Info.Location.FILE toplevel_name)
d1051 1
a1051 1
	    (default_error_info, Info.Location.FILE toplevel_name)
d1060 1
d1118 1
a1118 1
	    (default_error_info, Info.Location.FILE toplevel_name)
d1123 1
a1123 1
	    (default_error_info, Info.Location.FILE toplevel_name)
d1131 1
a1131 1
	            (default_error_info,
d1140 1
a1140 1
	            (default_error_info, 
d1234 1
d1362 126
@


1.113
log
@Added check_mo.
@
text
@d11 3
d517 1
a517 1
    val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
d873 1
a873 1
            val val_list : MLWorks.Internal.Value.T list = castit new_module
d891 1
a891 1
	  Map.merge (fn (old, new) => new) (signatures, delta_signatures)
@


1.112
log
@When a module is up to date, add_module and load_mo no longer read the
signatures from the file on disk.  They use whatever info is stored in
the project.
@
text
@d11 5
d908 16
d1020 1
a1020 3
    fun check_module
  	  (OPTIONS {options, ...})
          (module_id, toplevel_name) =
d1027 5
d1035 1
a1035 1
	    (!project, module_id)
d1037 1
@


1.111
log
@Removed filename field from result type.
@
text
@d11 3
d744 2
a963 5
		  val compiler_result =
	  	    InterMake.get_mo_information
		      (new_project, location)
		      moduleid

d965 4
a968 6
	            case compiler_result
	            of Compiler.RESULT {signatures, ...} =>
	              RESULT
	                {delta_basis = basis,
	                 delta_signatures = signatures,
	                 new_module = module}
a1133 8
		  val compiler_result =
	            InterMake.get_src_information
	              initial_compiler_basis
	              (default_error_info, 
		       Info.Location.FILE toplevel_name,
		       options)
	              (new_project, moduleid)
	      
d1135 4
a1138 6
	            case compiler_result
	            of Compiler.RESULT {signatures, ...} =>
	              RESULT
	                {delta_basis = basis,
	                 delta_signatures = signatures,
	                 new_module = module}
@


1.110
log
@Made load_mo and add_module return NONE if the module is both up to date
and visible.
@
text
@d11 4
d733 1
a733 2
       new_module is a new module and filename is the filename of the source.
       modules is the updated module table - not a delta. *)
d739 1
a739 2
         new_module: MLWorks.Internal.Value.T,
         filename: string}
d824 1
a824 2
	   new_module = module,
	   filename = filename}
d872 1
a872 1
	     {delta_basis, delta_signatures, new_module, filename, ...}) =
d938 1
a938 2
	             new_module = new_module,
	             filename = ModuleId.string moduleid}
d970 1
a970 2
	                 new_module = module,
	                 filename = ModuleId.string moduleid}
d1120 1
a1120 2
	             new_module = new_module,
	             filename = ModuleId.string moduleid}
d1150 1
a1150 2
	                 new_module = module,
	                 filename = ModuleId.string moduleid}
@


1.109
log
@Changed implementation of identifiers_from_result to extract identifiers
from the type basis.
@
text
@d11 4
a918 4
		    (*
	            NONE
	            (new_project, module_id, compiler_basis))
		    *)
a922 4
		    (*
	            NONE
	            (project, module_id, accumulated_info))
		    *)
a939 1
	      val _ = set_project new_project'
d941 3
a943 1
	      result
d950 27
a976 23
	    case Project.get_loaded_info (new_project, moduleid)
	    of SOME {basis, id_cache, module, ...} =>
	      let
	        val _ = set_project new_project

		val compiler_result =
	  	  InterMake.get_mo_information
		    (new_project, location)
		    moduleid

	        val result =
	          case compiler_result
	          of Compiler.RESULT {signatures, ...} =>
	            RESULT
	              {delta_basis = basis,
	               delta_signatures = signatures,
	               new_module = module,
	               filename = ModuleId.string moduleid}
	      in
	        result
	      end
	    |  NONE => 
	      Crash.impossible "impossible NONE returned in Incremental.load"
d1124 2
a1125 1
	      (new_project', result)
d1132 13
a1144 10
	    case Project.get_loaded_info (new_project, moduleid)
	    of SOME {basis, module, ...} =>
	      let
		val compiler_result =
	          InterMake.get_src_information
	            initial_compiler_basis
	            (default_error_info, 
		     Info.Location.FILE toplevel_name,
		     options)
	            (new_project, moduleid)
d1146 15
a1160 13
	        val result =
	          case compiler_result
	          of Compiler.RESULT {signatures, ...} =>
	            RESULT
	              {delta_basis = basis,
	               delta_signatures = signatures,
	               new_module = module,
	               filename = ModuleId.string moduleid}
	      in
	        (new_project, result)
	      end
	    |  NONE => 
	      Crash.impossible "impossible NONE returned in Incremental.compile"
d1209 1
d1212 1
a1212 1
	  preloaded := SOME result
@


1.108
log
@Added call to set object path from the environment.  This is needed for
the call to Project.reset_pervasives.
@
text
@d11 4
a732 1
	 identifiers: Ident.Identifier list,
d735 3
a737 1
    fun identifiers_from_result (RESULT {identifiers, ...}) = identifiers
a764 1
                                 identifiers,
a818 1
           identifiers = identifiers,
d937 1
a937 2
	             {basis = new_basis, signatures = new_signatures,
	              identifiers, ...} =>
a941 1
	             identifiers = identifiers,
d951 2
a952 2
               and compile the current file to get the signature and
               identifiers fields of the result value. *)
d965 1
a965 1
	          of Compiler.RESULT {signatures, identifiers, ...} =>
a969 1
	               identifiers = identifiers,
d1113 1
a1113 2
	             {basis = new_basis, signatures = new_signatures,
	              identifiers, ...} =>
a1120 1
	             identifiers = identifiers,
d1128 2
a1129 2
               and compile the current file to get the signature and
               identifiers fields of the result value. *)
d1143 1
a1143 1
	          of Compiler.RESULT {signatures, identifiers, ...} =>
a1147 1
	               identifiers = identifiers,
@


1.107
log
@Added support for loading libraries that share compiler code.
@
text
@d11 3
d506 2
@


1.106
log
@Reduced amount of information stored in projects for loaded units.
@
text
@d11 3
a669 9
    (* I don't know if this makes sense without resetting the context as
       well, but let's give it a go. *)
    local
      val pervasive_project = !project
    in
      fun reset_project () =
	set_project pervasive_project
    end

a712 9
    (*
    fun update_modules
	  (CONTEXT {topdec, compiler_basis, inter_env, signatures, ...},
	   modules) =
      (CONTEXT {topdec = topdec, compiler_basis = compiler_basis,
		inter_env = inter_env, signatures = signatures,
		modules = modules})
    *)

d1013 2
a1014 1
    fun add_module
d1087 1
a1087 1
	            NONE
d1097 1
a1097 1
	            NONE
d1167 47
@


1.105
log
@Changed information stored in project for loaded compilation units.
@
text
@d11 3
d417 2
a418 1
   sharing type InterMake.Compiler.result = Project.CompilerResult
d555 1
a555 1
	|  SOME {file_time, load_time, result, module, dependencies} =>
a556 4
            val Compiler.RESULT
		  {basis, signatures, identifiers, code, id_cache} =
	      result
  
d575 2
a576 4
		  result =
                    Compiler.RESULT
                      {signatures = signatures, identifiers = identifiers,
		       code = code, id_cache = id_cache, basis = new_basis},
d935 1
a935 1
        val (new_project', result, new_module) =
d939 18
a956 2
	  of SOME (new_project', result, new_module) =>
	    (new_project', result, new_module)
d958 4
d963 21
a983 2
	    of SOME {result, module, ...} =>
	      (new_project, result, module)
a985 13

	val _ = set_project new_project'
      in
	case result
	of Compiler.RESULT
	     {basis = new_basis, signatures = new_signatures,
	      identifiers, ...} =>
	  RESULT
	    {delta_basis = Compiler.make_external new_basis,
	     delta_signatures = new_signatures,
	     new_module = new_module,
	     identifiers = identifiers,
	     filename = ModuleId.string moduleid}
d1114 1
a1114 1
        val (new_project', result, new_module, accumulated_info) =
d1116 20
a1135 2
	  of SOME result =>
	    result
d1137 4
d1142 22
a1163 3
	    of SOME {result, module, ...} =>
	      (new_project, result, module,
	       Compiler.get_basis_debug_info compiler_basis)
d1169 1
a1169 13
	case result
	of Compiler.RESULT
	     {basis = new_basis, signatures = new_signatures,
	      identifiers, ...} =>
	  RESULT
	    {delta_basis =
	       Compiler.make_external
		 (Compiler.adjust_compiler_basis_debug_info
		    (new_basis, accumulated_info)),
	     delta_signatures = new_signatures,
	     new_module = new_module,
	     identifiers = identifiers,
	     filename = ModuleId.string moduleid}
@


1.104
log
@Hid implementation of Project.Unit type.
@
text
@d11 3
d551 1
a551 1
	|  SOME (time, compiler_result, module, consistency) =>
d555 1
a555 1
	      compiler_result
d572 9
a580 5
               SOME (time,
                     Compiler.RESULT
                       {signatures = signatures, identifiers = identifiers,
		        code = code, id_cache = id_cache, basis = new_basis},
		     module, consistency));
d663 6
d802 1
a802 1
	      of SOME (_, _, module, _) => module
d915 1
a915 1
	  Project.check_loaded
d945 2
a946 2
	    of SOME (_, compiler_result, module, _) =>
	      (new_project, compiler_result, module)
d1096 2
a1097 2
	    of SOME (_, compiler_result, module, _) =>
	      (new_project, compiler_result, module,
@


1.103
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d11 3
d965 1
a965 4
      Project.for_all
	(!project,
	 not o ModuleId.is_pervasive, 
	 fn (Project.UNIT {loaded, ...}) => loaded := NONE)
d967 1
a967 5
      Project.for_all
	(!project,
	 fn _ => true, 
	 fn (Project.UNIT {loaded, ...}) => loaded := NONE)
		
@


1.102
log
@Removing Option in favour of MLWorks.Option
@
text
@d11 3
d467 1
a467 1
                  signatures		: (Ident.SigId, Absyn.SigExp) Map.T}
d723 1
a723 1
         delta_signatures: (Ident.SigId,Absyn.SigExp) Map.T,
@


1.101
log
@Now passes debug info around as accumulated info instead of a basis.
@
text
@d11 3
d789 1
a789 1
              Compiler.Option.ABSENT =>
d794 1
a794 1
            | Compiler.Option.PRESENT code' => 
@


1.100
log
@Fixed propagation of debug information.
@
text
@d11 3
d528 2
a529 1
	   Compiler.initial_basis_for_builtin_library)
d597 1
a597 1
	   Compiler.initial_basis),
d1063 2
a1064 1
	            (new_project, module_id, compiler_basis))
d1082 2
a1083 1
	      (new_project, compiler_result, module, initial_compiler_basis)
d1097 1
a1097 2
		    (new_basis,
		     Compiler.get_basis_debug_info accumulated_info)),
@


1.99
log
@Reversing previous change.
@
text
@d11 3
d423 8
a430 7
    val empty_compiler_basis = case InterMake.Compiler.initial_basis of
      InterMake.Compiler.BASIS
      {parser_basis,
       type_basis,
       lambda_environment,
       debugger_environment,
       debug_info} =>
d432 5
a436 6
      {parser_basis = ParserEnv.empty_pB,
       type_basis = type_basis,
       lambda_environment = lambda_environment,
       debugger_environment = debugger_environment,
       debug_info = debug_info}

d542 1
a542 1
		  {parser_basis, type_basis, debug_info, debugger_environment,
d599 1
a599 1
      val Compiler.BASIS {lambda_environment, debug_info, ...} = basis
d618 1
d1070 1
a1070 1
        val (new_project', result, new_module) =
d1072 2
a1073 2
	  of SOME (new_project', result, new_module, _) =>
	    (new_project', result, new_module)
d1077 1
a1077 1
	      (new_project, compiler_result, module)
d1088 5
a1092 1
	    {delta_basis = Compiler.make_external new_basis,
@


1.98
log
@Changed compilation of pervasives to generate debug_info.
@
text
@d11 3
a464 26
    val debugging_options =
      case Options.default_options of
	Options.OPTIONS
	  {listing_options, compiler_options, print_options,
	   compat_options, extension_options} =>
	case compiler_options of
	  Options.COMPILEROPTIONS
	    {generate_debug_info, debug_variables, generate_moduler,
	     intercept, interrupt, opt_handlers, 
	     opt_leaf_fns, opt_tail_calls, opt_self_calls} =>
	  Options.OPTIONS
	    {listing_options = listing_options,
	     print_options = print_options,
	     compat_options = compat_options,
	     extension_options = extension_options,
	     compiler_options =
	       Options.COMPILEROPTIONS
		 {generate_debug_info = true,
		  debug_variables = debug_variables,
		  generate_moduler = generate_moduler,
		  intercept = intercept,
		  interrupt = interrupt,
		  opt_handlers = opt_handlers,
		  opt_leaf_fns = opt_leaf_fns,
		  opt_tail_calls = opt_tail_calls,
		  opt_self_calls = opt_self_calls}}
d519 1
a519 1
	   debugging_options)
d580 1
a580 1
	     debugging_options)
d628 1
a628 1
	  (Compiler.augment (debugging_options, initial_basis, basis))
@


1.97
log
@Reinstated delete_module and delete_all_modules.
@
text
@d11 3
d462 27
d540 1
a540 1
	  (Info.make_default_options(),
d542 1
a542 1
	   Options.default_options)
d592 1
a592 1
	  (Info.make_default_options(),
d601 1
a601 1
	    (Info.make_default_options(),
d603 1
a603 1
	     Options.default_options)
d619 1
a619 1
      val Compiler.BASIS {lambda_environment, ...} = basis
d638 1
a638 1
                             debug_info, ...} = Compiler.initial_basis
d651 1
a651 1
	  (Compiler.augment (Options.default_options, initial_basis, basis))
d694 2
a695 1
              Compiler.add_debug_info (options, debug_info, compiler_basis)}
d902 1
a902 1
	    (Info.make_default_options (), location)
d909 1
a909 1
	    (Info.make_default_options (), location)
d998 1
a998 1
	    (Info.make_default_options (), Info.Location.FILE toplevel_name)
d1062 1
a1062 1
	    (Info.make_default_options (), Info.Location.FILE toplevel_name)
d1067 1
a1067 1
	    (Info.make_default_options (), Info.Location.FILE toplevel_name)
d1071 1
a1071 1
	  (* NONE => first call.  Use new_project and initial_compiler_basis. *)
d1075 1
a1075 1
	            (Info.make_default_options(),
d1083 1
a1083 1
	            (Info.make_default_options(), 
@


1.96
log
@Modifications to use new project stuff.
@
text
@d11 3
d936 2
d939 11
a949 17
    (*  === ADD A MAKE MODULE ===  *)

(*
    fun delete_module 
      (CONTEXT {topdec, compiler_basis, inter_env, signatures, modules})
       moduleid =
      CONTEXT {topdec=topdec, compiler_basis=compiler_basis, 
               inter_env=inter_env, signatures=signatures, 
               modules=InterMake.delete_module
			 (modules, moduleid, Info.make_default_options())}

    fun delete_all_modules (CONTEXT {topdec, compiler_basis, inter_env, signatures, modules},
                            preserve_pervasive) =
      CONTEXT {topdec=topdec, compiler_basis=compiler_basis, 
               inter_env=inter_env, signatures=signatures, 
               modules=if preserve_pervasive then initial_modules else InterMake.empty_modules}
*)
@


1.95
log
@Adding error handlers for load_file etc.
@
text
@d11 3
d334 1
d358 1
d370 1
d372 1
d380 4
a383 3
   sharing type Io.ModuleId = Module.ModuleId =
		InterMake.Compiler.Absyn.ModuleId = ModuleId.ModuleId
   sharing type InterMake.Compiler.DebuggerEnv = Environ.EnvironTypes.DebuggerEnv
d387 1
d407 2
d440 1
a440 2
    exception Error of InterMake.modules * Info.error * Info.error list
    exception Interrupted = InterMake.Interrupted
d446 1
a446 2
                  signatures		: (Ident.SigId, Absyn.SigExp) Map.T,
                  modules		: InterMake.modules}
d454 2
d458 1
a458 1
    (*  == Externalise lambda environment in a compiler basis ==  *)
d460 9
a468 7
    fun make_external (Compiler.BASIS {parser_basis, type_basis,
                                       lambda_environment, debugger_environment, debug_info}) =
      Compiler.BASIS {parser_basis = parser_basis,
                      type_basis = type_basis,
                      lambda_environment = Environ.make_external lambda_environment,
                      debugger_environment = debugger_environment,
                      debug_info = debug_info}
d470 1
d472 3
d476 4
a479 1
    (*  === THE INITIAL CONTEXT ===  *)
d481 2
a482 1
    local
d484 3
a486 5
      val make_options =
        InterMake.OPTIONS
        {error_info = Info.make_default_options(),
	 name_monitor = MLWorks.Option.NONE,
         options = Options.default_options}
d488 1
a488 1
      val modules = InterMake.empty_modules
d490 3
a492 2
      val _ = Io.set_source_path_from_env
		(Info.Location.FILE "Initial Context");
d494 1
d498 7
a504 7
      fun modify_runtime_modules(str, value, _) = (str, value)

      val _ = Stamp.reset_counter Basis.pervasive_stamp_count

      val (modules, builtin_library_result) =
	case
	  InterMake.make
d507 24
a530 8
	  make_options
	  (map modify_runtime_modules (!MLWorks.Internal.Runtime.modules), true)
	  (modules,
	   Io.builtin_library_id,
	   "Making BuiltIn Library")
	of (modules, InterMake.EXECUTE (result,_)) =>
	  (modules, result)
	| _ => Crash.impossible "Bad builtin library make result"
d532 5
a536 17
      val (builtin_library_result,debugger_environment) =
        let
          val InterMake.RESULT
	        {name, time, load_time, dependencies, compiler_result, module} =
	    builtin_library_result
          val Compiler.RESULT {basis, signatures, identifiers, code, id_cache} = compiler_result
          val Compiler.BASIS {parser_basis, type_basis, debug_info,
                              debugger_environment,...} = basis
        in
         (InterMake.RESULT
          {name = name, time = time, load_time = load_time, dependencies = dependencies, module = module, 
           compiler_result =
             Compiler.RESULT
             {signatures = signatures, identifiers = identifiers, code = code,id_cache = id_cache,
              basis =
                Compiler.BASIS
                {parser_basis = parser_basis, type_basis = type_basis, debug_info = debug_info,
d538 12
a549 7
                 debugger_environment = debugger_environment}}},
          debugger_environment)
        end

      val modules =
        InterMake.add_module
	  (modules, Io.builtin_library_name, builtin_library_result)
d551 2
d557 31
a587 22
      val (modules, pervasive_library_result) =
	case
	  InterMake.make
	  (fn y => y)
	  (Compiler.initial_basis, Inter_EnvTypes.empty_env)
	  make_options
	  (map modify_runtime_modules (!MLWorks.Internal.Runtime.modules), true)
	  (modules,
	   Io.pervasive_library_id,
	   (*
	   Module.MODULE (Io.get_pervasive_dir (), Io.pervasive_library_id),
	   *)
	   "Making Pervasive Library")
	of (modules, InterMake.EXECUTE (result,_)) =>
	  (modules, result)
	| _ => Crash.impossible "Bad pervasive library make result"

      val InterMake.RESULT
          {compiler_result = Compiler.RESULT {basis, signatures, ...},
	   module,
           ...} = pervasive_library_result
      val strid = Ident.STRID(Symbol.find_symbol"FullPervasiveLibrary_")
d589 7
a595 8
        let
          val Compiler.BASIS {lambda_environment, ...} = basis
        in
          Inter_EnvTypes.augment_with_module
            (Inter_EnvTypes.empty_env, lambda_environment, module)
          handle Inter_EnvTypes.Augment =>
            Crash.impossible "Module does not match generated environment"
        end
d597 2
d613 1
d617 2
a618 1
        make_external (Compiler.augment (Options.default_options, initial_basis, basis))
d626 10
a635 3
                 signatures = signatures,
                 modules = modules}
      val initial_modules = modules
d639 1
a639 1
	  (CONTEXT {compiler_basis, topdec, inter_env, signatures, modules}) =
a642 1
              modules=modules, 
d647 1
a647 1
	   CONTEXT {compiler_basis, topdec, inter_env, signatures, modules}) =
a650 1
              modules=modules, 
d656 1
a656 1
	   CONTEXT {compiler_basis, topdec, inter_env, signatures, modules}) =
a659 1
              modules=modules, 
d665 2
a666 1
    fun parser_basis (CONTEXT {compiler_basis = Compiler.BASIS {parser_basis, ...}, ...}) = parser_basis
d678 1
a678 2
	 signatures = Map.empty' Ident.sigid_lt,
	 modules = InterMake.empty_modules}
d680 1
d687 1
a687 1

a699 1
         modules: InterMake.modules,
d714 1
a714 1
       (CONTEXT {compiler_basis, inter_env, modules, ...}),
d747 1
a747 1
        val aug_compiler_basis = make_external topdec_compiler_basis
d757 8
a764 6
              let
                val InterMake.RESULT {module, ...} =
                  InterMake.lookup_module (modules, module_name)
              in
                module
              end
a785 1
 	   modules = modules,
d833 1
a833 1
	   CONTEXT{topdec,compiler_basis,signatures,inter_env,...},
d835 1
a835 1
	     {delta_basis, delta_signatures, modules, new_module, filename, ...}) =
d858 1
a858 2
                 inter_env = new_inter_env,
                 modules = modules}
d861 4
a864 3
    (* The mo loading functions should be rewritten to avoid multiple
       calls to find_mo for the same module name, and redundant conversions
       between module_ids and strings. *)
d866 42
a907 34
    (* We hope that all dependencies have been loaded at this point *)
    fun load_one_mo (module_id, modules, location) =
      let
	val mo_name = case Module.find_mo(module_id, Module.empty_cache) of
	  (MLWorks.Option.NONE, _) =>
	    raise MLWorks.Internal.Runtime.Loader.Load "cannot find mo file"
	| (MLWorks.Option.SOME(filename, _, _), _) => filename
	val _ = output (std_out, "Loading mo file " ^ mo_name ^ "\n")
	val (module_id', module) =
	  MLWorks.Internal.Runtime.Loader.load_module mo_name
	val intermake_result =
	  InterMake.get_mo_information
	  (module_id, module, modules, location)
	val InterMake.RESULT{compiler_result,...} = intermake_result
	val Compiler.RESULT{basis,identifiers,...} = compiler_result
	val compiler_basis = make_external basis
	val modules' =
	  InterMake.add_module (modules, module_id', intermake_result)
      in
	(compiler_basis,module,identifiers,modules')
      end
    handle MLWorks.Internal.Runtime.Loader.Load s =>
             fatality (Info.Location.FILE (ModuleId.string module_id),
                       "Load failed: " ^ s)
         | InterMake.GetMoInformation s =>
             fatality (Info.Location.FILE (ModuleId.string module_id),
                       "Load failed: " ^ s)

    fun load_dependencies location ((modules,done), modname) =
      if Lists.member (modname, done) then
	(modules, done)
      else
        let
	  val module_id = ModuleId.from_string (modname, location)
d909 1
a909 21
          val submodules = InterMake.get_mo_dependencies (module_id, location)
            handle InterMake.GetMoInformation s =>
              fatality (Info.Location.FILE modname, "Load failed: " ^ s)

          val (modules',done') =
	    Lists.reducel
	      (load_dependencies location)
	      ((modules,modname::done),submodules)

          val (_,_,_,modules'') =
	    load_one_mo
	      (ModuleId.from_string (modname, location), modules', location)
              handle Info.Stop (error,error_list) => raise Error (modules',error,error_list)
        in
          (modules'',done')
        end
        
    fun load_mo (options, context, moduleid, location) =
      let
	val modname = ModuleId.string moduleid
        val CONTEXT{modules,...} = context
d911 10
a920 22
        let
          val submodules =
            InterMake.get_mo_dependencies (moduleid, location)
            handle InterMake.GetMoInformation s =>
              fatality (Info.Location.FILE modname, "Load failed: " ^ s)
          val (modules,done) =
            Lists.reducel
	    (load_dependencies location)
	    ((modules, [modname]), submodules)
          val (delta_basis, new_module, identifiers, modules') =
            load_one_mo (moduleid, modules, location)
            handle Info.Stop (error,error_list) => raise Error (modules,error,error_list)
        in
          RESULT
	  {delta_basis = delta_basis,
	   delta_signatures = Map.empty' Ident.sigid_lt,
	   modules = modules',
	   new_module = new_module,
	   identifiers = identifiers,
	   filename = modname}
        end
        handle Info.Stop (error,error_list) => raise Error (modules,error,error_list)
d922 10
d936 1
d950 1
d954 2
a955 1
    val overload_var = Ident.VAR (Ident.Symbol.find_symbol "<overload function>")
d958 2
a959 3
  	  (OPTIONS {options, debugger, ...})
          monitor_fun
          (CONTEXT {modules, ...}, moduleid, toplevel_name) =
d964 6
a969 1
		  ["Checking make module `", ModuleId.string moduleid, "'"])
d971 1
a971 11
	case InterMake.make
	  debugger
	  (initial_compiler_basis, initial_inter_env)
	  (InterMake.OPTIONS
	     {error_info = Info.make_default_options(),
	      name_monitor = MLWorks.Option.SOME monitor_fun,
	      options = Options.set_no_execute options})
	  ([], false)
	  (modules, moduleid, toplevel_name)
	of (_, InterMake.NO_EXECUTE filelist) => filelist
	|  _ => Crash.impossible "EXECUTE returned in check_module"
a972 6
      handle
	InterMake.Error (_, error, error_list) =>
          (diagnostic (2, fn _ => ["Check make failed."]);
           raise Error (modules, error, error_list))
      | InterMake.Interrupted _ =>
          raise Interrupted modules
d975 2
a976 11
	  (OPTIONS
	     {options as Options.OPTIONS
		{compiler_options = Options.COMPILEROPTIONS
                 {generate_moduler, ...},
		 ...},
	      debugger,
	      ...})
          monitor_fun
          (CONTEXT {inter_env, modules, ...},
           moduleid,
           toplevel_name) =
d983 8
a990 1
        (* Here we have some crap to do with overload_var *)
d1008 3
a1010 1
			(Environ.add_valid_env (Environ.empty_env, (overload_var, EnvironTypes.EXTERNAL)),
d1020 4
a1023 3
            Inter_EnvTypes.add_val (initial_inter_env,
                                    (overload_var,
                                     Inter_EnvTypes.lookup_val (overload_var,inter_env)))
d1025 2
a1026 1
            handle Map.Undefined => Crash.impossible "<overload function> not defined"
d1030 39
a1068 1
	val basis = initial_compiler_basis
d1070 1
a1070 1
	val inter_env = initial_inter_env
d1072 6
a1077 22
	case InterMake.make
	  debugger
	  (basis, inter_env)
	  (InterMake.OPTIONS
	     {error_info = Info.make_default_options(),
	      name_monitor = MLWorks.Option.SOME monitor_fun,
	      options = options})
	  ([], false)
	  (modules, moduleid, toplevel_name)
	of (modules',
	    InterMake.EXECUTE
	      (InterMake.RESULT
	         {compiler_result =
	            Compiler.RESULT
		      {basis = new_basis,
		       signatures = new_signatures,
		       identifiers, ...},
		  module,
		  ...},
               _)) =>
          RESULT
	    {delta_basis = make_external new_basis,
d1079 1
a1079 2
	     modules = modules',
	     new_module = module,
a1081 2
	|  _ =>
	  Crash.impossible "NO_EXECUTE returned in add_module"
d1084 1
a1084 1
	InterMake.Error (new_modules, error, error_list) =>
d1088 5
a1092 3
           raise Error (new_modules, error, error_list))
      | InterMake.Interrupted new_modules =>
          raise Interrupted new_modules
d1108 1
a1108 2
                   signatures,
                   modules} = context
d1134 1
a1134 2
                  signatures = signatures,
                  modules = modules},
d1180 1
a1180 1
                   inter_env, signatures, modules} = context
d1199 1
a1199 2
                  signatures = signatures,
                  modules = modules},
@


1.94
log
@Moved identifier to Ident
@
text
@d11 3
d427 4
a430 1
      (Info.FATAL, location, "Incremental: " ^ message)
d839 5
a843 2
      fatality (Info.Location.FILE (ModuleId.string module_id),
		"Load failed: " ^ s)
d853 1
a853 1
            handle MLWorks.Internal.Runtime.Loader.Load s =>
d864 1
d873 8
a880 6
        val submodules =
	  InterMake.get_mo_dependencies (moduleid, location)
          handle MLWorks.Internal.Runtime.Loader.Load s =>
            fatality (Info.Location.FILE modname, "Load failed: " ^ s)
        val (modules,done) =
	  Lists.reducel
d883 5
a887 4
        val (delta_basis, new_module, identifiers, modules') =
	  load_one_mo (moduleid, modules, location)
      in
        RESULT
d894 2
d898 1
a899 3

    exception Error of InterMake.modules * Info.error * Info.error list
    exception Interrupted = InterMake.Interrupted
@


1.93
log
@Adding delete_all_modules
@
text
@d11 3
d646 1
a646 1
	 identifiers: InterMake.Compiler.identifier list,
d1075 1
a1075 1
        [Compiler.VALUE ident])
d1141 1
a1141 1
        [Compiler.STRUCTURE ident])
@


1.92
log
@Removing crash function
@
text
@d11 3
d575 1
d893 2
a894 1
    fun delete_all_modules (CONTEXT {topdec, compiler_basis, inter_env, signatures, modules}) =
d897 1
a897 1
               modules=InterMake.empty_modules}
@


1.91
log
@Make mo loading use object_path
@
text
@d11 3
a419 5
    fun crash (location, message) =
      Info.error'
      (Info.make_default_options ())
      (Info.FAULT, location, "Incremental: " ^ message)

d481 1
a481 1
	| _ => Crash.impossible"Bad builtin library make result"
d542 1
a542 2
            crash (Info.Location.FILE "Pervasive Library",
		   "Module does not match generated environment")
d765 1
a765 1
            | _ => crash (Info.Location.UNKNOWN,"Wrong number of bindings in evaluate_exp_topdec")
d790 1
a790 2
              crash (Info.Location.FILE filename,
		     "Module does not match generated environment")
@


1.90
log
@Io.set_source_path_from_env now takes a location.
@
text
@d11 3
d810 22
a831 19
	 let
	   val mo_name = ModuleId.to_host (module_id, "mo")
           val _ = output (std_out, "Loading mo file " ^ mo_name ^ "\n")
           val (module_id', module) =
	     MLWorks.Internal.Runtime.Loader.load_module (mo_name)
           val intermake_result =
	     InterMake.get_mo_information
	       (module_id, module, modules, location)
           val InterMake.RESULT{compiler_result,...} = intermake_result
           val Compiler.RESULT{basis,identifiers,...} = compiler_result
           val compiler_basis = make_external basis
           val modules' =
	     InterMake.add_module (modules, module_id', intermake_result)
         in
           (compiler_basis,module,identifiers,modules')
         end
         handle MLWorks.Internal.Runtime.Loader.Load s =>
           fatality (Info.Location.FILE (ModuleId.string module_id),
		     "Load failed: " ^ s)
@


1.89
log
@Replacing Tyfun_id etc. with Stamp
@
text
@d11 3
d361 1
a361 1
   sharing type ParserEnv.Ident.Location.T = ModuleId.Location
d458 2
a459 1
      val _ = Io.set_source_path_from_env ();
@


1.88
log
@Merged identifier list with Result type.
@
text
@d11 3
d315 1
d328 1
d359 2
d462 1
a462 4
      val _ =
        (Datatypes.Tyname_id.reset_counter Basis.pervasive_tyname_count;
         Datatypes.Tyfun_id.reset_counter Basis.pervasive_tyfun_count;
         Datatypes.Strname_id.reset_counter Basis.pervasive_strname_count)
d882 5
@


1.87
log
@Removing (some) stepper variables
@
text
@d11 3
d631 1
d634 2
d711 7
a717 7
        (RESULT
	   {delta_basis = aug_compiler_basis,
 	    delta_signatures = aug_signatures,
	    new_module = module,
 	    modules = modules,
	    filename = filename},
         identifiers)
d742 1
a742 1
            val (RESULT {delta_basis, new_module, ...},_) =
d765 1
a765 1
	     {delta_basis, delta_signatures, modules, new_module, filename}) =
d857 7
a863 7
        (RESULT
	   {delta_basis = delta_basis,
	    delta_signatures = Map.empty' Ident.sigid_lt,
	    modules = modules',
	    new_module = new_module,
	    filename = modname},
	 identifiers)
d990 7
a996 7
          (RESULT
	     {delta_basis = make_external new_basis,
	      delta_signatures = new_signatures,
	      modules = modules',
	      new_module = module,
	      filename = ModuleId.string moduleid},
	   identifiers)
@


1.86
log
@Improvements to interface to typechecker
@
text
@d11 3
a872 10
    (* stepper_vars and overload_var are used in add_module,
       if generate_stepper and generate_moduler are set, respectively. *)
    val stepper_vars =
      map
        (Ident.VAR o Ident.Symbol.find_symbol)
        ["step function",
         "breakpoint function",
         "breakpoint_on_exit function",
         "step handler function"]

a876 42
  (* This is horrible *)
  fun set_no_execute (Options.OPTIONS{listing_options,
                                      compiler_options,
                                      print_options,
                                      compat_options,
                                      extension_options
                                      }) =
    let val Options.COMPILEROPTIONS {debug,
                                     debug_variables,
                                     debug_polyvariables,
                                     generate_stepper,
                                     generate_moduler,
                                     generate_stepper_specific,
                                     no_execute,
                                     intercept,
                                     interrupt,
                                     opt_leaf_fns,
                                     opt_tail_calls,
                                     opt_self_calls} = compiler_options
      val new_compiler_options = 
        Options.COMPILEROPTIONS
        {debug = debug,
         debug_variables = debug_variables,
         debug_polyvariables = debug_polyvariables,
         generate_stepper = generate_stepper,
         generate_moduler = generate_moduler,
         generate_stepper_specific = generate_stepper_specific,
         no_execute = true,  (* Aha!! *)
         intercept = intercept,
         interrupt = interrupt,
         opt_leaf_fns = opt_leaf_fns,
         opt_tail_calls = opt_tail_calls,
         opt_self_calls = opt_self_calls} 
    in
      Options.OPTIONS
      {listing_options = listing_options,
       compiler_options = new_compiler_options,
       print_options = print_options,
       compat_options = compat_options,
       extension_options = extension_options}
    end

d893 1
a893 1
	      options = set_no_execute options})
d910 1
a910 1
		   {generate_stepper, generate_moduler, ...},
d924 1
d942 1
a942 3
			(Environ.add_valid_env
			   (Environ.empty_env,
                              (overload_var, EnvironTypes.EXTERNAL)),
d952 3
a954 4
            Inter_EnvTypes.add_val
	      (initial_inter_env,
	       (overload_var,
	        Inter_EnvTypes.lookup_val (overload_var,inter_env)))
d960 1
a960 21
	val basis =
          if generate_stepper then
	    let val valid_env =
		  Lists.reducel
		    (fn (env, var) =>
		       Environ.add_valid_env
		         (env, (var, EnvironTypes.EXTERNAL)))
		    (Environ.empty_env, stepper_vars)
	    in
              Compiler.BASIS
	        {parser_basis = parser_basis,
                 type_basis = type_basis,
                 lambda_environment = 
		   Environ.augment_top_env
		     (lambda_environment,
                      EnvironTypes.TOP_ENV (valid_env, Environ.empty_fun_env)),
                 debugger_environment=debugger_environment,
                 debug_info=debug_info}
	    end
          else
	    initial_compiler_basis
d962 1
a962 10
	val inter_env =
          if generate_stepper then
	    Lists.reducel
	      (fn (env, var) =>
		 Inter_EnvTypes.add_val
		   (env, (var, Inter_EnvTypes.lookup_val (var, inter_env)))
                   handle Map.Undefined => Crash.impossible "Some stepper variable not defined")
	      (initial_inter_env, stepper_vars)
          else
	    initial_inter_env
@


1.85
log
@Removed horrible UNIX-dependent hack of module names.
@
text
@d11 3
a304 2
require "../typechecker/valenv";
require "../typechecker/strenv";
a305 1
require "../typechecker/types";
a316 2
   structure Valenv : VALENV
   structure Strenv : STRENV
a317 1
   structure Types : TYPES
d329 1
a329 2
   sharing Basis.BasisTypes.Datatypes = Valenv.Datatypes = Strenv.Datatypes
   sharing ParserEnv.Map = Valenv.Datatypes.NewMap
d450 3
a452 3
        (Datatypes.Tyname_id.reset_counter Types.pervasive_tyname_count;
         Datatypes.Tyfun_id.reset_counter Types.pervasive_tyfun_count;
         Datatypes.Strname_id.reset_counter Strenv.pervasive_strname_count)
d602 1
a602 1
	 signatures = Map.empty' Datatypes.Ident.sigid_lt,
d1092 1
a1092 2
                      type_basis = BasisTypes.BASIS (level, nameset, functor_env, signature_env,
                                           Datatypes.ENV (structure_env, type_env, value_env)),
d1099 2
a1100 3
	val ident = Datatypes.Ident.VAR
		      (Datatypes.Ident.Symbol.find_symbol identifier)
        val new_value_env = Valenv.add_to_ve (ident, scheme, value_env)
d1118 1
a1118 2
                     type_basis = BasisTypes.BASIS (level, nameset, functor_env, signature_env,
                                        Datatypes.ENV (structure_env, type_env, new_value_env)),
d1167 1
a1167 2
                      type_basis = BasisTypes.BASIS (level,nameset, functor_env, signature_env,
                                                Datatypes.ENV (structure_env, type_env, value_env)),
d1172 5
a1176 3
        val ident = Datatypes.Ident.STRID (Datatypes.Ident.Symbol.find_symbol identifier)
        val new_structure_env = Strenv.add_to_se (ident, str, structure_env)
        val new_lambda_env = Environ.add_strid_env (lambda_env, (ident, (Environ.make_str_env (str,false), EnvironTypes.EXTERNAL,false)))
d1185 1
a1185 2
                     type_basis = BasisTypes.BASIS (level,nameset, functor_env, signature_env,
                                               Datatypes.ENV (new_structure_env, type_env, value_env)),
@


1.84
log
@Debugger changes
@
text
@d11 3
d351 1
d788 3
a790 7
    (* The munging of filenames in the following functions is horrible.
       They should use the Module and ModuleId functors.  - daveb, 28/7/94. *)

    fun mo_name s = s ^ ".mo"

    fun trans_filename name =
      implode (map (fn "." => "/" | c => c) (explode name))
a791 1

d793 24
a816 23
    fun load_one_mo (modname,modules,location) =
      let
	val modname = trans_filename modname
        val _ = output (std_out, "Loading mo file " ^ mo_name modname ^ "\n")
        val (module_id,module) = MLWorks.Internal.Runtime.Loader.load_module (mo_name modname)
        val intermake_result = InterMake.get_mo_information (modname,module,modules,location)
        val InterMake.RESULT{compiler_result,...} = intermake_result
        val Compiler.RESULT{basis,identifiers,...} = compiler_result
        val compiler_basis = make_external basis
        val modules' = InterMake.add_module (modules,module_id,intermake_result)
      in
        (compiler_basis,module,identifiers,modules')
      end
      handle MLWorks.Internal.Runtime.Loader.Load s =>
        fatality (Info.Location.FILE modname, "Load failed: " ^ s)

    val pervasives = ["__pervasive_library","__builtin_library","mlworks","bits","string","bytearray","vector","array"]

    fun is_perv modname = Lists.member (modname,pervasives)
      
    fun load_dependencies location ((modules,done),modname) =
      if Lists.member (modname,done) orelse is_perv modname
        then (modules,done)
d819 3
a821 1
          val submodules = InterMake.get_mo_dependencies (modname,location)
d824 9
a832 2
          val (modules',done') = Lists.reducel (load_dependencies location) ((modules,modname::done),submodules)
          val (_,_,_,modules'') = load_one_mo (modname,modules',location)
d842 1
a842 1
	  InterMake.get_mo_dependencies (modname,location)
d850 1
a850 1
	  load_one_mo (modname, modules, location)
@


1.83
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d11 3
d875 3
a877 2
    val overload_var =
      Ident.VAR (Ident.Symbol.find_symbol ("overload function"))
d1001 2
d1033 2
a1034 1
		   (env, (var, Inter_EnvTypes.lookup_val (var, inter_env))))
@


1.82
log
@Changing uses of cast
@
text
@d11 3
a341 1
   sharing type Io.Directory = Module.Directory
a361 1
    structure Option = InterMake.Option
d434 1
a434 1
	 name_monitor = Option.ABSENT,
d789 1
d793 1
a793 1
        val modname = trans_filename modname
d932 1
a932 1
	      name_monitor = Option.PRESENT monitor_fun,
d1037 1
a1037 1
	      name_monitor = Option.PRESENT monitor_fun,
@


1.81
log
@Change to Basis.lookup_val
@
text
@d11 3
d412 2
d740 1
a740 1
            val val_list : MLWorks.Internal.Value.T list = MLWorks.Internal.Value.cast new_module
@


1.80
log
@Renamed SourceResult to Result, and made it a datatype with a record
argument instead of a tuple.  Added a modules field for returning the
updated modules table, which fixed a bug in the behaviour of make.
@
text
@d11 5
d731 4
a734 5
            val ittype = #1(Basis.lookup_val (Ident.NOPATH,
                                           Ident.VAR(Symbol.find_symbol"it"),
                                           Basis.basis_to_context type_basis,
					   Info.Location.UNKNOWN,
					   false))
@


1.79
log
@Moved preferences out of options structures.
@
text
@d11 3
a597 1
    (*  === COMPILE SOURCE CODE INTO A CONTEXT ===  *)
d599 13
a611 5
    type SourceResult = 
        Compiler.basis * 
        (Ident.SigId,Absyn.SigExp) Map.T *
        MLWorks.Internal.Value.T *
        string
d613 2
a614 1
    fun pb_from_result(Compiler.BASIS {parser_basis, ...}, _, _, _) =
d617 2
d688 6
a693 1
        ((aug_compiler_basis,aug_signatures,module,filename),
d719 1
a719 1
            val ((aug_compiler_basis,_,module,_),_) =
d725 1
a725 1
            val Compiler.BASIS{type_basis,...} = aug_compiler_basis
d731 1
a731 1
            val val_list : MLWorks.Internal.Value.T list = MLWorks.Internal.Value.cast module
d741 3
a743 2
	   CONTEXT{topdec,compiler_basis,signatures,inter_env,modules},
           (aug_compiler_basis,aug_signatures,module,filename)) =
d746 2
a747 1
	  Compiler.augment (options, compiler_basis, aug_compiler_basis)
d749 1
a749 1
	  Map.merge (fn (old, new) => new) (signatures, aug_signatures)
d755 1
a755 1
            val Compiler.BASIS {lambda_environment, ...} = aug_compiler_basis
d758 1
a758 1
	      (inter_env, lambda_environment, module)
d826 1
a826 1
        val (aug_compiler_basis,module,identifiers,modules') =
d829 6
a834 1
        ((aug_compiler_basis, Map.empty' Ident.sigid_lt, module, modname),
d1016 1
a1016 1
		   (env, (var, Inter_EnvTypes.lookup_val (var, env))))
d1030 1
a1030 1
	of (_,
d1035 3
a1037 1
		      {basis, signatures = module_signatures, identifiers, ...},
d1041 6
a1046 2
          ((make_external basis, module_signatures, module,
	    ModuleId.string moduleid),
@


1.78
log
@Made load_mo return a SourceResult value.
@
text
@d11 3
d844 1
a844 3
                                      extension_options,
                                      editor_options,
                                      environment_options
d878 1
a878 3
       extension_options = extension_options,
       editor_options = editor_options,
       environment_options = environment_options}
@


1.77
log
@Moved set_no_execute here from _shell_utils, so that add_module and
check_module don't have to check that the option is set correctly.
@
text
@d11 4
d748 2
a749 1
    (* This augments the module component of the context *)
a750 7
    fun set_modules (CONTEXT{topdec,compiler_basis,signatures,inter_env,modules},new_modules) =
      CONTEXT {topdec = topdec+1,
               compiler_basis = compiler_basis,
               signatures = signatures,
               inter_env = inter_env,
               modules = new_modules}
      
d803 1
a803 1
        val (compiler_basis,module,identifiers,modules') =
a804 1
        val context' = set_modules (context, modules')
d806 2
a807 5
        (add_definitions
	   (options, context',
	     (compiler_basis, Map.empty' Ident.sigid_lt, module, modname ^ ".sml")),
	 identifiers,
	 compiler_basis)
d1006 1
a1006 1
	of (modules,
@


1.76
log
@Removed inter_env component of InterMake.Result type.
@
text
@d11 3
d842 46
d889 1
a889 7
	  (inc_options as OPTIONS
	     {options as Options.OPTIONS
		{compiler_options = Options.COMPILEROPTIONS
		   {no_execute, ...},
		 ...},
	      debugger,
	      ...})
d891 1
a891 1
          (context as CONTEXT {modules, ...}, moduleid, toplevel_name) =
d894 3
a896 6
	  if not no_execute then
	    Crash.impossible "check_module called when no_execute is false"
	  else
	    diagnostic
	      (2, fn _ =>
		    ["Checking make module `", ModuleId.string moduleid, "'"])
d904 1
a904 1
	      options = options})
d918 1
a918 1
	  (inc_options as OPTIONS
d921 1
a921 1
		   {no_execute, generate_stepper, generate_moduler, ...},
d926 1
a926 2
          (context as CONTEXT
	     {topdec, compiler_basis, inter_env, signatures, modules},
d931 3
a933 6
	  if no_execute then
	    Crash.impossible "add_module called when no_execute is true"
	  else
	    diagnostic
	      (2, fn _ =>
		    ["Adding make module `", ModuleId.string moduleid, "'"])
@


1.75
log
@Changed add_module to return a SourceResult, so that it can be used to
build both a full context and a delta context.  Took the no_execute
functionality out of add_module and put it in a separate function
(check_module).  Made some of the debugger code readable.
@
text
@d11 6
d443 3
a445 2
          val InterMake.RESULT {name, time, load_time, dependencies, compiler_result, module, 
                                inter_env} = builtin_library_result
a451 1
           inter_env = inter_env,
d490 1
a490 1
           inter_env,
d493 10
@


1.74
log
@Update debugger information production
@
text
@d11 3
d572 4
a575 4
      Compiler.basis * 
      (Ident.SigId,Absyn.SigExp) Map.T *
      MLWorks.Internal.Value.T *
      string
d577 2
a578 1
    fun pb_from_result(Compiler.BASIS {parser_basis, ...}, _, _, _) = parser_basis
d695 4
a698 3
    fun add_definitions (options,
			 CONTEXT{topdec,compiler_basis,signatures,inter_env,modules},
                         (aug_compiler_basis,aug_signatures,module,filename)) =
d702 2
a703 1
        val new_signatures = Map.merge (fn (old, new) => new) (signatures, aug_signatures)
d711 2
a712 1
            Inter_EnvTypes.augment_with_module (inter_env, lambda_environment, module)
d714 2
a715 1
              crash (Info.Location.FILE filename, "Module does not match generated environment")
a724 25
    fun add_definitions' (options,
			  CONTEXT{topdec,compiler_basis,signatures,inter_env,modules},
                          aug_compiler_basis,module,filename) =
      let
        val new_compiler_basis =
	  Compiler.augment (options, compiler_basis, aug_compiler_basis)

        (* Incorporate the results of the loading into the interpreter *)
        (* environment to form the result context. *)
        val new_inter_env =
          let
            val Compiler.BASIS {lambda_environment, ...} = aug_compiler_basis
          in
            Inter_EnvTypes.augment_with_module (inter_env, lambda_environment, module)
            handle Inter_EnvTypes.Augment =>
              crash (Info.Location.FILE filename, "Module does not match generated environment")
          end
      in
        CONTEXT {topdec = topdec+1,
                 compiler_basis = new_compiler_basis,
                 signatures = signatures,
                 inter_env = new_inter_env,
                 modules = modules}
      end

d790 5
a794 3
        (add_definitions'
	   (options, context', compiler_basis, module, modname ^ ".sml"), identifiers,
	   compiler_basis)
d810 23
a832 10
    fun add_module (inc_options as OPTIONS
		    {options as Options.OPTIONS
		     {compiler_options = Options.COMPILEROPTIONS{no_execute,
                                                                 generate_stepper, generate_moduler, ...}, ...},
		     debugger, ...})
                   monitor_fun
                   (context as
		    CONTEXT {topdec, compiler_basis, inter_env, signatures, modules},
                    moduleid,
                    toplevel_name) =
d834 7
a840 1
        val _ = diagnostic (2, fn _ => ["Adding make module `", ModuleId.string moduleid, "'"])
d842 1
a842 1
	(case InterMake.make
d844 5
a848 48
           let
             val (initial_compiler_basis as Compiler.BASIS{parser_basis,
                                  type_basis,
                                  lambda_environment,
                                  debugger_environment,
                                  debug_info} , initial_inter_env) =
	  (if generate_moduler then
             let
               val Compiler.BASIS{parser_basis,
                                  type_basis,
                                  lambda_environment,
                                  debugger_environment,
                                  debug_info} = initial_compiler_basis
             in
               Compiler.BASIS{parser_basis=parser_basis,
                                 type_basis=type_basis,
                                 lambda_environment=Environ.augment_top_env(lambda_environment,
                                   EnvironTypes.TOP_ENV(Environ.add_valid_env(Environ.empty_env,
                                            (Ident.VAR(Ident.Symbol.find_symbol("overload function")),
                                             EnvironTypes.EXTERNAL)),Environ.empty_fun_env)),
                                 debugger_environment=debugger_environment,
                                 debug_info=debug_info}
             end
           else initial_compiler_basis, 
             if generate_moduler then
               Inter_EnvTypes.add_val(initial_inter_env,(Ident.VAR(Ident.Symbol.find_symbol("overload function")),Inter_EnvTypes.lookup_val(Ident.VAR(Ident.Symbol.find_symbol("overload function")),inter_env)))
             else initial_inter_env)
           in
            (if generate_stepper then
               Compiler.BASIS{parser_basis=parser_basis,
                                 type_basis=type_basis,
                                 lambda_environment=Environ.augment_top_env(lambda_environment,
                                   EnvironTypes.TOP_ENV(Environ.add_valid_env(Environ.add_valid_env(Environ.add_valid_env(Environ.add_valid_env(Environ.empty_env,
                                            (Ident.VAR(Ident.Symbol.find_symbol("step function")),
                                             EnvironTypes.EXTERNAL)),(Ident.VAR(Ident.Symbol.find_symbol("breakpoint function")),
                                             EnvironTypes.EXTERNAL)),(Ident.VAR(Ident.Symbol.find_symbol("breakpoint_on_exit function")),
                                             EnvironTypes.EXTERNAL)),(Ident.VAR(Ident.Symbol.find_symbol("step handler function")),
                                             EnvironTypes.EXTERNAL)),Environ.empty_fun_env)),
                                 debugger_environment=debugger_environment,
                                 debug_info=debug_info}
           else initial_compiler_basis, 
             if generate_stepper then
               Inter_EnvTypes.add_val(Inter_EnvTypes.add_val(Inter_EnvTypes.add_val(Inter_EnvTypes.add_val(initial_inter_env,(Ident.VAR(Ident.Symbol.find_symbol("step function")),Inter_EnvTypes.lookup_val(Ident.VAR(Ident.Symbol.find_symbol("step function")),inter_env))),(Ident.VAR(Ident.Symbol.find_symbol("breakpoint function")),Inter_EnvTypes.lookup_val(Ident.VAR(Ident.Symbol.find_symbol("breakpoint function")),inter_env))),(Ident.VAR(Ident.Symbol.find_symbol("breakpoint_on_exit function")),Inter_EnvTypes.lookup_val(Ident.VAR(Ident.Symbol.find_symbol("breakpoint_on_exit function")),inter_env))),(Ident.VAR(Ident.Symbol.find_symbol("step handler function")),Inter_EnvTypes.lookup_val(Ident.VAR(Ident.Symbol.find_symbol("step handler function")),inter_env)))
             else initial_inter_env)
           end
	  (InterMake.OPTIONS{error_info = Info.make_default_options(),
			     name_monitor = Option.PRESENT monitor_fun,
			     options = options})
d850 124
a973 17
	  (modules, moduleid, toplevel_name) of
	  (modules,
	   InterMake.EXECUTE
	   (InterMake.RESULT
	    {compiler_result =
	     Compiler.RESULT {basis, signatures = module_signatures, identifiers, ...},
	     inter_env = module_inter_env, ...},
            filelist)) =>
	  (CONTEXT {topdec = topdec,
		    compiler_basis = Compiler.augment (options, compiler_basis, make_external basis),
		    inter_env = Inter_EnvTypes.augment (inter_env, module_inter_env),
		    signatures = Map.merge (fn (old, new) => new) (signatures, module_signatures),
		    modules = modules},
	  identifiers,
          filelist, basis)
	| (_,InterMake.NO_EXECUTE filelist) =>
	    (context, [], filelist, empty_compiler_basis))
d975 8
a982 9
      handle InterMake.Error (new_modules, error,error_list) =>
        (diagnostic (2, fn _ => ["Make failed.  Returning partially updated context."]);
         raise Error
	   (if no_execute then modules else new_modules,
	    error,
	    error_list))
        | InterMake.Interrupted new_modules =>
            raise Interrupted
              (if no_execute then modules else new_modules)
@


1.73
log
@ Added empty context (initial contexts aren't empty).
Changed Context components of Error and Interrupted exceptions to a set
of new modules, so that the user_context can be updated appropriately.
Added update_modules to aid this task.
@
text
@d11 6
d502 1
a502 1
        make_external (Compiler.augment (initial_basis, basis))
d533 1
a533 1
	  (debug_info,
d540 1
a540 1
              Compiler.add_debug_info (debug_info, compiler_basis)}
d615 1
a615 1
	  Compiler.augment (compiler_basis, topdec_compiler_basis)
d691 2
a692 1
    fun add_definitions (CONTEXT{topdec,compiler_basis,signatures,inter_env,modules},
d695 2
a696 1
        val new_compiler_basis = Compiler.augment (compiler_basis, aug_compiler_basis)
d717 2
a718 1
    fun add_definitions' (CONTEXT{topdec,compiler_basis,signatures,inter_env,modules},
d721 2
a722 1
        val new_compiler_basis = Compiler.augment (compiler_basis, aug_compiler_basis)
d791 1
a791 1
    fun load_mo (context, moduleid, location) =
d808 1
a808 1
	   (context', compiler_basis, module, modname ^ ".sml"), identifiers,
d898 1
a898 1
		    compiler_basis = Compiler.augment (compiler_basis, make_external basis),
@


1.72
log
@Breakpoint settings on function exits.
@
text
@d11 3
a420 3
	   (*
	   Module.MODULE (Io.get_pervasive_dir (), Io.builtin_library_id),
	   *)
d545 14
d573 2
a574 1
       CONTEXT {topdec, compiler_basis, inter_env, signatures, modules}, source) =
d608 2
a609 1
        val Compiler.BASIS{debug_info,...} = Compiler.augment (compiler_basis, topdec_compiler_basis)
d804 2
a805 2
    exception Error of Context * Info.error * Info.error list
    exception Interrupted of Context
d897 1
a897 1
      handle InterMake.Error (modules, error,error_list) =>
d900 4
a903 7
	   ((if no_execute then context
	     else
	       CONTEXT {topdec = topdec, compiler_basis = compiler_basis,
			inter_env = inter_env, signatures = signatures, modules = modules}),
	       error,
	       error_list))
        | InterMake.Interrupted modules =>
d905 1
a905 5
              (if no_execute
                 then context
               else
                 CONTEXT {topdec = topdec, compiler_basis = compiler_basis,
                          inter_env = inter_env, signatures = signatures, modules = modules})
@


1.71
log
@Basis.lookup_val now takes an extra argument.
Also added a sharing constraint.
@
text
@d11 4
d846 1
a846 1
                                   EnvironTypes.TOP_ENV(Environ.add_valid_env(Environ.add_valid_env(Environ.add_valid_env(Environ.empty_env,
d849 1
d856 1
a856 1
               Inter_EnvTypes.add_val(Inter_EnvTypes.add_val(Inter_EnvTypes.add_val(initial_inter_env,(Ident.VAR(Ident.Symbol.find_symbol("step function")),Inter_EnvTypes.lookup_val(Ident.VAR(Ident.Symbol.find_symbol("step function")),inter_env))),(Ident.VAR(Ident.Symbol.find_symbol("breakpoint function")),Inter_EnvTypes.lookup_val(Ident.VAR(Ident.Symbol.find_symbol("breakpoint function")),inter_env))),(Ident.VAR(Ident.Symbol.find_symbol("step handler function")),Inter_EnvTypes.lookup_val(Ident.VAR(Ident.Symbol.find_symbol("step handler function")),inter_env)))
@


1.70
log
@Add function to give parser basis from source result
@
text
@d11 3
d287 1
d654 3
a656 1
                                           Basis.basis_to_context type_basis,false))
@


1.69
log
@Changed add_module and delete_module and load_mo to take ModuleIds.
@
text
@d11 3
d318 15
d546 2
d772 2
a773 1
	   (context', compiler_basis, module, modname ^ ".sml"), identifiers)
d866 1
a866 1
          filelist)
d868 1
a868 1
	    (context, [], filelist))
@


1.68
log
@Added add_debug_info
add_module returns a file list
@
text
@d11 4
d242 1
d269 1
a288 1
   sharing type InterMake.Module = Module.Module
d290 2
a291 1
   sharing type Io.ModuleId = Module.ModuleId
d313 1
a313 1
    type Module = Module.Module
d391 2
d394 1
d438 2
d441 1
d735 1
a735 1
    fun load_mo (context,modname,location) =
d737 1
d739 2
a740 1
        val submodules = InterMake.get_mo_dependencies (modname,location)
d743 7
a749 3
        val (modules,done) = Lists.reducel (load_dependencies location) ((modules,[modname]),submodules)
        val (compiler_basis,module,identifiers,modules') = load_one_mo (modname,modules,location)
        val context' = set_modules (context,modules')
d751 2
a752 1
        (add_definitions' (context',compiler_basis,module,modname ^ ".sml"),identifiers)
d761 2
a762 2
      (CONTEXT {topdec, compiler_basis, inter_env, signatures, modules},
       filename) =
d765 2
a766 1
               modules=InterMake.delete_module(modules,filename,Info.make_default_options())}
d776 1
a776 1
                    module,
d779 1
a779 1
        val _ = diagnostic (2, fn _ => ["Adding make module `", Module.sml_name module, "'"])
d831 1
a831 1
	  (modules, module, toplevel_name) of
@


1.67
log
@Put load_time back in InterMake.Result
@
text
@d11 3
d387 1
a387 1
	of (modules, InterMake.EXECUTE result) =>
d431 1
a431 1
	of (modules, InterMake.EXECUTE result) =>
d488 10
d817 2
a818 1
	     inter_env = module_inter_env, ...})) =>
d824 4
a827 3
	  identifiers)
	| (_,InterMake.NO_EXECUTE _) =>
	    (context, [](* This may be wrong? *)))
@


1.66
log
@Debugger environments for Modules Debugger.
@
text
@d11 3
d390 1
a390 1
          val InterMake.RESULT {name, time, dependencies, compiler_result, module, 
d397 1
a397 1
          {name = name, time = time, dependencies = dependencies, module = module, 
@


1.65
log
@Adding clear_debug functionality.
@
text
@d11 3
d280 1
d337 2
a338 1
    fun make_external (Compiler.BASIS {parser_basis, type_basis, lambda_environment, debug_info}) =
d342 1
d385 1
a385 1
      val builtin_library_result =
d389 3
a391 2
          val Compiler.RESULT {basis, signatures, identifiers, code,id_cache} = compiler_result
          val Compiler.BASIS {parser_basis, type_basis, debug_info, ...} = basis
d393 1
a393 1
          InterMake.RESULT
d402 3
a404 1
                 lambda_environment = Compiler.builtin_lambda_environment}}}
a433 1
      val basis = Compiler.remove_str(basis, strid)
d436 15
d452 1
a452 1
        make_external (Compiler.augment (Compiler.initial_basis, basis))
d602 1
a602 1
                                           Basis.basis_to_context type_basis))
d734 2
a735 1
		     {compiler_options = Options.COMPILEROPTIONS{no_execute, ...}, ...},
d747 44
a790 1
	  (initial_compiler_basis, initial_inter_env)
d837 2
a838 2
                      type_basis = BasisTypes.BASIS (level,nameset, functor_env, signature_env,
                                                Datatypes.ENV (structure_env, type_env, value_env)),
d840 1
d851 3
d865 5
a869 3
                     type_basis = BasisTypes.BASIS (level,nameset, functor_env, signature_env,
                                               Datatypes.ENV (structure_env, type_env, new_value_env)),
                     lambda_environment = EnvironTypes.TOP_ENV (new_lambda_env, lambda_functor_env),
d918 1
d923 2
a924 1
        val new_lambda_env = Environ.add_strid_env (lambda_env, (ident, (Environ.make_str_env str, EnvironTypes.EXTERNAL)))
d935 1
@


1.64
log
@_add_module now takes a Module argument instead of a file name.
@
text
@d11 3
d441 2
a442 1
    fun clear_debug_info (CONTEXT {compiler_basis, topdec, inter_env, signatures, modules}) =
d447 1
a447 1
              compiler_basis = Compiler.clear_debug_info compiler_basis}
d449 9
@


1.63
log
@Better locations in error messages
@
text
@d11 3
d225 1
a225 1
require "../basics/module_id";
d251 1
a251 1
   structure ModuleId : MODULE_ID
d271 3
a273 1
   sharing type InterMake.FileName.ModuleId = Io.ModuleId = ModuleId.ModuleId
d291 1
a291 2
    structure FileName = InterMake.FileName
    structure Option = FileName.Option
d294 2
d369 5
a373 2
	  (modules, Io.builtin_library_name, "Making builtin library") of
	  (modules, InterMake.EXECUTE result) => (modules, result)
d410 5
a414 2
	  (modules, Io.pervasive_library_name, "Making Pervasive Library") of
	  (modules, InterMake.EXECUTE result) => (modules, result)
d703 1
a703 1
                    filename,
d706 1
a706 1
        val _ = diagnostic (2, fn _ => ["Adding make module `", filename, "'"])
d708 1
a708 1
	case InterMake.make
d715 1
a715 1
	  (modules, filename, toplevel_name) of
d729 1
a729 1
	    (context, [](* This may be wrong? *))
@


1.62
log
@Changes to intermake
@
text
@d11 6
d363 1
a363 1
	  (modules, Io.builtin_library_name) of
d401 1
a401 1
	  (modules, Io.pervasive_library_name) of
d625 1
a625 1
    fun load_one_mo (modname,modules) =
d630 1
a630 1
        val intermake_result = InterMake.get_mo_information (modname,module,modules)
d645 1
a645 1
    fun load_dependencies ((modules,done),modname) =
d650 1
a650 1
          val submodules = InterMake.get_mo_dependencies modname
d653 2
a654 2
          val (modules',done') = Lists.reducel load_dependencies ((modules,modname::done),submodules)
          val (_,_,_,modules'') = load_one_mo (modname,modules')
d659 1
a659 1
    fun load_mo (context,modname) =
d662 1
a662 1
        val submodules = InterMake.get_mo_dependencies modname
d665 2
a666 2
        val (modules,done) = Lists.reducel load_dependencies ((modules,[modname]),submodules)
        val (compiler_basis,module,identifiers,modules') = load_one_mo (modname,modules)
d691 2
a692 1
                    filename) =
d703 1
a703 1
	  (modules, filename) of
@


1.61
log
@Added function for loading an mo file.
@
text
@d11 3
a336 1
      val cache = InterMake.empty_cache
d350 1
a350 1
      val (modules, cache, builtin_library_result) =
d357 2
a358 2
	  (modules, cache, Io.builtin_library_name) of
	  (modules, cache, InterMake.EXECUTE result) => (modules, cache, result)
d364 1
a364 1
                                inter_env,load_time} = builtin_library_result
d370 1
a370 1
           inter_env = inter_env, load_time = load_time,
a383 2
      val cache = InterMake.empty_cache

d388 1
a388 1
      val (modules, cache, pervasive_library_result) =
d395 2
a396 2
	  (modules, cache, Io.pervasive_library_name) of
	  (modules, cache, InterMake.EXECUTE result) => (modules, cache, result)
d466 1
a466 1
                                 code}, _) =
d469 1
a469 1
          (fn (_, _, location, _, _) =>
d475 1
a475 1
          ((), compiler_basis, [], false)
d582 1
a582 1
                         (result,modname,aug_compiler_basis,module,filename)) =
d601 1
a601 1
                 modules = InterMake.add_module (modules,modname,result)}
d604 16
a619 1
    fun load_mo (context,modname) =
d621 3
a623 2
        val (module_id,module) = MLWorks.Internal.Runtime.Loader.load_module (modname ^ ".mo")
        val CONTEXT{modules,...} = context
d628 1
d630 1
a630 2
        (add_definitions' (context,(intermake_result,module_id,compiler_basis,module,modname ^ ".sml")),
         identifiers)
d635 31
d696 2
a697 2
	  (modules, InterMake.empty_cache, filename) of
	  (modules, _,
d709 1
a709 1
	| (_, _, InterMake.NO_EXECUTE _) =>
d712 1
a712 1
      handle InterMake.Error (modules, _, error,error_list) =>
d721 1
a721 1
        | InterMake.Interrupted (modules,_) =>
@


1.60
log
@Added level field to Basis.
@
text
@d11 3
d218 1
d233 1
d290 5
d343 5
d363 1
a363 1
          val Compiler.RESULT {basis, signatures, identifiers, code} = compiler_result
d371 1
a371 1
             {signatures = signatures, identifiers = identifiers, code = code,
d464 1
d556 1
a556 1
      
d580 38
@


1.59
log
@Changed use of runtime system modules to remove the time stamp field
@
text
@d11 3
d637 1
a637 1
                      type_basis = BasisTypes.BASIS (nameset, functor_env, signature_env,
d661 1
a661 1
                     type_basis = BasisTypes.BASIS (nameset, functor_env, signature_env,
d675 1
a675 1
		     BasisTypes.BASIS(_, _, _, env),
d709 1
a709 1
                      type_basis = BasisTypes.BASIS (nameset, functor_env, signature_env,
d724 1
a724 1
                     type_basis = BasisTypes.BASIS (nameset, functor_env, signature_env,
@


1.58
log
@Changes to do with remembering whether compilations are of pervasives
@
text
@d11 3
d328 2
d336 1
a336 1
	  (!MLWorks.Internal.Runtime.modules, true)
d376 1
a376 1
	  (!MLWorks.Internal.Runtime.modules, true)
@


1.57
log
@lookup_val now returns runtime_instance for polymorphic debugger.
@
text
@d11 3
d445 1
a445 1
          (fn (_, _, location, _) =>
d452 1
a452 1
          source
@


1.56
log
@Merging in bug fixes
@
text
@d11 3
d519 1
a519 1
            val ittype = Basis.lookup_val (Ident.NOPATH,
d521 1
a521 1
                                           Basis.basis_to_context type_basis)
@


1.55
log
@Changes to support moduleids and reflect changes to Io signature.
@
text
@d11 7
d322 1
a322 1
	  (fn x => fn y => y)
d362 1
a362 1
	  (fn x => fn y => y)
d453 2
d474 7
a480 4
                InterLoad.load
                debugger
                (inter_env, module_map)
                code'
d575 1
a575 1
	  (fn _ => debugger)
@


1.55.1.1
log
@Fork for bug fixing
@
text
@a10 3
 *  Revision 1.55  1993/08/16  11:38:08  daveb
 *  Changes to support moduleids and reflect changes to Io signature.
 *
@


1.55.1.2
log
@Simplified debugger interface to InterMake.make
Use InterMake.with_debug_info to set the debug information for the debugger
@
text
@d318 1
a318 1
	  (fn y => y)
d358 1
a358 1
	  (fn y => y)
a448 2
        val Compiler.BASIS{debug_info,...} = Compiler.augment (compiler_basis, topdec_compiler_basis)

d468 4
a471 7
                InterMake.with_debug_information
                debug_info
                (fn () =>
                 InterLoad.load
                 debugger
                 (inter_env, module_map)
                 code')
d566 1
a566 1
	  debugger
@


1.54
log
@structure Option.
@
text
@d11 3
d191 2
a192 1
require "../lambda/environ.sml";
d203 33
a235 34
functor Incremental (structure Environ : ENVIRON
                     structure InterLoad : INTERLOAD
                     structure InterMake : INTERMAKE
                     structure Valenv : VALENV
                     structure Strenv : STRENV
                     structure Basis : BASIS
                     structure Lexer : LEXER
                     structure ParserEnv : PARSERENV
                     structure Lists : LISTS
                     structure Diagnostic : DIAGNOSTIC
		     structure Io : IO
		     structure Crash : CRASH

                     sharing Environ.EnvironTypes =
		       InterMake.Inter_EnvTypes.EnvironTypes
                     sharing InterLoad.Inter_EnvTypes =
                       InterMake.Inter_EnvTypes
                     sharing Basis.BasisTypes.Datatypes =
                       Valenv.Datatypes =
                       Strenv.Datatypes

                     sharing ParserEnv.Map = Valenv.Datatypes.NewMap
                     sharing ParserEnv.Ident = Basis.BasisTypes.Datatypes.Ident
                       = InterMake.Compiler.Absyn.Ident =
                       Environ.EnvironTypes.LambdaTypes.Ident
                     sharing Environ.EnvironTypes.NewMap = Basis.BasisTypes.Datatypes.NewMap =
		       InterMake.Compiler.NewMap
		     sharing InterMake.FileName.Option = Io.Option
                     sharing type InterMake.Compiler.Module = InterLoad.Module
                     sharing type Environ.Structure = Basis.BasisTypes.Datatypes.Structure
                     sharing type Environ.EnvironTypes.LambdaTypes.Type = Basis.BasisTypes.Datatypes.Type
                     sharing type InterMake.Compiler.TypeBasis = Basis.BasisTypes.Basis
                     sharing type Lexer.TokenStream = InterMake.Compiler.tokenstream
                     sharing type InterMake.Compiler.ParserBasis = ParserEnv.pB
a256 15
    val pervasive_library_dir =
      case Io.get_pervasive_dir(MLWorks.OS.Unix.environment()) of
        Option.PRESENT s => s
      | _ => (output(MLWorks.IO.std_err, "No pervasive library directory\n");
	      raise Bind)

    val builtin_library_filename =
      InterMake.FileName.parse_absolute (
	implode [pervasive_library_dir, "/", Io.builtin_library_name])

    val pervasive_library_filename =
      InterMake.FileName.parse_absolute (
	implode [pervasive_library_dir, "/", Io.pervasive_library_name]
      )

d307 2
d318 2
a319 2
	  (!MLWorks.Internal.Runtime.modules)
	  (modules, cache, builtin_library_filename) of
d325 1
a325 1
          val InterMake.RESULT {name, source, time, dependencies, compiler_result, module, 
d331 1
a331 1
          {name = name, source = source, time = time, dependencies = dependencies, module = module, 
d343 2
a344 5
        let
          val InterMake.FileName.ABSOLUTE (_, module_name, _) = builtin_library_filename
        in
          InterMake.add_module (modules, module_name, builtin_library_result)
        end
d358 2
a359 2
	  (!MLWorks.Internal.Runtime.modules)
	  (modules, cache, pervasive_library_filename) of
d560 1
a560 4
        val _ = diagnostic (2, fn _ =>
                            ["Adding make module `",
                             InterMake.FileName.absolute_name filename,
                             "'"])
d568 1
a568 1
	  []
a584 25
(*
        val (modules, _,
             InterMake.RESULT
             {compiler_result =
              Compiler.RESULT {basis, signatures = module_signatures, identifiers, ...},
              inter_env = module_inter_env, ...}) =

          case InterMake.make
	    (fn _ => debugger)
	    (initial_compiler_basis, initial_inter_env)
	    (InterMake.OPTIONS{error_info = Info.make_default_options(),
			       name_monitor = Option.PRESENT monitor_fun,
			       options = options})
	    []
	    (modules, InterMake.empty_cache, filename) of
	    (modules, cache, EXECUTE result) => (modules, cache, result)
      in
        (CONTEXT {topdec = topdec,
                  compiler_basis = Compiler.augment (compiler_basis, make_external basis),
                  inter_env = Inter_EnvTypes.augment (inter_env, module_inter_env),
                  signatures = Map.merge (fn (old, new) => new) (signatures, module_signatures),
                  modules = modules},
        identifiers)
      end
*)
a706 5

    fun find_module(CONTEXT {modules,...}, filename) = 
      case InterMake.find_module(filename,modules) of
        InterMake.FOUND x => x
      | InterMake.NOT_FOUND => ""
@


1.53
log
@Changed Info.default_options to Info.make_default_options, which creates a new
options object.
Added Interrupted exceptions and handlers.
@
text
@d11 5
d472 1
a472 1
              Compiler.ABSENT =>
d477 1
a477 1
            | Compiler.PRESENT code' => 
@


1.52
log
@Removed exception environments.
@
text
@d11 3
d275 2
a276 2
	Info.default_options
	(Info.FAULT, location, "Incremental: " ^ message)
d307 1
a307 1
        {error_info = Info.default_options,
d470 1
a470 1
                (Info.FAULT, Info.Location.UNKNOWN,
d550 1
d557 1
a557 1
               modules=InterMake.delete_module(modules,filename,Info.default_options)}
d576 1
a576 1
	  (InterMake.OPTIONS{error_info = Info.default_options,
d606 1
a606 1
	    (InterMake.OPTIONS{error_info = Info.default_options,
d630 7
a636 2


@


1.51
log
@Deleted the name component of the context type.
@
text
@d11 3
d639 1
a639 1
                                                Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
d645 2
a646 1
        val ident = Datatypes.Ident.VAR (Datatypes.Ident.Symbol.find_symbol identifier)
d648 3
a650 1
        val new_lambda_env = Environ.add_valid_env (lambda_env, (ident, EnvironTypes.EXTERNAL))
d663 1
a663 1
                                               Datatypes.ENV (structure_env, type_env, new_value_env, exception_env)),
d693 1
a693 2
                                       Datatypes.VE(_,valenv),
                                       Datatypes.VE(_,eenv))) =
d695 1
a695 2
               (fn (PE.VE ve,PE.VE ve') => PE.VE(Map.union (ve,ve')))
               (make_pVE valenv,make_pVE eenv),
d711 1
a711 1
                                                Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
d726 1
a726 1
                                               Datatypes.ENV (new_structure_env, type_env, value_env, exception_env)),
@


1.50
log
@Changes to Error handling
@
text
@d11 3
a200 2
                     val initial_name : string

d273 1
a273 2
      CONTEXT of {name			: string,
                  topdec		: int,
d379 1
a379 2
        CONTEXT {name = initial_name,
                 topdec = 0,
d386 1
a386 9
    fun rename (CONTEXT {compiler_basis, topdec, inter_env, signatures, modules, ...}, name) =
      CONTEXT {compiler_basis = compiler_basis,
               inter_env = inter_env,
               topdec = topdec,
               signatures = signatures,
               modules = modules,
               name = name}

    fun clear_debug_info (CONTEXT {compiler_basis, topdec, inter_env, signatures, modules, name}) =
a390 1
              name=name,
a393 1
    fun name (CONTEXT record) = #name record
d415 1
a415 1
       CONTEXT {name, topdec, compiler_basis, inter_env, signatures, modules}, source) =
d517 1
a517 1
    fun add_definitions (CONTEXT{name,topdec,compiler_basis,signatures,inter_env,modules},
d534 1
a534 2
        CONTEXT {name = name,
                 topdec = topdec+1,
d546 1
a546 1
      (CONTEXT {name, topdec, compiler_basis, inter_env, signatures, modules},
d548 1
a548 1
      CONTEXT {name=name, topdec=topdec, compiler_basis=compiler_basis, 
d558 1
a558 1
		    CONTEXT {name, topdec, compiler_basis, inter_env, signatures, modules},
d580 1
a580 2
	  (CONTEXT {name = name,
		    topdec = topdec,
d606 1
a606 2
        (CONTEXT {name = name,
                  topdec = topdec,
d619 1
a619 1
	       CONTEXT {name = name, topdec = topdec, compiler_basis = compiler_basis,
d631 1
a631 2
          CONTEXT {name,
                   topdec,
d652 1
a652 2
        (CONTEXT {name = name,
                  topdec = topdec+1,
d702 1
a702 2
          CONTEXT {name,
                   topdec,
d717 1
a717 2
        (CONTEXT {name = name,
                  topdec = topdec+1,
@


1.49
log
@Added Crash parameter to functor parameter
@
text
@d11 3
d424 3
a426 2
      (inc_options as OPTIONS {options,debugger,...})
      (CONTEXT {name, topdec, compiler_basis, inter_env, signatures, modules}, source) =
a438 3

	val error_info = Info.default_options

d490 1
a490 1
    fun evaluate_exp_topdec (inc_options,context,topdec) =
d511 5
a515 3
              compile_source inc_options
                             (context,
                              Compiler.TOPDEC("",topdec,PE.empty_pB))
@


1.48
log
@Added is_an_expression function
@
text
@d11 3
d170 1
d193 1
d309 9
a317 6
        InterMake.make
        (fn x => fn y => y)
        (Compiler.initial_basis_for_builtin_library, Inter_EnvTypes.empty_env)
        make_options
        (!MLWorks.Internal.Runtime.modules)
        (modules, cache, builtin_library_filename)
d352 9
a360 6
        InterMake.make
        (fn x => fn y => y)
        (Compiler.initial_basis, Inter_EnvTypes.empty_env)
        make_options
        (!MLWorks.Internal.Runtime.modules)
        (modules, cache, pervasive_library_filename)
d441 1
a441 1
                                 code}) =
d444 1
a444 1
          (fn (_, _, location) =>
d450 1
a450 1
          ((), compiler_basis)
d561 4
a564 1
    fun add_module (inc_options as OPTIONS {options, debugger, ...})
d566 2
a567 1
                   (CONTEXT {name, topdec, compiler_basis, inter_env, signatures, modules},
d574 26
a599 1

d605 10
a614 8
          InterMake.make
          (fn _ => debugger)
          (initial_compiler_basis, initial_inter_env)
          (InterMake.OPTIONS{error_info = Info.default_options,
                             name_monitor = Option.PRESENT monitor_fun,
                             options = options})
          []
          (modules, InterMake.empty_cache, filename)
d624 1
d627 7
a633 4
         raise Error (CONTEXT {name = name, topdec = topdec, compiler_basis = compiler_basis,
                               inter_env = inter_env, signatures = signatures, modules = modules},
                      error,
                      error_list))
@


1.47
log
@Added error_list to Error exception
@
text
@d11 3
d480 13
a492 1
        fun not_an_expression _ = false
d494 1
a494 1
        if not_an_expression topdec
d506 1
a506 1
            val [itval : MLWorks.Internal.Value.T] = MLWorks.Internal.Value.cast module
d508 3
a510 1
            (itval,ittype)
@


1.46
log
@Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d11 3
d524 1
a524 1
    exception Error of Context * Info.error
d565 1
a565 1
      handle InterMake.Error (modules, _, error) =>
d569 2
a570 1
                      error))
@


1.45
log
@add_module takes an explicit monitor function argument
@
text
@d11 3
d267 1
a267 2
      {error_info       : Info.options,
       options	        : Options.options,
d288 1
a288 1
         name_monitor = Option.ABSENT,
d404 1
a404 1
      (inc_options as OPTIONS {error_info,options,debugger,...})
d419 2
d426 1
a426 1
          (error_info,options)
a523 1
      (options as OPTIONS {error_info, ...})
d528 1
a528 1
               modules=InterMake.delete_module(modules,filename,error_info)}
d530 1
a530 1
    fun add_module (inc_options as OPTIONS {error_info,options, debugger, ...})
d548 1
a548 1
          (InterMake.OPTIONS{error_info = error_info,
d572 1
a572 1
    fun add_value (OPTIONS _) (context, identifier, scheme, value) =
d645 1
a645 1
    fun add_structure (OPTIONS _) (context, identifier, str, value) =
@


1.44
log
@Added code to remove FullPervasiveLibrary_ from initial environment
@
text
@d11 3
a265 1
       name_monitor	: (string -> unit) InterMake.FileName.Option.T,
d285 2
a286 2
        {name_monitor = InterMake.FileName.Option.ABSENT,
         error_info = Info.default_options,
d527 2
a528 1
    fun add_module (inc_options as OPTIONS {error_info,options,name_monitor, debugger, ...})
d545 2
a546 2
          (InterMake.OPTIONS{name_monitor = name_monitor,
                             error_info = error_info,
@


1.43
log
@Added evaluate_exp_topdec
@
text
@d11 3
d345 3
@


1.42
log
@removed string parameter from debugger function
@
text
@d11 3
d155 1
a155 1
require "../typechecker/basistypes";
d168 1
a168 1
                     structure BasisTypes : BASISTYPES
d181 1
a181 1
                     sharing BasisTypes.Datatypes =
d186 2
a187 1
                     sharing ParserEnv.Ident = BasisTypes.Datatypes.Ident = InterMake.Compiler.Absyn.Ident =
d189 2
a190 2
                     sharing Environ.EnvironTypes.NewMap = BasisTypes.Datatypes.NewMap =
		       InterMake.Compiler.Debugger_Types.NewMap
d193 3
a195 3
                     sharing type Environ.Structure = BasisTypes.Datatypes.Structure
                     sharing type Environ.EnvironTypes.LambdaTypes.Type = BasisTypes.Datatypes.Type
                     sharing type InterMake.Compiler.TypeBasis = BasisTypes.Basis
d205 1
a205 1
    structure Debugger_Types = Compiler.Debugger_Types
d211 1
d405 1
a405 1
           (output (stream, "Adding topdec from ");
a428 4
        (* Create a context which is up-to-date except for the interpreter *)
        (* environment for the use of the debugger.  Load the module using *)
        (* a debugger specialised for that context. *)

d458 24
@


1.41
log
@Removed get_pervasive_dir, using one in io instead
@
text
@d11 3
d256 1
a256 2
       debugger		: string ->
                          (MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T) ->
d448 1
a448 1
                (debugger "")
d509 1
a509 2
          (fn (compiler_basis,inter_env,modules,current_module) => 
           (debugger (current_module)))
@


1.40
log
@Removed add_source which is split up into compile_source and add_definitions
@
text
@d11 3
a181 1

d183 2
a184 1
                        InterMake.Compiler.Debugger_Types.NewMap
a210 15
    val pervasive_dir_arg = "PERVASIVE_DIR="
    val pervasive_dir_arg_len = size pervasive_dir_arg

    fun get_pervasive_dir [] = Option.ABSENT
      | get_pervasive_dir(arg :: rest) =
        if size arg < pervasive_dir_arg_len then
          get_pervasive_dir rest
        else
          if String.substring(arg, 0, pervasive_dir_arg_len) =
            pervasive_dir_arg then
            Option.PRESENT(String.substring(arg, pervasive_dir_arg_len,
                                            size arg - pervasive_dir_arg_len))
          else
            get_pervasive_dir rest

d212 1
a212 1
      case get_pervasive_dir(MLWorks.OS.Unix.environment()) of
d214 2
a215 1
      | _ => !Io.pervasive_library_dir
a646 1

@


1.39
log
@Added parserbasis field to Compiler.TOPDEC source
@
text
@d11 3
d391 9
a399 3
    fun add_source
         (inc_options as OPTIONS {error_info,options,debugger,...})
         (CONTEXT {name, topdec, compiler_basis, inter_env, signatures, modules}, source) =
d414 1
a414 1
                                 signatures = new_signatures,
d431 1
a431 1
        val topdec_compiler_basis = make_external topdec_compiler_basis
a436 12
        val compiler_basis = Compiler.augment (compiler_basis, topdec_compiler_basis)
        val signatures =
          Map.merge (fn (old, new) => new) (signatures, new_signatures)

        val debugger_context =
          CONTEXT {name = name,
                   topdec = topdec+1,
                   compiler_basis = compiler_basis,
                   inter_env = inter_env,
                   signatures = signatures,
                   modules = modules}

d461 4
d466 6
d474 1
a474 1
        val inter_env =
d476 1
a476 1
            val Compiler.BASIS {lambda_environment, ...} = topdec_compiler_basis
d479 2
a480 2
              handle Inter_EnvTypes.Augment =>
                crash (Info.Location.FILE filename, "Module does not match generated environment")
d483 6
a488 7
        (CONTEXT {name = name,
                  topdec = topdec+1,
                  compiler_basis = compiler_basis,
                  signatures = signatures,
                  inter_env = inter_env,
                  modules = modules},
        identifiers)
a489 1

@


1.38
log
@Simplified debugger function
Signature revisions
@
text
@d11 4
d396 1
a396 1
          | Compiler.TOPDEC (filename, _) => filename
@


1.37
log
@Options & Info changes
Changed options type
@
text
@d11 4
d167 2
a168 2
                       Strenv.Datatypes =
                       Environ.EnvironTypes.LambdaTypes.Datatypes
d170 2
a171 2
                     sharing ParserEnv.Ident = Valenv.Datatypes.Ident = InterMake.Compiler.Absyn.Ident
                     sharing InterMake.Compiler.MachTypes = InterLoad.MachTypes
d173 5
d187 3
a189 3
    structure EnvironTypes = Compiler.EnvironTypes
    structure Debugger_Types = Compiler.MirTypes.Debugger_Types
    structure Datatypes = Debugger_Types.Datatypes
d257 1
a257 1
       debugger		: (options * Context ref * string) ->
d456 1
a456 1
                (debugger (inc_options,ref debugger_context,""))
d510 1
a510 8
           (debugger (inc_options,
                      ref (CONTEXT{name = name,
                                   topdec = topdec,
                                   compiler_basis = compiler_basis,
                                   inter_env = inter_env,
                                   signatures = signatures,
                                   modules = modules}),
                      current_module)))
@


1.36
log
@Added newlines to build messages.
@
text
@d11 3
d135 2
d148 2
d161 1
a161 1
                     sharing InterMake.Compiler.BasisTypes.Datatypes =
d166 6
a171 4
                     sharing ParserEnv.Ident = Valenv.Datatypes.Ident
                     sharing type InterMake.Compiler.Parser.ParserBasis = ParserEnv.pB
                     sharing InterMake.Compiler.MachTypes =
		       InterLoad.MachTypes
a174 1
    structure Parser = Compiler.Parser
d176 2
a177 3
    structure Lexer = Parser.Lexer
    structure Info = Compiler.Parser.Lexer.Info
    structure BasisTypes = Compiler.BasisTypes
d180 1
a180 1
    structure Datatypes = BasisTypes.Datatypes
d183 2
a184 2
    structure Absyn = Parser.Absyn
    structure Ident = Absyn.Datatypes.Ident
d190 1
d235 1
a235 1
    datatype context =
d245 4
a248 3
      {compiler_options	: Compiler.MirTypes.options,
       make_options	: InterMake.options,
       debugger		: (options * context * string) ->
a251 1

d268 3
a270 3
        {compiler_options =
           Compiler.MirTypes.default_options,
         name_monitor = InterMake.FileName.Option.ABSENT}
d376 1
a376 5
         (options as OPTIONS {
	    compiler_options as Compiler.MirTypes.OPTIONS{info_opts,...},
            debugger,
	    ...
	 })
d396 9
a404 9
            compiler_options
            (fn (_, _, location) =>
               Info.error'
		 info_opts
		 (Info.FATAL, location, "require used at top level")
                 (* maybe this should generate a warning, not an error *)
	    )
            ((), compiler_basis)
            source
d442 1
a442 1
                info_opts
d447 1
a447 1
                (debugger (options,debugger_context,""))
d475 1
a475 1
    exception Error of context * Info.error
d478 1
a478 1
      (options as OPTIONS {make_options, ...})
d483 1
a483 1
               modules=InterMake.delete_module(modules,filename,make_options)}
d485 1
a485 1
    fun add_module (options as OPTIONS {make_options, debugger, ...})
d501 8
a508 8
           (debugger (options,
                      CONTEXT{name = name,
                              topdec = topdec,
                              compiler_basis = compiler_basis,
                              inter_env = inter_env,
                              signatures = signatures,
                              modules = modules},
                      current_module)))        
d510 4
a513 1
          make_options []
@


1.35
log
@Added code to update parser environment when adding a structure to a context.
@
text
@d11 3
d219 2
a220 1
      (fn (verbosity, stream) => (output (stream, "Incremental: "); output_function (verbosity, stream)))
d267 2
a268 1
      val _ = diagnostic_fn (0, fn (_, stream) => output (stream, "making the builtin library"))
d306 3
a308 1
      val _ = diagnostic_fn (0, fn (_, stream) => output (stream, "making the pervasive library"))
@


1.34
log
@Fixed sharing problem between Option and InterMake.FileName.Option
@
text
@d11 3
d129 1
d140 1
d155 3
d164 1
d536 8
a543 3
        val value_env = Valenv.add_to_ve (ident, scheme, value_env)
        val lambda_env = Environ.add_valid_env (lambda_env, (ident, EnvironTypes.EXTERNAL))
        val inter_env = Inter_EnvTypes.add_val (inter_env, (ident, value))
d549 1
a549 1
                    {parser_basis = parser_basis,
d551 2
a552 2
                                               Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
                     lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
d554 1
a554 1
                  inter_env = inter_env,
d570 23
d607 4
a610 3
        val structure_env = Strenv.add_to_se (ident, str, structure_env)
        val lambda_env = Environ.add_strid_env (lambda_env, (ident, (Environ.make_str_env str, EnvironTypes.EXTERNAL)))
        val inter_env = Inter_EnvTypes.add_str (inter_env, (ident, value))
d616 1
a616 1
                    {parser_basis = parser_basis,
d618 2
a619 2
                                               Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
                     lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
d621 1
a621 1
                  inter_env = inter_env,
@


1.33
log
@Typechecker structure changes
@
text
@d11 3
a122 1
require "../utils/option";
a137 1
		     structure Option : OPTION
d170 1
@


1.32
log
@Signature Changes.
@
text
@d11 3
a122 1
require "../typechecker/tyenv";
a123 1
require "../typechecker/sigenv";
a133 2
                     structure Tyenv : TYENV
                     structure Sigenv : SIGENV
d145 1
a145 1
                     sharing InterMake.Compiler.Basis.Tyvarenv.Datatypes =
d148 1
a148 4
                       Tyenv.Datatypes =
                       Sigenv.Sigma.Nameset.Datatypes =
                       Environ.EnvironTypes.LambdaTypes.Datatypes =
		       InterMake.Compiler.Parser.Absyn.Datatypes 
d157 1
a157 1
    structure Basis = Compiler.Basis
d160 1
a160 1
    structure Datatypes = Basis.Tyvarenv.Datatypes
d517 1
a517 1
                      type_basis = Basis.BASIS (nameset, functor_env, signature_env,
d534 1
a534 1
                     type_basis = Basis.BASIS (nameset, functor_env, signature_env,
d548 1
a548 1
		     Basis.BASIS(_, _, _, env),
d562 1
a562 1
                      type_basis = Basis.BASIS (nameset, functor_env, signature_env,
d577 1
a577 1
                     type_basis = Basis.BASIS (nameset, functor_env, signature_env,
@


1.31
log
@Changed default make options to turn off debug, tracing and profiling
@
text
@d11 3
a122 1
require "../typechecker/datatypes";
d251 1
a251 1
         name_monitor = InterMake.Option.ABSENT}
@


1.30
log
@Modified to deal with new code printing options
@
text
@d11 3
d248 1
a248 20
           Compiler.MirTypes.OPTIONS {
	     info_opts = Info.default_options,
	     list_opts = Compiler.MirTypes.BELO {
	       show_absyn = false,
	       show_lambda = false,
	       show_match = false,
               show_opt_lambda = false,
               show_environ = false,
               show_mir = false,
               show_opt_mir = false,
               show_mach = false
	       },
             debug = true,
             profile = true,
	     trace = true,
	     debug_warnings = false,
	     opt_leaf_fns = true,
	     opt_self_calls = true,
	     opt_tail_calls = true
	   },
@


1.29
log
@We also pass the current module forward for the source_displayer
@
text
@d11 3
d247 10
@


1.28
log
@Changes propagated from the lower levels
@
text
@d11 3
d220 1
a220 1
       debugger		: (options * context) ->
d430 1
a430 1
                (debugger (options,debugger_context))
d483 1
a483 1
          (fn (compiler_basis,inter_env,modules) => 
d490 2
a491 1
                              modules = modules})))        
@


1.27
log
@Added find_module for the source_displayer
@
text
@d11 3
d149 1
a149 1
    structure Info = Compiler.MirTypes.Info
d152 1
a152 1
    structure Debugger_Types = Compiler.Debugger_Types
d397 1
a397 1
          Compiler.Map.merge (fn (old, new) => new) (signatures, new_signatures)
d496 1
a496 1
                  signatures = Compiler.Map.merge (fn (old, new) => new) (signatures, module_signatures),
@


1.26
log
@Removed some sharing constraints.
@
text
@d11 3
d138 1
a138 1
		       InterMake.Compiler.Parser.Absyn.Datatypes =
d584 5
@


1.25
log
@Added module list parameter to make of pervasive files.
@
text
@d11 3
a123 4
		     (*
                     val builtin_library_filename : InterMake.FileName.absolute
                     val pervasive_library_filename : InterMake.FileName.absolute
		     *)
a125 1
                       InterMake.Compiler.EnvironTypes =
d136 3
a138 2
		       InterMake.Inter_EnvTypes.EnvironTypes.LambdaTypes.Datatypes
                     sharing InterMake.Compiler.MachTypes = InterLoad.MachTypes) : INCREMENTAL =
@


1.24
log
@Changes to support the PERVASIVE_DIR Unix environment variable.
Removed a sharing constraint.
@
text
@d11 4
d256 1
d294 1
d484 1
a484 1
          make_options
@


1.23
log
@Added the delete_module function
@
text
@d11 3
d92 1
d99 1
d113 2
d117 1
d120 1
a124 2
		     sharing InterMake.Compiler.MirTypes.Info  =
		       InterMake.Compiler.Parser.Lexer.Info
d153 29
@


1.22
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d11 3
d220 2
a221 1
          val InterMake.RESULT {name, source, time, dependencies, compiler_result, module, inter_env} = builtin_library_result
d226 2
a227 1
          {name = name, source = source, time = time, dependencies = dependencies, module = module, inter_env = inter_env,
d409 8
@


1.21
log
@Added a comment.
@
text
@d11 3
d113 2
d130 1
a130 1
    structure Info = Lexer.Info
d167 1
a167 1
      {compiler_options	: Compiler.options,
d191 10
a200 3
           Compiler.OPTIONS {info_opts = Info.default_options,
                             debug = true,
                             profile = true},
d300 5
a304 2
         (options as OPTIONS {compiler_options as Compiler.OPTIONS{info_opts,...},
                              debugger, ...})
d324 9
a332 6
          (fn (_, _, location) =>
           (* maybe this should generate a warning, not an error *)
           Info.error' info_opts (Info.FATAL, location, "require used at top level"))
          compiler_options
          ((), compiler_basis)
          source
@


1.20
log
@Debugger now takes a more up-to-date environment
@
text
@d11 3
d310 1
d353 1
a353 1
                (Info.FATAL, Info.Location.UNKNOWN,
@


1.19
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d11 4
d398 1
a398 1
          (fn compiler_basis => 
d403 1
a403 1
                              inter_env = Inter_EnvTypes.empty_env,
@


1.18
log
@Added clear_debug_info function
@
text
@d11 3
a139 14
    val dummy_stream = Info.Stream.outstream{output = fn s => output(std_out,s),
                                             flush_out = fn () => (),
                                             close_out = fn () => ()}
    val default_options = Info.OPTIONS {error = {outstream = dummy_stream,
                                                 stop = Info.FATAL,
                                                 report = Info.ADVICE,
                                                 worst = ref Info.ADVICE},
                                        information = {outstream = dummy_stream,
                                                       level = 2},
                                        listing = {outstream = dummy_stream,
                                                   level = 2},
                                        diagnostic = {outstream = dummy_stream,
                                                      level = 2}}

d141 3
a143 1
      Info.error' default_options (Info.FAULT, location, "Incremental: " ^ message)
d179 1
a179 1
           Compiler.OPTIONS {info_opts = default_options,
@


1.17
log
@Dealt with the fact that the code slot is now optional (we can throw it away
after loading)
@
text
@d11 4
d266 9
@


1.16
log
@Modified sharing constraints to remove superfluous structures
@
text
@d11 3
d337 11
a347 4
            InterLoad.load
            (debugger (options,debugger_context))
            (inter_env, module_map)
            code
@


1.15
log
@Changed intermake to wrap a debugger around the loading operation
@
text
@d11 3
a71 1
require "inter_envtypes";
a76 1
                     structure Inter_EnvTypes : INTER_ENVTYPES
d92 2
a93 3
                       Inter_EnvTypes.EnvironTypes
                     sharing Inter_EnvTypes =
                       InterLoad.Inter_EnvTypes =
d100 3
a102 4
                       Environ.EnvironTypes.LambdaTypes.Datatypes
                     sharing InterMake.Compiler.Parser.Absyn.Datatypes.Ident =
                       Inter_EnvTypes.Ident =
                       Valenv.Datatypes.Ident
a105 1
    structure Info = InterMake.Info
d107 2
a110 1
    structure Lexer = Parser.Lexer
d117 2
a118 2
    structure LambdaTypes = Compiler.LambdaTypes
    structure Inter_EnvTypes = Inter_EnvTypes
@


1.14
log
@More Error -> Info revision
@
text
@d11 3
d194 1
d229 1
d366 1
a366 1
    fun add_module (OPTIONS {make_options, ...})
d380 10
a389 1
          InterMake.make (initial_compiler_basis, initial_inter_env)
@


1.13
log
@Changed Error structure to Info
@
text
@d11 3
d270 2
a271 1
         (options as OPTIONS {compiler_options, debugger, ...})
d292 1
a292 1
           Info.error' default_options (Info.FATAL, location, "require used at top level"))
@


1.12
log
@Added env function to extract th environment from a context.
@
text
@d11 3
d101 1
a102 1
    structure Error = Parser.Error
d125 14
d140 1
a140 1
      Error.report' (Error.ERROR (Error.FAULT, location, "Incremental: " ^ message))
d176 1
a176 1
           Compiler.OPTIONS {error_output_level = Error.ADVICE,
d288 1
a288 1
           Error.report' (Error.ERROR (Error.FATAL, location, "require used at top level")))
d340 1
a340 1
                crash (Error.Location.FILE filename, "Module does not match generated environment")
d355 1
a355 1
    exception Error of context * Error.error
@


1.11
log
@Got exit working, and passed through enough for debugger to bind frame arguments to it
on invoking a sub-shell
@
text
@d11 4
d410 10
@


1.10
log
@Added make options as distinct from compiler options.
Dealt with a make error which might return a partially updated module table.
@
text
@d11 4
d133 1
a133 1
       debugger		: context ->
d246 1
a246 1
         (OPTIONS {compiler_options, debugger, ...})
d306 1
a306 1
            (debugger debugger_context)
@


1.9
log
@Changes for windowing listener
@
text
@d11 7
d127 2
a128 1
      {compiler		: Compiler.options,
d148 7
a154 4
      val compiler_options =
        Compiler.OPTIONS {error_output_level = Error.ADVICE,
                          debug = true,
                          profile = true}
d164 2
a165 2
        compiler_options
        (modules, cache, builtin_library_filename, fn _ => ())
d198 2
a199 2
        compiler_options
        (modules, cache, pervasive_library_filename, fn _ => ())
d242 1
a242 1
         (OPTIONS {compiler = compiler_options, debugger, ...})
d330 3
a332 1
    fun add_module (OPTIONS {compiler = compiler_options, ...})
d334 1
a334 2
                    filename,
                    consumer) =
d336 5
d347 2
a348 2
          compiler_options
          (modules, InterMake.empty_cache, filename,consumer)
d358 5
@


1.8
log
@Incorporated the make system.
@
text
@d11 3
d154 1
a154 1
        (modules, cache, builtin_library_filename)
d188 1
a188 1
        (modules, cache, pervasive_library_filename)
d321 2
a322 1
                    filename) =
d331 1
a331 1
          (modules, InterMake.empty_cache, filename)
@


1.7
log
@Changed add_topdec to add_source of compiler source type.
@
text
@d11 3
a33 3
require "../main/compiler";
require "../debugger/get_type_information";
require "../main/io";
d43 2
d47 1
a47 2
functor Incremental (structure Compiler : COMPILER
                     structure Environ : ENVIRON
d49 2
a54 2
                     structure GetTypeInformation : GETTYPEINFORMATION
                     structure Io : IO
d59 2
d63 6
a68 10
                       Compiler.EnvironTypes =
                       Inter_EnvTypes.EnvironTypes =
                       GetTypeInformation.EnvironTypes
                     sharing GetTypeInformation.Debugger_Types =
                       Compiler.Debugger_Types
                     sharing GetTypeInformation.Parser.Absyn.Datatypes.Ident =
                       Compiler.Parser.Absyn.Datatypes.Ident =
                       Inter_EnvTypes.Ident =
                       Valenv.Datatypes.Ident
                     sharing GetTypeInformation.Basis.Tyvarenv.Datatypes =
d74 4
a77 4
                     sharing Valenv.Datatypes.NewMap = Compiler.Map
                     sharing GetTypeInformation.Basis = Compiler.Basis
                     sharing GetTypeInformation.Parser = Compiler.Parser
) : INCREMENTAL =
d79 1
a79 1
    structure Compiler = Compiler
d91 1
d93 2
d112 2
a113 1
                  signatures		: (Ident.SigId, Absyn.SigExp) Map.T}
d117 4
a120 4
      {compiler			: Compiler.options,
       debugger			: context ->
                    		  (MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T) ->
                  		  MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T}
d123 1
a123 8
    (*  === THE INITIAL CONTEXT ===
     *
     *  The SML initial context is generated by extracting the builtin
     *  library and pervasive library modules from within the compiler and
     *  matching them against the environments from their mo files.  The
     *  results are used to augment the empty environments and thus provide
     *  the pervasive context.
     *)
d125 10
d136 55
a190 2
      fun find s = Lists.assoc (s, !MLWorks.Internal.Runtime.modules)
        handle Lists.Assoc => crash (Error.Location.UNKNOWN, "Couldn't find internal module " ^ s)
d192 2
a193 3
      val builtin_library_module = find Io.builtin_library_name
      val pervasive_library_module = find Io.pervasive_library_name
    end
d195 1
a195 13
    val sml_initial =
      let
        val (builtin_library_basis, builtin_library_env) =
          let
            val (pb, tb, debug_info, lambda_env) =
              GetTypeInformation.get_type_information Io.builtin_library_name
          in
            (Compiler.BASIS {parser_basis = pb,
                             type_basis = tb,
                             lambda_environment = Environ.make_external lambda_env,
                             debug_info = debug_info},
            lambda_env)
          end
d197 1
a197 15
        val (pervasive_library_basis, pervasive_library_env) =
          let
            val (pb, tb, debug_info, lambda_env) =
              GetTypeInformation.get_type_information Io.pervasive_library_name
          in
            (Compiler.BASIS {parser_basis = pb,
                             type_basis = tb,
                             lambda_environment = Environ.make_external lambda_env,
                             debug_info = debug_info},
            lambda_env)
          end

        val to_module : MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T list =
          MLWorks.Internal.Value.cast
      in
d200 5
a204 11
                 compiler_basis =
                   Compiler.augment (Compiler.augment (Compiler.initial_basis, builtin_library_basis),
                                     pervasive_library_basis),
                 inter_env =
                   Inter_EnvTypes.augment_with_module
                   (Inter_EnvTypes.augment_with_module
                    (Inter_EnvTypes.empty_env,
                     builtin_library_env, to_module builtin_library_module),
                    pervasive_library_env, to_module pervasive_library_module),
                 signatures = Map.empty (Ident.sigid_lt, Ident.sigid_eq)}
      end
d206 1
a206 2

    fun rename (CONTEXT {compiler_basis, topdec, inter_env, signatures, ...}, name) =
d211 1
d225 1
a225 1
    (*  === COMPILE A TOPDEC INTO A CONTEXT ===  *)
d227 9
a235 1
    local
d237 4
a240 1
      (*  == Load compilation result ==  *)
a241 12
      local
        structure Symbol = Ident.Symbol
        structure MachTypes = Compiler.MachTypes
      in
        fun load (debugger,
                  code_env as Inter_EnvTypes.INTER_ENV (values, exceptions, structures, functors),
                  MachTypes.MODULE module_element_list) =
          let
            val value_map     = Inter_EnvTypes.NewMap.apply values
            val exception_map = Inter_EnvTypes.NewMap.apply exceptions
            val structure_map = Inter_EnvTypes.NewMap.apply structures
            val functor_map   = Inter_EnvTypes.NewMap.apply functors
d243 10
a252 1
            val cast = MLWorks.Internal.Value.cast
d254 2
a255 27
            fun element (result, []) = result
              | element (result, MachTypes.REAL (i, string) :: rest) =
                element ((i, cast (MLWorks.Internal.Value.string_to_real string))::result, rest)
              | element (result, MachTypes.STRING (i, string) :: rest) =
                element ((i, cast string)::result, rest)
              | element (result, MachTypes.VAR (i, name) :: rest) =
                element ((i, value_map (Ident.VAR (Symbol.find_symbol name)))::result, rest)
              | element (result, MachTypes.EXN (i, name) :: rest) =
                element ((i, exception_map (Ident.EXCON (Symbol.find_symbol name)))::result, rest)
              | element (result, MachTypes.STRUCT (i, name) :: rest) =
                element ((i, structure_map (Ident.STRID (Symbol.find_symbol name)))::result, rest)
              | element (result, MachTypes.FUNCT (i, name) :: rest) =
                element ((i, functor_map (Ident.FUNID (Symbol.find_symbol name)))::result, rest)
              | element (result, MachTypes.WORDSET (MachTypes.WORD_SET list) :: rest) =
                element (MLWorks.Internal.Runtime.Loader.load_wordset list @@ result, rest)
              | element (result, MachTypes.EXTERNAL (i, name) :: rest) =
                let
                  val module =
                    if name = Io.builtin_library_name then
                      builtin_library_module
                    else if name = Io.pervasive_library_name then
                      pervasive_library_module
                    else
                      crash (Error.Location.UNKNOWN, "Cannot link to external module " ^ name ^ ".")
                in
                  element ((i, module)::result, rest)
                end
d257 1
a257 10
            val closure =
              MLWorks.Internal.Value.cast
              (MLWorks.Internal.Value.list_to_tuple
               (map #2
                (Lists.qsort (fn ((i:int, _), (j:int, _)) => i < j)
                 (element ([], module_element_list)))))
          in
            MLWorks.Internal.Value.cast ((debugger closure) closure) : MLWorks.Internal.Value.T list
          end
      end
d259 3
a261 1
    in
d263 3
a265 9
      fun add_source
           (OPTIONS {compiler = compiler_options, debugger, ...})
           (CONTEXT {name, topdec, compiler_basis, inter_env, signatures}, source) =
        let
          val filename =
            case source of
              Compiler.TOKENSTREAM token_stream => Lexer.associated_filename token_stream
            | Compiler.TOKENSTREAM1 token_stream => Lexer.associated_filename token_stream
            | Compiler.TOPDEC (filename, _) => filename
d267 7
a273 4
          val _ = diagnostic_fn
            (2, fn (_, stream) =>
             (output (stream, "Adding topdec from ");
              output (stream, filename)))
d275 17
a291 10
          val (_, Compiler.RESULT {basis = topdec_compiler_basis,
                                   signatures = new_signatures,
                                   identifiers,
                                   code}) =
            Compiler.compile
            (fn (_, module) =>
             Error.report' (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN, "require topdec not supported yet")))
            compiler_options
            ((), compiler_basis)
            source
d293 5
a297 5
          (* Replace the values bound in the lambda environment with *)
          (* external references. *)

          local
            val Compiler.BASIS {parser_basis, type_basis, lambda_environment, debug_info} = topdec_compiler_basis
d299 3
a301 6
            val topdec_lambda_environment = Environ.make_external lambda_environment
            val topdec_compiler_basis =
              Compiler.BASIS {parser_basis = parser_basis,
                              type_basis = type_basis,
                              lambda_environment = topdec_lambda_environment,
                              debug_info = debug_info}
d303 9
a312 3
          (* Create a context which is up-to-date except for the interpreter *)
          (* environment for the use of the debugger.  Load the module using *)
          (* a debugger specialised for that context. *)
d314 1
a314 3
          val compiler_basis = Compiler.augment (compiler_basis, topdec_compiler_basis)
          val signatures =
            Compiler.Map.merge (fn (old, new) => new) (signatures, new_signatures)
d316 21
a336 6
          val debugger_context =
            CONTEXT {name = name,
                     topdec = topdec+1,
                     compiler_basis = compiler_basis,
                     inter_env = inter_env,
                     signatures = signatures}
a337 3
          (* Create a callable function from the generated code and invoke it, *)
          (* giving an untyped module. *)
          val module = load (debugger debugger_context, inter_env, code)
a338 15
          (* Incorporate the results of the loading into the interpreter *)
          (* environment to form the result context. *)
          val inter_env =
            Inter_EnvTypes.augment_with_module (inter_env, topdec_lambda_environment, module)
              handle Inter_EnvTypes.Augment =>
                crash (Error.Location.FILE filename, "Module does not match generated environment")
        in
          (CONTEXT {name = name,
                    topdec = topdec+1,
                    compiler_basis = compiler_basis,
                    signatures = signatures,
                    inter_env = inter_env},
          identifiers)
        end
    end
a339 1

d355 2
a356 1
                   signatures} = context
d372 2
a373 1
                  signatures = signatures},
d389 1
a389 1
                   inter_env, signatures} = context
d405 2
a406 1
                  signatures = signatures},
@


1.6
log
@Added return of identifiers from add_value and add_structure.
@
text
@d11 3
d261 1
a261 1
      fun add_topdec
d263 1
a263 2
           (CONTEXT {name, topdec, compiler_basis, inter_env, signatures},
            token_stream) =
d265 5
a269 1
          val filename = Lexer.associated_filename token_stream
d285 1
a285 1
            (false, token_stream)
@


1.5
log
@The incremental compiler now uses the generalised Compiler structure.
@
text
@d11 3
d270 4
a273 4
          val (_, {basis = topdec_compiler_basis,
                   signatures = new_signatures,
                   identifiers,
                   code}) =
d352 12
a363 11
        CONTEXT {name = name,
                 topdec = topdec+1,
                 compiler_basis =
                   Compiler.BASIS
                   {parser_basis = parser_basis,
                    type_basis = Basis.BASIS (nameset, functor_env, signature_env,
                                              Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
                    lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
                    debug_info = debug_info},
                 inter_env = inter_env,
                 signatures = signatures}
d384 12
a395 11
        CONTEXT {name = name,
                 topdec = topdec+1,
                 compiler_basis =
                   Compiler.BASIS
                   {parser_basis = parser_basis,
                    type_basis = Basis.BASIS (nameset, functor_env, signature_env,
                                              Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
                    lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
                    debug_info = debug_info},
                 inter_env = inter_env,
                 signatures = signatures}
@


1.4
log
@Removed inadequate add_source_file.
@
text
@d11 3
d25 1
a27 7
require "../lambda/lambda";
require "../lambda/lambdaoptimiser";
require "../lambda/lambdamodule";
require "../lambda/lambdaprint";
require "../mir/mir_cg";
require "../mir/miroptimiser";
require "../machine/mach_cg";
a35 2
require "../typechecker/mod_rules";
require "../main/primitives";
d39 1
a39 4
functor Incremental (structure Lambda : LAMBDA
                     structure LambdaOptimiser : LAMBDAOPTIMISER
                     structure LambdaModule : LAMBDAMODULE
                     structure LambdaPrint : LAMBDAPRINT
a40 3
                     structure Mir_Cg : MIR_CG
                     structure MirOptimiser : MIROPTIMISER
                     structure Mach_Cg : MACH_CG
a41 1
                     structure Mod_Rules : MODULE_RULES
a45 1
                     structure Primitives : PRIMITIVES
d53 2
a54 7
                     sharing MirOptimiser.Map =
                       GetTypeInformation.Basis.Tyvarenv.Datatypes.NewMap
                     sharing LambdaOptimiser.LambdaTypes =
                       LambdaPrint.LambdaTypes =
                       Mir_Cg.EnvironTypes.LambdaTypes
                     sharing Mir_Cg.EnvironTypes =
                       Environ.EnvironTypes =
d56 1
a56 4
                       LambdaModule.EnvironTypes =
                       Lambda.EnvironTypes =
                       GetTypeInformation.EnvironTypes =
                       Primitives.EnvironTypes
d58 1
a58 4
                       Mir_Cg.MirTypes.Debugger_Types =
                       Lambda.Debugger_Types
                     sharing MirOptimiser.MirTypes = Mir_Cg.MirTypes = Mach_Cg.MirTypes
                     sharing MirOptimiser.MachSpec = Mach_Cg.MachSpec
d60 1
a63 2
                       GetTypeInformation.Debugger_Types.Datatypes =
                       GetTypeInformation.Parser.Absyn.Datatypes =
d67 5
a71 7
                       Sigenv.Sigma.Nameset.Datatypes
                     sharing GetTypeInformation.Parser.Absyn =
                       Mod_Rules.Absyn = Lambda.Absyn
                     sharing GetTypeInformation.Basis =
                       Mod_Rules.Basis
                     sharing GetTypeInformation.Parser.Error =
                       GetTypeInformation.Parser.Lexer.Error
d74 2
a75 1
    structure Parser = GetTypeInformation.Parser
d77 2
a78 2
    structure Basis = GetTypeInformation.Basis
    structure EnvironTypes = GetTypeInformation.EnvironTypes
d80 1
a80 1
    structure Debugger_Types = GetTypeInformation.Debugger_Types
d102 1
a102 3
                  parser_basis		: Parser.ParserBasis,
                  type_basis		: Basis.Basis,
                  lambda_environment	: EnvironTypes.Top_Env,
a103 1
                  debug_info		: Debugger_Types.information,
d108 1
a108 3
      {compile_debug		: bool,
       compile_profile		: bool,
       error_output_level	: Error.severity,
a112 7
    datatype identifier =
      VALUE of Ident.ValId |
      EXCEPTION of Ident.ValId |
      TYPE of Ident.TyCon |
      STRUCTURE of Ident.StrId |
      SIGNATURE of Ident.SigId |
      FUNCTOR of Ident.FunId
a113 1

d133 11
a143 4
        val (_, _, info, builtin_env) =
          GetTypeInformation.get_type_information Io.builtin_library_name
        val (pb, tb, more_info, pervasive_env) =
          GetTypeInformation.get_type_information Io.pervasive_library_name
d145 12
d162 3
a164 7
                 parser_basis = Parser.augment_pB (Parser.initial_pB, pb),
                 type_basis = Basis.basis_circle_plus_basis (Basis.initial_basis, tb),
                 lambda_environment =
                   Environ.augment_top_env
                   (EnvironTypes.TOP_ENV
                    (Primitives.env_for_not_ml_definable_builtins, Environ.empty_fun_env),
                    Environ.make_external pervasive_env),
d169 2
a170 3
                     builtin_env, to_module builtin_library_module),
                    pervasive_env, to_module pervasive_library_module),
                 debug_info = Debugger_Types.augment_information (info, more_info),
d175 2
a176 5
    fun rename (CONTEXT {topdec, parser_basis, type_basis, lambda_environment,
                         inter_env, debug_info, signatures, ...}, name) =
      CONTEXT {parser_basis = parser_basis,
               type_basis = type_basis,
               lambda_environment = lambda_environment,
a177 1
               debug_info = debug_info,
d184 5
a188 3
    fun parser_basis (CONTEXT record) = #parser_basis record
    fun type_basis (CONTEXT record) = #type_basis record
    fun lambda_environment (CONTEXT record) = #lambda_environment record
a189 1
    fun debug_info (CONTEXT record) = #debug_info record
a196 32
      (*  == Transform require topdecs ==
       *
       *  The incremental compiler does not support the make system yet.  In
       *  order to support a user-defined make-system require topdecs are
       *  transformed into applications of a function called
       *  MLWorks_require.
       *)

      local
        open Absyn
      in
        fun transform_requires (Absyn.REQUIREtopdec filename) =
            STRDECtopdec
            (DECstrdec
             (VALdec
              ([],
               [(WILDpat,
                 APPexp (VALexp
                         (Ident.LONGVALID
                          (Ident.NOPATH, Ident.VAR (Ident.Symbol.find_symbol "MLWorks_require")),
                          ref Datatypes.NULLTYPE,
                          Location.UNKNOWN),
                         SCONexp (Ident.STRING filename),
                         Location.UNKNOWN,
                         ref Datatypes.NULLTYPE),
                 Location.UNKNOWN)],
               Set.empty_set)),
             Location.UNKNOWN)
          | transform_requires other = other
      end


a199 2
        structure MachTypes = Mach_Cg.MachTypes
        structure Ident = Inter_EnvTypes.Ident
d201 1
d256 2
a257 3
           (OPTIONS {compile_debug, debugger, error_output_level, ...})
           (CONTEXT {name, topdec, parser_basis, type_basis,
                     lambda_environment, inter_env, debug_info, signatures},
d267 10
a276 1
          val error_wrap = Error.wrap (Error.FATAL, Error.RECOVERABLE, error_output_level)
d278 2
a279 2
          val (absyn, topdec_parser_basis) =
            error_wrap Parser.parse_topdec (token_stream, parser_basis)
d281 10
a290 1
          val absyn = transform_requires absyn
a291 43
          val topdec_type_basis =
            error_wrap Mod_Rules.check_topdec (absyn, type_basis)

          val ((topdec_lambda_environment, lambda), debug_info) =
            let
              val (environment, bindings, debug_info) =
                error_wrap Lambda.trans_top_dec (absyn, lambda_environment, compile_debug, debug_info)
            in
              (LambdaModule.pack (environment, bindings), debug_info)
            end

          val lambda = LambdaOptimiser.optimise lambda

          val _ = diagnostic_fn
            (3, fn (_, stream) =>
             (output (stream, "Optimised lambda:\n");
              LambdaPrint.output_lambda (stream, lambda)))

          val (mir, debug_info) =
            error_wrap Mir_Cg.mir_cg (lambda, lambda_environment, filename, debug_info, compile_debug)

          val mir = MirOptimiser.optimise mir

          val (mach, debug_info) =
            let
              val {gc, non_gc, fp} = MirOptimiser.machine_register_assignments
            in
              error_wrap Mach_Cg.mach_cg (mir, (gc, non_gc, fp), compile_debug, debug_info)
            end

          (* Extract any signatured declared and store their abstract syntax *)
          (* so that it can be printed in future. *)
          val signatures =
            case absyn of
              Absyn.SIGNATUREtopdec sigbinds =>
                Lists.reducel
                (fn (map, Absyn.SIGBIND bindings) =>
                 Lists.reducel
                 (fn (map, (ident, exp, _)) => Map.define (map, ident, exp))
                 (map, bindings))
                (signatures, sigbinds)
            | _ => signatures

d294 1
a294 3
          (* a debugger specialised for that context, and incorporate the *)
          (* results of the loading into the interpreter environment to form *)
          (* the result context. *)
d296 3
a298 8
          val context =
            let
              val parser_basis = Parser.augment_pB (parser_basis, topdec_parser_basis)
              val type_basis = Basis.basis_circle_plus_basis (type_basis, topdec_type_basis)
              val lambda_environment =
                Environ.augment_top_env
                (lambda_environment,
                 Environ.make_external topdec_lambda_environment)
d300 6
a305 4
              val debugger_context =
                CONTEXT {name = name, topdec = topdec+1, parser_basis = parser_basis,
                         type_basis = type_basis, lambda_environment = lambda_environment,
                         inter_env = inter_env, debug_info = debug_info, signatures = signatures}
d307 3
a309 12
              (* Create a callable function from the generated code and invoke it, *)
              (* giving an untyped module. *)
              val module = load (debugger debugger_context, inter_env, mach)
            in
              CONTEXT {name = name, topdec = topdec+1, parser_basis = parser_basis,
                       type_basis = type_basis, lambda_environment = lambda_environment,
                       debug_info = debug_info, signatures = signatures,
                       inter_env =
                         Inter_EnvTypes.augment_with_module (inter_env, topdec_lambda_environment, module)
                         handle Inter_EnvTypes.Augment =>
                           crash (Error.Location.FILE filename, "Module does not match generated environment")}
            end
d311 6
a316 43
          (* Extract the list of new identifiers from the compilation result. *)
          val identifiers =
            let
              val Basis.BASIS (_,
                               Basis.Funenv.FUNENV functor_env,
                               Basis.Sigenv.SIGENV signature_env,
                               Datatypes.ENV (Datatypes.SE structure_env,
                                              Datatypes.TE type_env,
                                              Datatypes.VE (_, value_env),
                                              Datatypes.VE (_, exception_env))) = topdec_type_basis

              val identifiers =
                Map.fold
                (fn (identifiers, valid, _) => (VALUE valid)::identifiers)
                ([], value_env)

              val identifiers =
                Map.fold
                (fn (identifiers, tycon, _) => (TYPE tycon)::identifiers)
                (identifiers, type_env)

              val identifiers =
                Map.fold
                (fn (identifiers, valid, _) => (EXCEPTION valid)::identifiers)
                (identifiers, exception_env)

              val identifiers =
                Map.fold
                (fn (identifiers, strid, _) => (STRUCTURE strid)::identifiers)
                (identifiers, structure_env)

              val identifiers =
                Basis.Funenv.Phi.Sigma.Nameset.Datatypes.NewMap.fold
                (fn (identifiers, funid, _) => (FUNCTOR funid)::identifiers)
                (identifiers, functor_env)

              val identifiers =
                Basis.Sigenv.Sigma.Nameset.Datatypes.NewMap.fold
                (fn (identifiers, sigid, _) => (SIGNATURE sigid)::identifiers)
                (identifiers, signature_env)
            in
              identifiers
            end
d318 6
a323 1
          (context, identifiers)
d333 11
a343 5
          CONTEXT {name, topdec, parser_basis,
                   type_basis = Basis.BASIS (nameset, functor_env, signature_env,
                                             Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
                   lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
                   inter_env, debug_info, signatures} = context
d351 9
a359 5
                 parser_basis = parser_basis,
                 type_basis = Basis.BASIS (nameset, functor_env, signature_env,
                                           Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
                 lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
                 inter_env = inter_env, debug_info = debug_info, signatures = signatures}
d365 10
a374 5
          CONTEXT {name, topdec, parser_basis,
                   type_basis = Basis.BASIS (nameset, functor_env, signature_env,
                                             Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
                   lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
                   inter_env, debug_info, signatures} = context
d382 9
a390 5
                 parser_basis = parser_basis,
                 type_basis = Basis.BASIS (nameset, functor_env, signature_env,
                                           Datatypes.ENV (structure_env, type_env, value_env, exception_env)),
                 lambda_environment = EnvironTypes.TOP_ENV (lambda_env, lambda_functor_env),
                 inter_env = inter_env, debug_info = debug_info, signatures = signatures}
d394 1
@


1.3
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d11 3
d196 1
a196 1
                 signatures = Map.empty (Sigenv.sigid_order,Sigenv.sigid_equal)}
d225 32
d334 2
a458 27


    fun add_source_file options (context, filename) =
      let
        val stream = open_in filename
        val token_stream =
          Lexer.mkTokenStream (fn () => input (stream, 4096), filename)

        val (context, identifiers) =
          let
            fun next (context, identifiers) =
              if Lexer.eof token_stream then
                (context, identifiers)
              else
                let
                  val (context, more_identifiers) = add_topdec options (context, token_stream)
                in
                  next (context, identifiers @@ more_identifiers)
                end
          in
            next (context, [])
          end
            handle exn as (Error.Stop _) => (close_in stream; raise exn)
      in
        close_in stream;
        (context, identifiers)
      end
@


1.2
log
@add_topdec was returning the wrong context.
@
text
@d11 3
d193 1
a193 1
                 signatures = Map.empty Sigenv.sigid_order}
@


1.1
log
@Initial revision
@
text
@d10 4
a13 1
 *  $Log$
d416 1
a416 12
          (CONTEXT {name = name,
                    topdec = topdec+1,
                    parser_basis = Parser.augment_pB (parser_basis, topdec_parser_basis),
                    type_basis = Basis.basis_circle_plus_basis (type_basis, topdec_type_basis),
                    lambda_environment =
                      Environ.augment_top_env
                      (lambda_environment,
                       Environ.make_external topdec_lambda_environment),
                    inter_env = inter_env,
                    debug_info = debug_info,
                    signatures = signatures},
          identifiers)
@
