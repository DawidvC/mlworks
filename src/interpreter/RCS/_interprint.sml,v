head	1.66;
access;
symbols
	MLW_daveb_inline_1_4_99:1.66.1
	MLWorks_21c0_1999_03_25:1.66
	MLWorks_20c1_1998_08_20:1.65
	MLWorks_20c0_1998_08_04:1.65
	MLWorks_20b2c2_1998_06_19:1.65
	MLWorks_20b2_Windows_1998_06_12:1.65
	MLWorks_20b1c1_1998_05_07:1.65
	MLWorks_20b0_1998_04_07:1.65
	MLWorks_20b0_1998_03_20:1.65
	MLWorks_20m2_1998_02_16:1.64
	MLWorks_20m1_1997_10_23:1.64
	MLWorks_11r1:1.63.5.1.1.1.1
	MLWorks_workspace_97:1.64.2
	MLWorks_dt_wizard:1.64.1
	MLWorks_11c0_1997_09_09:1.63.5.1.1.1
	MLWorks_10r3:1.63.5.1.3
	MLWorks_10r2_551:1.63.5.1.2
	MLWorks_11:1.63.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.63.5.1
	MLWorks_20m0_1997_06_20:1.64
	MLWorks_1_0_r2c2_1997_06_14:1.63.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.63.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.63.5
	MLWorks_BugFix_1997_04_24:1.63
	MLWorks_1_0_r2_Win32_1997_04_11:1.63
	MLWorks_1_0_r2_Unix_1997_04_04:1.63
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.63.3.1.1
	MLWorks_gui_1996_12_18:1.63.4
	MLWorks_1_0_Win32_1996_12_17:1.63.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.63.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.63.1.1
	MLWorks_1_0_Irix_1996_11_28:1.63.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.63.2
	MLWorks_1_0_Unix_1996_11_14:1.63.1
	MLWorks_Open_Beta2_1996_10_11:1.60.2
	MLWorks_License_dev:1.60.1
	MLWorks_1_open_beta_1996_09_13:1.59.1
	MLWorks_Open_Beta_1996_08_22:1.59
	MLWorks_Beta_1996_07_02:1.58
	MLWorks_Beta_1996_06_07:1.58
	MLWorks_Beta_1996_06_06:1.58
	MLWorks_Beta_1996_06_05:1.58
	MLWorks_Beta_1996_06_03:1.58
	MLWorks_Beta_1996_05_31:1.58
	MLWorks_Beta_1996_05_30:1.58
	ML_beta_release_12/08/94:1.45
	ML_beta_release_03/08/94:1.44
	ML_revised_beta_release_25/05/94:1.40
	ML_final_beta_release_02/03/94:1.38
	mlworks-28-01-1994:1.36
	Release:1.31
	mlworks-beta-01-09-1993:1.31
	MLWorks-1-0-4-29/01/1993:1.17
	MLWorks-1-0-3-21/12/1992:1.16
	MLWorks-1-0-2-15/12/1992:1.15
	MLWorks-1-0-1-04/12/1992:1.14;
locks; strict;
comment	@ * @;


1.66
date	99.02.02.16.00.05;	author mitchell;	state Exp;
branches
	1.66.1.1;
next	1.65;

1.65
date	98.03.02.15.07.22;	author mitchell;	state Exp;
branches;
next	1.64;

1.64
date	97.05.22.14.03.29;	author jont;	state Exp;
branches
	1.64.1.1
	1.64.2.1;
next	1.63;

1.63
date	96.11.06.11.13.57;	author matthew;	state Exp;
branches
	1.63.1.1
	1.63.2.1
	1.63.3.1
	1.63.4.1
	1.63.5.1;
next	1.62;

1.62
date	96.10.30.15.12.26;	author io;	state Exp;
branches;
next	1.61;

1.61
date	96.10.23.11.31.19;	author andreww;	state Exp;
branches;
next	1.60;

1.60
date	96.09.05.17.02.28;	author andreww;	state Exp;
branches
	1.60.1.1
	1.60.2.1;
next	1.59;

1.59
date	96.08.05.18.18.50;	author andreww;	state Exp;
branches
	1.59.1.1;
next	1.58;

1.58
date	96.05.01.09.49.24;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	96.04.30.09.39.40;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	95.12.22.17.56.11;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	95.09.21.09.23.41;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	95.08.15.16.11.42;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	95.08.15.11.12.57;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	95.07.13.12.05.51;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	95.05.02.12.23.10;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	95.04.11.10.07.57;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	95.04.06.12.23.38;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	95.03.31.10.19.15;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	95.03.02.12.47.57;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	95.02.07.13.59.28;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	94.08.09.12.14.48;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	94.07.28.15.42.30;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	94.06.24.10.56.16;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	94.06.21.12.11.51;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	94.06.09.16.01.56;	author nickh;	state Exp;
branches;
next	1.40;

1.40
date	94.05.06.16.41.51;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	94.05.04.15.04.03;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	94.02.21.23.45.59;	author nosa;	state Exp;
branches;
next	1.37;

1.37
date	94.01.28.16.22.41;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	94.01.07.15.59.47;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	93.12.17.18.36.04;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.12.15.13.42.41;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	93.11.30.13.33.51;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.09.17.10.04.26;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	93.07.29.11.18.11;	author matthew;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	93.07.06.11.20.51;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	93.06.04.16.28.42;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.06.03.10.40.45;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.05.10.10.59.27;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.05.06.12.12.49;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.04.26.17.31.56;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	93.04.02.14.03.56;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.03.12.11.11.26;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.03.09.15.31.52;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.03.04.10.56.21;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	93.02.22.17.02.06;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.02.09.10.45.27;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.02.04.18.33.33;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.01.07.11.29.15;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	92.12.18.16.46.13;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.12.09.15.41.12;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.12.03.13.36.45;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.12.01.17.46.16;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	92.11.30.16.36.29;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	92.11.27.19.47.29;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	92.11.26.14.25.28;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.11.20.16.38.10;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.11.09.14.37.10;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	92.11.03.16.26.41;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	92.10.14.17.53.11;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.10.12.08.46.21;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.10.09.09.36.23;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.10.08.11.17.29;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.10.07.15.24.14;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.10.01.16.47.20;	author richard;	state Exp;
branches;
next	;

1.31.1.1
date	93.07.29.11.18.11;	author jont;	state Exp;
branches;
next	;

1.59.1.1
date	96.09.13.11.16.37;	author hope;	state Exp;
branches;
next	;

1.60.1.1
date	96.10.07.16.06.30;	author hope;	state Exp;
branches;
next	;

1.60.2.1
date	96.10.17.11.24.45;	author hope;	state Exp;
branches;
next	;

1.63.1.1
date	96.11.14.12.49.37;	author hope;	state Exp;
branches
	1.63.1.1.1.1;
next	;

1.63.1.1.1.1
date	96.11.28.15.00.51;	author hope;	state Exp;
branches;
next	;

1.63.2.1
date	96.11.22.18.09.12;	author hope;	state Exp;
branches;
next	;

1.63.3.1
date	96.12.17.17.47.51;	author hope;	state Exp;
branches
	1.63.3.1.1.1;
next	;

1.63.3.1.1.1
date	97.02.24.11.37.38;	author hope;	state Exp;
branches;
next	;

1.63.4.1
date	96.12.18.09.41.51;	author hope;	state Exp;
branches;
next	;

1.63.5.1
date	97.05.12.10.34.19;	author hope;	state Exp;
branches
	1.63.5.1.1.1
	1.63.5.1.2.1
	1.63.5.1.3.1;
next	;

1.63.5.1.1.1
date	97.07.28.18.19.23;	author daveb;	state Exp;
branches
	1.63.5.1.1.1.1.1;
next	;

1.63.5.1.1.1.1.1
date	97.10.07.11.44.31;	author jkbrook;	state Exp;
branches;
next	;

1.63.5.1.2.1
date	97.09.08.17.12.58;	author daveb;	state Exp;
branches;
next	;

1.63.5.1.3.1
date	97.09.09.14.08.36;	author daveb;	state Exp;
branches;
next	;

1.64.1.1
date	97.09.10.19.23.54;	author brucem;	state Exp;
branches;
next	;

1.64.2.1
date	97.09.11.20.54.47;	author daveb;	state Exp;
branches;
next	;

1.66.1.1
date	99.04.01.17.56.49;	author daveb;	state Exp;
branches;
next	;


desc
@Incremental context value printer.
Functor.
@


1.66
log
@[Bug #190500]
Remove redundant require statements
@
text
@(*  ==== INTERPRETER PRINTER ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: _interprint.sml,v $
 * Revision 1.65  1998/03/02  15:07:22  mitchell
 * [Bug #70074]
 * Add depth limit support for signature printing
 *
 * Revision 1.64  1997/05/22  14:03:29  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.63  1996/11/06  11:13:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.62  1996/10/30  15:12:26  io
 * [Bug #1614]
 * removing toplevel String
 *
 * Revision 1.61  1996/10/23  11:31:19  andreww
 * [Bug #1686]
 * extending parser environment
 *
 * Revision 1.60  1996/09/05  17:02:28  andreww
 * [Bug #1577]
 * Catching the "Unbound" exception in the print_identifier function
 *
 * Revision 1.59  1996/08/05  18:18:50  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml and _types.sml
 *
 * Revision 1.58  1996/05/01  09:49:24  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.57  1996/04/30  09:39:40  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.56  1995/12/22  17:56:11  jont
 * Remove Option in favour of MLWorks.Option
 *
 *  Revision 1.55  1995/09/21  09:23:41  daveb
 *  Changed printing of datatypes back, but kept separate printing of constructors
 *  as well.
 *
 *  Revision 1.54  1995/08/15  16:11:42  daveb
 *  I implemented the last change by changing the way datatypes are printed.
 *  I've now corrected this so that constructors are printed *separately*.
 *
 *  Revision 1.53  1995/08/15  11:12:57  daveb
 *  Changed printing of datatypes to emphasise the fact that
 *  the value constructors are bound as well as the type constructor.
 *
 *  Revision 1.52  1995/07/13  12:05:51  matthew
 *  Moving identifier type to Ident
 *
 *  Revision 1.51  1995/05/02  12:23:10  matthew
 *  Removing debug_polyvariables
 *
 *  Revision 1.50  1995/04/11  10:07:57  matthew
 *  Adding cached completion functions
 *
 *  Revision 1.49  1995/04/06  12:23:38  matthew
 *  Adding (debugging) output of internal structures.
 *
 *  Revision 1.48  1995/03/31  10:19:15  daveb
 *  Removed constructors from the list of results.
 *
 *  Revision 1.47  1995/03/02  12:47:57  daveb
 *  Removed the indentation argument to the strings function.
 *
 *  Revision 1.46  1995/02/07  13:59:28  matthew
 *  Changes to type lookup functions
 *
 *  Revision 1.45  1994/08/09  12:14:48  daveb
 *  Removed SourceResult type, and changed strings function to take a
 *  ParserBasis argument instead.
 *
 *  Revision 1.44  1994/07/28  15:42:30  daveb
 *  Removed definitions function.
 *
 *  Revision 1.43  1994/06/24  10:56:16  daveb
 *  Restored printing of fixity directives.
 *
 *  Revision 1.42  1994/06/21  12:11:51  daveb
 *  Added strings function, for tools that want to use the result strings.
 *
 *  Revision 1.41  1994/06/09  16:01:56  nickh
 *  New runtime directory structure.
 *
 *  Revision 1.40  1994/05/06  16:41:51  jont
 *  Add printing of fixity directives
 *
 *  Revision 1.39  1994/05/04  15:04:03  jont
 *  Fix printing of types in general to get the arity information right
 *  and to give the full information
 *
 *  Revision 1.38  1994/02/21  23:45:59  nosa
 *  Boolean indicators for Modules Debugger and Monomorphic debugger decapsulation.
 *
 *  Revision 1.37  1994/01/28  16:22:41  matthew
 *  Better locations in error messages
 *
 *  Revision 1.36  1994/01/07  15:59:47  matthew
 *  Print signature name when signature absyn is unknown.
 *
 *  Revision 1.35  1993/12/17  18:36:04  matthew
 *  Added option for depth of structure printing
 *
 *  Revision 1.34  1993/12/15  13:42:41  matthew
 *  Added level field to Basis.
 *
 *  Revision 1.33  1993/11/30  13:33:51  matthew
 *  Added is_abs field to TYNAME and METATYNAME
 *
 *  Revision 1.32  1993/09/17  10:04:26  nosa
 *  Print overloaded polymorphic values as functions for polymorphic debugger.
 *
 *  Revision 1.31  1993/07/29  11:18:11  matthew
 *  Removed error_info parameter from definitions
 *
 *  Revision 1.30  1993/07/06  11:20:51  daveb
 *  Removed exception environments.
 *
 *  Revision 1.29  1993/06/04  16:28:42  matthew
 *  Added space after tyvars in datatype printing
 *
 *  Revision 1.28  1993/06/03  10:40:45  matthew
 *  Added space before list of tyvars in type printing
 *
 *  Revision 1.27  1993/05/10  10:59:27  matthew
 *  Use ordered fold for printing datatypes etc.
 *
 *  Revision 1.26  1993/05/06  12:12:49  matthew
 *  Removed printer descriptors.
 *
 *  Revision 1.25  1993/04/26  17:31:56  daveb
 *  Moved print_tyvars and make_tyvars to _types.
 *
 *  Revision 1.24  1993/04/02  14:03:56  matthew
 *  Signature changes
 *
 *  Revision 1.23  1993/03/12  11:11:26  matthew
 *  Changed definitions to take an output function rather than a stream
 *
 *  Revision 1.22  1993/03/09  15:31:52  matthew
 *  Options & Info changes
 *  Removed InterMake from signature
 *
 *  Revision 1.21  1993/03/04  10:56:21  daveb
 *  Changed a call to output to a call to Info.error'.
 *  Changed references to std_out to the appropriate outstream.
 *
 *  Revision 1.20  1993/02/22  17:02:06  matthew
 *   Removed currying from completion interface
 *  Reinstated printing of COPYSTR's
 *
 *  Revision 1.19  1993/02/09  10:45:27  matthew
 *  Typechecker structure changes
 *
 *  Revision 1.18  1993/02/04  18:33:33  matthew
 *  Structure changes.
 *
 *  Revision 1.17  1993/01/07  11:29:15  matthew
 *  In print_typescheme_closed, removed the application of the type scheme which
 *  didn't handle imperative and equality attributes properly.
 *
 *  Revision 1.16  1992/12/18  16:46:13  jont
 *  Modified to produce longtycons when printing types out of structures
 *
 *  Revision 1.15  1992/12/09  15:41:12  clive
 *  Lower level changes going up
 *
 *  Revision 1.14  1992/12/03  13:36:45  jont
 *  Modified tyenv for efficiency
 *
 *  Revision 1.13  1992/12/01  17:46:16  daveb
 *  Changes to propagate compiler options as parameters instead of references.
 *
 *  Revision 1.12  1992/11/30  16:36:29  matthew
 *  Used pervasive streams
 *
 *  Revision 1.11  1992/11/27  19:47:29  daveb
 *  Changes to make show_id_class and show_eq_info part of Info structure
 *  instead of references.
 *
 *  Revision 1.10  1992/11/26  14:25:28  matthew
 *  Changed to use Stream structure
 *
 *  Revision 1.9  1992/11/20  16:38:10  jont
 *  Modified sharing constraints to remove superfluous structures
 *
 *  Revision 1.8  1992/11/09  14:37:10  daveb
 *  Added option type to control printing.
 *
 *  Revision 1.7  1992/11/03  16:26:41  richard
 *  Time is now represented by a pervasive structure.
 *
 *  Revision 1.6  1992/10/14  17:53:11  richard
 *  Added diagnostics.
 *
 *  Revision 1.5  1992/10/12  08:46:21  clive
 *  Tynames now have a slot recording their definition point
 *
 *  Revision 1.4  1992/10/09  09:36:23  clive
 *  Added printing of the values contained in structures
 *
 *  Revision 1.3  1992/10/08  11:17:29  clive
 *  Modified to use new value_printer
 *
 *  Revision 1.2  1992/10/07  15:24:14  richard
 *  Changes related to restructuring of Incremental.
 *
 *  Revision 1.1  1992/10/01  16:47:20  richard
 *  Initial revision
 *
 *)

require "^.basis.__text_io";
require "^.basis.__int";

require "../utils/diagnostic";
require "../lambda/topdecprint";
require "../basics/identprint";
require "../debugger/value_printer";
require "../lambda/environ";
require "../typechecker/basis";
require "../typechecker/environment";
require "../typechecker/valenv";
require "../typechecker/strenv";
require "../typechecker/tyenv";
require "../typechecker/types";
require "../typechecker/completion";
require "../typechecker/sigma";
require "../parser/parserenv";
require "../rts/gen/tags";
require "incremental";
require "interprint";

functor InterPrint (
  structure Incremental	: INCREMENTAL
  structure TopdecPrint	: TOPDECPRINT
  structure IdentPrint	: IDENTPRINT
  structure ValuePrinter: VALUE_PRINTER
  structure Environ     : ENVIRON
  structure Basis       : BASIS
  structure Env         : ENVIRONMENT
  structure Valenv	: VALENV
  structure Strenv	: STRENV 
  structure Tyenv	: TYENV
  structure Types	: TYPES
  structure Completion	: COMPLETION
  structure Sigma	: SIGMA
  structure ParserEnv	: PARSERENV
  structure Diagnostic	: DIAGNOSTIC
  structure Tags	: TAGS

  sharing Types.Datatypes.Ident = IdentPrint.Ident = ParserEnv.Ident
  sharing Incremental.InterMake.Compiler.Absyn = TopdecPrint.Absyn
  sharing Basis.BasisTypes.Datatypes = Completion.Datatypes =
    Types.Datatypes = Valenv.Datatypes = Tyenv.Datatypes = Strenv.Datatypes = Env.Datatypes
  sharing TopdecPrint.Options = Types.Options = IdentPrint.Options =
    Incremental.InterMake.Inter_EnvTypes.Options = Completion.Options =
    ValuePrinter.Options = Sigma.Options
  sharing Incremental.InterMake.Inter_EnvTypes.EnvironTypes = Environ.EnvironTypes
  sharing Incremental.InterMake.Compiler.NewMap =
    Basis.BasisTypes.Datatypes.NewMap
  sharing TopdecPrint.Absyn.Ident = Basis.BasisTypes.Datatypes.Ident =
    Environ.EnvironTypes.LambdaTypes.Ident
  sharing Basis.BasisTypes = Sigma.BasisTypes

  sharing type Incremental.InterMake.Compiler.DebugInformation =
    ValuePrinter.DebugInformation
  sharing type Environ.Structure = Basis.BasisTypes.Datatypes.Structure
  sharing type TopdecPrint.Absyn.Type = Basis.BasisTypes.Datatypes.Type = 
    ValuePrinter.Type = Environ.EnvironTypes.LambdaTypes.Type
  sharing type Incremental.InterMake.Compiler.TypeBasis = ValuePrinter.TypeBasis = Basis.BasisTypes.Basis
  sharing type Incremental.InterMake.Compiler.ParserBasis = ParserEnv.pB
) : INTERPRINT =
  struct
    structure Incremental = Incremental
    structure Datatypes = Types.Datatypes
    structure Map = Datatypes.NewMap
    structure Ident = Datatypes.Ident
    structure Inter_EnvTypes = Incremental.InterMake.Inter_EnvTypes
    structure Compiler = Incremental.InterMake.Compiler
    structure BasisTypes = Basis.BasisTypes
    structure Diagnostic = Diagnostic
    structure ValuePrinter = ValuePrinter
    structure Info = Compiler.Info
    structure Options = ValuePrinter.Options
    type Context = Incremental.Context

    fun diagnostic_fn (level, output_function) =
      Diagnostic.output_fn level
      (fn (verbosity, stream) => (TextIO.output (stream, "Incremental: ");
				  output_function (verbosity, stream)))

    val show_structures = false

    exception Undefined of Ident.Identifier

    val make_tyvars = Types.make_tyvars

    fun strings 
	  (context,
           options as
           Options.OPTIONS
	     {print_options,
	      compiler_options =
		Options.COMPILEROPTIONS
		  {generate_moduler, ...},
              compat_options =
                Options.COMPATOPTIONS
                  {old_definition, ...},
              ...},
           identifiers,
	   parser_basis) =
      let
        val cache_ref = ref (Completion.empty_cache ())
        fun print (so_far, string) = so_far ^ string
        val out = ""
        val signatures = Incremental.signatures context
        val type_basis = Incremental.type_basis context

        val fixity = case parser_basis of
	  ParserEnv.B(_, _, ParserEnv.E(ParserEnv.FE fixity_map, _, _,_)) =>
	    fixity_map

        val BasisTypes.BASIS (_,_, functor_env, _, environment as
                              Datatypes.ENV (structure_env,
                                             type_env,
                                             value_env)) = type_basis
        val inter_env = Incremental.inter_env context

	fun print_one_fixity(symbol, ParserEnv.LEFT i) =
	  "infix " ^ Int.toString i ^ " " ^
	  ParserEnv.Ident.Symbol.symbol_name symbol
	  | print_one_fixity(symbol, ParserEnv.RIGHT i) =
	    "infixr " ^ Int.toString i ^ " " ^
	    ParserEnv.Ident.Symbol.symbol_name symbol
	  | print_one_fixity(symbol, ParserEnv.NONFIX) = ""

	fun print_fixity (out, fix) =
	  let
	    val string = print_one_fixity fix
	  in
	    if string = "" then out
	    else
	      print(out, string ^ "\n")
	  end

        fun print_typescheme_closed(out, scheme) =
          case scheme of
            Datatypes.SCHEME (arity, (ty,_)) =>
              let
                val (str,newcache) = 
                  Completion.cached_print_type(options,
                                               environment,ty,!cache_ref)
              in
                cache_ref := newcache;
                print (out,str)
              end
          | Datatypes.UNBOUND_SCHEME (ty,_) =>
              let
                val (str,newcache) = Completion.cached_print_type
                  (options,environment,ty,!cache_ref)
              in
                cache_ref := newcache;
                print (out,str)
              end
          | Datatypes.OVERLOADED_SCHEME _ =>
              print (out, "<strange overloaded scheme>")

        fun print_indent (out, 0) = out
          | print_indent (out, indent) =
            let
              fun reduce (out, 0) = out
                | reduce (out, indent) =
                  if indent >= 8 then
                    reduce (print (out, "        "), indent-8)
                  else if indent >= 4 then
                    reduce (print (out, "    "), indent-4)
                  else if indent >= 2 then
                    reduce (print (out, "  "), indent-2)
                  else 
                    print (out, " ")
            in
              reduce (out, indent)
            end

	fun tyname_name(Datatypes.TYNAME{2=name, ...}) = name
	  | tyname_name(Datatypes.METATYNAME{2=name, ...}) = name

        fun print_value (out, indent,
			 valid as Ident.VAR _,
			 typescheme, value_opt) =
            let
              val out = print_indent (out, indent)
              val out = print (out, "val ")
              val out = print (out, IdentPrint.printValId print_options valid)
              val out = print (out, " : ")
              val out = print_typescheme_closed (out, typescheme)
            in
              case value_opt of
                NONE => print (out, " = _\n")
              | SOME value => 
                  let
                    val out = print (out, " = ")
                    val out =
                      let
                        val string =
                          case typescheme of
                            Datatypes.SCHEME (arity, (ty,_)) =>
                              ValuePrinter.stringify_value false
                              (print_options, value,
                               Types.apply (Datatypes.TYFUN (ty, arity), make_tyvars arity), 
                               Incremental.debug_info context)
                          | Datatypes.UNBOUND_SCHEME (ty,_) =>
                              ValuePrinter.stringify_value false
                              (print_options, value, ty,
                               Incremental.debug_info context)
                          | Datatypes.OVERLOADED_SCHEME _ =>
                              "<strange overloaded value>"
                      in
                        print (out, string)
                      end
                    val out = print (out, "\n")
                  in
                    out
                  end
            end
        |   print_value (out, indent, valid as Ident.EXCON _, typescheme, _) =
          let
            val out = print_indent (out, indent)
            val out = print (out, "exception ")
            val out = print (out, IdentPrint.printValId print_options valid)
            val out =
              case typescheme of
                Datatypes.UNBOUND_SCHEME (ty as Datatypes.FUNTYPE (arg, exn),_) =>
                  if Types.type_eq (exn, Types.exn_type, true, true) then
                    print (print (out, " of "),
			   Types.print_type options arg)
                  else
                    print (print (out, " <strange function type> "),
			   Types.print_type options ty)
              | Datatypes.UNBOUND_SCHEME (ty,_) =>
                  if Types.type_eq (ty, Types.exn_type, true, true) then
                    out
                  else
                    print (print (out, " <strange type> "),
			   Types.print_type options ty)
              | scheme => 
                  print_typescheme_closed (print (out, " <strange scheme> "),
					   scheme)
            val out = print (out, "\n")
          in
            out
          end
        |   print_value (out, indent, valid as Ident.CON _, typescheme, _) =
            let
              val out = print_indent (out, indent)
              val out = print (out, "val ")
              val out = print (out, IdentPrint.printValId print_options valid)
              val out = print (out, " : ")
              val out = print_typescheme_closed (out, typescheme)
            in
              print (out, "\n")
            end
        |   print_value {1=out, ...} = out

        fun print_type (out, indent, tycon,
			Datatypes.TYSTR(tyfun, value_env as
						 Datatypes.VE (_, values))) =

	  case tyfun of

	    Datatypes.NULL_TYFUN _ =>
	      let
		val out = print_indent (out, indent)
		val out = print (out, "<strange null tyfun> ")
		val out = print (out, IdentPrint.printTyCon tycon)
		val out = print (out, "\n")
	      in
		out
	      end

	  | Datatypes.ETA_TYFUN tyname =>
	      (case tyname of
		 Datatypes.METATYNAME{1=ref tyfun', ...} =>
		   print_type(out, indent, tycon,
			      Datatypes.TYSTR(tyfun', value_env))
	       | _ =>
                   if Valenv.empty_valenvp value_env then
                     let
                       val tyvars = make_tyvars (Types.tyname_arity tyname)
                       val out = print_indent (out, indent)
                       val out = print (out,
                                        if Types.eq_attrib tyname then
                                          "eqtype "
                                        else
                                          "type ")
                       val out = print (out, Types.print_tyvars options tyvars)
                       val out = case tyvars of [] => out | _ => print (out," ")
                       val out = print (out, IdentPrint.printTyCon tycon)
                       val out = print (out, " = ")
                       val out = print (out, Types.print_type 
                                        options
                                        (Types.apply (tyfun, tyvars)))
                       val out = print (out, "\n")
                     in
                       out
                     end
                   else
                     let
                       val tyvars = make_tyvars (Types.tyname_arity tyname)

                       val out = print_indent (out, indent)
                       val out = print (out, "datatype ")
                       val out = print (out, Types.print_tyvars options tyvars)
                       val out = case tyvars of [] => out | _ => 
                                                        print (out," ")
                       val out = print (out, IdentPrint.printTyCon tycon)

                       val (out, _) =
                         Datatypes.NewMap.fold_in_order
                         (fn ((out, first), valid, typescheme) =>
                          let
                            val out = print (out, if first then " =\n" else " |\n")
                            val out = print_indent (out, indent+2)
                            val out = print (out, IdentPrint.printValId print_options valid)
                          in
                            (case typescheme of
                               Datatypes.UNBOUND_SCHEME (Datatypes.FUNTYPE (arg, _),_) =>
                                 print (print (out, " of "), 
                                        Types.print_type options arg)
                             | Datatypes.UNBOUND_SCHEME _ => out
                             | Datatypes.SCHEME (arity, (ty,_)) =>
                                 (case Types.apply (Datatypes.TYFUN (ty, arity), tyvars) of
                                    Datatypes.FUNTYPE (arg, _) =>
                                      print (print (out, " of "), 
                                             Types.print_type options arg)
                                  | _ => out)
                             | Datatypes.OVERLOADED_SCHEME _ =>
                                 print (out, " <strange overloaded scheme>"),
                                 false)
                          end)
                         ((out, true), values)

                       val out = print (out, "\n")
                     in
                       out
                     end)

(*
		 let
		   val tyvars = make_tyvars (Types.tyname_arity tyname)
		   val out = print_indent (out, indent)
		   val out = print (out, if Types.eq_attrib tyname then "eqtype " else "type ")
		   val out = print (out, Types.print_tyvars tyvars)
		   val out = case tyvars of [] => out | _ => print (out," ")
		   val out = print (out, IdentPrint.printTyCon tycon)
		 in
		   if Valenv.empty_valenvp value_env then
		     let
		       val out = print (out, " = ")
		       val out = print (out, Types.print_type options
                                               (Types.apply (tyfun, tyvars)))
		     in
		       print (out, "\n")
		     end
		   else
		     print (out, "\n")
		 end)
*)

	  | tyfun as Datatypes.TYFUN (ty, arity) =>
	      let
		val tyvars = make_tyvars arity
		val out = print_indent (out, indent)
		val out = print (out, if Types.equalityp tyfun then "eqtype " else "type ")
		val out = print (out, Types.print_tyvars options tyvars)
		val out = if arity = 0 then out else print (out," ")
		val out = print (out, IdentPrint.printTyCon tycon)
		val out = print (out, " = ")
		val out = print (out, Types.print_type options
                                              (Types.apply (tyfun, tyvars)))
		val out = print (out, "\n")
	      in
		out
	      end

        exception ExpandStr

        fun print_structure (out, indent, depth, strid,
                             str,
                             value_opt) =
          let
            val out = print_indent (out, indent)
            val out = print (out, "structure ")
            val out = print (out, IdentPrint.printStrId strid)
            val out = if show_structures then print (print (out, ": "), Env.string_str str) else out
            val lambda_env = Environ.make_str_env (str,generate_moduler)

            val (_,_,Datatypes.ENV (Datatypes.SE structures,
                                    Datatypes.TE types,
                                    Datatypes.VE (_, values))) =
              case Env.expand_str str of
                Datatypes.STR data => data
              | _ => raise ExpandStr

            fun sub_structure (value, index) =
              let
                val primary = MLWorks.Internal.Value.primary value
              in
                if primary = Tags.PAIRPTR then
                  SOME (MLWorks.Internal.Value.sub (value, index))
                else if primary = Tags.POINTER then
                  SOME (MLWorks.Internal.Value.sub (value, index+1))
                else
                  NONE
              end
          in
            if depth = 0 
              then print (out, " = struct ... end\n")
            else
              let
                val out = print (out, " =\n")
                val out = print_indent (out, indent+2)
                val out = print (out, "struct\n")

                val out =
                  Datatypes.NewMap.fold_in_order
                  (fn (out, strid, str) => 
                   let
                     val substructure =
                       case value_opt of
                         NONE => NONE
                       | SOME value =>
                           (case Environ.lookup_strid (strid, lambda_env) of
                              (_, Environ.EnvironTypes.FIELD {index, ...}, _) =>
                                sub_structure (value, index)
                            | _ => NONE)
                   in
                     print_structure (out, indent+4, depth-1, strid, str, substructure)
                   end)
                  (out, structures)
                  
                val out =
                  Datatypes.NewMap.fold_in_order
                  (fn (out, tycon, tystr) => print_type (out, indent+4, tycon, tystr))
                  (out, types)
                  
                val out =
                  Datatypes.NewMap.fold_in_order
                  (fn (out, valid, typescheme) => 
                   let
                     val subvalue =
                       case value_opt of
                         NONE => NONE
                       | SOME value =>
                           (case Environ.lookup_valid
				   (valid, lambda_env) of
                              Environ.EnvironTypes.FIELD {index, ...} =>
                                sub_structure (value, index)
                            | _ => NONE)
                   in
                     print_value (out, indent+4, valid, typescheme, subvalue)
                   end)
                  (out,values)

                val out = print_indent (out, indent+2)
                val out = print (out, "end\n")
              in
                out
              end
          end

        fun print_signature (out, indent, sigid, sigexp) =
          let
            val out = print_indent (out, indent)
            val out = print (out, "signature ")
            val out = print (out, IdentPrint.printSigId sigid)
            val out = 
              if show_structures then
                let
                  val sigma = Basis.lookup_sigid (sigid,type_basis)
                in
                  print (print (out,": "), Sigma.string_sigma Options.default_print_options sigma)
                end
              else out
            val Options.PRINTOPTIONS{maximum_sig_depth,...} = print_options
          in 
            if (maximum_sig_depth = 0)
            then print(out, " = sig ... end\n")
            else 
              let val out = print(out, " =\n");
                  val out = TopdecPrint.print_sigexp options
                    print (out, indent+2, sigexp)
                  val out = print (out, "\n")
               in
                  out
              end
          end

        fun print_functor (out, indent, funid) =
          let
            val out = print_indent (out, indent)
            val out = print (out, "functor ")
            val out = print (out, IdentPrint.printFunId funid)
            val out = print (out, "\n")
            val out = 
              if show_structures then
                let
                  val phi = Basis.lookup_funid (funid,type_basis)
                in
                  print (out, Sigma.string_phi Options.default_print_options phi)
                end
              else out
          in
            out
          end

        fun print_identifier (out, ident as Ident.SIGNATURE sigid) =
            (print_signature (out, 0, sigid, Map.apply' (signatures, sigid))
               handle Map.Undefined => print (out,"signature " ^ IdentPrint.printSigId sigid ^ "\n"))
          | print_identifier (out, ident as Ident.VALUE valid) =
            (print_value (out, 0, valid,
			  Valenv.lookup (valid, value_env),
                          (SOME
			    (Inter_EnvTypes.lookup_val
			       (valid, inter_env)))
                          handle Map.Undefined => NONE)
                              (* This handler exists for the special case when
                                 we're replicating built-in datatypes: their
                                 definitions do not exist in the inter_env *)
             handle Valenv.LookupValId _ => raise Undefined ident)
          | print_identifier (out, ident as Ident.TYPE tycon) =
            (print_type (out, 0, tycon, Tyenv.lookup (type_env, tycon))
               handle Tyenv.LookupTyCon _ => raise Undefined ident)
          | print_identifier (out, ident as Ident.STRUCTURE strid) =
            let
              val Options.PRINTOPTIONS{maximum_str_depth,...} = print_options
            in
              case Strenv.lookup (strid, structure_env) of
                SOME str =>
                  (print_structure (out, 0, maximum_str_depth, strid, 
                                    str,
                                    SOME(Inter_EnvTypes.lookup_str (strid, inter_env))))
              | _ => raise Undefined ident
            end
          | print_identifier (out, ident as Ident.FUNCTOR funid) =
            print_functor(out, 0, funid)

	fun group_by_class ([], sigs, funs, strs, types, values) =
	  (rev sigs, rev funs, rev strs, rev types, rev values)
	|   group_by_class ((ident as Ident.SIGNATURE _) :: t, sigs, funs, strs, types, values) =
	  group_by_class (t, ident :: sigs, funs, strs, types, values)
	|   group_by_class ((ident as Ident.FUNCTOR _) :: t, sigs, funs, strs, types, values) =
	  group_by_class (t, sigs, ident :: funs, strs, types, values)
	|   group_by_class ((ident as Ident.STRUCTURE _) :: t, sigs, funs, strs, types, values) =
	  group_by_class (t, sigs, funs, ident :: strs, types, values)
	|   group_by_class ((ident as Ident.TYPE _) :: t, sigs, funs, strs, types, values) =
	  group_by_class (t, sigs, funs, strs, ident :: types, values)
	|   group_by_class ((ident as Ident.VALUE _) :: t, sigs, funs, strs, types, values) =
	  group_by_class (t, sigs, funs, strs, types, ident :: values)

	val (sigs, funs, strs, types, values) =
	  group_by_class (identifiers, [], [], [], [], [])
      in
        diagnostic_fn
        (1,
	 fn (_, stream) =>
	 app
           (fn Ident.SIGNATURE sigid =>
	       TextIO.output(stream,
		      concat ["signature ", IdentPrint.printSigId sigid, "\n"]
	             )
             | Ident.STRUCTURE strid =>
	       TextIO.output(stream,
		      concat ["structure ", IdentPrint.printStrId strid, "\n"]
		     )
             | Ident.VALUE (valid as Ident.EXCON _) =>
	       TextIO.output(stream,
		      concat ["exception ", IdentPrint.printValId print_options valid, "\n"]
		     )
             | Ident.VALUE valid =>
	       TextIO.output(stream,
		      concat ["value ",     IdentPrint.printValId print_options valid, "\n"]
		     )
             | Ident.TYPE      tycon =>
	       TextIO.output(stream,
		      concat ["type ",      IdentPrint.printTyCon tycon, "\n"]
		     )
             | Ident.FUNCTOR   funid =>
	       TextIO.output(stream,
		      concat ["functor ",   IdentPrint.printFunId funid, "\n"]
		     )
	   )
           identifiers
	);
	map
	  (fn entry as (sym, fix) =>
	     (Ident.VALUE (Ident.VAR sym), print_fixity (out, entry)))
	  (ParserEnv.Map.to_list fixity)
	@@ map (fn id => (id, print_identifier (out, id))) sigs
	@@ map (fn id => (id, print_identifier (out, id))) funs
	@@ map (fn id => (id, print_identifier (out, id))) strs
	@@ map (fn id => (id, print_identifier (out, id))) types
	@@ map (fn id => (id, print_identifier (out, id))) values
      end
  end
@


1.66.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
 * Revision 1.66  1999/02/02  16:00:05  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.65
log
@[Bug #70074]
Add depth limit support for signature printing
@
text
@d8 4
a226 1
require "^.basis.__list";
@


1.64
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d8 4
d695 12
a706 6
            val out = print (out, " =\n")
            val out = TopdecPrint.print_sigexp options
              print (out, indent+2, sigexp)
            val out = print (out, "\n")
          in
            out
@


1.64.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
 * Revision 1.64  1997/05/22  14:03:29  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.64.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
 * Revision 1.64  1997/05/22  14:03:29  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.63
log
@[Bug #1728]
__integer becomes __int
@
text
@d8 4
d217 1
d295 1
a295 1
      (fn (verbosity, stream) => (MLWorks.IO.output (stream, "Incremental: ");
d769 1
a769 1
	       MLWorks.IO.output(stream,
d773 1
a773 1
	       MLWorks.IO.output(stream,
d777 1
a777 1
	       MLWorks.IO.output(stream,
d781 1
a781 1
	       MLWorks.IO.output(stream,
d785 1
a785 1
	       MLWorks.IO.output(stream,
d789 1
a789 1
	       MLWorks.IO.output(stream,
@


1.63.5.1
log
@branched from 1.63
@
text
@a7 4
 * Revision 1.63  1996/11/06  11:13:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.63.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.63.5.1  1997/05/12  10:34:19  hope
 * branched from 1.63
 *
@


1.63.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.63.5.1  1997/05/12  10:34:19  hope
 * branched from 1.63
 *
@


1.63.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.63.5.1  1997/05/12  10:34:19  hope
 * branched from 1.63
 *
@


1.63.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.63.5.1.1.1  1997/07/28  18:19:23  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.63.4.1
log
@branched from 1.63
@
text
@a7 4
 * Revision 1.63  1996/11/06  11:13:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.63.3.1
log
@branched from 1.63
@
text
@a7 4
 * Revision 1.63  1996/11/06  11:13:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.63.3.1.1.1
log
@branched from 1.63.3.1
@
text
@a7 3
 * Revision 1.63.3.1  1996/12/17  17:47:51  hope
 * branched from 1.63
 *
@


1.63.2.1
log
@branched from 1.63
@
text
@a7 4
 * Revision 1.63  1996/11/06  11:13:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.63.1.1
log
@branched from 1.63
@
text
@a7 4
 * Revision 1.63  1996/11/06  11:13:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.63.1.1.1.1
log
@branched from 1.63.1.1
@
text
@a7 3
 * Revision 1.63.1.1  1996/11/14  12:49:37  hope
 * branched from 1.63
 *
@


1.62
log
@[Bug #1614]
removing toplevel String
@
text
@d8 4
d213 1
a213 1
require "^.basis.__integer";
@


1.61
log
@[Bug #1686]
extending parser environment
@
text
@d8 4
d209 2
a210 1
require "../basis/__integer";
a211 1
require "../utils/lists";
a244 1
  structure Lists	: LISTS
d396 2
a397 2
                MLWorks.Option.NONE => print (out, " = _\n")
              | MLWorks.Option.SOME value => 
d607 1
a607 1
                  MLWorks.Option.SOME (MLWorks.Internal.Value.sub (value, index))
d609 1
a609 1
                  MLWorks.Option.SOME (MLWorks.Internal.Value.sub (value, index+1))
d611 1
a611 1
                  MLWorks.Option.NONE
d628 2
a629 2
                         MLWorks.Option.NONE => MLWorks.Option.NONE
                       | MLWorks.Option.SOME value =>
d633 1
a633 1
                            | _ => MLWorks.Option.NONE)
d650 2
a651 2
                         MLWorks.Option.NONE => MLWorks.Option.NONE
                       | MLWorks.Option.SOME value =>
d656 1
a656 1
                            | _ => MLWorks.Option.NONE)
d714 1
a714 1
                          (MLWorks.Option.SOME
d730 1
a730 1
                MLWorks.Option.SOME str =>
d733 1
a733 1
                                    MLWorks.Option.SOME(Inter_EnvTypes.lookup_str (strid, inter_env))))
d758 1
a758 1
           Lists.iterate
d761 1
a761 1
		      String.implode ["signature ", IdentPrint.printSigId sigid, "\n"]
d765 1
a765 1
		      String.implode ["structure ", IdentPrint.printStrId strid, "\n"]
d769 1
a769 1
		      String.implode ["exception ", IdentPrint.printValId print_options valid, "\n"]
d773 1
a773 1
		      String.implode ["value ",     IdentPrint.printValId print_options valid, "\n"]
d777 1
a777 1
		      String.implode ["type ",      IdentPrint.printTyCon tycon, "\n"]
d781 1
a781 1
		      String.implode ["functor ",   IdentPrint.printFunId funid, "\n"]
@


1.60
log
@[Bug #1577]
Catching the "Unbound" exception in the print_identifier function
@
text
@d8 4
d314 1
a314 1
	  ParserEnv.B(_, _, ParserEnv.E(ParserEnv.FE fixity_map, _, _)) =>
@


1.60.2.1
log
@branched from 1.60
@
text
@a7 4
 * Revision 1.60  1996/09/05  17:02:28  andreww
 * [Bug #1577]
 * Catching the "Unbound" exception in the print_identifier function
 *
@


1.60.1.1
log
@branched from 1.60
@
text
@a7 4
 * Revision 1.60  1996/09/05  17:02:28  andreww
 * [Bug #1577]
 * Catching the "Unbound" exception in the print_identifier function
 *
@


1.59
log
@[Bug #1521]
Propagating changes made to typechecker/_scheme.sml and _types.sml
@
text
@d8 4
d707 1
a707 1
                          MLWorks.Option.SOME
d710 4
@


1.59.1.1
log
@branched from 1.59
@
text
@a7 4
 * Revision 1.59  1996/08/05  18:18:50  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml and _types.sml
 *
@


1.58
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d8 6
d286 1
d292 4
a295 1
	      ...},
d336 3
a338 1
                val (str,newcache) = Completion.cached_print_type(print_options,environment,ty,!cache_ref)
d345 2
a346 1
                val (str,newcache) = Completion.cached_print_type(print_options,environment,ty,!cache_ref)
d422 1
a422 1
			   Types.print_type print_options arg)
d425 1
a425 1
			   Types.print_type print_options ty)
d431 1
a431 1
			   Types.print_type print_options ty)
d482 1
a482 1
                       val out = print (out, Types.print_tyvars tyvars)
d486 3
a488 1
                       val out = print (out, Types.print_type print_options (Types.apply (tyfun, tyvars)))
d499 3
a501 2
                       val out = print (out, Types.print_tyvars tyvars)
                       val out = case tyvars of [] => out | _ => print (out," ")
d514 2
a515 1
                                 print (print (out, " of "), Types.print_type print_options arg)
d520 2
a521 1
                                      print (print (out, " of "), Types.print_type print_options arg)
d546 2
a547 2
		       val out = print (out, Types.print_type
					       print_options (Types.apply (tyfun, tyvars)))
d561 1
a561 1
		val out = print (out, Types.print_tyvars tyvars)
d565 2
a566 1
		val out = print (out, Types.print_type print_options (Types.apply (tyfun, tyvars)))
d672 2
a673 1
            val out = TopdecPrint.print_sigexp print_options print (out, indent+2, sigexp)
@


1.57
log
@Removing MLWorks.Integer
@
text
@d8 3
d269 1
a269 1
      (fn (verbosity, stream) => (output (stream, "Incremental: ");
d725 2
a726 2
	       output(stream,
		      implode ["signature ", IdentPrint.printSigId sigid, "\n"]
d729 2
a730 2
	       output(stream,
		      implode ["structure ", IdentPrint.printStrId strid, "\n"]
d733 2
a734 2
	       output(stream,
		      implode ["exception ", IdentPrint.printValId print_options valid, "\n"]
d737 2
a738 2
	       output(stream,
		      implode ["value ",     IdentPrint.printValId print_options valid, "\n"]
d741 2
a742 2
	       output(stream,
		      implode ["type ",      IdentPrint.printTyCon tycon, "\n"]
d745 2
a746 2
	       output(stream,
		      implode ["functor ",   IdentPrint.printFunId funid, "\n"]
@


1.56
log
@Remove Option in favour of MLWorks.Option
@
text
@d8 3
d188 2
d303 1
a303 1
	  "infix " ^ MLWorks.Integer.makestring i ^ " " ^
d306 1
a306 1
	    "infixr " ^ MLWorks.Integer.makestring i ^ " " ^
@


1.55
log
@Changed printing of datatypes back, but kept separate printing of constructors
as well.
@
text
@d8 4
a185 1
require "../utils/option";
a219 1
  structure Option	: OPTION
d364 2
a365 2
                Option.ABSENT => print (out, " = _\n")
              | Option.PRESENT value => 
d569 1
a569 1
                  Option.PRESENT (MLWorks.Internal.Value.sub (value, index))
d571 1
a571 1
                  Option.PRESENT (MLWorks.Internal.Value.sub (value, index+1))
d573 1
a573 1
                  Option.ABSENT
d590 2
a591 2
                         Option.ABSENT => Option.ABSENT
                       | Option.PRESENT value =>
d595 1
a595 1
                            | _ => Option.ABSENT)
d612 2
a613 2
                         Option.ABSENT => Option.ABSENT
                       | Option.PRESENT value =>
d618 1
a618 1
                            | _ => Option.ABSENT)
d675 1
a675 1
                          Option.PRESENT
d690 1
a690 1
                                    Option.PRESENT(Inter_EnvTypes.lookup_str (strid, inter_env))))
@


1.54
log
@I implemented the last change by changing the way datatypes are printed.
I've now corrected this so that constructors are printed *separately*.
@
text
@d8 4
d450 57
d526 1
@


1.53
log
@Changed printing of datatypes to emphasise the fact that
the value constructors are bound as well as the type constructor.
@
text
@d8 4
d412 10
d446 8
a455 10
		       val tyvars = make_tyvars (Types.tyname_arity tyname)
		       val out = print_indent (out, indent)
		       val out = print (out,
					if Types.eq_attrib tyname then
					  "eqtype "
					else
					  "type ")
		       val out = print (out, Types.print_tyvars tyvars)
		       val out = case tyvars of [] => out | _ => print (out," ")
		       val out = print (out, IdentPrint.printTyCon tycon)
d457 2
a458 2
		       val out = print (out, Types.print_type print_options (Types.apply (tyfun, tyvars)))
		       val out = print (out, "\n")
d460 1
a460 1
		       out
d463 2
a464 41
		     let
		       val tyvars = make_tyvars (Types.tyname_arity tyname)

		       val out = print_indent (out, indent)
		       val out = print (out, "type ")
		       val out = print (out, Types.print_tyvars tyvars)
		       val out = case tyvars of [] => out | _ => print (out," ")
		       val out = print (out, IdentPrint.printTyCon tycon)
		       val out = print (out, "\n")

		       fun print_value_con (out, valid, typescheme) =
			 let
			   val out = print_indent (out, indent)
			   val out = print (out, "val ")
			   val out = print (out, IdentPrint.printValId print_options valid)
			   val out = print (out, " : ")
			   val out =
			     case typescheme of
			       Datatypes.UNBOUND_SCHEME (Datatypes.FUNTYPE (arg, _),_) =>
				 print (print (out, Types.print_type print_options arg), " -> ")
			     | Datatypes.UNBOUND_SCHEME _ => out
			     | Datatypes.SCHEME (arity, (ty,_)) =>
				 (case Types.apply (Datatypes.TYFUN (ty, arity), tyvars) of
				    Datatypes.FUNTYPE (arg, _) =>
				      print
					(print (out, Types.print_type print_options arg), " -> ")
				  | _ => out)
			     | Datatypes.OVERLOADED_SCHEME _ =>
				 print (out, " <strange overloaded scheme>")
			   val out = print (out, IdentPrint.printTyCon tycon)
			 in
		           print (out, "\n")
			 end

		       val out =
			 Datatypes.NewMap.fold_in_order
			   print_value_con
			   (out, values)
		     in
		       out
		     end)
d632 12
a643 2
        fun is_constructor (Ident.VALUE (Ident.CON _)) = true
        |   is_constructor _ = false
d645 2
a646 1
	val identifiers = Lists.filter_outp is_constructor identifiers
d683 5
a687 1
	@@ map (fn id => (id, print_identifier (out, id))) identifiers
@


1.52
log
@Moving identifier type to Ident
@
text
@d8 3
d455 1
a455 1
		       val out = print (out, "datatype ")
d459 1
d461 8
a468 9
		       val (out, _) =
			 Datatypes.NewMap.fold_in_order
			 (fn ((out, first), valid, typescheme) =>
			  let
			    val out = print (out, if first then " =\n" else " |\n")
			    val out = print_indent (out, indent+2)
			    val out = print (out, IdentPrint.printValId print_options valid)
			  in
			    (case typescheme of
d470 1
a470 1
				 print (print (out, " of "), Types.print_type print_options arg)
d475 2
a476 1
				      print (print (out, " of "), Types.print_type print_options arg)
d479 5
a483 4
				 print (out, " <strange overloaded scheme>"),
				 false)
			  end)
			 ((out, true), values)
d485 4
a488 1
		       val out = print (out, "\n")
@


1.51
log
@Removing debug_polyvariables
@
text
@d8 3
d253 1
a253 1
    exception Undefined of Compiler.identifier
d624 1
a624 1
        fun print_identifier (out, ident as Compiler.SIGNATURE sigid) =
d627 1
a627 1
          | print_identifier (out, ident as Compiler.VALUE valid) =
d634 1
a634 1
          | print_identifier (out, ident as Compiler.TYPE tycon) =
d637 1
a637 1
          | print_identifier (out, ident as Compiler.STRUCTURE strid) =
d648 1
a648 1
          | print_identifier (out, ident as Compiler.FUNCTOR funid) =
d651 1
a651 1
        fun is_constructor (Compiler.VALUE (Ident.CON _)) = true
d660 1
a660 1
           (fn Compiler.SIGNATURE sigid =>
d664 1
a664 1
             | Compiler.STRUCTURE strid =>
d668 1
a668 1
             | Compiler.VALUE (valid as Ident.EXCON _) =>
d672 1
a672 1
             | Compiler.VALUE valid =>
d676 1
a676 1
             | Compiler.TYPE      tycon =>
d680 1
a680 1
             | Compiler.FUNCTOR   funid =>
d689 1
a689 1
	     (Compiler.VALUE (Ident.VAR sym), print_fixity (out, entry)))
@


1.50
log
@Adding cached completion functions
@
text
@d8 3
d260 1
a260 1
		  {debug_polyvariables, generate_moduler, ...},
a358 9
                               if debug_polyvariables then
                                (case Types.all_tyvars(ty) of
                                   nil => 
                                     Types.apply (Datatypes.TYFUN (ty, arity), make_tyvars arity)
                                 | _ => 
                                     Datatypes.FUNTYPE(Types.int_type,
                                                   Types.apply (Datatypes.TYFUN (ty, arity), 
                                                                make_tyvars arity)))
                               else
@


1.49
log
@Adding (debugging) output of internal structures.
@
text
@d8 3
d262 1
d298 6
a303 1
              print (out,Completion.print_type(print_options,environment,ty))
d305 6
a310 1
              print (out,Completion.print_type(print_options,environment,ty))
@


1.48
log
@Removed constructors from the list of results.
@
text
@d8 3
d168 1
a168 1
require "../typechecker/basistypes";
d175 1
d187 1
a187 1
  structure BasisTypes  : BASISTYPES
d194 1
d203 1
a203 1
  sharing BasisTypes.Datatypes = Completion.Datatypes =
d207 1
a207 1
    ValuePrinter.Options
d210 2
a211 2
    BasisTypes.Datatypes.NewMap
  sharing TopdecPrint.Absyn.Ident = BasisTypes.Datatypes.Ident =
d213 1
d217 2
a218 2
  sharing type Environ.Structure = BasisTypes.Datatypes.Structure
  sharing type TopdecPrint.Absyn.Type = BasisTypes.Datatypes.Type = 
d220 1
a220 1
  sharing type Incremental.InterMake.Compiler.TypeBasis = ValuePrinter.TypeBasis = BasisTypes.Basis
d230 1
a230 1
    structure BasisTypes = BasisTypes
d242 2
a316 12
        fun print_signature (out, indent, sigid, sigexp) =
          let
            val out = print_indent (out, indent)
            val out = print (out, "signature ")
            val out = print (out, IdentPrint.printSigId sigid)
            val out = print (out, " =\n")
            val out = TopdecPrint.print_sigexp print_options print (out, indent+2, sigexp)
            val out = print (out, "\n")
          in
            out
          end

d489 2
d492 1
a492 5
                             str as Datatypes.STR
			       (_,_,Datatypes.ENV
				      (Datatypes.SE structures,
                                       Datatypes.TE types,
                                       Datatypes.VE (_, values))),
d498 2
d501 6
a506 1
            val lambda_env = Environ.make_str_env (str,generate_moduler)
d574 20
a593 2
          | print_structure (out,indent,depth,strid,str as Datatypes.COPYSTR _,value_opt) =
            print_structure (out,indent,depth,strid,Env.expand_str str,value_opt)
d601 8
@


1.47
log
@Removed the indentation argument to the strings function.
@
text
@d8 3
d612 5
@


1.46
log
@Changes to type lookup functions
@
text
@d8 3
a238 1
	   parser_basis,
d245 2
a246 1
           indent, identifiers) =
d584 1
a584 1
            (print_signature (out, indent, sigid, Map.apply' (signatures, sigid))
d587 1
a587 1
            (print_value (out, indent, valid,
d594 1
a594 1
            (print_type (out, indent, tycon, Tyenv.lookup (type_env, tycon))
d602 1
a602 1
                  (print_structure (out, indent, maximum_str_depth, strid, 
d608 1
a608 1
            print_functor(out, indent, funid)
@


1.45
log
@Removed SourceResult type, and changed strings function to take a
ParserBasis argument instead.
@
text
@d8 4
d152 3
a154 1
require "incremental";
a166 3
require "../utils/lists";
require "../utils/option";
require "../utils/diagnostic";
d168 1
a326 1
                handle Valenv.Lookup_in_VE => raise Undefined (Compiler.VALUE valid)
d589 1
a589 1
             handle Valenv.Lookup_in_VE => raise Undefined ident)
d592 1
a592 1
               handle Tyenv.Lookup_in_TE => raise Undefined ident)
d597 6
a602 4
              (print_structure (out, indent, maximum_str_depth, strid, 
                                Strenv.lookup (strid, structure_env),
                                Option.PRESENT(Inter_EnvTypes.lookup_str (strid, inter_env)))
              handle Strenv.Lookup_in_SE => raise Undefined ident)
@


1.44
log
@Removed definitions function.
@
text
@d8 3
a229 6
    type SourceResult = 
      Compiler.basis * 
      (Ident.SigId,TopdecPrint.Absyn.SigExp) Map.T *
      MLWorks.Internal.Value.T *
      string

d232 1
a232 1
	   (basis, signatures, module, _),
a245 2
	val Compiler.BASIS {parser_basis, ...} = basis
	
@


1.43
log
@Restored printing of fixity directives.
@
text
@d8 3
a217 4
    fun diagnostic (level, output_function) =
      Diagnostic.output level
      (fn verbosity => "Incremental: " :: (output_function verbosity))

a225 424

    fun definitions 
          do_output
	  (context,
           Options.OPTIONS{print_options,
                           compiler_options = 
                           Options.COMPILEROPTIONS{debug_polyvariables,
                                                                generate_moduler, ...}, ...},
           indent,
           identifiers,
	   parser_basis) =
      let
        fun print (_,string) = do_output string
        val out = ()
        val signatures = Incremental.signatures context
        val fixity = case parser_basis of
	  ParserEnv.B(_, _, ParserEnv.E(ParserEnv.FE fixity_map, _, _)) => fixity_map
        val BasisTypes.BASIS
	      (_,_, functor_env, _,
	       environment as Datatypes.ENV
		 (structure_env, type_env, value_env)) =
	  Incremental.type_basis context
        val inter_env = Incremental.inter_env context

	fun print_one_fixity(symbol, ParserEnv.LEFT i) =
	  "infix " ^ MLWorks.Integer.makestring i ^ " " ^
	  ParserEnv.Ident.Symbol.symbol_name symbol
	  | print_one_fixity(symbol, ParserEnv.RIGHT i) =
	    "infixr " ^ MLWorks.Integer.makestring i ^ " " ^
	    ParserEnv.Ident.Symbol.symbol_name symbol
	  | print_one_fixity(symbol, ParserEnv.NONFIX) = ""

	fun print_fixity fix =
	  let
	    val string = print_one_fixity fix
	  in
	    if string = "" then ()
	    else
	      print(out, string ^ "\n")
	  end

        fun print_typescheme_closed(out, scheme) =
          case scheme of
            Datatypes.SCHEME (arity, (ty,_)) =>
              print
		(out,
		 Completion.print_type
		   (print_options, environment, ty))
          | Datatypes.UNBOUND_SCHEME (ty,_) =>
              print
		(out,
		 Completion.print_type
		   (print_options, environment, ty))
          | Datatypes.OVERLOADED_SCHEME _ =>
              print (out, "<strange overloaded scheme>")

	(*
        fun print_typescheme_open(out, tyvars, scheme) =
          case scheme of
            Datatypes.SCHEME (arity, (ty,_)) =>
              let
                val ty = Types.apply (Datatypes.TYFUN (ty, arity), tyvars)
              in
                print (out,Completion.print_type(print_options,environment,ty))
              end
          | Datatypes.UNBOUND_SCHEME (ty,_) =>
                print (out, Completion.print_type(print_options,environment,ty))
          | Datatypes.OVERLOADED_SCHEME _ =>
              print (out, "<strange overloaded scheme>")
	*)

        fun print_indent (out, 0) = out
          | print_indent (out, indent) =
            let
              fun reduce (out, 0) = out
                | reduce (out, indent) =
                  if indent >= 8 then
                    reduce (print (out, "        "), indent-8)
                  else if indent >= 4 then
                    reduce (print (out, "    "), indent-4)
                  else if indent >= 2 then
                    reduce (print (out, "  "), indent-2)
                  else 
                    print (out, " ")
            in
              reduce (out, indent)
            end

        fun print_signature (out, indent, sigid, sigexp) =
          let
            val out = print_indent (out, indent)
            val out = print (out, "signature ")
            val out = print (out, IdentPrint.printSigId sigid)
            val out = print (out, " =\n")
            val out = TopdecPrint.print_sigexp print_options print (out, indent+2, sigexp)
            val out = print (out, "\n")
          in
            out
          end

	fun tyname_name(Datatypes.TYNAME{2=name, ...}) = name
	  | tyname_name(Datatypes.METATYNAME{2=name, ...}) = name

        fun print_value (out, indent,
			 valid as Ident.VAR _,
			 typescheme, value_opt) =
            let
              val out = print_indent (out, indent)
              val out = print (out, "val ")
              val out = print (out, IdentPrint.printValId print_options valid)
              val out = print (out, " : ")
              val out = print_typescheme_closed (out, typescheme)
                handle Valenv.Lookup_in_VE => raise Undefined (Compiler.VALUE valid)
            in
              case value_opt of
                Option.ABSENT => print (out, " = _\n")
              | Option.PRESENT value => 
                  let
                    val out = print (out, " = ")
                    val out =
                      let
                        val string =
                          case typescheme of
                            Datatypes.SCHEME (arity, (ty,_)) =>
                              ValuePrinter.stringify_value false
                              (print_options, value,
                               if debug_polyvariables then
                                (case Types.all_tyvars(ty) of
                                   nil => 
                                     Types.apply (Datatypes.TYFUN (ty, arity), make_tyvars arity)
                                 | _ => 
                                     Datatypes.FUNTYPE(Types.int_type,
                                                   Types.apply (Datatypes.TYFUN (ty, arity), 
                                                                make_tyvars arity)))
                               else
                               Types.apply (Datatypes.TYFUN (ty, arity), make_tyvars arity), 
                               Incremental.debug_info context)
                          | Datatypes.UNBOUND_SCHEME (ty,_) =>
                              ValuePrinter.stringify_value false
                              (print_options, value, ty,
                               Incremental.debug_info context)
                          | Datatypes.OVERLOADED_SCHEME _ =>
                              "<strange overloaded value>"
                      in
                        print (out, string)
                      end
                    val out = print (out, "\n")
                  in
                    out
                  end
            end
        |   print_value (out, indent, valid as Ident.EXCON _, typescheme, _) =
          let
            val out = print_indent (out, indent)
            val out = print (out, "exception ")
            val out = print (out, IdentPrint.printValId print_options valid)
            val out =
              case typescheme of
                Datatypes.UNBOUND_SCHEME (ty as Datatypes.FUNTYPE (arg, exn),_) =>
                  if Types.type_eq (exn, Types.exn_type, true, true) then
                    print (print (out, " of "),
			   Types.print_type print_options arg)
                  else
                    print (print (out, " <strange function type> "),
			   Types.print_type print_options ty)
              | Datatypes.UNBOUND_SCHEME (ty,_) =>
                  if Types.type_eq (ty, Types.exn_type, true, true) then
                    out
                  else
                    print (print (out, " <strange type> "),
			   Types.print_type print_options ty)
              | scheme => 
                  print_typescheme_closed
		    (print (out, " <strange scheme> "), scheme)
            val out = print (out, "\n")
          in
            out
          end
        |   print_value {1=out, ...} = out

        fun print_type (out, indent, tycon,
			Datatypes.TYSTR(tyfun, value_env as
						 Datatypes.VE (_, values))) =

	  case tyfun of

	    Datatypes.NULL_TYFUN _ =>
	      let
		val out = print_indent (out, indent)
		val out = print (out, "<strange null tyfun> ")
		val out = print (out, IdentPrint.printTyCon tycon)
		val out = print (out, "\n")
	      in
		out
	      end

	  | Datatypes.ETA_TYFUN tyname =>
	      (case tyname of
		 Datatypes.METATYNAME{1=ref tyfun', ...} =>
		   print_type(out, indent, tycon,
			      Datatypes.TYSTR(tyfun', value_env))
	       | _ =>
		   if Valenv.empty_valenvp value_env then
		     let
		       val tyvars = make_tyvars (Types.tyname_arity tyname)
		       val out = print_indent (out, indent)
		       val out = print (out,
					if Types.eq_attrib tyname then
					  "eqtype "
					else
					  "type ")
		       val out = print (out, Types.print_tyvars tyvars)
		       val out = case tyvars of [] => out | _ => print (out," ")
		       val out = print (out, IdentPrint.printTyCon tycon)
		       val out = print (out, " = ")
		       val out = print (out, Types.print_type print_options (Types.apply (tyfun, tyvars)))
		       val out = print (out, "\n")
		     in
		       out
		     end
		   else
		     let
		       val tyvars = make_tyvars (Types.tyname_arity tyname)

		       val out = print_indent (out, indent)
		       val out = print (out, "datatype ")
		       val out = print (out, Types.print_tyvars tyvars)
		       val out = case tyvars of [] => out | _ => print (out," ")
		       val out = print (out, IdentPrint.printTyCon tycon)

		       val (out, _) =
			 Datatypes.NewMap.fold_in_order
			 (fn ((out, first), valid, typescheme) =>
			  let
			    val out = print (out, if first then " =\n" else " |\n")
			    val out = print_indent (out, indent+2)
			    val out = print (out, IdentPrint.printValId print_options valid)
			  in
			    (case typescheme of
			       Datatypes.UNBOUND_SCHEME (Datatypes.FUNTYPE (arg, _),_) =>
				 print (print (out, " of "), Types.print_type print_options arg)
			     | Datatypes.UNBOUND_SCHEME _ => out
			     | Datatypes.SCHEME (arity, (ty,_)) =>
				 (case Types.apply (Datatypes.TYFUN (ty, arity), tyvars) of
				    Datatypes.FUNTYPE (arg, _) =>
				      print (print (out, " of "), Types.print_type print_options arg)
				  | _ => out)
			     | Datatypes.OVERLOADED_SCHEME _ =>
				 print (out, " <strange overloaded scheme>"),
				 false)
			  end)
			 ((out, true), values)

		       val out = print (out, "\n")
		     in
		       out
		     end)

	  | tyfun as Datatypes.TYFUN (ty, arity) =>
	      let
		val tyvars = make_tyvars arity
		val out = print_indent (out, indent)
		val out = print (out, if Types.equalityp tyfun then "eqtype " else "type ")
		val out = print (out, Types.print_tyvars tyvars)
		val out = if arity = 0 then out else print (out," ")
		val out = print (out, IdentPrint.printTyCon tycon)
		val out = print (out, " = ")
		val out = print (out, Types.print_type print_options (Types.apply (tyfun, tyvars)))
		val out = print (out, "\n")
	      in
		out
	      end

        fun print_structure (out, indent, depth, strid,
                             str as Datatypes.STR
			       (_,_,Datatypes.ENV
				      (Datatypes.SE structures,
                                       Datatypes.TE types,
                                       Datatypes.VE (_, values))),
                             value_opt) =
          let
            val out = print_indent (out, indent)
            val out = print (out, "structure ")
            val out = print (out, IdentPrint.printStrId strid)

            val lambda_env = Environ.make_str_env (str,generate_moduler)

            fun sub_structure (value, index) =
              let
                val primary = MLWorks.Internal.Value.primary value
              in
                if primary = Tags.PAIRPTR then
                  Option.PRESENT (MLWorks.Internal.Value.sub (value, index))
                else if primary = Tags.POINTER then
                  Option.PRESENT (MLWorks.Internal.Value.sub (value, index+1))
                else
                  Option.ABSENT
              end
          in
            if depth = 0 
              then print (out, " = struct ... end\n")
            else
              let
                val out = print (out, " =\n")
                val out = print_indent (out, indent+2)
                val out = print (out, "struct\n")

                val out =
                  Datatypes.NewMap.fold_in_order
                  (fn (out, strid, str) => 
                   let
                     val substructure =
                       case value_opt of
                         Option.ABSENT => Option.ABSENT
                       | Option.PRESENT value =>
                           (case Environ.lookup_strid (strid, lambda_env) of
                              (_, Environ.EnvironTypes.FIELD {index, ...}, _) =>
                                sub_structure (value, index)
                            | _ => Option.ABSENT)
                   in
                     print_structure (out, indent+4, depth-1, strid, str, substructure)
                   end)
                  (out, structures)
                  
                val out =
                  Datatypes.NewMap.fold_in_order
                  (fn (out, tycon, tystr) => print_type (out, indent+4, tycon, tystr))
                  (out, types)
                  
                val out =
                  Datatypes.NewMap.fold_in_order
                  (fn (out, valid, typescheme) => 
                   let
                     val subvalue =
                       case value_opt of
                         Option.ABSENT => Option.ABSENT
                       | Option.PRESENT value =>
                           (case Environ.lookup_valid
				   (valid, lambda_env) of
                              Environ.EnvironTypes.FIELD {index, ...} =>
                                sub_structure (value, index)
                            | _ => Option.ABSENT)
                   in
                     print_value (out, indent+4, valid, typescheme, subvalue)
                   end)
                  (out,values)

                val out = print_indent (out, indent+2)
                val out = print (out, "end\n")
              in
                out
              end
          end
          | print_structure (out,indent,depth,strid,str as Datatypes.COPYSTR _,value_opt) =
            print_structure (out,indent,depth,strid,Env.expand_str str,value_opt)

        fun print_functor (out, indent, funid) =
          let
            val out = print_indent (out, indent)
            val out = print (out, "functor ")
            val out = print (out, IdentPrint.printFunId funid)
            val out = print (out, "\n")
          in
            out
          end

        fun print_identifier (out, ident as Compiler.SIGNATURE sigid) =
            (print_signature (out, indent, sigid, Map.apply' (signatures, sigid))
               handle Map.Undefined => print (out,"signature " ^ IdentPrint.printSigId sigid ^ "\n"))
          | print_identifier (out, ident as Compiler.VALUE valid) =
	    (print_value
	       (out, indent, valid, Valenv.lookup (valid, value_env),
	        Option.PRESENT (Inter_EnvTypes.lookup_val (valid, inter_env)))
             handle Valenv.Lookup_in_VE => raise Undefined ident)
          | print_identifier (out, ident as Compiler.TYPE tycon) =
            (print_type (out, indent, tycon, Tyenv.lookup (type_env, tycon))
               handle Tyenv.Lookup_in_TE => raise Undefined ident)
          | print_identifier (out, ident as Compiler.STRUCTURE strid) =
            let
              val Options.PRINTOPTIONS{maximum_str_depth,...} = print_options
            in
              (print_structure (out, indent, maximum_str_depth, strid, 
                                Strenv.lookup (strid, structure_env),
                                Option.PRESENT(Inter_EnvTypes.lookup_str (strid, inter_env)))
              handle Strenv.Lookup_in_SE => raise Undefined ident)
            end
          | print_identifier (out, ident as Compiler.FUNCTOR funid) =
            print_functor(out, indent, funid)
      in
        diagnostic_fn
        (1,
	 fn (_, stream) =>
           Lists.iterate
           (fn Compiler.SIGNATURE sigid =>
	       output(stream,
		      implode ["signature ", IdentPrint.printSigId sigid, "\n"]
	             )
             | Compiler.STRUCTURE strid =>
	       output(stream,
		      implode ["structure ", IdentPrint.printStrId strid, "\n"]
		     )
             | Compiler.VALUE (valid as Ident.EXCON _) =>
	       output(stream,
		      implode ["exception ", IdentPrint.printValId print_options valid, "\n"]
		     )
             | Compiler.VALUE valid =>
	       output(stream,
		      implode ["value ",     IdentPrint.printValId print_options valid, "\n"]
		     )
             | Compiler.TYPE      tycon =>
	       output(stream,
		      implode ["type ",      IdentPrint.printTyCon tycon, "\n"]
		     )
             | Compiler.FUNCTOR   funid =>
	       output(stream,
		      implode ["functor ",   IdentPrint.printFunId funid, "\n"]
		     )
	   )
           identifiers
	);
	ParserEnv.Map.iterate print_fixity fixity;
	Lists.reducel print_identifier (out, identifiers);
        ()
      end
@


1.42
log
@Added strings function, for tools that want to use the result strings.
@
text
@d8 3
d180 1
a180 1
  sharing Types.Datatypes.Ident = IdentPrint.Ident
d674 2
a675 2
	(*
	(* Should get the parser basis from the context. *)
d677 3
a679 2
	  ParserEnv.B(_, _, ParserEnv.E(ParserEnv.FE fixity_map, _, _)) => fixity_map
	*)
d694 1
a694 1
	fun print_fixity fix =
d1063 5
a1067 4
	(*
	ParserEnv.Map.iterate print_fixity fixity;
	*)
	map (fn id => (id, print_identifier (out, id))) identifiers
@


1.41
log
@New runtime directory structure.
@
text
@d8 3
a238 1
        val type_basis = Incremental.type_basis context
d241 5
a245 4
        val BasisTypes.BASIS (_,_, functor_env, _, environment as
                              Datatypes.ENV (structure_env,
                                             type_env,
                                             value_env)) = type_basis
d268 4
a271 1
              print (out,Completion.print_type(print_options,environment,ty))
d273 4
a276 1
              print (out,Completion.print_type(print_options,environment,ty))
d280 1
d293 414
d1059 1
d1061 2
a1062 2
	Lists.reducel print_identifier (out, identifiers);
        ()
@


1.40
log
@Add printing of fixity directives
@
text
@d8 3
d152 1
a152 1
require "../rts/tags";
@


1.39
log
@Fix printing of types in general to get the arity information right
and to give the full information
@
text
@d8 4
d145 1
d165 1
d190 1
d227 2
a228 1
           identifiers) =
d234 2
d242 17
d632 2
a633 1
        Lists.reducel print_identifier (out, identifiers);
@


1.38
log
@Boolean indicators for Modules Debugger and Monomorphic debugger decapsulation.
@
text
@d8 3
d283 3
d367 1
a367 65
            case tyfun of

              Datatypes.NULL_TYFUN _ =>
                let
                  val out = print_indent (out, indent)
                  val out = print (out, "<strange null tyfun> ")
                  val out = print (out, IdentPrint.printTyCon tycon)
                  val out = print (out, "\n")
                in
                  out
                end

            | Datatypes.ETA_TYFUN tyname =>
                if Valenv.empty_valenvp value_env then
                  let
                    val out = print_indent (out, indent)
                    val out = print (out, if Types.eq_attrib tyname then
					    "eqtype "
					  else
					    "type ")
                    val out = print (out, IdentPrint.printTyCon tycon)
                    val out = print (out, "\n")
                  in
                    out
                  end
                else
                  let
                    val tyvars =
                      make_tyvars (case tyname of
                                     Datatypes.TYNAME (_, _, n, _, _,_,_,_) => n
                                   | Datatypes.METATYNAME (_, _, n, _, _,_) => n)

                    val out = print_indent (out, indent)
                    val out = print (out, "datatype ")
                    val out = print (out, Types.print_tyvars tyvars)
                    val out = case tyvars of [] => out | _ => print (out," ")
                    val out = print (out, IdentPrint.printTyCon tycon)

                    val (out, _) =
                      Datatypes.NewMap.fold_in_order
                      (fn ((out, first), valid, typescheme) =>
                       let
                         val out = print (out, if first then " =\n" else " |\n")
                         val out = print_indent (out, indent+2)
                         val out = print (out, IdentPrint.printValId print_options valid)
                       in
                         (case typescheme of
                            Datatypes.UNBOUND_SCHEME (Datatypes.FUNTYPE (arg, _),_) =>
                              print (print (out, " of "), Types.print_type print_options arg)
                          | Datatypes.UNBOUND_SCHEME _ => out
                          | Datatypes.SCHEME (arity, (ty,_)) =>
                              (case Types.apply (Datatypes.TYFUN (ty, arity), tyvars) of
                                 Datatypes.FUNTYPE (arg, _) =>
                                   print (print (out, " of "), Types.print_type print_options arg)
                               | _ => out)
                          | Datatypes.OVERLOADED_SCHEME _ =>
                              print (out, " <strange overloaded scheme>"),
                          false)
                       end)
                      ((out, true), values)

                    val out = print (out, "\n")
                  in
                    out
                  end
d369 86
a454 14
            | tyfun as Datatypes.TYFUN (ty, arity) =>
                let
                  val tyvars = make_tyvars arity
                  val out = print_indent (out, indent)
                  val out = print (out, if Types.equalityp tyfun then "eqtype " else "type ")
                  val out = print (out, Types.print_tyvars tyvars)
                  val out = if arity = 0 then out else print (out," ")
                  val out = print (out, IdentPrint.printTyCon tycon)
                  val out = print (out, " = ")
                  val out = print (out, Types.print_type print_options (Types.apply (tyfun, tyvars)))
                  val out = print (out, "\n")
                in
                  out
                end
@


1.37
log
@Better locations in error messages
@
text
@d8 3
d214 2
a215 1
                           Options.COMPILEROPTIONS{debug_polyvariables,...}, ...},
d301 1
a301 1
                              ValuePrinter.stringify_value
d315 1
a315 1
                              ValuePrinter.stringify_value
d390 1
a390 1
                                     Datatypes.TYNAME (_, _, n, _, _,_,_) => n
d454 1
a454 1
            val lambda_env = Environ.make_str_env str
d485 1
a485 1
                              (_, Environ.EnvironTypes.FIELD {index, ...}) =>
d514 1
a514 1
                  (out, values)
@


1.36
log
@Print signature name when signature absyn is unknown.
@
text
@d8 3
d540 1
a540 11
             handle Valenv.Lookup_in_VE => raise Undefined ident
               (* This is treated as a crash *)
                  | Datatypes.NewMap.Undefined => 
		    ( Info.error'
                        (Info.make_default_options ())
			( Info.FATAL,		(* ??? *)
			  Info.Location.UNKNOWN,
                          implode ["value ",
				   IdentPrint.printValId print_options valid,
				   " not in inter_env\n"]);
                      raise Undefined ident))
@


1.35
log
@Added option for depth of structure printing
@
text
@d8 3
d530 1
a530 1
               handle Map.Undefined => raise Undefined ident)
@


1.34
log
@Added level field to Basis.
@
text
@d8 3
d184 1
a184 1

d203 1
a203 1
           ValuePrinter.Options.OPTIONS{print_options,
d205 1
a205 1
                           ValuePrinter.Options.COMPILEROPTIONS{debug_polyvariables,...}, ...},
d458 3
a460 1
            if depth > 0 then
a510 2
            else
              print (out, " = struct ... end\n")
d549 8
a556 4
            (print_structure (out, indent, 2, strid, 
                              Strenv.lookup (strid, structure_env),
                              Option.PRESENT(Inter_EnvTypes.lookup_str (strid, inter_env)))
               handle Strenv.Lookup_in_SE => raise Undefined ident)
@


1.33
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d8 3
d210 1
a210 1
        val BasisTypes.BASIS (_, functor_env, _, environment as
@


1.32
log
@Print overloaded polymorphic values as functions for polymorphic debugger.
@
text
@d8 3
d374 2
a375 2
                                     Datatypes.TYNAME (_, _, n, _, _,_) => n
                                   | Datatypes.METATYNAME (_, _, n, _, _) => n)
@


1.31
log
@Removed error_info parameter from definitions
@
text
@d8 3
d194 3
a196 1
           print_options,
d212 1
a212 1
            Datatypes.SCHEME (arity, ty) =>
d214 1
a214 1
          | Datatypes.UNBOUND_SCHEME ty =>
d221 1
a221 1
            Datatypes.SCHEME (arity, ty) =>
d227 1
a227 1
          | Datatypes.UNBOUND_SCHEME ty =>
d281 1
a281 1
                            Datatypes.SCHEME (arity, ty) =>
d284 9
d295 1
a295 1
                          | Datatypes.UNBOUND_SCHEME ty =>
d316 1
a316 1
                Datatypes.UNBOUND_SCHEME (ty as Datatypes.FUNTYPE (arg, exn)) =>
d323 1
a323 1
              | Datatypes.UNBOUND_SCHEME ty =>
d389 1
a389 1
                            Datatypes.UNBOUND_SCHEME (Datatypes.FUNTYPE (arg, _)) =>
d392 1
a392 1
                          | Datatypes.SCHEME (arity, ty) =>
@


1.31.1.1
log
@Fork for bug fixing
@
text
@a7 3
 *  Revision 1.31  1993/07/29  11:18:11  matthew
 *  Removed error_info parameter from definitions
 *
@


1.30
log
@Removed exception environments.
@
text
@d8 3
a189 1
          error_info
d512 1
d515 1
a515 1
			error_info
@


1.29
log
@Added space after tyvars in datatype printing
@
text
@d8 3
d200 1
a200 2
                                             value_env,
                                             excon_env)) = type_basis
d293 1
a293 3
          | print_value {1=out, ...} = out

        fun print_exception (out, indent, valid, typescheme) =
d302 2
a303 1
                    print (print (out, " of "), Types.print_type print_options arg)
d305 2
a306 1
                    print (print (out, " <strange function type> "), Types.print_type print_options ty)
d311 2
a312 1
                    print (print (out, " <strange type> "), Types.print_type print_options ty)
d314 2
a315 1
                  print_typescheme_closed (print (out, " <strange scheme> "), scheme)
d320 1
d322 3
a324 1
        fun print_type (out, indent, tycon, Datatypes.TYSTR(tyfun, value_env as Datatypes.VE (_, values))) =
d342 4
a345 1
                    val out = print (out, if Types.eq_attrib tyname then "eqtype " else "type ")
d408 5
a412 4
                             str as Datatypes.STR (_,_,Datatypes.ENV (Datatypes.SE structures,
                                                                     Datatypes.TE types,
                                                                     Datatypes.VE (_, values),
                                                                     Datatypes.VE (_, excons))),
a462 5
                  (fn (out, valid, typescheme) => print_exception (out, indent+4, valid, typescheme))
                  (out, excons)

                val out =
                  Datatypes.NewMap.fold_in_order
d469 2
a470 1
                           (case Environ.lookup_valid (valid, lambda_env) of
d503 1
a503 1
        |   print_identifier (out, ident as Compiler.VALUE valid) =
d506 3
a508 4
                          Option.PRESENT (Inter_EnvTypes.lookup_val (valid,
								     inter_env)
					 )
			 )
a518 3
          | print_identifier (out, ident as Compiler.EXCEPTION valid) =
            (print_exception (out, indent, valid, Valenv.lookup (valid, excon_env))
               handle Valenv.Lookup_in_VE => raise Undefined ident)
d542 1
a542 1
             | Compiler.VALUE     valid =>
d544 1
a544 1
		      implode ["value ",     IdentPrint.printValId print_options valid, "\n"]
d546 1
a546 1
             | Compiler.EXCEPTION valid =>
d548 1
a548 1
		      implode ["exception ", IdentPrint.printValId print_options valid, "\n"]
@


1.28
log
@Added space before list of tyvars in type printing
@
text
@d8 3
d351 1
@


1.27
log
@Use ordered fold for printing datatypes etc.
@
text
@d8 3
d384 1
@


1.26
log
@Removed printer descriptors.
@
text
@d8 3
d348 1
a348 1
                      Datatypes.NewMap.fold
d421 1
a421 1
                  Datatypes.NewMap.fold
d438 1
a438 1
                  Datatypes.NewMap.fold
d443 1
a443 1
                  Datatypes.NewMap.fold
d448 1
a448 1
                  Datatypes.NewMap.fold
@


1.25
log
@Moved print_tyvars and make_tyvars to _types.
@
text
@d8 3
d177 1
a177 1
           printer_desc as ValuePrinter.PRINTER_DESCRIPTOR{print_options,...},
d265 1
a265 1
                              (printer_desc, value,
d270 1
a270 1
                              (printer_desc, value, ty,
@


1.24
log
@Signature changes
@
text
@d8 3
d168 1
a168 21
    fun make_tyvars n =
      let
        fun name n =
          if n < 26 then
            chr (ord "a" + n)
          else
            chr (ord "a" + (n mod 26)) ^ name (n div 26)

        fun make_tyvar n =
          Datatypes.TYVAR (ref 0, Ident.TYVAR (
				    Ident.Symbol.find_symbol ("'" ^ name n),
                                    true,
				    true))

        fun make_tyvars' (list, 0) = list
          | make_tyvars' (list, n) =
            make_tyvars' (make_tyvar (n-1) :: list, n-1)
      in
        make_tyvars' ([], n)
      end

a305 17
          let
            fun print_tyvars (out, []) = out
              | print_tyvars (out, [tyvar]) = print (print (out, Types.print_type print_options tyvar), " ")
              | print_tyvars (out, tyvar::tyvars) =
                let
                  val out = print (out, "(")
                  val out = print (out, Types.print_type print_options tyvar)
                  val out =
                    Lists.reducel
                    (fn (out, tyvar) =>
                     print (print (out, ", "), Types.print_type print_options tyvar))
                    (out, tyvars)
                  val out = print (out, ") ")
                in
                  out
                end
          in
d338 1
a338 1
                    val out = print_tyvars (out, tyvars)
d374 1
a374 1
                  val out = print_tyvars (out, tyvars)
a381 1
          end
@


1.23
log
@Changed definitions to take an output function rather than a stream
@
text
@d8 3
a123 2
  sharing Incremental.InterMake.Compiler.Debugger_Types =
    ValuePrinter.Debugger_Types
d125 2
a126 1
    Incremental.InterMake.Inter_EnvTypes.Options = Completion.Options
d128 1
a128 1
  sharing Incremental.InterMake.Compiler.Debugger_Types.NewMap =
d133 2
d137 1
a137 1
    ValuePrinter.Debugger_Types.Type = Environ.EnvironTypes.LambdaTypes.Type
@


1.22
log
@Options & Info changes
Removed InterMake from signature
@
text
@d8 4
d119 3
a121 4
  sharing BasisTypes.Datatypes = ValuePrinter.Debugger_Types.Datatypes = 
    Types.Datatypes = Valenv.Datatypes = Tyenv.Datatypes = Strenv.Datatypes = Env.Datatypes =
    Environ.EnvironTypes.LambdaTypes.Datatypes = Completion.Datatypes
  sharing Incremental.InterMake.Compiler.MirTypes.Debugger_Types =
d125 9
a133 4

  sharing TopdecPrint.Absyn.Ident = BasisTypes.Datatypes.Ident

  sharing type TopdecPrint.Absyn.Type = BasisTypes.Datatypes.Type
d184 1
a184 1
	  outstream
d191 2
a192 2
        fun print (stream,string) = (output(stream,string);stream)
        val out = outstream
@


1.21
log
@Changed a call to output to a call to Info.error'.
Changed references to std_out to the appropriate outstream.
@
text
@d8 4
d82 1
d101 1
d113 3
a115 4
  sharing Incremental.InterMake.Compiler.BasisTypes.Datatypes.Ident = IdentPrint.Ident
  sharing Incremental.InterMake.Compiler.Parser.Absyn = TopdecPrint.Absyn
  sharing Incremental.InterMake.Compiler.BasisTypes = ValuePrinter.BasisTypes
  sharing Incremental.InterMake.Compiler.BasisTypes.Datatypes =
d120 7
a126 2
  sharing TopdecPrint.Info = Types.Info = IdentPrint.Info =
    Incremental.InterMake.Inter_EnvTypes.Info = Completion.Info
d130 1
a130 1
    structure Datatypes = Incremental.InterMake.Compiler.Parser.Absyn.Datatypes
d135 1
a135 1
    structure BasisTypes = Compiler.BasisTypes
d138 3
d177 5
a181 2
	  info_opts
	  (context, printer_desc, indent, identifiers) =
d197 1
a197 1
              print (out,Completion.print_type(info_opts,environment,ty))
d199 1
a199 1
              print (out,Completion.print_type(info_opts,environment,ty))
d209 1
a209 1
                print (out,Completion.print_type(info_opts,environment,ty))
d212 1
a212 1
                print (out, Completion.print_type(info_opts,environment,ty))
d239 1
a239 1
            val out = TopdecPrint.print_sigexp info_opts print (out, indent+2, sigexp)
d251 1
a251 1
              val out = print (out, IdentPrint.printValId info_opts valid)
d290 1
a290 1
            val out = print (out, IdentPrint.printValId info_opts valid)
d295 1
a295 1
                    print (print (out, " of "), Types.print_type info_opts arg)
d297 1
a297 1
                    print (print (out, " <strange function type> "), Types.print_type info_opts ty)
d302 1
a302 1
                    print (print (out, " <strange type> "), Types.print_type info_opts ty)
d313 1
a313 1
              | print_tyvars (out, [tyvar]) = print (print (out, Types.print_type info_opts tyvar), " ")
d317 1
a317 1
                  val out = print (out, Types.print_type info_opts tyvar)
d321 1
a321 1
                     print (print (out, ", "), Types.print_type info_opts tyvar))
d369 1
a369 1
                         val out = print (out, IdentPrint.printValId info_opts valid)
d373 1
a373 1
                              print (print (out, " of "), Types.print_type info_opts arg)
d378 1
a378 1
                                   print (print (out, " of "), Types.print_type info_opts arg)
d399 1
a399 1
                  val out = print (out, Types.print_type info_opts (Types.apply (tyfun, tyvars)))
d514 4
a517 4
		    ( Types.Info.error'
			info_opts
			( Types.Info.FATAL,		(* ??? *)
			  Types.Info.Location.UNKNOWN,
d519 1
a519 1
				   IdentPrint.printValId info_opts valid,
d550 1
a550 1
		      implode ["value ",     IdentPrint.printValId info_opts valid, "\n"]
d554 1
a554 1
		      implode ["exception ", IdentPrint.printValId info_opts valid, "\n"]
@


1.20
log
@ Removed currying from completion interface
Reinstated printing of COPYSTR's
@
text
@d8 4
d490 1
a490 1
            ((print_value (out, indent, valid,
d498 8
a505 4
                      (output (std_out, implode ["value ",
						 IdentPrint.printValId info_opts valid,
						 " not in inter_env\n"]);
                       raise Undefined ident)))
d525 1
a525 1
	       output(std_out,
d529 1
a529 1
	       output(std_out,
d533 1
a533 1
	       output(std_out,
d537 1
a537 1
	       output(std_out,
d541 1
a541 1
	       output(std_out,
d545 1
a545 1
	       output(std_out,
@


1.19
log
@Typechecker structure changes
@
text
@d8 3
d177 1
a177 10
              let
(*
                val ty = Types.apply (Datatypes.TYFUN (ty, arity),
				      make_tyvars arity)
*)
              in
                print (out,
		       (Completion.print_type info_opts environment ty)
		       handle _ => Types.print_type info_opts ty)
              end
d179 1
a179 3
                print (out,
		       (Completion.print_type info_opts environment ty)
		       handle _ => Types.print_type info_opts ty)
d189 1
a189 3
                print (out,
		       (Completion.print_type info_opts environment ty)
		       handle _ => Types.print_type info_opts ty)
d192 1
a192 3
                print (out,
		       (Completion.print_type info_opts environment ty)
		       handle _ => Types.print_type info_opts ty)
d470 1
a470 2
            print (out, "<Ouch>\n")
(*            print_structure (out,indent,depth,strid,Env.expand_str str,value_opt) *)
@


1.18
log
@Structure changes.
@
text
@d8 3
d100 1
a100 1
  sharing Incremental.InterMake.Compiler.Parser.Absyn.Datatypes.Ident = IdentPrint.Ident
d102 4
a105 9
  sharing Incremental.InterMake.Compiler.Parser.Absyn.Datatypes =
    Types.Datatypes =
    Valenv.Datatypes =
    Tyenv.Datatypes =
    Strenv.Datatypes =
    Env.Datatypes =
    ValuePrinter.Debugger_Types.Datatypes  =
    Environ.EnvironTypes.LambdaTypes.Datatypes =
    Completion.Datatypes
a107 5
  sharing ValuePrinter.Basis = Incremental.InterMake.Compiler.Basis
(*
  sharing Incremental.InterMake.Compiler.Parser.Absyn.Datatypes.Ident 
    = Environ.EnvironTypes.LambdaTypes.Datatypes.Ident
*)
d118 1
a118 1
    structure Basis = Compiler.Basis
d164 5
a168 5
        val Basis.BASIS (_, functor_env, _, environment as
                         Datatypes.ENV (structure_env,
                                        type_env,
                                        value_env,
                                        excon_env)) = type_basis
@


1.17
log
@In print_typescheme_closed, removed the application of the type scheme which
didn't handle imperative and equality attributes properly.
@
text
@d8 4
d63 1
a63 3
require "../utils/lists";
require "../utils/option";
require "../utils/diagnostic";
d65 2
d68 1
a68 2
require "../basics/identprint";
require "../typechecker/types";
d72 1
d74 3
a76 1
require "../debugger/value_printer";
a77 2
require "incremental";
require "inter_envtypes";
d85 2
a93 1
  structure Environ     : ENVIRON
d104 1
d116 1
a116 1
    Incremental.Inter_EnvTypes.Info = Completion.Info
d123 1
a123 1
    structure Inter_EnvTypes = Incremental.Inter_EnvTypes
d406 1
a406 1
                             str as Datatypes.STR (_, Datatypes.ENV (Datatypes.SE structures,
d488 3
@


1.16
log
@Modified to produce longtycons when printing types out of structures
@
text
@d8 3
d176 1
d179 1
@


1.15
log
@Lower level changes going up
@
text
@d8 3
a58 1
require "../main/info";
d66 1
d82 1
d97 2
a98 1
    Environ.EnvironTypes.LambdaTypes.Datatypes
d102 1
d105 3
a107 1
  sharing TopdecPrint.Info = Types.Info = IdentPrint.Info = Incremental.Inter_EnvTypes.Info
d162 1
a162 1
        val Basis.BASIS (_, functor_env, _,
d169 1
a169 1
        fun print_typescheme_closed (out, scheme) =
d176 3
a178 1
                print (out, Types.print_type info_opts ty)
d181 3
a183 1
              print (out, Types.print_type info_opts ty)
d187 1
a187 1
        fun print_typescheme_open (out, tyvars, scheme) =
d193 3
a195 1
                print (out, Types.print_type info_opts ty)
d198 3
a200 1
              print (out, Types.print_type info_opts ty)
d272 1
a272 1
          | print_value (out, _, _, _, _) = out
d492 1
a492 1
            (print_value (out, indent, valid,
d503 1
a503 1
                       raise Undefined ident))
d516 1
a516 1
            print_functor (out, indent, funid)
@


1.14
log
@Modified tyenv for efficiency
@
text
@d8 3
d85 1
d87 1
a87 3
  sharing IdentPrint.Ident =
    Incremental.Datatypes.Ident
  sharing Incremental.Datatypes =
d94 1
a94 1
  sharing Incremental.InterMake.Compiler.Debugger_Types =
d97 2
a98 1
  sharing Incremental.Datatypes.Ident = Environ.EnvironTypes.LambdaTypes.Datatypes.Ident
d103 1
a103 1
    structure Datatypes = Incremental.Datatypes
@


1.13
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d8 3
d489 1
a489 1
            (print_type (out, indent, tycon, Tyenv.lookup (tycon, type_env))
@


1.12
log
@Used pervasive streams
@
text
@d8 3
a137 4
    datatype options = 
      OPTIONS of
        ValuePrinter.printer_descriptor *
	Types.Info.options
d141 2
a142 1
	  (context, OPTIONS (printer_desc, info_opts), indent, identifiers) =
@


1.11
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d8 4
a101 1
    structure Stream = Compiler.Parser.Lexer.Info.Stream
d144 1
a144 1
        fun print (stream,string) = (Stream.output(stream,string);stream)
@


1.10
log
@Changed to use Stream structure
@
text
@d8 3
d43 1
d54 1
d86 1
d134 2
a135 1
        ValuePrinter.printer_descriptor
d137 3
a139 1
    fun definitions outstream (context, options, indent, identifiers) =
d159 1
a159 1
                print (out, Types.print_type ty)
d162 1
a162 1
              print (out, Types.print_type ty)
d172 1
a172 1
                print (out, Types.print_type ty)
d175 1
a175 1
              print (out, Types.print_type ty)
d202 1
a202 1
            val out = TopdecPrint.print_sigexp print (out, indent+2, sigexp)
d208 1
a208 1
        fun print_value (out, OPTIONS printer_desc, indent,
d214 1
a214 1
              val out = print (out, IdentPrint.printValId valid)
d247 1
a247 1
          | print_value (out, _, _, _, _, _) = out
d253 1
a253 1
            val out = print (out, IdentPrint.printValId valid)
d258 1
a258 1
                    print (print (out, " of "), Types.print_type arg)
d260 1
a260 1
                    print (print (out, " <strange function type> "), Types.print_type ty)
d265 1
a265 1
                    print (print (out, " <strange type> "), Types.print_type ty)
d276 1
a276 1
              | print_tyvars (out, [tyvar]) = print (print (out, Types.print_type tyvar), " ")
d280 1
a280 1
                  val out = print (out, Types.print_type tyvar)
d284 1
a284 1
                     print (print (out, ", "), Types.print_type tyvar))
d332 1
a332 1
                         val out = print (out, IdentPrint.printValId valid)
d336 1
a336 1
                              print (print (out, " of "), Types.print_type arg)
d341 1
a341 1
                                   print (print (out, " of "), Types.print_type arg)
d362 1
a362 1
                  val out = print (out, Types.print_type (Types.apply (tyfun, tyvars)))
d440 1
a440 1
                     print_value (out, options, indent+4, valid, typescheme, subvalue)
d467 1
a467 1
            (print_value (out, options, indent, valid,
d476 1
a476 1
						 IdentPrint.printValId valid,
d507 1
a507 1
		      implode ["value ",     IdentPrint.printValId valid, "\n"]
d511 1
a511 1
		      implode ["exception ", IdentPrint.printValId valid, "\n"]
@


1.9
log
@Modified sharing constraints to remove superfluous structures
@
text
@d8 3
d92 1
d130 1
a130 1
    fun definitions print (out, context, options, indent, identifiers) =
d132 2
d515 2
a516 1
        Lists.reducel print_identifier (out, identifiers)
@


1.8
log
@Added option type to control printing.
@
text
@d8 3
d64 1
a64 1
  sharing Incremental.Absyn = TopdecPrint.Absyn
a65 1
    Incremental.Ident =
d74 1
a74 1
  sharing Incremental.Compiler.Debugger_Types =
d76 2
a77 2
  sharing ValuePrinter.Basis = Incremental.Compiler.Basis
  sharing Incremental.Ident = Environ.EnvironTypes.LambdaTypes.Datatypes.Ident
a80 2
    structure Map = Incremental.Map
    structure Ident = Incremental.Ident
d82 2
d85 1
a85 1
    structure Compiler = Incremental.Compiler
d459 1
a459 1
                  | Inter_EnvTypes.NewMap.Undefined => 
@


1.7
log
@Time is now represented by a pervasive structure.
@
text
@d8 3
d46 31
a76 29
functor InterPrint (structure Incremental	: INCREMENTAL
                    structure TopdecPrint	: TOPDECPRINT
                    structure IdentPrint	: IDENTPRINT
                    structure ValuePrinter	: VALUE_PRINTER
                    structure Valenv		: VALENV
                    structure Strenv		: STRENV 
                    structure Tyenv		: TYENV
                    structure Types		: TYPES
                    structure Tags		: TAGS
                    structure Lists		: LISTS
                    structure Option		: OPTION
                    structure Environ            : ENVIRON
                    structure Diagnostic	: DIAGNOSTIC

                    sharing Incremental.Absyn = TopdecPrint.Absyn
                    sharing IdentPrint.Ident =
                      Incremental.Ident =
                      Incremental.Datatypes.Ident
                    sharing Incremental.Datatypes =
                      Types.Datatypes =
                      Valenv.Datatypes =
                      Tyenv.Datatypes =
                      Strenv.Datatypes =
                      ValuePrinter.Debugger_Types.Datatypes  =
                      Environ.EnvironTypes.LambdaTypes.Datatypes
                    sharing Incremental.Compiler.Debugger_Types = ValuePrinter.Debugger_Types
                    sharing ValuePrinter.Basis = Incremental.Compiler.Basis
                    sharing Incremental.Ident = Environ.EnvironTypes.LambdaTypes.Datatypes.Ident
                    ) : INTERPRINT =
d86 1
d94 2
a95 1
      (fn (verbosity, stream) => (output (stream, "Incremental: "); output_function (verbosity, stream)))
d108 4
a111 2
          Datatypes.TYVAR (ref 0, Ident.TYVAR (Ident.Symbol.find_symbol ("'" ^ name n),
                                               true, true))
d120 5
a124 1
    fun definitions print (out, context, indent, identifiers) =
d139 2
a140 1
                val ty = Types.apply (Datatypes.TYFUN (ty, arity), make_tyvars arity)
d191 3
a193 1
        fun print_value (out, indent, valid as Ident.VAR _, typescheme, value_opt) =
d213 1
a213 1
                              (ValuePrinter.toplevel_default_print_descriptor, value,
d218 1
a218 1
                              (ValuePrinter.toplevel_default_print_descriptor, value, ty,
d230 1
a230 1
          | print_value (out, _, _, _, _) = out
d423 1
a423 1
                     print_value (out, indent+4, valid, typescheme, subvalue)
d449 13
a461 7
          | print_identifier (out, ident as Compiler.VALUE valid) =
            (print_value (out, indent, valid, Valenv.lookup (valid, value_env),
                          Option.PRESENT (Inter_EnvTypes.lookup_val (valid, inter_env)))
               handle Valenv.Lookup_in_VE => raise Undefined ident
                    | Inter_EnvTypes.NewMap.Undefined => 
                        (output (std_out, implode ["value ", IdentPrint.printValId valid, " not in inter_env\n"]);
                         raise Undefined ident))
d477 30
a506 10
        (1, fn (_, stream) =>
         Lists.iterate
         (fn Compiler.SIGNATURE sigid => output (std_out, implode ["signature ", IdentPrint.printSigId sigid, "\n"])
           | Compiler.STRUCTURE strid => output (std_out, implode ["structure ", IdentPrint.printStrId strid, "\n"])
           | Compiler.VALUE     valid => output (std_out, implode ["value ",     IdentPrint.printValId valid, "\n"])
           | Compiler.EXCEPTION valid => output (std_out, implode ["exception ", IdentPrint.printValId valid, "\n"])
           | Compiler.TYPE      tycon => output (std_out, implode ["type ",      IdentPrint.printTyCon tycon, "\n"])
           | Compiler.FUNCTOR   funid => output (std_out, implode ["functor ",   IdentPrint.printFunId funid, "\n"]))
         identifiers);

@


1.6
log
@Added diagnostics.
@
text
@d8 3
d39 1
d51 1
d341 1
a341 1
                             structure_address_option) =
d346 14
a359 1
            val structure_as_lambda_env = Environ.make_str_env str
d371 8
a378 5
                     val structure_address =
                       case (structure_address_option,Environ.lookup_strid(strid,structure_as_lambda_env)) of
                         (Option.PRESENT structure_address,(_,Environ.EnvironTypes.FIELD {index,...})) => 
                           Option.PRESENT(MLWorks.Internal.Debugger.get_object_at_address(structure_address,index*4-1))
                       | _ => Option.ABSENT
d380 1
a380 1
                     print_structure (out, indent+4, depth-1, strid, str,structure_address)
d383 1
a383 1

d388 1
a388 1

d398 8
a405 5
                     val value_address =
                       case (structure_address_option,Environ.lookup_valid(valid,structure_as_lambda_env)) of
                         (Option.PRESENT structure_address,Environ.EnvironTypes.FIELD {index,...}) => 
                           Option.PRESENT(MLWorks.Internal.Debugger.get_object_at_address(structure_address,index*4-1))
                       | _ => Option.ABSENT
d407 1
a407 1
                     print_value (out, indent+4, valid, typescheme, value_address)
@


1.5
log
@Tynames now have a slot recording their definition point
@
text
@d8 3
d27 1
d50 1
d75 1
d77 8
d413 3
a415 1
                    | Inter_EnvTypes.NewMap.Undefined => raise Undefined ident)
d430 11
@


1.4
log
@Added printing of the values contained in structures
@
text
@d8 3
d266 1
a266 1
                                     Datatypes.TYNAME (_, _, n, _, _) => n
@


1.3
log
@Modified to use new value_printer
@
text
@d8 3
d22 1
d42 1
d53 2
a54 1
                      ValuePrinter.Debugger_Types.Datatypes 
d57 1
d315 5
a319 4
                             Datatypes.STR (_, Datatypes.ENV (Datatypes.SE structures,
                                                              Datatypes.TE types,
                                                              Datatypes.VE (_, values),
                                                              Datatypes.VE (_, excons)))) =
d324 1
d334 10
a343 1
                  (fn (out, strid, str) => print_structure (out, indent+4, depth-1, strid, str))
d358 10
a367 1
                  (fn (out, valid, typescheme) => print_value (out, indent+4, valid, typescheme, Option.ABSENT))
d404 3
a406 1
            (print_structure (out, indent, 2, strid, Strenv.lookup (strid, structure_env))
@


1.2
log
@Changes related to restructuring of Incremental.
@
text
@d8 3
d47 3
a49 1
                      Strenv.Datatypes
d51 1
a51 1
                    sharing ValuePrinter.Datatypes = Incremental.Datatypes) : INTERPRINT =
d169 2
a170 2
                               Types.apply (Datatypes.TYFUN (ty, arity), make_tyvars arity), type_env,
                               (fn s => (s, Datatypes.NULLTYPE, Tyenv.empty_tyenv, false)), false)
d173 2
a174 2
                              (ValuePrinter.toplevel_default_print_descriptor, value, ty, type_env,
                               (fn s => (s, Datatypes.NULLTYPE, Tyenv.empty_tyenv, false)), false)
@


1.1
log
@Initial revision
@
text
@d7 4
a10 1
 *  $Log$
d45 1
a45 1
                    sharing ValuePrinter.Basis = Incremental.Basis
d53 2
a54 1
    structure Basis = Incremental.Basis
d56 1
a56 1
    exception Undefined of Incremental.identifier
d150 1
a150 1
                handle Valenv.Lookup_in_VE => raise Undefined (Incremental.VALUE valid)
d357 1
a357 1
        fun print_identifier (out, ident as Incremental.SIGNATURE sigid) =
d360 1
a360 1
          | print_identifier (out, ident as Incremental.VALUE valid) =
d365 1
a365 1
          | print_identifier (out, ident as Incremental.EXCEPTION valid) =
d368 1
a368 1
          | print_identifier (out, ident as Incremental.TYPE tycon) =
d371 1
a371 1
          | print_identifier (out, ident as Incremental.STRUCTURE strid) =
d374 1
a374 1
          | print_identifier (out, ident as Incremental.FUNCTOR funid) =
@
