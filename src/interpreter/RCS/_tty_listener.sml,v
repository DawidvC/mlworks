head	1.63;
access;
symbols
	MLW_daveb_inline_1_4_99:1.63.1
	MLWorks_21c0_1999_03_25:1.63
	MLWorks_20c1_1998_08_20:1.63
	MLWorks_20c0_1998_08_04:1.63
	MLWorks_20b2c2_1998_06_19:1.63
	MLWorks_20b2_Windows_1998_06_12:1.63
	MLWorks_20b1c1_1998_05_07:1.63
	MLWorks_20b0_1998_04_07:1.63
	MLWorks_20b0_1998_03_20:1.63
	MLWorks_20m2_1998_02_16:1.62
	MLWorks_20m1_1997_10_23:1.61
	MLWorks_11r1:1.59.1.1.1.1.1
	MLWorks_workspace_97:1.61.2
	MLWorks_dt_wizard:1.61.1
	MLWorks_11c0_1997_09_09:1.59.1.1.1.1
	MLWorks_10r3:1.59.1.1.3
	MLWorks_10r2_551:1.59.1.1.2
	MLWorks_11:1.59.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.59.1.1
	MLWorks_20m0_1997_06_20:1.61
	MLWorks_1_0_r2c2_1997_06_14:1.59.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.59.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.59.1
	MLWorks_BugFix_1997_04_24:1.59
	MLWorks_1_0_r2_Win32_1997_04_11:1.59
	MLWorks_1_0_r2_Unix_1997_04_04:1.59
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.57.6.1.1
	MLWorks_gui_1996_12_18:1.57.7
	MLWorks_1_0_Win32_1996_12_17:1.57.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.57.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.57.4.1
	MLWorks_1_0_Irix_1996_11_28:1.57.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.57.5
	MLWorks_1_0_Unix_1996_11_14:1.57.4
	MLWorks_Open_Beta2_1996_10_11:1.57.3
	MLWorks_License_dev:1.57.2
	MLWorks_1_open_beta_1996_09_13:1.57.1
	MLWorks_Open_Beta_1996_08_22:1.57
	MLWorks_Beta_1996_07_02:1.57
	MLWorks_Beta_1996_06_07:1.57
	MLWorks_Beta_1996_06_06:1.57
	MLWorks_Beta_1996_06_05:1.57
	MLWorks_Beta_1996_06_03:1.57
	MLWorks_Beta_1996_05_31:1.57
	MLWorks_Beta_1996_05_30:1.56
	ML_beta_release_12/08/94:1.37
	ML_beta_release_03/08/94:1.36
	ML_revised_beta_release_25/05/94:1.34
	ML_final_beta_release_02/03/94:1.31
	mlworks-28-01-1994:1.28
	Release:1.24
	mlworks-beta-01-09-1993:1.24;
locks; strict;
comment	@ * @;


1.63
date	98.02.18.17.03.57;	author jont;	state Exp;
branches
	1.63.1.1;
next	1.62;

1.62
date	98.01.26.18.52.18;	author johnh;	state Exp;
branches;
next	1.61;

1.61
date	97.06.17.14.37.32;	author daveb;	state Exp;
branches
	1.61.1.1
	1.61.2.1;
next	1.60;

1.60
date	97.06.13.09.10.21;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	97.03.25.11.56.05;	author andreww;	state Exp;
branches
	1.59.1.1;
next	1.58;

1.58
date	97.03.17.14.31.04;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	96.05.30.13.19.00;	author daveb;	state Exp;
branches
	1.57.1.1
	1.57.2.1
	1.57.3.1
	1.57.4.1
	1.57.5.1
	1.57.6.1
	1.57.7.1;
next	1.56;

1.56
date	96.05.24.12.45.59;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	96.05.16.13.07.37;	author stephenb;	state Exp;
branches;
next	1.54;

1.54
date	96.05.01.10.30.27;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	96.03.15.12.39.09;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	96.01.22.14.04.04;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	96.01.18.11.24.45;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	96.01.16.11.24.40;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	95.10.18.13.54.37;	author nickb;	state Exp;
branches;
next	1.48;

1.48
date	95.09.08.15.15.57;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	95.07.12.14.24.02;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	95.06.15.13.08.20;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	95.06.14.13.01.39;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	95.05.29.16.40.58;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	95.05.02.15.17.10;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	95.04.28.12.18.21;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	95.03.15.15.37.45;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.02.23.17.22.42;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	95.01.13.15.04.35;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	94.12.08.17.29.48;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	94.08.10.14.45.18;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	94.08.01.09.36.50;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	94.06.21.15.06.56;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	94.04.07.12.15.38;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	94.03.21.17.14.55;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	94.03.11.17.04.51;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	94.02.24.01.19.11;	author nosa;	state Exp;
branches;
next	1.30;

1.30
date	94.02.02.10.54.03;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	94.01.28.16.27.01;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.12.22.10.52.02;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	93.11.25.14.21.02;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.11.22.17.49.23;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	93.10.08.16.21.47;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.08.10.12.21.29;	author matthew;	state Exp;
branches
	1.24.1.1;
next	1.23;

1.23
date	93.05.26.12.54.53;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.05.20.09.32.16;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.05.12.15.45.15;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.05.11.13.48.26;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.05.10.15.57.35;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	93.05.10.14.02.20;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.05.10.09.37.06;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.05.06.17.43.15;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.05.06.15.27.24;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.05.04.15.20.23;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.04.30.10.30.17;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.04.26.12.10.44;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.04.20.15.55.03;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	93.04.06.16.09.28;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	93.04.02.14.59.18;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.04.01.12.44.18;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	93.03.30.12.24.22;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.03.26.14.04.37;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.03.18.18.09.57;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.03.15.16.44.22;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.03.12.14.24.59;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.09.15.29.45;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.02.18.59.33;	author daveb;	state Exp;
branches;
next	;

1.24.1.1
date	93.08.10.12.21.29;	author jont;	state Exp;
branches;
next	1.24.1.2;

1.24.1.2
date	93.10.08.14.53.05;	author matthew;	state Exp;
branches;
next	;

1.57.1.1
date	96.09.13.11.16.28;	author hope;	state Exp;
branches;
next	;

1.57.2.1
date	96.10.07.16.06.24;	author hope;	state Exp;
branches;
next	;

1.57.3.1
date	96.10.17.11.24.39;	author hope;	state Exp;
branches;
next	;

1.57.4.1
date	96.11.14.12.49.28;	author hope;	state Exp;
branches
	1.57.4.1.1.1;
next	;

1.57.4.1.1.1
date	96.11.28.15.00.43;	author hope;	state Exp;
branches;
next	;

1.57.5.1
date	96.11.22.18.09.05;	author hope;	state Exp;
branches;
next	;

1.57.6.1
date	96.12.17.17.47.44;	author hope;	state Exp;
branches
	1.57.6.1.1.1;
next	;

1.57.6.1.1.1
date	97.02.24.11.37.30;	author hope;	state Exp;
branches;
next	;

1.57.7.1
date	96.12.18.09.41.45;	author hope;	state Exp;
branches;
next	;

1.59.1.1
date	97.05.12.10.34.12;	author hope;	state Exp;
branches
	1.59.1.1.1.1
	1.59.1.1.2.1
	1.59.1.1.3.1;
next	;

1.59.1.1.1.1
date	97.07.28.18.19.13;	author daveb;	state Exp;
branches
	1.59.1.1.1.1.1.1;
next	;

1.59.1.1.1.1.1.1
date	97.10.07.11.44.21;	author jkbrook;	state Exp;
branches;
next	;

1.59.1.1.2.1
date	97.09.08.17.12.49;	author daveb;	state Exp;
branches;
next	;

1.59.1.1.3.1
date	97.09.09.14.08.28;	author daveb;	state Exp;
branches;
next	;

1.61.1.1
date	97.09.10.19.23.39;	author brucem;	state Exp;
branches;
next	;

1.61.2.1
date	97.09.11.20.54.37;	author daveb;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	97.11.26.13.13.39;	author daveb;	state Exp;
branches;
next	;

1.63.1.1
date	99.04.01.17.56.43;	author daveb;	state Exp;
branches;
next	;


desc
@A TTY-based listener.  Runs on top of a shell.
@


1.63
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@(*  TTY Listener.
 *
 *  Copyright (C) 1992, 1993 Harlequin Ltd
 *
 *  $Log: _tty_listener.sml,v $
 * Revision 1.62  1998/01/26  18:52:18  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.61.2.2  1997/11/26  13:13:39  daveb
 * [Bug #30071]
 *
 * Revision 1.61.2.1  1997/09/11  20:54:37  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.61  1997/06/17  14:37:32  daveb
 * [Bug #30090]
 * Added handler for IO.Io around TextIO.inputLine, so that the gui.img
 * builds correctly on Windows.
 *
 * Revision 1.60  1997/06/13  09:10:21  matthew
 * Removing uses of MLWorks.IO
 *
 * Revision 1.59  1997/03/25  11:56:05  andreww
 * [Bug #1989]
 * removing Internal.Value.exn_name_string.
 *
 * Revision 1.58  1997/03/17  14:31:04  matthew
 * Remove ShellData from ActionQueue
 *
 * Revision 1.57  1996/05/30  13:19:00  daveb
 * The Interrupt exception is no longer at top level.
 *
 * Revision 1.56  1996/05/24  12:45:59  matthew
 * Improving SYSTEM ERROR behaviour
 *
 * Revision 1.55  1996/05/16  13:07:37  stephenb
 * Update wrt MLWorks.Debugger -> MLWorks.Internal.Debugger change.
 *
 * Revision 1.54  1996/05/01  10:30:27  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.53  1996/03/15  12:39:09  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.52  1996/01/22  14:04:04  daveb
 * Minor change to catch extra cases of Shell.Result datatype.
 *
 *  Revision 1.51  1996/01/18  11:24:45  daveb
 *  Changed Shell interface.
 *
 *  Revision 1.50  1996/01/16  11:24:40  daveb
 *  The Shell structure now uses a ShellState type.
 *
 *  Revision 1.49  1995/10/18  13:54:37  nickb
 *  Add dummy profiler entry to the shell_data created here.
 *
 *  Revision 1.48  1995/09/08  15:15:57  matthew
 *  Adding flush_stream function to Shell.shell
 *
 *  Revision 1.47  1995/07/12  14:24:02  matthew
 *  Removed Incremental from Ml_Debugger
 *
 *  Revision 1.46  1995/06/15  13:08:20  daveb
 *  Type of Ml_Debugger.ml_debugger has changed.
 *
 *  Revision 1.45  1995/06/14  13:01:39  daveb
 *  Type of Ml_Debugger.ml_debugger has changed.
 *
 *  Revision 1.44  1995/05/29  16:40:58  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *  Moved user_preferences into Preferences.
 *
 *  Revision 1.43  1995/05/02  15:17:10  matthew
 *  Remove script argument to ml_debugger
 *  Change use of cast (again)
 *
 *  Revision 1.42  1995/04/28  12:18:21  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.41  1995/03/15  15:37:45  daveb
 *  Type of shell_date has changed.  Prompt function now takes the
 *  context name as a string, so in the TTY listener I just use "MLWorks".
 *
 *  Revision 1.40  1995/02/23  17:22:42  matthew
 *  Adding break on SYSTEM ERROR.  This is mainly for debugging purposes.
 *
 *  Revision 1.39  1995/01/13  15:04:35  daveb
 *  Removed obsolete sharing condition.
 *
 *  Revision 1.38  1994/12/08  17:29:48  jont
 *  Move OS specific stuff into a system link directory
 *
 *  Revision 1.37  1994/08/10  14:45:18  daveb
 *  Moved read_dot_mlworks to _actionqueue.
 *
 *  Revision 1.36  1994/08/01  09:36:50  daveb
 *  Separated preferences from options.
 *
 *  Revision 1.35  1994/06/21  15:06:56  daveb
 *  Replaced context_ref with user_contexts.
 *  The ActionQueue.Error exception no longer includes a context.
 *
 *  Revision 1.34  1994/04/07  12:15:38  daveb
 *  Added case for DebuggerTrapped.
 *
 *  Revision 1.33  1994/03/21  17:14:55  matthew
 *  Added catchall handler around interpreter loop
 *
 *  Revision 1.32  1994/03/11  17:04:51  matthew
 *  Replace Exit by Shell.Exit
 *
 *  Revision 1.31  1994/02/24  01:19:11  nosa
 *  Debugger scripts for tracing tool using debugger.
 *
 *  Revision 1.30  1994/02/02  10:54:03  daveb
 *  Minor changes to sharing constraints.
 *
 *  Revision 1.29  1994/01/28  16:27:01  matthew
 *  Improvements to error locations
 *
 *  Revision 1.28  1993/12/22  10:52:02  daveb
 *  Changed quit message for debugger, since it no longer raises Interrupt.
 *
 *  Revision 1.27  1993/11/25  14:21:02  matthew
 *  Moved exception DebuggerTrapped from Shell to ShellTypes
 *
 *  Revision 1.26  1993/11/22  17:49:23  daveb
 *  Ml_Debugger.with_start_frame no longer needs a frame argument, removing
 *  the need for the call to MLWorks.Internal.Value.frame_call.
 *
 *  Revision 1.25  1993/10/08  16:21:47  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.24.1.2  1993/10/08  14:53:05  matthew
 *  Use with_base_frame in debugger function
 *  Stream name now "<TTY listener>"
 *
 *  Revision 1.24.1.1  1993/08/10  12:21:29  jont
 *  Fork for bug fixing
 *
 *  Revision 1.24  1993/08/10  12:21:29  matthew
 *  Added stream_name parameter to Shell.shell
 *
 *  Revision 1.23  1993/05/26  12:54:53  matthew
 *  Changes to error handling
 *
 *  Revision 1.22  1993/05/20  09:32:16  matthew
 *  Pass over non-existent .mlworks in silence.
 *
 *  Revision 1.21  1993/05/12  15:45:15  matthew
 *  Changes to ActionQueue
 *
 *  Revision 1.20  1993/05/11  13:48:26  matthew
 *  Changes to use
 *
 *  Revision 1.19  1993/05/10  15:57:35  daveb
 *  Changed type of ml_debugger.
 *
 *  Revision 1.18  1993/05/10  14:02:20  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *
 *  Revision 1.17  1993/05/10  09:37:06  matthew
 *  Removed interrupt handler
 *
 *  Revision 1.16  1993/05/06  17:43:15  matthew
 *  Wrap reading .mlworks with a with_shell_data
 *
 *  Revision 1.15  1993/05/06  15:27:24  matthew
 *  Changed interface to ActionQueue.do_actions
 *  ShellTypes simplification
 *
 *  Revision 1.14  1993/05/04  15:20:23  matthew
 *  Changed context ref handling
 *
 *  Revision 1.13  1993/04/30  10:30:17  matthew
 *  Added Interrupt handler around loop
 *
 *  Revision 1.12  1993/04/26  12:10:44  matthew
 *  Removed ML_Debugger.BASE_FRAME
 *
 *  Revision 1.11  1993/04/20  15:55:03  richard
 *  Commented out old tracing code.
 *
 *  Revision 1.10  1993/04/06  16:09:28  jont
 *  Moved user_options and version from interpreter to main
 *
 *  Revision 1.9  1993/04/02  14:59:18  matthew
 *  Signature changes
 *
 *  Revision 1.8  1993/04/01  12:44:18  daveb
 *  Passes empty lines to shell, which handles end of file appropriately.
 *  Added call to clear_eof after printing a prompt, so that user input
 *  terinated by an EOF doesn't affect compiler input.
 *
 *  Revision 1.7  1993/03/30  12:24:22  matthew
 *  Added read_dot_mlworks function
 *  Added initial_listener function that reads .mlworks file
 *
 *  Revision 1.6  1993/03/26  14:04:37  matthew
 *  Moved break function in from _shell_structure
 *
 *  Revision 1.5  1993/03/18  18:09:57  matthew
 *  Added output_fn field to shell_data
 *
 *  Revision 1.4  1993/03/15  16:44:22  matthew
 *  Simplified ShellTypes types
 *
 *  Revision 1.3  1993/03/12  14:24:59  matthew
 *  Removed prompt stuff, use prompt function from shell
 *  Simpilified debugger interface
 *  Signature revisions
 *
 *  Revision 1.2  1993/03/09  15:29:45  matthew
 *  Options & Info changes
 *  Changes for ShellData type
 *  
 *  Revision 1.1  1993/03/02  18:59:33  daveb
 *  Initial revision
 *
 *)

require "../debugger/ml_debugger";
require "shell_types";
require "user_context";
require "../main/user_options";
require "../main/preferences";
require "shell";
require "tty_listener";

require "../basis/__text_io";
require "../basis/__io";

functor TTYListener (
  structure Ml_Debugger : ML_DEBUGGER
  structure ShellTypes: SHELL_TYPES
  structure UserContext: USER_CONTEXT
  structure UserOptions: USER_OPTIONS
  structure Preferences: PREFERENCES
  structure Shell: SHELL

  sharing UserOptions.Options = Ml_Debugger.ValuePrinter.Options =
	  ShellTypes.Options

  sharing type ShellTypes.user_options =
	       UserOptions.user_tool_options

  sharing type Shell.ShellData = ShellTypes.ShellData
  sharing type Shell.Context = ShellTypes.Context = UserContext.Context
  sharing type ShellTypes.user_context = UserContext.user_context
  sharing type UserContext.user_context_options =
	       UserOptions.user_context_options
  sharing type Ml_Debugger.preferences = Preferences.preferences = ShellTypes.preferences
  sharing type ShellTypes.user_preferences = Preferences.user_preferences
): TTY_LISTENER =
struct
  structure Info = Shell.Info

  type ListenerArgs = ShellTypes.ListenerArgs

  fun listener_aux (ShellTypes.LISTENER_ARGS
                    {user_context,
                     prompter,
                     user_options,
                     user_preferences,
                     mk_xinterface_fn},
                    initial_shell_p) = 
    let
      fun output_fn s = TextIO.print s
        
      val exit_fn : int -> unit = (fn n => raise Shell.Exit n)
        
      fun debugger_function f x =
        let
          val call_debugger =
            Ml_Debugger.ml_debugger 
              (Ml_Debugger.TERMINAL,
               ShellTypes.new_options (user_options, user_context),
               Preferences.new_preferences user_preferences)
        in
	    Ml_Debugger.with_start_frame
             (fn base_frame =>
	      ((f x)
	       handle
		 exn as ShellTypes.DebuggerTrapped => raise exn
	       | exn as Shell.Exit _ => raise exn
	       | exn as MLWorks.Interrupt => raise exn
	       | exn as Info.Stop _ => raise exn
	       | exn => 
		   (call_debugger 
		      (base_frame,
		       Ml_Debugger.EXCEPTION exn,
		       Ml_Debugger.POSSIBLE
			 ("quit (return to listener)",
                          Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
		       Ml_Debugger.NOT_POSSIBLE);
		    raise ShellTypes.DebuggerTrapped)))
        end

      fun profiler p = 
        TextIO.output (TextIO.stdErr, "Graphical profiler not available in TTY Listener\n")

      val shell_data = 
        ShellTypes.SHELL_DATA
         {get_user_context = fn () => user_context,
          user_options = user_options,
          user_preferences = user_preferences,
          debugger = debugger_function,
	  profiler = profiler,
          prompter = prompter,
          exit_fn = exit_fn,
          x_running = false,		(* X isn't running yet. *)
          mk_xinterface_fn = mk_xinterface_fn,
          mk_tty_listener = initial_listener}

      val title = "<TTY listener>"

      (* This should discard unprocessed input on std_in *)
      fun flush_stream () = ()

      val (handler, do_prompt) = Shell.shell (shell_data,title,flush_stream)

      fun debugger_function exn = 
        let
          val shell_data as ShellTypes.SHELL_DATA{prompter,
                                                  mk_xinterface_fn,
                                                  ...} = !ShellTypes.shell_data_ref
          val context = ShellTypes.get_current_context shell_data
        in
          Ml_Debugger.ml_debugger 
          (Ml_Debugger.get_debugger_type (),
           ShellTypes.get_current_options shell_data,
           ShellTypes.get_current_preferences shell_data)
          (Ml_Debugger.get_start_frame(),
           Ml_Debugger.EXCEPTION exn,
           Ml_Debugger.POSSIBLE ("Return to top level",
                                 Ml_Debugger.NORMAL_RETURN),
           Ml_Debugger.NOT_POSSIBLE)
        end
  
      fun loop state =
        let
	  val _ = output_fn(do_prompt ("MLWorks", state))
	  (* val _ = MLWorks.IO.clear_eof MLWorks.IO.std_in *)
          val line = TextIO.inputLine TextIO.stdIn
		     handle IO.Io _ => ""
          val new_state =
	    (case #3 (ShellTypes.with_toplevel_name title
	    	       (fn () =>
			  handler
			    (Info.make_default_options ())
			    (line, state)))
	     of Shell.OK s => s
	     |  _ => Shell.initial_state)
            handle 
              MLWorks.Interrupt => Shell.initial_state
            | ShellTypes.DebuggerTrapped => Shell.initial_state
            | exn as Shell.Exit _ => raise exn
            | exn => (debugger_function exn;
                      Shell.initial_state)
	in
          loop new_state
        end
    in
      loop Shell.initial_state
      handle Shell.Exit n => n
    end (* of listener_aux *)

  and listener args = listener_aux (args,false)
  and initial_listener args = listener_aux (args,true)

end
@


1.63.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.63  1998/02/18  17:03:57  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
@


1.62
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d6 4
a363 8
(*
                (MLWorks.IO.output(MLWorks.IO.terminal_out,
                        "SYSTEM ERROR: Unexpected exception " ^ 
		          (MLWorks.Internal.Value.exn_name exn) ^
                        "\nreached top level -- restarting tty loop\n");
                 MLWorks.Internal.Debugger.break "SYSTEM ERROR";
		 Shell.initial_state)
*)
@


1.61
log
@[Bug #30090]
Added handler for IO.Io around TextIO.inputLine, so that the gui.img
builds correctly on Windows.
@
text
@d6 11
a285 1
	       | exn as Shell.Error _ => raise exn
@


1.61.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 5
 * Revision 1.61  1997/06/17  14:37:32  daveb
 * [Bug #30090]
 * Added handler for IO.Io around TextIO.inputLine, so that the gui.img
 * builds correctly on Windows.
 *
@


1.61.2.2
log
@[Bug #30071]
@
text
@a5 3
 * Revision 1.61.2.1  1997/09/11  20:54:37  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d280 1
@


1.61.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 5
 * Revision 1.61  1997/06/17  14:37:32  daveb
 * [Bug #30090]
 * Added handler for IO.Io around TextIO.inputLine, so that the gui.img
 * builds correctly on Windows.
 *
@


1.60
log
@Removing uses of MLWorks.IO
@
text
@d6 3
d220 1
d335 1
@


1.59
log
@[Bug #1989]
removing Internal.Value.exn_name_string.
@
text
@d6 4
d216 2
d253 1
a253 1
      fun output_fn s = MLWorks.IO.output(MLWorks.IO.std_out,s)
d286 1
a286 2
	MLWorks.IO.output(MLWorks.IO.messages,
	       "Graphical profiler not available in TTY Listener\n")
d329 2
a330 2
	  val _ = MLWorks.IO.clear_eof MLWorks.IO.std_in
          val line = MLWorks.IO.input_line MLWorks.IO.std_in
@


1.59.1.1
log
@branched from 1.59
@
text
@a5 4
 * Revision 1.59  1997/03/25  11:56:05  andreww
 * [Bug #1989]
 * removing Internal.Value.exn_name_string.
 *
@


1.59.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.59.1.1  1997/05/12  10:34:12  hope
 * branched from 1.59
 *
@


1.59.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.59.1.1  1997/05/12  10:34:12  hope
 * branched from 1.59
 *
@


1.59.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.59.1.1  1997/05/12  10:34:12  hope
 * branched from 1.59
 *
@


1.59.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.59.1.1.1.1  1997/07/28  18:19:13  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.58
log
@Remove ShellData from ActionQueue
@
text
@d6 3
a342 1
                        MLWorks.Internal.Value.exn_name_string
@


1.57
log
@The Interrupt exception is no longer at top level.
@
text
@d6 3
a201 1
require "action_queue";
a214 1
  structure ActionQueue : ACTION_QUEUE
a218 1
  sharing Shell.Info = ActionQueue.Info
d221 1
a221 1
	       UserOptions.user_tool_options = ActionQueue.UserOptions
d225 1
a225 2
  sharing type ActionQueue.user_context = ShellTypes.user_context =
	       UserContext.user_context
a229 1
  sharing type ActionQueue.ShellData = Shell.ShellData
d232 1
a232 1
  structure Info = ActionQueue.Info
d262 1
@


1.57.7.1
log
@branched from 1.57
@
text
@a5 3
 * Revision 1.57  1996/05/30  13:19:00  daveb
 * The Interrupt exception is no longer at top level.
 *
@


1.57.6.1
log
@branched from 1.57
@
text
@a5 3
 * Revision 1.57  1996/05/30  13:19:00  daveb
 * The Interrupt exception is no longer at top level.
 *
@


1.57.6.1.1.1
log
@branched from 1.57.6.1
@
text
@a5 3
 * Revision 1.57.6.1  1996/12/17  17:47:44  hope
 * branched from 1.57
 *
@


1.57.5.1
log
@branched from 1.57
@
text
@a5 3
 * Revision 1.57  1996/05/30  13:19:00  daveb
 * The Interrupt exception is no longer at top level.
 *
@


1.57.4.1
log
@branched from 1.57
@
text
@a5 3
 * Revision 1.57  1996/05/30  13:19:00  daveb
 * The Interrupt exception is no longer at top level.
 *
@


1.57.4.1.1.1
log
@branched from 1.57.4.1
@
text
@a5 3
 * Revision 1.57.4.1  1996/11/14  12:49:28  hope
 * branched from 1.57
 *
@


1.57.3.1
log
@branched from 1.57
@
text
@a5 3
 * Revision 1.57  1996/05/30  13:19:00  daveb
 * The Interrupt exception is no longer at top level.
 *
@


1.57.2.1
log
@branched from 1.57
@
text
@a5 3
 * Revision 1.57  1996/05/30  13:19:00  daveb
 * The Interrupt exception is no longer at top level.
 *
@


1.57.1.1
log
@branched from 1.57
@
text
@a5 3
 * Revision 1.57  1996/05/30  13:19:00  daveb
 * The Interrupt exception is no longer at top level.
 *
@


1.56
log
@Improving SYSTEM ERROR behaviour
@
text
@d6 3
d264 1
a264 1
	       | exn as Interrupt => raise exn
d333 1
a333 1
              Interrupt => Shell.initial_state
@


1.55
log
@Update wrt MLWorks.Debugger -> MLWorks.Internal.Debugger change.
@
text
@d6 3
d226 1
a226 1
  sharing type Ml_Debugger.preferences = Preferences.preferences
d298 18
d333 3
a335 1
            | exn => 
d343 1
@


1.54
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d6 6
d318 1
a318 1
                 MLWorks.Debugger.break "SYSTEM ERROR";
@


1.53
log
@Fixed use of Info.default_options.
@
text
@d6 3
d234 1
a234 1
      fun output_fn s = output(std_out,s)
d266 1
a266 1
	output(MLWorks.IO.messages,
d292 2
a293 2
	  val _ = MLWorks.IO.clear_eof std_in
          val line = MLWorks.IO.input_line std_in
d307 1
a307 1
                (output(MLWorks.IO.terminal_out,
@


1.52
log
@Minor change to catch extra cases of Shell.Result datatype.
@
text
@d6 3
d293 4
a296 1
	    	       (fn () => handler Info.default_options (line, state)))
@


1.51
log
@Changed Shell interface.
@
text
@d6 3
d292 1
a292 1
	     |  Shell.ERROR _ => Shell.initial_state)
@


1.50
log
@The Shell structure now uses a ShellState type.
@
text
@d6 3
d197 1
d286 4
a289 2
	    #4 (ShellTypes.with_toplevel_name title
	          (fn _ => handler (line, state)))
d292 1
a293 1
            | ShellTypes.DebuggerTrapped => Shell.initial_state
@


1.49
log
@Add dummy profiler entry to the shell_data created here.
@
text
@d6 3
d276 23
a298 20
      fun loop () =
        (let val _ = output_fn(do_prompt("MLWorks"))
	     val _ = MLWorks.IO.clear_eof std_in
             val line = MLWorks.IO.input_line std_in
         in
           ShellTypes.with_toplevel_name title
	   (fn _ => handler line)
         end
         handle 
         Interrupt => ([],false)
       | exn as Shell.Exit _ => raise exn
       | ShellTypes.DebuggerTrapped => ([],false)
       | exn => 
           (output(MLWorks.IO.terminal_out,
                   "SYSTEM ERROR: Unexpected exception " ^ 
                   MLWorks.Internal.Value.exn_name_string (MLWorks.Internal.Value.exn_name exn) ^
                   "\nreached top level -- restarting tty loop\n");
           MLWorks.Debugger.break "SYSTEM ERROR";
           ([],false));
         loop())
d300 1
a300 1
      loop ()
@


1.48
log
@Adding flush_stream function to Shell.shell
@
text
@d6 3
d249 4
d259 1
@


1.47
log
@Removed Incremental from Ml_Debugger
@
text
@d6 3
d260 4
a263 1
      val (handler, do_prompt) = Shell.shell (shell_data,title)
@


1.46
log
@Type of Ml_Debugger.ml_debugger has changed.
@
text
@d6 3
a182 1
  sharing Ml_Debugger.Incremental.InterMake.Compiler.Info = ActionQueue.Info
d190 1
a190 2
  sharing type Shell.Context = ShellTypes.Context = UserContext.Context =
	       Ml_Debugger.Incremental.Context
d200 1
a200 1
  structure Info = Ml_Debugger.Incremental.InterMake.Compiler.Info
@


1.45
log
@Type of Ml_Debugger.ml_debugger has changed.
@
text
@d6 3
d219 3
a221 4
            (Ml_Debugger.TERMINAL,
             ShellTypes.new_options (user_options, user_context),
             Preferences.new_preferences user_preferences,
	     fn s => output (std_out, s))
@


1.44
log
@Separated user_options into tool-specific and context-specific parts.
Moved user_preferences into Preferences.
@
text
@d6 4
d216 2
a217 2
            Ml_Debugger.TERMINAL
            (ShellTypes.new_options (user_options, user_context),
d219 1
a219 12
             UserContext.get_context user_context)
            (fn context' =>
             (* note that the user options are copied *)
               (listener
		  (ShellTypes.LISTENER_ARGS
                     {user_context = user_context,
                      user_preferences = user_preferences,
                      prompter = prompter,
                      user_options =
			UserOptions.copy_user_tool_options user_options,
                      mk_xinterface_fn = mk_xinterface_fn});
                ()))
d224 14
a237 12
	       handle exn as ShellTypes.DebuggerTrapped => raise exn
		    | exn as Shell.Exit _ => raise exn
		    | exn as Interrupt => raise exn
		    | exn as Info.Stop _ => raise exn
		    | exn => 
			(call_debugger 
			 base_frame
			 (Ml_Debugger.EXCEPTION exn,
			  Ml_Debugger.POSSIBLE ("quit (return to listener)",
                                                Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
			  Ml_Debugger.NOT_POSSIBLE);
			 raise ShellTypes.DebuggerTrapped)))
@


1.43
log
@Remove script argument to ml_debugger
Change use of cast (again)
@
text
@d6 4
d160 1
d169 1
d178 1
a178 1
	       UserOptions.user_options = ActionQueue.UserOptions
d185 4
a188 1
  sharing type Ml_Debugger.preferences = UserOptions.preferences
d200 1
d213 3
a215 3
            (UserOptions.new_options(user_options),
             UserOptions.new_preferences(user_options),
             UserContext.get_context (user_context))
d218 9
a226 6
             (listener (ShellTypes.LISTENER_ARGS
                        {user_context = user_context,
                         prompter = prompter,
                         user_options = UserOptions.copy user_options,
                         mk_xinterface_fn = mk_xinterface_fn});
             ()))
d247 1
a247 1
         {user_context = ref user_context,
d249 1
@


1.42
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d6 3
d226 3
a228 6
			  Ml_Debugger.POSSIBLE 
			  ("quit (return to listener)",
			   Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped
			   ),
			  Ml_Debugger.NOT_POSSIBLE
			  ) [];
@


1.41
log
@Type of shell_date has changed.  Prompt function now takes the
context name as a string, so in the TTY listener I just use "MLWorks".
@
text
@d6 4
d139 6
a144 7
Revision 1.2  1993/03/09  15:29:45  matthew
Options & Info changes
Changes for ShellData type

Revision 1.1  1993/03/02  18:59:33  daveb
Initial revision

d151 1
d159 1
d164 1
a164 2
  sharing Ml_Debugger.Incremental.InterMake.Compiler.Info = ShellTypes.Info =
	  ActionQueue.Info
a167 2
  sharing type Ml_Debugger.Incremental.options = ShellTypes.IncrementalOptions

d171 2
a172 4
  sharing type Shell.ShellData =
	       ShellTypes.ShellData
  sharing type Shell.Context =
               ShellTypes.Context =
d174 2
a175 1
  sharing type ActionQueue.user_context = ShellTypes.user_context
d202 1
a202 1
             ShellTypes.get_context (user_context))
@


1.40
log
@Adding break on SYSTEM ERROR.  This is mainly for debugging purposes.
@
text
@d6 3
a144 1
require "../utils/lists";
a146 1
require "shell_structure";
a152 1
  structure Lists : LISTS
d179 1
a179 4
  structure Incremental = Ml_Debugger.Incremental
  structure Compiler = Incremental.InterMake.Compiler

  structure Info = Compiler.Info
a193 9
      val context_stack = ref [user_context]

      exception BadContextStack

      fun get_current_user_context () =
        case !context_stack of
          (c::_) => c
        | _ => raise BadContextStack

d201 1
a201 1
             ShellTypes.get_context (get_current_user_context ()))
d203 1
a203 1
             (* note that the ref slots are copied *)
d205 1
a205 1
                        {user_context = ShellTypes.copyUserContext (get_current_user_context()), (* HACK *)
d233 1
a233 1
         {context_stack = context_stack,
d247 1
a247 1
        (let val _ = output_fn(do_prompt())
@


1.39
log
@Removed obsolete sharing condition.
@
text
@d6 3
d275 2
a276 1
              ([],false));
@


1.38
log
@Move OS specific stuff into a system link directory
@
text
@d6 3
a157 1
  sharing Ml_Debugger.Incremental.InterMake.Option = ShellTypes.Option
@


1.37
log
@Moved read_dot_mlworks to _actionqueue.
@
text
@d6 3
a136 1
require "../make/unix";
a146 1
  structure Unix : UNIX
@


1.36
log
@Separated preferences from options.
@
text
@d6 3
d170 1
a270 48


      (* It would be nicer if this didn't have to use the action queue *)
      fun read_dot_mlworks shell_data =
        let
          exception NoHome
          val ShellTypes.SHELL_DATA{debugger,...} = shell_data
          fun do_use filename =
            (ActionQueue.add_use filename;
             ActionQueue.do_actions(ShellTypes.get_user_context shell_data,
                                    ShellTypes.get_user_options shell_data,
                                    debugger,
                                    fn s => output_fn ("Reading .mlworks: " ^ s))
             handle ActionQueue.Error (s,_,_) =>
               output_fn (s ^ "\n")
               | ActionQueue.Handled => ())


          fun get_shell_variable (varname) =
            let
              val testsize = (size varname) + 1
              val teststring = varname ^ "="
              fun find_var [] = raise NoHome
                | find_var (binding :: l) =
                  if (size binding >= testsize
                      andalso
                      (String.substring (binding,0,testsize) = teststring))
                    then
                      String.substring (binding,testsize,(size binding) - testsize)
                  else
                    find_var l
            in
              find_var (MLWorks.OS.Unix.environment ())
            end
          val pathname = get_shell_variable "HOME" ^ "/.mlworks"
        in
          case Unix.mtime pathname of
             Unix.NOT_EXIST => ()
           | Unix.EXISTS _ =>
               (ShellTypes.with_shell_data
               shell_data
               (fn () => 
                 do_use (pathname,
                         Info.default_options)
                         handle NoHome => (output_fn "No HOME variable set\n")
                              | Io _ => (output_fn "No .mlworks found\n")
                              | exn => (output_fn "Error occured using MLWorks")))
        end
a271 3
      if initial_shell_p
        then read_dot_mlworks (shell_data)
      else ();
@


1.35
log
@Replaced context_ref with user_contexts.
The ActionQueue.Error exception no longer includes a context.
@
text
@d6 4
d166 1
d202 1
d209 1
a209 2
                         user_options =
                         UserOptions.make_user_options (UserOptions.new_options (user_options)),
@


1.34
log
@Added case for DebuggerTrapped.
@
text
@d6 3
d160 3
a162 4
	       Ml_Debugger.Incremental.Context =
               ActionQueue.Context

          ): TTY_LISTENER =
d172 1
a172 1
                    {context_ref,
d182 1
a182 1
      val context_stack = ref [context_ref]
d186 1
a186 1
      fun get_current_context_ref () =
d197 1
a197 1
             ShellTypes.get_context_ref (get_current_context_ref ()))
d201 1
a201 1
                        {context_ref = ShellTypes.copyContextRef (get_current_context_ref()), (* HACK *)
d271 1
a271 1
             ActionQueue.do_actions(ShellTypes.get_context_ref (ShellTypes.get_shell_context_ref shell_data),
d275 1
a275 1
             handle ActionQueue.Error (s,context,error,error_list) =>
@


1.33
log
@Added catchall handler around interpreter loop
@
text
@d6 3
d252 1
@


1.32
log
@Replace Exit by Shell.Exit
@
text
@d6 3
d246 9
a254 1
         handle Interrupt => ([],false);
@


1.31
log
@Debugger scripts for tracing tool using debugger.
@
text
@d6 3
a169 2
      exception Exit of int
      
d172 1
a172 1
      val exit_fn : int -> unit = (fn n => raise Exit n)
d204 1
a204 1
		    | exn as Exit _ => raise exn
d298 1
a298 1
      handle Exit n => n
@


1.30
log
@Minor changes to sharing constraints.
@
text
@d6 3
d215 1
a215 1
			  );
@


1.29
log
@Improvements to error locations
@
text
@d6 3
d130 5
a134 4
  sharing Ml_Debugger.Incremental.InterMake.Compiler.Info = ShellTypes.Info
  sharing Ml_Debugger.Incremental.InterMake.FileName.Option = ShellTypes.Option
  sharing UserOptions.Options = Ml_Debugger.ValuePrinter.Options = ShellTypes.Options
  sharing ActionQueue.Incremental = Ml_Debugger.Incremental
@


1.28
log
@Changed quit message for debugger, since it no longer raises Interrupt.
@
text
@d6 3
d223 3
a225 1
      val (handler, do_prompt) = Shell.shell (shell_data,"<TTY listener>")
d232 2
a233 1
	   handler line
@


1.27
log
@Moved exception DebuggerTrapped from Shell to ShellTypes
@
text
@d6 3
d201 1
a201 1
			  ("Raise Interrupt",
@


1.26
log
@Ml_Debugger.with_start_frame no longer needs a frame argument, removing
the need for the call to MLWorks.Internal.Value.frame_call.
@
text
@d6 4
d189 1
a189 1
	       handle Shell.DebuggerTrapped => raise Shell.DebuggerTrapped
d199 1
a199 1
			   Ml_Debugger.DO_RAISE Shell.DebuggerTrapped
d203 1
a203 1
			 raise Shell.DebuggerTrapped)))
@


1.25
log
@Merging in bug fixes
@
text
@d6 3
d182 2
a183 5
          MLWorks.Internal.Value.frame_call
          (fn base_frame =>
	    (Ml_Debugger.with_start_frame
             base_frame
	     (fn () =>
d199 1
a199 1
			 raise Shell.DebuggerTrapped)))))
@


1.24
log
@Added stream_name parameter to Shell.shell
@
text
@d6 10
d180 20
a199 17
          (fn base_frame => 
           ((f x)
            handle Shell.DebuggerTrapped => raise Shell.DebuggerTrapped
                 | exn as Exit _ => raise exn
                 | exn as Interrupt => raise exn
                 | exn as Info.Stop _ => raise exn
                 | exn => 
                     (call_debugger 
                      base_frame
                      (Ml_Debugger.EXCEPTION exn,
                       Ml_Debugger.POSSIBLE 
                       ("Raise Interrupt",
                        Ml_Debugger.DO_RAISE Shell.DebuggerTrapped
                        ),
                       Ml_Debugger.NOT_POSSIBLE
                       );
                      raise Shell.DebuggerTrapped)))
d213 1
a213 1
      val (handler, do_prompt) = Shell.shell (shell_data,"TTY listener")
d220 1
a220 5
           MLWorks.Internal.Value.frame_call
           (fn base_frame =>
            Ml_Debugger.with_start_frame
            base_frame
            (fn () => handler line))
d240 2
a241 2
            
              
@


1.24.1.1
log
@Fork for bug fixing
@
text
@a5 3
 *  Revision 1.24  1993/08/10  12:21:29  matthew
 *  Added stream_name parameter to Shell.shell
 *
@


1.24.1.2
log
@Use with_base_frame in debugger function
Stream name now "<TTY listener>"
@
text
@a5 3
 *  Revision 1.24.1.1  1993/08/10  12:21:29  jont
 *  Fork for bug fixing
 *
d173 17
a189 20
          (fn base_frame =>
	    (Ml_Debugger.with_start_frame
             base_frame
	     (fn () =>
	      ((f x)
	       handle Shell.DebuggerTrapped => raise Shell.DebuggerTrapped
		    | exn as Exit _ => raise exn
		    | exn as Interrupt => raise exn
		    | exn as Info.Stop _ => raise exn
		    | exn => 
			(call_debugger 
			 base_frame
			 (Ml_Debugger.EXCEPTION exn,
			  Ml_Debugger.POSSIBLE 
			  ("Raise Interrupt",
			   Ml_Debugger.DO_RAISE Shell.DebuggerTrapped
			   ),
			  Ml_Debugger.NOT_POSSIBLE
			  );
			 raise Shell.DebuggerTrapped)))))
d203 1
a203 1
      val (handler, do_prompt) = Shell.shell (shell_data,"<TTY listener>")
d210 5
a214 1
	   handler line
d234 2
a235 2


@


1.23
log
@Changes to error handling
@
text
@d6 3
d200 1
a200 1
      val (handler, do_prompt) = Shell.shell shell_data
@


1.22
log
@Pass over non-existent .mlworks in silence.
@
text
@d6 3
d224 5
a228 3
                                    fn s => output_fn ("Make: compiling " ^ s))
             handle ActionQueue.Error (s,context) =>
               output_fn (s ^ "\n"))
@


1.21
log
@Changes to ActionQueue
@
text
@d6 3
d80 1
d91 1
d241 1
d243 11
a253 8
          ShellTypes.with_shell_data
          shell_data
          (fn () => 
           do_use (get_shell_variable "HOME" ^ "/.mlworks",
                   Info.default_options)
           handle NoHome => (output_fn "No HOME variable set\n")
                | Io _ => (output_fn "No .mlworks found\n")
                | exn => (output_fn "Error occured using MLWorks"))
@


1.20
log
@Changes to use
@
text
@d6 3
a104 1
  sharing type ShellTypes.ContextRef = ActionQueue.ContextRef
d107 2
a108 1
	       Ml_Debugger.Incremental.Context
d213 1
a213 1
             ActionQueue.do_actions(ShellTypes.get_shell_context_ref shell_data,
d216 4
a219 1
                                    fn s => output_fn ("Make: compiling " ^ s)))
@


1.19
log
@Changed type of ml_debugger.
@
text
@d6 3
d234 2
a235 1
           do_use (get_shell_variable "HOME" ^ "/.mlworks")
@


1.18
log
@Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d6 3
d140 1
a140 2
            (Incremental.OPTIONS{options = UserOptions.new_options(user_options),
                                 debugger = debugger_function},
@


1.17
log
@Removed interrupt handler
@
text
@d6 3
a111 1
                     error_info,
d137 1
a137 2
            (Incremental.OPTIONS{error_info = error_info,
                                 options = UserOptions.new_options(user_options),
a143 1
                         error_info = error_info,
a173 2
          output_fn = output_fn,
          error_info = error_info,
d202 1
a202 1
          val ShellTypes.SHELL_DATA{output_fn,debugger,...} = shell_data
@


1.16
log
@Wrap reading .mlworks with a with_shell_data
@
text
@d6 3
d152 1
a152 28
           (MLWorks.Internal.Runtime.Event.signal
            (2,
             fn s => (call_debugger 
                      base_frame
                      (Ml_Debugger.SIGNAL s,
                       Ml_Debugger.POSSIBLE (
                                             "Return to TopLevel by raising Interrupt",
                                             Ml_Debugger.DO_RAISE Interrupt
                                             ),
                       Ml_Debugger.POSSIBLE (
                                             "Continue interrupted code",
                                             Ml_Debugger.NORMAL_RETURN
                                             ));
                      ()
                      )
             );
(*
            (MLWorks.Internal.Tracing.with_tracing (
                                                    fn in_value => 
                                                    call_debugger 
                                                    Ml_Debugger.NO_BASE_FRAME 
                                                    (Ml_Debugger.TRACE in_value,
                                                     Ml_Debugger.NOT_POSSIBLE,
                                                     Ml_Debugger.NOT_POSSIBLE))
            f
            x)
*)
            (f x)
d190 5
a194 1
           handler line
@


1.15
log
@Changed interface to ActionQueue.do_actions
ShellTypes simplification
@
text
@d6 4
d248 7
a254 4
          do_use (get_shell_variable "HOME" ^ "/.mlworks")
          handle NoHome => (output_fn "No HOME variable set\n")
               | Io _ => (output_fn "No .mlworks found\n")
               | exn => (output_fn "Error occured using MLWorks")
@


1.14
log
@Changed context ref handling
@
text
@d6 3
d77 1
a79 1
  sharing type Ml_Debugger.ValuePrinter.print_method_table = ShellTypes.print_method_table
d82 1
a82 1
	       UserOptions.user_options
a84 1
               ActionQueue.ShellData =
d86 1
a86 1

a101 1
                     print_method_table_ref,
a102 1
                     name_monitor,
d109 14
a122 1
      val cref = ShellTypes.get_context_ref context_ref
d128 1
a128 2
            (!print_method_table_ref,
             Incremental.OPTIONS{error_info = error_info,
a129 1
                                 name_monitor = name_monitor,
d131 1
a131 1
             cref)
d135 1
a135 2
                        {context_ref = context_ref, (* HACK *)
                         print_method_table_ref = ref (!print_method_table_ref),
a136 1
                         name_monitor = name_monitor,
a188 10
      
      fun output_fn s = output(std_out,s)
        
      val exit_fn : int -> unit = (fn n => raise Exit n)
        
      val shell_state =
        ShellTypes.SHELL_STATE
        {context_ref = context_ref,
         print_method_table_ref = print_method_table_ref,
         user_options=user_options}
d192 2
a193 1
         {state_stack = ref [shell_state],
a195 1
          name_monitor = name_monitor,
d217 1
a217 1
      fun read_dot_mlworks (shell_data as ShellTypes.SHELL_DATA{output_fn,...}) =
d220 1
d223 4
a226 2
             ActionQueue.do_actions shell_data)

@


1.13
log
@Added Interrupt handler around loop
@
text
@d6 3
d109 1
d120 1
a120 1
             context_ref)
d124 1
a124 1
                        {context_ref = ref context',
@


1.12
log
@Removed ML_Debugger.BASE_FRAME
@
text
@d6 3
d209 1
a209 1
         (* handle Interrupt => () *) ;
@


1.11
log
@Commented out old tracing code.
@
text
@d6 3
d132 1
a132 1
                      (Ml_Debugger.BASE_FRAME base_frame)
d163 1
a163 1
                      (Ml_Debugger.BASE_FRAME base_frame)
@


1.10
log
@Moved user_options and version from interpreter to main
@
text
@d6 3
d142 1
d152 2
@


1.9
log
@Signature changes
@
text
@d6 3
d47 1
a47 1
require "user_options";
@


1.8
log
@Passes empty lines to shell, which handles end of file appropriately.
Added call to clear_eof after printing a prompt, so that user input
terinated by an EOF doesn't affect compiler input.
@
text
@d6 5
d56 3
a58 2
  sharing UserOptions.Options = Ml_Debugger.ValuePrinter.Debugger_Types.Options
  sharing Ml_Debugger.Incremental = ShellTypes.Incremental
d60 1
d71 2
a72 1
	       ShellTypes.Incremental.Context
d76 1
a76 1
  structure Incremental = ShellTypes.Incremental
@


1.7
log
@Added read_dot_mlworks function
Added initial_listener function that reads .mlworks file
@
text
@d6 4
d181 1
a183 1
           if line = "" (*eof*) then raise Exit 0 else ();
@


1.6
log
@Moved break function in from _shell_structure
@
text
@d6 3
d32 1
d44 1
d55 2
a56 1
  sharing type Shell.Args =
d66 1
d69 1
a69 1
  type Args = ShellTypes.ListenerArgs
d71 9
a79 9
  fun listener (ShellTypes.LISTENER_ARGS
                {options_ref,
                 context_ref,
                 print_method_table_ref,
                 error_info,
                 name_monitor,
                 prompter,
                 user_options,
                 mk_xinterface_fn}) = 
d82 1
a82 1
      fun debugger_function current_module f x =
d89 1
a89 1
                                 options = !options_ref,
d92 1
a92 2
             context_ref,
             current_module)
d96 1
a96 2
                        {options_ref = ref (!options_ref),
                         context_ref = ref context',
d101 2
a102 1
                         user_options = UserOptions.make_user_options (!options_ref),
d150 1
a150 1
      fun do_output s = output(std_out,s)
d154 5
a158 39
      val break_function =
        let
          val call_debugger =
            Ml_Debugger.ml_debugger 
            Ml_Debugger.TERMINAL
            (!print_method_table_ref,
             Incremental.OPTIONS{error_info = error_info,
                                 options = !options_ref,
                                 name_monitor = name_monitor,
                                 debugger = debugger_function},
             context_ref,
             "")
            (fn context' =>
             (listener 
              (ShellTypes.LISTENER_ARGS
               {options_ref = ref (!options_ref),
                context_ref = ref context',
                print_method_table_ref = ref (!print_method_table_ref),
                user_options = UserOptions.make_user_options (!options_ref),
                error_info = error_info,
                name_monitor = name_monitor,
                prompter = prompter,
                mk_xinterface_fn = mk_xinterface_fn});
              ()))
        in
          MLWorks.Internal.Value.frame_call
          (fn base_frame =>
           (fn s => (call_debugger 
                     (Ml_Debugger.BASE_FRAME base_frame)
                     (Ml_Debugger.BREAK s,
                      Ml_Debugger.POSSIBLE (
                                            "Return to TopLevel by raising Interrupt",
                                            Ml_Debugger.DO_RAISE Interrupt),
                      Ml_Debugger.POSSIBLE (
                                            "Continue interrupted code",
                                            Ml_Debugger.NORMAL_RETURN
                                            ));
                     ())))
        end
a159 2
      val _ = MLWorks.Internal.Tracing.break_hook := break_function

d162 2
a163 5
         {options_ref = options_ref,
          contexts = ref [context_ref],
          print_method_table_ref = print_method_table_ref,
          output_fn = do_output,
          user_options=user_options,
a165 1
          break_function = break_function,
d171 1
a171 1
          mk_tty_listener = listener}
d176 1
a176 1
        (let val _ = do_output(do_prompt())
d180 1
a180 1
           handler (do_output,line)
d182 1
a182 1
           (* handle Interrupt => () *) ;
d184 32
d217 3
d222 5
a226 1
    end (* of listener *)
@


1.5
log
@Added output_fn field to shell_data
@
text
@d6 3
d148 44
a191 3
      val (handler, do_prompt) =
        Shell.shell
        (ShellTypes.SHELL_DATA
d193 1
a193 1
          context_ref = context_ref,
d199 1
d205 3
a207 1
          mk_tty_listener = listener})
@


1.4
log
@Simplified ShellTypes types
@
text
@d6 3
d151 1
@


1.3
log
@Removed prompt stuff, use prompt function from shell
Simpilified debugger interface
Signature revisions
@
text
@d6 5
d45 1
a45 1
	       ShellTypes.ShellArgs
d59 8
a66 9
                (ShellTypes.SHELL_DATA{options_ref,
                                       context_ref,
                                       print_method_table_ref,
                                       error_info,
                                       name_monitor,
                                       prompter,
                                       user_options,
                                       ...},
                xinterface_fn)) =
d84 8
a91 10
                        (ShellTypes.SHELL_DATA
                         {options_ref = ref (!options_ref),
                          context_ref = ref context',
                          print_method_table_ref = ref (!print_method_table_ref),
                          error_info = error_info,
                          name_monitor = name_monitor,
                          prompter = prompter,
                          debugger = debugger_function,
                          user_options = UserOptions.make_user_options (!options_ref)},
                         xinterface_fn));
d144 13
a156 14
        (ShellTypes.SHELL_ARGS
         (ShellTypes.SHELL_DATA
          {options_ref = options_ref,
           context_ref = context_ref,
           print_method_table_ref = print_method_table_ref,
           user_options=user_options,
           error_info = error_info,
           name_monitor = name_monitor,
           debugger = debugger_function,
           prompter = prompter},
          exit_fn,
          false,		(* X isn't running yet. *)
          xinterface_fn,
          listener))
@


1.2
log
@Options & Info changes
Changes for ShellData type
@
text
@d6 4
d53 82
a134 1
    exception DebuggerTrapped
d136 34
a169 151
    fun listener (ShellTypes.LISTENER_ARGS
                  (shell_data as ShellTypes.SHELL_DATA{options_ref as ref options,
                                                       context_ref as ref context,
                                                       print_method_table_ref as ref print_method_table,
                                                       error_info,
                                                       name_monitor,
                                                       prompter,
                                                       ...},
                  xinterface_fn)) =
      let
        exception Exit of int

        val prompter_arg =
          {subline = ref 0, name = ref "MLWorks", topdec = ref 0}
          
	val user_options = UserOptions.make_user_options options

	fun debugger_function
	      (_,_,current_module)
	      f
	      x =
          let
            val _ = ShellTypes.update_options shell_data

            val call_debugger =
              Ml_Debugger.ml_debugger 
              Ml_Debugger.TERMINAL
              (ShellTypes.get_current_print_method_table shell_data,
               ShellTypes.make_incremental_options shell_data,
               ShellTypes.get_context_ref shell_data,
               current_module)
              (fn context' =>
               (listener (ShellTypes.LISTENER_ARGS
                          (ShellTypes.copy_shell_data_with_context (shell_data,context'),
                           xinterface_fn));
               ()))
          in
            MLWorks.Internal.Value.frame_call
            (fn base_frame => 
             (MLWorks.Internal.Runtime.Event.signal
              (2,
               fn s => (call_debugger 
                        (Ml_Debugger.BASE_FRAME base_frame)
                        (Ml_Debugger.SIGNAL s,
                         Ml_Debugger.POSSIBLE (
                                               "Return to TopLevel by raising Interrupt",
                                               Ml_Debugger.DO_RAISE Interrupt
                                               ),
                         Ml_Debugger.POSSIBLE (
                                               "Continue interrupted code",
                                               Ml_Debugger.NORMAL_RETURN
                                               ));
                        ()
                        )
               );
              (MLWorks.Internal.Tracing.with_tracing (
	       fn in_value => 
                 call_debugger 
                   Ml_Debugger.NO_BASE_FRAME 
		   (Ml_Debugger.TRACE in_value,
		    Ml_Debugger.NOT_POSSIBLE,
		    Ml_Debugger.NOT_POSSIBLE
	       ))
	     f
	     x
	    )
            handle DebuggerTrapped => raise DebuggerTrapped
            | exn as Exit _ => raise exn
            | exn as Interrupt => raise exn
            | exn as Info.Stop _ => raise exn
            | exn => 
                 (call_debugger 
                    (Ml_Debugger.BASE_FRAME base_frame)
		    (Ml_Debugger.EXCEPTION exn,
                     Ml_Debugger.POSSIBLE 
                     ("Raise Interrupt",
		      Ml_Debugger.DO_RAISE DebuggerTrapped
                      ),
                     Ml_Debugger.NOT_POSSIBLE
                     );
                    raise DebuggerTrapped)))
          end

	val exit_fn : int -> unit = (fn n => raise Exit n)

        val (handler, reset_prompt) =
          Shell.shell
          (ShellTypes.SHELL_ARGS
           (ShellTypes.SHELL_DATA
            {options_ref = ref options,
             context_ref = ref context,
             print_method_table_ref = ref print_method_table,
             user_options=user_options,
             error_info = error_info,
             name_monitor = name_monitor,
             debugger = debugger_function,
             prompter = prompter},
            exit_fn,
            false,		(* X isn't running yet. *)
            xinterface_fn,
            listener))

	exception Exit

	fun loop () =
	  let
            fun prompt line_number =
              let
                val arg =
                  let
                    val {subline, name, topdec} = prompter_arg
                  in
                    {line = line_number, subline = !subline,
		     name = !name,       topdec = !topdec}
                  end
              in
                output (std_out, prompter arg);
                MLWorks.IO.flush_out std_out;
                let
                  val line = MLWorks.IO.input_line std_in
                    
                  fun trivial 0 = true
                    | trivial n =
                      let
                        val c = MLWorks.String.ordof (line, n-1)
                      in
                        (c = ord " " orelse c = ord "\n" orelse
                         c = ord "\t" orelse c = ord "\012") andalso
                        trivial (n-1)
                      end
                in
                  if line = "" (*eof*) then raise Exit (*line *) else
                    if trivial (size line) then
                      prompt line_number
                    else
                      ((#subline prompter_arg) := !(#subline prompter_arg)+1;
                       line)
                end
              end
	    (*
            (prompter_arg, Lexer.mkLineTokenStream (prompt, name))
	    *)
          in
	    handler (prompt 0);
	    loop ()
	  end
	  handle Exit => 0

      in
        loop ()
      end (* of listener *)
@


1.1
log
@Initial revision
@
text
@d5 4
a8 1
 *  $Log$
a12 1
require "../main/toplevel";
a13 1
require "interprint";
a20 1
  structure InterPrint : INTERPRINT
a22 2
  structure TopLevel : TOPLEVEL
  structure ShellStructure: SHELL_STRUCTURE
d27 4
a30 9
  sharing InterPrint.Incremental =
	  Ml_Debugger.Incremental =
	  UserOptions.Incremental =
	  ShellTypes.Incremental

  sharing type InterPrint.ValuePrinter.printer_descriptor =
	       Ml_Debugger.ValuePrinter.printer_descriptor =
	       UserOptions.printer_descriptor =
	       ShellTypes.printer_descriptor
a35 1
	       ShellStructure.ShellArgs =
d39 1
a39 2
  	       ShellStructure.Context =
	       ShellTypes.Incremental.context
d41 1
a41 3
  sharing TopLevel.MirTypes =
          InterPrint.Incremental.InterMake.Compiler.MirTypes
): TTY_LISTENER =
d43 1
a43 1
  structure Incremental = InterPrint.Incremental
d45 1
a45 1
  structure Lexer = Compiler.Parser.Lexer
a49 6

    (* made the action queue global -- code should ensure that it is never *)
    (* left unemptied *)
    (*
    val action_queue = ShellStructure.ActionQueue.create ();
    *)
d51 9
a59 12
    fun listener (ShellTypes.LISTENER_ARGS (
		(compiler_options as Compiler.MirTypes.OPTIONS{
		  info_opts,
		  ...
		},
                make_options
	       ),
	       context,
	       prompter,
	       print_options,
	       xinterface
	      )) =
d66 1
a66 2
	val user_options =
	  UserOptions.make_user_options (print_options, compiler_options)
d69 1
a69 11
	      (options as Incremental.OPTIONS{
		 make_options,
                 compiler_options as Compiler.MirTypes.OPTIONS{
		   info_opts,
		   ...
		 },
		 ...
	       },
	       context,
               current_module
	      )
d73 1
a73 2
	    val print_options' =
	      UserOptions.new_pr_options (user_options, print_options)
a74 12
	    val (info_opts',
		 options' as Incremental.OPTIONS {
		   compiler_options = compiler_options',
		   make_options = make_options',
		   ...
		}) = 
	      UserOptions.new_shell_options (
		user_options,
		info_opts,
		options
	      )

d78 4
a81 2
              info_opts'
              (print_options', options', context,current_module)
d83 4
a86 11
               (listener (ShellTypes.LISTENER_ARGS (
		 (compiler_options',
		  make_options'
		 ),
                 context',
		 prompter,
		 print_options',
		 xinterface
		));
                ()
	      ))
d120 1
a120 1
            | exn as Lexer.Info.Stop _ => raise exn
d134 1
a134 8
        val shell_options =
          Incremental.OPTIONS {
	    compiler_options = compiler_options,
            make_options = make_options,
            debugger = debugger_function
	  }

	val exit_fn = MLWorks.Internal.Value.cast (fn n => raise Exit n)
d137 15
a151 17
          Shell.shell (
	    Incremental.initial,
	    ShellTypes.SHELL_ARGS (
              prompter,
              shell_options,
              print_options,
	      user_options,
	      exit_fn,
	      false,		(* X isn't running yet. *)
	      xinterface,
              listener))

	(*
        val (prompt_parameters, token_stream) =
          interactive_input (Incremental.name context, instream,
			     outstream, prompter)
        *)
a197 97
    
	(*
        fun loop () =
          let
            datatype doit = STOP of int | AGAIN of Incremental.options
            fun loop' shell_options =
              if Lexer.eof token_stream then
	      ( (* Lexer.clear_eof token_stream; *)
                STOP 0
	      ) else
                let
                  val context = !current_context
		  fun recycle (info_opts, shell_opts) =
		    let
		      val (_, shell_options') =
		        UserOptions.new_shell_options (
		          user_options,
		          info_opts,
		          shell_opts
		        )
		    in
                      AGAIN shell_options'
		    end
                in
                  ((#subline prompt_parameters) := 0;
                   (#topdec prompt_parameters) := Incremental.topdec context;
                   (#name prompt_parameters) := Incremental.name context;
                   let
                     val (context, identifiers) =
                       (Incremental.add_source shell_options (
			  context,
			  Compiler.TOKENSTREAM1 token_stream
		       ))
                       handle exn => (Lexer.flush_to_nl token_stream;
                                      raise exn)
 
		     val (info_options', shell_options') =
		       UserOptions.new_shell_options (
		         user_options,
		         info_opts,
		         shell_options
		       )
                     val print_options' =
		       UserOptions.new_pr_options (user_options,
						      print_options)
                     val _ = 
                       InterPrint.definitions
		         std_out
		         info_options'
		         (context,
                          print_options',
		          0,
                          identifiers
		         )
		     val _ =
		       current_context := 
                         ShellStructure.ActionQueue.do_actions (
		           action_queue,
                           0,
                           context,
                           std_out,
                           (fn s => output(std_out, s)),
                           shell_options',
		           print_options'
		         )
		   in
		     recycle (info_options', shell_options')
		   end
		  )
                  handle Exit n => STOP n
                  | Lexer.Info.Stop _ => recycle (info_opts, shell_options)
                  | DebuggerTrapped => recycle (info_opts, shell_options)
                  | Interrupt => recycle (info_opts, shell_options)
                  | exn =>
                      let
                        val string =
                          MLWorks.Internal.Value.exn_name_string
                            (MLWorks.Internal.Value.exn_name exn)
                      in
                        output(std_out,
			       "Uncaught exception " ^ string ^ "\n");
                        recycle (info_opts, shell_options)
                      end
                end

            fun cycle shell_opts =
              let
                val x = loop' shell_opts
              in
                case x of
                  STOP n => n
                | AGAIN shell_opts' => cycle shell_opts'
              end
          in
            cycle shell_options
          end
	  *)
a198 14
	  (*
          val context =
	    ShellStructure.make_shell_structure(
	      context,
              user_options,
              print_options, 
              shell_options, 
              prompter,
              action_queue,
	      exit_fn,
	      xinterface,
	      listener
	    )
	  *)
a199 3
	(*
        current_context := context;
	*)
@
