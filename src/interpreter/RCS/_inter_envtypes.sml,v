head	1.23;
access;
symbols
	MLW_daveb_inline_1_4_99:1.23.1
	MLWorks_21c0_1999_03_25:1.23
	MLWorks_20c1_1998_08_20:1.23
	MLWorks_20c0_1998_08_04:1.23
	MLWorks_20b2c2_1998_06_19:1.23
	MLWorks_20b2_Windows_1998_06_12:1.23
	MLWorks_20b1c1_1998_05_07:1.23
	MLWorks_20b0_1998_04_07:1.23
	MLWorks_20b0_1998_03_20:1.23
	MLWorks_20m2_1998_02_16:1.22
	MLWorks_20m1_1997_10_23:1.22
	MLWorks_11r1:1.21.8.1.1.1.1
	MLWorks_workspace_97:1.22.2
	MLWorks_dt_wizard:1.22.1
	MLWorks_11c0_1997_09_09:1.21.8.1.1.1
	MLWorks_10r3:1.21.8.1.3
	MLWorks_10r2_551:1.21.8.1.2
	MLWorks_11:1.21.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.21.8.1
	MLWorks_20m0_1997_06_20:1.22
	MLWorks_1_0_r2c2_1997_06_14:1.21.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.21.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.21.8
	MLWorks_BugFix_1997_04_24:1.21
	MLWorks_1_0_r2_Win32_1997_04_11:1.21
	MLWorks_1_0_r2_Unix_1997_04_04:1.21
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.21.6.1.1
	MLWorks_gui_1996_12_18:1.21.7
	MLWorks_1_0_Win32_1996_12_17:1.21.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.21.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.21.4.1
	MLWorks_1_0_Irix_1996_11_28:1.21.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.21.5
	MLWorks_1_0_Unix_1996_11_14:1.21.4
	MLWorks_Open_Beta2_1996_10_11:1.21.3
	MLWorks_License_dev:1.21.2
	MLWorks_1_open_beta_1996_09_13:1.21.1
	MLWorks_Open_Beta_1996_08_22:1.21
	MLWorks_Beta_1996_07_02:1.21
	MLWorks_Beta_1996_06_07:1.21
	MLWorks_Beta_1996_06_06:1.21
	MLWorks_Beta_1996_06_05:1.21
	MLWorks_Beta_1996_06_03:1.21
	MLWorks_Beta_1996_05_31:1.21
	MLWorks_Beta_1996_05_30:1.21
	ML_beta_release_12/08/94:1.17
	ML_beta_release_03/08/94:1.17
	ML_revised_beta_release_25/05/94:1.17
	ML_final_beta_release_02/03/94:1.17
	mlworks-28-01-1994:1.17
	Release:1.17
	mlworks-beta-01-09-1993:1.17
	MLWorks-1-0-4-29/01/1993:1.13
	MLWorks-1-0-3-21/12/1992:1.13
	MLWorks-1-0-2-15/12/1992:1.13
	MLWorks-1-0-1-04/12/1992:1.13
	checkpoint_17_08_92:1.5;
locks; strict;
comment	@ * @;


1.23
date	98.02.20.09.33.51;	author mitchell;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	97.05.19.10.43.47;	author jont;	state Exp;
branches
	1.22.1.1
	1.22.2.1;
next	1.21;

1.21
date	96.05.01.09.40.55;	author jont;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1
	1.21.4.1
	1.21.5.1
	1.21.6.1
	1.21.7.1
	1.21.8.1;
next	1.20;

1.20
date	96.03.19.16.19.42;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	96.02.23.17.48.49;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	94.12.06.10.32.23;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.07.05.13.55.20;	author daveb;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	93.04.26.17.01.01;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.03.11.10.26.12;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.03.04.18.08.06;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.11.27.15.06.10;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	92.10.27.18.29.00;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.10.13.14.13.32;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.10.06.08.27.40;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.09.10.16.57.33;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.08.26.18.57.15;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.08.26.18.54.42;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.08.19.10.55.15;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.08.13.16.17.09;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.08.04.18.47.17;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.07.29.09.53.03;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	92.06.19.17.01.55;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	92.06.18.12.10.39;	author jont;	state Exp;
branches;
next	;

1.17.1.1
date	93.07.05.13.55.20;	author jont;	state Exp;
branches;
next	;

1.21.1.1
date	96.09.13.11.15.36;	author hope;	state Exp;
branches;
next	;

1.21.2.1
date	96.10.07.16.05.49;	author hope;	state Exp;
branches;
next	;

1.21.3.1
date	96.10.17.11.24.06;	author hope;	state Exp;
branches;
next	;

1.21.4.1
date	96.11.14.12.48.37;	author hope;	state Exp;
branches
	1.21.4.1.1.1;
next	;

1.21.4.1.1.1
date	96.11.28.15.00.09;	author hope;	state Exp;
branches;
next	;

1.21.5.1
date	96.11.22.18.08.29;	author hope;	state Exp;
branches;
next	;

1.21.6.1
date	96.12.17.17.47.10;	author hope;	state Exp;
branches
	1.21.6.1.1.1;
next	;

1.21.6.1.1.1
date	97.02.24.11.36.52;	author hope;	state Exp;
branches;
next	;

1.21.7.1
date	96.12.18.09.41.11;	author hope;	state Exp;
branches;
next	;

1.21.8.1
date	97.05.12.10.33.37;	author hope;	state Exp;
branches
	1.21.8.1.1.1
	1.21.8.1.2.1
	1.21.8.1.3.1;
next	;

1.21.8.1.1.1
date	97.07.28.18.19.35;	author daveb;	state Exp;
branches
	1.21.8.1.1.1.1.1;
next	;

1.21.8.1.1.1.1.1
date	97.10.07.11.44.44;	author jkbrook;	state Exp;
branches;
next	;

1.21.8.1.2.1
date	97.09.08.17.13.11;	author daveb;	state Exp;
branches;
next	;

1.21.8.1.3.1
date	97.09.09.14.08.49;	author daveb;	state Exp;
branches;
next	;

1.22.1.1
date	97.09.10.19.24.12;	author brucem;	state Exp;
branches;
next	;

1.22.2.1
date	97.09.11.20.54.59;	author daveb;	state Exp;
branches;
next	;

1.23.1.1
date	99.04.01.17.56.56;	author daveb;	state Exp;
branches;
next	;


desc
@Value environment for interpreter
@


1.23
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _inter_envtypes.sml the functor *)
(*
$Log: _inter_envtypes.sml,v $
 * Revision 1.22  1997/05/19  10:43:47  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.21  1996/05/01  09:40:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.20  1996/03/19  16:19:42  matthew
 * Problems with value polymorphism
 *
 * Revision 1.19  1996/02/23  17:48:49  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.18  1994/12/06  10:32:23  matthew
 * Changing uses of cast
 *
Revision 1.17  1993/07/05  13:55:20  daveb
Removed exception environments.

Revision 1.16  1993/04/26  17:01:01  jont
Added remove_str for getting rid of FullPervasiveLibrary_ from initial env

Revision 1.15  1993/03/11  10:26:12  matthew
Signature revisions

Revision 1.14  1993/03/04  18:08:06  matthew
Options & Info changes

Revision 1.13  1992/11/27  15:06:10  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.12  1992/10/27  18:29:00  jont
Changeed maps to use valid_lt. Removed dependence on _environ

Revision 1.11  1992/10/13  14:13:32  richard
Corrected a the *completely* bogus implementation of augment.
Added print.

Revision 1.10  1992/10/06  08:27:40  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.9  1992/09/10  16:57:33  richard
Added augment_with_module to do the job of linking module contents
into the environment.

Revision 1.8  1992/08/26  18:57:15  richard
Rationalisation of the MLWorks structure.

Revision 1.7  1992/08/26  18:54:42  jont
Removed some redundant structures and sharing

Revision 1.6  1992/08/19  10:55:15  clive
Changes to reflect pervasive_library changes

Revision 1.5  1992/08/13  16:17:09  clive
Changes to reflect lower level sharing changes

Revision 1.4  1992/08/04  18:47:17  jont
Reworked in terms of NewMap.fold and NewMap.union

Revision 1.3  1992/07/29  09:53:03  jont
Removed references to callc_codes and __callc_codes

Revision 1.2  1992/06/19  17:01:55  jont
Fixed the source errors

Revision 1.1  1992/06/18  12:10:39  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/lists";
require "../lambda/environtypes";
require "../basics/identprint";
require "inter_envtypes";

functor Inter_EnvTypes(
  structure Lists : LISTS
  structure EnvironTypes : ENVIRONTYPES
  structure IdentPrint : IDENTPRINT

  sharing IdentPrint.Ident = EnvironTypes.LambdaTypes.Ident
) : INTER_ENVTYPES =
struct
  structure NewMap = EnvironTypes.NewMap
  structure Ident = EnvironTypes.LambdaTypes.Ident
  structure EnvironTypes = EnvironTypes
  structure Options = IdentPrint.Options

  datatype inter_env =
    INTER_ENV of
    (Ident.ValId, MLWorks.Internal.Value.ml_value) NewMap.map * (* VARs *)
    (Ident.StrId, MLWorks.Internal.Value.ml_value) NewMap.map * (* STRs *)
    (Ident.FunId, MLWorks.Internal.Value.ml_value) NewMap.map (* FUNs *)

  val castit = MLWorks.Internal.Value.cast

  val empty_val_map = NewMap.empty (Ident.valid_lt,Ident.valid_eq)

  val empty_str_map = NewMap.empty (Ident.strid_lt,Ident.strid_eq)

  val empty_fun_map = NewMap.empty (Ident.funid_lt,Ident.funid_eq)

  fun lookup_val(valid, INTER_ENV(val_map, _, _)) =
    NewMap.apply'(val_map, valid)

  fun lookup_str(strid, INTER_ENV(_, str_map, _)) =
    NewMap.apply'(str_map, strid)

  fun lookup_fun(funid, INTER_ENV(_, _, fun_map)) =
    NewMap.apply'(fun_map, funid)

  fun add_val(INTER_ENV(val_map, str_map, fun_map), (valid, value)) =
    INTER_ENV(NewMap.define(val_map, valid, value), str_map, fun_map)

  fun add_str(INTER_ENV(val_map, str_map, fun_map), (strid, value)) =
    INTER_ENV(val_map, NewMap.define(str_map, strid, value), fun_map)

  fun add_fun(INTER_ENV(val_map, str_map, fun_map), (funid, value)) =
    INTER_ENV(val_map, str_map, NewMap.define(fun_map, funid, value))

  fun add_val'(INTER_ENV(val_map, str_map, fun_map), valid, value) =
    INTER_ENV(NewMap.define(val_map, valid, value), str_map, fun_map)

  fun add_str'(INTER_ENV(val_map, str_map, fun_map), strid, value) =
    INTER_ENV(val_map, NewMap.define(str_map, strid, value), fun_map)

  fun add_fun'(INTER_ENV(val_map, str_map, fun_map), funid, value) =
    INTER_ENV(val_map, str_map, NewMap.define(fun_map, funid, value))

  fun add_val_list arg =
    Lists.reducel
    add_val
    arg

  fun add_str_list arg =
    Lists.reducel
    add_str
    arg

  fun add_fun_list arg =
    Lists.reducel
    add_fun
    arg

  val empty_env =
    INTER_ENV(empty_val_map, empty_str_map, empty_fun_map)

  fun remove_str(INTER_ENV(val_map, str_map, fun_map), strid) =
    INTER_ENV(val_map, NewMap.undefine(str_map, strid), fun_map)

  fun augment(inter_env,
	      INTER_ENV(val_map, str_map, fun_map)) =
    let
      val inter_env = NewMap.fold add_val' (inter_env, val_map)
      val inter_env = NewMap.fold add_fun' (inter_env, fun_map)
      val inter_env = NewMap.fold add_str' (inter_env, str_map)
    in
      inter_env
    end

  exception Augment

  fun augment_with_module
        (inter_env,
         EnvironTypes.TOP_ENV (EnvironTypes.ENV (values, structures),
                               EnvironTypes.FUN_ENV functors),
         module) =
    let
      fun link (values, [], alist, f) = (values, alist)
        | link ([], h::_, alist, f) = (print(f h ^ "\n"); raise Augment)
        | link (value::values, x::xs, alist, f) =
          link (values, xs, (x, value)::alist, f)

      val module : MLWorks.Internal.Value.T list = castit module          
      val (module, value_bindings)     = link (module, NewMap.domain_ordered values, [], IdentPrint.debug_printValId)
      val (module, structure_bindings) = link (module, NewMap.domain_ordered structures, [], IdentPrint.printStrId)
      val (module, functor_bindings)   = link (module, NewMap.domain_ordered functors, [], IdentPrint.printFunId)
    in
      ignore(if module = [] then [] else (print"module not empty\n"; raise Augment));
      add_fun_list
      (add_str_list
        (add_val_list
         (inter_env,
          value_bindings),
        structure_bindings),
       functor_bindings)
    end

  fun print options print (out, INTER_ENV (values, structures, functors)) =
    let
      val out =
        NewMap.fold
        (fn (out, valid, _) => print (print (out, " "),
				      IdentPrint.debug_printValId valid))
        (print (out, "values:"), values)
      val out = print (out, "\n")
      val out =
        NewMap.fold
        (fn (out, strid, _) => print (print (out, " "), IdentPrint.printStrId strid))
        (print (out, "structures:"), structures)
      val out = print (out, "\n")
      val out =
        NewMap.fold
        (fn (out, funid, _) => print (print (out, " "), IdentPrint.printFunId funid))
        (print (out, "functors:"), functors)
      val out = print (out, "\n")
    in
      out
    end

end
@


1.23.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.23  1998/02/20  09:33:51  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.22
log
@[Bug #30090]
Translate output std_out to print
@
text
@d4 4
d188 1
a188 1
      if module = [] then [] else (print"module not empty\n"; raise Augment);
@


1.22.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.22  1997/05/19  10:43:47  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.22.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.22  1997/05/19  10:43:47  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.21
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d175 1
a175 1
        | link ([], h::_, alist, f) = (MLWorks.IO.output (MLWorks.IO.std_out, f h ^ "\n"); raise Augment)
d184 1
a184 1
      if module = [] then [] else (MLWorks.IO.output (MLWorks.IO.std_out, "module not empty\n"); raise Augment);
@


1.21.8.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/05/01  09:40:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.21.8.1  1997/05/12  10:33:37  hope
 * branched from 1.21
 *
@


1.21.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.21.8.1  1997/05/12  10:33:37  hope
 * branched from 1.21
 *
@


1.21.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.21.8.1  1997/05/12  10:33:37  hope
 * branched from 1.21
 *
@


1.21.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.21.8.1.1.1  1997/07/28  18:19:35  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.21.7.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/05/01  09:40:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.6.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/05/01  09:40:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.6.1.1.1
log
@branched from 1.21.6.1
@
text
@a3 3
 * Revision 1.21.6.1  1996/12/17  17:47:10  hope
 * branched from 1.21
 *
@


1.21.5.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/05/01  09:40:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.4.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/05/01  09:40:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.4.1.1.1
log
@branched from 1.21.4.1
@
text
@a3 3
 * Revision 1.21.4.1  1996/11/14  12:48:37  hope
 * branched from 1.21
 *
@


1.21.3.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/05/01  09:40:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.2.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/05/01  09:40:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.1.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/05/01  09:40:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.20
log
@Problems with value polymorphism
@
text
@d4 3
d169 1
a169 1
        | link ([], h::_, alist, f) = (output (std_out, f h ^ "\n"); raise Augment)
d178 1
a178 1
      if module = [] then [] else (output (std_out, "module not empty\n"); raise Augment);
@


1.19
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
d91 1
a91 1
  val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
@


1.18
log
@Changing uses of cast
@
text
@d4 3
d84 3
a86 3
    (Ident.ValId, MLWorks.Internal.Value.ml_value) NewMap.T * (* VARs *)
    (Ident.StrId, MLWorks.Internal.Value.ml_value) NewMap.T * (* STRs *)
    (Ident.FunId, MLWorks.Internal.Value.ml_value) NewMap.T (* FUNs *)
@


1.17
log
@Removed exception environments.
@
text
@d4 3
d85 2
d164 1
a164 1
      val module : MLWorks.Internal.Value.T list = MLWorks.Internal.Value.cast module          
@


1.17.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.17  1993/07/05  13:55:20  daveb
Removed exception environments.

@


1.16
log
@Added remove_str for getting rid of FullPervasiveLibrary_ from initial env
@
text
@d4 3
a78 1
    (Ident.ValId, MLWorks.Internal.Value.ml_value) NewMap.T * (* EXNs *)
a83 2
  val empty_exn_map = NewMap.empty (Ident.valid_lt,Ident.valid_eq)

d88 1
a88 1
  fun lookup_val(valid, INTER_ENV(val_map, _, _, _)) =
d91 1
a91 4
  fun lookup_exn(valid, INTER_ENV(_, exn_map, _, _)) =
    NewMap.apply'(exn_map, valid)

  fun lookup_str(strid, INTER_ENV(_, _, str_map, _)) =
d94 1
a94 1
  fun lookup_fun(funid, INTER_ENV(_, _, _, fun_map)) =
d97 2
a98 8
  fun add_val(INTER_ENV(val_map, exn_map, str_map, fun_map), (valid, value)) =
    INTER_ENV(NewMap.define(val_map, valid, value), exn_map, str_map, fun_map)

  fun add_exn(INTER_ENV(val_map, exn_map, str_map, fun_map), (valid, value)) =
    INTER_ENV(val_map, NewMap.define(exn_map, valid, value), str_map, fun_map)

  fun add_str(INTER_ENV(val_map, exn_map, str_map, fun_map), (strid, value)) =
    INTER_ENV(val_map, exn_map, NewMap.define(str_map, strid, value), fun_map)
d100 2
a101 2
  fun add_fun(INTER_ENV(val_map, exn_map, str_map, fun_map), (funid, value)) =
    INTER_ENV(val_map, exn_map, str_map, NewMap.define(fun_map, funid, value))
d103 2
a104 2
  fun add_val'(INTER_ENV(val_map, exn_map, str_map, fun_map), valid, value) =
    INTER_ENV(NewMap.define(val_map, valid, value), exn_map, str_map, fun_map)
d106 2
a107 2
  fun add_exn'(INTER_ENV(val_map, exn_map, str_map, fun_map), valid, value) =
    INTER_ENV(val_map, NewMap.define(exn_map, valid, value), str_map, fun_map)
d109 2
a110 2
  fun add_str'(INTER_ENV(val_map, exn_map, str_map, fun_map), strid, value) =
    INTER_ENV(val_map, exn_map, NewMap.define(str_map, strid, value), fun_map)
d112 2
a113 2
  fun add_fun'(INTER_ENV(val_map, exn_map, str_map, fun_map), funid, value) =
    INTER_ENV(val_map, exn_map, str_map, NewMap.define(fun_map, funid, value))
a119 5
  fun add_exn_list arg =
    Lists.reducel
    add_exn
    arg

d131 1
a131 1
    INTER_ENV(empty_val_map, empty_exn_map, empty_str_map, empty_fun_map)
d133 2
a134 2
  fun remove_str(INTER_ENV(val_map, exn_map, str_map, fun_map), strid) =
    INTER_ENV(val_map, exn_map, NewMap.undefine(str_map, strid), fun_map)
d137 1
a137 1
	      INTER_ENV(val_map, exn_map, str_map, fun_map)) =
a139 1
      val inter_env = NewMap.fold add_exn' (inter_env, exn_map)
d150 1
a150 1
         EnvironTypes.TOP_ENV (EnvironTypes.ENV (values, exceptions, structures),
d154 4
a157 4
      fun link (values, [], alist) = (values, alist)
        | link ([], _, alist) = raise Augment
        | link (value::values, x::xs, alist) =
          link (values, xs, (x, value)::alist)
d160 3
a162 4
      val (module, value_bindings)     = link (module, NewMap.domain_ordered values, [])
      val (module, exception_bindings) = link (module, NewMap.domain_ordered exceptions, [])
      val (module, structure_bindings) = link (module, NewMap.domain_ordered structures, [])
      val (module, functor_bindings)   = link (module, NewMap.domain_ordered functors, [])
d164 1
a164 1
      if module = [] then [] else raise Augment;
a166 1
       (add_exn_list
a169 1
         exception_bindings),
d174 1
a174 1
  fun print options print (out, INTER_ENV (values, exceptions, structures, functors)) =
d178 2
a179 1
        (fn (out, valid, _) => print (print (out, " "), IdentPrint.printValId options valid))
a180 5
      val out = print (out, "\n")
      val out =
        NewMap.fold
        (fn (out, valid, _) => print (print (out, " "), IdentPrint.printValId options valid))
        (print (out, "exceptions:"), exceptions)
@


1.15
log
@Signature revisions
@
text
@d4 3
d146 3
@


1.14
log
@Options & Info changes
@
text
@d4 3
d62 1
a62 1
  sharing IdentPrint.Ident = EnvironTypes.LambdaTypes.Datatypes.Ident
d65 2
a66 3
  structure Datatypes = EnvironTypes.LambdaTypes.Datatypes
  structure NewMap = Datatypes.NewMap
  structure Ident = Datatypes.Ident
@


1.13
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d58 1
d66 1
a66 1
  structure Info = IdentPrint.Info
@


1.12
log
@Changeed maps to use valid_lt. Removed dependence on _environ
@
text
@d4 3
d61 1
d179 1
a179 1
  fun print print (out, INTER_ENV (values, exceptions, structures, functors)) =
d183 1
a183 1
        (fn (out, valid, _) => print (print (out, " "), IdentPrint.printValId valid))
d188 1
a188 1
        (fn (out, valid, _) => print (print (out, " "), IdentPrint.printValId valid))
@


1.11
log
@Corrected a the *completely* bogus implementation of augment.
Added print.
@
text
@d4 4
d43 1
a43 1
require "../lambda/environ";
d49 1
a49 1
  structure Environ : ENVIRON
d51 1
a51 1
  sharing IdentPrint.Ident = Environ.EnvironTypes.LambdaTypes.Datatypes.Ident
d54 1
a54 1
  structure Datatypes = Environ.EnvironTypes.LambdaTypes.Datatypes
d57 1
a57 1
  structure EnvironTypes = Environ.EnvironTypes
d66 1
a66 1
  val empty_val_map = NewMap.empty (Environ.valid_order,Environ.valid_equal)
d68 1
a68 1
  val empty_exn_map = NewMap.empty (Environ.valid_order,Environ.valid_equal)
d70 1
a70 1
  val empty_str_map = NewMap.empty (Environ.strid_order,Environ.strid_equal)
d72 1
a72 1
  val empty_fun_map = NewMap.empty (Environ.funid_order,Environ.funid_equal)
@


1.10
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d40 1
d46 2
d132 4
a135 18
      val tree = 
	NewMap.fold
	add_val'
	(inter_env, val_map)
      val tree =
	NewMap.fold
	add_exn'
	(inter_env, exn_map)
      val tree =
	NewMap.fold
	add_fun'
      val tree =
	NewMap.fold
	add_str'
(*
	(fn (tree, dom, ran) => add_str(tree, (dom, ran)))
*)
	(inter_env, str_map)
d137 1
a137 1
      tree
d152 2
a153 1
          
d169 26
@


1.9
log
@Added augment_with_module to do the job of linking module contents
into the environment.
@
text
@d4 4
d56 1
a56 1
  val empty_val_map = NewMap.empty Environ.valid_order
d58 1
a58 1
  val empty_exn_map = NewMap.empty Environ.valid_order
d60 1
a60 1
  val empty_str_map = NewMap.empty Environ.strid_order
d62 1
a62 1
  val empty_fun_map = NewMap.empty Environ.funid_order
@


1.8
log
@Rationalisation of the MLWorks structure.
@
text
@d4 3
d43 1
d116 1
a116 1
  val initial_env =
d143 31
@


1.7
log
@Removed some redundant structures and sharing
@
text
@d4 3
d43 4
a46 4
    (Ident.ValId, MLWorks.System.Unsafe.Value.ml_value) NewMap.T * (* VARs *)
    (Ident.ValId, MLWorks.System.Unsafe.Value.ml_value) NewMap.T * (* EXNs *)
    (Ident.StrId, MLWorks.System.Unsafe.Value.ml_value) NewMap.T * (* STRs *)
    (Ident.FunId, MLWorks.System.Unsafe.Value.ml_value) NewMap.T (* FUNs *)
@


1.6
log
@Changes to reflect pervasive_library changes
@
text
@d4 3
a24 1
require "../utils/newmap";
a25 1
require "../basics/ident";
a29 1
  structure NewMap : NEWMAP
a30 1
  structure Ident : IDENT
a31 2
  sharing NewMap = Environ.EnvironTypes.NewMap
  sharing Ident = Environ.Ident
d34 3
a36 2
  structure NewMap = NewMap
  structure Ident = Ident
@


1.5
log
@Changes to reflect lower level sharing changes
@
text
@d4 3
d42 4
a45 4
    (Ident.ValId, MLWorks.System.Unsafe.Int.ml_value) NewMap.T * (* VARs *)
    (Ident.ValId, MLWorks.System.Unsafe.Int.ml_value) NewMap.T * (* EXNs *)
    (Ident.StrId, MLWorks.System.Unsafe.Int.ml_value) NewMap.T * (* STRs *)
    (Ident.FunId, MLWorks.System.Unsafe.Int.ml_value) NewMap.T (* FUNs *)
@


1.4
log
@Reworked in terms of NewMap.fold and NewMap.union
@
text
@d4 3
d39 4
a42 4
    (Ident.ValId, System.Unsafe.Int.ml_value) NewMap.T * (* VARs *)
    (Ident.ValId, System.Unsafe.Int.ml_value) NewMap.T * (* EXNs *)
    (Ident.StrId, System.Unsafe.Int.ml_value) NewMap.T * (* STRs *)
    (Ident.FunId, System.Unsafe.Int.ml_value) NewMap.T (* FUNs *)
@


1.3
log
@Removed references to callc_codes and __callc_codes
@
text
@d4 3
d73 12
d111 18
a128 4
      val val_list = NewMap.to_list val_map
      val exn_list = NewMap.to_list exn_map
      val str_list = NewMap.to_list str_map
      val fun_list = NewMap.to_list fun_map
d130 1
a130 2
      add_val_list(add_exn_list(add_str_list(add_fun_list(inter_env, fun_list),
					     str_list), exn_list), val_list)
@


1.2
log
@Fixed the source errors
@
text
@d4 3
a12 1
require "../rts/callc_codes";
a19 1
  structure CallC_Codes : CALLC_CODES
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d12 2
a13 1
require "../basics/symbol";
d20 2
a21 1
  structure Symbol : SYMBOL
d24 1
d28 1
a28 1
  structure Symbol = Symbol
a29 8
(*
  datatype source_name =
    VAR of Symbol.Symbol |
    EXN of Symbol.Symbol |
    STR of Symbol.Symbol |
    FUN of Symbol.Symbol
*)

a90 6
(*
  datatype top_element =
    REAL of real |
    STRING of string |
    INT_CODE of string | (* The internal pieces of code *)
    EXT_CODE of store_value (* The external references *)
d92 11
a102 6
  fun call_code top_element_list =
    System.call_c(CallC_Codes.call_compiled_code, top_element_list)
  (* Call the compiled code given as a list here, the first element *)
  (* being the top level procedure itself (cf external compilation system) *)
*)

@
