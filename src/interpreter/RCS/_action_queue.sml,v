head	1.75;
access;
symbols
	MLWorks_20m1_1997_10_23:1.75
	MLWorks_11r1:1.74.1.1.1.1.1
	MLWorks_workspace_97:1.75.2
	MLWorks_dt_wizard:1.75.1
	MLWorks_11c0_1997_09_09:1.74.1.1.1.1
	MLWorks_10r3:1.74.1.1.3
	MLWorks_10r2_551:1.74.1.1.2
	MLWorks_11:1.74.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.74.1.1
	MLWorks_20m0_1997_06_20:1.75
	MLWorks_1_0_r2c2_1997_06_14:1.74.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.74.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.74.1
	MLWorks_BugFix_1997_04_24:1.74
	MLWorks_1_0_r2_Win32_1997_04_11:1.74
	MLWorks_1_0_r2_Unix_1997_04_04:1.74
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.73.3.1.1
	MLWorks_gui_1996_12_18:1.73.4
	MLWorks_1_0_Win32_1996_12_17:1.73.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.73.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.73.1.1
	MLWorks_1_0_Irix_1996_11_28:1.73.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.73.2
	MLWorks_1_0_Unix_1996_11_14:1.73.1
	MLWorks_Open_Beta2_1996_10_11:1.72.3
	MLWorks_License_dev:1.72.2
	MLWorks_1_open_beta_1996_09_13:1.72.1
	MLWorks_Open_Beta_1996_08_22:1.72
	MLWorks_Beta_1996_07_02:1.70
	MLWorks_Beta_1996_06_07:1.68
	MLWorks_Beta_1996_06_06:1.68
	MLWorks_Beta_1996_06_05:1.68
	MLWorks_Beta_1996_06_03:1.68
	MLWorks_Beta_1996_05_31:1.68
	MLWorks_Beta_1996_05_30:1.67
	ML_beta_release_12/08/94:1.35
	ML_beta_release_03/08/94:1.34
	ML_revised_beta_release_25/05/94:1.33
	ML_final_beta_release_02/03/94:1.31
	mlworks-28-01-1994:1.28
	Release:1.24
	mlworks-beta-01-09-1993:1.24;
locks; strict;
comment	@ * @;


1.75
date	97.05.19.10.40.08;	author jont;	state Exp;
branches
	1.75.1.1
	1.75.2.1;
next	1.74;

1.74
date	97.03.17.15.34.33;	author matthew;	state Exp;
branches
	1.74.1.1;
next	1.73;

1.73
date	96.10.30.12.20.39;	author io;	state Exp;
branches
	1.73.1.1
	1.73.2.1
	1.73.3.1
	1.73.4.1;
next	1.72;

1.72
date	96.08.20.14.04.08;	author daveb;	state Exp;
branches
	1.72.1.1
	1.72.2.1
	1.72.3.1;
next	1.71;

1.71
date	96.08.06.09.27.49;	author stephenb;	state Exp;
branches;
next	1.70;

1.70
date	96.06.24.11.45.21;	author daveb;	state Exp;
branches;
next	1.69;

1.69
date	96.06.21.15.24.53;	author stephenb;	state Exp;
branches;
next	1.68;

1.68
date	96.05.30.13.14.19;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	96.05.23.12.14.52;	author stephenb;	state Exp;
branches;
next	1.66;

1.66
date	96.05.21.11.11.54;	author stephenb;	state Exp;
branches;
next	1.65;

1.65
date	96.05.17.09.50.48;	author stephenb;	state Exp;
branches;
next	1.64;

1.64
date	96.05.08.12.17.52;	author stephenb;	state Exp;
branches;
next	1.63;

1.63
date	96.05.08.11.27.32;	author daveb;	state Exp;
branches;
next	1.62;

1.62
date	96.05.03.09.47.56;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	96.05.01.10.22.08;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	96.04.19.14.27.53;	author stephenb;	state Exp;
branches;
next	1.59;

1.59
date	96.04.18.15.03.27;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	96.04.12.08.38.15;	author stephenb;	state Exp;
branches;
next	1.57;

1.57
date	96.04.09.18.27.03;	author daveb;	state Exp;
branches;
next	1.56;

1.56
date	96.04.02.11.34.57;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	96.03.27.15.17.21;	author stephenb;	state Exp;
branches;
next	1.54;

1.54
date	96.03.26.09.43.26;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	96.03.19.12.29.17;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	96.03.15.12.37.24;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	96.02.09.17.52.51;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	95.12.12.11.49.02;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	95.12.06.18.46.31;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	95.12.04.11.38.25;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	95.07.28.14.01.42;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	95.06.12.16.26.33;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	95.06.08.09.25.30;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	95.06.05.14.37.53;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	95.05.26.11.36.59;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.04.28.17.57.11;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	95.04.21.13.56.09;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.04.12.13.27.18;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	95.02.20.14.28.27;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	95.01.16.10.37.50;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	94.12.08.17.53.41;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	94.08.17.14.31.54;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	94.08.10.14.07.56;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	94.06.21.16.13.54;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	94.03.25.16.28.05;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	94.03.17.12.50.37;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	94.02.25.15.41.52;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	94.02.02.10.32.20;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	94.01.28.16.21.12;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	94.01.06.16.16.43;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.11.26.12.14.42;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.10.08.16.18.17;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.09.06.13.55.41;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	93.08.24.17.08.39;	author matthew;	state Exp;
branches
	1.24.1.1;
next	1.23;

1.23
date	93.08.24.12.14.23;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.08.12.16.12.48;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	93.08.10.11.57.12;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.07.29.15.31.59;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.05.26.17.02.39;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.05.19.10.48.33;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.05.12.16.02.52;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.05.11.13.36.11;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.05.10.13.58.40;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	93.05.06.16.49.51;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	93.05.06.14.01.26;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.05.04.15.23.14;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.04.30.09.41.26;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.04.02.14.42.36;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.03.31.16.08.34;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.03.29.16.36.30;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.03.26.18.37.05;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.03.25.10.32.53;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	93.03.19.18.43.24;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.03.18.18.43.26;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.03.12.11.15.28;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.09.15.41.43;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.02.11.13.10;	author daveb;	state Exp;
branches;
next	;

1.24.1.1
date	93.08.24.17.08.39;	author jont;	state Exp;
branches;
next	1.24.1.2;

1.24.1.2
date	93.10.08.13.14.04;	author matthew;	state Exp;
branches;
next	;

1.72.1.1
date	96.09.13.11.16.19;	author hope;	state Exp;
branches;
next	;

1.72.2.1
date	96.10.07.16.06.19;	author hope;	state Exp;
branches;
next	;

1.72.3.1
date	96.10.17.11.24.34;	author hope;	state Exp;
branches;
next	;

1.73.1.1
date	96.11.14.12.49.20;	author hope;	state Exp;
branches
	1.73.1.1.1.1;
next	;

1.73.1.1.1.1
date	96.11.28.15.00.37;	author hope;	state Exp;
branches;
next	;

1.73.2.1
date	96.11.22.18.09.00;	author hope;	state Exp;
branches;
next	;

1.73.3.1
date	96.12.17.17.47.38;	author hope;	state Exp;
branches
	1.73.3.1.1.1;
next	;

1.73.3.1.1.1
date	97.02.24.11.37.24;	author hope;	state Exp;
branches;
next	;

1.73.4.1
date	96.12.18.09.41.39;	author hope;	state Exp;
branches;
next	;

1.74.1.1
date	97.05.12.10.34.06;	author hope;	state Exp;
branches
	1.74.1.1.1.1
	1.74.1.1.2.1
	1.74.1.1.3.1;
next	;

1.74.1.1.1.1
date	97.07.28.18.19.09;	author daveb;	state Exp;
branches
	1.74.1.1.1.1.1.1;
next	;

1.74.1.1.1.1.1.1
date	97.10.07.11.44.16;	author jkbrook;	state Exp;
branches;
next	;

1.74.1.1.2.1
date	97.09.08.17.12.45;	author daveb;	state Exp;
branches;
next	;

1.74.1.1.3.1
date	97.09.09.14.08.23;	author daveb;	state Exp;
branches;
next	;

1.75.1.1
date	97.09.10.19.23.32;	author brucem;	state Exp;
branches;
next	;

1.75.2.1
date	97.09.11.20.54.31;	author daveb;	state Exp;
branches;
next	;


desc
@Creates an action queue for use by shells, and provides functions
 for manipulating it.  Used to be in shell.
@


1.75
log
@[Bug #30090]
Translate output std_out to print
@
text
@(*  Action Queues store actions to be performed after a shell has evaluated
 *  a topdec, such as files to use or make.
 *
 *  Copyright (C) 1992,1993 Harlequin Ltd
 *
 *  $Log: _action_queue.sml,v $
 * Revision 1.74  1997/03/17  15:34:33  matthew
 * Making use not use action queue
 *
 * Revision 1.73  1996/10/30  12:20:39  io
 * moving String from toplevel
 *
 * Revision 1.72  1996/08/20  14:04:08  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
 * Revision 1.71  1996/08/06  09:27:49  stephenb
 * Replace calls to OldOs.mtime in which the resulting time is
 * ignored by calls to with OS.FileSys.access.
 *
 * Revision 1.70  1996/06/24  11:45:21  daveb
 * Replaced Getenv.get_home_dir with Getenv.get_startup_filename and
 * Getenv.get_preferences_filename.
 *
 * Revision 1.69  1996/06/21  15:24:53  stephenb
 * Fix #1330 - Shell.File.loadObject doesn't look for .mo extension
 *
 * Revision 1.68  1996/05/30  13:14:19  daveb
 * The Io and Interrupt exceptions are no longer at top level.
 *
 * Revision 1.67  1996/05/23  12:14:52  stephenb
 * Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
 * now does what the former used to do.
 *
 * Revision 1.66  1996/05/21  11:11:54  stephenb
 * Change to pull in Path directly rather than OS.Path since the latter
 * now conforms to the latest basis and it is too much effort to update
 * the code to OS.Path at this point.
 *
 * Revision 1.65  1996/05/17  09:50:48  stephenb
 * Remove redundant require of "os_filesys".
 *
 * Revision 1.64  1996/05/08  12:17:52  stephenb
 * Rename filesys to be os_filesys in line with latest file naming conventions.
 *
 * Revision 1.63  1996/05/08  11:27:32  daveb
 * Added Info.options argument to ActionQueue.do_actions.
 *
 * Revision 1.62  1996/05/03  09:47:56  daveb
 * Stopped Handled exception being raised to the outside world.
 * Removed Incremental.Interrupted and ShellUtils.Error exceptions.
 *
 * Revision 1.61  1996/05/01  10:22:08  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.60  1996/04/19  14:27:53  stephenb
 * Add an OS.SysErr exception handler for any use of realPath.
 * This fixes bug 1277.
 *
 * Revision 1.59  1996/04/18  15:03:27  jont
 * initbasis moved to basis
 *
 * Revision 1.58  1996/04/12  08:38:15  stephenb
 * Rename Os -> OS to conform with latest basis revision.
 *
 * Revision 1.57  1996/04/09  18:27:03  daveb
 * Added a preferences argument to do_actions, because
 * ShellUtils.{load_source_file,load_file,use_file} now require a preferences
 * argument (for passing to process_result).
 *
 * Revision 1.56  1996/04/02  11:34:57  daveb
 * Added read_dependencies_module and read_dependencies_file.
 *
 * Revision 1.55  1996/03/27  15:17:21  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
 * Revision 1.54  1996/03/26  09:43:26  daveb
 * Replaced Module.with_source_path with Incremental.match_{source,object}_path.
 *
 * Revision 1.53  1996/03/19  12:29:17  daveb
 * Added add_check_load_module and add_check_load_file.
 *
 * Revision 1.52  1996/03/15  12:37:24  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.51  1996/02/09  17:52:51  daveb
 * UserContext.set_context_info has been deleted, replaced here with
 * UserContext.clear_debug_info.
 *
 *  Revision 1.50  1995/12/12  11:49:02  daveb
 *  Module.with_source_path now takes a string describing the action undertaken.
 *
 *  Revision 1.49  1995/12/06  18:46:31  daveb
 *  Reinstated Incremental.delete_module and Incremental.delete_all_modules.
 *
 *  Revision 1.48  1995/12/04  11:38:25  daveb
 *  Changes in InterMake, Incremental and therefore ShellUtils to use Project.
 *
 *  Revision 1.47  1995/07/28  14:01:42  matthew
 *  Fixing problem with errors during load.
 *
 *  Revision 1.46  1995/06/12  16:26:33  daveb
 *  Added function to strip spaces from beginning and end of filenames.
 *
 *  Revision 1.45  1995/06/08  09:25:30  matthew
 *  Adding touch_all function
 *
 *  Revision 1.44  1995/06/05  14:37:53  daveb
 *  ShellUtils.{make,load}_file now take a user_options argument.
 *
 *  Revision 1.43  1995/05/26  11:36:59  daveb
 *  Split user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.42  1995/04/28  17:57:11  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.41  1995/04/21  13:56:09  daveb
 *  Fixed broken handling of subuses (code was broken when I moved to
 *  the new FileSys and Path structures).
 *  Better error handling.
 *  filesys and path moved from utils to initbasis.
 *
 *  Revision 1.40  1995/04/12  13:27:18  jont
 *  Change FILESYS to FILE_SYS
 *
 *  Revision 1.39  1995/02/20  14:28:27  daveb
 *  do_actions now takes an output function argument.
 *
 *  Revision 1.38  1995/01/16  10:37:50  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *  Replaced FileName parameter with FileSys and Path.
 *
 *  Revision 1.37  1994/12/08  17:53:41  jont
 *  Move OS specific stuff into a system link directory
 *
 *  Revision 1.36  1994/08/17  14:31:54  jont
 *  Modify aux function to take directory (string) argument describing
 *  where use was from. This should allow use to deal with subuses correctly
 *
 *  Revision 1.35  1994/08/10  14:07:56  daveb
 *  Added read_dot_mlworks functions.
 *
 *  Revision 1.34  1994/06/21  16:13:54  daveb
 *  do_actions now takes a user_context instead of a Context ref.
 *  The Error exception no longer includes a Context (it was never used).
 *  THe new Error' exception takes its place internally.
 *
 *  Revision 1.33  1994/03/25  16:28:05  daveb
 *  Added new commands that distinguish modules and files.
 *
 *  Revision 1.32  1994/03/17  12:50:37  matthew
 *  Added check_make stuff
 *
 *  Revision 1.31  1994/02/25  15:41:52  daveb
 *  Adding clear_debug functionality.
 *
 *  Revision 1.30  1994/02/02  10:32:20  daveb
 *  Removed redundant FileName structure.
 *
 *  Revision 1.29  1994/01/28  16:21:12  matthew
 *  Better locations in error messages
 *
 *  Revision 1.28  1994/01/06  16:16:43  matthew
 *  Added load function -- this loads an mo
 *
 *  Revision 1.27  1993/11/26  12:14:42  matthew
 *  Remove calls to exn_message.  Changed defn. of exn_message.
 *
 *  Revision 1.26  1993/10/08  16:18:17  matthew
 *  Bug fixing
 *
 *  Revision 1.25  1993/09/06  13:55:41  jont
 *  Added add_save function
 *
 *  Revision 1.24.1.2  1993/10/08  13:14:04  matthew
 *  Added Info.Stop handlers
 *
 *  Revision 1.24.1.1  1993/08/24  17:08:39  jont
 *  Fork for bug fixing
 *
 *  Revision 1.24  1993/08/24  17:08:39  matthew
 *  Added Interrupt handlers
 *
 *  Revision 1.23  1993/08/24  12:14:23  matthew
 *  Added "Unexpected exception" message.
 *
 *  Revision 1.22  1993/08/12  16:12:48  daveb
 *  Changed type of actions to use strings (representing moduleids) instead
 *  of filenames.
 *
 *  Revision 1.21  1993/08/10  11:57:12  matthew
 *  Added missing handler for Incremental.Interrupted
 *  reraise Interrupted as Interrupt at outermost level
 *
 *  Revision 1.20  1993/07/29  15:31:59  matthew
 *  Added handler for Incremental.Interrupted exception.
 *
 *  Revision 1.19  1993/05/26  17:02:39  matthew
 *  Changes to Error handling
 *
 *  Revision 1.18  1993/05/19  10:48:33  matthew
 *  Removed "\n"'s from errors.
 *
 *  Revision 1.17  1993/05/12  16:02:52  matthew
 *  Use ShellUtils functions
 *
 *  Revision 1.16  1993/05/11  13:36:11  matthew
 *  Use ShellUtils.make_file
 *
 *  Revision 1.15  1993/05/10  13:58:40  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *
 *  Revision 1.14  1993/05/06  16:49:51  jont
 *  Added resolution of filenames beginning ~ when given to make or use
 *
 *  Revision 1.13  1993/05/06  14:01:26  matthew
 *  Changed argument to do_actions
 *
 *  Revision 1.12  1993/05/04  15:23:14  matthew
 *  Changed context ref handling.
 *
 *  Revision 1.11  1993/04/30  09:41:26  matthew
 *  Better use of generic filenames
 *
 *  Revision 1.10  1993/04/02  14:42:36  matthew
 *  Signature changes
 *
 *  Revision 1.9  1993/03/31  16:08:34  matthew
 *  Fixed the action handler to side-effect the relevant context ref
 *
 *  Revision 1.8  1993/03/29  16:36:30  matthew
 *  Removed update_options call
 *
 *  Revision 1.7  1993/03/26  18:37:05  matthew
 *  Use get_context_ref function
 *
 *
 *  Revision 1.6  1993/03/25  10:32:53  daveb
 *  do_actions now takes a single ShellData argument.  Changes to options
 *  during a use now take immediate effect.
 *
 *  Revision 1.5  1993/03/19  18:43:24  matthew
 *  Changed context parameter to be a reference, which is side-effected.
 *  do_actions now returns unit.
 *  Uses Incremental.compile_source & Incremental.add_definitions
 *  (Incremental.add_source has been removed)
 *  
 *  Revision 1.4  1993/03/18  18:43:26  matthew
 *  Changed error output to use output function.
 *  
 *  Revision 1.3  1993/03/12  11:15:28  matthew
 *  Options changes
 *  
 *  Revision 1.2  1993/03/09  15:41:43  matthew
 *  Options & Info changes
 *  
 *  Revision 1.1  1993/03/02  11:13:10  daveb
 *  Initial revision
 *  
 *
 *)

require "^.basis.__string";
require "../utils/lists";
require "../basis/os";
require "../basics/module";
require "../basics/module_id";
require "../utils/getenv";
require "../main/user_options";
require "../basis/path";
require "incremental";
require "shell_utils";
require "user_context";
require "shell_types";

require "action_queue";

functor ActionQueue (
  structure Lists : LISTS
  structure OS : OS
  structure Path : PATH
  structure UserOptions : USER_OPTIONS
  structure UserContext : USER_CONTEXT
  structure Incremental : INCREMENTAL
  structure ShellTypes : SHELL_TYPES
  structure ShellUtils : SHELL_UTILS
  structure ModuleId : MODULE_ID
  structure Module : MODULE
  structure Getenv : GETENV

  sharing Incremental.InterMake.Compiler.Info = ShellUtils.Info
  sharing UserOptions.Options = Incremental.InterMake.Compiler.Options =
          ShellUtils.Options = ShellTypes.Options

  sharing type ShellUtils.UserOptions = UserOptions.user_tool_options =
	       ShellTypes.user_options
  sharing type UserContext.user_context_options =
	       UserOptions.user_context_options
  sharing type UserContext.Context = Incremental.Context =
               ShellUtils.Context = ShellTypes.Context
  sharing type ModuleId.ModuleId = Module.ModuleId =
	       ShellUtils.ModuleId = Incremental.ModuleId
  sharing type Module.Location = ModuleId.Location =
	       ShellUtils.Info.Location.T
  sharing type ShellUtils.user_context = UserContext.user_context =
	       ShellTypes.user_context
  sharing type ShellUtils.ShellData = ShellTypes.ShellData
  sharing type ShellUtils.preferences = ShellTypes.preferences
): ACTION_QUEUE =
struct
  structure Incremental = Incremental
  structure Info = ShellUtils.Info
  structure Options = UserOptions.Options

  type Context = UserContext.Context
  type UserOptions = UserOptions.user_tool_options
  type user_context = UserContext.user_context
  type ShellData = ShellTypes.ShellData
  type preferences = ShellUtils.preferences

  exception Handled
  exception Error of string * Info.error * Info.error list

  datatype QueueEntry =
    READ_DEPENDENCIES_FILE of string |
    READ_DEPENDENCIES_MODULE of string |
    TOUCH_LOADED_FILE of string |
    TOUCH_LOADED_MODULE of string |
    TOUCH_ALL_LOADED |
    LOAD_SOURCE_FILE of string |
    LOAD_SOURCE_MODULE of string |
    CHECK_LOAD_SOURCE_FILE of string |
    CHECK_LOAD_SOURCE_MODULE of string |
    COMPILE_FILE of string |
    COMPILE_MODULE of string |
    COMPILE_AND_LOAD_FILE of string |
    COMPILE_AND_LOAD_MODULE of string |
    CHECK_COMPILE_FILE of string |
    CHECK_COMPILE_MODULE of string |
    LOAD_FILE of string |
    LOAD_MODULE of string |
    CHECK_LOAD_FILE of string |
    CHECK_LOAD_MODULE of string |
    SAVE of string |
    CLEAR_DEBUG_INFO of string |
    CLEAR_DEBUG_ALL_INFO
      
  val queue = ref [];

  fun add_read_dependencies_file (filename, options) =
    queue := READ_DEPENDENCIES_FILE filename :: !queue

  fun add_read_dependencies_module (module_name, options) =
    queue := READ_DEPENDENCIES_MODULE module_name :: !queue

  fun add_load_source_file (filename, options) =
    queue := LOAD_SOURCE_FILE filename :: !queue

  fun add_load_source_module (module_name, options) =
    queue := LOAD_SOURCE_MODULE module_name :: !queue

  fun add_check_load_source_file (filename, options) =
    queue := CHECK_LOAD_SOURCE_FILE filename :: !queue

  fun add_check_load_source_module (module_name, options) =
    queue := CHECK_LOAD_SOURCE_MODULE module_name :: !queue

  fun add_compile_file (filename, options) =
    queue := COMPILE_FILE filename :: !queue

  fun add_compile_and_load_file (filename, options) =
    queue := COMPILE_AND_LOAD_FILE filename :: !queue

  fun add_check_compile_file (filename, options) =
    queue := CHECK_COMPILE_FILE filename :: !queue

  fun add_load_file (filename,options) =
    queue := LOAD_FILE filename :: !queue

  fun add_load_module (module_name,options) =
    queue := LOAD_MODULE module_name :: !queue

  fun add_check_load_file (filename,options) =
    queue := CHECK_LOAD_FILE filename :: !queue

  fun add_check_load_module (module_name,options) =
    queue := CHECK_LOAD_MODULE module_name :: !queue

  fun add_touch_loaded_file (filename, options) =
    queue := TOUCH_LOADED_FILE filename :: !queue

  fun add_touch_loaded_module (module_name, options) =
    queue := TOUCH_LOADED_MODULE module_name :: !queue

  fun add_touch_all_loaded (options) =
    queue := TOUCH_ALL_LOADED :: !queue

  fun add_compile_module (module_name, options) =
    queue := COMPILE_MODULE module_name :: !queue

  fun add_compile_and_load_module (module_name, options) =
    queue := COMPILE_AND_LOAD_MODULE module_name :: !queue

  fun add_check_compile_module (module_name, options) =
    queue := CHECK_COMPILE_MODULE module_name :: !queue

  fun add_save (module_name, options) =
    queue := SAVE module_name :: !queue

  fun add_clear_debug name =
    queue := CLEAR_DEBUG_INFO name :: !queue

  fun add_clear_debug_all () =
    queue := CLEAR_DEBUG_ALL_INFO :: !queue


  fun trim_spaces s =
    let
      val space = ord #" "
      fun loopl i =
	if MLWorks.String.ordof (s, i) = space then
	  loopl (i+1)
	else
	  i
      
      fun loopr i =
	if MLWorks.String.ordof (s, i) = space then
	  loopr (i-1)
	else
	  i
      
      val (start, finish) = (loopl 0, loopr (size s - 1))
      handle MLWorks.String.Substring => (0, size s - 1) (* This handle is bogus and should be removed *)
    in
      substring (* could raise Substring *) (s, start, finish - start + 1)
    end

  fun clear_queue () = queue := []

  fun do_actions
	{user_context, user_options, error_info, preferences,
	 debugger, output_fn, monitor_fn} =
    let
      fun aux () =
        let
          val toplevel_name = ShellTypes.get_current_toplevel_name()

          fun do_action (CLEAR_DEBUG_INFO name) =
	    UserContext.clear_debug_info (user_context, name)
          |   do_action CLEAR_DEBUG_ALL_INFO =
	    UserContext.clear_debug_all_info user_context
          |   do_action (READ_DEPENDENCIES_FILE filename) =
	    let
	      val trimmed_name = trim_spaces filename
	    in
	      Incremental.match_source_path
 	        (Incremental.read_dependencies toplevel_name,
		 error_info,
		 Info.Location.FILE toplevel_name, trimmed_name,
		 "read dependencies")
	    end
          |   do_action (READ_DEPENDENCIES_MODULE module_name) =
	    let
	      val module_id = 
		ModuleId.from_string
		  (module_name, Info.Location.FILE toplevel_name)
	    in
	      Incremental.read_dependencies
		toplevel_name
                error_info
 		module_id
	    end
          |   do_action (TOUCH_LOADED_FILE filename) =
	    let
	      val trimmed_name = trim_spaces filename
	    in
	      Incremental.match_source_path
 	        (Incremental.delete_module,
		 error_info,
		 Info.Location.FILE toplevel_name, trimmed_name,
		 "touching loaded")
	    end
          |   do_action (TOUCH_LOADED_MODULE module_name) =
	    let
	      val module_id = 
		ModuleId.from_string
		  (module_name, Info.Location.FILE toplevel_name)
	    in
 	      Incremental.delete_module
		error_info
		module_id
	    end
          |   do_action (TOUCH_ALL_LOADED) =
 	    Incremental.delete_all_modules true
          |   do_action (LOAD_SOURCE_FILE filename) =
            (Incremental.match_source_path
	      (ShellUtils.load_source_file
                 (user_context,
                  toplevel_name,
                  ShellTypes.new_options (user_options, user_context),
		  user_options,
                  preferences,
		  debugger,
                  output_fn),
		error_info,
		Info.Location.FILE toplevel_name,
		trim_spaces filename,
		"loading source for")
             handle 
               MLWorks.Interrupt => raise Handled
             | Info.Stop (e,el) =>
		 raise Error ("Error loading from source of " ^ filename,e,el)
             | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (LOAD_SOURCE_MODULE module_name) =
	    (let val module_id = 
		   ModuleId.from_string
		     (module_name, Info.Location.FILE toplevel_name)
	     in
               ShellUtils.load_source_file
                 (user_context,
                  toplevel_name,
                  ShellTypes.new_options (user_options, user_context),
		  user_options,
                  preferences,
		  debugger,
                  output_fn)
		 error_info
	         module_id
	     end
             handle 
               MLWorks.Interrupt => raise Handled
             | Info.Stop (e,el) =>
		 raise
		   Error ("Error loading from source of " ^ module_name,e,el)
             | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (CHECK_LOAD_SOURCE_FILE filename) =
	    (Incremental.match_source_path
              (ShellUtils.check_load_source_file
                 (UserContext.get_context user_context,
                  toplevel_name,
                  ShellTypes.new_options (user_options, user_context),
                  debugger,
                  output_fn),
	       error_info,
	       Info.Location.FILE toplevel_name,
	       trim_spaces filename,
	       "checking dependencies")
            handle 
              MLWorks.Interrupt => raise Handled
            | Info.Stop (e,el) =>
		raise Error
		  ("Error checking make dependencies for " ^ filename,e,el)
            | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (CHECK_LOAD_SOURCE_MODULE module_name) =
            (let val module_id =
                  ModuleId.from_string
                    (module_name, Info.Location.FILE toplevel_name)
            in
              ShellUtils.check_load_source_file
                (UserContext.get_context user_context,
                 toplevel_name,
                 ShellTypes.new_options (user_options, user_context),
                 debugger,
                 output_fn)
		error_info
	        module_id
	    end
            handle
              MLWorks.Interrupt => raise Handled
            | Info.Stop (e,el) =>
		raise Error
		  ("Error checking make dependencies for " ^ module_name,e,el)
            | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (COMPILE_FILE filename) =
            (Incremental.match_source_path
	      (ShellUtils.compile_file
                 (toplevel_name,
		  ShellTypes.new_options (user_options, user_context),
                  output_fn),
		error_info,
		Info.Location.FILE toplevel_name,
		trim_spaces filename,
		"compiling")
             handle
               MLWorks.Interrupt => raise Handled
             | Info.Stop (e,el) =>
		 raise Error ("Error loading " ^ filename,e,el)
             | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (COMPILE_MODULE module_name) =
	    (let val module_id = 
		   ModuleId.from_string
		     (module_name, Info.Location.FILE toplevel_name)
	     in
               ShellUtils.compile_file
                 (toplevel_name,
		  ShellTypes.new_options (user_options, user_context),
                  output_fn)
		 error_info
	         module_id
	     end
             handle
               MLWorks.Interrupt => raise Handled
             | Info.Stop (e,el) =>
		 raise Error ("Error loading " ^ module_name,e,el)
             | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (CHECK_COMPILE_FILE filename) =
	    (Incremental.match_source_path
              (ShellUtils.check_compile_file
                 (toplevel_name,
		  ShellTypes.new_options (user_options, user_context),
                  output_fn),
	       error_info,
	       Info.Location.FILE toplevel_name,
	       trim_spaces filename,
	       "checking dependencies of")
            handle 
              MLWorks.Interrupt => raise Handled
            | Info.Stop (e,el) =>
		raise Error
		  ("Error checking make dependencies for " ^ filename,e,el)
            | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (CHECK_COMPILE_MODULE module_name) =
            (let val module_id =
                  ModuleId.from_string
                    (module_name, Info.Location.FILE toplevel_name)
            in
              ShellUtils.check_compile_file
                (toplevel_name,
		 ShellTypes.new_options (user_options, user_context),
                 output_fn)
		error_info
	        module_id
	    end
            handle 
              MLWorks.Interrupt => raise Handled
            | Info.Stop (e,el) =>
		raise Error
		  ("Error checking make dependencies for " ^ module_name,e,el)
            | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (LOAD_FILE filename) =
               (Incremental.match_object_path
                  (ShellUtils.load_file
                    (user_context, toplevel_name,
                     ShellTypes.new_options (user_options, user_context),
                     preferences, output_fn),
                  error_info,
                  Info.Location.FILE toplevel_name,
                  trim_spaces filename)
                handle
                  MLWorks.Interrupt => raise Handled
                | Info.Stop (e,el) =>
		    raise Error ("Error loading " ^ filename,e,el)
                | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (LOAD_MODULE module_name) =
              (let 
                val module_id =
                  ModuleId.from_string
                  (module_name, Info.Location.FILE toplevel_name)
              in
                ShellUtils.load_file
                  (user_context, toplevel_name,
                   ShellTypes.new_options (user_options, user_context),
                   preferences, output_fn)
		  error_info
                  module_id
              end
            handle
              MLWorks.Interrupt => raise Handled
            | Info.Stop (e,el) =>
		raise Error ("Error loading " ^ module_name,e,el)
            | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (CHECK_LOAD_FILE filename) =
	      (Incremental.match_object_path
                 (ShellUtils.check_load_file
                    (toplevel_name, output_fn),
		  error_info,
	          Info.Location.FILE toplevel_name,
	          trim_spaces filename)
               handle
                 MLWorks.Interrupt => raise Handled
               | Info.Stop (e,el) =>
		   raise Error
		     ("Error checking make dependencies for " ^ filename,e,el)
               | ShellTypes.DebuggerTrapped => raise Handled)

          |   do_action (CHECK_LOAD_MODULE module_name) =
            (let val module_id =
                  ModuleId.from_string
                    (module_name, Info.Location.FILE toplevel_name)
            in
              ShellUtils.check_load_file
                (toplevel_name, output_fn)
	        error_info
		module_id
	    end
            handle
              MLWorks.Interrupt => raise Handled
            | Info.Stop (e,el) =>
		raise Error
		  ("Error checking make dependencies for " ^ module_name,e,el)
            | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (COMPILE_AND_LOAD_FILE filename) =
            (Incremental.match_source_path
	       (fn opts => fn mod_id =>
		  (ShellUtils.compile_file
                     (toplevel_name,
		      ShellTypes.new_options (user_options, user_context),
                      output_fn)
		     opts
		     mod_id;
                   ShellUtils.load_file
                     (user_context, toplevel_name,
                      ShellTypes.new_options (user_options, user_context),
                      preferences, output_fn)
		     opts
		     mod_id),
		 error_info,
		 Info.Location.FILE toplevel_name,
		 trim_spaces filename,
		 "compiling")
             handle
               MLWorks.Interrupt => raise Handled
             | Info.Stop (e,el) =>
	         raise
		   Error
		     ("Error during compile and load of " ^ filename, e, el)
             | ShellTypes.DebuggerTrapped => raise Handled)
          |   do_action (COMPILE_AND_LOAD_MODULE module_name) =
	    (let val module_id = 
		   ModuleId.from_string
		     (module_name, Info.Location.FILE toplevel_name)
	     in
               ShellUtils.compile_file
                 (toplevel_name,
		  ShellTypes.new_options (user_options, user_context),
                  output_fn)
		 error_info
	         module_id;
               ShellUtils.load_file
                 (user_context, toplevel_name,
                  ShellTypes.new_options (user_options, user_context),
                  preferences, output_fn)
		 error_info
                 module_id
	     end
             handle
               MLWorks.Interrupt => raise Handled
             | Info.Stop (e,el) =>
		 raise
		   Error
		     ("Error during compile and load of " ^ module_name, e, el)
             | ShellTypes.DebuggerTrapped => raise Handled)
	  |   do_action (SAVE module_name) =
	    ()
	    (*
            (ShellUtils.save_file
             (trim_spaces filename,
              UserContext.get_context user_context,
              toplevel_name,
              monitor_fn,
              ShellTypes.new_options (user_options, user_context),
              debugger,
              output_fn)
             handle
               MLWorks.Interrupt => raise Handled
             | Info.Stop (e,el) =>
	         raise Error' ("Error saving " ^ module_name,e,el)
             | ShellTypes.DebuggerTrapped => raise Handled)
	   *)
          val actions = rev (!queue)
        in
          queue := [];
          app do_action actions
	end
      in
        (* this probably should be more intelligent about possible
	   concurrent updates *)
        aux ()
        handle
	  Handled => ()
        | exn as MLWorks.IO.Io s =>
	   (print("Exception Io of " ^ s ^ "\n");
	    raise exn)
    end

end
@


1.75.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a6 4
 * Revision 1.75  1997/05/19  10:40:08  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.75.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a6 4
 * Revision 1.75  1997/05/19  10:40:08  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.74
log
@Making use not use action queue
@
text
@d7 3
d786 1
a786 1
	   (MLWorks.IO.output(MLWorks.IO.std_out,"Exception Io of " ^ s ^ "\n");
@


1.74.1.1
log
@branched from 1.74
@
text
@a6 3
 * Revision 1.74  1997/03/17  15:34:33  matthew
 * Making use not use action queue
 *
@


1.74.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a6 3
 * Revision 1.74.1.1  1997/05/12  10:34:06  hope
 * branched from 1.74
 *
@


1.74.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a6 3
 * Revision 1.74.1.1  1997/05/12  10:34:06  hope
 * branched from 1.74
 *
@


1.74.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a6 3
 * Revision 1.74.1.1  1997/05/12  10:34:06  hope
 * branched from 1.74
 *
@


1.74.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a6 3
 * Revision 1.74.1.1.1.1  1997/07/28  18:19:09  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.73
log
@moving String from toplevel
@
text
@d7 3
d308 1
a345 1
    USE of string |
a350 3
  fun add_use (filename,options) =
    queue := USE filename :: !queue

d438 3
a440 1
      
d445 1
a445 1
      fun aux pathname level =
a447 1
          val actions = rev (!queue)
d771 1
a771 36
          |   do_action (USE filename) =
	   ((let
	       val expanded_path = OS.FileSys.fullPath pathname
	       val expanded_file = Getenv.expand_home_dir (trim_spaces filename)
	       val new_name =
		 Path.mkCanonical
		   (Path.mkAbsolute (expanded_file, expanded_path))
	     in
	       ShellUtils.use_file
	         {filename = new_name,
		  user_context = user_context,
		  error_info = error_info,
		  toplevel_name = toplevel_name,
		  user_options = user_options,
		  preferences = preferences,
		  debugger = debugger,
		  output_fn = output_fn,
		  level = level,
		  queue_function = aux (Path.dir new_name)}
	     end
	     handle
               Getenv.BadHomeName s =>
                 Info.default_error'
                   (Info.FATAL, Info.Location.FILE toplevel_name,
		    "Invalid home name: " ^ s)
             | OS.SysErr _ => 
                 Info.default_error'
                   (Info.FATAL, Info.Location.FILE toplevel_name,
		    "No such file: `" ^ filename ^ "'")
	     | MLWorks.Interrupt => raise Handled
	     | ShellTypes.DebuggerTrapped => raise Handled)
	    handle
	      (* This handler catches exceptions raised by the calls to
		 Info.default_error' in the inner handler, as well as 
		 cases when ShellUtils.use_file raises Info.Stop. *)
              Info.Stop (e,el) => raise Error ("Error using " ^ filename,e,el))
d779 1
a779 1
        (aux "." 0)
a785 31

    fun read_dot_mlworks shell_data =
      let
	val ShellTypes.SHELL_DATA{debugger,...} = shell_data

        fun output_fn s = MLWorks.IO.output (MLWorks.IO.messages, s);

        fun do_use filename =
          (add_use filename;
           do_actions
             {user_context = ShellTypes.get_user_context shell_data,
              user_options = ShellTypes.get_user_options shell_data,
	      preferences = ShellTypes.get_current_preferences shell_data,
	      error_info = Info.make_default_options (),
              debugger = debugger,
	      output_fn = output_fn,
              monitor_fn = fn s => output_fn ("Reading .mlworks: " ^ s)}
           handle
             Error (s,_,_) => output_fn (s ^ "\n")
           | Handled => ())
      in
        case Getenv.get_startup_filename () of
          NONE => ()
        | SOME pathname =>
            if OS.FileSys.access (pathname, []) handle OS.SysErr _ => false then
              ShellTypes.with_shell_data
                shell_data
                (fn () => do_use (pathname, Info.make_default_options ()))
            else
              ()
      end
@


1.73.4.1
log
@branched from 1.73
@
text
@a6 3
 * Revision 1.73  1996/10/30  12:20:39  io
 * moving String from toplevel
 *
@


1.73.3.1
log
@branched from 1.73
@
text
@a6 3
 * Revision 1.73  1996/10/30  12:20:39  io
 * moving String from toplevel
 *
@


1.73.3.1.1.1
log
@branched from 1.73.3.1
@
text
@a6 3
 * Revision 1.73.3.1  1996/12/17  17:47:38  hope
 * branched from 1.73
 *
@


1.73.2.1
log
@branched from 1.73
@
text
@a6 3
 * Revision 1.73  1996/10/30  12:20:39  io
 * moving String from toplevel
 *
@


1.73.1.1
log
@branched from 1.73
@
text
@a6 3
 * Revision 1.73  1996/10/30  12:20:39  io
 * moving String from toplevel
 *
@


1.73.1.1.1.1
log
@branched from 1.73.1.1
@
text
@a6 3
 * Revision 1.73.1.1  1996/11/14  12:49:20  hope
 * branched from 1.73
 *
@


1.72
log
@[Bug #1480]
Implemented compile-and-load properly.
@
text
@d7 4
d261 1
d420 1
a420 2
      val space = String.ord " "

d422 1
a422 1
	if String.ordof (s, i) = space then
d428 1
a428 1
	if String.ordof (s, i) = space then
d434 1
a434 1
      handle String.Substring => (0, size s - 1)
d436 1
a436 1
      String.substring (s, start, finish - start + 1)
a438 2


d808 1
a808 1
          Lists.iterate do_action actions
d842 2
a843 2
          MLWorks.Option.NONE => ()
        | MLWorks.Option.SOME pathname =>
@


1.72.3.1
log
@branched from 1.72
@
text
@a6 4
 * Revision 1.72  1996/08/20  14:04:08  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
@


1.72.2.1
log
@branched from 1.72
@
text
@a6 4
 * Revision 1.72  1996/08/20  14:04:08  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
@


1.72.1.1
log
@branched from 1.72
@
text
@a6 4
 * Revision 1.72  1996/08/20  14:04:08  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
@


1.71
log
@Replace calls to OldOs.mtime in which the resulting time is
ignored by calls to with OS.FileSys.access.
@
text
@d7 4
d328 2
d367 3
d397 3
d510 1
a510 1
		 raise Error ("Error making " ^ filename,e,el)
d531 2
a532 1
		 raise Error ("Error making " ^ module_name,e,el)
d584 2
a585 1
             | Info.Stop (e,el) => raise Error ("Error making " ^ filename,e,el)
d602 1
a602 1
		 raise Error ("Error making " ^ module_name,e,el)
d658 6
a663 6
                 ShellUtils.load_file
                 (user_context, toplevel_name,
                  ShellTypes.new_options (user_options, user_context),
                  preferences, output_fn)
		 error_info
                 module_id
d700 51
@


1.70
log
@Replaced Getenv.get_home_dir with Getenv.get_startup_filename and
Getenv.get_preferences_filename.
@
text
@d7 4
a257 1
require "../make/old_os";
a277 1
  structure OldOs : OLD_OS
d777 1
a777 3
            case OldOs.mtime pathname of
              OldOs.NOT_EXIST => ()
            | OldOs.EXISTS _ =>
d781 2
@


1.69
log
@Fix #1330 - Shell.File.loadObject doesn't look for .mo extension
@
text
@d7 3
d772 3
a774 7
        case Getenv.get_home_dir () of
          MLWorks.Option.NONE =>
          (output_fn
             "Warning, no HOME variable set -- can't read .mlworks file\n")
        | MLWorks.Option.SOME dir =>
          let val pathname = dir ^ "/.mlworks"
          in
a780 1
          end
@


1.68
log
@The Io and Interrupt exceptions are no longer at top level.
@
text
@d7 3
a419 19
  (* Return the realPath associated with *fileName*.
   * Reports a fatal error if the realPath cannot be determined
   * indicating that the error occured when reading the file with 
   * *enclosingFileName*.
   *)
  fun expandFileNameIn (enclosingFileName, fileName) =
    let
      val expandedFileName = Getenv.expand_home_dir (trim_spaces fileName)
    in
      OS.FileSys.fullPath expandedFileName
      handle OS.SysErr _ => 
        let
          val location = Info.Location.FILE enclosingFileName
        in
          Info.default_error' (Info.FATAL, location, "No such file: `" ^ fileName ^ "'")
        end
    end


d627 1
a627 1
                  expandFileNameIn (toplevel_name, filename))
d657 1
a657 1
	          expandFileNameIn (toplevel_name, filename))
@


1.67
log
@Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
now does what the former used to do.
@
text
@d7 4
d507 1
a507 1
               Interrupt => raise Handled
d528 1
a528 1
               Interrupt => raise Handled
d545 1
a545 1
              Interrupt => raise Handled
d565 1
a565 1
              Interrupt => raise Handled
d581 1
a581 1
               Interrupt => raise Handled
d597 1
a597 1
               Interrupt => raise Handled
d612 1
a612 1
              Interrupt => raise Handled
d630 1
a630 1
              Interrupt => raise Handled
d645 1
a645 1
                  Interrupt => raise Handled
d663 1
a663 1
              Interrupt => raise Handled
d675 1
a675 1
                 Interrupt => raise Handled
d692 1
a692 1
              Interrupt => raise Handled
d709 1
a709 1
               Interrupt => raise Handled
d743 1
a743 1
	     | Interrupt => raise Handled
d760 1
a760 1
        | exn as Io s =>
@


1.66
log
@Change to pull in Path directly rather than OS.Path since the latter
now conforms to the latest basis and it is too much effort to update
the code to OS.Path at this point.
@
text
@d7 5
d422 1
a422 1
      OS.FileSys.realPath expandedFileName
d712 1
a712 1
	       val expanded_path = OS.FileSys.realPath pathname
@


1.65
log
@Remove redundant require of "os_filesys".
@
text
@d7 3
d252 1
d710 2
a711 2
		 OS.Path.mkCanonical
		   (OS.Path.mkAbsolute (expanded_file, expanded_path))
d723 1
a723 1
		  queue_function = aux (OS.Path.dir new_name)}
@


1.64
log
@Rename filesys to be os_filesys in line with latest file naming conventions.
@
text
@d7 3
a237 1
require "../basis/os_filesys";
@


1.63
log
@Added Info.options argument to ActionQueue.do_actions.
@
text
@d7 3
d235 1
a235 1
require "../basis/filesys";
@


1.62
log
@Stopped Handled exception being raised to the outside world.
Removed Incremental.Interrupted and ShellUtils.Error exceptions.
@
text
@d7 4
d419 1
a419 1
	{user_context, user_options, preferences,
d437 1
a437 1
		 Info.make_default_options (),
d449 1
a449 1
                (Info.make_default_options ())
d458 1
a458 1
		 Info.make_default_options (),
d469 1
a469 1
		(Info.make_default_options ())
d484 1
a484 1
		Info.make_default_options (),
d506 1
a506 1
		 (Info.make_default_options ())
d522 1
a522 1
	       Info.make_default_options (),
d543 1
a543 1
		(Info.make_default_options ())
d558 1
a558 1
		Info.make_default_options (),
d575 1
a575 1
		 (Info.make_default_options ())
d589 1
a589 1
	       Info.make_default_options (),
d608 1
a608 1
		(Info.make_default_options ())
d623 1
a623 1
                  Info.make_default_options (),
d641 1
a641 1
		 (Info.make_default_options ())
d653 1
a653 1
		  Info.make_default_options (),
d670 1
a670 1
	        (Info.make_default_options ())
d705 10
a714 3
	         (new_name, user_context, toplevel_name, user_options,
		  preferences, debugger, output_fn, level,
		  aux (OS.Path.dir new_name))
d759 1
@


1.61
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d7 6
a280 5
  exception Error' of
    string * (* Incremental.InterMake.modules * *) Info.error * Info.error list
  (* Error' is an internal form of Error.  The modules are used to update
     the module tables in the user_context before raising the exception
     to the outside world. *)
d484 5
a488 5
             handle exn as ShellUtils.Error ((* c, *) e,el) =>
               raise Error' ("Error making " ^ filename, (* c, *) e,el)
                  | Interrupt => raise Handled
                  | Info.Stop (e,el) => raise Error ("Error making " ^ filename,e,el)
                  | ShellTypes.DebuggerTrapped => raise Handled)
d505 5
a509 8
             handle exn as ShellUtils.Error ((* c, *) e,el) =>
               raise Error' ("Error making " ^ module_name, (* c, *) e,el)
		  (*
                  | exn as Incremental.Interrupted _ => raise exn
		  *)
                  | Interrupt => raise Handled
                  | Info.Stop (e,el) => raise Error ("Error making " ^ module_name,e,el)
                  | ShellTypes.DebuggerTrapped => raise Handled)
d522 6
a527 7
            handle exn as ShellUtils.Error ((* c, *) e,el) =>
              raise Error'
		      ("Error checking make dependencies for " ^ filename,
		       (* c, *) e,el)
                 | Interrupt => raise Handled
                 | Info.Stop (e,el) => raise Error ("Error checking make dependencies for " ^ filename,e,el)
                 | ShellTypes.DebuggerTrapped => raise Handled)
d542 6
a547 10
            handle exn as ShellUtils.Error ((* c, *) e,el) =>
              raise Error'
		      ("Error checking make dependencies for " ^ module_name,
		       (* c, *) e,el)
		 (*
                 | exn as Incremental.Interrupted _ => raise exn
		 *)
                 | Interrupt => raise Handled
                 | Info.Stop (e,el) => raise Error ("Error checking make dependencies for " ^ module_name,e,el)
                 | ShellTypes.DebuggerTrapped => raise Handled)
d558 4
a561 5
             handle exn as ShellUtils.Error ((* c, *) e,el) =>
               raise Error' ("Error making " ^ filename, (* c, *) e,el)
                  | Interrupt => raise Handled
                  | Info.Stop (e,el) => raise Error ("Error making " ^ filename,e,el)
                  | ShellTypes.DebuggerTrapped => raise Handled)
d574 5
a578 8
             handle exn as ShellUtils.Error ((* c, *) e,el) =>
               raise Error' ("Error making " ^ module_name, (* c, *) e,el)
		  (*
                  | exn as Incremental.Interrupted _ => raise exn
		  *)
                  | Interrupt => raise Handled
                  | Info.Stop (e,el) => raise Error ("Error making " ^ module_name,e,el)
                  | ShellTypes.DebuggerTrapped => raise Handled)
d589 6
a594 7
            handle exn as ShellUtils.Error ((* c, *) e,el) =>
              raise Error'
		      ("Error checking make dependencies for " ^ filename,
		       (* c, *) e,el)
                 | Interrupt => raise Handled
                 | Info.Stop (e,el) => raise Error ("Error checking make dependencies for " ^ filename,e,el)
                 | ShellTypes.DebuggerTrapped => raise Handled)
d607 6
a612 10
            handle exn as ShellUtils.Error ((* c, *) e,el) =>
              raise Error'
		      ("Error checking make dependencies for " ^ module_name,
		       (* c, *) e,el)
		 (*
                 | exn as Incremental.Interrupted _ => raise exn
		 *)
                 | Interrupt => raise Handled
                 | Info.Stop (e,el) => raise Error ("Error checking make dependencies for " ^ module_name,e,el)
                 | ShellTypes.DebuggerTrapped => raise Handled)
d623 4
a626 5
                    exn as ShellUtils.Error (e,el) =>
                      raise Error' ("Error loading " ^ filename,e,el)
                  | Interrupt => raise Handled
                  | Info.Stop (e,el) => raise Error ("Error loading " ^ filename,e,el)
                  | ShellTypes.DebuggerTrapped => raise Handled)
d640 5
a644 5
            handle exn as ShellUtils.Error (e,el) =>
              raise Error' ("Error loading " ^ module_name,e,el)
                 | Interrupt => raise Handled
                  | Info.Stop (e,el) => raise Error ("Error loading " ^ module_name,e,el)
                 | ShellTypes.DebuggerTrapped => raise Handled)
d653 5
a657 7
                  exn as ShellUtils.Error ((* c, *) e,el) =>
                    raise Error'
		      ("Error checking make dependencies for " ^ filename,
		       (* c, *) e,el)
                 | Interrupt => raise Handled
                 | Info.Stop (e,el) => raise Error ("Error checking make dependencies for " ^ filename,e,el)
                 | ShellTypes.DebuggerTrapped => raise Handled)
d669 6
a674 10
            handle exn as ShellUtils.Error ((* c, *) e,el) =>
              raise Error'
		      ("Error checking make dependencies for " ^ module_name,
		       (* c, *) e,el)
		 (*
                 | exn as Incremental.Interrupted _ => raise exn
		 *)
                 | Interrupt => raise Handled
                 | Info.Stop (e,el) => raise Error ("Error checking make dependencies for " ^ module_name,e,el)
                 | ShellTypes.DebuggerTrapped => raise Handled)
d686 5
a690 6
             handle (* exn as ShellUtils.Error ((*c,*)e,el) =>
               raise Error' ("Error saving " ^ filename,(*c,*)e,el)
                  | *) Interrupt => raise Handled
                  | Info.Stop (e,el) =>
	       raise Error' ("Error saving " ^ module_name,e,el)
                  | ShellTypes.DebuggerTrapped => raise Handled)
d693 1
a693 1
	    (let
d706 4
a709 8
	       exn as ShellUtils.Error ((* c, *) e,el) =>
		  raise Error' ("Error using " ^ filename, (* c, *) e,el)
             | Getenv.BadHomeName s =>
                 (Info.default_error'
                    (Info.FATAL, Info.Location.FILE toplevel_name,
		     "Invalid home name: " ^ s)
                    handle
                    Info.Stop (e,el) => raise Error ("Error using " ^ filename,e,el))
d711 3
a713 5
                 (Info.default_error'
                    (Info.FATAL, Info.Location.FILE toplevel_name,
		     "No such file: `" ^ filename ^ "'")
                    handle
                    Info.Stop (e,el) => raise Error ("Error using " ^ filename,e,el))
a714 1
             | Info.Stop (e,el) => raise Error ("Error using " ^ filename,e,el)
d716 5
d726 2
a727 1
        (* this probably should be more intelligent about possible concurrent updates *)
d730 1
a730 6
	  Error' (s, (* modules, *) e,l) =>
	  (*
          (update_modules (user_context, modules);
           raise Error (s,e,l))
	   *)
           raise Error (s,e,l)
d732 2
a733 7
	  (MLWorks.IO.output(MLWorks.IO.std_out,"Exception Io of " ^ s ^ "\n");raise exn)
	(*
        | Incremental.Interrupted (modules) =>
          (update_modules (user_context, modules);
           (* reraise as Interrupt *)
           raise Interrupt)
	   *)
@


1.60
log
@Add an OS.SysErr exception handler for any use of realPath.
This fixes bug 1277.
@
text
@d7 4
d372 1
a372 1
      val space = ord " "
d762 1
a762 1
	  (output(std_out,"Exception Io of " ^ s ^ "\n");raise exn)
d775 1
a775 1
        fun output_fn s = output (MLWorks.IO.messages, s);
@


1.59
log
@initbasis moved to basis
@
text
@d7 3
d389 20
d626 2
a627 7
	    (let
	       val expanded_file = Getenv.expand_home_dir (trim_spaces filename)
	       val expanded_path = OS.FileSys.realPath expanded_file
                    (* XXXEXCEPTION: should handle OS.SysErr *)
	     in
               Incremental.match_object_path
                 (ShellUtils.load_file
d631 1
a631 1
		  Info.make_default_options (),
d633 4
a636 4
	          expanded_path)
	     end
             handle exn as ShellUtils.Error (e,el) =>
                  raise Error' ("Error loading " ^ filename,e,el)
d659 1
a659 6
	    (let
	       val expanded_file = Getenv.expand_home_dir (trim_spaces filename)
	       val expanded_path = OS.FileSys.realPath expanded_file
                    (* XXXEXCEPTION: should handle OS.SysErr *)
	     in
	       Incremental.match_object_path
d664 4
a667 4
	          expanded_path)
	     end
             handle exn as ShellUtils.Error ((* c, *) e,el) =>
              raise Error'
d670 4
a673 3
                  | Interrupt => raise Handled
                  | Info.Stop (e,el) => raise Error ("Error checking make dependencies for " ^ filename,e,el)
                  | ShellTypes.DebuggerTrapped => raise Handled)
a714 1
                    (* XXXEXCEPTION: should handle OS.SysErr *)
d732 6
@


1.58
log
@Rename Os -> OS to conform with latest basis revision.
@
text
@d7 3
d209 1
a209 1
require "../initbasis/os";
d215 2
a216 2
require "../initbasis/filesys";
require "../initbasis/path";
@


1.57
log
@Added a preferences argument to do_actions, because
ShellUtils.{load_source_file,load_file,use_file} now require a preferences
argument (for passing to process_result).
@
text
@d7 5
d223 1
a223 1
  structure Os : OS
d602 2
a603 1
	       val expanded_path = Os.FileSys.realPath expanded_file
d640 2
a641 1
	       val expanded_path = Os.FileSys.realPath expanded_file
d697 2
a698 1
	       val expanded_path = Os.FileSys.realPath pathname
d701 2
a702 2
		 Os.Path.mkCanonical
		   (Os.Path.mkAbsolute (expanded_file, expanded_path))
d707 1
a707 1
		  aux (Os.Path.dir new_name))
@


1.56
log
@Added read_dependencies_module and read_dependencies_file.
@
text
@d7 3
d245 1
d256 1
d378 3
a380 1
  fun do_actions (user_context, user_options, debugger, output_fn, monitor_fn) =
d441 2
a442 1
                  debugger,
d463 2
a464 1
                  debugger,
d603 1
a603 1
                     output_fn),
d622 1
a622 1
                  output_fn)
d698 2
a699 1
		  debugger, output_fn, level, aux (Os.Path.dir new_name))
d746 6
a751 5
             (ShellTypes.get_user_context shell_data,
              ShellTypes.get_user_options shell_data,
              debugger,
	      output_fn,
              fn s => output_fn ("Reading .mlworks: " ^ s))
@


1.55
log
@Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
the deprecated OS interface.
@
text
@d7 4
d262 2
d289 6
d384 21
@


1.54
log
@Replaced Module.with_source_path with Incremental.match_{source,object}_path.
@
text
@d7 3
d194 1
d198 1
a198 1
require "../make/os";
d211 1
a211 2
  structure FileSys : FILE_SYS
  structure Path : PATH
d219 1
a219 1
  structure Os : OS
d555 1
a555 1
	       val expanded_path = FileSys.realPath expanded_file
d592 1
a592 1
	       val expanded_path = FileSys.realPath expanded_file
d648 1
a648 1
	       val expanded_path = FileSys.realPath pathname
d651 2
a652 2
		 Path.mkCanonical
		   (Path.mkAbsolute (expanded_file, expanded_path))
d656 1
a656 1
		  debugger, output_fn, level, aux (Path.dir new_name))
d719 3
a721 3
            case Os.mtime pathname of
              Os.NOT_EXIST => ()
            | Os.EXISTS _ =>
@


1.53
log
@Added add_check_load_module and add_check_load_file.
@
text
@d7 3
d373 1
a373 1
	      Module.with_source_path
d375 1
d385 3
a387 1
 	      Incremental.delete_module module_id
d392 1
a392 1
            (Module.with_source_path
d400 1
d421 1
d433 1
a433 1
	    (Module.with_source_path
d440 1
d462 1
d476 1
a476 1
            (Module.with_source_path
d481 1
d499 1
d511 1
a511 1
	    (Module.with_source_path
d516 1
d536 1
d550 18
a567 13
              (Module.with_source_path
               (ShellUtils.load_file
                (user_context, toplevel_name,
                 ShellTypes.new_options (user_options, user_context),
                 output_fn),
                Info.Location.FILE toplevel_name,
		trim_spaces filename,
		"loading")
               handle exn as ShellUtils.Error (e,el) =>
                 raise Error' ("Error loading " ^ filename,e,el)
                    | Interrupt => raise Handled
                    | Info.Stop (e,el) => raise Error ("Error loading " ^ filename,e,el)
                    | ShellTypes.DebuggerTrapped => raise Handled)
d578 1
d587 12
a598 7
	    (Module.with_source_path
              (ShellUtils.check_load_file
                 (toplevel_name, output_fn),
	       Info.Location.FILE toplevel_name,
	       trim_spaces filename,
	       "checking dependencies")
            handle exn as ShellUtils.Error ((* c, *) e,el) =>
d602 3
a604 3
                 | Interrupt => raise Handled
                 | Info.Stop (e,el) => raise Error ("Error checking make dependencies for " ^ filename,e,el)
                 | ShellTypes.DebuggerTrapped => raise Handled)
d612 2
a613 1
	        module_id
@


1.52
log
@Fixed use of Info.default_options.
@
text
@d7 3
d265 2
d301 6
d540 1
a540 1
                 user_options, output_fn),
d558 1
a558 1
                  user_options, output_fn)
d565 33
@


1.51
log
@UserContext.set_context_info has been deleted, replaced here with
UserContext.clear_debug_info.
@
text
@d7 4
d589 1
a589 2
                 (Info.error'
                    Info.default_options
d651 1
a651 1
                (fn () => do_use (pathname, Info.default_options))
@


1.50
log
@Module.with_source_path now takes a string describing the action undertaken.
@
text
@d7 3
d214 1
a214 1
	       ShellTypes.user_options = UserContext.user_tool_options
d348 1
a348 9
	    let val (c, delta, hist, smap) =
		  UserContext.get_context_info user_context
	    in
	      UserContext.set_context_info
		(user_context,
	         (Incremental.clear_debug_info (name, c),
	          Incremental.clear_debug_info (name, delta),
		  hist, smap))
	    end
d350 1
a350 9
	    let val (c, delta, hist, smap) =
		  UserContext.get_context_info user_context
	    in
	      UserContext.set_context_info
		(user_context,
	         (Incremental.clear_debug_all_info c,
	          Incremental.clear_debug_all_info delta,
		  hist, smap))
	    end
d551 1
a551 1
	  |   do_action (SAVE filename) =
d562 5
a566 4
             handle exn as ShellUtils.Error (c,e,el) =>
               raise Error' ("Error saving " ^ filename,c,e,el)
                  | Interrupt => raise Handled
                  | Info.Stop (e,el) => raise Error ("Error saving " ^ filename,e,el)
d568 1
a568 1
	    *)
@


1.49
log
@Reinstated Incremental.delete_module and Incremental.delete_all_modules.
@
text
@d7 3
d370 2
a371 1
		 Info.Location.FILE toplevel_name, trimmed_name)
d393 2
a394 1
		trim_spaces filename)
d430 3
a432 1
	       Info.Location.FILE toplevel_name, trim_spaces filename)
d470 2
a471 1
		trim_spaces filename)
d502 3
a504 1
	       Info.Location.FILE toplevel_name, trim_spaces filename)
d539 3
a541 1
                Info.Location.FILE toplevel_name, trim_spaces filename)
@


1.48
log
@Changes in InterMake, Incremental and therefore ShellUtils to use Project.
@
text
@d7 3
d362 2
a363 6
	    ()
	    (*
	    let val (c, delta, hist, smap) =
		  UserContext.get_context_info user_context

		val trimmed_name = trim_spaces filename
d365 3
a367 9
	      UserContext.set_context_info
		(user_context,
	         (Module.with_source_path
 		    (Incremental.delete_module c,
		     Info.Location.FILE toplevel_name, trimmed_name),
	          Module.with_source_path
 		    (Incremental.delete_module delta,
		     Info.Location.FILE toplevel_name, trimmed_name),
		  hist, smap))
a368 1
	    *)
d370 4
a373 7
	    ()
	    (*
	    let val module_id = 
		  ModuleId.from_string
		    (module_name, Info.Location.FILE toplevel_name)
		val (c, delta, hist, smap) =
		  UserContext.get_context_info user_context
d375 1
a375 5
	      UserContext.set_context_info
		(user_context,
 		 (Incremental.delete_module c module_id,
 		  Incremental.delete_module delta module_id,
		  hist, smap))
a376 1
	    *)
d378 1
a378 14
	    ()
	    (*
	    let 
              val (c, delta, hist, smap) =
                UserContext.get_context_info user_context
	    in
	      UserContext.set_context_info
		(user_context,
 		 (Incremental.delete_all_modules (c,true),
                  (* Should this not preserve the pervasive modules? *)
 		  Incremental.delete_all_modules (delta,false),
		  hist, smap))
	    end
	    *)
@


1.47
log
@Fixing problem with errors during load.
@
text
@d7 3
a215 1
  sharing type Incremental.InterMake.modules = ShellUtils.modules
d230 1
a230 1
    string * Incremental.InterMake.modules * Info.error * Info.error list
d236 11
a246 7
    TOUCH_FILE of string |
    TOUCH_MODULE of string |
    TOUCH_ALL |
    MAKE_FILE of string |
    MAKE_MODULE of string |
    CHECK_FILE of string |
    CHECK_MODULE of string |
d259 8
a266 2
  fun add_make_file (filename, options) =
    queue := MAKE_FILE filename :: !queue
d268 8
a275 2
  fun add_check_file (filename, options) =
    queue := CHECK_FILE filename :: !queue
d280 2
a281 2
  fun add_touch_file (filename, options) =
    queue := TOUCH_FILE filename :: !queue
d283 2
a284 2
  fun add_make_module (module_name, options) =
    queue := MAKE_MODULE module_name :: !queue
d286 2
a287 2
  fun add_check_module (module_name, options) =
    queue := CHECK_MODULE module_name :: !queue
d289 2
a290 2
  fun add_load_module (module_name,options) =
    queue := LOAD_MODULE module_name :: !queue
d292 2
a293 2
  fun add_touch_module (module_name, options) =
    queue := TOUCH_MODULE module_name :: !queue
d295 2
a296 2
  fun add_touch_all (options) =
    queue := TOUCH_ALL :: !queue
a306 8
  fun update_modules (user_context, modules) =
    let val (c, delta, hist, smap) = UserContext.get_context_info user_context
    in UserContext.set_context_info 
	 (user_context,
	  (Incremental.update_modules (c, modules),
	   Incremental.update_modules (delta, modules),
	   hist, smap))
    end
d358 3
a360 1
          |   do_action (TOUCH_FILE filename) =
d376 4
a379 1
          |   do_action (TOUCH_MODULE module_name) =
d392 4
a395 1
          |   do_action (TOUCH_ALL) =
d407 2
a408 1
          |   do_action (MAKE_FILE filename) =
d410 1
a410 1
	      (ShellUtils.make_file
a412 1
                  monitor_fn,
d419 2
a420 2
             handle exn as ShellUtils.Error (c,e,el) =>
               raise Error' ("Error making " ^ filename,c,e,el)
d424 1
a424 1
          |   do_action (MAKE_MODULE module_name) =
d429 1
a429 1
               ShellUtils.make_file
a431 1
                  monitor_fn,
d438 3
a440 2
             handle exn as ShellUtils.Error (c,e,el) =>
               raise Error' ("Error making " ^ module_name,c,e,el)
d442 1
d446 1
a446 1
          |   do_action (CHECK_FILE filename) =
d448 1
a448 1
              (ShellUtils.check_make_file
a450 1
                  monitor_fn,
d455 4
a458 2
            handle exn as ShellUtils.Error (c,e,el) =>
              raise Error' ("Error checking make dependencies for " ^ filename,c,e,el)
d462 1
a462 1
          |   do_action (CHECK_MODULE module_name) =
d467 1
a467 1
              ShellUtils.check_make_file
a469 1
                 monitor_fn,
d475 72
a546 2
            handle exn as ShellUtils.Error (c,e,el) =>
              raise Error' ("Error checking make dependencies for " ^ module_name,c,e,el)
d548 1
d559 2
a560 2
               handle exn as ShellUtils.Error (c,e,el) =>
                 raise Error' ("Error loading " ^ filename,c,e,el)
d576 2
a577 2
            handle exn as ShellUtils.Error (c,e,el) =>
              raise Error' ("Error loading " ^ module_name,c,e,el)
d582 2
d597 1
d611 2
a612 2
	       exn as ShellUtils.Error (c,e,el) =>
		  raise Error' ("Error using " ^ filename, c,e,el)
d631 2
a632 1
	  Error' (s,modules,e,l) =>
d635 2
d639 1
d644 1
@


1.46
log
@Added function to strip spaces from beginning and end of filenames.
@
text
@d7 3
a402 3
                  | exn as Incremental.Interrupted _ => raise exn
                  | exn as Error' _ => raise exn
                  | exn as Handled => raise exn
d404 2
a405 3
                  | Info.Stop _ => raise Handled
                  | ShellTypes.DebuggerTrapped => raise Handled
                  | exn => raise exn)
a423 2
                  | exn as Error' _ => raise exn
                  | exn as Handled => raise exn
d425 2
a426 3
                  | Info.Stop _ => raise Handled
                  | ShellTypes.DebuggerTrapped => raise Handled
                  | exn => raise exn)
a438 3
                 | exn as Incremental.Interrupted _ => raise exn
                 | exn as Error' _ => raise exn
                 | exn as Handled => raise exn
d440 2
a441 3
                 | Info.Stop _ => raise Handled
                 | ShellTypes.DebuggerTrapped => raise Handled
                 | exn => raise exn)
a458 2
                 | exn as Error' _ => raise exn
                 | exn as Handled => raise exn
d460 2
a461 3
                 | Info.Stop _ => raise Handled
                 | ShellTypes.DebuggerTrapped => raise Handled
                 | exn => raise exn)
d463 11
a473 6
	    Module.with_source_path
              (ShellUtils.load_file
	         (user_context, toplevel_name,
                  ShellTypes.new_options (user_options, user_context),
		  user_options, output_fn),
	       Info.Location.FILE toplevel_name, trim_spaces filename)
d475 2
a476 1
            let val module_id =
d478 13
a490 8
                    (module_name, Info.Location.FILE toplevel_name)
            in
              ShellUtils.load_file
	        (user_context, toplevel_name,
                 ShellTypes.new_options (user_options, user_context),
		 user_options, output_fn)
	        module_id
	    end
a501 3
                  | exn as Incremental.Interrupted _ => raise exn
                  | exn as Error' _ => raise exn
                  | exn as Handled => raise exn
d503 2
a504 3
                  | Info.Stop _ => raise Handled
                  | ShellTypes.DebuggerTrapped => raise Handled
                  | exn => raise exn)
d525 2
a526 5
                  handle
 	            Info.Stop _ => raise Handled)
	     | exn as Incremental.Interrupted _ => raise exn
	     | exn as Error' _ => raise exn
	     | exn as Handled => raise exn
d528 2
a529 3
	     | Info.Stop _ => raise Handled
	     | ShellTypes.DebuggerTrapped => raise Handled
	     | exn => raise exn)
@


1.45
log
@Adding touch_all function
@
text
@d7 3
d295 23
d348 2
d355 1
a355 1
		     Info.Location.FILE toplevel_name, filename),
d358 1
a358 1
		     Info.Location.FILE toplevel_name, filename),
d397 1
a397 1
		filename)
d440 1
a440 1
	       Info.Location.FILE toplevel_name, filename)
d479 1
a479 1
	       Info.Location.FILE toplevel_name, filename)
d493 1
a493 1
             (filename,
d512 1
a512 1
	       val expanded_file = Getenv.expand_home_dir filename
@


1.44
log
@ShellUtils.{make,load}_file now take a user_options argument.
@
text
@d7 3
d230 1
d271 3
d344 12
@


1.43
log
@Split user_options into tool-specific and context-specific parts.
@
text
@d7 3
d346 1
d370 1
d431 1
a431 1
		  output_fn),
d441 1
a441 1
		 output_fn)
@


1.42
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d7 3
d187 1
a187 1
          ShellUtils.Options
d189 4
a192 2
  sharing type ShellUtils.UserOptions = UserOptions.user_options =
	       ShellTypes.user_options
a201 1
  sharing type ShellUtils.UserOptions = UserContext.user_options
d209 1
a209 1
  type UserOptions = UserOptions.user_options
d342 1
a342 1
                  UserOptions.new_options user_options,
d365 1
a365 1
                  UserOptions.new_options user_options,
d385 1
a385 1
                  UserOptions.new_options user_options,
d407 1
a407 1
                 UserOptions.new_options user_options,
d425 2
a426 1
		  UserOptions.new_options user_options, output_fn),
d435 2
a436 1
	         UserOptions.new_options user_options, output_fn)
d445 1
a445 1
              UserOptions.new_options user_options,
@


1.41
log
@Fixed broken handling of subuses (code was broken when I moved to
the new FileSys and Path structures).
Better error handling.
filesys and path moved from utils to initbasis.
@
text
@d7 6
d163 1
d173 1
d182 1
a182 2
  sharing Incremental.InterMake.Compiler.Info =
	  ShellTypes.Info = ShellUtils.Info
d186 4
a189 5
  sharing type Incremental.options = ShellTypes.IncrementalOptions
  sharing type ShellUtils.UserOptions = UserOptions.user_options
  sharing type ShellTypes.Context =
	       Incremental.Context =
               ShellUtils.Context
d192 4
a195 2
  sharing type Module.Location = ShellTypes.Info.Location.T = ModuleId.Location
  sharing type ShellUtils.user_context = ShellTypes.user_context
d197 2
a198 2
  sharing type ShellUtils.UserOptions = ShellTypes.user_options
  ): ACTION_QUEUE =
d201 1
a201 1
  structure Info = ShellTypes.Info
d204 1
a204 1
  type Context = ShellTypes.Context
d206 1
a206 1
  type user_context = ShellTypes.user_context
d270 2
a271 2
    let val (c, delta, hist, smap) = ShellTypes.get_context_info user_context
    in ShellTypes.set_context_info 
d287 1
a287 1
		  ShellTypes.get_context_info user_context
d289 1
a289 1
	      ShellTypes.set_context_info
d297 1
a297 1
		  ShellTypes.get_context_info user_context
d299 1
a299 1
	      ShellTypes.set_context_info
d307 1
a307 1
		  ShellTypes.get_context_info user_context
d309 1
a309 1
	      ShellTypes.set_context_info
d324 1
a324 1
		  ShellTypes.get_context_info user_context
d326 1
a326 1
	      ShellTypes.set_context_info
d378 1
a378 1
                 (ShellTypes.get_context user_context,
d400 1
a400 1
                (ShellTypes.get_context user_context,
d436 1
a436 1
              ShellTypes.get_context user_context,
@


1.40
log
@Change FILESYS to FILE_SYS
@
text
@d7 3
d153 2
a154 2
require "../utils/filesys";
require "../utils/path";
a271 5
      fun exn_message exn = output(MLWorks.IO.terminal_out,
                                   "Reraising unexpected exception from do_actions:" ^
                                   MLWorks.Internal.Value.exn_name_string(MLWorks.Internal.Value.exn_name exn)^
                                   "\n")

a274 1
          val toplevel_location = Info.Location.FILE toplevel_name
d276 47
a322 47
        in
          queue := [];
          Lists.iterate
          (fn CLEAR_DEBUG_INFO name =>
	     let val (c, delta, hist, smap) =
		   ShellTypes.get_context_info user_context
	     in
	       ShellTypes.set_context_info
		 (user_context,
	          (Incremental.clear_debug_info (name, c),
	           Incremental.clear_debug_info (name, delta),
		   hist, smap))
	     end
           | CLEAR_DEBUG_ALL_INFO =>
	     let val (c, delta, hist, smap) =
		   ShellTypes.get_context_info user_context
	     in
	       ShellTypes.set_context_info
		 (user_context,
	          (Incremental.clear_debug_all_info c,
	           Incremental.clear_debug_all_info delta,
		   hist, smap))
	     end
           | TOUCH_FILE filename =>
	     let val (c, delta, hist, smap) =
		   ShellTypes.get_context_info user_context
	     in
	       ShellTypes.set_context_info
		 (user_context,
	          (Module.with_source_path
 		     (Incremental.delete_module c, filename),
	           Module.with_source_path
 		     (Incremental.delete_module delta, filename),
		   hist, smap))
	     end
           | TOUCH_MODULE module_name =>
	     let val module_id = 
		   ModuleId.from_string
		     (module_name, Info.Location.UNKNOWN)
		 val (c, delta, hist, smap) =
		   ShellTypes.get_context_info user_context
	     in
	       ShellTypes.set_context_info
		 (user_context,
 		  (Incremental.delete_module c module_id,
 		   Incremental.delete_module delta module_id,
		   hist, smap))
d324 1
a324 1
        | MAKE_FILE filename =>
d333 2
a334 1
	       filename)
d343 2
a344 2
                  | exn => ((* exn_message exn;*) raise exn))
        | MAKE_MODULE module_name =>
d346 22
a367 22
		      ModuleId.from_string
			(module_name, Info.Location.UNKNOWN)
	    in
              ShellUtils.make_file
                (user_context,
                 toplevel_name,
                 monitor_fn,
                 UserOptions.new_options user_options,
                 debugger,
                 output_fn)
	        module_id
	    end
            handle exn as ShellUtils.Error (c,e,el) =>
              raise Error' ("Error making " ^ module_name,c,e,el)
                 | exn as Incremental.Interrupted _ => raise exn
                 | exn as Error' _ => raise exn
                 | exn as Handled => raise exn
                 | Interrupt => raise Handled
                 | Info.Stop _ => raise Handled
                 | ShellTypes.DebuggerTrapped => raise Handled
                 | exn => ((* exn_message exn;*) raise exn))
        | CHECK_FILE filename =>
d376 1
a376 1
	       filename)
d385 2
a386 2
                 | exn => ((* exn_message exn;*) raise exn))
        | CHECK_MODULE module_name =>
d389 1
a389 1
                    (module_name, Info.Location.UNKNOWN)
d408 2
a409 2
                 | exn => ((* exn_message exn;*) raise exn))
        | LOAD_FILE filename =>
d414 2
a415 2
	       filename)
        | LOAD_MODULE module_name =>
d418 1
a418 1
                    (module_name, Info.Location.UNKNOWN)
d425 1
a425 1
	| SAVE filename =>
d442 33
a474 36
                  | exn => ((* exn_message exn;*) raise exn))
        | USE filename =>
	    let
(*
	      val _ = output(std_out, "pathname = " ^ pathname ^ "\n")
*)
	      val expanded = FileSys.expand_path pathname
(*
	      val _ = output(std_out, "real path = " ^ expanded ^ "\n")
*)
	      val new_name = Path.mkRelative (filename, expanded)
(*
	      val _ = output(std_out, "Using file '" ^ filename ^ "\n")
*)
	    in
	      (ShellUtils.use_file
	       (new_name,
		user_context,
		toplevel_name,
		user_options,
		debugger,
		output_fn,
		level,
		aux (Path.dir new_name))
	       handle exn as ShellUtils.Error (c,e,el) =>
		 raise Error' ("Error using " ^ filename,
			       c,e,el)
		    | exn as Incremental.Interrupted _ => raise exn
		    | exn as Error' _ => raise exn
		    | exn as Handled => raise exn
		    | Interrupt => raise Handled
		    | Info.Stop _ => raise Handled
		    | ShellTypes.DebuggerTrapped => raise Handled
		    | exn => ((* exn_message exn;*) raise exn))
	    end)
          actions
@


1.39
log
@do_actions now takes an output function argument.
@
text
@d7 3
d160 1
a160 1
  structure FileSys : FILESYS
@


1.38
log
@Replaced Option structure with references to MLWorks.Option.
Replaced FileName parameter with FileSys and Path.
@
text
@d7 4
d264 1
a264 1
  fun do_actions (user_context,user_options,debugger,monitor_fn) =
a265 1
      fun output_fn s = output(std_out,s)
d505 1
@


1.37
log
@Move OS specific stuff into a system link directory
@
text
@d7 3
d143 2
a144 1
require "../utils/filename";
d153 2
a154 1
  structure FileName : FILENAME
d444 1
a444 1
	      val realpath = MLWorks.OS.Unix.realpath pathname
d446 1
a446 1
	      val _ = output(std_out, "realpath = " ^ realpath ^ "\n")
d448 1
a448 17
	      val abs = case filename of
		"" => true (* Will fail later *)
	      | _ =>
		  case String.substring(filename, 0, 1) of
		    "/" => true
		  | _ => false
	      val newname =
		if abs then filename
		else
		  let
		    val dir = FileName.parse_route realpath
		    val new_name =
		      FileName.prefix_route(dir, FileName.parse_relative filename)
		  in
		    FileName.relative_name new_name
		  end
	      val FileName.RELATIVE(dir, _, _) = FileName.parse_relative newname
d454 1
a454 1
	       (newname,
d461 1
a461 1
		aux (FileName.route_name dir))
d508 1
a508 1
          Getenv.Option.ABSENT =>
d511 1
a511 1
        | Getenv.Option.PRESENT dir =>
@


1.36
log
@Modify aux function to take directory (string) argument describing
where use was from. This should allow use to deal with subuses correctly
@
text
@d7 4
d137 2
a138 2
require "../basics/getenv";
require "../make/unix";
d156 1
a156 1
  structure Unix : UNIX
d525 3
a527 3
            case Unix.mtime pathname of
              Unix.NOT_EXIST => ()
            | Unix.EXISTS _ =>
@


1.35
log
@Added read_dot_mlworks functions.
@
text
@d7 3
d136 1
d145 1
d259 1
a259 1
      fun aux level =
d430 50
a479 20
        | USE pathname =>
            (ShellUtils.use_file
             (pathname,
              user_context,
              toplevel_name,
              user_options,
              debugger,
              output_fn,
              level,
              aux)
             handle exn as ShellUtils.Error (c,e,el) =>
               raise Error' ("Error using " ^ pathname,
                            c,e,el)
                  | exn as Incremental.Interrupted _ => raise exn
                  | exn as Error' _ => raise exn
                  | exn as Handled => raise exn
                  | Interrupt => raise Handled
                  | Info.Stop _ => raise Handled
                  | ShellTypes.DebuggerTrapped => raise Handled
                  | exn => ((* exn_message exn;*) raise exn)))
d484 1
a484 1
        (aux 0)
@


1.34
log
@do_actions now takes a user_context instead of a Context ref.
The Error exception no longer includes a Context (it was never used).
THe new Error' exception takes its place internally.
@
text
@d7 5
d130 2
d147 2
d150 2
a151 1
  sharing Incremental.InterMake.Compiler.Info = ShellTypes.Info = ShellUtils.Info
d153 1
a153 1
    ShellUtils.Options
d165 1
d175 1
d461 34
@


1.33
log
@Added new commands that distinguish modules and files.
@
text
@d7 3
d153 2
a154 1

d163 1
d166 6
a171 1
  exception Error of (string * Context * Info.error * Info.error list)
d225 7
a231 22
  (*
  fun with_source_path (f, filename) =
    let
      val old_source_path = Io.get_source_path ()

      val (on_path, module) =
        Module.find_file (filename, Info.Location.UNKNOWN)
        handle
          Module.NoSuchFile s =>
            Info.error'
            (Info.make_default_options ())
            (Info.FATAL, Info.Location.UNKNOWN, "No such file: `" ^ s ^ "'")

      val _ = if not on_path then
                Io.set_source_path (Module.module_dir module :: old_source_path)
              else
                ();

      val result = f (Module.module_id module)
    in
      Io.set_source_path old_source_path;
      result
a232 4
    handle x =>
      (Io.set_source_path old_source_path;
       raise x)
  *)
d234 1
a234 1
  fun do_actions (context_ref,user_options,debugger,monitor_fn) =
d251 43
a293 14
           context_ref := Incremental.clear_debug_info (name, !context_ref)
        | CLEAR_DEBUG_ALL_INFO =>
           context_ref := Incremental.clear_debug_all_info (!context_ref)
        | TOUCH_FILE filename =>
            context_ref :=
  	      Module.with_source_path
 		(Incremental.delete_module (!context_ref), filename)
        | TOUCH_MODULE module_name =>
	    let val module_id = 
		  ModuleId.from_string
		    (module_name, Info.Location.UNKNOWN)
	    in
              context_ref :=
	        (Incremental.delete_module (!context_ref) module_id)
a294 4
	(*
        | TOUCH_FILE filename =>
            context_ref := Incremental.delete_module (!context_ref, filename)
	*)
d298 1
a298 1
                 (context_ref,
d306 1
a306 1
               raise Error ("Error making " ^ filename,c,e,el)
d308 1
a308 1
                  | exn as Error _ => raise exn
d320 1
a320 1
                (context_ref,
d329 1
a329 1
              raise Error ("Error making " ^ module_name,c,e,el)
d331 1
a331 1
                 | exn as Error _ => raise exn
a336 20
	(*
        | MAKE_FILE filename =>
            (ShellUtils.make_file
             (filename,
              context_ref,
              toplevel_name,
              monitor_fn,
              UserOptions.new_options user_options,
              debugger,
              output_fn)
             handle exn as ShellUtils.Error (c,e,el) =>
               raise Error ("Error making " ^ filename,c,e,el)
                  | exn as Incremental.Interrupted _ => raise exn
                  | exn as Error _ => raise exn
                  | exn as Handled => raise exn
                  | Interrupt => raise Handled
                  | Info.Stop _ => raise Handled
                  | ShellTypes.DebuggerTrapped => raise Handled
                  | exn => ((* exn_message exn;*) raise exn))
	*)
d340 1
a340 1
                 (context_ref,
d348 1
a348 1
              raise Error ("Error checking make dependencies for " ^ filename,c,e,el)
d350 1
a350 1
                 | exn as Error _ => raise exn
d362 1
a362 1
                (context_ref,
d371 1
a371 1
              raise Error ("Error checking make dependencies for " ^ module_name,c,e,el)
d373 1
a373 1
                 | exn as Error _ => raise exn
a378 20
	(*
        | CHECK_FILE filename =>
            (ShellUtils.check_make_file
             (filename,
              context_ref,
              toplevel_name,
              monitor_fn,
              UserOptions.new_options user_options,
              debugger,
              output_fn)
             handle exn as ShellUtils.Error (c,e,el) =>
               raise Error ("Error checking make dependencies for " ^ filename,c,e,el)
                  | exn as Incremental.Interrupted _ => raise exn
                  | exn as Error _ => raise exn
                  | exn as Handled => raise exn
                  | Interrupt => raise Handled
                  | Info.Stop _ => raise Handled
                  | ShellTypes.DebuggerTrapped => raise Handled
                  | exn => ((* exn_message exn;*) raise exn))
	*)
d382 1
a382 1
	         (context_ref, toplevel_name,
d391 1
a391 1
	        (context_ref, toplevel_name,
a394 4
	(*
        | LOAD_FILE filename =>
            ShellUtils.load_file (filename,context_ref,toplevel_name,UserOptions.new_options user_options,output_fn)
	*)
d398 1
a398 1
              context_ref,
d405 1
a405 1
               raise Error ("Error saving " ^ filename,c,e,el)
d407 1
a407 1
                  | exn as Error _ => raise exn
d416 1
a416 1
              context_ref,
d424 1
a424 1
               raise Error ("Error using " ^ pathname,
d427 1
a427 1
                  | exn as Error _ => raise exn
d438 10
a447 8
        handle exn as Error (_,context,_,_) =>
          (context_ref := context;
           raise exn)
             | exn as Io s => (output(std_out,"Exception Io of " ^ s ^ "\n");raise exn)
             | Incremental.Interrupted (context) =>
                 (context_ref := context;
                  (* reraise as Interrupt *)
                  raise Interrupt)
@


1.32
log
@Added check_make stuff
@
text
@d7 3
d120 2
d135 2
d147 3
d164 8
a171 3
    REMAKE_FILE of string |
    MAKE of string |
    CHECK_MAKE of string |
a173 1
    LOAD of string |
d182 14
a195 2
  fun add_make (filename, options) =
    queue := MAKE filename :: !queue
d197 2
a198 2
  fun add_check_make (filename, options) =
    queue := CHECK_MAKE filename :: !queue
d200 2
a201 2
  fun add_save (filename, options) =
    queue := SAVE filename :: !queue
d203 2
a204 4
  fun add_remake (filename, options) =
    queue := MAKE filename ::
	     REMAKE_FILE filename ::
	     !queue
d206 3
d215 27
a241 2
  fun add_load (filename,options) =
    queue := LOAD filename :: !queue
a249 1
      exception Ooops of Context
d263 1
a263 1
        | REMAKE_FILE filename =>
d265 58
a322 2
            Incremental.delete_module (!context_ref, filename)
        | MAKE filename =>
d340 45
a384 1
        | CHECK_MAKE filename =>
d402 21
d460 1
a460 3
                  | exn => ((* exn_message exn;*) raise exn))
        | LOAD pathname =>
            ShellUtils.load_file (pathname,context_ref,toplevel_name,UserOptions.new_options user_options,output_fn))
d462 1
a462 1
        end
@


1.31
log
@Adding clear_debug functionality.
@
text
@d7 3
d156 1
d171 3
d226 18
@


1.30
log
@Removed redundant FileName structure.
@
text
@d7 3
d156 2
a157 1
    CLEAR_DEBUG_INFO
d175 5
a179 2
  fun add_clear_debug () =
    queue := CLEAR_DEBUG_INFO :: !queue
d201 4
a204 2
          (fn CLEAR_DEBUG_INFO =>
           context_ref := Incremental.clear_debug_info (!context_ref)
@


1.29
log
@Better locations in error messages
@
text
@d7 3
a137 1
  structure Filename = Incremental.InterMake.FileName
@


1.28
log
@Added load function -- this loads an mo
@
text
@d7 3
d186 2
d201 1
d219 1
d237 1
d254 1
a254 1
            ShellUtils.load_file (pathname,context_ref,UserOptions.new_options user_options,output_fn))
@


1.27
log
@Remove calls to exn_message.  Changed defn. of exn_message.
@
text
@d7 3
d147 1
d169 3
d227 8
a234 8
            ShellUtils.use_file
            (pathname,
             context_ref,
             user_options,
             debugger,
             output_fn,
             level,
             aux)
d245 2
d255 1
@


1.26
log
@Bug fixing
@
text
@d7 3
d168 4
a171 3
      fun exn_message exn = output_fn ("Unexpected exception " ^
                                     MLWorks.Internal.Value.exn_name_string(MLWorks.Internal.Value.exn_name exn)^
                                       "\n")
d200 2
a201 1
                  | exn => (exn_message exn; raise Handled))
d217 2
a218 1
                  | exn => (exn_message exn; raise Handled))
d236 2
a237 1
                  | exn => (exn_message exn;raise Handled))
@


1.25
log
@Added add_save function
@
text
@d7 9
d190 1
a190 2
               raise Error ("Error making " ^ filename,
                            c,e,el)
d194 2
a195 1
                  | exn as Interrupt => raise Handled
d206 1
a206 2
               raise Error ("Error saving " ^ filename,
                            c,e,el)
d210 2
a211 1
                  | exn as Interrupt => raise Handled
d228 2
a229 1
                  | exn as Interrupt => raise Handled
@


1.24
log
@Added Interrupt handlers
@
text
@d7 3
d130 1
d142 3
d182 16
@


1.24.1.1
log
@Fork for bug fixing
@
text
@a6 3
 *  Revision 1.24  1993/08/24  17:08:39  matthew
 *  Added Interrupt handlers
 *
@


1.24.1.2
log
@Added Info.Stop handlers
@
text
@a6 3
 *  Revision 1.24.1.1  1993/08/24  17:08:39  jont
 *  Fork for bug fixing
 *
d182 1
a182 2
                  | Interrupt => raise Handled
                  | Info.Stop _ => raise Handled
d199 1
a199 2
                  | Interrupt => raise Handled
                  | Info.Stop _ => raise Handled
@


1.23
log
@Added "Unexpected exception" message.
@
text
@d7 3
d179 1
d196 1
@


1.22
log
@Changed type of actions to use strings (representing moduleids) instead
of filenames.
@
text
@d7 4
d146 3
a148 1

d176 1
a176 1
                  | exn => raise Handled)
d192 1
a192 1
                  | exn => raise Handled)
@


1.21
log
@Added missing handler for Incremental.Interrupted
reraise Interrupted as Interrupt at outermost level
@
text
@d7 4
d53 1
a53 1

d58 18
a75 17
Revision 1.5  1993/03/19  18:43:24  matthew
 Changed context parameter to be a reference, which is side-effected.do_actions now returns unit.
Uses Incremental.compile_source & Incremental.add_definitions
(Incremental.add_source has been removed)

Revision 1.4  1993/03/18  18:43:26  matthew
Changed error output to use output function.

Revision 1.3  1993/03/12  11:15:28  matthew
Options changes

Revision 1.2  1993/03/09  15:41:43  matthew
Options & Info changes

Revision 1.1  1993/03/02  11:13:10  daveb
Initial revision

a97 1
  sharing Incremental.InterMake.FileName = ShellUtils.Filename
d107 1
a107 1
  structure Filename = ShellUtils.Filename
d118 3
a120 3
    REMAKE_FILE of Filename.absolute |
    MAKE of Filename.absolute |
    USE of Filename.absolute |
d126 1
a126 1
    queue := USE (ShellUtils.parse_absolute (filename,options)) :: !queue
d129 1
a129 1
    queue := MAKE (ShellUtils.parse_absolute (filename, options)) :: !queue
d132 2
a133 2
    queue := MAKE (ShellUtils.parse_absolute (filename, options)) ::
	     REMAKE_FILE (ShellUtils.parse_absolute (filename, options)) ::
d165 1
a165 1
               raise Error ("Error making " ^ Filename.absolute_name filename,
d181 1
a181 1
               raise Error ("Error using " ^ Filename.absolute_name pathname,
@


1.20
log
@Added handler for Incremental.Interrupted exception.
@
text
@d7 3
d163 1
d192 3
a194 1
                 context_ref := context
@


1.19
log
@Changes to Error handling
@
text
@d7 3
a133 2
      val error_info = Info.default_options

d175 1
d187 2
@


1.18
log
@Removed "\n"'s from errors.
@
text
@d7 3
d104 3
a128 2
  exception Error of (string * ShellTypes.Context)

d154 3
a156 6
             handle ShellUtils.Error(subcontext,_,_) => 
               (raise Error (implode ["Error making `", 
                                      Filename.absolute_name filename,
                                      "'"
                                      ],
                  subcontext))
d158 2
a159 6
                  | exn => 
                      (raise Error (implode ["Error making `", 
                                             Filename.absolute_name filename,
                                             "'"
                                             ],
                         !context_ref)))
d169 6
a174 8
            handle exn as Error _ => raise exn
                 | Io s =>
                     raise Error (s, !context_ref)
                 | exn =>
                     raise Error (implode ["Error using `",
                                           Filename.absolute_name pathname,
                                           "'"],
                                  !context_ref))
a176 1

d180 1
a180 1
        handle exn as Error (s,context) =>
a183 1

@


1.17
log
@Use ShellUtils functions
@
text
@d7 3
d153 1
a153 1
                                      "'\n"
d160 1
a160 1
                                             "'\n"
d174 1
a174 1
                     raise Error (s ^ "\n", !context_ref)
d178 1
a178 1
                                           "'\n"],
@


1.16
log
@Use ShellUtils.make_file
@
text
@d7 3
a62 1
require "../lexer/lexer";
d64 1
d67 1
a67 2
require "incremental";
require "interprint";
d72 1
a72 1
  structure Lexer : LEXER
a73 1
  structure InterPrint : INTERPRINT
a75 1
  structure UserOptions : USER_OPTIONS
a76 1
  sharing Incremental.InterMake.Compiler = InterPrint.Compiler
d83 2
a84 3

  sharing type InterPrint.Context =
               ShellTypes.Context =
a87 2
  sharing type Lexer.TokenStream =
	       Incremental.InterMake.Compiler.tokenstream
d92 2
a93 3
  structure Compiler = Incremental.InterMake.Compiler
  structure Info = Compiler.Info
  structure Options = Compiler.Options
d95 1
a95 1
  type ContextRef = ShellTypes.ContextRef
d120 2
a123 7
      exception Error of (string * Incremental.Context)
      fun get_context () =
        !(ShellTypes.get_context_ref (context_ref))

      fun set_context (context) =
        ShellTypes.set_context_ref (context_ref, context)

a127 6
      fun make_print_options () =
        let val Options.OPTIONS{print_options,...} = UserOptions.new_options user_options
        in
          print_options
        end

d135 1
a135 1
           set_context(Incremental.clear_debug_info (get_context()))
d137 2
a138 2
            set_context(Incremental.delete_module
                        (get_context(), filename))
d142 1
a142 1
              ShellTypes.get_context_ref context_ref,
d147 1
a147 1
             handle Incremental.Error(subcontext,_,_) => 
d159 1
a159 1
                         get_context())))
d161 16
a176 73
            let
              (* USE is more generous than make, compile or recompile.
               It can read a file without a ".sml" extension!
               For compatibility with other compilers.
               *)
              val Filename.ABSOLUTE(loc,name,extension) = pathname

              val filename_sml =
                let
                  val sml_pathname = 
                    case extension of
                      Filename.Option.PRESENT _ => pathname
                    | _ => Filename.ABSOLUTE (loc,name,Filename.Option.PRESENT "sml")
                in
                  Filename.absolute_name sml_pathname
                end
 
              val filename = Filename.absolute_name pathname

              val (stream, filename) =
                (open_in filename_sml, filename_sml)
                handle Io _ => (open_in filename, filename)
 
              val _ =
                let fun spaces y =
                  if y <= 0 then filename else ("   " ^ spaces (y-1))
                in output_fn (spaces level ^ "\n")
                end
 
              val token_stream =
                Lexer.mkFileTokenStream (stream, filename)

              fun make_incremental_options () =
                Incremental.OPTIONS
                {options = UserOptions.new_options user_options,
                 debugger = debugger}

               fun next () =
                 if Lexer.eof token_stream then
                   close_in stream
                 else
                   let
                     val (source_result, identifiers) =
                       Incremental.compile_source
		       (make_incremental_options())
                       (get_context(), Compiler.TOKENSTREAM1 token_stream)

                     val new_context =
                       Incremental.add_definitions
			 (get_context(), source_result)
                   in
                     InterPrint.definitions
                     output_fn
                     error_info
                     (new_context,
                      make_print_options(),
                      0, identifiers);
                     set_context new_context;
                     aux (level+1);
                     next()
                   end
            in
              next()
              handle exn as Error _ => raise exn
                   | exn =>
                       (raise Error (implode ["Error using `", filename, "'\n"],
                                     (get_context())))
            end
          handle
          Io s =>
            raise Error (s ^ "\n", get_context())
        | Filename.Parse _ =>
            raise Error ("Invalid filename\n", get_context()))
d183 3
a185 3
        handle Error (s,context) =>
          (output_fn s; set_context context)
             | exn => ()
@


1.15
log
@Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d7 3
a60 1
require "../main/io";
d62 1
d74 1
a74 1
  structure Io : IO
d78 3
a80 2
  sharing Incremental.InterMake.Compiler.Info = ShellTypes.Info
  sharing UserOptions.Options = Incremental.InterMake.Compiler.Options
d82 1
d87 2
a88 1
	       Incremental.Context
d95 1
a95 1
  structure FileName = Incremental.InterMake.FileName
d104 3
a106 3
    REMAKE_FILE of FileName.absolute |
    MAKE of FileName.absolute |
    USE of string |
d111 2
a112 23
  fun parse_home_name filename =
    Io.trans_home_name filename handle Io.bad_home_name s => s

  fun parse_filename filename = 
    FileName.parse_absolute filename
    handle FileName.Parse _ => 
      (FileName.parse_absolute(MLWorks.OS.Unix.getwd() ^ "/" ^ filename))

  fun parse_absolute (filename, error_info) =
    let
      val filename = parse_home_name filename
    in
      FileName.parse_absolute filename
      handle FileName.Parse _ => 
	(FileName.parse_absolute(MLWorks.OS.Unix.getwd() ^ "/" ^ filename)
	 handle (exn as FileName.Parse _) => 
	   Info.error' error_info (Info.FATAL,
				   Info.Location.UNKNOWN, 
				   "Invalid Filename : " ^ filename))
    end

  fun add_use (filename) =
    queue := USE(parse_home_name filename) :: !queue
d115 1
a115 1
    queue := MAKE (parse_absolute (filename, options)) :: !queue
d118 2
a119 2
    queue := MAKE (parse_absolute (filename, options)) ::
	     REMAKE_FILE (parse_absolute (filename, options)) ::
a137 5
      fun make_incremental_options () =
        Incremental.OPTIONS
        {options = UserOptions.new_options user_options,
         debugger = debugger}

d156 21
a176 29
            (let
              val (new_context, identifiers) =
                Incremental.add_module
                (make_incremental_options())
                monitor_fn
                (get_context(), filename)
             in
               InterPrint.definitions
               output_fn
               error_info
               (new_context,
                make_print_options(),
                0, identifiers);
               set_context new_context
            end
            handle Incremental.Error(subcontext,_) => 
              (raise Error (implode ["Error making `", 
                                     FileName.absolute_name filename,
                                     "'\n"
                                     ],
                            subcontext))
                 | exn as Error _ => raise exn
                 | exn => 
                     (raise Error (implode ["Error making `", 
                                            FileName.absolute_name filename,
                                            "'\n"
                                            ],
                                   get_context())))
        | USE name =>
d182 1
a182 2
              val pathname as (FileName.ABSOLUTE(loc,name,extension)) =
                parse_filename name
d188 2
a189 2
                      FileName.Option.PRESENT _ => pathname
                    | _ => FileName.ABSOLUTE (loc,name,FileName.Option.PRESENT "sml")
d191 1
a191 1
                  FileName.absolute_name sml_pathname
d194 1
a194 1
              val filename = FileName.absolute_name pathname
d209 5
d248 1
a248 1
        | FileName.Parse _ =>
@


1.14
log
@Added resolution of filenames beginning ~ when given to make or use
@
text
@d7 3
d155 1
a155 2
        {error_info = error_info,
         options = UserOptions.new_options user_options,
a173 1
                        (make_incremental_options())
@


1.13
log
@Changed argument to do_actions
@
text
@d7 3
d55 1
d68 1
d102 3
d111 11
a121 5
    parse_filename filename
    handle (exn as FileName.Parse _) => 
      Info.error' error_info (Info.FATAL,
                              Info.Location.UNKNOWN, 
                              "Invalid Filename : " ^ filename)
d124 1
a124 1
    queue := USE filename :: !queue
@


1.12
log
@Changed context ref handling.
@
text
@d7 3
a11 2
 *  ,
 *  .`
d52 1
d64 1
d68 1
a71 3
  sharing type InterPrint.ValuePrinter.printer_descriptor =
	       ShellTypes.printer_descriptor

d78 1
a78 1
): ACTION_QUEUE =
d84 1
a84 2
  structure ValuePrinter = InterPrint.ValuePrinter
  structure Options = ValuePrinter.Options
d86 2
a87 2
  type print_method_table = InterPrint.ValuePrinter.print_method_table
  type ShellData = ShellTypes.ShellData
d123 1
a123 1
  fun do_actions (shell_data as ShellTypes.SHELL_DATA {output_fn, ...}) =
a125 1
      val context_ref = ShellTypes.get_shell_context_ref shell_data
d132 16
d158 1
a158 1
                        (ShellTypes.make_incremental_options shell_data)
d164 2
a165 1
                (ShellTypes.make_incremental_options shell_data)
d170 1
a170 1
               (ShellTypes.get_error_info shell_data)
d172 1
a172 1
                ShellTypes.make_printer_descriptor shell_data,
d230 1
a230 1
		       (ShellTypes.make_incremental_options shell_data)
d239 1
a239 1
                     (ShellTypes.get_error_info shell_data)
d241 1
a241 1
                      ShellTypes.make_printer_descriptor shell_data,
@


1.11
log
@Better use of generic filenames
,
.`
@
text
@d7 5
d126 7
a132 1
      val context_ref = ShellTypes.get_context_ref shell_data
d140 1
a140 1
           context_ref := Incremental.clear_debug_info (!context_ref)
d142 3
a144 4
            context_ref :=
            Incremental.delete_module
            (ShellTypes.make_incremental_options shell_data)
            (!context_ref, filename)
d150 1
a150 1
                (!context_ref, filename)
d158 1
a158 1
               context_ref := new_context
d172 1
a172 1
                                   !context_ref)))
d215 1
a215 1
                       (!context_ref, Compiler.TOKENSTREAM1 token_stream)
d219 1
a219 1
			 (!context_ref, source_result)
d227 1
a227 1
                     context_ref := new_context;
d236 1
a236 1
                                     (!context_ref)))
d240 1
a240 1
            raise Error (s ^ "\n", !context_ref)
d242 1
a242 1
            raise Error ("Invalid filename\n", !context_ref))
d250 1
a250 1
          (output_fn s; context_ref := context)
@


1.10
log
@Signature changes
@
text
@d7 3
d92 1
a92 1
  fun parse_absolute (filename, error_info) =
d95 8
a102 5
      (FileName.parse_absolute(MLWorks.OS.Unix.getwd() ^ "/" ^ filename)
       handle (exn as FileName.Parse _) => 
         Info.error' error_info (Info.FATAL,
                                 Info.Location.UNKNOWN, 
                                 "Invalid Filename : " ^ filename))
d163 1
a163 1
        | USE filename =>
d169 3
d173 8
a180 4
                (if size filename < 4 orelse
                   String.substring (filename, size filename - 4, 4) <> ".sml"
		   then filename ^ ".sml"
                 else filename)
d182 2
d228 2
a229 1
          handle exn as Io s =>
d231 2
a232 1
	  )
@


1.9
log
@Fixed the action handler to side-effect the relevant context ref
@
text
@d7 3
d44 1
d51 1
d55 4
a58 1
  sharing ShellTypes.Incremental.InterMake.Compiler = InterPrint.Compiler
d64 2
a65 1
	       ShellTypes.Incremental.Context
d68 1
a68 1
	       ShellTypes.Incremental.InterMake.Compiler.tokenstream
d71 1
a71 1
  structure Incremental = ShellTypes.Incremental
d76 1
a76 1
  structure Options = ValuePrinter.Debugger_Types.Options
@


1.8
log
@Removed update_options call
@
text
@d7 3
d106 2
a107 2

      fun aux (context,level) =
d109 1
a109 1
          val filenames = rev (!queue)
d112 45
a156 46
          Lists.reducel
          (fn (context, CLEAR_DEBUG_INFO) =>
             Incremental.clear_debug_info context
           | (context, REMAKE_FILE filename) =>
             Incremental.delete_module
	       (ShellTypes.make_incremental_options shell_data)
	       (context, filename)
           | (context, MAKE filename) =>
             (let
               val (new_context, identifiers) =
                 Incremental.add_module
		   (ShellTypes.make_incremental_options shell_data)
		   (context, filename)
              in
                InterPrint.definitions
                  output_fn
                  (ShellTypes.get_error_info shell_data)
                  (new_context,
		   ShellTypes.make_printer_descriptor shell_data,
		   0, identifiers);
                new_context
              end
              handle 
                Incremental.Error(subcontext,_) => 
                  (raise Error (implode ["Error making `", 
                                         FileName.absolute_name filename,
                                         "'\n"
                                        ],
                                subcontext))
              | exn as Error _ => raise exn
              | exn => 
                (raise Error (implode ["Error making `", 
                                       FileName.absolute_name filename,
                                       "'\n"
                                      ],
                 	      context))
	     )
           | (context, USE filename) =>
             let
               (* USE is more generous than make, compile or recompile.
                  It can read a file without a ".sml" extension!
                  For compatibility with other compilers.
                *)
               val filename_sml =
                 (if size filename < 4 orelse
		    String.substring (filename, size filename - 4, 4) <> ".sml"
d160 3
a162 3
               val (stream, filename) =
                 (open_in filename_sml, filename_sml)
                  handle Io _ => (open_in filename, filename)
d164 5
a168 5
               val _ =
                 let fun spaces y =
		       if y <= 0 then filename else ("   " ^ spaces (y-1))
    		 in output_fn (spaces level ^ "\n")
    		 end
d170 4
a173 4
               val token_stream =
                 Lexer.mkFileTokenStream (stream, filename)
                   
               fun next context =
d175 1
a175 1
                   (close_in stream; context)
d181 1
a181 1
                       (context, Compiler.TOKENSTREAM1 token_stream)
d185 1
a185 1
			 (context, source_result)
d188 8
a195 6
                       output_fn
                       (ShellTypes.get_error_info shell_data)
                       (new_context,
			ShellTypes.make_printer_descriptor shell_data,
			0, identifiers);
                     next (aux (new_context,level+1))
d197 9
a205 10
             in
               next context
               handle
                 exn as Error _ => raise exn
               | exn =>
                  (raise Error (implode ["Error using `", filename, "'\n"],
                                context))
             end
             handle exn as Io s =>
               raise Error (s ^ "\n", context)
d207 1
a207 1
          (context, filenames)
a209 2
      val context_ref = ShellTypes.get_context_ref shell_data

d212 1
a212 1
        context_ref := aux (!context_ref, 0)
@


1.7
log
@Use get_context_ref function
@
text
@d7 3
a179 2

		     val _ = ShellTypes.update_options shell_data
@


1.6
log
@do_actions now takes a single ShellData argument.  Changes to options
during a use now take immediate effect.
@
text
@d7 5
d97 1
a97 2
  fun do_actions (shell_data as ShellTypes.SHELL_DATA
		    {context_ref, output_fn, ...}) =
d205 3
d209 1
a209 2
        (* this probably should be more intelligent about possible
         concurrent updates *)
d211 2
a212 1
        handle Error (s,context) => output_fn s
@


1.5
log
@ Changed context parameter to be a reference, which is side-effected.do_actions now returns unit.
Uses Incremental.compile_source & Incremental.add_definitions
(Incremental.add_source has been removed)
@
text
@d7 5
d29 1
a29 1
require "incremental";
d37 3
a39 1
  structure Incremental : INCREMENTAL
d41 2
a42 1
  sharing Incremental.InterMake.Compiler = InterPrint.Compiler
d44 5
a48 2
  sharing type InterPrint.Context = Incremental.Context
  sharing type Lexer.TokenStream = Incremental.InterMake.Compiler.tokenstream
d51 1
a51 1
  structure Incremental = Incremental
d59 1
d92 2
a93 1
  fun do_actions (level, context_ref, do_output, options, print_method_table) =
a96 13
      val printer_descriptor =
        let val
          Incremental.OPTIONS{options=Options.OPTIONS{print_options,...},...}
          = options
        in
          ValuePrinter.PRINTER_DESCRIPTOR
          {print_options = print_options,
           print_method_table = print_method_table}
        end
        
      fun get_error_info (Incremental.OPTIONS {error_info,...}) =
        error_info

d106 3
a108 1
             Incremental.delete_module options (context, filename)
d112 3
a114 1
                 Incremental.add_module options (context, filename)
d117 6
a122 4
                  do_output
                  (get_error_info options)
                  (new_context, printer_descriptor, 0, identifiers);
                  new_context
d158 1
a158 1
    		 in do_output (spaces level ^ "\n")
d170 2
a171 1
                       Incremental.compile_source options
d173 3
d177 2
a178 1
                       Incremental.add_definitions (context,source_result)
d181 6
a186 4
                       do_output
                       (get_error_info options)
                       (new_context,printer_descriptor, 0, identifiers);
                       next (aux (new_context,level+1))
d204 2
a205 2
        context_ref := aux (!context_ref,level)
        handle Error (s,context) => do_output s
@


1.4
log
@Changed error output to use output function.
@
text
@d7 3
d80 1
a80 1
  fun do_actions (level, context, do_output, options, print_method_table) =
d163 5
a167 3
                     val (context, identifiers) =
                       Incremental.add_source options
                         (context, Compiler.TOKENSTREAM1 token_stream)
d172 2
a173 2
                       (context,printer_descriptor, 0, identifiers);
                       next (aux (context,level+1))
d188 6
a193 4
    in
      aux (context,level)
      handle Error (s,context) => (do_output s; context)
           | exn => context
@


1.3
log
@Options changes
@
text
@d7 3
d77 1
a77 1
  fun do_actions (level, context, consumer, options, print_method_table) =
d110 1
a110 1
                  consumer
d149 1
a149 1
    		 in consumer (spaces level ^ "\n")
d165 1
a165 1
                       consumer
d185 1
a185 1
      handle Error (s,context) => (output(std_out,s);context)
@


1.2
log
@Options & Info changes
@
text
@d7 3
d80 1
a80 1
          Incremental.OPTIONS{options=Options.OPTIONS(_,_,print_options),...}
d107 1
a107 1
                  std_out
d134 1
a134 1
                 if size filename < 4 orelse
d137 1
a137 1
                 else filename           
d162 1
a162 1
                       std_out
d165 1
a165 1
                     next (aux (context,level+1))
@


1.1
log
@Initial revision
@
text
@d6 4
a9 1
 *  $Log$
d14 2
d21 1
d23 6
d31 1
a31 1
  structure Incremental = InterPrint.Incremental
d34 3
a36 1
  structure Lexer = Compiler.Parser.Lexer
d38 1
a38 1
  type printer_descriptor = InterPrint.ValuePrinter.printer_descriptor
d48 1
a48 1
  fun parse_absolute (filename, info_opts) =
d53 3
a55 4
         Lexer.Info.error' info_opts
                           (Lexer.Info.FATAL, 
                            Lexer.Info.Location.UNKNOWN, 
                            "Invalid Filename : " ^ filename))
d71 1
a71 1
  fun do_actions (level, context, consumer, options, print_options) =
d73 1
a73 1
      exception Error of (string * Incremental.context)
d75 12
a86 7
      fun get_info_opts options =
        case options of
          Incremental.OPTIONS {
            compiler_options = Compiler.MirTypes.OPTIONS {info_opts, ...},
            ...
          } =>
          info_opts
d105 2
a106 2
                  (get_info_opts options)
                  (new_context, print_options, 0, identifiers);
d160 2
a161 2
                       (get_info_opts options)
                       (context,print_options, 0, identifiers);
@
