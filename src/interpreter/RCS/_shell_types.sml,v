head	1.40;
access;
symbols
	MLW_daveb_inline_1_4_99:1.40.11
	MLWorks_21c0_1999_03_25:1.40
	MLWorks_20c1_1998_08_20:1.40
	MLWorks_20c0_1998_08_04:1.40
	MLWorks_20b2c2_1998_06_19:1.40
	MLWorks_20b2_Windows_1998_06_12:1.40
	MLWorks_20b1c1_1998_05_07:1.40
	MLWorks_20b0_1998_04_07:1.40
	MLWorks_20b0_1998_03_20:1.40
	MLWorks_20m2_1998_02_16:1.40
	MLWorks_20m1_1997_10_23:1.40
	MLWorks_11r1:1.40.8.1.1.1.1
	MLWorks_workspace_97:1.40.10
	MLWorks_dt_wizard:1.40.9
	MLWorks_11c0_1997_09_09:1.40.8.1.1.1
	MLWorks_10r3:1.40.8.1.3
	MLWorks_10r2_551:1.40.8.1.2
	MLWorks_11:1.40.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.40.8.1
	MLWorks_20m0_1997_06_20:1.40
	MLWorks_1_0_r2c2_1997_06_14:1.40.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.40.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.40.8
	MLWorks_BugFix_1997_04_24:1.40
	MLWorks_1_0_r2_Win32_1997_04_11:1.40
	MLWorks_1_0_r2_Unix_1997_04_04:1.40
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.40.6.1.1
	MLWorks_gui_1996_12_18:1.40.7
	MLWorks_1_0_Win32_1996_12_17:1.40.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.40.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.40.4.1
	MLWorks_1_0_Irix_1996_11_28:1.40.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.40.5
	MLWorks_1_0_Unix_1996_11_14:1.40.4
	MLWorks_Open_Beta2_1996_10_11:1.40.3
	MLWorks_License_dev:1.40.2
	MLWorks_1_open_beta_1996_09_13:1.40.1
	MLWorks_Open_Beta_1996_08_22:1.40
	MLWorks_Beta_1996_07_02:1.40
	MLWorks_Beta_1996_06_07:1.40
	MLWorks_Beta_1996_06_06:1.40
	MLWorks_Beta_1996_06_05:1.40
	MLWorks_Beta_1996_06_03:1.40
	MLWorks_Beta_1996_05_31:1.40
	MLWorks_Beta_1996_05_30:1.40
	ML_beta_release_12/08/94:1.28
	ML_beta_release_03/08/94:1.28
	ML_revised_beta_release_25/05/94:1.23
	ML_final_beta_release_02/03/94:1.23
	mlworks-28-01-1994:1.20
	Release:1.17
	mlworks-beta-01-09-1993:1.17;
locks; strict;
comment	@ * @;


1.40
date	96.02.05.17.30.52;	author daveb;	state Exp;
branches
	1.40.1.1
	1.40.2.1
	1.40.3.1
	1.40.4.1
	1.40.5.1
	1.40.6.1
	1.40.7.1
	1.40.8.1
	1.40.9.1
	1.40.10.1
	1.40.11.1;
next	1.39;

1.39
date	95.10.18.14.22.46;	author nickb;	state Exp;
branches;
next	1.38;

1.38
date	95.05.29.16.37.53;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	95.04.28.10.38.46;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	95.04.19.10.44.24;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	95.03.31.17.44.39;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	95.03.16.19.20.07;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	95.03.15.15.28.45;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	95.03.10.15.14.50;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	95.03.06.18.23.56;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	95.03.01.10.56.08;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	95.01.13.12.10.32;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	94.08.01.09.51.46;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	94.07.19.09.02.53;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	94.07.14.15.35.41;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	94.06.30.14.39.53;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	94.06.21.12.26.37;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	94.02.23.20.19.20;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	94.02.01.17.20.25;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	94.01.28.16.23.12;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.11.25.14.19.09;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.11.09.15.30.55;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	93.09.02.16.00.31;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.06.16.13.23.56;	author matthew;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	93.06.03.17.52.59;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	93.05.18.15.25.02;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	93.05.11.09.55.54;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	93.05.10.13.42.02;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	93.05.06.14.52.00;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.05.04.15.33.49;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.04.06.16.09.03;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	93.04.02.14.33.11;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.03.29.16.59.44;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.03.26.14.02.28;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.03.19.19.34.20;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.03.18.18.05.59;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.03.15.16.27.40;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.03.11.10.54.59;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.09.15.25.25;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.02.18.30.07;	author daveb;	state Exp;
branches;
next	;

1.17.1.1
date	93.06.16.13.23.56;	author jont;	state Exp;
branches;
next	;

1.40.1.1
date	96.09.13.11.15.55;	author hope;	state Exp;
branches;
next	;

1.40.2.1
date	96.10.07.16.06.01;	author hope;	state Exp;
branches;
next	;

1.40.3.1
date	96.10.17.11.24.18;	author hope;	state Exp;
branches;
next	;

1.40.4.1
date	96.11.14.12.48.56;	author hope;	state Exp;
branches
	1.40.4.1.1.1;
next	;

1.40.4.1.1.1
date	96.11.28.15.00.21;	author hope;	state Exp;
branches;
next	;

1.40.5.1
date	96.11.22.18.08.43;	author hope;	state Exp;
branches;
next	;

1.40.6.1
date	96.12.17.17.47.23;	author hope;	state Exp;
branches
	1.40.6.1.1.1;
next	;

1.40.6.1.1.1
date	97.02.24.11.37.07;	author hope;	state Exp;
branches;
next	;

1.40.7.1
date	96.12.18.09.41.23;	author hope;	state Exp;
branches;
next	;

1.40.8.1
date	97.05.12.10.33.50;	author hope;	state Exp;
branches
	1.40.8.1.1.1
	1.40.8.1.2.1
	1.40.8.1.3.1;
next	;

1.40.8.1.1.1
date	97.07.28.18.19.19;	author daveb;	state Exp;
branches
	1.40.8.1.1.1.1.1;
next	;

1.40.8.1.1.1.1.1
date	97.10.07.11.44.26;	author jkbrook;	state Exp;
branches;
next	;

1.40.8.1.2.1
date	97.09.08.17.12.54;	author daveb;	state Exp;
branches;
next	;

1.40.8.1.3.1
date	97.09.09.14.08.33;	author daveb;	state Exp;
branches;
next	;

1.40.9.1
date	97.09.10.19.23.48;	author brucem;	state Exp;
branches;
next	;

1.40.10.1
date	97.09.11.20.54.43;	author daveb;	state Exp;
branches;
next	;

1.40.11.1
date	99.04.01.17.56.46;	author daveb;	state Exp;
branches;
next	;


desc
@ Defines types used elsewhere in this directory.
@


1.40
log
@UserContext no longer includes a user_tool_options type.
@
text
@(* Types for passing to the shell and listener creation functions.
 *
 * Copyright (C) 1993 Harlequin Ltd.
 *
 * $Log: _shell_types.sml,v $
 *  Revision 1.39  1995/10/18  14:22:46  nickb
 *  Add profiler.
 *
 *  Revision 1.38  1995/05/29  16:37:53  daveb
 *  Separated user options into tool-specific and context-specific parts.
 *
 *  Revision 1.37  1995/04/28  10:38:46  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.36  1995/04/19  10:44:24  daveb
 *  Added set_context_name.
 *
 *  Revision 1.35  1995/03/31  17:44:39  daveb
 *  Added history number to each history item.
 *
 *  Revision 1.34  1995/03/16  19:20:07  daveb
 *  Merged get_context_name and string_context_name.
 *  
 *  Revision 1.33  1995/03/15  15:28:45  daveb
 *  Changed ShellData to hold a single user_context instead of a stack.
 *  
 *  Revision 1.32  1995/03/10  15:14:50  daveb
 *  Added a current selection to the user_context type, and functions
 *  to set and get this, and a registry for automatic update of a tool's
 *   current selection.
 *  
 *  Revision 1.31  1995/03/06  18:23:56  daveb
 *  Added context to history item type.  Added process_result function.
 *  
 *  Revision 1.30  1995/03/01  10:56:08  matthew
 *  Removing ValuePrinter from parameter
 *  
 *  Revision 1.29  1995/01/13  12:10:32  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *  
 *  Revision 1.28  1994/08/01  09:51:46  daveb
 *  Added get_current_preferences.
 *  
 *  Revision 1.27  1994/07/19  09:02:53  daveb
 *  Added register of update functions to user contexts.
 *  
 *  Revision 1.26  1994/07/14  15:35:41  daveb
 *  mk_xinterface_fn now has the type Podium_.ListenerArgs -> bool -> unit.
 *  
 *  Revision 1.25  1994/06/30  14:39:53  daveb
 *  Made source_map type concrete.
 *  Added save file name to user contexts.
 *  
 *  Revision 1.24  1994/06/21  12:26:37  daveb
 *  Replaced ContextRefs with user_contexts.  These store info about the
 *  evaluations done in the current user context, as well as the aggregate
 *  context.
 *  
 *  Revision 1.23  1994/02/23  20:19:20  daveb
 *  Changed naming scheme for contexts.
 *  
 *  Revision 1.22  1994/02/01  17:20:25  daveb
 *  Changed substructure of InterMake.
 *  
 *  Revision 1.21  1994/01/28  16:23:12  matthew
 *  Better locations in error messages
 *  
 *  Revision 1.20  1993/11/25  14:19:09  matthew
 *  Moved exception DebuggerTrapped from Shell for easier use elsewhere.
 *  
 *  Revision 1.19  1993/11/09  15:30:55  jont
 *  shell_data_ref initial value commented as only to initialise the ref
 *  
 *  Revision 1.18  1993/09/02  16:00:31  daveb
 *  Fixed non-exhaustive value binding.
 *  
 *  Revision 1.17  1993/06/16  13:23:56  matthew
 *  Changed context string to eg. MLWorks-1 from MLWorks%1
 *  
 *  Revision 1.16  1993/06/03  17:52:59  daveb
 *  Removed the context field from the prompter.
 *  
 *  Revision 1.15  1993/05/18  15:25:02  jont
 *  Removed integer parameter
 *  
 *  Revision 1.14  1993/05/11  09:55:54  daveb
 *  Added code to create, store and retreive an initial contextref.
 *  
 *  Revision 1.13  1993/05/10  13:42:02  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *  
 *  Revision 1.12  1993/05/06  14:52:00  matthew
 *  Simplified.  Removed ShellState type, removed printer_descriptor and print_method
 *  table fields.
 *  
 *  Revision 1.11  1993/05/04  15:33:49  matthew
 *  Added ContextRef type.
 *  
 *  Revision 1.10  1993/04/06  16:09:03  jont
 *  Moved user_options and version from interpreter to main
 *  
 *  Revision 1.9  1993/04/02  14:33:11  matthew
 *  Signature changes
 *  
 *  Revision 1.8  1993/03/29  16:59:44  matthew
 *  Added ShellState type
 *  Added shell_data_ref and with_shell_data
 *  
 *  Revision 1.7  1993/03/26  14:02:28  matthew
 *  Changed context_ref in ShellData to a list of context refs
 *  
 *  Revision 1.6  1993/03/19  19:34:20  matthew
 *  Added copy_listener_args
 *  
 *  Revision 1.5  1993/03/18  18:05:59  matthew
 *  Added output_fn field to shell_data
 *  
 *  Revision 1.4  1993/03/15  16:27:40  matthew
 *  Simplified types
 *  
 *  Revision 1.3  1993/03/11  10:54:59  matthew
 *  Options changes
 *  
 *  Revision 1.2  1993/03/09  15:25:25  matthew
 *  Added ShellData type and access functions
 *  
 *  Revision 1.1  1993/03/02  18:30:07  daveb
 *  Initial revision
 *  
 *)

require "user_context";
require "../main/user_options";
require "../main/preferences";
require "shell_types";

functor ShellTypes (
   structure UserContext: USER_CONTEXT
   structure UserOptions: USER_OPTIONS
   structure Preferences: PREFERENCES

   sharing UserOptions.Options = UserContext.Options

   sharing type UserOptions.user_context_options =
		UserContext.user_context_options
): SHELL_TYPES =
struct
  structure Options = UserOptions.Options

  type user_options = UserOptions.user_tool_options
  type user_preferences = Preferences.user_preferences
  type user_context = UserContext.user_context
  type Context = UserContext.Context
  type preferences = Preferences.preferences

  exception DebuggerTrapped

  datatype ListenerArgs = 
    LISTENER_ARGS of
    {user_context : user_context,
     user_options : user_options,
     user_preferences : user_preferences,
     prompter :
       {line : int, subline : int, name : string, topdec : int} -> string,
     mk_xinterface_fn : ListenerArgs -> bool -> unit}

  fun new_options (user_options, user_context) = 
    UserOptions.new_options
      (user_options, UserContext.get_user_options user_context)

  (* this is the data used by each shell *)
  datatype ShellData =
    SHELL_DATA of
    {get_user_context : unit -> user_context,
     user_options : user_options,
     user_preferences : user_preferences,
     prompter :
       {line : int, subline : int, name : string, topdec : int} -> string,
     debugger :
       (MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T) ->
       (MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T),
     profiler : MLWorks.Profile.profile -> unit,
     exit_fn : int -> unit,
     x_running : bool,
     mk_xinterface_fn : ListenerArgs -> bool -> unit,
     mk_tty_listener : ListenerArgs -> int}

  fun get_listener_args (SHELL_DATA{get_user_context,
                                    user_options,
                                    user_preferences,
                                    prompter,
                                    mk_xinterface_fn,
                                    ...}) =
    LISTENER_ARGS
      {user_context = get_user_context (),
       user_options = UserOptions.copy_user_tool_options user_options,
       user_preferences = user_preferences,
       prompter = prompter,
       mk_xinterface_fn = mk_xinterface_fn}

  fun get_current_options (SHELL_DATA{user_options, get_user_context, ...}) = 
    UserOptions.new_options
      (user_options, UserContext.get_user_options (get_user_context ()))

  fun get_current_preferences (SHELL_DATA{user_preferences,...}) = 
    Preferences.new_preferences user_preferences

  fun get_user_options (SHELL_DATA{user_options,...}) = 
    user_options

  fun get_user_preferences (SHELL_DATA{user_preferences,...}) = 
    user_preferences

  fun get_user_context
	(SHELL_DATA{get_user_context, ...}) =
    get_user_context ()

  fun get_current_context shell_data =
    UserContext.get_context (get_user_context shell_data)

  fun get_current_prompter (SHELL_DATA{prompter,...}) = prompter

  fun get_current_profiler (SHELL_DATA{profiler,...}) = profiler

  fun get_print_options (Options.OPTIONS{print_options,...}) = print_options

  fun get_current_print_options shell_data =
    get_print_options(get_current_options shell_data)

  exception BadShellData of string

  val shell_data_ref =
    (* This is a dummy value solely for initialising the reference *)
    ref
      (SHELL_DATA
         {get_user_context = fn () => UserContext.dummy_context,
          user_options =
            UserOptions.make_user_tool_options Options.default_options,
	  user_preferences =
	    Preferences.make_user_preferences Preferences.default_preferences,
          prompter = fn _ => raise BadShellData "prompter",
          debugger = fn _ => raise BadShellData "debugger",
	  profiler = fn _ => raise BadShellData "profiler",
	  exit_fn = fn _ => raise BadShellData "exit",
          x_running = false,
          mk_xinterface_fn = fn _ => raise BadShellData "xinterface",
          mk_tty_listener = fn _ => raise BadShellData "tty listener"})

  fun with_shell_data shell_data f =
    let
      val old_data = !shell_data_ref
      val _ = shell_data_ref := shell_data
      val result = f () handle exn => (shell_data_ref := old_data; raise exn)
    in
      shell_data_ref := old_data;
      result
    end

  val toplevel_name_ref = ref []

  fun get_current_toplevel_name () =
    case !toplevel_name_ref of
      (n::_) => n
    | _ => "Top Level"

  fun with_toplevel_name name f =
    let
      val previous = !toplevel_name_ref
      val _ = toplevel_name_ref := name :: !toplevel_name_ref;
      val result = (f ()) handle exn => (toplevel_name_ref := previous;raise exn)
    in
      toplevel_name_ref := previous;
      result
    end

end;
@


1.40.11.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.8.1
log
@branched from 1.40
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.40.8.1  1997/05/12  10:33:50  hope
 * branched from 1.40
 *
@


1.40.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.40.8.1  1997/05/12  10:33:50  hope
 * branched from 1.40
 *
@


1.40.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.40.8.1  1997/05/12  10:33:50  hope
 * branched from 1.40
 *
@


1.40.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.40.8.1.1.1  1997/07/28  18:19:19  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.40.7.1
log
@branched from 1.40
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.6.1
log
@branched from 1.40
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.6.1.1.1
log
@branched from 1.40.6.1
@
text
@a5 3
 * Revision 1.40.6.1  1996/12/17  17:47:23  hope
 * branched from 1.40
 *
@


1.40.5.1
log
@branched from 1.40
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.4.1
log
@branched from 1.40
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.4.1.1.1
log
@branched from 1.40.4.1
@
text
@a5 3
 * Revision 1.40.4.1  1996/11/14  12:48:56  hope
 * branched from 1.40
 *
@


1.40.3.1
log
@branched from 1.40
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.2.1
log
@branched from 1.40
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.40.1.1
log
@branched from 1.40
@
text
@a5 3
 * Revision 1.40  1996/02/05  17:30:52  daveb
 * UserContext no longer includes a user_tool_options type.
 *
@


1.39
log
@Add profiler.
@
text
@d6 3
a143 1
   sharing type UserOptions.user_tool_options = UserContext.user_tool_options
@


1.38
log
@Separated user options into tool-specific and context-specific parts.
@
text
@d6 3
d180 1
d221 2
d241 2
a242 1
          exit_fn = fn _ => raise BadShellData "exit",
@


1.37
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d6 3
d138 3
a140 1
   sharing type Preferences.preferences = UserOptions.preferences
d145 2
a146 1
  type user_options = UserOptions.user_options
d157 1
d162 4
d169 1
a169 1
    {user_context : user_context ref,
d171 1
d182 1
a182 1
  fun get_listener_args (SHELL_DATA{user_context,
d184 1
d189 3
a191 2
      {user_context = !user_context,
       user_options = UserOptions.copy user_options,
d195 3
a197 2
  fun get_current_options (SHELL_DATA{user_options,...}) = 
    UserOptions.new_options user_options
d199 2
a200 2
  fun get_current_preferences (SHELL_DATA{user_options,...}) = 
    UserOptions.new_preferences user_options
d205 3
d209 2
a210 2
	(SHELL_DATA{user_context, ...}) =
    !user_context
d228 1
a228 1
         {user_context = ref UserContext.dummy_context,
d230 3
a232 2
            UserOptions.make_user_options
              (Options.default_options, Preferences.default_preferences),
@


1.36
log
@Added set_context_name.
@
text
@d6 3
d12 110
a121 67
Revision 1.34  1995/03/16  19:20:07  daveb
Merged get_context_name and string_context_name.

Revision 1.33  1995/03/15  15:28:45  daveb
Changed ShellData to hold a single user_context instead of a stack.

Revision 1.32  1995/03/10  15:14:50  daveb
Added a current selection to the user_context type, and functions
to set and get this, and a registry for automatic update of a tool's
 current selection.

Revision 1.31  1995/03/06  18:23:56  daveb
Added context to history item type.  Added process_result function.

Revision 1.30  1995/03/01  10:56:08  matthew
Removing ValuePrinter from parameter

Revision 1.29  1995/01/13  12:10:32  daveb
Replaced Option structure with references to MLWorks.Option.

Revision 1.28  1994/08/01  09:51:46  daveb
Added get_current_preferences.

Revision 1.27  1994/07/19  09:02:53  daveb
Added register of update functions to user contexts.

Revision 1.26  1994/07/14  15:35:41  daveb
mk_xinterface_fn now has the type Podium_.ListenerArgs -> bool -> unit.

Revision 1.25  1994/06/30  14:39:53  daveb
Made source_map type concrete.
Added save file name to user contexts.

Revision 1.24  1994/06/21  12:26:37  daveb
Replaced ContextRefs with user_contexts.  These store info about the
evaluations done in the current user context, as well as the aggregate
context.

Revision 1.23  1994/02/23  20:19:20  daveb
Changed naming scheme for contexts.

Revision 1.22  1994/02/01  17:20:25  daveb
Changed substructure of InterMake.

Revision 1.21  1994/01/28  16:23:12  matthew
Better locations in error messages

Revision 1.20  1993/11/25  14:19:09  matthew
Moved exception DebuggerTrapped from Shell for easier use elsewhere.

Revision 1.19  1993/11/09  15:30:55  jont
shell_data_ref initial value commented as only to initialise the ref

Revision 1.18  1993/09/02  16:00:31  daveb
Fixed non-exhaustive value binding.

Revision 1.17  1993/06/16  13:23:56  matthew
Changed context string to eg. MLWorks-1 from MLWorks%1

Revision 1.16  1993/06/03  17:52:59  daveb
Removed the context field from the prompter.

Revision 1.15  1993/05/18  15:25:02  jont
Removed integer parameter

Revision 1.14  1993/05/11  09:55:54  daveb
Added code to create, store and retreive an initial contextref.
d123 1
a123 45
Revision 1.13  1993/05/10  13:42:02  daveb
Removed error_info field from ListenerArgs, ShellData and Incremental.options

Revision 1.12  1993/05/06  14:52:00  matthew
Simplified.  Removed ShellState type, removed printer_descriptor and print_method
table fields.

Revision 1.11  1993/05/04  15:33:49  matthew
Added ContextRef type.

Revision 1.10  1993/04/06  16:09:03  jont
Moved user_options and version from interpreter to main

Revision 1.9  1993/04/02  14:33:11  matthew
Signature changes

Revision 1.8  1993/03/29  16:59:44  matthew
Added ShellState type
Added shell_data_ref and with_shell_data

Revision 1.7  1993/03/26  14:02:28  matthew
Changed context_ref in ShellData to a list of context refs

Revision 1.6  1993/03/19  19:34:20  matthew
Added copy_listener_args

Revision 1.5  1993/03/18  18:05:59  matthew
Added output_fn field to shell_data

Revision 1.4  1993/03/15  16:27:40  matthew
Simplified types

Revision 1.3  1993/03/11  10:54:59  matthew
Options changes

Revision 1.2  1993/03/09  15:25:25  matthew
Added ShellData type and access functions

Revision 1.1  1993/03/02  18:30:07  daveb
Initial revision

*)

require "incremental";
require "interprint";
a125 3
require "../utils/lists";
require "../utils/newmap";
require "../utils/crash";
d128 2
a129 4
functor ShellTypes
  (structure Incremental: INCREMENTAL
   structure InterPrint: INTERPRINT
   structure Lists: LISTS
a131 2
   structure Map: NEWMAP
   structure Crash: CRASH
d133 1
a133 2
   sharing Incremental.InterMake.Compiler = InterPrint.Compiler
   sharing InterPrint.Compiler.Options = UserOptions.Options
a134 1
   sharing type InterPrint.Context = Incremental.Context
a137 1
  structure Incremental = Incremental
a138 1
  structure Info = Incremental.InterMake.Compiler.Info
a139 1
  type ('a, 'b) map = ('a, 'b) Map.T
d141 2
a142 2
  type Context = Incremental.Context
  type IncrementalOptions = Incremental.options
a144 46
  datatype ContextName = CONTEXTNAME of string * int list
  (* Context names have the form MLWorks-0, MLWorks-1.2.1, etc. *)

  type identifier = Incremental.InterMake.Compiler.identifier
  type Result = Incremental.Result

(*
  datatype binding =
    VALUE of Absyn.Ident.ValId * BasisTypes.DataTypes.Typescheme
  | TYPE of Absyn.Ident.TyCon * BasisTypes.DataTypes.Tystr
  | STRUCTURE of Absyn.Ident.StrId * BasisTypes.DataTypes.Structure
  | SIGNATURE of Absyn.Ident.SigId * BasisTypes.Sigma
  | FUNCTOR of Absyn.Ident.FunId * BasisTypes.Phi
*)

  datatype history_entry =
    ITEM of int * identifier * Context * string * string
  (* An entry in the history list of a context contains the number of the
     entry in the history, the identifier that was defined, the delta context
     after evaluating it, the string version of the result of evaluation, and
     the source string.  This list is used directly by the history widget. *)

  datatype source_map =
    MAP of (identifier, string) Map.T
  (* This is used for finding the source that corresponds to an entry in
     the current user context.  *)

  val empty_source_map =
    MAP (Map.empty' Incremental.InterMake.Compiler.compare_identifiers)

  type register_key = int

  datatype user_context =
    USER_CONTEXT of
      {info: (Context * Context * history_entry list * source_map) ref,
       update_register: ((register_key, (unit -> unit)) Map.T * int) ref,
       select_register:
	 ((register_key,
	  (history_entry -> unit) * (unit -> UserOptions.user_options)) Map.T
	 * int) ref,
       selected: history_entry MLWorks.Option.option ref,
       name: ContextName ref,
       version_number: int ref,
       is_constant: bool,
       save_file: string MLWorks.Option.option ref}

a146 192
  val initialContext = ref MLWorks.Option.NONE

  val contextList = ref []

  fun makeInitialUserContext (context,name) =
    let
      val newcontext =
	USER_CONTEXT
	  {info = ref (context, context, [], empty_source_map),
	   name = ref (CONTEXTNAME(name, [])),
	   update_register = ref (Map.empty' op<, 0),
	   select_register = ref (Map.empty' op<, 0),
	   selected = ref MLWorks.Option.NONE,
	   version_number = ref 0,
	   is_constant = true,
	   save_file = ref MLWorks.Option.NONE} exception AlreadyInitialised
    in
      case !initialContext of
	MLWorks.Option.NONE => initialContext := MLWorks.Option.SOME newcontext
      | _ => raise AlreadyInitialised;
      contextList := [newcontext];
      newcontext
    end

  fun pushContext c = contextList := c :: (!contextList)

  fun getCurrentContexts () = !contextList

  fun copyUserContext
	(USER_CONTEXT
	   {info = ref (context, _, _, _),
	    name = ref (CONTEXTNAME(name, l)),
	    version_number = r,
	    ...}) =
    let
      val newcontext =
	USER_CONTEXT
	  {info =
	     ref (context, Incremental.empty_context, [], empty_source_map),
	   update_register = ref (Map.empty' op<, 0),
	   select_register = ref (Map.empty' op<, 0),
	   selected = ref MLWorks.Option.NONE,
	   name = ref (CONTEXTNAME(name, !r+1 :: l)),
	   version_number = ref 0,
	   is_constant = false,
	   save_file = ref MLWorks.Option.NONE}
    in
      r := !r + 1;
      pushContext newcontext;
      newcontext
    end

  fun set_selected
	(USER_CONTEXT {selected, select_register = ref (map, _), ...},
	 UserOptions.USER_OPTIONS ({set_selection, ...}, _),
	 entry) =
    if !set_selection then
      let
        fun do_select (_, (f, mk_user_options)) =
          let
            val UserOptions.USER_OPTIONS ({sense_selection, ...}, _) =
              mk_user_options ()
          in
	    if !sense_selection then
              f entry
            else
              ()
          end
      in
        selected := MLWorks.Option.SOME entry;
        Map.iterate do_select map
      end
    else
      ();

  fun get_selected
	(USER_CONTEXT {selected,  ...},
	 UserOptions.USER_OPTIONS ({sense_selection, ...}, _)) =
    if !sense_selection then
      !selected
    else
      MLWorks.Option.NONE

  fun add_select_fn
	(USER_CONTEXT {select_register as ref (map, count), ...}, select_fn) =
    (select_register := (Map.define (map, count, select_fn), count + 1);
     count)

  fun remove_select_fn
	(USER_CONTEXT {select_register as ref (map, count), ...}, key) =
    select_register := (Map.undefine (map, key), count)

  fun add_update_fn
	(USER_CONTEXT {update_register as ref (map, count), ...}, update_fn) =
    (update_register := (Map.define (map, count, update_fn), count + 1);
     count)

  fun remove_update_fn
	(USER_CONTEXT {update_register as ref (map, count), ...}, key) =
    update_register := (Map.undefine (map, key), count)

  local
    fun string_index_list (str, [], l) = implode (str :: "-" :: l)
    |   string_index_list (str, x::t, []) =
      string_index_list (str, t, [MLWorks.Integer.makestring x])
    |   string_index_list (str, x::t, l) =
      string_index_list (str, t, MLWorks.Integer.makestring x :: "." :: l)
  
    fun string_context_name (CONTEXTNAME(str, [])) = str
    |   string_context_name (CONTEXTNAME(str, index)) =
      string_index_list (str, index, [])
  in
    fun get_context_name (USER_CONTEXT {name, is_constant, ...}) =
      let
	val str = string_context_name (!name)
      in 
	if is_constant then
	  str ^ " (Read Only)"
	else
	  str
      end

    fun set_context_name (USER_CONTEXT {name, is_constant, ...}, new_name) =
      name := CONTEXTNAME (new_name, [1])
  end
  
  fun getNewInitialContext () =
    case !initialContext
    of MLWorks.Option.SOME user_context =>
      let
	val c = copyUserContext (user_context)
      in
	case c of
	  USER_CONTEXT {name as ref (CONTEXTNAME (_, l)), ...} =>
	    name := CONTEXTNAME ("MLWorks", l);
        c
      end
    |  _ => Crash.impossible "Bad initial context!"

  fun get_saved_file_name (USER_CONTEXT {save_file, ...}) = !save_file

  fun set_saved_file_name (USER_CONTEXT {save_file, ...}, name) =
    save_file := MLWorks.Option.SOME name

  fun get_context_info (USER_CONTEXT {info,...}) = !info

  fun set_context_info
	(USER_CONTEXT {info, update_register as ref (map, _), ...}, newinfo) =
    (info := newinfo;
     Map.iterate (fn (_, f) => f()) map)

  fun get_context (USER_CONTEXT {info,...}) = #1(!info)

  fun is_const_context (USER_CONTEXT r) = #is_constant r

  fun process_result (src, result, user_context, options, output_fn) =
    let
      val (c, delta, hist, MAP smap) =
        get_context_info user_context

      val new_delta = Incremental.add_definitions(options, delta, result)

      val new_context = Incremental.add_definitions (options, c, result)

      val result_strings =
        InterPrint.strings
	  (new_context, options,
	   Incremental.identifiers_from_result result,
	   Incremental.pb_from_result result);

      val current_index =
	case hist
	of [] => 0
	|  (ITEM (n, _, _, _, _) :: _) => n

      val new_hist =
        Lists.reducel
        (fn ((n, l), (id, s)) => (n+1, ITEM (n+1, id, new_delta, s, src) :: l))
	((current_index, hist), result_strings)

      val new_smap =
        Lists.reducel
          (fn (map, (id, _)) => Map.define (map, id, src))
          (smap, result_strings)

    in
      Lists.iterate (fn (_, s) => output_fn s) result_strings;
      set_context_info
        (user_context,
         (new_context, new_delta, #2 new_hist, MAP new_smap))
    end

d195 1
a195 3
    let val USER_CONTEXT {info, ...} = get_user_context shell_data
    in #1 (!info)
    end
a203 4
  fun make_incremental_options (shell_data as SHELL_DATA{debugger,...}) =
    Incremental.OPTIONS {options = get_current_options shell_data,
                         debugger=debugger}

d208 12
a219 26
    let
      val dummy_context =
        USER_CONTEXT
          {info = ref (Incremental.empty_context, Incremental.empty_context,
                       [], empty_source_map),
           name = ref (CONTEXTNAME("", [])),
           update_register = ref (Map.empty' op<, 0),
           select_register = ref (Map.empty' op<, 0),
	   selected = ref MLWorks.Option.NONE,
           version_number = ref 0,
           is_constant = true,
           save_file = ref MLWorks.Option.NONE} exception AlreadyInitialised
    in
      ref
        (SHELL_DATA
           {user_context = ref dummy_context,
            user_options =
	      UserOptions.make_user_options
	        (Options.default_options, Preferences.default_preferences),
            prompter = fn _ => raise BadShellData "prompter",
            debugger = fn _ => raise BadShellData "debugger",
            exit_fn = fn _ => raise BadShellData "exit",
            x_running = false,
            mk_xinterface_fn = fn _ => raise BadShellData "xinterface",
            mk_tty_listener = fn _ => raise BadShellData "tty listener"})
    end
@


1.35
log
@Added history number to each history item.
@
text
@d6 3
d196 1
a196 1
       name: ContextName,
d212 1
a212 1
	   name = CONTEXTNAME(name, []),
d234 1
a234 1
	    name = CONTEXTNAME(name, l),
d245 1
a245 1
	   name = CONTEXTNAME(name, !r+1 :: l),
a254 46
  fun namedCopyUserContext
	(USER_CONTEXT
	   {info = ref (context, _, _, _),
	    name = CONTEXTNAME(_, l),
	    version_number = r,
	    ...},
	 name) =
    let
      val newcontext =
	USER_CONTEXT
	  {info =
	     ref (context, Incremental.empty_context, [], empty_source_map),
	   select_register = ref (Map.empty' op<, 0),
	   update_register = ref (Map.empty' op<, 0),
	   selected = ref MLWorks.Option.NONE,
	   name = CONTEXTNAME(name, !r+1 :: l),
	   version_number = ref 0,
	   is_constant = false,
	   save_file = ref MLWorks.Option.NONE}
    in
      r := !r + 1;
      pushContext newcontext;
      newcontext
    end

(*
  fun sense_selected
	(USER_CONTEXT {selected = MLWorks.Option.SOME entry,
		       select_register = ref (map, _), ...})
    let
      fun do_select (_, (f, mk_user_options)) =
        let
          val UserOptions.USER_OPTIONS ({sense_selection, ...}, _) =
            mk_user_options ()
        in
           if !sense_selection then
             f entry
           else
             ()
        end
    in
      Map.iterate do_select map
    end
  |   sense_selected _ = ()
*)

d304 25
d332 8
a339 1
      namedCopyUserContext (user_context, "MLWorks")
a357 22
  local
    fun string_index_list (str, [], l) = implode (str :: "-" :: l)
    |   string_index_list (str, x::t, []) =
      string_index_list (str, t, [MLWorks.Integer.makestring x])
    |   string_index_list (str, x::t, l) =
      string_index_list (str, t, MLWorks.Integer.makestring x :: "." :: l)
  
    fun string_context_name (CONTEXTNAME(str, [])) = str
    |   string_context_name (CONTEXTNAME(str, index)) =
      string_index_list (str, index, [])
  in
    fun context_name (USER_CONTEXT {name, is_constant, ...}) =
      let
	val name = string_context_name (name)
      in 
	if is_constant then
	  name ^ " (Read Only)"
	else
	  name
      end
  end
  
d467 1
a467 1
           name = CONTEXTNAME("", []),
@


1.34
log
@Merged get_context_name and string_context_name.
@
text
@d6 3
d167 6
a172 5
  datatype history_entry = ITEM of identifier * Context * string * string
  (* An entry in the history list of a context contains the identifier that
     was defined, the delta context after evaluating it, the string version of
     the result of evaluation, and the source string.  This list is used
     directly by the history widget. *)
d406 5
d412 3
a414 1
        map (fn (i, s) => ITEM (i, new_delta, s, src)) result_strings
d425 1
a425 1
         (new_context, new_delta, new_hist @@ hist, MAP new_smap))
@


1.33
log
@Changed ShellData to hold a single user_context instead of a stack.
@
text
@d6 3
d305 4
a308 4
             if !sense_selection then
               f entry
             else
               ()
d326 2
a327 2
	(USER_CONTEXT {select_register as ref (map, count), ...}, update_fn) =
    (select_register := (Map.define (map, count, update_fn), count + 1);
d365 21
a385 1
  fun get_context_name (USER_CONTEXT r) = #name r
a415 10

  fun string_index_list (str, [], l) = implode (str :: "-" :: l)
  |   string_index_list (str, x::t, []) =
    string_index_list (str, t, [MLWorks.Integer.makestring x])
  |   string_index_list (str, x::t, l) =
    string_index_list (str, t, MLWorks.Integer.makestring x :: "." :: l)

  fun string_context_name (CONTEXTNAME(str, [])) = str
  |   string_context_name (CONTEXTNAME(str, index)) =
    string_index_list (str, index, [])
@


1.32
log
@Added a current selection to the user_context type, and functions
to set and get this, and a registry for automatic update of a tool's
 current selection.
@
text
@d6 5
d415 1
a415 1
    {context_stack : user_context list ref,
d427 1
a427 3
  exception BadContextStack

  fun get_listener_args (SHELL_DATA{context_stack,
d432 5
a436 8
    (case context_stack of
       ref (user_context :: _) =>
         LISTENER_ARGS {user_context = user_context,
                        user_options = 
                          UserOptions.copy user_options,
                        prompter = prompter,
                        mk_xinterface_fn = mk_xinterface_fn}
     | _ => raise BadContextStack)
d448 2
a449 3
	(SHELL_DATA{context_stack = ref (user_context :: _),...}) =
    user_context
  |   get_user_context _ = raise BadContextStack
d451 1
a451 1
  fun get_user_context_info shell_data =
d453 1
a453 1
    in !info
a455 14
  fun set_user_context_info
	(SHELL_DATA
	   {context_stack =
	      ref (USER_CONTEXT {info, update_register as ref (map, _), ...}
		   :: _),
	    ...},
	 newinfo) =
    (info := newinfo;
     Map.iterate (fn (_, f) => f()) map)
  |   set_user_context_info _ = raise BadContextStack

  fun get_current_context shell_data =
    #1 (get_user_context_info shell_data)

d470 27
a496 13
    ref (SHELL_DATA
         {context_stack = ref [],
          user_options =
	    UserOptions.make_user_options
	      (Options.default_options, Preferences.default_preferences),
          prompter = fn _ => raise BadShellData "prompter",
          debugger = fn _ => raise BadShellData "debugger",
          exit_fn = fn _ => raise BadShellData "exit",
          x_running = false,
          mk_xinterface_fn = fn _ => raise BadShellData "xinterface",
          mk_tty_listener = fn _ => raise BadShellData "tty listener"
          })
  (* This is a dummy value solely for initialising the reference *)
@


1.31
log
@Added context to history item type.  Added process_result function.
@
text
@d6 3
d170 1
a170 1
  type update_fn_key = int
d175 6
a180 1
       register: ((update_fn_key, (unit -> unit)) Map.T * int) ref,
d198 3
a200 1
	   register = ref (Map.empty' op<, 0),
d227 3
a229 1
	   register = ref (Map.empty' op<, 0),
d252 3
a254 1
	   register = ref (Map.empty' op<, 0),
d265 61
d327 2
a328 2
	(USER_CONTEXT {register as ref (map, count), ...}, update_fn) =
    (register := (Map.define (map, count, update_fn), count + 1);
d332 2
a333 2
	(USER_CONTEXT {register as ref (map, count), ...}, key) =
    register := (Map.undefine (map, key), count)
d349 1
a349 1
	(USER_CONTEXT {info, register as ref (map, _), ...}, newinfo) =
d460 2
a461 1
	      ref (USER_CONTEXT {info, register as ref (map, _), ...} :: _),
@


1.30
log
@Removing ValuePrinter from parameter
@
text
@d6 3
d104 1
d107 1
d114 2
d121 2
a122 1
   sharing Incremental.InterMake.Inter_EnvTypes.Options = UserOptions.Options
d124 1
d142 10
d153 1
a153 1
  datatype history_entry = ITEM of identifier * string * string
d155 3
a157 2
     was defined, the string version of the result of evaluation, and the
     source string.  This list is used directly by the history widget. *)
d160 1
a160 1
    MAP of (Incremental.InterMake.Compiler.identifier, string) Map.T
d284 30
@


1.29
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d6 3
a99 1
require "../debugger/value_printer";
a108 1
   structure ValuePrinter: VALUE_PRINTER
d114 1
a114 2
   sharing ValuePrinter.Options =
     Incremental.InterMake.Inter_EnvTypes.Options = UserOptions.Options
@


1.28
log
@Added get_current_preferences.
@
text
@d6 3
a121 1
  structure Option = Incremental.InterMake.Option
d156 1
a156 1
       save_file: string Option.opt ref}
d160 1
a160 1
  val initialContext = ref Option.ABSENT
d173 1
a173 2
	   save_file = ref Option.ABSENT}
      exception AlreadyInitialised
d176 1
a176 1
	Option.ABSENT => initialContext := Option.PRESENT newcontext
d201 1
a201 1
	   save_file = ref Option.ABSENT}
d224 1
a224 1
	   save_file = ref Option.ABSENT}
d242 1
a242 1
    of Option.PRESENT user_context =>
d249 1
a249 1
    save_file := Option.PRESENT name
@


1.27
log
@Added register of update functions to user contexts.
@
text
@d6 3
d97 1
d103 1
a103 2
  (
   structure Incremental: INCREMENTAL
d106 1
d113 1
d125 1
d307 1
a307 1
                        UserOptions.make_user_options(UserOptions.new_options user_options),
d315 3
d360 3
a362 1
          user_options = UserOptions.make_user_options(Options.default_options),
@


1.26
log
@mk_xinterface_fn now has the type Podium_.ListenerArgs -> bool -> unit.
@
text
@d6 3
d139 2
d143 6
a148 2
      (Context * Context * history_entry list * source_map) ref
       * ContextName * int ref * bool * string Option.opt ref
d160 6
a165 5
	  (ref (context, context, [], empty_source_map),
	   CONTEXTNAME(name, []),
	   ref 0,
	   true,
	   ref Option.ABSENT)
d180 5
a184 1
	(USER_CONTEXT (ref (context, _, _, _), CONTEXTNAME(name, l), r, _, _)) =
d188 7
a194 5
	  (ref (context, Incremental.empty_context, [], empty_source_map),
	   CONTEXTNAME(name, !r+1 :: l),
	   ref 0,
	   false,
	   ref Option.ABSENT)
d202 5
a206 1
	(USER_CONTEXT (ref (context, _, _, _), CONTEXTNAME(_, l), r, _, _),
d211 7
a217 5
	  (ref (context, Incremental.empty_context, [], empty_source_map),
	   CONTEXTNAME(name, !r+1 :: l),
	   ref 0,
	   false,
	   ref Option.ABSENT)
d224 9
d239 1
a239 1
  fun get_saved_file_name (USER_CONTEXT {5=r, ...}) = !r
d241 2
a242 2
  fun set_saved_file_name (USER_CONTEXT {5=r, ...}, name) =
    r := Option.PRESENT name
d244 1
a244 1
  fun get_context_info (USER_CONTEXT {1=cref,...}) = !cref
d246 4
a249 1
  fun set_context_info (USER_CONTEXT {1=cref,...}, info) = cref := info
d251 1
a251 1
  fun get_context (USER_CONTEXT {1=cref,...}) = #1(!cref)
d253 1
a253 1
  fun is_const_context (USER_CONTEXT {4=b,...}) = b
d255 1
a255 1
  fun get_context_name (USER_CONTEXT {2=name,...}) = name
d263 2
a264 1
  fun string_context_name (CONTEXTNAME(str,index)) =
d318 2
a319 2
    let val USER_CONTEXT {1=cref, ...} = get_user_context shell_data
    in !cref
d323 7
a329 3
	(SHELL_DATA{context_stack = ref (USER_CONTEXT {1=cref, ...} :: _), ...},
	 context) =
    cref := context
@


1.25
log
@Made source_map type concrete.
Added save file name to user contexts.
@
text
@d6 4
d238 1
a238 1
     mk_xinterface_fn : ListenerArgs -> unit -> unit}
d252 1
a252 1
     mk_xinterface_fn : ListenerArgs -> unit -> unit,
@


1.24
log
@Replaced ContextRefs with user_contexts.  These store info about the
evaluations done in the current user context, as well as the aggregate
context.
@
text
@d6 5
d109 1
d118 1
d124 2
a125 1
  type source_map = (Incremental.InterMake.Compiler.identifier, string) Map.T
d130 1
a130 1
    Map.empty' Incremental.InterMake.Compiler.compare_identifiers
d135 1
a135 1
       * ContextName * int ref * bool
d150 2
a151 1
	   true)
d166 1
a166 1
	(USER_CONTEXT (ref (context, _, _, _), CONTEXTNAME(name, l), r, _)) =
d173 2
a174 1
	   false)
d182 2
a183 1
	(USER_CONTEXT (ref (context, _, _, _), CONTEXTNAME(_, l), r, _), name) =
d190 2
a191 1
	   false)
d204 5
d279 1
a279 1
    let val USER_CONTEXT(cref, _, _, _) = get_user_context shell_data
d284 1
a284 1
	(SHELL_DATA{context_stack = ref (USER_CONTEXT(cref, _, _, _) :: _),...},
@


1.23
log
@Changed naming scheme for contexts.
@
text
@d6 3
d82 1
d91 1
d109 19
a127 3
  datatype ContextRef = CONTEXTREF of Context ref * ContextName * int ref
  (* Each contextref the number of times it has been copied, for the naming
     scheme. *)
d131 3
a133 3
  val initialContext = ref []
   (* This isn't really a list, but we don't have an initial value to store,
      here, and an empty lost is a useful dummy. *)
d135 1
a135 1
  fun makeInitialContextRef (context,name) =
d137 6
a142 3
      val newcontext = CONTEXTREF(ref context,
				  CONTEXTNAME(name, []),
				  ref 0)
d146 1
a146 1
	[] => initialContext := [newcontext]
d148 1
a151 2
  val contextList = ref []

d156 2
a157 1
  fun copyContextRef (CONTEXTREF (ref context, CONTEXTNAME(name, l), r)) =
d160 5
a164 1
	CONTEXTREF(ref context, CONTEXTNAME(name, !r+1 :: l), ref 0)
d171 2
a172 2
  fun namedCopyContextRef
	(CONTEXTREF (ref context, CONTEXTNAME(_, l), r), name) =
d175 5
a179 1
	CONTEXTREF(ref context, CONTEXTNAME(name, !r+1 :: l), ref 0)
d188 2
a189 1
    of [contextRef] => namedCopyContextRef (contextRef, "MLWorks")
d192 5
a196 1
  fun get_context_ref (CONTEXTREF (cref,_,_)) = cref
d198 1
a198 1
  fun set_context_ref (CONTEXTREF (cref,_,_),context) = cref := context
d200 1
a200 1
  fun get_context_name (CONTEXTREF (cref,name,_)) = name
d213 1
a213 1
    {context_ref : ContextRef,
d222 1
a222 1
    {context_stack : ContextRef list ref,
d242 2
a243 2
       ref (context_ref :: _) =>
         LISTENER_ARGS {context_ref = context_ref,
a249 10
  fun get_shell_context_ref (SHELL_DATA{context_stack = ref (context_ref :: _),...}) =
    context_ref
    | get_shell_context_ref _ = raise BadContextStack

  fun get_current_context shell_data =
    let val CONTEXTREF(ref context,_,_) = get_shell_context_ref shell_data
    in
      context
    end

d256 8
a263 4
  fun set_current_context (shell_data,context) =
    let val CONTEXTREF(cref,_,_) = (get_shell_context_ref shell_data)
    in
      cref := context
d266 9
d279 2
a280 1
  fun get_current_print_options shell_data = get_print_options(get_current_options shell_data)
@


1.22
log
@Changed substructure of InterMake.
@
text
@d6 3
d103 4
a106 2
  datatype ContextName = CONTEXTNAME of string * int
  datatype ContextRef = CONTEXTREF of Context ref * ContextName
a109 13
  local
    val context_index = ref 0
  in
    fun next_context_index () =
      let val result = !context_index
      in
        context_index:= result + 1;
        result
      end
  end

  val getContextId = next_context_index

d117 2
a118 1
				  CONTEXTNAME(name, next_context_index()))
d133 1
a133 1
  fun copyContextRef (CONTEXTREF (ref context, CONTEXTNAME(name,_))) =
d135 2
a136 1
      val newcontext = CONTEXTREF(ref context, CONTEXTNAME(name,next_context_index()))
d138 1
d143 2
a144 1
  fun namedCopyContextRef (CONTEXTREF (ref context, contextname),name) =
d146 2
a147 1
      val newcontext = CONTEXTREF(ref context, CONTEXTNAME(name,next_context_index()))
d149 1
d159 1
a159 1
  fun get_context_ref (CONTEXTREF (cref,_)) = cref
d161 1
a161 1
  fun set_context_ref (CONTEXTREF (cref,_),context) = cref := context
d163 1
a163 1
  fun get_context_name (CONTEXTREF (cref,name)) = name
d165 6
d172 1
a172 1
    str ^ "-" ^ MLWorks.Integer.makestring index
d218 1
a218 1
    let val CONTEXTREF(ref context,_) = get_shell_context_ref shell_data
d230 1
a230 1
    let val CONTEXTREF(cref,_) = (get_shell_context_ref shell_data)
@


1.21
log
@Better locations in error messages
@
text
@d6 3
d94 1
a94 1
  structure Option = Incremental.InterMake.FileName.Option
@


1.20
log
@Moved exception DebuggerTrapped from Shell for easier use elsewhere.
@
text
@d6 3
d262 18
@


1.19
log
@shell_data_ref initial value commented as only to initialise the ref
@
text
@d6 3
d96 2
@


1.18
log
@Fixed non-exhaustive value binding.
@
text
@d6 3
d243 1
@


1.17
log
@Changed context string to eg. MLWorks-1 from MLWorks%1
@
text
@d6 3
d59 1
a59 2
 *
 *)
d64 1
d72 1
d143 3
a145 3
    let val [contextRef] = !initialContext
    in  namedCopyContextRef (contextRef, "MLWorks")
    end
@


1.17.1.1
log
@Fork for bug fixing
@
text
@a5 3
Revision 1.17  1993/06/16  13:23:56  matthew
Changed context string to eg. MLWorks-1 from MLWorks%1

@


1.16
log
@Removed the context field from the prompter.
@
text
@d6 3
d150 1
a150 1
    str ^ "%" ^ MLWorks.Integer.makestring index
@


1.15
log
@Removed integer parameter
@
text
@d6 3
d153 2
a154 1
     prompter : {line : int, subline : int, name : string, topdec : int, context : int} -> string,
d162 2
a163 1
     prompter : {line : int, subline : int, name : string, topdec : int, context : int} -> string,
d165 2
a166 2
     (MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T) ->
     (MLWorks.Internal.Value.T -> MLWorks.Internal.Value.T),
@


1.14
log
@Added code to create, store and retreive an initial contextref.
@
text
@d6 3
a52 1
require "../utils/integer";
d59 1
a59 1
  (structure Integer : INTEGER
d144 1
a144 1
    str ^ "%" ^ Integer.makestring index
@


1.13
log
@Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d6 3
d92 16
d130 3
a132 6
  fun makeContextRef (context,name) =
    let
      val newcontext = CONTEXTREF(ref context, CONTEXTNAME(name, next_context_index()))
    in
      pushContext newcontext;
      newcontext
@


1.12
log
@Simplified.  Removed ShellState type, removed printer_descriptor and print_method
table fields.
@
text
@d6 4
a131 1
     error_info : Info.options,
a139 2
     output_fn : string -> unit,
     error_info : Info.options,
a152 1
                                    error_info,
a160 1
                        error_info = error_info,
a188 2
  fun get_error_info (SHELL_DATA{error_info,...}) = error_info

d193 2
a194 3
  fun make_incremental_options (shell_data as SHELL_DATA{error_info,debugger,...}) =
    Incremental.OPTIONS {error_info = error_info,
                         options = get_current_options shell_data,
a202 2
          output_fn = fn _ => raise BadShellData "output function",
          error_info = Info.default_options,
@


1.11
log
@Added ContextRef type.
@
text
@d6 3
a65 2
  type printer_descriptor = ValuePrinter.printer_descriptor
  type print_method_table = ValuePrinter.print_method_table
a126 1
     print_method_table_ref : print_method_table ref,
a128 1
     name_monitor : (string -> unit) Option.T,
a131 6
  datatype ShellState = 
    SHELL_STATE of
    {context_ref : ContextRef,
     print_method_table_ref : print_method_table ref,
     user_options : user_options}

d135 2
a136 1
    {state_stack : ShellState list ref,
a138 1
     name_monitor : (string -> unit) Option.T,
d148 1
a148 10
  fun copy_shell_state (SHELL_STATE{context_ref,
                                    print_method_table_ref = ref print_method_table,
                                    user_options}) =
    SHELL_STATE
    {context_ref = copyContextRef context_ref,
     print_method_table_ref = ref print_method_table,
     user_options = UserOptions.make_user_options(UserOptions.new_options user_options)
     }
    
  exception BadShellStack
d150 2
a151 1
  fun get_listener_args (SHELL_DATA{state_stack,
a152 1
                                    name_monitor,
d156 2
a157 2
    (case state_stack of
       ref (SHELL_STATE{context_ref,print_method_table_ref,user_options} :: _) =>
d159 2
a160 2
                        print_method_table_ref = print_method_table_ref,
                        user_options = user_options,
a161 1
                        name_monitor = name_monitor,
d164 1
a164 1
     | _ => raise BadShellStack)
d166 3
a168 2
  fun getShellState (SHELL_DATA{state_stack = ref ((SHELL_STATE state) :: _),...}) = state
    | getShellState _ = raise BadShellStack
d170 5
a174 10
  fun shell_state_fun f shell_data=
    f (getShellState shell_data)

  val get_current_context =
    shell_state_fun
    (fn {context_ref = CONTEXTREF(ref context,_),...} => context)

  val get_current_options = 
    shell_state_fun
    (fn {user_options,...} => UserOptions.new_options user_options)
d176 2
a177 3
  val get_current_print_method_table =
    shell_state_fun
    (fn {print_method_table_ref,...} => !print_method_table_ref)
d179 2
a180 3
  val get_shell_context_ref  =
     shell_state_fun 
     #context_ref
a181 4
  val get_user_options =
    shell_state_fun
    #user_options

d196 1
a196 1
  fun make_incremental_options (shell_data as SHELL_DATA{error_info,name_monitor,debugger,...}) =
a198 1
                         name_monitor = name_monitor,
a200 5
  fun make_printer_descriptor (shell_data) =
    ValuePrinter.PRINTER_DESCRIPTOR
    {print_options = get_print_options (get_current_options shell_data),
     print_method_table = get_current_print_method_table shell_data}

d205 2
a206 1
         {state_stack = ref [],
a208 1
          name_monitor = Option.ABSENT,
@


1.10
log
@Moved user_options and version from interpreter to main
@
text
@d6 3
d40 1
d46 5
a50 4
functor ShellTypes(
  structure Incremental: INCREMENTAL
  structure ValuePrinter: VALUE_PRINTER
  structure UserOptions: USER_OPTIONS
d52 2
a53 2
  sharing ValuePrinter.Options =
      Incremental.InterMake.Inter_EnvTypes.Options = UserOptions.Options
d68 55
a123 1

d125 1
a125 1
    {context_ref : Incremental.Context ref,
d135 1
a135 1
    {context_ref : Incremental.Context ref,
d155 1
a155 1
  fun copy_shell_state (SHELL_STATE{context_ref = ref context,
d159 1
a159 1
    {context_ref = ref context,
d191 1
a191 1
    (fn {context_ref,...} => !context_ref)
d201 1
a201 1
  val get_context_ref  =
d210 4
a213 1
    (get_context_ref shell_data) := context
@


1.9
log
@Signature changes
@
text
@d6 3
d39 1
a39 1
require "user_options";
@


1.8
log
@Added ShellState type
Added shell_data_ref and with_shell_data
@
text
@d6 4
d44 1
a44 1
  sharing ValuePrinter.Debugger_Types.Options =
d57 2
@


1.7
log
@Changed context_ref in ShellData to a list of context refs
@
text
@d6 3
d47 3
d57 1
a57 2
    {options_ref : Incremental.InterMake.Inter_EnvTypes.Options.options ref,
     context_ref : Incremental.Context ref,
d60 3
a62 3
     error_info : Incremental.InterMake.Compiler.Info.options,
     name_monitor : (string -> unit) Incremental.InterMake.FileName.Option.T,
     prompter : {line : int, subline : int, name : string, topdec : int} -> string,
d65 6
d74 1
a74 3
    {options_ref : Incremental.InterMake.Inter_EnvTypes.Options.options ref,
     contexts : (Incremental.Context ref) list ref,
     print_method_table_ref : print_method_table ref,
d76 3
a78 5
     user_options : user_options,
     error_info : Incremental.InterMake.Compiler.Info.options,
     name_monitor : (string -> unit) Incremental.InterMake.FileName.Option.T,
     prompter : {line : int, subline : int, name : string, topdec : int} -> string,
     break_function : string -> unit,
a79 1
     string ->
d87 10
a96 5
  fun make_incremental_options (SHELL_DATA{options_ref,error_info,name_monitor,debugger,...}) =
    Incremental.OPTIONS {error_info = error_info,
                         options = !options_ref,
                         name_monitor = name_monitor,
                         debugger=debugger}
d98 1
a98 6
  exception DuffShellData

  fun get_listener_args (SHELL_DATA{options_ref,
                                    contexts = ref (context_ref::_),
                                    print_method_table_ref,
                                    user_options,
d104 39
a142 16
    LISTENER_ARGS {options_ref = options_ref,
                   context_ref = context_ref,
                   print_method_table_ref = print_method_table_ref,
                   user_options = user_options,
                   error_info = error_info,
                   name_monitor = name_monitor,
                   prompter = prompter,
                   mk_xinterface_fn = mk_xinterface_fn}
    | get_listener_args _ = raise DuffShellData

  fun get_current_context (SHELL_DATA{contexts = ref (context_ref::_),...}) = !context_ref
    | get_current_context _ = raise DuffShellData
  fun set_current_context (SHELL_DATA{contexts = ref (context_ref::_),...},context) = context_ref := context
    | set_current_context _ = raise DuffShellData
  fun get_current_options (SHELL_DATA{options_ref,...}) = !options_ref
  fun get_current_print_method_table (SHELL_DATA{print_method_table_ref,...}) = !print_method_table_ref
d145 1
a147 3
  fun get_context_ref (SHELL_DATA{contexts = ref (context_ref::_),...}) = context_ref
    | get_context_ref _ = raise DuffShellData
    
d152 5
a156 26
  fun make_printer_descriptor (SHELL_DATA{options_ref,print_method_table_ref,...}) =
    ValuePrinter.PRINTER_DESCRIPTOR{print_options = get_print_options(!options_ref),
                                    print_method_table = (!print_method_table_ref)}

  fun update_options (SHELL_DATA{options_ref,user_options,...}) =
    options_ref := (UserOptions.new_options user_options)

  fun copy_listener_args 
    (LISTENER_ARGS {options_ref = ref options,
                    context_ref = ref context,
                    print_method_table_ref = ref print_method_table,
                    user_options,
                    error_info,
                    name_monitor,
                    prompter,
                    mk_xinterface_fn}) =
    LISTENER_ARGS {options_ref = ref options,
                   context_ref = ref context,
                   print_method_table_ref = ref print_method_table,
                   user_options = UserOptions.make_user_options options,
                   error_info = error_info,
                   name_monitor = name_monitor,
                   prompter = prompter,
                   mk_xinterface_fn = mk_xinterface_fn}


d158 30
@


1.6
log
@Added copy_listener_args
@
text
@d6 3
d64 1
a64 1
     context_ref : Incremental.Context ref,
d71 1
d87 2
d90 1
a90 1
                                    context_ref,
d106 1
d108 4
a111 2
  fun get_current_context (SHELL_DATA{context_ref,...}) = !context_ref
  fun set_current_context (SHELL_DATA{context_ref,...},context) = context_ref := context
d118 2
a119 1
  fun get_context_ref (SHELL_DATA{context_ref,...}) = context_ref
@


1.5
log
@Added output_fn field to shell_data
@
text
@d6 3
d83 13
a95 17
  fun get_listener_args (SHELL_DATA{options_ref = ref options,
                                  context_ref = ref context,
                                  print_method_table_ref = ref print_method_table,
                                  output_fn,
                                  user_options,
                                  error_info,
                                  name_monitor,
                                  prompter,
                                  debugger,
                                  exit_fn,
                                  x_running,
                                  mk_xinterface_fn,
                                  mk_tty_listener}) =
    LISTENER_ARGS {options_ref = ref options,
                   context_ref = ref context,
                   print_method_table_ref = ref print_method_table,
                   user_options = UserOptions.make_user_options options,
d121 20
@


1.4
log
@Simplified types
@
text
@d6 3
d60 1
d83 1
@


1.3
log
@Options changes
@
text
@d6 3
d39 13
d60 2
a61 1
     debugger	:
d65 5
a69 3
     prompter : ({line : int, subline : int, name : string, topdec : int} -> string)
     }
     
d76 1
a76 1
  fun copy_shell_data (SHELL_DATA{options_ref = ref options,
d82 1
d84 13
a96 29
                                  prompter}) =
    SHELL_DATA{options_ref = ref options,
               context_ref = ref context,
               print_method_table_ref = ref print_method_table,
               user_options = UserOptions.make_user_options options,
               error_info = error_info,
               name_monitor = name_monitor,
               debugger = debugger,
               prompter = prompter}

  fun copy_shell_data_with_context (SHELL_DATA{options_ref = ref options,
                                               context_ref,
                                               print_method_table_ref = ref print_method_table,
                                               user_options,
                                               error_info,
                                               name_monitor,
                                               debugger,
                                               prompter},
                                    context) =
    SHELL_DATA{options_ref = ref options,
               context_ref = ref context,
               print_method_table_ref = ref print_method_table,
               user_options = UserOptions.make_user_options options,
               error_info = error_info,
               name_monitor = name_monitor,
               debugger = debugger,
               prompter = prompter}
                                  
                                  
a116 43

  datatype ListenerArgs = 
    LISTENER_ARGS of
    ShellData * (ShellData -> unit -> unit)

  datatype ShellArgs =
    SHELL_ARGS of ShellData * (int -> unit) * bool * (ShellData -> unit -> unit) * (ListenerArgs -> int)


(*
  (* Clearly these types are far too complicated *)

  datatype ListenerArgs =
    LISTENER_ARGS of
      Incremental.options *
      Incremental.Context * 
      ({line : int, subline : int, name : string, topdec : int} -> string) *
      printer_descriptor *
      ( user_options *
        printer_descriptor *
        Incremental.options *
        Incremental.Context ref *
        ({line : int, subline : int, name : string, topdec : int} -> string) ->
          unit -> unit
      )

  datatype ShellArgs =
    SHELL_ARGS of
      ({line : int, subline : int, name : string, topdec : int} -> string) *
      Incremental.options *
      printer_descriptor *
      user_options *
      (int -> unit) *   (* exit function *)
      bool *            (* can we start X? *)
      ( user_options *
        printer_descriptor *
        Incremental.options *
        Incremental.Context ref *
        ({line : int, subline : int, name : string, topdec : int} -> string) ->
          unit -> unit
      ) *
      (ListenerArgs -> int)
*)
@


1.2
log
@Added ShellData type and access functions
@
text
@d6 3
d45 1
a45 1
     (Incremental.options * Incremental.Context ref * string) ->
d103 1
a103 1
  fun get_print_options (Options.OPTIONS(_,_,print_options)) = print_options
@


1.1
log
@Initial revision
@
text
@d5 4
a8 1
 * $Log$
d21 4
d28 1
a28 1

d31 83
d115 5
d124 2
a125 4
      ( Incremental.InterMake.Compiler.MirTypes.options *
        Incremental.InterMake.options
      ) *
      Incremental.context * 
d131 1
a131 2
        Incremental.InterMake.Compiler.BasisTypes.Info.options *
        Incremental.context ref *
d147 1
a147 2
        Incremental.InterMake.Compiler.BasisTypes.Info.options *
        Incremental.context ref *
d152 2
a154 1

@
