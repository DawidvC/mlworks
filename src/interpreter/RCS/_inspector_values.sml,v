head	1.32;
access;
symbols
	MLW_daveb_inline_1_4_99:1.32.4
	MLWorks_21c0_1999_03_25:1.32
	MLWorks_20c1_1998_08_20:1.32
	MLWorks_20c0_1998_08_04:1.32
	MLWorks_20b2c2_1998_06_19:1.32
	MLWorks_20b2_Windows_1998_06_12:1.32
	MLWorks_20b1c1_1998_05_07:1.32
	MLWorks_20b0_1998_04_07:1.32
	MLWorks_20b0_1998_03_20:1.32
	MLWorks_20m2_1998_02_16:1.32
	MLWorks_20m1_1997_10_23:1.32
	MLWorks_11r1:1.32.1.1.1.1.1
	MLWorks_workspace_97:1.32.3
	MLWorks_dt_wizard:1.32.2
	MLWorks_11c0_1997_09_09:1.32.1.1.1.1
	MLWorks_10r3:1.32.1.1.3
	MLWorks_10r2_551:1.32.1.1.2
	MLWorks_11:1.32.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.32.1.1
	MLWorks_20m0_1997_06_20:1.32
	MLWorks_1_0_r2c2_1997_06_14:1.32.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.32.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.32.1
	MLWorks_BugFix_1997_04_24:1.32
	MLWorks_1_0_r2_Win32_1997_04_11:1.32
	MLWorks_1_0_r2_Unix_1997_04_04:1.32
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.31.3.1.1
	MLWorks_gui_1996_12_18:1.31.4
	MLWorks_1_0_Win32_1996_12_17:1.31.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.31.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.31.1.1
	MLWorks_1_0_Irix_1996_11_28:1.31.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.31.2
	MLWorks_1_0_Unix_1996_11_14:1.31.1
	MLWorks_Open_Beta2_1996_10_11:1.29.1
	MLWorks_License_dev:1.28.2
	MLWorks_1_open_beta_1996_09_13:1.28.1
	MLWorks_Open_Beta_1996_08_22:1.28
	MLWorks_Beta_1996_07_02:1.27
	MLWorks_Beta_1996_06_07:1.27
	MLWorks_Beta_1996_06_06:1.27
	MLWorks_Beta_1996_06_05:1.27
	MLWorks_Beta_1996_06_03:1.27
	MLWorks_Beta_1996_05_31:1.27
	MLWorks_Beta_1996_05_30:1.27
	ML_beta_release_12/08/94:1.15
	ML_beta_release_03/08/94:1.15
	ML_revised_beta_release_25/05/94:1.14
	ML_final_beta_release_02/03/94:1.12
	mlworks-28-01-1994:1.10
	Release:1.8
	mlworks-beta-01-09-1993:1.8;
locks; strict;
comment	@ * @;


1.32
date	97.03.07.15.02.47;	author matthew;	state Exp;
branches
	1.32.1.1
	1.32.2.1
	1.32.3.1
	1.32.4.1;
next	1.31;

1.31
date	96.11.06.11.14.10;	author matthew;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1
	1.31.4.1;
next	1.30;

1.30
date	96.10.30.11.17.05;	author io;	state Exp;
branches;
next	1.29;

1.29
date	96.10.04.16.55.35;	author andreww;	state Exp;
branches
	1.29.1.1;
next	1.28;

1.28
date	96.08.06.15.22.21;	author andreww;	state Exp;
branches
	1.28.1.1
	1.28.2.1;
next	1.27;

1.27
date	96.04.30.09.40.41;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	96.03.19.17.06.16;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	96.02.15.10.55.44;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	96.02.15.10.45.52;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	95.12.27.13.33.58;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	95.10.19.15.46.35;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	95.10.13.23.51.51;	author brianm;	state Exp;
branches;
next	1.20;

1.20
date	95.10.09.22.19.53;	author brianm;	state Exp;
branches;
next	1.19;

1.19
date	95.08.10.14.51.28;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.07.25.15.58.29;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	95.05.11.11.19.40;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.03.24.16.09.46;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	94.06.09.16.00.47;	author nickh;	state Exp;
branches;
next	1.14;

1.14
date	94.05.05.13.49.11;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	94.03.11.14.08.10;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	94.02.28.08.44.11;	author nosa;	state Exp;
branches;
next	1.11;

1.11
date	94.02.14.16.21.03;	author nickh;	state Exp;
branches;
next	1.10;

1.10
date	93.11.30.13.53.43;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.09.16.15.55.04;	author nosa;	state Exp;
branches;
next	1.8;

1.8
date	93.08.09.14.05.34;	author nosa;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	93.05.18.15.13.33;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	93.05.05.11.40.31;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.04.23.16.37.42;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.04.23.14.50.04;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.04.20.10.23.57;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.04.01.11.03.42;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.03.12.15.26.37;	author matthew;	state Exp;
branches;
next	;

1.8.1.1
date	93.08.09.14.05.34;	author jont;	state Exp;
branches;
next	;

1.28.1.1
date	96.09.13.11.15.47;	author hope;	state Exp;
branches;
next	;

1.28.2.1
date	96.10.07.16.05.56;	author hope;	state Exp;
branches;
next	;

1.29.1.1
date	96.10.17.11.24.13;	author hope;	state Exp;
branches;
next	;

1.31.1.1
date	96.11.14.12.48.48;	author hope;	state Exp;
branches
	1.31.1.1.1.1;
next	;

1.31.1.1.1.1
date	96.11.28.15.00.16;	author hope;	state Exp;
branches;
next	;

1.31.2.1
date	96.11.22.18.08.36;	author hope;	state Exp;
branches;
next	;

1.31.3.1
date	96.12.17.17.47.17;	author hope;	state Exp;
branches
	1.31.3.1.1.1;
next	;

1.31.3.1.1.1
date	97.02.24.11.36.59;	author hope;	state Exp;
branches;
next	;

1.31.4.1
date	96.12.18.09.41.17;	author hope;	state Exp;
branches;
next	;

1.32.1.1
date	97.05.12.10.33.44;	author hope;	state Exp;
branches
	1.32.1.1.1.1
	1.32.1.1.2.1
	1.32.1.1.3.1;
next	;

1.32.1.1.1.1
date	97.07.28.18.19.43;	author daveb;	state Exp;
branches
	1.32.1.1.1.1.1.1;
next	;

1.32.1.1.1.1.1.1
date	97.10.07.11.44.51;	author jkbrook;	state Exp;
branches;
next	;

1.32.1.1.2.1
date	97.09.08.17.13.18;	author daveb;	state Exp;
branches;
next	;

1.32.1.1.3.1
date	97.09.09.14.08.56;	author daveb;	state Exp;
branches;
next	;

1.32.2.1
date	97.09.10.19.24.23;	author brucem;	state Exp;
branches;
next	;

1.32.3.1
date	97.09.11.20.55.06;	author daveb;	state Exp;
branches;
next	;

1.32.4.1
date	99.04.01.17.56.59;	author daveb;	state Exp;
branches;
next	;


desc
@tty inspector
@


1.32
log
@Fixing equality
@
text
@(* inspector utilities
 *
 * Copyright (C) 1993 Harlequin Ltd.
 *
 * $Log: _inspector_values.sml,v $
 * Revision 1.31  1996/11/06  11:14:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.30  1996/10/30  11:17:05  io
 * moving String from toplevel
 *
 * Revision 1.29  1996/10/04  16:55:35  andreww
 * [Bug #1592]
 * threading level argument to TYNAME
 *
 * Revision 1.28  1996/08/06  15:22:21  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml (and
 * originally due to those made to typechecker/_types.sml).
 *
 * Revision 1.27  1996/04/30  09:40:41  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.26  1996/03/19  17:06:16  matthew
 * Changed interface to Scheme functions
 *
 * Revision 1.25  1996/02/15  10:55:44  jont
 * ERROR becomes MLERROR
 *
Revision 1.24  1996/02/15  10:45:52  jont
ERROR becomes MLERROR

Revision 1.23  1995/12/27  13:33:58  jont
Removing Option in favour of MLWorks.Option

Revision 1.22  1995/10/19  15:46:35  matthew
Correcting misspelling of abbreviate.

Revision 1.21  1995/10/13  23:51:51  brianm
Adding support for abbreviated strings (needed by the Graphical Inspector).

Revision 1.20  1995/10/09  22:19:53  brianm
Adding string type test.

Revision 1.19  1995/08/10  14:51:28  daveb
Added types for different lengths of words, ints and reals.

Revision 1.18  1995/07/25  15:58:29  matthew
Adding utilities for graphical inspection

Revision 1.17  1995/05/11  11:19:40  matthew
Changing Scheme.generalises

Revision 1.16  1995/03/24  16:09:46  matthew
Replacing Tyfun_id etc. with Stamp

Revision 1.15  1994/06/09  16:00:47  nickh
New runtime directory structure.

Revision 1.14  1994/05/05  13:49:11  daveb
Datatypes.META_OVERLOADED has extra arguments.

Revision 1.13  1994/03/11  14:08:10  matthew
Added inspector_method functions

Revision 1.12  1994/02/28  08:44:11  nosa
Changed null type function handling to accomodate Monomorphic debugger decapsulation;
Extra TYNAME valenv for Modules Debugger.

Revision 1.11  1994/02/14  16:21:03  nickh
Moved convert_string to MLWorks.String.ml_string.

Revision 1.10  1993/11/30  13:53:43  matthew
Added is_abs field to TYNAME and METATYNAME
Don't inspect subcomponents of abstypes

Revision 1.9  1993/09/16  15:55:04  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.8  1993/08/09  14:05:34  nosa
Inspecting values of hidden types in debugger-window.

Revision 1.7  1993/05/18  15:13:33  jont
Removed integer parameter

Revision 1.6  1993/05/05  11:40:31  matthew
Fixed inspection of vectors.

Revision 1.5  1993/04/23  16:37:42  matthew
Changed is_valid_domain to always return true.  This seems OK

Revision 1.3  1993/04/20  10:23:57  matthew
Added inspect methods

Revision 1.2  1993/04/01  11:03:42  matthew
Removed printing stuff.

Revision 1.1  1993/03/12  15:26:37  matthew
Initial revision

 *)

require "^.basis.__int";
require "^.basis.__list";
require "../utils/lists";
require "../utils/crash";
require "../typechecker/types" ;
require "../typechecker/valenv";
require "../typechecker/scheme";
require "../rts/gen/tags";
require "../debugger/value_printer";

require "inspector_values";

functor InspectorValues(
  structure Lists : LISTS
  structure Crash : CRASH
  structure Types : TYPES
  structure Valenv : VALENV
  structure Scheme : SCHEME
  structure Tags : TAGS
  structure ValuePrinter : VALUE_PRINTER

  sharing Types.Datatypes = Valenv.Datatypes = Scheme.Datatypes

    ) : INSPECTOR_VALUES =
  struct

    structure Datatypes = Types.Datatypes
    structure NewMap = Datatypes.NewMap
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Options = Scheme.Options

    type Type = Datatypes.Type
    type options = Options.options

    val jump_vccs = true

    (* Inspect method table *)
    (* An inspect method is of type "ty -> {some record}".  Establish a method by
     using a value of type Dynamic *)
    
    val inspect_method_table = ref [] : (MLWorks.Internal.Value.ml_value * Type * Type) list ref

    fun delete_all_inspect_methods _ = inspect_method_table := []

    exception InspectMethodNotFound

    fun fify f x = x := f (!x)

    fun delete_method ran =
      let 
        fun pred (fun_value',ran',dom') =
          not (Types.type_eq (ran,ran',true,true))
      in
        fify (List.filter pred) inspect_method_table
      end
            
    fun insert_method (args as (_,ran,_)) = 
      (delete_method ran handle InspectMethodNotFound => ();
       inspect_method_table := args :: (!inspect_method_table))

    exception InspectMethodInvalidDomain
    exception InspectMethodInvalidType

(*
    fun is_valid_domain (Datatypes.RECTYPE _) = true
      | is_valid_domain (Datatypes.METARECTYPE _) = true
      | is_valid_domain _ = false
*)
    fun is_valid_domain _ = true

    fun add_inspect_method (fun_value,ty) =
      case ty of
        Datatypes.FUNTYPE(ran,dom) =>
          if is_valid_domain dom
            then insert_method (fun_value,ran,dom)
          else raise InspectMethodInvalidDomain
      | _ => raise InspectMethodInvalidType

    fun delete_inspect_method (fun_value,ty) =
      case ty of
        Datatypes.FUNTYPE(ran,dom) =>
          if is_valid_domain dom
            then delete_method ran
          else raise InspectMethodInvalidDomain
      | _ => raise InspectMethodInvalidType

    exception TryApply

    fun try_apply options ((method,ran,dom),(object,ty)) =
      let
        val Options.OPTIONS{compat_options=
                            Options.COMPATOPTIONS{old_definition,...},...}
          = options

        val binding_list =
          Scheme.generalises_map old_definition (ran,ty)
          handle Scheme.Mismatch => raise TryApply
          
        val result_type = Scheme.apply_instantiation (dom,binding_list)
      in
        ((MLWorks.Internal.Value.cast method) object,result_type)
      end

    exception ApplyAll

    (* Handlers not nice here, need a loop control variable or something *)

    fun apply_all options ([],(object,ty)) = raise ApplyAll
      | apply_all options (method_info::rest,dyn) =
        try_apply options (method_info,dyn)
        handle TryApply => apply_all options (rest,dyn)

    exception Value of string

    fun generate_underbar(x) = "_" (* ^ " (" ^ x ^ ") " *)

    exception Error of string

    fun error_notification (_,s) = raise Error s

    fun contag value =
      let
        val primary = MLWorks.Internal.Value.primary value
      in
        if primary = Tags.INTEGER0 orelse primary = Tags.INTEGER1 then
          MLWorks.Internal.Value.cast value : int
        else if primary = Tags.PAIRPTR then
          MLWorks.Internal.Value.cast (MLWorks.Internal.Value.sub (value, 0)) : int
        else
          raise Value "contag: not a constructor"
      end

    fun select field =
      if field < 0 then
        raise Value "select: negative field"
      else
        fn value =>
        let
          val primary = MLWorks.Internal.Value.primary value
        in
          if primary = Tags.PAIRPTR 
            then
              if field >= 2 
                then
                  raise Value "select: field >= 2 in pair"
              else
                MLWorks.Internal.Value.sub (value, field)
              else if primary = Tags.POINTER 
                     then
                       let
                         val (secondary, length) = MLWorks.Internal.Value.header value
                       in
                         if (secondary = Tags.INTEGER0 andalso field=0)
                           orelse (secondary = Tags.INTEGER1 andalso field=0)
                           then
                             MLWorks.Internal.Value.sub (value, 1)
                         else 
                           if secondary = Tags.RECORD then
                             if field >= length then
                               raise Value "select: field >= length in record"
                             else
                               MLWorks.Internal.Value.sub (value, field+1)
                           else
                             raise Value "select: invalid secondary"
                       end
                   else
                     raise Value "select: invalid primary"
        end
      
    fun get_list_values (value, acc) =
      let val primary = MLWorks.Internal.Value.primary value
      in
	if primary = Tags.INTEGER1 then
          if (MLWorks.Internal.Value.cast value : int) = 1 then
	    rev acc
	  else
	    raise Value "list: invalid integer"
        else if primary = Tags.PAIRPTR then
	  let val head = select 0 value
	      val tail = select 1 value
	  in
            get_list_values (tail, head :: acc)
	  end
        else
	  raise Value "invalid list"
      end

    (* kind of hacky scheme instantiation function *)

    fun scheme_instantiate (Datatypes.SCHEME (n,(ty,_)),tylist) =
      Types.apply (Datatypes.TYFUN(ty,n),tylist)
      | scheme_instantiate _ = raise Error "Yoicks"

    fun type_eq (ty1,ty2) = Types.type_eq (ty1,ty2,true,true)

    fun is_scalar_value (x,ty) = 
      let
        val primary = MLWorks.Internal.Value.primary x
      in
        primary = Tags.INTEGER0 orelse primary = Tags.INTEGER1
      end

    fun is_string_type ty = type_eq (Types.string_type,ty)

    fun is_ref_type (Datatypes.CONSTYPE (_,tyname)) =
      Types.has_ref_equality tyname
      | is_ref_type _ = false

    val string_abbreviation = ValuePrinter.string_abbreviation

    exception DuffUserMethod of exn

    fun get_inspector_values options debugger_print (object,ty) =
      let
          fun get_arg_type(Datatypes.METATYVAR(ref(_,object,_),_,_)) = get_arg_type object
            | get_arg_type(Datatypes.FUNTYPE (arg,_)) = arg
            | get_arg_type x = Datatypes.NULLTYPE
              
          fun get_next_part_of_type(Datatypes.METATYVAR(ref(_,object,_),_,_)) =
            get_next_part_of_type object
            | get_next_part_of_type x = x

          fun get_values' options dyn =
            get_values (apply_all options (!inspect_method_table,dyn))
            handle ApplyAll => get_values dyn
                 | exn => raise DuffUserMethod exn
            
          and get_values(object,ty as Datatypes.METATYVAR _) = 
              get_values(object,get_next_part_of_type ty)
            
            | get_values(object,Datatypes.META_OVERLOADED {1=ref ty,...}) = 
              get_values(object,get_next_part_of_type ty)
              
            | get_values(_,Datatypes.NULLTYPE) = []
              
            | get_values(object,Datatypes.FUNTYPE _) = []

            | get_values(object,
                              Datatypes.CONSTYPE
                              (tys,Datatypes.METATYNAME
                               (ref(tyfun as (Datatypes.TYFUN _)),
                                    _,_,_,_,_))) =
              get_values(object,Types.apply(tyfun,tys))

            | get_values(object,
                              Datatypes.CONSTYPE
                              (tys,Datatypes.METATYNAME
                               (ref(Datatypes.ETA_TYFUN tyname),_,_,_,_,_))) =
              get_values(object,Datatypes.CONSTYPE(tys,tyname))

            (* for encapsulated debugger... *)
            | get_values(object,
                         Datatypes.CONSTYPE
                         (tys,Datatypes.METATYNAME
                          (ref(Datatypes.NULL_TYFUN
                           (_,(ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))))),
                           name,n,b,ve,abs))) = 
              if debugger_print then 
                get_values(object,
                           Datatypes.CONSTYPE
                           (tys,
                            Datatypes.TYNAME(Types.make_stamp(),
                                             name,n,b,ve,NONE,
                                             abs,ve,0)))
                          (* put tyname level as 0 here since 
                             nothing useful is being done with it.*)
              else
                []

            | get_values(object,
                         Datatypes.CONSTYPE
                         (tys,Datatypes.METATYNAME
                            (ref(Datatypes.NULL_TYFUN(_,tyfun)),
                             name,n,b,ve,abs))) =
              if debugger_print then
                get_values(object,Datatypes.CONSTYPE(tys,
                               Datatypes.METATYNAME(tyfun,name,n,b,ve,abs)))
              else
                [] 
                       
            | get_values (object, ty as Datatypes.CONSTYPE(tys,tyname)) =
	      if Types.num_or_string_typep ty then []
              else if Types.tyname_eq (tyname,Types.bool_tyname) then []
              else if Types.tyname_eq (tyname,Types.list_tyname) then
                (case tys of
                   [ty] =>
                     let
                       val element_list = get_list_values (object,[])
                       val (_,tagged_list) =
                         Lists.reducel
                         (fn ((n,l),object) =>
                          (n+1,(Int.toString n,(object,ty))::l))
                         ((0,[]),element_list)
                     in
                       rev tagged_list
                     end
                 | _ => error_notification (object, "<list arity>"))
                   handle Value message => 
                     error_notification (object, "<" ^ message ^ ">")
                     
              else if Types.tyname_eq (tyname,Types.ml_value_tyname) then []
                

              else if Types.tyname_eq (tyname,Types.ref_tyname) then
                let
                  fun convert_ref value =
                    if
                      MLWorks.Internal.Value.primary value =
                                                  Tags.REFPTR andalso
                      MLWorks.Internal.Value.header value = (Tags.ARRAY, 1)
                      then
                        MLWorks.Internal.Value.cast value : 
                                         MLWorks.Internal.Value.T ref
                    else
                      error_notification (value,"Not a ref")
                in
                  case (tys, convert_ref object) of
                    ([ty], ref object) => [("ref",(object,ty))]
                  | _ => error_notification (object, "<ref arity>")
                end

              else if Types.tyname_eq (tyname,Types.array_tyname) then
                if MLWorks.Internal.Value.primary object = Tags.REFPTR
                  then
                    let
                      val (secondary, length) = 
                        MLWorks.Internal.Value.header object
                    in
                      if secondary = Tags.ARRAY
                        then
                          case tys of
                            [ty] =>
                              let
                                fun iterate (0,acc) = acc
                                  | iterate (n,acc) =
                                    iterate (n-1,(Int.toString (n-1),
                                                  MLWorks.Internal.Value.sub (object, n+2))::acc)
                                val subvalues = iterate (length,[])
                                val string_list =
                                  map (fn (s,object) => (s,(object,ty))) subvalues
                              in
                                string_list
                              end
                          | _ => error_notification (object, "array arity")
                      else
                        error_notification(object,"Array not an array")
                    end
                else error_notification(object,"Array not an ref")

              else if Types.tyname_eq (tyname,Types.vector_tyname) then
                case tys of
                  [ty] =>
                    let
                      val primary = MLWorks.Internal.Value.primary object
                      val (secondary, length) =
                        if primary = Tags.POINTER then
                          MLWorks.Internal.Value.header object
                        else
                          if primary = Tags.PAIRPTR then
                            (Tags.RECORD, 2)
                          else
                            (Tags.MLERROR, 0)
                      fun record_map (object, 2) f =
                        [f (MLWorks.Internal.Value.sub (object, 0)),
                         f (MLWorks.Internal.Value.sub (object, 1))]
                        | record_map (object, length) f =
                          let
                            fun iterate (list, 0) = list
                              | iterate (list, n) =
                                iterate ((f (MLWorks.Internal.Value.sub (object, n)))::list, n-1)
                          in
                            iterate ([], length)
                          end
                    in
                      if secondary = Tags.RECORD then
                        let
                          val element_list =
                            record_map
                            (object,length)
                            (fn x => x)
                          val (_,tagged_list) =
                            Lists.reducel
                            (fn ((n,l),object) =>
                             (n+1,(Int.toString n,(object,ty))::l))
                            ((0,[]),element_list)
                        in
                          rev tagged_list
                        end
                      else
                        if secondary = Tags.MLERROR then
                          error_notification(object,"<Vector not a pointer>")
                        else
                          error_notification (object,"<Vector not a record>")
                    end
                | _ => error_notification (object,"<Bad vector type>")
                
              else
                (* we have a non-builtin type here *)
                let
                  val primary = MLWorks.Internal.Value.primary object
                  val result = 
                    case tyname of 
                      Datatypes.TYNAME
                      (_,ty_name,_,_,
                       ref(val_map as Datatypes.VE(_,constructor_map)),
                       _,ref is_abs,_,_) => 
                        if is_abs orelse 
                           Datatypes.NewMap.is_empty constructor_map then []
                        else
                          let
                            val (domain,range) = 
                              Lists.unzip(NewMap.to_list_ordered
                                                            constructor_map)
                            val is_a_single_constructor = 
                                  (length domain = 1)
                            fun test_scheme 
                               (Datatypes.SCHEME(_,(Datatypes.FUNTYPE _,_))) = 
                              true
                              | test_scheme
                                (Datatypes.UNBOUND_SCHEME
                                                     (Datatypes.FUNTYPE _,_)) =
                                true
                              | test_scheme _ = false
                            val is_a_single_vcc = 
                              case range of
                                [x] => test_scheme x
                              | _ => false
                          in
                            if is_a_single_constructor andalso not is_a_single_vcc then []
                            else if is_a_single_vcc then
                              case domain of 
                                [name' as Ident.CON name] => 
                                  let
                                    val name = Symbol.symbol_name name
                                    val scheme = Valenv.lookup(name',val_map)
                                    val ty =
                                      (case scheme of
                                         Datatypes.SCHEME _ => scheme_instantiate(scheme,tys)
                                       | Datatypes.UNBOUND_SCHEME (ty',_) => ty'
                                       | Datatypes.OVERLOADED_SCHEME _ => Datatypes.NULLTYPE)
                                    val arg_type = get_arg_type ty
                                  in
                                    [(name, (object,arg_type))]
                                  end
                              | _ => error_notification(object,"(Problems in vcc code)")
                            else if primary = Tags.INTEGER0 orelse primary = Tags.INTEGER1 then []
                            else if primary = Tags.POINTER orelse primary = Tags.PAIRPTR then
                              let
                                val (code, packet) =
                                  if primary = Tags.PAIRPTR then
                                    (MLWorks.Internal.Value.sub (object,0),
                                     MLWorks.Internal.Value.sub (object,1))
                                  else
                                    (MLWorks.Internal.Value.sub (object,1),
                                     MLWorks.Internal.Value.sub (object,2))
                                val name' = Lists.nth(MLWorks.Internal.Value.cast(code),domain)
                                val name =
                                  case name' of
                                    Ident.CON x => Ident.Symbol.symbol_name x
                                  | _ => error_notification (object,"Can't figure out name")
                                val scheme = Valenv.lookup(name',val_map)
                                val ty =
                                  (case scheme of
                                     Datatypes.SCHEME _ => scheme_instantiate (scheme,tys)
                                   | Datatypes.UNBOUND_SCHEME(ty',_) => ty'
                                   | Datatypes.OVERLOADED_SCHEME _ => Datatypes.NULLTYPE)
                                val arg_type = get_arg_type ty
                              in
                                [(name,(packet,arg_type))]
                              end
                            handle Lists.Nth => error_notification(object,"lists.nth 2")
                                 else
                                   error_notification(object, "(Not INTEGER,POINTER,PAIR in expected datatype case)")
                          end
                    | _ => error_notification(object,"(Can't handle this part of the object)")
                in
                  case result of
                    [(_,x as (_,ty))] => 
                      if jump_vccs andalso not (is_ref_type ty) 
                        then get_values' options x 
                      else result
                  | _ => result
                end
            | get_values(object,ty as Datatypes.RECTYPE _) =
                 let
                   val dom =
                     map
                     (fn (Ident.LAB s) => Symbol.symbol_name s)
                     (Types.rectype_domain ty)
                   val range = Types.rectype_range ty
                   val primary = MLWorks.Internal.Value.primary object
                 in
                   if length dom = 0 then []
                   else
                     (* this should return a list of (label,string) pairs and a label -> (value,type) fn. *)
                     if primary = Tags.PAIRPTR orelse primary = Tags.POINTER then
                     let
                       fun get_elements ([],_) = []
                         | get_elements (ty::tys,pos) = 
                           (MLWorks.Internal.Value.sub (object,pos),ty)
                           :: get_elements(tys,pos+1)

                       val record_size =
                         if primary = Tags.PAIRPTR then
                           2
                         else
                           #2 (MLWorks.Internal.Value.header object)
                     in
                       if length range = record_size then
                         let
                           val labtyvals = Lists.zip (dom,get_elements(range, if record_size = 2 then 0 else 1))
                           val items =
                             map (fn (lab,(value,ty)) => (lab,(value,ty))) labtyvals
                         in
                           items
                         end
                       else 
                         error_notification(object,"(Record is not of correct size)")
                     end
                   else
                     case dom of
                       [] => []
                     | _ => error_notification(object,"(record pointer not found when expected)")
                 end

            | get_values _ = []
      in
        get_values' options (object,ty)
      end

  end
@


1.32.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 3
 * Revision 1.32  1997/03/07  15:02:47  matthew
 * Fixing equality
 *
@


1.32.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 3
 * Revision 1.32  1997/03/07  15:02:47  matthew
 * Fixing equality
 *
@


1.32.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 3
 * Revision 1.32  1997/03/07  15:02:47  matthew
 * Fixing equality
 *
@


1.32.1.1
log
@branched from 1.32
@
text
@a5 3
 * Revision 1.32  1997/03/07  15:02:47  matthew
 * Fixing equality
 *
@


1.32.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.32.1.1  1997/05/12  10:33:44  hope
 * branched from 1.32
 *
@


1.32.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.32.1.1  1997/05/12  10:33:44  hope
 * branched from 1.32
 *
@


1.32.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.32.1.1  1997/05/12  10:33:44  hope
 * branched from 1.32
 *
@


1.32.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.32.1.1.1.1  1997/07/28  18:19:43  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.31
log
@[Bug #1728]
__integer becomes __int
@
text
@d6 4
d298 17
d582 4
a585 2
                    [(_,x)] => if jump_vccs then get_values' options x 
                               else result
a633 13

    fun type_eq (ty1,ty2) = Types.type_eq (ty1,ty2,true,true)

    fun is_scalar_value (x,ty) = 
      let
        val primary = MLWorks.Internal.Value.primary x
      in
        primary = Tags.INTEGER0 orelse primary = Tags.INTEGER1
      end

    fun is_string_type (ty) = type_eq(Types.string_type,ty)

    val string_abbreviation = ValuePrinter.string_abbreviation
@


1.31.4.1
log
@branched from 1.31
@
text
@a5 4
 * Revision 1.31  1996/11/06  11:14:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.3.1
log
@branched from 1.31
@
text
@a5 4
 * Revision 1.31  1996/11/06  11:14:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.3.1.1.1
log
@branched from 1.31.3.1
@
text
@a5 3
 * Revision 1.31.3.1  1996/12/17  17:47:17  hope
 * branched from 1.31
 *
@


1.31.2.1
log
@branched from 1.31
@
text
@a5 4
 * Revision 1.31  1996/11/06  11:14:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.1.1
log
@branched from 1.31
@
text
@a5 4
 * Revision 1.31  1996/11/06  11:14:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.1.1.1.1
log
@branched from 1.31.1.1
@
text
@a5 3
 * Revision 1.31.1.1  1996/11/14  12:48:48  hope
 * branched from 1.31
 *
@


1.30
log
@moving String from toplevel
@
text
@d6 3
d100 1
a100 1
require "^.basis.__integer";
@


1.29
log
@[Bug #1592]
threading level argument to TYNAME
@
text
@d6 4
d97 2
a98 2
require "../basis/__integer";

d151 1
a151 1
        fify (Lists.filterp pred) inspect_method_table
d343 1
a343 1
                                             name,n,b,ve,MLWorks.Option.NONE,
d495 1
a495 1
                                  (Lists.length domain = 1)
d571 1
a571 1
                   if Lists.length dom = 0 then []
d587 1
a587 1
                       if Lists.length range = record_size then
@


1.29.1.1
log
@branched from 1.29
@
text
@a5 4
 * Revision 1.29  1996/10/04  16:55:35  andreww
 * [Bug #1592]
 * threading level argument to TYNAME
 *
@


1.28
log
@[Bug #1521]
Propagating changes made to typechecker/_scheme.sml (and
originally due to those made to typechecker/_types.sml).
@
text
@d6 5
d316 3
a318 1
                              (tys,Datatypes.METATYNAME(ref(tyfun as (Datatypes.TYFUN _)),_,_,_,_,_))) =
d323 2
a324 1
                              (tys,Datatypes.METATYNAME(ref(Datatypes.ETA_TYFUN tyname),_,_,_,_,_))) =
d330 4
a333 3
                         (tys,Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN(_,
                                                 (ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))))),
                                                   name,n,b,ve,abs))) = 
d339 4
a342 1
                                             name,n,b,ve,MLWorks.Option.NONE,abs,ve)))
d347 4
a350 3
                              Datatypes.CONSTYPE
                              (tys,Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN(_,tyfun)),
                                                        name,n,b,ve,abs))) =
d353 1
a353 1
                                                   Datatypes.METATYNAME(tyfun,name,n,b,ve,abs)))
d374 2
a375 1
                   handle Value message => error_notification (object, "<" ^ message ^ ">")
d384 2
a385 1
                      MLWorks.Internal.Value.primary value = Tags.REFPTR andalso
d388 2
a389 1
                        MLWorks.Internal.Value.cast value : MLWorks.Internal.Value.T ref
d402 2
a403 1
                      val (secondary, length) = MLWorks.Internal.Value.header object
d479 6
a484 2
                      Datatypes.TYNAME(_,ty_name,_,_,ref(val_map as Datatypes.VE(_,constructor_map)),_,ref is_abs,_) => 
                        if is_abs orelse Datatypes.NewMap.is_empty constructor_map then []
d487 7
a493 3
                            val (domain,range) = Lists.unzip(NewMap.to_list_ordered constructor_map)
                            val is_a_single_constructor = (Lists.length domain = 1)
                            fun test_scheme (Datatypes.SCHEME(_,(Datatypes.FUNTYPE _,_))) = 
d495 3
a497 1
                              | test_scheme (Datatypes.UNBOUND_SCHEME(Datatypes.FUNTYPE _,_)) =
@


1.28.2.1
log
@branched from 1.28
@
text
@a5 5
 * Revision 1.28  1996/08/06  15:22:21  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml (and
 * originally due to those made to typechecker/_types.sml).
 *
@


1.28.1.1
log
@branched from 1.28
@
text
@a5 5
 * Revision 1.28  1996/08/06  15:22:21  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml (and
 * originally due to those made to typechecker/_types.sml).
 *
@


1.27
log
@Removing MLWorks.Integer
@
text
@d6 3
d118 1
d121 1
d177 1
a177 1
    fun try_apply ((method,ran,dom),(object,ty)) =
d179 4
d184 1
a184 1
          Scheme.generalises_map (true,ran,ty)
d196 4
a199 4
    fun apply_all ([],(object,ty)) = raise ApplyAll
      | apply_all (method_info::rest,dyn) =
        try_apply (method_info,dyn)
        handle TryApply => apply_all (rest,dyn)
d284 1
a284 1
    fun get_inspector_values debugger_print (object,ty) =
d294 2
a295 2
          fun get_values' dyn =
            get_values (apply_all (!inspect_method_table,dyn))
d527 2
a528 1
                    [(_,x)] => if jump_vccs then get_values' x else result
d575 1
a575 1
        get_values'(object,ty)
@


1.26
log
@Changed interface to Scheme functions
@
text
@d6 3
d85 2
d346 1
a346 1
                          (n+1,(MLWorks.Integer.makestring n,(object,ty))::l))
d386 1
a386 1
                                    iterate (n-1,(MLWorks.Integer.makestring (n-1),
d434 1
a434 1
                             (n+1,(MLWorks.Integer.makestring n,(object,ty))::l))
@


1.25
log
@ERROR becomes MLERROR
@
text
@d6 3
d170 1
a170 1
          Scheme.generalises_map (ran,ty)
@


1.24
log
@ERROR becomes MLERROR
@
text
@d6 3
a8 3
# Revision 1.1  1996/02/15  10:45:43  jont
# Initial revision
#
@


1.23
log
@Removing Option in favour of MLWorks.Option
@
text
@d6 6
d404 1
a404 1
                            (Tags.ERROR, 0)
d432 1
a432 1
                        if secondary = Tags.ERROR then
@


1.22
log
@Correcting misspelling of abbreviate.
@
text
@d6 3
d307 1
a307 1
                                             name,n,b,ve,Datatypes.Option.ABSENT,abs,ve)))
@


1.21
log
@Adding support for abbreaviated strings (needed by the Graphical Inspector).
@
text
@d6 3
d562 1
a562 1
    val string_abbreaviation = ValuePrinter.string_abbreaviation
@


1.20
log
@Adding string type test.
@
text
@d6 3
d73 1
d84 1
d558 2
@


1.19
log
@Added types for different lengths of words, ints and reals.
@
text
@d6 3
d551 3
@


1.18
log
@Adding utilities for graphical inspection
@
text
@d6 3
d307 2
a308 5
            | get_values (object,Datatypes.CONSTYPE(tys,tyname)) =
              if Types.tyname_eq (tyname,Types.int_tyname) then []
                      
              else if Types.tyname_eq (tyname,Types.real_tyname) then []

a309 3
                      
              else if Types.tyname_eq (tyname,Types.string_tyname) then []
                      
@


1.17
log
@Changing Scheme.generalises
@
text
@d6 3
d543 8
@


1.16
log
@Replacing Tyfun_id etc. with Stamp
@
text
@d6 3
d142 1
a142 1
          handle Scheme.MisMatch _ => raise TryApply
@


1.15
log
@New runtime directory structure.
@
text
@d6 3
d280 5
a284 2
                get_values(object,Datatypes.CONSTYPE(tys,
                                                   Datatypes.TYNAME(Datatypes.Tyname_id.make_tyname_id(),name,n,b,ve,Datatypes.Option.ABSENT,abs,ve)))
@


1.14
log
@Datatypes.META_OVERLOADED has extra arguments.
@
text
@d6 3
d54 1
a54 1
require "../rts/tags";
@


1.13
log
@Added inspector_method functions
@
text
@d6 3
d250 1
a250 1
            | get_values(object,Datatypes.META_OVERLOADED(ref ty,_)) = 
@


1.12
log
@Changed null type function handling to accomodate Monomorphic debugger decapsulation;
Extra TYNAME valenv for Modules Debugger.
@
text
@d6 4
d80 17
a96 1
    fun insert_method args = inspect_method_table := args :: (!inspect_method_table)
d113 8
@


1.11
log
@Moved convert_string to MLWorks.String.ml_string.
@
text
@d6 3
d201 1
a201 1
    fun get_inspector_values (object,ty) =
d235 2
a236 1
                       
d238 10
a247 6
                              Datatypes.CONSTYPE
                              (tys,Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN(_,
                                            Datatypes.Option.PRESENT(tyfun))),name,n,b,ve,is_abs))) =
              get_values(object,Datatypes.CONSTYPE(tys,
                                                   Datatypes.METATYNAME(tyfun,name,n,b,ve,is_abs)))
    
d250 7
a256 2
                              (tys,Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN _),_,_,_,_,_))) = 
              [] 
d382 1
a382 1
                      Datatypes.TYNAME(_,ty_name,_,_,ref(val_map as Datatypes.VE(_,constructor_map)),_,ref is_abs) => 
@


1.10
log
@Added is_abs field to TYNAME and METATYNAME
Don't inspect subcomponents of abstypes
@
text
@d6 4
a187 40
      end

    fun convert_string s =
      let
        fun make_digits n =
          let
            val d1 = n mod 10
            val n1 = n div 10
            val d2 = n1 mod 10
            val n2 = n1 div 10
            val d3 = n2 mod 3
          in
            (d1,d2,d3)
          end
        fun aux ([],result) = implode (rev result)
          | aux (char::rest,result) =
            let val newbit =
              case char of 
                "\n" => ["n","\\"]
              | "\t" => ["t","\\"]
              | "\"" => ["\"","\\"]
              | "\\" => ["\\","\\"]
              | c =>
                  (if (ord c) < 32
                     then [chr (64 + ord c),"^","\\"]
                   else
                     if (ord c) >= 127
                       then
                         let val (d1,d2,d3) = make_digits (ord c)
                           fun to_digit n = chr (n + ord "0")
                         in
                           [to_digit d1,to_digit d2,to_digit d3,"\\"]
                         end
                     else
                       [c])
            in
              aux (rest, newbit @@ result)
            end
      in
        aux (explode s,[])
@


1.9
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d6 3
d261 1
a261 1
                              (tys,Datatypes.METATYNAME(ref(tyfun as (Datatypes.TYFUN _)),_,_,_,_))) =
d266 1
a266 1
                              (tys,Datatypes.METATYNAME(ref(Datatypes.ETA_TYFUN tyname),_,_,_,_))) =
d272 1
a272 1
                                            Datatypes.Option.PRESENT(tyfun))),name,n,b,ve))) =
d274 1
a274 1
                                                   Datatypes.METATYNAME(tyfun,name,n,b,ve)))
d278 1
a278 1
                              (tys,Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN _),_,_,_,_))) = 
d405 2
a406 2
                      Datatypes.TYNAME(_,ty_name,_,_,ref(val_map as Datatypes.VE(_,constructor_map)),_) => 
                        if Datatypes.NewMap.is_empty constructor_map then []
@


1.8
log
@Inspecting values of hidden types in debugger-window.
@
text
@d6 3
d225 1
a225 1
    fun scheme_instantiate (Datatypes.SCHEME (n,ty),tylist) =
d233 1
a233 1
          fun get_arg_type(Datatypes.METATYVAR(ref(_,object),_,_)) = get_arg_type object
d237 1
a237 1
          fun get_next_part_of_type(Datatypes.METATYVAR(ref(_,object),_,_)) =
d269 1
a269 1
                                            Datatypes.Option.PRESENT(tyfun))),name,n,b,ve))) = 
d271 1
a271 1
                                     Datatypes.METATYNAME(tyfun,name,n,b,ve)))
d408 4
a411 2
                            fun test_scheme (Datatypes.SCHEME(_,Datatypes.FUNTYPE _)) = true
                              | test_scheme (Datatypes.UNBOUND_SCHEME(Datatypes.FUNTYPE _)) = true
d428 1
a428 1
                                       | Datatypes.UNBOUND_SCHEME ty' => ty'
d454 1
a454 1
                                   | Datatypes.UNBOUND_SCHEME(ty') => ty'
@


1.8.1.1
log
@Fork for bug fixing
@
text
@a5 3
Revision 1.8  1993/08/09  14:05:34  nosa
Inspecting values of hidden types in debugger-window.

@


1.7
log
@Removed integer parameter
@
text
@d6 3
d265 9
a273 1
                              (tys,Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN _),_,_,_,_))) = []
@


1.6
log
@Fixed inspection of vectors.
@
text
@d6 3
a22 1
require "../utils/integer";
d32 7
a38 7
functor InspectorValues(structure Integer : INTEGER
                        structure Lists : LISTS
                        structure Crash : CRASH
                        structure Types : TYPES
                        structure Valenv : VALENV
                        structure Scheme : SCHEME
                        structure Tags : TAGS
d40 1
a40 1
                        sharing Types.Datatypes = Valenv.Datatypes = Scheme.Datatypes
d42 1
a42 1
                          ) : INSPECTOR_VALUES =
d281 1
a281 1
                          (n+1,(Integer.makestring n,(object,ty))::l))
d321 1
a321 1
                                    iterate (n-1,(Integer.makestring (n-1),
d369 1
a369 1
                             (n+1,(Integer.makestring n,(object,ty))::l))
@


1.5
log
@Changed is_valid_domain to always return true.  This seems OK
@
text
@d6 3
d306 1
a306 2
              else if Types.tyname_eq (tyname,Types.array_tyname) 
                     orelse Types.tyname_eq (tyname,Types.vector_tyname) then
d331 1
a331 2
                else
                  error_notification(object,"Array not an ref")
d333 47
@


1.4
log
@ Added facility to jump VCCs.  Controlled by jump_vccs variable
This should maybe be an option
Return error in user method as DuffUserMethod exception
@
text
@d60 1
d64 2
@


1.3
log
@Added inspect methods
@
text
@d6 3
d47 2
d215 2
d228 3
a230 2
            (get_values (apply_all (!inspect_method_table,dyn))
             handle ApplyAll => get_values dyn)
d333 63
d397 3
a399 62
                  case tyname of 
                    Datatypes.TYNAME(_,ty_name,_,_,ref(val_map as Datatypes.VE(_,constructor_map)),_) => 
                      if Datatypes.NewMap.is_empty constructor_map then []
                      else
                        let
                          val (domain,range) = Lists.unzip(NewMap.to_list_ordered constructor_map)
                          val is_a_single_constructor = (Lists.length domain = 1)
                          fun test_scheme (Datatypes.SCHEME(_,Datatypes.FUNTYPE _)) = true
                            | test_scheme (Datatypes.UNBOUND_SCHEME(Datatypes.FUNTYPE _)) = true
                            | test_scheme _ = false
                          val is_a_single_vcc = 
                            case range of
                              [x] => test_scheme x
                            | _ => false
                        in
                          if is_a_single_constructor andalso not is_a_single_vcc then []
                          else if is_a_single_vcc then
                            case domain of 
                              [name' as Ident.CON name] => 
                                let
                                  val name = Symbol.symbol_name name
                                  val scheme = Valenv.lookup(name',val_map)
                                  val ty =
                                    (case scheme of
                                       Datatypes.SCHEME _ => scheme_instantiate(scheme,tys)
                                     | Datatypes.UNBOUND_SCHEME ty' => ty'
                                     | Datatypes.OVERLOADED_SCHEME _ => Datatypes.NULLTYPE)
                                  val arg_type = get_arg_type ty
                                in
                                  [(name, (object,arg_type))]
                                end
                            | _ => error_notification(object,"(Problems in vcc code)")
                          else if primary = Tags.INTEGER0 orelse primary = Tags.INTEGER1 then []
                          else if primary = Tags.POINTER orelse primary = Tags.PAIRPTR then
                            let
                              val (code, packet) =
                                if primary = Tags.PAIRPTR then
                                  (MLWorks.Internal.Value.sub (object,0),
                                   MLWorks.Internal.Value.sub (object,1))
                                else
                                  (MLWorks.Internal.Value.sub (object,1),
                                   MLWorks.Internal.Value.sub (object,2))
                              val name' = Lists.nth(MLWorks.Internal.Value.cast(code),domain)
                              val name =
                                case name' of
                                  Ident.CON x => Ident.Symbol.symbol_name x
                                | _ => error_notification (object,"Can't figure out name")
                              val scheme = Valenv.lookup(name',val_map)
                              val ty =
                                (case scheme of
                                   Datatypes.SCHEME _ => scheme_instantiate (scheme,tys)
                                 | Datatypes.UNBOUND_SCHEME(ty') => ty'
                                 | Datatypes.OVERLOADED_SCHEME _ => Datatypes.NULLTYPE)
                              val arg_type = get_arg_type ty
                            in
                              [(name,(packet,arg_type))]
                            end
                          handle Lists.Nth => error_notification(object,"lists.nth 2")
                               else
                                 error_notification(object, "(Not INTEGER,POINTER,PAIR in expected datatype case)")
                        end
                  | _ => error_notification(object,"(Can't handle this part of the object)")
@


1.2
log
@Removed printing stuff.
@
text
@d6 3
d19 1
d24 7
a30 6
functor Inspector_Values(structure Integer : INTEGER
                         structure Lists : LISTS
                         structure Crash : CRASH
                         structure Types : TYPES
                         structure Valenv : VALENV
                         structure Tags : TAGS
d32 1
a32 1
                         sharing Types.Datatypes = Valenv.Datatypes
d34 1
a34 1
                       ) : INSPECTOR_VALUES =
d44 45
d220 5
a224 1
          fun get_values(object,ty as Datatypes.METATYVAR _) = 
d433 1
a433 1
        get_values(object,ty)
@


1.1
log
@Initial revision
@
text
@d6 3
a10 1
require "../typechecker/types" ;
d14 1
a14 2
require "../typechecker/tyenv";
require "../typechecker/tystr";
d17 1
a17 2
require "../debugger/debugger_types";
require "../debugger/value_printer";
d20 1
a20 3
functor Inspector_Values(structure Types : TYPES
                         structure Valenv : VALENV
                         structure Integer : INTEGER
d23 2
a25 1
                         structure ValuePrinter : VALUE_PRINTER
a27 1
                         sharing type Types.Datatypes.Type = ValuePrinter.Debugger_Types.Type
d36 2
a37 1
    structure Debugger_Types = ValuePrinter.Debugger_Types
a38 1
    exception BadLabel
a42 6
    fun print_fun (object,ty) =
      ValuePrinter.stringify_value(ValuePrinter.toplevel_default_print_descriptor,
                                    object,
                                    ty,
                                    ValuePrinter.Debugger_Types.empty_information)

a95 22
(*
    fun list (value,acc) =
      let
        val c = contag value
      in
        if c = 0 then
          let
            val object = select 1 value
            val head = select 0 object
            val tail = select 1 object
          in
            list(tail,head::acc)
          end
        else 
          if c = 1 
            then
              rev acc
          else
            raise Value "list: illegal constructor"
      end
*)

d160 1
a160 2
    exception CantInspect
    fun get_inspector_values(object,ty) =
a161 3
          val print_fn_details = false 
          val print_exn_details = false 

d169 1
a169 1
              
d176 1
a176 1
            | get_values(_,Datatypes.NULLTYPE) = raise CantInspect
d178 1
a178 2
            | get_values(object,Datatypes.FUNTYPE _) = 
              raise CantInspect
d192 1
a192 2
                              (tys,Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN _),_,_,_,_))) =
              raise CantInspect
d195 1
a195 2
              if Types.tyname_eq (tyname,Types.int_tyname) then
                raise CantInspect
d197 1
a197 2
              else if Types.tyname_eq (tyname,Types.real_tyname) then
                raise CantInspect
d199 1
a199 2
              else if Types.tyname_eq (tyname,Types.bool_tyname) then
                raise CantInspect
d201 1
a201 2
              else if Types.tyname_eq (tyname,Types.string_tyname) then
                raise CantInspect
d208 2
a209 1
                       val (_,tagged_list) = Lists.reducel
d211 1
a211 2
                          (n+1,(Integer.makestring n, print_fun(object,ty))::l))
                         
a212 3
                       fun get_object_from_tag s =
                         ((Lists.nth(Integer.parseinteger s,element_list),ty)
                          handle Lists.Nth => raise BadLabel)
d214 1
a214 3
                       case tagged_list of
                         [] => raise CantInspect
                       | _ => ("List",rev tagged_list,get_object_from_tag)
d219 2
a220 2
              else if Types.tyname_eq (tyname,Types.ml_value_tyname) then
                raise CantInspect
d234 1
a234 5
                    ([ty], ref object) =>
                      let val (substr,a,b) = get_values(object,ty)
                      in
                        ("ref",[("ref",print_fun (object,ty))],fn _ => (object,ty))
                      end
d256 1
a256 7
                                  map (fn (s,object) => (s,print_fun(object,ty))) subvalues
                                fun lookup_fun s =
                                  let val object = Lists.assoc (s,subvalues)
                                  in
                                    (object,ty)
                                  end
                                handle Lists.Assoc => raise BadLabel
d258 1
a258 1
                                ("Array",string_list,lookup_fun)
d274 1
a274 2
                      if Datatypes.NewMap.is_empty constructor_map then
                        raise CantInspect
d287 1
a287 2
                          if is_a_single_constructor andalso not is_a_single_vcc then
                            raise CantInspect
a299 1
                                  val (substr,a,b) = get_values (object,arg_type)
d301 1
a301 1
                                  (name ^ " of " ^ substr,a,b)
d304 1
a304 2
                          else if primary = Tags.INTEGER0 orelse primary = Tags.INTEGER1 then
                            raise CantInspect
a325 1
                              val (substr,a,b) = get_values (packet,arg_type)
d327 1
a327 1
                              (name ^ " of " ^ substr,a,b)
d344 1
a344 2
                   if Lists.length dom = 0 then 
                     raise CantInspect
d363 2
a364 4
                           val print_strings =
                             map (fn (lab,(value,ty)) => (lab,print_fun(value,ty))) labtyvals
                           fun get_subval lab =
                             Lists.assoc (lab,labtyvals) handle Lists.Assoc => raise BadLabel
d366 1
a366 1
                           ("Record", print_strings,get_subval)
d373 1
a373 1
                       [] => raise CantInspect
d377 1
a377 1
            | get_values _ = raise CantInspect
@
