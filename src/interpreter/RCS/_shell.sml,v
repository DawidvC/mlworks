head	1.134;
access;
symbols
	MLW_daveb_inline_1_4_99:1.134.1
	MLWorks_21c0_1999_03_25:1.134
	MLWorks_20c1_1998_08_20:1.134
	MLWorks_20c0_1998_08_04:1.134
	MLWorks_20b2c2_1998_06_19:1.134
	MLWorks_20b2_Windows_1998_06_12:1.134
	MLWorks_20b1c1_1998_05_07:1.134
	MLWorks_20b0_1998_04_07:1.134
	MLWorks_20b0_1998_03_20:1.134
	MLWorks_20m2_1998_02_16:1.133
	MLWorks_20m1_1997_10_23:1.132
	MLWorks_11r1:1.130.1.1.1.2.1
	MLWorks_workspace_97:1.132.2
	MLWorks_dt_wizard:1.132.1
	MLWorks_11c0_1997_09_09:1.130.1.1.1.2
	MLWorks_10r3:1.130.1.1.3
	MLWorks_10r2_551:1.130.1.1.2
	MLWorks_11:1.130.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.130.1.1
	MLWorks_20m0_1997_06_20:1.131
	MLWorks_1_0_r2c2_1997_06_14:1.130.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.130.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.130.1
	MLWorks_BugFix_1997_04_24:1.130
	MLWorks_1_0_r2_Win32_1997_04_11:1.130
	MLWorks_1_0_r2_Unix_1997_04_04:1.130
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.128.3.1.1
	MLWorks_gui_1996_12_18:1.128.4
	MLWorks_1_0_Win32_1996_12_17:1.128.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.128.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.128.1.1
	MLWorks_1_0_Irix_1996_11_28:1.128.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.128.2
	MLWorks_1_0_Unix_1996_11_14:1.128.1
	MLWorks_Open_Beta2_1996_10_11:1.126.3
	MLWorks_License_dev:1.126.2
	MLWorks_1_open_beta_1996_09_13:1.126.1
	MLWorks_Open_Beta_1996_08_22:1.126
	MLWorks_Beta_1996_07_02:1.124
	MLWorks_Beta_1996_06_07:1.124
	MLWorks_Beta_1996_06_06:1.124
	MLWorks_Beta_1996_06_05:1.124
	MLWorks_Beta_1996_06_03:1.124
	MLWorks_Beta_1996_05_31:1.124
	MLWorks_Beta_1996_05_30:1.123
	ML_beta_release_12/08/94:1.100
	ML_beta_release_03/08/94:1.99
	ML_revised_beta_release_25/05/94:1.95
	ML_final_beta_release_02/03/94:1.92
	mlworks-28-01-1994:1.90
	Release:1.86
	mlworks-beta-01-09-1993:1.86
	MLWorks-1-0-4-29/01/1993:1.59
	MLWorks-1-0-3-21/12/1992:1.55
	MLWorks-1-0-2-15/12/1992:1.46
	MLWorks-1-0-1-04/12/1992:1.38;
locks; strict;
comment	@ * @;


1.134
date	98.02.19.19.36.21;	author mitchell;	state Exp;
branches
	1.134.1.1;
next	1.133;

1.133
date	98.01.26.18.47.52;	author johnh;	state Exp;
branches;
next	1.132;

1.132
date	97.07.31.12.43.33;	author johnh;	state Exp;
branches
	1.132.1.1
	1.132.2.1;
next	1.131;

1.131
date	97.05.19.10.46.42;	author jont;	state Exp;
branches;
next	1.130;

1.130
date	97.03.25.11.55.45;	author andreww;	state Exp;
branches
	1.130.1.1;
next	1.129;

1.129
date	97.03.19.12.27.33;	author matthew;	state Exp;
branches;
next	1.128;

1.128
date	96.10.31.13.39.44;	author io;	state Exp;
branches
	1.128.1.1
	1.128.2.1
	1.128.3.1
	1.128.4.1;
next	1.127;

1.127
date	96.10.30.12.56.56;	author io;	state Exp;
branches;
next	1.126;

1.126
date	96.08.07.11.03.49;	author daveb;	state Exp;
branches
	1.126.1.1
	1.126.2.1
	1.126.3.1;
next	1.125;

1.125
date	96.07.30.09.44.57;	author daveb;	state Exp;
branches;
next	1.124;

1.124
date	96.05.30.13.16.33;	author daveb;	state Exp;
branches;
next	1.123;

1.123
date	96.05.08.12.50.59;	author daveb;	state Exp;
branches;
next	1.122;

1.122
date	96.05.08.10.03.19;	author daveb;	state Exp;
branches;
next	1.121;

1.121
date	96.05.02.17.28.25;	author daveb;	state Exp;
branches;
next	1.120;

1.120
date	96.05.01.10.28.08;	author jont;	state Exp;
branches;
next	1.119;

1.119
date	96.04.09.18.40.25;	author daveb;	state Exp;
branches;
next	1.118;

1.118
date	96.02.05.17.41.31;	author daveb;	state Exp;
branches;
next	1.117;

1.117
date	96.01.24.12.09.41;	author daveb;	state Exp;
branches;
next	1.116;

1.116
date	96.01.22.14.07.38;	author daveb;	state Exp;
branches;
next	1.115;

1.115
date	96.01.18.14.16.34;	author daveb;	state Exp;
branches;
next	1.114;

1.114
date	96.01.17.12.15.08;	author daveb;	state Exp;
branches;
next	1.113;

1.113
date	95.09.08.15.29.33;	author matthew;	state Exp;
branches;
next	1.112;

1.112
date	95.07.19.12.08.51;	author matthew;	state Exp;
branches;
next	1.111;

1.111
date	95.07.13.12.19.26;	author matthew;	state Exp;
branches;
next	1.110;

1.110
date	95.06.05.14.13.33;	author daveb;	state Exp;
branches;
next	1.109;

1.109
date	95.05.26.11.40.03;	author daveb;	state Exp;
branches;
next	1.108;

1.108
date	95.04.28.12.00.07;	author daveb;	state Exp;
branches;
next	1.107;

1.107
date	95.04.25.12.45.55;	author daveb;	state Exp;
branches;
next	1.106;

1.106
date	95.03.16.17.43.30;	author daveb;	state Exp;
branches;
next	1.105;

1.105
date	95.03.15.14.19.27;	author daveb;	state Exp;
branches;
next	1.104;

1.104
date	95.03.06.12.22.21;	author daveb;	state Exp;
branches;
next	1.103;

1.103
date	95.03.02.12.13.58;	author matthew;	state Exp;
branches;
next	1.102;

1.102
date	95.02.20.14.47.40;	author daveb;	state Exp;
branches;
next	1.101;

1.101
date	95.01.13.15.00.03;	author daveb;	state Exp;
branches;
next	1.100;

1.100
date	94.08.09.12.53.13;	author daveb;	state Exp;
branches;
next	1.99;

1.99
date	94.07.28.14.44.28;	author daveb;	state Exp;
branches;
next	1.98;

1.98
date	94.06.23.10.06.31;	author jont;	state Exp;
branches;
next	1.97;

1.97
date	94.06.22.10.50.00;	author daveb;	state Exp;
branches;
next	1.96;

1.96
date	94.06.21.15.04.39;	author daveb;	state Exp;
branches;
next	1.95;

1.95
date	94.05.06.15.52.21;	author jont;	state Exp;
branches;
next	1.94;

1.94
date	94.03.17.10.17.26;	author matthew;	state Exp;
branches;
next	1.93;

1.93
date	94.03.15.10.18.29;	author matthew;	state Exp;
branches;
next	1.92;

1.92
date	94.02.23.17.38.21;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	94.02.02.10.45.51;	author daveb;	state Exp;
branches;
next	1.90;

1.90
date	93.11.25.14.19.25;	author matthew;	state Exp;
branches;
next	1.89;

1.89
date	93.09.23.16.37.48;	author daveb;	state Exp;
branches;
next	1.88;

1.88
date	93.09.23.14.13.09;	author daveb;	state Exp;
branches;
next	1.87;

1.87
date	93.09.16.15.49.39;	author nosa;	state Exp;
branches;
next	1.86;

1.86
date	93.08.10.13.23.01;	author matthew;	state Exp;
branches
	1.86.1.1;
next	1.85;

1.85
date	93.07.29.11.17.31;	author matthew;	state Exp;
branches;
next	1.84;

1.84
date	93.06.03.17.53.27;	author daveb;	state Exp;
branches;
next	1.83;

1.83
date	93.06.01.11.29.56;	author matthew;	state Exp;
branches;
next	1.82;

1.82
date	93.05.27.11.28.55;	author matthew;	state Exp;
branches;
next	1.81;

1.81
date	93.05.12.15.45.56;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	93.05.10.10.40.38;	author daveb;	state Exp;
branches;
next	1.79;

1.79
date	93.05.06.15.04.00;	author matthew;	state Exp;
branches;
next	1.78;

1.78
date	93.04.20.12.25.54;	author matthew;	state Exp;
branches;
next	1.77;

1.77
date	93.04.15.11.18.55;	author daveb;	state Exp;
branches;
next	1.76;

1.76
date	93.04.06.17.49.50;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	93.04.06.16.24.51;	author jont;	state Exp;
branches;
next	1.74;

1.74
date	93.04.02.14.50.00;	author matthew;	state Exp;
branches;
next	1.73;

1.73
date	93.04.01.12.07.01;	author daveb;	state Exp;
branches;
next	1.72;

1.72
date	93.03.29.17.10.08;	author matthew;	state Exp;
branches;
next	1.71;

1.71
date	93.03.25.10.19.17;	author daveb;	state Exp;
branches;
next	1.70;

1.70
date	93.03.24.14.22.14;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	93.03.19.12.19.09;	author matthew;	state Exp;
branches;
next	1.68;

1.68
date	93.03.17.12.09.06;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	93.03.15.16.38.41;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	93.03.12.11.21.12;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	93.03.09.15.51.47;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	93.03.02.18.49.09;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	93.02.23.15.54.47;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	93.02.19.19.18.23;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	93.02.09.12.34.23;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	93.02.08.10.42.02;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	93.01.28.16.52.09;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	93.01.07.16.38.25;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	93.01.05.11.58.34;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	92.12.23.17.48.19;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	92.12.21.13.09.30;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	92.12.18.16.49.28;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	92.12.18.13.25.21;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	92.12.18.10.41.33;	author clive;	state Exp;
branches;
next	1.51;

1.51
date	92.12.17.12.47.37;	author clive;	state Exp;
branches;
next	1.50;

1.50
date	92.12.16.18.25.21;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	92.12.16.17.50.56;	author clive;	state Exp;
branches;
next	1.48;

1.48
date	92.12.16.16.39.14;	author clive;	state Exp;
branches;
next	1.47;

1.47
date	92.12.16.13.31.19;	author clive;	state Exp;
branches;
next	1.46;

1.46
date	92.12.10.15.54.23;	author clive;	state Exp;
branches;
next	1.45;

1.45
date	92.12.09.18.07.17;	author clive;	state Exp;
branches;
next	1.44;

1.44
date	92.12.09.12.36.37;	author clive;	state Exp;
branches;
next	1.43;

1.43
date	92.12.09.12.27.35;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	92.12.08.21.00.42;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	92.12.08.16.59.15;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	92.12.08.16.37.20;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	92.12.08.13.42.25;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	92.12.04.15.28.55;	author clive;	state Exp;
branches;
next	1.37;

1.37
date	92.12.04.11.48.59;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	92.12.03.22.28.04;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	92.12.02.18.06.36;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	92.12.02.15.29.35;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	92.12.01.16.17.55;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.12.01.15.03.30;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	92.12.01.10.55.39;	author clive;	state Exp;
branches;
next	1.30;

1.30
date	92.11.28.16.05.44;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	92.11.26.18.46.16;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	92.11.26.17.29.41;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.11.26.16.41.04;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	92.11.25.17.32.57;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	92.11.24.12.03.04;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.11.24.10.59.16;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	92.11.20.16.54.11;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.11.19.19.45.20;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	92.11.18.17.40.14;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.11.18.15.06.46;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	92.11.12.17.32.14;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.11.12.11.32.00;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	92.11.11.16.14.47;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	92.11.10.16.19.55;	author clive;	state Exp;
branches;
next	1.15;

1.15
date	92.10.30.15.48.39;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.10.27.11.03.21;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.10.23.14.05.30;	author clive;	state Exp;
branches;
next	1.12;

1.12
date	92.10.22.14.34.20;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.10.20.16.45.31;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.10.19.16.26.38;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.10.19.11.22.32;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.10.14.15.22.07;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.10.08.16.43.57;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.10.08.11.35.03;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.10.08.08.20.00;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.10.07.15.39.54;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.10.07.10.52.43;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.10.02.07.44.34;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.10.01.17.20.12;	author richard;	state Exp;
branches;
next	;

1.86.1.1
date	93.08.10.13.23.01;	author jont;	state Exp;
branches;
next	1.86.1.2;

1.86.1.2
date	93.09.23.14.07.46;	author daveb;	state Exp;
branches;
next	1.86.1.3;

1.86.1.3
date	93.09.23.16.12.23;	author daveb;	state Exp;
branches;
next	;

1.126.1.1
date	96.09.13.11.16.11;	author hope;	state Exp;
branches;
next	;

1.126.2.1
date	96.10.07.16.06.13;	author hope;	state Exp;
branches;
next	;

1.126.3.1
date	96.10.17.11.24.29;	author hope;	state Exp;
branches;
next	;

1.128.1.1
date	96.11.14.12.49.13;	author hope;	state Exp;
branches
	1.128.1.1.1.1;
next	;

1.128.1.1.1.1
date	96.11.28.15.00.32;	author hope;	state Exp;
branches;
next	;

1.128.2.1
date	96.11.22.18.08.55;	author hope;	state Exp;
branches;
next	;

1.128.3.1
date	96.12.17.17.47.33;	author hope;	state Exp;
branches
	1.128.3.1.1.1;
next	;

1.128.3.1.1.1
date	97.02.24.11.37.19;	author hope;	state Exp;
branches;
next	;

1.128.4.1
date	96.12.18.09.41.34;	author hope;	state Exp;
branches;
next	;

1.130.1.1
date	97.05.12.10.34.01;	author hope;	state Exp;
branches
	1.130.1.1.1.1
	1.130.1.1.2.1
	1.130.1.1.3.1;
next	;

1.130.1.1.1.1
date	97.07.28.18.19.30;	author daveb;	state Exp;
branches;
next	1.130.1.1.1.2;

1.130.1.1.1.2
date	97.08.04.15.49.10;	author johnh;	state Exp;
branches
	1.130.1.1.1.2.1.1;
next	;

1.130.1.1.1.2.1.1
date	97.10.07.11.44.39;	author jkbrook;	state Exp;
branches;
next	;

1.130.1.1.2.1
date	97.09.08.17.13.06;	author daveb;	state Exp;
branches;
next	;

1.130.1.1.3.1
date	97.09.09.14.08.44;	author daveb;	state Exp;
branches;
next	;

1.132.1.1
date	97.09.10.19.24.05;	author brucem;	state Exp;
branches;
next	;

1.132.2.1
date	97.09.11.20.54.54;	author daveb;	state Exp;
branches;
next	1.132.2.2;

1.132.2.2
date	97.11.26.13.07.48;	author daveb;	state Exp;
branches;
next	;

1.134.1.1
date	99.04.01.17.56.54;	author daveb;	state Exp;
branches;
next	;


desc
@Incremental compiler shell.
Functor.
@


1.134
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(*  ==== COMPILER SHELL ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Implementation 
 *  --------------
 *
 *  Revision Log
 *  ------------
 *  $Log: _shell.sml,v $
 * Revision 1.133  1998/01/26  18:47:52  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.132.2.2  1997/11/26  13:07:48  daveb
 * [Bug #30071]
 *
 * Revision 1.132.2.1  1997/09/11  20:54:54  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.132  1997/07/31  12:43:33  johnh
 * [Bug #50019]
 * Modify process_result to take a UserContext.source_reference type for src.
 *
 * Revision 1.131  1997/05/19  10:46:42  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.130  1997/03/25  11:55:45  andreww
 * [Bug #1989]
 * removing Internal.Value.exn_name_string.
 *
 * Revision 1.129  1997/03/19  12:27:33  matthew
 * Adding level to do_actions
 *
 * Revision 1.128  1996/10/31  13:39:44  io
 * [Bug #1717]
 * fix an incorrect translation
 *
 * Revision 1.127  1996/10/30  12:56:56  io
 * moving String from toplevel
 *
 * Revision 1.126  1996/08/07  11:03:49  daveb
 * Added \r to the list of trivial characters.
 *
 * Revision 1.125  1996/07/30  09:44:57  daveb
 * [Bug #1299]
 * Added handlers to update end_pos and topdecs after a DebuggerTrapped or
 * Interrupt exception.  Also ignored trivial remaining lines, so that the
 * listener doesn't print unnecessary newlines.
 *
 * Revision 1.124  1996/05/30  13:16:33  daveb
 * The Interrupt exception is no longer at top level.
 *
 * Revision 1.123  1996/05/08  12:50:59  daveb
 * Moved code that updates the end_position and topdecs references so that
 * the ActionQueue is cleared first.  Thus errors that arise from the action
 * queue are handled in the same way as those that occur during compilation.
 *
 * Revision 1.121  1996/05/02  17:28:25  daveb
 * Removed ActionQueue.Handler exception.
 *
 * Revision 1.120  1996/05/01  10:28:08  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.119  1996/04/09  18:40:25  daveb
 * UserContext.process_result now takes a preferences argument (and a record
 * instead of a tuple).
 *
 * Revision 1.118  1996/02/05  17:41:31  daveb
 * UserContext no longer includes a user_tool_options type.
 *
 *  Revision 1.117  1996/01/24  12:09:41  daveb
 *  Fixed bug in handling of trivial lines.
 *
 *  Revision 1.116  1996/01/22  14:07:38  daveb
 *  Added INTERRUPT, EMPTY, and DEBUGGER_TRAPPED constructors to Result
 *  datatype, so that listeners can perform appropriate cleanup actions.
 *
 *  Revision 1.115  1996/01/18  14:16:34  daveb
 *  Added Result datatype.  Made the do_line function take Info.options.
 *
 *  Revision 1.114  1996/01/17  12:15:08  daveb
 *  Changes to support the new gui listener behaviour.
 *  The do_line function now takes and returns an explicit ShellState value,
 *  instead of this information being stored internally.  It also returns
 *  a list of the sources of each topdec, instead of offsets into the source
 *  string, and an extra string for any remaining source.  It uses the new
 *  Location.extract function to extract these source strings.
 *
 *  Revision 1.113  1995/09/08  15:29:33  matthew
 *  Changing error wrapping.
 *
 *  Revision 1.112  1995/07/19  12:08:51  matthew
 *  Changing parser error reporting.
 *
 *  Revision 1.111  1995/07/13  12:19:26  matthew
 *  Moving identifier type to Ident
 *
 *  Revision 1.110  1995/06/05  14:13:33  daveb
 *  UserContext.process_result now takes a user_options argument.
 *
 *  Revision 1.109  1995/05/26  11:40:03  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.108  1995/04/28  12:00:07  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.107  1995/04/25  12:45:55  daveb
 *  Added current_source ref, so that do_lines can synthesize the full
 *  source of the current topdec.
 *
 *  Revision 1.106  1995/03/16  17:43:30  daveb
 *  Removed context_name function, as is no longer used.
 *
 *  Revision 1.105  1995/03/15  14:19:27  daveb
 *  Type of ShellTypes.ShellData has changed.
 *  Also, prompt_function now takes the context name string as an argument.
 *
 *  Revision 1.104  1995/03/06  12:22:21  daveb
 *  Replaced user context manipulation with a call to ShellTypes.process_result.
 *
 *  Revision 1.103  1995/03/02  12:13:58  matthew
 *  Changes to Lexer structure
 *
 *  Revision 1.102  1995/02/20  14:47:40  daveb
 *  do_actions now takes an output function argument.
 *
 *  Revision 1.101  1995/01/13  15:00:03  daveb
 *  Removed obsolete sharing constraint.
 *
 *  Revision 1.100  1994/08/09  12:53:13  daveb
 *  Changed type of InterPrint.strings.  Renamed source_result to result.
 *
 *  Revision 1.99  1994/07/28  14:44:28  daveb
 *  Changed print_options identifier to options, for clarity.
 *
 *  Revision 1.98  1994/06/23  10:06:31  jont
 *  Update debugger information production
 *
 *  Revision 1.97  1994/06/22  10:50:00  daveb
 *  Removed extraneous newline from printed results.
 *
 *  Revision 1.96  1994/06/21  15:04:39  daveb
 *  Changes to support per-user_context information.
 *
 *  Revision 1.95  1994/05/06  15:52:21  jont
 *  Add incremental parser basis to stuff passed to interprint
 *
 *  Revision 1.94  1994/03/17  10:17:26  matthew
 *  Commented out catchall handler.
 *
 *  Revision 1.93  1994/03/15  10:18:29  matthew
 *  Added Exit exception and handler
 *
 *  Revision 1.92  1994/02/23  17:38:21  matthew
 *  Added catchall exception handler
 *
 *  Revision 1.91  1994/02/02  10:45:51  daveb
 *  Rejigged substructures.
 *
 *  Revision 1.90  1993/11/25  14:19:25  matthew
 *  Moved exception DebuggerTrapped into ShellTypes for easier use elsewhere.
 *
 *  Revision 1.89  1993/09/23  16:37:48  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.88  1993/09/23  14:13:09  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.87  1993/09/16  15:49:39  nosa
 *  Pass options to InterPrint.definitions instead of print_options.
 *
 *  Revision 1.86.1.3  1993/09/23  16:12:23  daveb
 *  No longer resets prompt when a topdec ends in the middle of a line.
 *
 *  Revision 1.86.1.2  1993/09/23  14:07:46  daveb
 *  Minor fix to handling of blank lines & subline count.
 *
 *  Revision 1.86.1.1  1993/08/10  13:23:01  jont
 *  Fork for bug fixing
 *
 *  Revision 1.86  1993/08/10  13:23:01  matthew
 *  Added stream_name parameter to be used as name of input token stream
 *  Changed line count to be the subline number
 *
 *  Revision 1.85  1993/07/29  11:17:31  matthew
 *  Removed error_info parameter from InterPrint.definitions
 *
 *  Revision 1.84  1993/06/03  17:53:27  daveb
 *  Removed the prompter_args value.  Now uses the name of the current
 *  ContextRef for the prompt.
 *
 *  Revision 1.83  1993/06/01  11:29:56  matthew
 *  Added handler for ActionQueue.Handled around ActionQueue.do_actions
 *
 *  Revision 1.82  1993/05/27  11:28:55  matthew
 *  Changes to error handling
 *
 *  Revision 1.81  1993/05/12  15:45:56  matthew
 *  Changes to ActionQueue
 *
 *  Revision 1.80  1993/05/10  10:40:38  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *
 *  Revision 1.79  1993/05/06  15:04:00  matthew
 *  Removed printer descriptors
 *  Changes to ActionQueue interface
 *
 *  Revision 1.78  1993/04/20  12:25:54  matthew
 *  Added unit parameter to two calls to reset_parsing_state
 *
 *  Revision 1.77  1993/04/15  11:18:55  daveb
 *  Replaced a call to output_fn with a call to Info.error', and
 *  moved it so that the resulatant raise of Info.Stop will be
 *  handled correctly.
 *
 *  Revision 1.76  1993/04/06  17:49:50  daveb
 *  The shell's do_line function now returns the positions of any topdecs
 *  that end in the current line, and whether the current topdec is still valid.
 *
 *  Revision 1.75  1993/04/06  16:24:51  jont
 *  Moved user_options and version from interpreter to main
 *
 *  Revision 1.74  1993/04/02  14:50:00  matthew
 *  Signature changes
 *
 *  Revision 1.73  1993/04/01  12:07:01  daveb
 *  Interprets empty lines as end-of-file.  Knows enough about lexer state to
 *  set prompt appropriately.  Passes empty lines to parser when appropriate.
 *
 *  Revision 1.72  1993/03/29  17:10:08  matthew
 *  Prompt changes
 *  Used with_shell_data
 *  Removed call to make_shell_structure (this is done only once now)
 *
 *  Revision 1.71  1993/03/25  10:19:17  daveb
 *  ActionQueue.do_actions now takes a single ShellData argument.
 *
 *  Revision 1.70  1993/03/24  14:22:14  matthew
 *  reset prompt before executing topdec
 *
 *  Revision 1.69  1993/03/19  12:19:09  matthew
 *  Error wrap of call to incremental parser.  Restructuring of the command loop
 *
 *  Revision 1.68  1993/03/17  12:09:06  matthew
 *  Changed to allow error wrapping of incremental parsing.
 *  Loop function simplified.
 *  Pass new parser basis to Incremental.add_source
 *  Fixed line numbering of blank lines.
 *
 *  Revision 1.67  1993/03/15  16:38:41  matthew
 *  Changed ShellData type to include all shell information
 *
 *  Revision 1.66  1993/03/12  11:21:12  matthew
 *  Fixed problem with prompts
 *  do_line now takes an output function
 *
 *  Revision 1.65  1993/03/09  15:51:47  matthew
 *  Options & Info changes
 *
 *  Revision 1.64  1993/03/02  18:49:09  daveb
 *  Completely revised.  Much stuff moved to _action_queue, _shell_structure,
 *  _user_options and _tty_listener.  The shell now provides a core service
 *  to both TTY-based and X-based listeners.
 *
 *  Revision 1.61  1993/02/09  12:34:23  matthew
 *  Typechecker structure changes
 *
 *  Revision 1.60  1993/02/08  10:42:02  matthew
 *  Changes of sharing relations and new structure representation
 *
 *  Revision 1.59  1993/01/28  16:52:09  jont
 *  Modified to allow user control of listing options
 *
 *  Revision 1.58  1993/01/07  16:38:25  matthew
 *  Modified empty_action_queue so errors are only handled once at the
 *  outermost call.
 *  This stops compilation continuing after an error.
 *
 *  Revision 1.57  1993/01/05  11:58:34  jont
 *  Modified to deal with new code printing options
 *
 *  Revision 1.56  1992/12/23  17:48:19  daveb
 *  "use" can now read a file that doesn't have a ".sml" extension.
 *
 *  Revision 1.55  1992/12/21  13:09:30  matthew
 *  Changed listener window syntax error message.
 *  Added proper line numbering for listener shell
 *
 *  Revision 1.54  1992/12/18  16:49:28  daveb
 *  Ensured that user options are passed from the TTY shell to the listener shell
 *
 *  Revision 1.53  1992/12/18  13:25:21  matthew
 *  Added xinterface_flag to make_shell_structure -- if true, xinterface is running.
 *  Rebound streams when saving image from listener window.
 *  Fix of Clive to interrupt handling in listener.
 *
 *  Revision 1.52  1992/12/18  10:41:33  clive
 *  We also pass the current module forward for the source_displayer
 *
 *  Revision 1.51  1992/12/17  12:47:37  clive
 *  Changed debug info to have only module name - needed to pass module table through to window stuff
 *
 *  Revision 1.50  1992/12/16  18:25:21  matthew
 *  Fixed secondary prompts.
 *  Changed some messages
 *
 *  Revision 1.49  1992/12/16  17:50:56  clive
 *  Fixed bug in 'make' from 'source' option in listener with no file selected
 *
 *  Revision 1.48  1992/12/16  16:39:14  clive
 *  Tried to give an error message if make called on an invalid filename
 *
 *  Revision 1.47  1992/12/16  13:31:19  clive
 *  Changes to the debugger for a limited backtrace
 *
 *  Revision 1.46  1992/12/10  15:54:23  clive
 *  Stopped recompile errors entring the debugger
 *  Changed the debugger to propagate Interrupt if told to 'q' during ^C action
 *
 *  Revision 1.45  1992/12/09  18:07:17  clive
 *  Message from use if the file is not found
 *
 *  Revision 1.44  1992/12/09  12:36:37  clive
 *  Added passing of the module_table to the source_viewer
 *
 *  Revision 1.43  1992/12/09  12:27:35  matthew
 *  Various bug fixes.
 *  Made action queue global -- experimental
 *
 *  Revision 1.42  1992/12/08  21:00:42  jont
 *  Removed a number of duplicated signatures and structures
 *
 *  Revision 1.41  1992/12/08  16:59:15  daveb
 *  Fixed clear_debug_info - we can't set the current_context with a
 *  user-visible function, because it gets reset later.  So we have to use
 *  the action queue.
 *
 *  Revision 1.40  1992/12/08  16:37:20  daveb
 *  Made changed options apply immediately after evaluation.
 *  Changed the user-visible field optimise_self_calls to
 *  optimise_self_tail_calls.
 *
 *  Revision 1.39  1992/12/08  13:42:25  daveb
 *  Ensured that options are pased to compile, recompile and make.
 *
 *  Revision 1.38  1992/12/04  15:28:55  clive
 *  Added a correct handler around make to preserve context on partial make
 *
 *  Revision 1.37  1992/12/04  11:48:59  daveb
 *  Fixed exit from listener.
 *  Fixed calculation of subline in listener prompt.
 *
 *  Revision 1.36  1992/12/03  22:28:04  daveb
 *  Moved xinterface and save into Shell structure.
 *  Attempted to fix exit from listener shells.
 *  Propagated options into shells.
 *  Removed the shell function (it was causing a lot of trouble).
 *  Added remake function (clive).
 *  Improved error reporting.
 *  Removed a sharing constraint.
 *  Minor tidying up.
 *
 *  Revision 1.35  1992/12/02  18:06:36  daveb
 *  Deleted several pieces of commented-out code.
 *
 *  Revision 1.34  1992/12/02  15:29:35  daveb
 *  Changes to propagate compiler options as parameters instead of references.
 *  Many settable options now plumbed in.
 *  Exit function pu into shell structure.
 *  Some minor tidying up.
 *
 *  Revision 1.33  1992/12/01  16:17:55  clive
 *  Added a forced garbage collection before a save
 *
 *  Revision 1.32  1992/12/01  15:03:30  matthew
 *  Changed stream handling.
 *
 *  Revision 1.31  1992/12/01  10:55:39  clive
 *  Debugger now takes the print options
 *
 *  Revision 1.30  1992/11/28  16:05:44  daveb
 *  Changes to make show_id_class and show_eq_info part of Info structure
 *  instead of references.
 *
 *  Revision 1.29  1992/11/26  18:46:16  matthew
 *  Flush output when starting shell.
 *
 *  Revision 1.28  1992/11/26  17:29:41  clive
 *  Added some of the functions in the Debug structure
 *
 *  Revision 1.27  1992/11/26  16:41:04  matthew
 *  Integrated clm stuff.  Tidied some things up.  Used streams more.
 *
 *  Revision 1.26  1992/11/25  17:32:57  daveb
 *  Put the substructures in the structures.
 *
 *  Revision 1.25  1992/11/24  12:03:04  clive
 *  The debugger now takes messages to go with the 'q' and 'c' options
 *
 *  Revision 1.24  1992/11/24  10:59:16  daveb
 *  More changes to the user visible structures.  These aren't plumbed in
 *  to the rest of the compiler yet.
 *
 *  Revision 1.23  1992/11/20  16:54:11  jont
 *  Modified sharing constraints to remove superfluous structures
 *
 *  Revision 1.22  1992/11/19  19:45:20  matthew
 *  Added recompile and compile, and some info bug fixes.
 *
 *  Revision 1.21  1992/11/18  17:40:14  clive
 *  Added completion of name by adding .sml to used files
 *  Added an error message if a use or make fails
 *
 *  Revision 1.20  1992/11/18  15:06:46  matthew
 *  Changed Error structure to Info
 *
 *  Revision 1.19  1992/11/12  17:32:14  clive
 *  Added tracing
 *
 *  Revision 1.18  1992/11/12  11:32:00  daveb
 *  Added show structure, moved Print structure out of Shell.
 *
 *  Revision 1.17  1992/11/11  16:14:47  daveb
 *  Added print controls to user-visible values in shell().
 *
 *)

require "../utils/lists";
require "../utils/crash";
require "../parser/parser";
require "shell_types";
require "user_context";
require "incremental";
require "shell";

functor Shell (
  structure Crash : CRASH
  structure Lists : LISTS
  structure Parser : PARSER
  structure ShellTypes: SHELL_TYPES
  structure UserContext: USER_CONTEXT
  structure Incremental: INCREMENTAL

  sharing Parser.Lexer.Info = Incremental.InterMake.Compiler.Info
  sharing Incremental.InterMake.Compiler.Absyn = Parser.Absyn
  sharing ShellTypes.Options = UserContext.Options =
	  Incremental.InterMake.Compiler.Options

  sharing type Incremental.InterMake.Compiler.ParserBasis = Parser.ParserBasis
  sharing type Incremental.Result = UserContext.Result
  sharing type Parser.Lexer.Options = ShellTypes.Options.options
  sharing type ShellTypes.Context = Incremental.Context
  sharing type ShellTypes.user_context = UserContext.user_context
  sharing type UserContext.identifier =
	       Parser.Absyn.Ident.Identifier
  sharing type ShellTypes.preferences = UserContext.preferences
): SHELL =
struct
  structure Compiler = Incremental.InterMake.Compiler
  structure Parser = Parser
  structure Lexer  = Parser.Lexer
  structure Info = Compiler.Info
  structure Options = ShellTypes.Options
  structure Absyn = Parser.Absyn

  type ShellData = ShellTypes.ShellData
  type Context = Incremental.Context

  exception Exit of int

  datatype ShellState =
    SHELL_STATE of
      {parser_state: Parser.ParserState,
       lexer_state: Lexer.Token.LexerState,
       source: string,
       line_count: int}

  datatype Result =
    OK of ShellState
  | ERROR of Info.error * Info.error list
  | INTERRUPT
  | DEBUGGER_TRAPPED
  | TRIVIAL

  val initial_state =
    SHELL_STATE
      {parser_state = Parser.initial_parser_state,
       lexer_state = Lexer.Token.PLAIN_STATE,
       source = "",
       line_count = 1}


  (* shell returns two functions.  The first takes one line of input,
     parses it relative to a state stored from earlier lines, and evaluates
     any topdecs found.  The second takes a string and converts
     it into a prompt string. *)
  fun shell (shell_data,stream_name,flush_stream) =
    let
      val ShellTypes.SHELL_DATA{debugger,
                                exit_fn,
                                ...} = shell_data

      val output_fn = print
        
      fun do_prompt (s, SHELL_STATE {line_count, ...}) =
        ShellTypes.get_current_prompter
	  shell_data
          {line = ~1,
           subline = line_count - 1,
	   name = s,
           topdec =
	     Incremental.topdec (ShellTypes.get_current_context shell_data)}

      (* need to record the context in which the current topdec is parsed *)
      val current_context = ref (ShellTypes.get_current_context shell_data)

      (* and the incremental parser basis *)
      fun get_current_pB () = Incremental.parser_basis (!current_context)

      val current_pB = ref (get_current_pB ())

      fun do_line error_info (line, state) =
        ShellTypes.with_shell_data
        shell_data
        (fn () =>
         let
	   (* A null string signals EOF *)
	   val real_eof = size line = 0

	   val SHELL_STATE
		 {parser_state = parser_start_state,
		  lexer_state = lexer_start_state,
		  source = old_source,
		  line_count} =
	     state

	   val full_source = old_source ^ line

           (* when one or more topdecs end on the line being parsed, topdecs
	      stores the source of each of the topdecs, and end_position
	      records the position where the remaining text begins, for later
	      extraction. *)
           val end_position = ref 0;
           val topdecs = ref [];

           (* need to wrap the parser so that we stop on errors *)
           fun error_wrap f a =
	     Info.wrap
               error_info
               (Info.FATAL, Info.RECOVERABLE,
	        Info.FAULT, Info.Location.FILE stream_name)
               f
               a

	  fun check_eof () =
	    if real_eof then
	      exit_fn 0
            else
	      ()

	  fun all_chars p str =
	    let
	      fun scan i = 
		if i < 0 then
		  true
		else
		  p (MLWorks.String.ordof (str, i)) andalso (scan (i-1))
	    in
	      scan (size str -1)
	    end
	    
	  val trivial =
	    all_chars 
              (fn c => (c = ord #" " orelse c = ord #"\n" orelse
                        c = ord #"\t" orelse c = ord #"\r" orelse
			c = ord #"\012"))

	  (* trivial' is similar to trivial, but also ignores semi-colons.
	     This is used to ignore empty topdecs.  *)
          val trivial' =
	    all_chars
	      (fn c => (c = ord #" " orelse c = ord #"\n" orelse
                        c = ord #"\t" orelse c = ord #"\r" orelse
			c = ord #"\012" orelse c = ord #";"))
        in
	  if line_count = 1 andalso size line > 0
	     andalso trivial' line then
	     (* Blank lines are ignored if we haven't parsed anything yet *)
	    ([], "", TRIVIAL)
	  else if lexer_start_state = Lexer.Token.PLAIN_STATE
                  andalso size line > 0 andalso trivial line then
	    ([],
	     full_source,
	     OK (SHELL_STATE
		   {lexer_state = lexer_start_state,
		    parser_state = parser_start_state,
		    source = full_source,
		    line_count = line_count + 1}))
          else
            let
              val input_function =
                let val buff = ref line
                in
                  fn _ => (let val out = !buff in buff := ""; out end)
                end
              
              val token_stream = Lexer.mkLineTokenStream (input_function,
                                                          stream_name,
                                                          line_count,
							  real_eof)
              exception STOP of ShellState
              
	      (* get_topdec parses the token_stream.  If it finds a topdec
		 it returns that topdec; otherwise it raises an exception. *)
              fun get_topdec error_info (lexer_state, parser_state) =
                (let 
                  val (pB,new_ps,new_ls) =
                    Parser.parse_incrementally
                      error_info
                      (ShellTypes.get_current_options shell_data,
                       token_stream,
                       !current_pB,
                       parser_state,
                       lexer_state)
                in
                  (* we are part way through parsing a topdec, so store state *)
                  current_pB := pB;
		  (* Return the full source in the state, as the lexer_state
		     includes position information relative to everything
		     read so far. *)
                  raise STOP
		          (SHELL_STATE
		             {parser_state = new_ps,
                              lexer_state = new_ls,
		              source = full_source,
		              line_count = line_count + 1})
                end
                handle
                  Parser.FoundTopDec (topdec,newpB,loc) =>
                    (topdec,newpB,loc)
                | Parser.SyntaxError (message,location) =>
                    Info.error' error_info (Info.FATAL, location, message))

              fun reset_parsing_state () =
                (current_context := ShellTypes.get_current_context (shell_data);
                 current_pB := get_current_pB ())
                
	      (* The loop function parses as many topdecs as possible from
		 the tokenstream. *)
              fun loop (lexer_state, parser_state) =
                let
                  val _ =
                    if Parser.is_initial_state parser_state
		       andalso lexer_state = Lexer.Token.PLAIN_STATE then
                      reset_parsing_state ()
                    else
                      ()
                        
                  val parsing_context = !current_context

		  (* If get_topdec reaches the end of the input, it raises
		     STOP. *)
                  val (topdec, new_pB, loc2) = 
                    error_wrap get_topdec (lexer_state, parser_state)
                    handle exn as Info.Stop _ =>
                      (ignore(flush_stream ());
                       raise exn)

		  val loc1 =
		    case topdec of
		      Absyn.STRDECtopdec (_, l) => l
		    | Absyn.REQUIREtopdec (_, l) => l
		    | Absyn.FUNCTORtopdec (_, l) => l
		    | Absyn.SIGNATUREtopdec (_, l) => l

		  (* loc1 is the location of the topdec itself; loc2 is
		     the location of the semicolon. *)
		  val loc = Info.Location.combine (loc1, loc2);

		  val (s_pos, e_pos) =
		    Info.Location.extract (loc, full_source)
		    handle
		      Info.Location.InvalidLocation => (0, 1)

		  val new_source =
		    substring (* could raise Substring *) (full_source, s_pos, e_pos - s_pos)
		    handle Subscript => full_source (* tied to substring above *)

                  (*compile the source in the parsing context *)
                  val result =
                    (Incremental.compile_source
                     error_info
                     (Incremental.OPTIONS
                      {options = ShellTypes.get_current_options shell_data,
                       debugger=debugger},
                      parsing_context,
                      Compiler.TOPDEC (stream_name,topdec,new_pB))
                     handle
                     exn as ShellTypes.DebuggerTrapped =>
                       (end_position := e_pos;
                        topdecs := new_source :: !topdecs;
                        raise exn)
                   | exn as MLWorks.Interrupt =>
                       (end_position := e_pos;
                        topdecs := new_source :: !topdecs;
                        raise exn))

                in
		  UserContext.process_result
		    {src = UserContext.STRING new_source,
		     result = result,
		     user_context = ShellTypes.get_user_context shell_data,
		     options = ShellTypes.get_current_options shell_data,
		     preferences =
		       ShellTypes.get_current_preferences shell_data,
		     output_fn = output_fn};

		  (* Don't update these references until after the topdec
		     has been successfully compiled. *)
		  end_position := e_pos;
		  topdecs := new_source :: !topdecs;

		  (* The following lines check whether there is anything
		     else to parse on this line.  If not, the initial state
		     is returned, without incrementing the line_count. *)
                  reset_parsing_state();
                  if Lexer.eof token_stream then
		    (* This is the end of the line.  NOT usually the real end
		       of file.  That only happens when (size line = 0). *)
                    raise STOP initial_state
                  else
		    ();
                  loop
		    (Lexer.Token.PLAIN_STATE, Parser.initial_parser_state)
                end
            in
              loop (lexer_start_state, parser_start_state)
              handle exn =>
		let
		  val current_source =
		    let
		      val i = !end_position

		      val remainder =
		        substring (line, i, size line - i)
		        handle
			  Subscript => line (* tied to substring above *)
		    in
		      if trivial remainder then
			""
		      else
			remainder
		    end
		in
		  case exn of 
                    STOP
		      (state as SHELL_STATE
		         {parser_state, lexer_state, source, line_count}) =>
		      (check_eof ();
		       if lexer_state = Lexer.Token.PLAIN_STATE andalso
		          Parser.is_initial_state parser_state then
                         (rev (!topdecs), "", OK initial_state)
		       else
		         (rev (!topdecs), current_source, OK state))
                  | Info.Stop (error, error_list) =>
		      (reset_parsing_state();
		       (rev (!topdecs),
			current_source,
			ERROR (error, error_list)))
		      (* I'm not sure how to handle EOF in this case *)
                  | ShellTypes.DebuggerTrapped =>
                      (check_eof ();
		       reset_parsing_state();
		       (rev (!topdecs), current_source, DEBUGGER_TRAPPED))
                  | MLWorks.Interrupt =>
                      (check_eof ();
		       reset_parsing_state();
		       (rev (!topdecs), current_source, INTERRUPT))
                  | exn as Exit _ => raise exn
		  | exn => raise exn
    (*
                  | exn =>
                      (* Can't use regular error reporting mechanism here *)
                      (* This should print a stack backtrace also *)
                      (print("Compiler Error: Unexpected exception " ^ 
                              (MLWorks.Internal.Value.exn_name exn) ^
                              "\n");
                       check_eof ();
		       reset_parsing_state();
		       (rev (!topdecs), false, current_source, initial_state))
    *)
		end
    
            end
        end)
    in
      (do_line, do_prompt)
    end (* of shell *)
  
  end
@


1.134.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.134  1998/02/19  19:36:21  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.133
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d11 4
d671 1
a671 1
                      (flush_stream ();
@


1.132
log
@[Bug #50019]
Modify process_result to take a UserContext.source_reference type for src.
@
text
@d11 10
a433 1
require "action_queue";
a442 1
  structure ActionQueue: ACTION_QUEUE
d445 1
a445 2
  sharing Parser.Lexer.Info = Incremental.InterMake.Compiler.Info =
	  ActionQueue.Info
d454 1
a454 3
  sharing type ShellTypes.user_options = ActionQueue.UserOptions
  sharing type ActionQueue.user_context = ShellTypes.user_context =
	       UserContext.user_context
d457 1
a457 2
  sharing type ShellTypes.preferences = ActionQueue.preferences =
	       UserContext.preferences
a470 1
  exception Error = ActionQueue.Error
d708 1
a708 1
                    handle exn => (ActionQueue.clear_queue (); raise exn)
a717 18
                  ActionQueue.do_actions
                    {user_context = ShellTypes.get_user_context shell_data,
                     user_options = ShellTypes.get_user_options shell_data,
		     error_info = error_info,
		     preferences =
		       ShellTypes.get_current_preferences shell_data,
                     debugger = debugger,
		     output_fn = output_fn,
                     monitor_fn = fn s => output_fn ("Make: compiling " ^ s)}
		  handle
                    exn as ShellTypes.DebuggerTrapped =>
		      (end_position := e_pos;
		       topdecs := new_source :: !topdecs;
		       raise exn)
                  | exn as MLWorks.Interrupt =>
		      (end_position := e_pos;
		       topdecs := new_source :: !topdecs;
		       raise exn);
d720 1
a720 2
		     has been successfully compiled, and the action queue
		     called. *)
a765 6
		  | ActionQueue.Error (_, error, error_list) =>
		      (reset_parsing_state();
		       (rev (!topdecs),
			current_source,
			ERROR (error, error_list)))
		      (* I'm not sure how to handle EOF in this case *)
@


1.132.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 4
 * Revision 1.132  1997/07/31  12:43:33  johnh
 * [Bug #50019]
 * Modify process_result to take a UserContext.source_reference type for src.
 *
@


1.132.2.2
log
@[Bug #30071]
@
text
@a10 3
 * Revision 1.132.2.1  1997/09/11  20:54:54  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d428 1
d438 1
d441 2
a442 1
  sharing Parser.Lexer.Info = Incremental.InterMake.Compiler.Info
d451 3
a453 1
  sharing type ShellTypes.user_context = UserContext.user_context
d456 2
a457 1
  sharing type ShellTypes.preferences = UserContext.preferences
d471 1
d709 1
a709 1

d719 18
d739 2
a740 1
		     has been successfully compiled. *)
d786 6
@


1.132.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 4
 * Revision 1.132  1997/07/31  12:43:33  johnh
 * [Bug #50019]
 * Modify process_result to take a UserContext.source_reference type for src.
 *
@


1.131
log
@[Bug #30090]
Translate output std_out to print
@
text
@d11 4
d708 1
a708 1
		    {src = new_source,
@


1.130
log
@[Bug #1989]
removing Internal.Value.exn_name_string.
@
text
@d11 4
d497 1
a497 1
      fun output_fn s = MLWorks.IO.output(MLWorks.IO.std_out,s)
d804 1
a804 1
                      (MLWorks.IO.output(MLWorks.IO.std_out,"Compiler Error: Unexpected exception " ^ 
@


1.130.1.1
log
@branched from 1.130
@
text
@a10 4
 * Revision 1.130  1997/03/25  11:55:45  andreww
 * [Bug #1989]
 * removing Internal.Value.exn_name_string.
 *
@


1.130.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
 * Revision 1.130.1.1  1997/05/12  10:34:01  hope
 * branched from 1.130
 *
@


1.130.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
 * Revision 1.130.1.1  1997/05/12  10:34:01  hope
 * branched from 1.130
 *
@


1.130.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
 * Revision 1.130.1.1  1997/05/12  10:34:01  hope
 * branched from 1.130
 *
@


1.130.1.1.1.2
log
@[Bug #50019]
Merging - changing type of src field in UserContext.process_result.
@
text
@a10 4
 *
 * Revision 1.130.1.1.1.1  1997/07/28  18:19:30  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d707 1
a707 1
		    {src = UserContext.STRING new_source,
@


1.130.1.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 4
 * Revision 1.130.1.1.1.2  1997/08/04  15:49:10  johnh
 * [Bug #50019]
 * Merging - changing type of src field in UserContext.process_result.
 *
@


1.129
log
@Adding level to do_actions
@
text
@d11 3
d801 1
a801 1
                              MLWorks.Internal.Value.exn_name_string (MLWorks.Internal.Value.exn_name exn) ^
@


1.128
log
@[Bug #1717]
fix an incorrect translation
@
text
@d11 4
d456 1
d678 17
a694 16
                    Incremental.compile_source
                      error_info
		      (Incremental.OPTIONS
		         {options = ShellTypes.get_current_options shell_data,
			  debugger=debugger},
                       parsing_context,
		       Compiler.TOPDEC (stream_name,topdec,new_pB))
		    handle
                      exn as ShellTypes.DebuggerTrapped =>
		        (end_position := e_pos;
		         topdecs := new_source :: !topdecs;
		         raise exn)
                    | exn as MLWorks.Interrupt =>
		        (end_position := e_pos;
		         topdecs := new_source :: !topdecs;
		         raise exn)
@


1.128.4.1
log
@branched from 1.128
@
text
@a10 4
 * Revision 1.128  1996/10/31  13:39:44  io
 * [Bug #1717]
 * fix an incorrect translation
 *
@


1.128.3.1
log
@branched from 1.128
@
text
@a10 4
 * Revision 1.128  1996/10/31  13:39:44  io
 * [Bug #1717]
 * fix an incorrect translation
 *
@


1.128.3.1.1.1
log
@branched from 1.128.3.1
@
text
@a10 3
 * Revision 1.128.3.1  1996/12/17  17:47:33  hope
 * branched from 1.128
 *
@


1.128.2.1
log
@branched from 1.128
@
text
@a10 4
 * Revision 1.128  1996/10/31  13:39:44  io
 * [Bug #1717]
 * fix an incorrect translation
 *
@


1.128.1.1
log
@branched from 1.128
@
text
@a10 4
 * Revision 1.128  1996/10/31  13:39:44  io
 * [Bug #1717]
 * fix an incorrect translation
 *
@


1.128.1.1.1.1
log
@branched from 1.128.1.1
@
text
@a10 3
 * Revision 1.128.1.1  1996/11/14  12:49:13  hope
 * branched from 1.128
 *
@


1.127
log
@moving String from toplevel
@
text
@d11 3
d543 1
a543 1
	  fun all_chars p (s:string):bool = 
d545 5
a549 4
	      fun scan 0 = true
		| scan i =
		(p (MLWorks.Internal.Value.unsafe_string_sub (s, i))) andalso 
		scan (i-1)
d551 1
a551 1
	      scan (size s - 1)
@


1.126
log
@Added \r to the list of trivial characters.
@
text
@d11 3
d540 1
a540 1
	  fun all_chars p str =
d542 4
a545 7
              fun all' 0 = true
                | all' n =
                  let
                    val c = MLWorks.String.ordof (str, n-1)
                  in
		    p c andalso all' (n-1)
                  end
d547 1
a547 1
	      all' (size str)
d549 1
a549 1

d552 3
a554 3
              (fn c => (c = String.ord " " orelse c = String.ord "\n" orelse
                        c = String.ord "\t" orelse c = String.ord "\r" orelse
			c = String.ord "\012"))
d560 3
a562 3
	      (fn c => (c = String.ord " " orelse c = String.ord "\n" orelse
                        c = String.ord "\t" orelse c = String.ord "\r" orelse
			c = String.ord "\012" orelse c = String.ord ";"))
d664 2
a665 2
		    String.substring (full_source, s_pos, e_pos - s_pos)
		    handle Substring => full_source
d741 1
a741 1
		        String.substring (line, i, size line - i)
d743 1
a743 1
			  Substring => line
@


1.126.3.1
log
@branched from 1.126
@
text
@a10 3
 * Revision 1.126  1996/08/07  11:03:49  daveb
 * Added \r to the list of trivial characters.
 *
@


1.126.2.1
log
@branched from 1.126
@
text
@a10 3
 * Revision 1.126  1996/08/07  11:03:49  daveb
 * Added \r to the list of trivial characters.
 *
@


1.126.1.1
log
@branched from 1.126
@
text
@a10 3
 * Revision 1.126  1996/08/07  11:03:49  daveb
 * Added \r to the list of trivial characters.
 *
@


1.125
log
@[Bug #1299]
Added handlers to update end_pos and topdecs after a DebuggerTrapped or
Interrupt exception.  Also ignored trivial remaining lines, so that the
listener doesn't print unnecessary newlines.
@
text
@d11 6
d553 2
a554 1
                        c = String.ord "\t" orelse c = String.ord "\012"))
d561 1
a561 1
                        c = String.ord "\t" orelse
@


1.124
log
@The Interrupt exception is no longer at top level.
@
text
@d11 3
d510 2
a511 2
	      stores the source of the each topdecs, and end_position records
	      the position where the remaining text begins, for later
d531 12
a542 7
          fun all_chars p 0 = true
            | all_chars p n =
              let
                val c = MLWorks.String.ordof (line, n-1)
              in
		p c andalso all_chars p (n-1)
              end
d554 2
a555 1
                        c = String.ord "\t" orelse c = String.ord "\012" orelse c = String.ord ";"))
d558 1
a558 1
	     andalso trivial' (size line) then
d562 1
a562 1
                  andalso size line > 0 andalso trivial (size line) then
d669 9
d695 10
a704 1
                     monitor_fn = fn s => output_fn ("Make: compiling " ^ s)};
d732 5
d738 4
a741 2
		      String.substring (line, i, size line - i)
		      handle Substring => line
@


1.123
log
@Moved code that updates the end_position and topdecs references so that
the ActionQueue is cleared first.  Thus errors that arise from the action
queue are handled in the same way as those that occur during compilation.
@
text
@d11 5
d736 1
a736 1
                  | Interrupt =>
@


1.122
log
@Added Info.options argument to ActionQueue.do_actions.
@
text
@a654 5

		  (* Don't update these references until after the topdec
		     has been successfully compiled. *)
		  val _ = end_position := e_pos
		  val _ = topdecs := new_source :: !topdecs
d673 7
d701 1
a701 2
		      (* Ignore trailing newline character *)
		      String.substring (line, i, size line - i - 1)
@


1.121
log
@Removed ActionQueue.Handler exception.
@
text
@d11 3
d672 1
@


1.120
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d11 6
d673 1
a673 3
                     monitor_fn = fn s => output_fn ("Make: compiling " ^ s)}
                  handle
		    ActionQueue.Handled => ();
@


1.119
log
@UserContext.process_result now takes a preferences argument (and a record
instead of a tuple).
@
text
@d11 4
d456 1
a456 1
      fun output_fn s = output(std_out,s)
d524 2
a525 2
              (fn c => (c = ord " " orelse c = ord "\n" orelse
                        c = ord "\t" orelse c = ord "\012"))
d531 2
a532 2
	      (fn c => (c = ord " " orelse c = ord "\n" orelse
                        c = ord "\t" orelse c = ord "\012" orelse c = ord ";"))
d732 1
a732 1
                      (output(std_out,"Compiler Error: Unexpected exception " ^ 
@


1.118
log
@UserContext no longer includes a user_tool_options type.
@
text
@d11 3
d404 2
a405 1

d649 7
a655 5
		    (new_source,
		     result,
		     ShellTypes.get_user_context shell_data,
		     ShellTypes.get_current_options shell_data,
		     output_fn);
d657 7
a663 5
                    (ShellTypes.get_user_context shell_data,
                     ShellTypes.get_user_options shell_data,
                     debugger,
		     output_fn,
                     fn s => output_fn ("Make: compiling " ^ s))
@


1.117
log
@Fixed bug in handling of trivial lines.
@
text
@d11 3
a400 1
  sharing type UserContext.user_tool_options = ActionQueue.UserOptions
a648 1
                     ShellTypes.get_user_options shell_data,
@


1.116
log
@Added INTERRUPT, EMPTY, and DEBUGGER_TRAPPED constructors to Result
datatype, so that listeners can perform appropriate cleanup actions.
@
text
@d11 4
d504 2
a505 2
          fun trivial 0 = true
            | trivial n =
d509 1
a509 4
                (c = ord " " orelse c = ord "\n" orelse
                 c = ord "\t" orelse c = ord "\012" orelse
		 c = ord ";") andalso
                trivial (n-1)
d511 12
d524 13
a536 14
	  if lexer_start_state = Lexer.Token.PLAIN_STATE
             andalso size line > 0 andalso trivial (size line) then
               if line_count = 1 then
		 (* Blank lines are ignored if we haven't parsed
		    anything yet *)
		  ([], "", TRIVIAL)
	       else
		 ([],
		  full_source,
		  OK (SHELL_STATE
		        {lexer_state = lexer_start_state,
		         parser_state = parser_start_state,
		         source = full_source,
		         line_count = line_count + 1}))
@


1.115
log
@Added Result datatype.  Made the do_line function take Info.options.
@
text
@d11 3
d420 3
d506 2
a507 1
                 c = ord "\t" orelse c = ord "\012") andalso
d516 1
a516 1
		  ([], "", OK state)
d696 1
a696 1
		       (rev (!topdecs), current_source, OK initial_state))
d700 1
a700 1
		       (rev (!topdecs), current_source, OK initial_state))
@


1.114
log
@Changes to support the new gui listener behaviour.
The do_line function now takes and returns an explicit ShellState value,
instead of this information being stored internally.  It also returns
a list of the sources of each topdec, instead of offsets into the source
string, and an extra string for any remaining source.  It uses the new
Location.extract function to extract these source strings.
@
text
@d11 8
d376 2
a377 1
  sharing Parser.Lexer.Info = Incremental.InterMake.Compiler.Info
d414 4
a435 2
      val error_info = Info.default_options

d455 1
a455 1
      fun do_line (line, state) =
d509 1
a509 1
		  ([], true, "", state)
d511 1
a511 1
		 ([], true,
d513 5
a517 5
		  SHELL_STATE
		    {lexer_state = lexer_start_state,
		     parser_state = parser_start_state,
		     source = full_source,
		     line_count = line_count + 1})
d547 3
a607 4
		  val _ = end_position := e_pos

		  val _ = topdecs := new_source :: !topdecs

d617 5
d636 2
a637 3
                  handle ActionQueue.Error(s,_,_) =>
                    output_fn (s ^ "\n")
                       | ActionQueue.Handled => ();
d659 2
a660 1
		      String.substring (line, i, size line - i)
d671 1
a671 1
                         (rev (!topdecs), true, "", initial_state)
d673 13
a685 11
		         (rev (!topdecs), true,
			  current_source,
			  SHELL_STATE
			    {lexer_state = lexer_state,
			     parser_state = parser_state,
			     source = full_source,
			     line_count = line_count + 1}))
                  | Info.Stop _ =>
                      (check_eof ();
		       reset_parsing_state();
		       (rev (!topdecs), false, current_source, initial_state))
d689 1
a689 1
		       (rev (!topdecs), false, current_source, initial_state))
d693 1
a693 1
		       (rev (!topdecs), false, current_source, initial_state))
@


1.113
log
@Changing error wrapping.
@
text
@d11 3
d391 1
d398 19
a422 1

d427 8
a434 25
      val subline = ref 0

      fun prompt(s) =
        let
          val result =
            (ShellTypes.get_current_prompter shell_data)
            {line = ~1,
             subline = !subline,
	     name = s,
             topdec = Incremental.topdec
			(ShellTypes.get_current_context shell_data)}
        in
          subline := !subline + 1;
          result
        end

      val line_count = ref 1

      val current_parser_state = ref Parser.initial_parser_state
      val current_lexer_state = ref Lexer.Token.PLAIN_STATE

      (* when one or more topdecs end on the line being parsed, end_positions
	 records the positions where they end, so that the history mechanism
	 in a listener can extract whole topdecs. *)
      val end_positions = ref [];
d444 1
a444 6
      val current_source = ref ""

      fun reset_prompt () =
        subline := 0

      fun do_line line =
d452 15
a466 1
	   val _ = end_positions := []
d470 1
a470 1
             let val result = Info.wrap
d472 2
a473 1
               (Info.FATAL, Info.RECOVERABLE, Info.FAULT,Info.Location.FILE stream_name)
a475 3
             in
               result
             end
d493 1
a493 1
	  if !current_lexer_state = Lexer.Token.PLAIN_STATE
d495 12
a506 8
               (if !subline = 1 then
		  (* Blank lines are ignored if we haven't parsed
		     anything yet *)
		  reset_prompt ()
		else
		  current_source := !current_source ^ line;
                line_count := (!line_count) + 1;
	        ([], true))
d517 1
a517 1
                                                          !subline,
d519 1
a519 3
              val _ = line_count := (!line_count) + 1
                
              exception STOP
d521 3
a523 1
              fun get_topdec error_info () =
d527 6
a532 6
                    error_info
                    (ShellTypes.get_current_options shell_data,
                     token_stream,
                     !current_pB,
                     !current_parser_state,
                     !current_lexer_state)
a534 2
                  current_parser_state := new_ps;
                  current_lexer_state := new_ls;
d537 5
d543 5
a547 5
              handle
              Parser.FoundTopDec (topdec,newpB,loc) =>
                (topdec,newpB,loc)
            | Parser.SyntaxError (message,location) =>
                Info.error' error_info (Info.FATAL, location, message))
d550 1
a550 3
                (current_parser_state := Parser.initial_parser_state;
                 current_lexer_state := Lexer.Token.PLAIN_STATE;
                 current_context := ShellTypes.get_current_context (shell_data);
d553 3
a555 1
              fun loop () =
d558 3
a560 4
                    if Parser.is_initial_state (!current_parser_state)
		       andalso !current_lexer_state = Lexer.Token.PLAIN_STATE
                      then
                        reset_parsing_state ()
d562 1
a562 1
                    ()
d566 4
a569 2
                  val (topdec,new_pB,loc) = 
                    error_wrap get_topdec ()
d574 15
a588 4
		  val new_position =
		    case loc of
		      Info.Location.EXTENT {e_col, ...} => e_col - 1
		    | _ => Crash.impossible "shell expected EXTENT from parser"
d591 2
a592 3
		    case !end_positions of
		      [] => String.substring (line, 0, new_position)
		    | h::_ => String.substring (line, h, new_position - h - 1)
d594 3
a596 2
		  val _ = end_positions := 
		    new_position :: !end_positions
d601 6
a606 6
                    error_info
		    (Incremental.OPTIONS
		       {options = ShellTypes.get_current_options shell_data,
			debugger=debugger},
                     parsing_context,
		     Compiler.TOPDEC (stream_name,topdec,new_pB))
d609 1
a609 1
		    (!current_source ^ new_source,
d624 3
a626 1
		  current_source := "";
d631 1
a631 1
                    raise STOP
d634 2
a635 1
                  loop ()
d638 54
a691 50
              loop ()
              handle
                STOP =>
		  (check_eof ();
		   if !current_lexer_state = Lexer.Token.PLAIN_STATE andalso
		      Parser.is_initial_state (!current_parser_state) then
                      (reset_prompt();
		       current_source := "";
                       (rev (!end_positions), false))
		   else
		     (current_source :=
			!current_source ^
		        (case !end_positions of
		          [] => line (* ^ "\n" *)
		        | h::_ =>
			  String.substring (line, h, size line - h (* - 1 *)) (* ^ "\n" *));
		     (rev (!end_positions), true)))
              | Info.Stop _ =>
                  (check_eof ();
		   current_source := "";
		   reset_parsing_state();
                   reset_prompt();
		   (rev (!end_positions), false))
              | ShellTypes.DebuggerTrapped =>
                  (check_eof ();
		   current_source := "";
		   reset_parsing_state();
                   reset_prompt();
		   (rev (!end_positions), false))
              | Interrupt =>
                  (check_eof ();
		   current_source := "";
		   reset_parsing_state();
                   reset_prompt();
		   (rev (!end_positions), false))
              | exn as Exit _ => raise exn
(*
              | exn =>
                  (* Can't use regular error reporting mechanism here *)
                  (* This should print a stack backtrace also *)
                  (output(std_out,"Compiler Error: Unexpected exception " ^ 
                          MLWorks.Internal.Value.exn_name_string (MLWorks.Internal.Value.exn_name exn) ^
                          "\n");
                   check_eof ();
		   current_source := "";
		   reset_parsing_state();
                   reset_prompt();
		   (rev (!end_positions), false))
*)

d695 1
a695 1
      (do_line, prompt)
@


1.112
log
@Changing parser error reporting.
@
text
@d11 3
d394 1
a394 1
  fun shell (shell_data,stream_name) =
d458 1
a458 1
               (Info.RECOVERABLE, Info.RECOVERABLE, Info.FAULT,Info.Location.FILE stream_name)
d508 22
a529 22
                (let val (pB,new_ps,new_ls) =
                       Parser.parse_incrementally
                         error_info
                         (ShellTypes.get_current_options shell_data,
                          token_stream,
                          !current_pB,
                          !current_parser_state,
                          !current_lexer_state)
                 in
                   (* we are part way through parsing a topdec,
			so store state *)
                   current_parser_state := new_ps;
                   current_lexer_state := new_ls;
                   current_pB := pB;
                   raise STOP
                 end
                 handle
		   Parser.FoundTopDec(topdec,newpB,loc) =>
                     (topdec,newpB,loc)
                 | Parser.SyntaxError(message,location) =>
		     Info.error' error_info (Info.FATAL, location, message))
                   
d548 5
a552 1
                  val (topdec,new_pB,loc) = error_wrap get_topdec ()
@


1.111
log
@Moving identifier type to Ident
@
text
@d11 3
d524 2
a525 3
                 | Parser.SyntaxError(token,location) =>
		     Info.error' error_info
				 (Info.FATAL, location, "Unexpected " ^ token))
@


1.110
log
@UserContext.process_result now takes a user_options argument.
@
text
@d11 3
d372 1
a372 1
	       Incremental.InterMake.Compiler.identifier
@


1.109
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d11 3
a342 1
require "../main/user_options";
d370 2
d570 1
@


1.108
log
@Moved all the user_context stuff from ShellTypes into a separate file.
@
text
@d11 3
a350 1
  structure UserOptions: USER_OPTIONS
d356 1
a356 1
  sharing UserOptions.Options = ShellTypes.Options = UserContext.Options =
d363 1
a363 2
  sharing type UserOptions.user_options = ShellTypes.user_options =
	       ActionQueue.UserOptions
d374 1
a374 1
  structure Options = UserOptions.Options
@


1.107
log
@Added current_source ref, so that do_lines can synthesize the full
source of the current topdec.
@
text
@d11 4
d336 1
d347 1
d352 1
a352 2
  sharing Parser.Lexer.Info = ShellTypes.Info =
	  Incremental.InterMake.Compiler.Info
d354 2
a355 1
  sharing UserOptions.Options = ShellTypes.Options
d358 1
a358 1
  sharing type ShellTypes.Result = Incremental.Result
a359 1
  sharing type ShellTypes.IncrementalOptions = Incremental.options
d363 4
a366 2
  sharing type ActionQueue.user_context = ShellTypes.user_context
  sharing type ShellTypes.identifier = Incremental.InterMake.Compiler.identifier
d554 3
a556 1
                    (ShellTypes.make_incremental_options shell_data,
d560 1
a560 1
		  ShellTypes.process_result
@


1.106
log
@Removed context_name function, as is no longer used.
@
text
@d11 3
d418 2
d462 6
a467 2
               (if !subline = 1 then reset_prompt () else ();
		(* Blank lines are ignored if we haven't parsed anything yet *)
d532 1
a532 1
		      Info.Location.EXTENT {e_col, ...} => e_col
d535 5
d552 2
a553 1
		    ("<shell>", result,
d558 6
a563 6
                  (ShellTypes.get_user_context shell_data,
                   ShellTypes.get_user_options shell_data,
                   debugger,
		   output_fn,
                   fn s => output_fn ("Make: compiling " ^ s))
                handle ActionQueue.Error(s,_,_) =>
d566 1
d584 1
d586 8
a593 1
		   else (rev (!end_positions), true))
d596 1
d602 1
d608 1
d621 1
@


1.105
log
@Type of ShellTypes.ShellData has changed.
Also, prompt_function now takes the context name string as an argument.
@
text
@d11 4
a366 5

  fun context_name shell_data =
    ShellTypes.string_context_name
      (ShellTypes.get_context_name
         (ShellTypes.get_user_context shell_data))
@


1.104
log
@Replaced user context manipulation with a call to ShellTypes.process_result.
@
text
@d11 3
d364 4
a367 8
  fun context_depth (ShellTypes.SHELL_DATA{context_stack,...}) =
    (Lists.length (!context_stack)) - 1

  fun context_name (ShellTypes.SHELL_DATA{context_stack,...}) =
    case !context_stack of
      [] => Crash.impossible "empty context stack"
    | h::_ => ShellTypes.string_context_name
		(ShellTypes.get_context_name h)
d384 1
a384 1
      fun prompt() =
d390 1
a390 1
	     name = context_name shell_data,
@


1.103
log
@Changes to Lexer structure
@
text
@d11 3
a320 1
require "interprint";
a330 1
  structure InterPrint : INTERPRINT
d336 3
a338 1
  sharing Incremental.InterMake.Compiler = InterPrint.Compiler
a339 3
  sharing Parser.Lexer.Info = InterPrint.Compiler.Info = ShellTypes.Info
  sharing Parser.Absyn = InterPrint.Compiler.Absyn
  sharing UserOptions.Options = InterPrint.Compiler.Options
d341 2
d345 1
a345 1
  sharing type ShellTypes.Context = InterPrint.Context = Incremental.Context
a347 1
  sharing type Parser.ParserBasis = InterPrint.Compiler.ParserBasis
d532 1
a532 1
                  val (result,identifiers) =
a537 28

		  val (full_context, delta_context, history, source_map) =
		    ShellTypes.get_user_context_info shell_data

                  val options =
                    ShellTypes.get_current_options shell_data

                  val new_context =
                    Incremental.add_definitions
		      (options, full_context, result)
		  (* I'm not sure why this doesn't use the parsing context *)

                  val new_delta =
                    Incremental.add_definitions
		      (options, delta_context, result)

                  val result_strings = 
                    InterPrint.strings
		      (new_context, Incremental.pb_from_result result,
		       options, 0, identifiers);

		  val _ =
		    map
		      (fn (_, s) => output (std_out, s))
		      result_strings

		  val new_history =
		    map (fn (i, s) => ShellTypes.ITEM (i, s, "")) result_strings
d539 5
a543 4
                  ShellTypes.set_user_context_info
		    (shell_data,
		       (new_context, new_delta,
			new_history @@ history, source_map));
@


1.102
log
@do_actions now takes an output function argument.
@
text
@d11 3
d336 1
a336 1
  sharing Parser.Options = UserOptions.Options = ShellTypes.Options
d341 1
@


1.101
log
@Removed obsolete sharing constraint.
@
text
@d11 3
d570 1
@


1.100
log
@Changed type of InterPrint.strings.  Renamed source_result to result.
@
text
@d11 3
a333 1
  sharing ShellTypes.Option = Incremental.InterMake.Option
@


1.99
log
@Changed print_options identifier to options, for clarity.
@
text
@d11 3
a337 1
  sharing type InterPrint.SourceResult = Incremental.SourceResult
d522 1
a522 1
                  val (source_result,identifiers) =
d537 1
a537 1
		      (options, full_context, source_result)
d542 1
a542 1
		      (options, delta_context, source_result)
d546 2
a547 1
                    (new_context, source_result, options, 0, identifiers);
@


1.98
log
@Update debugger information production
@
text
@d11 3
d530 1
a530 1
                  val print_options =
d535 1
a535 1
		      (print_options, full_context, source_result)
d540 1
a540 1
		      (print_options, delta_context, source_result)
d544 1
a544 1
                    (new_context, source_result, print_options, 0, identifiers);
@


1.97
log
@Removed extraneous newline from printed results.
@
text
@d11 3
d419 1
a419 1
               (Info.WARNING, Info.RECOVERABLE, Info.FAULT,Info.Location.FILE stream_name)
d527 3
d532 1
a532 1
		      (full_context, source_result)
d537 1
a537 4
		      (delta_context, source_result)

                  val print_options =
                    ShellTypes.get_current_options shell_data
@


1.96
log
@Changes to support per-user_context information.
@
text
@d11 3
d542 1
a542 2
		      (fn (_, s) =>
			 (output (std_out, s); output (std_out, "\n")))
@


1.95
log
@Add incremental parser basis to stuff passed to interprint
@
text
@d11 3
d322 1
a322 2
  sharing type ShellTypes.Context = InterPrint.Context = Incremental.Context =
               ActionQueue.Context
d326 3
d392 3
a394 1
      val current_pB = ref (Incremental.parser_basis (!current_context))
d486 1
a486 1
                 current_pB := Incremental.parser_basis (!current_context)) 
d510 1
a510 1
                  (*compiler the source in the parsing context *)
d518 3
d523 6
a528 1
		      (ShellTypes.get_current_context shell_data, source_result)
d532 13
a544 6
                  val _ = 
                    InterPrint.definitions
                    output_fn
                    (new_context,
                     print_options,
                     0, identifiers, Incremental.pb_from_result source_result);
d546 4
a549 1
                  ShellTypes.set_current_context(shell_data,new_context);
d551 1
a551 1
                  (ShellTypes.get_context_ref (ShellTypes.get_shell_context_ref shell_data),
d555 1
a555 1
                handle ActionQueue.Error(s,context,_,_) =>
@


1.94
log
@Commented out catchall handler.
@
text
@d11 3
d522 1
a522 1
                     0, identifiers);
@


1.93
log
@Added Exit exception and handler
@
text
@d11 3
d565 1
d576 1
a576 1

@


1.92
log
@Added catchall exception handler
@
text
@d11 3
d338 2
d543 3
a545 3
                     reset_prompt()
		   else ();
		   (rev (!end_positions), true))
d561 1
@


1.91
log
@Rejigged substructures.
@
text
@d11 3
d519 1
a519 1
                  handle ActionQueue.Error(s,context,_,_) =>
d556 12
@


1.90
log
@Moved exception DebuggerTrapped into ShellTypes for easier use elsewhere.
@
text
@d11 3
d286 1
d297 1
d299 1
a299 1
  sharing ActionQueue.Incremental.InterMake.Compiler = InterPrint.Compiler
d304 1
a304 1
  sharing ShellTypes.Option = ActionQueue.Incremental.InterMake.FileName.Option
d306 2
a307 2
  sharing type ShellTypes.IncrementalOptions = ActionQueue.Incremental.options
  sharing type ShellTypes.Context = InterPrint.Context = ActionQueue.Incremental.Context =
d309 2
a310 1
  sharing type UserOptions.user_options = ShellTypes.user_options = ActionQueue.UserOptions
a313 1
  structure Incremental = ActionQueue.Incremental
@


1.89
log
@Merged in bug fix.
@
text
@d11 3
a317 2
  exception DebuggerTrapped

d538 1
a538 1
              | DebuggerTrapped =>
@


1.88
log
@Merged in bug fix.
@
text
@d11 3
d16 4
a19 1

a474 2
                  val _ = reset_prompt()

d527 4
@


1.87
log
@Pass options to InterPrint.definitions instead of print_options.
@
text
@d11 9
d405 2
a406 1
               (subline := (!subline) - 1;
@


1.86
log
@Added stream_name parameter to be used as name of input token stream
Changed line count to be the subline number
@
text
@d11 4
d482 1
a482 1
                    ShellTypes.get_current_print_options shell_data
@


1.86.1.1
log
@Fork for bug fixing
@
text
@a10 4
 *  Revision 1.86  1993/08/10  13:23:01  matthew
 *  Added stream_name parameter to be used as name of input token stream
 *  Changed line count to be the subline number
 *
@


1.86.1.2
log
@Minor fix to handling of blank lines & subline count.
@
text
@a10 3
 *  Revision 1.86.1.1  1993/08/10  13:23:01  jont
 *  Fork for bug fixing
 *
d396 1
a396 2
               (if !subline = 1 then reset_prompt () else ();
		(* Blank lines are ignored if we haven't parsed anything yet *)
@


1.86.1.3
log
@No longer resets prompt when a topdec ends in the middle of a line.
@
text
@a10 3
 *  Revision 1.86.1.2  1993/09/23  14:07:46  daveb
 *  Minor fix to handling of blank lines & subline count.
 *
d463 2
a516 4
		   if !current_lexer_state = Lexer.Token.PLAIN_STATE andalso
		      Parser.is_initial_state (!current_parser_state) then
                     reset_prompt()
		   else ();
@


1.85
log
@Removed error_info parameter from InterPrint.definitions
@
text
@d11 3
d307 1
a307 1
  fun shell shell_data =
d367 1
a367 1
               (Info.WARNING, Info.RECOVERABLE, Info.FAULT,Info.Location.FILE "Listener Input")
d404 2
a405 2
                                                          "Listener Input",
                                                          !line_count,
d471 1
a471 1
		     Compiler.TOPDEC ("listener input",topdec,new_pB))
@


1.84
log
@Removed the prompter_args value.  Now uses the name of the current
ContextRef for the prompt.
@
text
@d11 4
a478 1
                    error_info
@


1.83
log
@Added handler for ActionQueue.Handled around ActionQueue.do_actions
@
text
@d11 3
d294 6
d311 1
a311 4
      val prompt_args =
        {subline = ref 0,
         name = ref (Incremental.name (ShellTypes.get_current_context shell_data)),
         topdec = ref (Incremental.topdec (ShellTypes.get_current_context shell_data))}
a314 1
          val {subline, name, topdec} = prompt_args
d319 3
a321 3
             name = !name,
             topdec = !topdec,
             context = context_depth shell_data}
d344 1
a344 1
        #subline prompt_args := 0
d385 3
a387 6
            (let val subline_ref = #subline prompt_args
            in
               subline_ref := (!subline_ref) - 1;
               line_count := (!line_count) + 1;
	       ([], true)
            end)
a488 2
                  (#topdec prompt_args) := Incremental.topdec new_context;
                  (#name prompt_args) := Incremental.name new_context;
@


1.82
log
@Changes to error handling
@
text
@d11 3
d485 2
a486 1
                    output_fn (s ^ "\n");
@


1.81
log
@Changes to ActionQueue
@
text
@d11 3
d352 1
a352 1
               (Info.WARNING, Info.RECOVERABLE, Info.FAULT)
d456 3
a458 2
                    (ShellTypes.make_incremental_options shell_data)
                    (parsing_context,
d481 1
a481 1
                  handle ActionQueue.Error(s,context) =>
@


1.80
log
@Removed error_info field from ListenerArgs, ShellData and Incremental.options
@
text
@d11 3
d264 2
a265 3
  sharing type ShellTypes.Context = InterPrint.Context = ActionQueue.Incremental.Context
  sharing type ShellTypes.ContextRef =
	       ActionQueue.ContextRef
d473 1
a473 1
                  (ShellTypes.get_shell_context_ref shell_data,
d476 3
a478 1
                   fn s => output_fn ("Make: compiling " ^ s));
@


1.79
log
@Removed printer descriptors
Changes to ActionQueue interface
@
text
@d11 4
a285 1
                                error_info,
d289 2
@


1.78
log
@Added unit parameter to two calls to reset_parsing_state
@
text
@d11 3
a251 1

d253 2
a254 2

  sharing UserOptions.Options = InterPrint.ValuePrinter.Options
a256 1

d258 3
a260 8

  sharing type ShellTypes.print_method_table =
    InterPrint.ValuePrinter.print_method_table =
    ActionQueue.print_method_table

  sharing type ShellTypes.ShellData =
	       ActionQueue.ShellData
  sharing type UserOptions.user_options = ShellTypes.user_options
a261 1
  sharing type ShellTypes.printer_descriptor = InterPrint.ValuePrinter.printer_descriptor
a269 1
  structure ValuePrinter = InterPrint.ValuePrinter
d276 2
a277 2
  fun context_depth (ShellTypes.SHELL_DATA{state_stack,...}) =
    (Lists.length (!state_stack)) - 1
d281 8
a332 2
           val (ShellTypes.SHELL_DATA{output_fn, exit_fn, ...}) = shell_data

d341 1
a341 1
               (ShellTypes.get_error_info shell_data)
d454 2
d459 1
a459 1
                    (ShellTypes.get_error_info shell_data)
d461 1
a461 1
                     ShellTypes.make_printer_descriptor shell_data,
a462 1

d465 5
a469 1
                  ActionQueue.do_actions shell_data;
@


1.77
log
@Replaced a call to output_fn with a call to Info.error', and
moved it so that the resulatant raise of Info.Stop will be
handled correctly.
@
text
@d11 5
d489 1
a489 1
		   reset_parsing_state;
d494 1
a494 1
		   reset_parsing_state;
@


1.76
log
@The shell's do_line function now returns the positions of any topdecs
that end in the current line, and whether the current topdec is still valid.
@
text
@d11 4
d401 6
a406 2
                 handle Parser.FoundTopDec(topdec,newpB,loc) =>
                   (topdec,newpB,loc))
d474 18
a491 26
              Parser.SyntaxError(token,location) =>
                (reset_parsing_state();
                 reset_prompt();
                 output_fn (implode [Lexer.Info.Location.to_string location,
                                     ": Unexpected ",
                                     token,
                                     "\n"]);
		 (rev (!end_positions), false))
            | STOP =>
		(check_eof ();
		 (rev (!end_positions), true))
            | Info.Stop _ =>
                (check_eof ();
		 reset_parsing_state();
                 reset_prompt();
		 (rev (!end_positions), false))
            | DebuggerTrapped =>
                (check_eof ();
		 reset_parsing_state;
                 reset_prompt();
		 (rev (!end_positions), false))
            | Interrupt =>
                (check_eof ();
		 reset_parsing_state;
                 reset_prompt();
		 (rev (!end_positions), false))
@


1.75
log
@Moved user_options and version from interpreter to main
@
text
@d4 1
a4 1

d11 3
d220 1
d229 1
d303 5
d327 2
d361 2
a362 1
               line_count := (!line_count) + 1
d381 14
a394 3
                ((* if Lexer.eof token_stream then
		   (* This is the end of the line.  NOT usually the real end
		      of file.  That only happens when (size line = 0). *)
d396 1
a396 17
                 else *)
                   let val (pB,new_ps,new_ls) =
                     Parser.parse_incrementally
                     error_info
                     (ShellTypes.get_current_options shell_data,
                      token_stream,
                      !current_pB,
                      !current_parser_state,
                      !current_lexer_state)
                   in
                     (* we are part way through parsing a topdec,
			so store state *)
                     current_parser_state := new_ps;
                     current_lexer_state := new_ls;
                     current_pB := pB;
                     raise STOP
                   end
d422 8
d434 2
a435 1
                    (parsing_context,Compiler.TOPDEC ("listener input",topdec,new_pB))
d438 2
a439 2
                    Incremental.add_definitions (ShellTypes.get_current_context shell_data,
                                                 source_result)
d472 5
a476 2
                                     "\n"]))
            | STOP => check_eof ()
d480 2
a481 1
                 reset_prompt())
d485 2
a486 1
                 reset_prompt())
d490 2
a491 1
                 reset_prompt())
@


1.74
log
@Signature changes
@
text
@d11 3
d220 1
a220 1
require "user_options";
@


1.73
log
@Interprets empty lines as end-of-file.  Knows enough about lexer state to
set prompt appropriately.  Passes empty lines to parser when appropriate.
@
text
@d11 4
d229 3
a231 2
  sharing ShellTypes.Incremental =
	  ActionQueue.Incremental
d233 1
a233 3
  sharing ShellTypes.Incremental.InterMake.Compiler = InterPrint.Compiler
  sharing Parser.Options = UserOptions.Options
  sharing Parser.Lexer.Info = InterPrint.Compiler.Info
d235 1
a235 1
  sharing Parser.Absyn = InterPrint.Compiler.Absyn
d237 1
a237 1
  sharing UserOptions.Options = InterPrint.ValuePrinter.Debugger_Types.Options
d239 1
a239 1
  sharing type ShellTypes.Incremental.Context = InterPrint.Context
d252 1
a252 1
  structure Incremental = ShellTypes.Incremental
@


1.72
log
@Prompt changes
Used with_shell_data
Removed call to make_shell_structure (this is done only once now)
@
text
@d11 5
d290 1
d306 4
a309 1
           val (ShellTypes.SHELL_DATA{output_fn,...}) = shell_data
d322 6
d338 2
a339 1
          if trivial (size line) then
d355 2
a356 1
                                                          !line_count)
d362 3
a364 1
                (if Lexer.eof token_stream then
d366 2
a367 2
                 else
                   let val (pB,new_state) =
d373 2
a374 1
                      !current_parser_state)
d376 4
a379 2
                     (* we are part way through parsing a topdec, so store state *)
                     current_parser_state := new_state;
d383 2
a384 2
                 handle Parser.FoundTopDec(topdec,newpB) =>
                   (topdec,newpB))
d388 1
d396 1
d404 1
a404 1
                  val (topdec,new_pB) = error_wrap get_topdec ()
d432 6
d450 1
a450 1
            | STOP => ()
d452 2
a453 1
                (reset_parsing_state();
d456 2
a457 1
                (reset_parsing_state;
d460 2
a461 1
                (reset_parsing_state;
@


1.71
log
@ActionQueue.do_actions now takes a single ShellData argument.
@
text
@d11 3
a206 1
require "shell_structure";
a215 1
  structure ShellStructure: SHELL_STRUCTURE
d231 1
a231 1
  sharing type ShellStructure.Context = InterPrint.Context
a237 1
	       ShellStructure.ShellData =
a238 1
  sharing type ShellTypes.Incremental.Context = ShellStructure.Context
d252 1
a252 1
  type Args = ShellTypes.ShellData
d257 3
d272 5
a276 1
            {line = ~1, subline = !subline,name = !name, topdec = !topdec}
a283 5
      (* not so sure about this *)
      val context = ShellStructure.make_shell_structure shell_data

      val _ = ShellTypes.set_current_context(shell_data,context)
                         
d295 17
a311 12
      fun do_line (do_output,line) =
        let
          (* need to wrap the parser so that we stop on errors *)
          fun error_wrap f a =
            let val result = Info.wrap
              (ShellTypes.get_error_info shell_data)
              (Info.WARNING, Info.RECOVERABLE, Info.FAULT)
              f
              a
            in
              result
            end
a389 2
                  val _ = ShellTypes.update_options shell_data
                    
d396 1
a396 1
                    do_output
a404 1
                  ShellTypes.update_options shell_data;
d416 1
a416 1
                 do_output (implode [Lexer.Info.Location.to_string location,
d431 1
a431 1
        end
@


1.70
log
@reset prompt before executing topdec
@
text
@d11 3
d236 3
a238 1
  sharing type ShellTypes.ShellData = ShellStructure.ShellData
d400 1
a400 7
                  ActionQueue.do_actions
                  (0,
                   ShellTypes.get_context_ref shell_data,
                   do_output,
                   ShellTypes.make_incremental_options shell_data,
                   ShellTypes.get_current_print_method_table shell_data
                   );
@


1.69
log
@Error wrap of call to incremental parser.  Restructuring of the command loop
@
text
@d11 3
d371 2
a402 1
                  reset_prompt();
@


1.68
log
@Changed to allow error wrapping of incremental parsing.
Loop function simplified.
Pass new parser basis to Incremental.add_source
Fixed line numbering of blank lines.
@
text
@d11 6
d357 9
d367 4
a370 2
                  val (new_context, identifiers) =
                    Incremental.add_source
d372 2
a373 1
                    (!current_context,Compiler.TOPDEC ("listener input",topdec,new_pB))
d376 4
d387 1
a387 9
                  val new_context = 
                    ActionQueue.do_actions
                    (0,
                     new_context,
                     do_output,
                     ShellTypes.make_incremental_options shell_data,
                     ShellTypes.get_current_print_method_table shell_data
                     )
                  val _ = ShellTypes.update_options shell_data
d390 8
@


1.67
log
@Changed ShellData type to include all shell information
@
text
@d11 3
d244 17
a260 17
    fun shell shell_data =
      let
        val prompt_args =
          {subline = ref 0,
           name = ref (Incremental.name (ShellTypes.get_current_context shell_data)),
           topdec = ref (Incremental.topdec (ShellTypes.get_current_context shell_data))}

        fun prompt() =
          let
            val {subline, name, topdec} = prompt_args
	    val result =
              (ShellTypes.get_current_prompter shell_data)
              {line = ~1, subline = !subline,name = !name, topdec = !topdec}
	  in
            subline := !subline + 1;
	    result
          end
d262 1
a262 1
        val line_count = ref 1
d264 2
a265 1
	val context = ShellStructure.make_shell_structure shell_data
d267 1
a267 1
        val _ = ShellTypes.set_current_context(shell_data,context)
d269 4
a272 2
        val current_parser_state = ref Parser.initial_parser_state
        val current_pB = ref (Incremental.parser_basis (ShellTypes.get_current_context shell_data))
d274 2
a275 2
	fun reset_prompt () =
          #subline prompt_args := 0
d277 58
a334 100
        fun do_line (do_output,line) =
           let
             fun trivial 0 = true
             |   trivial n =
               let
                 val c = MLWorks.String.ordof (line, n-1)
               in
                 (c = ord " " orelse c = ord "\n" orelse
                  c = ord "\t" orelse c = ord "\012") andalso
                 trivial (n-1)
               end
           in
             if trivial (size line) then
               (let val subline_ref = #subline prompt_args
               in
                  subline_ref := (!subline_ref) - 1
               end)
             else
               let
                 val input_function =
                   let val buff = ref line
                   in
                     fn _ => (let val out = !buff in buff := ""; out end)
                   end
                 
                 val token_stream = Lexer.mkLineTokenStream (input_function,
                                                             "Listener Input",
                                                             !line_count)
                 val _ = line_count := (!line_count) + 1

                 fun loop () =
                   let
                     datatype Action = STOP |
				       AGAIN
                     fun loop' () =
                       if Lexer.eof token_stream then
			 STOP
                       else
                         let val (pB,new_state) =
                           Parser.parse_incrementally
                           (ShellTypes.get_error_info shell_data,
                            ShellTypes.get_current_options shell_data)
                           (token_stream,!current_pB,!current_parser_state)
                         in
                           (current_parser_state := new_state;
                            current_pB := pB;
                            STOP
			   )
                         end
                       handle Parser.FoundTopDec(topdec,newpB) =>
                         let
                           val context = ShellTypes.get_current_context shell_data
                           val (new_context, identifiers) =
                             Incremental.add_source
                             (ShellTypes.make_incremental_options shell_data)
                             (context,Compiler.TOPDEC ("listener input",topdec))
                           val _ = ShellTypes.update_options shell_data

                           val _ = 
                             InterPrint.definitions
			       do_output
			       (ShellTypes.get_error_info shell_data)
			       (new_context,
                                ShellTypes.make_printer_descriptor shell_data,
                                0, identifiers);
                           val new_context = 
                             ActionQueue.do_actions
                             (0,
                              new_context,
                              do_output,
                              ShellTypes.make_incremental_options shell_data,
                              ShellTypes.get_current_print_method_table shell_data
                              )
                           val _ = ShellTypes.update_options shell_data
                         in
                           (#subline prompt_args) := 0;
                           (#topdec prompt_args) := Incremental.topdec new_context;
                           (#name prompt_args) := Incremental.name new_context;
                           ShellTypes.set_current_context(shell_data,new_context);
                           current_pB := Incremental.parser_basis (new_context);
                           current_parser_state := Parser.initial_parser_state;
                           AGAIN
                         end
                       | Parser.SyntaxError(token,location) =>
                           (current_parser_state := Parser.initial_parser_state;
                            current_pB := Incremental.parser_basis(ShellTypes.get_current_context shell_data);
                            (#subline prompt_args) := 0;
                            do_output (implode [Lexer.Info.Location.to_string location,
                                                ": Unexpected ",
                                                token,
                                                "\n"]);
                            STOP)
                     fun cycle () =
                       let
                         val res = loop' ()
                       in
                         case res of
                           AGAIN => cycle()
                         | STOP => ()
                       end
d336 4
a339 1
                     cycle ()
d341 67
a407 14
                 handle Lexer.Info.Stop _ =>
                   (current_parser_state := Parser.initial_parser_state;
                    current_pB := Incremental.parser_basis(ShellTypes.get_current_context shell_data);
                    reset_prompt())
                 | DebuggerTrapped => reset_prompt()
                 | Interrupt => reset_prompt()
               in
                 loop()
               end
           end
      in
        (do_line, prompt)
      end (* of shell *)

@


1.66
log
@Fixed problem with prompts
do_line now takes an output function
@
text
@d11 4
d221 1
a221 1
  sharing type ShellTypes.ShellArgs = ShellStructure.ShellArgs
d236 1
a236 1
  type Args = ShellTypes.ShellArgs
d241 1
a241 1
    fun shell (args as ShellTypes.SHELL_ARGS (shell_data,_, _, _, _)) =
d261 1
a261 1
	val context = ShellStructure.make_shell_structure args
@


1.65
log
@Options & Info changes
@
text
@d11 3
a243 2
        val increment_ref = ref false

a246 1
            val _ = if !increment_ref then subline := !subline + 1 else ()
d251 1
a251 1
            increment_ref := true;
d265 1
a265 3
          (#subline prompt_args := 0;
           increment_ref := false;
           "\n" ^ prompt())
d267 1
a267 1
        fun do_line line =
d280 4
a283 2
               (increment_ref := false;
                prompt ())
d299 1
a299 1
                     datatype Action = STOP of string |
d303 1
a303 1
			 STOP(prompt())
d308 1
a308 1
                            ShellTypes.get_current_print_options shell_data)
d313 1
a313 1
                            STOP(prompt())
d327 1
a327 1
			       std_out
d336 1
a336 1
                              fn s => output(std_out,s),
a339 1

d343 1
a343 3
                           increment_ref := false;
                           (#topdec prompt_args) :=
			     Incremental.topdec new_context;
a352 1
                            increment_ref := false;
d354 5
a358 5
                            STOP(implode [Lexer.Info.Location.to_string location,
                                          ": Unexpected ",
                                          token,
                                          "\n",
                                          prompt()]))
d365 1
a365 1
                         | STOP x => x
d373 3
a375 6
		    reset_prompt()
		   )
                 | DebuggerTrapped =>
		    reset_prompt()
                 | Interrupt =>
		    reset_prompt()
d381 1
a381 1
        (do_line, reset_prompt)
@


1.64
log
@Completely revised.  Much stuff moved to _action_queue, _shell_structure,
_user_options and _tty_listener.  The shell now provides a core service
to both TTY-based and X-based listeners.
@
text
@d11 5
d180 1
a180 2
require "../main/toplevel";
require "../debugger/ml_debugger";
d189 2
a191 3
  structure Lists : LISTS
  structure TopLevel : TOPLEVEL
  structure Ml_Debugger : ML_DEBUGGER
d198 7
a204 16
	  InterPrint.Incremental =
	  UserOptions.Incremental =
	  ActionQueue.Incremental =
	  Ml_Debugger.Incremental

  sharing type ShellTypes.printer_descriptor =
	       Ml_Debugger.ValuePrinter.printer_descriptor =
	       UserOptions.printer_descriptor =
	       InterPrint.ValuePrinter.printer_descriptor =
	       ActionQueue.printer_descriptor

  sharing type ShellTypes.ShellArgs =
	       ShellStructure.ShellArgs

  sharing type ShellTypes.Incremental.context =
	       ShellStructure.Context
d206 1
a206 2
  sharing Ml_Debugger.ValuePrinter.Debugger_Types.Info =
	  InterPrint.Incremental.InterMake.Compiler.Parser.Lexer.Info
d208 1
a208 2
  sharing type UserOptions.user_options =
	       ShellTypes.user_options
d210 9
a218 2
  sharing InterPrint.Incremental.InterMake.Compiler.MirTypes =
	  TopLevel.MirTypes
d221 1
a221 1
  structure Incremental = InterPrint.Incremental
d223 5
a227 2
  structure Parser = Compiler.Parser
  structure Lexer = Parser.Lexer
d230 1
a230 1
  type Context = Incremental.context
d234 1
a234 16
    fun shell (context,
	       args as ShellTypes.SHELL_ARGS
		 (prompter,
          	  shell_options as
	    	    Incremental.OPTIONS{
	      	      make_options,
              	      compiler_options as Compiler.MirTypes.OPTIONS{
			info_opts,
			...
	      	      },
              	      debugger
	    	    },
          	  print_options,
	  	  user_options,
	  	  _, _, _, _
              )) =
d238 2
a239 2
           name = ref (Incremental.name context),
           topdec = ref (Incremental.topdec context)}
d248 2
a249 2
              prompter {line = ~1, subline = !subline,
		        name = !name, topdec = !topdec}
d257 1
a257 4
        val current_context = ref context

	val context =
	  ShellStructure.make_shell_structure (current_context, args)
d259 1
a259 1
        val _ = current_context := context
a260 1
        val current_shell_options = ref shell_options
d262 1
a262 1
        val current_pB = ref (Incremental.parser_basis (!current_context))
d300 2
a301 9
				       AGAIN of Incremental.options
                     fun loop' (
                       shell_options as Incremental.OPTIONS {
                         compiler_options = Compiler.MirTypes.OPTIONS {
                           info_opts = info_opts as Lexer.Info.OPTIONS info_rec,
                           ...
                         },
                         ...
                       })  =
d307 3
a309 2
                             info_opts
                             (token_stream,!current_pB,!current_parser_state)
a312 1
                            current_shell_options := shell_options;
d318 1
a318 1
                           val context = !current_context
d320 5
a324 15
                             Incremental.add_source shell_options (
			       context, 
                               Compiler.TOPDEC ("listener input",topdec)
			     )
			   val (info_options', shell_options') =
			     UserOptions.new_shell_options (
			       user_options,
			       info_opts,
			       shell_options
			     )
			   val print_options' =
			     UserOptions.new_pr_options (
			       user_options,
			       print_options
			     )
d328 4
a331 2
			       info_options'
			       (new_context, print_options', 0, identifiers);
d333 9
a341 13
                             ActionQueue.do_actions(
                               0,
                               new_context,
                               fn s => output(std_out,s),
                               shell_options',
                               print_options'
			     )
			   val (info_options'', shell_options'') =
			     UserOptions.new_shell_options (
			       user_options,
			       info_options',
			       shell_options'
			     )
d348 2
a349 3
                           current_context := new_context;
                           current_pB :=
			     Incremental.parser_basis (new_context);
d351 1
a351 1
                           AGAIN shell_options''
d355 1
a355 1
                            current_pB := Incremental.parser_basis(!current_context);
d363 1
a363 1
                     fun cycle shell_opts =
d365 1
a365 1
                         val res = loop' shell_opts
d368 1
a368 1
                           AGAIN shell_opts' => cycle shell_opts'
d372 1
a372 1
                     cycle (! current_shell_options)
d376 1
a376 1
                    current_pB := Incremental.parser_basis(!current_context);
@


1.63
log
@Added Shell.break function.
@
text
@d4 1
a4 1
 *
a10 3
 *  Revision 1.62  1993/02/19  19:18:23  jont
 *  Read and updated pervasive_library_dir on startup
 *
d18 1
a18 1
 *  Modfified to allow user control of listing options
a174 8
require "../basics/identprint";
require "../utils/crash";
require "../typechecker/types";
require "../typechecker/datatypes";
require "../typechecker/strenv";
require "../typechecker/tyenv";
require "../typechecker/valenv";
require "../typechecker/scheme";
a175 1
require "../make/recompile";
a176 3
require "../clm/listener";
require "../clm/podium";
require "../clm/dialogs";
d178 4
a181 1
require "version";
d184 55
a238 1150
functor Shell (structure InterPrint : INTERPRINT
    	       structure IdentPrint : IDENTPRINT
               structure Types : TYPES
               structure Strenv : STRENV
               structure Tyenv : TYENV
               structure Valenv : VALENV
               structure Scheme : SCHEME
               structure Lists : LISTS
               structure Ml_Debugger : ML_DEBUGGER
               structure Recompile : RECOMPILE
               structure TopLevel : TOPLEVEL
               structure Listener : LISTENER
               structure Podium  : PODIUM
               structure Dialogs  : DIALOGS
               structure Crash : CRASH
               structure Version : VERSION

               sharing Ml_Debugger.ValuePrinter.BasisTypes =
                 InterPrint.Incremental.InterMake.Compiler.BasisTypes =
                 TopLevel.BasisTypes
               sharing Types.Datatypes = Strenv.Datatypes = Tyenv.Datatypes =
                 Valenv.Datatypes = Scheme.Datatypes = TopLevel.BasisTypes.Datatypes

	       sharing Types.Datatypes.Ident = IdentPrint.Ident

	       sharing Listener.ClmTypes= Dialogs.ClmTypes = Podium.Widgets.ClmTypes

               sharing InterPrint.Incremental =
		 Ml_Debugger.Incremental =
		 Listener.Incremental

	       sharing TopLevel.MirTypes =
		 InterPrint.Incremental.InterMake.Compiler.MirTypes =
		 Recompile.MirTypes

               sharing InterPrint.ValuePrinter = Ml_Debugger.ValuePrinter

               val default_prompter :
		 {line : int, subline : int, name : string, topdec : int} ->
		   string
) : SHELL =
  struct

    structure Incremental = InterPrint.Incremental
    structure InterMake = Incremental.InterMake
    structure Compiler = InterMake.Compiler
    structure Parser = Compiler.Parser
    structure Lexer = Parser.Lexer
    structure BasisTypes = InterMake.Compiler.BasisTypes
    structure Datatypes = Types.Datatypes
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Info = Lexer.Info
    structure Debugger_Types = Compiler.MirTypes.Debugger_Types
    structure FileName = InterMake.FileName
    structure Option = FileName.Option

    fun get_info_opts options =
      case options of 
	Incremental.OPTIONS {
                             compiler_options = Compiler.MirTypes.OPTIONS {info_opts, ...},
                             ...
                             } =>
        info_opts

    fun interactive_input (name, instream, outstream, prompter) =
      let
        val prompter_arg =
          {subline = ref 0, name = ref "", topdec = ref 0}
          
        fun prompt line_number =
          let
            val arg =
              let
                val {subline, name, topdec} = prompter_arg
              in
                {line = line_number, subline = !subline,
		 name = !name,       topdec = !topdec}
              end
          in
            output (outstream, prompter arg);
            MLWorks.IO.flush_out outstream;
            let
              val line = MLWorks.IO.input_line instream
                
              fun trivial 0 = true
                | trivial n =
                  let
                    val c = MLWorks.String.ordof (line, n-1)
                  in
                    (c = ord " " orelse c = ord "\n" orelse
                     c = ord "\t" orelse c = ord "\012") andalso
                    trivial (n-1)
                  end
            in
              if line = "" (*eof*) then line else
                if trivial (size line) then
                  prompt line_number
                else
                  ((#subline prompter_arg) := !(#subline prompter_arg)+1;
                   line)
            end
          end
      in
        (prompter_arg, Lexer.mkInteractiveTokenStream (prompt, name))
      end
    
    exception DebuggerTrapped
    datatype QueueEntry =
      REMAKE_FILE of FileName.absolute |
      MAKE of FileName.absolute |
      USE of string |
      CLEAR_DEBUG_INFO
      
    val default_print_desc =
      InterPrint.ValuePrinter.toplevel_default_print_descriptor
      
    (* dealing with makes and uses *)

    fun empty_action_queue (
                            action_queue,
                            level,
                            context,
                            outstream,
                            options,
                            consumer,
                            print_options
                            ) =
      let
        exception Error of (string * Incremental.context)
        fun aux (context,level) =
          let
            val filenames = rev (!action_queue)
          in
            action_queue := [];
            Lists.reducel
            (fn (context, CLEAR_DEBUG_INFO) =>
             Incremental.clear_debug_info context
          | (context, REMAKE_FILE filename) =>
              Incremental.delete_module options (context, filename)
          | (context, MAKE filename) =>
              (let
                val (new_context, identifiers) =
                  Incremental.add_module options (context, filename)
              in
                 InterPrint.definitions
                 outstream
                 (get_info_opts options)
                 (new_context, print_options, 0, identifiers);
                 new_context
              end
            handle 
            Incremental.Error(subcontext,_) => 
              (raise Error (implode ["Error making `", 
                                     FileName.absolute_name filename,
                                     "'\n"
                                     ],
                 subcontext))
          | exn as Error _ => raise exn
          | exn => 
              (raise Error (implode ["Error making `", 
                                     FileName.absolute_name filename,
                                     "'\n"
                                     ],
                 context)))
          | (context, USE filename) =>
              let
                (* USE is more generous than make, compile or recompile.
                 It can read a file without a ".sml" extension!
                 For compatibility with other compilers.
                 *)
                val filename_sml =
                  if size filename < 4
                    orelse String.substring(filename,size filename - 4,4) <> ".sml"
                    then filename ^ ".sml"
                  else filename           
                val (stream, filename) =
                  (open_in filename_sml, filename_sml)
                  handle Io _ => (open_in filename, filename)
                val _ = consumer(level,filename)
                val token_stream =
                  Lexer.mkFileTokenStream (stream, filename)
                  
                fun next context =
                  if Lexer.eof token_stream then
                    (close_in stream; context)
                  else
                    let
                      val (context, identifiers) =
                        Incremental.add_source options
                        (context, Compiler.TOKENSTREAM1 token_stream)
                    in
                      InterPrint.definitions
                      outstream
                      (get_info_opts options)
                      (context,print_options, 0, identifiers);
                      next (aux (context,level+1))
                    end
              in
                next context
                handle
                exn as Error _ => raise exn
              | exn =>
                  (raise Error (implode ["Error using `", 
                                         filename,
                                         "'\n"
                                         ],
                                context))
              end
            handle exn as Io s =>
              raise Error (s ^ "\n",context))
            (context, filenames)
          end
      in
        aux (context,level)
        handle Error (s,context) => (output(std_out,s);context)
             | exn => context
      end

    (* write indented filenames, used in empty_action_queue *)
      
    fun mk_consumer print (n,x) =
      let
        fun spaces y =
          if y <= 0 then x else ("   " ^ spaces (y-1))
      in
        print (spaces n ^ "\n")
      end
    
    
    (* made the action queue global -- code should ensure that it is never *)
    (* left unemptied *)
  
    val action_queue = ref ([]  : QueueEntry list)
      
    (* user options *)
      
    type user_options = {
                         show_fn_details:	        bool ref,
                         show_exn_details:	        bool ref,
                         maximum_list_size:        int ref,
                         maximum_depth:	        int ref,
                         maximum_shape_depth:      int ref,
                         maximum_ref_depth:        int ref,
                         generate_tracing_code:    bool ref,
                         generate_profiling_code:  bool ref,
                         generate_debug_info:      bool ref,
                         show_debug_warnings:      bool ref,
                         optimise_leaf_fns:        bool ref,
                         optimise_tail_calls:      bool ref,
                         optimise_self_tail_calls: bool ref,
                         show_id_class:	        bool ref,
                         show_eq_info:	        bool ref,
                         show_absyn:	        bool ref,
                         show_match:	        bool ref,
                         show_environ:	        bool ref,
                         show_lambda:	        bool ref,
                         show_opt_lambda:	        bool ref,
                         show_mir:	  	        bool ref,
                         show_opt_mir:	        bool ref,
			 show_mach:             bool ref,
                         show_debug_info:	        bool ref,
                         show_timings:	        bool ref,
                         show_print_timings:       bool ref
                         }
      
    (* These references can be set by the user.  *)
    fun make_user_options (
                           InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc,
                           Compiler.MirTypes.OPTIONS
                           {info_opts = Info.OPTIONS {
                                                      show_id_class,
                                                      show_eq_info,
                                                      ...
                                                      },
			   list_opts = Compiler.MirTypes.BELO {
							       show_absyn,
							       show_lambda,
							       show_match,
							       show_opt_lambda,
							       show_environ,
							       show_mir,
							       show_opt_mir,
							       show_mach
							       },
                           trace,
                           profile,
                           debug,
                           debug_warnings,
                           opt_leaf_fns,
                           opt_tail_calls,
                           opt_self_calls,
			   ...
                           }) =
      {maximum_list_size        = ref (#maximum_list_size print_desc),
       maximum_ref_depth        = ref (#maximum_ref_depth print_desc),
       maximum_shape_depth      = ref (#maximum_shape_depth print_desc),
       maximum_depth            = ref (#maximum_depth print_desc),
       show_fn_details          = ref (#print_fn_details print_desc),
       show_exn_details         = ref (#print_exn_details print_desc),
       generate_tracing_code    = ref trace,
       generate_profiling_code  = ref profile,
       generate_debug_info      = ref debug,
       show_debug_warnings      = ref debug_warnings,
       optimise_leaf_fns        = ref opt_leaf_fns,
       optimise_tail_calls      = ref opt_tail_calls,
       optimise_self_tail_calls = ref opt_self_calls,
       show_id_class	        = ref show_id_class,
       show_eq_info 	        = ref show_eq_info,
       show_absyn		= ref show_absyn,
       show_match		= ref show_match,
       show_lambda		= ref show_lambda,
       show_environ		= ref show_environ,
       show_opt_lambda	        = ref show_opt_lambda,
       show_mir		        = ref show_mir,
       show_opt_mir		= ref show_opt_mir,
       show_mach		= ref show_mach,
       show_debug_info	        = ref false,
       show_timings		= ref false,
       show_print_timings	= ref false
       }
      
    fun new_pr_options (
                        user_options: user_options,
                        InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc
                        ) = 
      InterPrint.ValuePrinter.PRINTER_DESCRIPTOR 
      {print_fn_details =
       !(#show_fn_details user_options),
       print_exn_details =
       !(#show_exn_details user_options),
       maximum_list_size =
       !(#maximum_list_size user_options),
       maximum_ref_depth =
       !(#maximum_ref_depth user_options),
       maximum_shape_depth =
       !(#maximum_shape_depth user_options),
       maximum_depth =
       !(#maximum_depth user_options),
       print_method_table =
       #print_method_table print_desc
       }
      
    fun new_info_options (
                          user_options: user_options,
                          Info.OPTIONS info_rec
                          ) =
      Info.OPTIONS {
                    error = #error info_rec,
                    information = #information info_rec,
                    listing = #listing info_rec,
                    diagnostic = #diagnostic info_rec,
                    show_eq_info = !(#show_eq_info user_options),
                    show_id_class = !(#show_id_class user_options)
                    }
      
    fun new_compiler_options (user_options: user_options, info_options) =
      Compiler.MirTypes.OPTIONS 
      {info_opts = new_info_options (user_options, info_options),
       list_opts = Compiler.MirTypes.BELO {
	 show_absyn = !(#show_absyn user_options),
	 show_lambda = !(#show_lambda user_options),
	 show_match = !(#show_match user_options),
         show_opt_lambda = !(#show_opt_lambda user_options),
         show_environ = !(#show_environ user_options),
         show_mir = !(#show_mir user_options),
         show_opt_mir = !(#show_opt_mir user_options),
         show_mach = !(#show_mach user_options)
	 },
       debug = !(#generate_debug_info user_options),
       profile = !(#generate_profiling_code user_options),
       trace = !(#generate_tracing_code user_options),
       debug_warnings = !(#show_debug_warnings user_options),
       opt_leaf_fns = !(#optimise_leaf_fns user_options),
       opt_tail_calls = !(#optimise_tail_calls user_options),
       opt_self_calls = !(#optimise_self_tail_calls user_options)
       }
      
    fun new_shell_options (
                           user_options: user_options,
                           info_options,
                           Incremental.OPTIONS {
                                                debugger,
                                                make_options = InterMake.OPTIONS {
                                                                                  name_monitor,
                                                                                  ...
                                                                                  },
                                                ...
                                                }) =
      let
        val info_options' =
	  new_info_options (user_options, info_options)
        val compiler_options' =
	  new_compiler_options (user_options, info_options')
        val shell_options' =
          Incremental.OPTIONS {
                               compiler_options = compiler_options',
                               make_options = InterMake.OPTIONS {
                                                                 name_monitor = name_monitor,
                                                                 compiler_options = compiler_options'
                                                                 },
                               debugger = debugger
                               }
      in
	(info_options', shell_options')
      end
    
    datatype option_place = OPTIONS_PRESENT of Info.options | OPTIONS_ABSENT

    fun parse_absolute (filename,opt) =
      FileName.parse_absolute filename
      handle FileName.Parse _ => 
        (FileName.parse_absolute(MLWorks.OS.Unix.getwd() ^
                                            "/" ^ filename)
         handle (exn as FileName.Parse _) => 
           (case opt of
              OPTIONS_PRESENT info_opts =>
                Info.error'
                info_opts
                (Info.FATAL, 
                 Info.Location.UNKNOWN, 
                 "Invalid Filename : " ^ filename)
            | OPTIONS_ABSENT => raise exn))
        
    exception NotImplemented
    fun not_implemented () =
      raise NotImplemented
        
    fun show_debug_info options (name,context) =
      let
        fun is_a_substring(a,b) =
          if size a > size b
            then 
              false
          else
            let
              val length_a = size a
              val maximum_index = size b - length_a
              fun search x =
                if x < 0
                  then
                    false
                else
                  if String.substring(b,x,length_a) = a
                    then
                      true
                  else search(x-1)
            in
              search maximum_index
            end
        val Debugger_Types.INFO debug_info = Incremental.debug_info context
        val Debugger_Types.INFO empty_map = Debugger_Types.empty_information
        val filtered_map =
          if name = ""
            then
              debug_info
          else
            Debugger_Types.Datatypes.NewMap.fold
            (fn (old_map,from,to) =>
             if is_a_substring (name,from) 
               then 
                 Debugger_Types.Datatypes.NewMap.define(old_map,from,to)
             else
               old_map)
            (empty_map,debug_info)
      in
        output(std_out,Debugger_Types.string_information options (Debugger_Types.INFO filtered_map));
        ()
      end
    
    fun show_signatures context =
      map
      IdentPrint.printSigId
      (Datatypes.NewMap.domain (Incremental.signatures context))
      
    fun show_functors context =
      let
	val funmap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_, BasisTypes.FUNENV map, _, _) => map
      in
	map
        IdentPrint.printFunId
        (Datatypes.NewMap.domain funmap)
      end
    
    fun show_structures context =
      let
	val strmap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_, _, _, Datatypes.ENV(Datatypes.SE map, _, _, _)) =>
	      map
      in
	map
        IdentPrint.printStrId
        (Datatypes.NewMap.domain strmap)
      end
    
    fun show_types context =
      let
	val tymap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_, _, _, Datatypes.ENV(_, Datatypes.TE map, _, _)) =>
	      map
      in
	map
        IdentPrint.printTyCon
        (Datatypes.NewMap.domain tymap)
      end
    
    fun show_values p context =
      let
	val valmap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_, _, _,
			 Datatypes.ENV(_, _, Datatypes.VE(_, map), _)) =>
            map
            
	fun getsym (Ident.VAR s) = s
          |   getsym (Ident.CON s) = s
          |   getsym (Ident.EXCON s) = s
      in
	map
        (Symbol.symbol_name o getsym)
        (Lists.filterp p (Datatypes.NewMap.domain valmap))
      end
    
    fun show_exceptions context =
      let
	val exnmap =
	  case Incremental.type_basis context of
	    BasisTypes.BASIS (_, _, _,
			 Datatypes.ENV(_, _, _, Datatypes.VE(_, map))) =>
            map
      in
	map
        (Symbol.symbol_name o
         (fn (Ident.EXCON s) => s
       | _ => Crash.impossible "non-exception in exception environment"
           ))
        (Datatypes.NewMap.domain exnmap)
      end
    
    (* make the visible structures of the shell. This is called each time
     a shell is made *)
   
    fun make_shell_structure(
                             context,
                             user_options: user_options,
                             outstream,
                             print_options,
                             shell_options as Incremental.OPTIONS
                             {make_options,
                              compiler_options as Compiler.MirTypes.OPTIONS
                              {info_opts = info_opts as Info.OPTIONS info_rec,
                               ...
                               },
                              ...
                              },
                             current_context,
                             prompter,
                             action_queue,
                             ts_ref,
                             exit_fn,
                             xinterface_flag
                             ) =
      let
        open Datatypes
          
        (* utilities for making the structures visible in shell *)
          
        (* make the types *)
          
        fun make_pair (a,b) = 
          Types.add_to_rectype
          (Ident.LAB (Symbol.find_symbol "1"),
           a,
           Types.add_to_rectype(
                                Ident.LAB (Symbol.find_symbol "2"),
                                b,
                                Types.empty_rec_type
                                ))
          
        val string_pair = 
          make_pair(
                    CONSTYPE([],Types.string_tyname),
                    CONSTYPE([],Types.string_tyname)
                    )
          
        val consumer_type = 
          FUNTYPE(
                  make_pair(
                            CONSTYPE([],Types.string_tyname),
                            FUNTYPE(Types.string_type, Types.empty_rec_type)
                            ),
                  Types.string_type
                  )
          
        (* Make up the type ('a -> 'b) -> unit *)
        val alpha_beta_bool =
          let 
            val aty = TYVAR (ref 0,
			     Ident.TYVAR (Ident.Symbol.find_symbol ("'a"),
					  false,
					  false
                                          )
                             )
            val bty = TYVAR (ref 0,
			     Ident.TYVAR (Ident.Symbol.find_symbol ("'b"),
					  false,
					  false
                                          )
                             )
          in
            Scheme.make_scheme ([aty,bty],
                                FUNTYPE(
                                        FUNTYPE(aty,bty),
                                        CONSTYPE([],Types.bool_tyname)
                                        ))
          end
        
        val show_type = 
          FUNTYPE (
                   Types.empty_rec_type,
                   CONSTYPE([CONSTYPE([],Types.string_tyname)], Types.list_tyname)
                   )
          
        val unit_to_unit = 
          FUNTYPE (Types.empty_rec_type, Types.empty_rec_type)
          
        val int_to_unit = 
          FUNTYPE (Types.int_type, Types.empty_rec_type)
          
        val string_to_unit = 
          FUNTYPE (Types.string_type, Types.empty_rec_type)
          
	val string_ref =
	  CONSTYPE([CONSTYPE([], Types.string_tyname)], Types.ref_tyname)
          
        (* this returns the data needed by the listener widget *)
        fun command_handler_fn shell_window current_context =
          (fn window_fn =>
           let
             val print_options' = new_pr_options (user_options, print_options)

             val (info_opts', shell_options') =
	       new_shell_options (user_options, info_opts, shell_options)
               
             fun debugger_function (a,b,current_module) f x =
               let
                 val call_debugger =
                   Ml_Debugger.ml_debugger 
                   Ml_Debugger.TERMINAL
                   info_opts'
                   (print_options', a, b,current_module)
                   (fn _ => output(std_out,"Shell not defined yet|\n"))
               in
                 MLWorks.Internal.Value.frame_call
                 (fn base_frame =>
                  ((MLWorks.Internal.Tracing.with_tracing (
                                                          fn in_value => 
                                                          call_debugger 
                                                          Ml_Debugger.NO_BASE_FRAME 
                                                          (Ml_Debugger.TRACE in_value,
                                                           Ml_Debugger.NOT_POSSIBLE,
                                                           Ml_Debugger.NOT_POSSIBLE
                                                           ))
                  f
                  x
                  handle exn as Listener.Listener_Exit => raise exn
                       | exn => 
                           (Ml_Debugger.ml_debugger 
                            (Ml_Debugger.WINDOWING window_fn)
                            info_opts'
                            (print_options', a, b,current_module)
                            (fn _ => output(std_out,"Shell not defined yet|\n"))
                            (Ml_Debugger.BASE_FRAME base_frame)
                            (Ml_Debugger.EXCEPTION exn,
                             Ml_Debugger.NOT_POSSIBLE,
                             Ml_Debugger.NOT_POSSIBLE);
                            raise DebuggerTrapped
                              ))))
               end
               
             fun copy_options (Incremental.OPTIONS x) =
               Incremental.OPTIONS
               {compiler_options = #compiler_options x,
                make_options = #make_options x,
                debugger = debugger_function
                }
               
             val interface =
               make_listener_shell
               (!current_context,
                prompter,
                copy_options shell_options',
                print_options',
                shell_window
                )
           in
             interface
           end)
          
        (* make the context itself *)
          
        val context =
          let
            val (context, identifiers) =
              Incremental.add_value shell_options
              (context,
               "use",
               UNBOUND_SCHEME (
                               FUNTYPE (Types.string_type, Types.empty_rec_type)
                               ),
               MLWorks.Internal.Value.cast
               (fn filename => action_queue := USE(filename) :: !action_queue))
          in
            context
          end
        
        val xinterface_fn =
          MLWorks.Internal.Value.cast 
          (fn (h,s) =>
           if xinterface_flag
             then
               Info.error
               info_opts
               (Info.RECOVERABLE, Lexer.locate (!ts_ref), "X interface already started\n")
           else
             Podium.start_mlworks
             (Listener.make_listener
              current_context
              command_handler_fn,
              h,
              s
              ))
          
	fun mk_valenv l =
	  Lists.reducel
	  (fn (ve, (name, ty)) =>
	   Valenv.add_to_ve
	   (Ident.VAR(Ident.Symbol.find_symbol name),
	    UNBOUND_SCHEME ty,
	    ve))
	  (empty_valenv, l)

	fun mk_exnenv l =
	  Lists.reducel
	  (fn (ve, (name, ty)) =>
	   Valenv.add_to_ve
	   (Ident.EXCON(Ident.Symbol.find_symbol name),
	    UNBOUND_SCHEME ty,
	    ve))
	  (empty_valenv, l)

	fun mk_strenv l =
	  Lists.reducel
	  (fn (se, (name, str)) =>
	   Strenv.add_to_se(
			    Ident.STRID(Ident.Symbol.find_symbol name),
			    str,
			    se
			    )
	   )
	  (Strenv.empty_strenv, l)

	fun mk_mixed_structure(strs, vals, exns) =
          STR (
	       STRNAME (Strname_id.make_strname_id ()),
               ref ABSENT,
	       ENV(
                   mk_strenv strs,
                   Tyenv.empty_tyenv,
		   mk_valenv vals,
                   mk_exnenv exns
                   )
               )

	fun mk_structure l = mk_mixed_structure([], l, [])
	  
	fun mk_ref t = CONSTYPE([CONSTYPE([], t)], Types.ref_tyname)
          
        val value_printer_structure = mk_structure
          [("show_fn_details",  mk_ref Types.bool_tyname),
           ("show_exn_details",  mk_ref Types.bool_tyname),
           ("show_id_class",  mk_ref Types.bool_tyname),
           ("show_eq_info",  mk_ref Types.bool_tyname),
           ("maximum_list_size",  mk_ref Types.int_tyname),
           ("maximum_ref_depth",  mk_ref Types.int_tyname),
           ("maximum_shape_depth",  mk_ref Types.int_tyname),
           ("maximum_depth",  mk_ref Types.int_tyname)
           ]

	val value_printer_record =
          MLWorks.Internal.Value.cast 
          {maximum_depth =
           MLWorks.Internal.Value.cast
           (#maximum_depth user_options),
           maximum_shape_depth =
           MLWorks.Internal.Value.cast(
                                       #maximum_shape_depth user_options
                                       ),
           maximum_ref_depth =
           MLWorks.Internal.Value.cast(
                                       #maximum_ref_depth user_options
                                       ),
           maximum_list_size =
           MLWorks.Internal.Value.cast(
                                       #maximum_list_size user_options
                                       ),
           show_fn_details =
           MLWorks.Internal.Value.cast(
                                       #show_fn_details user_options
                                       ),
           show_exn_details =
           MLWorks.Internal.Value.cast(
                                       #show_exn_details user_options
                                       ),
           show_id_class =
           MLWorks.Internal.Value.cast(
                                       #show_id_class user_options
                                       ),
           show_eq_info =
           MLWorks.Internal.Value.cast(
                                       #show_eq_info user_options
                                       )
           }
          
	val internals_structure = mk_structure
	  [("show_absyn", mk_ref Types.bool_tyname),
	   ("show_lambda", mk_ref Types.bool_tyname),
	   ("show_opt_lambda", mk_ref Types.bool_tyname),
	   ("show_environ", mk_ref Types.bool_tyname),
	   ("show_mir", mk_ref Types.bool_tyname),
	   ("show_opt_mir", mk_ref Types.bool_tyname),
	   ("show_mach", mk_ref Types.bool_tyname)]

	val internals_record =
          MLWorks.Internal.Value.cast 
	  {
	   show_absyn =
	   MLWorks.Internal.Value.cast(#show_absyn user_options),
	   show_lambda =
	   MLWorks.Internal.Value.cast(#show_lambda user_options),
	   show_opt_lambda =
	   MLWorks.Internal.Value.cast(#show_opt_lambda user_options),
	   show_environ =
	   MLWorks.Internal.Value.cast(#show_environ user_options),
	   show_mir =
	   MLWorks.Internal.Value.cast(#show_mir user_options),
	   show_opt_mir =
	   MLWorks.Internal.Value.cast(#show_opt_mir user_options),
	   show_mach =
	   MLWorks.Internal.Value.cast(#show_mach user_options)
	   }

	val compiler_structure = mk_structure
          [("generate_tracing_code", mk_ref Types.bool_tyname),
           ("generate_profiling_code", mk_ref Types.bool_tyname),
	     ("generate_debug_info", mk_ref Types.bool_tyname),
	     ("show_debug_warnings", mk_ref Types.bool_tyname),
	     ("optimise_leaf_fns", mk_ref Types.bool_tyname),
	     ("optimise_tail_calls", mk_ref Types.bool_tyname),
	     ("optimise_self_tail_calls", mk_ref Types.bool_tyname)
             ]
          
	val compiler_record =
          MLWorks.Internal.Value.cast 
          {generate_tracing_code =
           MLWorks.Internal.Value.cast(
                                       #generate_tracing_code user_options
                                       ),
           generate_profiling_code =
           MLWorks.Internal.Value.cast
           (#generate_profiling_code user_options),
           generate_debug_info =
           MLWorks.Internal.Value.cast(
                                       #generate_debug_info user_options
                                       ),
           show_debug_warnings =
           MLWorks.Internal.Value.cast(
                                       #show_debug_warnings user_options
                                       ),
           optimise_leaf_fns =
           MLWorks.Internal.Value.cast(
                                       #optimise_leaf_fns user_options
                                       ),
           optimise_tail_calls =
           MLWorks.Internal.Value.cast(
                                       #optimise_tail_calls user_options
	         ),
           optimise_self_tail_calls =
           MLWorks.Internal.Value.cast(
                                       #optimise_self_tail_calls user_options
                                       )
           }
          
        val topenv_structure = mk_structure
          [("signatures", show_type),
           ("functors", show_type),
           ("structures", show_type),
           ("types", show_type),
           ("exceptions", show_type),
           ("constructors", show_type),
           ("variables", show_type),
           ("values", show_type)
           ]
          
	val topenv_record =
	     MLWorks.Internal.Value.cast {
	       a_signatures =
	         MLWorks.Internal.Value.cast(
	           fn () => show_signatures (!current_context)
	         ),
	       a_functors =
	         MLWorks.Internal.Value.cast(
	           fn () => show_functors (!current_context)
	         ),
	       a_structures =
	         MLWorks.Internal.Value.cast(
	           fn () => show_structures (!current_context)
	         ),
	       a_types =
	         MLWorks.Internal.Value.cast(
	           fn () => show_types (!current_context)
	         ),
	       a_exceptions =
	         MLWorks.Internal.Value.cast(
	           fn () => show_exceptions (!current_context)
	         ),
	       a_constructors =
	         MLWorks.Internal.Value.cast(
	           fn () => show_values
	    		  (fn (Ident.CON _) => true | _ => false)
	    		  (!current_context)
	         ),
	       a_variables =
	         MLWorks.Internal.Value.cast(
	           fn () => show_values
	    		  (fn (Ident.VAR _) => true | _ => false)
	    		  (!current_context)
	         ),
	       a_values =
	         MLWorks.Internal.Value.cast(
	           fn () => show_values
	    		  (fn _ => true)
	    		  (!current_context)
	         )
	    }

        val make_structure = mk_structure
	    [("make", string_to_unit),
	     ("remake_file", string_to_unit),
	     ("compile", string_to_unit),
	     ("recompile", string_to_unit)
	    ]


	val make_record =
	     MLWorks.Internal.Value.cast{
	       a_make =
	         MLWorks.Internal.Value.cast(
	           fn filename =>
	    	     action_queue :=
	    	       MAKE (parse_absolute (filename,OPTIONS_PRESENT info_opts)) :: !action_queue
	         ),
	       a_remake_file =
                 MLWorks.Internal.Value.cast(
                   fn filename =>
                     action_queue :=
                       MAKE(parse_absolute (filename,OPTIONS_PRESENT info_opts)) ::
			 REMAKE_FILE (parse_absolute (filename,OPTIONS_PRESENT info_opts)) ::
			 !action_queue
	         ),
	       a_compile =
	         MLWorks.Internal.Value.cast (
		   fn filename =>
		     let
		       val info_options' =
			 new_info_options (
			   user_options,
			   info_opts
			 )

		       val compiler_options' =
			 new_compiler_options (
			   user_options,
			   info_options'
			 )
		     in
		       TopLevel.compile_file
		         info_options'
		         compiler_options'
		         filename
		     end
		 ),
	       a_recompile =
	         MLWorks.Internal.Value.cast (
		   fn filename =>
		     let
		       val info_options' =
			 new_info_options (
			   user_options,
			   info_opts
			 )

		       val compiler_options' =
			 new_compiler_options (
			   user_options,
			   info_options'
			 )
		     in
		       Recompile.recompile
		         info_options'
		         compiler_options'
		         filename
		     end
		 )
	    }

	val debug_structure =
	     STR (
	       STRNAME (Strname_id.make_strname_id ()),
               ref ABSENT,
	       ENV (
		 Strenv.empty_strenv,
		 Tyenv.empty_tyenv,
		 Lists.reducel
		   (fn (ve, (name, typescheme)) =>
		      Valenv.add_to_ve(
		        Ident.VAR(Ident.Symbol.find_symbol name),
		        typescheme,
		        ve
		      )
		   )
		   (empty_valenv,
		    [("trace", alpha_beta_bool),
		     ("untrace", alpha_beta_bool),
		     ("show_debug_info", UNBOUND_SCHEME string_to_unit),
		     ("show_all_debug_info", UNBOUND_SCHEME unit_to_unit),
		     ("clear_debug_info", UNBOUND_SCHEME unit_to_unit)
		   ]),
		 empty_valenv
	       )
	     )

	val debug_record =
             MLWorks.Internal.Value.cast{
               a_trace =
                 MLWorks.Internal.Value.cast
                   MLWorks.Internal.Tracing.add_trace,
               a_untrace =
                 MLWorks.Internal.Value.cast
                   MLWorks.Internal.Tracing.remove_trace,
	       a_clear_debug_info =
	         MLWorks.Internal.Value.cast
		   (fn () =>
	    	     action_queue :=
	    	       CLEAR_DEBUG_INFO :: !action_queue),
	       a_show_debug_info =
	         MLWorks.Internal.Value.cast
                   (fn name => show_debug_info info_opts (name,!current_context)),
	       a_show_all_debug_info =
	         MLWorks.Internal.Value.cast
                   (fn () => show_debug_info info_opts ("",!current_context))
	    }

        val options_structure = mk_mixed_structure
	  ([("ValuePrinter", value_printer_structure),
	    ("Compiler", compiler_structure),
	    ("Internals", internals_structure)
	    ], [], [])

	val options_record =
	     (* Prefix "a_" for values, "b_" for exceptions,
	        and "c_" for structures, to ensure correct ordering.
	      *)
             MLWorks.Internal.Value.cast{
	       c_value_printer = value_printer_record,
	       c_compiler = compiler_record,
	       c_internals = internals_record
	     }

	fun break_function(options as Incremental.OPTIONS{make_options,
                                                          compiler_options as Compiler.MirTypes.OPTIONS{info_opts,...},...},
                           context,
                           current_module
                           ) =
          let
	    val print_options' = new_pr_options (user_options, print_options)
	    val (info_opts',
		 options' as Incremental.OPTIONS {
		   compiler_options = compiler_options',
		   make_options = make_options',
		   ...
		}) = 
	      new_shell_options (user_options, info_opts, options)
            val call_debugger =
              Ml_Debugger.ml_debugger 
              Ml_Debugger.TERMINAL
              info_opts'
              (print_options', options', context,current_module)
              (fn context' =>
               (shell (
                 std_in,
		 outstream,
		 (compiler_options',
		  make_options'
		 ),
                 context',
		 prompter,
		 print_options'
		);
                ()
	      ))
          in
            MLWorks.Internal.Value.frame_call
            (fn base_frame =>
             (fn s => (call_debugger 
                       (Ml_Debugger.BASE_FRAME base_frame)
                       (Ml_Debugger.BREAK s,
                        Ml_Debugger.POSSIBLE (
                                              "Return to TopLevel by raising Interrupt",
                                              Ml_Debugger.DO_RAISE Interrupt
                                              ),
                        Ml_Debugger.POSSIBLE (
                                              "Continue interrupted code",
                                              Ml_Debugger.NORMAL_RETURN
                                              ));
                       ())))
          end

        val break_fn =
          MLWorks.Internal.Value.cast((break_function (shell_options,context,"Foo")) : string -> unit)
               
	val save_fn =
              MLWorks.Internal.Value.cast (
	        fn filename =>
		  let
                    val old_level =
		      !MLWorks.Internal.Runtime.StorageManager.gc_message_level

		    val (info_options',
			 Incremental.OPTIONS {
			   compiler_options = compiler_options',
			   make_options = make_options',
			   ...
			}) =
		      new_shell_options (
			user_options,
d240 8
a247 101
			shell_options
		      )

                    fun collect 200 = ()
                      | collect n = 
                        (MLWorks.Internal.Runtime.StorageManager.interface (20,n);
                         collect(n+1)
                         )
                  in
                    MLWorks.Internal.Runtime.StorageManager.gc_message_level :=
		      ~1;
                    collect 0
                    handle MLWorks.Internal.Runtime.StorageManager.StorageManager _ => ();
                    MLWorks.Internal.Runtime.StorageManager.gc_message_level :=
		      old_level;
                    MLWorks.save (
		      filename,
		      fn () =>
                        MLWorks.IO.with_standard_output
                        MLWorks.IO.terminal_out
                        (fn () =>
                         MLWorks.IO.with_standard_input
                         MLWorks.IO.terminal_in
                         (fn () =>
                          (output (std_out, Version.version_string ^ "\n");
			   (case Incremental.get_pervasive_dir(MLWorks.OS.Unix.environment ()) of
			      Option.PRESENT str => TopLevel.pervasive_library_dir := str
			    | _ => ());
                           shell (
                                  std_in,
                                  std_out,
                                  (compiler_options', make_options'),
                                  !current_context,
                                  prompter,
                                  new_pr_options (user_options, print_options)
                                  )
                          ))))
                    handle MLWorks.Save message =>
                      Info.error'
		        info_opts
		        (Info.FATAL, Lexer.locate (!ts_ref), message)
                  end
	      )

        val context =
          let
            val (context, identifiers) =
              Incremental.add_structure
	        shell_options
                (context,
	         "Shell",
		 mk_mixed_structure
		 (
		  [("Make", make_structure),
		   ("Options", options_structure),
		   ("Debug", debug_structure),
		   ("TopEnv", topenv_structure)
		   ],
		  [("exit", int_to_unit),
		   ("xinterface",
		    FUNTYPE (string_pair, Types.empty_rec_type)),
		   ("save", string_to_unit),
                   ("break",string_to_unit)
		   ],
		  []),
	         (* Prefix "a_" for values, "b_" for exceptions,
		    and "c_" for structures, to ensure correct ordering.
	          *)
                 MLWorks.Internal.Value.cast{
                   a_break = break_fn,
		   a_exit = exit_fn,
		   a_save = save_fn,
		   a_xinterface = xinterface_fn,
                   c_topenv = topenv_record,
		   c_make = make_record,
		   c_debug = debug_record,
		   c_options = options_record
		 })
          in
            context
          end
      in
	current_context := context;
	context
      end (* of make_shell_structure *)

    and make_listener_shell (
	  context,
          prompter,
          shell_options as
	    Incremental.OPTIONS{
	      make_options,
              compiler_options as Compiler.MirTypes.OPTIONS{
		info_opts,
		...
	      },
              debugger
	    },
          print_options,
	  widget
        ) =
a269 2
	val user_options = make_user_options (print_options, compiler_options)

d272 2
a273 1
	val ts_ref = ref (Lexer.mkTokenStream (fn _ => "", "Dummy"))
a274 20
	val exit_fn =
	  fn _ => (Dialogs.popdown widget;
	    	   Podium.Widgets.destroy_widget widget;
		   raise Listener.Listener_Exit
		  )

	val context = make_shell_structure (
			context,
                        user_options,
                        std_out,
                        print_options,
                        shell_options,
                        current_context,
                        prompter,
                        action_queue,
			ts_ref,
			exit_fn,
                        true
		      )

d281 6
a286 4
        fun do_line outstream (line) =
          MLWorks.IO.with_standard_output
          outstream
          (fn () =>
a313 2
		 val _ = ts_ref := token_stream

d321 1
a321 1
                           info_opts = info_opts as Info.OPTIONS info_rec,
d349 1
a349 1
			     new_shell_options (
d355 4
a358 1
			     new_pr_options (user_options, print_options)
d361 1
a361 1
			       outstream
d365 1
a365 2
                             empty_action_queue(
			       action_queue,
d368 1
a368 1
                               outstream,
a369 1
                               mk_consumer (fn s => output(std_out,s)),
d373 1
a373 1
			     new_shell_options (
d395 1
a395 1
                            STOP(implode [Info.Location.to_string location,
d411 1
a411 1
                 handle Info.Stop _ =>
d414 1
a414 3
                    (#subline prompt_args) := 0;
                    increment_ref := false;
                    prompt()
d417 1
a417 3
                   ((#subline prompt_args) := 0;
                    increment_ref := false;
                    prompt())
d419 1
a419 3
                   ((#subline prompt_args) := 0;
                    increment_ref := false;
                    prompt())
d423 1
a423 66
           end)

        fun do_use outstream (name,consumer) =
          MLWorks.IO.with_standard_output
            outstream
            (fn () =>
	       let val (_, shell_options') =
		     new_shell_options (user_options, info_opts, shell_options)
	       in
	         action_queue := USE(name) :: !action_queue ;
                 current_context :=
	           empty_action_queue (
	             action_queue,
                     0,
                     !current_context,
                     outstream,
                     shell_options',
                     mk_consumer consumer,
                     new_pr_options (user_options, print_options)
	           );
                   #subline prompt_args := 0;
                   increment_ref := false;
                   "\n" ^ prompt ()
	       end
	    )

        fun do_make outstream (name,consumer) =
          MLWorks.IO.with_standard_output
            outstream
            (fn () => 
             (let
               val compiler_options' = 
                 new_compiler_options (
                                       user_options,
                                       info_opts
                                       )
               val shell_options' =
                 Incremental.OPTIONS {
                                      compiler_options = compiler_options',
                                      debugger = debugger,
                                      make_options = 
                                      InterMake.OPTIONS {
                                                         compiler_options = compiler_options',
                                                         name_monitor =
                                                         Option.PRESENT (mk_consumer consumer)
                                                         }}
             in
               action_queue := MAKE(parse_absolute (name,OPTIONS_PRESENT info_opts)) :: !action_queue;
               current_context :=
               empty_action_queue (
                                   action_queue,
                                   0,
                                   !current_context,
                                   outstream,
                                   shell_options',
                                   mk_consumer consumer,
                                   new_pr_options (user_options, print_options)
                                   );
               #subline prompt_args := 0;
               increment_ref := false;
               "\n" ^ prompt()
             end
           handle Info.Stop _ => 
             (#subline prompt_args := 0;
              increment_ref := false;
              "\n" ^ prompt())))
d425 1
a425 237
        (current_context, do_line, do_use, do_make)
      end (* of make_listener_shell *)

    (* make a tty shell *)

    and shell (instream,
	       outstream,
	       (compiler_options as Compiler.MirTypes.OPTIONS{
		  info_opts,
		  ...
		},
                make_options
	       ),
	       context,
	       prompter,
	       print_options (* as
		 InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc *)
	      ) =
      let
	val user_options = make_user_options (print_options, compiler_options);

        val current_context = ref context

        exception Exit of int

	fun debugger_function
	      (options as Incremental.OPTIONS{
		 make_options,
                 compiler_options as Compiler.MirTypes.OPTIONS{
		   info_opts,
		   ...
		 },
		 ...
	       },
	       context,
               current_module
	      )
	      f
	      x =
          let
	    val print_options' = new_pr_options (user_options, print_options)
	    val (info_opts',
		 options' as Incremental.OPTIONS {
		   compiler_options = compiler_options',
		   make_options = make_options',
		   ...
		}) = 
	      new_shell_options (user_options, info_opts, options)
            val call_debugger =
              Ml_Debugger.ml_debugger 
              Ml_Debugger.TERMINAL
              info_opts'
              (print_options', options', context,current_module)
              (fn context' =>
               (shell (
		 instream,
		 outstream,
		 (compiler_options',
		  make_options'
		 ),
                 context',
		 prompter,
		 print_options'
		);
                ()
	      ))
          in
            MLWorks.Internal.Value.frame_call
            (fn base_frame => 
             (MLWorks.Internal.Runtime.Event.signal
              (2,
               fn s => (call_debugger 
                        (Ml_Debugger.BASE_FRAME base_frame)
                        (Ml_Debugger.SIGNAL s,
                         Ml_Debugger.POSSIBLE (
                                               "Return to TopLevel by raising Interrupt",
                                               Ml_Debugger.DO_RAISE Interrupt
                                               ),
                         Ml_Debugger.POSSIBLE (
                                               "Continue interrupted code",
                                               Ml_Debugger.NORMAL_RETURN
                                               ));
                        ()
                        )
               );
              (MLWorks.Internal.Tracing.with_tracing (
	       fn in_value => 
                 call_debugger 
                   Ml_Debugger.NO_BASE_FRAME 
		   (Ml_Debugger.TRACE in_value,
		    Ml_Debugger.NOT_POSSIBLE,
		    Ml_Debugger.NOT_POSSIBLE
	       ))
	     f
	     x
	    )
            handle DebuggerTrapped => raise DebuggerTrapped
            | exn as Exit _ => raise exn
            | exn as Interrupt => raise exn
            | exn as Info.Stop _ => raise exn
            | exn => 
                 (call_debugger 
                    (Ml_Debugger.BASE_FRAME base_frame)
		    (Ml_Debugger.EXCEPTION exn,
                     Ml_Debugger.POSSIBLE 
                     ("Raise Interrupt",
		      Ml_Debugger.DO_RAISE DebuggerTrapped
                      ),
                     Ml_Debugger.NOT_POSSIBLE
                     );
                    raise DebuggerTrapped)))
          end

        val shell_options =
          Incremental.OPTIONS {
	    compiler_options = compiler_options,
            make_options = make_options,
            debugger = debugger_function
	  }

        val (prompt_parameters, token_stream) =
          interactive_input (Incremental.name context, instream,
			     outstream, prompter)

        fun loop () =
          let
            datatype doit = STOP of int | AGAIN of Incremental.options
            fun loop' shell_options =
              if Lexer.eof token_stream then
	      ( (* Lexer.clear_eof token_stream; *)
                STOP 0
	      ) else
                let
                  val context = !current_context
		  fun recycle (info_opts, shell_opts) =
		    let
		      val (_, shell_options') =
		        new_shell_options (
		          user_options,
		          info_opts,
		          shell_opts
		        )
		    in
                      AGAIN shell_options'
		    end
                in
                  ((#subline prompt_parameters) := 0;
                   (#topdec prompt_parameters) := Incremental.topdec context;
                   (#name prompt_parameters) := Incremental.name context;
                   let
                     val (context, identifiers) =
                       (Incremental.add_source shell_options (
			  context,
			  Compiler.TOKENSTREAM1 token_stream
		       ))
                       handle exn => (Lexer.flush_to_nl token_stream;
                                      raise exn)
 
		     val (info_options', shell_options') =
		       new_shell_options (
		         user_options,
		         info_opts,
		         shell_options
		       )
                     val print_options' =
		       new_pr_options (user_options, print_options)
                     val _ = 
                       InterPrint.definitions
		         outstream
		         info_options'
		         (context,
                          print_options',
		          0,
                          identifiers
		         )
		     val _ =
		       current_context := 
                         empty_action_queue (
		           action_queue,
                           0,
                           context,
                           outstream,
                           shell_options',
                           mk_consumer (fn s => output(outstream, s)),
		           print_options'
		         )
		   in
		     recycle (info_options', shell_options')
		   end
		  )
                  handle Exit n => STOP n
                  | Info.Stop _ => recycle (info_opts, shell_options)
                  | DebuggerTrapped => recycle (info_opts, shell_options)
                  | Interrupt => recycle (info_opts, shell_options)
                  | exn =>
                      let
                        val string =
                          MLWorks.Internal.Value.exn_name_string
                            (MLWorks.Internal.Value.exn_name exn)
                      in
                        output(outstream,
			       "Uncaught exception " ^ string ^ "\n");
                        recycle (info_opts, shell_options)
                      end
                end

            fun cycle shell_opts =
              let
                val x = loop' shell_opts
              in
                case x of
                  STOP n => n
                | AGAIN shell_opts' => cycle shell_opts'
              end
          in
            cycle shell_options
          end

	  val exit_fn = MLWorks.Internal.Value.cast (fn n => raise Exit n)

          val context =
	    make_shell_structure(
	      context,
              user_options,
              outstream,
              print_options, 
              shell_options, 
              current_context,
              prompter,
              action_queue,
	      ref token_stream,
	      exit_fn,
              false
	    )
      in
        current_context := context;
        loop ()
a426 17

    fun main arguments =
      shell (
	std_in,
	std_out,
	(TopLevel.default_compiler_options,
	 InterMake.OPTIONS {
	   name_monitor =
	     Option.PRESENT (
	       mk_consumer (fn s => output(std_out, "Make: compiling " ^ s))
	     ),
	   compiler_options = TopLevel.default_compiler_options
	}),
	Incremental.initial,
	default_prompter,
	default_print_desc
      )
@


1.62
log
@Read and updated pervasive_library_dir on startup
@
text
@d11 3
d1279 52
d1408 2
a1409 1
		   ("save", string_to_unit)
d1416 1
@


1.61
log
@Typechecker structure changes
@
text
@d11 3
d1317 3
@


1.60
log
@Changes of sharing relations and new structure representation
@
text
@d11 3
d207 5
a211 6
               sharing Types.Datatypes =
                 InterPrint.Incremental.InterMake.Compiler.Parser.Absyn.Datatypes =
                 Strenv.Datatypes =
                 Tyenv.Datatypes =
                 Valenv.Datatypes =
                 Scheme.Datatypes
d238 1
a238 1
    structure Basis = InterMake.Compiler.Basis
d669 1
a669 1
	    Basis.BASIS (_, Basis.Funenv.FUNENV map, _, _) => map
d680 1
a680 1
	    Basis.BASIS (_, _, _, Datatypes.ENV(Datatypes.SE map, _, _, _)) =>
d692 1
a692 1
	    Basis.BASIS (_, _, _, Datatypes.ENV(_, Datatypes.TE map, _, _)) =>
d704 1
a704 1
	    Basis.BASIS (_, _, _,
d721 1
a721 1
	    Basis.BASIS (_, _, _,
d1292 1
a1292 1
                    fun collect 0 = ()
d1295 1
a1295 1
                         collect(n-1)
d1300 1
a1300 1
                    collect 200
@


1.59
log
@Modfified to allow user control of listing options
@
text
@d11 3
a218 3
               sharing Ml_Debugger.Info =
                 InterPrint.Incremental.InterMake.Compiler.Parser.Lexer.Info
                 
d242 2
d297 2
a298 2
      REMAKE_FILE of Incremental.FileName.absolute |
      MAKE of Incremental.FileName.absolute |
d342 1
a342 1
                                     Incremental.FileName.absolute_name filename,
d349 1
a349 1
                                     Incremental.FileName.absolute_name filename,
d598 3
a600 3
      Incremental.FileName.parse_absolute filename
      handle Incremental.FileName.Parse _ => 
        (Incremental.FileName.parse_absolute(MLWorks.OS.Unix.getwd() ^
d602 1
a602 1
         handle (exn as Incremental.FileName.Parse _) => 
d957 1
d1211 1
d1628 1
a1628 1
                                                         InterMake.Option.PRESENT (mk_consumer consumer)
d1897 1
a1897 1
	     InterMake.Option.PRESENT (
@


1.58
log
@Modified empty_action_queue so errors are only handled once at the
outermost call.
This stops compilation continuing after an error.
@
text
@d11 5
d441 1
d446 1
d461 10
d495 8
a502 6
       show_absyn		= ref false,
       show_match		= ref false,
       show_lambda		= ref false,
       show_opt_lambda	        = ref false,
       show_mir		        = ref false,
       show_opt_mir		= ref false,
d546 8
a553 8
	 show_absyn = false,
	 show_lambda = false,
	 show_match = false,
         show_opt_lambda = false,
         show_environ = false,
         show_mir = false,
         show_opt_mir = false,
         show_mach = false
d923 30
a952 1
	fun mk_structure l =
d956 1
a956 1
                   Strenv.empty_strenv,
d958 2
a959 8
                   Lists.reducel
		   (fn (ve, (name, ty)) =>
                    Valenv.add_to_ve
                    (Ident.VAR(Ident.Symbol.find_symbol name),
                     UNBOUND_SCHEME ty,
                     ve))
		   (empty_valenv, l),
                   empty_valenv
d962 3
a964 1
          
d977 1
a977 1
          
d1013 28
a1081 14
	(*
	val internals_structure = mk_structure
	    [("show_absyn", mk_ref Types.bool_tyname),
	     ("show_match", mk_ref Types.bool_tyname),
	     ("show_lambda", mk_ref Types.bool_tyname),
	     ("show_opt_lambda", mk_ref Types.bool_tyname),
	     ("show_mir", mk_ref Types.bool_tyname),
	     ("show_opt_mir", mk_ref Types.bool_tyname),
	     ("show_debug_info", mk_ref Types.bool_tyname),
	     ("show_timings", mk_ref Types.bool_tyname),
	     ("show_print_timings", mk_ref Types.bool_tyname)
	    ]
        *)

d1251 5
a1255 21
        val options_structure =
             STR (
	       STRNAME (Strname_id.make_strname_id ()),
               ENV (
	         Lists.reducel
		   (fn (se, (name, str)) =>
		      Strenv.add_to_se(
		        Ident.STRID(Ident.Symbol.find_symbol name),
		        str,
		        se
		      )
		   )
		   (Strenv.empty_strenv,
		    [("ValuePrinter", value_printer_structure),
		     ("Compiler", compiler_structure)
		   ]),
                 Tyenv.empty_tyenv,
                 empty_valenv,
                 empty_valenv
	       )
	     )
d1263 2
a1264 1
	       c_compiler = compiler_record
d1331 13
a1343 34
                 STR (
	           STRNAME (Strname_id.make_strname_id ()),
                   ENV (
                        Lists.reducel
                          (fn (se, (name, str)) =>
                             Strenv.add_to_se(
                               Ident.STRID(Ident.Symbol.find_symbol name),
                               str,
                               se
                          ))
                          (Strenv.empty_strenv,
                           [("Make", make_structure),
                            ("Options", options_structure),
                            ("Debug", debug_structure),
                            ("TopEnv", topenv_structure)
                          ]),
                        Tyenv.empty_tyenv,
		        Lists.reducel
		          (fn (ve, (name, ty)) =>
		             Valenv.add_to_ve(
		               Ident.VAR(Ident.Symbol.find_symbol name),
		               UNBOUND_SCHEME ty,
		               ve
		             )
		          )
		          (empty_valenv,
		           [("exit", int_to_unit),
		            ("xinterface",
			       FUNTYPE (string_pair, Types.empty_rec_type)),
			    ("save", string_to_unit)
		          ]),
                        empty_valenv
                        )
                   ),
@


1.57
log
@Modified to deal with new code printing options
@
text
@d11 3
d310 2
a311 38
        val filenames = rev (!action_queue)
      in
        action_queue := [];
        Lists.reducel
        (fn (context, CLEAR_DEBUG_INFO) =>
         Incremental.clear_debug_info context
      |  (context, REMAKE_FILE filename) =>
           Incremental.delete_module options (context, filename)
      | (context, MAKE filename) =>
          (let
            val (context, identifiers) =
              Incremental.add_module options (context, filename)
          in
             InterPrint.definitions
             outstream
             (get_info_opts options)
             (context, print_options, 0, identifiers);
             context
          end
        handle 
        Incremental.Error(context,_) => 
          (output (outstream,
                   implode ["Error making `", 
                            Incremental.FileName.absolute_name filename,
                            "'\n"
                            ]);
          context
          )
        | exn => 
          (output (outstream,
                   implode ["Error making `", 
                            Incremental.FileName.absolute_name filename,
                            "'\n"
                            ]);
          raise exn
            )
          )
      | (context, USE filename) =>
d313 1
a313 39
	    (* USE is more generous than make, compile or recompile.
	       It can read a file without a ".sml" extension!
	       For compatibility with other compilers.
	     *)
            val filename_sml =
              if size filename < 4
                orelse String.substring(filename,size filename - 4,4) <> ".sml"
                then filename ^ ".sml"
              else filename           
            val (stream, filename) =
	      (open_in filename_sml, filename_sml)
	      handle Io _ => (open_in filename, filename)
            val _ = consumer(level,filename)
            val token_stream =
              Lexer.mkFileTokenStream (stream, filename)
              
            fun next context =
              if Lexer.eof token_stream then
                (close_in stream; context)
              else
                let
                  val (context, identifiers) =
                    Incremental.add_source options
                    (context, Compiler.TOKENSTREAM1 token_stream)
                in
                  InterPrint.definitions
                  outstream
                  (get_info_opts options)
                  (context,print_options, 0, identifiers);
                  next (empty_action_queue (
                                            action_queue,
                                            level+1,
                                            context,
                                            outstream,
                                            options,
                                            consumer,
                                            print_options
                                            ))
                end
d315 78
a392 8
            next context
            handle exn => (
                           close_in stream; 
                           output (outstream,
                                   "Error using " ^ filename ^ "\n"
                                   );
                           raise exn
                             )
d394 4
a397 3
        handle exn as Io s => (output (outstream, s ^ "\n");
                               raise exn))
        (context, filenames)
a398 2
    handle exn => context

@


1.56
log
@"use" can now read a file that doesn't have a ".sml" extension.
@
text
@d11 3
d462 2
a463 1
                           opt_self_calls
d528 10
@


1.55
log
@Changed listener window syntax error message.
Added proper line numbering for listener shell
@
text
@d11 4
d332 1
a332 1
      | exn => 
d343 5
a347 1
            val filename =
d352 3
a354 1
            val stream = open_in filename
d386 1
a386 2
                           output (
                                   outstream,
d392 1
a392 2
        handle exn as Io s => (
                               output (outstream, s ^ "\n");
@


1.54
log
@Ensured that user options are passed from the TTY shell to the listener shell
@
text
@d11 3
d1357 2
d1417 5
a1421 2
                 val token_stream = Lexer.mkTokenStream (input_function,
                                                         "Listener Input")
d1499 1
a1499 1
                       | Parser.SyntaxError token =>
d1504 5
a1508 2
                            STOP("Syntax error at " ^ token ^ "\n" ^ prompt())
			   )
@


1.53
log
@Added xinterface_flag to make_shell_structure -- if true, xinterface is running.
Rebound streams when saving image from listener window.
Fix of Clive to interrupt handling in listener.
@
text
@d11 5
d788 3
d797 1
a797 8
                   (Info.OPTIONS {
                                  error = #error info_rec,
                                  information = #information info_rec,
                                  listing = #listing info_rec,
                                  diagnostic = #listing info_rec,
                                  show_id_class = !(#show_id_class user_options),
                                  show_eq_info = !(#show_eq_info user_options)
                                  })
d817 1
a817 8
                            (Info.OPTIONS {
                                           error = #error info_rec,
                                           information = #information info_rec,
                                           listing = #listing info_rec,
                                           diagnostic = #listing info_rec,
                                           show_id_class = !(#show_id_class user_options),
                                           show_eq_info = !(#show_eq_info user_options)
                                           })
d839 1
a839 1
                copy_options shell_options,
@


1.52
log
@We also pass the current module forward for the source_displayer
@
text
@d11 3
d702 2
a703 1
                             exit_fn
d802 1
a802 2
                  (MLWorks.Internal.Runtime.Event.signal(2, fn _ => raise Interrupt);
                   (MLWorks.Internal.Tracing.with_tracing (
d873 13
a885 7
           Podium.start_mlworks
           (Listener.make_listener
            current_context
            command_handler_fn,
            h,
            s
            ))
d1240 17
a1256 11
		      fn () => (
                        output (std_out, Version.version_string ^ "\n");
		        shell (
			  std_in,
			  std_out,
            		  (compiler_options', make_options'),
			  !current_context,
			  prompter,
			  new_pr_options (user_options, print_options)
			)
		    ))
d1382 2
a1383 1
			exit_fn
d1831 2
a1832 1
	      exit_fn
@


1.51
log
@Changed debug info to have only module name - needed to pass module table through to window stuff
@
text
@d11 3
d780 1
a780 1
             fun debugger_function (a,b) f x =
d793 1
a793 1
                   (print_options', a, b)
d821 1
a821 1
                            (print_options', a, b)
d1618 2
a1619 1
	       context
d1636 1
a1636 1
              (print_options', options', context)
@


1.50
log
@Fixed secondary prompts.
Changed some messages
@
text
@d11 4
a792 1
                 MLWorks.Internal.Runtime.Event.signal(2, fn _ => raise Interrupt);
d795 2
a796 1
                  (MLWorks.Internal.Tracing.with_tracing (
d825 1
a825 1
                              )))
a868 2
            (fn filename => 
             Incremental.find_module(!current_context,parse_absolute(filename,OPTIONS_ABSENT)))
d1215 4
a1218 7
                      | collect n = (
			  MLWorks.Internal.Runtime.StorageManager.interface(
			    20,
			    n
			  );
                          collect(n-1)
		        )
d1222 2
a1223 1
                    collect 200;
a1646 16
            MLWorks.Internal.Runtime.Event.signal
            (2,
	     fn s => (call_debugger 
                       Ml_Debugger.NO_BASE_FRAME
                       (Ml_Debugger.SIGNAL s,
                        Ml_Debugger.POSSIBLE (
			  "Return to TopLevel by raising Interrupt",
			  Ml_Debugger.DO_RAISE Interrupt
			),
                        Ml_Debugger.POSSIBLE (
			  "Continue interrupted code",
			  Ml_Debugger.NORMAL_RETURN
		        ));
		      ()
		     )
	    );
d1649 17
a1665 1
               (MLWorks.Internal.Tracing.with_tracing (
d1690 1
a1690 1
                    raise DebuggerTrapped))
@


1.49
log
@Fixed bug in 'make' from 'source' option in listener with no file selected
@
text
@d11 3
d360 1
a360 1
                                   "Error occurred whilst USEing " ^ filename ^ "\n"
d1328 3
a1330 1
        fun prompt increment =
d1333 1
d1338 1
a1338 1
	    if increment then subline := !subline + 1 else ();
d1389 2
a1390 1
               prompt false
d1416 1
a1416 1
			 STOP(prompt true)
d1426 1
a1426 1
                            STOP(prompt true)
d1468 1
d1480 2
a1481 2
                            current_pB :=
			      Incremental.parser_basis(!current_context);
d1483 1
a1483 1
                            STOP("Syntax error at " ^ token ^ "\n" ^ prompt true)
d1500 2
a1501 1
                    ("Error occurred\n" ^ prompt true)
d1505 2
a1506 1
                    prompt true)
d1509 2
a1510 1
                    prompt true)
d1535 2
a1536 1
                   "\n" ^ prompt true
d1573 2
a1574 1
               "\n" ^ prompt true
d1578 2
a1579 2
              "\n" ^ prompt true)))

@


1.48
log
@Tried to give an error message if make called on an invalid filename
@
text
@d11 3
d1532 34
a1565 32
               let
		 val compiler_options' = 
		   new_compiler_options (
		     user_options,
		     info_opts
		   )
                 val shell_options' =
                   Incremental.OPTIONS {
		     compiler_options = compiler_options',
                     debugger = debugger,
                     make_options = 
                       InterMake.OPTIONS {
		         compiler_options = compiler_options',
                         name_monitor =
		           InterMake.Option.PRESENT (mk_consumer consumer)
	           }}
               in
                 action_queue := MAKE(parse_absolute (name,OPTIONS_PRESENT info_opts)) :: !action_queue;
                 current_context :=
	           empty_action_queue (
	             action_queue,
                     0,
                     !current_context,
                     outstream,
                     shell_options',
                     mk_consumer consumer,
                     new_pr_options (user_options, print_options)
	           );
                   #subline prompt_args := 0;
                   "\n" ^ prompt true
               end
	    )
@


1.47
log
@Changes to the debugger for a limited backtrace
@
text
@d11 3
d530 3
a532 1
    fun parse_absolute filename =
d535 1
a535 1
        Incremental.FileName.parse_absolute(MLWorks.OS.Unix.getwd() ^
d537 9
d860 1
a860 1
             Incremental.find_module(!current_context,parse_absolute filename))
d1054 1
a1054 1
	    	       MAKE (parse_absolute filename) :: !action_queue
d1060 2
a1061 2
                       MAKE(parse_absolute filename) ::
			 REMAKE_FILE (parse_absolute filename) ::
d1546 1
a1546 1
                 action_queue := MAKE(parse_absolute name) :: !action_queue;
@


1.46
log
@Stopped recompile errors entring the debugger
Changed the debugger to propagate Interrupt if told to 'q' during ^C action
@
text
@d11 4
d204 4
a207 4
	  compiler_options = Compiler.MirTypes.OPTIONS {info_opts, ...},
	  ...
	} =>
	  info_opts
d213 1
a213 1

d228 1
a228 1

d250 1
a250 1

d257 1
a257 1

d259 2
a260 2
	InterPrint.ValuePrinter.toplevel_default_print_descriptor

d264 8
a271 8
	  action_queue,
	  level,
	  context,
	  outstream,
	  options,
	  consumer,
	  print_options
	) =
d278 2
a279 2
	   Incremental.clear_debug_info context
         |  (context, REMAKE_FILE filename) =>
d281 81
a361 81
         | (context, MAKE filename) =>
             (let
                val (context, identifiers) =
                  Incremental.add_module options (context, filename)
              in
                InterPrint.definitions
	          outstream
	          (get_info_opts options)
	          (context, print_options, 0, identifiers);
                  context
              end
              handle 
                Incremental.Error(context,_) => (
	          output (outstream,
		          implode ["Error making `", 
                                   Incremental.FileName.absolute_name filename,
			           "'\n"
		         ]);
                  context
	        )
              | exn => (
	          output (outstream,
		          implode ["Error making `", 
                                   Incremental.FileName.absolute_name filename,
			           "'\n"
		         ]);
                  raise exn
	        )
	     )
         | (context, USE filename) =>
             let
               val filename =
                 if size filename < 4
                   orelse String.substring(filename,size filename - 4,4) <> ".sml"
                   then filename ^ ".sml"
                 else filename           
               val stream = open_in filename
               val _ = consumer(level,filename)
               val token_stream =
                 Lexer.mkFileTokenStream (stream, filename)
                 
               fun next context =
                 if Lexer.eof token_stream then
                   (close_in stream; context)
                 else
                   let
                     val (context, identifiers) =
                       Incremental.add_source options
                       (context, Compiler.TOKENSTREAM1 token_stream)
                   in
                     InterPrint.definitions
		       outstream
		       (get_info_opts options)
		       (context,print_options, 0, identifiers);
                     next (empty_action_queue (
			     action_queue,
			     level+1,
                             context,
			     outstream,
			     options,
			     consumer,
			     print_options
		          ))
                   end
             in
               next context
               handle exn => (
	         close_in stream; 
                 output (
	           outstream,
		   "Error occurred whilst USEing " ^ filename ^ "\n"
	         );
                 raise exn
	       )
             end
               handle exn as Io s => (
                 output (outstream, s ^ "\n");
	         raise exn))
         (context, filenames)
       end
       handle exn => context
d365 1
a365 1

a372 1

d374 1
d377 1
a377 1

d379 1
a379 1

d381 1
a381 1

d383 26
a408 26
      show_fn_details:	        bool ref,
      show_exn_details:	        bool ref,
      maximum_list_size:        int ref,
      maximum_depth:	        int ref,
      maximum_shape_depth:      int ref,
      maximum_ref_depth:        int ref,
      generate_tracing_code:    bool ref,
      generate_profiling_code:  bool ref,
      generate_debug_info:      bool ref,
      show_debug_warnings:      bool ref,
      optimise_leaf_fns:        bool ref,
      optimise_tail_calls:      bool ref,
      optimise_self_tail_calls: bool ref,
      show_id_class:	        bool ref,
      show_eq_info:	        bool ref,
      show_absyn:	        bool ref,
      show_match:	        bool ref,
      show_lambda:	        bool ref,
      show_opt_lambda:	        bool ref,
      show_mir:	  	        bool ref,
      show_opt_mir:	        bool ref,
      show_debug_info:	        bool ref,
      show_timings:	        bool ref,
      show_print_timings:       bool ref
    }

d411 15
a425 15
          InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc,
          Compiler.MirTypes.OPTIONS{
    	    info_opts = Info.OPTIONS {
    	      show_id_class,
    	      show_eq_info,
    	      ...
    	    },
    	    trace,
    	    profile,
    	    debug,
    	    debug_warnings,
    	    opt_leaf_fns,
    	    opt_tail_calls,
    	    opt_self_calls
        }) =
d450 2
a451 2
      }

d453 20
a472 20
	  user_options: user_options,
	  InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc
	) = 
      InterPrint.ValuePrinter.PRINTER_DESCRIPTOR {
	print_fn_details =
          !(#show_fn_details user_options),
        print_exn_details =
          !(#show_exn_details user_options),
	maximum_list_size =
	  !(#maximum_list_size user_options),
	maximum_ref_depth =
	  !(#maximum_ref_depth user_options),
	maximum_shape_depth =
	  !(#maximum_shape_depth user_options),
	maximum_depth =
	  !(#maximum_depth user_options),
	print_method_table =
	  #print_method_table print_desc
      }

d474 3
a476 3
          user_options: user_options,
          Info.OPTIONS info_rec
        ) =
d478 8
a485 8
        error = #error info_rec,
        information = #information info_rec,
        listing = #listing info_rec,
        diagnostic = #diagnostic info_rec,
        show_eq_info = !(#show_eq_info user_options),
        show_id_class = !(#show_id_class user_options)
      }

d487 11
a497 11
      Compiler.MirTypes.OPTIONS {
        info_opts = new_info_options (user_options, info_options),
        debug = !(#generate_debug_info user_options),
        profile = !(#generate_profiling_code user_options),
        trace = !(#generate_tracing_code user_options),
        debug_warnings = !(#show_debug_warnings user_options),
        opt_leaf_fns = !(#optimise_leaf_fns user_options),
        opt_tail_calls = !(#optimise_tail_calls user_options),
        opt_self_calls = !(#optimise_self_tail_calls user_options)
      }

d499 10
a508 10
	  user_options: user_options,
	  info_options,
	  Incremental.OPTIONS {
	    debugger,
	    make_options = InterMake.OPTIONS {
	      name_monitor,
	      ...
	    },
	    ...
	}) =
d516 7
a522 7
            compiler_options = compiler_options',
            make_options = InterMake.OPTIONS {
	      name_monitor = name_monitor,
	      compiler_options = compiler_options'
	    },
            debugger = debugger
          }
d526 1
a526 1

d531 2
a532 2
	  "/" ^ filename)

d536 1
a536 1

d578 1
a578 1

d581 3
a583 3
	IdentPrint.printSigId
	(Datatypes.NewMap.domain (Incremental.signatures context))

d591 2
a592 2
	  IdentPrint.printFunId
	  (Datatypes.NewMap.domain funmap)
d594 1
a594 1

d603 2
a604 2
	  IdentPrint.printStrId
	  (Datatypes.NewMap.domain strmap)
d606 1
a606 1

d615 2
a616 2
	  IdentPrint.printTyCon
	  (Datatypes.NewMap.domain tymap)
d618 1
a618 1

d625 2
a626 2
	      map

d628 2
a629 2
	|   getsym (Ident.CON s) = s
	|   getsym (Ident.EXCON s) = s
d632 2
a633 2
	  (Symbol.symbol_name o getsym)
	  (Lists.filterp p (Datatypes.NewMap.domain valmap))
d635 1
a635 1

d642 1
a642 1
	      map
d645 5
a649 5
	  (Symbol.symbol_name o
	    (fn (Ident.EXCON s) => s
	     | _ => Crash.impossible "non-exception in exception environment"
	  ))
	  (Datatypes.NewMap.domain exnmap)
d651 1
a651 1

d653 2
a654 2
       a shell is made *)

d656 18
a673 18
      context,
      user_options: user_options,
      outstream,
      print_options,
      shell_options as Incremental.OPTIONS{
	make_options,
        compiler_options as Compiler.MirTypes.OPTIONS{
	  info_opts = info_opts as Info.OPTIONS info_rec,
	  ...
	},
        ...
      },
      current_context,
      prompter,
      action_queue,
      ts_ref,
      exit_fn
    ) =
d676 1
a676 1

d678 1
a678 1

d680 1
a680 1

d682 9
a690 9
          Types.add_to_rectype(
	    Ident.LAB (Symbol.find_symbol "1"),
            a,
            Types.add_to_rectype(
	      Ident.LAB (Symbol.find_symbol "2"),
              b,
              Types.empty_rec_type
	  ))

d693 4
a696 4
	    CONSTYPE([],Types.string_tyname),
	    CONSTYPE([],Types.string_tyname)
	  )

d699 7
a705 7
	    make_pair(
	      CONSTYPE([],Types.string_tyname),
              FUNTYPE(Types.string_type, Types.empty_rec_type)
	    ),
            Types.string_type
	  )

d713 2
a714 2
					 )
			    )
d719 2
a720 2
			    		 )
			    )
d724 3
a726 3
				  FUNTYPE(aty,bty),
                                  CONSTYPE([],Types.bool_tyname)
			       ))
d728 1
a728 1

d731 4
a734 4
            Types.empty_rec_type,
            CONSTYPE([CONSTYPE([],Types.string_tyname)], Types.list_tyname)
	  )

d737 1
a737 1

d740 1
a740 1

d743 1
a743 1

d746 1
a746 1

d750 73
a822 45
             let
               val print_options' = new_pr_options (user_options, print_options)

               fun debugger_function (a,b) f x =
                 (f x
		  handle exn as Listener.Listener_Exit => raise exn
		  | exn => 
                   (Ml_Debugger.ml_debugger 
                     (Ml_Debugger.WINDOWING window_fn)
		      (Info.OPTIONS {
		         error = #error info_rec,
		         information = #information info_rec,
		         listing = #listing info_rec,
		         diagnostic = #listing info_rec,
		         show_id_class = !(#show_id_class user_options),
		         show_eq_info = !(#show_eq_info user_options)
		      })
                      (print_options', a, b)
                      (fn _ => output(std_out,"Shell not defined yet|\n"))
                      (Ml_Debugger.EXCEPTION exn,
		       Ml_Debugger.NOT_POSSIBLE,
		       Ml_Debugger.NOT_POSSIBLE);
                    raise DebuggerTrapped
		 ))
                   
               fun copy_options (Incremental.OPTIONS x) =
                 Incremental.OPTIONS{
	           compiler_options = #compiler_options x,
                   make_options = #make_options x,
                   debugger = debugger_function
		 }

               val interface =
                 make_listener_shell(
		   !current_context,
		   prompter,
		   copy_options shell_options,
		   print_options',
		   shell_window
		 )
	     in
	       interface
             end
	  )

d824 1
a824 1

d828 8
a835 10
              Incremental.add_value shell_options(
	        context,
		"use",
                UNBOUND_SCHEME (
		  FUNTYPE (Types.string_type, Types.empty_rec_type)
		),
                MLWorks.Internal.Value.cast(
		  fn filename => action_queue := USE(filename) :: !action_queue
	        )
	      )
d839 1
a839 1

d841 12
a852 12
             MLWorks.Internal.Value.cast (
	       fn (h,s) =>
		  Podium.start_mlworks(
		    Listener.make_listener
                      (fn filename => 
                        Incremental.find_module(!current_context,parse_absolute filename))
                      current_context
		      command_handler_fn,
		    h,
		    s
	       ))

d854 1
a854 1
             STR (
d857 3
a859 3
		 Strenv.empty_strenv,
		 Tyenv.empty_tyenv,
		 Lists.reducel
d861 4
a864 6
		      Valenv.add_to_ve(
		        Ident.VAR(Ident.Symbol.find_symbol name),
		        UNBOUND_SCHEME ty,
		        ve
		      )
		   )
d866 4
a869 4
		 empty_valenv
	       )
	     )

d871 1
a871 1

d873 10
a882 10
	    [("show_fn_details",  mk_ref Types.bool_tyname),
             ("show_exn_details",  mk_ref Types.bool_tyname),
	     ("show_id_class",  mk_ref Types.bool_tyname),
	     ("show_eq_info",  mk_ref Types.bool_tyname),
	     ("maximum_list_size",  mk_ref Types.int_tyname),
	     ("maximum_ref_depth",  mk_ref Types.int_tyname),
	     ("maximum_shape_depth",  mk_ref Types.int_tyname),
	     ("maximum_depth",  mk_ref Types.int_tyname)
	    ]
	 
d884 34
a917 35
	     MLWorks.Internal.Value.cast {
	       maximum_depth =
	         MLWorks.Internal.Value.cast(
	           #maximum_depth user_options
	         ),
	       maximum_shape_depth =
	         MLWorks.Internal.Value.cast(
	           #maximum_shape_depth user_options
	         ),
	       maximum_ref_depth =
	         MLWorks.Internal.Value.cast(
	           #maximum_ref_depth user_options
	         ),
	       maximum_list_size =
	         MLWorks.Internal.Value.cast(
	           #maximum_list_size user_options
	         ),
	       show_fn_details =
	         MLWorks.Internal.Value.cast(
	           #show_fn_details user_options
	         ),
	       show_exn_details =
	         MLWorks.Internal.Value.cast(
	           #show_exn_details user_options
	         ),
	       show_id_class =
	         MLWorks.Internal.Value.cast(
	           #show_id_class user_options
	         ),
	       show_eq_info =
	         MLWorks.Internal.Value.cast(
	           #show_eq_info user_options
	         )
	    }

d919 2
a920 2
	    [("generate_tracing_code", mk_ref Types.bool_tyname),
	     ("generate_profiling_code", mk_ref Types.bool_tyname),
d926 2
a927 2
	    ]

d929 23
a951 4
	     MLWorks.Internal.Value.cast {
	       generate_tracing_code =
	         MLWorks.Internal.Value.cast(
	           #generate_tracing_code user_options
d953 6
a958 26
	       generate_profiling_code =
	         MLWorks.Internal.Value.cast(
	           #generate_profiling_code user_options
	         ),
	       generate_debug_info =
	         MLWorks.Internal.Value.cast(
	           #generate_debug_info user_options
	         ),
	       show_debug_warnings =
	         MLWorks.Internal.Value.cast(
	           #show_debug_warnings user_options
	         ),
	       optimise_leaf_fns =
	         MLWorks.Internal.Value.cast(
	           #optimise_leaf_fns user_options
	         ),
	       optimise_tail_calls =
	         MLWorks.Internal.Value.cast(
	           #optimise_tail_calls user_options
	         ),
	       optimise_self_tail_calls =
	         MLWorks.Internal.Value.cast(
	           #optimise_self_tail_calls user_options
	         )
	    }

a972 1

d974 10
a983 10
	    [("signatures", show_type),
	     ("functors", show_type),
	     ("structures", show_type),
	     ("types", show_type),
	     ("exceptions", show_type),
	     ("constructors", show_type),
	     ("variables", show_type),
	     ("values", show_type)
	    ]

d1345 2
a1346 1
                                                         
d1401 1
d1469 1
a1469 1
                     cycle shell_options
d1617 3
a1619 2
	     fn s => (call_debugger (
			Ml_Debugger.SIGNAL s,
d1621 1
a1621 1
			  "Return to TopLevel",
d1631 3
a1633 1
            (MLWorks.Internal.Tracing.with_tracing (
d1635 5
a1639 4
                 call_debugger (
		   Ml_Debugger.TRACE in_value,
		   Ml_Debugger.NOT_POSSIBLE,
		   Ml_Debugger.NOT_POSSIBLE
d1649 5
a1653 4
                 (call_debugger (
		    Ml_Debugger.EXCEPTION exn,
                    Ml_Debugger.POSSIBLE (
		      "Return to TopLevel",
d1655 4
a1658 4
		    ),
                    Ml_Debugger.NOT_POSSIBLE
		  );
                  raise DebuggerTrapped)
d1741 1
@


1.45
log
@Message from use if the file is not found
@
text
@d11 3
d1452 4
a1455 2
                    ("Debugger entered\n" ^ prompt true)
                   )
d1594 1
a1594 1
			  Ml_Debugger.DO_RAISE DebuggerTrapped
d1615 2
@


1.44
log
@Added passing of the module_table to the source_viewer
@
text
@d11 3
d340 1
a340 1
               handle exn as Io s => (
a341 5
                 output (outstream, s);
	         raise exn
	       )
	       | exn => (
	         close_in stream; 
d348 4
a351 1
             end)
@


1.43
log
@Various bug fixes.
Made action queue global -- experimental
@
text
@d11 4
d811 3
a813 1
		      current_context
@


1.42
log
@Removed a number of duplicated signatures and structures
@
text
@d11 3
d154 1
a154 3
	       sharing type Listener.Widget = Dialogs.Widget

               sharing Podium.Widgets.ClmTypes = Listener.ClmTypes
d161 2
a162 2
		 InterPrint.Incremental.Inter_EnvTypes.Info

d363 5
d1273 1
a1273 1
        fun prompt () =
d1280 1
a1280 1
	    subline := !subline + 1;
a1285 2
        val action_queue = ref ([]  : QueueEntry list)

d1330 1
a1330 1
               prompt()
d1356 1
a1356 1
			 STOP(prompt())
d1365 1
a1365 1
                            STOP(prompt())
d1421 1
a1421 1
                            STOP("Syntax error at " ^ token ^ "\n" ^ prompt())
d1438 1
a1438 1
                    ("Error occurred\n" ^ prompt())
d1442 1
a1442 1
                    ("Debugger entered\n" ^ prompt())
d1467 2
a1468 1
                 "\n" ^ prompt()
d1504 2
a1505 1
                 "\n" ^ prompt()
a1530 2
        val action_queue = ref ([]  : QueueEntry list)
          
@


1.41
log
@Fixed clear_debug_info - we can't set the current_context with a
user-visible function, because it gets reset later.  So we have to use
the action queue.
@
text
@d11 5
d143 1
a143 1
                 InterPrint.Incremental.Datatypes =
d179 2
a180 1
    structure Datatypes = Incremental.Datatypes
a182 1
    structure Basis = Incremental.InterMake.Compiler.Basis
d184 1
a184 1
    structure Debugger_Types = Incremental.InterMake.Compiler.Debugger_Types
@


1.40
log
@Made changed options apply immediately after evaluation.
Changed the user-visible field optimise_self_calls to
optimise_self_tail_calls.
@
text
@d11 5
d235 2
a236 1
      USE of string
d257 32
a288 21
        (fn (context, REMAKE_FILE filename) =>
         Incremental.delete_module options (context, filename)
      | (context, MAKE filename) =>
          (let
             val (context, identifiers) =
               Incremental.add_module options (context, filename)
           in
             InterPrint.definitions
	       outstream
	       (get_info_opts options)
	       (context, print_options, 0, identifiers);
               context
           end
           handle 
             Incremental.Error(context,_) => (
	       output (outstream,
		       implode ["Error making `", 
                                Incremental.FileName.absolute_name filename,
			        "'\n"
		      ]);
               context
d290 54
a343 63
           | exn => (
	       output (outstream,
		       implode ["Error making `", 
                                Incremental.FileName.absolute_name filename,
			        "'\n"
		      ]);
               raise exn
	     )
	  )
      | (context, USE filename) =>
          let
            val filename =
              if size filename < 4
                orelse String.substring(filename,size filename - 4,4) <> ".sml"
                then filename ^ ".sml"
              else filename           
            val stream = open_in filename
            val _ = consumer(level,filename)
            val token_stream =
              Lexer.mkFileTokenStream (stream, filename)
              
            fun next context =
              if Lexer.eof token_stream then
                (close_in stream; context)
              else
                let
                  val (context, identifiers) =
                    Incremental.add_source options
                    (context, Compiler.TOKENSTREAM1 token_stream)
                in
                  InterPrint.definitions
		    outstream
		    (get_info_opts options)
		    (context,print_options, 0, identifiers);
                  next (empty_action_queue (
			  action_queue,
			  level+1,
                          context,
			  outstream,
			  options,
			  consumer,
			  print_options
		       ))
                end
          in
            next context
            handle exn as Io s => (
	      close_in stream; 
              output (outstream, s);
	      raise exn
	    )
	    | exn => (
	      close_in stream; 
              output (
	        outstream,
		"Error occurred whilst USEing " ^ filename ^ "\n"
	      );
              raise exn
	    )
          end)
        (context, filenames)
      end
    handle exn => context
d1085 3
a1087 2
                   (fn () => current_context :=
			       Incremental.clear_debug_info(!current_context)),
@


1.39
log
@Ensured that options are pased to compile, recompile and make.
@
text
@d11 3
d352 24
a375 24
      show_fn_details:	       bool ref,
      show_exn_details:	       bool ref,
      maximum_list_size:       int ref,
      maximum_depth:	       int ref,
      maximum_shape_depth:     int ref,
      maximum_ref_depth:       int ref,
      generate_tracing_code:   bool ref,
      generate_profiling_code: bool ref,
      generate_debug_info:     bool ref,
      show_debug_warnings:     bool ref,
      optimise_leaf_fns:       bool ref,
      optimise_tail_calls:     bool ref,
      optimise_self_calls:     bool ref,
      show_id_class:	       bool ref,
      show_eq_info:	       bool ref,
      show_absyn:	       bool ref,
      show_match:	       bool ref,
      show_lambda:	       bool ref,
      show_opt_lambda:	       bool ref,
      show_mir:	  	       bool ref,
      show_opt_mir:	       bool ref,
      show_debug_info:	       bool ref,
      show_timings:	       bool ref,
      show_print_timings:      bool ref
d378 43
d464 1
a464 1
        opt_self_calls = !(#optimise_self_calls user_options)
d869 1
a869 1
	     ("optimise_self_calls", mk_ref Types.bool_tyname)
d898 1
a898 1
	       optimise_self_calls =
d900 1
a900 1
	           #optimise_self_calls user_options
d1239 2
a1240 8
		info_opts as Info.OPTIONS info_rec,
		trace,
		profile,
		debug,
		debug_warnings,
		opt_leaf_fns,
		opt_tail_calls,
		opt_self_calls
d1244 1
a1244 2
          print_options as
	      InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc,
d1264 1
a1264 27
	(* These references can be set by the user.  *)
	val user_options = {
	  maximum_list_size       = ref (#maximum_list_size print_desc),
	  maximum_ref_depth       = ref (#maximum_ref_depth print_desc),
	  maximum_shape_depth     = ref (#maximum_shape_depth print_desc),
	  maximum_depth           = ref (#maximum_depth print_desc),
	  show_fn_details         = ref (#print_fn_details print_desc),
	  show_exn_details        = ref (#print_exn_details print_desc),
          generate_tracing_code   = ref trace,
          generate_profiling_code = ref profile,
          generate_debug_info     = ref debug,
          show_debug_warnings     = ref debug_warnings,
          optimise_leaf_fns       = ref opt_leaf_fns,
          optimise_tail_calls     = ref opt_tail_calls,
          optimise_self_calls     = ref opt_self_calls,
	  show_id_class	          = ref (#show_id_class info_rec),
	  show_eq_info 	          = ref (#show_eq_info info_rec),
          show_absyn		  = ref false,
          show_match		  = ref false,
          show_lambda		  = ref false,
          show_opt_lambda	  = ref false,
          show_mir		  = ref false,
          show_opt_mir		  = ref false,
          show_debug_info	  = ref false,
          show_timings		  = ref false,
          show_print_timings	  = ref false
	}
d1353 5
a1363 5
                           val (new_context, identifiers) =
                             Incremental.add_source shell_options' (
			       context, 
                               Compiler.TOPDEC ("listener input",topdec)
			     )
d1381 6
d1396 1
a1396 1
                           AGAIN shell_options'
d1499 1
a1499 7
		  trace,
		  profile,
		  debug,
		  debug_warnings,
		  opt_leaf_fns,
		  opt_tail_calls,
		  opt_self_calls
d1505 2
a1506 2
	       print_options as
		 InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc
d1509 1
a1509 28

	(* These references can be set by the user.  *)
	val user_options = {
	  maximum_list_size       = ref (#maximum_list_size print_desc),
	  maximum_ref_depth       = ref (#maximum_ref_depth print_desc),
	  maximum_shape_depth     = ref (#maximum_shape_depth print_desc),
	  maximum_depth           = ref (#maximum_depth print_desc),
	  show_fn_details         = ref (#print_fn_details print_desc),
	  show_exn_details        = ref (#print_exn_details print_desc),
          generate_tracing_code   = ref trace,
          generate_profiling_code = ref profile,
          generate_debug_info     = ref debug,
          show_debug_warnings     = ref debug_warnings,
          optimise_leaf_fns       = ref opt_leaf_fns,
          optimise_tail_calls     = ref opt_tail_calls,
          optimise_self_calls     = ref opt_self_calls,
	  show_id_class	          = ref false,
	  show_eq_info 	          = ref false,
          show_absyn		  = ref false,
          show_match		  = ref false,
          show_lambda		  = ref false,
          show_opt_lambda	  = ref false,
          show_mir		  = ref false,
          show_opt_mir		  = ref false,
          show_debug_info	  = ref false,
          show_timings		  = ref false,
          show_print_timings	  = ref false
	}
d1618 11
a1628 6
		  val (info_options', shell_options') =
		    new_shell_options (
		      user_options,
		      info_opts,
		      shell_options
		    )
a1632 1
                   current_context :=
d1635 1
a1635 1
                       (Incremental.add_source shell_options' (
d1642 6
d1650 23
a1672 20
                   in
                     InterPrint.definitions
		       outstream
		       info_options'
		       (context,
                        print_options',
		        0,
                        identifiers
		       );
                     empty_action_queue (
		       action_queue,
                       0,
                       context,
                       outstream,
                       shell_options',
                       mk_consumer (fn s => output(outstream, s)),
		       print_options'
		     )
                   end;
                   AGAIN shell_options'
d1675 2
a1676 2
                  | Info.Stop _ => AGAIN shell_options'
                  | DebuggerTrapped => AGAIN shell_options'
d1685 1
a1685 1
                        AGAIN shell_options'
@


1.38
log
@Added a correct handler around make to preserve context on partial make
@
text
@d11 3
d252 3
a254 3
            val (context, identifiers) =
              Incremental.add_module options (context, filename)
          in
d256 23
a278 14
	     outstream
	     (get_info_opts options)
	     (context, print_options, 0, identifiers);
             context
          end
        handle 
        Incremental.Error(context,_) =>
          (output (outstream,implode ["Error making `", 
                                      Incremental.FileName.absolute_name filename, "'\n"]);
           context)
      | exn =>
          (output (outstream,implode ["Error making `", 
                                      Incremental.FileName.absolute_name filename, "'\n"]);
           raise exn))
d396 25
d423 9
a431 3
	  Info.OPTIONS info_rec,
	  Incremental.OPTIONS shell_rec
        ) =
d434 1
a434 8
          Info.OPTIONS {
            error = #error info_rec,
            information = #information info_rec,
            listing = #listing info_rec,
            diagnostic = #diagnostic info_rec,
            show_eq_info = !(#show_eq_info user_options),
            show_id_class = !(#show_id_class user_options)
          }
d436 1
a436 14
          Compiler.MirTypes.OPTIONS {
            info_opts = info_options',
            debug = !(#generate_debug_info user_options),
            profile =
              !(#generate_profiling_code user_options),
            trace =
              !(#generate_tracing_code user_options),
            debug_warnings = !(#show_debug_warnings user_options),
            opt_leaf_fns = !(#optimise_leaf_fns user_options),
            opt_tail_calls =
              !(#optimise_tail_calls user_options),
            opt_self_calls =
              !(#optimise_self_calls user_options)
          }
d440 5
a444 2
            make_options = #make_options shell_rec,
            debugger = #debugger shell_rec
d940 1
a940 1
	    	   MAKE (parse_absolute filename) :: !action_queue
d953 18
a970 4
		     TopLevel.compile_file
		       Info.default_options
		       TopLevel.default_compiler_options
		       filename
d975 18
a992 4
		     Recompile.recompile
		       Info.default_options
		       TopLevel.default_compiler_options
		       filename
d1202 1
a1202 1
              ...
d1265 12
a1276 12
	  val context = make_shell_structure (
			  context,
                          user_options,
                          std_out,
                          print_options,
                          shell_options,
                          current_context,
                          prompter,
                          action_queue,
			  ts_ref,
			  exit_fn
			)
d1414 19
a1432 15
          outstream
          (fn () =>
          (action_queue := USE(name) :: !action_queue ;
           current_context :=
	     empty_action_queue (
	       action_queue,
               0,
               !current_context,
               outstream,
               shell_options,
               mk_consumer consumer,
               new_pr_options (user_options, print_options)
	     );
           "\n" ^ prompt()
	   ))
d1436 33
a1468 30
          outstream
          (fn () => 
          let
            val Incremental.OPTIONS old_options = shell_options
            val InterMake.OPTIONS old_intermake_option =
	      #make_options old_options
            val shell_options' =
              Incremental.OPTIONS
              {compiler_options = #compiler_options old_options,
               debugger = #debugger old_options,
               make_options = 
                 InterMake.OPTIONS {
		   compiler_options = #compiler_options old_intermake_option,
                   name_monitor =
		     InterMake.Option.PRESENT (mk_consumer consumer)
	      }}
          in
            action_queue := MAKE(parse_absolute name) :: !action_queue ;
            current_context :=
	      empty_action_queue (
	        action_queue,
                0,
                !current_context,
                outstream,
                shell_options',
                mk_consumer consumer,
                new_pr_options (user_options, print_options)
	      );
            "\n" ^ prompt()
          end)
@


1.37
log
@Fixed exit from listener.
Fixed calculation of subline in listener prompt.
@
text
@d11 4
d247 6
a252 9
        | (context, MAKE filename) =>
         let
           val (context, identifiers) =
             Incremental.add_module options (context, filename)
             handle exn =>
               (output (outstream,implode ["Error making `", Incremental.FileName.absolute_name filename, "'\n"]);
                raise exn)
         in
           InterPrint.definitions
d256 11
a266 2
           context
         end
d1669 1
a1669 1
	       mk_consumer (fn s => output(std_out, "Making" ^ s))
@


1.36
log
@Moved xinterface and save into Shell structure.
Attempted to fix exit from listener shells.
Propagated options into shells.
Removed the shell function (it was causing a lot of trouble).
Added remake function (clive).
Improved error reporting.
Removed a sharing constraint.
Minor tidying up.
@
text
@d11 10
a635 2
	  let exception Exit of int
	  in
d642 1
a642 1
		  handle exn as Exit _ => raise exn
a680 1
	  end
d1153 6
a1158 3
          in
            prompter {line = ~1, subline = !subline,
		      name = !name, topdec = !topdec}
d1198 1
a1198 1
		   ()
a1325 1
                         (#subline prompt_args) := 1 + !(#subline prompt_args);
a1338 3
		 (*
                 | Exit n => prompt()
		 *)
a1406 1
	       (* init_shell_options as Incremental.OPTIONS *)
d1418 1
a1418 4
	       )
	       (*
		debugger
	       } *),
d1663 3
a1665 1
	Incremental.initial
@


1.35
log
@Deleted several pieces of commented-out code.
@
text
@d11 3
d90 1
d108 1
d121 2
a129 3
		 InterPrint.Incremental.InterMake.Compiler.Parser.Lexer.Info =
		 InterPrint.Incremental.InterMake.Compiler.Debugger_Types.Info =
		 InterPrint.Incremental.InterMake.Compiler.MirTypes.Info =
d207 4
a210 1
    datatype QueueEntry = MAKE of Incremental.FileName.absolute | USE of string
d231 3
a233 1
        (fn (context, MAKE filename) =>
d284 6
a289 1
            handle exn => (
d295 2
a296 1
              raise exn)
d537 8
a544 7
      options as Incremental.OPTIONS{make_options,
                                     compiler_options as
				       Compiler.MirTypes.OPTIONS{
					 info_opts =
					   info_opts as Info.OPTIONS info_rec,
					 ...},
				     ...},
d548 1
d625 3
a627 1
        fun command_handler_fn current_context =
d633 3
a635 1
                 (f(x) handle exn => 
d665 3
a667 2
		   copy_options options,
		   print_options'
d669 2
a670 2
             in
               interface
d673 1
d680 1
a680 1
              Incremental.add_value options(
d694 10
a703 20
        val context =
          let
            val (context, identifiers) =
              Incremental.add_value options (
		context,
                "start_mlworks",
                UNBOUND_SCHEME (FUNTYPE (string_pair, Types.empty_rec_type)),
                MLWorks.Internal.Value.cast(
		  (fn (h,s) =>
		     Podium.start_mlworks(
		       Listener.make_listener
			 current_context
			 command_handler_fn,
		       h,
		       s
		  )): string * string -> unit
	      ))
          in
            context
          end
d783 31
d815 1
d827 1
d900 6
a905 2
	         MLWorks.Internal.Value.cast(
		   not_implemented
d983 2
a984 1
		    [("ValuePrinter", value_printer_structure)
d997 2
a998 1
	       c_value_printer = value_printer_record
d1001 53
d1058 1
a1058 1
	        options
d1087 4
a1090 1
		           [("exit", int_to_unit)
d1100 2
d1123 7
a1129 1
		...
d1134 2
a1135 1
	      InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc
d1159 7
a1165 7
          generate_tracing_code   = ref false,
          generate_profiling_code = ref false,
          generate_debug_info     = ref false,
          show_debug_warnings     = ref false,
          optimise_leaf_fns       = ref true,
          optimise_tail_calls     = ref true,
          optimise_self_calls     = ref true,
a1178 2
        exception Exit of int

d1183 1
a1183 3
        val _ = current_context :=
	  let
	    open Datatypes
d1185 5
a1189 2
	    (* We can't define save or shell here because we
	       don't have an instream. *)
d1191 12
a1202 25
	    val exit_fn = MLWorks.Internal.Value.cast (fn n => raise Exit n)

	    (*
            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value shell_options(
		    context,
		    "exit",
                    UNBOUND_SCHEME (FUNTYPE (Types.int_type,
					     Types.empty_rec_type)),
                    MLWorks.Internal.Value.cast (fn n => raise Exit n)
		  )
              in
                InterPrint.definitions
		  outstream
		  info_opts
		  (context,
                   print_options,
		   0,
		   identifiers
		  );
                context
              end
	    *)
d1204 1
a1204 14
	    val context = make_shell_structure (
			    context,
                            user_options,
                            std_out,
                            print_options,
                            shell_options,
                            current_context,
                            prompter,
                            action_queue,
			    exit_fn
			  )
	  in
	    context
	  end
d1236 2
d1330 3
a1336 1
                 | Exit n => (prompt())
d1401 14
a1414 2
	       {compiler_options as Compiler.MirTypes.OPTIONS{info_opts, ...},
                make_options,
d1416 1
a1416 1
	       },
d1432 7
a1438 7
          generate_tracing_code   = ref false,
          generate_profiling_code = ref false,
          generate_debug_info     = ref false,
          show_debug_warnings     = ref false,
          optimise_leaf_fns       = ref true,
          optimise_tail_calls     = ref true,
          optimise_self_calls     = ref true,
d1458 80
d1542 1
a1542 3
            debugger = debugger
			 (fn Exit _ => false | _ => true)
			 print_options
d1554 1
a1554 1
	      ( Lexer.clear_eof token_stream;
d1629 15
d1645 1
a1645 145

        current_context :=
          let
            open Datatypes

            val context = !current_context

            fun change_eq_id (
	          Incremental.OPTIONS{
		    compiler_options as Compiler.MirTypes.OPTIONS {
		      info_opts as Info.OPTIONS {
			error, information, listing, diagnostic,
			show_eq_info, show_id_class
		      },
		      debug, profile, trace, debug_warnings, opt_leaf_fns,
		      opt_tail_calls, opt_self_calls
		    },
                    make_options,
                    debugger
		}) =
	          {compiler_options = Compiler.MirTypes.OPTIONS {
		     info_opts = Info.OPTIONS {
			error = error,
                        information = information,
                        listing = listing,
                        diagnostic = diagnostic,
		        show_id_class = !(#show_id_class user_options),
		        show_eq_info = !(#show_eq_info user_options)
		     },
		     debug = debug,
		     profile = profile,
		     trace = trace,
		     debug_warnings = debug_warnings,
		     opt_leaf_fns = opt_leaf_fns,
		     opt_tail_calls = opt_tail_calls,
		     opt_self_calls = opt_self_calls
		   },
                   make_options = make_options,
		   (* Does this do what we want? *)
                   debugger = fn f => fn pr_opts => debugger
		  }

            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value shell_options (
		    context,
		    "save",
                    UNBOUND_SCHEME (
		      FUNTYPE (Types.string_type, Types.empty_rec_type)
		    ),
                    MLWorks.Internal.Value.cast (
		      fn filename => (
			let
                          val old_level =
			    !MLWorks.Internal.Runtime.StorageManager.gc_message_level
                          fun collect 0 = ()
                            | collect n = (
				MLWorks.Internal.Runtime.StorageManager.interface(20,n);
                                collect(n-1)
			      )
                        in
                          MLWorks.Internal.Runtime.StorageManager.gc_message_level := ~1;
                          collect 200;
                          MLWorks.Internal.Runtime.StorageManager.gc_message_level := old_level
                        end;
                        MLWorks.save (
			  filename,
			  fn () => (
                            output (outstream, Version.version_string ^ "\n");
			    shell (
			      instream,
			      outstream,
            		      change_eq_id shell_options,
			      !current_context,
			      prompter,
			      new_pr_options (user_options, print_options)
			    )
			))
                        handle MLWorks.Save message =>
                          Info.error'
			    info_opts
			    (Info.FATAL, Lexer.locate token_stream, message)
		  )))
              in
                context
              end

            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value shell_options (
		    context,
		    "shell",
                    UNBOUND_SCHEME (FUNTYPE (Types.string_type,
					     Types.int_type)),
                    MLWorks.Internal.Value.cast(
		      fn name =>
                          shell(
			    instream,
			    outstream,
			    change_eq_id shell_options,
			    Incremental.rename (!current_context, name),
			    prompter,
			    new_pr_options (user_options, print_options)
			  )
		  ))
              in
                context
              end

	    val exit_fn = MLWorks.Internal.Value.cast (fn n => raise Exit n)

	    (*
            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options(
		    context,
		    "exit",
                    UNBOUND_SCHEME (FUNTYPE (Types.int_type,
					     Types.empty_rec_type)),
                    MLWorks.Internal.Value.cast (fn n => raise Exit n)
		  )
              in
                context
              end
	    *)

            val context =
	      make_shell_structure(
		context,
                user_options,
                outstream,
                print_options, 
                shell_options, 
                current_context,
                prompter,
                action_queue,
		exit_fn
	      )
          in
            context
          end;

d1650 13
a1662 88
      let
        fun the_shell options context =
          shell (std_in, std_out, options, context,
		 default_prompter, default_print_desc)
          
        fun debugger_function
	      shell_fn 
	      deal_with_this_exception
	      print_options
	      (options as Incremental.OPTIONS{
			    make_options,
                            compiler_options as Compiler.MirTypes.OPTIONS{
			      info_opts,
			      ...
			    },
			    ...
			  },
	       context
	      )
	      f
	      x =
          let
            val call_debugger =
              Ml_Debugger.ml_debugger 
              Ml_Debugger.TERMINAL
              info_opts
              (print_options, options, context)
              (fn context' =>
               (shell_fn
                {make_options = make_options,
                 compiler_options = compiler_options,
                 debugger = debugger_function the_shell}
                context';
                ()))
          in
            MLWorks.Internal.Runtime.Event.signal
            (2,
	     fn s => (call_debugger (
			Ml_Debugger.SIGNAL s,
                        Ml_Debugger.POSSIBLE (
			  "Return to TopLevel",
			  Ml_Debugger.DO_RAISE DebuggerTrapped
			),
                        Ml_Debugger.POSSIBLE (
			  "Continue interrupted code",
			  Ml_Debugger.NORMAL_RETURN
		        ));
		      ()
		     )
	    );
            (MLWorks.Internal.Tracing.with_tracing (
	       fn in_value => 
                 call_debugger (
		   Ml_Debugger.TRACE in_value,
		   Ml_Debugger.NOT_POSSIBLE,
		   Ml_Debugger.NOT_POSSIBLE
	       ))
	     f
	     x
	    )
            handle DebuggerTrapped => raise DebuggerTrapped
            | exn => 
               if deal_with_this_exception exn then
                 (call_debugger (
		    Ml_Debugger.EXCEPTION exn,
                    Ml_Debugger.POSSIBLE (
		      "Return to TopLevel",
		      Ml_Debugger.DO_RAISE DebuggerTrapped
		    ),
                    Ml_Debugger.NOT_POSSIBLE
		  );
                  raise DebuggerTrapped)
               else
                 raise exn
          end
        
        val options = {
	  compiler_options = TopLevel.default_compiler_options,
          make_options =
            InterMake.OPTIONS {
	      name_monitor = InterMake.Option.ABSENT,
              compiler_options = TopLevel.default_compiler_options
	    },
          debugger = debugger_function the_shell
	}
      in
        the_shell options Incremental.initial
      end (* of main *)
@


1.34
log
@Changes to propagate compiler options as parameters instead of references.
Many settable options now plumbed in.
Exit function pu into shell structure.
Some minor tidying up.
@
text
@d11 6
a667 6
	    (*
            InterPrint.definitions
	      outstream
	      info_opts
	      (context, print_options, 0, identifiers);
            *)
a688 6
	    (*
            InterPrint.definitions
	      outstream
	      info_opts
	      (context, print_options, 0, identifiers);
	    *)
a722 33
	(*
        val value_printer_structure =
             STR (
	       STRNAME (Strname_id.make_strname_id ()),
	       ENV(
		 Strenv.empty_strenv,
		 Tyenv.empty_tyenv,
		 Lists.reducel
		   (fn (ve, (name, cell_type)) =>
		      Valenv.add_to_ve(
		        Ident.VAR(Ident.Symbol.find_symbol name),
		        UNBOUND_SCHEME(
		          CONSTYPE(
		            [CONSTYPE([], cell_type)],
		            Types.ref_tyname
		        )),
		        ve
		      )
		   )
		   (empty_valenv,
		    [("show_fn_details", Types.bool_tyname),
                     ("show_exn_details", Types.bool_tyname),
		     ("show_id_class", Types.bool_tyname),
		     ("show_eq_info", Types.bool_tyname),
		     ("maximum_list_size", Types.int_tyname),
		     ("maximum_ref_depth", Types.int_tyname),
		     ("maximum_shape_depth", Types.int_tyname),
		     ("maximum_depth", Types.int_tyname)
		   ]),
		 empty_valenv
	       )
	     )
	*)
a769 33
	(*
	val compiler_record =
	     MLWorks.Internal.Value.cast {
	       generate_tracing_code =
	         MLWorks.Internal.Value.cast(
	           #generate_tracing_code user_options
	         ),
	       generate_profiling_code =
	         MLWorks.Internal.Value.cast(
	           #generate_profiling_code user_options
	         ),
	       generate_debug_info =
	         MLWorks.Internal.Value.cast(
	           #generate_debug_info user_options
	         ),
	       show_debug_warnings =
	         MLWorks.Internal.Value.cast(
	           #show_debug_warnings user_options
	         ),
	       optimise_leaf_fns =
	         MLWorks.Internal.Value.cast(
	           #optimise_leaf_fns user_options
	         ),
	       optimise_tail_calls =
	         MLWorks.Internal.Value.cast(
	           #optimise_tail_calls user_options
	         ),
	       optimise_self_calls =
	         MLWorks.Internal.Value.cast(
	           #optimise_self_calls user_options
	         )
	    }
	    *)
a782 41
	(*
	val internals_record =
	     MLWorks.Internal.Value.cast {
	       show_absyn =
	         MLWorks.Internal.Value.cast(
	           #show_absyn user_options
	         ),
	       show_match =
	         MLWorks.Internal.Value.cast(
	           #show_match user_options
	         ),
	       show_lambda =
	         MLWorks.Internal.Value.cast(
	           #show_lambda user_options
	         ),
	       show_opt_lambda =
	         MLWorks.Internal.Value.cast(
	           #show_opt_lambda user_options
	         ),
	       show_mir =
	         MLWorks.Internal.Value.cast(
	           #show_mir user_options
	         ),
	       show_opt_mir =
	         MLWorks.Internal.Value.cast(
	           #show_opt_mir user_options
	         ),
	       show_debug_info =
	         MLWorks.Internal.Value.cast(
	           #show_debug_info user_options
	         ),
	       show_timings =
	         MLWorks.Internal.Value.cast(
	           #show_timings user_options
	         ),
	       show_minor_timings =
	         MLWorks.Internal.Value.cast(
	           #show_minor_timings user_options
	         )
	    }
	    *)
a793 29
	(*
        val topenv_structure =
             STR (
	       STRNAME (Strname_id.make_strname_id ()),
	       ENV(
		 Strenv.empty_strenv,
		 Tyenv.empty_tyenv,
		 Lists.reducel
		   (fn (ve, name) =>
		      Valenv.add_to_ve(
		        Ident.VAR(Ident.Symbol.find_symbol name),
		        UNBOUND_SCHEME show_type,
		        ve
		      )
		   )
		   (empty_valenv,
		    ["signatures",
		     "functors",
		     "structures",
		     "types",
		     "exceptions",
		     "constructors",
		     "variables",
		     "values"
		   ]),
                 empty_valenv
	       )
	     )
	*)
a843 25
	(*
        val make_structure = mk_structure
	     STR (
	       STRNAME (Strname_id.make_strname_id ()),
	       ENV (
	         Strenv.empty_strenv,
	         Tyenv.empty_tyenv,
	         Lists.reducel
	           (fn (ve, (name, type_rep)) =>
		      Valenv.add_to_ve(
		        Ident.VAR(Ident.Symbol.find_symbol name),
		        UNBOUND_SCHEME type_rep,
		        ve
		      )
		   )
		   (empty_valenv,
		    [("make", string_to_unit),
		     ("remake_file", string_to_unit),
		     ("compile", string_to_unit),
		     ("recompile", string_to_unit)
		   ]),
		 empty_valenv
	       )
	     )
	*)
a997 6
	    (*
            InterPrint.definitions
	      outstream
	      info_opts
	      (context, print_options, 0, identifiers);
             *)
a1530 10
		(*
                InterPrint.definitions
		  outstream
		  info_opts
		  (context,
                   print_options,
		   0,
		   identifiers
		  );
		*)
a1553 10
		(*
                InterPrint.definitions
		  outstream
		  info_opts
		  (context,
                   print_options,
		   0,
		   identifiers
		  );
		*)
a1570 10
		(*
                InterPrint.definitions
		  outstream
		  info_opts
		  (context,
                   print_options,
		   0,
		   identifiers
		  );
		*)
@


1.33
log
@Added a forced garbage collection before a save
@
text
@d11 3
d119 1
d122 4
d146 8
d199 2
a200 5
    val default_print_options =
      InterPrint.OPTIONS
	(InterPrint.ValuePrinter.toplevel_default_print_descriptor,
	 Incremental.Inter_EnvTypes.Info.default_options
	)
d204 9
a212 1
    fun empty_action_queue (action_queue,level,context,outstream,options,consumer,print_options) =
d226 4
a229 1
           InterPrint.definitions outstream (context, print_options, 0, identifiers);
d253 13
a265 3
                  InterPrint.definitions outstream (context,print_options, 0, identifiers);
                  next (empty_action_queue (action_queue,level+1,
                                            context,outstream,options,consumer,print_options))
d269 7
a275 3
            handle exn => (close_in stream; 
                           output(outstream,"Error occurred whilst USEing " ^ filename ^ "\n");
                           raise exn)
d296 24
a319 21
      show_fn_details:	     bool ref,
      show_exn_details:	     bool ref,
      maximum_list_size:     int ref,
      maximum_depth:	     int ref,
      maximum_shape_depth:   int ref,
      maximum_ref_depth:     int ref,
      show_id_class:	     bool ref,
      show_eq_info:	     bool ref,
      (*
      pervasive_library_dir: string ref
      *)
      show_absyn:	     bool ref,
      show_match:	     bool ref,
      show_lambda:	     bool ref,
      show_opt_lambda:	     bool ref,
      show_mir:	  	     bool ref,
      show_opt_mir:	     bool ref,
      show_mach:	     bool ref,
      show_debug_info:	     bool ref,
      show_timings:	     bool ref,
      show_print_timings:    bool ref
d322 61
d386 2
a387 1
        Incremental.FileName.parse_absolute(MLWorks.OS.Unix.getwd() ^ "/" ^ filename)
d518 1
a518 1
				       Compiler.OPTIONS{
d525 2
a526 1
      action_queue
d592 3
d605 2
a606 1
               val InterPrint.OPTIONS (print_descriptor,_) = print_options
d619 1
a619 1
                      (print_descriptor,a,b)
d639 1
a639 1
		   print_options
d646 2
d662 6
a667 4
            (*
             InterPrint.definitions outstream (context,
				          print_options, 0, identifiers);
             *)
a670 2
        (* make the context itself *)

d672 25
a696 15
              let
                val (context, identifiers) =
                  Incremental.add_value options
                  (context,
                   "start_mlworks",
                   UNBOUND_SCHEME (FUNTYPE (string_pair, Types.empty_rec_type)),
                   MLWorks.Internal.Value.cast((fn (h,s) =>
                                                Podium.start_mlworks(Listener.make_listener current_context command_handler_fn,h,s)):string * string -> unit)
                   )
              in
                (*
                 InterPrint.definitions outstream (context, print_options, 0, identifiers);
                 *)
                context
              end
d799 44
a849 1
	     ("show_mach", mk_ref Types.bool_tyname),
a881 4
	       show_mach =
	         MLWorks.Internal.Value.cast(
	           #show_mach user_options
	         ),
d981 1
a983 3
	     (* ,
	     ("pervasive_library_dir", string_ref)
	     *)
d1003 1
a1005 3
		     (* ,
		     ("pervasive_library_dir", string_ref)
		     *)
d1020 4
d1025 7
a1031 1
	         MLWorks.Internal.Value.cast TopLevel.compile_file,
a1032 3
	         MLWorks.Internal.Value.cast Recompile.recompile
	       (* ,
	       a_pervasive_library_dir =
d1034 6
a1039 3
	           #pervasive_library_dir user_options
	         )
	       *)
d1140 11
a1150 1
                        empty_valenv,
d1158 1
d1165 5
a1169 2
            (*
             InterPrint.definitions outstream (context, print_options, 0, identifiers);
d1174 1
d1181 1
a1181 1
          options as
d1184 4
a1187 1
              compiler_options as Compiler.OPTIONS{info_opts,...},
d1191 1
a1191 4
	    InterPrint.OPTIONS(
	      InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc,
	      _
	    )
d1203 2
a1204 1
            prompter {line = ~1, subline = !subline, name = !name, topdec = !topdec}
d1209 24
a1232 21
	  maximum_list_size     = ref(#maximum_list_size print_desc),
	  maximum_ref_depth     = ref(#maximum_ref_depth print_desc),
	  maximum_shape_depth   = ref(#maximum_shape_depth print_desc),
	  maximum_depth         = ref(#maximum_depth print_desc),
	  show_fn_details       = ref(#print_fn_details print_desc),
	  show_exn_details       = ref(#print_exn_details print_desc),
	  show_id_class	        = ref false,
	  show_eq_info 	        = ref false,
	  (*
	  pervasive_library_dir = ref ""
	  *)
          show_absyn		= ref false,
          show_match		= ref false,
          show_lambda		= ref false,
          show_opt_lambda	= ref false,
          show_mir		= ref false,
          show_opt_mir		= ref false,
          show_mach		= ref false,
          show_debug_info	= ref false,
          show_timings		= ref false,
          show_print_timings	= ref false
d1241 47
a1287 8
        val _ = current_context := make_shell_structure (context,
                                                         user_options,
                                                         std_out,
                                                         print_options,
                                                         options,
                                                         current_context,
                                                         prompter,
                                                         action_queue)
d1298 8
a1305 8
               |   trivial n =
                   let
                     val c = MLWorks.String.ordof (line, n-1)
                   in
                     (c = ord " " orelse c = ord "\n" orelse
                      c = ord "\t" orelse c = ord "\012") andalso
                     trivial (n-1)
                   end
d1321 12
a1332 4
                     datatype Action = STOP of string | AGAIN
                     fun loop' () =
                       if Lexer.eof token_stream 
                         then STOP(prompt())
d1336 2
a1337 2
                           info_opts
                           (token_stream,!current_pB,!current_parser_state)
d1341 2
a1342 1
                            STOP(prompt()))
d1347 6
d1354 6
a1359 3
                             Incremental.add_source options 
                             (context, 
                              Compiler.TOPDEC ("listener input",topdec))
d1361 4
a1364 1
                             InterPrint.definitions outstream (new_context, print_options, 0, identifiers);
d1366 9
a1374 7
                             empty_action_queue(action_queue,
                                                0,
                                                new_context,
                                                outstream,
                                                options,
                                                mk_consumer (fn s => output(std_out,s)),
                                                print_options)
d1377 2
a1378 1
                           (#topdec prompt_args) := Incremental.topdec new_context;
d1381 2
a1382 1
                           current_pB := Incremental.parser_basis (new_context);
d1384 1
a1384 1
                           AGAIN
d1386 8
a1393 6
                            | Parser.SyntaxError token =>
                                (current_parser_state := Parser.initial_parser_state;
                                 current_pB := Incremental.parser_basis(!current_context);
                                 (#subline prompt_args) := 0;
                                 STOP("Syntax error at " ^ token ^ "\n" ^ prompt()))
                     fun cycle () =
d1395 1
a1395 1
                         val res = loop'()
d1399 1
a1399 1
                           AGAIN => cycle()
d1403 1
a1403 1
                     cycle()
d1410 6
a1415 6
		    )
                      | DebuggerTrapped =>
                          ((#subline prompt_args) := 0;
                           ("Debugger entered\n" ^ prompt())
                           )
                      | Exit n => (prompt())
a1420 1

d1426 12
a1437 8
           current_context := empty_action_queue(action_queue,
                                                 0,
                                                 !current_context,
                                                 outstream,
                                                 options,
                                                 mk_consumer consumer,
                                                 print_options);
           "\n" ^ prompt()))
d1444 4
a1447 3
            val Incremental.OPTIONS old_options = options
            val InterMake.OPTIONS old_intermake_option = #make_options old_options
            val options' =
d1452 5
a1456 3
               InterMake.OPTIONS
               {compiler_options = #compiler_options old_intermake_option,
                name_monitor = InterMake.Option.PRESENT (mk_consumer consumer)}}
d1459 10
a1468 7
            current_context := empty_action_queue (action_queue,
                                                   0,
                                                   !current_context,
                                                   outstream,
                                                   options',
                                                   mk_consumer consumer,
                                                   print_options);
d1473 2
a1474 2
        (current_context,do_line,do_use,do_make)
      end; (* of make_listener_shell *)
d1478 1
a1478 1
    fun shell (instream,
d1480 4
a1483 2
	       shell_options as {compiler_options as Compiler.OPTIONS{info_opts,...},
                                 make_options,debugger},
d1487 2
a1488 1
		 InterPrint.OPTIONS(InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc, _)) =
d1493 24
a1516 21
	  maximum_list_size     = ref(#maximum_list_size print_desc),
	  maximum_ref_depth     = ref(#maximum_ref_depth print_desc),
	  maximum_shape_depth   = ref(#maximum_shape_depth print_desc),
	  maximum_depth         = ref(#maximum_depth print_desc),
	  show_fn_details       = ref(#print_fn_details print_desc),
	  show_exn_details       = ref(#print_exn_details print_desc),
	  show_id_class	        = ref false,
	  show_eq_info 	        = ref false,
	  (*
	  pervasive_library_dir = ref ""
	  *)
          show_absyn		= ref false,
          show_match		= ref false,
          show_lambda		= ref false,
          show_opt_lambda	= ref false,
          show_mir		= ref false,
          show_opt_mir		= ref false,
          show_mach		= ref false,
          show_debug_info	= ref false,
          show_timings		= ref false,
          show_print_timings	= ref false
a1521 1
        val current_print_options = ref print_options
d1525 8
a1532 5
        val options =
          Incremental.OPTIONS 
          {compiler_options=compiler_options,
           make_options = make_options,
           debugger = debugger (fn Exit _ => false | _ => true) current_print_options}
d1540 2
a1541 2
            datatype doit = STOP of int | AGAIN
            fun loop' () =
d1548 6
d1555 49
a1603 51
                  (#subline prompt_parameters) := 0;
                  (#topdec prompt_parameters) := Incremental.topdec context;
                  (#name prompt_parameters) := Incremental.name context;
                  current_context :=
                  let
                    val _ = current_print_options := print_options
                    val (context, identifiers) =
                      (Incremental.add_source options
                       (context, Compiler.TOKENSTREAM1 token_stream))
                      handle exn => (Lexer.flush_to_nl token_stream;
                                     raise exn)
		    val print_options =
		      InterPrint.OPTIONS (
			InterPrint.ValuePrinter.PRINTER_DESCRIPTOR {
			  print_fn_details =
			    !(#show_fn_details user_options),
			  print_exn_details =
			    !(#show_exn_details user_options),
			  maximum_list_size =
			    !(#maximum_list_size user_options),
			  maximum_ref_depth =
			    !(#maximum_ref_depth user_options),
			  maximum_shape_depth =
			    !(#maximum_shape_depth user_options),
			  maximum_depth =
			    !(#maximum_depth user_options),
			  print_method_table =
			    #print_method_table print_desc
			  (* ,
			  show_id_class =
			    !(#show_id_class user_options),
			  show_eq_info =
			    !(#show_eq_info user_options)
			  *)
		        },
			Info.default_options
		      )
                  in
                    InterPrint.definitions outstream (context,
                                                      print_options, 0,
                                                      identifiers);
                     
                    empty_action_queue (action_queue,
                                        0,
                                        context,
                                        outstream,
                                        options,
                                        mk_consumer (fn s => output(outstream,s)),
					print_options)
                  end;
                  AGAIN
a1604 12
              handle Exit n => STOP n
                   | Info.Stop _ => AGAIN
                   | DebuggerTrapped => AGAIN
                   | exn =>
                       let
                         val string =
                           MLWorks.Internal.Value.exn_name_string
                           (MLWorks.Internal.Value.exn_name exn)
                       in
                         output(outstream,"Uncaught exception " ^ string ^ "\n");
                         AGAIN
                       end
d1606 1
a1606 1
            fun cycle () =
d1608 1
a1608 1
                val x = loop'()
d1612 1
a1612 1
                | AGAIN => cycle()
d1615 1
a1615 1
            cycle()
d1623 1
d1626 35
d1664 39
a1702 21
                  Incremental.add_value options
                  (context, "save",
                   UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rec_type)),
                   MLWorks.Internal.Value.cast
                   (fn filename =>
                    (let
                      val old_level = ! MLWorks.Internal.Runtime.StorageManager.gc_message_level
                      fun collect 0 = ()
                        | collect n = (MLWorks.Internal.Runtime.StorageManager.interface(20,n);
                                       collect(n-1))
                    in
                      MLWorks.Internal.Runtime.StorageManager.gc_message_level := ~1;
                      collect 200;
                      MLWorks.Internal.Runtime.StorageManager.gc_message_level := old_level
                    end;
                    MLWorks.save (filename,
                                  fn () => (output(outstream,Version.version_string ^ "\n");
                                            shell
                                            (instream, outstream, shell_options, !current_context, prompter, print_options)))
                    handle MLWorks.Save message =>
                      Info.error' info_opts (Info.FATAL, Lexer.locate token_stream, message))))
d1704 10
a1713 4
                (*
                 InterPrint.definitions outstream (context,
                                                  print_options, 0, identifiers);
                 *)
d1720 1
a1720 1
                  Incremental.add_value options(
d1727 8
a1734 32
			let
		          val print_options =
		            InterPrint.OPTIONS (
			      InterPrint.ValuePrinter.PRINTER_DESCRIPTOR {
			        print_fn_details =
			          !(#show_fn_details user_options),
			        print_exn_details =
			          !(#show_exn_details user_options),
			        maximum_list_size =
			          !(#maximum_list_size user_options),
			        maximum_ref_depth =
			          !(#maximum_ref_depth user_options),
			        maximum_shape_depth =
			          !(#maximum_shape_depth user_options),
			        maximum_depth =
			          !(#maximum_depth user_options),
			        print_method_table =
			          #print_method_table print_desc
				(* ,
                                show_id_class =
                                  !(#show_id_class user_options),
                                show_eq_info =
                                  !(#show_eq_info user_options)
				*)
		              },
			      Info.default_options
			    )
			in
                          shell(instream, outstream, shell_options,
			        Incremental.rename (!current_context, name),
			        prompter, print_options)
			end
d1737 10
a1746 4
                (*
                 InterPrint.definitions outstream (context,
                                                  print_options, 0, identifiers);
                 *)
d1750 3
d1764 10
a1773 4
                (*
                 InterPrint.definitions outstream (context,
                                                  print_options, 0, identifiers);
                 *)
d1776 1
d1779 11
a1789 8
	      make_shell_structure(context,
                                   user_options,
                                   outstream,
                                   print_options, 
                                   options, 
                                   current_context,
                                   prompter,
                                   action_queue)
d1801 1
a1801 1
		 default_prompter, default_print_options)
d1803 16
a1818 7
        fun debugger_function shell_fn 
			      deal_with_this_exception
                              current_print_options_ref
			      (options as Incremental.OPTIONS{make_options,
                                                              compiler_options as Compiler.OPTIONS{info_opts,...},
							      ...}, context)
			      f x =
a1819 1
            val InterPrint.OPTIONS (printer_descriptor,_) = !current_print_options_ref
d1824 1
a1824 1
              (printer_descriptor,options, context)
d1834 24
a1857 9
            (2,fn s => (call_debugger (Ml_Debugger.SIGNAL s,
                                       Ml_Debugger.POSSIBLE
                                       ("Return to TopLevel",Ml_Debugger.DO_RAISE DebuggerTrapped),
                                       Ml_Debugger.POSSIBLE
                                       ("Continue interrupted code",Ml_Debugger.NORMAL_RETURN));()));
            (MLWorks.Internal.Tracing.with_tracing
             (fn in_value => 
              call_debugger 
              (Ml_Debugger.TRACE in_value,Ml_Debugger.NOT_POSSIBLE,Ml_Debugger.NOT_POSSIBLE)) f x)
d1859 13
a1871 10
                 | exn => 
                     if deal_with_this_exception exn 
                       then
                         (call_debugger (Ml_Debugger.EXCEPTION exn,
                                         Ml_Debugger.POSSIBLE
                                         ("Return to TopLevel",Ml_Debugger.DO_RAISE DebuggerTrapped),
                                         Ml_Debugger.NOT_POSSIBLE);
                         raise DebuggerTrapped)
                     else
                       raise exn
d1874 9
a1882 27
        val default_options = Info.OPTIONS {error = {outstream = std_out,
                                                     stop = Info.FATAL,
                                                     report = Info.ADVICE,
                                                     worst = ref Info.ADVICE},
                                            information = {outstream = std_out,
                                                           level = 2},
                                            listing = {outstream = std_out,
                                                       level = 2},
                                            diagnostic = {outstream = std_out,
                                                          level = 2},
					    show_eq_info = false,
					    show_id_class = false}

        val compiler_options = 
          Compiler.OPTIONS
          {info_opts = default_options,
           debug = true,
           profile = true
           }

        val options =
          {compiler_options = compiler_options,
           make_options =
             InterMake.OPTIONS
             {name_monitor = InterMake.Option.ABSENT,
              compiler_options = compiler_options},
           debugger = debugger_function the_shell}
@


1.32
log
@Changed stream handling.
@
text
@d11 3
d1374 10
d1388 2
a1389 2
                      handle MLWorks.Save message =>
                        Info.error' info_opts (Info.FATAL, Lexer.locate token_stream, message)))
@


1.31
log
@Debugger now takes the print options
@
text
@d11 3
a132 1
    structure Stream = Info.Stream
a134 2
    (* note that instream is a normal ML stream, outstream is a Stream.outstream *)

d150 2
a151 2
            Stream.output (outstream, prompter arg);
            Stream.flush_out outstream;
d199 1
a199 1
               (Stream.output (outstream,implode ["Error making `", Incremental.FileName.absolute_name filename, "'\n"]);
d233 1
a233 1
                           Stream.output(outstream,"Error occurred whilst USEing " ^ filename ^ "\n");
d246 1
a246 1
          if y <= 0 then x else ("   " ^ spaces (y-1) ^ "\n")
d248 1
a248 1
        print (spaces n)
d549 2
a550 1
            InterPrint.definitions outstream (context,
d552 1
d569 3
a571 1
                InterPrint.definitions outstream (context, print_options, 0, identifiers);
d986 3
a988 1
            InterPrint.definitions outstream (context, print_options, 0, identifiers);
a1049 53
        (* store the output here *)
        val current_output = ref [] : string list ref

        fun get_current_output () =
          let val outp = !current_output
          in
            current_output := [];
            implode (rev outp) ^ prompt()
          end

        fun out_fun s = current_output := s :: (!current_output)
        val outstream = Stream.outstream{output = out_fun,
                                         flush_out = fn () => (),
                                         close_out = fn () => ()}
          

        fun change_stream (Incremental.OPTIONS{compiler_options,
                                               make_options,
                                               debugger}) =
          let
            fun change_info_options (Info.OPTIONS {error,
                                                   information,
                                                   listing,
                                                   diagnostic,
						   show_eq_info,
						   show_id_class}) =
              let
                fun change_error {outstream = _ ,stop,report,worst} =
                  {outstream=outstream,stop=stop,report=report,worst=worst}
                fun change_other {outstream = _,level} = {outstream=outstream,level=level}
              in
                Info.OPTIONS{error = change_error error,
                             information = change_other information,
                             listing = change_other listing,
                             diagnostic = change_other diagnostic,
			     show_id_class = show_id_class,
			     show_eq_info = show_eq_info}
              end
            fun change_compiler_options (Compiler.OPTIONS{info_opts,debug,profile}) =
              Compiler.OPTIONS{info_opts = change_info_options info_opts,
                               debug = debug,
                               profile = profile}
            fun change_make_options (InterMake.OPTIONS{name_monitor,compiler_options}) =
              InterMake.OPTIONS{name_monitor = name_monitor,
                                compiler_options = change_compiler_options compiler_options}
          in
            Incremental.OPTIONS{compiler_options = change_compiler_options compiler_options,
                                make_options = change_make_options make_options,
                                debugger = debugger}
          end
                  
        val options = change_stream options
                                                                                   
d1056 1
a1056 1
                                                         outstream,
d1066 91
a1156 92
        fun do_line (line) =
          let
            fun trivial 0 = true
            |   trivial n =
              let
                val c = MLWorks.String.ordof (line, n-1)
              in
                (c = ord " " orelse c = ord "\n" orelse
                 c = ord "\t" orelse c = ord "\012") andalso
                trivial (n-1)
              end
          in
            if trivial (size line) then
              get_current_output()
            else
              let
                val input_function =
                  let val buff = ref line
                  in
                    fn _ => (let val out = !buff in buff := ""; out end)
                  end

                val token_stream = Lexer.mkTokenStream (input_function,
							"Listener Input")
                fun loop () =
                  let
                        datatype Action = STOP of string | AGAIN
                        fun loop' () =
                          if Lexer.eof token_stream 
                            then STOP(get_current_output())
                          else
                            let val (pB,new_state) =
                              Parser.parse_incrementally
                              info_opts
                              (token_stream,!current_pB,!current_parser_state)
                            in
                              (current_parser_state := new_state;
                               current_pB := pB;
                               STOP(get_current_output()))
                            end
                          handle Parser.FoundTopDec(topdec,newpB) =>
                            let
                              val context = !current_context
                              val (new_context, identifiers) =
                                Incremental.add_source options 
                                (context, 
                                 Compiler.TOPDEC ("listener input",topdec))
                              val _ = 
                                InterPrint.definitions outstream (new_context, print_options, 0, identifiers);
                              val new_context = 
                                empty_action_queue(action_queue,
                                                   0,
                                                   new_context,
                                                   outstream,
                                                   options,
                                                   mk_consumer out_fun,
						   print_options)
                            in
                              (#subline prompt_args) := 0;
                              (#topdec prompt_args) := Incremental.topdec new_context;
                              (#name prompt_args) := Incremental.name new_context;
                              current_context := new_context;
                              current_pB := Incremental.parser_basis (new_context);
                              current_parser_state := Parser.initial_parser_state;
                              AGAIN
                            end
                               | Parser.SyntaxError token =>
                                   (current_parser_state := Parser.initial_parser_state;
                                    current_pB := Incremental.parser_basis(!current_context);
                                    (#subline prompt_args) := 0;
                                    STOP("Syntax error at " ^ token ^ "\n" ^ get_current_output()))
                    fun cycle () =
                      let
                        val res = loop'()
                      in
                       (#subline prompt_args) := 1 + !(#subline prompt_args);
                        case res of
                          AGAIN => cycle()
                        | STOP x => x
                      end
                  in
                    cycle()
                  end
                  handle Info.Stop _ =>
                    (current_parser_state := Parser.initial_parser_state;
                     current_pB := Incremental.parser_basis(!current_context);
                     (#subline prompt_args) := 0;
                     ("Error occurred\n" ^ get_current_output())
		    )
                  | DebuggerTrapped =>
		    ((#subline prompt_args) := 0;
                     ("Debugger entered\n" ^ get_current_output())
d1158 9
a1166 5
                  | Exit n => (get_current_output())
              in
                loop()
              end
          end
d1169 4
a1172 1
        fun do_use (name,consumer) =
d1181 1
a1181 1
           "\n" ^ get_current_output())
d1183 4
a1186 1
        fun do_make (name,consumer) =
d1207 2
a1208 2
            "\n" ^ get_current_output()
          end
d1320 1
d1326 1
a1326 1
                                        mk_consumer (fn s => Stream.output(outstream,s)),
d1340 1
a1340 1
                         Stream.output(outstream,"Uncaught exception " ^ string ^ "\n");
d1372 1
a1372 1
                                  fn () => (Stream.output(outstream,Version.version_string ^ "\n");
d1378 2
a1379 1
                InterPrint.definitions outstream (context,
d1381 1
d1429 2
a1430 1
                InterPrint.definitions outstream (context,
d1432 1
d1447 2
a1448 1
                InterPrint.definitions outstream (context,
d1450 1
a1471 5
        val outstream = Stream.outstream {output = fn s => output(std_out,s),
                                          flush_out = fn () => (),
                                          close_out = fn () => ()}
            

d1473 1
a1473 1
          shell (std_in, outstream, options, context,
d1521 1
a1521 1
        val default_options = Info.OPTIONS {error = {outstream = outstream,
d1525 1
a1525 1
                                            information = {outstream = outstream,
d1527 1
a1527 1
                                            listing = {outstream = outstream,
d1529 1
a1529 1
                                            diagnostic = {outstream = outstream,
@


1.30
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d11 4
d73 1
d90 1
d112 2
d495 2
a496 1
               fun debugger_function args f x =
d508 1
a508 1
                      args
d1292 1
d1300 1
a1300 1
           debugger = debugger (fn Exit _ => false | _ => true)}
d1322 1
d1408 4
a1411 1
                    MLWorks.save (filename, fn () => shell (instream, outstream, shell_options, !current_context, prompter, print_options))
d1514 1
d1520 1
d1525 1
a1525 1
              (options, context)
a1584 1
        MLWorks.Internal.Runtime.modules := [];
@


1.29
log
@Flush output when starting shell.
@
text
@d11 3
d55 1
d58 1
d63 2
a64 2
(* require "../main/toplevel"; *)
(* require "../make/recompile"; *)
d72 1
d80 2
a81 2
               structure Recompile : sig val recompile : string -> unit end
               structure TopLevel : sig val compile_file : string -> unit end
d93 2
d99 1
a99 1
                 Listener.Incremental
d101 4
a104 2
               sharing InterPrint.Incremental.InterMake.Compiler.Parser.Lexer.Info =
		 Ml_Debugger.Info
d120 1
a120 1
    structure Basis = InterMake.Compiler.Basis
d174 3
a176 1
	InterPrint.ValuePrinter.toplevel_default_print_descriptor
d255 1
d257 11
d279 1
a279 1
    fun show_debug_info (name,context) =
d317 1
a317 1
        output(std_out,Debugger_Types.string_information (Debugger_Types.INFO filtered_map));
d323 1
a323 1
	(Symbol.symbol_name o (fn (Ident.SIGID s) => s))
d333 1
a333 1
	  (Symbol.symbol_name o (fn (Ident.FUNID s) => s))
d345 1
a345 1
	  (Symbol.symbol_name o (fn (Ident.STRID s) => s))
d357 1
a357 1
	  (Symbol.symbol_name o (fn (Ident.TYCON s) => s))
d394 2
a395 1
    (* make the visible structures of the shell, this is called each time a shell is made *)
d397 16
a412 5
    fun make_shell_structure(context, user_options: user_options, outstream, print_options,
                             options as Incremental.OPTIONS{make_options,
                                                              compiler_options as Compiler.OPTIONS{info_opts,...},
							      ...},
                             current_context, prompter, action_queue) =
a483 1

d491 8
a498 1
                      info_opts
d501 5
a505 2
                      (Ml_Debugger.EXCEPTION exn,Ml_Debugger.NOT_POSSIBLE,Ml_Debugger.NOT_POSSIBLE);
                      raise DebuggerTrapped))
d526 19
d562 98
a659 48
        val context =
          let
            val (context, identifiers) =
              Incremental.add_value options(
	        context,
		"use",
                UNBOUND_SCHEME (
		  FUNTYPE (Types.string_type, Types.empty_rec_type)
		),
                MLWorks.Internal.Value.cast(
		  fn filename => action_queue := USE(filename) :: !action_queue
	        )
	      )
          in
            InterPrint.definitions outstream (context, print_options, 0, identifiers);
            context
          end

            val value_printer_structure =
                 STR (
	           STRNAME (Strname_id.make_strname_id ()),
	           ENV(
		     Strenv.empty_strenv,
		     Tyenv.empty_tyenv,
		     Lists.reducel
		       (fn (ve, (name, cell_type)) =>
			  Valenv.add_to_ve(
			    Ident.VAR(Ident.Symbol.find_symbol name),
			    UNBOUND_SCHEME(
			      CONSTYPE(
			        [CONSTYPE([], cell_type)],
			        Types.ref_tyname
			    )),
			    ve
			  )
		       )
		       (empty_valenv,
			[("show_fn_details", Types.bool_tyname),
                         ("show_exn_details", Types.bool_tyname),
			 ("show_id_class", Types.bool_tyname),
			 ("show_eq_info", Types.bool_tyname),
			 ("maximum_list_size", Types.int_tyname),
			 ("maximum_ref_depth", Types.int_tyname),
			 ("maximum_shape_depth", Types.int_tyname),
			 ("maximum_depth", Types.int_tyname)
		       ]),
		       empty_valenv
	           )
d661 1
a661 36
	 
	    val value_printer_record =
	         MLWorks.Internal.Value.cast {
		   maximum_depth =
		     MLWorks.Internal.Value.cast(
		       #maximum_depth user_options
		     ),
		   maximum_shape_depth =
		     MLWorks.Internal.Value.cast(
		       #maximum_shape_depth user_options
		     ),
		   maximum_ref_depth =
		     MLWorks.Internal.Value.cast(
		       #maximum_ref_depth user_options
		     ),
		   maximum_list_size =
		     MLWorks.Internal.Value.cast(
		       #maximum_list_size user_options
		     ),
		   show_fn_details =
		     MLWorks.Internal.Value.cast(
		       #show_fn_details user_options
		     ),
		   show_exn_details =
		     MLWorks.Internal.Value.cast(
		       #show_exn_details user_options
		     ),
		   show_id_class =
		     MLWorks.Internal.Value.cast(
		       #show_id_class user_options
		     ),
		   show_eq_info =
		     MLWorks.Internal.Value.cast(
		       #show_eq_info user_options
		     )
		}
d663 55
a717 26
            val topenv_structure =
                 STR (
	           STRNAME (Strname_id.make_strname_id ()),
	           ENV(
		     Strenv.empty_strenv,
		     Tyenv.empty_tyenv,
		     Lists.reducel
		       (fn (ve, name) =>
			  Valenv.add_to_ve(
			    Ident.VAR(Ident.Symbol.find_symbol name),
			    UNBOUND_SCHEME show_type,
			    ve
			  )
		       )
		       (empty_valenv,
			["signatures",
			 "functors",
			 "structures",
			 "types",
			 "exceptions",
			 "constructors",
			 "variables",
			 "values"
		       ]),
                     empty_valenv
	           )
d719 2
d722 24
a745 63
	    val topenv_record =
	         MLWorks.Internal.Value.cast {
		   a_signatures =
		     MLWorks.Internal.Value.cast(
		       fn () => show_signatures (!current_context)
		     ),
		   a_functors =
		     MLWorks.Internal.Value.cast(
		       fn () => show_functors (!current_context)
		     ),
		   a_structures =
		     MLWorks.Internal.Value.cast(
		       fn () => show_structures (!current_context)
		     ),
		   a_types =
		     MLWorks.Internal.Value.cast(
		       fn () => show_types (!current_context)
		     ),
		   a_exceptions =
		     MLWorks.Internal.Value.cast(
		       fn () => show_exceptions (!current_context)
		     ),
		   a_constructors =
		     MLWorks.Internal.Value.cast(
		       fn () => show_values
				  (fn (Ident.CON _) => true | _ => false)
				  (!current_context)
		     ),
		   a_variables =
		     MLWorks.Internal.Value.cast(
		       fn () => show_values
				  (fn (Ident.VAR _) => true | _ => false)
				  (!current_context)
		     ),
		   a_values =
		     MLWorks.Internal.Value.cast(
		       fn () => show_values
				  (fn _ => true)
				  (!current_context)
		     )
		}

            val make_structure =
		 STR (
		   STRNAME (Strname_id.make_strname_id ()),
		   ENV (
		     Strenv.empty_strenv,
		     Tyenv.empty_tyenv,
		     Lists.reducel
		       (fn (ve, (name, type_rep)) =>
			  Valenv.add_to_ve(
			    Ident.VAR(Ident.Symbol.find_symbol name),
			    UNBOUND_SCHEME type_rep,
			    ve
			  )
		       )
		       (empty_valenv,
			[("make", string_to_unit),
			 ("compile", string_to_unit),
			 ("recompile", string_to_unit),
			 ("pervasive_library_dir", string_ref)
		       ]),
		     empty_valenv
d747 56
a802 1
		 )
d804 23
a826 43
	    val make_record =
		 (* Prefix "a_" for values, "b_" for exceptions,
		    and "c_" for structures, to ensure correct ordering.
		  *)
		 MLWorks.Internal.Value.cast{
		   a_make =
		     MLWorks.Internal.Value.cast(
		       fn filename =>
			 action_queue :=
			   MAKE (parse_absolute filename) :: !action_queue
		     ),
		   a_compile =
		     MLWorks.Internal.Value.cast TopLevel.compile_file,
		   a_recompile =
		     MLWorks.Internal.Value.cast Recompile.recompile,
		   a_pervasive_library_dir =
		     MLWorks.Internal.Value.cast (
		       #pervasive_library_dir user_options
		     )
		}

	    val debug_structure =
		 STR (
		   STRNAME (Strname_id.make_strname_id ()),
		   ENV (
		     Strenv.empty_strenv,
		     Tyenv.empty_tyenv,
		     Lists.reducel
		       (fn (ve, (name, typescheme)) =>
			  Valenv.add_to_ve(
			    Ident.VAR(Ident.Symbol.find_symbol name),
			    typescheme,
			    ve
			  )
		       )
		       (empty_valenv,
			[("trace", alpha_beta_bool),
			 ("untrace", alpha_beta_bool),
			 ("show_debug_info", UNBOUND_SCHEME string_to_unit),
		 	 ("show_all_debug_info", UNBOUND_SCHEME unit_to_unit),
			 ("clear_debug_info", UNBOUND_SCHEME unit_to_unit)
		       ]),
		     empty_valenv
d828 29
d858 2
d861 73
a933 42
	    val debug_record =
	         (* Prefix "a_" for values, "b_" for exceptions,
	            and "c_" for structures, to ensure correct ordering.
	          *)
                 MLWorks.Internal.Value.cast{
                   a_trace =
                     MLWorks.Internal.Value.cast
                       MLWorks.Internal.Tracing.add_trace,
                   a_untrace =
                     MLWorks.Internal.Value.cast
                       MLWorks.Internal.Tracing.remove_trace,
		   a_clear_debug_info =
		     MLWorks.Internal.Value.cast
                     (fn () => current_context := Incremental.clear_debug_info(!current_context)),
		   a_show_debug_info =
		     MLWorks.Internal.Value.cast
                     (fn name => show_debug_info (name,!current_context)),
		   a_show_all_debug_info =
		     MLWorks.Internal.Value.cast
                     (fn () => show_debug_info ("",!current_context))
		}

            val options_structure =
                 STR (
	           STRNAME (Strname_id.make_strname_id ()),
                   ENV (
		     Lists.reducel
		       (fn (se, (name, str)) =>
			  Strenv.add_to_se(
			    Ident.STRID(Ident.Symbol.find_symbol name),
			    str,
			    se
			  )
		       )
		       (Strenv.empty_strenv,
			[("ValuePrinter", value_printer_structure)
		       ]),
                     Tyenv.empty_tyenv,
                     empty_valenv,
                     empty_valenv
	           )
	         )
a934 8
	    val options_record =
	         (* Prefix "a_" for values, "b_" for exceptions,
	            and "c_" for structures, to ensure correct ordering.
	          *)
                 MLWorks.Internal.Value.cast{
		   c_value_printer = value_printer_record
		 }

d946 11
a956 12
                        (fn (se, (name, str)) =>
                         Strenv.add_to_se(
                                          Ident.STRID(Ident.Symbol.find_symbol name),
                                          str,
                                          se
                                          )
                         )
                        (Strenv.empty_strenv,
                         [("Make", make_structure),
                          ("Options", options_structure),
                          ("Debug", debug_structure),
                          ("TopEnv", topenv_structure)
d964 1
a964 1
and "c_" for structures, to ensure correct ordering.
d980 15
a994 9
    and make_listener_shell (context,
                             prompter,
                             options as Incremental.OPTIONS{make_options,
                                                            compiler_options as Compiler.OPTIONS{info_opts,...},
                                                            ...},
                             print_options as
                             InterPrint.OPTIONS(
                                                InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc)
                             ) =
d1018 1
d1020 11
d1058 3
a1060 1
                                                   diagnostic}) =
d1069 3
a1071 1
                             diagnostic = change_other diagnostic}
d1252 1
a1252 1
		 InterPrint.OPTIONS(InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc)) =
d1265 1
d1267 11
d1340 3
a1342 1
		      })
d1440 3
a1442 1
		            })
d1550 3
a1552 1
                                                          level = 2}}
@


1.28
log
@Added some of the functions in the Debug structure
@
text
@d11 3
d936 1
a936 1
              prompt ()
@


1.27
log
@Integrated clm stuff.  Tidied some things up.  Used streams more.
@
text
@d11 3
d110 1
d252 42
d734 1
a734 1
		       not_implemented,
d737 1
a737 1
		       not_implemented,
d740 1
a740 1
		       not_implemented
@


1.26
log
@Put the substructures in the structures.
@
text
@d11 3
d52 2
a53 5
require "../typechecker/basis";
require "../main/toplevel";
require "../make/unix";
require "../make/recompile";
require "../main/io";
d55 2
a56 2
require "../debugger/value_printer";
require "incremental";
d60 1
a60 4
functor Shell (structure Incremental : INCREMENTAL
               structure InterPrint : INTERPRINT
               structure Io : IO
               structure Unix : UNIX
d68 4
a71 2
               structure Recompile : RECOMPILE
               structure TopLevel : TOPLEVEL
d75 1
a75 1
                 Incremental.Datatypes =
d81 2
d84 2
a85 2
		 Incremental =
		 Ml_Debugger.Incremental
d87 1
a87 1
               sharing Incremental.InterMake.Compiler.Parser.Lexer.Info =
d96 3
a98 1
    structure Compiler = Incremental.InterMake.Compiler
d104 1
a104 1
    structure Basis = Incremental.InterMake.Compiler.Basis
d106 3
d125 2
a126 2
            output (outstream, prompter arg);
            MLWorks.IO.flush_out outstream;
d159 3
a161 1
    fun empty_action_queue (action_queue,level,write,context,outstream,options,consumer,print_options) =
d172 1
a172 2
               (write (outstream, 
                       implode ["Error making `", Incremental.FileName.absolute_name filename, "'\n"]);
d175 1
a175 1
           InterPrint.definitions write (outstream, context, print_options, 0, identifiers);
d199 1
a199 1
                  InterPrint.definitions write (outstream, context,print_options, 0, identifiers);
d201 1
a201 1
                                            write,context,outstream,options,consumer,print_options))
d206 1
a206 1
                           write(outstream,"Error occurred whilst USEing " ^ filename ^ "\n");
d214 3
a216 1
    fun mk_consumer write (n,x) =
d219 1
a219 1
          if y <= 0 then x else ("   " ^ spaces (y-1))
d221 1
a221 1
        write(spaces n)
d224 3
d321 2
d327 1
a327 1
                             current_context, write, prompter, action_queue) =
d331 4
a344 16
        fun make_quad_type (a,b,c,d) = 
          Types.add_to_rectype(
	    Ident.LAB (Symbol.find_symbol "1"),
            a,
            Types.add_to_rectype(
	      Ident.LAB (Symbol.find_symbol "2"),
              b,
              Types.add_to_rectype(
		Ident.LAB (Symbol.find_symbol "3"),
                c,
                Types.add_to_rectype(
		  Ident.LAB (Symbol.find_symbol "4"),
                  d,
                  Types.empty_rec_type
	   ))))

a394 5
        val context_tyname =
          Types.make_tyname(0, false, "context", Types.Datatypes.ABSENT)

        val context_constype = CONSTYPE([],context_tyname)

d398 1
a398 8
        val debugger_window_type =
          FUNTYPE(
	    make_pair(
	      CONSTYPE([],Types.string_tyname),
              CONSTYPE([string_pair],Types.list_tyname)
	    ),
            Types.empty_rec_type
	  )
a399 12
        val command_handler_type = 
          FUNTYPE(
	    context_constype,
            FUNTYPE(
	      debugger_window_type,
              make_quad_type(
		context_constype,
                FUNTYPE(Types.string_type,Types.string_type),
                consumer_type,
                consumer_type
	  )))
                    
d432 17
d463 1
a463 2
            InterPrint.definitions write (outstream, context,
				          print_options, 0, identifiers);
d621 2
a622 2
			 ("compile", unit_to_unit),
			 ("recompile", unit_to_unit),
d736 19
a754 32
		     Lists.reducel
		       (fn (se, (name, str)) =>
			  Strenv.add_to_se(
			    Ident.STRID(Ident.Symbol.find_symbol name),
			    str,
			    se
			  )
		       )
		       (Strenv.empty_strenv,
			[("Make", make_structure),
			 ("Options", options_structure),
			 ("Debug", debug_structure),
			 ("TopEnv", topenv_structure)
		       ]),
                     Tyenv.add_to_te(
		       Ident.TYCON (Ident.Symbol.find_symbol "context"),
                       TYSTR(ETA_TYFUN context_tyname, empty_valenv),
                       Tyenv.empty_tyenv
		     ), 
                     Valenv.add_to_ve(
		        Ident.VAR(Ident.Symbol.find_symbol
			          "interface_to_windows"),
                        UNBOUND_SCHEME command_handler_type,
                        Valenv.add_to_ve(
		          Ident.VAR(Ident.Symbol.find_symbol "initial_context"),
                          UNBOUND_SCHEME context_constype,
                          empty_valenv
		        )
		     ),
                     empty_valenv
	           )
	         ),
d756 1
a756 1
	            and "c_" for structures, to ensure correct ordering.
d759 1
a759 5
		   a_initial_context =
		     MLWorks.Internal.Value.cast current_context,
                   a_interface_to_windows =
		     MLWorks.Internal.Value.cast command_handler_fn,
		   c_topenv = topenv_record,
d765 1
a765 3
            InterPrint.definitions
	      write
	      (outstream, context, print_options, 0, identifiers);
d770 1
a770 1
      end
d772 10
a781 11
    and make_listener_shell (
	  context,
	  prompter,
          options as Incremental.OPTIONS{make_options,
                                         compiler_options as Compiler.OPTIONS{info_opts,...},
                                         ...},
	  print_options as
	    InterPrint.OPTIONS(
	      InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc)
    ) = let

d819 5
a823 3
        fun write ((), string) = current_output := string :: (!current_output)
            
        val action_queue = ref ([]  : QueueEntry list)
d825 8
a832 25
        val current_context = 
          ref
          (let
             open Datatypes
            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options
                  (context, "use",
                   UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rec_type)),
                   MLWorks.Internal.Value.cast (fn filename => action_queue := USE(filename) :: !action_queue))
              in
                context
              end
            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options
                  (context, "recompile",
                   UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rec_type)),
                   MLWorks.Internal.Value.cast (Recompile.recompile))
              in
                context
              end
            val context =
d834 3
a836 17
                val (context, identifiers) =
                  Incremental.add_value options
                  (context, "compile",
                   UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rec_type)),
                   MLWorks.Internal.Value.cast (TopLevel.compile_file))
              in
                context
              end
            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options
                  (context, "make",
                   UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rec_type)),
                   MLWorks.Internal.Value.cast
                   (fn filename =>
                    action_queue := MAKE(parse_absolute filename) :: !action_queue))
d838 4
a841 1
                context
d843 7
d851 8
a858 2
            context
          end)
d860 1
d862 9
d922 1
a922 1
                                InterPrint.definitions write ((), new_context, print_options, 0, identifiers);
d925 1
a925 1
                                                   0,write,
d927 3
a929 2
                                                   (),options,
                                                   mk_consumer(fn x => write((),x)),
d976 7
a982 1
           current_context := empty_action_queue(action_queue,0,write,!current_context,(),options,mk_consumer consumer,print_options);
d988 1
a988 1
            val Incremental.InterMake.OPTIONS old_intermake_option = #make_options old_options
d994 1
a994 1
               Incremental.InterMake.OPTIONS
d996 1
a996 1
                name_monitor = Incremental.InterMake.Option.PRESENT (mk_consumer consumer)}}
d999 7
a1005 1
            current_context := empty_action_queue(action_queue,0,write,!current_context,(),options',mk_consumer consumer,print_options);
d1011 1
a1011 1
      end;
d1013 1
a1013 5
    fun prompt_for_return exn =
      (output(std_out,"Return to top level (y for yes - anything else for no) ?");
       if MLWorks.IO.input_line std_in = "y\n"
         then raise exn
       else ())
d1022 1
a1022 3
		 InterPrint.OPTIONS(
		   InterPrint.ValuePrinter.PRINTER_DESCRIPTOR print_desc
	      )) =
a1053 2
        fun write (outstream, string) = (output (outstream, string); outstream)

d1100 3
a1102 3
                    InterPrint.definitions write (outstream, context,
						  print_options, 0,
						  identifiers);
d1104 1
a1104 1
                                        0,write,
d1106 3
a1108 1
                                        outstream,options,mk_consumer(fn x => (write(outstream,x); ())),
d1122 1
a1122 1
                         write (outstream, "Uncaught exception " ^ string ^ "\n");
d1157 2
a1158 2
                InterPrint.definitions write (outstream, context,
					      print_options, 0, identifiers);
d1204 2
a1205 2
                InterPrint.definitions write (outstream, context,
					      print_options, 0, identifiers);
d1220 2
a1221 2
                InterPrint.definitions write (outstream, context,
					      print_options, 0, identifiers);
d1226 8
a1233 1
	      make_shell_structure(context, user_options, outstream, print_options, options, current_context, write, prompter, action_queue)
d1239 1
a1239 1
      end
d1243 5
d1249 1
a1249 1
          shell (std_in, std_out, options, context,
d1295 7
a1301 8
    val dummy_stream = Info.Stream.outstream{output = fn s => output(std_out,s),
                                             flush_out = fn () => (),
                                             close_out = fn () => ()}
    val default_options = Info.OPTIONS {error = {outstream = dummy_stream,
                                                 stop = Info.FATAL,
                                                 report = Info.ADVICE,
                                                 worst = ref Info.ADVICE},
                                        information = {outstream = dummy_stream,
d1303 2
a1304 4
                                        listing = {outstream = dummy_stream,
                                                   level = 2},
                                        diagnostic = {outstream = dummy_stream,
                                                      level = 2}}
d1316 2
a1317 2
             Incremental.InterMake.OPTIONS
             {name_monitor = Incremental.InterMake.Option.ABSENT,
d1323 1
a1323 1
      end
@


1.25
log
@The debugger now takes messages to go with the 'q' and 'c' options
@
text
@d11 3
a473 4
              Incremental.add_structure
	        options
                (context,
	         "ValuePrinter",
d503 3
a505 1
	         ),
d539 1
a539 1
		})
a541 4
              Incremental.add_structure
	        options
                (context,
	         "Topenv",
d567 3
a569 1
	         ),
d609 1
a609 1
		})
a611 4
              Incremental.add_structure
	        options
                (context,
		 "Make",
d633 3
a635 1
		 ),
d654 1
a654 1
		})
a656 4
	      Incremental.add_structure
		options
		(context,
		 "Debug",
d679 3
a681 1
	         ),
d701 1
a701 1
		})
a703 4
              Incremental.add_structure
	        options
                (context,
	         "Options",
d707 11
a717 1
		     Strenv.empty_strenv,
d722 3
a724 1
	         ),
d729 2
a730 3
		   c_value_printer =
		     MLWorks.Internal.Value.cast value_printer_structure
		 })
d742 14
a755 1
		     Strenv.empty_strenv,
d782 4
a785 6
		   c_topenv =
		     MLWorks.Internal.Value.cast topenv_structure,
		   c_debug =
		     MLWorks.Internal.Value.cast debug_structure,
		   c_options =
		     MLWorks.Internal.Value.cast options_structure
@


1.24
log
@More changes to the user visible structures.  These aren't plumbed in
to the rest of the compiler yet.
@
text
@d11 4
d40 1
d70 1
a85 3
	       sharing Tyenv.NewMap =
		 Incremental.Datatypes.NewMap

d214 1
d429 2
a430 3
                      (Ml_Debugger.EXCEPTION exn);
                    raise DebuggerTrapped
		 ))
d494 1
d526 4
d814 1
d1041 1
d1091 2
d1187 2
d1256 12
a1267 13
            fun call_debugger e =
              (Ml_Debugger.ml_debugger 
               Ml_Debugger.TERMINAL
               info_opts
               (options, context)
               (fn context' =>
                (shell_fn
                 {make_options = make_options,
                  compiler_options = compiler_options,
                  debugger = debugger_function the_shell}
                 context';
                 ()))
               e)
d1270 9
a1278 3
            (2,fn s => (call_debugger (Ml_Debugger.SIGNAL s);
                        prompt_for_return DebuggerTrapped));
            (MLWorks.Internal.Tracing.with_tracing(fn in_value => call_debugger (Ml_Debugger.TRACE in_value)) f x)
d1281 7
a1287 3
                     if deal_with_this_exception exn then
                       (call_debugger (Ml_Debugger.EXCEPTION exn);
                        raise DebuggerTrapped)
d1291 1
a1291 1

@


1.23
log
@Modified sharing constraints to remove superfluous structures
@
text
@d11 3
d41 1
d73 4
a76 1
               sharing InterPrint.Incremental = Incremental = Ml_Debugger.Incremental
d79 7
a85 1
               val default_prompter : {line : int, subline : int, name : string, topdec : int} -> string
d95 1
d109 2
a110 1
                {line = line_number, subline = !subline, name = !name, topdec = !topdec}
d210 8
a217 5
      print_fn_details:	   bool ref,
      maximum_list_size:   int ref,
      maximum_depth:	   int ref,
      maximum_shape_depth: int ref,
      maximum_ref_depth:   int ref
d225 21
a245 1
    fun show_structures (context) =
d248 32
a279 2
	  case Incremental.env context of
	    Datatypes.ENV(Datatypes.SE map, _, _, _) => map
d281 3
a283 1
	Datatypes.NewMap.domain strmap
d286 16
d313 17
a329 1
                a,
d331 2
a332 2
		  Ident.LAB (Symbol.find_symbol "2"),
                  b,
d334 1
a334 1
	      ))
d336 37
a372 34
            fun make_quad_type (a,b,c,d) = 
              Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "1"),
                                   a,
                                   Types.add_to_rectype
                                   (Ident.LAB (Symbol.find_symbol "2"),
                                    b,
                                    Types.add_to_rectype
                                    (Ident.LAB (Symbol.find_symbol "3"),
                                     c,
                                     Types.add_to_rectype
                                     (Ident.LAB (Symbol.find_symbol "4"),
                                      d,
                                      Types.empty_rec_type))))

            val string_pair = 
              make_pair(
		CONSTYPE([],Types.string_tyname),
		CONSTYPE([],Types.string_tyname)
	      )

            val consumer_type = 
              FUNTYPE
              (make_pair(CONSTYPE([],Types.string_tyname),
                         FUNTYPE(Types.string_type,Types.empty_rec_type)),
               Types.string_type)
              
            val show_type = 
              FUNTYPE(
                Types.empty_rec_type,
                CONSTYPE([CONSTYPE([],Types.string_tyname)], Types.list_tyname)
	      )

            val context_tyname =
	      Types.make_tyname(0, false, "context", Types.Datatypes.ABSENT)
d374 40
a413 29
            val context_constype = CONSTYPE([],context_tyname)

            (* Make up the type ('a -> 'b) -> unit *)
            val alpha_beta_bool =
              let 
                val aty = TYVAR (ref 0,Ident.TYVAR (Ident.Symbol.find_symbol ("'a"),false,false))
                val bty = TYVAR (ref 0,Ident.TYVAR (Ident.Symbol.find_symbol ("'b"),false,false))
              in
                Scheme.make_scheme ([aty,bty],
                                    FUNTYPE
                                    (FUNTYPE(aty,bty),
                                     CONSTYPE([],Types.bool_tyname)))
              end

            val debugger_window_type =
              FUNTYPE
              (make_pair(CONSTYPE([],Types.string_tyname),
                         CONSTYPE([string_pair],Types.list_tyname)),
               Types.empty_rec_type)
              
            val command_handler_type = 
              FUNTYPE
              (context_constype,
               FUNTYPE 
               (debugger_window_type,
                make_quad_type(context_constype,
                               FUNTYPE(Types.string_type,Types.string_type),
                               consumer_type,
                               consumer_type)))
d415 7
a421 7
            fun command_handler_fn current_context =
              (fn window_fn =>
               let
                 fun debugger_function args f x =
                   (f(x) handle exn => 
                     (Ml_Debugger.ml_debugger 
                      (Ml_Debugger.WINDOWING window_fn)
d426 2
a427 1
                      raise DebuggerTrapped))
d429 18
a446 16
                 fun copy_options (Incremental.OPTIONS x) =
                   Incremental.OPTIONS{
		     compiler_options = #compiler_options x,
                     make_options = #make_options x,
                     debugger = debugger_function
		   }

                   val interface =
                     make_listener_shell(!current_context,
					 prompter,
					 copy_options options,
					 print_options
					 )
               in
                 interface
               end)
d448 18
a465 16
            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options(
		    context,
		    "use",
                    UNBOUND_SCHEME (FUNTYPE (Types.string_type,
					     Types.empty_rec_type)),
                    MLWorks.Internal.Value.cast(
		      fn filename => action_queue := USE(filename) :: !action_queue
		  ))
              in
                InterPrint.definitions write (outstream, context,
					      print_options, 0, identifiers);
                context
              end
d467 153
a619 72
            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options(
		    context,
		    "recompile",
                    UNBOUND_SCHEME (FUNTYPE (Types.string_type,
					     Types.empty_rec_type)),
                    MLWorks.Internal.Value.cast(Recompile.recompile))
              in
                InterPrint.definitions write (outstream, context,
					      print_options, 0, identifiers);
                context
              end

            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options(
		    context,
                   "compile",
                    UNBOUND_SCHEME (FUNTYPE (Types.string_type,
					     Types.empty_rec_type)),
                    MLWorks.Internal.Value.cast(TopLevel.compile_file))
              in
                InterPrint.definitions write (outstream, context,
					      print_options, 0, identifiers);
                context
              end

            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options(
		    context,
		    "make",
                    UNBOUND_SCHEME (FUNTYPE (Types.string_type,
					     Types.empty_rec_type)),
                    MLWorks.Internal.Value.cast(
		      fn filename =>
                        action_queue :=
			  MAKE (parse_absolute filename) :: !action_queue)
		  )
              in
                InterPrint.definitions write (outstream, context,
					      print_options, 0, identifiers);
                context
              end

            val context =
              let
        val (context, identifiers) =
          Incremental.add_structure
	    options
            (context,
	     "Print",
             STR (
	       STRNAME (Strname_id.make_strname_id ()),
	       ENV(
		       Strenv.empty_strenv,
		       Tyenv.empty_tyenv,
		       Lists.reducel
			 (fn (ve, (name, cell_type)) =>
			    Valenv.add_to_ve(
			      Ident.VAR(Ident.Symbol.find_symbol name),
			      UNBOUND_SCHEME(
				CONSTYPE(
				  [CONSTYPE([], cell_type)],
				  Types.ref_tyname
			      )),
			      ve
			    )
d621 9
a629 56
			  (empty_valenv,
			   [("print_fn_details", Types.bool_tyname),
			    ("maximum_list_size", Types.int_tyname),
			    ("maximum_ref_depth", Types.int_tyname),
			    ("maximum_shape_depth", Types.int_tyname),
			    ("maximum_depth", Types.int_tyname)
			  ]),
			  empty_valenv
	       )
	     ),
	       MLWorks.Internal.Value.cast {
		 maximum_depth =
		   MLWorks.Internal.Value.cast(
		     #maximum_depth user_options
			 ),
		       maximum_shape_depth =
			 MLWorks.Internal.Value.cast(
			   #maximum_shape_depth user_options
			 ),
		       maximum_ref_depth =
			 MLWorks.Internal.Value.cast(
			   #maximum_ref_depth user_options
			 ),
		       maximum_list_size =
			 MLWorks.Internal.Value.cast(
			   #maximum_list_size user_options
			 ),
		       print_fn_details =
			 MLWorks.Internal.Value.cast(
			   #print_fn_details user_options
			 )
		     })
              in
                InterPrint.definitions
		  write
		  (outstream, context, print_options, 0, identifiers);
                context
              end

            val context =
              let
        val (context, identifiers) =
          Incremental.add_structure
	    options
            (context,
	     "Show",
             STR (
	       STRNAME (Strname_id.make_strname_id ()),
               ENV (
		 Strenv.empty_strenv,
		 Tyenv.empty_tyenv,
                 Valenv.add_to_ve(
		    Ident.VAR(Ident.Symbol.find_symbol
			      "structures"),
                    UNBOUND_SCHEME show_type,
                    empty_valenv
d631 37
a667 10
                 empty_valenv
	       )
	     ),
	     (* Prefix "a_" for values, "b_" for exceptions,
	        and "c_" for structures, to ensure correct ordering.
	      *)
             MLWorks.Internal.Value.cast{
		     a_structures =
		       MLWorks.Internal.Value.cast(
			 fn () => show_structures (!current_context)
d669 15
a683 54
		   })
              in
                InterPrint.definitions
		  write
		  (outstream, context, print_options, 0, identifiers);
                context
              end

            val context =
              let
        val (context, identifiers) =
          Incremental.add_structure
	    options
            (context,
	     "Shell",
             STR (
	       STRNAME (Strname_id.make_strname_id ()),
               ENV (
		 Strenv.empty_strenv,
                 Tyenv.add_to_te(
		   Ident.TYCON (Ident.Symbol.find_symbol "context"),
                   TYSTR(ETA_TYFUN context_tyname, empty_valenv),
                   Tyenv.empty_tyenv
		 ), 
                 Valenv.add_to_ve(
		    Ident.VAR(Ident.Symbol.find_symbol
			      "interface_to_windows"),
                    UNBOUND_SCHEME command_handler_type,
                    Valenv.add_to_ve(
		      Ident.VAR(Ident.Symbol.find_symbol "initial_context"),
                      UNBOUND_SCHEME context_constype,
                    Valenv.add_to_ve(
		      Ident.VAR(Ident.Symbol.find_symbol "trace"),
                      alpha_beta_bool,
                    Valenv.add_to_ve(
		      Ident.VAR(Ident.Symbol.find_symbol "untrace"),
                      alpha_beta_bool,
                      empty_valenv
                      )
                     )
		    )
		 ),
                 empty_valenv
	       )
	     ),
	     (* Prefix "a_" for values, "b_" for exceptions,
	        and "c_" for structures, to ensure correct ordering.
	      *)
             MLWorks.Internal.Value.cast{
		     a_initial_context =
		       MLWorks.Internal.Value.cast current_context,
                     a_interface_to_windows =
		       MLWorks.Internal.Value.cast command_handler_fn,
                     a_trace =
d685 2
a686 2
                     MLWorks.Internal.Tracing.add_trace,
                     a_untrace =
d688 87
a774 11
                     MLWorks.Internal.Tracing.remove_trace
		   })
              in
                InterPrint.definitions
		  write
		  (outstream, context, print_options, 0, identifiers);
                context
              end
        in
	  context
	end
d801 8
a808 5
	  maximum_list_size   = ref(#maximum_list_size print_desc),
	  maximum_ref_depth   = ref(#maximum_ref_depth print_desc),
	  maximum_shape_depth = ref(#maximum_shape_depth print_desc),
	  maximum_depth       = ref(#maximum_depth print_desc),
	  print_fn_details    = ref(#print_fn_details print_desc)
d1027 8
a1034 5
	  maximum_list_size   = ref(#maximum_list_size print_desc),
	  maximum_ref_depth   = ref(#maximum_ref_depth print_desc),
	  maximum_shape_depth = ref(#maximum_shape_depth print_desc),
	  maximum_depth       = ref(#maximum_depth print_desc),
	  print_fn_details    = ref(#print_fn_details print_desc)
d1080 1
a1080 1
			    !(#print_fn_details user_options),
d1091 6
d1174 1
a1174 1
			          !(#print_fn_details user_options),
d1185 6
d1210 4
a1213 3
                   UNBOUND_SCHEME (FUNTYPE (Types.int_type,
					    Types.empty_rec_type)),
                   MLWorks.Internal.Value.cast (fn n => raise Exit n))
@


1.22
log
@Added recompile and compile, and some info bug fixes.
@
text
@d11 3
d70 2
a71 1
               sharing Incremental.Info = Ml_Debugger.Info = Incremental.Compiler.Parser.Info
d76 3
a78 1
    structure Lexer = Incremental.Compiler.Parser.Lexer
a79 1
    structure Parser = Incremental.Compiler.Parser
d82 1
a82 1
    structure Info = Incremental.Info
d169 1
a169 1
                    (context, Incremental.Compiler.TOKENSTREAM1 token_stream)
d218 1
a218 1
                                                              compiler_options as Incremental.Compiler.OPTIONS{info_opts,...},
d561 1
a561 1
                                         compiler_options as Incremental.Compiler.OPTIONS{info_opts,...},
d705 1
a705 1
                                 Incremental.Compiler.TOPDEC ("listener input",topdec))
d793 1
a793 1
	       shell_options as {compiler_options as Incremental.Compiler.OPTIONS{info_opts,...},
d848 1
a848 1
                       (context, Incremental.Compiler.TOKENSTREAM1 token_stream))
d1000 1
a1000 1
                                                              compiler_options as Incremental.Compiler.OPTIONS{info_opts,...},
d1046 1
a1046 1
          Incremental.Compiler.OPTIONS
@


1.21
log
@Added completion of name by adding .sml to used files
Added an error message if a use or make fails
@
text
@d11 4
d35 1
d37 1
d56 2
a78 14
    val dummy_stream = Info.Stream.outstream{output = fn s => output(std_out,s),
                                             flush_out = fn () => (),
                                             close_out = fn () => ()}
    val default_options = Info.OPTIONS {error = {outstream = dummy_stream,
                                                 stop = Info.FATAL,
                                                 report = Info.ADVICE,
                                                 worst = ref Info.ADVICE},
                                        information = {outstream = dummy_stream,
                                                       level = 2},
                                        listing = {outstream = dummy_stream,
                                                   level = 2},
                                        diagnostic = {outstream = dummy_stream,
                                                      level = 2}}

d211 5
a215 1
    fun make_shell_structure(context, user_options: user_options, outstream, print_options, options, current_context, write, prompter, action_queue) =
d301 1
a301 1
                      default_options
d346 30
d555 3
a557 1
	  options,
d618 20
d687 1
a687 1
                              default_options
d788 2
a789 1
	       shell_options as {compiler_options,make_options,debugger},
d842 4
a845 2
                      Incremental.add_source options
                      (context, Incremental.Compiler.TOKENSTREAM1 token_stream)
d916 1
a916 1
                        Info.error' default_options (Info.FATAL, Lexer.locate token_stream, message)))
d1025 14
@


1.20
log
@Changed Error structure to Info
@
text
@d11 3
d143 4
a146 3
             handle Incremental.Error (context, _) =>
               (write (outstream, implode ["Error making `", Incremental.FileName.absolute_name filename, "'\n"]);
                (context, []))
d153 5
d173 2
a174 1
                  next (empty_action_queue (action_queue,level+1,write,context,outstream,options,consumer,print_options))
d178 3
a180 1
            handle exn => (close_in stream; raise exn)
d184 1
a184 2
    handle exn => (write(outstream,"Error occurred during a use\n");
                   context)
@


1.19
log
@Added tracing
@
text
@d11 3
d56 1
a56 1

a61 1
    structure Error = Incremental.Error
d66 1
d68 14
d292 1
d625 3
a627 3
                              Parser.parse_incrementally (token_stream,
                                                          !current_pB,
                                                          !current_parser_state)
d675 1
a675 1
                  handle Error.Stop _ =>
d811 1
a811 1
                   | Error.Stop _ => AGAIN
d852 1
a852 2
                        Error.report'
                        (Error.ERROR (Error.FATAL, Lexer.locate token_stream, message))))
d931 1
a931 1
							      compiler_options,
d938 1
d964 4
a967 3
          {debug = true,
           profile = true,
           error_output_level = Error.ADVICE}
a981 1

@


1.18
log
@Added show structure, moved Print structure out of Shell.
@
text
@d11 3
d24 1
d41 1
d49 2
a50 1
                 Valenv.Datatypes
d240 11
d252 6
a257 6
              val debugger_window_type =
                FUNTYPE
                (make_pair(CONSTYPE([],Types.string_tyname),
                           CONSTYPE([string_pair],Types.list_tyname)),
                 Types.empty_rec_type)

d456 6
d463 2
d477 7
a483 1
		       MLWorks.Internal.Value.cast command_handler_fn
d918 1
a918 1
            fun call_debugger (term,e) =
d932 1
a932 1
            (2,fn s => (call_debugger (false,Ml_Debugger.SIGNAL s);
d934 1
a934 1
            f(x) 
d938 1
a938 1
                       (call_debugger (true,Ml_Debugger.EXCEPTION exn);
@


1.17
log
@Added print controls to user-visible values in shell().
@
text
@d10 4
a13 1
 *  $Log$
d174 9
d223 5
d316 2
a317 1

d322 1
a322 1
	     "Shell",
d325 1
a325 6
               ENV (
		 Strenv.add_to_se(
		   Ident.STRID(Ident.Symbol.find_symbol "Print"),
		   STR (
		     STRNAME (Strname_id.make_strname_id ()),
		     ENV(
d348 22
d371 25
a395 2
		     ),
		     Strenv.empty_strenv
d397 30
a448 22
	       c_Print = MLWorks.Internal.Value.cast {
		 maximum_depth =
		   MLWorks.Internal.Value.cast(
		     #maximum_depth user_options
			 ),
		       maximum_shape_depth =
			 MLWorks.Internal.Value.cast(
			   #maximum_shape_depth user_options
			 ),
		       maximum_ref_depth =
			 MLWorks.Internal.Value.cast(
			   #maximum_ref_depth user_options
			 ),
		       maximum_list_size =
			 MLWorks.Internal.Value.cast(
			   #maximum_list_size user_options
			 ),
		       print_fn_details =
			 MLWorks.Internal.Value.cast(
			   #print_fn_details user_options
			 )
		     },
d460 3
@


1.16
log
@Added some handling of interrupts, and united the make and use queues
@
text
@d10 1
a10 1
 *  $log$
d21 1
d100 5
a104 1
    fun empty_action_queue (action_queue,level,write,context,outstream,options,consumer) =
d118 1
a118 1
           InterPrint.definitions write (outstream, context, 0, identifiers);
d137 2
a138 2
                  InterPrint.definitions write (outstream, context, 0, identifiers);
                  next (empty_action_queue (action_queue,level+1,write,context,outstream,options,consumer))
d149 1
d158 8
d171 1
a171 1
    fun make_listener_shell (context,prompter,options) =
d173 221
d395 9
d416 9
d429 1
d471 1
d478 8
a485 8
              | trivial n =
                let
                  val c = MLWorks.String.ordof (line, n-1)
                in
                  (c = ord " " orelse c = ord "\n" orelse
                   c = ord "\t" orelse c = ord "\012") andalso
                  trivial (n-1)
                end
d488 12
a499 2
                  prompt ()
                else
a500 8
                    val input_function =
                      let val buff = ref line
                      in
                        fn _ => (let val out = !buff in buff := ""; out end)
                      end
                    val token_stream = Lexer.mkTokenStream (input_function,"Listener Input")
                    fun loop () =
                      let
d523 1
a523 1
                                InterPrint.definitions write ((), new_context, 0, identifiers);
d529 2
a530 1
                                                   mk_consumer(fn x => write((),x)))
d545 3
a547 9
                        fun cycle () =
                          let
                            val res = loop'()
                          in
                            (#subline prompt_args) := 1 + !(#subline prompt_args);
                            case res of
                              AGAIN => cycle()
                            | STOP x => x
                          end
d549 4
a552 1
                        cycle()
a553 8
                    handle Error.Stop _ =>
                      (current_parser_state := Parser.initial_parser_state;
                       current_pB := Incremental.parser_basis(!current_context);
                       (#subline prompt_args) := 0;
                       ("Error occurred\n" ^ get_current_output()))
                         | DebuggerTrapped => ((#subline prompt_args) := 0;
                                               ("Debugger entered\n" ^ get_current_output()))
                         | Exit n => (get_current_output())
d555 1
a555 1
                    loop()
d557 14
d576 1
a576 1
           current_context := empty_action_queue(action_queue,0,write,!current_context,(),options,mk_consumer consumer);
d593 1
a593 1
            current_context := empty_action_queue(action_queue,0,write,!current_context,(),options',mk_consumer consumer);
d599 1
a599 1
      end
d607 9
a615 1
    fun shell (instream, outstream, shell_options as {compiler_options,make_options,debugger}, context, prompter) =
d618 9
d640 2
a641 1
          interactive_input (Incremental.name context, instream, outstream, prompter)
d650 1
d652 1
a652 1
              else
d664 16
d681 3
a683 1
                    InterPrint.definitions write (outstream, context, 0, identifiers);
d687 2
a688 1
                                        outstream,options,mk_consumer(fn x => (write(outstream,x); ())))
d704 1
a721 83

            val context_tyname = Types.make_tyname(0,false,"context",Types.Datatypes.ABSENT)
            val context_constype = CONSTYPE([],context_tyname)

            fun make_pair (a,b) = 
              Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "1"),
                                   a,
                                   Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "2"),
                                                        b,
                                                        Types.empty_rec_type))

            fun make_quad_type (a,b,c,d) = 
              Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "1"),
                                   a,
                                   Types.add_to_rectype
                                   (Ident.LAB (Symbol.find_symbol "2"),
                                    b,
                                    Types.add_to_rectype
                                    (Ident.LAB (Symbol.find_symbol "3"),
                                     c,
                                     Types.add_to_rectype
                                     (Ident.LAB (Symbol.find_symbol "4"),
                                      d,
                                      Types.empty_rec_type))))

            val string_pair = 
              make_pair(CONSTYPE([],Types.string_tyname),CONSTYPE([],Types.string_tyname))

            val consumer_type = 
              FUNTYPE
              (make_pair(CONSTYPE([],Types.string_tyname),
                         FUNTYPE(Types.string_type,Types.empty_rec_type)),
               Types.string_type)

              val debugger_window_type =
                FUNTYPE
                (make_pair(CONSTYPE([],Types.string_tyname),
                           CONSTYPE([string_pair],Types.list_tyname)),
                 Types.empty_rec_type)

            val command_handler_type = 
              FUNTYPE
              (context_constype,
               FUNTYPE 
               (debugger_window_type,
                make_quad_type(context_constype,
                               FUNTYPE(Types.string_type,Types.string_type),
                               consumer_type,
                               consumer_type)))
                    
            fun command_handler_fn current_context =
              (fn window_fn =>
               let
                 fun debugger_function args f x =
                   let
                     fun call_debugger (term,e) =
                       (Ml_Debugger.ml_debugger
                        (Ml_Debugger.WINDOWING window_fn)
                        args (fn _ => output(std_out,"Shell not defined yet|\n"))
                        e)
                   in
                     MLWorks.Internal.Runtime.Event.signal
                     (2, fn s => (call_debugger (false,Ml_Debugger.SIGNAL s);
                                  prompt_for_return DebuggerTrapped));
                     f(x) 
                     handle DebuggerTrapped => raise DebuggerTrapped
                          | exn => (call_debugger (true,Ml_Debugger.EXCEPTION exn);
                                    raise DebuggerTrapped)
                   end

                 fun copy_options (Incremental.OPTIONS x) =
                   Incremental.OPTIONS
                   {compiler_options = #compiler_options x,
                    make_options = #make_options x,
                    debugger = debugger_function}

                   val interface =
                     make_listener_shell(!current_context,prompter,copy_options options)
               in
                 interface
               end)
              

a727 26
                  (context, "use",
                   UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rec_type)),
                   MLWorks.Internal.Value.cast (fn filename => action_queue := USE(filename) :: !action_queue))
              in
                InterPrint.definitions write (outstream, context, 0, identifiers);
                context
              end

            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options
                  (context, "make",
                   UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rec_type)),
                   MLWorks.Internal.Value.cast
                   (fn filename =>
                    action_queue := MAKE(parse_absolute filename) :: !action_queue))
              in
                InterPrint.definitions write (outstream, context, 0, identifiers);
                context
              end

            val context =
              let
                val (context, identifiers) =
                  Incremental.add_value options
d732 1
a732 1
                    MLWorks.save (filename, fn () => shell (instream, outstream, shell_options, !current_context, prompter))
d737 2
a738 1
                InterPrint.definitions write (outstream, context, 0, identifiers);
d745 30
a774 6
                  Incremental.add_value options
                  (context, "shell",
                   UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.int_type)),
                   MLWorks.Internal.Value.cast
                   (fn name =>
                    shell (instream, outstream, shell_options, Incremental.rename (!current_context, name), prompter)))
d776 2
a777 1
                InterPrint.definitions write (outstream, context, 0, identifiers);
d784 5
a788 3
                  Incremental.add_value options
                  (context, "exit",
                   UNBOUND_SCHEME (FUNTYPE (Types.int_type, Types.empty_rec_type)),
d791 2
a792 1
                InterPrint.definitions write (outstream, context, 0, identifiers);
d797 1
a797 23
              let
                val (context, identifiers) =
                  Incremental.add_structure options
                  (context, "Shell",
                   STR (STRNAME (Strname_id.make_strname_id ()),
                        ENV (Strenv.empty_strenv,
                             Tyenv.add_to_te(Ident.TYCON (Ident.Symbol.find_symbol "context"),
                                             TYSTR(ETA_TYFUN context_tyname,
                                                         empty_valenv),
                                             Tyenv.empty_tyenv), 
                             Valenv.add_to_ve(Ident.VAR(Ident.Symbol.find_symbol "interface_to_windows"),
                                              UNBOUND_SCHEME command_handler_type,
                                              Valenv.add_to_ve(Ident.VAR(Ident.Symbol.find_symbol "initial_context"),
                                                               UNBOUND_SCHEME context_constype,
                                                               empty_valenv)),
                             empty_valenv)),
                   MLWorks.Internal.Value.cast 
                   {initial_context = MLWorks.Internal.Value.cast current_context,
                    interface_to_windows = MLWorks.Internal.Value.cast command_handler_fn})
              in
                InterPrint.definitions write (outstream, context, 0, identifiers);
                context
              end
d808 2
a809 1
          shell (std_in, std_out, options, context, default_prompter)
d811 6
a816 2
        fun debugger_function shell_fn deal_with_this_exception 
          (options as Incremental.OPTIONS{make_options,compiler_options,...},context) f x =
a862 4




@


1.15
log
@Changes to the debugger calling mechanism.
@
text
@d97 1
d99 1
a99 1
    fun empty_make_queue (make_queue,write,context,outstream,options) =
d101 1
a101 1
        val filenames = rev (!make_queue)
d103 1
a103 1
        make_queue := [];
d105 1
a105 1
        (fn (context, filename) =>
d115 24
a138 33
         end)
        (context, filenames)
      end

    fun empty_use_queue (use_queue,level,write,context,outstream,options,consumer) =
      let
        val filenames = rev(!use_queue)
      in
        use_queue := [];
        Lists.reducel
        (fn (context, filename) =>
         let
           val stream = open_in filename
           val _ = consumer(level,filename)
           val token_stream =
             Lexer.mkFileTokenStream (stream, filename)
             
           fun next context =
             if Lexer.eof token_stream then
               (close_in stream; context)
             else
               let
                 val (context, identifiers) =
                   Incremental.add_source options
                   (context, Incremental.Compiler.TOKENSTREAM1 token_stream)
               in
                 InterPrint.definitions write (outstream, context, 0, identifiers);
                 next (empty_use_queue (use_queue,level+1,write,context,outstream,options,consumer))
               end
         in
           next context
           handle exn => (close_in stream; raise exn)
         end)
d151 5
a155 1
              
d185 1
a185 3

        val use_queue = ref ([]  : string list)
        val make_queue = ref ([] : Incremental.FileName.absolute list)
d197 1
a197 1
                   MLWorks.Internal.Value.cast (fn filename => use_queue := filename :: !use_queue))
d209 1
a209 1
                    make_queue := Incremental.FileName.parse_absolute filename :: !make_queue))
d268 5
a272 9
                                empty_use_queue(use_queue,
                                                0,write,
                                                empty_make_queue(make_queue,
                                                                 write,
                                                                 new_context,
                                                                 (),
                                                                 options),
                                                (),options,
                                                mk_consumer(fn x => write((),x)))
d314 2
a315 2
          (use_queue := name :: !use_queue ;
           current_context := empty_use_queue(use_queue,0,write,!current_context,(),options,mk_consumer consumer);
d331 2
a332 3
            make_queue := Incremental.FileName.parse_absolute name :: !make_queue ;
            current_context := empty_make_queue(make_queue,write,
                                                !current_context,(),options');
d340 6
d349 2
a350 3
        val use_queue = ref ([]  : string list)
        val make_queue = ref ([] : Incremental.FileName.absolute list)

d386 4
a389 8
                    empty_use_queue (use_queue,
                                     0,write,
                                     empty_make_queue(make_queue,
                                                      write,
                                                      context,
                                                      outstream,
                                                      options),
                                     outstream,options,mk_consumer(fn x => (write(outstream,x); ())))
d476 16
a491 7
                   (f(x) handle exn =>
                     (Ml_Debugger.ml_debugger
                      (Ml_Debugger.WINDOWING window_fn)
                      args (fn _ => output(std_out,"Shell not defined yet|\n"))
                      (Ml_Debugger.EXCEPTION exn);
                      raise DebuggerTrapped))
                   
d513 1
a513 1
                   MLWorks.Internal.Value.cast (fn filename => use_queue := filename :: !use_queue))
d527 1
a527 1
                    make_queue := Incremental.FileName.parse_absolute filename :: !make_queue))
d614 26
a639 17
          (f(x) 
           handle exn => 
             if deal_with_this_exception exn then
               (Ml_Debugger.ml_debugger 
                Ml_Debugger.TERMINAL
                (options, context)
                (fn context' =>
                 (shell_fn
                  {make_options = make_options,
                   compiler_options = compiler_options,
                   debugger = debugger_function the_shell}
                  context';
                  ()))
                (Ml_Debugger.EXCEPTION exn);
                raise DebuggerTrapped)
             else
               raise exn)
@


1.14
log
@Got exit working, and passed through enough for debugger to bind frame arguments to it
on invoking a sub-shell
@
text
@d486 6
a491 9
                   (f(x) 
                    handle exn => 
                      (MLWorks.Internal.Debugger.call_debugger 
                       (Ml_Debugger.ml_debugger 
                        (Ml_Debugger.WINDOWING window_fn)
                        args
                        (fn _ => output(std_out,"Shell not defined yet|\n")),
                        exn);
                       raise DebuggerTrapped))
d617 15
a631 14
             if deal_with_this_exception exn
               then
                 (MLWorks.Internal.Debugger.call_debugger 
                  (Ml_Debugger.ml_debugger 
                   Ml_Debugger.TERMINAL
                   (options,context)
                   (fn context' => (shell_fn
                                    {make_options=make_options,
                                     compiler_options=compiler_options,
                                     debugger=debugger_function the_shell}
                                    context';())),
                   exn);
                  raise DebuggerTrapped)
             else raise exn)
@


1.13
log
@Added definition of make and use to make-listener
@
text
@d351 1
a351 1
    fun shell (instream, outstream, options, context, prompter) =
d361 6
d485 1
a485 1
                 fun debugger_function context f x =
d491 2
a492 2
                        context 
                        (fn () => output(std_out,"Shell not defined yet|\n")),
d545 1
a545 1
                    MLWorks.save (filename, fn () => shell (instream, outstream, options, !current_context, prompter))
d562 1
a562 1
                    shell (instream, outstream, options, Incremental.rename (!current_context, name), prompter)))
a610 11
     fun debugger_function context f x =
       (f(x) 
        handle exn => 
          (MLWorks.Internal.Debugger.call_debugger 
           (Ml_Debugger.ml_debugger 
            Ml_Debugger.TERMINAL
            context 
            (fn () => output(std_out,"Shell not defined yet|\n")),
            exn);
           raise DebuggerTrapped))

d613 22
a641 1
          Incremental.OPTIONS
d647 1
a647 1
           debugger = debugger_function}
d650 1
a650 1
        shell (std_in, std_out, options, Incremental.initial, default_prompter)
d654 1
@


1.12
log
@Adjusted to set the windowing consumer to the correct function
@
text
@a163 5
        val use_queue = ref ([]  : string list)
        val make_queue = ref ([] : Incremental.FileName.absolute list)

        val current_context = ref context

d189 33
@


1.11
log
@Changed the options to the incremental compiler.
Dealt with Incremental.Error as a result of add_module.
@
text
@d98 1
a98 1
    fun empty_make_queue (make_queue,write,context,outstream,options,consumer) =
a120 4
        fun spaces x =
          if x <= 0
            then ""
          else " " ^ spaces (x-1)
d127 1
a127 1
           val _ = consumer(spaces(2 * level) ^ filename ^ "\n")
d152 9
d193 1
a193 1

d249 6
a254 2
                                                                 write,new_context,(),options,fn x => write((),x)),
                                                (),options,fn x => write((),x))
d297 1
a297 1
           current_context := empty_use_queue(use_queue,0,write,!current_context,(),options,consumer);
d301 17
a317 3
          (make_queue := Incremental.FileName.parse_absolute name :: !make_queue ;
           current_context := empty_make_queue(make_queue,write,!current_context,(),options,consumer);
           "\n" ^ get_current_output())
d361 5
a365 2
                                                      write,context,outstream,options,fn x => (write(outstream,x); ())),
                                     outstream,options,fn x => (write(outstream,x); ()))
@


1.10
log
@More changes to allow spawning of listeners
@
text
@d100 1
a100 1
        val filenames = !make_queue
d107 4
a110 1
             Incremental.add_module options (context, filename, consumer)
d436 1
a436 1
                 fun copy_options(Incremental.OPTIONS x) =
d438 3
a440 4
                   {
                    compiler = #compiler x,
                    debugger = debugger_function
                    }
d564 6
d572 5
a576 3
          {compiler = Incremental.Compiler.OPTIONS {debug = true,
                                                    profile = true,
                                                    error_output_level = Error.ADVICE},
@


1.9
log
@Changes for windowing listener
@
text
@d98 1
a98 4
    val use_queue = ref ([]  : string list)
    val make_queue = ref ([] : Incremental.FileName.absolute list)

    fun empty_make_queue (write,context,outstream,options,consumer) =
d115 1
a115 1
    fun empty_use_queue (level,write,context,outstream,options,consumer) =
d142 1
a142 1
                 next (empty_use_queue (level+1,write,context,outstream,options,consumer))
d155 4
a173 1
        exception Foo;
d238 4
a241 2
                                empty_use_queue(0,write,
                                                empty_make_queue(write,new_context,(),options,fn x => write((),x)),
d285 1
a285 1
           current_context := empty_use_queue(0,write,!current_context,(),options,consumer);
d290 1
a290 1
           current_context := empty_make_queue(write,!current_context,(),options,consumer);
d294 1
a294 1
        (do_line,do_use,do_make)
d299 4
d332 4
a335 2
                    empty_use_queue (0,write,
                                     empty_make_queue(write,context,outstream,options,fn x => (write(outstream,x); ())),
d370 4
a373 1
            val string_pair = 
d375 1
a375 1
                                   CONSTYPE([],Types.string_tyname),
d377 1
a377 1
                                                        CONSTYPE([],Types.string_tyname),
d380 17
d399 9
a407 6
              (Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "1"),
                                    CONSTYPE([],Types.string_tyname),
                                    Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "2"),
                                                         FUNTYPE(Types.string_type,Types.empty_rec_type),
                                                         Types.empty_rec_type)),
              Types.string_type)
d410 8
a417 15
              FUNTYPE 
              (FUNTYPE
               (Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "1"),
                                     CONSTYPE([],Types.string_tyname),
                                     Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "2"),
                                                          CONSTYPE([string_pair],Types.list_tyname),
                                                          Types.empty_rec_type)),
               Types.empty_rec_type),
               Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "1"),
                                    FUNTYPE(Types.string_type,Types.string_type),
                                    Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "2"),
                                                         consumer_type,
                                                         Types.add_to_rectype(Ident.LAB (Symbol.find_symbol "3"),
                                                                              consumer_type,
                                                                              Types.empty_rec_type))))
d419 1
a419 2
            val command_handler_fn =
              MLWorks.Internal.Value.cast 
d439 3
a441 1
                   
d443 1
a443 1
                 make_listener_shell(!current_context,prompter,copy_options options)
a450 13
                
                val (context,identifiers) =
                  Incremental.add_value options
                  (context, "interface_to_windows",
                   UNBOUND_SCHEME command_handler_type,
                   command_handler_fn)
              in
                InterPrint.definitions write (outstream, context, 0, identifiers);
                context
              end
            
            val context =
              let
d525 9
a533 4
                             Tyenv.empty_tyenv, 
                             Valenv.add_to_ve (Ident.VAR (Ident.Symbol.find_symbol "foo"),
                                               UNBOUND_SCHEME (FUNTYPE (Types.empty_rec_type, Types.empty_rec_type)),
                                               empty_valenv),
d535 3
a537 1
                   MLWorks.Internal.Value.cast {foo = fn () => output (std_out, "Foo!\n")})
@


1.8
log
@Incorporated the make system.
Changed the parameter to token stream to take a line number.
@
text
@d52 2
a96 1
        
d98 58
d213 62
a274 32
                      if Lexer.eof token_stream then get_current_output()
                      else
                        let val (pB,new_state) =
                          Parser.parse_incrementally (token_stream,
                                                      !current_pB,
                                                      !current_parser_state)
                        in
                          (current_parser_state := new_state;
                           current_pB := pB;
                           get_current_output())
                        end
                      handle Parser.FoundTopDec(topdec,newpB) =>
                        let
                          val context = !current_context
                          val (new_context, identifiers) =
                            Incremental.add_source options (context, 
                                                            Incremental.Compiler.TOPDEC ("listener input",topdec))
                        in
                          InterPrint.definitions write ((), new_context, 0, identifiers);
                          (#subline prompt_args) := 0;
                          (#topdec prompt_args) := Incremental.topdec new_context;
                          (#name prompt_args) := Incremental.name new_context;
                          current_context := new_context;
                          current_pB := Incremental.parser_basis (new_context);
                          current_parser_state := Parser.initial_parser_state;
                          loop()
                        end
                           | Parser.SyntaxError token =>
                               (current_parser_state := Parser.initial_parser_state;
                                current_pB := Incremental.parser_basis(!current_context);
                                (#subline prompt_args) := 0;
                                "Syntax error at " ^ token ^ "\n" ^ get_current_output())
d276 1
a276 2
                    (#subline prompt_args) := 1 + !(#subline prompt_args);
                    loop ()
a277 6
                handle Error.Stop _ =>
                  (current_parser_state := Parser.initial_parser_state;
                   current_pB := Incremental.parser_basis(!current_context);
                   (#subline prompt_args) := 0;
                   "Error occurred\n" ^ get_current_output())
                     | Exit n => get_current_output()
d279 12
d292 1
a292 1
        do_line
d306 1
a306 3
        val use_queue = ref []

        fun empty_use_queue context =
d308 44
a351 34
            val filenames = !use_queue
          in
            use_queue := [];
            Lists.reducel
            (fn (context, filename) =>
             let
               val stream = open_in filename
               val token_stream =
                 Lexer.mkFileTokenStream (stream, filename)

               fun next context =
                 if Lexer.eof token_stream then
                   (close_in stream; context)
                 else
                   let
                     val (context, identifiers) =
                       Incremental.add_source options
                       (context, Incremental.Compiler.TOKENSTREAM1 token_stream)
                   in
                     InterPrint.definitions write (outstream, context, 0, identifiers);
                     next (empty_use_queue context)
                   end
             in
               next context
               handle exn => (close_in stream; raise exn)
             end)
            (context, filenames)
          end

        val make_queue = ref []

        fun empty_make_queue context =
          let
            val filenames = !make_queue
d353 1
a353 11
            make_queue := [];
            Lists.reducel
            (fn (context, filename) =>
             let
               val (context, identifiers) =
                 Incremental.add_module options (context, filename)
             in
               InterPrint.definitions write (outstream, context, 0, identifiers);
               context
             end)
            (context, filenames)
a355 34
        fun loop () =
          if Lexer.eof token_stream then
            0
          else
            let
              val context = !current_context
            in
              (#subline prompt_parameters) := 0;
              (#topdec prompt_parameters) := Incremental.topdec context;
              (#name prompt_parameters) := Incremental.name context;
              current_context :=
                let
                  val (context, identifiers) =
                    Incremental.add_source options
                    (context, Incremental.Compiler.TOKENSTREAM1 token_stream)
                in
                  InterPrint.definitions write (outstream, context, 0, identifiers);
                  empty_use_queue (empty_make_queue context)
                end;
              loop ()
            end
            handle Exit n => n
                 | Error.Stop _ => loop ()
                 | DebuggerTrapped => loop()
                 | exn =>
                     let
                       val string =
                         MLWorks.Internal.Value.exn_name_string
                         (MLWorks.Internal.Value.exn_name exn)
                     in
                       write (outstream, "Uncaught exception " ^ string ^ "\n");
                       loop ()
                     end

d362 60
d426 1
d429 3
a431 5
                  (context, "command_handler",
                   UNBOUND_SCHEME 
                   (FUNTYPE (Types.empty_rec_type,FUNTYPE(Types.string_type,Types.string_type))),
                   MLWorks.Internal.Value.cast 
                   (fn () => make_listener_shell(!current_context,prompter,options): string -> string))
d436 1
a436 1

d535 1
d555 4
@


1.7
log
@Modified to call debugger
@
text
@d44 1
a44 1
               val default_prompter : {line : int, name : string, topdec : int} -> string
d56 1
a56 1
          {line = ref 0, name = ref "", topdec = ref 0}
d58 1
a58 1
        fun prompt () =
d62 1
a62 1
                val {line, name, topdec} = prompter_arg
d64 1
a64 1
                {line = !line, name = !name, topdec = !topdec}
d84 1
a84 1
                  prompt ()
d86 1
a86 1
                  ((#line prompter_arg) := !(#line prompter_arg)+1;
d100 1
d102 1
a102 1
          {line = ref 0,
d108 1
a108 1
            val {line, name, topdec} = prompt_args
d110 1
a110 1
            prompter{line = !line, name = !name, topdec = !topdec}
d150 1
a150 1
                        fn () => (let val out = !buff in buff := ""; out end)
d173 1
a173 1
                          (#line prompt_args) := 0;
d184 1
a184 1
                                (#line prompt_args) := 0;
d187 1
a187 1
                    (#line prompt_args) := 1 + !(#line prompt_args);
d193 1
a193 1
                   (#line prompt_args) := 0;
d224 1
a224 1
                 Lexer.mkTokenStream (fn () => input (stream, 4096), filename)
d245 19
d271 1
a271 1
              (#line prompt_parameters) := 0;
d281 1
a281 1
                  empty_use_queue context
d306 9
a314 9
              val context =
                let
                  val (context,identifiers) =
                    Incremental.add_value options
                    (context, "command_handler",
                     UNBOUND_SCHEME 
                     (FUNTYPE (Types.empty_rec_type,FUNTYPE(Types.string_type,Types.string_type))),
                     MLWorks.Internal.Value.cast 
                     (fn () => make_listener_shell(!current_context,prompter,options): string -> string))
a319 1

d336 14
d433 1
a433 1
        shell (std_in, std_out, options, Incremental.sml_initial, default_prompter)
@


1.6
log
@Changed add_topdec to add_source of compiler source type.
@
text
@d20 1
d34 1
d42 1
a42 1
               sharing InterPrint.Incremental = Incremental
d51 1
d94 1
a95 1
        
d97 103
d267 1
d286 15
d380 10
d397 1
a397 1
           debugger = fn context => fn x => x}
@


1.5
log
@Added printing of implicit shell functions.
@
text
@d124 3
a126 1
                     val (context, identifiers) = Incremental.add_topdec options (context, token_stream)
d150 3
a152 1
                  val (context, identifiers) = Incremental.add_topdec options (context, token_stream)
@


1.4
log
@Changes related to restructuring of Incremental.
@
text
@d176 10
a185 4
              Incremental.add_value options
              (context, "use",
               UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rec_type)),
               MLWorks.Internal.Value.cast (fn filename => use_queue := filename :: !use_queue))
d188 15
a202 9
              Incremental.add_value options
              (context, "save",
               UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.empty_rec_type)),
               MLWorks.Internal.Value.cast
               (fn filename =>
                MLWorks.save (filename, fn () => shell (instream, outstream, options, !current_context, prompter))
                  handle MLWorks.Save message =>
                    Error.report'
                    (Error.ERROR (Error.FATAL, Lexer.locate token_stream, message))))
d205 12
a216 6
              Incremental.add_value options
              (context, "shell",
               UNBOUND_SCHEME (FUNTYPE (Types.string_type, Types.int_type)),
               MLWorks.Internal.Value.cast
               (fn name =>
                shell (instream, outstream, options, Incremental.rename (!current_context, name), prompter)))
d219 10
a228 4
              Incremental.add_value options
              (context, "exit",
               UNBOUND_SCHEME (FUNTYPE (Types.int_type, Types.empty_rec_type)),
               MLWorks.Internal.Value.cast (fn n => raise Exit n))
d231 16
a246 10
              Incremental.add_structure options
              (context, "Shell",
               STR (STRNAME (Strname_id.make_strname_id ()),
                    ENV (Strenv.empty_strenv,
                         Tyenv.empty_tyenv, 
                         Valenv.add_to_ve (Ident.VAR (Ident.Symbol.find_symbol "foo"),
                                           UNBOUND_SCHEME (FUNTYPE (Types.empty_rec_type, Types.empty_rec_type)),
                                           empty_valenv),
                         empty_valenv)),
               MLWorks.Internal.Value.cast {foo = fn () => output (std_out, "Foo!\n")})
@


1.3
log
@Changed `use' to work properly in nested files.  It still isn't
quite like New Jersey's use though.
Removed use of a .mlrc file temporarily.
@
text
@d46 1
a46 1
    structure Lexer = Incremental.Parser.Lexer
d228 3
a230 3
          {compile_debug = true,
           compile_profile = true,
           error_output_level = Error.ADVICE,
@


1.2
log
@The main() function now discards the module table.
@
text
@d13 1
d32 1
d91 3
d103 2
d107 1
a107 3
        fun write ((), string) = output (outstream, string)

        fun loop () =
d109 1
a109 1
            val queue = !use_queue
d112 6
d119 4
a122 4
            case queue of
              [] => ()
            | list =>
                 current_context :=
d124 5
a128 20
                     fun use (context, []) = context
                       | use (context, filename::rest) =
                         let
                           val (context, identifiers) =
                             Incremental.add_source_file options (context, Io.sml_name filename)
                         in
                           InterPrint.definitions write ((), context, 0, identifiers);
                           use (context, rest)
                         end
                           handle Io message =>
                             Error.report' (Error.ERROR (Error.FATAL, Lexer.locate token_stream, message))
                   in 
                     use (!current_context, rev list)
                   end;

           if Lexer.eof token_stream then
             0
           else
             let
               val context = !current_context
d130 4
a133 12
               (#line prompt_parameters) := 0;
               (#topdec prompt_parameters) := Incremental.topdec context;
               (#name prompt_parameters) := Incremental.name context;
               current_context :=
                 let
                   val (context, identifiers) = Incremental.add_topdec options (context, token_stream)
                 in
                   InterPrint.definitions write ((), context, 0, identifiers);
                   context
                 end;
               loop ()
             end
a134 2
            handle Error.Stop _ => loop ()
                 | Exit n => n
d136 31
a219 25

        current_context :=
          (let
             val context = !current_context
             val mlrc = implode [Unix.home "", "/", ".mlrc"]
           in
             case Unix.mtime mlrc of
               Unix.NOT_EXIST => context
             | _ =>
                 let
                   val (context, identifiers) = Incremental.add_source_file options (!current_context, mlrc)
                 in
                   InterPrint.definitions write ((), context, 0, identifiers);
                   context
                 end
                   handle Error.Stop _ => context
                        | Io message =>
                            (Error.report (Error.ERROR (Error.RECOVERABLE, Error.Location.FILE mlrc, message));
                             context)
           end
             handle Unix.ParseEnviron =>
               (Error.report
                (Error.ERROR (Error.WARNING, Lexer.locate token_stream,
                              "Unable to find HOME directory in environment."));
                context));
@


1.1
log
@Initial revision
@
text
@d241 1
@
