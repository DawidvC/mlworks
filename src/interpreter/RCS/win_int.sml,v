head	1.13;
access;
symbols;
locks; strict;
comment	@ * @;


1.13
date	95.07.21.14.49.06;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	95.07.13.10.36.16;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.07.12.13.25.24;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.06.15.13.24.48;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.06.14.13.09.24;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	95.06.09.16.23.46;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.06.02.14.17.26;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.06.01.11.56.31;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.05.22.10.44.24;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	95.05.02.15.26.34;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.05.01.11.36.31;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	95.03.02.16.01.41;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	95.02.28.15.35.40;	author jont;	state Exp;
branches;
next	;


desc
@new unit
No reason given
@


1.13
log
@Change incremental__ to incremental_
@
text
@(*  ==== RUN THE INTERPRETER ====
 *
 *  Copyright (C) 1995 Harlequin Ltd
 *
 *  Description
 *  -----------
 *  This is the file that starts the interpreter.  It is the last file
 *  loaded into the runtime system in order to create an interpreter image.
 *
 *  Notes
 *  -----
 *  It is a good idea to have your own copy of this file if you are
 *  developing, as you will be able to flip various switches without much
 *  recompilation.
 *
 *  Revision Log
 *  ------------
 *  $Log: win_int.sml,v $
 * Revision 1.12  1995/07/13  10:36:16  matthew
 * Changes to Ml_Debugger
 *
 * Revision 1.11  1995/07/12  13:25:24  jont
 * Add parameter to make_shell_structure to indicate image type (ie tty or motif)
 *
 * Revision 1.10  1995/06/15  13:24:48  daveb
 * Type of Ml_Debugger.ml_debugger has changed.
 *
 * Revision 1.9  1995/06/14  13:09:24  daveb
 * Type of Ml_Debugger.ml_debugger has changed.
 *
 * Revision 1.8  1995/06/09  16:23:46  jont
 * Remove double initialisation
 *
 * Revision 1.7  1995/06/02  14:17:26  nickb
 * Add fatal signal handling.
 *
 * Revision 1.6  1995/06/01  11:56:31  daveb
 * Separated user_options into tool-specific and context-specific parts.
 *
 * Revision 1.5  1995/05/22  10:44:24  jont
 * Bring up to date with latest listener stuff
 *
 * Revision 1.4  1995/05/02  15:26:34  matthew
 * Removing Debugger.script
 *
 * Revision 1.3  1995/05/01  11:36:31  daveb
 * Moved the user context stuff into a separate file from shelltypes.sml.
 *
 * Revision 1.2  1995/03/02  16:01:41  jont
 * General impreovements
 *
 * Revision 1.1  1995/02/28  15:35:40  jont
 * new unit
 * No reason given
 *  
 *)

require "../main/__toplevel";
require "../main/__info";
require "../debugger/__ml_debugger";
require "__shell_types";
require "__user_context";
require "__shell";
require "../main/__user_options";
require "../main/__preferences";
require "../main/__options";
require "__tty_listener";
require "../interpreter/__shell_structure";
require "__incremental";

(*require "../motif/__podium";*)

(* require "__intermake"; InterMake_.Diagnostic.set 1; *)
(* require "../main/__compiler"; Compiler_.Diagnostic.set 2; *)

require "../typechecker/__mod_rules";
require "../typechecker/__scheme";

local

  structure Options = TopLevel_.Options
  structure ShellTypes = ShellTypes_
  structure UserContext = UserContext_
  structure Shell = Shell_
  structure Ml_Debugger = Ml_Debugger_
  structure Incremental = Incremental_
  structure Info = Info_
  structure Module_rules = Module_rules_
  structure Scheme = Scheme_
  structure Options = Options_
  (* This is getting too big *)

  datatype window = WINDOW of int;

  fun default_prompter {name, topdec, line, subline} =
    implode [name, if subline > 0 then ">> " else "> "]

  exception NoDebugger

  val initial_context = ShellStructure_.make_shell_structure true
    (ShellTypes.shell_data_ref,
     Incremental.initial)

  val user_context_options =
    UserOptions_.make_user_context_options Options.default_options

  val _ =
    case user_context_options
    of UserOptions_.USER_CONTEXT_OPTIONS
	 {1={generate_interruptable_code, ...}, ...} =>
      generate_interruptable_code := true
      (* want this on for the interpreter *)

  val _ = UserContext.makeInitialUserContext
	    (initial_context, "Initial", user_context_options)

  (* Argument handling is actually done is the Shell.save function in
   interpreter/_shell_structure.sml.  The reason for this is that 
   main is run when building the motif.img, in the images Makefile.
   The Makefile pipes "Shell.save ..." into the interpreter, and it
   saves an image.  It is this image that the user runs, and that has
   to handle the user's arguments.
   
   An alternative approach would be to call MLWorks.save here.  Unfortunately
   this increases the size of the saved image.  I don't know why.  *)

  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

  val main_loop = env"nt main loop"
  val main_init = env"nt main init"
  val make_window = env"nt create window"
  val callback_add = env"nt add callback"

  val input_chars : string list ref = ref []

  val context_stack : UserContext.user_context list ref = ref [UserContext.getNewInitialContext()]

  val prompter = fn _ => ""

  fun debugger_function f x = f x

  val exit_fn : int -> unit = fn n => raise Shell.Exit n

  val mk_xinterface_fn = fn _ => (fn _ => ())

  val initial_listener = fn _ => 0

  val user_tool_options =
    UserOptions_.make_user_tool_options Options.default_options

  val user_preferences =
    Preferences_.make_user_preferences Preferences_.default_preferences

  val shell_data =
    ShellTypes.SHELL_DATA
     {get_user_context = UserContext.getInitialContext,
      user_options = user_tool_options,
      user_preferences = user_preferences,
      debugger = debugger_function,
      prompter = prompter,
      exit_fn = exit_fn,
      x_running = false,		(* X isn't running yet. *)
      mk_xinterface_fn = mk_xinterface_fn,
      mk_tty_listener = initial_listener}

  val title = "<TTY listener>"

  val (handler, do_prompt) = Shell.shell (shell_data,title)

  fun listener_char(ch : int) =
    let
      val char = chr ch
    in
      if char = "\n" then
	let
	  val chars = !input_chars
	in
          (ShellTypes.with_toplevel_name title
           (fn _ => handler(implode(rev chars)));
	   input_chars := [])
	end
      else
        input_chars := char :: (!input_chars)
    end

(*
  fun loop () =
    (let
       val _ = output_fn(do_prompt())
       val _ = MLWorks.IO.clear_eof std_in
       val line = MLWorks.IO.input_line std_in
     in
       ShellTypes.with_toplevel_name title
       (fn _ => handler line)
     end
     handle
         Interrupt => ([],false)
       | exn as Shell.Exit _ => raise exn
       | ShellTypes.DebuggerTrapped => ([],false)
       | exn =>
           (output(MLWorks.IO.terminal_out,
                   "SYSTEM ERROR: Unexpected exception " ^
                   MLWorks.Internal.Value.exn_name_string (MLWorks.Internal.Value.exn_name exn) ^
                   "\nreached top level -- restarting tty loop\n");
              ([],false));
         loop())
*)

  fun create_listener() =
    let
      val list : window = make_window("Listener")
    in
      callback_add(list, 500 (*Magic number *), listener_char)
    end

  fun create_editor() =
    let
    in
      make_window("Editor")
    end

  val main_loop =
    fn _ =>
      fn _ =>
        (let
	   val main_window : window = main_init();
	 in
           callback_add((main_window, 300 (*Magic number *), create_listener));
           callback_add((main_window, 350 (*Magic number *), create_editor));
           main_loop()
	 end)

  fun main arguments =
    let
    in
      TTYListener_.listener
      (ShellTypes_.LISTENER_ARGS
       {user_context = UserContext.getNewInitialContext(),
	user_options = user_tool_options,
	user_preferences = user_preferences,
	prompter=default_prompter,
	mk_xinterface_fn = main_loop})
    end
in

  (* This is a function for setting the module table to just *)
  (* the pervasive files.  This should be done by setting something *)
  (* pervasive after making the pervasive image *)

  fun last(n,l) =
    let
      fun nthtail (0,l) = l
        | nthtail (_,[]) = []
        | nthtail (n,(a::l)) = nthtail (n-1,l)
      fun scan (l,[]) = l
        | scan ([],l) = [] (* impossible case, but there you go *)
        | scan (a::l,a'::l') = scan (l,l')
    in
      scan (l,nthtail (n,l))
    end

  val _ = MLWorks.Internal.Runtime.modules := last(8,!MLWorks.Internal.Runtime.modules)


(* Note: when this is made to work, need to do something for fatal
 * signals as well. See interpreter.sml or xinterpreter.sml for
 * comparisons. Nick B 1995-06-02 *)

(*
  fun interrupt_function shell_data_ref s = 
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
      val context = ShellTypes.get_current_context shell_data
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.SIGNAL s,
         Ml_Debugger.POSSIBLE ("Return to TopLevel",
                               Ml_Debugger.DO_RAISE Interrupt),
         Ml_Debugger.POSSIBLE ("Continue interrupted code",
                               Ml_Debugger.NORMAL_RETURN))
    end

  fun stack_overflow_function shell_data_ref s = 
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
      val context = ShellTypes.get_current_context shell_data
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.STACK_OVERFLOW,
         Ml_Debugger.POSSIBLE
	   ("Return to TopLevel", Ml_Debugger.DO_RAISE Interrupt),
         Ml_Debugger.POSSIBLE
	   ("Continue with extended stack",
            Ml_Debugger.FUN
	      (fn () =>
		 (MLWorks.Internal.Runtime.StorageManager.interface(40,2);()))))
     end

  val _ =
    MLWorks.Internal.Runtime.Event.stack_overflow_handler
    (stack_overflow_function ShellTypes.shell_data_ref)

  val _ =
    MLWorks.Internal.Runtime.Event.interrupt_handler
    (interrupt_function ShellTypes.shell_data_ref)

  fun break_function (shell_data_ref) s =
    let
      val shell_data as ShellTypes.SHELL_DATA{prompter,
                                              mk_xinterface_fn,
                                              ...} = !shell_data_ref
      val context = ShellTypes.get_current_context shell_data
    in
      Ml_Debugger.ml_debugger 
        (Ml_Debugger.get_debugger_type (),
         ShellTypes.get_current_options shell_data,
         ShellTypes.get_current_preferences shell_data)
        (Ml_Debugger.get_start_frame(),
         Ml_Debugger.BREAK s,
         Ml_Debugger.POSSIBLE ("Return to TopLevel",
                               Ml_Debugger.DO_RAISE Interrupt),
         Ml_Debugger.POSSIBLE ("Continue interrupted code",
                               Ml_Debugger.NORMAL_RETURN))
    end
  
  val _ = MLWorks.Debugger.break_hook := break_function (ShellTypes.shell_data_ref)

  val cast : 'a -> 'b = MLWorks.Internal.Value.cast

  val _ = MLWorks.Dynamic.generalises_ref :=
     (fn (ty,ty') =>
      (Scheme.generalises (cast ty,cast ty'))
      handle Scheme.MisMatch (t,t') => 
        raise MLWorks.Dynamic.Coerce(cast t,cast t'))
        

*)
  val _ = MLWorks.exit (main (MLWorks.OS.arguments ()));
  
end
@


1.12
log
@Changes to Ml_Debugger
@
text
@d19 3
d86 1
a86 1
  structure Incremental = Incremental__
@


1.11
log
@Add parameter to make_shell_structure to indicate image type (ie tty or motif)
@
text
@d19 3
d66 2
d83 1
a83 1
  structure Incremental = Ml_Debugger.Incremental
@


1.10
log
@Type of Ml_Debugger.ml_debugger has changed.
@
text
@d19 3
d92 1
a92 1
  val initial_context = ShellStructure_.make_shell_structure
@


1.9
log
@Type of Ml_Debugger.ml_debugger has changed.
@
text
@d19 3
d269 1
a269 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
d288 1
a288 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
d318 1
a318 2
         ShellTypes.get_current_preferences shell_data,
         fn s => output (std_out, s))
@


1.8
log
@Remove double initialisation
@
text
@d19 3
d264 10
a273 11
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       context)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.SIGNAL s,
       Ml_Debugger.POSSIBLE ("Return to TopLevel",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.POSSIBLE ("Continue interrupted code",
                             Ml_Debugger.NORMAL_RETURN))
d284 13
a296 11
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       context)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.STACK_OVERFLOW,
       Ml_Debugger.POSSIBLE ("Return to TopLevel",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.POSSIBLE ("Continue with extended stack",
                             Ml_Debugger.FUN (fn () => (MLWorks.Internal.Runtime.StorageManager.interface(40,2);()))))
d315 10
a324 11
      (Ml_Debugger.get_debugger_type ())
      (ShellTypes.get_current_options shell_data,
       ShellTypes.get_current_preferences shell_data,
       context)
      (fn context' => (output(std_out,"No shell in break debugger yet\n")))
      (Ml_Debugger.get_start_frame())
      (Ml_Debugger.BREAK s,
       Ml_Debugger.POSSIBLE ("Return to TopLevel",
                             Ml_Debugger.DO_RAISE Interrupt),
       Ml_Debugger.POSSIBLE ("Continue interrupted code",
                             Ml_Debugger.NORMAL_RETURN))
@


1.7
log
@Add fatal signal handling.
@
text
@d19 3
a135 4

  val _ =
    UserContext.makeInitialUserContext
      (initial_context, "MLWorks", user_context_options)
@


1.6
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d19 3
d248 4
@


1.5
log
@Bring up to date with latest listener stuff
@
text
@d19 3
d81 9
a89 1
  val _ = UserContext.makeInitialUserContext(initial_context,"Initial")
d91 3
a114 3
  val user_options =
    UserOptions_.make_user_options(Options.default_options, Preferences_.default_preferences)

d125 10
d137 3
a139 3
     {user_context =
      ref(UserContext.makeInitialUserContext(initial_context,"MLWorks")),
      user_options = user_options,
a215 7
      val user_options =
	UserOptions_.make_user_options
	(Options.default_options, Preferences_.default_preferences)
      val _ = case user_options of
	UserOptions_.USER_OPTIONS{1={generate_interruptable_code, ...}, ...} =>
	  generate_interruptable_code := true
    (* want this on for the interpreter *)
d220 2
a221 1
	user_options = user_options,
@


1.4
log
@Removing Debugger.script
@
text
@d19 3
d116 2
a117 1
     {context_stack = context_stack,
@


1.3
log
@Moved the user context stuff into a separate file from shelltypes.sml.
@
text
@d19 3
a51 2
  val _ = Module_rules_.print_times := false;

a246 1
      []
d267 2
a268 2
                             Ml_Debugger.FUN (fn () => (MLWorks.Internal.Runtime.StorageManager.interface(40,2);())))) []
    end
a296 1
      (!MLWorks.Debugger.script)
d301 1
a301 1
  val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
d305 1
a305 1
      (Scheme.generalises (castit ty,castit ty'))
d307 1
a307 1
        raise MLWorks.Dynamic.Coerce(castit t,castit t'))
@


1.2
log
@General impreovements
@
text
@d19 3
a29 1
require "../debugger/__value_printer";
d32 1
d53 1
d74 1
a74 1
  val _ = ShellTypes.makeInitialUserContext(initial_context,"Initial")
d95 1
a95 1
  val context_stack : ShellTypes.user_context list ref = ref [ShellTypes.getNewInitialContext()]
d200 1
a200 1
       {user_context = ShellTypes.getNewInitialContext(),
@


1.1
log
@new unit
No reason given
@
text
@d18 4
a21 1
 *  $Log$
d30 1
d33 1
d50 1
d56 1
d59 2
d84 99
a182 1
  val main_loop = env "nt main loop"
a193 1
(*
d199 1
a199 3
	mk_xinterface_fn = Podium_.start_x_interface})
*)
      main_loop()
@
