head	1.40;
access;
symbols
	MLW_daveb_inline_1_4_99:1.38.1
	MLWorks_21c0_1999_03_25:1.38
	MLWorks_20c1_1998_08_20:1.38
	MLWorks_20c0_1998_08_04:1.38
	MLWorks_20b2c2_1998_06_19:1.37
	MLWorks_20b2_Windows_1998_06_12:1.37
	MLWorks_20b1c1_1998_05_07:1.35
	MLWorks_20b0_1998_04_07:1.33
	MLWorks_20b0_1998_03_20:1.32
	MLWorks_20m2_1998_02_16:1.29
	MLWorks_20m1_1997_10_23:1.27
	MLWorks_11r1:1.19.1.2.1.1.1
	MLWorks_workspace_97:1.24.2
	MLWorks_dt_wizard:1.24.1
	MLWorks_11c0_1997_09_09:1.19.1.2.1.1
	MLWorks_10r3:1.19.1.2.3
	MLWorks_10r2_551:1.19.1.2.2
	MLWorks_11:1.19.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.19.1.2
	MLWorks_20m0_1997_06_20:1.24
	MLWorks_1_0_r2c2_1997_06_14:1.19.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.19.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.19.1
	MLWorks_BugFix_1997_04_24:1.19
	MLWorks_1_0_r2_Win32_1997_04_11:1.19
	MLWorks_1_0_r2_Unix_1997_04_04:1.19
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.3.1.1
	MLWorks_gui_1996_12_18:1.15.4
	MLWorks_1_0_Win32_1996_12_17:1.15.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.1.1
	MLWorks_1_0_Irix_1996_11_28:1.15.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.2
	MLWorks_1_0_Unix_1996_11_14:1.15.1
	MLWorks_Open_Beta2_1996_10_11:1.12.3
	MLWorks_License_dev:1.12.2
	MLWorks_1_open_beta_1996_09_13:1.12.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.4
	MLWorks_Beta_1996_06_07:1.3
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.3
	MLWorks_Beta_1996_05_31:1.3
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ *  @;


1.40
date	99.05.27.10.33.21;	author johnh;	state Exp;
branches;
next	1.39;

1.39
date	99.05.13.14.00.32;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	98.07.14.09.37.27;	author jkbrook;	state Exp;
branches
	1.38.1.1;
next	1.37;

1.37
date	98.06.08.15.33.15;	author jkbrook;	state Exp;
branches;
next	1.36;

1.36
date	98.06.03.16.29.56;	author mitchell;	state Exp;
branches;
next	1.35;

1.35
date	98.05.01.10.55.09;	author mitchell;	state Exp;
branches;
next	1.34;

1.34
date	98.04.24.11.48.30;	author johnh;	state Exp;
branches;
next	1.33;

1.33
date	98.03.26.12.31.11;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	98.03.18.17.13.48;	author mitchell;	state Exp;
branches;
next	1.31;

1.31
date	98.02.19.19.38.29;	author mitchell;	state Exp;
branches;
next	1.30;

1.30
date	98.02.10.15.38.43;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	98.01.26.18.45.04;	author johnh;	state Exp;
branches;
next	1.28;

1.28
date	97.12.10.10.38.14;	author johnh;	state Exp;
branches;
next	1.27;

1.27
date	97.10.16.11.22.58;	author johnh;	state Exp;
branches;
next	1.26;

1.26
date	97.10.14.12.39.03;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	97.10.06.18.30.49;	author jkbrook;	state Exp;
branches;
next	1.24;

1.24
date	97.05.27.13.48.29;	author johnh;	state Exp;
branches
	1.24.1.1
	1.24.2.1;
next	1.23;

1.23
date	97.05.12.16.31.00;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	97.04.29.15.11.48;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	97.04.24.17.10.48;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	97.04.24.16.56.57;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	97.03.27.14.48.18;	author daveb;	state Exp;
branches
	1.19.1.1;
next	1.18;

1.18
date	97.03.24.16.23.40;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	97.03.20.17.33.34;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	96.12.19.14.42.23;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	96.11.06.12.03.25;	author daveb;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1;
next	1.14;

1.14
date	96.10.30.15.17.18;	author io;	state Exp;
branches;
next	1.13;

1.13
date	96.10.17.12.54.52;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	96.09.04.13.31.11;	author daveb;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1;
next	1.11;

1.11
date	96.09.04.10.48.42;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	96.08.06.09.16.10;	author stephenb;	state Exp;
branches;
next	1.9;

1.9
date	96.07.22.09.30.03;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	96.07.19.14.30.12;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	96.07.12.09.54.53;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	96.07.11.12.04.36;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	96.07.03.13.38.30;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	96.06.24.11.32.10;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	96.05.30.13.19.46;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.12.59.19;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	96.05.20.15.43.20;	author daveb;	state Exp;
branches;
next	;

1.12.1.1
date	96.09.13.11.16.01;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.10.07.16.06.06;	author hope;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	96.10.08.12.21.20;	author jont;	state Exp;
branches;
next	;

1.12.3.1
date	96.10.17.11.24.22;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.11.14.12.49.02;	author hope;	state Exp;
branches
	1.15.1.1.1.1;
next	;

1.15.1.1.1.1
date	96.11.28.15.00.25;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.11.22.18.08.48;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.12.17.17.47.27;	author hope;	state Exp;
branches
	1.15.3.1.1.1;
next	;

1.15.3.1.1.1
date	97.02.24.11.37.11;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.12.18.09.41.27;	author hope;	state Exp;
branches;
next	;

1.19.1.1
date	97.05.12.10.33.54;	author hope;	state Exp;
branches;
next	1.19.1.2;

1.19.1.2
date	97.05.13.15.11.35;	author daveb;	state Exp;
branches
	1.19.1.2.1.1
	1.19.1.2.2.1
	1.19.1.2.3.1;
next	;

1.19.1.2.1.1
date	97.07.28.18.19.00;	author daveb;	state Exp;
branches
	1.19.1.2.1.1.1.1;
next	;

1.19.1.2.1.1.1.1
date	97.10.07.11.44.08;	author jkbrook;	state Exp;
branches;
next	1.19.1.2.1.1.1.2;

1.19.1.2.1.1.1.2
date	97.10.14.16.48.56;	author jkbrook;	state Exp;
branches;
next	;

1.19.1.2.2.1
date	97.09.08.17.12.37;	author daveb;	state Exp;
branches;
next	;

1.19.1.2.3.1
date	97.09.09.14.08.15;	author daveb;	state Exp;
branches;
next	1.19.1.2.3.2;

1.19.1.2.3.2
date	97.10.14.17.34.49;	author jkbrook;	state Exp;
branches;
next	;

1.24.1.1
date	97.09.10.19.23.20;	author brucem;	state Exp;
branches;
next	;

1.24.2.1
date	97.09.11.20.54.23;	author daveb;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	97.11.20.16.58.37;	author daveb;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	97.11.26.11.24.34;	author daveb;	state Exp;
branches;
next	;

1.38.1.1
date	99.04.01.17.56.35;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Separates code for saving image from where it was entangled in _shell_structure.
@


1.40
log
@[Bug #190553]
FIx require statements to fix bootstrap compiler.
@
text
@(*  This module defines functions for saving and restarting an image.
 *
 *  Copyright (C) 1996 Harlequin Ltd
 *
 *  $Log: _save_image.sml,v $
 *  Revision 1.39  1999/05/13  14:00:32  daveb
 *  [Bug #190553]
 *  Replaced use of basis/exit with utils/mlworks_exit.
 *
 *  Revision 1.38  1998/07/14  09:37:27  jkbrook
 *  [Bug #30435]
 *  Remove license-prompting
 *
 *  Revision 1.37  1998/06/08  15:33:15  jkbrook
 *  [Bug #30411]
 *  Get edition info from license if present before printing banner
 *  in tty listener
 *
 *  Revision 1.36  1998/06/03  16:29:56  mitchell
 *  [Bug #70125]
 *  Zap history when saving image
 *
 *  Revision 1.35  1998/05/01  10:55:09  mitchell
 *  [Bug #50071]
 *  Close project when saving guib.img
 *
 *  Revision 1.34  1998/04/24  11:48:30  johnh
 *  [Bug #30229]
 *  Group compiler options to allow more flexibility.
 *
 *  Revision 1.33  1998/03/26  12:31:11  jont
 *  [Bug #30090]
 *  Remove uses of MLWorks.IO
 *
 *  Revision 1.32  1998/03/18  17:13:48  mitchell
 *  [Bug #50062]
 *  Fix context browser so contents persists in saved images, and the basis appears in the initial context for guib
 *
 *  Revision 1.31  1998/02/19  19:38:29  mitchell
 *  [Bug #30349]
 *  Fix to avoid non-unit sequence warnings
 *
 *  Revision 1.30  1998/02/10  15:38:43  jont
 *  [Bug #70065]
 *  Remove uses of MLWorks.IO.messages and use the Messages structure
 *
 *  Revision 1.29  1998/01/26  18:45:04  johnh
 *  [Bug #30071]
 *  Merge in Project Workspace changes.
 *
 *  Revision 1.28  1997/12/10  10:38:14  johnh
 *  [Bug #30185]
 *  Source path not printed - causes main-windows to break and is also inconsistent if
 *  -source-path is specified with a different path.
 *
 *  Revision 1.27  1997/10/16  11:22:58  johnh
 *  [Bug #30284]
 *  Add with_fns.
 *
 *  Revision 1.26  1997/10/14  12:39:03  daveb
 *  [Bug #30283]
 *  Made saveImage clear the user input history before saving the image.
 *
 *  Revision 1.25  1997/10/06  18:30:49  jkbrook
 *  [Bug #30213]
 *  Legal option list printed by invalid-argument error message
 *  should be consistent with those printed by -help
 *
 *  Revision 1.24.2.3  1997/11/26  11:24:34  daveb
 *  [Bug #30071]
 *
 *  Revision 1.24.2.2  1997/11/20  16:58:37  daveb
 *  [Bug #30326]
 *
 *  Revision 1.24.2.1  1997/09/11  20:54:23  daveb
 *  branched from trunk for label MLWorks_workspace_97
 *
 *  Revision 1.24  1997/05/27  13:48:29  johnh
 *  [Bug #20033]
 *  Added -no-banner option.
 *
 *  Revision 1.23  1997/05/12  16:31:00  jont
 *  [Bug #20050]
 *  main/io now exports MLWORKS_IO
 *
 *  Revision 1.22  1997/04/29  15:11:48  matthew
 *  [Bug #20028]
 *  Enlarging scope of with_standard_streams
 *
 *  Revision 1.21  1997/04/24  17:10:48  jont
 *  [Bug #20016]
 *  Fix typo in usage message
 *
 *  Revision 1.20  1997/04/24  16:56:57  jont
 *  [Bug #20016]
 *  Document -silent in usage message
 *
 *  Revision 1.19  1997/03/27  14:48:18  daveb
 *  [Bug #1990]
 *  Version.version_string is now Version.versionString, and a function instead
 *  of a constant.
 *
 *  Revision 1.18  1997/03/24  16:23:40  daveb
 *  [Bug #1966]
 *  Unset update functions for user context options and user preferences before
 *  saving the image, so that the image doesn't access non-existent windows when
 *  it restarts.
 *
 *  Revision 1.17  1997/03/20  17:33:34  matthew
 *  Moved read_dot_mlworks
 *
 *  Revision 1.16  1996/12/19  14:42:23  jont
 *  [Bug #1852]
 *  Include help info that -mono must be first arg
 *
 *  Revision 1.15  1996/11/06  12:03:25  daveb
 *  Revised licensing scheme to allow registration-style licensing.
 *
 *  Revision 1.14  1996/10/30  15:17:18  io
 *  [Bug #1614]
 *  removing toplevel String.
 *
 *  Revision 1.13  1996/10/17  12:54:52  jont
 *  Add license server stuff
 *
 *  Revision 1.12.2.2  1996/10/08  12:21:20  jont
 *  Add call to initialise license
 *
 *  Revision 1.12.2.1  1996/10/07  16:06:06  hope
 *  branched from 1.12
 *
 *  Revision 1.12  1996/09/04  13:31:11  daveb
 *  [Bug #1587]
 *  save_image now expands its filename argument.
 *
 *  Revision 1.11  1996/09/04  10:48:42  jont
 *  [Bug #1393]
 *  Add -mono to help message
 *
 *  Revision 1.10  1996/08/06  09:16:10  stephenb
 *  Replace any use of OldOs.mtime that ignores the time with
 *  with OS.FileSys.access.
 *
 *  Revision 1.9  1996/07/22  09:30:03  jont
 *  Fix problem where -no-init was interpreted as -tty and vice versa.
 *
 *  Revision 1.8  1996/07/19  14:30:12  jont
 *  Add control of compilation message printing
 *
 *  Revision 1.7  1996/07/12  09:54:53  jont
 *  Sort out problems with bad environment variable settings
 *
 *  Revision 1.6  1996/07/11  12:04:36  jont
 *  Add a no-init command line option to prevent spurious reading of .mlworks
 *  and .mlworks_preferences for situations such as the test suite
 *
 *  Revision 1.5  1996/07/03  13:38:30  daveb
 *  Bug 1448/Support Call 35: Added remove_file_info to project and incremental,
 *  and called it from _save_image.
 *
 *  Revision 1.4  1996/06/24  11:32:10  daveb
 *  Replaced Getenv.get_home_dir with Getenv.get_startup_filename and
 *  Getenv.get_preferences_filename.
 *
 *  Revision 1.3  1996/05/30  13:19:46  daveb
 *  The Interrupt exception is no longer at top level.
 *
 *  Revision 1.2  1996/05/22  12:59:19  daveb
 *  Combined the Debugging and Variable Info modes.
 *
 *  Revision 1.1  1996/05/20  15:43:20  daveb
 *  new unit
 *  Separates code for saving image from where it was entangled in _shell_structure.
 *
 *
 *)


require "../basis/list";
require "../utils/mlworks_exit";
require "../utils/getenv";
require "../basis/os";
require "../basis/__text_io";
require "^.utils.__messages";
require "shell_types";
require "user_context";
require "shell_utils";
require "incremental";
require "../main/info";
require "../main/version";
require "../main/mlworks_io";
require "../main/user_options";
require "../main/preferences";
require "../main/proj_file";
require "../main/license";
require "save_image";

functor SaveImage
  (structure Info : INFO
   structure Io : MLWORKS_IO
   structure Getenv : GETENV
   structure OS : OS
   structure Preferences : PREFERENCES
   structure License : LICENSE
   structure UserOptions : USER_OPTIONS
   structure UserContext : USER_CONTEXT
   structure ShellTypes : SHELL_TYPES
   structure Exit : MLWORKS_EXIT
   structure Version : VERSION
   structure ShellUtils : SHELL_UTILS
   structure Incremental : INCREMENTAL
   structure List : LIST
   structure ProjFile : PROJ_FILE

   sharing UserOptions.Options = UserContext.Options = ShellTypes.Options
   sharing type ShellUtils.ShellData = ShellTypes.ShellData
   sharing type Preferences.preferences = UserContext.preferences
   sharing type UserOptions.user_context_options =
                UserContext.user_context_options
   sharing type UserContext.user_context = ShellTypes.user_context
   sharing type UserOptions.user_tool_options = ShellTypes.user_options
   sharing type UserContext.Context = ShellTypes.Context
   sharing type Preferences.user_preferences = ShellTypes.user_preferences
   sharing type Io.Location = Info.Location.T
  ): SAVE_IMAGE =
struct
  type ShellData = ShellTypes.ShellData

  (* with_no_update_functions sets the update function lists of the User
     Context and the User Preferences to empty lists.  If this were not
     done, attempts to set options in a .mlworks file would cause the
     functions to try to update windows that no longer exist, and MLWorks
     would crash.  The Tool Context doesn't need to be cleared in this
     way, as it is always copied when a new tool is created, and so the
     update functions are specific to each tool. *)
  fun with_no_update_functions shell_data f x =
    let
      val UserOptions.USER_CONTEXT_OPTIONS(_, update_ref1) =
        UserContext.get_user_options (ShellTypes.get_user_context shell_data)
      val Preferences.USER_PREFERENCES (_, update_ref2) =
        ShellTypes.get_user_preferences shell_data
      val old_option_fns = !update_ref1
      val old_preference_fns = !update_ref2
      val _ = update_ref1 := [];
      val _ = update_ref2 := []

      val result =
	f x
	handle exn =>
	  (update_ref1 := old_option_fns;
	   update_ref2 := old_preference_fns;
	   raise exn)
    in
      update_ref1 := old_option_fns;
      update_ref2 := old_preference_fns;
      result
    end

  fun update_print_messages(shell_data, b) =
    let
      val UserOptions.USER_CONTEXT_OPTIONS({print_messages, ...}, _) =
        UserContext.get_user_options (ShellTypes.get_user_context shell_data)
    in
      print_messages := b
    end

  fun select_optimizing shell_data =
    let
      val user_context_options =
        UserContext.get_user_options (ShellTypes.get_user_context shell_data)
    in
      UserOptions.select_optimizing user_context_options
    end

  fun select_debugging shell_data =
    let
      val user_context_options =
        UserContext.get_user_options (ShellTypes.get_user_context shell_data)
    in
      UserOptions.select_debugging user_context_options
    end

  fun set_user_preference (f, shell_data) =
    let val Preferences.USER_PREFERENCES (user_preferences, _) =
      ShellTypes.get_user_preferences shell_data
    in
      (f user_preferences) := true
    end

  fun clear_user_preference (f, shell_data) =
    let val Preferences.USER_PREFERENCES (user_preferences, _) =
      ShellTypes.get_user_preferences shell_data
    in
      (f user_preferences) := false
    end


  fun get_mk_xinterface_fn (ShellTypes.SHELL_DATA{mk_xinterface_fn,...}) =
    mk_xinterface_fn

  fun get_x_running (ShellTypes.SHELL_DATA{x_running,...}) = x_running

  val gui_message = "The MLWorks GUI is already running\n"

  fun startGUI has_controlling_tty shell_data =
    if get_x_running shell_data then
      print gui_message
    else
      (get_mk_xinterface_fn shell_data)
      (ShellTypes.get_listener_args shell_data)
      has_controlling_tty

  (* Use the standard streams *)

  fun with_standard_streams f =
    let
      val oldIO = MLWorks.Internal.StandardIO.currentIO()
      val _ = MLWorks.Internal.StandardIO.resetIO();
      val result = (f() handle exn =>
		    (MLWorks.Internal.StandardIO.redirectIO oldIO; raise exn))
    in
      MLWorks.Internal.StandardIO.redirectIO oldIO;
      result
    end

  fun get_mk_tty_listener (ShellTypes.SHELL_DATA{mk_tty_listener,...}) =
    mk_tty_listener

  (*
   * I don't understand why the following uses OS.FileSys.access
   * (previously OldOs.mtime) to determine if the file exists and
   * then calls TextIO.openIn to open the file.  Currently
   * an exception is raised if there is any problem reading the
   * file, but no warning is given if the file cannot be opened!
   * Also the one call to set_preferences doesn't seem to catch
   * the Io exeption - stephenb
   *)
  fun set_preferences (_, false) = ()
    | set_preferences (shell_data as ShellTypes.SHELL_DATA{user_preferences, ...}, _) =
      case Getenv.get_preferences_filename () of
        NONE => ()
      | SOME pathname =>
          if OS.FileSys.access (pathname, []) handle OS.SysErr _ => false then
            let
              val user_options =
                UserContext.get_user_options
                (ShellTypes.get_user_context shell_data)

              val instream = TextIO.openIn pathname
              (* XXXEXCEPTION: should handle Io exception -- unlikely but possible *)

              fun parse2 ([],acc) = implode (rev acc)
                | parse2 (#"\n" ::rest,acc) = implode (rev acc)
                | parse2 (a::rest,acc) = parse2 (rest,a::acc)

              fun parse1 ([],acc) = (implode (rev acc),"")
                | parse1 (#" " ::rest,acc) =
                  (implode (rev acc),parse2 (rest,[]))
                | parse1 (a::rest,acc) = parse1 (rest,a::acc)

              fun loop acc =
                let
                  val line = TextIO.inputLine instream
                in
                  if line = "" then rev acc
                  else loop (parse1 (explode line,[])::acc)
                end

              val items = loop []
                handle
                exn =>
                  (TextIO.closeIn instream;
                   raise exn)
            in
              TextIO.closeIn instream;
              Preferences.set_from_list (user_preferences,items);
              UserOptions.set_from_list (user_options,items)
            end
          else
            ()

  val show_banner = ref true
  fun showBanner () = !show_banner

  local
    fun message s =
    (Messages.output s;
     Messages.output"\n")

    val usage =
" Usage:  mlworks [options]\n" ^
" Options:\n" ^
"   -gui  Start the MLWorks Graphical User Interface directly.  This is the\n" ^
"    default.\n" ^
"   -tty    Start MLWorks in text mode.\n" ^
(*
"   -short-menus\n" ^
"           When running the motif interface, hide advanced and experimental\n" ^
"           features.  This is the default.\n" ^
"   -full-menus\n" ^
"           When running the motif interface, make all features of the interface\n" ^
"           available, including advanced and experimental features.\n" ^
*)
"   -debug-mode\n" ^
"           Start MLWorks with debugging mode on.\n" ^
"   -optimize-mode\n" ^
"           Start MLWorks with optimizing mode on.\n" ^
"   -no-init\n" ^
"           Ignore any .mlworks or .mlworks_preferences files.\n" ^
"   -mono\n" ^
"           Attempt to start for a monochrome display (motif only)\n" ^
"   -silent\n" ^
"           Turn off printing of messages about using, loading or\n" ^
"           compiling files.  Also suppresses the MLWorks prompt.\n" ^
"   -stack n\n" ^
"           Set initial maximum number of stack blocks to n.\n" ^
"   -help   Display this message and exit."
    (* Argument parsing.  The second parameter is the current set of
       arguments, which is modified as the list is traversed. *)
    fun parse set_state (shell_data, arguments) =
      let
        fun parse' ([], r) = r
          | parse' ("-tty" :: t, (_, init)) = parse' (t, (true, init))
          | parse' ("-gui" :: t, (_, init)) = parse' (t, (false, init))
          | parse' ("-no-init" :: t, (tty, _)) = parse' (t, (tty, false))
          | parse' ("-full-menus" :: t, r) =
            (if set_state then
               set_user_preference (#full_menus, shell_data)
             else
               ();
               parse' (t, r))
          | parse' ("-short-menus" :: t, r) =
            (if set_state then
               clear_user_preference (#full_menus, shell_data)
             else
               ();
               parse' (t, r))
          | parse' ("-debug-mode" :: t, r) =
            (if set_state then
               select_debugging shell_data
             else
               ();
               parse' (t, r))
          | parse' ("-optimize-mode" :: t, r) =
            (if set_state then
               select_optimizing shell_data
             else
               ();
               parse' (t, r))
          | parse'("-source-path" :: path :: rest, r) =
            (if set_state then
               Io.set_source_path_from_string
               (path, Info.Location.FILE "Command Line")
             else
               ();
               parse'(rest, r))
          | parse'("-object-path" :: path :: rest, r) =
            (if set_state then
               Io.set_object_path(path, Info.Location.FILE "Command Line")
             else
               ();
               parse'(rest, r))
          | parse'("-pervasive-dir" :: dir :: rest, r) =
            (if set_state then
               Io.set_pervasive_dir (dir, Info.Location.FILE "Command Line")
             else
               ();
               parse'(rest, r))
          | parse'("-silent" :: t, r) =
            (if set_state then
               update_print_messages(shell_data, false)
             else
               ();
               parse'(t, r))
          | parse'("-verbose" :: t, r) =
            (if set_state then
               update_print_messages(shell_data, true)
             else
               ();
               parse'(t, r))
          | parse' ("-help" :: _, r) =
            (message usage;
             ignore(Exit.exit Exit.failure);
             (false, false) (* dummy value *))
	  | parse' ("-no-banner" :: t, r) =
	    (show_banner := false;
	     parse'(t,r))	
          | parse' (s :: t, r) =
            (message
             ("Invalid argument " ^ s ^ ".\n" ^
              "Valid arguments are: -tty -gui -debug-mode -optimize-mode -no-init -mono -silent -stack n -help.");
             ignore(Exit.exit Exit.failure);
             (false, false) (* dummy value *))
      in
        parse'(arguments, (false, true))
      end

    fun make_new_shell_data
      (ShellTypes.SHELL_DATA
       {get_user_context,
        user_options,
        user_preferences,
        prompter,
        debugger,
        profiler,
        exit_fn,
        x_running,
        mk_xinterface_fn,
        mk_tty_listener}) =
      ShellTypes.SHELL_DATA
      {get_user_context = get_user_context,
       user_options = user_options,
       user_preferences = user_preferences,
       prompter = prompter,
       debugger = debugger,
       profiler = profiler,
       exit_fn = exit_fn,
       x_running = false,
       mk_xinterface_fn = mk_xinterface_fn,
       mk_tty_listener = mk_tty_listener}

    fun make_no_prompter_shell_data
      (ShellTypes.SHELL_DATA
       {get_user_context,
        user_options,
        user_preferences,
        prompter,
        debugger,
        profiler,
        exit_fn,
        x_running,
        mk_xinterface_fn,
        mk_tty_listener}) =
      ShellTypes.SHELL_DATA
      {get_user_context = get_user_context,
       user_options = user_options,
       user_preferences = user_preferences,
       prompter = fn _ => "",
       debugger = debugger,
       profiler = profiler,
       exit_fn = exit_fn,
       x_running = false,
       mk_xinterface_fn = mk_xinterface_fn,
       mk_tty_listener = mk_tty_listener}


    fun main (is_a_tty_image, arguments) =
      let
        val shell_data = make_new_shell_data (!ShellTypes.shell_data_ref)

        (* Set things from env *)

	val silent = List.exists (fn "-silent" => true | _ => false) arguments

        val _ =
          let
	    (* Don't print the default source path as this causes main-windows
	     * to break and also will be inconsistent with an user-specified
	     * source path (ie. specified from the command line.
	     *)
            val _ = Io.set_source_path_from_env
              ((Info.Location.FILE "<Initialisation code>"), true)

            val _ = Io.set_pervasive_dir_from_env
              (Info.Location.FILE "<Initialisation code>")
          in
            ()
          end
        handle Info.Stop _ => Exit.exit Exit.failure

        (* Set the preferences before reading the command line args *)
        (* The fact that the option refs modified by this call to
         set_preferences and the option refs modified by parse are in
         fact _one and the same_ is obscure but true (as of now)
         *)

        val (_, init) = parse false (shell_data, arguments)

        val _ = set_preferences(shell_data, init)
        (* XXXEXCEPTION: should handle Io *)

        (* Parse arguments.  Default is gui.  This may override some env stuff *)
        val (tty, _) = parse true (shell_data, arguments)
        val tty = tty orelse is_a_tty_image

	val shell_data =
	  if silent andalso tty then
	    make_no_prompter_shell_data shell_data
	  else
	    shell_data

        val _ =
	  if init then
	    let
	      val ShellTypes.SHELL_DATA {get_user_context,
					 user_options,
					 user_preferences,
					 debugger,
					 ...} = shell_data
	      val error_info = Info.make_default_options ()
	    in
	      ShellUtils.read_dot_mlworks shell_data
	    end
	  else ()

        val _ = ShellTypes.shell_data_ref := shell_data

        val mk_tty_listener = get_mk_tty_listener shell_data

        val listener_args = ShellTypes.get_listener_args shell_data
      in
        if tty then
          (let
              val license_status = License.license License.ttyComplain
              val default_to_free : unit -> unit =
                 MLWorks.Internal.Runtime.environment "license set edition" 
           in
              case license_status of 
                  SOME false => default_to_free ()
                | _ => ()
           end;
            if showBanner() then message (Version.versionString ()) else ();
            mk_tty_listener listener_args)
        else
          (startGUI false shell_data;
           0  (* exit status *))
      end
    handle
    (* Handle eg. interrupts during starting interface *)
    MLWorks.Interrupt => 0

  in
    fun saveImage' (is_a_tty_image, handler_fn) (filename, do_exec_save) =
      let

	val expanded_file =
	  Getenv.expand_home_dir filename

	val save_fn =
          if do_exec_save then
            MLWorks.Internal.execSave
          else
            MLWorks.Internal.save

	fun restart () =
           with_standard_streams
           (fn () => main (is_a_tty_image, MLWorks.arguments ()))

	val shell_data as
	      ShellTypes.SHELL_DATA {get_user_context, ...} =
		!ShellTypes.shell_data_ref

        (* This is just a temporary crude mechanism for detecting when we
           are saving guib.img *)
        fun saving_guib() =
            let val size = size(filename)
             in substring(filename, size - 8, 8) = "guib.img"
                andalso ((size = 8)
                         orelse let val c = substring(filename, size - 9, 1)
                                 in (c = "/" orelse c = "\\") end)
            end
            handle _ => false

      in
	Incremental.remove_file_info ();

        if (saving_guib())        
        then
          (print"Saving guib.img\n";
           UserContext.move_context_history_to_system(get_user_context());
           ProjFile.close_proj())
        else ();

        ignore(
          with_no_update_functions
            shell_data
            (UserContext.with_null_history (get_user_context ()) save_fn)
            (expanded_file, restart))
      end
      handle
        MLWorks.Internal.Save msg => handler_fn msg
      | Getenv.BadHomeName s =>
	  handler_fn ("Invalid home name: " ^ s)

    val save_image_fn = ref saveImage'

    fun add_with_fn withFn =
      let val new_save_fn = withFn (!save_image_fn)
      in
	save_image_fn := new_save_fn
      end

    fun saveImage arg1 arg2 =
      let val save_image = (!save_image_fn)
      in
	save_image_fn := saveImage';
	save_image arg1 arg2 handle exn => (save_image_fn := save_image; raise exn);
	save_image_fn := save_image
      end

  end

end

@


1.39
log
@[Bug #190553]
Replaced use of basis/exit with utils/mlworks_exit.
@
text
@d6 4
d180 1
a180 1
require "mlworks_exit";
@


1.38
log
@[Bug #30435]
Remove license-prompting
@
text
@d6 4
d176 1
a176 1
require "../basis/exit";
d204 1
a204 1
   structure Exit : EXIT
@


1.38.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 *  Revision 1.38  1998/07/14  09:37:27  jkbrook
 *  [Bug #30435]
 *  Remove license-prompting
 *
@


1.37
log
@[Bug #30411]
Get edition info from license if present before printing banner
in tty listener
@
text
@d6 5
d605 9
a613 3
          (ignore(License.license
           {promptUser = License.ttyPromptUser,
            complain = License.ttyComplain});
@


1.36
log
@[Bug #70125]
Zap history when saving image
@
text
@d6 4
d600 1
a600 2
          (if showBanner() then message (Version.versionString ()) else ();
           ignore(License.license
d603 2
a604 1
           mk_tty_listener listener_args)
@


1.35
log
@[Bug #50071]
Close project when saving guib.img
@
text
@d6 4
d654 1
a654 1
            save_fn
@


1.34
log
@[Bug #30229]
Group compiler options to allow more flexibility.
@
text
@d6 4
d173 1
d192 1
d643 2
a644 1
           UserContext.move_context_history_to_system(get_user_context()))
@


1.33
log
@[Bug #30090]
Remove uses of MLWorks.IO
@
text
@d6 4
d240 1
a240 1
  fun select_optimizing (shell_data, b) =
d245 1
a245 1
      UserOptions.select_optimizing (user_context_options, b)
d248 1
a248 1
  fun select_debugging (shell_data, b) =
d253 1
a253 1
      UserOptions.select_debugging (user_context_options, b)
d378 1
a378 1
"           Start MLWorks with debugging mode on and optimizing mode off.\n" ^
d380 1
a380 1
"           Start MLWorks with optimizing mode on and debugging mode off.\n" ^
d413 1
a413 2
               (select_debugging (shell_data, true);
                select_optimizing (shell_data, false))
d419 1
a419 2
               (select_optimizing (shell_data, true);
                select_debugging (shell_data, false))
@


1.32
log
@[Bug #50062]
Fix context browser so contents persists in saved images, and the basis appears in the initial context for guib
@
text
@d6 4
d154 1
d276 1
a276 1
      MLWorks.IO.output (MLWorks.IO.std_out, gui_message)
a281 1

d285 9
a293 9
    MLWorks.IO.with_standard_output
      MLWorks.IO.terminal_out
      (fn () =>
         MLWorks.IO.with_standard_error
           MLWorks.IO.terminal_out
           (fn () =>
              MLWorks.IO.with_standard_input
                MLWorks.IO.terminal_in
                f))
d301 1
a301 1
   * then calls MLWorks.IO.open_in to open the file.  Currently
d318 1
a318 1
              val instream = MLWorks.IO.open_in pathname
d332 1
a332 1
                  val line = MLWorks.IO.input_line instream
d341 1
a341 1
                  (MLWorks.IO.close_in instream;
d344 1
a344 1
              MLWorks.IO.close_in instream;
d600 1
d634 1
a634 1
          (MLWorks.IO.output (MLWorks.IO.std_out, "Saving guib.img\n");
@


1.31
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d6 4
d612 12
d626 12
a637 7
	ignore(with_no_update_functions
	  shell_data
	  (UserContext.with_null_history
	    (get_user_context ())
	    save_fn)
	  (expanded_file, restart));
        ()
@


1.30
log
@[Bug #70065]
Remove uses of MLWorks.IO.messages and use the Messages structure
@
text
@d6 4
d446 1
a446 1
             Exit.exit Exit.failure;
d455 1
a455 1
             Exit.exit Exit.failure;
d577 1
a577 1
           License.license
d579 1
a579 1
            complain = License.ttyComplain};
d610 1
a610 1
	with_no_update_functions
d615 1
a615 1
	  (expanded_file, restart);
@


1.29
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d6 4
d142 1
d206 2
a207 2
	  (update_ref1 := old_option_fns; 
	   update_ref2 := old_preference_fns; 
d210 2
a211 2
      update_ref1 := old_option_fns; 
      update_ref2 := old_preference_fns; 
d286 1
a286 1
  (* 
d344 2
a345 2
    (MLWorks.IO.output(MLWorks.IO.messages, s);
     MLWorks.IO.output(MLWorks.IO.messages, "\n"));
d444 1
a444 1
	  | parse' ("-no-banner" :: t, r) = 
d457 1
a457 1
    fun make_new_shell_data 
d481 1
a481 1
    fun make_no_prompter_shell_data 
d523 1
a523 1
            val _ = Io.set_pervasive_dir_from_env 
d545 2
a546 2
	val shell_data = 
	  if silent andalso tty then 
d551 13
a563 14
        val _ = if init 
                  then 
                    let
                      val ShellTypes.SHELL_DATA {get_user_context,
                                                 user_options,
                                                 user_preferences,
                                                 debugger,
                                                 ...} = shell_data
                      fun output_fn s = MLWorks.IO.output (MLWorks.IO.messages, s);
                      val error_info = Info.make_default_options ()
                    in
                      ShellUtils.read_dot_mlworks shell_data
                    end
                else ()
d616 1
a616 1
      | Getenv.BadHomeName s => 
d621 1
a621 1
    fun add_with_fn withFn = 
d627 2
a628 2
    fun saveImage arg1 arg2 = 
      let val save_image = (!save_image_fn) 
@


1.28
log
@[Bug #30185]
Source path not printed - causes main-windows to break and is also inconsistent if
-source-path is specified with a different path.
@
text
@d6 5
d24 9
a140 1
require "action_queue";
d144 1
a144 1
require "../main/io";
a162 1
   structure ActionQueue : ACTION_QUEUE
a166 1
   sharing ActionQueue.Info = Info
d168 1
a168 2
   sharing type Preferences.preferences = UserContext.preferences =
     ActionQueue.preferences
d171 1
a171 2
   sharing type UserContext.user_context = ShellTypes.user_context = 
     ActionQueue.user_context
a174 1
   sharing type ActionQueue.UserOptions = ShellTypes.user_options
d557 1
a557 12
                      ShellUtils.read_dot_mlworks 
                      (shell_data,
                       fn level =>
                       ActionQueue.do_actions 
                       {user_context = get_user_context (),
                        user_options = user_options,
                        preferences = Preferences.new_preferences (user_preferences),
                        error_info = error_info,
                        debugger = debugger,
                        output_fn = output_fn,
                        monitor_fn = fn s => output_fn ("Make: compiling " ^ s)}
                       handle ActionQueue.Error _ => ())
@


1.27
log
@[Bug #30284]
Add with_fns.
@
text
@d6 4
d503 4
d508 1
a508 1
              ((Info.Location.FILE "<Initialisation code>"), silent)
@


1.26
log
@[Bug #30283]
Made saveImage clear the user input history before saving the image.
@
text
@d6 4
d575 1
d577 1
a577 1
    fun saveImage (is_a_tty_image, handler_fn) (filename, do_exec_save) =
d609 17
@


1.25
log
@[Bug #30213]
Legal option list printed by invalid-argument error message
should be consistent with those printed by -help
@
text
@d6 5
d164 1
a164 1
  (* remove_update_functions sets the update function lists of the User
d171 1
a171 1
  fun remove_update_functions (shell_data) =
d177 11
d189 3
a191 2
      update_ref1 := [];
      update_ref2 := []
d586 4
d592 6
a597 2
	remove_update_functions (!ShellTypes.shell_data_ref);
	save_fn (expanded_file, restart);
@


1.24
log
@[Bug #20033]
Added -no-banner option.
@
text
@d6 4
a330 1
"           Must be the first parameter\n" ^
d334 2
d412 1
a412 1
              "Valid arguments are: -tty -gui -debug-mode -optimize-mode -no-init -help.");
@


1.24.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 *  Revision 1.24  1997/05/27  13:48:29  johnh
 *  [Bug #20033]
 *  Added -no-banner option.
 *
@


1.24.2.2
log
@[Bug #30326]
@
text
@a5 3
 *  Revision 1.24.2.1  1997/09/11  20:54:23  daveb
 *  branched from trunk for label MLWorks_workspace_97
 *
d118 1
a118 1
require "../main/mlworks_io";
@


1.24.2.3
log
@[Bug #30071]
@
text
@a5 3
 *  Revision 1.24.2.2  1997/11/20  16:58:37  daveb
 *  [Bug #30326]
 *
d117 1
d140 1
d145 1
d147 2
a148 1
   sharing type Preferences.preferences = UserContext.preferences
d151 2
a152 1
   sharing type UserContext.user_context = ShellTypes.user_context
d156 1
d522 12
a533 1
                      ShellUtils.read_dot_mlworks shell_data
@


1.24.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 4
 *  Revision 1.24  1997/05/27  13:48:29  johnh
 *  [Bug #20033]
 *  Added -no-banner option.
 *
@


1.23
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d6 4
d103 1
d135 1
d297 2
d330 1
a330 1
"           compiling files.\n" ^
d401 3
d414 1
a414 1
    fun make_new_shell_data
d438 25
d468 3
d474 1
a474 1
              (Info.Location.FILE "<Initialisation code>")
d498 6
d537 1
a537 1
          (message (Version.versionString ());
@


1.22
log
@[Bug #20028]
Enlarging scope of with_standard_streams
@
text
@d6 4
d117 1
a117 1
   structure Io : IO
@


1.21
log
@[Bug #20016]
Fix typo in usage message
@
text
@d6 4
a233 2


d487 9
a495 11
        with_standard_streams
        (fn () =>
         if tty then
           (message (Version.versionString ());
	    License.license
	      {promptUser = License.ttyPromptUser,
	       complain = License.ttyComplain};
            mk_tty_listener listener_args)
         else
           (startGUI false shell_data;
            0  (* exit status *)))
d513 2
a514 1
          main (is_a_tty_image, MLWorks.arguments ())
@


1.20
log
@[Bug #20016]
Document -silent in usage message
@
text
@d6 4
d315 1
a315 1
"           Turn off printing of message about using, loading or\n" ^
@


1.19
log
@[Bug #1990]
Version.version_string is now Version.versionString, and a function instead
of a constant.
@
text
@d6 5
d310 3
@


1.19.1.1
log
@branched from 1.19
@
text
@a5 5
 *  Revision 1.19  1997/03/27  14:48:18  daveb
 *  [Bug #1990]
 *  Version.version_string is now Version.versionString, and a function instead
 *  of a constant.
 *
@


1.19.1.2
log
@[Bug #20028]
Enlarging scope of with_standard_streams.
@
text
@a5 3
 *  Revision 1.19.1.1  1997/05/12  10:33:54  hope
 *  branched from 1.19
 *
d478 2
d488 1
a488 1
            0  (* exit status *))
d506 1
a506 2
          with_standard_streams
          (fn () => main (is_a_tty_image, MLWorks.arguments ()))
@


1.19.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 4
 *  Revision 1.19.1.2  1997/05/13  15:11:35  daveb
 *  [Bug #20028]
 *  Enlarging scope of with_standard_streams.
 *
@


1.19.1.2.3.2
log
@[Bug #30283]
Merging from trunk
Made saveImage clear the user input history before saving the image.
@
text
@a5 3
 *  Revision 1.19.1.2.3.1  1997/09/09  14:08:15  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
d144 1
a144 1
  (* with_no_update_functions sets the update function lists of the User
d151 1
a151 1
  fun with_no_update_functions shell_data f x =
a156 11
      val old_option_fns = !update_ref1
      val old_preference_fns = !update_ref2
      val _ = update_ref1 := [];
      val _ = update_ref2 := []

      val result =
	f x
	handle exn =>
	  (update_ref1 := old_option_fns; 
	   update_ref2 := old_preference_fns; 
	   raise exn)
d158 2
a159 3
      update_ref1 := old_option_fns; 
      update_ref2 := old_preference_fns; 
      result
d511 2
a512 6
           with_standard_streams
           (fn () => main (is_a_tty_image, MLWorks.arguments ()))

	val shell_data as
	      ShellTypes.SHELL_DATA {get_user_context, ...} =
		!ShellTypes.shell_data_ref
d515 2
a516 6
	with_no_update_functions
	  shell_data
	  (UserContext.with_null_history
	    (get_user_context ())
	    save_fn)
	  (expanded_file, restart);
@


1.19.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 4
 *  Revision 1.19.1.2  1997/05/13  15:11:35  daveb
 *  [Bug #20028]
 *  Enlarging scope of with_standard_streams.
 *
@


1.19.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 4
 *  Revision 1.19.1.2  1997/05/13  15:11:35  daveb
 *  [Bug #20028]
 *  Enlarging scope of with_standard_streams.
 *
@


1.19.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 *  Revision 1.19.1.2.1.1  1997/07/28  18:19:00  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.19.1.2.1.1.1.2
log
@[Bug #30283]
Merging from trunk:
Made saveImage clear the user input history before saving the image.
@
text
@a5 3
 *  Revision 1.19.1.2.1.1.1.1  1997/10/07  11:44:08  jkbrook
 *  branched from MLWorks_11 for label MLWorks_11r1
 *
d147 1
a147 1
  (* with_no_update_functions sets the update function lists of the User
d154 1
a154 1
  fun with_no_update_functions shell_data f x =
a159 11
      val old_option_fns = !update_ref1
      val old_preference_fns = !update_ref2
      val _ = update_ref1 := [];
      val _ = update_ref2 := []

      val result =
	f x
	handle exn =>
	  (update_ref1 := old_option_fns; 
	   update_ref2 := old_preference_fns; 
	   raise exn)
d161 2
a162 3
      update_ref1 := old_option_fns; 
      update_ref2 := old_preference_fns; 
      result
d514 2
a515 6
           with_standard_streams
           (fn () => main (is_a_tty_image, MLWorks.arguments ()))

	val shell_data as
	      ShellTypes.SHELL_DATA {get_user_context, ...} =
		!ShellTypes.shell_data_ref
d518 2
a519 6
	with_no_update_functions
	  shell_data
	  (UserContext.with_null_history
	    (get_user_context ())
	    save_fn)
	  (expanded_file, restart);
@


1.18
log
@[Bug #1966]
Unset update functions for user context options and user preferences before
saving the image, so that the image doesn't access non-existent windows when
it restarts.
@
text
@d6 6
d476 1
a476 1
           (message (Version.version_string);
@


1.17
log
@Moved read_dot_mlworks
@
text
@d6 3
d126 18
d486 1
a486 1
	 Getenv.expand_home_dir filename
d498 1
@


1.16
log
@[Bug #1852]
Include help info that -mono must be first arg
@
text
@d6 4
d78 1
d101 1
d106 4
a109 3

   sharing type ActionQueue.ShellData = ShellTypes.ShellData
   sharing type Preferences.preferences = UserContext.preferences
d112 2
a113 1
   sharing type UserContext.user_context = ShellTypes.user_context
d117 1
d414 25
a438 1
        val _ = if init then ActionQueue.read_dot_mlworks shell_data else ()
@


1.15
log
@Revised licensing scheme to allow registration-style licensing.
@
text
@d6 3
d268 1
@


1.15.4.1
log
@branched from 1.15
@
text
@a5 3
 *  Revision 1.15  1996/11/06  12:03:25  daveb
 *  Revised licensing scheme to allow registration-style licensing.
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a5 3
 *  Revision 1.15  1996/11/06  12:03:25  daveb
 *  Revised licensing scheme to allow registration-style licensing.
 *
@


1.15.3.1.1.1
log
@branched from 1.15.3.1
@
text
@a5 3
 *  Revision 1.15.3.1  1996/12/17  17:47:27  hope
 *  branched from 1.15
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a5 3
 *  Revision 1.15  1996/11/06  12:03:25  daveb
 *  Revised licensing scheme to allow registration-style licensing.
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a5 3
 *  Revision 1.15  1996/11/06  12:03:25  daveb
 *  Revised licensing scheme to allow registration-style licensing.
 *
@


1.15.1.1.1.1
log
@branched from 1.15.1.1
@
text
@a5 3
 *  Revision 1.15.1.1  1996/11/14  12:49:02  hope
 *  branched from 1.15
 *
@


1.14
log
@[Bug #1614]
removing toplevel String.
@
text
@d6 4
d78 1
d87 1
d413 3
a415 1
	    MLWorks.Internal.Runtime.environment "start license" ();
@


1.13
log
@Add license server stuff
@
text
@d6 3
d201 2
a202 2
              fun parse2 ([],acc) = String.implode (rev acc)
                | parse2 ("\n"::rest,acc) = String.implode (rev acc)
d205 3
a207 3
              fun parse1 ([],acc) = (String.implode (rev acc),"")
                | parse1 (" "::rest,acc) =
                  (String.implode (rev acc),parse2 (rest,[]))
d215 1
a215 1
                  else loop (parse1 (String.explode line,[])::acc)
@


1.12
log
@[Bug #1587]
save_image now expands its filename argument.
@
text
@d6 10
d404 1
@


1.12.3.1
log
@branched from 1.12
@
text
@a5 4
 *  Revision 1.12  1996/09/04  13:31:11  daveb
 *  [Bug #1587]
 *  save_image now expands its filename argument.
 *
@


1.12.2.1
log
@branched from 1.12
@
text
@a5 4
 *  Revision 1.12  1996/09/04  13:31:11  daveb
 *  [Bug #1587]
 *  save_image now expands its filename argument.
 *
@


1.12.2.2
log
@Add call to initialise license
@
text
@a5 3
 *  Revision 1.12.2.1  1996/10/07  16:06:06  hope
 *  branched from 1.12
 *
a397 1
	    MLWorks.Internal.Runtime.environment "start license" ();
@


1.12.1.1
log
@branched from 1.12
@
text
@a5 4
 *  Revision 1.12  1996/09/04  13:31:11  daveb
 *  [Bug #1587]
 *  save_image now expands its filename argument.
 *
@


1.11
log
@[Bug #1393]
Add -mono to help message
@
text
@d6 4
d404 17
a420 8
      (Incremental.remove_file_info ();
       if do_exec_save then
         MLWorks.Internal.execSave
         (filename, fn () => main (is_a_tty_image, MLWorks.arguments ()))
       else
         MLWorks.Internal.save
         (filename, fn () => main (is_a_tty_image, MLWorks.arguments ()));
         ())
d422 3
a424 1
      MLWorks.Internal.Save msg => handler_fn msg
@


1.10
log
@Replace any use of OldOs.mtime that ignores the time with
with OS.FileSys.access.
@
text
@d6 4
d240 2
@


1.9
log
@Fix problem where -no-init was interpreted as -tty and vice versa.
@
text
@d6 3
d43 1
a43 1
require "../make/old_os";
d59 1
a59 1
   structure OldOs : OLD_OS
d155 13
a167 4
  fun set_preferences
    (_, false) = ()
    | set_preferences
      (shell_data as ShellTypes.SHELL_DATA{user_preferences, ...}, _) =
d169 1
a169 1
	NONE => ()
d171 39
a209 38
	  case OldOs.mtime pathname of
	    OldOs.NOT_EXIST => ()
	  | OldOs.EXISTS _ =>
	      let
		val user_options =
		  UserContext.get_user_options
		  (ShellTypes.get_user_context shell_data)

		val instream = MLWorks.IO.open_in pathname

		fun parse2 ([],acc) = String.implode (rev acc)
		  | parse2 ("\n"::rest,acc) = String.implode (rev acc)
		  | parse2 (a::rest,acc) = parse2 (rest,a::acc)

		fun parse1 ([],acc) = (String.implode (rev acc),"")
		  | parse1 (" "::rest,acc) =
		    (String.implode (rev acc),parse2 (rest,[]))
		  | parse1 (a::rest,acc) = parse1 (rest,a::acc)

		fun loop acc =
		  let
		    val line = MLWorks.IO.input_line instream
		  in
		    if line = "" then rev acc
		    else loop (parse1 (String.explode line,[])::acc)
		  end

		val items =
		  loop []
		  handle
		  exn =>
		    (MLWorks.IO.close_in instream;
		     raise exn)
	      in
		MLWorks.IO.close_in instream;
		Preferences.set_from_list (user_preferences,items);
		UserOptions.set_from_list (user_options,items)
	      end
d242 64
a305 64
	  | parse' ("-tty" :: t, (_, init)) = parse' (t, (true, init))
	  | parse' ("-gui" :: t, (_, init)) = parse' (t, (false, init))
	  | parse' ("-no-init" :: t, (tty, _)) = parse' (t, (tty, false))
	  | parse' ("-full-menus" :: t, r) =
	    (if set_state then
	       set_user_preference (#full_menus, shell_data)
	     else
	       ();
	       parse' (t, r))
	  | parse' ("-short-menus" :: t, r) =
	    (if set_state then
	       clear_user_preference (#full_menus, shell_data)
	     else
	       ();
	       parse' (t, r))
	  | parse' ("-debug-mode" :: t, r) =
	    (if set_state then
	       (select_debugging (shell_data, true);
		select_optimizing (shell_data, false))
	     else
	       ();
	       parse' (t, r))
	  | parse' ("-optimize-mode" :: t, r) =
	    (if set_state then
	       (select_optimizing (shell_data, true);
		select_debugging (shell_data, false))
	     else
	       ();
	       parse' (t, r))
	  | parse'("-source-path" :: path :: rest, r) =
	    (if set_state then
	       Io.set_source_path_from_string
	       (path, Info.Location.FILE "Command Line")
	     else
	       ();
	       parse'(rest, r))
	  | parse'("-object-path" :: path :: rest, r) =
	    (if set_state then
	       Io.set_object_path(path, Info.Location.FILE "Command Line")
	     else
	       ();
	       parse'(rest, r))
	  | parse'("-pervasive-dir" :: dir :: rest, r) =
	    (if set_state then
	       Io.set_pervasive_dir (dir, Info.Location.FILE "Command Line")
	     else
	       ();
	       parse'(rest, r))
	  | parse'("-silent" :: t, r) =
	    (if set_state then
	       update_print_messages(shell_data, false)
	     else
	       ();
	       parse'(t, r))
	  | parse'("-verbose" :: t, r) =
	    (if set_state then
	       update_print_messages(shell_data, true)
	     else
	       ();
	       parse'(t, r))
	  | parse' ("-help" :: _, r) =
	    (message usage;
	     Exit.exit Exit.failure;
	     (false, false) (* dummy value *))
d307 5
a311 5
	    (message
	     ("Invalid argument " ^ s ^ ".\n" ^
	      "Valid arguments are: -tty -gui -debug-mode -optimize-mode -no-init -help.");
	     Exit.exit Exit.failure;
	     (false, false) (* dummy value *))
d319 9
a327 9
	user_options,
	user_preferences,
	prompter,
	debugger,
	profiler,
	exit_fn,
	x_running,
	mk_xinterface_fn,
	mk_tty_listener}) =
d342 1
a342 1
	val shell_data = make_new_shell_data (!ShellTypes.shell_data_ref)
d344 5
a348 5
	(* Set things from env *)
	val _ =
	  let
	    val _ = Io.set_source_path_from_env
	      (Info.Location.FILE "<Initialisation code>")
d350 6
a355 6
	    val _ = Io.set_pervasive_dir_from_env 
	      (Info.Location.FILE "<Initialisation code>")
	  in
	    ()
	  end
	handle Info.Stop _ => Exit.exit Exit.failure
d357 5
a361 5
	(* Set the preferences before reading the command line args *)
	(* The fact that the option refs modified by this call to
	 set_preferences and the option refs modified by parse are in
	 fact _one and the same_ is obscure but true (as of now)
	 *)
d363 1
a363 1
	val (_, init) = parse false (shell_data, arguments)
d365 2
a366 1
	val _ = set_preferences(shell_data, init)
d368 3
a370 3
	(* Parse arguments.  Default is gui.  This may override some env stuff *)
	val (tty, _) = parse true (shell_data, arguments)
	val tty = tty orelse is_a_tty_image
d372 1
a372 1
	val _ = if init then ActionQueue.read_dot_mlworks shell_data else ()
d374 1
a374 1
	val _ = ShellTypes.shell_data_ref := shell_data
d376 1
a376 1
	val mk_tty_listener = get_mk_tty_listener shell_data
d378 1
a378 1
	val listener_args = ShellTypes.get_listener_args shell_data
d380 1
a380 1
	with_standard_streams
d382 6
a387 6
	 if tty then
	   (message (Version.version_string);
	    mk_tty_listener listener_args)
	 else
	   (startGUI false shell_data;
	    0  (* exit status *)))
d397 1
a397 1
	 (filename, fn () => main (is_a_tty_image, MLWorks.arguments ()))
d399 3
a401 3
	 MLWorks.Internal.save
	 (filename, fn () => main (is_a_tty_image, MLWorks.arguments ()));
	 ())
@


1.8
log
@Add control of compilation message printing
@
text
@d6 3
d350 1
a350 1
	val (init, _) = parse false (shell_data, arguments)
d355 1
a355 1
	val (_, tty) = parse true (shell_data, arguments)
@


1.7
log
@Sort out problems with bad environment variable settings
@
text
@d6 3
d78 7
a84 1
  open MLWorks.Option
d200 1
a200 17
    (* Argument parsing.  The second parameter is the current set of
       arguments, which is modified as the list is traversed. *)
    fun get_init arguments =
      let
        fun parse' ([], r) = r
	  | parse' ("-tty" :: t, init) = parse' (t, init)
	  | parse' ("-gui" :: t, init) = parse' (t, init)
	  | parse' ("-no-init" :: t, init) = parse' (t, false)
	  | parse' ("-full-menus" :: t, r) = parse' (t, r)
	  | parse' ("-short-menus" :: t, r) = parse' (t, r)
	  | parse' ("-debug-mode" :: t, r) = parse' (t, r)
	  | parse' ("-optimize-mode" :: t, r) = parse' (t, r)
	  | parse'("-source-path" :: path :: rest, r) = parse'(rest, r)
	  | parse'("-object-path" :: path :: rest, r) = parse'(rest, r)
	  | parse'("-pervasive-dir" :: dir :: rest, r) =  parse'(rest, r)
	  | parse' ("-help" :: _, r) =
	      (message(
d220 4
a223 15
"   -help   Display this message and exit.");
	       Exit.exit Exit.failure;
	       false (* dummy value *))

          | parse' (s :: t, r) =
	      (message
	       ("Invalid argument " ^ s ^ ".\n" ^
		"Valid arguments are: -tty -gui -debug-mode -optimize-mode -no-init -help.");
	       Exit.exit Exit.failure;
	       false (* dummy value *))
      in
        parse' (arguments, true)
      end

    fun parse (shell_data, arguments) =
d226 3
a228 3
	  | parse' ("-tty" :: t, tty) = parse' (t, true)
	  | parse' ("-gui" :: t, tty) = parse' (t, false)
	  | parse' ("-no-init" :: t, r) = parse' (t, r)
d230 4
a233 1
	      (set_user_preference (#full_menus, shell_data);
d236 4
a239 1
	      (clear_user_preference (#full_menus, shell_data);
d242 5
a246 2
	      (select_debugging (shell_data, true);
	       select_optimizing (shell_data, false);
d249 5
a253 2
	      (select_optimizing (shell_data, true);
	       select_debugging (shell_data, false);
d256 5
a260 2
	      (Io.set_source_path_from_string
		 (path, Info.Location.FILE "Command Line");
d263 4
a266 1
	      (Io.set_object_path(path, Info.Location.FILE "Command Line");
d269 4
a272 1
	      (Io.set_pervasive_dir (dir, Info.Location.FILE "Command Line");
d274 16
d291 5
a295 5
	      (message
	       ("Invalid argument " ^ s ^ ".\n" ^
		"Valid arguments are: -tty -gui -debug-mode -optimize-mode -no-init -help.");
	       Exit.exit Exit.failure;
	       false (* dummy value *))
d297 1
a297 1
        parse' (arguments, false)
d300 13
a312 13
  fun make_new_shell_data
        (ShellTypes.SHELL_DATA
           {get_user_context,
	    user_options,
	    user_preferences,
	    prompter,
	    debugger,
	    profiler,
	    exit_fn,
	    x_running,
	    mk_xinterface_fn,
	    mk_tty_listener}) =
    ShellTypes.SHELL_DATA
d324 3
a326 3
  fun main (is_a_tty_image, arguments) =
    let
      val shell_data = make_new_shell_data (!ShellTypes.shell_data_ref)
d328 12
a339 12
      (* Set things from env *)
      val _ =
	let
	  val _ = Io.set_source_path_from_env
	    (Info.Location.FILE "<Initialisation code>")

	  val _ = Io.set_pervasive_dir_from_env 
	    (Info.Location.FILE "<Initialisation code>")
	in
	  ()
	end
      handle Info.Stop _ => Exit.exit Exit.failure
d341 2
a342 2
      (* Set the preferences before reading the command line args *)
      (* The fact that the option refs modified by this call to
d345 1
a345 1
	*)
d347 1
a347 1
      val init = get_init arguments
d349 1
a349 1
      val _ = set_preferences(shell_data, init)
d351 3
a353 2
      (* Parse arguments.  Default is gui.  This may override some env stuff *)
      val tty = parse(shell_data, arguments) orelse is_a_tty_image
d355 1
a355 1
      val _ = if init then ActionQueue.read_dot_mlworks shell_data else ()
d357 1
a357 1
      val _ = ShellTypes.shell_data_ref := shell_data
d359 1
a359 1
      val mk_tty_listener = get_mk_tty_listener shell_data
d361 3
a363 3
      val listener_args = ShellTypes.get_listener_args shell_data
    in
      with_standard_streams
d365 7
a371 7
	    if tty then
	      (message (Version.version_string);
	       mk_tty_listener listener_args)
	    else
	      (startGUI false shell_data;
	       0  (* exit status *)))
    end
d374 1
a374 1
      MLWorks.Interrupt => 0
d380 1
a380 1
           (filename, fn () => main (is_a_tty_image, MLWorks.arguments ()))
d383 4
a386 4
           (filename, fn () => main (is_a_tty_image, MLWorks.arguments ()));
       ())
       handle
	 MLWorks.Internal.Save msg => handler_fn msg
@


1.6
log
@Add a no-init command line option to prevent spurious reading of .mlworks
and .mlworks_preferences for situations such as the test suite
@
text
@d6 4
d310 11
a320 5
      val _ = Io.set_source_path_from_env
		(Info.Location.FILE "<Initialisation code>")

      val _ = Io.set_pervasive_dir_from_env 
		(Info.Location.FILE "<Initialisation code>")
@


1.5
log
@Bug 1448/Support Call 35: Added remove_file_info to project and incremental,
and called it from _save_image.
@
text
@d6 4
d137 44
a180 44
        (shell_data as ShellTypes.SHELL_DATA
           {user_preferences, ...}) =
    case Getenv.get_preferences_filename () of
      NONE => ()
    | SOME pathname =>
        (case OldOs.mtime pathname of
           OldOs.NOT_EXIST => ()
         | OldOs.EXISTS _ =>
             let
               val user_options =
                 UserContext.get_user_options
                   (ShellTypes.get_user_context shell_data)

               val instream = MLWorks.IO.open_in pathname

               fun parse2 ([],acc) = String.implode (rev acc)
                 | parse2 ("\n"::rest,acc) = String.implode (rev acc)
                 | parse2 (a::rest,acc) = parse2 (rest,a::acc)

               fun parse1 ([],acc) = (String.implode (rev acc),"")
                 | parse1 (" "::rest,acc) =
		     (String.implode (rev acc),parse2 (rest,[]))
                 | parse1 (a::rest,acc) = parse1 (rest,a::acc)

               fun loop acc =
                 let
                   val line = MLWorks.IO.input_line instream
                 in
                   if line = "" then rev acc
                   else loop (parse1 (String.explode line,[])::acc)
                 end

               val items =
   	         loop []
 	         handle
  		   exn =>
		     (MLWorks.IO.close_in instream;
		      raise exn)
             in
               MLWorks.IO.close_in instream;
               Preferences.set_from_list (user_preferences,items);
               UserOptions.set_from_list (user_options,items)
             end)

d189 48
d240 3
a242 2
	  | parse' ("-tty" :: t, _) = parse' (t, true)
	  | parse' ("-gui" :: t, _) = parse' (t, false)
a266 23
	  | parse' ("-help" :: _, r) =
	      (message (
" Usage:  mlworks [options]\n" ^
" Options:\n" ^
"   -gui  Start the MLWorks Graphical User Interface directly.  This is the\n" ^
"    default.\n" ^
"   -tty    Start MLWorks in text mode.\n" ^
(*
"   -short-menus\n" ^
"           When running the motif interface, hide advanced and experimental\n" ^
"           features.  This is the default.\n" ^
"   -full-menus\n" ^
"           When running the motif interface, make all features of the interface\n" ^
"           available, including advanced and experimental features.\n" ^
*)
"   -debug-mode\n" ^
"           Start MLWorks with debugging mode on and optimizing mode off.\n" ^
"   -optimize-mode\n" ^
"           Start MLWorks with optimizing mode on and debugging mode off.\n" ^
"   -help   Display this message and exit.");
	       Exit.exit Exit.failure;
	       false (* dummy value *))

d270 1
a270 1
		"Valid arguments are: -tty -gui -debug-mode -optimize-mode -help.");
d317 4
a320 1
      val _ = set_preferences shell_data
d323 1
a323 1
      val tty = parse (shell_data, arguments) orelse is_a_tty_image
d325 1
a325 1
      val _ = ActionQueue.read_dot_mlworks shell_data
@


1.4
log
@Replaced Getenv.get_home_dir with Getenv.get_startup_filename and
Getenv.get_preferences_filename.
@
text
@d6 4
d30 1
d50 1
d313 9
a321 10
    fun saveImage (is_a_tty_image, handler_fn) (filename, false) =
      ((MLWorks.Internal.save
          (filename, fn () => main (is_a_tty_image, MLWorks.arguments ()));
	   ())
       handle
	 MLWorks.Internal.Save msg => handler_fn msg)
    |   saveImage (is_a_tty_image, handler_fn) (filename, true) =
      ((MLWorks.Internal.execSave
          (filename, fn () => main (is_a_tty_image, MLWorks.arguments ()));
	   ())
d323 1
a323 1
         MLWorks.Internal.Save msg => handler_fn msg)
@


1.3
log
@The Interrupt exception is no longer at top level.
@
text
@d6 3
a125 7
  (* moved here from shell_utils *)
  fun preference_file_name () =
    case Getenv.get_home_dir () of
      NONE => NONE
    | SOME dir =>
        SOME (dir ^ "/.mlworks_preferences")

d129 1
a129 1
    case preference_file_name () of
@


1.2
log
@Combined the Debugging and Variable Info modes.
@
text
@d6 3
d309 1
a309 1
      Interrupt => 0
@


1.1
log
@new unit
Separates code for saving image from where it was entangled in _shell_structure.
@
text
@d5 5
a9 1
 *  $Log$
d65 1
a65 1
  fun select_var_info (shell_data, b) =
d70 1
a70 1
      UserOptions.select_var_info (user_context_options, b)
d192 1
a192 1
	      (select_var_info (shell_data, true);
d197 1
a197 1
	       select_var_info (shell_data, false);
@
