head	1.112;
access;
symbols
	MLW_daveb_inline_1_4_99:1.112.1
	MLWorks_21c0_1999_03_25:1.112
	MLWorks_20c1_1998_08_20:1.112
	MLWorks_20c0_1998_08_04:1.112
	MLWorks_20b2c2_1998_06_19:1.112
	MLWorks_20b2_Windows_1998_06_12:1.112
	MLWorks_20b1c1_1998_05_07:1.112
	MLWorks_20b0_1998_04_07:1.111
	MLWorks_20b0_1998_03_20:1.111
	MLWorks_20m2_1998_02_16:1.111
	MLWorks_20m1_1997_10_23:1.108
	MLWorks_11r1:1.103.1.2.1.1.1
	MLWorks_workspace_97:1.107.2
	MLWorks_dt_wizard:1.107.1
	MLWorks_11c0_1997_09_09:1.103.1.2.1.1
	MLWorks_10r3:1.103.1.2.3
	MLWorks_10r2_551:1.103.1.2.2
	MLWorks_11:1.103.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.103.1.2
	MLWorks_20m0_1997_06_20:1.107
	MLWorks_1_0_r2c2_1997_06_14:1.103.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.103.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.103.1
	MLWorks_BugFix_1997_04_24:1.104
	MLWorks_1_0_r2_Win32_1997_04_11:1.103
	MLWorks_1_0_r2_Unix_1997_04_04:1.103
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.102.3.1.1
	MLWorks_gui_1996_12_18:1.102.4
	MLWorks_1_0_Win32_1996_12_17:1.102.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.102.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.102.1.1
	MLWorks_1_0_Irix_1996_11_28:1.102.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.102.2
	MLWorks_1_0_Unix_1996_11_14:1.102.1
	MLWorks_Open_Beta2_1996_10_11:1.101.3
	MLWorks_License_dev:1.101.2
	MLWorks_1_open_beta_1996_09_13:1.101.1
	MLWorks_Open_Beta_1996_08_22:1.101
	MLWorks_Beta_1996_07_02:1.97
	MLWorks_Beta_1996_06_07:1.97
	MLWorks_Beta_1996_06_06:1.97
	MLWorks_Beta_1996_06_05:1.97
	MLWorks_Beta_1996_06_03:1.97
	MLWorks_Beta_1996_05_31:1.97
	MLWorks_Beta_1996_05_30:1.96
	ML_beta_release_12/08/94:1.71
	ML_beta_release_03/08/94:1.71
	ML_revised_beta_release_25/05/94:1.68
	ML_final_beta_release_02/03/94:1.61
	mlworks-28-01-1994:1.57
	Release:1.43
	mlworks-beta-01-09-1993:1.43
	MLWorks-1-0-4-29/01/1993:1.25
	MLWorks-1-0-3-21/12/1992:1.23
	MLWorks-1-0-2-15/12/1992:1.20
	MLWorks-1-0-1-04/12/1992:1.16;
locks; strict;
comment	@ * @;


1.112
date	98.04.22.17.09.07;	author jont;	state Exp;
branches
	1.112.1.1;
next	1.111;

1.111
date	98.01.29.15.00.02;	author johnh;	state Exp;
branches;
next	1.110;

1.110
date	97.11.25.10.30.50;	author jont;	state Exp;
branches;
next	1.109;

1.109
date	97.10.20.17.35.43;	author jont;	state Exp;
branches;
next	1.108;

1.108
date	97.10.10.17.47.27;	author daveb;	state Exp;
branches;
next	1.107;

1.107
date	97.05.28.10.44.56;	author daveb;	state Exp;
branches
	1.107.1.1
	1.107.2.1;
next	1.106;

1.106
date	97.05.12.16.15.18;	author jont;	state Exp;
branches;
next	1.105;

1.105
date	97.05.07.14.51.30;	author jont;	state Exp;
branches;
next	1.104;

1.104
date	97.04.09.16.30.33;	author jont;	state Exp;
branches;
next	1.103;

1.103
date	97.03.21.10.41.53;	author johnh;	state Exp;
branches
	1.103.1.1;
next	1.102;

1.102
date	96.10.30.12.26.57;	author io;	state Exp;
branches
	1.102.1.1
	1.102.2.1
	1.102.3.1
	1.102.4.1;
next	1.101;

1.101
date	96.08.14.11.42.09;	author daveb;	state Exp;
branches
	1.101.1.1
	1.101.2.1
	1.101.3.1;
next	1.100;

1.100
date	96.08.13.16.41.33;	author jont;	state Exp;
branches;
next	1.99;

1.99
date	96.08.06.14.28.44;	author andreww;	state Exp;
branches;
next	1.98;

1.98
date	96.07.19.14.36.23;	author jont;	state Exp;
branches;
next	1.97;

1.97
date	96.05.30.12.55.08;	author daveb;	state Exp;
branches;
next	1.96;

1.96
date	96.05.16.10.34.23;	author daveb;	state Exp;
branches;
next	1.95;

1.95
date	96.05.03.09.15.06;	author daveb;	state Exp;
branches;
next	1.94;

1.94
date	96.05.01.09.43.41;	author jont;	state Exp;
branches;
next	1.93;

1.93
date	96.03.26.13.00.16;	author stephenb;	state Exp;
branches;
next	1.92;

1.92
date	96.03.26.11.49.16;	author daveb;	state Exp;
branches;
next	1.91;

1.91
date	96.03.19.16.20.53;	author daveb;	state Exp;
branches;
next	1.90;

1.90
date	96.03.18.16.09.55;	author daveb;	state Exp;
branches;
next	1.89;

1.89
date	96.03.14.16.17.18;	author daveb;	state Exp;
branches;
next	1.88;

1.88
date	96.03.11.17.30.02;	author daveb;	state Exp;
branches;
next	1.87;

1.87
date	96.03.04.17.16.07;	author daveb;	state Exp;
branches;
next	1.86;

1.86
date	95.12.27.14.55.02;	author jont;	state Exp;
branches;
next	1.85;

1.85
date	95.12.11.16.46.06;	author daveb;	state Exp;
branches;
next	1.84;

1.84
date	95.11.29.14.55.15;	author daveb;	state Exp;
branches;
next	1.83;

1.83
date	95.07.28.16.13.37;	author matthew;	state Exp;
branches;
next	1.82;

1.82
date	95.07.28.12.01.16;	author matthew;	state Exp;
branches;
next	1.81;

1.81
date	95.04.28.15.30.59;	author jont;	state Exp;
branches;
next	1.80;

1.80
date	95.04.20.14.04.16;	author jont;	state Exp;
branches;
next	1.79;

1.79
date	95.03.24.16.24.02;	author matthew;	state Exp;
branches;
next	1.78;

1.78
date	95.02.14.13.26.56;	author matthew;	state Exp;
branches;
next	1.77;

1.77
date	95.01.30.16.08.46;	author daveb;	state Exp;
branches;
next	1.76;

1.76
date	95.01.30.11.26.25;	author matthew;	state Exp;
branches;
next	1.75;

1.75
date	95.01.17.14.55.10;	author daveb;	state Exp;
branches;
next	1.74;

1.74
date	94.12.08.17.53.23;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	94.12.07.11.37.00;	author matthew;	state Exp;
branches;
next	1.72;

1.72
date	94.10.13.15.34.38;	author matthew;	state Exp;
branches;
next	1.71;

1.71
date	94.07.26.10.12.25;	author daveb;	state Exp;
branches;
next	1.70;

1.70
date	94.06.22.15.16.08;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	94.06.21.14.14.29;	author matthew;	state Exp;
branches;
next	1.68;

1.68
date	94.04.13.12.59.18;	author jont;	state Exp;
branches;
next	1.67;

1.67
date	94.04.08.10.01.51;	author jont;	state Exp;
branches;
next	1.66;

1.66
date	94.03.25.17.21.33;	author daveb;	state Exp;
branches;
next	1.65;

1.65
date	94.03.17.17.06.38;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	94.03.16.12.55.59;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	94.03.14.10.48.35;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	94.03.07.14.15.52;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	94.02.22.11.47.59;	author nosa;	state Exp;
branches;
next	1.60;

1.60
date	94.02.08.14.34.08;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	94.02.01.17.00.33;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	94.01.28.16.21.47;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	94.01.26.18.02.05;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	94.01.10.17.02.07;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	94.01.10.14.35.29;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	93.12.23.12.35.24;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	93.12.16.15.04.06;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	93.12.15.15.08.03;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	93.11.18.13.22.04;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	93.11.15.14.09.54;	author nickh;	state Exp;
branches;
next	1.49;

1.49
date	93.11.10.15.35.17;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	93.10.13.16.26.10;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	93.10.06.11.45.45;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	93.09.27.08.34.49;	author nosa;	state Exp;
branches;
next	1.45;

1.45
date	93.09.23.11.23.40;	author nosa;	state Exp;
branches;
next	1.44;

1.44
date	93.09.02.17.08.22;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	93.08.28.17.49.13;	author daveb;	state Exp;
branches
	1.43.1.1;
next	1.42;

1.42
date	93.08.26.11.22.16;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	93.08.25.14.16.45;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	93.08.17.16.53.41;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	93.08.10.11.34.37;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	93.07.30.14.40.27;	author nosa;	state Exp;
branches;
next	1.37;

1.37
date	93.07.29.15.59.19;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	93.06.16.13.17.13;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	93.05.27.09.16.50;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.05.18.15.16.11;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	93.05.14.13.17.12;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	93.05.11.12.58.51;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	93.04.16.15.46.26;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	93.04.02.13.39.31;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.03.11.13.31.23;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.03.09.14.53.49;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.02.24.14.33.03;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	93.02.04.15.29.52;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.01.07.14.30.26;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.01.06.13.59.33;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	92.12.18.11.16.13;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.12.17.17.32.11;	author clive;	state Exp;
branches;
next	1.21;

1.21
date	92.12.16.16.49.43;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.12.10.16.25.49;	author clive;	state Exp;
branches;
next	1.19;

1.19
date	92.12.09.14.03.58;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.12.09.11.00.16;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.12.09.10.39.21;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	92.12.04.13.05.34;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.12.03.12.56.33;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.12.02.17.05.12;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	92.11.30.17.45.05;	author clive;	state Exp;
branches;
next	1.12;

1.12
date	92.11.27.18.02.12;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	92.11.26.12.14.19;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.11.25.17.25.04;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.11.23.16.53.24;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.11.20.15.41.27;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.11.19.14.43.04;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.11.18.18.00.12;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	92.11.17.17.47.43;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	92.11.02.16.28.37;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.10.20.16.31.07;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.10.16.13.57.54;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.10.14.15.26.49;	author richard;	state Exp;
branches;
next	;

1.43.1.1
date	93.08.28.17.49.13;	author jont;	state Exp;
branches;
next	1.43.1.2;

1.43.1.2
date	93.09.01.15.03.26;	author matthew;	state Exp;
branches;
next	;

1.101.1.1
date	96.09.13.11.16.16;	author hope;	state Exp;
branches;
next	;

1.101.2.1
date	96.10.07.16.06.17;	author hope;	state Exp;
branches;
next	;

1.101.3.1
date	96.10.17.11.24.33;	author hope;	state Exp;
branches;
next	;

1.102.1.1
date	96.11.14.12.49.18;	author hope;	state Exp;
branches
	1.102.1.1.1.1;
next	;

1.102.1.1.1.1
date	96.11.28.15.00.35;	author hope;	state Exp;
branches;
next	;

1.102.2.1
date	96.11.22.18.08.59;	author hope;	state Exp;
branches;
next	;

1.102.3.1
date	96.12.17.17.47.37;	author hope;	state Exp;
branches
	1.102.3.1.1.1;
next	;

1.102.3.1.1.1
date	97.02.24.11.37.22;	author hope;	state Exp;
branches;
next	;

1.102.4.1
date	96.12.18.09.41.38;	author hope;	state Exp;
branches;
next	;

1.103.1.1
date	97.05.12.10.34.05;	author hope;	state Exp;
branches;
next	1.103.1.2;

1.103.1.2
date	97.06.10.15.30.05;	author daveb;	state Exp;
branches
	1.103.1.2.1.1
	1.103.1.2.2.1
	1.103.1.2.3.1;
next	;

1.103.1.2.1.1
date	97.07.28.18.19.36;	author daveb;	state Exp;
branches
	1.103.1.2.1.1.1.1;
next	;

1.103.1.2.1.1.1.1
date	97.10.07.11.44.45;	author jkbrook;	state Exp;
branches;
next	;

1.103.1.2.2.1
date	97.09.08.17.13.12;	author daveb;	state Exp;
branches;
next	;

1.103.1.2.3.1
date	97.09.09.14.08.50;	author daveb;	state Exp;
branches;
next	;

1.107.1.1
date	97.09.10.19.24.14;	author brucem;	state Exp;
branches;
next	;

1.107.2.1
date	97.09.11.20.55.00;	author daveb;	state Exp;
branches;
next	1.107.2.2;

1.107.2.2
date	97.09.17.15.52.41;	author daveb;	state Exp;
branches;
next	1.107.2.3;

1.107.2.3
date	97.10.29.11.58.49;	author daveb;	state Exp;
branches;
next	1.107.2.4;

1.107.2.4
date	97.10.29.13.53.34;	author daveb;	state Exp;
branches;
next	1.107.2.5;

1.107.2.5
date	97.11.20.16.58.04;	author daveb;	state Exp;
branches;
next	1.107.2.6;

1.107.2.6
date	97.11.26.15.16.12;	author daveb;	state Exp;
branches;
next	;

1.112.1.1
date	99.04.01.17.56.57;	author daveb;	state Exp;
branches;
next	;


desc
@Make system for the interpreter.
Functor.
@


1.112
log
@[Bug #70091]
removing req_name from consistency info
@
text
@(*  ==== INTERPRETER MAKE SYSTEM ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *
 *  Revision Log
 *  ------------
 *  $Log: _intermake.sml,v $
 * Revision 1.111  1998/01/29  15:00:02  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.110  1997/11/25  10:30:50  jont
 * [Bug #30328]
 * Add environment parameter to decode_type_basis
 * for finding pervasive type names
 *
 * Revision 1.109  1997/10/20  17:35:43  jont
 * [Bug #30089]
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
 * Revision 1.108  1997/10/10  17:47:27  daveb
 * [Bug #20090]
 * Projects now store the time stamps of object files in the loaded info,
 * instead of their modification times.
 *
 * Revision 1.107.2.6  1997/11/26  15:16:12  daveb
 * [Bug #30071]
 *
 * Revision 1.107.2.5  1997/11/20  16:58:04  daveb
 * [Bug #30326]
 *
 * Revision 1.107.2.4  1997/10/29  13:53:34  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
 * Revision 1.107.2.3  1997/10/29  11:58:49  daveb
 * [Bug #20090]
 * Merged from trunk:
 * Projects now store the time stamps of object files in the loaded info,
 * instead of their modification times.
 *
 * Revision 1.107.2.2  1997/09/17  15:52:41  daveb
 * [Bug #30071]
 * Converted build system to project workspace.
 *
 * Revision 1.107.2.1  1997/09/11  20:55:00  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.107  1997/05/28  10:44:56  daveb
 * [Bug #30090]
 * Converted lexer to Basis IO.
 *
 * Revision 1.106  1997/05/12  16:15:18  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
 * Revision 1.105  1997/05/07  14:51:30  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.104  1997/04/09  16:30:33  jont
 * [Bug #2040]
 * Make InterMake.load take an options argument
 *
 * Revision 1.103  1997/03/21  10:41:53  johnh
 * [Bug #1965]
 * Added a comment about an unhandled NotSet exception in commented code.
 *
 * Revision 1.102  1996/10/30  12:26:57  io
 * moving String from toplevel
 *
 * Revision 1.101  1996/08/14  11:42:09  daveb
 * [Bug #1220]
 * Made compile' load an object file if no source file is available.
 *
 * Revision 1.100  1996/08/13  16:41:33  jont
 * [bug: 1543]
 * Sort out problems mixing loadObject and loadSource
 *
 * Revision 1.99  1996/08/06  14:28:44  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_scheme.sml and _types.sml
 *
 * Revision 1.98  1996/07/19  14:36:23  jont
 * Add control of printing of compilation messages
 *
 * Revision 1.97  1996/05/30  12:55:08  daveb
 * The Io exception is no longer at top level.
 *
 * Revision 1.96  1996/05/16  10:34:23  daveb
 * Marked every loaded module not visible, until it is explicitly added to the
 * context by code elsewhere.  (Fixes bug 1337).
 *
 * Revision 1.95  1996/05/03  09:15:06  daveb
 * Removed Interrupted and Error exceptions.
 * The load and load' functions side-effect their project arguments instead
 * of returning an updated value.
 *
 * Revision 1.94  1996/05/01  09:43:41  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.93  1996/03/26  13:00:16  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
 * Revision 1.92  1996/03/26  11:49:16  daveb
 * Removed unnecessary verbosity.
 *
 * Revision 1.91  1996/03/19  16:20:53  daveb
 * Got rid of the "hacked up mini module naming system".
 *
 * Revision 1.90  1996/03/18  16:09:55  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
 * Revision 1.89  1996/03/14  16:17:18  daveb
 * Added get_mo_information (again) and get_src_information.
 * Reduced amount of information stored in projects for loaded units.
 *
 * Revision 1.88  1996/03/11  17:30:02  daveb
 * Changed test for pervasive modules in compile: instead of testing whether
 * the list of preloaded modules is NONE, is uses ModuleId.is_pervasive.
 *
 * Revision 1.87  1996/03/04  17:16:07  daveb
 * Changed information stored in project for loaded compilation units.
 *
 * Revision 1.86  1995/12/27  14:55:02  jont
 * Removing Option in favour of MLWorks.Option
 *
 *  Revision 1.85  1995/12/11  16:46:06  daveb
 *  Now passes debug info around as accumulated info instead of a basis.
 *
 *  Revision 1.84  1995/11/29  14:55:15  daveb
 *  Changed to use projects.
 *
 *  Revision 1.83  1995/07/28  16:13:37  matthew
 *  Improving error message for being unable to find an mo file.
 *
 *  Revision 1.82  1995/07/28  12:01:16  matthew
 *  Improving load_mo errors
 *
 *  Revision 1.81  1995/04/28  15:30:59  jont
 *  New module naming stuff
 *
 *  Revision 1.80  1995/04/20  14:04:16  jont
 *  Change type of decode_type_basis to take a btree
 *
 *  Revision 1.79  1995/03/24  16:24:02  matthew
 *  Change Tyfun_id etc to Stamp
 *
 *  Revision 1.78  1995/02/14  13:26:56  matthew
 *  Changes to Debugger_Types and CompilerOptions
 *
 *  Revision 1.77  1995/01/30  16:08:46  daveb
 *  Replaced UNIX-specific pathname mangling.
 *
 *  Revision 1.76  1995/01/30  11:26:25  matthew
 *  Changes to type of Encapsulate.decode_type_basis
 *
 *  Revision 1.75  1995/01/17  14:55:10  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *
 *  Revision 1.74  1994/12/08  17:53:23  jont
 *  Move OS specific stuff into a system link directory
 *
 *  Revision 1.73  1994/12/07  11:37:00  matthew
 *  Changing uses of cast
 *
 *  Revision 1.72  1994/10/13  15:34:38  matthew
 *  Make NewMap return pervasive option
 *
 *  Revision 1.71  1994/07/26  10:12:25  daveb
 *  Removed code from the results of a load.  The necessary information is
 *  in the module.  This saves 240K of unnecessary pervasive code in the
 *  motif image.  Also removed inter_env component of Result type.
 *
 *  Revision 1.70  1994/06/22  15:16:08  jont
 *  Update debugger information production
 *
 *  Revision 1.69  1994/06/21  14:14:29  matthew
 *  Catch user exceptions raised during Interload.load
 *
 *  Revision 1.68  1994/04/13  12:59:18  jont
 *  Fix require file names in consistency info.
 *  Ensure canonical module names are used in the internal tables,
 *   and placed in saved mo files.
 *
 *  Revision 1.67  1994/04/08  10:01:51  jont
 *  Add original require file names to consistency info.
 *
 *  Revision 1.66  1994/03/25  17:21:33  daveb
 *  Changed make and delete_module to take module ids.
 *
 *  Revision 1.65  1994/03/17  17:06:38  matthew
 *  Changes to the way dependency checking works.
 *
 *  Revision 1.64  1994/03/16  12:55:59  matthew
 *  Changed name of pervasive stream to <Pervasive> (helps with debug info)
 *
 *  Revision 1.63  1994/03/14  10:48:35  matthew
 *  Reinstated load_time in Result
 *  Dependencies also contain load_time value
 *  I don't think it is broken any more.
 *
 *  Revision 1.62  1994/03/07  14:15:52  matthew
 *  Use action_required to determine if recompilation is necessary in function check
 *  rather than the times.
 *
 *  Revision 1.61  1994/02/22  11:47:59  nosa
 *  Deleted compiler option debug_polyvariables in Debugger_Types.INFO;
 *  Debugger environments for Modules Debugger.
 *
 *  Revision 1.60  1994/02/08  14:34:08  matthew
 *  get_mo_file makes an error if the file can't be found
 *  Don't return the file itself and the pervasive library when getting the dependencies
 *
 *  Revision 1.59  1994/02/01  17:00:33  daveb
 *  make now takes a MOdule argument instead of a file name argument.
 *
 *  Revision 1.58  1994/01/28  16:21:47  matthew
 *  Better locations in error messages
 *
 *  Revision 1.57  1994/01/26  18:18:56  matthew
 *  Numerous changes and simplifications:
 *  Removed load_time
 *  Made various accumulators refs within make
 *  Simplified interface to compiler.
 *
 *  Revision 1.56  1994/01/10  17:02:07  matthew
 *  Fixed a non-exhaustive binding.
 *
 *  Revision 1.55  1994/01/10  14:35:29  matthew
 *  Added functions for reading mo type information.
 *  Added functions for writing out type information from interpreter.
 *
 *  Revision 1.54  1993/12/23  12:35:24  daveb
 *  Changed error message for non-existent modules.
 *
 *  Revision 1.53  1993/12/16  15:04:06  daveb
 *  Removed EnvironPrint parameter.
 *
 *  Revision 1.52  1993/12/15  15:08:03  matthew
 *  Renamed Encapsulate.Basistypes to Encapsulate.BasisTypes
 *
 *  Revision 1.51  1993/11/18  13:22:04  jont
 *  Changed to make the consistency information correct when mo files are
 *  saved from the interpreter. Part of ongoing work to make them fully
 *  fledged mo files.
 *
 *  Revision 1.50  1993/11/15  14:09:54  nickh
 *  New pervasive time structure.
 *
 *  Revision 1.49  1993/11/10  15:35:17  daveb
 *  Removed an extraneous parameter from check.
 *
 *  Revision 1.48  1993/10/13  16:26:10  daveb
 *  Ensured __pervasive_library entries in dependency lists are treated as
 *  pervasive.
 *
 *  Revision 1.47  1993/10/06  11:45:45  jont
 *  Added save function for writing out .mo files
 *
 *  Revision 1.46  1993/09/27  08:34:49  nosa
 *  Deleted output message.
 *
 *  Revision 1.45  1993/09/23  11:23:40  nosa
 *  Record compiler option debug_polyvariables in Debugger_Types.INFO
 *  for recompilation purposes.
 *
 *  Revision 1.44  1993/09/02  17:08:22  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.43.1.2  1993/09/01  15:03:26  matthew
 *  Added with_debug_information and current_debug_information to
 *  control global debug information.
 *
 *  Revision 1.43  1993/08/28  17:49:13  daveb
 *  FileName.find_sml now takes a filename cache.
 *
 *  Revision 1.42  1993/08/26  11:22:16  daveb
 *  FileName.find_file has been replaced with FileName.find_sml.
 *
 *  Revision 1.41  1993/08/25  14:16:45  daveb
 *  ModuleId.from_string now takes a location parameter.
 *  Io.get_pervasive_dir can raise Io.NotSet.
 *
 *  Revision 1.40  1993/08/17  16:53:41  daveb
 *  Major changes: to use ModuleIds and search path.
 *
 *  Revision 1.39  1993/08/10  11:34:37  matthew
 *  Added missing Interrupt handlers.
 *
 *  Revision 1.38  1993/07/30  14:40:27  nosa
 *  structure Option.
 *
 *  Revision 1.37  1993/07/29  15:59:19  matthew
 *  Changed some unknown locations to file locations
 *  Added Interrupted exception to indicate if a make was interrupted.
 *
 *  Revision 1.36  1993/06/16  13:17:13  matthew
 *  delete_module no longer generates error when module not in table.
 *
 *  Revision 1.35  1993/05/27  09:16:50  matthew
 *  Use full filename in making tokenstream & thence in locations
 *
 *  Revision 1.34  1993/05/18  15:16:11  jont
 *  Removed integer parameter
 *
 *  Revision 1.33  1993/05/14  13:17:12  jont
 *  Implemented make -n functionality
 *
 *  Revision 1.32  1993/05/11  12:58:51  matthew
 *  Added error_list to Error exception
 *
 *  Revision 1.31  1993/04/16  15:46:26  matthew
 *  error list field added to Info.Stop
 *
 *  Revision 1.30  1993/04/02  13:39:31  matthew
 *  Signature changes
 *
 *  Revision 1.29  1993/03/11  13:31:23  matthew
 *  Signature revisions
 *
 *  Revision 1.28  1993/03/09  14:53:49  matthew
 *  Options & Info changes
 *
 *  Revision 1.27  1993/02/24  14:33:03  daveb
 *  Changed type of name_monitor field; indenting now done in this file.
 *
 *  Revision 1.26  1993/02/04  15:29:52  matthew
 *  Substructure changes.
 *
 *  Revision 1.25  1993/01/07  14:30:26  matthew
 *  Put in some simple checks for circularity of requires.  Checks
 *  are done at the start of up_to_date and compile.  Both of these
 *   may not be necessary.
 *
 *  Revision 1.24  1993/01/06  13:59:33  matthew
 *  Changed check on loading time to be <= rather than <
 *
 *  Revision 1.23  1992/12/18  11:16:13  clive
 *  We also pass the current module forward for the source_displayer
 *
 *  Revision 1.22  1992/12/17  17:32:11  clive
 *  Changed debug info to have only module name - needed to pass module table through to window stuff
 *
 *  Revision 1.21  1992/12/16  16:49:43  clive
 *  Keep the debug information up to date during a load
 *
 *  Revision 1.20  1992/12/10  16:25:49  clive
 *  If Interrupt is hit, the partially updated module table is returned
 *  so that work does not have to be re-done later
 *
 *  Revision 1.19  1992/12/09  14:03:58  clive
 *  Changes to reflect lower level signature changes
 *
 *  Revision 1.18  1992/12/09  11:00:16  clive
 *  Added find_module for the source_displayer
 *
 *  Revision 1.17  1992/12/09  10:39:21  daveb
 *  Fixed sharing constraint to match new constraint in result signature.
 *
 *  Revision 1.16  1992/12/04  13:05:34  richard
 *  Make now checks the preloaded module list before attempting to load
 *  the results of a compilation.
 *
 *  Revision 1.15  1992/12/03  12:56:33  clive
 *  Added the load_time slot to the result
 *
 *  Revision 1.14  1992/12/02  17:05:12  daveb
 *  Changes to propagate compiler options as parameters instead of references.
 *
 *  Revision 1.13  1992/11/30  17:45:05  clive
 *  Propgate an up-to-date environment in case the make breaks - this might
 *  be rather space inefficient
 *
 *  Revision 1.12  1992/11/27  18:02:12  daveb
 *  Changes to make show_id_class and show_eq_info part of Info structure
 *  instead of references.
 *
 *  Revision 1.11  1992/11/26  12:14:19  clive
 *  Keeps an up-to-date compiler_basis in case the debugger needs it
 *
 *  Revision 1.10  1992/11/25  17:25:04  matthew
 *  Change to error message.
 *
 *  Revision 1.9  1992/11/23  16:53:24  clive
 *  Started working on load dependencies between file - if the compilation options change,
 *  then we do not need to recompile files above the given file - we simply need to
 *  re-load them.
 *  Propagated debug information to get it up to date when the debugger could be called
 *
 *  Revision 1.8  1992/11/20  15:41:27  jont
 *  Modified sharing constraints to remove superfluous structures
 *
 *  Revision 1.7  1992/11/19  14:43:04  clive
 *  Propogated debugging information all over the shop
 *
 *  Revision 1.6  1992/11/18  18:00:12  matthew
 *  More Error -> Info revision
 *
 *  Revision 1.5  1992/11/17  17:47:43  matthew
 *  Changed Error structure to Info
 *
 *  Revision 1.4  1992/11/02  16:28:37  richard
 *  Changes to pervasives and representation of time.
 *
 *  Revision 1.3  1992/10/20  16:31:07  richard
 *  Introduced make options as distinct from compiler options.
 *  Added a name monitor to watch the progress of compilations.
 *  Changed the way the require function works in order to return a
 *  partially complete module table if an error occurs.
 *
 *  Revision 1.2  1992/10/16  13:57:54  clive
 *  Changes for windowing listener
 *
 *  Revision 1.1  1992/10/14  15:26:49  richard
 *  Initial revision
 *
 *)

require "../basis/__text_io";
(* Require this structure to avoid clashes with the IO signature. *)
require "../basis/__io";
require "../system/__time";

require "../basics/module_id";
require "../main/project";
require "../utils/lists";
require "../utils/diagnostic";
require "../typechecker/basis";
require "../typechecker/stamp";
require "../main/compiler";
require "../main/mlworks_io";
require "../main/encapsulate";
require "../utils/crash";
require "../lexer/lexer";
require "interload";
require "intermake";

functor InterMake (
  structure ModuleId: MODULE_ID
  structure Project: PROJECT
  structure Lists : LISTS
  structure Compiler : COMPILER
  structure Lexer : LEXER
  structure InterLoad : INTERLOAD
  structure MLWorksIo : MLWORKS_IO
  structure Encapsulate : ENCAPSULATE
  structure Basis : BASIS
  structure Stamp : STAMP
  structure Crash : CRASH
  structure Diagnostic : DIAGNOSTIC

  sharing InterLoad.Inter_EnvTypes.Options = Compiler.Options
  sharing Encapsulate.BasisTypes = Basis.BasisTypes
  sharing Compiler.NewMap = InterLoad.Inter_EnvTypes.EnvironTypes.NewMap =
          Encapsulate.ParserEnv.Map
  sharing InterLoad.Inter_EnvTypes.EnvironTypes = Encapsulate.EnvironTypes
  sharing Project.Info = Compiler.Info
  sharing Compiler.Options = Encapsulate.Debugger_Types.Options

  sharing type Compiler.Top_Env = Encapsulate.EnvironTypes.Top_Env
  sharing type Basis.BasisTypes.Basis = Compiler.TypeBasis
  sharing type Encapsulate.ParserEnv.pB = Compiler.ParserBasis
  sharing type Compiler.DebugInformation =
	       Encapsulate.Debugger_Types.information
  sharing type Lexer.TokenStream = Compiler.tokenstream
  sharing type Encapsulate.Module = InterLoad.Module = Compiler.Module
  sharing type ModuleId.ModuleId = MLWorksIo.ModuleId = Project.ModuleId
  sharing type ModuleId.Location = Compiler.Absyn.Ident.Location.T
  sharing type Encapsulate.EnvironTypes.LambdaTypes.Ident.ValId =
	       Compiler.Absyn.Ident.ValId
  sharing type Encapsulate.EnvironTypes.LambdaTypes.Ident.StrId =
	       Compiler.Absyn.Ident.StrId
  sharing type Encapsulate.EnvironTypes.DebuggerEnv = Compiler.DebuggerEnv
  sharing type Basis.BasisTypes.Datatypes.Stamp = Stamp.Stamp
  sharing type Basis.BasisTypes.Datatypes.StampMap = Stamp.Map.T
  sharing type Project.CompilerBasis = Compiler.basis
  sharing type Project.IdCache = Compiler.id_cache
) : INTERMAKE =
  struct
    structure Debugger_Types = Encapsulate.Debugger_Types
    structure Compiler = Compiler
    structure Diagnostic = Diagnostic
    structure Inter_EnvTypes = InterLoad.Inter_EnvTypes
    structure Ident = Compiler.Absyn.Ident
    structure Info = Compiler.Info
    structure Options = Compiler.Options
    structure Map = Inter_EnvTypes.EnvironTypes.NewMap
    structure Token = Lexer.Token
    structure Location = Ident.Location
    structure Datatypes = Encapsulate.BasisTypes.Datatypes
(*     structure FileSys = OS.FileSys *)

    type Project = Project.Project
    type ModuleId = ModuleId.ModuleId

    fun diagnostic (level, output_function) =
      Diagnostic.output level
      (fn verbosity => "InterMake: " :: (output_function verbosity))

    fun augment_accumulated_info(options, basis, basis') =
      Compiler.augment(options, basis, Compiler.make_external basis')

    val get_basis_debug_info = Compiler.get_basis_debug_info

    exception GetSubRequires of string
    (* This should get the subrequires info *)
    fun get_subrequires (acc, modname, project) =
      let
        fun test [] = false
          | test ((m', _, _)::l) = modname = m' orelse test l

        fun lookupmodname modname =
	  let
	    val mod_id = ModuleId.from_mo_string (modname, Location.UNKNOWN)
	  in
	    case Project.get_loaded_info (project, mod_id)
	    of SOME {id_cache, dependencies, ...} =>
              let
                val Compiler.ID_CACHE{stamp_start,stamp_no} = id_cache
              in
                (stamp_start, stamp_no, dependencies)
              end
	    |  NONE =>
	      Crash.impossible ("Unknown module: " ^ ModuleId.string mod_id)
	  end
      in
        if test acc
          then acc
        else
          let
            val (stamps, stamp_no, Project.DEPEND_LIST dependencies) =
	      lookupmodname modname

            val acc' =
              Lists.reducel
                (fn (acc, modname) =>
                   get_subrequires (acc, modname, project))
              ((modname, stamps,stamp_no) :: acc,
               (map #mod_name dependencies))
          in
            acc'
          end
      end

    val Basis.BasisTypes.BASIS(_, _, _, _, initial_env_for_normal_file) = Basis.initial_basis

    fun get_mo_information (project, location) module_id =
      let
	val modname = ModuleId.string module_id
        val dir = ModuleId.path_string (ModuleId.path module_id)

        val mo_name =
          case Project.get_object_info (project, module_id)
          of SOME {file, ...} =>
	    file
          |  NONE =>
            raise MLWorks.Internal.Runtime.Loader.Load "cannot find mo file"

        val {parser_env, type_env, lambda_env, stamps, consistency,
	     time_stamp = src_time, mod_name} =
          Encapsulate.input_all mo_name

        val stamp_count = Stamp.read_counter ()

        val _ = Stamp.reset_counter (stamp_count + stamps)

        val id_cache = Compiler.ID_CACHE{stamp_start = stamp_count,
                                         stamp_no = stamps}

        val subnames = map #mod_name consistency

        (* And make the require list *)
	(* This returns a list that maps module names to the corresponding
	   (stamp_count, stamps) information, for each of the dependencies. *)
        val require_list =
          Lists.reducel
            (fn (acc,modname) =>
                 get_subrequires (acc, modname, project))
            ([(modname, stamp_count, stamps)], subnames)

	val require_table =
	  Map.from_list'
	    op<
	    (map (fn (x as (name, _, _)) => (name, x)) require_list)

        val (parser_env, lambda_env, type_basis, debug_info) =
          Encapsulate.decode_all
	  {parser_env=parser_env,
	   lambda_env=lambda_env,
	   type_env=type_env,
	   file_name=mod_name,
	   sub_modules=require_table,
	   decode_debug_information=false,
	   pervasive_env=initial_env_for_normal_file}

        val compiler_basis =
	  Compiler.BASIS
	    {parser_basis = parser_env,
             type_basis = type_basis,
             lambda_environment = lambda_env,
             debugger_environment =
               Inter_EnvTypes.EnvironTypes.DENV
                 (Map.empty (Ident.valid_lt,Ident.valid_eq),
                  Map.empty (Ident.strid_lt,Ident.strid_eq)),
             debug_info = debug_info}

        val compiler_result =
	  Compiler.RESULT
	    {basis = compiler_basis,
             signatures = Map.empty (Ident.sigid_lt,Ident.sigid_eq),
             code = NONE,
             id_cache = id_cache}
      in
        compiler_result
      end

    (* This is the exported function, for loading an object file. *)
    fun load options (project, location) module_id =
      let
	val Options.OPTIONS
	  {compiler_options = Options.COMPILEROPTIONS
	   {print_messages, ...},
	   ...} =
	  options

        val _ =
	  if print_messages then
	    print ("Loading mo module " ^ ModuleId.string module_id ^ "\n")
	  else
	    ()
        val (mo_name, time, dependencies) =
          case Project.get_object_info (project, module_id)
          of SOME {file, time_stamp,
		   consistency = Project.DEPEND_LIST (_ :: cons), ...} =>
	    (file, time_stamp, cons)
	  |  SOME _ =>
	    Crash.impossible "No entry for pervasive library in consistency"
	    (* This should possibly be done in a neater way *)
          |  NONE =>
            raise MLWorks.Internal.Runtime.Loader.Load "cannot find mo file"

        val (module_id', module) =
          MLWorks.Internal.Runtime.Loader.load_module mo_name

        val compiler_result =
          get_mo_information (project, location) module_id

	val (id_cache, basis) =
	  case compiler_result
	  of Compiler.RESULT {id_cache, basis, ...} => (id_cache, basis)

	fun get_load_time {mod_name, time} =
	  case
	    Project.get_loaded_info
	      (project, ModuleId.from_string (mod_name, Location.UNKNOWN))
	  of SOME {load_time, ...} =>
	    {mod_name = mod_name, time = load_time}
	  |  NONE => Crash.impossible ("no loaded info for `" ^ mod_name ^ "'")
      in
	Project.set_visible (project, module_id, false);
        Project.set_loaded_info
          (project, module_id,
	   SOME
	     {file_time = Project.OBJECT time,
	      load_time = Time.now (),
	      basis = basis,
	      id_cache = id_cache,
	      module = module,
	      dependencies =
		Project.DEPEND_LIST (map get_load_time dependencies)});
        (compiler_result, module)
      end
      handle
        MLWorks.Internal.Runtime.Loader.Load s =>
          Info.error'
	    (Info.make_default_options ())
	    (Info.FATAL,
	     Info.Location.FILE (ModuleId.string module_id),
             "Load failed: " ^ s)
      | Encapsulate.BadInput s =>
          Info.error'
	    (Info.make_default_options ())
	    (Info.FATAL,
	     Info.Location.FILE (ModuleId.string module_id),
             "Load failed: " ^ s)

    val debug_info_ref = ref Debugger_Types.empty_information

    fun with_debug_information debug_info f =
      let
        val old = !debug_info_ref
        val _ = debug_info_ref := debug_info
        val result = f () handle exn => (debug_info_ref := old;raise exn)
      in
        debug_info_ref := old;
        result
      end

    fun current_debug_information () = !debug_info_ref

    (* This is extracted from the old make function. *)
    local
      (* Load a compiler_result and return an updated project and debug_info. *)
      fun load' debugger
             initial_inter_env
	     (error_info, location, options)
	     preloaded_opt
             (project, module_id, module_str, accumulated_info,
              compiler_result, src_time, consistency) =
           let
             val _ = diagnostic (4, fn _ => ["loading ", module_str])

	     val generate_debug_info =
	       case options of
	         Options.OPTIONS
	           {compiler_options =
		      Options.COMPILEROPTIONS {generate_debug_info, ...},
		    ...} =>
		 generate_debug_info

             val Compiler.RESULT
		   {code, basis, signatures, id_cache} =
	       compiler_result

             val Compiler.BASIS {lambda_environment, ...} = basis

             val accumulated_info =
               Debugger_Types.augment_information
	         (generate_debug_info,
		  accumulated_info,
                  get_basis_debug_info basis)

             val module =
	       case preloaded_opt
	       of SOME preloaded =>
                 (* When compiling pervasives get module from preloaded list.
		    This is derived from MLWorks.Internal.Runtime.modules *)
                 (Lists.assoc (module_str, preloaded)
                  handle Lists.Assoc =>
		    Crash.impossible "No pervasive modules!")
               | NONE =>
                   (* This is code that is normally executed *)
                   let
                     fun module_map module_str =
		       case Project.get_loaded_info
			      (project, ModuleId.from_mo_string
					  (module_str, Info.Location.UNKNOWN))
		       of SOME {module, ...} => module
		       |  NONE =>
			 Crash.impossible
			   ("Can't find compilation unit `" ^ module_str
			    ^ "' in project when loading")
                   in
                     case code of
                       NONE =>
			 Info.error'
			   error_info
			   (Info.FATAL, location,
			    concat
			      ["`", module_str,
			       "' database entry has no code recorded."])
                     | SOME code' =>
                         with_debug_information
                           accumulated_info
                           (fn () =>
                              InterLoad.load
                                debugger
			        (initial_inter_env, module_map)
			        code')
                   end

             val compiler_result =
               Compiler.RESULT
	         {code=NONE,
		  basis=basis,
		  signatures=signatures,
		  id_cache=id_cache}

	     val _ =
	       Project.set_visible (project, module_id, false);

	     val _ =
	       Project.set_loaded_info
		 (project,
		  module_id,
		  SOME
		    {load_time = Time.now(),
		     file_time = Project.SOURCE src_time,
		     basis = basis,
		     id_cache = id_cache,
		     module = module,
		     dependencies = Project.DEPEND_LIST consistency})

             val _ = diagnostic (2, fn _ => ["finished ", module_str])
           in
             (compiler_result, module, accumulated_info)
           end

      fun compile'
            initial_compiler_basis
            (error_info, location, options)
            (project, module_id, filename, time) =
	let
	  val module_str = ModuleId.string module_id
	
	  val is_pervasive = ModuleId.is_pervasive module_id

	  val Options.OPTIONS
		{compiler_options = Options.COMPILEROPTIONS
		   {print_messages, ...},
		 ...} =
	    options

	  val _ =
	    if print_messages then
	      print ("Compiling " ^ module_str ^ "\n")
	    else
	      ()

          val _ = diagnostic
		    (2, fn _ => ["Compiling ", module_str, " as ", filename]);

          val (dependencies, compiler_result) =
            let
              val instream =
		TextIO.openIn filename
                handle IO.Io {name, cause, ...} =>
		  let
		    val message = exnMessage cause ^ " in: " ^ name
		  in
                    Info.error'
		      error_info
		        (Info.FATAL, Info.Location.FILE filename,
                         "Io error during make, " ^ message)
		  end
            in
              let
                val token_stream =
                  let
                    val stream_name =
                      if is_pervasive then "<Pervasive>"
                      else filename
                  in
                    Lexer.mkFileTokenStream (instream, stream_name)
                  end

                fun require_function
		      (dependencies, sub_module_name, source_location) =
                  let
                    val _ = diagnostic (3, fn _ =>
			      [ModuleId.string module_id, " requiring ",
                               sub_module_name])

		    val (full_module_id, loaded_info) =
                      if is_pervasive orelse
		         sub_module_name = MLWorksIo.pervasive_library_name then
			let
			  val m =
			    ModuleId.perv_from_require_string
			      (sub_module_name, source_location)
			in
			  (m, Project.get_loaded_info (project, m))
			end
		      else
			let
			  val m =
			    ModuleId.add_path
			      (ModuleId.empty_path,
			       ModuleId.from_require_string
			         (sub_module_name, source_location))
			in
			  (Project.get_name (project, m),
                           Project.get_loaded_info (project, m))
			end

		    val (sub_time, basis) =
		      case loaded_info
		      of NONE =>
			Crash.impossible
			  ("No loaded info for `"
			   ^ sub_module_name ^ "' in project")
		      |  SOME {load_time, basis, ...} =>
			(load_time, basis)
                  in
                    ({mod_name = ModuleId.string full_module_id,
		      time = sub_time}
		      :: dependencies,
                      ModuleId.string full_module_id,
		      basis)
                  end

                val (dependencies, compiler_result) =
                  Compiler.compile
		    (error_info, options)
		    require_function
                    ([], initial_compiler_basis, true)
                    (is_pervasive, Compiler.TOKENSTREAM token_stream)

              in
                TextIO.closeIn instream;
                (dependencies, compiler_result)
              end
              handle exn => (TextIO.closeIn instream; raise exn)
            end
        in
          (module_str, compiler_result, time, dependencies)
        end

    in
      fun compile
	    debugger
            (initial_compiler_basis, initial_inter_env)
            (error_info, location, options)
	    preloaded_opt
            (project, module_id, accumulated_info) =
	case Project.get_source_info (project, module_id)
	of NONE =>
	  (* No source file, so load the object file *)
	  let
	    val (compilerResult, module) =
	      load options (project, location) module_id
	  in
	    (compilerResult, module, accumulated_info)
	  end
	|  SOME (filename, time) =>
          let
	    val (module_str, compiler_result, time, dependencies) =
	      compile'
                initial_compiler_basis
                (error_info, location, options)
                (project, module_id, filename, time)

            val result =
              load'
	        debugger
	        initial_inter_env
	        (error_info, location, options)
	        preloaded_opt
	        (project, module_id, module_str, accumulated_info,
                 compiler_result, time, dependencies)
          in
            result
          end

      fun get_src_information
            initial_compiler_basis
            (error_info, location, options)
            (project, module_id) =
	case Project.get_source_info (project, module_id)
	of NONE =>
          Info.error'
	    error_info
	      (Info.FATAL, location,
	       "can't find compilation unit `" ^
	       ModuleId.string module_id ^ "'")
	|  SOME (filename, time) =>
          let
	    val (_, compiler_result, _, _) =
	      compile'
                initial_compiler_basis
                (error_info, location, options)
                (project, module_id, filename, time)
	  in
	    compiler_result
	  end
    end
end
@


1.112.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.112  1998/04/22  17:09:07  jont
 * [Bug #70091]
 * removing req_name from consistency info
 *
@


1.111
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d11 4
d520 1
a520 1
          | test ((m',_)::l) = modname = m' orelse test l
d548 1
a548 1
              ((modname, (stamps,stamp_no)) :: acc,
d589 1
a589 1
            ([(modname, (stamp_count, stamps))], subnames)
d594 1
a594 1
	    (map (fn (x as (name, value)) => (name, x)) require_list)
d596 9
a604 3
        val (type_basis, debug_info) =
          Encapsulate.decode_type_basis
            (type_env, modname, require_table, false, initial_env_for_normal_file)
d662 1
a662 1
	fun get_load_time {mod_name, req_name, time} =
d667 1
a667 1
	    {mod_name = mod_name, req_name = req_name, time = load_time}
a802 9
(*
		fun sub_requires require_list =
		  Lists.reducel
		  (fn (acc, {mod_name, req_name, time}) => acc ^ mod_name ^ "\n")
		  ("", require_list)

		val _ = print("load': Require list for " ^ module_str ^ " is:-\n" ^
			      sub_requires consistency)
*)
a895 1
		      req_name = sub_module_name,
a908 9
(*
		fun sub_requires require_list =
		  Lists.reducel
		  (fn (acc, {mod_name, req_name, time}) => acc ^ mod_name ^ "\n")
		  ("", require_list)

		val _ = print("Require list for " ^ module_str ^ " is:-\n" ^
			      sub_requires dependencies)
*)
@


1.110
log
@[Bug #30328]
Add environment parameter to decode_type_basis
for finding pervasive type names
@
text
@d11 5
d25 24
a430 1
require "../basics/module";
a435 1
require "../basis/os";
d437 1
a437 1
require "../main/io";
d451 1
a451 1
  structure Io : MLWORKS_IO
a455 2
  structure Module : MODULE
  structure OS : OS
d473 1
a473 2
  sharing type ModuleId.ModuleId = Module.ModuleId =
	       Io.ModuleId = Project.ModuleId
a488 1
    structure Module = Module
d497 1
a497 1
    structure FileSys = OS.FileSys
a586 10
(*
	fun sub_requires require_list =
	  Lists.reducel
	  (fn (acc, (name, _)) => acc ^ name ^ "\n")
	  ("", require_list)

	val _ = print("Require list for " ^ modname ^ " is:-\n" ^
		      sub_requires require_list)
*)

a686 135
    (*
    fun save error_info (modules, filename,location) =
      let
	(* Need time stamp of pervasive mo *)
	val pervasive_mo_stamp =
	  let
	    val module = Module.MODULE (Io.get_pervasive_dir(), Io.pervasive_library_id)
	    (* XXXEXCEPTION: Io.NotSet should be handled here *)
	  in
	    FileSys.modTime(Module.mo_name module)
	    handle OS.SysErr _ =>
	      (Info.error' error_info
	       (Info.WARNING,location,
		"cannot find pervasive library mo '" ^ (Module.mo_name module) ^
		"' time stamp when saving " ^
		filename);
	       Time.now())
	  end

        exception GetSubRequires of string
        (* This should get the subrequires info *)
        fun get_subrequires first (acc,module_id) =
          let
            val modname = ModuleId.string module_id
            fun test [] = false
              | test ((m',_)::l) = modname = m' orelse test l
          in
            if test acc
              then acc
            else
              let
                val RESULT{dependencies,
			   compiler_result=Compiler.RESULT{id_cache, ...},
			   ...} =
                  case Map.tryApply'(modules, modname) of
                    SOME result => result
                  | _ => Info.error' error_info
                      (Info.FATAL, location, "cannot find module " ^
                       modname)

                val Compiler.ID_CACHE{stamp_start,stamp_no} = id_cache

                val acc' =
                  Lists.reducel
                  (get_subrequires false)
                  ((if first then "" else modname,
                   (stamp_start,stamp_no)) :: acc,
                   (map #mod_name dependencies))
              in
                acc'
              end
          end

	fun do_save(done, module_id) =
	  let
	    val module_str = ModuleId.string module_id
	  in
	    case Map.tryApply'(done, module_str) of
	      NONE =>
		let
		  val result as
		    RESULT{name, time, dependencies,
			   compiler_result=Compiler.RESULT{code,id_cache,basis, ...},
			   ...} =
		    case Map.tryApply'(modules, module_str) of
		      SOME result => result
		    | _ => Info.error' error_info
			(Info.FATAL, location, "cannot find module " ^
			 module_str)
                  val require_list = rev (get_subrequires true ([],module_id))
                  val Compiler.ID_CACHE{stamp_no,...} = id_cache
                  val sub_modules = map #mod_name dependencies
		  val done = Lists.reducel do_save (done, sub_modules)
		  val module_name =
		    case Module.find_sml(module_id, Module.empty_cache) of
		      (SOME(_, module, _), _) => module
		    | _ => Info.error' error_info
			(Info.FATAL,location,
			 "cannot find source of module " ^ module_str)
		  val mo_name = Module.mo_name module_name
                  (* a module for a module loaded from an mo has no code, *)
		  (* so can't be saved *)
		  val module = case code of
		    SOME module => module
		  | _ =>
		      Info.error' error_info
			(Info.FATAL, location,
			 "no code for module " ^ module_str)
                  val Compiler.BASIS{parser_basis,
                                     type_basis,
                                     lambda_environment,
                                     debugger_environment,
                                     debug_info} = basis
		in
                  Encapsulate.clean_basis Basis.initial_basis;
                  Encapsulate.clean_basis type_basis;
		  print ("Saving '" ^ module_str ^ "'\n");
		  Encapsulate.output_file false
		    {filename=mo_name,
		     code=module,
		     stamps=stamp_no,
		     parser_env=parser_basis,
		     type_basis=type_basis,
		     debug_info=debug_info,
		     require_list=require_list,
		     lambda_env=lambda_environment,
		     mod_name=module_str,
		     time_stamp=time,
		     consistency=
		       map
		       (fn {mod_name=mod_id, req_name=req_id, ...} =>
		          let
		            val mod_id = ModuleId.string mod_id
		            val req_id = ModuleId.string req_id
		          in
		            {mod_name=mod_id, req_name=req_id,
			     time=Map.apply'(done, mod_id)}
		          end)
		       (rev dependencies)};
		   Map.define(done, module_str,
			      FileSys.modTime mo_name
			      handle OS.SysErr _ => Info.error' error_info
				(Info.FATAL, location,
				 "cannot find time stamp of module " ^ mo_name ^
				 " just written"))
		end
	    | _ => done
	  end
      in
	(do_save (Map.from_list' ((op<):string*string->bool) [(Io.pervasive_library_name, pervasive_mo_stamp)],
                  ModuleId.from_host(filename,location));
	 ())
      end
    *)

d865 1
a865 1
		         sub_module_name = Io.pervasive_library_name then
d877 1
a877 1
			      (ModuleId.path module_id,
d944 1
a944 1
	|  SOME (filename, _, time) =>
d975 1
a975 1
	|  SOME (filename, _, time) =>
@


1.109
log
@[Bug #30089]
Remove use of OldOs.mtime in favour of OsFileSys.modTime
@
text
@d11 4
d528 2
d581 1
a581 1
            (type_env, modname, require_table, false)
@


1.108
log
@[Bug #20090]
Projects now store the time stamps of object files in the loaded info,
instead of their modification times.
@
text
@d11 5
d395 1
d404 1
a404 1
require "../make/old_os";
d426 1
a426 1
  structure OldOs : OLD_OS
d470 1
d646 1
a646 1
	      load_time = MLWorks.Time.now (),
d677 8
a684 9
	    case OldOs.mtime(Module.mo_name module) of
	      OldOs.EXISTS time => time
	    | OldOs.NOT_EXIST =>
		(Info.error' error_info
		 (Info.WARNING,location,
		  "cannot find pervasive library mo '" ^ (Module.mo_name module) ^
		  "' time stamp when saving " ^
		  filename);
		 MLWorks.Time.now())
d788 5
a792 6
			      case OldOs.mtime mo_name of
				OldOs.EXISTS time => time
			      | _ => Info.error' error_info
				  (Info.FATAL, location,
				   "cannot find time stamp of module " ^ mo_name ^
				   " just written"))
d903 1
a903 1
		    {load_time = MLWorks.Time.now(),
@


1.107
log
@[Bug #30090]
Converted lexer to Basis IO.
@
text
@d11 4
d607 1
a607 1
          of SOME {file, file_time,
d609 1
a609 1
	    (file, file_time, cons)
d612 1
a612 1
	    (* This should possible be done in a neater way *)
@


1.107.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 4
 * Revision 1.107  1997/05/28  10:44:56  daveb
 * [Bug #30090]
 * Converted lexer to Basis IO.
 *
@


1.107.2.2
log
@[Bug #30071]
Converted build system to project workspace.
@
text
@a10 3
 * Revision 1.107.2.1  1997/09/11  20:55:00  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d988 1
a988 1
			      (ModuleId.empty_path,
d1055 1
a1055 1
	|  SOME (filename, time) =>
d1086 1
a1086 1
	|  SOME (filename, time) =>
@


1.107.2.3
log
@[Bug #20090]
Merged from trunk:
Projects now store the time stamps of object files in the loaded info,
instead of their modification times.
@
text
@a10 4
 * Revision 1.107.2.2  1997/09/17  15:52:41  daveb
 * [Bug #30071]
 * Converted build system to project workspace.
 *
d610 1
a610 1
          of SOME {file, time_stamp,
d612 1
a612 1
	    (file, time_stamp, cons)
d615 1
a615 1
	    (* This should possibly be done in a neater way *)
@


1.107.2.4
log
@[Bug #30089]
Merged from trunk:
Remove use of OldOs.mtime in favour of OsFileSys.modTime
@
text
@a10 6
 * Revision 1.107.2.3  1997/10/29  11:58:49  daveb
 * [Bug #20090]
 * Merged from trunk:
 * Projects now store the time stamps of object files in the loaded info,
 * instead of their modification times.
 *
a396 1
require "../system/__time";
d405 1
a405 1
require "../basis/os";
d427 1
a427 1
  structure OS : OS
a470 1
    structure FileSys = OS.FileSys
d646 1
a646 1
	      load_time = Time.now (),
d677 9
a685 8
	    FileSys.modTime(Module.mo_name module)
	    handle OS.SysErr _ =>
	      (Info.error' error_info
	       (Info.WARNING,location,
		"cannot find pervasive library mo '" ^ (Module.mo_name module) ^
		"' time stamp when saving " ^
		filename);
	       Time.now())
d789 6
a794 5
			      FileSys.modTime mo_name
			      handle OS.SysErr _ => Info.error' error_info
				(Info.FATAL, location,
				 "cannot find time stamp of module " ^ mo_name ^
				 " just written"))
d905 1
a905 1
		    {load_time = Time.now(),
@


1.107.2.5
log
@[Bug #30326]
@
text
@a10 5
 * Revision 1.107.2.4  1997/10/29  13:53:34  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
d414 1
a414 1
require "../main/mlworks_io";
@


1.107.2.6
log
@[Bug #30071]
@
text
@a10 3
 * Revision 1.107.2.5  1997/11/20  16:58:04  daveb
 * [Bug #30326]
 *
d411 1
d417 1
d433 1
a433 1
  structure MLWorksIo : MLWORKS_IO
d438 2
d457 2
a458 1
  sharing type ModuleId.ModuleId = MLWorksIo.ModuleId = Project.ModuleId
d474 1
d483 1
d571 10
d681 135
d994 1
a994 1
		         sub_module_name = MLWorksIo.pervasive_library_name then
@


1.107.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 4
 * Revision 1.107  1997/05/28  10:44:56  daveb
 * [Bug #30090]
 * Converted lexer to Basis IO.
 *
@


1.106
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d11 4
d383 4
d598 1
a598 2
	    MLWorks.IO.output
	    (MLWorks.IO.std_out, "Loading mo module " ^ ModuleId.string module_id ^ "\n")
d754 1
a754 1
		  MLWorks.IO.output(MLWorks.IO.std_out, "Saving '" ^ module_str ^ "'\n");
a771 3
(*
                            val _ = MLWorks.IO.output(MLWorks.IO.std_out,mod_id^"\n")
*)
d932 1
a932 2
	      MLWorks.IO.output
		(MLWorks.IO.std_out, "Compiling " ^ module_str ^ "\n")
d942 10
a951 6
		MLWorks.IO.open_in filename
                handle MLWorks.IO.Io message =>
                  Info.error'
		    error_info
		    (Info.FATAL, Info.Location.FILE filename,
                     "Io error during make, " ^ message)
d1026 1
a1026 1
                MLWorks.IO.close_in instream;
d1029 1
a1029 1
              handle exn => (MLWorks.IO.close_in instream; raise exn)
@


1.105
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d11 4
d402 1
a402 1
  structure Io : IO
@


1.104
log
@[Bug #2040]
Make InterMake.load take an options argument
@
text
@d11 4
a448 2
    open MLWorks.Option

d474 1
a474 1
              let 
d491 1
a491 1
              Lists.reducel 
d500 1
a500 1
    
d516 1
a516 1
              
d518 1
a518 1
          
d520 1
a520 1
          
d523 1
a523 1
          
d525 1
a525 1
          
d529 2
a530 2
        val require_list = 
          Lists.reducel 
d534 11
a544 1
          
d553 1
a553 1
          
d564 1
a564 1
          
d574 1
a574 1
    
d690 1
a690 1
                  Lists.reducel 
d808 1
a808 1
              compiler_result, src_time, consistency) = 
d861 1
a861 1
                     | SOME code' => 
d892 9
d913 1
a913 1
	      
d931 1
a931 1
             
d945 1
a945 1
                    val stream_name = 
d1004 10
@


1.103
log
@[Bug #1965]
Added a comment about an unhandled NotSet exception in commented code.
@
text
@d11 4
d564 1
a564 1
    fun load (project, location) module_id =
d566 6
d573 2
a574 1
	  MLWorks.IO.output
d576 2
a577 1

d1005 1
a1005 1
	      load (project, location) module_id
@


1.103.1.1
log
@branched from 1.103
@
text
@a10 4
 * Revision 1.103  1997/03/21  10:41:53  johnh
 * [Bug #1965]
 * Added a comment about an unhandled NotSet exception in commented code.
 *
@


1.103.1.2
log
@[Bug #02040]
Made -silent suppress "loading mo" messages.
@
text
@a10 3
 * Revision 1.103.1.1  1997/05/12  10:34:05  hope
 * branched from 1.103
 *
d564 1
a564 1
    fun load options (project, location) module_id =
a565 6
        val Options.OPTIONS
          {compiler_options = Options.COMPILEROPTIONS
           {print_messages, ...},
           ...} =
          options
  
d567 2
a568 6
          if print_messages then
	    MLWorks.IO.output
	      (MLWorks.IO.std_out, "Loading mo module " ^ ModuleId.string module_id ^ "\n")
          else
            ()

d997 1
a997 1
	      load options (project, location) module_id
@


1.103.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 4
 * Revision 1.103.1.2  1997/06/10  15:30:05  daveb
 * [Bug #02040]
 * Made -silent suppress "loading mo" messages.
 *
@


1.103.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 4
 * Revision 1.103.1.2  1997/06/10  15:30:05  daveb
 * [Bug #02040]
 * Made -silent suppress "loading mo" messages.
 *
@


1.103.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 4
 * Revision 1.103.1.2  1997/06/10  15:30:05  daveb
 * [Bug #02040]
 * Made -silent suppress "loading mo" messages.
 *
@


1.103.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 3
 * Revision 1.103.1.2.1.1  1997/07/28  18:19:36  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.102
log
@moving String from toplevel
@
text
@d11 3
d629 1
@


1.102.4.1
log
@branched from 1.102
@
text
@a10 3
 * Revision 1.102  1996/10/30  12:26:57  io
 * moving String from toplevel
 *
@


1.102.3.1
log
@branched from 1.102
@
text
@a10 3
 * Revision 1.102  1996/10/30  12:26:57  io
 * moving String from toplevel
 *
@


1.102.3.1.1.1
log
@branched from 1.102.3.1
@
text
@a10 3
 * Revision 1.102.3.1  1996/12/17  17:47:37  hope
 * branched from 1.102
 *
@


1.102.2.1
log
@branched from 1.102
@
text
@a10 3
 * Revision 1.102  1996/10/30  12:26:57  io
 * moving String from toplevel
 *
@


1.102.1.1
log
@branched from 1.102
@
text
@a10 3
 * Revision 1.102  1996/10/30  12:26:57  io
 * moving String from toplevel
 *
@


1.102.1.1.1.1
log
@branched from 1.102.1.1
@
text
@a10 3
 * Revision 1.102.1.1  1996/11/14  12:49:18  hope
 * branched from 1.102
 *
@


1.101
log
@[Bug #1220]
[Bug #1220]
Made compile' load an object file if no source file is available.
@
text
@d11 4
d550 1
a550 1
             code = MLWorks.Option.NONE,
d654 1
a654 1
                    MLWorks.Option.SOME result => result
d677 1
a677 1
	      MLWorks.Option.NONE =>
d684 1
a684 1
		      MLWorks.Option.SOME result => result
d694 1
a694 1
		      (MLWorks.Option.SOME(_, module, _), _) => module
d702 1
a702 1
		    MLWorks.Option.SOME module => module
d752 1
a752 1
	(do_save (Map.from_list' String.< [(Io.pervasive_library_name, pervasive_mo_stamp)],
d826 1
a826 1
                       MLWorks.Option.NONE =>
d830 1
a830 1
			    String.implode
d833 1
a833 1
                     | MLWorks.Option.SOME code' => 
d845 1
a845 1
	         {code=MLWorks.Option.NONE,
@


1.101.3.1
log
@branched from 1.101
@
text
@a10 5
 * Revision 1.101  1996/08/14  11:42:09  daveb
 * [Bug #1220]
 * [Bug #1220]
 * Made compile' load an object file if no source file is available.
 *
@


1.101.2.1
log
@branched from 1.101
@
text
@a10 5
 * Revision 1.101  1996/08/14  11:42:09  daveb
 * [Bug #1220]
 * [Bug #1220]
 * Made compile' load an object file if no source file is available.
 *
@


1.101.1.1
log
@branched from 1.101
@
text
@a10 5
 * Revision 1.101  1996/08/14  11:42:09  daveb
 * [Bug #1220]
 * [Bug #1220]
 * Made compile' load an object file if no source file is available.
 *
@


1.100
log
@[bug: 1543]
Sort out problems mixing loadObject and loadSource
@
text
@d11 4
a865 1

d869 1
a869 1
            (project, module_id) =
d875 5
a879 12
	  val source_info = Project.get_source_info (project, module_id)

          val (filename, time) =
	    case source_info
	    of SOME (filename, _, time) => (filename, time)
	    |  NONE =>
	      (* We should use the object file if it exists. *)
              Info.error'
		error_info
		(Info.FATAL, location,
		 String.implode
		   ["can't find compilation unit `", module_str, "'"])
a880 2
	  val Options.OPTIONS{compiler_options = Options.COMPILEROPTIONS{print_messages, ...}, ...} =
	    options
d883 2
a884 1
	      MLWorks.IO.output(MLWorks.IO.std_out, "Compiling " ^ module_str ^ "\n")
d980 28
a1007 18
        let
	  val (module_str, compiler_result, time, dependencies) =
	    compile'
              initial_compiler_basis
              (error_info, location, options)
              (project, module_id)

          val result =
            load'
	      debugger
	      initial_inter_env
	      (error_info, location, options)
	      preloaded_opt
	      (project, module_id, module_str, accumulated_info,
               compiler_result, time, dependencies)
        in
          result
        end
d1013 17
a1029 9
        let
	  val (_, compiler_result, _, _) =
	    compile'
              initial_compiler_basis
              (error_info, location, options)
              (project, module_id)
	in
	  compiler_result
	end
@


1.99
log
@[Bug #1521]
Propagating changes made to typechecker/_scheme.sml and _types.sml
@
text
@d11 4
d540 1
a540 1
	    {basis = Compiler.make_external compiler_basis,
@


1.98
log
@Add control of printing of compilation messages
@
text
@d11 3
d390 1
a391 2
  sharing type Compiler.Options.print_options =
	       Encapsulate.Debugger_Types.printOptions
@


1.97
log
@The Io exception is no longer at top level.
@
text
@d11 3
d879 7
a885 2
	  val _ = MLWorks.IO.output
		    (MLWorks.IO.std_out, "Compiling " ^ module_str ^ "\n");
@


1.96
log
@Marked every loaded module not visible, until it is explicitly added to the
context by code elsewhere.  (Fixes bug 1337).
@
text
@d11 4
d886 1
a886 1
                handle Io message =>
@


1.95
log
@Removed Interrupted and Error exceptions.
The load and load' functions side-effect their project arguments instead
of returning an updated value.
@
text
@d11 5
d571 1
d828 3
@


1.94
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d11 6
a425 3
    exception Error of Project * Info.error * Info.error list
    exception Interrupted of Project

d576 1
a576 1
        (project, compiler_result, module)
d803 3
a805 2
			    String.implode ["`", module_str,
				     "' database entry has no code recorded."])
d807 7
a813 11
                         (with_debug_information
                            accumulated_info
                            (fn () =>
                               InterLoad.load
                                  debugger
				  (initial_inter_env, module_map)
				  code'))
                         (* If an exception escapes, its probably been
			    handled by the debugger, so just return the
			    project in the Interrupted exception *)
                         handle exn => raise Interrupted (project)
d837 1
a837 1
             (project, compiler_result, module, accumulated_info)
d860 5
a864 1
		 String.implode ["can't find compilation unit `", module_str, "'"])
a865 1
	  val _ = MLWorks.IO.output (MLWorks.IO.std_out, "Compiling " ^ module_str ^ "\n");
@


1.93
log
@Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
the deprecated OS interface.
@
text
@d11 4
d531 2
a532 2
	  output
	    (std_out, "Loading mo module " ^ ModuleId.string module_id ^ "\n")
d685 1
a685 1
		  output(std_out, "Saving '" ^ module_str ^ "'\n");
d704 1
a704 1
                            val _ = output(std_out,mod_id^"\n")
d800 1
a800 1
			    implode ["`", module_str,
d860 1
a860 1
		 implode ["can't find compilation unit `", module_str, "'"])
d862 1
a862 1
	  val _ = output (std_out, "Compiling " ^ module_str ^ "\n");
d869 1
a869 1
		open_in filename
d939 1
a939 1
                close_in instream;
d942 1
a942 1
              handle exn => (close_in instream; raise exn)
@


1.92
log
@Removed unnecessary verbosity.
@
text
@d11 3
d334 1
a334 1
require "../make/os";
d356 1
a356 1
  structure Os : OS
d593 3
a595 3
	    case Os.mtime(Module.mo_name module) of
	      Os.EXISTS time => time
	    | Os.NOT_EXIST =>
d708 2
a709 2
			      case Os.mtime mo_name of
				Os.EXISTS time => time
@


1.91
log
@Got rid of the "hacked up mini module naming system".
@
text
@d11 3
a537 2
        val _ = output (std_out, "Loading mo file " ^ mo_name ^ "\n")

a565 1
        output (std_out, "Set load info for `" ^ ModuleId.string module_id ^ "'\n");
@


1.90
log
@Removed the identifiers field from the Compiler.result type.  This information
can be synthesised from the type basis.
@
text
@d11 4
a412 22

    (* This is a hacked up mini module naming system.
       It should be got rid of.  *)

    fun is_perv module_name = ord module_name = ord " "

    fun get_mod_dir modname =
      let
        val chars = rev (explode modname)
        fun strip [] = ""
          | strip ("."::rest) = implode (rev rest)
          | strip (c::rest) = strip rest
      in
        strip chars
      end

    fun extend_name (modname,dir) =
      if get_mod_dir modname = "" andalso not (dir = "") andalso
	 not (is_perv modname)
        then dir ^ "." ^ modname
      else modname

d479 2
d483 3
a485 8
          (fn (acc,modname) =>
           let
             val modname = extend_name (modname,dir)
             val dir = get_mod_dir modname
           in
             get_subrequires (acc,modname,project (*dir,modules *))
           end)
          ([(modname,(stamp_count,stamps))],subnames)
@


1.89
log
@Added get_mo_information (again) and get_src_information.
Reduced amount of information stored in projects for loaded units.
@
text
@d11 4
a531 1
             identifiers = Compiler.extract_identifiers ([],type_basis),
d777 1
a777 1
		   {code, basis, signatures, identifiers, id_cache} =
a834 1
		  identifiers=identifiers,
@


1.88
log
@Changed test for pervasive modules in compile: instead of testing whether
the list of preloaded modules is NONE, is uses ModuleId.is_pervasive.
@
text
@d11 4
d371 3
a373 2
  sharing type Project.CompilerResult = Compiler.result
 ) : INTERMAKE =
d439 1
a439 1
	    of SOME {file_time, load_time, result, module, dependencies} =>
a440 1
                val Compiler.RESULT{id_cache,...} = result
d467 1
a467 1
    fun get_mo_information (project, mo_name, module_id, module, location) =
d472 7
d559 5
a563 1
          get_mo_information (project, mo_name, module_id, module, location)
d578 2
a579 1
	      result = compiler_result,
d842 2
a843 1
		     result = compiler_result,
d851 8
a858 8
    in
      fun compile debugger
             (initial_compiler_basis, initial_inter_env)
             (error_info, location, options)
	     preloaded_opt
             (project, module_id, accumulated_info) =
           let
	     val module_str = ModuleId.string module_id
d860 1
a860 1
	     val is_pervasive = ModuleId.is_pervasive module_id
d862 1
a862 2
	     val source_info =
	       Project.get_source_info (project, module_id)
d864 13
a876 14
             val (filename, time) =
	       case source_info
	       of SOME (filename, _, time) => (filename, time)
	       |  NONE =>
		 (* We should use the object file if it exists. *)
                 Info.error'
		   error_info
		   (Info.FATAL, location,
		    implode ["can't find compilation unit `", module_str, "'"])

	     val _ = output (std_out, "Compiling " ^ module_str ^ "\n");
             val _ = diagnostic
		       (2, fn _ => ["Compiling ", module_str, " as ",
				    filename]);
d878 121
a998 93
             val (dependencies, compiler_result) =
               let
                 val instream =
		   open_in filename
                   handle Io message =>
                     Info.error'
		       error_info
		       (Info.FATAL, Info.Location.FILE filename,
                        "Io error during make, " ^ message)
               in
                 let
                   val token_stream =
                     let
                       val stream_name = 
                         if is_pervasive then "<Pervasive>"
                         else filename
                     in
                       Lexer.mkFileTokenStream (instream, stream_name)
                     end

                   fun require_function
			 (dependencies, sub_module_name, source_location) =
                     let
                       val _ = diagnostic
                         (3, fn _ => [ModuleId.string module_id,
                                      " requiring ",
                                      sub_module_name])

		       val (full_module_id, loaded_info) =
                         if is_pervasive orelse
			    sub_module_name = Io.pervasive_library_name then
			   let
			     val m =
			       ModuleId.perv_from_require_string
			         (sub_module_name, source_location)
			   in
			     (m, Project.get_loaded_info (project, m))
			   end
			 else
			   let
			     val m =
			       ModuleId.add_path
			         (ModuleId.path module_id,
				  ModuleId.from_require_string
				    (sub_module_name, source_location))
			   in
			     (Project.get_name (project, m),
                              Project.get_loaded_info (project, m))
			   end

		       val (sub_time, basis) =
			 case loaded_info
			 of NONE =>
			   Crash.impossible
			     ("No loaded info for `"
			      ^ sub_module_name ^ "' in project")
			 |  SOME {load_time, result, ...} =>
			   case result
			   of Compiler.RESULT {basis, ...} =>
			       (load_time, basis)
                     in
                       ({mod_name = ModuleId.string full_module_id,
			 req_name = sub_module_name,
			 time = sub_time}
			 ::dependencies,
                        ModuleId.string full_module_id,
			basis)
                     end

                   val (dependencies, compiler_result) =
                     Compiler.compile
		       (error_info, options)
		       require_function
                       ([], initial_compiler_basis, true)
                       (is_pervasive, Compiler.TOKENSTREAM token_stream)
                 in
                   close_in instream;
                   (dependencies, compiler_result)
                 end
                 handle exn => (close_in instream; raise exn)
               end

             val result =
               load'
		 debugger
		 initial_inter_env
		 (error_info, location, options)
		 preloaded_opt
	         (project, module_id, module_str, accumulated_info,
                  compiler_result, time, dependencies)
           in
             result
           end
a999 1

@


1.87
log
@Changed information stored in project for loaded compilation units.
@
text
@d11 3
d743 1
a743 1
	     pervasive_info
d770 1
a770 1
	       case pervasive_info
d838 1
a838 1
	     pervasive_info
d842 2
a843 5

	     val is_pervasive =
	       case pervasive_info 
	       of SOME _ => true
	       |  NONE => false
d950 1
a950 1
		 pervasive_info
@


1.86
log
@Removing Option in favour of MLWorks.Option
@
text
@d11 3
d431 1
a431 1
	    of SOME (time, compiler_result, module, Project.CONSISTENCY cons) =>
d433 1
a433 1
                val Compiler.RESULT{id_cache,...} = compiler_result
d436 1
a436 1
                (stamp_start, stamp_no, cons)
d446 2
a447 1
            val (stamps, stamp_no, consistency) = lookupmodname modname
d454 1
a454 1
               (map #mod_name consistency))
d465 2
a466 1
        val {parser_env, type_env, lambda_env, stamps, consistency} =
a468 5
        val (src_time,consistency') =
          case consistency of
            ({time=src_time, ...}::consistency') => (src_time,consistency')
          | _ => Crash.impossible "Empty consistency info"
          
d476 1
a476 1
        val subnames = map #mod_name consistency'
d521 1
d528 1
a528 1
        val (mo_name, time, cons) =
d530 6
a535 1
          of SOME (file_name, time, _, cons) => (file_name, time, cons)
d546 8
d557 8
a564 1
	   SOME (time, compiler_result, module, cons));
d678 17
a694 16
		   Encapsulate.output_file false
		   {filename=mo_name,
		    code=module,
		    stamps=stamp_no,
		    parser_env=parser_basis,
		    type_basis=type_basis,
		    debug_info=debug_info,
		    require_list=require_list,
		    lambda_env=lambda_environment,
		    consistency=
                    {mod_name=module_str, req_name=module_str, time=time} ::
		    map
		    (fn {mod_name=mod_id, req_name=req_id, ...} =>
		     let
		       val mod_id = ModuleId.string mod_id
		       val req_id = ModuleId.string req_id
d696 1
a696 1
                       val _ = output(std_out,mod_id^"\n")
d698 5
a702 4
		     in
		       {mod_name=mod_id, req_name=req_id, time=Map.apply'(done, mod_id)}
		     end)
		    (rev dependencies)};
d734 4
a737 4
  (* This is extracted from the old make function. *)

    (* Load a compiler_result and return an updated project and debug_info *)
    fun load' debugger
d742 1
a742 1
              compiler_result, src_time, dependencies) = 
d781 1
a781 1
		       of SOME (_, _, module, _) => module
a815 6
	     val consistency =
               {mod_name = ModuleId.string module_id,
		req_name = ModuleId.string module_id,
		time=src_time}
		:: dependencies
	       
d820 6
a825 2
		  SOME (MLWorks.Time.now(), compiler_result, module,
		        Project.CONSISTENCY consistency))
d831 2
a832 5


  (* This is extracted from the old make function. *)

 fun compile debugger
d852 1
d919 2
a920 2
			 |  SOME (time, compiler_result, _, _) =>
			   case compiler_result
d922 1
a922 1
			     (time, basis)
d956 1
d958 1
a958 1
  end
@


1.85
log
@Now passes debug info around as accumulated info instead of a basis.
@
text
@d11 3
d515 1
a515 1
             code = Compiler.Option.ABSENT,
d643 1
a643 1
		    Compiler.Option.PRESENT module => module
d765 1
a765 1
                       Compiler.Option.ABSENT =>
d771 1
a771 1
                     | Compiler.Option.PRESENT code' => 
d787 1
a787 1
	         {code=Compiler.Option.ABSENT,
@


1.84
log
@Changed to use projects.
@
text
@d11 3
d734 6
d769 2
a770 10
                         let 
                           val debug_info =
                             (* For now, set debug to true *)
                             Debugger_Types.augment_information
			       (generate_debug_info,
				get_basis_debug_info accumulated_info,
                                get_basis_debug_info basis)
                         in
                           (with_debug_information
                            debug_info
d776 4
a779 5
                           (* If an exception escapes, its probably been
			      handled by the debugger, so just return the
			      project in the Interrupted exception *)
                           handle exn => raise Interrupted (project)
                         end
a780 4

             val accumulated_info =
               augment_accumulated_info
		 (options, accumulated_info, basis)
@


1.83
log
@Improving error message for being unable to find an mo file.
@
text
@d11 3
d299 1
d315 1
d332 1
a332 1
    Encapsulate.ParserEnv.Map
d334 1
d336 2
a337 1
  sharing type Compiler.Options.print_options = Encapsulate.Debugger_Types.printOptions
d341 2
a342 1
  sharing type Compiler.DebugInformation = Encapsulate.Debugger_Types.information
d345 2
a346 2
  sharing type ModuleId.ModuleId = Compiler.Absyn.ModuleId = Module.ModuleId =
	       Io.ModuleId
d348 4
a351 2
  sharing type Encapsulate.EnvironTypes.LambdaTypes.Ident.ValId = Compiler.Absyn.Ident.ValId
  sharing type Encapsulate.EnvironTypes.LambdaTypes.Ident.StrId = Compiler.Absyn.Ident.StrId
d355 1
d371 5
d380 2
a381 1
    val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
a382 50
    datatype result =
      RESULT of {name		: ModuleId.ModuleId,
                 time		: MLWorks.Time.time,
                 load_time    	: MLWorks.Time.time,
                 (* first time is .sml mod time, second is load time *)
                 dependencies	:
			{mod_name : Compiler.Absyn.ModuleId,
			 req_name : Compiler.Absyn.ModuleId,
                         time : MLWorks.Time.time,
                         load_time : MLWorks.Time.time} list,
                 compiler_result: Compiler.result,
                 module		: MLWorks.Internal.Value.T}

    datatype make_result =
      EXECUTE of result * string list
    | NO_EXECUTE of string list

    type modules = (string, result) Map.T
    type cache = modules

    datatype action_required =
      RECOMPILE |
      NONE

    (* daveb, 26/7/94: I've removed the inter_env component of the
       accumulated info.  As far as I can see, the modules component
       isn't used either, and the basis component is only used
       in the load function. *)
    fun augment_accumulated_info(options, (basis,modules),basis',modules') =
      (Compiler.augment(options, basis,Compiler.make_external basis'),
       Map.merge (fn (_,a) => a) (modules,modules'))

    val empty_modules = (Map.empty' String.<)
    val empty_cache = empty_modules

    val add_module = Map.define

    exception Lookup of string

    fun lookup_module (modules, string) =
      Map.apply' (modules, string)
      handle Map.Undefined => raise Lookup string


    datatype options =
      OPTIONS of {name_monitor	: (string -> unit) MLWorks.Option.option,
                  error_info    : Info.options,
                  options       : Options.options}

    val adjust_compiler_basis_debug_info  = Compiler.adjust_compiler_basis_debug_info
d385 2
a386 2
    exception Error of modules * Info.error * Info.error list
    exception Interrupted of modules
a387 2
    fun is_pervasive_library module_id =
      module_id = Io.pervasive_library_id
d392 1
a392 22
    val pervasives =
      ["__pervasive_library","__builtin_library","mlworks","bits",
       "string","bytearray","vector","array"]

    fun is_perv module_id = Lists.member (module_id, pervasives)

    fun get_mo_file ((MLWorks.Option.SOME (filename, module,_),_), _, _) =
      (*Module.mo_name module*)filename
      | get_mo_file (_, modname, location) =
        Info.error' (Info.make_default_options ())
                    (Info.FATAL, location, "cannot find .mo file for module " ^ modname)

    fun complete_filename (module_id, location) =
      let
	val module =
          if is_perv (ModuleId.string module_id) then
            Module.find_pervasive_mo (module_id, Module.empty_cache)
          else
            Module.find_mo (module_id, Module.empty_cache)
      in
        get_mo_file (module, ModuleId.string module_id, location)
      end
d412 1
a412 1
    fun get_subrequires (acc,modname,dir,modules) =
a413 1
        val modname = extend_name (modname,dir)
d416 16
a431 10
        fun lookupmodname (modname,modules) =
          let 
            val RESULT {dependencies,compiler_result,...} = 
              lookup_module (modules, modname)
              handle Lookup s => Crash.impossible ("Unknown module: " ^ s)
            val Compiler.RESULT{id_cache,...} = compiler_result
            val Compiler.ID_CACHE{stamp_start,stamp_no} = id_cache
          in
            (stamp_start,stamp_no,dependencies)
          end
d437 2
a438 2
            val (stamps,stamp_no,consistency) = 
              (lookupmodname (modname,modules)) handle Lookup _ => raise GetSubRequires modname
d441 4
a444 9
              (fn (acc,modname) =>
               let
                 val modname = extend_name (modname,dir)
                 val dir = get_mod_dir modname
               in
                 get_subrequires (acc,modname,dir,modules)
               end)
              ((modname,(stamps,stamp_no)) :: acc,
               (map (ModuleId.string o #mod_name) consistency))
d450 1
a450 17
    exception GetMoInformation = Encapsulate.BadInput

    fun get_mo_dependencies (module_id, location) =
      let
	val mo_name = complete_filename (module_id, location)
        val {stamps, consistency} =
          Encapsulate.input_info mo_name
      in
        (* THIS ASSUMES THAT THE FIRST 2 ITEMS ON THE CONSISTENCY LIST ARE
	   THE FILE ITSELF AND THE PERVASIVE LIBRARY *)
        case (map #mod_name consistency) of
          (_ :: _ :: result) => result
        | _ => Crash.impossible
		 "Intermake: Wrong dependencies in get_mo_dependencies"
      end
      
    fun get_mo_information (module_id,module,modules,location) =
d454 2
a455 3
        val mo_name = complete_filename (module_id,location)
        val {parser_env, type_env, lambda_env,
             stamps, consistency} =
a471 18
        val dependencies =
          map
          (fn {mod_name=modname, req_name=reqname, ...} =>
             let
               val RESULT {time,load_time,...} =
		 lookup_module (modules, modname)
             in
               {mod_name=
		  ModuleId.from_string (modname, Info.Location.FILE mo_name),
	        req_name=
		   ModuleId.from_string (reqname, Info.Location.FILE mo_name),
	        time=time,
	        load_time=load_time}
             end
	     handle Lookup s =>
	       Crash.impossible ("Non existent dependency: " ^ s))
          (rev consistency')
          
d480 1
a480 1
             get_subrequires (acc,modname,dir,modules)
d485 4
a488 1
	  Map.from_list' op< (map (fn (x as (name, value)) => (name, x)) require_list)
d491 1
a491 1
          (type_env, modname, require_table, false)
d493 10
a502 8
        val compiler_basis = Compiler.BASIS {parser_basis = parser_env,
                                             type_basis = type_basis,
                                             lambda_environment = lambda_env,
                                             debugger_environment =
                                             Inter_EnvTypes.EnvironTypes.DENV
                                             (Map.empty (Ident.valid_lt,Ident.valid_eq),
                                              Map.empty (Ident.strid_lt,Ident.strid_eq)),
                                             debug_info = debug_info}
d504 7
a510 17
        val compiler_result = Compiler.RESULT {basis = compiler_basis,
                                               signatures = Map.empty (Ident.sigid_lt,Ident.sigid_eq),
                                               identifiers = Compiler.extract_identifiers ([],type_basis),
                                               code = Compiler.Option.ABSENT,
                                               id_cache = id_cache}
          
        val mo_time =
          case Os.mtime mo_name of
            Os.EXISTS time => time
          | Os.NOT_EXIST => Crash.impossible "Can't find timestamp for file just read"
              
        val result = RESULT {name = module_id,
                             time = src_time,
                             load_time = mo_time,
                             dependencies = dependencies,
                             compiler_result = compiler_result,
                             module = module}
d512 1
a512 1
        result
d515 40
d689 1
d705 1
a705 15
    (* The pervasive argument tells us if we are compiling the pervasives *)
    (* This affects how module names are looked up and is passed to the compiler *)
    (* preloaded is a list of pervasive modules that are not to be re-loaded *)
    fun make debugger
             (initial_compiler_basis, initial_inter_env)
             (OPTIONS{name_monitor,error_info,
		      options = options as
		      Options.OPTIONS{compiler_options =
				      Options.COMPILEROPTIONS{no_execute,generate_debug_info, ...}, ...}})
             (preloaded, pervasive)
             (modules, module_id, toplevel_name) =
      let

        (* Make the cache a local ref *)
        (* A cache of module ids and results.  This is local to each make, and can be trusted. *)
d707 7
a713 48
        val cache_ref = ref empty_cache
        fun cache_lookup modname = Map.tryApply' (!cache_ref, modname)
        fun cache_define (modname,result) =
          cache_ref := Map.define (!cache_ref, modname, result)

        (* A ref used to store the current module table *)

        val modules_ref = ref modules
        fun modules_lookup modname = Map.tryApply' (!modules_ref, modname)
        fun modules_define (modname,result) =
          modules_ref := Map.define (!modules_ref, modname, result)
        fun current_modules () = !modules_ref

        (* Accumulate a list of files compiled here *)
        val done_ref = ref []
        fun add_done filename = done_ref := filename:: !done_ref
        fun get_dones () = !done_ref

        fun get_top_module seen = 
          case seen of
            h :: _ => h
          |  _ => toplevel_name

        fun error (message,seen) =
            Info.error' error_info (Info.FATAL, Info.Location.FILE (get_top_module seen), message)

        (* Use of the seen list to find the module id seems a hack *)
        fun check_circularity (module_name,seen) =
          if Lists.member (module_name,seen) then
            let fun print_seen' [] = []
                  |   print_seen' [_] = []
                  |   print_seen' [x, _] = ["and ", x]
                  |   print_seen' (h::t) = h :: ", " :: print_seen' t
                      
                fun print_seen [] = []
                  |   print_seen [_] = []
                  |   print_seen [x, _] = ["from ", x]
                  |   print_seen l = ", via " :: print_seen' l
            in
              error (implode (["Circular definition of ", module_name] @@
                              print_seen seen),
                     seen)
            end
          else ()

        (* Load a compiler_result and return a Result object *)
        fun load (module_id, module_str,accumulated_info,
                  compiler_result, time, dependencies, seen) = 
d716 9
d728 1
d730 1
d732 8
a739 10
               if no_execute
                 then castit []
               else
                 if pervasive
                   then
                     (* When compiling pervasives get module from preloaded list *)
                     (* This is actually almost MLWorks.Internal.Runtime.modules *)
                     Lists.assoc (module_str, preloaded)
                     handle Lists.Assoc => Crash.impossible "No pervasive modules!"
                 else
a741 2
                     val modules = current_modules()
                     (* Note that there is no handling of the Undefined exception *)
d743 8
a750 5
                       let
                         val RESULT {module, ...} = Map.apply' (modules, module_str)
                       in
                         module
                       end
d753 6
a758 3
                       Compiler.Option.ABSENT => error (implode ["`", module_str,
                                                                 "' database entry has no code recorded."],
                                                        seen)
a760 1
                           val  (cb, m) = accumulated_info
d763 4
a766 3
                             Debugger_Types.augment_information(generate_debug_info,
                                                                get_basis_debug_info cb,
                                                                get_basis_debug_info basis)
d775 4
a778 3
                           (* If an exception escapes, its probably been handled by the debugger *)
                           (* So just return the modules in the Interrupted exception *)
                           handle exn => raise Interrupted (current_modules())
d784 1
a784 1
		 (options, accumulated_info, basis, modules)
d786 20
a805 13
             val result =
               RESULT {name = module_id,
                       time = time,
                       load_time = MLWorks.Time.now(),
                       dependencies = dependencies,
                       compiler_result =
                         Compiler.RESULT
			   {code=Compiler.Option.ABSENT,
			    basis=basis,
			    signatures=signatures,
			    identifiers=identifiers,
			    id_cache=id_cache},
		       module = module}
a807 2
             val _ = cache_define (module_str, result)
             val _ = modules_define (module_str, result)
d809 1
a809 1
             (module_id, result,accumulated_info)
a811 1
	datatype Source = CACHED of result | FILE of Module.Module
d813 1
a813 39
        (* Note that seen is only used for error reports *)
	fun find_source (mod_path, sub_module_id,seen) =
	  let
	    val module_id =
	      if pervasive
                then sub_module_id
	      else
		ModuleId.add_path (mod_path, sub_module_id)
	    (* This allows non-pervasives to require the pervasive library *)
	    val module_str = ModuleId.string module_id
            val in_cache = 
              (check_circularity (module_str,seen);
               cache_lookup module_str)
	  in
            (* If the module is in the cache then it is known to be up to
	       date during this phase. *)
            case in_cache of
              MLWorks.Option.SOME result =>
                (CACHED result, module_id, module_str)
            | MLWorks.Option.NONE =>
	        if pervasive then
		  (FILE (Module.MODULE (Io.get_pervasive_dir(), module_id)),
		   module_id, module_str)
          	  handle Io.NotSet _ =>
                    error ("Pervasive directory not set",seen)
		else
	          case Module.find_sml (module_id, Module.empty_cache) of
		    (MLWorks.Option.SOME (_, f, _), _) =>
		      (FILE f, module_id, module_str)
		  | (MLWorks.Option.NONE, _) =>
(*
		      find_source
		      (ModuleId.parent mod_path, sub_module_id,seen)
		      handle ModuleId.NoParent =>
*)
			error (implode ["can't find module `",
					module_str, "' on search path"],
                               seen)
	  end
d815 7
a821 39
	(* level:	  The depth of the search.  Only used in diagnostics.
	   mod_path:      The path of the current module name
	   sub_module_id: The id of the module to check
	 *)
	 (* Returns:
	    ((full_module_id, result,accumulated_info),
	     action_required)
	   full_module_id:  module_id of the module found after searching the
			    path.
	   result:	    As per the datatype.
	   action_required: As per the datatype.
	 *)

        fun up_to_date (level,mod_path,
			sub_module_id, seen, accumulated_info) =
	   case find_source (mod_path, sub_module_id,seen) of
	     (CACHED result, module_id, module_str) =>
	       (diagnostic
		(3, fn _ => [module_str, " cached as up to date"]);
		((module_id, result, accumulated_info),
		 NONE))
	   | (FILE file, module_id, module_str) =>
	       let
		 val root_module_name = Module.module_id file
		 val root_module_name_string = ModuleId.string root_module_name
		 val module_str = root_module_name_string
		 val module_id = root_module_name
	       in
		 case modules_lookup module_str of
		   (* If the module isn't in the module table then it needs to be made. *)
		   MLWorks.Option.NONE =>
		     (diagnostic (3, fn _ => [module_str, " never compiled"]);
		      compile (level,module_id, module_str,
			       Module.sml_name file,
			       seen, accumulated_info))

		   (* If the module does have source then check the
		    timestamps of it and its dependencies.  (If the source
		    doesn't exist then it's implicitly up to date.) *)
d823 21
a843 106
		   | MLWorks.Option.SOME (result as RESULT {time, dependencies, 
						compiler_result, ...}) =>
		     let
		       val filename = Module.sml_name file
		       val Compiler.RESULT{basis,...} = compiler_result
		     in
		       case Os.mtime filename of
			 Os.NOT_EXIST =>
			   (diagnostic (3, fn _ => [module_str, " has no source (assumed up to date)"]);
			    cache_define (module_str, result);
			    ((module_id, result,
			      augment_accumulated_info
				(options, accumulated_info, basis, modules)),
			     NONE))

		       | Os.EXISTS new_time =>
			   if not (time = new_time) then
			     (diagnostic
			      (3, fn _ => [module_str,
					   " is out of date wrt source"]);
			      compile (level,module_id,
				       module_str, filename, seen,
				       accumulated_info))
			   else
			     compile_sub_modules
			     (level,module_id,
			      module_str, filename, result, seen,
			      accumulated_info)
		     end
	       end

	and compile_sub_modules (level,module_id, module_str,
				 filename,
				 result as RESULT {time, dependencies,
					           compiler_result, ...},
				 seen, accumulated_info) =
          let
            (* The made module is up to date wrt to its source, but possibly
	       not wrt its dependencies, so bring them up to date and check
	       that the resulting time stamps match. Both the sml modification times
               and the load time (ie. the last compilation time) must match *)

	    val Compiler.RESULT {basis,...} = compiler_result

            fun check ([], accumulated_info) = 
              (NONE, accumulated_info)
	      | check ({mod_name=sub_module_id, req_name=sub_req_id, time=time, load_time=load_time} :: rest,
		       accumulated_info) =
                if is_pervasive_library sub_module_id then
		  (diagnostic (3, fn _ => ["Ignoring pervasive library in compile_sub_modules"]);
		   check (rest,accumulated_info))
                else
                  let
                    val _ = diagnostic
                      (4, fn _ => ["checking ", module_str, " dependency ",
                                   ModuleId.string sub_module_id]);
                    val ((_,
                          RESULT {time = new_time,
                                  load_time = new_load_time,
                                  ...},
                          accumulated_info),
		      action_required) =
                      (up_to_date (level,
                                   ModuleId.path module_id, sub_req_id(*sub_module_id*),
                                   module_str :: seen, accumulated_info))
                  in
                    if time = new_time andalso load_time = new_load_time then
		      (diagnostic
		       (4, fn _ => [module_str, " dependency ",
				    ModuleId.string sub_module_id,
				    " checked OK"]);
		       check (rest, accumulated_info))
                    else
                      (RECOMPILE, accumulated_info)
                  end
          in
            case check (dependencies, accumulated_info) of
	      (NONE, accumulated_info) =>
		(diagnostic (3, fn _ => [module_str, " is up to date!"]);
		 cache_define (module_str,result);
		 ((module_id,result,
		   augment_accumulated_info (options, accumulated_info, basis,
					     current_modules())),
		  NONE))

            |  (RECOMPILE, accumulated_info) =>
		 (diagnostic (3, fn _ => [module_str," is out of date wrt dependencies"]);
		  compile (level,module_id, module_str, filename,
			   seen, accumulated_info))
          end

        and compile (level,module_id, module_str,
		     filename, seen, accumulated_info) =
          (if no_execute
             then ()
           else
             (diagnostic (2, fn _ => [MLWorks.Integer.makestring level,
                                      " compiling ", module_str, " as ", filename]);
              
              case name_monitor of
                MLWorks.Option.SOME f =>
                  let fun spaces y =
                    if y <= 0 then module_str else ("   " ^ spaces (y-1))
                  in f (spaces level ^ "\n")
                  end
              | MLWorks.Option.NONE => ());
d845 1
a845 12
           check_circularity (module_str, seen);

           let
             val new_seen = module_str :: seen
             val time =
               case Os.mtime filename of
                 Os.EXISTS time => time
               | Os.NOT_EXIST =>
                   error (implode ["can't find module `",filename, "' on search path"],
                          new_seen)

             val (dependencies, compiler_result,accumulated_info) =
d847 2
a848 1
                 val instream = open_in filename
d850 4
a853 3
                     Info.error' error_info (Info.FATAL,
                                             Info.Location.FILE filename,
                                             "Io error during make, " ^ message)
d859 1
a859 1
                         if pervasive then "<Pervasive>"
d865 2
a866 2
                   fun require_function ((dependencies,accumulated_info), 
                                         sub_module_id, source_location) =
d871 1
a871 1
                                      ModuleId.string sub_module_id])
d873 32
a904 26
                       val ((full_module_id,
                             RESULT {time, 
                                     load_time,
                                     compiler_result = Compiler.RESULT {basis, ...},
                                     ...},
                             accumulated_info), _) =
                         (* don't check the pervasive library *)
                         if is_pervasive_library sub_module_id
                           then
                             let
                               val pervasive_library_result =
                                 case modules_lookup Io.pervasive_library_name
                                   of
                                     MLWorks.Option.NONE => Crash.impossible "No pervasive library in modules"
                                   | MLWorks.Option.SOME result => result
                             in
                               ((sub_module_id,
                                 pervasive_library_result,
                                 accumulated_info),
                                NONE)
                             end
                         else
                           up_to_date
                           (level+1,
                            ModuleId.path module_id, sub_module_id,
                            new_seen,accumulated_info)
d906 6
a911 2
                       (({mod_name=full_module_id, req_name=sub_module_id, time=time,load_time=load_time}::dependencies,accumulated_info),
                        ModuleId.string full_module_id,basis)
d914 6
a919 4
                   val ((dependencies,accumulated_info), compiler_result) =
                     Compiler.compile (error_info,options) require_function
                     (([],accumulated_info), initial_compiler_basis, true)
                     (pervasive, Compiler.TOKENSTREAM token_stream)
d922 1
a922 2
                   add_done filename;
                   (dependencies,compiler_result, accumulated_info)
d926 1
d928 7
a934 3
               load (module_id, module_str,accumulated_info,
                     compiler_result, time,
                     dependencies,seen)
d936 2
a937 38
             (result, RECOMPILE)
           end)
      in
        (diagnostic (1, fn _ => ["Making `", ModuleId.string module_id, "'"]);
         let
	   val modules' = modules
           val initial_debug_info =
	     (initial_compiler_basis, empty_modules)
           val ((_, result, accumulated_info), _) =
             up_to_date (0,ModuleId.empty_path,
			 module_id, [], initial_debug_info)
            val RESULT
		  {name,time,load_time,dependencies,compiler_result,module} =
	      result
            val Compiler.RESULT{basis,signatures,identifiers,code,id_cache} = compiler_result
            val result' =
              RESULT{name=name,
                     time=time,
                     load_time=load_time,
                     dependencies=dependencies,
                     compiler_result=
                     Compiler.RESULT{basis=adjust_compiler_basis_debug_info
                                     (basis,get_basis_debug_info (#1 accumulated_info)),
                                     signatures=signatures,
                                     identifiers=identifiers,
                                     code=code,
                                     id_cache = id_cache},
                     module=module}
            val done = rev (get_dones())
         in
	   (if no_execute 
              then (modules', NO_EXECUTE done)
	    else (current_modules (), EXECUTE (result',done)))
         end
       handle
       Interrupt => raise Interrupted (current_modules())
     | Info.Stop (error,error_list) => raise Error (current_modules(),error,error_list))
      end
a938 12
    fun delete_module(modules,
                      module_id,
                      error_info) =
      let val modname = ModuleId.string module_id
      in
        case Map.tryApply'(modules, modname) of
          MLWorks.Option.SOME _ =>
            Map.undefine(modules, modname)
        | MLWorks.Option.NONE => 
            (diagnostic (1, fn _ => ["Module ", modname, " not found"]);
             modules)
      end
@


1.82
log
@Improving load_mo errors
@
text
@d11 3
d437 1
a437 1
                    (Info.FATAL, location, "cannot find module " ^ modname)
@


1.81
log
@New module naming stuff
@
text
@d11 3
d503 1
a503 1
    exception GetMoInformation
a509 2
          handle exn as Encapsulate.BadInput s =>
            raise GetMoInformation
a526 2
          handle exn as Encapsulate.BadInput s =>
            raise GetMoInformation
@


1.80
log
@Change type of decode_type_basis to take a btree
@
text
@d11 3
d427 2
a428 2
    fun get_mo_file ((MLWorks.Option.SOME (module,_),_), _, _) =
      Module.mo_name module
d683 1
a683 1
		      (MLWorks.Option.SOME(module, _), _) => module
d929 6
a934 5
	          case Module.find_sml (module_id, Module.empty_cache)
		  of (MLWorks.Option.SOME (f, _), _) =>
		    (FILE f, module_id, module_str)
		  |  (MLWorks.Option.NONE, _) =>
		    find_source
d937 1
@


1.79
log
@Change Tyfun_id etc to Stamp
@
text
@d11 3
d317 2
a318 1
  sharing Compiler.NewMap = InterLoad.Inter_EnvTypes.EnvironTypes.NewMap
d559 1
a559 1
        val require_list' = 
d570 2
a571 2
        val require_list = rev require_list'
          
d574 1
a574 1
          (type_env, modname, require_list, false)
@


1.78
log
@Changes to Debugger_Types and CompilerOptions
@
text
@d11 3
d287 1
d306 1
d330 2
a345 3
    structure Tyname_id = Datatypes.Tyname_id
    structure Strname_id = Datatypes.Strname_id
    structure Tyfun_id = Datatypes.Tyfun_id
d459 1
a459 1
          | test ((m',_,_,_)::l) = modname = m' orelse test l
d466 1
a466 2
            val Compiler.ID_CACHE{tyname_start,strname_start,tyfun_start,
                                  tyname_no,strname_no,tyfun_no} = id_cache
d468 1
a468 1
            (tyname_start,tyname_no,strname_start,strname_no,tyfun_start,tyfun_no,dependencies)
d475 1
a475 1
            val (tynames,tyname_no,strnames,strname_no,tyfuns,tyfun_no,consistency) = 
d486 1
a486 1
              ((modname,(tynames,tyname_no),(strnames,strname_no),(tyfuns,tyfun_no)) :: acc,
d498 1
a498 1
        val {tynames, strnames, tyfuns, consistency} =
d517 1
a517 1
             tynames, strnames, tyfuns, consistency} =
d527 6
a532 14
        val tyname_count = Tyname_id.read_counter ()
        val strname_count = Strname_id.read_counter ()
        val tyfun_count = Tyfun_id.read_counter ()
          
        val _ = Tyname_id.reset_counter (tyname_count + tynames)
        val _ = Strname_id.reset_counter (strname_count + strnames)
        val _ = Tyfun_id.reset_counter (tyfun_count + tyfuns)
          
        val id_cache = Compiler.ID_CACHE{tyname_start = tyname_count,
                                         strname_start = strname_count,
                                         tyfun_start = tyfun_count,
                                         tyname_no = tynames,
                                         strname_no = strnames,
                                         tyfun_no = tyfuns}
d564 1
a564 1
          ([(modname,(tyname_count,tynames),(strname_count,strnames),(tyfun_count,tyfuns))],subnames)
d626 1
a626 1
              | test ((m',_,_,_)::l) = modname = m' orelse test l
d641 1
a641 2
                val Compiler.ID_CACHE{tyname_start,strname_start,tyfun_start,
                                      tyname_no,strname_no,tyfun_no} = id_cache
d647 1
a647 3
                      (tyname_start,tyname_no),
                      (strname_start,strname_no),
                      (tyfun_start,tyfun_no)) :: acc,
d671 1
a671 1
                  val Compiler.ID_CACHE{tyname_no,strname_no,tyfun_no,...} = id_cache
d701 1
a701 3
		    tynames=tyname_no,
		    strnames=strname_no,
		    tyfuns=tyfun_no,
@


1.77
log
@Replaced UNIX-specific pathname mangling.
@
text
@d11 3
d307 1
a307 2
  sharing InterLoad.Inter_EnvTypes.Options =
    Compiler.Options = Encapsulate.Debugger_Types.Options
d312 1
a399 1
    val augment_debug_info = Debugger_Types.augment_information
a760 3
    fun get_no_execute (Options.OPTIONS{compiler_options = Options.COMPILEROPTIONS{no_execute,...}, ...}) =
      no_execute

d769 1
a769 1
				      Options.COMPILEROPTIONS{no_execute, ...}, ...}})
a773 2
        val no_execute = get_no_execute options

d861 4
a864 2
			     augment_debug_info(options, get_basis_debug_info cb,
						get_basis_debug_info basis)
@


1.76
log
@Changes to type of Encapsulate.decode_type_basis
@
text
@d11 3
a401 1
    (* This should be done better *)
d405 6
a410 1
    (* This is a hacked up mini module naming system *)
d412 1
a412 1
    val pervasives = ["__pervasive_library","__builtin_library","mlworks","bits","string","bytearray","vector","array"]
d414 1
a414 3
    fun is_perv modname = Lists.member (modname,pervasives)
      
    fun get_mo_file ((MLWorks.Option.SOME (module,_),_),modname) =
d416 1
a416 1
      | get_mo_file (_,modname) =
d418 1
a418 1
                    (Info.FATAL, Location.UNKNOWN, "cannot find module " ^ modname)
d420 1
a420 2

    fun complete_filename (filename,location) =
d422 5
a426 1
        val modname = ModuleId.from_host(filename,location)
d428 1
a428 5
        if is_perv filename
          then
            get_mo_file (Module.find_pervasive_mo (modname,Module.empty_cache),filename)
        else
          get_mo_file (Module.find_mo (modname,Module.empty_cache),filename)
d442 2
a443 1
      if get_mod_dir modname = "" andalso not (dir = "") andalso not (is_perv modname)
d490 1
a490 1
    fun get_mo_dependencies (filename,location) =
d492 1
a492 1
        val mo_name = complete_filename (filename,location)
d498 2
a499 1
        (* THIS ASSUMES THAT THE FIRST 2 ITEMS ON THE CONSISTENCY LIST ARE THE FILE ITSELF AND THE PERVASIVE LIBRARY *)
d502 2
a503 1
        | _ => Crash.impossible "Intermake: Wrong dependencies here"
d506 1
a506 1
    fun get_mo_information (filename,module,modules,location) =
a507 1
	val module_id = ModuleId.from_host(filename, location)
d510 1
a510 1
        val mo_name = complete_filename (filename,location)
d542 13
a554 5
           let
             val RESULT {time,load_time,...} = lookup_module (modules, modname)
           in
             {mod_name=ModuleId.from_string(modname, Info.Location.FILE filename), req_name=ModuleId.from_string(reqname, Info.Location.FILE filename),time=time,load_time=load_time}
           end handle Lookup s => Crash.impossible ("Non existent dependency: " ^ s))
@


1.75
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d11 3
d557 1
a557 1
        val (type_basis, debug_information) =
d568 1
a568 1
                                             debug_info = Debugger_Types.INFO debug_information}
@


1.74
log
@Move OS specific stuff into a system link directory
@
text
@d11 3
a299 1
  sharing Compiler.Option = Module.Option
a311 1
  sharing type Module.Directory = Io.Directory
a319 1
    structure Option = Module.Option
d385 3
a387 3
      OPTIONS of {name_monitor		: (string -> unit) Option.opt,
                  error_info            : Info.options,
                  options	        : Options.options}
d406 1
a406 1
    fun get_mo_file ((Option.PRESENT (module,_),_),modname) =
d415 1
a415 1
        val modname = ModuleId.from_string(filename,location)
a423 3
    fun trans_filename name =
      implode (map (fn "/" => "." | c => c) (explode name))

d498 3
a500 2
        val modname = trans_filename filename
        val dir = get_mod_dir modname
d570 1
a570 1
                                               code = Option.ABSENT,
d578 1
a578 1
        val result = RESULT {name = ModuleId.from_string(filename, location),
d665 1
a665 1
		      (Option.PRESENT(module, _), _) => module
d724 1
a724 1
                  ModuleId.from_string(filename,location));
d917 1
a917 1
		  of (Module.Option.PRESENT (f, _), _) =>
d919 1
a919 1
		  |  (Module.Option.ABSENT, _) =>
d1068 1
a1068 1
                Option.PRESENT f =>
d1073 1
a1073 1
              | Option.ABSENT => ());
@


1.73
log
@Changing uses of cast
@
text
@d11 3
d272 1
a272 1
require "../make/unix";
d292 1
a292 1
  structure Unix : UNIX
d576 3
a578 3
          case Unix.mtime mo_name of
            Unix.EXISTS time => time
          | Unix.NOT_EXIST => Crash.impossible "Can't find timestamp for file just read"
d597 3
a599 3
	    case Unix.mtime(Module.mo_name module) of
	      Unix.EXISTS time => time
	    | Unix.NOT_EXIST =>
d715 2
a716 2
			      case Unix.mtime mo_name of
				Unix.EXISTS time => time
d976 2
a977 2
		       case Unix.mtime filename of
			 Unix.NOT_EXIST =>
d985 1
a985 1
		       | Unix.EXISTS new_time =>
d1082 3
a1084 3
               case Unix.mtime filename of
                 Unix.EXISTS time => time
               | Unix.NOT_EXIST =>
@


1.72
log
@Make NewMap return pervasive option
@
text
@d11 3
d335 2
d818 1
a818 1
                 then MLWorks.Internal.Value.cast []
@


1.71
log
@Removed code from the results of a load.  The necessary information is
in the module.  This saves 240K of unnecessary pervasive code in the
motif image.  Also removed inter_env component of Result type.
@
text
@d11 5
d616 1
a616 1
                    Map.YES result => result
d642 1
a642 1
	      Map.NO =>
d649 1
a649 1
		      Map.YES result => result
d901 1
a901 1
              Map.YES result =>
d903 1
a903 1
            | Map.NO =>
d952 1
a952 1
		   Map.NO =>
d962 1
a962 1
		   | Map.YES (result as RESULT {time, dependencies, 
d1119 2
a1120 2
                                     Map.NO => Crash.impossible "No pervasive library in modules"
                                   | Map.YES result => result
d1198 1
a1198 1
          Map.YES _ =>
d1200 1
a1200 1
        | Map.NO => 
@


1.70
log
@Update debugger information production
@
text
@d11 3
d338 1
a338 2
                 module		: MLWorks.Internal.Value.T,
                 inter_env	: Inter_EnvTypes.inter_env}
d351 5
a355 1
    fun augment_accumulated_info(options, (basis,inter_env,modules),basis',inter_env',modules') =
a356 1
       Inter_EnvTypes.augment(inter_env,inter_env'),
a469 5
    fun make_inter_env (lambda_environment,module) = 
      Inter_EnvTypes.augment_with_module (Inter_EnvTypes.empty_env, 
                                          lambda_environment, 
                                          module)

a561 2
        val inter_env = make_inter_env (lambda_env,module)
          
d572 1
a572 2
                             module = module,
                             inter_env = inter_env}
d802 3
a804 1
             val Compiler.RESULT {code, basis, ...} = compiler_result
d806 1
a806 1
             val (module,basis) =
d808 1
a808 1
                 then (MLWorks.Internal.Value.cast [], basis)
d814 1
a814 1
                     (Lists.assoc (module_str, preloaded), basis)
d834 1
a834 1
                           val  (cb,ie,m) = accumulated_info
d842 4
a845 3
                             (InterLoad.load
                              debugger (initial_inter_env, module_map) code',
                              basis)))
a851 1
             val inter_env = make_inter_env (lambda_environment,module)
d853 2
a854 1
               augment_accumulated_info(options, accumulated_info,basis,inter_env,modules)
d861 8
a868 3
                       compiler_result = compiler_result,
		       module = module,
                       inter_env = inter_env}
d958 1
a958 1
						compiler_result, inter_env, ...}) =>
d968 2
a969 1
			      augment_accumulated_info (options, accumulated_info, basis, inter_env, modules)),
d991 1
a991 1
					           compiler_result, inter_env, ...},
d1039 1
a1039 1
					     inter_env, current_modules())),
d1154 2
a1155 1
           val initial_debug_info = (initial_compiler_basis, Inter_EnvTypes.empty_env,empty_modules)
d1159 3
a1161 1
            val RESULT{name,time,load_time,dependencies,compiler_result,module,inter_env} = result
d1175 1
a1175 2
                     module=module,
                     inter_env=inter_env}
@


1.69
log
@Catch user exceptions raised during Interload.load
@
text
@d11 3
d349 2
a350 2
    fun augment_accumulated_info((basis,inter_env,modules),basis',inter_env',modules') =
      (Compiler.augment(basis,Compiler.make_external basis'),
d836 3
a838 2
                           val debug_info = (augment_debug_info(get_basis_debug_info cb,
                                                                get_basis_debug_info basis))
d854 1
a854 1
               augment_accumulated_info(accumulated_info,basis,inter_env,modules)
d963 1
a963 1
			      augment_accumulated_info (accumulated_info, basis, inter_env, modules)),
d1032 1
a1032 1
		   augment_accumulated_info (accumulated_info, basis,
@


1.68
log
@Fix require file names in consistency info.
Ensure canonical module names are used in the internal tables,
 and placed in saved mo files.
@
text
@d11 5
d836 9
a844 6
                           with_debug_information
                           debug_info
                           (fn () =>
                            (InterLoad.load
                             debugger (initial_inter_env, module_map) code',
                             basis))
@


1.67
log
@Add original require file names to consistency info.
@
text
@d11 3
d322 4
a325 3
			(ModuleId.ModuleId * 
                         MLWorks.Time.time *
                         MLWorks.Time.time) list,
d451 1
a451 1
               (map (ModuleId.string o #1) consistency))
d513 1
a513 1
          (fn modname =>
d517 1
a517 1
             (ModuleId.from_string(modname, Info.Location.FILE filename),time,load_time)
d519 1
a519 1
          (rev subnames)
d621 1
a621 1
                   (map #1 dependencies))
d645 1
a645 1
                  val sub_modules = map #1 dependencies
d654 2
a655 1
                  (* a module for a module loaded from an mo has no code, so can't be saved *)
d685 1
a685 1
		    (fn (id,_,_) =>
d687 5
a691 2
		       val str_id = ModuleId.string id
                       val _ = output(std_out,str_id^"\n")
d693 1
a693 1
		       {mod_name=str_id, req_name=str_id, time=Map.apply'(done, str_id)}
d922 48
a969 40
	       case modules_lookup module_str of
		 (* If the module isn't in the module table then it needs to be made. *)
		 Map.NO =>
		   (diagnostic (3, fn _ => [module_str, " never compiled"]);
		    compile (level,module_id, module_str,
			     Module.sml_name file,
			     seen, accumulated_info))

	  (* If the module does have source then check the
	   timestamps of it and its dependencies.  (If the source
	   doesn't exist then it's implicitly up to date.) *)

	       | Map.YES (result as RESULT {time, dependencies, 
					    compiler_result, inter_env, ...}) =>
		 let
		   val filename = Module.sml_name file
		   val Compiler.RESULT{basis,...} = compiler_result
		 in
		   case Unix.mtime filename of
		     Unix.NOT_EXIST =>
		       (diagnostic (3, fn _ => [module_str, " has no source (assumed up to date)"]);
                        cache_define (module_str, result);
			((module_id, result,
			  augment_accumulated_info (accumulated_info, basis, inter_env, modules)),
                         NONE))

		   | Unix.EXISTS new_time =>
		       if not (time = new_time) then
			 (diagnostic
			  (3, fn _ => [module_str,
				       " is out of date wrt source"]);
			  compile (level,module_id,
				   module_str, filename, seen,
				   accumulated_info))
		       else
                         compile_sub_modules
                         (level,module_id,
                          module_str, filename, result, seen,
                          accumulated_info)
		 end
d985 1
a985 1
            |   check ((sub_module_id, time,load_time) :: rest,
d987 3
a989 4
                if is_pervasive_library sub_module_id
                  then
                    (diagnostic (3, fn _ => ["Ignoring pervasive library in compile_sub_modules"]);
                     check (rest,accumulated_info))
a994 1
                    
d1000 1
a1000 1
                         action_required) =
d1002 1
a1002 1
                                   ModuleId.path module_id, sub_module_id,
d1005 6
a1010 8
                    if (time = new_time andalso
                        load_time = new_load_time)
                      then
                        (diagnostic
                         (4, fn _ => [module_str, " dependency ",
                                      ModuleId.string sub_module_id,
                                      " checked OK"]);
                         check (rest, accumulated_info))
d1015 8
a1022 8
            case check (dependencies, accumulated_info)
	    of (NONE, accumulated_info) =>
              (diagnostic (3, fn _ => [module_str, " is up to date!"]);
               cache_define (module_str,result);
               ((module_id,result,
                 augment_accumulated_info (accumulated_info, basis,
					   inter_env, current_modules())),
                NONE))
d1025 3
a1027 3
              (diagnostic (3, fn _ => [module_str," is out of date wrt dependencies"]);
               compile (level,module_id, module_str, filename,
			seen, accumulated_info))
d1110 1
a1110 1
                       (((full_module_id, time,load_time)::dependencies,accumulated_info),
@


1.66
log
@Changed make and delete_module to take module ids.
@
text
@d11 3
d469 1
a469 1
        case (map #1 consistency) of
d487 1
a487 1
            ((_,src_time)::consistency') => (src_time,consistency')
d505 1
a505 1
        val subnames = map #1 consistency'
d678 1
a678 1
                    (module_str, time) ::
d685 1
a685 1
		       (str_id, Map.apply'(done, str_id))
@


1.65
log
@Changes to the way dependency checking works.
@
text
@d11 3
a309 2
    type Module = Module.Module

d728 1
a728 1
             (modules, module, toplevel_name) =
d1118 1
a1118 1
        (diagnostic (1, fn _ => ["Making `", Module.sml_name module, "'"]);
d1124 1
a1124 3
			 Module.module_id module,
                         [],
                         initial_debug_info)
d1155 9
a1163 6
      case Map.tryApply'(modules, module_id) of
        Map.YES _ =>
          Map.undefine(modules, module_id)
      | Map.NO => 
          (diagnostic (1, fn _ => ["Module ", module_id, " not found"]);
           modules)
@


1.64
log
@Changed name of pervasive stream to <Pervasive> (helps with debug info)
@
text
@d11 3
d323 1
a323 1
      EXECUTE of result
d1016 14
a1029 3
          ((diagnostic (2, fn _ => [MLWorks.Integer.makestring level,
				    " compiling ", module_str, " as ", filename]);

a1031 8
           case name_monitor of
             Option.PRESENT f =>
	       let fun spaces y =
		     if y <= 0 then module_str else ("   " ^ spaces (y-1))
	       in f (spaces level ^ "\n")
	       end
           | Option.ABSENT => ();

d1115 1
a1115 1
           end))
d1144 3
a1146 9
	   (if no_execute then
	      (output(std_out, "Modules to be compiled\n");
	       Lists.iterate
	       (fn name => output(std_out, name ^ "\n"))
	       done)
	    else ());
	   (if no_execute then
	      (modules', NO_EXECUTE done)
	    else (current_modules(), EXECUTE result'))
@


1.63
log
@Reinstated load_time in Result
Dependencies also contain load_time value
I don't think it is broken any more.
@
text
@d11 5
d1045 7
a1051 1
                     Lexer.mkFileTokenStream (instream, filename)
@


1.62
log
@Use action_required to determine if recompilation is necessary in function check
rather than the times.
@
text
@d11 4
d304 2
d307 3
a309 1
			(ModuleId.ModuleId * MLWorks.Time.time) list,
d499 1
a499 1
             val RESULT {time,...} = lookup_module (modules, modname)
d501 1
a501 1
             (ModuleId.from_string(modname, Info.Location.FILE filename),time)
d547 1
d611 1
a611 1
	fun do_save(done, (module_id, _)) =
d629 2
a630 1
		  val done = Lists.reducel do_save (done, dependencies)
d668 1
a668 1
		    (fn (id, _) =>
d687 2
a688 3
	(do_save(Map.from_list' String.< [(Io.pervasive_library_name, pervasive_mo_stamp)],
		 (ModuleId.from_string(filename,location),
		  (* A dummy parameter *)MLWorks.Time.zero));
d827 1
d895 1
a895 1
	   case find_source(mod_path, sub_module_id,seen) of
d922 1
a922 4
		       (diagnostic
			(3, fn _ =>
			 [module_str,
			  " has no source (assumed up to date)"]);
d925 1
a925 3
			  augment_accumulated_info
			  (accumulated_info, basis,
			   inter_env, modules)),
d950 2
a951 1
	       that the resulting time stamp matches. *)
d953 1
a953 1
	    val Compiler.RESULT{basis,...} = compiler_result
d957 1
a957 1
            |   check ((sub_module_id, time) :: rest,
d971 1
d979 3
a981 2
                    case action_required of
                      NONE =>
d987 2
a988 2
                    | RECOMPILE =>
                        (RECOMPILE, accumulated_info)
d1052 1
d1077 1
a1077 1
                       (((full_module_id, time)::dependencies,accumulated_info),
d1109 1
a1109 1
            val RESULT{name,time,dependencies,compiler_result,module,inter_env} = result
d1114 1
@


1.61
log
@Deleted compiler option debug_polyvariables in Debugger_Types.INFO;
Debugger environments for Modules Debugger.
@
text
@d11 4
d972 9
a980 4
                    if time = new_time
                      then check (rest, accumulated_info)
                    else
                      (RECOMPILE, accumulated_info)
d1001 1
a1001 1
				    " compiling ", module_str]);
d1138 3
a1140 2
      | Map.NO => modules

@


1.60
log
@get_mo_file makes an error if the file can't be found
Don't return the file itself and the pervasive library when getting the dependencies
@
text
@d11 4
d265 3
d509 1
a509 1
          (type_env, modname, require_list)
d514 5
a518 1
                                             debug_info = Debugger_Types.INFO (debug_information,false)}
d634 1
d640 1
a640 1
		   Encapsulate.output_file
d701 4
a704 1
             (OPTIONS{name_monitor,error_info,options})
@


1.59
log
@make now takes a MOdule argument instead of a file name argument.
@
text
@d11 3
d345 1
a345 2
    exception GetFile
    fun get_mo_file (Option.PRESENT (module,_),_) =
d347 4
a350 1
      | get_mo_file _ = raise GetFile
d358 1
a358 1
            get_mo_file (Module.find_pervasive_mo (modname,Module.empty_cache))
d360 1
a360 1
          get_mo_file (Module.find_mo (modname,Module.empty_cache))
d437 4
a440 1
        map #1 consistency
@


1.58
log
@Better locations in error messages
@
text
@d11 3
d214 1
a216 1
require "../utils/filename";
d237 1
a237 1
  structure FileName : FILENAME
d243 1
a243 1
  sharing Compiler.Option = FileName.Option
d254 3
a256 2
  sharing type ModuleId.ModuleId = Compiler.Absyn.ModuleId = FileName.ModuleId
  sharing type FileName.Directory = Io.Directory
d262 1
a262 1
    structure Option = FileName.Option
d264 1
a264 1
    structure FileName = FileName
d281 2
a331 4
    val pervasive_library_str = Io.pervasive_library_name
    val pervasive_module_id =
      ModuleId.from_string(pervasive_library_str, Location.FILE "Making intermake")

a332 1

d334 1
a334 1
      module_id = pervasive_module_id
d344 1
a344 1
      FileName.mo_name module
d353 1
a353 1
            get_mo_file (FileName.find_pervasive_mo (modname,FileName.empty_cache))
d355 1
a355 1
          get_mo_file (FileName.find_mo (modname,FileName.empty_cache))
d529 1
a529 1
	    val module = FileName.MODULE (Io.get_pervasive_dir(), pervasive_module_id)
d531 1
a531 1
	    case Unix.mtime(FileName.mo_name module) of
d536 1
a536 1
		  "cannot find pervasive library mo '" ^ (FileName.mo_name module) ^
d599 1
a599 1
		    case FileName.find_sml(module_id, FileName.empty_cache) of
d604 1
a604 1
		  val mo_name = FileName.mo_name module_name
d653 1
a653 1
	(do_save(Map.from_list' String.< [(pervasive_library_str, pervasive_mo_stamp)],
d683 1
a683 1
             (modules, module_name,toplevel_name) =
d803 1
a803 1
	datatype Source = CACHED of result | FILE of FileName.Module
d826 1
a826 1
		  (FILE (FileName.MODULE (Io.get_pervasive_dir(), module_id)),
d831 2
a832 2
	          case FileName.find_sml (module_id, FileName.empty_cache)
		  of (FileName.Option.PRESENT (f, _), _) =>
d834 1
a834 1
		  |  (FileName.Option.ABSENT, _) =>
d870 1
a870 1
			     FileName.sml_name file,
d880 1
a880 1
		   val filename = FileName.sml_name file
d1020 1
a1020 1
                                 case modules_lookup pervasive_library_str
a1039 20
(*
                   (* Some stuff to require the pervasive library *)
                   (* This is unnecessary as the initial compiler basis already contains *)
                   (* the relevant stuff *)
                   val initial_compiler_basis =
                     if pervasive then initial_compiler_basis
                     else
                       let
                         val RESULT {compiler_result =
                                     Compiler.RESULT {basis, ...},
                                     ...}
                           case modules_lookup pervasive_library_str
                             of
                               Map.NO => Crash.impossible "No pervasive library in modules"
                             | Map.YES result => result
                       in
                         Compiler.augment(initial_compiler_basis, basis)
                       end
*)

d1059 1
a1059 1
        (diagnostic (1, fn _ => ["Making `", module_name, "'"]);
d1065 1
a1065 1
			 ModuleId.from_string (module_name, Info.Location.FILE toplevel_name),
@


1.57
log
@Numerous small changes and simplifications
@
text
@d11 6
d328 1
a328 1
      ModuleId.from_string(pervasive_library_str, Location.UNKNOWN)
d346 1
a346 1
    fun complete_filename filename =
d348 1
a348 1
        val modname = ModuleId.from_string(filename, Info.Location.UNKNOWN)
d423 1
a423 1
    fun get_mo_dependencies (filename) =
d425 1
a425 1
        val mo_name = complete_filename filename
d434 1
a434 1
    fun get_mo_information (filename,module,modules) =
d438 1
a438 1
        val mo_name = complete_filename filename
d473 1
a473 1
             (ModuleId.from_string(modname, Info.Location.UNKNOWN),time)
d513 1
a513 1
        val result = RESULT {name = ModuleId.from_string(filename, Info.Location.UNKNOWN),
d523 1
a523 1
    fun save error_info (modules, filename) =
d534 1
a534 1
		 (Info.WARNING, Location.UNKNOWN,
d559 1
a559 1
                      (Info.FATAL, Location.UNKNOWN, "cannot find module " ^
d592 1
a592 1
			(Info.FATAL, Location.UNKNOWN, "cannot find module " ^
d601 1
a601 1
			(Info.FATAL, Location.UNKNOWN,
d609 1
a609 1
			(Info.FATAL, Location.UNKNOWN,
d645 1
a645 1
				  (Info.FATAL, Location.UNKNOWN,
d653 1
a653 1
		 (ModuleId.from_string(filename, Info.Location.UNKNOWN),
d682 1
a682 1
             (modules, module_name) =
d708 5
d714 1
a714 9
          let
            (* this is the parent module of the current one *)
            val top_module =
              case seen of
                h :: _ => h
              |  _ => "Make top level"
          in
            Info.error' error_info (Info.FATAL, Info.Location.FILE top_module, message)
          end
d737 1
a737 1
                  compiler_result, time, dependencies) = 
d765 3
a767 4
                       Compiler.Option.ABSENT =>
                         Info.error' error_info (Info.FATAL, Info.Location.UNKNOWN,
                                                 implode ["`", module_str,
                                                          "' database entry has no code recorded."])
d927 1
a927 1
                    (diagnostic (0, fn _ => ["Ignoring pervasive library in compile_sub_modules"]);
d1073 1
a1073 1
                     dependencies)
d1084 1
a1084 1
			 ModuleId.from_string (module_name, Info.Location.FILE "Make top level"),
@


1.56
log
@Fixed a non-exhaustive binding.
@
text
@d11 3
a214 1
require "../lambda/environ";
a223 1
  structure Environ : ENVIRON
a231 4
  sharing InterLoad.Inter_EnvTypes.EnvironTypes = Environ.EnvironTypes
  sharing Compiler.Absyn.Ident = Environ.EnvironTypes.LambdaTypes.Ident
  sharing Environ.EnvironTypes = Encapsulate.EnvironTypes
  sharing Compiler.NewMap = InterLoad.Inter_EnvTypes.EnvironTypes.NewMap
a233 2
  sharing Environ.EnvironTypes.NewMap = Encapsulate.Debugger_Types.NewMap
(**)
a234 1
(**)
d236 2
d239 1
a243 6
  sharing type Environ.EnvironTypes.LambdaTypes.Primitive =
    Compiler.Pervasives.pervasive
  sharing type Environ.EnvironTypes.LambdaTypes.LambdaExp =
    Compiler.LambdaExp
  sharing type Environ.EnvironTypes.Top_Env =
    Compiler.Top_Env
a255 2
    structure EnvironTypes = Environ.EnvironTypes
    structure LambdaTypes = EnvironTypes.LambdaTypes
d259 1
a259 1
    structure Map = EnvironTypes.NewMap
a266 2
    val forget_code_after_a_load = false

a270 4
    fun diagnostic_fn (level, output_function) =
      Diagnostic.output_fn level
      (fn (verbosity, stream) => (output (stream, "InterMake: "); output_function (verbosity, stream)))

a273 1
                 load_time    	: MLWorks.Time.time,
d287 3
a289 10
      datatype action_required =
        RECOMPILE |
        LOAD |
        NONE

    fun make_external (Compiler.BASIS {parser_basis, type_basis, lambda_environment, debug_info}) =
      Compiler.BASIS {parser_basis = parser_basis,
                      type_basis = type_basis,
                      lambda_environment = Environ.make_external lambda_environment,
                      debug_info = debug_info}
d292 1
a292 1
      (Compiler.augment(basis,make_external basis'),
d317 2
a318 2
    exception Error of modules * cache * Info.error * Info.error list
    exception Interrupted of modules * cache
d324 5
d410 5
d416 12
a427 1
    
d500 1
a500 1
        val inter_env = Inter_EnvTypes.augment_with_module (Inter_EnvTypes.empty_env,lambda_env,module)
a508 1
                             load_time = MLWorks.Time.now (),
d580 1
a580 1
		    RESULT{name, time, load_time, dependencies,
d598 1
d624 2
a625 1
		    consistency=(module_str, time) ::
d647 1
a647 1
		 (ModuleId.from_string(filename, Info.Location.FILE "Listener input"),
d666 6
d674 3
a676 6
             (OPTIONS{name_monitor,error_info,
		      options = options as
		      Options.OPTIONS{compiler_options =
				      Options.COMPILEROPTIONS{no_execute, 
                                                              debug_polyvariables, ...}, ...}})
             (preloaded, pervasive) =
d679 22
a700 12
        val inCache = 
            (fn (result as Map.YES(RESULT{compiler_result=
                                       Compiler.RESULT{basis,...},...})) =>
             let
               val Debugger_Types.INFO(_,debug_polyvariables') = 
                 Compiler.get_basis_debug_info basis
             in
               if debug_polyvariables'<>debug_polyvariables then Map.NO
               else
                 result
             end
             | result => result)
d702 1
a702 1
	fun error (message, seen, modules, cache) =
d706 3
a708 5
	      case seen
	      of h :: _ => h
	      |  _ => Crash.impossible "no parent module in inter_make"

            val error = (Info.FATAL, Info.Location.FILE top_module, message)
d710 1
a710 2
            Info.error error_info error;
            raise Error (modules, cache, Info.ERROR error, [])
d712 18
a729 17
	  
        fun check_circularity (module_name, seen, modules, cache) =
          if Lists.member(module_name, seen) then
	    let fun print_seen' [] = []
		|   print_seen' [_] = []
		|   print_seen' [x, _] = ["and ", x]
		|   print_seen' (h::t) = h :: ", " :: print_seen' t

	        fun print_seen [] = []
		|   print_seen [_] = []
		|   print_seen [x, _] = ["from ", x]
		|   print_seen l = ", via " :: print_seen' l
	    in
	      error (implode (["Circular definition of ", module_name] @@
			      print_seen seen),
		     seen, modules, cache)
	    end
a730 3
      
         fun load (module_id, module_str, modules, cache, accumulated_info,
		   filename, compiler_result, time, load_time, dependencies) = 
d732 3
d737 2
a738 1

d740 11
a750 5
               let
                 val Compiler.RESULT {code, basis=basis, ...} = compiler_result
               in
                 (Lists.assoc (module_str, preloaded), basis)
                 handle Lists.Assoc =>
d752 2
a753 1

d756 1
a756 2
                         val RESULT {module, ...} =
			   Map.apply' (modules, module_str)
d761 10
a770 15
                     case (code,accumulated_info) of
                       (Compiler.Option.ABSENT,_) =>
			 (* The no_execute case *)
			 if no_execute then
			   (MLWorks.Internal.Value.cast[], basis)
			 else
			   Info.error'
			   error_info
			   (Info.FATAL, Info.Location.FILE module_str,
			    implode ["`", module_str,
				     "' database entry has no code recorded."])
		     | (Compiler.Option.PRESENT code',(cb,ie,m)) => 
                         let val debug_info =
                           (augment_debug_info(get_basis_debug_info cb,
                                               get_basis_debug_info basis))
d776 1
a776 2
                             debugger
                             (initial_inter_env, module_map) code',
a779 12
               end

             val _ = diagnostic (4, fn _ => ["building environment for ", module_str])

             val inter_env =
               let
                 val Compiler.RESULT {basis = Compiler.BASIS {lambda_environment, ...}, ...} = 
                   compiler_result
               in
                 Inter_EnvTypes.augment_with_module
                 (Inter_EnvTypes.empty_env, lambda_environment, module)
               end
d781 1
a783 2
                   
             val Compiler.RESULT compiler_result' = compiler_result
a787 1
                       load_time = load_time,
d789 1
a789 9
                       compiler_result = 
                       if forget_code_after_a_load then
			 Compiler.RESULT{basis= #basis compiler_result',
					 signatures = #signatures compiler_result',
					 identifiers = #identifiers compiler_result',
					 code = Compiler.Option.ABSENT,
                                         id_cache = #id_cache compiler_result'}
                       else
                         compiler_result,
d794 2
a795 1

d797 1
a797 3
             (Map.define (modules, module_str, result),
              Map.define (cache, module_str, result),
              module_id, result, accumulated_info)
a799 1

d802 2
a803 2
	fun find_source (pervasive, mod_path, sub_module_id, seen,
			 modules, cache) =
a804 5
(*
	    val _ = output(std_out, "find_path looking for " ^
			   ModuleId.string sub_module_id ^ " with path " ^
			   ModuleId.path_string mod_path ^ "\n")
*)
d806 2
a807 2
	      if pervasive then
		sub_module_id
d813 2
a814 2
              (check_circularity (module_str, seen, modules, cache);
               inCache (Map.tryApply' (cache, module_str)))
a817 1

d820 1
a820 3
                (diagnostic
		   (3, fn _ => [module_str, " cached as up to date"]);
                 (CACHED result, module_id, module_str))
d826 1
a826 5
            	    Info.error'
              	      error_info
                      (Info.FATAL,
                       Info.Location.UNKNOWN,
                       "Pervasive directory not set")
d833 1
a833 2
		      (pervasive, ModuleId.parent mod_path, sub_module_id,
		       seen, modules, cache)
d837 1
a837 1
			       seen, modules, cache)
a840 4
	   modules:       The permanent list of module ids and results.  We're
			  checking the consistency of this.
	   cache:         A cache of module ids and results.  This is local
			  to each make, and can be trusted.
a842 1
	   seen:          A list of module ids, used to check for circularity. 
d845 2
a846 3
	    ((modules, cache, full_module_id, result, accumulated_info),
	     action_required, done)
	   modules, cache, accumulated_info, done: as above.
d853 3
a855 3
        fun up_to_date (pervasive, level, modules, cache, mod_path,
			sub_module_id, seen, accumulated_info, done) =
	   case find_source(pervasive, mod_path, sub_module_id, seen, modules, cache) of
d859 2
a860 2
		((modules, cache, module_id, result, accumulated_info),
		 NONE, done))
d862 2
a863 3
	       case Map.tryApply' (modules, module_str) of
		 (* If the module isn't in the module table then
		  it needs to be made. *)
d866 1
a866 1
		    compile (pervasive, level, modules, cache, module_id, module_str,
d868 1
a868 1
			     seen, accumulated_info, done))
d875 1
a875 2
					    compiler_result, inter_env,
					    load_time, ...}) =>
a878 2
		   val Debugger_Types.INFO(_,debug_polyvariables') = 
		     Compiler.get_basis_debug_info basis
d886 2
a887 2
			((modules, Map.define (cache, module_str, result),
			  module_id, result,
d891 1
a891 1
			 NONE, done))
d898 1
a898 1
			  compile (pervasive, level, modules, cache, module_id,
d900 1
a900 1
				   accumulated_info, done))
d902 4
a905 12
			 if debug_polyvariables'<>debug_polyvariables then
			   (diagnostic
			    (3, fn _ => [module_str,
					 " forcibly recompiled"]);
			    compile (pervasive, level, modules, cache, module_id,
				     module_str, filename, seen,
				     accumulated_info, done))
			 else
			   compile_sub_modules
			   (pervasive, level, modules, cache, module_id,
			    module_str, filename, result, seen,
			    accumulated_info, done)
d907 1
a907 1
	and compile_sub_modules (pervasive, level, modules, cache, module_id, module_str,
d910 2
a911 3
					           compiler_result, inter_env,
						   load_time, ...},
				 seen, accumulated_info, done) =
d919 8
a926 29
            fun check (modules, cache, [], accumulated_info, done) = 
              (modules, cache, NONE, accumulated_info, done)
            |   check (modules, cache, (sub_module_id, time) :: rest,
		       accumulated_info, done) =
              let
                val _ = diagnostic
			  (4, fn _ => ["checking ", module_str, " dependency ",
				       ModuleId.string sub_module_id]);

		val perv =
		  pervasive orelse
		  (case rest of nil => true | _ => false)

                val ((modules, cache, _,
		      RESULT {time = new_time,
			      load_time = new_load_time,
			      ...},
                      accumulated_info),
		     action_required, done) =
                  up_to_date (perv, level, modules, cache,
			      ModuleId.path module_id, sub_module_id,
			      module_str :: seen, accumulated_info, done)
              in
                if time = new_time andalso
		   (new_load_time = load_time orelse
		    MLWorks.Time.< (new_load_time, load_time)) then
                  check (modules, cache, rest, accumulated_info, done)
                else if time <> new_time then
                  (modules, cache, RECOMPILE, accumulated_info, done)
d928 19
a946 2
                  (modules, cache, LOAD, accumulated_info, done)
              end
d948 2
a949 2
            case check (modules, cache, dependencies, accumulated_info, done)
	    of (modules, cache, NONE, accumulated_info, done) =>
d951 2
a952 2
               ((modules, Map.define (cache, module_str, result), module_id,
		 result,
d954 2
a955 2
					   inter_env, modules)),
                NONE, done))
d957 4
a960 12
            |  (modules, cache, LOAD, accumulated_info, done) =>
              (diagnostic (3, fn _ => [module_str, " needs loading"]);
               (load (module_id, module_str, modules, cache, accumulated_info,
		      filename, compiler_result, time, MLWorks.Time.now(),
		      dependencies),
                LOAD, done))

            |  (modules, cache, RECOMPILE, accumulated_info, done) =>
              (diagnostic (3, fn _ => [module_str,
				       " is out of date wrt dependencies"]);
               compile (pervasive, level, modules, cache, module_id, module_str, filename,
			seen, accumulated_info, done))
d963 2
a964 2
        and compile (pervasive, level, modules, cache, module_id, module_str,
		     filename, seen, accumulated_info, done) =
d968 1
a968 1
           check_circularity (module_str,seen,modules,cache);
d984 2
a985 11
                   Info.error'
                   error_info
                  (Info.FATAL, Info.Location.FILE module_str,
                   implode ["can't find module `",
			    filename, "' on search path"])

             val instream = open_in filename
               handle Io message =>
                 Info.error' error_info (Info.FATAL,
                                        Info.Location.FILE filename,
                                        "Io error during make, " ^ message)
d987 1
a987 2
             val (modules, cache, dependencies, compiler_result,
		  accumulated_info, done) =
d989 47
a1035 7
                 val token_stream =
                   Lexer.mkFileTokenStream (instream, filename)

                 (* This was functional originally, but due to the *)
                 (* inadequacies of the exception mechanism it isn't *)
                 (* possible to cause an error _and_ return some *)
                 (* information. *)
a1036 11
                 val current_modules = ref modules
                 val current_cache = ref cache

                 fun require_function ((dependencies,accumulated_info), 
                                       sub_module_id, source_location, done, pervasive) =
                   let
                     val _ = diagnostic
			       (3, fn _ => [ModuleId.string module_id,
					    " requiring ",
					    ModuleId.string sub_module_id])

d1038 6
a1043 5
		     val _ = output(std_out, implode [ModuleId.string module_id,
					    " requiring ",
					    ModuleId.string sub_module_id, "\n"])
*)
                     val (time, basis,accumulated_info, done, full_module_id) =
d1045 7
a1051 9
                         val ((modules, cache, full_module_id,
                               RESULT {time, compiler_result =
				 	       Compiler.RESULT {basis, ...},
				       ...},
                               accumulated_info), _, done) =
                           up_to_date
			     (pervasive, level+1, !current_modules, !current_cache,
                              ModuleId.path module_id, sub_module_id,
			      new_seen, accumulated_info, done)
d1053 1
a1053 3
                         current_modules := modules;
                         current_cache := cache;
                         (time, basis,accumulated_info, done, full_module_id)
d1055 1
d1057 10
a1066 63
                     val module_expression =
                       LambdaTypes.APP
			 (LambdaTypes.BUILTIN Compiler.Pervasives.LOAD_STRING,
                          LambdaTypes.SCON
			    (Ident.STRING (ModuleId.string full_module_id)),
                          LambdaTypes.Option.ABSENT)
                   in
                     (((full_module_id, time)::dependencies,accumulated_info),
                      module_expression, basis, done)
                   end
                   handle
		       Interrupt =>
                     raise Interrupted (!current_modules, !current_cache)
                   |   Info.Stop (error,error_list) =>
		     raise Error (!current_modules, !current_cache,
				  error, error_list)
(*
		 val _ =
		   if pervasive then
		     output(std_out, "Compiling a pervasive, don't require pervasives\n")
		   else
		     output(std_out, "Compiling non-pervasive '" ^ filename ^
			    "' so require pervasives as well\n")
*)
			    
		 (* Some stuff to require the pervasive library *)
(*
		 val basis =
		   if pervasive then initial_compiler_basis
		   else
		     let
		       val ((_, _, _,
			     RESULT {compiler_result =
				     Compiler.RESULT {basis, ...},
				     ...},
			     _), _, _) =
			 up_to_date
			 (true, level+1, !current_modules, !current_cache,
			  ModuleId.empty_path,
			  ModuleId.from_string(Io.pervasive_library_name,
					       Info.Location.FILE "Listener input"),
			  new_seen, accumulated_info, done)
		     in
		       Compiler.augment(initial_compiler_basis, basis)
		     end
*)
                 val ((dependencies,accumulated_info), compiler_result, done) =
                   Compiler.compile (error_info,options) require_function
                   (([],accumulated_info), initial_compiler_basis, done, true)
                   (pervasive, Compiler.TOKENSTREAM token_stream)
                   handle
		       Interrupt =>
                     (close_in instream;
                      raise Interrupted (!current_modules, !current_cache))
                   |   Info.Stop (error,error_list) => 
                     (close_in instream;
                      raise Error (!current_modules, !current_cache,
				   error, error_list))
                   |   other => (close_in instream; raise other)
               in
                 close_in instream;
                 (!current_modules, !current_cache, dependencies,
                  compiler_result, accumulated_info, done)
a1067 1

d1069 3
a1071 4
               load (module_id, module_str, modules, cache, accumulated_info,
		     filename, compiler_result, time, MLWorks.Time.now(),
		     dependencies)

d1073 2
a1074 8
             (result, RECOMPILE, done)
           end)
          handle
	      Interrupt =>
            raise Interrupted (modules, cache)
          |   Info.Stop (error,error_list) =>
            raise Error (modules,cache,error,error_list))

a1075 2

        fn (modules, cache, module_name) =>
a1077 3
(*
	   val _ = output(std_out, implode ["Making `", module_name, "'\n"])
*)
d1079 7
a1085 26
	   val cache' = cache
           val ((modules, cache, _, result, accumulated_info), _, done) =
             up_to_date (pervasive, 0, modules, cache, ModuleId.empty_path,
			 ModuleId.from_string
			   (module_name, Info.Location.FILE "Listener input"),
			 ["Listener input"],
                         (initial_compiler_basis,
			  Inter_EnvTypes.empty_env,empty_modules),
			 [])

           val _ = diagnostic_fn
             (5, fn (_, stream) =>
              let
                val RESULT {name, inter_env, ...} = result
                val Options.OPTIONS{print_options,...} = options
              in
                output (stream,
			implode ["Result of ", ModuleId.string name, ":\n"]);
                Inter_EnvTypes.print
		print_options
                (fn (stream, string) => (output (stream, string); stream))
                (stream, inter_env);
                ()
              end)

            val RESULT{name,time,dependencies,compiler_result,module,inter_env,load_time} = result
a1089 1
                     load_time=load_time,
d1096 1
a1096 4
                                     code=if forget_code_after_a_load then
					    Compiler.Option.ABSENT
					  else
					    code,
d1100 1
d1109 6
a1114 4
	      (modules', cache', NO_EXECUTE done)
	    else (modules, cache, EXECUTE result'))
         end)

@


1.55
log
@Added functions for reading mo type information.
Added functions for writing out type information from interpreter.
@
text
@d11 4
d443 4
a446 1
        val ((_,src_time)::consistency') = consistency
@


1.54
log
@Changed error message for non-existent modules.
@
text
@d11 3
a201 1
require "../debugger/debugger_types";
a214 1
  structure Debugger_Types : DEBUGGER_TYPES
d232 2
a233 2
    Compiler.Options = Debugger_Types.Options
  sharing Environ.EnvironTypes.NewMap = Debugger_Types.NewMap
d239 3
a241 1
  sharing type Compiler.DebugInformation = Debugger_Types.information
d255 1
d269 4
a283 1

d345 170
d533 37
d579 1
a579 1
			   compiler_result=Compiler.RESULT{code, ...},
d586 2
d602 4
d607 2
d613 8
a620 8
		    tynames=0,
		    strnames=0,
		    tyfuns=0,
		    parser_env=Encapsulate.ParserEnv.empty_pB,
		    type_basis=Basis.empty_basis,
		    debug_info=Encapsulate.Debugger_Types.empty_information,
		    require_list=[],
		    lambda_env=Environ.empty_top_env,
d626 1
d630 1
a630 1
		    dependencies};
d792 2
a793 1
					 code = Compiler.Option.ABSENT}
d1206 1
a1206 1
            val Compiler.RESULT{basis,signatures,identifiers,code} = compiler_result
d1220 2
a1221 1
					    code},
a1223 1

@


1.53
log
@Removed EnvironPrint parameter.
@
text
@d11 3
d632 2
a633 2
			error (implode ["make called on non-existent file `",
					module_str, "'"],
d791 2
a792 2
        and compile (pervasive, level, modules, cache, module_id, module_str, filename,
		     seen, accumulated_info, done) =
d815 2
a816 2
                   implode ["make called on non-existent file `",
			    filename, "'"])
@


1.52
log
@Renamed Encapsulate.Basistypes to Encapsulate.BasisTypes
@
text
@d11 3
a202 1
require "../lambda/environprint";
a213 1
  structure EnvironPrint : ENVIRONPRINT
d223 1
a223 2
  sharing InterLoad.Inter_EnvTypes.EnvironTypes =
    EnvironPrint.EnvironTypes = Environ.EnvironTypes
d227 1
a227 1
  sharing EnvironPrint.Options = InterLoad.Inter_EnvTypes.Options =
d258 1
a258 1
    structure Options = EnvironPrint.Options
@


1.51
log
@Changed to make the consistency information correct when mo files are
saved from the interpreter. Part of ongoing work to make them fully
fledged mo files.
@
text
@d11 5
d233 1
a233 1
  sharing Encapsulate.Basistypes = Basis.BasisTypes
@


1.50
log
@New pervasive time structure.
@
text
@d11 3
d326 1
d328 1
a328 1
      ModuleId.from_string(Io.pervasive_library_name, Location.UNKNOWN)
d332 16
d351 2
a352 10
	    val result as
	      RESULT{name, time, load_time, dependencies,
		     compiler_result=Compiler.RESULT{code, ...},
		     ...} =
	      case Map.tryApply'(modules, module_str) of
		Map.YES result => result
	      | _ => Info.error' error_info
		  (Info.FATAL, Location.UNKNOWN, "cannot find module " ^
		   module_str)
	    val done = case Map.tryApply'(done, module_str) of
d355 10
d379 1
a379 1
		  (output(std_out, "Saving '" ^ module_str ^ "'\n");
d391 16
a406 3
		    consistency=(module_str, MLWorks.Time.now()) ::
		    map (fn (id, time) => (ModuleId.string id, time)) dependencies};
		   Map.define(done, module_str, true))
a408 7
	    (* Throw away first dependent if it's the pervasive library (should be) *)
	    val dependencies = case (rev dependencies) of
	      (dep, _) :: rest =>
		if dep = pervasive_module_id then rest else dependencies
	    | _ => dependencies
	  in
	    Lists.reducel do_save (done, dependencies)
d411 1
a411 1
	(do_save(Map.empty' String.<,
d413 1
a413 1
		  MLWorks.Time.now()));
@


1.49
log
@Removed an extraneous parameter from check.
@
text
@d11 3
d268 2
a269 2
                 time		: MLWorks.Time.Real.T,
                 load_time    	: MLWorks.Time.Real.T,
d271 1
a271 1
			(ModuleId.ModuleId * MLWorks.Time.Real.T) list,
d369 1
a369 1
		    consistency=(module_str, MLWorks.Time.Real.now()) ::
d385 1
a385 1
		  MLWorks.Time.Real.now()));
d665 1
a665 2
		       if not (MLWorks.Time.Real.equal
			       (time, new_time)) then
d724 1
a724 1
		    MLWorks.Time.Real.< (new_load_time, load_time)) then
d744 1
a744 1
		      filename, compiler_result, time, MLWorks.Time.Real.now(),
d899 1
a899 1
		     filename, compiler_result, time, MLWorks.Time.Real.now(),
@


1.48
log
@Ensured __pervasive_library entries in dependency lists are treated as
pervasive.
@
text
@d11 4
d697 1
a697 1
            fun check (_, modules, cache, [], accumulated_info, done) = 
d699 1
a699 1
            |   check (first, modules, cache, (sub_module_id, time) :: rest,
d723 1
a723 1
                  check (false, modules, cache, rest, accumulated_info, done)
d730 1
a730 1
            case check (true, modules, cache, dependencies, accumulated_info, done)
@


1.47
log
@Added save function for writing out .mo files
@
text
@d11 3
d693 1
a693 1
            fun check (modules, cache, [], accumulated_info, done) = 
d695 1
a695 1
            |   check (modules, cache, (sub_module_id, time) :: rest,
d701 5
d712 3
a714 3
                  up_to_date (pervasive, level, modules, cache, ModuleId.path module_id,
			      sub_module_id, module_str :: seen,
			      accumulated_info, done)
d719 1
a719 1
                  check (modules, cache, rest, accumulated_info, done)
d726 1
a726 1
            case check (modules, cache, dependencies, accumulated_info, done)
@


1.46
log
@Deleted output message.
@
text
@d11 3
d174 1
d179 1
d197 2
d207 1
d212 4
d225 1
a225 1
  sharing type InterLoad.Module = Compiler.Module
d242 2
d313 66
d540 1
a540 1
	fun find_source (mod_path, sub_module_id, seen,
d543 11
a553 1
	    val module_id = ModuleId.add_path (mod_path, sub_module_id)
d583 1
a583 1
		      (ModuleId.parent mod_path, sub_module_id,
d610 1
a610 1
        fun up_to_date (level, modules, cache, mod_path,
d612 15
a626 19
	   case find_source (mod_path, sub_module_id, seen, modules, cache)
	   of (CACHED result, module_id, module_str) =>
                 (diagnostic
		    (3, fn _ => [module_str, " cached as up to date"]);
                  ((modules, cache, module_id, result, accumulated_info),
		   NONE, done))
	   |  (FILE file, module_id, module_str) =>
                 case Map.tryApply' (modules, module_str) of
                    (* If the module isn't in the module table then
		       it needs to be made. *)
                    Map.NO =>
                      (diagnostic (3, fn _ => [module_str, " never compiled"]);
                       compile (level, modules, cache, module_id, module_str,
			        FileName.sml_name file,
                                seen, accumulated_info, done))
  
                    (* If the module does have source then check the
		       timestamps of it and its dependencies.  (If the source
		       doesn't exist then it's implicitly up to date.) *)
d628 50
a677 47
                 |  Map.YES (result as RESULT {time, dependencies, 
                                               compiler_result, inter_env,
					       load_time, ...}) =>
                      let
                        val filename = FileName.sml_name file
                        val Compiler.RESULT{basis,...} = compiler_result
                        val Debugger_Types.INFO(_,debug_polyvariables') = 
                          Compiler.get_basis_debug_info basis
                      in
                        case Unix.mtime filename of
                          Unix.NOT_EXIST =>
                            (diagnostic
			       (3, fn _ =>
				     [module_str,
				      " has no source (assumed up to date)"]);
                             ((modules, Map.define (cache, module_str, result),
			       module_id, result,
                               augment_accumulated_info
			         (accumulated_info, basis,
				  inter_env, modules)),
                              NONE, done))
  
                        | Unix.EXISTS new_time =>
                            if not (MLWorks.Time.Real.equal
				      (time, new_time)) then
                              (diagnostic
			         (3, fn _ => [module_str,
					      " is out of date wrt source"]);
                               compile (level, modules, cache, module_id,
				        module_str, filename, seen,
				        accumulated_info, done))
                            else
                              if debug_polyvariables'<>debug_polyvariables then
                                (diagnostic
			         (3, fn _ => [module_str,
					      " forcibly recompiled"]);
                                 compile (level, modules, cache, module_id,
                                          module_str, filename, seen,
                                          accumulated_info, done))
                              else
                                compile_sub_modules
			        (level, modules, cache, module_id,
				 module_str, filename, result, seen,
				 accumulated_info, done)
                      end
  
	and compile_sub_modules (level, modules, cache, module_id, module_str,
d704 1
a704 1
                  up_to_date (level, modules, cache, ModuleId.path module_id,
d737 1
a737 1
               compile (level, modules, cache, module_id, module_str, filename,
d741 1
a741 1
        and compile (level, modules, cache, module_id, module_str, filename,
d789 1
a789 1
                                       sub_module_id, source_location, done) =
d796 5
d809 1
a809 1
			     (level+1, !current_modules, !current_cache,
d834 30
a863 1

d867 1
a867 1
                   (Compiler.TOKENSTREAM token_stream)
d902 3
d908 1
a908 1
             up_to_date (0, modules, cache, ModuleId.empty_path,
@


1.45
log
@Record compiler option debug_polyvariables in Debugger_Types.INFO
for recompilation purposes.
@
text
@d11 4
a545 1
                        val _ = output(std_out,"\nMap.YES\n")
@


1.44
log
@Merging in bug fixes
@
text
@d11 3
d314 2
a315 1
				      Options.COMPILEROPTIONS{no_execute, ...}, ...}})
d319 13
d461 3
a464 2
            check_circularity (module_str, seen, modules, cache);

d468 1
a468 1
            case Map.tryApply' (cache, module_str) of
d542 1
d545 2
d571 9
a579 1
			      compile_sub_modules
@


1.43
log
@FileName.find_sml now takes a filename cache.
@
text
@d11 7
d292 14
d381 12
a392 10
			 (InterLoad.load
			  (debugger 
			   (adjust_compiler_basis_debug_info
			    (cb,(augment_debug_info(get_basis_debug_info cb,
						    get_basis_debug_info basis))),
			    ie,
			    modules,
			    filename))
			  (initial_inter_env, module_map) code',
			  basis)
@


1.43.1.1
log
@Fork for bug fixing
@
text
@a10 3
 *  Revision 1.43  1993/08/28  17:49:13  daveb
 *  FileName.find_sml now takes a filename cache.
 *
@


1.43.1.2
log
@Added with_debug_information and current_debug_information to
control global debug information.
@
text
@a287 14
    val debug_info_ref = ref Debugger_Types.empty_information

    fun with_debug_information debug_info f =
      let
        val old = !debug_info_ref
        val _ = debug_info_ref := debug_info
        val result = f () handle exn => (debug_info_ref := old;raise exn)
      in
        debug_info_ref := old;
        result
      end

    fun current_debug_information () = !debug_info_ref

d363 10
a372 12
                         let val debug_info =
                           (augment_debug_info(get_basis_debug_info cb,
                                               get_basis_debug_info basis))
                         in
                           with_debug_information
                           debug_info
                           (fn () =>
                            (InterLoad.load
                             debugger
                             (initial_inter_env, module_map) code',
                             basis))
                         end
@


1.42
log
@FileName.find_file has been replaced with FileName.find_sml.
@
text
@d11 3
a412 18
	(* mod_path:      The path of the current module name
	   sub_module_id: The id of the module to check
	   cache:         A cache of module ids and results.  This is local
			  to each make, and can be trusted.
	   modules:       The permanent list of module ids and results.  We're
			  checking the consistency of this.
	   seen:          A list of module ids, used to check for circularity. 
	   level:	  The depth of the search.  Only used in diagnostics.
	 *)
	 (* Returns:
	    ((modules, cache, full_module_id, result, accumulated_info),
	     action_required, done)
	   modules, cache, accumulated_info, done: as above.
	   full_module_id:  module_id of the module found after searching the
			    path.
	   result:	    As per the datatype.
	   action_required: As per the datatype.
	 *)
d443 2
a444 2
	          case FileName.find_sml module_id
		  of FileName.Option.PRESENT (f, _) =>
d446 1
a446 1
		  |  FileName.Option.ABSENT =>
d456 21
a476 2
        fun up_to_date (level, modules, cache, mod_path, sub_module_id, seen,
			accumulated_info, done) =
@


1.41
log
@ModuleId.from_string now takes a location parameter.
Io.get_pervasive_dir can raise Io.NotSet.
@
text
@d11 4
d458 2
a459 2
	          case FileName.find_file module_id
		  of FileName.Option.PRESENT f =>
@


1.40
log
@Major changes: to use ModuleIds and search path.
@
text
@d11 3
d195 1
d447 6
d720 3
a722 1
			 ModuleId.from_string module_name, ["Listener input"],
@


1.39
log
@Added missing Interrupt handlers.
@
text
@d11 3
d143 1
d151 1
d159 1
d168 1
d190 3
a192 1
    ) : INTERMAKE =
d218 1
a218 2
      RESULT of {name		: string,
                 source		: FileName.absolute,
d221 2
a222 1
                 dependencies	: (FileName.relative * MLWorks.Time.Real.T) list,
d250 1
a250 1
    val empty_modules = (Map.empty' MLWorks.String.<)
d279 2
a280 3
				      Options.COMPILEROPTIONS{no_execute, 
                                                              debug_variables, ...}, ...}})
             preloaded =
d283 30
a312 16
        fun check_circularity (module_name,seen,modules,cache) =
          if Lists.member(module_name,seen)
            then
              let
                (* this is the parent module of the current one *)
                val top_module :: _ = seen
                val error = (Info.FATAL,
                             Info.Location.FILE top_module,
                             implode["circular require of ",
                                     module_name,
                                     " in ",
                                     top_module])
              in
                Info.error error_info error;
                raise Error (modules,cache,Info.ERROR error,[])
              end
d315 2
a316 2
         fun load (module_name,modules,cache,accumulated_info,
                   compiler_result,absolute,time,load_time,dependencies,filename) = 
d319 1
a319 2

             val _ = diagnostic (4, fn _ => ["loading ", module_name])
d325 1
a325 1
                 (Lists.assoc (module_name, preloaded), basis)
d329 1
a329 1
                     fun module_map module_name =
d331 2
a332 1
                         val RESULT {module, ...} = Map.apply' (modules, module_name)
d345 3
a347 2
			   (Info.FATAL, Info.Location.FILE module_name,
			    implode ["`", module_name, "' database entry has no code recorded. "])
d362 1
a362 1
             val _ = diagnostic (4, fn _ => ["building environment for ", module_name])
d379 1
a379 2
               RESULT {name = module_name,
                       source = absolute,
d394 1
a394 1
             val _ = diagnostic (2, fn _ => ["finished ", module_name])
d397 3
a399 4
             (Map.define (modules, module_name, result),
               Map.define (cache, module_name, result),
               result,
               accumulated_info)
d402 181
a582 4
        fun up_to_date (level, modules, cache, location, module_name, seen, accumulated_info, done) =
          (diagnostic (2, fn _ => [MLWorks.Integer.makestring level, " ", module_name, " up to date?"]);

           check_circularity (module_name,seen,modules,cache);
d584 1
a584 103
           (* If the module is in the cache then it is known to be up to date *)
           (* during this phase. *)
           case Map.tryApply' (cache, module_name) of

             Map.YES(result) =>
               (diagnostic (3, fn _ => [module_name, " cached as up to date"]);
                ((modules, cache, result,accumulated_info),NONE, done))

           | Map.NO =>

               (case Map.tryApply' (modules, module_name) of

                  (* If the module isn't in the module table then it needs to *)
                  (* be made. *)

                  Map.NO =>
                    (diagnostic (3, fn _ => [module_name, " never compiled"]);
                     compile (level, modules, cache, location, 
                              module_name,seen,accumulated_info, done))

                  (* If the module does have source then check the timestamps *)
                  (* of it and its dependencies.  (If the source doesn't *)
                  (* exist then it's implicitly up to date.) *)

                | Map.YES (result as RESULT {source, time, dependencies, 
                                             compiler_result, inter_env, load_time, ...}) =>

                    let
                      val filename = FileName.absolute_name source
                      val Compiler.RESULT{basis,...} = compiler_result
                    in
                      case Unix.mtime filename of

                        Unix.NOT_EXIST =>

                          (diagnostic (3, fn _ => [module_name, " has no source (assumed up to date)"]);
                           ((modules, Map.define (cache, module_name, result), result,
                             augment_accumulated_info(accumulated_info,basis,inter_env,modules)),
                            NONE, done))

                      | Unix.EXISTS new_time =>

                          if not (MLWorks.Time.Real.equal (time, new_time)) then
                            (diagnostic (3, fn _ => [module_name, " is out of date wrt source"]);
                             compile (level, modules, cache, location, 
                                      module_name,seen,accumulated_info, done))
                          else
                            let

                              (* The made module is up to date wrt to its source, *)
                              (* but possibly not wrt its dependencies, so bring *)
                              (* them up to date and check that the resulting *)
                              (* time stamp matches. *)

                              fun check (modules, cache, [],accumulated_info, done) = 
                                (modules, cache, NONE, accumulated_info, done)
                                | check (modules, cache, 
                                         (FileName.RELATIVE (route, sub_module_name, _), time)::rest,accumulated_info, done) =
                                  (diagnostic (4, fn _ => ["checking ", module_name, " dependency ", sub_module_name]);
                                   let
                                     val ((modules, cache, RESULT {time = new_time, load_time = new_load_time, ...},
                                           accumulated_info),action_required, done) =
                                       up_to_date (level, modules, cache,
                                                   FileName.follow (location, route), 
                                                   sub_module_name,
                                                   module_name :: seen,
                                                   accumulated_info, done)
                                   in
                                     if time = new_time andalso (new_load_time = load_time orelse MLWorks.Time.Real.<(new_load_time,load_time))
                                       then
                                         check (modules, cache, rest, accumulated_info, done)
                                     else 
                                       if time <> new_time 
                                         then
                                           (modules, cache, RECOMPILE, accumulated_info, done)
                                       else
                                         (modules, cache, LOAD, accumulated_info, done)
                                   end)
                            in
                              case check (modules, cache, dependencies,accumulated_info, done) of
                                (modules, cache, NONE, accumulated_info, done) =>
                                  (diagnostic (3, fn _ => [module_name, " is up to date!"]);
                                   ((modules, Map.define (cache, module_name, result), result,
                                    augment_accumulated_info(accumulated_info,basis,inter_env,modules)),
                                    NONE, done))

                              | (modules, cache, LOAD, accumulated_info, done) =>
                                  (diagnostic (3, fn _ => [module_name, " needs loading"]);
                                   (load (module_name,modules,cache,accumulated_info,compiler_result,
                                          FileName.ABSOLUTE (location, module_name, Option.PRESENT "sml"),
                                          time,MLWorks.Time.Real.now(),dependencies,filename),
                                   LOAD, done))

                              | (modules, cache, RECOMPILE, accumulated_info, done) =>
                                  (diagnostic (3, fn _ => [module_name, " is out of date wrt dependencies"]);
                                   compile (level, modules, cache, location, 
                                            module_name,seen,accumulated_info, done))
                           end
                    end))

        and compile (level, modules, cache, location, module_name,seen,accumulated_info, done) =
          ((diagnostic (2, fn _ => [MLWorks.Integer.makestring level, " compiling ", module_name]);
           check_circularity (module_name,seen,modules,cache);
d589 1
a589 1
		     if y <= 0 then module_name else ("   " ^ spaces (y-1))
d595 1
a595 3
             val absolute = FileName.ABSOLUTE (location, module_name, Option.PRESENT "sml")
             val filename = FileName.absolute_name absolute
             val new_seen = module_name :: seen
d602 3
a604 2
                  (Info.FATAL, Info.Location.FILE filename,
                   implode ["make called on non-existent file `", filename, "'"])
d612 2
a613 1
             val (modules, cache, dependencies, compiler_result, accumulated_info, done) =
d616 1
a616 3
                   Lexer.mkFileTokenStream 
                   (instream, 
                    filename (* Io.sml_name module_name *) )
d627 1
a627 1
                                       filename, source_location, done) =
d629 4
a632 1
                     val _ = diagnostic (3, fn _ => [module_name, " requiring ", filename])
d634 1
a634 11
                     val relative as FileName.RELATIVE (route, module_name, _) =
                       FileName.parse_relative filename
                       handle FileName.Parse _ =>
                         Info.error'
                         error_info
                         (Info.FATAL, source_location,
                          implode ["`", filename, "' is not a valid relative file name argument to require"])

                     val location = FileName.follow (location, route)

                     val (time, basis,accumulated_info, done) =
d636 9
a644 5
                         val ((modules, cache,
                               RESULT {time, compiler_result = Compiler.RESULT {basis, ...}, ...},
                               accumulated_info),_, done) =
                           up_to_date (level+1, !current_modules, !current_cache, location, 
                                       module_name, new_seen, accumulated_info, done)
d648 1
a648 1
                         (time, basis,accumulated_info, done)
d652 5
a656 3
                       LambdaTypes.APP (LambdaTypes.BUILTIN Compiler.Pervasives.LOAD_STRING,
                                        LambdaTypes.SCON (Ident.STRING (module_name)),
                                        LambdaTypes.Option.ABSENT)
d658 2
a659 4
                     (((relative, time)::dependencies,accumulated_info),
                      module_expression,
                      basis,
		      done)
d661 2
a662 1
                   handle Interrupt =>
d664 3
a666 2
                        | Info.Stop (error,error_list) =>
		     raise Error (!current_modules, !current_cache, error, error_list)
a667 1

d672 2
a673 1
                   handle Interrupt =>
d676 5
a680 4
                        | Info.Stop (error,error_list) => 
                            (close_in instream;
                             raise Error (!current_modules, !current_cache, error, error_list))
                        | other => (close_in instream; raise other)
d683 1
a683 1
                 (!current_modules, !current_cache, dependencies, 
d688 3
a690 2
               load (module_name,modules,cache,accumulated_info,compiler_result,
                     absolute,time,MLWorks.Time.Real.now(),dependencies,filename)
d693 1
a693 1
             (result,RECOMPILE, done)
d695 2
a696 1
          handle Interrupt =>
d698 2
a699 2
               | Info.Stop (error,error_list) =>
                   raise Error (modules,cache,error,error_list))
d703 2
a704 2
        fn (modules, cache, filename as FileName.ABSOLUTE (location, module_name, _)) =>
        (diagnostic (1, fn _ => ["Making `", FileName.absolute_name filename, "'"]);
d708 6
a713 3
           val ((modules, cache, result,accumulated_info),_, done) =
             up_to_date (0, modules, cache, location, module_name,[],
                         (initial_compiler_basis,Inter_EnvTypes.empty_env,empty_modules), [])
d721 2
a722 1
                output (stream, implode ["Result of ", name, ":\n"]);
d730 1
a730 1
            val RESULT{name,source,time,dependencies,compiler_result,module,inter_env,load_time} = result
a733 1
                     source=source,
d742 4
a745 2
                                     code=if forget_code_after_a_load then Compiler.Option.ABSENT 
                                          else code},
d764 1
a764 1
                      FileName.ABSOLUTE (_, module_name, _),
d766 3
a768 3
      case Map.tryApply'(modules,module_name) of
        Map.YES(_) =>
           Map.undefine(modules,module_name)
a769 31
(*
          Info.error'
          error_info
          (Info.FATAL, Info.Location.UNKNOWN,
           implode ["`", module_name, "' is not in the module table"])
*)

    datatype find_module_result = 
      FOUND of string |
      NOT_FOUND

    val debug_find_module = false

    fun find_module (FileName.ABSOLUTE (_, module_name, _),modules) =
      case Map.tryApply'(modules,module_name) of
        Map.YES (RESULT{source=FileName.ABSOLUTE(location,_,_),...}) =>
          FOUND(FileName.path_to_file location)
      | Map.NO => 
          if debug_find_module
            then
              let
                val available = Map.domain modules
              in
                output(std_out,"Tried to find the module " ^ module_name ^ "\n");
                output(std_out," in ");
                map (fn x => output(std_out,x ^ " ")) available;
                output(std_out,"\n");
                NOT_FOUND
              end
          else
            NOT_FOUND
a771 1

@


1.38
log
@structure Option.
@
text
@d11 3
d570 3
a572 1
                   handle Info.Stop (error,error_list) =>
d580 1
a580 1
                   handle Info.Stop (error,error_list) => 
d582 4
a585 1
                      raise Error (!current_modules, !current_cache, error, error_list))
d600 2
a601 1
          handle Interrupt =>  raise Interrupted (modules, cache)
@


1.37
log
@Changed some unknown locations to file locations
Added Interrupted exception to indicate if a make was interrupted.
@
text
@d11 4
d169 1
d249 1
d251 1
a251 1
      OPTIONS of {name_monitor		: (string -> unit) Option.T,
d267 2
a268 1
				      Options.COMPILEROPTIONS{no_execute, ...}, ...}})
d313 1
a313 1
                       (Compiler.ABSENT,_) =>
d322 1
a322 1
		     | (Compiler.PRESENT code',(cb,ie,m)) => 
d363 1
a363 1
					 code = Compiler.ABSENT}
a384 1

d387 1
a387 1
             Map.YES result =>
a484 1

d560 1
a560 1
                                        LambdaTypes.null_type_annotation)
d634 2
a635 1
                                     code=if forget_code_after_a_load then Compiler.ABSENT else code},
d657 2
a658 2
        Map.YES _ =>
          Map.undefine(modules,module_name)
@


1.36
log
@delete_module no longer generates error when module not in table.
@
text
@d11 3
d254 1
d272 1
a272 1
                             Info.Location.UNKNOWN,
d313 1
a313 1
			   (Info.FATAL, Info.Location.UNKNOWN,
d500 1
a500 1
                  (Info.FATAL, Info.Location.UNKNOWN,
d506 1
a506 1
                                        Info.Location.UNKNOWN,
d587 3
a589 5
          handle Interrupt =>  raise Error (modules, cache, 
                                            Info.ERROR(Info.FATAL,
                                                       Info.Location.UNKNOWN,
                                                       "Interrupt pressed"),
                                            []))
@


1.35
log
@Use full filename in making tokenstream & thence in locations
@
text
@d11 3
d651 2
a652 1
      | Map.NO =>
d657 1
@


1.34
log
@Removed integer parameter
@
text
@d11 3
d507 1
a507 1
                    Io.sml_name module_name )
@


1.33
log
@Implemented make -n functionality
@
text
@d11 3
a124 1
require "../utils/integer";
a138 1
  structure Integer : INTEGER
d362 1
a362 1
          (diagnostic (2, fn _ => [Integer.makestring level, " ", module_name, " up to date?"]);
d468 1
a468 1
          ((diagnostic (2, fn _ => [Integer.makestring level, " compiling ", module_name]);
@


1.32
log
@Added error_list to Error exception
@
text
@d11 3
a120 1
require "../utils/newmap";
a132 1

d136 12
a147 13
                   structure Map : NEWMAP
                   structure Lists : LISTS
                   structure Integer : INTEGER
                   structure Debugger_Types : DEBUGGER_TYPES
                   structure Compiler : COMPILER
                   structure Lexer : LEXER
                   structure InterLoad : INTERLOAD
                   structure EnvironPrint : ENVIRONPRINT
                   structure Environ : ENVIRON
                   structure Io : IO
                   structure FileName : FILENAME
                   structure Unix : UNIX
                   structure Diagnostic : DIAGNOSTIC
d149 6
a154 6
                   sharing type Lexer.TokenStream = Compiler.tokenstream
                   sharing InterLoad.Inter_EnvTypes.EnvironTypes =
                     EnvironPrint.EnvironTypes = Environ.EnvironTypes
                   sharing Compiler.Absyn.Ident = Environ.EnvironTypes.LambdaTypes.Ident
		   sharing EnvironPrint.Options = InterLoad.Inter_EnvTypes.Options =
                     Compiler.Options = Debugger_Types.Options
d156 10
a165 9
                   sharing type Compiler.DebugInformation = Debugger_Types.information
                   sharing type Environ.EnvironTypes.LambdaTypes.Primitive =
                     Compiler.Pervasives.pervasive
                   sharing type Environ.EnvironTypes.LambdaTypes.LambdaExp =
                     Compiler.LambdaExp
                   sharing type Environ.EnvironTypes.Top_Env =
                     Compiler.Top_Env
                   sharing type InterLoad.Module = Compiler.Module
		  ) : INTERMAKE =
d172 2
a173 1
    structure LambdaTypes = Environ.EnvironTypes.LambdaTypes
d177 1
d200 4
d247 4
a250 1
             (OPTIONS {name_monitor,error_info,options})
d272 89
a360 1
        fun up_to_date (level, modules, cache, location, module_name, seen, accumulated_info) =
d372 1
a372 1
                ((modules, cache, result,accumulated_info),NONE))
d384 1
a384 1
                              module_name,seen,accumulated_info))
d404 1
a404 1
                            NONE))
d411 1
a411 1
                                      module_name,seen,accumulated_info))
d420 2
a421 2
                              fun check (modules, cache, [],accumulated_info) = 
                                (modules, cache, NONE, accumulated_info)
d423 1
a423 1
                                         (FileName.RELATIVE (route, sub_module_name, _), time)::rest,accumulated_info) =
d427 1
a427 1
                                           accumulated_info),action_required) =
d432 1
a432 1
                                                   accumulated_info)
d436 1
a436 1
                                         check (modules, cache, rest, accumulated_info)
d440 1
a440 1
                                           (modules, cache, RECOMPILE, accumulated_info)
d442 1
a442 1
                                         (modules, cache, LOAD, accumulated_info)
d445 2
a446 2
                              case check (modules, cache, dependencies,accumulated_info) of
                                (modules, cache, NONE, accumulated_info) =>
d450 1
a450 1
                                    NONE))
d452 1
a452 1
                              | (modules, cache, LOAD, accumulated_info) =>
d457 1
a457 1
                                   LOAD))
d459 1
a459 1
                              | (modules, cache, RECOMPILE, accumulated_info) => 
d462 1
a462 1
                                            module_name,seen,accumulated_info))
d466 1
a466 1
        and compile (level, modules, cache, location, module_name,seen,accumulated_info) =
a479 1

d498 1
a498 1
             val (modules, cache, dependencies, compiler_result,accumulated_info) =
d514 1
a514 1
                                       filename, source_location) =
d528 1
a528 1
                     val (time, basis,accumulated_info) =
d532 1
a532 1
                               accumulated_info),_) =
d534 1
a534 1
                                       module_name, new_seen, accumulated_info)
d538 1
a538 1
                         (time, basis,accumulated_info)
d548 2
a549 1
                      basis)
d551 2
a552 2
                 handle Info.Stop (error,error_list) =>
                   raise Error (!current_modules, !current_cache, error, error_list)
d554 2
a555 2
                     
                 val ((dependencies,accumulated_info), compiler_result) =
d557 1
a557 1
                   (([],accumulated_info), initial_compiler_basis)
d566 1
a566 1
                  compiler_result,accumulated_info)
d569 1
a569 1
             val result = 
d574 1
a574 1
             (result,RECOMPILE)
a581 85
         and load (module_name,modules,cache,accumulated_info,
                   compiler_result,absolute,time,load_time,dependencies,filename) = 

           let

             val _ = diagnostic (4, fn _ => ["loading ", module_name])

             val (module,basis) =
               let
                 val Compiler.RESULT {code, basis=basis, ...} = compiler_result
               in
                 (Lists.assoc (module_name, preloaded), basis)
                 handle Lists.Assoc =>
                   let

                     fun module_map module_name =
                       let
                         val RESULT {module, ...} = Map.apply' (modules, module_name)
                       in
                         module
                       end
                   in
                     case (code,accumulated_info) of
                       (Compiler.ABSENT,_) =>
                         Info.error'
                             error_info
                             (Info.FATAL, Info.Location.UNKNOWN,
                              implode ["`", module_name, "' database entry has no code recorded. "])
                       | (Compiler.PRESENT code',(cb,ie,m)) => 
                           (InterLoad.load 
                            (debugger 
                             (adjust_compiler_basis_debug_info
                              (cb,(augment_debug_info(get_basis_debug_info cb,
                                                      get_basis_debug_info basis))),
                              ie,
                              modules,
                              filename))
                            (initial_inter_env, module_map) code',
                            basis)
                   end
               end

             val _ = diagnostic (4, fn _ => ["building environment for ", module_name])

             val inter_env =
               let
                 val Compiler.RESULT {basis = Compiler.BASIS {lambda_environment, ...}, ...} = 
                   compiler_result
               in
                 Inter_EnvTypes.augment_with_module
                 (Inter_EnvTypes.empty_env, lambda_environment, module)
               end

             val accumulated_info =
               augment_accumulated_info(accumulated_info,basis,inter_env,modules)
                   
             val Compiler.RESULT compiler_result' = compiler_result

             val result =
               RESULT {name = module_name,
                       source = absolute,
                       time = time,
                       load_time = load_time,
                       dependencies = dependencies,
                       compiler_result = 
                       if forget_code_after_a_load
                         then
                           Compiler.RESULT{basis= #basis compiler_result',
                                           signatures = #signatures compiler_result',
                                           identifiers = #identifiers compiler_result',
                                           code = Compiler.ABSENT}
                       else
                         compiler_result,
                       module = module,
                       inter_env = inter_env}

             val _ = diagnostic (2, fn _ => ["finished ", module_name])

           in
             (Map.define (modules, module_name, result),
               Map.define (cache, module_name, result),
               result,
               accumulated_info)
           end

d587 3
a589 1
           val ((modules, cache, result,accumulated_info),_) =
d591 1
a591 1
                         (initial_compiler_basis,Inter_EnvTypes.empty_env,empty_modules))
d625 9
a633 1
           (modules, cache, result')
@


1.31
log
@error list field added to Info.Stop
@
text
@d11 3
d236 1
a236 1
    exception Error of modules * cache * Info.error
d258 1
a258 1
                raise Error (modules,cache,Info.ERROR error)
d453 2
a454 1
                 handle Info.Stop (error,error_list) => raise Error (!current_modules, !current_cache, error)
d462 2
a463 1
                     (close_in instream; raise Error (!current_modules, !current_cache, error))
d481 2
a482 1
                                                       "Interrupt pressed")))
@


1.30
log
@Signature changes
@
text
@d11 3
d450 1
a450 1
                 handle Info.Stop error => raise Error (!current_modules, !current_cache, error)
d457 1
a457 1
                   handle Info.Stop error => 
@


1.29
log
@Signature revisions
@
text
@d11 3
d112 7
d120 1
a121 1
require "interload";
d124 2
a125 7
require "../main/io";
require "../utils/filename";
require "../make/unix";
require "../utils/newmap";
require "../utils/lists";
require "../utils/integer";
require "../utils/diagnostic";
d128 6
a133 1
functor InterMake (structure Compiler : COMPILER
a140 3
                   structure Map : NEWMAP
                   structure Lists : LISTS
                   structure Integer : INTEGER
d148 1
a148 1
                     Compiler.Debugger_Types.Options
d150 1
d226 3
a228 4
     val adjust_compiler_basis_debug_info  = Compiler.adjust_compiler_basis_debug_info
     val get_basis_debug_info = Compiler.get_basis_debug_info
     val augment_debug_info = Compiler.Debugger_Types.augment_information

@


1.28
log
@Options & Info changes
@
text
@d11 3
a136 1
                   sharing InterLoad.MachTypes = Compiler.MachTypes
d138 12
a149 10
                     Compiler.EnvironTypes =
                     EnvironPrint.EnvironTypes = 
                     Environ.EnvironTypes
		   sharing EnvironPrint.Options =
			   InterLoad.Inter_EnvTypes.Options =
                           Compiler.MirTypes.Debugger_Types.Options
                   sharing Compiler.EnvironTypes.LambdaTypes.Datatypes.Ident =
                     Compiler.Absyn.Ident
                   sharing type Compiler.EnvironTypes.LambdaTypes.Datatypes.Type =
                     Compiler.Absyn.Type
d157 1
a157 1
    structure LambdaTypes = Compiler.EnvironTypes.LambdaTypes
d220 1
a220 1
     val augment_debug_info = Compiler.MirTypes.Debugger_Types.augment_information
d566 1
a566 1
                val Options.OPTIONS(_,_,print_options) = options
@


1.27
log
@Changed type of name_monitor field; indenting now done in this file.
@
text
@d11 3
d107 1
d121 1
d133 1
d139 7
a145 4
                   sharing Compiler.EnvironTypes.LambdaTypes.Datatypes =
                     Compiler.Parser.Absyn.Datatypes
		   sharing Compiler.Parser.Lexer.Info =
			   InterLoad.Inter_EnvTypes.Info 
d154 3
a156 2
    structure Ident = Compiler.Parser.Absyn.Datatypes.Ident
    structure Info = Compiler.Parser.Lexer.Info
d211 2
a212 1
                  compiler_options	: Compiler.MirTypes.options}
d223 1
a223 2
             (OPTIONS {name_monitor,
                       compiler_options as Compiler.MirTypes.OPTIONS{info_opts,...}})
d240 1
a240 1
                Info.error info_opts error;
d374 1
a374 1
                   info_opts
d380 1
a380 1
                 Info.error' info_opts (Info.FATAL,
d387 1
a387 1
                   Compiler.Parser.Lexer.mkFileTokenStream 
d408 1
a408 1
                         info_opts
d440 1
a440 1
                   Compiler.compile compiler_options require_function
d489 1
a489 1
                             info_opts
d562 1
d566 1
a566 1
		info_opts
d597 1
a597 2
                      (OPTIONS {name_monitor,
                                compiler_options as Compiler.MirTypes.OPTIONS{info_opts,...}})) =
d603 1
a603 1
          info_opts
@


1.26
log
@Substructure changes.
@
text
@d11 3
d200 1
a200 1
      OPTIONS of {name_monitor		: (int * string -> unit) Option.T,
d347 5
a351 1
             Option.PRESENT f => f (level, module_name) 
@


1.25
log
@Put in some simple checks for circularity of requires.  Checks
are done at the start of up_to_date and compile.  Both of these
 may not be necessary.
@
text
@d11 5
d101 3
a103 1
require "../main/info";
d105 2
d109 1
a109 1
require "../utils/filename";
a110 5
require "../utils/integer";
require "../make/unix";
require "../lambda/environprint";
require "../lambda/environ";
require "interload";
d114 3
a117 2
                   structure EnvironPrint : ENVIRONPRINT
                   structure InterLoad : INTERLOAD
a123 1
                   structure Environ : ENVIRON
@


1.24
log
@Changed check on loading time to be <= rather than <
@
text
@d11 3
d210 19
a228 1
        fun up_to_date (level, modules, cache, location, module_name,accumulated_info) =
d231 2
d252 1
a252 1
                              module_name,accumulated_info))
d279 1
a279 1
                                      module_name,accumulated_info))
d299 1
d330 1
a330 1
                                            module_name, accumulated_info))
d334 1
a334 1
        and compile (level, modules, cache, location, module_name,accumulated_info) =
d337 2
d347 1
a347 1

d354 2
a355 2
                  (Info.FAULT, Info.Location.UNKNOWN,
                   implode ["intermake: compile called on non-existent file `", filename, "'"])
d359 3
a361 1
                 Info.error' info_opts (Info.FATAL, Info.Location.UNKNOWN, "intermake: Io error, " ^ message)
d368 1
a368 1
                        Io.sml_name module_name )
d399 1
a399 1
                                       module_name, accumulated_info)
d439 1
a439 1
                                            Info.ERROR(Info.FAULT,
d534 1
a534 1
             up_to_date (0, modules, cache, location, module_name,
@


1.23
log
@We also pass the current module forward for the source_displayer
@
text
@d11 3
d278 1
a278 1
                                     if time = new_time andalso MLWorks.Time.Real.<(new_load_time,load_time)
@


1.22
log
@Changed debug info to have only module name - needed to pass module table through to window stuff
@
text
@d11 3
d297 1
a297 1
                                          time,MLWorks.Time.Real.now(),dependencies),
d402 1
a402 1
                     absolute,time,MLWorks.Time.Real.now(),dependencies)
d413 1
a413 1
                   compiler_result,absolute,time,load_time,dependencies) = 
d447 2
a448 1
                              modules))
@


1.21
log
@Keep the debug information up to date during a load
@
text
@d11 3
a132 1
    val shorten_filename_stored_in_function = false
d334 1
a334 5
                    if shorten_filename_stored_in_function
                      then
                        Io.sml_name(Io.compilation_name filename)
                    else
                      filename)
d405 3
a407 1
                                            Info.ERROR(Info.FAULT,Info.Location.UNKNOWN,"Interrupt pressed")))
d423 1
d444 1
a444 1
                              m))
d554 3
a556 1
      
d561 14
a574 1
      | Map.NO => NOT_FOUND
@


1.20
log
@If Interrupt is hit, the partially updated module table is returned
so that work does not have to be re-done later
@
text
@d11 4
d430 2
a431 2
                     case code of
                       Compiler.ABSENT =>
d436 1
a436 1
                       | Compiler.PRESENT code' => 
d438 6
a443 1
                            (debugger accumulated_info)
@


1.19
log
@Changes to reflect lower level signature changes
@
text
@d11 3
d299 1
a299 1
          (diagnostic (2, fn _ => [Integer.makestring level, " compiling ", module_name]);
d396 2
a397 1
               load (module_name,modules,cache,accumulated_info,compiler_result,absolute,time,MLWorks.Time.Real.now(),dependencies)
d402 2
d405 2
a406 1
         and load (module_name,modules,cache,accumulated_info,compiler_result,absolute,time,load_time,dependencies) = 
@


1.18
log
@Added find_module for the source_displayer
@
text
@d11 3
d110 1
a110 2
			   InterLoad.Inter_EnvTypes.Info =
			   Compiler.MirTypes.Info
d180 1
a180 1
     val augment_debug_info = Compiler.Debugger_Types.augment_information
@


1.17
log
@Fixed sharing constraint to match new constraint in result signature.
@
text
@d11 3
d531 10
@


1.16
log
@Make now checks the preloaded module list before attempting to load
the results of a compilation.
@
text
@d11 4
d101 2
a102 2
                   sharing Compiler.EnvironTypes.LambdaTypes.Datatypes.Ident =
                     Compiler.Parser.Absyn.Datatypes.Ident
@


1.15
log
@Added the load_time slot to the result
@
text
@d11 3
d179 2
a180 4
                       compiler_options as Compiler.MirTypes.OPTIONS{
			 info_opts,
			 ...
	     }}) =
d399 3
a401 2

                 fun module_map module_name =
d403 6
a408 1
                     val RESULT {module, ...} = Map.apply' (modules, module_name)
d410 11
a420 1
                     module
a421 13

               in
                 case code of
                   Compiler.ABSENT =>
                     Info.error'
                         info_opts
                         (Info.FATAL, Info.Location.UNKNOWN,
                          implode ["`", module_name, "' database entry has no code recorded. "])
                   | Compiler.PRESENT code' => 
                       (InterLoad.load 
                        (debugger accumulated_info)
                        (initial_inter_env, module_map) code',
                        basis)
@


1.14
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d11 3
d110 1
a110 1
    val forget_code_after_a_load = true
d126 1
d211 1
a211 1
                                             compiler_result, inter_env, ...}) =>
d246 2
a247 1
                                     val ((modules, cache, RESULT {time = new_time, ...},accumulated_info),action_required) =
d253 9
a261 4
                                     if time = new_time then
                                       check (modules, cache, rest, accumulated_info)
                                     else
                                       (modules, cache, RECOMPILE, accumulated_info)
d272 5
a276 3
                                  (load (module_name,modules,cache,accumulated_info,compiler_result,
                                         FileName.ABSOLUTE (location, module_name, Option.PRESENT "sml"),time,dependencies),
                                  LOAD)
d383 1
a383 1
               load (module_name,modules,cache,accumulated_info,compiler_result,absolute,time,dependencies)
d389 1
a389 1
         and load (module_name,modules,cache,accumulated_info,compiler_result,absolute,time,dependencies) = 
d440 1
d485 1
a485 1
            val RESULT{name,source,time,dependencies,compiler_result,module,inter_env} = result
d491 1
d507 13
@


1.13
log
@Propgate an up-to-date environment in case the make breaks - this might
be rather space inefficient
@
text
@d11 4
d93 3
a95 1
		   sharing Compiler.Parser.Lexer.Info = InterLoad.Inter_EnvTypes.Info
d160 1
a160 1
                  compiler_options	: Compiler.options}
d172 4
a175 1
                       compiler_options as Compiler.OPTIONS{info_opts,...}}) =
d358 1
a358 1
                   Compiler.compile require_function compiler_options
@


1.12
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d11 4
d66 1
d80 2
d85 2
a86 1
                     EnvironPrint.EnvironTypes
d102 1
a102 1
    val shorten_filename_stored_in_function = true
d130 11
d179 1
a179 1
                (modules, cache, result,accumulated_info,NONE))
d198 1
a198 1
                                             compiler_result, ...}) =>
d209 2
a210 2
                           (modules, Map.define (cache, module_name, result), result,
                            Compiler.augment(accumulated_info,basis),
d233 1
a233 1
                                     val (modules, cache, RESULT {time = new_time, ...},accumulated_info,action_required) =
d248 2
a249 2
                                   (modules, Map.define (cache, module_name, result), result,
                                    Compiler.augment(accumulated_info,basis),
d253 3
a255 2
                                  load (module_name,modules,cache,accumulated_info,compiler_result,
                                        FileName.ABSOLUTE (location, module_name, Option.PRESENT "sml"),time,dependencies) 
d325 3
a327 3
                         val (modules, cache,
                              RESULT {time, compiler_result = Compiler.RESULT {basis, ...}, ...},
                              accumulated_info,_) =
d365 1
a365 1
             (#1 result,#2 result,#3 result,#4 result,RECOMPILE)
d374 1
a374 1
             val (module,accumulated_info) =
a384 3
                 val accumulated_info =
                   Compiler.augment(accumulated_info,basis)
                   
d396 1
a396 1
                        accumulated_info)
d410 3
d436 3
a438 4
              Map.define (cache, module_name, result),
              result,
              accumulated_info,
              LOAD)
d446 1
a446 1
           val (modules, cache, result,accumulated_info,_) =
d448 1
a448 1
                         initial_compiler_basis)
d472 1
a472 1
                                     (basis,get_basis_debug_info accumulated_info),
@


1.11
log
@Keeps an up-to-date compiler_basis in case the debugger needs it
@
text
@d11 3
d80 3
a82 1
                     Compiler.Parser.Absyn.Datatypes.Ident) : INTERMAKE =
d438 1
@


1.10
log
@Change to error message.
@
text
@d11 3
d15 2
a16 2
 *  Started working a load dependencies between file - it the compilation options change,
 *  then we do not need to recompile files about the given file - we simply need to
d145 1
a145 1
        fun up_to_date (level, modules, cache, location, module_name,accumulated_debug_info) =
d155 1
a155 1
                (modules, cache, result,accumulated_debug_info,NONE))
d167 1
a167 1
                              module_name,accumulated_debug_info))
d186 1
a186 2
                            augment_debug_info(accumulated_debug_info,
                                               get_basis_debug_info basis),
d194 1
a194 1
                                      module_name,accumulated_debug_info))
d203 2
a204 2
                              fun check (modules, cache, [],accumulated_debug_info) = 
                                (modules, cache, NONE, accumulated_debug_info)
d206 1
a206 1
                                         (FileName.RELATIVE (route, sub_module_name, _), time)::rest,accumulated_debug_info) =
d209 1
a209 1
                                     val (modules, cache, RESULT {time = new_time, ...},accumulated_debug_info,action_required) =
d213 1
a213 1
                                                   accumulated_debug_info)
d216 1
a216 1
                                       check (modules, cache, rest, accumulated_debug_info)
d218 1
a218 1
                                       (modules, cache, RECOMPILE, accumulated_debug_info)
d221 2
a222 2
                              case check (modules, cache, dependencies,accumulated_debug_info) of
                                (modules, cache, NONE, accumulated_debug_info) =>
d225 1
a225 2
                                    augment_debug_info(accumulated_debug_info,
                                                       get_basis_debug_info basis),
d228 2
a229 2
                              | (modules, cache, LOAD, accumulated_debug_info) =>
                                  load (module_name,modules,cache,accumulated_debug_info,compiler_result,
d232 1
a232 1
                              | (modules, cache, RECOMPILE, accumulated_debug_info) => 
d235 1
a235 1
                                            module_name, accumulated_debug_info))
d239 1
a239 1
        and compile (level, modules, cache, location, module_name,accumulated_debug_info) =
d264 1
a264 1
             val (modules, cache, dependencies, compiler_result,accumulated_debug_info) =
d283 1
a283 1
                 fun require_function ((dependencies,accumulated_debug_info), 
d298 1
a298 1
                     val (time, basis,accumulated_debug_info) =
d302 1
a302 1
                              accumulated_debug_info,_) =
d304 1
a304 1
                                       module_name, accumulated_debug_info)
d308 1
a308 1
                         (time, basis,accumulated_debug_info)
d316 1
a316 1
                     (((relative, time)::dependencies,accumulated_debug_info),
d323 1
a323 1
                 val ((dependencies,accumulated_debug_info), compiler_result) =
d325 1
a325 1
                   (([],accumulated_debug_info), initial_compiler_basis)
d333 1
a333 1
                  compiler_result,accumulated_debug_info)
d337 1
a337 1
               load (module_name,modules,cache,accumulated_debug_info,compiler_result,absolute,time,dependencies)
d343 1
a343 1
         and load (module_name,modules,cache,accumulated_debug_info,compiler_result,absolute,time,dependencies) = 
d349 1
a349 1
             val (module,accumulated_debug_info) =
d360 2
a361 3
                 val accumulated_debug_info =
                   augment_debug_info(accumulated_debug_info,
                                      get_basis_debug_info basis)
d372 1
a372 1
                        (debugger (adjust_compiler_basis_debug_info(basis,accumulated_debug_info)))
d374 1
a374 1
                        accumulated_debug_info)
d413 1
a413 1
              accumulated_debug_info,
d422 1
a422 1
           val (modules, cache, result,accumulated_debug_info,_) =
d424 1
a424 1
                         get_basis_debug_info initial_compiler_basis)
d447 1
a447 1
                                     (basis,accumulated_debug_info),
@


1.9
log
@Started working a load dependencies between file - it the compilation options change,
then we do not need to recompile files about the given file - we simply need to
re-load them.
Propagated debug information to get it up to date when the debugger could be called
@
text
@d11 6
d261 1
a261 1
                 Info.error' info_opts (Info.FATAL, Info.Location.UNKNOWN, message)
@


1.8
log
@Modified sharing constraints to remove superfluous structures
@
text
@d11 3
d42 1
d54 1
d79 3
d103 5
d146 1
a146 1
                (modules, cache, result,accumulated_debug_info))
d178 2
a179 1
                                               get_basis_debug_info basis)))
d196 1
a196 1
                                (modules, cache, true,accumulated_debug_info)
d201 1
a201 1
                                     val (modules, cache, RESULT {time = new_time, ...},accumulated_debug_info) =
d208 1
a208 1
                                       check (modules, cache, rest,accumulated_debug_info)
d210 1
a210 1
                                       (modules, cache, false,accumulated_debug_info)
d214 1
a214 1
                                (modules, cache, true,accumulated_debug_info) =>
d218 8
a225 2
                                                       get_basis_debug_info basis)))
                              | (modules, cache, false,accumulated_debug_info) => 
d260 7
a266 1
                   Compiler.Parser.Lexer.mkFileTokenStream (instream, filename)
d295 1
a295 1
                              accumulated_debug_info) =
d329 11
d358 11
a368 4
                 (InterLoad.load 
                  (debugger (adjust_compiler_basis_debug_info(basis,accumulated_debug_info)))
                  (initial_inter_env, module_map) code,
                  accumulated_debug_info)
d375 2
a376 1
                 val Compiler.RESULT {basis = Compiler.BASIS {lambda_environment, ...}, ...} = compiler_result
d382 2
d389 9
a397 1
                       compiler_result = compiler_result,
d407 3
a409 2
              accumulated_debug_info)
           end)
d416 1
a416 1
           val (modules, cache, result,accumulated_debug_info) =
d444 1
a444 1
                                     code=code},
@


1.7
log
@Propogated debugging information all over the shop
@
text
@d11 3
a44 1
require "../lambda/environ";
a49 1
                   structure Environ : ENVIRON
a60 1
                     Environ.EnvironTypes =
d70 1
a70 1
    structure LambdaTypes = Compiler.LambdaTypes
d72 1
a72 1
    structure Info = Compiler.Info
@


1.6
log
@More Error -> Info revision
@
text
@d11 3
d110 5
d117 2
a118 1
    fun make (initial_compiler_basis, initial_inter_env)
d123 1
a123 1
        fun up_to_date (level, modules, cache, location, module_name) =
d133 1
a133 1
                (modules, cache, result))
d144 2
a145 1
                     compile (level, modules, cache, location, module_name))
d151 2
a152 1
                | Map.YES (result as RESULT {source, time, dependencies, ...}) =>
d156 1
d163 3
a165 1
                           (modules, Map.define (cache, module_name, result), result))
d171 2
a172 1
                             compile (level, modules, cache, location, module_name))
d181 5
a185 3
                              fun check (modules, cache, []) = (modules, cache, true)
                                | check (modules, cache, (FileName.RELATIVE (route, sub_module_name, _), time)::rest) =
                                  (diagnostic (4, fn _ => ["checking ", module_name, " depenency ", sub_module_name]);
d187 1
a187 1
                                     val (modules, cache, RESULT {time = new_time, ...}) =
d189 3
a191 1
                                                   FileName.follow (location, route), sub_module_name)
d194 1
a194 1
                                       check (modules, cache, rest)
d196 1
a196 1
                                       (modules, cache, false)
d199 2
a200 2
                              case check (modules, cache, dependencies) of
                                (modules, cache, true) =>
d202 4
a205 2
                                   (modules, Map.define (cache, module_name, result), result))
                              | (modules, cache, false) => 
d207 2
a208 1
                                   compile (level, modules, cache, location, module_name))
d212 1
a212 1
        and compile (level, modules, cache, location, module_name) =
d237 1
a237 1
             val (modules, cache, dependencies, compiler_result) =
d250 2
a251 1
                 fun require_function (dependencies, filename, source_location) =
d265 1
a265 1
                     val (time, basis) =
d268 4
a271 2
                              RESULT {time, compiler_result = Compiler.RESULT {basis, ...}, ...}) =
                           up_to_date (level+1, !current_modules, !current_cache, location, module_name)
d275 1
a275 1
                         (time, basis)
d283 1
a283 1
                     ((relative, time)::dependencies,
d287 1
a287 1
                   handle Info.Stop error => raise Error (!current_modules, !current_cache, error)
d290 1
a290 1
                 val (dependencies, compiler_result) =
d292 1
a292 1
                   ([], initial_compiler_basis)
d294 2
a295 1
                   handle Info.Stop error => (close_in instream; raise Error (!current_modules, !current_cache, error))
d299 2
a300 1
                 (!current_modules, !current_cache, dependencies, compiler_result)
d305 1
a305 1
             val module =
d307 1
a307 1
                 val Compiler.RESULT {code, ...} = compiler_result
d315 5
d321 4
a324 1
                 InterLoad.load (fn x => x) (initial_inter_env, module_map) code
d351 2
a352 1
              result)
d360 3
a362 2
           val (modules, cache, result) =
             up_to_date (0, modules, cache, location, module_name)
d375 17
d393 1
a393 1
           (modules, cache, result)
@


1.5
log
@Changed Error structure to Info
@
text
@d11 3
a79 14
    val dummy_stream = Info.Stream.outstream{output = fn s => output(std_out,s),
                                             flush_out = fn () => (),
                                             close_out = fn () => ()}
    val default_options = Info.OPTIONS {error = {outstream = dummy_stream,
                                                 stop = Info.FATAL,
                                                 report = Info.ADVICE,
                                                 worst = ref Info.ADVICE},
                                        information = {outstream = dummy_stream,
                                                       level = 2},
                                        listing = {outstream = dummy_stream,
                                                   level = 2},
                                        diagnostic = {outstream = dummy_stream,
                                                      level = 2}}

d110 2
a111 1
             (OPTIONS {name_monitor, compiler_options}) =
d207 1
a207 1
                   default_options
d213 1
a213 1
                 Info.error' default_options (Info.FATAL, Info.Location.UNKNOWN, message)
d236 1
a236 1
                         default_options
@


1.4
log
@Changes to pervasives and representation of time.
@
text
@d11 3
d29 1
a59 1
    structure Error = Compiler.Error
d66 1
d77 14
d118 1
a118 1
    exception Error of modules * cache * Error.error
d216 4
a219 3
                   Error.report'
                   (Error.ERROR (Error.FAULT, Error.Location.UNKNOWN,
                                 implode ["intermake: compile called on non-existent file `", filename, "'"]))
d223 1
a223 1
                 Error.report' (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN, message))
d245 4
a248 4
                         Error.report'
                         (Error.ERROR
                          (Error.FATAL, source_location,
                           implode ["`", filename, "' is not a valid relative file name argument to require"]))
d272 1
a272 1
                   handle Error.Stop error => raise Error (!current_modules, !current_cache, error)
d274 1
d279 1
a279 1
                   handle Error.Stop error => (close_in instream; raise Error (!current_modules, !current_cache, error))
@


1.3
log
@Introduced make options as distinct from compiler options.
Added a name monitor to watch the progress of compilations.
Changed the way the require function works in order to return a
partially complete module table if an error occurs.
@
text
@d11 6
a72 2
    type time = {hi : int, lo : int}

d76 2
a77 2
                 time		: time,
                 dependencies	: (FileName.relative * time) list,
d147 1
a147 1
                          if time <> new_time then
@


1.2
log
@Changes for windowing listener
@
text
@d11 3
d24 1
d39 1
a68 2
    exception FileName of string

d78 2
a79 1
    type cache = (string, result) Map.T
d81 2
a82 1
    datatype modules = MODULES of cache
d84 1
a84 2
    val empty_cache = (Map.empty' MLWorks.String.<)
    val empty_modules = MODULES empty_cache
a85 3
    fun add_module (MODULES modules, string, result) =
      MODULES (Map.define (modules, string, result))

d88 1
a88 1
    fun lookup_module (MODULES modules, string) =
d92 8
a99 1
    fun make (initial_compiler_basis, initial_inter_env) compiler_options =
a100 2
        fun up_to_date (modules, cache, location, module_name,consumer) =
          (diagnostic (2, fn _ => [module_name, " up to date?"]);
d102 3
d123 1
a123 1
                     compile (modules, cache, location, module_name,consumer))
d145 1
a145 1
                             compile (modules, cache, location, module_name,consumer))
d154 2
a155 2
                              fun check [] = true
                                | check ((FileName.RELATIVE (route, sub_module_name, _), time)::rest) =
d159 2
a160 2
                                       up_to_date (modules, cache, FileName.follow (location, route), 
                                                   sub_module_name,consumer)
d162 4
a165 1
                                     time = new_time andalso check rest
d168 7
a174 6
                              if check dependencies then
                                (diagnostic (3, fn _ => [module_name, " is up to date!"]);
                                 (modules, Map.define (cache, module_name, result), result))
                              else
                                (diagnostic (3, fn _ => [module_name, " is out of date wrt dependencies"]);
                                 compile (modules, cache, location, module_name,consumer))
d178 2
a179 2
        and compile (modules, cache, location, module_name,consumer) =
          let
d181 3
a183 2
            val _ = diagnostic (2, fn _ => ["compiling ", module_name])
            val _ = consumer (module_name ^ "\n")
d185 1
a185 3
            fun require_function ((modules, cache, dependencies), filename, source_location) =
              let
                val _ = diagnostic (3, fn _ => [module_name, " requiring ", filename])
d187 2
a188 7
                val relative as FileName.RELATIVE (route, module_name, _) =
                  FileName.parse_relative filename
                    handle FileName.Parse _ =>
                      Error.report'
                      (Error.ERROR
                       (Error.FATAL, source_location,
                        implode ["`", filename, "' is not a valid relative file name argument to require"]))
d190 7
a196 1
                val location = FileName.follow (location, route)
d198 3
a200 4
                val (modules, cache,
                     RESULT {time,
                             compiler_result = Compiler.RESULT {basis, ...}, ...}) =
                  up_to_date (modules, cache, location, module_name,fn x => consumer(" " ^ x))
d202 4
a205 11
                val module_expression =
                   LambdaTypes.APP (LambdaTypes.BUILTIN Compiler.Pervasives.LOAD_STRING,
                                    LambdaTypes.SCON (Ident.STRING (module_name)),
                                    LambdaTypes.null_type_annotation)
              in
                ((modules,
                  cache,
                  (relative, time)::dependencies),
                 module_expression,
                 basis)
              end
d207 4
a210 2
            val absolute = FileName.ABSOLUTE (location, module_name, Option.PRESENT "sml")
            val filename = FileName.absolute_name absolute
d212 2
a213 7
            val time =
              case Unix.mtime filename of
                Unix.EXISTS time => time
              | Unix.NOT_EXIST =>
                  Error.report'
                  (Error.ERROR (Error.FAULT, Error.Location.UNKNOWN,
                                implode ["intermake: compile called on non-existent file `", filename, "'"]))
d215 3
a217 4
            val instream = open_in filename
              handle Io message =>
                Error.report'
                (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN, message))
d219 7
a225 4
            val ((modules, cache, dependencies), compiler_result) =
              let
                val token_stream =
                  Compiler.Parser.Lexer.mkFileTokenStream (instream, filename)
d227 1
a227 9
                val result =
                  Compiler.compile require_function compiler_options
                  ((modules, cache, []), initial_compiler_basis)
                  (Compiler.TOKENSTREAM token_stream)
                  handle exn => (close_in instream; raise exn)
              in
                close_in instream;
                result
              end
d229 10
a238 1
            val _ = diagnostic (4, fn _ => ["loading ", module_name])
d240 10
a249 3
            val module =
              let
                val Compiler.RESULT {code, ...} = compiler_result
d251 10
a260 9
                fun module_map module_name =
                  let
                    val RESULT {module, ...} = Map.apply' (modules, module_name)
                  in
                    module
                  end
              in
                InterLoad.load (fn x => x) (initial_inter_env, module_map) code
              end
d262 1
a262 1
            val _ = diagnostic (4, fn _ => ["building environment for ", module_name])
d264 3
a266 7
            val inter_env =
              let
                val Compiler.RESULT {basis = Compiler.BASIS {lambda_environment, ...}, ...} = compiler_result
              in
                Inter_EnvTypes.augment_with_module
                (Inter_EnvTypes.empty_env, lambda_environment, module)
              end
d268 9
a276 8
            val result =
              RESULT {name = module_name,
                      source = absolute,
                      time = time,
                      dependencies = dependencies,
                      compiler_result = compiler_result,
                      module = module,
                      inter_env = inter_env}
d278 1
a278 1
            val _ = diagnostic (2, fn _ => ["finished ", module_name])
d280 7
a286 5
          in
            (Map.define (modules, module_name, result),
             Map.define (cache, module_name, result),
             result)
          end
d288 17
d306 2
a307 1
        fn (MODULES modules, cache, filename as FileName.ABSOLUTE (location, module_name, _),consumer) =>
d311 1
a311 1
             up_to_date (modules, cache, location, module_name, consumer)
d325 1
a325 1
           (MODULES modules, cache, result)
d327 1
@


1.1
log
@Initial revision
@
text
@d10 4
a13 1
 *  $Log$
d93 1
a93 1
        fun up_to_date (modules, cache, location, module_name) =
d114 1
a114 1
                     compile (modules, cache, location, module_name))
d136 1
a136 1
                             compile (modules, cache, location, module_name))
d150 2
a151 1
                                       up_to_date (modules, cache, FileName.follow (location, route), sub_module_name)
d161 1
a161 1
                                 compile (modules, cache, location, module_name))
d165 1
a165 1
        and compile (modules, cache, location, module_name) =
d169 1
d188 1
a188 1
                  up_to_date (modules, cache, location, module_name)
d277 1
a277 1
        fn (MODULES modules, cache, filename as FileName.ABSOLUTE (location, module_name, _)) =>
d281 1
a281 1
             up_to_date (modules, cache, location, module_name)
@
