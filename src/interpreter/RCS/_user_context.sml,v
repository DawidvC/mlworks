head	1.23;
access;
symbols
	MLW_daveb_inline_1_4_99:1.23.1
	MLWorks_21c0_1999_03_25:1.23
	MLWorks_20c1_1998_08_20:1.23
	MLWorks_20c0_1998_08_04:1.23
	MLWorks_20b2c2_1998_06_19:1.23
	MLWorks_20b2_Windows_1998_06_12:1.23
	MLWorks_20b1c1_1998_05_07:1.22
	MLWorks_20b0_1998_04_07:1.22
	MLWorks_20b0_1998_03_20:1.22
	MLWorks_20m2_1998_02_16:1.21
	MLWorks_20m1_1997_10_23:1.21
	MLWorks_11r1:1.18.5.1.1.2.1
	MLWorks_workspace_97:1.20.2
	MLWorks_dt_wizard:1.20.1
	MLWorks_11c0_1997_09_09:1.18.5.1.1.2
	MLWorks_10r3:1.18.5.1.3
	MLWorks_10r2_551:1.18.5.1.2
	MLWorks_11:1.18.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.18.5.1
	MLWorks_20m0_1997_06_20:1.19
	MLWorks_1_0_r2c2_1997_06_14:1.18.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.18.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.18.5
	MLWorks_BugFix_1997_04_24:1.18
	MLWorks_1_0_r2_Win32_1997_04_11:1.18
	MLWorks_1_0_r2_Unix_1997_04_04:1.18
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.18.3.1.1
	MLWorks_gui_1996_12_18:1.18.4
	MLWorks_1_0_Win32_1996_12_17:1.18.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.18.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.18.1.1
	MLWorks_1_0_Irix_1996_11_28:1.18.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.18.2
	MLWorks_1_0_Unix_1996_11_14:1.18.1
	MLWorks_Open_Beta2_1996_10_11:1.16.3
	MLWorks_License_dev:1.16.2
	MLWorks_1_open_beta_1996_09_13:1.16.1
	MLWorks_Open_Beta_1996_08_22:1.16
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.15
	MLWorks_Beta_1996_06_06:1.15
	MLWorks_Beta_1996_06_05:1.15
	MLWorks_Beta_1996_06_03:1.15
	MLWorks_Beta_1996_05_31:1.15
	MLWorks_Beta_1996_05_30:1.15;
locks; strict;
comment	@ * @;


1.23
date	98.06.03.16.30.16;	author mitchell;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	98.03.18.17.15.21;	author mitchell;	state Exp;
branches;
next	1.21;

1.21
date	97.10.14.09.33.07;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	97.07.31.13.24.17;	author johnh;	state Exp;
branches
	1.20.1.1
	1.20.2.1;
next	1.19;

1.19
date	97.05.02.16.57.22;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	96.11.06.11.13.52;	author matthew;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1
	1.18.4.1
	1.18.5.1;
next	1.17;

1.17
date	96.10.09.11.56.47;	author io;	state Exp;
branches;
next	1.16;

1.16
date	96.08.15.13.56.38;	author daveb;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1;
next	1.15;

1.15
date	96.05.14.11.36.46;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	96.05.01.09.50.55;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.04.30.09.40.18;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	96.04.11.15.14.11;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	96.03.15.10.21.03;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	96.02.23.17.56.03;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	96.02.08.13.56.19;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	96.01.17.17.20.55;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.07.13.12.09.35;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.06.08.14.21.54;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.06.06.12.23.48;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.06.05.13.57.52;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.05.30.17.34.34;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	95.05.19.15.51.13;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	95.05.01.08.54.52;	author daveb;	state Exp;
branches;
next	;

1.16.1.1
date	96.09.13.11.16.21;	author hope;	state Exp;
branches;
next	;

1.16.2.1
date	96.10.07.16.06.20;	author hope;	state Exp;
branches;
next	;

1.16.3.1
date	96.10.17.11.24.35;	author hope;	state Exp;
branches;
next	;

1.18.1.1
date	96.11.14.12.49.21;	author hope;	state Exp;
branches
	1.18.1.1.1.1;
next	;

1.18.1.1.1.1
date	96.11.28.15.00.38;	author hope;	state Exp;
branches;
next	;

1.18.2.1
date	96.11.22.18.09.01;	author hope;	state Exp;
branches;
next	;

1.18.3.1
date	96.12.17.17.47.40;	author hope;	state Exp;
branches
	1.18.3.1.1.1;
next	;

1.18.3.1.1.1
date	97.02.24.11.37.25;	author hope;	state Exp;
branches;
next	;

1.18.4.1
date	96.12.18.09.41.40;	author hope;	state Exp;
branches;
next	;

1.18.5.1
date	97.05.12.10.34.07;	author hope;	state Exp;
branches
	1.18.5.1.1.1
	1.18.5.1.2.1
	1.18.5.1.3.1;
next	;

1.18.5.1.1.1
date	97.07.28.18.19.11;	author daveb;	state Exp;
branches;
next	1.18.5.1.1.2;

1.18.5.1.1.2
date	97.08.04.15.37.11;	author johnh;	state Exp;
branches
	1.18.5.1.1.2.1.1;
next	;

1.18.5.1.1.2.1.1
date	97.10.07.11.44.18;	author jkbrook;	state Exp;
branches;
next	1.18.5.1.1.2.1.2;

1.18.5.1.1.2.1.2
date	97.10.14.16.45.50;	author jkbrook;	state Exp;
branches;
next	;

1.18.5.1.2.1
date	97.09.08.17.12.47;	author daveb;	state Exp;
branches;
next	;

1.18.5.1.3.1
date	97.09.09.14.08.25;	author daveb;	state Exp;
branches;
next	1.18.5.1.3.2;

1.18.5.1.3.2
date	97.10.14.17.32.12;	author jkbrook;	state Exp;
branches;
next	;

1.20.1.1
date	97.09.10.19.23.35;	author brucem;	state Exp;
branches;
next	;

1.20.2.1
date	97.09.11.20.54.33;	author daveb;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	97.09.12.15.13.28;	author johnh;	state Exp;
branches;
next	;

1.23.1.1
date	99.04.01.17.56.42;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Separated user context code from shelltypes.sml.
@


1.23
log
@[Bug #70125]
Zap history when moving from user to system context
@
text
@(* User contexts.
 *
 * Copyright (C) 1995 Harlequin Ltd.
 *
 * $Log: _user_context.sml,v $
 * Revision 1.22  1998/03/18  17:15:21  mitchell
 * [Bug #50062]
 * Fix context browser so contents persists in saved images, and the basis appears in the initial context for guib
 *
 * Revision 1.21  1997/10/14  09:33:07  daveb
 * [Bug #30283]
 * Added with_null_history.
 *
 * Revision 1.20  1997/07/31  13:24:17  johnh
 * [Bug #50019]
 * Modify process_result to take a UserContext.source_reference type for src.
 *
 * Revision 1.19  1997/05/02  16:57:22  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.18  1996/11/06  11:13:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.17  1996/10/09  11:56:47  io
 * moving String from toplevel
 *
 * Revision 1.16  1996/08/15  13:56:38  daveb
 * [Bug #1519]
 * Allowed the source field of an item to indicate that it shares the source
 * of the previous item in the history.
 *
 * Revision 1.15  1996/05/14  11:36:46  daveb
 * Added null_history and save_name_set.
 *
 * Revision 1.14  1996/05/01  09:50:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.13  1996/04/30  09:40:18  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.12  1996/04/11  15:14:11  daveb
 * Added history deletion functions, changed the type of update functions,
 * and added a preferences argument to process_result (and made it take a
 * record instead of a tuple).
 *
 * Revision 1.11  1996/03/15  10:21:03  daveb
 * Made process_result update the context before calling the update functions,
 * because the update_graph function in the browser reads the context rather
 * than using its arguments.
 *
 * Revision 1.10  1996/02/23  17:56:03  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.9  1996/02/08  13:56:19  daveb
 * The update_functions now take the list of new items as an argument.
 * Removed the old selection stuff.  Removed some detritus..
 *
 *  Revision 1.8  1996/01/17  17:20:55  matthew
 *  Adding history_item_name function
 *
 *  Revision 1.7  1995/07/13  12:09:35  matthew
 *  Moving identifier type to Ident
 *
 *  Revision 1.6  1995/06/08  14:21:54  daveb
 *  process_result was assuming a non-empty list of results.
 *
 *  Revision 1.5  1995/06/06  12:23:48  daveb
 *  Added get_latest and get_n, to support history operations.
 *
 *  Revision 1.4  1995/06/05  13:57:52  daveb
 *  Made process_result set the current selection if the set_selection
 *  user option is set.
 *
 *  Revision 1.3  1995/05/30  17:34:34  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.2  1995/05/19  15:51:13  daveb
 *  Added getInitialContext.
 *
 *  Revision 1.1  1995/05/01  08:54:52  daveb
 *  new unit
 *  Separated user context code from shelltypes.sml.
 *
 *  
*)

require "../basis/__int";

require "incremental";
require "interprint";
require "../main/user_options";
require "../main/preferences";
require "../utils/lists";
require "../utils/map";
require "../utils/crash";
require "user_context";

functor UserContext
  (structure Incremental: INCREMENTAL
   structure InterPrint: INTERPRINT
   structure Lists: LISTS
   structure UserOptions: USER_OPTIONS
   structure Preferences: PREFERENCES
   structure Map: MAP
   structure Crash: CRASH

   sharing Incremental.InterMake.Compiler = InterPrint.Compiler
   sharing InterPrint.Compiler.Options = UserOptions.Options

   sharing type InterPrint.Context = Incremental.Context
): USER_CONTEXT =
struct
  structure Options = UserOptions.Options
  structure Ident = Incremental.InterMake.Compiler.Absyn.Ident
  structure Symbol = Ident.Symbol

  type user_context_options = UserOptions.user_context_options
  type preferences = Preferences.preferences
  type Context = Incremental.Context

  datatype ContextName = CONTEXTNAME of string * int list
  (* Context names have the form MLWorks-0, MLWorks-1.2.1, etc. *)

  type identifier = Ident.Identifier
  type Result = Incremental.Result

  (* A source reference stores the source of a value in the history.
     The COPY constructor is used when the same source binds several
     identifiers.  The function that saves source to files (in gui_utils)
     ignores copies.  *)
  datatype source_reference =
    STRING of string
  | COPY of string

  (* The History tool uses a list of history entries. *)
  datatype history_entry =
    ITEM of
      {index: int,		 (* the number of the entry in the history *)
       id: identifier,		 (* the identifier that was defined *)
       context: Context,	 (* the delta context after evaluating the id *)
       result: string,		 (* the printed version of the result *)
       source: source_reference} (* the source string *)
  (* If the source field is NONE, the source is assumed to be the same as
     the previous entry.  *)

  type register_key = int

  datatype user_context =
    USER_CONTEXT of
      {info: (Context * Context * history_entry list) ref,
       user_options: UserOptions.user_context_options,
       update_register:
	 ((register_key,
	  (history_entry list option -> unit)) Map.map * int) ref,
       name: ContextName ref,
       version_number: int ref,
       is_constant: bool,
       save_file: string option ref}

  exception DebuggerTrapped

  val initialContext = ref NONE

  val contextList = ref []

  fun makeInitialUserContext (context, name, user_options) =
    let
      val newcontext =
	USER_CONTEXT
	  {info = ref (context, context, []),
	   name = ref (CONTEXTNAME(name, [])),
	   user_options = user_options,
	   update_register = ref (Map.empty' op<, 0),
	   version_number = ref 0,
	   is_constant = true,
	   save_file = ref NONE}

      exception AlreadyInitialised
    in
      case !initialContext of
	NONE => initialContext := SOME newcontext
      | _ => raise AlreadyInitialised;
      contextList := [newcontext];
      newcontext
    end

  fun pushContext c = contextList := c :: (!contextList)

  fun getCurrentContexts () = !contextList

  fun copyUserContext
	(USER_CONTEXT
	   {info = ref (context, _, _),
	    name = ref (CONTEXTNAME(name, l)),
	    user_options,
	    version_number = r,
	    ...}) =
    let
      val newcontext =
	USER_CONTEXT
	  {info = ref (context, Incremental.empty_context, []),
	   user_options = UserOptions.copy_user_context_options user_options,
	   update_register = ref (Map.empty' op<, 0),
	   name = ref (CONTEXTNAME(name, !r+1 :: l)),
	   version_number = ref 0,
	   is_constant = false,
	   save_file = ref NONE}

    in
      r := !r + 1;
      pushContext newcontext;
      newcontext
    end

  fun add_update_fn
	(USER_CONTEXT {update_register as ref (map, count), ...}, update_fn) =
    (update_register := (Map.define (map, count, update_fn), count + 1);
     count)

  fun remove_update_fn
	(USER_CONTEXT {update_register as ref (map, count), ...}, key) =
    update_register := (Map.undefine (map, key), count)

  local
    fun string_index_list (str, [], l) = concat (str :: "-" :: l)
    |   string_index_list (str, x::t, []) =
      string_index_list (str, t, [Int.toString x])
    |   string_index_list (str, x::t, l) =
      string_index_list (str, t, Int.toString x :: "." :: l)
  
    fun string_context_name (CONTEXTNAME(str, [])) = str
    |   string_context_name (CONTEXTNAME(str, index)) =
      string_index_list (str, index, [])
  in
    fun get_context_name (USER_CONTEXT {name, is_constant, ...}) =
      let
	val str = string_context_name (!name)
      in 
	if is_constant then
	  str ^ " (Read Only)"
	else
	  str
      end

    fun set_context_name (USER_CONTEXT {name, is_constant, ...}, new_name) =
      name := CONTEXTNAME (new_name, [1])
  end
  
  fun getInitialContext () =
    case !initialContext
    of SOME c => c
    |  _ => Crash.impossible "Bad initial context!"

  fun getNewInitialContext () =
    let
      val c = copyUserContext (getInitialContext ())
    in
      case c of
        USER_CONTEXT {name as ref (CONTEXTNAME (_, l)), ...} =>
          name := CONTEXTNAME ("MLWorks", l);
      c
    end

  fun get_saved_file_name (USER_CONTEXT {save_file, ...}) = !save_file

  fun set_saved_file_name (USER_CONTEXT {save_file, ...}, name) =
    save_file := SOME name

  fun saved_name_set user_context =
    case get_saved_file_name user_context
    of NONE => false
    |  SOME _ => true

  fun get_context_info (USER_CONTEXT {info,...}) = !info

  fun set_context_info
	(USER_CONTEXT {info, update_register as ref (map, _), ...}, newinfo) =
    (info := newinfo)

  local
    fun get_hist c = #3 (get_context_info c)
  in
    fun get_latest c =
      case get_hist c
      of [] => NONE
      |  (h::t) => SOME h

    fun get_nth (c, n) =
      (* The history is stored in reverse order, so we need to get the
	 index of the latest entry and subtract the parameter from that. *)
      case get_hist c
      of [] => NONE
      |  l as (ITEM {index, ...} :: _) =>
        SOME (Lists.nth (index - n, l))
        handle
          Lists.Nth => NONE
  end

  fun clear_debug_info (user_context, name) =
    let val (c, delta, hist) = get_context_info user_context
    in
      set_context_info
        (user_context,
         (Incremental.clear_debug_info (name, c),
          Incremental.clear_debug_info (name, delta),
          hist))
    end

  fun clear_debug_all_info user_context =
    let val (c, delta, hist) = get_context_info user_context
    in
      set_context_info
        (user_context,
         (Incremental.clear_debug_all_info c,
          Incremental.clear_debug_all_info delta,
          hist))
    end

  fun get_user_options (USER_CONTEXT {user_options,...}) = user_options

  fun get_context (USER_CONTEXT {info,...}) = #1(!info)

  fun get_delta (USER_CONTEXT {info,...}) = #2(!info)

  fun get_history (USER_CONTEXT {info,...}) = #3(!info)

  fun null_history user_context =
    length (get_history user_context) = 0

  fun with_null_history (USER_CONTEXT {info,...}) f x =
    let
      val old_info = !info
      val new_info = (#1 (!info), Incremental.empty_context, [])
      val _ = info := new_info
      val result =
	f x
	handle exn => (info := old_info; raise exn)
    in
      info := old_info; 
      result
    end

  fun is_const_context (USER_CONTEXT r) = #is_constant r


  (* The following functions delete selected items or duplicates from
     a history.  Care must be taken to re-number the items correctly. *)

  fun renumber_from (n, l) =
    let
      fun renumber ((i, l), ITEM {id, context, result, source, ...}) =

	let
	  val newItem =
	    ITEM
	      {index = i+1, id = id, context = context,
	       result = result, source = source}
	in
          (i+1, newItem :: l)
	end

      val (_, result) =
        Lists.reducel renumber ((n, []), rev l)
    in
      result
    end

  local
    exception NotFound

    fun aux (n, [], l) = raise NotFound
    |   aux (n, ITEM {index = n', id, context, result, source} :: t, l) =
      if n = n' then
        rev l @@ t
      else
	let
	  val newItem =
	    ITEM
	      {index = n' - 1,
	       id = id,
	       context = context,
	       result = result,
	       source = source}
	in
          aux (n, t, newItem :: l)
	end
  in
    fun delete_item_from_history (ITEM {index, ...}, hist) =
      aux (index, hist, [])
      handle
        NotFound => hist
  end
	  
  fun delete_from_history (user_context, item) =
    let
      val USER_CONTEXT {info, update_register as ref (fn_map, _), ...} =
	user_context
      val (c, delta, hist) = !info
      val new_hist = delete_item_from_history (item, hist)
    in
      set_context_info (user_context, (c, delta, new_hist));
      Map.iterate (fn (_, f) => f NONE) fn_map
    end

  fun delete_entire_history user_context =
    let
      val USER_CONTEXT {info, update_register as ref (fn_map, _), ...} =
	user_context
      val (c, delta, hist) = !info
    in
      set_context_info (user_context, (c, delta, []));
      Map.iterate (fn (_, f) => f NONE) fn_map
    end

  fun remove_duplicate_items_from_history (id, hist) =
    let
      (* Traverse the list in reverse order, deleting duplicates and
	 decrementing the indices as required. *)
      fun aux ([], _, acc) = acc
      |   aux ((item as ITEM {index, id = id', context, result, source}) :: l,
	       decrement, acc) =
        if id = id' then
          aux (l, decrement + 1, acc)
        else if decrement = 0 then
          aux (l, 0, item :: acc)
	else
	  let
	    val newItem =
	      ITEM
		{index = index - decrement,
		 id = id',
		 context = context,
		 result = result,
		 source = source}
	  in
	    aux (l, decrement, newItem :: acc)
	  end
    in
      aux (rev hist, 0, [])
    end

  (* The result of this must be renumbered before use *)
  fun remove_all_duplicates_from_history hist =
    let
      fun aux ([], result) = rev result
      |   aux ((item as ITEM {id, ...}) :: l, result) =
        let
          val l' = remove_duplicate_items_from_history (id, l)
        in
          aux (l', item :: result)
        end
    in
      aux (hist, [])
    end

  fun remove_duplicates_from_history user_context =
    let
      val USER_CONTEXT {info, update_register as ref (fn_map, _), ...} =
	user_context
      val (c, delta, hist) = !info
      val stripped_hist = remove_all_duplicates_from_history hist
      val new_hist = renumber_from (0, stripped_hist)
    in
      set_context_info (user_context, (c, delta, new_hist));
      Map.iterate (fn (_, f) => f NONE) fn_map
    end


  (* When saving guib.img we move the basis from the user context to the 
     initial context, and clear the user context.  *)

  fun move_context_history_to_system (USER_CONTEXT {info=from_info, ...}) =
    let val USER_CONTEXT {info=system_info, ...} = getInitialContext()
        val (from_context, from_delta, from_history) = !from_info
     in system_info := (from_context, from_context, []);
        from_info := (#1 (!from_info), Incremental.empty_context, []) 
    end

  fun process_result
	{src, result, user_context, preferences, options, output_fn} =
    let
      val USER_CONTEXT {info, update_register as ref (fn_map, _), ...} =
	user_context

      val remove_duplicates_from_context =
	case preferences
	of Preferences.PREFERENCES
	     {environment_options =
		Preferences.ENVIRONMENT_OPTIONS
		  {remove_duplicates_from_context, ...},
	      ...} =>
	  !remove_duplicates_from_context

      val (c, delta, hist) = !info

      val new_delta = Incremental.add_definitions(options, delta, result)

      val new_context = Incremental.add_definitions (options, c, result)

      val result_strings =
        InterPrint.strings
	  (new_context, options,
	   Incremental.identifiers_from_result result,
	   Incremental.pb_from_result result);

      val current_index =
        case hist
	of [] => 0
	|  (ITEM {index, ...} :: _) => index

      (* In the Listener, if we type two definitions without a semicolon
       * separating them, then the entire text is passed to process_result
       * as the source.  As a result we only want one string copy of the source
       * text to be stored in the history list so that only one copy is saved.
       *)
      val copy_src = case src of 
	  COPY s => COPY s
	| STRING s => COPY s

      fun mkItem ((n, l, source), (id, result)) =
	let
	  val newItem =
	    ITEM 
	      {index = n+1,
	       id = id,
	       context = new_delta,
	       result = result,
	       source = source}
	in
	  (n+1, newItem :: l, copy_src)
	end

      val (_, new_items, _) =
        Lists.reducel
	  mkItem
	  ((current_index, [], src), result_strings)

      val new_items' =
	if remove_duplicates_from_context then
	  remove_all_duplicates_from_history new_items
	else
	  new_items

      val old_hist =
	if remove_duplicates_from_context then
	  Lists.reducel
	    (fn (h, ITEM {id, ...}) =>
	       remove_duplicate_items_from_history (id, h))
	    (hist, new_items')
	else
	  hist

      (* Removal of duplicates may have changed the current index *)
      val new_index =
        case old_hist
	of [] => 0
	|  (ITEM {index, ...} :: _) => index

      val new_items'' =
	if new_index = current_index then
	  new_items'
	else
	  renumber_from (new_index, new_items')

      val new_hist = new_items'' @@ old_hist
    in
      Lists.iterate (fn (_, s) => output_fn s) result_strings;
      info := (new_context, new_delta, new_hist);
      Map.iterate (fn (_, f) => f (SOME new_items)) fn_map
    end

  val dummy_context =
    USER_CONTEXT
      {info = ref (Incremental.empty_context, Incremental.empty_context, []),
       name = ref (CONTEXTNAME("", [])),
       user_options =
	 UserOptions.make_user_context_options Options.default_options,
       update_register = ref (Map.empty' op<, 0),
       version_number = ref 0,
       is_constant = true,
       save_file = ref NONE}

  fun history_entry_name (ITEM {id, ...}) =
    case id of
      Ident.VALUE (Ident.VAR s) => SOME (Symbol.symbol_name s)
    | _ => NONE
end;
@


1.23.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.23  1998/06/03  16:30:16  mitchell
 * [Bug #70125]
 * Zap history when moving from user to system context
 *
@


1.22
log
@[Bug #50062]
Fix context browser so contents persists in saved images, and the basis appears in the initial context for guib
@
text
@d6 4
d480 1
a480 1
     in system_info := (from_context, from_context, from_history);
@


1.21
log
@[Bug #30283]
Added with_null_history.
@
text
@d6 4
d469 10
@


1.20
log
@[Bug #50019]
Modify process_result to take a UserContext.source_reference type for src.
@
text
@d6 4
d326 13
@


1.20.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 * Revision 1.20  1997/07/31  13:24:17  johnh
 * [Bug #50019]
 * Modify process_result to take a UserContext.source_reference type for src.
 *
@


1.20.2.2
log
@[Bug #30071]
Redesign Comopilation Manager -> Project Workspace.
get/set project file.
@
text
@d155 1
a155 2
       save_file: string option ref,
       project_file: string option ref}
d173 1
a173 2
	   save_file = ref NONE,
 	   project_file = ref NONE}
d204 1
a204 2
	   save_file = ref NONE,
 	   project_file = ref NONE}
a270 10
  fun get_project_file (USER_CONTEXT {project_file, ...}) = !project_file

  fun set_project_file (USER_CONTEXT {project_file, ...}, name) = 
    project_file := SOME name

  fun project_file_set user_context = 
    case get_project_file user_context of
      NONE   => false
    | SOME _ => true

d555 1
a555 2
       save_file = ref NONE,
       project_file = ref NONE}
@


1.20.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 4
 * Revision 1.20  1997/07/31  13:24:17  johnh
 * [Bug #50019]
 * Modify process_result to take a UserContext.source_reference type for src.
 *
@


1.19
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d6 4
d481 9
d500 1
a500 1
	  (n+1, newItem :: l, COPY src)
d506 1
a506 1
	  ((current_index, [], STRING src), result_strings)
@


1.18
log
@[Bug #1728]
__integer becomes __int
@
text
@d6 4
a101 1
  structure Option = MLWorks.Option
d143 1
a143 1
	  (history_entry list Option.option -> unit)) Map.map * int) ref,
d170 1
a170 1
	Option.NONE => initialContext := SOME newcontext
d526 1
a526 1
      Map.iterate (fn (_, f) => f (Option.SOME new_items)) fn_map
@


1.18.5.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/06  11:13:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.18.5.1  1997/05/12  10:34:07  hope
 * branched from 1.18
 *
@


1.18.5.1.3.2
log
@[Bug #30283]
Merging from trunk:
Adding with_null_history
@
text
@a5 3
 * Revision 1.18.5.1.3.1  1997/09/09  14:08:25  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
a321 13

  fun with_null_history (USER_CONTEXT {info,...}) f x =
    let
      val old_info = !info
      val new_info = (#1 (!info), Incremental.empty_context, [])
      val _ = info := new_info
      val result =
	f x
	handle exn => (info := old_info; raise exn)
    in
      info := old_info; 
      result
    end
@


1.18.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.18.5.1  1997/05/12  10:34:07  hope
 * branched from 1.18
 *
@


1.18.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.18.5.1  1997/05/12  10:34:07  hope
 * branched from 1.18
 *
@


1.18.5.1.1.2
log
@[Bug #50019]
Merging - changing type of src field in UserContext.process_result.
@
text
@a5 4
 *
 * Revision 1.18.5.1.1.1  1997/07/28  18:19:11  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a480 9
      (* In the Listener, if we type two definitions without a semicolon
       * separating them, then the entire text is passed to process_result
       * as the source.  As a result we only want one string copy of the source
       * text to be stored in the history list so that only one copy is saved.
       *)
      val copy_src = case src of 
	  COPY s => COPY s
	| STRING s => COPY s

d491 1
a491 1
	  (n+1, newItem :: l, copy_src)
d497 1
a497 1
	  ((current_index, [], src), result_strings)
@


1.18.5.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 4
 * Revision 1.18.5.1.1.2  1997/08/04  15:37:11  johnh
 * [Bug #50019]
 * Merging - changing type of src field in UserContext.process_result.
 *
@


1.18.5.1.1.2.1.2
log
@[Bug #30283]
Merging from trunk:
Adding with_null_history
@
text
@a5 3
 * Revision 1.18.5.1.1.2.1.1  1997/10/07  11:44:18  jkbrook
 * branched from MLWorks_11 for label MLWorks_11r1
 *
a329 13

  fun with_null_history (USER_CONTEXT {info,...}) f x =
    let
      val old_info = !info
      val new_info = (#1 (!info), Incremental.empty_context, [])
      val _ = info := new_info
      val result =
	f x
	handle exn => (info := old_info; raise exn)
    in
      info := old_info; 
      result
    end
@


1.18.4.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/06  11:13:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.3.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/06  11:13:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.3.1.1.1
log
@branched from 1.18.3.1
@
text
@a5 3
 * Revision 1.18.3.1  1996/12/17  17:47:40  hope
 * branched from 1.18
 *
@


1.18.2.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/06  11:13:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.1.1
log
@branched from 1.18
@
text
@a5 4
 * Revision 1.18  1996/11/06  11:13:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.1.1.1.1
log
@branched from 1.18.1.1
@
text
@a5 3
 * Revision 1.18.1.1  1996/11/14  12:49:21  hope
 * branched from 1.18
 *
@


1.17
log
@moving String from toplevel
@
text
@d6 3
d72 1
a72 1
require "../basis/__integer";
@


1.16
log
@[Bug #1519]
Allowed the source field of an item to indicate that it shares the source
of the previous item in the history.
@
text
@d6 5
d141 1
a141 1
       save_file: string MLWorks.Option.option ref}
d145 1
a145 1
  val initialContext = ref Option.NONE
d159 1
a159 1
	   save_file = ref Option.NONE}
d164 1
a164 1
	Option.NONE => initialContext := Option.SOME newcontext
d190 1
a190 1
	   save_file = ref Option.NONE}
d208 1
a208 1
    fun string_index_list (str, [], l) = String.implode (str :: "-" :: l)
d234 1
a234 1
    of Option.SOME c => c
d250 1
a250 1
    save_file := Option.SOME name
d254 2
a255 2
    of MLWorks.Option.NONE => false
    |  MLWorks.Option.SOME _ => true
d268 2
a269 2
      of [] => Option.NONE
      |  (h::t) => Option.SOME h
d275 1
a275 1
      of [] => Option.NONE
d277 1
a277 1
        Option.SOME (Lists.nth (index - n, l))
d279 1
a279 1
          Lists.Nth => Option.NONE
d311 1
a311 1
    Lists.length (get_history user_context) = 0
d372 1
a372 1
      Map.iterate (fn (_, f) => f Option.NONE) fn_map
d382 1
a382 1
      Map.iterate (fn (_, f) => f Option.NONE) fn_map
d435 1
a435 1
      Map.iterate (fn (_, f) => f Option.NONE) fn_map
d532 1
a532 1
       save_file = ref MLWorks.Option.NONE}
d536 2
a537 2
      Ident.VALUE (Ident.VAR s) => Option.SOME (Symbol.symbol_name s)
    | _ => Option.NONE
@


1.16.3.1
log
@branched from 1.16
@
text
@a5 5
 * Revision 1.16  1996/08/15  13:56:38  daveb
 * [Bug #1519]
 * Allowed the source field of an item to indicate that it shares the source
 * of the previous item in the history.
 *
@


1.16.2.1
log
@branched from 1.16
@
text
@a5 5
 * Revision 1.16  1996/08/15  13:56:38  daveb
 * [Bug #1519]
 * Allowed the source field of an item to indicate that it shares the source
 * of the previous item in the history.
 *
@


1.16.1.1
log
@branched from 1.16
@
text
@a5 5
 * Revision 1.16  1996/08/15  13:56:38  daveb
 * [Bug #1519]
 * Allowed the source field of an item to indicate that it shares the source
 * of the previous item in the history.
 *
@


1.15
log
@Added null_history and save_name_set.
@
text
@d6 3
d105 9
d115 8
a122 5
    ITEM of int * identifier * Context * string * string
  (* An entry in the history list of a context contains the number of the
     entry in the history, the identifier that was defined, the delta context
     after evaluating it, the string version of the result of evaluation, and
     the source string.  This list is used directly by the history widget. *)
d271 2
a272 2
      |  l as (ITEM (i, _, _, _, _) :: _) =>
        Option.SOME (Lists.nth (i-n, l))
d316 11
d328 1
a328 4
        Lists.reducel
          (fn ((i, l), ITEM (_, id, d, s, src)) =>
             (i+1, ITEM (i+1, id, d, s, src) :: l))
          ((n, []), rev l)
d337 1
a337 1
    |   aux (n, ITEM (n', w, x, y, z) :: t, l) =
d341 11
a351 1
        aux (n, t, ITEM (n' - 1, w, x, y, z) :: l)
d353 2
a354 2
    fun delete_item_from_history (ITEM {1 = n, ...}, hist) =
      aux (n, hist, [])
d384 3
a386 2
      fun aux ([], _, result) = result
      |   aux ((item as ITEM (n, id', x, y, z)) :: l, decrement, result) =
d388 1
a388 1
          aux (l, decrement + 1, result)
d390 1
a390 1
          aux (l, 0, item :: result)
d392 11
a402 1
	  aux (l, decrement, ITEM (n - decrement, id', x, y, z) :: result)
d411 1
a411 1
      |   aux ((item as ITEM {2=id, ...}) :: l, result) =
d464 14
a477 1
	|  (ITEM (n, _, _, _, _) :: _) => n
d479 1
a479 1
      val (_, new_items) =
d481 2
a482 3
          (fn ((n, l), (id, s)) =>
	     (n+1, ITEM (n+1, id, new_delta, s, src) :: l))
	  ((current_index, []), result_strings)
d493 1
a493 1
	    (fn (h, ITEM (_, id, _, _, _)) =>
d503 1
a503 1
	|  (ITEM (n, _, _, _, _) :: _) => n
d529 1
a529 1
  fun history_entry_name (ITEM (_,id,context,_,src)) =
@


1.14
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d6 6
d232 5
d289 3
@


1.13
log
@Removing MLWorks.Integer
@
text
@d6 3
d182 1
a182 1
    fun string_index_list (str, [], l) = implode (str :: "-" :: l)
@


1.12
log
@Added history deletion functions, changed the type of update functions,
and added a preferences argument to process_result (and made it take a
record instead of a tuple).
@
text
@d6 5
d52 2
d181 1
a181 1
      string_index_list (str, t, [MLWorks.Integer.makestring x])
d183 1
a183 1
      string_index_list (str, t, MLWorks.Integer.makestring x :: "." :: l)
@


1.11
log
@Made process_result update the context before calling the update functions,
because the update_graph function in the browser reads the context rather
than using its arguments.
@
text
@d6 5
d61 1
d77 1
d100 2
a101 1
	 ((register_key, (history_entry list -> unit)) Map.map * int) ref,
d109 1
a109 1
  val initialContext = ref MLWorks.Option.NONE
d123 1
a123 1
	   save_file = ref MLWorks.Option.NONE}
d128 1
a128 1
	MLWorks.Option.NONE => initialContext := MLWorks.Option.SOME newcontext
d154 1
a154 1
	   save_file = ref MLWorks.Option.NONE}
d198 1
a198 1
    of MLWorks.Option.SOME c => c
d214 1
a214 1
    save_file := MLWorks.Option.SOME name
d227 2
a228 2
      of [] => MLWorks.Option.NONE
      |  (h::t) => MLWorks.Option.SOME h
d234 1
a234 1
      of [] => MLWorks.Option.NONE
d236 1
a236 1
        MLWorks.Option.SOME (Lists.nth (i-n, l))
d238 1
a238 1
          Lists.Nth => MLWorks.Option.NONE
d271 32
a302 1
  fun process_result (src, result, user_context, options, output_fn) =
d306 74
d404 28
a431 1
      val new_hist = new_items @@ hist
d435 1
a435 1
      Map.iterate (fn (_, f) => f new_items) fn_map
@


1.10
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d6 3
d147 1
d294 2
a295 2
      Map.iterate (fn (_, f) => f new_items) fn_map;
      info := (new_context, new_delta, new_hist)
@


1.9
log
@The update_functions now take the list of new items as an argument.
Removed the old selection stuff.  Removed some detritus..
@
text
@d6 4
d44 1
a44 1
require "../utils/newmap";
d53 1
a53 1
   structure Map: NEWMAP
d90 1
a90 1
	 ((register_key, (history_entry list -> unit)) Map.T * int) ref,
@


1.8
log
@Adding history_item_name function
@
text
@d6 3
a62 1
  type ('a, 'b) map = ('a, 'b) Map.T
a63 1
  type user_tool_options = UserOptions.user_tool_options
a78 8
  datatype source_map =
    MAP of (identifier, string) Map.T
  (* This is used for finding the source that corresponds to an entry in
     the current user context.  *)

  val empty_source_map =
    MAP (Map.empty' Ident.compare_identifiers)

d83 1
a83 1
      {info: (Context * Context * history_entry list * source_map) ref,
d85 2
a86 7
       update_register: ((register_key, (unit -> unit)) Map.T * int) ref,
       select_register:
	 ((register_key,
	  (history_entry -> unit)
	  * (unit -> UserOptions.user_tool_options)) Map.T
	 * int) ref,
       selected: history_entry MLWorks.Option.option ref,
d102 1
a102 1
	  {info = ref (context, context, [], empty_source_map),
a105 2
	   select_register = ref (Map.empty' op<, 0),
	   selected = ref MLWorks.Option.NONE,
d125 1
a125 1
	   {info = ref (context, _, _, _),
d133 1
a133 2
	  {info =
	     ref (context, Incremental.empty_context, [], empty_source_map),
a135 2
	   select_register = ref (Map.empty' op<, 0),
	   selected = ref MLWorks.Option.NONE,
a145 40
  fun set_selected
	(USER_CONTEXT {selected, select_register = ref (map, _), ...},
	 UserOptions.USER_TOOL_OPTIONS ({set_selection, ...}, _),
	 entry) =
    if !set_selection then
      let
        fun do_select (_, (f, mk_user_options)) =
          let
            val UserOptions.USER_TOOL_OPTIONS ({sense_selection, ...}, _) =
              mk_user_options ()
          in
	    if !sense_selection then
              f entry
            else
              ()
          end
      in
        selected := MLWorks.Option.SOME entry;
        Map.iterate do_select map
      end
    else
      ();

  fun get_selected
	(USER_CONTEXT {selected,  ...},
	 UserOptions.USER_TOOL_OPTIONS ({sense_selection, ...}, _)) =
    if !sense_selection then
      !selected
    else
      MLWorks.Option.NONE

  fun add_select_fn
	(USER_CONTEXT {select_register as ref (map, count), ...}, select_fn) =
    (select_register := (Map.define (map, count, select_fn), count + 1);
     count)

  fun remove_select_fn
	(USER_CONTEXT {select_register as ref (map, count), ...}, key) =
    select_register := (Map.undefine (map, key), count)

d204 1
a204 2
    (info := newinfo;
     Map.iterate (fn (_, f) => f()) map)
d225 20
d249 4
d255 1
a255 2
  fun process_result
        (src, result, user_context, options, user_options, output_fn) =
d257 4
a260 2
      val (c, delta, hist, MAP smap) =
        get_context_info user_context
d277 1
a277 1
      val (_, new_hist) =
d281 1
a281 1
	  ((current_index, hist), result_strings)
d283 1
a283 4
      val new_smap =
        Lists.reducel
          (fn (map, (id, _)) => Map.define (map, id, src))
          (smap, result_strings)
d286 2
a287 6
      case result_strings
      of [] => ()
      |  _  => set_selected (user_context, user_options, Lists.hd new_hist);
      set_context_info
        (user_context,
         (new_context, new_delta, new_hist, MAP new_smap))
d292 1
a292 2
      {info = ref (Incremental.empty_context, Incremental.empty_context,
                   [], empty_source_map),
a296 2
       select_register = ref (Map.empty' op<, 0),
       selected = ref MLWorks.Option.NONE,
@


1.7
log
@Moving identifier type to Ident
@
text
@d6 3
d55 1
d58 1
d344 4
a347 1

@


1.6
log
@process_result was assuming a non-empty list of results.
@
text
@d6 3
d53 1
d63 1
a63 1
  type identifier = Incremental.InterMake.Compiler.identifier
d79 1
a79 1
    MAP (Map.empty' Incremental.InterMake.Compiler.compare_identifiers)
@


1.5
log
@Added get_latest and get_n, to support history operations.
@
text
@d6 3
d259 3
a261 3
      MLWorks.Option.SOME (Lists.hd (get_hist c))
      handle
        Lists.Hd => MLWorks.Option.NONE
d297 1
a297 1
	case hist
d303 3
a305 2
        (fn ((n, l), (id, s)) => (n+1, ITEM (n+1, id, new_delta, s, src) :: l))
	((current_index, hist), result_strings)
d313 3
d318 1
a318 2
         (new_context, new_delta, new_hist, MAP new_smap));
      set_selected (user_context, user_options, Lists.hd new_hist)
@


1.4
log
@Made process_result set the current selection if the set_selection
user option is set.
@
text
@d6 4
d251 19
@


1.3
log
@Separated user_options into tool-specific and context-specific parts.
@
text
@d6 3
d254 2
a255 1
  fun process_result (src, result, user_context, options, output_fn) =
d275 1
a275 1
      val new_hist =
a283 1

d288 2
a289 1
         (new_context, new_delta, #2 new_hist, MAP new_smap))
@


1.2
log
@Added getInitialContext.
@
text
@d6 3
d42 2
a43 1
  type user_options = UserOptions.user_options
d72 1
d76 2
a77 1
	  (history_entry -> unit) * (unit -> UserOptions.user_options)) Map.T
d91 1
a91 1
  fun makeInitialUserContext (context,name) =
d97 1
d103 3
a105 1
	   save_file = ref MLWorks.Option.NONE} exception AlreadyInitialised
d122 1
d130 1
d146 1
a146 1
	 UserOptions.USER_OPTIONS ({set_selection, ...}, _),
d152 1
a152 1
            val UserOptions.USER_OPTIONS ({sense_selection, ...}, _) =
d169 1
a169 1
	 UserOptions.USER_OPTIONS ({sense_selection, ...}, _)) =
d245 2
d293 2
@


1.1
log
@new unit
Separated user context code from shelltypes.sml.
@
text
@d5 5
a9 1
 * $Log$
d207 1
a207 1
  fun getNewInitialContext () =
d209 1
a209 9
    of MLWorks.Option.SOME user_context =>
      let
	val c = copyUserContext (user_context)
      in
	case c of
	  USER_CONTEXT {name as ref (CONTEXTNAME (_, l)), ...} =>
	    name := CONTEXTNAME ("MLWorks", l);
        c
      end
d211 10
@
