head	1.48;
access;
symbols
	MLWorks_20b0_1998_03_20:1.48
	MLWorks_20m2_1998_02_16:1.47
	MLWorks_20m1_1997_10_23:1.45
	MLWorks_11r1:1.39.1.1.1.1.1
	MLWorks_workspace_97:1.43.2
	MLWorks_dt_wizard:1.43.1
	MLWorks_11c0_1997_09_09:1.39.1.1.1.1
	MLWorks_10r3:1.39.1.1.3
	MLWorks_10r2_551:1.39.1.1.2
	MLWorks_11:1.39.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.39.1.1
	MLWorks_20m0_1997_06_20:1.42
	MLWorks_1_0_r2c2_1997_06_14:1.39.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.39.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.39.1
	MLWorks_BugFix_1997_04_24:1.39
	MLWorks_1_0_r2_Win32_1997_04_11:1.39
	MLWorks_1_0_r2_Unix_1997_04_04:1.39
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.37.4.1.1
	MLWorks_gui_1996_12_18:1.37.5
	MLWorks_1_0_Win32_1996_12_17:1.37.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.37.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.37.1.1
	JFHmswindows:1.37.3
	MLWorks_1_0_Irix_1996_11_28:1.37.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.37.2
	MLWorks_1_0_Unix_1996_11_14:1.37.1
	MLWorks_Open_Beta2_1996_10_11:1.35.2
	MLWorks_License_dev:1.35.1
	MLWorks_1_open_beta_1996_09_13:1.32.1
	MLWorks_Open_Beta_1996_08_22:1.32
	MLWorks_Beta_1996_07_02:1.31
	MLWorks_Beta_1996_06_07:1.29
	MLWorks_Beta_1996_06_06:1.29
	MLWorks_Beta_1996_06_05:1.29
	MLWorks_Beta_1996_06_03:1.29
	MLWorks_Beta_1996_05_31:1.29
	MLWorks_Beta_1996_05_30:1.29;
locks; strict;
comment	@ * @;


1.48
date	98.02.19.16.18.06;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	98.01.27.15.26.00;	author johnh;	state Exp;
branches;
next	1.46;

1.46
date	97.10.16.14.33.14;	author johnh;	state Exp;
branches;
next	1.45;

1.45
date	97.10.16.13.00.38;	author johnh;	state Exp;
branches;
next	1.44;

1.44
date	97.10.10.10.54.51;	author johnh;	state Exp;
branches;
next	1.43;

1.43
date	97.09.05.14.31.03;	author johnh;	state Exp;
branches
	1.43.1.1
	1.43.2.1;
next	1.42;

1.42
date	97.05.19.14.11.57;	author johnh;	state Exp;
branches;
next	1.41;

1.41
date	97.05.16.15.34.46;	author johnh;	state Exp;
branches;
next	1.40;

1.40
date	97.05.06.10.27.34;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	97.03.25.17.26.58;	author johnh;	state Exp;
branches
	1.39.1.1;
next	1.38;

1.38
date	97.03.17.14.22.30;	author johnh;	state Exp;
branches;
next	1.37;

1.37
date	96.11.06.11.18.13;	author matthew;	state Exp;
branches
	1.37.1.1
	1.37.2.1
	1.37.3.1
	1.37.4.1
	1.37.5.1;
next	1.36;

1.36
date	96.10.25.15.45.59;	author johnh;	state Exp;
branches;
next	1.35;

1.35
date	96.09.30.13.43.05;	author johnh;	state Exp;
branches
	1.35.1.1
	1.35.2.1;
next	1.34;

1.34
date	96.09.26.09.23.53;	author johnh;	state Exp;
branches;
next	1.33;

1.33
date	96.09.25.15.29.21;	author johnh;	state Exp;
branches;
next	1.32;

1.32
date	96.07.26.14.59.10;	author daveb;	state Exp;
branches
	1.32.1.1;
next	1.31;

1.31
date	96.06.18.13.23.08;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	96.06.13.11.24.53;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	96.05.28.16.09.21;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	96.05.23.09.04.46;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	96.05.13.16.33.12;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	96.05.01.12.15.33;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	96.04.30.13.24.54;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	96.04.18.15.22.11;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	96.04.10.10.48.24;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	96.03.20.14.26.09;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	96.03.07.14.16.05;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	96.03.01.11.25.34;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	96.02.27.16.09.26;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	96.02.02.15.03.47;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	96.01.25.12.27.09;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	96.01.12.16.35.41;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	96.01.12.10.00.34;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	96.01.04.16.16.47;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	95.12.20.15.14.02;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	95.12.15.14.31.48;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.12.14.14.22.37;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	95.12.06.17.16.30;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	95.11.21.11.11.19;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.11.14.13.57.53;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.09.19.14.02.27;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.09.05.10.50.15;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.08.31.10.12.16;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.25.10.18.35;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.15.11.23.45;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.08.11.08.36.44;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.08.03.12.53.13;	author matthew;	state Exp;
branches;
next	;

1.32.1.1
date	96.09.13.11.20.06;	author hope;	state Exp;
branches;
next	;

1.35.1.1
date	96.10.07.16.10.01;	author hope;	state Exp;
branches;
next	;

1.35.2.1
date	96.10.17.11.28.23;	author hope;	state Exp;
branches;
next	;

1.37.1.1
date	96.11.14.12.54.03;	author hope;	state Exp;
branches
	1.37.1.1.1.1;
next	;

1.37.1.1.1.1
date	96.11.28.15.04.59;	author hope;	state Exp;
branches;
next	;

1.37.2.1
date	96.11.22.18.12.53;	author hope;	state Exp;
branches;
next	;

1.37.3.1
date	96.12.17.09.57.40;	author hope;	state Exp;
branches;
next	;

1.37.4.1
date	96.12.17.17.51.21;	author hope;	state Exp;
branches
	1.37.4.1.1.1;
next	;

1.37.4.1.1.1
date	97.02.24.11.41.52;	author hope;	state Exp;
branches;
next	;

1.37.5.1
date	96.12.18.09.45.37;	author hope;	state Exp;
branches;
next	1.37.5.2;

1.37.5.2
date	96.12.18.14.08.28;	author johnh;	state Exp;
branches;
next	;

1.39.1.1
date	97.05.12.10.38.07;	author hope;	state Exp;
branches
	1.39.1.1.1.1
	1.39.1.1.2.1
	1.39.1.1.3.1;
next	;

1.39.1.1.1.1
date	97.07.28.18.23.18;	author daveb;	state Exp;
branches
	1.39.1.1.1.1.1.1;
next	;

1.39.1.1.1.1.1.1
date	97.10.07.11.49.01;	author jkbrook;	state Exp;
branches;
next	;

1.39.1.1.2.1
date	97.09.08.17.16.40;	author daveb;	state Exp;
branches;
next	;

1.39.1.1.3.1
date	97.09.09.14.12.45;	author daveb;	state Exp;
branches;
next	;

1.43.1.1
date	97.09.10.19.28.44;	author brucem;	state Exp;
branches;
next	;

1.43.2.1
date	97.09.11.20.58.40;	author daveb;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	97.09.12.14.48.42;	author johnh;	state Exp;
branches;
next	1.43.2.3;

1.43.2.3
date	97.11.20.16.11.10;	author johnh;	state Exp;
branches;
next	;


desc
@new unit
MS Windows GUI
@


1.48
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@(*
 * $Log: _windows.sml,v $
 * Revision 1.47  1998/01/27  15:26:00  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.46  1997/10/16  14:33:14  johnh
 * [Bug #30059]
 * Implement combo boxes for create dialog.
 *
 * Revision 1.44  1997/10/10  10:54:51  johnh
 * [Bug #30204]
 * Update binding of runtime exception.
 *
 * Revision 1.43.2.3  1997/11/20  16:11:10  johnh
 * [Bug #30071]
 * Generalise openFileDialog to take a description and a mask.
 *
 * Revision 1.43.2.2  1997/09/12  14:48:42  johnh
 * [Bug #30071]
 * Redesign Compilation Manager -> Project Workspace.
 *
 * Revision 1.43  1997/09/05  14:31:03  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
 * Revision 1.42  1997/05/19  14:11:57  johnh
 * Implementing toolbar.
 *
 * Revision 1.41  1997/05/16  15:34:46  johnh
 * Implementing single menu bar on Windows.
 *
 * Revision 1.40  1997/05/06  10:27:34  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.39  1997/03/25  17:26:58  johnh
 * [Bug #1992]
 * Added WM_CONTEXTMENU message value.
 *
 * Revision 1.38  1997/03/17  14:22:30  johnh
 * [Bug #1954]
 * Added WM_SIZING value (used by Capi.set_min_window_size).
 *
 * Revision 1.37  1996/11/06  11:18:13  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.36  1996/10/25  15:45:59  johnh
 * [Bug #1687]
 * Removed redundant isAltOn function.
 *
 * Revision 1.35  1996/09/30  13:43:05  johnh
 * Added scrolling functionality.
 *
 * Revision 1.33  1996/09/25  15:29:21  johnh
 * [Bug #1613]
 * [Bug #1613]
 * Added get_scroll_info and set_pixel and also added a check to ensure that.
 * the WindowSystemError is not redefined on compiling Windows.sml in Gui.
 *
 * Revision 1.32  1996/07/26  14:59:10  daveb
 * [Bug #1478]
 * Added WM_USER[0-5] messages.
 *
 * Revision 1.31  1996/06/18  13:23:08  daveb
 * Moved exception WindowSystemError here from _capi.
 * Added DEFAULT_GUI_FONT to stock_object datatype.
 * Added WM_INITDIALOG to message datatype.
 *
 * Revision 1.30  1996/06/13  11:24:53  daveb
 * Added WM_SYSCOMMAND, sc_value and convertScValue, and SW_RESTORE etc.
 *
 * Revision 1.29  1996/05/28  16:09:21  jont
 * add saveImageDialog
 *
 * Revision 1.28  1996/05/23  09:04:46  matthew
 * Changed type of word shift operations
 *
 * Revision 1.27  1996/05/13  16:33:12  matthew
 * Changes to basis
 *
 * Revision 1.26  1996/05/01  12:15:33  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.25  1996/04/30  13:24:54  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.24  1996/04/18  15:22:11  jont
 * initbasis moves to basis
 *
 * Revision 1.23  1996/04/10  10:48:24  matthew
 * New language definition
 *
 * Revision 1.22  1996/03/20  14:26:09  matthew
 * Changes for new language definition
 *
 * Revision 1.21  1996/03/07  14:16:05  matthew
 * Extending
 *
 * Revision 1.20  1996/03/01  11:25:34  matthew
 * Extending library functions
 *
 * Revision 1.19  1996/02/27  16:09:26  matthew
 * More rationalization
 *
 * Revision 1.18  1996/02/02  15:03:47  matthew
 * Extending library functions
 *
 * Revision 1.17  1996/01/25  12:27:09  matthew
 * Adding get_bg_color etc.
 *
 * Revision 1.16  1996/01/12  16:35:41  matthew
 * Adding WM_SETREDRAW message
 *
 * Revision 1.15  1996/01/12  10:00:34  daveb
 * Added open_file_dialog, open_dir_dialog and save_as_dialog.
 *
 * Revision 1.14  1996/01/04  16:16:47  matthew
 * Adding get_stock_object
 *
 * Revision 1.13  1995/12/20  15:14:02  matthew
 * Adding color functions
 *
 * Revision 1.12  1995/12/15  14:31:48  matthew
 * Adding new window styles.
 *
 * Revision 1.11  1995/12/14  14:22:37  matthew
 * Changing message handling
 *
 * Revision 1.10  1995/12/06  17:16:30  matthew
 * Adding clipboard functionality
 *
 * Revision 1.9  1995/11/21  11:11:19  matthew
 * More stuff
 *
 * Revision 1.8  1995/11/14  13:57:53  matthew
 * Extending for graphics
 *
 * Revision 1.7  1995/09/19  14:02:27  matthew
 * Changes for new word signature
 *
 * Revision 1.6  1995/09/05  10:50:15  matthew
 * Adding word_to_signed_int
 *
 * Revision 1.5  1995/08/31  10:12:16  matthew
 * Adding extra menu functions
 *
 * Revision 1.4  1995/08/25  10:18:35  matthew
 * More stuff
 *
 * Revision 1.3  1995/08/15  11:23:45  matthew
 * Extending
 *
 * Revision 1.2  1995/08/11  08:36:44  matthew
 * Making it all work
 *
 * Revision 1.1  1995/08/03  12:53:13  matthew
 * new unit
 * MS Windows GUI
 *
 *)

require "../basis/__int";

require "^.utils.__terminal";
require "windows";
require "../basis/__word32";

functor Windows () : WINDOWS =
  struct
    structure Word = Word32

    exception WindowSystemError of string


    val print = Terminal.output

    fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
    exception Unimplemented of string
    fun unimpl s = fn _ => (print (s ^ " unimplemented\n"); raise Unimplemented s)

    local 
      val windows_exns_initialised = env "nt windows exns initialised"
      val WindowSystemErrorExn = env "exception win"
    in
      val _ = 
	if !windows_exns_initialised then 
	    MLWorks.Internal.Value.update_exn (WindowSystemError "", WindowSystemErrorExn)
	  else
	    (windows_exns_initialised := true;
	     WindowSystemErrorExn := WindowSystemError "")
    end

    val N = Int.toString

    type word = Word.word
    val intToWord = Word.fromInt
    val wordToInt = Word.toInt

    val nullWord = intToWord 0

    (* There should be a better way of doing this *)
    fun wordToSignedInt w =
      wordToInt w
      handle _ => ~(wordToInt (Word.- (nullWord,w)))

    fun W w = N (wordToInt w) (* no Word.makestring! *)

    datatype hwnd = HWND of word
    fun windowToWord (HWND w) = w
    fun wordToWindow w = HWND w

    datatype hmenu = HMENU of word
    fun menuToWord (HMENU w) = w
    fun wordToMenu w = HMENU w

    datatype accelerator_table = ACCELERATOR_TABLE of word
    datatype wparam = WPARAM of word
    datatype lparam = LPARAM of word
    datatype hdc = HDC of word
    datatype timer = TIMER of word
    datatype color = COLOR of word
    datatype cursor = CURSOR of word

    val nullWindow = HWND nullWord
    val null_menu = HMENU nullWord

    fun isNullWindow (hwnd) = hwnd = nullWindow

    datatype rect = RECT of {left:int,top:int,right:int,bottom:int}
    datatype point = POINT of {x:int,y:int}

    (* It would be nice to auto generate this lot *)
    datatype message =
      BM_GETCHECK |
      BM_GETSTATE |
      BM_SETCHECK |
      BM_SETSTATE |
      BM_SETSTYLE |
      
      BN_CLICKED |
      BN_DISABLE |
      BN_DOUBLECLICKED |
      BN_HILITE |
      BN_PAINT |
      BN_UNHILITE |
      
      CBN_CLOSEUP |
      CBN_DBLCLK |
      CBN_DROPDOWN |
      CBN_EDITCHANGE |
      CBN_EDITUPDATE |
      CBN_ERRSPACE |
      CBN_KILLFOCUS |
      CBN_SELCHANGE |
      CBN_SELENDCANCEL |
      CBN_SELENDOK |
      CBN_SETFOCUS |

      CB_ADDSTRING |
      CB_DELETESTRING |
      CB_DIR |
      CB_FINDSTRING |
      CB_FINDSTRINGEXACT |
      CB_GETCOUNT |
      CB_GETCURSEL |
      CB_GETDROPPEDCONTROLRECT |
      CB_GETDROPPEDSTATE |
      CB_GETDROPPEDWIDTH |
      CB_GETEDITSEL |
      CB_GETEXTENDEDUI |
      CB_GETHORIZONTALEXTENT |
      CB_GETITEMDATA |
      CB_GETITEMHEIGHT |
      CB_GETLBTEXT |
      CB_GETLBTEXTLEN |
      CB_GETLOCALE |
      CB_GETTOPINDEX |
      CB_INITSTORAGE |
      CB_INSERTSTRING |
      CB_LIMITTEXT |
      CB_RESETCONTENT |
      CB_SELECTSTRING |
      CB_SETCURSEL |
      CB_SETDROPPEDWIDTH |
      CB_SETEDITSEL |
      CB_SETEXTENDEDUI |
      CB_SETHORIZONTALEXTENT |
      CB_SETITEMDATA |
      CB_SETITEMHEIGHT |
      CB_SETLOCALE |
      CB_SETTOPINDEX |
      CB_SHOWDROPDOWN |

      DM_GETDEFID |
      DM_SETDEFID |
      
      EM_CANUNDO |
      EM_EMPTYUNDOBUFFER |
      EM_FMTLINES |
      EM_GETFIRSTVISIBLELINE |
      EM_GETHANDLE |
      EM_GETLINE |
      EM_GETLINECOUNT |
      EM_GETMODIFY |
      EM_GETPASSWORDCHAR |
      EM_GETRECT |
      EM_GETSEL |
      EM_GETWORDBREAKPROC |
      EM_LIMITTEXT |
      EM_LINEFROMCHAR |
      EM_LINEINDEX |
      EM_LINELENGTH |
      EM_LINESCROLL |
      EM_REPLACESEL |
      EM_SCROLL |
      EM_SCROLLCARET |
      EM_SETHANDLE |
      EM_SETMODIFY |
      EM_SETPASSWORDCHAR |
      EM_SETREADONLY |
      EM_SETRECT |
      EM_SETRECTNP |
      EM_SETSEL |
      EM_SETTABSTOPS |
      EM_SETWORDBREAKPROC |
      EM_UNDO |
      EN_CHANGE |
      EN_ERRSPACE |
      EN_HSCROLL |
      EN_KILLFOCUS |
      EN_MAXTEXT |
      EN_SETFOCUS |
      EN_UPDATE |
      EN_VSCROLL |

      FINDMSGSTRING |

      LBN_DBLCLK |
      LBN_ERRSPACE |
      LBN_KILLFOCUS |
      LBN_SELCANCEL |
      LBN_SELCHANGE |
      LBN_SETFOCUS |
      
      LB_ADDFILE |
      LB_ADDSTRING |
      LB_DELETESTRING |
      LB_DIR |
      LB_FINDSTRING |
      LB_FINDSTRINGEXACT |
      LB_GETANCHORINDEX |
      LB_GETCARETINDEX |
      LB_GETCOUNT |
      LB_GETCURSEL |
      LB_GETHORIZONTALEXTENT |
      LB_GETITEMDATA |
      LB_GETITEMHEIGHT |
      LB_GETITEMRECT |
      LB_GETLOCALE |
      LB_GETSEL |
      LB_GETSELCOUNT |
      LB_GETSELITEMS |
      LB_GETTEXT |
      LB_GETTEXTLEN |
      LB_GETTOPINDEX |
      LB_INSERTSTRING |
      LB_RESETCONTENT |
      LB_SELECTSTRING |
      LB_SELITEMRANGE |
      LB_SELITEMRANGEEX |
      LB_SETANCHORINDEX |
      LB_SETCARETINDEX |
      LB_SETCOLUMNWIDTH |
      LB_SETCOUNT |
      LB_SETCURSEL |
      LB_SETHORIZONTALEXTENT |
      LB_SETITEMDATA |
      LB_SETITEMHEIGHT |
      LB_SETLOCALE |
      LB_SETSEL |
      LB_SETTABSTOPS |
      LB_SETTOPINDEX |
      
      TB_GETSTATE |
      TB_SETSTATE |

      WM_ACTIVATE |
      WM_ACTIVATEAPP |
      WM_CANCELMODE |
      WM_CHAR |
      WM_CHARTOITEM |
      WM_CHILDACTIVATE |
      WM_CLOSE |
      WM_COMMAND |
      WM_CONTEXTMENU |
      WM_COPY |
      WM_COPYDATA |
      WM_CREATE |
      WM_CTLCOLORBTN |
      WM_CTLCOLOREDIT |
      WM_CUT |
      WM_DEADCHAR |
      WM_DESTROY |
      WM_ENABLE |
      WM_ENDSESSION |
      WM_ERASEBKGND |
      WM_GETFONT |
      WM_GETMINMAXINFO |
      WM_GETTEXT |
      WM_GETTEXTLENGTH |
      WM_HOTKEY |
      WM_HSCROLL |
      WM_INITDIALOG |
      WM_INITMENU |
      WM_KEYDOWN |
      WM_KEYUP |
      WM_KILLFOCUS |
      WM_LBUTTONDBLCLK |
      WM_LBUTTONDOWN |
      WM_LBUTTONUP |
      WM_MBUTTONDBLCLK |
      WM_MBUTTONDOWN |
      WM_MBUTTONUP |
      WM_MOUSEACTIVATE |
      WM_MOUSEMOVE |
      WM_MOVE |
      WM_NCACTIVATE |
      WM_NCCALCSIZE |
      WM_NCCREATE |
      WM_NCDESTROY |
      WM_NCHITTEST |
      WM_NCLBUTTONDBLCLK |
      WM_NCLBUTTONDOWN |
      WM_NCLBUTTONUP |
      WM_NCMBUTTONDBLCLK |
      WM_NCMBUTTONDOWN |
      WM_NCMBUTTONUP |
      WM_NCMOUSEMOVE |
      WM_NCRBUTTONDBLCLK |
      WM_NCRBUTTONDOWN |
      WM_NCRBUTTONUP |
      WM_NOTIFY |
      (* WM_OPENICON | *)
      WM_PAINT |
      WM_PARENTNOTIFY |
      WM_PASTE |
      WM_POWER |
      WM_QUERYENDSESSION |
      WM_QUERYOPEN |
      WM_QUEUESYNC |
      WM_QUIT |
      WM_RBUTTONDBLCLK |
      WM_RBUTTONDOWN |
      WM_RBUTTONUP |
      WM_SETCURSOR | 
      WM_SETFOCUS |
      WM_SETFONT |
      WM_SETREDRAW |
      WM_SETTEXT |
      WM_SHOWWINDOW |
      WM_SIZE |
      WM_SIZING |
      WM_SYSCHAR |
      WM_SYSCOMMAND |
      WM_SYSDEADCHAR |
      WM_SYSKEYDOWN |
      WM_SYSKEYUP |
      WM_UNDO |		
      WM_USER0 |
      WM_USER1 |
      WM_USER2 |
      WM_USER3 |
      WM_USER4 |
      WM_USER5 |
      WM_VSCROLL |
      WM_WINDOWPOSCHANGED |
      WM_WINDOWPOSCHANGING 
      (* WN_DELETEITEM | *)
      (* WN_VKEYTOITEM *)



    datatype window_style =
      BS_3STATE |
      BS_AUTO3STATE |
      BS_AUTOCHECKBOX |
      BS_AUTORADIOBUTTON |
      BS_CHECKBOX |
      BS_DEFPUSHBUTTON |
      BS_GROUPBOX |
      BS_LEFTTEXT |
      BS_OWNERDRAW |
      BS_PUSHBUTTON |
      BS_RADIOBUTTON |
      BS_USERBUTTON |

      CBS_AUTOHSCROLL |
      CBS_DISABLENOSCROLL |
      CBS_DROPDOWN |
      CBS_DROPDOWNLIST |
      CBS_HASSTRINGS |
      CBS_NOINTEGRALHEIGHT |
      CBS_OEMCONVERT |
      CBS_OWNERDRAWFIXED |
      CBS_OWNERDRAWVARIABLE |
      CBS_SIMPLE |
      CBS_SORT |

      DS_ABSALIGN |
      DS_LOCALEDIT |
      DS_MODALFRAME |
      DS_NOIDLEMSG |
      DS_SETFONT |
      DS_SETFOREGROUND |
      DS_SYSMODAL |

      ES_AUTOHSCROLL |
      ES_AUTOVSCROLL |
      ES_CENTER |
      ES_LEFT |
      ES_LOWERCASE |
      ES_MULTILINE |
      ES_NOHIDESEL |
      ES_OEMCONVERT |
      ES_PASSWORD |
      ES_READONLY |
      ES_RIGHT |
      ES_UPPERCASE |
      ES_WANTRETURN |

      LBS_DISABLENOSCROLL |
      LBS_EXTENDEDSEL |
      LBS_HASSTRINGS |
      LBS_MULTICOLUMN |
      LBS_MULTIPLESEL |
      LBS_NODATA |
      LBS_NOINTEGRALHEIGHT |
      LBS_NOREDRAW |
      LBS_NOTIFY |
      LBS_OWNERDRAWFIXED |
      LBS_OWNERDRAWVARIABLE |
      LBS_SORT |
      LBS_STANDARD |
      LBS_USETABSTOPS |
      LBS_WANTKEYBOARDINPUT |

      SBS_BOTTOMALIGN |
      SBS_HORZ |
      SBS_LEFTALIGN |
      SBS_RIGHTALIGN |
      SBS_SIZEBOX |
      SBS_SIZEBOXBOTTOMRIGHTALIGN |
      SBS_SIZEBOXTOPLEFTALIGN |
      SBS_TOPALIGN |
      SBS_VERT |

      SS_BLACKFRAME |
      SS_BLACKRECT |
      SS_CENTER |
      SS_GRAYFRAME |
      SS_GRAYRECT |
      SS_ICON |
      SS_LEFT |
      SS_LEFTNOWORDWRAP |
      SS_NOPREFIX |
      SS_RIGHT |
      SS_SIMPLE |
      SS_WHITEFRAME |
      SS_WHITERECT |

      TBSTYLE_ALTDRAG  |
      TBSTYLE_TOOLTIPS |
      TBSTYLE_WRAPABLE |

      WS_BORDER |
      WS_CAPTION |
      WS_CHILD |
      WS_CLIPCHILDREN |
      WS_CLIPSIBLINGS |
      WS_DISABLED |
      WS_DLGFRAME |
      WS_GROUP |
      WS_HSCROLL |
      WS_ICONIC |
      WS_MAXIMIZE |
      WS_MAXIMIZEBOX |
      WS_MINIMIZE |
      WS_MINIMIZEBOX |
      WS_OVERLAPPED |
      WS_OVERLAPPED_WINDOW |
      WS_POPUP |
      WS_POPUPWINDOW |
      WS_SYSMENU |
      WS_TABSTOP |
      WS_THICKFRAME |
      WS_TILEDWINDOW |
      WS_VISIBLE |
      WS_VSCROLL

    type message_handler = (wparam * lparam -> word option)

    (* This is the type of object stored in the handler map *)
    type handler_map_entry = 
      (hwnd * (* The window *)
       (word * (* The C function to call if not handled by ML *)
        (word * message_handler list ref) list ref)) (* An updatable list of message handlers *)

    val getHandlerMap : unit -> handler_map_entry list = env "nt get handler map"
    val setHandlerMap : handler_map_entry list -> unit = env "nt set handler map"

    fun addNewWindow (window,cproc) =
      let
        val hmap = getHandlerMap ()
      in
        setHandlerMap ((window,(cproc,ref nil)) :: hmap)
      end

    val mainLoop : unit -> unit = env "nt main loop"
    val doInput : unit -> bool = env "nt do input"

    val mainInit : unit -> hwnd = 
      env "nt main init"

    datatype sw_arg =
      SW_HIDE |
      SW_MAXIMIZE |
      SW_MINIMIZE |
      SW_RESTORE |
      SW_SHOW |
      SW_SHOWDEFAULT |
      SW_SHOWMAXIMIZED |
      SW_SHOWMINIMIZED | 
      SW_SHOWMINNOACTIVE |
      SW_SHOWNA |
      SW_SHOWNOACTIVE |
      SW_SHOWNORMAL

    datatype gw_arg =
      GW_CHILD |
      GW_HWNDFIRST |
      GW_HWNDLAST |
      GW_HWNDNEXT |
      GW_HWNDPREV |
      GW_OWNER

    datatype wa_value = 
      WA_ACTIVE |
      WA_CLICKACTIVE |
      WA_INACTIVE

    val convertWaValue : wa_value -> int = env "win32 ml convert wa value"

    (* Ch. 1 Windows *)
    val anyPopup : unit -> bool = env "nt any popup"
    val bringWindowToTop : hwnd -> unit = env "nt bring window to top"
    val childWindowFromPoint : hwnd * (int * int) -> hwnd = env"nt child window from point"
    val closeWindow : hwnd -> unit = env "nt close window"
    val createWindow : 
      {class: string,
       name: string,
       styles : window_style list,
       width : int,
       height : int,
       parent: hwnd,
       menu : word} -> 
      hwnd = env "nt create window"
    val destroyWindow : hwnd -> unit = env "nt destroy window"
    val enumChildWindows : hwnd * (hwnd -> unit) -> unit = env "nt enum child windows"
    val enumWindows : (hwnd -> unit) -> unit = env "nt enum windows"
    val findWindow : string * string -> hwnd = env "nt find window"
    val getClientRect : hwnd -> rect = env "nt get client rect";
    val getDesktopWindow : unit-> hwnd = env "nt get desktop window"
    val getForegroundWindow : unit-> hwnd = env "nt get foreground window"
    val getLastActivePopup : hwnd -> hwnd = env "nt get last active popup"
    val getNextWindow : hwnd * gw_arg -> hwnd = env "nt get next window"
    val getParent : hwnd -> hwnd = env "nt get parent"
    val getTopWindow : hwnd -> hwnd = env "nt get top window"
    val getWindow : hwnd * gw_arg -> hwnd = env "nt get window"
    val getWindowRect : hwnd -> rect = env "nt get window rect"
    val getWindowPlacement : hwnd -> int * point * point * rect = 
        env "win32 get window placement"
    val isChild : hwnd * hwnd -> bool = env "nt is child"
    val isIconic : hwnd -> bool = env "nt is iconic"
    val isWindow : hwnd -> bool = env "nt is window"
    val isWindowUnicode : hwnd -> bool = env "nt is window unicode"
    val isWindowVisible : hwnd -> bool = env "nt is window visible"
    val isZoomed : hwnd -> bool = env "nt is zoomed"
    val moveWindow : hwnd * int * int * int * int * bool -> unit = env "nt move window"
    val setForegroundWindow : hwnd -> unit = env "nt set foreground window"
    val setParent : hwnd * hwnd -> hwnd = env "nt set parent"
    val setWindowText : hwnd * string -> unit = env "nt set window text"
    val setWindowPos : hwnd * {x: int, y: int, height: int, width: int} -> unit = 
	env "win32 set window pos"
    val showOwnedPopups : hwnd * bool -> unit = env "nt show owned popups"
    val showWindow : hwnd * sw_arg -> unit = env "nt show window"
    val updateWindow : hwnd -> unit = env "nt update window"
    val windowFromPoint : int * int -> hwnd = env "nt window from point"

    val getMinMaxInfo : word -> point * point * point * point = 
        env "win32 get minmax info"
    val setMinMaxInfo : word * point * point * point * point -> word = 
        env "win32 set minmax info"

    (* Ch 2 Messages *)

    val getInputState : unit -> bool = env "nt get input state"
    val getMessagePos : unit -> int * int = env "nt get message pos"
    val getMessageTime : unit -> int = env "nt get message time"
    val inSendMessage : unit -> bool = env "nt in send message"
    val postMessage : hwnd * message * wparam * lparam -> unit = env "nt post message"
    val postQuitMessage : int -> unit = env "nt post quit message"
    val sendMessage : hwnd * message * wparam * lparam -> word = env "nt send message"
    val messageToWord : message -> word = env "nt convert message"

    (* Ch 3. Window Classes *)

    datatype gwl_value =
      DWL_DLGPROC |
      DWL_MSGRESULT |
      DWL_USER |
      GWL_EXSTYLE |
      GWL_HINSTANCE |
      GWL_HWNDPARENT | 
      GWL_ID | 
      GWL_USERDATA |
      GWL_WNDPROC

    val get_window_long_internal : hwnd * int -> word = env "nt get window long"
    val set_window_long_internal : hwnd * int * word -> word = env "nt set window long"
    val convertGwlValue : gwl_value -> int = env "nt convert gwl value"

    fun getWindowLong (hwnd,value) =
      get_window_long_internal (hwnd,convertGwlValue value)

    fun setWindowLong (hwnd,value,x) =
      set_window_long_internal (hwnd,convertGwlValue value,x)

    (* Ch 5. Keyboard Input *)
    val enableWindow : hwnd * bool -> bool = env "nt enable window"
    val getActiveWindow  : unit -> hwnd = env "nt get active window"
    val getFocus : unit -> hwnd = env "nt get focus"
    val isWindowEnabled : hwnd -> bool = env "nt is window enabled"
    val setActiveWindow  : hwnd -> hwnd = env "nt set active window"
    val setFocus : hwnd -> hwnd = env "nt set focus"

    (* Ch 6. Mouse input *)
    val getCapture : unit -> hwnd = env "nt get capture"
    val releaseCapture : unit -> unit = env "nt release capture"
    val setCapture : hwnd -> hwnd = env "nt set capture"

    (* Ch 7. Timers *)
    val killTimer : hwnd * timer -> unit = env "nt kill timer"
    val setTimer : hwnd * int * (unit -> unit) -> timer = env "nt set timer"
      
    (* Ch. 39 Coordinate Spaces & Transformations *)
    val clientToScreen : hwnd * point -> point = env "nt client to screen";
    val screenToClient : hwnd * point -> point = env "nt screen to client";

    (* ML window procedures *)

    fun getWindowEntry window =
      let
        val hmap = getHandlerMap ()
        fun lookup (window,[]) =
          (* Can't find it so ... *)
          let
            val entry = (nullWord,ref [])
          in
            setHandlerMap ((window,entry) :: hmap);
            entry
          end
          | lookup (window,(w,entry) :: rest) =
            if w = window then entry
            else lookup (window,rest)
      in
        lookup (window,hmap)
      end

    fun addMessageHandler (window,message,handler) =
      let
        val (cproc,handlerlistref) = getWindowEntry window
        val message_word = messageToWord message
        fun find_message (m,[]) = NONE
          | find_message (m,(m',r)::rest) =
            if m = m' then SOME r else find_message (m,rest)
      in 
        case find_message (message_word,!handlerlistref) of
          SOME r =>
            r := handler :: !r
          | _ => 
              handlerlistref := (message_word,ref [handler]) :: !handlerlistref
      end

    fun removeWindow (window) =
      let
        val hmap = getHandlerMap ()
        fun remove (w,[],acc) = rev acc
          | remove (w,(entry as (w',_)) :: rest,acc) =
            if w = w' then rev acc @@ rest
            else remove (w,rest,entry :: acc)
      in
        setHandlerMap (remove (window,hmap,[]))
      end

    (* Old stuff *)

    val getMlWindowProc : unit -> word = env "nt get ml window proc"

    (* Menus *)
    (* These should be representable by 16 bit values *)
    (* So we could probably use an int for them *)
    val id_count = ref 1000 (* Start at 1000 for no very good reason *)
    fun newControlId () =
      let
        val result = intToWord (!id_count)
      in
        id_count := !id_count+1;
        result
      end

    datatype menu_value = SUBMENU of hmenu | ITEM of word

    datatype menu_flag =
      MF_BITMAP |
      MF_CHECKED |
      MF_BYCOMMAND |
      MF_BYPOSITION |
      MF_DISABLED |
      MF_ENABLED |
      MF_GRAYED |
      MF_MENUBARBREAK |
      MF_MENUBREAK |
      MF_OWNERDRAW |
      MF_POPUP |
      MF_SEPARATOR |
      MF_STRING |
      MF_UNCHECKED

    val append_menu_ : hmenu * menu_flag list * word * string -> unit = env "nt append menu"

    val appendMenu : hmenu * menu_flag list * menu_value * string -> unit = 
      fn (menu,flags,value,string) =>
        case value of 
          SUBMENU (HMENU b) => append_menu_ (menu,flags,b,string)
        | ITEM b => append_menu_ (menu,flags,b,string)

    val checkMenuItem : hmenu * word * menu_flag list -> unit = env "nt check menu item"
    val createMenu : unit -> hmenu = env "nt create menu"
    val createPopupMenu : unit -> hmenu = env "nt create popup menu"
    val destroyMenu : hmenu -> unit = env "nt destroy menu"
    val deleteMenu : hmenu * word * menu_flag -> unit = env "nt remove menu"
    val drawMenuBar : hwnd -> unit = env "nt draw menu bar"
    val enableMenuItem : hmenu * word * menu_flag list -> unit = env "nt enable menu item"
    val getMenu : hwnd -> hmenu = env "nt get menu"
    val getMenuItemId : hmenu * int -> word = env "nt get menu item id"
    val getMenuItemCount : hmenu -> int = env "nt get menu item count"
    val getMenuState : hmenu * word * menu_flag -> menu_flag list = unimpl "nt get menu state"
    val getMenuString : hmenu * word * menu_flag -> string = unimpl "nt get menu string"
    val getSubmenu : hmenu * int -> hmenu = env "nt get submenu"
    val getSystemMenu : hwnd * bool -> hmenu = env "nt get system menu"
    val setMenu : hwnd * hmenu -> unit = env "nt set menu"
    val removeMenu : hmenu * word * menu_flag -> unit = env "nt remove menu"

    (* End libraries *)
    val addCommandHandlerInternal : hwnd * word * (hwnd * int-> unit) -> unit = 
      env "nt add menu command"

    fun addCommandHandler (window,w,handler) =
      addCommandHandlerInternal (window, w, handler)

    (* DIALOGS *)

    val registerPopupWindow : hwnd -> unit = env "nt register popup window"
    val unregisterPopupWindow : hwnd -> unit = env "nt unregister popup window"

    datatype message_box_style =
      MB_ABORTRETRYIGNORE |
      MB_APPLMODAL |
      MB_ICONASTERISK |
      MB_ICONEXCLAMATION |
      MB_ICONHAND |
      MB_ICONINFORMATION |
      MB_ICONQUESTION |
      MB_ICONSTOP |
      MB_OK |
      MB_OKCANCEL |
      MB_RETRYCANCEL |
      MB_YESNO |
      MB_YESNOCANCEL

    val messageBox : hwnd * string * string * message_box_style list -> int = env "nt message box"
    val messageBeep : message_box_style -> unit = env "nt message beep"
      
    val endDialog : hwnd * int -> unit = env "nt end dialog"
    val getDlgItem : hwnd * word -> hwnd = env "nt get dlg item"
    val getDlgCtrlID : hwnd -> int = env "win32 get dlg ctrl id"

    val getDialogBaseUnits : unit -> word = env "nt get dialog base units"

    val getFindFlags : word -> {searchStr: string,
             searchDown: bool,
             matchCase: bool,
             wholeWord: bool,
             findNext: bool,
	     closing: bool} = env "win32 get find flags"
    val findDialog : hwnd * string * bool option * bool option * bool option -> hwnd = 
	env "win32 find dialog"

    val openFileDialog : hwnd * string * string -> string = env "nt open file dialog"
    val openDirDialog : hwnd -> string = env "nt open dir dialog"
    val saveDialog : hwnd * string * string -> string = env "win32 save dialog"

    (* CURSORS *)

    datatype cursor_shape = 
      IDC_APPSTARTING |
      IDC_ARROW |
      IDC_CROSS |
      IDC_IBEAM |
      IDC_ICON |
      IDC_NO |
      IDC_SIZE |
      IDC_SIZEALL |
      IDC_SIZENESW |
      IDC_SIZENS |
      IDC_SIZEWE |
      IDC_UPARROW |
      IDC_WAIT

    val clipCursor : rect option -> unit = env "nt clip cursor"
    val getClipCursor : unit -> rect = env "nt get clip cursor"
    val getCursorPos : unit -> point = env "nt get cursor pos"
    val setCursorPos : int * int -> unit = env "nt set cursor pos"
    val showCursor : bool -> int = env "nt show cursor"
    val loadCursor : cursor_shape -> cursor = env "win32 load cursor"
    val setCursor : cursor -> cursor = env "win32 set cursor"

    (* CONTROLS *)
 (*   val createStatusWindow: word * string * hwnd * int -> hwnd = env "nt create status window" *)

    (* BUTTON CONTROLS *)
    val checkDlgButton: hwnd * word * int -> unit = env "nt check dlg button"
    val checkRadioButton: hwnd * word * word * word -> unit = env "nt check radio button"
    val isDlgButtonChecked: hwnd * word -> int = env "nt is dlg button checked"

    (* SCROLLBARS *)

    datatype sb_value =
      SB_BOTH |
      SB_BOTTOM |
      SB_CTL |
      SB_ENDSCROLL |
      SB_HORZ |
      SB_LINEDOWN |
      SB_LINELEFT |
      SB_LINERIGHT |
      SB_LINEUP |
      SB_PAGEDOWN |
      SB_PAGELEFT |
      SB_PAGERIGHT |
      SB_PAGEUP |
      SB_THUMBPOSITION |
      SB_THUMBTRACK |
      SB_TOP |
      SB_VERT

    val convertSbValue : sb_value -> int = env "nt ml convert sb value"

    datatype esb_value =
      ESB_DISABLE_BOTH
    | ESB_DISABLE_DOWN
    | ESB_DISABLE_LEFT
    | ESB_DISABLE_LTUP
    | ESB_DISABLE_RIGHT
    | ESB_DISABLE_RTDN
    | ESB_DISABLE_UP
    | ESB_ENABLE_BOTH

    val enableScrollBar : hwnd * sb_value * esb_value -> unit = env "nt enable scroll bar"
    val setScrollRange : hwnd * sb_value * int * int * bool -> unit = env "nt set scroll range"
    val getScrollRange : hwnd * sb_value -> int * int = env "nt get scroll range"
    val setScrollPos : hwnd * sb_value * int * bool -> unit = env "nt set scroll pos"
    val getScrollPos : hwnd * sb_value -> int = env "nt get scroll pos"
    val showScrollBar : hwnd * sb_value * bool -> unit = env "nt show scroll bar"
    val getScrollInfo : hwnd * sb_value -> int * word * word * int * int * word * int * int = env "nt get scroll info"  

    datatype sc_value =
      SC_CLOSE
    | SC_CONTEXTHELP
    | SC_DEFAULT
    | SC_HOTKEY
    | SC_HSCROLL
    | SC_KEYMENU
    | SC_MAXIMIZE
    | SC_MINIMIZE
    | SC_MOUSEMENU
    | SC_MOVE
    | SC_NEXTWINDOW
    | SC_PREVWINDOW
    | SC_RESTORE
    | SC_SCREENSAVE
    | SC_SIZE
    | SC_TASKLIST
    | SC_VSCROLL

    val convertScValue : sc_value -> int = env "nt ml convert sc value"

    (* GRAPHICS *)

    datatype object = OBJECT of word
    datatype hbrush = HBRUSH of word
    datatype hpen = HPEN of word

    datatype object_type = 
      OBJ_PEN | 
      OBJ_BRUSH |
      OBJ_PAL |
      OBJ_FONT |
      OBJ_BITMAP

    (* get_stock_object etc *)
    datatype stock_object =
      ANSI_FIXED_FONT |
      ANSI_VAR_FONT |
      BLACK_BRUSH |
      BLACK_PEN |
      DEFAULT_GUI_FONT |
      DEFAULT_PALETTE |
      DKGRAY_BRUSH |
      GRAY_BRUSH |
      HOLLOW_BRUSH |
      LTGRAY_BRUSH |
      NULL_BRUSH |
      NULL_PEN |
      OEM_FIXED_FONT |
      SYSTEM_FIXED_FONT |
      SYSTEM_FONT |
      WHITE_BRUSH |
      WHITE_PEN

    datatype rop_mode =
      BLACKNESS |
      DSTINVERT |
      MERGECOPY |
      MERGEPAINT |
      NOTSRCCOPY |
      NOTSRCERASE |
      PATCOPY |
      PATINVERT |
      PATPAINT |
      SRCAND |
      SRCCOPY |
      SRCERASE |
      SRCINVERT |
      SRCPAINT |
      WHITENESS
      
    val cancelDC : hdc -> unit (* only of use with native threads *) = env "nt cancel dc"
    val createCompatibleDC : hdc -> hdc = env "nt create compatible dc"
    val deleteObject : object -> unit = env "nt delete object"
    val getCurrentObject : hdc * object_type -> object = env "nt get current object"
    val getDC : hwnd -> hdc = env "nt get dc"
    val getDCOrgEx : hdc -> point = env "nt get dc org ex"
    val getStockObject : stock_object -> object = env "nt get stock object"
    val releaseDC : hwnd * hdc -> unit = env "nt release dc"
    val restoreDC : hdc * int -> unit = env "nt restore dc"
    val saveDC : hdc -> int = env "nt save dc"
    val selectObject : hdc * object -> object = env "nt select object"

    val bitBlt : hdc * int * int * int *int * hdc * int * int * rop_mode -> unit = unimpl "nt bit blt"

    datatype hatch_style =
      HS_BDIAGONAL
    | HS_CROSS
    | HS_DIAGCROSS
    | HS_FDIAGONAL
    | HS_HORIZONTAL
    | HS_VERTICAL
      
    val createHatchBrush : hatch_style * color -> hbrush = env "nt create hatch brush"
    val createSolidBrush : color -> hbrush = env "nt create solid brush"
(*
    val getBrushOrgEx : hdc -> point = env "nt get brush org ex"
    val setBrushOrg : hdc * point -> unit = env "nt set brush org"
*)

    datatype pen_style =
      PS_DASH |
      PS_DASHDOT |
      PS_DASHDOTDOT |
      PS_DOT |
      PS_NULL |
      PS_SOLID |
      PS_INSIDEFRAME

    (* Make a pen *)
    val createPen : pen_style * int * color -> hpen = env "nt create pen"

    (* Lines and curves *)
    datatype arc_direction = AD_CLOCKWISE| AD_COUNTERCLOCKWISE

    val angleArc : hdc * int * int * int * real * real -> unit = env "nt angle arc"
    val arc : hdc * int * int * int * int * int * int * int * int -> unit = env "nt arc"
    val arcTo : hdc * int * int * int * int * int * int * int * int -> unit = env "nt arc to"
    val getArcDirection : hdc -> arc_direction = env "nt get arc direction"
    val lineTo : hdc * int * int -> unit = env "nt line to"
    val moveTo : hdc * int * int * word -> unit = env "nt move to"
    val polyBezier : hdc * point list -> unit = unimpl "nt poly bezier"
    val polyBezierTo : hdc * point list -> unit = unimpl "nt poly bezier to"
    (* polyDraw needs some thought *)
    val polyline : hdc * point list -> unit = unimpl "nt polyline"
    val polylineTo : hdc * point list -> unit = unimpl "nt polyline to"
    val polyPolyline : hdc * point list list -> unit = unimpl "nt poly polyline"
    val setArcDirection : hdc * arc_direction -> unit = env "nt set arc direction"

    val chord : hdc * int * int * int * int * int * int * int * int -> unit = env "nt chord"
    val ellipse : hdc * int * int * int * int -> unit = env "nt ellipse"
    val fillRect : hdc * rect * hbrush -> unit = env "nt fill rect"
    val frameRect : hdc * rect * hbrush -> unit = env "nt frame rect"
    val invertRect : hdc * rect -> unit = env "nt invert rect"
    val pie : hdc * int * int * int * int * int * int * int * int -> unit = env "nt pie"
    val polygon : hdc * point list -> unit = unimpl "nt polygon"
    val polyPolygon : hdc * point list list -> unit = unimpl "nt poly polygon"
    val setPixel : hdc * int * int * color -> color = env "nt set pixel" 
    val rectangle : hdc * int * int * int * int -> unit = env "nt rectangle"
    val roundRect : hdc * int * int * int * int * int * int -> unit = env "nt round rect"
    val	textOut : hdc * int * int * string -> unit = env "nt text out"
    val getTextExtentPoint : hdc * string -> int * int = env "nt get text extent point"
    val validateRect : hwnd * rect option -> unit = env "nt validate rect"
    val invalidateRect : hwnd * rect option * bool -> unit = env "nt invalidate rect"
    val windowFromDC : hdc -> hwnd = env "nt window from dc"

    datatype rop2_mode =
      R2_BLACK |
      R2_COPYPEN |
      R2_MASKNOTPEN |
      R2_MASKPEN |
      R2_MASKPENNOT |
      R2_MERGENOTPEN |
      R2_MERGEPEN |
      R2_MERGEPENNOT |
      R2_NOP |
      R2_NOT |
      R2_NOTCOPYPEN |
      R2_NOTMASKPEN |
      R2_NOTMERGEPEN |
      R2_NOTXORPEN |
      R2_WHITE |
      R2_XORPEN

    val getRop2 : hdc -> rop2_mode = env "nt get rop2"
    val setRop2 : hdc * rop2_mode -> rop2_mode = env "nt set rop2"

    datatype color_spec =
      COLOR_ACTIVEBORDER |
      COLOR_ACTIVECAPTION |
      COLOR_APPWORKSPACE |
      COLOR_BACKGROUND |
      COLOR_BTNSHADOW |
      COLOR_BTNTEXT |
      COLOR_CAPTIONTEXT |
      COLOR_GRAYTEXT |
      COLOR_HIGHLIGHT |
      COLOR_HIGHLIGHTTEXT |
      COLOR_INACTIVEBORDER |
      COLOR_INACTIVECAPTION |
      COLOR_INACTIVECAPTIONTEXT |
      COLOR_MENU |
      COLOR_SCROLLBAR |
      COLOR_WINDOW |
      COLOR_WINDOWFRAME |
      COLOR_WINDOWTEXT

    val getSysColor : color_spec -> color = env "nt get sys color"
    val setBkColor : hdc * color -> color = env "nt set bk color"
    val getBkColor : hdc -> color = env "nt get bk color"
    val setTextColor : hdc * color -> color = env "nt set text color"
    val getTextColor : hdc -> color = env "nt get text color"

    (* Toolbars *)

    datatype tb_button_state = 
      TBSTATE_CHECKED |
      TBSTATE_ENABLED |
      TBSTATE_HIDDEN |
      TBSTATE_INDETERMINATE |
      TBSTATE_PRESSED |
      TBSTATE_WRAP

    val tbStatesToWord : tb_button_state list -> word = env "win32 convert tb states"

    datatype tb_button_style = 
      TBSTYLE_BUTTON |
      TBSTYLE_CHECK |
      TBSTYLE_CHECKGROUP |
      TBSTYLE_GROUP |
      TBSTYLE_SEP

    val createToolbarEx : 
	{bmp_id: word,
	 buttons: (int * word * tb_button_state list * tb_button_style list * word * int) list,
	 num_bmps: int,
	 num_buttons: int,
	 parent: hwnd,
	 styles: window_style list,
	 toolbar_id: word,
	 x_bitmap: int,
	 x_button: int,
	 y_bitmap: int,
	 y_button: int} ->
	hwnd = env "win32 create toolbar ex"

    (* Accelerator tables *)

    datatype accelerator_flag =
      FALT
    | FCONTROL
    | FNOINVERT
    | FSHIFT
    | FVIRTKEY

    (* First int is the key, the second is the command identifier *)
    val createAcceleratorTable : (accelerator_flag list * int * int) list -> accelerator_table =
      env "nt create accelerator table"

    val destroyAcceleratorTable : accelerator_table -> unit =
      env "nt destroy accelerator table"
    (* set the global mlworks accelerator table *)
    val setAcceleratorTable : accelerator_table -> unit = env "nt set accelerator table"

    (* clipboard *)

    val openClipboard : hwnd -> bool = env "nt open clipboard"
    val closeClipboard : unit -> unit = env "nt close clipboard"
    val emptyClipboard : unit -> unit = env "nt empty clipboard"
    val setClipboardData : string -> unit = env "nt set clipboard data"
    val getClipboardData : unit -> string = env "nt get clipboard data"

    (* MISC -- these should be somewhere else probably *)
    val malloc : int -> word = env "nt ml malloc"
    val free : word -> unit = env "nt ml free"
    val wordToString : word -> string = env "nt word to string"
    val setByte : word * int * int -> unit = env "nt set byte"
    val makeCString : string -> word = env "nt make c string"

    fun hiword w = wordToInt (Word.>> (w,0w16))
    fun loword w = wordToInt (Word.andb (w,intToWord ((256 * 256) - 1)))
  end
@


1.47
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d3 4
d169 1
d180 1
a180 1
    fun print s = MLWorks.IO.output (MLWorks.IO.terminal_out,s)
a822 3
(*
        output (MLWorks.IO.terminal_out,Int.toString (!id_count) ^ " id\n");
*)
@


1.46
log
@[Bug #30059]
Implement combo boxes for create dialog.
@
text
@d3 4
d11 8
d222 1
d455 1
d899 1
d912 1
a912 1
    val openFileDialog : hwnd * string -> string = env "nt open file dialog"
d914 1
a914 2
    val saveAsDialog : hwnd -> string = env "nt save as dialog"
    val saveImageDialog : hwnd -> string = env "nt save image dialog"
d918 15
d938 2
@


1.45
log
@[Bug #30193]
Implement SetWindowPos.
@
text
@d234 47
@


1.44
log
@[Bug #30204]
Update binding of runtime exception.
@
text
@d3 4
d631 2
@


1.43
log
@[Bug #30241]
Implementing proper Find Dialog.
@
text
@d3 4
d170 2
a171 1
	if !windows_exns_initialised then () 
@


1.43.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.43  1997/09/05  14:31:03  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
@


1.43.2.2
log
@[Bug #30071]
Redesign Compilation Manager -> Project Workspace.
@
text
@a830 1
    val getDlgCtrlID : hwnd -> int = env "win32 get dlg ctrl id"
d845 2
a846 1
    val saveDialog : hwnd * string * string -> string = env "win32 save dialog"
@


1.43.2.3
log
@[Bug #30071]
Generalise openFileDialog to take a description and a mask.
@
text
@a2 4
 * Revision 1.43.2.2  1997/09/12  14:48:42  johnh
 * [Bug #30071]
 * Redesign Compilation Manager -> Project Workspace.
 *
a204 1
    datatype cursor = CURSOR of word
a389 1
      WM_SETCURSOR | 
d844 1
a844 1
    val openFileDialog : hwnd * string * string -> string = env "nt open file dialog"
a849 15
    datatype cursor_shape = 
      IDC_APPSTARTING |
      IDC_ARROW |
      IDC_CROSS |
      IDC_IBEAM |
      IDC_ICON |
      IDC_NO |
      IDC_SIZE |
      IDC_SIZEALL |
      IDC_SIZENESW |
      IDC_SIZENS |
      IDC_SIZEWE |
      IDC_UPARROW |
      IDC_WAIT

a854 2
    val loadCursor : cursor_shape -> cursor = env "win32 load cursor"
    val setCursor : cursor -> cursor = env "win32 set cursor"
@


1.43.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.43  1997/09/05  14:31:03  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
@


1.42
log
@Implementing toolbar.
@
text
@d3 3
d267 2
d829 9
@


1.41
log
@Implementing single menu bar on Windows.
@
text
@d3 3
d310 3
d368 1
d496 4
d1079 33
@


1.40
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d3 4
d560 6
d594 2
d610 5
@


1.39
log
@[Bug #1992]
Added WM_CONTEXTMENU message value.
@
text
@d3 4
a139 2

    structure Option = MLWorks.Option
d510 1
a510 1
    type message_handler = (wparam * lparam -> word MLWorks.Option.option)
d678 1
a678 1
        fun find_message (m,[]) = Option.NONE
d680 1
a680 1
            if m = m' then Option.SOME r else find_message (m,rest)
d683 1
a683 1
          Option.SOME r =>
d804 1
a804 1
    val clipCursor : rect MLWorks.Option.option -> unit = env "nt clip cursor"
d1001 2
a1002 2
    val validateRect : hwnd * rect MLWorks.Option.option -> unit = env "nt validate rect"
    val invalidateRect : hwnd * rect MLWorks.Option.option * bool -> unit = env "nt invalidate rect"
@


1.39.1.1
log
@branched from 1.39
@
text
@a2 4
 * Revision 1.39  1997/03/25  17:26:58  johnh
 * [Bug #1992]
 * Added WM_CONTEXTMENU message value.
 *
@


1.39.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.39.1.1  1997/05/12  10:38:07  hope
 * branched from 1.39
 *
@


1.39.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.39.1.1  1997/05/12  10:38:07  hope
 * branched from 1.39
 *
@


1.39.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.39.1.1  1997/05/12  10:38:07  hope
 * branched from 1.39
 *
@


1.39.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.39.1.1.1.1  1997/07/28  18:23:18  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.38
log
@[Bug #1954]
Added WM_SIZING value (used by Capi.set_min_window_size).
@
text
@d3 4
d309 1
@


1.37
log
@[Bug #1728]
__integer becomes __int
@
text
@d3 4
d369 1
@


1.37.5.1
log
@branched from 1.37
@
text
@a2 4
 * Revision 1.37  1996/11/06  11:18:13  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.37.5.2
log
@Implemented CreateToolbarEx including the extra styles.
@
text
@a2 3
 * Revision 1.37.5.1  1996/12/18  09:45:37  hope
 * branched from 1.37
 *
a296 3
      TB_GETSTATE |
      TB_SETSTATE |

a350 1
      WM_NOTIFY |
a476 4
      TBSTYLE_ALTDRAG  |
      TBSTYLE_TOOLTIPS |
      TBSTYLE_WRAPABLE |

d523 2
a524 1
    val mainInit : unit -> hwnd = env "nt main init"
a1042 33

    (* Toolbars *)

    datatype tb_button_state = 
      TBSTATE_CHECKED |
      TBSTATE_ENABLED |
      TBSTATE_HIDDEN |
      TBSTATE_INDETERMINATE |
      TBSTATE_PRESSED |
      TBSTATE_WRAP

    val tbStateToWord : tb_button_state -> word = env "win32 convert tb state"

    datatype tb_button_style = 
      TBSTYLE_BUTTON |
      TBSTYLE_CHECK |
      TBSTYLE_CHECKGROUP |
      TBSTYLE_GROUP |
      TBSTYLE_SEP

    val createToolbarEx : 
	{bmp_id: word,
	 buttons: (int * int * tb_button_state list * tb_button_style list * word * int) list,
	 num_bmps: int,
	 num_buttons: int,
	 parent: hwnd,
	 styles: window_style list,
	 toolbar_id: word,
	 x_bitmap: int,
	 x_button: int,
	 y_bitmap: int,
	 y_button: int} ->
	hwnd = env "win32 create toolbar ex"
@


1.37.4.1
log
@branched from 1.37
@
text
@a2 4
 * Revision 1.37  1996/11/06  11:18:13  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.37.4.1.1.1
log
@branched from 1.37.4.1
@
text
@a2 3
 * Revision 1.37.4.1  1996/12/17  17:51:21  hope
 * branched from 1.37
 *
@


1.37.3.1
log
@branched from 1.37
@
text
@a2 4
 * Revision 1.37  1996/11/06  11:18:13  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.37.2.1
log
@branched from 1.37
@
text
@a2 4
 * Revision 1.37  1996/11/06  11:18:13  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.37.1.1
log
@branched from 1.37
@
text
@a2 4
 * Revision 1.37  1996/11/06  11:18:13  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.37.1.1.1.1
log
@branched from 1.37.1.1
@
text
@a2 3
 * Revision 1.37.1.1  1996/11/14  12:54:03  hope
 * branched from 1.37
 *
@


1.36
log
@[Bug #1687]
Removed redundant isAltOn function.
@
text
@d3 4
d121 1
a121 1
require "../basis/__integer";
@


1.35
log
@Added scrolling functionality.
@
text
@d3 3
a1070 2
    (* bit 29 tells us if alt is on *)
    fun isAltOn w = Word.andb (w,Word.<<(0w1,0w29)) <> nullWord
@


1.35.2.1
log
@branched from 1.35
@
text
@a2 3
 * Revision 1.35  1996/09/30  13:43:05  johnh
 * Added scrolling functionality.
 *
@


1.35.1.1
log
@branched from 1.35
@
text
@a2 3
 * Revision 1.35  1996/09/30  13:43:05  johnh
 * Added scrolling functionality.
 *
@


1.34
log
@Fixed syntax error causing daily build to fail.
@
text
@d776 2
@


1.33
log
@[Bug #1613]
[Bug #1613]
Added get_scroll_info and set_pixel and also added a check to ensure that.
the WindowSystemError is not redefined on compiling Windows.sml in Gui.
@
text
@d3 6
d667 1
a667 1
              handlerlistref := (message_word,ref [handler]) :: !handlerlistref)
@


1.32
log
@[Bug #1478]
Added WM_USER[0-5] messages.
@
text
@d3 4
d128 10
a137 1
    val _ = (env "exception win" : exn ref) :=  WindowSystemError ""
a289 1
      WM_CUT |
d293 1
d357 7
a363 1
      WM_UNDO |
d366 1
a366 1
      WM_WINDOWPOSCHANGING |
a369 6
      WM_USER0 |
      WM_USER1 |
      WM_USER2 |
      WM_USER3 |
      WM_USER4 |
      WM_USER5
d661 1
a661 1
              handlerlistref := (message_word,ref [handler]) :: !handlerlistref
d783 2
d830 1
d969 1
@


1.32.1.1
log
@branched from 1.32
@
text
@a2 4
 * Revision 1.32  1996/07/26  14:59:10  daveb
 * [Bug #1478]
 * Added WM_USER[0-5] messages.
 *
@


1.31
log
@Moved exception WindowSystemError here from _capi.
Added DEFAULT_GUI_FONT to stock_object datatype.
Added WM_INITDIALOG to message datatype.
@
text
@d3 5
d347 1
a347 1
      WM_WINDOWPOSCHANGING
d350 8
@


1.30
log
@Added WM_SYSCOMMAND, sc_value and convertScValue, and SW_RESTORE etc.
@
text
@d3 3
d110 3
d119 2
d287 1
d843 1
a844 1
      DEVICE_DEFAULT_FONT |
@


1.29
log
@add saveImageDialog
@
text
@d3 3
d326 1
d478 1
d480 7
a486 1
      SW_SHOWDEFAULT
d793 21
@


1.28
log
@Changed type of word shift operations
@
text
@d3 3
d727 1
@


1.27
log
@Changes to basis
@
text
@d3 3
d93 1
a93 1
require "../basis/word";
d95 1
a95 1
functor Windows (structure Word : WORD) : WINDOWS =
d99 1
d983 1
a983 1
    fun hiword w = wordToInt (Word.>> (w,intToWord 16))
d986 1
a986 1
    fun isAltOn w = Word.andb (w,Word.<<(intToWord 1,intToWord 29)) <> nullWord
@


1.26
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d106 2
a107 2
    val intToWord = Word.IntCvt.from
    val wordToInt = Word.IntCvt.to
@


1.25
log
@Removing MLWorks.Integer
@
text
@d3 3
d91 1
a91 1
    fun print s = output (MLWorks.IO.terminal_out,s)
@


1.24
log
@initbasis moves to basis
@
text
@d3 3
d78 2
d94 1
a94 1
    val N = MLWorks.Integer.makestring
d627 1
a627 1
        output (MLWorks.IO.terminal_out,MLWorks.Integer.makestring (!id_count) ^ " id\n");
@


1.23
log
@New language definition
@
text
@d3 3
d21 52
a72 52
# Revision 1.17  1996/01/25  12:27:09  matthew
# Adding get_bg_color etc.
#
# Revision 1.16  1996/01/12  16:35:41  matthew
# Adding WM_SETREDRAW message
#
# Revision 1.15  1996/01/12  10:00:34  daveb
# Added open_file_dialog, open_dir_dialog and save_as_dialog.
#
# Revision 1.14  1996/01/04  16:16:47  matthew
# Adding get_stock_object
#
# Revision 1.13  1995/12/20  15:14:02  matthew
# Adding color functions
#
# Revision 1.12  1995/12/15  14:31:48  matthew
# Adding new window styles.
#
# Revision 1.11  1995/12/14  14:22:37  matthew
# Changing message handling
#
# Revision 1.10  1995/12/06  17:16:30  matthew
# Adding clipboard functionality
#
# Revision 1.9  1995/11/21  11:11:19  matthew
# More stuff
#
# Revision 1.8  1995/11/14  13:57:53  matthew
# Extending for graphics
#
# Revision 1.7  1995/09/19  14:02:27  matthew
# Changes for new word signature
#
# Revision 1.6  1995/09/05  10:50:15  matthew
# Adding word_to_signed_int
#
# Revision 1.5  1995/08/31  10:12:16  matthew
# Adding extra menu functions
#
# Revision 1.4  1995/08/25  10:18:35  matthew
# More stuff
#
# Revision 1.3  1995/08/15  11:23:45  matthew
# Extending
#
# Revision 1.2  1995/08/11  08:36:44  matthew
# Making it all work
#
# Revision 1.1  1995/08/03  12:53:13  matthew
# new unit
# MS Windows GUI
#
d76 1
a76 1
require "../initbasis/word";
@


1.22
log
@Changes for new language definition
@
text
@d3 3
d75 1
a75 1
functor Windows (structure Word : WORD sharing type Word.IntCvt.other = int and type Word.word = Word.IntCvt.word) : WINDOWS =
@


1.21
log
@Extending
@
text
@d3 3
d549 2
a550 2
    val killTimer = env "nt kill timer"
    val setTimer = env "nt set timer"
@


1.20
log
@Extending library functions
@
text
@d3 3
d73 3
d77 2
a79 1
    fun print s = output (MLWorks.IO.terminal_out,s)
a94 3
    exception Unimplemented of string
    fun unimplemented s _ = raise Unimplemented s

d108 1
d546 2
a547 2
    val killTimer = unimplemented "killTimer"
    val setTimer = unimplemented "setTimer"
d654 2
a655 2
    val getMenuState : hmenu * word * menu_flag -> menu_flag list = unimplemented "get_menu_state"
    val getMenuString : hmenu * word * menu_flag -> string = unimplemented "get_menu_string"
d754 10
a763 2
    val getDc : hwnd -> hdc = env "nt get dc"
    val releaseDc : hwnd * hdc -> unit = env "nt release dc"
d785 16
a800 1
    val getStockObject : stock_object -> word = env "nt get stock object"
d802 28
a829 19
    datatype color_spec =
      COLOR_ACTIVEBORDER |
      COLOR_ACTIVECAPTION |
      COLOR_APPWORKSPACE |
      COLOR_BACKGROUND |
      COLOR_BTNSHADOW |
      COLOR_BTNTEXT |
      COLOR_CAPTIONTEXT |
      COLOR_GRAYTEXT |
      COLOR_HIGHLIGHT |
      COLOR_HIGHLIGHTTEXT |
      COLOR_INACTIVEBORDER |
      COLOR_INACTIVECAPTION |
      COLOR_INACTIVECAPTIONTEXT |
      COLOR_MENU |
      COLOR_SCROLLBAR |
      COLOR_WINDOW |
      COLOR_WINDOWFRAME |
      COLOR_WINDOWTEXT
d831 20
a850 5
    val getSysColor : color_spec -> word = env "nt get sys color"
    val setBkColor : hdc * word -> word = env "nt set bk color"
    val getBkColor : hdc -> word  = env "nt get bk color"
    val setTextColor : hdc * word -> word = env "nt set text color"
    val getTextColor : hdc -> word = env "nt get text color"
d852 18
a869 3
    val lineTo : hdc * int * int -> unit = env "nt line to"
    val fillRectangle : hdc * int * int * int * int -> unit = env "nt fill rectangle"
    val clearRectangle : hdc * int * int * int * int -> unit = env "nt clear rectangle"
d896 26
@


1.19
log
@More rationalization
@
text
@d3 3
d805 3
a807 1
    val validateClientArea : hwnd -> unit = env "nt validate client area"
@


1.18
log
@Extending library functions
@
text
@d3 3
d73 2
a74 2
    val int_to_word = Word.IntCvt.from
    val word_to_int = Word.IntCvt.to
d76 1
a76 1
    val null_word = int_to_word 0
d79 3
a81 3
    fun word_to_signed_int w =
      word_to_int w
      handle _ => ~(word_to_int (Word.- (null_word,w)))
d83 1
a83 1
    fun W w = N (word_to_int w) (* no Word.makestring! *)
d88 13
a100 13
    datatype Hwnd = HWND of word
    fun window_to_word (HWND w) = w
    fun word_to_window w = HWND w

    datatype Hmenu = HMENU of word
    fun menu_to_word (HMENU w) = w
    fun word_to_menu w = HMENU w

    datatype AcceleratorTable = ACCELERATORTABLE of word
    datatype WParam = WPARAM of word
    datatype LParam = LPARAM of word
    datatype HDC = HDC of word
    datatype Timer = TIMER of word
d102 2
a103 2
    val null_window = HWND null_word
    val null_menu = HMENU null_word
d105 1
a105 1
    fun is_null_window (hwnd) = hwnd = null_window
d107 2
a108 2
    datatype Rect = RECT of {left:int,top:int,right:int,bottom:int}
    datatype Point = POINT of {x:int,y:int}
d111 1
a111 1
    datatype Message =
d295 1
a295 1
    datatype WindowStyle =
d408 1
a408 1
    type message_handler = (WParam * LParam -> word MLWorks.Option.option)
d412 1
a412 1
      (Hwnd * (* The window *)
d416 2
a417 2
    val get_handler_map : unit -> handler_map_entry list = env "nt get handler map"
    val set_handler_map : handler_map_entry list -> unit = env "nt set handler map"
d419 1
a419 1
    fun add_new_window (window,cproc) =
d421 1
a421 1
        val hmap = get_handler_map ()
d423 1
a423 1
        set_handler_map ((window,(cproc,ref nil)) :: hmap)
d426 2
a427 2
    val main_loop : unit -> unit = env "nt main loop"
    val do_input : unit -> bool = env "nt do input"
d429 1
a429 1
    val main_init : unit -> Hwnd = 
d432 1
a432 1
    datatype SWArg =
d439 1
a439 1
    datatype GWArg =
d449 5
a453 5
    val any_popup : unit -> bool = env "nt any popup"
    val bring_window_to_top : Hwnd -> unit = env "nt bring window to top"
    val child_window_from_point : Hwnd * (int * int) -> Hwnd = env"nt child window from point"
    val close_window : Hwnd -> unit = env "nt close window"
    val create_window : 
d456 1
a456 1
       styles : WindowStyle list,
d459 1
a459 1
       parent: Hwnd,
d461 28
a488 28
      Hwnd = env "nt create window"
    val destroy_window : Hwnd -> unit = env "nt destroy window"
    val enum_child_windows : Hwnd * (Hwnd -> unit) -> unit = env "nt enum child windows"
    val enum_windows : (Hwnd -> unit) -> unit = env "nt enum windows"
    val find_window : string * string -> Hwnd = env "nt find window"
    val get_client_rect : Hwnd -> Rect = env "nt get client rect";
    val get_desktop_window : unit-> Hwnd = env "nt get desktop window"
    val get_foreground_window : unit-> Hwnd = env "nt get foreground window"
    val get_last_active_popup : Hwnd -> Hwnd = env "nt get last active popup"
    val get_next_window : Hwnd * GWArg -> Hwnd = env "nt get next window"
    val get_parent : Hwnd -> Hwnd = env "nt get parent"
    val get_top_window : Hwnd -> Hwnd = env "nt get top window"
    val get_window : Hwnd * GWArg -> Hwnd = env "nt get window"
    val get_window_rect : Hwnd -> Rect = env "nt get window rect"
    val is_child : Hwnd * Hwnd -> bool = env "nt is child"
    val is_iconic : Hwnd -> bool = env "nt is iconic"
    val is_window : Hwnd -> bool = env "nt is window"
    val is_window_unicode : Hwnd -> bool = env "nt is window unicode"
    val is_window_visible : Hwnd -> bool = env "nt is window visible"
    val is_zoomed : Hwnd -> bool = env "nt is zoomed"
    val move_window : Hwnd * int * int * int * int * bool -> unit = env "nt move window"
    val set_foreground_window : Hwnd -> unit = env "nt set foreground window"
    val set_parent : Hwnd * Hwnd -> Hwnd = env "nt set parent"
    val set_window_text : Hwnd * string -> unit = env "nt set window text"
    val show_owned_popups : Hwnd * bool -> unit = env "nt show owned popups"
    val show_window : Hwnd * SWArg -> unit = env "nt show window"
    val update_window : Hwnd -> unit = env "nt update window"
    val window_from_point : int * int -> Hwnd = env "nt window from point"
d492 8
a499 8
    val get_input_state : unit -> bool = env "nt get input state"
    val get_message_pos : unit -> int * int = env "nt get message pos"
    val get_message_time : unit -> int = env "nt get message time"
    val in_send_message : unit -> bool = env "nt in send message"
    val post_message : Hwnd * Message * WParam * LParam -> unit = env "nt post message"
    val post_quit_message : int -> unit = env "nt post quit message"
    val send_message : Hwnd * Message * WParam * LParam -> word = env "nt send message"
    val message_to_word : Message -> word = env "nt convert message"
d503 1
a503 1
    datatype GwlValue =
d514 3
a516 3
    val get_window_long_internal : Hwnd * int -> word = env "nt get window long"
    val set_window_long_internal : Hwnd * int * word -> word = env "nt set window long"
    val convert_gwl_value : GwlValue -> int = env "nt convert gwl value"
d518 2
a519 2
    fun get_window_long (hwnd,value) =
      get_window_long_internal (hwnd,convert_gwl_value value)
d521 2
a522 2
    fun set_window_long (hwnd,value,x) =
      set_window_long_internal (hwnd,convert_gwl_value value,x)
d525 6
a530 6
    val enable_window : Hwnd * bool -> bool = env "nt enable window"
    val get_active_window  : unit -> Hwnd = env "nt get active window"
    val get_focus : unit -> Hwnd = env "nt get focus"
    val is_window_enabled : Hwnd -> bool = env "nt is window enabled"
    val set_active_window  : Hwnd -> Hwnd = env "nt set active window"
    val set_focus : Hwnd -> Hwnd = env "nt set focus"
d533 3
a535 3
    val get_capture : unit -> Hwnd = env "nt get capture"
    val release_capture : unit -> unit = env "nt release capture"
    val set_capture : Hwnd -> Hwnd = env "nt set capture"
d538 2
a539 2
    val kill_timer = unimplemented "kill_timer"
    val set_timer = unimplemented "set_timer"
d542 2
a543 2
    val client_to_screen : Hwnd * Point -> Point = env "nt client to screen";
    val screen_to_client : Hwnd * Point -> Point = env "nt screen to client";
d547 1
a547 1
    fun get_window_entry window =
d549 1
a549 1
        val hmap = get_handler_map ()
d553 1
a553 1
            val entry = (null_word,ref [])
d555 1
a555 1
            set_handler_map ((window,entry) :: hmap);
d565 1
a565 1
    fun add_message_handler (window,message,handler) =
d567 2
a568 2
        val (cproc,handlerlistref) = get_window_entry window
        val message_word = message_to_word message
d580 1
a580 1
    fun remove_window (window) =
d582 1
a582 1
        val hmap = get_handler_map ()
d588 1
a588 1
        set_handler_map (remove (window,hmap,[]))
d593 1
a593 1
    val get_ml_window_proc : unit -> word = env "nt get ml window proc"
d599 1
a599 1
    fun new_control_id () =
d601 1
a601 1
        val result = int_to_word (!id_count)
d610 1
a610 1
    datatype MenuValue = SUBMENU of Hmenu | ITEM of word
d612 1
a612 1
    datatype MenuFlag =
d628 1
a628 1
    val append_menu_ : Hmenu * MenuFlag list * word * string -> unit = env "nt append menu"
d630 1
a630 1
    val append_menu : Hmenu * MenuFlag list * MenuValue * string -> unit = 
d636 16
a651 16
    val check_menu_item : Hmenu * word * MenuFlag list -> unit = env "nt check menu item"
    val create_menu : unit -> Hmenu = env "nt create menu"
    val create_popup_menu : unit -> Hmenu = env "nt create popup menu"
    val destroy_menu : Hmenu -> unit = env "nt destroy menu"
    val delete_menu : Hmenu * word * MenuFlag -> unit = env "nt remove menu"
    val draw_menu_bar : Hwnd -> unit = env "nt draw menu bar"
    val enable_menu_item : Hmenu * word * MenuFlag list -> unit = env "nt enable menu item"
    val get_menu : Hwnd -> Hmenu = env "nt get menu"
    val get_menu_item_id : Hmenu * int -> word = env "nt get menu item id"
    val get_menu_item_count : Hmenu -> int = env "nt get menu item count"
    val get_menu_state : Hmenu * word * MenuFlag -> MenuFlag list = unimplemented "get_menu_state"
    val get_menu_string : Hmenu * word * MenuFlag -> string = unimplemented "get_menu_string"
    val get_submenu : Hmenu * int -> Hmenu = env "nt get submenu"
    val get_system_menu : Hwnd * bool -> Hmenu = env "nt get system menu"
    val set_menu : Hwnd * Hmenu -> unit = env "nt set menu"
    val remove_menu : Hmenu * word * MenuFlag -> unit = env "nt remove menu"
d654 1
a654 1
    val add_command_handler_internal : Hwnd * word * (Hwnd * int-> unit) -> unit = 
d657 2
a658 2
    fun add_command_handler (window,w,handler) =
      add_command_handler_internal (window, w, handler)
d662 2
a663 2
    val register_popup_window : Hwnd -> unit = env "nt register popup window"
    val unregister_popup_window : Hwnd -> unit = env "nt unregister popup window"
d665 1
a665 1
    datatype MessageBoxStyle =
d680 2
a681 2
    val message_box : Hwnd * string * string * MessageBoxStyle list -> int = env "nt message box"
    val message_beep : MessageBoxStyle -> unit = env "nt message beep"
d683 2
a684 2
    val end_dialog : Hwnd * int -> unit = env "nt end dialog"
    val get_dlg_item : Hwnd * word -> Hwnd = env "nt get dlg item"
d686 3
a688 3
    val open_file_dialog : Hwnd * string -> string = env "nt open file dialog"
    val open_dir_dialog : Hwnd -> string = env "nt open dir dialog"
    val save_as_dialog : Hwnd -> string = env "nt save as dialog"
d692 5
a696 5
    val clip_cursor : Rect MLWorks.Option.option -> unit = env "nt clip cursor"
    val get_clip_cursor : unit -> Rect = env "nt get clip cursor"
    val get_cursor_pos : unit -> Point = env "nt get cursor pos"
    val set_cursor_pos : int * int -> unit = env "nt set cursor pos"
    val show_cursor : bool -> int = env "nt show cursor"
d700 3
a702 3
    val check_dlg_button: Hwnd * word * int -> unit = env "nt check dlg button"
    val check_radio_button: Hwnd * word * word * word -> unit = env "nt check radio button"
    val is_dlg_button_checked: Hwnd * word -> int = env "nt is dlg button checked"
d706 1
a706 1
    datatype SB_Value =
d725 1
a725 1
    val convert_sb_value : SB_Value -> int = env "nt ml convert sb value"
d727 1
a727 1
    datatype ESB_Value =
d737 6
a742 6
    val enable_scroll_bar : Hwnd * SB_Value * ESB_Value -> unit = env "nt enable scroll bar"
    val set_scroll_range : Hwnd * SB_Value * int * int * bool -> unit = env "nt set scroll range"
    val get_scroll_range : Hwnd * SB_Value -> int * int = env "nt get scroll range"
    val set_scroll_pos : Hwnd * SB_Value * int * bool -> unit = env "nt set scroll pos"
    val get_scroll_pos : Hwnd * SB_Value -> int = env "nt get scroll pos"
    val show_scroll_bar : Hwnd * SB_Value * bool -> unit = env "nt show scroll bar"
d746 2
a747 2
    val get_dc : Hwnd -> HDC = env "nt get dc"
    val release_dc : Hwnd * HDC -> unit = env "nt release dc"
d750 1
a750 1
    datatype StockObject =
d769 1
a769 1
    val get_stock_object : StockObject -> word = env "nt get stock object"
d771 1
a771 1
    datatype ColorSpec =
d791 12
a802 12
    val get_sys_color : ColorSpec -> word = env "nt get sys color"
    val set_bk_color : HDC * word -> word = env "nt set bk color"
    val get_bk_color : HDC -> word  = env "nt get bk color"
    val set_text_color : HDC * word -> word = env "nt set text color"
    val get_text_color : HDC -> word = env "nt get text color"
    val move_to : HDC * int * int * word -> unit = env "nt move to"
    val line_to : HDC * int * int -> unit = env "nt line to"
    val fill_rectangle : HDC * int * int * int * int -> unit = env "nt fill rectangle"
    val clear_rectangle : HDC * int * int * int * int -> unit = env "nt clear rectangle"
    val	text_out : HDC * int * int * string -> unit = env "nt text out"
    val get_text_extent_point : HDC * string -> int * int = env "nt get text extent point"
    val validate_client_area : Hwnd -> unit = env "nt validate client area"
d804 1
a804 1
    datatype ROP2Mode =
d822 2
a823 2
    val get_rop2 : HDC -> ROP2Mode = env "nt get rop2"
    val set_rop2 : HDC * ROP2Mode -> ROP2Mode = env "nt set rop2"
d827 1
a827 1
    datatype AcceleratorFlag =
d835 1
a835 1
    val create_accelerator_table : (AcceleratorFlag list * int * int) list -> AcceleratorTable =
d838 1
a838 1
    val destroy_accelerator_table : AcceleratorTable -> unit =
d841 1
a841 1
    val set_accelerator_table : AcceleratorTable -> unit = env "nt set accelerator table"
d845 5
a849 5
    val open_clipboard : Hwnd -> bool = env "nt open clipboard"
    val close_clipboard : unit -> unit = env "nt close clipboard"
    val empty_clipboard : unit -> unit = env "nt empty clipboard"
    val set_clipboard_data : string -> unit = env "nt set clipboard data"
    val get_clipboard_data : unit -> string = env "nt get clipboard data"
d854 3
a856 3
    val word_to_string : word -> string = env "nt word to string"
    val set_byte : word * int * int -> unit = env "nt set byte"
    val make_c_string : string -> word = env "nt make c string"
d858 2
a859 2
    fun hiword w = word_to_int (Word.>> (w,int_to_word 16))
    fun loword w = word_to_int (Word.andb (w,int_to_word ((256 * 256) - 1)))
d861 1
a861 1
    fun is_alt_on w = Word.andb (w,Word.<<(int_to_word 1,int_to_word 29)) <> null_word
@


1.17
log
@Adding get_bg_color etc.
@
text
@d3 3
d82 3
d97 1
a428 12
    val create_window : 
      {class: string,
       name: string,
       styles : WindowStyle list,
       width : int,
       height : int,
       parent: Hwnd,
       menu : word} -> 
      Hwnd = env "nt create window"

    val move_window : Hwnd * int * int * int * int * bool -> unit = env "nt move window"

a435 2
    val show_window : Hwnd * SWArg -> unit = env "nt show window"

a443 1
    val get_window : Hwnd * GWArg -> Hwnd = env "nt get window"
d445 2
a446 3
    val update_window : Hwnd -> unit = env "nt update window"
    val enable_window : Hwnd * bool -> bool = env "nt enable window"
    val is_window : Hwnd -> bool = env "nt is window"
d448 1
d450 9
d460 8
d469 17
d487 1
a487 2
    val enum_windows : (Hwnd -> unit) -> unit = env "nt enum windows"
    val enum_child_windows : Hwnd * (Hwnd -> unit) -> unit = env "nt enum child windows"
d489 8
a496 8
    val get_window_rect : Hwnd -> Rect = env "nt get window rect"
    val get_client_rect : Hwnd -> Rect = env "nt get client rect";
    val client_to_screen : Hwnd * Point -> Point = env "nt client to screen";
    val screen_to_client : Hwnd * Point -> Point = env "nt screen to client";

    val set_focus : Hwnd -> Hwnd = env "nt set focus"
    val set_active_window  : Hwnd -> Hwnd = env "nt set active window"
    val get_focus : unit -> Hwnd = env "nt get focus"
d498 1
a498 2
    val get_window_long : Hwnd * int -> word = env "nt get window long"
    val set_window_long : Hwnd * int * word -> word = env "nt set window long"
d511 3
a513 1
    val convert_gwl_value : GwlValue -> int = env"nt convert gwl value"
d515 13
a527 1
    (* MESSAGES *)
d529 12
a540 8
    val get_input_state : unit -> bool = env "nt get input state"
    val get_message_pos : unit -> int * int = env "nt get message pos"
    val get_message_time : unit -> int = env "nt get message time"
    val in_send_message : unit -> bool = env "nt in send message"
    val post_message : Hwnd * Message * WParam * LParam -> unit = env "nt post message"
    val post_quit_message : int -> unit = env "nt post quit message"
    val send_message : Hwnd * Message * WParam * LParam -> word = env "nt send message"
    val message_to_word : Message -> word = env "nt convert message"
a624 9
    val get_menu : Hwnd -> Hmenu = env "nt get menu"
    val get_submenu : Hmenu * int -> Hmenu = env "nt get submenu"
    val set_menu : Hwnd * Hmenu -> unit = env "nt set menu"
    val create_menu : unit -> Hmenu = env "nt create menu"
    val create_popup_menu : unit -> Hmenu = env "nt create popup menu"

    val check_menu_item : Hmenu * word * MenuFlag list -> unit = env "nt check menu item"
    val enable_menu_item : Hmenu * word * MenuFlag list -> unit = env "nt enable menu item"

d633 15
a648 1
    val delete_menu : Hmenu * word * MenuFlag -> unit = env "nt remove menu"
d650 1
d687 9
d704 1
d722 13
d739 1
a739 1
    val convert_sb_value : SB_Value -> int = env "nt ml convert sb value"
@


1.16
log
@Adding WM_SETREDRAW message
@
text
@d3 3
d719 3
@


1.15
log
@Added open_file_dialog, open_dir_dialog and save_as_dialog.
@
text
@d3 3
d267 1
@


1.14
log
@Adding get_stock_object
@
text
@d3 3
d627 4
@


1.13
log
@Adding color functions
@
text
@d3 3
d661 22
@


1.12
log
@Adding new window styles.
@
text
@d3 3
d657 23
@


1.11
log
@Changing message handling
@
text
@d3 3
d281 1
d285 2
d292 1
d295 8
d337 3
d366 1
d378 1
d381 1
a381 1
      
d426 11
d454 1
@


1.10
log
@Adding clipboard functionality
@
text
@d3 3
a81 4
    val main_loop : unit -> unit = env "nt main loop"
    val main_init : unit -> Hwnd = env "nt main init"
    val do_input : unit -> bool = env "nt do input"

d362 24
d397 1
d404 1
d441 11
d454 47
a500 3
    val set_ml_window_proc : (Hwnd * word * WParam * LParam -> word MLWorks.Option.option) -> unit = env "nt set ml window proc"
    val call_window_proc : word * (Hwnd * word * WParam * LParam) -> word = env "nt call window proc"
    val get_simple_window_proc : unit -> word = env "nt get simple window proc"
a559 32

    (* MESSAGES *)

    val get_input_state : unit -> bool = env "nt get input state"
    val get_message_pos : unit -> int * int = env "nt get message pos"
    val get_message_time : unit -> int = env "nt get message time"
    val in_send_message : unit -> bool = env "nt in send message"
    val post_message : Hwnd * Message * WParam * LParam -> unit = env "nt post message"
    val send_message : Hwnd * Message * WParam * LParam -> word = env "nt send message"
    val message_to_word : Message -> word = env "nt convert message"

    val message_handlers = ref [] : (Hwnd * word * (WParam * LParam -> word)) list ref

    fun add_message_handler (window,message,handler) =
      let
        val message_word = message_to_word message
      in
        message_handlers := (window,message_word,handler) :: !message_handlers
      end

    fun eq (x,y) = x = y
    fun despatch_message (window,message,wparam,lparam) =
      let
        fun apply [] = Option.NONE
          | apply ((window',message',handler) :: rest) =
            if eq (window,window') andalso eq (message,message')
              then 
                Option.SOME (handler (wparam,lparam))
            else apply rest
      in
        apply (!message_handlers)
      end
@


1.9
log
@More stuff
@
text
@d3 3
a388 2
    val callback_add : (Hwnd * int * ('a -> unit)) -> unit = env "nt add callback"

d620 8
@


1.8
log
@Extending for graphics
@
text
@d3 3
d63 1
d430 3
a432 3
        if (!id_count) mod 1000 = 0 
          then output (MLWorks.IO.terminal_out,MLWorks.Integer.makestring (!id_count) ^ " id\n") 
        else ();
d474 2
a475 1
    val add_command_handler_internal : word * (Hwnd * int-> unit) -> unit = env "nt add menu command"
d477 2
a478 2
    fun add_command_handler (w,handler) =
      add_command_handler_internal (w, fn args => handler args (* handle _ => (print "exception caught in command handler\n") *))
d514 3
d601 18
@


1.7
log
@Changes for new word signature
@
text
@d3 3
d62 1
d197 1
d203 1
d233 1
d254 1
d535 59
d603 2
@


1.6
log
@Adding word_to_signed_int
@
text
@d3 3
d25 1
a25 1
require "../initbasis/words";
d27 1
a27 1
functor Windows (structure Word : WORD) : WINDOWS =
d37 5
a41 3
    val null_word = Word.intToWord 0
    val int_to_word = Word.intToWord
    val word_to_int = Word.wordToInt
d44 2
a45 2
      Word.wordToInt w
      handle _ => ~(Word.wordToInt (Word.- (null_word,w)))
d415 1
a415 1
        val result = Word.intToWord (!id_count)
d429 2
d459 3
d534 2
a535 2
    fun hiword w = Word.wordToInt (Word.shift (w,~16))
    fun loword w = Word.wordToInt (Word.andb (w,Word.intToWord ((256 * 256) - 1)))
@


1.5
log
@Adding extra menu functions
@
text
@d3 3
d37 5
d452 4
a455 1
    val add_command_handler : word * (Hwnd * int-> unit) -> unit = env "nt add menu command"
@


1.4
log
@More stuff
@
text
@d3 3
d24 1
d44 2
a45 2
    datatype WParam = WPWORD of word
    datatype LParam = LPWORD of word
d185 1
d392 2
a393 2
    val set_ml_window_proc : (Hwnd * word * word * word -> word MLWorks.Option.option) -> unit = env "nt set ml window proc"
    val call_window_proc : word * (Hwnd * word * word * word) -> word = env "nt call window proc"
d433 3
d444 1
a444 1
    val add_command_handler : word * (int->unit) -> unit = env "nt add menu command"
d455 22
@


1.3
log
@Extending
@
text
@d3 3
d23 3
d30 1
d40 2
a41 4
    (* WParam doesn't need a string constructor *)
    (* perhaps we should have WPINT and LPINT too *)
    datatype WParam = WPWORD of word | WPSTRING of string
    datatype LParam = LPWORD of word | LPSTRING of string
d53 1
d349 2
d369 21
a389 2
    val set_window_long : Hwnd * int -> word = env "nt set window long"
    val get_window_long : Hwnd * int * word -> word = env "nt get window long"
d392 2
d400 3
a438 1
    (* Should probably have a message class *)
d468 8
d481 1
d483 2
@


1.2
log
@Making it all work
@
text
@d3 3
a32 4
    datatype MenuId = MENUID of word
    fun menu_id_to_word (MENUID w) = w
    fun word_to_menu_id w = MENUID w

d330 2
a331 1
       parent: Hwnd} -> 
d365 2
a366 2
    val id_count = ref 100 (* Start at 100 for no very good reason *)
    fun new_menu_id () =
d368 1
a368 1
        val result = MENUID (Word.intToWord (!id_count))
d374 1
a374 1
    datatype MenuValue = SUBMENU of Hmenu | ITEM of MenuId
d378 7
d386 3
a388 1
      MF_STRING
d402 1
a402 1
        | ITEM (MENUID b) => append_menu_ (menu,flags,b,string)
d404 1
a404 1
    val add_menu_command : MenuId * (unit->unit) -> unit = env "nt add menu command"
@


1.1
log
@new unit
MS Windows GUI
@
text
@d3 4
d10 1
d12 1
a12 1
functor Windows () : WINDOWS =
d14 1
d17 29
a45 2
    datatype window = WINDOW of int
    val null_window = WINDOW 0
d48 379
a426 3
    val main_init : unit -> window = env "nt main init"
    val make_window : string -> window = env "nt create window"
    val callback_add : (window * int * ('a -> unit)) -> unit = env "nt add callback"
d428 5
@
