head	1.129;
access;
symbols
	MLW_daveb_inline_1_4_99:1.129.1
	MLWorks_21c0_1999_03_25:1.129
	MLWorks_20c1_1998_08_20:1.126
	MLWorks_20c0_1998_08_04:1.125
	MLWorks_20b2c2_1998_06_19:1.118
	MLWorks_20b2_Windows_1998_06_12:1.116
	MLWorks_20b1c1_1998_05_07:1.113
	MLWorks_20b0_1998_04_07:1.113
	MLWorks_20b0_1998_03_20:1.110
	MLWorks_20m2_1998_02_16:1.107
	MLWorks_20m1_1997_10_23:1.104
	MLWorks_11r1:1.91.1.1.1.3.1
	MLWorks_workspace_97:1.100.2
	MLWorks_dt_wizard:1.100.1
	MLWorks_11c0_1997_09_09:1.91.1.1.1.3
	MLWorks_10r3:1.91.1.1.3
	MLWorks_10r2_551:1.91.1.1.2
	MLWorks_11:1.91.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.91.1.1
	MLWorks_20m0_1997_06_20:1.95
	MLWorks_1_0_r2c2_1997_06_14:1.91.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.91.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.91.1
	MLWorks_BugFix_1997_04_24:1.91
	MLWorks_1_0_r2_Win32_1997_04_11:1.91
	MLWorks_1_0_r2_Unix_1997_04_04:1.91
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.88.2.1.1
	MLWorks_gui_1996_12_18:1.88.3
	MLWorks_1_0_Win32_1996_12_17:1.88.2
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.78.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.78.1.1
	JFHmswindows:1.88.1
	MLWorks_1_0_Irix_1996_11_28:1.78.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.85.1
	MLWorks_1_0_Unix_1996_11_14:1.78.1
	MLWorks_Open_Beta2_1996_10_11:1.72.2
	MLWorks_License_dev:1.72.1
	MLWorks_1_open_beta_1996_09_13:1.66.1
	MLWorks_Open_Beta_1996_08_22:1.66
	MLWorks_Beta_1996_07_02:1.59
	MLWorks_Beta_1996_06_07:1.56
	MLWorks_Beta_1996_06_06:1.56
	MLWorks_Beta_1996_06_05:1.56
	MLWorks_Beta_1996_06_03:1.56
	MLWorks_Beta_1996_05_31:1.55
	MLWorks_Beta_1996_05_30:1.55;
locks; strict;
comment	@ * @;


1.129
date	99.03.15.23.25.28;	author mitchell;	state Exp;
branches
	1.129.1.1;
next	1.128;

1.128
date	99.03.09.10.39.07;	author mitchell;	state Exp;
branches;
next	1.127;

1.127
date	98.08.20.16.08.43;	author jont;	state Exp;
branches;
next	1.126;

1.126
date	98.08.14.16.13.35;	author mitchell;	state Exp;
branches;
next	1.125;

1.125
date	98.07.30.13.07.12;	author johnh;	state Exp;
branches;
next	1.124;

1.124
date	98.07.23.14.41.35;	author johnh;	state Exp;
branches;
next	1.123;

1.123
date	98.07.17.15.00.10;	author jkbrook;	state Exp;
branches;
next	1.122;

1.122
date	98.07.15.11.26.02;	author jkbrook;	state Exp;
branches;
next	1.121;

1.121
date	98.07.14.09.33.23;	author johnh;	state Exp;
branches;
next	1.120;

1.120
date	98.07.09.12.35.00;	author johnh;	state Exp;
branches;
next	1.119;

1.119
date	98.07.02.14.56.48;	author johnh;	state Exp;
branches;
next	1.118;

1.118
date	98.06.24.14.29.09;	author johnh;	state Exp;
branches;
next	1.117;

1.117
date	98.06.24.13.24.25;	author johnh;	state Exp;
branches;
next	1.116;

1.116
date	98.06.11.18.23.31;	author jkbrook;	state Exp;
branches;
next	1.115;

1.115
date	98.06.11.15.06.32;	author johnh;	state Exp;
branches;
next	1.114;

1.114
date	98.06.01.10.34.52;	author johnh;	state Exp;
branches;
next	1.113;

1.113
date	98.04.01.15.05.16;	author jont;	state Exp;
branches;
next	1.112;

1.112
date	98.03.31.17.52.30;	author johnh;	state Exp;
branches;
next	1.111;

1.111
date	98.03.26.13.14.34;	author johnh;	state Exp;
branches;
next	1.110;

1.110
date	98.02.20.11.38.07;	author mitchell;	state Exp;
branches;
next	1.109;

1.109
date	98.02.18.17.09.18;	author jont;	state Exp;
branches;
next	1.108;

1.108
date	98.02.17.16.43.56;	author johnh;	state Exp;
branches;
next	1.107;

1.107
date	98.01.27.15.28.54;	author johnh;	state Exp;
branches;
next	1.106;

1.106
date	97.11.06.13.00.00;	author johnh;	state Exp;
branches;
next	1.105;

1.105
date	97.10.30.09.40.34;	author johnh;	state Exp;
branches;
next	1.104;

1.104
date	97.10.16.14.13.40;	author johnh;	state Exp;
branches;
next	1.103;

1.103
date	97.10.09.15.35.56;	author johnh;	state Exp;
branches;
next	1.102;

1.102
date	97.10.06.10.36.44;	author johnh;	state Exp;
branches;
next	1.101;

1.101
date	97.09.19.14.29.29;	author brucem;	state Exp;
branches;
next	1.100;

1.100
date	97.09.05.15.00.35;	author johnh;	state Exp;
branches
	1.100.1.1
	1.100.2.1;
next	1.99;

1.99
date	97.08.06.12.46.57;	author brucem;	state Exp;
branches;
next	1.98;

1.98
date	97.07.23.14.09.51;	author johnh;	state Exp;
branches;
next	1.97;

1.97
date	97.07.18.13.45.47;	author johnh;	state Exp;
branches;
next	1.96;

1.96
date	97.06.18.08.28.05;	author johnh;	state Exp;
branches;
next	1.95;

1.95
date	97.06.17.16.20.04;	author johnh;	state Exp;
branches;
next	1.94;

1.94
date	97.06.13.10.50.23;	author johnh;	state Exp;
branches;
next	1.93;

1.93
date	97.05.20.15.57.33;	author johnh;	state Exp;
branches;
next	1.92;

1.92
date	97.05.16.15.36.29;	author johnh;	state Exp;
branches;
next	1.91;

1.91
date	97.03.26.09.32.51;	author johnh;	state Exp;
branches
	1.91.1.1;
next	1.90;

1.90
date	97.03.19.11.18.12;	author johnh;	state Exp;
branches;
next	1.89;

1.89
date	97.03.17.14.26.20;	author johnh;	state Exp;
branches;
next	1.88;

1.88
date	96.12.03.20.28.54;	author daveb;	state Exp;
branches
	1.88.1.1
	1.88.2.1
	1.88.3.1;
next	1.87;

1.87
date	96.12.03.19.02.41;	author daveb;	state Exp;
branches;
next	1.86;

1.86
date	96.12.03.17.41.14;	author daveb;	state Exp;
branches;
next	1.85;

1.85
date	96.11.22.12.12.42;	author daveb;	state Exp;
branches
	1.85.1.1;
next	1.84;

1.84
date	96.11.22.11.38.27;	author stephenb;	state Exp;
branches;
next	1.83;

1.83
date	96.11.21.13.00.13;	author jont;	state Exp;
branches;
next	1.82;

1.82
date	96.11.20.17.24.10;	author johnh;	state Exp;
branches;
next	1.81;

1.81
date	96.11.20.11.37.32;	author daveb;	state Exp;
branches;
next	1.80;

1.80
date	96.11.20.10.29.47;	author johnh;	state Exp;
branches;
next	1.79;

1.79
date	96.11.18.13.19.40;	author daveb;	state Exp;
branches;
next	1.78;

1.78
date	96.11.12.11.45.13;	author daveb;	state Exp;
branches
	1.78.1.1;
next	1.77;

1.77
date	96.11.06.11.18.09;	author matthew;	state Exp;
branches;
next	1.76;

1.76
date	96.11.01.14.55.31;	author johnh;	state Exp;
branches;
next	1.75;

1.75
date	96.10.31.10.55.48;	author johnh;	state Exp;
branches;
next	1.74;

1.74
date	96.10.30.20.13.39;	author io;	state Exp;
branches;
next	1.73;

1.73
date	96.10.30.20.02.35;	author io;	state Exp;
branches;
next	1.72;

1.72
date	96.10.02.11.00.35;	author johnh;	state Exp;
branches
	1.72.1.1
	1.72.2.1;
next	1.71;

1.71
date	96.10.02.10.22.35;	author johnh;	state Exp;
branches;
next	1.70;

1.70
date	96.09.23.14.43.05;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	96.09.19.13.03.48;	author johnh;	state Exp;
branches;
next	1.68;

1.68
date	96.09.19.12.41.22;	author johnh;	state Exp;
branches;
next	1.67;

1.67
date	96.09.19.12.09.38;	author johnh;	state Exp;
branches;
next	1.66;

1.66
date	96.08.07.12.24.29;	author daveb;	state Exp;
branches
	1.66.1.1;
next	1.65;

1.65
date	96.08.06.15.54.52;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	96.08.01.15.12.47;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	96.07.30.14.38.31;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	96.07.29.09.29.18;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	96.07.09.15.48.08;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	96.07.04.09.14.24;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	96.06.25.15.32.11;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	96.06.18.14.12.34;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	96.06.13.14.05.25;	author daveb;	state Exp;
branches;
next	1.56;

1.56
date	96.05.31.16.16.40;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	96.05.28.16.12.09;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	96.05.28.15.53.36;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	96.05.16.17.00.25;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	96.05.16.13.07.43;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	96.05.16.09.29.31;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	96.05.15.12.35.54;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	96.05.07.17.05.20;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	96.05.01.12.23.46;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	96.04.30.13.24.40;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	96.04.18.10.11.38;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	96.04.16.16.19.14;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	96.04.16.13.03.51;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	96.04.16.12.17.34;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	96.04.03.15.58.00;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	96.03.14.11.41.09;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	96.03.07.16.20.19;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	96.03.01.11.21.02;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	96.02.28.17.17.33;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	96.02.09.11.39.05;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	96.02.01.14.18.24;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	96.01.31.14.15.22;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	96.01.25.16.05.31;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	96.01.25.12.29.26;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	96.01.17.10.23.44;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	96.01.12.16.45.16;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	96.01.12.10.29.43;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	96.01.09.14.19.45;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	96.01.08.15.37.28;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	96.01.04.15.32.52;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	96.01.04.14.22.40;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	95.12.20.15.13.11;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	95.12.14.15.33.47;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	95.12.13.15.08.33;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	95.12.07.16.41.21;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	95.12.06.16.57.03;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	95.11.23.12.37.36;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	95.11.21.14.44.04;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.11.17.11.17.27;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	95.11.15.15.18.27;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.11.15.15.18.27;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	95.11.14.13.58.22;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	95.10.10.12.20.30;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	95.10.08.22.40.43;	author brianm;	state Exp;
branches;
next	1.12;

1.12
date	95.10.02.10.14.54;	author brianm;	state Exp;
branches;
next	1.11;

1.11
date	95.09.22.13.56.10;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	95.09.21.15.36.07;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.09.19.10.39.58;	author brianm;	state Exp;
branches;
next	1.8;

1.8
date	95.09.11.13.30.07;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.09.05.10.49.48;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.08.31.10.42.40;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.08.25.10.27.36;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.15.16.24.23;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.15.14.40.19;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.08.11.13.58.23;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.08.03.12.51.30;	author matthew;	state Exp;
branches;
next	;

1.66.1.1
date	96.09.13.11.20.10;	author hope;	state Exp;
branches;
next	;

1.72.1.1
date	96.10.07.16.10.05;	author hope;	state Exp;
branches;
next	;

1.72.2.1
date	96.10.17.11.28.29;	author hope;	state Exp;
branches;
next	;

1.78.1.1
date	96.11.14.12.54.10;	author hope;	state Exp;
branches
	1.78.1.1.1.1;
next	;

1.78.1.1.1.1
date	96.11.28.15.05.02;	author hope;	state Exp;
branches;
next	;

1.85.1.1
date	96.11.22.18.12.57;	author hope;	state Exp;
branches;
next	;

1.88.1.1
date	96.12.17.09.57.43;	author hope;	state Exp;
branches;
next	;

1.88.2.1
date	96.12.17.17.51.25;	author hope;	state Exp;
branches
	1.88.2.1.1.1;
next	;

1.88.2.1.1.1
date	97.02.24.11.41.57;	author hope;	state Exp;
branches;
next	;

1.88.3.1
date	96.12.18.09.45.41;	author hope;	state Exp;
branches;
next	1.88.3.2;

1.88.3.2
date	96.12.18.14.03.15;	author johnh;	state Exp;
branches;
next	;

1.91.1.1
date	97.05.12.10.38.11;	author hope;	state Exp;
branches
	1.91.1.1.1.1
	1.91.1.1.2.1
	1.91.1.1.3.1;
next	;

1.91.1.1.1.1
date	97.07.28.18.23.21;	author daveb;	state Exp;
branches;
next	1.91.1.1.1.2;

1.91.1.1.1.2
date	97.08.05.09.17.57;	author johnh;	state Exp;
branches;
next	1.91.1.1.1.3;

1.91.1.1.1.3
date	97.08.05.10.54.04;	author johnh;	state Exp;
branches
	1.91.1.1.1.3.1.1;
next	;

1.91.1.1.1.3.1.1
date	97.10.07.11.49.05;	author jkbrook;	state Exp;
branches;
next	;

1.91.1.1.2.1
date	97.09.08.17.16.44;	author daveb;	state Exp;
branches;
next	;

1.91.1.1.3.1
date	97.09.09.14.12.49;	author daveb;	state Exp;
branches;
next	;

1.100.1.1
date	97.09.10.19.28.55;	author brucem;	state Exp;
branches;
next	;

1.100.2.1
date	97.09.11.20.58.50;	author daveb;	state Exp;
branches;
next	1.100.2.2;

1.100.2.2
date	97.09.12.14.48.42;	author johnh;	state Exp;
branches;
next	1.100.2.3;

1.100.2.3
date	97.11.24.15.24.48;	author johnh;	state Exp;
branches;
next	1.100.2.4;

1.100.2.4
date	97.12.11.14.49.30;	author johnh;	state Exp;
branches;
next	1.100.2.5;

1.100.2.5
date	98.01.06.15.55.58;	author johnh;	state Exp;
branches;
next	1.100.2.6;

1.100.2.6
date	98.01.09.11.10.06;	author johnh;	state Exp;
branches;
next	;

1.129.1.1
date	99.04.01.17.59.19;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
MS Windows GUI
@


1.129
log
@[Bug #190512]
Modify handling of splash advert so that it has to be explicitly dismissed
@
text
@(*
 * $Log: _capi.sml,v $
 * Revision 1.128  1999/03/09  10:39:07  mitchell
 * [Bug #190512]
 * Add advert splash screen
 *
 * Revision 1.127  1998/08/20  16:08:43  jont
 * [Bug #70157]
 * Fix compiler warning
 *
 * Revision 1.126  1998/08/14  16:13:35  mitchell
 * [Bug #30479]
 * Fix up debugging information in set_insertion_position
 *
 * Revision 1.125  1998/07/30  13:07:12  johnh
 * [Bug #30455]
 * Add activateapp message handler for podium window.
 *
 * Revision 1.124  1998/07/23  14:41:35  johnh
 * [Bug #30451]
 * Implement SetBkMode and GetBkMode and fix timer text on splash screen.
 *
 * Revision 1.123  1998/07/17  15:00:10  jkbrook
 * [Bug #30436]
 * PERSONAL replaces FREE and STUDENT editions
 *
 * Revision 1.122  1998/07/15  11:26:02  jkbrook
 * [Bug #30435]
 * Remove license-prompting code
 *
 * Revision 1.121  1998/07/14  09:33:23  johnh
 * [Bug #50056]
 * Remove dummy window and live with windows obscuring toolbar.
 *
 * Revision 1.120  1998/07/09  12:35:00  johnh
 * [Bug #30400]
 * Fix returning to and from tty mode.
 *
 * Revision 1.119  1998/07/02  14:56:48  johnh
 * [Bug #30431]
 * Extend Capi to allow setting of window attributes.
 *
 * Revision 1.118  1998/06/24  14:29:09  johnh
 * [Bug #30433]
 * Use new splash screen - need to reposition time out label.
 *
 * Revision 1.117  1998/06/24  13:24:25  johnh
 * [Bug #30411]
 * Fix problems checking edition and setting time out of spalsh screen.
 *
 * Revision 1.116  1998/06/11  18:23:31  jkbrook
 * [Bug #30411]
 * Include Free edition
 *
 * Revision 1.115  1998/06/11  15:06:32  johnh
 * [Bug #30411]
 * Free edition splash screen changes.
 *
 * Revision 1.114  1998/06/01  10:34:52  johnh
 * [Bug #30369]
 * Make file selection dialog allow multiple selection.
 *
 * Revision 1.113  1998/04/01  15:05:16  jont
 * [Bug #70086]
 * WINDOWS becomes WINDOWS_GUI, Windows becomesd WindowsGui
 *
 * Revision 1.112  1998/03/31  17:52:30  johnh
 * [Bug #30346]
 * Add Capi.getNextWindowPos().
 *
 * Revision 1.111  1998/03/26  13:14:34  johnh
 * [Bug #50035]
 * Keyboard accelerators now platform specific.
 *
 * Revision 1.110  1998/02/20  11:38:07  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.109  1998/02/18  17:09:18  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 * Revision 1.108  1998/02/17  16:43:56  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.107  1998/01/27  15:28:54  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.106  1997/11/06  13:00:00  johnh
 * [Bug #30125]
 * Move implementation of send_message to Menus.
 *
 * Revision 1.105  1997/10/30  09:40:34  johnh
 * [Bug #30187]
 * Fix horizontal scrolling on Win95.
 *
 * Revision 1.104  1997/10/16  14:13:40  johnh
 * [Bug #30193]
 * Fix size of maximised podium for display on NT 3.51.
 *
 * Revision 1.103  1997/10/09  15:35:56  johnh
 * [Bug #30193]
 * Resize the maximised podium.
 *
 * Revision 1.102  1997/10/06  10:36:44  johnh
 * [Bug #30137]
 * Add make_messages_popup.
 *
 * Revision 1.101  1997/09/19  14:29:29  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.100.2.6  1998/01/09  11:10:06  johnh
 * [Bug #30071]
 * Add Capi.Callback.ValueChange
 *
 * Revision 1.100.2.5  1998/01/06  15:55:58  johnh
 * [Bug #30071]
 * Add command handler for an activate callback (for use in project properties about info).
 *
 * Revision 1.100.2.4  1997/12/11  14:49:30  johnh
 * [Bug #30071]
 * Change height of text boxes to cope with large fonts on NT 3.51.
 *
 * Revision 1.100.2.3  1997/11/24  15:24:48  johnh
 * [Bug #30071]
 * Generalise Windows.openFileDialog to take a description of Filter.
 *
 * Revision 1.100.2.2  1997/09/12  14:48:42  johnh
 * [Bug #30071]
 * Redesign Compilation Manager -> Project Workspace.
 *
 * Revision 1.100  1997/09/05  15:00:35  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
 * Revision 1.99  1997/08/06  12:46:57  brucem
 * [Bug #30224]
 * Add function makeYesNo.
 *
 * Revision 1.98  1997/07/23  14:09:51  johnh
 * [Bug #30182]
 * Add delete handler.
 *
 * Revision 1.97  1997/07/18  13:45:47  johnh
 * [Bug #20074]
 * Improve license dialog.
 *
 * Revision 1.96  1997/06/18  08:28:05  johnh
 * [Bug #30181]
 * Tidy interrupt button code.
 *
 * Revision 1.95  1997/06/17  16:20:04  johnh
 * [Bug #30179]
 * Adding dummy function used in Motif.
 *
 * Revision 1.94  1997/06/13  10:50:23  johnh
 * [Bug #30175]
 * Add all windows to dynamic menu, except top level tools.
 *
 * Revision 1.93  1997/05/20  15:57:33  johnh
 * Removing interrupt button and putting it on the toolbar.
 *
 * Revision 1.92  1997/05/16  15:36:29  johnh
 * Implementing single menu bar on Windows.
 *
 * Revision 1.91  1997/03/26  09:32:51  johnh
 * [Bug #1992]
 * Removed the window (or context) menu to prevent user from using
 * the cut and paste operations from this menu in wrong situations.
 *
 * Revision 1.90  1997/03/19  11:18:12  johnh
 * [Bug #1981]
 * Moved list_select window to be always inside the desktop window.
 *
 * Revision 1.89  1997/03/17  14:26:20  johnh
 * [Bug #1954]
 * Added set_min_window_size.
 *
 * Revision 1.88  1996/12/03  20:28:54  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks, which was
 * causing erroneous behaviour (Dialog boxes use the WM_USER0 and WM_USER1
 * message values!).  The debugger_window and error_browser now call
 * set_close_callback instead.
 *
 * Revision 1.87  1996/12/03  19:02:41  daveb
 * Increased toplevel_width again; the previous increase wasn't enough for
 * the Compilation Manager.
 *
 * Revision 1.86  1996/12/03  17:41:14  daveb
 * Changed the labels of the license dialog to match those on Unix/in the
 * documentation.
 *
 * Revision 1.85  1996/11/22  12:12:42  daveb
 * Made the C getBitmap function reveal the window itself, and return a boolean
 * to indicate success or failure.
 *
 * Revision 1.84  1996/11/22  11:38:27  stephenb
 * [Bug #1461]
 * return_max: change to be tail recursive.  This is important
 * because this code is run during a stack overflow handler
 * to display the frames.
 *
 * Revision 1.83  1996/11/21  13:00:13  jont
 * [Bug #1799]
 * Modify check_insertion to truncate string if it would not fit at all
 * Reduce limits on edit control sizes
 *
 * Revision 1.82  1996/11/20  17:24:10  johnh
 * Removed the title bar from the splash screen.
 *
 * Revision 1.81  1996/11/20  11:37:32  daveb
 * Extended default width to allow for Help menu.
 *
 * Revision 1.80  1996/11/20  10:29:47  johnh
 * Rewrote license dialog so that tabbing was allowed within it.
 *
 * Revision 1.79  1996/11/18  13:19:40  daveb
 * Added splash screen.
 *
 * Revision 1.78  1996/11/12  11:45:13  daveb
 * Added license_prompt and license_complain.
 *
 * Revision 1.77  1996/11/06  11:18:09  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.76  1996/11/01  14:55:31  johnh
 * Enabling close from control box on top left of window.
 *
 * Revision 1.75  1996/10/31  10:55:48  johnh
 * Add interrupt button to Windows.
 *
 * Revision 1.74  1996/10/30  20:13:39  io
 * [Bug #1614]
 * sorting out a typo
 *
 * Revision 1.73  1996/10/30  20:02:35  io
 * moving String from toplevel
 *
 * Revision 1.72  1996/10/02  11:00:35  johnh
 * [Bug #1560]
 * Enable scrolling on edit controls.
 *
 * Revision 1.70  1996/09/23  14:43:05  matthew
 * Adding interrupt button feature
 *
 * Revision 1.69  1996/09/19  13:03:48  johnh
 * [Bug #1583]
 * passing has_controlling_tty to exit_mlworks instead of passing false.
 *
 * Revision 1.66  1996/08/07  12:24:29  daveb
 * [Bug #1517]
 * Added handler for WM_SYSCHAR to handle Alt-<key> combinations.
 *
 * Revision 1.65  1996/08/06  15:54:52  daveb
 * [Bug #1517]
 * Changed definition of Text.end_line to return the current position if it
 * is already at the end of a line.
 *
 * Revision 1.64  1996/08/01  15:12:47  daveb
 * Corrected definition of terminator.
 *
 * Revision 1.63  1996/07/30  14:38:31  jont
 * Provide a system dependent line terminator
 *
 * Revision 1.62  1996/07/29  09:29:18  daveb
 * [Bug #1478]
 * Made WM_CLOSE of top level tools and popups mimic the Motif behaviour.
 * Top level tools ignore it, and popups unmap themselves, sending a WM_USER0
 * message to simulate an Unmap callback.  This prevents users from  deleting
 * stack browsers or their parent windows in the middle of an evaluation.
 *
 * Revision 1.61  1996/07/09  15:48:08  daveb
 * [Bug #1260]
 * Changed the Capi layout datatype so that the PANED constructor takes the
 * layout info for its sub-panes.  This enables the Windows layout code to
 * calculate the minimum size of each window.
 *
 * Revision 1.60  1996/07/04  09:14:24  daveb
 * Bug 1378: The Windows menu needs to be cleared when entering or leaving the
 * GUI.  I've changed initialize_application to clear the list of main windows.
 *
 * Revision 1.59  1996/06/25  15:32:11  daveb
 * Added handlers around all calls to Capi.getStockObject.
 *
 * Revision 1.58  1996/06/18  14:12:34  daveb
 * Moved exception WindowSystemError to windows.sml.
 * Set font of text widgets to be ANSI_FIXED_FONT.
 * Set font of labels, etc. to be DEFAULT_GUI_FONT when defined, and ANSI_VAR_FONT
 * otherwise.
 *
 * Revision 1.57  1996/06/13  14:05:25  daveb
 * Made make_main_window ignore the parent argument, so that all top level
 * windows are independent.  This means that the podium may be brought to the
 * front by the user.  Added code to intercept minimize and restore actions,
 * so that minimizing the podium minimizes all other top-level windows.
 *
 * Revision 1.56  1996/05/31  16:16:40  daveb
 * Bug 1074: Capi.list_select now takes a function to be called on any key
 * press handled by the list widget itself.  In the listener, this pops the
 * completions widget down as if the key had been typed at the listener.
 *
 * Revision 1.55  1996/05/28  16:12:09  jont
 * Distinguish image saving from file saving and call appropriate rts function
 *
 * Revision 1.54  1996/05/28  15:53:36  matthew
 * Adding reset function
 *
 * Revision 1.53  1996/05/16  17:00:25  jont
 * Ensure WindowSystemError is defined before use
 *
 * Revision 1.52  1996/05/16  13:07:43  matthew
 * Set runtime exception
 *
 * Revision 1.51  1996/05/16  09:29:31  matthew
 * Adding something for set_highlight
 *
 * Revision 1.50  1996/05/15  12:35:54  matthew
 * set_pos sends a LBN_SELCHANGE message
 *
 * Revision 1.49  1996/05/07  17:05:20  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.48  1996/05/01  12:23:46  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.47  1996/04/30  13:24:40  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.46  1996/04/18  10:11:38  matthew
 * Adding start/stop graphics functions
 *
 * Revision 1.45  1996/04/16  16:19:14  matthew
 * Fixing problem with resizing
 *
 * Revision 1.44  1996/04/16  13:03:51  matthew
 * Adding more scrollbar functionality to graphics ports
 *
 * Revision 1.43  1996/04/16  12:17:34  matthew
 * Fixing set_message_widget function
 *
 * Revision 1.42  1996/04/03  15:58:00  matthew
 * Fixing some problems
 *
 * Revision 1.41  1996/03/14  11:41:09  matthew
 * Fixing a newline in a message.
 *
 * Revision 1.40  1996/03/07  16:20:19  matthew
 * Changes to Windows structure
 *
 * Revision 1.39  1996/03/01  11:21:02  matthew
 * Changes to Windows structure
 *
 * Revision 1.38  1996/02/28  17:17:33  matthew
 * Changes to Windows signature
 *
 * Revision 1.37  1996/02/09  11:39:05  daveb
 * Changed return type of make_scrolllist to a record, with an extra element
 * add_items.  Replaced set_bottom_pos with set_pos (which can be implemented
 * on windows).  Added add_items to the List structure.
 *
 * Revision 1.36  1996/02/01  14:18:24  matthew
 * Changing type of [set/get]_window_long
 *
 * Revision 1.35  1996/01/31  14:15:22  matthew
 * Changing representation of Widgets
 *
 * Revision 1.34  1996/01/25  16:05:31  matthew
 * Changing default height of graph panes
 *
 * Revision 1.33  1996/01/25  12:29:26  matthew
 * Trying to fix with_highlighting
 *
 * Revision 1.32  1996/01/17  10:23:44  matthew
 * Send WM_LIMITTEXT to edit windows.
 *
 * Revision 1.31  1996/01/12  16:45:16  matthew
 * Adding insertion checks for the benefit of Windows
 *
 * Revision 1.30  1996/01/12  10:29:43  daveb
 * Removed use of FileDialog structure, incorporating the definitions directly
 * in this file instead.
 *
 * Revision 1.29  1996/01/09  14:19:45  matthew
 * Moved list_select in from _gui_utils
 *
 * Revision 1.28  1996/01/08  15:37:28  matthew
 * Adding "exit" command for all windows -- used for accelerators.
 *
 * Revision 1.27  1996/01/04  15:32:52  matthew
 * Fixing bungle with previous fix
 *
 * Revision 1.26  1996/01/04  14:22:40  matthew
 * Fixing some bugs
 *
 * Revision 1.25  1995/12/20  15:13:11  matthew
 * Adding color functions
 *
 * Revision 1.24  1995/12/14  15:33:47  matthew
 * Changing message handling
 *
 * Revision 1.23  1995/12/13  15:08:33  daveb
 * FileDialog now includes a datatype that also needs to be included here.
 *
 * Revision 1.22  1995/12/07  16:41:21  matthew
 * Adding extra text functions
 *
 * Revision 1.21  1995/12/06  16:57:03  matthew
 * Adding clipboard functionality
 *
 * Revision 1.20  1995/11/23  12:37:36  matthew
 * Fixing slight bungle in make_scrolllist
 *
 * Revision 1.19  1995/11/21  14:44:04  matthew
 * More stuff
 *
 * Revision 1.18  1995/11/17  11:17:27  matthew
 * More stuff on command handlers
 *
 * Revision 1.16  1995/11/15  15:18:27  matthew
 * Adding (dummy) get_main_windows
 *
 * Revision 1.15  1995/11/14  13:58:22  matthew
 * Extending for graphics
 *
 * Revision 1.14  1995/10/10  12:20:30  nickb
 * Add Resize callback.
 *
 * Revision 1.13  1995/10/08  22:40:43  brianm
 * Adding mod. to make_graphics.
 *
 * Revision 1.12  1995/10/02  10:14:54  brianm
 * Adding dummy `with_graphics_port' functions and associated functions.
 *
 * Revision 1.11  1995/09/22  13:56:10  daveb
 * Added dummy Capi.Text.set_highlight function.
 *
 * Revision 1.10  1995/09/21  15:36:07  nickb
 * Make scroll bars on graphics ports optional.
 *
 * Revision 1.9  1995/09/19  10:39:58  brianm
 * Updating by adding Capi Point/Region datatypes.
 *
 * Revision 1.8  1995/09/11  13:30:07  matthew
 * Changing top level window initialization
 *
 * Revision 1.7  1995/09/05  10:49:48  matthew
 * Changing use of word_to_int
 *
 * Revision 1.6  1995/08/31  10:42:40  matthew
 * Improving event handling
 *
 * Revision 1.5  1995/08/25  10:27:36  matthew
 * More stuff
 *
 * Revision 1.4  1995/08/15  16:24:23  matthew
 * More work
 *
 * Revision 1.3  1995/08/15  14:40:19  matthew
 * More stuff
 *
 * Revision 1.2  1995/08/11  13:58:23  matthew
 * Making it all work
 *
 * Revision 1.1  1995/08/03  12:51:30  matthew
 * new unit
 * MS Windows GUI
 *
 *)

require "^.utils.__terminal";
require "^.basis.__list";
require "^.basis.__string";
require "../basis/__int";

require "../basis/word";
require "../utils/lists";
require "../main/version";
require "../gui/menus";
require "windows_gui";
require "capitypes";
require "labelstrings";

require "../gui/capi";

functor Capi (structure Lists : LISTS
              structure WindowsGui : WINDOWS_GUI
              structure LabelStrings : LABELSTRINGS
              structure CapiTypes : CAPITYPES
              structure Menus : MENUS
	      structure Word32 : WORD
	      structure Version : VERSION

              sharing type LabelStrings.AcceleratorFlag = WindowsGui.accelerator_flag
	      sharing type Menus.Widget = CapiTypes.Widget
              sharing type CapiTypes.Hwnd = WindowsGui.hwnd
              sharing type WindowsGui.word = LabelStrings.word = Word32.word
                ): CAPI =
struct
  val do_debug = false
  fun debug s = if do_debug then Terminal.output (s() ^ "\n") else ()
  fun ddebug s = Terminal.output(s() ^ "\n")

  datatype Point = POINT of { x : int, y : int }

  datatype Region = REGION of { x : int, y :int, width : int, height :int }

  type Widget = CapiTypes.Widget
  type Font = unit

  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

  (* This exn can be raised when an inner event loop is terminated *)
  exception SubLoopTerminated
  exception WindowSystemError = WindowsGui.WindowSystemError

  exception Unimplemented of string
  fun N n = Int.toString n
  fun W w = "<word>"
  fun dummy s = debug (fn _ => s ^ " unimplemented")
  fun unimplemented s = (dummy s; raise Unimplemented s)

  fun max (x:int,y:int) = if x > y then x else y

(* evaluating: boolean reference set by listener and compilation manager 
 * and read by podium so that user cannot exit during compilation or 
 * computation - must interrupt it first. 
 *)
  val evaluating = ref false;

  (* This could be rather more efficient -- in particular, only do this if
   the line does contain newlines *)
    fun munge_string s =
      let
        fun munge ([],acc) = implode (rev acc)
          | munge (#"\013" :: #"\010" :: rest,acc) = munge (rest, #"\010" :: #"\013" :: acc)
          | munge (#"\n" ::rest,acc) = munge (rest, #"\010" :: #"\013" :: acc)
          | munge (c::rest,acc) = munge (rest,c::acc)
      in
        munge (explode s,[])
      end

(*
 Someone should do this efficiently! 
  fun strip_string_controls s =
    let
      fun aux c =
          if c < #" " then ""
          else c
    in
      implode (map aux (explode s))
    end
*)

  fun strip_string_controls (s:string):string =
    implode (List.filter (fn c=>not(c < #" ")) (explode s))


  (* The list of main windows provides the information for 
   * the Tools menu.  
   *)
  val main_windows : (CapiTypes.Widget * string) list ref = ref []

  fun push (a,r) = r := a :: !r
  
  fun delete (a,[]) = []
    | delete (a,((item as (a', _)) :: rest)) = 
      if a = a' then delete (a,rest) else item::delete (a,rest)

  fun add_main_window (w,title) = push ((w, title), main_windows)
  fun remove_main_window w = main_windows := delete (w,!main_windows)

  fun get_main_windows () = (!main_windows)

  (* List of text handlers *)
  val text_handlers = ref []

  fun restart () =
    (main_windows := [];
     text_handlers := [])

  datatype WidgetAttribute = 
      PanedMargin of bool
    | Position of    int * int
    | Size of        int * int
    | ReadOnly of    bool


  datatype WidgetClass = Frame | Graphics | Label | Button | Text | RowColumn | Paned | Form

  fun convert_class class =
    case class of
      Label => ("STATIC",[WindowsGui.SS_LEFT])
    | Button => ("BUTTON",[WindowsGui.BS_PUSHBUTTON])
    | Text => ("EDIT",[WindowsGui.WS_BORDER])
    | _ => ("Frame",[]) (* A class of my own devising *)

  val sendMessageNoResult = ignore o WindowsGui.sendMessage;

  fun set_text (window,s) =
    let
      val string_word = WindowsGui.makeCString (munge_string s)
    in
      sendMessageNoResult (CapiTypes.get_real window,WindowsGui.WM_SETTEXT,
                           WindowsGui.WPARAM (WindowsGui.nullWord),
                           WindowsGui.LPARAM string_word);
      WindowsGui.free string_word
    end

  (* Needed on Motif so that menus on main_popups automatically created can be removed *)
  fun remove_menu widget = ()

  fun reveal window =
    (WindowsGui.showWindow (window,WindowsGui.SW_SHOWNORMAL);
     WindowsGui.updateWindow window)

  fun hide window =
    WindowsGui.showWindow (CapiTypes.get_real window,WindowsGui.SW_HIDE)

  datatype window_ex_style = 
    WS_EX_DLGMODALFRAME |
    WS_EX_STATICEDGE |
    WS_EX_WINDOWEDGE

  fun createWindowEx (details : 
    {ex_styles: window_ex_style list,
     class: string,
     name: string,
     x: int,
     y: int,
     width : int,
     height : int,
     parent: WindowsGui.hwnd,
     menu : WindowsGui.word,
     styles : WindowsGui.window_style list}) : WindowsGui.hwnd = 
       (MLWorks.Internal.Runtime.environment "win32 create window ex") details

  fun create_revealed args =
    let
      val window = WindowsGui.createWindow args
    in
      reveal window;
      window
    end

  fun convert_name (Label,name) = LabelStrings.get_label name
    | convert_name (Button,name) = LabelStrings.get_label name
    | convert_name (_,name) = LabelStrings.get_title name
  val default_width = 720
  val toplevel_width = default_width
  val toplevel_height = 100
  val graphics_height = 200

  val next_window = ref (0,0)

  fun class_height class =
    case class of
      Frame => 120
    | Graphics => 120
    | Label => 20
    | Button => 20
    | Text => 26
    | RowColumn => 30
    | Paned => 120
    | Form => 120

  structure Event = 
    struct
      type Modifier = int
      val meta_modifier = 0
      datatype Button = LEFT | RIGHT | OTHER
    end

  (* WINDOW PROCEDURES *)

  (* currently alt chars just make a beep *)
  fun despatch_text (window, char, alt_on) =
    let
      fun scan [] = false
        | scan ((window',handler)::rest) =
          if window = CapiTypes.get_real window'
            then handler (char,if alt_on then [Event.meta_modifier] else [])
          else scan rest
    in
      scan (!text_handlers)
    end

  fun set_text_font window =
    let
      val WindowsGui.OBJECT text_font =
	WindowsGui.getStockObject (WindowsGui.ANSI_VAR_FONT)   (* WindowsGui.ANSI_FIXED_FONT) *)
    in
      sendMessageNoResult
          (CapiTypes.get_real window,
           WindowsGui.WM_SETFONT,
           WindowsGui.WPARAM text_font,
           WindowsGui.LPARAM (WindowsGui.intToWord 1))
    end
    handle WindowsGui.WindowSystemError _ => ()

  fun set_gui_font window =
    let
      val WindowsGui.OBJECT gui_font =
	WindowsGui.getStockObject (WindowsGui.DEFAULT_GUI_FONT)
	handle
	  WindowsGui.WindowSystemError _ => 
	    WindowsGui.getStockObject (WindowsGui.ANSI_VAR_FONT)
    in
      sendMessageNoResult
          (CapiTypes.get_real window,
           WindowsGui.WM_SETFONT,
           WindowsGui.WPARAM gui_font,
           WindowsGui.LPARAM (WindowsGui.intToWord 1))
    end
    handle WindowsGui.WindowSystemError _ => ()

  fun class_postaction (window,class) =
    case class of
      Text =>
	(set_text_font window;
         set_text (window, ""))
    | Label => set_gui_font window
    | Button => set_gui_font window
    | _ => ()

  fun getStylesFromAttributes [] = []
    | getStylesFromAttributes ((ReadOnly true)::rest) = 
	WindowsGui.ES_READONLY :: getStylesFromAttributes(rest)
    | getStylesFromAttributes (another::rest) =
	getStylesFromAttributes(rest)

  fun getSize ((Size (w,h))::rest) = SOME (w,h)
    | getSize (notsize::rest) = getSize rest
    | getSize [] = NONE

  fun make_widget (name,class,parent,attributes) = 
    let
      val (class_name,styles) = convert_class class
      val class_styles = case class of
	     Text => [WindowsGui.WS_BORDER,
		      WindowsGui.ES_MULTILINE,
		      WindowsGui.ES_AUTOHSCROLL]
	   | _ => []
      val (width, height) = 
	getOpt (getSize attributes, (default_width, class_height class))
      val window =
        WindowsGui.createWindow {class = class_name,
                              name = convert_name (class,name),
                              width = width,
                              height = height,
                              parent = CapiTypes.get_real parent,
                              menu = WindowsGui.nullWord,
                              styles = [WindowsGui.WS_CHILD] @@ 
				       class_styles @@
				       styles @@
				       getStylesFromAttributes (attributes)}
      val widget = CapiTypes.REAL (window,parent)
    in
      class_postaction (widget,class);
      widget
    end

  fun make_managed_widget (name,class,parent,attributes) = 
    let
      val widget = make_widget (name, class, parent, attributes)
    in
      reveal (CapiTypes.get_real widget);
      widget
    end

  (* Utility functions for creating the main window of a tool *)

  (* Shouldn't be necessary as this should be done in initialize_application? *)
  (* But this is also used for (some) popups *)

  fun make_context_label parent =
    let
      val window = 
        WindowsGui.createWindow
        {class = "STATIC",
         name = "contextLabel",
         height = 20,
         width = default_width,
         parent = CapiTypes.get_real parent,
         menu = WindowsGui.nullWord,
         styles = [WindowsGui.WS_CHILD,WindowsGui.SS_CENTER]}
    in
      reveal window;
      CapiTypes.REAL (window,parent)
    end

  fun make_main_subwindows (parent,has_context_label) = 
    let
      val label_window =
        if has_context_label
          then SOME (make_context_label parent)
        else NONE
    in
      (parent,parent,label_window)
    end

  fun make_subwindow parent = parent

(* The 'visible' argument here is used to distinguish between times when the 
 * window is created but hidden and times when it is shown after being hidden.
 * An example is the debugger window which is created at the same time as the 
 * podium and without the 'visible' argument would become visible with the podium
 * instead of later when needed. *)
  fun min_child (owner, window, visible) = 
    WindowsGui.addMessageHandler(owner, WindowsGui.WM_SHOWWINDOW, 
      fn (WindowsGui.WPARAM w, WindowsGui.LPARAM l) => 
	(if (!visible) then 
	   if (w = WindowsGui.nullWord) then 
	     WindowsGui.showWindow(window, WindowsGui.SW_HIDE)
           else 
	     WindowsGui.showWindow(window, WindowsGui.SW_SHOW) 
	 else ();
	 NONE))

  fun getNextWindowPos () = 
    let 
      val (curX, curY) = !next_window
      val inc = 30
    in
      if (curX < (100 + inc * 6)) then
	next_window := (curX + inc, curY + inc)
      else
	next_window := (100, curY - inc * 6);
      (curX, curY)
    end

  (* This should eventually return a MainWindow *)
  fun initialize_application (name, title, has_controlling_tty) = 
    let
      val window = WindowsGui.mainInit ()
      val widget = CapiTypes.REAL (window,CapiTypes.NONE)

      val height = ref 0
      (* This function gets the desired height of a maximised podium so that the 
       * toolbar is only just visible on both NT3.51 and NT4.0 
       *)
      fun get_height window = 
	let
	  val _ = WindowsGui.setWindowPos (window, {x=0, y=0, height=200, width = 1000})
	  val (WindowsGui.RECT {bottom=c_height, ...}) = WindowsGui.getClientRect window
	in
	  height := 200 - (c_height - 28)
	end

      (* Motivation for needing this sizing reference:  The function get_height which 
       * is called by getminmax below, calls WindowsGui.setWindowPos which, as a side 
       * effect causes getminmax to be called.  There is a circular loop here in the 
       * function calls, and to ensure that (a) the new height can be calculated and 
       * set, and (b) that no infinite loop occurs, the sizing reference is used as 
       * below, so that, in effect, getminmax is not called from within itself.
       *)
      val sizing = ref false
      (* Sets the size when the podium is maximized *)
      fun getminmax window (_, WindowsGui.LPARAM addr) = 
	let
	  val (_, _, _, maxtrack) = WindowsGui.getMinMaxInfo addr
	  val desk = WindowsGui.getDesktopWindow()
	  val (WindowsGui.RECT {right=r, left=l, ...}) = WindowsGui.getWindowRect desk
	  fun p (xc, yc) = WindowsGui.POINT {x=xc, y=yc}
	in 
	  (* p(r+6, !height) sets the window size when it is maximised.
	   * The p(~4,~4) is the position of the window so that the 
	   * border is not visible when the window is maximised and the remaining
	   * arguments set the minimum and maximum tracking size of the window. *)
	  if (!height) = 0 then
	    if (!sizing) then () else 
	      (sizing := true;
	       get_height window;
	       ignore(WindowsGui.setMinMaxInfo (addr, p(r+6, !height), p(~4,~4), p(0,0), maxtrack));
	       sizing := false)
	  else 
	    (ignore(WindowsGui.setMinMaxInfo (addr, p(r+6, !height), p(~4,~4), p(0,0), maxtrack));
	     ());
	  
	  NONE
	end

    in
      next_window := (50, (!height) + 50);

      restart ();
      WindowsGui.addMessageHandler (window,WindowsGui.WM_DESTROY,
                                   fn _ => (WindowsGui.postQuitMessage 0;
                                            NONE));
      (* Ensure that close has the same effect as selecting the ML menu item
         Return SOME ... to indicate the message has been handled -- otherwise
         we also get the default action, which destroys the window
       *)
      WindowsGui.addMessageHandler (window,WindowsGui.WM_CLOSE,
              fn _ => (if not (!evaluating) then
			  Menus.exit_dialog (widget,widget,has_controlling_tty)
			else ();
                        SOME (WindowsGui.nullWord)));

      WindowsGui.addMessageHandler (window, WindowsGui.WM_GETMINMAXINFO, getminmax window);
      WindowsGui.addMessageHandler (window, WindowsGui.WM_ACTIVATEAPP, 
				    fn _ => (ignore(WindowsGui.setFocus window); NONE));

      (* Add an all-window command handler for "exit" action *)
      WindowsGui.addCommandHandler (WindowsGui.nullWindow,
                                   LabelStrings.get_action "exit",
              fn _ => (if not (!evaluating) then
			Menus.exit_dialog (widget,widget,has_controlling_tty)
		       else ()  ));
      WindowsGui.setAcceleratorTable (WindowsGui.createAcceleratorTable (LabelStrings.accelerators));

      widget
    end

  (* For the moment, the shell is the same as the menubar window *)
  fun make_main_window {name, title, parent, contextLabel, winMenu, pos:int * int} = 
    let
      val window = 
        createWindowEx
        {ex_styles = [],
	 class = "Toplevel",
         name = LabelStrings.get_title name,
	 x = #1(pos),
	 y = #2(pos),
         height = toplevel_height,
         width = toplevel_width,
         parent = CapiTypes.get_real parent,
         menu = WindowsGui.nullWord,
         styles = [WindowsGui.WS_OVERLAPPED_WINDOW]}
      val widget = CapiTypes.REAL (window,parent)
      val label_window =
        if contextLabel
          then SOME (make_context_label widget)
        else NONE
    in
      set_text (widget,title);

      (* The windows contained in the tools menu do not need to be added to the 
       * dynamic list of windows, but other windows are created by this function,
       * so a distinction is needed.
       *)
      if winMenu then
	push ((widget, title), main_windows)
      else ();

      WindowsGui.addMessageHandler (window,WindowsGui.WM_DESTROY,
                                   fn _ => (remove_main_window widget;
					    NONE));
      (widget,widget,widget,label_window)
    end

  (* The same as above, but the shell isn't made visible *)
  fun make_main_popup {name, title, parent, contextLabel, visibleRef, pos: int * int} = 
    let
      val window = 
        createWindowEx
        {ex_styles = [],
	 class = "Toplevel",
         name = LabelStrings.get_title name,
	 x = #1(pos),
	 y = #2(pos),
         height = toplevel_height,
         width = toplevel_width,
         parent = CapiTypes.get_real parent, (* This will be the windows owner *)
         menu = WindowsGui.nullWord,
         styles = [WindowsGui.WS_OVERLAPPED_WINDOW]}
      val widget =CapiTypes.REAL (window,parent)
      val label_window =
        if contextLabel
          then SOME (make_context_label widget)
        else NONE
      val _ = WindowsGui.registerPopupWindow (window)
      fun destroy_handler _ =
        (WindowsGui.unregisterPopupWindow window;
         NONE)
    in
      min_child (CapiTypes.get_real parent, window, visibleRef);

      (* If the window is initially hidden (eg. stack browser) then don't 
       * add the window name to the windows menu - this will be done when 
       * is brought up.
       *)
      if (!visibleRef) then   
    	push ((widget, title), main_windows)
      else ();

      WindowsGui.addMessageHandler (window,WindowsGui.WM_DESTROY,destroy_handler);
      set_text (widget,title);
      (widget,widget,widget,label_window)
    end

  fun make_messages_popup (parent, visible) = 
    make_main_popup {name = "messages", 
		     title = "System Messages", 
		     parent = parent, 
		     contextLabel = false, 
		     visibleRef = visible,
		     pos = getNextWindowPos()}

  (* Register this to allow tabbing etc. *)
  fun make_popup_shell (name,parent,attributes,visible) =
    let
      val (width, height) = 
	getOpt(getSize attributes, (toplevel_width, toplevel_height))
      val window =
        WindowsGui.createWindow
        {class = "Toplevel",
         name = LabelStrings.get_title name,
         width = width,
         height = height,
         parent = CapiTypes.get_real parent, (* This will be the windows owner, it should be a top level window *)
         menu = WindowsGui.nullWord,
         styles = [WindowsGui.WS_OVERLAPPED_WINDOW(*,
                   WindowsGui.WS_POPUP,
                   WindowsGui.WS_CAPTION,
                   WindowsGui.WS_BORDER,
                   WindowsGui.WS_SYSMENU*)] @@
		  getStylesFromAttributes (attributes)}
      val _ = WindowsGui.registerPopupWindow (window)
      fun destroy_handler _ =
        (WindowsGui.unregisterPopupWindow window;
         NONE)
    in
      min_child (CapiTypes.get_real parent, window, visible);
      WindowsGui.addMessageHandler (window,WindowsGui.WM_DESTROY,destroy_handler);
      CapiTypes.REAL (window,parent)
    end

  fun make_toplevel_shell (name,title,parent,attributes) =
    let
      val (width, height) = 
	getOpt (getSize attributes, (toplevel_width, toplevel_height))
      val window =
        WindowsGui.createWindow
        {class = "Toplevel",
         name = LabelStrings.get_title name,
         width = width,
         height = height,
         parent = WindowsGui.nullWindow,
         menu = WindowsGui.nullWord,
         styles = [WindowsGui.WS_OVERLAPPED_WINDOW] @@
		  getStylesFromAttributes (attributes)}
      val widget =CapiTypes.REAL (window,CapiTypes.NONE)
    in
      set_text (widget,title);
      WindowsGui.showWindow (window,WindowsGui.SW_SHOW);
      WindowsGui.updateWindow window;
      widget
    end

  fun text_subclass window =
    let
      val ml_window_proc = WindowsGui.getMlWindowProc()
      val original_window_proc =
        WindowsGui.setWindowLong (window,
                               WindowsGui.GWL_WNDPROC,
                               ml_window_proc)

      fun char_handler (WindowsGui.WPARAM wparam,WindowsGui.LPARAM lparam) =
        if despatch_text
	     (window, String.str(chr (WindowsGui.wordToInt wparam)), false) then
	  SOME (WindowsGui.nullWord)
        else
          NONE

      fun syschar_handler (WindowsGui.WPARAM wparam,WindowsGui.LPARAM lparam) =
        if despatch_text
	     (window, String.str(chr (WindowsGui.wordToInt wparam)), true) then
	  SOME (WindowsGui.nullWord)
        else
          NONE
    in
      WindowsGui.addNewWindow (window,original_window_proc);
      (* Essential for the current mechanism to do this here *)
      (* Yet another thing to improve *)
      WindowsGui.addMessageHandler (window, WindowsGui.WM_CHAR, char_handler);
      WindowsGui.addMessageHandler (window, WindowsGui.WM_SYSCHAR, syschar_handler)
    end

  val scrolled_text_id = WindowsGui.newControlId ()
  fun make_scrolled_text (name,parent,attributes) =
    let
      val (width, height) =
	getOpt (getSize attributes, (default_width, 200))
      val window =
        create_revealed
        {class = "EDIT",
         name = LabelStrings.get_title name,
         width = width,
         height = height,
         parent = CapiTypes.get_real parent,
         menu = scrolled_text_id,
         styles = [WindowsGui.WS_CHILD,
                   WindowsGui.WS_BORDER,
                   WindowsGui.WS_HSCROLL,WindowsGui.WS_VSCROLL,
                   WindowsGui.ES_MULTILINE,
                   WindowsGui.ES_AUTOHSCROLL,WindowsGui.ES_AUTOVSCROLL] @@
		  getStylesFromAttributes (attributes)}
      (* What should we do here? *)
      (* The MAXTEXT event is only generated when the output has already failed *)
      (* perhaps we should check for running out of room before we do the output *)
      fun command_handler (hwnd,event) =
        if event = WindowsGui.wordToInt (WindowsGui.messageToWord (WindowsGui.EN_MAXTEXT))
          then Terminal.output("MAXTEXT received\n")
        else ()
      val widget = CapiTypes.REAL (window,parent)

      (* This function implements a fix for a bug on Windows 95 (request #30187).
       * WM_HSCROLL messages with SB_PAGELEFT or SB_PAGERIGHT set do not work
       * on Windows 95, so this function replaces them with WM_HSCROLL messages
       * with SB_THUMBPOSITION set including the calculated required position that
       * the scrollbar should be in.
       *)
      fun scrolling (WindowsGui.WPARAM w, WindowsGui.LPARAM l) = 
	let 
	  val scroll_value = WindowsGui.loword w
	  val sb_left = WindowsGui.convertSbValue (WindowsGui.SB_PAGELEFT)
	  val sb_right = WindowsGui.convertSbValue (WindowsGui.SB_PAGERIGHT)
	  val (ireturned, wsize, wmask, imin, imax, wpage, ipos, itrackpos) = 
	    WindowsGui.getScrollInfo (window, WindowsGui.SB_HORZ)
	  val w2i = WindowsGui.wordToInt
	  val (isize, imask, ipage) = (w2i wsize, w2i wmask, w2i wpage)
	  val pager = Int.min (imax, ipos + ipage - 1)
	  val pagel = Int.max (imin, ipos - ipage + 1)
	  val hi_word = Word32.fromInt (WindowsGui.convertSbValue WindowsGui.SB_THUMBPOSITION)
	  val lo_word_r = Word32.<< (Word32.fromInt pager, 0w16)
	  val lo_word_l = Word32.<< (Word32.fromInt pagel, 0w16)
	in
	  if scroll_value = sb_right then 
	    SOME (WindowsGui.sendMessage(window, WindowsGui.WM_HSCROLL, 
				 WindowsGui.WPARAM (Word32.+ (lo_word_r, hi_word)),
				 WindowsGui.LPARAM WindowsGui.nullWord))
	  else if scroll_value = sb_left then 
	      SOME (WindowsGui.sendMessage(window, WindowsGui.WM_HSCROLL, 
				       WindowsGui.WPARAM (Word32.+ (lo_word_l, hi_word)),
				       WindowsGui.LPARAM WindowsGui.nullWord))
	  else NONE
	end

    in
      set_text_font widget;
      set_text (widget,"");
      text_subclass window;
      WindowsGui.addCommandHandler (CapiTypes.get_real parent,scrolled_text_id,command_handler);

      (* This message handler prevents the window menu from being displayed and hence acts
       * as a workaround for bug #1992.  Ideally though the menu should be enabled and 
       * the illegal operations grayed out - use calls to TrackPopupMenu, GetSystemMenu,
       * and SetMenuItemInfo to achieve this. *)
      WindowsGui.addMessageHandler (window, WindowsGui.WM_CONTEXTMENU, 
	fn _ => SOME WindowsGui.nullWord);

      WindowsGui.addMessageHandler (window, WindowsGui.WM_HSCROLL, scrolling);   
      sendMessageNoResult (window,
                           WindowsGui.EM_LIMITTEXT,
                           WindowsGui.WPARAM WindowsGui.nullWord,
                           WindowsGui.LPARAM WindowsGui.nullWord);
      (widget,widget)
    end

(* This should be superseeded by WindowsGui.setMinMaxInfo *)
  fun set_min_window_size (widget, min_x, min_y) = 
    let 
      val min_window_size : WindowsGui.wparam * WindowsGui.lparam * int * int -> unit = 
	env "win32 min window size"
    in
      WindowsGui.addMessageHandler(CapiTypes.get_real widget, WindowsGui.WM_SIZING, 
	fn (wp, lp) => 
	  (min_window_size (wp, lp, min_x, min_y);
	   NONE))
    end

  fun make_scrolllist {parent, name, select_fn, action_fn, print_fn} =
    let
      val scrolllist_id = WindowsGui.newControlId ()
      val items_ref = ref []
      val window = 
        create_revealed
        {class = "LISTBOX",
         name = LabelStrings.get_title name,
         width = default_width,
         height = 150,
         parent = CapiTypes.get_real parent,
         menu = scrolllist_id,
         styles = [WindowsGui.WS_CHILD,WindowsGui.WS_BORDER,
                   WindowsGui.WS_VSCROLL,WindowsGui.WS_HSCROLL,
		   WindowsGui.LBS_NOTIFY, WindowsGui.LBS_NOINTEGRALHEIGHT]}
      val widget =CapiTypes.REAL (window,parent)



      local
        fun itemTextWidth (_, (itemIndex, maxWidth)) =
          let
            val w = WindowsGui.WPARAM (WindowsGui.intToWord itemIndex)
            val l = WindowsGui.LPARAM WindowsGui.nullWord
            val r = WindowsGui.sendMessage (window, WindowsGui.LB_GETTEXTLEN, w, l)
            val maxWidth' = max (WindowsGui.wordToInt r, maxWidth)
          in
            (itemIndex+1, maxWidth')
          end
      in

        fun itemsMaxTextWidth items = 
         let
           val (_, maxWidth) = List.foldl itemTextWidth (0, 0) items
         in
           maxWidth
         end
      end



      fun add_items opts items =
        ((Lists.iterate
         (fn item =>
          let
            val string = strip_string_controls (print_fn opts item)
            val string_word = WindowsGui.makeCString string
          in
            sendMessageNoResult (window,WindowsGui.LB_ADDSTRING,
                                 WindowsGui.WPARAM WindowsGui.nullWord,
                                 WindowsGui.LPARAM string_word);
            WindowsGui.free string_word
          end)
         items;
         items_ref := !items_ref @@ items);

	(* This let statement sets the horizontal extent to the value of
         * the maximum text length in the list box to enable horizontal
         * scrolling.
         *)
	let 
	   val i2w = WindowsGui.intToWord
	   (* Need this because LB_SETHORIZONTALEXTENT takes pixel values  *)
	   val charWidthInPixels = WindowsGui.loword(WindowsGui.getDialogBaseUnits())
           val maxTextWidth = itemsMaxTextWidth (!items_ref)
	in 
          if maxTextWidth > 0 then 
	    sendMessageNoResult
              (window,WindowsGui.LB_SETHORIZONTALEXTENT, 
               WindowsGui.WPARAM (i2w (maxTextWidth * charWidthInPixels)),
               WindowsGui.LPARAM WindowsGui.nullWord)
          else ()
	end)


      fun set_items opts items =
        (* Clear the list widget, and then reset *)
        (sendMessageNoResult (window,WindowsGui.LB_RESETCONTENT,
                              WindowsGui.WPARAM WindowsGui.nullWord,
                              WindowsGui.LPARAM WindowsGui.nullWord);
	 items_ref := [];
	 add_items opts items)

      val select_fn' = select_fn (widget,widget,set_items,add_items)
      val action_fn' = action_fn (widget,widget,set_items,add_items)

      fun select_handler (_,event) =
        if event = 1 (* MAGIC NUMBER = LBN_SELCHANGE *) then
          let
            val item =
              WindowsGui.wordToSignedInt
		(WindowsGui.sendMessage
		   (window,
		    WindowsGui.LB_GETCURSEL,
		    WindowsGui.WPARAM WindowsGui.nullWord,
                    WindowsGui.LPARAM WindowsGui.nullWord))
          in
            debug (fn _ => "Selection of " ^ N item ^ "\n");
            if item >= 0 then select_fn' (Lists.nth (item,!items_ref)) else ()
          end
        else if event = 2 (* MAGIC NUMBER = LBN_DBLCLK *) then
          let
            val item =
              WindowsGui.wordToSignedInt
		(WindowsGui.sendMessage
		   (window,
                    WindowsGui.LB_GETCURSEL,
                    WindowsGui.WPARAM WindowsGui.nullWord,
                    WindowsGui.LPARAM WindowsGui.nullWord))
          in
            debug (fn _ => "Double click of " ^ N item ^ "\n");
            if item >= 0 then action_fn' (Lists.nth (item,!items_ref)) else ()
          end
        else
          debug (fn _ => "Event " ^ N event ^ " received for list\n")
    in
      set_text_font widget;
      WindowsGui.addCommandHandler
	(CapiTypes.get_real parent,scrolllist_id,select_handler);
      {scroll=widget, list=widget, set_items=set_items, add_items=add_items}
    end

  fun make_file_selection_box (name,parent,attributes) =
    unimplemented "make_file_selection_box"

  (* Widget functions *)
  fun destroy window = WindowsGui.destroyWindow (CapiTypes.get_real window)

  fun initialize_toplevel window = reveal (CapiTypes.get_real window)
  fun initialize_application_shell shell = 
	WindowsGui.showWindow(CapiTypes.get_real shell, WindowsGui.SW_SHOWMAXIMIZED)

  (* When bringing a window to the front (eg. by selecting an item in the windows
   * menu), we want the window to be restored if it is minimized, so that it 
   * becomes visible *)
  fun to_front window = 
    let val (state, _, _, _) = WindowsGui.getWindowPlacement (CapiTypes.get_real window)
    in
      if state = 0 (* restored *) then 
	WindowsGui.showWindow (CapiTypes.get_real window, WindowsGui.SW_RESTORE)
      else if state = 1 (* minimized *) then 
	WindowsGui.showWindow (CapiTypes.get_real window, WindowsGui.SW_MINIMIZE)
      else (* = 2 which is maximized *)
	WindowsGui.showWindow (CapiTypes.get_real window, WindowsGui.SW_MAXIMIZE);
      WindowsGui.bringWindowToTop (CapiTypes.get_real window)
    end

  fun transfer_focus (from,to) =
    WindowsGui.addMessageHandler (CapiTypes.get_real from,WindowsGui.WM_SETFOCUS,
                                 fn _ => 
                                 (ignore(WindowsGui.setFocus (CapiTypes.get_real to));
                                  SOME WindowsGui.nullWord))

  fun set_sensitivity (widget,sensitivity) = ()

  (* set the label string of a label widget *)  
  fun set_label_string (label,s) =
    set_text (label,s)

  fun set_focus w = (ignore(WindowsGui.setFocus (CapiTypes.get_real w)); ())

  fun set_busy w = (ignore(WindowsGui.setCursor (WindowsGui.loadCursor WindowsGui.IDC_WAIT)); ())

  fun unset_busy w = (ignore(WindowsGui.setCursor (WindowsGui.loadCursor WindowsGui.IDC_ARROW)); ())

  fun widget_size widget = 
    let
      val WindowsGui.RECT {left,top,right,bottom} = WindowsGui.getWindowRect (CapiTypes.get_real widget)
    in
      (right-left,bottom-top)
    end

  fun widget_pos widget = 
    let
      val WindowsGui.RECT {left,top, ...} = WindowsGui.getWindowRect (CapiTypes.get_real widget)
    in
      (left, top)
    end

  val set_message_window : CapiTypes.Hwnd -> unit = env "nt set message widget"

  fun set_message_widget widget =
    set_message_window (CapiTypes.get_real widget)

  val no_message_widget : unit -> unit = env "nt no message widget"

  fun move_window (widget,x,y) = 
    let
      val (w,h) = widget_size widget
    in
      WindowsGui.moveWindow (CapiTypes.get_real widget,x,y,w,h,true)
    end

  fun size_window (widget, w, h) = 
   let
     val WindowsGui.RECT {left,top,right,bottom} = WindowsGui.getWindowRect (CapiTypes.get_real widget)
   in
     WindowsGui.moveWindow (CapiTypes.get_real widget, left, top, w, h, true)
   end

  fun init_size (window, sizeOpt) = 
    if isSome (sizeOpt) then 
      let val (w, h) = valOf(sizeOpt) 
      in 
	size_window (window, w, h)
      end
    else ()

  fun get_pointer_pos () =
    let
      val WindowsGui.POINT {x,y} = WindowsGui.getCursorPos ()
    in
      (x,y)
    end

  fun set_close_callback (shell, close_fun) = 
    WindowsGui.addMessageHandler(CapiTypes.get_real shell, WindowsGui.WM_CLOSE, 
	fn _ => (ignore(close_fun()); SOME (WindowsGui.nullWord)))

  fun event_loop continue = 
    (while (!continue) do 
       if WindowsGui.doInput ()
         then raise SubLoopTerminated
       else ();
     debug (fn _ => "sub loop exited\n"))

  fun main_loop () = WindowsGui.mainLoop ()


  datatype FileType = DIRECTORY | FILE

  (* The following windows functions return the empty string when they
     can't find a file.  We convert this to an option type.  *)

  fun open_file_dialog (parent, mask, multi) =
    let 
      val (ext, desc) = 
	case mask of 
	  ".sml" => ("sml", "SML files")
	| ".mo"  => ("mo", "MLWorks objects files")
	| ".mlp" => ("mlp", "MLWorks projects files")
	| "" 	 => ("*", "All files")
	| s	 => (s, "")

    in
      (case WindowsGui.openFileDialog (CapiTypes.get_real parent, desc, ext, multi) of
         [] => NONE
       | s => SOME s)
    end
  
  fun open_dir_dialog parent =
    (case WindowsGui.openDirDialog (CapiTypes.get_real parent)
     of "" => NONE
     |  s => SOME s)

  (* Can create a directory on Unix, but Win32 does not allow
   * a directory to be created.
   *)
  val set_dir_dialog = open_dir_dialog

  fun save_as_dialog (parent, mask) =
    case mask of
      ".sml" =>
	(case WindowsGui.saveDialog (CapiTypes.get_real parent, "SML files", "sml") of
	   "" => NONE
	 | s => SOME s)
    | ".img" =>
	(case WindowsGui.saveDialog (CapiTypes.get_real parent, "Image files", "img") of
	   "" => NONE
	 | s => SOME s)
    | ".mlp" =>
	(case WindowsGui.saveDialog (CapiTypes.get_real parent, "MLW project files", "mlp") of
	   "" => NONE
	 | s => SOME s)
    | _ =>
	(case WindowsGui.saveDialog (CapiTypes.get_real parent, "All files", "*") of
	   "" => NONE
	 | s => SOME s)

  val send_message = Menus.send_message

  fun makeYesNoCancel (parent, question, cancelButton) () =
    let 
      val yes = env "win32 yes id"
      val no = env "win32 no id"
      val cancel = env "win32 cancel id"
      val yesNoStyle = if cancelButton then WindowsGui.MB_YESNOCANCEL else WindowsGui.MB_YESNO
      val answer = WindowsGui.messageBox (CapiTypes.get_real parent, question, 
				       "MLWorks", yesNoStyle :: [WindowsGui.MB_APPLMODAL])
    in
      if answer = (env "win32 yes id") then SOME true
      else
	if answer = (env "win32 no id") then SOME false
	else NONE
    end

  fun find_dialog (parent, searchFn, spec) = 
    let 
      val real_parent = CapiTypes.get_real parent
      val {findStr, caseOpt, downOpt, wordOpt} = spec

      val dialogRef = ref WindowsGui.nullWindow
      val id_cancel : int = env "win32 cancel id"

      (* function searching is called when the user clicks
       * the Find Next button on the find dialog *)
      fun searching (_, WindowsGui.LPARAM addr) = 
	let 
	  val {searchStr, matchCase, searchDown, wholeWord, findNext, closing} = 
	    WindowsGui.getFindFlags addr
	in
	  if findNext then 
	    searchFn {searchStr=searchStr, 
		      matchCase=matchCase,
		      searchDown=searchDown,
		      wholeWord=wholeWord}
	  else ();
	  NONE
	end

    in
      WindowsGui.addMessageHandler(real_parent, WindowsGui.FINDMSGSTRING, searching);

      fn () => 
	(if ((!dialogRef) = WindowsGui.nullWindow) then 
	   (dialogRef := WindowsGui.findDialog (real_parent,
					   findStr, caseOpt, downOpt, wordOpt);
	    WindowsGui.registerPopupWindow (!dialogRef);
	    WindowsGui.addCommandHandler(!dialogRef, WindowsGui.intToWord id_cancel, 
		fn _ => hide (CapiTypes.REAL(!dialogRef, parent)));
	    WindowsGui.addMessageHandler(!dialogRef, WindowsGui.WM_DESTROY,
		fn _ => (WindowsGui.unregisterPopupWindow(!dialogRef);
			dialogRef := WindowsGui.nullWindow;
			SOME (WindowsGui.nullWord))))
	 else ();
	 reveal (!dialogRef);
	 CapiTypes.REAL (!dialogRef, parent))
    end

  fun with_message (parent,message) f = 
    let
      val _ = set_busy parent
      fun reset () = unset_busy parent
      val result = f () 
        handle exn as SubLoopTerminated => raise exn
             | exn => (reset(); raise exn)
    in
      reset();
      result
    end

  fun beep widget = WindowsGui.messageBeep WindowsGui.MB_OK

  structure Callback =
    struct
      datatype Type =
	Activate (* just used for processing return in text widgets *)
      | Destroy (* used a lot *)
      | Unmap (* not used in WindowsGui. *)
      | Resize (* WM_SIZE corresponds here *)
      | ValueChange

      fun print_callback c =
        case c of
          Activate => "Activate"
        | Destroy => "Destroy"
        | Unmap => "Unmap"
        | Resize => "Resize"
        | ValueChange => "ValueChange"

      fun convert_callback c =
        case c of
          Activate => NONE
        | Destroy => SOME WindowsGui.WM_DESTROY
        | Unmap => NONE
        | Resize => SOME WindowsGui.WM_SIZE
	| ValueChange => SOME WindowsGui.WM_CLOSE

      fun getParentIdPair CapiTypes.NONE = (WindowsGui.nullWindow, WindowsGui.nullWord)
	| getParentIdPair (CapiTypes.REAL (w, p)) = 
	    (CapiTypes.get_real p, WindowsGui.intToWord (WindowsGui.getDlgCtrlID w))
	| getParentIdPair (CapiTypes.FAKE _) = (WindowsGui.nullWindow, WindowsGui.nullWord)

      fun add (window,callback,handler) =
        case convert_callback callback of
          NONE => ()
	| SOME WindowsGui.WM_CLOSE => 
	    let val (p, win_id) = getParentIdPair window
	    in WindowsGui.addCommandHandler (p, win_id, fn _ => handler())
	    end
        | SOME message =>
            WindowsGui.addMessageHandler (CapiTypes.get_real window,message,
                                       fn _ => (handler (); NONE))
    end

  structure List =
    struct
      (* The capi, for historical reasons, numbers list items from 1 (yuk!) *)
      (* but windows numbers things from 0 *)
      fun get_selected_pos list = 
        let
          val result = 
            WindowsGui.wordToSignedInt (WindowsGui.sendMessage (CapiTypes.get_real list,
                                                          WindowsGui.LB_GETCURSEL,
                                                          WindowsGui.WPARAM WindowsGui.nullWord,
                                                          WindowsGui.LPARAM WindowsGui.nullWord))
        in
          if result >= 0
            then MLWorks.Internal.Vector.vector [result+1]
          else MLWorks.Internal.Vector.vector []
        end

      (* perhaps we should notice the notify parameter *)
      (* or it should be removed from the capi *)
      fun select_pos (list,pos,notify) = 
        let
          val hwnd = CapiTypes.get_real list
	  val id = WindowsGui.getDlgCtrlID hwnd
        in
          sendMessageNoResult (CapiTypes.get_real list,
                               WindowsGui.LB_SETCURSEL,
                               WindowsGui.WPARAM (WindowsGui.intToWord (pos-1)),
                               WindowsGui.LPARAM WindowsGui.nullWord);
          if not notify then ()
          else
            (debug (fn _ => "Notifying\n");
             sendMessageNoResult (WindowsGui.getParent (CapiTypes.get_real list),
                                  WindowsGui.WM_COMMAND,
                                  WindowsGui.WPARAM (WindowsGui.intToWord (256 * 256 * 1 + id)),
                                  WindowsGui.LPARAM (WindowsGui.windowToWord hwnd)))
        end

      (* "sets the item to be the first visible in the list widget" *)
      fun set_pos (list, pos) =
        sendMessageNoResult (CapiTypes.get_real list,
                             WindowsGui.LB_SETTOPINDEX,
                             WindowsGui.WPARAM (WindowsGui.intToWord (pos-1)),
                             WindowsGui.LPARAM WindowsGui.nullWord)
       
      fun add_items (list, items) =
        (Lists.iterate
           (fn item =>
              let
                val string = strip_string_controls item
                val string_word = WindowsGui.makeCString string
              in
                sendMessageNoResult   
	          (CapiTypes.get_real list,
	           WindowsGui.LB_ADDSTRING,
                   WindowsGui.WPARAM WindowsGui.nullWord,
                   WindowsGui.LPARAM string_word);
                WindowsGui.free string_word
              end)
            items;
	 ())
    end

  structure Text =
    struct

      fun add_del_handler (window, handler) = 
        let 
          val window' = CapiTypes.get_real window
          fun del_handler (WindowsGui.WPARAM w, WindowsGui.LPARAM l) = 
	    if ((WindowsGui.wordToInt w) = LabelStrings.VK_DELETE) then 
	      (ignore(handler()); SOME (WindowsGui.nullWord))
	    else
	      NONE
        in
          WindowsGui.addMessageHandler (window', WindowsGui.WM_KEYDOWN, del_handler)
        end

      fun text_size text =
        WindowsGui.wordToSignedInt (WindowsGui.sendMessage (CapiTypes.get_real text,
                                                      WindowsGui.WM_GETTEXTLENGTH,
                                                      WindowsGui.WPARAM WindowsGui.nullWord,
                                                      WindowsGui.LPARAM WindowsGui.nullWord))
      fun get_insertion_position text =
        let
          val res = WindowsGui.sendMessage (CapiTypes.get_real text,
                                         WindowsGui.EM_GETSEL,
                                         WindowsGui.WPARAM WindowsGui.nullWord,
                                         WindowsGui.LPARAM WindowsGui.nullWord)
        in
          WindowsGui.hiword res
        end

      fun set_selection (text,pos1,pos2) =
        (debug (fn _ => "set_selection " ^ N pos1 ^ ", " ^ N pos2);
         sendMessageNoResult (CapiTypes.get_real text,
                              WindowsGui.EM_SETSEL,
                              WindowsGui.WPARAM (WindowsGui.intToWord pos1),
                              WindowsGui.LPARAM (WindowsGui.intToWord pos2)))

      fun set_insertion_position (text,pos) =
        (set_selection (text,pos,pos);
         let
           val p = get_insertion_position text
         in
           if p = pos then () 
           else debug (fn _ => "Set insertion position has failed: " ^ N pos ^ " " ^ N p)
         end)

      fun insert (text,pos,str) =
        let
          val string_word = WindowsGui.makeCString (munge_string str)
        in
          set_insertion_position (text,pos);
          sendMessageNoResult (CapiTypes.get_real text,
                               WindowsGui.EM_REPLACESEL,
                               WindowsGui.WPARAM WindowsGui.nullWord,
                               WindowsGui.LPARAM string_word);
          WindowsGui.free string_word
        end

      fun replace (text,from,to,str) =
        let
          val string_word = WindowsGui.makeCString (munge_string str)
        in
          set_selection (text,from,to);
          sendMessageNoResult (CapiTypes.get_real text,
                               WindowsGui.EM_REPLACESEL,
                               WindowsGui.WPARAM WindowsGui.nullWord,
                               WindowsGui.LPARAM string_word);
          WindowsGui.free string_word
        end

      val get_last_position = text_size
      fun get_string text = 
        let
          val size = text_size text
          (* What happens if the text changes at this point? *)
          val buffer = WindowsGui.malloc (size+1) (* extra for null termination *)
          (* should check for malloc failure here *)
          val _ = WindowsGui.sendMessage (CapiTypes.get_real text,
                                       WindowsGui.WM_GETTEXT,
                                       WindowsGui.WPARAM (WindowsGui.intToWord (size+1)), (* add 1 for the last null character *)
                                        WindowsGui.LPARAM buffer)
          val _ = WindowsGui.setByte (buffer,size,0) (* null terminate *) (* probably not necessary *)
          val result = WindowsGui.wordToString buffer
        in
          WindowsGui.free buffer;
          result
        end

      fun substring (text,from,size) =
        MLWorks.String.substring (* could raise Substring *) (get_string text,from,size)

      fun set_string (text,s) = set_text (text,s)

      fun set_highlight (text, startpos, endpos, b) =
        if not b then ()
        else 
          let
            val hwnd = CapiTypes.get_real text
            val w = WindowsGui.intToWord startpos
          in
            sendMessageNoResult (hwnd,
                                 WindowsGui.EM_SETSEL,
                                 WindowsGui.WPARAM w,
                                 WindowsGui.LPARAM w);
            sendMessageNoResult (hwnd,
                                 WindowsGui.EM_SCROLLCARET,
                                 WindowsGui.WPARAM WindowsGui.nullWord,
                                 WindowsGui.LPARAM WindowsGui.nullWord)
          end

      fun get_selection text = 
        let
          val res = WindowsGui.sendMessage (CapiTypes.get_real text,
                                         WindowsGui.EM_GETSEL,
                                         WindowsGui.WPARAM WindowsGui.nullWord,
                                         WindowsGui.LPARAM WindowsGui.nullWord)
          val start = WindowsGui.loword res
          val finish = WindowsGui.hiword res
        in
          substring (text,start,finish-start)
        end

      fun remove_selection text = 
        let
          val string_word = WindowsGui.makeCString ""
        in
          sendMessageNoResult (CapiTypes.get_real text,
                               WindowsGui.EM_REPLACESEL,
                               WindowsGui.WPARAM WindowsGui.nullWord,
                               WindowsGui.LPARAM string_word);
          WindowsGui.free string_word
        end

      local
        fun lastline (str, ~1) = 0
          | lastline (str,n) =
            if MLWorks.String.ordof (str, n) = ord #"\n"
              then n+1
            else lastline (str,n-1)
      in
        (* Return the line containing pos, and the index of its first character *)
        fun get_line_and_index (text,pos) =
          let
            val str = get_string text
            val length = size str
              
            fun nextline n =
              if n = length orelse MLWorks.String.ordof (str, n) = ord #"\n" then
                n
              else
                nextline (n+1)
            val start = lastline (str,pos-1)
            val finish = nextline pos
            val result = MLWorks.String.substring (* could raise Substring *) (str, start, finish - start)
          in
            (result,pos - start)
          end
        
        (* Returns the index of the line containing pos *)
        fun current_line (text,pos) =
          lastline (get_string text,pos-1)
          
        (* Returns the index of the line after the line containing pos *)
        fun end_line (text,pos) =
          let
            val str = get_string text
            val length = size str
            fun aux n = 
              if n = length orelse MLWorks.String.ordof (str, n) = ord #"\n" then
                n
              else
                aux (n+1)
          in
	    if pos > length then pos else aux pos
          end
        
        val get_line = #1 o get_line_and_index
      end

      val convert_text = munge_string
      fun text_size s = size (munge_string s)

      (* Handlers *)
      fun add_handler (window,handler: string * Event.Modifier list -> bool) =
        text_handlers := (window,handler) :: !text_handlers

      (* The HOME, END, and cursor key actions are sufficient on Windows, and 
       * the functions defined in the Listener are not needed.  Using the Listener
       * also do not allow selections to be made by holding down the shift and
       * control keys.  If in the future, the Listener functions are needed, then 
       * they can be attached to the HOME, END, etc keys using the same method 
       * as in add_del_handler.
       *)
      fun get_key_bindings _ = []

      fun add_modify_verify _ = () (* dummy "add_modify_verify" *)
      (* nasty hack *)
      val read_only_before_prompt = true

      fun cut_selection text =
        (sendMessageNoResult (CapiTypes.get_real text,
                              WindowsGui.WM_CUT,
                              WindowsGui.WPARAM WindowsGui.nullWord,
                              WindowsGui.LPARAM WindowsGui.nullWord))

      fun paste_selection text =
        (sendMessageNoResult (CapiTypes.get_real text,
                              WindowsGui.WM_PASTE,
                              WindowsGui.WPARAM WindowsGui.nullWord,
                              WindowsGui.LPARAM WindowsGui.nullWord))

      fun copy_selection text =
        (sendMessageNoResult (CapiTypes.get_real text,
                              WindowsGui.WM_COPY,
                              WindowsGui.WPARAM WindowsGui.nullWord,
                              WindowsGui.LPARAM WindowsGui.nullWord))

      val delete_selection = remove_selection

      (* Can't handle text of more than 64K because set_insertion_position is limited to 16 bit positions *)
      val text_limit = 50000
      val text_chunk = 8000

      fun check_insertion(text, str, current, marks) =
        let
          val length = get_last_position text
	  val size = size str
	  val max = text_limit-text_chunk
        in
          if length + size < text_limit then
	    str
          else
	    if size >= max then
	      check_insertion(text, String.substring(str, size-max, max), current, marks)
	    else
	      let
		val reduction = if size > text_chunk then size else text_chunk
		val reduction = if reduction >= current then current else reduction
	      in
		sendMessageNoResult (CapiTypes.get_real text,
				     WindowsGui.WM_SETREDRAW,
				     WindowsGui.WPARAM (WindowsGui.intToWord 0),
				     WindowsGui.LPARAM WindowsGui.nullWord);
		replace (text,0,text_chunk,"");
		set_insertion_position (text,current-reduction);
		sendMessageNoResult (CapiTypes.get_real text,
				     WindowsGui.WM_SETREDRAW,
				     WindowsGui.WPARAM (WindowsGui.intToWord 1),
				     WindowsGui.LPARAM WindowsGui.nullWord);
		Lists.iterate (fn pos => pos := !pos - reduction) marks;
		str
	      end
        end
    end

  fun setAttribute (widget, attrib) =
    let
      val hwnd = CapiTypes.get_real widget

      fun changeStyle (window_style, toAdd) = 
	let 
	  val style_word = WindowsGui.convertStyle window_style
	  val cur_value = WindowsGui.getWindowLong (hwnd, WindowsGui.GWL_STYLE)
	  val new_value = 
	    if (toAdd) then 
	      Word32.orb (cur_value, style_word)
	    else
	      Word32.andb (cur_value, Word32.notb (style_word))
	in
	  WindowsGui.setWindowLong (hwnd, WindowsGui.GWL_STYLE, new_value)
	end
    in
      (* Setting the size and position of a control after it has been created 
       * does not work properly at present, probably due to the message handler
       * for WM_SIZE, which is set up in a call to Capi.Layout.laay_out.
       *)
      ignore(
	case attrib of
          Position (x,y) => move_window (widget, x, y)
        | Size (w,h)     => size_window (widget, w, h)
        | ReadOnly tf    => ignore(changeStyle (WindowsGui.ES_READONLY, tf))
	| PanedMargin m  => ())
    end

  structure Layout =
    struct
      datatype Class =
        MENUBAR of CapiTypes.Widget
      | FLEX of CapiTypes.Widget
      | FIXED of CapiTypes.Widget
      | FILEBOX of CapiTypes.Widget
      | PANED of CapiTypes.Widget * (CapiTypes.Widget * Class list) list
      | SPACE

      (* get the parent-relative position of a window *)
      fun widget_position window =
        let
          val window = CapiTypes.get_real window
          val WindowsGui.RECT {left,top,...} = WindowsGui.getWindowRect window
          val parent = WindowsGui.getParent window
        in
          if WindowsGui.isNullWindow parent
            then (left,top)
          else
            let
              val WindowsGui.POINT{x,y,...} = WindowsGui.screenToClient (parent,WindowsGui.POINT {x=left,y=top})
            in
              (x,y)
            end
        end

      fun enum_direct_children (w,f) =
        let
          val realw = CapiTypes.get_real w
          fun g subwindow =
            if not (WindowsGui.isNullWindow subwindow) andalso
              WindowsGui.getParent subwindow = realw (* only do this for direct subwindows *)
              then f (CapiTypes.REAL (subwindow,w))
            else ()
        in
          WindowsGui.enumChildWindows (realw,g)
        end
      
      fun count_direct_children w =
        let
          val count = ref 0
        in
          enum_direct_children (w, fn _ => count := 1 + !count);
          !count
        end

      (* This basically should arrange the given widgets in a column within *)
      (* their frame *)
      fun lay_out (parent, sizeOpt, children) =
        let
          fun do_one
	       (child, (maxwidth, y, min_height), (width, height)) =
            let
              val child = CapiTypes.get_real child
            in
              if not (WindowsGui.isNullWindow child) then
                (debug (fn _ => "do_one: " ^ N width ^ " " ^ N height ^ " " ^ N y);
                 WindowsGui.moveWindow (child, 0, y, width, height, true);
                 (max (width, maxwidth), y + height, min_height + height))
              else
		(maxwidth, y, min_height)
            end

	  fun do_all (w_list, (max_width, y, min_height)) =
            Lists.reducel
            (fn (a,MENUBAR w) => a (* Window deals with menubars itself *)
              | (a as (_, _, min_height), FLEX w) =>
		  let
		    val (maxwidth, y, _) = do_one (w,a,widget_size w)
		  in
		    (maxwidth, y, min_height + 10)
		  end
              | (a,FILEBOX w) => do_one (w,a,widget_size w)
              | (a,FIXED w) => do_one (w,a,widget_size w)
              | (a as (_, _, min_height), PANED (w, panes)) => 
		  let
		    (* First lay out each subwindow.  This includes setting
		       up a resize handler. *)
		    val _ = map lay_out (map (fn (w,p) => (w, NONE, p)) panes)

		    (* Now find the height, max_width, and min_height of w
		       by traversing the sub-specification (again). *)
		    val (max_width', y', min_height') =
		      Lists.reducel
		        (fn (a, (_, children)) =>
		           do_all (children, a))
		        ((0,0,0), panes)

		    val (maxwidth'', y'', _) =
		      do_one (w, a, (max_width', y'))
		  in
		    (maxwidth'', y'', min_height + min_height')
		  end
              | ((width,y,min_height),SPACE) =>
		(width, y, min_height))
            ((max_width, y, min_height), w_list)

          val (total_width, total_height, min_height) =
	    do_all (children, (0, 0, 0))

          val height_ref = ref total_height
          val (x,y) = widget_position parent
          val (w,h) = widget_size parent
          val WindowsGui.RECT {right=cright,bottom=cbottom,left=cleft,top=ctop} =
	    WindowsGui.getClientRect (CapiTypes.get_real parent)

          fun relayout (width,height) =
            let
              val delta = height - !height_ref (* amount to add on *)
              val _ = height_ref := height
              val yref = ref 0

              fun move_one (window,delta) =
                if WindowsGui.isNullWindow (CapiTypes.get_real window)
                  then ()
                else
                  let
                    val (_,h) = widget_size window
                    val newh = h + delta
                  in
                    WindowsGui.moveWindow(CapiTypes.get_real window,0,!yref,width,newh,true);
                    yref := !yref + newh
                  end

              fun do_one (MENUBAR window) = ()
                | do_one (FLEX window) =
                    move_one (window,delta)
                | do_one (FILEBOX window) = move_one (window,0)
                | do_one (FIXED window) = move_one (window,0)
                | do_one (PANED (window, _)) = 
                  let
                    val num_children = count_direct_children window
                  in
                    if num_children = 0
                      then ()
                    else
                      let
                        val yref = ref 0
                        val (_,h) = widget_size window
                        val subheight = (h + delta) div num_children
                        val first_height = h + delta - ((num_children - 1) * subheight)
                        val height_ref = ref first_height
                      in
                        enum_direct_children
                        (window,
                         fn subwindow =>
                         (WindowsGui.moveWindow (CapiTypes.get_real subwindow,0,!yref,width,!height_ref,true);
                          yref := !yref + !height_ref;
                          height_ref := subheight))
                      end;
                    move_one (window,delta)
                  end
                | do_one (SPACE) = ()
            in
              Lists.iterate do_one (children)
            end
        in
	  if isSome(sizeOpt) then
	    init_size(parent, sizeOpt)
	  else
            WindowsGui.moveWindow
	      (CapiTypes.get_real parent, x, y,
	       total_width + w - cright,
	       total_height + h - cbottom,
	       true);

	  (* This relayout needs to be done otherwise the Error Browser will not 
	   * appear properly until resized.  The reason is unknown but this bug
	   * only raised its ugly head due to the menubar being removed and hence
	   * no longer invokes a WM_SIZE being sent, and hence relayout is no
	   * longer called automatically and needs to be done explicitly here. *)
          relayout (total_width, total_height);

          (* only add the resize handler after the initial layout *)
          WindowsGui.addMessageHandler
	    (CapiTypes.get_real parent,
	     WindowsGui.WM_SIZE,
             fn (WindowsGui.WPARAM wparam, WindowsGui.LPARAM lparam) => 
               (if  WindowsGui.wordToInt wparam = 1 (* SIZE_MINIMIZED *) then
		  ()
                else
                  let
                    val width = WindowsGui.loword lparam
                    val height = WindowsGui.hiword lparam
                  in
		    if height < min_height then
		      ()
		    else
                      relayout (width, height)
                  end;
                SOME WindowsGui.nullWord))
        end
    end

  fun list_select (parent, name, _) =
    let
      val shell = make_popup_shell (name,parent, [], ref true)
      val form = make_subwindow shell
      exception ListSelect
      val select_fn_ref = ref (fn _ => raise ListSelect)
      val print_fn_ref = ref (fn _ => raise ListSelect)

      val exited = ref false;
      fun exit _ = if !exited then () else (destroy shell; exited := true)

      val {scroll, set_items, ...} =
        make_scrolllist
        {parent = form,
         name = "listSelect",
         select_fn = fn _ => fn x => (exit();(!select_fn_ref) x),
         action_fn = fn _ => fn _ => (),
         print_fn = fn _ => (!print_fn_ref)}

      val dialogButtons = make_managed_widget ("dialogButtons", RowColumn,form,[])
      val {update = buttons_updatefn, ...} = 
        Menus.make_buttons
        (dialogButtons,
         [Menus.PUSH ("cancel",
                      exit,
                      fn _ => true)])
      fun moveit () =
        let
          val width = 200
          val height = 221
          val (x,y) = get_pointer_pos ()
	  val desktopRect = WindowsGui.getWindowRect (WindowsGui.getDesktopWindow() )
	  fun get_list_rect () = WindowsGui.getWindowRect (CapiTypes.get_real shell)

	  (* shiftWindow moves the window to the new position and calls unobscureWindow
	   * so that all relevant sides of the window are checked against the desktop
	   * window.  *)
	  fun shiftWindow (hwnd, rect, desktop, new_x, new_y) = 
	    (WindowsGui.moveWindow (hwnd, new_x, new_y, width, height, true);
	     unobscureWindow (hwnd, get_list_rect(), desktop))

	  (* unobscureWindow checks three edges of the window against the desktop 
	   * window to ensure that the window is not outside the desktop window.
	   * The top edge is not checked against as the initial window position
	   * is below the cursor, and therefore the window will never be off the top
	   * of the screen *)
	  and unobscureWindow (hwnd,
		(rect as (WindowsGui.RECT {top=t, left=l, right=r, bottom=b})),
		(desktop as (WindowsGui.RECT {top=dt, left=dl, right=dr, bottom=db}))) =
	     if (l < dl) then 
	       shiftWindow (hwnd, rect, desktop, 0, t)
	     else if (r > dr) then 
	       shiftWindow (hwnd, rect, desktop, dr - width, t)
	     else if (b > db) then
	       shiftWindow (hwnd, rect, desktop, l, db - height)
	     else ()

        in
          (WindowsGui.moveWindow (CapiTypes.get_real shell,x-100,y+10,width,height,true);
	   unobscureWindow (CapiTypes.get_real shell, get_list_rect(), desktopRect))
        end

      fun popup (items,select_fn,print_fn) =
        (moveit ();
         select_fn_ref := select_fn;
         print_fn_ref := print_fn;
         set_items () items;
         reveal (CapiTypes.get_real form);
         exit)
        
    in
      Layout.lay_out
      (form, NONE,
       [Layout.FLEX scroll,
        Layout.SPACE,
        Layout.FIXED dialogButtons,
        Layout.SPACE]);
      popup
    end

  (* CLIPBOARD INTERFACE *)
  (* this just deals with text right now *)
  (* temporary hack *)

  fun clipboard_set (widget,s) = 
    let
      val window = CapiTypes.get_real widget
    in
      if WindowsGui.openClipboard (window)
        then
          (WindowsGui.emptyClipboard ();
           WindowsGui.setClipboardData s;
           WindowsGui.closeClipboard ())
      else Terminal.output("Can't open Clipboard\n")
    end

  fun clipboard_get (w,handler) =
    if WindowsGui.openClipboard (WindowsGui.nullWindow)
      then 
        let
          val result = WindowsGui.getClipboardData ()
          val _ = WindowsGui.closeClipboard ()
        in
          handler result
        end
      else 
        (Terminal.output("Can't open Clipboard\n");
         ())

  fun clipboard_empty widget =
    if WindowsGui.openClipboard (CapiTypes.get_real widget)
      then 
        let
          val result = WindowsGui.getClipboardData ()
          val _ = WindowsGui.closeClipboard ()
        in
          result = ""
        end
      else true

  local
    (* This duplicates code in _menus.sml *)

    (* some dimensions *)
    val x_margin = 4
    val y_margin = 4
    val item_height = 10
    val text_height = 12
    val item_sep = 4
    val item_width = 150
    val text_width = 75

    val yref = ref y_margin
    val namestr = ref ""
    val numstr = ref ""
    val continue = ref true

    datatype ItemTemplate =
      ITEMTEMPLATE of
      {styles: WindowsGui.window_style list,
       x: int,
       y: int,
       width: int,
       height: int,
       id : WindowsGui.word,
       class : string,
       text: string}

    datatype Template =
      TEMPLATE of
      {styles: WindowsGui.window_style list,
       x: int,
       y: int,
       width: int,
       height: int,
       title: string,
       items: ItemTemplate list,
       nitems: int}

    val create_dialog_indirect : Template * WindowsGui.hwnd -> WindowsGui.hwnd = 
	env "nt create dialog indirect"

    val name_id = WindowsGui.newControlId()
    val num_id = WindowsGui.newControlId()
    val continue_id = WindowsGui.newControlId() 

    fun make_label (string, label_width, down) = 
      let 
	val label_template = ITEMTEMPLATE
	  {styles = [WindowsGui.SS_LEFT,
                     WindowsGui.WS_CHILD,
                     WindowsGui.WS_VISIBLE],
           x = x_margin,
           y = !yref,
           width = label_width,
           height = item_height,
           class = "STATIC",
           text = string,
           id = WindowsGui.nullWord}
      in
	(if down then yref := !yref + item_height + item_sep else ();
	 label_template)
      end

    fun make_text text_id = 
      let 
	val text_template = ITEMTEMPLATE
          {styles = [WindowsGui.WS_CHILD,
                     WindowsGui.WS_TABSTOP,
                     WindowsGui.WS_BORDER,
                     WindowsGui.WS_VISIBLE,
		     WindowsGui.ES_AUTOHSCROLL],
           x = x_margin + text_width,
           y = !yref,
           width = text_width,
           height = text_height,
           class = "EDIT",
           text = "",
           id = text_id}
      in
	(yref := !yref + text_height + item_sep; 
	 text_template)
      end

    fun make_button (string, button_id) =  
      let 
        val template = ITEMTEMPLATE
          {styles = [WindowsGui.WS_CHILD,
		     WindowsGui.BS_DEFPUSHBUTTON,
                     WindowsGui.WS_TABSTOP,
                     WindowsGui.WS_VISIBLE],
           x = x_margin,
           y = !yref,
           width = item_width,
           height = item_height + 2,
           class = "BUTTON",
           text = string,
           id = button_id}
      in
	(yref := !yref + item_height + 2 + item_sep;
	 template)
      end


    fun license_error_message (parent,message) =
      let 
	val id_ok : int = env "win32 ok id"
        val full_message = (message^
                            "\nYou need to reinstall MLWorks\n\nClick OK to continue with a restricted\nsession of MLWorks or Cancel to exit")
                            
	fun show_message () = 
	  WindowsGui.messageBox (CapiTypes.get_real parent,full_message,"MLWorks",
                         [WindowsGui.MB_OKCANCEL,
                          WindowsGui.MB_APPLMODAL])
      in
        WindowsGui.messageBeep WindowsGui.MB_ICONEXCLAMATION;
        (* OK => continue as free, Cancel => Exit *)
	(if show_message() = id_ok then SOME false else NONE)
      end
  in
    fun license_complain parent message = license_error_message(parent, message)
  end

  local
    fun getBitmap args = 
        (MLWorks.Internal.Runtime.environment "win32 get splash bitmap") args
    fun paintBitmap dc = 
	(MLWorks.Internal.Runtime.environment "win32 paint splash bitmap") dc  

    val ref_show_splash = ref true;

    fun set_timer_text_font window =
      let
        val WindowsGui.OBJECT text_font =
	  WindowsGui.getStockObject (WindowsGui.ANSI_VAR_FONT)
      in
        sendMessageNoResult
          (window,
           WindowsGui.WM_SETFONT,
           WindowsGui.WPARAM text_font,
           WindowsGui.LPARAM (WindowsGui.intToWord 1))
      end
      handle WindowsGui.WindowSystemError _ => ()

    fun show_screen (parent, kind, duration) = 
      let 
	val desktop = WindowsGui.getDesktopWindow()
	val isFree = kind <> 0
	val countdown = ref duration

        val splash_window =
          createWindowEx
          {ex_styles = [WS_EX_DLGMODALFRAME],
	   class = "TopLevel",
           name = "",
	   x = 100,
	   y = 100,
           width = 506,
           height = 381,
           parent = WindowsGui.nullWindow,
           menu = WindowsGui.nullWord,
	   (* WS_POPUP style is needed to remove the title bar. *)
           styles = [WindowsGui.WS_POPUP,
                     WindowsGui.WS_BORDER,
		     WindowsGui.DS_MODALFRAME]}

	val _ = WindowsGui.centerWindow (splash_window, desktop)

        fun closedown () = (ref_show_splash := false; 
			  WindowsGui.destroyWindow splash_window);

	val s_dialog = CapiTypes.REAL (splash_window, parent)

	fun decrement_text () =
	  let 
	    val dc = WindowsGui.getDC splash_window
	    val _ = paintBitmap dc
	    val old_mode = WindowsGui.setBkMode(dc, WindowsGui.TRANSPARENT)
	  in
	    set_timer_text_font splash_window;
	    if (kind <> 2)
            then WindowsGui.textOut(dc, 350, 50, 
  		   "Time Left:  " ^ Int.toString (!countdown))
            else (* Skip timer for advert *) ();
	    ignore(WindowsGui.setBkMode(dc, old_mode))
	  end

        fun timercb () = 
	  if ((!countdown) = 1) then
	    closedown()
	  else
	    (countdown := (!countdown) - 1;
	     decrement_text())

	val splash_timer = WindowsGui.setTimer(splash_window, 1000, timercb);

	fun close_cb _ = (WindowsGui.killTimer(splash_window, splash_timer);
			  WindowsGui.destroyWindow splash_window;
			  ref_show_splash := false;
			  SOME (WindowsGui.nullWord))
	fun paint_cb _ = let val dc = WindowsGui.getDC splash_window
			in (ignore(paintBitmap dc); NONE)
			end
      in
	if getBitmap (splash_window, kind) then
	  (if kind = 1 then 
	     ()
	   else
	     (WindowsGui.addMessageHandler
		(splash_window, WindowsGui.WM_CLOSE, close_cb);
	      WindowsGui.addMessageHandler
		(splash_window, WindowsGui.WM_LBUTTONDOWN, close_cb));
	   decrement_text();
	   WindowsGui.addMessageHandler(splash_window, WindowsGui.WM_PAINT, paint_cb);
	   to_front s_dialog;
           event_loop ref_show_splash)
	else
	   if isFree then
	     (send_message (parent, "Splash screen bitmap not found.");
	      destroy parent)
	   else ()
      end
  in
    fun show_splash_screen parent = 
      let 
	val isFree = 
          let
            val edition = Version.edition()
          in
            edition = Version.PERSONAL 
          end

      in 
        if isFree
        then
          (show_screen (parent, 1, 5);
           ref_show_splash := true; 
           show_screen (parent, 2, 100))
        else
          show_screen (parent, 0, 5)
      end
  end

  structure GraphicsPorts =
    struct
      fun max (x:int,y) = if x > y then x else y
      fun min (x:int,y) = if x < y then x else y

      (* we should perhaps do something cleverer with the dc *)
      datatype GraphicsPort = 
        GP of {window: CapiTypes.Widget,
               dcref : WindowsGui.hdc option ref,
               name : string,
               title : string,
               x_offset: int ref,
               y_offset: int ref}

      exception BadDC

      fun gp_widget (GP {window,...}) = window
      fun gp_dc (GP {dcref = ref (SOME hdc),...}) = hdc
        | gp_dc (GP {dcref = ref (NONE),...}) = raise BadDC

      fun start_graphics (GP {window,dcref,...}) =
        case !dcref of
          SOME _ => ()
        | NONE =>
            let
              val dc = WindowsGui.getDC (CapiTypes.get_real window)
              (* Need to set the dc background to be the same as the windows *)
              val background = WindowsGui.getSysColor (WindowsGui.COLOR_WINDOW)
              val gui_font =
		WindowsGui.getStockObject (WindowsGui.DEFAULT_GUI_FONT)
	        handle
	          WindowsGui.WindowSystemError _ => 
	            WindowsGui.getStockObject (WindowsGui.ANSI_VAR_FONT)
            in
              ignore(WindowsGui.setBkColor (dc,background));
              ignore(WindowsGui.selectObject (dc,gui_font));
              dcref := SOME dc
            end
	    handle WindowsGui.WindowSystemError _ => ()

      fun stop_graphics (GP {window,dcref,...}) =
        case !dcref of
          NONE => ()
        | SOME dc =>
            (WindowsGui.releaseDC (CapiTypes.get_real window,dc);
             dcref := NONE)

      fun with_graphics gp f x =
         let
           val _ = start_graphics gp
           val result = f x handle exn => (stop_graphics gp; raise exn)
         in
           stop_graphics gp;
           result
         end

      (* currently no initialiazation *)
      fun initialize_gp _ = ()
      fun is_initialized _ = true
      exception UnInitialized

      fun get_offset (GP {x_offset,y_offset,...}) =
          POINT{x = !x_offset,y = !y_offset}
      fun set_offset (GP {x_offset,y_offset,...},POINT{x,y}) =
          (x_offset := max (x,0); y_offset:= max (y,0))

      (* We will try this by temporarily setting the text foreground and background colors *)
          
      fun with_highlighting (gp,f,a) = 
       let
          val dc = gp_dc gp
          val old_fg = WindowsGui.setTextColor (dc,WindowsGui.getBkColor dc);
          val old_bg = WindowsGui.setBkColor (dc,old_fg);
          fun undo _ = (ignore(WindowsGui.setTextColor (dc,old_fg));
                        WindowsGui.setBkColor (dc,old_bg))
          val result = f a handle exn => (ignore(undo ()); raise exn)
        in
          ignore(undo ());
          result
        end

      (* clip regions are unimplemented currently *)
      fun clear_clip_region (GP{...}) = () (* Unimplemented so far *)
      fun set_clip_region (GP {...},REGION{x,y,width,height}) = (* Unimplemented so far *)
        ()

      (* Erase the background, and redraw *)
      fun redisplay (gp as GP {window,...}) =
        with_graphics
        gp
        (fn () =>
         let
           val WindowsGui.HDC dcw = gp_dc gp
         in
           sendMessageNoResult (CapiTypes.get_real window,WindowsGui.WM_ERASEBKGND,
                                WindowsGui.WPARAM dcw,
                                WindowsGui.LPARAM WindowsGui.nullWord);
           sendMessageNoResult (CapiTypes.get_real window,WindowsGui.WM_PAINT,
                                WindowsGui.WPARAM WindowsGui.nullWord,
                                WindowsGui.LPARAM WindowsGui.nullWord)
         end)
        ()

      (* just redraw *)
      fun reexpose (GP {window,...}) =
        (WindowsGui.postMessage (CapiTypes.get_real window,WindowsGui.WM_PAINT,
                              WindowsGui.WPARAM WindowsGui.nullWord,
                              WindowsGui.LPARAM WindowsGui.nullWord);
         ())

      (* Useful for scrolling? *)
      (* This isn't currently used externally *)
      fun copy_gp_region (GP{...},GP{...},
                          REGION{x=x1,y=y1,width,height},POINT{x=x2,y=y2}) = 
        ()

      (* we store a dc for the each port -- could this be too expensive? *)
      (* We might run out of cached dcs also *)
       
      fun make_gp (name,title,widget) = 
          GP {window = widget,
              dcref = ref NONE,
              name = LabelStrings.get_title name,
              title = title,
              x_offset = ref 0,
              y_offset = ref 0}

      (* Windoze doesn't return quite the information X does *)
      (* Maybe we can do better *)
      fun text_extent (gp,string) =
        let
          val dc = gp_dc gp
          val (width,height) = WindowsGui.getTextExtentPoint (dc,string)
        in
          {ascent=0,
           descent=height,
           font_ascent=0,
           font_descent=height,
           lbearing=0,
           rbearing=0,
           width=width}
        end

      fun draw_line (gp,POINT{x,y},POINT{x=x',y=y'}) =
        let
          val GP {x_offset,y_offset,...} = gp
          val xo = !x_offset
          val yo = !y_offset
          val dc = gp_dc gp
        in
          WindowsGui.moveTo (dc,x-xo,y-yo,WindowsGui.nullWord);
          WindowsGui.lineTo (dc,x'-xo,y'-yo)
        end

      fun draw_point (gp,point) =
        draw_line (gp,point,point)

      fun draw_rectangle (gp,REGION{x,y,width,height}) =
        let
          val GP {x_offset,y_offset,...} = gp
          val xo = !x_offset
          val yo = !y_offset
          val dc = gp_dc gp
        in
          WindowsGui.moveTo (dc,x-xo,y-yo,WindowsGui.nullWord);
          WindowsGui.lineTo (dc,x+width-xo,y-yo);
          WindowsGui.lineTo (dc,x+width-xo,y+height-yo);
          WindowsGui.lineTo (dc,x-xo,y+height-yo);
          WindowsGui.lineTo (dc,x-xo,y-yo)
        end

      fun object_from_brush (WindowsGui.HBRUSH brush) =
        WindowsGui.OBJECT brush

      fun fill_rectangle (gp,region as REGION{x,y,width,height}) =
        let
          val dc = gp_dc gp
          val GP {x_offset,y_offset,...} = gp
          val xo = !x_offset
          val yo = !y_offset
          val brush = WindowsGui.createSolidBrush (WindowsGui.getSysColor (WindowsGui.COLOR_WINDOWTEXT))
        in
          WindowsGui.fillRect (dc,
                            WindowsGui.RECT {left = x-xo,
                                          top = y-yo,
                                          right = x+width-xo,
                                          bottom = y+height-yo},
                            brush);
          WindowsGui.deleteObject (object_from_brush brush)
        end

      fun clear_rectangle (gp,region as REGION{x,y,width,height}) =
        let
          val dc = gp_dc gp
          val GP {x_offset,y_offset,...} = gp
          val xo = !x_offset
          val yo = !y_offset
          val brush = WindowsGui.createSolidBrush (WindowsGui.getSysColor (WindowsGui.COLOR_WINDOW))
        in
          WindowsGui.fillRect (dc,
                            WindowsGui.RECT {left = x-xo,
                                          top = y-yo,
                                          right = x+width-xo,
                                          bottom = y+height-yo},
                            brush);
          WindowsGui.deleteObject (object_from_brush brush)
        end

      (* This should probably draw a filled rectangle in the appropriate place also *)
      fun draw_image_string (gp,string,POINT{x,y}) =
        let
          val dc = gp_dc gp
          val GP {x_offset,y_offset,...} = gp
          val xo = !x_offset
          val yo = !y_offset
        in
          WindowsGui.textOut (dc,x-xo,y-yo,string)
        end
        
      fun draw_arc (gp,REGION{x,y,width,height},theta1,theta2) = 
        () (* Currently unimplemented *)

      fun make_graphics (name,title,draw,get_extents,
                         (want_hscroll, want_vscroll), parent) =
        let  
          val styles =
            [WindowsGui.WS_CHILD,WindowsGui.WS_BORDER] @@
            (if want_hscroll then [WindowsGui.WS_HSCROLL] else []) @@
            (if want_vscroll then [WindowsGui.WS_VSCROLL] else [])
          val window =
            create_revealed {class = "Frame",
                             name = LabelStrings.get_title name,
                             width = default_width,
                             height = graphics_height,
                             parent = CapiTypes.get_real parent,
                             menu = WindowsGui.nullWord,
                             styles = styles}
          val widget = CapiTypes.REAL (window,parent)
          val gp = make_gp (name,title,widget)

          (* This (sort of) sets the scrollbar extents of the widget *)
          fun set_scrollbars () =
            let
              val (x,y) = get_extents ()
              val (w,h) = widget_size widget
            in
              (* This should change the position to be in the range, if necessary *)
              if want_hscroll
                then WindowsGui.setScrollRange (window,WindowsGui.SB_HORZ,0,max (0,x-w),true)
              else ();
              if want_vscroll
                then WindowsGui.setScrollRange (window,WindowsGui.SB_VERT,0,max (0,y-h),true)
              else ()
            end

          (* The handler for a WM_PAINT event *)
          fun draw_handler _ =
            (WindowsGui.validateRect (window,NONE);
             ignore(with_graphics gp draw (gp,REGION {x=0,y=0,width=1000,height=1000}));
             SOME WindowsGui.nullWord)

          (* increments for line up/down and line left/right *)
          val hinc = 20
          val vinc = 20

          (* page increments are the current width/height of the window *)

          fun getx () = #1 (widget_size widget)
          fun gety () = #2 (widget_size widget)

          (* two scroll handlers *)
          (* we ought to be able to use get_scroll_pos to find the position *)
          (* but this didn't seem to work *)
          fun vscroll_handler (WindowsGui.WPARAM wparam, WindowsGui.LPARAM lparam) =
            let
              val code = WindowsGui.loword wparam
              val GP {y_offset,...} = gp
              fun dochange pos =
                let
                  val pos = max (0, min (#2 (get_extents ()) - gety(), pos))
                in
                  WindowsGui.setScrollPos (window,WindowsGui.SB_VERT,pos,true);
                  y_offset := pos;
                  (* redraw the whole lot on scrolling *)
                  redisplay gp
                end
              (* line down shouldn't go past the scroll limit *)
              val _ = 
                if code = WindowsGui.convertSbValue WindowsGui.SB_THUMBPOSITION
                  then dochange (WindowsGui.hiword wparam)
                else if code = WindowsGui.convertSbValue WindowsGui.SB_LINEUP
                  then dochange (!y_offset - vinc)
                else if code = WindowsGui.convertSbValue WindowsGui.SB_LINEDOWN
                  then dochange (!y_offset + vinc)
                else if code = WindowsGui.convertSbValue WindowsGui.SB_PAGEUP
                  then dochange (!y_offset - gety ())
                else if code = WindowsGui.convertSbValue WindowsGui.SB_PAGEDOWN
                  then dochange (!y_offset + gety ())
                else ()
            in
              SOME WindowsGui.nullWord
            end

          fun hscroll_handler (WindowsGui.WPARAM wparam, WindowsGui.LPARAM lparam) =
            let
              val code = WindowsGui.loword wparam
              val GP {x_offset,...} = gp
              fun dochange pos =
                let
                  val pos = max (0, min (#1 (get_extents ()) - getx(), pos))
                in
                  WindowsGui.setScrollPos (window,WindowsGui.SB_HORZ,pos,true);
                  x_offset := pos;
                  (* redraw the whole lot on scrolling *)
                  redisplay gp
                end
              val _ = 
                if code = WindowsGui.convertSbValue WindowsGui.SB_THUMBPOSITION
                  then dochange (WindowsGui.hiword wparam)
                else if code = WindowsGui.convertSbValue WindowsGui.SB_LINELEFT 
                  then dochange (!x_offset - hinc)
                else if code = WindowsGui.convertSbValue WindowsGui.SB_LINERIGHT
                  then dochange (!x_offset + hinc)
                else if code = WindowsGui.convertSbValue WindowsGui.SB_PAGELEFT 
                  then dochange (!x_offset - getx())
                else if code = WindowsGui.convertSbValue WindowsGui.SB_PAGERIGHT
                  then dochange (!x_offset + getx())
                else ()
            in
              SOME WindowsGui.nullWord
            end

          (* But not do a redisplay *)
          fun set_position (POINT{x=xi',y=yi'}) = 
            let
              val POINT{x=cur_xi,y=cur_yi}  = get_offset gp

              val xi = if (xi' < 0) then cur_xi else xi'
              val yi = if (yi' < 0) then cur_yi else yi'

              val (ww,wh) = widget_size widget
              val (xextent,yextent) = get_extents()
              val new_xi = max (min (xi,xextent-ww),0)
              val new_yi = max (min (yi,yextent-wh),0)
            in
              if want_hscroll 
                then WindowsGui.setScrollPos (window,WindowsGui.SB_HORZ,new_xi,true) 
              else ();
              if want_vscroll 
                then WindowsGui.setScrollPos (window,WindowsGui.SB_VERT,new_yi,true) 
              else ();
              set_offset (gp,POINT{x=new_xi,y=new_yi});
              redisplay gp
            end

          fun resize_function data = 
            let
              val (ww,wh) = widget_size widget
              val (xextent,yextent) = get_extents()
              val POINT{x=xi,y=yi}  = get_offset gp
              val new_xi = max (min (xi,xextent-ww),0)
              val new_yi = max (min (yi,yextent-wh),0)
            in
              set_offset (gp,POINT{x=new_xi,y=new_yi});
              set_scrollbars ()
            end
        in
          WindowsGui.addMessageHandler (window,WindowsGui.WM_PAINT,draw_handler);
          if want_vscroll 
            then WindowsGui.addMessageHandler (window,WindowsGui.WM_VSCROLL,vscroll_handler) 
          else ();
          if want_hscroll 
            then WindowsGui.addMessageHandler (window,WindowsGui.WM_HSCROLL,hscroll_handler) 
          else ();
          WindowsGui.addMessageHandler (window,WindowsGui.WM_SIZE,
                                     fn _ => 
                                     (resize_function ();
                                      SOME WindowsGui.nullWord));
          set_scrollbars();
          (widget,
           gp,
           fn _ => (resize_function () ;redisplay gp),
           set_position)
        end

      (* the Point value is in gp coordinates *)
      fun add_input_handler (gp,handler) =
        let
          val GP {window,x_offset,y_offset,...} = gp
          val window = CapiTypes.get_real window
          fun mouse_handler button (WindowsGui.WPARAM wparam,WindowsGui.LPARAM lparam) =
            let
              val x = WindowsGui.loword lparam
              val y = WindowsGui.hiword lparam
            in
              ignore(handler (button,POINT {x=x + !x_offset,y=y + !y_offset}));
              SOME WindowsGui.nullWord
            end
        in
          WindowsGui.addMessageHandler (window,WindowsGui.WM_LBUTTONDOWN,mouse_handler (Event.LEFT));
          WindowsGui.addMessageHandler (window,WindowsGui.WM_RBUTTONDOWN,mouse_handler (Event.RIGHT))
        end          
          
      type PixMap = unit

      datatype LineStyle = LINESOLID | LINEONOFFDASH | LINEDOUBLEDASH	
      
      datatype Attribute =
         FONT of Font
      |  LINE_STYLE of LineStyle
      |  LINE_WIDTH of int  
      |  FOREGROUND of PixMap
      |  BACKGROUND of PixMap

      datatype Request =
         REQUEST_FONT
      |  REQUEST_LINE_STYLE
      |  REQUEST_LINE_WIDTH
      |  REQUEST_FOREGROUND
      |  REQUEST_BACKGROUND

      val getAttributes : GraphicsPort * Request list -> Attribute list =
	  fn(_,_) => (dummy "getAttributes"; [])

      val setAttributes : GraphicsPort * Attribute list -> unit =
          fn(_,_) => (dummy "setAttributes"; ())
 
      val with_graphics_port :(GraphicsPort * ('a -> 'b) * 'a) -> 'b =
          fn(_,f,a) => (dummy "with_graphics_port"; f(a))

    end

  fun parent CapiTypes.NONE = CapiTypes.NONE
    | parent (CapiTypes.REAL (_,p)) = p
    | parent (CapiTypes.FAKE (p,_)) = p

  val reveal = reveal o CapiTypes.get_real

  val terminator = "\r\n"

  (* dummy function - used only on Unix *)
  fun register_interrupt_widget w = ()

  fun with_window_updates f =
    let 
	fun toggle_updates tf = (MLWorks.Internal.Runtime.environment 
		"nt ml window updates toggle") tf
	val start_it = 	toggle_updates true
	val result = f () handle exn => (ignore(toggle_updates false); raise exn)
    in
       (ignore(toggle_updates false);
	result)
    end

end
@


1.129.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.129  1999/03/15  23:25:28  mitchell
 * [Bug #190512]
 * Modify handling of splash advert so that it has to be explicitly dismissed
 *
@


1.128
log
@[Bug #190512]
Add advert splash screen
@
text
@d3 4
d2415 4
a2418 2
	    WindowsGui.textOut(dc, 350, 50, 
		"Time Left:  " ^ Int.toString (!countdown));
d2440 1
a2440 1
	  (if isFree then 
d2472 1
a2472 1
           show_screen (parent, 2, 5))
@


1.127
log
@[Bug #70157]
Fix compiler warning
@
text
@d3 4
d2375 1
a2375 2
  in
    fun show_splash_screen parent = 
d2378 2
a2379 8
	val isFree = 
          let
            val edition = Version.edition()
          in
            edition = Version.PERSONAL 
          end

	val countdown = ref (if isFree then 10 else 5)
d2433 1
a2433 1
	if getBitmap (splash_window, isFree) then
d2450 19
@


1.126
log
@[Bug #30479]
Fix up debugging information in set_insertion_position
@
text
@d3 4
d900 1
a900 1
				    fn _ => (WindowsGui.setFocus window; NONE));
@


1.125
log
@[Bug #30455]
Add activateapp message handler for podium window.
@
text
@d3 4
d1667 1
a1667 1
           else Terminal.output("Set insertion position has failed: " ^ N pos ^ " " ^ N p ^ "\n")
@


1.124
log
@[Bug #30451]
Implement SetBkMode and GetBkMode and fix timer text on splash screen.
@
text
@d3 4
d891 2
@


1.123
log
@[Bug #30436]
PERSONAL replaces FREE and STUDENT editions
@
text
@d3 4
d2350 1
a2350 1
          (CapiTypes.get_real window,
a2387 13
	val timer_text = 
          createWindowEx
          {ex_styles = [],
	   class = "EDIT",
           name = "",
	   x = 350,
	   y = 50,
           width = 130,
           height = 26,
           parent = splash_window,
           menu = WindowsGui.nullWord,
           styles = [WindowsGui.WS_CHILD]}

d2394 10
a2403 2
	  set_text (CapiTypes.REAL (timer_text, CapiTypes.NONE), 
		       " Time Left:  " ^ Int.toString (!countdown))
a2420 2

        val timer_text_w = CapiTypes.REAL (timer_text, CapiTypes.NONE)
a2429 1
	   set_timer_text_font timer_text_w;
a2430 1
	   reveal timer_text;
@


1.122
log
@[Bug #30435]
Remove license-prompting code
@
text
@d3 4
d2361 1
a2361 1
            (edition = Version.STUDENT) orelse (edition = Version.FREE)
@


1.121
log
@[Bug #50056]
Remove dummy window and live with windows obscuring toolbar.
@
text
@d3 4
a2307 49
    val item_list = [make_label ("You must register your copy of MLWorks.", 175, true),
		     make_label ("License Name:", 75, false),
		     make_text name_id,
		     make_label ("License Code:", 75, false),
		     make_text num_id,
		     make_button ("Continue", continue_id)]

    val license_template = TEMPLATE
      {styles = [WindowsGui.WS_POPUP,
                 WindowsGui.WS_CAPTION,
                 WindowsGui.WS_SYSMENU,
                 WindowsGui.WS_VISIBLE],
        x = 40,
        y = 40,
        width = item_width + x_margin + x_margin + 2,
        height = !yref + y_margin + item_sep,
        title = "Licensing",
        items = item_list,
        nitems = length item_list}

    val text = ref CapiTypes.NONE

    fun copy _ =
      clipboard_set (!text,Text.get_selection (!text))
    fun paste _ =
      clipboard_get (!text,
			fn s =>
			Text.insert (!text,
				     Text.get_insertion_position (!text),
				     s))
    fun cut _ =
      let
        val s = Text.get_selection (!text)
      in
        Text.delete_selection (!text);
        clipboard_set (!text,s)
      end

    fun set_text_ref hwnd = 
      text := (CapiTypes.REAL (hwnd, CapiTypes.NONE))

    fun ok_callback dialog_wnd =
      (continue := false;
       namestr := Text.get_string (CapiTypes.REAL 
	 ((WindowsGui.getDlgItem (dialog_wnd, name_id)), CapiTypes.NONE));
       numstr := Text.get_string (CapiTypes.REAL 
	 ((WindowsGui.getDlgItem (dialog_wnd, num_id)), CapiTypes.NONE));
       WindowsGui.unregisterPopupWindow dialog_wnd;
       WindowsGui.destroyWindow dialog_wnd)
d2309 1
a2309 1
    fun retry_message (parent,message) =
d2311 4
a2314 1
	val id_retry : int = env "win32 retry id"
d2316 2
a2317 2
	  WindowsGui.messageBox (CapiTypes.get_real parent,message,"MLWorks",
                         [WindowsGui.MB_RETRYCANCEL,
d2321 2
a2322 1
	(show_message() = id_retry)
a2323 1

d2325 1
a2325 36
    fun license_prompt parent () = 
      let 
	val l_dialog = 
	  create_dialog_indirect (license_template, CapiTypes.get_real parent) 
        val cut_id = LabelStrings.get_action "cut"
        val paste_id = LabelStrings.get_action "paste"
        val copy_id = LabelStrings.get_action "copy"
	val real_parent = CapiTypes.get_real parent
      in 
	(WindowsGui.registerPopupWindow l_dialog;
	 continue := true;
	 Text.set_string (CapiTypes.REAL ((WindowsGui.getDlgItem (l_dialog, name_id)), 
					CapiTypes.NONE), !namestr);
	 Text.set_string (CapiTypes.REAL ((WindowsGui.getDlgItem (l_dialog, num_id)), 
					CapiTypes.NONE), !numstr);
	 WindowsGui.addCommandHandler(real_parent, cut_id, cut);
	 WindowsGui.addCommandHandler(real_parent, copy_id, copy);
	 WindowsGui.addCommandHandler(real_parent, paste_id, paste);
	 WindowsGui.addCommandHandler(l_dialog, name_id, 
	   fn _ => (set_text_ref (WindowsGui.getDlgItem(l_dialog, name_id))));
	 WindowsGui.addCommandHandler(l_dialog, num_id, 
	   fn _ => (set_text_ref (WindowsGui.getDlgItem(l_dialog, num_id))));

	 WindowsGui.addCommandHandler(l_dialog, continue_id,
           fn n => (sendMessageNoResult(l_dialog,
          	      WindowsGui.WM_CLOSE, WindowsGui.WPARAM WindowsGui.nullWord,
                      WindowsGui.LPARAM WindowsGui.nullWord)));
         WindowsGui.addMessageHandler
           (l_dialog, WindowsGui.WM_CLOSE, fn _ => (ok_callback l_dialog; 
						SOME (WindowsGui.nullWord)));
	 reveal l_dialog;
	 event_loop continue;
	 (!namestr, !numstr))
      end

    fun license_complain parent message = retry_message(parent, message)
@


1.120
log
@[Bug #30400]
Fix returning to and from tty mode.
@
text
@d3 4
d533 2
a534 11
  (* The list of main windows is used in two ways.  First, it provides
     the information for the Windows menus.  Second, when the podium
     is minimized, all the other main windows are minimized; and when
     the podium is restored, all main windows are restored to their
     previous state (unless they have been restored separately in
     the meantime.
   *)

  (* The min_max datatype is used to store the state of a main window.
     (I'm not sure that maximized windows can even be minimized by minimizing
     the podium, but this code checks it anyway).
d536 1
a536 3
  datatype min_max = MINIMIZED | MAXIMIZED | NORMAL

  val main_windows : (CapiTypes.Widget * min_max ref * string) list ref = ref []
d541 1
a541 1
    | delete (a,((item as (a', _, _)) :: rest)) = 
d544 1
a544 1
  fun add_main_window (w,title) = push ((w, ref NORMAL, title), main_windows)
d547 1
a547 16
(* This is used as the owner of all top level windows so that these windows can
 * be minimized and restored together while only using one icon on the task bar. *)
  val dummyWindow = ref NONE

  local
    open WindowsGui
    fun show_main_windows style = 
	(showWindow (valOf (!dummyWindow), style);
	 showWindow (valOf (!dummyWindow), SW_HIDE))
  in
    fun minimize_main_windows () = show_main_windows SW_MINIMIZE;
    fun restore_main_windows () = show_main_windows SW_RESTORE
  end

  fun get_main_windows _ =
    map (fn (w, _, s) => (w, s)) (!main_windows)
a777 6
(* Used to minimize (and restore again) windows which are owned by a window which 
 * is itself owned.  This is necessary otherwise this window will not be minimized
 * automatically when its grandparent is, even though its parent is correctly
 * minimized.  This provides the behaviour that if the grandparent is minimized, 
 * then so are its children and grandchildren. *)

a809 9
      val dummyWindow' = 
        WindowsGui.createWindow
        {class = "TopLevel",
         name = LabelStrings.get_title name,
         height = toplevel_height,
         width = toplevel_width,
         parent = WindowsGui.nullWindow,
         menu = WindowsGui.nullWord,
         styles = [WindowsGui.WS_OVERLAPPED_WINDOW]}
a858 2
      dummyWindow := SOME dummyWindow';
      WindowsGui.showWindow (valOf (!dummyWindow), WindowsGui.SW_HIDE);
a859 5
      (* The min_max value for the podium window is a dummy value, as
	 minimize/maximize events are always handled explicitly.  Using
	 MINIMIZED ensures that no spurious commands are issued for it
	 by minimize_main_windows or restore_main_WindowsGui.
       *)
d862 1
a862 2
                                   fn _ => (WindowsGui.destroyWindow dummyWindow';
					    WindowsGui.postQuitMessage 0;
a873 17
      (* Catch the minimize command, so that we can minimize all the other
	 top-level windows when the podium is minimized.
       *)
      WindowsGui.addMessageHandler
	(window, WindowsGui.WM_SYSCOMMAND,
         fn (WindowsGui.WPARAM sc_value, _) => 
	   if WindowsGui.wordToInt sc_value =
	      WindowsGui.convertScValue WindowsGui.SC_MINIMIZE then
	     (minimize_main_windows ();
	      NONE)
	   else if WindowsGui.wordToInt sc_value =
	           WindowsGui.convertScValue WindowsGui.SC_RESTORE then
	     (restore_main_windows ();
	      NONE)
	   else
	     NONE);

d899 1
a899 1
         parent = valOf (!dummyWindow),
a906 1
      val min_max = ref NORMAL
d914 2
a915 2
      if winMenu then 
	push ((widget,min_max,title),main_windows) 
d917 1
a947 1
      val min_max = ref NORMAL
d955 2
a956 2
      if (!visibleRef) then 
	push ((widget,min_max,title),main_windows) 
d958 1
d967 1
a967 1
		     parent = CapiTypes.REAL (valOf(!dummyWindow), parent), 
@


1.119
log
@[Bug #30431]
Extend Capi to allow setting of window attributes.
@
text
@d3 4
d906 2
a907 1
                                   fn _ => (WindowsGui.postQuitMessage 0;
d915 1
a915 2
			  Menus.exit_dialog (widget,widget,has_controlling_tty, 
			  map (fn (w,_,_) => w) (!main_windows))
d942 2
a943 3
			Menus.exit_dialog (widget,widget,has_controlling_tty, 
				map (fn (w,_,_) => w) (!main_windows))
			else ()  ));
@


1.118
log
@[Bug #30433]
Use new splash screen - need to reposition time out label.
@
text
@d3 4
d574 6
a579 1
  datatype WidgetAttribute = PanedMargin of bool
d718 10
d731 7
d741 2
a742 2
                              width = default_width,
                              height = class_height class,
d745 4
a748 1
                              styles = [WindowsGui.WS_CHILD] @@ styles}
d757 1
a757 16
      val (class_name,styles) = convert_class class
      val class_styles = case class of
	     Text => [WindowsGui.WS_BORDER,
		      WindowsGui.ES_MULTILINE,
		      WindowsGui.ES_AUTOHSCROLL]
	   | _ => []
      val window =
        create_revealed {class = class_name,
                         name = convert_name (class,name),
                         width = default_width,
                         height = class_height class,
                         parent = CapiTypes.get_real parent,
                         menu = WindowsGui.nullWord,
                         styles = [WindowsGui.WS_CHILD] @@ class_styles @@ styles}
      val widget = CapiTypes.REAL (window,parent)

d759 1
a759 1
      class_postaction (widget,class);
d1034 2
d1040 2
a1041 2
         width = toplevel_width,
         height = toplevel_height,
d1048 2
a1049 1
                   WindowsGui.WS_SYSMENU*)]}
d1062 2
d1068 2
a1069 2
         width = toplevel_width,
         height = toplevel_height,
d1072 2
a1073 1
         styles = [WindowsGui.WS_OVERLAPPED_WINDOW]}
d1114 2
d1120 2
a1121 2
         width = default_width,
         height = 200,
d1128 2
a1129 1
                   WindowsGui.ES_AUTOHSCROLL,WindowsGui.ES_AUTOVSCROLL]}
a1191 23
  fun make_message_text (name,parent,attributes) =
    let
      val window =
        create_revealed
        {class = "EDIT",
         name = LabelStrings.get_title name,
         width = default_width,
         height = 200,
         parent = CapiTypes.get_real parent,
         menu = WindowsGui.nullWord,
         styles = [WindowsGui.WS_CHILD,
                   WindowsGui.WS_BORDER,
		   WindowsGui.WS_VSCROLL,
                   WindowsGui.ES_READONLY,
                   WindowsGui.ES_MULTILINE,
                   WindowsGui.ES_AUTOHSCROLL,WindowsGui.ES_AUTOVSCROLL]}
      val widget =CapiTypes.REAL (window,parent)
    in
      set_text_font widget;
      set_text (widget,"");
      (widget,widget)
    end

d1914 29
@


1.117
log
@[Bug #30411]
Fix problems checking edition and setting time out of spalsh screen.
@
text
@d3 4
d2476 2
a2477 2
           width = 504,
           height = 360,
d2492 2
a2493 2
	   x = 10,
	   y = 10,
@


1.116
log
@[Bug #30411]
Include Free edition
@
text
@d3 4
a2451 9
    val isFree = fn () => 
        let
          val edition = Version.edition()
        in
          (edition = Version.STUDENT) orelse (edition = Version.FREE)
        end


    val countdown = ref (if isFree() then 10 else 5)
d2456 8
d2524 2
a2525 2
	if getBitmap (splash_window, isFree()) then
	  (if isFree() then 
d2539 1
a2539 1
	   if isFree() then
@


1.115
log
@[Bug #30411]
Free edition splash screen changes.
@
text
@d3 4
d2448 7
a2454 1
    val isFree = fn () => (Version.editionStr = "Student")
@


1.114
log
@[Bug #30369]
Make file selection dialog allow multiple selection.
@
text
@d3 4
d428 1
d442 1
d2424 2
a2425 2
    fun getBitmap W = 
	(MLWorks.Internal.Runtime.environment "win32 get bitmap") W  
d2427 1
a2427 1
	(MLWorks.Internal.Runtime.environment "win32 paint bitmap") dc  
d2431 16
d2450 2
d2467 19
d2487 14
a2500 3
        fun timercb () = (ref_show_splash := false; 
			  WindowsGui.destroyWindow splash_window;());
	val splash_timer = WindowsGui.setTimer(splash_window, 5000, timercb);
d2508 2
d2511 11
a2521 4
	if getBitmap splash_window then
	  (WindowsGui.addMessageHandler(splash_window, WindowsGui.WM_CLOSE, close_cb);
	   WindowsGui.addMessageHandler
	     (splash_window, WindowsGui.WM_LBUTTONDOWN, close_cb);
d2526 4
a2529 1
	  ()
@


1.113
log
@[Bug #70086]
WINDOWS becomes WINDOWS_GUI, Windows becomesd WindowsGui
@
text
@d3 4
d1420 1
a1420 1
  fun open_file_dialog (parent, mask) =
d1429 1
d1431 3
a1433 3
      (case WindowsGui.openFileDialog (CapiTypes.get_real parent, desc, ext) of
         "" => NONE
       |  s => SOME s)
@


1.112
log
@[Bug #30346]
Add Capi.getNextWindowPos().
@
text
@d3 4
d421 1
a421 1
require "windows";
d428 1
a428 1
              structure Windows : WINDOWS
d434 1
a434 1
              sharing type LabelStrings.AcceleratorFlag = Windows.accelerator_flag
d436 2
a437 2
              sharing type CapiTypes.Hwnd = Windows.hwnd
              sharing type Windows.word = LabelStrings.word = Word32.word
d455 1
a455 1
  exception WindowSystemError = Windows.WindowSystemError
d529 1
a529 1
    open Windows
d554 3
a556 3
      Label => ("STATIC",[Windows.SS_LEFT])
    | Button => ("BUTTON",[Windows.BS_PUSHBUTTON])
    | Text => ("EDIT",[Windows.WS_BORDER])
d559 1
a559 1
  val sendMessageNoResult = ignore o Windows.sendMessage;
d563 1
a563 1
      val string_word = Windows.makeCString (munge_string s)
d565 4
a568 4
      sendMessageNoResult (CapiTypes.get_real window,Windows.WM_SETTEXT,
                           Windows.WPARAM (Windows.nullWord),
                           Windows.LPARAM string_word);
      Windows.free string_word
d575 2
a576 2
    (Windows.showWindow (window,Windows.SW_SHOWNORMAL);
     Windows.updateWindow window)
d579 1
a579 1
    Windows.showWindow (CapiTypes.get_real window,Windows.SW_HIDE)
d594 3
a596 3
     parent: Windows.hwnd,
     menu : Windows.word,
     styles : Windows.window_style list}) : Windows.hwnd = 
d601 1
a601 1
      val window = Windows.createWindow args
d651 2
a652 2
      val Windows.OBJECT text_font =
	Windows.getStockObject (Windows.ANSI_VAR_FONT)   (* Windows.ANSI_FIXED_FONT) *)
d656 3
a658 3
           Windows.WM_SETFONT,
           Windows.WPARAM text_font,
           Windows.LPARAM (Windows.intToWord 1))
d660 1
a660 1
    handle Windows.WindowSystemError _ => ()
d664 2
a665 2
      val Windows.OBJECT gui_font =
	Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
d667 2
a668 2
	  Windows.WindowSystemError _ => 
	    Windows.getStockObject (Windows.ANSI_VAR_FONT)
d672 3
a674 3
           Windows.WM_SETFONT,
           Windows.WPARAM gui_font,
           Windows.LPARAM (Windows.intToWord 1))
d676 1
a676 1
    handle Windows.WindowSystemError _ => ()
d691 1
a691 1
        Windows.createWindow {class = class_name,
d696 2
a697 2
                              menu = Windows.nullWord,
                              styles = [Windows.WS_CHILD] @@ styles}
d708 3
a710 3
	     Text => [Windows.WS_BORDER,
		      Windows.ES_MULTILINE,
		      Windows.ES_AUTOHSCROLL]
d718 2
a719 2
                         menu = Windows.nullWord,
                         styles = [Windows.WS_CHILD] @@ class_styles @@ styles}
d735 1
a735 1
        Windows.createWindow
d741 2
a742 2
         menu = Windows.nullWord,
         styles = [Windows.WS_CHILD,Windows.SS_CENTER]}
d772 2
a773 2
    Windows.addMessageHandler(owner, Windows.WM_SHOWWINDOW, 
      fn (Windows.WPARAM w, Windows.LPARAM l) => 
d775 2
a776 2
	   if (w = Windows.nullWord) then 
	     Windows.showWindow(window, Windows.SW_HIDE)
d778 1
a778 1
	     Windows.showWindow(window, Windows.SW_SHOW) 
d797 1
a797 1
      val window = Windows.mainInit ()
d799 1
a799 1
        Windows.createWindow
d804 3
a806 3
         parent = Windows.nullWindow,
         menu = Windows.nullWord,
         styles = [Windows.WS_OVERLAPPED_WINDOW]}
d815 2
a816 2
	  val _ = Windows.setWindowPos (window, {x=0, y=0, height=200, width = 1000})
	  val (Windows.RECT {bottom=c_height, ...}) = Windows.getClientRect window
d822 1
a822 1
       * is called by getminmax below, calls Windows.setWindowPos which, as a side 
d830 1
a830 1
      fun getminmax window (_, Windows.LPARAM addr) = 
d832 4
a835 4
	  val (_, _, _, maxtrack) = Windows.getMinMaxInfo addr
	  val desk = Windows.getDesktopWindow()
	  val (Windows.RECT {right=r, left=l, ...}) = Windows.getWindowRect desk
	  fun p (xc, yc) = Windows.POINT {x=xc, y=yc}
d845 1
a845 1
	       ignore(Windows.setMinMaxInfo (addr, p(r+6, !height), p(~4,~4), p(0,0), maxtrack));
d848 1
a848 1
	    (ignore(Windows.setMinMaxInfo (addr, p(r+6, !height), p(~4,~4), p(0,0), maxtrack));
d857 1
a857 1
      Windows.showWindow (valOf (!dummyWindow), Windows.SW_HIDE);
d862 1
a862 1
	 by minimize_main_windows or restore_main_windows.
d865 2
a866 2
      Windows.addMessageHandler (window,Windows.WM_DESTROY,
                                   fn _ => (Windows.postQuitMessage 0;
d872 1
a872 1
      Windows.addMessageHandler (window,Windows.WM_CLOSE,
d877 1
a877 1
                        SOME (Windows.nullWord)));
d882 5
a886 5
      Windows.addMessageHandler
	(window, Windows.WM_SYSCOMMAND,
         fn (Windows.WPARAM sc_value, _) => 
	   if Windows.wordToInt sc_value =
	      Windows.convertScValue Windows.SC_MINIMIZE then
d889 2
a890 2
	   else if Windows.wordToInt sc_value =
	           Windows.convertScValue Windows.SC_RESTORE then
d896 1
a896 1
      Windows.addMessageHandler (window, Windows.WM_GETMINMAXINFO, getminmax window);
d899 1
a899 1
      Windows.addCommandHandler (Windows.nullWindow,
d905 1
a905 1
      Windows.setAcceleratorTable (Windows.createAcceleratorTable (LabelStrings.accelerators));
d923 2
a924 2
         menu = Windows.nullWord,
         styles = [Windows.WS_OVERLAPPED_WINDOW]}
d941 1
a941 1
      Windows.addMessageHandler (window,Windows.WM_DESTROY,
d960 2
a961 2
         menu = Windows.nullWord,
         styles = [Windows.WS_OVERLAPPED_WINDOW]}
d967 1
a967 1
      val _ = Windows.registerPopupWindow (window)
d969 1
a969 1
        (Windows.unregisterPopupWindow window;
d982 1
a982 1
      Windows.addMessageHandler (window,Windows.WM_DESTROY,destroy_handler);
d999 1
a999 1
        Windows.createWindow
d1005 7
a1011 7
         menu = Windows.nullWord,
         styles = [Windows.WS_OVERLAPPED_WINDOW(*,
                   Windows.WS_POPUP,
                   Windows.WS_CAPTION,
                   Windows.WS_BORDER,
                   Windows.WS_SYSMENU*)]}
      val _ = Windows.registerPopupWindow (window)
d1013 1
a1013 1
        (Windows.unregisterPopupWindow window;
d1017 1
a1017 1
      Windows.addMessageHandler (window,Windows.WM_DESTROY,destroy_handler);
d1024 1
a1024 1
        Windows.createWindow
d1029 3
a1031 3
         parent = Windows.nullWindow,
         menu = Windows.nullWord,
         styles = [Windows.WS_OVERLAPPED_WINDOW]}
d1035 2
a1036 2
      Windows.showWindow (window,Windows.SW_SHOW);
      Windows.updateWindow window;
d1042 1
a1042 1
      val ml_window_proc = Windows.getMlWindowProc()
d1044 2
a1045 2
        Windows.setWindowLong (window,
                               Windows.GWL_WNDPROC,
d1048 1
a1048 1
      fun char_handler (Windows.WPARAM wparam,Windows.LPARAM lparam) =
d1050 2
a1051 2
	     (window, String.str(chr (Windows.wordToInt wparam)), false) then
	  SOME (Windows.nullWord)
d1055 1
a1055 1
      fun syschar_handler (Windows.WPARAM wparam,Windows.LPARAM lparam) =
d1057 2
a1058 2
	     (window, String.str(chr (Windows.wordToInt wparam)), true) then
	  SOME (Windows.nullWord)
d1062 1
a1062 1
      Windows.addNewWindow (window,original_window_proc);
d1065 2
a1066 2
      Windows.addMessageHandler (window, Windows.WM_CHAR, char_handler);
      Windows.addMessageHandler (window, Windows.WM_SYSCHAR, syschar_handler)
d1069 1
a1069 1
  val scrolled_text_id = Windows.newControlId ()
d1080 5
a1084 5
         styles = [Windows.WS_CHILD,
                   Windows.WS_BORDER,
                   Windows.WS_HSCROLL,Windows.WS_VSCROLL,
                   Windows.ES_MULTILINE,
                   Windows.ES_AUTOHSCROLL,Windows.ES_AUTOVSCROLL]}
d1089 1
a1089 1
        if event = Windows.wordToInt (Windows.messageToWord (Windows.EN_MAXTEXT))
d1100 1
a1100 1
      fun scrolling (Windows.WPARAM w, Windows.LPARAM l) = 
d1102 3
a1104 3
	  val scroll_value = Windows.loword w
	  val sb_left = Windows.convertSbValue (Windows.SB_PAGELEFT)
	  val sb_right = Windows.convertSbValue (Windows.SB_PAGERIGHT)
d1106 2
a1107 2
	    Windows.getScrollInfo (window, Windows.SB_HORZ)
	  val w2i = Windows.wordToInt
d1111 1
a1111 1
	  val hi_word = Word32.fromInt (Windows.convertSbValue Windows.SB_THUMBPOSITION)
d1116 3
a1118 3
	    SOME (Windows.sendMessage(window, Windows.WM_HSCROLL, 
				 Windows.WPARAM (Word32.+ (lo_word_r, hi_word)),
				 Windows.LPARAM Windows.nullWord))
d1120 3
a1122 3
	      SOME (Windows.sendMessage(window, Windows.WM_HSCROLL, 
				       Windows.WPARAM (Word32.+ (lo_word_l, hi_word)),
				       Windows.LPARAM Windows.nullWord))
d1130 1
a1130 1
      Windows.addCommandHandler (CapiTypes.get_real parent,scrolled_text_id,command_handler);
d1136 2
a1137 2
      Windows.addMessageHandler (window, Windows.WM_CONTEXTMENU, 
	fn _ => SOME Windows.nullWord);
d1139 1
a1139 1
      Windows.addMessageHandler (window, Windows.WM_HSCROLL, scrolling);   
d1141 3
a1143 3
                           Windows.EM_LIMITTEXT,
                           Windows.WPARAM Windows.nullWord,
                           Windows.LPARAM Windows.nullWord);
d1156 7
a1162 7
         menu = Windows.nullWord,
         styles = [Windows.WS_CHILD,
                   Windows.WS_BORDER,
		   Windows.WS_VSCROLL,
                   Windows.ES_READONLY,
                   Windows.ES_MULTILINE,
                   Windows.ES_AUTOHSCROLL,Windows.ES_AUTOVSCROLL]}
d1170 1
a1170 1
(* This should be superseeded by Windows.setMinMaxInfo *)
d1173 1
a1173 1
      val min_window_size : Windows.wparam * Windows.lparam * int * int -> unit = 
d1176 1
a1176 1
      Windows.addMessageHandler(CapiTypes.get_real widget, Windows.WM_SIZING, 
d1184 1
a1184 1
      val scrolllist_id = Windows.newControlId ()
d1194 3
a1196 3
         styles = [Windows.WS_CHILD,Windows.WS_BORDER,
                   Windows.WS_VSCROLL,Windows.WS_HSCROLL,
		   Windows.LBS_NOTIFY, Windows.LBS_NOINTEGRALHEIGHT]}
d1204 4
a1207 4
            val w = Windows.WPARAM (Windows.intToWord itemIndex)
            val l = Windows.LPARAM Windows.nullWord
            val r = Windows.sendMessage (window, Windows.LB_GETTEXTLEN, w, l)
            val maxWidth' = max (Windows.wordToInt r, maxWidth)
d1228 1
a1228 1
            val string_word = Windows.makeCString string
d1230 4
a1233 4
            sendMessageNoResult (window,Windows.LB_ADDSTRING,
                                 Windows.WPARAM Windows.nullWord,
                                 Windows.LPARAM string_word);
            Windows.free string_word
d1243 1
a1243 1
	   val i2w = Windows.intToWord
d1245 1
a1245 1
	   val charWidthInPixels = Windows.loword(Windows.getDialogBaseUnits())
d1250 3
a1252 3
              (window,Windows.LB_SETHORIZONTALEXTENT, 
               Windows.WPARAM (i2w (maxTextWidth * charWidthInPixels)),
               Windows.LPARAM Windows.nullWord)
d1259 3
a1261 3
        (sendMessageNoResult (window,Windows.LB_RESETCONTENT,
                              Windows.WPARAM Windows.nullWord,
                              Windows.LPARAM Windows.nullWord);
d1272 2
a1273 2
              Windows.wordToSignedInt
		(Windows.sendMessage
d1275 3
a1277 3
		    Windows.LB_GETCURSEL,
		    Windows.WPARAM Windows.nullWord,
                    Windows.LPARAM Windows.nullWord))
d1285 2
a1286 2
              Windows.wordToSignedInt
		(Windows.sendMessage
d1288 3
a1290 3
                    Windows.LB_GETCURSEL,
                    Windows.WPARAM Windows.nullWord,
                    Windows.LPARAM Windows.nullWord))
d1299 1
a1299 1
      Windows.addCommandHandler
d1308 1
a1308 1
  fun destroy window = Windows.destroyWindow (CapiTypes.get_real window)
d1312 1
a1312 1
	Windows.showWindow(CapiTypes.get_real shell, Windows.SW_SHOWMAXIMIZED)
d1318 1
a1318 1
    let val (state, _, _, _) = Windows.getWindowPlacement (CapiTypes.get_real window)
d1321 1
a1321 1
	Windows.showWindow (CapiTypes.get_real window, Windows.SW_RESTORE)
d1323 1
a1323 1
	Windows.showWindow (CapiTypes.get_real window, Windows.SW_MINIMIZE)
d1325 2
a1326 2
	Windows.showWindow (CapiTypes.get_real window, Windows.SW_MAXIMIZE);
      Windows.bringWindowToTop (CapiTypes.get_real window)
d1330 1
a1330 1
    Windows.addMessageHandler (CapiTypes.get_real from,Windows.WM_SETFOCUS,
d1332 2
a1333 2
                                 (ignore(Windows.setFocus (CapiTypes.get_real to));
                                  SOME Windows.nullWord))
d1341 1
a1341 1
  fun set_focus w = (ignore(Windows.setFocus (CapiTypes.get_real w)); ())
d1343 1
a1343 1
  fun set_busy w = (ignore(Windows.setCursor (Windows.loadCursor Windows.IDC_WAIT)); ())
d1345 1
a1345 1
  fun unset_busy w = (ignore(Windows.setCursor (Windows.loadCursor Windows.IDC_ARROW)); ())
d1349 1
a1349 1
      val Windows.RECT {left,top,right,bottom} = Windows.getWindowRect (CapiTypes.get_real widget)
d1356 1
a1356 1
      val Windows.RECT {left,top, ...} = Windows.getWindowRect (CapiTypes.get_real widget)
d1372 1
a1372 1
      Windows.moveWindow (CapiTypes.get_real widget,x,y,w,h,true)
d1377 1
a1377 1
     val Windows.RECT {left,top,right,bottom} = Windows.getWindowRect (CapiTypes.get_real widget)
d1379 1
a1379 1
     Windows.moveWindow (CapiTypes.get_real widget, left, top, w, h, true)
d1392 1
a1392 1
      val Windows.POINT {x,y} = Windows.getCursorPos ()
d1398 2
a1399 2
    Windows.addMessageHandler(CapiTypes.get_real shell, Windows.WM_CLOSE, 
	fn _ => (ignore(close_fun()); SOME (Windows.nullWord)))
d1403 1
a1403 1
       if Windows.doInput ()
d1408 1
a1408 1
  fun main_loop () = Windows.mainLoop ()
d1426 1
a1426 1
      (case Windows.openFileDialog (CapiTypes.get_real parent, desc, ext) of
d1432 1
a1432 1
    (case Windows.openDirDialog (CapiTypes.get_real parent)
d1444 1
a1444 1
	(case Windows.saveDialog (CapiTypes.get_real parent, "SML files", "sml") of
d1448 1
a1448 1
	(case Windows.saveDialog (CapiTypes.get_real parent, "Image files", "img") of
d1452 1
a1452 1
	(case Windows.saveDialog (CapiTypes.get_real parent, "MLW project files", "mlp") of
d1456 1
a1456 1
	(case Windows.saveDialog (CapiTypes.get_real parent, "All files", "*") of
d1467 3
a1469 3
      val yesNoStyle = if cancelButton then Windows.MB_YESNOCANCEL else Windows.MB_YESNO
      val answer = Windows.messageBox (CapiTypes.get_real parent, question, 
				       "MLWorks", yesNoStyle :: [Windows.MB_APPLMODAL])
d1482 1
a1482 1
      val dialogRef = ref Windows.nullWindow
d1487 1
a1487 1
      fun searching (_, Windows.LPARAM addr) = 
d1490 1
a1490 1
	    Windows.getFindFlags addr
d1502 1
a1502 1
      Windows.addMessageHandler(real_parent, Windows.FINDMSGSTRING, searching);
d1505 2
a1506 2
	(if ((!dialogRef) = Windows.nullWindow) then 
	   (dialogRef := Windows.findDialog (real_parent,
d1508 2
a1509 2
	    Windows.registerPopupWindow (!dialogRef);
	    Windows.addCommandHandler(!dialogRef, Windows.intToWord id_cancel, 
d1511 4
a1514 4
	    Windows.addMessageHandler(!dialogRef, Windows.WM_DESTROY,
		fn _ => (Windows.unregisterPopupWindow(!dialogRef);
			dialogRef := Windows.nullWindow;
			SOME (Windows.nullWord))))
d1532 1
a1532 1
  fun beep widget = Windows.messageBeep Windows.MB_OK
d1539 1
a1539 1
      | Unmap (* not used in Windows. *)
d1554 1
a1554 1
        | Destroy => SOME Windows.WM_DESTROY
d1556 2
a1557 2
        | Resize => SOME Windows.WM_SIZE
	| ValueChange => SOME Windows.WM_CLOSE
d1559 1
a1559 1
      fun getParentIdPair CapiTypes.NONE = (Windows.nullWindow, Windows.nullWord)
d1561 2
a1562 2
	    (CapiTypes.get_real p, Windows.intToWord (Windows.getDlgCtrlID w))
	| getParentIdPair (CapiTypes.FAKE _) = (Windows.nullWindow, Windows.nullWord)
d1567 1
a1567 1
	| SOME Windows.WM_CLOSE => 
d1569 1
a1569 1
	    in Windows.addCommandHandler (p, win_id, fn _ => handler())
d1572 1
a1572 1
            Windows.addMessageHandler (CapiTypes.get_real window,message,
d1583 4
a1586 4
            Windows.wordToSignedInt (Windows.sendMessage (CapiTypes.get_real list,
                                                          Windows.LB_GETCURSEL,
                                                          Windows.WPARAM Windows.nullWord,
                                                          Windows.LPARAM Windows.nullWord))
d1598 1
a1598 1
	  val id = Windows.getDlgCtrlID hwnd
d1601 3
a1603 3
                               Windows.LB_SETCURSEL,
                               Windows.WPARAM (Windows.intToWord (pos-1)),
                               Windows.LPARAM Windows.nullWord);
d1607 4
a1610 4
             sendMessageNoResult (Windows.getParent (CapiTypes.get_real list),
                                  Windows.WM_COMMAND,
                                  Windows.WPARAM (Windows.intToWord (256 * 256 * 1 + id)),
                                  Windows.LPARAM (Windows.windowToWord hwnd)))
d1616 3
a1618 3
                             Windows.LB_SETTOPINDEX,
                             Windows.WPARAM (Windows.intToWord (pos-1)),
                             Windows.LPARAM Windows.nullWord)
d1625 1
a1625 1
                val string_word = Windows.makeCString string
d1629 4
a1632 4
	           Windows.LB_ADDSTRING,
                   Windows.WPARAM Windows.nullWord,
                   Windows.LPARAM string_word);
                Windows.free string_word
d1644 3
a1646 3
          fun del_handler (Windows.WPARAM w, Windows.LPARAM l) = 
	    if ((Windows.wordToInt w) = LabelStrings.VK_DELETE) then 
	      (ignore(handler()); SOME (Windows.nullWord))
d1650 1
a1650 1
          Windows.addMessageHandler (window', Windows.WM_KEYDOWN, del_handler)
d1654 4
a1657 4
        Windows.wordToSignedInt (Windows.sendMessage (CapiTypes.get_real text,
                                                      Windows.WM_GETTEXTLENGTH,
                                                      Windows.WPARAM Windows.nullWord,
                                                      Windows.LPARAM Windows.nullWord))
d1660 4
a1663 4
          val res = Windows.sendMessage (CapiTypes.get_real text,
                                         Windows.EM_GETSEL,
                                         Windows.WPARAM Windows.nullWord,
                                         Windows.LPARAM Windows.nullWord)
d1665 1
a1665 1
          Windows.hiword res
d1671 3
a1673 3
                              Windows.EM_SETSEL,
                              Windows.WPARAM (Windows.intToWord pos1),
                              Windows.LPARAM (Windows.intToWord pos2)))
d1686 1
a1686 1
          val string_word = Windows.makeCString (munge_string str)
d1690 4
a1693 4
                               Windows.EM_REPLACESEL,
                               Windows.WPARAM Windows.nullWord,
                               Windows.LPARAM string_word);
          Windows.free string_word
d1698 1
a1698 1
          val string_word = Windows.makeCString (munge_string str)
d1702 4
a1705 4
                               Windows.EM_REPLACESEL,
                               Windows.WPARAM Windows.nullWord,
                               Windows.LPARAM string_word);
          Windows.free string_word
d1713 1
a1713 1
          val buffer = Windows.malloc (size+1) (* extra for null termination *)
d1715 6
a1720 6
          val _ = Windows.sendMessage (CapiTypes.get_real text,
                                       Windows.WM_GETTEXT,
                                       Windows.WPARAM (Windows.intToWord (size+1)), (* add 1 for the last null character *)
                                        Windows.LPARAM buffer)
          val _ = Windows.setByte (buffer,size,0) (* null terminate *) (* probably not necessary *)
          val result = Windows.wordToString buffer
d1722 1
a1722 1
          Windows.free buffer;
d1736 1
a1736 1
            val w = Windows.intToWord startpos
d1739 3
a1741 3
                                 Windows.EM_SETSEL,
                                 Windows.WPARAM w,
                                 Windows.LPARAM w);
d1743 3
a1745 3
                                 Windows.EM_SCROLLCARET,
                                 Windows.WPARAM Windows.nullWord,
                                 Windows.LPARAM Windows.nullWord)
d1750 6
a1755 6
          val res = Windows.sendMessage (CapiTypes.get_real text,
                                         Windows.EM_GETSEL,
                                         Windows.WPARAM Windows.nullWord,
                                         Windows.LPARAM Windows.nullWord)
          val start = Windows.loword res
          val finish = Windows.hiword res
d1762 1
a1762 1
          val string_word = Windows.makeCString ""
d1765 4
a1768 4
                               Windows.EM_REPLACESEL,
                               Windows.WPARAM Windows.nullWord,
                               Windows.LPARAM string_word);
          Windows.free string_word
d1839 3
a1841 3
                              Windows.WM_CUT,
                              Windows.WPARAM Windows.nullWord,
                              Windows.LPARAM Windows.nullWord))
d1845 3
a1847 3
                              Windows.WM_PASTE,
                              Windows.WPARAM Windows.nullWord,
                              Windows.LPARAM Windows.nullWord))
d1851 3
a1853 3
                              Windows.WM_COPY,
                              Windows.WPARAM Windows.nullWord,
                              Windows.LPARAM Windows.nullWord))
d1878 3
a1880 3
				     Windows.WM_SETREDRAW,
				     Windows.WPARAM (Windows.intToWord 0),
				     Windows.LPARAM Windows.nullWord);
d1884 3
a1886 3
				     Windows.WM_SETREDRAW,
				     Windows.WPARAM (Windows.intToWord 1),
				     Windows.LPARAM Windows.nullWord);
d1907 2
a1908 2
          val Windows.RECT {left,top,...} = Windows.getWindowRect window
          val parent = Windows.getParent window
d1910 1
a1910 1
          if Windows.isNullWindow parent
d1914 1
a1914 1
              val Windows.POINT{x,y,...} = Windows.screenToClient (parent,Windows.POINT {x=left,y=top})
d1924 2
a1925 2
            if not (Windows.isNullWindow subwindow) andalso
              Windows.getParent subwindow = realw (* only do this for direct subwindows *)
d1929 1
a1929 1
          Windows.enumChildWindows (realw,g)
d1949 1
a1949 1
              if not (Windows.isNullWindow child) then
d1951 1
a1951 1
                 Windows.moveWindow (child, 0, y, width, height, true);
d1997 2
a1998 2
          val Windows.RECT {right=cright,bottom=cbottom,left=cleft,top=ctop} =
	    Windows.getClientRect (CapiTypes.get_real parent)
d2007 1
a2007 1
                if Windows.isNullWindow (CapiTypes.get_real window)
d2014 1
a2014 1
                    Windows.moveWindow(CapiTypes.get_real window,0,!yref,width,newh,true);
d2040 1
a2040 1
                         (Windows.moveWindow (CapiTypes.get_real subwindow,0,!yref,width,!height_ref,true);
d2054 1
a2054 1
            Windows.moveWindow
d2068 1
a2068 1
          Windows.addMessageHandler
d2070 3
a2072 3
	     Windows.WM_SIZE,
             fn (Windows.WPARAM wparam, Windows.LPARAM lparam) => 
               (if  Windows.wordToInt wparam = 1 (* SIZE_MINIMIZED *) then
d2076 2
a2077 2
                    val width = Windows.loword lparam
                    val height = Windows.hiword lparam
d2084 1
a2084 1
                SOME Windows.nullWord))
d2119 2
a2120 2
	  val desktopRect = Windows.getWindowRect (Windows.getDesktopWindow() )
	  fun get_list_rect () = Windows.getWindowRect (CapiTypes.get_real shell)
d2126 1
a2126 1
	    (Windows.moveWindow (hwnd, new_x, new_y, width, height, true);
d2135 2
a2136 2
		(rect as (Windows.RECT {top=t, left=l, right=r, bottom=b})),
		(desktop as (Windows.RECT {top=dt, left=dl, right=dr, bottom=db}))) =
d2146 1
a2146 1
          (Windows.moveWindow (CapiTypes.get_real shell,x-100,y+10,width,height,true);
d2176 1
a2176 1
      if Windows.openClipboard (window)
d2178 3
a2180 3
          (Windows.emptyClipboard ();
           Windows.setClipboardData s;
           Windows.closeClipboard ())
d2185 1
a2185 1
    if Windows.openClipboard (Windows.nullWindow)
d2188 2
a2189 2
          val result = Windows.getClipboardData ()
          val _ = Windows.closeClipboard ()
d2198 1
a2198 1
    if Windows.openClipboard (CapiTypes.get_real widget)
d2201 2
a2202 2
          val result = Windows.getClipboardData ()
          val _ = Windows.closeClipboard ()
d2227 1
a2227 1
      {styles: Windows.window_style list,
d2232 1
a2232 1
       id : Windows.word,
d2238 1
a2238 1
      {styles: Windows.window_style list,
d2247 1
a2247 1
    val create_dialog_indirect : Template * Windows.hwnd -> Windows.hwnd = 
d2250 3
a2252 3
    val name_id = Windows.newControlId()
    val num_id = Windows.newControlId()
    val continue_id = Windows.newControlId() 
d2257 3
a2259 3
	  {styles = [Windows.SS_LEFT,
                     Windows.WS_CHILD,
                     Windows.WS_VISIBLE],
d2266 1
a2266 1
           id = Windows.nullWord}
d2275 5
a2279 5
          {styles = [Windows.WS_CHILD,
                     Windows.WS_TABSTOP,
                     Windows.WS_BORDER,
                     Windows.WS_VISIBLE,
		     Windows.ES_AUTOHSCROLL],
d2295 4
a2298 4
          {styles = [Windows.WS_CHILD,
		     Windows.BS_DEFPUSHBUTTON,
                     Windows.WS_TABSTOP,
                     Windows.WS_VISIBLE],
d2319 4
a2322 4
      {styles = [Windows.WS_POPUP,
                 Windows.WS_CAPTION,
                 Windows.WS_SYSMENU,
                 Windows.WS_VISIBLE],
d2355 1
a2355 1
	 ((Windows.getDlgItem (dialog_wnd, name_id)), CapiTypes.NONE));
d2357 3
a2359 3
	 ((Windows.getDlgItem (dialog_wnd, num_id)), CapiTypes.NONE));
       Windows.unregisterPopupWindow dialog_wnd;
       Windows.destroyWindow dialog_wnd)
d2365 3
a2367 3
	  Windows.messageBox (CapiTypes.get_real parent,message,"MLWorks",
                         [Windows.MB_RETRYCANCEL,
                          Windows.MB_APPLMODAL])
d2369 1
a2369 1
        Windows.messageBeep Windows.MB_ICONEXCLAMATION;
d2383 1
a2383 1
	(Windows.registerPopupWindow l_dialog;
d2385 1
a2385 1
	 Text.set_string (CapiTypes.REAL ((Windows.getDlgItem (l_dialog, name_id)), 
d2387 1
a2387 1
	 Text.set_string (CapiTypes.REAL ((Windows.getDlgItem (l_dialog, num_id)), 
d2389 7
a2395 7
	 Windows.addCommandHandler(real_parent, cut_id, cut);
	 Windows.addCommandHandler(real_parent, copy_id, copy);
	 Windows.addCommandHandler(real_parent, paste_id, paste);
	 Windows.addCommandHandler(l_dialog, name_id, 
	   fn _ => (set_text_ref (Windows.getDlgItem(l_dialog, name_id))));
	 Windows.addCommandHandler(l_dialog, num_id, 
	   fn _ => (set_text_ref (Windows.getDlgItem(l_dialog, num_id))));
d2397 1
a2397 1
	 Windows.addCommandHandler(l_dialog, continue_id,
d2399 5
a2403 5
          	      Windows.WM_CLOSE, Windows.WPARAM Windows.nullWord,
                      Windows.LPARAM Windows.nullWord)));
         Windows.addMessageHandler
           (l_dialog, Windows.WM_CLOSE, fn _ => (ok_callback l_dialog; 
						SOME (Windows.nullWord)));
d2432 2
a2433 2
           parent = Windows.nullWindow,
           menu = Windows.nullWord,
d2435 3
a2437 3
           styles = [Windows.WS_POPUP,
                     Windows.WS_BORDER,
		     Windows.DS_MODALFRAME]}
d2440 4
a2443 4
			  Windows.destroyWindow splash_window;());
	val splash_timer = Windows.setTimer(splash_window, 5000, timercb);
	fun close_cb _ = (Windows.killTimer(splash_window, splash_timer);
			  Windows.destroyWindow splash_window;
d2445 2
a2446 2
			  SOME (Windows.nullWord))
	fun paint_cb _ = let val dc = Windows.getDC splash_window
d2451 4
a2454 4
	  (Windows.addMessageHandler(splash_window, Windows.WM_CLOSE, close_cb);
	   Windows.addMessageHandler
	     (splash_window, Windows.WM_LBUTTONDOWN, close_cb);
	   Windows.addMessageHandler(splash_window, Windows.WM_PAINT, paint_cb);
d2470 1
a2470 1
               dcref : Windows.hdc option ref,
d2487 1
a2487 1
              val dc = Windows.getDC (CapiTypes.get_real window)
d2489 1
a2489 1
              val background = Windows.getSysColor (Windows.COLOR_WINDOW)
d2491 1
a2491 1
		Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
d2493 2
a2494 2
	          Windows.WindowSystemError _ => 
	            Windows.getStockObject (Windows.ANSI_VAR_FONT)
d2496 2
a2497 2
              ignore(Windows.setBkColor (dc,background));
              ignore(Windows.selectObject (dc,gui_font));
d2500 1
a2500 1
	    handle Windows.WindowSystemError _ => ()
d2506 1
a2506 1
            (Windows.releaseDC (CapiTypes.get_real window,dc);
d2533 4
a2536 4
          val old_fg = Windows.setTextColor (dc,Windows.getBkColor dc);
          val old_bg = Windows.setBkColor (dc,old_fg);
          fun undo _ = (ignore(Windows.setTextColor (dc,old_fg));
                        Windows.setBkColor (dc,old_bg))
d2554 1
a2554 1
           val Windows.HDC dcw = gp_dc gp
d2556 6
a2561 6
           sendMessageNoResult (CapiTypes.get_real window,Windows.WM_ERASEBKGND,
                                Windows.WPARAM dcw,
                                Windows.LPARAM Windows.nullWord);
           sendMessageNoResult (CapiTypes.get_real window,Windows.WM_PAINT,
                                Windows.WPARAM Windows.nullWord,
                                Windows.LPARAM Windows.nullWord)
d2567 3
a2569 3
        (Windows.postMessage (CapiTypes.get_real window,Windows.WM_PAINT,
                              Windows.WPARAM Windows.nullWord,
                              Windows.LPARAM Windows.nullWord);
d2594 1
a2594 1
          val (width,height) = Windows.getTextExtentPoint (dc,string)
d2612 2
a2613 2
          Windows.moveTo (dc,x-xo,y-yo,Windows.nullWord);
          Windows.lineTo (dc,x'-xo,y'-yo)
d2626 5
a2630 5
          Windows.moveTo (dc,x-xo,y-yo,Windows.nullWord);
          Windows.lineTo (dc,x+width-xo,y-yo);
          Windows.lineTo (dc,x+width-xo,y+height-yo);
          Windows.lineTo (dc,x-xo,y+height-yo);
          Windows.lineTo (dc,x-xo,y-yo)
d2633 2
a2634 2
      fun object_from_brush (Windows.HBRUSH brush) =
        Windows.OBJECT brush
d2642 1
a2642 1
          val brush = Windows.createSolidBrush (Windows.getSysColor (Windows.COLOR_WINDOWTEXT))
d2644 2
a2645 2
          Windows.fillRect (dc,
                            Windows.RECT {left = x-xo,
d2650 1
a2650 1
          Windows.deleteObject (object_from_brush brush)
d2659 1
a2659 1
          val brush = Windows.createSolidBrush (Windows.getSysColor (Windows.COLOR_WINDOW))
d2661 2
a2662 2
          Windows.fillRect (dc,
                            Windows.RECT {left = x-xo,
d2667 1
a2667 1
          Windows.deleteObject (object_from_brush brush)
d2678 1
a2678 1
          Windows.textOut (dc,x-xo,y-yo,string)
d2688 3
a2690 3
            [Windows.WS_CHILD,Windows.WS_BORDER] @@
            (if want_hscroll then [Windows.WS_HSCROLL] else []) @@
            (if want_vscroll then [Windows.WS_VSCROLL] else [])
d2697 1
a2697 1
                             menu = Windows.nullWord,
d2710 1
a2710 1
                then Windows.setScrollRange (window,Windows.SB_HORZ,0,max (0,x-w),true)
d2713 1
a2713 1
                then Windows.setScrollRange (window,Windows.SB_VERT,0,max (0,y-h),true)
d2719 1
a2719 1
            (Windows.validateRect (window,NONE);
d2721 1
a2721 1
             SOME Windows.nullWord)
d2735 1
a2735 1
          fun vscroll_handler (Windows.WPARAM wparam, Windows.LPARAM lparam) =
d2737 1
a2737 1
              val code = Windows.loword wparam
d2743 1
a2743 1
                  Windows.setScrollPos (window,Windows.SB_VERT,pos,true);
d2750 3
a2752 3
                if code = Windows.convertSbValue Windows.SB_THUMBPOSITION
                  then dochange (Windows.hiword wparam)
                else if code = Windows.convertSbValue Windows.SB_LINEUP
d2754 1
a2754 1
                else if code = Windows.convertSbValue Windows.SB_LINEDOWN
d2756 1
a2756 1
                else if code = Windows.convertSbValue Windows.SB_PAGEUP
d2758 1
a2758 1
                else if code = Windows.convertSbValue Windows.SB_PAGEDOWN
d2762 1
a2762 1
              SOME Windows.nullWord
d2765 1
a2765 1
          fun hscroll_handler (Windows.WPARAM wparam, Windows.LPARAM lparam) =
d2767 1
a2767 1
              val code = Windows.loword wparam
d2773 1
a2773 1
                  Windows.setScrollPos (window,Windows.SB_HORZ,pos,true);
d2779 3
a2781 3
                if code = Windows.convertSbValue Windows.SB_THUMBPOSITION
                  then dochange (Windows.hiword wparam)
                else if code = Windows.convertSbValue Windows.SB_LINELEFT 
d2783 1
a2783 1
                else if code = Windows.convertSbValue Windows.SB_LINERIGHT
d2785 1
a2785 1
                else if code = Windows.convertSbValue Windows.SB_PAGELEFT 
d2787 1
a2787 1
                else if code = Windows.convertSbValue Windows.SB_PAGERIGHT
d2791 1
a2791 1
              SOME Windows.nullWord
d2808 1
a2808 1
                then Windows.setScrollPos (window,Windows.SB_HORZ,new_xi,true) 
d2811 1
a2811 1
                then Windows.setScrollPos (window,Windows.SB_VERT,new_yi,true) 
d2829 1
a2829 1
          Windows.addMessageHandler (window,Windows.WM_PAINT,draw_handler);
d2831 1
a2831 1
            then Windows.addMessageHandler (window,Windows.WM_VSCROLL,vscroll_handler) 
d2834 1
a2834 1
            then Windows.addMessageHandler (window,Windows.WM_HSCROLL,hscroll_handler) 
d2836 1
a2836 1
          Windows.addMessageHandler (window,Windows.WM_SIZE,
d2839 1
a2839 1
                                      SOME Windows.nullWord));
d2852 1
a2852 1
          fun mouse_handler button (Windows.WPARAM wparam,Windows.LPARAM lparam) =
d2854 2
a2855 2
              val x = Windows.loword lparam
              val y = Windows.hiword lparam
d2858 1
a2858 1
              SOME Windows.nullWord
d2861 2
a2862 2
          Windows.addMessageHandler (window,Windows.WM_LBUTTONDOWN,mouse_handler (Event.LEFT));
          Windows.addMessageHandler (window,Windows.WM_RBUTTONDOWN,mouse_handler (Event.RIGHT))
@


1.111
log
@[Bug #50035]
Keyboard accelerators now platform specific.
@
text
@d3 4
d611 2
d778 12
d851 1
d989 1
a989 1
		     pos = (100,100)}
@


1.110
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d3 4
d1800 9
@


1.109
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d3 4
d547 2
d553 3
a555 3
      Windows.sendMessage (CapiTypes.get_real window,Windows.WM_SETTEXT,
                            Windows.WPARAM (Windows.nullWord),
                            Windows.LPARAM string_word);
d640 5
a644 6
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM text_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
d656 5
a660 6
      Windows.sendMessage
        (CapiTypes.get_real window,
         Windows.WM_SETFONT,
         Windows.WPARAM gui_font,
         Windows.LPARAM (Windows.intToWord 1));
      ()
d819 1
a819 1
	       Windows.setMinMaxInfo (addr, p(r+6, !height), p(~4,~4), p(0,0), maxtrack);
d822 1
a822 1
	    (Windows.setMinMaxInfo (addr, p(r+6, !height), p(~4,~4), p(0,0), maxtrack);
d1112 2
a1113 2
      Windows.addMessageHandler (window, Windows.WM_HSCROLL, scrolling);
      Windows.sendMessage (window,
d1203 1
a1203 1
            Windows.sendMessage (window,Windows.LB_ADDSTRING,
d1221 6
a1226 7
	   if maxTextWidth > 0 then 
	   	(Windows.sendMessage
                   (window,Windows.LB_SETHORIZONTALEXTENT, 
                    Windows.WPARAM (i2w (maxTextWidth * charWidthInPixels)),
                    Windows.LPARAM Windows.nullWord);
                ())
	else ()
d1232 1
a1232 1
        (Windows.sendMessage (window,Windows.LB_RESETCONTENT,
d1305 1
a1305 1
                                 (Windows.setFocus (CapiTypes.get_real to);
d1314 1
a1314 1
  fun set_focus w = (Windows.setFocus (CapiTypes.get_real w); ())
d1316 1
a1316 1
  fun set_busy w = (Windows.setCursor (Windows.loadCursor Windows.IDC_WAIT); ())
d1318 1
a1318 1
  fun unset_busy w = (Windows.setCursor (Windows.loadCursor Windows.IDC_ARROW); ())
d1372 1
a1372 1
	fn _ => (close_fun(); SOME (Windows.nullWord)))
d1573 1
a1573 1
          Windows.sendMessage (CapiTypes.get_real list,
d1580 1
a1580 1
             Windows.sendMessage (Windows.getParent (CapiTypes.get_real list),
d1583 1
a1583 2
                                  Windows.LPARAM (Windows.windowToWord hwnd));
             ())
d1588 4
a1591 5
        (Windows.sendMessage (CapiTypes.get_real list,
                              Windows.LB_SETTOPINDEX,
                              Windows.WPARAM (Windows.intToWord (pos-1)),
                              Windows.LPARAM Windows.nullWord);
        ())
d1600 1
a1600 1
                Windows.sendMessage
d1605 1
a1605 1
                  Windows.free string_word
d1619 1
a1619 1
	      (handler(); SOME (Windows.nullWord))
d1643 1
a1643 1
         Windows.sendMessage (CapiTypes.get_real text,
d1646 1
a1646 2
                              Windows.LPARAM (Windows.intToWord pos2));
         ())
d1662 1
a1662 1
          Windows.sendMessage (CapiTypes.get_real text,
d1674 1
a1674 1
          Windows.sendMessage (CapiTypes.get_real text,
d1711 1
a1711 1
            Windows.sendMessage (hwnd,
d1715 1
a1715 1
            Windows.sendMessage (hwnd,
d1718 1
a1718 2
                                 Windows.LPARAM Windows.nullWord);
            ()
d1737 1
a1737 1
          Windows.sendMessage (CapiTypes.get_real text,
d1802 1
a1802 1
        (Windows.sendMessage (CapiTypes.get_real text,
d1805 1
a1805 2
                              Windows.LPARAM Windows.nullWord);
         ())
d1808 1
a1808 1
        (Windows.sendMessage (CapiTypes.get_real text,
d1811 1
a1811 2
                              Windows.LPARAM Windows.nullWord);
        ())
d1814 1
a1814 1
        (Windows.sendMessage (CapiTypes.get_real text,
d1817 1
a1817 2
                              Windows.LPARAM Windows.nullWord);
        ())
d1841 1
a1841 1
		Windows.sendMessage (CapiTypes.get_real text,
d1847 1
a1847 1
		Windows.sendMessage (CapiTypes.get_real text,
d2362 3
a2364 4
           fn n => (Windows.sendMessage(l_dialog,
        	    Windows.WM_CLOSE, Windows.WPARAM Windows.nullWord,
                    Windows.LPARAM Windows.nullWord);
	           ()));
d2411 1
a2411 1
			in (paintBitmap dc; NONE)
d2460 2
a2461 2
              Windows.setBkColor (dc,background);
              Windows.selectObject (dc,gui_font);
d2499 1
a2499 1
          fun undo _ = (Windows.setTextColor (dc,old_fg);
d2501 1
a2501 1
          val result = f a handle exn => (undo (); raise exn)
d2503 1
a2503 1
          undo ();
d2520 1
a2520 1
           Windows.sendMessage (CapiTypes.get_real window,Windows.WM_ERASEBKGND,
d2523 1
a2523 1
           Windows.sendMessage (CapiTypes.get_real window,Windows.WM_PAINT,
d2525 1
a2525 2
                                Windows.LPARAM Windows.nullWord);
           ()
d2684 1
a2684 1
             with_graphics gp draw (gp,REGION {x=0,y=0,width=1000,height=1000});
d2821 1
a2821 1
              handler (button,POINT {x=x + !x_offset,y=y + !y_offset});
d2874 1
a2874 1
	val result = f () handle exn => (toggle_updates false; raise exn)
d2876 1
a2876 1
	(toggle_updates false;
@


1.108
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d3 4
d397 1
a423 2
  val debug_out = MLWorks.IO.terminal_out

d425 2
a426 2
  fun debug s = if do_debug then MLWorks.IO.output (debug_out, s() ^ "\n") else ()
  fun ddebug s = MLWorks.IO.output (debug_out, s() ^ "\n")
d1059 1
a1059 1
          then MLWorks.IO.output (debug_out, "MAXTEXT received\n")
d1654 1
a1654 1
           else MLWorks.IO.output (debug_out, "Set insertion position has failed: " ^ N pos ^ " " ^ N p ^ "\n")
d2149 1
a2149 1
      else MLWorks.IO.output (debug_out,"Can't open Clipboard\n")
d2162 1
a2162 1
        (MLWorks.IO.output (debug_out,"Can't open Clipboard\n");
@


1.107
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d3 4
d560 18
d877 1
a877 1
  fun make_main_window (name,title,parent,has_context_label, in_windows_menu) = 
d880 3
a882 2
        Windows.createWindow
        {class = "Toplevel",
d884 2
d893 1
a893 1
        if has_context_label
d904 1
a904 1
      if in_windows_menu then 
d914 1
a914 1
  fun make_main_popup (name,title,parent,has_context_label, visible) = 
d917 3
a919 2
        Windows.createWindow
        {class = "Toplevel",
d921 2
d930 1
a930 1
        if has_context_label
d939 1
a939 1
      min_child (CapiTypes.get_real parent, window, visible);
d945 1
a945 1
      if (!visible) then 
d954 6
a959 5
    make_main_popup ("messages", 
		     "System Messages", 
		     CapiTypes.REAL (valOf(!dummyWindow), parent), 
		     false, 
		     visible)
d1321 7
d1349 8
d1907 1
a1907 1
      fun lay_out (parent,children) =
d1937 1
a1937 1
		    val _ = map lay_out panes
d2016 8
a2023 5
          Windows.moveWindow
	    (CapiTypes.get_real parent, x, y,
	     total_width + w - cright,
	     total_height + h - cbottom,
	     true);
d2125 1
a2125 1
      (form,
a2382 18

    datatype window_ex_style = 
	WS_EX_DLGMODALFRAME |
	WS_EX_STATICEDGE |
	WS_EX_WINDOWEDGE

    fun createWindowEx (details : 
      {ex_styles: window_ex_style list,
       class: string,
       name: string,
       x: int,
       y: int,
       width : int,
       height : int,
       parent: Windows.hwnd,
       menu : Windows.word,
       styles : Windows.window_style list}) : Windows.hwnd = 
	(MLWorks.Internal.Runtime.environment "win32 create window ex") details
@


1.106
log
@[Bug #30125]
Move implementation of send_message to Menus.
@
text
@d3 4
d27 20
d546 3
d578 1
a578 1
    | Text => 50
d607 1
a607 1
	Windows.getStockObject (Windows.ANSI_FIXED_FONT)
a665 1
		      Windows.WS_HSCROLL,
a1118 3
  (* we only need one of these *)
  val scrolllist_id = Windows.newControlId ()

d1121 1
d1128 1
a1128 1
         height = 200,
d1281 3
a1283 2
  fun set_busy window = () (* dummy "set_busy" *)
  fun unset_busy window = () (* dummy "unset_busy" *)
d1306 7
d1340 13
a1352 3
    (case Windows.openFileDialog (CapiTypes.get_real parent, mask)
     of "" => NONE
     |  s => SOME s)
d1359 5
d1367 9
a1375 1
	(case Windows.saveAsDialog (CapiTypes.get_real parent) of
d1379 1
a1379 1
	(case Windows.saveImageDialog (CapiTypes.get_real parent) of
d1385 14
a1398 5
  fun makeYesNo (parent, question) () =
    (env "win32 yes id") =  Windows.messageBox (CapiTypes.get_real parent,
                                                question, "MLWorks",
                                                [Windows.MB_YESNO,
                                                Windows.MB_APPLMODAL])
d1443 12
a1454 1
  fun with_message (parent,message) f = f ()
d1464 1
d1472 2
a1473 1
        
d1480 6
d1489 5
a1493 2
          NONE => 
            ()
d1521 1
d1532 1
a1532 1
                                  Windows.WPARAM (Windows.intToWord (256 * 256 * 1 + Windows.wordToInt scrolllist_id)),
d1983 1
a1983 1
          relayout (total_width + w - cright, total_height + h - cbottom);
@


1.105
log
@[Bug #30187]
Fix horizontal scrolling on Win95.
@
text
@d3 4
d1328 1
a1328 6
  fun send_message (parent,message) =
    (Windows.messageBeep Windows.MB_ICONQUESTION;
     Windows.messageBox (CapiTypes.get_real parent,message,"MLWorks",
                         [Windows.MB_OK,
                          Windows.MB_APPLMODAL]);
     ())
@


1.104
log
@[Bug #30193]
Fix size of maximised podium for display on NT 3.51.
@
text
@d3 4
d365 1
d379 1
d384 1
a384 1
              sharing type Windows.word = LabelStrings.word
d1000 33
d1045 2
@


1.103
log
@[Bug #30193]
Resize the maximised podium.
@
text
@d3 4
d718 20
d739 1
a739 1
      fun getminmax (_, Windows.LPARAM addr) = 
d746 1
a746 3

	  (* p(r+6, 130) sets the window size when it is maximised and the 74 is 
	   * the height of the maximised window.
d750 10
a759 1
	  Windows.setMinMaxInfo (addr, p(r+6, 74), p(~4,~4), p(0,0), maxtrack);
d762 1
d804 1
a804 1
      Windows.addMessageHandler (window, Windows.WM_GETMINMAXINFO, getminmax);
d814 1
@


1.102
log
@[Bug #30137]
Add make_messages_popup.
@
text
@d3 4
d723 3
a725 3
	  (* p(r+6, 130) sets the window size when it is maximised and the 130 is 
	   * chosen to show about four lines of the message text box when the window
	   * is maximised.  The p(~4,~4) is the position of the window so that the 
d728 1
a728 1
	  Windows.setMinMaxInfo (addr, p(r+6, 130), p(~4,~4), p(0,0), maxtrack);
@


1.101
log
@[Bug #30153]
Remove references to Old.
@
text
@d3 4
d851 7
@


1.100
log
@[Bug #30241]
Implementing proper Find Dialog.
@
text
@d3 4
a344 1
require "^.basis.__old";
d903 1
a903 1
	     (window, Old.chr (Windows.wordToInt wparam), false) then
d910 1
a910 1
	     (window, Old.chr (Windows.wordToInt wparam), true) then
@


1.100.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.100  1997/09/05  15:00:35  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
@


1.100.2.2
log
@[Bug #30071]
Redesign Compilation Manager -> Project Workspace.
@
text
@a500 3
  (* Needed on Motif so that menus on main_popups automatically created can be removed *)
  fun remove_menu widget = ()

d530 1
a530 1
    | Text => 25
d559 1
a559 1
	Windows.getStockObject (Windows.ANSI_VAR_FONT)   (* Windows.ANSI_FIXED_FONT) *)
d618 1
d1001 3
a1005 1
      val scrolllist_id = Windows.newControlId ()
d1012 1
a1012 1
         height = 150,
a1188 7
  fun size_window (widget, w, h) = 
   let
     val Windows.RECT {left,top,right,bottom} = Windows.getWindowRect (CapiTypes.get_real widget)
   in
     Windows.moveWindow (CapiTypes.get_real widget, left, top, w, h, true)
   end

a1224 5
  (* Can create a directory on Unix, but Win32 does not allow
   * a directory to be created.
   *)
  val set_dir_dialog = open_dir_dialog

d1228 1
a1228 9
	(case Windows.saveDialog (CapiTypes.get_real parent, "SML files", "sml") of
	   "" => NONE
	 | s => SOME s)
    | ".img" =>
	(case Windows.saveDialog (CapiTypes.get_real parent, "Image files", "img") of
	   "" => NONE
	 | s => SOME s)
    | ".mlp" =>
	(case Windows.saveDialog (CapiTypes.get_real parent, "MLW project files", "mlp") of
d1232 1
a1232 1
	(case Windows.saveDialog (CapiTypes.get_real parent, "All files", "*") of
d1243 5
a1247 14
  fun makeYesNoCancel (parent, question, cancelButton) () =
    let 
      val yes = env "win32 yes id"
      val no = env "win32 no id"
      val cancel = env "win32 cancel id"
      val yesNoStyle = if cancelButton then Windows.MB_YESNOCANCEL else Windows.MB_YESNO
      val answer = Windows.messageBox (CapiTypes.get_real parent, question, 
				       "MLWorks", yesNoStyle :: [Windows.MB_APPLMODAL])
    in
      if answer = (env "win32 yes id") then SOME true
      else
	if answer = (env "win32 no id") then SOME false
	else NONE
    end
a1347 1
	  val id = Windows.getDlgCtrlID hwnd
d1358 1
a1358 1
                                  Windows.WPARAM (Windows.intToWord (256 * 256 * 1 + id)),
d1809 1
a1809 1
          relayout (total_width, total_height);
@


1.100.2.3
log
@[Bug #30071]
Generalise Windows.openFileDialog to take a description of Filter.
@
text
@a2 4
 * Revision 1.100.2.2  1997/09/12  14:48:42  johnh
 * [Bug #30071]
 * Redesign Compilation Manager -> Project Workspace.
 *
d1165 2
a1166 3
  fun set_busy w = (Windows.setCursor (Windows.loadCursor Windows.IDC_WAIT); ())

  fun unset_busy w = (Windows.setCursor (Windows.loadCursor Windows.IDC_ARROW); ())
d1223 3
a1225 13
    let 
      val (ext, desc) = 
	case mask of 
	  ".sml" => ("sml", "SML files")
	| ".mo"  => ("mo", "MLWorks objects files")
	| ".mlp" => ("mlp", "MLWorks projects files")
	| "" 	 => ("*", "All files")
	| s	 => (s, "")
    in
      (case Windows.openFileDialog (CapiTypes.get_real parent, desc, ext) of
         "" => NONE
       |  s => SOME s)
    end
d1321 1
a1321 12
  fun with_message (parent,message) f = 
    let
      val _ = set_busy parent
      fun reset () = unset_busy parent
      val result = f () 
        handle exn as SubLoopTerminated => raise exn
             | exn => (reset(); raise exn)
    in
      reset();
      result
    end

@


1.100.2.4
log
@[Bug #30071]
Change height of text boxes to cope with large fonts on NT 3.51.
@
text
@a2 4
 * Revision 1.100.2.3  1997/11/24  15:24:48  johnh
 * [Bug #30071]
 * Generalise Windows.openFileDialog to take a description of Filter.
 *
d537 1
a537 1
    | Text => 26
@


1.100.2.5
log
@[Bug #30071]
Add command handler for an activate callback (for use in project properties about info).
@
text
@a2 4
 * Revision 1.100.2.4  1997/12/11  14:49:30  johnh
 * [Bug #30071]
 * Change height of text boxes to cope with large fonts on NT 3.51.
 *
d1371 1
a1371 1
          Activate => SOME Windows.WM_CLOSE
a1375 5
      fun getParentIdPair CapiTypes.NONE = (Windows.nullWindow, Windows.nullWord)
	| getParentIdPair (CapiTypes.REAL (w, p)) = 
	    (CapiTypes.get_real p, Windows.intToWord (Windows.getDlgCtrlID w))
	| getParentIdPair (CapiTypes.FAKE _) = (Windows.nullWindow, Windows.nullWord)

d1378 2
a1379 5
          NONE => ()
	| SOME Windows.WM_CLOSE => 
	    let val (p, win_id) = getParentIdPair window
	    in Windows.addCommandHandler (p, win_id, fn _ => handler())
	    end
@


1.100.2.6
log
@[Bug #30071]
Add Capi.Callback.ValueChange
@
text
@a2 4
 * Revision 1.100.2.5  1998/01/06  15:55:58  johnh
 * [Bug #30071]
 * Add command handler for an activate callback (for use in project properties about info).
 *
a1364 1
      | ValueChange
d1372 1
a1372 2
        | ValueChange => "ValueChange"

d1375 1
a1375 1
          Activate => NONE
a1378 1
	| ValueChange => SOME Windows.WM_CLOSE
@


1.100.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.100  1997/09/05  15:00:35  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
@


1.99
log
@[Bug #30224]
Add function makeYesNo.
@
text
@d3 4
d1244 43
@


1.98
log
@[Bug #30182]
Add delete handler.
@
text
@d3 4
d1234 6
@


1.97
log
@[Bug #20074]
Improve license dialog.
@
text
@d3 4
d1330 13
@


1.96
log
@[Bug #30181]
Tidy interrupt button code.
@
text
@d3 4
d1834 40
d1997 41
a2037 8
   fun ok_callback dialog_wnd =
     (continue := false;
      namestr := Text.get_string (CapiTypes.REAL 
	((Windows.getDlgItem (dialog_wnd, name_id)), CapiTypes.NONE));
      numstr := Text.get_string (CapiTypes.REAL 
	((Windows.getDlgItem (dialog_wnd, num_id)), CapiTypes.NONE));
      Windows.unregisterPopupWindow dialog_wnd;
      Windows.destroyWindow dialog_wnd)
d2041 25
a2065 7
	let 
	  val l_dialog = 
	    create_dialog_indirect (license_template, CapiTypes.get_real parent) 
	in (Windows.registerPopupWindow l_dialog;
	    Windows.addCommandHandler(l_dialog, continue_id,
                fn n => (Windows.sendMessage(l_dialog,
                    Windows.WM_CLOSE, Windows.WPARAM Windows.nullWord,
d2067 8
a2074 8
	      ()));
            Windows.addMessageHandler
              (l_dialog, Windows.WM_CLOSE, fn _ => (ok_callback l_dialog; 
			SOME (Windows.nullWord)));
	    reveal l_dialog;
	    event_loop continue;
	    (!namestr, !numstr))
	end
d2076 1
a2076 5
    fun license_complain parent message =
      (send_message(parent, message);
       map (fn (w,_,_) => Windows.destroyWindow (CapiTypes.get_real w))
           (!main_windows);
       MLWorks.Internal.StandardIO.resetIO())
a2578 40

  (* CLIPBOARD INTERFACE *)
  (* this just deals with text right now *)
  (* temporary hack *)

  fun clipboard_set (widget,s) = 
    let
      val window = CapiTypes.get_real widget
    in
      if Windows.openClipboard (window)
        then
          (Windows.emptyClipboard ();
           Windows.setClipboardData s;
           Windows.closeClipboard ())
      else MLWorks.IO.output (debug_out,"Can't open Clipboard\n")
    end

  fun clipboard_get (w,handler) =
    if Windows.openClipboard (Windows.nullWindow)
      then 
        let
          val result = Windows.getClipboardData ()
          val _ = Windows.closeClipboard ()
        in
          handler result
        end
      else 
        (MLWorks.IO.output (debug_out,"Can't open Clipboard\n");
         ())

  fun clipboard_empty widget =
    if Windows.openClipboard (CapiTypes.get_real widget)
      then 
        let
          val result = Windows.getClipboardData ()
          val _ = Windows.closeClipboard ()
        in
          result = ""
        end
      else true
@


1.95
log
@[Bug #30179]
Adding dummy function used in Motif.
@
text
@d3 4
a2535 3

  (* The interrupt button now lives in the toolbar which is created in Menus *)
  fun make_interrupt_button w = (CapiTypes.FAKE (CapiTypes.NONE, []))
@


1.94
log
@[Bug #30175]
Add all windows to dynamic menu, except top level tools.
@
text
@d3 4
d2535 3
@


1.93
log
@Removing interrupt button and putting it on the toolbar.
@
text
@d3 3
d425 1
a705 1
      push ((widget,ref MINIMIZED,title), main_windows); 
d751 1
a751 1
  fun make_main_window (name,title,parent,has_context_label) = 
d771 7
a777 1
      push ((widget,min_max,title),main_windows);
d805 1
d808 8
@


1.92
log
@Implementing single menu bar on Windows.
@
text
@d3 3
d2511 2
a2512 3
  fun register_interrupt_widget W = 
	(MLWorks.Internal.Runtime.environment "nt set interrupt window")
	(CapiTypes.get_real W)
@


1.91
log
@[Bug #1992]
Removed the window (or context) menu to prevent user from using
the cut and paste operations from this menu in wrong situations.
@
text
@d3 5
d421 14
a434 15
  fun minimize_main_windows () =
    map
      (fn (w, ref MINIMIZED, _) => ()
       |  (w, _, _) => Windows.showWindow (CapiTypes.get_real w, Windows.SW_MINIMIZE))
      (!main_windows)
	
  fun restore_main_windows () =
    map
      (fn (w, ref MINIMIZED, _) => ()
       |  (w, ref NORMAL, _) =>
	 Windows.showWindow (CapiTypes.get_real w, Windows.SW_RESTORE)
       |  (w, ref MAXIMIZED, _) =>
	 Windows.showWindow (CapiTypes.get_real w, Windows.SW_MAXIMIZE))
      (!main_windows)
    
d443 1
a443 57
     text_handlers := []
     )

  (* This should eventually return a MainWindow *)
  fun initialize_application (name, title, has_controlling_tty) = 
    let
      val window = Windows.mainInit ()
      val widget = CapiTypes.REAL (window,CapiTypes.NONE)
    in
      (* The min_max value for the podium window is a dummy value, as
	 minimize/maximize events are always handled explicitly.  Using
	 MINIMIZED ensures that no spurious commands are issued for it
	 by minimize_main_windows or restore_main_windows.
       *)
      restart ();
      push ((widget,ref MINIMIZED,title), main_windows);
      Windows.addMessageHandler (window,Windows.WM_DESTROY,
                                   fn _ => (Windows.postQuitMessage 0;
                                            NONE));
      (* Ensure that close has the same effect as selecting the ML menu item
         Return SOME ... to indicate the message has been handled -- otherwise
         we also get the default action, which destroys the window
       *)
      Windows.addMessageHandler (window,Windows.WM_CLOSE,
              fn _ => (if not (!evaluating) then
			  Menus.exit_dialog (widget,widget,has_controlling_tty, 
			  map (fn (w,_,_) => w) (!main_windows))
			else ();
                        SOME (Windows.nullWord)));

      (* Catch the minimize command, so that we can minimize all the other
	 top-level windows when the podium is minimized.
       *)
      Windows.addMessageHandler
	(window, Windows.WM_SYSCOMMAND,
         fn (Windows.WPARAM sc_value, _) => 
	   if Windows.wordToInt sc_value =
	      Windows.convertScValue Windows.SC_MINIMIZE then
	     (minimize_main_windows ();
	      NONE)
	   else if Windows.wordToInt sc_value =
	           Windows.convertScValue Windows.SC_RESTORE then
	     (restore_main_windows ();
	      NONE)
	   else
	     NONE);

      (* Add an all-window command handler for "exit" action *)
      Windows.addCommandHandler (Windows.nullWindow,
                                   LabelStrings.get_action "exit",
              fn _ => (if not (!evaluating) then
			Menus.exit_dialog (widget,widget,has_controlling_tty, 
				map (fn (w,_,_) => w) (!main_windows))
			else ()  ));
      Windows.setAcceleratorTable (Windows.createAcceleratorTable (LabelStrings.accelerators));
      widget
    end
d635 24
a658 2
  (* For the moment, the shell is the same as the menubar window *)
  fun make_main_window (name,title,parent,has_context_label) = 
d660 2
a661 1
      val window = 
d663 1
a663 1
        {class = "Toplevel",
d667 1
a667 1
         parent = Windows.nullWindow,	(* The window has no owner *)
d670 19
a688 6
      val widget = CapiTypes.REAL (window,parent)
      val label_window =
        if has_context_label
          then SOME (make_context_label widget)
        else NONE
      val min_max = ref NORMAL
d690 23
a712 1
      set_text (widget,title);
d714 2
a715 2
      (* Catch the minimize command, so that we can track the current
	 status of this window.
d722 1
a722 1
	     (min_max := MINIMIZED;
d726 1
a726 5
	     (min_max := NORMAL;
	      NONE)
	   else if Windows.wordToInt sc_value =
	           Windows.convertScValue Windows.SC_MAXIMIZE then
	     (min_max := MAXIMIZED;
d731 34
a765 1

d773 1
a773 1
  fun make_main_popup (name,title,parent,has_context_label) = 
d794 1
d801 1
a801 1
  fun make_popup_shell (name,parent,attributes) =
d821 1
d823 1
a823 1
     CapiTypes.REAL (window,parent)
d897 1
a897 1
      val widget =CapiTypes.REAL (window,parent)
d929 1
a929 1
                   Windows.WS_HSCROLL,Windows.WS_VSCROLL,
d940 1
d1084 2
a1085 1
  fun initialize_application_shell shell = ()
d1087 14
a1100 1
  fun to_front window = Windows.bringWindowToTop (CapiTypes.get_real window)
d1633 1
a1633 1
          val Windows.RECT {right=cright,bottom=cbottom,...} =
d1693 7
d1723 1
a1723 1
      val shell = make_popup_shell (name,parent, [])
@


1.91.1.1
log
@branched from 1.91
@
text
@a2 5
 * Revision 1.91  1997/03/26  09:32:51  johnh
 * [Bug #1992]
 * Removed the window (or context) menu to prevent user from using
 * the cut and paste operations from this menu in wrong situations.
 *
@


1.91.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.91.1.1  1997/05/12  10:38:11  hope
 * branched from 1.91
 *
@


1.91.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.91.1.1  1997/05/12  10:38:11  hope
 * branched from 1.91
 *
@


1.91.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.91.1.1  1997/05/12  10:38:11  hope
 * branched from 1.91
 *
@


1.91.1.1.1.2
log
@[Bug #20074]
Merging - improving license dialog.
@
text
@a2 4
 *
 * Revision 1.91.1.1.1.1  1997/07/28  18:23:21  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a1749 40
  (* CLIPBOARD INTERFACE *)
  (* this just deals with text right now *)
  (* temporary hack *)

  fun clipboard_set (widget,s) = 
    let
      val window = CapiTypes.get_real widget
    in
      if Windows.openClipboard (window)
        then
          (Windows.emptyClipboard ();
           Windows.setClipboardData s;
           Windows.closeClipboard ())
      else MLWorks.IO.output (debug_out,"Can't open Clipboard\n")
    end

  fun clipboard_get (w,handler) =
    if Windows.openClipboard (Windows.nullWindow)
      then 
        let
          val result = Windows.getClipboardData ()
          val _ = Windows.closeClipboard ()
        in
          handler result
        end
      else 
        (MLWorks.IO.output (debug_out,"Can't open Clipboard\n");
         ())

  fun clipboard_empty widget =
    if Windows.openClipboard (CapiTypes.get_real widget)
      then 
        let
          val result = Windows.getClipboardData ()
          val _ = Windows.closeClipboard ()
        in
          result = ""
        end
      else true

d1873 8
a1880 41
    val text = ref CapiTypes.NONE

    fun copy _ =
      clipboard_set (!text,Text.get_selection (!text))
    fun paste _ =
      clipboard_get (!text,
			fn s =>
			Text.insert (!text,
				     Text.get_insertion_position (!text),
				     s))
    fun cut _ =
      let
        val s = Text.get_selection (!text)
      in
        Text.delete_selection (!text);
        clipboard_set (!text,s)
      end

    fun set_text_ref hwnd = 
      text := (CapiTypes.REAL (hwnd, CapiTypes.NONE))

    fun ok_callback dialog_wnd =
      (continue := false;
       namestr := Text.get_string (CapiTypes.REAL 
	 ((Windows.getDlgItem (dialog_wnd, name_id)), CapiTypes.NONE));
       numstr := Text.get_string (CapiTypes.REAL 
	 ((Windows.getDlgItem (dialog_wnd, num_id)), CapiTypes.NONE));
       Windows.unregisterPopupWindow dialog_wnd;
       Windows.destroyWindow dialog_wnd)

    fun retry_message (parent,message) =
      let 
	val id_retry : int = env "win32 retry id"
	fun show_message () = 
	  Windows.messageBox (CapiTypes.get_real parent,message,"MLWorks",
                         [Windows.MB_RETRYCANCEL,
                          Windows.MB_APPLMODAL])
      in
        Windows.messageBeep Windows.MB_ICONEXCLAMATION;
	(show_message() = id_retry)
      end
d1884 7
a1890 25
      let 
	val l_dialog = 
	  create_dialog_indirect (license_template, CapiTypes.get_real parent) 
        val cut_id = LabelStrings.get_action "cut"
        val paste_id = LabelStrings.get_action "paste"
        val copy_id = LabelStrings.get_action "copy"
	val real_parent = CapiTypes.get_real parent
      in 
	(Windows.registerPopupWindow l_dialog;
	 continue := true;
	 Text.set_string (CapiTypes.REAL ((Windows.getDlgItem (l_dialog, name_id)), 
					CapiTypes.NONE), !namestr);
	 Text.set_string (CapiTypes.REAL ((Windows.getDlgItem (l_dialog, num_id)), 
					CapiTypes.NONE), !numstr);
	 Windows.addCommandHandler(real_parent, cut_id, cut);
	 Windows.addCommandHandler(real_parent, copy_id, copy);
	 Windows.addCommandHandler(real_parent, paste_id, paste);
	 Windows.addCommandHandler(l_dialog, name_id, 
	   fn _ => (set_text_ref (Windows.getDlgItem(l_dialog, name_id))));
	 Windows.addCommandHandler(l_dialog, num_id, 
	   fn _ => (set_text_ref (Windows.getDlgItem(l_dialog, num_id))));

	 Windows.addCommandHandler(l_dialog, continue_id,
           fn n => (Windows.sendMessage(l_dialog,
        	    Windows.WM_CLOSE, Windows.WPARAM Windows.nullWord,
d1892 14
a1905 10
	           ()));
         Windows.addMessageHandler
           (l_dialog, Windows.WM_CLOSE, fn _ => (ok_callback l_dialog; 
						SOME (Windows.nullWord)));
	 reveal l_dialog;
	 event_loop continue;
	 (!namestr, !numstr))
      end

    fun license_complain parent message = retry_message(parent, message)
d2408 40
@


1.91.1.1.1.3
log
@[Bug #30182]
Merging - add delete handler.
@
text
@a3 4
 * Revision 1.91.1.1.1.2  1997/08/05  09:17:57  johnh
 * [Bug #20074]
 * Merging - improving license dialog.
 *
a1252 13

      fun add_del_handler (window, handler) = 
        let 
          val window' = CapiTypes.get_real window
          fun del_handler (Windows.WPARAM w, Windows.LPARAM l) = 
	    if ((Windows.wordToInt w) = LabelStrings.VK_DELETE) then 
	      (handler(); SOME (Windows.nullWord))
	    else
	      NONE
        in
          Windows.addMessageHandler (window', Windows.WM_KEYDOWN, del_handler)
        end

@


1.91.1.1.1.3.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 4
 * Revision 1.91.1.1.1.3  1997/08/05  10:54:04  johnh
 * [Bug #30182]
 * Merging - add delete handler.
 *
@


1.90
log
@[Bug #1981]
Moved list_select window to be always inside the desktop window.
@
text
@d3 4
d866 7
@


1.89
log
@[Bug #1954]
Added set_min_window_size.
@
text
@d3 4
d1682 26
d1709 2
a1710 1
          Windows.moveWindow (CapiTypes.get_real shell,x-100,y+10,width,height,true)
@


1.88
log
@Replaced the hacky mswindows simulation of unmap callbacks, which was
causing erroneous behaviour (Dialog boxes use the WM_USER0 and WM_USER1
message values!).  The debugger_window and error_browser now call
set_close_callback instead.
@
text
@d3 6
d886 11
@


1.88.3.1
log
@branched from 1.88
@
text
@a2 6
 * Revision 1.88  1996/12/03  20:28:54  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks, which was
 * causing erroneous behaviour (Dialog boxes use the WM_USER0 and WM_USER1
 * message values!).  The debugger_window and error_browser now call
 * set_close_callback instead.
 *
@


1.88.3.2
log
@Added function to create toolbar on podium.
@
text
@a2 3
 * Revision 1.88.3.1  1996/12/18  09:45:41  hope
 * branched from 1.88
 *
a1845 67
  val CreatePodiumToolbar : Windows.hwnd -> Windows.hwnd = env "win32 create podium toolbar"
  fun make_podium_toolbar (parent, actionlist) = 
    let 
      val i2w = Windows.intToWord
      val pwin = CapiTypes.get_real parent
      val toolbar_id = Windows.newControlId() 
      fun get_default_button n = (n, 1996 + n, [Windows.TBSTATE_ENABLED], 
		[Windows.TBSTYLE_BUTTON], i2w (1996 + n), 0)
      val widg = Windows.createToolbarEx
		{parent = pwin, 
		 styles = [Windows.WS_CHILD, Windows.TBSTYLE_TOOLTIPS], 
		 bmp_id = i2w 109,
		 toolbar_id = toolbar_id,
		 num_bmps = 13,
		 num_buttons = 13,
		 x_bitmap = 16,
		 y_bitmap = 16,
		 x_button = 16,
		 y_button = 16,
		 buttons = (map get_default_button [0,1,2,3]) @@
     [(0, 1000, [Windows.TBSTATE_INDETERMINATE], [Windows.TBSTYLE_SEP], i2w 0, 0)] @@
		(map get_default_button [4,5,6,7,8]) @@
     [(0, 1000, [Windows.TBSTATE_INDETERMINATE], [Windows.TBSTYLE_SEP], i2w 0, 0)] @@
		(map get_default_button [9,10])}

      val _ = reveal widg
      exception ActionLookup
      fun get_action (a::thelist) 0 = a
	| get_action (a::thelist) n = get_action thelist (n-1)
	| get_action [] _ = raise ActionLookup
      fun toolButtonCB n = 
	let 
	  val (actionfn, enablefn) = get_action actionlist n
	in 
	  if enablefn() then actionfn() else ()
	end
      val processNotify : Windows.hwnd * Windows.wparam * Windows.lparam -> unit = 
	env "win32 process notify"
      val enabled = Windows.LPARAM (Windows.tbStateToWord Windows.TBSTATE_ENABLED)
      val grayed = Windows.LPARAM (Windows.tbStateToWord Windows.TBSTATE_INDETERMINATE)
      fun update_toolbar (~1) = NONE
	| update_toolbar n = 
	let
	  val (actionfn, enablefn) = get_action actionlist n
	  val wp = Windows.WPARAM (i2w (1996 + n))
	in
	  (if enablefn() then 
		Windows.sendMessage(widg, Windows.TB_SETSTATE, wp, enabled)
	   else
		Windows.sendMessage(widg, Windows.TB_SETSTATE, wp, grayed);
	   update_toolbar (n-1);
	   NONE)
	end
      fun process_notify (w,l) = (processNotify (widg,w,l); NONE)
      fun add_command_handlers n = 
	(Windows.addCommandHandler(pwin, i2w (1996 + n), fn _ => toolButtonCB n);
	 if (n <> 0) then add_command_handlers (n-1) else ())
    in
      add_command_handlers 10;
      Windows.addMessageHandler(pwin, Windows.WM_PARENTNOTIFY, fn _ => update_toolbar 10);
      Windows.addMessageHandler(pwin, Windows.WM_LBUTTONDOWN, fn _ => update_toolbar 10);
      Windows.addMessageHandler(pwin, Windows.WM_LBUTTONUP, fn _ => update_toolbar 10);
      Windows.addMessageHandler(pwin, Windows.WM_NCLBUTTONDOWN, fn _ => update_toolbar 10);
      Windows.addMessageHandler(pwin, Windows.WM_NCLBUTTONUP, fn _ => update_toolbar 10);
      Windows.addMessageHandler(pwin, Windows.WM_NOTIFY, process_notify);
      CapiTypes.REAL (widg, CapiTypes.NONE)
    end
@


1.88.2.1
log
@branched from 1.88
@
text
@a2 6
 * Revision 1.88  1996/12/03  20:28:54  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks, which was
 * causing erroneous behaviour (Dialog boxes use the WM_USER0 and WM_USER1
 * message values!).  The debugger_window and error_browser now call
 * set_close_callback instead.
 *
@


1.88.2.1.1.1
log
@branched from 1.88.2.1
@
text
@a2 3
 * Revision 1.88.2.1  1996/12/17  17:51:25  hope
 * branched from 1.88
 *
@


1.88.1.1
log
@branched from 1.88
@
text
@a2 6
 * Revision 1.88  1996/12/03  20:28:54  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks, which was
 * causing erroneous behaviour (Dialog boxes use the WM_USER0 and WM_USER1
 * message values!).  The debugger_window and error_browser now call
 * set_close_callback instead.
 *
@


1.87
log
@Increased toplevel_width again; the previous increase wasn't enough for
the Compilation Manager.
@
text
@d3 4
a744 12
      (* Treat WM_CLOSE like a Motif "unmap" message, using WM_USER0 to
	 send an Unmap callback. *)
      Windows.addMessageHandler
	(window,
	 Windows.WM_CLOSE,
         fn _ => (hide widget;
      	          Windows.sendMessage
		    (window,
                     Windows.WM_USER0,
                     Windows.WPARAM Windows.nullWord,
                     Windows.LPARAM Windows.nullWord);
         SOME (Windows.nullWord)));
d1118 1
a1118 1
      | Unmap (* used for popup windows.  Simulated via WM_USER0. *)
d1132 1
a1132 1
        | Unmap => SOME Windows.WM_USER0
a1138 1
            (* print ("Can't convert callback " ^ print_callback callback ^ "\n") *)
@


1.86
log
@Changed the labels of the license dialog to match those on Unix/in the
documentation.
@
text
@d3 4
d518 1
a518 1
  val default_width = 650
@


1.85
log
@Made the C getBitmap function reveal the window itself, and return a boolean
to indicate success or failure.
@
text
@d3 4
d1792 1
a1792 1
		     make_label ("Name:", 75, false),
d1794 1
a1794 1
		     make_label ("License number:", 75, false),
@


1.85.1.1
log
@branched from 1.85
@
text
@a2 4
 * Revision 1.85  1996/11/22  12:12:42  daveb
 * Made the C getBitmap function reveal the window itself, and return a boolean
 * to indicate success or failure.
 *
@


1.84
log
@[Bug #1461]
return_max: change to be tail recursive.  This is important
because this code is run during a stack overflow handler
to display the frames.
@
text
@d3 6
d1868 2
a1869 1
    fun make_splash_screen parent = 
d1882 2
a1883 2
           styles = [Windows.WS_POPUP,	(* WS_POPUP style is needed to remove the 
					 * title bar. *)
d1898 9
a1906 15
	reveal splash_window;
	getBitmap splash_window;
	Windows.addMessageHandler(splash_window, Windows.WM_CLOSE, close_cb);
	Windows.addMessageHandler(splash_window, Windows.WM_LBUTTONDOWN, close_cb);
	Windows.addMessageHandler(splash_window, Windows.WM_PAINT, paint_cb);
	to_front s_dialog;
	s_dialog 
      end

  in
    fun show_splash_screen parent = 
      let 
	val splash_screen = make_splash_screen parent
      in
	event_loop ref_show_splash
@


1.83
log
@[Bug #1799]
Modify check_insertion to truncate string if it would not fit at all
Reduce limits on edit control sizes
@
text
@d3 5
d895 24
d934 4
a937 2
	(* This let statement sets the horizontal extent to the value of the maximum
	 * text length in the list box to enable horizontal scrolling. *)
a938 8
	   (* return_max returns the length of the maximum text length in the item list,
	    * or list box. *)
	
	   fun return_max [] max_so_far index = max_so_far
	     | return_max (item1::rest) max_so_far index = 
		max( max( Windows.wordToInt (Windows.sendMessage (window, Windows.LB_GETTEXTLEN,
			  Windows.WPARAM (Windows.intToWord index), Windows.LPARAM Windows.nullWord)),
		     max_so_far), return_max rest max_so_far (index + 1))
d940 3
a942 4

	   (* Need this because LB_SETHORIZONTALEXTENT takes pixel values. *)
	   (* loword of GetDialogBaseUnits is the width of a character in pixels. *)
	   val widthm = Windows.loword (Windows.getDialogBaseUnits ())
d944 6
a949 4
	   if ((return_max (!items_ref) 0 0) > 0) then 
	   	(Windows.sendMessage (window,Windows.LB_SETHORIZONTALEXTENT, 
		Windows.WPARAM (i2w ((return_max (!items_ref) 0 0) * widthm) ),
		Windows.LPARAM Windows.nullWord);())
d951 2
a952 1
	end;())
@


1.82
log
@Removed the title bar from the splash screen.
@
text
@d3 3
d160 107
a266 107
# Revision 1.36  1996/02/01  14:18:24  matthew
# Changing type of [set/get]_window_long
#
# Revision 1.35  1996/01/31  14:15:22  matthew
# Changing representation of Widgets
#
# Revision 1.34  1996/01/25  16:05:31  matthew
# Changing default height of graph panes
#
# Revision 1.33  1996/01/25  12:29:26  matthew
# Trying to fix with_highlighting
#
# Revision 1.32  1996/01/17  10:23:44  matthew
# Send WM_LIMITTEXT to edit windows.
#
# Revision 1.31  1996/01/12  16:45:16  matthew
# Adding insertion checks for the benefit of Windows
#
# Revision 1.30  1996/01/12  10:29:43  daveb
# Removed use of FileDialog structure, incorporating the definitions directly
# in this file instead.
#
# Revision 1.29  1996/01/09  14:19:45  matthew
# Moved list_select in from _gui_utils
#
# Revision 1.28  1996/01/08  15:37:28  matthew
# Adding "exit" command for all windows -- used for accelerators.
#
# Revision 1.27  1996/01/04  15:32:52  matthew
# Fixing bungle with previous fix
#
# Revision 1.26  1996/01/04  14:22:40  matthew
# Fixing some bugs
#
# Revision 1.25  1995/12/20  15:13:11  matthew
# Adding color functions
#
# Revision 1.24  1995/12/14  15:33:47  matthew
# Changing message handling
#
# Revision 1.23  1995/12/13  15:08:33  daveb
# FileDialog now includes a datatype that also needs to be included here.
#
# Revision 1.22  1995/12/07  16:41:21  matthew
# Adding extra text functions
#
# Revision 1.21  1995/12/06  16:57:03  matthew
# Adding clipboard functionality
#
# Revision 1.20  1995/11/23  12:37:36  matthew
# Fixing slight bungle in make_scrolllist
#
# Revision 1.19  1995/11/21  14:44:04  matthew
# More stuff
#
# Revision 1.18  1995/11/17  11:17:27  matthew
# More stuff on command handlers
#
# Revision 1.16  1995/11/15  15:18:27  matthew
# Adding (dummy) get_main_windows
#
# Revision 1.15  1995/11/14  13:58:22  matthew
# Extending for graphics
#
# Revision 1.14  1995/10/10  12:20:30  nickb
# Add Resize callback.
#
# Revision 1.13  1995/10/08  22:40:43  brianm
# Adding mod. to make_graphics.
#
# Revision 1.12  1995/10/02  10:14:54  brianm
# Adding dummy `with_graphics_port' functions and associated functions.
#
# Revision 1.11  1995/09/22  13:56:10  daveb
# Added dummy Capi.Text.set_highlight function.
#
# Revision 1.10  1995/09/21  15:36:07  nickb
# Make scroll bars on graphics ports optional.
#
# Revision 1.9  1995/09/19  10:39:58  brianm
# Updating by adding Capi Point/Region datatypes.
#
# Revision 1.8  1995/09/11  13:30:07  matthew
# Changing top level window initialization
#
# Revision 1.7  1995/09/05  10:49:48  matthew
# Changing use of word_to_int
#
# Revision 1.6  1995/08/31  10:42:40  matthew
# Improving event handling
#
# Revision 1.5  1995/08/25  10:27:36  matthew
# More stuff
#
# Revision 1.4  1995/08/15  16:24:23  matthew
# More work
#
# Revision 1.3  1995/08/15  14:40:19  matthew
# More stuff
#
# Revision 1.2  1995/08/11  13:58:23  matthew
# Making it all work
#
# Revision 1.1  1995/08/03  12:51:30  matthew
# new unit
# MS Windows GUI
#
d271 1
d1380 1
a1380 1
      val text_limit = 60000
d1383 1
a1383 1
      fun check_insertion (text,str,current,marks) =
d1386 2
d1389 2
a1390 2
          if length + size str < text_limit
            then ()
d1392 20
a1411 11
            (Windows.sendMessage (CapiTypes.get_real text,
                                  Windows.WM_SETREDRAW,
                                  Windows.WPARAM (Windows.intToWord 0),
                                  Windows.LPARAM Windows.nullWord);
             replace (text,0,text_chunk,"");
             set_insertion_position (text,current-text_chunk);
             Windows.sendMessage (CapiTypes.get_real text,
                                  Windows.WM_SETREDRAW,
                                  Windows.WPARAM (Windows.intToWord 1),
                                  Windows.LPARAM Windows.nullWord);
             Lists.iterate (fn pos => pos := !pos - text_chunk) marks)
@


1.81
log
@Extended default width to allow for Help menu.
@
text
@d3 3
d1802 18
d1825 6
a1830 3
          Windows.createWindow
          {class = "TopLevel",
           name = "Harlequin MLWorks v1.0",
d1835 2
a1836 1
           styles = [Windows.WS_DLGFRAME,
@


1.80
log
@Rewrote license dialog so that tabbing was allowed within it.
@
text
@d3 3
d492 1
a492 1
  val default_width = 600
@


1.79
log
@Added splash screen.
@
text
@d3 3
d1633 15
a1647 1
    val ok_id = Windows.newControlId ()
d1649 42
a1690 12
    fun make_button (name,parent) =
      let
        val (class_name,styles) = convert_class Button
        val window =
          create_revealed {class = class_name,
                         name = convert_name (Button,name),
                         width = default_width,
                         height = class_height Button,
                         parent = CapiTypes.get_real parent,
                         menu = ok_id,
                         styles = [Windows.WS_CHILD] @@ styles}
        val widget = CapiTypes.REAL (window,parent)
d1692 2
a1693 2
        class_postaction (widget,Button);
        widget
d1696 15
a1710 13
    fun make_managed (name,class,parent,attributes, w, h) =
      let
        val (class_name,styles) = convert_class class
        val window =
          create_revealed {class = class_name,
                              name = convert_name (class,name),
                              width = w,
                              height = h,
                              parent = CapiTypes.get_real parent,
                              menu = Windows.nullWord,
                              styles = [Windows.WS_CHILD] @@
                                        styles @@ attributes}
        val widget = CapiTypes.REAL (window,parent)
d1712 2
a1713 2
        class_postaction (widget,class);
        widget
d1716 18
a1733 2
    fun make_text (name,parent) =
      make_managed (name, Text, parent, [Windows.ES_AUTOHSCROLL], 150, 25)
d1735 28
a1762 2
    val namestr = ref ""
    val numstr = ref ""
d1764 10
a1773 43
    fun make_license_dialog (parent) = let
        val continue = ref true
        val l_dialog =
	  make_popup_shell
	    ("Licensing", parent,
             [Windows.WS_POPUP,
              Windows.WS_SYSMENU,
              Windows.WS_CAPTION,
              Windows.DS_SYSMODAL,
              Windows.DS_MODALFRAME])
        val form = make_subwindow l_dialog
        val msg_label = make_managed_widget
	  ("You must register your copy of MLWorks.", Label, form, [])
        val name_label = make_managed_widget ("Name:", Label, form, [])
        val name_text = make_text ("Name Text", form)
        val lic_no_label = make_managed_widget ("License Number:", Label,
                                form, [])
        val lic_no = make_text ("LicenseNo", form)
        val ok_button = make_button ("Continue", form)
        fun ok_callback _ =
	  (continue := false;
           namestr := Text.get_string name_text;
           numstr := Text.get_string lic_no;
           NONE)
      in
        (Layout.lay_out
	   (form,
	    [Layout.FIXED msg_label,
	     Layout.SPACE,
             Layout.FIXED name_label, Layout.FIXED name_text,
             Layout.FIXED lic_no_label, Layout.FIXED lic_no,
             Layout.SPACE,
             Layout.FIXED ok_button]);
        reveal (CapiTypes.get_real form);
        to_front l_dialog;
        Windows.addCommandHandler
	  (CapiTypes.get_real l_dialog, ok_id,
           fn n =>
	     (ok_callback();
              Windows.sendMessage
	        (CapiTypes.get_real l_dialog,
                 Windows.WM_CLOSE, Windows.WPARAM Windows.nullWord,
                 Windows.LPARAM Windows.nullWord);
d1775 7
a1781 9
        Windows.addMessageHandler
          (CapiTypes.get_real l_dialog, Windows.WM_CLOSE, ok_callback);
        event_loop continue;
        l_dialog)
      end
  in
    fun license_prompt parent () =
      (make_license_dialog parent;
       (!namestr, !numstr))
a1790 1

@


1.78
log
@Adeded license_prompt and license_compaillain.
@
text
@d3 3
d1732 52
@


1.78.1.1
log
@branched from 1.78
@
text
@a2 3
 * Revision 1.78  1996/11/12  11:45:13  daveb
 * Adeded license_prompt and license_compaillain.
 *
@


1.78.1.1.1.1
log
@branched from 1.78.1.1
@
text
@a2 3
 * Revision 1.78.1.1  1996/11/14  12:54:10  hope
 * branched from 1.78
 *
@


1.77
log
@[Bug #1728]
__integer becomes __int
@
text
@d3 4
d29 1
a29 1
 * passing has_controlling_tty to exit_mlworks instead of passed ing false.
d1625 105
@


1.76
log
@Enabling close from control box on top left of window.
@
text
@d3 3
d252 1
a252 1
require "../basis/__integer";
@


1.75
log
@Add interrupt button to Windows.
@
text
@d3 3
d298 6
d403 5
a407 2
                                   fn _ => (Menus.exit_dialog (widget,widget,has_controlling_tty, map (fn (w,_,_) => w) (!main_windows));
                                            SOME (Windows.nullWord)));
d429 4
a432 1
                                   fn _ => (Menus.exit_dialog (widget,widget,has_controlling_tty, map (fn (w,_,_) => w) (!main_windows))));
a670 3
      (* Ignore the WM_CLOSE message, to simulate the Motif behaviour. *)
      Windows.addMessageHandler (window,Windows.WM_CLOSE,
                                   fn _ => (SOME (Windows.nullWord)));
d1008 4
@


1.74
log
@[Bug #1614]
sorting out a typo
@
text
@d3 4
d2084 15
a2098 1
  val register_interrupt_widget = fn _ => ()
@


1.73
log
@moving String from toplevel
@
text
@d3 3
d297 1
a297 1
          | munge ("\n"::rest,acc) = munge (rest, #"\010", #"\013" :: acc)
@


1.72
log
@[Bug #1560]
Enable scrolling on edit controls.
@
text
@d3 4
d237 2
a260 2
  structure Option = MLWorks.Option

d271 1
a273 2
  open CapiTypes

d290 9
a298 10
  fun munge_string s =
    let
      fun munge ([],acc) = String.implode (rev acc)
        | munge ("\013" :: "\010" :: rest,acc) =
          munge (rest, "\010" :: "\013" :: acc)
        | munge ("\n"::rest,acc) = munge (rest,"\013\010" :: acc)
        | munge (c::rest,acc) = munge (rest,c::acc)
    in
      munge (String.explode s,[])
    end
d300 2
a301 1
  (* Someone should do this efficiently! *)
d305 1
a305 1
          if String.ord c < String.ord " " then ""
d308 1
a308 1
      String.implode (map aux (String.explode s))
d310 5
d330 1
a330 1
  val main_windows : (Widget * min_max ref * string) list ref = ref []
d343 1
a343 1
       |  (w, _, _) => Windows.showWindow (get_real w, Windows.SW_MINIMIZE))
d350 1
a350 1
	 Windows.showWindow (get_real w, Windows.SW_RESTORE)
d352 1
a352 1
	 Windows.showWindow (get_real w, Windows.SW_MAXIMIZE))
d370 1
a370 1
      val widget = REAL (window,NONE)
d381 1
a381 1
                                            Option.NONE));
d388 1
a388 1
                                            Option.SOME (Windows.nullWord)));
d399 1
a399 1
	      Option.NONE)
d403 1
a403 1
	      Option.NONE)
d405 1
a405 1
	     Option.NONE);
d430 1
a430 1
      Windows.sendMessage (get_real window,Windows.WM_SETTEXT,
d441 1
a441 1
    Windows.showWindow (get_real window,Windows.SW_HIDE)
d484 1
a484 1
          if window = get_real window'
d497 1
a497 1
        (get_real window,
d514 1
a514 1
        (get_real window,
d539 1
a539 1
                              parent = get_real parent,
d542 1
a542 1
      val widget = REAL (window,parent)
d562 1
a562 1
                         parent = get_real parent,
d565 1
a565 1
      val widget = REAL (window,parent)
d585 1
a585 1
         parent = get_real parent,
d590 1
a590 1
      REAL (window,parent)
d597 2
a598 2
          then Option.SOME (make_context_label parent)
        else Option.NONE
d617 1
a617 1
      val widget = REAL (window,parent)
d620 2
a621 2
          then Option.SOME (make_context_label widget)
        else Option.NONE
d635 1
a635 1
	      Option.NONE)
d639 1
a639 1
	      Option.NONE)
d643 1
a643 1
	      Option.NONE)
d645 1
a645 1
	     Option.NONE);
d651 1
a651 1
                                   fn _ => (Option.SOME (Windows.nullWord)));
d654 1
a654 1
					    Option.NONE));
d667 1
a667 1
         parent = get_real parent, (* This will be the windows owner *)
d670 1
a670 1
      val widget = REAL (window,parent)
d673 2
a674 2
          then Option.SOME (make_context_label widget)
        else Option.NONE
d678 1
a678 1
         Option.NONE)
d691 1
a691 1
         Option.SOME (Windows.nullWord)));
d706 1
a706 1
         parent = get_real parent, (* This will be the windows owner, it should be a top level window *)
d716 1
a716 1
         Option.NONE)
d719 1
a719 1
      REAL (window,parent)
d733 1
a733 1
      val widget = REAL (window,NONE)
d751 2
a752 2
	     (window, String.chr (Windows.wordToInt wparam), false) then
	  Option.SOME (Windows.nullWord)
d754 1
a754 1
          Option.NONE
d758 2
a759 2
	     (window, String.chr (Windows.wordToInt wparam), true) then
	  Option.SOME (Windows.nullWord)
d761 1
a761 1
          Option.NONE
d779 1
a779 1
         parent = get_real parent,
d793 1
a793 1
      val widget = REAL (window,parent)
d798 1
a798 1
      Windows.addCommandHandler (get_real parent,scrolled_text_id,command_handler);
d814 1
a814 1
         parent = get_real parent,
d822 1
a822 1
      val widget = REAL (window,parent)
d841 1
a841 1
         parent = get_real parent,
d846 1
a846 1
      val widget = REAL (window,parent)
d930 1
a930 1
	(get_real parent,scrolllist_id,select_handler);
d938 1
a938 1
  fun destroy window = Windows.destroyWindow (get_real window)
d940 1
a940 1
  fun initialize_toplevel window = reveal (get_real window)
d943 1
a943 1
  fun to_front window = Windows.bringWindowToTop (get_real window)
d946 1
a946 1
    Windows.addMessageHandler (get_real from,Windows.WM_SETFOCUS,
d948 2
a949 2
                                 (Windows.setFocus (get_real to);
                                  Option.SOME Windows.nullWord))
d957 1
a957 1
  fun set_focus w = (Windows.setFocus (get_real w); ())
d964 1
a964 1
      val Windows.RECT {left,top,right,bottom} = Windows.getWindowRect (get_real widget)
d969 1
a969 1
  val set_message_window : Hwnd -> unit = env "nt set message widget"
d972 1
a972 1
    set_message_window (get_real widget)
d980 1
a980 1
      Windows.moveWindow (get_real widget,x,y,w,h,true)
d1006 3
a1008 3
    (case Windows.openFileDialog (get_real parent, mask)
     of "" => MLWorks.Option.NONE
     |  s => MLWorks.Option.SOME s)
d1011 3
a1013 3
    (case Windows.openDirDialog (get_real parent)
     of "" => MLWorks.Option.NONE
     |  s => MLWorks.Option.SOME s)
d1018 3
a1020 3
	(case Windows.saveAsDialog (get_real parent) of
	   "" => MLWorks.Option.NONE
	 | s => MLWorks.Option.SOME s)
d1022 3
a1024 3
	(case Windows.saveImageDialog (get_real parent) of
	   "" => MLWorks.Option.NONE
	 | s => MLWorks.Option.SOME s)
d1028 1
a1028 1
     Windows.messageBox (get_real parent,message,"MLWorks",
d1053 4
a1056 4
          Activate => Option.NONE
        | Destroy => Option.SOME Windows.WM_DESTROY
        | Unmap => Option.SOME Windows.WM_USER0
        | Resize => Option.SOME Windows.WM_SIZE
d1060 1
a1060 1
          Option.NONE => 
d1063 3
a1065 3
        | Option.SOME message =>
            Windows.addMessageHandler (get_real window,message,
                                       fn _ => (handler (); Option.NONE))
d1075 1
a1075 1
            Windows.wordToSignedInt (Windows.sendMessage (get_real list,
d1089 1
a1089 1
          val hwnd = get_real list
d1091 1
a1091 1
          Windows.sendMessage (get_real list,
d1098 1
a1098 1
             Windows.sendMessage (Windows.getParent (get_real list),
d1107 1
a1107 1
        (Windows.sendMessage (get_real list,
d1121 1
a1121 1
	          (get_real list,
d1134 1
a1134 1
        Windows.wordToSignedInt (Windows.sendMessage (get_real text,
d1140 1
a1140 1
          val res = Windows.sendMessage (get_real text,
d1150 1
a1150 1
         Windows.sendMessage (get_real text,
d1170 1
a1170 1
          Windows.sendMessage (get_real text,
d1182 1
a1182 1
          Windows.sendMessage (get_real text,
d1196 1
a1196 1
          val _ = Windows.sendMessage (get_real text,
d1208 1
a1208 1
        String.substring (get_string text,from,size)
d1216 1
a1216 1
            val hwnd = get_real text
d1232 1
a1232 1
          val res = Windows.sendMessage (get_real text,
d1246 1
a1246 1
          Windows.sendMessage (get_real text,
d1256 1
a1256 1
            if String.ordof (str, n) = String.ord "\n"
d1267 1
a1267 1
              if n = length orelse String.ordof (str, n) = String.ord "\n" then
d1273 1
a1273 1
            val result = String.substring (str, start, finish - start)
d1288 1
a1288 1
              if n = length orelse String.ordof (str, n) = String.ord "\n" then
d1311 1
a1311 1
        (Windows.sendMessage (get_real text,
d1318 1
a1318 1
        (Windows.sendMessage (get_real text,
d1325 1
a1325 1
        (Windows.sendMessage (get_real text,
d1344 1
a1344 1
            (Windows.sendMessage (get_real text,
d1350 1
a1350 1
             Windows.sendMessage (get_real text,
d1361 5
a1365 5
        MENUBAR of Widget
      | FLEX of Widget
      | FIXED of Widget
      | FILEBOX of Widget
      | PANED of Widget * (Widget * Class list) list
d1371 1
a1371 1
          val window = get_real window
d1387 1
a1387 1
          val realw = get_real w
d1391 1
a1391 1
              then f (REAL (subwindow,w))
d1412 1
a1412 1
              val child = get_real child
d1463 1
a1463 1
	    Windows.getClientRect (get_real parent)
d1472 1
a1472 1
                if Windows.isNullWindow (get_real window)
d1479 1
a1479 1
                    Windows.moveWindow(get_real window,0,!yref,width,newh,true);
d1505 1
a1505 1
                         (Windows.moveWindow (get_real subwindow,0,!yref,width,!height_ref,true);
d1517 1
a1517 1
	    (get_real parent, x, y,
d1524 1
a1524 1
	    (get_real parent,
d1539 1
a1539 1
                Option.SOME Windows.nullWord))
d1575 1
a1575 1
          Windows.moveWindow (get_real shell,x-100,y+10,width,height,true)
d1583 1
a1583 1
         reveal (get_real form);
d1603 2
a1604 2
        GP of {window: Widget,
               dcref : Windows.hdc MLWorks.Option.option ref,
d1613 2
a1614 2
      fun gp_dc (GP {dcref = ref (Option.SOME hdc),...}) = hdc
        | gp_dc (GP {dcref = ref (Option.NONE),...}) = raise BadDC
d1618 2
a1619 2
          Option.SOME _ => ()
        | Option.NONE =>
d1621 1
a1621 1
              val dc = Windows.getDC (get_real window)
d1632 1
a1632 1
              dcref := Option.SOME dc
d1638 4
a1641 4
          Option.NONE => ()
        | Option.SOME dc =>
            (Windows.releaseDC (get_real window,dc);
             dcref := Option.NONE)
d1690 1
a1690 1
           Windows.sendMessage (get_real window,Windows.WM_ERASEBKGND,
d1693 1
a1693 1
           Windows.sendMessage (get_real window,Windows.WM_PAINT,
d1702 1
a1702 1
        (Windows.postMessage (get_real window,Windows.WM_PAINT,
d1718 1
a1718 1
              dcref = ref Option.NONE,
d1831 1
a1831 1
                             parent = get_real parent,
d1834 1
a1834 1
          val widget = REAL (window,parent)
d1854 1
a1854 1
            (Windows.validateRect (window,Option.NONE);
d1856 1
a1856 1
             Option.SOME Windows.nullWord)
d1897 1
a1897 1
              Option.SOME Windows.nullWord
d1926 1
a1926 1
              Option.SOME Windows.nullWord
d1974 1
a1974 1
                                      Option.SOME Windows.nullWord));
d1986 1
a1986 1
          val window = get_real window
d1993 1
a1993 1
              Option.SOME Windows.nullWord
d2035 1
a2035 1
      val window = get_real widget
d2059 1
a2059 1
    if Windows.openClipboard (get_real widget)
d2069 3
a2071 3
  fun parent NONE = NONE
    | parent (REAL (_,p)) = p
    | parent (FAKE (p,_)) = p
d2073 1
a2073 1
  val reveal = reveal o get_real
@


1.72.2.1
log
@branched from 1.72
@
text
@a2 4
 * Revision 1.72  1996/10/02  11:00:35  johnh
 * [Bug #1560]
 * Enable scrolling on edit controls.
 *
@


1.72.1.1
log
@branched from 1.72
@
text
@a2 4
 * Revision 1.72  1996/10/02  11:00:35  johnh
 * [Bug #1560]
 * Enable scrolling on edit controls.
 *
@


1.71
log
@[Bug #1621]
Enabling scrollbar functionality on list box in error browser.
@
text
@d544 4
a547 2
	     Text => [Windows.WS_HSCROLL, Windows.ES_AUTOHSCROLL, 
		      Windows.ES_MULTILINE]
@


1.70
log
@Adding interrupt button feature
@
text
@d3 3
d457 1
a457 1
    | Text => 25
d543 4
d554 1
a554 1
                         styles = [Windows.WS_CHILD] @@ styles}
d839 1
a839 1
        (Lists.iterate
d851 25
a875 1
         items_ref := !items_ref @@ items)
@


1.69
log
@[Bug #1583]
passing has_controlling_tty to exit_mlworks instead of passed ing false.
@
text
@d3 4
d406 1
a406 1
  datatype WidgetClass = Frame | Graphics | Label | Text | RowColumn | Paned | Form
d411 1
d441 1
a442 1

d453 1
d517 1
d2036 1
@


1.68
log
@[Bug #1579]
Resize function was previously not called causing no reset of scrolling.
@
text
@d352 1
a352 1
  fun initialize_application (name, title) = 
d372 1
a372 1
                                   fn _ => (Menus.exit_dialog (widget,widget,false, map (fn (w,_,_) => w) (!main_windows));
d395 1
a395 1
                                   fn _ => (Menus.exit_dialog (widget,widget,false, map (fn (w,_,_) => w) (!main_windows))));
@


1.67
log
@Bug #148.
Passed list a of main Winwindows to exit_dialog function so that they can be killed.
@
text
@d1925 1
a1925 1
                                     (set_scrollbars ();
@


1.66
log
@[Bug #1517]
Added handler for WM_SYSCHAR to handle Alt-<key> combinations.
@
text
@d3 4
d372 1
a372 1
                                   fn _ => (Menus.exit_dialog (widget,widget,false);
d395 1
a395 1
                                   fn _ => (Menus.exit_dialog (widget,widget,false)));
d421 1
a421 1
    (Windows.showWindow (window,Windows.SW_SHOW);
@


1.66.1.1
log
@branched from 1.66
@
text
@a2 4
 * Revision 1.66  1996/08/07  12:24:29  daveb
 * [Bug #1517]
 * Added handler for WM_SYSCHAR to handle Alt-<key> combinations.
 *
@


1.65
log
@[Bug #1517]
Changed definition of Text.end_line to return the current position if it
is already at the end of a line.
@
text
@d3 5
d459 1
a459 1
  fun despatch_text (window,char,alt_on) =
d720 1
a720 1
      fun is_alt_on w = Windows.isAltOn w
d722 10
a731 2
        if despatch_text (window,String.chr (Windows.wordToInt wparam),is_alt_on wparam)
          then Option.SOME (Windows.nullWord)
d738 2
a739 2
      Windows.addMessageHandler (window,Windows.WM_CHAR,
                                   char_handler)
@


1.64
log
@Corrected definition of terminator.
@
text
@d3 3
d1228 1
a1228 3
            if pos = length 
              then pos 
            else aux (pos + 1)
@


1.63
log
@Provide a system dependent line terminator
@
text
@d3 3
d2009 1
a2009 1
  val terminator = "\n\r"
@


1.62
log
@[Bug #1478]
Made WM_CLOSE of top level tools and popups mimic the Motif behaviour.
Top level tools ignore it, and popups unmap themselves, sending a WM_USER0
message to simulate an Unmap callback.  This prevents users from  deleting
stack browsers or their parent windows in the middle of an evaluation.
@
text
@d3 7
d2005 3
@


1.61
log
@[Bug #1260]
Changed the Capi layout datatype so that the PANED constructor takes the
layout info for its sub-panes.  This enables the Windows layout code to
calculate the minimum size of each window.
@
text
@d3 6
d289 1
a289 1
     the podium, but this code checks it anyway.
d603 3
d608 1
a608 1
                                            Option.NONE));
d634 12
d963 1
a963 1
      | Unmap (* hmm *)
d977 1
a977 1
        | Unmap => Option.NONE
@


1.60
log
@Bug 1378: The Windows menu needs to be cleared when entering or leaving the
GUI.  I've changed initialize_application to clear the list of main windows.
@
text
@d3 4
d1268 1
a1268 1
      | PANED of Widget
d1312 2
a1313 1
          fun do_one (child,(maxwidth,y),(width,height)) =
d1317 6
a1322 6
              if not (Windows.isNullWindow child)
                then
                  (debug (fn _ => "do_one: " ^ N width ^ " " ^ N height ^ " " ^ N y);
                   Windows.moveWindow (child,0,y,width,height,true);
                   (max (width,maxwidth),y+height))
              else (maxwidth,y)
d1324 2
a1325 1
          val (total_width,total_height) =
d1328 6
a1333 1
              | (a,FLEX w) => do_one (w,a,widget_size w)
d1336 26
a1361 19
              | (a,PANED w) => 
                  let
                    (* Assumes that the paned window has no non-client area *)
                    val yref = ref 0
                    val maxwidthref = ref 0
                    fun do_subpane subwindow =
                      let
                        val (width,height) = widget_size subwindow
                      in
                        Windows.moveWindow (get_real subwindow,0,!yref,width,height,true);
                        yref := !yref + height;
                        maxwidthref := max (!maxwidthref,width)
                      end
                  in
                    enum_direct_children (w,do_subpane);
                    do_one (w,a,(!maxwidthref,!yref))
                  end
              | ((width,y),SPACE) => (width,y))
            ((0,0),children)
d1365 3
a1367 1
          val Windows.RECT {right=cright,bottom=cbottom,...} = Windows.getClientRect (get_real parent)
d1373 1
d1385 1
d1391 1
a1391 1
                | do_one (PANED window) = 
d1416 1
a1416 1
              Lists.iterate do_one children
d1419 6
a1424 1
          Windows.moveWindow (get_real parent,x,y,total_width+w-cright,total_height+h-cbottom,true);
d1426 17
a1442 12
          Windows.addMessageHandler (get_real parent,Windows.WM_SIZE,
                                     fn (Windows.WPARAM wparam,Windows.LPARAM lparam) => 
                                     (if  Windows.wordToInt wparam = 1 (* SIZE_MINIMIZED *)
                                        then ()
                                      else
                                        let
                                          val width = Windows.loword lparam
                                          val height = Windows.hiword lparam
                                        in
                                          relayout (width,height)
                                        end;
                                      Option.SOME Windows.nullWord))
@


1.59
log
@Added handlers around all calls to Capi.getStockObject.
@
text
@d3 3
d311 8
d330 1
a429 3
  (* List of text handlers *)
  val text_handlers = ref []

a1944 5

  fun restart () =
    (main_windows := [];
     text_handlers := []
     )
@


1.58
log
@Moved exception WindowSystemError to windows.sml.
Set font of text widgets to be ANSI_FIXED_FONT.
Set font of labels, etc. to be DEFAULT_GUI_FONT when defined, and ANSI_VAR_FONT
otherwise.
@
text
@d3 6
d309 1
a309 1
  fun initialize_application (name,title) = 
d445 1
d462 1
d1496 1
@


1.57
log
@Made make_main_window ignore the parent argument, so that all top level
windows are independent.  This means that the podium may be brought to the
front by the user.  Added code to intercept minimize and restore actions,
so that minimizing the podium minimizes all other top-level windows.
@
text
@d3 6
d227 1
a227 3
  exception WindowSystemError of string

  val _ = (env "exception win" : exn ref) :=  WindowSystemError ""
d427 29
d458 4
a461 1
      Text => set_text (window,"")
d699 1
d728 1
d808 1
d1478 5
d1485 1
@


1.56
log
@Bug 1074: Capi.list_select now takes a function to be called on any key
press handled by the list widget itself.  In the listener, this pops the
completions widget down as if the key had been typed at the listener.
@
text
@d3 5
d256 16
a271 1
  val main_windows : (Widget * string) list ref = ref []
d273 1
d275 1
a275 1
    | delete (a,((item as (a',_))::rest)) = 
d277 1
d279 18
a296 1
  fun get_main_windows _ = !main_windows
d304 6
a309 1
      push ((widget,title),main_windows);
d313 4
a316 3
      (* Ensure that close has the same effect as selecting the ML menu item *)
      (* Return SOME ... to indicate the message has been handled -- otherwise we *)
      (* also get the default action, which destroys the window *)
d320 18
d505 1
a505 1
         parent = get_real parent, (* This will be the windows owner *)
d513 1
d516 24
a539 1
      push ((widget,title),main_windows);
@


1.55
log
@Distinguish image saving from file saving and call appropriate rts function
@
text
@d3 3
d1271 1
a1271 1
  fun list_select (parent,name) =
@


1.54
log
@Adding reset function
@
text
@d3 3
d767 9
a775 3
    case Windows.saveAsDialog (get_real parent)
    of "" => MLWorks.Option.NONE
    |  s => MLWorks.Option.SOME s
@


1.53
log
@Ensure WindowSystemError is defined before use
@
text
@d3 3
d1784 4
@


1.52
log
@Set runtime exception
@
text
@d3 3
a204 2
  val _ = (env "exception win" : exn ref) :=  WindowSystemError ""

d208 2
@


1.51
log
@Adding something for set_highlight
@
text
@d3 3
d201 2
@


1.50
log
@set_pos sends a LBN_SELCHANGE message
@
text
@d3 3
d943 17
a959 1
      fun set_highlight (w, s, e, b) = ()
d1032 1
@


1.49
log
@Array moving to MLWorks.Array
@
text
@d3 3
d184 1
d816 16
a831 5
        (Windows.sendMessage (get_real list,
                              Windows.LB_SETCURSEL,
                              Windows.WPARAM (Windows.intToWord (pos-1)),
                              Windows.LPARAM Windows.nullWord);
        ())
@


1.48
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d805 2
a806 2
            then Vector.vector [result+1]
          else Vector.vector []
@


1.47
log
@Removing MLWorks.Integer
@
text
@d3 3
d174 1
a174 1
  fun debug s = if do_debug then output (debug_out, s() ^ "\n") else ()
d202 1
a202 1
      fun munge ([],acc) = implode (rev acc)
d208 1
a208 1
      munge (explode s,[])
d215 1
a215 1
          if ord c < ord " " then ""
d218 1
a218 1
      implode (map aux (explode s))
d509 1
a509 1
        if despatch_text (window,chr (Windows.wordToInt wparam),is_alt_on wparam)
d542 1
a542 1
          then output (debug_out, "MAXTEXT received\n")
d869 1
a869 1
           else output (debug_out, "Set insertion position has failed: " ^ N pos ^ " " ^ N p ^ "\n")
d947 1
a947 1
            if String.ordof (str, n) = ord "\n"
d958 1
a958 1
              if n = length orelse String.ordof (str, n) = ord "\n" then
d979 1
a979 1
              if n = length orelse String.ordof (str, n) = ord "\n" then
d1699 1
a1699 1
      else output (debug_out,"Can't open Clipboard\n")
d1712 1
a1712 1
        (output (debug_out,"Can't open Clipboard\n");
@


1.46
log
@Adding start/stop graphics functions
@
text
@d3 3
d144 2
d188 1
a188 1
  fun N n = MLWorks.Integer.makestring n
@


1.45
log
@Fixing problem with resizing
@
text
@d3 3
d1260 1
a1260 1
               dc : Windows.hdc,
d1265 3
a1267 1
        
d1269 22
a1290 1
      fun gp_dc (GP {dc,...}) = dc
d1292 8
a1299 2
      (* dcs are currently associated permanently with a gp *)
      fun release_gp_dc _ = ()
d1313 3
a1315 2
      fun with_highlighting (GP {dc,...},f,a) = 
        let
d1332 16
a1347 8
      fun redisplay (GP {window,dc = Windows.HDC dcw,...}) =
        (Windows.sendMessage (get_real window,Windows.WM_ERASEBKGND,
                               Windows.WPARAM dcw,
                               Windows.LPARAM Windows.nullWord);
         Windows.sendMessage (get_real window,Windows.WM_PAINT,
                              Windows.WPARAM Windows.nullWord,
                              Windows.LPARAM Windows.nullWord);
         ())
d1350 1
a1350 1
      fun reexpose (GP {window,dc = Windows.HDC dcw,...}) =
a1365 6
        let
          val dc = Windows.getDC (get_real widget)
          (* Need to set the dc background to be the same as the windows *)
          val background = Windows.getSysColor (Windows.COLOR_WINDOW)
        in
          Windows.setBkColor (dc,background);
d1367 1
a1367 1
              dc = dc,
a1371 1
        end
d1504 1
a1504 1
             draw (gp,REGION {x=0,y=0,width=1000,height=1000});
@


1.44
log
@Adding more scrollbar functionality to graphics ports
@
text
@d3 3
d1182 11
a1192 8
                                     fn (_,Windows.LPARAM lparam) => 
                                     let
                                       val width = Windows.loword lparam
                                       val height = Windows.hiword lparam
                                     in
                                       relayout (width,height);
                                       Option.SOME Windows.nullWord
                                     end)
@


1.43
log
@Fixing set_message_widget function
@
text
@d3 3
d1471 5
d1484 8
a1491 4
                (Windows.setScrollPos (window,Windows.SB_VERT,pos,true);
                 y_offset := pos;
                 (* redraw the whole lot on scrolling *)
                 redisplay gp)
d1497 1
a1497 1
                  then dochange (max (0,!y_offset - vinc))
d1499 5
a1503 1
                  then dochange (min (#2 (get_extents()),!y_offset + vinc))
d1514 8
a1521 5
                (Windows.setScrollPos (window,Windows.SB_HORZ,pos,true);
                 x_offset := pos;
                 (* redraw the whole lot on scrolling *)
                 redisplay gp)
                
d1526 1
a1526 1
                  then dochange (max (0,!x_offset - hinc))
d1528 5
a1532 1
                  then dochange (min (#1 (get_extents()),!x_offset + hinc))
@


1.42
log
@Fixing some problems
@
text
@d3 3
d676 5
a680 1
  val set_message_widget : Widget -> unit = env "nt set message widget"
@


1.41
log
@Fixing a newline in a message.
@
text
@d3 3
d191 10
a560 11
  (* Someone should do this efficiently! *)
  fun strip_string s =
    let
      fun aux [] = ""
        | aux (c::rest) =
          if ord c < ord " " then aux (rest)
          else implode (rev (c :: rest))
    in
      aux (rev (explode s))
    end

d572 2
a573 1
         styles = [Windows.WS_CHILD,Windows.WS_BORDER,Windows.WS_VSCROLL,
d581 1
a581 1
            val string = strip_string (munge_string (print_fn opts item))
d800 1
a800 1
                val string = strip_string (munge_string item)
@


1.40
log
@Changes to Windows structure
@
text
@d3 3
d842 1
a842 1
           else output (debug_out, "Set insertion position has failed" ^ N pos ^ " " ^ N p ^ "\\n")
@


1.39
log
@Changes to Windows structure
@
text
@d3 3
d147 3
a164 2
  fun print s = output (MLWorks.IO.terminal_out, s)
  fun print1 s = () (* output (MLWorks.IO.terminal_out, s) *)
d167 1
a167 1
  fun dummy s = output (MLWorks.IO.terminal_out, s ^ " unimplemented \n")
d608 1
a608 1
            print ("Selection of " ^ N item ^ "\n");
d621 1
a621 1
            print ("Double click of " ^ N item ^ "\n");
d625 1
a625 1
          print ("Event " ^ N event ^ " received for list\n")
d689 1
a689 1
     print "sub loop exited\n")
d826 1
a826 1
        (print1 ("set_selection " ^ N pos1 ^ ", " ^ N pos2 ^ "\n");
d1077 1
a1077 1
                  (print1 ("do_one: " ^ N width ^ " " ^ N height ^ " " ^ N y ^ "\n");
d1304 1
a1304 1
          val dc = Windows.getDc (get_real widget)
d1361 3
d1370 1
d1372 7
a1378 1
          Windows.fillRectangle (dc,x-xo,y-yo,x+width-xo,y+height-yo)
d1387 1
d1389 7
a1395 1
          Windows.clearRectangle (dc,x-xo,y-yo,x+width-xo,y+height-yo)
@


1.38
log
@Changes to Windows signature
@
text
@d3 3
d1426 1
a1426 1
            (Windows.validateClientArea window;
@


1.37
log
@Changed return type of make_scrolllist to a record, with an extra element
add_items.  Replaced set_bottom_pos with set_pos (which can be implemented
on windows).  Added add_items to the List structure.
@
text
@d3 5
d131 1
a131 1
              sharing type LabelStrings.AcceleratorFlag = Windows.AcceleratorFlag
d133 1
a133 1
              sharing type CapiTypes.Hwnd = Windows.Hwnd
d189 1
a189 1
      val window = Windows.main_init ()
d193 2
a194 2
      Windows.add_message_handler (window,Windows.WM_DESTROY,
                                   fn _ => (Windows.post_quit_message 0;
d199 1
a199 1
      Windows.add_message_handler (window,Windows.WM_CLOSE,
d201 1
a201 1
                                            Option.SOME (Windows.null_word)));
d203 1
a203 1
      Windows.add_command_handler (Windows.null_window,
d206 1
a206 1
      Windows.set_accelerator_table (Windows.create_accelerator_table (LabelStrings.accelerators));
d222 1
a222 1
      val string_word = Windows.make_c_string (munge_string s)
d224 2
a225 2
      Windows.send_message (get_real window,Windows.WM_SETTEXT,
                            Windows.WPARAM (Windows.null_word),
d231 2
a232 2
    (Windows.show_window (window,Windows.SW_SHOW);
     Windows.update_window window)
d235 1
a235 1
    Windows.show_window (get_real window,Windows.SW_HIDE)
d239 1
a239 1
      val window = Windows.create_window args
d246 1
a246 1
    | convert_name (_,name) = name
d296 7
a302 7
        Windows.create_window {class = class_name,
                               name = convert_name (class,name),
                               width = default_width,
                               height = class_height class,
                               parent = get_real parent,
                               menu = Windows.null_word,
                               styles = [Windows.WS_CHILD] @@ styles}
d318 1
a318 1
                         menu = Windows.null_word,
d335 1
a335 1
        Windows.create_window
d341 1
a341 1
         menu = Windows.null_word,
d364 1
a364 1
        Windows.create_window
d366 1
a366 1
         name = name,
d370 1
a370 1
         menu = Windows.null_word,
d380 1
a380 1
      Windows.add_message_handler (window,Windows.WM_DESTROY,
d390 1
a390 1
        Windows.create_window
d392 1
a392 1
         name = name,
d396 1
a396 1
         menu = Windows.null_word,
d403 1
a403 1
      val _ = Windows.register_popup_window (window)
d405 1
a405 1
        (Windows.unregister_popup_window window;
d408 1
a408 1
      Windows.add_message_handler (window,Windows.WM_DESTROY,destroy_handler);
d417 1
a417 1
        Windows.create_window
d419 1
a419 1
         name = LabelStrings.get_label name,
d423 1
a423 1
         menu = Windows.null_word,
d429 1
a429 1
      val _ = Windows.register_popup_window (window)
d431 1
a431 1
        (Windows.unregister_popup_window window;
d434 1
a434 1
      Windows.add_message_handler (window,Windows.WM_DESTROY,destroy_handler);
d441 1
a441 1
        Windows.create_window
d443 1
a443 1
         name = name,
d446 2
a447 2
         parent = Windows.null_window,
         menu = Windows.null_word,
d452 2
a453 2
      Windows.show_window (window,Windows.SW_SHOW);
      Windows.update_window window;
d459 1
a459 1
      val ml_window_proc = Windows.get_ml_window_proc()
d461 4
a464 4
        Windows.set_window_long (window,
                                 Windows.GWL_WNDPROC,
                                 ml_window_proc)
      fun is_alt_on w = Windows.is_alt_on w
d466 2
a467 2
        if despatch_text (window,chr (Windows.word_to_int wparam),is_alt_on wparam)
          then Option.SOME (Windows.null_word)
d471 1
a471 1
      Windows.add_new_window (window,original_window_proc);
d474 1
a474 1
      Windows.add_message_handler (window,Windows.WM_CHAR,
d478 1
a478 1
  val scrolled_text_id = Windows.new_control_id ()
d484 1
a484 1
         name = name,
d498 1
a498 1
        if event = Windows.word_to_int (Windows.message_to_word (Windows.EN_MAXTEXT))
d505 5
a509 5
      Windows.add_command_handler (get_real parent,scrolled_text_id,command_handler);
      Windows.send_message (window,
                            Windows.EM_LIMITTEXT,
                            Windows.WPARAM Windows.null_word,
                            Windows.LPARAM Windows.null_word);
d518 1
a518 1
         name = name,
d522 1
a522 1
         menu = Windows.null_word,
d536 1
a536 1
  val scrolllist_id = Windows.new_control_id ()
d555 1
a555 1
         name = name,
d569 1
a569 1
            val string_word = Windows.make_c_string string
d571 3
a573 3
            Windows.send_message (window,Windows.LB_ADDSTRING,
                                  Windows.WPARAM Windows.null_word,
                                  Windows.LPARAM string_word);
d581 3
a583 3
        (Windows.send_message (window,Windows.LB_RESETCONTENT,
                               Windows.WPARAM Windows.null_word,
                               Windows.LPARAM Windows.null_word);
d594 2
a595 2
              Windows.word_to_signed_int
		(Windows.send_message
d598 2
a599 2
		    Windows.WPARAM Windows.null_word,
                    Windows.LPARAM Windows.null_word))
d607 2
a608 2
              Windows.word_to_signed_int
		(Windows.send_message
d611 2
a612 2
                    Windows.WPARAM Windows.null_word,
                    Windows.LPARAM Windows.null_word))
d620 1
a620 1
      Windows.add_command_handler
d629 1
a629 1
  fun destroy window = Windows.destroy_window (get_real window)
d634 1
a634 1
  fun to_front window = Windows.bring_window_to_top (get_real window)
d637 1
a637 1
    Windows.add_message_handler (get_real from,Windows.WM_SETFOCUS,
d639 2
a640 2
                                 (Windows.set_focus (get_real to);
                                  Option.SOME Windows.null_word))
d648 1
a648 1
  fun set_focus w = (Windows.set_focus (get_real w); ())
d650 2
a651 2
  fun set_busy window = dummy "set_busy"
  fun unset_busy window = dummy "unset_busy"
d655 1
a655 1
      val Windows.RECT {left,top,right,bottom} = Windows.get_window_rect (get_real widget)
d663 14
d679 1
a679 1
       if Windows.do_input ()
d684 1
a684 1
  fun main_loop () = Windows.main_loop ()
d691 1
d693 1
a693 1
    (case Windows.open_file_dialog (get_real parent, mask)
d698 1
a698 1
    (case Windows.open_dir_dialog (get_real parent)
d703 1
a703 1
    case Windows.save_as_dialog (get_real parent)
d708 4
a711 4
    (Windows.message_beep Windows.MB_ICONQUESTION;
     Windows.message_box (get_real parent,message,"MLWorks",
                          [Windows.MB_OK,
                           Windows.MB_APPLMODAL]);
d715 1
a715 1
  fun beep widget = Windows.message_beep Windows.MB_OK
d742 2
a743 1
            print ("Can't convert callback " ^ print_callback callback ^ "\n")
d745 2
a746 2
            Windows.add_message_handler (get_real window,message,
                                         fn _ => (handler (); Option.NONE))
d756 4
a759 4
            Windows.word_to_signed_int (Windows.send_message (get_real list,
                                                              Windows.LB_GETCURSEL,
                                                              Windows.WPARAM Windows.null_word,
                                                              Windows.LPARAM Windows.null_word))
d769 4
a772 4
        (Windows.send_message (get_real list,
                               Windows.LB_SETCURSEL,
                               Windows.WPARAM (Windows.int_to_word (pos-1)),
                               Windows.LPARAM Windows.null_word);
d777 4
a780 4
        (Windows.send_message (get_real list,
                               Windows.LB_SETTOPINDEX,
                               Windows.WPARAM (Windows.int_to_word (pos-1)),
                               Windows.LPARAM Windows.null_word);
d788 1
a788 1
                val string_word = Windows.make_c_string string
d790 1
a790 1
                Windows.send_message
d793 1
a793 1
                   Windows.WPARAM Windows.null_word,
d804 4
a807 4
        Windows.word_to_signed_int (Windows.send_message (get_real text,
                                                          Windows.WM_GETTEXTLENGTH,
                                                          Windows.WPARAM Windows.null_word,
                                                          Windows.LPARAM Windows.null_word))
d810 4
a813 4
          val res = Windows.send_message (get_real text,
                                          Windows.EM_GETSEL,
                                          Windows.WPARAM Windows.null_word,
                                          Windows.LPARAM Windows.null_word)
d820 5
a824 5
         Windows.send_message (get_real text,
                               Windows.EM_SETSEL,
                               Windows.WPARAM (Windows.int_to_word pos1),
                               Windows.LPARAM (Windows.int_to_word pos2));
        ())
d831 2
a832 1
           if p = pos then () else output (debug_out, "Set insertion position has failed\n")
d837 1
a837 1
          val string_word = Windows.make_c_string (munge_string str)
d840 4
a843 4
          Windows.send_message (get_real text,
                                Windows.EM_REPLACESEL,
                                Windows.WPARAM Windows.null_word,
                                Windows.LPARAM string_word);
d849 1
a849 1
          val string_word = Windows.make_c_string (munge_string str)
d852 4
a855 4
          Windows.send_message (get_real text,
                                Windows.EM_REPLACESEL,
                                Windows.WPARAM Windows.null_word,
                                Windows.LPARAM string_word);
d866 3
a868 3
          val _ = Windows.send_message (get_real text,
                                        Windows.WM_GETTEXT,
                                        Windows.WPARAM (Windows.int_to_word (size+1)), (* add 1 for the last null character *)
d870 2
a871 2
          val _ = Windows.set_byte (buffer,size,0) (* null terminate *) (* probably not necessary *)
          val result = Windows.word_to_string buffer
d886 4
a889 4
          val res = Windows.send_message (get_real text,
                                          Windows.EM_GETSEL,
                                          Windows.WPARAM Windows.null_word,
                                          Windows.LPARAM Windows.null_word)
d898 1
a898 1
          val string_word = Windows.make_c_string ""
d900 4
a903 4
          Windows.send_message (get_real text,
                                Windows.EM_REPLACESEL,
                                Windows.WPARAM Windows.null_word,
                                Windows.LPARAM string_word);
d961 1
a961 1
      fun add_modify_verify _ = dummy "add_modify_verify"
d966 4
a969 4
        (Windows.send_message (get_real text,
                               Windows.WM_CUT,
                               Windows.WPARAM Windows.null_word,
                               Windows.LPARAM Windows.null_word);
d973 5
a977 6
        (Windows.send_message (get_real text,
                               Windows.WM_PASTE,
                               Windows.WPARAM Windows.null_word,

                               Windows.LPARAM Windows.null_word);
         ())
d980 5
a984 5
        (Windows.send_message (get_real text,
                               Windows.WM_COPY,
                               Windows.WPARAM Windows.null_word,
                               Windows.LPARAM Windows.null_word);
         ())
d988 3
a990 2
      val text_limit = 10000
      val text_chunk = 2000
d992 1
a992 2
      fun check_insertion (text,str,current,marks) = ()
(*
d999 4
a1002 4
            (Windows.send_message (text,
                                   Windows.WM_SETREDRAW,
                                   Windows.WPARAM (Windows.int_to_word 0),
                                   Windows.LPARAM Windows.null_word);
d1005 4
a1008 4
             Windows.send_message (text,
                                   Windows.WM_SETREDRAW,
                                   Windows.WPARAM (Windows.int_to_word 1),
                                   Windows.LPARAM Windows.null_word);
a1010 1
*)
d1027 2
a1028 2
          val Windows.RECT {left,top,...} = Windows.get_window_rect window
          val parent = Windows.get_parent window
d1030 1
a1030 1
          if Windows.is_null_window parent
d1034 1
a1034 1
              val Windows.POINT{x,y,...} = Windows.screen_to_client (parent,Windows.POINT {x=left,y=top})
d1044 2
a1045 2
            if not (Windows.is_null_window subwindow) andalso
              Windows.get_parent subwindow = realw (* only do this for direct subwindows *)
d1049 1
a1049 1
          Windows.enum_child_windows (realw,g)
d1068 1
a1068 1
              if not (Windows.is_null_window child)
d1071 1
a1071 1
                   Windows.move_window (child,0,y,width,height,true);
d1090 1
a1090 1
                        Windows.move_window (get_real subwindow,0,!yref,width,height,true);
d1103 1
a1103 1
          val Windows.RECT {right=cright,bottom=cbottom,...} = Windows.get_client_rect (get_real parent)
d1110 1
a1110 1
                if Windows.is_null_window (get_real window)
d1117 1
a1117 1
                    Windows.move_window(get_real window,0,!yref,width,newh,true);
d1142 1
a1142 1
                         (Windows.move_window (get_real subwindow,0,!yref,width,!height_ref,true);
d1153 1
a1153 1
          Windows.move_window (get_real parent,x,y,total_width+w-cright,total_height+h-cbottom,true);
d1155 9
a1163 9
          Windows.add_message_handler (get_real parent,Windows.WM_SIZE,
                                       fn (_,Windows.LPARAM lparam) => 
                                       let
                                         val width = Windows.loword lparam
                                         val height = Windows.hiword lparam
                                       in
                                         relayout (width,height);
                                         Option.SOME Windows.null_word
                                       end)
a1194 5
          val Windows.RECT {left=pleft,top=ptop,right=pright,bottom=pbottom} =
            Windows.get_window_rect (get_real parent)
          val Windows.RECT {left,top,...} = 
            Windows.get_window_rect (get_real shell)
          (* These should be some sort of global parameters *)
d1197 1
d1199 1
a1199 1
          Windows.move_window (get_real shell,left,top,width,height,false)
a1200 1
         
d1228 1
a1228 1
               dc : Windows.HDC,
d1254 4
a1257 4
          val old_fg = Windows.set_text_color (dc,Windows.get_bk_color dc);
          val old_bg = Windows.set_bk_color (dc,old_fg);
          fun undo _ = (Windows.set_text_color (dc,old_fg);
                        Windows.set_bk_color (dc,old_bg))
d1271 1
a1271 1
        (Windows.send_message (get_real window,Windows.WM_ERASEBKGND,
d1273 4
a1276 4
                               Windows.LPARAM Windows.null_word);
         Windows.send_message (get_real window,Windows.WM_PAINT,
                               Windows.WPARAM Windows.null_word,
                               Windows.LPARAM Windows.null_word);
d1281 3
a1283 3
        (Windows.post_message (get_real window,Windows.WM_PAINT,
                               Windows.WPARAM Windows.null_word,
                               Windows.LPARAM Windows.null_word);
d1297 1
a1297 1
          val dc = Windows.get_dc (get_real widget)
d1299 1
a1299 1
          val background = Windows.get_sys_color (Windows.COLOR_WINDOW)
d1301 1
a1301 1
          Windows.set_bk_color (dc,background);
d1304 1
a1304 1
              name = name,
d1315 1
a1315 1
          val (width,height) = Windows.get_text_extent_point (dc,string)
d1333 2
a1334 2
          Windows.move_to (dc,x-xo,y-yo,Windows.null_word);
          Windows.line_to (dc,x'-xo,y'-yo)
d1347 5
a1351 5
          Windows.move_to (dc,x-xo,y-yo,Windows.null_word);
          Windows.line_to (dc,x+width-xo,y-yo);
          Windows.line_to (dc,x+width-xo,y+height-yo);
          Windows.line_to (dc,x-xo,y+height-yo);
          Windows.line_to (dc,x-xo,y-yo)
d1361 1
a1361 1
          Windows.fill_rectangle (dc,x-xo,y-yo,x+width-xo,y+height-yo)
d1371 1
a1371 1
          Windows.clear_rectangle (dc,x-xo,y-yo,x+width-xo,y+height-yo)
d1382 1
a1382 1
          Windows.text_out (dc,x-xo,y-yo,string)
d1397 1
a1397 1
                             name = name,
d1401 1
a1401 1
                             menu = Windows.null_word,
d1414 1
a1414 1
                then Windows.set_scroll_range (window,Windows.SB_HORZ,0,max (0,x-w),true)
d1417 1
a1417 1
                then Windows.set_scroll_range (window,Windows.SB_VERT,0,max (0,y-h),true)
d1423 1
a1423 1
            (Windows.validate_client_area window;
d1425 1
a1425 1
             Option.SOME Windows.null_word)
d1439 1
a1439 1
                (Windows.set_scroll_pos (window,Windows.SB_VERT,pos,true);
d1445 1
a1445 1
                if code = Windows.convert_sb_value Windows.SB_THUMBPOSITION
d1447 1
a1447 1
                else if code = Windows.convert_sb_value Windows.SB_LINEUP
d1449 1
a1449 1
                else if code = Windows.convert_sb_value Windows.SB_LINEDOWN
d1453 1
a1453 1
              Option.SOME Windows.null_word
d1461 1
a1461 1
                (Windows.set_scroll_pos (window,Windows.SB_HORZ,pos,true);
d1467 1
a1467 1
                if code = Windows.convert_sb_value Windows.SB_THUMBPOSITION
d1469 1
a1469 1
                else if code = Windows.convert_sb_value Windows.SB_LINELEFT 
d1471 1
a1471 1
                else if code = Windows.convert_sb_value Windows.SB_LINERIGHT
d1475 1
a1475 1
              Option.SOME Windows.null_word
d1492 1
a1492 1
                then Windows.set_scroll_pos (window,Windows.SB_HORZ,new_xi,true) 
d1495 1
a1495 1
                then Windows.set_scroll_pos (window,Windows.SB_VERT,new_yi,true) 
d1513 1
a1513 1
          Windows.add_message_handler (window,Windows.WM_PAINT,draw_handler);
d1515 1
a1515 1
            then Windows.add_message_handler (window,Windows.WM_VSCROLL,vscroll_handler) 
d1518 1
a1518 1
            then Windows.add_message_handler (window,Windows.WM_HSCROLL,hscroll_handler) 
d1520 4
a1523 4
          Windows.add_message_handler (window,Windows.WM_SIZE,
                                       fn _ => 
                                       (set_scrollbars ();
                                        Option.SOME Windows.null_word));
d1542 1
a1542 1
              Option.SOME Windows.null_word
d1545 2
a1546 2
          Windows.add_message_handler (window,Windows.WM_LBUTTONDOWN,mouse_handler (Event.LEFT));
          Windows.add_message_handler (window,Windows.WM_RBUTTONDOWN,mouse_handler (Event.RIGHT))
d1586 1
a1586 1
      if Windows.open_clipboard (window)
d1588 3
a1590 3
          (Windows.empty_clipboard ();
           Windows.set_clipboard_data s;
           Windows.close_clipboard ())
d1595 1
a1595 1
    if Windows.open_clipboard (Windows.null_window)
d1598 2
a1599 2
          val result = Windows.get_clipboard_data ()
          val _ = Windows.close_clipboard ()
d1608 1
a1608 1
    if Windows.open_clipboard (get_real widget)
d1611 2
a1612 2
          val result = Windows.get_clipboard_data ()
          val _ = Windows.close_clipboard ()
@


1.36
log
@Changing type of [set/get]_window_long
@
text
@d3 3
d533 11
d555 2
a556 2
         styles = [Windows.WS_CHILD,Windows.WS_BORDER,Windows.WS_VSCROLL,Windows.LBS_NOTIFY,
                   Windows.LBS_NOINTEGRALHEIGHT]}
d558 3
a560 16
      (* Someone should do this efficiently! *)
      fun strip s =
        let
          fun aux [] = ""
            | aux (c::rest) =
              if ord c < ord " " then aux (rest)
              else implode (rev (c :: rest))
        in
          aux (rev (explode s))
        end
      fun set_items opts items =
        (* Clear the list widget, and then reset *)
        (Windows.send_message (window,Windows.LB_RESETCONTENT,
                               Windows.WPARAM Windows.null_word,
                               Windows.LPARAM Windows.null_word);
         Lists.iterate
d563 1
a563 1
            val string = strip (munge_string (print_fn opts item))
d572 13
a584 3
         items_ref := items)
      val select_fn' = select_fn (widget,widget,set_items)
      val action_fn' = action_fn (widget,widget,set_items)
d586 28
a613 30
        if event = 1 (* MAGIC NUMBER = LBN_SELCHANGE *)
          then
            let
              val item =
                Windows.word_to_signed_int (Windows.send_message (window,
                                                                  Windows.LB_GETCURSEL,
                                                                  Windows.WPARAM Windows.null_word,
                                                                  Windows.LPARAM Windows.null_word))
            in
              print ("Selection of " ^ N item ^ "\n");
              if item >= 0
                then select_fn' (Lists.nth (item,!items_ref))
              else ()
            end
        else if event = 2 (* MAGIC NUMBER = LBN_DBLCLK *)
               then
                 let
                   val item =
                     Windows.word_to_signed_int (Windows.send_message (window,
                                                                       Windows.LB_GETCURSEL,
                                                                       Windows.WPARAM Windows.null_word,
                                                                       Windows.LPARAM Windows.null_word))
                 in
                   print ("Double click of " ^ N item ^ "\n");
                   if item >= 0
                     then action_fn' (Lists.nth (item,!items_ref))
                   else ()
                 end
             else
               print ("Event " ^ N event ^ " received for list\n")
d615 3
a617 2
      Windows.add_command_handler (get_real parent,scrolllist_id,select_handler);
      (widget,widget,set_items)
d744 1
d754 24
a777 2
      (* "sets the item to be the last visible in the list widget" *)
      fun set_bottom_pos (list,pos) = dummy "set_bottom_pos";
d1158 1
a1158 1
      val (scroll,_,setitems) =
d1165 1
d1191 1
a1191 1
         setitems () items;
@


1.35
log
@Changing representation of Widgets
@
text
@d3 3
d454 1
a454 1
                                 Windows.convert_gwl_value (Windows.GWL_WNDPROC),
@


1.34
log
@Changing default height of graph panes
@
text
@d3 3
d109 1
d117 1
d121 2
a122 1
	      sharing type Menus.Widget = Windows.Hwnd
d136 1
a136 1
  type Widget = Windows.Hwnd
d179 1
d181 1
a181 1
      push ((window,title),main_windows);
d189 1
a189 1
                                   fn _ => (Menus.exit_dialog (window,window,false);
d194 1
a194 1
                                   fn _ => (Menus.exit_dialog (window,window,false)));
d196 1
a196 1
      window
d213 1
a213 1
      Windows.send_message (window,Windows.WM_SETTEXT,
d224 1
a224 1
    Windows.show_window (window,Windows.SW_HIDE)
d269 1
a269 1
          if window = window'
d289 1
a289 1
                               parent = parent,
d292 1
d294 2
a295 2
      class_postaction (window,class);
      window
d306 1
a306 1
                         parent = parent,
d309 2
d312 2
a313 2
      class_postaction (window,class);
      window
d329 1
a329 1
         parent = parent,
d334 1
a334 1
      window
d358 1
a358 1
         parent = parent, (* This will be the windows owner *)
d361 1
d364 1
a364 1
          then Option.SOME (make_context_label window)
d367 2
a368 2
      set_text (window,title);
      push ((window,title),main_windows);
d370 1
a370 1
                                   fn _ => (remove_main_window window;
d372 1
a372 1
      (window,window,window,label_window)
d384 1
a384 1
         parent = parent, (* This will be the windows owner *)
d387 1
d390 1
a390 1
          then Option.SOME (make_context_label window)
d398 2
a399 2
      set_text (window,title);
      (window,window,window,label_window)
d411 1
a411 1
         parent = parent, (* This will be the windows owner, it should be a top level window *)
d424 1
a424 1
      window
d438 1
d440 1
a440 1
      set_text (window,title);
d443 1
a443 1
      window
d476 1
a476 1
         parent = parent,
d490 1
d492 1
a492 1
      set_text (window,"");
d494 1
a494 1
      Windows.add_command_handler (parent,scrolled_text_id,command_handler);
d499 1
a499 1
      (window,window)
d510 1
a510 1
         parent = parent,
d518 1
d520 2
a521 2
      set_text (window,"");
      (window,window)
d536 1
a536 1
         parent = parent,
d540 1
d569 2
a570 2
      val select_fn' = select_fn (window,window,set_items)
      val action_fn' = action_fn (window,window,set_items)
d603 2
a604 2
      Windows.add_command_handler (parent,scrolllist_id,select_handler);
      (window,window,set_items)
d611 1
a611 1
  fun destroy window = Windows.destroy_window window
d613 1
a613 1
  fun initialize_toplevel window = reveal window
d616 1
a616 1
  fun to_front window = Windows.bring_window_to_top window
d619 1
a619 1
    Windows.add_message_handler (from,Windows.WM_SETFOCUS,
d621 1
a621 1
                                 (Windows.set_focus to;
d630 1
a630 1
  fun set_focus w = (Windows.set_focus w; ())
a631 1
  val parent = Windows.get_parent
d637 1
a637 1
      val Windows.RECT {left,top,right,bottom} = Windows.get_window_rect widget
d660 1
a660 1
    (case Windows.open_file_dialog (parent, mask)
d665 1
a665 1
    (case Windows.open_dir_dialog parent
d670 1
a670 1
    case Windows.save_as_dialog parent
d676 1
a676 1
     Windows.message_box (parent,message,"MLWorks",
d711 1
a711 1
            Windows.add_message_handler (window,message,
d721 5
a725 4
          val result = Windows.word_to_signed_int (Windows.send_message (list,
                                                                         Windows.LB_GETCURSEL,
                                                                         Windows.WPARAM Windows.null_word,
                                                                         Windows.LPARAM Windows.null_word))
d734 1
a734 1
        (Windows.send_message (list,
d747 1
a747 1
        Windows.word_to_signed_int (Windows.send_message (text,
d753 1
a753 1
          val res = Windows.send_message (text,
d763 1
a763 1
         Windows.send_message (text,
d782 1
a782 1
          Windows.send_message (text,
d794 1
a794 1
          Windows.send_message (text,
d808 1
a808 1
          val _ = Windows.send_message (text,
d828 1
a828 1
          val res = Windows.send_message (text,
d842 1
a842 1
          Windows.send_message (text,
d908 1
a908 1
        (Windows.send_message (text,
d915 1
a915 1
        (Windows.send_message (text,
d923 1
a923 1
        (Windows.send_message (text,
d970 1
d986 1
d989 2
a990 2
              Windows.get_parent subwindow = w (* only do this for direct subwindows *)
              then f subwindow
d993 1
a993 1
          Windows.enum_child_windows (w,g)
d1009 10
a1018 6
            if not (Windows.is_null_window child)
              then
                (print1 ("do_one: " ^ N width ^ " " ^ N height ^ " " ^ N y ^ "\n");
                 Windows.move_window (child,0,y,width,height,true);
                 (max (width,maxwidth),y+height))
            else (maxwidth,y)
d1034 1
a1034 1
                        Windows.move_window (subwindow,0,!yref,width,height,true);
d1047 1
a1047 1
          val Windows.RECT {right=cright,bottom=cbottom,...} = Windows.get_client_rect parent
d1054 1
a1054 1
                if Windows.is_null_window window
d1061 1
a1061 1
                    Windows.move_window(window,0,!yref,width,newh,true);
d1086 1
a1086 1
                         (Windows.move_window (subwindow,0,!yref,width,!height_ref,true);
d1097 1
a1097 1
          Windows.move_window (parent,x,y,total_width+w-cright,total_height+h-cbottom,true);
d1099 1
a1099 1
          Windows.add_message_handler (parent,Windows.WM_SIZE,
d1139 1
a1139 1
            Windows.get_window_rect parent
d1141 1
a1141 1
            Windows.get_window_rect shell
d1146 1
a1146 1
          Windows.move_window (shell,left,top,width,height,false)
d1155 1
a1155 1
         reveal form;
d1219 1
a1219 1
        (Windows.send_message (window,Windows.WM_ERASEBKGND,
d1222 1
a1222 1
         Windows.send_message (window,Windows.WM_PAINT,
d1229 1
a1229 1
        (Windows.post_message (window,Windows.WM_PAINT,
d1245 1
a1245 1
          val dc = Windows.get_dc widget
a1311 1
(*
a1320 1
*)
d1348 1
a1348 1
                             parent = parent,
d1351 2
a1352 1
          val gp = make_gp (name,title,window)
d1358 1
a1358 1
              val (w,h) = widget_size window
d1434 1
a1434 1
              val (ww,wh) = widget_size window
d1451 1
a1451 1
              val (ww,wh) = widget_size window
d1473 1
a1473 1
          (window,
d1483 1
d1530 11
a1540 7
  fun clipboard_set (window,s) = 
    if Windows.open_clipboard (window)
      then
        (Windows.empty_clipboard ();
         Windows.set_clipboard_data s;
         Windows.close_clipboard ())
    else output (debug_out,"Can't open Clipboard\n")
d1555 2
a1556 2
  fun clipboard_empty window =
    if Windows.open_clipboard (window)
d1565 7
@


1.33
log
@Trying to fix with_highlighting
@
text
@d3 3
d233 1
d1114 14
d1129 2
a1130 1
        (select_fn_ref := select_fn;
a1322 1
          val (w,h) = get_extents ()
d1326 2
a1327 2
                             width = w,
                             height = h,
@


1.32
log
@Send WM_LIMITTEXT to edit windows.
@
text
@d3 3
d1157 2
a1158 1
      (* This doesn't work -- rop2 mode only affects filled shapes *)
d1161 5
a1165 2
          val old_mode = Windows.set_rop2 (dc,Windows.R2_BLACK)
          val result = f a handle exn => (Windows.set_rop2 (dc,old_mode); raise exn)
d1167 1
a1167 1
          Windows.set_rop2 (dc,old_mode);
@


1.31
log
@Adding insertion checks for the benefit of Windows
@
text
@d3 3
d474 4
d911 2
a912 1
      fun check_insertion (text,str,current,marks) =
d931 1
@


1.30
log
@Removed use of FileDialog structure, incorporating the definitions directly
in this file instead.
@
text
@d3 4
d888 1
d901 22
@


1.29
log
@Moved list_select in from _gui_utils
@
text
@d3 3
a90 1
require "../gui/file_dialog";
a97 1
              structure FileDialog : FILE_DIALOG
d103 1
a103 1
	      sharing type FileDialog.Widget = Menus.Widget = Windows.Hwnd
d621 19
a639 2
  (* This defines the FileType datatype and the find_file function. *)
  open FileDialog
@


1.28
log
@Adding "exit" command for all windows -- used for accelerators.
@
text
@d3 3
d1026 42
@


1.27
log
@Fixing bungle with previous fix
@
text
@d3 3
d100 1
d167 4
d383 5
a387 1
         styles = [Windows.WS_OVERLAPPED_WINDOW]} (* Should this be WS_POPUP? *)
@


1.26
log
@Fixing some bugs
@
text
@d3 3
d158 2
d162 1
a162 1
                                            Option.NONE));
@


1.25
log
@Adding color functions
@
text
@d3 3
d80 1
d90 2
d93 1
a93 1
	      sharing type FileDialog.Widget = Windows.Hwnd
d153 4
@


1.24
log
@Changing message handling
@
text
@d3 3
d1070 13
a1082 6
        GP {window = widget,
            dc = Windows.get_dc widget,
            name = name,
            title = title,
            x_offset = ref 0,
            y_offset = ref 0}
@


1.23
log
@FileDialog now includes a datatype that also needs to be included here.
@
text
@d3 3
d142 3
a209 26
  val subclass_window_procs = ref []

  (* This finds an ML window procedure to call *)
  fun window_despatch (window,message,wparam,lparam) =
    let
      fun scan [] = Option.NONE
        | scan ((window',handler)::rest) =
          if window = window'
            then handler (window,message,wparam,lparam)
          else scan rest
    in
      scan (!subclass_window_procs)
    end

  fun ml_window_procedure (window,message,wparam,lparam) =
    (case window_despatch (window,message,wparam,lparam) of
       Option.NONE => 
         Windows.despatch_message (window,message,wparam,lparam)
     | result => result)
       (* handle _ => 
      (print "exception caught in ml_window_procedure\n";
       Option.SOME (Windows.null_word)) *)

  val _ = output (debug_out,"Resetting window procedure\n")
  val _ = Windows.set_ml_window_proc (ml_window_procedure)

d316 1
a316 1
                                            Windows.null_word));
d339 1
a339 1
         Windows.null_word)
d361 1
a361 1
         Windows.null_word)
d387 1
a387 2
      (* Don't do this at top level cos it might change *)
      val simple_window_proc = Windows.get_simple_window_proc()
d391 4
a394 7
                                 simple_window_proc)
      fun is_alt_on w =
        Windows.is_alt_on w
      fun ml_window_proc (window,message,Windows.WPARAM wparam,Windows.LPARAM lparam) =
        if Windows.word_to_int message = 
          Windows.word_to_int (Windows.message_to_word (Windows.WM_CHAR))
          andalso despatch_text (window,chr (Windows.word_to_int wparam),is_alt_on wparam)
d397 1
a397 3
          Option.SOME (Windows.call_window_proc (original_window_proc,
                                                 (window,message,
                                                  Windows.WPARAM wparam,Windows.LPARAM lparam)))
d399 5
a403 1
      subclass_window_procs := (window,ml_window_proc) :: !subclass_window_procs
d554 1
a554 1
                                  Windows.null_word))
d607 1
d628 1
a628 1
                                         fn _ => (handler (); Windows.null_word))
d990 1
a990 1
                                         Windows.null_word
d1191 1
a1191 1
             Windows.null_word)
d1219 1
a1219 1
              Windows.null_word
d1241 1
a1241 1
              Windows.null_word
d1289 1
a1289 1
                                        Windows.null_word));
d1307 1
a1307 1
              Windows.null_word
@


1.22
log
@Adding extra text functions
@
text
@d3 3
d81 1
d609 2
a610 1
  fun find_file _ = (dummy "find_file"; Option.NONE)
@


1.21
log
@Adding clipboard functionality
@
text
@d3 3
d838 23
d1363 2
a1364 2
  fun clipboard_set s = 
    if Windows.open_clipboard (Windows.null_window)
d1371 1
a1371 1
  fun clipboard_get _ =
d1378 1
a1378 1
          result
d1382 1
a1382 4
         "")

  fun clipboard_empty _ =
    clipboard_get () = ""
d1384 10
@


1.20
log
@Fixing slight bungle in make_scrolllist
@
text
@d3 3
d1337 23
a1359 4
  val clipboard_ref = ref ""
  fun clipboard_set s = clipboard_ref := s
  fun clipboard_get _ = !clipboard_ref
  fun clipboard_empty _ = !clipboard_ref = ""
@


1.19
log
@More stuff
@
text
@d3 3
d346 4
d351 1
d356 1
d358 18
a375 8
    Windows.create_window
    {class = "Toplevel",
     name = LabelStrings.get_label name,
     width = toplevel_width,
     height = toplevel_height,
     parent = parent, (* This will be the windows owner, it should be a top level window *)
     menu = Windows.null_word,
     styles = [Windows.WS_OVERLAPPED_WINDOW]} (* Should this be WS_POPUP? *)
d547 1
a547 1
      Windows.add_command_handler (window,scrolllist_id,select_handler);
d618 21
a638 1
      fun add (w,t,f) = dummy "callback add"
@


1.18
log
@More stuff on command handlers
@
text
@d3 3
d68 1
d73 2
d126 1
d199 1
a199 3
            then
              (print1 "Calling window handler\n";
               handler (window,message,wparam,lparam))
d214 1
a214 1
  val _ = output (std_out,"Resetting window procedure\n")
a222 3
(*
      val _ = output (std_out,"despatch_text: " ^ String.ml_string (char,~1) ^ "\n")
*)
d322 1
a322 1
                                   fn _ => (main_windows := delete (parent,!main_windows);
a323 4
(*
      Windows.show_window (window,Windows.SW_SHOW);
      Windows.update_window window;
*)
d399 1
d409 1
a409 1
         menu = Windows.null_word,
d415 7
d425 1
d450 3
a454 1
      val id = Windows.new_control_id ()
d463 1
a463 1
         menu = id,
d528 1
a528 1
      Windows.add_command_handler (id,select_handler);
d543 6
d555 1
a555 1
  fun set_focus w = ()
d637 10
d656 6
a661 1
        set_selection (text,~1,pos)
a686 10
      fun get_insertion_position text =
        let
          val res = Windows.send_message (text,
                                          Windows.EM_GETSEL,
                                          Windows.WPARAM Windows.null_word,
                                          Windows.LPARAM Windows.null_word)
        in
          Windows.hiword res
        end

d723 1
a861 1
                    val _ = print1 "Doing paned window\n"
d1076 1
d1086 1
d1228 6
a1233 2
          if want_vscroll then Windows.add_message_handler (window,Windows.WM_VSCROLL,vscroll_handler) else ();
          if want_hscroll then Windows.add_message_handler (window,Windows.WM_HSCROLL,hscroll_handler) else ();
@


1.17
log
@Improving Windows menu
@
text
@d3 3
d106 8
d116 6
a121 1
    Windows.main_init ()
d209 1
d218 3
a299 2
  fun get_main_windows _ = []

d318 4
d703 10
a712 1
      fun remove_selection text = set_selection (text,~1,~1)
d714 47
a760 4
      fun get_line_and_index (text,pos) = (dummy "get_line_and_index";("",0))
      fun current_line (text,pos) = (dummy "current_line"; 0)
      fun end_line (text,pos) = (dummy "end_line"; 0)
      fun get_line (text,pos) = (dummy "get_line"; "")
d769 3
@


1.16
log
@Adding (dummy) get_main_windows
@
text
@@


1.15
log
@Extending for graphics
@
text
@d3 3
d280 2
d1187 10
@


1.14
log
@Add Resize callback.
@
text
@d3 3
d156 7
d195 2
a196 1
  fun despatch_text (window,char) =
a197 1
      (* val _ = print ("Text gets WM_CHAR: " ^ String.ml_string (char,100) ^ "\n") *)
d201 1
a201 1
            then handler (char,[])
d359 2
d362 3
a364 2
        if Windows.word_to_int message = Windows.word_to_int (Windows.message_to_word (Windows.WM_CHAR))
          andalso despatch_text (window,chr (Windows.word_to_int wparam))
d367 3
a369 1
          Option.SOME (Windows.call_window_proc (original_window_proc,(window,message,Windows.WPARAM wparam,Windows.LPARAM lparam)))
a549 17
  structure Event = 
    struct
      type Event = int
      type Modifier = int
      datatype Button = LEFT | RIGHT | OTHER
      fun get_button_data event =
        unimplemented "get_button_data"
      val meta_modifier = 0
      fun get_key_data event =
        unimplemented "get_key_data"
      fun get_button_data event =
        unimplemented "get_button_data"
      datatype EventType = KeyPress | ButtonPress | Other
      fun get_event_type event =
        unimplemented "get_event_type"
    end

a551 1
      type CallbackData = int
d553 4
a556 10
	Activate
      | Destroy
      | ModifyVerify
      | Unmap
      | Input
      | Resize
      fun convert_verify_data data =
        unimplemented "convert_verify_data"
      fun get_event data =
        unimplemented "get_event"
d688 2
a840 1
  (* Lets not worry about this lot just yet *)
d845 2
a846 1
          
d848 3
a850 1
        GP of {name : string,
d855 9
a863 3
      fun gp_widget _ = (dummy "gp_widget";Windows.null_window)
      fun initialize_gp _ = dummy "initialize_gp"
      fun is_initialized _ = false
d865 1
d867 1
a867 1
          POINT{x=(!x_offset),y=(!y_offset)}
d871 36
a906 3
      fun with_highlighting (gp,f,a) = f a
      fun clear_clip_region (GP{...}) = ()
      fun set_clip_region (GP {...},REGION{x,y,width,height}) =
d908 4
a911 2
      fun redisplay (GP {...}) = ()
      fun copy_gp_region (GP{...},GP{...},REGION{x=x1,y=y1,width,height},POINT{x=x2,y=y2}) = ()
d913 9
a921 1
        (dummy "make_gp"; GP{name = "",title="",x_offset=ref 0,y_offset=ref 0})
d923 75
a997 7
        {ascent=0,descent=0,font_ascent=0,font_descent=0,lbearing=0,rbearing=0,width=0}
      fun draw_point (gp,POINT{x,y}) = ()
      fun draw_line (gp,POINT{x,y},POINT{x=x',y=y'}) = ()
      fun draw_rectangle (gp,REGION{x,y,width,height}) = ()
      fun draw_fill_rectangle (gp,REGION{x,y,width,height}) = ()
      fun draw_image_string (gp,string,POINT{x,y}) = ()
      fun draw_arc (gp,REGION{x,y,width,height},theta1,theta2) = ()
d999 31
a1029 8
				  (want_hscroll, want_vscroll), parent) =
        (dummy "make_graphics";
         (Windows.null_window,
          GP{name="",title="",x_offset=ref 0,y_offset=ref 0},
          fn () => (),
          fn(_) => ()
         )
        )
d1031 123
@


1.13
log
@Adding mod. to make_graphics.
@
text
@d3 3
d555 7
a561 1
      datatype Type = Activate | Destroy | ModifyVerify | Unmap | Input
@


1.12
log
@Adding dummy `with_graphics_port' functions and associated functions.
@
text
@d3 3
d879 6
a884 1
         (Windows.null_window,GP{name="",title="",x_offset=ref 0,y_offset=ref 0},fn () => ()))
@


1.11
log
@Added dummy Capi.Text.set_highlight function.
@
text
@d3 3
d58 2
d862 1
a862 1
      fun copy_gp (GP{...},GP{...},REGION{x=x1,y=y1,width,height},POINT{x=x2,y=y2}) = ()
d873 1
a873 1
      fun make_scrolled_graphics (name,title,draw,get_extents,
d875 1
a875 1
        (dummy "make_scrolled_graphics";
d877 28
@


1.10
log
@Make scroll bars on graphics ports optional.
@
text
@d3 3
d654 3
@


1.9
log
@Updating by adding Capi Point/Region datatypes.
@
text
@d3 3
d862 2
a863 1
      fun make_scrolled_graphics (name,title,draw,get_extents,parent) =
@


1.8
log
@Changing top level window initialization
@
text
@d3 3
d45 4
d838 4
a841 2
      fun get_offset (GP {x_offset,y_offset,...}) = (!x_offset,!y_offset)
      fun set_offset (GP {x_offset,y_offset,...},x,y) = (x_offset := max (x,0); y_offset:= max (y,0))
d845 1
a845 1
      fun set_clip_region (GP {...},(x,y,width,height)) =
d848 1
a848 1
      fun copy_gp (GP{...},GP{...},x1,y1,width,height,x2,y2) = ()
d853 6
a858 6
      fun draw_point (gp,x,y) = ()
      fun draw_line (gp,x,y,x',y') = ()
      fun draw_rectangle (gp,x,y,w,h) = ()
      fun draw_fill_rectangle (gp,x,y,w,h) = ()
      fun draw_image_string (gp,string,x,y) = ()
      fun draw_arc (gp,x,y,width,height,theta1,theta2) = ()
@


1.7
log
@Changing use of word_to_int
@
text
@d3 3
d462 3
a464 1
  fun initialize window = ()
@


1.6
log
@Improving event handling
@
text
@d3 3
d145 7
a151 4
    case window_despatch (window,message,wparam,lparam) of
      MLWorks.Option.NONE => 
        Windows.despatch_message (window,message,wparam,lparam)
    | result => result
a169 20
  fun text_subclass window =
    let
      (* Don't do this at top level cos it might change *)
      val simple_window_proc = Windows.get_simple_window_proc()
      val original_window_proc =
        Windows.set_window_long (window,
                                 Windows.convert_gwl_value (Windows.GWL_WNDPROC),
                                 simple_window_proc)
      fun ml_window_proc (window,message,Windows.WPARAM wparam,Windows.LPARAM lparam) =
        ((* print ("in text window proc, message: " ^ N (Windows.word_to_int message) ^ "\n"); *)
         (* This should use the generic message handling that I have just implemented *)
         if Windows.word_to_int message = Windows.word_to_int (Windows.message_to_word (Windows.WM_CHAR))
           andalso despatch_text (window,chr (Windows.word_to_int wparam))
           then Option.SOME (Windows.null_word)
         else
           Option.SOME (Windows.call_window_proc (original_window_proc,(window,message,Windows.WPARAM wparam,Windows.LPARAM lparam))))
    in
      subclass_window_procs := (window,ml_window_proc) :: !subclass_window_procs
    end

d314 18
d353 21
d423 4
a426 4
                Windows.word_to_int (Windows.send_message (window,
                                                           Windows.LB_GETCURSEL,
                                                           Windows.WPARAM Windows.null_word,
                                                           Windows.LPARAM Windows.null_word))
d437 4
a440 4
                     Windows.word_to_int (Windows.send_message (window,
                                                                Windows.LB_GETCURSEL,
                                                                Windows.WPARAM Windows.null_word,
                                                                Windows.LPARAM Windows.null_word))
d540 4
a543 4
          val result = Windows.word_to_int (Windows.send_message (list,
                                                                  Windows.LB_GETCURSEL,
                                                                  Windows.WPARAM Windows.null_word,
                                                                  Windows.LPARAM Windows.null_word))
d565 4
a568 4
        Windows.word_to_int (Windows.send_message (text,
                                                   Windows.WM_GETTEXTLENGTH,
                                                   Windows.WPARAM Windows.null_word,
                                                   Windows.LPARAM Windows.null_word))
@


1.5
log
@More stuff
@
text
@d3 3
d86 2
a87 2
                            Windows.WPWORD (Windows.null_word),
                            Windows.LPWORD string_word);
d142 4
a145 1
    window_despatch (window,message,wparam,lparam)
d172 1
a172 1
      fun ml_window_proc (window,message,wparam,lparam) =
d174 1
d179 1
a179 1
           Option.SOME (Windows.call_window_proc (original_window_proc,(window,message,wparam,lparam))))
d252 2
a253 1
  (* This should return a MainWindow *)
d255 1
a255 1
  fun make_main_window (name,title,applicationShell,has_context_label) = 
d263 1
a263 1
         parent = applicationShell, (* This will be the windows owner *)
d272 2
a273 1
      Windows.show_window (window,Windows.SW_SHOWDEFAULT);
d275 22
d303 1
a303 1
     name = name,
d323 1
a323 1
      Windows.show_window (window,Windows.SW_SHOWDEFAULT);
d361 2
a362 1
         styles = [Windows.WS_CHILD,Windows.WS_BORDER,Windows.WS_VSCROLL,Windows.LBS_NOTIFY]}
d376 2
a377 2
                               Windows.WPWORD Windows.null_word,
                               Windows.LPWORD Windows.null_word);
d385 2
a386 2
                                  Windows.WPWORD Windows.null_word,
                                  Windows.LPWORD string_word);
d393 1
a393 1
      fun select_handler event =
d400 2
a401 2
                                                           Windows.WPWORD Windows.null_word,
                                                           Windows.LPWORD Windows.null_word))
d414 2
a415 2
                                                                Windows.WPWORD Windows.null_word,
                                                                Windows.LPWORD Windows.null_word))
d434 1
a434 1
  fun realize window = ()
a435 5
  (* What windows functions should these map onto? *)
  (* note that in Motif a popup is popped up by managing its child *)
  (* here we also manage the "form", but it is the same widget as the shell! *)
  fun manage window = reveal window;
  fun unmanage window = hide window;
d461 5
a465 4
    while (!continue) do 
      if Windows.do_input ()
        then raise SubLoopTerminated
      else ()
d517 2
a518 2
                                                                  Windows.WPWORD Windows.null_word,
                                                                  Windows.LPWORD Windows.null_word))
d529 2
a530 2
                               Windows.WPWORD (Windows.int_to_word (pos-1)),
                               Windows.LPWORD Windows.null_word);
d542 2
a543 2
                                                   Windows.WPWORD Windows.null_word,
                                                   Windows.LPWORD Windows.null_word))
d548 2
a549 2
                               Windows.WPWORD (Windows.int_to_word pos1),
                               Windows.LPWORD (Windows.int_to_word pos2));
d562 2
a563 2
                                Windows.WPWORD Windows.null_word,
                                Windows.LPWORD string_word);
d574 2
a575 2
                                Windows.WPWORD Windows.null_word,
                                Windows.LPWORD string_word);
d583 2
a584 2
                                          Windows.WPWORD Windows.null_word,
                                          Windows.LPWORD Windows.null_word)
d598 2
a599 2
                                        Windows.WPWORD (Windows.int_to_word (size+1)), (* add 1 for the last null character *)
                                        Windows.LPWORD buffer)
d615 2
a616 2
                                          Windows.WPWORD Windows.null_word,
                                          Windows.LPWORD Windows.null_word)
d640 2
a641 1
      | TEXT of Widget
a642 1
      | OTHER of Widget
d662 19
d695 1
a695 1
              | (a,TEXT w) => do_one (w,a,widget_size w)
d697 1
a697 1
              | (a,OTHER w) => do_one (w,a,widget_size w)
d705 7
a711 13
                      if not (Windows.is_null_window subwindow) andalso
                        Windows.get_parent subwindow = w (* only do this for direct subwindows *)
                        then
                          let
                            val (width,height) = widget_size subwindow
                            val _ = print1 ("do_subpane: " ^ N width ^ " " ^ N height ^ " " ^ N (!yref)  ^ "\n")
                          in
                            print1 ("move_window1: " ^ Text.get_string subwindow ^ " " ^ N 0 ^ " " ^ N (!yref) ^ " " ^ N width ^ " " ^ N height ^ "\n");
                            Windows.move_window (subwindow,0,!yref,width,height,true);
                            yref := !yref + height;
                            maxwidthref := max (!maxwidthref,width)
                          end
                      else ()
d713 1
a713 1
                    Windows.enum_child_windows (w,do_subpane);
d718 1
d722 48
d771 11
a781 2
          print1 ("move_window2: " ^ Text.get_string parent ^ " " ^ N x ^ " " ^ N y ^ " " ^ N (total_width+w-cright) ^ " " ^ N (total_height+h-cbottom) ^ "\n");
          Windows.move_window (parent,x,y,total_width+w-cright,total_height+h-cbottom,true)
@


1.4
log
@More work
@
text
@d3 3
d42 2
a43 1
  fun print s = output (MLWorks.IO.terminal_out, s ^ "\n")
d45 1
d79 8
a86 4
    (Windows.send_message (window,Windows.WM_SETTEXT,
                           Windows.WPWORD (Windows.null_word),
                           Windows.LPSTRING (munge_string s));
     ())
d120 57
d239 2
a240 2
          then MLWorks.Option.SOME (make_context_label parent)
        else MLWorks.Option.NONE
d260 2
a261 2
          then MLWorks.Option.SOME (make_context_label window)
        else MLWorks.Option.NONE
d314 1
d331 10
d349 2
a350 1
            val string = print_fn opts item
d353 3
a355 2
                                  Windows.WPWORD (Windows.null_word),
                                  Windows.LPSTRING (munge_string string))
d371 1
a371 1
              print ("Selection of " ^ N item);
d385 1
a385 1
                   print ("Double click of " ^ N item);
a422 3
  fun exit_dialog (parent,applicationShell,has_controlling_tty) =
    dummy "exit_dialog"

d433 6
a438 1
  fun event_loop continue = dummy "event_loop"
d441 1
a441 1
  fun find_file _ = (dummy "find_file"; MLWorks.Option.NONE)
d517 1
a517 1
        (print ("set_selection " ^ N pos1 ^ ", " ^ N pos2);
d528 10
a537 6
        (set_insertion_position (text,pos);
         Windows.send_message (text,
                               Windows.EM_REPLACESEL,
                               Windows.WPWORD Windows.null_word,
                               Windows.LPSTRING (munge_string str));
        ())
d540 11
a550 6
        (set_selection (text,from,to);
         Windows.send_message (text,
                               Windows.EM_REPLACESEL,
                               Windows.WPWORD Windows.null_word,
                               Windows.LPSTRING (munge_string str));
         ())
d552 9
a560 1
        (dummy "get_insertion_position";0)
d583 11
a593 1
      fun get_selection _ = (dummy "get_selection";"")
d600 6
d641 1
a641 1
                (print ("do_one: " ^ N width ^ " " ^ N height ^ " " ^ N y);
d656 1
a656 1
                    val _ = print "Doing paned window"
d663 1
a663 1
                            val _ = print ("do_subpane: " ^ N width ^ " " ^ N height ^ " " ^ N (!yref))
d665 1
a665 1
                            print ("move_window1: " ^ Text.get_string subwindow ^ " " ^ N 0 ^ " " ^ N (!yref) ^ " " ^ N width ^ " " ^ N height);
d681 1
a681 1
          print ("move_window2: " ^ Text.get_string parent ^ " " ^ N x ^ " " ^ N y ^ " " ^ N (total_width+w-cright) ^ " " ^ N (total_height+h-cbottom));
@


1.3
log
@More stuff
@
text
@d3 3
d46 13
d76 1
a76 1
                           Windows.LPSTRING s);
d153 16
d173 1
a173 1
          then MLWorks.Option.SOME (make_managed_widget ("contextLabel",Label,parent,[]))
d194 1
a194 1
          then MLWorks.Option.SOME (make_managed_widget ("contextLabel",Label,window,[]))
d242 1
d263 1
a263 1
         styles = [Windows.WS_CHILD,Windows.WS_VSCROLL,Windows.LBS_NOTIFY]}
d276 1
a276 1
                                  Windows.LPSTRING string)
d451 1
a451 1
                               Windows.LPSTRING str);
d459 1
a459 1
                               Windows.LPSTRING str);
@


1.2
log
@Making it all work
@
text
@d3 3
d29 2
d49 1
a49 1
  datatype WidgetClass = Frame | Graphics | Label | PushButton | Text | RowColumn | Paned | Form
d53 1
a53 1
      Label => ("STATIC",[Windows.SS_LEFT,Windows.WS_BORDER])
a54 1
    | PushButton => ("BUTTON",[])
a78 1
    | convert_name (PushButton,name) = LabelStrings.get_label name
d81 2
a82 1
  val default_width = 400
a83 1
  val toplevel_width = 400
d87 2
a88 2
      Frame => 100
    | Graphics => 100
d90 4
a93 5
    | PushButton => 20
    | Text => 20
    | RowColumn => 20
    | Paned => 100
    | Form => 100
d109 1
d125 1
d158 1
d178 1
d190 1
d206 1
a206 1
         height = 150,
d208 1
d220 2
d227 1
a227 1
         height = 150,
d229 2
a230 1
         styles = [Windows.WS_CHILD,Windows.WS_VSCROLL,Windows.LBS_STANDARD]}
d232 48
a279 10
        Lists.iterate
        (fn item =>
         let
           val string = print_fn opts item
         in
           Windows.send_message (window,Windows.LB_ADDSTRING,
                                 Windows.WPWORD (Windows.null_word),
                                 Windows.LPSTRING string)
         end)
        items
d281 1
a281 1
      (* Need a set_items function here *)
a310 2
  fun quit_on_exit () = dummy "quit_on_exit"

d321 2
a322 2
  fun set_message_widget _ = dummy "set_message_widget"
  fun no_message_widget _ = dummy "no_message_widget"
d369 2
d379 1
a379 1
            then Vector.vector [result]
d387 1
a387 1
                               Windows.WPWORD (Windows.int_to_word pos),
d403 2
a404 1
        (Windows.send_message (text,
d410 3
d414 1
a414 1
        (set_selection (text,pos,pos);
a419 2
      fun set_insertion_position (text,pos) =
        set_selection (text,pos,pos)
d439 1
a439 1
                                        Windows.WPWORD (Windows.int_to_word size),
d441 1
a441 1
          val _ = Windows.set_byte (buffer,size,0) (* null terminate *)
d447 1
d450 1
d567 1
a567 2
        (dummy "text_extent";
         {ascent=0,descent=0,font_ascent=0,font_descent=0,lbearing=0,rbearing=0,width=0})
@


1.1
log
@new unit
MS Windows GUI
@
text
@d3 4
d9 1
d12 1
d16 2
a17 1
functor Capi (structure FileDialog : FILE_DIALOG
d19 1
d24 1
a24 1
  type Widget = Windows.window
d31 4
a34 1
  fun unimplemented s _ = raise Unimplemented s
d36 3
d45 53
a97 1
    
d99 14
a112 1
    raise Unimplemented "make_widget"
d114 13
a126 1
    Windows.null_window
d130 3
d134 8
a141 1
    (Windows.null_window,Windows.null_window,MLWorks.Option.NONE)
d143 2
d146 19
a164 1
    raise Unimplemented "make_main_window"
d167 8
a174 1
    raise Unimplemented "make_popup_shell"
d176 16
a191 1
    raise Unimplemented "make_toplevel_shell"
d193 17
a209 1
    (Windows.null_window,Windows.null_window)
d211 25
a235 1
    raise Unimplemented "make_scrolllist"
d237 2
a238 1
    raise Unimplemented "make_file_selection_box"
d240 1
a240 1
  val destroy = unimplemented "destroy"
a241 3
  fun manage window = ()
  fun unmanage window = ()
  val to_front = unimplemented "to_front"
d243 8
a250 2
  fun set_sensitivity (widget,sensitivity) =
    raise Unimplemented "set_sensitivity"
d253 3
a255 1
  fun set_label_string (label,s) = ()
d258 3
a260 3
  val parent = unimplemented "parent"
  val set_busy = unimplemented "set_busy"
  val unset_busy = unimplemented "unset_busy"
d262 1
a262 1
  val quit_on_exit : unit -> unit = unimplemented "quit_on_exit"
d265 1
a265 1
    raise Unimplemented "exit_dialog"
d267 6
a272 1
  fun widget_size widget = (0,0)
d274 2
a275 2
  fun set_message_widget _ = ()
  fun no_message_widget _ = ()
d277 1
a277 1
  fun event_loop continue = ()
d280 8
a287 1
  val find_file = unimplemented "find_file"
a288 1
  fun send_message (parent,message) = ()
d290 1
a290 1
  fun beep widget = ()
d296 3
d301 1
a301 1
        raise Unimplemented "get_key_data"
d303 1
a303 1
        raise Unimplemented "get_button_data"
d306 1
a306 1
        raise Unimplemented "get_event_type"
d314 1
a314 1
        raise Unimplemented "convert_verify_data"
d316 2
a317 3
        raise Unimplemented "get_event"
      fun add (w,t,f) =
        raise Unimplemented "add"
d322 22
a343 3
      val get_selected_pos = unimplemented "get_selected_pos"
      val select_pos = unimplemented "select_pos"
      val set_bottom_pos = unimplemented "set_bottom_pos"
d348 12
d361 9
a369 1
        raise Unimplemented "insert"
d371 6
a376 3
        raise Unimplemented "replace"
      fun set_insertion_position (text,pos) =
        raise Unimplemented "set_insertion_position"
d378 18
a395 3
        raise Unimplemented "get_insertion_position"
      fun get_last_position text =
        raise Unimplemented "get_last_position"
d397 9
a405 15
        raise Unimplemented "substring"

      val get_string = unimplemented "get_string"
      val set_string = unimplemented "set_string"
      val get_selection = unimplemented "get_selection"
      val remove_selection = unimplemented "remove_selection"

      fun get_line_and_index (text,pos) =
        raise Unimplemented "get_line_and_index"
      fun current_line (text,pos) =
        raise Unimplemented "current_line"
      fun end_line (text,pos) =
        raise Unimplemented "end_line"
      fun get_line (text,pos) = 
        raise Unimplemented "get_line"
d418 66
a483 2
      fun lay_out _ =
        ()
d485 2
d498 2
a499 2
      fun gp_widget _ = raise Unimplemented "gp_widget"
      fun initialize_gp _ = raise Unimplemented "initialize_gp"
d504 2
a505 1
        
d512 1
a512 1
        raise Unimplemented "make_gp"
d514 2
a515 1
        raise Unimplemented "text_extent"
d523 2
a524 1
        raise Unimplemented "make_scrolled_graphics"
@
