head	1.65;
access;
symbols
	MLW_daveb_inline_1_4_99:1.65.1
	MLWorks_21c0_1999_03_25:1.65
	MLWorks_20c1_1998_08_20:1.64
	MLWorks_20c0_1998_08_04:1.64
	MLWorks_20b2c2_1998_06_19:1.63
	MLWorks_20b2_Windows_1998_06_12:1.63
	MLWorks_20b1c1_1998_05_07:1.63
	MLWorks_20b0_1998_04_07:1.62
	MLWorks_20b0_1998_03_20:1.61
	MLWorks_20m2_1998_02_16:1.59
	MLWorks_20m1_1997_10_23:1.55
	MLWorks_11r1:1.44.1.1.1.2.1
	MLWorks_workspace_97:1.54.2
	MLWorks_dt_wizard:1.54.1
	MLWorks_11c0_1997_09_09:1.44.1.1.1.2
	MLWorks_10r3:1.44.1.1.3
	MLWorks_10r2_551:1.44.1.1.2
	MLWorks_11:1.44.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.44.1.1
	MLWorks_20m0_1997_06_20:1.52
	MLWorks_1_0_r2c2_1997_06_14:1.44.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.44.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.44.1
	MLWorks_BugFix_1997_04_24:1.44
	MLWorks_1_0_r2_Win32_1997_04_11:1.44
	MLWorks_1_0_r2_Unix_1997_04_04:1.44
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.41.3.1.1
	MLWorks_gui_1996_12_18:1.41.4
	MLWorks_1_0_Win32_1996_12_17:1.41.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.40.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.40.1.1
	JFHmswindows:1.41.2
	MLWorks_1_0_Irix_1996_11_28:1.40.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.41.1
	MLWorks_1_0_Unix_1996_11_14:1.40.1
	MLWorks_Open_Beta2_1996_10_11:1.36.2
	MLWorks_License_dev:1.36.1
	MLWorks_1_open_beta_1996_09_13:1.35.1
	MLWorks_Open_Beta_1996_08_22:1.35
	MLWorks_Beta_1996_07_02:1.32
	MLWorks_Beta_1996_06_07:1.27
	MLWorks_Beta_1996_06_06:1.27
	MLWorks_Beta_1996_06_05:1.27
	MLWorks_Beta_1996_06_03:1.27
	MLWorks_Beta_1996_05_31:1.27
	MLWorks_Beta_1996_05_30:1.27;
locks; strict;
comment	@ * @;


1.65
date	99.03.23.14.44.44;	author johnh;	state Exp;
branches
	1.65.1.1;
next	1.64;

1.64
date	98.07.09.13.56.15;	author johnh;	state Exp;
branches;
next	1.63;

1.63
date	98.04.16.17.02.20;	author johnh;	state Exp;
branches;
next	1.62;

1.62
date	98.04.01.12.17.42;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	98.02.20.11.34.03;	author mitchell;	state Exp;
branches;
next	1.60;

1.60
date	98.02.18.17.10.28;	author jont;	state Exp;
branches;
next	1.59;

1.59
date	98.01.30.14.31.12;	author johnh;	state Exp;
branches;
next	1.58;

1.58
date	97.11.06.13.00.32;	author johnh;	state Exp;
branches;
next	1.57;

1.57
date	97.10.29.11.06.12;	author johnh;	state Exp;
branches;
next	1.56;

1.56
date	97.10.28.16.02.44;	author johnh;	state Exp;
branches;
next	1.55;

1.55
date	97.09.19.14.29.50;	author brucem;	state Exp;
branches;
next	1.54;

1.54
date	97.09.08.08.52.32;	author johnh;	state Exp;
branches
	1.54.1.1
	1.54.2.1;
next	1.53;

1.53
date	97.07.15.15.39.26;	author johnh;	state Exp;
branches;
next	1.52;

1.52
date	97.06.16.15.30.21;	author johnh;	state Exp;
branches;
next	1.51;

1.51
date	97.06.13.09.35.01;	author johnh;	state Exp;
branches;
next	1.50;

1.50
date	97.06.09.10.29.51;	author johnh;	state Exp;
branches;
next	1.49;

1.49
date	97.05.28.10.32.04;	author johnh;	state Exp;
branches;
next	1.48;

1.48
date	97.05.22.16.35.49;	author johnh;	state Exp;
branches;
next	1.47;

1.47
date	97.05.21.09.37.27;	author johnh;	state Exp;
branches;
next	1.46;

1.46
date	97.05.16.15.34.38;	author johnh;	state Exp;
branches;
next	1.45;

1.45
date	97.05.06.10.37.00;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	97.03.17.14.23.09;	author johnh;	state Exp;
branches
	1.44.1.1;
next	1.43;

1.43
date	97.03.14.13.17.05;	author johnh;	state Exp;
branches;
next	1.42;

1.42
date	97.03.13.13.55.03;	author johnh;	state Exp;
branches;
next	1.41;

1.41
date	96.11.20.12.15.09;	author daveb;	state Exp;
branches
	1.41.1.1
	1.41.2.1
	1.41.3.1
	1.41.4.1;
next	1.40;

1.40
date	96.11.06.11.17.58;	author matthew;	state Exp;
branches
	1.40.1.1;
next	1.39;

1.39
date	96.11.05.12.45.06;	author johnh;	state Exp;
branches;
next	1.38;

1.38
date	96.10.30.20.11.16;	author io;	state Exp;
branches;
next	1.37;

1.37
date	96.10.30.20.01.27;	author io;	state Exp;
branches;
next	1.36;

1.36
date	96.09.19.11.28.52;	author johnh;	state Exp;
branches
	1.36.1.1
	1.36.2.1;
next	1.35;

1.35
date	96.08.12.10.48.51;	author nickb;	state Exp;
branches
	1.35.1.1;
next	1.34;

1.34
date	96.08.01.12.59.12;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	96.07.12.16.51.53;	author andreww;	state Exp;
branches;
next	1.32;

1.32
date	96.06.28.15.42.06;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	96.06.25.15.19.05;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	96.06.24.12.58.26;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	96.06.24.10.51.05;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	96.06.18.13.18.49;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	96.05.29.10.09.51;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	96.05.28.15.14.17;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	96.05.28.11.00.22;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	96.05.01.13.49.03;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	96.05.01.12.09.08;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	96.04.30.13.24.32;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	96.04.04.14.34.40;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	96.03.05.16.25.30;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	96.02.27.15.48.25;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	96.01.31.12.18.44;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	96.01.24.15.26.36;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	96.01.08.16.13.06;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	96.01.04.16.33.41;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	95.12.15.12.09.39;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	95.12.13.12.19.06;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	95.11.23.12.36.12;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.11.22.16.12.01;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	95.11.08.10.30.44;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	95.10.17.16.08.15;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.10.04.09.35.15;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	95.09.19.14.16.18;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.09.05.11.52.30;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.08.31.11.25.06;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.25.10.33.17;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.15.14.37.22;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.08.10.09.33.01;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.08.03.12.52.41;	author matthew;	state Exp;
branches;
next	;

1.35.1.1
date	96.09.13.11.20.16;	author hope;	state Exp;
branches;
next	;

1.36.1.1
date	96.10.07.16.10.11;	author hope;	state Exp;
branches;
next	;

1.36.2.1
date	96.10.17.11.28.38;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	96.11.14.12.54.17;	author hope;	state Exp;
branches
	1.40.1.1.1.1;
next	;

1.40.1.1.1.1
date	96.11.28.15.05.08;	author hope;	state Exp;
branches;
next	;

1.41.1.1
date	96.11.22.18.13.01;	author hope;	state Exp;
branches;
next	;

1.41.2.1
date	96.12.17.09.57.50;	author hope;	state Exp;
branches;
next	;

1.41.3.1
date	96.12.17.17.51.30;	author hope;	state Exp;
branches
	1.41.3.1.1.1;
next	;

1.41.3.1.1.1
date	97.02.24.11.42.03;	author hope;	state Exp;
branches;
next	;

1.41.4.1
date	96.12.18.09.45.46;	author hope;	state Exp;
branches;
next	;

1.44.1.1
date	97.05.12.10.38.16;	author hope;	state Exp;
branches
	1.44.1.1.1.1
	1.44.1.1.2.1
	1.44.1.1.3.1;
next	;

1.44.1.1.1.1
date	97.07.28.18.23.14;	author daveb;	state Exp;
branches;
next	1.44.1.1.1.2;

1.44.1.1.1.2
date	97.08.05.14.39.16;	author johnh;	state Exp;
branches
	1.44.1.1.1.2.1.1;
next	;

1.44.1.1.1.2.1.1
date	97.10.07.11.48.56;	author jkbrook;	state Exp;
branches;
next	;

1.44.1.1.2.1
date	97.09.08.17.16.36;	author daveb;	state Exp;
branches;
next	;

1.44.1.1.3.1
date	97.09.09.14.12.41;	author daveb;	state Exp;
branches;
next	;

1.54.1.1
date	97.09.10.19.28.40;	author brucem;	state Exp;
branches;
next	;

1.54.2.1
date	97.09.11.20.58.37;	author daveb;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	97.09.12.14.48.42;	author johnh;	state Exp;
branches;
next	;

1.65.1.1
date	99.04.01.17.59.07;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
MS Windows GUI
@


1.65
log
@[Bug #190536]
Change help menu.
@
text
@(* Windows menu bar utilites *)
(*
 * $Log: _menus.sml,v $
 * Revision 1.64  1998/07/09  13:56:15  johnh
 * [Bug #30400]
 * Fix returning to and from tty mode.
 *
 * Revision 1.63  1998/04/16  17:02:20  johnh
 * [Bug #30318]
 * Add createDialog to Windows structure.
 *
 * Revision 1.62  1998/04/01  12:17:42  jont
 * [Bug #70086]
 * WINDOWS becomes WINDOWS_GUI, Windows becomesd WindowsGui
 *
 * Revision 1.61  1998/02/20  11:34:03  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.60  1998/02/18  17:10:28  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 * Revision 1.59  1998/01/30  14:31:12  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.58  1997/11/06  13:00:32  johnh
 * [Bug #30125]
 * Move implementation of send_message to Menus.
 *
 * Revision 1.57  1997/10/29  11:06:12  johnh
 * [Bug #30233]
 * editor dialog now stored as resource.
 *
 * Revision 1.56  1997/10/28  16:02:44  johnh
 * [Bug #30059]
 * Implement interface to Win32 resource dialogs.
 *
 * Revision 1.55  1997/09/19  14:29:50  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.54.2.2  1997/09/12  14:48:42  johnh
 * [Bug #30071]
 * Redesign Compilation Manager -> Project Workspace.
 * Implement Radio and Toggle buttons in make_buttons function.
 *
 * Revision 1.54  1997/09/08  08:52:32  johnh
 * [Bug #30241]
 * Implement proper find dialog.
 *
 * Revision 1.53  1997/07/15  15:39:26  johnh
 * [Bug #30124]
 * Creating help menu.
 *
 * Revision 1.52  1997/06/16  15:30:21  johnh
 * [Bug #30174]
 * Moving stuff into platform specific podium.
 *
 * Revision 1.51  1997/06/13  09:35:01  johnh
 * [Bug #30175]
 * Combine tools and windows menus - need to change implementation of dynamic menus.
 *
 * Revision 1.50  1997/06/09  10:29:51  johnh
 * [Bug #30068]
 * Add a toolbar button for the BreakTrace manager top level tool.
 *
 * Revision 1.49  1997/05/28  10:32:04  johnh
 * [Bug #30155]
 * Added get_graph_menuspec.
 *
 * Revision 1.48  1997/05/22  16:35:49  johnh
 * [Bug #20059]
 * Menus.windowHandle made global and set from actions of some menu items.
 *
 * Revision 1.47  1997/05/21  09:37:27  johnh
 * Implementing toolbar.
 *
 * Revision 1.46  1997/05/16  15:34:38  johnh
 * Implementing single menu bar on Windows.
 *
 * Revision 1.45  1997/05/06  10:37:00  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.44  1997/03/17  14:23:09  johnh
 * [Bug #1954]
 * Improved slider functionality - added range checking.
 *
 * Revision 1.43  1997/03/14  13:17:05  johnh
 * [Bug #1923]
 * Removed system menu from exit dialog.
 *
 * Revision 1.42  1997/03/13  13:55:03  johnh
 * [Bug #1772]
 * Attaching Esc to 'Cancel' button on dialogs.
 *
 * Revision 1.41  1996/11/20  12:15:09  daveb
 * Reinstated the help menus.
 *
 * Revision 1.40  1996/11/06  11:17:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.39  1996/11/05  12:45:06  johnh
 * [Bug #1727]
 * Add ES_AUTOHSCROLL to text boxes to input past the end of textbox.
 *
 * Revision 1.38  1996/10/30  20:11:16  io
 * [Bug #1614]
 * sorting out a typo
 *
 * Revision 1.37  1996/10/30  20:01:27  io
 * moving String from toplevel
 *
 * Revision 1.36  1996/09/19  11:28:52  johnh
 * [Bug #1481]
 * Passed list of main windows to exit_dialog function so that they can
 * be killed.
 *
 * Revision 1.35  1996/08/12  10:48:51  nickb
 * Option dialog setter functions now return accept/reject.
 *
 * Revision 1.34  1996/08/01  12:59:12  daveb
 * [Bug #1517]
 * make_buttons now adds a command handler to the grandparent of the button,
 * which in our code is the top level widget.  This allows accelerators to
 * refer to buttons.  This is a fragile feature; changes in the nesting of
 * windows will break it.
 *
 * Revision 1.33  1996/07/12  16:51:53  andreww
 * Adding code to redirect standard IO back to the terminal.
 * Since current implementation ignores has_controlling_tty, we can always
 * do it anyway.
 *
 * Revision 1.32  1996/06/28  15:42:06  jont
 * Static command handlers changed to be dynamic to improve delivery
 *
 * Revision 1.31  1996/06/25  15:19:05  daveb
 * Added handlers around all calls to Capi.getStockObject.
 *
 * Revision 1.30  1996/06/24  12:58:26  daveb
 * Removed the Help menus.
 *
 * Revision 1.29  1996/06/24  10:51:05  daveb
 * Corrected sizes of buttons in the light of the recent font change.
 *
 * Revision 1.28  1996/06/18  13:18:49  daveb
 * Made buttons use the DEFAULT_GUI_FONT, when defined, and ANSI_VAR_FONT
 * otherwise.
 *
 * Revision 1.27  1996/05/29  10:09:51  matthew
 * More on last change
 *
 * Revision 1.26  1996/05/28  15:14:17  matthew
 * Improving exit_dialog
 *
 * Revision 1.25  1996/05/28  11:00:22  matthew
 * Don'
 * Don't do action after OK with nothing selected
 *
 * Revision 1.24  1996/05/01  13:49:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.23  1996/05/01  12:09:08  matthew
 * Removing Integer structure
 *
 * Revision 1.22  1996/04/30  13:24:32  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.21  1996/04/04  14:34:40  matthew
 * Fixing sliders
 *
 * Revision 1.20  1996/03/05  16:25:30  matthew
 * Changes to windows structure
 *
 * Revision 1.19  1996/02/27  15:48:25  matthew
 * Changes to Windows signature
 *
 * Revision 1.18  1996/01/31  12:18:44  matthew
 * Changing representation of Widgets
 *
 * Revision 1.17  1996/01/24  15:26:36  matthew
 * Adding slider controls
 *
 * Revision 1.16  1996/01/08  16:13:06  matthew
 * More stuff.
 *
 * Revision 1.15  1996/01/04  16:33:41  matthew
 * Make buttons variable width, depending on string size
 *
 * Revision 1.14  1995/12/15  12:09:39  matthew
 * Changing some windows styles
 *
 * Revision 1.13  1995/12/13  12:19:06  matthew
 * Changing message handling
 *
 * Revision 1.12  1995/11/23  12:36:12  matthew
 * More stuff
 *
 * Revision 1.11  1995/11/22  16:12:01  matthew
 * More stuff
 *
 * Revision 1.10  1995/11/08  10:30:44  matthew
 * Trying to fix radio buttons
 *
 * Revision 1.9  1995/10/17  16:08:15  nickb
 * Add sliders.
 *
 * Revision 1.8  1995/10/04  09:35:15  daveb
 * make_buttons now returns a record of functions.
 *
 * Revision 1.7  1995/09/19  14:16:18  matthew
 * Attempting to do dynamic menus
 *
 * Revision 1.6  1995/09/05  11:52:30  matthew
 * ** No reason given. **
 *
 * Revision 1.5  1995/08/31  11:25:06  matthew
 * Adding text and int input.
 *
 * Revision 1.4  1995/08/25  10:33:17  matthew
 * Adding dialogs
 *
 * Revision 1.3  1995/08/15  14:37:22  matthew
 * Extending
 *
 * Revision 1.2  1995/08/10  09:33:01  matthew
 * Making it all work
 *
 * Revision 1.1  1995/08/03  12:52:41  matthew
 * new unit
 * MS Windows GUI
 *
 * Copyright (c) 1993 Harlequin Ltd.
 * 
 *)

require "^.utils.__terminal";
require "../basis/__int";
require "../basis/__list";

require "../utils/lists";
require "../utils/crash";
require "../utils/getenv";
require "windows_gui";
require "capitypes";
require "labelstrings";
require "control_names";
require "../main/version";

require "../gui/menus";

(* some utility functions for specifying menus *)

functor Menus (structure Lists : LISTS
               structure Crash : CRASH
               structure WindowsGui : WINDOWS_GUI
               structure CapiTypes : CAPITYPES
               structure LabelStrings : LABELSTRINGS
	       structure ControlName : CONTROL_NAME
	       structure Getenv : GETENV
	       structure Version : VERSION

               sharing type LabelStrings.word = WindowsGui.word
               sharing type CapiTypes.Hwnd = WindowsGui.hwnd
                 ) : MENUS =
  struct
    type Widget = CapiTypes.Widget
    type word = WindowsGui.word

    fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

    fun dummy s = Terminal.output(s ^ " unimplemented \n")

    val P = Int.toString
    val W = Int.toString o WindowsGui.wordToInt

    fun k x y = x

    val print = Terminal.output

    (* some constants, which should be derived from winmain.h *)

    val IDM_HELPCONTENTS = WindowsGui.intToWord 400
    val IDM_HELPSEARCH   = WindowsGui.intToWord 401
    val IDM_HELPHELP     = WindowsGui.intToWord 402
    val IDM_ABOUT        = WindowsGui.intToWord 403

    val null_item = WindowsGui.ITEM WindowsGui.nullWord

    (* use a list of these to specify the top level menu *)
    datatype ButtonSpec =
        (* a separator widget *)
        SEPARATOR
      | LABEL of string
        (* fun 1 is a function to get initial value, fun 2 is callback function, fun 3 is a sensitive function *)
      | TOGGLE of string * (unit -> bool) * (bool -> unit) * (unit -> bool)
	(* name, min, max, callback *)
      |	SLIDER of string * int * int * (int -> unit)
        (* name and callback function and test sensitivity *)
      | PUSH of string * (unit -> unit) * (unit -> bool)
	(* name, get function, and callback function (set) and sensitive function*)
      | RADIO of string * (unit -> bool) * (bool -> unit) * (unit -> bool)
        (* cascade button and submenu specification *)
      | CASCADE of string * ButtonSpec list * (unit -> bool)
	(* cade button and function to create submenu specification *)
      | DYNAMIC of string * (unit -> ButtonSpec list) * (unit -> bool)

    (* cache of ids to reuse for dynamic menus *)
    val id_cache = ref []

    (* toggles:  (string * (bool -> unit) ref * (unit -> bool) ref) list *)
    (* This references stores all the toggle menu items along with their 
     * checked references and  sensitivity functions *)
    val toggles = ref []

    (* dynamics: (string * ButtonSpec list ref * (unit -> bool) ref) list *)
    (* This reference stores all the dynamic menu cascade items. *)
    val dynamics = ref []

    (* menuItems: (string * (unit -> unit) ref * (unit -> bool) ref) list *)
    (* This stores all the menu items (inc. toggles) and their associated action
     * and sensitivity functions *)
    val menuItems = ref []

    (* Handle of current window - used to set the focus back to current window 
     * after selecting a menu item *)
    val windowHandle = ref WindowsGui.nullWindow

    (* Stores the function which resets the menu items associated with a window,
     * when that window is closed. *)
    val deactivate_fun = ref (fn () => ())

     (* Used to reset the menu to the initial state in the situation when all the 
     * other windows are closed *)
    val initial_fn = ref (fn () => ())

    (* used to reset the menu when a window is closed *)
    fun quit () = ((!deactivate_fun) ();
                   deactivate_fun := (fn () => ());
                   (!initial_fn) ())

    (* get the reference within itemListRef associated with the name 'name' *)
    fun getMenuRef name itemListRef = 
      Lists.findp (fn (s,_,_) => (s = name)) (!itemListRef) 

    (* Adds a menu item to the reference list - called when creating the menu *)
    fun addRef name = 
      (if Lists.member (name, map (fn (s,_,_) => s) (!menuItems)) then ()
       else menuItems := (name, ref (fn () => ()), ref (fn () => true)) :: (!menuItems);
       getMenuRef name menuItems)

    fun addDynamicRef name = 
      (if Lists.member (name, map (fn (s,_,_) => s) (!dynamics)) then ()
      else dynamics := (name, ref (fn () => []), ref (fn () => true)) :: (!dynamics);
      getMenuRef name dynamics)

    (* Changes the action and sensitivity functions of a push button menu item *)
    fun changeItem (name, new_act, new_sens) = 
      let 
        val (name, act_ref, sens_ref) = getMenuRef name menuItems
       (* This exception is raised if the item 'name' cannot be found in the reference
        * list in which case the programmer has either got the name wrong in one of the
	* tools or has not added the name to the menu structure in the podium. *)
          handle Lists.Find => (print (name ^ " menu item not found in reference list\n");
                                ("", ref (fn () => ()), ref (fn () => false)))
      in
        act_ref := (fn () => (ignore(new_act()); 
                              ignore(WindowsGui.setFocus (!windowHandle)); 
                              ()));
	sens_ref := new_sens
      end

    (* Changes the action and sensitivity functions of a DYNAMIC menu item *)
    (* Also there is a subtle difference between changeItem and changeDynamic in 
     * changeItem calls WindowsGui.setFocus to set the focus back to the window which 
     * had the focus before selecting a menu item.  This is not done on dynamic
     * menus because the Windows menu is dynamic and we do not want to the focus
     * to the wrong window after selecting an item from the Windows menu *)
    fun changeDynamic (name, new_act, new_sens) = 
      let
        val (name, act_ref, sens_ref) = getMenuRef name dynamics
          handle Lists.Find => (print (name ^ " dynamic menu item not found in reference list\n");
                                ("", ref (new_act), ref (fn () => false)))
      in
        act_ref := new_act;
        sens_ref := new_sens
      end

    (* Changes the action and sensitivity function of a toggle menu item *)
    fun changeToggleItem (name, new_get, new_act, new_sens) = 
      let 
        val (name, act_ref, sens_ref) = getMenuRef name menuItems
          handle Lists.Find => (print (name ^ " menu item not found in reference list\n");
                                ("", ref (fn () => ()), ref (fn () => false)))

        val (name, toggle_ref, get_ref) =
          Lists.findp (fn (s,_,_) => (s = name)) (!toggles)
          handle Lists.Find => (print (name ^ " toggle menu item not found in reference list\n");
                                ("", ref false, ref (fn () => false)))
      in
        get_ref := new_get;
        act_ref := (fn () => (toggle_ref := not (!toggle_ref);
                              ignore(new_act (!toggle_ref));
                              ignore(WindowsGui.setFocus (!windowHandle)); ()));
        sens_ref := new_sens
      end

    (* This is used to store a function for updating the toolbar, ie. enabling and 
     * disabling buttons appropriately.  This function is attached to some message
     * handlers when the toolbar is created, and is also called when the menu items
     * change so that the menus and the toolbar are kept consistent with each other.
     *)
    val update_ref = ref (fn () => ())

    (* changeItems takes a widget, a ButtonSpec list and does the following:
     * This function is called by all windows, except the podium and is used to set up
     * a WM_ACTIVATE message handler to change the actions and sensitivity of the 
     * menu items when window focus changes. *)

    (* setItems is called by the Podium only, and sets up a function to change the 
     * menu actions back to their original state when all other windows have been
     * closed by the user. *)
    local
      fun get_sensitive SEPARATOR = false
        | get_sensitive (LABEL _) = false
        | get_sensitive (PUSH (name, act, sens)) = sens()
        | get_sensitive (SLIDER _) = false
        | get_sensitive (RADIO _) = false
        | get_sensitive (TOGGLE (name, get, act, sens)) = sens()
        | get_sensitive (DYNAMIC (name, blist, sens)) = sens()
        | get_sensitive (CASCADE (name, items, sens)) = 
		foldl (fn (a,b) => (get_sensitive a) orelse b) false items
      fun convertItems ((casc as (CASCADE (name, items, sens))) :: rest) sens_fn = 
             (changeItem (name, fn () => (), fn () => get_sensitive casc); 
	      convertItems (items @@ rest) sens_fn)
        | convertItems ((PUSH (name, act, sens)) :: rest) sens_fn = 
              (changeItem (name, act, sens_fn sens); 
	       convertItems rest sens_fn)
        | convertItems ((TOGGLE (name, get, act, sens)) :: rest) sens_fn = 
              (changeToggleItem (name, get, act, sens_fn sens); 
	       convertItems rest sens_fn)
        | convertItems (SEPARATOR :: rest) sens_fn = convertItems rest sens_fn
        | convertItems ((LABEL _) :: rest) sens_fn = convertItems rest sens_fn
        | convertItems ((SLIDER _) :: rest) sens_fn = convertItems rest sens_fn
        | convertItems ((RADIO _) :: rest) sens_fn = convertItems rest sens_fn
        | convertItems ((DYNAMIC (name, act, sens)) :: rest) sens_fn = 
              (changeDynamic (name, act, sens_fn sens); 
	       convertItems rest sens_fn)
        | convertItems [] sens_fn = ()
    in
      fun changeItems (parent, itemList) = 
	let 
	  fun reset () = (convertItems itemList (fn _ => (fn _ => false)))
          fun convert () = (convertItems itemList (fn f => f))
          fun activate (WindowsGui.WPARAM w, WindowsGui.LPARAM l) =
            let
              val deactivated = 
                (WindowsGui.loword w) = (WindowsGui.convertWaValue WindowsGui.WA_INACTIVE)
            in
              windowHandle := CapiTypes.get_real parent;
              if (not deactivated) then 
           	((!deactivate_fun) ();
            	deactivate_fun := reset;
            	convert())
              else ();
	      (!update_ref) ();
              NONE
            end
	in
          WindowsGui.addMessageHandler(CapiTypes.get_real parent, WindowsGui.WM_ACTIVATE, activate)
	end

      fun setItems itemList = initial_fn := (fn () => (convertItems itemList (fn f => f)))
    end

    fun send_message (parent,message) =
      (WindowsGui.messageBeep WindowsGui.MB_ICONQUESTION;
       ignore(WindowsGui.messageBox (CapiTypes.get_real parent,message,"MLWorks",
                                  [WindowsGui.MB_OK,WindowsGui.MB_APPLMODAL]));
       ())

    (* These should use something from labelstrings *)
    (* Anyway, global ids will do *)
    val ok_env : int = env "win32 ok id"
    val cancel_env : int = env "win32 cancel id"
    val i2w = WindowsGui.intToWord

    (* the ids for apply and reset need to be the same for each dialog, 
     * therefore an id symbol is given to each of the controls in the 
     * resource editor, and this id symbol is used here to reference 
     * each control.
     *)
    val ok_id = i2w ok_env
    val apply_id = i2w (ControlName.getResID "IDAPPLY")
    val reset_id = i2w (ControlName.getResID "IDRESET")
    val cancel_id = i2w cancel_env

    (* This is called by every window, except the podium, and is used to change the 
     * actions and sensitivity functions of the menu items when window focus changes *)
    fun make_submenus (parent, itemList) = changeItems (parent, itemList)

    fun minimizefun window (WindowsGui.WPARAM w, l) = 
      (if (w = WindowsGui.nullWord) then 
         WindowsGui.showWindow(window, WindowsGui.SW_HIDE)
       else
         WindowsGui.showWindow(window, WindowsGui.SW_SHOW);
       NONE)

   (* Parent should be the top level window here *)
    fun make_menus (parent, menuspec, isPodium) =
      let
        val real_parent = CapiTypes.get_real parent
	val itemCount = ref 0
        fun add_item menu isSubmenu item =
	  (itemCount := (!itemCount) + 1;
           case item of
             SEPARATOR =>
               (WindowsGui.appendMenu (menu,[WindowsGui.MF_SEPARATOR],null_item,"");
                NONE)
           | LABEL name => 
               let
                 val label = LabelStrings.get_label name
                 val value = WindowsGui.ITEM WindowsGui.nullWord
               in
                 WindowsGui.appendMenu (menu, [WindowsGui.MF_STRING,WindowsGui.MF_DISABLED],value,label);
                 NONE
               end
           | TOGGLE (name,get,action,sensitive) =>
               let
                 val label = LabelStrings.get_label name
                 val id = LabelStrings.get_action name 
                 val value = WindowsGui.ITEM id
                 val checked = ref false
                 val get_ref = ref get

		(* Note here that the item 'name' is added to two lists - one called
		 * toggles which stores the get function reference and the checked 
		 * reference and the other list is the normal reference list to store
		 * the action and sensitivity functions. *)
                 val _ = if Lists.member (name, map (fn (s,_,_) => s) (!toggles)) then ()
                         else 
                           toggles := (name, checked, get_ref) :: (!toggles)
                 val (_, actionRef, sensitiveRef) = addRef name
               in
                 actionRef := (fn () => (checked := not (!checked);
                                         action (!checked)));
                 sensitiveRef := sensitive;
                 WindowsGui.appendMenu (menu,[WindowsGui.MF_STRING],value,label);
                 WindowsGui.addCommandHandler (real_parent,
                                            id,
                                            fn _ => (!actionRef) ());
                 SOME (fn _ =>
                              (checked := (!get_ref) ();
                               WindowsGui.enableMenuItem
                               (menu,
                                id,
                                [if (!sensitiveRef) ()
                                   then WindowsGui.MF_ENABLED
                                 else WindowsGui.MF_GRAYED]);
                               WindowsGui.checkMenuItem
                               (menu,
                                id,
                                [if !checked 
                                   then WindowsGui.MF_CHECKED
                                 else WindowsGui.MF_UNCHECKED])))
               end
           | SLIDER (name,min,max,set_value) =>
	      Crash.impossible "No sliders in MS Windows"
           | RADIO _ =>
	      Crash.impossible "No radio buttons in menus in MS Windows"
           | PUSH (name,action,sensitive) =>
               let
                 val label = LabelStrings.get_label name
                 val id = LabelStrings.get_action name 
                 val (_, actionRef, sensitiveRef) = addRef name
               in
                 actionRef := action;
                 sensitiveRef := sensitive;
                 WindowsGui.appendMenu (menu,[WindowsGui.MF_STRING],WindowsGui.ITEM id,label);
                 WindowsGui.addCommandHandler (real_parent,id,fn _ => (!actionRef) ());
                 SOME
                 (fn _ =>
                  WindowsGui.enableMenuItem
                  (menu,
                   id,
                   [if (!sensitiveRef) ()
                      then WindowsGui.MF_ENABLED
                    else WindowsGui.MF_GRAYED]))
               end
           (* we can use the same set of identifiers for all dynamic menus *)
           | DYNAMIC (name,f,sensitive) =>
               (* We need to handle a WM_INITMENUPOPUP message *)
               let
		 val (_, actionRef, sensitiveRef) = addDynamicRef name
                 val label = LabelStrings.get_label name
                 val submenu = WindowsGui.createPopupMenu()
                 val count_ref = ref 0
                 val all_ids = ref []
		 val base_count = (!itemCount) - 1

                 (* This should also delete the handler entries for the menu *)
		 fun loopto (dmenu, r, q) = 
		   if r <= q then ()
		   else
		     (WindowsGui.deleteMenu (dmenu,WindowsGui.intToWord (r-1),WindowsGui.MF_BYPOSITION);
		      loopto (dmenu, r-1, q))
                 fun loop n = loopto (submenu, n, 0)
                 fun get_id () =
                   case !id_cache of
                     [] => 
                       let
                         val id = WindowsGui.newControlId ()
                       in
                         all_ids := id :: !all_ids; id
                       end
                   | (id::rest) =>
                       (id_cache := rest;
                        all_ids := id :: !all_ids;
                        id)

                 fun add_dynamic_item menu (PUSH (name,action,sensitive)) =
                   let
                     val id = get_id ()
                   in
                     WindowsGui.appendMenu (menu,[WindowsGui.MF_STRING],WindowsGui.ITEM id,name);
                     WindowsGui.addCommandHandler (real_parent,id,fn _ => action ());
                     (fn _ =>
                      WindowsGui.enableMenuItem
                      (menu,id,
                       [if sensitive ()
                          then WindowsGui.MF_ENABLED
                        else WindowsGui.MF_GRAYED]))
                   end
                 | add_dynamic_item _ _ = Crash.impossible "add_dynamic_item"
                 (* This attempts to reuse the identifiers *)
                 fun init (the_menu, loop_fn) = 
                   (ignore(loop_fn (!count_ref));
                    id_cache := !all_ids @@ !id_cache; (* add currently used ids to cache *)
                    all_ids := [];
                    let
                      val subfns = map (add_dynamic_item the_menu) ( (!actionRef) () )
                    in
                      count_ref := length subfns;
                      app (fn f => f ()) subfns
                    end)
               in
                 actionRef := f;
                 sensitiveRef := sensitive;
		 if name = "" then 
		   SOME (fn _ =>
		     (init (menu, fn n => loopto (menu, (!count_ref) + base_count, base_count))))
		 else
                   (WindowsGui.appendMenu (menu,[WindowsGui.MF_POPUP],WindowsGui.SUBMENU submenu,label);
                    SOME (fn _ => (init (submenu, loop))))
               end
           | CASCADE (name,subitems,sensitive) =>
               let
                 val label = LabelStrings.get_label name

		 (* Using LabelStrings.get_action to retrieve the id for some reason 
		  * retrieves an incorrect id and hence enabling and disabling a cascade
		  * menu item doesn't work.  A workaround is in place which uses the
		  * position of the cascade menu item to enable or disable it.  Also 
		  * only those cascade menu items which do not appear on the main menubar
		  * are ever disabled - this is intended. *)
		 val id = WindowsGui.intToWord ((!itemCount) - 1)
		 val temp = (!itemCount)
		 val _ = itemCount := 0
                 val (_, actionRef, sensitiveRef) = addRef name
                 val submenu = WindowsGui.createPopupMenu ()
		 fun enable_fn () = 
		   WindowsGui.enableMenuItem (menu, id, 
		      if (!sensitiveRef)() orelse (not isSubmenu) then 
			[WindowsGui.MF_ENABLED, WindowsGui.MF_BYPOSITION]
		      else
			[WindowsGui.MF_GRAYED, WindowsGui.MF_BYPOSITION])

                 val subfns = (SOME enable_fn) :: (map (add_item submenu true) subitems)
		 val _ = itemCount := temp
               in
		 sensitiveRef := sensitive;
		 if (!sensitiveRef)() orelse (not isSubmenu) then 
		   WindowsGui.appendMenu (menu, [WindowsGui.MF_POPUP,
					      WindowsGui.MF_ENABLED], 
							WindowsGui.SUBMENU submenu, label)
		 else
       	       	   WindowsGui.appendMenu (menu,[WindowsGui.MF_POPUP,
					     WindowsGui.MF_GRAYED],WindowsGui.SUBMENU submenu,label);
                 SOME
                 (fn _ =>
                  app (fn (SOME f) => f () | NONE => ()) subfns)
               end)
            
	(* This function is more general than necessary for Version 1.0,
	   but is useful for a more complete Help menu. *)
        fun add_help menu =
          let
            val help_menu = WindowsGui.createPopupMenu ()
            datatype Item = ITEM of string * WindowsGui.word | SEPARATOR
            fun add_item (ITEM (name,id)) =
                WindowsGui.appendMenu
		  (help_menu,[WindowsGui.MF_STRING],WindowsGui.ITEM id,name)
              | add_item SEPARATOR =
                WindowsGui.appendMenu (help_menu,[WindowsGui.MF_SEPARATOR],null_item,"")
	    fun help_item (name, action) = 
	      let 
                val label = LabelStrings.get_label name
                val id = LabelStrings.get_action name 
	      in
	        WindowsGui.addCommandHandler(real_parent, id, fn _ => action());
		ITEM (label, id)
	      end

	    fun getBitmap args = 
        	(MLWorks.Internal.Runtime.environment "win32 get splash bitmap") args
	    fun paintBitmap dc = 
		(MLWorks.Internal.Runtime.environment "win32 paint splash bitmap") dc  

	    val adWindow = ref WindowsGui.nullWindow
	    val licWindow = ref WindowsGui.nullWindow

	    fun mkDialog (resourceName, windowRef, creationFn) = 
	      let
		val w = 
		  if (WindowsGui.isWindow (!windowRef)) then (!windowRef) 
		  else WindowsGui.createDialog(WindowsGui.getModuleHandle(""), 
					       real_parent, resourceName)
		
		val _ = if (w = WindowsGui.nullWindow) then 
			  Crash.impossible "dialog resource not found\n"
			else ()

		fun destroyW _ = (WindowsGui.destroyWindow w; 
				  windowRef := WindowsGui.nullWindow)

		fun addCommands () = 
		  (WindowsGui.addCommandHandler(w, ok_id, destroyW);
                   WindowsGui.addMessageHandler(real_parent, WindowsGui.WM_SHOWWINDOW, 
                    			        minimizefun w))
              in
		if ((!windowRef) = WindowsGui.nullWindow) then
		  (ignore (creationFn w);
		   addCommands();
		   windowRef := w)
		else ();
		WindowsGui.showWindow (w, WindowsGui.SW_SHOW);
		WindowsGui.bringWindowToTop w
	      end

	    fun personalAd () = 
	      mkDialog ("PERSONAL_AD", adWindow,
		  fn w => (ignore (getBitmap (w, 2));
			   WindowsGui.centerWindow (w, WindowsGui.getDesktopWindow());
			   WindowsGui.addMessageHandler(w, WindowsGui.WM_PAINT, 
				fn _ => (ignore (paintBitmap (WindowsGui.getDC w)); NONE))))

	    fun mlwLicensing () = mkDialog ("MLWORKS_LICENSE", licWindow, fn w => ())

	    val help_items = 
	      let
		val open_web_location : string -> unit = env "win32 open web location"
		val source_path_opt = Getenv.get_source_path()
		val source_path = 
		  if isSome(source_path_opt) then 
		    valOf(source_path_opt)
		  else ""
		val doc_path = source_path ^ "\\documentation\\"
		fun guide () = 
		  open_web_location (doc_path ^ "guide\\html\\index.htm")
		fun reference () = 
		  open_web_location (doc_path ^ "reference\\html\\index.htm")
		fun install () = 
		  open_web_location (doc_path ^ "installation-notes\\html\\index.htm")
		fun relnotes () = 
		  open_web_location (doc_path ^ "release-notes\\html\\index.htm")
		val aboutMLW = 
		  if (Version.edition() = Version.PERSONAL) then
		    [("personalAd", personalAd), ("mlwLicensing", mlwLicensing)]
		  else [("mlwLicensing", mlwLicensing)]
	      in
		(map help_item 
		  [("userGuide", guide),
		   ("referenceMan", reference),
		   ("installationHelp", install),
		   ("releaseNotes", relnotes)]) @@ 
		[SEPARATOR] @@
		(map help_item aboutMLW)
	      end

          in
            app add_item 
              (help_items @@ [ITEM ("&About MLWorks...",       IDM_ABOUT)]);
            WindowsGui.appendMenu
	      (menu,[WindowsGui.MF_POPUP],WindowsGui.SUBMENU help_menu,"&Help")
          end

        val menu = WindowsGui.createMenu ()
        val itemfns = map (add_item menu false) menuspec
        fun update_fn _ =
          (app
           (fn NONE => ()
             | SOME f => f ())
           itemfns;
           SOME WindowsGui.nullWord)
      in
        add_help menu;
        WindowsGui.addMessageHandler (real_parent,WindowsGui.WM_INITMENU,update_fn);
	if isPodium then 
	  setItems menuspec
	else
	  changeItems (parent, menuspec);
        WindowsGui.setMenu (real_parent,menu)
      end

    (* The dependency graph and the tools menu have different menu structures between
     * Motif and Windows - see the signature file for details.
     *)
    fun get_graph_menuspec (close, graph) = [close, graph]
    fun get_tools_menuspec (tools_buttons, update_fn) = 
      CASCADE ("tools", tools_buttons @@ 
			[SEPARATOR, 
			DYNAMIC ("", update_fn, k true)], fn _ => true)

    datatype ToolButton = TB_SEP | TB_TOGGLE | TB_PUSH | TB_GROUP | TB_TOGGLE_GROUP
    datatype ToolState = CHECKED | ENABLED | HIDDEN | GRAYED | PRESSED | WRAP
    datatype ToolButtonSpec = TOOLBUTTON of 
	{style:	ToolButton,
	 states: ToolState list,
	 tooltip_id: int,
	 name: string}

(* The following function shares the reference lists for storing the actions
 * and sensitivity functions of the menu items.  These functions can then
 * be obtained when only the name of the menu item is given, and also keeps
 * the tool buttons consistent with their associated menu items.
 *)
    fun make_toolbar (parent, bmp_id, buttonSpec) = 
      let 
	val i2w = WindowsGui.intToWord
	val pwin = CapiTypes.get_real parent
	val toolbar_id = WindowsGui.newControlId()
	val num_buttons = Lists.length buttonSpec
	val button_count = ref 0

        fun add_button (TOOLBUTTON
	    {style = style, states = states,
	     tooltip_id = tip_id, name = name}) = 
          let
 	    val id = if (style = TB_PUSH) orelse (style = TB_TOGGLE) then 
	        WindowsGui.newControlId() 
	      else
	        WindowsGui.nullWord
	    val style = 
	      case style of 
	          TB_SEP => WindowsGui.TBSTYLE_SEP
	        | TB_TOGGLE => WindowsGui.TBSTYLE_CHECK
	        | TB_PUSH => WindowsGui.TBSTYLE_BUTTON
	        | TB_GROUP => WindowsGui.TBSTYLE_GROUP
	        | TB_TOGGLE_GROUP => WindowsGui.TBSTYLE_CHECKGROUP
	    fun get_state state = 
	      case state of
	          CHECKED => WindowsGui.TBSTATE_CHECKED
	        | ENABLED => WindowsGui.TBSTATE_ENABLED
	        | HIDDEN => WindowsGui.TBSTATE_HIDDEN
	        | GRAYED => WindowsGui.TBSTATE_INDETERMINATE
	        | PRESSED => WindowsGui.TBSTATE_PRESSED
	        | WRAP => WindowsGui.TBSTATE_WRAP
	    val tb_states = map get_state states
	    fun addCommand () = 
	      let 
	(* Given a name of a menu item to be duplicated as a toolbutton, the action and
	 * sensitivity functions can be obtained from the reference lists used to update
	 * the single menu bar.
	 *)
		val (name, act_ref, sens_ref) = getMenuRef name menuItems
		  handle Lists.Find => 
			if (name <> "interruptButton") then raise Lists.Find 
			else ("interruptButton", ref (fn () => ()), ref (fn () => true))
	        fun command _ = (!act_ref)()
	      in 
	        (WindowsGui.addCommandHandler(pwin, id, command); 
	         sens_ref)
	      end
	    val sens_ref_opt = case style of 
	        WindowsGui.TBSTYLE_CHECK => SOME (addCommand())
	      | WindowsGui.TBSTYLE_BUTTON => SOME (addCommand())
	      | _ => NONE

	    val bitmap_index = 
	      if (style = WindowsGui.TBSTYLE_SEP) then
		0
	      else
		(!button_count)
          in
	    if (style <> WindowsGui.TBSTYLE_SEP) then button_count := (!button_count) + 1 else ();

	(* sens function followed by a further tuple containing:
	 *	(bitmap index, id, states, styles, res id of tooltip, string index) *)
	    (name, sens_ref_opt, (bitmap_index, id, tb_states, [style], i2w tip_id, 0))
          end

	val buttonList = map add_button buttonSpec
	val buttons = map #3 buttonList

	val widg = WindowsGui.createToolbarEx
                {parent = pwin, styles = [WindowsGui.TBSTYLE_TOOLTIPS, WindowsGui.WS_CHILD],
                 bmp_id = i2w bmp_id, toolbar_id = toolbar_id,
                 num_bmps = num_buttons, num_buttons = num_buttons,
                 x_bitmap = 16, y_bitmap = 16,
                 x_button = 16, y_button = 16,
                 buttons = buttons}

	val processNotify : WindowsGui.hwnd * WindowsGui.wparam * WindowsGui.lparam -> unit = 
		env "win32 process notify"
        fun process_notify (w,l) = (processNotify (widg,w,l); NONE)

	(* get_sens function takes a list of button info as returned by a mapped call
	 * to add_button, and returns a list of tuples storing (name, id, sens_function)
	 *)
	fun get_sens (name, sens, (_,id,_,_,_,_)) = (name, id, fn () => (!(valOf(sens))) () )

	(* sens_list stores a list of button info for those buttons that have a sensitivity 
	 * function, ie. only those of type TB_TOGGLE or TB_PUSH
	 *)
	val sens_list = Lists.filterp (fn (_,sens_ref_opt,_) => isSome sens_ref_opt) buttonList

	(* idsensList is a list of tuples (see comment on get_sens) for those buttons which 
	 * have a sensitivity function.  This list is used to update the toolbar so that the
	 * right buttons are enabled at the right time.
	 *)
	val idsensList = map get_sens sens_list

	fun setButtonState (id, states) = 
	  WindowsGui.sendMessage(widg, WindowsGui.TB_SETSTATE, WindowsGui.WPARAM id, 
	    WindowsGui.LPARAM (WindowsGui.tbStatesToWord states))

	fun isToggle name = Lists.member (name, map (fn (s,_,_) => s) (!toggles))
	fun toggleChecked name = 
	  if isToggle name then 
	    !(#2 (Lists.findp (fn (s,_,_) => (s = name)) (!toggles)))
	  else 
	    false

	fun get_states (name, sens_fn) = 
	  (if sens_fn() then WindowsGui.TBSTATE_ENABLED else WindowsGui.TBSTATE_INDETERMINATE) :: 
	  (if (isToggle name) andalso (toggleChecked name) then [WindowsGui.TBSTATE_CHECKED] 
	  else [])

	fun update_one (name, id, sens_fn) = setButtonState (id, get_states(name, sens_fn))

	fun update _ = (app (ignore o update_one) idsensList; NONE)
	val interrupt = env "win32 interrupt"
	val set_interrupt_window = env "nt set interrupt window"

	val (_,_,(_,interrupt_id,_,_,_,_)) = 
	  Lists.findp (fn (name,_,_) => (name = "interruptButton")) buttonList
      in
	ignore(set_interrupt_window widg);
	WindowsGui.addCommandHandler(pwin, interrupt_id, fn _ => interrupt());
	update_ref := (fn () => (app (ignore o update_one) idsensList; ()));
	WindowsGui.addMessageHandler(pwin, WindowsGui.WM_NCACTIVATE, update);
	WindowsGui.addMessageHandler(pwin, WindowsGui.WM_PARENTNOTIFY, update);
	WindowsGui.addMessageHandler(pwin, WindowsGui.WM_INITMENU, update);
        WindowsGui.addMessageHandler(pwin, WindowsGui.WM_NOTIFY, process_notify);
	CapiTypes.REAL (widg, parent)
      end	

    val sendMessageNoResult = ignore o WindowsGui.sendMessage;

    fun set_gui_font window =
      let
        val WindowsGui.OBJECT gui_font =
          WindowsGui.getStockObject (WindowsGui.DEFAULT_GUI_FONT)
          handle
            WindowsGui.WindowSystemError _ =>
              WindowsGui.getStockObject (WindowsGui.ANSI_VAR_FONT)
      in
        sendMessageNoResult
          (window,
           WindowsGui.WM_SETFONT,
           WindowsGui.WPARAM gui_font,
           WindowsGui.LPARAM (WindowsGui.intToWord 0))
      end
      handle WindowsGui.WindowSystemError _ => ()

    fun make_buttons (parent, menuspec) =
      (* parent is a "frame" type widget *)
      let
        val real_parent = CapiTypes.get_real parent
        (* This should calculate how big the buttons need to be *)
        val right_margin = 5
        val spacing = 5
        val top_margin = 5
        val height = 20
	val internal_space = 25
        val xref = ref right_margin
        (* now some stuff for calculating the text sizes *)
        val dc = WindowsGui.getDC real_parent

	val first_radio = ref true

	(* To change the font used by the button, we have to send a
	   WM_SETFONT message after the window is created.  But this
	   doesn't change the size of the window to match the text, so
	   we also change the font in the display context before working
	   out the size of the displayed string.  Changing the display
	   context alone does not change the font used in the display.
	 *)
	val _ =
	  let
            val WindowsGui.OBJECT gui_font =
              WindowsGui.getStockObject (WindowsGui.DEFAULT_GUI_FONT)
              handle
                WindowsGui.WindowSystemError _ =>
                  WindowsGui.getStockObject (WindowsGui.ANSI_VAR_FONT)
	  in
	    ignore(WindowsGui.selectObject (dc, WindowsGui.OBJECT gui_font));
	    ()
          end
	  handle WindowsGui.WindowSystemError _ => ()

        fun do_one (PUSH (name,callback,sensitive)) =
          let
            val id = LabelStrings.get_action name
            val label = LabelStrings.get_label name
            val (twidth,_) = WindowsGui.getTextExtentPoint (dc,label)
            val width = twidth + internal_space
            val button = 
              WindowsGui.createWindow
              {class = "BUTTON",
               name = label,
               styles = [WindowsGui.WS_CHILD,WindowsGui.BS_PUSHBUTTON],
               width = 10,
               height = 10,
               parent = real_parent,
               menu = id}
            fun set_sensitivity () =
              (ignore(WindowsGui.enableWindow (button,sensitive()));
               ())
          in
	    set_gui_font button;
            WindowsGui.moveWindow (button,!xref,top_margin,width,height,false);
            WindowsGui.showWindow (button,WindowsGui.SW_SHOW);
            WindowsGui.updateWindow button;
            xref := !xref + width + spacing;
            (* This should check what the notification event is *)
            WindowsGui.addCommandHandler (real_parent,id,fn n => callback ());
	    (* Push buttons add a command handler to their grandparent as
	       well.  In the MLWorks GUI, this is the top level widget.
	       This allows accelerators to refer to buttons as well as
	       menu entries.  It is fragile; changes in the window hierarchy
	       will break this. *)
            WindowsGui.addCommandHandler
	      (WindowsGui.getParent real_parent, id, fn n => callback ());
            set_sensitivity
          end
	| do_one (TOGGLE (name, get, set, sensitive)) =
	  let
            val id = LabelStrings.get_action name
            val label = LabelStrings.get_label name
            val (twidth,_) = WindowsGui.getTextExtentPoint (dc,label)
            val width = twidth + internal_space
            val button = 
              WindowsGui.createWindow
              {class = "BUTTON",
               name = label,
               styles = [WindowsGui.WS_CHILD,WindowsGui.BS_AUTOCHECKBOX],
               width = 10,
               height = 10,
               parent = real_parent,
               menu = id}
            fun set_sensitivity () =
              (WindowsGui.checkDlgButton (real_parent, id, if get() then 1 else 0);
	       ignore(WindowsGui.enableWindow (button,sensitive()));
               ())
	  in
	    set_gui_font button;
            WindowsGui.moveWindow (button,!xref,top_margin,width,height,false);
            WindowsGui.showWindow (button,WindowsGui.SW_SHOW);
            WindowsGui.updateWindow button;
            xref := !xref + width + spacing;
            WindowsGui.addCommandHandler 
	      (WindowsGui.getParent real_parent, id, fn n => set(not(get())));
            WindowsGui.addCommandHandler 
	      (WindowsGui.getParent (WindowsGui.getParent real_parent), id, fn n => set(not(get())));
            set_sensitivity
          end

	| do_one (RADIO (name, get, set, sensitive)) =
          let
            val id = LabelStrings.get_action name
            val label = LabelStrings.get_label name
            val (twidth,_) = WindowsGui.getTextExtentPoint (dc,label)
            val width = twidth + internal_space
            val button = 
              WindowsGui.createWindow
              {class = "BUTTON",
               name = label,
               styles = [WindowsGui.WS_CHILD,WindowsGui.BS_AUTORADIOBUTTON] @@ 
			(if (!first_radio) then [WindowsGui.WS_GROUP] else []),
               width = 10,
               height = 10,
               parent = real_parent,
               menu = id}
            fun set_sensitivity () =
              (WindowsGui.checkDlgButton (real_parent, id, if get() then 1 else 0);
	       ignore(WindowsGui.enableWindow (button,sensitive()));
               ())
          in
	    set_gui_font button;
	    first_radio := false;
            WindowsGui.moveWindow (button,!xref,top_margin,width,height,false);
            WindowsGui.showWindow (button,WindowsGui.SW_SHOW);
            WindowsGui.updateWindow button;
            xref := !xref + width + spacing;

(* WWW *)  (* This should check what the notification event is *)
            WindowsGui.addCommandHandler 
	      (real_parent, id, fn n => set true);
            WindowsGui.addCommandHandler 
	      (WindowsGui.getParent real_parent, id, fn n => set true);
            WindowsGui.addCommandHandler 
	      (WindowsGui.getParent (WindowsGui.getParent real_parent), id, fn n => set true);
	
	    (* Push buttons add a command handler to their grandparent as
	       well.  In the MLWorks GUI, this is the top level widget.
	       This allows accelerators to refer to buttons as well as
	       menu entries.  It is fragile; changes in the window hierarchy
	       will break this. *)

            set_sensitivity
          end

        | do_one (LABEL (name)) =
          let
            val label = LabelStrings.get_label name
            val (twidth,_) = WindowsGui.getTextExtentPoint (dc,label)
            val width = twidth + internal_space
            val button =
              WindowsGui.createWindow
              {class = "STATIC",
               name = label,
               styles = [WindowsGui.WS_CHILD,WindowsGui.SS_CENTER],
               width = 10,
               height = 10,
               parent = real_parent,
               menu = WindowsGui.nullWord}
          in
	    set_gui_font button;
            WindowsGui.moveWindow (button,!xref,top_margin,width,height,false);
            WindowsGui.showWindow (button,WindowsGui.SW_SHOW);
            WindowsGui.updateWindow button;
            xref := !xref + width + spacing;
            fn _ => ()
          end
        | do_one (SLIDER (name,min,max,set_value)) =
            let
              val width = 300
              val id = LabelStrings.get_action name
              val label = LabelStrings.get_label name
              val curpos = ref 0
              val line_increment = (max - min) div 50
	      val page_increment = (max - min) div 10
              val slider =
                WindowsGui.createWindow
                {class = "SCROLLBAR",
                 name = label,
                 styles = [WindowsGui.WS_CHILD,WindowsGui.SBS_HORZ],
                 width = 10,
                 height = 10,
                 parent = real_parent,
                 menu = id}
                fun handler (WindowsGui.WPARAM wparam, WindowsGui.LPARAM lparam) =
                  let
                    val code = WindowsGui.loword wparam
		    val convert = WindowsGui.convertSbValue
		    val pos = 
		      if code = convert WindowsGui.SB_THUMBPOSITION then
			WindowsGui.hiword wparam
		      else if code = convert WindowsGui.SB_LINELEFT then 
			let val temp_pos = !curpos - line_increment
			in
			  if (temp_pos < min) then min else temp_pos
			end
		      else if code = convert WindowsGui.SB_LINERIGHT then
			let val temp_pos = !curpos + line_increment
			in
			  if (temp_pos > max) then max else temp_pos
			end
		      else if code = convert WindowsGui.SB_PAGELEFT then
			let val temp_pos = !curpos - page_increment
			in
			  if (temp_pos < min) then min else temp_pos
			end
		      else if code = convert WindowsGui.SB_PAGERIGHT then
			let val temp_pos = !curpos + page_increment
			in
			  if (temp_pos > max) then max else temp_pos
			end
		      else !curpos
                  in
		    set_value pos;
		    curpos := pos;
		    WindowsGui.setScrollPos (slider, WindowsGui.SB_CTL, pos, true);
                    SOME WindowsGui.nullWord
                  end
            in
              WindowsGui.setScrollRange (slider,WindowsGui.SB_CTL,min,max,false);
              WindowsGui.moveWindow (slider,!xref,top_margin,width,height,false);
              WindowsGui.showWindow (slider,WindowsGui.SW_SHOW);
              WindowsGui.updateWindow slider;
              xref := !xref + width + spacing;
              WindowsGui.addMessageHandler (real_parent,WindowsGui.WM_HSCROLL,handler);
              fn _ => ()
            end
        | do_one _ = (fn _ => ())
        val set_sensitivity_fns = map do_one menuspec
      in
        WindowsGui.releaseDC (real_parent,dc);
        {update = fn _ => app (fn f => f ()) set_sensitivity_fns,
	 set_focus = fn _ => ()}
      end

    (* DIALOGS *)

    datatype ItemTemplate =
      ITEMTEMPLATE of
      {styles: WindowsGui.window_style list,
       x: int,
       y: int,
       width: int,
       height: int,
       id : WindowsGui.word,
       class : string,
       text: string}

    (* For the moment, no menu, standard dialog class *)
    datatype Template =
      TEMPLATE of
      {styles: WindowsGui.window_style list,
       x: int,
       y: int,
       width: int,
       height: int,
       title: string,
       items: ItemTemplate list,
       nitems: int}

    datatype selection = SINGLE | EXTENDED

    (* First function is get the value for the widget
       second is set the value for the widget, and returns accept/reject *)
    datatype OptionSpec =
      OPTSEPARATOR |
      OPTLABEL of string |
      OPTTOGGLE of string * (unit -> bool) * (bool -> bool) |
      OPTTEXT of string * (unit -> string) * (string -> bool) |
      OPTINT of string * (unit -> int) * (int -> bool) |
      OPTRADIO of OptionSpec list |
      OPTCOMBO of string * (unit -> string * string list) * (string -> bool) |
      OPTLIST of string * 
		 (unit -> string list * string list) * 
		 (string list -> bool) * 
		 selection

    val create_dialog_indirect : Template * WindowsGui.hwnd -> WindowsGui.hwnd = env "nt create dialog indirect"
    val dialog_box_indirect : Template * WindowsGui.hwnd -> int = env "nt dialog box indirect"

    (* Next 4 functions taken straight from _capi, need some sharing here *)
    fun munge_string s =
      let
        fun munge ([],acc) = implode (rev acc)
          | munge (#"\013" :: #"\010" :: rest,acc) = munge (rest, #"\010" :: #"\013" :: acc)
          | munge (#"\n" ::rest,acc) = munge (rest, #"\010" :: #"\013" :: acc)
          | munge (c::rest,acc) = munge (rest,c::acc)
      in
        munge (explode s,[])
      end


    fun set_text (window,s) =
      let
        val string_word = WindowsGui.makeCString (munge_string s)
      in
        sendMessageNoResult (window,WindowsGui.WM_SETTEXT,
                             WindowsGui.WPARAM (WindowsGui.nullWord),
                             WindowsGui.LPARAM string_word);
        WindowsGui.free string_word
      end

    fun text_size text =
      WindowsGui.wordToInt (WindowsGui.sendMessage (text,
                                              WindowsGui.WM_GETTEXTLENGTH,
                                              WindowsGui.WPARAM WindowsGui.nullWord,
                                              WindowsGui.LPARAM WindowsGui.nullWord))
    fun get_text (window) =
      let
        val size = text_size window
        (* What happens if the text changes at this point? *)
        val buffer = WindowsGui.malloc (size+1) (* extra for null termination *)
        (* should check for malloc failure here *)
        val _ = WindowsGui.sendMessage (window,
                                     WindowsGui.WM_GETTEXT,
                                     WindowsGui.WPARAM (WindowsGui.intToWord (size+1)), (* add 1 for the last null character *)
                                     WindowsGui.LPARAM buffer)
        val _ = WindowsGui.setByte (buffer,size,0) (* null terminate *) (* probably not necessary *)
        val result = WindowsGui.wordToString buffer
      in
        WindowsGui.free buffer;
        result
      end

    (* some dimensions *)
    val x_margin = 4
    val y_margin = 4
    val item_height = 10
    val text_height = 12
    val item_sep = 4
    val item_width = 150
    val text_width = 75
    val int_width = 40

    fun bell () = WindowsGui.messageBeep WindowsGui.MB_OK
      
    exception InvalidControl of string

    (* Once all dialogs created using Menus.create_dialog have been converted
     * to resources, the function convert_spec below will be superseeded by
     * resource_convert_spec, and should then be removed.
     *)
    fun convert_spec (title,action,speclist) =
      let
        val yref = ref y_margin
        fun do_spec (acc as (templates,initializers,setters,ids),spec) =
          case spec of
           OPTSEPARATOR => 
              let
                val template =
                  ITEMTEMPLATE
                  {styles = [WindowsGui.SS_GRAYRECT,
                             WindowsGui.WS_CHILD,
                             WindowsGui.WS_VISIBLE],
                   x = 0,
                   y = !yref,
                   width = item_width + x_margin + x_margin,
                   height = 1,
                   class = "STATIC",
                   text = "",
                   id = WindowsGui.nullWord}
              in
                yref := !yref + item_sep; 
                (template :: templates,initializers,setters,ids)
              end
          | OPTLABEL string =>
              let
                val template =
                  ITEMTEMPLATE
                  {styles = [WindowsGui.SS_LEFT,
                             WindowsGui.WS_CHILD,
                             WindowsGui.WS_VISIBLE],
                   x = x_margin,
                   y = !yref,
                   width = item_width,
                   height = item_height,
                   class = "STATIC",
                   text = LabelStrings.get_label string,
                   id = WindowsGui.nullWord}
              in
                yref := !yref + item_height + item_sep;
                (template :: templates,initializers,setters,ids)
              end
          | OPTTOGGLE (string,get,set) =>
              let
                val id = LabelStrings.get_action string
                val template =
                  ITEMTEMPLATE
                  {styles = [WindowsGui.BS_AUTOCHECKBOX,
                             WindowsGui.WS_CHILD,
                             WindowsGui.WS_TABSTOP,
                             WindowsGui.WS_VISIBLE],
                   x = x_margin,
                   y = !yref,
                   width = item_width,
                   height = item_height,
                   class = "BUTTON",
                   text = LabelStrings.get_label string,
                   id = id}
                fun initializer hwnd =
                  let val value = get ()
                  in WindowsGui.checkDlgButton (hwnd,id,if value then 1 else 0)
                  end
                fun setter hwnd =
                  let
		    val value = (WindowsGui.isDlgButtonChecked (hwnd,id) = 1)
		    val settable =  set value
		  in
		    if settable then () else (bell ();
					      initializer hwnd)
                  end
              in
                yref := !yref + item_height + item_sep;
                (template :: templates,
                 initializer:: initializers,
                 setter :: setters,
                 id :: ids)
              end
          | OPTTEXT (string,get,set) =>
              let
                val id = LabelStrings.get_action string
                val text_template =
                  ITEMTEMPLATE
                  {styles = [WindowsGui.WS_CHILD,
                             WindowsGui.WS_TABSTOP,
                             WindowsGui.WS_BORDER,
                             WindowsGui.WS_VISIBLE,
			     WindowsGui.ES_AUTOHSCROLL],
                   x = x_margin,
                   y = !yref,
                   width = text_width,
                   height = text_height,
                   class = "EDIT",
                   text = "",
                   id = id}
                val label_template =
                  ITEMTEMPLATE
                  {styles = [WindowsGui.WS_CHILD,
                             WindowsGui.SS_LEFT,
                             WindowsGui.WS_VISIBLE],
                   x = x_margin + text_width + 2,
                   y = !yref + text_height - item_height,
                   width = item_width - text_width,
                   height = item_height,
                   class = "STATIC",
                   text = LabelStrings.get_label string,
                   id = WindowsGui.nullWord}
                fun get_input_pane hwnd = WindowsGui.getDlgItem (hwnd,id)
                fun initializer hwnd = set_text (get_input_pane hwnd,get ())
                fun setter hwnd =
		  let val settable = set (get_text (get_input_pane hwnd))
		  in if settable then () else (bell();
					       initializer hwnd)
		  end
              in
                yref := !yref + text_height + item_sep;
                (label_template :: text_template :: templates,
                 initializer:: initializers,
                 setter :: setters,
                 id :: ids)
              end
	  | OPTCOMBO _ => raise InvalidControl "Combo box only available as resource"
	  | OPTLIST _ => raise InvalidControl "List box only available as resource"
          | OPTINT (string,get,set) =>
              let
                val id = LabelStrings.get_action string
                val text_template =
                  ITEMTEMPLATE
                  {styles = [WindowsGui.WS_CHILD,
                             WindowsGui.WS_BORDER,
                             WindowsGui.WS_TABSTOP,
                             WindowsGui.WS_VISIBLE],
                   x = x_margin,
                   y = !yref,
                   width = int_width,
                   height = text_height,
                   class = "EDIT",
                   text = "",
                   id = id}
                val label_template =
                  ITEMTEMPLATE
                  {styles = [WindowsGui.WS_CHILD,
                             WindowsGui.SS_LEFT,
                             WindowsGui.WS_VISIBLE],
                   x = x_margin + int_width + 2,
                   y = !yref + text_height - item_height,
                   width = item_width - int_width,
                   height = item_height,
                   class = "STATIC",
                   text = LabelStrings.get_label string,
                   id = WindowsGui.nullWord}
                fun get_input_pane hwnd = WindowsGui.getDlgItem (hwnd,id)
                fun initializer hwnd = set_text (get_input_pane hwnd,Int.toString (get ()))
                fun setter hwnd = 
		  let
		    val num = Int.fromString (get_text (get_input_pane hwnd))
		    val settable =
		      (case num of
			 SOME n => set n
		       | _ => false)
		  in
		    if settable then () else
		      (bell();
		       initializer hwnd)
		  end
              in
                yref := !yref + text_height + item_sep;
                (label_template :: text_template :: templates,
                 initializer:: initializers,
                 setter :: setters,
                 id :: ids)
              end
          | OPTRADIO (itemspecs) =>
              let
                val first = ref true
                fun do_one (OPTTOGGLE (string,get,set)) =
                  let
                    val is_first = !first
                    val _ = first := false
                    val id = LabelStrings.get_action string
                    val text = LabelStrings.get_label string
(*
                    val _ = print ("Radio: " ^ string ^ " " ^ W id ^ "\n")
*)
                    val template =
                      ITEMTEMPLATE
                      {styles = (if is_first then [WindowsGui.WS_GROUP,
                                                   WindowsGui.WS_TABSTOP]
                                 else []) @@
                                [WindowsGui.WS_CHILD,
                                 WindowsGui.WS_VISIBLE,
                                 WindowsGui.BS_AUTORADIOBUTTON],
                       x = x_margin,
                       y = !yref,
                       width = item_width,
                       height = item_height,
                       class = "BUTTON",
                       text = text,
                       id = id}
                  in
                    yref := !yref + item_height + item_sep;
                    (template,(get,id,string),(set,id))
                  end
                  | do_one _ = Crash.impossible "Non toggle button in OPTRADIO"
                val stuff = map do_one itemspecs
                val new_templates = map #1 stuff
                val getids = map #2 stuff
                val setids = map #3 stuff
                val new_ids = map #2 getids
                fun get_ends (a::rest) =
                  let
                    fun aux [] = (a,a)
                      | aux [b] = (a,b)
                      | aux (b::rest) = aux rest
                  in
                    aux rest
                  end
                | get_ends _ = Crash.impossible "get_ends"
                val (first,last) = get_ends new_ids
                fun initializer hwnd =
                  Lists.iterate
                  (fn (get,id,string) =>
                   WindowsGui.checkDlgButton (hwnd,id,if get() then 1 else 0))
                  getids
(* check_radio_button seems to assume that the identifiers are in order *)                  
(* so we don't use it here *)
(*
                fun initializer hwnd =
                  Lists.iterate
                  (fn (get,id,string) =>
                   if get () then
                     (print ("Checking: " ^ string ^ " " ^ W first ^ " " ^ W last ^ " " ^ W id ^ "\n");
                      WindowsGui.checkRadioButton (hwnd,first,last,id))
                   else ())
                  getids
*)
                fun setter hwnd =
                  Lists.iterate
                  (fn (set,id) =>
                   if WindowsGui.isDlgButtonChecked (hwnd,id) = 1
                     then set true
                   else true)
                  setids
              in
                (* The templates etc. are accumulated in _reverse_ order *)
                (rev new_templates @@ templates,
                 initializer :: initializers,
                 setter :: setters,
                 rev new_ids @@ ids)
              end
        val (itemspecs,initializers,setters,ids) = Lists.reducel do_spec (([],[],[],[]),speclist)
        val button_specs =
          ITEMTEMPLATE
          {styles = [WindowsGui.SS_GRAYRECT,
                     WindowsGui.WS_CHILD,
                     WindowsGui.WS_VISIBLE],
           x = 0,
           y = !yref,
           width = item_width + x_margin + x_margin,
           height = 1,
           class = "STATIC",
           text = "",
           id = WindowsGui.nullWord} ::
          map 
          (fn (x,text,id,default) =>
           ITEMTEMPLATE
           {styles = [WindowsGui.WS_CHILD,
                      if default then WindowsGui.BS_DEFPUSHBUTTON
                      else WindowsGui.BS_PUSHBUTTON,
                      WindowsGui.WS_VISIBLE],
            x = x,
            y = !yref + item_sep,
            width = 30,
            height = 10,
            class = "BUTTON",
            text = text,
            id = id})
          [(x_margin,"OK",ok_id,true),
           (x_margin + 35,"Apply",apply_id,false),
           (x_margin + 70,"Reset",reset_id,false),
           (x_margin + 105,"Cancel",cancel_id,false)]
        val items = rev itemspecs @@ button_specs
      in
        (TEMPLATE
         {styles = [WindowsGui.WS_POPUP,
                    WindowsGui.WS_CAPTION,
                    (* WindowsGui.WS_DLGFRAME, *) (* This seems to do nothing *)
                    WindowsGui.WS_SYSMENU,
                    WindowsGui.WS_VISIBLE],
          x = 40,
          y = 40,
          width = item_width + x_margin + x_margin + 2,
          height = !yref + y_margin + item_sep + 10,
          title = title,
          items = items,
          nitems = length items},
         rev initializers, rev setters, (* these fns in same order as the definition *)
         ids,
         (ok_id,apply_id,reset_id,cancel_id))
      end

    fun strip_string_controls (s:string):string =
      implode (List.filter (fn c=>not(c < #" ")) (explode s))

    local
      fun itemTextWidth (hwnd, combo) (_, (itemIndex, maxWidth)) =
        let
       	  val w = WindowsGui.WPARAM (WindowsGui.intToWord itemIndex)
          val l = WindowsGui.LPARAM WindowsGui.nullWord
	  val message = 
	    if combo then 
		WindowsGui.CB_GETLBTEXTLEN 
	    else 
		WindowsGui.LB_GETTEXTLEN
          val r = WindowsGui.sendMessage (hwnd, message, w, l)
          val maxWidth' = Int.max (WindowsGui.wordToInt r, maxWidth)
        in
          (itemIndex+1, maxWidth')
        end
    in
      fun itemsMaxTextWidth (hwnd, items, combo) = 
        let
          val (_, maxWidth) = 
	    List.foldl (itemTextWidth (hwnd, combo)) (0, 0) items
        in
          maxWidth
        end
    end  (* local *)

    (* add_items is used to add listbox and combobox items, therefore need to 
     * know whether to send the LB_ADDSTRING or CB_ADDSTRING Win32 API message *)
    fun add_items (hwnd, items, message) = 
      let 
        fun do_one item = 
          let val CString = WindowsGui.makeCString (strip_string_controls item)
          in
            sendMessageNoResult (hwnd, message,
    			         WindowsGui.WPARAM WindowsGui.nullWord,
	   			 WindowsGui.LPARAM CString);
	    WindowsGui.free CString
          end
      in
        Lists.iterate do_one items
      end

    fun resource_convert_spec speclist = 
      let 
	fun getResID name = WindowsGui.intToWord (ControlName.getResID name)
	fun do_spec ((initializers, setters, ids), idspec) = 
	  case idspec of
	    OPTTOGGLE (name, get, set) =>
	      let 
		val id = getResID name
		fun initializer hwnd = 
		  let val value = get()
		  in WindowsGui.checkDlgButton (hwnd, id, if value then 1 else 0)
		  end
		fun setter hwnd = 
		  let val settable = set (WindowsGui.isDlgButtonChecked (hwnd, id) = 1)
		  in if settable then () else (bell(); initializer hwnd)
		  end
	      in 
		(initializer :: initializers,
		setter :: setters,
		id :: ids)
	      end
	  | OPTTEXT (name, get, set) =>
	      let 
		val id = getResID name
		fun get_input_pane hwnd = WindowsGui.getDlgItem (hwnd,id)
		fun initializer hwnd = set_text (get_input_pane hwnd, get())
		fun setter hwnd = 
			(* get_text replaced with GetDlgItemText? *)
		  let val settable = set (get_text (get_input_pane hwnd))
		  in if settable then () else (bell();
					       initializer hwnd)
		  end
	      in
		(initializer :: initializers,
		setter :: setters,
		id :: ids)
	      end
	  | OPTCOMBO (name, get, set) => 
	      let
		val id = getResID name

		fun set_horizontal_extent hwnd = 
		  let 
		    val i2w = WindowsGui.intToWord
		    val charWidthInPixels = WindowsGui.loword(WindowsGui.getDialogBaseUnits())
		    val (init_string, items) = get()
		    val maxTextWidth = itemsMaxTextWidth (hwnd, items, true)
		  in
		    if maxTextWidth > 0 then
		      sendMessageNoResult
  			(hwnd, WindowsGui.CB_SETHORIZONTALEXTENT, 
			 WindowsGui.WPARAM (i2w (maxTextWidth * charWidthInPixels)),
			 WindowsGui.LPARAM WindowsGui.nullWord)
		    else ()
		  end

		fun initializer dialog = 
		  let 
		    val hwnd = WindowsGui.getDlgItem (dialog, id)
		  in
		    sendMessageNoResult(hwnd, WindowsGui.CB_RESETCONTENT, 
					WindowsGui.WPARAM WindowsGui.nullWord,
					WindowsGui.LPARAM WindowsGui.nullWord);
		    add_items (hwnd, #2(get()), WindowsGui.CB_ADDSTRING);
 		    set_horizontal_extent hwnd;
		    set_text (hwnd, #1(get()))
		  end

		fun setter dialog = 
		  let 
		    val new_text = get_text (WindowsGui.getDlgItem (dialog, id))
		    val settable = set new_text
		  in
		    if settable then () else
			(bell();
			initializer dialog)
		  end

	      in
		(initializer :: initializers,
		setter :: setters,
		id :: ids)
	      end
	  | OPTLIST (name, get, set, sel_type) =>
	      let
		val id = getResID name
		val null_w = WindowsGui.WPARAM WindowsGui.nullWord
		val null_l = WindowsGui.LPARAM WindowsGui.nullWord

		fun set_horizontal_extent hwnd = 
		  let 
		    val i2w = WindowsGui.intToWord
		    val charWidthInPixels = WindowsGui.loword(WindowsGui.getDialogBaseUnits())
		    val (items, sel_items) = get()
		    val maxTextWidth = itemsMaxTextWidth (hwnd, items, false)
		  in
		    if maxTextWidth > 0 then
		      sendMessageNoResult
  			(hwnd, WindowsGui.LB_SETHORIZONTALEXTENT, 
			 WindowsGui.WPARAM (i2w (maxTextWidth * charWidthInPixels)),
			 null_l) 
		    else ()
		  end

		fun select_items hwnd [] = ()
		  | select_items hwnd (str::rest) = 
		    let 
		      val w = WindowsGui.WPARAM (WindowsGui.intToWord (~1))
		      val CString = WindowsGui.makeCString (strip_string_controls str)
		      val l = WindowsGui.LPARAM CString
		    in
		      (* To select a value in an extended selection listbox, need
		       * to find the string in the listbox, given the index, then 
		       * use LB_SETSEL.  To select a value in a single selection 
		       * listbox, LB_SELECTSTRING can be used. *)
                      if sel_type = EXTENDED then 
			let val index = 
			      WindowsGui.sendMessage(hwnd, WindowsGui.LB_FINDSTRING, w, l)
			in
			  sendMessageNoResult
			    (hwnd, 
			     WindowsGui.LB_SETSEL, 
			     WindowsGui.WPARAM (WindowsGui.intToWord 1),
			     WindowsGui.LPARAM index)
			end
		      else
			sendMessageNoResult(hwnd, WindowsGui.LB_SELECTSTRING, w, l);
		      WindowsGui.free CString;
		      select_items hwnd rest
		    end

		fun initializer dialog = 
		  let 
		    val hwnd = WindowsGui.getDlgItem (dialog, id)
		    val (all_items, sel_items) = get()
		  in
		    sendMessageNoResult(hwnd, WindowsGui.LB_RESETCONTENT, null_w, null_l);
		    add_items (hwnd, all_items, WindowsGui.LB_ADDSTRING);
 		    set_horizontal_extent hwnd;
		    select_items hwnd sel_items
		  end

		fun setter dialog = 
		  let
		    val i2w = WindowsGui.intToWord
		    val hwnd = WindowsGui.getDlgItem (dialog, id)
		    val (all_items, sel_items) = get()
		    val maxWidth = itemsMaxTextWidth (hwnd, all_items, false)

		    fun get_list_string index = 
		      let
			val w = WindowsGui.WPARAM (WindowsGui.intToWord index)
		        val size = WindowsGui.wordToInt (WindowsGui.sendMessage 
				      (hwnd, WindowsGui.LB_GETTEXTLEN, w, null_l))

		        val buffer = WindowsGui.malloc (size+1)
		        (* should check for malloc failure here *)
		        val _ = WindowsGui.sendMessage 
				   (hwnd,
		                    WindowsGui.LB_GETTEXT, w,
		                    WindowsGui.LPARAM buffer)
		        val _ = WindowsGui.setByte (buffer,size,0) (* null terminate *)
		        val result = WindowsGui.wordToString buffer
		      in
		        WindowsGui.free buffer;
		        result
		      end

		    fun get_count () = 
		      WindowsGui.wordToInt 
			(WindowsGui.sendMessage
			   (hwnd, WindowsGui.LB_GETCOUNT, null_w, null_l))

		    (* The listbox can be sorted so we can't assume that the 
		     * selections appear in the list in the order they are given.
		     * Also this method of getting the selection strings applies 
		     * to both single and extended selection listboxes. *)
		    fun get_sel 0 sel_list = sel_list
		      | get_sel i sel_list = 
		        let
			  val w = WindowsGui.WPARAM (WindowsGui.intToWord (i-1))
			  val selected = 
			    (WindowsGui.sendMessage (hwnd, WindowsGui.LB_GETSEL, w, null_l)) <>
			    WindowsGui.nullWord
			  val new_sel_list = 
			    if selected then 
			      (get_list_string (i-1)) :: sel_list
			    else sel_list
			in
			  get_sel (i-1) new_sel_list
			end

		    val settable = set (get_sel (get_count()) [])

		  in
		    if settable then () else
			(bell();
			initializer dialog)
		  end (* fun setter *)

	      in
		(initializer :: initializers,
		setter :: setters,
		id :: ids)
	      end

	  | OPTINT (name, get, set) =>
	      let 
		val id = getResID name

		(* should be the following (setDlgItemInt):
		fun initializer hwnd = setDlgItemInt(hwnd, id, get(), true) *)

		fun get_input_pane hwnd = WindowsGui.getDlgItem (hwnd, id)
		fun initializer hwnd = set_text (get_input_pane hwnd,
						Int.toString (get()))
                fun setter hwnd = 
		  let
		    val num = Int.fromString (get_text (get_input_pane hwnd))
		    val settable = (case num of
			 		SOME n => set n
				       | _ => false)
		  in
		    if settable then () else
		      (bell(); initializer hwnd)
		  end
	      in 
		(initializer :: initializers,
		setter :: setters,
		id :: ids)
	      end
	  | OPTRADIO toggle_list =>
	      let 
		fun do_one (OPTTOGGLE (name, get, set)) =
		  (getResID name, get, set)
	          | do_one _ = Crash.impossible "Non toggle button in OPTRADIO"
	        val idgetset_list = map do_one toggle_list
		fun initializer hwnd = 
		  Lists.iterate (fn (id, get, set) => 
		    WindowsGui.checkDlgButton (hwnd, id, if get() then 1 else 0))
		    idgetset_list
		fun setter hwnd = 
		  Lists.iterate (fn (id, get, set) =>
		    if WindowsGui.isDlgButtonChecked (hwnd, id) = 1 then
		      set true
		    else true) idgetset_list
		val new_ids = map #1 idgetset_list
	      in
		(initializer :: initializers,
		setter :: setters,
		rev new_ids @@ ids)
	      end
	  | _ => (initializers, setters, ids)
	val (initializers, setters, ids) = Lists.reducel do_spec (([],[],[]), speclist)
      in
	(TEMPLATE {styles=[], height=0, width=0, x=0, y=0, title="", items=[], nitems=0}, 
initializers, setters, ids, (ok_id, apply_id, reset_id, cancel_id))
      end


    (* isResourceDialog is temporary until all the dialogs have been
     * converted to resource dialogs.
     *)
    fun isResourceDialog str =
      case str of 
	"modeOptions" => true
      | "editorOptions" => true
      | "environmentOptions" => true
      | "languageOptions" => true
      | "compilerOptions" => true
      | _ => false 

    fun resourceDialog (window, resName) = 
      WindowsGui.createDialog (WindowsGui.getModuleHandle(""), window, resName)

    fun create_dialog (parent, title, name, action, spec) =
      let
        val (template,initializers,setters,ids,(ok_id,apply_id,reset_id,cancel_id)) = 
	  if (isResourceDialog name) then 
	    resource_convert_spec spec
	  else
	    convert_spec (title, action, spec)
        val window_ref = ref (WindowsGui.nullWindow)
        val changed_ref = ref false
        fun set_sensitivity window =
          (ignore(WindowsGui.enableWindow (WindowsGui.getDlgItem (window,apply_id),!changed_ref));
           ignore(WindowsGui.enableWindow (WindowsGui.getDlgItem (window,reset_id),!changed_ref));
           ())
        val real_parent = CapiTypes.get_real parent
      in
       (fn _ => 
        if WindowsGui.isWindow (!window_ref)
          then (windowHandle := (!window_ref);
		WindowsGui.bringWindowToTop (!window_ref))
        else
          let
            val dbox = if (isResourceDialog name) then
		resourceDialog (real_parent, name)
	      else
		create_dialog_indirect (template,real_parent)

	    val _ = if (dbox = WindowsGui.nullWindow) then 
		Crash.impossible "no resource for dialog\n"
		else ()
	    val _ = windowHandle := dbox

            val _ = WindowsGui.registerPopupWindow (dbox)
            fun destroy _ =
              (WindowsGui.unregisterPopupWindow dbox;
               WindowsGui.destroyWindow dbox)
          in
            WindowsGui.addMessageHandler(real_parent, WindowsGui.WM_SHOWWINDOW, 
                minimizefun dbox);
            (* We should attempt to remove these menu identifiers when we have finished *)
            Lists.iterate
            	(fn id => WindowsGui.addCommandHandler(dbox, id,
              	    fn _ => 
			if not (!changed_ref)
                	then (changed_ref := true;
                   	      set_sensitivity dbox; ())
              		else ()))
                ids;
            WindowsGui.addCommandHandler(dbox, ok_id,
             fn _ => (if !changed_ref
                      	then (Lists.iterate (fn f => f dbox) setters; action ())
                      	else ();
              	      destroy()));
            WindowsGui.addCommandHandler(dbox, apply_id,
             fn _ => (app (fn f => f dbox) setters;
              	      changed_ref := false;
              	      set_sensitivity dbox;
              	      action ()));
            WindowsGui.addCommandHandler(dbox, reset_id,
             fn _ => (app (fn f => f dbox) initializers;
		     changed_ref := false;
              	     set_sensitivity dbox));
            WindowsGui.addCommandHandler(dbox, cancel_id, destroy);
            window_ref := dbox;
            app (fn f => f dbox) initializers;
            changed_ref := false;
            set_sensitivity dbox;
            WindowsGui.showWindow (dbox,WindowsGui.SW_SHOW)
          end,
        fn _ => if WindowsGui.isWindow (!window_ref)
          	  then 
            	    (app (fn f => f (!window_ref)) initializers;
             	     changed_ref := false;
             	     set_sensitivity (!window_ref))
        	  else ())
      end

local
      fun tty_action (hwnd,_) =
        WindowsGui.endDialog (hwnd,2)
      fun exit_action (hwnd,_) =
        WindowsGui.endDialog (hwnd,1)
      fun cancel_action (hwnd,_) =
        WindowsGui.endDialog (hwnd,0)
      val quit_on_exit : unit -> unit = env "nt quit on exit"
    in
      fun exit_dialog (parent,applicationShell,has_controlling_tty) =
        let
          (* Currently ignores has_controlling_tty *)
	  (* a fixed set of control identifiers here *)
	  val tty_id = WindowsGui.newControlId ()
	  val exit_id = WindowsGui.newControlId ()
	  val cancel_id = i2w cancel_env
	  val _ =
	    (WindowsGui.addCommandHandler (WindowsGui.nullWindow,
					tty_id,tty_action);
	     WindowsGui.addCommandHandler (WindowsGui.nullWindow,
					exit_id,exit_action);
	     WindowsGui.addCommandHandler (WindowsGui.nullWindow,
					cancel_id,cancel_action))
          val button_y = 20
          val (dialog_width,items) =
            if has_controlling_tty
              then
                (190,
                 [ITEMTEMPLATE
                 {styles = [WindowsGui.WS_CHILD,
                            WindowsGui.SS_CENTER,
                            WindowsGui.WS_VISIBLE],
                  x = 0,
                  y = 5,
                  width = 190,
                  height = 15,
                  class = "STATIC",
                  text = "Select an action:",
                  id = WindowsGui.nullWord},
                 ITEMTEMPLATE
                 {styles = [WindowsGui.WS_CHILD,WindowsGui.BS_DEFPUSHBUTTON,
                            WindowsGui.WS_VISIBLE],
                  x = 5,
                  y = button_y,
                  width = 60,
                  height = 12,
                  class = "BUTTON",
                  text = "Return to TTY",
                  id = tty_id},
                 ITEMTEMPLATE
                 {styles = [WindowsGui.WS_CHILD,WindowsGui.BS_DEFPUSHBUTTON,
                            WindowsGui.WS_VISIBLE],
                  x = 75,
                  y = button_y,
                  width = 60,
                  height = 12,
                  class = "BUTTON",
                  text = "Exit MLWorks",
                  id = exit_id},
                 ITEMTEMPLATE
                 {styles = [WindowsGui.WS_CHILD,WindowsGui.BS_PUSHBUTTON,
                            WindowsGui.WS_VISIBLE],
                  x = 145,
                  y = button_y,
                  width = 40,
                  height = 12,
                  class = "BUTTON",
                  text = "Cancel",
                  id = cancel_id}])
            else
              (120,
               [ITEMTEMPLATE
                 {styles = [WindowsGui.WS_CHILD,
                            WindowsGui.SS_CENTER,
                            WindowsGui.WS_VISIBLE],
                  x = 0,
                  y = 5,
                  width = 100,
                  height = 15,
                  class = "STATIC",
                  text = "Select an action:",
                  id = WindowsGui.nullWord},
                 ITEMTEMPLATE
                 {styles = [WindowsGui.WS_CHILD,WindowsGui.BS_DEFPUSHBUTTON,
                            WindowsGui.WS_VISIBLE],
                  x = 5,
                  y = button_y,
                  width = 60,
                  height = 12,
                  class = "BUTTON",
                  text = "Exit MLWorks",
                  id = exit_id},
                 ITEMTEMPLATE
                 {styles = [WindowsGui.WS_CHILD,WindowsGui.BS_PUSHBUTTON,
                            WindowsGui.WS_VISIBLE],
                  x = 75,
                  y = button_y,
                  width = 40,
                  height = 12,
                  class = "BUTTON",
                  text = "Cancel",
                  id = cancel_id}])
          val template =
            TEMPLATE
            {styles = [WindowsGui.WS_POPUP,
                       WindowsGui.WS_CAPTION,
                       WindowsGui.DS_MODALFRAME], 
            x = 40,
            y = 40,
            width = dialog_width,
            height = 40,
            title = "Exit Dialog",
            items = items,
            nitems = length items}
          val result = dialog_box_indirect (template,CapiTypes.get_real parent)

	  fun do_destroy () = 
	    (WindowsGui.destroyWindow (CapiTypes.get_real applicationShell);
	     MLWorks.Internal.StandardIO.resetIO())

	  val uninitialise : unit -> unit = 
	    MLWorks.Internal.Runtime.environment "uninitialise mlworks"
        in
          case result of
            0 => ()
          | 1 => (do_destroy o quit_on_exit) ()
          | 2 => (do_destroy o uninitialise) ()
          | _ => print "Bad return from exit dialog"
        end
    end
  end

@


1.65.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.65  1999/03/23  14:44:44  johnh
 * [Bug #190536]
 * Change help menu.
 *
@


1.64
log
@[Bug #30400]
Fix returning to and from tty mode.
@
text
@d4 4
d254 1
d267 1
d488 16
d508 7
d719 46
d782 4
d790 2
a791 1
		   ("installationHelp", install)]) @@ 
d793 1
a793 2
		(map help_item
		   [("releaseNotes", relnotes)])
a1328 16
    (* These should use something from labelstrings *)
    (* Anyway, global ids will do *)
    val ok_env : int = env "win32 ok id"
    val cancel_env : int = env "win32 cancel id"
    val i2w = WindowsGui.intToWord

    (* the ids for apply and reset need to be the same for each dialog, 
     * therefore an id symbol is given to each of the controls in the 
     * resource editor, and this id symbol is used here to reference 
     * each control.
     *)
    val ok_id = i2w ok_env
    val apply_id = i2w (ControlName.getResID "IDAPPLY")
    val reset_id = i2w (ControlName.getResID "IDRESET")
    val cancel_id = i2w cancel_env

a1989 6
            fun minimizefun window (WindowsGui.WPARAM w, l) = 
              (if (w = WindowsGui.nullWord) then 
                WindowsGui.showWindow(window, WindowsGui.SW_HIDE)
              else
                WindowsGui.showWindow(window, WindowsGui.SW_SHOW);
              NONE)
@


1.63
log
@[Bug #30318]
Add createDialog to Windows structure.
@
text
@d4 4
d1983 1
a1983 1
      fun exit_dialog (parent,applicationShell,has_controlling_tty,main_windows) =
a1989 3
          fun destroy_main_windows () = map
                (fn w => WindowsGui.destroyWindow (CapiTypes.get_real w))
                (main_windows)
d2089 7
d2099 2
a2100 6
          | 1 => 
              (WindowsGui.destroyWindow (CapiTypes.get_real applicationShell);
               MLWorks.Internal.StandardIO.resetIO();
               quit_on_exit ())
          | 2 => (ignore(destroy_main_windows ());
                  MLWorks.Internal.StandardIO.resetIO())
@


1.62
log
@[Bug #70086]
WINDOWS becomes WINDOWS_GUI, Windows becomesd WindowsGui
@
text
@d4 4
d1885 2
a1886 2
    val resourceDialog : WindowsGui.hwnd * string -> WindowsGui.hwnd = 
      env "nt create dialog"
@


1.61
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d238 1
a238 1
require "windows";
d249 1
a249 1
               structure Windows : WINDOWS
d255 2
a256 2
               sharing type LabelStrings.word = Windows.word
               sharing type CapiTypes.Hwnd = Windows.hwnd
d260 1
a260 1
    type word = Windows.word
d267 1
a267 1
    val W = Int.toString o Windows.wordToInt
d275 4
a278 4
    val IDM_HELPCONTENTS = Windows.intToWord 400
    val IDM_HELPSEARCH   = Windows.intToWord 401
    val IDM_HELPHELP     = Windows.intToWord 402
    val IDM_ABOUT        = Windows.intToWord 403
d280 1
a280 1
    val null_item = Windows.ITEM Windows.nullWord
d319 1
a319 1
    val windowHandle = ref Windows.nullWindow
d360 1
a360 1
                              ignore(Windows.setFocus (!windowHandle)); 
d367 1
a367 1
     * changeItem calls Windows.setFocus to set the focus back to the window which 
d396 1
a396 1
                              ignore(Windows.setFocus (!windowHandle)); ()));
d447 1
a447 1
          fun activate (Windows.WPARAM w, Windows.LPARAM l) =
d450 1
a450 1
                (Windows.loword w) = (Windows.convertWaValue Windows.WA_INACTIVE)
d462 1
a462 1
          Windows.addMessageHandler(CapiTypes.get_real parent, Windows.WM_ACTIVATE, activate)
d469 3
a471 3
      (Windows.messageBeep Windows.MB_ICONQUESTION;
       ignore(Windows.messageBox (CapiTypes.get_real parent,message,"MLWorks",
                                  [Windows.MB_OK,Windows.MB_APPLMODAL]));
d487 1
a487 1
               (Windows.appendMenu (menu,[Windows.MF_SEPARATOR],null_item,"");
d492 1
a492 1
                 val value = Windows.ITEM Windows.nullWord
d494 1
a494 1
                 Windows.appendMenu (menu, [Windows.MF_STRING,Windows.MF_DISABLED],value,label);
d501 1
a501 1
                 val value = Windows.ITEM id
d517 2
a518 2
                 Windows.appendMenu (menu,[Windows.MF_STRING],value,label);
                 Windows.addCommandHandler (real_parent,
d523 1
a523 1
                               Windows.enableMenuItem
d527 3
a529 3
                                   then Windows.MF_ENABLED
                                 else Windows.MF_GRAYED]);
                               Windows.checkMenuItem
d533 2
a534 2
                                   then Windows.MF_CHECKED
                                 else Windows.MF_UNCHECKED])))
d548 2
a549 2
                 Windows.appendMenu (menu,[Windows.MF_STRING],Windows.ITEM id,label);
                 Windows.addCommandHandler (real_parent,id,fn _ => (!actionRef) ());
d552 1
a552 1
                  Windows.enableMenuItem
d556 2
a557 2
                      then Windows.MF_ENABLED
                    else Windows.MF_GRAYED]))
d565 1
a565 1
                 val submenu = Windows.createPopupMenu()
d574 1
a574 1
		     (Windows.deleteMenu (dmenu,Windows.intToWord (r-1),Windows.MF_BYPOSITION);
d581 1
a581 1
                         val id = Windows.newControlId ()
d594 2
a595 2
                     Windows.appendMenu (menu,[Windows.MF_STRING],Windows.ITEM id,name);
                     Windows.addCommandHandler (real_parent,id,fn _ => action ());
d597 1
a597 1
                      Windows.enableMenuItem
d600 2
a601 2
                          then Windows.MF_ENABLED
                        else Windows.MF_GRAYED]))
d622 1
a622 1
                   (Windows.appendMenu (menu,[Windows.MF_POPUP],Windows.SUBMENU submenu,label);
d635 1
a635 1
		 val id = Windows.intToWord ((!itemCount) - 1)
d639 1
a639 1
                 val submenu = Windows.createPopupMenu ()
d641 1
a641 1
		   Windows.enableMenuItem (menu, id, 
d643 1
a643 1
			[Windows.MF_ENABLED, Windows.MF_BYPOSITION]
d645 1
a645 1
			[Windows.MF_GRAYED, Windows.MF_BYPOSITION])
d652 3
a654 3
		   Windows.appendMenu (menu, [Windows.MF_POPUP,
					      Windows.MF_ENABLED], 
							Windows.SUBMENU submenu, label)
d656 2
a657 2
       	       	   Windows.appendMenu (menu,[Windows.MF_POPUP,
					     Windows.MF_GRAYED],Windows.SUBMENU submenu,label);
d667 2
a668 2
            val help_menu = Windows.createPopupMenu ()
            datatype Item = ITEM of string * Windows.word | SEPARATOR
d670 2
a671 2
                Windows.appendMenu
		  (help_menu,[Windows.MF_STRING],Windows.ITEM id,name)
d673 1
a673 1
                Windows.appendMenu (help_menu,[Windows.MF_SEPARATOR],null_item,"")
d679 1
a679 1
	        Windows.addCommandHandler(real_parent, id, fn _ => action());
d712 2
a713 2
            Windows.appendMenu
	      (menu,[Windows.MF_POPUP],Windows.SUBMENU help_menu,"&Help")
d716 1
a716 1
        val menu = Windows.createMenu ()
d723 1
a723 1
           SOME Windows.nullWord)
d726 1
a726 1
        Windows.addMessageHandler (real_parent,Windows.WM_INITMENU,update_fn);
d731 1
a731 1
        Windows.setMenu (real_parent,menu)
d758 1
a758 1
	val i2w = Windows.intToWord
d760 1
a760 1
	val toolbar_id = Windows.newControlId()
d769 1
a769 1
	        Windows.newControlId() 
d771 1
a771 1
	        Windows.nullWord
d774 5
a778 5
	          TB_SEP => Windows.TBSTYLE_SEP
	        | TB_TOGGLE => Windows.TBSTYLE_CHECK
	        | TB_PUSH => Windows.TBSTYLE_BUTTON
	        | TB_GROUP => Windows.TBSTYLE_GROUP
	        | TB_TOGGLE_GROUP => Windows.TBSTYLE_CHECKGROUP
d781 6
a786 6
	          CHECKED => Windows.TBSTATE_CHECKED
	        | ENABLED => Windows.TBSTATE_ENABLED
	        | HIDDEN => Windows.TBSTATE_HIDDEN
	        | GRAYED => Windows.TBSTATE_INDETERMINATE
	        | PRESSED => Windows.TBSTATE_PRESSED
	        | WRAP => Windows.TBSTATE_WRAP
d800 1
a800 1
	        (Windows.addCommandHandler(pwin, id, command); 
d804 2
a805 2
	        Windows.TBSTYLE_CHECK => SOME (addCommand())
	      | Windows.TBSTYLE_BUTTON => SOME (addCommand())
d809 1
a809 1
	      if (style = Windows.TBSTYLE_SEP) then
d814 1
a814 1
	    if (style <> Windows.TBSTYLE_SEP) then button_count := (!button_count) + 1 else ();
d824 2
a825 2
	val widg = Windows.createToolbarEx
                {parent = pwin, styles = [Windows.TBSTYLE_TOOLTIPS, Windows.WS_CHILD],
d832 1
a832 1
	val processNotify : Windows.hwnd * Windows.wparam * Windows.lparam -> unit = 
d853 2
a854 2
	  Windows.sendMessage(widg, Windows.TB_SETSTATE, Windows.WPARAM id, 
	    Windows.LPARAM (Windows.tbStatesToWord states))
d864 2
a865 2
	  (if sens_fn() then Windows.TBSTATE_ENABLED else Windows.TBSTATE_INDETERMINATE) :: 
	  (if (isToggle name) andalso (toggleChecked name) then [Windows.TBSTATE_CHECKED] 
d878 1
a878 1
	Windows.addCommandHandler(pwin, interrupt_id, fn _ => interrupt());
d880 4
a883 4
	Windows.addMessageHandler(pwin, Windows.WM_NCACTIVATE, update);
	Windows.addMessageHandler(pwin, Windows.WM_PARENTNOTIFY, update);
	Windows.addMessageHandler(pwin, Windows.WM_INITMENU, update);
        Windows.addMessageHandler(pwin, Windows.WM_NOTIFY, process_notify);
d887 1
a887 1
    val sendMessageNoResult = ignore o Windows.sendMessage;
d891 2
a892 2
        val Windows.OBJECT gui_font =
          Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
d894 2
a895 2
            Windows.WindowSystemError _ =>
              Windows.getStockObject (Windows.ANSI_VAR_FONT)
d899 3
a901 3
           Windows.WM_SETFONT,
           Windows.WPARAM gui_font,
           Windows.LPARAM (Windows.intToWord 0))
d903 1
a903 1
      handle Windows.WindowSystemError _ => ()
d917 1
a917 1
        val dc = Windows.getDC real_parent
d930 2
a931 2
            val Windows.OBJECT gui_font =
              Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
d933 2
a934 2
                Windows.WindowSystemError _ =>
                  Windows.getStockObject (Windows.ANSI_VAR_FONT)
d936 1
a936 1
	    ignore(Windows.selectObject (dc, Windows.OBJECT gui_font));
d939 1
a939 1
	  handle Windows.WindowSystemError _ => ()
d945 1
a945 1
            val (twidth,_) = Windows.getTextExtentPoint (dc,label)
d948 1
a948 1
              Windows.createWindow
d951 1
a951 1
               styles = [Windows.WS_CHILD,Windows.BS_PUSHBUTTON],
d957 1
a957 1
              (ignore(Windows.enableWindow (button,sensitive()));
d961 3
a963 3
            Windows.moveWindow (button,!xref,top_margin,width,height,false);
            Windows.showWindow (button,Windows.SW_SHOW);
            Windows.updateWindow button;
d966 1
a966 1
            Windows.addCommandHandler (real_parent,id,fn n => callback ());
d972 2
a973 2
            Windows.addCommandHandler
	      (Windows.getParent real_parent, id, fn n => callback ());
d980 1
a980 1
            val (twidth,_) = Windows.getTextExtentPoint (dc,label)
d983 1
a983 1
              Windows.createWindow
d986 1
a986 1
               styles = [Windows.WS_CHILD,Windows.BS_AUTOCHECKBOX],
d992 2
a993 2
              (Windows.checkDlgButton (real_parent, id, if get() then 1 else 0);
	       ignore(Windows.enableWindow (button,sensitive()));
d997 3
a999 3
            Windows.moveWindow (button,!xref,top_margin,width,height,false);
            Windows.showWindow (button,Windows.SW_SHOW);
            Windows.updateWindow button;
d1001 4
a1004 4
            Windows.addCommandHandler 
	      (Windows.getParent real_parent, id, fn n => set(not(get())));
            Windows.addCommandHandler 
	      (Windows.getParent (Windows.getParent real_parent), id, fn n => set(not(get())));
d1012 1
a1012 1
            val (twidth,_) = Windows.getTextExtentPoint (dc,label)
d1015 1
a1015 1
              Windows.createWindow
d1018 2
a1019 2
               styles = [Windows.WS_CHILD,Windows.BS_AUTORADIOBUTTON] @@ 
			(if (!first_radio) then [Windows.WS_GROUP] else []),
d1025 2
a1026 2
              (Windows.checkDlgButton (real_parent, id, if get() then 1 else 0);
	       ignore(Windows.enableWindow (button,sensitive()));
d1031 3
a1033 3
            Windows.moveWindow (button,!xref,top_margin,width,height,false);
            Windows.showWindow (button,Windows.SW_SHOW);
            Windows.updateWindow button;
d1037 1
a1037 1
            Windows.addCommandHandler 
d1039 4
a1042 4
            Windows.addCommandHandler 
	      (Windows.getParent real_parent, id, fn n => set true);
            Windows.addCommandHandler 
	      (Windows.getParent (Windows.getParent real_parent), id, fn n => set true);
d1056 1
a1056 1
            val (twidth,_) = Windows.getTextExtentPoint (dc,label)
d1059 1
a1059 1
              Windows.createWindow
d1062 1
a1062 1
               styles = [Windows.WS_CHILD,Windows.SS_CENTER],
d1066 1
a1066 1
               menu = Windows.nullWord}
d1069 3
a1071 3
            Windows.moveWindow (button,!xref,top_margin,width,height,false);
            Windows.showWindow (button,Windows.SW_SHOW);
            Windows.updateWindow button;
d1084 1
a1084 1
                Windows.createWindow
d1087 1
a1087 1
                 styles = [Windows.WS_CHILD,Windows.SBS_HORZ],
d1092 1
a1092 1
                fun handler (Windows.WPARAM wparam, Windows.LPARAM lparam) =
d1094 2
a1095 2
                    val code = Windows.loword wparam
		    val convert = Windows.convertSbValue
d1097 3
a1099 3
		      if code = convert Windows.SB_THUMBPOSITION then
			Windows.hiword wparam
		      else if code = convert Windows.SB_LINELEFT then 
d1104 1
a1104 1
		      else if code = convert Windows.SB_LINERIGHT then
d1109 1
a1109 1
		      else if code = convert Windows.SB_PAGELEFT then
d1114 1
a1114 1
		      else if code = convert Windows.SB_PAGERIGHT then
d1123 2
a1124 2
		    Windows.setScrollPos (slider, Windows.SB_CTL, pos, true);
                    SOME Windows.nullWord
d1127 4
a1130 4
              Windows.setScrollRange (slider,Windows.SB_CTL,min,max,false);
              Windows.moveWindow (slider,!xref,top_margin,width,height,false);
              Windows.showWindow (slider,Windows.SW_SHOW);
              Windows.updateWindow slider;
d1132 1
a1132 1
              Windows.addMessageHandler (real_parent,Windows.WM_HSCROLL,handler);
d1138 1
a1138 1
        Windows.releaseDC (real_parent,dc);
d1147 1
a1147 1
      {styles: Windows.window_style list,
d1152 1
a1152 1
       id : Windows.word,
d1159 1
a1159 1
      {styles: Windows.window_style list,
d1185 2
a1186 2
    val create_dialog_indirect : Template * Windows.hwnd -> Windows.hwnd = env "nt create dialog indirect"
    val dialog_box_indirect : Template * Windows.hwnd -> int = env "nt dialog box indirect"
d1202 1
a1202 1
        val string_word = Windows.makeCString (munge_string s)
d1204 4
a1207 4
        sendMessageNoResult (window,Windows.WM_SETTEXT,
                             Windows.WPARAM (Windows.nullWord),
                             Windows.LPARAM string_word);
        Windows.free string_word
d1211 4
a1214 4
      Windows.wordToInt (Windows.sendMessage (text,
                                              Windows.WM_GETTEXTLENGTH,
                                              Windows.WPARAM Windows.nullWord,
                                              Windows.LPARAM Windows.nullWord))
d1219 1
a1219 1
        val buffer = Windows.malloc (size+1) (* extra for null termination *)
d1221 6
a1226 6
        val _ = Windows.sendMessage (window,
                                     Windows.WM_GETTEXT,
                                     Windows.WPARAM (Windows.intToWord (size+1)), (* add 1 for the last null character *)
                                     Windows.LPARAM buffer)
        val _ = Windows.setByte (buffer,size,0) (* null terminate *) (* probably not necessary *)
        val result = Windows.wordToString buffer
d1228 1
a1228 1
        Windows.free buffer;
d1246 1
a1246 1
    val i2w = Windows.intToWord
d1258 1
a1258 1
    fun bell () = Windows.messageBeep Windows.MB_OK
d1275 3
a1277 3
                  {styles = [Windows.SS_GRAYRECT,
                             Windows.WS_CHILD,
                             Windows.WS_VISIBLE],
d1284 1
a1284 1
                   id = Windows.nullWord}
d1293 3
a1295 3
                  {styles = [Windows.SS_LEFT,
                             Windows.WS_CHILD,
                             Windows.WS_VISIBLE],
d1302 1
a1302 1
                   id = Windows.nullWord}
d1312 4
a1315 4
                  {styles = [Windows.BS_AUTOCHECKBOX,
                             Windows.WS_CHILD,
                             Windows.WS_TABSTOP,
                             Windows.WS_VISIBLE],
d1325 1
a1325 1
                  in Windows.checkDlgButton (hwnd,id,if value then 1 else 0)
d1329 1
a1329 1
		    val value = (Windows.isDlgButtonChecked (hwnd,id) = 1)
d1347 5
a1351 5
                  {styles = [Windows.WS_CHILD,
                             Windows.WS_TABSTOP,
                             Windows.WS_BORDER,
                             Windows.WS_VISIBLE,
			     Windows.ES_AUTOHSCROLL],
d1361 3
a1363 3
                  {styles = [Windows.WS_CHILD,
                             Windows.SS_LEFT,
                             Windows.WS_VISIBLE],
d1370 2
a1371 2
                   id = Windows.nullWord}
                fun get_input_pane hwnd = Windows.getDlgItem (hwnd,id)
d1392 4
a1395 4
                  {styles = [Windows.WS_CHILD,
                             Windows.WS_BORDER,
                             Windows.WS_TABSTOP,
                             Windows.WS_VISIBLE],
d1405 3
a1407 3
                  {styles = [Windows.WS_CHILD,
                             Windows.SS_LEFT,
                             Windows.WS_VISIBLE],
d1414 2
a1415 2
                   id = Windows.nullWord}
                fun get_input_pane hwnd = Windows.getDlgItem (hwnd,id)
d1450 2
a1451 2
                      {styles = (if is_first then [Windows.WS_GROUP,
                                                   Windows.WS_TABSTOP]
d1453 3
a1455 3
                                [Windows.WS_CHILD,
                                 Windows.WS_VISIBLE,
                                 Windows.BS_AUTORADIOBUTTON],
d1486 1
a1486 1
                   Windows.checkDlgButton (hwnd,id,if get() then 1 else 0))
d1496 1
a1496 1
                      Windows.checkRadioButton (hwnd,first,last,id))
d1503 1
a1503 1
                   if Windows.isDlgButtonChecked (hwnd,id) = 1
d1517 3
a1519 3
          {styles = [Windows.SS_GRAYRECT,
                     Windows.WS_CHILD,
                     Windows.WS_VISIBLE],
d1526 1
a1526 1
           id = Windows.nullWord} ::
d1530 4
a1533 4
           {styles = [Windows.WS_CHILD,
                      if default then Windows.BS_DEFPUSHBUTTON
                      else Windows.BS_PUSHBUTTON,
                      Windows.WS_VISIBLE],
d1548 5
a1552 5
         {styles = [Windows.WS_POPUP,
                    Windows.WS_CAPTION,
                    (* Windows.WS_DLGFRAME, *) (* This seems to do nothing *)
                    Windows.WS_SYSMENU,
                    Windows.WS_VISIBLE],
d1571 2
a1572 2
       	  val w = Windows.WPARAM (Windows.intToWord itemIndex)
          val l = Windows.LPARAM Windows.nullWord
d1575 1
a1575 1
		Windows.CB_GETLBTEXTLEN 
d1577 3
a1579 3
		Windows.LB_GETTEXTLEN
          val r = Windows.sendMessage (hwnd, message, w, l)
          val maxWidth' = Int.max (Windows.wordToInt r, maxWidth)
d1598 1
a1598 1
          let val CString = Windows.makeCString (strip_string_controls item)
d1601 3
a1603 3
    			         Windows.WPARAM Windows.nullWord,
	   			 Windows.LPARAM CString);
	    Windows.free CString
d1611 1
a1611 1
	fun getResID name = Windows.intToWord (ControlName.getResID name)
d1619 1
a1619 1
		  in Windows.checkDlgButton (hwnd, id, if value then 1 else 0)
d1622 1
a1622 1
		  let val settable = set (Windows.isDlgButtonChecked (hwnd, id) = 1)
d1633 1
a1633 1
		fun get_input_pane hwnd = Windows.getDlgItem (hwnd,id)
d1652 2
a1653 2
		    val i2w = Windows.intToWord
		    val charWidthInPixels = Windows.loword(Windows.getDialogBaseUnits())
d1659 3
a1661 3
  			(hwnd, Windows.CB_SETHORIZONTALEXTENT, 
			 Windows.WPARAM (i2w (maxTextWidth * charWidthInPixels)),
			 Windows.LPARAM Windows.nullWord)
d1667 1
a1667 1
		    val hwnd = Windows.getDlgItem (dialog, id)
d1669 4
a1672 4
		    sendMessageNoResult(hwnd, Windows.CB_RESETCONTENT, 
					Windows.WPARAM Windows.nullWord,
					Windows.LPARAM Windows.nullWord);
		    add_items (hwnd, #2(get()), Windows.CB_ADDSTRING);
d1679 1
a1679 1
		    val new_text = get_text (Windows.getDlgItem (dialog, id))
d1695 2
a1696 2
		val null_w = Windows.WPARAM Windows.nullWord
		val null_l = Windows.LPARAM Windows.nullWord
d1700 2
a1701 2
		    val i2w = Windows.intToWord
		    val charWidthInPixels = Windows.loword(Windows.getDialogBaseUnits())
d1707 2
a1708 2
  			(hwnd, Windows.LB_SETHORIZONTALEXTENT, 
			 Windows.WPARAM (i2w (maxTextWidth * charWidthInPixels)),
d1716 3
a1718 3
		      val w = Windows.WPARAM (Windows.intToWord (~1))
		      val CString = Windows.makeCString (strip_string_controls str)
		      val l = Windows.LPARAM CString
d1726 1
a1726 1
			      Windows.sendMessage(hwnd, Windows.LB_FINDSTRING, w, l)
d1730 3
a1732 3
			     Windows.LB_SETSEL, 
			     Windows.WPARAM (Windows.intToWord 1),
			     Windows.LPARAM index)
d1735 2
a1736 2
			sendMessageNoResult(hwnd, Windows.LB_SELECTSTRING, w, l);
		      Windows.free CString;
d1742 1
a1742 1
		    val hwnd = Windows.getDlgItem (dialog, id)
d1745 2
a1746 2
		    sendMessageNoResult(hwnd, Windows.LB_RESETCONTENT, null_w, null_l);
		    add_items (hwnd, all_items, Windows.LB_ADDSTRING);
d1753 2
a1754 2
		    val i2w = Windows.intToWord
		    val hwnd = Windows.getDlgItem (dialog, id)
d1760 3
a1762 3
			val w = Windows.WPARAM (Windows.intToWord index)
		        val size = Windows.wordToInt (Windows.sendMessage 
				      (hwnd, Windows.LB_GETTEXTLEN, w, null_l))
d1764 1
a1764 1
		        val buffer = Windows.malloc (size+1)
d1766 1
a1766 1
		        val _ = Windows.sendMessage 
d1768 4
a1771 4
		                    Windows.LB_GETTEXT, w,
		                    Windows.LPARAM buffer)
		        val _ = Windows.setByte (buffer,size,0) (* null terminate *)
		        val result = Windows.wordToString buffer
d1773 1
a1773 1
		        Windows.free buffer;
d1778 3
a1780 3
		      Windows.wordToInt 
			(Windows.sendMessage
			   (hwnd, Windows.LB_GETCOUNT, null_w, null_l))
d1789 1
a1789 1
			  val w = Windows.WPARAM (Windows.intToWord (i-1))
d1791 2
a1792 2
			    (Windows.sendMessage (hwnd, Windows.LB_GETSEL, w, null_l)) <>
			    Windows.nullWord
d1822 1
a1822 1
		fun get_input_pane hwnd = Windows.getDlgItem (hwnd, id)
d1848 1
a1848 1
		    Windows.checkDlgButton (hwnd, id, if get() then 1 else 0))
d1852 1
a1852 1
		    if Windows.isDlgButtonChecked (hwnd, id) = 1 then
d1881 1
a1881 1
    val resourceDialog : Windows.hwnd * string -> Windows.hwnd = 
d1891 1
a1891 1
        val window_ref = ref (Windows.nullWindow)
d1894 2
a1895 2
          (ignore(Windows.enableWindow (Windows.getDlgItem (window,apply_id),!changed_ref));
           ignore(Windows.enableWindow (Windows.getDlgItem (window,reset_id),!changed_ref));
d1900 1
a1900 1
        if Windows.isWindow (!window_ref)
d1902 1
a1902 1
		Windows.bringWindowToTop (!window_ref))
d1910 1
a1910 1
	    val _ = if (dbox = Windows.nullWindow) then 
d1915 1
a1915 1
            val _ = Windows.registerPopupWindow (dbox)
d1917 5
a1921 5
              (Windows.unregisterPopupWindow dbox;
               Windows.destroyWindow dbox)
            fun minimizefun window (Windows.WPARAM w, l) = 
              (if (w = Windows.nullWord) then 
                Windows.showWindow(window, Windows.SW_HIDE)
d1923 1
a1923 1
                Windows.showWindow(window, Windows.SW_SHOW);
d1926 1
a1926 1
            Windows.addMessageHandler(real_parent, Windows.WM_SHOWWINDOW, 
d1930 1
a1930 1
            	(fn id => Windows.addCommandHandler(dbox, id,
d1937 1
a1937 1
            Windows.addCommandHandler(dbox, ok_id,
d1942 1
a1942 1
            Windows.addCommandHandler(dbox, apply_id,
d1947 1
a1947 1
            Windows.addCommandHandler(dbox, reset_id,
d1951 1
a1951 1
            Windows.addCommandHandler(dbox, cancel_id, destroy);
d1956 1
a1956 1
            Windows.showWindow (dbox,Windows.SW_SHOW)
d1958 1
a1958 1
        fn _ => if Windows.isWindow (!window_ref)
d1968 1
a1968 1
        Windows.endDialog (hwnd,2)
d1970 1
a1970 1
        Windows.endDialog (hwnd,1)
d1972 1
a1972 1
        Windows.endDialog (hwnd,0)
d1979 2
a1980 2
	  val tty_id = Windows.newControlId ()
	  val exit_id = Windows.newControlId ()
d1983 1
a1983 1
                (fn w => Windows.destroyWindow (CapiTypes.get_real w))
d1986 1
a1986 1
	    (Windows.addCommandHandler (Windows.nullWindow,
d1988 1
a1988 1
	     Windows.addCommandHandler (Windows.nullWindow,
d1990 1
a1990 1
	     Windows.addCommandHandler (Windows.nullWindow,
d1998 3
a2000 3
                 {styles = [Windows.WS_CHILD,
                            Windows.SS_CENTER,
                            Windows.WS_VISIBLE],
d2007 1
a2007 1
                  id = Windows.nullWord},
d2009 2
a2010 2
                 {styles = [Windows.WS_CHILD,Windows.BS_DEFPUSHBUTTON,
                            Windows.WS_VISIBLE],
d2019 2
a2020 2
                 {styles = [Windows.WS_CHILD,Windows.BS_DEFPUSHBUTTON,
                            Windows.WS_VISIBLE],
d2029 2
a2030 2
                 {styles = [Windows.WS_CHILD,Windows.BS_PUSHBUTTON,
                            Windows.WS_VISIBLE],
d2041 3
a2043 3
                 {styles = [Windows.WS_CHILD,
                            Windows.SS_CENTER,
                            Windows.WS_VISIBLE],
d2050 1
a2050 1
                  id = Windows.nullWord},
d2052 2
a2053 2
                 {styles = [Windows.WS_CHILD,Windows.BS_DEFPUSHBUTTON,
                            Windows.WS_VISIBLE],
d2062 2
a2063 2
                 {styles = [Windows.WS_CHILD,Windows.BS_PUSHBUTTON,
                            Windows.WS_VISIBLE],
d2073 3
a2075 3
            {styles = [Windows.WS_POPUP,
                       Windows.WS_CAPTION,
                       Windows.DS_MODALFRAME], 
d2088 1
a2088 1
              (Windows.destroyWindow (CapiTypes.get_real applicationShell);
@


1.60
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d4 4
d355 3
a357 1
        act_ref := (fn () => (new_act(); Windows.setFocus (!windowHandle); ()));
d391 2
a392 2
                              new_act (!toggle_ref);
                              Windows.setFocus (!windowHandle); ()));
d466 2
a467 3
       Windows.messageBox (CapiTypes.get_real parent,message,"MLWorks",
                         [Windows.MB_OK,
                          Windows.MB_APPLMODAL]);
d602 1
a602 1
                   (loop_fn (!count_ref);
d706 1
a706 1
            map add_item 
d866 1
a866 1
	fun update _ = (map update_one idsensList; NONE)
d873 1
a873 1
	set_interrupt_window widg;
d875 1
a875 1
	update_ref := (fn () => (map update_one idsensList; ()));
d883 2
d893 1
a893 1
        Windows.sendMessage
d897 1
a897 2
           Windows.LPARAM (Windows.intToWord 0));
	()
d932 1
a932 1
	    Windows.selectObject (dc, Windows.OBJECT gui_font);
d953 1
a953 1
              (Windows.enableWindow (button,sensitive());
d989 1
a989 1
	       Windows.enableWindow (button,sensitive());
d1022 1
a1022 1
	       Windows.enableWindow (button,sensitive());
d1200 3
a1202 3
        Windows.sendMessage (window,Windows.WM_SETTEXT,
                              Windows.WPARAM (Windows.nullWord),
                              Windows.LPARAM string_word);
d1596 2
a1597 2
	    Windows.sendMessage (hwnd, message,
				 Windows.WPARAM Windows.nullWord,
d1654 2
a1655 2
		      (Windows.sendMessage
			(hwnd, Windows.CB_SETHORIZONTALEXTENT, 
d1657 1
a1657 2
			 Windows.LPARAM Windows.nullWord); 
		      ())
d1665 1
a1665 1
		    Windows.sendMessage(hwnd, Windows.CB_RESETCONTENT, 
d1702 2
a1703 2
		      (Windows.sendMessage
			(hwnd, Windows.LB_SETHORIZONTALEXTENT, 
d1705 1
a1705 2
			 null_l); 
		      ())
d1720 1
a1720 1
		      if sel_type = EXTENDED then 
d1724 5
a1728 5
			  Windows.sendMessage
				(hwnd, 
				Windows.LB_SETSEL, 
				Windows.WPARAM (Windows.intToWord 1),
				Windows.LPARAM index)
d1731 1
a1731 1
			Windows.sendMessage(hwnd, Windows.LB_SELECTSTRING, w, l);
d1741 1
a1741 1
		    Windows.sendMessage(hwnd, Windows.LB_RESETCONTENT, null_w, null_l);
d1890 2
a1891 2
          (Windows.enableWindow (Windows.getDlgItem (window,apply_id),!changed_ref);
           Windows.enableWindow (Windows.getDlgItem (window,reset_id),!changed_ref);
d1907 1
a1907 1
		(Crash.impossible "no resource for dialog\n"; ())
d2087 1
a2087 1
          | 2 => (destroy_main_windows ();
@


1.59
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d1 1
a1 1
(* Motif menu bar utilites *)
d4 4
d223 1
d256 1
a256 1
    fun dummy s = MLWorks.IO.output (MLWorks.IO.terminal_out, s ^ " unimplemented \n")
d263 1
a263 1
    fun print s = MLWorks.IO.output (MLWorks.IO.terminal_out, s)
@


1.58
log
@[Bug #30125]
Move implementation of send_message to Menus.
@
text
@d4 4
d20 5
d793 6
d804 1
a804 1
	    (name, sens_ref_opt, ((!button_count - 1), id, tb_states, [style], i2w tip_id, 0))
d904 2
d961 77
@


1.57
log
@[Bug #30233]
editor dialog now stored as resource.
@
text
@d4 4
d443 7
@


1.56
log
@[Bug #30059]
Implement interface to Win32 resource dialogs.
@
text
@d4 4
d1757 1
@


1.55
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 4
d203 2
d211 1
d222 1
d1044 2
d1054 6
a1059 1
      OPTRADIO of OptionSpec list
d1124 5
d1130 2
a1131 2
    val apply_id = Windows.newControlId ()
    val reset_id = Windows.newControlId ()
d1136 6
d1261 2
d1441 321
a1761 1
    fun create_dialog (parent,title,name,action,optionsspec) =
d1764 4
a1767 1
          convert_spec (title,action,optionsspec)
d1782 8
a1789 1
            val dbox = create_dialog_indirect (template,real_parent)
d1791 1
d1807 22
a1828 40
            (fn id => 
             Windows.addCommandHandler
             (dbox,
              id,
              fn _ =>
              if not (!changed_ref)
                then
                  (changed_ref := true;
                   set_sensitivity dbox;
                   ())
              else ()))
            ids;
            Windows.addCommandHandler
            (dbox,
             ok_id,
             fn _ =>
             (if !changed_ref
                then (Lists.iterate (fn f => f dbox) setters;
                      action ())
              else ();
              destroy()));
            Windows.addCommandHandler
            (dbox,
             apply_id,
             fn _ =>
             (app (fn f => f dbox) setters;
              changed_ref := false;
              set_sensitivity dbox;
              action ()));
            Windows.addCommandHandler
            (dbox,
             reset_id,
             fn _ =>
             (changed_ref := false;
              set_sensitivity dbox;
              app (fn f => f dbox) initializers));
            Windows.addCommandHandler
            (dbox,
             cancel_id,
             destroy);
d1835 6
a1840 7
        fn _ =>
        if Windows.isWindow (!window_ref)
          then 
            (app (fn f => f (!window_ref)) initializers;
             changed_ref := false;
             set_sensitivity (!window_ref))
        else ())
@


1.54
log
@[Bug #30241]
Implement proper find dialog.
@
text
@d4 4
a206 1
require "^.basis.__old";
@


1.54.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.54  1997/09/08  08:52:32  johnh
 * [Bug #30241]
 * Implement proper find dialog.
 *
@


1.54.2.2
log
@[Bug #30071]
Redesign Compilation Manager -> Project Workspace.
Implement Radio and Toggle buttons in make_buttons function.
@
text
@a866 2
	val first_radio = ref true

a921 77
	| do_one (TOGGLE (name, get, set, sensitive)) =
	  let
            val id = LabelStrings.get_action name
            val label = LabelStrings.get_label name
            val (twidth,_) = Windows.getTextExtentPoint (dc,label)
            val width = twidth + internal_space
            val button = 
              Windows.createWindow
              {class = "BUTTON",
               name = label,
               styles = [Windows.WS_CHILD,Windows.BS_AUTOCHECKBOX],
               width = 10,
               height = 10,
               parent = real_parent,
               menu = id}
            fun set_sensitivity () =
              (Windows.checkDlgButton (real_parent, id, if get() then 1 else 0);
	       Windows.enableWindow (button,sensitive());
               ())
	  in
	    set_gui_font button;
            Windows.moveWindow (button,!xref,top_margin,width,height,false);
            Windows.showWindow (button,Windows.SW_SHOW);
            Windows.updateWindow button;
            xref := !xref + width + spacing;
            Windows.addCommandHandler 
	      (Windows.getParent real_parent, id, fn n => set(not(get())));
            Windows.addCommandHandler 
	      (Windows.getParent (Windows.getParent real_parent), id, fn n => set(not(get())));
            set_sensitivity
          end

	| do_one (RADIO (name, get, set, sensitive)) =
          let
            val id = LabelStrings.get_action name
            val label = LabelStrings.get_label name
            val (twidth,_) = Windows.getTextExtentPoint (dc,label)
            val width = twidth + internal_space
            val button = 
              Windows.createWindow
              {class = "BUTTON",
               name = label,
               styles = [Windows.WS_CHILD,Windows.BS_AUTORADIOBUTTON] @@ 
			(if (!first_radio) then [Windows.WS_GROUP] else []),
               width = 10,
               height = 10,
               parent = real_parent,
               menu = id}
            fun set_sensitivity () =
              (Windows.checkDlgButton (real_parent, id, if get() then 1 else 0);
	       Windows.enableWindow (button,sensitive());
               ())
          in
	    set_gui_font button;
	    first_radio := false;
            Windows.moveWindow (button,!xref,top_margin,width,height,false);
            Windows.showWindow (button,Windows.SW_SHOW);
            Windows.updateWindow button;
            xref := !xref + width + spacing;

(* WWW *)  (* This should check what the notification event is *)
            Windows.addCommandHandler 
	      (real_parent, id, fn n => set true);
            Windows.addCommandHandler 
	      (Windows.getParent real_parent, id, fn n => set true);
            Windows.addCommandHandler 
	      (Windows.getParent (Windows.getParent real_parent), id, fn n => set true);
	
	    (* Push buttons add a command handler to their grandparent as
	       well.  In the MLWorks GUI, this is the top level widget.
	       This allows accelerators to refer to buttons as well as
	       menu entries.  It is fragile; changes in the window hierarchy
	       will break this. *)

            set_sensitivity
          end

@


1.54.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.54  1997/09/08  08:52:32  johnh
 * [Bug #30241]
 * Implement proper find dialog.
 *
@


1.53
log
@[Bug #30124]
Creating help menu.
@
text
@d4 4
d252 2
d377 1
d394 1
d489 2
@


1.52
log
@[Bug #30174]
Moving stuff into platform specific podium.
@
text
@d4 4
d193 1
d208 1
d611 39
a649 4
              Windows.appendMenu
		(help_menu,[Windows.MF_STRING],Windows.ITEM id,name)
            |   add_item SEPARATOR =
              Windows.appendMenu (help_menu,[Windows.MF_SEPARATOR],null_item,"")
d652 1
a652 1
              [ITEM ("&About MLWorks...",       IDM_ABOUT)];
@


1.51
log
@[Bug #30175]
Combine tools and windows menus - need to change implementation of dynamic menus.
@
text
@d4 4
a279 1
    val isMotif = false
a649 25

    fun mk_toolbutton (style, states, tip_id, name) = 
      TOOLBUTTON {style = style, states = states, tooltip_id = tip_id, name = name}
    fun push (name, id) = mk_toolbutton (TB_PUSH, [ENABLED], id, name)
    fun toggle (name, id) = mk_toolbutton (TB_TOGGLE, [ENABLED], id, name)
    val separator = mk_toolbutton (TB_SEP, [GRAYED], 0, "")
    val podium_buttons = 
	[push ("load_source_file", 2008), push ("save", 2007),
	 separator, 
	 separator,
	 push ("cut", 1996), push ("copy", 1997), 
	 push ("paste", 1998), push ("delete", 1999),
	 separator,
	 push ("listener", 2000), push ("compManager", 2001), 
	 push ("contextBrowser", 2002), push ("initialBrowser", 2003), 
	 push ("contextWindow", 2004), push ("breakTrace", 2005),
	 separator,
	 push ("inspect", 2009), push ("repeat", 2010), push ("search", 2011),
	 push ("duplicate", 2012), toggle ("autoSelection", 2013),
	 separator,
	 push ("abort", 2014), push ("continue", 2015), 
	 push ("step", 2016), push ("next", 2017),
	 push ("trace", 2018), push ("untrace", 2019),
	 separator,
	 push ("interruptButton", 2020)]
@


1.50
log
@[Bug #30068]
Add a toolbar button for the BreakTrace manager top level tool.
@
text
@d4 4
d214 2
d300 1
a300 1
          handle Lists.Find => (print (name ^ "  menu item not found in reference list\n");
d316 2
d327 2
d332 2
d500 2
d503 6
a508 4
                 fun loop 0 = ()
                   | loop n =
                     (Windows.deleteMenu (submenu,Windows.intToWord (n-1),Windows.MF_BYPOSITION);
                      loop (n-1))
d537 2
a538 2
                 fun init _ = 
                   (loop (!count_ref);
d542 1
a542 1
                      val subfns = map (add_dynamic_item submenu) ( (!actionRef) () )
d550 6
a555 2
                 Windows.appendMenu (menu,[Windows.MF_POPUP],Windows.SUBMENU submenu,label);
                 SOME init
d631 3
d635 4
@


1.49
log
@[Bug #30155]
Added get_graph_menuspec.
@
text
@d4 4
d635 1
a635 1
	 push ("contextWindow", 2004),
@


1.48
log
@[Bug #20059]
Menus.windowHandle made global and set from actions of some menu items.
@
text
@d4 4
d606 2
@


1.47
log
@Implementing toolbar.
@
text
@d4 3
d1358 2
a1359 1
          then Windows.bringWindowToTop (!window_ref)
d1363 1
@


1.46
log
@Implementing single menu bar on Windows.
@
text
@d4 3
d190 2
d319 7
d375 1
d599 163
@


1.45
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d224 68
a291 2
    (* Parent should be the top level window here *)
    fun make_submenus (parent, menuspec) =
d293 91
a383 3
        val parent = CapiTypes.get_real parent
        fun add_item menu item =
          (case item of
d398 1
a398 1
                 val id = LabelStrings.get_action name
d401 10
d412 3
d416 1
a416 1
                 Windows.addCommandHandler (parent,
d418 1
a418 3
                                            fn _ =>
                                            (checked := not (!checked);
                                             action (!checked)));
d420 1
a420 1
                              (checked := get();
d424 1
a424 1
                                [if sensitive ()
d439 2
a440 1
                 val id = LabelStrings.get_action name
d442 2
d445 1
a445 1
                 Windows.addCommandHandler (parent,id,fn _ => action ());
d451 1
a451 1
                   [if sensitive ()
d459 1
d487 1
a487 1
                     Windows.addCommandHandler (parent,id,fn _ => action ());
d502 1
a502 1
                      val subfns = map (add_dynamic_item submenu) (f())
d508 2
d516 11
d528 9
a536 1
                 val subfns = map (add_item submenu) subitems
d538 8
a545 1
                 Windows.appendMenu (menu,[Windows.MF_POPUP],Windows.SUBMENU submenu,label);
d570 1
a570 1
        val itemfns = map (add_item menu) menuspec
d579 6
a584 2
        Windows.addMessageHandler (parent,Windows.WM_INITMENU,update_fn);
        Windows.setMenu (parent,menu)
d1187 6
d1194 2
@


1.44
log
@[Bug #1954]
Improved slider functionality - added range checking.
@
text
@d4 4
d104 52
a155 52
# Revision 1.17  1996/01/24  15:26:36  matthew
# Adding slider controls
#
# Revision 1.16  1996/01/08  16:13:06  matthew
# More stuff.
#
# Revision 1.15  1996/01/04  16:33:41  matthew
# Make buttons variable width, depending on string size
#
# Revision 1.14  1995/12/15  12:09:39  matthew
# Changing some windows styles
#
# Revision 1.13  1995/12/13  12:19:06  matthew
# Changing message handling
#
# Revision 1.12  1995/11/23  12:36:12  matthew
# More stuff
#
# Revision 1.11  1995/11/22  16:12:01  matthew
# More stuff
#
# Revision 1.10  1995/11/08  10:30:44  matthew
# Trying to fix radio buttons
#
# Revision 1.9  1995/10/17  16:08:15  nickb
# Add sliders.
#
# Revision 1.8  1995/10/04  09:35:15  daveb
# make_buttons now returns a record of functions.
#
# Revision 1.7  1995/09/19  14:16:18  matthew
# Attempting to do dynamic menus
#
# Revision 1.6  1995/09/05  11:52:30  matthew
# ** No reason given. **
#
# Revision 1.5  1995/08/31  11:25:06  matthew
# Adding text and int input.
#
# Revision 1.4  1995/08/25  10:33:17  matthew
# Adding dialogs
#
# Revision 1.3  1995/08/15  14:37:22  matthew
# Extending
#
# Revision 1.2  1995/08/10  09:33:01  matthew
# Making it all work
#
# Revision 1.1  1995/08/03  12:52:41  matthew
# new unit
# MS Windows GUI
#
d182 1
a182 3

    structure Option = MLWorks.Option

a191 2
    open CapiTypes

d223 1
a223 1
        val parent = get_real parent
d228 1
a228 1
                MLWorks.Option.NONE)
d235 1
a235 1
                 MLWorks.Option.NONE
d347 1
a347 1
                  app (fn (SOME f) => f () | MLWorks.Option.NONE => ()) subfns)
d372 1
a372 1
           (fn MLWorks.Option.NONE => ()
d402 1
a402 1
        val real_parent = get_real parent
d970 1
a970 1
        val real_parent = get_real parent
d1057 1
a1057 1
                (fn w => Windows.destroyWindow (get_real w))
d1157 1
a1157 1
          val result = dialog_box_indirect (template,get_real parent)
d1162 1
a1162 1
              (Windows.destroyWindow (get_real applicationShell);
@


1.44.1.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1997/03/17  14:23:09  johnh
 * [Bug #1954]
 * Improved slider functionality - added range checking.
 *
@


1.44.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.44.1.1  1997/05/12  10:38:16  hope
 * branched from 1.44
 *
@


1.44.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.44.1.1  1997/05/12  10:38:16  hope
 * branched from 1.44
 *
@


1.44.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.44.1.1  1997/05/12  10:38:16  hope
 * branched from 1.44
 *
@


1.44.1.1.1.2
log
@[Bug #30124]
Merging - Help interface to documentation (Win32).
@
text
@a3 4
 *
 * Revision 1.44.1.1.1.1  1997/07/28  18:23:14  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a165 1
require "../utils/getenv";
a179 1
	       structure Getenv : GETENV
d364 4
a367 39
                Windows.appendMenu
		  (help_menu,[Windows.MF_STRING],Windows.ITEM id,name)
              | add_item SEPARATOR =
                Windows.appendMenu (help_menu,[Windows.MF_SEPARATOR],null_item,"")
	    fun help_item (name, action) = 
	      let 
                val label = LabelStrings.get_label name
                val id = LabelStrings.get_action name 
	      in
	        Windows.addCommandHandler(parent, id, fn _ => action());
		ITEM (label, id)
	      end
	    val help_items = 
	      let
		val open_web_location : string -> unit = env "win32 open web location"
		val source_path_opt = Getenv.get_source_path()
		val source_path = 
		  if isSome(source_path_opt) then 
		    valOf(source_path_opt)
		  else ""
		val doc_path = source_path ^ "\\documentation\\"
		fun guide () = 
		  open_web_location (doc_path ^ "guide\\html\\index.htm")
		fun reference () = 
		  open_web_location (doc_path ^ "reference\\html\\index.htm")
		fun install () = 
		  open_web_location (doc_path ^ "installation-notes\\html\\index.htm")
		fun relnotes () = 
		  open_web_location (doc_path ^ "release-notes\\html\\index.htm")
	      in
		(map help_item 
		  [("userGuide", guide),
		   ("referenceMan", reference),
		   ("installationHelp", install)]) @@ 
		[SEPARATOR] @@
		(map help_item
		   [("releaseNotes", relnotes)])
	      end

d370 1
a370 1
              (help_items @@ [ITEM ("&About MLWorks...",       IDM_ABOUT)]);
@


1.44.1.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 4
 * Revision 1.44.1.1.1.2  1997/08/05  14:39:16  johnh
 * [Bug #30124]
 * Merging - Help interface to documentation (Win32).
 *
@


1.43
log
@[Bug #1923]
Removed system menu from exit dialog.
@
text
@d4 4
d496 2
a497 1
              val line_increment = (max - min) div 10
d510 25
a534 28
                    val _ =
                      if code = Windows.convertSbValue Windows.SB_THUMBPOSITION
                        then
                          let
                            val pos = Windows.hiword wparam
                          in
                            set_value pos;
                            Windows.setScrollPos (slider,Windows.SB_CTL,pos,true)
                          end
                      else if code = Windows.convertSbValue Windows.SB_LINELEFT 
                        then
                          let
                            val pos = !curpos - line_increment
                          in
                            set_value pos;
                            curpos := pos;
                            Windows.setScrollPos (slider,Windows.SB_CTL,pos,true)
                          end
                      else if code = Windows.convertSbValue Windows.SB_LINERIGHT 
                        then
                          let
                            val pos = !curpos + line_increment
                          in
                            set_value pos;
                            curpos := pos;
                            Windows.setScrollPos (slider,Windows.SB_CTL,pos,true)
                          end
                      else () 
d536 3
@


1.42
log
@[Bug #1772]
Attaching Esc to 'Cancel' button on dialogs.
@
text
@d4 4
d1144 1
a1144 2
                       Windows.DS_MODALFRAME,
                       Windows.WS_SYSMENU],
@


1.41
log
@Reinstated the help menus.
@
text
@d4 3
d643 5
a647 1
    val ok_id = Windows.newControlId ()
d650 1
a650 1
    val cancel_id = Windows.newControlId ()
d1046 1
a1046 1
	  val cancel_id = Windows.newControlId ()
@


1.41.4.1
log
@branched from 1.41
@
text
@a3 3
 * Revision 1.41  1996/11/20  12:15:09  daveb
 * Reinstated the help menus.
 *
@


1.41.3.1
log
@branched from 1.41
@
text
@a3 3
 * Revision 1.41  1996/11/20  12:15:09  daveb
 * Reinstated the help menus.
 *
@


1.41.3.1.1.1
log
@branched from 1.41.3.1
@
text
@a3 3
 * Revision 1.41.3.1  1996/12/17  17:51:30  hope
 * branched from 1.41
 *
@


1.41.2.1
log
@branched from 1.41
@
text
@a3 3
 * Revision 1.41  1996/11/20  12:15:09  daveb
 * Reinstated the help menus.
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a3 3
 * Revision 1.41  1996/11/20  12:15:09  daveb
 * Reinstated the help menus.
 *
@


1.40
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d20 3
a22 2
 * Bug #148.
 * Passed list a of main Winwindows to exit_dialog function so that they can be killed.
a28 1
 * [Bug #1517]
d339 18
d366 1
@


1.40.1.1
log
@branched from 1.40
@
text
@a3 4
 * Revision 1.40  1996/11/06  11:17:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.40.1.1.1.1
log
@branched from 1.40.1.1
@
text
@a3 3
 * Revision 1.40.1.1  1996/11/14  12:54:17  hope
 * branched from 1.40
 *
@


1.39
log
@[Bug #1727]
Add ES_AUTOHSCROLL to text boxes to input past the end of textbox.
@
text
@d4 4
d141 1
a141 1
require "../basis/__integer";
@


1.38
log
@[Bug #1614]
sorting out a typo
@
text
@d4 4
d704 2
a705 1
                             Windows.WS_VISIBLE],
@


1.37
log
@moving String from toplevel
@
text
@d4 3
d558 1
a558 1
          | munge ("\n"::rest,acc) = munge (rest, #"\010", #"\013" :: acc)
@


1.36
log
@Bug #148.
Passed list a of main Winwindows to exit_dialog function so that they can be killed.
@
text
@d4 4
a130 1

d138 1
d202 1
a202 1
                Option.NONE)
d209 1
a209 1
                 Option.NONE
d224 1
a224 1
                 Option.SOME (fn _ =>
d248 1
a248 1
                 Option.SOME
d305 2
a306 2
                      count_ref := Lists.length subfns;
                      Lists.iterate (fn f => f ()) subfns
d310 1
a310 1
                 Option.SOME init
d319 1
a319 1
                 Option.SOME
d321 1
a321 1
                  Lists.iterate (fn (Option.SOME f) => f () | Option.NONE => ()) subfns)
d327 3
a329 3
          (Lists.iterate
           (fn Option.NONE => ()
             | Option.SOME f => f ())
d331 1
a331 1
           Option.SOME Windows.nullWord)
d493 1
a493 1
                    Option.SOME Windows.nullWord
d508 1
a508 1
        {update = fn _ => Lists.iterate (fn f => f ()) set_sensitivity_fns,
d553 3
a555 4
        fun munge ([],acc) = String.implode (rev acc)
          | munge ("\013" :: "\010" :: rest,acc) =
            munge (rest, "\010" :: "\013" :: acc)
          | munge ("\n"::rest,acc) = munge (rest,"\013\010" :: acc)
d558 1
a558 1
        munge (String.explode s,[])
d561 1
d903 1
a903 1
          nitems = Lists.length items},
d959 1
a959 1
             (Lists.iterate (fn f => f dbox) setters;
d969 1
a969 1
              Lists.iterate (fn f => f dbox) initializers));
d975 1
a975 1
            Lists.iterate (fn f => f dbox) initializers;
d983 1
a983 1
            (Lists.iterate (fn f => f (!window_ref)) initializers;
d1106 1
a1106 1
            nitems = Lists.length items}
@


1.36.2.1
log
@branched from 1.36
@
text
@a3 4
 * Revision 1.36  1996/09/19  11:28:52  johnh
 * Bug #148.
 * Passed list a of main Winwindows to exit_dialog function so that they can be killed.
 *
@


1.36.1.1
log
@branched from 1.36
@
text
@a3 4
 * Revision 1.36  1996/09/19  11:28:52  johnh
 * Bug #148.
 * Passed list a of main Winwindows to exit_dialog function so that they can be killed.
 *
@


1.35
log
@Option dialog setter functions now return accept/reject.
@
text
@d4 3
d994 1
a994 1
      fun exit_dialog (parent,applicationShell,has_controlling_tty) =
d1001 3
d1111 1
a1111 1
          | 2 => (Windows.destroyWindow (get_real applicationShell);
@


1.35.1.1
log
@branched from 1.35
@
text
@a3 3
 * Revision 1.35  1996/08/12  10:48:51  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.34
log
@[Bug #1517]
[Bug #1517]
make_buttons now adds a command handler to the grandparent of the button,
which in our code is the top level widget.  This allows accelerators to
refer to buttons.  This is a fragile feature; changes in the nesting of
windows will break it.
@
text
@d4 8
d531 1
a531 1
       second is set the value for the widget *)
d535 3
a537 3
      OPTTOGGLE of string * (unit -> bool) * (bool -> unit) |
      OPTTEXT of string * (unit -> string) * (string -> unit) |
      OPTINT of string * (unit -> int) * (int -> unit) |
d604 2
d611 1
a611 1
            OPTSEPARATOR => 
d664 2
a665 4
                  let
                    val value = get ()
                  in
                    Windows.checkDlgButton (hwnd,id,if value then 1 else 0)
d669 5
a673 3
                    val value = (Windows.isDlgButtonChecked (hwnd,id) = 1)
                  in
                    set value
d712 5
a716 1
                fun setter hwnd = set (get_text (get_input_pane hwnd))
d755 11
a765 3
                  case Int.fromString (get_text (get_input_pane hwnd)) of
                    Option.SOME n => set n
                  | _ => ()
d842 1
a842 1
                   else ())
@


1.33
log
@Adding code to redirect standard IO back to the terminal.
Since current implementation ignores has_controlling_tty, we can always
do it anyway.
@
text
@d4 5
d399 7
@


1.32
log
@Static command handlers changed to be dynamic to improve delivery
@
text
@d4 3
d1069 1
d1071 2
a1072 1
          | 2 => Windows.destroyWindow (get_real applicationShell)
@


1.31
log
@Added handlers around all calls to Capi.getStockObject.
@
text
@d4 3
d945 1
a945 5
    local
      (* a fixed set of control identifiers here *)
      val tty_id = Windows.newControlId ()
      val exit_id = Windows.newControlId ()
      val cancel_id = Windows.newControlId ()
a952 4
      val _ =
        (Windows.addCommandHandler (Windows.nullWindow,tty_id,tty_action);
         Windows.addCommandHandler (Windows.nullWindow,exit_id,exit_action);
         Windows.addCommandHandler (Windows.nullWindow,cancel_id,cancel_action))
d957 11
@


1.30
log
@Removed the Help menus.
@
text
@d4 3
d311 17
d349 12
a360 6
        val Windows.OBJECT gui_font =
          Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
          handle
            Windows.WindowSystemError _ =>
              Windows.getStockObject (Windows.ANSI_VAR_FONT)
	val _ = Windows.selectObject (dc, Windows.OBJECT gui_font);
d381 1
a381 5
            Windows.sendMessage
              (button,
               Windows.WM_SETFONT,
               Windows.WPARAM gui_font,
               Windows.LPARAM (Windows.intToWord 0));
d405 1
a405 5
            Windows.sendMessage
              (button,
               Windows.WM_SETFONT,
               Windows.WPARAM gui_font,
               Windows.LPARAM (Windows.intToWord 0));
@


1.29
log
@Corrected sizes of buttons in the light of the recent font change.
@
text
@d4 3
a293 17
        fun add_help menu =
          let
            val help_menu = Windows.createPopupMenu ()
            datatype Item = ITEM of string * Windows.word | SEPARATOR
            fun add_item (ITEM (name,id)) =
              Windows.appendMenu (help_menu,[Windows.MF_STRING],Windows.ITEM id,name)
              | add_item SEPARATOR =
                Windows.appendMenu (help_menu,[Windows.MF_SEPARATOR],null_item,"")
          in
            map add_item 
            [ITEM ("&Contents", IDM_HELPCONTENTS),
             ITEM ("&Search for Help On...",  IDM_HELPSEARCH),
             ITEM ("&How to Use Help",        IDM_HELPHELP),
             SEPARATOR,
             ITEM ("&About MLWorks...",       IDM_ABOUT)];
            Windows.appendMenu (menu,[Windows.MF_POPUP],Windows.SUBMENU help_menu,"&Help")
          end
a303 1
        add_help menu;
@


1.28
log
@Made buttons use the DEFAULT_GUI_FONT, when defined, and ANSI_VAR_FONT
otherwise.
@
text
@d4 4
a322 16
    fun set_gui_font window =
      let
        val Windows.OBJECT gui_font =
          Windows.getStockObject (Windows.DEFAULT_GUI_FONT)
	  handle
	    Windows.WindowSystemError _ =>
              Windows.getStockObject (Windows.ANSI_VAR_FONT)
      in
        Windows.sendMessage
          (window,
           Windows.WM_SETFONT,
           Windows.WPARAM gui_font,
           Windows.LPARAM (Windows.intToWord 1));
        ()
      end

d332 1
d336 15
d356 1
a356 1
            val width = twidth + 30
d370 5
a374 1
	    set_gui_font button;
d387 1
a387 1
            val width = twidth + 30
d398 5
a402 1
	    set_gui_font button;
@


1.27
log
@More on last change
@
text
@d4 3
d319 16
d366 1
d390 1
d1051 1
@


1.26
log
@Improving exit_dialog
@
text
@d4 3
d917 1
a917 2
      fun quit_on_exit () =
        MLWorks.IO.output (MLWorks.IO.terminal_out,"Quit on exit\n")
a925 1
          val dialog_width = 150
d930 1
a930 1
                (150,
d937 1
a937 1
                  width = dialog_width,
d947 1
a947 1
                  width = 40,
d950 1
a950 1
                  text = "End Windows Session",
d955 1
a955 1
                  x = 55,
d957 1
a957 1
                  width = 40,
d965 1
a965 1
                  x = 105,
d973 1
a973 1
              (100,
d980 1
a980 1
                  width = dialog_width,
d990 1
a990 1
                  width = 40,
d993 1
a993 1
                  text = "Exit",
d998 1
a998 1
                  x = 55,
@


1.25
log
@Don'
Don't do action after OK with nothing selected
@
text
@d4 4
d914 2
d924 1
a924 1
          val dialog_width = 100
d926 78
a1003 32
          val items =
            [ITEMTEMPLATE
             {styles = [Windows.WS_CHILD,
                        Windows.SS_CENTER,
                        Windows.WS_VISIBLE],
              x = 0,
              y = 5,
              width = dialog_width,
              height = 15,
              class = "STATIC",
              text = "Select an action:",
              id = Windows.nullWord},
             ITEMTEMPLATE
             {styles = [Windows.WS_CHILD,Windows.BS_DEFPUSHBUTTON,
                        Windows.WS_VISIBLE],
              x = 5,
              y = button_y,
              width = 40,
              height = 12,
              class = "BUTTON",
              text = "Exit",
              id = exit_id},
             ITEMTEMPLATE
             {styles = [Windows.WS_CHILD,Windows.BS_PUSHBUTTON,
                        Windows.WS_VISIBLE],
              x = 55,
              y = button_y,
              width = 40,
              height = 12,
              class = "BUTTON",
              text = "Cancel",
              id = cancel_id}]
d1021 3
a1023 1
          | 1 => Windows.destroyWindow (get_real applicationShell)
@


1.24
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d860 4
a863 2
             (Lists.iterate (fn f => f dbox) setters;
              action ();
@


1.23
log
@Removing Integer structure
@
text
@d4 3
d105 1
a105 1
    fun dummy s = output (MLWorks.IO.terminal_out, s ^ " unimplemented \n")
d110 1
a110 1
    fun print s = output (MLWorks.IO.terminal_out, s)
d471 1
a471 1
        fun munge ([],acc) = implode (rev acc)
d477 1
a477 1
        munge (explode s,[])
@


1.22
log
@Removing MLWorks.Integer
@
text
@d4 3
a77 1
require "../utils/integer";
a87 1
               structure Integer : INTEGER
d669 5
a673 2
                fun initializer hwnd = set_text (get_input_pane hwnd,Integer.makestring (get ()))
                fun setter hwnd = set (Integer.parseinteger (get_text (get_input_pane hwnd)))
@


1.21
log
@Fixing sliders
@
text
@d4 3
d72 2
d103 2
a104 2
    val P = MLWorks.Integer.makestring
    val W = MLWorks.Integer.makestring o Windows.wordToInt
@


1.20
log
@Changes to windows structure
@
text
@d4 3
d359 2
a379 2
                            (* output (MLWorks.IO.terminal_out,
                                    "Sliding to " ^ MLWorks.Integer.makestring pos ^ "\n");*)
d382 19
a400 1
                      else ()
@


1.19
log
@Changes to Windows signature
@
text
@d4 3
d302 1
a302 1
        val dc = Windows.getDc real_parent
d395 1
a395 1
        Windows.releaseDc (real_parent,dc);
@


1.18
log
@Changing representation of Widgets
@
text
@d4 3
d82 1
a82 1
               sharing type CapiTypes.Hwnd = Windows.Hwnd
d93 1
a93 1
    val W = MLWorks.Integer.makestring o Windows.word_to_int
d101 4
a104 4
    val IDM_HELPCONTENTS = Windows.int_to_word 400
    val IDM_HELPSEARCH   = Windows.int_to_word 401
    val IDM_HELPHELP     = Windows.int_to_word 402
    val IDM_ABOUT        = Windows.int_to_word 403
d106 1
a106 1
    val null_item = Windows.ITEM Windows.null_word
d134 1
a134 1
               (Windows.append_menu (menu,[Windows.MF_SEPARATOR],null_item,"");
d139 1
a139 1
                 val value = Windows.ITEM Windows.null_word
d141 1
a141 1
                 Windows.append_menu (menu, [Windows.MF_STRING,Windows.MF_DISABLED],value,label);
d151 6
a156 6
                 Windows.append_menu (menu,[Windows.MF_STRING],value,label);
                 Windows.add_command_handler (parent,
                                              id,
                                              fn _ =>
                                              (checked := not (!checked);
                                               action (!checked)));
d159 1
a159 1
                               Windows.enable_menu_item
d165 1
a165 1
                               Windows.check_menu_item
d179 2
a180 2
                 Windows.append_menu (menu,[Windows.MF_STRING],Windows.ITEM id,label);
                 Windows.add_command_handler (parent,id,fn _ => action ());
d183 1
a183 1
                  Windows.enable_menu_item
d195 1
a195 1
                 val submenu = Windows.create_popup_menu()
d201 1
a201 1
                     (Windows.delete_menu (submenu,Windows.int_to_word (n-1),Windows.MF_BYPOSITION);
d207 1
a207 1
                         val id = Windows.new_control_id ()
d220 2
a221 2
                     Windows.append_menu (menu,[Windows.MF_STRING],Windows.ITEM id,name);
                     Windows.add_command_handler (parent,id,fn _ => action ());
d223 1
a223 1
                      Windows.enable_menu_item
d242 1
a242 1
                 Windows.append_menu (menu,[Windows.MF_POPUP],Windows.SUBMENU submenu,label);
d248 1
a248 1
                 val submenu = Windows.create_popup_menu ()
d251 1
a251 1
                 Windows.append_menu (menu,[Windows.MF_POPUP],Windows.SUBMENU submenu,label);
d258 1
a258 1
            val help_menu = Windows.create_popup_menu ()
d261 1
a261 1
              Windows.append_menu (help_menu,[Windows.MF_STRING],Windows.ITEM id,name)
d263 1
a263 1
                Windows.append_menu (help_menu,[Windows.MF_SEPARATOR],null_item,"")
d271 1
a271 1
            Windows.append_menu (menu,[Windows.MF_POPUP],Windows.SUBMENU help_menu,"&Help")
d274 1
a274 1
        val menu = Windows.create_menu ()
d281 1
a281 1
           Option.SOME Windows.null_word)
d284 2
a285 2
        Windows.add_message_handler (parent,Windows.WM_INITMENU,update_fn);
        Windows.set_menu (parent,menu)
d299 1
a299 1
        val dc = Windows.get_dc real_parent
d304 1
a304 1
            val (twidth,_) = Windows.get_text_extent_point (dc,label)
d307 1
a307 1
              Windows.create_window
d316 1
a316 1
              (Windows.enable_window (button,sensitive());
d319 3
a321 3
            Windows.move_window (button,!xref,top_margin,width,height,false);
            Windows.show_window (button,Windows.SW_SHOW);
            Windows.update_window button;
d324 1
a324 1
            Windows.add_command_handler (real_parent,id,fn n => callback ());
d330 1
a330 1
            val (twidth,_) = Windows.get_text_extent_point (dc,label)
d333 1
a333 1
              Windows.create_window
d340 1
a340 1
               menu = Windows.null_word}
d342 3
a344 3
            Windows.move_window (button,!xref,top_margin,width,height,false);
            Windows.show_window (button,Windows.SW_SHOW);
            Windows.update_window button;
d354 1
a354 1
                Windows.create_window
d366 1
a366 1
                      if code = Windows.convert_sb_value Windows.SB_THUMBPOSITION
d374 1
a374 1
                            Windows.set_scroll_pos (slider,Windows.SB_CTL,pos,true)
d378 1
a378 1
                    Option.SOME Windows.null_word
d381 4
a384 4
              Windows.set_scroll_range (slider,Windows.SB_CTL,min,max,false);
              Windows.move_window (slider,!xref,top_margin,width,height,false);
              Windows.show_window (slider,Windows.SW_SHOW);
              Windows.update_window slider;
d386 1
a386 1
              Windows.add_message_handler (real_parent,Windows.WM_HSCROLL,handler);
d392 1
a392 1
        Windows.release_dc (real_parent,dc);
d401 1
a401 1
      {styles: Windows.WindowStyle list,
d413 1
a413 1
      {styles: Windows.WindowStyle list,
d432 2
a433 2
    val create_dialog_indirect : Template * Windows.Hwnd -> Windows.Hwnd = env "nt create dialog indirect"
    val dialog_box_indirect : Template * Windows.Hwnd -> int = env "nt dialog box indirect"
d449 1
a449 1
        val string_word = Windows.make_c_string (munge_string s)
d451 2
a452 2
        Windows.send_message (window,Windows.WM_SETTEXT,
                              Windows.WPARAM (Windows.null_word),
d458 4
a461 4
      Windows.word_to_int (Windows.send_message (text,
                                                 Windows.WM_GETTEXTLENGTH,
                                                 Windows.WPARAM Windows.null_word,
                                                 Windows.LPARAM Windows.null_word))
d468 6
a473 6
        val _ = Windows.send_message (window,
                                      Windows.WM_GETTEXT,
                                      Windows.WPARAM (Windows.int_to_word (size+1)), (* add 1 for the last null character *)
                                      Windows.LPARAM buffer)
        val _ = Windows.set_byte (buffer,size,0) (* null terminate *) (* probably not necessary *)
        val result = Windows.word_to_string buffer
d491 4
a494 4
    val ok_id = Windows.new_control_id ()
    val apply_id = Windows.new_control_id ()
    val reset_id = Windows.new_control_id ()
    val cancel_id = Windows.new_control_id ()
d514 1
a514 1
                   id = Windows.null_word}
d532 1
a532 1
                   id = Windows.null_word}
d557 1
a557 1
                    Windows.check_dlg_button (hwnd,id,if value then 1 else 0)
d561 1
a561 1
                    val value = (Windows.is_dlg_button_checked (hwnd,id) = 1)
d599 2
a600 2
                   id = Windows.null_word}
                fun get_input_pane hwnd = Windows.get_dlg_item (hwnd,id)
d637 2
a638 2
                   id = Windows.null_word}
                fun get_input_pane hwnd = Windows.get_dlg_item (hwnd,id)
d698 1
a698 1
                   Windows.check_dlg_button (hwnd,id,if get() then 1 else 0))
d708 1
a708 1
                      Windows.check_radio_button (hwnd,first,last,id))
d715 1
a715 1
                   if Windows.is_dlg_button_checked (hwnd,id) = 1
d738 1
a738 1
           id = Windows.null_word} ::
d781 1
a781 1
        val window_ref = ref (Windows.null_window)
d784 2
a785 2
          (Windows.enable_window (Windows.get_dlg_item (window,apply_id),!changed_ref);
           Windows.enable_window (Windows.get_dlg_item (window,reset_id),!changed_ref);
d790 2
a791 2
        if Windows.is_window (!window_ref)
          then Windows.bring_window_to_top (!window_ref)
d795 1
a795 1
            val _ = Windows.register_popup_window (dbox)
d797 2
a798 2
              (Windows.unregister_popup_window dbox;
               Windows.destroy_window dbox)
d803 1
a803 1
             Windows.add_command_handler
d814 1
a814 1
            Windows.add_command_handler
d821 1
a821 1
            Windows.add_command_handler
d829 1
a829 1
            Windows.add_command_handler
d836 1
a836 1
            Windows.add_command_handler
d844 1
a844 1
            Windows.show_window (dbox,Windows.SW_SHOW)
d847 1
a847 1
        if Windows.is_window (!window_ref)
d857 3
a859 3
      val tty_id = Windows.new_control_id ()
      val exit_id = Windows.new_control_id ()
      val cancel_id = Windows.new_control_id ()
d861 1
a861 1
        Windows.end_dialog (hwnd,2)
d863 1
a863 1
        Windows.end_dialog (hwnd,1)
d865 1
a865 1
        Windows.end_dialog (hwnd,0)
d867 3
a869 3
        (Windows.add_command_handler (Windows.null_window,tty_id,tty_action);
         Windows.add_command_handler (Windows.null_window,exit_id,exit_action);
         Windows.add_command_handler (Windows.null_window,cancel_id,cancel_action))
d887 1
a887 1
              id = Windows.null_word},
d925 2
a926 2
          | 1 => Windows.destroy_window (get_real applicationShell)
          | 2 => Windows.destroy_window (get_real applicationShell)
@


1.17
log
@Adding slider controls
@
text
@d4 3
d64 1
d75 1
d77 1
d79 1
d94 1
a94 1
    type Widget = Windows.Hwnd
d127 1
d288 1
d296 1
a296 1
        val dc = Windows.get_dc parent
d310 1
a310 1
               parent = parent,
d321 1
a321 1
            Windows.add_command_handler (parent,id,fn n => callback ());
d336 1
a336 1
               parent = parent,
d357 1
a357 1
                 parent = parent,
d383 1
a383 1
              Windows.add_message_handler (parent,Windows.WM_HSCROLL,handler);
d389 1
a389 1
        Windows.release_dc (parent,dc);
d784 1
d791 1
a791 1
            val dbox = create_dialog_indirect (template,parent)
d918 1
a918 1
          val result = dialog_box_indirect (template,parent)
d922 2
a923 2
          | 1 => Windows.destroy_window (applicationShell)
          | 2 => Windows.destroy_window (applicationShell)
@


1.16
log
@More stuff.
@
text
@d4 3
d304 2
a305 1
              (Windows.enable_window (button,sensitive()))
d315 63
a377 1
        | do_one _ = (fn _ => false)
@


1.15
log
@Make buttons variable width, depending on string size
@
text
@d4 3
d684 1
a684 1
                    Windows.WS_DLGFRAME,
@


1.14
log
@Changing some windows styles
@
text
@d4 3
a276 1
        val width = 100
d280 2
d285 3
d291 1
a291 1
               name = LabelStrings.get_label name,
d311 1
@


1.13
log
@Changing message handling
@
text
@d4 3
d673 1
a673 1
                    Windows.WS_BORDER,
d822 1
a822 1
                       (* Windows.DS_MODALFRAME, *)
@


1.12
log
@More stuff
@
text
@d4 3
d258 1
a258 1
           Windows.null_word)
@


1.11
log
@More stuff
@
text
@d4 3
d268 1
a268 1
        val width = 70
d295 1
a295 1
        | do_one _ = Crash.impossible "Can't do this button type yet"
@


1.10
log
@Trying to fix radio buttons
@
text
@d4 3
d54 1
d64 3
d96 2
d118 1
a118 1
                 val id = Windows.new_control_id ()
d123 2
a124 1
                 Windows.add_command_handler (id,
d143 1
a143 1
	  | SLIDER (name,min,max,set_value) =>
d148 1
a148 2
                 val id = Windows.new_control_id ()
                 val value = Windows.ITEM id
d150 2
a151 2
                 Windows.append_menu (menu,[Windows.MF_STRING],value,label);
                 Windows.add_command_handler (id,fn _ => action ());
d161 1
a162 1
               (* A hack until we do dynamic menus properly *)
d167 3
a169 1
                 val count_ref = ref Option.NONE
d174 28
a201 1
                 (* This should attempt to reuse the identifiers *)
d203 3
a205 4
                   (case !count_ref of
                      Option.SOME count =>
                        loop count
                    | _ => ();
d207 1
a207 1
                      val subfns = map (add_item submenu) (f())
d209 2
a210 2
                      count_ref := Option.SOME (Lists.length subfns);
                      Lists.iterate (fn (Option.SOME f) => f () | Option.NONE => ()) subfns
d271 1
a271 1
            val id = Windows.new_control_id ()
d289 1
a289 1
            Windows.add_command_handler (id,fn n => callback ());
d390 8
d441 1
a441 1
                val id = Windows.new_control_id()
d476 1
a476 1
                val id = Windows.new_control_id ()
d514 1
a514 1
                val id = Windows.new_control_id()
a552 1
                val first_id = ref Windows.null_word
d557 5
a561 1
                    val id = Windows.new_control_id()
d575 1
a575 1
                       text = LabelStrings.get_label string,
d579 1
a579 1
                    (template,(get,id),(set,id))
d599 9
a607 1
                  (fn (get,id) =>
d609 2
a610 1
                     Windows.check_radio_button (hwnd,first,last,id)
d613 1
a628 4
        val ok_id = Windows.new_control_id ()
        val apply_id = Windows.new_control_id ()
        val reset_id = Windows.new_control_id ()
        val cancel_id = Windows.new_control_id ()
d696 4
d705 2
a706 1
             (id,
d716 2
a717 1
            (ok_id,
d721 1
a721 1
              Windows.destroy_window dbox));
d723 2
a724 1
            (apply_id,
d731 2
a732 1
            (reset_id,
d738 3
a740 3
            (cancel_id,
             fn _ =>
             Windows.destroy_window dbox);
d758 3
a760 3
      val tty_id = Windows.new_control_id()
      val exit_id = Windows.new_control_id()
      val cancel_id = Windows.new_control_id()
d768 3
a770 3
        (Windows.add_command_handler (tty_id,tty_action);
         Windows.add_command_handler (exit_id,exit_action);
         Windows.add_command_handler (cancel_id,cancel_action))
@


1.9
log
@Add sliders.
@
text
@d4 3
d564 2
a565 1
                (new_templates @@ templates,
d568 1
a568 1
                 new_ids @@ ids)
@


1.8
log
@make_buttons now returns a record of functions.
@
text
@d4 3
d77 2
d130 2
@


1.7
log
@Attempting to do dynamic menus
@
text
@d4 3
d248 2
a249 1
        fn _ => Lists.iterate (fn f => f ()) set_sensitivity_fns
@


1.6
log
@** No reason given. **
@
text
@d4 3
d145 17
a161 1
                 val subfns = map (add_item submenu) (f())
a162 1
                 dummy "dynamic menus";
d164 1
a164 3
                 Option.SOME
                 (fn _ =>
                  Lists.iterate (fn (Option.SOME f) => f () | Option.NONE => ()) subfns)
@


1.5
log
@Adding text and int input.
@
text
@d4 3
d557 1
a557 1
          (fn (x,text,id) =>
d559 3
a561 1
           {styles = [Windows.WS_CHILD,Windows.BS_PUSHBUTTON,
d570 4
a573 4
          [(x_margin,"OK",ok_id),
           (x_margin + 35,"Apply",apply_id),
           (x_margin + 70,"Reset",reset_id),
           (x_margin + 105,"Cancel",cancel_id)]
d589 1
a589 1
         initializers,setters,
d697 1
a697 1
             {styles = [Windows.WS_CHILD,Windows.BS_PUSHBUTTON,
@


1.4
log
@Adding dialogs
@
text
@d4 3
d22 1
d32 1
d39 2
d45 2
d76 82
a157 35
        fun add_items ([],menu) = ()
          | add_items (item::rest,menu) =
            (case item of
               SEPARATOR =>
                 Windows.append_menu (menu,[Windows.MF_SEPARATOR],null_item,"")
             | LABEL _ => ()
             | TOGGLE _ => ()
             | PUSH (name,action,sensitive) =>
                 let
                   val label = LabelStrings.get_label name
                   val id = Windows.new_control_id ()
                   val value = Windows.ITEM id
                 in
                   (Windows.append_menu (menu,[Windows.MF_STRING],value,label);
                    Windows.add_command_handler (id,fn _ => action ()))
                 end
             | DYNAMIC (name,f,sensitive) =>
                 (* A hack until we do dynamic menus properly *)
                 (* We need to handle a WM_INITMENUPOPUP message *)
                 let
                   val label = LabelStrings.get_label name
                   val submenu = Windows.create_popup_menu()
                   val _ = add_items (f(),submenu)
                 in
                   Windows.append_menu (menu,[Windows.MF_POPUP],Windows.SUBMENU submenu,label)
                 end
             | CASCADE (name,subitems,sensitive) =>
                 let
                   val label = LabelStrings.get_label name
                   val submenu = Windows.create_popup_menu()
                   val _ = add_items (subitems,submenu)
                 in
                   Windows.append_menu (menu,[Windows.MF_POPUP],Windows.SUBMENU submenu,label)
                 end;
              add_items (rest,menu))
d177 7
a184 1
        add_items (menuspec,menu);
d186 1
d262 1
a262 2
      OPTRADIO of OptionSpec list |
      OPTSUBMENU of OptionSpec list
d267 44
d315 1
d318 2
d366 1
a366 1
                  {styles = [Windows.BS_AUTOCHECKBOX, (* Maybe this should be RADIOBUTTON *)
d396 140
a535 1
          | _ => acc
d537 4
a540 4
        val ok_id = Windows.new_control_id()
        val apply_id = Windows.new_control_id()
        val reset_id = Windows.new_control_id()
        val cancel_id = Windows.new_control_id()
d658 75
a732 4
    (* Need a hand-crafted exit function here *)
    fun exit_dialog (parent,applicationShell,has_controlling_tty) =
      dummy "exit_dialog"

@


1.3
log
@Extending
@
text
@d4 3
d34 4
a39 3
    fun dummy s =
      output (MLWorks.IO.terminal_out, s ^ " unimplemented \n")

d72 1
a72 1
             | LABEL _=> ()
d149 2
d157 2
a158 1
            Windows.add_command_handler (id,fn n => callback ())
d161 1
d163 1
a163 2
        Lists.iterate do_one menuspec;
        fn _ => ()
d166 25
d202 139
d342 72
a413 2
      (dummy "create_dialog";
       (fn _ => (), fn _ => ()))
@


1.2
log
@Making it all work
@
text
@d4 3
d15 2
d24 3
a26 1
functor Menus (structure Windows : WINDOWS
a32 2
    exception Unimplemented of string 

d36 9
d66 2
a67 1
               SEPARATOR => ()
d73 1
a73 1
                   val id = Windows.new_menu_id ()
d77 11
a87 1
                    Windows.add_menu_command (id,action))
a88 1
             | DYNAMIC _ => ()
d98 18
d119 1
d124 34
a157 2
      (dummy "make_buttons";
       fn _ => ())
a168 4

    fun make_options  (parent, optionspec) =
      (dummy "make_options";
       (fn _ => (), fn _ => ()))
@


1.1
log
@new unit
MS Windows GUI
@
text
@d4 4
d13 1
d20 1
d24 1
a24 1
    type Widget = Windows.window
d28 3
d46 38
d95 3
a97 3
    fun make_submenus (parent, menuspec) =
      (output (std_out, "Unimplemented make_submenus\n");
       fn _ => ())
a98 2
    fun make_options  (parent, optionspec) =
      raise Unimplemented "make_options"
d100 1
a100 1
      (output (std_out, "Unimplemented create_dialog\n");
@
