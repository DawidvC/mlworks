head	1.20;
access;
symbols
	MLW_daveb_inline_1_4_99:1.20.1
	MLWorks_21c0_1999_03_25:1.20
	MLWorks_20c1_1998_08_20:1.19
	MLWorks_20c0_1998_08_04:1.19
	MLWorks_20b2c2_1998_06_19:1.18
	MLWorks_20b2_Windows_1998_06_12:1.18
	MLWorks_20b1c1_1998_05_07:1.16
	MLWorks_20b0_1998_04_07:1.15
	MLWorks_20b0_1998_03_20:1.15
	MLWorks_20m2_1998_02_16:1.14
	MLWorks_20m1_1997_10_23:1.14
	MLWorks_11r1:1.11.1.1.1.4.1
	MLWorks_workspace_97:1.14.2
	MLWorks_dt_wizard:1.14.1
	MLWorks_11c0_1997_09_09:1.11.1.1.1.4
	MLWorks_10r3:1.11.1.1.3
	MLWorks_10r2_551:1.11.1.1.2
	MLWorks_11:1.11.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.11.1.1
	MLWorks_20m0_1997_06_20:1.12
	MLWorks_1_0_r2c2_1997_06_14:1.11.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.11.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.11.1
	MLWorks_BugFix_1997_04_24:1.11
	MLWorks_1_0_r2_Win32_1997_04_11:1.11
	MLWorks_1_0_r2_Unix_1997_04_04:1.11
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.3.1.1
	MLWorks_gui_1996_12_18:1.8.4
	MLWorks_1_0_Win32_1996_12_17:1.8.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.1.1
	MLWorks_1_0_Irix_1996_11_28:1.8.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.2
	MLWorks_1_0_Unix_1996_11_14:1.8.1
	MLWorks_Open_Beta2_1996_10_11:1.6.3
	MLWorks_License_dev:1.6.2
	MLWorks_1_open_beta_1996_09_13:1.6.1
	MLWorks_Open_Beta_1996_08_22:1.5;
locks; strict;
comment	@ *  @;


1.20
date	99.02.02.16.02.07;	author mitchell;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	98.07.29.13.24.27;	author mitchell;	state Exp;
branches;
next	1.18;

1.18
date	98.06.05.14.24.54;	author mitchell;	state Exp;
branches;
next	1.17;

1.17
date	98.05.26.13.56.24;	author mitchell;	state Exp;
branches;
next	1.16;

1.16
date	98.04.21.10.53.11;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	98.02.19.16.23.41;	author mitchell;	state Exp;
branches;
next	1.14;

1.14
date	97.07.16.15.24.49;	author brucem;	state Exp;
branches
	1.14.1.1
	1.14.2.1;
next	1.13;

1.13
date	97.07.11.11.21.07;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	97.05.09.12.48.11;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	97.03.24.13.25.16;	author andreww;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	97.01.15.12.14.06;	author io;	state Exp;
branches;
next	1.9;

1.9
date	96.11.16.02.05.04;	author io;	state Exp;
branches;
next	1.8;

1.8
date	96.11.08.14.24.26;	author matthew;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1;
next	1.7;

1.7
date	96.10.21.15.24.19;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	96.08.22.10.33.16;	author stephenb;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1;
next	1.5;

1.5
date	96.08.20.10.45.31;	author andreww;	state Exp;
branches;
next	1.4;

1.4
date	96.08.14.10.29.51;	author andreww;	state Exp;
branches;
next	1.3;

1.3
date	96.08.09.13.30.48;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	96.08.05.16.04.11;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	96.07.18.16.07.09;	author andreww;	state Exp;
branches;
next	;

1.6.1.1
date	96.09.13.11.43.58;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.10.07.16.37.11;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.10.17.11.56.10;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.11.14.13.24.31;	author hope;	state Exp;
branches
	1.8.1.1.1.1;
next	;

1.8.1.1.1.1
date	96.11.28.15.35.25;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.11.22.18.41.37;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.12.17.18.20.35;	author hope;	state Exp;
branches
	1.8.3.1.1.1;
next	;

1.8.3.1.1.1
date	97.02.24.12.15.13;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.12.18.10.16.08;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	97.05.12.10.54.13;	author hope;	state Exp;
branches
	1.11.1.1.1.1
	1.11.1.1.2.1
	1.11.1.1.3.1;
next	;

1.11.1.1.1.1
date	97.07.28.18.36.48;	author daveb;	state Exp;
branches;
next	1.11.1.1.1.2;

1.11.1.1.1.2
date	97.08.08.09.02.13;	author johnh;	state Exp;
branches;
next	1.11.1.1.1.3;

1.11.1.1.1.3
date	97.08.08.09.13.02;	author johnh;	state Exp;
branches;
next	1.11.1.1.1.4;

1.11.1.1.1.4
date	97.08.08.09.27.57;	author johnh;	state Exp;
branches
	1.11.1.1.1.4.1.1;
next	;

1.11.1.1.1.4.1.1
date	97.10.07.12.01.55;	author jkbrook;	state Exp;
branches;
next	;

1.11.1.1.2.1
date	97.09.08.17.28.58;	author daveb;	state Exp;
branches;
next	;

1.11.1.1.3.1
date	97.09.09.14.26.53;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	97.09.10.19.45.09;	author brucem;	state Exp;
branches;
next	;

1.14.2.1
date	97.09.11.21.12.19;	author daveb;	state Exp;
branches;
next	;

1.20.1.1
date	99.04.01.18.10.23;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
renaming file __primio.sml -> __os_prim_io.sml
@


1.20
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* ==== INITIAL BASIS : OS_PRIM_IO for Win32 ====
 *
 *  Copyright (C) 1996 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  Revision Log
 *  ------------
 *  $Log: __os_prim_io.sml,v $
 *  Revision 1.19  1998/07/29  13:24:27  mitchell
 *  [Bug #30450]
 *  Modify routine that adds CRs so that it doesn't fail if output only partially succeeds
 *
 *  Revision 1.18  1998/06/05  14:24:54  mitchell
 *  [Bug #30416]
 *  Use CREATE_ALWAYS when opening a file for writing
 *
 *  Revision 1.17  1998/05/26  13:56:24  mitchell
 *  [Bug #30413]
 *  Rename stdErr stream stdErr rather than stdOut
 *
 *  Revision 1.16  1998/04/21  10:53:11  jont
 *  [Bug #70107]
 *  Ensure that close closes the io descriptor as well as the file handle
 *
 *  Revision 1.15  1998/02/19  16:23:41  mitchell
 *  [Bug #30349]
 *  Fix to avoid non-unit sequence warnings
 *
 *  Revision 1.14  1997/07/16  15:24:49  brucem
 *  [Bug #30197]
 *  Change exception Fail "RandomAccessNotSupported" to IO.RandomAccessNotSupported.
 *
 *  Revision 1.13  1997/07/11  11:21:07  daveb
 *  [Bug #30192]
 *  Made attempts to close stdIn etc. raise IO.Io.
 *
 *  Revision 1.12  1997/05/09  12:48:11  jont
 *  [Bug #20045]
 *  Ensure getPos for writes return position rather than size of last write
 *
 *  Revision 1.11  1997/03/24  13:25:16  andreww
 *  [Bug #1960]
 *  making stdIO readers/writers uniform wrt unix ones.
 *
 *  Revision 1.10  1997/01/15  12:14:06  io
 *  [Bug #1892]
 *  rename __word{8,16,32}{array,vector} to __word{8,16,32}_{array,vector}
 *
 *  Revision 1.9  1996/11/16  02:05:04  io
 *  [Bug #1757]
 *  renamed __char{array,vector} to __char_{array,vector}
 *
 *  Revision 1.8  1996/11/08  14:24:26  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
 *  Revision 1.7  1996/10/21  15:24:19  jont
 *  Remove references to basis.toplevel
 *
 *  Revision 1.6  1996/08/22  10:33:16  stephenb
 *  [Bug #1554]
 *  As part of the fix iodesc and file_desc are no longer the same
 *  so add a call to Win32.fdToIOD in the necessary places.
 *
 *  Revision 1.5  1996/08/20  10:45:31  andreww
 *  [Bug #1558]
 *  Adjusting win32 open so that it doesn't create a file when
 *  reading.
 *
 *  Revision 1.3  1996/08/09  13:30:48  daveb
 *  [Bug #1536]
 *  Word8Vector.vector no longer shares with string.
 *
 *  Revision 1.2  1996/08/05  16:04:11  andreww
 *  [Bug #1530]
 *  Ensuring that length counters are set appropriately.
 *
 *  Revision 1.1  1996/07/18  16:07:09  andreww
 *  new unit
 *  renaming file __primio.sml -> __os_prim_io.sml
 *
 *  Revision 1.13  1996/07/16  13:48:14  andreww
 *  simplifying standard in, out and err.
 *
 *  Revision 1.12  1996/07/04  18:05:10  andreww
 *  Altering interface with win32 runtime environment
 *
 *  Revision 1.11  1996/07/03  12:19:48  andreww
 *  redirecting standard input/output to Window listeners.
 *
 *  Revision 1.10  1996/05/30  14:02:31  andreww
 *  Removing TextPrimIO and BinPrimIO structures.
 *
 *  Revision 1.9  1996/05/30  12:45:33  andreww
 *  adding bin to text converters.
 *
 *  Revision 1.8  1996/05/24  11:54:09  andreww
 *  extracting TextPrimIO and BinPrimIO structures
 *
 *  Revision 1.7  1996/05/20  16:55:32  jont
 *  Changes for new signatures
 *
 *  Revision 1.6  1996/05/15  14:08:50  jont
 *  __fileposint moved to __position
 *
 *  Revision 1.5  1996/05/07  08:58:39  stephenb
 *  Make stdErr write to stderr rather than stdout.
 *
 *  Revision 1.4  1996/05/01  15:23:05  matthew
 *  Fixing sharing problem
 *
 *  Revision 1.3  1996/04/18  15:25:46  jont
 *  initbasis moves to basis
 *
 *  Revision 1.2  1996/03/13  18:43:24  jont
 *  Reinstate signature constraint commented out during debugging
 *
 *  Revision 1.1  1996/03/05  16:03:29  jont
 *  new unit
 *  Support for revised initial basis
 *
 *
 *)

require "^.basis.__word8";
require "^.basis.__word8_array";
require "^.basis.__word8_vector";
require "^.basis.__char";
require "^.basis.__char_array";
require "^.basis.__char_vector";
require "^.basis.os_prim_io";
require "^.basis.__text_prim_io";
require "^.basis.__bin_prim_io";
require "^.basis.__io";
require "__win32os";
require "__win32";

structure OSPrimIO : OS_PRIM_IO =
struct

  type bin_reader = BinPrimIO.reader
  type bin_writer = BinPrimIO.writer
  type text_reader = TextPrimIO.reader
  type text_writer = TextPrimIO.writer 
  type file_desc = Win32_.file_desc


  (* It isn't clear what should be done if it the call
   * to Win32_.fdToIOD fails.  Decided against propagating
   * the error and instead just returning NONE in this case.
   *)
  fun fdToIOD fd =
    SOME (Win32_.fdToIOD fd)
    handle MLWorks.Internal.Error.SysErr _ => NONE



  fun mkWin32Reader
       {fd: file_desc, name: string, initialPos: BinPrimIO.pos, 
        checkSize : bool} =
    let
      val pos = ref initialPos

      val stringsize = size

(*
      val {size, blksize, ...} = Win32OS_.stat fd (* Extent and blocksize *)
*)
      val blksize = 1024 (* Temporary *)
      val size = if checkSize then Win32OS_.size fd else 1
      val ioDesc = fdToIOD fd
    in
      BinPrimIO.augmentReader
        (BinPrimIO.RD
	   {readVec =
	      SOME (fn i =>
	              (let val result = Win32OS_.read (fd, i)
		       in
		         pos := !pos + Word8Vector.length result;
			 result
		       end)),
            readVecNB = NONE,
(* Can Win32 do non-blocking read?
	      SOME (fn i =>
	              (let val result =
			     Win32OS_.read (fd, i)
		       in
		         pos := !pos + stringsize result;
			 SOME result
		       end)
	               handle
	                 Win32OS_.WouldBlock => NONE),
*)

            readArr = NONE,
            readArrNB = NONE,
            block = NONE,
            canInput = NONE,
            avail = fn()=>NONE,
            name = name,
            chunkSize =  blksize,
            close =
	    fn () => (case ioDesc of
			NONE => Win32OS_.close fd
		      | SOME iod => Win32_.closeIOD iod),
	    getPos = SOME(fn () => !pos),
            setPos = SOME(fn newPos =>
		       (ignore(Win32OS_.seek (fd, newPos,Win32OS_.FROM_BEGIN));
		        pos := newPos)),
            endPos = SOME(fn () => size),
            verifyPos = NONE,
	    ioDesc = ioDesc})
    end



  fun openRd filename =
    mkWin32Reader
      {fd = Win32OS_.open_ (filename, 
                            Win32OS_.READ, 
                            Win32OS_.OPEN_EXISTING),
       name = filename,
       initialPos = 0, checkSize = true}



  fun mkWin32Writer
       {fd: file_desc, name: string, blocksize: int, size: int,
        initialPos: BinPrimIO.pos} =
    let
      val pos = ref initialPos
      val ioDesc = fdToIOD fd

    in
      BinPrimIO.augmentWriter
        (BinPrimIO.WR
           {writeVec =
	      SOME (fn {buf, i, sz} => 
	              (let
			 val nelems = case sz of
			   SOME i => i
			 | NONE => Word8Vector.length buf - i
			 val result = Win32OS_.write (fd, buf, i, nelems)
		       in
		         pos := !pos + result;
			 result
		       end)),
(* Can Win32 do non-blocking write?
	      SOME (fn {data, first, nelems} => 
	              (let
			 val result = Win32OS_.write (fd, data, first, nelems)
		       in
		         pos := result;
			 SOME result
		       end)
	               handle
	                 Win32OS_.WouldBlock => NONE),
*)
            writeVecNB = NONE,
            writeArrNB = NONE,
            writeArr = NONE,
            block = NONE,
            canOutput = NONE,
            name = name,
            chunkSize = blocksize,
            close =
	    fn () => (case ioDesc of
			NONE => Win32OS_.close fd
		      | SOME iod => Win32_.closeIOD iod),
            getPos = SOME(fn () => !pos),
            setPos = SOME(fn newPos =>
            (ignore(Win32OS_.seek (fd, newPos,Win32OS_.FROM_BEGIN));
		        pos := newPos)),
            endPos = SOME(fn () => size),
            verifyPos = NONE,            (* needs to change! use seek*)
	    ioDesc = ioDesc})
    end
   
  fun openWr filename =
    let 
      val fd = Win32OS_.open_ (filename, Win32OS_.WRITE, Win32OS_.CREATE_ALWAYS)
(*
      val {size, blksize, ...} = Win32OS_.stat fd
*)
      val blksize = 1024 (* Temporary *)
      val size = Win32OS_.size fd
    in
      mkWin32Writer
        {fd = fd,
         name = filename,
	 blocksize = blksize,
	 size = size,
         initialPos = 0}
    end

  fun openApp filename =
    let 
      val fd = Win32OS_.open_ (filename, Win32OS_.READ_WRITE,
                               Win32OS_.OPEN_ALWAYS)
      val _ = Win32OS_.seek (fd, 0, Win32OS_.FROM_END)
(*
      val {size, blksize, ...} = Win32OS_.stat fd
*)
     val blksize = 1024 (* Temporary *)
      val size = Win32OS_.size fd
    in
      mkWin32Writer
        {fd = fd,
         name = filename,
	 blocksize = blksize,
	 size = size,
         initialPos = size}
    end





   (*                                                    *)
   (* Standard Input, Standard Output and Standard Error *)
   (*                                                    *)

   (* note that the functions for getPos and setPos have cases where
    * they handle the MLWorks.Internal.Error.SysErr exception.  This is
    * needed when an illegal seek occurs ... for example, when standard
    * in has been redirected from a pipe --- as is the case when
    * guib is being loaded.  I just ignore it. *)

  local
    open MLWorks.Internal.StandardIO
    val cast = MLWorks.Internal.Value.cast
  in
    val stdIn =  BinPrimIO.augmentReader
      (BinPrimIO.RD
       {readVec = SOME (fn i => cast (#get(#input(currentIO()))) i),
        readVecNB =NONE,
        readArr = NONE,
        readArrNB = NONE,
        block = NONE,
        canInput = SOME(fn ()=>valOf(#can_input(#input(currentIO()))) ()
                       handle Option => raise IO.RandomAccessNotSupported),
        avail = fn()=>NONE,
        name = "<stdIn>",
        chunkSize =  1,                        (* arbitrary! *)
        close = fn () =>
          raise IO.Io
                  {name = "<stdIn>",
                   function = "close",
                   cause = Fail "Cannot close stdIn"},
        getPos = SOME(fn ()=> valOf(#get_pos(#input(currentIO())))()
                      handle Option => raise IO.RandomAccessNotSupported
                           | MLWorks.Internal.Error.SysErr _ => 0),
        setPos = SOME(fn newPos => valOf(#set_pos(#input(currentIO()))) newPos
                      handle Option => raise IO.RandomAccessNotSupported
                           | MLWorks.Internal.Error.SysErr _ => ()),
        endPos = NONE,
        verifyPos = SOME(fn ()=> valOf(#get_pos(#input(currentIO())))()
                      handle Option => raise IO.RandomAccessNotSupported
                           | MLWorks.Internal.Error.SysErr _ => 0),
        ioDesc = NONE}) (* this value cannot be redirected dynamically*)
      
    val stdOut =
      BinPrimIO.augmentWriter
      (BinPrimIO.WR
       {writeVec = SOME (fn s => #put(#output(currentIO())) (cast s)),
       writeVecNB = NONE,
       writeArrNB = NONE,
       writeArr = NONE,
       block = NONE,
       canOutput = SOME(fn () => valOf(#can_output(#output(currentIO())))()
                        handle Option => true),
       name = "<stdOut>",
       chunkSize = 1,               (* arbitrary! *)
       close = fn () =>
         raise IO.Io
                 {name = "<stdOut>",
                  function = "close",
                  cause = Fail "Cannot close stdOut"},
       getPos = SOME(fn ()=> valOf(#get_pos(#output(currentIO())))()
                 handle Option => raise IO.RandomAccessNotSupported
                      | MLWorks.Internal.Error.SysErr _ => 0),
       setPos = SOME(fn newPos => valOf(#set_pos(#output(currentIO()))) newPos
                     handle Option => raise IO.RandomAccessNotSupported
                          | MLWorks.Internal.Error.SysErr _ => ()),
       endPos = NONE,
       verifyPos = SOME(fn ()=> valOf(#get_pos(#output(currentIO())))()
                 handle Option => raise IO.RandomAccessNotSupported
                      | MLWorks.Internal.Error.SysErr _ => 0),
       ioDesc=NONE})   
      
    val stdErr =
      BinPrimIO.augmentWriter
      (BinPrimIO.WR
       {writeVec = SOME (fn s => #put(#error(currentIO())) (cast s)),
       writeVecNB = NONE,
       writeArrNB = NONE,
       writeArr = NONE,
       block = NONE,
       canOutput = SOME(fn ()=> valOf(#can_output(#error(currentIO())))()
                       handle Option => raise IO.RandomAccessNotSupported),
       name = "<stdErr>",
       chunkSize = 1,               (* arbitrary! *)
       close = fn () =>
         raise IO.Io
                 {name = "<stdErr>",
                  function = "close",
                  cause = Fail "Cannot close stdErr"},
       getPos = SOME(fn () => valOf(#get_pos(#error(currentIO()))) ()
                       handle Option => raise IO.RandomAccessNotSupported
                            | MLWorks.Internal.Error.SysErr _ => 0),
       setPos = SOME(fn newPos => valOf(#set_pos(#error(currentIO()))) newPos
                       handle Option => raise IO.RandomAccessNotSupported
                            | MLWorks.Internal.Error.SysErr _ => ()),
       endPos = NONE,
       verifyPos = SOME(fn () => valOf(#get_pos(#error(currentIO()))) ()
                       handle Option => raise IO.RandomAccessNotSupported
                            | MLWorks.Internal.Error.SysErr _ => 0),
       ioDesc=NONE})   
      
  end




  (* On Win32, text isn't binary: but the only difference appears    *)
  (* to be that line feeds in text become linefeeds+carriage returns *)
  (* in binary mode.  Therefore conversion should simply remove      *)
  (* carriage returns.                                               *)

  (* NOTE: the reader/writer operations return the number of chars   *)
  (* that they read from/wrote to the in/outstream.  I'm assuming    *)
  (* that they always read/write the required number of chars.  The  *)
  (* library spec suggests that any k less than the required number  *)
  (* can do, but I don't quite know what this means.  Thus I subtract*)
  (* the number of carriage returns from the total.                  *)



  fun translateIn (x : BinPrimIO.reader) : TextPrimIO.reader = 
    let
       val BinPrimIO.RD({name= n,
                         chunkSize=cS,
                         readVec=rV,
                         readArr=rA,
                         readVecNB=rVNB,
                         readArrNB=rANB,
                         block= b,
                         canInput=cI,
                         avail=av,
                         getPos=gP,
                         setPos=sP,
                         endPos=eP,
                         verifyPos=vP,
                         close=c,
                         ioDesc=iD}) = x

       val CR = 13



       (* following functions remove CRs in VECTORS *)
       (* if vector only contains CRs, must reinput,*)
       (* otherwise end-of-stream signalled falsely *)
       local
         fun removeCRinVector v f = 
           if (Word8Vector.length v) = 0 then
	     CharVector.fromList []    (*propagate EOS*)
           else 
             case (Word8Vector.foldr (fn (w,l)=> 
                                      let val i = (Word8.toInt w)
                                      in if i=CR then l
                                         else (Char.chr i)::l
                                      end) [] v)
               of [] => removeCRinVector (f()) f           (* reinput *)
                | l =>  CharVector.fromList l
       in

         fun rVconv NONE = NONE
           | rVconv (SOME f) = SOME(fn args => removeCRinVector (f args)
                                                (fn () => f args))

         (* for nonblocking input, have to propagate "input blocks"    *)
         (* signals.  Use the block exception for this.                *)

         fun rVNBconv NONE = NONE
           | rVNBconv (SOME f) = 
             SOME(fn args => case (f args)
                               of NONE => NONE
                                | (SOME v) => 
                                    let exception block
                                    in
                                      SOME(removeCRinVector v
                                           (fn () => case (f args)
                                                       of NONE => raise block
                                                        | (SOME v) => v))
                                      handle block => NONE
                                    end)
       end






         (* following functions remove CRs in ARRAYS *)
         (* again, problem with having to reinput    *)

       local
         (* in following, src is the source Binary array, size is the *)
         (* size of input data, trg is the target character array and *)
         (* more is the function that reloads the array in case CR    *)
         (** removal empties src.                                     *)

         fun removeCRinArray src size trg posn more= 
           let 
             fun removeCR i j s = 
               if i>= size then (size-s,j)
               else let val k=(Word8.toInt(Word8Array.sub(src,i)))
                     in if k=CR then removeCR (i+1) j (size-1)
                        else (CharArray.update(trg,j,Char.chr k);
                             removeCR (i+1) (j+1) size)
                    end
           in 
             if size=0 then 0 else              (* propagate eos condition   *)
               case (removeCR 0 posn size)      (* otherwise remove CRs.     *)
                 of (CRs,0)=>removeCRinArray    (* if removing CRs empties   *)
                         src (more()) trg       (* array, reinput and repeat *)
                         posn more              
                  | (CRs,k)=> k-CRs             (* ow, return number of chars*)
           end
       in
         fun rAconv NONE=NONE
           | rAconv (SOME f) =
             SOME(fn (args as {buf=a,i=p,sz=s}) => 
                  let
                    val len = case s
                                of NONE=> CharArray.length a-p
                                 | (SOME z)=> z

                    val b = Word8Array.array(len,Word8.fromInt 0)
                  in
                    removeCRinArray b (f {buf=b,i=0,sz=NONE}) a p
                                      (fn () => f {buf=b,i=0,sz=NONE})
                  end)


         fun rANBconv NONE=NONE
           | rANBconv (SOME f) = 
             SOME(fn (args as {buf=a,i=p,sz=s}) => 
                  let
                    val len = case s
                                of NONE=> CharArray.length a-p
                                 | (SOME z)=> z

                    val b = Word8Array.array(len,Word8.fromInt 0)

                    exception block
                                
                    fun more () = case (f {buf=b,i=0,sz=NONE})
                                    of NONE=> raise block
                                     | (SOME k)=> k


                  in
                    SOME(removeCRinArray b (more ()) a p more)
                    handle block => NONE
                  end)
       end
    in
      TextPrimIO.RD({name=n,
                     chunkSize=cS,
                     readVec=rVconv rV,
                     readArr=rAconv rA,
                     readVecNB=rVNBconv rVNB,
                     readArrNB=rANBconv rANB,
                     block= b,
                     canInput=cI,
                     avail=av,
                     getPos=gP,
                     setPos=sP,
                     endPos=eP,
                     verifyPos=vP,
                     close=c,
                     ioDesc=iD})
    end



  (* NOW, to translate binary writers into text writers.  The translator *)
  (* should only involve adding CRs after or before line feeds.  No need *)
  (* for complicated re-outputs.                                         *)
  (* (Though perhaps chunk size efficiency should be considered?)        *)


  fun translateOut (x : BinPrimIO.writer) : TextPrimIO.writer = 
    let
      val BinPrimIO.WR({name = n,
                        chunkSize=cS,
                        writeVec=wV,
                        writeArr=wA,
                        writeVecNB=wVNB,
                        writeArrNB=wANB,
                        block=b,
                        canOutput=cO,
                        endPos=eP,
                        getPos=gP,
                        setPos=sP,
                        verifyPos=vP,
                        close=c,
                        ioDesc=iD})=x

      val LF = 10
      val CR = 13
      val LFcode=Word8.fromInt LF
      val CRcode=Word8.fromInt 13

      local
                            (* the following functions do the conversions *)
                            (* for the two write vector operations        *)
                            (* Convert text writes to binary writes.      *)

        fun addCRtoVec v = 
          let val CRs = ref 0
              val v'= Word8Vector.fromList (CharVector.foldr
                                    (fn (c,l)=> if Char.ord c=LF then
                                       (CRs:=(!CRs)+1;CRcode::LFcode::l) else
                                       Word8.fromInt (Char.ord c)::l)
                                    [] v)
           in
             (!CRs,v')
          end

        fun CRs_actually_outputV
              (CRs, augmented_vector, amount_output) =
          if Word8Vector.length(augmented_vector) = amount_output
          then CRs
          else (* Now things get messy - for now let's assume there were no
                  CRs in the original vector *)
            Word8Vector.foldli
              (fn (_, c, CRs) => if Word8.toInt c = CR then CRs + 1 else CRs)
              0
              (augmented_vector, 0, SOME amount_output)

        fun CRs_actually_outputA
              (CRs, augmented_array, amount_output) =
          if Word8Array.length(augmented_array) = amount_output
          then CRs
          else (* Now things get messy - for now let's assume there were no
                  CRs in the original vector *)
            Word8Array.foldli
              (fn (_, c, CRs) => if Word8.toInt c = CR then CRs + 1 else CRs)
              0
              (augmented_array, 0, SOME amount_output)

      in
            fun wVconv NONE=NONE
              | wVconv (SOME f) =
                SOME(fn {buf=v,i=p,sz=(s:int option)} =>
                     let val (CRs,v')=addCRtoVec (CharVector.extract(v,p,s))
                         val real_out = f{buf=v',i=0, sz=NONE}
                       in real_out-(CRs_actually_outputV(CRs, v', real_out))
                     end)
                     

            fun wVNBconv NONE=NONE
              | wVNBconv (SOME f) =
                SOME(fn {buf=v,i=p,sz=(s:int option)}=>
                     let val (CRs,v') = addCRtoVec (CharVector.extract(v,p,s))
                     in
                       case f{buf=v',i=0,sz=NONE}
                              of NONE=> NONE
                               | (SOME k) => 
                                   SOME(k-CRs_actually_outputV(CRs, v', k))
                     end)

            fun wAconv NONE=NONE
              | wAconv (SOME f) =
                SOME(fn {buf=a,i=p,sz=(s:int option)}=>
                     let val (CRs,v) = addCRtoVec (CharArray.extract(a,p,s))
                         val a'= Word8Array.array(Word8Vector.length v,
                                                  Word8.fromInt 0)
                      in
                        (Word8Array.copyVec{src=v,si=0,len=NONE,dst=a',di=0};
                         let val amount_output = f{buf=a',i=0,sz=NONE}
                          in amount_output - 
                               CRs_actually_outputA(CRs, a', amount_output) end)
                     end)


            fun wANBconv NONE=NONE
              | wANBconv (SOME f) =
                SOME(fn {buf=a,i=p,sz=(s:int option)}=>
                     let val (CRs,v) = addCRtoVec (CharArray.extract(a,p,s))
                         val a'= Word8Array.array(Word8Vector.length v,
                                                  Word8.fromInt 0)
                      in
                        (Word8Array.copyVec{src=v,si=0,len=NONE,dst=a',di=0};
                         case f{buf=a',i=0,sz=NONE}
                           of NONE=> NONE
                            | (SOME k) => SOME (k-CRs_actually_outputA(CRs, a', k)))
                     end)
      end




    in
      TextPrimIO.WR({name=n,
                     chunkSize=cS,
                     writeVec=wVconv wV,
                     writeArr=wAconv wA,
                     writeVecNB=wVNBconv wVNB,
                     writeArrNB=wANBconv wANB,
                     block=b,
                     canOutput=cO,
                     endPos=eP,
                     getPos=gP,
                     setPos=sP,
                     verifyPos=vP,
                     close=c,
                     ioDesc=iD})
    end

  fun openString s =
    let
      val pos = ref 0
      val len = size s
        
      fun stringReadVec i = 
        if !pos>=len then "" else
        (CharVector.extract(s,!pos,if !pos+i>=len
                                    then (pos:=len;NONE)
                                  else (pos:=(!pos+i);SOME i)))

      fun stringReadArr {buf,i,sz} =
        if !pos>=len then 0 else
        let val startPos = !pos
          val num_elems = case sz
                            of NONE => (pos:=len;
                                        len-startPos)
                             | (SOME n) =>
                                 if !pos+n>=len then
                                   (pos:=len;
                                    len-startPos)
                                 else (pos:=(!pos+n); n)
        in
          CharArray.copyVec {src=s, si= !pos, len=SOME num_elems,
                             dst=buf, di=i};
          num_elems
        end
      
    in
      TextPrimIO.RD
      {readVec=SOME(stringReadVec),
       readArr=SOME(stringReadArr),
       readVecNB=SOME(SOME o stringReadVec),
       readArrNB=SOME(SOME o stringReadArr),
       block=NONE,
       canInput=SOME(fn ()=> !pos< (len-1)),
       avail=fn()=> SOME(len-(!pos)),
       name="<stringIn>",
       chunkSize=1,
       close=fn () => pos:=len-1,
       getPos=SOME(fn()=> !pos),
       setPos=SOME(fn i => pos:=i),
       endPos=SOME(fn()=> len-1),
       verifyPos=SOME(fn() => !pos),
       ioDesc=NONE}
    end



end
@


1.20.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 *  Revision 1.20  1999/02/02  16:02:07  mitchell
 *  [Bug #190500]
 *  Remove redundant require statements
 *
@


1.19
log
@[Bug #30450]
Modify routine that adds CRs so that it doesn't fail if output only partially succeeds
@
text
@d12 4
a136 1
require "^.basis.__position";
@


1.18
log
@[Bug #30416]
Use CREATE_ALWAYS when opening a file for writing
@
text
@d12 4
d613 1
d633 22
d660 2
a661 1
                       in f{buf=v',i=0, sz=NONE}-CRs
d672 2
a673 1
                               | (SOME k) => SOME(k-CRs)
d684 3
a686 1
                         f{buf=a',i=0,sz=NONE}-CRs)
d700 1
a700 1
                            | (SOME k) => SOME (k-CRs))
a701 3



@


1.17
log
@[Bug #30413]
Rename stdErr stream stdErr rather than stdOut
@
text
@d12 4
d277 1
a277 1
      val fd = Win32OS_.open_ (filename, Win32OS_.WRITE, Win32OS_.OPEN_ALWAYS)
@


1.16
log
@[Bug #70107]
Ensure that close closes the io descriptor as well as the file handle
@
text
@d12 4
d393 1
a393 1
       name = "<stdOut>",
@


1.15
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d12 4
d159 1
d190 5
a194 2
            close = fn () => Win32OS_.close fd,
            getPos = SOME(fn () => !pos),
d200 1
a200 1
	    ioDesc = fdToIOD fd})
d220 1
d254 4
a257 1
            close = fn () => Win32OS_.close fd,
d264 1
a264 1
	    ioDesc = fdToIOD fd})
@


1.14
log
@[Bug #30197]
Change exception Fail "RandomAccessNotSupported" to IO.RandomAccessNotSupported.
@
text
@d12 4
d188 1
a188 1
		       (Win32OS_.seek (fd, newPos,Win32OS_.FROM_BEGIN);
d248 1
a248 1
            (Win32OS_.seek (fd, newPos,Win32OS_.FROM_BEGIN);
@


1.14.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 *  Revision 1.14  1997/07/16  15:24:49  brucem
 *  [Bug #30197]
 *  Change exception Fail "RandomAccessNotSupported" to IO.RandomAccessNotSupported.
 *
@


1.14.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 *  Revision 1.14  1997/07/16  15:24:49  brucem
 *  [Bug #30197]
 *  Change exception Fail "RandomAccessNotSupported" to IO.RandomAccessNotSupported.
 *
@


1.13
log
@[Bug #30192]
Made attempts to close stdIn etc. raise IO.Io.
@
text
@d1 1
a1 1
(*  ==== INITIAL BASIS : OS_PRIM_IO for Win32 ====
d12 4
d313 1
a313 1
                       handle Option => raise Fail "RandomAccessNotSupported"),
d323 1
a323 1
                      handle Option => raise Fail "RandomAccessNotSupported"
d326 1
a326 1
                      handle Option => raise Fail "RandomAccessNotSupported"
d330 1
a330 1
                      handle Option => raise Fail "RandomAccessNotSupported"
d352 1
a352 1
                 handle Option => raise Fail "RandomAccessNotSupported"
d355 1
a355 1
                     handle Option => raise Fail "RandomAccessNotSupported"
d359 1
a359 1
                 handle Option => raise Fail "RandomAccessNotSupported"
d372 1
a372 1
                       handle Option => raise Fail "RandomAccessNotSupported"),
d381 1
a381 1
                       handle Option => raise Fail "RandomAccessNotSupported"
d384 1
a384 1
                       handle Option => raise Fail "RandomAccessNotSupported"
d388 1
a388 1
                       handle Option => raise Fail "RandomAccessNotSupported"
@


1.12
log
@[Bug #20045]
Ensure getPos for writes return position rather than size of last write
@
text
@d12 4
d110 1
d313 5
a317 1
        close = fn () => #close(#input(currentIO()))(),
d342 5
a346 1
       close = fn() => #close(#output(currentIO()))(),
d371 5
a375 1
       close = fn () => #close(#error(currentIO()))(),
@


1.11
log
@[Bug #1960]
making stdIO readers/writers uniform wrt unix ones.
@
text
@d12 4
d211 1
a211 1
		         pos := result;
a213 1
            writeVecNB = NONE,
d225 1
@


1.11.1.1
log
@branched from 1.11
@
text
@a11 4
 *  Revision 1.11  1997/03/24  13:25:16  andreww
 *  [Bug #1960]
 *  making stdIO readers/writers uniform wrt unix ones.
 *
@


1.11.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 *  Revision 1.11.1.1  1997/05/12  10:54:13  hope
 *  branched from 1.11
 *
@


1.11.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 *  Revision 1.11.1.1  1997/05/12  10:54:13  hope
 *  branched from 1.11
 *
@


1.11.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 *  Revision 1.11.1.1  1997/05/12  10:54:13  hope
 *  branched from 1.11
 *
@


1.11.1.1.1.2
log
@[Bug #20045]
Merging from trunk into MLWorks_11.
Ensure getPos for writes return position rather than size of last write
@
text
@a11 3
 *  Revision 1.11.1.1.1.1  1997/07/28  18:36:48  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d214 1
a214 1
		         pos := !pos + result;
d217 1
a228 1
            writeVecNB = NONE,
@


1.11.1.1.1.3
log
@[Bug #30192]
Merging into MLWorks_11 - Made attempts to close stdIn etc. raise IO.Io.
@
text
@a11 6
 *
 *  Revision 1.11.1.1.1.2  1997/08/08  09:02:13  johnh
 *  [Bug #20045]
 *  Merging from trunk into MLWorks_11.
 *  Ensure getPos for writes return position rather than size of last write
 *
a111 1
require "^.basis.__io";
d314 1
a314 5
        close = fn () =>
          raise IO.Io
                  {name = "<stdIn>",
                   function = "close",
                   cause = Fail "Cannot close stdIn"},
d339 1
a339 5
       close = fn () =>
         raise IO.Io
                 {name = "<stdOut>",
                  function = "close",
                  cause = Fail "Cannot close stdOut"},
d364 1
a364 5
       close = fn () =>
         raise IO.Io
                 {name = "<stdErr>",
                  function = "close",
                  cause = Fail "Cannot close stdErr"},
@


1.11.1.1.1.4
log
@[Bug #30197]
Merging into MLWorks_11.
Change exception Fail "RandomAccessNotSupported" to IO.RandomAccessNotSupported.
@
text
@d1 1
a1 1
(* ==== INITIAL BASIS : OS_PRIM_IO for Win32 ====
a11 3
 *  Revision 1.11.1.1.1.3  1997/08/08  09:13:02  johnh
 *  [Bug #30192]
 *  Merging into MLWorks_11 - Made attempts to close stdIn etc. raise IO.Io.
d317 1
a317 1
                       handle Option => raise IO.RandomAccessNotSupported),
d327 1
a327 1
                      handle Option => raise IO.RandomAccessNotSupported
d330 1
a330 1
                      handle Option => raise IO.RandomAccessNotSupported
d334 1
a334 1
                      handle Option => raise IO.RandomAccessNotSupported
d356 1
a356 1
                 handle Option => raise IO.RandomAccessNotSupported
d359 1
a359 1
                     handle Option => raise IO.RandomAccessNotSupported
d363 1
a363 1
                 handle Option => raise IO.RandomAccessNotSupported
d376 1
a376 1
                       handle Option => raise IO.RandomAccessNotSupported),
d385 1
a385 1
                       handle Option => raise IO.RandomAccessNotSupported
d388 1
a388 1
                       handle Option => raise IO.RandomAccessNotSupported
d392 1
a392 1
                       handle Option => raise IO.RandomAccessNotSupported
@


1.11.1.1.1.4.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 5
 *  Revision 1.11.1.1.1.4  1997/08/08  09:27:57  johnh
 *  [Bug #30197]
 *  Merging into MLWorks_11.
 *  Change exception Fail "RandomAccessNotSupported" to IO.RandomAccessNotSupported.
 *
@


1.10
log
@[Bug #1892]
rename __word{8,16,32}{array,vector} to __word{8,16,32}_{array,vector}
@
text
@d12 4
d311 4
a314 2
        endPos = SOME(fn()=> raise Fail "RandomAccessNotSupported"),
        verifyPos = NONE,
d337 3
a339 1
       verifyPos = NONE,
d362 3
a364 1
       verifyPos = NONE,
@


1.9
log
@[Bug #1757]
renamed __char{array,vector} to __char_{array,vector}
@
text
@d12 4
d89 2
a90 2
require "^.basis.__word8array";
require "^.basis.__word8vector";
@


1.8
log
@[Bug #1661]
Changing io_desc to iodesc
@
text
@d12 4
d88 2
a89 2
require "^.basis.__chararray";
require "^.basis.__charvector";
@


1.8.4.1
log
@branched from 1.8
@
text
@a11 4
 *  Revision 1.8  1996/11/08  14:24:26  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.8.3.1
log
@branched from 1.8
@
text
@a11 4
 *  Revision 1.8  1996/11/08  14:24:26  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.8.3.1.1.1
log
@branched from 1.8.3.1
@
text
@a11 3
 *  Revision 1.8.3.1  1996/12/17  18:20:35  hope
 *  branched from 1.8
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a11 4
 *  Revision 1.8  1996/11/08  14:24:26  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a11 4
 *  Revision 1.8  1996/11/08  14:24:26  matthew
 *  [Bug #1661]
 *  Changing io_desc to iodesc
 *
@


1.8.1.1.1.1
log
@branched from 1.8.1.1
@
text
@a11 3
 *  Revision 1.8.1.1  1996/11/14  13:24:31  hope
 *  branched from 1.8
 *
@


1.7
log
@Remove references to basis.toplevel
@
text
@d12 3
d17 1
a17 1
 *  As part of the fix io_desc and file_desc are no longer the same
@


1.6
log
@[Bug #1554]
As part of the fix io_desc and file_desc are no longer the same
so add a call to Win32.fdToIOD in the necessary places.
@
text
@d12 5
a85 1
require "^.basis.toplevel";
@


1.6.3.1
log
@branched from 1.6
@
text
@a11 5
 *  Revision 1.6  1996/08/22  10:33:16  stephenb
 *  [Bug #1554]
 *  As part of the fix io_desc and file_desc are no longer the same
 *  so add a call to Win32.fdToIOD in the necessary places.
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a11 5
 *  Revision 1.6  1996/08/22  10:33:16  stephenb
 *  [Bug #1554]
 *  As part of the fix io_desc and file_desc are no longer the same
 *  so add a call to Win32.fdToIOD in the necessary places.
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a11 5
 *  Revision 1.6  1996/08/22  10:33:16  stephenb
 *  [Bug #1554]
 *  As part of the fix io_desc and file_desc are no longer the same
 *  so add a call to Win32.fdToIOD in the necessary places.
 *
@


1.5
log
@[Bug #1558]
Adjusting win32 open so that it doesn't create a file when
reading.
@
text
@d12 5
d93 1
a93 1
  type file_desc = int (* A Win32 Handle *)
d96 7
a102 3
  (*                                            *)
  (* Readers and Writers for Win N/T filesystem *)
  (*                                            *)
d152 1
a152 1
		       (Win32OS_.seek (fd, newPos,Win32OS_.FILE_BEGIN);
d156 1
a156 1
	    ioDesc = SOME(Win32_.FILE_DESC fd)})
d164 1
a164 1
                            Win32OS_.GENERIC_READ, 
d167 1
a167 1
       initialPos = (* Position.fromDefault *) 0, checkSize = true}
d212 1
a212 1
            (Win32OS_.seek (fd, newPos,Win32OS_.FILE_BEGIN);
d216 1
a216 1
	    ioDesc = SOME(Win32_.FILE_DESC fd)})
d221 1
a221 2
      val fd = Win32OS_.open_ (filename, Win32OS_.GENERIC_WRITE,
                               Win32OS_.OPEN_ALWAYS)
d233 1
a233 1
         initialPos = (* Position.fromDefault *) 0}
d238 3
a240 3
      val fd = Win32OS_.open_ (filename, Win32OS_.GENERIC_READ_WRITE,
                               Win32OS_.OPEN_ALWAYS)   (*1. open*)
      val _ = Win32OS_.seek(fd,0,Win32OS_.FILE_END)    (*2. move to end*)
d252 1
a252 1
         initialPos = (* Position.fromDefault *) size}
d264 1
a264 1
    * they handle the MLWorks.Internal.SysErr exception.  This is
d288 1
a288 1
                           | MLWorks.Internal.SysErr _ => 0),
d291 1
a291 1
                           | MLWorks.Internal.SysErr _ => ()),
d311 1
a311 1
                      | MLWorks.Internal.SysErr _ => 0),
d314 1
a314 1
                          | MLWorks.Internal.SysErr _ => ()),
d334 1
a334 1
                            | MLWorks.Internal.SysErr _ => 0),
d337 1
a337 1
                            | MLWorks.Internal.SysErr _ => ()),
@


1.4
log
@[Bug #1537]
Augment primitive IO to pass file descriptors when opening/closing files.
@
text
@d156 1
a156 1
                            Win32OS_.OPEN_ALWAYS),
@


1.3
log
@[Bug #1536]
Word8Vector.vector no longer shares with string.
@
text
@d12 4
d147 1
a147 1
	    ioDesc = NONE})
d207 1
a207 1
	    ioDesc = NONE})
@


1.2
log
@[Bug #1530]
Ensuring that length counters are set appropriately.
@
text
@d12 4
d259 1
d263 1
a263 1
       {readVec = SOME (fn i => #get(#input(currentIO())) i),
d287 1
a287 1
       {writeVec = SOME (fn s => #put(#output(currentIO())) s),
d310 1
a310 1
       {writeVec = SOME (fn s => #put(#error(currentIO())) s),
a373 2
         

d375 3
a377 2
         fun removeCRinVector v f= 
           if (Word8Vector.length v) = 0 then v         (*propagate EOS*)
@


1.1
log
@new unit
renaming file __primio.sml -> __os_prim_io.sml
@
text
@d11 5
a15 1
 *  $Log: __primio.sml,v $
d612 1
d614 1
a614 1
                                    then (pos:=len-1;NONE)
d618 1
d621 1
a621 1
                            of NONE => (pos:=len-1;
d625 1
a625 1
                                   (pos:=len-1;
@
