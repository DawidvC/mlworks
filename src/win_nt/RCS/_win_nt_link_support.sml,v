head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.8.1
	MLWorks_21c0_1999_03_25:1.8;
locks; strict;
comment	@ * @;


1.9
date	99.04.23.11.22.48;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	99.03.17.14.56.55;	author daveb;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	99.02.02.16.02.13;	author mitchell;	state Exp;
branches;
next	1.6;

1.6
date	98.11.03.13.14.22;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	98.11.02.14.52.42;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	98.10.30.16.57.06;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	98.10.23.16.03.19;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	98.10.21.13.47.24;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	98.10.21.12.59.33;	author jont;	state Exp;
branches;
next	;

1.8.1.1
date	99.04.01.18.10.28;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Support for linking dlls and sos at lowest level
@


1.9
log
@[Bug #190553]
OS.Process.status is no longer an equality type.
@
text
@(* WinNtLinkSupport the functor *)
(*
 * Functions to support linking of .o files to make .sos or .dlls
 *
 * Copyright (c) 1998, Harlequin Group plc
 * All rights reserved
 *
 * $Log: _win_nt_link_support.sml,v $
 * Revision 1.8  1999/03/17  14:56:55  daveb
 * [Bug #190523]
 * Changes to execute functions in the Windows structure.
 *
 * Revision 1.7  1999/02/02  16:02:13  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.6  1998/11/03  13:14:22  jont
 * [Bug #70204]
 * Do archive using Windows.execute as system isn't good enough
 *
 * Revision 1.5  1998/11/02  14:52:42  jont
 * [Bug #70204]
 * Sort out entry point when linking exes
 *
 * Revision 1.4  1998/10/30  16:57:06  jont
 * [Bug #70198]
 * Add support for invoking gcc and creating a unqiue stamp for a dll/so
 *
 * Revision 1.3  1998/10/23  16:03:19  jont
 * [Bug #70198]
 * Add ability to make archives (using ar)
 *
 * Revision 1.2  1998/10/21  13:47:24  jont
 * Automatic checkin:
 * changed attribute _comment to ' * '
 *
 *
 *)

require "../utils/crash";
require "../basis/__word32";
require "../basis/__int";
require "../basis/__list";
require "../basis/__string";
require "../basis/__string";
require "../basis/__word8_vector";
require "../basis/__bin_io";
require "../basis/__text_io";
require "../basis/__io";
require "__windows";
require "__os";
require "../main/encapsulate";
require "../main/link_support";

functor WinNtLinkSupport (
  structure Crash : CRASH
  structure Encapsulate : ENCAPSULATE
) : LINK_SUPPORT =
  struct
    datatype target_type = DLL | EXE
    datatype linker_type = GNU | LOCAL
    fun munge(acc, []) = String.concat(rev acc)
      | munge(acc, [x]) = munge(x :: acc, [])
      | munge(acc, x :: y) = munge(" " :: x :: acc, y)

    val munge = fn list => munge([], list)

    fun get_all_output ins =
      if TextIO.endOfStream ins then
	()
      else
	(ignore(TextIO.input1 ins); get_all_output ins)

    fun link
      {objects, (* Full pathnames *)
       libs, (* Full pathnames *)
       target, (* Just a final component, without .exe or anything *)
       target_path, (* Where to put the target *)
       dll_or_exe,
       base, (* Default base address *)
       make_map, (* True if a link map should be produced *)
       linker (* Use the default or GNU *)
       } =
      let
	val target_ext = case dll_or_exe of DLL => "dll" | EXE => "exe"
	val target_pathname = OS.Path.joinDirFile{dir=target_path, file=target}
	val target_filename = OS.Path.joinBaseExt{base=target_pathname, ext=SOME target_ext}
	val (linker, out, linker_opts) =
	  case linker of
	    GNU => ("ld.exe", "", Crash.unimplemented"GNU linker for Win32")
	  | LOCAL =>
	      let
		val args =
		  if make_map then
		    ["/MAP:" ^ OS.Path.joinBaseExt{base=target_pathname, ext=SOME"map"}]
		  else
		    []
		val args =
		  "/nologo" ::
		  (case dll_or_exe of DLL => "/ENTRY:MLWDLLmain@@12" | EXE => "/ENTRY:main") ::
		  "-base:0x" ^ Word32.toString base :: args
		val args = case dll_or_exe of
		  DLL => "/DLL" :: args
		| EXE => args
		val out = "/OUT:" ^ target_filename
	      in
		("link.exe", out, args)
	      end
	val linker_path = case Windows.findExecutable linker of
	  SOME ln => ln
	| NONE => raise OS.SysErr("Cannot find linker: " ^ linker, NONE)
	val args = out :: (objects @@ libs @@ linker_opts)
	val cmd = munge(out :: (objects @@ libs @@ linker_opts))

	val status = Windows.simpleExecute (linker_path, args)
      in
	if OS.Process.isSuccess status then
          ()
        else
          raise OS.SysErr("Link failed", NONE)
      end

    fun checked_input(f, len) =
      let
	val s = BinIO.inputN(f, len)
	val read_len = Word8Vector.length s
      in
	if read_len <> len then raise OS.SysErr("Corrupt object file (2) " ^ Int.toString read_len ^ " " ^ Int.toString len, NONE)
	else
	  s
      end

    fun new_name file =
      let
	val {base, ext} = OS.Path.splitBaseExt file
      in
	OS.Path.toUnixPath(OS.Path.joinBaseExt{base=base, ext=SOME"mrc"})
      end

    fun copy file =
      let
	val copied = new_name file
	val code_offset = Encapsulate.code_offset file
	val input =
	  BinIO.openIn file
	  handle IO.Io{name, ...} =>
	    raise OS.SysErr("Io error: " ^ name, NONE)
	val output =
	  BinIO.openOut copied
	  handle IO.Io{name, ...} =>
	    raise OS.SysErr("Io error: " ^ name, NONE)
	(* Get everything up to but not including the code *)
	val s = checked_input(input, code_offset)
      in
	BinIO.output(output, s);
	BinIO.closeOut output
      end

    fun archive{archive : string, files : string list} =
      let
	val ar = case Windows.findExecutable"ar.exe" of
	  SOME x => x
	| NONE => raise OS.SysErr("Cannot find archiver: ar.exe", NONE)
	val copies = map new_name files
	(* Now extract the compiler info from all the .mo files *)
	val _ = app copy files;
	(* Now make the archive *)
	val status = Windows.simpleExecute (ar, "cr" :: archive :: copies)
      in
	  if OS.Process.isSuccess status then
	    ()
          else 
            raise OS.SysErr("ar failed", NONE);
	(* Now remove the copies *)
	app OS.FileSys.remove copies
      end

    fun gcc arg =
      let
	val gcc = case Windows.findExecutable"gcc.exe" of
	  SOME gcc => gcc
	| NONE => raise OS.SysErr("Can't find gcc", NONE)
	val {base, ext} = OS.Path.splitBaseExt arg
	val object = OS.Path.joinBaseExt{base=base, ext = SOME"o"}
	val args = munge["-c", arg, "-o", object]
	val status = OS.Process.system(gcc ^ " " ^ args)
      in
	if not (OS.Process.isSuccess status) then
	  raise OS.SysErr("'gcc " ^ args ^ "' failed", NONE)
	else
	  let
	    val extend = case Windows.findExecutable"extend.exe" of
	      SOME extend => extend
	    | NONE => raise OS.SysErr("Can't find extend", NONE)
	    val status = OS.Process.system(extend ^ " " ^ object)
	  in
	    if OS.Process.isSuccess status then
	      ()
	    else
	      raise OS.SysErr("'extend " ^ object ^ "' failed", NONE)
	  end
      end

    fun make_word([], n, acc) = (String.implode(rev acc), [])
      | make_word(list as (l :: rest), n, acc) =
      if n <= 0 then
	(String.implode(rev acc), rest)
      else
	make_word(rest, n-1, l :: acc)

    fun munge_stamp string =
      let
	val expl = String.explode string
	val expl = List.filter (fn x => x <> #"-") expl
	val (num1, rest) = make_word(expl, 8, [])
	val (num2, rest) = make_word(rest, 8, [])
	val (num3, rest) = make_word(rest, 8, [])
	val (num4, rest) = make_word(rest, 8, [])
      in
	(num1, num2, num3, num4)
      end

    fun make_stamp dll =
      let
	val uuidgen = case Windows.findExecutable"uuidgen.exe" of
	  SOME uuidgen => uuidgen
	| NONE => raise OS.SysErr("Can't find uuidgen", NONE)
	val proc = Windows.execute(uuidgen, [])
	val ins = Windows.textInstreamOf proc
	val line = TextIO.inputLine ins
	val (num1, num2, num3, num4) = munge_stamp line
	val _ = Windows.reap proc
      in
	"\t.data\n\t.globl\tuid\nuid:\n" ^
	"\t.long\t0x" ^ num1 ^ "\n" ^
	"\t.long\t0x" ^ num2 ^ "\n" ^
	"\t.long\t0x" ^ num3 ^ "\n" ^
	"\t.long\t0x" ^ num4 ^ "\n" ^
	"\t.globl\ttext_start\n" ^
	"\t.long\ttext_start\n" ^
	"\t.globl\tdata_start\n" ^
	"\t.long\tdata_start\n" ^
	"\t.globl\ttext_end\n" ^
	"\t.long\ttext_end\n" ^
	"\t.globl\tdata_end\n" ^
	"\t.long\tdata_end\n" ^
	"\t.long\t0\n" ^
	"\t.asciz\t\"" ^ dll ^ "\"\n"
      end

  end
@


1.8
log
@[Bug #190523]
Changes to execute functions in the Windows structure.
@
text
@d9 4
d117 3
a119 1
	if status <> OS.Process.success then
a120 2
        else
          ()
d170 2
a171 2
	  if status <> OS.Process.success then
            raise OS.SysErr("ar failed", NONE)
d173 1
a173 1
	    ();
d188 1
a188 1
	if status <> OS.Process.success then
d197 3
a199 1
	    if status <> OS.Process.success then
a200 2
	    else
	      ()
@


1.8.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 4
 * Revision 1.8  1999/03/17  14:56:55  daveb
 * [Bug #190523]
 * Changes to execute functions in the Windows structure.
 *
@


1.7
log
@[Bug #190500]
Remove redundant require statements
@
text
@d9 4
d110 2
a111 7
(*
	val _ = print("Trying '" ^ linker_path ^ " " ^ cmd ^ "'\n");
*)
	val proc = Windows.execute(linker_path, args)
	(* Now we need to read the linker output to prevent it blocking *)
	val (ins, _) = Windows.streamsOf proc
	val _ = get_all_output ins handle IO.Io _ => ()
d113 4
a116 4
	if Windows.reap proc <> 0 then
	  raise OS.SysErr("Link failed", NONE)
	else
	  ()
d164 1
a164 6
	val proc = Windows.execute(ar, "cr" :: archive :: copies)
	val _ =
	  if Windows.reap proc <> 0 then
	    raise OS.SysErr("ar failed", NONE)
	  else
	    ()
d166 4
d225 1
a225 1
	val (ins, _) = Windows.streamsOf proc
d228 1
a228 1
	val i = Windows.reap proc
@


1.6
log
@[Bug #70204]
Do archive using Windows.execute as system isn't good enough
@
text
@d9 4
a31 1
require "__win32";
a36 1
require "../basis/__char";
@


1.5
log
@[Bug #70204]
Sort out entry point when linking exes
@
text
@d9 4
d132 1
a132 1
	OS.Path.joinBaseExt{base=base, ext=SOME"mrc"}
d163 1
a163 1
	val status = OS.Process.system(ar ^ " " ^ munge("cr" :: archive :: copies));
d165 1
a165 1
	  if status <> OS.Process.success then
@


1.4
log
@[Bug #70198]
Add support for invoking gcc and creating a unqiue stamp for a dll/so
@
text
@d9 4
d86 1
a86 1
		  "/ENTRY:MLWDLLmain@@12" ::
a97 1
	(* Now because cmd is so crap, we have to put the list of objects in a file *)
@


1.3
log
@[Bug #70198]
Add ability to make archives (using ar)
@
text
@d9 4
d20 1
d24 4
d30 1
d44 12
d70 1
a70 1
	val (linker, linker_opts) =
d72 1
a72 1
	    GNU => ("ld.exe", Crash.unimplemented"GNU linker for Win32")
a75 6
		  ["/nologo",
		   "-link",
		   "/DLL",
		   "/ENTRY:MLWDLLmain@@12",
		   "-base:0x" ^ Word32.toString base]
		val args =
d77 1
a77 1
		    "/MAP:" ^ OS.Path.joinBaseExt{base=target_pathname, ext=SOME"map"} :: args
d79 9
a87 1
		    "/Fe" ^ target_filename :: args
d89 1
a89 1
		("cl.exe", args)
d94 10
d105 4
a108 1
	Windows.shellExecute(linker_path, (linker_opts @@ objects @@ libs))
a152 1
      in
d154 1
a154 1
	app copy files;
d156 8
a163 2
	Windows.shellExecute(ar, "cr" :: archive :: copies);
	(* Now put the moved files back *)
d166 74
@


1.2
log
@Automatic checkin:
changed attribute _comment to ' * '
@
text
@d8 5
a12 1
 * $Log$
d18 4
d24 1
d29 1
d50 1
a50 1
	    GNU => ("ld", Crash.unimplemented"GNU linker for Win32")
d65 1
a65 1
		("cl", args)
d72 51
@


1.1
log
@new unit
Support for linking dlls and sos at lowest level
@
text
@@
