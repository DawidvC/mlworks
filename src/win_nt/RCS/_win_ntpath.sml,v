head	1.15;
access;
symbols
	MLWorks_20b0_1998_03_20:1.15
	MLWorks_20m2_1998_02_16:1.15
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.15.5.1.1.1.1
	MLWorks_workspace_97:1.15.7
	MLWorks_dt_wizard:1.15.6
	MLWorks_11c0_1997_09_09:1.15.5.1.1.1
	MLWorks_10r3:1.15.5.1.3
	MLWorks_10r2_551:1.15.5.1.2
	MLWorks_11:1.15.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.5.1
	MLWorks_20m0_1997_06_20:1.15
	MLWorks_1_0_r2c2_1997_06_14:1.15.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.5
	MLWorks_BugFix_1997_04_24:1.15
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.3.1.1
	MLWorks_gui_1996_12_18:1.15.4
	MLWorks_1_0_Win32_1996_12_17:1.15.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.1.1
	MLWorks_1_0_Irix_1996_11_28:1.15.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.2
	MLWorks_1_0_Unix_1996_11_14:1.15.1
	MLWorks_Open_Beta2_1996_10_11:1.12.3
	MLWorks_License_dev:1.12.2
	MLWorks_1_open_beta_1996_09_13:1.12.1
	MLWorks_Open_Beta_1996_08_22:1.12
	MLWorks_Beta_1996_07_02:1.12
	MLWorks_Beta_1996_06_07:1.12
	MLWorks_Beta_1996_06_06:1.12
	MLWorks_Beta_1996_06_05:1.12
	MLWorks_Beta_1996_06_03:1.12
	MLWorks_Beta_1996_05_31:1.12
	MLWorks_Beta_1996_05_30:1.12;
locks; strict;
comment	@ * @;


1.15
date	96.11.06.16.37.56;	author jont;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1
	1.15.5.1
	1.15.6.1
	1.15.7.1;
next	1.14;

1.14
date	96.11.04.17.11.49;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.10.30.20.53.21;	author io;	state Exp;
branches;
next	1.12;

1.12
date	96.05.21.12.39.26;	author stephenb;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1;
next	1.11;

1.11
date	96.05.01.11.54.49;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	96.04.18.15.27.04;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	96.03.28.13.57.53;	author stephenb;	state Exp;
branches;
next	1.8;

1.8
date	96.03.08.17.10.50;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.04.20.15.52.22;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.03.15.11.42.41;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.03.06.20.17.47;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.02.28.14.28.22;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.01.26.15.36.37;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	95.01.25.19.37.22;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	95.01.25.17.12.37;	author daveb;	state Exp;
branches;
next	;

1.12.1.1
date	96.09.13.11.43.49;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.10.07.16.37.01;	author hope;	state Exp;
branches;
next	;

1.12.3.1
date	96.10.17.11.56.00;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.11.14.13.24.22;	author hope;	state Exp;
branches
	1.15.1.1.1.1;
next	;

1.15.1.1.1.1
date	96.11.28.15.35.13;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.11.22.18.41.27;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.12.17.18.20.25;	author hope;	state Exp;
branches
	1.15.3.1.1.1;
next	;

1.15.3.1.1.1
date	97.02.24.12.15.00;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.12.18.10.15.59;	author hope;	state Exp;
branches;
next	;

1.15.5.1
date	97.05.12.10.54.03;	author hope;	state Exp;
branches
	1.15.5.1.1.1
	1.15.5.1.2.1
	1.15.5.1.3.1;
next	;

1.15.5.1.1.1
date	97.07.28.18.36.58;	author daveb;	state Exp;
branches
	1.15.5.1.1.1.1.1;
next	;

1.15.5.1.1.1.1.1
date	97.10.07.12.02.03;	author jkbrook;	state Exp;
branches;
next	;

1.15.5.1.2.1
date	97.09.08.17.29.07;	author daveb;	state Exp;
branches;
next	;

1.15.5.1.3.1
date	97.09.09.14.27.03;	author daveb;	state Exp;
branches;
next	;

1.15.6.1
date	97.09.10.19.45.21;	author brucem;	state Exp;
branches;
next	;

1.15.7.1
date	97.09.11.21.12.28;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
The OS.Pathname structure from the basis.
@


1.15
log
@Remove references to Old so basis can be free of it
@
text
@(*  FILE PATH NAME MANIPULATION 
 *
 *  Copyright (C) 1994 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is the definition from the revised standard basis.
 *
 *  Assumes that the arcs in an exploded path are in the same order as in
 *  the unexploded path; that if the last arc is empty then the "last"
 *  component of an exploded path is empty (as opposed to making it the last
 *  directory), and that {explode,implode,split,make}Path don't check for
 *  validity.
 *  getParent "\foo" = "\" and getParent "foo" raises Path (it could instead
 *  return "..").
 *  mkCanonical "\..\foo" = "\foo"
 *  mkRelative raises Path if its arguments do not share a common root.
 *  isAbsolute, isRelative, root, and explodePath may raise Path if the
 *  path is not valid.  They do not have to do so.  This is intended to
 *  cover cases where there is no reasonable way to parse the root of the path.
 *  Drives must be a single letter.  This is probably wrong.
 *  extension of a name with a trailing "." is NOEXT, and the "." is
 *  included in the name.  "." and ".." are treated specially.
 *  Arcs may be no longer than 254 characters, and are restricted to certain
 *  characters.  ^ is a legal character (Microsoft documentation doesn't
 *  mention it either way.)
 *  mkRelative always treats the second argument as specifying a directory.
 *  Assumes Ascii.
 *
 *  Possibly we should have an isDirName predicate, and require that the
 *  second arguments to mkRelative and mkAbsolute, and the argument to
 *  getParent, should be dirNames.  If so, we should probably have a
 *  mkDirName function as well, which adds a trailing separator if needed.
 *  In fact this might be useful anyway.
 *
 *  Revision Log
 *  ------------
 *  $Log: _win_ntpath.sml,v $
 * Revision 1.14  1996/11/04  17:11:49  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.13  1996/10/30  20:53:21  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.12  1996/05/21  12:39:26  stephenb
 * Replace OS_PATH with PATH since this definition is not up to date
 * wrt revised basis and is in the process of being replaced by _os_path.
 *
 * Revision 1.11  1996/05/01  11:54:49  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.10  1996/04/18  15:27:04  jont
 * initbasis moves to basis
 *
 * Revision 1.9  1996/03/28  13:57:53  stephenb
 * PATH -> OS_PATH
 *
 * Revision 1.8  1996/03/08  17:10:50  jont
 * Allow / to be parsed as a directory separator during splitExt
 *
 * Revision 1.7  1995/04/20  15:52:22  daveb
 * filesys and path moved from utils to initbasis.
 *
 * Revision 1.6  1995/03/15  11:42:41  daveb
 * Removed trailing separators from dir components of results.
 *
 * Revision 1.5  1995/03/06  20:17:47  daveb
 * Removed the "last" component from exploded paths, and replaced
 * splitPath with splitExt and splitLast.
 *
 * Revision 1.4  1995/02/28  14:28:22  daveb
 * Removed suffix function.
 *
 * Revision 1.3  1995/01/26  15:36:37  daveb
 * Made suffix check for parent arcs of the form "...." and "..   ".
 *
 * Revision 1.2  1995/01/25  19:37:22  daveb
 * Modified find_root to ignore trailing separator on server roots.
 *
 * Revision 1.1  1995/01/25  17:12:37  daveb
 * new unit
 * The OS.Pathname structure from the basis.
 *
 *)


require "../basis/path";
require "../utils/lists";
require "^.basis.__list";
require "^.basis.__string";

functor Win_ntPath (
  structure Lists: LISTS
): PATH =
struct
  datatype path_root = REL | ABS of string

  exception Path

  val parent = ".."
  val current = "."

  (* local *) val separator = #"\\"

  (* local *) val ordsep = ord separator
  (* local *) val ordcolon = ord #":"
  (* local *) val orddot = ord #"."

  (* forall is a local function that returns true if p holds for every
     character in s. *)
  fun forall (p, s) =
    let
      fun scan ~1 = true
      |   scan i =
        p (ord(String.sub(s, i))) andalso scan (i-1)
    in
      scan (size s - 1)
    end

  fun isLetter i =
    (ord #"a" <= i andalso i <= ord #"z")
    orelse (ord #"A" <= i andalso i <= ord #"Z")

  val specials = "\"\\*/:<>?|"
  (* legal chars include $%'-_@@{}~`!#(),+=[]; *) (* \" *)

  fun isValidChar i =
    ord #" " <= i andalso i < 127 andalso
    forall (fn x => x <> i, specials)

  fun isValidArc s =
    s = current orelse s = parent orelse s = ""
    orelse
      (size s < 255 andalso
       forall (isValidChar, s) andalso
       MLWorks.String.ordof (s, size s - 1) <> ord #" ")

  (* scanr is a local function that finds the first occurrence of ch in s,
     scanning from right to left. *)
  fun scanr (s, ch, ~1) =
    NONE
  |   scanr (s, ch, n) =
    if ch = MLWorks.String.ordof (s, n) then
      SOME n
    else
      scanr (s, ch, n-1)

  (* scanl is a local function that finds the first occurrence of ch in s,
     scanning from left to right. *)
  fun scanl (s, ch, n) =
    let
      val len = size s
    in
      if n = len then
        NONE
      else if ch = MLWorks.String.ordof (s, n) then
        SOME n
      else
        scanl (s, ch, n+1)
    end

  (* Roots in NT are complicated.  It's easiest to have separate functions
     for the main two cases. *)
  fun isDriveRoot s = 
    (((size s = 3 andalso MLWorks.String.ordof (s, 2) = ordsep) orelse size s = 2)
     andalso MLWorks.String.ordof (s, 1) = ordcolon
     andalso isLetter (MLWorks.String.ordof (s, 0)))

  fun isServerRoot s =
    let
      fun check_rest () =
	let
	  val (server_ok, n) =
	    case scanl (s, ordsep, 2)
	    of SOME n =>
	      (n > 3 andalso isValidArc (substring (s, 2, n - 2)),
	       n)
	    | _ => (false, 0)
	in
	    server_ok andalso
	    (size s = n + 1 orelse
	     case scanl (s, ordsep, n + 1)
	     of SOME n' =>
	       size s = n' + 1 andalso
	       isValidArc (substring (s, n + 1, n' - n - 2))
	     | _ => 
	       isValidArc (substring (s, n + 1, size s - n - 2)))
	end
    in
      size s > 3
      andalso MLWorks.String.ordof (s, 0) = ordsep
      andalso MLWorks.String.ordof (s, 1) = ordsep
      andalso check_rest ()
    end

  fun isValidRoot "\\" = true
  |   isValidRoot s =
    isDriveRoot s orelse isServerRoot s

  (* find_last is a local function that returns the last arc of s, together
     with the index of the separator. *)
  fun find_last s =
    let
      fun find' ~1 =
        NONE
      |   find' n =
        if MLWorks.String.ordof (s, n) = ordsep orelse
           MLWorks.String.ordof (s, n) = ordcolon then
          SOME n
        else
          find' (n-1)
    in
      case find' (size s - 1)
      of SOME n =>
        (substring (s, n + 1, size s - n - 1), n)
      | NONE => (s, ~1)
    end

  fun find_root s =
    if size s < 2 then
      if s = "\\" then
	(ABS "\\", 0)
      else
        (REL, ~1)
    else if MLWorks.String.ordof (s, 1) = ordcolon andalso isLetter (MLWorks.String.ord s) then
      if size s > 2 andalso MLWorks.String.ordof (s, 2) = ordsep then
        (ABS (substring (s, 0, 3)), 2)
      else
        (ABS (substring (s, 0, 2)), 1)
    else if MLWorks.String.ordof (s, 0) = ordsep then
      if MLWorks.String.ordof (s, 1) <> ordsep then
	(ABS "\\", 0)
      else
        case scanl (s, ordsep, 2)
        of NONE =>
          raise Path
        |  SOME n =>
	  if n = size s - 1 then
	    (ABS s, n)
	  else
	    (case scanl (s, ordsep, n+1)
	     of NONE =>
	       (ABS s, size s - 1)
	     |  SOME n =>
	       (ABS (substring (s, 0, n)), n))
    else
      (REL, ~1)

  fun isAbsolute s =
    case find_root s
    of (ABS _, _) => true
    |  (REL, _) => false

  fun isRelative s = not (isAbsolute s)

  fun explodePath s =
    let
      val (root, root_pos) = find_root s

      fun scan_arcs (l, n) =
        case scanr (s, ordsep, n)
        of SOME n' =>
	  if n' <= root_pos then
	    substring (s, root_pos + 1, n - root_pos) :: l
	  else if n' = 0 then
	    substring (s, 0, n) :: l
	  else
	    scan_arcs
	      (substring (s, n' + 1, n - n') :: l, n' - 1)
        |  NONE => 
	  if root_pos = ~1 then
            substring (s, 0, n + 1) :: l
	  else
            substring (s, root_pos + 1, n - root_pos) :: l

      val arcs =
	if root_pos = size s - 1 then
	  []
	else
          scan_arcs ([], size s - 1)
    in
      {root = root, arcs = arcs}
    end

  fun isValidPath s =
    let val {arcs, ...} = explodePath s
    in List.all isValidArc arcs
    end
    handle Path => false

  val root = #1 o find_root

  local
    (* join concatenates two paths, inserting a separator if necessary. *)
    fun join ("", s2) = s2
    |   join (s1, s2) =
      (* Assumes that s2 is relative *)
      if MLWorks.String.ordof (s1, size s1 - 1) = ordsep
	 orelse MLWorks.String.ordof (s1, size s1 - 1) = ordcolon then
	s1 ^ s2
      else 
	s1 ^ (str separator) ^ s2
  in
    fun concatPath (s1, s2) =
      if isRelative s2 then
        join (s1, s2)
      else
        raise Path

    fun mkAbsolute (s1, s2) =
      if isAbsolute s2 then
        if isAbsolute s1 then
	  s1
        else
	  join (s2, s1)
      else
        raise Path

    fun addLast {dir, last} = join (dir, last)

    fun implodePath {root, arcs} =
      let
        val first =
          case root
          of REL => ""
          |  ABS s => s

        fun separate_arcs [] = []
        |   separate_arcs [arc] = [arc]
        |   separate_arcs (arc::arcs) =
	  arc :: (str separator) :: separate_arcs arcs
      in
      case join (first, concat (separate_arcs arcs))
      of "" => current
      |  s => s
      end
  end

  fun mkCanonical s =
    let
      val {root, arcs} = explodePath s

      (* canon takes a list of arcs in reverse order, a count of the parent
	 arcs encountered and yet to be discharged, and a result list. *)
      fun canon ([], 0, result) = result
      |   canon ([], n, result) =
	(* n > 0 => need parent arcs at the beginning, unless the path is
	   absolute *)
	(case root
	 of REL => canon ([], n-1, parent :: result)
	 |  ABS _ => result)
      |   canon ("" :: arcs, level, result) =
	(* ignore empty arcs *)
	canon (arcs, level, result)
      |   canon ("." :: arcs, level, result) =
	(* ignore current arcs *)
	canon (arcs, level, result)
      |   canon (".." :: arcs, level, result) =
	(* parent arc => increase count *)
	canon (arcs, level + 1, result)
      |   canon (arc :: arcs, 0, result) =
	(* a real arc => add to result, with separator *)
	canon (arcs, 0, arc :: result)
      |   canon (_ :: arcs, n, result) =
	(* n > 0 => this arc is overridden by a parent arc *)
	canon (arcs, n-1, result)

      (* NT ignores trailing spaces and dots. *)
      fun skip_trails s =
	let
	  fun loop ~1 = ~1
	  |   loop i =
	    if MLWorks.String.ordof (s, i) = ord #" " then
	      loop (i - 1)
	    else if MLWorks.String.ordof (s, i) = orddot then
	      if i = 0 then
		i
	      else if i = 1 andalso MLWorks.String.ord s = orddot then
		i
	      else
		loop (i - 1)
	    else
	      i

	  val endpos = size s - 1

	  val index = loop endpos
	in
	  if index = endpos then
	    s
	  else
	    substring (s, 0, index + 1)
	end

      val arcs' = map skip_trails arcs

      val canon_list = canon (rev arcs', 0, [])
    in
      implodePath {root = root, arcs = canon_list}
    end

  fun getParent s =
    case explodePath s
    of {root=REL, arcs=[arc]} => raise Path
    |  {root, arcs} =>
      let
        fun prune [] = raise Path
          | prune [x] = []
          | prune (x::r) = x::(prune r)
      in
        implodePath {root=root, arcs=prune arcs}
      end

  local
    (* diff finds the relative path from a directory to another file. *)
    fun diff (s1, s2) =
      (* s1 and s2 are both absolute.  s2 is a directory. *)
      let
	val canon1 = mkCanonical s1
	val canon2 = mkCanonical s2

	val {arcs = arcs1, ...} = explodePath canon1
	val {arcs = arcs2, ...} = explodePath canon2

	fun strip_common_prefix (l, []:string list) = (l, [])
	|   strip_common_prefix ([], l) = ([], l)
	|   strip_common_prefix (l1 as h1::t1, l2 as h2::t2) =
	  if h1 = h2 then
	    strip_common_prefix (t1, t2)
	  else
	    (l1, l2)

	val (arcs1', arcs2') = strip_common_prefix (arcs1, arcs2)

	fun mkRel ([], result) = result
	|   mkRel (_::t, result) = mkRel (t, parent :: result)

	val arcs = mkRel (arcs1', arcs2')
      in
	implodePath {root = REL, arcs = arcs}
      end

    fun compare_roots (s1, s2) =
      let
	fun loop ~1 = true
	|   loop i =
	  let
	    val o1 = MLWorks.String.ordof (s1, i)
	    val o2 = MLWorks.String.ordof (s2, i)
	  in
	    (* This should use the Ctype functions, but we haven't written
	       them yet. *)
	    if o1 = o2 orelse
	       (ord #"A" <= o1 andalso o1 <= ord #"Z" andalso o1 + 32 = o2) orelse
	       (ord #"A" <= o2 andalso o2 <= ord #"Z" andalso o2 + 32 = o1) then
	      loop (i-1)
	    else
	      false
	  end
      in
	size s1 = size s2 andalso loop (size s1 - 1)
      end
  in
    fun mkRelative (s1, s2) =
      case (root s1, root s2)
      of (REL, ABS _) => s1
      |  (ABS root1, ABS root2) =>
	if compare_roots (root1, root2) then
	  diff (s2, s1)
	else
	  raise Path
      |  (_, REL) => raise Path
  end

  fun splitLast s =
    let
      val (root, root_pos) = find_root s

      val (last, n1) = find_last s

      fun upto ~1 = ""
      |   upto n = substring (s, 0, n)
    in
      case root
      of ABS r =>
        if n1 < root_pos then
          {dir = s, last = ""}
        else if n1 = root_pos then
          {dir = r, last = last}
	else
	  {dir = upto n1, last = last}
      |  REL => 
	  {dir = upto n1, last = last}
    end
    
  val dir = (#dir o splitLast)
  val last = (#last o splitLast)

  datatype path_ext = NOEXT | EXT of string

  fun find_ext s =
    case scanr (s, orddot, size s - 1)
    of SOME n =>
	if n = size s - 1 then
	  (* File names ending in a . have no extension. *)
	  (NOEXT, size s)
        else
          let
            (* Check that the . occurs after the final separator. *)
            val ok1 =
              case scanr (s, ordsep, size s - 1) of
		SOME n' => n' < n
              | NONE => true
            val ok2 =
              case scanr (s, ord #"/", size s - 1) of
		SOME n' => n' < n
              | NONE => true
          in
            if ok1 andalso ok2 then
              (EXT (substring (s, n + 1, size s - n - 1)), n)
            else 
              (NOEXT, size s)
          end
     |  NONE => (NOEXT, size s)

  fun splitExt s =
    let
      val (ext, n2) = find_ext s

      val name = substring (s, 0, n2)
    in
      {name = name, ext = ext}
    end

  val name = (#name o splitExt)
  val ext = #1 o find_ext (* #ext o splitPath *)

  fun addExt {name, ext=NOEXT} = name
  |   addExt {name, ext=EXT ext} = name ^ "." ^ ext
end;
@


1.15.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a38 3
 * Revision 1.15  1996/11/06  16:37:56  jont
 * Remove references to Old so basis can be free of it
 *
@


1.15.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a38 3
 * Revision 1.15  1996/11/06  16:37:56  jont
 * Remove references to Old so basis can be free of it
 *
@


1.15.5.1
log
@branched from 1.15
@
text
@a38 3
 * Revision 1.15  1996/11/06  16:37:56  jont
 * Remove references to Old so basis can be free of it
 *
@


1.15.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a38 3
 * Revision 1.15.5.1  1997/05/12  10:54:03  hope
 * branched from 1.15
 *
@


1.15.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a38 3
 * Revision 1.15.5.1  1997/05/12  10:54:03  hope
 * branched from 1.15
 *
@


1.15.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a38 3
 * Revision 1.15.5.1  1997/05/12  10:54:03  hope
 * branched from 1.15
 *
@


1.15.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a38 3
 * Revision 1.15.5.1.1.1  1997/07/28  18:36:58  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.15.4.1
log
@branched from 1.15
@
text
@a38 3
 * Revision 1.15  1996/11/06  16:37:56  jont
 * Remove references to Old so basis can be free of it
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a38 3
 * Revision 1.15  1996/11/06  16:37:56  jont
 * Remove references to Old so basis can be free of it
 *
@


1.15.3.1.1.1
log
@branched from 1.15.3.1
@
text
@a38 3
 * Revision 1.15.3.1  1996/12/17  18:20:25  hope
 * branched from 1.15
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a38 3
 * Revision 1.15  1996/11/06  16:37:56  jont
 * Remove references to Old so basis can be free of it
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a38 3
 * Revision 1.15  1996/11/06  16:37:56  jont
 * Remove references to Old so basis can be free of it
 *
@


1.15.1.1.1.1
log
@branched from 1.15.1.1
@
text
@a38 3
 * Revision 1.15.1.1  1996/11/14  13:24:22  hope
 * branched from 1.15
 *
@


1.14
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d39 4
a93 1
require "^.basis.__old";
d230 1
a230 1
    else if MLWorks.String.ordof (s, 1) = ordcolon andalso isLetter (Old.ord s) then
d383 1
a383 1
	      else if i = 1 andalso Old.ord s = orddot then
@


1.13
log
@[Bug #1614]
removing toplevel String.
@
text
@d39 4
d92 1
d117 1
a117 1
        p (MLWorks.Internal.Value.unsafe_string_sub (s, i)) andalso scan (i-1)
@


1.12
log
@Replace OS_PATH with PATH since this definition is not up to date
wrt revised basis and is in the process of being replaced by _os_path.
@
text
@d39 4
d86 2
d100 1
a100 1
  (* local *) val separator = "\\"
d102 3
a104 3
  (* local *) val ordsep = String.ord separator
  (* local *) val ordcolon = String.ord ":"
  (* local *) val orddot = String.ord "."
d112 1
a112 1
        p (String.ordof (s, i)) andalso scan (i-1)
d118 2
a119 2
    (String.ord "a" <= i andalso i <= String.ord "z")
    orelse (String.ord "A" <= i andalso i <= String.ord "Z")
d122 1
a122 1
  (* legal chars include $%'-_@@{}~`!#(),+=[]; *)
d125 1
a125 1
    String.ord " " <= i andalso i < 127 andalso
d133 1
a133 1
       String.ordof (s, size s - 1) <> String.ord " ")
d138 1
a138 1
    MLWorks.Option.NONE
d141 1
a141 1
      MLWorks.Option.SOME n
d151 2
a152 2
      if n = size s then
        MLWorks.Option.NONE
d154 1
a154 1
        MLWorks.Option.SOME n
d162 3
a164 3
    (((size s = 3 andalso String.ordof (s, 2) = ordsep) orelse size s = 2)
     andalso String.ordof (s, 1) = ordcolon
     andalso isLetter (String.ordof (s, 0)))
d172 2
a173 2
	    of MLWorks.Option.SOME n =>
	      (n > 3 andalso isValidArc (String.substring (s, 2, n - 2)),
d180 1
a180 1
	     of MLWorks.Option.SOME n' =>
d182 1
a182 1
	       isValidArc (String.substring (s, n + 1, n' - n - 2))
d184 1
a184 1
	       isValidArc (String.substring (s, n + 1, size s - n - 2)))
d188 2
a189 2
      andalso String.ordof (s, 0) = ordsep
      andalso String.ordof (s, 1) = ordsep
d202 1
a202 1
        MLWorks.Option.NONE
d206 1
a206 1
          MLWorks.Option.SOME n
d211 3
a213 3
      of MLWorks.Option.SOME n =>
        (MLWorks.String.substring (s, n + 1, size s - n - 1), n)
      | MLWorks.Option.NONE => (s, ~1)
d222 3
a224 3
    else if String.ordof (s, 1) = ordcolon andalso isLetter (String.ord s) then
      if size s > 2 andalso String.ordof (s, 2) = ordsep then
        (ABS (String.substring (s, 0, 3)), 2)
d226 3
a228 3
        (ABS (String.substring (s, 0, 2)), 1)
    else if String.ordof (s, 0) = ordsep then
      if String.ordof (s, 1) <> ordsep then
d232 1
a232 1
        of MLWorks.Option.NONE =>
d234 1
a234 1
        |  MLWorks.Option.SOME n =>
d239 1
a239 1
	     of MLWorks.Option.NONE =>
d241 2
a242 2
	     |  MLWorks.Option.SOME n =>
	       (ABS (String.substring (s, 0, n)), n))
d259 1
a259 1
        of MLWorks.Option.SOME n' =>
d261 1
a261 1
	    MLWorks.String.substring (s, root_pos + 1, n - root_pos) :: l
d263 1
a263 1
	    MLWorks.String.substring (s, 0, n) :: l
d266 2
a267 2
	      (MLWorks.String.substring (s, n' + 1, n - n') :: l, n' - 1)
        |  MLWorks.Option.NONE => 
d269 1
a269 1
            MLWorks.String.substring (s, 0, n + 1) :: l
d271 1
a271 1
            MLWorks.String.substring (s, root_pos + 1, n - root_pos) :: l
d284 1
a284 1
    in Lists.forall isValidArc arcs
d299 1
a299 1
	s1 ^ separator ^ s2
d328 1
a328 1
	  arc :: separator :: separate_arcs arcs
d330 1
a330 1
      case join (first, String.implode (separate_arcs arcs))
d370 1
a370 1
	    if String.ordof (s, i) = String.ord " " then
d372 1
a372 1
	    else if String.ordof (s, i) = orddot then
d375 1
a375 1
	      else if i = 1 andalso String.ord s = orddot then
d389 1
a389 1
	    String.substring (s, 0, index + 1)
d445 2
a446 2
	    val o1 = String.ordof (s1, i)
	    val o2 = String.ordof (s2, i)
d451 2
a452 2
	       (String.ord "A" <= o1 andalso o1 <= String.ord "Z" andalso o1 + 32 = o2) orelse
	       (String.ord "A" <= o2 andalso o2 <= String.ord "Z" andalso o2 + 32 = o1) then
d479 1
a479 1
      |   upto n = MLWorks.String.substring (s, 0, n)
d500 1
a500 1
    of MLWorks.Option.SOME n =>
d509 2
a510 2
		MLWorks.Option.SOME n' => n' < n
              | MLWorks.Option.NONE => true
d512 3
a514 3
              case scanr (s, String.ord"/", size s - 1) of
		MLWorks.Option.SOME n' => n' < n
              | MLWorks.Option.NONE => true
d517 1
a517 1
              (EXT (MLWorks.String.substring (s, n + 1, size s - n - 1)), n)
d521 1
a521 1
     |  MLWorks.Option.NONE => (NOEXT, size s)
d527 1
a527 1
      val name = MLWorks.String.substring (s, 0, n2)
@


1.12.3.1
log
@branched from 1.12
@
text
@a38 4
 * Revision 1.12  1996/05/21  12:39:26  stephenb
 * Replace OS_PATH with PATH since this definition is not up to date
 * wrt revised basis and is in the process of being replaced by _os_path.
 *
@


1.12.2.1
log
@branched from 1.12
@
text
@a38 4
 * Revision 1.12  1996/05/21  12:39:26  stephenb
 * Replace OS_PATH with PATH since this definition is not up to date
 * wrt revised basis and is in the process of being replaced by _os_path.
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a38 4
 * Revision 1.12  1996/05/21  12:39:26  stephenb
 * Replace OS_PATH with PATH since this definition is not up to date
 * wrt revised basis and is in the process of being replaced by _os_path.
 *
@


1.11
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d39 6
d85 1
a85 1
): OS_PATH =
@


1.10
log
@initbasis moves to basis
@
text
@d39 3
d90 3
a92 3
  (* local *) val ordsep = ord separator
  (* local *) val ordcolon = ord ":"
  (* local *) val orddot = ord "."
d106 2
a107 2
    (ord "a" <= i andalso i <= ord "z")
    orelse (ord "A" <= i andalso i <= ord "Z")
d113 1
a113 1
    ord " " <= i andalso i < 127 andalso
d121 1
a121 1
       String.ordof (s, size s - 1) <> ord " ")
d210 1
a210 1
    else if String.ordof (s, 1) = ordcolon andalso isLetter (ord s) then
d318 1
a318 1
      case join (first, implode (separate_arcs arcs))
d358 1
a358 1
	    if String.ordof (s, i) = ord " " then
d363 1
a363 1
	      else if i = 1 andalso ord s = orddot then
d439 2
a440 2
	       (ord "A" <= o1 andalso o1 <= ord "Z" andalso o1 + 32 = o2) orelse
	       (ord "A" <= o2 andalso o2 <= ord "Z" andalso o2 + 32 = o1) then
d500 1
a500 1
              case scanr (s, ord"/", size s - 1) of
@


1.9
log
@PATH -> OS_PATH
@
text
@d39 3
d51 16
a66 17
# Revision 1.5  1995/03/06  20:17:47  daveb
# Removed the "last" component from exploded paths, and replaced
# splitPath with splitExt and splitLast.
#
# Revision 1.4  1995/02/28  14:28:22  daveb
# Removed suffix function.
#
# Revision 1.3  1995/01/26  15:36:37  daveb
# Made suffix check for parent arcs of the form "...." and "..   ".
#
# Revision 1.2  1995/01/25  19:37:22  daveb
# Modified find_root to ignore trailing separator on server roots.
#
# Revision 1.1  1995/01/25  17:12:37  daveb
# new unit
# The OS.Pathname structure from the basis.
#
d71 1
a71 1
require "../initbasis/path";
@


1.8
log
@Allow / to be parsed as a directory separator during splitExt
@
text
@d39 3
d74 1
a74 1
): PATH =
@


1.7
log
@filesys and path moved from utils to initbasis.
@
text
@d39 3
d487 8
a494 4
            val ok =
              case scanr (s, ordsep, size s - 1)
              of MLWorks.Option.SOME n' => n' < n
              |  MLWorks.Option.NONE => true
d496 1
a496 1
            if ok then
@


1.6
log
@Removed trailing separators from dir components of results.
@
text
@d39 3
d63 1
a63 1
require "../utils/path";
@


1.5
log
@Removed the "last" component from exploded paths, and replaced
splitPath with splitExt and splitLast.
@
text
@d39 4
d452 2
a453 6
      val no_last =
        case root
        of ABS _ =>
          n1 < root_pos
	|  REL => 
	  false
d455 10
a464 8
      if no_last then
        {dir = s, last = ""}
      else
	let
	  val dir = MLWorks.String.substring (s, 0, n1 + 1)
        in
          {dir = dir, last = last}
        end
@


1.4
log
@Removed suffix function.
@
text
@d39 3
a226 2
      val (last, n) = find_last s

d244 4
a247 1
        if n <= root_pos then [] else scan_arcs ([], n - 1)
d249 1
a249 4
      if n < root_pos then
        {root = root, arcs = arcs, last = ""}
      else
        {root = root, arcs = arcs, last = last}
d260 34
a293 1
  val last = #1 o find_last (* #last o explodePath *)
d295 10
a304 1
  datatype path_ext = NOEXT | EXT of string
d308 1
a308 6
      val {root, arcs, last} = explodePath s

      val first =
        case root
        of REL => ""
        |  ABS s => s
d317 1
a317 1
	 of REL => canon ([], n-1, "..\\" :: result)
d330 1
a330 1
	canon (arcs, 0, arc :: separator :: result)
d364 1
a364 6
      val canon_list =
        case skip_trails last
        of ".." => canon (rev arcs', 1, [])
        |  "." => canon (rev arcs', 0, [""])
        |  s => canon (rev arcs', 0, [s])

d366 1
a366 3
      case implode (first :: canon_list)
      of "" => "."
      | s => s
d369 4
a372 30
  local
    (* join concatenates two paths, inserting a separator if necessary. *)
    fun join ("", s2) = s2
    |   join (s1, s2) =
      (* Assumes that s2 is relative *)
      if MLWorks.String.ordof (s1, size s1 - 1) = ordsep
	 orelse MLWorks.String.ordof (s1, size s1 - 1) = ordcolon then
	s1 ^ s2
      else 
	s1 ^ separator ^ s2
  in
    fun concatPath (s1, s2) =
      if isRelative s2 then
        join (s1, s2)
      else
        raise Path

    fun mkAbsolute (s1, s2) =
      if isAbsolute s2 then
        if isAbsolute s1 then
	  s1
        else
	  join (s2, s1)
      else
        raise Path

    fun makePath {dir, name, ext = NOEXT} = join (dir, name)
    |   makePath {dir, name, ext = EXT ext} = join (dir, name) ^ "." ^ ext

    fun implodePath {root, arcs, last} =
d374 3
a376 8
        val first =
          case root
          of REL => ""
          |  ABS s => s

        fun separate_arcs ([], last) = last
        |   separate_arcs (arc::arcs, last) =
	  arc :: separator :: separate_arcs (arcs, last)
d378 1
a378 1
        join (first, implode (separate_arcs (arcs, [last])))
a379 1
  end
a380 12
  fun getParent s = (case (explodePath s)
       of {root, arcs, last=""} => let
            fun prune [] = raise Path
              | prune [x] = []
              | prune (x::r) = x::(prune r)
            in
              implodePath {root=root, arcs=prune arcs, last=""}
            end
        | {root=REL, arcs=[], last} => raise Path
        | {root, arcs, last} => implodePath {root=root, arcs=arcs, last=""}
      (* end case *))

a381 6
    fun strip_separators (s, i) =
      if MLWorks.String.ordof (s, i) = ordsep then
	strip_separators (s, i+1)
      else
	MLWorks.String.substring (s, i, size s - i)

d389 2
a390 2
	val {arcs = arcs1, last = last1, ...} = explodePath canon1
	val {arcs = arcs2, last = last2, ...} = explodePath canon2
d402 2
a403 6
	fun mkRel ([], result) =
	  if last1 = "" then
	    result
	  else
	    ".." :: result
	|   mkRel (_::t, result) = mkRel (t, ".." :: result)
d405 1
a405 10
	val arcs =
	  case (arcs1', arcs2')
	  of ([], []) => mkRel ([], [])
	  |  ([], l as h::t) =>
	    if last1 = h then
	      (* catches cases like diff ("\bar", "\bar\foo"). *)
	      t
	    else
	      mkRel ([], l)
	  |  _ => mkRel (arcs1', arcs2')
d407 1
a407 1
	implodePath {root = REL, arcs = arcs, last = last2}
d442 28
d491 1
a491 1
  fun splitPath s =
d493 1
a493 1
      val (root, root_pos) = find_root s
d495 1
a495 8
      val (last, n1) = find_last s

      val no_last =
        case root
        of ABS _ =>
          n1 < root_pos
	|  REL => 
	  false
d497 2
a498 5
      if no_last then
        {dir = s, name = "", ext = NOEXT}
      else
	let
          val (ext, n2) = find_ext last
d500 1
a500 10
          val name = MLWorks.String.substring (last, 0, n2)
	 
	  val dir = MLWorks.String.substring (s, 0, n1 + 1)
        in
          {dir = dir, name = name, ext = ext}
        end
    end
    
  val dir = (#dir o splitPath)
  val name = (#name o splitPath)
d503 2
a504 5
  fun base s =
    case find_ext s of
    (NOEXT, _) => s |
    (EXT _, n) => MLWorks.String.substring (s, 0, n)

@


1.3
log
@Made suffix check for parent arcs of the form "...." and "..   ".
@
text
@d39 3
a472 105

  fun suffix (s1, s2) =
    (* suffix tries a character by character comparison of the two paths.
       It then checks whether the suffix of the longer string contains
       any parent arcs.  If it doesn't, the result of the quick check can
       be trusted.  Otherwise it canonicalises the two strings and checks
       again. *)
    let
      val len1 = size s1
      val len2 = size s2

      fun skip_separators n =
        let
          fun skip i =
            if i = len1 then
              i
            else if MLWorks.String.ordof (s1, i) = ordsep then
              skip (i + 1)
            else
              i
        in
          skip n
        end

      (* canonical (s, i) checks that substring (s, i, size s - i) is
         canonical, i.e. that it contains no occurrences of the parent arc.
         This tells us whether we can trust the result of quick_check ().
	 The auxiliary function skip_trails returns true if the remainder of
	 an arc consists entirely of trailing dots and spaces. *)
      fun canonical (s, i, len) =
        if i = len then
          true
        else if String.ordof (s, i) = ordsep then
          if i+2 >= len then
            true
          else if String.ordof (s, i + 1) = orddot andalso
                  String.ordof (s, i + 2) = orddot then
	    skip_trails (s, i+3, len)
          else
            canonical (s, i+3, len)
        else
          canonical (s, i+1, len)

      and skip_trails (s, i, len) =
        if i = len then
          false
        else if String.ordof (s, i) = orddot orelse
		String.ordof (s, i) = ord " " then
	  skip_trails (s, i+1, len)
	else if String.ordof (s, i) = ordsep then
	  false
	else
	  canonical (s, i, len)
	
      fun full_check () =
        let
          val canon1 = mkCanonical s1
          val canon2 = mkCanonical s2
          val len1 = size canon1
          val len2 = size canon2

          fun check' i =
            if i = len2 then
              if i = len1 then
                MLWorks.Option.SOME i
              else if (String.ordof (canon1, i) = ordsep orelse
                       String.ordof (canon2, i - 1) = ordsep) then
                MLWorks.Option.SOME (skip_separators i)
              else
                MLWorks.Option.NONE
            else if i = len1 then
              MLWorks.Option.NONE
            else if String.ordof (canon1, i) = String.ordof (canon2, i) then
              check' (i + 1)
            else
              MLWorks.Option.NONE
        in
          check' 0
        end

      fun quick_check i =
        if i = len2 then
          if i = len1 then
            MLWorks.Option.SOME i
          else if (String.ordof (s1, i) = ordsep orelse
                   String.ordof (s1, i - 1) = ordsep) andalso
                  canonical (s1, i - 1, len1) then
            MLWorks.Option.SOME (skip_separators i)
          else
            full_check ()
        else if i = len1 then
          if canonical (s2, i, len2) then
            MLWorks.Option.NONE
          else
            full_check ()
        else if String.ordof (s1, i) = String.ordof (s2, i) then
          quick_check (i + 1)
        else
          full_check ()
    in
      if isRelative s1 orelse isRelative s2 then
        raise Path
      else
        quick_check 0
    end
@


1.2
log
@Modified find_root to ignore trailing separator on server roots.
@
text
@d39 3
d496 3
a498 1
         This tells us whether we can trust the result of quick_check (). *)
d506 2
a507 3
                  String.ordof (s, i + 2) = orddot andalso
                  (i+3 = len orelse String.ordof (s, i + 3) = ordsep) then
            false
d509 1
a509 1
            canonical (s, i + 3, len)
d511 1
a511 1
          canonical (s, i + 1, len)
d513 11
@


1.1
log
@new unit
The OS.Pathname structure from the basis.
@
text
@d38 5
a42 1
 *  $Log$
d203 1
a203 1
	       (ABS (String.substring (s, 0, n + 1)), n))
@
