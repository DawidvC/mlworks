head	1.10;
access;
symbols
	MLW_daveb_inline_1_4_99:1.10.1
	MLWorks_21c0_1999_03_25:1.10
	MLWorks_20c1_1998_08_20:1.9
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.8
	MLWorks_20b0_1998_04_07:1.8
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.7
	MLWorks_20m1_1997_10_23:1.7
	MLWorks_11r1:1.7.1.1.1.1.1
	MLWorks_workspace_97:1.7.3
	MLWorks_dt_wizard:1.7.2
	MLWorks_11c0_1997_09_09:1.7.1.1.1.1
	MLWorks_10r3:1.7.1.1.3
	MLWorks_10r2_551:1.7.1.1.2
	MLWorks_11:1.7.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.7.1.1
	MLWorks_20m0_1997_06_20:1.7
	MLWorks_1_0_r2c2_1997_06_14:1.7.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.7.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.7.1
	MLWorks_BugFix_1997_04_24:1.7
	MLWorks_1_0_r2_Win32_1997_04_11:1.7
	MLWorks_1_0_r2_Unix_1997_04_04:1.7
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.3.1.1
	MLWorks_gui_1996_12_18:1.5.4
	MLWorks_1_0_Win32_1996_12_17:1.5.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.1.1
	MLWorks_1_0_Irix_1996_11_28:1.5.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.2
	MLWorks_1_0_Unix_1996_11_14:1.5.1
	MLWorks_Open_Beta2_1996_10_11:1.3.3
	MLWorks_License_dev:1.3.2
	MLWorks_1_open_beta_1996_09_13:1.3.1
	MLWorks_Open_Beta_1996_08_22:1.3
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ *  @;


1.10
date	99.03.17.10.55.48;	author daveb;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	98.08.13.10.17.38;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	98.02.20.10.55.50;	author mitchell;	state Exp;
branches;
next	1.7;

1.7
date	97.03.31.12.16.50;	author johnh;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1;
next	1.6;

1.6
date	97.03.04.14.57.12;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	96.10.30.20.28.46;	author io;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1;
next	1.4;

1.4
date	96.10.21.15.24.06;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.06.19.13.33.36;	author andreww;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1;
next	1.2;

1.2
date	96.06.19.12.22.12;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	96.05.21.14.35.13;	author stephenb;	state Exp;
branches;
next	;

1.3.1.1
date	96.09.13.11.43.57;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.10.07.16.37.09;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.10.17.11.56.08;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.11.14.13.24.29;	author hope;	state Exp;
branches
	1.5.1.1.1.1;
next	;

1.5.1.1.1.1
date	96.11.28.15.35.23;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.11.22.18.41.36;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.12.17.18.20.33;	author hope;	state Exp;
branches
	1.5.3.1.1.1;
next	;

1.5.3.1.1.1
date	97.02.24.12.15.11;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.12.18.10.16.07;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	97.05.12.10.54.11;	author hope;	state Exp;
branches
	1.7.1.1.1.1
	1.7.1.1.2.1
	1.7.1.1.3.1;
next	;

1.7.1.1.1.1
date	97.07.28.18.36.43;	author daveb;	state Exp;
branches
	1.7.1.1.1.1.1.1;
next	;

1.7.1.1.1.1.1.1
date	97.10.07.12.01.52;	author jkbrook;	state Exp;
branches;
next	;

1.7.1.1.2.1
date	97.09.08.17.28.56;	author daveb;	state Exp;
branches;
next	;

1.7.1.1.3.1
date	97.09.09.14.26.49;	author daveb;	state Exp;
branches;
next	;

1.7.2.1
date	97.09.10.19.45.06;	author brucem;	state Exp;
branches;
next	;

1.7.3.1
date	97.09.11.21.12.17;	author daveb;	state Exp;
branches;
next	;

1.10.1.1
date	99.04.01.18.10.21;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.10
log
@[Bug #30092]
Added InvalidArc exception.
@
text
@(* Copyright 1996 The Harlequin Group Limited.  All rights reserved.
 *
 * Win32 OS.Path implementation.  This is just a shell of a definition
 * to satisfy the signature.  To be fleshed out ASAP.
 *
 * Revision Log
 * ------------
 *
 * $Log: __os_path.sml,v $
 *  Revision 1.9  1998/08/13  10:17:38  jont
 *  [Bug #30468]
 *  Change types of mkAbsolute and mkRelative to uses records with names fields
 *
 *  Revision 1.8  1998/02/20  10:55:50  mitchell
 *  [Bug #30337]
 *  Change OS.Path.concat to take a string list, instead of a pair of strings.
 *
 *  Revision 1.7  1997/03/31  12:16:50  johnh
 *  [Bug #1967]
 *  Changed mkCanonical to return lowercase paths.
 *
 *  Revision 1.6  1997/03/04  14:57:12  jont
 *  [Bug #1939]
 *  Add fromUnixPath and toUnixPath
 *
 *  Revision 1.5  1996/10/30  20:28:46  io
 *  [Bug #1614]
 *  removing toplevel String
 *
 *  Revision 1.4  1996/10/21  15:24:06  jont
 *  Remove references to basis.toplevel
 *
 *  Revision 1.3  1996/06/19  13:33:36  andreww
 *  Checking for empty argument to isDir.
 *
 *  Revision 1.1  1996/05/21  14:35:13  stephenb
 *  new unit
 *
 *)

require "^.basis.__list";
require "^.basis.__string";
require "^.basis.os_path";
require "^.basis.__char";

structure OSPath_ : OS_PATH =
  struct

    exception Path

    exception InvalidArc

    val dirSeparator = #"\\"

    val extSeparator = #"."

    val parentArc = ".."

    val currentArc = "."

    val volumeSeparator = #":"

    fun isVolumePrefix s = 
      size s >= 2 andalso 
      String.sub(s,1) = volumeSeparator andalso 
      Char.isAlpha (String.sub(s,0))
      
    fun validVolume {isAbs= isAbs, vol = vol} = 
      (vol = "") orelse
      (size vol = 2 andalso isVolumePrefix vol)
      
    fun invalidArc s = Char.contains s dirSeparator

    fun fromString "" = {isAbs=false, vol="", arcs=[]}
      | fromString s = 
      let
        val (vol, s) = 
          if isVolumePrefix s then
            (String.extract (s, 0, SOME 2), String.extract (s, 2, NONE))
          else
            ("", s)
      in
        {isAbs=
         size s > 0 andalso String.sub(s,0) = dirSeparator,
         vol=vol,
         arcs=
         case String.fields (fn c=> c=dirSeparator) s of
          ""::xs => xs
         | xs => xs
         }
      end

    val sep = String.str dirSeparator


    fun toString {isAbs, vol, arcs} = 
      if not (validVolume {isAbs=isAbs, vol=vol}) then
        raise Path
      else
        case arcs of
          [] => if isAbs then vol^sep else ""
        | (arc::arcs) =>
            let 
	      val _ =
                if invalidArc arc then
                  raise InvalidArc
                else
                  ()

              val initialPath = 
                if isAbs then 
                   concat [vol, sep, arc] 
                else if arc <> "" then 
                  arc
                else
                  raise Path

	      fun addArc (arc, path) =
		if invalidArc arc then
		  raise InvalidArc
		else
		  concat [path, sep, arc]
            in
              List.foldl addArc initialPath arcs
            end (* toString *)

    fun getVolume s = (* #vol (fromString s) *)
      if isVolumePrefix s then
        substring(s, 0, 2)
      else ""
        
    (* OSPath_.getParent "a:\\bcd\\efg\\hij" = "a:\\bcd\\efg"
     * OSPath_.getParent "a:\\" = "a:\\"
     * OSPath_.getParent "a:xyz\\abc" = "a:xyz"
     * OSPath_.getParent "a:xyz\\abc\\" = "a:xyz\\abc\\.."
     * OSPath_.getParent "xyz" = "."
     * OSPath_.getParent ".." = "..\\.."
     * OSPath_.getParent "." = ".."
     * OSPath_.getParent "a:." = "a:.."
     * OSPath_.getParent "" = ".."
     *)
    fun getParent s = 
      let
        val {isAbs, vol, arcs} = fromString s
        fun scan1 [] = parentArc
          | scan1 [""] = ""
          | scan1 ["."] = parentArc
          | scan1 [".."] = s^sep^parentArc
          | scan1 [x] = currentArc
          | scan1 [x, ""] = s^parentArc
          | scan1 ["", x] = ""
          | scan1 [x, y] = x
          | scan1 (x::xs) = List.foldl (fn (arc, path)=> path^sep^arc) 
                                       x (scan2 ([],xs))
        and scan2 (acc, []) = rev acc
          | scan2 (acc, ["."]) = rev (parentArc::acc)
          | scan2 (acc, [x, ""]) = rev (parentArc::x::acc)
          | scan2 (acc, [x, y]) = rev (x::acc)
          | scan2 (acc, x::xs) = scan2(x::acc, xs)
      in
        vol ^ (if isAbs then sep else "")^(scan1 arcs)
      end
        
    (* An auxiliary function which returns (dirLength, fileStart).
     * for a given (path, start, end, end).  
     *)
    fun splitDirFile' (s, xmin, n, e) = 
      let
        fun scan (n, e) = 
          if n < xmin then (xmin, xmin)
          else if String.sub (s, n) = dirSeparator then
            (if n = xmin then (n+1, n+1) 
             else
               (n, n+1))
          else
            scan (n-1, e)
      in
        scan (n, e)
      end
    
    fun splitDirFile s =
      let
        val l = size s
        val e = l - 1
        val xmin = if isVolumePrefix s then 2 else 0
        val (m, n) = splitDirFile' (s, xmin, l-1, l-1)
      in
        { dir =  substring (s, 0, m)
         , file = substring (s, n, l-n)
         }
      end

    fun joinDirFile {dir, file} = 
      let
        val xmin = if isVolumePrefix dir then 2 else 0
	val _ = if invalidArc file then raise InvalidArc else ()
      in
        if dir = "" then
	  file
        else if size dir > xmin then
          if String.sub(dir, size dir -1) = dirSeparator then
            dir ^ file
          else
            dir ^ sep ^ file
        else
          dir ^ file
      end

    fun dir s = 
      let
        val e = size s - 1
        val xmin = if isVolumePrefix s then 2 else 0
        val (m,_) = splitDirFile' (s, xmin, e, e)
      in
        substring(s, 0, m)
      end

    fun file s = 
      let
        val sz = size s
        val xmin = if isVolumePrefix s then 2 else 0
        val (_, n) = splitDirFile' (s, xmin, sz-1, sz-1)
      in
        substring (s, n, sz-n)
      end


    fun splitBaseExt' (s, xmin, n, e) =
      let
        fun scan (n, e) = 
          if n <= xmin then
            NONE
          else
            let
              val c = String.sub(s, n)
            in
              if c = extSeparator then
                if n = e  
                   orelse String.sub (s, n-1) = dirSeparator then
                  NONE
                else
                  SOME n
              else if c = dirSeparator then 
                NONE
              else
                scan (n-1, e)
            end
      in
        scan (n, e)
      end
    
    fun splitBaseExt s =
      let
        val e = size s - 1
        val xmin = if isVolumePrefix s then 2 else 0
      in
        case splitBaseExt' (s, xmin, e, e) of
          NONE => {base = s, ext = NONE}
        | SOME n => { base = substring (s, 0, n)
                     , ext =  SOME (substring (s, n+1, e-n))
                     }
      end

    fun joinBaseExt {base, ext = NONE} = base
      | joinBaseExt {base, ext = SOME ""} = base
      | joinBaseExt {base, ext = SOME ext} = base 
                                           ^ (String.str extSeparator) ^ ext

    fun base s = 
      let
        val e = size s - 1
        val xmin = if isVolumePrefix s then 2 else 0
      in
        case splitBaseExt' (s, xmin, e, e) of
          NONE => s
        | SOME n => substring (s, 0, n)
      end


    fun ext s = 
      let
        val e = size s - 1
        val xmin = if isVolumePrefix s then 2 else 0
      in
        case splitBaseExt' (s, xmin, e, e) of
          NONE => NONE
        | SOME n => SOME (substring (s, n+1, e-n))
      end


    fun mkCanonical s = 
      let
        val {isAbs, vol, arcs} = fromString s
        fun canon ([], 0, result) = result
        |   canon ([], n, result) =
          (* n > 0 => need parent arcs at the beginning, unless the path is
             absolute *)
          if isAbs
          then result
          else canon ([], n-1, parentArc :: result)
        |   canon ("" :: arcs, level, result) =  (* ignore empty arcs *)
          canon (arcs, level, result)
        |   canon ("." :: arcs, level, result) =
          canon (arcs, level, result)
        |   canon (".." :: arcs, level, result) =
          canon (arcs, level + 1, result)
        |   canon (arc :: arcs, 0, result) =
          canon (arcs, 0, arc :: result)
        |   canon (_ :: arcs, n, result) =
          (* n > 0 => this arc is overridden by a parent arc *)
          canon (arcs, n-1, result)

        val arcs' = canon (rev arcs, 0, [])
        val s' = toString {isAbs=isAbs, vol=vol, arcs=arcs'}

 	fun toLowerStr s = implode (map Char.toLower (explode s)) 
      in
        toLowerStr (if s' = "" then currentArc else s')
      end

(*
    fun mkCanonical s = 
      let
        val {isAbs, vol, arcs} = fromString s
        fun scan1 (level, []) =
          if isAbs andalso level >= 0 then [] 
          else
            raise Path
          | scan1 (level, ["."]) = "." :: scan1 (level,[])
          | scan1 (level, ".."::xs) = ".." :: scan2 (level-1, xs)
          | scan1 (level, ""::xs) = ""::scan3(level, xs)
          | scan1 xs = scan3 xs
        and scan2 (level, ".."::xs) = ".." :: scan2 (level-1, xs)
          | scan2 (level, xs) = scan3 (level, xs)
        and scan3 (level, []) = 
          if level >= 0 then []
          else 
            raise Path
          | scan3 (level, ("."::xs)) = scan3 (level,xs)
          | scan3 (level, (".."::xs)) = scan3 (level-1, xs)
          | scan3 (level, (""::xs)) = scan3
*)              
          

                     
    fun isCanonical s = 
      let
        val {isAbs, vol, arcs} = fromString s
        (* check for currentArc on its own *)
        fun scan1 ["."] = not isAbs
          | scan1 (".."::xs) = isAbs = false andalso scan2 xs
          | scan1 (""::xs) = scan3 xs
          | scan1 xs = scan3 xs
        (* grep initial segments of ".." *)
        and scan2 (".."::xs) = scan2 xs
          | scan2 xs = scan3 xs
        (* do the usual bit *)
        and scan3 [] = true
          | scan3 ("."::_) = false
          | scan3 (".."::_) = false
          | scan3 (""::_) = false
          | scan3 (_::xs) = scan3 xs
      in
        scan1 arcs
      end



    fun isAbsolute "" = false
      | isAbsolute s = 
      let
        val xmin = if isVolumePrefix s then 2 else 0
      in
        if size s - xmin <= 0 then
          false
        else
          String.sub(s, xmin) = dirSeparator
      end

    fun isRelative s = not (isAbsolute s)



    local
      
      fun strip_common_prefix (l, []:string list) = (l, [])
        | strip_common_prefix ([],l) = ([],l)
        |   strip_common_prefix (l1 as h1::t1, l2 as h2::t2) =
            if h1 = h2
              then strip_common_prefix (t1, t2)
            else (l1, l2)
              
              
      fun mkRel ([], result) = result
        |   mkRel (_::t, result) = mkRel (t, parentArc :: result)
            
      fun noroot [""] = []
        | noroot x = x

      fun diff (s1, s2) =
        (* s1 and s2 are both absolute.  s2 is a directory. *)
        let
          val canon1 = mkCanonical s1
          val canon2 = s2
          val {arcs = arcs1, ...} = fromString canon1
          val {arcs = arcs2, ...} = fromString canon2
          val (arcs1', arcs2') = strip_common_prefix (arcs1, arcs2)
          val arcs = mkRel (arcs1', noroot arcs2')
        in
          toString {isAbs = false, vol = "", arcs = arcs}
        end
      

        fun isDir s = size s>1
           andalso String.sub(s,size s-1)=dirSeparator

      
    in
      
      fun mkRelative {path, relativeTo} = 
        let
          (*isDir s = true if s is a non-root directory *)

          val r1 = 
            if isAbsolute relativeTo then
              if isAbsolute path
                then diff (relativeTo, path)
              else path
            else
              raise Path

          val r2 = if isDir path andalso not (isDir r1) 
                     then r1^sep else r1

        in
          if path="" then "" else if r2="" then currentArc else r2
        end
    end






    (* isRoot "a:\\" = true
     * isRoot "\\" = true
     * isRoot "\\aaa" = false
     *)

    fun isRoot "" = false
      | isRoot s = 
      case size s of
        1 => String.sub(s, 0) = dirSeparator
      | 3 => String.sub(s, 1) = volumeSeparator andalso 
                                String.sub(s, 2) = dirSeparator
      | _ => false



    (* concat ["a:", "b:"] = raise Path
     * concat ["a:bcd", "a:def"] = "a:bcd\\def"
     * assume volume identifiers are not case sensitive
     *)

    fun concat2backwards (t,s) = 
      let
        val s = 
          if isVolumePrefix s then 
            if isVolumePrefix t then
              let
                val (c,d) = (Char.toLower (String.sub(s, 0)), 
                             Char.toLower (String.sub(t, 0)))
              in
                if c <> d then raise Path
                else
                  s
              end
            else (* not isVolumePrefix t *)
              s
          else (* not isVolumePrefix s *)
          if isVolumePrefix t then
            substring(t, 0, 2)^s
          else
            s
        val xmint = if isVolumePrefix t then 2 else 0
        val sz = size t
      in
        (* identify if relative *)
        if isVolumePrefix t then
          if (sz > 2 andalso String.sub(t, 2) = dirSeparator) then
            raise Path
          else
            s^sep^String.extract(t, 2, NONE)
        else (* not isVolumePrefix t *)
          if (sz > 0 andalso String.sub(t, 0) = dirSeparator) then
            raise Path
          else
            if s="" then t else s^sep^ t
      end

    fun concat [] = ""
      | concat (h::t) = foldl concat2backwards h t;
     
    fun mkAbsolute {path, relativeTo} =
      if isAbsolute relativeTo then
        if isAbsolute path then
          path
        else mkCanonical (concat [relativeTo, path])
      else
        raise Path

    val unixSeparator = #"/"
    val win32Separator = #"\\"

    (* Conversions to and from unix *)
    (* We use MKS conventions for the drive letters *)
    (* Convert a path of the form *)
    (* C:\foo\bar to C:/foo/bar *)
    fun toUnixPath s =
      let
	fun trans #"\\" = unixSeparator
	  | trans x = x
      in
	String.implode(map trans (String.explode s))
      end

    (* Convert a path of the form *)
    (* C:/foo/bar to C:\foo\bar *)
    fun fromUnixPath s =
      let
	fun trans #"/" = win32Separator
	  | trans x = x
      in
	String.implode(map trans (String.explode s))
      end

  end
@


1.10.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 4
 *  Revision 1.10  1999/03/17  10:55:48  daveb
 *  [Bug #30092]
 *  Added InvalidArc exception.
 *
@


1.9
log
@[Bug #30468]
Change types of mkAbsolute and mkRelative to uses records with names fields
@
text
@d10 4
d51 2
d72 2
d103 20
a122 7
            let val initialPath = 
              (if isAbs then 
                 vol^sep 
              else if not (arc = "") then 
                 ""
              else raise Path)
                 ^arc
d124 1
a124 1
              List.foldl (fn (arc, path) => path ^ sep ^ arc) initialPath arcs
d193 1
a193 2
    fun joinDirFile {dir="", file} = file
      | joinDirFile {dir, file} = 
d196 1
d198 3
a200 1
        if size dir > xmin then
a456 1

@


1.8
log
@[Bug #30337]
Change OS.Path.concat to take a string list, instead of a pair of strings.
@
text
@d10 4
d397 1
a397 1
      fun mkRelative (p, abs) = 
d402 4
a405 4
            if isAbsolute abs then
              if isAbsolute p
                then diff (abs, p)
              else p
d409 1
a409 1
          val r2 = if isDir p andalso not (isDir r1) 
d413 1
a413 1
          if p="" then "" else if r2="" then currentArc else r2
d482 5
a486 5
    fun mkAbsolute (p, abs) = 
      if isAbsolute abs then
        if isAbsolute p then
          p
        else mkCanonical (concat [abs, p])
@


1.7
log
@[Bug #1967]
Changed mkCanonical to return lowercase paths.
@
text
@d10 4
d434 2
a435 2
    (* concat ("a:", "b:") = raise Path
     * concat ("a:bcd", "a:def") = "a:bcd\\def"
d438 2
a439 1
    fun concat (s,t) = 
d475 2
d482 1
a482 1
        else mkCanonical (concat (abs, p))
@


1.7.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 4
 *  Revision 1.7  1997/03/31  12:16:50  johnh
 *  [Bug #1967]
 *  Changed mkCanonical to return lowercase paths.
 *
@


1.7.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 4
 *  Revision 1.7  1997/03/31  12:16:50  johnh
 *  [Bug #1967]
 *  Changed mkCanonical to return lowercase paths.
 *
@


1.7.1.1
log
@branched from 1.7
@
text
@a9 4
 *  Revision 1.7  1997/03/31  12:16:50  johnh
 *  [Bug #1967]
 *  Changed mkCanonical to return lowercase paths.
 *
@


1.7.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 3
 *  Revision 1.7.1.1  1997/05/12  10:54:11  hope
 *  branched from 1.7
 *
@


1.7.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 3
 *  Revision 1.7.1.1  1997/05/12  10:54:11  hope
 *  branched from 1.7
 *
@


1.7.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 3
 *  Revision 1.7.1.1  1997/05/12  10:54:11  hope
 *  branched from 1.7
 *
@


1.7.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 3
 *  Revision 1.7.1.1.1.1  1997/07/28  18:36:43  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.6
log
@[Bug #1939]
Add fromUnixPath and toUnixPath
@
text
@d10 4
a102 1

d284 2
d287 1
a287 1
        if s' = "" then currentArc else s'
@


1.5
log
@[Bug #1614]
removing toplevel String
@
text
@d10 4
d474 24
a499 1

@


1.5.4.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/30  20:28:46  io
 *  [Bug #1614]
 *  removing toplevel String
 *
@


1.5.3.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/30  20:28:46  io
 *  [Bug #1614]
 *  removing toplevel String
 *
@


1.5.3.1.1.1
log
@branched from 1.5.3.1
@
text
@a9 3
 *  Revision 1.5.3.1  1996/12/17  18:20:33  hope
 *  branched from 1.5
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/30  20:28:46  io
 *  [Bug #1614]
 *  removing toplevel String
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a9 4
 *  Revision 1.5  1996/10/30  20:28:46  io
 *  [Bug #1614]
 *  removing toplevel String
 *
@


1.5.1.1.1.1
log
@branched from 1.5.1.1
@
text
@a9 3
 *  Revision 1.5.1.1  1996/11/14  13:24:29  hope
 *  branched from 1.5
 *
@


1.4
log
@Remove references to basis.toplevel
@
text
@d10 3
d42 1
a42 1
      String.size s >= 2 andalso 
d48 1
a48 1
      (String.size vol = 2 andalso isVolumePrefix vol)
d60 1
a60 1
         String.size s > 0 andalso String.sub(s,0) = dirSeparator,
d92 1
a92 1
        String.substring(s, 0, 2)
d152 2
a153 2
        { dir =  String.substring (s, 0, m)
         , file = String.substring (s, n, l-n)
d162 2
a163 2
        if String.size dir > xmin then
          if String.sub(dir, String.size dir -1) = dirSeparator then
d177 1
a177 1
        String.substring(s, 0, m)
d186 1
a186 1
        String.substring (s, n, sz-n)
d221 2
a222 2
        | SOME n => { base = String.substring (s, 0, n)
                     , ext =  SOME (String.substring (s, n+1, e-n))
d238 1
a238 1
        | SOME n => String.substring (s, 0, n)
d249 1
a249 1
        | SOME n => SOME (String.substring (s, n+1, e-n))
d374 2
a375 2
        fun isDir s = String.size s>1
           andalso String.sub(s,String.size s-1)=dirSeparator
d442 1
a442 1
            String.substring(t, 0, 2)^s
@


1.3
log
@Checking for empty argument to isDir.
@
text
@d10 3
a17 1
require "^.basis.toplevel";
@


1.3.3.1
log
@branched from 1.3
@
text
@a9 3
 *  Revision 1.3  1996/06/19  13:33:36  andreww
 *  Checking for empty argument to isDir.
 *
@


1.3.2.1
log
@branched from 1.3
@
text
@a9 3
 *  Revision 1.3  1996/06/19  13:33:36  andreww
 *  Checking for empty argument to isDir.
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a9 3
 *  Revision 1.3  1996/06/19  13:33:36  andreww
 *  Checking for empty argument to isDir.
 *
@


1.2
log
@implementing OS.PATH
@
text
@d368 4
a378 2
          fun isDir s = String.sub(s,String.size s-1)=dirSeparator
                        andalso String.size s>1
d391 1
a391 1
          if r2="" then currentArc else r2
@


1.1
log
@new unit
@
text
@d9 4
a12 1
 * $Log$
d19 1
a19 1

a23 2
    exception Unimplemented of string

d34 1
a34 1
    fun validVolume _ = raise Unimplemented "validVolume"
d36 426
a461 1
    fun fromString _ = raise Unimplemented "fromString"
a462 1
    fun toString _ = raise Unimplemented "toString"
d464 1
a464 17
    fun getVolume _ = raise Unimplemented "getVolume"

    fun getParent x = raise Unimplemented "getParent"  (* XXX *)

    fun splitDirFile s = raise Unimplemented "splitDirFile"

    fun joinDirFile {dir, file} = dir ^ (String.str dirSeparator) ^ file

    fun dir s = raise Unimplemented "dir"

    fun file s = raise Unimplemented "file"

    fun splitBaseExt s = raise Unimplemented "splitBaseExt"

    fun joinBaseExt _ = raise Unimplemented "joinBaseExt"

    fun base s = raise Unimplemented "base"
a465 19
    fun ext s = raise Unimplemented "ext"

    fun mkCanonical x = raise Unimplemented "mkCanonical"

    fun isCanonical x = raise Unimplemented "isCanonical"

    fun mkAbsolute x = raise Unimplemented "mkAbsolute"

    fun mkRelative x = raise Unimplemented "mkRelative"

    fun isAbsolute x = raise Unimplemented "isAbsolute"

    fun isRelative x = raise Unimplemented "isRelative"

    fun isRoot x = raise Unimplemented "isRoot"

    fun concat x = raise Unimplemented "concat"

  end
@
