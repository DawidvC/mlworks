head	1.4;
access;
symbols;
locks; strict;
comment	@ * @;


1.4
date	95.01.24.17.58.12;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	95.01.18.13.52.01;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	95.01.13.14.31.04;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.12.12.16.34.44;	author jont;	state Exp;
branches;
next	;


desc
@new file
@


1.4
log
@Sort out realpath stuff
@
text
@(*  ==== FILE NAMING UTILITIES ====
 *          Windows NT FUNCTOR
 *
 *  Copyright (C) 1994 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 *  $Log: _win_ntfilename.sml,v $
 * Revision 1.3  1995/01/18  13:52:01  jont
 * Add realpath function
 *
 * Revision 1.2  1995/01/13  14:31:04  jont
 * Modified to work under NT. Some areas are still outstanding,
 * such as the use of getFullPathName for NT, which seems not to work
 *
 * Revision 1.1  1994/12/12  16:34:44  jont
 * new file
 *
 * Revision 1.1  1994/12/09  13:35:30  jont
 * new file
 *
 *)

require "../utils/getenv";
require "../utils/filename";

functor Win_ntFileName
  (structure Getenv : GETENV
  ): FILENAME =
struct
    structure Option = Getenv.Option

    type Directory = string
    type Route = string

    datatype Absolute = ABSOLUTE of Directory * string * string Option.opt
    datatype Relative = RELATIVE of Route * string * string Option.opt

    exception Parse of string
    exception BadHomeName of string

    val separator = "\\"

    val realpath = MLWorks.OS.Win_nt.get_path_name

    val getwd = MLWorks.OS.Win_nt.get_current_directory;

    fun upto_separator(n, []) = n
      | upto_separator(n, x :: rest) =
	if x = separator then n else upto_separator(n+1, rest)
       
    (* This now uses realpath to resolve symbolic links *)
    fun expand_path string =
      let
        val len = size string

	val expanded =
          if string = "." then
            getwd ()
(*
          else if len = 0 orelse String.ordof(string, 0) <> ord"~" then
*)
	  else
            string
(* Not relevant for NT I think
          else
            let
              val start = upto_separator(0, explode string)
              val name =
                if start = 1 then
                  case Getenv.get_user_name() of
                    Option.PRESENT s => s
                  | _ => raise BadHomeName string
                else
                  String.substring(string, 1, start-1)
              val rest = String.substring(string, start, len-start)
              val MLWorks.OS.Unix.PASSWD {dir, ...} =
                MLWorks.OS.Unix.getpwnam name
                handle MLWorks.OS.Unix.Unix _ =>
                  raise BadHomeName string
            in
              dir ^ rest
            end
*)
          val expanded = realpath expanded handle (Io _) => expanded
      in
        if String.ordof (expanded, size expanded - 1) = ord separator then
	  expanded
	else
	  expanded ^ separator
      end

    fun parse_file file =
      let
        fun find 0 = (file, Option.ABSENT)
          | find n =
            if String.ordof (file, n-1) = ord "." then
              (String.substring (file, 0, n-1),
               Option.PRESENT (String.substring (file, n, size file - n)))
            else
              find (n-1)
      in
        find (size file)
      end

    fun parse_path path =
      let
        fun find 0 = ("", path)
	  | find n =
	    if String.ordof (path, n-1) = ord separator then
	      (expand_path (String.substring (path, 0, n)),
	       String.substring (path, n, size path - n))
	    else
	      find (n-1)
      in
        case find (size path) of
          (_, "") => raise Parse path
        | other => other
      end

    fun is_full_path "" = false
      | is_full_path s =
	String.ordof (s, 0) = ord separator orelse
	(size s >= size "A:\\" andalso
	 String.substring(s, 1, 2) = ":\\")

    fun parse_absolute path =
      let
        val (location, file) = parse_path path
        val (base, kind_opt) = parse_file file
	val directory =
	  if is_full_path location then location else getwd () ^ separator ^ location
      in
        ABSOLUTE (directory, base, kind_opt)
      end

    fun parse_relative path =
      let
        val (route, file) = parse_path path
        val (base, kind_opt) = parse_file file
      in
        RELATIVE (route, base, kind_opt)
      end

    fun parse_route s = expand_path s

    fun parse_directory s = 
      let
	val route = parse_route s
      in 
        if is_full_path route then route else getwd () ^ separator ^ route
      end

    local
      fun print (directory, base, kind_opt) =
        implode (directory :: base ::
                 (case kind_opt of
                    Option.ABSENT => nil
                  | Option.PRESENT extension => [".", extension]))
    in
      fun absolute_name (ABSOLUTE triple) = print triple
      fun relative_name (RELATIVE triple) = print triple
    end

    fun directory_name s = s
    val route_name = directory_name

    fun concat_route (r1, r2) =
      if is_full_path r2 then r2 else r1 ^ r2

    (* Both Directory and Route are string, so we can re-use concat_route. *)
    val follow = concat_route

    fun prefix_route (prefix, rel as RELATIVE (route, name, ext)) =
      if is_full_path route then
	rel
      else
        RELATIVE (prefix ^ route, name, ext)

    fun rel_to_abs (dir, RELATIVE (triple as (route, name, ext))) =
      if is_full_path route then
	ABSOLUTE triple
      else
        ABSOLUTE (dir ^ route, name, ext)

  end;
@


1.3
log
@Add realpath function
@
text
@d9 3
d44 1
a44 1
    val realpath = fn x => x (* Temporary, until we work out getFullPathName isn't working *)
d85 1
a85 3
(* Doesn't appear to work using SMB
          val expanded = MLWorks.OS.Win_nt.get_path_name expanded handle (Io _) => expanded
*)
@


1.2
log
@Modified to work under NT. Some areas are still outstanding,
such as the use of getFullPathName for NT, which seems not to work
@
text
@d9 4
d40 2
@


1.1
log
@new file
@
text
@d2 1
a2 1
 *          UNIX FUNCTOR
d8 4
a11 1
 *  $Log: _unixfilename.sml,v $
d35 3
a37 1
    val getwd = MLWorks.OS.Unix.getwd;
d39 3
a41 3
    fun upto_slash(n, []) = n
      | upto_slash(n, "/" :: _) = n
      | upto_slash(n, _ :: rest) = upto_slash(n+1, rest)
d50 2
a51 1
            MLWorks.OS.Unix.getwd ()
d53 2
d56 1
d59 1
a59 1
              val start = upto_slash(0, explode string)
d75 4
a78 1
          val expanded = MLWorks.OS.Unix.realpath expanded handle (Io _) => expanded
d80 1
a80 1
        if String.ordof (expanded, size expanded - 1) = ord "/" then
d83 1
a83 1
	  expanded ^ "/"
d102 6
a107 6
        |   find n =
          if String.ordof (path, n-1) = ord "/" then
            (expand_path (String.substring (path, 0, n)),
             String.substring (path, n, size path - n))
          else
            find (n-1)
d115 4
a118 1
    |   is_full_path s = String.ordof (s, 0) = ord "/"
d125 1
a125 1
	  if is_full_path location then location else getwd () ^ "/" ^ location
d141 2
a142 1
      let val route = parse_route s
d144 1
a144 1
        if is_full_path route then route else getwd () ^ "/" ^ route
@
