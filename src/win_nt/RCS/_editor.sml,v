head	1.40;
access;
symbols
	MLW_daveb_inline_1_4_99:1.40.1
	MLWorks_21c0_1999_03_25:1.40
	MLWorks_20c1_1998_08_20:1.40
	MLWorks_20c0_1998_08_04:1.40
	MLWorks_20b2c2_1998_06_19:1.40
	MLWorks_20b2_Windows_1998_06_12:1.40
	MLWorks_20b1c1_1998_05_07:1.40
	MLWorks_20b0_1998_04_07:1.39
	MLWorks_20b0_1998_03_20:1.38
	MLWorks_20m2_1998_02_16:1.38
	MLWorks_20m1_1997_10_23:1.37
	MLWorks_11r1:1.32.1.1.1.4.1
	MLWorks_workspace_97:1.36.2
	MLWorks_dt_wizard:1.36.1
	MLWorks_11c0_1997_09_09:1.32.1.1.1.4
	MLWorks_10r3:1.32.1.1.3
	MLWorks_10r2_551:1.32.1.1.2
	MLWorks_11:1.32.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.32.1.1
	MLWorks_20m0_1997_06_20:1.33
	MLWorks_1_0_r2c2_1997_06_14:1.32.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.32.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.32.1
	MLWorks_BugFix_1997_04_24:1.32
	MLWorks_1_0_r2_Win32_1997_04_11:1.32
	MLWorks_1_0_r2_Unix_1997_04_04:1.32
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.31.3.1.1
	MLWorks_gui_1996_12_18:1.31.4
	MLWorks_1_0_Win32_1996_12_17:1.31.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.31.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.31.1.1
	MLWorks_1_0_Irix_1996_11_28:1.31.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.31.2
	MLWorks_1_0_Unix_1996_11_14:1.31.1
	MLWorks_Open_Beta2_1996_10_11:1.29.3
	MLWorks_License_dev:1.29.2
	MLWorks_1_open_beta_1996_09_13:1.29.1
	MLWorks_Open_Beta_1996_08_22:1.28
	MLWorks_Beta_1996_07_02:1.27
	MLWorks_Beta_1996_06_07:1.26
	MLWorks_Beta_1996_06_06:1.26
	MLWorks_Beta_1996_06_05:1.26
	MLWorks_Beta_1996_06_03:1.26
	MLWorks_Beta_1996_05_31:1.26
	MLWorks_Beta_1996_05_30:1.25;
locks; strict;
comment	@ * @;


1.40
date	98.03.30.15.17.19;	author jont;	state Exp;
branches
	1.40.1.1;
next	1.39;

1.39
date	98.03.23.16.28.31;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	97.10.31.09.42.14;	author johnh;	state Exp;
branches;
next	1.37;

1.37
date	97.09.19.09.33.50;	author brucem;	state Exp;
branches;
next	1.36;

1.36
date	97.08.25.10.47.36;	author johnh;	state Exp;
branches
	1.36.1.1
	1.36.2.1;
next	1.35;

1.35
date	97.08.22.09.02.52;	author johnh;	state Exp;
branches;
next	1.34;

1.34
date	97.07.30.10.54.29;	author johnh;	state Exp;
branches;
next	1.33;

1.33
date	97.05.01.13.21.08;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	97.03.13.19.14.37;	author brianm;	state Exp;
branches
	1.32.1.1;
next	1.31;

1.31
date	96.11.06.11.37.18;	author matthew;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1
	1.31.4.1;
next	1.30;

1.30
date	96.10.30.20.33.02;	author io;	state Exp;
branches;
next	1.29;

1.29
date	96.08.26.12.24.55;	author brianm;	state Exp;
branches
	1.29.1.1
	1.29.2.1
	1.29.3.1;
next	1.28;

1.28
date	96.08.11.18.43.36;	author brianm;	state Exp;
branches;
next	1.27;

1.27
date	96.06.15.15.30.09;	author brianm;	state Exp;
branches;
next	1.26;

1.26
date	96.05.30.15.16.47;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	96.05.01.12.12.34;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	96.04.30.13.26.36;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	96.04.22.15.22.43;	author brianm;	state Exp;
branches;
next	1.22;

1.22
date	96.04.16.09.12.40;	author brianm;	state Exp;
branches;
next	1.21;

1.21
date	96.03.28.15.25.23;	author stephenb;	state Exp;
branches;
next	1.20;

1.20
date	96.01.19.15.17.28;	author stephenb;	state Exp;
branches;
next	1.19;

1.19
date	95.10.23.12.51.08;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.10.20.16.43.48;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	95.10.02.13.23.44;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	95.01.13.17.14.02;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	94.12.08.18.04.03;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	94.08.03.09.24.12;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	94.08.02.16.26.01;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	94.07.29.16.19.00;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.08.31.11.29.18;	author matthew;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	93.08.27.17.20.41;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.08.25.15.06.30;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.06.04.14.12.35;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	93.05.18.16.33.29;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	93.04.22.13.00.22;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.15.23.51;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	93.04.08.17.42.49;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	93.04.08.15.00.45;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	93.03.23.18.35.09;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	93.03.10.17.24.30;	author jont;	state Exp;
branches;
next	;

1.11.1.1
date	93.08.31.11.29.18;	author jont;	state Exp;
branches;
next	;

1.29.1.1
date	96.09.13.11.43.54;	author hope;	state Exp;
branches;
next	;

1.29.2.1
date	96.10.07.16.37.07;	author hope;	state Exp;
branches;
next	;

1.29.3.1
date	96.10.17.11.56.06;	author hope;	state Exp;
branches;
next	;

1.31.1.1
date	96.11.14.13.24.27;	author hope;	state Exp;
branches
	1.31.1.1.1.1;
next	;

1.31.1.1.1.1
date	96.11.28.15.35.20;	author hope;	state Exp;
branches;
next	;

1.31.2.1
date	96.11.22.18.41.33;	author hope;	state Exp;
branches;
next	;

1.31.3.1
date	96.12.17.18.20.31;	author hope;	state Exp;
branches
	1.31.3.1.1.1;
next	;

1.31.3.1.1.1
date	97.02.24.12.15.07;	author hope;	state Exp;
branches;
next	;

1.31.4.1
date	96.12.18.10.16.04;	author hope;	state Exp;
branches;
next	;

1.32.1.1
date	97.05.12.10.54.09;	author hope;	state Exp;
branches
	1.32.1.1.1.1
	1.32.1.1.2.1
	1.32.1.1.3.1;
next	;

1.32.1.1.1.1
date	97.07.28.18.36.38;	author daveb;	state Exp;
branches;
next	1.32.1.1.1.2;

1.32.1.1.1.2
date	97.08.04.15.04.37;	author johnh;	state Exp;
branches;
next	1.32.1.1.1.3;

1.32.1.1.1.3
date	97.08.22.09.15.16;	author johnh;	state Exp;
branches;
next	1.32.1.1.1.4;

1.32.1.1.1.4
date	97.08.25.10.55.12;	author johnh;	state Exp;
branches
	1.32.1.1.1.4.1.1;
next	;

1.32.1.1.1.4.1.1
date	97.10.07.12.01.50;	author jkbrook;	state Exp;
branches;
next	;

1.32.1.1.2.1
date	97.09.08.17.28.53;	author daveb;	state Exp;
branches;
next	;

1.32.1.1.3.1
date	97.09.09.14.26.45;	author daveb;	state Exp;
branches;
next	;

1.36.1.1
date	97.09.10.19.45.03;	author brucem;	state Exp;
branches;
next	;

1.36.2.1
date	97.09.11.21.12.14;	author daveb;	state Exp;
branches;
next	;

1.40.1.1
date	99.04.01.18.10.17;	author daveb;	state Exp;
branches;
next	;


desc
@Implementation of interface to external editors
@


1.40
log
@[Bug #70086]
Update type of "dde send execute string" to return unit and simplify
@
text
@(* _editor.sml the functor *)
(*
$Log: _editor.sml,v $
 * Revision 1.39  1998/03/23  16:28:31  jont
 * [Bug #30090]
 * Replace use of MLWorks.IO.Io with syserr
 *
 * Revision 1.38  1997/10/31  09:42:14  johnh
 * [Bug #30233]
 * Change CustomEditor interface to make connectDialogs distinct from custom commands.
 *
 * Revision 1.37  1997/09/19  09:33:50  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.36  1997/08/25  10:47:36  johnh
 * [Bug #30220]
 * Put quotes around %f parameter.
 *
 * Revision 1.35  1997/08/22  09:02:52  johnh
 * [Bug #30220]
 * Putting quotes around full filename for external editor.
 *
 * Revision 1.34  1997/07/30  10:54:29  johnh
 * [Bug #30220]
 * Using Wordpad instead of Textpad.
 *
 * Revision 1.33  1997/05/01  13:21:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.32  1997/03/13  19:14:37  brianm
 * Bug fix for Bug ID 1803 - problems with empty dialog types.
 *
 * Revision 1.31  1996/11/06  11:37:18  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.30  1996/10/30  20:33:02  io
 * [Bug #1614]
 * remove toplevel String
 *
 * Revision 1.29  1996/08/26  12:24:55  brianm
 * Added local default editor options ...
 *
 * Revision 1.28  1996/08/11  18:43:36  brianm
 * [Bug #1528]
 * Minor correction to custom_server.
 *
 * Revision 1.27  1996/06/15  15:30:09  brianm
 * Modifications to add custom editor interface ...
 *
 * Revision 1.26  1996/05/30  15:16:47  daveb
 * The Io exception is no longer at top level.
 *
 * Revision 1.25  1996/05/01  12:12:34  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.24  1996/04/30  13:26:36  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.23  1996/04/22  15:22:43  brianm
 * Adding support for TextPad ...
 *
 * Revision 1.22  1996/04/16  09:12:40  brianm
 * Adding PFE support via DDE ...
 *
 * Revision 1.21  1996/03/28  15:25:23  stephenb
 * Remove the Os argument since it is not currently used.
 *
 * Revision 1.20  1996/01/19  15:17:28  stephenb
 * OS reorganisation: Remove all the Unix specific stuff since
 * this never worked and since the Unix structure is no longer
 * part of the pervasive library won't even compile.
 *
Revision 1.19  1995/10/23  12:51:08  daveb
Changed name of e-lisp highlight function to mlworks-highlight.

Revision 1.18  1995/10/20  16:43:48  daveb
Sent the emacs commands as separate S-expressions, to avoid buffer
overflow problems.

Revision 1.17  1995/10/02  13:23:44  daveb
Made emacs highlight errors.
Removed next_error and no_more_errors.

Revision 1.16  1995/01/13  17:14:02  daveb
Replaced Option structure with references to MLWorks.Option.

Revision 1.15  1994/12/08  18:04:03  jont
Move OS specific stuff into a system link directory

Revision 1.14  1994/08/03  09:24:12  matthew
Reinstate call to makestring

Revision 1.13  1994/08/02  16:26:01  daveb
Added support for user-defined editors.

Revision 1.12  1994/07/29  16:19:00  daveb
Moved preferences into separate structure.

Revision 1.11  1993/08/31  11:29:18  matthew
reversed arguments to kill
added handler for Unix exception

Revision 1.10  1993/08/27  17:20:41  matthew
Added call to Unix.kill

Revision 1.9  1993/08/25  15:06:30  matthew
Return quit function from ShellUtils.edit_string
Need to uncomment call to kill

Revision 1.8  1993/06/04  14:12:35  daveb
Removed filename component of error result for edit functions.

Revision 1.7  1993/05/18  16:33:29  daveb
Changed Integer.makestring to MLWorks.Integer.makestring and removed
the Integer structure.

Revision 1.6  1993/04/22  13:00:22  richard
The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.

Revision 1.5  1993/04/14  15:23:51  jont
Added editing from location. Added a function to do next error from a list

Revision 1.4  1993/04/08  17:42:49  jont
Modify edit and edit_from_location to use the relevant editor

Revision 1.3  1993/04/08  15:00:45  jont
Added options parameter

Revision 1.2  1993/03/23  18:35:09  jont
Changed editor implementastion slightly.

Revision 1.1  1993/03/10  17:24:30  jont
Initial revision

Copyright (C) 1993 Harlequin Ltd
*)

require "$.basis.__int";
require "$.basis.__string";

require "../main/preferences";
require "../basics/location";
require "../editor/editor";
require "../editor/custom";
require "../utils/lists";
require "../utils/crash";

require "win32";


functor Editor
  (structure Preferences: PREFERENCES
   structure Location : LOCATION
   structure Win32    : WIN32
   structure CustomEditor : CUSTOM_EDITOR
   structure Lists : LISTS
   structure Crash : CRASH
  ) : EDITOR =
struct
    structure Location = Location

    type preferences = Preferences.preferences
      

    (* Setting Win32 Default Editor Options *)

    local
        open Preferences
        val EDITOR_OPTIONS {editor, oneWayEditorName, 
			    twoWayEditorName, externalEditorCommand} =
            default_editor_options
    in
        val _ =
          ( editor                 := "External";
            oneWayEditorName       := "Wordpad";
            twoWayEditorName       := "PFE32";
            externalEditorCommand  := 
		"\"C:\\Program Files\\Accessories\\Wordpad.exe\" \"%f\""
          )
    end

    fun null_fun () = ()

    fun show_int (i) =
        if i < 0 then "-" ^ Int.toString(~i) else Int.toString(i)

    val member   = Lists.member

    (* Locations etc. *)

    fun line_from_location(Location.UNKNOWN) = 0
      | line_from_location(Location.FILE _) = 0
      | line_from_location(Location.LINE(_, i)) = i
      | line_from_location(Location.POSITION(_, i, _)) = i
      | line_from_location(Location.EXTENT{s_line=i, ...}) = i


    fun get_position_info (Location.EXTENT{s_line, s_col, e_line, e_col, ...}) =
        (s_line,s_col, e_line, e_col)

      | get_position_info (loc) = (line_from_location loc,0,~1,~1)


    (* Editor interfaces *)


    (* Argument Specifier Notation:
     * ============================
     *   %f =   filename
     *   %l =   %sl   = start line no.
     *   %c =   %sc   = start char no.
     *   %el =  end line no.
     *   %ec =  end char no.
     *   %%  =  % (percent)
     *)


    fun expand_args (fnm, st_l, st_c, e_l, e_c) =
	let fun trans (#"%" :: #"%" :: l, r) =
                  trans(l, "%" :: r)
	      | trans (#"%" :: #"f" :: l, r) =
                  trans(l, fnm :: r)
	      | trans (#"%" :: #"l" :: l, r) =
                  trans(l, show_int(st_l) :: r)
	      | trans (#"%" :: #"s" :: #"l" :: l, r) =
                  trans(l, show_int(st_l) :: r)
	      | trans (#"%" :: #"c" :: l, r) =
                  trans(l, show_int(st_c) :: r)
	      | trans (#"%" :: #"s" :: #"c" :: l, r) =
                  trans(l, show_int(st_c) :: r)
	      | trans (#"%" :: #"e" :: #"l" :: l, r) =
                  trans(l, show_int(e_l) :: r)
	      | trans (#"%" :: #"e" :: #"c" :: l, r) =
                  trans(l, show_int(e_c) :: r)
	      | trans (c :: l, r) =
                  trans (l, (String.str c)::r)
              | trans (_, r) =
                  concat (rev r) 

            fun doit str = trans(explode str,[])
        in
            doit
        end

    fun transEntry loc_details (server,commands) =
      let 
	val translate = expand_args loc_details
      in
        (server, map translate commands)
      end


    (* Dynamic Data Exchange interface -- execute strings only *)

    type dde_data = word;

    local

       val env  = MLWorks.Internal.Runtime.environment

    in
       val start_dde_dialog : (string * string) -> dde_data =
	   env "dde start dialog";

       val send_dde_execute_string : (dde_data * string * int * int) -> unit =
	   env "dde send execute string";

       val stop_dde_dialog : dde_data -> unit =
	   env "dde stop dialog";
    end

    fun dde_dialog ("", "", _) =
            ( SOME ("Unspecified service & topic for DDE server"), null_fun )

      | dde_dialog ("", _, _) =
            ( SOME ("Unspecified service for DDE server"), null_fun )

      | dde_dialog (_, "", _) =
            ( SOME ("Unspecified topic for DDE server"), null_fun )

      |  dde_dialog (service, topic, cmds) =
	let val busy_retries = 20    (* max number of busy retries *)
	    val delay = 200          (* milliseconds *)

	    val dde_info = start_dde_dialog (service,topic)
	      handle MLWorks.Internal.Error.SysErr(msg, err) =>
		raise MLWorks.Internal.Error.SysErr("Unable to contact " ^ service ^ " DDE server", err)
	    fun exec_dde s =
		send_dde_execute_string (dde_info,s,busy_retries,delay)

	    fun doit (s :: lst) = (exec_dde(s) ; doit lst)
	      | doit [] = stop_dde_dialog dde_info
	in
	      doit cmds;
	      (NONE, null_fun)
	end
	handle
	MLWorks.Internal.Error.SysErr(msg, _) => (SOME msg, null_fun)



    (* PFE interface *)

    val standard_pfe_commands =
        let val file_open   = "[FileOpen(\"%f\")]"
            val file_visit  = "[FileVisit(\"%f\")]"

            val goto_line   = "[EditGotoLine(%sl,0)]"
            val fwd_char    = "[CaretRight(%sc,0)]"
            val highlight   = "[EditGotoLine(%el,1)][CaretRight(%ec,1)]"

            val display_cmds = [goto_line, fwd_char, highlight]
            val full_dialog  = file_open :: display_cmds

        in
 
	   CustomEditor.addConnectDialog("PFE32", "DDE", "PFE32" :: "Editor" :: full_dialog);
           (file_open, file_visit, display_cmds)

        end


    fun pfe_server (fname, st_l, st_c, e_l, e_c, edit_file) =
        let val service = "PFE32"

	    val topic =   "Editor"

            val (openf,viewf,display_cmds) = standard_pfe_commands

            val dialog = if edit_file then openf :: display_cmds
                         else viewf :: display_cmds

            val translate = expand_args (fname,st_l,st_c,e_l,e_c)
        in
            dde_dialog (service, topic, map translate dialog)
        end

    (* TextPad and Wordpad interfaces *)


    val _ = let 
	      val wordpad_cmd = "\"C:\\Program Files\\Accessories\\Wordpad.exe\" \"%f\""
	      val textpad_cmd = "\"C:\\TextPad\\DDEOPN32.EXE\" TextPad %f(%sl,%sc)"
	    in
	      CustomEditor.addCommand("TextPad", textpad_cmd);
	      CustomEditor.addCommand("Wordpad", wordpad_cmd)
	    end;

    fun do_command (s) =
        (
	  (* launch Win32 process (HIGH pri.) *)
	  if not(Win32.create_process(s,Win32.HIGH)) then 
	    (SOME "Can't execute editor process\n", null_fun)
	  else 
            (NONE, null_fun)
        )

    (* this function provides an external editor - by launching an editor
       each time it is needed - a `one-shot' editor.
    *)
    fun external_server extCmd (string, s_l, s_c, e_l, e_c) =
	let val translate = expand_args (string, s_l, s_c, e_l, e_c)
	in
	    do_command ( translate extCmd )
	end

    fun one_way_server customName loc_details = 
      let 
	val translate = expand_args loc_details
	val cmd = translate (CustomEditor.getCommandEntry customName)

	val cmd_result = 
	  if (cmd <> "") then do_command cmd
	  else (SOME "invalid choice for editor", null_fun)
      in
	cmd_result
      end

    fun two_way_server customName loc_details = 
      let 
	val (dialog_type, commands) = 
	  transEntry loc_details (CustomEditor.getDialogEntry customName)

	val (service, topic, commands) = 
	  case commands of
	    s::t::cmds => (s,t,cmds)
	  | _ => ("","",commands)
      in
	case dialog_type of 
	  "DDE"	=> dde_dialog (service, topic, commands)
	| _ => (SOME ("Unknown custom dialog type : " ^ dialog_type), null_fun)
      end

    fun edit
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
	        {editor, externalEditorCommand, oneWayEditorName, twoWayEditorName, ...},
	      ...})
          (string, i) =
	case !editor of
	  "External" =>
	     external_server (!externalEditorCommand) (string, i, 0, ~1, ~1)

	| "OneWay" =>
	     one_way_server (!oneWayEditorName) (string, i, 0, ~1, ~1)

	| "TwoWay" =>
	     two_way_server (!twoWayEditorName) (string, i, 0, ~1, ~1)

	| opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")


    fun edit_from_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
	        {editor, externalEditorCommand, oneWayEditorName, twoWayEditorName, ...},
	      ...})
          (string, location) =
	let val (s_l, s_c, e_l, e_c) = get_position_info location
	in
	   case !editor of
	     "External" =>
		 external_server (!externalEditorCommand) (string, s_l, s_c, e_l, e_c)

	   | "OneWay" =>
		 one_way_server (!oneWayEditorName) (string, s_l, s_c, e_l, e_c)

	   | "TwoWay" =>
		 two_way_server (!twoWayEditorName) (string, s_l, s_c, e_l, e_c)

           | opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")
        end


    fun show_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
	        {editor, externalEditorCommand, oneWayEditorName, twoWayEditorName, ...},
	      ...})
          (string, location) =
	let val (s_l, s_c, e_l, e_c) = get_position_info location
	in
	   case !editor of
	     "External" =>
		 (SOME("show location requires emacs"), null_fun)

	   | "OneWay" =>
		 one_way_server (!oneWayEditorName) (string, s_l, s_c, e_l, e_c)

	   | "TwoWay" =>
		 two_way_server (!twoWayEditorName) (string, s_l, s_c, e_l, e_c)

           | opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")
        end
   end
@


1.40.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.40  1998/03/30  15:17:19  jont
 * [Bug #70086]
 * Update type of "dde send execute string" to return unit and simplify
 *
@


1.39
log
@[Bug #30090]
Replace use of MLWorks.IO.Io with syserr
@
text
@d4 4
d273 1
a273 1
       val send_dde_execute_string : (dde_data * string * int * int) -> dde_data =
d293 1
a293 1
	    val dde_info = ref(start_dde_dialog (service,topic))
d296 2
a297 2
	    fun exec_dde (s) =
		dde_info := send_dde_execute_string (!dde_info,s,busy_retries,delay)
d300 1
a300 1
	      | doit [] = stop_dde_dialog (!dde_info)
@


1.38
log
@[Bug #30233]
Change CustomEditor interface to make connectDialogs distinct from custom commands.
@
text
@d4 4
d110 1
a110 1
Need to uncomment call to kill]
d290 2
a291 4
			   handle
			     MLWorks.IO.Io _ =>
			       raise (MLWorks.IO.Io ("Unable to contact " ^ service ^ " DDE server"))

d302 1
a302 1
	   MLWorks.IO.Io msg => (SOME msg, null_fun)
@


1.37
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 4
d169 2
a170 1
        val EDITOR_OPTIONS {editor, customEditorName, externalEditorCommand} =
d175 2
a176 1
            customEditorName       := "TextPad";
d245 6
a250 8
    fun transEntry (file,s_line,s_char,e_line,e_char) (cmd,server,commands) =
        let val translate = expand_args (file,s_line,s_char,e_line,e_char)
        in
           ( translate cmd
           , server
           , map translate commands
           )
        end
d353 5
a357 2
	  Win32.create_process(s,Win32.HIGH); (* launch Win32 process (HIGH pri.) *)
          (NONE, null_fun)
a359 4
    (* stub function for emacs server - does nothing. *)
    fun emacs_server (string, s_l, s_c, e_l, e_c, edit_file) =
        (SOME "Emacs is currently unsupported on Win 32", null_fun)

d369 26
a394 40
    (* this function provides custom editing services *)
    fun custom_server customName (string, s_l, s_c, e_l, e_c) =

                        (* first expand the string *) 
        let val trans = transEntry (string, s_l, s_c, e_l, e_c)

                        (* fetch commands etc. *) 
            val (cmd,dialog_type,commands) = trans (CustomEditor.getEntry customName)
                        (* extract DDE service and topic as first two commands *)
            val (service,topic,commands) =
                     case commands of
                       s::t::cmds => (s,t,cmds)
                     | _ => ("","",commands)

                        (* perform non-trivial editor launcher command *) 
            val cmd_result as (res_msg,callback) = 
                   if (cmd <> "") then do_command (cmd)
                   else  (NONE,null_fun)
        in
            (* analyse return message from editor launcher command *)
            case res_msg of
              NONE =>    (* i.e. normal situation *)
		( case dialog_type of
		    "DDE"     => dde_dialog (service,topic,commands)
		  
                  | "Emacs"   =>
		     ( SOME ("Emacs dialog not supported on Win 32 platforms")
		     , callback
		     )
                  
                  | "" => (NONE, callback) (* empty dialog type *)
		  
                  | _ =>
		     ( SOME ("Unknown custom dialog type : " ^ dialog_type)
		     , callback
		     )
                )

            | _ => cmd_result
        end
d399 1
a399 1
	        {editor, externalEditorCommand, customEditorName, ...},
d403 2
a404 2
	  "EmacsServer" =>
	     emacs_server (string, i, 0, ~1, ~1, true)
d406 2
a407 2
	| "External" =>
	     external_server (!externalEditorCommand) (string, i, 0, ~1, ~1)
d409 2
a410 2
	| "Custom" =>
	     custom_server (!customEditorName) (string, i, 0, ~1, ~1)
d418 1
a418 1
	        {editor, externalEditorCommand, customEditorName, ...},
d424 2
a425 2
	     "EmacsServer" =>
		 emacs_server (string, s_l, s_c, e_l, e_c, true)
d427 2
a428 2
	   | "External" =>
		 external_server (!externalEditorCommand) (string, s_l, s_c, e_l, e_c)
d430 2
a431 2
	   | "Custom" =>
		 custom_server (!customEditorName) (string, s_l, s_c, e_l, e_c)
d440 1
a440 1
	        {editor, externalEditorCommand, customEditorName, ...},
d446 2
a447 2
	     "EmacsServer" =>
		 emacs_server (string, s_l, s_c, e_l, e_c, false)
d449 2
a450 2
	   | "External" =>
		 (SOME("show location requires emacs"), null_fun)
d452 2
a453 2
	   | "Custom" =>
		 custom_server (!customEditorName) (string, s_l, s_c, e_l, e_c)
@


1.36
log
@[Bug #30220]
Put quotes around %f parameter.
@
text
@d4 4
d134 2
a135 2
require "../basis/__int";
require "^.basis.__old";
d212 21
a232 16
    fun expand_args (fnm,st_l,st_c,e_l,e_c) =
	let fun trans ("%" :: "%" :: l, r) = trans(l, "%" :: r)

	      | trans ("%" :: "f" :: l, r) = trans(l, fnm :: r)

	      | trans ("%" :: "l" :: l, r)        = trans(l,show_int(st_l) :: r)
	      | trans ("%" :: "s" :: "l" :: l, r) = trans(l,show_int(st_l) :: r)

	      | trans ("%" :: "c" :: l, r)        = trans(l,show_int(st_c) :: r)
	      | trans ("%" :: "s" :: "c" :: l, r) = trans(l,show_int(st_c) :: r)

	      | trans ("%" :: "e" :: "l" :: l, r) = trans(l,show_int(e_l) :: r)
	      | trans ("%" :: "e" :: "c" :: l, r) = trans(l,show_int(e_c) :: r)

	      | trans (c :: l, r) = trans (l,c::r)
              | trans (_, r)      = concat (rev r) 
d234 1
a234 1
            fun doit str = trans(Old.explode str,[])
@


1.36.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.36  1997/08/25  10:47:36  johnh
 * [Bug #30220]
 * Put quotes around %f parameter.
 *
@


1.36.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.36  1997/08/25  10:47:36  johnh
 * [Bug #30220]
 * Put quotes around %f parameter.
 *
@


1.35
log
@[Bug #30220]
Putting quotes around full filename for external editor.
@
text
@d4 4
d168 1
a168 1
		"\"C:\\Program Files\\Accessories\\Wordpad.exe\" %f"
d331 1
a331 1
	      val wordpad_cmd = "\"C:\\Program Files\\Accessories\\Wordpad.exe\" %f"
@


1.34
log
@[Bug #30220]
Using Wordpad instead of Textpad.
@
text
@d4 4
d164 1
a164 1
		"C:\\Program Files\\Accessories\\Wordpad.exe %f"
d327 2
a328 2
	      val wordpad_cmd = "C:\\Program Files\\Accessories\\Wordpad.exe %f"
	      val textpad_cmd = "C:\\TextPad\\DDEOPN32.EXE TextPad %f(%sl,%sc)"
@


1.33
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d157 4
a160 3
          ( editor                 := "Custom";
            customEditorName       := "PFE32";
            externalEditorCommand  := "C:\\TextPad\\DDEOPN32.EXE TextPad %f(%sl,%sc)"
d319 1
a319 1
    (* TextPad interface *)
d322 3
a324 1
    val _ = let val textpad_cmd = "C:\\TextPad\\DDEOPN32.EXE TextPad %f(%sl,%sc)"
d326 2
a327 1
		CustomEditor.addCommand("TextPad", textpad_cmd)
@


1.32
log
@Bug fix for Bug ID 1803 - problems with empty dialog types.
@
text
@d4 3
d247 1
a247 1
            ( MLWorks.Option.SOME ("Unspecified service & topic for DDE server"), null_fun )
d250 1
a250 1
            ( MLWorks.Option.SOME ("Unspecified service for DDE server"), null_fun )
d253 1
a253 1
            ( MLWorks.Option.SOME ("Unspecified topic for DDE server"), null_fun )
d271 1
a271 1
	      (MLWorks.Option.NONE, null_fun)
d274 1
a274 1
	   MLWorks.IO.Io msg => (MLWorks.Option.SOME msg, null_fun)
d325 1
a325 1
          (MLWorks.Option.NONE, null_fun)
d330 1
a330 1
        (MLWorks.Option.SOME "Emacs is currently unsupported on Win 32", null_fun)
d358 1
a358 1
                   else  (MLWorks.Option.NONE,null_fun)
d362 1
a362 1
              MLWorks.Option.NONE =>    (* i.e. normal situation *)
d367 1
a367 1
		     ( MLWorks.Option.SOME ("Emacs dialog not supported on Win 32 platforms")
d374 1
a374 1
		     ( MLWorks.Option.SOME ("Unknown custom dialog type : " ^ dialog_type)
d436 1
a436 1
		 (MLWorks.Option.SOME("show location requires emacs"), null_fun)
@


1.32.1.1
log
@branched from 1.32
@
text
@a3 3
 * Revision 1.32  1997/03/13  19:14:37  brianm
 * Bug fix for Bug ID 1803 - problems with empty dialog types.
 *
@


1.32.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.32.1.1  1997/05/12  10:54:09  hope
 * branched from 1.32
 *
@


1.32.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.32.1.1  1997/05/12  10:54:09  hope
 * branched from 1.32
 *
@


1.32.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.32.1.1  1997/05/12  10:54:09  hope
 * branched from 1.32
 *
@


1.32.1.1.1.2
log
@[Bug #30220]
Merging - include Wordpad in default editors.
@
text
@a3 3
 * Revision 1.32.1.1.1.1  1997/07/28  18:36:38  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a6 8
 * Revision 1.34  1997/07/30  10:54:29  johnh
 * [Bug #30220]
 * Using Wordpad instead of Textpad.
 *
 * Revision 1.33  1997/05/01  13:21:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
d156 3
a158 4
          ( editor                 := "External";
            customEditorName       := "TextPad";
            externalEditorCommand  := 
		"C:\\Program Files\\Accessories\\Wordpad.exe %f"
d317 1
a317 1
    (* TextPad and Wordpad interfaces *)
d320 1
a320 3
    val _ = let 
	      val wordpad_cmd = "C:\\Program Files\\Accessories\\Wordpad.exe %f"
	      val textpad_cmd = "C:\\TextPad\\DDEOPN32.EXE TextPad %f(%sl,%sc)"
d322 1
a322 2
	      CustomEditor.addCommand("TextPad", textpad_cmd);
	      CustomEditor.addCommand("Wordpad", wordpad_cmd)
@


1.32.1.1.1.3
log
@[Bug #30220]
Merging - Putting quotes around full filename for external editor.
@
text
@a3 4
 * Revision 1.32.1.1.1.2  1997/08/04  15:04:37  johnh
 * [Bug #30220]
 * Merging - include Wordpad in default editors.
 *
d170 1
a170 1
		"\"C:\\Program Files\\Accessories\\Wordpad.exe\" %f"
d333 2
a334 2
	      val wordpad_cmd = "\"C:\\Program Files\\Accessories\\Wordpad.exe\" %f"
	      val textpad_cmd = "\"C:\\TextPad\\DDEOPN32.EXE\" TextPad %f(%sl,%sc)"
@


1.32.1.1.1.4
log
@[Bug #30220]
Merging - Put quotes around %f parameter.
@
text
@a3 4
 * Revision 1.32.1.1.1.3  1997/08/22  09:15:16  johnh
 * [Bug #30220]
 * Merging - Putting quotes around full filename for external editor.
 *
d174 1
a174 1
		"\"C:\\Program Files\\Accessories\\Wordpad.exe\" \"%f\""
d337 1
a337 1
	      val wordpad_cmd = "\"C:\\Program Files\\Accessories\\Wordpad.exe\" \"%f\""
@


1.32.1.1.1.4.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 4
 * Revision 1.32.1.1.1.4  1997/08/25  10:55:12  johnh
 * [Bug #30220]
 * Merging - Put quotes around %f parameter.
 *
@


1.31
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d321 1
a321 1
	  Win32.create_process(s,Win32.HIGH);
d325 1
d329 3
d338 1
d340 2
d343 2
d346 1
d352 1
d357 1
d359 1
a359 1
              MLWorks.Option.NONE =>
d362 2
a363 1
		  | "Emacs"   =>
d367 4
a370 1
		  | _ =>
d375 1
@


1.31.4.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:37:18  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.3.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:37:18  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.3.1.1.1
log
@branched from 1.31.3.1
@
text
@a3 3
 * Revision 1.31.3.1  1996/12/17  18:20:31  hope
 * branched from 1.31
 *
@


1.31.2.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:37:18  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.1.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:37:18  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.1.1.1.1
log
@branched from 1.31.1.1
@
text
@a3 3
 * Revision 1.31.1.1  1996/11/14  13:24:27  hope
 * branched from 1.31
 *
@


1.30
log
@[Bug #1614]
remove toplevel String
@
text
@d4 4
d111 1
a111 1
require "../basis/__integer";
@


1.29
log
@Added local default editor options ...
@
text
@d4 3
d108 1
a152 3
    val explode  = String.explode
    val implode  = String.implode

d199 1
a199 1
              | trans (_, r)      = implode(rev r) 
d201 1
a201 1
            fun doit str = trans(explode str,[])
@


1.29.3.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/08/26  12:24:55  brianm
 * Added local default editor options ...
 *
@


1.29.2.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/08/26  12:24:55  brianm
 * Added local default editor options ...
 *
@


1.29.1.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/08/26  12:24:55  brianm
 * Added local default editor options ...
 *
@


1.28
log
@[Bug #1528]
Minor correction to custom_server.
@
text
@d4 4
d128 15
@


1.27
log
@Modifications to add custom editor interface ...
@
text
@d4 3
d308 1
a308 1
            val (cmd,dialog_type,commands) = trans (CustomEditor.getEntry string)
@


1.26
log
@The Io exception is no longer at top level.
@
text
@d4 3
d102 4
d113 3
d122 7
a128 1
    (* Hacking the default editor options - they are currently specific to Unix/X *)
d130 3
a132 8
    val _ =
        let val Preferences.EDITOR_OPTIONS 
                   { xterm_editor_command, x_editor_command, ...} =
                   Preferences.default_editor_options
        in
	  xterm_editor_command := "C:\\TextPad\\DDEOPN32.EXE TextPad";
          x_editor_command := "(None)"       (* UNIX/X specific *)
        end
a139 1
    fun null_fun () = ()
d141 50
a190 1
    val show_int = Int.toString
d212 2
a213 5
    (* PFE interface *)
    fun pfe (filename, s_line, s_col, e_line, e_col, edit_file) =
	let val service = "PFE32"

	    val topic =   "Editor"
d215 2
a216 21
	    val find_file =
		if edit_file then
		   ["[FileOpen(\"", filename, "\")]"]  (* Editable file *)
		else
		   ["[FileView(\"", filename, "\")]"]  (* Read Only *)

	    val goto_line =
		["[EditGotoLine(", show_int s_line, ",0)]"]

	    val forward_char =
		["[CaretRight(", show_int s_col, ",0)]"]

	    val set_highlight =
		if e_line <> ~1 then
		   if s_line <> e_line then
		      ["[EditGotoLine(", show_int e_line, ",1)]",
		       "[CaretRight(", show_int e_col, ",1)]"
		      ]
		   else [ "[CaretRight(", show_int (e_col - s_col), ",1)]"] 
		else
		   []
d218 2
a219 1
	    val cmds = [ find_file, goto_line, forward_char, set_highlight ]
d221 2
a222 1
	    val busy_retries = 20    (* max number of busy retries *)
d228 1
a228 1
			       raise (MLWorks.IO.Io "Unable to contact PFE32 DDE server")
d233 1
a233 2
	    fun doit ([] :: lst) = doit(lst)
	      | doit (s :: lst) = (exec_dde(String.implode s) ; doit lst)
d243 37
d282 49
a330 13
    local
       fun create_process (s) = Win32.create_process(s,Win32.HIGH)
    in
       fun textpad (call,filename, s_line, s_col) =
	   let val line_no = show_int(s_line)
               val char_posn = show_int(s_col)
               val cmd = call ^ " " ^ filename ^ "(" ^ line_no ^ "," ^ char_posn ^ ")"
	   in
	     create_process(cmd) ;
	     (MLWorks.Option.NONE, null_fun)
	   end
    end
    
d334 1
a334 1
	        {editor, x_editor_command, xterm_editor_command, ...},
d337 12
a348 4
      case !editor of
        "emacs_server" => pfe (string, i, 0, ~1, ~1,true)
      | "xterm" => textpad(!xterm_editor_command,string,i,0)
      | _ => (MLWorks.Option.SOME ("Unsupported editor `" ^ !editor ^ "'"),null_fun)
d353 1
a353 1
	        {editor, x_editor_command, xterm_editor_command, ...},
d356 14
a369 12
      case !editor of
        "emacs_server" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   pfe (string, s_line, s_col, e_line, e_col, true)
	 |  _ => pfe (string, line_from_location location, 0, ~1, ~1, true))
      | "xterm" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   textpad (!xterm_editor_command,string, s_line, s_col)
	 |  _ => textpad (!xterm_editor_command,string, line_from_location location, 0))
      | _ => (MLWorks.Option.SOME ("Unsupported editor `" ^ !editor ^ "'"),null_fun)
a371 1
    (* Show file at location - i.e. look but don't touch *)
d375 1
a375 1
	        {editor, x_editor_command, xterm_editor_command, ...},
d378 8
a385 12
      case !editor of
        "emacs_server" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   pfe (string, s_line, s_col, e_line, e_col, false)
	 |  _ => pfe (string, line_from_location location, 0, ~1, ~1, false))
      | "xterm" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   textpad (!xterm_editor_command,string, s_line, s_col)
	 |  _ => textpad (!xterm_editor_command,string, line_from_location location, 0))
      | _ => (MLWorks.Option.SOME ("Unsupported editor `" ^ !editor ^ "'"),null_fun)
d387 6
a392 1
  end
@


1.25
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d188 2
a189 1
			     Io _ => raise (Io "Unable to contact PFE32 DDE server")
d202 1
a202 1
	   Io msg => (MLWorks.Option.SOME msg, null_fun)
@


1.24
log
@Removing MLWorks.Integer
@
text
@d4 3
d188 1
a188 1
	      | doit (s :: lst) = (exec_dde(implode s) ; doit lst)
@


1.23
log
@Adding support for TextPad ...
@
text
@d4 3
d85 2
d122 1
a122 1
    val show_int = MLWorks.Integer.makestring
@


1.22
log
@Adding PFE support via DDE ...
@
text
@d4 3
a81 2
(* require "../initbasis/__word32"; *)

d85 1
d91 1
d98 11
a138 12


    (* Hacking the default editor options - they are specific to Unix/X *)
    val _ =
        let val Preferences.EDITOR_OPTIONS 
                   { xterm_editor_command, x_editor_command, ...} =
                   Preferences.default_editor_options
        in
	  xterm_editor_command := "(None)";  (* UNIX/X specific *)
          x_editor_command := "(None)"       (* UNIX/X specific *)
        end

d189 16
d213 1
d228 5
d249 5
@


1.21
log
@Remove the Os argument since it is not currently used.
@
text
@d4 3
d79 2
a82 1
require "../utils/crash";
d85 1
a87 1
   structure Crash : CRASH
d103 6
d110 1
a110 2
    fun edit _ _ = 
      (MLWorks.Option.SOME ("Not implemented"), null_fun)
d112 114
a225 2
    fun edit_from_location _ _ = 
      (MLWorks.Option.SOME ("Not implemented"), null_fun)
a226 2
    fun show_location _ _ =
      (MLWorks.Option.SOME ("Not implemented"), null_fun)
@


1.20
log
@OS reorganisation: Remove all the Unix specific stuff since
this never worked and since the Unix structure is no longer
part of the pervasive library won't even compile.
@
text
@d4 5
a75 1
require "../make/os";
a84 1
   structure Os : OS
@


1.19
log
@Changed name of e-lisp highlight function to mlworks-highlight.
@
text
@d4 3
d75 1
a75 1
require "editor";
a81 1
   val server_socket_name : string
d97 8
a104 142
    fun emacs (filename, s_line, s_col, e_line, e_col, raise_window) =
      let
        val s = MLWorks.OS.Unix.socket (1, 1, 0)
      in
	let
	  val find_file =
            ["(find-file \"", filename, "\")\n"]

          val goto_line =
            ["(goto-line ", MLWorks.Integer.makestring s_line, ")\n"]

          val forward_char =
            ["(forward-char ", MLWorks.Integer.makestring s_col, ")\n"]
  
	  val set_highlight =
	    if e_line <> ~1 then
	      ["(mlworks-highlight ",
	       MLWorks.Integer.makestring s_line, " ",
	       MLWorks.Integer.makestring s_col, " ",
	       MLWorks.Integer.makestring e_line, " ",
	       MLWorks.Integer.makestring e_col, ")\n"]
	    else
	      ["\n"]
  
	  val raise_code =
	    if raise_window then
	      ["(raise-this-window)\n"]
	    else
	      []
        in
	  MLWorks.OS.Unix.connect
            (s, MLWorks.OS.Unix.SOCKADDR_UNIX
	          (implode [Os.home "", "/", server_socket_name]));
          MLWorks.OS.Unix.write (s, implode find_file);
          MLWorks.OS.Unix.write
	    (s, implode (["(progn "] @@ goto_line @@ forward_char
			 @@ set_highlight @@ raise_code @@ [")"]));
          MLWorks.OS.Unix.close s;
          (MLWorks.Option.NONE, null_fun)
        end
	handle
	MLWorks.OS.Unix.Unix msg =>
          (MLWorks.OS.Unix.close s;
           (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server",
	    null_fun))
      end
      handle MLWorks.OS.Unix.Unix _ =>
        (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server", null_fun)

    fun parse_command (s, filename, line) =
      let fun parse (~1, [], list) = list
          |   parse (~1, word, list) = implode word :: list
	  |   parse (i, word, list) =
	    let val ch = String.ordof (s, i)
	    in
	      if ch = ord " " then
		case word of
		  [] => parse (i-1, [], list)
	        | _  => parse (i-1, [], implode (word) :: list)
	      else if ch = ord "l" andalso i > 0
		   andalso String.ordof (s, i-1) = ord "%" then
                   parse (i-2, MLWorks.Integer.makestring line :: word, list)
	      else
	        parse (i-1, chr ch :: word, list)
	    end
      in
	parse (size s - 1, [], [filename])
      end

    fun xterm parsed_command =
      let
        val pid = 
          (MLWorks.OS.Unix.vfork_execvp
             ("xterm", ["xterm", "-name", "visual", "-e"] @@ parsed_command))
      in
        (MLWorks.Option.NONE,fn () =>
         MLWorks.OS.Unix.kill (pid,9)
         handle MLWorks.OS.Unix.Unix _ => ())
      end
      handle MLWorks.OS.Unix.Unix _ =>
        (MLWorks.Option.SOME ("Unable to launch xterm editor processes"),null_fun)

    fun x (parsed_command as command :: _) =
      (let
         val pid = 
           (MLWorks.OS.Unix.vfork_execvp
              (command, parsed_command))
       in
         (MLWorks.Option.NONE,fn () =>
          MLWorks.OS.Unix.kill (pid,9)
          handle MLWorks.OS.Unix.Unix _ => ())
       end
       handle MLWorks.OS.Unix.Unix _ =>
         (MLWorks.Option.SOME ("Unable to launch x editor process"),null_fun))
    |  x nil = Crash.impossible "nil argument to x editor"

    fun edit
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
	        {editor, x_editor_command, xterm_editor_command, ...},
	      ...})
          (string, i) =
      case !editor of
        "emacs_server" => emacs (string, i, 0, ~1, ~1, true)
      | "xterm" => xterm (parse_command (!xterm_editor_command, string, i))
      | "x" =>
	x (parse_command (!x_editor_command, string, i))
      | _ => (MLWorks.Option.SOME ("Unknown editor `" ^ !editor ^ "'"),null_fun)

    fun edit_from_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
	        {editor, x_editor_command, xterm_editor_command, ...},
	      ...})
          (string, location) =
      case !editor of
        "emacs_server" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   emacs (string, s_line, s_col, e_line, e_col, true)
	 |  _ => emacs (string, line_from_location location, 0, ~1, ~1, true))
      | "xterm" =>
	xterm (parse_command
		 (!xterm_editor_command, string, line_from_location location))
      | "x" =>
	x (parse_command
	     (!x_editor_command, string, line_from_location location))
      | _ => (MLWorks.Option.SOME ("Unknown editor `" ^ !editor ^ "'"),null_fun)

    fun show_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
	        {editor, x_editor_command, xterm_editor_command, ...},
	      ...})
          (string, location) =
      case !editor of
        "emacs_server" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   emacs (string, s_line, s_col, e_line, e_col, false)
	 |  _ => emacs (string, line_from_location location, 0, ~1, ~1, false))
      | _ => (MLWorks.Option.SOME ("Show location require emacs"), null_fun)
@


1.18
log
@Sent the emacs commands as separate S-expressions, to avoid buffer
overflow problems.
@
text
@d4 4
d111 1
a111 1
	      ["(set-highlight ",
@


1.17
log
@Made emacs highlight errors.
Removed next_error and no_more_errors.
@
text
@d4 4
d90 2
a91 1
    fun emacs (filename, s_line, s_col, e_line, e_col) =
a93 19

	val find_file =
	  ["(progn (find-file \"",
           filename,
           "\") (goto-line ",
           MLWorks.Integer.makestring s_line,
           ") (forward-char ",
	   MLWorks.Integer.makestring s_col,
	   ")"]
	
	val set_highlight =
	  if e_line <> ~1 then
	    ["(set-highlight ",
	     MLWorks.Integer.makestring s_line, " ",
	     MLWorks.Integer.makestring s_col, " ",
	     MLWorks.Integer.makestring e_line, " ",
	     MLWorks.Integer.makestring e_col, "))\n"]
	  else
	    [")\n"]
d95 41
a135 6
        MLWorks.OS.Unix.connect
          (s, MLWorks.OS.Unix.SOCKADDR_UNIX
	        (implode [Os.home "", "/", server_socket_name]));
        MLWorks.OS.Unix.write (s, implode (find_file @@ set_highlight));
        MLWorks.OS.Unix.close s;
        (MLWorks.Option.NONE, null_fun)
d138 1
a138 1
        (MLWorks.Option.SOME ("Unable to contact MLWorks Emacs server"), null_fun)
d194 1
a194 1
        "emacs_server" => emacs (string, i, 0, ~1, ~1)
d210 2
a211 2
	   emacs (string, s_line, s_col, e_line, e_col)
	 |  _ => emacs (string, line_from_location location, 0, ~1, ~1))
d219 14
@


1.16
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d4 3
a77 2
    exception no_more_errors

d86 1
a86 1
    fun emacs (filename, line) =
d89 19
d110 3
a112 6
        (s, MLWorks.OS.Unix.SOCKADDR_UNIX (implode [Os.home "", "/", server_socket_name]));
        MLWorks.OS.Unix.write (s, implode ["(progn (find-file \"",
                                           filename,
                                           "\") (goto-line ",
                                           MLWorks.Integer.makestring line,
                                           "))\n"]);
d114 1
a114 1
        (MLWorks.Option.NONE,null_fun)
d167 5
a171 5
      (Preferences.PREFERENCES
         {editor_options=Preferences.EDITOR_OPTIONS
	    {editor, x_editor_command, xterm_editor_command, ...},
	  ...})
      (string, i) =
d173 1
a173 1
        "emacs_server" => emacs (string, i)
d179 19
a197 17
    fun edit_from_location options (string, location) =
      edit options (string, line_from_location location)

    fun next_error options [] = raise no_more_errors
      | next_error options ((location, string) :: rest) =
	let
	  val file = case location of
	    Location.UNKNOWN => Crash.impossible("Unknown error location")
	  | Location.FILE file => file
	  | Location.LINE(file, _) => file
	  | Location.POSITION(file, _, _) => file
	  | Location.EXTENT{name=file, ...} => file
	in
	  output(std_out, string ^ "\n");
	  edit_from_location options (file, location);
	  rest
	end
@


1.15
log
@Move OS specific stuff into a system link directory
@
text
@d4 3
a57 1
require "../main/options";
a59 1
require "../utils/option";
a64 1
   structure Option : OPTION
a71 1
    structure Option = Option
d97 1
a97 1
        (Option.ABSENT,null_fun)
d100 1
a100 1
        (Option.PRESENT ("Unable to contact MLWorks Emacs server"), null_fun)
d128 1
a128 1
        (Option.ABSENT,fn () =>
d133 1
a133 1
        (Option.PRESENT ("Unable to launch xterm editor processes"),null_fun)
d141 1
a141 1
         (Option.ABSENT,fn () =>
d146 1
a146 1
         (Option.PRESENT ("Unable to launch x editor process"),null_fun))
d160 1
a160 1
      | _ => (Option.PRESENT ("Unknown editor `" ^ !editor ^ "'"),null_fun)
@


1.14
log
@Reinstate call to makestring
@
text
@d4 3
d54 1
a59 1
require "../make/unix";
d67 1
a67 1
   structure Unix : UNIX
d91 1
a91 1
        (s, MLWorks.OS.Unix.SOCKADDR_UNIX (implode [Unix.home "", "/", server_socket_name]));
@


1.13
log
@Added support for user-defined editors.
@
text
@d4 3
d112 1
a112 1
	        parse (i-2, (* MLWorks.Integer.makestring line *) "23" :: word, list)
@


1.12
log
@Moved preferences into separate structure.
@
text
@d4 3
d97 21
a117 1
    fun vi (filename, line) =
d121 1
a121 2
           ("xterm", ["xterm", "-name", "visual",
                      "-e", "vi", "+" ^ MLWorks.Integer.makestring line, filename]))
d128 15
a142 1
        (Option.PRESENT ("Unable to launch vi process"),null_fun)
d146 3
a148 1
         {editor_options=Preferences.EDITOR_OPTIONS{editor, ...}, ...})
d151 4
a154 2
        "emacs" => emacs (string, i)
      | "vi" => vi (string, i)
@


1.11
log
@reversed arguments to kill
added handler for Unix exception
@
text
@d4 4
d46 1
d53 9
a61 8
functor Editor(
  structure Options : OPTIONS
  structure Option : OPTION
  structure Crash : CRASH
  structure Location : LOCATION
  structure Unix : UNIX
  val server_socket_name : string) : EDITOR =
  struct
d64 2
a65 1
    structure Options = Options
d109 2
a110 2
      (Options.OPTIONS
       {editor_options=Options.EDITOR_OPTIONS{editor, ...}, ...})
@


1.11.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.11  1993/08/31  11:29:18  matthew
reversed arguments to kill
added handler for Unix exception

@


1.10
log
@Added call to Unix.kill
@
text
@d4 3
d94 3
a96 1
        (Option.ABSENT,fn () => MLWorks.OS.Unix.kill (9,pid))
@


1.9
log
@Return quit function from ShellUtils.edit_string
Need to uncomment call to kill]
@
text
@d4 4
d91 1
a91 1
        (Option.ABSENT,fn () => output(std_out,"Poo\n") (* MLWorks.OS.Unix.kill pid *))
@


1.8
log
@Removed filename component of error result for edit functions.
@
text
@d4 3
d61 2
d75 1
a75 1
        Option.ABSENT
d78 1
a78 1
        Option.PRESENT ("Unable to contact MLWorks Emacs server")
d81 8
a88 4
      (MLWorks.OS.Unix.vfork_execvp
       ("xterm", ["xterm", "-name", "visual",
                  "-e", "vi", "+" ^ MLWorks.Integer.makestring line, filename]);
       Option.ABSENT)
d90 1
a90 1
        Option.PRESENT ("Unable to launch vi process")
d99 1
a99 1
      | _ => Option.PRESENT ("Unknown editor `" ^ !editor ^ "'")
@


1.7
log
@Changed Integer.makestring to MLWorks.Integer.makestring and removed
the Integer structure.
@
text
@d4 4
d73 1
a73 1
        Option.PRESENT (filename, "Unable to contact MLWorks Emacs server")
d81 1
a81 1
        Option.PRESENT (filename, "Unable to launch vi process")
d90 1
a90 1
      | _ => Option.PRESENT (string, "Unknown editor `" ^ !editor ^ "'")
@


1.6
log
@The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.
@
text
@d4 5
a29 1
require "../utils/integer";
a36 1
  structure Integer : INTEGER
d63 1
a63 1
                                           Integer.makestring line,
d74 1
a74 1
                  "-e", "vi", "+" ^ Integer.makestring line, filename]);
d83 1
a83 1
      case editor of
d86 1
a86 1
      | _ => Option.PRESENT (string, "Unknown editor `" ^ editor ^ "'")
@


1.5
log
@Added editing from location. Added a function to do next error from a list
@
text
@d4 3
d27 1
d35 3
a37 1
  structure Location : LOCATION) : EDITOR =
d45 5
a49 5
    fun line_from_location(Location.UNKNOWN) = "+0"
      | line_from_location(Location.FILE _) = "+0"
      | line_from_location(Location.LINE(_, i)) = "+" ^ Integer.makestring i
      | line_from_location(Location.POSITION(_, i, _)) = "+" ^ Integer.makestring i
      | line_from_location(Location.EXTENT{s_line=i, ...}) = "+" ^ Integer.makestring i
d51 16
a66 10
    fun edit_from_location
      (Options.OPTIONS
       {editor_options=Options.EDITOR_OPTIONS{editor, ...}, ...})
      (string, location) =
      ((case editor of
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file [string]
	| MLWorks.Editor.VI =>
	    MLWorks.Editor.vi_file [line_from_location location, string]);
	  Option.ABSENT)
      handle MLWorks.Editor.NotFound arg => Option.PRESENT arg
d68 8
d80 7
a86 6
      ((case editor of
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file[string]
	| MLWorks.Editor.VI =>
	    MLWorks.Editor.vi_file["+" ^ Integer.makestring i, string]);
	  Option.ABSENT)
      handle MLWorks.Editor.NotFound arg => Option.PRESENT arg
@


1.4
log
@Modify edit and edit_from_location to use the relevant editor
@
text
@d4 3
d22 2
d29 2
d37 8
d50 3
a52 3
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file
	| MLWorks.Editor.VI => MLWorks.Editor.vi_file)
	  [string];
d61 3
a63 2
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file
	| MLWorks.Editor.VI => MLWorks.Editor.vi_file)[string];
d66 15
@


1.3
log
@Added options parameter
@
text
@d4 3
d34 5
a38 2
      (MLWorks.Editor.load_file[string];
       Option.ABSENT)
d45 4
a48 2
      (MLWorks.Editor.load_file[string];
       Option.ABSENT)
@


1.2
log
@Changed editor implementastion slightly.
@
text
@d4 3
d13 1
d19 1
d25 1
d27 4
a30 1
    fun edit_from_location (string, location) =
d35 4
a38 1
    fun edit(string, i) =
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d22 1
a22 1
      (MLWorks.Editor.load_file string;
d27 1
a27 1
      (MLWorks.Editor.load_file string;
@
