head	1.14;
access;
symbols
	MLW_daveb_inline_1_4_99:1.14.1
	MLWorks_21c0_1999_03_25:1.14
	MLWorks_20c1_1998_08_20:1.13
	MLWorks_20c0_1998_08_04:1.13
	MLWorks_20b2c2_1998_06_19:1.13
	MLWorks_20b2_Windows_1998_06_12:1.13
	MLWorks_20b1c1_1998_05_07:1.13
	MLWorks_20b0_1998_04_07:1.13
	MLWorks_20b0_1998_03_20:1.13
	MLWorks_20m2_1998_02_16:1.12
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.10.5.1.1.1.1
	MLWorks_workspace_97:1.11.2
	MLWorks_dt_wizard:1.11.1
	MLWorks_11c0_1997_09_09:1.10.5.1.1.1
	MLWorks_10r3:1.10.5.1.3
	MLWorks_10r2_551:1.10.5.1.2
	MLWorks_11:1.10.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.5.1
	MLWorks_20m0_1997_06_20:1.11
	MLWorks_1_0_r2c2_1997_06_14:1.10.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.5
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.3.1.1
	MLWorks_gui_1996_12_18:1.10.4
	MLWorks_1_0_Win32_1996_12_17:1.10.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.1.1
	MLWorks_1_0_Irix_1996_11_28:1.10.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.2
	MLWorks_1_0_Unix_1996_11_14:1.10.1
	MLWorks_Open_Beta2_1996_10_11:1.8.3
	MLWorks_License_dev:1.8.2
	MLWorks_1_open_beta_1996_09_13:1.8.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8;
locks; strict;
comment	@ * @;


1.14
date	99.02.02.15.59.54;	author mitchell;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	98.02.19.17.07.44;	author mitchell;	state Exp;
branches;
next	1.12;

1.12
date	97.09.19.09.19.48;	author brucem;	state Exp;
branches;
next	1.11;

1.11
date	97.05.21.17.07.12;	author jont;	state Exp;
branches
	1.11.1.1
	1.11.2.1;
next	1.10;

1.10
date	96.11.06.11.12.40;	author matthew;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1
	1.10.4.1
	1.10.5.1;
next	1.9;

1.9
date	96.10.31.15.02.24;	author io;	state Exp;
branches;
next	1.8;

1.8
date	96.05.01.12.56.56;	author jont;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1;
next	1.7;

1.7
date	96.04.30.13.20.57;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	94.11.30.15.42.27;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	94.10.27.14.48.10;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.10.19.15.14.44;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.10.18.14.14.01;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.09.16.13.26.57;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.09.09.14.55.00;	author jont;	state Exp;
branches;
next	;

1.8.1.1
date	96.09.13.11.15.19;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.10.07.16.05.37;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.10.17.11.23.53;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.11.14.12.48.19;	author hope;	state Exp;
branches
	1.10.1.1.1.1;
next	;

1.10.1.1.1.1
date	96.11.28.14.59.50;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.11.22.18.08.16;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.12.17.17.46.58;	author hope;	state Exp;
branches
	1.10.3.1.1.1;
next	;

1.10.3.1.1.1
date	97.02.24.11.36.38;	author hope;	state Exp;
branches;
next	;

1.10.4.1
date	96.12.18.09.40.56;	author hope;	state Exp;
branches;
next	;

1.10.5.1
date	97.05.12.10.33.21;	author hope;	state Exp;
branches
	1.10.5.1.1.1
	1.10.5.1.2.1
	1.10.5.1.3.1;
next	;

1.10.5.1.1.1
date	97.07.28.18.18.42;	author daveb;	state Exp;
branches
	1.10.5.1.1.1.1.1;
next	;

1.10.5.1.1.1.1.1
date	97.10.07.11.43.45;	author jkbrook;	state Exp;
branches;
next	;

1.10.5.1.2.1
date	97.09.08.17.12.16;	author daveb;	state Exp;
branches;
next	;

1.10.5.1.3.1
date	97.09.09.14.07.54;	author daveb;	state Exp;
branches;
next	;

1.11.1.1
date	97.09.10.19.22.51;	author brucem;	state Exp;
branches;
next	;

1.11.2.1
date	97.09.11.20.54.01;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	99.04.01.17.56.24;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.14
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _i386print.sml the functor *)
(*
$Log: _i386print.sml,v $
 * Revision 1.13  1998/02/19  17:07:44  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.12  1997/09/19  09:19:48  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.11  1997/05/21  17:07:12  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.10  1996/11/06  11:12:40  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.9  1996/10/31  15:02:24  io
 * removing toplevel String.
 *
 * Revision 1.8  1996/05/01  12:56:56  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.7  1996/04/30  13:20:57  matthew
 * Removing use of MLWorks.Integer
 *
 * Revision 1.6  1994/11/30  15:42:27  matthew
 * Made printing bytes optional
 *
Revision 1.5  1994/10/27  14:48:10  jont
Remove debugging print statements

Revision 1.4  1994/10/19  15:14:44  jont
Fix label calculation

Revision 1.3  1994/10/18  14:14:01  jont
Fix printing for mutually recursive functions

Revision 1.2  1994/09/16  13:26:57  jont
Add printing of binary form at present

Revision 1.1  1994/09/09  14:55:00  jont
new file

Copyright (c) 1994 Harlequin Ltd.
*)

require "../basis/__text_io";

require "../utils/lists";
require "i386_assembly";
require "../main/machprint";
require "^.basis.__string_cvt";

functor I386Print(
  structure Lists : LISTS
  structure I386_Assembly : I386_ASSEMBLY
) : MACHPRINT =
struct
  structure I386_Assembly = I386_Assembly
  structure I386_Opcodes = I386_Assembly.I386_Opcodes

  type Opcode = I386_Assembly.opcode

  val print_bytes = true

  val opcol = 35
  val labcol = 8

  fun pad columns x = 
    StringCvt.padRight #" " columns x

  fun print_nibble i =
    if i >= 0 andalso i <= 9 then
      chr (i+ ord #"0")
    else
      if i >= 10 andalso i <= 16 then
	chr(i+ ord #"a" - 10)
      else
	raise Match

  fun print_byte i =
    let
      val hi = (i div 16) mod 16
      val lo = i mod 16
    in
      str (print_nibble hi) ^ str (print_nibble lo) ^ " "
    end

  val max_bytes = 12

  fun space_pad 0 = []
    | space_pad n =
      if n < 0 then raise Match else "   " :: space_pad(n-1)

  fun double_align n = ((n+7) div 8) * 8

  (* This could be somewhat better coded *)
  (* The diddling with +- 2 is to cope with backptr slots *)
  (* Now +-8 as we're working in bytes *)
  fun print_code (stream,labmap) (n,((tag, code),name)) =
    (TextIO.output(stream, ("[I386_Assembly Code]" ^ " for " ^ name ^
		     (*"at offset " ^ Int.toString(n + 8) ^ *)"\n"));
     Lists.reducel
     (fn (n,(x,y)) =>
      let
	val I386_Opcodes.OPCODE byte_list = I386_Assembly.assemble x
        val (lab,ass) = I386_Assembly.labprint (x,n,labmap)
	val bytes = length byte_list
	val code = if print_bytes then map print_byte byte_list else []
	val padding =
          if print_bytes then
	    if bytes > max_bytes then
	      (print"Strange, very long opcode sequence";
	       [])
	    else
	      space_pad(max_bytes - bytes)
          else []
        val line =
          if size y = 0 then
	    concat (padding @@ code @@ [pad labcol lab,ass,"\n"])
          else
            concat (padding @@ code @@ [pad labcol lab,pad opcol ass,"; ",y,"\n"])
      in
        TextIO.output(stream,line);
        n+I386_Assembly.opcode_size x
      end)
     (double_align n + 8,code))

  fun print_mach_code code_list_list stream =
    let
      val labmap = 
        I386_Assembly.make_labmap 
        (map
         (fn code_list =>
          map 
          (fn ((tag,code),name) => (map (fn (x,y) => x) code))
          code_list)
         code_list_list)
    in
      ignore(Lists.reducel
        (fn (n,code_list) =>
         Lists.reducel (print_code (stream,labmap)) (double_align n,code_list))
        (0,code_list_list));
      ()
    end
end
@


1.14.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.14  1999/02/02  15:59:54  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.13
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
a52 1
require "../basis/__int";
@


1.12
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 4
d143 4
a146 4
      Lists.reducel
      (fn (n,code_list) =>
       Lists.reducel (print_code (stream,labmap)) (double_align n,code_list))
      (0,code_list_list);
@


1.11
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d4 4
a50 1
require "^.basis.__old";
@


1.11.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.11  1997/05/21  17:07:12  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.11.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.11  1997/05/21  17:07:12  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.10
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d42 1
d97 1
a97 1
    (MLWorks.IO.output(stream, ("[I386_Assembly Code]" ^ " for " ^ name ^
d107 6
a112 7
          if print_bytes
            then
              if bytes > max_bytes then
                (MLWorks.IO.output(MLWorks.IO.std_out, "Strange, very long opcode sequence");
                 [])
              else
                space_pad(max_bytes - bytes)
d120 1
a120 1
        MLWorks.IO.output(stream,line);
@


1.10.5.1
log
@branched from 1.10
@
text
@a3 4
 * Revision 1.10  1996/11/06  11:12:40  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.10.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.10.5.1  1997/05/12  10:33:21  hope
 * branched from 1.10
 *
@


1.10.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.10.5.1  1997/05/12  10:33:21  hope
 * branched from 1.10
 *
@


1.10.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.10.5.1  1997/05/12  10:33:21  hope
 * branched from 1.10
 *
@


1.10.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.10.5.1.1.1  1997/07/28  18:18:42  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.10.4.1
log
@branched from 1.10
@
text
@a3 4
 * Revision 1.10  1996/11/06  11:12:40  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.10.3.1
log
@branched from 1.10
@
text
@a3 4
 * Revision 1.10  1996/11/06  11:12:40  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.10.3.1.1.1
log
@branched from 1.10.3.1
@
text
@a3 3
 * Revision 1.10.3.1  1996/12/17  17:46:58  hope
 * branched from 1.10
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a3 4
 * Revision 1.10  1996/11/06  11:12:40  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a3 4
 * Revision 1.10  1996/11/06  11:12:40  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.10.1.1.1.1
log
@branched from 1.10.1.1
@
text
@a3 3
 * Revision 1.10.1.1  1996/11/14  12:48:19  hope
 * branched from 1.10
 *
@


1.9
log
@removing toplevel String.
@
text
@d4 3
d37 1
a37 1
require "../basis/__integer";
@


1.8
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d39 2
d57 2
a58 13
  fun make_spaces (string,n) =
    let
      fun mk (0,acc) = acc
        | mk (n,acc) = mk (n-1," " :: acc)
    in
      String.implode (string :: mk (n,[]))
    end

  fun pad columns x =
    if size x < columns
      then 
        make_spaces (x,columns-size x)
    else x
d62 1
a62 1
      String.chr (i+String.ord"0")
d65 1
a65 1
	String.chr(i+String.ord"a"-10)
d74 1
a74 1
      print_nibble hi ^ print_nibble lo ^ " "
d96 1
a96 1
	val bytes = Lists.length byte_list
d109 1
a109 1
	    String.implode (padding @@ code @@ [pad labcol lab,ass,"\n"])
d111 1
a111 1
            String.implode (padding @@ code @@ [pad labcol lab,pad opcol ass,"; ",y,"\n"])
@


1.8.3.1
log
@branched from 1.8
@
text
@a3 6
 * Revision 1.8  1996/05/01  12:56:56  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a3 6
 * Revision 1.8  1996/05/01  12:56:56  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a3 6
 * Revision 1.8  1996/05/01  12:56:56  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.7
log
@Removing use of MLWorks.Integer
@
text
@d4 3
d54 1
a54 1
      implode (string :: mk (n,[]))
d65 1
a65 1
      chr (i+ord"0")
d68 1
a68 1
	chr(i+ord"a"-10)
d92 1
a92 1
    (output(stream, ("[I386_Assembly Code]" ^ " for " ^ name ^
d105 1
a105 1
                (output(std_out, "Strange, very long opcode sequence");
d112 1
a112 1
	    implode (padding @@ code @@ [pad labcol lab,ass,"\n"])
d114 1
a114 1
            implode (padding @@ code @@ [pad labcol lab,pad opcol ass,"; ",y,"\n"])
d116 1
a116 1
        output(stream,line);
@


1.6
log
@Made printing bytes optional
@
text
@d4 3
d25 2
d90 1
a90 1
		     (*"at offset " ^ MLWorks.Integer.makestring(n + 8) ^ *)"\n"));
@


1.5
log
@Remove debugging print statements
@
text
@d4 3
d36 2
d39 1
a39 1
  val labcol = 5
d92 1
a92 1
	val code = map print_byte byte_list
d94 8
a101 5
	  if bytes > max_bytes then
	    (output(std_out, "Strange, very long opcode sequence");
	     [])
	  else
	    space_pad(max_bytes - bytes)
@


1.4
log
@Fix label calculation
@
text
@d4 3
d80 1
a80 1
		     "at offset " ^ MLWorks.Integer.makestring(n + 8) ^ "\n"));
@


1.3
log
@Fix printing for mutually recursive functions
@
text
@d4 3
d76 2
a77 1
    (output(stream, ("[I386_Assembly Code]" ^ " for " ^ name ^ "\n"));
d100 1
a100 1
     (double_align(n+8),code))
d114 2
a115 1
      (fn (n,code_list) => Lists.reducel (print_code (stream,labmap)) (n-8,code_list))
@


1.2
log
@Add printing of binary form at present
@
text
@d4 3
d67 2
d96 1
a96 1
     (n+8,code))
@


1.1
log
@new file
@
text
@d3 4
a6 1
$Log$
d20 1
d41 23
d72 1
d74 8
d83 2
a84 2
          if size y = 0
            then implode [pad labcol lab,ass,"\n"]
d86 1
a86 1
            implode [pad labcol lab,pad opcol ass,"; ",y,"\n"]
@
