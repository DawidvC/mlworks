head	1.14;
access;
symbols
	MLW_daveb_inline_1_4_99:1.14.1
	MLWorks_21c0_1999_03_25:1.14
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.13
	MLWorks_20b2_Windows_1998_06_12:1.13
	MLWorks_20b1c1_1998_05_07:1.13
	MLWorks_20b0_1998_04_07:1.13
	MLWorks_20b0_1998_03_20:1.13
	MLWorks_20m2_1998_02_16:1.13
	MLWorks_20m1_1997_10_23:1.13
	MLWorks_11r1:1.12.5.1.1.1.1
	MLWorks_workspace_97:1.13.2
	MLWorks_dt_wizard:1.13.1
	MLWorks_11c0_1997_09_09:1.12.5.1.1.1
	MLWorks_10r3:1.12.5.1.3
	MLWorks_10r2_551:1.12.5.1.2
	MLWorks_11:1.12.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.12.5.1
	MLWorks_20m0_1997_06_20:1.13
	MLWorks_1_0_r2c2_1997_06_14:1.12.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.12.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.12.5
	MLWorks_BugFix_1997_04_24:1.12
	MLWorks_1_0_r2_Win32_1997_04_11:1.12
	MLWorks_1_0_r2_Unix_1997_04_04:1.12
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.12.3.1.1
	MLWorks_gui_1996_12_18:1.12.4
	MLWorks_1_0_Win32_1996_12_17:1.12.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.12.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.12.1.1
	MLWorks_1_0_Irix_1996_11_28:1.12.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.12.2
	MLWorks_1_0_Unix_1996_11_14:1.12.1
	MLWorks_Open_Beta2_1996_10_11:1.10.3
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.10
	MLWorks_Beta_1996_06_07:1.10
	MLWorks_Beta_1996_06_06:1.10
	MLWorks_Beta_1996_06_05:1.10
	MLWorks_Beta_1996_06_03:1.10
	MLWorks_Beta_1996_05_31:1.10
	MLWorks_Beta_1996_05_30:1.10;
locks; strict;
comment	@ * @;


1.14
date	98.06.29.13.17.21;	author jont;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	97.05.06.10.02.48;	author jont;	state Exp;
branches
	1.13.1.1
	1.13.2.1;
next	1.12;

1.12
date	96.11.06.10.53.26;	author andreww;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1
	1.12.4.1
	1.12.5.1;
next	1.11;

1.11
date	96.10.28.15.21.51;	author andreww;	state Exp;
branches;
next	1.10;

1.10
date	96.04.04.13.03.40;	author jont;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1;
next	1.9;

1.9
date	95.12.20.14.14.31;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	94.12.09.13.27.56;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	94.12.08.11.06.07;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	94.11.15.15.28.08;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.09.20.14.48.49;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.09.19.13.46.52;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.09.16.12.34.09;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.09.15.15.52.49;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.09.08.16.29.36;	author jont;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.15.09;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.05.29;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.10.17.11.23.44;	author hope;	state Exp;
branches;
next	;

1.12.1.1
date	96.11.14.12.48.08;	author hope;	state Exp;
branches
	1.12.1.1.1.1;
next	;

1.12.1.1.1.1
date	96.11.28.14.59.41;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.11.22.18.08.08;	author hope;	state Exp;
branches;
next	;

1.12.3.1
date	96.12.17.17.46.50;	author hope;	state Exp;
branches
	1.12.3.1.1.1;
next	;

1.12.3.1.1.1
date	97.02.24.11.36.28;	author hope;	state Exp;
branches;
next	;

1.12.4.1
date	96.12.18.09.40.48;	author hope;	state Exp;
branches;
next	;

1.12.5.1
date	97.05.12.10.33.11;	author hope;	state Exp;
branches
	1.12.5.1.1.1
	1.12.5.1.2.1
	1.12.5.1.3.1;
next	;

1.12.5.1.1.1
date	97.07.28.18.18.33;	author daveb;	state Exp;
branches
	1.12.5.1.1.1.1.1;
next	;

1.12.5.1.1.1.1.1
date	97.10.07.11.43.37;	author jkbrook;	state Exp;
branches;
next	;

1.12.5.1.2.1
date	97.09.08.17.12.08;	author daveb;	state Exp;
branches;
next	;

1.12.5.1.3.1
date	97.09.09.14.07.46;	author daveb;	state Exp;
branches;
next	;

1.13.1.1
date	97.09.10.19.22.41;	author brucem;	state Exp;
branches;
next	;

1.13.2.1
date	97.09.11.20.53.52;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	99.04.01.17.56.18;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.14
log
@[Bug #20117]
Add align directive for benefit of jump tables
@
text
@(* i386_assembly.sml the signature *)
(*
$Log: i386_assembly.sml,v $
 * Revision 1.13  1997/05/06  10:02:48  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.12  1996/11/06  10:53:26  andreww
 * [Bug #1734]
 * Changing type Backend_Annotation to eqtype Backend_Annotation.
 *
 * Revision 1.11  1996/10/28  15:21:51  andreww
 * [Bug #1707]
 * threading debugger information.
 *
 * Revision 1.10  1996/04/04  13:03:40  jont
 * Allow offsets in mem_operands to be bigger than an int, to cope with words
 *
 * Revision 1.9  1995/12/20  14:14:31  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
Revision 1.8  1994/12/09  13:27:56  matthew
Added fnclex

Revision 1.7  1994/12/08  11:06:07  matthew
Added FP opcodes

Revision 1.6  1994/11/15  15:28:08  jont
Add fixed length rel32 type for use in switches

Revision 1.5  1994/09/20  14:48:49  jont
Get type of reverse_branch right

Revision 1.4  1994/09/19  13:46:52  jont
Add print_mnemonic function

Revision 1.3  1994/09/16  12:34:09  jont
Change 32 bit immediates to be pairs to get full range

Revision 1.2  1994/09/15  15:52:49  jont
Make option an eqtype

Revision 1.1  1994/09/08  16:29:36  jont
new file

Copyright (c) 1994 Harlequin Ltd.
*)

require "i386_opcodes";

signature I386_ASSEMBLY = sig
  structure I386_Opcodes : I386_OPCODES

  type ''a Set

  type tag (* MirTypes.tag *)
  eqtype Backend_Annotation (* MirTypes.Debugger_Types.Backend_Annotation *)

  datatype ('a, 'b)union = INL of 'a | INR of 'b

  datatype cc =
    above
  | above_or_equal
  | below
  | below_or_equal
  | cx_equal_zero
  | ecx_equal_zero
  | equal
  | greater
  | greater_or_equal
  | less
  | less_or_equal
  | not_equal
  | not_overflow
  | not_parity
  | not_sign
  | overflow
  | parity
  | sign

  datatype mnemonic =
    aaa
  | aad
  | aam
  | aas
  | adc
  | add
  | align
  | and_op
  | arpl
  | bound
  | bsf
  | bsr
  | bt
  | btc
  | btr
  | bts
  | call
  | cbw
  | cwde
  | clc
  | cld
  | cli
  | clts
  | cmc
  | cmp
  | cmps
  | cmpsb
  | cmpsw
  | cmpsd
  | cwd
  | cdq
  | daa
  | das
  | dec
  | div_op
  | enter
  (* Floating point *)
  | fld
  | fst
  | fstp
  | fild
  | fist
  | fistp
  (* Binary ops *)
  | fadd
  | fsub
  | fsubr
  | fmul
  | fdiv
  | fdivr
  (* Unary ops *)
  | fabs
  | fpatan
  | fchs
  | fcos
  | fsin
  | fsqrt
  | fptan
  | fldz
  | fld1
  | fyl2x
  | fyl2xp
  | f2xm1
  (* Comparisons & tests *)
  (* No integer comparisons for the moment *)
  | fcom
  | fcomp
  | fcompp
  | fucom
  | fucomp
  | fucompp
  | ftst
  | fxam
  (* Control *)
  | fldcw
  | fstcw 
  | fnstcw
  | fstsw
  | fstsw_ax
  | fnstsw
  | fnclex
  (* End floating point *)
  | hlt
  | idiv
  | imul
  | in_op
  | inc
  | ins
  | insb
  | insw
  | insd
  | int
  | into
  | iret
  | iretd
  | jcc of cc
  | jmp
  | lahf
  | lar
  | lea
  | leave
  | lgdt
  | lidt
  | lgs
  | lss
  | lds
  | les
  | lfs
  | lldt
  | lmsw
  | lock
  | lods
  | lodsb
  | lodsw
  | lodsd
  | loop
  | loopz
  | loopnz
  | lsl
  | ltr
  | mov
  | movs
  | movsb
  | movsw
  | movsd
  | movsx
  | movzx
  | mul
  | neg
  | nop
  | not
  | or
  | out
  | outs
  | outsb
  | outsw
  | outsd
  | pop
  | popa
  | popad
  | popf
  | popfd
  | push
  | pusha
  | pushad
  | pushf
  | pushfd
  | rcl
  | rcr
  | rol
  | ror
  | rep
  | repz
  | repnz
  | ret
  | sahf
  | sal
  | sar
  | shl
  | shr
  | sbb
  | scas
  | scasb
  | scasw
  | scasd
  | setcc of cc
  | sgdt
  | sidt
  | shld
  | shrd
  | sldt
  | smsw
  | stc
  | std
  | sti
  | stos
  | stosb
  | stosw
  | stosd
  | str
  | sub
  | test
  | verr
  | verw
  | wait
  | xchg
  | xlat
  | xlatb
  | xor

  datatype offset_operand =
    SMALL of int
  | LARGE of int * int

  datatype mem_operand =
    MEM of {base: I386_Opcodes.I386Types.I386_Reg option,
	    index: (I386_Opcodes.I386Types.I386_Reg * int option) option,
	    offset: offset_operand option}
	    
  (* Note, the 32 bit quantities may need to be made larger (ie more than one int) *)

  datatype adr_mode =
    rel8 of int
  | rel16 of int
  | rel32 of int
  | fix_rel32 of int
  | ptr16_16 of int * int
  | ptr16_32 of int * int
  | r8 of I386_Opcodes.I386Types.I386_Reg
  | r16 of I386_Opcodes.I386Types.I386_Reg
  | r32 of I386_Opcodes.I386Types.I386_Reg
  | imm8 of int
  | imm16 of int
  | imm32 of (int * int)
  | r_m8 of (I386_Opcodes.I386Types.I386_Reg, mem_operand) union
  | r_m16 of (I386_Opcodes.I386Types.I386_Reg, mem_operand) union
  | r_m32 of (I386_Opcodes.I386Types.I386_Reg, mem_operand) union
  | m8 of mem_operand
  | m16 of mem_operand
  | m32 of mem_operand
  | fp_mem of mem_operand
  | fp_reg of int
(* I don't think we will want these, so I've left them out for the present
  | m16_16
  | m16_32
  | m16_m16
  | m16_m32
  | m32_m32
  | moffs8
  | moffs16
  | moffs32
  | sreg
*)

  datatype opcode =
    OPCODE of mnemonic * (adr_mode list)
   | AugOPCODE of opcode * Backend_Annotation


  val check: opcode -> unit (* Test a proposed opcode for validity *)

  val assemble : opcode -> I386_Opcodes.opcode

  val opcode_size : opcode -> int

  type LabMap

  val make_labmap : opcode list list list -> LabMap

  val print_mnemonic : mnemonic -> string
  val print : opcode -> string
  val labprint : opcode * int * LabMap -> string * string
  val reverse_branch : mnemonic -> mnemonic
  (* Produce rel' where a rel b == b rel' a *)

  val inverse_branch : mnemonic -> mnemonic
  (* Produce rel' where a rel b == not(a rel' b) *)

  val defines_and_uses :
    opcode ->
    I386_Opcodes.I386Types.I386_Reg Set * I386_Opcodes.I386Types.I386_Reg Set *
    I386_Opcodes.I386Types.I386_Reg Set * I386_Opcodes.I386Types.I386_Reg Set
  val nop_code : opcode
  val other_nop_code : opcode
  val no_op : opcode * tag option * string
end
@


1.14.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.14  1998/06/29  13:17:21  jont
 * [Bug #20117]
 * Add align directive for benefit of jump tables
 *
@


1.13
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d89 1
@


1.13.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.13  1997/05/06  10:02:48  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.13.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.13  1997/05/06  10:02:48  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.12
log
@[Bug #1734]
Changing type Backend_Annotation to eqtype Backend_Annotation.
@
text
@d4 4
d56 2
d273 3
a275 3
    MEM of {base: I386_Opcodes.I386Types.I386_Reg MLWorks.Option.option,
	    index: (I386_Opcodes.I386Types.I386_Reg * int MLWorks.Option.option) MLWorks.Option.option,
	    offset: offset_operand MLWorks.Option.option}
d292 3
a294 3
  | r_m8 of (I386_Opcodes.I386Types.I386_Reg, mem_operand) MLWorks.Option.union
  | r_m16 of (I386_Opcodes.I386Types.I386_Reg, mem_operand) MLWorks.Option.union
  | r_m32 of (I386_Opcodes.I386Types.I386_Reg, mem_operand) MLWorks.Option.union
d342 1
a342 1
  val no_op : opcode * tag MLWorks.Option.option * string
@


1.12.5.1
log
@branched from 1.12
@
text
@a3 4
 * Revision 1.12  1996/11/06  10:53:26  andreww
 * [Bug #1734]
 * Changing type Backend_Annotation to eqtype Backend_Annotation.
 *
@


1.12.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.12.5.1  1997/05/12  10:33:11  hope
 * branched from 1.12
 *
@


1.12.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.12.5.1  1997/05/12  10:33:11  hope
 * branched from 1.12
 *
@


1.12.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.12.5.1  1997/05/12  10:33:11  hope
 * branched from 1.12
 *
@


1.12.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.12.5.1.1.1  1997/07/28  18:18:33  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.12.4.1
log
@branched from 1.12
@
text
@a3 4
 * Revision 1.12  1996/11/06  10:53:26  andreww
 * [Bug #1734]
 * Changing type Backend_Annotation to eqtype Backend_Annotation.
 *
@


1.12.3.1
log
@branched from 1.12
@
text
@a3 4
 * Revision 1.12  1996/11/06  10:53:26  andreww
 * [Bug #1734]
 * Changing type Backend_Annotation to eqtype Backend_Annotation.
 *
@


1.12.3.1.1.1
log
@branched from 1.12.3.1
@
text
@a3 3
 * Revision 1.12.3.1  1996/12/17  17:46:50  hope
 * branched from 1.12
 *
@


1.12.2.1
log
@branched from 1.12
@
text
@a3 4
 * Revision 1.12  1996/11/06  10:53:26  andreww
 * [Bug #1734]
 * Changing type Backend_Annotation to eqtype Backend_Annotation.
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a3 4
 * Revision 1.12  1996/11/06  10:53:26  andreww
 * [Bug #1734]
 * Changing type Backend_Annotation to eqtype Backend_Annotation.
 *
@


1.12.1.1.1.1
log
@branched from 1.12.1.1
@
text
@a3 3
 * Revision 1.12.1.1  1996/11/14  12:48:08  hope
 * branched from 1.12
 *
@


1.11
log
@[Bug #1707]
threading debugger information.
@
text
@d4 4
d50 1
a50 1
  type Backend_Annotation (* MirTypes.Debugger_Types.Backend_Annotation *)
@


1.10
log
@Allow offsets in mem_operands to be bigger than an int, to cope with words
@
text
@d4 3
d46 1
d304 2
a305 4
  (* An opcode specification is a mnemonic *)
  (* Together with a list of operands *)
  (* For an opcode like CMC, this list is nil, as CMC has no operands *)
  (* For a call, the list has one element, since call takes one operand *)
@


1.10.3.1
log
@branched from 1.10
@
text
@a3 3
 * Revision 1.10  1996/04/04  13:03:40  jont
 * Allow offsets in mem_operands to be bigger than an int, to cope with words
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a3 3
 * Revision 1.10  1996/04/04  13:03:40  jont
 * Allow offsets in mem_operands to be bigger than an int, to cope with words
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a3 3
 * Revision 1.10  1996/04/04  13:03:40  jont
 * Allow offsets in mem_operands to be bigger than an int, to cope with words
 *
@


1.9
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d4 4
d254 4
d261 1
a261 1
	    offset: int MLWorks.Option.option}
@


1.8
log
@Added fnclex
@
text
@d4 3
a39 4
  eqtype 'a opt

  eqtype ('a, 'b) option

d251 3
a253 3
    MEM of {base: I386_Opcodes.I386Types.I386_Reg opt,
	    index: (I386_Opcodes.I386Types.I386_Reg * int opt) opt,
	    offset: int opt}
d270 3
a272 3
  | r_m8 of (I386_Opcodes.I386Types.I386_Reg, mem_operand) option
  | r_m16 of (I386_Opcodes.I386Types.I386_Reg, mem_operand) option
  | r_m32 of (I386_Opcodes.I386Types.I386_Reg, mem_operand) option
d322 1
a322 1
  val no_op : opcode * tag opt * string
@


1.7
log
@Added FP opcodes
@
text
@d4 3
d141 1
@


1.6
log
@Add fixed length rel32 type for use in switches
@
text
@d4 3
d94 45
d273 2
@


1.5
log
@Get type of reverse_branch right
@
text
@d4 3
d210 1
d240 1
a240 1
  (* Together with a list of operand address modes *)
a242 2
  (* This one element may be any of rel16, r_m16, ptr16_16, m16_16, *)
  (* rel32, r_m32, ptr16_32, m16_32 *)
@


1.4
log
@Add print_mnemonic function
@
text
@d4 3
d255 1
a255 1
  val reverse_branch : opcode -> opcode
d258 1
a258 1
  val inverse_branch : opcode -> opcode
@


1.3
log
@Change 32 bit immediates to be pairs to get full range
@
text
@d4 3
d249 1
@


1.2
log
@Make option an eqtype
@
text
@d4 3
d208 1
a208 1
  | imm32 of int
@


1.1
log
@new file
@
text
@d3 4
a6 1
$Log$
d19 1
a19 1
  type 'a opt
d21 1
a21 1
  type ('a, 'b) option
@
