head	1.16;
access;
symbols
	MLW_daveb_inline_1_4_99:1.16.1
	MLWorks_21c0_1999_03_25:1.16
	MLWorks_20c1_1998_08_20:1.16
	MLWorks_20c0_1998_08_04:1.16
	MLWorks_20b2c2_1998_06_19:1.16
	MLWorks_20b2_Windows_1998_06_12:1.15
	MLWorks_20b1c1_1998_05_07:1.15
	MLWorks_20b0_1998_04_07:1.15
	MLWorks_20b0_1998_03_20:1.15
	MLWorks_20m2_1998_02_16:1.15
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.13.5.1.1.1.1
	MLWorks_workspace_97:1.14.2
	MLWorks_dt_wizard:1.14.1
	MLWorks_11c0_1997_09_09:1.13.5.1.1.1
	MLWorks_10r3:1.13.5.1.3
	MLWorks_10r2_551:1.13.5.1.2
	MLWorks_11:1.13.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.13.5.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.13.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.13.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.13.5
	MLWorks_BugFix_1997_04_24:1.13
	MLWorks_1_0_r2_Win32_1997_04_11:1.13
	MLWorks_1_0_r2_Unix_1997_04_04:1.13
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.13.3.1.1
	MLWorks_gui_1996_12_18:1.13.4
	MLWorks_1_0_Win32_1996_12_17:1.13.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.13.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.13.1.1
	MLWorks_1_0_Irix_1996_11_28:1.13.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.13.2
	MLWorks_1_0_Unix_1996_11_14:1.13.1
	MLWorks_Open_Beta2_1996_10_11:1.12.3
	MLWorks_License_dev:1.12.2
	MLWorks_1_open_beta_1996_09_13:1.12.1
	MLWorks_Open_Beta_1996_08_22:1.12
	MLWorks_Beta_1996_07_02:1.12
	MLWorks_Beta_1996_06_07:1.12
	MLWorks_Beta_1996_06_06:1.12
	MLWorks_Beta_1996_06_05:1.12
	MLWorks_Beta_1996_06_03:1.12
	MLWorks_Beta_1996_05_31:1.12
	MLWorks_Beta_1996_05_30:1.12;
locks; strict;
comment	@ * @;


1.16
date	98.06.16.13.09.02;	author jont;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	97.09.19.09.25.23;	author brucem;	state Exp;
branches;
next	1.14;

1.14
date	97.05.14.19.44.14;	author jont;	state Exp;
branches
	1.14.1.1
	1.14.2.1;
next	1.13;

1.13
date	96.10.09.11.55.39;	author io;	state Exp;
branches
	1.13.1.1
	1.13.2.1
	1.13.3.1
	1.13.4.1
	1.13.5.1;
next	1.12;

1.12
date	96.05.01.12.35.48;	author jont;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1;
next	1.11;

1.11
date	96.04.03.16.02.52;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.08.14.12.14.25;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	95.08.14.12.14.25;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	95.07.25.15.59.06;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	94.11.24.11.56.05;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.11.18.15.11.06;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.09.21.13.14.52;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.09.20.11.11.23;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.09.16.14.11.29;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.09.15.11.07.22;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.09.09.15.57.02;	author jont;	state Exp;
branches;
next	;

1.12.1.1
date	96.09.13.11.14.59;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.10.07.16.05.20;	author hope;	state Exp;
branches;
next	;

1.12.3.1
date	96.10.17.11.23.35;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	96.11.14.12.47.58;	author hope;	state Exp;
branches
	1.13.1.1.1.1;
next	;

1.13.1.1.1.1
date	96.11.28.14.59.29;	author hope;	state Exp;
branches;
next	;

1.13.2.1
date	96.11.22.18.07.58;	author hope;	state Exp;
branches;
next	;

1.13.3.1
date	96.12.17.17.46.39;	author hope;	state Exp;
branches
	1.13.3.1.1.1;
next	;

1.13.3.1.1.1
date	97.02.24.11.36.18;	author hope;	state Exp;
branches;
next	;

1.13.4.1
date	96.12.18.09.40.39;	author hope;	state Exp;
branches;
next	;

1.13.5.1
date	97.05.12.10.33.01;	author hope;	state Exp;
branches
	1.13.5.1.1.1
	1.13.5.1.2.1
	1.13.5.1.3.1;
next	;

1.13.5.1.1.1
date	97.07.28.18.18.45;	author daveb;	state Exp;
branches
	1.13.5.1.1.1.1.1;
next	;

1.13.5.1.1.1.1.1
date	97.10.07.11.43.50;	author jkbrook;	state Exp;
branches;
next	;

1.13.5.1.2.1
date	97.09.08.17.12.19;	author daveb;	state Exp;
branches;
next	;

1.13.5.1.3.1
date	97.09.09.14.07.57;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	97.09.10.19.22.56;	author brucem;	state Exp;
branches;
next	;

1.14.2.1
date	97.09.11.20.54.07;	author daveb;	state Exp;
branches;
next	;

1.16.1.1
date	99.04.01.17.56.26;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.16
log
@[Bug #70137]
Modify print to produce gas format
@
text
@(* _i386types.sml the functor *)
(*
$Log: _i386types.sml,v $
 * Revision 1.15  1997/09/19  09:25:23  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.14  1997/05/14  19:44:14  jont
 * [Bug #30076]
 * Adding argument passing pseudo registers for multiple argument passing work.
 *
 * Revision 1.13  1996/10/09  11:55:39  io
 * moving String from toplevel
 *
 * Revision 1.12  1996/05/01  12:35:48  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.11  1996/04/03  16:02:52  jont
 * Give type of register value (cond, heap, stack, nil_v) which fails register_value
 *
 * Revision 1.10  1995/08/14  12:14:25  jont
 * Add bits_per_word
 * Remove smallest_int, largest_int, largest_word
 *
Revision 1.8  1995/07/25  15:59:06  jont
Add largest_word

Revision 1.7  1994/11/24  11:56:05  jont
Add full_reg_name function

Revision 1.6  1994/11/18  15:11:06  jont
Modify to new register assignment

Revision 1.5  1994/09/21  13:14:52  jont
Add word_reg_name function

Revision 1.4  1994/09/20  11:11:23  jont
Add register value function

Revision 1.3  1994/09/16  14:11:29  jont
Add conversion to byte registers function

Revision 1.2  1994/09/15  11:07:22  jont
Remove fp, we're not having an fp

Revision 1.1  1994/09/09  15:57:02  jont
new file

Copyright (c) 1994 Harlequin Ltd.
*)

require "$.basis.__string";
require "../utils/crash";
require "i386types";

functor I386Types(
  structure Crash : CRASH
  ) : I386TYPES =

struct
  datatype I386_Reg =
    EAX |
    EBX |
    ECX |
    EDX |
    ESP |
    EBP |
    EDI |
    ESI |
    AX |
    BX |
    CX |
    DX |
    SP |
    BP |
    DI |
    SI |
    AH |
    AL |
    BH |
    BL |
    CH |
    CL |
    DH |
    DL |
    cond |
    heap |
    stack |
    nil_v |
    i_arg1 |
    i_arg2 |
    i_arg3 |
    i_arg4 |
    i_arg5 |
    i_arg6 |
    i_arg7 |
    o_arg1 |
    o_arg2 |
    o_arg3 |
    o_arg4 |
    o_arg5 |
    o_arg6 |
    o_arg7

  fun register_value EAX = 0
    | register_value EBX = 3
    | register_value ECX = 1
    | register_value EDX = 2
    | register_value ESP = 4
    | register_value EBP = 5
    | register_value EDI = 7
    | register_value ESI = 6
    | register_value AX = 0
    | register_value BX = 3
    | register_value CX = 1
    | register_value DX = 2
    | register_value SP = 4
    | register_value BP = 5
    | register_value DI = 7
    | register_value SI = 6
    | register_value AH = 4
    | register_value AL = 0
    | register_value BH = 7
    | register_value BL = 3
    | register_value CH = 5
    | register_value CL = 1
    | register_value DH = 6
    | register_value DL = 2
    | register_value cond = Crash.impossible"register_value:not register (cond)"
    | register_value heap = Crash.impossible"register_value:not register (heap)"
    | register_value stack = Crash.impossible"register_value:not register (stack)"
    | register_value nil_v = Crash.impossible"register_value:not register (nil_v)"
    | register_value i_arg1 = Crash.impossible"register value:not register (i_arg1)"
    | register_value i_arg2 = Crash.impossible"register value:not register (i_arg2)"
    | register_value i_arg3 = Crash.impossible"register value:not register (i_arg3)"
    | register_value i_arg4 = Crash.impossible"register value:not register (i_arg4)"
    | register_value i_arg5 = Crash.impossible"register value:not register (i_arg5)"
    | register_value i_arg6 = Crash.impossible"register value:not register (i_arg6)"
    | register_value i_arg7 = Crash.impossible"register value:not register (i_arg7)"
    | register_value o_arg1 = Crash.impossible"register value:not register (o_arg1)"
    | register_value o_arg2 = Crash.impossible"register value:not register (o_arg2)"
    | register_value o_arg3 = Crash.impossible"register value:not register (o_arg3)"
    | register_value o_arg4 = Crash.impossible"register value:not register (o_arg4)"
    | register_value o_arg5 = Crash.impossible"register value:not register (o_arg5)"
    | register_value o_arg6 = Crash.impossible"register value:not register (o_arg6)"
    | register_value o_arg7 = Crash.impossible"register value:not register (o_arg7)"

  fun byte_reg_name EAX = AL
    | byte_reg_name EBX = BL
    | byte_reg_name ECX = CL
    | byte_reg_name EDX = DL
    | byte_reg_name _ = Crash.impossible"byte_reg_name: bad argument"

  fun has_byte_name EAX = true
    | has_byte_name EBX = true
    | has_byte_name ECX = true
    | has_byte_name EDX = true
    | has_byte_name _ = false

  fun half_reg_name EAX = AX
    | half_reg_name EBX = BX
    | half_reg_name ECX = CX
    | half_reg_name EDX = DX
    | half_reg_name ESP = SP
    | half_reg_name EBP = BP
    | half_reg_name EDI = DI
    | half_reg_name ESI = SI
    | half_reg_name _ = Crash.impossible"half_reg_name: bad argument"

  fun full_reg_name EAX = EAX
    | full_reg_name EBX = EBX
    | full_reg_name ECX = ECX
    | full_reg_name EDX = EDX
    | full_reg_name ESP = ESP
    | full_reg_name EBP = EBP
    | full_reg_name EDI = EDI
    | full_reg_name ESI = ESI
    | full_reg_name AX = EAX
    | full_reg_name BX = EBX
    | full_reg_name CX = ECX
    | full_reg_name DX = EDI
    | full_reg_name SP = ESP
    | full_reg_name BP = EBP
    | full_reg_name DI = EDI
    | full_reg_name SI = ESI
    | full_reg_name AH = EAX
    | full_reg_name AL = EAX
    | full_reg_name BH = EBX
    | full_reg_name BL = EBX
    | full_reg_name CH = ECX
    | full_reg_name CL = ECX
    | full_reg_name DH = EDX
    | full_reg_name DL = EDX
    | full_reg_name _ = Crash.impossible"full_reg_name:not register"

  datatype fp_type = single | double | extended

  val fp_used = double

  fun reg_to_string EAX = "%eax"
    | reg_to_string EBX = "%ebx"
    | reg_to_string ECX = "%ecx"
    | reg_to_string EDX = "%edx"
    | reg_to_string ESP = "%esp"
    | reg_to_string EBP = "%ebp"
    | reg_to_string EDI = "%edi"
    | reg_to_string ESI = "%esi"
    | reg_to_string AX = "%ax"
    | reg_to_string BX = "%bx"
    | reg_to_string CX = "%cx"
    | reg_to_string DX = "%dx"
    | reg_to_string SP = "%sp"
    | reg_to_string BP = "%bp"
    | reg_to_string DI = "%di"
    | reg_to_string SI = "%si"
    | reg_to_string AH = "%ah"
    | reg_to_string AL = "%al"
    | reg_to_string BH = "%bh"
    | reg_to_string BL = "%bl"
    | reg_to_string CH = "%ch"
    | reg_to_string CL = "%cl"
    | reg_to_string DH = "%dh"
    | reg_to_string DL = "%dl"
    | reg_to_string cond = "cond"
    | reg_to_string heap = "heap"
    | reg_to_string stack = "stack"
    | reg_to_string nil_v = "nil_v"
    | reg_to_string i_arg1 = "i_arg1"
    | reg_to_string i_arg2 = "i_arg2"
    | reg_to_string i_arg3 = "i_arg3"
    | reg_to_string i_arg4 = "i_arg4"
    | reg_to_string i_arg5 = "i_arg5"
    | reg_to_string i_arg6 = "i_arg6"
    | reg_to_string i_arg7 = "i_arg7"
    | reg_to_string o_arg1 = "o_arg1"
    | reg_to_string o_arg2 = "o_arg2"
    | reg_to_string o_arg3 = "o_arg3"
    | reg_to_string o_arg4 = "o_arg4"
    | reg_to_string o_arg5 = "o_arg5"
    | reg_to_string o_arg6 = "o_arg6"
    | reg_to_string o_arg7 = "o_arg7"

  fun fp_reg_to_string _ = Crash.unimplemented"fp_reg_to_string"
      
  val caller_arg = EBX
  val callee_arg = EBX
  val caller_closure = EBP
  val callee_closure = EDI
  val sp = ESP
  val global = ECX
  val implicit = ESI

  val digits_in_real = 64
  val bits_per_word = 30

  exception Ord and Chr

  val ord = fn x=>(ord (String.sub(x, 0))) handle ? => raise Ord
  val chr = fn x=>String.str(chr x) handle ? => raise Chr

end
@


1.16.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.16  1998/06/16  13:09:02  jont
 * [Bug #70137]
 * Modify print to produce gas format
 *
@


1.15
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 4
d203 24
a226 24
  fun reg_to_string EAX = "EAX"
    | reg_to_string EBX = "EBX"
    | reg_to_string ECX = "ECX"
    | reg_to_string EDX = "EDX"
    | reg_to_string ESP = "ESP"
    | reg_to_string EBP = "EBP"
    | reg_to_string EDI = "EDI"
    | reg_to_string ESI = "ESI"
    | reg_to_string AX = "AX"
    | reg_to_string BX = "BX"
    | reg_to_string CX = "CX"
    | reg_to_string DX = "DX"
    | reg_to_string SP = "SP"
    | reg_to_string BP = "BP"
    | reg_to_string DI = "DI"
    | reg_to_string SI = "SI"
    | reg_to_string AH = "AH"
    | reg_to_string AL = "AL"
    | reg_to_string BH = "BH"
    | reg_to_string BL = "BL"
    | reg_to_string CH = "CH"
    | reg_to_string CL = "CL"
    | reg_to_string DH = "DH"
    | reg_to_string DL = "DL"
@


1.14
log
@[Bug #30076]
Adding argument passing pseudo registers for multiple argument passing work.
@
text
@d4 4
d51 1
a53 2
require "^.basis.__old";

d257 2
a258 2
  val ord = fn x=>(Old.ord x) handle ? => raise Ord
  val chr = fn x=>(Old.chr x) handle ? => raise Chr
@


1.14.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.14  1997/05/14  19:44:14  jont
 * [Bug #30076]
 * Adding argument passing pseudo registers for multiple argument passing work.
 *
@


1.14.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.14  1997/05/14  19:44:14  jont
 * [Bug #30076]
 * Adding argument passing pseudo registers for multiple argument passing work.
 *
@


1.13
log
@moving String from toplevel
@
text
@d4 3
d85 15
a99 1
    nil_v
d129 14
a191 36

(*
  val F0 = G0
  val F1 = G1
  val F2 = G2
  val F3 = G3
  val F4 = G4
  val F5 = G5
  val F6 = G6
  val F7 = G7
  val F8 = O0
  val F9 = O1
  val F10 = O2
  val F11 = O3
  val F12 = O4
  val F13 = O5
  val F14 = O6
  val F15 = O7
  val F16 = L0
  val F17 = L1
  val F18 = L2
  val F19 = L3
  val F20 = L4
  val F21 = L5
  val F22 = L6
  val F23 = L7
  val F24 = I0
  val F25 = I1
  val F26 = I2
  val F27 = I3
  val F28 = I4
  val F29 = I5
  val F30 = I6
  val F31 = I7
*)

d224 14
@


1.13.5.1
log
@branched from 1.13
@
text
@a3 3
 * Revision 1.13  1996/10/09  11:55:39  io
 * moving String from toplevel
 *
@


1.13.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.13.5.1  1997/05/12  10:33:01  hope
 * branched from 1.13
 *
@


1.13.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.13.5.1  1997/05/12  10:33:01  hope
 * branched from 1.13
 *
@


1.13.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.13.5.1  1997/05/12  10:33:01  hope
 * branched from 1.13
 *
@


1.13.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.13.5.1.1.1  1997/07/28  18:18:45  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.13.4.1
log
@branched from 1.13
@
text
@a3 3
 * Revision 1.13  1996/10/09  11:55:39  io
 * moving String from toplevel
 *
@


1.13.3.1
log
@branched from 1.13
@
text
@a3 3
 * Revision 1.13  1996/10/09  11:55:39  io
 * moving String from toplevel
 *
@


1.13.3.1.1.1
log
@branched from 1.13.3.1
@
text
@a3 3
 * Revision 1.13.3.1  1996/12/17  17:46:39  hope
 * branched from 1.13
 *
@


1.13.2.1
log
@branched from 1.13
@
text
@a3 3
 * Revision 1.13  1996/10/09  11:55:39  io
 * moving String from toplevel
 *
@


1.13.1.1
log
@branched from 1.13
@
text
@a3 3
 * Revision 1.13  1996/10/09  11:55:39  io
 * moving String from toplevel
 *
@


1.13.1.1.1.1
log
@branched from 1.13.1.1
@
text
@a3 3
 * Revision 1.13.1.1  1996/11/14  12:47:58  hope
 * branched from 1.13
 *
@


1.12
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d46 1
d245 2
a246 2
  val ord = fn x=>(String.ord x) handle ? => raise Ord
  val chr = fn x=>(String.chr x) handle ? => raise Chr
@


1.12.3.1
log
@branched from 1.12
@
text
@a3 6
 * Revision 1.12  1996/05/01  12:35:48  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.12.2.1
log
@branched from 1.12
@
text
@a3 6
 * Revision 1.12  1996/05/01  12:35:48  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a3 6
 * Revision 1.12  1996/05/01  12:35:48  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.11
log
@Give type of register value (cond, heap, stack, nil_v) which fails register_value
@
text
@d4 3
d238 2
a239 2
  val ord = fn x=>(ord x) handle ? => raise Ord
  val chr = fn x=>(chr x) handle ? => raise Chr
@


1.10
log
@Add bits_per_word
Remove smallest_int, largest_int, largest_word
@
text
@d4 4
d98 4
a101 1
    | register_value _ = Crash.impossible"register_value:not register"
@


1.9
log
@Add bits_per_word
Remove smallest_int, largest_int, largest_word
@
text
@@


1.8
log
@Add largest_word
@
text
@d4 3
a222 3
  val largest_int = "536870911"
  val smallest_int = "~536870912"
  val largest_word = "1073741823"
d224 1
@


1.7
log
@Add full_reg_name function
@
text
@d4 3
d222 1
@


1.6
log
@Modify to new register assignment
@
text
@d4 3
d111 27
@


1.5
log
@Add word_reg_name function
@
text
@d4 3
d179 2
a180 2
  val caller_arg = ESI
  val callee_arg = ESI
d185 1
a185 1
  val implicit = EBX
@


1.4
log
@Add register value function
@
text
@d4 3
a87 4
    | byte_reg_name ESP = AH
    | byte_reg_name EBP = CH
    | byte_reg_name EDI = DH
    | byte_reg_name ESI = BH
d89 16
@


1.3
log
@Add conversion to byte registers function
@
text
@d4 3
d54 26
@


1.2
log
@Remove fp, we're not having an fp
@
text
@d4 3
d51 10
@


1.1
log
@new file
@
text
@d3 4
a6 1
$Log$
d121 1
a121 1
  val caller_closure = EDI
a122 1
  val fp = EBP
d125 1
@
