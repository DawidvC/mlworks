head	1.14;
access;
symbols
	MLW_daveb_inline_1_4_99:1.14.1
	MLWorks_21c0_1999_03_25:1.14
	MLWorks_20c1_1998_08_20:1.12
	MLWorks_20c0_1998_08_04:1.12
	MLWorks_20b2c2_1998_06_19:1.12
	MLWorks_20b2_Windows_1998_06_12:1.12
	MLWorks_20b1c1_1998_05_07:1.12
	MLWorks_20b0_1998_04_07:1.12
	MLWorks_20b0_1998_03_20:1.12
	MLWorks_20m2_1998_02_16:1.12
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.11.5.1.1.1.1
	MLWorks_workspace_97:1.12.2
	MLWorks_dt_wizard:1.12.1
	MLWorks_11c0_1997_09_09:1.11.5.1.1.1
	MLWorks_10r3:1.11.5.1.3
	MLWorks_10r2_551:1.11.5.1.2
	MLWorks_11:1.11.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.11.5.1
	MLWorks_20m0_1997_06_20:1.12
	MLWorks_1_0_r2c2_1997_06_14:1.11.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.11.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.11.5
	MLWorks_BugFix_1997_04_24:1.11
	MLWorks_1_0_r2_Win32_1997_04_11:1.11
	MLWorks_1_0_r2_Unix_1997_04_04:1.11
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.11.3.1.1
	MLWorks_gui_1996_12_18:1.11.4
	MLWorks_1_0_Win32_1996_12_17:1.11.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.11.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.11.1.1
	MLWorks_1_0_Irix_1996_11_28:1.11.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.11.2
	MLWorks_1_0_Unix_1996_11_14:1.11.1
	MLWorks_Open_Beta2_1996_10_11:1.10.3
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.9
	MLWorks_Beta_1996_06_07:1.9
	MLWorks_Beta_1996_06_06:1.9
	MLWorks_Beta_1996_06_05:1.9
	MLWorks_Beta_1996_06_03:1.9
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.9;
locks; strict;
comment	@ * @;


1.14
date	99.02.02.15.59.52;	author mitchell;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	98.08.20.17.04.14;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	97.05.06.10.07.04;	author jont;	state Exp;
branches
	1.12.1.1
	1.12.2.1;
next	1.11;

1.11
date	96.11.06.11.12.34;	author matthew;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1
	1.11.4.1
	1.11.5.1;
next	1.10;

1.10
date	96.08.09.17.11.55;	author daveb;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1;
next	1.9;

1.9
date	96.04.30.13.21.06;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	96.04.04.13.41.43;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.12.20.14.30.38;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	95.02.10.15.35.45;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	95.01.16.18.01.25;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.11.15.15.59.08;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.10.26.18.45.17;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.09.21.10.38.33;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.09.15.12.32.49;	author jont;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.15.17;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.05.35;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.10.17.11.23.51;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	96.11.14.12.48.17;	author hope;	state Exp;
branches
	1.11.1.1.1.1;
next	;

1.11.1.1.1.1
date	96.11.28.14.59.48;	author hope;	state Exp;
branches;
next	;

1.11.2.1
date	96.11.22.18.08.15;	author hope;	state Exp;
branches;
next	;

1.11.3.1
date	96.12.17.17.46.56;	author hope;	state Exp;
branches
	1.11.3.1.1.1;
next	;

1.11.3.1.1.1
date	97.02.24.11.36.36;	author hope;	state Exp;
branches;
next	;

1.11.4.1
date	96.12.18.09.40.55;	author hope;	state Exp;
branches;
next	;

1.11.5.1
date	97.05.12.10.33.19;	author hope;	state Exp;
branches
	1.11.5.1.1.1
	1.11.5.1.2.1
	1.11.5.1.3.1;
next	;

1.11.5.1.1.1
date	97.07.28.18.18.41;	author daveb;	state Exp;
branches
	1.11.5.1.1.1.1.1;
next	;

1.11.5.1.1.1.1.1
date	97.10.07.11.43.45;	author jkbrook;	state Exp;
branches;
next	;

1.11.5.1.2.1
date	97.09.08.17.12.15;	author daveb;	state Exp;
branches;
next	;

1.11.5.1.3.1
date	97.09.09.14.07.53;	author daveb;	state Exp;
branches;
next	;

1.12.1.1
date	97.09.10.19.22.49;	author brucem;	state Exp;
branches;
next	;

1.12.2.1
date	97.09.11.20.54.00;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	99.04.01.17.56.23;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.14
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _i386_schedule.sml the functor *)
(*
$Log: _i386_schedule.sml,v $
 * Revision 1.13  1998/08/20  17:04:14  jont
 * [Bug #20116]
 * Fix poor code sequences bserved in 20116 and 20118
 *
 * Revision 1.12  1997/05/06  10:07:04  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.11  1996/11/06  11:12:34  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.10  1996/08/09  17:11:55  daveb
 * [Bug #1534]
 * before is now an infix identifier.
 *
 * Revision 1.9  1996/04/30  13:21:06  matthew
 * Removing use of MLWorks.Integer
 *
 * Revision 1.8  1996/04/04  13:41:43  jont
 * Allow offsets in mem_operands to be bigger than an int, to cope with words
 *
 * Revision 1.7  1995/12/20  14:30:38  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
Revision 1.6  1995/02/10  15:35:45  jont
Remove the debug output

Revision 1.5  1995/01/16  18:01:25  jont
Add some more peepholing (zero propagation, large moves)

Revision 1.4  1994/11/15  15:59:08  jont
Add some peephole optimisations
In particular, to remove superfluous pop/push pairs
and to remove reloads after stores and restores after loads

Revision 1.3  1994/10/26  18:45:17  jont
Change of option type in newmap

Revision 1.2  1994/09/21  10:38:33  jont
Add code to remove unwanted blocks

Revision 1.1  1994/09/15  12:32:49  jont
new file

Copyright (c) 1994 Harlequin Ltd.
*)

require "../utils/crash";
require "../utils/lists";
require "../mir/mirtypes";
require "i386_assembly";
require "i386_schedule";

functor I386_Schedule(
  structure Crash : CRASH
  structure Lists : LISTS
  structure I386_Assembly : I386_ASSEMBLY
  structure MirTypes: MIRTYPES
  sharing type MirTypes.tag = I386_Assembly.tag
  sharing type MirTypes.Set.Set = I386_Assembly.Set
  ) : I386_SCHEDULE =
struct
  structure I386_Assembly = I386_Assembly
  structure NewMap = MirTypes.Map
  structure Set = MirTypes.Set
  structure I386Types = I386_Assembly.I386_Opcodes.I386Types

  (* No scheduling done at present *)
  (* Block level peepholing *)
  (* We look for pop/push pairs of the same register *)
  (* Store/load pairs of the same register, store location pair *)
  (* Sequences of the form mov ecx, n[esp] ; mov ecx, a ; mov b, ecx ; mov ecx, n[esp] *)
  (* where b is not n[esp]. These shrink to mov ecx, a ; mov b, ecx ; mov ecx, n[esp] *)
  (* Ie we omit the first mov ecx, n[esp]. These can occur in large numbers *)
  (* in setup functions *)
  (* Clearing of registers which are already zero *)
  (* Use of lea as a move where there is no gain (a one byte loss in fact ) *)
  (* Long copying sequences of contiguous data (tricky stuff this) *)

  fun is_mem(I386_Assembly.r_m32(I386_Assembly.INR _)) = true
    | is_mem _ = false

  fun is_reg(I386_Assembly.r32 _) = true
    | is_reg(I386_Assembly.r_m32(I386_Assembly.INL _)) = true
    | is_reg _ = false

  fun involves(reg, I386_Assembly.r_m32(I386_Assembly.INR
					(I386_Assembly.MEM{base, index, ...}))) =
    (isSome base andalso valOf base = reg) orelse
    (isSome index andalso #1(valOf index) = reg)
    | involves _ = false

  fun convert_reg(I386_Assembly.r32 reg) = I386_Assembly.r_m32(I386_Assembly.INL reg)
    | convert_reg(I386_Assembly.r_m32(I386_Assembly.INL reg)) = I386_Assembly.r32 reg
    | convert_reg _ = Crash.impossible"convert_reg: not a register"

  fun check_for_more_copying([],_ , _, _, _, _, _, _) =
    Crash.impossible"check_for_more_copying reaches block end"
    | check_for_more_copying([_], count_of_copies, _, _, _, _, _, _) =
      count_of_copies
    | check_for_more_copying((opcode1 as
			      (I386_Assembly.OPCODE
			       (I386_Assembly.mov,
				[I386_Assembly.r32 reg1,
				 I386_Assembly.r_m32
				 (I386_Assembly.INR
				  (I386_Assembly.MEM
				   {base=SOME base_reg1,
				    index=NONE,
				    offset=SOME(I386_Assembly.SMALL offset1)}))]),
			       NONE, _)) ::
                             (opcode2 as
			      (I386_Assembly.OPCODE
			       (I386_Assembly.mov,
				[I386_Assembly.r_m32
				 (I386_Assembly.INR
				  (I386_Assembly.MEM
				   {base=SOME base_reg2,
				    index=NONE,
				    offset=SOME(I386_Assembly.SMALL offset2)})),
				 I386_Assembly.r32 reg2]),
			       NONE, _)) ::
			     rest,
			     count_of_copies, inc, internal_register,
			     source_reg, dest_reg,
			     source_count, dest_count) =
      if reg1 = internal_register andalso reg2 = internal_register andalso
	source_reg = base_reg1 andalso dest_reg = base_reg2 andalso
	offset1 = source_count + inc andalso dest_count + inc = offset2 then
	check_for_more_copying(rest, count_of_copies + 1, inc, internal_register,
			       source_reg, dest_reg,
			       source_count + inc, dest_count + inc)
      else
	count_of_copies
    | check_for_more_copying(_, count_of_copies, _, _, _, _, _, _) =
      count_of_copies

  fun find_copy_sequence_in_block(_, []) = NONE
    | find_copy_sequence_in_block(_, [_]) = NONE
    | find_copy_sequence_in_block(position, [_, _]) = NONE
    | find_copy_sequence_in_block(position, instr1 :: (rest' as (instr2 :: rest))) =
      (case instr1 of
	 (I386_Assembly.OPCODE
	  (I386_Assembly.mov,
	   [I386_Assembly.r32 reg1,
	    I386_Assembly.r_m32
	    (I386_Assembly.INR
	     (I386_Assembly.MEM
	      {base=SOME base_reg1,
	       index=NONE,
	       offset=SOME(I386_Assembly.SMALL offset1)}))]),
	  NONE, _) =>
	 (case instr2 of
	    (I386_Assembly.OPCODE
	     (I386_Assembly.mov,
	      [I386_Assembly.r_m32
	       (I386_Assembly.INR
		(I386_Assembly.MEM
		 {base=SOME base_reg2,
		  index=NONE,
		  offset=SOME(I386_Assembly.SMALL offset2)})),
	       I386_Assembly.r32 reg2]),
	     NONE, _) =>
	    if reg1 = reg2 (* Check it is a store copy *) then
	      let
		(* A possible store copying sequence *)
		val copy_count_up =
		  check_for_more_copying(rest, 1, 4, reg1, base_reg1, base_reg2,
					 offset1, offset2)
		val copy_count_down =
		  check_for_more_copying(rest, 1, ~4, reg1, base_reg1, base_reg2,
					 offset1, offset2)
	      in
		if copy_count_up > 3 then
		  ((*output(std_out, "Found store copy up sequence of length " ^
			  Int.toString copy_count_up ^ "\n");*)
		   SOME(position, 4, copy_count_up, reg1,
				  base_reg1, base_reg2, offset1, offset2))
		else
		  if copy_count_down > 3 then
		    ((*output(std_out, "Found store copy down sequence of length " ^
			    Int.toString copy_count_down ^ "\n");*)
		     SOME(position, ~4, copy_count_down, reg1,
				    base_reg1, base_reg2, offset1, offset2))
		  else
		    find_copy_sequence_in_block(position + 2, rest)
	      end
	    else
	      find_copy_sequence_in_block(position + 2, rest)
	  | _ => find_copy_sequence_in_block(position + 1, rest'))
	| _ => find_copy_sequence_in_block(position + 1, rest'))

  fun is_clear(I386_Assembly.r32 reg, I386_Assembly.r_m32(I386_Assembly.INL reg')) =
    (reg = reg', reg)
    | is_clear(I386_Assembly.r_m32(I386_Assembly.INL reg'), I386_Assembly.r32 reg) =
      (reg = reg', reg)
    | is_clear _ = (false, I386Types.cond)

  fun needs_rewrite [] = false
    | needs_rewrite((I386_Assembly.OPCODE(I386_Assembly.pop, [I386_Assembly.r32 r1]),
		     NONE, _) ::
		    (I386_Assembly.OPCODE(I386_Assembly.push, [I386_Assembly.r32 r2]),
		     NONE, _) ::
		    rest) =
      r1 = r2 orelse needs_rewrite rest
    | needs_rewrite((I386_Assembly.OPCODE(I386_Assembly.mov,
					  [op1 as I386_Assembly.r_m32
					   (I386_Assembly.INR a),
					   I386_Assembly.imm8 _]),
		     NONE, comment) ::
		    (rest as ((I386_Assembly.OPCODE(I386_Assembly.mov,
						    [I386_Assembly.r32 reg, op2]),
			       NONE, _) ::
			      _))) =
      op1 = op2 orelse needs_rewrite rest
    | needs_rewrite((I386_Assembly.OPCODE(I386_Assembly.mov,
					  [op1 as I386_Assembly.r_m32
					   (I386_Assembly.INR a),
					   I386_Assembly.imm16 _]),
		     NONE, comment) ::
		    (rest as ((I386_Assembly.OPCODE(I386_Assembly.mov,
						    [I386_Assembly.r32 reg, op2]),
			       NONE, _) ::
			      _))) =
      op1 = op2 orelse needs_rewrite rest
    | needs_rewrite((I386_Assembly.OPCODE(I386_Assembly.mov,
					  [op1 as I386_Assembly.r_m32
					   (I386_Assembly.INR a),
					   I386_Assembly.imm32 _]),
		     NONE, comment) ::
		    (rest as ((I386_Assembly.OPCODE(I386_Assembly.mov,
						    [I386_Assembly.r32 reg, op2]),
			       NONE, _) ::
			      _))) =
      op1 = op2 orelse needs_rewrite rest
    | needs_rewrite((I386_Assembly.OPCODE(I386_Assembly.mov, [op1, op2]),
		     NONE, comment) ::
		    (rest as ((I386_Assembly.OPCODE(I386_Assembly.mov, [op3, op4]),
			       NONE, _) ::
			      rest'))) =
      if (op1 = op4 andalso op2 = op3) then
	true
      else
	(* Check for other potential rewrites involving moves *)
	(case rest' of
	   [] => false
	 | (I386_Assembly.OPCODE(I386_Assembly.mov, [op5, op6]),
	     NONE, comment) :: rest'' =>
	     (op2 = op3 andalso op5 = op6 andalso op1 = op5) orelse needs_rewrite rest
	 | _ => needs_rewrite rest)
    | needs_rewrite((I386_Assembly.OPCODE(I386_Assembly.xor, [a, b]), _, _) :: rest) =
      let
	val (ok, _) = is_clear(a, b)
      in
	ok orelse needs_rewrite rest
      end
    | needs_rewrite((I386_Assembly.OPCODE(I386_Assembly.lea,
					  [I386_Assembly.r32 reg,
					   I386_Assembly.r_m32
					   (I386_Assembly.INR
					    (I386_Assembly.MEM
					     {base=SOME reg',
					      index=SOME(reg'', NONE),
					      offset=offset}))]), _, _) :: rest) =
      let
	val offset_ok = case offset of
	  SOME(I386_Assembly.SMALL i) => i = 0
	| SOME(I386_Assembly.LARGE(i, j)) => i = 0 andalso j = 0
	| _ => true
      in
	offset_ok andalso (reg = reg' orelse reg = reg'')
      end
    | needs_rewrite(_ :: rest) = needs_rewrite rest

  fun rewrite_block(done, _, []) = rev done
    | rewrite_block(done, set,
		    not_done as ((instr as (opcode, tag_opt, comment)) :: instrs)) =
      let
	val (defs, _, _, _) = I386_Assembly.defines_and_uses opcode
      in
	case opcode of
	  I386_Assembly.OPCODE(I386_Assembly.xor, [a, b]) =>
	    let
	      val (ok, reg) = is_clear(a, b)
	    in
	      if ok then
		if Set.is_member(reg, set) then
		  rewrite_block(done, set, instrs) (* Omit reset to zero of reg *)
		else
		  rewrite_block(instr :: done, Set.add_member(reg, set), instrs)
	      else
		rewrite_block(instr :: done, set, instrs)
	    end
	| (opc as I386_Assembly.OPCODE(I386_Assembly.lea,
				[I386_Assembly.r32 reg,
				 I386_Assembly.r_m32
				 (I386_Assembly.INR
				  (I386_Assembly.MEM
				   {base=SOME reg',
				    index=NONE,
				    offset=SOME offs}))])) =>
	  (case offs of
	     I386_Assembly.SMALL i =>
	       if i = 0 then
		 (if Set.is_member(reg', set) then
		    if Set.is_member(reg, set) then
		      (* Here we are resetting to zero a register which is already zero *)
		      rewrite_block(done, set, instrs)
		    else
		      (* Here we are resetting to zero a register not known to be zero *)
		      rewrite_block((I386_Assembly.OPCODE(I386_Assembly.xor,
							  [I386_Assembly.r32 reg,
							   I386_Assembly.r_m32
							   (I386_Assembly.INL reg)]),
				     tag_opt, comment) :: done,
				    Set.add_member(reg, set), instrs)
		  else
		    (* Here we have an lea which is really a move *)
		    rewrite_block((I386_Assembly.OPCODE(I386_Assembly.mov,
							  [I386_Assembly.r32 reg,
							   I386_Assembly.r_m32
							   (I386_Assembly.INL reg')]),
				     tag_opt, comment) :: done,
				    Set.setdiff(set, defs), instrs))
	       else
		 if (i < ~128 orelse i > 127) andalso Set.is_member(reg', set) then
		   (rewrite_block((I386_Assembly.OPCODE(I386_Assembly.mov,
							[I386_Assembly.r32 reg,
							 I386_Assembly.imm32(i div 4, i mod 4)]),
				   tag_opt, comment) :: done, Set.setdiff(set, defs), instrs))
		 else
		   rewrite_block(instr :: done, Set.setdiff(set, defs), instrs)
	   | I386_Assembly.LARGE(i, j) =>
	       if (i < ~32 orelse i > 31) andalso Set.is_member(reg', set) then
		 rewrite_block((I386_Assembly.OPCODE(I386_Assembly.mov,
						     [I386_Assembly.r32 reg,
						      I386_Assembly.imm32(i, j)]),
				tag_opt, comment) :: done, Set.setdiff(set, defs), instrs)
	       else
		 rewrite_block(instr :: done, Set.setdiff(set, defs), instrs))
	| (I386_Assembly.OPCODE(I386_Assembly.lea,
				[I386_Assembly.r32 reg,
				 I386_Assembly.r_m32
				 (I386_Assembly.INR
				  (I386_Assembly.MEM
				   {base=SOME reg',
				    index=SOME(reg'', NONE),
				    offset=offset}))])) =>
	  let
	    (* Thanks to Tony for this one *)
	    val offset_ok = case offset of
	      SOME(I386_Assembly.SMALL i) => i = 0
	    | SOME(I386_Assembly.LARGE(i, j)) => i = 0 andalso j = 0
	    | _ => true
	    val set = Set.setdiff(set, defs)
	  in
	    if offset_ok then
	      if reg = reg' then
		rewrite_block((I386_Assembly.OPCODE(I386_Assembly.add,
						    [I386_Assembly.r32 reg,
						     I386_Assembly.r_m32
						     (I386_Assembly.INL reg'')]),
			       tag_opt, comment) :: done, set, instrs)
	      else
		if reg = reg'' then
		  rewrite_block((I386_Assembly.OPCODE(I386_Assembly.add,
						      [I386_Assembly.r32 reg,
						       I386_Assembly.r_m32
						       (I386_Assembly.INL reg')]),
				 tag_opt, comment) :: done, set, instrs)
		else
		  rewrite_block(instr :: done, set, instrs)
	    else
	      rewrite_block(instr :: done, set, instrs)
	  end
	| _ =>
	    let
	      val set = Set.setdiff(set, defs)
	    in
	      case not_done of
		((pop as
		  (I386_Assembly.OPCODE(I386_Assembly.pop, [I386_Assembly.r32 r1]),
		   NONE, _)) ::
		 (push as
		  (I386_Assembly.OPCODE(I386_Assembly.push, [I386_Assembly.r32 r2]),
		   NONE, _)) :: rest) =>
		if r1 = r2 then
		  rewrite_block(done, set, rest) (* Omit pop/push of same register *)
		else
		  rewrite_block(push :: pop :: done, set, rest)
	      | ((mov1 as (I386_Assembly.OPCODE(I386_Assembly.mov, [op1, op2]),
			   NONE, comment1)) ::
		 (mov2 as (I386_Assembly.OPCODE(I386_Assembly.mov, [op3, op4]),
			   NONE, comment2)) ::
		 rest) =>
		if op1 = op4 andalso op2 = op3 then
		  (* Here we check for a further inefficiency *)
		  (* We may be able to remove mov1 as well *)
		  (* This all steams from sequences of MIR like *)
		  (* ld gcn, r[clos] ; st gcn, s[reg]; ld gcn, s[clos] *)
		  (* The first ld translates into a move from store into ecx *)
		  (* and then onto the stack. The st translates *)
		  (* to a move from the stack back to ecx *)
		  (* and then from ecx into store *)
		  (* The second ld translates into a move from store into ecx *)
		  (* and then back into the same stack slot used by the first ld *)
		  (* Hence rendering the first move onto the stack irrelevant *)
		  case (mov1, rest) of
		    ((I386_Assembly.OPCODE(I386_Assembly.mov,
					  [I386_Assembly.r_m32
					   (I386_Assembly.INR
					    (I386_Assembly.MEM
					     {base=SOME I386Types.ESP,
					      index=NONE,
					      offset=offset1})),
					   I386_Assembly.r32 reg1]),
		     NONE, _),
		     (op1 as (I386_Assembly.OPCODE(I386_Assembly.mov,
						   [I386_Assembly.r_m32
						    (I386_Assembly.INR
						     (I386_Assembly.MEM
						      {base=SOME reg',
						      index=NONE,
						       offset=offset2})),
						    I386_Assembly.r32 reg2]),
			      NONE, _)) ::
		     (op2 as (I386_Assembly.OPCODE(I386_Assembly.mov,
						   [I386_Assembly.r32 reg3,
						    I386_Assembly.r_m32
						    (I386_Assembly.INR
						     (I386_Assembly.MEM
						      {base=SOME reg'',
						       index=NONE,
						       offset=offset3}))]),
			      NONE, _)) ::
		     (op3 as (I386_Assembly.OPCODE(I386_Assembly.mov,
						   [I386_Assembly.r_m32
						    (I386_Assembly.INR
						     (I386_Assembly.MEM
						      {base=SOME I386Types.ESP,
						       index=NONE,
						       offset=offset4})),
						    I386_Assembly.r32 reg4]),
			      NONE, _)) :: rest') =>
		    let
		      val do_rewrite =
			reg1 = reg4 andalso offset1 = offset4 andalso
			reg2 = reg1 andalso reg3 = reg1 andalso
			(reg'' <> I386Types.ESP orelse offset3 <> offset1)
			val op1' = #1 op1
			val op2' = #1 op2
			val op3' = #1 op3
		    in
		      if do_rewrite then
			let
			  val (defs1, _, _, _) = I386_Assembly.defines_and_uses op1'
			  val (defs2, _, _, _) = I386_Assembly.defines_and_uses op2'
			  val (defs3, _, _, _) = I386_Assembly.defines_and_uses op3'
			  val set = Set.setdiff
			    (Set.setdiff(Set.setdiff(set, defs1), defs2), defs3)
			in
			  rewrite_block(op2 :: op1 :: done, set, op3 :: rest')
			  (* Note that op3 may be a further candidate for this reduction *)
			end
		      else
			(rewrite_block(mov1 :: done, set, rest))
		    end
		     | _ => rewrite_block(mov1 :: done, set, rest)
		else
		  (* Here we look for mov a, $n; mov reg, a *)
		  (* which we rewrite as xor reg, reg; mov a, reg *)
		  (* or mov reg, $n; mov a, reg depending on whther n = 0 or not *)
		  (* We must take care here that reg is defined but not used *)
		  (* by mov a, reg else we shall corrupt reg before the store into a *)
		  (* We also look for mov reg, a; mov b, reg; mov reg, a *)
		  (* which we rewrite by leaving out the second mov *)
		  if op1 = op4 then
		    if is_mem op1 then
		      (case op3 of
			 I386_Assembly.r32 reg =>
			   let
			     val (is_imm, is_zero) =
			     case op2 of
			       I386_Assembly.imm8 i => (true, i = 0)
			     | I386_Assembly.imm16 i => (true, i = 0)
			     | I386_Assembly.imm32(i, j) => (true, i = 0 andalso j = 0)
			     | _ => (false, false)
			   in
			     if is_imm then
			       if not(involves(reg, op4)) then
				 let
				   val mov2' =
				     (I386_Assembly.OPCODE(I386_Assembly.mov, [op1, op3]),
				      NONE, comment2)
				   val mov1' =
				     if is_zero then
				       (I386_Assembly.OPCODE(I386_Assembly.xor,
							     [op3,
							      I386_Assembly.r_m32
							      (I386_Assembly.INL reg)]),
					NONE, comment1)
				     else
				       (I386_Assembly.OPCODE(I386_Assembly.mov, [op3, op2]),
					NONE, comment1)
				   val (defs', _, _, _) =
				     I386_Assembly.defines_and_uses(#1 mov1')
				   val set' = Set.setdiff(set, defs')
				   val set' =
				     if is_zero then Set.add_member(reg, set') else set'
				   val omit_mov1 =
				     is_zero andalso Set.is_member(reg, set)
				   val done =
				     if omit_mov1 then done else mov1' :: done
				 in
				   rewrite_block(mov2' :: done, set', rest)
				 end
			       else
				 (* mov2 corrupts its argument so we can't rewrite *)
				 rewrite_block(mov1 :: done, set, mov2 :: rest)
			     else
			       (* Non immediate version *)
			       (* Optimise the case of mov a, reg ; mov reg', a *)
			       (* into mov a, reg; mov reg', reg *)
			       if is_reg op2 then
				 let
				   val (defs', _, _, _) =
				     I386_Assembly.defines_and_uses(#1 mov2)
				   val set = Set.setdiff(set, defs')
				   val mov2' =
				     (I386_Assembly.OPCODE(I386_Assembly.mov,
							   [op3, convert_reg op2]),
				      NONE, comment2)
				 in
				   rewrite_block(mov2' :: mov1 :: done, set, rest)
				 end
			       else
				 (* This almost never happens, so isn't worth optimising *)
				 (rewrite_block(mov1 :: done, set, mov2 :: rest))
			   end
		       | _ => rewrite_block(mov1 :: done, set, mov2 :: rest))
		    else
		      (* op1 not a memory operand *)
		      (* Should therefore be a register operand *)
		      (* But it might be something not 32 bit *)
		      (* in which case we would leave well alone *)
		      if is_reg op1 then
			case rest of
			  mov3 :: rest' =>
			    if #1 mov1 = #1 mov3 andalso is_mem op3 then
			      (* We can delete mov3 *)
			      (* As it simply repeats mov1 and mov2 can't change *)
			      (* the store moved into a reg by mov1 *)
			      (rewrite_block(mov1 :: done, set, mov2 :: rest'))
			    else
			      rewrite_block(mov1 :: done, set, mov2 :: rest)
			| _ =>
			      (* This case should never happen *)
			      (rewrite_block(mov1 :: done, set, mov2 :: rest))
		      else
			(rewrite_block(mov1 :: done, set, mov2 :: rest))
		  else
		    (* op1 <> op4 *)
		    (* No known rewrites at present *)
		    rewrite_block(mov1 :: done, set, mov2 :: rest)
	      | (opc :: rest) => rewrite_block(opc :: done, set, rest)
	      | [] => rev done (* Should never occur, but makes match exhaustive *)
	    end
      end

  fun reschedule_block x =
    if needs_rewrite x then
      rewrite_block([], Set.empty_set, x)
    else
      x

  fun deal_with_tags(_, new_block_map, []) = new_block_map
    | deal_with_tags(old_block_map, new_block_map, tag :: tags) =
      case NewMap.tryApply'(new_block_map, tag) of
	NONE =>
	  (case NewMap.tryApply'(old_block_map, tag) of
	     NONE => deal_with_tags(old_block_map, new_block_map, tags)
	       (* Tag refers outside procedure anyway *)
	   | SOME opcode_list =>
	       let
		 val tags = Lists.reducel
		   (fn (tags, (_, SOME tag, _)) => tag :: tags
		     | (tags, _) => tags)
		   (tags, opcode_list)
	       in
		 deal_with_tags(old_block_map,
				NewMap.define(new_block_map, tag, opcode_list),
				tags)
	       end)
      | _ => deal_with_tags(old_block_map, new_block_map, tags)

  fun rev_app([], y) = y
    | rev_app(x :: xs, y) = rev_app(xs, x:: y)

  fun split_block(previous, after, insert, n) =
    if n < 0 then
      Crash.impossible"split_block:negative argument"
    else
      if n = 0 then
	(rev_app(previous, insert), after)
      else
	case after of
	  instr :: instrs =>
	    split_block(instr :: previous, instrs, insert, n-1)
	| _ => Crash.impossible"split_block:end of list"

  fun drop(n, x) =
    if n < 0 then
      Crash.impossible"drop:negative argument"
    else
      if n = 0 then
	x
      else
	case x of
	  _ :: xs => drop(n-1, xs)
	| _ => Crash.impossible"drop:end of list"

  fun convert_copy_blocks(done, []) = done
    | convert_copy_blocks(done, (block as (tag, x)) :: blocks) =
      (case find_copy_sequence_in_block(0, x) of
	 SOME(position, inc, copy_count, reg1,
			base_reg1, base_reg2, offset1, offset2) =>
	 let
	   val new_tag = MirTypes.new_tag()
	   val direction_op =
	     if inc = 4 then I386_Assembly.cld else I386_Assembly.std
	   val insert =
	     [(I386_Assembly.OPCODE
	       (I386_Assembly.push,
		[I386_Assembly.r32 I386Types.ESI]),
	       NONE, "save string source"),
	      (I386_Assembly.OPCODE
	       (I386_Assembly.push,
		[I386_Assembly.r32 I386Types.EDI]),
	       NONE, "save string destination"),
	      (I386_Assembly.OPCODE
	       (I386_Assembly.push,
		[I386_Assembly.r32 I386Types.ESI]),
	       NONE, "save global"),
	      (I386_Assembly.OPCODE
	       (I386_Assembly.lea,
		[I386_Assembly.r32 I386Types.ESI,
		 I386_Assembly.r_m32
		 (I386_Assembly.INR
		  (I386_Assembly.MEM
		   {base=SOME base_reg1,
		    index=NONE,
		    offset=SOME(I386_Assembly.SMALL offset1)}))]),
	       NONE, "Set string source to base of stuff to copy"),
	      (I386_Assembly.OPCODE
	       (I386_Assembly.lea,
		[I386_Assembly.r32 I386Types.EDI,
		 I386_Assembly.r_m32
		 (I386_Assembly.INR
		  (I386_Assembly.MEM
		   {base=SOME base_reg2,
		    index=NONE,
		    offset=SOME(I386_Assembly.SMALL offset2)}))]),
	       NONE, "Set string destination to base of area to copy to"),
	      (I386_Assembly.OPCODE(direction_op, []),
	       NONE, "set direction flag appropriately"),
	      (I386_Assembly.OPCODE
	       (I386_Assembly.mov,
		[I386_Assembly.r32 I386Types.global,
		 I386_Assembly.imm32(copy_count div 4, copy_count mod 4)]),
	       NONE, "initialise counter for loop"),
	      (I386_Assembly.OPCODE(I386_Assembly.jmp, [I386_Assembly.rel32 0]),
	       SOME new_tag, "jump to start of loop (should be elided)")]
	   val (pre_block, post_block) =
	     split_block([], x, insert, position)
	   val post_block =
	     (I386_Assembly.OPCODE
	      (I386_Assembly.movsd, []), NONE, "One word move") ::
	     (I386_Assembly.OPCODE
	      (I386_Assembly.loop, []), SOME new_tag, "loop until ecx = 0") ::
	     (I386_Assembly.OPCODE
	      (I386_Assembly.mov,
	       [I386_Assembly.r32 reg1,
		I386_Assembly.r_m32
		(I386_Assembly.INR
		 (I386_Assembly.MEM
		  {base=SOME base_reg1,
		   index=NONE,
		   offset=SOME(I386_Assembly.SMALL(offset1 + inc*(copy_count-1)))}))]),
	      NONE, "load intermediate register final value") ::
	     (I386_Assembly.OPCODE
	      (I386_Assembly.pop, [I386_Assembly.r32 I386Types.global]),
	      NONE, "restore global (probably unnecessary)") ::
	     (I386_Assembly.OPCODE
	      (I386_Assembly.pop, [I386_Assembly.r32 I386Types.EDI]),
	      NONE, "restore string destination") ::
	     (I386_Assembly.OPCODE
	      (I386_Assembly.pop, [I386_Assembly.r32 I386Types.ESI]),
	      NONE, "restore string source") ::
	     drop(copy_count*2, post_block) (* Remove the old code *)
	 in
	   convert_copy_blocks((tag, pre_block) :: done, (new_tag, post_block) :: blocks)
	 end
       | _ =>
	   convert_copy_blocks(block :: done, blocks))

  (* This just removes unreachable blocks *)
  fun reschedule_proc(proc_tag, blocks) =
    let
(*
      val blocks = convert_copy_blocks([], blocks)
*)
      val block_map = NewMap.from_list blocks
      val new_block_map = NewMap.empty
    in
      (proc_tag, NewMap.to_list(deal_with_tags(block_map, new_block_map, [proc_tag])))
    end

end
@


1.14.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.14  1999/02/02  15:59:52  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.13
log
@[Bug #20116]
Fix poor code sequences bserved in 20116 and 20118
@
text
@d4 4
a52 3
require "../basis/__int";

require "../utils/_hashset";
@


1.12
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
a70 459
(*
  structure HashSet = HashSet(
    structure Crash = Crash
    structure Lists = Lists
    type element = MirTypes.tag
    val eq = MirTypes.equal_tag
    val size = 1000
    val hash = MirTypes.int_of_tag
      )
  val new_tag = MirTypes.new_tag

  val new_tag = fn x => new_tag()

  val hashset_size = 32

  fun refs_for_opcode_list(done, []) = done
  | refs_for_opcode_list(done, (_, SOME tag, _) :: rest) =
    refs_for_opcode_list(HashSet.add_member(done, tag), rest)
  | refs_for_opcode_list(done, _ :: rest) =  refs_for_opcode_list(done, rest)

  fun refs_for_block(done, (tag, opcode_list)) =
    refs_for_opcode_list(done, opcode_list)

  fun refs_all(tag, block_list) =
    Lists.reducel
    refs_for_block
    (HashSet.add_member(HashSet.empty_set hashset_size, tag), block_list)

  val nop_code = I386_Assembly.nop_code
  val nop = (nop_code, NONE, "")

  fun sets_miss(s1, s2) =
    let
      val l1 = Set.set_to_list s1
    in
      not(Lists.exists (fn x => Set.is_member(x, s2)) l1)
    end

  fun passes_from_sets((first_i_defines, first_i_uses, first_r_defines,
			first_r_uses),
		       (second_i_defines, second_i_uses, second_r_defines,
			second_r_uses)) =
    (* Return true if the first instruction can safely pass the second *)
    sets_miss((first_i_defines, second_i_defines))
    andalso
    sets_miss((first_i_defines, second_i_uses)) andalso
    sets_miss((first_i_uses, second_i_defines)) andalso
    sets_miss((first_r_defines, second_r_defines))
    andalso
    sets_miss((first_r_defines, second_r_uses)) andalso
    sets_miss((first_r_uses, second_r_defines))
    andalso
    ((not (Set.is_member(I386Types.cond, second_r_defines))) orelse
     (Set.empty_setp first_r_defines andalso Set.empty_setp first_r_uses))
  (* Final clause says fp instructions can't pass fp comparisions *)
  (* This is because the poxious architecture demands a non-fp *)
  (* instruction between a FCMP and a FBfcc *)

  fun convert_branch_annul(I386_Assembly.BRANCH_ANNUL
			   (branch, disp), tag_opt, comment) =
    (I386_Assembly.BRANCH(branch, disp), tag_opt, comment)
    | convert_branch_annul(I386_Assembly.FBRANCH_ANNUL
			   (branch, disp), tag_opt, comment) =
      (I386_Assembly.FBRANCH(branch, disp), tag_opt, comment)
    | convert_branch_annul opcode = opcode

  fun has_delay(I386_Assembly.BRANCH _) = true
    | has_delay(I386_Assembly.BRANCH_ANNUL _) = true
    | has_delay(I386_Assembly.FBRANCH _) = true
    | has_delay(I386_Assembly.FBRANCH_ANNUL _) = true
    | has_delay(I386_Assembly.Call _) = true
    | has_delay(I386_Assembly.JUMP_AND_LINK _) = true
    | has_delay _ = false

  fun remove_doubled_instrs(tag, opcode_list) =
    let
      fun remove(done, []) = rev done
      | remove(done, [x]) = rev(x :: done)
      | remove(done, [x, y]) = rev(y :: x :: done)
      | remove(done,
	       (opc as (I386_Assembly.BRANCH_ANNUL(opcode, i),
			SOME tag, comment)) ::
	       (other as
		(op1 as (opc1, opt1, _)) ::
		(op2 as (opc2, opt2, _)) :: rest)) =
	(case opcode of
	   I386_Assembly.BA =>
             (* Got rid of the error message as it was given for computed gotos -
                we really ought to check that it is a computed goto at this point *)
	      remove(opc :: done, other)
	 | _ =>
	     if opc1 = opc2 andalso opt1 = opt2 then
	       remove(op1 :: (I386_Assembly.BRANCH(opcode, i),
			      SOME tag, comment) :: done, rest)
	     else
	       remove(op1 :: opc :: done, op2 :: rest))
	| remove(done, x :: rest) = remove(x :: done, rest)
	  
    in
      (tag, remove([], opcode_list))
    end

  fun get_tag_and_instr(tag, opcode :: _) = (tag, opcode)
    | get_tag_and_instr(_, _) = Crash.impossible"Empty block"

  fun find_baa_block(_, []) = Crash.impossible"Empty block"
    | find_baa_block(_, (I386_Assembly.BRANCH_ANNUL(I386_Assembly.BA, _),
			 _, _) :: rest) =
      (case rest of
	 [] => true
       | [(I386_Assembly.ARITHMETIC_AND_LOGICAL(I386_Assembly.AND,
						 I386Types.G0,
						 I386_Assembly.IMM 0,
						 I386Types.G0),
	   _, _)] => true
       | _ => Crash.impossible"Unreachable instructions after BAA")
    | find_baa_block _ = false

  fun get_transitive_dest baa_tags_and_dests =
    let
      fun g_t_d(visited, tag) =
	(case NewMap.tryApply'(baa_tags_and_dests, tag) of
	   NewMap.YES dest_tag =>
	     (case NewMap.tryApply'(baa_tags_and_dests, dest_tag) of
		NewMap.YES _ =>
		  if not(Lists.member(tag, visited)) then
		    g_t_d(tag :: visited, dest_tag)
		  else dest_tag
	      | NewMap.NO => dest_tag)
	 | NewMap.NO => Crash.impossible"get_transitive_dest failure")
    in
      g_t_d
    end

  fun replace_chained_branch baa_tags_and_dests =
    fn (opcode as (I386_Assembly.BRANCH(branch, _),
		   SOME tag, comment)) =>
    (case NewMap.tryApply'(baa_tags_and_dests, tag) of
       NewMap.YES dest_tag => 
	 (I386_Assembly.BRANCH(branch, 0), SOME dest_tag, comment)
     | NewMap.NO => opcode)
    | (opcode as (I386_Assembly.BRANCH_ANNUL(branch,_),
		  SOME tag, comment)) =>
      (case NewMap.tryApply'(baa_tags_and_dests, tag) of
	 NewMap.YES dest_tag =>
	   (I386_Assembly.BRANCH_ANNUL(branch, 0), SOME dest_tag, comment)
       | NewMap.NO => opcode)
    |  opcode => opcode

  fun has_delay'(I386_Assembly.LOAD_OFFSET _) = true
    | has_delay' x = has_delay x

  fun reschedule_proc(tag, block_list) =
    let
      (* Attempt to move instructions from the starts of blocks into the delay slots *)
      (* of instructions referencing them from other blocks *)
      (* Mustn't move LOAD_OFFSET instructions *)
      (* which may expand into more than one opcode *)
(*
      val _ = print("reschedule_proc with " ^
		    Int.toString(Lists.length block_list) ^ "blocks")
      val _ = output(std_out, "Reschedule proc tag " ^ MirTypes.print_tag tag ^ "\n")
*)

      val baa_blocks = Lists.filterp find_baa_block block_list

      val baa_tags_and_dests =
	Lists.reducel
	(fn (tree,
	     (tag,
	      (I386_Assembly.BRANCH_ANNUL(I386_Assembly.BA, _),
	       SOME dest_tag, _) :: _)) =>
	 NewMap.define(tree, tag, dest_tag)
	     | _ => Crash.impossible"Bad baa block")
	(NewMap.empty, baa_blocks)

      val get_transitive_dest' = get_transitive_dest baa_tags_and_dests

      val baa_tags_and_dests =
	Lists.reducel
	(fn (tree, (tag, _)) =>
	 NewMap.define(tree, tag, get_transitive_dest'([], tag)))
	(NewMap.empty, baa_blocks)

      val replace_chained_branch' = replace_chained_branch baa_tags_and_dests

      val block_list =
	map
	(fn (tag, opcode_list) =>
	 (tag, map replace_chained_branch' opcode_list))
	block_list

      val all_tags_and_instrs =	map get_tag_and_instr block_list

      val ok_tags_and_instrs =
	Lists.filterp
	(fn (_, (x, _, _)) => not(has_delay' x))
	all_tags_and_instrs

(*
      val _ = output(std_out, "ok_tags =\n")
      val _ = Lists.iterate
	(fn (tag, _) => output(std_out, MirTypes.print_tag tag ^ "\n"))
	ok_tags_and_instrs
*)
	
      fun get_ref_tags_for_block(done, []) = done
	| get_ref_tags_for_block(done,
				 (I386_Assembly.BRANCH_ANNUL(branch, _),
				  SOME tag, _) :: rest) =
	  (case (branch, rest) of
	     (I386_Assembly.BA, _) =>
	       get_ref_tags_for_block(done, rest)
	     | (_, (I386_Assembly.ARITHMETIC_AND_LOGICAL
		    (I386_Assembly.AND, I386Types.G0, I386_Assembly.IMM 0,
		     I386Types.G0), _, _) :: _) =>
	       get_ref_tags_for_block(HashSet.add_member(done, tag), rest)
		   | _ => get_ref_tags_for_block(done, rest))
	| get_ref_tags_for_block(done,
				 (I386_Assembly.FBRANCH_ANNUL(branch, _),
				  SOME tag, _) :: rest) =
	  (case (branch, rest) of
	     (I386_Assembly.FBA, _) =>
	       get_ref_tags_for_block(done, rest)
	     | (_, (I386_Assembly.ARITHMETIC_AND_LOGICAL
		    (I386_Assembly.AND, I386Types.G0, I386_Assembly.IMM 0,
		     I386Types.G0), _, _) :: _) =>
	       get_ref_tags_for_block(HashSet.add_member(done, tag), rest)
		   | _ => get_ref_tags_for_block(done, rest))
	| get_ref_tags_for_block(done, _ :: rest) =
	  get_ref_tags_for_block(done, rest)

      val ref_tags =
	Lists.reducel
	(fn (tags, (tag, x)) => get_ref_tags_for_block(tags, x))
	(HashSet.empty_set hashset_size, block_list)

(*
      val _ = output(std_out, "ref_tags =\n")
      val _ = output(std_out,
		     HashSet.set_print(ref_tags, 
				       (fn tag => MirTypes.print_tag tag ^ "\n")))
*)
	
      fun filter_fun(tag, _) = HashSet.is_member(ref_tags, tag)

      val ref_tags_etc =
	Lists.reducel
	(fn (tree, (tag, instr)) =>
	 NewMap.define(tree, tag, (instr, new_tag())))
	(NewMap.empty,
	 Lists.filterp filter_fun ok_tags_and_instrs)

      fun split_blocks(acc, []) = rev acc
      | split_blocks(_, (_, []) :: _) = Crash.impossible"Empty block"
      | split_blocks(acc, (block as (tag, opcode :: rest)) :: others) =
        (case NewMap.tryApply'(ref_tags_etc, tag) of
           NewMap.YES (instr, dest_tag) =>
	     split_blocks
             ((tag,
	       [opcode,
		(I386_Assembly.BRANCH_ANNUL(I386_Assembly.BA, 0),
		 SOME dest_tag,
		 "Split off leading instruction")]) ::
	      (dest_tag, rest) ::
	      acc,
	      others)
	 | NewMap.NO =>
             split_blocks(block :: acc,  others))

      val new_block_list = split_blocks([], block_list)

      fun do_replace(done, []) = rev done
	| do_replace(done, [opcode]) = rev(opcode :: done)
	| do_replace(done, op1 :: op2 :: rest) =
	  (case (op1, op2) of
	     ((I386_Assembly.BRANCH_ANNUL(branch, _), SOME tag,
	       comment),
	      (I386_Assembly.ARITHMETIC_AND_LOGICAL
	       (I386_Assembly.AND, I386Types.G0, I386_Assembly.IMM 0,
		I386Types.G0), _, _)) =>
	     (case NewMap.tryApply'(ref_tags_etc, tag) of
		NewMap.YES ((opcode, tag_opt, comment), new_tag) => 
		  if branch = I386_Assembly.BA then
		    do_replace(op2 :: op1 :: done, rest)
		  else
		    do_replace((opcode, tag_opt, comment ^
				" moved to annulled delay slot") ::
			       (I386_Assembly.BRANCH_ANNUL(branch, 0),
				SOME new_tag, comment) :: done,
			       rest)
	      | NewMap.NO =>
		  do_replace(op2 :: op1 :: done, rest))
	   | ((I386_Assembly.FBRANCH_ANNUL(branch, _), SOME tag,
	       comment),
	      (I386_Assembly.ARITHMETIC_AND_LOGICAL
	       (I386_Assembly.AND, I386Types.G0, I386_Assembly.IMM 0,
		I386Types.G0), _, _)) =>
	     (case NewMap.tryApply'(ref_tags_etc, tag) of
		NewMap.YES ((opcode, tag_opt, comment), new_tag) =>
		  if branch = I386_Assembly.FBA then
		    do_replace(op2 :: op1 :: done, rest)
		  else
		    do_replace((opcode, tag_opt, comment ^
				" moved to annulled delay slot") ::
			       (I386_Assembly.FBRANCH_ANNUL(branch, 0),
				SOME new_tag, comment) :: done,
			       rest)
	      | NewMap.NO =>
		  do_replace(op2 :: op1 :: done, rest))
	   | _ => do_replace(op1 :: done, op2 :: rest))

      fun replace_delay_slots(tag, opcode_list) =
	(tag, do_replace([], opcode_list))

      val new_new_block_list = map replace_delay_slots new_block_list

      val baa_blocks = Lists.filterp find_baa_block new_new_block_list

      val baa_tags_and_dests =
	Lists.reducel
	(fn (tree,
	     (tag,
	      (I386_Assembly.BRANCH_ANNUL(I386_Assembly.BA, _),
	       SOME dest_tag, _) :: _)) =>
	 NewMap.define(tree, tag, dest_tag)
	     | _ => Crash.impossible"Bad baa block")
	(NewMap.empty, baa_blocks)

      val get_transitive_dest' = get_transitive_dest baa_tags_and_dests

      val baa_tags_and_dests =
	Lists.reducel
	(fn (tree, (tag, _)) =>
	 NewMap.define(tree, tag, get_transitive_dest'([], tag)))
	(NewMap.empty, baa_blocks)

      val replace_chained_branch' = replace_chained_branch baa_tags_and_dests

      val next_block_list =
	map
	(fn (tag, opcode_list) =>
	 (tag, map replace_chained_branch' opcode_list))
	new_new_block_list

      val new_ref_tags = refs_all(tag, next_block_list)

      fun use_block(tag, _) = HashSet.is_member(new_ref_tags, tag)
      val final_block_list =
	Lists.filterp use_block next_block_list
      val result as (_, blocks) = (tag, map remove_doubled_instrs final_block_list)
    in
	result
    end

(*
  val reschedule_proc = fn x => reschedule_proc(reschedule_proc x)
*)

  fun combine((i_d1, i_u1, r_d1, r_u1), (i_d2, i_u2, r_d2, r_u2)) =
    (Set.union(i_d1, i_d2), Set.union(i_u1, i_u2), Set.union(r_d1, r_d2),
     Set.union(r_u1, r_u2))

  fun search_for_moveable_instr(pos, _, []) = (pos, false, nop)
    | search_for_moveable_instr(pos, current_defs,
				(opc as (opcode, _, _)) :: rest) =
      if opcode = I386_Assembly.other_nop_code orelse
	(case opcode of I386_Assembly.LOAD_OFFSET _ => true | _ => false)
	then
	  (pos,false,nop)
      else
	let
	  val is_delay = case rest of
	    [] => false
	  | (opc', _, _) :: _ => has_delay opc'
	in
	  if is_delay (*orelse pos >= 100*) then
	    (pos, false, nop)
	  else
	    let
	      val (i_def, i_use, r_def, r_use) =
		I386_Assembly.defines_and_uses opcode
	      val new_defs =
		(Set.setdiff(i_def, Set.singleton I386Types.G0), 
		 Set.setdiff(i_use, Set.singleton I386Types.G0),
		 r_def, r_use)
	    in
	      if pos <= 1 andalso
		(case rest of
		   (opc', _, _) :: _ =>
		     Set.is_member(I386Types.cond,
				   #3 (I386_Assembly.defines_and_uses opc'))
		 | _ => false) then
		   (* Above test to ensure we don't remove the separating *)
		   (* instruction between an FCMP and an FBRANCH *)
		   search_for_moveable_instr(pos+1, combine(new_defs,
							    current_defs), rest)
	      else
		if passes_from_sets(new_defs, current_defs) then
		  (pos, true, opc)
		else
		  search_for_moveable_instr(pos+1, combine(new_defs, current_defs),
					    rest)
	    end
	end

  fun copy_over(n, done, rest) =
    if n < 0 then
      Crash.impossible"copy_over negative argument"
    else
      if n = 0 then (done, rest)
      else
	case rest of
	  [] => Crash.impossible"copy_over run out of list"
	| x :: xs => copy_over(n-1, x :: done, xs)

  fun traverse(done, []) = done
    | traverse(done, [x]) = x :: done
    | traverse(done, (x as (opc1, _, _)) ::
	       (rest as ((y as (opc2, _, _)) :: rest_of_block))) =
      if opc1 = nop_code andalso has_delay opc2 then
	(* The difficult case, we've found a delay slot we would like to fill *)
	let
	  val (pos, found, z) =
	    search_for_moveable_instr(0, I386_Assembly.defines_and_uses opc2,
				      rest_of_block)
	in
	  if found then
	    (* Got a moveable instr, so move it in *)
	    let
	      val (done, rest) =
		copy_over(pos, convert_branch_annul y :: z :: done,
			  rest_of_block)
	    in
	      case rest of
		[] => Crash.impossible"Scheduled from beyond end of block"
	      | x :: xs => traverse(done, xs)
	    end
	  else
	    traverse(y :: x :: done, rest_of_block)
	  (*
	   traverse(copy_over(if pos >= 2 then pos-2 else 0, y :: x :: done,
	   rest_of_block))
	   (* Copy over the number of failed instructions first *)
	   (* Making sure we don't skip any further delay instructions *)
	   *)
	end
      else
	traverse(x :: done, rest)

  fun reschedule_block
    (ops as [_, {1=I386_Assembly.BRANCH_ANNUL(I386_Assembly.BA, _), ...}, _]) = ops
    | reschedule_block opcode_list =
      let
        val rev_list = rev opcode_list
      in
        traverse([], rev_list)
      end
*)
d76 4
d84 17
d210 30
d244 11
a254 2
			      _))) =
      (op1 = op4 andalso op2 = op3) orelse needs_rewrite rest
d292 1
a292 2
		  ((*output(std_out, "Removing superfluous xor reg, reg\n");*)
		   rewrite_block(done, set, instrs) (* Omit reset to zero of reg *))
d298 1
a298 1
	| (I386_Assembly.OPCODE(I386_Assembly.lea,
d308 21
a328 6
	       if (i < ~128 orelse i > 127) andalso Set.is_member(reg', set) then
		 ((*output(std_out, "Shortening lea after xor to move\n");*)
		  rewrite_block((I386_Assembly.OPCODE(I386_Assembly.mov,
						      [I386_Assembly.r32 reg,
						       I386_Assembly.imm32(i div 4, i mod 4)]),
				 tag_opt, comment) :: done, Set.setdiff(set, defs), instrs))
d330 7
a336 1
		 rewrite_block(instr :: done, Set.setdiff(set, defs), instrs)
d339 4
a342 5
		 ((*output(std_out, "Shortening lea after xor to move\n");*)
		  rewrite_block((I386_Assembly.OPCODE(I386_Assembly.mov,
						      [I386_Assembly.r32 reg,
						       I386_Assembly.imm32(i, j)]),
				 tag_opt, comment) :: done, Set.setdiff(set, defs), instrs))
a362 1
		((*output(std_out, "Replacing lea rn, [rn][rm] with add rn, rm\n");*)
d367 1
a367 1
			       tag_opt, comment) :: done, set, instrs))
a369 1
		  ((*output(std_out, "Replacing lea rn, [rm][rn] with add rn, rm\n");*)
d374 1
a374 1
				 tag_opt, comment) :: done, set, instrs))
d396 1
a396 1
			   NONE, comment)) ::
d398 1
a398 1
			   NONE, _)) ::
d401 72
a472 1
		  rewrite_block(mov1 :: done, set, rest)
d474 95
a568 1
		  rewrite_block(mov1 :: done, set, mov2 :: rest)
@


1.12.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.12  1997/05/06  10:07:04  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.12.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.12  1997/05/06  10:07:04  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.11
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d83 1
a83 1
  | refs_for_opcode_list(done, (_, MLWorks.Option.SOME tag, _) :: rest) =
d96 1
a96 1
  val nop = (nop_code, MLWorks.Option.NONE, "")
d148 1
a148 1
			MLWorks.Option.SOME tag, comment)) ::
d160 1
a160 1
			      MLWorks.Option.SOME tag, comment) :: done, rest)
d203 1
a203 1
		   MLWorks.Option.SOME tag, comment)) =>
d206 1
a206 1
	 (I386_Assembly.BRANCH(branch, 0), MLWorks.Option.SOME dest_tag, comment)
d209 1
a209 1
		  MLWorks.Option.SOME tag, comment)) =>
d212 1
a212 1
	   (I386_Assembly.BRANCH_ANNUL(branch, 0), MLWorks.Option.SOME dest_tag, comment)
d238 1
a238 1
	       MLWorks.Option.SOME dest_tag, _) :: _)) =>
d276 1
a276 1
				  MLWorks.Option.SOME tag, _) :: rest) =
d287 1
a287 1
				  MLWorks.Option.SOME tag, _) :: rest) =
d329 1
a329 1
		 MLWorks.Option.SOME dest_tag,
d343 1
a343 1
	     ((I386_Assembly.BRANCH_ANNUL(branch, _), MLWorks.Option.SOME tag,
d356 1
a356 1
				MLWorks.Option.SOME new_tag, comment) :: done,
d360 1
a360 1
	   | ((I386_Assembly.FBRANCH_ANNUL(branch, _), MLWorks.Option.SOME tag,
d373 1
a373 1
				MLWorks.Option.SOME new_tag, comment) :: done,
d391 1
a391 1
	       MLWorks.Option.SOME dest_tag, _) :: _)) =>
d544 1
a544 1
				 (MLWorks.Option.INR
d546 4
a549 4
				   {base=MLWorks.Option.SOME base_reg1,
				    index=MLWorks.Option.NONE,
				    offset=MLWorks.Option.SOME(I386_Assembly.SMALL offset1)}))]),
			       MLWorks.Option.NONE, _)) ::
d554 1
a554 1
				 (MLWorks.Option.INR
d556 3
a558 3
				   {base=MLWorks.Option.SOME base_reg2,
				    index=MLWorks.Option.NONE,
				    offset=MLWorks.Option.SOME(I386_Assembly.SMALL offset2)})),
d560 1
a560 1
			       MLWorks.Option.NONE, _)) ::
d576 3
a578 3
  fun find_copy_sequence_in_block(_, []) = MLWorks.Option.NONE
    | find_copy_sequence_in_block(_, [_]) = MLWorks.Option.NONE
    | find_copy_sequence_in_block(position, [_, _]) = MLWorks.Option.NONE
d585 1
a585 1
	    (MLWorks.Option.INR
d587 4
a590 4
	      {base=MLWorks.Option.SOME base_reg1,
	       index=MLWorks.Option.NONE,
	       offset=MLWorks.Option.SOME(I386_Assembly.SMALL offset1)}))]),
	  MLWorks.Option.NONE, _) =>
d595 1
a595 1
	       (MLWorks.Option.INR
d597 3
a599 3
		 {base=MLWorks.Option.SOME base_reg2,
		  index=MLWorks.Option.NONE,
		  offset=MLWorks.Option.SOME(I386_Assembly.SMALL offset2)})),
d601 1
a601 1
	     MLWorks.Option.NONE, _) =>
d615 1
a615 1
		   MLWorks.Option.SOME(position, 4, copy_count_up, reg1,
d621 1
a621 1
		     MLWorks.Option.SOME(position, ~4, copy_count_down, reg1,
d631 1
a631 1
  fun is_clear(I386_Assembly.r32 reg, I386_Assembly.r_m32(MLWorks.Option.INL reg')) =
d633 1
a633 1
    | is_clear(I386_Assembly.r_m32(MLWorks.Option.INL reg'), I386_Assembly.r32 reg) =
d639 1
a639 1
		     MLWorks.Option.NONE, _) ::
d641 1
a641 1
		     MLWorks.Option.NONE, _) ::
d645 1
a645 1
		     MLWorks.Option.NONE, comment) ::
d647 1
a647 1
			       MLWorks.Option.NONE, _) ::
d659 1
a659 1
					   (MLWorks.Option.INR
d661 2
a662 2
					     {base=MLWorks.Option.SOME reg',
					      index=MLWorks.Option.SOME(reg'', MLWorks.Option.NONE),
d666 2
a667 2
	  MLWorks.Option.SOME(I386_Assembly.SMALL i) => i = 0
	| MLWorks.Option.SOME(I386_Assembly.LARGE(i, j)) => i = 0 andalso j = 0
d697 1
a697 1
				 (MLWorks.Option.INR
d699 3
a701 3
				   {base=MLWorks.Option.SOME reg',
				    index=MLWorks.Option.NONE,
				    offset=MLWorks.Option.SOME offs}))])) =>
d724 1
a724 1
				 (MLWorks.Option.INR
d726 2
a727 2
				   {base=MLWorks.Option.SOME reg',
				    index=MLWorks.Option.SOME(reg'', MLWorks.Option.NONE),
d732 2
a733 2
	      MLWorks.Option.SOME(I386_Assembly.SMALL i) => i = 0
	    | MLWorks.Option.SOME(I386_Assembly.LARGE(i, j)) => i = 0 andalso j = 0
d743 1
a743 1
						     (MLWorks.Option.INL reg'')]),
d751 1
a751 1
						       (MLWorks.Option.INL reg')]),
d765 1
a765 1
		   MLWorks.Option.NONE, _)) ::
d768 1
a768 1
		   MLWorks.Option.NONE, _)) :: rest) =>
d774 1
a774 1
			   MLWorks.Option.NONE, comment)) ::
d776 1
a776 1
			   MLWorks.Option.NONE, _)) ::
d796 1
a796 1
	MLWorks.Option.NONE =>
d798 1
a798 1
	     MLWorks.Option.NONE => deal_with_tags(old_block_map, new_block_map, tags)
d800 1
a800 1
	   | MLWorks.Option.SOME opcode_list =>
d803 1
a803 1
		   (fn (tags, (_, MLWorks.Option.SOME tag, _)) => tag :: tags
d842 1
a842 1
	 MLWorks.Option.SOME(position, inc, copy_count, reg1,
d852 1
a852 1
	       MLWorks.Option.NONE, "save string source"),
d856 1
a856 1
	       MLWorks.Option.NONE, "save string destination"),
d860 1
a860 1
	       MLWorks.Option.NONE, "save global"),
d865 1
a865 1
		 (MLWorks.Option.INR
d867 4
a870 4
		   {base=MLWorks.Option.SOME base_reg1,
		    index=MLWorks.Option.NONE,
		    offset=MLWorks.Option.SOME(I386_Assembly.SMALL offset1)}))]),
	       MLWorks.Option.NONE, "Set string source to base of stuff to copy"),
d875 1
a875 1
		 (MLWorks.Option.INR
d877 4
a880 4
		   {base=MLWorks.Option.SOME base_reg2,
		    index=MLWorks.Option.NONE,
		    offset=MLWorks.Option.SOME(I386_Assembly.SMALL offset2)}))]),
	       MLWorks.Option.NONE, "Set string destination to base of area to copy to"),
d882 1
a882 1
	       MLWorks.Option.NONE, "set direction flag appropriately"),
d887 1
a887 1
	       MLWorks.Option.NONE, "initialise counter for loop"),
d889 1
a889 1
	       MLWorks.Option.SOME new_tag, "jump to start of loop (should be elided)")]
d894 1
a894 1
	      (I386_Assembly.movsd, []), MLWorks.Option.NONE, "One word move") ::
d896 1
a896 1
	      (I386_Assembly.loop, []), MLWorks.Option.SOME new_tag, "loop until ecx = 0") ::
d901 1
a901 1
		(MLWorks.Option.INR
d903 4
a906 4
		  {base=MLWorks.Option.SOME base_reg1,
		   index=MLWorks.Option.NONE,
		   offset=MLWorks.Option.SOME(I386_Assembly.SMALL(offset1 + inc*(copy_count-1)))}))]),
	      MLWorks.Option.NONE, "load intermediate register final value") ::
d909 1
a909 1
	      MLWorks.Option.NONE, "restore global (probably unnecessary)") ::
d912 1
a912 1
	      MLWorks.Option.NONE, "restore string destination") ::
d915 1
a915 1
	      MLWorks.Option.NONE, "restore string source") ::
@


1.11.5.1
log
@branched from 1.11
@
text
@a3 4
 * Revision 1.11  1996/11/06  11:12:34  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.11.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.11.5.1  1997/05/12  10:33:19  hope
 * branched from 1.11
 *
@


1.11.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.11.5.1  1997/05/12  10:33:19  hope
 * branched from 1.11
 *
@


1.11.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.11.5.1  1997/05/12  10:33:19  hope
 * branched from 1.11
 *
@


1.11.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.11.5.1.1.1  1997/07/28  18:18:41  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.11.4.1
log
@branched from 1.11
@
text
@a3 4
 * Revision 1.11  1996/11/06  11:12:34  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.11.3.1
log
@branched from 1.11
@
text
@a3 4
 * Revision 1.11  1996/11/06  11:12:34  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.11.3.1.1.1
log
@branched from 1.11.3.1
@
text
@a3 3
 * Revision 1.11.3.1  1996/12/17  17:46:56  hope
 * branched from 1.11
 *
@


1.11.2.1
log
@branched from 1.11
@
text
@a3 4
 * Revision 1.11  1996/11/06  11:12:34  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.11.1.1
log
@branched from 1.11
@
text
@a3 4
 * Revision 1.11  1996/11/06  11:12:34  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.11.1.1.1.1
log
@branched from 1.11.1.1
@
text
@a3 3
 * Revision 1.11.1.1  1996/11/14  12:48:17  hope
 * branched from 1.11
 *
@


1.10
log
@[Bug #1534]
before is now an infix identifier.
@
text
@d4 4
d41 1
a41 1
require "../basis/__integer";
@


1.10.3.1
log
@branched from 1.10
@
text
@a3 4
 * Revision 1.10  1996/08/09  17:11:55  daveb
 * [Bug #1534]
 * before is now an infix identifier.
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a3 4
 * Revision 1.10  1996/08/09  17:11:55  daveb
 * [Bug #1534]
 * before is now an infix identifier.
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a3 4
 * Revision 1.10  1996/08/09  17:11:55  daveb
 * [Bug #1534]
 * before is now an infix identifier.
 *
@


1.9
log
@Removing use of MLWorks.Integer
@
text
@d4 3
d808 1
a808 1
  fun split_block(before, after, insert, n) =
d813 1
a813 1
	(rev_app(before, insert), after)
d817 1
a817 1
	    split_block(instr :: before, instrs, insert, n-1)
@


1.8
log
@Allow offsets in mem_operands to be bigger than an int, to cope with words
@
text
@d4 3
d34 2
d216 1
a216 1
		    MLWorks.Integer.makestring(Lists.length block_list) ^ "blocks")
d603 1
a603 1
			  MLWorks.Integer.makestring copy_count_up ^ "\n");*)
d609 1
a609 1
			    MLWorks.Integer.makestring copy_count_down ^ "\n");*)
@


1.7
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d4 4
d532 1
a532 1
				    offset=MLWorks.Option.SOME offset1}))]),
d542 1
a542 1
				    offset=MLWorks.Option.SOME offset2})),
d573 1
a573 1
	       offset=MLWorks.Option.SOME offset1}))]),
d583 1
a583 1
		  offset=MLWorks.Option.SOME offset2})),
d650 2
a651 1
	  MLWorks.Option.SOME i => i = 0
d685 20
a704 9
				    offset=MLWorks.Option.SOME i}))])) =>
	  if (i < ~128 orelse i > 127) andalso Set.is_member(reg', set) then
	    ((*output(std_out, "Shortening lea after xor to move\n");*)
	     rewrite_block((I386_Assembly.OPCODE(I386_Assembly.mov,
						 [I386_Assembly.r32 reg,
						  I386_Assembly.imm32(i div 4, i mod 4)]),
			    tag_opt, comment) :: done, Set.setdiff(set, defs), instrs))
	  else
	    rewrite_block(instr :: done, Set.setdiff(set, defs), instrs)
d716 2
a717 1
	      MLWorks.Option.SOME i => i = 0
d853 1
a853 1
		    offset=MLWorks.Option.SOME offset1}))]),
d863 1
a863 1
		    offset=MLWorks.Option.SOME offset2}))]),
d889 1
a889 1
		   offset=MLWorks.Option.SOME(offset1+inc*(copy_count-1))}))]),
@


1.6
log
@Remove the debug output
@
text
@d4 3
a29 1
require "../utils/option";
a36 1
  structure Option : OPTION
a39 2
  sharing type Option.opt = I386_Assembly.opt
  sharing type Option.option = I386_Assembly.option
a42 3
(*
  structure Option = Option
*)
d63 1
a63 1
  | refs_for_opcode_list(done, (_, MirTypes.Option.PRESENT tag, _) :: rest) =
d76 1
a76 1
  val nop = (nop_code, MirTypes.Option.ABSENT, "")
d128 1
a128 1
			MirTypes.Option.PRESENT tag, comment)) ::
d140 1
a140 1
			      MirTypes.Option.PRESENT tag, comment) :: done, rest)
d183 1
a183 1
		   MirTypes.Option.PRESENT tag, comment)) =>
d186 1
a186 1
	 (I386_Assembly.BRANCH(branch, 0), MirTypes.Option.PRESENT dest_tag, comment)
d189 1
a189 1
		  MirTypes.Option.PRESENT tag, comment)) =>
d192 1
a192 1
	   (I386_Assembly.BRANCH_ANNUL(branch, 0), MirTypes.Option.PRESENT dest_tag, comment)
d218 1
a218 1
	       MirTypes.Option.PRESENT dest_tag, _) :: _)) =>
d256 1
a256 1
				  MirTypes.Option.PRESENT tag, _) :: rest) =
d267 1
a267 1
				  MirTypes.Option.PRESENT tag, _) :: rest) =
d309 1
a309 1
		 MirTypes.Option.PRESENT dest_tag,
d323 1
a323 1
	     ((I386_Assembly.BRANCH_ANNUL(branch, _), MirTypes.Option.PRESENT tag,
d336 1
a336 1
				MirTypes.Option.PRESENT new_tag, comment) :: done,
d340 1
a340 1
	   | ((I386_Assembly.FBRANCH_ANNUL(branch, _), MirTypes.Option.PRESENT tag,
d353 1
a353 1
				MirTypes.Option.PRESENT new_tag, comment) :: done,
d371 1
a371 1
	       MirTypes.Option.PRESENT dest_tag, _) :: _)) =>
d524 1
a524 1
				 (Option.SOME2
d526 4
a529 4
				   {base=Option.PRESENT base_reg1,
				    index=Option.ABSENT,
				    offset=Option.PRESENT offset1}))]),
			       Option.ABSENT, _)) ::
d534 1
a534 1
				 (Option.SOME2
d536 3
a538 3
				   {base=Option.PRESENT base_reg2,
				    index=Option.ABSENT,
				    offset=Option.PRESENT offset2})),
d540 1
a540 1
			       Option.ABSENT, _)) ::
d556 3
a558 3
  fun find_copy_sequence_in_block(_, []) = Option.ABSENT
    | find_copy_sequence_in_block(_, [_]) = Option.ABSENT
    | find_copy_sequence_in_block(position, [_, _]) = Option.ABSENT
d565 1
a565 1
	    (Option.SOME2
d567 4
a570 4
	      {base=Option.PRESENT base_reg1,
	       index=Option.ABSENT,
	       offset=Option.PRESENT offset1}))]),
	  Option.ABSENT, _) =>
d575 1
a575 1
	       (Option.SOME2
d577 3
a579 3
		 {base=Option.PRESENT base_reg2,
		  index=Option.ABSENT,
		  offset=Option.PRESENT offset2})),
d581 1
a581 1
	     Option.ABSENT, _) =>
d595 1
a595 1
		   Option.PRESENT(position, 4, copy_count_up, reg1,
d601 1
a601 1
		     Option.PRESENT(position, ~4, copy_count_down, reg1,
d611 1
a611 1
  fun is_clear(I386_Assembly.r32 reg, I386_Assembly.r_m32(Option.SOME1 reg')) =
d613 1
a613 1
    | is_clear(I386_Assembly.r_m32(Option.SOME1 reg'), I386_Assembly.r32 reg) =
d619 1
a619 1
		     Option.ABSENT, _) ::
d621 1
a621 1
		     Option.ABSENT, _) ::
d625 1
a625 1
		     Option.ABSENT, comment) ::
d627 1
a627 1
			       Option.ABSENT, _) ::
d639 1
a639 1
					   (Option.SOME2
d641 2
a642 2
					     {base=Option.PRESENT reg',
					      index=Option.PRESENT(reg'', Option.ABSENT),
d646 1
a646 1
	  Option.PRESENT i => i = 0
d676 1
a676 1
				 (Option.SOME2
d678 3
a680 3
				   {base=Option.PRESENT reg',
				    index=Option.ABSENT,
				    offset=Option.PRESENT i}))])) =>
d692 1
a692 1
				 (Option.SOME2
d694 2
a695 2
				   {base=Option.PRESENT reg',
				    index=Option.PRESENT(reg'', Option.ABSENT),
d700 1
a700 1
	      Option.PRESENT i => i = 0
d710 1
a710 1
						     (Option.SOME1 reg'')]),
d718 1
a718 1
						       (Option.SOME1 reg')]),
d732 1
a732 1
		   Option.ABSENT, _)) ::
d735 1
a735 1
		   Option.ABSENT, _)) :: rest) =>
d741 1
a741 1
			   Option.ABSENT, comment)) ::
d743 1
a743 1
			   Option.ABSENT, _)) ::
d770 1
a770 1
		   (fn (tags, (_, Option.PRESENT tag, _)) => tag :: tags
d809 1
a809 1
	 Option.PRESENT(position, inc, copy_count, reg1,
d819 1
a819 1
	       Option.ABSENT, "save string source"),
d823 1
a823 1
	       Option.ABSENT, "save string destination"),
d827 1
a827 1
	       Option.ABSENT, "save global"),
d832 1
a832 1
		 (Option.SOME2
d834 4
a837 4
		   {base=Option.PRESENT base_reg1,
		    index=Option.ABSENT,
		    offset=Option.PRESENT offset1}))]),
	       Option.ABSENT, "Set string source to base of stuff to copy"),
d842 1
a842 1
		 (Option.SOME2
d844 4
a847 4
		   {base=Option.PRESENT base_reg2,
		    index=Option.ABSENT,
		    offset=Option.PRESENT offset2}))]),
	       Option.ABSENT, "Set string destination to base of area to copy to"),
d849 1
a849 1
	       Option.ABSENT, "set direction flag appropriately"),
d854 1
a854 1
	       Option.ABSENT, "initialise counter for loop"),
d856 1
a856 1
	       Option.PRESENT new_tag, "jump to start of loop (should be elided)")]
d861 1
a861 1
	      (I386_Assembly.movsd, []), Option.ABSENT, "One word move") ::
d863 1
a863 1
	      (I386_Assembly.loop, []), Option.PRESENT new_tag, "loop until ecx = 0") ::
d868 1
a868 1
		(Option.SOME2
d870 4
a873 4
		  {base=Option.PRESENT base_reg1,
		   index=Option.ABSENT,
		   offset=Option.PRESENT(offset1+inc*(copy_count-1))}))]),
	      Option.ABSENT, "load intermediate register final value") ::
d876 1
a876 1
	      Option.ABSENT, "restore global (probably unnecessary)") ::
d879 1
a879 1
	      Option.ABSENT, "restore string destination") ::
d882 1
a882 1
	      Option.ABSENT, "restore string source") ::
@


1.5
log
@Add some more peepholing (zero propagation, large moves)
@
text
@d4 3
d556 1
a556 36
	let
(*
	    val _ =
	      if reg1 <> internal_register then
		output(std_out, "check_for_more_copying fails for wrong reg1\n")
	      else
		()
	    val _ =
	      if reg2 <> internal_register then
		output(std_out, "check_for_more_copying fails for wrong reg2\n")
	      else
		()
	    val _ =
	      if source_reg <> base_reg1 then
		output(std_out, "check_for_more_copying fails for wrong base_reg1\n")
	      else
		()
	    val _ =
	      if dest_reg <> base_reg2 then
		output(std_out, "check_for_more_copying fails for wrong base_reg2\n")
	      else
		()
	    val _ =
	      if offset1 <> source_count + inc then
		output(std_out, "check_for_more_copying fails for wrong offset1\n")
	      else
		()
	    val _ =
	      if offset2 <> dest_count + inc then
		output(std_out, "check_for_more_copying fails for wrong offset2\n")
	      else
		()
*)
	in
	  count_of_copies
	end
d597 2
a598 2
		  (output(std_out, "Found store copy up sequence of length " ^
			  MLWorks.Integer.makestring copy_count_up ^ "\n");
d603 2
a604 2
		    (output(std_out, "Found store copy down sequence of length " ^
			    MLWorks.Integer.makestring copy_count_down ^ "\n");
d670 1
a670 1
		  (output(std_out, "Removing superfluous xor reg, reg\n");
d686 1
a686 1
	    (output(std_out, "Shortening lea after xor to move\n");
d710 1
a710 1
		(output(std_out, "Replacing lea rn, [rn][rm] with add rn, rm\n");
d718 1
a718 1
		  (output(std_out, "Replacing lea rn, [rm][rn] with add rn, rm\n");
d741 1
a741 2
		  ((*output(std_out, "Removing superfluous push/pop pair\n");*)
		   rewrite_block(done, set, rest) (* Omit pop/push of same register *))
d750 1
a750 2
		  ((*output(std_out, "Removing superfluous load after store or vv\n");*)
		   rewrite_block(mov1 :: done, set, rest))
@


1.4
log
@Add some peephole optimisations
In particular, to remove superfluous pop/push pairs
and to remove reloads after stores and restores after loads
@
text
@d4 5
d37 2
a45 1
(*
d48 1
d511 141
a651 1
  (* And store/load pairs of the same register, store location pair *)
d666 21
d689 102
a790 24
  fun rewrite_block(done, []) = rev done
    | rewrite_block(done, ((pop as
			    (I386_Assembly.OPCODE(I386_Assembly.pop, [I386_Assembly.r32 r1]),
			     Option.ABSENT, _)) ::
			   (push as
			    (I386_Assembly.OPCODE(I386_Assembly.push, [I386_Assembly.r32 r2]),
			    Option.ABSENT, _)) ::
			   rest)) =
      if r1 = r2 then
	((*output(std_out, "Removing superfluous push/pop pair\n");*)
	 rewrite_block(done, rest) (* Omit pop/push of same register *))
      else
	rewrite_block(push :: pop :: done, rest)
    | rewrite_block(done, ((mov1 as (I386_Assembly.OPCODE(I386_Assembly.mov, [op1, op2]),
				     Option.ABSENT, comment)) ::
			   (mov2 as (I386_Assembly.OPCODE(I386_Assembly.mov, [op3, op4]),
				     Option.ABSENT, _)) ::
			   rest)) =
      if op1 = op4 andalso op2 = op3 then
	((*output(std_out, "Removing superfluous load after store or vv\n");*)
	 rewrite_block(mov1 :: done, rest))
      else
	rewrite_block(mov1 :: done, mov2 :: rest)
    | rewrite_block(done, opc :: rest) = rewrite_block(opc :: done, rest)
d794 1
a794 1
      rewrite_block([], x)
d818 110
d931 3
@


1.3
log
@Change of option type in newmap
@
text
@d4 3
d502 49
a550 1
  fun reschedule_block x = x
d572 1
@


1.2
log
@Add code to remove unwanted blocks
@
text
@d4 3
d504 1
a504 1
	NewMap.NO =>
d506 1
a506 1
	     NewMap.NO => deal_with_tags(old_block_map, new_block_map, tags)
d508 1
a508 1
	   | NewMap.YES opcode_list =>
@


1.1
log
@new file
@
text
@d3 4
a6 1
$Log$
d14 1
d23 3
d32 1
a33 1
  structure MirTypes = I386_Assembly.MirTypes
a35 1
  structure NewMap = MirTypes.Map
d497 28
a524 1
  fun reschedule_proc x = x
@
