head	1.19;
access;
symbols
	MLW_daveb_inline_1_4_99:1.19.4
	MLWorks_21c0_1999_03_25:1.19
	MLWorks_20c1_1998_08_20:1.19
	MLWorks_20c0_1998_08_04:1.19
	MLWorks_20b2c2_1998_06_19:1.19
	MLWorks_20b2_Windows_1998_06_12:1.19
	MLWorks_20b1c1_1998_05_07:1.19
	MLWorks_20b0_1998_04_07:1.19
	MLWorks_20b0_1998_03_20:1.19
	MLWorks_20m2_1998_02_16:1.19
	MLWorks_20m1_1997_10_23:1.19
	MLWorks_11r1:1.19.1.1.1.1.1
	MLWorks_workspace_97:1.19.3
	MLWorks_dt_wizard:1.19.2
	MLWorks_11c0_1997_09_09:1.19.1.1.1.1
	MLWorks_10r3:1.19.1.1.3
	MLWorks_10r2_551:1.19.1.1.2
	MLWorks_11:1.19.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.19.1.1
	MLWorks_20m0_1997_06_20:1.19
	MLWorks_1_0_r2c2_1997_06_14:1.19.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.19.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.19.1
	MLWorks_BugFix_1997_04_24:1.19
	MLWorks_1_0_r2_Win32_1997_04_11:1.19
	MLWorks_1_0_r2_Unix_1997_04_04:1.19
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.3.1.1
	MLWorks_gui_1996_12_18:1.15.4
	MLWorks_1_0_Win32_1996_12_17:1.15.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.1.1
	MLWorks_1_0_Irix_1996_11_28:1.15.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.2
	MLWorks_1_0_Unix_1996_11_14:1.15.1
	MLWorks_Open_Beta2_1996_10_11:1.14.3
	MLWorks_License_dev:1.14.2
	MLWorks_1_open_beta_1996_09_13:1.14.1
	MLWorks_Open_Beta_1996_08_22:1.14
	MLWorks_Beta_1996_07_02:1.14
	MLWorks_Beta_1996_06_07:1.14
	MLWorks_Beta_1996_06_06:1.14
	MLWorks_Beta_1996_06_05:1.14
	MLWorks_Beta_1996_06_03:1.14
	MLWorks_Beta_1996_05_31:1.14
	MLWorks_Beta_1996_05_30:1.14
	ML_beta_release_12/08/94:1.2
	ML_beta_release_03/08/94:1.2
	ML_revised_beta_release_25/05/94:1.2
	ML_final_beta_release_02/03/94:1.2
	mlworks-28-01-1994:1.2;
locks; strict;
comment	@ * @;


1.19
date	97.01.28.15.05.21;	author matthew;	state Exp;
branches
	1.19.1.1
	1.19.2.1
	1.19.3.1
	1.19.4.1;
next	1.18;

1.18
date	97.01.24.14.46.22;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	97.01.14.11.43.53;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	96.12.05.12.02.43;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	96.10.10.02.39.55;	author io;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1;
next	1.14;

1.14
date	95.12.22.13.22.05;	author jont;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1;
next	1.13;

1.13
date	95.09.08.13.46.55;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	95.06.19.13.20.38;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.06.16.13.59.12;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.06.01.10.15.41;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	95.03.07.16.15.57;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	94.11.24.17.16.46;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	94.11.24.14.31.03;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	94.11.23.15.53.51;	author io;	state Exp;
branches;
next	1.5;

1.5
date	94.11.15.12.03.06;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	94.11.02.15.26.05;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	94.10.21.14.35.45;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.11.16.17.05.20;	author io;	state Exp;
branches;
next	1.1;

1.1
date	93.10.28.14.31.19;	author simon;	state Exp;
branches;
next	;

1.14.1.1
date	96.09.13.11.19.40;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.10.07.16.09.33;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.10.17.11.27.52;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.11.14.12.53.26;	author hope;	state Exp;
branches
	1.15.1.1.1.1;
next	;

1.15.1.1.1.1
date	96.11.28.15.04.21;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.11.22.18.12.24;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.12.17.17.50.53;	author hope;	state Exp;
branches
	1.15.3.1.1.1;
next	;

1.15.3.1.1.1
date	97.02.24.11.41.19;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.12.18.09.45.04;	author hope;	state Exp;
branches;
next	;

1.19.1.1
date	97.05.12.10.37.34;	author hope;	state Exp;
branches
	1.19.1.1.1.1
	1.19.1.1.2.1
	1.19.1.1.3.1;
next	;

1.19.1.1.1.1
date	97.07.28.18.22.46;	author daveb;	state Exp;
branches
	1.19.1.1.1.1.1.1;
next	;

1.19.1.1.1.1.1.1
date	97.10.07.11.48.28;	author jkbrook;	state Exp;
branches;
next	;

1.19.1.1.2.1
date	97.09.08.17.16.09;	author daveb;	state Exp;
branches;
next	;

1.19.1.1.3.1
date	97.09.09.14.12.06;	author daveb;	state Exp;
branches;
next	;

1.19.2.1
date	97.09.10.19.28.09;	author brucem;	state Exp;
branches;
next	;

1.19.3.1
date	97.09.11.20.58.07;	author daveb;	state Exp;
branches;
next	;

1.19.4.1
date	99.04.01.17.58.42;	author daveb;	state Exp;
branches;
next	;


desc
@Default RCS description
Copyright Harlequin Ltd., 1991
@


1.19
log
@Changing CGT code
@
text
@(*
 Copyright (c) 1993 Harlequin Ltd.

 based on ???

 Revision Log
 ------------
 $Log: _mips_schedule.sml,v $
 * Revision 1.18  1997/01/24  14:46:22  matthew
 * Adding option to control whether load delays are needed.
 *
 * Revision 1.17  1997/01/14  11:43:53  matthew
 * Check for multiplication hazards
 *
 * Revision 1.16  1996/12/05  12:02:43  jont
 * [Bug #1834]
 * Avoid problems scheduling past control transfers
 *
 * Revision 1.15  1996/10/10  02:39:55  io
 * [Bug #1557]
 * switch off instruction reordering and basify
 *
 * Revision 1.14  1995/12/22  13:22:05  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
Revision 1.13  1995/09/08  13:46:55  jont
Add a fixed branch type which can't be expanded beyond the 16 bit limit
This can be used to detect disastrous code generation in computed gotos
If this ever occurs, we can then fix the bug

Revision 1.12  1995/06/19  13:20:38  matthew
Fixing problem with handler register

Revision 1.11  1995/06/16  13:59:12  jont
Temporary fix for scheduling problems with handlers and trapping instructions

Revision 1.10  1995/06/01  10:15:41  matthew
Fix problem with moving instructions over intercept nops

Revision 1.9  1995/03/07  16:15:57  matthew
Debug annotations for CALLs

Revision 1.8  1994/11/24  17:16:46  matthew
Fix to not move other_nop

Revision 1.7  1994/11/24  14:31:03  matthew
Tidied up fill_candidate a little as I didn't understand it.

Revision 1.6  1994/11/23  15:53:51  io
Fixing problem with scheduling floats

Revision 1.5  1994/11/15  12:03:06  matthew
Lots more work

Revision 1.4  1994/11/02  15:26:05  matthew
Added "move from above to fill delay slots" stuff

Revision 1.3  1994/10/21  14:35:45  matthew
Added a function to remove unused blocks
Added a function to remove unnecessary load delay nops

Revision 1.2  1993/11/16  17:05:20  io
Deleted old SPARC comments and fixed type errors

 *)

require "../utils/crash";
require "../utils/lists";
require "mips_assembly";

require "mips_schedule";

functor Mips_Schedule(
  structure Crash : CRASH
  structure Lists : LISTS
  structure Mips_Assembly : MIPS_ASSEMBLY
  ) : MIPS_SCHEDULE =
struct
  structure Mips_Assembly = Mips_Assembly
  structure MirTypes = Mips_Assembly.MirTypes
  structure Set = MirTypes.Set
  structure MachTypes = Mips_Assembly.Mips_Opcodes.MachTypes
  structure NewMap = MirTypes.Map

  val do_scheduling = true

  val max_fill_iterations = 20
  val small_block_size = 2

  (* Various utility functions *)

  (* Most of these functions work on (opcode * tag option * comment) triples *)

  local
    open Mips_Assembly
  in
    fun is_nop (opcode,_,_) = opcode = Mips_Assembly.nop_code
    fun is_other_nop (opcode,_,_) = 
      opcode = Mips_Assembly.other_nop_code orelse
      opcode = Mips_Assembly.trace_nop_code

    val nop = (Mips_Assembly.nop_code, NONE, "")

    (* all kinds of transfers of control *)
    fun is_branch (BRANCH _,_,_) = true
      | is_branch (FIXED_BRANCH _,_,_) = true
      | is_branch (CALL _,_,_) = true
      | is_branch (JUMP _,_,_) = true
      | is_branch (FBRANCH _,_,_) = true
      | is_branch (_,_,_) = false

    fun is_fp_op (LOAD_AND_STORE_FLOAT _,_,_) = true
      | is_fp_op (FBRANCH _,_,_) = true
      | is_fp_op (FUNARY _,_,_) = true
      | is_fp_op (FBINARY _,_,_) = true
      | is_fp_op (FCMP _,_,_) = true
      | is_fp_op (CONV_OP _,_,_) = true
      | is_fp_op _ = false

    fun is_fp_delay_op (LOAD_AND_STORE_FLOAT _,_,_) = true
      | is_fp_delay_op (FCMP _,_,_) = true
      | is_fp_delay_op _ = false

    fun is_unconditional_branch (BRANCH (BA,_,_,_),_,_) = true
      | is_unconditional_branch (FIXED_BRANCH (BA,_,_,_),_,_) = true
      | is_unconditional_branch (CALL (BGEZAL,reg,_,_),_,_) = reg = MachTypes.zero_reg
      | is_unconditional_branch _ = false

    (* Simple test for possible instruction to fill a delay slot *)
    (* No fp operations for now *)
    (* No branches *)
    (* No funny operations like LOAD_OFFSET -- these can expand later *)

    fun fill_candidate op1 =
      if is_other_nop op1 then false
      else
        case op1 of
          (LOAD_AND_STORE _,_,_) => true
        | (ARITHMETIC_AND_LOGICAL _,_,_) => true
(*
          (LOAD_AND_STORE(opcode, dest, _, _), _, _) =>
	    (* Don't allow handler realods to be moved *)
	    (case opcode of
	       LW => dest <> Mips_Opcodes.MachTypes.handler
	     | _ => true)
        | (ARITHMETIC_AND_LOGICAL(opcode, dest, _, _),_,_) =>
	    (* Don't allow exception causing instructions to be moved *)
	    (case opcode of
	       ADD => false
	     | ADDI => false
	     | ADDIU => true
	     | ADDU => true
	     | SUB => false
	     | SUBU => true
	     | AND => true
	     | ANDI => true
	     | OR => dest <> Mips_Opcodes.MachTypes.handler
		 (* Don't allow handler setup instructions to be moved *)
	     | ORI => true
	     | XOR => true
	     | XORI => true
	     | NOR => true
	     | SLT => true
	     | SLTU => true
	     | SLTI => true
	     | SLTIU => true
	     | SLL => true
	     | SRL => true
	     | SRA => true
	     | SLLV => true
	     | SRLV => true
	     | SRAV => true)
*)
        | (SETHI _,_,_) => true
        | _ => false

    fun is_load mnemonic =
      case mnemonic of
        LB => true
      | LBU => true
      | LH => true
      | LHU => true
      | LW => true
      | LWL => true
      | LWR => true
      | _ => false

    (* Is is a load from memory? *)
    fun is_load_opcode (LOAD_AND_STORE (mnemonic,to,from,imm),_,_) = is_load mnemonic
      | is_load_opcode _ = false

    (* Get the register loaded *)

    fun loaded_reg (LOAD_AND_STORE (_,to,_,_),_,_) = to
      | loaded_reg _ = Crash.impossible "loaded_reg"

    (* (Partial) test for whether an instruction references a given register *)
    (* This should catch the common cases at least *)

    fun is_referenced (reg,(opn,_,_)) =
      case opn of
        LOAD_AND_STORE (mnemonic,to,from,_) => 
          if is_load mnemonic then reg = from
           (* Otherwise it's a store and we need to look at both registers *)
          else reg = from orelse reg = to
      | ARITHMETIC_AND_LOGICAL (_,_,reg1,REG reg2) => reg = reg1 orelse reg = reg2
      | ARITHMETIC_AND_LOGICAL (_,_,reg1,IMM _) => reg = reg1
      | SPECIAL_ARITHMETIC (_,reg1,REG reg2,reg3) => reg = reg1 orelse reg = reg2 orelse reg = reg3
      | SPECIAL_ARITHMETIC (_,reg1,IMM _,reg3) => reg = reg1 orelse reg = reg3
      | MULT_AND_DIV (_,reg1,reg2) => reg = reg1 orelse reg = reg2
      | MULT_AND_DIV_RESULT (_,reg1) => reg = reg1
      | SETHI _ => false
      | BRANCH (_,reg1,reg2,_) => reg = reg1 orelse reg = reg2
      | FIXED_BRANCH (_,reg1,reg2,_) => reg = reg1 orelse reg = reg2
      | CALL (_,reg1,_,_) => reg = reg1
      | JUMP (jump,reg_or_imm,reg2,_) =>
          (case reg_or_imm of
             REG reg1 =>
               (case jump of
                  JR => reg = reg1
                | JALR => reg = reg2
                | _ => Crash.impossible "is_referenced JUMP reg")
           | _ => false)
      (* Lets do the others sometime *)
      |  _ => true  (* Assume the worst *)
  end

  fun needs_delay (op1,next) =
    if is_branch op1 
      then true
    else if is_load_opcode op1
      then
        case next of
          SOME op2 => is_referenced (loaded_reg op1,op2)
        | _ => true
    (* For the moment, assume the worst for fp *)
     else if is_fp_delay_op op1 then true
     else false

  fun definitions (op1,_,_) =
    Mips_Assembly.defines_and_uses op1

  fun add_uses (op1,(int_defines,int_uses,fp_defines,fp_uses)) =
    let
      val (int_defines',int_uses',fp_defines',fp_uses') =
        definitions op1
    in
      (Set.union (int_defines,int_defines'),
       Set.union (int_uses,int_uses'),
       Set.union (fp_defines,fp_defines'),
       Set.union (fp_uses,fp_uses'))
    end

  fun disjoint (s1, s2) =
    let
      val l1 = Set.set_to_list s1
    in
      not(Lists.exists (fn x => Set.is_member(x, s2)) l1)
    end

  fun is_safe (op1,(int_defines,int_uses,fp_defines,fp_uses)) =
    let
      val (int_defines',int_uses',fp_defines',fp_uses') = definitions op1
    in
      disjoint (int_defines,int_defines') andalso
      disjoint (int_defines,int_uses') andalso
      disjoint (int_uses,int_defines') andalso
      disjoint (fp_defines,fp_defines') andalso
      disjoint (fp_defines,fp_uses') andalso
      disjoint (fp_uses,fp_defines')
    end

  (* target is the op whose delay slot needs filling *)
  (* rest is the preceding code *)
  (* next is (optionally) the next instruction *)

  fun find_filler (target,[],next) = NONE
    | find_filler (target,previous as (op1 :: _),next) =
    if is_branch op1 then
      (* Target is in the delay slot of a branch, so we can't move anything *)
      (* from before the branch into the delay slot of target *)
      NONE
    else
      let
	fun find (_,uses,0,acc) = NONE
	  | find (op1::op2::op3::rest,uses,count,acc) =
	  (* op2 is the candidate *)
	  (* if it's in a delay slot, give up *)
	  if is_branch op3 then
	    (* If its an intercept NOP, give up *)
	    NONE
	  else
	    if is_other_nop op3 then
	      NONE
	    else
	      if not (is_nop op2) andalso fill_candidate op2 andalso
		is_safe (op2,uses) andalso not (needs_delay (op2,next)) then
		SOME
		(if needs_delay (op3,SOME op1) then
		   (op2,rev acc @@ (Mips_Assembly.nop::op3::rest))
		 else
		   (op2,rev acc @@ (op3::rest)))
	      else
		find (op2::op3::rest,add_uses (op2,uses),count-1,op2::acc)
	  | find ([op1,op2],uses,count,acc) =
	    if is_branch op2 then
	      NONE
	    else
	      if fill_candidate op2 andalso
		is_safe (op2,uses) andalso
		not (needs_delay (op2,next)) then
		SOME (op2,rev acc)
	      else
		NONE
	  | find _ = NONE
      in
	find (target::previous,definitions target,max_fill_iterations,[])
      end

  (* and now some whizzier stuff *)
  fun do_block (need_load_delays, opcode_list,next) = 
    let

      fun delay_optional (op1,next) =
        if is_branch op1 
          then false
        else if need_load_delays then not (needs_delay (op1,next))
        else true

      fun fill_slots (op1::op2::rest,next,acc) =
        (if not (is_nop op1)
           then fill_slots (op2::rest,SOME op1,op1::acc)
         else
           (* We have found a nop *)
           if not (needs_delay (op2,next))
             (* Drop the nop if not required *)
             then fill_slots (op2::rest,next,acc)
           else
             (* The interesting case *)
             case find_filler (op2,rest,if is_branch op2 then NONE else next) of
               NONE => 
                 if delay_optional (op2,next)
                   then fill_slots (op2::rest,next,acc)
                 else fill_slots (op2::rest,SOME op1,op1::acc)
             | SOME (op1',rest') => 
                   fill_slots (op2::rest',SOME op1',op1'::acc))
        | fill_slots ([op1],next,acc) =
           if is_nop op1 then acc else op1 :: acc
        | fill_slots ([],next,acc) = acc
      
      val opcodes1 = rev opcode_list
      val result = fill_slots (opcodes1,next,[])
    in
      result
    end

  (* We want to change the linearized code so that blocks not jumped to *)
  (* are coalesced with the previous block that falls through to it *)

  fun collect_tags_from_block (tag_set, (tag,opcode_list)) =
    Lists.reducel
    (fn (tag_set,(opcode,SOME tag,_)) =>
     NewMap.define (tag_set,tag,())
  | (tag_set,_) => tag_set)
    (tag_set,opcode_list)

  fun collect_tags_from_proc (tag,blocklist) =
    let
      (* make sure the entry tag is marked as used *)
      val initial_tag_set = NewMap.define (NewMap.empty,tag,())
    in
      Lists.reducel collect_tags_from_block (initial_tag_set,blocklist)
    end
      
  fun coalesce_blocks (tag,blocklist) =
    let
      val used_map = collect_tags_from_proc (tag,blocklist)
      val used_fn = NewMap.tryApply used_map
      fun scan (block1::block2::rest,acc) =
        let
          val (tag1,opcodes1) = block1
        in
          case used_fn tag1 of
            SOME _ => scan (block2::rest,block1::acc)
          | _ => 
              (* If the block is unmentioned *)
              let
                val (tag2,opcodes2) = block2
                (* val _ = output (std_out,"Dropping " ^ MirTypes.print_tag tag1 ^ "\n") *)
              in
                scan ((tag2,opcodes2@@opcodes1)::rest,acc)
              end
        end
        | scan (rest,acc) =(rev rest) @@ acc
    in
      (scan (rev blocklist,[]))
    end

  (* Move first instruction from jumped to block for unconditional branches *)

  fun fill_unconditional_branches blocklist =
    let
      val block_map = NewMap.from_list blocklist
      val block_fn = NewMap.tryApply block_map
      val new_tag_map = ref NewMap.empty
      fun get_new_tag tag =
        case NewMap.tryApply'(!new_tag_map,tag) of
          SOME new_tag => new_tag
        | _ => 
            let
              val new_tag = MirTypes.new_tag ()
              val _ = new_tag_map := NewMap.define (!new_tag_map,tag,new_tag)
            in
              new_tag
            end
      fun first_instruction tag =
        case block_fn tag of
          SOME (first::_) =>
            if fill_candidate first then 
              SOME first
            else NONE
        | _ => NONE
      fun branch_target (_,SOME tag,_) = tag
        | branch_target (_,_,_) = Crash.impossible "branch target"
      fun set_target ((opc,_,comment),tag) = (opc,SOME tag,comment)
      fun scan (op1::op2::rest,acc) =
        if is_unconditional_branch op1 andalso is_nop op2
          then
            let
              val target = branch_target op1
            in
              case first_instruction target of
                SOME first =>
                  let
                    val new_tag = get_new_tag target
                  in
                    scan (rest,first :: set_target (op1,new_tag) :: acc)
                  end
              | _ => scan (rest,op2 :: op1 :: acc)
            end
        else scan (op2::rest,op1::acc)
        | scan (rest,acc) = rev rest @@ acc
      fun add_new_blocks blocklist =
        let
          val tag_fn = NewMap.tryApply (!new_tag_map)
          fun scan ([],acc) = rev acc
            | scan ((tag,opcodes)::rest,acc) =
              case tag_fn tag of
                SOME new_tag =>
                  (case opcodes of
                     (first::rest_opcodes) => 
                       scan (rest,(new_tag,rest_opcodes) :: (tag,[first]) :: acc)
                   | _ => Crash.impossible "Funny body in add_new_blocks")
              | _ => scan (rest,(tag,opcodes)::acc)
        in
          scan (blocklist,[])
        end
      val new_blocklist = 
        map
        (fn (tag,opcodelist) => (tag, rev (scan (opcodelist,[]))))
        blocklist
    in
      add_new_blocks new_blocklist
    end

  fun falls_through (tag,opcodes) =
    let
      fun scan (op1 :: op2 :: op3 :: rest) =
        scan (op2 :: op3 :: rest)
        | scan [(Mips_Assembly.BRANCH (Mips_Assembly.BA,_,_,_),_,_), op2] = false
        | scan [(Mips_Assembly.FIXED_BRANCH (Mips_Assembly.BA,_,_,_),_,_), op2] = false
        | scan [(Mips_Assembly.JUMP (Mips_Assembly.J,_,_,_),_,_), op2] = false
        | scan [(Mips_Assembly.JUMP (Mips_Assembly.JR,_,_,_),_,_), op2] = false
        | scan _ = true
    in
      scan opcodes
    end

  (* Eliminate branch to branches *)
  fun inline_small_blocks (tag,blocklist) =
    let
      (* Find all the small blocks *)
      val small_map =
        Lists.reducel
        (fn (map,(tag,opcodes)) =>
         if length opcodes <= small_block_size andalso
           not (falls_through (tag,opcodes))
           then
             NewMap.define (map,tag,opcodes)
         else map)
        (NewMap.empty,blocklist)
      val small_fn = NewMap.tryApply small_map
      (* Replace branch destinations *)
      (* We could do this just for the branches that need it *)
      fun scan (rest,acc,0) = rev rest @@ acc
        | scan (op1::op2::op3::rest,acc,depth) =
        scan (op2::op3::rest,op1::acc,depth)
        (* Branch at end of block *)
        | scan ([op1 as (Mips_Assembly.BRANCH(Mips_Assembly.BA,_,_,_),SOME tag,_),
                 op2],
                acc,depth) =
          (case small_fn tag of
             SOME opcodes =>
               if is_nop op2
                 then scan (opcodes,acc,depth-1)
               else scan (op2::opcodes,acc,depth-1)
           | _ => op2 :: op1 :: acc)
        | scan ([op1 as (Mips_Assembly.FIXED_BRANCH(Mips_Assembly.BA,_,_,_),SOME tag,_),
                 op2],
                acc,depth) =
          (case small_fn tag of
             SOME opcodes =>
               if is_nop op2
                 then scan (opcodes,acc,depth-1)
               else scan (op2::opcodes,acc,depth-1)
           | _ => op2 :: op1 :: acc)
        | scan (rest,acc,depth) = rev rest @@ acc
    in
      map (fn (tag,opcodes) => (tag, rev (scan (opcodes,[],20)))) blocklist
    end
                
  (* Once again, remove unreachable blocks *)
  fun remove_redundant (tag,blocklist) =
    let
      val used_map = collect_tags_from_proc (tag,blocklist)
      val used_fn = NewMap.tryApply used_map
      fun scan (block1::block2::rest,acc) =
        let
          val (tag,_) = block2
        in
          case used_fn tag of
            SOME _ => scan (block2::rest,block1::acc)
          | NONE =>
              if falls_through block1
                then scan (block2::rest,block1::acc)
              else scan (block1::rest,acc)
        end
      | scan (rest,acc) = rev rest @@ acc
    in
      rev (scan (blocklist,[]))
    end

  fun check_multiply (tag, opcodes) =
    let
      val nop = (Mips_Assembly.nop_code, NONE, "for multiply delay")
      fun scan (n,[],acc) = rev acc
        | scan (0, (opcode as (Mips_Assembly.MULT_AND_DIV _,_,_)) :: rest, acc) =
        scan (3, rest, opcode :: nop :: nop :: acc)
        | scan (1, (opcode as (Mips_Assembly.MULT_AND_DIV _,_,_)) :: rest, acc) =
        scan (3, rest, opcode :: nop :: acc)
        | scan (n, (opcode as (Mips_Assembly.MULT_AND_DIV_RESULT _,_,_)) :: rest, acc) =
        scan (0, rest, opcode :: acc)
        | scan (n, opcode :: rest, acc) =
        scan (n+1, rest, opcode :: acc)
    in
      (tag, scan (0,opcodes,[]))
    end
    
  fun reschedule_proc mips2 (tag, blocklist) =
    if not do_scheduling
      then (tag,map check_multiply blocklist)
    else
      let
        val blocklist = inline_small_blocks (tag,blocklist)
        val blocklist = coalesce_blocks (tag,blocklist)
        (* The blocks are in the correct order *)
        fun scan ((tag,opcode_list)::rest,acc) =
          let
            (* Find the first instruction of the next block *)
            val next = case rest of
              ((_,(next::_))::_) => SOME next
            | _ => NONE
          in
            scan (rest,(tag,do_block (not mips2,opcode_list,next))::acc)
          end
          | scan ([],acc) = rev acc
        val blocklist = scan (blocklist,[])
(*
        val blocklist =
          map
          (fn (tag,opcode_list) => (tag,do_block opcode_list))
          blocklist
*)
        val blocklist = fill_unconditional_branches blocklist
        val blocklist = remove_redundant (tag,blocklist)
      in
        (tag, map check_multiply blocklist)
      end

end
@


1.19.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 3
 * Revision 1.19  1997/01/28  15:05:21  matthew
 * Changing CGT code
 *
@


1.19.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a8 3
 * Revision 1.19  1997/01/28  15:05:21  matthew
 * Changing CGT code
 *
@


1.19.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a8 3
 * Revision 1.19  1997/01/28  15:05:21  matthew
 * Changing CGT code
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a8 3
 * Revision 1.19  1997/01/28  15:05:21  matthew
 * Changing CGT code
 *
@


1.19.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 * Revision 1.19.1.1  1997/05/12  10:37:34  hope
 * branched from 1.19
 *
@


1.19.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 * Revision 1.19.1.1  1997/05/12  10:37:34  hope
 * branched from 1.19
 *
@


1.19.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 * Revision 1.19.1.1  1997/05/12  10:37:34  hope
 * branched from 1.19
 *
@


1.19.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 * Revision 1.19.1.1.1.1  1997/07/28  18:22:46  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.18
log
@Adding option to control whether load delays are needed.
@
text
@d9 3
d99 3
a101 1
    fun is_other_nop (opcode,_,_) = opcode = Mips_Assembly.other_nop_code
@


1.17
log
@Check for multiplication hazards
@
text
@d9 3
d317 29
a345 17
  fun fill_slots (op1::op2::rest,next,acc) =
    (if not (is_nop op1)
       then fill_slots (op2::rest,SOME op1,op1::acc)
     else
       (* We have found a nop *)
       if not (needs_delay (op2,next))
         (* Drop the nop if not required *)
         then fill_slots (op2::rest,next,acc)
       else
         (* The interesting case *)
         case find_filler (op2,rest,if is_branch op2 then NONE else next) of
           NONE => fill_slots (op2::rest,SOME op1,op1::acc)
         | SOME (op1',rest') => 
             fill_slots (op2::rest',SOME op1',op1'::acc))
    | fill_slots ([op1],next,acc) =
      if is_nop op1 then acc else op1 :: acc
    | fill_slots ([],next,acc) = acc
a346 2
  fun do_block (opcode_list,next) = 
    let
a461 2
  fun reschedule_block opcode_list = opcode_list

d555 1
a555 1
  fun reschedule_proc (tag, blocklist) =
d570 1
a570 1
            scan (rest,(tag,do_block (opcode_list,next))::acc)
@


1.16
log
@[Bug #1834]
Avoid problems scheduling past control transfers
@
text
@d9 4
d94 3
a96 1
    
d527 17
a543 1
                
d546 1
a546 1
      then (tag,blocklist)
d572 1
a572 1
        (tag, blocklist)
@


1.15
log
@[Bug #1557]
switch off instruction reordering and basify
@
text
@d9 4
d264 42
a305 29
  fun find_filler (target,previous,next) =
    let
      fun find (_,uses,0,acc) = NONE
        | find (op1::op2::op3::rest,uses,count,acc) =
        (* op2 is the candidate *)
        (* if it's in a delay slot, give up *)
        if is_branch op3 then NONE
	(* If its an intercept NOP, give up *)
	else if is_other_nop op3 then NONE
        else
          if not (is_nop op2) andalso fill_candidate op2 andalso
            is_safe (op2,uses) andalso not (needs_delay (op2,next))
            then
              if needs_delay (op3,SOME op1)
                then SOME (op2,rev acc @@ (Mips_Assembly.nop::op3::rest))
              else SOME (op2,rev acc @@ (op3::rest))
          else find (op2::op3::rest,add_uses (op2,uses),count-1,op2::acc)
        | find ([op1,op2],uses,count,acc) =
          if is_branch op2 then NONE
          else
            if fill_candidate op2 andalso
              is_safe (op2,uses) andalso
              not (needs_delay (op2,next))
              then SOME (op2,rev acc)
            else NONE
        | find _ = NONE
    in
      find (target::previous,definitions target,max_fill_iterations,[])
    end
@


1.15.4.1
log
@branched from 1.15
@
text
@a8 4
 * Revision 1.15  1996/10/10  02:39:55  io
 * [Bug #1557]
 * switch off instruction reordering and basify
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a8 4
 * Revision 1.15  1996/10/10  02:39:55  io
 * [Bug #1557]
 * switch off instruction reordering and basify
 *
@


1.15.3.1.1.1
log
@branched from 1.15.3.1
@
text
@a8 3
 * Revision 1.15.3.1  1996/12/17  17:50:53  hope
 * branched from 1.15
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a8 4
 * Revision 1.15  1996/10/10  02:39:55  io
 * [Bug #1557]
 * switch off instruction reordering and basify
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a8 4
 * Revision 1.15  1996/10/10  02:39:55  io
 * [Bug #1557]
 * switch off instruction reordering and basify
 *
@


1.15.1.1.1.1
log
@branched from 1.15.1.1
@
text
@a8 3
 * Revision 1.15.1.1  1996/11/14  12:53:26  hope
 * branched from 1.15
 *
@


1.14
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d9 4
a71 2
  open MLWorks.Option

d322 1
a322 1
    (fn (tag_set,(opcode,MLWorks.Option.SOME tag,_)) =>
d383 1
a383 1
      fun branch_target (_,MLWorks.Option.SOME tag,_) = tag
d385 1
a385 1
      fun set_target ((opc,_,comment),tag) = (opc,MLWorks.Option.SOME tag,comment)
d448 1
a448 1
         if Lists.length opcodes <= small_block_size andalso
d461 1
a461 1
        | scan ([op1 as (Mips_Assembly.BRANCH(Mips_Assembly.BA,_,_,_),MLWorks.Option.SOME tag,_),
d470 1
a470 1
        | scan ([op1 as (Mips_Assembly.FIXED_BRANCH(Mips_Assembly.BA,_,_,_),MLWorks.Option.SOME tag,_),
@


1.14.3.1
log
@branched from 1.14
@
text
@a8 4
 * Revision 1.14  1995/12/22  13:22:05  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.14.2.1
log
@branched from 1.14
@
text
@a8 4
 * Revision 1.14  1995/12/22  13:22:05  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.14.1.1
log
@branched from 1.14
@
text
@a8 4
 * Revision 1.14  1995/12/22  13:22:05  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.13
log
@Add a fixed branch type which can't be expanded beyond the 16 bit limit
This can be used to detect disastrous code generation in computed gotos
If this ever occurs, we can then fix the bug
@
text
@d9 5
a61 1
  structure Option = Mips_Assembly.MirTypes.Option
d320 1
a320 1
    (fn (tag_set,(opcode,Option.PRESENT tag,_)) =>
d381 1
a381 1
      fun branch_target (_,Option.PRESENT tag,_) = tag
d383 1
a383 1
      fun set_target ((opc,_,comment),tag) = (opc,Option.PRESENT tag,comment)
d459 1
a459 1
        | scan ([op1 as (Mips_Assembly.BRANCH(Mips_Assembly.BA,_,_,_),Option.PRESENT tag,_),
d468 1
a468 1
        | scan ([op1 as (Mips_Assembly.FIXED_BRANCH(Mips_Assembly.BA,_,_,_),Option.PRESENT tag,_),
@


1.12
log
@Fixing problem with handler register
@
text
@d9 3
d83 1
d102 1
d191 1
d427 1
d455 10
a464 1
        | scan ([op1 as (Mips_Assembly.BRANCH (Mips_Assembly.BA,_,_,_),Option.PRESENT tag,_),
@


1.11
log
@Temporary fix for scheduling problems with handlers and trapping instructions
@
text
@d9 3
d110 3
d145 1
d297 1
a297 1
  fun do_block opcode_list = 
d300 1
a300 1
      val result = fill_slots (opcodes1,NONE,[])
d448 3
a450 1
        | scan ([op1 as (Mips_Assembly.BRANCH (Mips_Assembly.BA,_,_,_),Option.PRESENT tag,_),op2],acc,depth) =
d490 13
d507 1
@


1.10
log
@Fix problem with moving instructions over intercept nops
@
text
@d9 3
d107 32
a138 2
          (LOAD_AND_STORE _,_,_) => true
        | (ARITHMETIC_AND_LOGICAL _,_,_) => true
@


1.9
log
@Debug annotations for CALLs
@
text
@d9 3
d212 1
a212 1
        (* i2 is the candidate *)
d215 2
@


1.8
log
@Fix to not move other_nop
@
text
@d9 3
d89 1
a89 1
      | is_unconditional_branch (CALL (BGEZAL,reg,_),_,_) = reg = MachTypes.zero_reg
d143 1
a143 1
      | CALL (_,reg1,_) => reg = reg1
@


1.7
log
@Tidied up fill_candidate a little as I didn't understand it.
@
text
@d9 3
d95 7
a101 5
      case op1 of
        (LOAD_AND_STORE _,_,_) => true
      | (ARITHMETIC_AND_LOGICAL _,_,_) => true
      | (SETHI _,_,_) => true
      | _ => false
@


1.6
log
@Fixing problem with scheduling floats
@
text
@d9 3
a47 1
  (* FP scheduling doesn't work yet *)
d86 6
a91 1
    fun fill_candidate_for_branch op1 =
d94 1
a94 1
      | (LOAD_AND_STORE_FLOAT _,_,_) => true
a97 8
    (* op2 is the one with the delay slot *)
    (* op1 is the possible filler *)

    fun fill_candidate (op1,op2) = 
      if is_other_nop op1 then false
      else if (is_branch op2) then fill_candidate_for_branch op1
      else not (is_fp_op op1)

d205 1
a205 1
          if not (is_nop op2) andalso fill_candidate (op2,target) andalso
d215 1
a215 1
            if fill_candidate (op2,target) andalso
d314 1
a314 1
            if fill_candidate_for_branch first then 
@


1.5
log
@Lots more work
@
text
@d9 3
d68 8
d97 1
a97 1
      else true
@


1.4
log
@Added "move from above to fill delay slots" stuff
@
text
@d9 3
a20 1
require "../utils/_hashset";
a22 1
require "../utils/option";
d24 1
a29 1
  structure Option : OPTION
d33 1
a33 1
  structure Option = Option
a38 8
  structure HashSet = HashSet(
    structure Crash = Crash
    structure Lists = Lists
    type element = MirTypes.tag
    val eq = MirTypes.equal_tag
    val size = 1000
    val hash = MirTypes.int_of_tag
      )
d43 1
a43 1
  val do_scheduling = false
d46 1
d55 2
a56 6
    fun is_nop (opcode,_,_) =
      let
        val (nopcode,_,_) = Mips_Assembly.nop
      in
        opcode = nopcode
      end
d65 22
a86 9
    fun fill_candidate (ARITHMETIC_AND_LOGICAL _,_,_) = true
      | fill_candidate (SETHI _,_,_) = true
      | fill_candidate _ = false

(*
    fun fill_candidate (MULT_AND_DIV _,_,_) = false
      | fill_candidate (MULT_AND_DIV_RESULT _,_,_) = false
      | fill_candidate _ = true
*)
d126 8
d146 2
d183 1
a183 1
  (* op1 is the op whose delay slot needs filling *)
d187 1
a187 1
  fun find_filler (op1,previous,next) =
d190 1
a190 1
        | find (i1::i2::i3::rest,uses,count,acc) =
d193 1
a193 1
        if is_branch i3 then NONE
d195 2
a196 2
          if not (is_nop i2) andalso fill_candidate i2 andalso
            is_safe (i2,uses) andalso not (needs_delay (i2,next))
d198 6
a203 6
              if needs_delay (i3,SOME i1)
                then SOME (i2,rev acc @@ (Mips_Assembly.nop::i3::rest))
              else SOME (i2,rev acc @@ (i3::rest))
          else find (i2::i3::rest,add_uses (i2,uses),count-1,i2::acc)
        | find ([i1,i2],uses,count,acc) =
          if is_branch i2 then NONE
d205 4
a208 4
            if fill_candidate i2 andalso
              is_safe (i2,uses) andalso
              not (needs_delay (i2,next))
              then SOME (i2,rev acc)
d212 1
a212 1
      find (op1::previous,definitions op1,max_fill_iterations,[])
d230 3
a232 1
    | fill_slots (l,next,acc) =l @@ acc
d242 109
d353 65
d423 2
d429 2
@


1.3
log
@Added a function to remove unused blocks
Added a function to remove unnecessary load delay nops
@
text
@d9 4
d47 1
a47 31
  (* Return a list of the tags referenced by the opcode list *)
  (* Maybe this should use a more efficient table *)

  fun tags_from opcode_list =
    Lists.reducel
    (fn (acc,(opcode,MirTypes.Option.PRESENT t,_)) =>
     if Lists.member (t,acc) then acc else t :: acc
      | (acc,_) => acc)
    ([],opcode_list)

  (* Do a depth first search, finding referenced blocks *)
  fun dfs (block_fn,start) =
    let
      val seen = ref [] : MirTypes.tag list ref
      val result = ref NewMap.empty : unit NewMap.T ref
      fun scan tag =
        if Lists.member (tag,!seen)
          then ()
        else
          let
            val opcode_list = case block_fn tag of MLWorks.Option.SOME l => l | _ => []
          in
            seen := tag :: (!seen);
            Lists.iterate scan (tags_from opcode_list);
            result := NewMap.define (!result,tag,())
          end
    in
      scan start;
      (* And return in postorder *)
      !result
    end
d49 2
a50 2
  fun make_block_fn blocklist =
    NewMap.tryApply (NewMap.from_list blocklist)
d52 1
a52 16
  (* Remove the unreachable blocks from the blocklist *)
  fun eliminate_unreachable (tag,blocklist) =
    let
      val block_fn = make_block_fn blocklist
      val reachable = dfs (block_fn, tag)
    in
      Lists.filterp
      (fn (tag,block) =>
       case NewMap.tryApply' (reachable,tag) of
         MLWorks.Option.SOME _ => true
       | _ => false)
      blocklist
    end
    
  fun reschedule_proc (tag, blocklist) =
    (tag, eliminate_unreachable (tag,blocklist))
d75 10
a120 3
      (* Need to be careful here in case the branch is removed *)
      (* If scheduling is done at the right point, we needn't have this case *)
      | BRANCH (BA,reg1,reg2,_) => true
d127 99
a225 1
  (* And finally, removed unnecessary load delay nops from a list of opcodes *)
d227 1
a227 16
  fun remove_load_nops (op1::op2::op3::rest,acc) = 
    if is_branch op1
      then remove_load_nops (op3::rest,op2::op1::acc)
    else if is_nop op2 andalso is_load_opcode op1 andalso not (is_referenced (loaded_reg op1,op3))
      then remove_load_nops (op1::op3::rest,acc)
    else remove_load_nops (op2::op3::rest,op1::acc)
    (* Either the last instruction is a branch or we don't know what the fall through case is *)
    (* Either way, there is nothing useful to be done *)
    | remove_load_nops ([op1,op2],acc) = (op2::op1::acc)
(*
      if is_branch op1 then (op2::op1::acc)
      else if is_nop op2 andalso is_load_opcode op1
        then (op1::acc)
      else (op2::op1::acc)
*)
    | remove_load_nops (l,acc) = (rev l @@ acc)
d229 12
a240 3
  (* and that is all we do for the moment *)
  fun reschedule_block opcode_list = 
    rev (remove_load_nops (opcode_list,[]))
@


1.2
log
@Deleted old SPARC comments and fixed type errors
@
text
@d8 4
a11 1
 $Log$
d43 140
a182 2
  fun reschedule_proc(a)=a
  fun reschedule_block(a)=a
@


1.1
log
@Initial revision
@
text
@a0 1
(* _mips_schedule.sml the functor *)
d2 1
a2 4
$Log: _mips_schedule.sml,v $
Revision 1.1  1993/08/09  14:04  simon
Initial revision for mips.
*)
d4 6
a9 2
;;; Copyright 1991 Harlequin Ltd.
;;; $Log$
@
