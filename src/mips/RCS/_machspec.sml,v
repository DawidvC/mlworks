head	1.36;
access;
symbols
	MLW_daveb_inline_1_4_99:1.36.1
	MLWorks_21c0_1999_03_25:1.36
	MLWorks_20c1_1998_08_20:1.35
	MLWorks_20c0_1998_08_04:1.35
	MLWorks_20b2c2_1998_06_19:1.35
	MLWorks_20b2_Windows_1998_06_12:1.35
	MLWorks_20b1c1_1998_05_07:1.35
	MLWorks_20b0_1998_04_07:1.35
	MLWorks_20b0_1998_03_20:1.35
	MLWorks_20m2_1998_02_16:1.35
	MLWorks_20m1_1997_10_23:1.35
	MLWorks_11r1:1.31.1.1.1.1.1
	MLWorks_workspace_97:1.35.2
	MLWorks_dt_wizard:1.35.1
	MLWorks_11c0_1997_09_09:1.31.1.1.1.1
	MLWorks_10r3:1.31.1.1.3
	MLWorks_10r2_551:1.31.1.1.2
	MLWorks_11:1.31.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.31.1.1
	MLWorks_20m0_1997_06_20:1.35
	MLWorks_1_0_r2c2_1997_06_14:1.31.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.31.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.31.1
	MLWorks_BugFix_1997_04_24:1.31
	MLWorks_1_0_r2_Win32_1997_04_11:1.31
	MLWorks_1_0_r2_Unix_1997_04_04:1.31
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.28.3.1.1
	MLWorks_gui_1996_12_18:1.28.4
	MLWorks_1_0_Win32_1996_12_17:1.28.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.28.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.28.1.1
	MLWorks_1_0_Irix_1996_11_28:1.28.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.28.2
	MLWorks_1_0_Unix_1996_11_14:1.28.1
	MLWorks_Open_Beta2_1996_10_11:1.27.3
	MLWorks_License_dev:1.27.2
	MLWorks_1_open_beta_1996_09_13:1.27.1
	MLWorks_Open_Beta_1996_08_22:1.27
	MLWorks_Beta_1996_07_02:1.27
	MLWorks_Beta_1996_06_07:1.27
	MLWorks_Beta_1996_06_06:1.27
	MLWorks_Beta_1996_06_05:1.27
	MLWorks_Beta_1996_06_03:1.27
	MLWorks_Beta_1996_05_31:1.27
	MLWorks_Beta_1996_05_30:1.27
	ML_beta_release_12/08/94:1.13
	ML_beta_release_03/08/94:1.13
	ML_revised_beta_release_25/05/94:1.8
	ML_final_beta_release_02/03/94:1.5
	mlworks-28-01-1994:1.2;
locks; strict;
comment	@ * @;


1.36
date	98.08.27.12.14.19;	author jont;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	97.05.14.14.18.54;	author matthew;	state Exp;
branches
	1.35.1.1
	1.35.2.1;
next	1.34;

1.34
date	97.05.13.15.05.12;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	97.05.01.13.15.52;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	97.04.24.15.45.26;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	97.03.25.11.52.57;	author matthew;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	97.01.21.16.06.42;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	96.12.16.17.09.46;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	96.11.01.13.41.04;	author jont;	state Exp;
branches
	1.28.1.1
	1.28.2.1
	1.28.3.1
	1.28.4.1;
next	1.27;

1.27
date	96.03.20.12.33.53;	author matthew;	state Exp;
branches
	1.27.1.1
	1.27.2.1
	1.27.3.1;
next	1.26;

1.26
date	95.12.22.13.15.02;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	95.08.14.12.05.56;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	95.07.25.15.44.48;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	95.06.19.15.49.49;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	95.05.30.12.58.30;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	94.12.09.12.10.27;	author nickb;	state Exp;
branches;
next	1.20;

1.20
date	94.11.15.13.53.34;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	94.11.10.10.15.59;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	94.10.25.14.16.28;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	94.10.24.14.28.52;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	94.09.21.16.11.22;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	94.09.15.17.54.37;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	94.08.25.12.13.21;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	94.07.25.14.01.50;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	94.07.19.15.37.05;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	94.07.12.13.49.51;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	94.07.12.11.30.54;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	94.06.14.13.05.01;	author io;	state Exp;
branches;
next	1.8;

1.8
date	94.05.10.14.46.23;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	94.03.08.17.23.38;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.03.04.12.57.47;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.02.25.12.07.33;	author io;	state Exp;
branches;
next	1.4;

1.4
date	94.02.24.21.28.59;	author io;	state Exp;
branches;
next	1.3;

1.3
date	94.02.23.17.45.09;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	93.11.16.16.50.30;	author io;	state Exp;
branches;
next	1.1;

1.1
date	93.10.28.14.31.10;	author simon;	state Exp;
branches;
next	;

1.27.1.1
date	96.09.13.11.19.34;	author hope;	state Exp;
branches;
next	;

1.27.2.1
date	96.10.07.16.09.28;	author hope;	state Exp;
branches;
next	;

1.27.3.1
date	96.10.17.11.27.46;	author hope;	state Exp;
branches;
next	;

1.28.1.1
date	96.11.14.12.53.20;	author hope;	state Exp;
branches
	1.28.1.1.1.1;
next	;

1.28.1.1.1.1
date	96.11.28.15.04.16;	author hope;	state Exp;
branches;
next	;

1.28.2.1
date	96.11.22.18.12.19;	author hope;	state Exp;
branches;
next	;

1.28.3.1
date	96.12.17.17.50.48;	author hope;	state Exp;
branches
	1.28.3.1.1.1;
next	;

1.28.3.1.1.1
date	97.02.24.11.41.13;	author hope;	state Exp;
branches;
next	;

1.28.4.1
date	96.12.18.09.44.59;	author hope;	state Exp;
branches;
next	;

1.31.1.1
date	97.05.12.10.37.29;	author hope;	state Exp;
branches
	1.31.1.1.1.1
	1.31.1.1.2.1
	1.31.1.1.3.1;
next	;

1.31.1.1.1.1
date	97.07.28.18.22.42;	author daveb;	state Exp;
branches
	1.31.1.1.1.1.1.1;
next	;

1.31.1.1.1.1.1.1
date	97.10.07.11.48.22;	author jkbrook;	state Exp;
branches;
next	;

1.31.1.1.2.1
date	97.09.08.17.16.05;	author daveb;	state Exp;
branches;
next	;

1.31.1.1.3.1
date	97.09.09.14.12.01;	author daveb;	state Exp;
branches;
next	;

1.35.1.1
date	97.09.10.19.28.04;	author brucem;	state Exp;
branches;
next	;

1.35.2.1
date	97.09.11.20.58.02;	author daveb;	state Exp;
branches;
next	;

1.36.1.1
date	99.04.01.17.58.37;	author daveb;	state Exp;
branches;
next	;


desc
@Default RCS description
Copyright Harlequin Ltd., 1991
@


1.36
log
@[Bug #70040]
Modify register colourer to use stack colourer only if requested from machspec
@
text
@(*
 Copyright (c) 1993 Harlequin Ltd.

 based on Revision 1.43

 Revision Log
 ------------
 $Log: _machspec.sml,v $
 * Revision 1.35  1997/05/14  14:18:54  matthew
 * [Bug #30028]
 * Removing caller_closure from reserved_but_preferenceable
 *
 * Revision 1.34  1997/05/13  15:05:12  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
 * Revision 1.33  1997/05/01  13:15:52  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.32  1997/04/24  15:45:26  jont
 * [Bug #20007]
 * Adding reserved_but_preferencable registers
 *
 * Revision 1.31  1997/03/25  11:52:57  matthew
 * Adding mach_type value
 *
 * Revision 1.30  1997/01/21  16:06:42  jont
 * [Bug #0]
 * Add in corrupted_by_alloc and leaf_regs
 *
 * Revision 1.29  1996/12/16  17:09:46  matthew
 * Addin fp_arg_regs
 *
 * Revision 1.28  1996/11/01  13:41:04  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
 * Revision 1.27  1996/03/20  12:33:53  matthew
 * Changes for value polymorphism
 *
 * Revision 1.26  1995/12/22  13:15:02  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
Revision 1.25  1995/08/14  12:05:56  jont
Add bits_per_word
Remove smallest_int, largest_int, largest_word

Revision 1.24  1995/07/25  15:44:48  jont
Add largest_word

Revision 1.23  1995/06/19  15:49:49  jont
Extend number of floating point tempoaries to 3 as required by the register allocator

Revision 1.22  1995/05/30  12:58:30  matthew
Adding debugging_reserved register list

Revision 1.21  1994/12/09  12:10:27  nickb
Change floating-point callee-saves.

Revision 1.20  1994/11/15  13:53:34  jont
Add has_immediate_store flag

Revision 1.19  1994/11/10  10:15:59  matthew
Fixing FP temporaries.

Revision 1.18  1994/10/25  14:16:28  matthew
Reserve caller_closure to prevent it getting overwritten in leaf tail calls

Revision 1.17  1994/10/24  14:28:52  matthew
Various things:
Changed for multiple argument passing`
Added caller_arg and lr to corrupted_by_callee
Removed callee_arg from reserved list
Use R16 and lr as the only 2 spill temporaries
Changed the ranking of registers so caller_saves are allocated first

Revision 1.16  1994/09/21  16:11:22  jont
Add do_unspill value to control register allocator

Revision 1.15  1994/09/15  17:54:37  jont
Add chr and ord
Also add Chr and Ord

Revision 1.14  1994/08/25  12:13:21  matthew
Replaced *_arg2 with *_arg_regs

Revision 1.13  1994/07/25  14:01:50  matthew
Added dummy definition of arg2.  This won't work but should fail badly enough to notice.

Revision 1.12  1994/07/19  15:37:05  jont
Modify register preference order on callee saves

Revision 1.11  1994/07/12  13:49:51  jont
Change register ranking to preference for callee saves

Revision 1.10  1994/07/12  11:30:54  jont
Ensure tables of reserved, corrupted_by_callee and temporary are ok

Revision 1.9  1994/06/14  13:05:01  io
simplifying callee_arg and caller_arg

Revision 1.8  1994/05/10  14:46:23  jont
Remove lr, gc1, gc2, stack_limit from register interface

Revision 1.7  1994/03/08  17:23:38  jont
Move digits_in_real here

Revision 1.6  1994/03/04  12:57:47  jont
Changes for automatic_callee mechanism removal
and moving machspec from machine to main

Revision 1.5  1994/02/25  12:07:33  io
again

Revision 1.4  1994/02/24  21:28:59  io
Changed register conventions to nickh's conventions doc

Revision 1.3  1994/02/23  17:45:09  jont
Changes to register preferences for allocation

Revision 1.2  1993/11/16  16:50:30  io
Deleted old SPARC comments and fixed type errors

 *)

require "../utils/set";
require "../utils/crash";
require "../main/machspec";
require "machtypes";


functor MachSpec (

  structure MachTypes	: MACHTYPES
  structure Set		: SET
  structure Crash       : CRASH

) : MACHSPEC =

struct

  structure Set = Set


  (* === What sort of machine is it? === *)

  datatype MachType = SPARC | MIPS | I386

  val mach_type : MachType = MIPS

  (*  === MACHINE REGISTERS ===  *)


  type register = MachTypes.Mips_Reg



  local
    open MachTypes
  in

    (*  == Special registers ==  *)

    val caller_arg =		MachTypes.arg
    val callee_arg =		MachTypes.arg
    (* MLA Now have 8 argument registers *)
    val caller_arg_regs =	[MachTypes.arg,R17,R18,R19,R20,R21,R22,R23]
    val callee_arg_regs =       caller_arg_regs
    val caller_closure =	MachTypes.caller_closure
    val callee_closure =	MachTypes.callee_closure
    val tail_arg =		caller_arg
    val tail_closure = 		caller_closure
    val fp_arg_regs =           [F8,F10,F12,F14,F16,F18,F20,F22]
    val fp =			MachTypes.fp
    val sp =			MachTypes.sp
    val handler =		MachTypes.handler
    val global =		MachTypes.global
    val implicit =		MachTypes.implicit
    val fp_global =		MachTypes.fp_global

    val zero = SOME R0


    (*  == General registers ==
     *
     *  gcs:		int/ptr visible to garbage collector
     *  non_gcs:	int/ptr not visible to garbage collector
     *  fps:		floating point registers
     *)

    (* MLA Don't include arg regs here *)
    val gcs = 
      [R10, R11, R12, R13, R14, R15, R16, R17, R18, R19, R20, R21, R22, R23, R24, R25,lr]

    val non_gcs = []

    (* All the fps except for F4 which is fp_global *)
    (* F0 and F2 are spill temporaries and are reserved *)

    val fps = case MachTypes.fp_used of
      MachTypes.single =>
        Crash.impossible "machspec not configured for single-float case"
    | MachTypes.double =>
        [F0, F2, F6, F8, F10, F12, F14, F16, F18, F20, F22, F24, F26, F28, F30]
    | MachTypes.extended =>
        Crash.impossible "machspec not configured for extended-float case"

    val empty_register_set : Mips_Reg Set.Set = Set.empty_set

    (* MLA added caller_arg register and lr *)

    val corrupted_by_callee =
      {gc = Set.list_to_set [caller_arg,caller_closure, global,lr,
			     R16, R17, R18, R19, R20, R21, R22, R23],
       non_gc = empty_register_set,
       fp = Set.list_to_set[F0, F2, F4, F6, F8, F10, F12, F14, 
                            F16, F18, F20, F22, F24, F26, F28, F30] }

    val corrupted_by_alloc =
      {gc = Set.list_to_set [lr],
       non_gc = empty_register_set,
       fp = empty_register_set }

    val defined_on_entry =
      {gc = Set.list_to_set [caller_closure],
       non_gc = empty_register_set,
       fp = empty_register_set }

    val referenced_by_alloc =
      {gc = Set.list_to_set [callee_closure, caller_closure],
       (* This is to prevent callee_closure and caller_closure from being updated *)
       (* before an alloc which would then break the gc *)
       non_gc = empty_register_set,
       fp = empty_register_set }

    (*  == Reserved registers ==
     *
     *  These can never be used for anything except their special purpose,
     *  they can't even be temporarily spilled.  This list includes the
     *  temporary registers.
     *)

    (* Need to add caller_closure to prevent it getting overwritten in leaf tail calls *)

    val reserved =
      {gc = Set.list_to_set [R0, R1, gc1, gc2, handler, global, implicit,
			     stack_limit, sp, lr, fp, callee_closure,caller_closure,
			     R26, R27, R16],
       non_gc = empty_register_set,
       fp = Set.list_to_set [fp_global,F0, F2, F6]}

    val debugging_reserved = reserved

    val reserved_but_preferencable =
      {gc = [callee_closure, global, lr],
       non_gc = [],
       fp = [fp_global]}

    (* For debugging code, reserve callee_arg *)
    val debugging_reserved_but_preferencable =
      {gc = [],
       non_gc = [],
       fp = []}

    (*  == Temporary registers ==
     *
     *  These are the registers reserved for use as temporaries for the
     *  register allocator.  Currently, two are required for each used
     *  register type.  It's best to use the caller save registers first for
     *  temporaries as these tend to be corrupted by subroutine calls in any
     *  case. Or is it? In that case, we get almost no chance at leaf functions.
     *  Using callee_save registers is probably better here.
     *)
      
    (* Let's try using the link register as a spill temporary *)
    val temporary =
      {gc = [R16,lr],
       non_gc = [],
       fp = [F0, F2, F6]}


    (*  == Allocation order ==
     *
     *  On the SPARC the I registers should be allocated randomly, since
     *  they cost nothing to save.  After that, the O registers should be
     *  used in preference to the L registers because this will tend to
     *  leave the L's free for variables which _need_ to be preserved across
     *  calls.
     *)
    (* on the mips, things are simpler *)
    (*
     * No they aren't. We should rank the caller saves first, to maximise
     * the possibility of leaf procedures.
     *)

    local
      local
	open MachTypes
      in
	fun rank R10 = 1
	  | rank R11 = 2
	  | rank R12 = 3
	  | rank R13 = 4
	  | rank R14 = 5
	  | rank R15 = 6
	  | rank R16 = 0
	  | rank R17 = 0
	  | rank R18 = 0
	  | rank R19 = 0
	  | rank R20 = 0
	  | rank R21 = 0
	  | rank R22 = 0
	  | rank R23 = 0
	  | rank R24 = 7
	  | rank R25 = 8
	  | rank _ = 9
      end

      fun order (reg, reg') =
        let
          val r = rank reg
          val r' = rank reg'
        in
          r < r' 
        end
 
     fun equal (reg, reg') =
        let
          val r = rank reg
          val r' = rank reg'
        in
          r = r' 
        end

      fun fp_order(reg, reg') =
	let
	  val b1 = Set.is_member(reg, #fp corrupted_by_callee)
	  val b2 = Set.is_member(reg', #fp corrupted_by_callee)
	in
          b1 andalso not b2
	end

     fun fp_equal(reg, reg') =
	let
	  val b1 = Set.is_member(reg, #fp corrupted_by_callee)
	  val b2 = Set.is_member(reg', #fp corrupted_by_callee)
	in
          b1 = b2
	end

    in
      val allocation_order =
        {gc = order,
         non_gc = order,
         fp = fp_order}
      val allocation_equal =
        {gc = equal,
         non_gc = equal,
         fp = fp_equal}
    end

  end

  (*  == Spill handling == *)

  val do_unspilling = true

  (*  == Register printing ==  *)

  val print_register = MachTypes.reg_to_string

  (* Immediate stores for CISCs *)

  val has_immediate_stores = false

  (*  === MACHINE LIMITS ===  *)

  val digits_in_real = MachTypes.digits_in_real
  val bits_per_word = MachTypes.bits_per_word
  val leaf_regs = 9

  (* === REGISTER ALLOCATION STRATEGY === *)

  val use_stack_colourer = true

  (*  === MACHINE FUNCTIONS === *)

  exception Ord = MachTypes.Ord
  exception Chr = MachTypes.Chr

  val ord = MachTypes.ord
  val chr = MachTypes.chr

end
@


1.36.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 4
 * Revision 1.36  1998/08/27  12:14:19  jont
 * [Bug #70040]
 * Modify register colourer to use stack colourer only if requested from machspec
 *
@


1.35
log
@[Bug #30028]
Removing caller_closure from reserved_but_preferenceable
@
text
@d9 4
d383 4
@


1.35.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a8 4
 * Revision 1.35  1997/05/14  14:18:54  matthew
 * [Bug #30028]
 * Removing caller_closure from reserved_but_preferenceable
 *
@


1.35.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a8 4
 * Revision 1.35  1997/05/14  14:18:54  matthew
 * [Bug #30028]
 * Removing caller_closure from reserved_but_preferenceable
 *
@


1.34
log
@[Bug #20038]
Add referenced_by_alloc
@
text
@d9 4
d253 1
a253 1
      {gc = [callee_closure, caller_closure, global, lr],
@


1.33
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d9 4
a14 1
 * [Bug #20007]
d214 12
a225 2
      {gc = Set.list_to_set [lr, callee_closure, caller_closure],
       (* This is to prevent callee_closure and caller_clousre from being updated *)
@


1.32
log
@[Bug #20007]
[Bug #20007]
Adding reserved_but_preferencable registers
@
text
@d9 5
d172 1
a172 1
    val zero = MLWorks.Option.SOME R0
@


1.31
log
@Adding mach_type value
@
text
@d9 3
d206 3
a208 1
      {gc = Set.list_to_set [lr],
d229 11
@


1.31.1.1
log
@branched from 1.31
@
text
@a8 3
 * Revision 1.31  1997/03/25  11:52:57  matthew
 * Adding mach_type value
 *
@


1.31.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 * Revision 1.31.1.1  1997/05/12  10:37:29  hope
 * branched from 1.31
 *
@


1.31.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 * Revision 1.31.1.1  1997/05/12  10:37:29  hope
 * branched from 1.31
 *
@


1.31.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 * Revision 1.31.1.1  1997/05/12  10:37:29  hope
 * branched from 1.31
 *
@


1.31.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 * Revision 1.31.1.1.1.1  1997/07/28  18:22:42  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.30
log
@[Bug #0]
Add in corrupted_by_alloc and leaf_regs
@
text
@d9 4
d128 6
d199 2
a200 1
       fp = Set.list_to_set[F0, F2, F4, F6, F8, F10, F12, F14, F16, F18] }
@


1.29
log
@Addin fp_arg_regs
@
text
@d9 3
d191 5
d329 1
@


1.28
log
@[Bug #1683]
Make all fp registers caller save
@
text
@d9 4
a102 1
require "../utils/lists";
a110 1
  structure Lists	: LISTS
d143 1
d163 1
a163 2
      Lists.difference ([R10, R11, R12, R13, R14, R15, R16, R17, R18, R19, R20, R21, R22, R23, R24, R25,lr],
                        callee_arg_regs @@ caller_arg_regs)
d186 1
a186 1
       fp = Set.list_to_set[F0, F2, F4, F6, F8, F10, F12, F14, F16, F18, F20, F22, F24, F26, F28, F30] }
@


1.28.4.1
log
@branched from 1.28
@
text
@a8 4
 * Revision 1.28  1996/11/01  13:41:04  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
@


1.28.3.1
log
@branched from 1.28
@
text
@a8 4
 * Revision 1.28  1996/11/01  13:41:04  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
@


1.28.3.1.1.1
log
@branched from 1.28.3.1
@
text
@a8 3
 * Revision 1.28.3.1  1996/12/17  17:50:48  hope
 * branched from 1.28
 *
@


1.28.2.1
log
@branched from 1.28
@
text
@a8 4
 * Revision 1.28  1996/11/01  13:41:04  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
@


1.28.1.1
log
@branched from 1.28
@
text
@a8 4
 * Revision 1.28  1996/11/01  13:41:04  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
@


1.28.1.1.1.1
log
@branched from 1.28.1.1
@
text
@a8 3
 * Revision 1.28.1.1  1996/11/14  12:53:20  hope
 * branched from 1.28
 *
@


1.27
log
@Changes for value polymorphism
@
text
@d9 3
d184 1
a184 1
       fp = Set.list_to_set[F0, F2, F4, F6, F8, F10, F12, F14, F16, F18] }
@


1.27.3.1
log
@branched from 1.27
@
text
@a8 3
 * Revision 1.27  1996/03/20  12:33:53  matthew
 * Changes for value polymorphism
 *
@


1.27.2.1
log
@branched from 1.27
@
text
@a8 3
 * Revision 1.27  1996/03/20  12:33:53  matthew
 * Changes for value polymorphism
 *
@


1.27.1.1
log
@branched from 1.27
@
text
@a8 3
 * Revision 1.27  1996/03/20  12:33:53  matthew
 * Changes for value polymorphism
 *
@


1.26
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d9 4
d173 2
d180 1
a180 1
       non_gc = Set.empty_set,
d196 1
a196 1
       non_gc = Set.empty_set,
@


1.25
log
@Add bits_per_word
Remove smallest_int, largest_int, largest_word
@
text
@d9 4
a93 1
require "../utils/option";
a103 1
  structure Option	: OPTION
a109 1
  structure Option = Option
d141 1
a141 1
    val zero = Option.PRESENT R0
@


1.24
log
@Add largest_word
@
text
@d9 3
a306 3
  val largest_int = MachTypes.largest_int
  val smallest_int = MachTypes.smallest_int
  val largest_word = MachTypes.largest_word
d308 1
@


1.23
log
@Extend number of floating point tempoaries to 3 as required by the register allocator
@
text
@d9 3
d306 1
@


1.22
log
@Adding debugging_reserved register list
@
text
@d9 3
d184 1
a184 1
       fp = Set.list_to_set [fp_global,F0, F2]}
d202 1
a202 1
       fp = [F0, F2]}
@


1.21
log
@Change floating-point callee-saves.
@
text
@d9 3
d163 1
a163 1
			     R16, R17, R18, R19, R20, R21, R22, R23], (* jont: check this (done) *)
d183 2
a216 24

(*
      local
	open MachTypes
      in
	fun rank R10 = 0
	  | rank R11 = 1
	  | rank R12 = 2
	  | rank R13 = 3
	  | rank R14 = 4
	  | rank R15 = 5
	  | rank R16 = 8
	  | rank R17 = 8
	  | rank R18 = 8
	  | rank R19 = 8
	  | rank R20 = 8
	  | rank R21 = 8
	  | rank R22 = 8
	  | rank R23 = 8
	  | rank R24 = 6
	  | rank R25 = 7
	  | rank _ = 9
      end
*)
@


1.20
log
@Add has_immediate_store flag
@
text
@d9 3
d146 1
a146 1
    (* F24 and F26 are spill temporaries and are reserved *)
d152 1
a152 1
        [F24,F26,F28,F30, F16,F18,F20,F22, F8,F10,F12,F14, F0,F2,F6]
a156 1
    (* I wonder if this should contain FP global and spill temporaries also *)
d162 1
a162 2
       fp = Set.list_to_set[F8,F10,F12,F14, F16,F18,F20,F22, F24,F28,F30] }

d178 1
a178 1
       fp = Set.list_to_set [fp_global,F24,F26]}
d194 1
a194 1
       fp = [F24,F26]}
@


1.19
log
@Fixing FP temporaries.
@
text
@d9 3
d309 4
@


1.18
log
@Reserve caller_closure to prevent it getting overwritten in leaf tail calls
@
text
@d9 3
d139 3
d151 2
d172 1
a172 1
			     fp_global, R26, R27, R16],
d174 1
a174 1
       fp = Set.list_to_set [F24,F26]}
@


1.17
log
@Various things:
Changed for multiple argument passing`
Added caller_arg and lr to corrupted_by_callee
Removed callee_arg from reserved list
Use R16 and lr as the only 2 spill temporaries
Changed the ranking of registers so caller_saves are allocated first
@
text
@d9 8
d159 2
d163 1
a163 1
			     stack_limit, sp, lr, fp, callee_closure,
@


1.16
log
@Add do_unspill value to control register allocator
@
text
@d9 3
d59 1
d69 1
d93 21
a119 2
    
    val gcs = [R10, R11, R12, R13, R14, R15, R16, R17, R18, R19, R20, R21, R22, R23, R24, R25]
d121 5
d136 1
d138 1
a138 1
      {gc = Set.list_to_set [caller_closure, global,
a143 20
    (*  == Special registers ==  *)

    val caller_arg =		MachTypes.arg
    val callee_arg =		MachTypes.arg
    val caller_arg_regs =	[MachTypes.arg]
    val callee_arg_regs =	[MachTypes.arg]
    val caller_closure =	MachTypes.caller_closure
    val callee_closure =	MachTypes.callee_closure
    val tail_arg =		caller_arg
    val tail_closure = 		caller_closure
    val fp =			MachTypes.fp
    val sp =			MachTypes.sp
    val handler =		MachTypes.handler
    val global =		MachTypes.global
    val implicit =		MachTypes.implicit
    val fp_global =		MachTypes.fp_global

    val zero = Option.PRESENT R0


d153 2
a154 2
			     stack_limit, sp, lr, fp, callee_arg, callee_closure,
			     fp_global, R26, R27, R16, R17, R18],
d156 1
a156 1
       fp = Set.list_to_set [F24,F26,F28]}
d167 2
a168 1

d170 1
a170 1
      {gc = [R16, R17, R18],
d172 1
a172 1
       fp = [F24,F26,F28]}
d186 1
a186 1
     * the possibility of leaf procedures (TBD)
d191 1
d211 22
@


1.15
log
@Add chr and ord
Also add Chr and Ord
@
text
@d9 4
d247 1
a247 1

d249 1
d255 1
a255 3


    (*  === MACHINE LIMITS ===  *)
@


1.14
log
@Replaced *_arg2 with *_arg_regs
@
text
@d9 3
d257 9
@


1.13
log
@Added dummy definition of arg2.  This won't work but should fail badly enough to notice.
@
text
@d9 3
d111 2
a112 3
    (* This won't work yet, but need to define these values *)
    val caller_arg2 =		MachTypes.arg
    val callee_arg2 =		MachTypes.arg
a115 1
    val tail_arg2 =		caller_arg2
@


1.12
log
@Modify register preference order on callee saves
@
text
@d9 3
d108 3
d114 1
@


1.11
log
@Change register ranking to preference for callee saves
@
text
@d9 3
d169 16
a184 16
	  | rank R11 = 0
	  | rank R12 = 0
	  | rank R13 = 0
	  | rank R14 = 0
	  | rank R15 = 0
	  | rank R16 = 1
	  | rank R17 = 1
	  | rank R18 = 1
	  | rank R19 = 1
	  | rank R20 = 1
	  | rank R21 = 1
	  | rank R22 = 1
	  | rank R23 = 1
	  | rank R24 = 0
	  | rank R25 = 0
	  | rank _ = 3
@


1.10
log
@Ensure tables of reserved, corrupted_by_callee and temporary are ok
@
text
@d9 3
d165 16
a180 16
	fun rank R10 = 1
	  | rank R11 = 1
	  | rank R12 = 1
	  | rank R13 = 1
	  | rank R14 = 1
	  | rank R15 = 1
	  | rank R16 = 0
	  | rank R17 = 0
	  | rank R18 = 0
	  | rank R19 = 0
	  | rank R20 = 0
	  | rank R21 = 0
	  | rank R22 = 0
	  | rank R23 = 0
	  | rank R24 = 1
	  | rank R25 = 1
@


1.9
log
@simplifying callee_arg and caller_arg
@
text
@d9 3
d76 1
a76 1
    val gcs = [R7, R11, R12, R13, R14, R15, R16, R17, R18, R19, R20, R21, R22, R23]
d89 2
a90 1
      {gc = Set.list_to_set [global, implicit, R6, R7], (* jont: check this *)
d123 1
a123 1
			     fp_global, R26, R27, R11, R12, R13],
d125 1
a125 1
       fp = Set.list_to_set []}
d131 1
a131 1
     *  register type.  It's best to use the O registers first for
d133 2
a134 1
     *  case.
d138 1
a138 1
      {gc = [R11, R12, R13],
d151 5
a155 1
     (* on the mips, things are simpler *)
d158 22
a179 1
      fun rank _ = 0
d218 1
a218 1
     val allocation_equal =
@


1.8
log
@Remove lr, gc1, gc2, stack_limit from register interface
@
text
@d9 3
d93 2
a94 2
    val caller_arg =		MachTypes.caller_arg
    val callee_arg =		MachTypes.callee_arg
@


1.7
log
@Move digits_in_real here
@
text
@d9 3
a97 1
    val lr =			MachTypes.lr
a98 2
    val gc1 =			MachTypes.gc1
    val gc2 =			MachTypes.gc2
a101 2
    val implicit =		MachTypes.implicit
    val stack_limit =           MachTypes.stack_limit 
@


1.6
log
@Changes for automatic_callee mechanism removal
and moving machspec from machine to main
@
text
@d9 4
d208 1
a208 1

@


1.5
log
@again
@
text
@d9 3
d26 1
a26 1
require "machspec";
d87 2
@


1.4
log
@Changed register conventions to nickh's conventions doc
@
text
@d9 3
d73 1
a73 1
      {gc = Set.list_to_set [global, implicit, R6, R7] (* jont: check this *)
@


1.3
log
@Changes to register preferences for allocation
@
text
@d9 3
d57 1
a57 3
    val gcs = [R16, R17, R18, R19, R20, R21, R22, R23,
	       R10, R11, R12, R13, R14, R15,
	       R24, R25]
d70 1
a70 1
      {gc = Set.list_to_set [R16, R17, R18, R19, R20, R21, R22, R23],
@


1.2
log
@Deleted old SPARC comments and fixed type errors
@
text
@d8 4
a11 1
 $Log$
d54 3
a56 1
    val gcs = [R6, R7, R11, R12, R13, R14, R15, R16, R17, R18, R19, R20, R21, R22, R23]
d69 1
a69 1
      {gc = Set.list_to_set [global, implicit, R6, R7], (* check this *)
@


1.1
log
@Initial revision
@
text
@d1 2
a2 152
(*   ==== MACHINE SPECIFICATION ====
 *              FUNCTOR
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 *  $Log: _machspec.sml,v $
 *  Revision 1.43  1992/11/21  19:33:38  jont
 *  Removed is_inline to machperv in order to remove dependence of entire
 *  mir stage on pervasives
 *
 *  Revision 1.42  1992/10/02  17:05:26  clive
 *  Change to NewMap.empty which now takes < and = functions instead of the single-function
 *
 *  Revision 1.41  1992/09/15  11:05:20  clive
 *  Checked and corrected the specification for the floating point registers
 *
 *  Revision 1.40  1992/08/20  18:20:37  richard
 *  Added ByteArray primitives.
 *
 *  Revision 1.39  1992/08/19  12:14:25  richard
 *  Added UNSAFE_SUB and UNSAFE_UPDATE to the pervasives.
 *
 *  Revision 1.38  1992/08/17  13:56:42  jont
 *  Added inline ordof
 *
 *  Revision 1.37  1992/08/10  13:03:48  richard
 *  Changed the set of corruptible floating point registers to make
 *  calling C easier.
 *
 *  Revision 1.36  1992/07/28  15:20:38  jont
 *  Added fp registers corrupted and allocation preference
 *
 *  Revision 1.35  1992/06/19  15:51:44  jont
 *  Added ML_REQUIRE builtin for interpreter to get builtin library
 *
 *  Revision 1.34  1992/06/18  16:45:43  jont
 *  Added new builtin ML_OFFSET for computing pointers into middles of
 *  letrec code vectors
 *
 *  Revision 1.33  1992/06/17  09:40:18  jont
 *  Made call_ml_value inline
 *
 *  Revision 1.32  1992/06/15  17:29:55  jont
 *  Added various builtins for interpreter
 *
 *  Revision 1.31  1992/06/15  15:53:53  richard
 *  Added extra temporary for GC and FP registers.
 *
 *  Revision 1.30  1992/06/11  09:21:26  clive
 *  Save argument for the debugger to use
 *
 *  Revision 1.29  1992/06/10  17:09:08  richard
 *  Improved register ordering for allocation.
 *
 *  Revision 1.29  1992/06/10  12:02:30  richard
 *  Improved register colouring order.
 *
 *  Revision 1.28  1992/06/08  15:25:12  richard
 *  Added allocation_order.
 *
 *  Revision 1.27  1992/06/03  16:26:07  richard
 *  The temporary registers are now complete sets rather than preferences.
 *  They are also reserved registers.
 *
 *  Revision 1.26  1992/05/20  10:30:09  clive
 *  Added arithmetic right shift
 *
 *  Revision 1.25  1992/05/13  11:09:34  clive
 *  Added the Bits structure
 *
 *  Revision 1.24  1992/04/07  10:09:24  richard
 *  Partitioned corrupted_by_callee according to register type to
 *  avoid naming clashes.
 *
 *  Revision 1.23  1992/03/06  12:23:55  clive
 *  G7 missed off the corrupted by callee list
 *
 *  Revision 1.22  1992/03/02  15:22:33  richard
 *  Added EQFUN pervasive (not inline) and changed EQ to be inline.
 *  See Mir_Cg.
 *
 *  Revision 1.21  1992/02/11  10:45:19  clive
 *  New pervasive library
 *
 *  Revision 1.20  1992/02/06  16:16:46  richard
 *  Added temporary.
 *
 *  Revision 1.19  1992/01/23  09:35:47  clive
 *  Added the EXSUBSCRIPTVAL and EXSIZEVAL
 *
 *  Revision 1.18  1992/01/21  12:23:50  clive
 *  Added some code to support the ref_chain
 *
 *  Revision 1.17  1992/01/16  09:32:40  clive
 *  Added arrays and made most of the functions in this structure inline coded
 *
 *  Revision 1.16  1992/01/10  11:49:54  richard
 *  Added substring pervasive as a temporary measure until compiler is bootstrapped.
 *
 *  Revision 1.15  1992/01/07  09:29:44  clive
 *  Added stack limit register definitions
 *
 *  Revision 1.14  1992/01/03  16:36:12  richard
 *  Added the zero register.  Added exception values to the is_inline
 *  function.  Tidied up documentation.
 *
 *  Revision 1.13  1991/12/04  13:30:48  richard
 *  Added the callee_closure to the reserved registers so that the
 *  garbage collector can always find the closure.
 *
 *  Revision 1.12  91/11/29  15:28:49  richard
 *  Added `reserved' to prevent register allocation from very special
 *  registers.
 *  
 *  Revision 1.11  91/11/25  15:49:13  jont
 *  Added fp_global as a temporary for conversions from fp to int
 *  
 *  Revision 1.10  91/11/14  14:34:41  richard
 *  Added is_inline clause for CALL_C and SYSTEM.
 *  
 *  Revision 1.9  91/11/14  10:55:57  richard
 *  Removed references to fp_double registers.
 *  
 *  Revision 1.8  91/11/12  16:50:55  jont
 *  Added is_inline function on the pervasives, this is where it should be
 *  Removed specific subfunctions to do with multiply etc capability
 *  
 *  Revision 1.7  91/10/29  14:16:37  jont
 *  Added values indicating existence on machin level multiply, divide
 *  and modulus
 *  
 *  Revision 1.6  91/10/24  15:28:13  davidt
 *  Now knows about the `implicit' register.
 *  
 *  Revision 1.5  91/10/15  15:14:58  richard
 *  Changed corrupted_by_callee to a set rather than a list.
 *  
 *  Revision 1.4  91/10/14  14:37:58  richard
 *  Added corrupted_by_callee and fixed the gc register list.
 *  
 *  Revision 1.3  91/10/10  14:29:52  richard
 *  indicates allocation preferences. after_preserve and after_restore
 *  discarded.
 *  
 *  Revision 1.2  91/10/09  14:28:07  richard
 *  Added some new register definitions
 *  
 *  Revision 1.1  91/10/07  11:44:56  richard
 *  Initial revision
 *)
d4 1
a4 2
;;; Copyright 1991 Harlequin Ltd.
;;; $Log$
d6 4
@
