head	1.30;
access;
symbols
	MLW_daveb_inline_1_4_99:1.30.1
	MLWorks_21c0_1999_03_25:1.30
	MLWorks_20c1_1998_08_20:1.30
	MLWorks_20c0_1998_08_04:1.30
	MLWorks_20b2c2_1998_06_19:1.30
	MLWorks_20b2_Windows_1998_06_12:1.30
	MLWorks_20b1c1_1998_05_07:1.30
	MLWorks_20b0_1998_04_07:1.30
	MLWorks_20b0_1998_03_20:1.30
	MLWorks_20m2_1998_02_16:1.30
	MLWorks_20m1_1997_10_23:1.30
	MLWorks_11r1:1.29.1.1.1.1.1
	MLWorks_workspace_97:1.29.3
	MLWorks_dt_wizard:1.29.2
	MLWorks_11c0_1997_09_09:1.29.1.1.1.1
	MLWorks_10r3:1.29.1.1.3
	MLWorks_10r2_551:1.29.1.1.2
	MLWorks_11:1.29.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.29.1.1
	MLWorks_20m0_1997_06_20:1.29
	MLWorks_1_0_r2c2_1997_06_14:1.29.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.29.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.29.1
	MLWorks_BugFix_1997_04_24:1.29
	MLWorks_1_0_r2_Win32_1997_04_11:1.29
	MLWorks_1_0_r2_Unix_1997_04_04:1.29
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.26.3.1.1
	MLWorks_gui_1996_12_18:1.26.4
	MLWorks_1_0_Win32_1996_12_17:1.26.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.26.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.26.1.1
	MLWorks_1_0_Irix_1996_11_28:1.26.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.26.2
	MLWorks_1_0_Unix_1996_11_14:1.26.1
	MLWorks_Open_Beta2_1996_10_11:1.24.3
	MLWorks_License_dev:1.24.2
	MLWorks_1_open_beta_1996_09_13:1.24.1
	MLWorks_Open_Beta_1996_08_22:1.24
	MLWorks_Beta_1996_07_02:1.24
	MLWorks_Beta_1996_06_07:1.24
	MLWorks_Beta_1996_06_06:1.24
	MLWorks_Beta_1996_06_05:1.24
	MLWorks_Beta_1996_06_03:1.24
	MLWorks_Beta_1996_05_31:1.24
	MLWorks_Beta_1996_05_30:1.24
	ML_beta_release_12/08/94:1.10
	ML_beta_release_03/08/94:1.10
	ML_revised_beta_release_25/05/94:1.6
	ML_final_beta_release_02/03/94:1.2
	mlworks-28-01-1994:1.2;
locks; strict;
comment	@ * @;


1.30
date	97.09.19.09.38.48;	author brucem;	state Exp;
branches
	1.30.1.1;
next	1.29;

1.29
date	97.01.28.15.04.09;	author matthew;	state Exp;
branches
	1.29.1.1
	1.29.2.1
	1.29.3.1;
next	1.28;

1.28
date	97.01.13.12.10.24;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	96.11.11.13.20.47;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	96.11.06.11.11.15;	author matthew;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1
	1.26.4.1;
next	1.25;

1.25
date	96.10.30.20.59.02;	author io;	state Exp;
branches;
next	1.24;

1.24
date	96.05.01.12.03.27;	author jont;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1;
next	1.23;

1.23
date	96.04.29.14.51.51;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	95.12.22.13.17.22;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	95.09.08.14.11.47;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	95.08.21.13.38.26;	author io;	state Exp;
branches;
next	1.19;

1.19
date	95.08.21.11.08.20;	author io;	state Exp;
branches;
next	1.18;

1.18
date	95.08.09.18.09.57;	author io;	state Exp;
branches;
next	1.17;

1.17
date	95.06.19.12.31.06;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.03.07.16.15.56;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	95.01.19.11.24.30;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	94.11.22.17.15.24;	author io;	state Exp;
branches;
next	1.13;

1.13
date	94.11.09.16.19.18;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	94.11.02.13.14.29;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	94.10.21.13.58.50;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	94.07.29.17.53.30;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	94.07.14.15.12.47;	author io;	state Exp;
branches;
next	1.8;

1.8
date	94.06.09.18.03.58;	author io;	state Exp;
branches;
next	1.7;

1.7
date	94.05.10.09.44.45;	author io;	state Exp;
branches;
next	1.6;

1.6
date	94.03.10.12.16.26;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.03.08.13.57.39;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.03.04.16.21.47;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.03.04.15.49.32;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	93.11.16.17.02.25;	author io;	state Exp;
branches;
next	1.1;

1.1
date	93.10.28.14.31.14;	author simon;	state Exp;
branches;
next	;

1.24.1.1
date	96.09.13.11.19.29;	author hope;	state Exp;
branches;
next	;

1.24.2.1
date	96.10.07.16.09.22;	author hope;	state Exp;
branches;
next	;

1.24.3.1
date	96.10.17.11.27.38;	author hope;	state Exp;
branches;
next	;

1.26.1.1
date	96.11.14.12.53.13;	author hope;	state Exp;
branches
	1.26.1.1.1.1;
next	;

1.26.1.1.1.1
date	96.11.28.15.04.10;	author hope;	state Exp;
branches;
next	;

1.26.2.1
date	96.11.22.18.12.13;	author hope;	state Exp;
branches;
next	;

1.26.3.1
date	96.12.17.17.50.42;	author hope;	state Exp;
branches
	1.26.3.1.1.1;
next	;

1.26.3.1.1.1
date	97.02.24.11.41.05;	author hope;	state Exp;
branches;
next	;

1.26.4.1
date	96.12.18.09.44.53;	author hope;	state Exp;
branches;
next	;

1.29.1.1
date	97.05.12.10.37.23;	author hope;	state Exp;
branches
	1.29.1.1.1.1
	1.29.1.1.2.1
	1.29.1.1.3.1;
next	;

1.29.1.1.1.1
date	97.07.28.18.22.37;	author daveb;	state Exp;
branches
	1.29.1.1.1.1.1.1;
next	;

1.29.1.1.1.1.1.1
date	97.10.07.11.48.16;	author jkbrook;	state Exp;
branches;
next	;

1.29.1.1.2.1
date	97.09.08.17.15.58;	author daveb;	state Exp;
branches;
next	;

1.29.1.1.3.1
date	97.09.09.14.11.55;	author daveb;	state Exp;
branches;
next	;

1.29.2.1
date	97.09.10.19.27.59;	author brucem;	state Exp;
branches;
next	;

1.29.3.1
date	97.09.11.20.57.55;	author daveb;	state Exp;
branches;
next	;

1.30.1.1
date	99.04.01.17.58.33;	author daveb;	state Exp;
branches;
next	;


desc
@Default RCS description
Copyright Harlequin Ltd., 1991
@


1.30
log
@[Bug #30153]
Remove references to Old.
@
text
@(*
 Copyright (c) 1993 Harlequin Ltd.

 based on ???
 
 Revision Log
 ------------
 $Log: _mips_assembly.sml,v $
 * Revision 1.29  1997/01/28  15:04:09  matthew
 * Adding trace_nop_code
 *
 * Revision 1.28  1997/01/13  12:10:24  matthew
 * Adding MULT operations for defines_and_uses etc.
 *
 * Revision 1.27  1996/11/11  13:20:47  matthew
 * Case for BEQZ & BNEZ in inverse_branch
 *
 * Revision 1.26  1996/11/06  11:11:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.25  1996/10/30  20:59:02  io
 * moving String from toplevel
 *
 * Revision 1.24  1996/05/01  12:03:27  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.23  1996/04/29  14:51:51  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.22  1995/12/22  13:17:22  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
Revision 1.21  1995/09/08  14:11:47  jont
Add a fixed branch type which can't be expanded beyond the 16 bit limit
This can be used to detect disastrous code generation in computed gotos
If this ever occurs, we can then fix the bug

Revision 1.20  1995/08/21  13:38:26  io
No reason?

Revision 1.19  1995/08/21  11:08:20  io
adding beqz

Revision 1.18  1995/08/09  18:09:57  io
add BNEZ and R4k branch likely instrs eg bnel bltzl blezl bgtzl bgezl beql

Revision 1.17  1995/06/19  12:31:06  matthew
Fixing problem with handler register

Revision 1.16  1995/03/07  16:15:56  matthew
Improving debugger annotations

Revision 1.15  1995/01/19  11:24:30  nickb
Make a SUBI turn into an ADDI, not an ADDIU.

Revision 1.14  1994/11/22  17:15:24  io
args to C.xx wrong way round
added new instrs: CFC1 & CTC1
changed C_DF_D to C_SF_D (misspelling)

Revision 1.13  1994/11/09  16:19:18  matthew
Completed defines_and_uses for float operations.
Semi-fixed  problem with stack references not always being through fp and sp.

Revision 1.12  1994/11/02  13:14:29  matthew
Started implementing defines_and_uses.
This is not complete for floats.
\nImproved printing a bit.

Revision 1.11  1994/10/21  13:58:50  matthew
Corrected label printing and improved code.
Print moves and lis as moves and lis.

Revision 1.10  1994/07/29  17:53:30  jont
Fix backwards encoding of register controlled shifts

Revision 1.9  1994/07/14  15:12:47  io
SRL wrong way round

Revision 1.8  1994/06/09  18:03:58  io
adding comment to nop code

Revision 1.7  1994/05/10  09:44:45  io
adding labels and other cleanups

Revision 1.6  1994/03/10  12:16:26  jont
Adding support for load offset

Revision 1.5  1994/03/08  13:57:39  jont
Add an offset opcode for jump tables

Revision 1.4  1994/03/04  16:21:47  jont
Fix reverse_branch to handle BGTZ etc

Revision 1.3  1994/03/04  15:49:32  nickh
Improve code printing readability

Revision 1.2  1993/11/16  17:02:25  io
Deleted old SPARC comments and fixed type errors

 *)

require "../basis/__int";
require "^.basis.__string_cvt";

require "../utils/crash";
require "../utils/lists";
require "../utils/intnewmap";

require "../mir/mirtypes";
require "mips_opcodes";
require "mips_assembly";


functor Mips_Assembly(
  structure Crash : CRASH
  structure Lists : LISTS		     
  structure Map : INTNEWMAP
  structure MirTypes : MIRTYPES
  structure Mips_Opcodes : MIPS_OPCODES
  ) : MIPS_ASSEMBLY =
struct
  structure MirTypes = MirTypes
  structure Set = MirTypes.Set
  structure Mips_Opcodes = Mips_Opcodes
  structure MachTypes = Mips_Opcodes.MachTypes
  structure Debugger_Types = MirTypes.Debugger_Types

  datatype load_and_store =
    LB |
    LBU |
    LH |
    LHU |
    LW |
    LWL |
    LWR |
    SB |
    SH |
    SW |
    SWL |
    SWR

  datatype load_and_store_float =
    LWC1 |
    SWC1 |
    MTC1 |
    MFC1 |
    CTC1 |
    CFC1

  datatype arithmetic_and_logical =
    ADD |
    ADDI |
    ADDIU |
    ADDU |
    SUB |
    SUBU |
    AND |
    ANDI |
    OR |
    ORI |
    XOR |
    XORI |
    NOR |
    SLT |
    SLTU |
    SLTI |
    SLTIU |
    SLL |
    SRL |
    SRA |
    SLLV |
    SRLV |
    SRAV

  datatype load_offset = LEO

  datatype special_arithmetic = ADD_AND_MASK

  datatype special_load_offset =
    LOAD_OFFSET_AND_MASK |
    LOAD_OFFSET_HIGH

  datatype mult_and_div =
    MULT |
    MULTU |
    DIV |
    DIVU

  datatype mult_and_div_result =
    MFHI |
    MFLO |
    MTHI |
    MTLO

  datatype sethi = LUI

  datatype branch =
    BA |
    BEQ |
    BNE |
    BEQZ |
    BNEZ |
    BLEZ |
    BGTZ |
    BLTZ |
    BGEZ |
    (* r4k *)
    BNEL |
    BLTZL |
    BLEZL |
    BGTZL |
    BGEZL |
    BEQL

  datatype call = 
    BLTZAL |
    BGEZAL

  datatype jump = 
    JAL |
    JALR |
    J |
    JR

  datatype conv_op =
    CVT_S_D |
    CVT_S_W |
    CVT_D_W |
    CVT_D_S |
    CVT_W_D |
    CVT_W_S

  datatype funary =
    MOV_S |
    MOV_D |
    NEG_S |
    NEG_D |
    ABS_S |
    ABS_D

  datatype fbinary =
    ADD_D |
    ADD_S |
    DIV_D |
    DIV_S |
    MUL_D |
    MUL_S |
    SUB_D |
    SUB_S

  datatype fcmp =
    C_F_S   | 
    C_UN_S  | 
    C_EQ_S  | 
    C_UEQ_S | 
    C_OLT_S | 
    C_ULT_S | 
    C_OLE_S | 
    C_ULE_S |
    C_SF_S  | 
    C_NGLE_S | 
    C_SEQ_S | 
    C_NGL_S | 
    C_LT_S  | 
    C_NGE_S | 
    C_LE_S  | 
    C_NGT_S |
    C_F_D   | 
    C_UN_D  | 
    C_EQ_D  | 
    C_UEQ_D | 
    C_OLT_D | 
    C_ULT_D | 
    C_OLE_D | 
    C_ULE_D |
    C_SF_D  | 
    C_NGLE_D | 
    C_SEQ_D | 
    C_NGL_D | 
    C_LT_D  | 
    C_NGE_D | 
    C_LE_D  | 
    C_NGT_D

  datatype fbranch =
    BC1T |
    BC1F

(* have omitted, so far: SYSCALL BREAK *)

  datatype reg_or_imm =
    REG of MachTypes.Mips_Reg |
    IMM of int

  datatype opcode =
    LOAD_AND_STORE of 
    load_and_store * MachTypes.Mips_Reg * MachTypes.Mips_Reg * int
  | LOAD_AND_STORE_FLOAT of 
    load_and_store_float * MachTypes.Mips_Reg * MachTypes.Mips_Reg * reg_or_imm
  | ARITHMETIC_AND_LOGICAL of
    arithmetic_and_logical * MachTypes.Mips_Reg * MachTypes.Mips_Reg * reg_or_imm
  | SPECIAL_ARITHMETIC of
      special_arithmetic * MachTypes.Mips_Reg * reg_or_imm * MachTypes.Mips_Reg
  | MULT_AND_DIV of
    mult_and_div * MachTypes.Mips_Reg * MachTypes.Mips_Reg
  | MULT_AND_DIV_RESULT of
    mult_and_div_result * MachTypes.Mips_Reg
  | SETHI of sethi * MachTypes.Mips_Reg * int
  | BRANCH of branch * MachTypes.Mips_Reg * MachTypes.Mips_Reg * int
  | FIXED_BRANCH of branch * MachTypes.Mips_Reg * MachTypes.Mips_Reg * int
  | CALL of call * MachTypes.Mips_Reg * int *
    MirTypes.Debugger_Types.Backend_Annotation
  | JUMP of jump * reg_or_imm * MachTypes.Mips_Reg *
    MirTypes.Debugger_Types.Backend_Annotation
  | FBRANCH of fbranch * int
  | CONV_OP of conv_op * MachTypes.Mips_Reg * MachTypes.Mips_Reg
  | FUNARY of funary * MachTypes.Mips_Reg * MachTypes.Mips_Reg
  | FBINARY of fbinary * MachTypes.Mips_Reg * MachTypes.Mips_Reg *
    MachTypes.Mips_Reg
  | FCMP of fcmp * MachTypes.Mips_Reg * MachTypes.Mips_Reg
  | OFFSET of int
  | LOAD_OFFSET of load_offset * MachTypes.Mips_Reg * int
  | SPECIAL_LOAD_OFFSET of special_load_offset * MachTypes.Mips_Reg * MachTypes.Mips_Reg * int

  fun decode_load_and_store LB  = "lb     "
    | decode_load_and_store LBU = "lbu    "
    | decode_load_and_store LH  = "lh     "
    | decode_load_and_store LHU = "lhu    "
    | decode_load_and_store LW  = "lw     "
    | decode_load_and_store LWL = "lwl    "
    | decode_load_and_store LWR = "lwr    "
    | decode_load_and_store SB  = "sb     "
    | decode_load_and_store SH  = "sh     "
    | decode_load_and_store SW  = "sw     "
    | decode_load_and_store SWL = "swl    "
    | decode_load_and_store SWR = "swr    "

  fun decode_load_and_store_float LWC1 = "lwc1   "
    | decode_load_and_store_float SWC1 = "swc1   "
    | decode_load_and_store_float MTC1 = "mtc1   "
    | decode_load_and_store_float MFC1 = "mfc1   "
    | decode_load_and_store_float CTC1 = "ctc1   "
    | decode_load_and_store_float CFC1 = "cfc1   "

  fun decode_arithmetic_and_logical ADD   = "add    "
    | decode_arithmetic_and_logical ADDI  = "addi   "
    | decode_arithmetic_and_logical ADDIU = "addiu  "
    | decode_arithmetic_and_logical ADDU  = "addu   "
    | decode_arithmetic_and_logical SUB   = "sub    "
    | decode_arithmetic_and_logical SUBU  = "subu   "
    | decode_arithmetic_and_logical AND   = "and    "
    | decode_arithmetic_and_logical ANDI  = "andi   "
    | decode_arithmetic_and_logical OR    = "or     "
    | decode_arithmetic_and_logical ORI   = "ori    "
    | decode_arithmetic_and_logical XOR   = "xor    "
    | decode_arithmetic_and_logical XORI  = "xori   "
    | decode_arithmetic_and_logical NOR   = "nor    "
    | decode_arithmetic_and_logical SLT   = "slt    "
    | decode_arithmetic_and_logical SLTU  = "sltu   "
    | decode_arithmetic_and_logical SLTI  = "slti   "
    | decode_arithmetic_and_logical SLTIU = "sltiu  "
    | decode_arithmetic_and_logical SLL   = "sll    "
    | decode_arithmetic_and_logical SRL   = "srl    "
    | decode_arithmetic_and_logical SRA   = "sra    "
    | decode_arithmetic_and_logical SLLV  = "sllv   "
    | decode_arithmetic_and_logical SRLV  = "srlv   "
    | decode_arithmetic_and_logical SRAV  = "srav   "

  fun decode_mult_and_div MULT  = "mult   "
    | decode_mult_and_div MULTU = "multu  "
    | decode_mult_and_div DIV   = "div    "
    | decode_mult_and_div DIVU  = "divu   "

  fun decode_mult_and_div_result MFHI = "mfhi   "
    | decode_mult_and_div_result MFLO = "mflo   "
    | decode_mult_and_div_result MTHI = "mthi   "
    | decode_mult_and_div_result MTLO = "mtlo   "

  fun decode_sethi LUI = "lui    "

  fun decode_branch BA   = "ba     "
    | decode_branch BEQ  = "beq    "
    | decode_branch BNE  = "bne    "
    | decode_branch BEQZ = "beqz   "
    | decode_branch BNEZ = "bnez   "
    | decode_branch BLEZ = "blez   "
    | decode_branch BGTZ = "bgtz   "
    | decode_branch BLTZ = "bltz   "
    | decode_branch BGEZ = "bgez   "
    | decode_branch BNEL = "bnel   "
    | decode_branch BLTZL= "bltzl  "
    | decode_branch BLEZL= "blezl  "
    | decode_branch BGTZL= "bgtzl  "
    | decode_branch BGEZL= "bgezl  "
    | decode_branch BEQL = "beql   "


  fun decode_call BLTZAL = "bltzal "
    | decode_call BGEZAL = "bgezal "

  fun decode_jump JAL  = "jal    "
    | decode_jump JALR = "jalr   "
    | decode_jump J    = "j      "
    | decode_jump JR   = "jr     "

  fun decode_conv_op CVT_S_D = "cvt.s.d "
    | decode_conv_op CVT_S_W = "cvt.s.w "
    | decode_conv_op CVT_D_W = "cvt.d.w "
    | decode_conv_op CVT_D_S = "cvt.d.s "
    | decode_conv_op CVT_W_D = "cvt.w.d "
    | decode_conv_op CVT_W_S = "cvt.w.s "

  fun decode_funary MOV_S = "mov.s  "
    | decode_funary MOV_D = "mov.d  "
    | decode_funary NEG_S = "neg.s  "
    | decode_funary NEG_D = "neg.d  "
    | decode_funary ABS_S = "abs.s  "
    | decode_funary ABS_D = "abs.d  "

  fun decode_fbinary ADD_D = "add.d  "
    | decode_fbinary ADD_S = "add.s  "
    | decode_fbinary DIV_D = "div.d  "
    | decode_fbinary DIV_S = "div.s  "
    | decode_fbinary MUL_D = "mul.d  "
    | decode_fbinary MUL_S = "mul.s  "
    | decode_fbinary SUB_D = "sub.d  "
    | decode_fbinary SUB_S = "sub.s  "

  fun decode_fbranch BC1T = "bc1t   "
    | decode_fbranch BC1F = "bc1f   "

  fun decode_fcmp C_F_S   = "c.s.f  "
    | decode_fcmp C_UN_S  = "c.un.s "
    | decode_fcmp C_EQ_S  = "c.eq.s "
    | decode_fcmp C_UEQ_S = "c.ueq.s "
    | decode_fcmp C_OLT_S = "c.olt.s "
    | decode_fcmp C_ULT_S = "c.ult.s "
    | decode_fcmp C_OLE_S = "c.ole.s "
    | decode_fcmp C_ULE_S = "c.ule.s "
    | decode_fcmp C_SF_S  = "c.sf.s "
    | decode_fcmp C_NGLE_S= "c.ngle.s "
    | decode_fcmp C_SEQ_S = "c.seq.s "
    | decode_fcmp C_NGL_S = "c.ngl.s "
    | decode_fcmp C_LT_S  = "c.lt.s "
    | decode_fcmp C_NGE_S = "c.nge.s "
    | decode_fcmp C_LE_S  = "c.le.s "
    | decode_fcmp C_NGT_S = "c.ngt.s "
    | decode_fcmp C_F_D   = "c.f.d  "
    | decode_fcmp C_UN_D  = "c.un.d "
    | decode_fcmp C_EQ_D  = "c.eq.d "
    | decode_fcmp C_UEQ_D = "c.ueq.d "
    | decode_fcmp C_OLT_D = "c.olt.d "
    | decode_fcmp C_ULT_D = "c.ult.d "
    | decode_fcmp C_OLE_D = "c.ole.d "
    | decode_fcmp C_ULE_D = "c.ule.d "
    | decode_fcmp C_SF_D  = "c.sf.d "
    | decode_fcmp C_NGLE_D= "c.ngle.d "
    | decode_fcmp C_SEQ_D = "c.seq.d "
    | decode_fcmp C_NGL_D = "c.ngl.d "
    | decode_fcmp C_LT_D  = "c.lt.d "
    | decode_fcmp C_NGE_D = "c.nge.d "
    | decode_fcmp C_LE_D  = "c.le.d "
    | decode_fcmp C_NGT_D= "c.ngt.d "

  fun decode offset = "OFFSET"

  fun assemble(LOAD_AND_STORE(load_and_store, rt, base, imm)) =
    let val op2 = case load_and_store of
      LB  => 32
    | LBU => 36
    | LH  => 33
    | LHU => 37
    | LW  => 35
    | LWL => 34
    | LWR => 38 
    | SB  => 40
    | SH  => 41
    | SW  => 43
    | SWL => 42
    | SWR => 46
    in
      Mips_Opcodes.FORMATI(op2, base, rt, imm) 
    end
    | assemble(LOAD_AND_STORE_FLOAT(load_and_store_float, rt, base, reg_or_imm )) =
      ( case reg_or_imm of
	REG reg => 
	  let val op2 = case load_and_store_float of
	    MTC1 => 4
	  | MFC1 => 0
	  | CFC1 => 2
	  | CTC1 => 6
	  | _ => Crash.impossible "assemble load_and_store_float reg"
	  in
	    Mips_Opcodes.FORMATR2(17, op2, Mips_Opcodes.register_val rt, 
				  Mips_Opcodes.register_val base, 0, 0)
	  end
      | IMM imm =>
	  let val op2 = case load_and_store_float of
	    LWC1 => 49
	  | SWC1 => 57
	  | _    => Crash.impossible "assemble load_and_store_float imm" 
	  in
	    Mips_Opcodes.FORMATI(op2, base, rt, imm)
	  end)
    | assemble(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical, rd, rs, reg_or_imm)) =
      (case reg_or_imm of
	 REG reg =>
	   let
	     val (op2, reg, rs) = case arithmetic_and_logical of
	     ADD  => (32, reg, rs)
	   | ADDU => (33, reg, rs)
	   | SUB  => (34, reg, rs)
	   | SUBU => (35, reg, rs)
	   | AND  => (36, reg, rs)
	   | OR   => (37, reg, rs)
	   | XOR  => (38, reg, rs)
	   | NOR  => (39, reg, rs)
	   | SLT  => (42, reg, rs)
	   | SLTU => (43, reg, rs)
	   | SLLV =>  (4, rs, reg)
	   | SLL  =>  (4 (* really an SLLV *), rs, reg)
	   | SRAV =>  (7, rs, reg)
	   | SRA  =>  (7 (* really an SRAV *), rs, reg)
	   | SRLV =>  (6, rs, reg)
	   | SRL  =>  (6 (* really an SRLV *), rs, reg)
	   | _    => Crash.impossible ("assemble arith1 " ^ decode_arithmetic_and_logical arithmetic_and_logical)
	   in
	     Mips_Opcodes.FORMATR(0, rs, reg, rd, 0, op2)
	   end
       | IMM imm =>
	   (case arithmetic_and_logical of
	      SRL  => Mips_Opcodes.FORMATR(0, MachTypes.R0, rs, rd, imm, 2)
	    | SRA  => Mips_Opcodes.FORMATR(0, MachTypes.R0, rs, rd, imm, 3)
	    | SLL  => Mips_Opcodes.FORMATR(0, MachTypes.R0, rs, rd, imm, 0)
	    | SLTIU=> Mips_Opcodes.FORMATI(11, rs, rd, imm)
	    | SLTU => Mips_Opcodes.FORMATI(11, rs, rd, imm) (* aka SLTIU *)
	    | SLTI => Mips_Opcodes.FORMATI(10, rs, rd, imm)
	    | SLT  => Mips_Opcodes.FORMATI(10, rs, rd, imm) (* aka SLTI *)
		
(*
	      SRL  => Mips_Opcodes.FORMATR(0, MachTypes.R0, rd, rs, imm, 2)
	    | SRA  => Mips_Opcodes.FORMATR(0, MachTypes.R0, rd, rs, imm, 3)
	    | SLL  => Mips_Opcodes.FORMATR(0, MachTypes.R0, rd, rs, imm, 0)
	    | SLTIU=> Mips_Opcodes.FORMATI(11, rs, rd, imm)
	    | SLTI => Mips_Opcodes.FORMATI(10, rs, rd, imm)
*)
	    | XORI => Mips_Opcodes.FORMATI(14, rs, rd, imm)
	    | XOR  => Mips_Opcodes.FORMATI(14, rs, rd, imm) (* really an XORI *)
	    | ORI  => Mips_Opcodes.FORMATI(13, rs, rd, imm)
	    | OR   => Mips_Opcodes.FORMATI(13, rs, rd, imm) (* really an ORI *)
	    | ANDI => Mips_Opcodes.FORMATI(12, rs, rd, imm)
	    | AND  => Mips_Opcodes.FORMATI(12, rs, rd, imm) (* really an ANDI *)
	    | ADDI => Mips_Opcodes.FORMATI( 8, rs, rd, imm)
	    | ADD  => Mips_Opcodes.FORMATI( 8, rs, rd, imm) (* really an ADDI *)
	    | ADDIU=> Mips_Opcodes.FORMATI( 9, rs, rd, imm)
	    | ADDU => Mips_Opcodes.FORMATI( 9, rs, rd, imm) (* really an ADDIU *)
	    | SUB  => Mips_Opcodes.FORMATI( 8, rs, rd, 65536-imm) (* really an ADDIU *)
	    | SUBU => Mips_Opcodes.FORMATI( 9, rs, rd, 65536-imm) (* really an ADDIU *)
	    | _    => Crash.impossible ("assemble arith2 " ^ decode_arithmetic_and_logical arithmetic_and_logical)))
    | assemble(MULT_AND_DIV(mult_and_div, rs, rt)) =
      let val op2 = case mult_and_div of
	MULT  => 24
      | MULTU => 25
      | DIV   => 26
      | DIVU  => 27
      in
	Mips_Opcodes.FORMATI(0, rs, rt, op2) (* really R-type with 2 zero fields *)
      end
    | assemble(MULT_AND_DIV_RESULT(mult_and_div_result, rd)) =
      let val op2 = case mult_and_div_result of
	MFHI => 16
      | MTHI => 17
      | MFLO => 18
      | MTLO => 19
      in
	Mips_Opcodes.FORMATR2(0, 0, 0, Mips_Opcodes.register_val rd, 0, op2)
      end
    | assemble(SETHI(sethi, rt, imm)) =
       Mips_Opcodes.FORMATI2(15, 0, Mips_Opcodes.register_val rt, imm)
    | assemble(BRANCH(branch, rs, rt, imm)) = let
        val rVal = Mips_Opcodes.register_val
        val (branch', rs', rt') = case branch of
	  BA  => (4,       0,       0)
	| BEQ => (4, rVal rs, rVal rt)
        | BEQZ =>(4, rVal rs,      0) (* beq lhs zero *)
	| BNE => (5, rVal rs, rVal rt)
	| BNEZ =>(5, rVal rs,       0) (* bne lhs zero *) 
	| BLEZ=> (6, rVal rs,       0)
	| BGTZ=> (7, rVal rs,       0)
	| BLTZ=> (1, rVal rs,       0)
	| BGEZ=> (1, rVal rs,       1) 
	| BNEL=> (21,rVal rs, rVal rt) (* r4k *)
	| BLTZL=>(1, rVal rs,       2) (* r4k *)
	| BLEZL=>(22,rVal rs,       0) (* r4k *)
	| BGTZL=>(23,rVal rs,       0) (* r4k *)
	| BGEZL=>(1, rVal rs,       3) (* r4k *)
	| BEQL=> (20,rVal rs, rVal rt) (* r4k *)
      in
	Mips_Opcodes.FORMATI2(branch', rs', rt', imm)
      end
    | assemble(FIXED_BRANCH(branch, rs, rt, imm)) = let
        val rVal = Mips_Opcodes.register_val
        val (branch', rs', rt') = case branch of
	  BA  => (4,       0,       0)
	| BEQ => (4, rVal rs, rVal rt)
        | BEQZ =>(4, rVal rs,      0) (* beq lhs zero *)
	| BNE => (5, rVal rs, rVal rt)
	| BNEZ =>(5, rVal rs,       0) (* bne lhs zero *) 
	| BLEZ=> (6, rVal rs,       0)
	| BGTZ=> (7, rVal rs,       0)
	| BLTZ=> (1, rVal rs,       0)
	| BGEZ=> (1, rVal rs,       1) 
	| BNEL=> (21,rVal rs, rVal rt) (* r4k *)
	| BLTZL=>(1, rVal rs,       2) (* r4k *)
	| BLEZL=>(22,rVal rs,       0) (* r4k *)
	| BGTZL=>(23,rVal rs,       0) (* r4k *)
	| BGEZL=>(1, rVal rs,       3) (* r4k *)
	| BEQL=> (20,rVal rs, rVal rt) (* r4k *)
      in
	Mips_Opcodes.FORMATI2(branch', rs', rt', imm)
      end
    | assemble(CALL(call, rs, imm,_)) =
      let val op1 = case call of
	BLTZAL => 16
      | BGEZAL => 17
      in
	Mips_Opcodes.FORMATI2(1, Mips_Opcodes.register_val rs, op1, imm)
      end
    | assemble(JUMP(jump, reg_or_imm, rs, _)) =
      (case reg_or_imm of
	 REG reg =>
	   (case jump of
              (* reg_or_imm is reg to jump to *)
              (* rs is irrelevant *)
	      JR => Mips_Opcodes.FORMATR2(0, Mips_Opcodes.register_val reg, 
					  0, 0, 0, 8)
            (* rs is reg to jump to *)
            (* reg_or_imm is the link register *)
	    | JALR => Mips_Opcodes.FORMATR2(0, Mips_Opcodes.register_val rs, 
					    0, Mips_Opcodes.register_val reg, 0, 9)
	    | _ => Crash.impossible "assemble JUMP reg")
       | IMM imm =>
	   (case jump of 
	      JAL => Mips_Opcodes.FORMATJ(3, imm)
	    | J => Mips_Opcodes.FORMATJ(2, imm)
	    | _ => Crash.impossible "assemble JUMP imm"))
    | assemble(FBRANCH(BC1T, imm)) = Mips_Opcodes.FORMATI2(17, 8, 1, imm)
    | assemble(FBRANCH(BC1F, imm)) = Mips_Opcodes.FORMATI2(17, 8, 0, imm)
    | assemble(CONV_OP(conv_op, fd, fs)) =
      let val (op1, fmt) = case conv_op of
	CVT_S_D => (32, 1)
      | CVT_S_W => (32, 4)
      | CVT_D_S => (33, 0)
      | CVT_D_W => (33, 4)
      | CVT_W_S => (36, 0)
      | CVT_W_D => (36, 1)
      in
	Mips_Opcodes.FORMATR2(17, 16 + fmt, 0, Mips_Opcodes.register_val fs, 
			      Mips_Opcodes.register_val fd, op1)
      end
    | assemble(FUNARY(funary, fd, fs)) =
      let val (op1, fmt) = case funary of
	MOV_S => (6, 0)
      | MOV_D => (6, 1)
      | NEG_S => (7, 0)
      | NEG_D => (7, 1)
      | ABS_S => (5, 0)
      | ABS_D => (5, 1)
      in
	Mips_Opcodes.FORMATR2(17, 16 + fmt, 0, Mips_Opcodes.register_val fs, 
			      Mips_Opcodes.register_val fd, op1)
      end
    | assemble(FBINARY(fbinary, fd, fs, ft)) =
      let val (op1, fmt) = case fbinary of
	ADD_S => (0, 0)
      | ADD_D => (0, 1)
      | SUB_S => (1, 0)
      | SUB_D => (1, 1)
      | MUL_S => (2, 0)
      | MUL_D => (2, 1)
      | DIV_S => (3, 0)
      | DIV_D => (3, 1)
      in
	Mips_Opcodes.FORMATR2(17, 16 + fmt, Mips_Opcodes.register_val ft, 
			      Mips_Opcodes.register_val fs, Mips_Opcodes.register_val fd, op1)
      end
    | assemble(FCMP(fcmp, fs, ft)) =
      let val (fmt, cond) = case fcmp of
	C_F_S    => (0, 48)
      | C_UN_S   => (0, 49)
      | C_EQ_S   => (0, 50)
      | C_UEQ_S  => (0, 51)
      | C_OLT_S  => (0, 52)
      | C_ULT_S  => (0, 53)
      | C_OLE_S  => (0, 54)
      | C_ULE_S  => (0, 55)
      | C_SF_S   => (0, 56)
      | C_NGLE_S => (0, 57)
      | C_SEQ_S  => (0, 58)
      | C_NGL_S  => (0, 59)
      | C_LT_S   => (0, 60)
      | C_NGE_S  => (0, 61)
      | C_LE_S   => (0, 62)
      | C_NGT_S  => (0, 63)
      | C_F_D    => (1, 48)
      | C_UN_D   => (1, 49)
      | C_EQ_D   => (1, 50)
      | C_UEQ_D  => (1, 51)
      | C_OLT_D  => (1, 52)
      | C_ULT_D  => (1, 53)
      | C_OLE_D  => (1, 54)
      | C_ULE_D  => (1, 55)
      | C_SF_D   => (1, 56)
      | C_NGLE_D => (1, 57)
      | C_SEQ_D  => (1, 58)
      | C_NGL_D  => (1, 59)
      | C_LT_D   => (1, 60)
      | C_NGE_D  => (1, 61)
      | C_LE_D   => (1, 62)
      | C_NGT_D  => (1, 63)
      in
	Mips_Opcodes.FORMATR2(17, 16 + fmt, Mips_Opcodes.register_val ft,
			      Mips_Opcodes.register_val fs, 0, cond)
      end
    | assemble(OFFSET i) = Mips_Opcodes.OFFSET i
    | assemble(SPECIAL_ARITHMETIC _) = Crash.impossible"assemble SPECIAL_ARITHMETIC"
    | assemble(LOAD_OFFSET _) = Crash.impossible"assemble LOAD_OFFSET"
    | assemble(SPECIAL_LOAD_OFFSET _) = Crash.impossible"assemble SPECIAL_LOAD_OFFSET"

  fun pad columns x = 
    if size x < columns then
      StringCvt.padRight #" " columns x
    else
      x ^ " "
  local val opwidth = 9 in
			  val padit = pad opwidth
  end

  fun decode_reg_or_imm(REG reg) = MachTypes.reg_to_string reg
    | decode_reg_or_imm(IMM i) = "#" ^ Int.toString i

  fun decode_reg_or_imm_nohash(REG reg) = MachTypes.reg_to_string reg
    | decode_reg_or_imm_nohash(IMM i) = Int.toString i

  type LabMap = string Map.T

  (* Unordered list of jump destinations to a map from destinations to labels *)
  fun make_labmap_from_list (destination_list) = 
    let
      (* This should be in Lists structure *)
      fun remove_duplicates ([], acc) = rev acc
        | remove_duplicates ([a], acc) = rev (a::acc)
        | remove_duplicates (a::(rest as (b :: c)), acc) = 
          if a = b then
            remove_duplicates (a::c,acc)
          else remove_duplicates (rest, a::acc)
      val sorted = remove_duplicates (Lists.qsort (op <) destination_list, [])
      fun print_label i = "L" ^ Int.toString i
      (* And generate unique ordered label strings *)
      val (labmap,_) = Lists.reducel 
        (fn ((map,n),m) => (Map.define (map,m,print_label n),n+1))
        ((Map.empty, 0), sorted)
    in 
      labmap
    end

  local

    (* i is position of current instruction *)
    (* offset is branch offset *)
    (* +1 because offsets are from the next instruction *)

    fun get_destination ((i,destinations),opcode) =
      let
        fun add_branch (i,destinations,offset) = (offset+i+1) :: destinations
        val destinations' =
          case opcode of
            BRANCH (_, _, _, offset) => add_branch (i,destinations,offset)
	  | FIXED_BRANCH (_, _, _, offset) => add_branch (i,destinations,offset)
          | FBRANCH (_, offset) => add_branch (i,destinations,offset)
          | CALL (_, _,offset,_) => add_branch (i,destinations,offset)
          | _ => destinations
      in
        (i+1,destinations')
      end

    fun align i = if i mod 2 = 0 then i else i+1

  in
    (* The diddling with +- 2 is to cope with backptr slots *)
    fun make_labmap (codelistlist) = 
      let
        val (_,destinations) = 
          Lists.reducel 
          (fn ((i,acc),codelist) => 
           (Lists.reducel
            (fn ((i,acc),code) => 
             (* Double word align just in case *)
             (* Add 2 here for the back pointer and annotation *)
             Lists.reducel get_destination ((align i + 2, acc),code))
            ((align i,acc),codelist)))
          ((0,[]),codelistlist)
      in
        make_labmap_from_list destinations
      end (* make_labmap *)

  end (* local *)

  fun print_label (labmap, current, index) = 
    Map.apply' (labmap, current+index+1) 
    handle Map.Undefined => "<Undefined:" ^ Int.toString index ^ ">"
	
  fun opcode_text (opcode,n,labmap) = 
    case opcode of
      LOAD_AND_STORE(load_and_store, reg1, reg2, imm) => 
	concat [
		 decode_load_and_store load_and_store,
		 MachTypes.reg_to_string reg1, ", ", 
		 Int.toString imm,
		 "(",
		 MachTypes.reg_to_string reg2,
		 ")"]

    | LOAD_AND_STORE_FLOAT(load_and_store_float, reg1, reg2, reg_or_imm) =>
	if (Lists.member(load_and_store_float, [MTC1, MFC1, CFC1, CTC1])) then
	  concat [
		  decode_load_and_store_float load_and_store_float,
		  MachTypes.reg_to_string reg1, ", ",
		  MachTypes.fp_reg_to_string reg2]
       else concat [
                     decode_load_and_store_float load_and_store_float,
		     MachTypes.fp_reg_to_string reg1, ", ",
		     decode_reg_or_imm_nohash reg_or_imm, "(",
		     MachTypes.reg_to_string reg2, ")"]
    | ARITHMETIC_AND_LOGICAL(SLL, MachTypes.R0, MachTypes.R0, IMM 0) => padit "nop"
    | ARITHMETIC_AND_LOGICAL(OR, reg1, reg2, REG MachTypes.R0) => 
        concat ["move   ",
                 MachTypes.reg_to_string reg1, ", ",
                 MachTypes.reg_to_string reg2]
    | ARITHMETIC_AND_LOGICAL(ADDIU, reg1, MachTypes.R0, imm) => 
        concat ["li     ",
                 MachTypes.reg_to_string reg1, ", ",
                 decode_reg_or_imm imm]

    | ARITHMETIC_AND_LOGICAL(arithmetic_and_logical, reg1, reg2, reg_or_imm) =>
	concat [
		 decode_arithmetic_and_logical arithmetic_and_logical,
		 MachTypes.reg_to_string reg1, ", ",
		 MachTypes.reg_to_string reg2, ", ",
		 decode_reg_or_imm reg_or_imm ]
    | MULT_AND_DIV(mult_and_div, reg1, reg2) =>
	concat [
		 decode_mult_and_div mult_and_div,
		 MachTypes.reg_to_string reg1, ", ",
		 MachTypes.reg_to_string reg2 ]
    | MULT_AND_DIV_RESULT(mult_and_div_result, reg) =>
	concat [
		 decode_mult_and_div_result mult_and_div_result,
		 MachTypes.reg_to_string reg ]

    | SETHI(sethi, reg, imm) =>
	concat [
		 decode_sethi sethi,
		 MachTypes.reg_to_string reg, ", #",
		 Int.toString (if imm < 0 then imm+65536 else imm) ]
    | BRANCH(BA, _, _, imm) =>
	concat [
		 decode_branch BA,
		 print_label (labmap, n, imm) ]

    | BRANCH(branch, reg1, reg2, imm) =>
	concat [
		 decode_branch branch,
		 MachTypes.reg_to_string reg1, ", ",
		 case branch of
		   BLTZ => ""
		 | BLEZ => ""
		 | BGEZ => ""
		 | BGTZ => ""
		 | _    => MachTypes.reg_to_string reg2 ^ ", ",
		 print_label (labmap, n, imm) ]

    | FIXED_BRANCH(BA, _, _, imm) =>
	concat [
		 decode_branch BA,
		 print_label (labmap, n, imm) ]

    | FIXED_BRANCH(branch, reg1, reg2, imm) =>
	concat [
		 decode_branch branch,
		 MachTypes.reg_to_string reg1, ", ",
		 case branch of
		   BLTZ => ""
		 | BLEZ => ""
		 | BGEZ => ""
		 | BGTZ => ""
		 | _    => MachTypes.reg_to_string reg2 ^ ", ",
		 print_label (labmap, n, imm) ]

    | CALL(call, reg, imm,_) =>
	concat [
		 decode_call call,
		 MachTypes.reg_to_string reg,", ",
		 print_label (labmap, n, imm) ]

    | JUMP(JR, REG rd, rs, Annotation) =>
	concat [
		 decode_jump JR,
		 MachTypes.reg_to_string rd ]
    | JUMP(JALR, REG rd, rs, Annotation) =>
	concat [
		 decode_jump JALR,
		 MachTypes.reg_to_string rd, ", ",
		 MachTypes.reg_to_string rs ]
    | JUMP(jump, IMM imm, rs, Annotation) =>
	concat [
		 decode_jump jump,
		 print_label (labmap, n, imm) ]
    | JUMP(_,_,_,_) => Crash.impossible "assemble.print JUMP has illegal mode"
    | FBRANCH(fbranch, imm) =>
	concat [
		 decode_fbranch fbranch,
		 print_label (labmap, n, imm) ]
    | CONV_OP(conv_op, reg1, reg2) =>
	concat [
		 decode_conv_op conv_op,
		 MachTypes.fp_reg_to_string reg1, ", ",
		 MachTypes.fp_reg_to_string reg2 ]
    | FUNARY(funary, reg1, reg2) =>
	concat [
		 decode_funary funary,
		 MachTypes.fp_reg_to_string reg1, ", ",
		 MachTypes.fp_reg_to_string reg2 ]
    | FBINARY(fbinary, reg1, reg2, reg3) =>
	concat [
		 decode_fbinary fbinary,
		 MachTypes.fp_reg_to_string reg1, ", ",
		 MachTypes.fp_reg_to_string reg2, ", ",
		 MachTypes.fp_reg_to_string reg3 ]
    | FCMP(fcmp, reg1, reg2) =>
	concat [
		 decode_fcmp fcmp,
		 MachTypes.fp_reg_to_string reg1, ", ",
		 MachTypes.fp_reg_to_string reg2 ]
    | OFFSET i => "OFFSET " ^ Int.toString i
    | LOAD_OFFSET(_, rd, i) =>
	concat [
		 "load_offset ",
		 MachTypes.reg_to_string rd,
		 " plus ",
		 Int.toString i ]
    | SPECIAL_ARITHMETIC _ => Crash.impossible "opcode_text SPECIAL_ARITHMETIC"
    | SPECIAL_LOAD_OFFSET _ => Crash.impossible"opcode_text SPECIAL_LOAD_OFFSET"

  (* labprint: prettyprints output with assembler labels *)
  fun labprint (opcode, i, labmap) = 
    let
      val line = opcode_text (opcode, i, labmap)
    in
      case Map.tryApply' (labmap, i) of
        SOME labelstring => (labelstring ^ ":", line)
      | _ => ("", line)
    end

(*
 Mips_Assembly.print has been bypassed by the definition MachPrint.print
*)
  local
    fun hexchar a = chr (if a < 10 then a + ord #"0" else a + ord #"a" - 10);
    fun char2_2hex ch = (str (hexchar ((ord ch) div 16))) ^ (str (hexchar ((ord ch) mod 16)))
    fun string2hex s = concat (map char2_2hex (explode s))
  in
    fun print instr =
        string2hex (Mips_Opcodes.output_opcode (assemble instr))
	^ " " ^ opcode_text (instr,0,Map.empty)

  end (* local *)

  fun reverse_branch BEQ  = BEQ (*to compare arithmetic quantities in reversed order*)
    | reverse_branch BEQZ = BEQZ (* unary instr *)
    | reverse_branch BNE  = BNE
    | reverse_branch BNEZ = BNEZ 
    | reverse_branch BA   = BA
    | reverse_branch BLEZ = BGEZ 
    | reverse_branch BGTZ = BLTZ 
    | reverse_branch BLTZ = BGTZ 
    | reverse_branch BGEZ = BLEZ
    | reverse_branch BNEL = BNEL
    | reverse_branch BLTZL= BGTZL
    | reverse_branch BLEZL= BGEZL
    | reverse_branch BGTZL= BLTZL
    | reverse_branch BGEZL= BLEZL
    | reverse_branch BEQL = BEQL


  fun inverse_branch BEQ  = BNE (*to handle control flow alterations*)
    | inverse_branch BEQZ = BNEZ
    | inverse_branch BNE  = BEQ
    | inverse_branch BNEZ = BEQZ
    | inverse_branch BLEZ = BGTZ
    | inverse_branch BGTZ = BLEZ
    | inverse_branch BLTZ = BGEZ
    | inverse_branch BGEZ = BLTZ
    | inverse_branch BNEL = BEQL
    | inverse_branch BLTZL= BGEZL
    | inverse_branch BLEZL= BGTZL
    | inverse_branch BGTZL= BLEZL
    | inverse_branch BGEZL= BLTZL
    | inverse_branch BEQL = BNEL
    | inverse_branch BA = Crash.impossible "inverse_branch BA"

  val all_windowed_regs =
    Set.list_to_set []

  val null_result = (Set.empty_set,Set.empty_set,Set.empty_set,Set.empty_set)

  fun double_funary funary =
    case funary of
      MOV_D => true
    | NEG_D => true
    | ABS_D => true
    | _ => false

  fun double_fbinary fbinary =
    case fbinary of
      ADD_D => true
    | DIV_D => true
    | MUL_D => true
    | SUB_D => true
    | _ => false

  fun double_fcmp fcmp =
    case fcmp of
      C_F_D => true
    | C_UN_D => true
    | C_EQ_D => true
    | C_UEQ_D => true
    | C_OLT_D => true
    | C_ULT_D => true
    | C_OLE_D => true
    | C_ULE_D => true
    | C_SF_D  => true
    | C_NGLE_D => true
    | C_SEQ_D => true
    | C_NGL_D => true
    | C_LT_D  => true
    | C_NGE_D => true
    | C_LE_D  => true
    | C_NGT_D => true
    | _ => false

  fun float_reg (double,reg) =
    if double then [reg,MachTypes.next_reg reg]
    else [reg]

  (* This is currently incomplete -- needs more for float operations *)

  fun defines_and_uses(LOAD_AND_STORE(operation, rd, rs1, imm)) =
    let
      val is_nil = rs1 = MachTypes.implicit
      val is_stack = rs1 = MachTypes.fp orelse rs1 = MachTypes.sp
      val is_load = 
        case operation of
          SB => false
        | SH => false
        | SW => false
        | SWL => false
        | SWR => false
        | _ => true
      val main_uses = [rs1]
      (* Which component of the store is being modified? *)
      val store =
	if is_nil then MachTypes.nil_v
	else if is_stack then MachTypes.stack
        else MachTypes.heap
      val int_defines = Set.singleton (if is_load then rd else store)
      val int_uses = Set.list_to_set (if is_load then store :: main_uses else rd :: main_uses)
      val fp_defines = if is_load then Set.empty_set else Set.singleton store
      val fp_uses = if is_load then Set.singleton store else Set.empty_set
    in
      (int_defines, int_uses, fp_defines, fp_uses)
    end

  (* Reminder:
   (MTC1, rd, rs, REG _) => MTC1 rd,rs  (* rd processor, rs coprocessor *)
   (MFC1, rd, rs, REG _) => MFC1 rd,rs  (* rd processor, rs coprocessor *)
   (CFC1, rt, rd, REG _) => CFC1 rt,rd  (* rt processor, rd coprocessor *)
   (CTC1, rt, rd, REG _) => CTC1 rt,rd  (* rt processor, rd coprocessor *)
   (LWC1, rd, rs, IMM i) => LWC1 rd,i(rs)
   (SWC1, rd, rs, IMM i) => SWC1 rd,i(rs)
   *)

  | defines_and_uses(LOAD_AND_STORE_FLOAT(operation, rd, rs, reg_or_imm)) =
    (case reg_or_imm of
       REG _ =>
         (case operation of
            MTC1 => (Set.empty_set, Set.singleton rd, Set.singleton rs, Set.empty_set)
          | MFC1 => (Set.singleton rd, Set.empty_set, Set.empty_set, Set.singleton rs)
	  | CFC1 => (Set.singleton rd, Set.empty_set, Set.empty_set, Set.singleton rs)
	  | CTC1 => (Set.empty_set, Set.singleton rd, Set.singleton rs, Set.empty_set)
          | _ => Crash.impossible "defines_and_uses LOAD_AND_STORE_FLOAT reg")
     | IMM _ =>
         let
           val is_nil = rs = MachTypes.implicit
           val is_stack = rs = MachTypes.fp orelse rs = MachTypes.sp
           val store =
             if is_nil then MachTypes.nil_v
             else if is_stack then MachTypes.stack
             else MachTypes.heap
         in
           case operation of
             LWC1 => (Set.empty_set,
                      Set.list_to_set [rs,store],
                      Set.singleton rd,
                      Set.singleton store)
           | SWC1 => (Set.singleton store,
                      Set.singleton rs,
                      Set.singleton store,
                      Set.singleton rd)
           | _ => Crash.impossible "defines_and_uses LOAD_AND_STORE_FLOAT imm"
         end)
  | defines_and_uses(ARITHMETIC_AND_LOGICAL(opcode, rd, rs1, reg_or_imm)) =
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
     (* If either stack register used then treat this as updating the stack *)
     (* This prevents stack stores and loads being moved across *)
      (* This is a gross hack and should be done properly sometime *)
      val stack_used = 
        rs1 = MachTypes.fp orelse rs2 = MachTypes.fp orelse
        rs1 = MachTypes.sp orelse rs2 = MachTypes.sp
      (* The exception raising operations use the handler register *)
      val handler_regs = 
        case opcode of
          ADD => [Mips_Opcodes.MachTypes.handler]
        | ADDI => [Mips_Opcodes.MachTypes.handler]
        | SUB => [Mips_Opcodes.MachTypes.handler]
        | _ => []
    in
      (if stack_used then Set.list_to_set [rd,MachTypes.stack] else Set.singleton rd,
       Set.list_to_set(handler_regs @@ [rs1, rs2]),
       Set.empty_set,
       Set.empty_set)
    end
  | defines_and_uses(SPECIAL_ARITHMETIC (opcode, rd, reg_or_imm,rs1)) = 
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
      (* Just in case *)
      val stack_used = 
        rs1 = MachTypes.fp orelse rs2 = MachTypes.fp orelse
        rs1 = MachTypes.sp orelse rs2 = MachTypes.sp
    in
      (if stack_used then Set.list_to_set [rd,MachTypes.stack] else Set.singleton rd,
       Set.list_to_set[rs1, rs2],
       Set.empty_set,
       Set.empty_set)
    end
  | defines_and_uses(MULT_AND_DIV (_,r1,r2)) = 
    (Set.singleton MachTypes.mult_result,
     Set.list_to_set [r1,r2],
     Set.empty_set,
     Set.empty_set)
  | defines_and_uses(MULT_AND_DIV_RESULT (_,r)) = 
     (Set.singleton r,
      Set.singleton MachTypes.mult_result,
      Set.empty_set,
      Set.empty_set)
  | defines_and_uses(SETHI(_, rd, i)) =
    (Set.singleton rd, Set.empty_set,Set.empty_set, Set.empty_set)
  | defines_and_uses(BRANCH(branch,rs1,rs2,i)) =
    (Set.empty_set,
     Set.list_to_set [rs1,rs2],
     Set.empty_set, Set.empty_set)
  | defines_and_uses(FIXED_BRANCH(branch,rs1,rs2,i)) =
    (Set.empty_set,
     Set.list_to_set [rs1,rs2],
     Set.empty_set, Set.empty_set)
  | defines_and_uses(CALL (_,reg,_,_)) =
    (Set.singleton MachTypes.lr, Set.singleton reg,
     Set.empty_set, Set.empty_set)
  | defines_and_uses(JUMP(jump,reg_or_imm, rs1,_)) =
    (case reg_or_imm of
       REG reg =>
         (case jump of
            JR => (Set.empty_set,Set.singleton reg,Set.empty_set,Set.empty_set)
          | JALR => (Set.singleton reg,Set.singleton rs1,Set.empty_set,Set.empty_set)
          | _ => Crash.impossible "defines_and_uses JUMP reg")
     | IMM imm =>
         (case jump of
            JAL => (Set.singleton MachTypes.lr,Set.empty_set,Set.empty_set,Set.empty_set)
          | J => (Set.empty_set,Set.empty_set,Set.empty_set,Set.empty_set)
          | _ => Crash.impossible "defines_and_uses JUMP imm"))

  | defines_and_uses(FBRANCH(fbranch,imm)) =
    (Set.empty_set,Set.empty_set,Set.empty_set,Set.singleton MachTypes.cond)

  (* CVT_fmt1_fmt2 converts _from_ fmt2 _to_ fmt1 *)
  | defines_and_uses(CONV_OP(conv_op, rd, rs)) =
    (case conv_op of
       CVT_S_D => (Set.empty_set,Set.empty_set,Set.singleton rd,Set.list_to_set (float_reg (true,rs)))
     | CVT_S_W => (Set.empty_set,Set.empty_set,Set.singleton rd,Set.singleton rs)
     | CVT_D_W => (Set.empty_set,Set.empty_set,Set.list_to_set (float_reg (true,rd)),Set.singleton rs)
     | CVT_D_S => (Set.empty_set,Set.empty_set,Set.list_to_set (float_reg (true,rd)),Set.singleton rs)
     | CVT_W_D => (Set.empty_set,Set.empty_set,Set.singleton rd,Set.list_to_set (float_reg (true,rs)))
     | CVT_W_S => (Set.empty_set,Set.empty_set,Set.singleton rd,Set.singleton rs))

  | defines_and_uses(FUNARY(funary, rd, rs2)) = 
    let
      val double = double_funary funary
    in
      (Set.empty_set,
       Set.empty_set,
       Set.list_to_set (float_reg (double,rd)),
       Set.list_to_set (float_reg (double,rs2)))
    end

  | defines_and_uses(FBINARY(fbinary, rd, rs1, rs2)) = 
    let
      val double = double_fbinary fbinary
    in
      (Set.empty_set,
       Set.empty_set,
       Set.list_to_set (float_reg (double,rd)),
       Set.list_to_set (float_reg (double,rs1) @@ float_reg (double,rs2)))
    end

  | defines_and_uses(FCMP (fcmp,rs1,rs2)) =
    let
      val double = double_fcmp fcmp
    in
      (Set.empty_set,
       Set.empty_set,
       Set.singleton MachTypes.cond,
       Set.list_to_set (float_reg (double,rs1) @@ float_reg (double,rs2)))
    end

  | defines_and_uses(OFFSET _) = null_result

  | defines_and_uses (LOAD_OFFSET (_,reg,_)) =
    (Set.singleton reg,Set.empty_set,Set.empty_set,Set.empty_set)

  | defines_and_uses (SPECIAL_LOAD_OFFSET (_,rd,rs,_)) =
    (Set.singleton rd,Set.singleton rs,Set.empty_set,Set.empty_set)

  (* A hack to remove references to the zero register *)
  val defines_and_uses =
    fn opcode =>
    let 
      val (int_defines,int_uses,fp_defines,fp_uses) = defines_and_uses opcode
    in
      (Set.setdiff (int_defines,Set.singleton MachTypes.R0),
       Set.setdiff (int_uses,Set.singleton MachTypes.R0),
       fp_defines,
       fp_uses)
    end
    
  val nop_code = ARITHMETIC_AND_LOGICAL(SLL, MachTypes.R0, MachTypes.R0, IMM 0)
  (* Used for tracing *)
  val trace_nop_code = ARITHMETIC_AND_LOGICAL(SRL, MachTypes.R0, MachTypes.R0, IMM 0)
  (* Used for nops we don't want rescheduled *)
  val other_nop_code = ARITHMETIC_AND_LOGICAL(SRA, MachTypes.R0, MachTypes.R0, IMM 0)

  val nop = (nop_code, NONE, "")
  fun nopc comment = (nop_code, NONE, comment)
   
end
@


1.30.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 4
 * Revision 1.30  1997/09/19  09:38:48  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
@


1.29
log
@Adding trace_nop_code
@
text
@d9 3
a109 1
require "^.basis.__old";
@


1.29.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a8 3
 * Revision 1.29  1997/01/28  15:04:09  matthew
 * Adding trace_nop_code
 *
@


1.29.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a8 3
 * Revision 1.29  1997/01/28  15:04:09  matthew
 * Adding trace_nop_code
 *
@


1.29.1.1
log
@branched from 1.29
@
text
@a8 3
 * Revision 1.29  1997/01/28  15:04:09  matthew
 * Adding trace_nop_code
 *
@


1.29.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 * Revision 1.29.1.1  1997/05/12  10:37:23  hope
 * branched from 1.29
 *
@


1.29.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 * Revision 1.29.1.1  1997/05/12  10:37:23  hope
 * branched from 1.29
 *
@


1.29.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 * Revision 1.29.1.1  1997/05/12  10:37:23  hope
 * branched from 1.29
 *
@


1.29.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 * Revision 1.29.1.1.1.1  1997/07/28  18:22:37  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.28
log
@Adding MULT operations for defines_and_uses etc.
@
text
@d9 3
d1265 5
a1272 1
  val other_nop_code = ARITHMETIC_AND_LOGICAL(SRL, MachTypes.R0, MachTypes.R0, IMM 0)
@


1.27
log
@Case for BEQZ & BNEZ in inverse_branch
@
text
@d9 3
d1162 10
a1171 2
  | defines_and_uses(MULT_AND_DIV _) = Crash.impossible"defines_and_uses:MULT_AND_DIV"
  | defines_and_uses(MULT_AND_DIV_RESULT _) = Crash.impossible"defines_and_uses:MULT_AND_DIV_RESULT"
@


1.26
log
@[Bug #1728]
__integer becomes __int
@
text
@d9 4
d995 1
a995 1
    | inverse_branch BEQZ = Crash.impossible "inverse of BEQZ failed"
d997 1
a997 1
    | inverse_branch BNEZ = Crash.impossible "inverse of BNEZ failed"
@


1.26.4.1
log
@branched from 1.26
@
text
@a8 4
 * Revision 1.26  1996/11/06  11:11:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.26.3.1
log
@branched from 1.26
@
text
@a8 4
 * Revision 1.26  1996/11/06  11:11:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.26.3.1.1.1
log
@branched from 1.26.3.1
@
text
@a8 3
 * Revision 1.26.3.1  1996/12/17  17:50:42  hope
 * branched from 1.26
 *
@


1.26.2.1
log
@branched from 1.26
@
text
@a8 4
 * Revision 1.26  1996/11/06  11:11:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.26.1.1
log
@branched from 1.26
@
text
@a8 4
 * Revision 1.26  1996/11/06  11:11:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.26.1.1.1.1
log
@branched from 1.26.1.1
@
text
@a8 3
 * Revision 1.26.1.1  1996/11/14  12:53:13  hope
 * branched from 1.26
 *
@


1.25
log
@moving String from toplevel
@
text
@d9 3
d95 1
a95 1
require "../basis/__integer";
@


1.24
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d9 6
d93 2
d104 1
d721 8
a728 16
  local
    val opwidth = 9
    fun make_spaces (string, n) = let
      fun mk(0, acc) = acc 
	| mk(n, acc) = mk( n-1, " " :: acc)
    in
      String.implode(string :: mk(n, []))
    end
  in  
    fun pad columns x =
      if size x < columns then 
	make_spaces(x, columns - size x)
      else x ^ " "
    
    val padit = pad opwidth
  end (* local *)
d807 1
a807 1
	String.implode [
d817 1
a817 1
	  String.implode [
d821 1
a821 1
       else String.implode [
d828 1
a828 1
        String.implode ["move   ",
d832 1
a832 1
        String.implode ["li     ",
d837 1
a837 1
	String.implode [
d843 1
a843 1
	String.implode [
d848 1
a848 1
	String.implode [
d853 1
a853 1
	String.implode [
d858 1
a858 1
	String.implode [
d863 1
a863 1
	String.implode [
d875 1
a875 1
	String.implode [
d880 1
a880 1
	String.implode [
d892 1
a892 1
	String.implode [
d898 1
a898 1
	String.implode [
d902 1
a902 1
	String.implode [
d907 1
a907 1
	String.implode [
d912 1
a912 1
	String.implode [
d916 1
a916 1
	String.implode [
d921 1
a921 1
	String.implode [
d926 1
a926 1
	String.implode [
d932 1
a932 1
	String.implode [
d938 1
a938 1
	String.implode [
d952 1
a952 1
        MLWorks.Option.SOME labelstring => (labelstring ^ ":", line)
d960 3
a962 3
    fun hexchar a = String.chr (if a < 10 then a + String.ord ("0") else a + String.ord "a" - 10);
    fun char2_2hex ch = hexchar ((String.ord ch) div 16) ^ hexchar ((String.ord ch) mod 16);
    fun string2hex s = String.implode (map char2_2hex (String.explode s))
d1244 2
a1245 2
  val nop = (nop_code, MLWorks.Option.NONE, "")
  fun nopc comment = (nop_code, MLWorks.Option.NONE, comment)
@


1.24.3.1
log
@branched from 1.24
@
text
@a8 6
 * Revision 1.24  1996/05/01  12:03:27  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.24.2.1
log
@branched from 1.24
@
text
@a8 6
 * Revision 1.24  1996/05/01  12:03:27  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.24.1.1
log
@branched from 1.24
@
text
@a8 6
 * Revision 1.24  1996/05/01  12:03:27  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.23
log
@Removing MLWorks.Integer
@
text
@d9 3
d718 1
a718 1
      implode(string :: mk(n, []))
d806 1
a806 1
	implode [
d816 1
a816 1
	  implode [
d820 1
a820 1
       else implode [
d827 1
a827 1
        implode ["move   ",
d831 1
a831 1
        implode ["li     ",
d836 1
a836 1
	implode [
d842 1
a842 1
	implode [
d847 1
a847 1
	implode [
d852 1
a852 1
	implode [
d857 1
a857 1
	implode [
d862 1
a862 1
	implode [
d874 1
a874 1
	implode [
d879 1
a879 1
	implode [
d891 1
a891 1
	implode [
d897 1
a897 1
	implode [
d901 1
a901 1
	implode [
d906 1
a906 1
	implode [
d911 1
a911 1
	implode [
d915 1
a915 1
	implode [
d920 1
a920 1
	implode [
d925 1
a925 1
	implode [
d931 1
a931 1
	implode [
d937 1
a937 1
	implode [
d959 3
a961 3
    fun hexchar a = chr (if a < 10 then a + ord ("0") else a + ord "a" - 10);
    fun char2_2hex ch = hexchar ((ord ch) div 16) ^ hexchar ((ord ch) mod 16);
    fun string2hex s = implode (map char2_2hex (explode s))
@


1.22
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d9 4
d83 2
d727 1
a727 1
    | decode_reg_or_imm(IMM i) = "#" ^ MLWorks.Integer.makestring i
d730 1
a730 1
    | decode_reg_or_imm_nohash(IMM i) = MLWorks.Integer.makestring i
d745 1
a745 1
      fun print_label i = "L" ^ MLWorks.Integer.makestring i
d798 1
a798 1
    handle Map.Undefined => "<Undefined:" ^ MLWorks.Integer.makestring index ^ ">"
d806 1
a806 1
		 MLWorks.Integer.makestring imm,
d852 1
a852 1
		 MLWorks.Integer.makestring (if imm < 0 then imm+65536 else imm) ]
d932 1
a932 1
    | OFFSET i => "OFFSET " ^ MLWorks.Integer.makestring i
d938 1
a938 1
		 MLWorks.Integer.makestring i ]
@


1.21
log
@Add a fixed branch type which can't be expanded beyond the 16 bit limit
This can be used to detect disastrous code generation in computed gotos
If this ever occurs, we can then fix the bug
@
text
@d9 5
d1234 2
a1235 2
  val nop = (nop_code, MirTypes.Option.ABSENT, "")
  fun nopc comment = (nop_code, MirTypes.Option.ABSENT, comment)
@


1.20
log
@No reason?
@
text
@d9 3
d278 1
d569 21
d755 1
d859 17
d1142 4
@


1.19
log
@adding beqz
@
text
@d9 3
d549 1
a550 1
        | BEQZ => (5, rVal rs,      0) (* beq lhs zero *)
@


1.18
log
@add BNEZ and R4k branch likely instrs eg bnel bltzl blezl bgtzl bgezl beql
@
text
@d9 3
d163 1
d345 1
d547 1
d910 1
d912 1
a912 1
    | reverse_branch BNEZ = BNEZ
d914 3
a916 3
    | reverse_branch BLEZ = BGEZ
    | reverse_branch BGTZ = BLTZ
    | reverse_branch BLTZ = BGTZ
d927 1
@


1.17
log
@Fixing problem with handler register
@
text
@d9 3
d160 1
d164 8
a171 1
    BGEZ
d341 1
d346 7
d492 1
d494 2
a495 1

d542 1
d546 7
a552 1
	| BGEZ=> (1, rVal rs,       1) (* why rt = 1? *)
d905 1
d911 7
d921 1
d926 6
@


1.16
log
@Improving debugger annotations
@
text
@d9 3
d1012 7
d1021 1
a1021 1
       Set.list_to_set[rs1, rs2],
@


1.15
log
@Make a SUBI turn into an ADDI, not an ADDIU.
@
text
@d9 3
d254 4
a257 3
  | CALL of call * MachTypes.Mips_Reg * int
  | JUMP of jump * reg_or_imm * MachTypes.Mips_Reg
    * MirTypes.Debugger_Types.Backend_Annotation
d525 1
a525 1
    | assemble(CALL(call, rs, imm)) =
d691 1
a691 1
          | CALL (_, _,offset) => add_branch (i,destinations,offset)
d793 1
a793 1
    | CALL(call, reg, imm) =>
d1038 1
a1038 1
  | defines_and_uses(CALL (_,reg,_)) =
@


1.14
log
@args to C.xx wrong way round
added new instrs: CFC1 & CTC1
changed C_DF_D to C_SF_D (misspelling)
@
text
@d9 5
d485 1
a485 1
	    | SUB  => Mips_Opcodes.FORMATI( 9, rs, rd, 65536-imm) (* really an ADDIU *)
@


1.13
log
@Completed defines_and_uses for float operations.
Semi-fixed  problem with stack references not always being through fp and sp.
@
text
@d9 4
d91 3
a93 1
    MFC1
d212 1
a212 1
    C_DF_D  | 
d276 2
d381 1
a381 1
    | decode_fcmp C_DF_D  = "c.df.d "
d415 2
d547 1
d549 1
a549 1
      | CVT_D_S => (33, 0)
a550 1
      | CVT_W_S => (36, 0)
d571 4
a576 4
      | MUL_S => (2, 0)
      | MUL_D => (2, 1)
      | SUB_S => (1, 0)
      | SUB_D => (1, 1)
d581 1
a581 1
    | assemble(FCMP(fcmp, ft, fs)) =
d607 1
a607 1
      | C_DF_D   => (1, 56)
d726 2
a727 3
       if (load_and_store_float = MTC1)
	 orelse (load_and_store_float = MFC1) then
	 implode [
d863 3
a865 3
  fun reverse_branch BEQ = BEQ (*to compare arithmetic quantities in reversed order*)
    | reverse_branch BNE = BNE
    | reverse_branch BA = BA
d871 2
a872 2
  fun inverse_branch BEQ = BNE(*to handle control flow alterations*)
    | inverse_branch BNE = BEQ
d909 1
a909 1
    | C_DF_D  => true
d954 2
d964 4
a967 2
            MTC1 => (Set.empty_set,Set.singleton rd,Set.singleton rs,Set.empty_set)
          | MFC1 => (Set.singleton rd,Set.empty_set,Set.empty_set,Set.singleton rs)
@


1.12
log
@Started implementing defines_and_uses.
This is not complete for floats.
\nImproved printing a bit.
@
text
@d9 5
d517 2
d521 2
d875 39
d919 9
a927 9
      val is_stack = rs1 = MachTypes.fp
      val is_heap = (not is_nil) andalso (not is_stack)
      val is_load = case operation of
	SB => false
      | SH => false
      | SW => false
      | SWL => false
      | SWR => false
      | _ => true
d929 1
d932 3
a934 4
	else
	  if is_stack then MachTypes.stack
	  else MachTypes.heap
      val int_defines = Set.list_to_set (if is_load then [rd] else [store])
d941 35
a975 32
       
  | defines_and_uses(LOAD_AND_STORE_FLOAT(operation, rd, rs1, reg_or_imm)) =
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
      val is_nil = rs1 = MachTypes.implicit orelse rs2 = MachTypes.implicit
      val is_stack = rs1 = MachTypes.fp orelse rs2 = MachTypes.fp
      val is_heap = (not is_nil) andalso (not is_stack)
      val is_load = case operation of
	LWC1 => true
      | _ => false
      val store =
	if is_nil then MachTypes.nil_v
	else
	  if is_stack then MachTypes.stack
	  else MachTypes.heap
      val main_uses =
	if is_load then
	  Set.list_to_set[store, rs1, rs2]
	else
	  Set.list_to_set[rs1, rs2]
      val int_defines = if is_load then Set.empty_set else Set.singleton store
      val int_uses = main_uses
      val fp_defines = Set.singleton(if is_load then rd else store)
      val fp_uses = Set.singleton(if is_load then store else rd)
    in
      (int_defines,
       int_uses,
       fp_defines,
       fp_uses)
    end
d981 6
d988 1
a988 1
      (Set.singleton rd,
d998 4
d1003 1
a1003 1
      (Set.singleton rd,
d1020 26
d1047 1
a1047 5
      val do_link = 
        case jump of
          JALR => true
        | JAL => true
        | _ => false
d1049 4
a1052 8
      if do_link then
        case reg_or_imm of
          REG rd => (Set.singleton rd,Set.singleton rs1,Set.empty_set,Set.empty_set)
        | _ => Crash.impossible "Linked jump with no link register"
      else
        case reg_or_imm of
          REG rs2 => (Set.empty_set,Set.list_to_set [rs2,rs2],Set.empty_set,Set.empty_set)
        | _ => (Set.empty_set,Set.singleton rs1,Set.empty_set,Set.empty_set)
d1054 1
a1054 7
  (* Floats need some more work -- double operations define and use pairs of registers *)
  | defines_and_uses(FBRANCH(fbranch,imm)) =
    (Set.empty_set,Set.empty_set,Set.empty_set,Set.singleton MachTypes.cond)
  | defines_and_uses(CONV_OP(conv_op, rd, rs2)) =
    (Set.empty_set,Set.empty_set, Set.singleton rd,Set.singleton rs2)
  | defines_and_uses(FUNARY(funary, rd, rs2)) = 
    (Set.empty_set,Set.empty_set,Set.singleton rd,Set.singleton rs2)
d1056 9
a1064 1
    (Set.empty_set,Set.empty_set,Set.singleton rd,Set.list_to_set [rs1,rs2])
d1066 9
a1074 1
    (Set.empty_set,Set.empty_set,Set.singleton MachTypes.cond,Set.list_to_set [rs1,rs2])
d1076 1
d1079 1
@


1.11
log
@Corrected label printing and improved code.
Print moves and lis as moves and lis.
@
text
@d9 4
d318 22
a339 22
  fun decode_conv_op CVT_S_D = "cvt_s_d "
    | decode_conv_op CVT_S_W = "cvt_s_w "
    | decode_conv_op CVT_D_W = "cvt_d_w "
    | decode_conv_op CVT_D_S = "cvt_d_s "
    | decode_conv_op CVT_W_D = "cvt_w_d "
    | decode_conv_op CVT_W_S = "cvt_w_s "

  fun decode_funary MOV_S = "mov_s  "
    | decode_funary MOV_D = "mov_d  "
    | decode_funary NEG_S = "neg_s  "
    | decode_funary NEG_D = "neg_d  "
    | decode_funary ABS_S = "abs_s  "
    | decode_funary ABS_D = "abs_d  "

  fun decode_fbinary ADD_D = "add_d  "
    | decode_fbinary ADD_S = "add_s  "
    | decode_fbinary DIV_D = "div_d  "
    | decode_fbinary DIV_S = "div_s  "
    | decode_fbinary MUL_D = "mul_d  "
    | decode_fbinary MUL_S = "mul_s  "
    | decode_fbinary SUB_D = "sub_d  "
    | decode_fbinary SUB_S = "sub_s  "
d344 32
a375 32
  fun decode_fcmp C_F_S   = "c_s_f  "
    | decode_fcmp C_UN_S  = "c_un_s "
    | decode_fcmp C_EQ_S  = "c_eq_s "
    | decode_fcmp C_UEQ_S = "c_ueq_s "
    | decode_fcmp C_OLT_S = "c_olt_s "
    | decode_fcmp C_ULT_S = "c_ult_s "
    | decode_fcmp C_OLE_S = "c_ole_s "
    | decode_fcmp C_ULE_S = "c_ule_s "
    | decode_fcmp C_SF_S  = "c_sf_s "
    | decode_fcmp C_NGLE_S= "c_ngle_s "
    | decode_fcmp C_SEQ_S = "c_seq_s "
    | decode_fcmp C_NGL_S = "c_ngl_s "
    | decode_fcmp C_LT_S  = "c_lt_s "
    | decode_fcmp C_NGE_S = "c_nge_s "
    | decode_fcmp C_LE_S  = "c_le_s "
    | decode_fcmp C_NGT_S = "c_ngt_s "
    | decode_fcmp C_F_D   = "c_f_d  "
    | decode_fcmp C_UN_D  = "c_un_d "
    | decode_fcmp C_EQ_D  = "c_eq_d "
    | decode_fcmp C_UEQ_D = "c_ueq_d "
    | decode_fcmp C_OLT_D = "c_olt_d "
    | decode_fcmp C_ULT_D = "c_ult_d "
    | decode_fcmp C_OLE_D = "c_ole_d "
    | decode_fcmp C_ULE_D = "c_ule_d "
    | decode_fcmp C_DF_D  = "c_df_d "
    | decode_fcmp C_NGLE_D= "c_ngle_d "
    | decode_fcmp C_SEQ_D = "c_seq_d "
    | decode_fcmp C_NGL_D = "c_ngl_d "
    | decode_fcmp C_LT_D  = "c_lt_d "
    | decode_fcmp C_NGE_D = "c_nge_d "
    | decode_fcmp C_LE_D  = "c_le_d "
    | decode_fcmp C_NGT_D= "c_ngt_d "
d522 2
a523 2
    | assemble(FBRANCH(BC1T, imm)) = Mips_Opcodes.FORMATI2(17, 0, 1, imm)
    | assemble(FBRANCH(BC1F, imm)) = Mips_Opcodes.FORMATI2(17, 0, 0, imm)
d714 1
d716 2
a717 2
		     decode_reg_or_imm_nohash reg_or_imm, "[ ,",
		     MachTypes.reg_to_string reg2, "]"]
d723 1
a723 1
    | ARITHMETIC_AND_LOGICAL(ORI, reg1, MachTypes.R0, imm) => 
d864 5
a868 5
  fun defines_and_uses _ =
    (Set.list_to_set [], Set.list_to_set [], Set.list_to_set [], Set.list_to_set [])
(* let's leave this stuff out for the moment *)
(*
  fun defines_and_uses(LOAD_AND_STORE(operation, rd, rs1, reg_or_imm)) =
d870 2
a871 5
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
      val is_nil = rs1 = MachTypes.G5 orelse rs2 = MachTypes.G5
      val is_stack = rs1 = MachTypes.I6 orelse rs2 = MachTypes.I6
d874 5
a878 4
	STB => false
      | STH => false
      | ST => false
      | STD => false
d880 1
a880 5
      val next_reg = case operation of
	STD => true
      | LDD => true
      | _ => false
      val main_uses = [rs1, rs2]
d886 4
d891 1
a891 12
      (Set.list_to_set
       (if is_load then
	  if next_reg then [rd, MachTypes.next_reg rd] else [rd]
	else [store]),
	  Set.list_to_set
	  (if is_load then
	     store :: main_uses
	   else
	     if next_reg then rd :: MachTypes.next_reg rd :: main_uses
	     else rd :: main_uses),
	  if is_load then Set.empty_set else Set.singleton store,
	    if is_load then Set.singleton store else Set.empty_set)
d893 2
a894 2
  | defines_and_uses(LOAD_AND_STORE_FLOAT(operation, rd, rs1,
							 reg_or_imm)) =
d899 2
a900 2
      val is_nil = rs1 = MachTypes.G5 orelse rs2 = MachTypes.G5
      val is_stack = rs1 = MachTypes.I6 orelse rs2 = MachTypes.I6
d903 2
a904 3
	STF => false
      | STDF => false
      | _ => true
d915 4
a918 37
    in
      (if is_load then Set.empty_set else Set.singleton store,
	 main_uses,
	 Set.singleton(if is_load then rd else store),
	 Set.singleton(if is_load then store else rd))
    end
  | defines_and_uses(ARITHMETIC_AND_LOGICAL(opcode, rd, reg_or_imm, rs1)) =
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
      val (defines_cond, uses_cond) =
	case opcode of
	  ADD => (false, false)
	| ADDCC => (true, false)
	| ADDX => (false, true)
	| ADDXCC => (true, true)
	| SUB => (false, false)
	| SUBCC => (true, false)
	| SUBX => (false, true)
	| SUBXCC => (true, true)
	| AND => (false, false)
	| ANDCC => (true, false)
	| ANDN => (false, false)
	| ANDNCC => (true, false)
	| OR => (false, false)
	| ORCC => (true, false)
	| ORN => (false, false)
	| ORNCC => (true, false)
	| XOR => (false, false)
	| XORCC => (true, false)
	| XORN => (false, false)
	| XORNCC => (true, false)
	| SLL => (false, false)
	| SRL => (false, false)
	| SRA => (false, false)

d920 4
a923 5
      (if defines_cond then Set.list_to_set[MachTypes.cond, rd]
       else Set.singleton rd,
	 if uses_cond then Set.list_to_set[MachTypes.cond, rs1, rs2]
	 else Set.list_to_set[rs1, rs2],
       Set.empty_set, Set.empty_set)
d925 1
a925 2
  | defines_and_uses(TAGGED_ARITHMETIC(_, rd, reg_or_imm,
						      rs1)) =
d931 4
a934 2
      (Set.list_to_set[MachTypes.cond, rd], Set.list_to_set[rs1, rs2],
       Set.empty_set, Set.empty_set)
d936 1
a936 4
  | defines_and_uses(SetHI(_, rd, i)) =
    (Set.singleton rd, Set.empty_set,
       Set.empty_set, Set.empty_set)
  | defines_and_uses(SAVE_AND_RESTORE(_, rd, reg_or_imm, rs1)) =
d942 10
a951 5
      (Set.add_member(rd, all_windowed_regs),
       Set.add_member(rs1, Set.add_member(rs2, all_windowed_regs)),
       Set.empty_set, Set.empty_set)
    end
  | defines_and_uses(BRANCH(branch, _)) =
d953 4
a956 14
      (case branch of
	BA => Set.empty_set
      | BN => Set.empty_set
      | _ => Set.singleton MachTypes.cond),
	 Set.empty_set, Set.empty_set)
  | defines_and_uses(BRANCH_ANNUL(branch, _)) =
    (Set.empty_set,
      (case branch of
	BA => Set.empty_set
      | BN => Set.empty_set
      | _ => Set.singleton MachTypes.cond),
       Set.empty_set, Set.empty_set)
  | defines_and_uses(Call _) =
    (Set.singleton MachTypes.lr, Set.empty_set,
d958 1
a958 1
  | defines_and_uses(JUMP(_, rd, reg_or_imm, rs1,_)) =
d960 5
a964 3
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
d966 12
a977 19
      (Set.singleton rd, Set.list_to_set[rs1, rs2],
       Set.empty_set, Set.empty_set)
    end
  | defines_and_uses(FBRANCH(fbranch, _)) =
    (Set.empty_set,
     Set.empty_set,
     Set.empty_set,
      (case fbranch of
	FBA => Set.empty_set
      | FBN => Set.empty_set
      | _ => Set.singleton MachTypes.cond))
  | defines_and_uses(FBRANCH_ANNUL(fbranch, _)) =
    (Set.empty_set,
     Set.empty_set,
     Set.empty_set,
      (case fbranch of
	FBA => Set.empty_set
      | FBN => Set.empty_set
      | _ => Set.singleton MachTypes.cond))
d979 18
a996 8
	(Set.empty_set, Set.empty_set, Set.singleton rd, Set.singleton rs2)
  | defines_and_uses(FUNARY(funary, rd, rs2)) =
    let
      val defines_cond = case funary of
	FCMPS => true
      | FCMPD => true
      | FCMPX => true
      | _ => false
d998 4
a1001 3
      (Set.empty_set, Set.empty_set,
       Set.singleton(if defines_cond then MachTypes.cond else rd),
       if defines_cond then Set.list_to_set[rd, rs2] else Set.singleton rs2)
d1003 1
a1003 6
  | defines_and_uses(FBINARY(fbinary, rd, rs1, rs2)) =
    (Set.empty_set, Set.empty_set, Set.singleton rd,
     Set.list_to_set[rs1, rs2])
  | defines_and_uses(SPECIAL_ARITHMETIC _) = Crash.impossible"defines_and_uses"
*)

@


1.10
log
@Fix backwards encoding of register controlled shifts
@
text
@d9 3
d217 4
a220 4
    LOAD_AND_STORE of load_and_store * MachTypes.Mips_Reg 
    * MachTypes.Mips_Reg * int
  | LOAD_AND_STORE_FLOAT of load_and_store_float * MachTypes.Mips_Reg 
    * MachTypes.Mips_Reg * reg_or_imm
d222 1
a222 2
    arithmetic_and_logical * MachTypes.Mips_Reg
    * MachTypes.Mips_Reg * reg_or_imm
d626 19
a644 15
  fun make_labmap_from_list l = let
    fun remove_duplicates ([], acc) = acc
      | remove_duplicates ([a], acc) = a::acc
      | remove_duplicates (a::(rest as (b :: c)), acc) = 
	if a = b then
	  remove_duplicates (a::c,acc)
	else remove_duplicates (rest, a::acc)
    val sorted = rev (remove_duplicates (Lists.qsort (op <) l, []))
    fun print_label i = "L" ^ MLWorks.Integer.makestring i
    val (labmap,_) = Lists.reducel 
      (fn ((map,n),m) => (Map.define (map,m,print_label n),n+1))
      ((Map.empty, 0), sorted)
  in 
    labmap
  end
d648 18
a665 2
    fun add_branch (i, (n,labs)) = (n+1, (i+n+1) :: labs) 
(* +1 because offsets are from the subsequent in str *)
a666 4
    fun get_lab (w, BRANCH(_, _, _, i)) = add_branch(i, w)
      | get_lab (w, FBRANCH(_, i)) = add_branch(i,w)
      | get_lab (w, CALL(_, _,i)) = add_branch(i,w)
      | get_lab ((n,labs),_) = (n+1, labs)
d668 16
a683 11

(* The didling with +- 2 is to cope with backptr slots *)
    fun make_labmap (codelistlist) = let
      val (_,lablist) = Lists.reducel (fn ((n,acc),codelist) => 
	(Lists.reducel
	 (fn ((n,acc),code) => Lists.reducel get_lab ((n+2,acc),code))
	 ((n-2,acc),codelist)))
	((0,[]),codelistlist)
    in
      make_labmap_from_list lablist
    end (* make_labmap *)
d691 1
a691 1
  fun really_print (opcode,n,labmap) = 
d714 9
d813 2
a814 2
    | SPECIAL_ARITHMETIC _ => Crash.impossible "really_print SPECIAL_ARITHMETIC"
    | SPECIAL_LOAD_OFFSET _ => Crash.impossible"really_print SPECIAL_LOAD_OFFSET"
d816 9
a824 9

(* labprint: prettyprints output with assembler labels *)
  fun labprint (args as (_, n, labmap)) = let
    val line = really_print args
  in
    case Map.tryApply' (labmap, n) of
      Map.YES s => (s ^ ":", line)
      | _       => (""     , line)
  end
d836 1
a836 1
	^ " " ^ really_print(instr,0,Map.empty)
d1053 2
a1054 4
  val nop_code =
    ARITHMETIC_AND_LOGICAL(SLL, MachTypes.R0, MachTypes.R0, IMM 0) (*0x0000*)
    (* ARITHMETIC_AND_LOGICAL(AND, MachTypes.G0, IMM 0, MachTypes.G0) *)
  val nop = (nop_code, MirTypes.Option.ABSENT, "Delay slot")
d1057 1
a1057 2
  val other_nop_code =
    ARITHMETIC_AND_LOGICAL(SRL, MachTypes.R0, MachTypes.R0, IMM 0) (*0x0002*)
@


1.9
log
@SRL wrong way round
@
text
@d9 3
d412 18
a429 17
	   let val op2 = case arithmetic_and_logical of
	     ADD  => 32
	   | ADDU => 33
	   | SUB  => 34
	   | SUBU => 35
	   | AND  => 36
	   | OR   => 37
	   | XOR  => 38
	   | NOR  => 39
	   | SLT  => 42
	   | SLTU => 43
	   | SLLV =>  4
	   | SLL  =>  4 (* really an SLLV *)
	   | SRAV =>  7
	   | SRA  =>  7 (* really an SRAV *)
	   | SRLV =>  6
	   | SRL  =>  6 (* really an SRLV *)
@


1.8
log
@adding comment to nop code
@
text
@d9 3
d432 7
d444 1
@


1.7
log
@adding labels and other cleanups
@
text
@d9 3
d1010 2
a1011 1

@


1.6
log
@Adding support for load offset
@
text
@d9 3
d27 3
d36 2
d463 11
a473 10
      Mips_Opcodes.FORMATI2(15, 0, Mips_Opcodes.register_val rt, imm)
    | assemble(BRANCH(branch, rs, rt, imm)) =
      let val (op1, op2) = (case branch of
			      BA  => (4, 0)
			    | BEQ => (4, Mips_Opcodes.register_val rt)
			    | BNE => (5, Mips_Opcodes.register_val rt)
			    | BLEZ=> (6, 0)
			    | BGTZ=> (7, 0)
			    | BLTZ=> (1, 0)
			    | BGEZ=> (1, 1))
d475 1
a475 1
	Mips_Opcodes.FORMATI2(op1, Mips_Opcodes.register_val rs, op2, imm)
d581 17
d604 175
a778 131
  fun really_print(LOAD_AND_STORE(load_and_store, reg1, reg2, imm)) =
    implode
    [decode_load_and_store load_and_store,
     MachTypes.reg_to_string reg1,   
     ", ",
     MLWorks.Integer.makestring imm, 
     "[",
     MachTypes.reg_to_string reg2,
     "]"]
    | really_print(LOAD_AND_STORE_FLOAT(load_and_store_float, reg1, reg2, reg_or_imm)) =
      implode
      (if (load_and_store_float=MTC1) orelse (load_and_store_float=MFC1) then
	 [decode_load_and_store_float load_and_store_float,
	  MachTypes.reg_to_string reg1,
	  ", ",
	  MachTypes.fp_reg_to_string reg2]
       else
	 [decode_load_and_store_float load_and_store_float,
	  MachTypes.fp_reg_to_string reg1,
	  ", ",
	  decode_reg_or_imm_nohash reg_or_imm,
	  "[",
	  MachTypes.reg_to_string reg2,
	  "]"])
    | really_print(ARITHMETIC_AND_LOGICAL(SLL, MachTypes.R0, MachTypes.R0, IMM 0)) = 
      "nop      "
    | really_print(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical, reg1, reg2, reg_or_imm)) =
      implode
      [decode_arithmetic_and_logical arithmetic_and_logical,
       MachTypes.reg_to_string reg1,
       ", ",
       MachTypes.reg_to_string reg2,
       ", ",
       decode_reg_or_imm reg_or_imm]
    | really_print(MULT_AND_DIV(mult_and_div, reg1, reg2)) =
      implode
      [decode_mult_and_div mult_and_div,
       MachTypes.reg_to_string reg1,
       ", ",
       MachTypes.reg_to_string reg2]
    | really_print(MULT_AND_DIV_RESULT(mult_and_div_result, reg)) =
      implode
      [decode_mult_and_div_result mult_and_div_result,
       MachTypes.reg_to_string reg]
    | really_print(SETHI(sethi, reg, imm)) =
      implode
      [decode_sethi sethi,
       MachTypes.reg_to_string reg,
       ", #",
       MLWorks.Integer.makestring (if imm < 0 then imm+65536 else imm)]
    | really_print(BRANCH(BA, _, _, imm)) =
      implode
      [decode_branch BA, 
       MLWorks.Integer.makestring imm]
    | really_print(BRANCH(branch, reg1, reg2, imm)) =
      implode
      [decode_branch branch,
       MachTypes.reg_to_string reg1,
       ", ",
       (case branch of
	  BLTZ => ""
	| BLEZ => ""
	| BGEZ => ""
	| BGTZ => ""
	| _ => MachTypes.reg_to_string reg2 ^ ", "
	    ),
       MLWorks.Integer.makestring imm]
    | really_print(CALL(call, reg, imm)) =
      implode
      [decode_call call,
       MachTypes.reg_to_string reg,
       ", ",
       MLWorks.Integer.makestring imm]
    | really_print(JUMP(JR, REG rd, rs, Annotation)) =
      implode
      [decode_jump JR,
       MachTypes.reg_to_string rd]
    | really_print(JUMP(JALR, REG rd, rs, Annotation)) =
      implode
      [decode_jump JALR,
       MachTypes.reg_to_string rd,
       ", ",
       MachTypes.reg_to_string rs]
    | really_print(JUMP(jump, IMM imm, rs, Annotation)) =
      implode
      [decode_jump jump,
       MLWorks.Integer.makestring imm]
    | really_print(JUMP(_,_,_,_))
      = Crash.impossible "assemble.print JUMP has illegal mode"
    | really_print(FBRANCH(fbranch, imm)) =
      implode
      [decode_fbranch fbranch,
       MLWorks.Integer.makestring imm]
    | really_print(CONV_OP(conv_op, reg1, reg2)) =
      implode
      [decode_conv_op conv_op,
       MachTypes.fp_reg_to_string reg1,
       ", ",
       MachTypes.fp_reg_to_string reg2]
    | really_print(FUNARY(funary, reg1, reg2)) =
      implode
      [decode_funary funary,
       MachTypes.fp_reg_to_string reg1,
       ", ",
       MachTypes.fp_reg_to_string reg2]
    | really_print(FBINARY(fbinary, reg1, reg2, reg3)) =
      implode
      [decode_fbinary fbinary,
       MachTypes.fp_reg_to_string reg1,
       ", ",
       MachTypes.fp_reg_to_string reg2,
       ", ",
       MachTypes.fp_reg_to_string reg3]
    | really_print(FCMP(fcmp, reg1, reg2)) =
      implode
      [decode_fcmp fcmp,
       MachTypes.fp_reg_to_string reg1,
       ", ",
       MachTypes.fp_reg_to_string reg2]
    | really_print(OFFSET i) =
      "OFFSET " ^ MLWorks.Integer.makestring i
    | really_print(LOAD_OFFSET(_, rd, i)) =
      implode
      ["load_offset ",
       MachTypes.reg_to_string rd,
       " plus ",
       MLWorks.Integer.makestring i]
    | really_print(SPECIAL_ARITHMETIC _) =
      Crash.impossible"really_print SPECIAL_ARITHMETIC"
    | really_print(SPECIAL_LOAD_OFFSET _) =
      Crash.impossible"really_print SPECIAL_LOAD_OFFSET"
a782 1
    val print_hex_too = true
d784 6
a789 7
    fun print instr = 
      if print_hex_too then
	string2hex (Mips_Opcodes.output_opcode (assemble instr))
	^ " " ^ (really_print instr) 
      else really_print instr
  end
  
@


1.5
log
@Add an offset opcode for jump tables
@
text
@d9 3
d85 2
d89 4
d193 1
a193 1
    REG of Mips_Opcodes.MachTypes.Mips_Reg |
d197 4
a200 4
    LOAD_AND_STORE of load_and_store * Mips_Opcodes.MachTypes.Mips_Reg 
    * Mips_Opcodes.MachTypes.Mips_Reg * int
  | LOAD_AND_STORE_FLOAT of load_and_store_float * Mips_Opcodes.MachTypes.Mips_Reg 
    * Mips_Opcodes.MachTypes.Mips_Reg * reg_or_imm
d202 2
a203 2
    arithmetic_and_logical * Mips_Opcodes.MachTypes.Mips_Reg
    * Mips_Opcodes.MachTypes.Mips_Reg * reg_or_imm
d207 1
a207 1
    mult_and_div * Mips_Opcodes.MachTypes.Mips_Reg * Mips_Opcodes.MachTypes.Mips_Reg
d209 5
a213 5
    mult_and_div_result * Mips_Opcodes.MachTypes.Mips_Reg
  | SETHI of sethi * Mips_Opcodes.MachTypes.Mips_Reg * int
  | BRANCH of branch * Mips_Opcodes.MachTypes.Mips_Reg * Mips_Opcodes.MachTypes.Mips_Reg * int
  | CALL of call * Mips_Opcodes.MachTypes.Mips_Reg * int
  | JUMP of jump * reg_or_imm * Mips_Opcodes.MachTypes.Mips_Reg
d216 5
a220 5
  | CONV_OP of conv_op * Mips_Opcodes.MachTypes.Mips_Reg * Mips_Opcodes.MachTypes.Mips_Reg
  | FUNARY of funary * Mips_Opcodes.MachTypes.Mips_Reg * Mips_Opcodes.MachTypes.Mips_Reg
  | FBINARY of fbinary * Mips_Opcodes.MachTypes.Mips_Reg * Mips_Opcodes.MachTypes.Mips_Reg *
    Mips_Opcodes.MachTypes.Mips_Reg
  | FCMP of fcmp * Mips_Opcodes.MachTypes.Mips_Reg * Mips_Opcodes.MachTypes.Mips_Reg
d222 2
a566 1
    | assemble(SPECIAL_ARITHMETIC _) = Crash.impossible"assemble"
d568 3
a696 1
    | really_print(SPECIAL_ARITHMETIC _) = Crash.impossible"really_print"
d699 10
a933 68

(* fun post_save_or_restore_reg_or_imm conv_fun =
    let
      fun post(REG r) = REG(conv_fun r)
      | post arg = arg
    in
      post
    end *)
  
(* fun post_save_or_restore(conv_fun, opcode) =
    let
      val post_reg_or_imm = post_save_or_restore_reg_or_imm conv_fun
      fun post(LOAD_AND_STORE(load_and_store, rd, rs1,
			      reg_or_imm)) =
	LOAD_AND_STORE(load_and_store, conv_fun rd,
		       conv_fun rs1,
		       post_reg_or_imm reg_or_imm)
      | post(LOAD_AND_STORE_FLOAT(load_and_store_float, f,
				  rs1, reg_or_imm)) =
	LOAD_AND_STORE_FLOAT(load_and_store_float, f,
			     conv_fun rs1,
			     post_reg_or_imm reg_or_imm)
      | post(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical,
				    rd, reg_or_imm, rs1)) =
	ARITHMETIC_AND_LOGICAL(arithmetic_and_logical,
			       conv_fun rd,
			       post_reg_or_imm reg_or_imm,
			       conv_fun rs1)
      | post(TAGGED_ARITHMETIC(tagged_arithmetic, rd,
			       reg_or_imm, rs1)) =
	TAGGED_ARITHMETIC(tagged_arithmetic,
			  conv_fun rd,
			  post_reg_or_imm reg_or_imm,
			  conv_fun rs1)
      | post(SetHI(sethi, rd, i)) =
	SetHI(sethi, conv_fun rd, i)
      | post(SAVE_AND_RESTORE _) =
	Crash.impossible"post SAVE_AND_RESTORE"
      | post(opcode as BRANCH _) = opcode
      | post(opcode as BRANCH_ANNUL _) = opcode
      | post(opcode as Call _) = opcode
      | post(JUMP_AND_LINK(jump_and_link, rd, reg_or_imm,
			   rs1,debug)) =
	JUMP_AND_LINK(jump_and_link, conv_fun rd,
		      post_reg_or_imm reg_or_imm,
		      conv_fun rs1,debug)
      | post(opcode as FBRANCH _) = opcode
      | post(opcode as FBRANCH_ANNUL _) = opcode
      | post(CONV_OP(conv_op, rd, rs1)) =
	(case conv_op of
	  FITOS => CONV_OP(conv_op, rd, conv_fun rs1)
	| FITOD => CONV_OP(conv_op, rd, conv_fun rs1)
	| FITOX => CONV_OP(conv_op, rd, conv_fun rs1)
	| FSTOI => CONV_OP(conv_op, conv_fun rd, rs1)
	| FDTOI => CONV_OP(conv_op, conv_fun rd, rs1)
	| FXTOI => CONV_OP(conv_op, conv_fun rd, rs1))
      | post(opcode as FUNARY _) = opcode
      | post(opcode as FBINARY _) = opcode
      | post(SPECIAL_ARITHMETIC _) = Crash.impossible"post"
    in
      post opcode
    end *)

(* fun post_restore opcode =
    post_save_or_restore(MachTypes.after_restore, opcode) *)

(*  fun post_save opcode =
    post_save_or_restore(MachTypes.after_preserve, opcode) *)
@


1.4
log
@Fix reverse_branch to handle BGTZ etc
@
text
@d9 3
d212 1
d343 2
d557 1
d685 2
a686 1

@


1.3
log
@Improve code printing readability
@
text
@d9 3
d695 4
a698 4
    | reverse_branch BLEZ = Crash.impossible "reverse_branch BLEZ"
    | reverse_branch BGTZ = Crash.impossible "reverse_branch BGTZ"
    | reverse_branch BLTZ = Crash.impossible "reverse_branch BLTZ"
    | reverse_branch BGEZ = Crash.impossible "reverse_branch BGEZ"
@


1.2
log
@Deleted old SPARC comments and fixed type errors
@
text
@d8 4
a11 1
 $Log$
d207 128
a334 128
  fun decode_load_and_store LB  = "LB     "
    | decode_load_and_store LBU = "LBU    "
    | decode_load_and_store LH  = "LH     "
    | decode_load_and_store LHU = "LHU    "
    | decode_load_and_store LW  = "LW     "
    | decode_load_and_store LWL = "LWL    "
    | decode_load_and_store LWR = "LWR    "
    | decode_load_and_store SB  = "SB     "
    | decode_load_and_store SH  = "SH     "
    | decode_load_and_store SW  = "SW     "
    | decode_load_and_store SWL = "SWL    "
    | decode_load_and_store SWR = "SWR    "

  fun decode_load_and_store_float LWC1 = "LWC1   "
    | decode_load_and_store_float SWC1 = "SWC1   "
    | decode_load_and_store_float MTC1 = "MTC1   "
    | decode_load_and_store_float MFC1 = "MFC1   "

  fun decode_arithmetic_and_logical ADD   = "ADD    "
    | decode_arithmetic_and_logical ADDI  = "ADDI   "
    | decode_arithmetic_and_logical ADDIU = "ADDIU  "
    | decode_arithmetic_and_logical ADDU  = "ADDU   "
    | decode_arithmetic_and_logical SUB   = "SUB    "
    | decode_arithmetic_and_logical SUBU  = "SUBU   "
    | decode_arithmetic_and_logical AND   = "AND    "
    | decode_arithmetic_and_logical ANDI  = "ANDI   "
    | decode_arithmetic_and_logical OR    = "OR     "
    | decode_arithmetic_and_logical ORI   = "ORI    "
    | decode_arithmetic_and_logical XOR   = "XOR    "
    | decode_arithmetic_and_logical XORI  = "XORI   "
    | decode_arithmetic_and_logical NOR   = "NOR    "
    | decode_arithmetic_and_logical SLT   = "SLT    "
    | decode_arithmetic_and_logical SLTU  = "SLTU   "
    | decode_arithmetic_and_logical SLTI  = "SLTI   "
    | decode_arithmetic_and_logical SLTIU = "SLTIU  "
    | decode_arithmetic_and_logical SLL   = "SLL    "
    | decode_arithmetic_and_logical SRL   = "SRL    "
    | decode_arithmetic_and_logical SRA   = "SRA    "
    | decode_arithmetic_and_logical SLLV  = "SLLV   "
    | decode_arithmetic_and_logical SRLV  = "SRLV   "
    | decode_arithmetic_and_logical SRAV  = "SRAV   "

  fun decode_mult_and_div MULT  = "MULT   "
    | decode_mult_and_div MULTU = "MULTU  "
    | decode_mult_and_div DIV   = "DIV    "
    | decode_mult_and_div DIVU  = "DIVU   "

  fun decode_mult_and_div_result MFHI = "MFHI   "
    | decode_mult_and_div_result MFLO = "MFLO   "
    | decode_mult_and_div_result MTHI = "MTHI   "
    | decode_mult_and_div_result MTLO = "MTLO   "

  fun decode_sethi LUI = "LUI    "

  fun decode_branch BA   = "BA     "
    | decode_branch BEQ  = "BEQ    "
    | decode_branch BNE  = "BNE    "
    | decode_branch BLEZ = "BLEZ   "
    | decode_branch BGTZ = "BGTZ   "
    | decode_branch BLTZ = "BLTZ   "
    | decode_branch BGEZ = "BGEZ   "

  fun decode_call BLTZAL = "BLTZAL "
    | decode_call BGEZAL = "BGEZAL "

  fun decode_jump JAL  = "JAL    "
    | decode_jump JALR = "JALR   "
    | decode_jump J    = "J      "
    | decode_jump JR   = "JR     "

  fun decode_conv_op CVT_S_D = "CVT_S_D "
    | decode_conv_op CVT_S_W = "CVT_S_W "
    | decode_conv_op CVT_D_W = "CVT_D_W "
    | decode_conv_op CVT_D_S = "CVT_D_S "
    | decode_conv_op CVT_W_D = "CVT_W_D "
    | decode_conv_op CVT_W_S = "CVT_W_S "

  fun decode_funary MOV_S = "MOV_S  "
    | decode_funary MOV_D = "MOV_D  "
    | decode_funary NEG_S = "NEG_S  "
    | decode_funary NEG_D = "NEG_D  "
    | decode_funary ABS_S = "ABS_S  "
    | decode_funary ABS_D = "ABS_D  "

  fun decode_fbinary ADD_D = "ADD_D  "
    | decode_fbinary ADD_S = "ADD_S  "
    | decode_fbinary DIV_D = "DIV_D  "
    | decode_fbinary DIV_S = "DIV_S  "
    | decode_fbinary MUL_D = "MUL_D  "
    | decode_fbinary MUL_S = "MUL_S  "
    | decode_fbinary SUB_D = "SUB_D  "
    | decode_fbinary SUB_S = "SUB_S  "

  fun decode_fbranch BC1T = "BC1T   "
    | decode_fbranch BC1F = "BC1F   "

  fun decode_fcmp C_F_S   = "C_S_F  "
    | decode_fcmp C_UN_S  = "C_UN_S "
    | decode_fcmp C_EQ_S  = "C_EQ_S "
    | decode_fcmp C_UEQ_S = "C_UEQ_S "
    | decode_fcmp C_OLT_S = "C_OLT_S "
    | decode_fcmp C_ULT_S = "C_ULT_S "
    | decode_fcmp C_OLE_S = "C_OLE_S "
    | decode_fcmp C_ULE_S = "C_ULE_S "
    | decode_fcmp C_SF_S  = "C_SF_S "
    | decode_fcmp C_NGLE_S= "C_NGLE_S "
    | decode_fcmp C_SEQ_S = "C_SEQ_S "
    | decode_fcmp C_NGL_S = "C_NGL_S "
    | decode_fcmp C_LT_S  = "C_LT_S "
    | decode_fcmp C_NGE_S = "C_NGE_S "
    | decode_fcmp C_LE_S  = "C_LE_S "
    | decode_fcmp C_NGT_S = "C_NGT_S "
    | decode_fcmp C_F_D   = "C_F_D  "
    | decode_fcmp C_UN_D  = "C_UN_D "
    | decode_fcmp C_EQ_D  = "C_EQ_D "
    | decode_fcmp C_UEQ_D = "C_UEQ_D "
    | decode_fcmp C_OLT_D = "C_OLT_D "
    | decode_fcmp C_ULT_D = "C_ULT_D "
    | decode_fcmp C_OLE_D = "C_OLE_D "
    | decode_fcmp C_ULE_D = "C_ULE_D "
    | decode_fcmp C_DF_D  = "C_DF_D "
    | decode_fcmp C_NGLE_D= "C_NGLE_D "
    | decode_fcmp C_SEQ_D = "C_SEQ_D "
    | decode_fcmp C_NGL_D = "C_NGL_D "
    | decode_fcmp C_LT_D  = "C_LT_D "
    | decode_fcmp C_NGE_D = "C_NGE_D "
    | decode_fcmp C_LE_D  = "C_LE_D "
    | decode_fcmp C_NGT_D= "C_NGT_D "
d580 1
a580 1
      "NOP      "
d677 1
a677 1
    fun hexchar a = chr (if a < 10 then a + ord ("0") else a + ord "A" - 10);
@


1.1
log
@Initial revision
@
text
@a0 1
(* _mips_assembly.sml the functor *)
d2 1
a2 3
$Log
Copyright (c) 1993 Harlequin Ltd.
*)
d4 6
a9 2
;;; Copyright 1991 Harlequin Ltd.
;;; $Log$
@
