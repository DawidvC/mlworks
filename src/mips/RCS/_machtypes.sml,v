head	1.16;
access;
symbols
	MLW_daveb_inline_1_4_99:1.16.1
	MLWorks_21c0_1999_03_25:1.16
	MLWorks_20c1_1998_08_20:1.16
	MLWorks_20c0_1998_08_04:1.16
	MLWorks_20b2c2_1998_06_19:1.16
	MLWorks_20b2_Windows_1998_06_12:1.16
	MLWorks_20b1c1_1998_05_07:1.16
	MLWorks_20b0_1998_04_07:1.16
	MLWorks_20b0_1998_03_20:1.16
	MLWorks_20m2_1998_02_16:1.16
	MLWorks_20m1_1997_10_23:1.16
	MLWorks_11r1:1.15.1.1.1.1.1
	MLWorks_workspace_97:1.15.3
	MLWorks_dt_wizard:1.15.2
	MLWorks_11c0_1997_09_09:1.15.1.1.1.1
	MLWorks_10r3:1.15.1.1.3
	MLWorks_10r2_551:1.15.1.1.2
	MLWorks_11:1.15.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.1.1
	MLWorks_20m0_1997_06_20:1.15
	MLWorks_1_0_r2c2_1997_06_14:1.15.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.1
	MLWorks_BugFix_1997_04_24:1.15
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.14.3.1.1
	MLWorks_gui_1996_12_18:1.14.4
	MLWorks_1_0_Win32_1996_12_17:1.14.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.14.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.14.1.1
	MLWorks_1_0_Irix_1996_11_28:1.14.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.14.2
	MLWorks_1_0_Unix_1996_11_14:1.14.1
	MLWorks_Open_Beta2_1996_10_11:1.13.3
	MLWorks_License_dev:1.13.2
	MLWorks_1_open_beta_1996_09_13:1.13.1
	MLWorks_Open_Beta_1996_08_22:1.13
	MLWorks_Beta_1996_07_02:1.13
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.13
	MLWorks_Beta_1996_05_31:1.13
	MLWorks_Beta_1996_05_30:1.13
	ML_beta_release_12/08/94:1.8
	ML_beta_release_03/08/94:1.8
	ML_revised_beta_release_25/05/94:1.6
	ML_final_beta_release_02/03/94:1.4
	mlworks-28-01-1994:1.2;
locks; strict;
comment	@ * @;


1.16
date	97.09.19.09.38.22;	author brucem;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	97.01.13.16.18.49;	author matthew;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1;
next	1.14;

1.14
date	96.10.09.12.01.33;	author io;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1
	1.14.4.1;
next	1.13;

1.13
date	96.05.01.11.58.38;	author jont;	state Exp;
branches
	1.13.1.1
	1.13.2.1
	1.13.3.1;
next	1.12;

1.12
date	95.08.14.12.05.27;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	95.07.25.15.45.36;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	94.11.09.16.48.48;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	94.10.24.17.14.31;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	94.06.14.12.32.22;	author io;	state Exp;
branches;
next	1.7;

1.7
date	94.05.06.10.34.43;	author io;	state Exp;
branches;
next	1.6;

1.6
date	94.03.08.17.24.30;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.03.04.15.49.23;	author nickh;	state Exp;
branches;
next	1.4;

1.4
date	94.02.23.12.51.23;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.02.16.11.14.02;	author io;	state Exp;
branches;
next	1.2;

1.2
date	93.11.16.16.58.56;	author io;	state Exp;
branches;
next	1.1;

1.1
date	93.10.28.14.31.12;	author simon;	state Exp;
branches;
next	;

1.13.1.1
date	96.09.13.11.19.22;	author hope;	state Exp;
branches;
next	;

1.13.2.1
date	96.10.07.16.09.14;	author hope;	state Exp;
branches;
next	;

1.13.3.1
date	96.10.17.11.27.30;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	96.11.14.12.53.04;	author hope;	state Exp;
branches
	1.14.1.1.1.1;
next	;

1.14.1.1.1.1
date	96.11.28.15.04.01;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.11.22.18.12.06;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.12.17.17.50.35;	author hope;	state Exp;
branches
	1.14.3.1.1.1;
next	;

1.14.3.1.1.1
date	97.02.24.11.40.55;	author hope;	state Exp;
branches;
next	;

1.14.4.1
date	96.12.18.09.44.44;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	97.05.12.10.37.15;	author hope;	state Exp;
branches
	1.15.1.1.1.1
	1.15.1.1.2.1
	1.15.1.1.3.1;
next	;

1.15.1.1.1.1
date	97.07.28.18.22.28;	author daveb;	state Exp;
branches
	1.15.1.1.1.1.1.1;
next	;

1.15.1.1.1.1.1.1
date	97.10.07.11.48.09;	author jkbrook;	state Exp;
branches;
next	;

1.15.1.1.2.1
date	97.09.08.17.15.51;	author daveb;	state Exp;
branches;
next	;

1.15.1.1.3.1
date	97.09.09.14.11.48;	author daveb;	state Exp;
branches;
next	;

1.15.2.1
date	97.09.10.19.27.51;	author brucem;	state Exp;
branches;
next	;

1.15.3.1
date	97.09.11.20.57.46;	author daveb;	state Exp;
branches;
next	;

1.16.1.1
date	99.04.01.17.58.28;	author daveb;	state Exp;
branches;
next	;


desc
@Default RCS description
Copyright Harlequin Ltd., 1991
@


1.16
log
@[Bug #30153]
Remove references to Old.
@
text
@(*
 Copyright (c) 1993 Harlequin Ltd.

 based on Revision 1.30

 Revision Log
 ------------
 $Log: _machtypes.sml,v $
 * Revision 1.15  1997/01/13  16:18:49  matthew
 * Adding mult_result to registers
 *
 * Revision 1.14  1996/10/09  12:01:33  io
 * moving String from toplevel
 *
 * Revision 1.13  1996/05/01  11:58:38  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.12  1995/08/14  12:05:27  jont
 * Add bits_per_word
 * Remove smallest_int, largest_int, largest_word
 *
Revision 1.11  1995/07/25  15:45:36  jont
Add largest_word

Revision 1.10  1994/11/09  16:48:48  matthew
Changed fp_global to be R4

Revision 1.9  1994/10/24  17:14:31  matthew
Changed after_restore function to map callee closure to caller closure

Revision 1.8  1994/06/14  12:32:22  io
simplifying callee_arg and caller_arg

Revision 1.7  1994/05/06  10:34:43  io
added dummy_reg to identify ignored entries
in assembly format

Revision 1.6  1994/03/08  17:24:30  jont
Remove module type into separate file

Revision 1.5  1994/03/04  15:49:23  nickh
Improve code printing readability

Revision 1.4  1994/02/23  12:51:23  jont
Changes to machine register names

Revision 1.2  1993/11/16  16:58:56  io
Deleted old SPARC comments and fixed type errors

 *)

require "$.basis.__string";
require "../utils/crash";
require "machtypes";

functor MachTypes(
  structure Crash : CRASH
  ) : MACHTYPES =

struct
  datatype Mips_Reg =
    R0 |
    R1 |
    R2 |
    R3 |
    R4 |
    R5 |
    R6 |
    R7 |
    R8 |
    R9 |
    R10 |
    R11 |
    R12 |
    R13 |
    R14 |
    R15 |
    R16 |
    R17 |
    R18 |
    R19 |
    R20 |
    R21 |
    R22 |
    R23 |
    R24 |
    R25 |
    R26 |
    R27 |
    R28 |
    R29 |
    R30 |
    R31 |
    cond |
    heap |
    stack |
    mult_result |
    nil_v

  val F0 = R0
  val F1 = R1
  val F2 = R2
  val F3 = R3
  val F4 = R4
  val F5 = R5
  val F6 = R6
  val F7 = R7
  val F8 = R8
  val F9 = R9
  val F10 = R10
  val F11 = R11
  val F12 = R12
  val F13 = R13
  val F14 = R14
  val F15 = R15
  val F16 = R16
  val F17 = R17
  val F18 = R18
  val F19 = R19
  val F20 = R20
  val F21 = R21
  val F22 = R22
  val F23 = R23
  val F24 = R24
  val F25 = R25
  val F26 = R26
  val F27 = R27
  val F28 = R28
  val F29 = R29
  val F30 = R30
  val F31 = R31

  fun next_reg R0 = R1
  | next_reg R1 = R2
  | next_reg R2 = R3
  | next_reg R3 = R4
  | next_reg R4 = R5
  | next_reg R5 = R6
  | next_reg R6 = R7
  | next_reg R7 = R8
  | next_reg R8 = R9
  | next_reg R9 = R10
  | next_reg R10 = R11
  | next_reg R11 = R12
  | next_reg R12 = R13
  | next_reg R13 = R14
  | next_reg R14 = R15
  | next_reg R15 = R16
  | next_reg R16 = R17
  | next_reg R17 = R18
  | next_reg R18 = R19
  | next_reg R19 = R20
  | next_reg R20 = R21
  | next_reg R21 = R22
  | next_reg R22 = R23
  | next_reg R23 = R24
  | next_reg R24 = R25
  | next_reg R25 = R26
  | next_reg R26 = R27
  | next_reg R27 = R28
  | next_reg R28 = R29
  | next_reg R29 = R30
  | next_reg R30 = R31
  | next_reg R31 = Crash.impossible"Next reg of register 31"
  | next_reg _ = Crash.impossible"next_reg dummy register"

  datatype fp_type = single | double | extended

  val fp_used = double

  fun reg_to_string R0 = "zero"
    | reg_to_string R1 = "global"
    | reg_to_string R2 = "alloc"
    | reg_to_string R3 = "limit"
    | reg_to_string R4 = "arg"
    | reg_to_string R5 = "caller"
    | reg_to_string R6 = "callee"
    | reg_to_string R7 = "slimit"
    | reg_to_string R8 = "hndlr"
    | reg_to_string R9 = "implicit"
    | reg_to_string R10 = "r10"
    | reg_to_string R11 = "r11"
    | reg_to_string R12 = "r12"
    | reg_to_string R13 = "r13"
    | reg_to_string R14 = "r14"
    | reg_to_string R15 = "r15"
    | reg_to_string R16 = "r16"
    | reg_to_string R17 = "r17"
    | reg_to_string R18 = "r18"
    | reg_to_string R19 = "r19"
    | reg_to_string R20 = "r20"
    | reg_to_string R21 = "r21"
    | reg_to_string R22 = "r22"
    | reg_to_string R23 = "r23"
    | reg_to_string R24 = "r24"
    | reg_to_string R25 = "r25"
    | reg_to_string R26 = "kern1"
    | reg_to_string R27 = "kern2"
    | reg_to_string R28 = "gp"
    | reg_to_string R29 = "sp"
    | reg_to_string R30 = "fp"
    | reg_to_string R31 = "lr"
    | reg_to_string cond = "the condition codes"
    | reg_to_string heap = "the heap"
    | reg_to_string stack = "the stack"
    | reg_to_string mult_result = "multiplier result registers"
    | reg_to_string nil_v = "the nil vector"
      
  fun fp_reg_to_string R0 = "f0"
    | fp_reg_to_string R1 = "f1"
    | fp_reg_to_string R2 = "f2"
    | fp_reg_to_string R3 = "f3"
    | fp_reg_to_string R4 = "f4"
    | fp_reg_to_string R5 = "f5"
    | fp_reg_to_string R6 = "f6"
    | fp_reg_to_string R7 = "f7"
    | fp_reg_to_string R8 = "f8"
    | fp_reg_to_string R9 = "f9"
    | fp_reg_to_string R10 = "f10"
    | fp_reg_to_string R11 = "f11"
    | fp_reg_to_string R12 = "f12"
    | fp_reg_to_string R13 = "f13"
    | fp_reg_to_string R14 = "f14"
    | fp_reg_to_string R15 = "f15"
    | fp_reg_to_string R16 = "f16"
    | fp_reg_to_string R17 = "f17"
    | fp_reg_to_string R18 = "f18"
    | fp_reg_to_string R19 = "f19"
    | fp_reg_to_string R20 = "f20"
    | fp_reg_to_string R21 = "f21"
    | fp_reg_to_string R22 = "f22"
    | fp_reg_to_string R23 = "f23"
    | fp_reg_to_string R24 = "f24"
    | fp_reg_to_string R25 = "f25"
    | fp_reg_to_string R26 = "f26"
    | fp_reg_to_string R27 = "f27"
    | fp_reg_to_string R28 = "f28"
    | fp_reg_to_string R29 = "f29"
    | fp_reg_to_string R30 = "f30"
    | fp_reg_to_string R31 = "f31"

    | fp_reg_to_string cond = "the condition codes"
    | fp_reg_to_string heap = "the heap"
    | fp_reg_to_string stack = "the stack"
    | fp_reg_to_string mult_result = "multiplier result registers"
    | fp_reg_to_string nil_v = "the nil vector"
   
  val zero_reg = R0
  val dummy_reg = R0
  val arg = R4
  val caller_closure = R5
  val callee_closure = R6
  val fp = R30
  val sp = R29
  val lr = R31
  val handler = R8
  val gc1 = R2
  val gc2 = R3
  val global = R1
  val fp_global = R4 (* An arbitrary choice *)
  val implicit = R9
  val stack_limit = R7
    
  exception OutOfScope of Mips_Reg
  
  fun after_preserve X = X

  fun after_restore R6 = R5
    | after_restore X = X

  val digits_in_real = 64
  val bits_per_word = 30

  exception Ord and Chr

  val ord = fn x => (ord (String.sub(x, 0))) handle ? => raise Ord
  val chr = fn x => String.str(chr x) handle ? => raise Chr
  exception NeedsPreserve

  fun check_reg R0 = ()
    | check_reg R1 = ()
    | check_reg R2 = ()
    | check_reg R3 = ()
    | check_reg R4 = ()
    | check_reg R5 = () (* raise NeedsPreserve *)
    | check_reg R6 = ()
    | check_reg R7 = ()
    | check_reg R8 = ()
    | check_reg R9 = ()
    | check_reg R10 = raise NeedsPreserve
    | check_reg R11 = raise NeedsPreserve
    | check_reg R12 = raise NeedsPreserve
    | check_reg R13 = raise NeedsPreserve
    | check_reg R14 = raise NeedsPreserve
    | check_reg R15 = raise NeedsPreserve
    | check_reg R16 = ()
    | check_reg R17 = ()
    | check_reg R18 = ()
    | check_reg R19 = ()
    | check_reg R20 = ()
    | check_reg R21 = ()
    | check_reg R22 = ()
    | check_reg R23 = ()
    | check_reg R24 = raise NeedsPreserve
    | check_reg R25 = raise NeedsPreserve
    | check_reg R26 = ()
    | check_reg R27 = ()
    | check_reg R28 = ()
    | check_reg R29 = ()
    | check_reg R30 = ()
    | check_reg R31 = ()
    | check_reg cond = Crash.impossible"check_reg: the condition codes"
    | check_reg heap = Crash.impossible"check_reg: the heap"
    | check_reg stack = Crash.impossible"check_reg: the stack"
    | check_reg mult_result = Crash.impossible"check_reg: mult_result"
    | check_reg nil_v = Crash.impossible"check_reg: the nil vector"
      
end
@


1.16.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 4
 * Revision 1.16  1997/09/19  09:38:22  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
@


1.15
log
@Adding mult_result to registers
@
text
@d9 3
d55 1
a57 2
require "^.basis.__old";

d279 2
a280 2
  val ord = fn x => (Old.ord x) handle ? => raise Ord
  val chr = fn x => (Old.chr x) handle ? => raise Chr
@


1.15.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a8 3
 * Revision 1.15  1997/01/13  16:18:49  matthew
 * Adding mult_result to registers
 *
@


1.15.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a8 3
 * Revision 1.15  1997/01/13  16:18:49  matthew
 * Adding mult_result to registers
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a8 3
 * Revision 1.15  1997/01/13  16:18:49  matthew
 * Adding mult_result to registers
 *
@


1.15.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 * Revision 1.15.1.1  1997/05/12  10:37:15  hope
 * branched from 1.15
 *
@


1.15.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 * Revision 1.15.1.1  1997/05/12  10:37:15  hope
 * branched from 1.15
 *
@


1.15.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 * Revision 1.15.1.1  1997/05/12  10:37:15  hope
 * branched from 1.15
 *
@


1.15.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 * Revision 1.15.1.1.1.1  1997/07/28  18:22:28  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.14
log
@moving String from toplevel
@
text
@d9 3
d98 1
d166 1
a166 4
  | next_reg cond = Crash.impossible"next_reg cond"
  | next_reg heap = Crash.impossible"next_reg heap"
  | next_reg stack = Crash.impossible"next_reg stack"
  | next_reg nil_v = Crash.impossible"next_reg nil_v"
d207 1
d246 1
d248 1
a248 1
  
d252 2
a253 2
  val caller_closure = R5 (*io R3*)
  val callee_closure = R6 (*R3 (*originally R5*)*)
d258 3
a260 3
  val gc1 = R2 (* io R24 *)
  val gc2 = R3 (* io R25 *)
  val global = R1 (* io R28 *)
d263 1
a263 1
  val stack_limit = R7 (* io R10 *)
d267 3
a269 11
  fun after_preserve cond = Crash.impossible"after_preserve cond"
    | after_preserve heap = Crash.impossible"after_preserve heap"
    | after_preserve stack = Crash.impossible"after_preserve stack"
    | after_preserve nil_v = Crash.impossible"after_preserve nil_v"
    | after_preserve X = X

  fun after_restore cond = Crash.impossible"after_restore cond"    
    | after_restore heap = Crash.impossible"after_restore heap"
    | after_restore stack = Crash.impossible"after_restore stack"
    | after_restore nil_v = Crash.impossible"after_restore nil_v"
    | after_restore R6 = R5
d277 2
a278 2
  val ord = fn x=>(Old.ord x) handle ? => raise Ord
  val chr = fn x=>(Old.chr x) handle ? => raise Chr
d316 1
@


1.14.4.1
log
@branched from 1.14
@
text
@a8 3
 * Revision 1.14  1996/10/09  12:01:33  io
 * moving String from toplevel
 *
@


1.14.3.1
log
@branched from 1.14
@
text
@a8 3
 * Revision 1.14  1996/10/09  12:01:33  io
 * moving String from toplevel
 *
@


1.14.3.1.1.1
log
@branched from 1.14.3.1
@
text
@a8 3
 * Revision 1.14.3.1  1996/12/17  17:50:35  hope
 * branched from 1.14
 *
@


1.14.2.1
log
@branched from 1.14
@
text
@a8 3
 * Revision 1.14  1996/10/09  12:01:33  io
 * moving String from toplevel
 *
@


1.14.1.1
log
@branched from 1.14
@
text
@a8 3
 * Revision 1.14  1996/10/09  12:01:33  io
 * moving String from toplevel
 *
@


1.14.1.1.1.1
log
@branched from 1.14.1.1
@
text
@a8 3
 * Revision 1.14.1.1  1996/11/14  12:53:04  hope
 * branched from 1.14
 *
@


1.13
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d9 6
d51 1
d282 2
a283 2
  val ord = fn x=>(String.ord x) handle ? => raise Ord
  val chr = fn x=>(String.chr x) handle ? => raise Chr
@


1.13.3.1
log
@branched from 1.13
@
text
@a8 6
 * Revision 1.13  1996/05/01  11:58:38  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.13.2.1
log
@branched from 1.13
@
text
@a8 6
 * Revision 1.13  1996/05/01  11:58:38  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.13.1.1
log
@branched from 1.13
@
text
@a8 6
 * Revision 1.13  1996/05/01  11:58:38  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.12
log
@Add bits_per_word
Remove smallest_int, largest_int, largest_word
@
text
@d9 4
d275 2
a276 2
  val ord = fn x=>(ord x) handle ? => raise Ord
  val chr = fn x=>(chr x) handle ? => raise Chr
@


1.11
log
@Add largest_word
@
text
@d9 3
a265 3
  val largest_int = "536870911"
  val smallest_int = "~536870912"
  val largest_word = "1073741823"
d267 1
@


1.10
log
@Changed fp_global to be R4
@
text
@d9 3
d265 1
@


1.9
log
@Changed after_restore function to map callee closure to caller closure
@
text
@d9 3
d241 1
a241 1
  val fp_global = R1 (* io should fail because FP needs even regs *)
@


1.8
log
@simplifying callee_arg and caller_arg
@
text
@d9 3
d254 1
d272 1
a272 1
    | check_reg R5 = ()
@


1.7
log
@added dummy_reg to identify ignored entries
in assembly format
@
text
@d9 4
d225 1
a225 2
  val caller_arg = R4  (* originally R2, tried R4*)
  val callee_arg = R4  (* io *)(* originally R4, tried R2 *)
@


1.6
log
@Remove module type into separate file
@
text
@d9 3
d220 1
@


1.5
log
@Improve code printing readability
@
text
@d9 3
a28 14
  datatype wordset = WORD_SET of string list * (int * int * string) list * bool list * int list
  datatype module_element =
    REAL of int * string |
    STRING of int * string |
    MLVALUE of int * MLWorks.Internal.Value.ml_value |
    WORDSET of wordset |
    EXTERNAL of int * string |
    VAR of int * string |
    EXN of int * string |
    STRUCT of int * string |
    FUNCT of int * string

  datatype Module = MODULE of module_element list

a293 33

































@


1.4
log
@Changes to machine register names
@
text
@d9 3
d152 32
a183 32
  fun reg_to_string R0 = "R0"
    | reg_to_string R1 = "R1"
    | reg_to_string R2 = "R2"
    | reg_to_string R3 = "R3"
    | reg_to_string R4 = "R4"
    | reg_to_string R5 = "R5"
    | reg_to_string R6 = "R6"
    | reg_to_string R7 = "R7"
    | reg_to_string R8 = "R8"
    | reg_to_string R9 = "R9"
    | reg_to_string R10 = "R10"
    | reg_to_string R11 = "R11"
    | reg_to_string R12 = "R12"
    | reg_to_string R13 = "R13"
    | reg_to_string R14 = "R14"
    | reg_to_string R15 = "R15"
    | reg_to_string R16 = "R16"
    | reg_to_string R17 = "R17"
    | reg_to_string R18 = "R18"
    | reg_to_string R19 = "R19"
    | reg_to_string R20 = "R20"
    | reg_to_string R21 = "R21"
    | reg_to_string R22 = "R22"
    | reg_to_string R23 = "R23"
    | reg_to_string R24 = "R24"
    | reg_to_string R25 = "R25"
    | reg_to_string R26 = "R26"
    | reg_to_string R27 = "R27"
    | reg_to_string R28 = "R28"
    | reg_to_string R29 = "R29"
    | reg_to_string R30 = "R30"
    | reg_to_string R31 = "R31"
d189 32
a220 32
  fun fp_reg_to_string R0 = "F0"
    | fp_reg_to_string R1 = "F1"
    | fp_reg_to_string R2 = "F2"
    | fp_reg_to_string R3 = "F3"
    | fp_reg_to_string R4 = "F4"
    | fp_reg_to_string R5 = "F5"
    | fp_reg_to_string R6 = "F6"
    | fp_reg_to_string R7 = "F7"
    | fp_reg_to_string R8 = "F8"
    | fp_reg_to_string R9 = "F9"
    | fp_reg_to_string R10 = "F10"
    | fp_reg_to_string R11 = "F11"
    | fp_reg_to_string R12 = "F12"
    | fp_reg_to_string R13 = "F13"
    | fp_reg_to_string R14 = "F14"
    | fp_reg_to_string R15 = "F15"
    | fp_reg_to_string R16 = "F16"
    | fp_reg_to_string R17 = "F17"
    | fp_reg_to_string R18 = "F18"
    | fp_reg_to_string R19 = "F19"
    | fp_reg_to_string R20 = "F20"
    | fp_reg_to_string R21 = "F21"
    | fp_reg_to_string R22 = "F22"
    | fp_reg_to_string R23 = "F23"
    | fp_reg_to_string R24 = "F24"
    | fp_reg_to_string R25 = "F25"
    | fp_reg_to_string R26 = "F26"
    | fp_reg_to_string R27 = "F27"
    | fp_reg_to_string R28 = "F28"
    | fp_reg_to_string R29 = "F29"
    | fp_reg_to_string R30 = "F30"
    | fp_reg_to_string R31 = "F31"
@


1.3
log
@bringing into line with other sources, moved sigs from mips/ to main/
@
text
@d227 2
a228 2
  val caller_closure = R6 (*io R3*)
  val callee_closure = R5 (*R3 (*originally R5*)*)
@


1.2
log
@Deleted old SPARC comments and fixed type errors
@
text
@d8 4
a11 1
 $Log$
d223 1
a223 1
      
d226 3
a228 3
  val callee_arg = R2  (* originally R4, tried R2 *)
  val caller_closure = R3
  val callee_closure = R3 (*originally R5*)
d233 4
a236 4
  val gc1 = R24
  val gc2 = R25
  val global = R28
  val fp_global = R28
d238 1
a238 1
  val stack_limit = R10
d264 52
a315 1
  fun check_reg _ = ()
d317 18
a334 1
end
@


1.1
log
@Initial revision
@
text
@a0 1
(* _machtypes.sml the functor *)
d2 1
a2 3
$Log: _machtypes.sml,v $
Revision 1.1  1993/08/02  12:18  simon
Initial revision for mips.
d4 1
a4 2
;;; Copyright 1991 Harlequin Ltd.
;;; $Log$
d6 4
a9 101

Revision 1.30  1993/07/14  11:12:37  jont
Fixed maximum and minimum integer sizes for lambda optimiser

Revision 1.29  1993/03/18  10:08:35  jont
Added leaf and offsets lists into WORDSET

Revision 1.28  1993/03/11  11:07:13  matthew
Added type Module

Revision 1.27  1993/03/01  14:27:46  matthew
Added MLVALUEs

Revision 1.26  1993/02/03  15:34:53  jont
Changes for code vector reform.

Revision 1.25  1993/01/15  12:29:42  jont
Split store into three areas of heap, stack and nil vector for scheduling improvement

Revision 1.24  1992/09/15  10:56:24  clive
Checked and corrected the specification for the floating point registers

Revision 1.23  1992/06/18  11:01:06  jont
Added furhter constructors to the module element type to express
interpretive stuff

Revision 1.22  1992/01/13  14:19:26  clive
Added code for non_gc spills number in front of code objects in a closure

Revision 1.21  1992/01/07  09:07:08  clive
Added stack limit register definitions

Revision 1.20  1991/11/25  15:48:57  jont
Added fp_global as a temporary for conversions from fp to int

Revision 1.19  91/11/20  17:34:43  jont
Added check_reg function from mach_cg to see when save/restore is needed

Revision 1.18  91/11/13  12:41:08  jont
Added next_reg to give the next register up. Needed for doubel and extended
moves, abs, neg, and extended store operations

Revision 1.17  91/11/11  18:03:25  jont
Added a maximum number of real digits, and a type to determine the
type of floating point in use

Revision 1.16  91/11/08  11:31:49  jont
Added printing of floating point registers

Revision 1.15  91/10/28  11:55:25  jont
Added store register for detection of load/store interaction

Revision 1.14  91/10/24  15:26:26  davidt
Now knows about the `implicit' register.

Revision 1.13  91/10/24  13:26:44  jont
Added cond register to represent the condition for the benefit of the
instruction scheduler

Revision 1.12  91/10/16  12:47:12  jont
New improved simplified module structure

Revision 1.11  91/10/15  16:54:01  jont
Changed defn of FN_CALL

Revision 1.10  91/10/09  14:33:15  richard
Added some new register definitions

Revision 1.9  91/10/09  10:55:13  jont
Changed some register allocations

Revision 1.8  91/10/08  18:47:05  jont
New module structure with lists of functions

Revision 1.7  91/10/07  11:46:17  richard
Moved some machine specific information to MachSpec.
Changed Bad_Reg exception to include a value. It is now called
OutOfScope.

Revision 1.6  91/10/03  09:42:44  richard
Changed the name of spillable_regs to gc_registers for consistency,
and added fp_registers and fp_double_registers.

Revision 1.5  91/10/02  10:32:43  jont
More register names and fixed translations

Revision 1.4  91/09/06  13:27:36  jont
Added register definitions etc

Revision 1.3  91/08/27  12:51:31  davida
Added exceptions Ord and Chr

Revision 1.2  91/08/22  11:02:02  jont
Added string to int and int to string conversion functions in case we
want variations between host and target

Revision 1.1  91/08/09  17:22:25  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)
@
