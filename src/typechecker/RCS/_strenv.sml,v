head	1.15;
access;
symbols
	MLW_daveb_inline_1_4_99:1.15.11
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.15
	MLWorks_20c0_1998_08_04:1.15
	MLWorks_20b2c2_1998_06_19:1.15
	MLWorks_20b2_Windows_1998_06_12:1.15
	MLWorks_20b1c1_1998_05_07:1.15
	MLWorks_20b0_1998_04_07:1.15
	MLWorks_20b0_1998_03_20:1.15
	MLWorks_20m2_1998_02_16:1.15
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.15.8.1.1.1.1
	MLWorks_workspace_97:1.15.10
	MLWorks_dt_wizard:1.15.9
	MLWorks_11c0_1997_09_09:1.15.8.1.1.1
	MLWorks_10r3:1.15.8.1.3
	MLWorks_10r2_551:1.15.8.1.2
	MLWorks_11:1.15.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.8.1
	MLWorks_20m0_1997_06_20:1.15
	MLWorks_1_0_r2c2_1997_06_14:1.15.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.8
	MLWorks_BugFix_1997_04_24:1.15
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.6.1.1
	MLWorks_gui_1996_12_18:1.15.7
	MLWorks_1_0_Win32_1996_12_17:1.15.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.4.1
	MLWorks_1_0_Irix_1996_11_28:1.15.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.5
	MLWorks_1_0_Unix_1996_11_14:1.15.4
	MLWorks_Open_Beta2_1996_10_11:1.15.3
	MLWorks_License_dev:1.15.2
	MLWorks_1_open_beta_1996_09_13:1.15.1
	MLWorks_Open_Beta_1996_08_22:1.15
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.15
	MLWorks_Beta_1996_06_06:1.15
	MLWorks_Beta_1996_06_05:1.15
	MLWorks_Beta_1996_06_03:1.15
	MLWorks_Beta_1996_05_31:1.15
	MLWorks_Beta_1996_05_30:1.15
	ML_beta_release_12/08/94:1.13
	ML_beta_release_03/08/94:1.13
	ML_revised_beta_release_25/05/94:1.13
	ML_final_beta_release_02/03/94:1.13
	mlworks-28-01-1994:1.13
	Release:1.13
	mlworks-beta-01-09-1993:1.13
	MLWorks-1-0-4-29/01/1993:1.13
	MLWorks-1-0-3-21/12/1992:1.12
	MLWorks-1-0-2-15/12/1992:1.12
	MLWorks-1-0-1-04/12/1992:1.12
	checkpoint_17_08_92:1.9;
locks; strict;
comment	@ * @;


1.15
date	95.03.23.13.34.47;	author matthew;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1
	1.15.5.1
	1.15.6.1
	1.15.7.1
	1.15.8.1
	1.15.9.1
	1.15.10.1
	1.15.11.1;
next	1.14;

1.14
date	95.02.06.16.13.46;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.12.14.16.18.25;	author jont;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	92.10.27.19.15.21;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.10.02.16.05.06;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.08.18.16.06.19;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.08.11.15.32.42;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.04.12.29.43;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.03.09.14.25.26;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.02.11.10.10.06;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.01.31.09.24.24;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.01.22.16.27.15;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.01.15.12.23.37;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.01.07.19.28.42;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.11.18.14.51.34;	author richard;	state Exp;
branches;
next	;

1.13.1.1
date	92.12.14.16.18.25;	author jont;	state Exp;
branches;
next	;

1.15.1.1
date	96.09.13.11.41.15;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.10.07.16.34.18;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.10.17.11.53.26;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.11.14.13.21.01;	author hope;	state Exp;
branches
	1.15.4.1.1.1;
next	;

1.15.4.1.1.1
date	96.11.28.15.32.01;	author hope;	state Exp;
branches;
next	;

1.15.5.1
date	96.11.22.18.38.47;	author hope;	state Exp;
branches;
next	;

1.15.6.1
date	96.12.17.18.17.48;	author hope;	state Exp;
branches
	1.15.6.1.1.1;
next	;

1.15.6.1.1.1
date	97.02.24.12.12.04;	author hope;	state Exp;
branches;
next	;

1.15.7.1
date	96.12.18.10.13.04;	author hope;	state Exp;
branches;
next	;

1.15.8.1
date	97.05.12.10.51.22;	author hope;	state Exp;
branches
	1.15.8.1.1.1
	1.15.8.1.2.1
	1.15.8.1.3.1;
next	;

1.15.8.1.1.1
date	97.07.28.18.34.46;	author daveb;	state Exp;
branches
	1.15.8.1.1.1.1.1;
next	;

1.15.8.1.1.1.1.1
date	97.10.07.12.00.33;	author jkbrook;	state Exp;
branches;
next	;

1.15.8.1.2.1
date	97.09.08.17.27.37;	author daveb;	state Exp;
branches;
next	;

1.15.8.1.3.1
date	97.09.09.14.24.36;	author daveb;	state Exp;
branches;
next	;

1.15.9.1
date	97.09.10.19.43.33;	author brucem;	state Exp;
branches;
next	;

1.15.10.1
date	97.09.11.21.10.57;	author daveb;	state Exp;
branches;
next	;

1.15.11.1
date	99.04.01.18.09.11;	author daveb;	state Exp;
branches;
next	;


desc
@Structure envrionment tools and initial environment.
This is the functor.
@


1.15
log
@Removing SimpleTypes structue
@
text
@(* strenv.sml the functor *)

(* $Log: _strenv.sml,v $
Revision 1.14  1995/02/06  16:13:46  matthew
Stuff

Revision 1.13  1992/12/14  16:18:25  jont
Anel's last changes

Revision 1.12  1992/10/27  19:15:21  jont
Modified to use less than functions for maps

Revision 1.11  1992/10/02  16:05:06  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.10  1992/08/18  16:06:19  jont
Removed irrelevant handlers and new exceptions

Revision 1.9  1992/08/11  15:32:42  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.8  1992/08/04  12:29:43  jont
Anel's changes to use NewMap instead of Map

Revision 1.7  1992/03/09  14:25:26  jont
Added require "valenv"

Revision 1.6  1992/02/11  10:10:06  clive
New pervasive library code - cut some things out of the initial type basis

Revision 1.5  1992/01/31  09:24:24  clive
Got the imperative attributes wrong on some of the array stuff

Revision 1.4  1992/01/22  16:27:15  clive
Added the Array exceptions to the variable environment

Revision 1.3  1992/01/15  12:23:37  clive
Added arrays to the initial basis

Revision 1.2  1992/01/07  19:28:42  colin
Added pervasive_strname_count giving strname id of first strname after
the pervasives have been defined and added code to reset strname counter

Revision 1.1  1991/11/18  14:51:34  richard
Initial revision

Copyright (C) 1991 Harlequin Ltd.
*)

require "../typechecker/datatypes";

require "../typechecker/strenv";

functor Strenv ( structure Datatypes	: DATATYPES
                ) : STRENV =
  struct

    structure Datatypes = Datatypes

    open Datatypes

    val empty_strenv = SE (NewMap.empty (Ident.strid_lt, Ident.strid_eq))

    fun empty_strenvp (SE amap) = NewMap.is_empty amap

    fun lookup (strid,SE amap) = 
      NewMap.tryApply'(amap, strid)

    fun se_plus_se (SE amap,SE amap') =
      SE (NewMap.union(amap, amap'))

    fun add_to_se (strid,str,SE amap) =
      SE (NewMap.define (amap,strid,str))

    (* Build the initial structure environment *)
    val initial_se = empty_strenv
		    
  end
@


1.15.11.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.8.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.15.8.1  1997/05/12  10:51:22  hope
 * branched from 1.15
 *
@


1.15.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.15.8.1  1997/05/12  10:51:22  hope
 * branched from 1.15
 *
@


1.15.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.15.8.1  1997/05/12  10:51:22  hope
 * branched from 1.15
 *
@


1.15.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.15.8.1.1.1  1997/07/28  18:34:46  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.15.7.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.6.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.6.1.1.1
log
@branched from 1.15.6.1
@
text
@a3 3
 * Revision 1.15.6.1  1996/12/17  18:17:48  hope
 * branched from 1.15
 *
@


1.15.5.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.4.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.4.1.1.1
log
@branched from 1.15.4.1
@
text
@a3 3
 * Revision 1.15.4.1  1996/11/14  13:21:01  hope
 * branched from 1.15
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1995/03/23  13:34:47  matthew
 * Removing SimpleTypes structue
 *
@


1.14
log
@Stuff
@
text
@d4 3
d51 2
a52 7
require "../utils/print";
require "../basics/identprint";
require "../typechecker/simpletypes";
require "../typechecker/types";
require "../typechecker/scheme";
require "../typechecker/valenv";
require "../typechecker/tyenv";
d55 2
a56 17

functor Strenv (
  structure Print	: PRINT
  structure IdentPrint  : IDENTPRINT
  structure Strname_id	: STRNAME_ID
  structure Types	: TYPES
  structure Scheme	: SCHEME
  structure Valenv	: VALENV
  structure Tyenv	: TYENV

  sharing Valenv.Datatypes =
    Tyenv.Datatypes =
    Scheme.Datatypes =
    Types.Datatypes
  sharing Types.Datatypes.Ident = IdentPrint.Ident
) : STRENV =

d59 1
a59 1
    structure Datatypes	= Types.Datatypes
a74 4

    val _ = Strname_id.reset_counter 0

    val pervasive_strname_count = Strname_id.read_counter ()
@


1.13
log
@Anel's last changes
@
text
@d4 3
a49 1
require "../typechecker/ty_debug";
a60 1
  structure TyDebug	: TY_DEBUG
a65 5
  structure Debug :
	      sig
		val set_debug_level : int -> unit
		val debug_level : unit -> int
	      end
a79 4
    val do_debug = TyDebug.do_debug

    exception Lookup_in_SE = NewMap.Undefined

d85 1
a85 6
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("strid lookup in SE \n");
	       Print.print (IdentPrint.printStrId strid);
	       Print.print ("\n"))
       else ();
      NewMap.apply'(amap, strid))
a91 4

    fun member_of_se_domain (strid, SE amap) =
      (NewMap.apply'(amap, strid);
       true) handle NewMap.Undefined => false
@


1.13.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.13  1992/12/14  16:18:25  jont
Anel's last changes

@


1.12
log
@Modified to use less than functions for maps
@
text
@d4 3
d114 1
a114 39
      (* make_up_a_scheme is adapted from the defintion in valenv *)

    fun atyvar (id,eq,imp) =
      TYVAR (ref 0,Ident.TYVAR (Ident.Symbol.find_symbol (id),eq,imp))

      exception Make_up_a_scheme of string

      fun make_up_a_scheme (vars,[tyname1]) = 
	Scheme.make_scheme (vars,tyname1)
	| make_up_a_scheme (vars,[tyname1,tyname2]) = 
	  Scheme.make_scheme (vars,FUNTYPE
			      (tyname1,
			       tyname2))
	| make_up_a_scheme (vars,[tyname1,tyname2,tyname3]) = 
	  Scheme.make_scheme (vars,FUNTYPE
			      (Types.add_to_rectype
			       (Ident.LAB(Ident.Symbol.find_symbol ("1")),
				tyname1,
				Types.add_to_rectype
				(Ident.LAB (Ident.Symbol.find_symbol ("2")),
				 tyname2,
				 Types.empty_rec_type)),
			       tyname3))
	| make_up_a_scheme (vars,[tyname1,tyname2,tyname3,tyname4]) = 
	  Scheme.make_scheme (vars,FUNTYPE
			       (Types.add_to_rectype
				(Ident.LAB(Ident.Symbol.find_symbol ("1")),
				 tyname1,
				Types.add_to_rectype
				(Ident.LAB (Ident.Symbol.find_symbol ("2")),
				 tyname2,
                                 Types.add_to_rectype
                                 (Ident.LAB (Ident.Symbol.find_symbol ("3")),
                                  tyname3,
                                  Types.empty_rec_type))),
				tyname4))
	| make_up_a_scheme (_) = raise Make_up_a_scheme "Strenv.make_up_a_scheme"
	  
      (* Build the initial structure environment *)
@


1.11
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d85 1
a85 1
    val empty_strenv = SE (NewMap.empty (strid_order,strid_equal))
@


1.10
log
@Removed irrelevant handlers and new exceptions
@
text
@d4 3
d82 1
a82 1
    val empty_strenv = SE (NewMap.empty strid_order)
@


1.9
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d77 1
a77 1
    exception Lookup_in_SE
d89 1
a89 2
      NewMap.apply'(amap, strid )
      handle NewMap.Undefined => raise Lookup_in_SE)
@


1.8
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
a31 2
require "../utils/newmap";
require "../utils/lists";
d33 1
a35 1
require "../typechecker/datatypes";
a43 2

  structure Lists	: LISTS
d45 1
a45 1
  structure NewMap	: NEWMAP
a47 1
  structure Datatypes	: DATATYPES
d58 1
a58 2
  sharing Datatypes =
    Valenv.Datatypes =
d62 1
a62 1

d67 1
a67 1
    structure Datatypes	= Datatypes
d85 1
a85 1
      NewMap.apply amap strid 
d89 1
a89 7
      let 
        val strid_str_list' = NewMap.to_list amap'
      in
        SE (Lists.reducel
            (fn (tree,(strid,str)) => NewMap.define (tree,strid,str))
            (amap,strid_str_list'))
      end
d94 3
a96 2
    fun member_of_se_domain (strid, SE amap) = 
      Lists.member (strid,NewMap.domain amap)
@


1.7
log
@Added require "valenv"
@
text
@d4 3
d29 5
a33 2
require "../typechecker/strenv";
require "../typechecker/valenv";
a34 2
require "../typechecker/tyenv";
require "../typechecker/simpletypes";
d37 3
a39 1
require "../utils/map";
d44 5
d50 2
a51 1
  structure Mapping	: MAP
d54 5
a58 3
  structure Types	: TYPES
  structure Strname_id	: STRNAME_ID
  structure Scheme	: SCHEME
a59 3
  sharing Mapping =
    Datatypes.Mapping

a71 1

d74 1
a74 1
    val empty_se = SE Mapping.empty_map
d76 1
a76 2
    fun add_to_se (str_id, scheme, SE strenv) =
      SE (Mapping.add ((str_id, scheme), strenv, Ident.strid_order))
d78 28
d112 2
a113 2
      fun atyvar (id,eq,imp) =
	TYVAR (ref 0,Ident.TYVAR (Ident.Symbol.find_symbol (id),eq,imp))
d115 1
a115 1
	exception Make_up_a_scheme of string
d149 1
a149 1
    val initial_se = SE(Mapping.empty_map)
@


1.6
log
@New pervasive library code - cut some things out of the initial type basis
@
text
@d4 3
d27 1
@


1.5
log
@Got the imperative attributes wrong on some of the array stuff
@
text
@d4 3
a66 3
    val system_structure_strname = STRNAME (Strname_id.make_strname_id ())
    val array_structure_strname = STRNAME (Strname_id.make_strname_id ())

a106 116
      (* Build the SYSTEM structure *)
      local
	(* Build a type scheme int * 'a -> 'b for call_c *)
	val callc_scheme =
	  let
	    val alpha = atyvar("'a",false,false)
	    val beta = atyvar("'b",false,false)

	    val int_alpha_tuple =
	      Types.add_to_rectype
	      (Ident.LAB(Ident.Symbol.find_symbol "1"),
	       CONSTYPE ([], Types.int_tyname),
	       Types.add_to_rectype
	       (Ident.LAB(Ident.Symbol.find_symbol "2"),
		alpha,
		Types.empty_rec_type))
	  in
	    make_up_a_scheme
	    ([alpha, beta],[CONSTYPE([],Types.int_tyname),alpha,beta])
	  end

	(* Build a valenv containing the call_c function. *)
	val system_valenv =
	  Valenv.add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("call_c")),
			    callc_scheme,
			    Valenv.empty_valenv)
      in
	val system_str = STR (system_structure_strname,
			      ENV (empty_se,
				   Tyenv.empty_tyenv,
				   system_valenv,
				   Valenv.empty_valenv))
      end

      (* Build the ARRAY structure *)
    
      local
	val array_tyenv =
	  Tyenv.add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("array")),
			   TYSTR (Types.make_eta_tyfun (Types.array_tyname),
				  Valenv.empty_valenv),
			   Tyenv.empty_tyenv)

	val array_exception_env =
	  Valenv.add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Size")),
		    make_up_a_scheme([],
				     [CONSTYPE([],Types.exn_tyname)]),
	  Valenv.add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Subscript")),
		    make_up_a_scheme([],
				     [CONSTYPE([],Types.exn_tyname)]),
			   Valenv.empty_valenv))

	val array_varenv =
	  Valenv.add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("array")),
		     let 
		       val tyvar = atyvar("'_a",false,true)
		     in
		       make_up_a_scheme([tyvar],
					[CONSTYPE([],Types.int_tyname),
					 tyvar,
					 CONSTYPE([tyvar],Types.array_tyname)])
		     end,
	  Valenv.add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("arrayoflist")),
		     let 
		       val tyvar = atyvar("'_a",false,true)
		     in
		       make_up_a_scheme([tyvar],
					[CONSTYPE([tyvar],Types.list_tyname),
					 CONSTYPE([tyvar],Types.array_tyname)])
		     end,
		   Valenv.add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("length")),
			      let 
				val tyvar = atyvar("'a",false,false)
			      in
				make_up_a_scheme([tyvar],
						 [CONSTYPE([tyvar],Types.array_tyname),
						  CONSTYPE([],Types.int_tyname)])
		     end,
		   Valenv.add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("sub")),
			      let 
				val tyvar = atyvar("'a",false,false)
			      in
				make_up_a_scheme([tyvar],
						 [CONSTYPE([tyvar],Types.array_tyname),
						  CONSTYPE([],Types.int_tyname),
						  tyvar])
			      end,
		   Valenv.add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("tabulate")),
			      let 
				val tyvar = atyvar("'_a",false,true)
			      in
				make_up_a_scheme([tyvar],
						 [CONSTYPE([],Types.int_tyname),
						  FUNTYPE(CONSTYPE([],Types.int_tyname),tyvar),
						  CONSTYPE([tyvar],Types.array_tyname)])
			      end,
		   Valenv.add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("update")),
			      let 
				val tyvar = atyvar("'a",false,false)
			      in
				make_up_a_scheme([tyvar],
						 [CONSTYPE([tyvar],Types.array_tyname),
						  CONSTYPE([],Types.int_tyname),
						  tyvar,
						  Types.empty_rec_type])
			      end,
			    array_exception_env))))))

      in
	val array_str = STR (array_structure_strname,
			      ENV (empty_se,
				   array_tyenv,
				   array_varenv,
				   array_exception_env))
      end

d108 1
a108 8
    val initial_se =
      SE (Mapping.add(((Ident.STRID (Ident.Symbol.find_symbol "Array"),
			array_str),
		       Mapping.add ((Ident.STRID (Ident.Symbol.find_symbol "System"),
				     system_str),
				    Mapping.empty_map,
				    Ident.strid_order),
		       Ident.strid_order)))
@


1.4
log
@Added the Array exceptions to the variable environment
@
text
@d4 3
d179 1
a179 1
				val tyvar = atyvar("'_a",false,true)
d187 1
a187 1
				val tyvar = atyvar("'_a",false,true)
d205 1
a205 1
				val tyvar = atyvar("'_a",false,true)
@


1.3
log
@Added arrays to the initial basis
@
text
@d4 3
d210 1
a210 1
			    Valenv.empty_valenv))))))
@


1.2
log
@Added pervasive_strname_count giving strname id of first strname after
the pervasives have been defined and added code to reset strname counter
@
text
@d4 4
d59 1
d63 1
a63 2
    val initial_se =
      let
d65 38
d104 1
a104 2

	val scheme =
d106 2
a107 6
	    val alpha =
	      TYVAR (ref 0, Ident.TYVAR (Ident.Symbol.find_symbol "'a",
					 false, false))
	    val beta =
	      TYVAR (ref 0, Ident.TYVAR (Ident.Symbol.find_symbol "'b",
					 false, false))
d118 2
a119 3
	    Scheme.make_scheme
	    ([alpha, beta],
	     FUNTYPE (int_alpha_tuple, beta))
d123 1
a123 2

	val valenv =
d125 1
a125 1
			    scheme,
d127 7
d135 8
a142 1
	(* Build a Str containing the valenv *)
d144 65
a208 5
	val str = STR (system_structure_strname,
		       ENV (empty_se,
			    Tyenv.empty_tyenv,
			    valenv,
			    Valenv.empty_valenv))
d210 5
a214 4
	SE (Mapping.add ((Ident.STRID (Ident.Symbol.find_symbol "System"),
			  str),
			 Mapping.empty_map,
			 Ident.strid_order))
d216 10
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
(* $Log$
d52 2
d55 2
@
