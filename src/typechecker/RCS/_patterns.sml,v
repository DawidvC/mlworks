head	1.44;
access;
symbols
	MLW_daveb_inline_1_4_99:1.44.8
	MLWorks_21c0_1999_03_25:1.44
	MLWorks_20c1_1998_08_20:1.44
	MLWorks_20c0_1998_08_04:1.44
	MLWorks_20b2c2_1998_06_19:1.44
	MLWorks_20b2_Windows_1998_06_12:1.44
	MLWorks_20b1c1_1998_05_07:1.44
	MLWorks_20b0_1998_04_07:1.44
	MLWorks_20b0_1998_03_20:1.44
	MLWorks_20m2_1998_02_16:1.44
	MLWorks_20m1_1997_10_23:1.44
	MLWorks_11r1:1.44.5.1.1.1.1
	MLWorks_workspace_97:1.44.7
	MLWorks_dt_wizard:1.44.6
	MLWorks_11c0_1997_09_09:1.44.5.1.1.1
	MLWorks_10r3:1.44.5.1.3
	MLWorks_10r2_551:1.44.5.1.2
	MLWorks_11:1.44.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.44.5.1
	MLWorks_20m0_1997_06_20:1.44
	MLWorks_1_0_r2c2_1997_06_14:1.44.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.44.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.44.5
	MLWorks_BugFix_1997_04_24:1.44
	MLWorks_1_0_r2_Win32_1997_04_11:1.44
	MLWorks_1_0_r2_Unix_1997_04_04:1.44
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.44.3.1.1
	MLWorks_gui_1996_12_18:1.44.4
	MLWorks_1_0_Win32_1996_12_17:1.44.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.44.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.44.1.1
	MLWorks_1_0_Irix_1996_11_28:1.44.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.44.2
	MLWorks_1_0_Unix_1996_11_14:1.44.1
	MLWorks_Open_Beta2_1996_10_11:1.43.3
	MLWorks_License_dev:1.43.2
	MLWorks_1_open_beta_1996_09_13:1.43.1
	MLWorks_Open_Beta_1996_08_22:1.43
	MLWorks_Beta_1996_07_02:1.43
	MLWorks_Beta_1996_06_07:1.43
	MLWorks_Beta_1996_06_06:1.43
	MLWorks_Beta_1996_06_05:1.43
	MLWorks_Beta_1996_06_03:1.43
	MLWorks_Beta_1996_05_31:1.43
	MLWorks_Beta_1996_05_30:1.43
	ML_beta_release_12/08/94:1.33
	ML_beta_release_03/08/94:1.33
	ML_revised_beta_release_25/05/94:1.33
	ML_final_beta_release_02/03/94:1.32
	mlworks-28-01-1994:1.30
	Release:1.24
	mlworks-beta-01-09-1993:1.24
	MLWorks-1-0-4-29/01/1993:1.17
	MLWorks-1-0-3-21/12/1992:1.16
	MLWorks-1-0-2-15/12/1992:1.16
	MLWorks-1-0-1-04/12/1992:1.15
	checkpoint_17_08_92:1.9
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.44
date	96.10.29.13.44.06;	author io;	state Exp;
branches
	1.44.1.1
	1.44.2.1
	1.44.3.1
	1.44.4.1
	1.44.5.1
	1.44.6.1
	1.44.7.1
	1.44.8.1;
next	1.43;

1.43
date	96.04.30.15.51.04;	author jont;	state Exp;
branches
	1.43.1.1
	1.43.2.1
	1.43.3.1;
next	1.42;

1.42
date	95.12.27.12.38.53;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	95.09.08.15.43.09;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.08.31.13.41.11;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	95.06.09.10.16.21;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	95.05.02.10.59.23;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	95.02.13.11.46.28;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	95.02.06.14.57.45;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	95.01.04.12.23.48;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	94.09.22.16.06.26;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.05.04.16.42.41;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	94.02.22.01.58.23;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	94.02.08.12.01.23;	author nickh;	state Exp;
branches;
next	1.30;

1.30
date	93.12.16.11.39.23;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.12.02.17.36.56;	author nickh;	state Exp;
branches;
next	1.28;

1.28
date	93.11.30.14.48.50;	author nickh;	state Exp;
branches;
next	1.27;

1.27
date	93.11.25.12.14.58;	author nickh;	state Exp;
branches;
next	1.26;

1.26
date	93.11.25.09.36.42;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.09.17.10.14.58;	author nosa;	state Exp;
branches;
next	1.24;

1.24
date	93.08.09.16.31.40;	author jont;	state Exp;
branches
	1.24.1.1;
next	1.23;

1.23
date	93.03.10.15.25.20;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.03.09.11.43.11;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.03.02.15.46.01;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.02.22.15.17.12;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.02.08.18.47.43;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.02.04.16.51.37;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	92.12.22.15.51.42;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.12.10.19.00.46;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	92.12.04.13.40.54;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	92.12.02.16.49.12;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.11.26.17.29.36;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	92.11.05.09.52.25;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	92.09.08.17.22.55;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	92.09.04.09.31.09;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.08.12.10.38.33;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.04.12.23.38;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.07.22.12.30.47;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.06.15.10.35.56;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.04.07.14.53.43;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.01.27.20.01.36;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.01.27.11.03.33;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.21.19.04.15;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.36.52;	author colin;	state Exp;
branches;
next	;

1.24.1.1
date	93.08.09.16.31.40;	author jont;	state Exp;
branches;
next	;

1.43.1.1
date	96.09.13.11.42.08;	author hope;	state Exp;
branches;
next	;

1.43.2.1
date	96.10.07.16.35.13;	author hope;	state Exp;
branches;
next	;

1.43.3.1
date	96.10.17.11.54.18;	author hope;	state Exp;
branches;
next	;

1.44.1.1
date	96.11.14.13.22.19;	author hope;	state Exp;
branches
	1.44.1.1.1.1;
next	;

1.44.1.1.1.1
date	96.11.28.15.33.02;	author hope;	state Exp;
branches;
next	;

1.44.2.1
date	96.11.22.18.39.40;	author hope;	state Exp;
branches;
next	;

1.44.3.1
date	96.12.17.18.18.41;	author hope;	state Exp;
branches
	1.44.3.1.1.1;
next	;

1.44.3.1.1.1
date	97.02.24.12.12.57;	author hope;	state Exp;
branches;
next	;

1.44.4.1
date	96.12.18.10.14.01;	author hope;	state Exp;
branches;
next	;

1.44.5.1
date	97.05.12.10.52.14;	author hope;	state Exp;
branches
	1.44.5.1.1.1
	1.44.5.1.2.1
	1.44.5.1.3.1;
next	;

1.44.5.1.1.1
date	97.07.28.18.34.02;	author daveb;	state Exp;
branches
	1.44.5.1.1.1.1.1;
next	;

1.44.5.1.1.1.1.1
date	97.10.07.12.00.01;	author jkbrook;	state Exp;
branches;
next	;

1.44.5.1.2.1
date	97.09.08.17.27.07;	author daveb;	state Exp;
branches;
next	;

1.44.5.1.3.1
date	97.09.09.14.24.04;	author daveb;	state Exp;
branches;
next	;

1.44.6.1
date	97.09.10.19.42.57;	author brucem;	state Exp;
branches;
next	;

1.44.7.1
date	97.09.11.21.10.26;	author daveb;	state Exp;
branches;
next	;

1.44.8.1
date	99.04.01.18.08.54;	author daveb;	state Exp;
branches;
next	;


desc
@Type checking of patterns
@


1.44
log
@[Bug #1614]
basifying String
@
text
@(* _patterns.sml the functor *)
(*
$Log: _patterns.sml,v $
 * Revision 1.43  1996/04/30  15:51:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.42  1995/12/27  12:38:53  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.41  1995/09/08  15:43:09  daveb
Added new types for different sizes of ints, words and reals.

Revision 1.40  1995/08/31  13:41:11  jont
Add location info to wild pats

Revision 1.39  1995/06/09  10:16:21  daveb
Removed quotes around reconstructed source in error messagess.

Revision 1.38  1995/05/02  10:59:23  matthew
Removing polyvariable debugging

Revision 1.37  1995/02/13  11:46:28  matthew
Debugger changes

Revision 1.36  1995/02/06  14:57:45  matthew
Removing debug stuff

Revision 1.35  1995/01/04  12:23:48  matthew
Renaming debugger_env to runtime_env

Revision 1.34  1994/09/22  16:06:26  matthew
Abstraction of debug information

Revision 1.33  1994/05/04  16:42:41  daveb
Added location argument to lookup_val.

Revision 1.32  1994/02/22  01:58:23  nosa
Type function spills for Modules Debugger.

Revision 1.31  1994/02/08  12:01:23  nickh
Found a way to generate some 'impossible' type errors.

Revision 1.30  1993/12/16  11:39:23  matthew
Renamed Basis.level to Basis.context_level

Revision 1.29  1993/12/02  17:36:56  nickh
Removed old debugging code, fixup a couple of error messages.

Revision 1.28  1993/11/30  14:48:50  nickh
Marked certain error messages as "impossible".

Revision 1.27  1993/11/25  12:14:58  nickh
Added code to encode type errors as a list of strings and types.

Revision 1.26  1993/11/25  09:36:42  matthew
Added absyn annotations

Revision 1.25  1993/09/17  10:14:58  nosa
Compilation-instance recording in VALpats and LAYEREDpats
for polymorphic debugger.

Revision 1.24  1993/08/09  16:31:40  jont
Added context printing for unification errors

Revision 1.23  1993/03/10  15:25:20  matthew
Options changes

Revision 1.22  1993/03/09  11:43:11  matthew
Options & Info changes

Revision 1.21  1993/03/02  15:46:01  matthew
empty_rec_type to empty_rectype

Revision 1.20  1993/02/22  15:17:12  matthew
Changed Completion interface

Revision 1.19  1993/02/08  18:47:43  matthew
Changes for BASISTYPES signature

Revision 1.18  1993/02/04  16:51:37  matthew
Sharing changes

Revision 1.17  1992/12/22  15:51:42  jont
Anel's last changes

Revision 1.16  1992/12/10  19:00:46  matthew
Neatened up error messages so types align.

Revision 1.15  1992/12/04  13:40:54  matthew
Error message revision

Revision 1.14  1992/12/02  16:49:12  jont
Error message improvements

Revision 1.13  1992/11/26  17:29:36  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.12  1992/11/05  09:52:25  matthew
Changed Error structure to Info

Revision 1.11  1992/09/08  17:22:55  matthew
Added locations to errors.

Revision 1.10  1992/09/04  09:31:09  richard
Installed central error reporting mechanism.

Revision 1.9  1992/08/12  10:38:33  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.8  1992/08/04  12:23:38  jont
Anel's changes to use NewMap instead of Map

Revision 1.7  1992/07/22  12:30:47  jont
Removed references to Lists.foldl and Lists.foldr

Revision 1.6  1992/06/15  10:35:56  clive
Added the printing of the name of the relevant identifier in a couple of error messages

Revision 1.5  1992/04/07  14:53:43  jont
Removed on the fly calculation of valenv for METATYNAMEs. This is
now done properly during signature elaboration in _mod_rules,
and encoded in the .mo files

Revision 1.4  1992/01/27  20:01:36  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.3  1992/01/27  11:03:33  jont
Updated to calculate the valenv for METATYNAMES in VALpat and APPpat

Revision 1.2  1991/11/21  19:04:15  jont
Added copyright message. Fixed a sharing constraint appearing before
the structure it referenced

Revision 1.1  91/06/07  11:36:52  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/print";
require "../utils/lists";
require "../utils/crash";
require "../basics/identprint";
require "../typechecker/basis";
require "../typechecker/types";
require "../typechecker/tyenv";
require "../typechecker/environment";
require "../typechecker/scheme";
require "../typechecker/valenv";
require "../typechecker/type_exp";
require "../typechecker/completion";
require "../typechecker/control_unify";
require "../typechecker/context_print";
require "../debugger/runtime_env";

require "../typechecker/patterns";

functor Patterns(
  structure IdentPrint : IDENTPRINT
  structure Types : TYPES
  structure Basis : BASIS
  structure Tyenv : TYENV
  structure Env : ENVIRONMENT
  structure Scheme : SCHEME
  structure Valenv : VALENV
  structure Type_exp : TYPE_EXP
  structure Completion : COMPLETION
  structure Control_Unify : CONTROL_UNIFY
  structure Context_Print : CONTEXT_PRINT
  structure Print : PRINT
  structure Lists : LISTS
  structure Crash : CRASH
  structure RuntimeEnv : RUNTIMEENV

  sharing Control_Unify.Info = Type_exp.Info
  sharing Control_Unify.BasisTypes = Basis.BasisTypes = Type_exp.BasisTypes
  sharing Types.Datatypes = Scheme.Datatypes = Valenv.Datatypes =
    Completion.Datatypes = Env.Datatypes = Tyenv.Datatypes = Basis.BasisTypes.Datatypes
  sharing Types.Datatypes.Ident = IdentPrint.Ident
  sharing Completion.Options = IdentPrint.Options = Types.Options = Control_Unify.Options
  sharing Context_Print.Absyn = Type_exp.Absyn
  sharing Completion.Options = Context_Print.Options
  sharing type Type_exp.Absyn.RuntimeInfo = RuntimeEnv.RuntimeInfo
  sharing type Types.Datatypes.Type = RuntimeEnv.Type
  sharing type Types.Datatypes.Instance = Type_exp.Absyn.Instance = RuntimeEnv.Instance
    ) : PATTERNS =
  
  struct
    structure Absyn = Type_exp.Absyn
    structure BasisTypes = Basis.BasisTypes
    structure Info = Type_exp.Info
    structure Options = Completion.Options
    structure Datatypes = Types.Datatypes

    open Datatypes

    (***** Generate a fresh type variable *****)

    fun fresh_tyvar acontext =
      METATYVAR (ref (Basis.context_level acontext, NULLTYPE,NO_INSTANCE), false, false)

    (***** Inject a type into a typescheme *****)

    fun in_scheme atype =
      Scheme.make_scheme ([], atype)

    (***** Find the local context in a pattern *****)

    local
      (***** Add together two environments (infix operator) *****)
      
      infix &&

      fun ve1 && ve2 = Valenv.ve_plus_ve (ve1, ve2)

      fun singleVE (valid, ts) =
	Valenv.add_to_ve (valid, ts, empty_valenv)
    in
      fun pat_context (Absyn.WILDpat _) = empty_valenv
	| pat_context (Absyn.SCONpat _) = empty_valenv
	| pat_context (Absyn.VALpat ((Ident.LONGVALID (_, valid), (ref ty,_)),_)) =
	  singleVE (valid, UNBOUND_SCHEME (ty,NONE))
	| pat_context (Absyn.RECORDpat (fields, _, _)) =
	  Lists.reducel
	  (fn (res, (_, pat)) => pat_context pat && res)
	  (empty_valenv, fields)
	| pat_context (Absyn.APPpat ((Ident.LONGVALID (_,valid),ref ty),pat,_,_)) =
	  singleVE (valid, UNBOUND_SCHEME (ty,NONE)) && pat_context pat
	| pat_context (Absyn.TYPEDpat (pat, _,_)) =	pat_context pat
	| pat_context (Absyn.LAYEREDpat ((valid, (ref ty,_)), pat)) =
	  singleVE (valid, UNBOUND_SCHEME (ty,NONE)) && pat_context pat
    end

  (* location information *)

    fun near (opts, pat) =
      Datatypes.Err_String
      (concat ["\nNear: ", Context_Print.pat_to_string opts pat])

    fun check_pat 
      (error_info,options as Options.OPTIONS{print_options,
            compiler_options = Options.COMPILEROPTIONS{generate_moduler,...},...}) args =
      let
        val report_error = Info.error error_info
        fun report_strid_error (location,print_options,strid,lvalid) =
          report_error
          (Info.RECOVERABLE, 
           location,
           IdentPrint.valid_unbound_strid_message (strid,lvalid,print_options))

        val check_type = Type_exp.check_type error_info
        val unify = Control_Unify.unify (error_info,options)

    (***** rule 33 *****)
	
    fun check_pat (Absyn.WILDpat _, acontext) =
	(empty_valenv, fresh_tyvar acontext, [])

      (***** rule 34 *****)
    
      | check_pat (Absyn.SCONpat (scon, type_ref), acontext) =
	let
	  val ty = Types.type_of scon
	in
	  type_ref := ty;
	  (empty_valenv, ty, [])
	end
	   
      (***** rule 35 *****)
      
      | check_pat (Absyn.VALpat ((Ident.LONGVALID (_, aval as (Ident.VAR _)),
				 (stuff as (type_ref,info_ref))),_),
		   acontext) =
	let 
	  val new_ty = fresh_tyvar acontext
          val instance' = ref NO_INSTANCE
          val instance = NONE
	in
	  type_ref := new_ty;
          info_ref := RuntimeEnv.RUNTIMEINFO (SOME instance',nil);
	  (Valenv.add_to_ve (aval, in_scheme (new_ty,instance), empty_valenv),
	   new_ty, [stuff])
	end
	 
      (***** rule 36 *****)

      | check_pat (Absyn.VALpat ((lvalid as Ident.LONGVALID (_,Ident.CON _), (type_ref,info_ref)),
                                 location),
		   acontext) =
	let fun error_return () = 
	  let 
            val alpha = fresh_tyvar acontext
	  in 
            (type_ref := alpha; 
             (empty_valenv, alpha, []))
	  end 
	in
	  let 
	    val atype =
	      #1(Basis.lookup_val (lvalid, acontext, location, generate_moduler))
	  in
	    if Types.cons_typep atype then
	      (type_ref := atype;
	       (empty_valenv, atype, []))
	    else
	      (report_error
	       (Info.RECOVERABLE, location,
		concat ["Value constructor ",
			 IdentPrint.printLongValId print_options lvalid,
			 " used without argument in pattern"]);
	       error_return())
	  end
	handle Basis.LookupValId valid =>
	  (report_error (Info.RECOVERABLE, location,
                         IdentPrint.unbound_longvalid_message (valid,lvalid,"constructor",print_options));
           error_return ())
          | Basis.LookupStrId strid =>
              (report_strid_error (location,print_options,strid,lvalid);
               error_return ())
	end
       
      (***** rule 37 *****)

      | check_pat (Absyn.VALpat ((lvalid as Ident.LONGVALID (_,Ident.EXCON _), (type_ref,_)),location),
		   acontext) =

	let
	  val atype =
	    #1(Basis.lookup_val (lvalid, acontext, location, generate_moduler))
	    handle Basis.LookupValId valid =>
              (report_error
	       (Info.RECOVERABLE, location,
                IdentPrint.unbound_longvalid_message (valid,lvalid,"exception",print_options));
	       Types.exn_type)
                 | Basis.LookupStrId strid =>
                     (report_strid_error (location,print_options,strid,lvalid);
                      Types.exn_type)
	in
	  if Types.type_eq (atype, Types.exn_type, true, true) 
            then
              (type_ref := atype;
               (empty_valenv, atype, []))
	  else
            (report_error
	     (Info.RECOVERABLE, location,
	      concat ["Exception constructor ",
		       IdentPrint.printLongValId print_options lvalid,
		       " used without argument in pattern"]); 
             type_ref := Types.exn_type;
             (empty_valenv, Types.exn_type, []))
	end

      (***** rules 38, 40 and 41 *****)

      | check_pat (Absyn.RECORDpat (apatrowlist, flexp, type_ref), acontext) =

	let 
	  fun check_pat_row ([], acontext) = 
	      (empty_valenv, Types.empty_rectype, [])
	    | check_pat_row ((alab, apat) :: patrowlist, acontext) = 
	      let 
		val (ve1, atype1, pat_ty) = check_pat (apat, acontext)
		val (ve2, atype2, pat_tys) = check_pat_row (patrowlist, acontext)
	      in
		(Valenv.ve_plus_ve (ve1, ve2),
		 Types.add_to_rectype (alab, atype1, atype2),
                 pat_ty@@pat_tys)
	      end

	  val (new_ve, arectype, pat_tys) = check_pat_row (apatrowlist, acontext)
	in
	  (new_ve,
	   if flexp then
	     let
	       val metarectype = 
		 METARECTYPE (ref (Basis.context_level acontext,
				   true, arectype, false, false))
	     in
	       type_ref := metarectype;
	       metarectype
	     end
	   else
	     (type_ref := arectype;
	      arectype),
             pat_tys)
	end

      (***** rules 39 and 42 are parsed away *****)
      
      (***** rules 43 and 44 *****)
     
      | check_pat (fun_arg as Absyn.APPpat ((lvalid,type_ref), apat,location,_), acontext) =

	let
	  exception unsplit
	  val (new_ve, atype2, pat_ty2) = check_pat (apat, acontext)
	in
	  let
	    fun split (FUNTYPE (arg, res)) = (arg, res)
	      | split (_) = raise unsplit

	    val (arg, res) =
	      split (#1(Basis.lookup_val (lvalid, acontext, location, generate_moduler)))
	      handle Basis.LookupValId valid =>
                (report_error
                 (Info.RECOVERABLE, location,
                  IdentPrint.unbound_longvalid_message (valid,lvalid,"constructor",print_options));
		 (fresh_tyvar acontext, fresh_tyvar acontext))
          | Basis.LookupStrId strid =>
              (report_strid_error (location,print_options,strid,lvalid);
               (fresh_tyvar acontext, fresh_tyvar acontext))

	    val result_type = 
	      unify
	      {
	       first = arg, second = atype2, result = res,
	       context = acontext,
               error = fn () =>
               (location,
                [Datatypes.Err_String "Constructor applied to argument of wrong type",
		 near (print_options, fun_arg),
		 Datatypes.Err_String "\n  Required argument type: ",
		 Datatypes.Err_Type arg,
		 Datatypes.Err_String "\n  Actual argument type:   ",
		 Datatypes.Err_Type atype2],
                res)
	      }
	  in
	    type_ref := FUNTYPE (arg, result_type);
	    (new_ve, result_type, pat_ty2)
	  end
	  handle unsplit =>
            (report_error
             (Info.RECOVERABLE, location,
	      concat ["Nullary value constructor ",
		       IdentPrint.printLongValId print_options lvalid,
		       " applied to argument in pattern"]);
	     (new_ve, fresh_tyvar acontext, []))
	end
	   
      (***** rule 45 *****)
     
      | check_pat (arg as Absyn.TYPEDpat (apat, aty,location), acontext) =

	let 
	  val (new_ve, atype, pat_type) = check_pat (apat, acontext)
	  val ty_exp_ty = check_type (aty, acontext)
	in
	  (new_ve,
	   (unify
	    {
	     first = atype, second = ty_exp_ty, result = atype,
	     context = acontext,
             error = fn () =>
               (location,
		[Datatypes.Err_String "Types of pattern and constraint do not agree",
		 near (print_options,arg),
		 Datatypes.Err_String "\n  Pattern type:    ",
		 Datatypes.Err_Type atype,
		 Datatypes.Err_String "\n  Constraint type: ",
		 Datatypes.Err_Type ty_exp_ty],
                ty_exp_ty)
            }),
           pat_type)
	end

      (***** rule 46 *****)

      | check_pat (Absyn.LAYEREDpat ((avar, stuff as (type_ref,info_ref)), apat), acontext) =

	let
	  val (new_ve, pat_type, pat_type') = check_pat (apat, acontext)
          val instance' = ref(NO_INSTANCE)
          val instance = NONE
	in
	  type_ref := pat_type;
          info_ref := RuntimeEnv.RUNTIMEINFO (SOME (instance'),nil);
	  (Valenv.add_to_ve (avar, in_scheme (pat_type,instance), new_ve),
	   pat_type,
           pat_type'@@[stuff])
	end
      | check_pat _ = Crash.impossible "TYCON':check_pat:patterns"
      in
        check_pat args
      end
  end
@


1.44.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.44  1996/10/29  13:44:06  io
 * [Bug #1614]
 * basifying String
 *
@


1.44.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.44  1996/10/29  13:44:06  io
 * [Bug #1614]
 * basifying String
 *
@


1.44.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.44  1996/10/29  13:44:06  io
 * [Bug #1614]
 * basifying String
 *
@


1.44.5.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/10/29  13:44:06  io
 * [Bug #1614]
 * basifying String
 *
@


1.44.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.44.5.1  1997/05/12  10:52:14  hope
 * branched from 1.44
 *
@


1.44.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.44.5.1  1997/05/12  10:52:14  hope
 * branched from 1.44
 *
@


1.44.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.44.5.1  1997/05/12  10:52:14  hope
 * branched from 1.44
 *
@


1.44.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.44.5.1.1.1  1997/07/28  18:34:02  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.44.4.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/10/29  13:44:06  io
 * [Bug #1614]
 * basifying String
 *
@


1.44.3.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/10/29  13:44:06  io
 * [Bug #1614]
 * basifying String
 *
@


1.44.3.1.1.1
log
@branched from 1.44.3.1
@
text
@a3 3
 * Revision 1.44.3.1  1996/12/17  18:18:41  hope
 * branched from 1.44
 *
@


1.44.2.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/10/29  13:44:06  io
 * [Bug #1614]
 * basifying String
 *
@


1.44.1.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/10/29  13:44:06  io
 * [Bug #1614]
 * basifying String
 *
@


1.44.1.1.1.1
log
@branched from 1.44.1.1
@
text
@a3 3
 * Revision 1.44.1.1  1996/11/14  13:22:19  hope
 * branched from 1.44
 *
@


1.43
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d228 1
a228 1
	  singleVE (valid, UNBOUND_SCHEME (ty,MLWorks.Option.NONE))
d234 1
a234 1
	  singleVE (valid, UNBOUND_SCHEME (ty,MLWorks.Option.NONE)) && pat_context pat
d237 1
a237 1
	  singleVE (valid, UNBOUND_SCHEME (ty,MLWorks.Option.NONE)) && pat_context pat
d244 1
a244 1
      (String.implode ["\nNear: ", Context_Print.pat_to_string opts pat])
d283 1
a283 1
          val instance = MLWorks.Option.NONE
d286 1
a286 1
          info_ref := RuntimeEnv.RUNTIMEINFO (MLWorks.Option.SOME instance',nil);
d314 1
a314 1
		String.implode ["Value constructor ",
d352 1
a352 1
	      String.implode ["Exception constructor ",
d441 1
a441 1
	      String.implode ["Nullary value constructor ",
d480 1
a480 1
          val instance = MLWorks.Option.NONE
d483 1
a483 1
          info_ref := RuntimeEnv.RUNTIMEINFO (MLWorks.Option.SOME (instance'),nil);
@


1.43.3.1
log
@branched from 1.43
@
text
@a3 6
 * Revision 1.43  1996/04/30  15:51:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.43.2.1
log
@branched from 1.43
@
text
@a3 6
 * Revision 1.43  1996/04/30  15:51:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.43.1.1
log
@branched from 1.43
@
text
@a3 6
 * Revision 1.43  1996/04/30  15:51:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.42
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d238 1
a238 1
      (implode ["\nNear: ", Context_Print.pat_to_string opts pat])
d308 1
a308 1
		implode ["Value constructor ",
d346 1
a346 1
	      implode ["Exception constructor ",
d435 1
a435 1
	      implode ["Nullary value constructor ",
@


1.41
log
@Added new types for different sizes of ints, words and reals.
@
text
@d4 3
a177 1
  sharing Types.Datatypes.Option = Type_exp.Absyn.Option = RuntimeEnv.Option
d219 1
a219 1
	  singleVE (valid, UNBOUND_SCHEME (ty,Option.ABSENT))
d225 1
a225 1
	  singleVE (valid, UNBOUND_SCHEME (ty,Option.ABSENT)) && pat_context pat
d228 1
a228 1
	  singleVE (valid, UNBOUND_SCHEME (ty,Option.ABSENT)) && pat_context pat
d274 1
a274 1
          val instance = Option.ABSENT
d277 1
a277 1
          info_ref := RuntimeEnv.RUNTIMEINFO (Option.PRESENT instance',nil);
d471 1
a471 1
          val instance = Option.ABSENT
d474 1
a474 1
          info_ref := RuntimeEnv.RUNTIMEINFO (Option.PRESENT (instance'),nil);
@


1.40
log
@Add location info to wild pats
@
text
@d4 3
d256 7
a262 2
      | check_pat (Absyn.SCONpat scon, acontext) =
	(empty_valenv, Types.type_of scon, [])
@


1.39
log
@Removed quotes around reconstructed source in error messagess.
@
text
@d4 3
d211 1
a211 1
      fun pat_context (Absyn.WILDpat) = empty_valenv
d248 1
a248 1
    fun check_pat (Absyn.WILDpat, acontext) =
@


1.38
log
@Removing polyvariable debugging
@
text
@d4 3
d227 1
a227 3
      (implode ["\nNear '",
		Context_Print.pat_to_string opts pat,
		"'"])
@


1.37
log
@Debugger changes
@
text
@d4 3
d230 1
a230 2
            compiler_options = Options.COMPILEROPTIONS{debug_polyvariables,
                                                       generate_moduler,...},...}) args =
d260 1
a260 5
          val instance = 
            if debug_polyvariables then 
              Option.PRESENT (instance',ref Option.ABSENT)
            else
              Option.ABSENT
d457 1
a457 5
          val instance = 
            if debug_polyvariables then 
              Option.PRESENT(instance',ref(Option.ABSENT))
            else
              Option.ABSENT
d460 1
a460 1
          info_ref := RuntimeEnv.RUNTIMEINFO (Option.PRESENT(instance'),nil);
@


1.36
log
@Removing debug stuff
@
text
@d4 3
d257 1
a257 1
          val instance' = ref(NO_INSTANCE)
d260 1
a260 1
              Option.PRESENT(instance',ref(Option.ABSENT))
d265 1
a265 1
          info_ref := RuntimeEnv.RUNTIMEINFO (Option.PRESENT(instance'),nil);
d276 5
a280 3
	  let val alpha = fresh_tyvar acontext
	  in (type_ref := alpha; 
              (empty_valenv, alpha, []))
@


1.35
log
@Renaming debugger_env to runtime_env
@
text
@d4 3
a123 1
require "../typechecker/ty_debug";
a148 1
  structure Ty_Debug : TY_DEBUG
a151 5
  structure Debug :
    sig
      val set_debug_level : int -> unit
      val debug_level : unit -> int
    end
a174 1
    val do_debug = Ty_Debug.do_debug
a213 15
    (*****
    Printing out of debugging information.
    *****)

    local
      fun print_list [] = Print.print "\n"
	| print_list (h :: t) = (Print.print h ; print_list t)
    in
      fun debug L value =
	if do_debug andalso Debug.debug_level () > 10 then
	  (print_list L ; value)
	else
	  value
    end

d228 6
d293 7
a299 7
	handle Basis.LookupValId_in_Context =>
	  (report_error
	   (Info.RECOVERABLE, location,
	    implode ["Unbound value ",
		     IdentPrint.printLongValId print_options lvalid,
		     " in pattern"]);
	   error_return ())
d310 1
a310 1
	    handle Basis.LookupValId_in_Context =>
d313 1
a313 3
		implode ["Unbound exception constructor ",
			 IdentPrint.printLongValId print_options lvalid,
			 " in pattern"]);
d315 3
d384 1
a384 2
	      handle Basis.LookupValId_in_Context =>
              (* don't believe this can happen -- caught by parser *)
d387 1
a387 3
		  implode ["Unbound constructor ",
			   IdentPrint.printLongValId print_options lvalid,
			   " in pattern"]);
d389 3
@


1.34
log
@Abstraction of debug information
@
text
@d4 3
d131 1
a131 1
require "../debugger/debugger_env";
@


1.33
log
@Added location argument to lookup_val.
@
text
@d4 3
d128 2
d153 1
d161 1
a161 2
  sharing Types.Datatypes.Option = Type_exp.Absyn.Option
  sharing type Types.Datatypes.Instance = Type_exp.Absyn.Instance
d164 3
d203 2
a204 2
	| pat_context (Absyn.VALpat ((Ident.LONGVALID (_, valid), ref ty),_)) =
	  singleVE (valid, UNBOUND_SCHEME (#1(ty),Option.ABSENT))
d212 2
a213 2
	| pat_context (Absyn.LAYEREDpat ((valid, ref ty), pat)) =
	  singleVE (valid, UNBOUND_SCHEME (#1(ty),Option.ABSENT)) && pat_context pat
d261 1
a261 1
				 type_ref),_),
d272 2
a273 1
	  type_ref := (new_ty,Option.PRESENT(instance'),nil);
d275 1
a275 1
	   new_ty, [type_ref])
d280 1
a280 2
      | check_pat (Absyn.VALpat ((lvalid as Ident.LONGVALID 
                                  (apath, acon as (Ident.CON _)), type_ref),
d285 2
a286 1
	  in (type_ref := (alpha,Option.ABSENT,[]) ; (empty_valenv, alpha, []))
d291 1
a291 2
	      #1(Basis.lookup_val
		   (apath, acon, acontext, location, generate_moduler))
d294 1
a294 1
	      (type_ref := (atype,Option.ABSENT,[]);
d315 1
a315 2
      | check_pat (Absyn.VALpat ((lvalid as Ident.LONGVALID 
				 (apath,anexcon as (Ident.EXCON _)), type_ref),location),
d320 1
a320 2
	    #1(Basis.lookup_val
	         (apath, anexcon, acontext, location, generate_moduler))
d329 4
a332 2
	  if Types.type_eq (atype, Types.exn_type, true, true) then
	    (type_ref := (atype,Option.ABSENT,nil) ; (empty_valenv, atype, []))
d339 1
a339 1
             type_ref := (Types.exn_type,Option.ABSENT,nil);
d382 1
a382 2
      | check_pat (fun_arg as Absyn.APPpat ((lvalid as Ident.LONGVALID (apath, aval),
				  type_ref), apat,location,_), acontext) =
d393 1
a393 2
	      split (#1(Basis.lookup_val
			  (apath, aval, acontext, location, generate_moduler)))
d459 1
a459 1
      | check_pat (Absyn.LAYEREDpat ((avar, type_ref), apat), acontext) =
d470 2
a471 1
	  type_ref := (pat_type,Option.PRESENT(instance'),nil);
d474 1
a474 1
           pat_type'@@[type_ref])
a480 8

(* syntactic constraint enforces Dom ve disjoint from Dom ve'.  Side
 condition on lab is enforced by construction.  Together these
 conditions mean order of extending ve and constructing rectype is not
 important *)



@


1.32
log
@Type function spills for Modules Debugger.
@
text
@d4 3
d281 3
a283 1
	    val atype = #1(Basis.lookup_val (apath, acon, acontext, generate_moduler))
d312 3
a314 1
	  val atype = #1(Basis.lookup_val (apath, anexcon, acontext, generate_moduler))
d385 3
a387 1
	    val (arg, res) = split (#1(Basis.lookup_val(apath, aval, acontext, generate_moduler)))
@


1.31
log
@Found a way to generate some 'impossible' type errors.
@
text
@d4 3
d109 1
d139 1
d153 1
a153 1
  sharing type Types.Datatypes.instance = Type_exp.Absyn.Instance
d230 2
a231 1
            compiler_options = Options.COMPILEROPTIONS{debug_polyvariables,...},...}) args =
d240 1
a240 1
	(empty_valenv, fresh_tyvar acontext)
d245 1
a245 1
	(empty_valenv, Types.type_of scon)
d261 1
a261 1
	  type_ref := (new_ty,Option.PRESENT(instance'));
d263 1
a263 1
	   new_ty)
d274 1
a274 1
	  in (type_ref := (alpha,Option.ABSENT) ; (empty_valenv, alpha))
d278 1
a278 1
	    val atype = #1(Basis.lookup_val (apath, acon, acontext))
d281 2
a282 2
	      (type_ref := (atype,Option.ABSENT);
	       (empty_valenv, atype))
d307 1
a307 1
	  val atype = #1(Basis.lookup_val (apath, anexcon, acontext))
d317 1
a317 1
	    (type_ref := (atype,Option.ABSENT) ; (empty_valenv, atype))
d324 2
a325 2
             type_ref := (Types.exn_type,Option.ABSENT);
             (empty_valenv, Types.exn_type))
d334 1
a334 1
	      (empty_valenv, Types.empty_rectype)
d337 2
a338 2
		val (ve1, atype1) = check_pat (apat, acontext)
		val (ve2, atype2) = check_pat_row (patrowlist, acontext)
d341 2
a342 1
		 Types.add_to_rectype (alab, atype1, atype2))
d345 1
a345 1
	  val (new_ve, arectype) = check_pat_row (apatrowlist, acontext)
d359 2
a360 1
	      arectype))
d372 1
a372 1
	  val (new_ve, atype2) = check_pat (apat, acontext)
d378 1
a378 1
	    val (arg, res) = split (#1(Basis.lookup_val(apath, aval, acontext)))
d405 1
a405 1
	    (new_ve, result_type)
d413 1
a413 1
	     (new_ve, fresh_tyvar acontext))
d421 1
a421 1
	  val (new_ve, atype) = check_pat (apat, acontext)
d438 2
a439 1
            }))
d447 1
a447 1
	  val (new_ve, pat_type) = check_pat (apat, acontext)
d455 1
a455 1
	  type_ref := (pat_type,Option.PRESENT(instance'));
d457 2
a458 1
	   pat_type)
d460 1
@


1.30
log
@Renamed Basis.level to Basis.context_level
@
text
@d4 3
d266 15
a280 8

	let 
	  val atype = #1(Basis.lookup_val (apath, acon, acontext))
	    handle Basis.LookupValId_in_Context =>
              (* don't believe this can happen -- caught by parser *)
              (report_error
               (Info.RECOVERABLE, location,
		implode ["impossible type error 10: Unbound value ",
d282 10
a291 17
			 " in pattern"]);
               fresh_tyvar acontext)
	in
	  if Types.cons_typep atype then
	    (type_ref := (atype,Option.ABSENT);
	     (empty_valenv, atype))
	  else
            (report_error
             (Info.RECOVERABLE, location,
	      implode ["Value constructor ",
		       IdentPrint.printLongValId print_options lvalid,
		       " used without argument in pattern"]);
             let
               val alpha = fresh_tyvar acontext
             in
               (type_ref := (alpha,Option.ABSENT) ; (empty_valenv, alpha))
             end)
a302 1
              (* don't believe this can happen -- caught by parser *)
d305 1
a305 1
		implode ["impossible type error 11: Unbound exception constructor ",
d375 1
a375 1
		  implode ["impossible type error 12: Unbound constructor ",
@


1.29
log
@Removed old debugging code, fixup a couple of error messages.
@
text
@d4 3
d163 1
a163 1
      METATYVAR (ref (Basis.level acontext, NULLTYPE,NO_INSTANCE), false, false)
d342 1
a342 1
		 METARECTYPE (ref (Basis.level acontext,
@


1.28
log
@Marked certain error messages as "impossible".
@
text
@d4 3
d213 1
a213 1
      (implode ["Near '",
a227 2
        debug ["check_pat 33"]

a232 2
	debug ["check_pat 34"]

a239 3

	debug ["check_pat 35"]

a260 2
	debug ["check_pat 36"]

a293 2
	debug ["check_pat 37"]

a320 2
	debug ["check_pat 38, 40, 41"]

a356 2
	debug ["check_pat 43 and 44"]

d382 1
a382 1
                [Datatypes.Err_String "Constructor applied to argument of wrong type ",
a406 2
	debug ["check_pat 45"]

a430 2

	debug ["check_pat 46"]
@


1.27
log
@Added code to encode type errors as a list of strings and types.
@
text
@d4 3
d273 1
a273 1
		implode ["Unbound value ",
d308 1
a308 1
		implode ["Unbound exception constructor ",
d382 1
a382 1
		  implode ["Unbound constructor ",
@


1.26
log
@Added absyn annotations
@
text
@d4 3
d146 1
d149 1
a149 1
    open Types.Datatypes
d203 7
d391 6
a396 6
                implode ["Constructor applied to argument of wrong type",
			 " near ' ", Context_Print.pat_to_string print_options fun_arg,
                         "'\n  Required argument type: ",
                         Completion.print_type(print_options,Basis.env_of_context acontext,arg),
                         "\n  Actual argument type:   ",
                         Completion.print_type (print_options,Basis.env_of_context acontext,atype2)],
d429 6
a434 6
                implode ["Types of pattern and constraint do not agree",
			 " near '", Context_Print.pat_to_string print_options arg,
                         "'\n  Pattern type:    ",
                         Completion.print_type (print_options,Basis.env_of_context acontext, atype),
                         "\n  Constraint type: ",
                         Completion.print_type (print_options,Basis.env_of_context acontext,ty_exp_ty)],
@


1.25
log
@Compilation-instance recording in VALpats and LAYEREDpats
for polymorphic debugger.
@
text
@d4 4
d177 1
a177 1
	| pat_context (Absyn.APPpat ((Ident.LONGVALID (_,valid),ref ty),pat,_)) =
d351 1
a351 1
				  type_ref), apat,location), acontext) =
@


1.24
log
@Added context printing for unification errors
@
text
@d4 3
d128 2
d146 1
a146 1
      METATYVAR (ref (Basis.level acontext, NULLTYPE), false, false)
d168 1
a168 1
	  singleVE (valid, UNBOUND_SCHEME ty)
d174 1
a174 1
	  singleVE (valid, UNBOUND_SCHEME ty) && pat_context pat
d177 1
a177 1
	  singleVE (valid, UNBOUND_SCHEME ty) && pat_context pat
d196 3
a198 1
    fun check_pat (error_info,options as Options.OPTIONS{print_options,...}) args =
d228 6
d235 2
a236 2
	  type_ref := new_ty;
	  (Valenv.add_to_ve (aval, in_scheme new_ty, empty_valenv),
d250 1
a250 1
	  val atype = Basis.lookup_val (apath, acon, acontext)
d261 1
a261 1
	    (type_ref := atype;
d272 1
a272 1
               (type_ref := alpha ; (empty_valenv, alpha))
d285 1
a285 1
	  val atype = Basis.lookup_val (apath, anexcon, acontext)
d296 1
a296 1
	    (type_ref := atype ; (empty_valenv, atype))
d303 1
a303 1
             type_ref := Types.exn_type;
d359 1
a359 1
	    val (arg, res) = split (Basis.lookup_val(apath, aval, acontext))
d432 6
d439 2
a440 2
	  type_ref := pat_type;
	  (Valenv.add_to_ve (avar, in_scheme pat_type, new_ve),
@


1.24.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.24  1993/08/09  16:31:40  jont
Added context printing for unification errors

@


1.23
log
@Options changes
@
text
@d4 3
d95 1
d109 1
d125 2
d333 1
a333 1
      | check_pat (Absyn.APPpat ((lvalid as Ident.LONGVALID (apath, aval),
d364 2
a365 1
                         "\n  Required argument type: ",
d386 1
a386 1
      | check_pat (Absyn.TYPEDpat (apat, aty,location), acontext) =
d402 2
a403 1
                         "\n  Pattern type:    ",
@


1.22
log
@Options & Info changes
@
text
@d4 3
d184 1
a184 1
    fun check_pat (error_info,print_options) args =
d188 1
a188 1
        val unify = Control_Unify.unify (error_info,print_options)
@


1.21
log
@empty_rec_type to empty_rectype
@
text
@d4 3
d111 1
d116 1
a116 1
  sharing Completion.Info = IdentPrint.Info = Basis.BasisTypes.Info
d122 2
a123 1
    structure Info = BasisTypes.Info
d181 1
a181 1
    fun check_pat options args =
d183 3
a185 3
        val report_error = Info.error options
        val check_type = Type_exp.check_type options
        val unify = Control_Unify.unify options
d233 1
a233 1
			 IdentPrint.printLongValId options lvalid,
d244 1
a244 1
		       IdentPrint.printLongValId options lvalid,
d268 1
a268 1
			 IdentPrint.printLongValId options lvalid,
d278 1
a278 1
		       IdentPrint.printLongValId options lvalid,
d342 1
a342 1
			   IdentPrint.printLongValId options lvalid,
d355 1
a355 1
                         Completion.print_type(options,Basis.env_of_context acontext,arg),
d357 1
a357 1
                         Completion.print_type (options,Basis.env_of_context acontext,atype2)],
d368 1
a368 1
		       IdentPrint.printLongValId options lvalid,
d392 1
a392 1
                         Completion.print_type (options,Basis.env_of_context acontext, atype),
d394 1
a394 1
                         Completion.print_type (options,Basis.env_of_context acontext,ty_exp_ty)],
@


1.20
log
@Changed Completion interface
@
text
@d4 3
d287 1
a287 1
	      (empty_valenv, Types.empty_rec_type)
@


1.19
log
@Changes for BASISTYPES signature
@
text
@d4 3
d347 1
a347 1
                         Completion.print_type options (Basis.env_of_context acontext) arg,
d349 1
a349 1
                         Completion.print_type options (Basis.env_of_context acontext) atype2],
d384 1
a384 1
                         Completion.print_type options (Basis.env_of_context acontext) atype,
d386 1
a386 1
                         Completion.print_type options (Basis.env_of_context acontext) ty_exp_ty],
@


1.18
log
@Sharing changes
@
text
@d4 3
d70 1
d85 1
d101 2
a102 1
  
d104 1
a104 2
    Completion.Datatypes = Type_exp.Absyn.Datatypes =
    Env.Datatypes = Tyenv.Datatypes
d106 1
a106 4
  sharing Control_Unify.Info.Location = Type_exp.Absyn.Location
  sharing Control_Unify.Info = Completion.Info = IdentPrint.Info =
    Type_exp.Info = Control_Unify.Info
  sharing Type_exp.Basis = Control_Unify.Basis
d111 3
a113 2
    structure Info = Type_exp.Info
    structure Basis = Type_exp.Basis
@


1.17
log
@Anel's last changes
@
text
@d4 3
a76 1
require "basis";
a78 2
  structure Print : PRINT
  structure Lists : LISTS
a79 1
  structure Ty_Debug : TY_DEBUG
d88 3
a90 1
  structure Basis : BASIS
a96 1
  sharing Type_exp.Info = Control_Unify.Info
d99 1
a99 1
    Env.Datatypes = Tyenv.Datatypes = Basis.Tyvarenv.Datatypes
d102 3
a104 2
  sharing Control_Unify.Info = Completion.Info = IdentPrint.Info
  sharing Basis = Type_exp.Basis = Control_Unify.Basis
d109 2
a110 2
    structure Info = Completion.Info
    structure Basis = Basis
@


1.16
log
@Neatened up error messages so types align.
@
text
@d4 3
d217 3
a219 3
                             implode ["Unbound value ",
                                      IdentPrint.printLongValId options lvalid,
                                      " in pattern"]);
d252 3
a254 3
                             implode ["Unbound exception constructor ",
                                      IdentPrint.printLongValId options lvalid,
                                      " in pattern"]);
d326 3
a328 3
                               implode ["Unbound constructor ",
                                        IdentPrint.printLongValId options lvalid,
                                        " in pattern"]);
@


1.15
log
@Error message revision
@
text
@d4 3
d336 1
a336 1
                         "\n  Required argument type:",
d338 1
a338 1
                         "\n  Actual argument type: ",
d373 1
a373 1
                         "\n  Pattern type: ",
@


1.14
log
@Error message improvements
@
text
@d4 3
d208 1
d211 1
a211 1
                             implode ["unbound value ",
d222 1
a222 1
	      implode ["constructor ",
d243 1
d246 1
a246 1
                             implode ["unbound exception constructor ",
d256 1
a256 1
	      implode ["exception constructor ",
d317 1
d320 1
a320 1
                               implode ["unbound constructor ",
d332 2
a333 1
                implode ["\nRequired argument type:",
d335 1
a335 1
                         "\nActual argument type: ",
d346 1
a346 1
	      implode ["nullary value constructor ",
d369 2
a370 1
                implode ["\npattern type: ",
d372 1
a372 1
                         "\nconstraint type: ",
@


1.13
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d214 1
a214 1
		(empty_valenv, atype))
d218 3
a220 1
                           "nullary value constructor expected in rule 36");          
d240 2
a241 2
               (Info.RECOVERABLE, location,
                             implode ["unbound exception ",
d244 1
a244 1
               Types.exn_type)
d250 4
a253 2
             (Info.RECOVERABLE, location,
                           "Error in pattern : nullary exception constructor expected in rule 37");
d300 1
a300 1
	debug ["check_pat 43"]
a303 1

d326 1
a326 2
                implode ["unification failed in rule 43",
                         "\nRequired argument type:",
d339 4
a342 3
                           implode ["Error in pattern: non-nullary value constructor expected in rule 43 ",
                                    IdentPrint.printLongValId options lvalid]);
             (new_ve, fresh_tyvar acontext))
d362 1
a362 2
                implode ["unification failure in rule 45",
                         "\nPattern type: ",
d364 1
a364 1
                         "\nConstraint type: ",
@


1.12
log
@Changed Error structure to Info
@
text
@d4 3
d89 1
d95 1
a95 1
    structure Info = Control_Unify.Info
d204 1
a204 1
                                      IdentPrint.printLongValId lvalid,
d236 1
a236 1
                                      IdentPrint.printLongValId lvalid,
d308 1
a308 1
                                        IdentPrint.printLongValId lvalid,
d321 1
a321 1
                         Completion.print_type (Basis.env_of_context acontext) arg,
d323 1
a323 1
                         Completion.print_type (Basis.env_of_context acontext) atype2],
d334 1
a334 1
                                    IdentPrint.printLongValId lvalid]);
d357 1
a357 1
                         Completion.print_type (Basis.env_of_context acontext) atype,
d359 1
a359 1
                         Completion.print_type (Basis.env_of_context acontext) ty_exp_ty],
@


1.11
log
@Added locations to errors.
@
text
@d4 3
d80 1
d85 1
a85 1
  sharing Control_Unify.Error.Location = Type_exp.Absyn.Location
d91 1
a91 1
    structure Error = Control_Unify.Error
d148 7
d197 2
a198 2
              (Error.report
               (Error.ERROR (Error.RECOVERABLE, location,
d201 1
a201 1
                                      " in pattern"]));
d208 3
a210 3
            (Error.report
             (Error.ERROR (Error.RECOVERABLE, location,
                           "nullary value constructor expected in rule 36"));          
d229 2
a230 2
              (Error.report
               (Error.ERROR (Error.RECOVERABLE, location,
d233 1
a233 1
                                      " in pattern"]));
d239 3
a241 3
            (Error.report
             (Error.ERROR (Error.RECOVERABLE, location,
                           "Error in pattern : nullary exception constructor expected in rule 37"));
d301 2
a302 2
                (Error.report
                 (Error.ERROR (Error.RECOVERABLE, location,
d305 1
a305 1
                                        " in pattern"]));
d309 1
a309 1
	      Control_Unify.unify
d327 2
a328 2
            (Error.report
             (Error.ERROR (Error.RECOVERABLE, location,
d330 1
a330 1
                                    IdentPrint.printLongValId lvalid]));
d342 1
a342 1
	  val ty_exp_ty = Type_exp.check_type (aty, acontext)
d345 1
a345 1
	   (Control_Unify.unify
d373 3
@


1.10
log
@Installed central error reporting mechanism.
@
text
@d4 3
d116 1
a116 1
	| pat_context (Absyn.VALpat (Ident.LONGVALID (_, valid), ref ty)) =
d122 1
a122 1
	| pat_context (Absyn.APPpat ((Ident.LONGVALID (_,valid),ref ty),pat)) =
d124 1
a124 1
	| pat_context (Absyn.TYPEDpat (pat, _)) =	pat_context pat
d160 2
a161 2
      | check_pat (Absyn.VALpat (Ident.LONGVALID (_, aval as (Ident.VAR _)),
				 type_ref),
d176 3
a178 2
      | check_pat (Absyn.VALpat (lvalid as Ident.LONGVALID 
				 (apath, acon as (Ident.CON _)), type_ref),
d187 1
a187 1
               (Error.ERROR (Error.RECOVERABLE, Error.Location.UNKNOWN, 
d198 1
a198 1
             (Error.ERROR (Error.RECOVERABLE, Error.Location.UNKNOWN,
d209 2
a210 2
      | check_pat (Absyn.VALpat (lvalid as Ident.LONGVALID 
				 (apath,anexcon as (Ident.EXCON _)), type_ref),
d219 1
a219 1
               (Error.ERROR (Error.RECOVERABLE, Error.Location.UNKNOWN,
d229 1
a229 1
             (Error.ERROR (Error.RECOVERABLE, Error.Location.UNKNOWN,
d275 1
a275 1
				  type_ref), apat), acontext) =
d291 1
a291 1
                 (Error.ERROR (Error.RECOVERABLE, Error.Location.UNKNOWN,
d303 1
a303 1
               (Error.Location.UNKNOWN,
d317 1
a317 1
             (Error.ERROR (Error.RECOVERABLE, Error.Location.UNKNOWN,
d325 1
a325 1
      | check_pat (Absyn.TYPEDpat (apat, aty), acontext) =
d339 1
a339 1
               (Error.Location.UNKNOWN,
@


1.9
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d52 1
d67 1
d75 2
a76 5
    Control_Unify.Errors.Basis.Tyvarenv.Datatypes =
    Completion.Datatypes =
    Type_exp.Absyn.Datatypes =
    Env.Datatypes = Tyenv.Datatypes
  sharing Type_exp.Basis = Control_Unify.Errors.Basis
d78 2
d84 2
a85 2
    structure Errors = Control_Unify.Errors
    structure Basis = Errors.Basis
d182 6
a187 4
	      Errors.announce_error acontext Errors.return_alpha
	      ["unbound value ",
	       IdentPrint.printLongValId lvalid,
	       " in pattern"]
d193 8
a200 7
	    let
	      val alpha =
		Errors.announce_error acontext Errors.return_alpha
		["nullary value constructor expected in rule 36"]
	    in
	      (type_ref := alpha ; (empty_valenv, alpha))
	    end
d214 6
a219 5
	      Errors.announce_error acontext 
	      (Errors.return_val Types.exn_type)
	      ["unbound exception ",
	       IdentPrint.printLongValId lvalid,
	       " in pattern"]
d224 5
a228 8
	    let
	      val exn =
		Errors.announce_error acontext 
		(Errors.return_val Types.exn_type)
		["Error in pattern : nullary exception constructor expected in rule 37"]
	    in
	      (type_ref := exn ; (empty_valenv, exn))
	    end
d285 6
a290 3
	      handle Basis.LookupValId_in_Context => 
		Errors.announce_error acontext
		(Errors.return_val
a291 5
		["unbound constructor ",
		 IdentPrint.printLongValId lvalid,
		 " in pattern"]

	    fun result_value () = Errors.return_val res
d298 9
a306 9
	       get_action = result_value,
	       get_error_messages = fn () =>
	       ["unification failed in rule 43",
		"\nRequired argument type : ",
		Completion.print_type (Basis.env_of_context acontext) arg,
		"\nActual argument type : ",
		Completion.print_type (Basis.env_of_context acontext) 
		atype2]
	       }
d312 5
a316 4
	    Errors.announce_error acontext
	    (Errors.return_val (new_ve, fresh_tyvar acontext))
	    ["Error in pattern : non-nullary value constructor expected in rule 43",
             IdentPrint.printLongValId lvalid]
a327 3

	  fun result_value () = Errors.return_val ty_exp_ty

d334 9
a342 9
	     get_action = result_value,
	     get_error_messages = fn () =>
	     ["unification failure in rule 45",
	      "\nPattern type : ",
	      Completion.print_type (Basis.env_of_context acontext) atype,
	      "\nConstraint type : ",
	      Completion.print_type (Basis.env_of_context acontext) 
	      ty_exp_ty]
	     }))
@


1.8
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d37 1
a37 4
require "../utils/crash";
require "../basics/symbol";
require "../basics/ident";
require "../basics/absyn";
a38 1
require "../typechecker/datatypes";
a43 1
require "../typechecker/basis";
a45 1
require "../typechecker/errors";
d52 1
a52 4
  structure Crash : CRASH
  structure Symbol : SYMBOL
  structure Ident : IDENT
  structure Absyn : ABSYN
a53 1
  structure Datatypes : DATATYPES
a58 1
  structure Basis : BASIS
a60 1
  structure Errors : ERRORS
d68 4
a71 3
  sharing Types.Datatypes = Datatypes = Scheme.Datatypes = Valenv.Datatypes =
    Basis.Datatypes = Type_exp.Datatypes = Completion.Datatypes =
    Errors.Datatypes = Control_Unify.Datatypes = Absyn.Datatypes =
d73 2
a74 6
  sharing Type_exp.Absyn = Absyn
  sharing Type_exp.Basis = Basis = Errors.Basis = Control_Unify.Basis
  sharing Control_Unify.Errors = Errors
  sharing Absyn.Set = Basis.Set
  sharing Ident = Absyn.IdentClass = Datatypes.Ident
  sharing Ident.Symbol = Symbol
d78 3
a80 4
    structure Datatypes = Datatypes
    structure Absyn = Absyn
    structure Basis = Basis

d82 1
a82 1
    open Datatypes
@


1.7
log
@Removed references to Lists.foldl and Lists.foldr
@
text
@d4 3
d117 1
a117 1
	Valenv.add_to_ve (valid, ts, Valenv.empty_valenv)
d119 2
a120 2
      fun pat_context (Absyn.WILDpat) = Valenv.empty_valenv
	| pat_context (Absyn.SCONpat _) = Valenv.empty_valenv
d126 1
a126 1
	  (Valenv.empty_valenv, fields)
d154 1
a154 1
	(Valenv.empty_valenv, fresh_tyvar acontext)
d161 1
a161 1
	(Valenv.empty_valenv, Types.type_of scon)
d175 1
a175 1
	  (Valenv.add_to_ve (aval, in_scheme new_ty, Valenv.empty_valenv),
d197 1
a197 1
		(Valenv.empty_valenv, atype))
d204 1
a204 1
	      (type_ref := alpha ; (Valenv.empty_valenv, alpha))
d226 1
a226 1
	    (type_ref := atype ; (Valenv.empty_valenv, atype))
d234 1
a234 1
	      (type_ref := exn ; (Valenv.empty_valenv, exn))
d246 1
a246 1
	      (Valenv.empty_valenv, Types.empty_rec_type)
@


1.6
log
@Added the printing of the name of the relevant identifier in a couple of error messages
@
text
@d4 3
d121 3
a123 3
	  Lists.foldl
	  (fn (_, pat) => fn res => pat_context pat && res)
	  Valenv.empty_valenv fields
@


1.5
log
@Removed on the fly calculation of valenv for METATYNAMEs. This is
now done properly during signature elaboration in _mod_rules,
and encoded in the .mo files
@
text
@d4 5
d317 2
a318 1
	    ["Error in [attern : non-nullary value constructor expected in rule 43"]
@


1.4
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
a185 33
	     (let
		val ty = case atype of
		  Datatypes.FUNTYPE(_, ty) => ty
		| Datatypes.CONSTYPE _ => atype
		| _ => Crash.impossible"CON id is not constructed type(1)"
		val valenv as Datatypes.VE(_, the_map) =
		  case ty of
		    Datatypes.CONSTYPE
		    (_, Datatypes.TYNAME{5=ref valenv, ...}) =>
		      valenv
		  | Datatypes.CONSTYPE
		    (_, Datatypes.METATYNAME{2=str, 5=r as ref ve, ...}) =>
		      let
			val Datatypes.ENV(_, te, _, _) =
			  Ident.followPath
			  Env.find_env (apath, Basis.env_of_context acontext)
			val Datatypes.TYSTR(_, valenv) =
			  Tyenv.lookup(Ident.TYCON(Symbol.find_symbol str),
				       te)
		      in
			(r := valenv;
			 valenv)
		      end
		  | _ => Crash.impossible"CON id is not constructed type(2)"
	      in
		()
		(*
		Print.print"Found valenv with valids\n";
		Lists.iterate
		(fn (v, _) => Print.print(IdentPrint.printValId v ^ "\n"))
		(Mapping.assoc the_map)
		 *)
	      end);
a306 34

	   (case aval of
	      Ident.CON _ =>
		let
		  val valenv as Datatypes.VE(_, the_map) =
		    case result_type of
		      Datatypes.CONSTYPE
		      (_, Datatypes.TYNAME{5=ref valenv, ...}) =>
			valenv
		    | Datatypes.CONSTYPE
		      (_, Datatypes.METATYNAME{2=str, 5=r as ref ve, ...}) =>
			let
			  val Datatypes.ENV(_, te, _, _) =
			    Ident.followPath
			    Env.find_env (apath, Basis.env_of_context acontext)
			  val Datatypes.TYSTR(_, valenv) =
			    Tyenv.lookup(Ident.TYCON(Symbol.find_symbol str),
					 te)
			in
			  (r := valenv;
			   valenv)
			end
		    | _ => Crash.impossible"CON id is not constructed type(2)"
		in
		  ()
		  (*
		  Print.print"Found valenv with valids\n";
		  Lists.iterate
		  (fn (v, _) => Print.print(IdentPrint.printValId v ^ "\n"))
		  (Mapping.assoc the_map)
		   *)
		end
	    | _ => ());

@


1.3
log
@Updated to calculate the valenv for METATYNAMES in VALpat and APPpat
@
text
@d4 3
d16 1
d23 1
d37 24
a60 35
functor Patterns
  (structure Print : PRINT
   structure Lists : LISTS
   structure Crash : CRASH
   structure Symbol : SYMBOL
   structure Ident : IDENT
   structure Absyn : ABSYN
   structure Datatypes : DATATYPES
   structure Types : TYPES
   structure Tyenv : TYENV
   structure Env : ENVIRONMENT
   structure Scheme : SCHEME
   structure Valenv : VALENV
   structure Basis : BASIS
   structure Type_exp : TYPE_EXP
   structure Completion : COMPLETION
   structure Errors : ERRORS
   structure Control_Unify : CONTROL_UNIFY
   structure Debug :
     sig
       val set_debug_level : int -> unit
       val debug_level : unit -> int
     end

   sharing Types.Datatypes = Datatypes = Scheme.Datatypes = Valenv.Datatypes =
     Basis.Datatypes = Type_exp.Datatypes = Completion.Datatypes =
     Errors.Datatypes = Control_Unify.Datatypes = Absyn.Datatypes =
     Env.Datatypes = Tyenv.Datatypes
   sharing Type_exp.Absyn = Absyn
   sharing Type_exp.Basis = Basis = Errors.Basis = Control_Unify.Basis
   sharing Control_Unify.Errors = Errors
   sharing Absyn.Set = Basis.Set
   sharing Ident = Absyn.IdentClass = Datatypes.Ident
   sharing Ident.Symbol = Symbol
   ) : PATTERNS =
d62 12
d79 1
d128 1
a128 1
	if Debug.debug_level () > 10 then
@


1.2
log
@Added copyright message. Fixed a sharing constraint appearing before
the structure it referenced
@
text
@d3 5
a7 1
$Log:	_patterns.sml,v $
d15 4
d21 2
a29 1
require "../basics/absyn";
d35 4
d41 2
a49 1
   structure Absyn : ABSYN
d58 2
a59 1
     Errors.Datatypes = Control_Unify.Datatypes = Absyn.Datatypes
d64 2
d174 35
a208 1
	    (type_ref := atype ; (Valenv.empty_valenv, atype))
d329 34
@


1.1
log
@Initial revision
@
text
@d1 1
d3 5
a7 1
$Log$
a25 1

a26 1

a27 2
   sharing Types.Datatypes = Datatypes

a28 2
   sharing Scheme.Datatypes = Datatypes

a29 2
   sharing Valenv.Datatypes = Datatypes

a30 2
   sharing Basis.Datatypes = Datatypes

a31 4
   sharing Type_exp.Datatypes = Datatypes
   sharing Type_exp.Absyn = Absyn
   sharing Type_exp.Basis = Basis

a32 2
   sharing Completion.Datatypes = Datatypes

a33 3
   sharing Errors.Datatypes = Datatypes
   sharing Errors.Basis = Basis

a34 4
   sharing Control_Unify.Errors = Errors
   sharing Control_Unify.Datatypes = Datatypes
   sharing Control_Unify.Basis = Basis

a35 3
   sharing Absyn.Datatypes = Datatypes
   sharing Absyn.Set = Basis.Set

d41 8
@
