head	1.60;
access;
symbols
	MLW_daveb_inline_1_4_99:1.60.1
	MLWorks_21c0_1999_03_25:1.60
	MLWorks_20c1_1998_08_20:1.59
	MLWorks_20c0_1998_08_04:1.59
	MLWorks_20b2c2_1998_06_19:1.59
	MLWorks_20b2_Windows_1998_06_12:1.59
	MLWorks_20b1c1_1998_05_07:1.59
	MLWorks_20b0_1998_04_07:1.59
	MLWorks_20b0_1998_03_20:1.59
	MLWorks_20m2_1998_02_16:1.59
	MLWorks_20m1_1997_10_23:1.59
	MLWorks_11r1:1.58.5.1.1.1.1
	MLWorks_workspace_97:1.59.2
	MLWorks_dt_wizard:1.59.1
	MLWorks_11c0_1997_09_09:1.58.5.1.1.1
	MLWorks_10r3:1.58.5.1.3
	MLWorks_10r2_551:1.58.5.1.2
	MLWorks_11:1.58.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.58.5.1
	MLWorks_20m0_1997_06_20:1.59
	MLWorks_1_0_r2c2_1997_06_14:1.58.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.58.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.58.5
	MLWorks_BugFix_1997_04_24:1.58
	MLWorks_1_0_r2_Win32_1997_04_11:1.58
	MLWorks_1_0_r2_Unix_1997_04_04:1.58
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.58.3.1.1
	MLWorks_gui_1996_12_18:1.58.4
	MLWorks_1_0_Win32_1996_12_17:1.58.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.58.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.58.1.1
	MLWorks_1_0_Irix_1996_11_28:1.58.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.58.2
	MLWorks_1_0_Unix_1996_11_14:1.58.1
	MLWorks_Open_Beta2_1996_10_11:1.56.3
	MLWorks_License_dev:1.56.2
	MLWorks_1_open_beta_1996_09_13:1.56.1
	MLWorks_Open_Beta_1996_08_22:1.56
	MLWorks_Beta_1996_07_02:1.56
	MLWorks_Beta_1996_06_07:1.56
	MLWorks_Beta_1996_06_06:1.56
	MLWorks_Beta_1996_06_05:1.56
	MLWorks_Beta_1996_06_03:1.56
	MLWorks_Beta_1996_05_31:1.56
	MLWorks_Beta_1996_05_30:1.56
	ML_beta_release_12/08/94:1.47
	ML_beta_release_03/08/94:1.47
	ML_revised_beta_release_25/05/94:1.47
	ML_final_beta_release_02/03/94:1.47
	mlworks-28-01-1994:1.46
	Release:1.44
	mlworks-beta-01-09-1993:1.44
	MLWorks-1-0-4-29/01/1993:1.33
	MLWorks-1-0-3-21/12/1992:1.33
	MLWorks-1-0-2-15/12/1992:1.33
	MLWorks-1-0-1-04/12/1992:1.33
	checkpoint_17_08_92:1.16
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.60
date	99.02.02.16.01.43;	author mitchell;	state Exp;
branches
	1.60.1.1;
next	1.59;

1.59
date	97.05.01.12.53.24;	author jont;	state Exp;
branches
	1.59.1.1
	1.59.2.1;
next	1.58;

1.58
date	96.11.06.11.32.52;	author matthew;	state Exp;
branches
	1.58.1.1
	1.58.2.1
	1.58.3.1
	1.58.4.1
	1.58.5.1;
next	1.57;

1.57
date	96.10.28.17.05.11;	author io;	state Exp;
branches;
next	1.56;

1.56
date	96.04.30.16.00.25;	author jont;	state Exp;
branches
	1.56.1.1
	1.56.2.1
	1.56.3.1;
next	1.55;

1.55
date	96.04.29.14.02.12;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	96.02.26.11.31.06;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	96.02.23.17.10.56;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	95.10.20.10.08.33;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	95.03.24.15.23.22;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	95.02.07.16.39.01;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	94.10.13.11.04.37;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	94.10.06.11.54.50;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	94.02.28.06.20.47;	author nosa;	state Exp;
branches;
next	1.46;

1.46
date	93.12.15.13.31.25;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	93.12.02.17.34.58;	author nickh;	state Exp;
branches;
next	1.44;

1.44
date	93.07.08.13.51.22;	author nosa;	state Exp;
branches
	1.44.1.1;
next	1.43;

1.43
date	93.07.01.14.31.30;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	93.06.25.19.40.08;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	93.06.23.15.28.41;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	93.05.28.13.44.20;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	93.05.25.14.50.15;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	93.05.18.18.10.29;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	93.04.19.16.05.25;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	93.03.02.14.37.17;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	93.02.25.14.20.05;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	93.01.27.12.23.23;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	92.12.02.16.24.12;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	92.12.01.20.11.15;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	92.11.26.17.32.50;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	92.10.30.14.12.35;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	92.10.29.18.27.26;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	92.10.27.18.58.39;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	92.10.15.15.57.15;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.10.12.11.28.24;	author clive;	state Exp;
branches;
next	1.25;

1.25
date	92.09.21.11.41.20;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.09.15.15.41.28;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.09.15.15.18.48;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.09.11.16.00.49;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.09.11.12.56.35;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	92.09.01.16.22.08;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.08.27.14.27.50;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.08.20.18.46.32;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.08.18.14.42.18;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.08.13.17.26.59;	author davidt;	state Exp;
branches;
next	1.15;

1.15
date	92.08.12.10.54.54;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.08.06.14.30.40;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.08.04.19.12.42;	author davidt;	state Exp;
branches;
next	1.12;

1.12
date	92.08.04.15.44.02;	author davidt;	state Exp;
branches;
next	1.11;

1.11
date	92.07.17.15.42.54;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.07.16.13.24.37;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.07.15.13.34.09;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.07.06.10.49.30;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.06.26.17.44.51;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.04.16.15.22.59;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.04.16.14.20.26;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.04.14.17.24.04;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.01.27.19.59.22;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.21.16.44.16;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.34.21;	author colin;	state Exp;
branches;
next	;

1.44.1.1
date	93.07.08.13.51.22;	author jont;	state Exp;
branches;
next	;

1.56.1.1
date	96.09.13.11.42.21;	author hope;	state Exp;
branches;
next	;

1.56.2.1
date	96.10.07.16.35.27;	author hope;	state Exp;
branches;
next	;

1.56.3.1
date	96.10.17.11.54.33;	author hope;	state Exp;
branches;
next	;

1.58.1.1
date	96.11.14.13.22.46;	author hope;	state Exp;
branches
	1.58.1.1.1.1;
next	;

1.58.1.1.1.1
date	96.11.28.15.33.18;	author hope;	state Exp;
branches;
next	;

1.58.2.1
date	96.11.22.18.39.54;	author hope;	state Exp;
branches;
next	;

1.58.3.1
date	96.12.17.18.18.56;	author hope;	state Exp;
branches
	1.58.3.1.1.1;
next	;

1.58.3.1.1.1
date	97.02.24.12.13.13;	author hope;	state Exp;
branches;
next	;

1.58.4.1
date	96.12.18.10.14.16;	author hope;	state Exp;
branches;
next	;

1.58.5.1
date	97.05.12.10.52.28;	author hope;	state Exp;
branches
	1.58.5.1.1.1
	1.58.5.1.2.1
	1.58.5.1.3.1;
next	;

1.58.5.1.1.1
date	97.07.28.18.34.17;	author daveb;	state Exp;
branches
	1.58.5.1.1.1.1.1;
next	;

1.58.5.1.1.1.1.1
date	97.10.07.12.00.15;	author jkbrook;	state Exp;
branches;
next	;

1.58.5.1.2.1
date	97.09.08.17.27.19;	author daveb;	state Exp;
branches;
next	;

1.58.5.1.3.1
date	97.09.09.14.24.16;	author daveb;	state Exp;
branches;
next	;

1.59.1.1
date	97.09.10.19.43.10;	author brucem;	state Exp;
branches;
next	;

1.59.2.1
date	97.09.11.21.10.39;	author daveb;	state Exp;
branches;
next	;

1.60.1.1
date	99.04.01.18.09.01;	author daveb;	state Exp;
branches;
next	;


desc
@Assemblies - semantic object for modules
@


1.60
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _assemblies.sml the functor *)
(*
$Log: _assemblies.sml,v $
 * Revision 1.59  1997/05/01  12:53:24  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.58  1996/11/06  11:32:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.57  1996/10/28  17:05:11  io
 * moving String from toplevel
 *
 * Revision 1.56  1996/04/30  16:00:25  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.55  1996/04/29  14:02:12  matthew
 * Removing MLWorks.Integer.
 *
 * Revision 1.54  1996/02/26  11:31:06  jont
 * Change newhashtable to hashtable
 *
 * Revision 1.53  1996/02/23  17:10:56  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.52  1995/10/20  10:08:33  jont
 * Supply a modified version of expand_str which only does the
 * expansion necessary for assemblies, ie no value environments
 * and no constructor environments.
 *
Revision 1.51  1995/03/24  15:23:22  matthew
Use Stamp instead of Tyname_id etc.

Revision 1.50  1995/02/07  16:39:01  matthew
Removing debug stuff

Revision 1.49  1994/10/13  11:04:37  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.48  1994/10/06  11:54:50  matthew
Hash table rationizations

Revision 1.47  1994/02/28  06:20:47  nosa
Replaced option in NULL_TYFUNs for polymorphic debugger.

Revision 1.46  1993/12/15  13:31:25  matthew
Added level slot to Basis structure.

Revision 1.45  1993/12/02  17:34:58  nickh
Remove old debugging code and inexhuastive bindings.

Revision 1.44  1993/07/08  13:51:22  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.

Revision 1.43  1993/07/01  14:31:30  daveb
Removed exception environments.

Revision 1.42  1993/06/25  19:40:08  jont
Various improvements, particularly to do with signatures embedded in structures

Revision 1.41  1993/06/23  15:28:41  jont
Fixed new_assemblies_from basis and compose_assemblies to deal with the
possibility of the F component of the basis keeping structures alive

Revision 1.40  1993/05/28  13:44:20  jont
Cleaned up after assembly changes

Revision 1.39  1993/05/25  14:50:15  jont
Added a function for combining assemblies after elaboration of a topdec,
including dealing with shadowing

Revision 1.38  1993/05/18  18:10:29  jont
Removed integer parameter

Revision 1.37  1993/04/19  16:05:25  jont
Added a list to Type_Assembly function for input of assemblies

Revision 1.36  1993/03/02  14:37:17  matthew
NameHash.DataTypes now NameHash.Datatypes

Revision 1.35  1993/02/25  14:20:05  jont
Modified to use the new hashset with variable size tables

Revision 1.34  1993/01/27  12:23:23  matthew
Changes to Env representation
,

Revision 1.33  1992/12/02  16:24:12  jont
Error message improvements

Revision 1.32  1992/12/01  20:11:15  jont
Modified to new improved hashset signature

Revision 1.31  1992/11/26  17:32:50  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.30  1992/10/30  14:12:35  jont
Added IntMap structure for type assemblies

Revision 1.29  1992/10/29  18:27:26  jont
Recast in terms of intnewmap

Revision 1.28  1992/10/27  18:58:39  jont
Modified to use less than functions for maps

Revision 1.27  1992/10/15  15:57:15  clive
Anel's changes for encapsulating assemblies

Revision 1.26  1992/10/12  11:28:24  clive
Tynames now have a slot recording their definition point

Revision 1.25  1992/09/21  11:41:20  clive
Changed hashtables to a single structure implementation

Revision 1.24  1992/09/15  15:41:28  jont
Replaced two handles with lookup_default instead. Should perform better
for us if not for NJ

Revision 1.23  1992/09/15  15:18:48  jont
Removed use of strname_hash for structure assemblies. Removed cases
of tyfuns getting negative counts is type assemblies

Revision 1.22  1992/09/11  16:00:49  jont
Changed implementation of TypeAssembly to use a tree of lists from
hash values

Revision 1.21  1992/09/11  12:56:35  jont
Some minor improvements to remove some handlers and avoid wasting
time in others

Revision 1.20  1992/09/01  16:22:08  jont
Stuff to understand type functions properly

Revision 1.19  1992/08/27  14:27:50  jont
fixed bug in unionTypeAssembly.

Revision 1.18  1992/08/20  18:46:32  jont
Various improvements to remove garbage, handlers etc.

Revision 1.17  1992/08/18  14:42:18  jont
Removed irrelevant handlers and new exceptions

Revision 1.16  1992/08/13  17:26:59  davidt
Removed redundant arguments to newAssemblies function.

Revision 1.15  1992/08/12  10:54:54  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.14  1992/08/06  14:30:40  jont
Anel's changes to use NewMap instead of Map

Revision 1.11  1992/07/17  15:42:54  jont
Removed message about adding existing assembly

Revision 1.10  1992/07/16  13:24:37  jont
Various speed improvements, including imperative internal versions
of subAssemblies, newAssemblies, unionStrAssemblies and unionTypeAssemblies

Revision 1.8  1992/07/06  10:49:30  jont
Added a missing handle Assoc => raise LookupTyfun

Revision 1.7  1992/06/26  17:44:51  jont
Chnaged implementation of TypeAssemblies to avoid so much comparison of
tyfuns (expensive). Further improvements could be made by using namesets

Revision 1.6  1992/04/16  15:22:59  jont
Some minor corrections

Revision 1.5  1992/04/16  14:20:26  jont
Further improvements from Anel

Revision 1.3  1992/01/27  19:59:22  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.2  1991/11/21  16:44:16  jont
Added copyright message

Revision 1.1  91/06/07  11:34:21  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";

require "../utils/lists";
require "../utils/intnewmap";
require "../utils/print";
require "../utils/crash";
require "../utils/hashset";
require "../utils/hashtable";
require "../basics/identprint";
require "../typechecker/types";
require "../typechecker/strnames";
require "../typechecker/valenv";
require "../typechecker/tyenv";
require "../typechecker/strenv";
require "../typechecker/environment";
require "../typechecker/namehash";
require "../typechecker/basistypes";
require "../typechecker/assemblies";

functor Assemblies(
  structure IdentPrint : IDENTPRINT
  structure StrnameSet: HASHSET
  structure TyfunSet  : HASHSET
  structure IntMap    : INTNEWMAP
  structure Lists     : LISTS
  structure Print     : PRINT
  structure Crash     : CRASH
  structure Conenv    : VALENV
  structure Types     : TYPES
  structure Strnames  : STRNAMES
  structure Tyenv     : TYENV
  structure Strenv    : STRENV
  structure Env       : ENVIRONMENT
  structure NameHash  : NAMEHASH
  structure HashTable : HASHTABLE
  structure Basistypes : BASISTYPES
  sharing Strnames.Datatypes = Conenv.Datatypes =
    Tyenv.Datatypes = Env.Datatypes =
    Types.Datatypes = NameHash.Datatypes =
    Basistypes.Datatypes = Strenv.Datatypes
  sharing Types.Datatypes.Ident = IdentPrint.Ident
  sharing type StrnameSet.element = Types.Datatypes.Strname
  sharing type TyfunSet.element = Types.Datatypes.Tyfun
) : ASSEMBLIES =
  
  struct
    structure IntMap = IntMap
    structure Basistypes = Basistypes

    (* A constant for hash table sizes *)
    (* We could diddle with this maybe *)

    val hash_size = 128

    (****
     The rationale behind the use of assemblies is described in a separate 
     document.
     ****)

    structure Datatypes = Types.Datatypes

    open Datatypes

    type TypeOffspring = (Ident.TyCon,Tyfun * int) NewMap.map
      
    type StrOffspring = (Ident.StrId,Strname * int) NewMap.map
      
    type StrAssembly =
      (Strname * (StrOffspring * TypeOffspring)) list

    type TypeAssembly = ((Tyfun * (Valenv * int)) list) IntMap.T
(*
 Implement as lists of tyfuns hung off hash values
*)

    datatype 'a Opt = YES of 'a | NO

    exception Assoc = IntMap.Undefined

    fun rev_app(acc, []) = acc
      | rev_app([], acc) = acc
      | rev_app(x :: xs, acc) = rev_app(xs, x :: acc)

    infix 5 rev_app

    fun assoc(tyfun, []) = raise Assoc
      | assoc(tyfun, (tyfun', res) :: rest) =
	if Types.tyfun_eq(tyfun, tyfun') then
	  res
	else
	  assoc(tyfun, rest)

    fun tryAssoc(tyfun, []) = NO
      | tryAssoc(tyfun, (tyfun', res) :: rest) =
	if Types.tyfun_eq(tyfun, tyfun') then
	  YES res
	else
	  tryAssoc(tyfun, rest)

    fun lookup(tyfun, amap) =
      let
	val the_list = IntMap.apply'(amap, NameHash.tyfun_hash tyfun)
      in
	assoc(tyfun, the_list)
      end

    fun tryLookup(tyfun, amap) =
      case IntMap.tryApply'(amap, NameHash.tyfun_hash tyfun) of
	SOME the_list =>
	  tryAssoc(tyfun, the_list)
      | _ => NO

    fun lookup_default(tyfun, default, amap) =
      case tryLookup(tyfun, amap) of
	YES res => res
      | _ => default

    fun add_new(elem, a_list) = elem :: a_list

    fun usub(acc, [], elem) = elem :: acc
      | usub(acc, (elem' as (tyfun', _)) :: rest, elem as (tyfun, _)) =
	if Types.tyfun_eq(tyfun, tyfun') then
	  elem :: (acc rev_app rest)
	else
	  usub(elem' :: acc, rest, elem)

    fun update(arg as (tyfun, _), amap) =
      let
	val hash = NameHash.tyfun_hash tyfun
      in
	case IntMap.tryApply'(amap, hash) of
	  SOME the_list =>
	    IntMap.define(amap, hash, usub([], the_list, arg))
	| _ => IntMap.define(amap, hash, [arg])
      end

    fun rsub(acc, [], _) = acc
      | rsub(acc, (elem' as (tyfun', _)) :: rest, tyfun) =
	if Types.tyfun_eq(tyfun, tyfun') then
	  acc rev_app rest
	else
	  rsub(elem' :: acc, rest, tyfun)

    fun remove(tyfun, amap) =
      let
	val hash = NameHash.tyfun_hash tyfun
      in
	case IntMap.tryApply'(amap, hash) of
	  SOME [] =>
	    IntMap.undefine(amap, hash)
	| SOME the_list =>
	    IntMap.define(amap, hash, rsub([], the_list, tyfun))
	| _ => amap
      end

    fun strname_hash(Datatypes.STRNAME id) =
      Types.stamp_num id
    | strname_hash(Datatypes.NULLNAME id) =
      Types.stamp_num id
    | strname_hash(Datatypes.METASTRNAME(ref s)) = strname_hash s

    fun lookup_str'(strname, []) = raise Assoc
    | lookup_str'(strname, a_list) =
      let
	fun lsub [] = raise Assoc
	  | lsub((x, y) :: xs) =
	    if Strnames.strname_eq(strname, x) then y
	    else lsub xs
      in
	lsub a_list
      end

    val empty_str_offspring = NewMap.empty (Ident.strid_lt,Ident.strid_eq)
    val empty_type_offspring = NewMap.empty (Ident.tycon_lt,Ident.tycon_eq)
    val empty_strassembly = fn _ => []

    val empty_tyassembly = IntMap.empty

    fun lookup_str(strname, []) = (empty_str_offspring, empty_type_offspring)
    | lookup_str(strname, a_list) =
      let
	fun lsub [] = (empty_str_offspring, empty_type_offspring)
	  | lsub((x, y) :: xs) =
	    if Strnames.strname_eq(strname, x) then y
	    else lsub xs
      in
	lsub a_list
      end

    fun trylookup_str(strname, []) = NO
    | trylookup_str(strname, a_list) =
      let
	fun lsub [] = NO
	  | lsub((x, y) :: xs) =
	    if Strnames.strname_eq(strname, x) then YES y
	    else lsub xs
      in
	lsub a_list
      end

    fun remove_str(strname, []) = []
    | remove_str(strname, a_list) =
      let
	fun rsub(acc, []) = acc
	  | rsub(acc, (elem as (x, _)) :: xs) =
	    if Strnames.strname_eq(strname, x)
	      then acc rev_app xs
	    else rsub(elem :: acc, xs)
      in
	rsub([], a_list)
      end

    val add_new_str  = add_new

    fun update_str(elem, []) = [elem]
      | update_str(elem as (strname, ran), a_list) =
	add_new_str(elem, remove_str(strname, a_list))

    exception LookupStrname = Assoc
    exception LookupStrId = NewMap.Undefined
    exception LookupTyCon = NewMap.Undefined
    exception LookupTyfun = Assoc
    exception Consistency of string

    fun printTyfun_int (tyfun,n) =
      "(" ^ (Types.string_tyfun tyfun) ^ "," ^
      (Int.toString n) ^ ")\n"

    fun stringTypeOffspring amap =
      let
	val map_list = NewMap.to_list amap
      in
	case map_list of
	  [] => ""
	| _ =>
	    concat
	    ("\nTYPE_OFFSPRING \n" ::
	     ((map
	       (fn (tycon, tyfun_i) =>
		concat[IdentPrint.printTyCon tycon, " --> ",
			printTyfun_int tyfun_i]) map_list) @@ ["\n"]))
      end
    
    fun printStrname_int (strname,n) =
      "(" ^ (Strnames.string_strname strname) ^ "," ^
      (Int.toString n) ^ ")\n"

    fun stringStrOffspring amap =
      let
	val map_list = NewMap.to_list amap
      in
	case map_list of
	  [] => ""
	| _ =>
	    concat
	    ("\nSTR_OFFSPRING \n" ::
	     ((map
	       (fn (strid, str_i) =>
		concat[IdentPrint.printStrId strid, " --> ",
			printStrname_int str_i]) map_list) @@ ["\n"]))
      end
    
    fun stringOffspring (stroff,tyoff) =
      (stringStrOffspring stroff) ^ "\n" ^ 
      (stringTypeOffspring tyoff) ^ "\n"

    fun stringStrAssembly [] = ""
      | stringStrAssembly a_list =
	concat
	(((map
	   (fn (strname, offs) =>
	    concat[Strnames.string_strname strname, " |--> ",
		    stringOffspring offs]) a_list) @@ ["\n"]))

    val tyfun_length = ref 0
    fun print_tyfun (tyfun) =
      let 
	val string_tyfun = (Types.string_tyfun tyfun)
	val tyfun_size = size string_tyfun
      in
	(tyfun_length := tyfun_size;
	 "\n" ^ string_tyfun)
      end

    fun str_ce (ce) = Conenv.string_valenv (!tyfun_length + 5,ce)

    fun get_name_and_env (_,STR(m,_,e)) = (m,e)
      | get_name_and_env (error,_) = Crash.impossible error

    fun printCE_int (ce,n) =
      "(" ^ (str_ce ce) ^ "," ^ (Int.toString n) ^ ")"

    fun stringTypeAssembly ty_ass =
      concat
      (IntMap.fold
       (fn (str_list, _, a_list) =>
	Lists.reducel
	(fn (str_list, (tyfun, r)) =>
	 print_tyfun tyfun ^ " | --> " ^ printCE_int r :: str_list)
	(str_list, a_list))
       ([], ty_ass))

    val empty_str_offspringp = NewMap.is_empty

    val empty_type_offspringp = NewMap.is_empty

    fun lookupStrId (strid, amap) =
      NewMap.apply'(amap, strid)

    fun lookupTyCon (tycon, amap) = NewMap.apply'(amap, tycon)

    fun lookupTyfun (tyfun, amap) =
	 lookup_default(tyfun, (empty_valenv, 0), amap)

    val getStrIds = NewMap.domain_ordered

    fun inStrOffspringDomain(strid, amap) =
      case NewMap.tryApply'(amap, strid) of
	NONE => false
      | _ => true

    val getTyCons = NewMap.domain_ordered

    fun inTypeOffspringDomain(tycon, amap) =
      case NewMap.tryApply'(amap, tycon) of
	NONE => false
      | _ => true

    fun getStrOffspringMap str_offs = str_offs

    fun getTypeOffspringMap ty_offs = ty_offs

    fun findStrOffspring(strname, amap : StrAssembly) =
      #1 (lookup_str(strname,amap))

    fun findTypeOffspring (strname, amap : StrAssembly) =
      #2 (lookup_str(strname,amap))

    (****
     If two strnames from amap and amap' (the new map) are the same then 
     the strnames they are mapped to via a strid are also the same - a 
     result of consistency.
     ****)

    fun str_offsunion(amap, amap') =
      let 
	fun strmap_union(amap, strid, ran as (strname', count')) =
	  case NewMap.tryApply'(amap, strid) of
	    SOME (strname, count) =>
	      NewMap.define(amap, strid, (strname', count + count':int))
	  | _ => NewMap.define(amap, strid, ran)
      in
	NewMap.fold strmap_union (amap, amap')
      end

    fun ty_offsunion (amap, amap') =
      let
	fun tymap_union(amap, tycon, ran as (tyfun', funcount')) =
	  case NewMap.tryApply'(amap, tycon) of
	    SOME (tyfun, funcount) =>
	      NewMap.define(amap, tycon, (tyfun', funcount + funcount':int))
	  | _ => NewMap.define(amap, tycon, ran)
      in
	NewMap.fold tymap_union (amap, amap')
      end
    
    fun add_to_StrOffspring (strid,strname,num, amap) =
      case NewMap.tryApply'(amap, strid) of
	SOME (strname',count) =>
	  NewMap.define(amap, strid, (strname', count + num:int))
      | _ => NewMap.define(amap, strid, (strname, num))

    fun add_to_TypeOffspring (tycon,tyfun,num, amap) =
      case NewMap.tryApply'(amap, tycon) of
	SOME (tyfun', count) =>
	  NewMap.define(amap, tycon, (tyfun', count+num:int))
      | _ =>
	  NewMap.define(amap, tycon, (tyfun, num))

    fun lookupStrname(strname, amap) =
      let
	val strname' = Strnames.strip strname
      in
	 lookup_str(strname',amap)
      end

    fun add_to_StrAss(strname, str_offspring, type_offspring, str_assembly) =
      (* This one is imperative, for internal use only. *)
      (* Not to be taken! Keep out of the reach of small children! *)
       let
	 val strname' = Strnames.strip strname
       in
	 if not (empty_str_offspringp str_offspring 
		 andalso 
		 empty_type_offspringp type_offspring) then
	   ((let
	       val (str_offspring',type_offspring') =
		 HashTable.lookup(str_assembly, strname')
	     in
	       (HashTable.update(str_assembly, strname',
			      (str_offsunion (str_offspring',
					      str_offspring),
			       ty_offsunion(type_offspring',
					    type_offspring)));
		str_assembly)
			     
	     end) handle HashTable.Lookup =>
	       (HashTable.update(str_assembly, strname',
			      (str_offspring, type_offspring));
		str_assembly))
	 else
	   str_assembly
       end

    fun add_to_StrAssembly(strname,str_offspring,type_offspring,
			   str_assembly as amap) =
      let
	val strname' = Strnames.strip strname
      in
	if not (empty_str_offspringp str_offspring 
		andalso 
		empty_type_offspringp type_offspring) then
	  (case trylookup_str(strname', amap) of
	     YES(str_offspring',type_offspring') =>
	       update_str((strname',
			   (str_offsunion(str_offspring', str_offspring),
			    ty_offsunion(type_offspring', type_offspring))), amap)
	   | _ => update_str((strname', (str_offspring, type_offspring)), amap))
	else
	  str_assembly
      end

    (****
     A tyfun to ce mapping is added only when ce is not empty and in the 
     case of tyfun already in the type assembly only when the two ce's are 
     equal. 
     ****)

    fun add_to_TypeAss(tyfun,ce,num,ty_ass) =
      (* This one is imperative, for internal use only. *)
      (* Not to be taken! Keep out of the reach of small children! *)
       if Conenv.empty_valenvp ce then
	 ty_ass
       else 
	 let
	   val (ce',count) = HashTable.lookup(ty_ass, tyfun)
	 in
	   if Conenv.dom_valenv_eq (ce,ce') then
	     (HashTable.update(ty_ass, tyfun, (ce,count+num:int));
	      ty_ass)
	   else
	     raise Consistency "inconsistent value constructors"
	 end handle HashTable.Lookup =>
	   (HashTable.update(ty_ass, tyfun, (ce, num));
	    ty_ass)

    fun add_to_TypeAssembly (tyfun,ce,num,ty_assembly as amap) =
       if Conenv.empty_valenvp ce then
	 ty_assembly
       else 
	 case tryLookup(tyfun, amap) of
	   YES(ce', count) =>
	     if Conenv.dom_valenv_eq (ce,ce') then 
	       update((tyfun ,(ce,count+num:int)), amap)
	     else
	       raise Consistency "inconsistent value constructors"
	 | _ => update((tyfun, (ce, num)), amap)
      
    fun collectStrOffspring (SE amap,str_offspring) =
      let 
	fun collect (str_offspring, strid, STR(m,_,_)) =
	  add_to_StrOffspring (strid,m,1,str_offspring)
          | collect (str_offspring, strid, COPYSTR((smap,tmap),str)) =
            (* need to do a full copy since assemblies must be fully copied *)
            collect (str_offspring,strid,Env.str_copy(str,smap,tmap))
      in
	NewMap.fold collect (str_offspring, amap)
      end

    fun collectTypeOffspring (TE amap,type_offspring) =
      let
	fun collect (type_offspring, tycon, TYSTR(tyfun, _)) =
	  add_to_TypeOffspring (tycon,tyfun,1,type_offspring)
      in
	NewMap.fold collect (type_offspring, amap)
      end
    
    fun remfromStrAssembly (strname, amap) =
	 remove_str(strname,amap)

    fun remfromTypeAssembly (tyfun, amap) =
	 case tryLookup(tyfun, amap) of
	   YES (_, count) => (remove(tyfun, amap), count)
	 |_ => (amap, 0)

    fun te_copy(TE amap, tyname_copies) =
      let
	fun tystr_copy(_, TYSTR(tyfun, conenv)) =
	  TYSTR(Types.tyfun_copy (tyfun,tyname_copies), conenv)
      in
	TE(NewMap.map tystr_copy amap)
      end

    fun se_copy (SE amap,strname_copies,tyname_copies) =
      SE(NewMap.map (fn (_, str) => str_copy (str,strname_copies,tyname_copies)) amap)

    and env_copy (ENV (se,te,ve),strname_copies,tyname_copies) =
      ENV (se_copy (se,strname_copies,tyname_copies),
           (*Tyenv.*)te_copy (te,tyname_copies),
           ve)

    and str_copy (STR(name,r,env),strname_copies,tyname_copies) =
             STR(Strnames.strname_copy (name,strname_copies),
                 r,
                 env_copy (env,strname_copies,tyname_copies))
      | str_copy (COPYSTR(maps,str),strname_copies,tyname_copies) =
        let
	  val (smap,tmap) = Env.compose_maps (maps,(strname_copies,tyname_copies))
        in
          str_copy (str,smap,tmap)
        end

    fun expand_str str =
      let
        fun expand (STR (strid,r,env)) =
          STR (strid,r,expand_env env)
          | expand (COPYSTR((smap,tmap),str)) =
            expand (str_copy (str,smap,tmap))
      in
        expand str
      end

    and expand_se (SE se) =
      SE (NewMap.map (fn (strid,str) => expand_str str) se)

    and expand_env (ENV(se,te,ve)) =
      ENV (expand_se se,te,ve)

    val expand_str_sans_ve = expand_str

    (****
     subAssemblies is called when an assembly must be updated as a
     result of a StrId disappearing out of scope.  This only happens 
     during elaboration of a structure declaration and not during the 
     elaboration of a signature declaration because of 5.5 no 2. 
     The arguments of subAssemblies are the assemblies and the structure
     to which this StrId is mapped in the structure environment.  
     subAssemblies recursively decreases the counters associated with 
     mappings in the two offspring maps of the StrAssembly and in the 
     TypeAssembly which disappear as a result of the shadowing.
     There is a further subtlety to this stuff now.
     A functor result may be a rigid structure, which effectively
     "keeps alive" the structure name even if there are no longstrids
     within the basis by which it can be referenced.
     Thus we must run subAssemblies over the F part of the basis as
     well as the E part. But of course, we only care about rigid structures,
     so we must do as newAssemblies does when allow_meta is false.
     ****) 

    fun subTE (ty_ass, type_offspring, TE amap) =
      let
	fun do_all ((ty_ass, ty_offsmap),
		    tycon, TYSTR (tyfun',ce')) =
	  let
	    val (tyfun,count) = case NewMap.tryApply'(ty_offsmap, tycon) of
	      SOME res => res
	    | _ => (NULL_TYFUN (Types.make_stamp (),(ref(TYFUN(NULLTYPE,0)))),0)
	    val (ce, count') = HashTable.lookup_default(ty_ass, (ce',0), tyfun)

	    val new_tyoffs =
	      case count of
		0 => ty_offsmap
	      | 1 =>
		  NewMap.undefine(ty_offsmap, tycon)
	      | _ =>
		  NewMap.define(ty_offsmap, tycon, (tyfun,count-1))
	    val _ =
	      if count' = 0 orelse Conenv.empty_valenvp ce' then
		()
	      else
		if count' = 1 then
		  HashTable.delete(ty_ass, tyfun)
		else
		  HashTable.update(ty_ass, tyfun, (ce,count'-1))
	  in
	    (ty_ass, new_tyoffs)
	  end
      in
	NewMap.fold do_all ((ty_ass, type_offspring), amap)
      end

    fun internal_subAssemblies (str_ass, ty_ass, STR(m, _,ENV(se,te,_))) =
      (* Internally imperative form *)
      if not(Strnames.uninstantiated m) then
	let
	  val (str_offs, ty_offs) =
	    HashTable.lookup_default
	    (str_ass, (empty_str_offspring, empty_type_offspring), m)
	  val (str_offsmap, str_assmap', ty_ass') =
	    subSE(str_ass, ty_ass, str_offs, se)
	  val (ty_ass'', ty_offsmap) =
	    subTE (ty_ass',ty_offs,te)
	in
	  if NewMap.is_empty str_offsmap andalso NewMap.is_empty ty_offsmap then
	    ((HashTable.delete(str_assmap', m);
	      str_assmap'), ty_ass'')
	  else
	    ((HashTable.update(str_assmap', m, (str_offsmap,ty_offsmap));
	      str_assmap'), ty_ass'')
	end
      else
	(str_ass, ty_ass)
      | internal_subAssemblies (str_ass,ty_ass,str) =
(*
        internal_subAssemblies (str_ass,ty_ass, Env.expand_str str)
*)
        internal_subAssemblies (str_ass,ty_ass, expand_str_sans_ve str)

    and subSE (str_ass, ty_ass, str_offspring, SE amap) =
      let
	fun do_all ((str_offsmap, str_ass, ty_ass), strid, str) =
	  let 
	    val (strname, count) =
	      case NewMap.tryApply'(str_offsmap, strid) of
		SOME result => result
	      | _ =>
		  (NULLNAME (Types.make_stamp ()),0)
	    val (str_ass', ty_ass') =
	      case count of
		0 =>
	          (* When the count is zero, we don't want the result *)
	          (* This seems irrelevant, so I've removed it *)
		  let
		  (*
		    val new_str_ass = HashTable.copy str_ass
		    val new_ty_ass = HashTable.copy ty_ass
		    val _ =
		      internal_subAssemblies(new_str_ass, new_ty_ass, str)
		      *)
		  in
		    (str_ass, ty_ass)
		  end
	      | _ => internal_subAssemblies(str_ass, ty_ass, str)
	  in
	    case count of
	      0 => (str_offsmap, str_ass', ty_ass')
	    | 1 =>
		(NewMap.undefine(str_offsmap, strid), str_ass', ty_ass')
	    | _ =>
		(NewMap.define(str_offsmap, strid, (strname,count-1)),
		 str_ass',ty_ass')
	  end
      in
	NewMap.fold do_all ((str_offspring, str_ass, ty_ass), amap)
      end

    fun subAssemblies(str_ass, ty_ass, str) =
      let
	val str_ass' = HashTable.new(hash_size,Strnames.strname_eq,NameHash.strname_hash)
	val ty_ass' = HashTable.new(hash_size,Types.tyfun_eq,NameHash.tyfun_hash)
	val _ =
	  Lists.iterate
	  (fn (str, ran) => HashTable.update(str_ass', str, ran))
	  str_ass
	val _ =
	  IntMap.iterate
	  (fn (i, the_list) =>
	   Lists.iterate
	   (fn (tyfun, ran) => HashTable.update(ty_ass', tyfun, ran))
	   the_list)
	  ty_ass
	val (str_ass', ty_ass') =
	  internal_subAssemblies(str_ass', ty_ass', str)
      in
	((HashTable.to_list str_ass'),
	 HashTable.fold
	 (fn (ty_ass, tyfun, ran) => update((tyfun, ran), ty_ass))
	 (empty_tyassembly, ty_ass'))
      end

    fun subTypeAssembly (tyfun,ce,ty_ass as amap) =
      if Conenv.empty_valenvp ce then
	ty_ass
      else 
	let
	  val (ce',count) = lookup(tyfun, amap)
	in
	  if count = 1 then
	    remove(tyfun, amap)
	  else
	    update((tyfun, (ce, count - 1)), amap)
	end
      
    fun newTypeAssembly (ENV (se,te as TE amap,_),ty_assembly) =
      let 
	val ty_assembly' = seTypeAssembly (se,ty_assembly)
	fun teTypeAssembly (ty_assembly, _, TYSTR (tyfun,ce)) =
	  add_to_TypeAssembly (tyfun,ce,1,ty_assembly)
      in
	NewMap.fold teTypeAssembly (ty_assembly', amap)
      end

    and seTypeAssembly (SE amap,ty_assembly) =
      let
	fun gather (ty_assembly, strid, STR (_,_,env)) =
	  newTypeAssembly (env,ty_assembly)
          | gather (ty_ass, strid,str) =
(*
            gather (ty_ass,strid,Env.expand_str str)
*)
            gather (ty_ass,strid,expand_str_sans_ve str)
      in
	NewMap.fold gather (ty_assembly, amap)
      end
    

    local
      local
	fun collect((type_offspring,ty_ass), tycon, TYSTR (tyfun,ce)) =
	    (add_to_TypeOffspring(tycon,tyfun,1,type_offspring),
	     add_to_TypeAss(tyfun,ce,1,ty_ass))
      in
	fun collectTypeInfo(TE amap,ty_offs,ty_ass) =
	  NewMap.fold collect ((ty_offs,ty_ass), amap)
      end
    in
      fun internal_newAssemblies(strname,ENV (se,te,_),str_ass, ty_ass, allow_meta) =
	let
	  val ok = allow_meta orelse (not(Strnames.uninstantiated strname))
	  val str_offspring =
	    if ok then
	      collectStrOffspring(se,empty_str_offspring)
	    else
	      empty_str_offspring
	  val (type_offspring,ty_ass') =
	    if ok then
	       collectTypeInfo(te,empty_type_offspring,ty_ass)
	    else
	      (empty_type_offspring, ty_ass)
	  val str_ass' =
	    if ok then
	      add_to_StrAss(strname, str_offspring,type_offspring, str_ass)
	    else
	      str_ass
	in
	  collectStrInfo(se,str_ass',ty_ass', allow_meta)
	end

      and collectStrInfo(SE amap, str_ass, ty_ass, allow_meta) =
	NewMap.fold collect ((str_ass,ty_ass, allow_meta), amap)

      and collect((str_ass,ty_ass, allow_meta), strid, STR (m,_,env)) =
	internal_newAssemblies(m,env,str_ass,ty_ass, allow_meta)
	| collect(asses,strid,COPYSTR ((smap,tmap),str)) =
	  collect(asses,strid,Env.str_copy(str,smap,tmap))

      fun newAssemblies(strname, env, allow_meta) =
	(* Internally imperative version *)
	let
	  val str_ass' = HashTable.new(hash_size,Strnames.strname_eq,NameHash.strname_hash)
	  val ty_ass' = HashTable.new(hash_size,Types.tyfun_eq,NameHash.tyfun_hash)
	  val (str_ass', ty_ass', _) =
	    internal_newAssemblies(strname, env, str_ass', ty_ass', allow_meta)
	in
	  ((HashTable.to_list str_ass'),
	   HashTable.fold
	   (fn (ty_ass, tyfun, ran) => update((tyfun, ran), ty_ass))
	   (empty_tyassembly, ty_ass'))
	  (* This is poor, the hash table has these things in lists anyway *)
	end
    end


    fun partition P list =
      let
	fun part (ys,ns,[]) = (ys, ns)
	  | part (ys,ns,x::xs) =
	    if P x 
	      then part(x::ys,ns,xs)
	    else part(ys,x::ns,xs)
      in 
	part ([],[],list)
      end

    fun split(news, olds) =
      let
	val strnames =
	  Lists.reducel
	  (fn (set, (x, _)) => StrnameSet.add_member(set, x))
	  (StrnameSet.empty_set(length olds div 4), olds)
      in
	partition
	(fn (strname, _) => StrnameSet.is_member(strnames, strname))
	news
      end

    fun unionStrAssembly (str_ass, amap') =
      let
	val (ins, outs) = split(str_ass, amap')
	(* Only need to handle those already there specially *)
	(* Note we split the large set, relative to the small one *)
	(* Thus most of it will be in the outs, and can just be prepended *)
	fun union([],str_ass) = str_ass
	  | union((strname, (str_offs,ty_offs))::strnames,str_ass) =
	    union(strnames, add_to_StrAssembly(strname,str_offs,ty_offs,
					       str_ass))
      in
	outs rev_app union(ins, amap')
      end
    
    fun split(news, olds) =
      let
	val tyfuns =
	  Lists.reducel
	  (fn (set, (x, _)) => TyfunSet.add_member(set, x))
	  (TyfunSet.empty_set(length olds div 4), olds)
      in
	partition
	(fn (tyfun, _) => TyfunSet.is_member(tyfuns, tyfun))
	news
      end

    fun union([],ty_ass) = ty_ass
      | union((tyfun, (ce',count'))::tyfuns, alist) =
	let
	  val (ce, count : int) = assoc(tyfun, alist)
	in
	  if Conenv.dom_valenv_eq(ce,ce') then
	    union(tyfuns, usub([], alist, (tyfun, (ce',count' + count))))
	  else
	    raise Consistency"inconsistent value constructors"
	end

    fun unionTypeAssemblyLists(l1, l2) =
      let
	val (ins, outs) = split(l1, l2)
      in
	outs rev_app union(ins, l2)
      end

    fun unionTypeAssembly(ty_ass, amap') =
      let
	fun unite_lists(ty_ass, i, the_list) =
	  case IntMap.tryApply'(ty_ass, i) of
	    SOME the_list' =>
	      IntMap.define(ty_ass, i,
			    unionTypeAssemblyLists(the_list, the_list'))
	  | _ => IntMap.define(ty_ass, i, the_list)
      in
	IntMap.fold unite_lists (ty_ass, amap')
      end

    (****
     updateTypeAssembly is a function to increment the counts of
     all the typefunctions in the type assembly to which tycons in 
     ty_offs are mapped. Used in rule 54.
     ****)

    fun updateTypeAssembly (TE amap,ty_ass) =
      let 
	fun do_all (ty_ass, tycon, TYSTR (tyfun,ce)) =
	  if Conenv.empty_valenvp ce then
	    ty_ass
	  else
	    add_to_TypeAssembly (tyfun,ce,1,ty_ass)
      in
	NewMap.fold do_all (ty_ass, amap)
      end
      
    fun string_assembly(str_ass, ty_ass) =
      stringTypeAssembly ty_ass ^ stringStrAssembly str_ass

    fun compose_assemblies(new_ass as (str_ass, ty_ass),
			   old_ass as (str_ass', ty_ass'),
			   new_basis as
			   Basistypes.BASIS(_,_, Basistypes.FUNENV fun_map, _,
					    ENV(SE se, TE te, _)),
			   old_basis as
			   Basistypes.BASIS(_,_, Basistypes.FUNENV fun_map', _,
					    ENV(se', te', _))) =
      let
	(* First remove from old_ass anything shadowed by the new basis *)
	val old_ass' = NewMap.fold
	  (fn (arg1 as (str_ass, ty_ass), strid, _) =>
	   (case Strenv.lookup(strid, se') of
	      SOME str => subAssemblies(str_ass, ty_ass, str)
            | _ => arg1))
	  (old_ass, se)
	(* The E part *)
	val (str_ass', ty_ass') = NewMap.fold
	  (fn (arg1 as (str_ass, ty_ass), funid, _) =>
	   (let
	      val Basistypes.PHI(_, (_, Basistypes.SIGMA(_, str))) =
		NewMap.apply'(fun_map', funid)
	    in
	      subAssemblies(str_ass, ty_ass, str)
	    end handle NewMap.Undefined => arg1))
	  (old_ass', fun_map)
	(* The F part *)
	val ty_ass' = NewMap.fold
	  (fn (ty_ass, tycon, _) =>
	   (let
	      val TYSTR(tyfun, valenv) = Tyenv.lookup(te', tycon)
	    in
	      subTypeAssembly(tyfun, valenv, ty_ass)
	    end handle Tyenv.LookupTyCon _ => ty_ass))
	  (ty_ass', te)
	val result =
	  (unionStrAssembly(str_ass', str_ass), unionTypeAssembly(ty_ass', ty_ass))
      in
	result
      end

    fun new_assemblies_from_basis
      (Basistypes.BASIS(_,_, Basistypes.FUNENV fun_map, _,
			env as ENV(Datatypes.SE se, _, _))) =
      let
	fun new_str((str_ass, ty_ass), _, str) =
	  let
(*
	    val (m,env) = get_name_and_env ("expand_str",Env.expand_str str)
*)
	    val (m,env) = get_name_and_env ("expand_str",expand_str_sans_ve str)
	    val (str_ass', ty_ass') = newAssemblies(m, env, false)
	  in
	    (unionStrAssembly(str_ass, str_ass'),
	     unionTypeAssembly(ty_ass, ty_ass'))
	  end
	fun new_fun_result((str_ass, ty_ass), _,
			   Basistypes.PHI(_, (_, Basistypes.SIGMA(_, str)))) =
	  let
(*
	    val (m,env) = get_name_and_env ("expand_str",Env.expand_str str)
*)
	    val (m,env) = get_name_and_env ("expand_str",expand_str_sans_ve str)
	    val (str_ass', ty_ass') = newAssemblies(m, env, false)
	  (* This needs to check only the rigid structures. *)
	  (* Need a modified version of newAssemblies for this *)
	  in
	    (unionStrAssembly(str_ass, str_ass'),
	     unionTypeAssembly(ty_ass, ty_ass'))
	  end
      in
	NewMap.fold
	new_fun_result
	(NewMap.fold
	 new_str
	 ((empty_strassembly(),
	   newTypeAssembly(env, empty_tyassembly)),
	  se),
	 fun_map)
      end

    fun new_assemblies_from_basis_inc_sig
      (Basistypes.BASIS(_,_, Basistypes.FUNENV fun_map, _,
			env as ENV(Datatypes.SE se, _, _))) =
      let
	fun new_str((str_ass, ty_ass), _, str) =
	  let
(*
	    val (m,env) = get_name_and_env ("expand_str",Env.expand_str str)
*)
	    val (m,env) = get_name_and_env ("expand_str",expand_str_sans_ve str)
	    val (str_ass', ty_ass') = newAssemblies(m, env, true)
	  (* Check both rigid and flexible here, this is for sig elaboration *)
	  in
	    (unionStrAssembly(str_ass, str_ass'),
	     unionTypeAssembly(ty_ass, ty_ass'))
	  end
	fun new_fun_sig((str_ass, ty_ass), funid, Basistypes.PHI(_, (str, _))) =
	  let
(*
	    val (m,env) = get_name_and_env ("expand_str",Env.expand_str str)
*)
	    val (m,env) = get_name_and_env ("expand_str",expand_str_sans_ve str)
	    val (str_ass', ty_ass') = newAssemblies(m, env, true)
	  (* Check both rigid and flexible here, this is for sig elaboration *)
	  in
	    (unionStrAssembly(str_ass, str_ass'),
	     unionTypeAssembly(ty_ass, ty_ass'))
	  end
      in
	NewMap.fold
	new_fun_sig
	(NewMap.fold
	 new_str
	 ((empty_strassembly(),
	   newTypeAssembly(env, empty_tyassembly)),
	  se),
	 fun_map)
      end

    val newAssemblies = fn (strname, env) => newAssemblies(strname, env, true)
  end
@


1.60.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.60  1999/02/02  16:01:43  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.59
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
a198 1
require "../utils/_hashset";
@


1.59.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.59  1997/05/01  12:53:24  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.59.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.59  1997/05/01  12:53:24  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.58
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d507 1
a507 1
	MLWorks.Option.NONE => false
d514 1
a514 1
	MLWorks.Option.NONE => false
@


1.58.5.1
log
@branched from 1.58
@
text
@a3 4
 * Revision 1.58  1996/11/06  11:32:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.58.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.58.5.1  1997/05/12  10:52:28  hope
 * branched from 1.58
 *
@


1.58.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.58.5.1  1997/05/12  10:52:28  hope
 * branched from 1.58
 *
@


1.58.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.58.5.1  1997/05/12  10:52:28  hope
 * branched from 1.58
 *
@


1.58.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.58.5.1.1.1  1997/07/28  18:34:17  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.58.4.1
log
@branched from 1.58
@
text
@a3 4
 * Revision 1.58  1996/11/06  11:32:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.58.3.1
log
@branched from 1.58
@
text
@a3 4
 * Revision 1.58  1996/11/06  11:32:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.58.3.1.1.1
log
@branched from 1.58.3.1
@
text
@a3 3
 * Revision 1.58.3.1  1996/12/17  18:18:56  hope
 * branched from 1.58
 *
@


1.58.2.1
log
@branched from 1.58
@
text
@a3 4
 * Revision 1.58  1996/11/06  11:32:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.58.1.1
log
@branched from 1.58
@
text
@a3 4
 * Revision 1.58  1996/11/06  11:32:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.58.1.1.1.1
log
@branched from 1.58.1.1
@
text
@a3 3
 * Revision 1.58.1.1  1996/11/14  13:22:46  hope
 * branched from 1.58
 *
@


1.57
log
@moving String from toplevel
@
text
@d4 3
d184 1
a184 1
require "../basis/__integer";
@


1.56
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d290 1
a290 1
	MLWorks.Option.SOME the_list =>
d313 1
a313 1
	  MLWorks.Option.SOME the_list =>
d330 1
a330 1
	  MLWorks.Option.SOME [] =>
d332 1
a332 1
	| MLWorks.Option.SOME the_list =>
d417 1
a417 1
	    String.implode
d421 1
a421 1
		String.implode[IdentPrint.printTyCon tycon, " --> ",
d436 1
a436 1
	    String.implode
d440 1
a440 1
		String.implode[IdentPrint.printStrId strid, " --> ",
d450 1
a450 1
	String.implode
d453 1
a453 1
	    String.implode[Strnames.string_strname strname, " |--> ",
d475 1
a475 1
      String.implode
d530 1
a530 1
	    MLWorks.Option.SOME (strname, count) =>
d541 1
a541 1
	    MLWorks.Option.SOME (tyfun, funcount) =>
d550 1
a550 1
	MLWorks.Option.SOME (strname',count) =>
d556 1
a556 1
	MLWorks.Option.SOME (tyfun', count) =>
d747 1
a747 1
	      MLWorks.Option.SOME res => res
d806 1
a806 1
		MLWorks.Option.SOME result => result
d971 1
a971 1
	  (StrnameSet.empty_set(Lists.length olds div 4), olds)
d997 1
a997 1
	  (TyfunSet.empty_set(Lists.length olds div 4), olds)
d1026 1
a1026 1
	    MLWorks.Option.SOME the_list' =>
d1067 1
a1067 1
	      MLWorks.Option.SOME str => subAssemblies(str_ass, ty_ass, str)
@


1.56.3.1
log
@branched from 1.56
@
text
@a3 6
 * Revision 1.56  1996/04/30  16:00:25  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.56.2.1
log
@branched from 1.56
@
text
@a3 6
 * Revision 1.56  1996/04/30  16:00:25  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.56.1.1
log
@branched from 1.56
@
text
@a3 6
 * Revision 1.56  1996/04/30  16:00:25  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.55
log
@Removing MLWorks.Integer.
@
text
@d4 3
d411 1
a411 1
	    implode
d415 1
a415 1
		implode[IdentPrint.printTyCon tycon, " --> ",
d430 1
a430 1
	    implode
d434 1
a434 1
		implode[IdentPrint.printStrId strid, " --> ",
d444 1
a444 1
	implode
d447 1
a447 1
	    implode[Strnames.string_strname strname, " |--> ",
d469 1
a469 1
      implode
@


1.54
log
@Change newhashtable to hashtable
@
text
@d4 3
d172 2
d399 1
a399 1
      (MLWorks.Integer.makestring n) ^ ")\n"
d418 1
a418 1
      (MLWorks.Integer.makestring n) ^ ")\n"
d463 1
a463 1
      "(" ^ (str_ce ce) ^ "," ^ (MLWorks.Integer.makestring n) ^ ")"
@


1.53
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
d175 1
a175 1
require "../utils/newhashtable";
d202 1
a202 1
  structure NewHashTable : NEWHASHTABLE
d565 1
a565 1
		 NewHashTable.lookup(str_assembly, strname')
d567 1
a567 1
	       (NewHashTable.update(str_assembly, strname',
d574 2
a575 2
	     end) handle NewHashTable.Lookup =>
	       (NewHashTable.update(str_assembly, strname',
d613 1
a613 1
	   val (ce',count) = NewHashTable.lookup(ty_ass, tyfun)
d616 1
a616 1
	     (NewHashTable.update(ty_ass, tyfun, (ce,count+num:int));
d620 2
a621 2
	 end handle NewHashTable.Lookup =>
	   (NewHashTable.update(ty_ass, tyfun, (ce, num));
d735 1
a735 1
	    val (ce, count') = NewHashTable.lookup_default(ty_ass, (ce',0), tyfun)
d749 1
a749 1
		  NewHashTable.delete(ty_ass, tyfun)
d751 1
a751 1
		  NewHashTable.update(ty_ass, tyfun, (ce,count'-1))
d764 1
a764 1
	    NewHashTable.lookup_default
d772 1
a772 1
	    ((NewHashTable.delete(str_assmap', m);
d775 1
a775 1
	    ((NewHashTable.update(str_assmap', m, (str_offsmap,ty_offsmap));
d802 2
a803 2
		    val new_str_ass = NewHashTable.copy str_ass
		    val new_ty_ass = NewHashTable.copy ty_ass
d826 2
a827 2
	val str_ass' = NewHashTable.new(hash_size,Strnames.strname_eq,NameHash.strname_hash)
	val ty_ass' = NewHashTable.new(hash_size,Types.tyfun_eq,NameHash.tyfun_hash)
d830 1
a830 1
	  (fn (str, ran) => NewHashTable.update(str_ass', str, ran))
d836 1
a836 1
	   (fn (tyfun, ran) => NewHashTable.update(ty_ass', tyfun, ran))
d842 2
a843 2
	((NewHashTable.to_list str_ass'),
	 NewHashTable.fold
d927 2
a928 2
	  val str_ass' = NewHashTable.new(hash_size,Strnames.strname_eq,NameHash.strname_hash)
	  val ty_ass' = NewHashTable.new(hash_size,Types.tyfun_eq,NameHash.tyfun_hash)
d932 2
a933 2
	  ((NewHashTable.to_list str_ass'),
	   NewHashTable.fold
@


1.52
log
@Supply a modified version of expand_str which only does the
expansion necessary for assemblies, ie no value environments
and no constructor environments.
@
text
@d4 5
d228 1
a228 1
    type TypeOffspring = (Ident.TyCon,Tyfun * int) NewMap.T
d230 1
a230 1
    type StrOffspring = (Ident.StrId,Strname * int) NewMap.T
@


1.51
log
@Use Stamp instead of Tyname_id etc.
@
text
@d4 3
d655 45
d773 1
d775 2
d867 1
d869 2
d1070 1
a1070 2
	((*output(std_out, "Giving\n" ^ string_assembly result);*)
	 result)
d1079 1
d1081 2
d1091 1
d1093 2
d1119 1
d1121 2
d1131 1
d1133 2
@


1.50
log
@Removing debug stuff
@
text
@d4 3
d313 1
a313 1
      Datatypes.Strname_id.strname_id id
d315 1
a315 1
      Datatypes.Strname_id.strname_id id
d678 1
a678 1
	    | _ => (NULL_TYFUN (Tyfun_id.make_tyfun_id (),(ref(TYFUN(NULLTYPE,0)))),0)
d735 1
a735 1
		  (NULLNAME (Strname_id.make_strname_id ()),0)
@


1.49
log
@Use pervasive Option.option for return values in NewMap
@
text
@d4 3
a162 1
require "../typechecker/ty_debug";
a165 1
require "../typechecker/tystr";
a180 1
  structure Ty_Debug  : TY_DEBUG
a183 1
  structure Tystr     : TYSTR
d190 1
a190 6
  structure Debug     : sig
			  val set_debug_level : int -> unit
			  val debug_level : unit -> int
			end
  sharing Strnames.Datatypes =
    Tystr.Datatypes = Conenv.Datatypes =
a207 8
    val do_debug = Ty_Debug.do_debug

    fun debug L  =
      if do_debug andalso Debug.debug_level () > 10 then
	(Lists.iterate Print.print L)
      else
	()

d470 1
a470 1
    fun InStrOffspringDomain(strid, amap) =
d477 1
a477 1
    fun InTypeOffspringDomain(tycon, amap) =
d482 3
a484 1
    fun getTypeOffspringMap amap = amap
a971 21
    fun StrOffspring_to_map str_offs = str_offs
    fun map_to_StrOffspring str_offs = str_offs
    fun TypeOffspring_to_map ty_offs = ty_offs
    fun map_to_TypeOffspring ty_offs = ty_offs
    fun StrAssembly_to_list str_ass = str_ass
    fun list_to_StrAssembly str_ass = str_ass
    fun TypeAssembly_to_map ty_ass = ty_ass
    fun map_to_TypeAssembly ty_ass = ty_ass
    fun list_to_TypeAssembly list =
      Lists.reducel
      (fn (map, arg as (tyfun, _)) =>
       let
	 val hash = NameHash.tyfun_hash tyfun
	 val list = case IntMap.tryApply'(map, hash) of
	   MLWorks.Option.SOME list => list
	 | MLWorks.Option.NONE => []
       in
	 IntMap.define(map, hash, arg :: list)
       end)
      (IntMap.empty, list)

d987 3
a989 5
	   (let
	      val str = Strenv.lookup(strid, se')
	    in
	      subAssemblies(str_ass, ty_ass, str)
	    end handle Strenv.Lookup_in_SE => arg1))
d1008 1
a1008 1
	    end handle Tyenv.Lookup_in_TE => ty_ass))
@


1.48
log
@Hash table rationizations
@
text
@d4 3
d276 1
a276 1
	IntMap.YES the_list =>
d299 1
a299 1
	  IntMap.YES the_list =>
d316 1
a316 1
	  IntMap.YES [] =>
d318 1
a318 1
	| IntMap.YES the_list =>
d486 1
a486 1
	NewMap.NO => false
d493 1
a493 1
	NewMap.NO => false
d514 1
a514 1
	    NewMap.YES(strname, count) =>
d525 1
a525 1
	    NewMap.YES(tyfun, funcount) =>
d534 1
a534 1
	NewMap.YES(strname',count) =>
d540 1
a540 1
	NewMap.YES(tyfun', count) =>
d686 1
a686 1
	      NewMap.YES res => res
d742 1
a742 1
		NewMap.YES result => result
d959 1
a959 1
	    IntMap.YES the_list' =>
d998 2
a999 2
	   IntMap.YES list => list
	 | IntMap.NO => []
@


1.47
log
@Replaced option in NULL_TYFUNs for polymorphic debugger.
@
text
@d4 3
d205 6
d337 2
a338 2
    val empty_str_offspring = NewMap.empty' Ident.strid_lt
    val empty_type_offspring = NewMap.empty' Ident.tycon_lt
d773 2
a774 2
	val str_ass' = NewHashTable.new(512,Strnames.strname_eq,NameHash.strname_hash)
	val ty_ass' = NewHashTable.new(512,Types.tyfun_eq,NameHash.tyfun_hash)
d871 2
a872 2
	  val str_ass' = NewHashTable.new(512,Strnames.strname_eq,NameHash.strname_hash)
	  val ty_ass' = NewHashTable.new(512,Types.tyfun_eq,NameHash.tyfun_hash)
@


1.46
log
@Added level slot to Basis structure.
@
text
@d4 3
d675 1
a675 1
	    | _ => (NULL_TYFUN (Tyfun_id.make_tyfun_id (),Option.ABSENT),0)
@


1.45
log
@Remove old debugging code and inexhuastive bindings.
@
text
@d4 3
d996 1
a996 1
			   Basistypes.BASIS(_, Basistypes.FUNENV fun_map, _,
d999 1
a999 1
			   Basistypes.BASIS(_, Basistypes.FUNENV fun_map', _,
d1038 1
a1038 1
      (Basistypes.BASIS(_, Basistypes.FUNENV fun_map, _,
d1072 1
a1072 1
      (Basistypes.BASIS(_, Basistypes.FUNENV fun_map, _,
@


1.44
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.
@
text
@d4 4
d436 3
a461 3
      (if do_debug
         then debug ["Assemblies.lookupTyfun ", (Types.string_tyfun tyfun)]
       else ();
a462 1
	 )
d531 1
a531 5
	(if do_debug
           then debug ["Assemblies.lookupStrname ",
                       (Strnames.string_strname strname')]
         else ();
	 lookup_str(strname',amap))
a604 4
      (if do_debug
         then debug ["add_to_TypeAssembly - tyfun = ",
                     (Types.string_tyfun tyfun)]
       else ();
a614 1
	     )
d636 1
a636 5
      (if do_debug 
         then debug ["Assemblies.remfromStrAssembly ",
	             (Strnames.string_strname strname)]
       else ();
	 (remove_str(strname,amap)))
a638 4
      (if do_debug
         then debug ["Assemblies.remfromTypeAssembly ",
	             (Types.string_tyfun tyfun)]
       else ();
d641 1
a641 1
	 |_ => (amap, 0))
d696 13
a708 22
      (if do_debug 
         then debug ["Assemblies.subAssemblies ",
	             (Strnames.string_strname m)]
      else ();

	 (if not(Strnames.uninstantiated m) then
	    let
	      val (str_offs, ty_offs) =
		NewHashTable.lookup_default
		(str_ass, (empty_str_offspring, empty_type_offspring), m)
	      val (str_offsmap, str_assmap', ty_ass') =
		subSE(str_ass, ty_ass, str_offs, se)
	      val (ty_ass'', ty_offsmap) =
		subTE (ty_ass',ty_offs,te)
	    in
	      if NewMap.is_empty str_offsmap andalso NewMap.is_empty ty_offsmap then
		((NewHashTable.delete(str_assmap', m);
		  str_assmap'), ty_ass'')
	      else
		((NewHashTable.update(str_assmap', m, (str_offsmap,ty_offsmap));
		  str_assmap'), ty_ass'')
	    end
d710 5
a714 1
	    (str_ass, ty_ass)))
d781 11
a791 15
      (if do_debug 
         then debug ["Assemblies.subTypeAssembly ",(Types.string_tyfun tyfun)]
       else ();

       if Conenv.empty_valenvp ce then
	 ty_ass
       else 
	 let
	   val (ce',count) = lookup(tyfun, amap)
	 in
	   if count = 1 then
	     remove(tyfun, amap)
	   else
	     update((tyfun, (ce, count - 1)), amap)
	 end)
d894 12
a905 14
      (if do_debug then debug ["unionStrAssembly"] else ();
	 let
	   val (ins, outs) = split(str_ass, amap')
	   (* Only need to handle those already there specially *)
	   (* Note we split the large set, relative to the small one *)
	   (* Thus most of it will be in the outs, and can just be prepended *)
	   fun union([],str_ass) = str_ass
	     | union((strname, (str_offs,ty_offs))::strnames,str_ass) =
	       union(strnames, add_to_StrAssembly(strname,str_offs,ty_offs,
						str_ass))
	 in
	   outs rev_app union(ins, amap')
	 end
     )
d938 10
a947 11
      (if do_debug then debug ["Assemblies.unionTypeAssembly"] else ();
	 let
	   fun unite_lists(ty_ass, i, the_list) =
	     case IntMap.tryApply'(ty_ass, i) of
	       IntMap.YES the_list' =>
		 IntMap.define(ty_ass, i,
			       unionTypeAssemblyLists(the_list, the_list'))
	     | _ => IntMap.define(ty_ass, i, the_list)
	 in
	   IntMap.fold unite_lists (ty_ass, amap')
	 end)
d1040 1
a1040 1
	    val STR(m, _,env) = Env.expand_str str
d1049 1
a1049 1
	    val STR(m, _,env) = Env.expand_str str
d1074 1
a1074 1
	    val STR(m, _, env) = Env.expand_str str
d1083 1
a1083 1
	    val STR(m, _, env) = Env.expand_str str
@


1.44.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.44  1993/07/08  13:51:22  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.

@


1.43
log
@Removed exception environments.
@
text
@d4 3
d683 1
a683 1
	    | _ => (NULL_TYFUN (Tyfun_id.make_tyfun_id ()),0)
@


1.42
log
@Various improvements, particularly to do with signatures embedded in structures
@
text
@d4 3
d8 2
a9 2
Fixed new_assemblies_from basis and compose_assemblies to deal with the possibility
of the F component of the basis keeping structures alive
d705 1
a705 1
    fun internal_subAssemblies (str_ass, ty_ass, STR(m, _,ENV(se,te,_,_))) =
d813 1
a813 1
    fun newTypeAssembly (ENV (se,te as TE amap,_,_),ty_assembly) =
d843 1
a843 1
      fun internal_newAssemblies(strname, ENV(se,te,_,_),str_ass, ty_ass, allow_meta) =
d1017 1
a1017 1
					    ENV(SE se, TE te, _, _)),
d1020 1
a1020 1
					    ENV(se', te', _, _))) =
d1059 1
a1059 1
			env as ENV(Datatypes.SE se, _, _, _))) =
d1063 1
a1063 1
	    val STR(m, _, env) = Env.expand_str str
d1072 1
a1072 1
	    val STR(m, _, env) = Env.expand_str str
d1093 1
a1093 1
			env as ENV(Datatypes.SE se, _, _, _))) =
@


1.41
log
@Fixed new_assemblies_from basis and compose_assemblies to deal with the possibility
of the F component of the basis keeping structures alive
@
text
@d4 4
d850 1
a850 1
	      collectTypeInfo(te,empty_type_offspring,ty_ass)
d1080 33
@


1.40
log
@Cleaned up after assembly changes
@
text
@d4 3
d657 7
d666 1
a666 28
    fun internal_subAssemblies (str_ass, ty_ass, STR(m, _,ENV(se,te,_,_))) =
      (* Internally imperative form *)
      (if do_debug 
         then debug ["Assemblies.subAssemblies ",
	             (Strnames.string_strname m)]
      else ();

      let  
	val (str_offs, ty_offs) =
	  NewHashTable.lookup_default(str_ass,
				(empty_str_offspring, empty_type_offspring), m)

	val (str_offsmap, str_assmap', ty_ass') =
	  subSE(str_ass, ty_ass, str_offs, se)
	val (ty_ass'', ty_offsmap) =
	  subTE (ty_ass',ty_offs,te)
      in
	if NewMap.is_empty str_offsmap andalso NewMap.is_empty ty_offsmap then
	  ((NewHashTable.delete(str_assmap', m);
	    str_assmap'), ty_ass'')
	else
	  ((NewHashTable.update(str_assmap', m, (str_offsmap,ty_offsmap));
	    str_assmap'), ty_ass'')
      end)
      | internal_subAssemblies (str_ass,ty_ass,str) =
        internal_subAssemblies (str_ass,ty_ass, Env.expand_str str)

    and subTE (ty_ass, type_offspring, TE amap) =
d698 29
d739 2
a740 1
		  (* When the count is zero, we don't want the result *)
d742 1
d747 1
d828 3
a830 3
	fun collect ((type_offspring,ty_ass), tycon, TYSTR (tyfun,ce)) =
	  (add_to_TypeOffspring(tycon,tyfun,1,type_offspring),
	   add_to_TypeAss(tyfun,ce,1,ty_ass))
d832 1
a832 1
	fun collectTypeInfo (TE amap,ty_offs,ty_ass) =
d836 1
a836 1
      fun internal_newAssemblies(strname,ENV (se,te,_,_),str_ass, ty_ass) =
d838 6
a843 1
	  val str_offspring = collectStrOffspring (se,empty_str_offspring)
d845 9
a853 4
	    collectTypeInfo (te,empty_type_offspring,ty_ass)
	  val str_ass' = add_to_StrAss(strname,
				       str_offspring,type_offspring,
				       str_ass)
d855 1
a855 1
	  collectStrInfo (se,str_ass',ty_ass')
d858 2
a859 2
      and collectStrInfo (SE amap, str_ass, ty_ass) =
	NewMap.fold collect ((str_ass,ty_ass), amap)
d861 4
a864 4
      and collect ((str_ass,ty_ass), strid, STR (m,_,env)) =
	internal_newAssemblies(m,env,str_ass,ty_ass)
	| collect (asses,strid,COPYSTR ((smap,tmap),str)) =
	  collect (asses,strid,Env.str_copy(str,smap,tmap))
d866 1
a866 1
      fun newAssemblies(strname, env) =
d871 2
a872 2
	  val (str_ass', ty_ass') =
	    internal_newAssemblies(strname, env, str_ass', ty_ass')
d1008 6
a1013 3
			   new_basis as Basistypes.BASIS(_, _, _,
							 ENV(SE se, TE te, _, _)),
			   old_basis as Basistypes.BASIS(_, _, _, ENV(se', te', _, _))) =
d1016 1
a1016 8
(*
	val _ = output(std_out, "Compose\n")
	val _ = output(std_out, string_assembly old_ass)
	val _ = output(std_out, "with\n")
	val _ = output(std_out, string_assembly new_ass)
*)

	val (str_ass', ty_ass') = NewMap.fold
d1024 11
d1051 2
a1052 1
      (Basistypes.BASIS(_, _, _, env as ENV(Datatypes.SE se, TE te, _, _))) =
d1057 1
a1057 1
	    val (str_ass', ty_ass') = newAssemblies(m, env)
d1062 11
d1075 7
a1081 4
	new_str
	((empty_strassembly(),
	  newTypeAssembly(env, empty_tyassembly)),
	 se)
d1084 1
@


1.39
log
@Added a function for combining assemblies after elaboration of a topdec,
including dealing with shadowing
@
text
@d4 4
d429 1
a429 1
	a_list)
a431 2
    fun stringTypeAssembly _ = Crash.unimplemented"stringTypeAssembly"

d978 3
d988 7
d1011 2
d1014 21
a1034 1
	(unionStrAssembly(str_ass', str_ass), unionTypeAssembly(ty_ass', ty_ass))
@


1.38
log
@Removed integer parameter
@
text
@d4 3
d133 1
d136 1
d153 1
d157 1
d162 1
a162 1
  sharing Strnames.Datatypes = 
d164 3
a166 2
    Tyenv.Datatypes = Env.Datatypes = 
    Types.Datatypes = NameHash.Datatypes
d168 3
a170 3
 sharing type StrnameSet.element = Types.Datatypes.Strname
 sharing type TyfunSet.element = Types.Datatypes.Tyfun
) : ASSEMBLIES = 
d174 1
d208 6
d251 1
a251 1
	  elem :: (acc @@ rest)
d268 1
a268 1
	  acc @@ rest
d318 11
d335 1
a335 1
	      then acc @@ xs
d353 1
a353 1
    fun printTyfun_int (tyfun,n) = 
d372 1
a372 1
    fun printStrname_int (strname,n) = 
d376 1
a376 1
    fun stringStrOffspring amap = 
d391 1
a391 1
    fun stringOffspring (stroff,tyoff) = 
d412 1
d414 2
a415 1
    fun printCE_int (ce,n) = 
d434 1
a434 1
    fun lookupStrId (strid, amap) = 
d439 1
a439 1
    fun lookupTyfun (tyfun, amap) = 
d462 1
a462 1
    fun findStrOffspring(strname, amap : StrAssembly) = 
d465 1
a465 1
    fun findTypeOffspring (strname, amap : StrAssembly) = 
d502 1
a502 1
    fun add_to_TypeOffspring (tycon,tyfun,num, amap) = 
d550 8
a557 14
      (if do_debug
         then debug ["add_to_StrAssembly - strname = ",
	             (Strnames.string_strname strname)]
       else ();
       let
	 val strname' = Strnames.strip strname
       in
	 if not (empty_str_offspringp str_offspring 
		 andalso 
		 empty_type_offspringp type_offspring) then
	   ((let
	       val (str_offspring',type_offspring') =
		 lookup_str'(strname', amap)
	     in
d559 6
a564 10
			   (str_offsunion (str_offspring',
					   str_offspring),
			    ty_offsunion(type_offspring',
					 type_offspring))), amap)
	     end) handle Assoc => add_new_str((strname',(str_offspring,
						         type_offspring)),
                                               amap))
	 else
	   str_assembly
       end)
d572 1
a572 1
    fun add_to_TypeAss(tyfun,ce,num,ty_ass) = 
d590 1
a590 1
    fun add_to_TypeAssembly (tyfun,ce,num,ty_assembly as amap) = 
d607 1
a607 1
    fun collectStrOffspring (SE amap,str_offspring) = 
d618 1
a618 1
    fun collectTypeOffspring (TE amap,type_offspring) = 
d626 1
a626 1
    fun remfromStrAssembly (strname, amap) = 
d633 1
a633 1
    fun remfromTypeAssembly (tyfun, amap) = 
d671 1
a671 2
	if
	  NewMap.is_empty str_offsmap andalso NewMap.is_empty ty_offsmap then
d681 1
a681 1
    and subTE (ty_ass, type_offspring, TE amap) = 
d713 1
a713 1
    and subSE (str_ass, ty_ass, str_offspring, SE amap) = 
d772 1
a772 1
    fun subTypeAssembly (tyfun,ce,ty_ass as amap) = 
d777 2
a778 2
       if Conenv.empty_valenvp ce 
	 then ty_ass
d789 1
a789 1
    fun newTypeAssembly (ENV (se,te as TE amap,_,_),ty_assembly) = 
d798 1
a798 1
    and seTypeAssembly (SE amap,ty_assembly) = 
d810 6
a815 6
      fun collectTypeInfo (TE amap,ty_offs,ty_ass) = 
	let
	  fun collect ((type_offspring,ty_ass), tycon, TYSTR (tyfun,ce)) =
	    (add_to_TypeOffspring(tycon,tyfun,1,type_offspring),
	     add_to_TypeAss(tyfun,ce,1,ty_ass))
	in
d817 1
a817 1
	end
d819 1
a819 1
      fun internal_newAssemblies(strname,ENV (se,te,_,_),str_ass, ty_ass) = 
d831 2
a832 9
      and collectStrInfo (SE amap, str_ass, ty_ass) = 
	let 
	  fun collect ((str_ass,ty_ass), strid, STR (m,_,env)) =
	    internal_newAssemblies(m,env,str_ass,ty_ass)
            | collect (asses,strid,COPYSTR ((smap,tmap),str)) =
              collect (asses,strid,Env.str_copy(str,smap,tmap))
	in
	  NewMap.fold collect ((str_ass,ty_ass), amap)
	end
d834 5
d887 1
a887 1
	     | union((strname, (str_offs,ty_offs))::strnames,str_ass) = 
d891 1
a891 1
	   outs @@ union(ins, amap')
d922 1
a922 1
	outs @@ union(ins, l2)
d944 1
a944 1
    fun updateTypeAssembly (TE amap,ty_ass) = 
d975 28
@


1.37
log
@Added a list to Type_Assembly function for input of assemblies
@
text
@d4 3
a117 1
require "../utils/integer";
a141 1
  structure Integer   : INTEGER
d329 1
a329 1
      (Integer.makestring n) ^ ")\n"
d348 1
a348 1
      (Integer.makestring n) ^ ")\n"
d388 1
a388 1
      "(" ^ (str_ce ce) ^ "," ^ (Integer.makestring n) ^ ")"
@


1.36
log
@NameHash.DataTypes now NameHash.Datatypes
@
text
@d4 3
d947 12
a959 1

@


1.35
log
@Modified to use the new hashset with variable size tables
@
text
@d4 3
d154 1
a154 1
    Types.Datatypes = NameHash.DataTypes
@


1.34
log
@Changes to Env representation
,
@
text
@d4 4
d850 1
a850 1
	  (StrnameSet.empty_set(), olds)
d878 1
a878 1
	  (TyfunSet.empty_set(), olds)
@


1.33
log
@Error message improvements
@
text
@d4 3
d580 1
a580 1
	fun collect (str_offspring, strid, STR(m, _)) =
d582 3
d625 1
a625 2

    fun internal_subAssemblies (str_ass, ty_ass, STR(m, ENV(se,te,_,_))) =
d650 2
d772 1
a772 1
	fun gather (ty_assembly, strid, STR (_,env)) =
d774 2
d805 1
a805 1
	  fun collect ((str_ass,ty_ass), strid, STR (m,env)) =
d807 2
@


1.32
log
@Modified to new improved hashset signature
@
text
@d4 3
d528 2
a529 1
						   type_offspring)), amap))
d553 1
a553 1
	     raise Consistency "type structures are inconsistent"
d571 1
a571 1
	       raise Consistency "type structures are inconsistent"
d878 1
a878 1
	    raise Consistency"inconsistent constructor environments"
@


1.31
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d828 4
a831 1
	val strnames = StrnameSet.list_to_set(map (fn (x, _) => x) olds)
d834 1
a834 1
	(fn (strname, _) => StrnameSet.is_member(strname, strnames))
d856 4
a859 1
	val tyfuns = TyfunSet.list_to_set(map (fn (x, _) => x) olds)
d862 1
a862 1
	(fn (tyfun, _) => TyfunSet.is_member(tyfun, tyfuns))
a920 5
(*
      NewMap.from_list'
      (op< : int * int -> bool)
      (IntMap.to_list_ordered ty_ass)
*)
a921 4
(*
      IntMap.from_list
      (NewMap.to_list_ordered ty_ass)
*)
@


1.30
log
@Added IntMap structure for type assemblies
@
text
@d4 3
d307 1
a307 1
      "(" ^ (Types.string_tyfun_using_default tyfun) ^ "," ^
d359 1
a359 1
	val string_tyfun = (Types.string_tyfun_using_default tyfun)
d392 1
a392 1
         then debug ["Assemblies.lookupTyfun ", (Types.string_tyfun_using_default tyfun)]
d553 1
a553 1
                     (Types.string_tyfun_using_default tyfun)]
d593 1
a593 1
	             (Types.string_tyfun_using_default tyfun)]
d731 1
a731 1
         then debug ["Assemblies.subTypeAssembly ",(Types.string_tyfun_using_default tyfun)]
@


1.29
log
@Recast in terms of intnewmap
@
text
@d4 3
d141 1
a141 1

d907 2
a908 1
    fun TypeAssembly_to_map ty_ass =
d912 3
a914 1
    fun map_to_TypeAssembly ty_ass =
d917 1
a917 1

@


1.28
log
@Modified to use less than functions for maps
@
text
@d4 3
d88 1
d110 1
d163 1
a163 1
    type TypeAssembly = (int, (Tyfun * (Valenv * int)) list) NewMap.T
d170 1
a170 1
    exception Assoc = NewMap.Undefined
d188 1
a188 1
	val the_list = NewMap.apply'(amap, NameHash.tyfun_hash tyfun)
d194 2
a195 2
      case NewMap.tryApply'(amap, NameHash.tyfun_hash tyfun) of
	NewMap.YES the_list =>
d217 4
a220 4
	case NewMap.tryApply'(amap, hash) of
	  NewMap.YES the_list =>
	    NewMap.define(amap, hash, usub([], the_list, arg))
	| _ => NewMap.define(amap, hash, [arg])
d234 5
a238 5
	case NewMap.tryApply'(amap, hash) of
	  NewMap.YES [] =>
	    NewMap.undefine(amap, hash)
	| NewMap.YES the_list =>
	    NewMap.define(amap, hash, rsub([], the_list, tyfun))
d263 1
a263 1
    val empty_tyassembly = NewMap.empty' (op< : int * int -> bool)
d365 1
a365 1
      (NewMap.fold
d708 1
a708 1
	  NewMap.iterate
d872 3
a874 3
	     case NewMap.tryApply'(ty_ass, i) of
	       NewMap.YES the_list' =>
		 NewMap.define(ty_ass, i,
d876 1
a876 1
	     | _ => NewMap.define(ty_ass, i, the_list)
d878 1
a878 1
	   NewMap.fold unite_lists (ty_ass, amap')
d904 7
a910 2
    fun TypeAssembly_to_map ty_ass = ty_ass
    fun map_to_TypeAssembly ty_ass = ty_ass
@


1.27
log
@Anel's changes for encapsulating assemblies
@
text
@d4 3
d254 2
a255 2
    val empty_str_offspring = NewMap.empty' Ident.strid_order
    val empty_type_offspring = NewMap.empty' Ident.tycon_order
@


1.26
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d890 9
d900 1
@


1.25
log
@Changed hashtables to a single structure implementation
@
text
@d4 3
d290 1
a290 1
      "(" ^ (Types.string_tyfun tyfun) ^ "," ^
d342 1
a342 1
	val string_tyfun = (Types.string_tyfun tyfun)
d375 1
a375 1
         then debug ["Assemblies.lookupTyfun ", (Types.string_tyfun tyfun)]
d536 1
a536 1
                     (Types.string_tyfun tyfun)]
d576 1
a576 1
	             (Types.string_tyfun tyfun)]
d714 1
a714 1
         then debug ["Assemblies.subTypeAssembly ",(Types.string_tyfun tyfun)]
@


1.24
log
@Replaced two handles with lookup_default instead. Should perform better
for us if not for NJ
@
text
@d4 4
a81 1
require "../utils/_newhashtable";
d109 1
a285 22
    structure TypeAss = NewHashTable(
      structure Array = Array
      structure Crash = Crash
      structure Lists = Lists
      type Key = Tyfun
      type Value = Valenv * int
      val eq = Types.tyfun_eq
      val hash = NameHash.tyfun_hash
      val size = 512
  )

    structure StrAss = NewHashTable(
      structure Array = Array
      structure Crash = Crash
      structure Lists = Lists
      type Key = Strname
      type Value = StrOffspring * TypeOffspring
      val eq = Strnames.strname_eq
      val hash = NameHash.strname_hash
      val size = 512
  )

d462 1
a462 1
		 StrAss.lookup(str_assembly, strname')
d464 1
a464 1
	       (StrAss.update(str_assembly, strname',
d471 2
a472 2
	     end) handle StrAss.Lookup _ =>
	       (StrAss.update(str_assembly, strname',
d519 1
a519 1
	   val (ce',count) = TypeAss.lookup(ty_ass, tyfun)
d522 1
a522 1
	     (TypeAss.update(ty_ass, tyfun, (ce,count+num:int));
d526 2
a527 2
	 end handle TypeAss.Lookup _ =>
	   (TypeAss.update(ty_ass, tyfun, (ce, num));
d601 1
a601 1
	  StrAss.lookup_default(str_ass,
d603 1
a603 3
(*
	  handle StrAss.Lookup _ => (empty_str_offspring, empty_type_offspring)
*)
d611 1
a611 1
	  ((StrAss.delete(str_assmap', m);
d614 1
a614 1
	  ((StrAss.update(str_assmap', m, (str_offsmap,ty_offsmap));
d626 2
a627 4
	    val (ce, count') = TypeAss.lookup_default(ty_ass, (ce',0), tyfun)
(*
	      handle TypeAss.Lookup _ => (ce',0)
*)
d640 1
a640 1
		  TypeAss.delete(ty_ass, tyfun)
d642 1
a642 1
		  TypeAss.update(ty_ass, tyfun, (ce,count'-1))
d664 2
a665 2
		    val new_str_ass = StrAss.copy str_ass
		    val new_ty_ass = TypeAss.copy ty_ass
d687 2
a688 2
	val str_ass' = StrAss.new()
	val ty_ass' = TypeAss.new()
d691 1
a691 1
	  (fn (str, ran) => StrAss.update(str_ass', str, ran))
d697 1
a697 1
	   (fn (tyfun, ran) => TypeAss.update(ty_ass', tyfun, ran))
d703 2
a704 2
	((StrAss.to_list str_ass'),
	 TypeAss.fold
d777 2
a778 2
	  val str_ass' = StrAss.new()
	  val ty_ass' = TypeAss.new()
d782 2
a783 2
	  ((StrAss.to_list str_ass'),
	   TypeAss.fold
@


1.23
log
@Removed use of strname_hash for structure assemblies. Removed cases
of tyfuns getting negative counts is type assemblies
@
text
@d4 4
a232 3
(*
	val hash = strname_hash strname
*)
d235 1
a235 2
	    if (*strname_hash x = hash andalso*) Strnames.strname_eq(strname, x)
	      then y
a249 3
(*
	val hash = strname_hash strname
*)
d252 1
a252 2
	    if (*strname_hash x = hash andalso*) Strnames.strname_eq(strname, x)
	      then y
a260 3
(*
	val hash = strname_hash strname
*)
d263 1
a263 1
	    if (*strname_hash x = hash andalso*) Strnames.strname_eq(strname, x)
a292 8
(*
    fun strname_hash(Datatypes.STRNAME id) =
      Datatypes.Strname_id.strname_id id
    | strname_hash(Datatypes.NULLNAME id) =
      Datatypes.Strname_id.strname_id id
    | strname_hash(Datatypes.METASTRNAME(ref s)) = strname_hash s
*)

a303 5
(*
    fun strname_order((str1, _), (str2, _)) =
      strname_hash str1 < strname_hash str2
*)

d618 4
a621 1
	val (str_offs, ty_offs) = StrAss.lookup(str_ass, m) 
d623 1
d646 2
a647 1
	    val (ce, count') = TypeAss.lookup(ty_ass, tyfun)
d649 1
@


1.22
log
@Changed implementation of TypeAssembly to use a tree of lists from
hash values
@
text
@d4 4
d229 1
d231 1
d234 1
a234 1
	    if strname_hash x = hash andalso Strnames.strname_eq(strname, x)
d250 1
d252 1
d255 1
a255 1
	    if strname_hash x = hash andalso Strnames.strname_eq(strname, x)
d265 1
d267 1
d270 1
a270 1
	    if strname_hash x = hash andalso Strnames.strname_eq(strname, x)
d300 1
d306 1
d319 1
d322 1
d672 1
a672 1
	      if Conenv.empty_valenvp ce' then
@


1.21
log
@Some minor improvements to remove some handlers and avoid wasting
time in others
@
text
@d4 4
a135 2
    type TypeAssembly =
      ((Tyfun * int) * (Valenv * int)) list
d137 1
d139 1
a139 1
  Implement the above using an association list with embedded has values
a140 1
    exception Assoc
d142 1
a142 11
    fun lookup((tyfun, hash), a_list) =
      let
	fun lsub [] = raise Assoc
	  | lsub(((tyfun', hash'), result) :: rest) =
	    if hash = hash' andalso Types.tyfun_eq(tyfun, tyfun') then
	      result
	    else
	      lsub rest
      in
	lsub a_list
      end
d144 17
a160 1
    fun lookup'((tyfun, hash), a_list) =
d162 1
a162 6
	fun lsub [] = (empty_valenv, 0)
	  | lsub(((tyfun', hash'), result) :: rest) =
	    if hash = hash' andalso Types.tyfun_eq(tyfun, tyfun') then
	      result
	    else
	      lsub rest
d164 1
a164 1
	lsub a_list
d167 11
d180 8
a187 1
    fun update(elem as ((tyfun, hash), _), a_list) =
d189 1
a189 6
	fun usub(acc, []) = elem :: acc
	  | usub(acc, (elem' as ((tyfun', hash'), _)) :: rest) =
	    if hash = hash' andalso Types.tyfun_eq(tyfun, tyfun') then
	      elem :: (acc @@ rest)
	    else
	      usub(elem' :: acc, rest)
d191 4
a194 1
	usub([], a_list)
d197 8
a204 1
    fun remove((tyfun, hash), a_list) =
d206 1
a206 6
	fun rsub(acc, []) = acc
	  | rsub(acc, (elem' as ((tyfun', hash'), _)) :: rest) =
	    if hash = hash' andalso Types.tyfun_eq(tyfun, tyfun') then
	      acc @@ rest
	    else
	      rsub(elem' :: acc, rest)
d208 6
a213 1
	rsub([], a_list)
d239 1
a239 1
    val empty_tyassembly = []
a309 4
    val empty_strassembly = fn _ => []

    val empty_tyassembly = []

d373 9
a381 7
    fun stringTypeAssembly [] = ""
      | stringTypeAssembly a_list =
	implode
	(map
	 (fn ((tyfun, _), r) =>
	  print_tyfun tyfun ^ " | --> " ^ printCE_int r)
	 a_list)
d383 2
d398 2
a399 1
	 lookup'((tyfun, NameHash.tyfun_hash tyfun), amap))
d562 2
a563 6
	 let 
	   val tyfun_hash = NameHash.tyfun_hash tyfun
	 in
	   let
	     val (ce',count) = lookup((tyfun, tyfun_hash),amap)
	   in
d565 1
a565 1
	       update(((tyfun, tyfun_hash) ,(ce,count+num:int)), amap)
d568 2
a569 2
	   end handle Assoc => update(((tyfun, tyfun_hash), (ce, num)), amap)
	 end)
d599 3
a601 7
       let
	 val tyfun_hash = NameHash.tyfun_hash tyfun
	 val count = #2 (lookup((tyfun, tyfun_hash) ,amap : TypeAssembly))
       in
	 (remove((tyfun, tyfun_hash) ,amap), count)
       end handle Assoc => (amap, 0)
	 )
d716 5
a720 2
	  Lists.iterate
	  (fn ((tyfun, _), ran) => TypeAss.update(ty_ass', tyfun, ran))
d726 3
a728 2
	 (map (fn (tyfun, ran) => ((tyfun, NameHash.tyfun_hash tyfun), ran))
	  (TypeAss.to_list ty_ass')))
d740 1
a740 2
	   val tyfun_hash = NameHash.tyfun_hash tyfun
	   val (ce',count) = lookup((tyfun, tyfun_hash) ,amap)
d743 1
a743 1
	     remove((tyfun, tyfun_hash), amap)
d745 1
a745 2
	     update(((tyfun, tyfun_hash),
		     (ce,count - 1)), amap)
d805 4
a808 2
	   (map (fn (tyfun, ran) => ((tyfun, NameHash.tyfun_hash tyfun), ran))
	    (TypeAss.to_list ty_ass')))
d851 1
a851 1
	val tyfuns = TyfunSet.list_to_set(map (fn ((x, _), _) => x) olds)
d854 1
a854 1
	(fn ((tyfun, _), _) => TyfunSet.is_member(tyfun, tyfuns))
d858 18
d878 10
a887 20
       
       let
	 val tyfun_list = amap'
	 val (ins, outs) = split(ty_ass, amap')
	 fun union ([],ty_ass) = ty_ass
	   | union (((tyfun, tyfun_hash), (ce',count'))::tyfuns, amap) = 
	     let
	       val (ce, count : int) = lookup((tyfun, tyfun_hash), amap)
	     in
	       if Conenv.dom_valenv_eq (ce,ce') then
		 union(tyfuns, update(((tyfun, tyfun_hash), 
				       (ce',count' + count)),
				      amap))
	       else
		 raise Consistency"inconsistent constructor environments"
	     end
       in
	 outs @@ union(ins,amap')
       end) handle Assoc =>
	 Crash.impossible"unionTypeAssembly"
a906 1

@


1.20
log
@Stuff to understand type functions properly
@
text
@d4 3
d126 1
a126 2
    datatype TypeOffspring =
      TYPE_OFFSPRING of (Ident.TyCon,Tyfun * int) NewMap.T
d128 1
a128 2
    datatype StrOffspring = 
      STR_OFFSPRING of (Ident.StrId,Strname * int) NewMap.T
d209 2
a210 4
    val empty_str_offspring =
      STR_OFFSPRING(* Mapping.empty_map*) (NewMap.empty' Ident.strid_order)
    val empty_type_offspring =
      TYPE_OFFSPRING(* Mapping.empty_map*)(NewMap.empty' Ident.tycon_order)
a283 4
    val empty_str_offspring =
      STR_OFFSPRING(* Mapping.empty_map*) (NewMap.empty' Ident.strid_order)
    val empty_type_offspring =
      TYPE_OFFSPRING(* Mapping.empty_map*)(NewMap.empty' Ident.tycon_order)
d292 1
a292 1
    fun stringTypeOffspring (TYPE_OFFSPRING amap) =
d311 1
a311 1
    fun stringStrOffspring (STR_OFFSPRING amap) = 
d359 1
a359 2
    fun empty_str_offspringp (STR_OFFSPRING amap) =
      NewMap.is_empty amap
d361 1
a361 2
    fun empty_type_offspringp (TYPE_OFFSPRING amap) =
      NewMap.is_empty amap
d363 1
a363 1
    fun lookupStrId (strid,STR_OFFSPRING amap) = 
d366 1
a366 2
    fun lookupTyCon (tycon,TYPE_OFFSPRING amap) = 
      NewMap.apply'(amap, tycon)
d368 1
a368 1
    fun lookupTyfun (tyfun,(*TYPE_ASSEMBLY*) amap) = 
d374 1
a374 2
    fun getStrIds (STR_OFFSPRING amap) =
      NewMap.domain_ordered amap
d376 1
a376 1
    fun InStrOffspringDomain(strid, STR_OFFSPRING amap) =
d381 1
a381 2
    fun getTyCons (TYPE_OFFSPRING amap) =
      NewMap.domain_ordered amap
d383 1
a383 1
    fun InTypeOffspringDomain(tycon, TYPE_OFFSPRING amap) =
d388 1
a388 1
    fun getTypeOffspringMap(TYPE_OFFSPRING amap) = amap
d402 1
a402 1
    fun str_offsunion (STR_OFFSPRING amap,STR_OFFSPRING amap') =
d405 4
a408 6
	  let
	    val (strname, count) = NewMap.apply'(amap, strid)
	  in
	    NewMap.define(amap, strid, (strname', count + count':int))
	  end handle NewMap.Undefined =>
	    NewMap.define(amap, strid, ran)
d410 1
a410 1
	STR_OFFSPRING(NewMap.fold strmap_union (amap, amap'))
d413 1
a413 1
    fun ty_offsunion (TYPE_OFFSPRING amap,TYPE_OFFSPRING amap') =
d416 4
a419 6
	  let
	    val (tyfun, funcount) = NewMap.apply'(amap, tycon)
	  in
	    NewMap.define(amap, tycon, (tyfun', funcount + funcount':int))
	  end handle NewMap.Undefined =>
	    NewMap.define(amap, tycon, ran)
d421 1
a421 1
	TYPE_OFFSPRING(NewMap.fold tymap_union (amap, amap'))
d424 5
a428 7
    fun add_to_StrOffspring (strid,strname,num,STR_OFFSPRING amap) =
      let 
	val (strname',count) = NewMap.apply'(amap, strid) 
	  handle NewMap.Undefined => (strname,0)
      in
	STR_OFFSPRING(NewMap.define(amap, strid, (strname', count + num:int)))
      end
d430 6
a435 7
    fun add_to_TypeOffspring (tycon,tyfun,num,TYPE_OFFSPRING amap) = 
      let
	val (tyfun',count) = NewMap.apply'(amap, tycon)
	  handle NewMap.Undefined => (tyfun,0)
      in
	TYPE_OFFSPRING(NewMap.define(amap, tycon, (tyfun', count+num:int)))
      end
a516 1
	     handle TypeAss.Lookup _ => (ce,0)
d518 3
a520 4
	   if Conenv.dom_valenv_eq (ce,ce')
	     then
	       (TypeAss.update(ty_ass, tyfun, (ce,count+num:int));
		ty_ass)
d523 3
a525 1
	 end
a536 2
	   val (ce',count) = lookup((tyfun, tyfun_hash),amap)
	     handle Assoc => (ce,0)
d538 4
a541 2
	   if Conenv.dom_valenv_eq (ce,ce')
	     then 
d543 3
a545 2
	   else
	     raise Consistency "type structures are inconsistent"
a578 1
	   handle Assoc => 0
d581 2
a582 1
       end)
d607 1
a607 1
	val (str_offs' as STR_OFFSPRING str_offsmap, str_assmap', ty_ass') =
d609 1
a609 1
	val (ty_ass'', ty_offs' as TYPE_OFFSPRING ty_offsmap) =
d617 1
a617 1
	  ((StrAss.update(str_assmap', m, (str_offs',ty_offs'));
d623 1
a623 1
	fun do_all ((ty_ass, ty_offs as TYPE_OFFSPRING ty_offsmap),
d633 1
a633 1
		0 => ty_offs
d635 1
a635 1
		  TYPE_OFFSPRING(NewMap.undefine(ty_offsmap, tycon))
d637 1
a637 2
		  TYPE_OFFSPRING(NewMap.define(ty_offsmap, tycon,
					       (tyfun,count-1)))
d655 6
a660 5
	fun do_all ((str_offs as STR_OFFSPRING str_offsmap,
		     str_ass, ty_ass), strid, str) =
	    let 
	      val (strname,count) = NewMap.apply'(str_offsmap, strid)
		handle NewMap.Undefined =>
d662 1
a662 14
	      val (str_ass', ty_ass') =
		case count of
		  0 =>
		    (* When the count is zero, we don't want the result *)
		    let
		      val new_str_ass = StrAss.copy str_ass
		      val new_ty_ass = TypeAss.copy ty_ass
		      val _ =
			internal_subAssemblies(new_str_ass, new_ty_ass, str)
		    in
		      (str_ass, ty_ass)
		    end
		| _ => internal_subAssemblies(str_ass, ty_ass, str)
	    in
d664 20
a683 9
		0 => (str_offs, str_ass', ty_ass')
	      | 1 =>
		  (STR_OFFSPRING(NewMap.undefine(str_offsmap, strid)),
		   str_ass', ty_ass')
	      | _ =>
		  (STR_OFFSPRING(NewMap.define(str_offsmap, strid,
					       (strname,count-1))),
		   str_ass',ty_ass')
	    end
d728 7
a734 7
    let 
      val ty_assembly' = seTypeAssembly (se,ty_assembly)
      fun teTypeAssembly (ty_assembly, tycon, TYSTR (tyfun,ce)) =
	add_to_TypeAssembly (tyfun,ce,1,ty_assembly)
    in
      NewMap.fold teTypeAssembly (ty_assembly', amap)
    end
d790 10
a799 10
     fun partition P list =
       let
	 fun part (ys,ns,[]) = (ys, ns)
	   | part (ys,ns,x::xs) =
	     if P x 
	       then part(x::ys,ns,xs)
	     else part(ys,x::ns,xs)
       in 
	 part ([],[],list)
       end
@


1.19
log
@fixed bug in unionTypeAssembly.
@
text
@d4 3
d642 3
a644 3
	    val (tyfun,count) = NewMap.apply'(ty_offsmap, tycon)
	      handle NewMap.Undefined =>
		(NULL_TYFUN (Tyfun_id.make_tyfun_id ()),0)
@


1.18
log
@Various improvements to remove garbage, handlers etc.
@
text
@d4 3
d869 1
a869 1
	 outs @@ union(ins,ty_ass)
@


1.17
log
@Removed irrelevant handlers and new exceptions
@
text
@d4 3
d145 12
d189 2
a190 2
    fun lookup_str(strname, []) = raise Assoc
    | lookup_str(strname, a_list) =
d202 21
d374 1
a374 1
	 lookup((tyfun, NameHash.tyfun_hash tyfun), amap))
d379 5
d387 7
a395 1
      handle Assoc => empty_str_offspring
a398 1
      handle Assoc => empty_type_offspring
d501 1
a501 1
		 lookup_str(strname', amap)
@


1.16
log
@Removed redundant arguments to newAssemblies function.
@
text
@d4 3
d206 4
a209 4
    exception LookupStrname
    exception LookupStrId
    exception LookupTyCon
    exception LookupTyfun
d329 1
a329 1
      NewMap.apply'(amap, strid) handle NewMap.Undefined => raise LookupStrId
d332 1
a332 1
      NewMap.apply'(amap, tycon) handle NewMap.Undefined => raise LookupTyCon
d338 1
a338 3
	 lookup((tyfun, NameHash.tyfun_hash tyfun), amap)
	 handle Assoc => raise LookupTyfun
	   )
d410 1
a410 2
	 lookup_str(strname',amap) 
	 handle Assoc => raise LookupStrname)
a684 1
	     handle Assoc => raise LookupTyfun
d809 10
a818 12
	     (let
		val (ce, count : int) = lookup((tyfun, tyfun_hash), amap)
	      in
		if Conenv.dom_valenv_eq (ce,ce') then
		  union(tyfuns, update(((tyfun, tyfun_hash), 
					(ce',count' + count)),
				       amap))
		else
		  raise Consistency"inconsistent constructor environments"
	      end)
		handle Assoc =>
		  Crash.impossible"unionTypeAssembly"
d821 2
a822 1
       end)
@


1.15
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d742 1
a742 1
      fun newAssemblies(strname, env, str_ass, ty_ass) =
a746 8
	  val _ =
	    Lists.iterate
	    (fn (str, ran) => StrAss.update(str_ass', str, ran))
	    str_ass
	  val _ =
	    Lists.iterate
	    (fn ((tyfun, _), ran) => TypeAss.update(ty_ass', tyfun, ran))
	    ty_ass
@


1.14
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
a39 2
require "../utils/newmap";
require "../utils/map";
d48 1
a49 1
require "../typechecker/datatypes";
d60 1
a62 1
  structure NewMap    : NEWMAP
a65 1
  structure Mapping   : MAP
a67 1
  structure Datatypes : DATATYPES
d79 1
a79 2
  sharing Datatypes.Mapping = Mapping
  sharing Datatypes = Strnames.Datatypes = 
d83 3
a85 2
 sharing type StrnameSet.element = Datatypes.Strname
 sharing type TyfunSet.element = Datatypes.Tyfun
d103 1
a103 1
    structure Datatypes = Datatypes
@


1.13
log
@Took out some long bits of commented out code, and replaced
most to_list calls with folds.
@
text
@a3 3
Revision 1.12  1992/08/04  15:44:02  davidt
Removed redundant Array arguements.

d207 1
d224 1
d250 13
a262 8
      if NewMap.is_empty amap then "" else
	implode
	("\nTYPE_OFFSPRING \n" ::
	 NewMap.fold
	 (fn (L, tycon, tyfun_i) =>
	  IdentPrint.printTyCon tycon :: " --> " ::
	  printTyfun_int tyfun_i :: L)
	 (["\n"],amap))
d269 13
a281 8
      if NewMap.is_empty amap then "" else
	implode
	("\nSTR_OFFSPRING \n" ::
	 NewMap.fold
	 (fn (L, strid, str_i) =>
	  IdentPrint.printStrId strid :: " --> " ::
	  printStrname_int str_i :: L)
	 (["\n"],amap))
d511 2
a512 9
	val stridlist = Mapping.assoc amap
	fun collect ([],str_offspring) = str_offspring : StrOffspring
	  | collect ((strid, STR(m, _))::strids,str_offspring) =
	    let 
	      val str_offspring' = 
		add_to_StrOffspring (strid,m,1,str_offspring)
	    in
	      collect (strids,str_offspring')
	    end
d514 1
a514 1
	collect (stridlist,str_offspring)
d519 2
a520 9
	val tyconlist = Mapping.assoc amap
	fun collect ([],type_offspring) = type_offspring : TypeOffspring
	  | collect ((tycon, TYSTR(tyfun, _))::tycons,type_offspring) =
	    let 
	      val type_offspring' =
		add_to_TypeOffspring (tycon,tyfun,1,type_offspring)
	    in
	      collect (tycons,type_offspring')
	    end
d522 1
a522 1
	collect (tyconlist,type_offspring)
d557 1
d570 1
a570 1
	val (ty_offs' as TYPE_OFFSPRING ty_offsmap,ty_ass'') =
d578 2
a579 11
	  let
(*
	    val _ =
	      (StrAss.lookup(str_assmap', m);
	       Print.print"Adding existing element to STR_ASSEMBLY\n")
	      handle StrAss.Lookup _ => ()
*)
	  in
	    ((StrAss.update(str_assmap', m, (str_offs',ty_offs'));
	      str_assmap'), ty_ass'')
	  end
d584 22
a605 21
	val tyconlist = Mapping.assoc amap
	fun do_all ([], ty_ass, ty_offs) = (ty_offs, ty_ass)
	  | do_all ((tycon, TYSTR (tyfun',ce'))::tycons,
		    ty_ass, ty_offs as TYPE_OFFSPRING ty_offsmap) =
	    let
	      val (tyfun,count) = NewMap.apply'(ty_offsmap, tycon)
		handle NewMap.Undefined =>
		  (NULL_TYFUN (Tyfun_id.make_tyfun_id ()),0)
	      val (ce, count') = TypeAss.lookup(ty_ass, tyfun)
		handle TypeAss.Lookup _ => (ce',0)
	      val new_tyoffs =
		case count of
		  0 => ty_offs
		| 1 =>
		    TYPE_OFFSPRING(NewMap.undefine(ty_offsmap, tycon))
		| _ =>
		    TYPE_OFFSPRING(NewMap.define(ty_offsmap, tycon,
						 (tyfun,count-1)))
	      val _ =
		if Conenv.empty_valenvp ce' then
		  ()
d607 4
a610 7
		  if count' = 1 then
		    TypeAss.delete(ty_ass, tyfun)
		  else
		    TypeAss.update(ty_ass, tyfun, (ce,count'-1))
	    in
	      do_all(tycons, ty_ass, new_tyoffs)
	    end
d612 1
a612 1
	do_all(tyconlist, ty_ass, type_offspring)
d617 2
a618 5
	val stridlist = Mapping.assoc amap
	fun do_all ([],str_offs,str_ass,ty_ass) = (str_offs, str_ass, ty_ass)
	  | do_all ((strid, str)::strids,
		    str_offs as STR_OFFSPRING str_offsmap,
		    str_ass, ty_ass) =
d638 1
a638 1
		0 => do_all(strids, str_offs, str_ass', ty_ass')
d640 2
a641 4
		  do_all(strids, STR_OFFSPRING(NewMap.undefine(str_offsmap,
							       strid)),
			 str_ass',
			 ty_ass')
d643 3
a645 4
		  do_all(strids,
			 STR_OFFSPRING(NewMap.define(str_offsmap, strid,
						     (strname,count-1))),
			 str_ass',ty_ass')
d648 1
a648 1
	do_all(stridlist, str_offspring, str_ass, ty_ass)
a669 1
(**)
d694 2
a695 8
      val tyconlist = Mapping.assoc amap 
      fun teTypeAssembly ([],ty_assembly) = ty_assembly
	| teTypeAssembly ((tycon, TYSTR (tyfun,ce))::tycons,ty_assembly) = 
	  let 
	    val ty_assembly' = add_to_TypeAssembly (tyfun,ce,1,ty_assembly)
	  in
	    teTypeAssembly (tycons,ty_assembly')
	  end
d697 1
a697 1
      teTypeAssembly (tyconlist,ty_assembly')
d702 2
a703 8
	val stridlist = Mapping.assoc amap
	fun gather ([],ty_assembly) = ty_assembly
	  | gather ((strid, STR (_,env))::strids,ty_assembly) = 
	    let 
	      val ty_assembly' = newTypeAssembly (env,ty_assembly)
	    in
	      gather (strids,ty_assembly')
	    end
d705 1
a705 1
	gather (stridlist,ty_assembly)
d708 1
d712 3
a714 8
	  val tyconlist = Mapping.assoc amap
	  fun collect ([],type_offspring,ty_ass) = 
	    (type_offspring : TypeOffspring,ty_ass)
	    | collect ((tycon, TYSTR (tyfun,ce))::tycons,
		       type_offspring,ty_ass) =
	      collect(tycons,
		      add_to_TypeOffspring(tycon,tyfun,1,type_offspring),
		      add_to_TypeAss(tyfun,ce,1,ty_ass))
d716 1
a716 1
	  collect (tyconlist,ty_offs,ty_ass)
d733 2
a734 9
	  val stridlist = Mapping.assoc amap
	  fun collect ([],str_ass,ty_ass) = (str_ass,ty_ass)
	    | collect ((strid, STR (m,env))::strids,str_ass,ty_ass) = 
	      let
		val (str_ass',ty_ass') =
		  internal_newAssemblies(m,env,str_ass,ty_ass)
	      in
		collect (strids,str_ass',ty_ass')
	      end
d736 1
a736 1
	  collect (stridlist,str_ass,ty_ass)
d761 1
a784 5
(*
	   val sorter = Lists.qsort strname_order
	   val str_ass = sorter str_ass
	   val amap = sorter amap'
*)
a826 4
(*
		  union(tyfuns, add_new(((tyfun, tyfun_hash),
					 (ce',count')),amap))
*)
a827 3
(*
	 union(tyfun_list,ty_ass)
*)
d839 5
a843 7
	val tyconlist = Mapping.assoc amap
	fun do_all ([],ty_ass) = ty_ass
	  | do_all ((tycon, TYSTR (tyfun,ce))::tycons,ty_ass) = 
	    if Conenv.empty_valenvp ce then
	      do_all (tycons,ty_ass)
	    else
	      do_all (tycons,add_to_TypeAssembly (tyfun,ce,1,ty_ass))
d845 1
a845 1
	do_all (tyconlist,ty_ass)
@


1.12
log
@Removed redundant Array arguements.
@
text
@d4 3
d251 8
a258 13
      let
	val map_list = NewMap.to_list amap
      in
	case map_list of
	  [] => ""
	| _ =>
	    implode
	    ("\nTYPE_OFFSPRING \n" ::
	     ((map
	       (fn (tycon, tyfun_i) =>
		implode[IdentPrint.printTyCon tycon, " --> ",
			printTyfun_int tyfun_i]) map_list) @@ ["\n"]))
      end
d265 8
a272 13
      let
	val map_list = NewMap.to_list amap
      in
	case map_list of
	  [] => ""
	| _ =>
	    implode
	    ("\nSTR_OFFSPRING \n" ::
	     ((map
	       (fn (strid, str_i) =>
		implode[IdentPrint.printStrId strid, " --> ",
			printStrname_int str_i]) map_list) @@ ["\n"]))
      end
d349 7
a355 27
(*
	val stridlist = Mapping.assoc amap'
	fun strmap_union ([]) = amap
	  | strmap_union ((strid, ran as (strname',count'))::strids) =
	    if Mapping.domain_member (strid,amap) then
	      let 
		val (strname,count) = Mapping.lookup (strid,amap)
	      in
		Mapping.add ((strid,(strname',count + count':int)),
			     strmap_union (strids),
			     Ident.strid_order)
	      end
	    else
	      Mapping.add ((strid, ran),
			   strmap_union (strids),
			   Ident.strid_order)
*)
	val stridlist = NewMap.to_list amap'
	fun strmap_union(amap, []) = amap
	  | strmap_union(amap, (strid, ran as (strname', count')) :: strids) =
	    strmap_union
	    (((let
		 val (strname, count) = NewMap.apply'(amap, strid)
	       in
		 NewMap.define(amap, strid, (strname', count + count':int))
	       end) handle NewMap.Undefined =>
		 NewMap.define(amap, strid, ran)), strids)
d357 1
a357 1
	STR_OFFSPRING(strmap_union(amap, stridlist))
d362 7
a368 10
	val tyconlist = NewMap.to_list amap'
	fun tymap_union(amap, []) = amap
	  | tymap_union(amap, (tycon, ran as (tyfun', funcount')) :: tycons) =
	    tymap_union
	    (((let
		 val (tyfun, funcount) = NewMap.apply'(amap, tycon)
	       in
		 NewMap.define(amap, tycon, (tyfun', funcount + funcount':int))
	       end) handle NewMap.Undefined =>
		 NewMap.define(amap, tycon, ran)), tycons)
d370 1
a370 1
	TYPE_OFFSPRING(tymap_union(amap, tyconlist))
a451 18
(*
	   if Mapping.domain_member (strname',amap) then
	     let val (str_offspring',type_offspring') =
	       Mapping.lookup (strname',amap)
	     in
	       STR_ASSEMBLY (Mapping.add ((strname',
					   (str_offsunion (str_offspring',
							   str_offspring),
					    ty_offsunion(type_offspring',
							 type_offspring))),
					  Mapping.remove (strname',amap),
					  Strnames.strname_ord))
	     end
	   else
	     STR_ASSEMBLY (Mapping.add ((strname',(str_offspring,
						   type_offspring)),
					amap,Strnames.strname_ord))
*)
a561 101
(*
    fun subAssemblies (str_ass as str_assmap,
		       ty_ass, STR (m,ENV (se,te,_,_))) = 
      (if do_debug 
         then debug ["Assemblies.subAssemblies ",
	             (Strnames.string_strname m)]
      else ();

      let  
	val (str_offs,ty_offs) = lookup_str(m,str_assmap) 
	  handle Assoc => (empty_str_offspring,empty_type_offspring)
	val (str_offs' as STR_OFFSPRING str_offsmap, str_assmap',
	     ty_ass') = subSE (str_ass,ty_ass,str_offs,se)
	val (ty_offs' as TYPE_OFFSPRING ty_offsmap,ty_ass'') =
	  subTE (ty_ass',ty_offs,te)
      in
	if
	  NewMap.is_empty str_offsmap andalso NewMap.is_empty ty_offsmap then
	  (remove_str(m,str_assmap'),ty_ass'')
	else
	  let
(*
	    val _ =
	      (lookup_str(m, str_assmap');
	       Print.print"Adding existing element to STR_ASSEMBLY\n")
	      handle Assoc => ()
*)
	  in
	    (update_str((m,(str_offs',ty_offs')),str_assmap'),ty_ass'')
	  end
      end)

    and subTE (ty_ass,type_offspring,TE amap) = 
      let
	val tyconlist = Mapping.assoc amap
	fun do_all ([],ty_ass, ty_offs) = (ty_offs,ty_ass)
	  | do_all ((tycon, TYSTR (tyfun',ce'))::tycons,
		    ty_ass as (*TYPE_ASSEMBLY*) ty_assmap,
		    ty_offs as TYPE_OFFSPRING ty_offsmap) =
	    let
	      val (tyfun,count) = NewMap.apply'(ty_offsmap, tycon)
		handle NewMap.Undefined =>
		  (NULL_TYFUN (Tyfun_id.make_tyfun_id ()),0)
	      val tyfun_hash = NameHash.tyfun_hash tyfun
	      val (ce,count') = lookup ((tyfun, tyfun_hash), ty_assmap)
		handle Assoc => (ce',0)
	      val new_tyoffs = 
		case count of
		  0 => ty_offs
		| 1 =>
		    TYPE_OFFSPRING(NewMap.undefine(ty_offsmap, tycon))
		| _ =>
		    TYPE_OFFSPRING(NewMap.define(ty_offsmap, tycon,
						 (tyfun,count-1)))
	      val new_tyass =
		if Conenv.empty_valenvp ce' then
		  ty_ass
		else
		  if count' = 1 then
		    remove((tyfun, tyfun_hash) ,ty_assmap)
		  else
		    update(((tyfun, tyfun_hash), (ce,count'-1)), ty_assmap)
	    in
	      do_all (tycons, new_tyass, new_tyoffs)	
	    end
      in
	do_all (tyconlist,ty_ass,type_offspring)
      end

    and subSE (str_ass,ty_ass,str_offspring,SE amap) = 
      let
	val stridlist = Mapping.assoc amap
	fun do_all ([],str_offs,str_ass,ty_ass) = (str_offs,str_ass,ty_ass)
	  | do_all ((strid, str)::strids,
		    str_offs as STR_OFFSPRING str_offsmap,
		    str_ass,ty_ass) =
	    let 
	      val (strname,count) = NewMap.apply'(str_offsmap, strid)
		handle NewMap.Undefined =>
		  (NULLNAME (Strname_id.make_strname_id ()),0)
	      val (str_ass',ty_ass') = subAssemblies (str_ass,ty_ass,str)
	    in
	      case count of
		0 => do_all (strids,str_offs,str_ass,ty_ass)
	      | 1 =>
		  do_all(strids, STR_OFFSPRING(NewMap.undefine(str_offsmap,
							       strid)),
			 str_ass',
			 ty_ass')
	      | _ =>
		  do_all(strids,
			 STR_OFFSPRING(NewMap.define(str_offsmap, strid,
						     (strname,count-1))),
			 str_ass',ty_ass')
	    end
      in
	do_all(stridlist,str_offspring,str_ass,ty_ass)
      end
*)

(**)
a741 45
(*
    local
      fun collectTypeInfo (TE amap,ty_offs,ty_ass) = 
	let
	  val tyconlist = Mapping.assoc amap
	  fun collect ([],type_offspring,ty_ass) = 
	    (type_offspring : TypeOffspring,ty_ass)
	    | collect ((tycon, TYSTR (tyfun,ce))::tycons,
		       type_offspring,ty_ass) =
	      collect(tycons,
		      add_to_TypeOffspring(tycon,tyfun,1,type_offspring),
		      add_to_TypeAssembly(tyfun,ce,1,ty_ass))
	in
	  collect (tyconlist,ty_offs,ty_ass)
	end
    in
      fun newAssemblies(strname,ENV (se,te,_,_),str_ass, ty_ass) = 
	let
	  val str_offspring = collectStrOffspring (se,empty_str_offspring)
	  val (type_offspring,ty_ass') =
	    collectTypeInfo (te,empty_type_offspring,ty_ass)
	  val str_ass' = add_to_StrAssembly (strname,
					     str_offspring,type_offspring,
					     str_ass)
	  val (str_ass'',ty_ass'') = collectStrInfo (se,str_ass',ty_ass')
	in
	  (str_ass'',ty_ass'')
	end

      and collectStrInfo (SE amap, str_ass, ty_ass) = 
	let 
	  val stridlist = Mapping.assoc amap
	  fun collect ([],str_ass,ty_ass) = (str_ass,ty_ass)
	    | collect ((strid, STR (m,env))::strids,str_ass,ty_ass) = 
	      let
		val (str_ass',ty_ass') = newAssemblies (m,env,str_ass,ty_ass)
	      in
		collect (strids,str_ass',ty_ass')
	      end
	in
	  collect (stridlist,str_ass,ty_ass)
	end
    end
*)

a805 21
(*
    fun split([], outs, ins, _) = (outs, ins)
      | split(the_rest, outs, ins, []) = (the_rest @@ outs, ins)
      | split(in_rest as ((x_elem as (x, _)) :: xs), outs, ins,
	      lrest as ((y_elem as (y, _)) :: ys)) =
	let
	  val x_h = strname_hash x
	  val y_h = strname_hash y
	in
	  if x_h < y_h then
	    split(xs, x_elem :: outs, ins, lrest)
	  else
	    if x_h > y_h then
	      split(in_rest, outs, ins, ys)
	    else
	      split(xs, outs, x_elem :: ins, lrest)
	      (* Note this may put things on the in list which it shouldn't *)
	      (* This doesn't matter, the splitting is only an optimisation *)
	end
*)

a844 11
(*
       let
	 val strname_list = amap'
	 fun union([],str_ass) = str_ass
	   | union((strname, (str_offs,ty_offs))::strnames,str_ass) = 
	     union(strnames, add_to_StrAssembly(strname,str_offs,ty_offs,
						str_ass))
       in
	 union(strname_list,str_ass)
       end
*)
@


1.11
log
@Removed message about adding existing assembly
@
text
@d4 3
a206 1
      structure Array = Array
a222 1
      structure Array = Array
@


1.10
log
@Various speed improvements, including imperative internal versions
of subAssemblies, newAssemblies, unionStrAssemblies and unionTypeAssemblies
@
text
@d4 4
d731 1
a731 1
(**)
d736 1
a736 1
(**)
@


1.9
log
@Changed implementation of StrOffspring and TypeOffspring to be
balanced trees.
@
text
@d36 4
d52 2
d78 2
d83 1
a83 1
    
a100 1
(*
a101 4
      TYPE_OFFSPRING of (Ident.TyCon,Tyfun * int) Mapping.Map
*)

    datatype TypeOffspring =
a104 3
(*
      STR_OFFSPRING of (Ident.StrId,Strname * int) Mapping.Map
*)
d107 2
a108 6
    datatype StrAssembly = 
      STR_ASSEMBLY of (Strname,StrOffspring * TypeOffspring) Mapping.Map
(*
      STR_ASSEMBLY of (Strname,StrOffspring * TypeOffspring) NewMap.T
*)

a110 3
(*
      TYPE_ASSEMBLY of (Tyfun,Valenv * int) Mapping.Map
*)
d155 38
d199 11
d216 10
a225 13
    fun strname_order(arg as (str1, str2)) =
      if Strnames.strname_eq arg then NewMap.EQUAL
      else
	let
	  val h1 = strname_hash str1
	  val h2 = strname_hash str2
	in
	  if h1 = h2 then
	    Crash.impossible"Assemblies: strname_order"
	  else
	    if h1 < h2 then NewMap.LESS
	    else NewMap.GREATER
	end
d227 3
d234 1
a234 11
    val empty_strassembly =
      fn _ => STR_ASSEMBLY(Mapping.empty_eqfunmap Strnames.strname_eq)
(*
      STR_ASSEMBLY(NewMap.empty strname_order)
*)
    val empty_tyassembly =
(*
 TYPE_ASSEMBLY (Mapping.empty_eqfunmap 
					  Types.tyfun_eq)
*)
      []
d236 2
a255 9
(*
      if Mapping.emptymap_p amap
	  then ""
      else
	"\nTYPE_OFFSPRING \n" ^
	(Mapping.print_map (amap,
			    IdentPrint.printTyCon,printTyfun_int," --> "))
	^ "\n"
*)
a274 8
(*
      if Mapping.emptymap_p amap
	then ""
      else
	"\nSTR_OFFSPRING \n" ^
	Mapping.print_map (amap,
			   IdentPrint.printStrId,printStrname_int," --> ")
*)
d280 7
a286 20
    fun stringStrAssembly (STR_ASSEMBLY amap) =
(*
      let
	val map_list = NewMap.to_list amap
      in
	case map_list of
	  [] => "\n"
	| _ =>
	    implode
	    (((map
	       (fn (strname, offs) =>
		implode[Strnames.string_strname strname, " |--> ",
			stringOffspring offs]) map_list) @@ ["\n"]))
      end
*)
      if Mapping.emptymap_p amap
	then "\n"
      else
	Mapping.print_map (amap,Strnames.string_strname,
			   stringOffspring," |--> ") ^ "\n"
a300 11
(*
    fun stringTypeAssembly (TYPE_ASSEMBLY amap) = 
      if Mapping.emptymap_p amap
	then ""
      else
	let
	  val _ = tyfun_length := 0
	in
	  Mapping.print_map (amap,print_tyfun,printCE_int," |--> ") ^ "\n"
	end
*)
a309 3
(*
      Mapping.emptymap_p amap
*)
a312 3
(*
      Mapping.emptymap_p amap
*)
a315 3
(*
      Mapping.lookup (strid,amap) handle Mapping.Lookup => raise LookupStrId
*)
a318 3
(*
      Mapping.lookup (tycon,amap) handle Mapping.Lookup => raise LookupTyCon
*)
a324 3
(*
       Mapping.lookup (tyfun,amap) handle Mapping.Lookup => raise LookupTyfun
*)
a329 3
(*
      Mapping.domain amap
*)
a332 3
(*
      Mapping.domain amap
*)
d335 3
a337 7
    fun findStrOffspring (strname, STR_ASSEMBLY amap) = 
      #1 (Mapping.lookup (strname,amap))
      handle Mapping.Lookup => empty_str_offspring
(*
      #1 (NewMap.apply'(amap, strname))
      handle NewMap.Undefined => empty_str_offspring
*)
d339 3
a341 7
    fun findTypeOffspring (strname,STR_ASSEMBLY amap) = 
      # 2 (Mapping.lookup (strname,amap))
      handle Mapping.Lookup => empty_type_offspring
(*
      #2 (NewMap.apply'(amap, strname))
      handle NewMap.Undefined => empty_type_offspring
*)
a378 3
(*
	STR_OFFSPRING (strmap_union (stridlist))
*)
a383 17
(*
	val tyconlist = Mapping.assoc amap'
	fun tymap_union ([]) = amap
	  | tymap_union ((tycon, ran as (tyfun',funcount'))::tycons) =
	    if Mapping.domain_member (tycon,amap) then
	      let
		val (tyfun,funcount) = Mapping.lookup (tycon,amap)
	      in
		Mapping.add ((tycon,(tyfun',funcount + funcount':int)),
			     tymap_union (tycons),
			     Ident.tycon_order)
	      end
	    else
	      Mapping.add ((tycon,ran),
			   tymap_union (tycons),
			   Ident.tycon_order)
*)
a394 3
(*
	TYPE_OFFSPRING (tymap_union (tyconlist))
*)
a399 4
(*
	val (strname',count) = Mapping.lookup (strid,amap) 
	  handle Mapping.Lookup => (strname,0)
*)
a402 4
(*
	STR_OFFSPRING (Mapping.add ((strid,(strname',count + num:int)),
				    amap,Ident.strid_order))
*)
a406 1
(*
a407 8
	val (tyfun',count) = Mapping.lookup (tycon,amap)
	  handle Mapping.Lookup => (tyfun,0)
      in
	TYPE_OFFSPRING (Mapping.add ((tycon,(tyfun',count+num:int)),
				     amap,Ident.tycon_order))
      end
*)
      let
d414 1
a414 1
    fun lookupStrname (strname,STR_ASSEMBLY amap) =
d422 2
a423 6
	 Mapping.lookup (strname',amap) 
	 handle Mapping.Lookup => raise LookupStrname)
(*
	 NewMap.apply'(amap, strname') 
	 handle NewMap.Undefined => raise LookupStrname)
*)
d426 30
a455 2
    fun add_to_StrAssembly (strname,str_offspring,type_offspring,
			    str_assembly as STR_ASSEMBLY amap) =
d466 12
a493 13
(*
	   STR_ASSEMBLY
	   ((let
	       val (str_offspring',type_offspring') =
		 NewMap.apply'(amap, strname')
	     in
	       NewMap.define(amap, strname',
			     (str_offsunion(str_offspring',
					   str_offspring),
			      ty_offsunion(type_offspring',
					   type_offspring)))
	     end) handle NewMap.Undefined =>
	       NewMap.define(amap, strname', (str_offspring, type_offspring)))
d505 19
a523 1
    fun add_to_TypeAssembly (tyfun,ce,num,ty_assembly as (*TYPE_ASSEMBLY*) amap) = 
a531 4
(*
	   val (ce',count) = Mapping.lookup (tyfun,amap)
	     handle Mapping.Lookup => (ce,0)
*)
a537 4
(*
	       TYPE_ASSEMBLY (Mapping.add ((tyfun,(ce,count+num:int)),
					   amap,Types.tyfun_eq))
*)
d573 1
a573 1
    fun remfromStrAssembly (strname, STR_ASSEMBLY amap) = 
d578 1
a578 4
       STR_ASSEMBLY (Mapping.remove (strname,amap)))
(*
       STR_ASSEMBLY(NewMap.undefine(amap, strname)))
*)
a585 4
(*
	 val count = (#2 (Mapping.lookup (tyfun,amap))
		      handle Mapping.Lookup => 0)
*)
a589 3
(*
	 (TYPE_ASSEMBLY (Mapping.remove (tyfun,amap)),count)
*)
d605 2
a606 1
    fun subAssemblies (str_ass as STR_ASSEMBLY str_assmap,
d614 3
a616 3
	val (str_offs,ty_offs) = Mapping.lookup (m,str_assmap) 
	  handle Mapping.Lookup => (empty_str_offspring,empty_type_offspring)
	val (str_offs' as STR_OFFSPRING str_offsmap,STR_ASSEMBLY str_assmap',
d623 1
a623 1
	  (STR_ASSEMBLY (Mapping.remove (m,str_assmap')),ty_ass'')
d626 1
d628 4
a631 4
	      if Mapping.domain_member(m, str_assmap') then
		Print.print"Adding existing element to STR_ASSEMBLY\n"
	      else
		()
d633 1
a633 2
	    (STR_ASSEMBLY (Mapping.add ((m,(str_offs',ty_offs')),str_assmap',
					Strnames.strname_ord)),ty_ass'')
a644 4
(*
	      val (tyfun,count) = Mapping.lookup (tycon,ty_offsmap)
		handle Mapping.Lookup =>
*)
a653 1
(*
a654 7
		    TYPE_OFFSPRING (Mapping.remove (tycon,ty_offsmap))
		| _ =>
		    TYPE_OFFSPRING (Mapping.add 
				    ((tycon,(tyfun,count-1)),
				     ty_offsmap,Ident.tycon_order))
*)
		| 1 =>
a681 5
(*
	      val (strname,count) = Mapping.lookup (strid,str_offsmap)
		handle Mapping.Lookup =>
		  (NULLNAME (Strname_id.make_strname_id ()),0)
*)
a689 6
(*
		  do_all (strids,STR_OFFSPRING (Mapping.remove
						(strid,
						 str_offsmap)),str_ass',
			  ty_ass')
*)
a694 8
(*
		  do_all (strids,
			  STR_OFFSPRING (Mapping.add ((strid,
						       (strname,count-1)),
						      str_offsmap,
						      Ident.strid_order)),
			  str_ass',ty_ass')
*)
d703 1
d705 132
d886 1
d895 3
a897 7
	      let 
		val (type_offspring',ty_ass') = 
		  collect (tycons,type_offspring,ty_ass)
	      in
		(add_to_TypeOffspring (tycon,tyfun,1,type_offspring'),
		 add_to_TypeAssembly (tyfun,ce,1,ty_ass'))
	      end
d929 1
d931 26
a956 2
    fun unionStrAssembly (str_ass, STR_ASSEMBLY amap') =
      (if do_debug then debug ["unionStrAssembly"] else ();
d958 59
d1018 21
a1038 1
	 val strname_list = Mapping.assoc amap'
d1040 3
a1042 1
	 val strname_list = NewMap.to_list amap'
d1044 18
a1061 4
	 fun union ([],str_ass) = str_ass
	   | union ((strname, (str_offs,ty_offs))::strnames,str_ass) = 
	     union (strnames,add_to_StrAssembly (strname,str_offs,ty_offs,
						   str_ass))
d1063 4
a1066 2
	 union (strname_list,str_ass)
       end)
d1068 10
a1077 1
    fun unionTypeAssembly (ty_ass, (*TYPE_ASSEMBLY*) amap') =
d1082 1
d1084 1
a1084 2
	   | union (((tyfun, tyfun_hash), (ce',count'))::tyfuns,
		    ty_ass as (* TYPE_ASSEMBLY*) amap) = 
d1096 2
d1100 1
d1102 4
a1105 1
	 union (tyfun_list,ty_ass)
@


1.8
log
@Added a missing handle Assoc => raise LookupTyfun
@
text
@d4 3
d29 2
d35 1
d48 1
d51 1
d93 2
a94 1
    datatype TypeOffspring = 
d96 4
d102 1
d104 2
d109 3
d168 29
a196 4
    val empty_str_offspring = STR_OFFSPRING Mapping.empty_map
    val empty_type_offspring = TYPE_OFFSPRING Mapping.empty_map
    val empty_strassembly = STR_ASSEMBLY (Mapping.empty_eqfunmap 
					  Strnames.strname_eq)
d208 15
a222 1
    fun stringTypeOffspring (TYPE_OFFSPRING amap) = 
d224 1
a224 1
	then ""
d230 1
d237 14
d257 1
d263 15
a277 1
    fun stringStrAssembly (STR_ASSEMBLY amap) = 
d316 5
a320 2
    fun empty_str_offspringp (STR_OFFSPRING amap) = Mapping.emptymap_p amap
    fun empty_type_offspringp (TYPE_OFFSPRING amap) = Mapping.emptymap_p amap
d322 6
d329 1
d331 2
d335 1
d337 2
d351 5
a355 1
    fun getStrIds (STR_OFFSPRING amap) = Mapping.domain amap
d357 5
a361 1
    fun getTyCons (TYPE_OFFSPRING amap) = Mapping.domain amap
d363 2
a364 2
    fun findStrOffspring (strname,STR_ASSEMBLY amap) = 
      # 1 (Mapping.lookup (strname,amap))
d366 4
d374 4
d387 1
d403 11
d415 1
d417 2
d422 2
a423 1
      let 
d439 11
d451 1
d453 2
d459 1
d462 3
d466 1
d469 2
d474 2
a475 1
      let 
d482 7
d491 2
a492 1
      let val strname' = Strnames.strip strname
d500 4
d512 2
a513 1
       let val strname' = Strnames.strip strname
d534 14
d616 1
a616 1
    fun remfromStrAssembly (strname,STR_ASSEMBLY amap) = 
d622 3
d626 1
a626 1
    fun remfromTypeAssembly (tyfun,(*TYPE_ASSEMBLY*) amap) = 
d659 1
a659 2
		       ty_ass (*as TYPE_ASSEMBLY ty_assmap*),
		       STR (m,ENV (se,te,_,_))) = 
d673 14
a686 6
	if Mapping.emptymap_p str_offsmap andalso Mapping.emptymap_p ty_offsmap
	  then
	    (STR_ASSEMBLY (Mapping.remove (m,str_assmap')),ty_ass'')
	else 
	  (STR_ASSEMBLY (Mapping.add ((m,(str_offs',ty_offs')),str_assmap',
				      Strnames.strname_ord)),ty_ass'')
d690 1
a690 1
      let 
d697 1
d700 3
d710 2
a711 1
		| 1 => 
d717 6
d746 1
d750 4
d759 1
d764 5
d770 1
d777 5
d784 1
a784 1
	do_all (stridlist,str_offspring,str_ass,ty_ass)
d787 1
a787 1
    fun subTypeAssembly (tyfun,ce,ty_ass as (*TYPE_ASSEMBLY*) amap) = 
d855 1
a855 2
      fun newAssemblies (strname,ENV (se,te,_,_),str_ass as STR_ASSEMBLY amap,
			 ty_ass (*as TYPE_ASSEMBLY amap'*)) = 
d883 1
a883 1
    fun unionStrAssembly (str_ass,STR_ASSEMBLY amap') =
d888 3
@


1.7
log
@Chnaged implementation of TypeAssemblies to avoid so much comparison of
tyfuns (expensive). Further improvements could be made by using namesets
@
text
@d4 4
d576 1
d581 1
a581 1
	     update(((tyfun, NameHash.tyfun_hash tyfun),
@


1.6
log
@Some minor corrections
@
text
@d4 3
d25 1
d34 1
a35 1
require "../utils/print";
d38 2
a39 1
  structure Lists   : LISTS
d50 1
a54 1
  structure Print     : PRINT
d59 1
a59 1
    Types.Datatypes
d90 3
a92 1
    datatype TypeAssembly = 
d94 1
d96 43
d149 3
a151 1
    val empty_tyassembly = TYPE_ASSEMBLY (Mapping.empty_eqfunmap 
d153 3
a155 1
      
d205 1
d215 8
d233 1
a233 1
    fun lookupTyfun (tyfun,TYPE_ASSEMBLY amap) = 
d237 6
a242 1
       Mapping.lookup (tyfun,amap) handle Mapping.Lookup => raise LookupTyfun)
d370 1
a370 1
    fun add_to_TypeAssembly (tyfun,ce,num,ty_assembly as TYPE_ASSEMBLY amap) = 
d379 1
d382 4
d389 1
d392 2
d435 1
a435 1
    fun remfromTypeAssembly (tyfun,TYPE_ASSEMBLY amap) = 
d440 2
a441 1
       let 
d444 4
d449 1
d451 2
d468 1
a468 1
		       ty_ass as TYPE_ASSEMBLY ty_assmap,
d496 1
a496 1
		    ty_ass as TYPE_ASSEMBLY ty_assmap,
d502 3
a504 2
	      val (ce,count') = Mapping.lookup (tyfun,ty_assmap)
		handle Mapping.Lookup => (ce',0)
d514 8
a521 12
	      val new_tyass = if Conenv.empty_valenvp ce'
				then
				  ty_ass
			      else
				if count' = 1
				  then
				    TYPE_ASSEMBLY (Mapping.remove
						   (tyfun,ty_assmap))
				else
				  TYPE_ASSEMBLY (Mapping.add 
						 ((tyfun,(ce,count'-1)),
						  ty_assmap,Types.tyfun_eq))
d523 1
a523 1
	      do_all (tycons,new_tyass,new_tyoffs)	
d561 1
a561 1
    fun subTypeAssembly (tyfun,ce,ty_ass as TYPE_ASSEMBLY amap) = 
d569 3
a571 2
	 let 
	   val (ce',count) = lookupTyfun (tyfun,ty_ass)
d574 1
a574 1
	     #1 (remfromTypeAssembly (tyfun,ty_ass))
d576 2
a577 2
	     TYPE_ASSEMBLY (Mapping.add ((tyfun,(ce,count - 1)),amap,
					 Types.tyfun_eq))
d629 1
a629 1
			 ty_ass as TYPE_ASSEMBLY amap') = 
d670 1
a670 1
    fun unionTypeAssembly (ty_ass, TYPE_ASSEMBLY amap') =
d674 1
a674 1
	 val tyfun_list = Mapping.assoc amap'
d676 15
a690 18
	   | union ((tyfun, (ce',count'))::tyfuns,
		    ty_ass as TYPE_ASSEMBLY amap) = 
	     if Mapping.domain_member (tyfun,amap) then 
	       let val (ce,count) = lookupTyfun (tyfun,ty_ass)
	       in
		 if Conenv.dom_valenv_eq (ce,ce') then
		   union(tyfuns,TYPE_ASSEMBLY (Mapping.add 
					       ((tyfun,
						 (ce',count' + count)),
						amap,
						Types.tyfun_eq)))
		 else
		   raise Consistency"inconsistent constructor environments"
	       end
	     else
	       union (tyfuns,TYPE_ASSEMBLY (Mapping.add
					    ((tyfun,(ce',count')),amap,
					     Types.tyfun_eq)))
@


1.5
log
@Further improvements from Anel
@
text
@d4 3
d20 1
d34 1
@


1.4
log
@Efficiency improvements
@
text
@a15 1

a16 1
require "../utils/lists";
a29 1
  structure Lists : LISTS
d165 2
a166 2
      (if do_debug then
	 debug ["Assemblies.lookupTyfun ", (Types.string_tyfun tyfun)]
d251 4
a254 4
	(if do_debug then
	   debug ["Assemblies.lookupStrname ",
		  (Strnames.string_strname strname')]
	 else ();
d261 3
a263 3
      (if do_debug then
	 debug ["add_to_StrAssembly - strname = ",
		(Strnames.string_strname strname)]
d270 1
a270 1
	   if Mapping.domain_member (strname',amap) then 
d297 3
a299 2
      (if do_debug then
	 debug ["add_to_TypeAssembly - tyfun = ",(Types.string_tyfun tyfun)]
d347 3
a349 3
      (if do_debug then
	 debug ["Assemblies.remfromStrAssembly ",
		(Strnames.string_strname strname)]
d354 3
a356 3
      (if do_debug then
	 debug ["Assemblies.remfromTypeAssembly ",
		(Types.string_tyfun tyfun)]
d380 4
a383 4
      (if do_debug then
	 debug ["Assemblies.subAssemblies ",
		(Strnames.string_strname m)]
       else ();
d475 2
a476 2
      (if do_debug then
	 debug ["Assemblies.subTypeAssembly ",(Types.string_tyfun tyfun)]
d570 1
a570 3
      (if do_debug then
	 debug ["unionStrAssembly"]
       else ();
d583 1
a583 3
      (if do_debug then
	 debug ["Assemblies.unionTypeAssembly"]
       else ();
d616 1
a616 1
    fun updateTypeAssembly (tyenv as TE amap,ty_ass) = 
@


1.3
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d16 1
d18 1
d32 1
a57 10
    local
      fun print_list [] = Print.print "\n"
	| print_list (h :: t) = (Print.print h ; print_list t)
    in
      fun debug L  =
	if do_debug andalso Debug.debug_level () > 10 then
	  (print_list L)
	else
	  ()
    end
d59 6
d99 4
d107 4
a110 10
	let
	  fun printTyfun_int (tyfun,n) = 
	    "(" ^ (Types.string_tyfun tyfun) ^ "," ^
	    (Integer.makestring n) ^ ")\n"
	in
	  "\nTYPE_OFFSPRING \n" ^
	  (Mapping.print_map (amap,
			      IdentPrint.printTyCon,printTyfun_int," --> "))
	  ^ "\n"
	end
d112 4
d120 3
a122 9
	let
	  fun printStrname_int (strname,n) = 
	    "(" ^ (Strnames.string_strname strname) ^ "," ^
	    (Integer.makestring n) ^ ")\n"
	in
	  "\nSTR_OFFSPRING \n" ^
	  Mapping.print_map (amap,
			     IdentPrint.printStrId,printStrname_int," --> ")
	end
d124 4
d132 2
a133 8
	let
	  fun stringOffspring (stroff,tyoff) = 
	    (stringStrOffspring stroff) ^ "\n" ^ 
	    (stringTypeOffspring tyoff) ^ "\n"
	in
	  Mapping.print_map (amap,Strnames.string_strname,
			     stringOffspring," |--> ") ^ "\n"
	end
d135 13
d153 1
a153 12
	  val tyfun_length = ref 0
	  fun print_tyfun (tyfun) =
	    let 
	      val string_tyfun = (Types.string_tyfun tyfun)
	      val tyfun_size = size string_tyfun
	    in
	      (tyfun_length := tyfun_size;
	       "\n" ^ string_tyfun)
	    end
	  fun str_ce (ce) = Conenv.string_valenv (!tyfun_length + 5,ce)
	  fun printCE_int (ce,n) = 
	    "(" ^ (str_ce ce) ^ "," ^ (Integer.makestring n) ^ ")"
d168 3
a170 1
      (debug ["Assemblies.lookupTyfun ", (Types.string_tyfun tyfun)];
d193 9
a201 18
	val stridlist = Mapping.domain amap'
	fun strmap_union ([],amap,_) = amap
	  | strmap_union (strid::strids,amap,amap') =
	    let
	      val (strname',count') = Mapping.lookup (strid,amap')
	    in
	      if Mapping.domain_member (strid,amap)
		then
		  let 
		    val (strname,count) = Mapping.lookup (strid,amap)
		  in
		    Mapping.add ((strid,(strname',count + count':int)),
				 strmap_union (strids,amap,amap'),
				 Ident.strid_order)
		  end
	      else
		Mapping.add ((strid,(strname',count')),
			     strmap_union (strids,amap,amap'),
d203 5
a207 1
	    end
d209 1
a209 1
	STR_OFFSPRING (strmap_union (stridlist,amap,amap'))
d214 9
a222 16
	val tyconlist = Mapping.domain amap'
	fun tymap_union ([],amap,_) = amap
	  | tymap_union (tycon::tycons,amap,amap') =
	    let val (tyfun',funcount') = Mapping.lookup (tycon,amap')
	    in
	      if Mapping.domain_member (tycon,amap)
		then
		  let val (tyfun,funcount) = Mapping.lookup (tycon,amap)
		  in
		    Mapping.add ((tycon,(tyfun',funcount + funcount':int)),
				 tymap_union (tycons,amap,amap'),
				 Ident.tycon_order)
		  end
	      else
		Mapping.add ((tycon,(tyfun',funcount')),
			     tymap_union (tycons,amap,amap'),
d224 5
a228 1
	    end
d230 1
a230 1
	TYPE_OFFSPRING (tymap_union (tyconlist,amap,amap'))
d254 4
a257 2
	(debug ["Assemblies.lookupStrname ",
		(Strnames.string_strname strname')];
d264 4
a267 2
      (debug ["add_to_StrAssembly - strname = ",
	      (Strnames.string_strname strname)];
d272 17
a288 19
		 empty_type_offspringp type_offspring)
	   then
	     if Mapping.domain_member (strname',amap)
	       then 
		 let val (str_offspring',type_offspring') =
		   Mapping.lookup (strname',amap)
		 in
		   STR_ASSEMBLY (Mapping.add ((strname',
					       (str_offsunion (str_offspring',
							       str_offspring),
						ty_offsunion(type_offspring',
							     type_offspring))),
					      Mapping.remove (strname',amap),
					      Strnames.strname_ord))
		 end
	     else
	       STR_ASSEMBLY (Mapping.add ((strname',(str_offspring,
						     type_offspring)),
					  amap,Strnames.strname_ord))
d300 5
a304 4
      (debug ["add_to_TypeAssembly - tyfun = ",(Types.string_tyfun tyfun)];
       if Conenv.empty_valenvp ce 
	 then
	   ty_assembly
d318 1
a318 1
    fun collectStrOffspring (se as SE amap,str_offspring) = 
d320 3
a322 3
	val stridlist = Mapping.domain amap
	fun collect ([],se,str_offspring) = str_offspring : StrOffspring
	  | collect (strid::strids,se,str_offspring) =
a323 1
	      val STR (m,_) = Env.lookup_strid_in_SE (strid,se)
d327 1
a327 1
	      collect (strids,se,str_offspring')
d330 1
a330 1
	collect (stridlist,se,str_offspring)
d333 1
a333 1
    fun collectTypeOffspring (te as TE amap,type_offspring) = 
d335 3
a337 3
	val tyconlist = Mapping.domain amap
	fun collect ([],te,type_offspring) = type_offspring : TypeOffspring
	  | collect (tycon::tycons,te,type_offspring) =
a338 1
	      val TYSTR (tyfun,_) = Tyenv.lookup (tycon,te)
d342 1
a342 1
	      collect (tycons,te,type_offspring')
d345 1
a345 1
	collect (tyconlist,te,type_offspring)
d349 4
a352 2
      (debug ["Assemblies.remfromStrAssembly ",
	      (Strnames.string_strname strname)];
d356 4
a359 2
      (debug ["Assemblies.remfromTypeAssembly ",
	      (Types.string_tyfun tyfun)];
d382 4
a385 2
      (debug ["Assemblies.subAssemblies ",
	      (Strnames.string_strname m)];
d405 4
a408 4
	val tyconlist = Mapping.domain amap
	fun do_all ([],ty_ass as TYPE_ASSEMBLY ty_assmap,
		    ty_offs as TYPE_OFFSPRING ty_offsmap) = (ty_offs,ty_ass)
	  | do_all (tycon::tycons, ty_ass as TYPE_ASSEMBLY ty_assmap,
a410 1
	      val TYSTR (tyfun',ce') = Mapping.lookup (tycon,amap)
d417 8
a424 7
		case count of 0 => ty_offs
		  | 1 => 
		      TYPE_OFFSPRING (Mapping.remove (tycon,ty_offsmap))
		  | _ =>
		      TYPE_OFFSPRING (Mapping.add 
				      ((tycon,(tyfun,count-1)),
				       ty_offsmap,Ident.tycon_order))
d446 1
a446 1
	val stridlist = Mapping.domain amap
d448 2
a449 1
	  | do_all (strid::strids, str_offs as STR_OFFSPRING str_offsmap,
a454 1
	      val str = Mapping.lookup (strid,amap)
d457 14
a470 13
	      case count of 0 => do_all (strids,str_offs,str_ass,ty_ass)
		| 1 =>
		    do_all (strids,STR_OFFSPRING (Mapping.remove
						  (strid,
						   str_offsmap)),str_ass',
			    ty_ass')
		| _ =>
		    do_all (strids,
			    STR_OFFSPRING (Mapping.add ((strid,
							 (strname,count-1)),
							str_offsmap,
							Ident.strid_order)),
			    str_ass',ty_ass')
d477 3
a479 1
      (debug ["Assemblies.subTypeAssembly ",(Types.string_tyfun tyfun)];
d497 3
a499 3
      val tyconlist = Mapping.domain amap 
      fun teTypeAssembly ([],_,ty_assembly) = ty_assembly
	| teTypeAssembly (tycon::tycons,te,ty_assembly) = 
a500 1
	    val TYSTR (tyfun,ce) = Tyenv.lookup (tycon,te)
d503 1
a503 1
	    teTypeAssembly (tycons,te,ty_assembly')
d506 1
a506 1
      teTypeAssembly (tyconlist,te,ty_assembly')
d509 1
a509 1
    and seTypeAssembly (se as SE amap,ty_assembly) = 
d511 3
a513 3
	val stridlist = Mapping.domain amap
	fun gather ([],_,ty_assembly) = ty_assembly
	  | gather (strid::strids,se,ty_assembly) = 
a514 1
	      val STR (m,env) = Env.lookup_strid_in_SE (strid,se)
d517 1
a517 1
	      gather (strids,se,ty_assembly')
d520 1
a520 1
	gather (stridlist,se,ty_assembly)
d524 1
a524 1
      fun collectTypeInfo (te as TE amap,ty_offs,ty_ass) = 
d526 2
a527 2
	  val tyconlist = Mapping.domain amap
	  fun collect ([],te,type_offspring,ty_ass) = 
d529 2
a530 1
	    | collect (tycon::tycons,te,type_offspring,ty_ass) =
a531 1
		val TYSTR (tyfun,ce) = Tyenv.lookup (tycon,te)
d533 1
a533 1
		  collect (tycons,te,type_offspring,ty_ass)
d539 1
a539 1
	  collect (tyconlist,te,ty_offs,ty_ass)
d556 1
a556 1
      and collectStrInfo (se as SE amap, str_ass, ty_ass) = 
d558 3
a560 3
	  val stridlist = Mapping.domain amap
	  fun collect ([],_,str_ass,ty_ass) = (str_ass,ty_ass)
	    | collect (strid::strids,se as SE amap,str_ass,ty_ass) = 
a561 1
		val STR (m,env) = Mapping.lookup (strid,amap)
d564 1
a564 1
		collect (strids,se,str_ass',ty_ass')
d567 1
a567 1
	  collect (stridlist,se,str_ass,ty_ass)
d571 4
a574 2
    fun unionStrAssembly (str_ass,str_ass' as STR_ASSEMBLY amap') =
      (debug ["unionStrAssembly"];
d577 5
a581 9
	 val strname_list = Mapping.domain amap'
	 fun union ([],str_ass,_) = str_ass
	   | union (strname::strnames,str_ass,str_ass') = 
	     let
	       val (str_offs,ty_offs) = lookupStrname (strname,str_ass')
	     in
	       union (strnames,add_to_StrAssembly (strname,str_offs,ty_offs,
						   str_ass),str_ass')
	     end
d583 1
a583 1
	 union (strname_list,str_ass,str_ass')
d586 4
a589 2
    fun unionTypeAssembly (ty_ass,ty_ass' as TYPE_ASSEMBLY amap') =
      (debug ["Assemblies.unionTypeAssembly"];
d592 20
a611 26
	 val tyfun_list = Mapping.domain amap'
	 fun union ([],ty_ass,_) = ty_ass
	   | union (tyfun::tyfuns,ty_ass as TYPE_ASSEMBLY amap,ty_ass') = 
	     let
	       val (ce',count') = lookupTyfun (tyfun,ty_ass')
	     in
	       if Mapping.domain_member (tyfun,amap)
		 then 
		   let val (ce,count) = lookupTyfun (tyfun,ty_ass)
		   in
		     if Conenv.dom_valenv_eq (ce,ce')
		       then
			 union(tyfuns,TYPE_ASSEMBLY (Mapping.add 
						     ((tyfun,
						       (ce',count' + count)),
						      amap,
						      Types.tyfun_eq)),ty_ass')
		     else
		       raise Consistency
			 "inconsistent constructor environments"
		   end
	       else
		 union (tyfuns,TYPE_ASSEMBLY (Mapping.add
					      ((tyfun,(ce',count')),amap,
					       Types.tyfun_eq)),ty_ass')
	     end
d613 1
a613 1
	 union (tyfun_list,ty_ass,ty_ass')
d624 7
a630 12
	val tyconlist = Mapping.domain amap
	fun do_all ([],_,ty_ass) = ty_ass
	  | do_all (tycon::tycons,tyenv,ty_ass) = 
	    let
	      val TYSTR (tyfun,ce) = Tyenv.lookup (tycon,tyenv)
	    in
	      if Conenv.empty_valenvp ce
		then
		  do_all (tycons,tyenv,ty_ass)
	      else
		do_all (tycons,tyenv,add_to_TypeAssembly (tyfun,ce,1,ty_ass))
	    end
d632 1
a632 1
	do_all (tyconlist,tyenv,ty_ass)
@


1.2
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_assemblies.sml,v $
d14 1
d25 22
a46 18
functor Assemblies (structure Mapping   : MAP
		    structure Integer   : INTEGER
		    structure Datatypes : DATATYPES
		    structure Conenv    : VALENV
		    structure Types     : TYPES
		    structure Strnames  : STRNAMES
		    structure Tystr     : TYSTR
		    structure Tyenv     : TYENV
		    structure Env       : ENVIRONMENT
		    structure Debug     : sig val set_debug_level : int -> unit
					      val debug_level : unit -> int
					  end
		    structure Print     : PRINT
		    sharing Datatypes.Mapping = Mapping
		    sharing Datatypes = Strnames.Datatypes = 
		      Tystr.Datatypes = Conenv.Datatypes =
		      Tyenv.Datatypes = Env.Datatypes = 
		      Types.Datatypes) : ASSEMBLIES = 
d50 1
d56 1
a56 1
	if Debug.debug_level () > 10 then
@


1.1
log
@Initial revision
@
text
@d1 1
d3 5
a7 1
$Log$
@
