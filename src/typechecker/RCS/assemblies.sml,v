head	1.19;
access;
symbols
	MLW_daveb_inline_1_4_99:1.19.11
	MLWorks_21c0_1999_03_25:1.19
	MLWorks_20c1_1998_08_20:1.19
	MLWorks_20c0_1998_08_04:1.19
	MLWorks_20b2c2_1998_06_19:1.19
	MLWorks_20b2_Windows_1998_06_12:1.19
	MLWorks_20b1c1_1998_05_07:1.19
	MLWorks_20b0_1998_04_07:1.19
	MLWorks_20b0_1998_03_20:1.19
	MLWorks_20m2_1998_02_16:1.19
	MLWorks_20m1_1997_10_23:1.19
	MLWorks_11r1:1.19.8.1.1.1.1
	MLWorks_workspace_97:1.19.10
	MLWorks_dt_wizard:1.19.9
	MLWorks_11c0_1997_09_09:1.19.8.1.1.1
	MLWorks_10r3:1.19.8.1.3
	MLWorks_10r2_551:1.19.8.1.2
	MLWorks_11:1.19.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.19.8.1
	MLWorks_20m0_1997_06_20:1.19
	MLWorks_1_0_r2c2_1997_06_14:1.19.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.19.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.19.8
	MLWorks_BugFix_1997_04_24:1.19
	MLWorks_1_0_r2_Win32_1997_04_11:1.19
	MLWorks_1_0_r2_Unix_1997_04_04:1.19
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.19.6.1.1
	MLWorks_gui_1996_12_18:1.19.7
	MLWorks_1_0_Win32_1996_12_17:1.19.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.19.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.19.4.1
	MLWorks_1_0_Irix_1996_11_28:1.19.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.19.5
	MLWorks_1_0_Unix_1996_11_14:1.19.4
	MLWorks_Open_Beta2_1996_10_11:1.19.3
	MLWorks_License_dev:1.19.2
	MLWorks_1_open_beta_1996_09_13:1.19.1
	MLWorks_Open_Beta_1996_08_22:1.19
	MLWorks_Beta_1996_07_02:1.19
	MLWorks_Beta_1996_06_07:1.19
	MLWorks_Beta_1996_06_06:1.19
	MLWorks_Beta_1996_06_05:1.19
	MLWorks_Beta_1996_06_03:1.19
	MLWorks_Beta_1996_05_31:1.19
	MLWorks_Beta_1996_05_30:1.19
	ML_beta_release_12/08/94:1.17
	ML_beta_release_03/08/94:1.17
	ML_revised_beta_release_25/05/94:1.17
	ML_final_beta_release_02/03/94:1.17
	mlworks-28-01-1994:1.17
	Release:1.17
	mlworks-beta-01-09-1993:1.17
	MLWorks-1-0-4-29/01/1993:1.9
	MLWorks-1-0-3-21/12/1992:1.9
	MLWorks-1-0-2-15/12/1992:1.9
	MLWorks-1-0-1-04/12/1992:1.9
	checkpoint_17_08_92:1.5
	Ten15_release_19-11-91:1.1.1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.19
date	96.02.23.17.09.30;	author jont;	state Exp;
branches
	1.19.1.1
	1.19.2.1
	1.19.3.1
	1.19.4.1
	1.19.5.1
	1.19.6.1
	1.19.7.1
	1.19.8.1
	1.19.9.1
	1.19.10.1
	1.19.11.1;
next	1.18;

1.18
date	95.02.07.10.36.05;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.06.25.14.08.54;	author jont;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	93.06.23.14.56.04;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.05.28.13.32.04;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	93.05.25.18.32.37;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	93.05.25.14.48.32;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	93.04.19.15.57.51;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	93.03.09.13.22.30;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.02.08.13.07.32;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.10.30.14.10.09;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.10.15.15.56.24;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.08.20.17.52.54;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.08.20.17.52.54;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.08.13.15.28.37;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	92.07.15.10.36.36;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.21.16.49.40;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.19.12.18.37;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.42.12;	author colin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	91.11.19.11.12.51;	author jont;	state Exp;
branches;
next	;

1.17.1.1
date	93.06.25.14.08.54;	author jont;	state Exp;
branches;
next	;

1.19.1.1
date	96.09.13.11.41.58;	author hope;	state Exp;
branches;
next	;

1.19.2.1
date	96.10.07.16.35.05;	author hope;	state Exp;
branches;
next	;

1.19.3.1
date	96.10.17.11.54.10;	author hope;	state Exp;
branches;
next	;

1.19.4.1
date	96.11.14.13.22.05;	author hope;	state Exp;
branches
	1.19.4.1.1.1;
next	;

1.19.4.1.1.1
date	96.11.28.15.32.52;	author hope;	state Exp;
branches;
next	;

1.19.5.1
date	96.11.22.18.39.32;	author hope;	state Exp;
branches;
next	;

1.19.6.1
date	96.12.17.18.18.33;	author hope;	state Exp;
branches
	1.19.6.1.1.1;
next	;

1.19.6.1.1.1
date	97.02.24.12.12.48;	author hope;	state Exp;
branches;
next	;

1.19.7.1
date	96.12.18.10.13.51;	author hope;	state Exp;
branches;
next	;

1.19.8.1
date	97.05.12.10.52.05;	author hope;	state Exp;
branches
	1.19.8.1.1.1
	1.19.8.1.2.1
	1.19.8.1.3.1;
next	;

1.19.8.1.1.1
date	97.07.28.18.33.54;	author daveb;	state Exp;
branches
	1.19.8.1.1.1.1.1;
next	;

1.19.8.1.1.1.1.1
date	97.10.07.11.59.52;	author jkbrook;	state Exp;
branches;
next	;

1.19.8.1.2.1
date	97.09.08.17.26.58;	author daveb;	state Exp;
branches;
next	;

1.19.8.1.3.1
date	97.09.09.14.23.51;	author daveb;	state Exp;
branches;
next	;

1.19.9.1
date	97.09.10.19.42.48;	author brucem;	state Exp;
branches;
next	;

1.19.10.1
date	97.09.11.21.10.18;	author daveb;	state Exp;
branches;
next	;

1.19.11.1
date	99.04.01.18.08.49;	author daveb;	state Exp;
branches;
next	;


desc
@Assemblies - semantic object for modules
@


1.19
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@(* assemblies.sml the signature *)
(*
$Log: assemblies.sml,v $
 * Revision 1.18  1995/02/07  10:36:05  matthew
 * Rationalization
 *
Revision 1.17  1993/06/25  14:08:54  jont
Various improvements, particularly to do with signatures embedded in structures

Revision 1.16  1993/06/23  14:56:04  jont
Removed subAssemblies and subTypeAssembly from the signature,
no longer needed

Revision 1.15  1993/05/28  13:32:04  jont
Cleaned up after assembly changes

Revision 1.14  1993/05/25  18:32:37  jont
Added a comment on compose_assemblies

Revision 1.13  1993/05/25  14:48:32  jont
Added a new function for combining assemblies after a topdec

Revision 1.12  1993/04/19  15:57:51  jont
Added a list to Type_Assembly function for input of assemblies

Revision 1.11  1993/03/09  13:22:30  matthew
Options & Info changes

Revision 1.10  1993/02/08  13:07:32  matthew
Removed open Datatypes

Revision 1.9  1992/10/30  14:10:09  jont
Added IntMap structure for type assemblies

Revision 1.8  1992/10/15  15:56:24  clive
Anel's changes for encapsulating assemblies

Revision 1.7  1992/08/20  17:52:54  clive
Changed hashtables to a single structure implementation

Revision 1.6  1992/08/20  17:52:54  jont
Various improvements to remove garbage, handlers etc.

Revision 1.5  1992/08/13  15:28:37  davidt
Removed redundant arguments to newAssemblies function.

Revision 1.4  1992/07/15  10:36:36  jont
Changed exptyStrAssembly to be a function, in case we want an imperative
implementation ever

Revision 1.3  1991/11/21  16:49:40  jont
Added copyright message

Revision 1.2  91/11/19  12:18:37  jont
Merging in comments from Ten15 branch to main trunk

Revision 1.1.1.1  91/11/19  11:12:51  jont
Added comments for DRA on functions

Revision 1.1  91/06/07  11:42:12  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

(* Assemblies are not mentioned in the Definition except in passing,
yet they become crucial to handling the static semantics of modules
correctly. They are used especially in ensuring the correct behaviour
during shadowing. A separate document describes and justifies the use
of assemblies. This module defines the assmebly types and all
functions used with them. *)

require "../typechecker/basistypes";
require "../utils/intnewmap";

signature ASSEMBLIES = 
  sig
    structure IntMap : INTNEWMAP
    structure Basistypes : BASISTYPES

    type StrOffspring
    type TypeOffspring
    type StrAssembly 
    type TypeAssembly

    exception LookupStrname
    exception LookupStrId 
    exception LookupTyCon
    exception LookupTyfun
    exception Consistency of string

    val empty_strassembly : unit -> StrAssembly
    val empty_tyassembly : TypeAssembly

    val add_to_StrAssembly : 
      Basistypes.Datatypes.Strname * StrOffspring * TypeOffspring * StrAssembly -> 
      StrAssembly
    val add_to_TypeAssembly : Basistypes.Datatypes.Tyfun * Basistypes.Datatypes.Valenv * int * TypeAssembly ->
      TypeAssembly

    val collectStrOffspring : Basistypes.Datatypes.Strenv * StrOffspring -> StrOffspring
    val collectTypeOffspring : Basistypes.Datatypes.Tyenv * TypeOffspring -> TypeOffspring 

    val newAssemblies : Basistypes.Datatypes.Strname * Basistypes.Datatypes.Env -> StrAssembly * TypeAssembly

    val remfromStrAssembly : Basistypes.Datatypes.Strname * StrAssembly -> StrAssembly
    val remfromTypeAssembly : Basistypes.Datatypes.Tyfun * TypeAssembly -> TypeAssembly * int

    val lookupStrname : Basistypes.Datatypes.Strname * StrAssembly -> StrOffspring * TypeOffspring
    val lookupStrId : Basistypes.Datatypes.Ident.StrId * StrOffspring -> Basistypes.Datatypes.Strname * int
    val lookupTyCon : Basistypes.Datatypes.Ident.TyCon * TypeOffspring -> Basistypes.Datatypes.Tyfun * int
    val lookupTyfun : Basistypes.Datatypes.Tyfun * TypeAssembly -> Basistypes.Datatypes.Valenv * int

    val inStrOffspringDomain : Basistypes.Datatypes.Ident.StrId * StrOffspring -> bool
    val getStrIds : StrOffspring -> Basistypes.Datatypes.Ident.StrId list
    val inTypeOffspringDomain : Basistypes.Datatypes.Ident.TyCon * TypeOffspring -> bool
    val getTyCons : TypeOffspring -> Basistypes.Datatypes.Ident.TyCon list

    val findStrOffspring : Basistypes.Datatypes.Strname * StrAssembly  -> StrOffspring
    val findTypeOffspring : Basistypes.Datatypes.Strname * StrAssembly -> TypeOffspring

    val unionStrAssembly : StrAssembly * StrAssembly -> StrAssembly
    val unionTypeAssembly : TypeAssembly * TypeAssembly -> TypeAssembly

    val stringStrOffspring : StrOffspring -> string
    val stringTypeOffspring : TypeOffspring -> string
    val stringStrAssembly : StrAssembly -> string
    val stringTypeAssembly : TypeAssembly -> string

    val updateTypeAssembly : Basistypes.Datatypes.Tyenv * TypeAssembly -> TypeAssembly

    val getStrOffspringMap :
      StrOffspring ->
      (Basistypes.Datatypes.Ident.StrId, Basistypes.Datatypes.Strname * int) Basistypes.Datatypes.NewMap.map

    val getTypeOffspringMap :
      TypeOffspring -> 
      (Basistypes.Datatypes.Ident.TyCon, (Basistypes.Datatypes.Tyfun * int)) Basistypes.Datatypes.NewMap.map

    val compose_assemblies : (StrAssembly * TypeAssembly) * (StrAssembly * TypeAssembly) *
      Basistypes.Basis * Basistypes.Basis ->
      StrAssembly * TypeAssembly
      (* New assembly * old assembly * basis increment * basis *)

    val new_assemblies_from_basis : Basistypes.Basis -> StrAssembly * TypeAssembly

    val new_assemblies_from_basis_inc_sig :
      Basistypes.Basis -> StrAssembly * TypeAssembly
  end
@


1.19.11.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.8.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.19.8.1  1997/05/12  10:52:05  hope
 * branched from 1.19
 *
@


1.19.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.19.8.1  1997/05/12  10:52:05  hope
 * branched from 1.19
 *
@


1.19.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.19.8.1  1997/05/12  10:52:05  hope
 * branched from 1.19
 *
@


1.19.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.19.8.1.1.1  1997/07/28  18:33:54  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.19.7.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.6.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.6.1.1.1
log
@branched from 1.19.6.1
@
text
@a3 3
 * Revision 1.19.6.1  1996/12/17  18:18:33  hope
 * branched from 1.19
 *
@


1.19.5.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.4.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.4.1.1.1
log
@branched from 1.19.4.1
@
text
@a3 3
 * Revision 1.19.4.1  1996/11/14  13:22:05  hope
 * branched from 1.19
 *
@


1.19.3.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.2.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/02/23  17:09:30  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.18
log
@Rationalization
@
text
@d4 3
d134 1
a134 1
      (Basistypes.Datatypes.Ident.StrId, Basistypes.Datatypes.Strname * int) Basistypes.Datatypes.NewMap.T
d138 1
a138 1
      (Basistypes.Datatypes.Ident.TyCon, (Basistypes.Datatypes.Tyfun * int)) Basistypes.Datatypes.NewMap.T
@


1.17
log
@Various improvements, particularly to do with signatures embedded in structures
@
text
@d4 3
a88 2
    val empty_str_offspring : StrOffspring
    val empty_type_offspring : TypeOffspring
d92 5
a96 8
    val add_to_StrOffspring : Basistypes.Datatypes.Ident.StrId * Basistypes.Datatypes.Strname * int * StrOffspring 
      -> StrOffspring
    val add_to_TypeOffspring : Basistypes.Datatypes.Ident.TyCon * Basistypes.Datatypes.Tyfun * int * TypeOffspring
      -> TypeOffspring
    val add_to_StrAssembly : Basistypes.Datatypes.Strname * StrOffspring * TypeOffspring
      * StrAssembly -> StrAssembly
    val add_to_TypeAssembly : Basistypes.Datatypes.Tyfun * Basistypes.Datatypes.Valenv * int * TypeAssembly
      -> TypeAssembly
a100 1
    val newTypeAssembly : Basistypes.Datatypes.Env * TypeAssembly -> TypeAssembly
d105 2
a106 2
    val lookupStrname : Basistypes.Datatypes.Strname * StrAssembly -> 
      StrOffspring * TypeOffspring
d111 1
a111 1
    val InStrOffspringDomain : Basistypes.Datatypes.Ident.StrId * StrOffspring -> bool
d113 1
a113 1
    val InTypeOffspringDomain : Basistypes.Datatypes.Ident.TyCon * TypeOffspring -> bool
a114 2
    val getTypeOffspringMap :
      TypeOffspring -> (Basistypes.Datatypes.Ident.TyCon, (Basistypes.Datatypes.Tyfun * int)) Basistypes.Datatypes.NewMap.T
d129 1
a129 1
    val StrOffspring_to_map :
d132 5
a136 11
    val map_to_StrOffspring :
      (Basistypes.Datatypes.Ident.StrId, Basistypes.Datatypes.Strname * int) Basistypes.Datatypes.NewMap.T ->
      StrOffspring
    val TypeOffspring_to_map : TypeOffspring -> (Basistypes.Datatypes.Ident.TyCon, Basistypes.Datatypes.Tyfun * int) Basistypes.Datatypes.NewMap.T
    val map_to_TypeOffspring : (Basistypes.Datatypes.Ident.TyCon, Basistypes.Datatypes.Tyfun * int) Basistypes.Datatypes.NewMap.T -> TypeOffspring
    val TypeAssembly_to_map : TypeAssembly -> ((Basistypes.Datatypes.Tyfun * (Basistypes.Datatypes.Valenv * int)) list) IntMap.T
    val map_to_TypeAssembly : ((Basistypes.Datatypes.Tyfun * (Basistypes.Datatypes.Valenv * int)) list) IntMap.T -> TypeAssembly
    val StrAssembly_to_list : StrAssembly -> (Basistypes.Datatypes.Strname * (StrOffspring * TypeOffspring)) list
    val list_to_StrAssembly : (Basistypes.Datatypes.Strname * (StrOffspring * TypeOffspring)) list -> StrAssembly
    val list_to_TypeAssembly :
      (Basistypes.Datatypes.Tyfun * (Basistypes.Datatypes.Valenv * int)) list -> TypeAssembly
@


1.17.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.17  1993/06/25  14:08:54  jont
Various improvements, particularly to do with signatures embedded in structures

@


1.16
log
@Removed subAssemblies and subTypeAssembly from the signature,
no longer needed
@
text
@d4 4
d154 3
@


1.15
log
@Cleaned up after assembly changes
@
text
@d4 3
a103 4
    val subAssemblies : StrAssembly * TypeAssembly * Basistypes.Datatypes.Structure -> StrAssembly *
      TypeAssembly
    val subTypeAssembly : Basistypes.Datatypes.Tyfun * Basistypes.Datatypes.Valenv * TypeAssembly -> TypeAssembly

@


1.14
log
@Added a comment on compose_assemblies
@
text
@d4 3
d149 2
@


1.13
log
@Added a new function for combining assemblies after a topdec
@
text
@d4 3
d145 1
@


1.12
log
@Added a list to Type_Assembly function for input of assemblies
@
text
@d4 3
d54 1
a54 1
require "../typechecker/datatypes";
d60 1
a60 1
    structure Datatypes : DATATYPES
d78 1
a78 1
    val add_to_StrOffspring : Datatypes.Ident.StrId * Datatypes.Strname * int * StrOffspring 
d80 1
a80 1
    val add_to_TypeOffspring : Datatypes.Ident.TyCon * Datatypes.Tyfun * int * TypeOffspring
d82 1
a82 1
    val add_to_StrAssembly : Datatypes.Strname * StrOffspring * TypeOffspring
d84 1
a84 1
    val add_to_TypeAssembly : Datatypes.Tyfun * Datatypes.Valenv * int * TypeAssembly
d87 2
a88 2
    val collectStrOffspring : Datatypes.Strenv * StrOffspring -> StrOffspring
    val collectTypeOffspring : Datatypes.Tyenv * TypeOffspring -> TypeOffspring 
d90 2
a91 2
    val newTypeAssembly : Datatypes.Env * TypeAssembly -> TypeAssembly
    val newAssemblies : Datatypes.Strname * Datatypes.Env -> StrAssembly * TypeAssembly
d93 3
a95 3
    val remfromStrAssembly : Datatypes.Strname * StrAssembly -> StrAssembly
    val remfromTypeAssembly : Datatypes.Tyfun * TypeAssembly -> TypeAssembly * int
    val subAssemblies : StrAssembly * TypeAssembly * Datatypes.Structure -> StrAssembly *
d97 1
a97 1
    val subTypeAssembly : Datatypes.Tyfun * Datatypes.Valenv * TypeAssembly -> TypeAssembly
d99 1
a99 1
    val lookupStrname : Datatypes.Strname * StrAssembly -> 
d101 3
a103 3
    val lookupStrId : Datatypes.Ident.StrId * StrOffspring -> Datatypes.Strname * int
    val lookupTyCon : Datatypes.Ident.TyCon * TypeOffspring -> Datatypes.Tyfun * int
    val lookupTyfun : Datatypes.Tyfun * TypeAssembly -> Datatypes.Valenv * int
d105 4
a108 4
    val InStrOffspringDomain : Datatypes.Ident.StrId * StrOffspring -> bool
    val getStrIds : StrOffspring -> Datatypes.Ident.StrId list
    val InTypeOffspringDomain : Datatypes.Ident.TyCon * TypeOffspring -> bool
    val getTyCons : TypeOffspring -> Datatypes.Ident.TyCon list
d110 1
a110 1
      TypeOffspring -> (Datatypes.Ident.TyCon, (Datatypes.Tyfun * int)) Datatypes.NewMap.T
d112 2
a113 2
    val findStrOffspring : Datatypes.Strname * StrAssembly  -> StrOffspring
    val findTypeOffspring : Datatypes.Strname * StrAssembly -> TypeOffspring
d123 1
a123 1
    val updateTypeAssembly : Datatypes.Tyenv * TypeAssembly -> TypeAssembly
d127 1
a127 1
      (Datatypes.Ident.StrId, Datatypes.Strname * int) Datatypes.NewMap.T
d129 1
a129 1
      (Datatypes.Ident.StrId, Datatypes.Strname * int) Datatypes.NewMap.T ->
d131 6
a136 6
    val TypeOffspring_to_map : TypeOffspring -> (Datatypes.Ident.TyCon, Datatypes.Tyfun * int) Datatypes.NewMap.T
    val map_to_TypeOffspring : (Datatypes.Ident.TyCon, Datatypes.Tyfun * int) Datatypes.NewMap.T -> TypeOffspring
    val TypeAssembly_to_map : TypeAssembly -> ((Datatypes.Tyfun * (Datatypes.Valenv * int)) list) IntMap.T
    val map_to_TypeAssembly : ((Datatypes.Tyfun * (Datatypes.Valenv * int)) list) IntMap.T -> TypeAssembly
    val StrAssembly_to_list : StrAssembly -> (Datatypes.Strname * (StrOffspring * TypeOffspring)) list
    val list_to_StrAssembly : (Datatypes.Strname * (StrOffspring * TypeOffspring)) list -> StrAssembly
d138 4
a141 1
      (Datatypes.Tyfun * (Datatypes.Valenv * int)) list -> TypeAssembly
@


1.11
log
@Options & Info changes
@
text
@d4 3
d134 2
a135 1

@


1.10
log
@Removed open Datatypes
@
text
@d4 3
d89 1
a89 1
    val subAssemblies : StrAssembly * TypeAssembly * Datatypes.Str -> StrAssembly *
@


1.9
log
@Added IntMap structure for type assemblies
@
text
@d4 3
a52 2
    open Datatypes

d69 1
a69 1
    val add_to_StrOffspring : Ident.StrId * Strname * int * StrOffspring 
d71 1
a71 1
    val add_to_TypeOffspring : Ident.TyCon * Tyfun * int * TypeOffspring
d73 1
a73 1
    val add_to_StrAssembly : Strname * StrOffspring * TypeOffspring
d75 1
a75 1
    val add_to_TypeAssembly : Tyfun * Valenv * int * TypeAssembly
d78 2
a79 2
    val collectStrOffspring : Strenv * StrOffspring -> StrOffspring
    val collectTypeOffspring : Tyenv * TypeOffspring -> TypeOffspring 
d81 2
a82 2
    val newTypeAssembly : Env * TypeAssembly -> TypeAssembly
    val newAssemblies : Strname * Env -> StrAssembly * TypeAssembly
d84 3
a86 3
    val remfromStrAssembly : Strname * StrAssembly -> StrAssembly
    val remfromTypeAssembly : Tyfun * TypeAssembly -> TypeAssembly * int
    val subAssemblies : StrAssembly * TypeAssembly * Str -> StrAssembly *
d88 1
a88 1
    val subTypeAssembly : Tyfun * Valenv * TypeAssembly -> TypeAssembly
d90 1
a90 1
    val lookupStrname : Strname * StrAssembly -> 
d92 8
a99 8
    val lookupStrId : Ident.StrId * StrOffspring -> Strname * int
    val lookupTyCon : Ident.TyCon * TypeOffspring -> Tyfun * int
    val lookupTyfun : Tyfun * TypeAssembly -> Valenv * int

    val InStrOffspringDomain : Ident.StrId * StrOffspring -> bool
    val getStrIds : StrOffspring -> Ident.StrId list
    val InTypeOffspringDomain : Ident.TyCon * TypeOffspring -> bool
    val getTyCons : TypeOffspring -> Ident.TyCon list
d101 1
a101 1
      TypeOffspring -> (Ident.TyCon, (Tyfun * int)) NewMap.T
d103 2
a104 2
    val findStrOffspring : Strname * StrAssembly  -> StrOffspring
    val findTypeOffspring : Strname * StrAssembly -> TypeOffspring
d114 1
a114 1
    val updateTypeAssembly : Tyenv * TypeAssembly -> TypeAssembly
d116 12
a127 8
    val StrOffspring_to_map : StrOffspring -> (Ident.StrId,Strname * int) NewMap.T
    val map_to_StrOffspring : (Ident.StrId,Strname * int) NewMap.T -> StrOffspring
    val TypeOffspring_to_map : TypeOffspring -> (Ident.TyCon,Tyfun * int) NewMap.T
    val map_to_TypeOffspring : (Ident.TyCon,Tyfun * int) NewMap.T -> TypeOffspring
    val TypeAssembly_to_map : TypeAssembly -> ((Tyfun * (Valenv * int)) list) IntMap.T
    val map_to_TypeAssembly : ((Tyfun * (Valenv * int)) list) IntMap.T -> TypeAssembly
    val StrAssembly_to_list : StrAssembly -> (Strname * (StrOffspring * TypeOffspring)) list
    val list_to_StrAssembly : (Strname * (StrOffspring * TypeOffspring)) list -> StrAssembly
@


1.8
log
@Anel's changes for encapsulating assemblies
@
text
@d4 3
d43 1
d47 1
d119 2
a120 2
    val TypeAssembly_to_map : TypeAssembly -> (int, (Tyfun * (Valenv * int)) list) NewMap.T
    val map_to_TypeAssembly : (int, (Tyfun * (Valenv * int)) list) NewMap.T -> TypeAssembly
@


1.7
log
@Changed hashtables to a single structure implementation
@
text
@d4 3
d109 9
@


1.6
log
@Various improvements to remove garbage, handlers etc.
@
text
@d4 3
@


1.5
log
@Removed redundant arguments to newAssemblies function.
@
text
@d4 3
d84 1
d86 1
d88 2
@


1.4
log
@Changed exptyStrAssembly to be a function, in case we want an imperative
implementation ever
@
text
@d4 4
d67 1
a67 2
    val newAssemblies : Strname * Env * StrAssembly * TypeAssembly ->
      StrAssembly * TypeAssembly
@


1.3
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	assemblies.sml,v $
d47 1
a47 1
    val empty_strassembly : StrAssembly
@


1.2
log
@Merging in comments from Ten15 branch to main trunk
@
text
@d1 1
d4 3
d13 1
@


1.1
log
@Initial revision
@
text
@d2 7
a8 1
$Log$
d10 8
@


1.1.1.1
log
@Added comments for DRA on functions
@
text
@d2 1
a2 4
$Log:	assemblies.sml,v $
Revision 1.1  91/06/07  11:42:12  colin
Initial revision

a3 8

(* Assemblies are not mentioned in the Definition except in passing,
yet they become crucial to handling the static semantics of modules
correctly. They are used especially in ensuring the correct behaviour
during shadowing. A separate document describes and justifies the use
of assemblies. This module defines the assmebly types and all
functions used with them. *)

@
