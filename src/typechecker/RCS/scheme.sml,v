head	1.33;
access;
symbols
	MLW_daveb_inline_1_4_99:1.33.3
	MLWorks_21c0_1999_03_25:1.33
	MLWorks_20c1_1998_08_20:1.33
	MLWorks_20c0_1998_08_04:1.33
	MLWorks_20b2c2_1998_06_19:1.33
	MLWorks_20b2_Windows_1998_06_12:1.33
	MLWorks_20b1c1_1998_05_07:1.33
	MLWorks_20b0_1998_04_07:1.33
	MLWorks_20b0_1998_03_20:1.33
	MLWorks_20m2_1998_02_16:1.33
	MLWorks_20m1_1997_10_23:1.33
	MLWorks_11r1:1.32.8.1.1.1.1
	MLWorks_workspace_97:1.33.2
	MLWorks_dt_wizard:1.33.1
	MLWorks_11c0_1997_09_09:1.32.8.1.1.1
	MLWorks_10r3:1.32.8.1.3
	MLWorks_10r2_551:1.32.8.1.2
	MLWorks_11:1.32.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.32.8.1
	MLWorks_20m0_1997_06_20:1.33
	MLWorks_1_0_r2c2_1997_06_14:1.32.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.32.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.32.8
	MLWorks_BugFix_1997_04_24:1.32
	MLWorks_1_0_r2_Win32_1997_04_11:1.32
	MLWorks_1_0_r2_Unix_1997_04_04:1.32
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.32.6.1.1
	MLWorks_gui_1996_12_18:1.32.7
	MLWorks_1_0_Win32_1996_12_17:1.32.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.32.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.32.4.1
	MLWorks_1_0_Irix_1996_11_28:1.32.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.32.5
	MLWorks_1_0_Unix_1996_11_14:1.32.4
	MLWorks_Open_Beta2_1996_10_11:1.32.3
	MLWorks_License_dev:1.32.2
	MLWorks_1_open_beta_1996_09_13:1.32.1
	MLWorks_Open_Beta_1996_08_22:1.32
	MLWorks_Beta_1996_07_02:1.30
	MLWorks_Beta_1996_06_07:1.30
	MLWorks_Beta_1996_06_06:1.30
	MLWorks_Beta_1996_06_05:1.30
	MLWorks_Beta_1996_06_03:1.30
	MLWorks_Beta_1996_05_31:1.30
	MLWorks_Beta_1996_05_30:1.30
	ML_beta_release_12/08/94:1.22
	ML_beta_release_03/08/94:1.22
	ML_revised_beta_release_25/05/94:1.22
	ML_final_beta_release_02/03/94:1.21
	mlworks-28-01-1994:1.20
	Release:1.19
	mlworks-beta-01-09-1993:1.19
	MLWorks-1-0-4-29/01/1993:1.12
	MLWorks-1-0-3-21/12/1992:1.11
	MLWorks-1-0-2-15/12/1992:1.10
	MLWorks-1-0-1-04/12/1992:1.10
	checkpoint_17_08_92:1.7
	Ten15_release_19-11-91:1.1.1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.33
date	97.05.01.12.55.51;	author jont;	state Exp;
branches
	1.33.1.1
	1.33.2.1
	1.33.3.1;
next	1.32;

1.32
date	96.08.06.13.24.17;	author andreww;	state Exp;
branches
	1.32.1.1
	1.32.2.1
	1.32.3.1
	1.32.4.1
	1.32.5.1
	1.32.6.1
	1.32.7.1
	1.32.8.1;
next	1.31;

1.31
date	96.07.03.15.21.35;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	96.03.19.15.53.17;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	95.12.27.11.31.43;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	95.12.18.12.30.51;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	95.12.04.10.54.50;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	95.11.02.10.37.11;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	95.05.11.11.14.53;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	95.03.24.15.00.11;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	95.01.17.13.19.22;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	94.05.11.14.26.44;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	94.02.01.20.40.46;	author nosa;	state Exp;
branches;
next	1.20;

1.20
date	93.09.16.13.28.01;	author nosa;	state Exp;
branches;
next	1.19;

1.19
date	93.04.20.09.39.33;	author matthew;	state Exp;
branches
	1.19.1.1;
next	1.18;

1.18
date	93.04.07.10.55.00;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.04.01.16.44.38;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	93.03.04.10.20.38;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.02.22.10.40.51;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.02.08.13.15.42;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.02.01.14.20.25;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.01.06.12.39.19;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.12.18.15.45.56;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	92.12.01.15.48.08;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.10.30.15.25.54;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.27.19.54.28;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	92.08.13.17.07.52;	author davidt;	state Exp;
branches;
next	1.6;

1.6
date	92.07.16.18.54.40;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.07.04.17.16.05;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.06.16.15.47.43;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	91.11.21.16.53.33;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.19.12.19.10;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.45.06;	author colin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	91.11.19.11.13.02;	author jont;	state Exp;
branches;
next	;

1.19.1.1
date	93.04.20.09.39.33;	author jont;	state Exp;
branches;
next	;

1.32.1.1
date	96.09.13.11.42.10;	author hope;	state Exp;
branches;
next	;

1.32.2.1
date	96.10.07.16.35.16;	author hope;	state Exp;
branches;
next	;

1.32.3.1
date	96.10.17.11.54.20;	author hope;	state Exp;
branches;
next	;

1.32.4.1
date	96.11.14.13.22.23;	author hope;	state Exp;
branches
	1.32.4.1.1.1;
next	;

1.32.4.1.1.1
date	96.11.28.15.33.06;	author hope;	state Exp;
branches;
next	;

1.32.5.1
date	96.11.22.18.39.43;	author hope;	state Exp;
branches;
next	;

1.32.6.1
date	96.12.17.18.18.44;	author hope;	state Exp;
branches
	1.32.6.1.1.1;
next	;

1.32.6.1.1.1
date	97.02.24.12.13.00;	author hope;	state Exp;
branches;
next	;

1.32.7.1
date	96.12.18.10.14.04;	author hope;	state Exp;
branches;
next	;

1.32.8.1
date	97.05.12.10.52.17;	author hope;	state Exp;
branches
	1.32.8.1.1.1
	1.32.8.1.2.1
	1.32.8.1.3.1;
next	;

1.32.8.1.1.1
date	97.07.28.18.34.05;	author daveb;	state Exp;
branches
	1.32.8.1.1.1.1.1;
next	;

1.32.8.1.1.1.1.1
date	97.10.07.12.00.03;	author jkbrook;	state Exp;
branches;
next	;

1.32.8.1.2.1
date	97.09.08.17.27.09;	author daveb;	state Exp;
branches;
next	;

1.32.8.1.3.1
date	97.09.09.14.24.07;	author daveb;	state Exp;
branches;
next	;

1.33.1.1
date	97.09.10.19.43.00;	author brucem;	state Exp;
branches;
next	;

1.33.2.1
date	97.09.11.21.10.30;	author daveb;	state Exp;
branches;
next	;

1.33.3.1
date	99.04.01.18.08.56;	author daveb;	state Exp;
branches;
next	;


desc
@Type Schemes 
(datatype defined in datatypes)
@


1.33
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* scheme.sml the signature *)
(*
$Log: scheme.sml,v $
 * Revision 1.32  1996/08/06  13:24:17  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
 * Revision 1.31  1996/07/03  15:21:35  jont
 * Change check for free imperative type variables to return
 * the full type as well as the type variable
 *
 * Revision 1.30  1996/03/19  15:53:17  matthew
 * Adding option for value polymorphism
 *
 * Revision 1.29  1995/12/27  11:31:43  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.28  1995/12/18  12:30:51  matthew
Adding error info stuff.

Revision 1.27  1995/12/04  10:54:50  jont
Modify has_free_imptyvars to return the offending tyvar if it exists

Revision 1.26  1995/11/02  10:37:11  matthew
Exporting control of value polymorphism

Revision 1.25  1995/05/11  11:14:53  matthew
Removing value from Mismatch exception

Revision 1.24  1995/03/24  15:00:11  matthew
Use Stamp instead of Tyname_id etc.

Revision 1.23  1995/01/17  13:19:22  matthew
Rationalizing debugger

Revision 1.22  1994/05/11  14:26:44  daveb
New overloading scheme.

Revision 1.21  1994/02/01  20:40:46  nosa
generate_moduler compiler option required in type variable instantiation.

Revision 1.20  1993/09/16  13:28:01  nosa
Typechecker now records instances in closed-over type variables
for polymorphic debugger.

Revision 1.19  1993/04/20  09:39:33  matthew
Added generalises_map and apply_instantiation functions

Revision 1.18  1993/04/07  10:55:00  matthew
Added check_closure and generalises functions

Revision 1.17  1993/04/01  16:44:38  jont
Allowed overloadin on strings to be controlled by an option

Revision 1.16  1993/03/04  10:20:38  matthew
Options & Info changes

Revision 1.15  1993/02/22  10:40:51  matthew
Added completion_env to scheme_generalises

Revision 1.14  1993/02/08  13:15:42  matthew
Removed open Datatypes, Changes for BASISTYPES signature

Revision 1.13  1993/02/01  14:20:25  matthew
Removed Datatypes substructure

Revision 1.12  1993/01/06  12:39:19  jont
Anel's last changes

Revision 1.11  1992/12/18  15:45:56  matthew
Propagating options to signature matching error messages.

Revision 1.10  1992/12/01  15:48:08  matthew
Changed handling of overloaded variable errors.

Revision 1.9  1992/10/30  15:25:54  jont
Added special maps for tyfun_id, tyname_id, strname_id

Revision 1.8  1992/08/27  19:54:28  davidt
Yet more changes to get structure copying working better.

Revision 1.7  1992/08/13  17:07:52  davidt
Changed tyvars function to take a tuple of arguments.

Revision 1.6  1992/07/16  18:54:40  jont
Changed to use btrees for renaming of tynames and strnames

Revision 1.5  1992/07/04  17:16:05  jont
Anel's changes for improved structure copying

Revision 1.4  1992/06/16  15:47:43  clive
Added the printing of the name of the relevant identifier in a couple of error messages

Revision 1.3  1991/11/21  16:53:33  jont
Added copyright message

Revision 1.2  91/11/19  12:19:10  jont
Merging in comments from Ten15 branch to main trunk

Revision 1.1.1.1  91/11/19  11:13:02  jont
Added comments for DRA on functions

Revision 1.1  91/06/07  11:45:06  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

(* The type Typescheme (defined in datatypes.sml) corrersponds to the
class TypeScheme of semantic objects defined by the Definition (page
17). This module provides functions that operate on typeschemes, and
some basic type schemes.  All the functions are as described in the
specification of the typechecker, and are all simple *)

require "../utils/set";
require "../main/options";
require "../typechecker/datatypes";

signature SCHEME =
  sig
    structure Set : SET
    structure Options : OPTIONS
    structure Datatypes : DATATYPES

    type error_info 
    type print_options

    exception EnrichError of string
    
    val instantiate  : int * Datatypes.Typescheme * Datatypes.Ident.Location.T * bool 
      -> Datatypes.Type * (Datatypes.InstanceInfo * Datatypes.Instance ref option)
    val make_scheme :  
      (Datatypes.Type list 
       * (Datatypes.Type * (Datatypes.Instance ref * Datatypes.Instance ref option ref) option))
      -> Datatypes.Typescheme

    val unary_overloaded_scheme :
      Datatypes.Ident.ValId * Datatypes.Ident.TyVar -> Datatypes.Typescheme
    val binary_overloaded_scheme :
      Datatypes.Ident.ValId * Datatypes.Ident.TyVar -> Datatypes.Typescheme
    val predicate_overloaded_scheme :
      Datatypes.Ident.ValId * Datatypes.Ident.TyVar -> Datatypes.Typescheme

    val equalityp : Datatypes.Typescheme -> bool
    val schemify : 
      (error_info * Options.options * Datatypes.Ident.Location.T) ->
      (int * bool * Datatypes.Typescheme * Datatypes.Ident.TyVar Set.Set * bool) ->
      Datatypes.Typescheme 
    val schemify' : 
      (int * bool * Datatypes.Typescheme * Datatypes.Ident.TyVar Set.Set * bool) ->
      Datatypes.Typescheme 
    val string_scheme : Datatypes.Typescheme -> string
    val typescheme_eq : Datatypes.Typescheme * Datatypes.Typescheme -> bool 

    (* check we can close over all type variables *)
    val check_closure : (bool * Datatypes.Type * int * Datatypes.Ident.TyVar Set.Set) -> bool

    exception Mismatch

    val SML90_dynamic_generalises: MLWorks.Internal.Dynamic.type_rep
                                  * MLWorks.Internal.Dynamic.type_rep -> bool
    val SML96_dynamic_generalises: MLWorks.Internal.Dynamic.type_rep
                                  * MLWorks.Internal.Dynamic.type_rep -> bool

    val generalises : bool -> Datatypes.Type * Datatypes.Type -> bool
    val generalises_map : bool -> Datatypes.Type * Datatypes.Type -> (int * Datatypes.Type) list
    val apply_instantiation : Datatypes.Type * (int * Datatypes.Type) list -> Datatypes.Type

    val scheme_generalises :
      Options.options ->
      Datatypes.Ident.ValId * Datatypes.Env * int * Datatypes.Typescheme * Datatypes.Typescheme ->
      bool

    val gather_tynames : Datatypes.Typescheme -> Datatypes.Tyname list
    val has_free_imptyvars : Datatypes.Typescheme -> (Datatypes.Type *Datatypes.Type) option
    val scheme_copy : Datatypes.Typescheme * (Datatypes.Tyname) Datatypes.StampMap -> Datatypes.Typescheme
    val tyvars : Datatypes.Ident.TyVar list * Datatypes.Typescheme -> Datatypes.Ident.TyVar list
  end

signature TYPESCHEME = SCHEME
@


1.33.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.33  1997/05/01  12:55:51  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.33.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.33  1997/05/01  12:55:51  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.33.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.33  1997/05/01  12:55:51  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.32
log
@[Bug #1521]
Propagating changes to _types.sml and _completion.sml
and dividing the dynamic_generalises function into two:
one for sml'90 and one for sml'96 (to take into account the
differences in treatment of "imperative" variables.
@
text
@d4 7
d134 1
a134 1
      -> Datatypes.Type * (Datatypes.InstanceInfo * Datatypes.Instance ref MLWorks.Option.option)
d137 1
a137 1
       * (Datatypes.Type * (Datatypes.Instance ref * Datatypes.Instance ref MLWorks.Option.option ref) MLWorks.Option.option))
d178 1
a178 1
    val has_free_imptyvars : Datatypes.Typescheme -> (Datatypes.Type *Datatypes.Type) MLWorks.Option.option
@


1.32.8.1
log
@branched from 1.32
@
text
@a3 7
 * Revision 1.32  1996/08/06  13:24:17  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
@


1.32.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.32.8.1  1997/05/12  10:52:17  hope
 * branched from 1.32
 *
@


1.32.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.32.8.1  1997/05/12  10:52:17  hope
 * branched from 1.32
 *
@


1.32.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.32.8.1  1997/05/12  10:52:17  hope
 * branched from 1.32
 *
@


1.32.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.32.8.1.1.1  1997/07/28  18:34:05  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.32.7.1
log
@branched from 1.32
@
text
@a3 7
 * Revision 1.32  1996/08/06  13:24:17  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
@


1.32.6.1
log
@branched from 1.32
@
text
@a3 7
 * Revision 1.32  1996/08/06  13:24:17  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
@


1.32.6.1.1.1
log
@branched from 1.32.6.1
@
text
@a3 3
 * Revision 1.32.6.1  1996/12/17  18:18:44  hope
 * branched from 1.32
 *
@


1.32.5.1
log
@branched from 1.32
@
text
@a3 7
 * Revision 1.32  1996/08/06  13:24:17  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
@


1.32.4.1
log
@branched from 1.32
@
text
@a3 7
 * Revision 1.32  1996/08/06  13:24:17  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
@


1.32.4.1.1.1
log
@branched from 1.32.4.1
@
text
@a3 3
 * Revision 1.32.4.1  1996/11/14  13:22:23  hope
 * branched from 1.32
 *
@


1.32.3.1
log
@branched from 1.32
@
text
@a3 7
 * Revision 1.32  1996/08/06  13:24:17  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
@


1.32.2.1
log
@branched from 1.32
@
text
@a3 7
 * Revision 1.32  1996/08/06  13:24:17  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
@


1.32.1.1
log
@branched from 1.32
@
text
@a3 7
 * Revision 1.32  1996/08/06  13:24:17  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
@


1.31
log
@Change check for free imperative type variables to return
the full type as well as the type variable
@
text
@d4 4
d142 2
a143 2
      (error_info * print_options * Datatypes.Ident.Location.T) ->
      (bool * int * bool * Datatypes.Typescheme * Datatypes.Ident.TyVar Set.Set * bool) ->
d146 1
a146 1
      (bool * int * bool * Datatypes.Typescheme * Datatypes.Ident.TyVar Set.Set * bool) ->
d156 7
a162 2
    val generalises : bool * Datatypes.Type * Datatypes.Type -> bool
    val generalises_map : bool * Datatypes.Type * Datatypes.Type -> (int * Datatypes.Type) list
@


1.30
log
@Adding option for value polymorphism
@
text
@d4 3
d162 1
a162 1
    val has_free_imptyvars : Datatypes.Typescheme -> Datatypes.Type MLWorks.Option.option
@


1.29
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
a116 2
    val use_value_polymorphism : bool ref

d136 1
a136 1
      (int * bool * Datatypes.Typescheme * Datatypes.Ident.TyVar Set.Set * bool) ->
d139 1
a139 1
      (int * bool * Datatypes.Typescheme * Datatypes.Ident.TyVar Set.Set * bool) ->
d145 1
a145 1
    val check_closure : (Datatypes.Type * int * Datatypes.Ident.TyVar Set.Set) -> bool
d149 2
a150 2
    val generalises : Datatypes.Type * Datatypes.Type -> bool
    val generalises_map : Datatypes.Type * Datatypes.Type -> (int * Datatypes.Type) list
@


1.28
log
@Adding error info stuff.
@
text
@d4 3
d119 1
a119 1
      -> Datatypes.Type * (Datatypes.InstanceInfo * Datatypes.Instance ref Datatypes.Option.opt)
d122 1
a122 1
       * (Datatypes.Type * (Datatypes.Instance ref * Datatypes.Instance ref Datatypes.Option.opt ref) Datatypes.Option.opt))
@


1.27
log
@Modify has_free_imptyvars to return the offending tyvar if it exists
@
text
@d4 3
d108 3
a112 2
    exception MakeScheme of string * Datatypes.Type

d130 6
a135 1
    val schemify : (int * bool * Datatypes.Typescheme * Datatypes.Ident.TyVar Set.Set * bool) ->
@


1.26
log
@Exporting control of value polymorphism
@
text
@d4 3
d146 1
a146 1
    val has_free_imptyvars : Datatypes.Typescheme -> bool
@


1.25
log
@Removing value from Mismatch exception
@
text
@d4 3
d101 2
@


1.24
log
@Use Stamp instead of Tyname_id etc.
@
text
@d4 3
d126 2
a127 1
    exception MisMatch of (Datatypes.Type * Datatypes.Type)
@


1.23
log
@Rationalizing debugger
@
text
@d4 3
d135 1
a135 1
    val scheme_copy : Datatypes.Typescheme * (Datatypes.Tyname) Datatypes.Tyfun_id.Map.T -> Datatypes.Typescheme
@


1.22
log
@New overloading scheme.
@
text
@d4 3
d98 1
a98 1
      -> Datatypes.Type * (int list * Datatypes.Instance ref Datatypes.Option.opt)
@


1.21
log
@generate_moduler compiler option required in type variable instantiation.
@
text
@d4 3
a89 1
    exception UnresolvedVar of Datatypes.Ident.ValId
d94 1
a94 1
    val instantiate  : int * Datatypes.Typescheme * bool
d100 8
a107 3
    val unary_overloaded_scheme : Datatypes.Ident.ValId -> Datatypes.Typescheme
    val binary_overloaded_scheme : Datatypes.Ident.ValId -> Datatypes.Typescheme
    val predicate_overloaded_scheme : Datatypes.Ident.ValId -> Datatypes.Typescheme
@


1.20
log
@Typechecker now records instances in closed-over type variables
for polymorphic debugger.
@
text
@d4 4
d92 5
a96 5
    val instantiate  : int * Datatypes.Typescheme
      -> Datatypes.Type * (int list * Datatypes.instance ref Datatypes.Option.opt)
    val make_scheme :  (Datatypes.Type list 
                        * (Datatypes.Type * (Datatypes.instance ref
                           * Datatypes.instance ref Datatypes.Option.opt ref) Datatypes.Option.opt))
@


1.19
log
@Added generalises_map and apply_instantiation functions
@
text
@d4 3
d88 6
a93 2
    val instantiate  : int * Datatypes.Typescheme  -> Datatypes.Type
    val make_scheme :  (Datatypes.Type list * Datatypes.Type) -> Datatypes.Typescheme
@


1.19.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.19  1993/04/20  09:39:33  matthew
Added generalises_map and apply_instantiation functions

@


1.18
log
@Added check_closure and generalises functions
@
text
@d4 3
d101 2
@


1.17
log
@Allowed overloadin on strings to be controlled by an option
@
text
@d4 3
d92 7
d103 1
@


1.16
log
@Options & Info changes
@
text
@d4 3
d90 1
a90 1
      Options.print_options ->
@


1.15
log
@Added completion_env to scheme_generalises
@
text
@d4 3
d62 1
a62 1
require "../main/info";
d68 1
a68 1
    structure Info : INFO
a70 2
    sharing Datatypes.Ident.Location = Info.Location

d87 1
a87 1
      Info.options ->
@


1.14
log
@Removed open Datatypes, Changes for BASISTYPES signature
@
text
@d4 3
d87 1
a87 1
      Datatypes.Ident.ValId * int * Datatypes.Typescheme * Datatypes.Typescheme ->
@


1.13
log
@Removed Datatypes substructure
@
text
@d4 3
d67 2
a68 4
    open Datatypes

    exception UnresolvedVar of Ident.ValId
    exception MakeScheme of string * Type
d72 10
a81 10
    val instantiate  : int * Typescheme  -> Type
    val make_scheme :  (Type list * Type) -> Typescheme
    val unary_overloaded_scheme : Ident.ValId -> Typescheme
    val binary_overloaded_scheme : Ident.ValId -> Typescheme
    val predicate_overloaded_scheme : Ident.ValId -> Typescheme
    val equalityp : Typescheme -> bool
    val schemify : (int * bool * Typescheme * Ident.TyVar Set.Set * bool) ->
      Typescheme 
    val string_scheme : Typescheme -> string
    val typescheme_eq : Typescheme * Typescheme -> bool 
d84 1
a84 1
      Datatypes.Ident.ValId * int * Typescheme * Typescheme ->
d86 4
a89 4
    val gather_tynames : Typescheme -> Tyname list
    val has_free_imptyvars : Typescheme -> bool
    val scheme_copy : Typescheme * (Tyname) Tyfun_id.Map.T -> Typescheme
    val tyvars : Ident.TyVar list * Typescheme -> Ident.TyVar list
@


1.12
log
@Anel's last changes
@
text
@d4 3
d59 1
d61 3
a63 2
    structure Info : INFO
      
@


1.11
log
@Propagating options to signature matching error messages.
,
@
text
@d4 3
d61 1
a61 1
    exception UnresolvedVar
d68 3
a70 3
    val unary_overloaded_scheme : Typescheme
    val binary_overloaded_scheme : Typescheme
    val predicate_overloaded_scheme : Typescheme
@


1.10
log
@Changed handling of overloaded variable errors.
@
text
@d4 3
d47 1
d54 2
a55 1

d73 4
a76 1
    val scheme_generalises : Datatypes.Ident.ValId * int * Typescheme * Typescheme -> bool
@


1.9
log
@Added special maps for tyfun_id, tyname_id, strname_id
@
text
@d4 3
d53 3
a55 1
    exception MakeScheme of (string * Type)
@


1.8
log
@Yet more changes to get structure copying working better.
@
text
@d4 3
a40 1
require "../utils/newmap";
a44 1
    structure NewMap : NEWMAP
d66 1
a66 1
    val scheme_copy : Typescheme * (Tyfun_id.Tyfun_id, Tyname) NewMap.T -> Typescheme
@


1.7
log
@Changed tyvars function to take a tuple of arguments.
@
text
@d4 3
d65 1
a65 4
(*    val scheme_copy : Typescheme * (Tyname * Tyname) list * 
      (Tyname -> Tyname) -> Typescheme * (Tyname * Tyname) list *)
    val scheme_copy : Typescheme * (Tyfun_id.Tyfun_id, Tyname) NewMap.T * 
      (Tyname -> Tyname) -> Typescheme * (Tyfun_id.Tyfun_id, Tyname) NewMap.T 
a69 2


@


1.6
log
@Changed to use btrees for renaming of tynames and strnames
@
text
@d4 3
d66 1
a66 1
    val tyvars : Typescheme -> Ident.TyVar list -> Ident.TyVar list
@


1.5
log
@Anel's changes for improved structure copying
@
text
@d4 3
d32 1
d37 1
d61 2
a62 2
    val scheme_copy : Typescheme * (Tyfun_id.Tyfun_id * Tyname) list * 
      (Tyname -> Tyname) -> Typescheme * (Tyfun_id.Tyfun_id * Tyname) list 
@


1.4
log
@Added the printing of the name of the relevant identifier in a couple of error messages
@
text
@d4 3
d54 4
a57 2
    val scheme_copy : Typescheme * (Tyname * Tyname) list * 
      (Tyname -> Tyname) -> Typescheme * (Tyname * Tyname) list 
@


1.3
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	scheme.sml,v $
d48 1
a48 1
    val scheme_generalises : int * Typescheme * Typescheme -> bool
d57 1
@


1.2
log
@Merging in comments from Ten15 branch to main trunk
@
text
@d1 1
d4 3
d13 1
@


1.1
log
@Initial revision
@
text
@d2 7
a8 1
$Log$
d10 7
@


1.1.1.1
log
@Added comments for DRA on functions
@
text
@d2 1
a2 4
$Log:	scheme.sml,v $
Revision 1.1  91/06/07  11:45:06  colin
Initial revision

a3 7

(* The type Typescheme (defined in datatypes.sml) corrersponds to the
class TypeScheme of semantic objects defined by the Definition (page
17). This module provides functions that operate on typeschemes, and
some basic type schemes.  All the functions are as described in the
specification of the typechecker, and are all simple *)

@
