head	1.61;
access;
symbols
	MLW_daveb_inline_1_4_99:1.61.8
	MLWorks_21c0_1999_03_25:1.61
	MLWorks_20c1_1998_08_20:1.61
	MLWorks_20c0_1998_08_04:1.61
	MLWorks_20b2c2_1998_06_19:1.61
	MLWorks_20b2_Windows_1998_06_12:1.61
	MLWorks_20b1c1_1998_05_07:1.61
	MLWorks_20b0_1998_04_07:1.61
	MLWorks_20b0_1998_03_20:1.61
	MLWorks_20m2_1998_02_16:1.61
	MLWorks_20m1_1997_10_23:1.61
	MLWorks_11r1:1.61.5.1.1.1.1
	MLWorks_workspace_97:1.61.7
	MLWorks_dt_wizard:1.61.6
	MLWorks_11c0_1997_09_09:1.61.5.1.1.1
	MLWorks_10r3:1.61.5.1.3
	MLWorks_10r2_551:1.61.5.1.2
	MLWorks_11:1.61.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.61.5.1
	MLWorks_20m0_1997_06_20:1.61
	MLWorks_1_0_r2c2_1997_06_14:1.61.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.61.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.61.5
	MLWorks_BugFix_1997_04_24:1.61
	MLWorks_1_0_r2_Win32_1997_04_11:1.61
	MLWorks_1_0_r2_Unix_1997_04_04:1.61
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.61.3.1.1
	MLWorks_gui_1996_12_18:1.61.4
	MLWorks_1_0_Win32_1996_12_17:1.61.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.61.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.61.1.1
	MLWorks_1_0_Irix_1996_11_28:1.61.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.61.2
	MLWorks_1_0_Unix_1996_11_14:1.61.1
	MLWorks_Open_Beta2_1996_10_11:1.59.3
	MLWorks_License_dev:1.59.2
	MLWorks_1_open_beta_1996_09_13:1.59.1
	MLWorks_Open_Beta_1996_08_22:1.59
	MLWorks_Beta_1996_07_02:1.59
	MLWorks_Beta_1996_06_07:1.59
	MLWorks_Beta_1996_06_06:1.59
	MLWorks_Beta_1996_06_05:1.59
	MLWorks_Beta_1996_06_03:1.58
	MLWorks_Beta_1996_05_31:1.58
	MLWorks_Beta_1996_05_30:1.58
	ML_beta_release_12/08/94:1.46
	ML_beta_release_03/08/94:1.46
	ML_revised_beta_release_25/05/94:1.46
	ML_final_beta_release_02/03/94:1.44
	mlworks-28-01-1994:1.43
	Release:1.38
	mlworks-beta-01-09-1993:1.38
	MLWorks-1-0-4-29/01/1993:1.28
	MLWorks-1-0-3-21/12/1992:1.27
	MLWorks-1-0-2-15/12/1992:1.26
	MLWorks-1-0-1-04/12/1992:1.24
	checkpoint_17_08_92:1.14
	Ten15_release_19-11-91:1.3
	Ten15_release_21-08-91:1.3
	Ten15_release_19-08-91:1.3
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.61
date	96.10.29.13.50.31;	author io;	state Exp;
branches
	1.61.1.1
	1.61.2.1
	1.61.3.1
	1.61.4.1
	1.61.5.1
	1.61.6.1
	1.61.7.1
	1.61.8.1;
next	1.60;

1.60
date	96.10.25.12.35.45;	author jont;	state Exp;
branches;
next	1.59;

1.59
date	96.06.04.11.45.53;	author jont;	state Exp;
branches
	1.59.1.1
	1.59.2.1
	1.59.3.1;
next	1.58;

1.58
date	96.05.24.11.51.32;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	96.04.30.15.58.30;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	96.03.28.10.17.19;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	95.12.27.11.50.25;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	95.09.06.13.02.28;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	95.06.15.10.30.15;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	95.06.01.12.04.18;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	95.04.28.16.36.48;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	95.03.24.15.17.27;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	95.02.06.11.50.24;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	95.01.30.11.50.03;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	94.10.13.11.01.14;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	94.05.04.16.05.39;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	94.04.13.13.47.27;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	94.02.28.09.00.38;	author nosa;	state Exp;
branches;
next	1.43;

1.43
date	94.01.05.15.03.06;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	93.12.02.17.31.39;	author nickh;	state Exp;
branches;
next	1.41;

1.41
date	93.12.01.13.58.23;	author nickh;	state Exp;
branches;
next	1.40;

1.40
date	93.11.30.11.44.55;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	93.09.22.13.06.46;	author nosa;	state Exp;
branches;
next	1.38;

1.38
date	93.07.30.14.44.14;	author nosa;	state Exp;
branches
	1.38.1.1;
next	1.37;

1.37
date	93.07.07.15.24.41;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	93.04.01.16.55.51;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	93.03.17.18.55.26;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.03.10.14.45.10;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	93.03.04.11.53.27;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.02.23.12.04.16;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	93.02.22.10.34.06;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	93.02.08.19.09.57;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.02.01.14.58.09;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.01.06.12.34.58;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	92.12.18.16.13.24;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	92.12.07.11.23.11;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	92.12.04.20.07.36;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	92.12.03.13.33.13;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.11.26.19.53.33;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	92.11.25.16.56.22;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.11.25.12.59.57;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	92.11.23.12.22.19;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	92.11.23.12.22.19;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.10.12.11.32.13;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.09.08.13.44.16;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.08.27.14.59.35;	author davidt;	state Exp;
branches;
next	1.15;

1.15
date	92.08.18.15.55.14;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.08.12.11.15.08;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.08.11.11.24.17;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.08.10.17.05.46;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.08.04.13.27.03;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.05.05.14.09.27;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.04.27.11.43.28;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.03.16.11.30.35;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.02.03.12.08.27;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.01.27.20.14.29;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.01.24.16.56.50;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.11.19.19.12.06;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.16.17.21.20;	author colin;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.18.55.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.37.16;	author colin;	state Exp;
branches;
next	;

1.38.1.1
date	93.07.30.14.44.14;	author jont;	state Exp;
branches;
next	;

1.59.1.1
date	96.09.13.11.41.54;	author hope;	state Exp;
branches;
next	;

1.59.2.1
date	96.10.07.16.34.59;	author hope;	state Exp;
branches;
next	;

1.59.3.1
date	96.10.17.11.54.05;	author hope;	state Exp;
branches;
next	;

1.61.1.1
date	96.11.14.13.21.58;	author hope;	state Exp;
branches
	1.61.1.1.1.1;
next	;

1.61.1.1.1.1
date	96.11.28.15.32.47;	author hope;	state Exp;
branches;
next	;

1.61.2.1
date	96.11.22.18.39.27;	author hope;	state Exp;
branches;
next	;

1.61.3.1
date	96.12.17.18.18.28;	author hope;	state Exp;
branches
	1.61.3.1.1.1;
next	;

1.61.3.1.1.1
date	97.02.24.12.12.43;	author hope;	state Exp;
branches;
next	;

1.61.4.1
date	96.12.18.10.13.46;	author hope;	state Exp;
branches;
next	;

1.61.5.1
date	97.05.12.10.52.00;	author hope;	state Exp;
branches
	1.61.5.1.1.1
	1.61.5.1.2.1
	1.61.5.1.3.1;
next	;

1.61.5.1.1.1
date	97.07.28.18.33.48;	author daveb;	state Exp;
branches
	1.61.5.1.1.1.1.1;
next	;

1.61.5.1.1.1.1.1
date	97.10.07.11.59.48;	author jkbrook;	state Exp;
branches;
next	;

1.61.5.1.2.1
date	97.09.08.17.26.54;	author daveb;	state Exp;
branches;
next	;

1.61.5.1.3.1
date	97.09.09.14.23.46;	author daveb;	state Exp;
branches;
next	;

1.61.6.1
date	97.09.10.19.42.44;	author brucem;	state Exp;
branches;
next	;

1.61.7.1
date	97.09.11.21.10.13;	author daveb;	state Exp;
branches;
next	;

1.61.8.1
date	99.04.01.18.08.47;	author daveb;	state Exp;
branches;
next	;


desc
@Realisation Maps
See The Definition (section 5.7)
@


1.61
log
@[Bug #1614]
basifying String
@
text
@(*
$Log: _realise.sml,v $
 * Revision 1.60  1996/10/25  12:35:45  jont
 * Fix problem with compiler looping
 *
 * Revision 1.59  1996/06/04  11:45:53  jont
 * Remove the esoteric type sharing violation 2 message
 *
 * Revision 1.58  1996/05/24  11:51:32  matthew
 * Attempting to fix problem with where type
 *
 * Revision 1.57  1996/04/30  15:58:30  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.56  1996/03/28  10:17:19  matthew
 * Language revisions
 *
 * Revision 1.55  1995/12/27  11:50:25  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.54  1995/09/06  13:02:28  jont
Improved error reporting for missing values, types, substructures
during signature matching

Revision 1.53  1995/06/15  10:30:15  jont
Only report constructors different when the domains differ

Revision 1.52  1995/06/01  12:04:18  matthew
Fixing silent error for inconsistent valenvs

Revision 1.51  1995/04/28  16:36:48  daveb
Fixed bug in tystr_realise - it was testing for equality before
checking that the tyfun was in the nameset, which led to an error
message about equality instead of type sharing.

Revision 1.50  1995/03/24  15:17:27  matthew
Use Stamp instead of Tyname_id etc.

Revision 1.49  1995/02/06  11:50:24  matthew
Rationalizations

Revision 1.48  1995/01/30  11:50:03  matthew
Rationalizing debugger

Revision 1.47  1994/10/13  11:01:14  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.46  1994/05/04  16:05:39  jont
Fix make_eta_tyfun to preserve arity

Revision 1.45  1994/04/13  13:47:27  jont
Remove Bind handler

Revision 1.44  1994/02/28  09:00:38  nosa
Debugger structures for Modules Debugger.

Revision 1.43  1994/01/05  15:03:06  matthew
Greater care over the set of free names -- ensure functor parameters
don't get overwritten.
Check freeness of tynames before overwriting also

Revision 1.42  1993/12/02  17:31:39  nickh
Fixup some error messages and inexhaustive bindings.

Revision 1.41  1993/12/01  13:58:23  nickh
Marked certain error messages as "impossible".

Revision 1.40  1993/11/30  11:44:55  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.39  1993/09/22  13:06:46  nosa
Signature and structure instances linking for polymorphic debugger.

Revision 1.38  1993/07/30  14:44:14  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
new compiler option debug_variables.

Revision 1.37  1993/07/07  15:24:41  daveb
Removed exception environments.
ve_ran_enriches now checks that the constructor status of valids matches
appropriately.  It returns a bool to indicate when _lambda has to coerce
exceptions to values.

Revision 1.36  1993/04/01  16:55:51  jont
Allowed overloadin on strings to be controlled by an option

Revision 1.35  1993/03/17  18:55:26  matthew
Nameset signature changes

Revision 1.34  1993/03/10  14:45:10  matthew
Options changes

Revision 1.33  1993/03/04  11:53:27  matthew
Options & Info changes

Revision 1.32  1993/02/23  12:04:16  matthew
More on maximising number of errors reported in one go

Revision 1.31  1993/02/22  10:34:06  matthew
 Moved all realise and enrich code here from various places.
Fixed error reporting so it tries to report more than one
error at once.

Revision 1.30  1993/02/08  19:09:57  matthew
Changes for BASISTYPES signature

Revision 1.29  1993/02/01  14:58:09  matthew
COPYSTR changes
Changes to error messages.

Revision 1.28  1993/01/06  12:34:58  jont
Anel's last changes

Revision 1.27  1992/12/18  16:13:24  matthew
Propagating options to signature matching error messages.

Revision 1.26  1992/12/07  11:23:11  matthew
Changed error messages.

Revision 1.25  1992/12/04  20:07:36  matthew
Error message revisions.

Revision 1.24  1992/12/03  13:33:13  jont
Replaced some NewMap.fold calls with NewMap.forall

Revision 1.23  1992/11/26  19:53:33  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.22  1992/11/25  16:56:22  jont
Minor improvements to str_realise to strip the first strname before matching

Revision 1.21  1992/11/25  12:59:57  matthew
Really changed the error messages this time.

Revision 1.20  1992/11/23  12:22:19  matthew
Improved error messages.

Revision 1.19  1992/11/23  12:22:19  jont
Small improvements in tystr_realise

Revision 1.18  1992/10/12  11:32:13  clive
Tynames now have a slot recording their definition point

Revision 1.17  1992/09/08  13:44:16  jont
Modified the realisation of tynames

Revision 1.16  1992/08/27  14:59:35  davidt
Added Anel's changes.

Revision 1.15  1992/08/18  15:55:14  jont
Removed irrelevant handlers and new exceptions

Revision 1.14  1992/08/12  11:15:08  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.13  1992/08/11  11:24:17  matthew
removed type_eq_matters

Revision 1.12  1992/08/10  17:05:46  jont
Fix for equality type problem

Revision 1.11  1992/08/04  13:27:03  jont
Anel's changes to use NewMap instead of Map

Revision 1.10  1992/05/05  14:09:27  jont
Anel's fixes.

Revision 1.9  1992/04/27  11:43:28  jont
Added extra parameter to indicate when equality attributes of
types matter.

Revision 1.8  1992/03/16  11:30:35  jont
Added require "ty_debug"

Revision 1.7  1992/02/03  12:08:27  jont
Added type name to an error message

Revision 1.6  1992/01/27  20:14:29  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.5  1992/01/24  16:56:50  jont
Updated to allow valenv in METATYNAME

Revision 1.4  1991/11/19  19:12:06  jont
Fixed inexhaustive matches

Revision 1.3  91/07/16  17:21:20  colin
Modified tystr_realise to use Valenv.ve_domain to extract domain of valenvs

Revision 1.2  91/06/17  18:55:00  nickh
Modified to take new ValEnv definition with ref unit to allow
reading and writing circular data structures.

Revision 1.1  91/06/07  11:37:16  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/print";
require "../utils/crash";
require "../utils/lists";
require "../main/info";
require "../basics/identprint";
require "strnames";
require "types";
require "tyenv";
require "strenv";
require "environment";
require "sigma";
require "scheme";
require "valenv";
require "nameset";
require "realise";

functor Realise (
  include
  sig               
  structure Print     : PRINT
  structure Crash     : CRASH
  structure Lists     : LISTS
  structure IdentPrint : IDENTPRINT
  structure Strnames  : STRNAMES
  structure Types     : TYPES
  structure Tyenv     : TYENV
  structure Strenv    : STRENV
  structure Env       : ENVIRONMENT
  structure Sigma     : SIGMA
  structure Scheme    : SCHEME
  structure Valenv    : VALENV
  structure Nameset   : NAMESET
  structure Info      : INFO
  sharing Sigma.Options = Nameset.Options = IdentPrint.Options = Scheme.Options

  sharing Sigma.BasisTypes.Datatypes = Strnames.Datatypes
    = Types.Datatypes = Tyenv.Datatypes = Env.Datatypes = Scheme.Datatypes
    = Strenv.Datatypes = Valenv.Datatypes = Nameset.Datatypes
  sharing Types.Datatypes.Ident = IdentPrint.Ident
  sharing type Sigma.BasisTypes.Nameset = Nameset.Nameset
  end  where type Types.Datatypes.Stamp = int
    ) : REALISE =
  

  struct
    structure BasisTypes = Sigma.BasisTypes
    structure Info = Info
    structure Options = Scheme.Options
    structure Datatypes = BasisTypes.Datatypes

    open Datatypes

    fun string_strids strids =
      concat (map (fn s => IdentPrint.printStrId s ^ ".")(rev strids))

    fun string_strids' [] = ""
      | string_strids' (a::b) = string_strids b ^ IdentPrint.printStrId a

    (* eager andalso *)
    fun aswell (x,y) = x andalso y
          
    (* Don't use NewMap.forall this stops evaluating as soon as false is returned *)
    fun eforall pred map =
      NewMap.fold (fn (b,x,y) => aswell (pred(x,y),b)) (true,map)

    val dummy_tf = ~3
    val generate_moduler_debug = false

    fun get_name_and_env (_,STR(m,_,e)) = (m,e)
      | get_name_and_env (error,_) = Crash.impossible error
      
    fun sigmatch
      (error_info,
       options as Options.OPTIONS{print_options,
                                  compiler_options = Options.COMPILEROPTIONS{generate_moduler, ...}, ...})
      (location,completion_env,level,sigma as BasisTypes.SIGMA (names,str),str') =

      let
(*
        val _ = output (std_out, "Sigmatch:\n")
        val _ = output (std_out,Env.string_str str')
        val _ = output (std_out,Sigma.string_sigma Options.default_print_options sigma)
*)

        val nameset_ref = ref (Nameset.simple_copy names)

        fun remove_strname strname =
          nameset_ref := Nameset.remove_strname (strname,!nameset_ref)

        fun remove_tyname tyname =
          nameset_ref := Nameset.remove_tyname (tyname,!nameset_ref)

        fun error message_list =
          Info.error error_info (Info.RECOVERABLE,location,concat message_list)

        (* Realisation is managed by references in tynames and strnames.  
         In order to do this all type names and structure names generated
         during signature elaboration are flexible, containing
         uninstantiated references to type functions and structure names,
         respectively.  These references are destructively modified
         during realisation.  Because a single signature may have many
         structures as instances a copy is made of a signature before it
         is matched against a structure.  This is done in the function from 
         where Realise.sigmatch is called. *)

        (****
         The domain of amap is a subset of the domain of amap' and for every 
         element in the domain of amap the scheme corresponding to it in amap'
         must generalise the scheme corresponding to it in amap, and if valid
	 is a constructor in amap than it must be a constructor in amap'.
         ****)
          
        fun ve_ran_enriches(level,ve as VE (_,amap),ve' as VE (_,amap'), strids) =
          let
            fun ran_enriches(valid, scheme) =
              let
	        (* Use polymorphic equality, so that constructor status is compared. *)
                (* This might not work -- MLA *)
                (* Look it up *)
		val (entry, need_coerce) =
		  case NewMap.tryApply'Eq(amap', valid) of
		    NONE =>
		      (* Second chance if we're dealing with a valspec.
                       It can be matched by a constructor in the structure. *)
		      (case valid of
			 IdentPrint.Ident.VAR _ =>
			   (NewMap.tryApply' (amap', valid), true)
		       | _ => (NONE, false))
		  | entry => (entry, false)

                (* link signature and structure instances of identifiers;
                   compute integer-instance to be eventually passed round at runtime 
                   for the polymorphic debugger *)

                fun fetch_instance1 (SCHEME(_,(_,SOME(instance,_)))) = 
                    SOME instance
                  | fetch_instance1 (UNBOUND_SCHEME(_,SOME(instance,_))) = 
                    SOME instance
                  | fetch_instance1 _ = NONE

                fun fetch_instance2 (SCHEME(_,(_,SOME(_,instance')))) = 
                    SOME instance'
                  | fetch_instance2 (UNBOUND_SCHEME(_,SOME(_,instance'))) = 
                    SOME instance'
                  | fetch_instance2 _ = NONE

                fun make_instance_info (NO_INSTANCE) = ZERO
                  | make_instance_info (INSTANCE(instances)) = ONE (length instances)
                  | make_instance_info _ = Crash.impossible "make_instance_info:instantiate:realise"

              in
                case entry of
                  SOME scheme' => 
                    (* We have found a scheme *)
                    let
                      val scheme_generalises = 
                        (Scheme.scheme_generalises options (valid,completion_env,level,scheme,scheme')
                         handle Scheme.EnrichError s => (error [s];false),
                         need_coerce)

                      val instance_index = 
                        case fetch_instance1 scheme' of
                          SOME (ref (INSTANCE ((ref(_,_,instances))::_))) => 
                            (case instances of
                               INSTANCE (instances) => SOME (length instances)
                             | _ => NONE)
                        | _ => NONE
                      val _ =
                        case (fetch_instance2 scheme, fetch_instance2 scheme') of
                          (SOME instance, SOME instance') => 
                            (* Side effect the second instance ref in the signature scheme *)
                            (* The idea seems to be that this tells how to get to the actual structure *)
                            (* despite the signature constraint *)
                            instance :=  
                            (case !instance' of 
                               NONE =>
                                 (case fetch_instance1 scheme' of
                                    SOME (ref (INSTANCE ((ref (_,_,instances))::_))) => 
                                      (* Make a SIGNATURE_INSTANCE *)
                                      SOME (ref (SIGNATURE_INSTANCE (make_instance_info instances)))
                                  | SOME (ref(NO_INSTANCE)) =>  
                                      SOME (ref (NO_INSTANCE))
                                  | _ => 
                                      Crash.impossible "1:instance:ran_enriches:realise")
                             | SOME (ref (instance' as SIGNATURE_INSTANCE _)) => 
                                 SOME (ref instance')
                             | SOME (ref NO_INSTANCE) =>  
                                 SOME (ref NO_INSTANCE)
                             | _ => 
                                 Crash.impossible "2:instance:ran_enriches:realise")
                        | _ => ()
                    in
                      (scheme_generalises, instance_index)
                    end
                | NONE =>
                    (error [case valid of
			      IdentPrint.Ident.EXCON _ => "Missing exception "
			    | _ => "Missing value ",
                            IdentPrint.printValId print_options valid,
                            " in structure ",
			    string_strids' strids];
                     ((false, false), NONE))
              end

	    fun accumulator ((res,coerce,debugger_str), valid, scheme) =
	      let val ((res', coerce'), instance) = ran_enriches (valid, scheme)
	      in (res andalso res',
		  coerce orelse coerce',
                  NewMap.define(debugger_str,valid,instance))
	      end
          in
	    NewMap.fold accumulator ((true, false, NewMap.empty (Ident.valid_lt, Ident.valid_eq)), amap)
          end
        
        exception TyfunError
        exception TypeDiffer

        (****
         Enrichment test for type structures.  See p. 34 of The Definition.
         ****)

        fun tystr_enriches (tycon,TYSTR (tyfun,conenv),TYSTR (tyfun',conenv')) = 
          if Types.tyfun_eq (tyfun,tyfun') 
            then
              if Valenv.empty_valenvp conenv orelse Valenv.valenv_eq(conenv,conenv') 
                then true
              else
		(if Valenv.dom_valenv_eq(conenv,conenv') then
		   () (* Don't report this error if domains the same *)
		 else
		   let
		     fun string_conenv (VE (_,amap)) =
		       let 
			 fun print_spaces (res, n) =
			   if n = 0 then concat(" " :: res)
			   else print_spaces (" " :: res, n-1)
		       in
			 NewMap.string (IdentPrint.printValId print_options) (fn _ => "")
			 {start = "", domSep = "", itemSep = ", ", finish = ""}
			 (NewMap.map (fn (id,sch)=>sch) amap)
		       end
		   in
		     error ["Type ", IdentPrint.printTyCon tycon,  " has different constructors in structure and signature:\n",
			    "  Structure: ", string_conenv conenv', "\n",
			    "  Signature: ", string_conenv conenv]
		   end;
		   false)
          else raise TyfunError

        (****
         Enrichment test for type environments.
         ****)
       
        fun te_ran_enriches(TE amap,TE amap', strids) =
          let 
            fun ran_enriches(tycon,tystr) =
              (let
                val tystr' = NewMap.apply'(amap', tycon)
              in
                (tystr_enriches (tycon,tystr,tystr'))
                handle TypeDiffer => false
              end
              (* these may happen if realisation has failed, so just return false *)
              handle NewMap.Undefined => false (* Crash.impossible "Missing type in enrich" *)
                   | TyfunError => false (* Crash.impossible "Type clash in enrich" *))
                       
          in
            eforall ran_enriches amap
          end
        
        (****
         Enrichment test for environments. (See p. 34 of The Definition)
         ****)

        fun env_enriches (level,
                          ENV (se as SE se_map,te,ve),
                          ENV (se' as SE se_map',te',ve'), 
                          DSTR(debugger_str1,debugger_str2,_),
			  strids) = 
	  let
	    val (res1, coerce1, debugger_str1) =
	      se_ran_enriches (level,se,se',debugger_str1, strids)
	    val res2 = te_ran_enriches (te,te', strids)
            val (res3, coerce3, debugger_str) =
	      ve_ran_enriches(level,ve,ve', strids)
	  in
	    (res1 andalso res2 andalso res3, coerce1 orelse coerce3,
             DSTR(debugger_str1,debugger_str2,debugger_str))
	  end
          | env_enriches _ = Crash.impossible "EMPTY_DSTR:env_enriches:realise"

        and str_enriches (level,str,str',debugger_str, strids) =
          let
            val (strname,env) = get_name_and_env ("str_enriches1",str)
	    val (strname',env') = get_name_and_env ("str_enriches2",str')
          in
            (* does this need an error message? *)
            if Strnames.strname_eq (strname,strname') then
              env_enriches (level,env,env',debugger_str, strids)
	    else
	      (false, false, debugger_str)
          end
        
        and se_ran_enriches (level,SE amap,SE amap',debugger_str, strids) = 
          let 
            fun ran_enriches(strid, str) =
              case (NewMap.tryApply'(amap', strid),
                    NewMap.tryApply'(debugger_str, strid)) of
                (SOME str',SOME debugger_str) => 
                  str_enriches (level,str,str',debugger_str, strid :: strids)
              (* this may happen if realisation has failed, so just return false *)
              | (_,_) => (false, false, Datatypes.EMPTY_DSTR)


            fun accumulator ((res,coerce,debugger_str), valid, scheme) =
              let val (res', coerce',debugger_str') = ran_enriches (valid, scheme)
              in (res andalso res',
                  coerce orelse coerce',
                  NewMap.define(debugger_str,valid,debugger_str'))
              end
          in
            NewMap.fold accumulator ((true, false, NewMap.empty (Ident.strid_lt, Ident.strid_eq)), amap)
          end
        
         (* Returns false if and only if the final case fails. This used
         to be raise TyfunEq *)

        fun make_eta_tyfun(tyfun as TYFUN(CONSTYPE(types, tyname), i)) =
          if Types.tyname_arity tyname = i andalso Types.check_debruijns(types, 0) 
            then ETA_TYFUN (tyname)
          else tyfun
          | make_eta_tyfun tyfun = tyfun

        fun tystr_realise (TYSTR (tyfun,ve as VE (_,amap)),
                           TYSTR (tyfun',ve' as VE (_,amap')),
                           tycon,
                           strids) =
        let
          fun fetch_nulltyfun(tyf as ref(NULL_TYFUN _)) = tyf
            | fetch_nulltyfun(ref(ETA_TYFUN(METATYNAME{1=tyfun, ...}))) =
              fetch_nulltyfun tyfun
            | fetch_nulltyfun _ = Crash.impossible "fetch_nulltyfun:realise"
          val tyfun = make_eta_tyfun tyfun
          val tyfun' = make_eta_tyfun tyfun'
        in
          (case Types.tyfun_eq (tyfun, tyfun') of
             true => (true,
                      if Types.null_tyfunp tyfun' then ~2
                      else
                        if generate_moduler then Types.update_tyfun_instantiations tyfun'
                        else 0)
           | false => 
          (if Types.null_tyfunp tyfun then
             let
               val tyname = Types.meta_tyname tyfun
               val (t, eq, name) = case tyname of
                 METATYNAME (t,name,_,ref eq, _, _) => (t, eq, name)
               | _ => Crash.impossible"bad Types.meta_tyname tyfun"
               (* record implementation of type function for debugger *)
               val (ntf,id) = 
		 let
		   val ntf = 
		     case fetch_nulltyfun(t) of
		       tf as ref(NULL_TYFUN(id,tyf)) => 
			 ((if generate_moduler then ()
			   else ()(*tyf := tyfun'*);
			     (* Above removed because it generates circular tyfuns *)
			     (* This is a bug in the debugger which needs fixing *)
			     if generate_moduler then Types.update_tyfun_instantiations tyfun'
			     else 0),id)
		     | _ => (dummy_tf, 0) (* Highly dubious!! *) (* Uses Stamp.Stamp = int sharing *)
		 in
		   ntf
		 end

             in
               if Nameset.member_of_tynames (tyname,!nameset_ref) then
                 if Types.arity tyfun = Types.arity tyfun' then
                   if (Types.equalityp tyfun' orelse not eq) then
                     (t := tyfun';
                      if Types.null_tyfunp tyfun' andalso
                        Nameset.member_of_tynames
			  (Types.meta_tyname tyfun',!nameset_ref)
                        then remove_tyname tyname
                      else ();
                        (true,ntf))
                   else
                     (error ["Type ",
                             string_strids strids,
                             IdentPrint.printTyCon tycon,
                             " in structure does not admit equality"];
                     t := tyfun';
                     (false,ntf))
                 else
                   (error ["Number of parameters of type constructor ",
                           string_strids strids,
                           IdentPrint.printTyCon tycon,
                           " differ in signature and structure"];
(*
		   output(std_out, "tyfun = " ^ Types.string_tyfun tyfun ^
			  "\ntyfun' = " ^ Types.string_tyfun tyfun' ^ "\n");
*)
		   t := tyfun';
                   (false,ntf))
               else
                 (error ["Type sharing violation for ",
                         string_strids strids,
                         IdentPrint.printTyCon tycon];
                  (false,ntf))
             end
           else
              (true,dummy_tf)))
        end
         
        and se_realise (SE amap,se',strids) =
          let
            fun strname_map(strid,str) =
              case Strenv.lookup (strid,se') of 
                SOME str' => str_realise(str,str',strid::strids)
              | _ => 
                  (error ["Missing substructure ",
                          IdentPrint.printStrId strid,
			  " in structure ",
                          string_strids' strids];
                   (false, Datatypes.EMPTY_DSTR))
            val strname_map = NewMap.map strname_map amap
            val debugger_str = NewMap.map (fn (_,(_,str))=>str) strname_map
          in
            (NewMap.fold (fn (b',_,(b,_)) => b' andalso b) (true,strname_map), debugger_str)
          end

        and te_realise (TE amap,te',strids) =
          let 
            fun tyname_map(tycon, sig_tystr) =
              let
                val str_tystr = Tyenv.lookup (te', tycon)
              in
                tystr_realise (sig_tystr,str_tystr, tycon,strids)
              end
            handle Tyenv.LookupTyCon _ =>
              (error ["Missing type constructor ",
                      IdentPrint.printTyCon tycon,
		      " in structure ",
                      string_strids' strids];
               (false,dummy_tf))
            val tyname_map = NewMap.map tyname_map amap
            val debugger_str = NewMap.map (fn (_,(_,n))=>n) tyname_map
          in
            (NewMap.fold (fn (b',_,(b,_)) => b' andalso b) (true,tyname_map), debugger_str)
          end

        and env_realise (ENV (se,te,_),ENV (se',te',_),strids) =
          let
            val (se_realise, debugger_str') = se_realise (se,se',strids)
            val (te_realise, debugger_str) = te_realise (te,te',strids)
          in
            (se_realise andalso te_realise,
             DSTR(debugger_str',debugger_str,
                NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
          end
 
        and str_realise (str1,str2,strids) =
          let
            (* These structures should be fully expanded already *)
            (* So a Bind exn should be impossible *)
	    val (name,env) = get_name_and_env ("str_realise1",str1)
            val (name',env') = get_name_and_env ("str_realise2",str2)
            val name = Strnames.strip name
          in
            case name of
              METASTRNAME r =>
                if
                  Strnames.uninstantiated name' andalso 
                  Strnames.metastrname_eq (name,name')
                  then
                    env_realise (env,env',strids)
                else
                  let
                    val result = 
                      let
                        val (env_realise, debugger_str) = env_realise (env,env',strids)
                      in
                        if env_realise then
                          if Nameset.member_of_strnames (name,!nameset_ref)
                            then
                              (true, debugger_str) 
                          else
                            (error["Structure sharing violation for ",
                                   (case strids of
                                      [] => "impossible type error 13: top level structure"
                                    | _ => string_strids' strids)];
                            (false, debugger_str))
                        else
                          (* error will already be reported by env_realise *)
                          (false, debugger_str)
                      end
                  in
                    if Nameset.member_of_strnames (name',!nameset_ref)
                      then
                        (r := name';
                         result)
                    else
                      (r := name';
                       remove_strname name;
                       result)
                  end
            | _ =>
                if Strnames.strname_eq (name,name') then
                  env_realise (env,env',strids)
                else 
                  (error["Structure sharing violation for ",
                         (case strids of
                            [] => "impossible type error 14: top level structure"
                          | _ => string_strids' strids)];
                  (false,Datatypes.EMPTY_DSTR))
          end

        fun tystr_check (TYSTR (tyfun,ve as VE (_,amap)),
                         TYSTR (tyfun',ve' as VE (_,amap')),
                         tycon,
                         strids) =
          let
            val tyfun = make_eta_tyfun tyfun
            val tyfun' = make_eta_tyfun tyfun'
          in
            if Types.tyfun_eq (tyfun, tyfun')
              then true
            else
              (error ["Type sharing violation for ",
                      string_strids strids,
                      IdentPrint.printTyCon tycon(*,
                      "<", Types.string_tyfun tyfun, ",",Types.string_tyfun tyfun',">"*)];
               false)
          end
         
        and se_check (SE amap,se',strids) =
          let
            fun check (b,strid,str) =
              case Strenv.lookup (strid,se') of 
                SOME str' => str_check(str,str',strid::strids) andalso b
              | _ => b
          in
            NewMap.fold check (true,amap)
          end

        and te_check (TE amap,te',strids) =
          let 
            fun check_tyname (tycon, sig_tystr) =
              let
                val str_tystr = Tyenv.lookup (te', tycon)
              in
                tystr_check (sig_tystr,str_tystr, tycon,strids)
              end
            handle Tyenv.LookupTyCon _ => true
            val check_result = NewMap.map check_tyname amap
          in
            NewMap.fold (fn (b',_,b) => b' andalso b) (true,check_result)
          end

        and env_check (ENV (se,te,_),ENV (se',te',_),strids) =
          let
            val se_check = se_check (se,se',strids)
            val te_check = te_check (te,te',strids)
          in
            se_check andalso te_check
          end
 
        and str_check (str1,str2,strids) =
          let
	    val (name,env) = get_name_and_env ("str_check1",str1)
            val (name',env') = get_name_and_env ("str_check2",str2)
          in
            env_check (env,env',strids)
          end

	(* str_realise must be called before str_enriches *)
	val (res1, debugger_str) = str_realise (str,str',[])
	val res2 = str_check (str,str',[])
	val (res3, coerce, debugger_str) =
	  str_enriches (level,str,str',debugger_str, [])
      in
        (res1 andalso res2 andalso res3, coerce, debugger_str)
      end
  end




@


1.61.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.61  1996/10/29  13:50:31  io
 * [Bug #1614]
 * basifying String
 *
@


1.61.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.61  1996/10/29  13:50:31  io
 * [Bug #1614]
 * basifying String
 *
@


1.61.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.61  1996/10/29  13:50:31  io
 * [Bug #1614]
 * basifying String
 *
@


1.61.5.1
log
@branched from 1.61
@
text
@a2 4
 * Revision 1.61  1996/10/29  13:50:31  io
 * [Bug #1614]
 * basifying String
 *
@


1.61.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.61.5.1  1997/05/12  10:52:00  hope
 * branched from 1.61
 *
@


1.61.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.61.5.1  1997/05/12  10:52:00  hope
 * branched from 1.61
 *
@


1.61.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.61.5.1  1997/05/12  10:52:00  hope
 * branched from 1.61
 *
@


1.61.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.61.5.1.1.1  1997/07/28  18:33:48  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.61.4.1
log
@branched from 1.61
@
text
@a2 4
 * Revision 1.61  1996/10/29  13:50:31  io
 * [Bug #1614]
 * basifying String
 *
@


1.61.3.1
log
@branched from 1.61
@
text
@a2 4
 * Revision 1.61  1996/10/29  13:50:31  io
 * [Bug #1614]
 * basifying String
 *
@


1.61.3.1.1.1
log
@branched from 1.61.3.1
@
text
@a2 3
 * Revision 1.61.3.1  1996/12/17  18:18:28  hope
 * branched from 1.61
 *
@


1.61.2.1
log
@branched from 1.61
@
text
@a2 4
 * Revision 1.61  1996/10/29  13:50:31  io
 * [Bug #1614]
 * basifying String
 *
@


1.61.1.1
log
@branched from 1.61
@
text
@a2 4
 * Revision 1.61  1996/10/29  13:50:31  io
 * [Bug #1614]
 * basifying String
 *
@


1.61.1.1.1.1
log
@branched from 1.61.1.1
@
text
@a2 3
 * Revision 1.61.1.1  1996/11/14  13:21:58  hope
 * branched from 1.61
 *
@


1.60
log
@Fix problem with compiler looping
@
text
@d3 3
d260 1
a260 1
      String.implode (map (fn s => IdentPrint.printStrId s ^ ".")(rev strids))
d300 1
a300 1
          Info.error error_info (Info.RECOVERABLE,location,String.implode message_list)
d328 1
a328 1
		    MLWorks.Option.NONE =>
d334 1
a334 1
		       | _ => (MLWorks.Option.NONE, false))
d341 11
a351 11
                fun fetch_instance1 (SCHEME(_,(_,MLWorks.Option.SOME(instance,_)))) = 
                    MLWorks.Option.SOME instance
                  | fetch_instance1 (UNBOUND_SCHEME(_,MLWorks.Option.SOME(instance,_))) = 
                    MLWorks.Option.SOME instance
                  | fetch_instance1 _ = MLWorks.Option.NONE

                fun fetch_instance2 (SCHEME(_,(_,MLWorks.Option.SOME(_,instance')))) = 
                    MLWorks.Option.SOME instance'
                  | fetch_instance2 (UNBOUND_SCHEME(_,MLWorks.Option.SOME(_,instance'))) = 
                    MLWorks.Option.SOME instance'
                  | fetch_instance2 _ = MLWorks.Option.NONE
d354 1
a354 1
                  | make_instance_info (INSTANCE(instances)) = ONE (Lists.length(instances))
d359 1
a359 1
                  MLWorks.Option.SOME scheme' => 
d369 1
a369 1
                          MLWorks.Option.SOME (ref (INSTANCE ((ref(_,_,instances))::_))) => 
d371 3
a373 3
                               INSTANCE (instances) => MLWorks.Option.SOME(Lists.length(instances))
                             | _ => MLWorks.Option.NONE)
                        | _ => MLWorks.Option.NONE
d376 1
a376 1
                          (MLWorks.Option.SOME instance, MLWorks.Option.SOME instance') => 
d382 1
a382 1
                               MLWorks.Option.NONE =>
d384 1
a384 1
                                    MLWorks.Option.SOME (ref (INSTANCE ((ref (_,_,instances))::_))) => 
d386 3
a388 3
                                      MLWorks.Option.SOME (ref (SIGNATURE_INSTANCE (make_instance_info instances)))
                                  | MLWorks.Option.SOME(ref(NO_INSTANCE)) =>  
                                      MLWorks.Option.SOME (ref (NO_INSTANCE))
d391 4
a394 4
                             | MLWorks.Option.SOME (ref (instance' as SIGNATURE_INSTANCE _)) => 
                                 MLWorks.Option.SOME (ref instance')
                             | MLWorks.Option.SOME (ref NO_INSTANCE) =>  
                                 MLWorks.Option.SOME (ref NO_INSTANCE)
d401 1
a401 1
                | MLWorks.Option.NONE =>
d408 1
a408 1
                     ((false, false), MLWorks.Option.NONE))
d441 1
a441 1
			   if n = 0 then String.implode(" " :: res)
d515 1
a515 1
                (MLWorks.Option.SOME str',MLWorks.Option.SOME debugger_str) => 
d625 1
a625 1
                MLWorks.Option.SOME str' => str_realise(str,str',strid::strids)
d746 1
a746 1
                MLWorks.Option.SOME str' => str_check(str,str',strid::strids) andalso b
@


1.59
log
@Remove the esoteric type sharing violation 2 message
@
text
@d3 3
d564 14
a577 12
                   let
                     val ntf = 
                       case fetch_nulltyfun(t) of
                         tf as ref(NULL_TYFUN(id,tyf)) => 
                           ((if generate_moduler then ()
                             else tyf := tyfun';
                               if generate_moduler then Types.update_tyfun_instantiations tyfun'
                               else 0),id)
                       | _ => (dummy_tf, 0) (* Highly dubious!! *) (* Uses Stamp.Stamp = int sharing *)
                   in
                     ntf
                   end
@


1.59.3.1
log
@branched from 1.59
@
text
@a2 3
 * Revision 1.59  1996/06/04  11:45:53  jont
 * Remove the esoteric type sharing violation 2 message
 *
@


1.59.2.1
log
@branched from 1.59
@
text
@a2 3
 * Revision 1.59  1996/06/04  11:45:53  jont
 * Remove the esoteric type sharing violation 2 message
 *
@


1.59.1.1
log
@branched from 1.59
@
text
@a2 3
 * Revision 1.59  1996/06/04  11:45:53  jont
 * Remove the esoteric type sharing violation 2 message
 *
@


1.58
log
@Attempting to fix problem with where type
@
text
@d3 3
d727 1
a727 1
              (error ["Type sharing violation 2 for ",
@


1.57
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d607 1
a607 5
             (* it would be nice to indicate what the original sharing was here *)
             (error ["Type sharing violation for ",
                     string_strids strids,
                     IdentPrint.printTyCon tycon];
              (false,dummy_tf))))
d711 60
a770 1
          end(* handle Bind => Crash.impossible "unexpanded structure in str_realise"*)
d773 2
a774 1
	val (res2, coerce, debugger_str) =
d777 1
a777 1
        (res1 andalso res2, coerce, debugger_str)
d780 4
@


1.56
log
@Language revisions
@
text
@d3 3
d245 1
a245 1
      implode (map (fn s => IdentPrint.printStrId s ^ ".")(rev strids))
d285 1
a285 1
          Info.error error_info (Info.RECOVERABLE,location,implode message_list)
d426 1
a426 1
			   if n = 0 then implode(" " :: res)
@


1.55
log
@Removing Option in favour of MLWorks.Option
@
text
@d3 3
d206 2
d229 1
a229 1
  sharing type Types.Datatypes.Stamp = int
@


1.54
log
@Improved error reporting for missing values, types, substructures
during signature matching
@
text
@d3 4
d318 11
a328 11
                fun fetch_instance1 (SCHEME(_,(_,Option.PRESENT(instance,_)))) = 
                    Option.PRESENT instance
                  | fetch_instance1 (UNBOUND_SCHEME(_,Option.PRESENT(instance,_))) = 
                    Option.PRESENT instance
                  | fetch_instance1 _ = Option.ABSENT

                fun fetch_instance2 (SCHEME(_,(_,Option.PRESENT(_,instance')))) = 
                    Option.PRESENT instance'
                  | fetch_instance2 (UNBOUND_SCHEME(_,Option.PRESENT(_,instance'))) = 
                    Option.PRESENT instance'
                  | fetch_instance2 _ = Option.ABSENT
d346 1
a346 1
                          Option.PRESENT (ref (INSTANCE ((ref(_,_,instances))::_))) => 
d348 3
a350 3
                               INSTANCE (instances) => Option.PRESENT(Lists.length(instances))
                             | _ => Option.ABSENT)
                        | _ => Option.ABSENT
d353 1
a353 1
                          (Option.PRESENT instance, Option.PRESENT instance') => 
d359 1
a359 1
                               Option.ABSENT =>
d361 1
a361 1
                                    Option.PRESENT (ref (INSTANCE ((ref (_,_,instances))::_))) => 
d363 3
a365 3
                                      Option.PRESENT (ref (SIGNATURE_INSTANCE (make_instance_info instances)))
                                  | Option.PRESENT(ref(NO_INSTANCE)) =>  
                                      Option.PRESENT (ref (NO_INSTANCE))
d368 4
a371 4
                             | Option.PRESENT (ref (instance' as SIGNATURE_INSTANCE _)) => 
                                 Option.PRESENT (ref instance')
                             | Option.PRESENT (ref NO_INSTANCE) =>  
                                 Option.PRESENT (ref NO_INSTANCE)
d385 1
a385 1
                     ((false, false), Datatypes.Option.ABSENT))
@


1.53
log
@Only report constructors different when the domains differ
@
text
@d3 3
d292 1
a292 1
        fun ve_ran_enriches (level,ve as VE (_,amap),ve' as VE (_,amap')) =
d294 1
a294 1
            fun ran_enriches (valid, scheme) =
d379 2
a380 1
                            " in structure"];
d433 1
a433 1
        fun te_ran_enriches (TE amap,TE amap') =
d457 2
a458 1
                          DSTR(debugger_str1,debugger_str2,_)) = 
d460 5
a464 3
	    val (res1, coerce1, debugger_str1) = se_ran_enriches (level,se,se',debugger_str1)
	    val res2 = te_ran_enriches (te,te')
            val (res3, coerce3, debugger_str) = ve_ran_enriches (level,ve,ve')
d471 1
a471 1
        and str_enriches (level,str,str',debugger_str) =
d478 1
a478 1
              env_enriches (level,env,env',debugger_str)
d483 1
a483 1
        and se_ran_enriches (level,SE amap,SE amap',debugger_str) = 
d489 1
a489 1
                  str_enriches (level,str,str',debugger_str)
d602 4
a605 3
                  (error ["Missing substructure in structure: ",
                          string_strids strids,
                          IdentPrint.printStrId strid];
d622 4
a625 3
              (error ["Missing type constructor in structure: ",
                      string_strids strids,
                      IdentPrint.printTyCon tycon];
d700 2
a701 1
	val (res2, coerce, debugger_str) = str_enriches (level,str,str',debugger_str)
@


1.52
log
@Fixing silent error for inconsistent valenvs
@
text
@d3 3
d403 20
a422 17
                let
                  fun string_conenv (VE (_,amap)) =
                    let 
                      fun print_spaces (res, n) =
                        if n = 0 then implode(" " :: res)
                        else print_spaces (" " :: res, n-1)
                    in
                      NewMap.string (IdentPrint.printValId print_options) (fn _ => "")
                      {start = "", domSep = "", itemSep = ", ", finish = ""}
                      (NewMap.map (fn (id,sch)=>sch) amap)
                    end
                in
                  (error ["Type ", IdentPrint.printTyCon tycon,  " has different constructors in structure and signature:\n",
                          "  Structure: ", string_conenv conenv', "\n",
                          "  Signature: ", string_conenv conenv];
                  false)
                end
@


1.51
log
@Fixed bug in tystr_realise - it was testing for equality before
checking that the tyfun was in the nameset, which led to an error
message about equality instead of type sharing.
@
text
@d3 5
d394 1
a394 1
        fun tystr_enriches (TYSTR (tyfun,conenv),TYSTR (tyfun',conenv')) = 
d399 18
a416 1
              else raise TypeDiffer
d429 1
a429 1
                (tystr_enriches (tystr,tystr'))
@


1.50
log
@Use Stamp instead of Tyname_id etc.
@
text
@d3 3
d519 10
a528 10
               if Types.arity tyfun = Types.arity tyfun' then
                 if (Types.equalityp tyfun' orelse not eq) then
                   if Nameset.member_of_tynames (tyname,!nameset_ref)
                     then
                       (t := tyfun';
                        if Types.null_tyfunp tyfun' andalso
                          Nameset.member_of_tynames (Types.meta_tyname tyfun',!nameset_ref)
                          then remove_tyname tyname
                        else ();
                          (true,ntf))
d530 6
a535 4
                        (error ["Type sharing violation for ",
                                string_strids strids,
                                IdentPrint.printTyCon tycon];
                         (false,ntf))
d537 1
a537 1
                   (error ["Type ",
d540 6
a545 2
                           " in structure does not admit equality"];
                   t := tyfun';
d548 1
a548 1
                 (error ["Number of parameters of type constructor ",
d550 2
a551 8
                         IdentPrint.printTyCon tycon,
                         " differ in signature and structure"];
(*
		 output(std_out, "tyfun = " ^ Types.string_tyfun tyfun ^
			"\ntyfun' = " ^ Types.string_tyfun tyfun' ^ "\n");
*)
		 t := tyfun';
                 (false,ntf))
@


1.49
log
@Rationalizations
@
text
@d3 3
d206 1
a206 1
  sharing type Types.Datatypes.Tyfun_id.Tyfun_id = int
d244 6
d510 1
a510 1
                       | _ => (dummy_tf,Datatypes.Tyfun_id.make_tyfun_n 0)
@


1.48
log
@Rationalizing debugger
@
text
@d3 3
a176 1
require "tystr";
a192 1
  structure Tystr     : TYSTR
d200 1
a200 1
    = Strenv.Datatypes = Tystr.Datatypes = Valenv.Datatypes = Nameset.Datatypes
d370 15
d395 2
a396 4
                (Tystr.tystr_enriches (tystr,tystr'))
                handle 
                Tystr.TypeDiffer => 
                  false
d400 1
a400 1
                   | Tystr.TyfunError => false (* Crash.impossible "Type clash in enrich" *))
d552 7
a558 6
              str_realise(str,Strenv.lookup (strid,se'),strid::strids)
              handle Strenv.Lookup_in_SE =>
                (error ["Missing substructure in structure: ",
                        string_strids strids,
                        IdentPrint.printStrId strid];
                 (false, Datatypes.EMPTY_DSTR))
d573 1
a573 1
            handle Tyenv.Lookup_in_TE =>
@


1.47
log
@Use pervasive Option.option for return values in NewMap
@
text
@d3 3
a166 1
require "ty_debug";
a183 1
  structure Ty_Debug  : TY_DEBUG
a194 5
  structure Debug :
    sig
      val set_debug_level : int -> unit
      val debug_level : unit -> int
    end
d272 5
a276 5
	        (* Use polymorphic equality, so that constructor status
	           is compared. *)
                val entry = NewMap.tryApply'Eq(amap', valid)
		val (entry', need_coerce) =
		  case entry of
d279 1
a279 1
			 It can be matched by a constructor in the structure. *)
d284 2
a285 1
		  | x => (x, false)
d289 17
a305 13
                fun fetch_instance(SCHEME(_,(_,Option.PRESENT(instance,_)))) = 
                    Option.PRESENT(instance)
                  | fetch_instance(UNBOUND_SCHEME(_,Option.PRESENT(instance,_))) = 
                    Option.PRESENT(instance)
                  | fetch_instance _ = Option.ABSENT
                fun fetch_instance'(SCHEME(_,(_,Option.PRESENT(_,instance')))) = 
                    Option.PRESENT(instance')
                  | fetch_instance'(UNBOUND_SCHEME(_,Option.PRESENT(_,instance'))) = 
                    Option.PRESENT(instance')
                  | fetch_instance' _ = Option.ABSENT
                fun length (NO_INSTANCE) = nil
                  | length (INSTANCE(instances)) = [(Lists.length(instances))]
                  | length _ = Crash.impossible "length:instantiate:realise"
d307 3
a309 2
                case entry' of
                  MLWorks.Option.SOME (scheme') => 
d312 7
a318 11
                        (Scheme.scheme_generalises options 
                        (valid,completion_env,level,scheme,scheme')
                        handle Scheme.EnrichError s =>
                          (error [s];
                           false),
                          need_coerce)
                      val (instance'1,instance'2) = (fetch_instance' scheme, 
                                                     fetch_instance' scheme')
                      val instance' = 
                        case fetch_instance scheme' of
                          Option.PRESENT(ref(INSTANCE((ref(_,_,instances))::_))) => 
d320 1
a320 1
                               INSTANCE(instances) => Option.PRESENT(Lists.length(instances))
d323 24
d348 1
a348 21
                     ((case (instance'1,instance'2) of
                         (Option.PRESENT(instance),
                          Option.PRESENT(instance')) => 
                         instance :=
                         (case !instance' of 
                            Option.ABSENT =>
                              (case fetch_instance scheme' of
                                 Option.PRESENT(ref(INSTANCE((ref(_,_,instances))::_))) => 
                                   Option.PRESENT(ref(SIGNATURE_INSTANCE(length instances)))
                               | Option.PRESENT(ref(NO_INSTANCE)) =>  
                                   Option.PRESENT(ref(NO_INSTANCE))
                               | _ => 
                                   Crash.impossible "1:instance:ran_enriches:realise")
                          | Option.PRESENT(ref(instance' as SIGNATURE_INSTANCE(_))) => 
                              Option.PRESENT(ref(instance'))
                          | Option.PRESENT(ref(NO_INSTANCE)) =>  
                              Option.PRESENT(ref(NO_INSTANCE))
                          | _ => 
                              Crash.impossible "2:instance:ran_enriches:realise")
                        | _ => ());
                         (scheme_generalises, instance'))
@


1.46
log
@Fix make_eta_tyfun to preserve arity
@
text
@d3 3
d281 1
a281 1
		    NewMap.NO =>
d287 1
a287 1
		       | _ => (NewMap.NO, false))
d307 1
a307 1
                  NewMap.YES (scheme') => 
d348 1
a348 1
                | NewMap.NO =>
d425 2
a426 2
                (NewMap.YES str',
                 NewMap.YES debugger_str) => str_enriches (level,str,str',debugger_str)
@


1.45
log
@Remove Bind handler
@
text
@d3 3
d441 2
a442 2
        fun make_eta_tyfun(tyfun as TYFUN(CONSTYPE(types, tyname), _)) =
          if Types.check_debruijns(types, 0) 
d514 6
a519 2
                         "differ in signature and structure"];
                 t := tyfun';
@


1.44
log
@Debugger structures for Modules Debugger.
@
text
@d3 3
d621 1
a621 1
          end handle Bind => Crash.impossible "unexpanded structure in str_realise"
@


1.43
log
@Greater care over the set of free names -- ensure functor parameters
don't get overwritten.
Check freeness of tynames before overwriting also
@
text
@d3 5
d197 1
d222 3
d229 3
a231 3
      (error_info,options as Options.OPTIONS{print_options,
                     compiler_options = Options.COMPILEROPTIONS{debug_variables,
                                                                debug_polyvariables,...}, ...})
d283 5
a287 8
                fun fetch_instance(SCHEME(_,(_,Option.ABSENT))) = 
                    Crash.impossible "1:fetch_instance:ran_enriches:realise"
                  | fetch_instance(UNBOUND_SCHEME(_,Option.ABSENT)) = 
                    Crash.impossible "2:fetch_instance:ran_enriches:realise"
                  | fetch_instance(SCHEME(_,(_,Option.PRESENT(instance,_)))) = instance
                  | fetch_instance(UNBOUND_SCHEME(_,Option.PRESENT(instance,_))) = instance
                  | fetch_instance _ = 
                    Crash.impossible "3:fetch_instance:ran_enriches:realise"
d309 7
d324 1
a324 1
                                 ref(INSTANCE((ref(_,_,instances))::_)) => 
d326 1
a326 1
                               | ref(NO_INSTANCE) =>  
d337 1
a337 1
                      scheme_generalises)
d345 1
a345 1
                     (false, false))
d348 2
a349 2
	    fun accumulator ((res,coerce), valid, scheme) =
	      let val (res', coerce') = ran_enriches (valid, scheme)
d351 2
a352 1
		  coerce orelse coerce')
d355 1
a355 1
	    NewMap.fold accumulator ((true, false), amap)
d385 4
a388 2
        fun env_enriches (level,ENV (se as SE se_map,te,ve),
                          ENV (se' as SE se_map',te',ve')) = 
d390 1
a390 1
	    val (res1, coerce1) = se_ran_enriches (level,se,se')
d392 1
a392 1
            val (res3, coerce3) = ve_ran_enriches (level,ve,ve')
d394 2
a395 1
	    (res1 andalso res2 andalso res3, coerce1 orelse coerce3)
d397 1
d399 1
a399 1
        and str_enriches (level,str,str') =
d406 1
a406 1
              env_enriches (level,env,env')
d408 1
a408 1
	      (false, false)
d411 1
a411 1
        and se_ran_enriches (level,SE amap,SE amap') = 
d414 4
a417 2
              case NewMap.tryApply'(amap', strid) of
                NewMap.YES str' => str_enriches (level,str,str')
d419 1
a419 1
              | _ => (false, false)
d422 2
a423 2
            fun accumulator ((res,coerce), valid, scheme) =
              let val (res', coerce') = ran_enriches (valid, scheme)
d425 2
a426 1
                  coerce orelse coerce')
d429 1
a429 1
            NewMap.fold accumulator ((true, false), amap)
d445 11
a455 40
          let
            val tyfun = make_eta_tyfun tyfun
            val tyfun' = make_eta_tyfun tyfun'
          in
            (Types.tyfun_eq (tyfun, tyfun') orelse
             (if Types.null_tyfunp tyfun then
                let
                  val tyname = Types.meta_tyname tyfun
                  val (t, eq) = case tyname of
                    METATYNAME (t,_,_,ref eq, _,_) => (t, eq)
                  | _ => Crash.impossible"bad Types.meta_tyname tyfun"
                  (* record implemetation of type function for debugger *)
                  val _ = 
                    if debug_variables orelse debug_polyvariables then 
                      let
                        fun fetch_nulltyfun(tyf as NULL_TYFUN _) = tyf
                          | fetch_nulltyfun(ETA_TYFUN(METATYNAME{1=ref tyfun, ...})) =
                            fetch_nulltyfun tyfun
                          | fetch_nulltyfun _ = Crash.impossible "fetch_nulltyfun:realise"
                        val _ = 
                          case fetch_nulltyfun(!t) of
                            NULL_TYFUN(_,Option.PRESENT(tyf)) => tyf := tyfun'
                          | NULL_TYFUN(_) => ()
                          | _ => ()
                      in
                        ()
                      end
                    else
                      ()
                in
                  if Types.arity tyfun = Types.arity tyfun' then
                    if (Types.equalityp tyfun' orelse not eq) then
                      if Nameset.member_of_tynames (tyname,!nameset_ref)
                        then
                          (t := tyfun';
                           if Types.null_tyfunp tyfun' andalso
                             Nameset.member_of_tynames (Types.meta_tyname tyfun',!nameset_ref)
                             then remove_tyname tyname
                           else ();
                           true)
d457 36
d496 23
a518 23
                         false)
                    else
                      (error ["Type ",
                              string_strids strids,
                              IdentPrint.printTyCon tycon,
                              " in structure does not admit equality"];
                      t := tyfun';
                      false)
                  else
                    (error ["Number of parameters of type constructor ",
                            string_strids strids,
                            IdentPrint.printTyCon tycon,
                            " differ in signature and structure"];
                    t := tyfun';
                    false)
                end
              else
                (* it would be nice to indicate what the original sharing was here *)
                (error ["Type sharing violation for ",
                        string_strids strids,
                        IdentPrint.printTyCon tycon];
                 false)))
          end
d528 3
a530 1
                 false)
d532 1
a532 1
            eforall strname_map amap
d547 3
a549 1
               false)
d551 1
a551 1
            eforall tyname_map amap
d555 9
a563 3
          aswell(se_realise (se,se',strids),
                 te_realise (te,te',strids))

d582 4
a585 2
                      if env_realise (env,env',strids)
                        then
d588 1
a588 1
                              true
d594 5
a598 4
                            false)
                      else
                        (* error will already be reported by env_realise *)
                        false
d617 1
a617 1
                  false)
d620 2
a621 2
	val res1 = str_realise (str,str',[])
	val (res2, coerce) = str_enriches (level,str,str')
d623 1
a623 1
        (res1 andalso res2, coerce)
@


1.42
log
@Fixup some error messages and inexhaustive bindings.
@
text
@d3 3
d226 8
d414 6
d424 67
a490 50
          (Types.tyfun_eq (tyfun, tyfun') orelse
          (if Types.null_tyfunp tyfun then
             let
               val (t, eq) = case Types.meta_tyname tyfun of
                 METATYNAME (t,_,_,ref eq, _,_) => (t, eq)
               | _ => Crash.impossible"bad Types.meta_tyname tyfun"
             (* record implemetation of type function for debugger *)
               val _ = 
                 if debug_variables orelse debug_polyvariables then 
                   let
                     fun fetch_nulltyfun(tyf as NULL_TYFUN _) = tyf
                       | fetch_nulltyfun(ETA_TYFUN(METATYNAME{1=ref tyfun, ...})) =
                         fetch_nulltyfun tyfun
                       | fetch_nulltyfun _ = Crash.impossible "fetch_nulltyfun:realise"
                     val _ = 
                       case fetch_nulltyfun(!t) of
                         NULL_TYFUN(_,Option.PRESENT(tyf)) => tyf := tyfun'
                       | NULL_TYFUN(_) => ()
                       | _ => ()
                   in
                     ()
                   end
                 else
                   ()
             in
               if Types.arity tyfun = Types.arity tyfun' then
                 if (Types.equalityp tyfun' orelse not eq) then
                   (t := tyfun';
                    true)
                 else
                   (error ["Type ",
                           string_strids strids,
                           IdentPrint.printTyCon tycon,
                           " in structure does not admit equality"];
                   t := tyfun';
                   false)
               else
                 (error ["Number of parameters of type constructor ",
                         string_strids strids,
                         IdentPrint.printTyCon tycon,
                         " differ in signature and structure"];
                 t := tyfun';
                 false)
             end
           else
             (* it would be nice to indicate what the original sharing was here *)
             (error ["Type sharing violation for ",
                     string_strids strids,
                     IdentPrint.printTyCon tycon];
              false)))
d492 1
a492 1
        and se_realise (names,SE amap,se',strids) =
d495 1
a495 1
              str_realise(names,str,Strenv.lookup (strid,se'),strid::strids)
d505 1
a505 1
        and te_realise (names,TE amap,te',strids) =
d522 3
a524 3
        and env_realise (names,ENV (se,te,_),ENV (se',te',_),strids) =
          aswell(se_realise (names,se,se',strids),
                 te_realise (names,te,te',strids))
d526 1
a526 1
        and str_realise (names,str1,str2,strids) =
d540 1
a540 1
                    env_realise (names,env,env',strids)
d544 1
a544 1
                      if env_realise (names,env,env',strids)
d546 1
a546 1
                          if Nameset.member_of_strnames (name,names)
d559 8
a566 2
                    r := name';
                    result
d570 1
a570 1
                  env_realise (names,env,env',strids)
d579 1
a579 1
	val res1 = str_realise (names,str,str',[])
@


1.41
log
@Marked certain error messages as "impossible".
@
text
@d3 3
a197 1
    val do_debug = Ty_Debug.do_debug
d212 3
d372 2
a373 2
            val (STR (strname, _, env)) = str
            val (STR (strname', _, env')) = str'
d447 1
a447 1
                         "differ in signature and structure"];
d496 2
a497 2
            val STR (name, _, env) = str1
            val STR (name', _, env') = str2
d516 1
a516 1
                            (error["structure sharing violation for ",
d532 1
a532 1
                  (error["structure sharing violation for ",
@


1.40
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d3 3
d513 1
a513 1
                                      [] => "top level structure"
d529 1
a529 1
                            [] => "top level structure"
@


1.39
log
@Signature and structure instances linking for polymorphic debugger.
@
text
@d3 3
d403 1
a403 1
                 METATYNAME (t,_,_,ref eq, _) => (t, eq)
@


1.38
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
new compiler option debug_variables.
@
text
@d3 5
d135 1
d154 1
d207 2
a208 1
                     compiler_options = Options.COMPILEROPTIONS{debug_variables,...}, ...})
d249 19
d271 2
d279 25
d402 1
d404 1
a404 1
                 if debug_variables then 
@


1.38.1.1
log
@Fork for bug fixing
@
text
@a2 5
Revision 1.38  1993/07/30  14:44:14  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
new compiler option debug_variables.

@


1.37
log
@Removed exception environments.
ve_ran_enriches now checks that the constructor status of valids matches
appropriately.  It returns a bool to indicate when _lambda has to coerce
exceptions to values.
@
text
@d3 6
d199 2
a200 1
      (error_info,options as Options.OPTIONS{print_options,...})
d243 7
a249 7
                  NewMap.YES scheme' => 
                    ((Scheme.scheme_generalises options
			(valid,completion_env,level,scheme,scheme'))
                     handle Scheme.EnrichError s =>
                       (error [s];
                        false),
		     need_coerce)
d304 1
a304 1
          
d342 1
a342 1
          Types.tyfun_eq (tyfun, tyfun') orelse
d348 17
d390 1
a390 1
              false))
@


1.36
log
@Allowed overloadin on strings to be controlled by an option
@
text
@d3 3
a191 8
    (* check everything on the list is true -- this is meant to be eager *)
    fun check_all l =
      let fun aux ([],b) = b
            | aux (a::l,b) = aux (l,aswell(a,b))
      in
        aux (l,true)
      end
        
d213 2
a214 1
         must generalise the scheme corresponding to it in amap.
d221 13
a233 1
                val entry = NewMap.tryApply'(amap', valid)
d235 1
a235 1
                case entry of
d237 2
a238 1
                    ((Scheme.scheme_generalises options (valid,completion_env,level,scheme,scheme'))
d241 2
a242 1
                        false))
d244 3
a246 1
                    (error ["Missing value ",
d249 1
a249 1
                     false)
d251 6
a256 37
          in
            eforall ran_enriches amap
          end
        
        (****
         Used in the enrichment test for EE's.  Again, the domain of amap is a
         subset of the domain of amap'.  This time however the schemes in both
         amap and amap' corresponding to each element of amap must be equal.
         ****)
       
        fun ee_ran_eq (ve as VE (_,amap),ve' as VE (_,amap')) =
          let
            fun ran_eq (valid, scheme) =
              let
                val entry = NewMap.tryApply'(amap', valid)
              in
                case entry of
                  NewMap.YES scheme' => 
(*
                    (* This can never fail as the type check has been done by the valenv check *)
                    if Scheme.typescheme_eq (scheme,scheme') then
                      true
                    else
                      (error ["    spec - ",
                              IdentPrint.debug_printValId valid, ": ",
                              Scheme.string_scheme scheme,
                              "\n    actual - ",
                              IdentPrint.debug_printValId valid, ": ",
                              Scheme.string_scheme scheme'];
                      false)
*)
                    true
                | NewMap.NO => (error ["Missing exception ",
                                       IdentPrint.printValId print_options valid,
                                       " in structure"];
                                false)
              end
d258 1
a258 1
            eforall ran_eq amap
d274 1
a274 8
                  (error ["Value constructor(s) of type ",
                          IdentPrint.printTyCon tycon,
                          " does not match signature specification:",
                          "\n    spec : ",
                          (Valenv.string_valenv (11,(Tystr.get_ce tystr))),
                          "\n    actual : ",
                          (Valenv.string_valenv (13,(Tystr.get_ce tystr')))];
                  false)
d288 9
a296 6
        fun env_enriches (level,ENV (se as SE se_map,te,ve,ee),
                          ENV (se' as SE se_map',te',ve',ee')) = 
          check_all [se_ran_enriches (level,se,se'),
                     te_ran_enriches (te,te'),
                     ve_ran_enriches (level,ve,ve'),
                     ee_ran_eq (ee,ee')]
d300 2
a301 2
            val (STR (strname,_,env)) = str
            val (STR (strname',_,env')) = str'
d304 4
a307 3
            Strnames.strname_eq (strname,strname')
            andalso
            env_enriches (level,env,env')
d316 8
a323 1
              | _ => false (* Crash.impossible "Missing structure in enrich" *)
d325 1
a325 1
            eforall ran_enriches amap
d398 1
a398 1
        and env_realise (names,ENV (se,te,_,_),ENV (se',te',_,_),strids) =
d406 2
a407 2
            val STR (name,_,env) = str1
            val STR (name',_,env') = str2
d448 3
d452 1
a452 2
        aswell (str_realise (names,str,str',[]),
                str_enriches (level,str,str'))
@


1.35
log
@Nameset signature changes
@
text
@d3 3
d198 1
a198 1
      (error_info,Options.OPTIONS{print_options,...})
d229 1
a229 1
                    ((Scheme.scheme_generalises print_options (valid,completion_env,level,scheme,scheme'))
@


1.34
log
@Options changes
@
text
@d3 3
a155 1
  sharing Sigma.BasisTypes = Nameset.BasisTypes
d158 4
a161 2
    = Strenv.Datatypes = Tystr.Datatypes = Valenv.Datatypes
  sharing Types.Datatypes.Ident = IdentPrint.Ident) : REALISE =
d163 1
@


1.33
log
@Options & Info changes
@
text
@d3 3
d190 1
a190 1
      (error_info,print_options)
@


1.32
log
@More on maximising number of errors reported in one go
@
text
@d3 3
d112 1
d142 1
d148 2
a150 1
  sharing Types.Info = Sigma.BasisTypes.Info = Env.Info = Scheme.Info = IdentPrint.Info
d158 2
a159 1
    structure Info = Types.Info
d186 3
a188 1
    fun sigmatch options (location,completion_env,level,sigma as BasisTypes.SIGMA (names,str),str') =
d192 1
a192 1
          Info.error options (Info.RECOVERABLE,location,implode message_list)
d218 1
a218 1
                    ((Scheme.scheme_generalises options (valid,completion_env,level,scheme,scheme'))
d224 1
a224 1
                            IdentPrint.printValId options valid,
d261 1
a261 1
                                       IdentPrint.printValId options valid,
@


1.31
log
@ Moved all realise and enrich code here from various places.
Fixed error reporting so it tries to report more than one
error at once.
@
text
@d3 5
d267 1
a267 1
              let
a268 1
                  handle NewMap.Undefined => Crash.impossible "Missing type in enrich"
d271 10
a280 10
                handle Tystr.TyfunError => Crash.impossible "Type clash in enrich"
                     | Tystr.TypeDiffer => 
                         (error ["Value constructor(s) of type ",
                                 IdentPrint.printTyCon tycon,
                                 " does not match signature specification:",
                                 "\n    spec : ",
                                 (Valenv.string_valenv (11,(Tystr.get_ce tystr))),
                                 "\n    actual : ",
                                 (Valenv.string_valenv (13,(Tystr.get_ce tystr')))];
                         false)
d282 4
d315 4
a318 7
              let
                val str' = case NewMap.tryApply'(amap', strid) of
                  NewMap.YES x => x
                | _ => Crash.impossible "Missing structure in enrich"
              in
                str_enriches (level,str,str')
              end
a322 2
        
        
d346 1
d349 1
a349 1
                 (error ["Arities of type ",
d352 2
a353 1
                         " in signature and structure differ"];
d357 1
d407 26
a432 15
                ((Strnames.uninstantiated name') andalso 
                 (Strnames.metastrname_eq (name,name')) andalso 
                 env_realise (names,env,env',strids))
                orelse
                (env_realise (names,env,env',strids) andalso
                 (if Nameset.member_of_strnames (name,names)
                    then
                      (r := name';
                       true)
                  else
                    (error["structure sharing violation for ",
                           (case strids of
                              [] => "top level structure"
                            | _ => string_strids' strids)];
                    false)))
d444 2
a445 4
        str_realise (names,str,str',[])
        andalso
        (* don't do this bit if realisation fails *)
        str_enriches (level,str,str')
@


1.30
log
@Changes for BASISTYPES signature
@
text
@d3 3
a107 1
require "valenv";
d112 3
a124 1
  structure Valenv    : VALENV
d129 3
d139 1
a139 1
  sharing Types.Info = Sigma.BasisTypes.Info = Env.Info
d141 2
a142 2
    = Types.Datatypes = Tyenv.Datatypes = Env.Datatypes
    = Strenv.Datatypes = Valenv.Datatypes
a152 2
    exception RealiseError of string

d159 11
a169 76
    (* Realisation is managed by references in tynames and strnames.  
       In order to do this all type names and structure names generated
       during signature elaboration are flexible, containing
       uninstantiated references to type functions and structure names,
       respectively.  These references are destructively modified
       during realisation.  Because a single signature may have many
       structures as instances a copy is made of a signature before it
       is matched against a structure.  This is done in the function from 
       where Realise.sigmatch is called.
       Returns false if and only if the final case fails. This used
       to be raise TyfunEq *)

    fun tystr_realise (TYSTR (tyfun,ve as VE (_,amap)),
		       TYSTR (tyfun',ve' as VE (_,amap')),
                       tycon,
                       strids) =
      (if do_debug andalso Debug.debug_level ()> 10 then 
	 (Print.print ("tystr_realise \n");
	  Print.print "sig_tyfun = ";
	  Print.print (Types.string_tyfun tyfun);
	  Print.print "\n str_tyfun = ";
	  Print.print (Types.string_tyfun tyfun');
	  Print.print ("\n"))
       else ();
	 Types.tyfun_eq (tyfun, tyfun') orelse
	 (if Types.null_tyfunp tyfun then
	    let
	      val (t, eq) = case Types.meta_tyname tyfun of
	        METATYNAME (t,_,_,ref eq, _) => (t, eq)
	      | _ => Crash.impossible"bad Types.meta_tyname tyfun"
	    in
	      if Types.arity tyfun = Types.arity tyfun' then
	        if (Types.equalityp tyfun' orelse not eq) then
		  (if do_debug andalso Debug.debug_level () > 10 then 
		     (Print.print ("type_realise map from " ^ 
			  	   (Types.string_tyfun tyfun)
				   ^ " to " ^
				   (Types.string_tyfun tyfun')^ "\n"))
		   else ();
		     t := tyfun';
		     true)
	        else
		  raise RealiseError
		    ("Type " ^ 
                     string_strids strids ^
                     IdentPrint.printTyCon tycon ^
		     " in structure does not admit equality")
	      else
	        raise RealiseError
		  ("Arities of type " ^
                    string_strids strids ^
                    IdentPrint.printTyCon tycon ^
                    " in signature and structure differ")
	    end
          else
            raise RealiseError
              ("Type sharing violation for " ^
                string_strids strids ^
                IdentPrint.printTyCon tycon)
	      )
	    )

    and se_realise (names,SE amap,se',strids) =
      (if do_debug andalso Debug.debug_level ()> 10 then 
	 (Print.print ("se_realise");
	  Print.print ("\n"))
       else ();
      let
	fun strname_map(strid,str) =
	  str_realise(names,str,
		      (Strenv.lookup (strid,se')
		       handle Strenv.Lookup_in_SE =>
			 raise RealiseError ("Missing substructure in structure: " ^ 
					     string_strids strids ^
                                             (IdentPrint.printStrId strid))),
                      strid :: strids)
d171 4
a174 2
	NewMap.forall strname_map amap
      end)
d176 3
a178 20
    and te_realise (names,TE amap,te',strids) =
      (if do_debug andalso Debug.debug_level ()> 10 then 
	 (Print.print ("te_realise");
	  Print.print ("\n"))
       else ();
      let 
	fun tyname_map(tycon, sig_tystr) =
	  let
	    val str_tystr =
	      Tyenv.lookup (te', tycon)
	      handle Tyenv.Lookup_in_TE => raise RealiseError 
		("Missing type constructor in structure: " ^ 
                 string_strids strids ^
		 (IdentPrint.printTyCon tycon))
	  in
	    tystr_realise (sig_tystr,str_tystr, tycon,strids)
	  end
      in
	NewMap.forall tyname_map amap
      end)
d180 246
a425 16
    and env_realise (names,ENV (se,te,_,_),ENV (se',te',_,_),strids) =
      (if do_debug andalso Debug.debug_level ()> 10 then 
	 (Print.print ("env_realise");
	  Print.print ("\n"))
       else ();
       se_realise (names,se,se',strids) 
       andalso
       te_realise (names,te,te',strids))

    and str_realise (names,str1,str2,strids) =
      let
        (* These structures should be fully expanded already *)
        (* So a Bind exn should be impossible *)
        val STR (name,_,env) = str1
        val STR (name',_,env') = str2
	val name = Strnames.strip name
d427 5
a431 70
        (if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("str_realise\n");
	    Print.print ("name = " ^ (Strnames.string_strname name) ^ "\n");
	    Print.print ("name' = " ^ (Strnames.string_strname name'));
	    Print.print ("\n"))
         else ();
	   case name of
	     METASTRNAME r =>
	   ((Strnames.uninstantiated name') andalso 
            (Strnames.metastrname_eq (name,name')) andalso 
	    env_realise (names,env,env',strids))
	   orelse
	   (env_realise (names,env,env',strids) andalso
            (if Nameset.member_of_strnames (name,names)
	       then
		 (if do_debug andalso Debug.debug_level () > 10 then 
		    (Print.print ("realise map from " ^ 
		                  (Strnames.string_strname name) ^ "to " ^
			          (Strnames.string_strname name') ^ "\n"))
		  else ();
		  r := name';
		  true)
	      else
                raise RealiseError
                  ("structure sharing violation for " ^
                   (case strids of
                      [] => "top level structure"
                    | _ => string_strids' strids))))
	 | _ =>
	     if Strnames.strname_eq (name,name') then
               env_realise (names,env,env',strids)
             else 
               raise RealiseError
                 ("structure sharing violation for " ^
                  (case strids of
                     [] => "top level structure"
                   | _ => string_strids' strids)))
      end handle Bind => Crash.impossible "unexpanded structure in str_realise"
	 
    fun sigmatch options (level,sigma as BasisTypes.SIGMA (names,str),str') =
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("sigmatch \n");
	  Print.print ("str' (in sigmatch) = " ^ (Env.string_str str') ^ "\n");
	  Print.print ("sigma (in sigmatch) = " ^ 
		       (Sigma.string_sigma Info.default_options sigma) ^ "\n");
	  Print.print ("\n"))
       else ();
       if str_realise (names,str,str',[]) 
	 then
	   (if do_debug andalso Debug.debug_level () > 10 then 
	      Print.print ("str_realise successful \n")
	    else ();
	    if (Env.str_enriches options (level,str,str') 
		handle Env.EnrichError s => raise RealiseError s)
	      then
		(if do_debug andalso Debug.debug_level () > 10 then 
		   Print.print ("str_enriches successful \n")
		 else ();
		 true)
	    else
	      (if do_debug andalso Debug.debug_level () > 10 then 
		 Print.print ("str_enriches unsuccessful \n")
	       else ();
	       false))
       else
	 (if do_debug andalso Debug.debug_level () > 10 then 
	    Print.print ("str_realise unsuccessful \n")
	  else ();
	  false))

a432 2


@


1.29
log
@COPYSTR changes
Changes to error messages.
@
text
@d3 4
d125 1
d131 3
a133 2
  sharing Types.Info = Sigma.Nameset.Info = Env.Info
  sharing Sigma.Nameset.Datatypes = Strnames.Datatypes
d139 1
d141 2
a142 3
    structure Datatypes = Valenv.Datatypes
    structure Sigma = Sigma
    structure Nameset = Sigma.Nameset
d311 1
a311 1
    fun sigmatch options (level,sigma as Sigma.SIGMA (names,str),str') =
@


1.28
log
@Anel's last changes
@
text
@d3 3
d258 1
a258 1
    and str_realise (names,STR (name,env),STR (name',env'),strids) =
d260 4
d274 2
a275 4
	   ((Strnames.uninstantiated name') 
	    andalso 
            (Strnames.metastrname_eq (name,name'))
	    andalso 
d278 1
a278 2
	   (env_realise (names,env,env',strids)
	    andalso
d289 5
a293 1
	        Crash.impossible "wrong domain for realisation map"))
d303 1
a303 1
      end
@


1.27
log
@Propagating options to signature matching error messages.
,
@
text
@d3 3
d169 23
a191 17
	 Types.tyfun_eq(tyfun, tyfun') orelse
	 (Types.null_tyfunp tyfun andalso
	  let
	    val (t, eq) = case Types.meta_tyname tyfun of
	      METATYNAME (t,_,_,ref eq, _) => (t, eq)
	    | _ => Crash.impossible"bad Types.meta_tyname tyfun"
	  in
	    if Types.arity tyfun = Types.arity tyfun' then
	      if (Types.equalityp tyfun' orelse not eq) then
		(if do_debug andalso Debug.debug_level () > 10 then 
		   (Print.print ("type_realise map from " ^ 
				 (Types.string_tyfun tyfun)
				 ^ " to " ^
				 (Types.string_tyfun tyfun')^ "\n"))
		 else ();
		   t := tyfun';
		   true)
d193 13
a205 12
		raise RealiseError
		  ("Type " ^ 
                   string_strids strids ^
                   IdentPrint.printTyCon tycon ^
		   " in structure does not admit equality")
	    else
	      raise RealiseError
		("Arities of type " ^
                 string_strids strids ^
                 IdentPrint.printTyCon tycon ^
                 " in signature and structure differ")
	  end))
d240 1
a240 11
	    if tystr_realise (sig_tystr,str_tystr, tycon,strids) then
	      true
	    else
              (* dont think this can happen *)
	      (raise RealiseError ("Cannot match " ^ 
                                   string_strids strids ^
				   (IdentPrint.printTyCon tycon) ^ 
				   " in signature to " ^ 
                                   string_strids strids ^
				   (IdentPrint.printTyCon tycon) ^ 
				   " in structure\n"))
d255 1
a255 7
    and str_realise (names,
(*
		     STR (name as METASTRNAME (r as ref (NULLNAME _)),env),
*)
		     STR(name, env),
		     STR(name',env'),
                     strids) =
d259 2
a260 47
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("str_realise 1\n");
	  Print.print ("name = " ^ (Strnames.string_strname name) ^ "\n");
	  Print.print ("name' = " ^ (Strnames.string_strname name'));
	  Print.print ("\n"))
       else ();
	 case name of
	   METASTRNAME r =>
	 (if (Strnames.uninstantiated name') 
	   andalso (Strnames.metastrname_eq (name,name'))
	   andalso 
	   env_realise (names,env,env',strids) 
	   then
	     true
	 else
	   if env_realise (names,env,env',strids)
	     then
	       if Nameset.member_of_strnames (name,names)
		 then
		   (if do_debug andalso Debug.debug_level () > 10 then 
		      (Print.print ("realise map from " ^ 
				   (Strnames.string_strname name) ^ "to " ^
			    (Strnames.string_strname name') ^ "\n"))
		    else ();
		    r := name';
		    true)
	       else
		 raise RealiseError
                   ("Structure sharing violation for " ^
                    (case strids of
                       [] => "top level structure"
                     | _ => string_strids' strids))
	   else
	     false)
	 | _ =>
	     Strnames.strname_eq (name,name') 
	     andalso
	     env_realise (names,env,env',strids)
	     )
      end
(*
      | str_realise (names,
                     STR (name as METASTRNAME (ref n),env),
		     str' as STR (name',_),
                     strids) =
	(if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("str_realise 2\n");
d264 32
a295 14
	 else ();
	   str_realise (names,STR (n,env),str',strids))

      | str_realise (names,STR (name,env),STR (name',env'),strids) =
	(if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("str_realise 3\n");
	    Print.print ("name = " ^ (Strnames.string_strname name) ^ "\n");
	    Print.print ("name' = " ^ (Strnames.string_strname name'));
	    Print.print ("\n"))
	 else ();
	 Strnames.strname_eq (name,name') 
	 andalso
	 env_realise (names,env,env',strids))
*)
@


1.26
log
@Changed error messages.
@
text
@d3 3
a90 1
require "../main/info";
d120 1
d127 1
d330 1
a330 1
    fun sigmatch (level,sigma as Sigma.SIGMA (names,str),str') =
d335 1
a335 1
		       (Sigma.string_sigma Sigma.Nameset.Info.default_options sigma) ^ "\n");
d343 1
a343 1
	    if (Env.str_enriches (level,str,str') 
@


1.25
log
@Error message revisions.
@
text
@d3 3
d181 1
a181 1
		  ("Type '" ^ 
d184 1
a184 1
		   "' in structure does not admit equality")
d187 1
a187 1
		("Arities of type '" ^
d190 1
a190 1
                 "in signature and structure differ")
@


1.24
log
@Replaced some NewMap.fold calls with NewMap.forall
@
text
@d3 3
d181 1
a181 1
		   "' in structure does not admit equality\n")
d185 3
a187 3
                   string_strids strids ^
                   IdentPrint.printTyCon tycon ^
                   "in signature and structure differ")
d200 1
a200 1
			 raise RealiseError ("Missing substructure " ^ 
d202 1
a202 2
                                             (IdentPrint.printStrId strid) ^
					     " in structure\n")),
d219 1
a219 1
		("Missing type constructor " ^ 
d221 1
a221 2
		 (IdentPrint.printTyCon tycon)
                 ^ " in structure\n")
d226 1
@


1.23
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d3 4
d193 1
a193 2
	fun strname_map(res,strid,str) =
	  res andalso
d203 1
a203 1
	NewMap.fold strname_map (true, amap)
d212 1
a212 2
	fun tyname_map(res, tycon,sig_tystr) =
	  res andalso
d215 1
a215 1
	      Tyenv.lookup (tycon,te')
d234 1
a234 1
	NewMap.fold tyname_map (true, amap)
@


1.22
log
@Minor improvements to str_realise to strip the first strname before matching
@
text
@d3 3
d78 1
d88 1
d147 1
a147 1
	  Print.print (Types.string_tyfun_using_default tyfun);
d149 1
a149 1
	  Print.print (Types.string_tyfun_using_default tyfun');
d163 1
a163 1
				 (Types.string_tyfun_using_default tyfun)
d165 1
a165 1
				 (Types.string_tyfun_using_default tyfun')^ "\n"))
d324 1
a324 1
		       (Sigma.string_sigma sigma) ^ "\n");
@


1.21
log
@Really changed the error messages this time.
@
text
@d3 3
d240 1
d242 3
a244 1
		     STR (name',env'),
d246 3
d255 3
a257 1
	 if (Strnames.uninstantiated name') 
d283 7
a289 1
	 
d312 1
@


1.20
log
@Improved error messages.
@
text
@d3 3
d114 6
d133 3
a135 1
		       TYSTR (tyfun',ve' as VE (_,amap')), tycon) =
d163 3
a165 1
		  ("Type '" ^ IdentPrint.printTyCon tycon ^
d169 4
a172 1
		"Arities of types in signature and structure differ\n"
d175 1
a175 1
    and se_realise (names,SE amap,se') =
d181 1
a181 1
	fun strname_map(res, strid,str) =
d187 4
a190 2
					     (IdentPrint.printStrId strid) ^
					     " in structure\n")))
d195 1
a195 1
    and te_realise (names,TE amap,te') =
d208 3
a210 1
		 (IdentPrint.printTyCon tycon) ^ " in structure\n")
d212 1
a212 1
	    if tystr_realise (sig_tystr,str_tystr, tycon) then
d216 1
d219 1
d227 1
a227 1
    and env_realise (names,ENV (se,te,_,_),ENV (se',te',_,_)) =
d232 1
a232 1
       se_realise (names,se,se') 
d234 1
a234 1
       te_realise (names,te,te'))
d238 2
a239 1
		     STR (name',env')) =
d249 1
a249 1
	   env_realise (names,env,env') 
d253 1
a253 1
	   if env_realise (names,env,env')
d266 4
a269 1
		   "Illegal realisation map - trying to map a free signature name\n"
d273 4
a276 2
      | str_realise (names,STR (name as METASTRNAME (ref n),env),
		     str' as STR (name',_)) =
d283 1
a283 1
	   str_realise (names,STR (n,env),str'))
d285 1
a285 1
      | str_realise (names,STR (name,env),STR (name',env')) =
d294 1
a294 1
	 env_realise (names,env,env') )
d304 1
a304 1
       if str_realise (names,str,str') 
@


1.19
log
@Small improvements in tystr_realise
@
text
@d3 3
@


1.18
log
@Tynames now have a slot recording their definition point
@
text
@d3 3
d138 13
a150 17
	      let
		val new_eq = Types.equalityp tyfun'
	      in
		if ((eq andalso new_eq) orelse not eq) then
		  (if do_debug andalso Debug.debug_level () > 10 then 
		     (Print.print ("type_realise map from " ^ 
				   (Types.string_tyfun_using_default tyfun)
				   ^ " to " ^
				   (Types.string_tyfun_using_default tyfun')^ "\n"))
		   else ();
		     t := tyfun';
		     true)
		else
		  raise RealiseError
		    ("Type '" ^ IdentPrint.printTyCon tycon ^
		     "' in structure does not admit equality\n")
	      end
@


1.17
log
@Modified the realisation of tynames
@
text
@d3 3
d122 1
a122 1
	  Print.print (Types.string_tyfun tyfun);
d124 1
a124 1
	  Print.print (Types.string_tyfun tyfun');
d141 1
a141 1
				   (Types.string_tyfun tyfun)
d143 1
a143 1
				   (Types.string_tyfun tyfun')^ "\n"))
@


1.16
log
@Added Anel's changes.
@
text
@d3 3
d124 29
a152 39
       if Types.null_tyfunp tyfun then
	 let
	   val (meta, t, tyfun'', eq) = case Types.meta_tyname tyfun of
	     meta as METATYNAME (t as ref tyfun'',_,_,ref eq, _) =>
	       (meta, t, tyfun'', eq)
	   | _ => Crash.impossible"bad Types.meta_tyname tyfun"
	 in
	   (* necessary for elaborating a functor declaration *)
	   (* constrained by signature *)
	   if (Types.null_tyfunp (tyfun') andalso Types.tyname_eq (meta,Types.meta_tyname tyfun'))
	     then true
	   else
	     if Types.arity (tyfun) = Types.arity (tyfun') then
	       let
		 val new_eq = Types.equalityp tyfun'
	       in
		 if ((eq andalso new_eq) orelse not eq) then
		   (if do_debug andalso Debug.debug_level () > 10 then 
		      (Print.print ("type_realise map from " ^ 
				    (Types.string_tyfun tyfun'')
				    ^ " to " ^
				    (Types.string_tyfun tyfun')^ "\n"))
		    else ();
		      t := tyfun';
		      true)
		 else
		   raise RealiseError
		     ("Type '" ^ IdentPrint.printTyCon tycon ^
		      "' in structure does not admit equality\n")
	       end
	     else
	       raise RealiseError
		 "Arities of types in signature and structure differ\n"
	 end
       else
	 if Types.tyfun_eq (tyfun,tyfun') then
	   true
	 else 
	   false)
@


1.15
log
@Removed irrelevant handlers and new exceptions
@
text
@d3 3
d130 1
a130 2
	   if (Types.null_tyfunp (tyfun')
	       andalso Types.meta_tyname_eq (meta,Types.meta_tyname tyfun'))
d134 17
a150 22
	       if Valenv.empty_valenvp ve
		 orelse
		 Valenv.ve_domain ve = Valenv.ve_domain ve' then
		 let
		   val new_eq = Types.equalityp tyfun'
		 in
		   if ((eq andalso new_eq) orelse not eq) then
		     (if do_debug andalso Debug.debug_level () > 10 then 
			(Print.print ("type_realise map from " ^ 
				      (Types.string_tyfun tyfun'')
				      ^ " to " ^
				      (Types.string_tyfun tyfun')^ "\n"))
		      else ();
			t := tyfun';
			true)
		   else
		     raise RealiseError
		       ("Type '" ^ IdentPrint.printTyCon tycon ^
			"' in structure does not admit equality\n")
		 end
	       else
		 raise RealiseError "Type structures are inconsistent\n"
@


1.14
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d3 4
a94 1
    exception TyfunEq
d104 3
a106 1
       where Realise.sigmatch is called. *)
d132 1
a132 1
	       if Valenv.ve_domain ve = []
d162 1
a162 1
	   raise TyfunEq)
d197 8
a204 7
	    (tystr_realise (sig_tystr,str_tystr, tycon)
	     handle TyfunEq =>
	       (raise RealiseError ("Cannot match " ^ 
				    (IdentPrint.printTyCon tycon) ^ 
				    " in signature to " ^ 
				    (IdentPrint.printTyCon tycon) ^ 
				    " in structure\n")))
@


1.13
log
@removed type_eq_matters
@
text
@d3 3
d50 1
a52 2
require "nameset";
require "datatypes";
d64 1
a66 2
  structure Nameset   : NAMESET
  structure Datatypes : DATATYPES
d78 1
a78 1
  sharing Datatypes = Sigma.Datatypes = Strnames.Datatypes
d80 2
a81 2
    = Nameset.Datatypes = Strenv.Datatypes = Valenv.Datatypes
  sharing Nameset = Sigma.Nameset) : REALISE =
d84 1
a84 1
    structure Datatypes = Datatypes
d86 1
a86 1

d104 1
a104 1
		       TYSTR (tyfun',ve' as VE (_,amap'))) =
d113 36
a148 13
       if Types.null_tyfunp (tyfun)
	 then
	   let
	     val (meta, t, tyfun'', r, eq, s) = case Types.meta_tyname tyfun of
	       meta as METATYNAME (t as ref tyfun'',s,_,r as ref eq, _) =>
		 (meta, t, tyfun'', r, eq, s)
	     | _ => Crash.impossible"bad Types.meta_tyname tyfun"
	   in
	     (* necessary for elaborating a functor declaration *)
	     (* constrained by signature *)
	     if (Types.null_tyfunp (tyfun')
		 andalso Types.meta_tyname_eq (meta,Types.meta_tyname tyfun'))
	       then true
d150 6
a155 31
	       if Types.arity (tyfun) = Types.arity (tyfun') then
		 if Valenv.ve_domain ve = []
		   orelse
		   Valenv.ve_domain ve = Valenv.ve_domain ve' then
		   let
		     val new_eq = Types.equalityp tyfun'
		   in
                     if ((eq andalso new_eq) orelse not eq) then
                       (if do_debug andalso Debug.debug_level () > 10 then 
                          (Print.print ("type_realise map from " ^ 
                                        (Types.string_tyfun tyfun'')
                                        ^ " to " ^
                                        (Types.string_tyfun tyfun')^ "\n"))
                        else ();
                          r := new_eq;
                          t := tyfun';
                          true)
                     else
                       raise RealiseError
                         ("Type '" ^ s ^
                          "' in structure does not admit equality\n")
		   end
		 else
		   raise RealiseError "Type structures are inconsistent\n"
	       else
		 raise RealiseError
		   "Arities of types in signature and structure differ\n"
	   end
       else 
	 if Types.tyfun_eq (tyfun,tyfun') 
	   then true
d158 1
a158 1
	 
d165 8
a172 10
	val strid_str_list = NewMap.to_list amap
	fun strname_map [] = true
	  | strname_map ((strid,str)::strid_strs) =
	    str_realise (names,str,
			 (Strenv.lookup (strid,se')
			  handle Strenv.Lookup_in_SE =>
			    raise RealiseError ("Missing substructure " ^ 
						(IdentPrint.printStrId strid) ^
						" in structure\n")))
	    andalso strname_map strid_strs
d174 1
a174 1
	strname_map strid_str_list
d183 17
a199 20
	val tycon_tystr_list = NewMap.to_list amap
	fun tyname_map [] = true
	  | tyname_map ((tycon,sig_tystr)::tycon_tystrs) = 
	    let
	      val str_tystr =
		Tyenv.lookup (tycon,te')
		handle Tyenv.Lookup_in_TE => raise RealiseError 
		  ("Missing type constructor " ^ 
		   (IdentPrint.printTyCon tycon) ^ " in structure\n")
	    in
	      (tystr_realise (sig_tystr,str_tystr)
	       handle TyfunEq =>
		 (raise RealiseError ("Cannot match " ^ 
				      (IdentPrint.printTyCon tycon) ^ 
				      " in signature to " ^ 
				      (IdentPrint.printTyCon tycon) ^ 
				      " in structure\n")))
	      andalso 
	      tyname_map tycon_tystrs
	    end
d201 1
a201 1
	tyname_map tycon_tystr_list
@


1.12
log
@Fix for equality type problem
@
text
@d3 3
d103 1
a103 1
		       TYSTR (tyfun',ve' as VE (_,amap')),type_eq_matters) =
d133 14
a146 26
		     if type_eq_matters orelse not (Types.null_tyfunp tyfun')
		       then
			 if ((eq andalso new_eq) orelse not eq) then
			   (if do_debug andalso Debug.debug_level () > 10 then 
			      (Print.print ("type_realise map from " ^ 
					    (Types.string_tyfun tyfun'')
					    ^ " to " ^
					    (Types.string_tyfun tyfun')^ "\n"))
			    else ();
			      r := new_eq;
			      t := tyfun';
			      true)
			 else
			   raise RealiseError
			     ("Type '" ^ s ^
			      "' in structure does not admit equality\n")
		     else
		       (if do_debug andalso Debug.debug_level () > 10 then 
			  (Print.print ("type_realise map from " ^ 
					(Types.string_tyfun tyfun'')
					^ " to " ^
					(Types.string_tyfun tyfun')^ "\n"))
			else ();
			  r := new_eq;
			  t := tyfun';
			  true)
d160 1
a160 1
    and se_realise (names,SE amap,se',type_eq_matters) =
d174 1
a174 2
						" in structure\n")),
                         type_eq_matters)
d180 1
a180 1
    and te_realise (names,TE amap,te',type_eq_matters) =
d196 1
a196 1
	      (tystr_realise (sig_tystr,str_tystr,type_eq_matters)
d210 1
a210 1
    and env_realise (names,ENV (se,te,_,_),ENV (se',te',_,_),type_eq_matters) =
d215 1
a215 1
       se_realise (names,se,se',type_eq_matters) 
d217 1
a217 1
       te_realise (names,te,te',type_eq_matters))
d221 1
a221 1
		     STR (name',env'),type_eq_matters) =
d231 1
a231 1
	   env_realise (names,env,env',type_eq_matters) 
d235 1
a235 1
	   if env_realise (names,env,env',type_eq_matters)
d253 1
a253 1
		     str' as STR (name',_),type_eq_matters) =
d260 1
a260 1
	   str_realise (names,STR (n,env),str',type_eq_matters))
d262 1
a262 1
      | str_realise (names,STR (name,env),STR (name',env'),type_eq_matters) =
d271 1
a271 1
	 env_realise (names,env,env',type_eq_matters) )
d273 1
a273 1
    fun sigmatch (level,sigma as Sigma.SIGMA (names,str),str',type_eq_matters) =
d281 1
a281 1
       if str_realise (names,str,str',type_eq_matters) 
@


1.11
log
@Anel's changes to use NewMap instead of Map
@
text
@d3 3
d112 3
a114 3
	     val (meta, t, tyfun'', eq, s) = case Types.meta_tyname tyfun of
	       meta as METATYNAME (t as ref tyfun'',s,_,ref eq, _) =>
		 (meta, t, tyfun'', eq, s)
d123 20
a142 20
	       if Types.arity (tyfun) = Types.arity (tyfun')
		 then
		   if Valenv.ve_domain ve = [] 
		     orelse
		     Valenv.ve_domain ve = Valenv.ve_domain ve'
		     then
	                 if type_eq_matters
                           then	  
                             if ((eq andalso Types.equalityp (tyfun')) 
	                         orelse not eq)
			     then
			       (if do_debug andalso Debug.debug_level () > 10 then 
			          (Print.print ("type_realise map from " ^ 
					        (Types.string_tyfun tyfun'')
					        ^ " to " ^
					        (Types.string_tyfun tyfun')^ "\n"))
                                 else ();
			        t := tyfun';
			        true)
		         else
d144 3
a146 3
			   ("Type '" ^ s ^
			    "' in structure does not admit equality\n")
                     else
d148 11
a158 9
		          (Print.print ("type_realise map from " ^ 
				        (Types.string_tyfun tyfun'')
				        ^ " to " ^
				        (Types.string_tyfun tyfun')^ "\n"))
                         else ();
                           t := tyfun';
			   true)
		   else
		     raise RealiseError "Type structures are inconsistent\n"
@


1.10
log
@Anel's fixes.
@
text
@d3 3
d42 2
a43 1
require "realise";
a44 2
require "sigma";
require "strnames";
d46 1
d48 1
d50 2
a51 2
require "nameset";
require "valenv";
d53 6
a58 4
functor Realise(
  structure Print : PRINT
  structure Crash : CRASH
  structure Ty_Debug : TY_DEBUG
d60 6
a65 7
  structure Sigma : SIGMA
  structure Strnames : STRNAMES
  structure Types : TYPES
  structure Tyenv : TYENV
  structure Env : ENVIRONMENT
  structure Nameset : NAMESET
  structure Valenv : VALENV
d73 1
a73 1
    = Nameset.Datatypes = Valenv.Datatypes
d170 1
a170 1
	val strid_str_list = Mapping.assoc amap
d174 2
a175 2
			 (Env.lookup_strid_in_SE (strid,se')
			  handle Env.Lookup_StrId_in_SE =>
d185 1
a185 1
    and te_realise (names,TE amap,TE amap',type_eq_matters) =
d191 1
a191 1
	val tycon_tystr_list = Mapping.assoc amap
d196 2
a197 2
		Mapping.lookup (tycon,amap')
		handle Mapping.Lookup => raise RealiseError 
@


1.9
log
@Added extra parameter to indicate when equality attributes of
types matter.
@
text
@d3 4
d159 1
a159 1
    and se_realise (names,se as SE amap,se' as SE amap',type_eq_matters) =
d165 4
a168 4
	val stridlist = Mapping.domain amap
	fun strname_map ([],se,se') = true
	  | strname_map (strid::strids,se,se') =
	    str_realise (names,Env.lookup_strid_in_SE (strid,se),
d175 1
a175 1
	    andalso strname_map (strids,se,se')
d177 1
a177 1
	strname_map (stridlist,se,se')
d180 1
a180 1
    and te_realise (names,te as TE amap,te' as TE amap',type_eq_matters) =
d186 3
a188 3
	val tyconlist = Mapping.domain amap
	fun tyname_map ([],amap,amap') = true
	  | tyname_map (tycon::tycons,amap,amap') = 
d190 3
a192 8
	      val sig_tystr as TYSTR (sig_tyfun,sig_CE) = 
		Tyenv.lookup (tycon,amap)
		handle Tyenv.Lookup_in_TE => raise RealiseError 
		  ("Unbound type constructor " ^ (IdentPrint.printTyCon tycon)
		   ^ " in signature\n")
	      val str_tystr as TYSTR (str_tyfun,str_CE) =
		Tyenv.lookup (tycon,amap')
		handle Tyenv.Lookup_in_TE => raise RealiseError 
d204 1
a204 1
	      tyname_map (tycons,amap,amap')
d207 1
a207 1
	tyname_map (tyconlist,te,te')
@


1.8
log
@Added require "ty_debug"
@
text
@d3 3
d88 1
a88 1
		       TYSTR (tyfun',ve' as VE (_,amap'))) =
d117 15
a131 13
		       if ((eq andalso Types.equalityp (tyfun')) 
			   orelse not eq)
			 then
			   (if do_debug andalso Debug.debug_level () > 10 then 
			      (Print.print ("type_realise map from " ^ 
					    (Types.string_tyfun tyfun'')
					    ^ " to " ^
					    (Types.string_tyfun tyfun')^ "\n"))
			    else ();
			      t := tyfun';
			      true)
		       else
			 raise RealiseError
d134 9
d155 1
a155 1
    and se_realise (names,se as SE amap,se' as SE amap') =
d169 2
a170 1
						" in structure\n")))
d176 1
a176 1
    and te_realise (names,te as TE amap,te' as TE amap') =
d197 1
a197 1
	      (tystr_realise (sig_tystr,str_tystr)
d211 1
a211 1
    and env_realise (names,ENV (se,te,_,_),ENV (se',te',_,_)) =
d216 1
a216 1
       se_realise (names,se,se') 
d218 1
a218 1
       te_realise (names,te,te'))
d222 1
a222 1
		     STR (name',env')) =
d232 1
a232 1
	   env_realise (names,env,env') 
d236 1
a236 1
	   if env_realise (names,env,env')
d254 1
a254 1
		     str' as STR (name',_)) =
d261 1
a261 1
	   str_realise (names,STR (n,env),str'))
d263 1
a263 1
      | str_realise (names,STR (name,env),STR (name',env')) =
d272 1
a272 1
	 env_realise (names,env,env') )
d274 1
a274 1
    fun sigmatch (level,sigma as Sigma.SIGMA (names,str),str') =
d282 1
a282 1
       if str_realise (names,str,str') 
@


1.7
log
@Added type name to an error message
@
text
@d3 3
d31 1
@


1.6
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d3 4
d93 3
a95 3
	     val (meta, t, tyfun'', eq) = case Types.meta_tyname tyfun of
	       meta as METATYNAME (t as ref tyfun'',_,_,ref eq, _) =>
		 (meta, t, tyfun'', eq)
d123 2
a124 1
			   "Type in structure does not admit equality\n"
@


1.5
log
@Updated to allow valenv in METATYNAME
@
text
@d3 3
d13 1
a13 1
> Modified to take new ValEnv definition with ref unit to allow
d21 3
a32 2
require "../utils/print";
require "../utils/crash";
d34 21
a54 17
functor Realise (structure Datatypes : DATATYPES
		 structure Sigma : SIGMA
		 structure Strnames : STRNAMES
		 structure Types : TYPES
		 structure Tyenv : TYENV
		 structure Env : ENVIRONMENT
		 structure Nameset : NAMESET
		 structure Print : PRINT
		 structure Crash : CRASH
		 structure Valenv : VALENV
		 structure Debug :  sig val set_debug_level : int -> unit
					val debug_level : unit -> int
				    end
		 sharing Datatypes = Sigma.Datatypes = Strnames.Datatypes
		   = Types.Datatypes = Tyenv.Datatypes = Env.Datatypes
		   = Nameset.Datatypes = Valenv.Datatypes
		 sharing Nameset = Sigma.Nameset) : REALISE =
d60 1
d78 1
a78 1
      (if Debug.debug_level ()> 10 then 
d109 1
a109 1
			   (if Debug.debug_level () > 10 then 
d133 1
a133 1
      (if Debug.debug_level ()> 10 then 
d153 1
a153 1
      (if Debug.debug_level ()> 10 then 
d188 1
a188 1
      (if Debug.debug_level ()> 10 then 
d199 1
a199 1
      (if Debug.debug_level () > 10 then 
d216 1
a216 1
		   (if Debug.debug_level () > 10 then 
d231 1
a231 1
	(if Debug.debug_level () > 10 then 
d240 1
a240 1
	(if Debug.debug_level () > 10 then 
d251 1
a251 1
      (if Debug.debug_level () > 10 then 
d260 1
a260 1
	   (if Debug.debug_level () > 10 then 
d266 1
a266 1
		(if Debug.debug_level () > 10 then 
d271 1
a271 1
	      (if Debug.debug_level () > 10 then 
d276 1
a276 1
	 (if Debug.debug_level () > 10 then 
@


1.4
log
@Fixed inexhaustive matches
@
text
@d2 4
a5 1
$Log:	_realise.sml,v $
d81 1
a81 1
	       meta as METATYNAME (t as ref tyfun'',_,_,ref eq) =>
@


1.3
log
@Modified tystr_realise to use Valenv.ve_domain to extract domain of valenvs
@
text
@d3 3
d13 1
d25 1
d35 1
d77 4
a80 3
	     val 
	       meta as METATYNAME (t as ref tyfun'',_,_,ref eq) =
	       Types.meta_tyname tyfun
@


1.2
log
@> Modified to take new ValEnv definition with ref unit to allow
reading and writing circular data structures.
@
text
@d3 4
d19 1
d30 1
d36 1
a36 1
		   = Nameset.Datatypes
d58 2
a59 1
    fun tystr_realise (TYSTR (tyfun,VE (_,amap)),TYSTR (tyfun',VE (_,amap'))) =
d83 1
a83 1
		   if Mapping.domain (amap) = [] 
d85 1
a85 1
		     Mapping.domain (amap) = Mapping.domain (amap')
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d52 1
a52 1
    fun tystr_realise (TYSTR (tyfun,VE amap),TYSTR (tyfun',VE amap')) =
@
