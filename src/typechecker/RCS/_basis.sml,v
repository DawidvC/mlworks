head	1.43;
access;
symbols
	MLW_daveb_inline_1_4_99:1.43.3
	MLWorks_21c0_1999_03_25:1.43
	MLWorks_20c1_1998_08_20:1.43
	MLWorks_20c0_1998_08_04:1.43
	MLWorks_20b2c2_1998_06_19:1.43
	MLWorks_20b2_Windows_1998_06_12:1.43
	MLWorks_20b1c1_1998_05_07:1.43
	MLWorks_20b0_1998_04_07:1.43
	MLWorks_20b0_1998_03_20:1.43
	MLWorks_20m2_1998_02_16:1.43
	MLWorks_20m1_1997_10_23:1.43
	MLWorks_11r1:1.42.6.1.1.1.1
	MLWorks_workspace_97:1.43.2
	MLWorks_dt_wizard:1.43.1
	MLWorks_11c0_1997_09_09:1.42.6.1.1.1
	MLWorks_10r3:1.42.6.1.3
	MLWorks_10r2_551:1.42.6.1.2
	MLWorks_11:1.42.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.42.6.1
	MLWorks_20m0_1997_06_20:1.43
	MLWorks_1_0_r2c2_1997_06_14:1.42.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.42.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.42.6
	MLWorks_BugFix_1997_04_24:1.42
	MLWorks_1_0_r2_Win32_1997_04_11:1.42
	MLWorks_1_0_r2_Unix_1997_04_04:1.42
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.42.4.1.1
	MLWorks_gui_1996_12_18:1.42.5
	MLWorks_1_0_Win32_1996_12_17:1.42.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.42.2.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.42.2.1
	MLWorks_1_0_Irix_1996_11_28:1.42.2.1.1
	MLWorks_1_0_Win32_1996_11_22:1.42.3
	MLWorks_1_0_Unix_1996_11_14:1.42.2
	MLWorks_Open_Beta2_1996_10_11:1.42.1
	MLWorks_License_dev:1.41.2
	MLWorks_1_open_beta_1996_09_13:1.41.1
	MLWorks_Open_Beta_1996_08_22:1.41
	MLWorks_Beta_1996_07_02:1.40
	MLWorks_Beta_1996_06_07:1.40
	MLWorks_Beta_1996_06_06:1.40
	MLWorks_Beta_1996_06_05:1.40
	MLWorks_Beta_1996_06_03:1.40
	MLWorks_Beta_1996_05_31:1.40
	MLWorks_Beta_1996_05_30:1.40
	ML_beta_release_12/08/94:1.31
	ML_beta_release_03/08/94:1.31
	ML_revised_beta_release_25/05/94:1.31
	ML_final_beta_release_02/03/94:1.29
	mlworks-28-01-1994:1.28
	Release:1.26
	mlworks-beta-01-09-1993:1.26
	MLWorks-1-0-4-29/01/1993:1.20
	MLWorks-1-0-3-21/12/1992:1.19
	MLWorks-1-0-2-15/12/1992:1.19
	MLWorks-1-0-1-04/12/1992:1.19
	checkpoint_17_08_92:1.12
	Ten15_release_19-11-91:1.4
	Ten15_release_21-08-91:1.4
	Ten15_release_19-08-91:1.4
	ten15_release:1.4;
locks; strict;
comment	@ * @;


1.43
date	97.05.01.13.19.07;	author jont;	state Exp;
branches
	1.43.1.1
	1.43.2.1
	1.43.3.1;
next	1.42;

1.42
date	96.10.04.16.16.53;	author andreww;	state Exp;
branches
	1.42.1.1
	1.42.2.1
	1.42.3.1
	1.42.4.1
	1.42.5.1
	1.42.6.1;
next	1.41;

1.41
date	96.08.06.10.32.51;	author andreww;	state Exp;
branches
	1.41.1.1
	1.41.2.1;
next	1.40;

1.40
date	96.03.29.12.28.28;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	96.03.19.15.55.31;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	95.12.27.11.39.11;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.12.18.12.16.04;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	95.03.31.16.23.01;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	95.02.07.16.04.11;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	95.01.30.11.45.58;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.09.22.15.55.56;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	94.08.30.12.19.31;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	94.05.11.14.17.43;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	94.05.04.16.14.50;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	94.02.21.21.44.46;	author nosa;	state Exp;
branches;
next	1.28;

1.28
date	93.12.16.14.20.47;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.09.22.09.28.30;	author nosa;	state Exp;
branches;
next	1.26;

1.26
date	93.06.30.15.39.53;	author daveb;	state Exp;
branches
	1.26.1.1;
next	1.25;

1.25
date	93.04.26.16.22.17;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	93.03.17.18.48.13;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.03.02.16.00.33;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.02.08.18.24.33;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.01.27.12.23.38;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	92.12.22.15.19.03;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.12.03.13.27.32;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.12.01.15.59.44;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	92.11.25.15.38.37;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	92.10.27.19.01.58;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.10.02.16.11.58;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.10.01.12.05.57;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.08.18.15.10.05;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.08.12.13.06.12;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.08.06.17.31.13;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.08.04.18.42.59;	author davidt;	state Exp;
branches;
next	1.9;

1.9
date	92.06.24.17.19.46;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.02.11.10.01.58;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.01.27.20.13.42;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.01.14.17.07.20;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.11.21.16.44.25;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.06.28.16.34.11;	author nickh;	state Exp;
branches;
next	1.3;

1.3
date	91.06.28.15.00.27;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.17.11.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.34.42;	author colin;	state Exp;
branches;
next	;

1.26.1.1
date	93.06.30.15.39.53;	author jont;	state Exp;
branches;
next	;

1.41.1.1
date	96.09.13.11.41.44;	author hope;	state Exp;
branches;
next	;

1.41.2.1
date	96.10.07.16.34.49;	author hope;	state Exp;
branches;
next	;

1.42.1.1
date	96.10.17.11.53.55;	author hope;	state Exp;
branches;
next	;

1.42.2.1
date	96.11.14.13.21.38;	author hope;	state Exp;
branches
	1.42.2.1.1.1;
next	;

1.42.2.1.1.1
date	96.11.28.15.32.36;	author hope;	state Exp;
branches;
next	;

1.42.3.1
date	96.11.22.18.39.16;	author hope;	state Exp;
branches;
next	;

1.42.4.1
date	96.12.17.18.18.17;	author hope;	state Exp;
branches
	1.42.4.1.1.1;
next	;

1.42.4.1.1.1
date	97.02.24.12.12.32;	author hope;	state Exp;
branches;
next	;

1.42.5.1
date	96.12.18.10.13.35;	author hope;	state Exp;
branches;
next	;

1.42.6.1
date	97.05.12.10.51.51;	author hope;	state Exp;
branches
	1.42.6.1.1.1
	1.42.6.1.2.1
	1.42.6.1.3.1;
next	;

1.42.6.1.1.1
date	97.07.28.18.33.39;	author daveb;	state Exp;
branches
	1.42.6.1.1.1.1.1;
next	;

1.42.6.1.1.1.1.1
date	97.10.07.11.59.39;	author jkbrook;	state Exp;
branches;
next	;

1.42.6.1.2.1
date	97.09.08.17.26.45;	author daveb;	state Exp;
branches;
next	;

1.42.6.1.3.1
date	97.09.09.14.23.37;	author daveb;	state Exp;
branches;
next	;

1.43.1.1
date	97.09.10.19.42.33;	author brucem;	state Exp;
branches;
next	;

1.43.2.1
date	97.09.11.21.10.04;	author daveb;	state Exp;
branches;
next	;

1.43.3.1
date	99.04.01.18.08.41;	author daveb;	state Exp;
branches;
next	;


desc
@Datatypes for Basis and Context and associated functions
@


1.43
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* _basis.sml the functor  *)
(*
$Log: _basis.sml,v $
 * Revision 1.42  1996/10/04  16:16:53  andreww
 * [Bug #1592]
 * adding an extra function, tynamesIncludedIn
 *
 * Revision 1.41  1996/08/06  10:32:51  andreww
 * [Bug #1521]
 * Propagating changes made to _types.sml
 *
 * Revision 1.40  1996/03/29  12:28:28  matthew
 * Adding env_to_context function
 *
 * Revision 1.39  1996/03/19  15:55:31  matthew
 * Adding value polymorphism option
 *
 * Revision 1.38  1995/12/27  11:39:11  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.37  1995/12/18  12:16:04  matthew
Changing interface to Scheme

Revision 1.36  1995/03/31  16:23:01  matthew
Use Stamp instead of Tyname_id etc.

Revision 1.35  1995/02/07  16:04:11  matthew
Improvement to unbound long id errors

Revision 1.34  1995/01/30  11:45:58  matthew
Rationalizing debugger

Revision 1.33  1994/09/22  15:55:56  matthew
Efficiency improvements for lookup functions

Revision 1.32  1994/08/30  12:19:31  matthew
Removing diagnostics

Revision 1.31  1994/05/11  14:17:43  daveb
Datatypes.META_OVERLOADED takes extra arguments.  Removed UnresolvedVar
exception, and tidied the close function.

Revision 1.30  1994/05/04  16:14:50  jont
Fix use of check_debruijns to be safe

Revision 1.29  1994/02/21  21:44:46  nosa
generate_moduler compiler option required in type variable instantiation.
n\n\n\n\n\nog: .

Revision 1.28  1993/12/16  14:20:47  matthew
Added level field to Basis.
Levels now allocated from a ref to ensure monotonicity.

Revision 1.27  1993/09/22  09:28:30  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.26  1993/06/30  15:39:53  daveb
Removed exception environments.

Revision 1.25  1993/04/26  16:22:17  jont
Added remove_str for getting rid of FullPervasiveLibrary_ from initial env

Revision 1.24  1993/03/17  18:48:13  matthew
Nameset structure changes

Revision 1.23  1993/03/02  16:00:33  matthew
Rationalised use of Mapping structure

Revision 1.22  1993/02/08  18:24:33  matthew
Changes for BASISTYPES signature

Revision 1.21  1993/01/27  12:23:38  matthew
Changes for COPYSTR representation

Revision 1.20  1992/12/22  15:19:03  jont
Anel's last changes

Revision 1.19  1992/12/03  13:27:32  jont
Modified tyenv for efficiency

Revision 1.18  1992/12/01  15:59:44  matthew
Changed handling of overloaded variable errors.

Revision 1.17  1992/11/25  15:38:37  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.16  1992/10/27  19:01:58  jont
Modified to use less than functions for maps

Revision 1.15  1992/10/02  16:11:58  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.14  1992/10/01  12:05:57  richard
Moved chain reducing code here from _toplevel.

Revision 1.13  1992/08/18  15:10:05  jont
Removed irrelevant handlers and new exceptions

Revision 1.12  1992/08/12  13:06:12  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.11  1992/08/06  17:31:13  jont
Anel's changes to use NewMap instead of Map

Revision 1.9  1992/06/24  17:19:46  jont
Changed to imperative implementation of namesets with hashing

Revision 1.8  1992/02/11  10:01:58  clive
New pervasive library code - cut some things out of the initial type basis

Revision 1.7  1992/01/27  20:13:42  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.6  1992/01/14  17:07:20  jont
Changed ref unit in valenv to ref int to assist encoder

Revision 1.5  1991/11/21  16:44:25  jont
Added copyright message

Revision 1.4  91/06/28  16:34:11  nickh
fixed trivial bug in empty_basis.

Revision 1.3  91/06/28  15:00:27  nickh
Added empty_basis value.

Revision 1.2  91/06/17  17:11:00  nickh
Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures.

Revision 1.1  91/06/07  11:34:42  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "stamp";
require "../utils/lists";
require "../utils/print";
require "../basics/identprint";
require "../typechecker/scheme";
require "../typechecker/valenv";
require "../typechecker/strenv";
require "../typechecker/tyenv";
require "../typechecker/environment";
require "../typechecker/nameset";
require "../typechecker/types";
require "../typechecker/sigma";

require "../typechecker/basis";

functor Basis (
  structure IdentPrint : IDENTPRINT
  structure Valenv : VALENV
  structure Strenv : STRENV
  structure Tyenv : TYENV
  structure Nameset : NAMESET
  structure Scheme : SCHEME
  structure Types : TYPES
  structure Env : ENVIRONMENT
  structure Sigma : SIGMA
  structure Lists : LISTS
  structure Print : PRINT
  structure Stamp : STAMP

  sharing Scheme.Datatypes = Env.Datatypes = Nameset.Datatypes =
    Valenv.Datatypes = Tyenv.Datatypes = Types.Datatypes =
    Strenv.Datatypes = Sigma.BasisTypes.Datatypes
  sharing Valenv.Datatypes.Ident = IdentPrint.Ident
  sharing Scheme.Set = Sigma.BasisTypes.Set

  sharing type Nameset.Nameset = Sigma.BasisTypes.Nameset
  sharing type Stamp.Map.T = Types.Datatypes.StampMap
) : BASIS =

  struct
    structure BasisTypes = Sigma.BasisTypes
    structure Datatypes = Types.Datatypes
    structure Set = Scheme.Set

    type print_options = Scheme.print_options
    type options = Scheme.Options.options
    type error_info = Scheme.error_info

    (****
     This structure contains the datatypes for the semantic objects Basis and 
     Context and the operations on them.
     ****)

    open Datatypes

    exception LookupValId = Valenv.LookupValId
    exception LookupTyCon = Tyenv.LookupTyCon
    exception LookupStrId = Env.LookupStrId

    exception LookupSigId = NewMap.Undefined
    exception LookupFunId = NewMap.Undefined
    exception LookupTyvar = NewMap.Undefined


    (* auxiliary functions that gather the type names from types,
       environments etc. *)

    (* following function strips away metatynames.  This removes
       spurious "unit" type names.  *)

    fun tynameLevelsOK(tyname as TYNAME(_,_,_,_,_,_,_,_,lev)) lev'= 
                        if lev<lev' then [] else [tyname]
      | tynameLevelsOK(METATYNAME(ref tyfun,_,_,_,_,_)) lev = 
                       tyfunLevelsOK tyfun lev

    and tyfunLevelsOK(TYFUN(t,_)) l= typeLevelsOK t l
      | tyfunLevelsOK(ETA_TYFUN tyname) l= tynameLevelsOK tyname l
      | tyfunLevelsOK(NULL_TYFUN (stamp,ref tyfun)) l =
        tyfunLevelsOK tyfun l
        
    and typeLevelsOK(METATYVAR(ref (_,t,_),_,_)) l=
        typeLevelsOK t l
      | typeLevelsOK(META_OVERLOADED(ref t,_,_,_)) l =
        typeLevelsOK t l
      | typeLevelsOK(TYVAR(ref(_,t,_),_)) l =
        typeLevelsOK t l
      | typeLevelsOK(METARECTYPE(ref(_,_,t,_,_))) l =
        typeLevelsOK t l
      | typeLevelsOK(RECTYPE(amap)) l =
        Datatypes.NewMap.fold (fn (acc,_,t)=> acc@@(typeLevelsOK t l))
        ([],amap)
      | typeLevelsOK(FUNTYPE(t,t')) l =
        (typeLevelsOK t l) @@ (typeLevelsOK t' l)
      | typeLevelsOK(CONSTYPE(tylist,tyname)) l =
        (Lists.reducel (fn (acc,t) => acc@@(typeLevelsOK t l))
         (tynameLevelsOK tyname l,tylist))
      | typeLevelsOK(DEBRUIJN(_,_,_,t)) l =
        (case t of NONE => []
      | (SOME (ref (_,t',_))) => typeLevelsOK t' l)
      | typeLevelsOK NULLTYPE _ = []
        
    fun tyschemeLevelsOK (SCHEME(_,(t,_))) l = typeLevelsOK t l
      | tyschemeLevelsOK (UNBOUND_SCHEME(t,_)) l = typeLevelsOK t l
      | tyschemeLevelsOK (OVERLOADED_SCHEME _) _ = []
        
        
    fun valenvLevelsOK (VE (_,vmap)) lev =
      Lists.reducel
      (fn (acc,tscheme) => (tyschemeLevelsOK tscheme lev)@@acc)
      ([],Datatypes.NewMap.range vmap)
      
    fun tyenvLevelsOK(TE amap) lev =
      Lists.reducel (fn (acc,TYSTR(tyFun,_)) => (tyfunLevelsOK tyFun lev)@@acc)
      ([],Datatypes.NewMap.range amap)
      
    fun strEnvLevelsOK (SE smap) lev = 
      let
        fun structureLevelsOK(STR(_,_,env)) l = envLevelsOK env l
          | structureLevelsOK(COPYSTR((_,t),s)) l = 
            (Stamp.Map.range t) @@ (structureLevelsOK s l)
      in
        Lists.reducel (fn (acc,s) => acc @@ (structureLevelsOK s lev))
        ([],Datatypes.NewMap.range smap)
      end

    and envLevelsOK (ENV(strEnv ,tyEnv, valEnv)) l =
      (strEnvLevelsOK  strEnv l)@@(valenvLevelsOK valEnv l)@@
      (tyenvLevelsOK tyEnv l)


    (* tyvarenvs *)

    val empty_tyvarenv = BasisTypes.TYVARENV (NewMap.empty (Ident.tyvar_lt, 
                                                            Ident.tyvar_eq))

    fun tyvarenv_lookup (tyvar, BasisTypes.TYVARENV amap) = 
      NewMap.apply'(amap, tyvar)

    fun add_to_tyvarenv (alevel,tyvar,BasisTypes.TYVARENV amap) =
      BasisTypes.TYVARENV 
      (NewMap.define 
       (amap,tyvar,Datatypes.TYVAR(ref (alevel,
                   Datatypes.NULLTYPE,Datatypes.NO_INSTANCE),tyvar)))

    (* funenvs *)

    val empty_funenv = BasisTypes.FUNENV (NewMap.empty (Ident.funid_lt, Ident.funid_eq))
      
    fun add_to_funenv (funid,phi,BasisTypes.FUNENV amap) = 
      BasisTypes.FUNENV (NewMap.define (amap,funid,phi))
	      
    fun funenv_lookup (funid,BasisTypes.FUNENV amap) =
      NewMap.apply'(amap, funid)

    fun funenv_plus_funenv (BasisTypes.FUNENV amap,BasisTypes.FUNENV amap') = 
      BasisTypes.FUNENV (NewMap.union(amap, amap'))

    (* sigenvs *)

    val empty_sigenv = BasisTypes.SIGENV (NewMap.empty (Ident.sigid_lt, Ident.sigid_eq))

    fun add_to_sigenv (sigid,asig,BasisTypes.SIGENV amap) = 
      BasisTypes.SIGENV (NewMap.define (amap,sigid,asig))

    fun sigenv_lookup (sigid,BasisTypes.SIGENV amap) = 
      NewMap.apply'(amap, sigid)

    fun sigenv_plus_sigenv (BasisTypes.SIGENV amap,BasisTypes.SIGENV amap') =
      BasisTypes.SIGENV (NewMap.union(amap, amap'))

    (* Functions for looking up different values in the Context. *)

    fun lookup_tyvar (tyvar,BasisTypes.CONTEXT (_,_,_,tyvarenv)) =
      tyvarenv_lookup (tyvar,tyvarenv) 

    fun lookup_longtycon (longtycon,
                          BasisTypes.CONTEXT (_,_,env,_)) = 
      Env.lookup_longtycon (longtycon,env)

    fun lookup_val (longvalid,BasisTypes.CONTEXT (level,_,env,_),
                    location,generate_moduler) =
      let 
	val scheme = Env.lookup_longvalid (longvalid,env)
      in
	Scheme.instantiate (level, scheme, location, generate_moduler)
      end 


    fun lookup_tycon (tycon,BasisTypes.CONTEXT (_,_,ENV (_,te,_),_)) =
      Tyenv.lookup (te, tycon)

    (* This is used for setting levels in Basises and Contexts *)
    (* The requirement is for monotonically increasing allocation
       of level numbers *)
    (* When we have full concurrency this might still work *)
      
    val level_num_ref = ref 0

    fun new_level_num () = 
      let val new = 1 + (!level_num_ref) 
      in level_num_ref := new; new 
      end

    (****
     Modifications of the Context.
     ****)

    fun context_plus_ve (BasisTypes.CONTEXT (alevel,tyvars,
                                             ENV (se,te,ve),tyvarenv),ve') =
      BasisTypes.CONTEXT (new_level_num(),
                          tyvars,
                          ENV (se,te,Valenv.ve_plus_ve (ve,ve')),
                          tyvarenv)

    fun context_plus_te (BasisTypes.CONTEXT (level,tyvarset,
				  ENV (se,te,ve),tyvarenv),te') = 
      BasisTypes.CONTEXT (level,
                          tyvarset,
                          ENV (se,Tyenv.te_plus_te (te,te'),ve),
                          tyvarenv)

    fun context_plus_tyvarset (BasisTypes.CONTEXT(level,tyvars,
                                                  env,tyvarenv), tyvarset) =
      let 
	fun collect (tve, tv) = add_to_tyvarenv (level, tv, tve)
      in
	BasisTypes.CONTEXT (level,Set.union (tyvars,tyvarset), env,
                            Set.fold collect (tyvarenv,tyvarset))
      end


    fun context_plus_tyvarlist (BasisTypes.CONTEXT(level,
                                                   tyvars,env,tyvarenv), 
                                tyvarlist) =
      let
        fun collect ([],amap) = amap
          | collect (h::t,amap) =
            add_to_tyvarenv (level,h, collect(t,amap))
        fun make_tyvarenv (tyvars) =
          collect (tyvars, empty_tyvarenv)
      in
        BasisTypes.CONTEXT (level,tyvars,env,make_tyvarenv tyvarlist)
      end

    fun context_plus_env (BasisTypes.CONTEXT (alevel,tyvars,
                                              env,tyvarenv),env') =
      BasisTypes.CONTEXT (new_level_num(),
                          tyvars,
                          Env.env_plus_env (env,env'),tyvarenv)

    fun context_for_datbind (BasisTypes.CONTEXT (level,tyvarset,
                                                 ENV(se,te,ve),_),
                             location,
                             dummy_tycons) =
      let
        val loc_string = SOME location
        fun make_dummy_te ([],te) = te
          | make_dummy_te ((tyvars,tycon)::t,te) = 
            make_dummy_te(t,
                          Tyenv.add_to_te
                          (te, tycon,
                           TYSTR
                           (Types.make_eta_tyfun
                            (Types.make_tyname 
                             (Lists.length tyvars,
                              true,
                              IdentPrint.printTyCon tycon,
                              loc_string,level)),
                            empty_valenv)))
      in
        BasisTypes.CONTEXT (level,tyvarset,
                            ENV (se,make_dummy_te (dummy_tycons,te),ve),
                            empty_tyvarenv)
      end

    (****
     Closure as defined on p. 21 of The Definition.
     ****)

    fun close 
      (error_info,options,location)
      (alevel,VE (r,amap),exp_vars,tyvars_scoped_here,asig) =
      let 
  	fun close_ve (tree, valid, scheme) =
	  let
	    val scheme' =
	      Scheme.schemify 
              (error_info,options,location)
              (alevel,Lists.member (valid,exp_vars),
               scheme,tyvars_scoped_here,asig)
	  in
	    NewMap.define(tree, valid, scheme')
	  end
      in
	VE(ref 0,
	   NewMap.fold
	     close_ve
	     (NewMap.empty (Ident.valid_lt, Ident.valid_eq), amap))
      end
	
    (****
     Projection operations on the Context.
     ****)

    fun env_of_context (BasisTypes.CONTEXT (_,_,env,_)) = env

    fun te_of_context (BasisTypes.CONTEXT (_,_,ENV (_,te,_),_)) = te

    (****
     Various operations on the Context.
     ****)

    fun env_to_context env = BasisTypes.CONTEXT (0,Set.empty_set,env,
                                                 empty_tyvarenv)

    fun context_level (BasisTypes.CONTEXT (alevel,_,_,_)) = alevel

    fun get_tyvarset (BasisTypes.CONTEXT (_,tyvars,_,_)) = tyvars

    fun basis_to_context (BasisTypes.BASIS (level,_,_,_,env)) = 
      BasisTypes.CONTEXT (level,
                          Set.empty_set,env,empty_tyvarenv)
      
    (****
     Functions for looking up various values in the Basis.
     ****)

    fun lookup_sigid (sigid,BasisTypes.BASIS (_,_,_,sigenv,_)) = 
      sigenv_lookup (sigid,sigenv)

    fun lookup_longstrid (longstrid,BasisTypes.BASIS (_,_,_,_,env)) =
      Env.lookup_longstrid (longstrid,env)

    fun lookup_funid (funid,BasisTypes.BASIS (_,_,funenv,_,env)) = 
      funenv_lookup (funid,funenv)

    (****
     Injection operations into the basis.
     ****)

    (* These all seem to be only used for topdecs, so make level be 0 *)
    fun env_in_basis env = BasisTypes.BASIS (0,
                                             Nameset.empty_nameset(),
                                             empty_funenv,
                                             empty_sigenv,
                                             env)

    fun sigenv_in_basis sigenv = BasisTypes.BASIS (0,
                                                   Nameset.empty_nameset (),
                                                   empty_funenv,sigenv,
                                                   Env.empty_env)

    fun funenv_in_basis funenv = BasisTypes.BASIS (0,
                                                   Nameset.empty_nameset (),
                                                   funenv,
                                                   empty_sigenv,
                                                   Env.empty_env)

    (****
     Modifications of the Basis.
     ****)

    fun basis_plus_env (BasisTypes.BASIS (level,names,funenv,sigenv,env),
                        env') = 
      let
(*        val newNames = Nameset.nameset_of_name_lists(tynamesInEnv env',[])*)
      in
        BasisTypes.BASIS (new_level_num(),
                          (*Nameset.union(names,newNames),*) names,
                          funenv,sigenv,
                          Env.env_plus_env (env,env'))
      end


    fun basis_plus_sigenv (BasisTypes.BASIS (level,names,funenv,sigenv,env),
                           sigenv') = 
      BasisTypes.BASIS (level,names,funenv,
                        sigenv_plus_sigenv (sigenv,sigenv'),env)

    fun basis_plus_funenv (BasisTypes.BASIS (level,names,funenv,sigenv,env),
                           funenv') = 
      BasisTypes.BASIS (level,names,funenv_plus_funenv (funenv,funenv'),
                        sigenv,env)

    fun basis_plus_names (BasisTypes.BASIS (level,names,funenv,sigenv,env),
                          names') = 
      BasisTypes.BASIS (level,Nameset.union (names,names'),funenv,sigenv,env)


    fun basis_circle_plus_basis
             (BasisTypes.BASIS (level,names,funenv,sigenv,env),
	      BasisTypes.BASIS (level',names',funenv',sigenv',env')) = 
      BasisTypes.BASIS (new_level_num(),
                        Nameset.union (names,names'),
                        funenv_plus_funenv (funenv,funenv'),
                        sigenv_plus_sigenv (sigenv,sigenv'),
                        Env.env_plus_env (env,env'))

(* unused
    fun basis_plus_basis 
         (BasisTypes.BASIS (level,names,funenv,sigenv,env),
	  BasisTypes.BASIS (level',names',funenv',sigenv',env')) = 
      BasisTypes.BASIS (new_level_num(),
                        names,
                        funenv_plus_funenv (funenv,funenv'),
                        sigenv_plus_sigenv (sigenv,sigenv'),
                        Env.env_plus_env (env,env'))

*)
    fun basis_level (BasisTypes.BASIS{1=level,...}) = level

    val initial_basis =
      BasisTypes.BASIS (0,
                        Nameset.initial_nameset,
                        empty_funenv,
                        empty_sigenv,
                        Env.initial_env)

    val initial_basis_for_builtin_library =
      BasisTypes.BASIS (0,
                        Nameset.initial_nameset_for_builtin_library,
                        empty_funenv,
                        empty_sigenv,
                        Env.initial_env_for_builtin_library)

    val empty_basis = 
      BasisTypes.BASIS (0,
                        Nameset.empty_nameset (),
                        empty_funenv,
                        empty_sigenv,
                        Env.empty_env)

    fun remove_str(BasisTypes.BASIS(level,n, f, s, ENV(SE map, te, ve)),
                   strid) =
      BasisTypes.BASIS(level,n, f, s, ENV(SE(NewMap.undefine(map, strid)),
                                          te, ve))

    fun add_str (BasisTypes.BASIS (level,nameset, functor_env, signature_env,
                                   Datatypes.ENV (structure_env, type_env,
                                                  value_env)),
                 strid, str) =
      let
        val new_structure_env = Strenv.add_to_se (strid, str, structure_env)
      in
        BasisTypes.BASIS (level,nameset, functor_env, signature_env,
                          Datatypes.ENV (new_structure_env, type_env,
                                         value_env))
      end

    fun add_val (BasisTypes.BASIS (level, nameset, functor_env, signature_env,
                                   Datatypes.ENV (structure_env, type_env,
                                                  value_env)),
                 valid, scheme) =
      let
        val new_value_env = Valenv.add_to_ve (valid, scheme, value_env)
      in
        BasisTypes.BASIS (level, nameset, functor_env, signature_env,
                          Datatypes.ENV (structure_env, type_env,
                                         new_value_env))
      end

    local
      fun follow_tyname(arg as TYNAME _) = arg
        | follow_tyname(arg as METATYNAME{1=ref(NULL_TYFUN _), ...}) = arg
        | follow_tyname(METATYNAME{1=ref(ETA_TYFUN tyname), ...}) =
          follow_tyname tyname
        | follow_tyname(METATYNAME{1=ref(TYFUN(CONSTYPE([], tyname), 0)),
                                   ...}) = follow_tyname tyname
        | follow_tyname tyname = tyname

      fun follow_tyfun(arg as NULL_TYFUN _) = arg
        | follow_tyfun(arg as ETA_TYFUN(TYNAME _)) = arg
        | follow_tyfun(ETA_TYFUN(METATYNAME{1=ref tyfun, ...})) =
          follow_tyfun tyfun
        | follow_tyfun(tyfun as
                            TYFUN(CONSTYPE(l, tyname), 0)) =
          if Types.tyname_arity tyname = 0 andalso 
             Types.check_debruijns(l, 0) then
            follow_tyfun(ETA_TYFUN tyname)
          else
            tyfun
        | follow_tyfun tyfun = tyfun

      fun long_follow_tyfun(arg as NULL_TYFUN _) = arg
        | long_follow_tyfun(arg as ETA_TYFUN(TYNAME _)) = arg
        | long_follow_tyfun(arg as ETA_TYFUN(METATYNAME{1=ref(NULL_TYFUN _),
                                                        ...})) =
          arg
        | long_follow_tyfun(ETA_TYFUN(METATYNAME{1=ref tyfun, ...})) =
          long_follow_tyfun tyfun
        | long_follow_tyfun(tyfun as
                            TYFUN(CONSTYPE(l, tyname), 0)) =
          if Types.tyname_arity tyname = 0 andalso 
             Types.check_debruijns(l, 0) then
            long_follow_tyfun(ETA_TYFUN tyname)
          else
            tyfun
        | long_follow_tyfun tyfun = tyfun

      fun follow_strname(arg as STRNAME _) = arg
        | follow_strname(arg as NULLNAME _) = arg
        | follow_strname(arg as
                         METASTRNAME(ref(NULLNAME _))) =
          arg
        | follow_strname(arg as METASTRNAME(ref strname)) =
          follow_strname strname

      fun reduce_strname(arg as STRNAME _) = ()
        | reduce_strname(arg as NULLNAME _) = ()
        | reduce_strname(METASTRNAME(r as ref strname)) =
          r := follow_strname strname

      fun reduce_tyfun(arg as NULL_TYFUN _) = ()
        | reduce_tyfun(arg as ETA_TYFUN(METATYNAME{1=ref(NULL_TYFUN _), 
                                                   ...})) =
          ()
        | reduce_tyfun(ETA_TYFUN(METATYNAME{1=r as ref tyfun,
                                            5=ref_ve, ...})) =
          let
            val tyfun = long_follow_tyfun tyfun
          in
            (case tyfun of
               ETA_TYFUN _ => ref_ve := empty_valenv
             | _ => ());
               r := tyfun
          end
        | reduce_tyfun(ETA_TYFUN _) = ()
        | reduce_tyfun(TYFUN(ty, _)) = reduce_type ty

      and reduce_tyname(arg as TYNAME _) = ()
        | reduce_tyname(arg as METATYNAME{1=ref(NULL_TYFUN _), ...}) =
          ()
        | reduce_tyname(arg as METATYNAME{1=r as ref tyfun,
                                                    5=ref_ve, ...}) =
          let
            val tyfun = long_follow_tyfun tyfun
          in
            (case tyfun of
               ETA_TYFUN _ => ref_ve := empty_valenv
             | _ => ());
               r := tyfun
          end

      and reduce_scheme(SCHEME(_, (ty,_))) = reduce_type ty
        | reduce_scheme(UNBOUND_SCHEME (ty,_)) = reduce_type ty
        | reduce_scheme _ = ()

      and reduce_type(METATYVAR(ref(_, ty,_), _, _)) = reduce_type ty
        | reduce_type(META_OVERLOADED {1=ref ty,...}) =
	  reduce_type ty
        | reduce_type(TYVAR _) = ()
        | reduce_type(METARECTYPE(ref{3=ty, ...})) = reduce_type ty
        | reduce_type(ty as RECTYPE _) =
          Lists.iterate reduce_type (Types.rectype_range ty)
        | reduce_type(FUNTYPE(ty1, ty2)) =
          (reduce_type ty1;
           reduce_type ty2)
        | reduce_type(CONSTYPE(l, tyname)) =
          (Lists.iterate reduce_type l;
           reduce_tyname tyname)
        | reduce_type _ = ()

      and reduce_valenv(VE(_, ve_map)) =
        NewMap.iterate (fn (_, type_scheme) => reduce_scheme type_scheme)
                       ve_map

      fun reduce_str(STR(strname,_,env)) =
        (reduce_strname strname; reduce_env env)
        | reduce_str (COPYSTR((smap,tmap),str)) = 
          (* try this *) (* HACK *) (* This is  bad news *)
          reduce_str (Env.str_copy(str,smap,tmap))
(*
          let
            (* don't need to construct new maps here *)
            val smap' = Strname_id.Map.map (fn (_,strname) => (reduce_strname strname)) smap
            val tmap' = Tyfun_id.Map.map (fn (_,tyname) => (reduce_tyname tyname)) tmap
          in
            ()
          end
*)

      and reduce_env(ENV(SE strenv,
                                   TE tyenv,
                                   ve)) =
        (NewMap.iterate (fn (_, str) => reduce_str str) strenv;
         NewMap.iterate (fn (_, TYSTR(tyfun, ve)) =>
                         (reduce_valenv ve;
                          reduce_tyfun tyfun)) tyenv;
         reduce_valenv ve)

      fun reduce_nameset nameset =
        (Lists.iterate reduce_strname (Nameset.strnames_of_nameset nameset);
         Lists.iterate reduce_tyname (Nameset.tynames_of_nameset nameset))

      fun reduce_sigma(BasisTypes.SIGMA(nameset, str)) =
        (reduce_nameset nameset; reduce_str str)

    in

      fun reduce_chains (BasisTypes.BASIS(_,
                                          nameset, 
                                          BasisTypes.FUNENV funid_map,
                                          BasisTypes.SIGENV sigid_map, env)) =
        let
          val _ = reduce_nameset nameset
          val _ = NewMap.iterate
            (fn (_, BasisTypes.PHI(nameset, (str, sigma))) =>
             let
               val _ = reduce_nameset nameset
               val _ = reduce_str str
             in
               reduce_sigma sigma
             end)
            funid_map
          val _ = NewMap.iterate (fn (_, sigma) => reduce_sigma sigma)
                                 sigid_map
        in
          reduce_env env
        end
    end

    val pervasive_stamp_count = Types.pervasive_stamp_count


      (* The following function returns all the type names
         occurring within a type that were not also defined within a
         given context.  This is used to make sure that hidden value
         constructors do not escape. See rule 6 of _core_rules.sml *)

      fun tynamesNotIn (t,BasisTypes.CONTEXT(level,_,_,_)) =
        typeLevelsOK t level

      (* This function returns all the type names occurring within a 
         valenv that didn't also occur within a given context.
         This is used to check that no hidden type names escape
         through pattern matching (_core_rules.sml rules 15 and 16)
         and "val rec"s (_core_rules.sml rule 27) *)

      fun valEnvTynamesNotIn (valenv, BasisTypes.CONTEXT(level,_,_,_)) =
        valenvLevelsOK valenv level


end
@


1.43.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.43  1997/05/01  13:19:07  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.43.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.43  1997/05/01  13:19:07  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.43.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.43  1997/05/01  13:19:07  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.42
log
@[Bug #1592]
adding an extra function, tynamesIncludedIn
@
text
@d4 4
d394 1
a394 1
        val loc_string = MLWorks.Option.SOME location
@


1.42.6.1
log
@branched from 1.42
@
text
@a3 4
 * Revision 1.42  1996/10/04  16:16:53  andreww
 * [Bug #1592]
 * adding an extra function, tynamesIncludedIn
 *
@


1.42.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.42.6.1  1997/05/12  10:51:51  hope
 * branched from 1.42
 *
@


1.42.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.42.6.1  1997/05/12  10:51:51  hope
 * branched from 1.42
 *
@


1.42.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.42.6.1  1997/05/12  10:51:51  hope
 * branched from 1.42
 *
@


1.42.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.42.6.1.1.1  1997/07/28  18:33:39  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.42.5.1
log
@branched from 1.42
@
text
@a3 4
 * Revision 1.42  1996/10/04  16:16:53  andreww
 * [Bug #1592]
 * adding an extra function, tynamesIncludedIn
 *
@


1.42.4.1
log
@branched from 1.42
@
text
@a3 4
 * Revision 1.42  1996/10/04  16:16:53  andreww
 * [Bug #1592]
 * adding an extra function, tynamesIncludedIn
 *
@


1.42.4.1.1.1
log
@branched from 1.42.4.1
@
text
@a3 3
 * Revision 1.42.4.1  1996/12/17  18:18:17  hope
 * branched from 1.42
 *
@


1.42.3.1
log
@branched from 1.42
@
text
@a3 4
 * Revision 1.42  1996/10/04  16:16:53  andreww
 * [Bug #1592]
 * adding an extra function, tynamesIncludedIn
 *
@


1.42.2.1
log
@branched from 1.42
@
text
@a3 4
 * Revision 1.42  1996/10/04  16:16:53  andreww
 * [Bug #1592]
 * adding an extra function, tynamesIncludedIn
 *
@


1.42.2.1.1.1
log
@branched from 1.42.2.1
@
text
@a3 3
 * Revision 1.42.2.1  1996/11/14  13:21:38  hope
 * branched from 1.42
 *
@


1.42.1.1
log
@branched from 1.42
@
text
@a3 4
 * Revision 1.42  1996/10/04  16:16:53  andreww
 * [Bug #1592]
 * adding an extra function, tynamesIncludedIn
 *
@


1.41
log
@[Bug #1521]
Propagating changes made to _types.sml
@
text
@d1 1
a1 1
(* _basis.sml the functor *)
d4 4
d135 1
d162 1
d171 1
d198 67
d267 2
a268 1
    val empty_tyvarenv = BasisTypes.TYVARENV (NewMap.empty (Ident.tyvar_lt, Ident.tyvar_eq))
d322 1
d327 2
a328 1
    (* The requirement is for monotonically increasing allocation of level numbers *)
d333 4
a336 1
    fun new_level_num () = let val new = 1 + (!level_num_ref) in level_num_ref := new; new end
d342 5
a346 2
    fun context_plus_ve (BasisTypes.CONTEXT (alevel,tyvars,ENV (se,te,ve),tyvarenv),ve') =
      BasisTypes.CONTEXT (new_level_num(),tyvars,ENV (se,te,Valenv.ve_plus_ve (ve,ve')),
d351 2
a352 1
      BasisTypes.CONTEXT (level,tyvarset,
d356 2
a357 1
    fun context_plus_tyvarset (BasisTypes.CONTEXT(level,tyvars,env,tyvarenv), tyvarset) =
d365 4
a368 1
    fun context_plus_tyvarlist (BasisTypes.CONTEXT(level,tyvars,env,tyvarenv), tyvarlist) =
d379 5
a383 2
    fun context_plus_env (BasisTypes.CONTEXT (alevel,tyvars,env,tyvarenv),env') =
      BasisTypes.CONTEXT (new_level_num(),tyvars,Env.env_plus_env (env,env'),tyvarenv)
d385 2
a386 1
    fun context_for_datbind (BasisTypes.CONTEXT (level,tyvarset,ENV(se,te,ve),_),
d402 1
a402 1
                              loc_string)),
d447 2
a448 1
    fun env_to_context env = BasisTypes.CONTEXT (0,Set.empty_set,env,empty_tyvarenv)
d455 2
a456 1
      BasisTypes.CONTEXT (level,Set.empty_set,env,empty_tyvarenv)
d477 1
a477 1
                                             Nameset.empty_nameset (),
d497 10
a506 2
    fun basis_plus_env (BasisTypes.BASIS (level,names,funenv,sigenv,env),env') = 
      BasisTypes.BASIS (new_level_num(),names,funenv,sigenv,Env.env_plus_env (env,env'))
a507 2
    fun basis_plus_sigenv (BasisTypes.BASIS (level,names,funenv,sigenv,env),sigenv') = 
      BasisTypes.BASIS (level,names,funenv,sigenv_plus_sigenv (sigenv,sigenv'),env)
d509 9
a517 2
    fun basis_plus_funenv (BasisTypes.BASIS (level,names,funenv,sigenv,env),funenv') = 
      BasisTypes.BASIS (level,names,funenv_plus_funenv (funenv,funenv'),sigenv,env)
d519 2
a520 1
    fun basis_plus_names (BasisTypes.BASIS (level,names,funenv,sigenv,env),names') = 
d524 3
a526 2
    fun basis_circle_plus_basis (BasisTypes.BASIS (level,names,funenv,sigenv,env),
				 BasisTypes.BASIS (level',names',funenv',sigenv',env')) = 
d533 4
a536 2
    fun basis_plus_basis (BasisTypes.BASIS (level,names,funenv,sigenv,env),
			  BasisTypes.BASIS (level',names',funenv',sigenv',env')) = 
d543 1
d567 4
a570 2
    fun remove_str(BasisTypes.BASIS(level,n, f, s, ENV(SE map, te, ve)), strid) =
      BasisTypes.BASIS(level,n, f, s, ENV(SE(NewMap.undefine(map, strid)), te, ve))
d573 2
a574 1
                                   Datatypes.ENV (structure_env, type_env, value_env)),
d580 2
a581 1
                          Datatypes.ENV (new_structure_env, type_env, value_env))
d585 2
a586 1
                                   Datatypes.ENV (structure_env, type_env, value_env)),
d592 2
a593 1
                          Datatypes.ENV (structure_env, type_env, new_value_env))
d599 4
a602 2
        | follow_tyname(METATYNAME{1=ref(ETA_TYFUN tyname), ...}) = follow_tyname tyname
        | follow_tyname(METATYNAME{1=ref(TYFUN(CONSTYPE([], tyname), 0)), ...}) = follow_tyname tyname
d611 2
a612 1
          if Types.tyname_arity tyname = 0 andalso Types.check_debruijns(l, 0) then
d620 2
a621 1
        | long_follow_tyfun(arg as ETA_TYFUN(METATYNAME{1=ref(NULL_TYFUN _), ...})) =
d627 2
a628 1
          if Types.tyname_arity tyname = 0 andalso Types.check_debruijns(l, 0) then
d648 2
a649 1
        | reduce_tyfun(arg as ETA_TYFUN(METATYNAME{1=ref(NULL_TYFUN _), ...})) =
d652 1
a652 1
                                                                5=ref_ve, ...})) =
d698 2
a699 1
        NewMap.iterate (fn (_, type_scheme) => reduce_scheme type_scheme) ve_map
d749 2
a750 1
          val _ = NewMap.iterate (fn (_, sigma) => reduce_sigma sigma) sigid_map
d757 19
@


1.41.2.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/08/06  10:32:51  andreww
 * [Bug #1521]
 * Propagating changes made to _types.sml
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/08/06  10:32:51  andreww
 * [Bug #1521]
 * Propagating changes made to _types.sml
 *
@


1.40
log
@Adding env_to_context function
@
text
@d4 3
d173 1
d323 1
a323 1
      (use_value_polymorphism,error_info,print_options,location)
d330 2
a331 2
              (error_info,print_options,location)
              (use_value_polymorphism,alevel,Lists.member (valid,exp_vars),
@


1.39
log
@Adding value polymorphism option
@
text
@d4 3
d350 2
@


1.38
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d316 1
a316 1
      (error_info,print_options,location)
d324 1
a324 1
              (alevel,Lists.member (valid,exp_vars),
@


1.37
log
@Changing interface to Scheme
@
text
@d4 3
d231 5
a235 5
        let 
          val scheme = Env.lookup_longvalid (longvalid,env)
        in
          Scheme.instantiate (level, scheme, location, generate_moduler)
        end 
d288 1
a288 1
        val loc_string = Datatypes.Option.PRESENT location
@


1.36
log
@Use Stamp instead of Tyname_id etc.
@
text
@d4 3
d160 3
a177 2
    exception CloseError of (string * Type)

d309 3
a311 1
    fun close (alevel,VE (r,amap),exp_vars,tyvars_scoped_here,asig) =
d316 4
a319 2
	      Scheme.schemify (alevel,Lists.member (valid,exp_vars),
			       scheme,tyvars_scoped_here,asig)
a328 2
      handle
        Scheme.MakeScheme s => raise CloseError s
@


1.35
log
@Improvement to unbound long id errors
@
text
@d4 3
d558 1
a558 1
          (* try this *) (* HACK *)
d609 1
a609 3
    val pervasive_strname_count = Strenv.pervasive_strname_count
    val pervasive_tyname_count = Types.pervasive_tyname_count
    val pervasive_tyfun_count = Types.pervasive_tyfun_count
@


1.34
log
@Rationalizing debugger
@
text
@d4 3
d118 1
a120 3
require "../typechecker/tyvarenv";
require "../typechecker/sigenv";
require "../typechecker/funenv";
d123 2
d129 2
a130 4
  structure Tyvarenv : TYVARENV
  structure Sigenv : SIGENV
  structure Funenv : FUNENV
  structure Conenv : VALENV
d136 1
a136 1

d140 5
a144 9
  sharing Sigenv.BasisTypes = Funenv.BasisTypes = Tyvarenv.BasisTypes

  sharing Sigenv.BasisTypes.Datatypes =
    Scheme.Datatypes = Env.Datatypes = Nameset.Datatypes =
    Conenv.Datatypes = Tyenv.Datatypes = Types.Datatypes
  sharing Conenv.Datatypes.Ident = IdentPrint.Ident
  sharing Scheme.Set = Sigenv.BasisTypes.Set

  sharing type Nameset.Nameset = Sigenv.BasisTypes.Nameset
d146 1
d150 1
a150 1
    structure BasisTypes = Sigenv.BasisTypes
a151 2
    structure Sigenv = Sigenv
    structure Funenv = Funenv
d161 7
a167 6
    exception LookupValId_in_Context
    exception LookupLongTyCon
    exception LookupTyCon = Tyenv.Lookup_in_TE
    exception LookupSigId = Sigenv.Lookup_SigId
    exception LookupLongStrId = Env.Lookup_LongStrId
    exception LookupFunId = Funenv.Lookup_FunId
d171 43
a213 3
    (****
     Functions for looking up different values in the Context.
     ****)
a217 2
      handle Tyenv.Lookup_in_TE => raise LookupLongTyCon
           | Env.Lookup_StrId => raise LookupLongTyCon 
a225 2
      handle Env.Lookup_StrId => raise LookupValId_in_Context
           | Conenv.Lookup_in_VE => raise LookupValId_in_Context
d227 2
a228 2
    fun lookup_tycon (tycon,BasisTypes.CONTEXT (_,_,ENV (_,tyenv,_),_)) =
      Tyenv.lookup (tyenv, tycon)
d243 1
a243 1
      BasisTypes.CONTEXT (new_level_num(),tyvars,ENV (se,te,Conenv.ve_plus_ve (ve,ve')),
d249 2
a250 1
	       ENV (se,Tyenv.te_plus_te (te,te'),ve),tyvarenv)
d252 1
a252 2
    fun context_plus_tyvarset_and_tyvarenv(BasisTypes.CONTEXT(level,tyvars,env,tyvarenv),
					   tyvarset) =
d254 1
a254 1
	fun collect (tve, tv) = Tyvarenv.add_to_tyvarenv (level, tv, tve)
d257 12
a268 1
		 Set.fold collect (tyvarenv,tyvarset))
d274 24
d327 1
a327 2
    fun te_of_context (BasisTypes.CONTEXT (_,_,env,_)) = 
      Env.te_of_env env
d338 1
a338 1
      BasisTypes.CONTEXT (level,Set.empty_set,env,Tyvarenv.empty_tyvarenv)
d345 1
a345 1
      Sigenv.lookup (sigid,sigenv)
d351 1
a351 1
      Funenv.lookup (funid,funenv)
d360 2
a361 2
                                             Funenv.empty_funenv,
                                             Sigenv.empty_sigenv,
d366 1
a366 1
                                                   Funenv.empty_funenv,sigenv,
d372 1
a372 1
                                                   Sigenv.empty_sigenv,
d383 1
a383 1
      BasisTypes.BASIS (level,names,funenv,Sigenv.sigenv_plus_sigenv (sigenv,sigenv'),env)
d386 1
a386 1
      BasisTypes.BASIS (level,names,Funenv.funenv_plus_funenv (funenv,funenv'),sigenv,env)
d396 2
a397 2
                        Funenv.funenv_plus_funenv (funenv,funenv'),
                        Sigenv.sigenv_plus_sigenv (sigenv,sigenv'),
d404 2
a405 2
                        Funenv.funenv_plus_funenv (funenv,funenv'),
                        Sigenv.sigenv_plus_sigenv (sigenv,sigenv'),
d413 2
a414 2
                        Funenv.empty_funenv,
                        Sigenv.empty_sigenv,
d420 2
a421 2
                        Funenv.empty_funenv,
                        Sigenv.empty_sigenv,
d427 2
a428 2
                        Funenv.empty_funenv,
                        Sigenv.empty_sigenv,
d434 20
d455 4
a458 4
      fun follow_tyname(arg as Datatypes.TYNAME _) = arg
        | follow_tyname(arg as Datatypes.METATYNAME{1=ref(Datatypes.NULL_TYFUN _), ...}) = arg
        | follow_tyname(Datatypes.METATYNAME{1=ref(Datatypes.ETA_TYFUN tyname), ...}) = follow_tyname tyname
        | follow_tyname(Datatypes.METATYNAME{1=ref(Datatypes.TYFUN(Datatypes.CONSTYPE([], tyname), 0)), ...}) = follow_tyname tyname
d461 3
a463 3
      fun follow_tyfun(arg as Datatypes.NULL_TYFUN _) = arg
        | follow_tyfun(arg as Datatypes.ETA_TYFUN(Datatypes.TYNAME _)) = arg
        | follow_tyfun(Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=ref tyfun, ...})) =
d466 1
a466 1
                            Datatypes.TYFUN(Datatypes.CONSTYPE(l, tyname), 0)) =
d468 1
a468 1
            follow_tyfun(Datatypes.ETA_TYFUN tyname)
d473 3
a475 3
      fun long_follow_tyfun(arg as Datatypes.NULL_TYFUN _) = arg
        | long_follow_tyfun(arg as Datatypes.ETA_TYFUN(Datatypes.TYNAME _)) = arg
        | long_follow_tyfun(arg as Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=ref(Datatypes.NULL_TYFUN _), ...})) =
d477 1
a477 1
        | long_follow_tyfun(Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=ref tyfun, ...})) =
d480 1
a480 1
                            Datatypes.TYFUN(Datatypes.CONSTYPE(l, tyname), 0)) =
d482 1
a482 1
            long_follow_tyfun(Datatypes.ETA_TYFUN tyname)
d487 2
a488 2
      fun follow_strname(arg as Datatypes.STRNAME _) = arg
        | follow_strname(arg as Datatypes.NULLNAME _) = arg
d490 1
a490 1
                         Datatypes.METASTRNAME(ref(Datatypes.NULLNAME _))) =
d492 1
a492 1
        | follow_strname(arg as Datatypes.METASTRNAME(ref strname)) =
d495 3
a497 3
      fun reduce_strname(arg as Datatypes.STRNAME _) = ()
        | reduce_strname(arg as Datatypes.NULLNAME _) = ()
        | reduce_strname(Datatypes.METASTRNAME(r as ref strname)) =
d500 2
a501 2
      fun reduce_tyfun(arg as Datatypes.NULL_TYFUN _) = ()
        | reduce_tyfun(arg as Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=ref(Datatypes.NULL_TYFUN _), ...})) =
d503 1
a503 1
        | reduce_tyfun(Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=r as ref tyfun,
d509 1
a509 1
               Datatypes.ETA_TYFUN _ => ref_ve := Datatypes.empty_valenv
d513 2
a514 2
        | reduce_tyfun(Datatypes.ETA_TYFUN _) = ()
        | reduce_tyfun(Datatypes.TYFUN(ty, _)) = reduce_type ty
d516 2
a517 2
      and reduce_tyname(arg as Datatypes.TYNAME _) = ()
        | reduce_tyname(arg as Datatypes.METATYNAME{1=ref(Datatypes.NULL_TYFUN _), ...}) =
d519 1
a519 1
        | reduce_tyname(arg as Datatypes.METATYNAME{1=r as ref tyfun,
d525 1
a525 1
               Datatypes.ETA_TYFUN _ => ref_ve := Datatypes.empty_valenv
d530 2
a531 2
      and reduce_scheme(Datatypes.SCHEME(_, (ty,_))) = reduce_type ty
        | reduce_scheme(Datatypes.UNBOUND_SCHEME (ty,_)) = reduce_type ty
d534 2
a535 2
      and reduce_type(Datatypes.METATYVAR(ref(_, ty,_), _, _)) = reduce_type ty
        | reduce_type(Datatypes.META_OVERLOADED {1=ref ty,...}) =
d537 3
a539 3
        | reduce_type(Datatypes.TYVAR _) = ()
        | reduce_type(Datatypes.METARECTYPE(ref{3=ty, ...})) = reduce_type ty
        | reduce_type(ty as Datatypes.RECTYPE _) =
d541 1
a541 1
        | reduce_type(Datatypes.FUNTYPE(ty1, ty2)) =
d544 1
a544 1
        | reduce_type(Datatypes.CONSTYPE(l, tyname)) =
d549 1
a549 1
      and reduce_valenv(Datatypes.VE(_, ve_map)) =
d552 1
a552 1
      fun reduce_str(Datatypes.STR(strname,_,env)) =
d554 1
a554 1
        | reduce_str (Datatypes.COPYSTR((smap,tmap),str)) = 
d560 2
a561 2
            val smap' = Datatypes.Strname_id.Map.map (fn (_,strname) => (reduce_strname strname)) smap
            val tmap' = Datatypes.Tyfun_id.Map.map (fn (_,tyname) => (reduce_tyname tyname)) tmap
d567 2
a568 2
      and reduce_env(Datatypes.ENV(Datatypes.SE strenv,
                                   Datatypes.TE tyenv,
d571 1
a571 1
         NewMap.iterate (fn (_, Datatypes.TYSTR(tyfun, ve)) =>
d605 4
@


1.33
log
@Efficiency improvements for lookup functions
@
text
@d4 3
a112 2
require "../typechecker/ty_debug";
require "../typechecker/datatypes";
a124 1
  structure Ty_Debug : TY_DEBUG
d135 1
a136 4
  structure Debug : sig
		      val set_debug_level : int -> unit
		      val debug_level : unit -> int
		    end
a157 1
    val do_debug = Ty_Debug.do_debug
@


1.32
log
@Removing diagnostics
@
text
@d4 3
d182 3
a184 17
    fun lookup_val (apath,aval,BasisTypes.CONTEXT (alevel,_,env,_),
		    location,generate_moduler) =
      let val ENV (_,_,ve) = 
	Ident.followPath Env.find_env (apath,env)
      in
        Scheme.instantiate 
           (alevel, Conenv.lookup (aval,ve), location, generate_moduler)
      end handle Env.Lookup_StrId => raise LookupValId_in_Context
        | Conenv.Lookup_in_VE => raise LookupValId_in_Context

    fun lookup_longtycon (Ident.LONGTYCON (path,tycon),
			  BasisTypes.CONTEXT (_,_,env,_)) = 
      let val ENV (_,tyenv,_) = 
	Ident.followPath Env.find_env (path,env)
      in
	Tyenv.lookup(tyenv, tycon)
      end 
d187 10
@


1.31
log
@Datatypes.META_OVERLOADED takes extra arguments.  Removed UnresolvedVar
exception, and tidied the close function.
@
text
@d4 4
a157 1
    fun my_debug s = () (* output (MLWorks.IO.terminal_out,s ^ "\n") *)
a240 1
        val _ = my_debug ("Closing at level " ^ MLWorks.Integer.makestring alevel)
@


1.30
log
@Fix use of check_debruijns to be safe
@
text
@d4 3
a169 1
    exception UnresolvedVar of Ident.ValId
d176 2
a177 1
    fun lookup_val (apath,aval,BasisTypes.CONTEXT (alevel,_,env,_),generate_moduler) =
d182 1
a182 1
           (alevel,Conenv.lookup (aval,ve),generate_moduler)
d239 1
a239 1
  	fun close_ve (valid,scheme) =
d241 3
a243 5
	    val scheme' = Scheme.schemify (alevel,Lists.member (valid,exp_vars),
					   scheme,tyvars_scoped_here,asig)
	      handle
              Scheme.UnresolvedVar id => raise UnresolvedVar id
            | Scheme.MakeScheme (s,ty) => raise CloseError (s,ty)
d245 1
a245 1
	    (valid,scheme')
d248 4
a251 8
	VE(ref 0, NewMap.fold
	   (fn (tree, valid, scheme) =>
	    let
	      val (valid, scheme') = close_ve(valid, scheme)
	    in
	      NewMap.define(tree, valid, scheme')
	    end)
	   (NewMap.empty (Ident.valid_lt, Ident.valid_eq), amap))
d253 2
d451 2
a452 1
        | reduce_type(Datatypes.META_OVERLOADED(ref ty,_)) = reduce_type ty
@


1.29
log
@generate_moduler compiler option required in type variable instantiation.
n\n\n\n\n\nog: .
@
text
@d4 4
d384 1
a384 1
          if Types.check_debruijns(l, 0) then
d398 1
a398 1
          if Types.check_debruijns(l, 0) then
@


1.28
log
@Added level field to Basis.
Levels now allocated from a ref to ensure monotonicity.
@
text
@d4 4
d170 1
a170 1
   fun lookup_val (apath,aval,BasisTypes.CONTEXT (alevel,_,env,_)) =
d175 3
a177 4
           (alevel,Conenv.lookup (aval,ve))
      end
      handle Env.Lookup_StrId => raise LookupValId_in_Context
           | Conenv.Lookup_in_VE => raise LookupValId_in_Context
@


1.27
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d143 1
d166 1
a166 7
    fun lookup_val (apath,aval,BasisTypes.CONTEXT (alevel,_,env,_)) =
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("Basis.lookup_val \n");
	       Print.print (IdentPrint.debug_printValId aval);
	       Print.print (IdentPrint.printPath apath);
	       Print.print ("\n"))
       else ();
d172 3
a174 2
      end) handle Env.Lookup_StrId => raise LookupValId_in_Context
        | Conenv.Lookup_in_VE => raise LookupValId_in_Context
a177 5
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("Basis.lookup_longtycon \n");
	       Print.print (IdentPrint.printTyCon tycon);
	       Print.print ("\n"))
       else ();
d182 3
a184 2
      end) handle Tyenv.Lookup_in_TE => raise LookupLongTyCon
        | Env.Lookup_StrId => raise LookupLongTyCon 
d187 9
a195 6
     (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("Basis.lookup_tycon \n");
	       Print.print (IdentPrint.printTyCon tycon);
	       Print.print ("\n"))
       else ();
	 Tyenv.lookup (tyenv, tycon))
d201 3
a203 4
    fun context_plus_ve (BasisTypes.CONTEXT (alevel,tyvars,ENV (se,te,ve),
				  tyvarenv),ve') =
      BasisTypes.CONTEXT (1 + alevel,tyvars,ENV (se,te,Conenv.ve_plus_ve (ve,ve')),
	       tyvarenv)
d220 1
a220 1
      BasisTypes.CONTEXT (1 + alevel,tyvars,Env.env_plus_env (env,env'),tyvarenv)
d228 1
d263 1
a263 1
    fun level (BasisTypes.CONTEXT (alevel,_,_,_)) = alevel
d267 2
a268 2
    fun basis_to_context (BasisTypes.BASIS (_,_,_,env)) = 
      BasisTypes.CONTEXT (0,Set.empty_set,env,Tyvarenv.empty_tyvarenv)
d274 2
a275 23
    fun lookup_sigid (sigid,BasisTypes.BASIS (_,_,sigenv,_)) = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("Basis.lookup_sigid \n");
	       Print.print (IdentPrint.printSigId sigid);
	       Print.print ("\n"))
       else ();
      Sigenv.lookup (sigid,sigenv))

    fun lookup_longstrid (longstrid,BasisTypes.BASIS (_,_,_,env)) =
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("Basis.lookup_longstrid \n");
	       Print.print (IdentPrint.printLongStrId longstrid);
	       Print.print ("\n"))
       else ();
      Env.lookup_longstrid (longstrid,env))

    fun lookup_funid (funid,BasisTypes.BASIS (_,funenv,_,env)) = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("Basis.lookup_funid \n");
	       Print.print (IdentPrint.printFunId funid);
	       Print.print ("\n"))
       else ();
      Funenv.lookup (funid,funenv))
d277 6
d287 17
a303 11
    fun env_in_basis env = BasisTypes.BASIS (Nameset.empty_nameset (),
				  Funenv.empty_funenv,
				  Sigenv.empty_sigenv,env)

    fun sigenv_in_basis sigenv = BasisTypes.BASIS (Nameset.empty_nameset (),
					Funenv.empty_funenv,sigenv,
					Env.empty_env)

    fun funenv_in_basis funenv = BasisTypes.BASIS (Nameset.empty_nameset (),
					funenv,Sigenv.empty_sigenv,
					Env.empty_env)
d309 2
a310 2
    fun basis_plus_env (BasisTypes.BASIS (names,funenv,sigenv,env),env') = 
      BasisTypes.BASIS (names,funenv,sigenv,Env.env_plus_env (env,env'))
d312 2
a313 2
    fun basis_plus_sigenv (BasisTypes.BASIS (names,funenv,sigenv,env),sigenv') = 
      BasisTypes.BASIS (names,funenv,Sigenv.sigenv_plus_sigenv (sigenv,sigenv'),env)
d315 2
a316 2
    fun basis_plus_funenv (BasisTypes.BASIS (names,funenv,sigenv,env),funenv') = 
      BasisTypes.BASIS (names,Funenv.funenv_plus_funenv (funenv,funenv'),sigenv,env)
d318 2
a319 2
    fun basis_plus_names (BasisTypes.BASIS (names,funenv,sigenv,env),names') = 
      BasisTypes.BASIS (Nameset.union (names,names'),funenv,sigenv,env)
d321 5
a325 3
    fun basis_circle_plus_basis (BasisTypes.BASIS (names,funenv,sigenv,env),
				 BasisTypes.BASIS (names',funenv',sigenv',env')) = 
      BasisTypes.BASIS (Nameset.union (names,names'),
d330 4
a333 3
    fun basis_plus_basis (BasisTypes.BASIS (names,funenv,sigenv,env),
			  BasisTypes.BASIS (names',funenv',sigenv',env')) = 
      BasisTypes.BASIS (names,
d338 2
d341 2
a342 1
      BasisTypes.BASIS (Nameset.initial_nameset,
d348 2
a349 1
      BasisTypes.BASIS (Nameset.initial_nameset_for_builtin_library,
d355 2
a356 1
      BasisTypes.BASIS (Nameset.empty_nameset (),
d361 2
a362 2
    fun remove_str(BasisTypes.BASIS(n, f, s, ENV(SE map, te, ve)), strid) =
      BasisTypes.BASIS(n, f, s, ENV(SE(NewMap.undefine(map, strid)), te, ve))
d494 4
a497 2
      fun reduce_chains (BasisTypes.BASIS(nameset, BasisTypes.FUNENV funid_map,
                               BasisTypes.SIGENV sigid_map, env)) =
@


1.26
log
@Removed exception environments.
@
text
@d4 3
d172 2
a173 2
	Scheme.instantiate 
	(alevel,Conenv.lookup (aval,ve))
d443 2
a444 2
      and reduce_scheme(Datatypes.SCHEME(_, ty)) = reduce_type ty
        | reduce_scheme(Datatypes.UNBOUND_SCHEME ty) = reduce_type ty
d447 1
a447 1
      and reduce_type(Datatypes.METATYVAR(ref(_, ty), _, _)) = reduce_type ty
@


1.26.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.26  1993/06/30  15:39:53  daveb
Removed exception environments.

@


1.25
log
@Added remove_str for getting rid of FullPervasiveLibrary_ from initial env
@
text
@d4 3
d166 1
a166 1
      let val ENV (_,_,ve,_) = 
d181 1
a181 1
      let val ENV (_,tyenv,_,_) = 
d188 1
a188 1
    fun lookup_tycon (tycon,BasisTypes.CONTEXT (_,_,ENV (_,tyenv,_,_),_)) =
d200 1
a200 1
    fun context_plus_ve (BasisTypes.CONTEXT (alevel,tyvars,ENV (se,te,ve,ee),
d202 1
a202 1
      BasisTypes.CONTEXT (1 + alevel,tyvars,ENV (se,te,Conenv.ve_plus_ve (ve,ve'),ee),
d206 1
a206 1
				  ENV (se,te,ve,ee),tyvarenv),te') = 
d208 1
a208 1
	       ENV (se,Tyenv.te_plus_te (te,te'),ve,ee),tyvarenv)
d361 2
a362 2
    fun remove_str(BasisTypes.BASIS(n, f, s, ENV(SE map, te, ve, ee)), strid) =
      BasisTypes.BASIS(n, f, s, ENV(SE(NewMap.undefine(map, strid)), te, ve, ee))
d478 1
a478 1
                                   ve, ee)) =
d483 1
a483 2
         reduce_valenv ve;
         reduce_valenv ee)
@


1.24
log
@Nameset structure changes
@
text
@d4 3
d357 3
@


1.23
log
@Rationalised use of Mapping structure
@
text
@d4 3
d112 1
a112 1
  sharing Sigenv.BasisTypes = Funenv.BasisTypes = Tyvarenv.BasisTypes = Nameset.BasisTypes
d115 1
a115 1
    Scheme.Datatypes = Env.Datatypes =
d119 3
@


1.22
log
@Changes for BASISTYPES signature
@
text
@d4 3
d433 2
a434 4
        | reduce_type(Datatypes.RECTYPE map) =
          Lists.iterate
          (fn (_, ty) => reduce_type ty)
          (Datatypes.Mapping.assoc map)
@


1.21
log
@Changes for COPYSTR representation
@
text
@d4 3
d83 1
d95 1
d106 5
a110 7
  sharing Tyvarenv.Datatypes = Sigenv.Sigma.Nameset.Datatypes
    = Scheme.Datatypes = Env.Datatypes
    = Conenv.Datatypes = Tyenv.Datatypes = Types.Datatypes
(*
  sharing Sigenv.Sigma.Nameset = Funenv.Phi.Nameset = Funenv.Nameset
*)
  sharing Funenv.Phi.Sigma = Sigenv.Sigma 
d112 1
d116 2
a117 3
    structure Datatypes = Tyvarenv.Datatypes
    structure Tyvarenv = Tyvarenv
    structure Phi = Funenv.Phi
a118 1
    structure Sigma = Sigenv.Sigma
a119 1
    structure Nameset = Sigma.Nameset
a129 12
    type Tyvarset = Ident.TyVar Set.Set

    (****
     int represents the level of a specific context.
     ****)

    datatype Context =
      CONTEXT of (int * Tyvarset * Env * Tyvarenv.Tyvarenv)

    datatype Basis = 
      BASIS of (Nameset.Nameset * Funenv.Funenv * Sigenv.Sigenv * Env)
	
d144 1
a144 1
    fun lookup_val (apath,aval,CONTEXT (alevel,_,env,_)) =
d160 1
a160 1
			  CONTEXT (_,_,env,_)) = 
d173 1
a173 1
    fun lookup_tycon (tycon,CONTEXT (_,_,ENV (_,tyenv,_,_),_)) =
d185 1
a185 1
    fun context_plus_ve (CONTEXT (alevel,tyvars,ENV (se,te,ve,ee),
d187 1
a187 1
      CONTEXT (1 + alevel,tyvars,ENV (se,te,Conenv.ve_plus_ve (ve,ve'),ee),
d190 1
a190 1
    fun context_plus_te (CONTEXT (level,tyvarset,
d192 1
a192 1
      CONTEXT (level,tyvarset,
d195 1
a195 1
    fun context_plus_tyvarset_and_tyvarenv(CONTEXT(level,tyvars,env,tyvarenv),
d200 1
a200 1
	CONTEXT (level,Set.union (tyvars,tyvarset), env,
d204 2
a205 2
    fun context_plus_env (CONTEXT (alevel,tyvars,env,tyvarenv),env') =
      CONTEXT (1 + alevel,tyvars,Env.env_plus_env (env,env'),tyvarenv)
d238 1
a238 1
    fun env_of_context (CONTEXT (_,_,env,_)) = env
d240 1
a240 1
    fun te_of_context (CONTEXT (_,_,env,_)) = 
d247 1
a247 1
    fun level (CONTEXT (alevel,_,_,_)) = alevel
d249 1
a249 1
    fun get_tyvarset (CONTEXT (_,tyvars,_,_)) = tyvars
d251 2
a252 2
    fun basis_to_context (BASIS (_,_,_,env)) = 
      CONTEXT (0,Set.empty_set,env,Tyvarenv.empty_tyvarenv)
d258 1
a258 1
    fun lookup_sigid (sigid,BASIS (_,_,sigenv,_)) = 
d266 1
a266 1
    fun lookup_longstrid (longstrid,BASIS (_,_,_,env)) =
d274 1
a274 1
    fun lookup_funid (funid,BASIS (_,funenv,_,env)) = 
d286 1
a286 1
    fun env_in_basis env = BASIS (Nameset.empty_nameset (),
d290 1
a290 1
    fun sigenv_in_basis sigenv = BASIS (Nameset.empty_nameset (),
d294 1
a294 1
    fun funenv_in_basis funenv = BASIS (Nameset.empty_nameset (),
d302 2
a303 2
    fun basis_plus_env (BASIS (names,funenv,sigenv,env),env') = 
      BASIS (names,funenv,sigenv,Env.env_plus_env (env,env'))
d305 2
a306 2
    fun basis_plus_sigenv (BASIS (names,funenv,sigenv,env),sigenv') = 
      BASIS (names,funenv,Sigenv.sigenv_plus_sigenv (sigenv,sigenv'),env)
d308 2
a309 2
    fun basis_plus_funenv (BASIS (names,funenv,sigenv,env),funenv') = 
      BASIS (names,Funenv.funenv_plus_funenv (funenv,funenv'),sigenv,env)
d311 16
a326 16
    fun basis_plus_names (BASIS (names,funenv,sigenv,env),names') = 
      BASIS (Nameset.union (names,names'),funenv,sigenv,env)

    fun basis_circle_plus_basis (BASIS (names,funenv,sigenv,env),
				 BASIS (names',funenv',sigenv',env')) = 
      BASIS (Nameset.union (names,names'),
	     Funenv.funenv_plus_funenv (funenv,funenv'),
	     Sigenv.sigenv_plus_sigenv (sigenv,sigenv'),
	     Env.env_plus_env (env,env'))

    fun basis_plus_basis (BASIS (names,funenv,sigenv,env),
			  BASIS (names',funenv',sigenv',env')) = 
      BASIS (names,
	     Funenv.funenv_plus_funenv (funenv,funenv'),
	     Sigenv.sigenv_plus_sigenv (sigenv,sigenv'),
	     Env.env_plus_env (env,env'))
d329 4
a332 4
      BASIS (Nameset.initial_nameset,
	     Funenv.empty_funenv,
	     Sigenv.empty_sigenv,
	     Env.initial_env)
d335 4
a338 4
      BASIS (Nameset.initial_nameset_for_builtin_library,
	     Funenv.empty_funenv,
	     Sigenv.empty_sigenv,
	     Env.initial_env_for_builtin_library)
d341 4
a344 4
      BASIS (Nameset.empty_nameset (),
	     Funenv.empty_funenv,
	     Sigenv.empty_sigenv,
	     Env.empty_env)
d474 1
a474 1
      fun reduce_sigma(Sigma.SIGMA(nameset, str)) =
d479 2
a480 2
      fun reduce_chains (BASIS(nameset, Funenv.FUNENV funid_map,
                               Sigenv.SIGENV sigid_map, env)) =
d484 1
a484 1
            (fn (_, Phi.PHI(nameset, (str, sigma))) =>
@


1.20
log
@Anel's last changes
@
text
@d4 3
d456 1
a456 1
      fun reduce_str(Datatypes.STR(strname, env)) =
d458 12
@


1.19
log
@Modified tyenv for efficiency
@
text
@d4 3
d226 1
a226 1
              Scheme.UnresolvedVar => raise UnresolvedVar valid
d435 1
a435 1
        | reduce_type(Datatypes.META_OVERLOADED(ref ty)) = reduce_type ty
@


1.18
log
@Changed handling of overloaded variable errors.
@
text
@d4 3
d174 1
a174 1
	Tyenv.lookup(tycon,tyenv)
d184 1
a184 1
	 Tyenv.lookup (tycon,tyenv))
@


1.17
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d139 1
d219 3
a221 1
	      handle Scheme.MakeScheme (s,ty) => raise CloseError (s,ty)
@


1.16
log
@Modified to use less than functions for maps
@
text
@d4 3
d144 1
a144 1
	       Print.print (IdentPrint.printValId aval);
@


1.15
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d223 1
a223 1
	   (NewMap.empty (valid_order,valid_equal), amap))
@


1.14
log
@Moved chain reducing code here from _toplevel.
@
text
@d4 3
d220 1
a220 1
	   (NewMap.empty valid_order, amap))
@


1.13
log
@Removed irrelevant handlers and new exceptions
@
text
@d4 3
d58 1
d70 1
d81 1
a81 1
    = Conenv.Datatypes = Tyenv.Datatypes
d331 140
@


1.12
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d116 5
a120 4
    exception LookupTyCon
    exception LookupSigId
    exception LookupLongStrId
    exception LookupFunId
a135 1
	handle Env.Lookup_StrId => raise LookupValId_in_Context
d139 2
a140 2
	handle Conenv.Lookup_in_VE => raise LookupValId_in_Context
      end)
a150 1
	handle Env.Lookup_StrId => raise LookupLongTyCon 
d153 2
a154 2
	handle Tyenv.Lookup_in_TE => raise LookupLongTyCon
      end)
d162 1
a162 2
	 Tyenv.lookup (tycon,tyenv)
	 handle Tyenv.Lookup_in_TE => raise LookupTyCon)
d245 1
a245 2
      Sigenv.lookup (sigid,sigenv)
      handle Sigenv.Lookup_SigId => raise LookupSigId)
d253 1
a253 2
      Env.lookup_longstrid (longstrid,env)
      handle Env.Lookup_LongStrId => raise LookupLongStrId)
d261 1
a261 2
      Funenv.lookup (funid,funenv)
      handle Funenv.Lookup_FunId => raise LookupFunId)
@


1.11
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d38 1
a38 1
require "../utils/set";
d41 1
a48 3
require "../typechecker/nameset";
require "../typechecker/sigma";
require "../typechecker/phi";
d55 1
a55 1
  structure Datatypes : DATATYPES
a56 2
  structure Sigma : SIGMA
  structure Phi : PHI
a60 1
  structure Nameset : NAMESET
a62 1
  structure Set : SET
d70 2
a71 3
  sharing Datatypes = Tyvarenv.Datatypes = Sigma.Datatypes
    = Phi.Datatypes = Sigenv.Datatypes = Funenv.Datatypes
    = Nameset.Datatypes = Scheme.Datatypes = Env.Datatypes
d73 6
a78 4
  sharing Set = Scheme.Set
  sharing Nameset = Sigma.Nameset = Phi.Nameset = Funenv.Nameset
  sharing Sigma = Phi.Sigma = Sigenv.Sigma 
  sharing Phi = Funenv.Phi) : BASIS =
d81 1
a81 1
    structure Datatypes = Datatypes
d83 1
a83 2
    structure Sigma = Sigma
    structure Phi = Phi
d85 1
d87 2
a88 2
    structure Nameset = Nameset
    structure Set = Set
@


1.10
log
@Replaced to_list calls with folds.
@
text
@d194 20
a213 8
    fun close (alevel,VE (r,amap),
	       exp_vars,tyvars_scoped_here,asig) =
      VE (ref 0,Mapping.cond_mapit (amap,
				     fn (dom,ran) =>
				     (Scheme.schemify (alevel, 
						       Lists.member(dom,exp_vars),
						       ran,tyvars_scoped_here,asig))))
      handle Scheme.MakeScheme (s,ty) => raise CloseError (s,ty)
d245 1
a245 1
      Sigenv.lookup_sigid (sigid,sigenv)
@


1.9
log
@Changed to imperative implementation of namesets with hashing
@
text
@d4 3
d181 1
a181 3
	fun collect([],tve) = tve
	  | collect(h::t,tve) = collect (t,Tyvarenv.add_to_tyvarenv (level,h,
								     tve))
d183 2
a184 2
	CONTEXT (level,Set.union (tyvars,tyvarset),env,
		 collect (Set.set_to_list (tyvarset),tyvarenv))
@


1.8
log
@New pervasive library code - cut some things out of the initial type basis
@
text
@d4 3
d257 1
a257 1
    fun env_in_basis env = BASIS (Nameset.empty_nameset,
d261 1
a261 1
    fun sigenv_in_basis sigenv = BASIS (Nameset.empty_nameset,
d265 1
a265 1
    fun funenv_in_basis funenv = BASIS (Nameset.empty_nameset,
d312 1
a312 1
      BASIS (Nameset.empty_nameset,
@


1.7
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d301 6
@


1.6
log
@Changed ref unit in valenv to ref int to assist encoder
@
text
@d4 3
d28 1
d42 20
a61 17
functor Basis (structure Datatypes : DATATYPES
	       structure Tyvarenv : TYVARENV
	       structure Sigma : SIGMA
	       structure Phi : PHI
	       structure Sigenv : SIGENV
	       structure Funenv : FUNENV
	       structure Conenv : VALENV
	       structure Tyenv : TYENV
	       structure Nameset : NAMESET
	       structure Scheme : SCHEME
	       structure Env : ENVIRONMENT
	       structure Set : SET
	       structure Lists : LISTS
	       structure Debug : sig val set_debug_level : int -> unit
				     val debug_level : unit -> int
				 end
	       structure Print : PRINT
d63 8
a70 8
	       sharing Datatypes = Tyvarenv.Datatypes = Sigma.Datatypes
		 = Phi.Datatypes = Sigenv.Datatypes = Funenv.Datatypes
		 = Nameset.Datatypes = Scheme.Datatypes = Env.Datatypes
		 = Conenv.Datatypes = Tyenv.Datatypes
	       sharing Set = Scheme.Set
	       sharing Nameset = Sigma.Nameset = Phi.Nameset = Funenv.Nameset
	       sharing Sigma = Phi.Sigma = Sigenv.Sigma 
	       sharing Phi = Funenv.Phi) : BASIS =
d82 1
d115 1
a115 1
      (if (Debug.debug_level () > 10) 
d132 1
a132 1
      (if (Debug.debug_level () > 10) 
d146 1
a146 1
     (if (Debug.debug_level () > 10) 
d220 1
a220 1
      (if (Debug.debug_level () > 10) 
d229 1
a229 1
      (if (Debug.debug_level () > 10) 
d238 1
a238 1
      (if (Debug.debug_level () > 10) 
@


1.5
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_basis.sml,v $
d180 1
a180 1
      VE (ref (),Mapping.cond_mapit (amap,
@


1.4
log
@fixed trivial bug in empty_basis.
@
text
@d1 1
d4 3
d17 1
@


1.3
log
@Added empty_basis value.
@
text
@d3 3
d285 1
a285 1
	     Sigenv.empty_sigenv
@


1.2
log
@Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures.
@
text
@d3 4
d278 6
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d163 1
a163 1
    fun close (alevel,VE amap,
d165 5
a169 5
      VE (Mapping.cond_mapit (amap,
			      fn (dom,ran) =>
			      (Scheme.schemify (alevel, 
						Lists.member(dom,exp_vars),
						ran,tyvars_scoped_here,asig))))
d171 1
a171 1
      
@
