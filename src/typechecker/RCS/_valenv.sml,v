head	1.41;
access;
symbols
	MLW_daveb_inline_1_4_99:1.41.8
	MLWorks_21c0_1999_03_25:1.41
	MLWorks_20c1_1998_08_20:1.41
	MLWorks_20c0_1998_08_04:1.41
	MLWorks_20b2c2_1998_06_19:1.41
	MLWorks_20b2_Windows_1998_06_12:1.41
	MLWorks_20b1c1_1998_05_07:1.41
	MLWorks_20b0_1998_04_07:1.41
	MLWorks_20b0_1998_03_20:1.41
	MLWorks_20m2_1998_02_16:1.41
	MLWorks_20m1_1997_10_23:1.41
	MLWorks_11r1:1.41.5.1.1.1.1
	MLWorks_workspace_97:1.41.7
	MLWorks_dt_wizard:1.41.6
	MLWorks_11c0_1997_09_09:1.41.5.1.1.1
	MLWorks_10r3:1.41.5.1.3
	MLWorks_10r2_551:1.41.5.1.2
	MLWorks_11:1.41.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.41.5.1
	MLWorks_20m0_1997_06_20:1.41
	MLWorks_1_0_r2c2_1997_06_14:1.41.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.41.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.41.5
	MLWorks_BugFix_1997_04_24:1.41
	MLWorks_1_0_r2_Win32_1997_04_11:1.41
	MLWorks_1_0_r2_Unix_1997_04_04:1.41
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.41.3.1.1
	MLWorks_gui_1996_12_18:1.41.4
	MLWorks_1_0_Win32_1996_12_17:1.41.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.41.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.41.1.1
	MLWorks_1_0_Irix_1996_11_28:1.41.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.41.2
	MLWorks_1_0_Unix_1996_11_14:1.41.1
	MLWorks_Open_Beta2_1996_10_11:1.40.2
	MLWorks_License_dev:1.40.1
	MLWorks_1_open_beta_1996_09_13:1.39.1
	MLWorks_Open_Beta_1996_08_22:1.39
	MLWorks_Beta_1996_07_02:1.39
	MLWorks_Beta_1996_06_07:1.39
	MLWorks_Beta_1996_06_06:1.39
	MLWorks_Beta_1996_06_05:1.39
	MLWorks_Beta_1996_06_03:1.39
	MLWorks_Beta_1996_05_31:1.39
	MLWorks_Beta_1996_05_30:1.39
	ML_beta_release_12/08/94:1.33
	ML_beta_release_03/08/94:1.33
	ML_revised_beta_release_25/05/94:1.33
	ML_final_beta_release_02/03/94:1.32
	mlworks-28-01-1994:1.31
	Release:1.30
	mlworks-beta-01-09-1993:1.30
	MLWorks-1-0-4-29/01/1993:1.27
	MLWorks-1-0-3-21/12/1992:1.26
	MLWorks-1-0-2-15/12/1992:1.25
	MLWorks-1-0-1-04/12/1992:1.24
	checkpoint_17_08_92:1.18
	Ten15_release_19-11-91:1.4
	Ten15_release_21-08-91:1.4
	Ten15_release_19-08-91:1.4
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.41
date	96.10.28.17.20.01;	author io;	state Exp;
branches
	1.41.1.1
	1.41.2.1
	1.41.3.1
	1.41.4.1
	1.41.5.1
	1.41.6.1
	1.41.7.1
	1.41.8.1;
next	1.40;

1.40
date	96.09.23.12.19.28;	author andreww;	state Exp;
branches
	1.40.1.1
	1.40.2.1;
next	1.39;

1.39
date	96.04.30.15.26.02;	author jont;	state Exp;
branches
	1.39.1.1;
next	1.38;

1.38
date	95.12.27.11.36.02;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.09.08.17.47.43;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	95.07.27.16.27.54;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	95.05.26.10.33.17;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	95.02.06.10.54.38;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.05.11.15.02.11;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	93.12.03.13.26.47;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	93.09.16.13.49.18;	author nosa;	state Exp;
branches;
next	1.30;

1.30
date	93.03.04.10.23.31;	author matthew;	state Exp;
branches
	1.30.1.1;
next	1.29;

1.29
date	93.03.02.15.32.10;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.02.19.10.48.32;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	92.12.22.15.39.42;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	92.12.18.15.45.11;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	92.12.04.19.47.44;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	92.11.25.15.43.48;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	92.10.30.15.36.52;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.09.09.11.49.47;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	92.08.27.20.01.16;	author davidt;	state Exp;
branches;
next	1.20;

1.20
date	92.08.27.16.13.51;	author davidt;	state Exp;
branches;
next	1.19;

1.19
date	92.08.18.16.10.31;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.08.13.17.18.13;	author davidt;	state Exp;
branches;
next	1.17;

1.17
date	92.08.11.17.52.46;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.08.06.18.05.35;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.07.28.13.15.01;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.07.27.14.00.50;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.07.16.18.55.28;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.06.16.14.12.58;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.05.05.10.56.08;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.02.11.11.25.33;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.01.30.17.38.29;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.01.27.20.16.32;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.01.14.16.55.18;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.01.10.12.05.23;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.11.21.16.49.06;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.08.06.14.25.37;	author colin;	state Exp;
branches;
next	1.3;

1.3
date	91.07.16.16.01.28;	author colin;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.18.13.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.42.03;	author colin;	state Exp;
branches;
next	;

1.30.1.1
date	93.03.04.10.23.31;	author jont;	state Exp;
branches;
next	;

1.39.1.1
date	96.09.13.11.41.21;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	96.10.07.16.34.24;	author hope;	state Exp;
branches;
next	;

1.40.2.1
date	96.10.17.11.53.32;	author hope;	state Exp;
branches;
next	;

1.41.1.1
date	96.11.14.13.21.07;	author hope;	state Exp;
branches
	1.41.1.1.1.1;
next	;

1.41.1.1.1.1
date	96.11.28.15.32.10;	author hope;	state Exp;
branches;
next	;

1.41.2.1
date	96.11.22.18.38.54;	author hope;	state Exp;
branches;
next	;

1.41.3.1
date	96.12.17.18.17.54;	author hope;	state Exp;
branches
	1.41.3.1.1.1;
next	;

1.41.3.1.1.1
date	97.02.24.12.12.10;	author hope;	state Exp;
branches;
next	;

1.41.4.1
date	96.12.18.10.13.10;	author hope;	state Exp;
branches;
next	;

1.41.5.1
date	97.05.12.10.51.28;	author hope;	state Exp;
branches
	1.41.5.1.1.1
	1.41.5.1.2.1
	1.41.5.1.3.1;
next	;

1.41.5.1.1.1
date	97.07.28.18.33.20;	author daveb;	state Exp;
branches
	1.41.5.1.1.1.1.1;
next	;

1.41.5.1.1.1.1.1
date	97.10.07.11.59.18;	author jkbrook;	state Exp;
branches;
next	;

1.41.5.1.2.1
date	97.09.08.17.26.25;	author daveb;	state Exp;
branches;
next	;

1.41.5.1.3.1
date	97.09.09.14.23.15;	author daveb;	state Exp;
branches;
next	;

1.41.6.1
date	97.09.10.19.42.13;	author brucem;	state Exp;
branches;
next	;

1.41.7.1
date	97.09.11.21.09.43;	author daveb;	state Exp;
branches;
next	;

1.41.8.1
date	99.04.01.18.08.29;	author daveb;	state Exp;
branches;
next	;


desc
@Functions ranging over variable environments
(see datatypes.sml for datatype)
@


1.41
log
@moving String from toplevel
@
text
@(* _valenv.sml the functor *)
(*
$Log: _valenv.sml,v $
 * Revision 1.40  1996/09/23  12:19:28  andreww
 * [Bug #1605]
 * removing default_overloads flag.  Now subsumed by old_definition.
 *
 * Revision 1.39  1996/04/30  15:26:02  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.38  1995/12/27  11:36:02  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.37  1995/09/08  17:47:43  daveb
Added realint_tyvar for abs and ~; removed real_tyvar and int_tyvar.

Revision 1.36  1995/07/27  16:27:54  jont
Add div and mod to list of overloaded operators

Revision 1.35  1995/05/26  10:33:17  matthew
Get list of builtin library values from Primitives

Revision 1.34  1995/02/06  10:54:38  matthew
Removing debug structure

Revision 1.33  1994/05/11  15:02:11  daveb
Added resolve_overloads.  Simplified code for creating initial ve.

Revision 1.32  1993/12/03  13:26:47  nosa
TYCON' for type function functions in lambda code for Modules Debugger.

Revision 1.31  1993/09/16  13:49:18  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.30  1993/03/04  10:23:31  matthew
Options & Info changes

Revision 1.29  1993/03/02  15:32:10  matthew
empty_rec_type to empty_rectype

Revision 1.28  1993/02/19  10:48:32  matthew
Moved enrichment code to _realise

Revision 1.27  1992/12/22  15:39:42  jont
Anel's last changes

Revision 1.26  1992/12/18  15:45:11  matthew
Propagating options to signature matching error messages.

Revision 1.25  1992/12/04  19:47:44  matthew
Error message revisions.

Revision 1.24  1992/11/25  15:43:48  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.23  1992/10/30  15:36:52  jont
Added special maps for tyfun_id, tyname_id, strname_id

Revision 1.22  1992/09/09  11:49:47  matthew
Changed valenv printing

Revision 1.21  1992/08/27  20:01:16  davidt
Yet more changes to get structure copying working better.

Revision 1.20  1992/08/27  16:13:51  davidt
Added Anel's changes, and changed some stuff to do better
equality checking of valenvs etc.

Revision 1.19  1992/08/18  16:10:31  jont
Removed irrelevant handlers and new exceptions

Revision 1.18  1992/08/13  17:18:13  davidt
Changed to use Lists.reducel instead of Lists.foldr.

Revision 1.17  1992/08/11  17:52:46  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.16  1992/08/06  18:05:35  jont
Anel's changes to use NewMap instead of Map

Revision 1.14  1992/07/27  14:00:50  jont
Improved enrichment efficiency

Revision 1.13  1992/07/16  18:55:28  jont
Changed to use btrees for renaming of tynames and strnames

Revision 1.12  1992/06/16  14:12:58  clive
Added the printing of the name of the relevant identifier in a couple of error messages

Revision 1.11  1992/05/05  10:56:08  jont
Anel's fixes

Revision 1.10  1992/02/11  11:25:33  clive
New pervasive library code - cut some things out of the initial type basis

Revision 1.9  1992/01/30  17:38:29  jont
Removed some loop invariants from ve_ran_enriches and ee_ran_enriches
This is done for efficiency only, since NJ is too dumb to do it for you.
Our compiler, will, when we get there!

Revision 1.8  1992/01/27  20:16:32  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.7  1992/01/14  16:55:18  jont
Changed ref unit in valenv to ref int to assist encoder

Revision 1.6  1992/01/10  12:05:23  richard
Added a SUBSTRING pervasive as a temporary measure so that the same code
can be compiled under under both New Jersey and MLWorks.

Revision 1.5  1991/11/21  16:49:06  jont
Added copyright message

Revision 1.4  91/08/06  14:25:37  colin
fixed bug in ve_copy which was changing identifier status of all valids
to vars (now uses Mapping.domain rather than ve_domain)

Revision 1.3  91/07/16  16:01:28  colin
Made valenv map an eqfun_map with Ident.eq_valid as equality function. This
reflects the fact that in the semantics the domain of VE is a union rather
than a _disjoint_ union of VAR, CON and EXCON. Also made ve_domain coerce
everything to a VAR - this avoids problems with erroneous distinction of 
valid identifier classes.

Revision 1.2  91/06/17  18:13:00  nickh
Modified to take new ValEnv definition with ref unit to allow
reading and writing circular data structures.

Revision 1.1  91/06/07  11:42:03  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/crash";
require "../utils/lists";
require "../main/info";
require "../main/primitives";
require "../basics/identprint";
require "../typechecker/types";
require "../typechecker/scheme";

require "../typechecker/valenv";

functor Valenv(
  structure Crash     : CRASH
  structure Lists     : LISTS
  structure Info : INFO
  structure Primitives : PRIMITIVES
  structure IdentPrint : IDENTPRINT
  structure Types     : TYPES
  structure Scheme    : TYPESCHEME

  sharing Types.Options = IdentPrint.Options = Scheme.Options
  sharing Types.Datatypes = Scheme.Datatypes
  sharing Types.Datatypes.Ident = IdentPrint.Ident
  sharing IdentPrint.Ident.Location = Info.Location
    ) : VALENV =
  
  struct 
    structure Datatypes = Types.Datatypes
    type Options = Types.Options.options
    type ErrorInfo = Info.options

    open Datatypes
      
    exception LookupValId of Ident.ValId

    fun ve_plus_ve (VE (_,amap),VE (_,amap')) = 
      VE (ref 0, NewMap.union(amap, amap'))

    fun lookup (valid,VE (_,valenv)) = 
      case NewMap.tryApply'(valenv, valid) of
        SOME t => t
      | _ => raise LookupValId valid

    fun ve_domain (VE (_,amap)) = 
      NewMap.fold_in_rev_order
      (fn (res, Ident.CON sym, _) => Ident.VAR sym :: res
        | (res, Ident.EXCON sym, _) => Ident.VAR sym :: res
	| (res, v as (Ident.VAR _), _) => v :: res
        |  _ => Crash.impossible "TYCON':ve_domain:valenv")
      ([], amap)

    fun add_to_ve (valid,scheme,VE (_,amap)) =
      VE ((ref 0, NewMap.define (amap,valid,scheme)))
	 
    local
      val bool_scheme = Scheme.make_scheme ([],(CONSTYPE ([],Types.bool_tyname),NONE))
      fun atyvar (id,eq,imp) =
	TYVAR (ref (0,NULLTYPE,NO_INSTANCE),
               Ident.TYVAR (Ident.Symbol.find_symbol (id),eq,imp))
    in
      val initial_ee = empty_valenv
        
      val basic_constructor_set =
        Lists.reducel
        (fn (ve,(name,scheme)) =>
         (add_to_ve (Ident.CON (Ident.Symbol.find_symbol name),
                     scheme,
                     ve)))
        (empty_valenv,
         [("true",bool_scheme),
          ("false",bool_scheme),
          ("ref",
           let val aty = atyvar ("'_a",false,true)
           in
             Scheme.make_scheme([aty],(FUNTYPE (aty,CONSTYPE
                                                ([aty],Types.ref_tyname)),
                                       NONE))
           end),
          ("nil",
           let 
             val aty = atyvar ("'a",false,false)
           in
             Scheme.make_scheme([aty],(CONSTYPE ([aty],Types.list_tyname),
                                       NONE))
           end),
          ("::",
           let val aty = atyvar ("'a",false,false)
           in
             Scheme.make_scheme ([aty],
                                 (FUNTYPE
                                  (Types.add_to_rectype
                                   (Ident.LAB
                                    (Ident.Symbol.find_symbol ("1")),
                                    aty,Types.add_to_rectype
                                    (Ident.LAB
                                     (Ident.Symbol.find_symbol ("2")),
                                     CONSTYPE
                                     ([aty],Types.list_tyname),
                                     Types.empty_rectype)),
                                   CONSTYPE
                                   ([aty],Types.list_tyname)),NONE))
           end)])

      val initial_ve = 
        add_to_ve
	  (Ident.VAR (Ident.Symbol.find_symbol ("=")),
	   let val aty = atyvar ("''a",true,false)
	   in
	     Scheme.make_scheme ([aty],
                                 (FUNTYPE
                                  (Types.add_to_rectype
                                   (Ident.LAB
                                    (Ident.Symbol.find_symbol ("1")),aty,
                                    Types.add_to_rectype
                                    (Ident.LAB
                                     (Ident.Symbol.find_symbol ("2")),aty,
                                     Types.empty_rectype)),
                                   CONSTYPE ([],Types.bool_tyname)),
                                  NONE))
	   end,
           Lists.reducel
	     (fn (ve,(s, f, t)) =>
	        let val v = Ident.VAR (Ident.Symbol.find_symbol s)
	        in add_to_ve (v, f (v, t), ve)
	        end)
             (basic_constructor_set,
              [("~", Scheme.unary_overloaded_scheme, Ident.realint_tyvar),
               ("abs", Scheme.unary_overloaded_scheme, Ident.realint_tyvar),
               ("*", Scheme.binary_overloaded_scheme, Ident.num_tyvar),
               ("+", Scheme.binary_overloaded_scheme, Ident.num_tyvar),
               ("-", Scheme.binary_overloaded_scheme, Ident.num_tyvar),
               ("mod", Scheme.binary_overloaded_scheme, Ident.wordint_tyvar),
               ("div", Scheme.binary_overloaded_scheme, Ident.wordint_tyvar),
               ("/", Scheme.binary_overloaded_scheme, Ident.real_tyvar),
               ("<", Scheme.predicate_overloaded_scheme, Ident.numtext_tyvar),
               (">", Scheme.predicate_overloaded_scheme, Ident.numtext_tyvar),
               ("<=", Scheme.predicate_overloaded_scheme, Ident.numtext_tyvar),
               (">=", Scheme.predicate_overloaded_scheme, Ident.numtext_tyvar)]))

        val initial_ve_for_builtin_library =
          Lists.reducel
          (fn (env,s) =>
           let
             val aty = atyvar ("'a", false, false)
           in
             add_to_ve (Ident.VAR (Ident.Symbol.find_symbol s),
                        Scheme.make_scheme ([aty],(aty,NONE)),
                        env)
           end)
          (basic_constructor_set,
           (map #1 Primitives.values_for_builtin_library))
    end

    fun string_valenv (start, VE (_,amap)) =
      let 
        fun print_spaces (res, n) =
	  if n = 0 then concat(" " :: res)
	  else print_spaces (" " :: res, n-1)
      in
	NewMap.string IdentPrint.debug_printValId Scheme.string_scheme
	{start = "{", domSep = " |--> ", itemSep = "\n" ^ print_spaces([], start), finish = "}"}
	(NewMap.map (fn (id,sch)=>sch) amap)
      end

    fun empty_valenvp (VE (_,amap)) = NewMap.is_empty amap

    (*
     * Note that the constructor status of the identifiers in the domains
     * of valenvs is ignored during equality.
     *)

    fun valenv_eq (ve as VE (_,amap),ve' as VE (_,amap')) =
      NewMap.eq (fn (sch,sch')=> Scheme.typescheme_eq (sch,sch')) (amap, amap')

    fun dom_valenv_eq (ve as VE(_, m), ve' as VE(_, m')) =
      NewMap.eq (fn _ => true) (m, m')

    fun resolve_overloads
          error_info
          (ENV (_, _, VE (_, amap)),
	   options as Types.Options.OPTIONS
	     {print_options,
	      compat_options = Types.Options.COMPATOPTIONS
		{old_definition, ...},
	      ...}) =
      let
        fun error_fn (valid, loc) =
          Info.error' error_info
            (Info.FATAL, loc,
             "Unresolved overloading for "
             ^ IdentPrint.printValId print_options valid)

	fun resolve_scheme (_, SCHEME (i, (ty, inst))) =
	  Types.resolve_overloading (not old_definition, ty, error_fn)
	|   resolve_scheme (_, UNBOUND_SCHEME (ty, inst)) =
	  Types.resolve_overloading (not old_definition, ty, error_fn)
	|   resolve_scheme (_, s as OVERLOADED_SCHEME _) =
	  ()
      in
	NewMap.iterate resolve_scheme amap
      end
      
    fun ve_copy (VE (_,amap),tyname_copies) = 
      let
	fun copy (_, s) = Scheme.scheme_copy (s,tyname_copies)
      in
	VE(ref 0, NewMap.map copy amap)
      end

    fun tyvars (VE (_,amap)) = 
      Lists.filter
      (NewMap.fold (fn (acc, _,  ran) => Scheme.tyvars(acc, ran)) ([], amap))
  end
@


1.41.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 3
 * Revision 1.41  1996/10/28  17:20:01  io
 * moving String from toplevel
 *
@


1.41.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.41  1996/10/28  17:20:01  io
 * moving String from toplevel
 *
@


1.41.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.41  1996/10/28  17:20:01  io
 * moving String from toplevel
 *
@


1.41.5.1
log
@branched from 1.41
@
text
@a3 3
 * Revision 1.41  1996/10/28  17:20:01  io
 * moving String from toplevel
 *
@


1.41.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.41.5.1  1997/05/12  10:51:28  hope
 * branched from 1.41
 *
@


1.41.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.41.5.1  1997/05/12  10:51:28  hope
 * branched from 1.41
 *
@


1.41.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.41.5.1  1997/05/12  10:51:28  hope
 * branched from 1.41
 *
@


1.41.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.41.5.1.1.1  1997/07/28  18:33:20  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.41.4.1
log
@branched from 1.41
@
text
@a3 3
 * Revision 1.41  1996/10/28  17:20:01  io
 * moving String from toplevel
 *
@


1.41.3.1
log
@branched from 1.41
@
text
@a3 3
 * Revision 1.41  1996/10/28  17:20:01  io
 * moving String from toplevel
 *
@


1.41.3.1.1.1
log
@branched from 1.41.3.1
@
text
@a3 3
 * Revision 1.41.3.1  1996/12/17  18:17:54  hope
 * branched from 1.41
 *
@


1.41.2.1
log
@branched from 1.41
@
text
@a3 3
 * Revision 1.41  1996/10/28  17:20:01  io
 * moving String from toplevel
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a3 3
 * Revision 1.41  1996/10/28  17:20:01  io
 * moving String from toplevel
 *
@


1.41.1.1.1.1
log
@branched from 1.41.1.1
@
text
@a3 3
 * Revision 1.41.1.1  1996/11/14  13:21:07  hope
 * branched from 1.41
 *
@


1.40
log
@[Bug #1605]
removing default_overloads flag.  Now subsumed by old_definition.
@
text
@d4 4
d180 1
a180 1
        MLWorks.Option.SOME t => t
d195 1
a195 1
      val bool_scheme = Scheme.make_scheme ([],(CONSTYPE ([],Types.bool_tyname),MLWorks.Option.NONE))
d216 1
a216 1
                                       MLWorks.Option.NONE))
d223 1
a223 1
                                       MLWorks.Option.NONE))
d240 1
a240 1
                                   ([aty],Types.list_tyname)),MLWorks.Option.NONE))
d258 1
a258 1
                                  MLWorks.Option.NONE))
d286 1
a286 1
                        Scheme.make_scheme ([aty],(aty,MLWorks.Option.NONE)),
d296 1
a296 1
	  if n = 0 then String.implode(" " :: res)
@


1.40.2.1
log
@branched from 1.40
@
text
@a3 4
 * Revision 1.40  1996/09/23  12:19:28  andreww
 * [Bug #1605]
 * removing default_overloads flag.  Now subsumed by old_definition.
 *
@


1.40.1.1
log
@branched from 1.40
@
text
@a3 4
 * Revision 1.40  1996/09/23  12:19:28  andreww
 * [Bug #1605]
 * removing default_overloads flag.  Now subsumed by old_definition.
 *
@


1.39
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d319 1
a319 1
		{default_overloads, ...},
d329 1
a329 1
	  Types.resolve_overloading (default_overloads, ty, error_fn)
d331 1
a331 1
	  Types.resolve_overloading (default_overloads, ty, error_fn)
@


1.39.1.1
log
@branched from 1.39
@
text
@a3 6
 * Revision 1.39  1996/04/30  15:26:02  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.38
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d286 1
a286 1
	  if n = 0 then implode(" " :: res)
@


1.37
log
@Added realint_tyvar for abs and ~; removed real_tyvar and int_tyvar.
@
text
@d4 3
d182 1
a182 1
      val bool_scheme = Scheme.make_scheme ([],(CONSTYPE ([],Types.bool_tyname),Option.ABSENT))
d203 1
a203 1
                                       Option.ABSENT))
d210 1
a210 1
                                       Option.ABSENT))
d227 1
a227 1
                                   ([aty],Types.list_tyname)),Option.ABSENT))
d245 1
a245 1
                                  Option.ABSENT))
d273 1
a273 1
                        Scheme.make_scheme ([aty],(aty,Option.ABSENT)),
@


1.36
log
@Add div and mod to list of overloaded operators
@
text
@d4 3
d250 2
a251 2
              [("~", Scheme.unary_overloaded_scheme, Ident.num_tyvar),
               ("abs", Scheme.unary_overloaded_scheme, Ident.num_tyvar),
d257 1
@


1.35
log
@Get list of builtin library values from Primitives
@
text
@d4 3
d252 2
@


1.34
log
@Removing debug structure
@
text
@d4 3
a120 1
require "../utils/print";
d122 1
a131 1
  structure Print : PRINT
d133 1
d173 1
a173 31
      fun init_scheme ([tyname1]) = 
	Scheme.make_scheme ([],(CONSTYPE ([],tyname1),Option.ABSENT))
	| init_scheme ([tyname1,tyname2]) = 
	  Scheme.make_scheme ([],(FUNTYPE
			      (CONSTYPE ([],tyname1),
			       CONSTYPE ([],tyname2)),Option.ABSENT))
	| init_scheme ([tyname1,tyname2,tyname3]) = 
	  Scheme.make_scheme ([],(FUNTYPE
			      (Types.add_to_rectype
			       (Ident.LAB(Ident.Symbol.find_symbol ("1")),
				CONSTYPE ([],tyname1),
			       Types.add_to_rectype
				(Ident.LAB (Ident.Symbol.find_symbol ("2")),
				 CONSTYPE ([],tyname2),
				 Types.empty_rectype)),
			       CONSTYPE ([],tyname3)),Option.ABSENT))
	| init_scheme ([tyname1,tyname2,tyname3,tyname4]) = 
	  Scheme.make_scheme ([],(FUNTYPE
			      (Types.add_to_rectype
			       (Ident.LAB(Ident.Symbol.find_symbol ("1")),
				CONSTYPE ([],tyname1),
			       Types.add_to_rectype
				(Ident.LAB (Ident.Symbol.find_symbol ("2")),
				 CONSTYPE ([],tyname2),
                                 Types.add_to_rectype
                                 (Ident.LAB (Ident.Symbol.find_symbol ("3")),
                                  CONSTYPE ([],tyname3),
                                  Types.empty_rectype))),
                               CONSTYPE ([],tyname4)),Option.ABSENT))
	| init_scheme (_) = Crash.impossible "Valenv.init_scheme"

d181 39
a219 36
	add_to_ve (Ident.CON (Ident.Symbol.find_symbol ("true")),
		   init_scheme ([Types.bool_tyname]),
	add_to_ve (Ident.CON (Ident.Symbol.find_symbol ("false")),
		 init_scheme ([Types.bool_tyname]),
      add_to_ve (Ident.CON (Ident.Symbol.find_symbol ("ref")),      
		 let val aty = atyvar ("'_a",false,true)
		 in
		   Scheme.make_scheme([aty],(FUNTYPE (aty,CONSTYPE
						     ([aty],Types.ref_tyname)),
                                             Option.ABSENT))
		 end,
      add_to_ve (Ident.CON (Ident.Symbol.find_symbol ("nil")),      
		 let val aty = atyvar ("'a",false,false)
		 in
		   Scheme.make_scheme([aty],(CONSTYPE ([aty],Types.list_tyname),
                                             Option.ABSENT))
		 end,
      add_to_ve (Ident.CON (Ident.Symbol.find_symbol ("::")),
		 let val aty = atyvar ("'a",false,false)
		 in
		   Scheme.make_scheme ([aty],
				      (FUNTYPE
				       (Types.add_to_rectype
					(Ident.LAB
					 (Ident.Symbol.find_symbol ("1")),
					 aty,Types.add_to_rectype
					 (Ident.LAB
					  (Ident.Symbol.find_symbol ("2")),
					  CONSTYPE
					  ([aty],Types.list_tyname),
					  Types.empty_rectype)),
					CONSTYPE
					([aty],Types.list_tyname)),Option.ABSENT))
		 end,
               empty_valenv)))))   

a220 18
        val initial_ve_for_builtin_library =
          let
            val aty = atyvar ("'a", false, false)
            val aty' = atyvar ("'a", false, false)
          in
            add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("call_c")),
                       Scheme.make_scheme ([aty],
                                          (FUNTYPE
                                           (CONSTYPE ([], Types.string_tyname),
                                            aty),Option.ABSENT)),
            add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("don't_call_c")),
                       Scheme.make_scheme ([aty'],
                                          (FUNTYPE
                                           (CONSTYPE ([], Types.string_tyname),
                                            aty'),Option.ABSENT)),
                       basic_constructor_set))
          end

d227 10
a236 10
				      (FUNTYPE
				       (Types.add_to_rectype
					(Ident.LAB
					 (Ident.Symbol.find_symbol ("1")),aty,
					 Types.add_to_rectype
					 (Ident.LAB
					  (Ident.Symbol.find_symbol ("2")),aty,
					  Types.empty_rectype)),
					CONSTYPE ([],Types.bool_tyname)),
                                       Option.ABSENT))
d238 2
a239 2
           Lists.reducer
	     (fn ((s, f, t), ve) =>
d243 2
a244 1
             ([("~", Scheme.unary_overloaded_scheme, Ident.num_tyvar),
d252 14
a265 2
               (">=", Scheme.predicate_overloaded_scheme, Ident.numtext_tyvar)],
	      basic_constructor_set))
@


1.33
log
@Added resolve_overloads.  Simplified code for creating initial ve.
@
text
@d4 3
a120 1
require "../typechecker/ty_debug";
d123 1
a128 5
  structure Debug :
    sig
      val set_debug_level : int -> unit
      val debug_level : unit -> int
    end
a130 1
  structure Ty_Debug : TY_DEBUG
a145 1
    val do_debug = Ty_Debug.do_debug
d148 1
a148 1
    exception Lookup_in_VE = NewMap.Undefined
d154 3
a156 6
      (if (do_debug andalso Debug.debug_level () > 10) 
	then (Print.print ("valid lookup \n");
	      Print.print (IdentPrint.debug_printValId valid);
	      Print.print ("\n"))
      else ();
	NewMap.apply'(valenv, valid))
d167 1
a167 6
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("add_to_ve ... \n");
	       Print.print (IdentPrint.debug_printValId valid);
	       Print.print ("\n"))
       else ();
	 VE ((ref 0, NewMap.define (amap,valid,scheme))))
d316 1
a316 7
      (if (do_debug andalso Debug.debug_level () > 10)
	 then (Print.print ("valenv_eq \n");
	       Print.print ("ve = " ^ string_valenv (0,ve) ^ "\n");
	       Print.print ("ve' = " ^ string_valenv (0,ve') ^ "\n");
	       Print.print ("\n"))
       else ();
       NewMap.eq (fn (sch,sch')=> Scheme.typescheme_eq (sch,sch')) (amap, amap'))
d319 1
a319 7
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("dom_valenv_eq \n");
	       Print.print ("ve = " ^ string_valenv (0,ve) ^ "\n");
	       Print.print ("ve' = " ^ string_valenv (0,ve') ^ "\n");
	       Print.print ("\n"))
       else ();
	 NewMap.eq (fn _ => true) (m, m'))
@


1.32
log
@TYCON' for type function functions in lambda code for Modules Debugger.
@
text
@d4 3
d116 1
d132 1
d141 1
d146 2
d276 5
a280 4
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("=")),
		 let val aty = atyvar ("''a",true,false)
		 in
		   Scheme.make_scheme ([aty],
d291 16
a306 30
		 end,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("~")),
		 Scheme.unary_overloaded_scheme 
                 (Ident.VAR (Ident.Symbol.find_symbol ("~"))),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("abs")),
		 Scheme.unary_overloaded_scheme
                 (Ident.VAR (Ident.Symbol.find_symbol ("abs"))),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("*")),
		 Scheme.binary_overloaded_scheme
                 (Ident.VAR (Ident.Symbol.find_symbol ("*"))),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("+")),
		 Scheme.binary_overloaded_scheme
                 (Ident.VAR (Ident.Symbol.find_symbol ("+"))),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("-")),
		 Scheme.binary_overloaded_scheme
                 (Ident.VAR (Ident.Symbol.find_symbol ("-"))),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("<")),
		 Scheme.predicate_overloaded_scheme
                 (Ident.VAR (Ident.Symbol.find_symbol ("<"))),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol (">")),
		 Scheme.predicate_overloaded_scheme
                 (Ident.VAR (Ident.Symbol.find_symbol (">"))),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("<=")),
		 Scheme.predicate_overloaded_scheme
                 (Ident.VAR (Ident.Symbol.find_symbol ("<="))),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol (">=")),
		 Scheme.predicate_overloaded_scheme
                 (Ident.VAR (Ident.Symbol.find_symbol (">="))),
                 basic_constructor_set))))))))))

d345 25
@


1.31
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d161 2
a162 1
	| (res, v as (Ident.VAR _), _) => v :: res)
@


1.30
log
@Options & Info changes
@
text
@d4 3
d171 1
a171 1
	Scheme.make_scheme ([],CONSTYPE ([],tyname1))
d173 1
a173 1
	  Scheme.make_scheme ([],FUNTYPE
d175 1
a175 1
			       CONSTYPE ([],tyname2)))
d177 1
a177 1
	  Scheme.make_scheme ([],FUNTYPE
d185 1
a185 1
			       CONSTYPE ([],tyname3)))
d187 1
a187 1
	  Scheme.make_scheme ([],FUNTYPE
d198 1
a198 1
                               CONSTYPE ([],tyname4)))
d202 2
a203 1
	TYVAR (ref 0,Ident.TYVAR (Ident.Symbol.find_symbol (id),eq,imp))
d215 3
a217 2
		   Scheme.make_scheme([aty],FUNTYPE (aty,CONSTYPE
						     ([aty],Types.ref_tyname)))
d222 2
a223 1
		   Scheme.make_scheme([aty],CONSTYPE ([aty],Types.list_tyname))
d229 1
a229 1
				       FUNTYPE
d240 1
a240 1
					([aty],Types.list_tyname)))
d248 1
d252 6
a257 1
                                           FUNTYPE
d259 2
a260 2
                                            aty)),
                       basic_constructor_set)
d268 1
a268 1
				       FUNTYPE
d276 2
a277 1
					CONSTYPE ([],Types.bool_tyname)))
d318 1
a318 1
	amap
d335 1
a335 1
       NewMap.eq Scheme.typescheme_eq (amap, amap'))
@


1.30.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.30  1993/03/04  10:23:31  matthew
Options & Info changes

@


1.29
log
@empty_rec_type to empty_rectype
@
text
@d4 3
d127 1
a127 1
  sharing Types.Info = IdentPrint.Info = Scheme.Info
@


1.28
log
@Moved enrichment code to _realise
@
text
@d4 3
d178 1
a178 1
				 Types.empty_rec_type)),
d191 1
a191 1
                                  Types.empty_rec_type))),
d229 1
a229 1
					  Types.empty_rec_type)),
d260 1
a260 1
					  Types.empty_rec_type)),
@


1.27
log
@Anel's last changes
@
text
@d4 3
a127 1
    structure Info = Types.Info
a132 1
    exception EnrichError of string
a150 63

    (****
     The domain of amap is a subset of the domain of amap' and for every 
     element in the domain of amap the scheme corresponding to it in amap'
     must generalise the scheme corresponding to it in amap.
     ****)

    fun ve_ran_enriches options (level,ve as VE (_,amap),ve' as VE (_,amap')) =
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("ve_ran_enriches");
	       Print.print ("\n"))
       else ();
      let 
	fun ran_enriches (valid, scheme) =
	  let 
	    val scheme' = case NewMap.tryApply'(amap', valid) of
	      NewMap.YES x => x
	    | _ =>
		raise EnrichError ("Missing val in structure: " ^
				   (IdentPrint.printValId options valid))
	  in
	    (Scheme.scheme_generalises options (valid,level,scheme,scheme')
	     handle Scheme.EnrichError s => raise EnrichError s)
	  end
      in
	NewMap.forall ran_enriches amap
      end)

    (****
     Used in the enrichment test for EE's.  Again, the domain of amap is a
     subset of the domain of amap'.  This time however the schemes in both
     amap and amap' corresponding to each element of amap must be equal.
     ****)

    fun ee_ran_eq (ve as VE (_,amap),ve' as VE (_,amap')) =
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("ee_ran_eq");
	       Print.print ("\n"))
       else ();
      let 
	fun ran_eq (valid, scheme) =
	  let
	    val scheme' = case NewMap.tryApply'(amap', valid) of
	      NewMap.YES x => x
	    | _ =>
		raise EnrichError ("Missing exception in structure: " ^
				   (IdentPrint.debug_printValId valid))
	  in
	    if Scheme.typescheme_eq (scheme,scheme') then
	      true
	    else
              (* think this can't happen *)
	      raise EnrichError
		("    spec - " ^
		 (IdentPrint.debug_printValId valid) ^ " : " ^
		 (Scheme.string_scheme scheme) ^ 
		 "\n    actual - " ^
		 (IdentPrint.debug_printValId valid) ^ " : " ^
		 (Scheme.string_scheme scheme'))
	  end
      in
	NewMap.forall ran_eq amap
      end)
@


1.26
log
@Propagating options to signature matching error messages.
,
@
text
@d4 3
d323 2
a324 1
		 Scheme.unary_overloaded_scheme,
d326 2
a327 1
		 Scheme.unary_overloaded_scheme,
d329 2
a330 1
		 Scheme.binary_overloaded_scheme,
d332 2
a333 1
		 Scheme.binary_overloaded_scheme,
d335 2
a336 1
		 Scheme.binary_overloaded_scheme,
d338 2
a339 1
		 Scheme.predicate_overloaded_scheme,
d341 2
a342 1
		 Scheme.predicate_overloaded_scheme,
d344 2
a345 1
		 Scheme.predicate_overloaded_scheme,
d347 2
a348 1
		 Scheme.predicate_overloaded_scheme,
@


1.25
log
@Error message revisions.
@
text
@d4 3
d114 2
d122 2
a123 1
	 
d154 1
a154 1
    fun ve_ran_enriches (level,ve as VE (_,amap),ve' as VE (_,amap')) =
d166 1
a166 1
				   (IdentPrint.debug_printValId valid))
d168 1
a168 1
	    (Scheme.scheme_generalises (valid,level,scheme,scheme')
@


1.24
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d159 2
a160 2
		raise EnrichError ("Unmatched val specification : " ^
				   (IdentPrint.debug_printValId valid) ^ "\n")
d186 2
a187 2
		raise EnrichError ("Unmatched exception specification : " ^
				   (IdentPrint.debug_printValId valid) ^ "\n")
d192 1
d199 1
a199 1
		 (Scheme.string_scheme scheme') ^ "\n")
@


1.23
log
@Added special maps for tyfun_id, tyname_id, strname_id
@
text
@d4 3
d126 1
a126 1
	      Print.print (IdentPrint.printValId valid);
d156 1
a156 1
				   (IdentPrint.printValId valid) ^ "\n")
d183 1
a183 1
				   (IdentPrint.printValId valid) ^ "\n")
d190 1
a190 1
		 (IdentPrint.printValId valid) ^ " : " ^
d193 1
a193 1
		 (IdentPrint.printValId valid) ^ " : " ^
d203 1
a203 1
	       Print.print (IdentPrint.printValId valid);
d336 1
a336 1
	NewMap.string IdentPrint.printValId Scheme.string_scheme
@


1.22
log
@Changed valenv printing
@
text
@d4 3
d149 3
a151 2
	    val scheme' = NewMap.apply'(amap', valid)
	      handle NewMap.Undefined => 
d176 3
a178 2
	    val scheme' = NewMap.apply'(amap', valid)
	      handle NewMap.Undefined => 
d371 2
a372 1
      Lists.filter(Lists.reducel Scheme.tyvars ([], NewMap.range amap))
@


1.21
log
@Yet more changes to get structure copying working better.
@
text
@d4 3
d326 1
a326 1
	  else print_spaces ("  " :: res, n-1)
d329 1
a329 1
	{start = "{", domSep = " |--> ", itemSep = print_spaces([], start), finish = "}"}
@


1.20
log
@Added Anel's changes, and changed some stuff to do better
equality checking of valenvs etc.
@
text
@d4 4
d355 1
a355 1
    fun ve_copy (VE (_,amap),tyname_copies,tynamecopy_fun) = 
d357 1
a357 7
	fun copy_valenvs((ve,tyname_copies), valid,scheme) =
	  let
	    val (scheme',tyname_copies') = 
	      Scheme.scheme_copy (scheme,tyname_copies,tynamecopy_fun)
	  in
	    (add_to_ve (valid,scheme',ve), tyname_copies')
	  end
d359 1
a359 1
	NewMap.fold copy_valenvs ((empty_valenv, tyname_copies), amap)
@


1.19
log
@Removed irrelevant handlers and new exceptions
@
text
@d4 3
d119 5
a123 3
      map (fn Ident.CON sym => Ident.VAR sym
            | Ident.EXCON sym => Ident.VAR sym
	    | var as (Ident.VAR sym) => var) (NewMap.domain_ordered amap)
d137 1
a137 2
	fun ran_enriches(res,valid,scheme) =
	  res andalso
d148 1
a148 1
	NewMap.fold ran_enriches (true, amap)
d156 1
d163 1
a163 2
	fun ran_eq(res, valid,scheme) =
	  res andalso
d173 7
a179 6
	      raise EnrichError ("    spec - " ^
				 (IdentPrint.printValId valid) ^ " : " ^
				 (Scheme.string_scheme scheme) ^ 
				 "\n    actual - " ^
				 (IdentPrint.printValId valid) ^ " : " ^
				 (Scheme.string_scheme scheme') ^ "\n")
d182 1
a182 1
	NewMap.fold ran_eq (true, amap)
d191 1
a191 1
	 VE ((ref 0,NewMap.define (amap,valid,scheme))))
a193 1

d315 1
a315 1
    fun string_valenv (start,VE (_,amap)) =
d317 3
a319 21
        fun print_spaces n = if n = 0 
			       then " " 
			     else " " ^ (print_spaces (n-1))

        fun print_pair ((object,image),print_object,print_image,connector) = 
          print_object object ^ connector ^ print_image image

        val valid_scheme_list = NewMap.to_list_ordered amap

        val ve_string = 
          Lists.to_string
          (fn (x,y) => print_pair ((x,y),IdentPrint.printValId,
                                  fn ascheme => (Scheme.string_scheme ascheme)^
                                  "\n" ^ (print_spaces start)," |--> "))
          valid_scheme_list

	  fun shorten (n,l as (h::t)) = if n = 0 then l else shorten (n-1,t)
	    | shorten (n,[]) = []

	  val cut_string = implode (rev (shorten (start + 2,
						  rev (explode ve_string))))
d321 3
a323 2
	"{" ^ cut_string ^ "}"
      
d328 5
d340 1
a340 13
       let 
         fun eqmaps ([],[]) = true
	   | eqmaps ([],_) = false
	   | eqmaps (_,[]) = false
	   | eqmaps ((valid,scheme)::t,(valid',scheme')::t') =
	     Ident.valid_eq (valid,valid')
	     andalso
	     Scheme.typescheme_eq (scheme,scheme')
	     andalso
	     eqmaps (t,t')
      in
        eqmaps (NewMap.to_list_ordered amap,NewMap.to_list_ordered amap')
      end)
d342 1
a342 1
    fun dom_valenv_eq (ve,ve') =
d349 1
a349 5
	 (****
	  This is OK for determining the equality of the domains because
	  they are sorted lists.  The type of the elements admits equality.
	  ****)
	 ve_domain ve = ve_domain ve')
@


1.18
log
@Changed to use Lists.reducel instead of Lists.foldr.
@
text
@d4 3
d101 1
a101 1
    exception Lookup_in_VE
d113 1
a113 2
	NewMap.apply'(valenv, valid)
	 handle NewMap.Undefined => raise Lookup_in_VE)
@


1.17
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d387 1
a387 2
      Lists.filter (Lists.foldr Scheme.tyvars [] (NewMap.range amap))

@


1.16
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
a62 1
require "../utils/set";
a63 1
require "../utils/newmap";
d65 1
a66 1
require "../typechecker/datatypes";
a72 2
  structure Set       : SET
  structure NewMap    : NEWMAP
d81 1
a81 1
  structure Datatypes : DATATYPES
d84 2
a85 2
  sharing Datatypes = Types.Datatypes = Scheme.Datatypes
  sharing NewMap = Scheme.NewMap
d89 1
a89 2
    structure NewMap = NewMap
    structure Datatypes = Datatypes
d98 1
a98 8
      let
        val valid_scheme_list = NewMap.to_list amap'
      in
        VE (ref 0,
            Lists.reducel 
            (fn (tree,(valid,scheme)) => NewMap.define (tree,valid,scheme))
            (amap,valid_scheme_list))
      end
d106 1
a106 1
	NewMap.apply valenv valid
d126 11
a136 32
(*
	val _ = Print.print("Checking ran_enriches on ve' =\n")
	val _ = Lists.iterate
	  (fn x => Print.print(Datatypes.IdentPrint.printValId x ^ "\n"))
	  (Mapping.domain amap')
	val _ = Print.print("In ve =\n")
	val _ = Lists.iterate
	  (fn x => Print.print(Datatypes.IdentPrint.printValId x ^ "\n"))
	  (Mapping.domain amap)
	val _ = Print.print("domain' =\n")
	val _ = Lists.iterate
	  (fn x => Print.print(Datatypes.IdentPrint.printValId x ^ "\n"))
	  domain'
	val _ = Print.print("domain =\n")
	val _ = Lists.iterate
	  (fn x => Print.print(Datatypes.IdentPrint.printValId x ^ "\n"))
	  domain
*)
	val valid_scheme_list = NewMap.to_list amap
	fun ran_enriches [] = true
	  | ran_enriches ((valid,scheme)::valid_schemes) = 
            let 
              val scheme' = NewMap.apply amap' valid
                handle NewMap.Undefined => 
                  raise EnrichError ("Unmatched val specification : " ^
                                     (IdentPrint.printValId valid) ^ "\n")
            in
              (Scheme.scheme_generalises (valid,level,scheme,scheme')
               handle Scheme.EnrichError s => raise EnrichError s)
	      andalso 
	      ran_enriches valid_schemes
            end
d138 1
a138 1
	ran_enriches valid_scheme_list
d152 18
a169 19
	val valid_scheme_list = NewMap.to_list amap
	fun ran_eq [] = true
	  | ran_eq ((valid,scheme)::valid_schemes) = 
            let
              val scheme' = NewMap.apply amap' valid
                handle NewMap.Undefined => 
                  raise EnrichError ("Unmatched exception specification : " ^
                                     (IdentPrint.printValId valid) ^ "\n")
            in
              if Scheme.typescheme_eq (scheme,scheme')
                then ran_eq valid_schemes
              else
	        raise EnrichError ("    spec - " ^
		                   (IdentPrint.printValId valid) ^ " : " ^
				   (Scheme.string_scheme scheme) ^ 
				   "\n    actual - " ^
				   (IdentPrint.printValId valid) ^ " : " ^
				   (Scheme.string_scheme scheme') ^ "\n")
           end
d171 1
a171 1
	ran_eq valid_scheme_list
d336 1
a336 1
      (if (do_debug andalso Debug.debug_level () > 10) 
d371 7
a377 11
	val valid_scheme_list = NewMap.to_list amap
	fun copy_valenvs ([],tyname_copies,ve,_) = (ve,tyname_copies)
	  | copy_valenvs ((valid,scheme)::valid_schemes,tyname_copies,ve,
                          tynamecopy_fun) = 
	    let 
	      val (scheme',tyname_copies') = 
		Scheme.scheme_copy (scheme,tyname_copies,tynamecopy_fun)
	    in
	      copy_valenvs (valid_schemes,tyname_copies',
                            add_to_ve (valid,scheme',ve),tynamecopy_fun)
	    end
d379 1
a379 2
	copy_valenvs (valid_scheme_list,tyname_copies,empty_valenv,
                      tynamecopy_fun)
@


1.15
log
@Changed the type of call_c in the environment of the builtin library. It is
now a string -> 'a.
@
text
@a98 2
    val empty_valenv = VE (ref 0,Mapping.empty_eqfunmap Ident.valid_eq)

d100 8
a107 1
      VE (ref 0,Mapping.plus (amap,amap',Ident.valid_order))
d109 1
a109 1
    fun lookup (val_id,VE (_,valenv)) = 
d111 2
a112 2
	then (Print.print ("val_id lookup \n");
	      Print.print (IdentPrint.printValId val_id);
d115 2
a116 2
	Mapping.lookup (val_id,valenv)) 
	 handle Mapping.Lookup => raise Lookup_in_VE
d121 1
a121 1
	    | var as (Ident.VAR sym) => var) (Mapping.domain amap)
d153 1
a153 1
	val valid_scheme_list = Mapping.assoc amap
d157 2
a158 2
              val scheme' = Mapping.lookup (valid,amap')
                handle Mapping.Lookup => 
d182 1
a182 1
	val valid_scheme_list = Mapping.assoc amap
d186 2
a187 2
              val scheme' = Mapping.lookup (valid,amap')
                handle Mapping.Lookup => 
d205 1
a205 1
    fun add_to_ve (val_id,scheme,VE (_,valenv)) =
d208 1
a208 1
	       Print.print (IdentPrint.printValId val_id);
d211 1
a211 1
	 VE ((ref 0,Mapping.add ((val_id,scheme),valenv,Ident.valid_order))))
d252 3
a254 3
        add_to_ve (Ident.CON (Ident.Symbol.find_symbol ("true")),
                     init_scheme ([Types.bool_tyname]),
      add_to_ve (Ident.CON (Ident.Symbol.find_symbol ("false")),
a298 1

d337 17
a353 10
      let fun print_spaces n = if n = 0 
				 then " " 
			       else 
				 " " ^ (print_spaces (n-1))
	  val ve_string = Mapping.print_map 
	    (amap,
	     IdentPrint.printValId,
	     fn ascheme => (Scheme.string_scheme ascheme) ^ "\n" ^ 
	     (print_spaces start),
	     " |--> ")
d356 1
d364 1
a364 1
    fun empty_valenvp (VE (_,amap)) = Mapping.emptymap_p amap
d373 13
a385 1
      Mapping.eqmaps (amap,amap',Scheme.typescheme_eq))
d402 1
a402 1
	val valid_scheme_list = Mapping.assoc amap
d419 1
a419 1
      Lists.filter (Mapping.fold Scheme.tyvars [] amap)
@


1.14
log
@Improved enrichment efficiency
@
text
@d4 3
a244 31

	val callc_scheme =
	  let
	    val alpha = atyvar("'a",false,false)
	    val beta = atyvar("'b",false,false)

	fun make_up_a_scheme (vars,[tyname1,tyname2,tyname3]) = 
	  Scheme.make_scheme (vars,FUNTYPE
			      (Types.add_to_rectype
			       (Ident.LAB(Ident.Symbol.find_symbol ("1")),
				tyname1,
				Types.add_to_rectype
				(Ident.LAB (Ident.Symbol.find_symbol ("2")),
				 tyname2,
				 Types.empty_rec_type)),
			       tyname3))
          | make_up_a_scheme _ = Crash.impossible "Should match the callc scheme "

	    val int_alpha_tuple =
	      Types.add_to_rectype
	      (Ident.LAB(Ident.Symbol.find_symbol "1"),
	       CONSTYPE ([], Types.int_tyname),
	       Types.add_to_rectype
	       (Ident.LAB(Ident.Symbol.find_symbol "2"),
		alpha,
		Types.empty_rec_type))
	  in
	    make_up_a_scheme
	    ([alpha, beta],[CONSTYPE([],Types.int_tyname),alpha,beta])
	  end

d246 2
a247 2
        val basic_constructor_set =
          add_to_ve (Ident.CON (Ident.Symbol.find_symbol ("true")),
d283 10
a292 3
               add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("call_c")),
			    callc_scheme,
                            basic_constructor_set)
@


1.13
log
@Changed to use btrees for renaming of tynames and strnames
@
text
@d4 3
a126 2
	val domain' = ve_domain ve'
	val domain = ve_domain ve
d145 14
a158 23
	fun ran_enriches ([],amap,amap') = true
	  | ran_enriches (h::t,amap,amap') =  
	    if Lists.member(h, domain) then
	      let
		val scheme = Mapping.lookup (h,amap) 
		  handle exn as Mapping.Lookup => (Print.print"Lookup (ran_enriches(5))";
						   raise exn)
		val scheme' = Mapping.lookup (h,amap')
		  handle exn as Mapping.Lookup =>
		    (Print.print("Lookup (ran_enriches(6)) of '" ^
				 IdentPrint.printValId h ^ "'\nin ");
		     Lists.iterate
		     (fn x => Print.print(IdentPrint.printValId x ^ "\n"))
		     (Mapping.domain amap');
		     raise exn)
	      in 
		(Scheme.scheme_generalises (h,level,scheme,scheme')
		 handle Scheme.EnrichError s => raise EnrichError s)
		andalso 
		ran_enriches (t,amap,amap')
	      end
	    else
	      ran_enriches (t,amap,amap')
d160 1
a160 1
	ran_enriches(domain',amap,amap') 
d174 19
a192 26
	val domain' = ve_domain ve'
	val domain = ve_domain ve
	fun ran_eq ([],amap,amap') = true
	  | ran_eq (h::t,amap,amap') =  
	    if Lists.member(h, domain)
	      then
		let
		  val scheme = Mapping.lookup (h,amap)
		    handle exn as Mapping.Lookup => (Print.print"Lookup (ran_eq)";
						     raise exn)
		  val scheme' = Mapping.lookup (h,amap')
		    handle exn as Mapping.Lookup => (Print.print"Lookup (ran_eq)";
						     raise exn)
		in 
		  if Scheme.typescheme_eq (scheme,scheme') 
		    then ran_eq (t,amap,amap')
		  else
		    raise EnrichError ("    spec - " ^
				       (IdentPrint.printValId h) ^ " : " ^
				       (Scheme.string_scheme scheme) ^ 
				       "\n    actual - " ^
				       (IdentPrint.printValId h) ^ " : " ^
				       (Scheme.string_scheme scheme') ^"\n")
		end
	    else
	      ran_eq (t,amap,amap')
d194 1
a194 1
	ran_eq (domain',amap,amap')
@


1.12
log
@Added the printing of the name of the relevant identifier in a couple of error messages
@
text
@d4 3
d56 1
d67 1
d79 3
a81 2
  sharing Datatypes = Types.Datatypes = Scheme.Datatypes) 
  : VALENV =
d84 1
@


1.11
log
@Anel's fixes
@
text
@d4 3
d153 1
a153 1
		(Scheme.scheme_generalises (level,scheme,scheme')
@


1.10
log
@New pervasive library code - cut some things out of the initial type basis
@
text
@d4 3
d389 1
a389 1
    fun dom_valenv_eq (ve as VE (_,amap),ve' as VE (_,amap')) =
d396 5
a400 10
	 let 
	   val dom = ve_domain ve
	   val dom' = ve_domain ve'
	 in
	   (****
	    This is OK for determining the equality of the domains because
	    they are sorted lists.  The type of the elements admits equality.
	    ****)
	   dom = dom'
	 end)
d402 1
a402 1
    fun ve_copy (ve as VE (_,amap),tyname_copies,tynamecopy_fun) = 
d404 1
a404 1
	val valid_list = Mapping.domain amap
d406 2
a407 1
	  | copy_valenvs (valid::valids,tyname_copies,ve,tynamecopy_fun) = 
d409 1
a409 4
	      val scheme = Mapping.lookup (valid,amap)
		handle exn as Mapping.Lookup => (Print.print"Lookup (copy_valenvs)";
						 raise exn)
	      val (copy,tyname_copies') = 
d412 2
a413 2
	      copy_valenvs (valids,tyname_copies',add_to_ve (valid,copy,ve),
			    tynamecopy_fun)
d416 2
a417 1
	copy_valenvs (valid_list,tyname_copies,empty_valenv,tynamecopy_fun)
d420 2
a421 1
    fun tyvars (VE (_,amap)) = Lists.filter (Mapping.fold Scheme.tyvars [] amap)
@


1.9
log
@Removed some loop invariants from ve_ran_enriches and ee_ran_enriches
This is done for efficiency only, since NJ is too dumb to do it for you.
Our compiler, will, when we get there!
@
text
@d4 5
d243 1
a243 39
      val initial_ee = 
	add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Abs")),
		  init_scheme([Types.exn_tyname]),
	add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Ord")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Chr")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Div")),
		  init_scheme([Types.exn_tyname]),		
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Mod")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Quot")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Prod")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Neg")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Sum")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Diff")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Floor")),
		  init_scheme([Types.exn_tyname]),
	add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Sqrt")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Exp")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Ln")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Io")),
		  init_scheme([Types.string_tyname,
			       Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Match")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Bind")),
		  init_scheme([Types.exn_tyname]),
        add_to_ve(Ident.EXCON(Ident.Symbol.find_symbol("Interrupt")),
		  init_scheme([Types.exn_tyname]),
		  empty_valenv))))))))))))))))))
d245 4
d250 11
a260 13
      val initial_ve = ve_plus_ve (initial_ee,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("explode")),
		 Scheme.make_scheme
		 ([],FUNTYPE
		  (CONSTYPE ([],Types.string_tyname),
		   CONSTYPE ([CONSTYPE ([],Types.string_tyname)],
			     Types.list_tyname))),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("implode")),
		 Scheme.make_scheme
		 ([],FUNTYPE
		  (CONSTYPE ([CONSTYPE ([],Types.string_tyname)],
			     Types.list_tyname),
		   CONSTYPE ([],Types.string_tyname))),
d262 12
a273 5
		 (* 4/11 added *)
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("nthchr")),
		 init_scheme([Types.string_tyname,
			      Types.int_tyname,
			      Types.string_tyname]),
d275 4
a278 30
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("not")),
		 init_scheme ([Types.bool_tyname,Types.bool_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("~")),
		 Scheme.unary_overloaded_scheme,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("abs")),
		 Scheme.unary_overloaded_scheme,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("floor")),
		 init_scheme ([Types.real_tyname,Types.int_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("real")),
		 init_scheme ([Types.int_tyname,Types.real_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("sqrt")),
		 init_scheme ([Types.real_tyname,Types.real_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("sin")),
		 init_scheme ([Types.real_tyname,Types.real_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("cos")),
		 init_scheme ([Types.real_tyname,Types.real_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("arctan")),
		 init_scheme ([Types.real_tyname,Types.real_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("exp")),
		 init_scheme ([Types.real_tyname,Types.real_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("ln")),
		 init_scheme ([Types.real_tyname,Types.real_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("size")),
		 init_scheme ([Types.string_tyname,Types.int_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("chr")),
		 init_scheme ([Types.int_tyname,Types.string_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("ord")),
		 init_scheme ([Types.string_tyname,Types.int_tyname]),
      add_to_ve (Ident.CON (Ident.Symbol.find_symbol ("true")),
		 init_scheme ([Types.bool_tyname]),
a280 53
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("/")),
		 init_scheme ([Types.real_tyname,Types.real_tyname,
			       Types.real_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("div")),
		 init_scheme ([Types.int_tyname,Types.int_tyname,
			       Types.int_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("mod")),
		 init_scheme ([Types.int_tyname,Types.int_tyname,
			       Types.int_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("*")),
		 Scheme.binary_overloaded_scheme,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("+")),
		 Scheme.binary_overloaded_scheme,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("-")),
		 Scheme.binary_overloaded_scheme,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("^")),
		 init_scheme ([Types.string_tyname,Types.string_tyname,
			       Types.string_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("<")),
		 Scheme.predicate_overloaded_scheme,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol (">")),
		 Scheme.predicate_overloaded_scheme,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("<=")),
		 Scheme.predicate_overloaded_scheme,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol (">=")),
		 Scheme.predicate_overloaded_scheme,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("map")),      
		 let 
		   val aty = atyvar ("'a",false,false)
		   val bty = atyvar ("'b",false,false)
		in
		  Scheme.make_scheme ([aty,bty],
				      FUNTYPE (FUNTYPE (aty,bty),
					       FUNTYPE (CONSTYPE 
							([aty],
							 Types.list_tyname),
							CONSTYPE
							([bty],
							 Types.list_tyname))))
		end,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("rev")),      
		 let val aty = atyvar ("'a",false,false)
		 in
		   Scheme.make_scheme ([aty],FUNTYPE
				       (CONSTYPE ([aty],Types.list_tyname),
					CONSTYPE ([aty],Types.list_tyname)))
		 end,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("!")),      
		 let val aty = atyvar ("'a",false,false)
		 in
		   Scheme.make_scheme([aty],FUNTYPE
				      (CONSTYPE ([aty],Types.ref_tyname),aty))
		end,
d309 10
a318 19
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("@@")),
		 let val aty = atyvar ("'a",false,false)		  
		 in
		   Scheme.make_scheme ([aty],
				       FUNTYPE
				       (Types.add_to_rectype
					(Ident.LAB
					 (Ident.Symbol.find_symbol ("1")),
					 CONSTYPE
					 ([aty],Types.list_tyname),
					 Types.add_to_rectype
					 (Ident.LAB
					  (Ident.Symbol.find_symbol ("2")),
					  CONSTYPE
					  ([aty],Types.list_tyname),
					  Types.empty_rec_type)),
					CONSTYPE
					([aty],Types.list_tyname)))
		 end,
d333 19
a351 94
       add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("<>")),
		  let val aty = atyvar ("''a",true,false)
		  in
		    Scheme.make_scheme ([aty],
					FUNTYPE
					(Types.add_to_rectype
					 (Ident.LAB
					  (Ident.Symbol.find_symbol ("1")),aty, 
					  Types.add_to_rectype
					  (Ident.LAB(Ident.Symbol.
						     find_symbol ("2")),aty,
					   Types.empty_rec_type)),
					 CONSTYPE ([],Types.bool_tyname)))
		  end,
       add_to_ve (Ident.VAR (Ident.Symbol.find_symbol (":=")),
		  let val aty = atyvar ("'a",false,false)
		  in
		    Scheme.make_scheme ([aty],
					FUNTYPE
					(Types.add_to_rectype
					 (Ident.LAB
					  (Ident.Symbol.find_symbol ("1")),
					  CONSTYPE
					  ([aty],Types.ref_tyname),
					  Types.add_to_rectype
					  (Ident.LAB
					   (Ident.Symbol.find_symbol ("2")),
					   aty,
					   Types.empty_rec_type)),
					 Types.empty_rec_type))
		  end,
       add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("o")),
		  let 
		    val aty = atyvar ("'a",false,false)		 
		    val bty = atyvar ("'b",false,false)
		    val cty = atyvar ("'c",false,false)
		  in
		    Scheme.make_scheme ([aty,bty,cty],
					FUNTYPE
					(Types.add_to_rectype
					 (Ident.LAB
					  (Ident.Symbol.find_symbol ("1")),
					  FUNTYPE (bty,cty),
					  Types.add_to_rectype
					  (Ident.LAB (Ident.Symbol.
						      find_symbol ("2")),
					   FUNTYPE (aty,bty),
					   Types.empty_rec_type)),
					 FUNTYPE (aty,cty)))
		  end,
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("std_in")),
		 init_scheme ([Types.instream_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("open_in")),
		 init_scheme ([Types.string_tyname,Types.instream_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("input")),
		 init_scheme ([Types.instream_tyname,Types.int_tyname,
			       Types.string_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("lookahead")),
		 init_scheme ([Types.instream_tyname,Types.string_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("close_in")),
		 Scheme.make_scheme ([],FUNTYPE
				     (CONSTYPE ([],
						      Types.instream_tyname),
				      Types.empty_rec_type)),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("end_of_stream")),
		 init_scheme ([Types.instream_tyname,Types.bool_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("std_out")),
		 init_scheme ([Types.outstream_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("open_out")),
		 init_scheme ([Types.string_tyname,Types.outstream_tyname]),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("output")),
		 Scheme.make_scheme ([],FUNTYPE
				     (Types.add_to_rectype
				      (Ident.LAB 
				       (Ident.Symbol.find_symbol ("1")),
				       CONSTYPE ([],Types.outstream_tyname),
				       Types.add_to_rectype
				       (Ident.LAB 
					(Ident.Symbol.find_symbol ("2")),
					CONSTYPE ([],Types.string_tyname),
					Types.empty_rec_type)),
				      Types.empty_rec_type)),
      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("close_out")),
		 Scheme.make_scheme ([],FUNTYPE
				     (CONSTYPE ([],Types.outstream_tyname),
				      Types.empty_rec_type)),

      (* substring is a temporary measure only - it is not standard *)

      add_to_ve (Ident.VAR (Ident.Symbol.find_symbol ("substring")),
                 init_scheme ([Types.string_tyname, Types.int_tyname,
                               Types.int_tyname, Types.string_tyname]),
		 empty_valenv
		 )))))))))))))))))))))))))))))))))))))))))))))))))))))
@


1.8
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d107 19
d128 19
a146 10
	    if Set.is_member (h,Set.list_to_set (ve_domain ve))
	      then let
		     val scheme = Mapping.lookup (h,amap) 
		     val scheme' = Mapping.lookup (h,amap')
		   in 
		     (Scheme.scheme_generalises (level,scheme,scheme')
		      handle Scheme.EnrichError s => raise EnrichError s)
		     andalso 
		     ran_enriches (t,amap,amap')
		   end
d150 1
a150 1
	ran_enriches (domain',amap,amap') 
d164 2
a165 1
	val domain = ve_domain ve'
d168 20
a187 15
	    if Set.is_member (h,Set.list_to_set (ve_domain ve))
	      then let
		     val scheme = Mapping.lookup (h,amap)
		     val scheme' = Mapping.lookup (h,amap')
		   in 
		     if Scheme.typescheme_eq (scheme,scheme') 
		       then ran_eq (t,amap,amap')
		     else
		       raise EnrichError ("    spec - " ^
					  (IdentPrint.printValId h) ^ " : " ^
					  (Scheme.string_scheme scheme) ^ 
					  "\n    actual - " ^
					  (IdentPrint.printValId h) ^ " : " ^
					  (Scheme.string_scheme scheme') ^"\n")
		   end
d191 1
a191 1
	ran_eq (domain,amap,amap')
d598 2
@


1.7
log
@Changed ref unit in valenv to ref int to assist encoder
@
text
@d4 3
d34 1
d39 1
d45 15
a59 11
functor Valenv (structure Datatypes : DATATYPES
		structure Types     : TYPES
		structure Scheme    : TYPESCHEME
		structure Crash     : CRASH
		structure Set       : SET
		structure Lists     : LISTS
		structure Debug : sig val set_debug_level : int -> unit
				      val debug_level : unit -> int
				  end
		structure Print : PRINT
		sharing Datatypes = Types.Datatypes = Scheme.Datatypes) 
d65 1
d77 1
a77 1
      (if (Debug.debug_level () > 10) 
d97 1
a97 1
      (if (Debug.debug_level () > 10) 
d127 1
a127 1
      (if (Debug.debug_level () > 10) 
d157 1
a157 1
      (if (Debug.debug_level () > 10) 
d527 1
a527 1
      (if (Debug.debug_level () > 10) 
d536 1
a536 1
      (if (Debug.debug_level () > 10) 
@


1.6
log
@Added a SUBSTRING pervasive as a temporary measure so that the same code
can be compiled under under both New Jersey and MLWorks.
@
text
@d4 4
d61 1
a61 1
    val empty_valenv = VE (ref (),Mapping.empty_eqfunmap Ident.valid_eq)
d64 1
a64 1
      VE (ref (),Mapping.plus (amap,amap',Ident.valid_order))
d152 1
a152 1
	 VE ((ref (),Mapping.add ((val_id,scheme),valenv,Ident.valid_order))))
@


1.5
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_valenv.sml,v $
d168 13
d479 6
d486 1
a486 1
		 ))))))))))))))))))))))))))))))))))))))))))))))))))))
@


1.4
log
@fixed bug in ve_copy which was changing identifier status of all valids
to vars (now uses Mapping.domain rather than ve_domain)
@
text
@d1 1
d4 4
d22 1
@


1.3
log
@Made valenv map an eqfun_map with Ident.eq_valid as equality function. This
reflects the fact that in the semantics the domain of VE is a union rather
than a _disjoint_ union of VAR, CON and EXCON. Also made ve_domain coerce
everything to a VAR - this avoids problems with erroneous distinction of 
valid identifier classes.
@
text
@d3 7
d513 1
a513 1
	val valid_list = ve_domain ve
@


1.2
log
@Modified to take new ValEnv definition with ref unit to allow
reading and writing circular data structures.
@
text
@d3 4
d41 1
a41 1
    val empty_valenv = VE (ref (),Mapping.empty_map)
d55 4
a58 1
    fun ve_domain (VE (_,amap)) = Mapping.domain amap
d66 1
a66 1
    fun ve_ran_enriches (level,VE (_,amap), VE (_,amap')) =
d72 1
a72 1
	val domain' = Mapping.domain amap'
d75 1
a75 1
	    if Set.is_member (h,Set.list_to_set (Mapping.domain amap))
d96 1
a96 1
    fun ee_ran_eq (VE (_,amap),VE (_,amap')) =
d102 1
a102 1
	val domain = Mapping.domain (amap')
d105 1
a105 1
	    if Set.is_member (h,Set.list_to_set (Mapping.domain amap))
d494 2
a495 2
	   val dom = Mapping.domain amap
	   val dom' = Mapping.domain amap'
d504 1
a504 1
    fun ve_copy (VE (_,amap),tyname_copies,tynamecopy_fun) = 
d506 1
a506 1
	val valid_list = Mapping.domain amap
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d37 1
a37 1
    val empty_valenv = VE Mapping.empty_map
d39 2
a40 2
    fun ve_plus_ve (VE amap,VE amap') = 
      VE (Mapping.plus (amap,amap',Ident.valid_order))
d42 1
a42 1
    fun lookup (val_id,VE (valenv)) = 
d51 1
a51 1
    fun ve_domain (VE amap) = Mapping.domain amap
d59 1
a59 1
    fun ve_ran_enriches (level,VE amap, VE amap') =
d89 1
a89 1
    fun ee_ran_eq (VE amap,VE amap') =
d119 1
a119 1
    fun add_to_ve (val_id,scheme,VE (valenv)) =
d125 1
a125 1
	 VE (Mapping.add ((val_id,scheme),valenv,Ident.valid_order)))
d448 1
a448 1
    fun string_valenv (start,VE amap) =
d468 1
a468 1
    fun empty_valenvp (VE amap) = Mapping.emptymap_p amap
d470 1
a470 1
    fun valenv_eq (ve as VE amap,ve' as VE amap') =
d479 1
a479 1
    fun dom_valenv_eq (ve as VE amap,ve' as VE amap') =
d497 1
a497 1
    fun ve_copy (VE amap,tyname_copies,tynamecopy_fun) = 
d514 1
a514 1
    fun tyvars (VE amap) = Lists.filter (Mapping.fold Scheme.tyvars [] amap)
@
