head	1.37;
access;
symbols
	MLW_daveb_inline_1_4_99:1.37.1
	MLWorks_21c0_1999_03_25:1.37
	MLWorks_20c1_1998_08_20:1.37
	MLWorks_20c0_1998_08_04:1.37
	MLWorks_20b2c2_1998_06_19:1.37
	MLWorks_20b2_Windows_1998_06_12:1.37
	MLWorks_20b1c1_1998_05_07:1.37
	MLWorks_20b0_1998_04_07:1.37
	MLWorks_20b0_1998_03_20:1.37
	MLWorks_20m2_1998_02_16:1.36
	MLWorks_20m1_1997_10_23:1.34
	MLWorks_11r1:1.33.6.1.1.1.1
	MLWorks_workspace_97:1.34.2
	MLWorks_dt_wizard:1.34.1
	MLWorks_11c0_1997_09_09:1.33.6.1.1.1
	MLWorks_10r3:1.33.6.1.3
	MLWorks_10r2_551:1.33.6.1.2
	MLWorks_11:1.33.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.33.6.1
	MLWorks_20m0_1997_06_20:1.34
	MLWorks_1_0_r2c2_1997_06_14:1.33.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.33.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.33.6
	MLWorks_BugFix_1997_04_24:1.33
	MLWorks_1_0_r2_Win32_1997_04_11:1.33
	MLWorks_1_0_r2_Unix_1997_04_04:1.33
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.33.4.1.1
	MLWorks_gui_1996_12_18:1.33.5
	MLWorks_1_0_Win32_1996_12_17:1.33.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.33.2.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.33.2.1
	MLWorks_1_0_Irix_1996_11_28:1.33.2.1.1
	MLWorks_1_0_Win32_1996_11_22:1.33.3
	MLWorks_1_0_Unix_1996_11_14:1.33.2
	MLWorks_Open_Beta2_1996_10_11:1.33.1
	MLWorks_License_dev:1.32.2
	MLWorks_1_open_beta_1996_09_13:1.32.1
	MLWorks_Open_Beta_1996_08_22:1.32
	MLWorks_Beta_1996_07_02:1.32
	MLWorks_Beta_1996_06_07:1.32
	MLWorks_Beta_1996_06_06:1.32
	MLWorks_Beta_1996_06_05:1.32
	MLWorks_Beta_1996_06_03:1.32
	MLWorks_Beta_1996_05_31:1.32
	MLWorks_Beta_1996_05_30:1.32
	ML_beta_release_12/08/94:1.28
	ML_beta_release_03/08/94:1.28
	ML_revised_beta_release_25/05/94:1.28
	ML_final_beta_release_02/03/94:1.28
	mlworks-28-01-1994:1.28
	Release:1.27
	mlworks-beta-01-09-1993:1.27
	MLWorks-1-0-4-29/01/1993:1.18
	MLWorks-1-0-3-21/12/1992:1.18
	MLWorks-1-0-2-15/12/1992:1.18
	MLWorks-1-0-1-04/12/1992:1.18
	checkpoint_17_08_92:1.11
	Ten15_release_19-11-91:1.2
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.37
date	98.02.19.16.47.35;	author mitchell;	state Exp;
branches
	1.37.1.1;
next	1.36;

1.36
date	98.01.30.09.51.08;	author johnh;	state Exp;
branches;
next	1.35;

1.35
date	97.11.13.11.21.44;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	97.05.19.12.54.47;	author jont;	state Exp;
branches
	1.34.1.1
	1.34.2.1;
next	1.33;

1.33
date	96.10.02.14.08.43;	author andreww;	state Exp;
branches
	1.33.1.1
	1.33.2.1
	1.33.3.1
	1.33.4.1
	1.33.5.1
	1.33.6.1;
next	1.32;

1.32
date	96.04.30.15.32.01;	author jont;	state Exp;
branches
	1.32.1.1
	1.32.2.1;
next	1.31;

1.31
date	95.04.05.09.55.07;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	95.02.07.14.48.04;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	94.09.23.12.46.41;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.11.30.11.29.36;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.06.30.15.37.22;	author daveb;	state Exp;
branches
	1.27.1.1;
next	1.26;

1.26
date	93.05.21.15.35.10;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.04.08.12.50.17;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.03.17.18.38.43;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.03.04.10.40.15;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.02.19.13.47.17;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.02.17.15.37.17;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	93.02.09.12.07.02;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.02.04.10.10.21;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	92.12.02.16.19.18;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.12.01.18.43.00;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	92.11.26.16.57.18;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	92.10.30.16.11.19;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.10.23.13.15.37;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.09.08.13.06.45;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.08.27.18.46.20;	author davidt;	state Exp;
branches;
next	1.11;

1.11
date	92.08.11.18.06.16;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.08.03.12.27.24;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.07.17.10.38.22;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.06.30.10.27.54;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.05.04.13.51.04;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.04.22.20.16.01;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.01.27.20.15.27;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.01.22.15.19.10;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.21.16.47.31;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.17.15.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.38.20;	author colin;	state Exp;
branches;
next	;

1.27.1.1
date	93.06.30.15.37.22;	author jont;	state Exp;
branches;
next	;

1.32.1.1
date	96.09.13.11.41.41;	author hope;	state Exp;
branches;
next	;

1.32.2.1
date	96.10.07.16.34.47;	author hope;	state Exp;
branches;
next	;

1.33.1.1
date	96.10.17.11.53.53;	author hope;	state Exp;
branches;
next	;

1.33.2.1
date	96.11.14.13.21.33;	author hope;	state Exp;
branches
	1.33.2.1.1.1;
next	;

1.33.2.1.1.1
date	96.11.28.15.32.33;	author hope;	state Exp;
branches;
next	;

1.33.3.1
date	96.11.22.18.39.13;	author hope;	state Exp;
branches;
next	;

1.33.4.1
date	96.12.17.18.18.14;	author hope;	state Exp;
branches
	1.33.4.1.1.1;
next	;

1.33.4.1.1.1
date	97.02.24.12.12.29;	author hope;	state Exp;
branches;
next	;

1.33.5.1
date	96.12.18.10.13.32;	author hope;	state Exp;
branches;
next	;

1.33.6.1
date	97.05.12.10.51.48;	author hope;	state Exp;
branches
	1.33.6.1.1.1
	1.33.6.1.2.1
	1.33.6.1.3.1;
next	;

1.33.6.1.1.1
date	97.07.28.18.33.37;	author daveb;	state Exp;
branches
	1.33.6.1.1.1.1.1;
next	;

1.33.6.1.1.1.1.1
date	97.10.07.11.59.36;	author jkbrook;	state Exp;
branches;
next	;

1.33.6.1.2.1
date	97.09.08.17.26.43;	author daveb;	state Exp;
branches;
next	;

1.33.6.1.3.1
date	97.09.09.14.23.34;	author daveb;	state Exp;
branches;
next	;

1.34.1.1
date	97.09.10.19.42.31;	author brucem;	state Exp;
branches;
next	;

1.34.2.1
date	97.09.11.21.10.02;	author daveb;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	97.11.20.17.09.18;	author daveb;	state Exp;
branches;
next	;

1.37.1.1
date	99.04.01.18.08.40;	author daveb;	state Exp;
branches;
next	;


desc
@Sigma (N)S - semantic object for signatures
See The Definition (section 5.1)
@


1.37
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _sigma.sml the functor *)
(*
$Log: _sigma.sml,v $
 * Revision 1.36  1998/01/30  09:51:08  johnh
 * [Bug #30326]
 * Merge im change from branch MLWorks_workspace_97
 *
 * Revision 1.35  1997/11/13  11:21:44  jont
 * [Bug #30089]
 * Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
 *
 * Revision 1.34.2.2  1997/11/20  17:09:18  daveb
 * [Bug #30326]
 *
 * Revision 1.34.2.1  1997/09/11  21:10:02  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.34  1997/05/19  12:54:47  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.33  1996/10/02  14:08:43  andreww
 * [Bug #1592]
 * propagating level information for new type names.
 *
 * Revision 1.32  1996/04/30  15:32:01  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.31  1995/04/05  09:55:07  matthew
 * Fix for rigid tynames in functor result problem
 * Use Stamp instead of Tyname_id etc.
 * \nImprovements to copying signatures
 *
Revision 1.30  1995/02/07  14:48:04  matthew
Removing debug stuff

Revision 1.29  1994/09/23  12:46:41  matthew
Commented calls to xtime

Revision 1.28  1993/11/30  11:29:36  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.27  1993/06/30  15:37:22  daveb
Removed exception environments.

Revision 1.26  1993/05/21  15:35:10  matthew
Fixed problem with copying COPYSTRs
/

Revision 1.25  1993/04/08  12:50:17  matthew
Simplified interface to *names_of* functions.
Added abstract_sigma function
/

Revision 1.24  1993/03/17  18:38:43  matthew
Nameset signature changes

Revision 1.23  1993/03/04  10:40:15  matthew
Options & Info changes

Revision 1.22  1993/02/19  13:47:17  matthew
Fiddling.

Revision 1.21  1993/02/17  15:37:17  jont
Used compose_maps from environment, and removed COPYSTR of COPYSTR problems

Revision 1.20  1993/02/09  12:07:02  matthew
Changes for BASISTYPES signature

Revision 1.19  1993/02/04  10:10:21  matthew
COPYSTR changes
Strip tynames and strnames before going in nameset

Revision 1.18  1992/12/02  16:19:18  jont
Error message improvements

Revision 1.17  1992/12/01  18:43:00  matthew
Changed Timer.time_it to Timer.xtime.  Added print_timings

Revision 1.16  1992/11/26  16:57:18  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.15  1992/10/30  16:11:19  jont
Added special maps for tyfun_id, tyname_id, strname_id

Revision 1.14  1992/10/23  13:15:37  clive
Some bug fixes from Anel

Revision 1.13  1992/09/08  13:06:45  jont
Removed has_a_new_name, no longer needed

Revision 1.12  1992/08/27  18:46:20  davidt
Made various changes so that structure copying can be
done more efficiently.

Revision 1.11  1992/08/11  18:06:16  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.10  1992/08/03  12:27:24  jont
Anel's changes to use NewMap instead of Map

Revision 1.9  1992/07/17  10:38:22  jont
Changed to use btrees for renaming of tynames and strnames

Revision 1.8  1992/06/30  10:27:54  jont
Changed to imperative implementation of namesets with hashing

Revision 1.1  1992/04/21  17:27:06  jont
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "../typechecker/strnames";
require "../typechecker/nameset";
require "../typechecker/types";
require "../typechecker/scheme";
require "../typechecker/environment";
require "../typechecker/basistypes";
require "stamp";

require "../typechecker/sigma";

functor Sigma (
  structure Strnames  : STRNAMES
  structure Nameset   : NAMESET
  structure Types     : TYPES
  structure Scheme    : TYPESCHEME
  structure Env       : ENVIRONMENT
  structure BasisTypes: BASISTYPES
  structure Stamp : STAMP

  sharing Nameset.Options = Types.Options = Scheme.Options
  sharing Nameset.Datatypes = Env.Datatypes 
    = Scheme.Datatypes = Strnames.Datatypes = Types.Datatypes
    = BasisTypes.Datatypes

  sharing type BasisTypes.Nameset = Nameset.Nameset
  sharing type Types.Datatypes.Stamp = Stamp.Stamp
  sharing type Types.Datatypes.StampMap = Stamp.Map.T

) : SIGMA =
struct
    structure BasisTypes = BasisTypes
    structure Options = Nameset.Options

    open BasisTypes.Datatypes

    (* new_names_of returns all flexible names in a structure *)

    exception GetTyname
    fun get_tyname (ETA_TYFUN name) = name
      | get_tyname _ = raise GetTyname

    fun tyname_strip(METATYNAME{1=ref(ETA_TYFUN tyname), ...}) = tyname_strip tyname
      | tyname_strip tyname = tyname

    fun new_names_of str =
      let
        fun str_names (STR (name,_,env),nameset) =
          let
            val newname = Strnames.strip name
          in
            if (Env.empty_envp env) then
              if (Strnames.uninstantiated newname) then
                Nameset.add_strname (newname,nameset)
              else nameset
            else
              if (Strnames.uninstantiated newname) then
                env_names (env,Nameset.add_strname (newname,nameset))
              else
                env_names (env,nameset)
          end

          (* here, the range of the copy maps define the free names of the structure *)
          (* this arm isn't called for fully expanded structures *)
          | str_names (COPYSTR((smap,tmap),str),nameset) =

            (* Now we just look at the ranges of the two maps *)
            (* These should contain all the free names in the substructure *)
            let
              fun do_strname (nameset,_,strname) =
                if Strnames.uninstantiated strname
                  then Nameset.add_strname (strname,nameset)
                else nameset
              fun do_tyname (nameset,_,TYNAME _) = nameset
                | do_tyname (nameset,_,tyname as (METATYNAME (ref tyfun,_,_,_,_,_))) =
                  if Types.null_tyfunp tyfun
                    then (Nameset.add_tyname (tyname,nameset))
                  else nameset
            in
              Stamp.Map.fold do_strname (Stamp.Map.fold do_tyname (nameset,tmap),smap)
            end
	   
        and env_names (ENV (SE se_map,TE te_map, VE (_, ve_map)),nameset) =
          let 
            fun gather_tynames (nameset, _, TYSTR (tyfun,VE (_,amap))) =
              let
                val nameset' = NewMap.fold gather_ve_tynames (nameset, amap)
              in
                if Types.null_tyfunp tyfun then
                  Nameset.add_tyname (tyname_strip (Types.name tyfun), nameset')
                else
                  nameset'
              end

            and gather_strnames (nameset, _, str) = str_names (str,nameset)

            and gather_ve_tynames (nameset, _, scheme) =
              Nameset.tynames_in_nameset(Scheme.gather_tynames(scheme), nameset)

            val new_nameset = NewMap.fold gather_tynames (nameset, te_map)
            val new_nameset' = NewMap.fold gather_strnames (new_nameset, se_map)
          in
            NewMap.fold gather_ve_tynames (new_nameset', ve_map)
          end
      in
        str_names (str,Nameset.empty_nameset())
      end

    (* names_of returns both flexible and rigid names of a structure. nameset is the accumulator *)

    local 
      fun str_names (STR (name,_,env),nameset) =
        if (Env.empty_envp env) then
          Nameset.add_strname (Strnames.strip name,nameset)
        else
          env_names (env,Nameset.add_strname (Strnames.strip name,nameset))
        | str_names (COPYSTR((smap,tmap),str),nameset) =
          str_names (Env.str_copy (str,smap,tmap),nameset)
	   
      and env_names (ENV (SE se_map,TE te_map,VE (_, ve_map)),nameset) =
        let
          fun gather_tynames(nameset, _, TYSTR (tyfun, _)) =
            if Types.has_a_name tyfun then
              Nameset.add_tyname (tyname_strip(Types.name tyfun), nameset)
            else
              nameset
	    
          fun gather_strnames (nameset, _, str) =
            str_names (str, nameset)

          fun gather_ve_tynames (nameset, _, scheme) = 
            Nameset.tynames_in_nameset (Scheme.gather_tynames (scheme), nameset)
          val new_nameset = NewMap.fold gather_tynames (nameset, te_map)
          val new_nameset' = NewMap.fold gather_strnames (new_nameset, se_map)
        in
          NewMap.fold gather_ve_tynames (new_nameset', ve_map)
        end
    in
      fun names_of str = str_names (str,Nameset.empty_nameset())
      fun names_of_env env = env_names (env,Nameset.empty_nameset())
    end

    fun string_sigma options (BasisTypes.SIGMA (nameset,str)) =
      "SIGMA (" ^ Nameset.string_nameset options nameset ^ "{\n" ^ (Env.string_str str) ^ "})\n"

    fun string_phi options (BasisTypes.PHI (nameset,(str,sigma))) =
      "PHI (" ^ Nameset.string_nameset options nameset ^ ")" ^ 
      "(" ^ Env.string_str str ^ "\n  =>\n  " ^ string_sigma options sigma ^ ")\n"


    (****
     A signature is copied before it is matched against a structure, because
     signature matching is done by side effecting.  To match one signature
     to several structures will therefore become impossible if the signature
     is not copied beforehand.
     ****)

    fun print_map (strname_copies) =
      let
        fun it f [] = () | it f (a::b) = (ignore(f a) ; it f b)
      in
        (print"Copies:\n";
         it
         (fn (id,name) => print(Stamp.string_stamp id ^ ":" ^ Strnames.string_strname name ^ "\n"))
         (Stamp.Map.to_list strname_copies))
      end

    (* This copies the bound tynames in the sigma and returns the relevant *)
    (* substitutions as well as the new sigma *)

    fun sig_copy_return (BasisTypes.SIGMA (nameset,str),expand,
                         strname_copies,tyname_copies,functorp) 
                         newTynameLevel = 
      let 
        val (nameset', strname_copies', tyname_copies') =
          Nameset.nameset_copy (nameset,strname_copies,tyname_copies)
                               newTynameLevel
        val str' = case str of
          COPYSTR(maps, str'') =>
            let
              val (smap,tmap) = Env.compose_maps(maps,(strname_copies',
                                                       tyname_copies'))

              (* If we are doing a functor body, need to add explicit 
                 maps for the functor parameter objects *)

              val (smap',tmap') =
                if functorp
                  then (Stamp.Map.union (strname_copies,smap),
                        Stamp.Map.union(tyname_copies,tmap))
                else (smap,tmap)
            in
              if expand then Env.str_copy (str'',smap',tmap')
              else COPYSTR((smap',tmap'),str'')
            end
        | _ =>
            if expand then Env.str_copy (str, strname_copies',tyname_copies')
            else COPYSTR((strname_copies',tyname_copies'),str)
      in
        (BasisTypes.SIGMA(nameset', str'), strname_copies', tyname_copies')
      end

    fun sig_copy (sigma,expand) newTynameLevel =
      let 
	val (sigma',_,_) =
	  sig_copy_return (sigma, expand,Stamp.Map.empty,
                           Stamp.Map.empty,false) newTynameLevel
      in
	sigma'
      end

    fun phi_copy (phi as BasisTypes.PHI (names,(str,sigma)),expand) 
                 newTynameLevel =
      let
(*
        val _ = output (std_out,"Phi copy:\n")
        val _ = output (std_out,string_phi Options.default_print_options phi)
*)
	val (BasisTypes.SIGMA (names',str'), strname_copies, tyname_copies) =
	  sig_copy_return (BasisTypes.SIGMA (names, str), expand,
                           Stamp.Map.empty, Stamp.Map.empty, false)
                          newTynameLevel

        val (sigma',strname_copies',tyname_copies') = 
          sig_copy_return (sigma, expand,strname_copies, tyname_copies, true)
                          newTynameLevel

        val phi' = BasisTypes.PHI (names', (str', sigma'))

(* DEBUGGING
        val _ = output (std_out,string_phi Options.default_print_options phi')
        val _ = output (std_out,"Phi copy end\n")
*)
      in
	phi'
      end

    (* This functions should copy the sigma with new rigid names 
       for the bound names *)

    fun abstract_sigma (BasisTypes.SIGMA (nameset,str)) newTynameLevel =
      let 
        val (new_nameset, strname_copies, tyname_copies) =
          Nameset.nameset_rigid_copy (nameset,Stamp.Map.empty,Stamp.Map.empty)
                                     newTynameLevel

        val new_str = case str of
          COPYSTR(maps, str) =>
            COPYSTR(Env.compose_maps(maps, (strname_copies, tyname_copies)),
                    str)
        | _ =>
            COPYSTR((strname_copies,tyname_copies),str)
      in
        BasisTypes.SIGMA (new_nameset, new_str)
      end
  end;
@


1.37.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.37  1998/02/19  16:47:35  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.36
log
@[Bug #30326]
Merge im change from branch MLWorks_workspace_97
@
text
@d4 4
d277 1
a277 1
        fun it f [] = () | it f (a::b) = (f a ; it f b)
@


1.35
log
@[Bug #30089]
Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
@
text
@d4 10
@


1.34
log
@[Bug #30090]
Translate output std_out to print
@
text
@d4 4
a104 1
require "../utils/timer";
a115 1
  structure Timer     : TIMER
a245 16
(*
    (* Remove these after testing *)

    val names_of =
      (fn x =>
       Timer.xtime ("names_of",
                    print_times,
                    fn () => names_of x))

    val names_of_env =
      (fn x =>
       Timer.xtime ("names_of_env",
                    print_times,
                    fn () => names_of_env x))
*)
      
@


1.34.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.34  1997/05/19  12:54:47  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.34.2.2
log
@[Bug #30326]
@
text
@a3 3
 * Revision 1.34.2.1  1997/09/11  21:10:02  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d105 1
a105 1
require "../utils/mlworks_timer";
@


1.34.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.34  1997/05/19  12:54:47  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.33
log
@[Bug #1592]
propagating level information for new type names.
@
text
@d4 4
d279 1
a279 1
        (MLWorks.IO.output(MLWorks.IO.std_out,"Copies:\n");
d281 1
a281 1
         (fn (id,name) => MLWorks.IO.output(MLWorks.IO.std_out,Stamp.string_stamp id ^ ":" ^ Strnames.string_strname name ^ "\n"))
@


1.33.6.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/10/02  14:08:43  andreww
 * [Bug #1592]
 * propagating level information for new type names.
 *
@


1.33.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.33.6.1  1997/05/12  10:51:48  hope
 * branched from 1.33
 *
@


1.33.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.33.6.1  1997/05/12  10:51:48  hope
 * branched from 1.33
 *
@


1.33.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.33.6.1  1997/05/12  10:51:48  hope
 * branched from 1.33
 *
@


1.33.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.33.6.1.1.1  1997/07/28  18:33:37  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.33.5.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/10/02  14:08:43  andreww
 * [Bug #1592]
 * propagating level information for new type names.
 *
@


1.33.4.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/10/02  14:08:43  andreww
 * [Bug #1592]
 * propagating level information for new type names.
 *
@


1.33.4.1.1.1
log
@branched from 1.33.4.1
@
text
@a3 3
 * Revision 1.33.4.1  1996/12/17  18:18:14  hope
 * branched from 1.33
 *
@


1.33.3.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/10/02  14:08:43  andreww
 * [Bug #1592]
 * propagating level information for new type names.
 *
@


1.33.2.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/10/02  14:08:43  andreww
 * [Bug #1592]
 * propagating level information for new type names.
 *
@


1.33.2.1.1.1
log
@branched from 1.33.2.1
@
text
@a3 3
 * Revision 1.33.2.1  1996/11/14  13:21:33  hope
 * branched from 1.33
 *
@


1.33.1.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/10/02  14:08:43  andreww
 * [Bug #1592]
 * propagating level information for new type names.
 *
@


1.32
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d284 3
a286 1
    fun sig_copy_return (BasisTypes.SIGMA (nameset,str),expand,strname_copies,tyname_copies,functorp) = 
d290 1
d294 6
a299 2
              val (smap,tmap) = Env.compose_maps(maps,(strname_copies',tyname_copies'))
              (* If we are doing a functor body, need to add explicit maps for the functor parameter objects *)
d302 2
a303 1
                  then (Stamp.Map.union (strname_copies,smap),Stamp.Map.union(tyname_copies,tmap))
d316 1
a316 1
    fun sig_copy (sigma,expand) =
d319 2
a320 1
	  sig_copy_return (sigma, expand,Stamp.Map.empty, Stamp.Map.empty,false)
d325 2
a326 1
    fun phi_copy (phi as BasisTypes.PHI (names,(str,sigma)),expand) =
d333 8
a340 2
	  sig_copy_return (BasisTypes.SIGMA (names, str), expand,Stamp.Map.empty, Stamp.Map.empty, false)
        val (sigma',strname_copies',tyname_copies') = sig_copy_return (sigma, expand,strname_copies, tyname_copies, true)
d342 2
a343 1
(*
d351 4
a354 2
    (* This functions should copy the sigma with new rigid names for the bound names *)
    fun abstract_sigma (BasisTypes.SIGMA (nameset,str)) =
d358 2
d362 2
a363 1
            COPYSTR(Env.compose_maps(maps, (strname_copies, tyname_copies)), str)
@


1.32.2.1
log
@branched from 1.32
@
text
@a3 6
 * Revision 1.32  1996/04/30  15:32:01  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.32.1.1
log
@branched from 1.32
@
text
@a3 6
 * Revision 1.32  1996/04/30  15:32:01  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.31
log
@Fix for rigid tynames in functor result problem
Use Stamp instead of Tyname_id etc.
\nImprovements to copying signatures
@
text
@d4 5
d269 1
a269 1
        (output(std_out,"Copies:\n");
d271 1
a271 1
         (fn (id,name) => output(std_out,Stamp.string_stamp id ^ ":" ^ Strnames.string_strname name ^ "\n"))
@


1.30
log
@Removing debug stuff
@
text
@d4 3
d93 2
d105 1
d113 2
d166 1
a166 1
              Strname_id.Map.fold do_strname (Tyfun_id.Map.fold do_tyname (nameset,tmap),smap)
d246 1
a246 1
      "SIGMA(" ^ (Nameset.string_nameset options nameset) ^ ")\n{\n" ^ (Env.string_str str) ^ "}\n"
d249 2
a250 2
      "(" ^ Nameset.string_nameset options nameset ^ ")" ^ 
      "(" ^ Env.string_str str ^ "," ^ string_sigma options sigma ^ ")"
d266 2
a267 2
         (fn (id,name) => output(std_out,Strname_id.string_strname_id id ^ ":" ^ Strnames.string_strname name ^ "\n"))
         (Strname_id.Map.to_list strname_copies))
d269 5
a273 2
       
    fun sig_copy_return (BasisTypes.SIGMA (nameset,str),strname_copies,tyname_copies) = 
a278 4
(*
            COPYSTR ((strname_copies',tyname_copies'),
                     Env.expand_str str)
*)
d281 5
a285 10
(*
              val _ = output(std_out,"\nSigCopyReturn\n")
              val _ = print_map strname_copies'
              val _ = print_map smap
*)
              val newsmap = Strname_id.Map.union (strname_copies',smap)
              val newtmap = Tyfun_id.Map.union(tyname_copies',tmap)
(*
              val _ = print_map newsmap
*)
d287 2
a288 1
              COPYSTR((newsmap,newtmap),str'')
d291 2
a292 1
            COPYSTR((strname_copies',tyname_copies'),str)
d297 1
a297 1
    fun sig_copy sigma =
d300 1
a300 2
	  sig_copy_return
	  (sigma, Strname_id.Map.empty, Tyfun_id.Map.empty)
d305 1
a305 1
    fun phi_copy (phi as BasisTypes.PHI (names,(str,sigma))) =
d307 4
d312 2
a313 6
	  sig_copy_return
	  (BasisTypes.SIGMA (names, str),
           Strname_id.Map.empty,
	   Tyfun_id.Map.empty)
        val (sigma',strname_copies',tyname_copies') =
          sig_copy_return (sigma, strname_copies, tyname_copies)
d315 4
d327 1
a327 1
          Nameset.nameset_rigid_copy (nameset,Strname_id.Map.empty,Tyfun_id.Map.empty)
@


1.29
log
@Commented calls to xtime
@
text
@d4 3
a82 1
require "../utils/print";
a83 1
require "../typechecker/ty_debug";
a92 1
  structure Print     : PRINT
a93 1
  structure Ty_Debug  : TY_DEBUG
d100 1
a100 5
  structure Debug :
    sig
      val set_debug_level : int -> unit
      val debug_level : unit -> int
    end
a112 4
    val do_debug = Ty_Debug.do_debug

    val print_times = ref false

d227 1
a227 1
                    !print_times,
d233 1
a233 1
                    !print_times,
d240 5
d300 14
@


1.28
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d230 1
d235 1
a235 1
       Timer.xtime ("Time for names_of",
d241 1
a241 1
       Timer.xtime ("Time for names_of_env",
d244 1
@


1.27
log
@Removed exception environments.
@
text
@d4 3
d159 1
a159 1
                | do_tyname (nameset,_,tyname as (METATYNAME (ref tyfun,_,_,_,_))) =
@


1.27.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.27  1993/06/30  15:37:22  daveb
Removed exception environments.

@


1.26
log
@Fixed problem with copying COPYSTRs
/
@
text
@d4 4
d164 1
a164 1
        and env_names (ENV (SE se_map,TE te_map, VE (_, ve_map),_),nameset) =
d201 1
a201 1
      and env_names (ENV (SE se_map,TE te_map,VE (_, ve_map),_),nameset) =
@


1.25
log
@Simplified interface to *names_of* functions.
Added abstract_sigma function
/
@
text
@d4 5
d235 1
a235 1
      "(" ^ (Nameset.string_nameset options nameset) ^ ")\n" ^ (Env.string_str str)
d244 12
d261 20
a280 2
          COPYSTR(maps, str) =>
            COPYSTR(Env.compose_maps(maps, (strname_copies', tyname_copies')), str)
@


1.24
log
@Nameset signature changes
@
text
@d4 3
d118 27
a144 33
    fun new_names_of (STR (name,_,env),nameset) = 
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("Sigma.new_names_of " ^ 
		       Strnames.string_strname name);
	  Print.print ("\n"))
       else ();
         let val newname = Strnames.strip name
         in
           if (Env.empty_envp env) then
             if (Strnames.uninstantiated newname) then
               Nameset.add_strname (newname,nameset)
             else nameset
           else
             if (Strnames.uninstantiated newname) then
               new_names_of_env (env,Nameset.add_strname (newname,nameset))
             else
               new_names_of_env (env,nameset)
         end)

      (* here, the range of the copy maps define the free names of the structure *)
      (* this arm isn't called for fully expanded structures *)
      | new_names_of (COPYSTR((smap,tmap),str),nameset) =

        (* Now we just look at the ranges of the two maps *)
        (* These should contain all the free names in the substructure *)
        let fun do_strname (nameset,_,strname) =
          if Strnames.uninstantiated strname
            then Nameset.add_strname (strname,nameset)
          else nameset
            fun do_tyname (nameset,_,TYNAME _) = nameset
              | do_tyname (nameset,_,tyname as (METATYNAME (ref tyfun,_,_,_,_))) =
                if Types.null_tyfunp tyfun
                  then (Nameset.add_tyname (tyname,nameset))
d146 8
a153 3
        in
          Strname_id.Map.fold do_strname (Tyfun_id.Map.fold do_tyname (nameset,tmap),smap)
        end
d155 22
a176 24
    and new_names_of_env (ENV (SE se_map,TE te_map, VE (_, ve_map),_),nameset) =
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("Sigma.gather_names");
	  Print.print ("\n"))
       else ();
      let 
	fun gather_tynames (nameset, _, TYSTR (tyfun,VE (_,amap))) =
	  let
	    val nameset' = NewMap.fold gather_ve_tynames (nameset, amap)
	  in
	    if Types.null_tyfunp tyfun then
	      Nameset.add_tyname (tyname_strip (Types.name tyfun), nameset')
	    else
	      nameset'
	  end

	and gather_strnames (nameset, _, str) =
	  new_names_of (str,nameset)

	and gather_ve_tynames (nameset, _, scheme) =
	  Nameset.tynames_in_nameset(Scheme.gather_tynames(scheme), nameset)

	val new_nameset = NewMap.fold gather_tynames (nameset, te_map)
	val new_nameset' = NewMap.fold gather_strnames (new_nameset, se_map)
d178 2
a179 2
	NewMap.fold gather_ve_tynames (new_nameset', ve_map)
      end)
d183 8
a190 11
    fun names_of (STR (name,_,env),nameset) = 
      (if do_debug andalso Debug.debug_level ()> 10 then 
	 (Print.print ("Sigma.names_of");
	  Print.print ("\n"))
       else ();
	 if (Env.empty_envp env) then
	   Nameset.add_strname (Strnames.strip name,nameset)
	 else
	   names_of_env (env,Nameset.add_strname (Strnames.strip name,nameset)))
      | names_of (COPYSTR((smap,tmap),str),nameset) =
        names_of (Env.str_copy (str,smap,tmap),nameset)
d192 7
a198 11
    and names_of_env (ENV (SE se_map,TE te_map,VE (_, ve_map),_),nameset) =
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("Sigma.gather_old_names");
	  Print.print ("\n"))
       else ();
      let 
	fun gather_tynames(nameset, _, TYSTR (tyfun, _)) =
	  if Types.has_a_name tyfun then
	    Nameset.add_tyname (tyname_strip(Types.name tyfun), nameset)
	  else
	    nameset
d200 2
a201 2
	fun gather_strnames (nameset, _, str) =
	  names_of (str, nameset)
d203 11
a213 7
	fun gather_ve_tynames (nameset, _, scheme) = 
	  Nameset.tynames_in_nameset (Scheme.gather_tynames (scheme), nameset)
	val new_nameset = NewMap.fold gather_tynames (nameset, te_map)
	val new_nameset' = NewMap.fold gather_strnames (new_nameset, se_map)
      in
	NewMap.fold gather_ve_tynames (new_nameset', ve_map)
      end)
d240 11
a250 15
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print "sig_copy_return";
	  Print.print ("\n"))
       else ();
       let 
	 val (nameset', strname_copies', tyname_copies') =
	   Nameset.nameset_copy (nameset,strname_copies,tyname_copies)
	 val str' = case str of
	   COPYSTR(maps, str) =>
	     COPYSTR(Env.compose_maps(maps, (strname_copies', tyname_copies')), str)
	 | _ =>
	     COPYSTR((strname_copies',tyname_copies'),str)
       in
	 (BasisTypes.SIGMA(nameset', str'), strname_copies', tyname_copies')
       end)
d259 14
@


1.23
log
@Options & Info changes
@
text
@d4 3
d70 1
d82 1
d89 1
a89 1
  sharing Nameset.BasisTypes.Datatypes = Env.Datatypes 
d91 3
d97 1
a97 1
    structure BasisTypes = Nameset.BasisTypes
@


1.22
log
@Fiddling.
@
text
@d4 3
d83 1
d90 2
a91 1
    structure Info = BasisTypes.Info
@


1.21
log
@Used compose_maps from environment, and removed COPYSTR of COPYSTR problems
@
text
@d4 3
d93 1
a93 4
    (****
     new_names_of returns all flexible names in a structure.  nameset
     is the accumulator.
     ****)
a115 3
(*
               Nameset.add_strname (newname,new_names_of_env (env,nameset))
*)
d122 1
a122 1
      (* but I don't think this arm gets called *)
a124 2
(*        new_names_of (Env.str_copy (str,smap,tmap),nameset) *)

d168 1
a168 4
    (****
     names_of returns both flexible and rigid names of a structure. 
     nameset is the accumulator.
     ****)
@


1.20
log
@Changes for BASISTYPES signature
@
text
@d4 3
d245 5
a249 2
	 val str' =
           COPYSTR ((strname_copies',tyname_copies'),str)
@


1.19
log
@COPYSTR changes
Strip tynames and strnames before going in nameset
@
text
@d4 4
d74 1
a74 1
  sharing Nameset.Datatypes = Env.Datatypes 
d79 2
a80 2
    structure Nameset = Nameset
    structure Info = Nameset.Info
d83 1
a83 8
    val print_timings = ref false

    open Nameset.Datatypes

    (****
     Datatype declaration for the compound semantic object Sig and 
     the operations on it.
     ***)
d85 1
a85 1
    datatype Sigma = SIGMA of (Nameset.Nameset * Str)
d124 17
a140 1
        new_names_of (Env.str_copy (str,smap,tmap),nameset)
d209 16
a224 2
	
    fun string_sigma options (SIGMA (nameset,str)) =
d234 1
a234 1
    fun sig_copy_return (SIGMA (nameset,str),strname_copies,tyname_copies) = 
d245 1
a245 1
	 (SIGMA(nameset', str'), strname_copies', tyname_copies')
@


1.18
log
@Error message improvements
@
text
@d4 3
d92 1
a92 1
     is the accumalator.
d95 8
a102 1
    fun new_names_of (STR (name,env),nameset) = 
d108 20
a127 9
	 if (Env.empty_envp env) then
	   if (Strnames.uninstantiated name) then
	     Nameset.add_strname (name,nameset)
	   else nameset
	 else
	   if (Strnames.uninstantiated name) then
	     Nameset.add_strname (name,new_names_of_env (env,nameset))
	   else
	     new_names_of_env (env,nameset))
d140 1
a140 1
	      Nameset.add_tyname (Types.name tyfun, nameset')
d162 1
a162 1
    fun names_of (STR (name,env),nameset) = 
d168 1
a168 1
	   Nameset.add_strname (name,nameset)
d170 3
a172 1
	   Nameset.add_strname (name,names_of_env (env,nameset)))
d182 1
a182 1
	    Nameset.add_tyname (Types.name tyfun, nameset)
d216 1
a216 1
	   Env.str_copy (str,strname_copies',tyname_copies')
@


1.17
log
@Changed Timer.time_it to Timer.xtime.  Added print_timings
@
text
@d4 3
d191 1
a191 1
	   Timer.xtime ("nameset_copy", !print_timings, fn () => Nameset.nameset_copy(nameset,strname_copies,tyname_copies))
d193 1
a193 1
	   Timer.xtime ("str_copy", !print_timings, fn () => Env.str_copy (str,strname_copies',tyname_copies'))
@


1.16
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d73 2
d188 1
a188 1
	   Timer.time_it ("nameset_copy", fn () => Nameset.nameset_copy(nameset,strname_copies,tyname_copies))
d190 1
a190 1
	   Timer.time_it ("str_copy", fn () => Env.str_copy (str,strname_copies',tyname_copies'))
@


1.15
log
@Added special maps for tyfun_id, tyname_id, strname_id
@
text
@d4 3
d61 4
a64 3
    = Scheme.Datatypes = Strnames.Datatypes = Types.Datatypes)
  : SIGMA =
  struct
d66 1
a66 1

d165 2
a166 2
    fun string_sigma (SIGMA (nameset,str)) =
      "(" ^ (Nameset.string_nameset nameset) ^ ")\n" ^ (Env.string_str str)
@


1.14
log
@Some bug fixes from Anel
@
text
@d4 3
d189 1
a189 2
	  (sigma, NewMap.empty' Strname_id.strname_id_lt,
	   NewMap.empty' Tyfun_id.tyfun_id_lt)
@


1.13
log
@Removed has_a_new_name, no longer needed
@
text
@d4 3
d142 1
a142 1
	  if Types.null_tyfunp tyfun then
@


1.12
log
@Made various changes so that structure copying can be
done more efficiently.
@
text
@d4 4
d99 1
a99 1
	    if Types.has_a_new_name tyfun then
d139 1
a139 1
	  if Types.has_a_name tyfun then
@


1.11
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d85 1
a85 2
    and new_names_of_env (ENV (SE amap',TE amap,
			       VE (_,amap''),_),nameset) =
d107 2
a108 3
	val new_nameset = NewMap.fold gather_tynames (nameset, amap)
	val new_nameset' = NewMap.fold gather_strnames (new_nameset, amap')

d110 1
a110 1
	NewMap.fold gather_ve_tynames (new_nameset', amap'')
d128 1
a128 2
    and names_of_env (ENV (SE amap',TE amap,
			       VE (_,amap''),_),nameset) =
d134 3
a136 8
(*
	val str_list = NewMap.range amap'
	val tystr_list = NewMap.range amap
	val scheme_list = NewMap.range amap''
*)
	fun gather_tynames(nameset, _, TYSTR (tyfun,_)) =
	  if Types.has_a_name (tyfun) then
	    Nameset.add_tyname (Types.name (tyfun),nameset)
d139 1
a139 1

d141 1
a141 1
	  names_of (str,nameset)
d145 2
a146 2
	val new_nameset = NewMap.fold gather_tynames (nameset, amap)
	val new_nameset' = NewMap.fold gather_strnames (new_nameset, amap')
d148 1
a148 1
	NewMap.fold gather_ve_tynames (new_nameset', amap'')
d167 4
a170 15
	 val (nameset',strname_copies',tyname_copies') =
	   Timer.time_it
	   ("nameset_copy",
	    fn () => Nameset.nameset_copy(nameset,strname_copies,tyname_copies))
	 val (str',strname_copies'',tyname_copies'') =
(**)
	   Timer.time_it ("str_copy", fn () => Env.str_copy (str,strname_copies',tyname_copies',
			 Strnames.copy_metastrname,Types.copy_metatyname))
(**)
(*
	   Timer.time_it
	   ("str_copy_for_sigma",
	    fn () => Env.str_copy_for_sigma(str,strname_copies',tyname_copies')
	    )
*)
d172 1
a172 1
	 (SIGMA(nameset',str'), strname_copies'', tyname_copies'')
a174 3
    fun tyfun_lt (id, id') =
      Tyfun_id.tyfun_id id < Tyfun_id.tyfun_id id'

d178 3
a180 3
	  sig_copy_return (sigma,
			   NewMap.empty' Strname_id.strname_id_lt,
			   NewMap.empty' tyfun_lt)
@


1.10
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
a18 1
require "../utils/newmap";
a23 1
require "../typechecker/datatypes";
a29 1
  structure NewMap    : NEWMAP
a34 1
  structure Datatypes : DATATYPES
d43 1
a43 2
  sharing NewMap = Env.NewMap = Nameset.NewMap = Datatypes.NewMap
  sharing Datatypes = Nameset.Datatypes = Env.Datatypes 
a46 2

    structure Datatypes = Datatypes
d51 1
a51 1
    open Datatypes
d88 19
a106 41
	val str_list = NewMap.range amap'
	val tystr_list = NewMap.range amap
	val scheme_list = NewMap.range amap''
	fun gather_tynames ([],nameset) = nameset
	  | gather_tynames ((TYSTR (tyfun,VE (_,amap)))::tystrs,
			    nameset) = 
	    let
	      val schemelist = NewMap.range amap
	      val nameset' = gather_ve_tynames (schemelist,nameset)
	    in
		if Types.has_a_new_name (tyfun) 
		    then
			let val nameset'' = 
			    Nameset.add_tyname (Types.name (tyfun),nameset')
			in
			    gather_tynames (tystrs,nameset'')
			end
		else
		    gather_tynames (tystrs,nameset')
	    end
	and gather_strnames ([],nameset) = nameset
	  | gather_strnames (str::strs,nameset) =
	    let
(*
	      val nameset' = Nameset.union (nameset,new_names_of (str,nameset))
*)
	      val nameset' = new_names_of (str,nameset)
	    in
	      gather_strnames (strs,nameset')
	    end
	and gather_ve_tynames ([],nameset) = nameset
	  | gather_ve_tynames (scheme::schemes,nameset) = 
	    let
	      val nameset' =
		Nameset.tynames_in_nameset (Scheme.gather_tynames (scheme),
					    nameset)
	    in
	      gather_ve_tynames (schemes,nameset')
	    end
	val new_nameset = gather_tynames (tystr_list,nameset)
	val new_nameset' = gather_strnames (str_list,new_nameset)
d108 1
a108 1
	gather_ve_tynames (scheme_list,new_nameset')
d133 1
d137 14
a150 31
	fun gather_tynames ([],nameset) = nameset
	  | gather_tynames ((TYSTR (tyfun,_))::tystrs,
			    nameset) = 
	    if Types.has_a_name (tyfun) 
	      then
		let 
		  val nameset' = 
		    Nameset.add_tyname (Types.name (tyfun),nameset)
		in
		  gather_tynames (tystrs,nameset')
		end
	    else
	      gather_tynames (tystrs,nameset)
	fun gather_strnames ([],nameset) = nameset
	  | gather_strnames (str::strs,nameset) =
	    let 
	      val nameset' = names_of (str,nameset)
	    in
	      gather_strnames (strs,nameset')
	    end
	fun gather_ve_tynames ([],nameset) = nameset
	  | gather_ve_tynames (scheme::schemes,nameset) = 
	    let
	      val nameset' = 
		Nameset.tynames_in_nameset (Scheme.gather_tynames (scheme),
					    nameset)
	    in
	      gather_ve_tynames (schemes,nameset')
	    end
	val new_nameset = gather_tynames (tystr_list,nameset)
	val new_nameset' = gather_strnames (str_list,new_nameset)
d152 1
a152 1
	gather_ve_tynames (scheme_list,new_nameset')
d197 2
a198 2
			   Nameset.NewMap.empty' Strname_id.strname_id_lt,
			   Nameset.NewMap.empty' tyfun_lt)
@


1.9
log
@Changed to use btrees for renaming of tynames and strnames
@
text
@d4 3
d16 1
d20 2
a22 2
require "../typechecker/sigma";
require "../typechecker/strnames";
d24 1
a24 1
require "../typechecker/nameset";
d26 1
a26 1
require "../typechecker/scheme";
d28 7
a34 4
functor Sigma(
  structure Print : PRINT
  structure Timer : TIMER
  structure Ty_Debug : TY_DEBUG
d36 3
a38 5
  structure Strnames : STRNAMES
  structure Types : TYPES
  structure Nameset : NAMESET
  structure Env : ENVIRONMENT
  structure Scheme : TYPESCHEME
d44 1
a44 1
  sharing Env.NewMap = Nameset.NewMap
d54 1
d92 3
a94 3
	val str_list = Mapping.range amap'
	val tystr_list = Mapping.range amap
	val scheme_list = Mapping.range amap''
d99 1
a99 1
	      val schemelist = Mapping.range amap
d159 3
a161 3
	val str_list = Mapping.range amap'
	val tystr_list = Mapping.range amap
	val scheme_list = Mapping.range amap''
d238 3
a240 3
	  sig_copy_return(sigma,
			  Nameset.NewMap.empty' Strname_id.strname_id_lt,
			  Nameset.NewMap.empty' tyfun_lt)
@


1.8
log
@Changed to imperative implementation of namesets with hashing
@
text
@d4 3
d39 1
d207 4
a210 2
	 val (nameset',strname_copies',tyname_copies') = 
	   Timer.time_it ("nameset_copy",fn () => Nameset.nameset_copy (nameset,strname_copies,tyname_copies))
d212 1
d215 7
d223 1
a223 1
	 (SIGMA (nameset',str'),strname_copies'',tyname_copies'')
d226 4
a229 1
    fun sig_copy sigma = 
d231 4
a234 1
	val (sigma',_,_) = sig_copy_return (sigma,[],[])
@


1.7
log
@Anel's fixes
@
text
@d4 1
a4 18
Revision 1.6  1992/04/22  20:16:01  jont
Removed two unnecessary instances of Nameset.union

Revision 1.5  1992/01/27  20:15:27  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.4  1992/01/22  15:19:10  jont
Fixed a single character typo in sig_copy

Revision 1.3  1991/11/21  16:47:31  jont
Added copyright message

Revision 1.2  91/06/17  17:15:00  nickh
Modified to take new ValEnv definition with ref unit to allow
reading and writing circular data structures

Revision 1.1  91/06/07  11:38:20  colin
d7 1
a7 1
Copyright (c) 1991 Harlequin Ltd.
d22 1
a23 1
  structure Print : PRINT
d105 3
d186 1
a186 1

a217 1
	
@


1.6
log
@Removed two unnecessary instances of Nameset.union
@
text
@d4 3
d28 1
d39 1
d218 1
a218 1
	   Nameset.nameset_copy (nameset,strname_copies,tyname_copies)
d220 2
a221 2
	   Env.str_copy (str,strname_copies',tyname_copies',
			 Strnames.copy_metastrname,Types.copy_metatyname)
@


1.5
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d117 1
a117 1
	      val nameset' = Nameset.union (nameset,new_names_of (str,nameset))
d177 1
a177 1
	      val nameset' = Nameset.union (nameset,names_of (str,nameset))
@


1.4
log
@Fixed a single character typo in sig_copy
@
text
@d4 3
d19 4
a23 1
require "../typechecker/datatypes";
a28 1
require "../utils/print";
d30 16
a45 12
functor Sigma (structure Datatypes : DATATYPES
	       structure Strnames : STRNAMES
	       structure Types : TYPES
	       structure Nameset : NAMESET
	       structure Env : ENVIRONMENT
	       structure Scheme : TYPESCHEME
	       structure Debug :  sig val set_debug_level : int -> unit
				      val debug_level : unit -> int
				  end
	       structure Print : PRINT
		 sharing Datatypes = Nameset.Datatypes = Env.Datatypes 
		   = Scheme.Datatypes = Strnames.Datatypes = Types.Datatypes)
d52 1
d68 1
a68 1
      (if Debug.debug_level () > 10 then 
d85 1
a85 1
      (if Debug.debug_level () > 10 then 
d138 1
a138 1
      (if Debug.debug_level ()> 10 then 
d149 1
a149 1
      (if Debug.debug_level () > 10 then 
d203 1
a203 1
      (if Debug.debug_level () > 10 then 
@


1.3
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_sigma.sml,v $
d211 1
a211 1
	sigma
a214 6
  





@


1.2
log
@Modified to take new ValEnv definition with ref unit to allow
reading and writing circular data structures
@
text
@d1 1
d4 4
d11 1
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d65 1
a65 1
			       VE amap'',_),nameset) =
d75 1
a75 1
	  | gather_tynames ((TYSTR (tyfun,VE amap))::tystrs,
d129 1
a129 1
			       VE amap'',_),nameset) =
@
