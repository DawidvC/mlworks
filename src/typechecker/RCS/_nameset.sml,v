head	1.36;
access;
symbols
	MLW_daveb_inline_1_4_99:1.36.1
	MLWorks_21c0_1999_03_25:1.36
	MLWorks_20c1_1998_08_20:1.35
	MLWorks_20c0_1998_08_04:1.35
	MLWorks_20b2c2_1998_06_19:1.35
	MLWorks_20b2_Windows_1998_06_12:1.35
	MLWorks_20b1c1_1998_05_07:1.35
	MLWorks_20b0_1998_04_07:1.35
	MLWorks_20b0_1998_03_20:1.35
	MLWorks_20m2_1998_02_16:1.35
	MLWorks_20m1_1997_10_23:1.35
	MLWorks_11r1:1.34.6.1.1.1.1
	MLWorks_workspace_97:1.35.2
	MLWorks_dt_wizard:1.35.1
	MLWorks_11c0_1997_09_09:1.34.6.1.1.1
	MLWorks_10r3:1.34.6.1.3
	MLWorks_10r2_551:1.34.6.1.2
	MLWorks_11:1.34.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.34.6.1
	MLWorks_20m0_1997_06_20:1.35
	MLWorks_1_0_r2c2_1997_06_14:1.34.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.34.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.34.6
	MLWorks_BugFix_1997_04_24:1.34
	MLWorks_1_0_r2_Win32_1997_04_11:1.34
	MLWorks_1_0_r2_Unix_1997_04_04:1.34
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.34.4.1.1
	MLWorks_gui_1996_12_18:1.34.5
	MLWorks_1_0_Win32_1996_12_17:1.34.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.34.2.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.34.2.1
	MLWorks_1_0_Irix_1996_11_28:1.34.2.1.1
	MLWorks_1_0_Win32_1996_11_22:1.34.3
	MLWorks_1_0_Unix_1996_11_14:1.34.2
	MLWorks_Open_Beta2_1996_10_11:1.34.1
	MLWorks_License_dev:1.33.2
	MLWorks_1_open_beta_1996_09_13:1.33.1
	MLWorks_Open_Beta_1996_08_22:1.33
	MLWorks_Beta_1996_07_02:1.33
	MLWorks_Beta_1996_06_07:1.33
	MLWorks_Beta_1996_06_06:1.33
	MLWorks_Beta_1996_06_05:1.33
	MLWorks_Beta_1996_06_03:1.33
	MLWorks_Beta_1996_05_31:1.33
	MLWorks_Beta_1996_05_30:1.33
	ML_beta_release_12/08/94:1.29
	ML_beta_release_03/08/94:1.29
	ML_revised_beta_release_25/05/94:1.29
	ML_final_beta_release_02/03/94:1.29
	mlworks-28-01-1994:1.28
	Release:1.25
	mlworks-beta-01-09-1993:1.25
	MLWorks-1-0-4-29/01/1993:1.17
	MLWorks-1-0-3-21/12/1992:1.17
	MLWorks-1-0-2-15/12/1992:1.17
	MLWorks-1-0-1-04/12/1992:1.17
	checkpoint_17_08_92:1.9
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.36
date	99.02.02.16.01.47;	author mitchell;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	97.05.01.13.20.01;	author jont;	state Exp;
branches
	1.35.1.1
	1.35.2.1;
next	1.34;

1.34
date	96.10.02.13.48.48;	author andreww;	state Exp;
branches
	1.34.1.1
	1.34.2.1
	1.34.3.1
	1.34.4.1
	1.34.5.1
	1.34.6.1;
next	1.33;

1.33
date	96.02.22.11.59.48;	author jont;	state Exp;
branches
	1.33.1.1
	1.33.2.1;
next	1.32;

1.32
date	95.08.10.14.46.47;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	95.03.28.16.20.19;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	95.02.02.13.46.00;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	94.02.28.06.08.05;	author nosa;	state Exp;
branches;
next	1.28;

1.28
date	94.01.05.12.09.13;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.11.30.11.27.54;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.09.23.12.55.14;	author nosa;	state Exp;
branches;
next	1.25;

1.25
date	93.07.30.11.29.49;	author nosa;	state Exp;
branches
	1.25.1.1;
next	1.24;

1.24
date	93.05.21.15.59.41;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.05.20.12.55.39;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	93.04.08.11.43.39;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.03.17.18.31.49;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.03.04.10.32.59;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.02.26.11.48.46;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	93.02.08.17.38.20;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	92.12.01.18.51.54;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.11.25.20.27.38;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	92.10.30.16.03.57;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.10.23.13.19.51;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.09.16.12.27.47;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.09.08.17.05.13;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.09.01.16.31.39;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.08.27.18.38.22;	author davidt;	state Exp;
branches;
next	1.9;

1.9
date	92.08.11.17.42.42;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.04.19.51.39;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	92.07.17.10.17.37;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.07.04.17.15.54;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.06.30.10.28.33;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.02.11.10.07.17;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.01.27.20.14.13;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.21.16.46.12;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.36.46;	author colin;	state Exp;
branches;
next	;

1.25.1.1
date	93.07.30.11.29.49;	author jont;	state Exp;
branches;
next	;

1.33.1.1
date	96.09.13.11.42.25;	author hope;	state Exp;
branches;
next	;

1.33.2.1
date	96.10.07.16.35.31;	author hope;	state Exp;
branches;
next	;

1.34.1.1
date	96.10.17.11.54.37;	author hope;	state Exp;
branches;
next	;

1.34.2.1
date	96.11.14.13.22.53;	author hope;	state Exp;
branches
	1.34.2.1.1.1;
next	;

1.34.2.1.1.1
date	96.11.28.15.33.23;	author hope;	state Exp;
branches;
next	;

1.34.3.1
date	96.11.22.18.39.58;	author hope;	state Exp;
branches;
next	;

1.34.4.1
date	96.12.17.18.19.00;	author hope;	state Exp;
branches
	1.34.4.1.1.1;
next	;

1.34.4.1.1.1
date	97.02.24.12.13.17;	author hope;	state Exp;
branches;
next	;

1.34.5.1
date	96.12.18.10.14.20;	author hope;	state Exp;
branches;
next	;

1.34.6.1
date	97.05.12.10.52.32;	author hope;	state Exp;
branches
	1.34.6.1.1.1
	1.34.6.1.2.1
	1.34.6.1.3.1;
next	;

1.34.6.1.1.1
date	97.07.28.18.34.22;	author daveb;	state Exp;
branches
	1.34.6.1.1.1.1.1;
next	;

1.34.6.1.1.1.1.1
date	97.10.07.12.00.19;	author jkbrook;	state Exp;
branches;
next	;

1.34.6.1.2.1
date	97.09.08.17.27.23;	author daveb;	state Exp;
branches;
next	;

1.34.6.1.3.1
date	97.09.09.14.24.20;	author daveb;	state Exp;
branches;
next	;

1.35.1.1
date	97.09.10.19.43.15;	author brucem;	state Exp;
branches;
next	;

1.35.2.1
date	97.09.11.21.10.43;	author daveb;	state Exp;
branches;
next	;

1.36.1.1
date	99.04.01.18.09.03;	author daveb;	state Exp;
branches;
next	;


desc
@NameSet (bound type and structure names in modules)
@


1.36
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _nameset.sml the functor *)
(*
$Log: _nameset.sml,v $
 * Revision 1.35  1997/05/01  13:20:01  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.34  1996/10/02  13:48:48  andreww
 * [Bug #1592]
 * Adding "char" type name to initial_nameset.
 *
 * Revision 1.33  1996/02/22  11:59:48  jont
 * Replacing Map with NewMap
 *
 * Revision 1.32  1995/08/10  14:46:47  daveb
 * Added types for different lengths of words, ints and reals.
 *
Revision 1.31  1995/03/28  16:20:19  matthew
Fix for rigid tynames in functor result problem

Revision 1.30  1995/02/02  13:46:00  matthew
Removing debug stuff

Revision 1.29  1994/02/28  06:08:05  nosa
Extra TYNAME valenv for Modules Debugger.

Revision 1.28  1994/01/05  12:09:13  matthew
Added --
remove_strname -- delete a strname from a nameset
simple_copy -- make a duplicate nameset

Revision 1.27  1993/11/30  11:27:54  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.26  1993/09/23  12:55:14  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.25  1993/07/30  11:29:49  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.

Revision 1.24  1993/05/21  15:59:41  matthew
Handle Tyfun_id.Map.Undefined

Revision 1.23  1993/05/20  12:55:39  jont
Added nameset_rehash to deal with the effects of sharing and realisation

Revision 1.22  1993/04/08  11:43:39  matthew
Removed duplication between copying functions
Added nameset_rigid_copy for use in abstraction semantics

Revision 1.21  1993/03/17  18:31:49  matthew
Added NamesetTypes structure
/

Revision 1.20  1993/03/04  10:32:59  matthew
Options & Info changes

Revision 1.19  1993/02/26  11:48:46  jont
Modified to use the new hashset with variable size tables

Revision 1.18  1993/02/08  17:38:20  matthew
Changes for BASISTYPES signature

Revision 1.17  1992/12/01  18:51:54  jont
Modified to use new improved hashset signature

Revision 1.16  1992/11/25  20:27:38  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.15  1992/10/30  16:03:57  jont
Added special maps for tyfun_id, tyname_id, strname_id

Revision 1.14  1992/10/23  13:19:51  clive
Some bug fixes from Anel

Revision 1.13  1992/09/16  12:27:47  jont
Removed yet another silly handler

Revision 1.12  1992/09/08  17:05:13  jont
Added updating of valenvs within metatynames when copying, to assist
the interpreter with printing out types

Revision 1.11  1992/09/01  16:31:39  jont
Stuff to understand type functions properly

Revision 1.10  1992/08/27  18:38:22  davidt
Made various changes so that structure copying can be
done more efficiently.

Revision 1.9  1992/08/11  17:42:42  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.8  1992/08/04  19:51:39  davidt
Took out some long bits of commented out code, and replaced
most to_list calls with folds.

Revision 1.7  1992/07/17  10:17:37  jont
Changed to use btrees for renaming of tynames and strnames

Revision 1.6  1992/07/04  17:15:54  jont
Anel's changes for improved structure copying

Revision 1.5  1992/06/30  10:28:33  jont
Changed to imperative implementation of namesets with hashing

Revision 1.1  1992/04/21  17:03:09  jont
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "../utils/print";
require "../utils/crash";
require "../typechecker/types";
require "../typechecker/strnames";
require "stamp";
require "namesettypes";

require "../typechecker/nameset";

functor Nameset(
  structure Crash : CRASH
  structure Print : PRINT
  structure Types : TYPES
  structure NamesetTypes : NAMESETTYPES
  structure Stamp : STAMP

  structure Strnames : STRNAMES
  sharing Types.Datatypes = Strnames.Datatypes

  sharing type NamesetTypes.TynameSet.element = Types.Datatypes.Tyname
  sharing type NamesetTypes.StrnameSet.element = Types.Datatypes.Strname
  sharing type Types.Datatypes.Stamp = Stamp.Stamp
  sharing type Types.Datatypes.StampMap = Stamp.Map.T
) : NAMESET =
  struct
    structure Datatypes = Types.Datatypes
    structure Options = Types.Options
    structure TynameSet = NamesetTypes.TynameSet
    structure StrnameSet = NamesetTypes.StrnameSet

    type Nameset = NamesetTypes.Nameset

    open Datatypes

    val initial_tynameset_size = 32
    val initial_strnameset_size = 16

    fun empty_nameset () =
      NamesetTypes.NAMESET(NamesetTypes.TynameSet.empty_set initial_tynameset_size,
			 NamesetTypes.StrnameSet.empty_set initial_strnameset_size)

    fun member_of_tynames (tyname,NamesetTypes.NAMESET(tynames,_)) = 
      NamesetTypes.TynameSet.is_member(tynames, tyname)

    fun member_of_strnames (strname,NamesetTypes.NAMESET(_,strnames)) = 
      NamesetTypes.StrnameSet.is_member(strnames, strname)

    fun union (NamesetTypes.NAMESET(tynames,strnames),NamesetTypes.NAMESET(tynames',strnames')) =
      NamesetTypes.NAMESET(NamesetTypes.TynameSet.union(tynames,tynames'),
                           NamesetTypes.StrnameSet.union (strnames,strnames'))


    fun intersection (NamesetTypes.NAMESET(tynames,strnames),NamesetTypes.NAMESET(tynames',strnames')) = 
      NamesetTypes.NAMESET(NamesetTypes.TynameSet.intersection(tynames,tynames'),
                           NamesetTypes.StrnameSet.intersection (strnames,strnames'))

    fun nameset_eq (NamesetTypes.NAMESET(tynames,strnames),NamesetTypes.NAMESET(tynames',strnames')) = 
      NamesetTypes.TynameSet.seteq(tynames,tynames')
      andalso
      NamesetTypes.StrnameSet.seteq(strnames,strnames')

    fun emptyp nameset =
      nameset_eq (nameset, empty_nameset())

    fun no_tynames (NamesetTypes.NAMESET(tynames,_)) = NamesetTypes.TynameSet.empty_setp tynames

    fun add_tyname (name,NamesetTypes.NAMESET(tynames,strnames)) =
      NamesetTypes.NAMESET(NamesetTypes.TynameSet.add_member(tynames, name),strnames)

    fun add_strname (name,NamesetTypes.NAMESET(tynames,strnames)) = 
      NamesetTypes.NAMESET(tynames, NamesetTypes.StrnameSet.add_member(strnames, name))

    fun tynames_in_nameset (tynames,NamesetTypes.NAMESET(tynames',strnames)) = 
      NamesetTypes.NAMESET(NamesetTypes.TynameSet.add_list(tynames', tynames),strnames)

    (****
     local_setdiff removes all the elements of the second argument that are
     members of the first argument from the first argument.
     ****)

    fun remove_tyname (name,NamesetTypes.NAMESET(tynames,strnames)) = 
      NamesetTypes.NAMESET(NamesetTypes.TynameSet.remove_member(tynames, name),strnames)

    fun remove_strname (name,NamesetTypes.NAMESET(tynames,strnames)) = 
      NamesetTypes.NAMESET(tynames,NamesetTypes.StrnameSet.remove_member(strnames, name))

    fun diff (NamesetTypes.NAMESET(tynames,strnames),NamesetTypes.NAMESET(tynames',strnames')) =
      NamesetTypes.NAMESET(NamesetTypes.TynameSet.setdiff(tynames,tynames'),
                           NamesetTypes.StrnameSet.setdiff (strnames,strnames'))

    val initial_nameset =
      NamesetTypes.NAMESET(NamesetTypes.TynameSet.list_to_set
                         [Types.bool_tyname,
                          Types.int_tyname,
                          Types.word_tyname,
                          Types.int8_tyname,
                          Types.word8_tyname,
                          Types.int16_tyname,
                          Types.word16_tyname,
                          Types.int32_tyname,
                          Types.word32_tyname,
                          Types.int64_tyname,
                          Types.word64_tyname,
                          Types.real_tyname,
                          Types.float32_tyname,
                          Types.string_tyname,
                          Types.char_tyname,
                          Types.list_tyname,
                          Types.ref_tyname,
                          Types.exn_tyname],
                         NamesetTypes.StrnameSet.empty_set initial_strnameset_size)

    val initial_nameset_for_builtin_library =
      initial_nameset

    fun string_nameset options (NamesetTypes.NAMESET(tynames,strnames)) =
      "NAMESET ({" ^ (NamesetTypes.TynameSet.set_print(tynames, Types.debug_print_name)) ^ "}{" ^
      (NamesetTypes.StrnameSet.set_print(strnames, Strnames.string_strname)) ^ "})"

    local
      val doCopyRigidTyname = Types.create_tyname_copy true

      val doCopyRigidStrname = Strnames.create_strname_copy true

      val doNewTyname = Types.create_tyname_copy false

      val doNewStrname = Strnames.create_strname_copy false

      fun copy
        (tynamecopyfun,strnamecopyfun)
        (NamesetTypes.NAMESET(tynames,strnames),
         strname_copies,tyname_copies) newTynameLevel = 
	let
          (* Make copies of the nameset *)
	  val tyname_copies' =
	    NamesetTypes.TynameSet.fold (tynamecopyfun newTynameLevel)
                                        (tyname_copies, tynames)
	  val strname_copies' =
	    NamesetTypes.StrnameSet.fold strnamecopyfun 
                                         (strname_copies, strnames)

          (* Remove instantiations of METATYNAMES *)
	  fun strip_tyname(meta as METATYNAME{1 = ref(NULL_TYFUN _), ...}) =
	    meta
	    | strip_tyname(METATYNAME{1=ref(ETA_TYFUN tyname), ...}) =
	      strip_tyname tyname
	    | strip_tyname _ = Crash.impossible"strip_tyname"

          (* Is the difference with the one in _types significant? *)
	  fun copy_type(METATYVAR(ref(i, ty,instances), eq, imp)) =
	    METATYVAR(ref(i, copy_type ty,instances), eq, imp)
	    | copy_type(METARECTYPE(ref(i, flex, ty, eq, imp))) =
	      METARECTYPE(ref(i, flex, copy_type ty, eq, imp))
	    | copy_type(RECTYPE map) =
	      RECTYPE(NewMap.map copy_type_map map)
	    | copy_type(FUNTYPE(ty1, ty2)) =
	      FUNTYPE(copy_type ty1, copy_type ty2)
	    | copy_type(CONSTYPE(type_list, tyname)) =
	      let
		val type_list = map copy_type type_list
		val tyname = case tyname of
		  TYNAME {1=id,...} => 
                    (case Stamp.Map.tryApply'(tyname_copies', id) of
                       SOME tyname' => tyname'
                     | _ => tyname)
		| METATYNAME(r as ref tyfun, s, ar, ref eq, ref ve, ref is_abs) =>
		    if Types.null_tyfunp tyfun then
		      let
                        val stripped_tyname = strip_tyname tyname
			val (r, id) = case stripped_tyname of
			  METATYNAME{1=r as ref(NULL_TYFUN (id,_)), ...} =>
			    (r, id)
			| _ => Crash.impossible"strip_tyname2"
		      in
			case Stamp.Map.tryApply'(tyname_copies', id) of
                          SOME x => x
                        | _ => stripped_tyname
		      end
		    else
		      tyname
	      in
		CONSTYPE(type_list, tyname)
	      end
	    | copy_type ty = ty

	  and copy_type_map(_, ty) = copy_type ty

	  fun copy_type_for_scheme(FUNTYPE(ty, _)) =
	    FUNTYPE(copy_type ty, NULLTYPE)
	    | copy_type_for_scheme _ = NULLTYPE

	  and copy_scheme(scheme as OVERLOADED_SCHEME _) = scheme
	    | copy_scheme(UNBOUND_SCHEME (ty,instance)) =
	      UNBOUND_SCHEME(copy_type_for_scheme ty,instance)
	    | copy_scheme(SCHEME(i, (ty,instance))) =
	      SCHEME(i, (copy_type_for_scheme ty,instance))

	  fun new_valenvs(meta as METATYNAME(ref(NULL_TYFUN id), s, arity,
					     ref eq, r as
					     ref(VE(_,mapping)),
                                             ref is_abs)) =
	    let
	      val mapping = NewMap.map (copy_scheme o #2) mapping
	    in
	      r := VE(ref 0, mapping)
	    end
            | new_valenvs(TYNAME{5= r as ref(VE(_, mapping)) ,...}) =
              let
                val mapping = 
                  NewMap.map (copy_scheme o #2) mapping
              in
                r := VE(ref 0, mapping)
              end
	    | new_valenvs _ = ()

          fun findstrname (strname as METASTRNAME (ref (NULLNAME id)),
                           strname_map) =
            Stamp.Map.apply_default'(strname_map, strname, id)
            | findstrname (strname as METASTRNAME (ref name),copies) = 
              findstrname (name,copies)
            | findstrname (strname,_) = strname

          fun findtyname (tyname as METATYNAME {1=ref (NULL_TYFUN (id,_)), ...},
                          tyname_map) =
            Stamp.Map.apply_default'(tyname_map, tyname, id)
            | findtyname (METATYNAME {1 = ref (ETA_TYFUN 
                                               (tyname as METATYNAME 
                                                {1 = ref tyfun,...})),...},
              copies) = findtyname (tyname,copies)
            | findtyname (METATYNAME {1 = ref (TYFUN 
                                               (CONSTYPE ([],tyname as METATYNAME 
                                                          {1 = ref tyfun,...}),
                                                _)),...},
              copies) = findtyname (tyname,copies)
            | findtyname (tyname as METATYNAME {1=ref tyfun, ...},_) = tyname
            | findtyname (tyname as TYNAME {1= id,...},tyname_map) =
              Stamp.Map.apply_default'(tyname_map, tyname, id)

          fun substTynameCopies tyname_copies (res, tyname) =
            NamesetTypes.TynameSet.add_member (res, findtyname(tyname, tyname_copies))

          fun substStrnameCopies strname_copies (res, strname) =
            NamesetTypes.StrnameSet.add_member (res, findstrname(strname, strname_copies))

	  val tynames' =
	    NamesetTypes.TynameSet.fold (substTynameCopies tyname_copies')
	    (NamesetTypes.TynameSet.empty_set (NamesetTypes.TynameSet.set_size tynames div 2),
	     tynames)
	  val strnames' =
	    NamesetTypes.StrnameSet.fold (substStrnameCopies strname_copies')
	    (NamesetTypes.StrnameSet.empty_set(NamesetTypes.StrnameSet.set_size strnames div 2),
	     strnames)
	  val _ = NamesetTypes.TynameSet.iterate new_valenvs tynames'
	in
	  (NamesetTypes.NAMESET(tynames',strnames'), strname_copies',tyname_copies')
	end
    in
      val nameset_rigid_copy = copy (doCopyRigidTyname,doCopyRigidStrname)
      (****
       new_names instantiate every flexible name to a new distinct 
       name - used in rule 64.  Necessary for correct sharing.
       See test t4.sml.
       ****)

      val new_names =  copy (doNewTyname,doNewStrname)

      val nameset_copy = new_names

      fun new_names_from_scratch nameset = 
                new_names (nameset, Stamp.Map.empty, Stamp.Map.empty)
    end

    (* these next three functions added 6.6.91 by nickh to enable the
     spec-encoding and decoding *)

    fun tynames_of_nameset (NamesetTypes.NAMESET(tl,sl)) = NamesetTypes.TynameSet.set_to_list tl
    fun strnames_of_nameset (NamesetTypes.NAMESET(tl,sl)) = NamesetTypes.StrnameSet.set_to_list sl
    fun nameset_of_name_lists (tl,sl) =
      NamesetTypes.NAMESET (NamesetTypes.TynameSet.list_to_set tl,NamesetTypes.StrnameSet.list_to_set sl)

    fun simple_copy nameset =
      nameset_of_name_lists (tynames_of_nameset nameset,
                             strnames_of_nameset nameset)

    fun nameset_rehash(NamesetTypes.NAMESET(tl,sl)) =
      (TynameSet.rehash tl; StrnameSet.rehash sl)
  end
@


1.36.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.36  1999/02/02  16:01:47  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.35
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
a114 1
require "../utils/hashset";
@


1.35.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.35  1997/05/01  13:20:01  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.35.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.35  1997/05/01  13:20:01  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.34
log
@[Bug #1592]
Adding "char" type name to initial_nameset.
@
text
@d4 4
d275 1
a275 1
                       MLWorks.Option.SOME tyname' => tyname'
d287 1
a287 1
                          MLWorks.Option.SOME x => x
@


1.34.6.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/10/02  13:48:48  andreww
 * [Bug #1592]
 * Adding "char" type name to initial_nameset.
 *
@


1.34.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.34.6.1  1997/05/12  10:52:32  hope
 * branched from 1.34
 *
@


1.34.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.34.6.1  1997/05/12  10:52:32  hope
 * branched from 1.34
 *
@


1.34.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.34.6.1  1997/05/12  10:52:32  hope
 * branched from 1.34
 *
@


1.34.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.34.6.1.1.1  1997/07/28  18:34:22  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.34.5.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/10/02  13:48:48  andreww
 * [Bug #1592]
 * Adding "char" type name to initial_nameset.
 *
@


1.34.4.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/10/02  13:48:48  andreww
 * [Bug #1592]
 * Adding "char" type name to initial_nameset.
 *
@


1.34.4.1.1.1
log
@branched from 1.34.4.1
@
text
@a3 3
 * Revision 1.34.4.1  1996/12/17  18:19:00  hope
 * branched from 1.34
 *
@


1.34.3.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/10/02  13:48:48  andreww
 * [Bug #1592]
 * Adding "char" type name to initial_nameset.
 *
@


1.34.2.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/10/02  13:48:48  andreww
 * [Bug #1592]
 * Adding "char" type name to initial_nameset.
 *
@


1.34.2.1.1.1
log
@branched from 1.34.2.1
@
text
@a3 3
 * Revision 1.34.2.1  1996/11/14  13:22:53  hope
 * branched from 1.34
 *
@


1.34.1.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/10/02  13:48:48  andreww
 * [Bug #1592]
 * Adding "char" type name to initial_nameset.
 *
@


1.33
log
@Replacing Map with NewMap
@
text
@d4 3
d214 1
d238 2
a239 1
        (NamesetTypes.NAMESET(tynames,strnames),strname_copies,tyname_copies) = 
d243 2
a244 1
	    NamesetTypes.TynameSet.fold tynamecopyfun (tyname_copies, tynames)
d246 2
a247 1
	    NamesetTypes.StrnameSet.fold strnamecopyfun (strname_copies, strnames)
d372 1
a372 1
      val new_names = copy (doNewTyname,doNewStrname)
d376 2
a377 1
      fun new_names_from_scratch nameset = new_names (nameset, Stamp.Map.empty, Stamp.Map.empty)
@


1.33.2.1
log
@branched from 1.33
@
text
@a3 3
 * Revision 1.33  1996/02/22  11:59:48  jont
 * Replacing Map with NewMap
 *
@


1.33.1.1
log
@branched from 1.33
@
text
@a3 3
 * Revision 1.33  1996/02/22  11:59:48  jont
 * Replacing Map with NewMap
 *
@


1.32
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
d254 2
a255 1
	    | copy_type(RECTYPE map) = RECTYPE(Mapping.mapit(map, copy_type))
d285 2
@


1.31
log
@Fix for rigid tynames in functor result problem
@
text
@d4 3
d196 9
d206 1
@


1.30
log
@Removing debug stuff
@
text
@d4 3
d103 1
d113 1
d120 2
d204 2
a205 2
      "{" ^ (NamesetTypes.TynameSet.set_print(tynames, Types.debug_print_name)) ^ "," ^
      (NamesetTypes.StrnameSet.set_print(strnames, Strnames.string_strname)) ^ "}"
d208 1
a208 56
      fun findstrname (strname as METASTRNAME (ref (NULLNAME id)),
                       strname_map) =
        Strname_id.Map.apply_default'(strname_map, strname, id)
	| findstrname (strname as METASTRNAME (ref name),copies) = 
          findstrname (name,copies)
	| findstrname (strname,_) = strname

      fun findtyname (tyname as METATYNAME {1=ref (NULL_TYFUN (id,_)), ...},
                      tyname_map) =
	Tyfun_id.Map.apply_default'(tyname_map, tyname, id)
	| findtyname (METATYNAME {1 = ref (ETA_TYFUN 
					   (tyname as METATYNAME 
					    {1 = ref tyfun,...})),...},
                      copies) = findtyname (tyname,copies)
	| findtyname (METATYNAME {1 = ref (TYFUN 
					   (CONSTYPE ([],tyname as METATYNAME 
						      {1 = ref tyfun,...}),
					    _)),...},
                      copies) = findtyname (tyname,copies)
	| findtyname (tyname as METATYNAME {1=ref tyfun, ...},_) = tyname
	| findtyname (tyname as TYNAME _,_) = tyname

      fun rigid_copy_tyname (METATYNAME(ref(NULL_TYFUN id),
                                        printname,
                                        arity,
                                        ref eq,
                                        ref ve,
                                        ref is_abs)) =
        TYNAME (Tyname_id.make_tyname_id(),
                printname,
                arity,
                ref eq,
                ref ve,
                Option.ABSENT,
                ref is_abs,
                ref empty_valenv)
      | rigid_copy_tyname _ = Crash.impossible "rigid_copy_tyname"

      fun rigid_copy_strname (METASTRNAME (ref (NULLNAME id))) =
        STRNAME (Strname_id.make_strname_id())
        | rigid_copy_strname _ = Crash.impossible "rigid_copy_strname"

      fun substTynameCopies tyname_copies (res, tyname) =
	NamesetTypes.TynameSet.add_member(res, findtyname(tyname, tyname_copies))

      fun substStrnameCopies strname_copies (res, strname) =
	NamesetTypes.StrnameSet.add_member(res, findstrname(strname, strname_copies))

      fun doCopyTyname (copies, tyname) =
	Types.create_tyname_copies (tyname, copies, Types.copy_metatyname)

      fun doCopyStrname (copies, strname) =
	Strnames.create_strname_copy (strname, copies, Strnames.copy_metastrname)

      fun doCopyRigidTyname (copies,tyname) =
        Types.create_tyname_copies (tyname,copies,rigid_copy_tyname)
d210 1
a210 2
      fun doCopyRigidStrname (copies,strname) =
        Strnames.create_strname_copy (strname,copies,rigid_copy_strname)
d212 1
a212 2
      fun doNewTyname (new, tyname) =
	Types.create_tyname_copies (tyname, new, Types.new_metatyname)
d214 1
a214 2
      fun doNewStrname (new, strname) =
	Strnames.create_strname_copy (strname, new, Strnames.new_metastrname)
d220 1
d226 1
d233 1
d245 4
a248 1
		  TYNAME _ => tyname
d258 3
a260 2
			Tyfun_id.Map.apply'(tyname_copies', id)
                        handle Tyfun_id.Map.Undefined => stripped_tyname
d281 1
a281 1
					     ref(VE(_, mapping)),
d297 29
d328 1
a328 1
	    (NamesetTypes.TynameSet.empty_set(NamesetTypes.TynameSet.set_size tynames div 2),
a338 2
      val nameset_copy = copy (doCopyTyname,doCopyStrname)

d350 1
a350 2
      fun new_names_from_scratch nameset =
	new_names(nameset, Strname_id.Map.empty, Tyfun_id.Map.empty)
@


1.29
log
@Extra TYNAME valenv for Modules Debugger.
@
text
@d4 3
a97 1
require "../typechecker/ty_debug";
a105 5
  structure Debug :
		sig
		  val set_debug_level : int -> unit
		  val debug_level : unit -> int
		end
a106 1
  structure Ty_Debug : TY_DEBUG
a123 1
    val do_debug = Ty_Debug.do_debug
@


1.28
log
@Added --
remove_strname -- delete a strname from a nameset
simple_copy -- make a duplicate nameset
@
text
@d4 5
d240 2
a241 1
                ref is_abs)
@


1.27
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d137 1
a137 5
      (if do_debug andalso Debug.debug_level () > 5 then 
	 Print.print ("member_of_strnames " ^
		      (Strnames.string_strname strname) ^"\n")
       else ();
      NamesetTypes.StrnameSet.is_member(strnames, strname))
d140 2
a141 6
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("Nameset.union");
	  Print.print ("\n"))
       else ();
       NamesetTypes.NAMESET(NamesetTypes.TynameSet.union(tynames,tynames'),
                          NamesetTypes.StrnameSet.union (strnames,strnames')))
d145 2
a146 6
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("Nameset.intersection");
	  Print.print ("\n"))
       else ();
       NamesetTypes.NAMESET(NamesetTypes.TynameSet.intersection(tynames,tynames'),
                          NamesetTypes.StrnameSet.intersection (strnames,strnames')))
d165 1
a165 5
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("Nameset.tynames_in_nameset");
	  Print.print ("\n"))
       else ();
       NamesetTypes.NAMESET(NamesetTypes.TynameSet.add_list(tynames', tynames),strnames))
d175 3
d179 2
a180 6
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("Nameset.diff");
	  Print.print ("\n"))
       else ();
	 NamesetTypes.NAMESET(NamesetTypes.TynameSet.setdiff(tynames,tynames'),
                            NamesetTypes.StrnameSet.setdiff (strnames,strnames')))
d377 4
@


1.26
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d241 2
a242 1
                                        ref ve)) =
d248 2
a249 1
                Option.ABSENT)
d307 1
a307 1
		| METATYNAME(r as ref tyfun, s, ar, ref eq, ref ve) =>
d338 2
a339 1
					     ref(VE(_, mapping)))) =
@


1.25
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.
@
text
@d4 4
d290 2
a291 2
	  fun copy_type(METATYVAR(ref(i, ty), eq, imp)) =
	    METATYVAR(ref(i, copy_type ty), eq, imp)
d326 4
a329 4
	    | copy_scheme(UNBOUND_SCHEME (ty)) =
	      UNBOUND_SCHEME(copy_type_for_scheme ty)
	    | copy_scheme(SCHEME(i, (ty))) =
	      SCHEME(i, (copy_type_for_scheme ty))
d356 1
a356 1
          val _ = NamesetTypes.TynameSet.iterate new_valenvs tynames'
@


1.25.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.25  1993/07/30  11:29:49  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.

@


1.24
log
@Handle Tyfun_id.Map.Undefined
@
text
@d4 3
d215 1
a215 1
      fun findtyname (tyname as METATYNAME {1=ref (NULL_TYFUN id), ...},
d240 1
a240 1
                ABSENT)
d303 1
a303 1
			  METATYNAME{1=r as ref(NULL_TYFUN id), ...} =>
d317 1
a317 1
	  and copy_type_for_scheme(FUNTYPE(ty, _)) =
d322 1
a322 1
	    | copy_scheme(UNBOUND_SCHEME ty) =
d324 2
a325 2
	    | copy_scheme(SCHEME(i, ty)) =
	      SCHEME(i, copy_type_for_scheme ty)
d337 2
a338 1
                val mapping = NewMap.map (copy_scheme o #2) mapping
d352 1
a352 1
	  val _ = NamesetTypes.TynameSet.iterate new_valenvs tynames'
@


1.23
log
@Added nameset_rehash to deal with the effects of sharing and realisation
@
text
@d4 3
d201 1
a201 1
      "{" ^ (NamesetTypes.TynameSet.set_print(tynames, Types.print_name options)) ^ "," ^
d207 1
a207 5
	(if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("Nameset.findstrname strname = " ^ 
			 (Strnames.string_strname strname)))
	 else ();
	   Strname_id.Map.apply_default'(strname_map, strname, id))
d298 2
a299 1
			val (r, id) = case strip_tyname tyname of
d305 1
d363 2
@


1.22
log
@Removed duplication between copying functions
Added nameset_rigid_copy for use in abstraction semantics
@
text
@d4 4
d102 2
d374 3
@


1.21
log
@Added NamesetTypes structure
/
@
text
@d4 4
d139 6
a144 8
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("Nameset.nameset_eq");
	  Print.print ("\n"))
       else ();
	 NamesetTypes.TynameSet.seteq(tynames,tynames')
	 andalso
	 NamesetTypes.StrnameSet.seteq(strnames,strnames')
	 )
d222 17
d251 6
d262 4
a265 2
    in
      fun nameset_copy (NamesetTypes.NAMESET(tynames,strnames),strname_copies,tyname_copies) = 
d268 1
a268 1
	    NamesetTypes.TynameSet.fold doCopyTyname (tyname_copies, tynames)
d270 1
a270 1
	    NamesetTypes.StrnameSet.fold doCopyStrname (strname_copies, strnames)
d345 4
a348 1
    
d355 1
a355 76
      fun new_names (NamesetTypes.NAMESET(tynames,strnames),new_strnames,new_tynames) = 
	let
	  val new_tynames' =
	    NamesetTypes.TynameSet.fold doNewTyname (new_tynames, tynames)
	  val new_strnames' =
	    NamesetTypes.StrnameSet.fold doNewStrname (new_strnames, strnames)

	  fun strip_tyname(meta as METATYNAME{1 = ref(NULL_TYFUN _), ...}) =
	    meta
	    | strip_tyname(METATYNAME{1=ref(ETA_TYFUN tyname), ...}) =
	      strip_tyname tyname
	    | strip_tyname _ = Crash.impossible"strip_tyname"

	  fun copy_type(METATYVAR(ref(i, ty), eq, imp)) =
	    METATYVAR(ref(i, copy_type ty), eq, imp)
	    | copy_type(METARECTYPE(ref(i, flex, ty, eq, imp))) =
	      METARECTYPE(ref(i, flex, copy_type ty, eq, imp))
	    | copy_type(RECTYPE map) = RECTYPE(Mapping.mapit(map, copy_type))
	    | copy_type(FUNTYPE(ty1, ty2)) =
	      FUNTYPE(copy_type ty1, copy_type ty2)
	    | copy_type(CONSTYPE(type_list, tyname)) =
	      let
		val type_list = map copy_type type_list
		val tyname = case tyname of
		  TYNAME _ => tyname
		| METATYNAME(r as ref tyfun, s, ar, ref eq, ref ve) =>
		    if Types.null_tyfunp tyfun then
		      let
			val (r, id) = case strip_tyname tyname of
			  METATYNAME{1=r as ref(NULL_TYFUN id), ...} =>
			    (r, id)
			| _ => Crash.impossible"strip_tyname2"
		      in
			Tyfun_id.Map.apply_default'(new_tynames', tyname, id)
		      end
		    else
		      tyname
	      in
		CONSTYPE(type_list, tyname)
	      end
	    | copy_type ty = ty

	  and copy_type_for_scheme(FUNTYPE(ty, _)) =
	    FUNTYPE(copy_type ty, NULLTYPE)
	    | copy_type_for_scheme _ = NULLTYPE

	  and copy_scheme(scheme as OVERLOADED_SCHEME _) = scheme
	    | copy_scheme(UNBOUND_SCHEME ty) =
	      UNBOUND_SCHEME(copy_type_for_scheme ty)
	    | copy_scheme(SCHEME(i, ty)) =
	      SCHEME(i, copy_type_for_scheme ty)

	  fun new_valenvs(meta as METATYNAME(ref(NULL_TYFUN id), s, arity,
					     ref eq, r as
					     ref(VE(_, mapping)))) =
	    let
	      val mapping = NewMap.map (copy_scheme o #2) mapping
	    in
	      r := VE(ref 0, mapping)
	    end
	    | new_valenvs _ = ()

	  val tynames' =
	    NamesetTypes.TynameSet.fold (substTynameCopies new_tynames')
	    (NamesetTypes.TynameSet.empty_set(NamesetTypes.TynameSet.set_size tynames div 2),
	     tynames)
	  val strnames' =
	    NamesetTypes.StrnameSet.fold (substStrnameCopies new_strnames')
	    (NamesetTypes.StrnameSet.empty_set(NamesetTypes.StrnameSet.set_size strnames div 2),
	     strnames)
	  val _ = NamesetTypes.TynameSet.iterate
	    new_valenvs
	    tynames'
	in
	  (NamesetTypes.NAMESET(tynames',strnames'), new_strnames',new_tynames')
	end
@


1.20
log
@Options & Info changes
@
text
@d4 3
a66 1
require "../typechecker/nameset";
d69 3
a71 1
require "../typechecker/basistypes";
d83 1
a83 1
  structure BasisTypes : BASISTYPES
d86 4
a89 3
  sharing Types.Datatypes = Strnames.Datatypes = BasisTypes.Datatypes
  sharing type BasisTypes.TynameSet.element = Types.Datatypes.Tyname
  sharing type BasisTypes.StrnameSet.element = Types.Datatypes.Strname
a92 1
    structure BasisTypes = BasisTypes
d95 2
d104 2
a105 2
      BasisTypes.NAMESET(BasisTypes.TynameSet.empty_set initial_tynameset_size,
			 BasisTypes.StrnameSet.empty_set initial_strnameset_size)
d107 2
a108 2
    fun member_of_tynames (tyname,BasisTypes.NAMESET(tynames,_)) = 
      BasisTypes.TynameSet.is_member(tynames, tyname)
d110 1
a110 1
    fun member_of_strnames (strname,BasisTypes.NAMESET(_,strnames)) = 
d115 1
a115 1
      BasisTypes.StrnameSet.is_member(strnames, strname))
d117 1
a117 1
    fun union (BasisTypes.NAMESET(tynames,strnames),BasisTypes.NAMESET(tynames',strnames')) =
d122 2
a123 2
       BasisTypes.NAMESET(BasisTypes.TynameSet.union(tynames,tynames'),
                          BasisTypes.StrnameSet.union (strnames,strnames')))
d126 1
a126 1
    fun intersection (BasisTypes.NAMESET(tynames,strnames),BasisTypes.NAMESET(tynames',strnames')) = 
d131 2
a132 2
       BasisTypes.NAMESET(BasisTypes.TynameSet.intersection(tynames,tynames'),
                          BasisTypes.StrnameSet.intersection (strnames,strnames')))
d134 1
a134 1
    fun nameset_eq (BasisTypes.NAMESET(tynames,strnames),BasisTypes.NAMESET(tynames',strnames')) = 
d139 1
a139 1
	 BasisTypes.TynameSet.seteq(tynames,tynames')
d141 1
a141 1
	 BasisTypes.StrnameSet.seteq(strnames,strnames')
d144 1
a144 1
    fun no_tynames (BasisTypes.NAMESET(tynames,_)) = BasisTypes.TynameSet.empty_setp tynames
d146 2
a147 2
    fun add_tyname (name,BasisTypes.NAMESET(tynames,strnames)) =
      BasisTypes.NAMESET(BasisTypes.TynameSet.add_member(tynames, name),strnames)
d149 2
a150 2
    fun add_strname (name,BasisTypes.NAMESET(tynames,strnames)) = 
      BasisTypes.NAMESET(tynames, BasisTypes.StrnameSet.add_member(strnames, name))
d152 1
a152 1
    fun tynames_in_nameset (tynames,BasisTypes.NAMESET(tynames',strnames)) = 
d157 1
a157 1
       BasisTypes.NAMESET(BasisTypes.TynameSet.add_list(tynames', tynames),strnames))
d164 2
a165 2
    fun remove_tyname (name,BasisTypes.NAMESET(tynames,strnames)) = 
      BasisTypes.NAMESET(BasisTypes.TynameSet.remove_member(tynames, name),strnames)
d167 1
a167 1
    fun diff (BasisTypes.NAMESET(tynames,strnames),BasisTypes.NAMESET(tynames',strnames')) =
d172 2
a173 2
	 BasisTypes.NAMESET(BasisTypes.TynameSet.setdiff(tynames,tynames'),
                            BasisTypes.StrnameSet.setdiff (strnames,strnames')))
d176 1
a176 1
      BasisTypes.NAMESET(BasisTypes.TynameSet.list_to_set
d184 1
a184 1
                         BasisTypes.StrnameSet.empty_set initial_strnameset_size)
d189 3
a191 3
    fun string_nameset options (BasisTypes.NAMESET(tynames,strnames)) =
      "{" ^ (BasisTypes.TynameSet.set_print(tynames, Types.print_name options)) ^ "," ^
      (BasisTypes.StrnameSet.set_print(strnames, Strnames.string_strname)) ^ "}"
d221 1
a221 1
	BasisTypes.TynameSet.add_member(res, findtyname(tyname, tyname_copies))
d224 1
a224 1
	BasisTypes.StrnameSet.add_member(res, findstrname(strname, strname_copies))
d238 1
a238 1
      fun nameset_copy (BasisTypes.NAMESET(tynames,strnames),strname_copies,tyname_copies) = 
d241 1
a241 1
	    BasisTypes.TynameSet.fold doCopyTyname (tyname_copies, tynames)
d243 1
a243 1
	    BasisTypes.StrnameSet.fold doCopyStrname (strname_copies, strnames)
d307 2
a308 2
	    BasisTypes.TynameSet.fold (substTynameCopies tyname_copies')
	    (BasisTypes.TynameSet.empty_set(BasisTypes.TynameSet.set_size tynames div 2),
d311 2
a312 2
	    BasisTypes.StrnameSet.fold (substStrnameCopies strname_copies')
	    (BasisTypes.StrnameSet.empty_set(BasisTypes.StrnameSet.set_size strnames div 2),
d314 1
a314 1
	  val _ = BasisTypes.TynameSet.iterate new_valenvs tynames'
d316 1
a316 1
	  (BasisTypes.NAMESET(tynames',strnames'), strname_copies',tyname_copies')
d325 1
a325 1
      fun new_names (BasisTypes.NAMESET(tynames,strnames),new_strnames,new_tynames) = 
d328 1
a328 1
	    BasisTypes.TynameSet.fold doNewTyname (new_tynames, tynames)
d330 1
a330 1
	    BasisTypes.StrnameSet.fold doNewStrname (new_strnames, strnames)
d388 2
a389 2
	    BasisTypes.TynameSet.fold (substTynameCopies new_tynames')
	    (BasisTypes.TynameSet.empty_set(BasisTypes.TynameSet.set_size tynames div 2),
d392 2
a393 2
	    BasisTypes.StrnameSet.fold (substStrnameCopies new_strnames')
	    (BasisTypes.StrnameSet.empty_set(BasisTypes.StrnameSet.set_size strnames div 2),
d395 1
a395 1
	  val _ = BasisTypes.TynameSet.iterate
d399 1
a399 1
	  (BasisTypes.NAMESET(tynames',strnames'), new_strnames',new_tynames')
d409 2
a410 2
    fun tynames_of_nameset (BasisTypes.NAMESET(tl,sl)) = BasisTypes.TynameSet.set_to_list tl
    fun strnames_of_nameset (BasisTypes.NAMESET(tl,sl)) = BasisTypes.StrnameSet.set_to_list sl
d412 1
a412 1
      BasisTypes.NAMESET (BasisTypes.TynameSet.list_to_set tl,BasisTypes.StrnameSet.list_to_set sl)
@


1.19
log
@Modified to use the new hashset with variable size tables
@
text
@d4 3
a82 1
  sharing Types.Info = BasisTypes.Info
d89 1
a89 1
    structure Info = Types.Info
@


1.18
log
@Changes for BASISTYPES signature
@
text
@d4 3
d92 2
a93 1
    val set_size = 1024
d96 2
a97 1
      BasisTypes.NAMESET(BasisTypes.TynameSet.empty_set(), BasisTypes.StrnameSet.empty_set())
d176 1
a176 1
                         BasisTypes.StrnameSet.empty_set())
d300 2
a301 1
	    (BasisTypes.TynameSet.empty_set(), tynames)
d304 2
a305 1
	    (BasisTypes.StrnameSet.empty_set(), strnames)
d381 2
a382 1
	    (BasisTypes.TynameSet.empty_set(), tynames)
d385 2
a386 1
	    (BasisTypes.StrnameSet.empty_set(), strnames)
@


1.17
log
@Modified to use new improved hashset signature
@
text
@d4 3
d61 1
a64 2
  structure TynameSet : HASHSET
  structure StrnameSet : HASHSET
d73 2
d76 4
a79 3
  sharing Types.Datatypes = Strnames.Datatypes
  sharing type TynameSet.element = Types.Datatypes.Tyname
  sharing type StrnameSet.element = Types.Datatypes.Strname
d83 1
a88 7
    (****
     Nameset is one of the semantic objects for the Modules.  In this
     structure the type and the operations on it are defined.
     ****)

    type Nameset = (TynameSet.HashSet * StrnameSet.HashSet)

d92 1
a92 1
      (TynameSet.empty_set(), StrnameSet.empty_set())
d94 2
a95 2
    fun member_of_tynames (tyname,(tynames,_)) = 
      TynameSet.is_member(tynames, tyname)
d97 1
a97 1
    fun member_of_strnames (strname,(_,strnames)) = 
d102 1
a102 1
      StrnameSet.is_member(strnames, strname))
d104 1
a104 1
    fun union ((tynames,strnames),(tynames',strnames')) =
d109 2
a110 2
      (TynameSet.union(tynames,tynames'),
       StrnameSet.union (strnames,strnames')))
d113 1
a113 1
    fun intersection ((tynames,strnames),(tynames',strnames')) = 
d118 2
a119 2
      (TynameSet.intersection(tynames,tynames'),
       StrnameSet.intersection (strnames,strnames')))
d121 1
a121 1
    fun nameset_eq ((tynames,strnames),(tynames',strnames')) = 
d126 1
a126 1
	 TynameSet.seteq(tynames,tynames')
d128 1
a128 1
	 StrnameSet.seteq(strnames,strnames')
d131 1
a131 1
    fun no_tynames (tynames,_) = TynameSet.empty_setp tynames
d133 2
a134 2
    fun add_tyname (name,(tynames,strnames)) =
      (TynameSet.add_member(tynames, name),strnames)
d136 2
a137 2
    fun add_strname (name,(tynames,strnames)) = 
      (tynames, StrnameSet.add_member(strnames, name))
d139 1
a139 1
    fun tynames_in_nameset (tynames,(tynames',strnames)) = 
d144 1
a144 1
      (TynameSet.add_list(tynames', tynames),strnames))
d151 2
a152 2
    fun remove_tyname (name,(tynames,strnames)) = 
      (TynameSet.remove_member(tynames, name),strnames)
d154 1
a154 1
    fun diff ((tynames,strnames),(tynames',strnames')) =
d159 2
a160 2
	 (TynameSet.setdiff(tynames,tynames'),
	  StrnameSet.setdiff (strnames,strnames')))
d163 9
a171 9
      (TynameSet.list_to_set
       [Types.bool_tyname,
	Types.int_tyname,
	Types.real_tyname,
	Types.string_tyname,
	Types.list_tyname,
	Types.ref_tyname,
	Types.exn_tyname],
       StrnameSet.empty_set())
d176 3
a178 3
    fun string_nameset options (tynames,strnames) = 
      "{" ^ (TynameSet.set_print(tynames, Types.print_name options)) ^ "," ^
      (StrnameSet.set_print(strnames, Strnames.string_strname)) ^ "}"
d208 1
a208 1
	TynameSet.add_member(res, findtyname(tyname, tyname_copies))
d211 1
a211 1
	StrnameSet.add_member(res, findstrname(strname, strname_copies))
d225 1
a225 1
      fun nameset_copy ((tynames,strnames),strname_copies,tyname_copies) = 
d228 1
a228 1
	    TynameSet.fold doCopyTyname (tyname_copies, tynames)
d230 1
a230 1
	    StrnameSet.fold doCopyStrname (strname_copies, strnames)
d294 2
a295 2
	    TynameSet.fold (substTynameCopies tyname_copies')
	    (TynameSet.empty_set(), tynames)
d297 3
a299 3
	    StrnameSet.fold (substStrnameCopies strname_copies')
	    (StrnameSet.empty_set(), strnames)
	  val _ = TynameSet.iterate new_valenvs tynames'
d301 1
a301 1
	  ((tynames',strnames'), strname_copies',tyname_copies')
d310 1
a310 1
      fun new_names ((tynames,strnames),new_strnames,new_tynames) = 
d313 1
a313 1
	    TynameSet.fold doNewTyname (new_tynames, tynames)
d315 1
a315 1
	    StrnameSet.fold doNewStrname (new_strnames, strnames)
d373 2
a374 2
	    TynameSet.fold (substTynameCopies new_tynames')
	    (TynameSet.empty_set(), tynames)
d376 3
a378 3
	    StrnameSet.fold (substStrnameCopies new_strnames')
	    (StrnameSet.empty_set(), strnames)
	  val _ = TynameSet.iterate
d382 1
a382 1
	  ((tynames',strnames'), new_strnames',new_tynames')
d392 2
a393 2
    fun tynames_of_nameset (tl,sl) = TynameSet.set_to_list tl
    fun strnames_of_nameset (tl,sl) = StrnameSet.set_to_list sl
d395 1
a395 2
      (TynameSet.list_to_set tl,
       StrnameSet.list_to_set sl)
@


1.16
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d96 1
a96 1
      TynameSet.is_member(tyname,tynames)
d103 1
a103 1
      StrnameSet.is_member(strname,strnames))
d135 1
a135 1
      (TynameSet.add_member(name,tynames),strnames)
d138 1
a138 1
      (tynames, StrnameSet.add_member(name,strnames))
d145 1
a145 1
      (TynameSet.add_list(tynames,tynames'),strnames))
d153 1
a153 1
      (TynameSet.remove_member(name, tynames),strnames)
d209 1
a209 1
	TynameSet.add_member(findtyname(tyname, tyname_copies), res)
d212 1
a212 1
	StrnameSet.add_member(findstrname(strname, strname_copies), res)
@


1.15
log
@Added special maps for tyfun_id, tyname_id, strname_id
@
text
@d4 3
d74 1
d173 2
a174 2
    fun string_nameset (tynames,strnames) = 
      "{" ^ (TynameSet.set_print(tynames, Types.print_name)) ^ "," ^
@


1.14
log
@Some bug fixes from Anel
@
text
@d4 3
d180 1
a180 1
	   NewMap.apply_default'(strname_map, strname, id))
d187 1
a187 10
	NewMap.apply_default'(tyname_map, tyname, id)
(*
	(NewMap.apply'(tyname_map, id)
	 handle NewMap.Undefined =>
	   (if do_debug andalso Debug.debug_level () > 10 then 
	      (Print.print ("Nameset.findtyname tyname = " ^ 
			    (Types.print_name tyname)))
	    else ();
	      tyname))
*)
d251 1
a251 1
			NewMap.apply'(tyname_copies', id)
d336 1
a336 3
			case NewMap.tryApply'(new_tynames', id) of
			  NewMap.NO => tyname
			| NewMap.YES meta => meta
d379 1
a379 2
	new_names(nameset, NewMap.empty' Strname_id.strname_id_lt,
		  NewMap.empty' Tyfun_id.tyfun_id_lt)
@


1.13
log
@Removed yet another silly handler
@
text
@d4 3
d284 6
@


1.12
log
@Added updating of valenvs within metatynames when copying, to assist
the interpreter with printing out types
@
text
@d4 4
d170 5
a174 7
	  (NewMap.apply'(strname_map, id)
	   handle NewMap.Undefined =>
	     (if do_debug andalso Debug.debug_level () > 10 then 
		(Print.print ("Nameset.findstrname strname = " ^ 
			      (Strnames.string_strname strname)))
	      else ();
		strname))
@


1.11
log
@Stuff to understand type functions properly
@
text
@d4 3
d36 1
d43 1
d225 56
d287 1
d304 58
d368 3
@


1.10
log
@Made various changes so that structure copying can be
done more efficiently.
@
text
@d4 4
d174 2
d183 1
d189 1
a189 1
					   (CONSTYPE (_,tyname as METATYNAME 
@


1.9
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d196 1
a196 1
	#2(Types.tyname_copy (tyname, copies, Types.copy_metatyname))
d199 1
a199 1
	#2(Strnames.strname_copy (strname, copies, Strnames.copy_metastrname))
d202 1
a202 1
	#2(Types.tyname_copy (tyname, new, Types.new_metatyname))
d205 1
a205 1
	#2(Strnames.strname_copy (strname, new, Strnames.new_metastrname))
a244 3
      fun tyfun_id_lt(id, id') =
	Tyfun_id.tyfun_id id < Tyfun_id.tyfun_id id'

d247 1
a247 2
		  NewMap.empty' tyfun_id_lt)

a257 1

@


1.8
log
@Took out some long bits of commented out code, and replaced
most to_list calls with folds.
@
text
@d4 4
a22 2
require "../utils/newmap";
require "../utils/set";
a25 1
require "../typechecker/datatypes";
a30 2
  structure NewMap : NEWMAP
  structure Set : SET
a39 1
  structure Datatypes : DATATYPES
d42 3
a44 4
  sharing Datatypes = Types.Datatypes = Strnames.Datatypes
  sharing Types.NewMap = NewMap = Strnames.NewMap
  sharing type TynameSet.element = Datatypes.Tyname
  sharing type StrnameSet.element = Datatypes.Strname
d47 1
a47 2
    structure NewMap = NewMap
    structure Datatypes = Datatypes
@


1.7
log
@Changed to use btrees for renaming of tynames and strnames
@
text
@d4 3
a153 73
(*    local

      fun find_copy (name,[],_,stringfun) = 
	(if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("Nameset.find_copy name = " ^ (stringfun name)))
	 else ();
	   name)
	| find_copy (name,(h,h')::t,afun,stringfun) = 
	  if afun (name,h) then h'
	  else find_copy (name,t,afun,stringfun)
      fun collectCopies ([],copies,_,_) = copies
	| collectCopies (h::t,copies,afun,copy_fun) = 
	  let
	    val (copy,copies') = afun (h,copies,copy_fun)
	  in
	    collectCopies (t,copies',afun,copy_fun)
	  end
      fun substCopies ([],copies,afun,_) = []
	| substCopies (h::t,copies,afun,stringfun) = 
	  find_copy (h,copies,afun,stringfun)::substCopies (t,copies,afun,
							    stringfun)
    in
      fun nameset_copy ((tynames,strnames),strname_copies,tyname_copies) = 
	let
	  val tynames = TynameSet.set_to_list tynames
	  val strnames = StrnameSet.set_to_list strnames
	  val tyname_copies' =
	    collectCopies (tynames,tyname_copies,Types.tyname_copy,
			   Types.copy_metatyname)
	  val strname_copies' =
	    collectCopies (strnames,strname_copies,Strnames.strname_copy,
			   Strnames.copy_metastrname)
	  val tynames' = 
	    substCopies (tynames,tyname_copies',Types.tyname_eq,
			 Types.print_name)
	  val strnames' = 
	    substCopies (strnames,strname_copies',Strnames.strname_eq,
			 Strnames.string_strname)
	in
	  ((TynameSet.list_to_set tynames',
	    StrnameSet.list_to_set strnames'),
	   strname_copies',tyname_copies')
	end
    
      (****
       new_names instantiate every flexible name to a new distinct 
       name - used in rule 64.  Necessary for correct sharing.
       See test t4.sml.
       ****)

      fun new_names ((tynames,strnames),new_strnames,new_tynames) = 
	let
	  val tynames = TynameSet.set_to_list tynames
	  val strnames = StrnameSet.set_to_list strnames
	  val new_tynames' =
	    collectCopies (tynames,new_tynames,Types.tyname_copy,
			   Types.new_metatyname)
	  val new_strnames' =
	    collectCopies (strnames,new_strnames,Strnames.strname_copy,
			   Strnames.new_metastrname)
	  val tynames' = 
	    substCopies (tynames,new_tynames',Types.tyname_eq,
			 Types.print_name)
	  val strnames' = 
	    substCopies (strnames,new_strnames',Strnames.strname_eq,
			 Strnames.string_strname)
	in
	  ((TynameSet.list_to_set tynames',
	    StrnameSet.list_to_set strnames'),
	   new_strnames',new_tynames')
	end
    end
*)
a154 17

      fun collectCopies ([],copies,_,_) = copies
	| collectCopies (h::t,copies,afun,copy_fun) = 
	  let
	    val (_,copies') = afun (h,copies,copy_fun)
	  in
	    collectCopies (t,copies',afun,copy_fun)
	  end

(*
      fun findstrname (strname,[]) = 
	(if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("Nameset.findstrname strname = " ^ 
                         (Strnames.string_strname strname)))
	 else ();
	   strname)
*)
a167 8
(*
      fun findtyname (tyname,[]) = 
	(if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("Nameset.findtyname tyname = " ^ 
                         (Types.print_name tyname)))
	 else ();
	   tyname)
*)
d189 17
a205 3
      fun substCopies ([],_,_,acc) = acc
	| substCopies (h::t,copies,findfun,acc) = 
	  substCopies (t,copies,findfun,findfun (h,copies)::acc)
a208 2
	  val tynames = TynameSet.set_to_list tynames
	  val strnames = StrnameSet.set_to_list strnames
d210 1
a210 2
	    collectCopies (tynames,tyname_copies,Types.tyname_copy,
			   Types.copy_metatyname)
d212 7
a218 8
	    collectCopies (strnames,strname_copies,Strnames.strname_copy,
			   Strnames.copy_metastrname)
	  val tynames' = 
	    TynameSet.list_to_set (substCopies (tynames,tyname_copies',
                                                findtyname,[]))
	  val strnames' = 
	    StrnameSet.list_to_set (substCopies (strnames,strname_copies',
                                                 findstrname,[]))
d220 1
a220 2
	  ((tynames',strnames'),
	   strname_copies',tyname_copies')
a230 2
	  val tynames = TynameSet.set_to_list tynames
	  val strnames = StrnameSet.set_to_list strnames
d232 1
a232 2
	    collectCopies (tynames,new_tynames,Types.tyname_copy,
			   Types.new_metatyname)
d234 7
a240 8
	    collectCopies (strnames,new_strnames,Strnames.strname_copy,
			   Strnames.new_metastrname)
	  val tynames' = 
	    TynameSet.list_to_set (substCopies (tynames,new_tynames',
                                                findtyname,[]))
	  val strnames' = 
	    StrnameSet.list_to_set (substCopies (strnames,new_strnames',
                                                 findstrname,[]))
d242 1
a242 2
	  ((tynames',strnames'),
	   new_strnames',new_tynames')
d244 1
@


1.6
log
@Anel's changes for improved structure copying
@
text
@d4 3
d16 1
d27 1
d42 1
d47 1
a47 1

d234 1
d241 10
a250 3
	| findstrname (strname as METASTRNAME (ref (NULLNAME id)),
                       (id',strname')::t) =
	  if id = id' then strname' else findstrname (strname,t)
d255 1
d262 10
a271 3
	| findtyname (tyname as METATYNAME {1=ref (NULL_TYFUN id), ...},
                      (id',tyname')::t) =
	  if id = id' then tyname' else findtyname (tyname,t)
d335 7
@


1.5
log
@Changed to imperative implementation of namesets with hashing
@
text
@d4 3
d145 1
a145 1
    local
d217 1
a217 3


(*
d277 2
a278 1
	    substCopies (tynames,tyname_copies',findtyname,[])
d280 2
a281 1
	    substCopies (strnames,strname_copies',findstrname,[])
d283 1
a283 2
	  ((TynameSet.list_to_set tynames',
	    StrnameSet.list_to_set strnames'),
d304 2
a305 1
	    substCopies (tynames,new_tynames',findtyname,[])
d307 2
a308 1
	    substCopies (strnames,new_strnames',findstrname,[])
d310 1
a310 2
	  ((TynameSet.list_to_set tynames',
	    StrnameSet.list_to_set strnames'),
d314 1
a314 1
*)
@


1.4
log
@New pervasive library code - cut some things out of the initial type basis
@
text
@d4 1
a4 8
Revision 1.3  1992/01/27  20:14:13  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.2  1991/11/21  16:46:12  jont
Added copyright message

Revision 1.1  91/06/07  11:36:46  colin
d7 1
a7 1
Copyright (c) 1991 Harlequin Ltd.
d11 1
d21 2
d33 4
a36 2
  sharing Datatypes = Types.Datatypes 
    = Strnames.Datatypes) : NAMESET =
d49 1
a49 1
    type Nameset = (Tyname list * Strname list)
d51 1
a51 1
    val empty_nameset = ([],[])
d53 3
a55 3
    fun member (m,[],_) = false
      | member (m,h::t,eqfun) = eqfun (m,h) orelse member (m,t,eqfun)
 
d57 1
a57 1
      member (tyname,tynames,Types.tyname_eq)
d64 1
a64 1
      member (strname,strnames,Strnames.strname_eq))
a65 6
    fun local_union ([],set,_) = set
      | local_union (h::t,set,eqfun) = 
	if member (h,set,eqfun) 
	  then local_union (t,set,eqfun)
	else local_union (t,h::set,eqfun)

d71 2
a72 2
      (local_union (tynames,tynames',Types.tyname_eq),
       local_union (strnames,strnames',Strnames.strname_eq)))
a73 6
    fun local_intersection ([],set,_) = []
      | local_intersection (set,[],_) = []
      | local_intersection (h::t,set,eqfun) =
	if member (h,set,eqfun) 
	  then h::local_intersection (t,set,eqfun)
	else local_intersection (t,set,eqfun)
d80 2
a81 2
      (local_intersection (tynames,tynames',Types.tyname_eq),
       local_intersection (strnames,strnames',Strnames.strname_eq)))
a82 4
    fun local_subset ([],_,_) = true
      | local_subset (h::t,set,eqfun) = 
	member (h,set,eqfun) andalso local_subset (t,set,eqfun)

d88 4
a91 7
      local_subset (tynames,tynames',Types.tyname_eq)
      andalso
      local_subset (tynames',tynames,Types.tyname_eq)
      andalso
      local_subset (strnames,strnames',Strnames.strname_eq)
      andalso
      local_subset (strnames',strnames,Strnames.strname_eq))
d93 1
a93 1
    fun no_tynames (tynames,_) = local_subset (tynames,[],Types.tyname_eq)
a94 3
    fun local_add_member (m,set,eqfun) = 
      if member (m,set,eqfun) then set else m::set

d96 1
a96 1
      (local_add_member (name,tynames,Types.tyname_eq),strnames)
d99 1
a99 1
	(tynames,local_add_member (name,strnames,Strnames.strname_eq))
d106 1
a106 1
      (local_union (tynames,tynames',Types.tyname_eq),strnames))
a107 6
    fun local_remove (m,[],_) = []
      | local_remove (m,h::t,eqfun) =
	if eqfun (m,h) 
	  then t 
	else h :: (local_remove (m,t,eqfun))

a112 6
    fun local_setdiff (set,[],_) = set
      | local_setdiff (set,h::t,eqfun) = 
	if member (h,set,eqfun) 
	  then local_setdiff (local_remove (h,set,eqfun),t,eqfun)
	else local_setdiff (set,t,eqfun)

d114 1
a114 1
      (local_remove (name,tynames,Types.tyname_eq),strnames)
d121 2
a122 2
	 (local_setdiff (tynames,tynames',Types.tyname_eq),
	  local_setdiff (strnames,strnames',Strnames.strname_eq)))
d125 9
a133 8
      add_tyname (Types.bool_tyname,
      add_tyname (Types.int_tyname,
      add_tyname (Types.real_tyname,
      add_tyname (Types.string_tyname,
      add_tyname (Types.list_tyname,
      add_tyname (Types.ref_tyname,
      add_tyname (Types.exn_tyname,
                  empty_nameset)))))))
d139 2
a140 8
      let
	fun string_tynames tynames = 
	  Set.set_print (Set.list_to_set (tynames),Types.print_name)
	fun string_strnames strnames =
	  Set.set_print (Set.list_to_set (strnames),Strnames.string_strname)
      in
	"{" ^ (string_tynames tynames) ^ "," ^ (string_strnames strnames) ^ "}"
      end
d166 2
d181 3
a183 1
	  ((tynames',strnames'),strname_copies',tyname_copies')
d194 2
d209 3
a211 1
	  ((tynames',strnames'),new_strnames',new_tynames')
d215 97
d315 5
a319 3
    fun tynames_of_nameset (tl,sl) = tl
    fun strnames_of_nameset (tl,sl) = sl
    fun nameset_of_name_lists (tl,sl) = (tl,sl)
@


1.3
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d168 4
a171 2
      add_tyname (Types.instream_tyname,
      add_tyname (Types.outstream_tyname,empty_nameset)))))))))
@


1.2
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_nameset.sml,v $
d12 5
a17 1
require "../typechecker/datatypes";
a19 2
require "../utils/set";
require "../utils/print";
d21 14
a34 10
functor Nameset (structure Datatypes : DATATYPES
		 structure Types : TYPES
		 structure Strnames : STRNAMES
		 structure Set : SET
		 structure Debug :  sig val set_debug_level : int -> unit
					val debug_level : unit -> int
				    end
		 structure Print : PRINT
		 sharing Datatypes = Types.Datatypes 
		   = Strnames.Datatypes) : NAMESET =
d39 1
d58 1
a58 1
      (if Debug.debug_level () > 5 then 
d71 1
a71 1
      (if Debug.debug_level () > 10 then 
d86 1
a86 1
      (if Debug.debug_level () > 10 then 
d98 1
a98 1
      (if Debug.debug_level () > 10 then 
d122 1
a122 1
      (if Debug.debug_level () > 10 then 
d149 1
a149 1
      (if Debug.debug_level () > 10 then 
d180 1
a180 1
	(if Debug.debug_level () > 10 then 
a249 2


@


1.1
log
@Initial revision
@
text
@d1 1
d3 5
a7 1
$Log$
@
