head	1.42;
access;
symbols
	MLW_daveb_inline_1_4_99:1.42.3
	MLWorks_21c0_1999_03_25:1.42
	MLWorks_20c1_1998_08_20:1.42
	MLWorks_20c0_1998_08_04:1.42
	MLWorks_20b2c2_1998_06_19:1.42
	MLWorks_20b2_Windows_1998_06_12:1.42
	MLWorks_20b1c1_1998_05_07:1.42
	MLWorks_20b0_1998_04_07:1.42
	MLWorks_20b0_1998_03_20:1.42
	MLWorks_20m2_1998_02_16:1.42
	MLWorks_20m1_1997_10_23:1.42
	MLWorks_11r1:1.41.1.1.1.1.1
	MLWorks_workspace_97:1.42.2
	MLWorks_dt_wizard:1.42.1
	MLWorks_11c0_1997_09_09:1.41.1.1.1.1
	MLWorks_10r3:1.41.1.1.3
	MLWorks_10r2_551:1.41.1.1.2
	MLWorks_11:1.41.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.41.1.1
	MLWorks_20m0_1997_06_20:1.42
	MLWorks_1_0_r2c2_1997_06_14:1.41.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.41.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.41.1
	MLWorks_BugFix_1997_04_24:1.41
	MLWorks_1_0_r2_Win32_1997_04_11:1.41
	MLWorks_1_0_r2_Unix_1997_04_04:1.41
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.40.6.1.1
	MLWorks_gui_1996_12_18:1.40.7
	MLWorks_1_0_Win32_1996_12_17:1.40.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.40.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.40.4.1
	MLWorks_1_0_Irix_1996_11_28:1.40.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.40.5
	MLWorks_1_0_Unix_1996_11_14:1.40.4
	MLWorks_Open_Beta2_1996_10_11:1.40.3
	MLWorks_License_dev:1.40.2
	MLWorks_1_open_beta_1996_09_13:1.40.1
	MLWorks_Open_Beta_1996_08_22:1.40
	MLWorks_Beta_1996_07_02:1.40
	MLWorks_Beta_1996_06_07:1.40
	MLWorks_Beta_1996_06_06:1.40
	MLWorks_Beta_1996_06_05:1.40
	MLWorks_Beta_1996_06_03:1.40
	MLWorks_Beta_1996_05_31:1.40
	MLWorks_Beta_1996_05_30:1.40
	ML_beta_release_12/08/94:1.32
	ML_beta_release_03/08/94:1.32
	ML_revised_beta_release_25/05/94:1.32
	ML_final_beta_release_02/03/94:1.32
	mlworks-28-01-1994:1.32
	Release:1.31
	mlworks-beta-01-09-1993:1.31
	MLWorks-1-0-4-29/01/1993:1.24
	MLWorks-1-0-3-21/12/1992:1.23
	MLWorks-1-0-2-15/12/1992:1.23
	MLWorks-1-0-1-04/12/1992:1.21
	checkpoint_17_08_92:1.12
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.42
date	97.05.01.12.54.47;	author jont;	state Exp;
branches
	1.42.1.1
	1.42.2.1
	1.42.3.1;
next	1.41;

1.41
date	96.12.18.16.37.57;	author andreww;	state Exp;
branches
	1.41.1.1;
next	1.40;

1.40
date	96.03.08.12.09.13;	author daveb;	state Exp;
branches
	1.40.1.1
	1.40.2.1
	1.40.3.1
	1.40.4.1
	1.40.5.1
	1.40.6.1
	1.40.7.1;
next	1.39;

1.39
date	96.03.08.12.09.13;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	95.12.27.11.37.13;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.08.18.09.19.35;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	95.07.20.14.10.15;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	95.07.13.12.36.58;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	95.02.07.11.54.59;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.10.13.10.39.08;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.09.16.13.51.10;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	93.04.21.10.36.22;	author matthew;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	93.04.20.17.04.36;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.04.05.11.53.53;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.03.02.15.36.59;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.03.01.11.02.11;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.02.25.16.02.19;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.02.19.11.30.36;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	92.12.22.15.57.54;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.12.07.11.28.35;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	92.12.04.19.46.19;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	92.12.03.13.20.21;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	92.10.30.15.46.28;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.10.27.19.16.51;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.10.02.16.04.06;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.09.09.11.48.01;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	92.09.09.11.34.38;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	92.08.27.20.07.55;	author davidt;	state Exp;
branches;
next	1.14;

1.14
date	92.08.27.14.35.30;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.08.18.16.07.41;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.08.11.16.23.22;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.08.06.17.40.35;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.07.28.13.29.01;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.07.27.14.00.47;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.07.16.19.05.08;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.05.05.10.58.25;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.04.15.15.13.04;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.03.09.11.06.41;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.02.11.11.32.41;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.01.27.20.15.53;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.19.17.29.24;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.38.51;	author colin;	state Exp;
branches;
next	;

1.31.1.1
date	93.04.21.10.36.22;	author jont;	state Exp;
branches;
next	;

1.40.1.1
date	96.09.13.11.41.12;	author hope;	state Exp;
branches;
next	;

1.40.2.1
date	96.10.07.16.34.14;	author hope;	state Exp;
branches;
next	;

1.40.3.1
date	96.10.17.11.53.22;	author hope;	state Exp;
branches;
next	;

1.40.4.1
date	96.11.14.13.20.57;	author hope;	state Exp;
branches
	1.40.4.1.1.1;
next	;

1.40.4.1.1.1
date	96.11.28.15.31.57;	author hope;	state Exp;
branches;
next	;

1.40.5.1
date	96.11.22.18.38.43;	author hope;	state Exp;
branches;
next	;

1.40.6.1
date	96.12.17.18.17.44;	author hope;	state Exp;
branches
	1.40.6.1.1.1;
next	;

1.40.6.1.1.1
date	97.02.24.12.11.59;	author hope;	state Exp;
branches;
next	;

1.40.7.1
date	96.12.18.10.13.00;	author hope;	state Exp;
branches;
next	;

1.41.1.1
date	97.05.12.10.51.19;	author hope;	state Exp;
branches
	1.41.1.1.1.1
	1.41.1.1.2.1
	1.41.1.1.3.1;
next	;

1.41.1.1.1.1
date	97.07.28.18.34.40;	author daveb;	state Exp;
branches
	1.41.1.1.1.1.1.1;
next	;

1.41.1.1.1.1.1.1
date	97.10.07.12.00.30;	author jkbrook;	state Exp;
branches;
next	;

1.41.1.1.2.1
date	97.09.08.17.27.34;	author daveb;	state Exp;
branches;
next	;

1.41.1.1.3.1
date	97.09.09.14.24.32;	author daveb;	state Exp;
branches;
next	;

1.42.1.1
date	97.09.10.19.43.28;	author brucem;	state Exp;
branches;
next	;

1.42.2.1
date	97.09.11.21.10.54;	author daveb;	state Exp;
branches;
next	;

1.42.3.1
date	99.04.01.18.09.09;	author daveb;	state Exp;
branches;
next	;


desc
@Functions ranging over Type Environments
@


1.42
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(*
$Log: _tyenv.sml,v $
 * Revision 1.41  1996/12/18  16:37:57  andreww
 * [Bug #1818]
 * Adding new floatarray type name.
 *
 * Revision 1.40  1996/03/08  12:09:13  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
 * Revision 1.38  1995/12/27  11:37:13  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.37  1995/08/18  09:19:35  daveb
Added types for different lengths of words, ints and reals.

Revision 1.36  1995/07/20  14:10:15  jont
Add word type

Revision 1.35  1995/07/13  12:36:58  jont
Add char type for new revised basis

Revision 1.34  1995/02/07  11:54:59  matthew
Removing debug structure

Revision 1.33  1994/10/13  10:39:08  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.32  1993/09/16  13:51:10  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.31  1993/04/21  10:36:22  matthew
The normal initial type environment now just contains
standard ML types.

Revision 1.30  1993/04/20  17:04:36  matthew
Rationalised the way the initial tyenv is constructed/

Revision 1.29  1993/04/05  11:53:53  matthew
Added Type type to initial tyenv

Revision 1.28  1993/03/02  15:36:59  matthew
empty_rec_type to empty_rectype

Revision 1.27  1993/03/01  11:02:11  matthew
Added vector and bytearray as built in types
/
 .

Revision 1.26  1993/02/25  16:02:19  matthew
Added array type to initial type environment

Revision 1.25  1993/02/19  11:30:36  matthew
Changed Conenv to Valenv
Moved enrichment code to _realise

Revision 1.24  1992/12/22  15:57:54  jont
Anel's last changes

Revision 1.23  1992/12/07  11:28:35  matthew
Changed error messages.

Revision 1.22  1992/12/04  19:46:19  matthew
Error message revisions.

Revision 1.21  1992/12/03  13:20:21  jont
Modified tyenv for efficiency

Revision 1.20  1992/10/30  15:46:28  jont
Added special maps for tyfun_id, tyname_id, strname_id

Revision 1.19  1992/10/27  19:16:51  jont
Modified to use less than functions for maps

Revision 1.18  1992/10/02  16:04:06  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.17  1992/09/09  11:48:01  matthew
Changed error message

Revision 1.16  1992/09/09  11:34:38  matthew
Trivial change to typescheme printing.

Revision 1.15  1992/08/27  20:07:55  davidt
Yet more changes to get structure copying working better.

Revision 1.14  1992/08/27  14:35:30  jont
Anel's changes - an attempt to get slightly better error messages.

Revision 1.13  1992/08/18  16:07:41  jont
Removed irrelevant handlers and new exceptions

Revision 1.12  1992/08/11  16:23:22  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.11  1992/08/06  17:40:35  jont
Anel's changes to use NewMap instead of Map

Revision 1.9  1992/07/27  14:00:47  jont
Improved enrichment efficiency

Revision 1.8  1992/07/16  19:05:08  jont
Changed to use btrees for renaming of tynames and strnames

Revision 1.7  1992/05/05  10:58:25  jont
Anel's fixes

Revision 1.6  1992/04/15  15:13:04  jont
Some improvements from Anel

Revision 1.5  1992/03/09  11:06:41  jont
Added require "tystr";

Revision 1.4  1992/02/11  11:32:41  clive
New pervasive library code - cut some things out of the initial type basis

Revision 1.3  1992/01/27  20:15:53  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.2  1991/11/19  17:29:24  jont
Fixed inexhaustive bindings

Revision 1.1  91/06/07  11:38:51  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/lists";
require "../utils/print";
require "../utils/crash";
require "../basics/identprint";
require "../typechecker/tyenv";
require "../typechecker/types";
require "../typechecker/valenv";
require "../typechecker/scheme";

functor Tyenv(
  structure Lists : LISTS
  structure IdentPrint : IDENTPRINT
  structure Types : TYPES
  structure Valenv : VALENV
  structure Scheme : TYPESCHEME
  structure Print : PRINT
  structure Crash : CRASH

  sharing Types.Datatypes = Valenv.Datatypes = Scheme.Datatypes
  sharing IdentPrint.Ident = Types.Datatypes.Ident
    ) : TYENV =
 
  struct
    structure Datatypes = Types.Datatypes

    open Datatypes

    (****
     Operations on the type environment.
     ****)

    exception LookupTyCon of Ident.TyCon

    val empty_tyenv = TE (NewMap.empty (Ident.tycon_lt, Ident.tycon_eq))

    fun lookup (TE amap, tycon) =
      case NewMap.tryApply' (amap, tycon) of
        SOME tystr => tystr
      | _ => raise LookupTyCon tycon

    fun te_plus_te (TE amap,TE amap') =
      TE (NewMap.union(amap, amap'))

    fun add_to_te (TE amap, tycon, tystr) = 
      TE (NewMap.define (amap,tycon,tystr))

    fun string_tyenv (TE amap) =
      let
	val tycon_length = ref 0

        val tycon_tystr_list = NewMap.to_list_ordered amap

	fun print_tycon tycon =
	  let 
	    val string_tycon = IdentPrint.printTyCon tycon
	    val tycon_size = size string_tycon
	  in
	    (tycon_length := tycon_size;
	     string_tycon)
	  end

        fun string_tystr (start,TYSTR (tyfun,conenv)) =
          let 
            val tyfun_string = Types.string_tyfun tyfun
            val conenv_string = Valenv.string_valenv (start + 
                                                      (size tyfun_string) + 8,
                                                      conenv)
          in
            "(" ^ tyfun_string ^ "," ^ conenv_string ^ ")\n"
          end
  
	fun str_tystr tystr = string_tystr (!tycon_length,tystr)

        fun print_pair ((object,image),print_object,print_image,connector) = 
          print_object object ^ connector ^ print_image image

      in
        Lists.to_string
        (fn (x,y) => print_pair ((x,y),IdentPrint.printTyCon,
                                 fn tystr => (string_tystr (!tycon_length,tystr)),
                                 " |==> "))
        tycon_tystr_list
      end

    fun empty_tyenvp (TE amap) = NewMap.is_empty amap

    (****
     Used during copying of a signature before the signature is matched to 
     a structure.
     ****)

    fun tystr_copy (TYSTR (tyfun,conenv), tyname_copies) = 
      TYSTR(Types.tyfun_copy (tyfun,tyname_copies), Valenv.ve_copy(conenv,tyname_copies))

    fun te_copy (TE amap,tyname_copies) = 
      let
	fun copy (_, tystr) = tystr_copy (tystr, tyname_copies)
      in
	TE(NewMap.map copy amap)
      end

    local
      fun atyvar (id,eq,imp) =
	TYVAR (ref (0,NULLTYPE,NO_INSTANCE),
               Ident.TYVAR (Ident.Symbol.find_symbol (id),eq,imp))
      fun do_one (te,(id,tystr)) = add_to_te (te,id,tystr)
    in
      val basic_te =
        Lists.reducel
        do_one
        (empty_tyenv,
         [(Ident.TYCON (Ident.Symbol.find_symbol ("int")),
           TYSTR (Types.make_eta_tyfun (Types.int_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("word")),
           TYSTR (Types.make_eta_tyfun (Types.word_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("real")),
           TYSTR (Types.make_eta_tyfun (Types.real_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("string")),
           TYSTR (Types.make_eta_tyfun (Types.string_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("char")),
           TYSTR (Types.make_eta_tyfun (Types.char_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("ref")),
           let
             val aty = atyvar ("'_a",false,true)
           in
             TYSTR (Types.make_eta_tyfun (Types.ref_tyname),
                    let 
                      val valenv =
                        Valenv.add_to_ve
                        (Ident.CON (Ident.Symbol.find_symbol ("ref")),
                         Scheme.make_scheme
                         ([aty],
                          (FUNTYPE (aty,CONSTYPE([aty],
                                                Types.ref_tyname)),NONE)),
                         empty_valenv)
                      val valenvref = case Types.ref_tyname of
                        TYNAME {5=valenvref,...} => valenvref
                      | _ => Crash.impossible"Types.ref_tyname bad"
                    in
                      (valenvref := valenv ; valenv)
                    end)
           end), 
          (Ident.TYCON (Ident.Symbol.find_symbol ("exn")),
           TYSTR (Types.make_eta_tyfun (Types.exn_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("list")),
           let
             val aty = atyvar ("'a",false,false)
           in
             TYSTR (Types.make_eta_tyfun (Types.list_tyname),
                    let 
                      val valenv =
                        Valenv.add_to_ve
                        (Ident.CON (Ident.Symbol.find_symbol ("nil")),
                         Scheme.make_scheme
                         ([aty],(CONSTYPE ([aty],Types.list_tyname),
                                 NONE)),
                         Valenv.add_to_ve
                         (Ident.CON (Ident.Symbol.find_symbol ("::")),
                          Scheme.make_scheme
                          ([aty],(FUNTYPE
                           (Types.add_to_rectype
                            (Ident.LAB 
                             (Ident.Symbol.find_symbol ("1")),aty,
                             Types.add_to_rectype
                             (Ident.LAB (Ident.Symbol.find_symbol ("2")),
                              CONSTYPE ([aty],Types.list_tyname),
                              Types.empty_rectype)),
                            CONSTYPE ([aty],Types.list_tyname)),NONE)),
                          empty_valenv))
                      val valenvref = case Types.list_tyname of
                        TYNAME {5=valenvref,...} => valenvref
                      | _ => Crash.impossible"Types.list_tyname bad"
                    in
                      (valenvref := valenv ; valenv)
                    end)
           end),
          (Ident.TYCON (Ident.Symbol.find_symbol ("bool")),
           TYSTR (Types.make_eta_tyfun (Types.bool_tyname),
                  let 
                    val valenv = 
                      Valenv.add_to_ve
                      (Ident.CON (Ident.Symbol.find_symbol ("true")),
                       Scheme.make_scheme
                       ([],(CONSTYPE ([],Types.bool_tyname),NONE)),
                       Valenv.add_to_ve
                       (Ident.CON (Ident.Symbol.find_symbol ("false")),
                        Scheme.make_scheme
                        ([],(CONSTYPE ([],Types.bool_tyname),NONE)),  
                        empty_valenv))
                    val valenvref = case Types.bool_tyname of
                      TYNAME {5=valenvref,...} => valenvref
                    | _ => Crash.impossible"Types.bool_tyname bad"
                  in
                    (valenvref := valenv ; valenv)
                  end)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("unit")),
           TYSTR (Types.make_tyfun ([],Types.empty_rectype),
                  empty_valenv))])

      val initial_te_for_builtin_library =
        Lists.reducel
        do_one
        (basic_te,
         [(Ident.TYCON (Ident.Symbol.find_symbol "type_rep"),
           TYSTR (Types.make_eta_tyfun (Types.typerep_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol "vector"),
           TYSTR (Types.make_eta_tyfun (Types.vector_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol "bytearray"),
           TYSTR (Types.make_eta_tyfun (Types.bytearray_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol "floatarray"),
           TYSTR (Types.make_eta_tyfun (Types.floatarray_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol "array"),
           TYSTR (Types.make_eta_tyfun (Types.array_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("dynamic")),
           TYSTR (Types.make_eta_tyfun (Types.dynamic_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("int8")),
           TYSTR (Types.make_eta_tyfun (Types.int8_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("word8")),
           TYSTR (Types.make_eta_tyfun (Types.word8_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("int16")),
           TYSTR (Types.make_eta_tyfun (Types.int16_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("word16")),
           TYSTR (Types.make_eta_tyfun (Types.word16_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("int32")),
           TYSTR (Types.make_eta_tyfun (Types.int32_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("word32")),
           TYSTR (Types.make_eta_tyfun (Types.word32_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("int64")),
           TYSTR (Types.make_eta_tyfun (Types.int64_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("word64")),
           TYSTR (Types.make_eta_tyfun (Types.word64_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("float32")),
           TYSTR (Types.make_eta_tyfun (Types.float32_tyname),
                  empty_valenv)),
          (Ident.TYCON (Ident.Symbol.find_symbol ("ml_value")),
           TYSTR (Types.make_eta_tyfun (Types.ml_value_tyname),
                  empty_valenv))])

      val initial_te = basic_te 
    end
end
@


1.42.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.42  1997/05/01  12:54:47  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.42.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.42  1997/05/01  12:54:47  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.42.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.42  1997/05/01  12:54:47  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.41
log
@[Bug #1818]
Adding new floatarray type name.
@
text
@d3 4
d167 1
a167 1
        MLWorks.Option.SOME tystr => tystr
d268 1
a268 1
                                                Types.ref_tyname)),MLWorks.Option.NONE)),
d291 1
a291 1
                                 MLWorks.Option.NONE)),
d303 1
a303 1
                            CONSTYPE ([aty],Types.list_tyname)),MLWorks.Option.NONE)),
d319 1
a319 1
                       ([],(CONSTYPE ([],Types.bool_tyname),MLWorks.Option.NONE)),
d323 1
a323 1
                        ([],(CONSTYPE ([],Types.bool_tyname),MLWorks.Option.NONE)),  
@


1.41.1.1
log
@branched from 1.41
@
text
@a2 4
 * Revision 1.41  1996/12/18  16:37:57  andreww
 * [Bug #1818]
 * Adding new floatarray type name.
 *
@


1.41.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.41.1.1  1997/05/12  10:51:19  hope
 * branched from 1.41
 *
@


1.41.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.41.1.1  1997/05/12  10:51:19  hope
 * branched from 1.41
 *
@


1.41.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.41.1.1  1997/05/12  10:51:19  hope
 * branched from 1.41
 *
@


1.41.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.41.1.1.1.1  1997/07/28  18:34:40  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.40
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@d3 3
d343 3
@


1.40.7.1
log
@branched from 1.40
@
text
@a2 3
 * Revision 1.40  1996/03/08  12:09:13  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
@


1.40.6.1
log
@branched from 1.40
@
text
@a2 3
 * Revision 1.40  1996/03/08  12:09:13  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
@


1.40.6.1.1.1
log
@branched from 1.40.6.1
@
text
@a2 3
 * Revision 1.40.6.1  1996/12/17  18:17:44  hope
 * branched from 1.40
 *
@


1.40.5.1
log
@branched from 1.40
@
text
@a2 3
 * Revision 1.40  1996/03/08  12:09:13  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
@


1.40.4.1
log
@branched from 1.40
@
text
@a2 3
 * Revision 1.40  1996/03/08  12:09:13  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
@


1.40.4.1.1.1
log
@branched from 1.40.4.1
@
text
@a2 3
 * Revision 1.40.4.1  1996/11/14  13:20:57  hope
 * branched from 1.40
 *
@


1.40.3.1
log
@branched from 1.40
@
text
@a2 3
 * Revision 1.40  1996/03/08  12:09:13  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
@


1.40.2.1
log
@branched from 1.40
@
text
@a2 3
 * Revision 1.40  1996/03/08  12:09:13  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
@


1.40.1.1
log
@branched from 1.40
@
text
@a2 3
 * Revision 1.40  1996/03/08  12:09:13  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
@


1.39
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@@


1.38
log
@Removing Option in favour of MLWorks.Option
@
text
@d3 3
d332 2
a333 2
         [(Ident.TYCON (Ident.Symbol.find_symbol "Type"),
           TYSTR (Types.make_eta_tyfun (Types.type_tyname),
d344 1
a344 1
          (Ident.TYCON (Ident.Symbol.find_symbol ("Dynamic")),
@


1.37
log
@Added types for different lengths of words, ints and reals.
@
text
@d3 3
d258 1
a258 1
                                                Types.ref_tyname)),Option.ABSENT)),
d281 1
a281 1
                                 Option.ABSENT)),
d293 1
a293 1
                            CONSTYPE ([aty],Types.list_tyname)),Option.ABSENT)),
d309 1
a309 1
                       ([],(CONSTYPE ([],Types.bool_tyname),Option.ABSENT)),
d313 1
a313 1
                        ([],(CONSTYPE ([],Types.bool_tyname),Option.ABSENT)),  
@


1.36
log
@Add word type
@
text
@d3 3
d231 3
a242 3
          (Ident.TYCON (Ident.Symbol.find_symbol ("word")),
           TYSTR (Types.make_eta_tyfun (Types.word_tyname),
                  empty_valenv)),
d341 27
d372 1
a372 1
      val initial_te = basic_te (* initial_te_for_builtin_library *)
@


1.35
log
@Add char type for new revised basis
@
text
@d3 3
d236 3
@


1.34
log
@Removing debug structure
@
text
@d3 3
d230 3
@


1.33
log
@Use pervasive Option.option for return values in NewMap
@
text
@d3 3
a111 2
require "../typechecker/ty_debug";
require "../typechecker/tystr";
a119 1
  structure TyDebug : TY_DEBUG
a122 6
  structure Tystr : TYSTR
  structure Debug :
	      sig
		val set_debug_level : int -> unit
		val debug_level : unit -> int
	      end
d126 1
a126 2
  sharing Tystr.Datatypes = Types.Datatypes
    = Valenv.Datatypes = Scheme.Datatypes
a134 2
    val do_debug = TyDebug.do_debug

d139 1
a139 1
    exception Lookup_in_TE = NewMap.Undefined
d144 3
a146 11
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("tycon lookup \n");
	       Print.print (IdentPrint.printTyCon tycon);
	       Print.print ("\n"))
       else ();
	 NewMap.apply'(amap, tycon))

    fun member_of_te_domain (TE amap, tycon) = 
      (case NewMap.tryApply'(amap, tycon) of
	 MLWorks.Option.NONE => false
       | _ => true)
d169 11
a179 1
	fun str_tystr tystr = Tystr.string_tystr (!tycon_length,tystr)
d187 1
a187 2
                                 fn tystr => (Tystr.string_tystr 
                                              (!tycon_length,tystr)),
a191 2
    fun te_domain (TE amap) = NewMap.domain amap

d199 3
d204 1
a204 1
	fun copy (_, tystr) = Tystr.tystr_copy (tystr, tyname_copies)
@


1.32
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d3 3
d162 1
a162 1
	 NewMap.NO => false
@


1.31
log
@The normal initial type environment now just contains
standard ML types.
@
text
@d3 4
d215 2
a216 1
	TYVAR (ref 0,Ident.TYVAR (Ident.Symbol.find_symbol (id),eq,imp))
d243 2
a244 2
                          FUNTYPE (aty,CONSTYPE([aty],
                                                Types.ref_tyname))),
d266 2
a267 1
                         ([aty],CONSTYPE ([aty],Types.list_tyname)),
d271 1
a271 1
                          ([aty],FUNTYPE
d279 1
a279 1
                            CONSTYPE ([aty],Types.list_tyname))),
d295 1
a295 1
                       ([],CONSTYPE ([],Types.bool_tyname)),
d299 1
a299 1
                        ([],CONSTYPE ([],Types.bool_tyname)),  
@


1.31.1.1
log
@Fork for bug fixing
@
text
@a2 4
Revision 1.31  1993/04/21  10:36:22  matthew
The normal initial type environment now just contains
standard ML types.

@


1.30
log
@Rationalised the way the initial tyenv is constructed/
@
text
@d3 3
d328 1
a328 1
      val initial_te = initial_te_for_builtin_library
@


1.29
log
@Added Type type to initial tyenv
@
text
@d3 3
d209 1
d211 91
d303 21
a323 119
	add_to_te
	(add_to_te
	 (add_to_te
	  (add_to_te
	   (add_to_te
	    (add_to_te
	     (add_to_te
	      (add_to_te
	       (add_to_te
		(add_to_te
                 (add_to_te
                  (add_to_te
                   (add_to_te
                    (add_to_te
                     (empty_tyenv,
                      Ident.TYCON (Ident.Symbol.find_symbol "Type"),
                      TYSTR (Types.make_eta_tyfun (Types.type_tyname),
                             empty_valenv)),
                     Ident.TYCON (Ident.Symbol.find_symbol "vector"),
                     TYSTR (Types.make_eta_tyfun (Types.vector_tyname),
                            empty_valenv)),
                    Ident.TYCON (Ident.Symbol.find_symbol "bytearray"),
                    TYSTR (Types.make_eta_tyfun (Types.bytearray_tyname),
                           empty_valenv)),
                   Ident.TYCON (Ident.Symbol.find_symbol "array"),
                   TYSTR (Types.make_eta_tyfun (Types.array_tyname),
                          empty_valenv)),
                  Ident.TYCON (Ident.Symbol.find_symbol ("Dynamic")),
                  TYSTR (Types.make_eta_tyfun (Types.dynamic_tyname),
                         empty_valenv)),
		 Ident.TYCON (Ident.Symbol.find_symbol ("ml_value")),
		 TYSTR (Types.make_eta_tyfun (Types.ml_value_tyname),
			empty_valenv)),
		Ident.TYCON (Ident.Symbol.find_symbol ("int")),
		TYSTR (Types.make_eta_tyfun (Types.int_tyname),
		       empty_valenv)),
	       Ident.TYCON (Ident.Symbol.find_symbol ("real")),
	       TYSTR (Types.make_eta_tyfun (Types.real_tyname),
		      empty_valenv)),
	      Ident.TYCON (Ident.Symbol.find_symbol ("string")),
	      TYSTR (Types.make_eta_tyfun (Types.string_tyname),
		     empty_valenv)),
	     Ident.TYCON (Ident.Symbol.find_symbol ("ref")),
	     let
	       val aty = atyvar ("'_a",false,true)
	     in
	       TYSTR (Types.make_eta_tyfun (Types.ref_tyname),
		      let 
			val valenv =
			  Valenv.add_to_ve
			  (Ident.CON (Ident.Symbol.find_symbol ("ref")),
			   Scheme.make_scheme
			   ([aty],
			    FUNTYPE (aty,CONSTYPE([aty],
						  Types.ref_tyname))),
			   empty_valenv)
			val valenvref = case Types.ref_tyname of
			  TYNAME {5=valenvref,...} => valenvref
			| _ => Crash.impossible"Types.ref_tyname bad"
		      in
			(valenvref := valenv ; valenv)
		      end)
	     end), 
	    Ident.TYCON (Ident.Symbol.find_symbol ("exn")),
	    TYSTR (Types.make_eta_tyfun (Types.exn_tyname),
		   empty_valenv)),
	   Ident.TYCON (Ident.Symbol.find_symbol ("list")),
	   let
	     val aty = atyvar ("'a",false,false)
	   in
	     TYSTR (Types.make_eta_tyfun (Types.list_tyname),
		    let 
		      val valenv =
			Valenv.add_to_ve
			(Ident.CON (Ident.Symbol.find_symbol ("nil")),
			 Scheme.make_scheme
			 ([aty],CONSTYPE ([aty],Types.list_tyname)),
			 Valenv.add_to_ve
			 (Ident.CON (Ident.Symbol.find_symbol ("::")),
			  Scheme.make_scheme
			  ([aty],FUNTYPE
			   (Types.add_to_rectype
			    (Ident.LAB 
			     (Ident.Symbol.find_symbol ("1")),aty,
			     Types.add_to_rectype
			     (Ident.LAB (Ident.Symbol.find_symbol ("2")),
			      CONSTYPE ([aty],Types.list_tyname),
			      Types.empty_rectype)),
			    CONSTYPE ([aty],Types.list_tyname))),
			  empty_valenv))
		      val valenvref = case Types.list_tyname of
			TYNAME {5=valenvref,...} => valenvref
		      | _ => Crash.impossible"Types.list_tyname bad"
		    in
		      (valenvref := valenv ; valenv)
		    end)
	   end),
	  Ident.TYCON (Ident.Symbol.find_symbol ("bool")),
	  TYSTR (Types.make_eta_tyfun (Types.bool_tyname),
		 let 
		   val valenv = 
		     Valenv.add_to_ve
		     (Ident.CON (Ident.Symbol.find_symbol ("true")),
		      Scheme.make_scheme
		      ([],CONSTYPE ([],Types.bool_tyname)),
		      Valenv.add_to_ve
		      (Ident.CON (Ident.Symbol.find_symbol ("false")),
		       Scheme.make_scheme
		       ([],CONSTYPE ([],Types.bool_tyname)),  
		       empty_valenv))
		   val valenvref = case Types.bool_tyname of
		     TYNAME {5=valenvref,...} => valenvref
		   | _ => Crash.impossible"Types.bool_tyname bad"
		 in
		   (valenvref := valenv ; valenv)
		 end)),
	 Ident.TYCON (Ident.Symbol.find_symbol ("unit")),
	 TYSTR (Types.make_tyfun ([],Types.empty_rectype),
		empty_valenv))
a325 1

@


1.28
log
@empty_rec_type to empty_rectype
@
text
@d3 3
d221 5
a225 1
                    (empty_tyenv,
@


1.27
log
@Added vector and bytearray as built in types
/
 .
@
text
@d3 5
d288 1
a288 1
			      Types.empty_rec_type)),
d318 1
a318 1
	 TYSTR (Types.make_tyfun ([],Types.empty_rec_type),
@


1.26
log
@Added array type to initial type environment
@
text
@d3 3
d211 9
a219 1
                  (empty_tyenv,
@


1.25
log
@Changed Conenv to Valenv
Moved enrichment code to _realise
@
text
@d3 4
d207 5
a211 1
                 (empty_tyenv,
@


1.24
log
@Anel's last changes
@
text
@d3 3
d93 1
a93 1
  structure Conenv : VALENV
d105 1
a105 1
    = Conenv.Datatypes = Scheme.Datatypes
a120 1
    exception EnrichError of string
a171 38
    (****
     Enrichment test for type environments.
     ****)

    fun te_ran_enriches (TE amap,TE amap') =
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("te_ran_enriches");
	       Print.print ("\n"))
       else ();
      let 
	fun ran_enriches(res,tycon,tystr) =
	  res andalso
	  let
	    val tystr' = NewMap.apply'(amap', tycon)
	      handle NewMap.Undefined => 
                (* this is caught by realise I think *)
		raise EnrichError ("Unmatched type specification : " ^
				   (IdentPrint.printTyCon tycon) ^ "\n")
	  in
	    (((Tystr.tystr_enriches (tystr,tystr'))
              handle Tystr.TyfunError =>
                (* think this is caught in realise *)
                raise EnrichError 
                  ("Type clash in type " ^ IdentPrint.printTyCon tycon))
	     handle Tystr.TypeDiffer => 
               raise EnrichError
	         ("Value constructor(s) of type " ^ 
                  IdentPrint.printTyCon tycon ^
                  " does not match signature specification:" ^
                  "\n    spec : " ^
	          (Conenv.string_valenv (11,(Tystr.get_ce (tystr)))) ^
	          "\n    actual : " ^
	          (Conenv.string_valenv (13,(Tystr.get_ce tystr')))))
	  end
      in
	NewMap.fold ran_enriches(true, amap)
      end)

d202 5
a206 1
		(empty_tyenv,
d226 1
a226 1
			  Conenv.add_to_ve
d250 1
a250 1
			Conenv.add_to_ve
d254 1
a254 1
			 Conenv.add_to_ve
d278 1
a278 1
		     Conenv.add_to_ve
d282 1
a282 1
		      Conenv.add_to_ve
@


1.23
log
@Changed error messages.
@
text
@d3 3
d194 1
a194 1
	     handle Tystr.Inconsistent => 
d196 4
a199 3
	         ("Datatype " ^ IdentPrint.printTyCon tycon ^
                  " has inconsistent constructors:" ^
                  "\n    Spec : " ^
d201 1
a201 1
	          "\n    Actual : " ^
a202 9
(*
	    if Tystr.tystr_enriches (tystr,tystr') then
	      true
	    else raise EnrichError
	      ("\n    spec : " ^
	       (Conenv.string_valenv (13,(Tystr.get_ce (tystr)))) ^
	       "\n    actual : " ^
	       (Conenv.string_valenv (15,(Tystr.get_ce tystr'))))
*)
@


1.22
log
@Error message revisions.
@
text
@d3 3
d190 1
a190 1
                  ("type clash in type " ^ IdentPrint.printTyCon tycon))
d193 1
a193 1
	         ("datatype " ^ IdentPrint.printTyCon tycon ^
d195 1
a195 1
                  "\n    spec : " ^
d197 1
a197 1
	          "\n    actual : " ^
@


1.21
log
@Modified tyenv for efficiency
@
text
@d3 3
d179 1
d185 1
@


1.20
log
@Added special maps for tyfun_id, tyname_id, strname_id
@
text
@d3 3
d113 1
a113 1
    fun lookup (tycon,TE amap) =
d121 1
a121 1
    fun member_of_te_domain (tycon,TE amap) = 
d129 1
a129 1
    fun add_to_te (tycon,tystr,TE amap) = 
d226 93
a318 14
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("ml_value")),
                 TYSTR (Types.make_eta_tyfun (Types.ml_value_tyname),
                        empty_valenv),
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("int")),
		 TYSTR (Types.make_eta_tyfun (Types.int_tyname),
			empty_valenv),
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("real")),
		 TYSTR (Types.make_eta_tyfun (Types.real_tyname),
			empty_valenv),
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("string")),
		 TYSTR (Types.make_eta_tyfun (Types.string_tyname),
			empty_valenv),
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("ref")),
		 let val aty = atyvar ("'_a",false,true)
d320 5
a324 73
		   TYSTR (Types.make_eta_tyfun (Types.ref_tyname),
			  let 
			    val valenv =
			      Conenv.add_to_ve
			      (Ident.CON (Ident.Symbol.find_symbol ("ref")),
			       Scheme.make_scheme
			       ([aty],
				FUNTYPE (aty,CONSTYPE([aty],
						      Types.ref_tyname))),
			       empty_valenv)
			    val valenvref = case Types.ref_tyname of
			      TYNAME {5=valenvref,...} => valenvref
			    | _ => Crash.impossible"Types.ref_tyname bad"
			  in
			    (valenvref := valenv ; valenv)
			  end)
		 end, 
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("exn")),
		 TYSTR (Types.make_eta_tyfun (Types.exn_tyname),
			empty_valenv),
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("list")),
		 let val aty = atyvar ("'a",false,false)
		 in
		   TYSTR (Types.make_eta_tyfun (Types.list_tyname),
			  let 
			    val valenv =
			      Conenv.add_to_ve
			      (Ident.CON (Ident.Symbol.find_symbol ("nil")),
			       Scheme.make_scheme
			       ([aty],CONSTYPE ([aty],Types.list_tyname)),
			       Conenv.add_to_ve
			       (Ident.CON (Ident.Symbol.find_symbol ("::")),
				Scheme.make_scheme
				([aty],FUNTYPE
				 (Types.add_to_rectype
				  (Ident.LAB 
				   (Ident.Symbol.find_symbol ("1")),aty,
				   Types.add_to_rectype
				   (Ident.LAB (Ident.Symbol.find_symbol ("2")),
				    CONSTYPE ([aty],Types.list_tyname),
				    Types.empty_rec_type)),
				  CONSTYPE ([aty],Types.list_tyname))),
				empty_valenv))
			    val valenvref = case Types.list_tyname of
			      TYNAME {5=valenvref,...} => valenvref
			    | _ => Crash.impossible"Types.list_tyname bad"
			  in
			    (valenvref := valenv ; valenv)
			  end)
		 end,  
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("bool")),
		 TYSTR (Types.make_eta_tyfun (Types.bool_tyname),
			let 
			  val valenv = 
			    Conenv.add_to_ve
			    (Ident.CON (Ident.Symbol.find_symbol ("true")),
			     Scheme.make_scheme
			     ([],CONSTYPE ([],Types.bool_tyname)),
			     Conenv.add_to_ve
			     (Ident.CON (Ident.Symbol.find_symbol ("false")),
			      Scheme.make_scheme
			      ([],CONSTYPE ([],Types.bool_tyname)),  
			      empty_valenv))
			  val valenvref = case Types.bool_tyname of
			    TYNAME {5=valenvref,...} => valenvref
			  | _ => Crash.impossible"Types.bool_tyname bad"
			in
			  (valenvref := valenv ; valenv)
			end),
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("unit")),
		 TYSTR (Types.make_tyfun ([],Types.empty_rec_type),
			empty_valenv),
		 empty_tyenv)))))))))
@


1.19
log
@Modified to use less than functions for maps
@
text
@d3 3
d119 3
a121 2
      (NewMap.apply'(amap, tycon);
       true) handle NewMap.Undefined => false
@


1.18
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d3 3
d105 1
a105 1
    val empty_tyenv = TE (NewMap.empty (tycon_order,tycon_equal))
@


1.17
log
@Changed error message
@
text
@d3 3
d102 1
a102 1
    val empty_tyenv = TE (NewMap.empty tycon_order)
@


1.16
log
@Trivial change to typescheme printing.
@
text
@d3 3
d172 2
a173 1
	         ("type " ^ IdentPrint.printTyCon tycon ^
@


1.15
log
@Yet more changes to get structure copying working better.
@
text
@d3 3
d171 1
a171 1
	          (Conenv.string_valenv (13,(Tystr.get_ce (tystr)))) ^
d173 1
a173 1
	          (Conenv.string_valenv (15,(Tystr.get_ce tystr')))))
@


1.14
log
@Anel's changes - an attempt to get slightly better error messages.
@
text
@d3 3
d194 1
a194 1
    fun te_copy (TE amap,tyname_copies,tynamecopy_fun) = 
d196 1
a196 7
	fun copy_tyenvs((te, tyname_copies), tycon,tystr) = 
	  let
	    val (tystr',tyname_copies') = 
	      Tystr.tystr_copy (tystr,tyname_copies,tynamecopy_fun)
	  in
	    (add_to_te(tycon,tystr',te),tyname_copies')
	  end
d198 1
a198 1
	NewMap.fold copy_tyenvs ((empty_tyenv, tyname_copies), amap)
@


1.13
log
@Removed irrelevant handlers and new exceptions
@
text
@d3 3
d157 12
d176 1
@


1.12
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d3 4
d84 1
a84 1
    exception Lookup_in_TE
d95 1
a95 2
	 NewMap.apply'(amap, tycon) 
	 handle NewMap.Undefined => raise Lookup_in_TE)
@


1.11
log
@Anel's changes to use NewMap instead of Map
@
text
@d3 3
a37 1
require "../utils/newmap";
d40 1
a41 1
require "../typechecker/datatypes";
d49 2
a50 1
  structure NewMap : NEWMAP
a51 1
  structure Datatypes : DATATYPES
a55 1
  structure Lists : LISTS
d64 1
a64 1
  sharing Datatypes = Tystr.Datatypes = Types.Datatypes
d66 1
a66 1
  sharing NewMap = Tystr.NewMap
d70 1
a70 2
    structure NewMap = NewMap
    structure Datatypes = Datatypes
d91 1
a91 1
	 NewMap.apply amap tycon 
d95 2
a96 1
      Lists.member (tycon,NewMap.domain amap)
d99 1
a99 7
      let 
        val tycon_tystr_list' = NewMap.to_list amap'
      in
        TE (Lists.reducel
            (fn (tree,(tycon,tystr)) => NewMap.define (tree,tycon,tystr))
            (amap,tycon_tystr_list'))
      end
d128 1
a128 1
                                              (!tycon_length,tystr)) ^ "\n",
d143 16
a158 17
	val tycon_tystr_list = NewMap.to_list_ordered amap
	fun ran_enriches [] = true
	  | ran_enriches ((tycon,tystr)::tycon_tystrs) =  
            let 
              val tystr' = NewMap.apply amap' tycon
                handle NewMap.Undefined => 
                  raise EnrichError ("Unmatched type specification : " ^
                                     (IdentPrint.printTyCon tycon) ^ "\n")
            in
              if Tystr.tystr_enriches (tystr,tystr')
	        then ran_enriches tycon_tystrs
	      else raise EnrichError
	        ("\n    spec : " ^
	         (Conenv.string_valenv (13,(Tystr.get_ce (tystr)))) ^
	         "\n    actual : " ^
	         (Conenv.string_valenv (15,(Tystr.get_ce tystr'))))
            end
d160 1
a160 1
	ran_enriches tycon_tystr_list
d174 7
a180 11
	val tycon_tystr_list = NewMap.to_list amap
	fun copy_tyenvs ([],tyname_copies,te,_) = (te,tyname_copies)
	  | copy_tyenvs ((tycon,tystr)::tycon_tystrs,tyname_copies,te,
                         tynamecopy_fun) = 
	    let 
	      val (tystr',tyname_copies') = 
                Tystr.tystr_copy (tystr,tyname_copies,tynamecopy_fun)
	    in
	      copy_tyenvs (tycon_tystrs,tyname_copies',
                           add_to_te (tycon,tystr',te),tynamecopy_fun)
	    end
d182 1
a182 1
	copy_tyenvs (tycon_tystr_list,tyname_copies,empty_tyenv,tynamecopy_fun)
@


1.10
log
@Added an opaque type ml_value to the environment of the builtin
library.
@
text
@d48 1
a48 1
  structure Ty_Debug : TY_DEBUG
a71 1
    val do_debug = Ty_Debug.do_debug
d74 2
d83 1
a83 1
    val empty_tyenv = TE (Mapping.empty_map)
d85 1
a85 1
    fun lookup (tycon,TE (tyenv)) =
d91 2
a92 2
	 Mapping.lookup (tycon,tyenv) 
	 handle Mapping.Lookup => raise Lookup_in_TE)
d95 1
a95 1
      Mapping.domain_member (tycon,amap)
d97 8
a104 2
    fun te_plus_te (TE (tyenv),TE (tyenv')) =
      TE (Mapping.plus (tyenv,tyenv',Ident.tycon_order))
d106 2
a107 2
    fun add_to_te (tycon,tystr,TE (tyenv)) = 
      TE (Mapping.add ((tycon,tystr),tyenv,Ident.tycon_order)) 
d112 4
a115 1
	fun print_tycon (atycon) =
d117 1
a117 1
	    val string_tycon = (IdentPrint.printTyCon atycon)
d123 6
a128 2
	fun str_tystr (atystr) = Tystr.string_tystr(!tycon_length,atystr)
	val map_string = Mapping.print_map(amap,print_tycon,str_tystr," |==> ")
d130 6
a135 1
	map_string
d148 1
a148 1
	val tycon_tystr_list = Mapping.assoc amap
d152 2
a153 2
              val tystr' = Mapping.lookup (tycon,amap')
                handle Mapping.Lookup => 
d169 1
a169 1
    fun te_domain (TE amap) = Mapping.domain amap
d171 1
a171 1
    fun empty_tyenvp (TE amap) = Mapping.emptymap_p amap
d180 1
a180 1
	val tycon_tystr_list = Mapping.assoc amap
d202 1
a202 1
                        Conenv.empty_valenv),
d205 1
a205 1
			Conenv.empty_valenv),
d208 1
a208 1
			Conenv.empty_valenv),
d211 1
a211 1
			Conenv.empty_valenv),
d224 1
a224 1
			       Conenv.empty_valenv)
d234 1
a234 1
			Conenv.empty_valenv),
d257 1
a257 1
				Conenv.empty_valenv))
d277 1
a277 1
			      Conenv.empty_valenv))
d286 1
a286 1
			Conenv.empty_valenv),
@


1.9
log
@Improved enrichment efficiency
@
text
@d3 3
d181 3
d268 1
a268 1
		 empty_tyenv))))))))
@


1.8
log
@Changed to use btrees for renaming of tynames and strnames
@
text
@d3 3
d126 1
a126 1
	val tycon_tystr_list = Mapping.assoc amap'
d128 15
a142 17
	  | ran_enriches ((tycon,tystr')::tycon_tystrs) =  
	    if Mapping.domain_member (tycon,amap)
	      then 
                let
		  val tystr = Mapping.lookup (tycon,amap)
	         in 
		   (if Tystr.tystr_enriches (tystr,tystr') 
		      then true
		    else raise EnrichError
	              ("\n    spec : " ^
		       (Conenv.string_valenv (13,(Tystr.get_ce (tystr)))) ^
			"\n    actual : " ^
			(Conenv.string_valenv (15,(Tystr.get_ce (tystr'))))))
		   andalso ran_enriches tycon_tystrs
		 end
	    else
	      ran_enriches tycon_tystrs
@


1.7
log
@Anel's fixes
@
text
@d3 3
d29 1
d41 1
d58 3
a60 1
    = Conenv.Datatypes = Scheme.Datatypes) : TYENV =
d63 1
@


1.6
log
@Some improvements from Anel
@
text
@d3 3
d115 17
a131 18
	val domain = Mapping.domain (amap')
	fun ran_enriches ([],amap,amap') = true
	  | ran_enriches (h::t,amap,amap') =  
	    if Lists.member (h,Mapping.domain amap)
	      then let
		     val tystr = Mapping.lookup (h,amap)
		     val tystr' = Mapping.lookup (h,amap')
		   in 
		     (if Tystr.tystr_enriches (tystr,tystr') 
			then true
		      else raise EnrichError
			("\n    spec : " ^
			 (Conenv.string_valenv (13,(Tystr.get_ce (tystr)))) ^
			 "\n    actual : " ^
			 (Conenv.string_valenv (15,(Tystr.get_ce (tystr'))))))
			andalso
			ran_enriches (t,amap,amap') 
		   end
d133 1
a133 1
	      ran_enriches (t,amap,amap')
d135 1
a135 1
	ran_enriches (domain,amap,amap')
d149 1
a149 1
	val tycon_list = Mapping.domain amap
d151 2
a152 1
	  | copy_tyenvs (tycon::tycons,tyname_copies,te,tynamecopy_fun) = 
d154 2
a155 3
	      val tystr = Mapping.lookup (tycon,amap)
	      val (copy,tyname_copies) = Tystr.tystr_copy (tystr,tyname_copies,
							   tynamecopy_fun)
d157 2
a158 2
	      copy_tyenvs (tycons,tyname_copies,add_to_te (tycon,copy,te),
			   tynamecopy_fun)
d161 1
a161 1
	copy_tyenvs (tycon_list,tyname_copies,empty_tyenv,tynamecopy_fun)
@


1.5
log
@Added require "tystr";
@
text
@d3 3
d22 1
a22 1
require "../utils/set";
d40 1
a40 1
  structure Set : SET
d115 1
a115 1
	    if Set.is_member (h,Set.list_to_set (Mapping.domain amap))
@


1.4
log
@New pervasive library code - cut some things out of the initial type basis
@
text
@d3 3
d24 1
@


1.3
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d3 4
d159 1
a159 1
      val initial_te =
a191 6
      add_to_te(Ident.TYCON (Ident.Symbol.find_symbol ("instream")),
		TYSTR (Types.make_eta_tyfun(Types.instream_tyname),
		       Conenv.empty_valenv), 
      add_to_te (Ident.TYCON (Ident.Symbol.find_symbol ("outstream")),
		 TYSTR (Types.make_eta_tyfun (Types.outstream_tyname),
			Conenv.empty_valenv),
d244 4
a247 1
		 empty_tyenv))))))))))
a248 1

@


1.2
log
@Fixed inexhaustive bindings
@
text
@d2 4
a5 1
$Log:	_tyenv.sml,v $
d11 6
a17 1
require "../typechecker/datatypes";
a20 3
require "../utils/set";
require "../utils/print";
require "../utils/crash";
d22 15
a36 11
functor Tyenv (structure Datatypes : DATATYPES
	       structure Types : TYPES
	       structure Conenv : VALENV
	       structure Scheme : TYPESCHEME
	       structure Tystr : TYSTR
	       structure Set : SET
	       structure Debug : sig val set_debug_level : int -> unit
				     val debug_level : unit -> int
				 end
	       structure Print : PRINT
	       structure Crash : CRASH
d38 2
a39 2
	       sharing Datatypes = Tystr.Datatypes = Types.Datatypes
		 = Conenv.Datatypes = Scheme.Datatypes) : TYENV =
d44 1
d57 1
a57 1
      (if (Debug.debug_level () > 10) 
d96 1
a96 1
      (if (Debug.debug_level () > 10) 
@


1.1
log
@Initial revision
@
text
@d2 5
a6 1
$Log$
d15 1
d27 2
d168 3
a170 1
			    val TYNAME {5=valenvref,...} = Types.ref_tyname
d207 3
a209 1
			    val TYNAME {5=valenvref,...} = Types.list_tyname
d227 3
a229 1
			  val TYNAME {5=valenvref,...} = Types.bool_tyname
@
