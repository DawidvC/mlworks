head	1.34;
access;
symbols
	MLW_daveb_inline_1_4_99:1.34.3
	MLWorks_21c0_1999_03_25:1.34
	MLWorks_20c1_1998_08_20:1.34
	MLWorks_20c0_1998_08_04:1.34
	MLWorks_20b2c2_1998_06_19:1.34
	MLWorks_20b2_Windows_1998_06_12:1.34
	MLWorks_20b1c1_1998_05_07:1.34
	MLWorks_20b0_1998_04_07:1.34
	MLWorks_20b0_1998_03_20:1.34
	MLWorks_20m2_1998_02_16:1.34
	MLWorks_20m1_1997_10_23:1.34
	MLWorks_11r1:1.33.5.1.1.1.1
	MLWorks_workspace_97:1.34.2
	MLWorks_dt_wizard:1.34.1
	MLWorks_11c0_1997_09_09:1.33.5.1.1.1
	MLWorks_10r3:1.33.5.1.3
	MLWorks_10r2_551:1.33.5.1.2
	MLWorks_11:1.33.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.33.5.1
	MLWorks_20m0_1997_06_20:1.34
	MLWorks_1_0_r2c2_1997_06_14:1.33.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.33.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.33.5
	MLWorks_BugFix_1997_04_24:1.34
	MLWorks_1_0_r2_Win32_1997_04_11:1.33
	MLWorks_1_0_r2_Unix_1997_04_04:1.33
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.33.3.1.1
	MLWorks_gui_1996_12_18:1.33.4
	MLWorks_1_0_Win32_1996_12_17:1.33.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.33.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.33.1.1
	MLWorks_1_0_Irix_1996_11_28:1.33.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.33.2
	MLWorks_1_0_Unix_1996_11_14:1.33.1
	MLWorks_Open_Beta2_1996_10_11:1.32.3
	MLWorks_License_dev:1.32.2
	MLWorks_1_open_beta_1996_09_13:1.32.1
	MLWorks_Open_Beta_1996_08_22:1.32
	MLWorks_Beta_1996_07_02:1.31
	MLWorks_Beta_1996_06_07:1.31
	MLWorks_Beta_1996_06_06:1.31
	MLWorks_Beta_1996_06_05:1.31
	MLWorks_Beta_1996_06_03:1.31
	MLWorks_Beta_1996_05_31:1.31
	MLWorks_Beta_1996_05_30:1.31
	ML_beta_release_12/08/94:1.24
	ML_beta_release_03/08/94:1.24
	ML_revised_beta_release_25/05/94:1.24
	ML_final_beta_release_02/03/94:1.21
	mlworks-28-01-1994:1.21
	Release:1.16
	mlworks-beta-01-09-1993:1.16
	MLWorks-1-0-4-29/01/1993:1.9
	MLWorks-1-0-3-21/12/1992:1.9
	MLWorks-1-0-2-15/12/1992:1.9
	MLWorks-1-0-1-04/12/1992:1.9
	checkpoint_17_08_92:1.5
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.34
date	97.04.22.14.09.20;	author andreww;	state Exp;
branches
	1.34.1.1
	1.34.2.1
	1.34.3.1;
next	1.33;

1.33
date	96.11.06.11.33.10;	author matthew;	state Exp;
branches
	1.33.1.1
	1.33.2.1
	1.33.3.1
	1.33.4.1
	1.33.5.1;
next	1.32;

1.32
date	96.08.05.16.29.44;	author andreww;	state Exp;
branches
	1.32.1.1
	1.32.2.1
	1.32.3.1;
next	1.31;

1.31
date	96.04.29.14.02.59;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	96.04.15.12.19.34;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	95.09.06.14.14.43;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	95.07.28.10.05.11;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	95.05.11.15.25.35;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	95.02.17.12.50.28;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	95.02.02.14.59.24;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	94.05.13.15.48.49;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	94.05.12.13.43.52;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	94.05.04.16.47.42;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	93.12.17.15.49.03;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.12.03.16.24.48;	author nickh;	state Exp;
branches;
next	1.19;

1.19
date	93.11.30.14.41.34;	author nickh;	state Exp;
branches;
next	1.18;

1.18
date	93.11.25.15.36.21;	author nosa;	state Exp;
branches;
next	1.17;

1.17
date	93.11.24.16.17.17;	author nickh;	state Exp;
branches;
next	1.16;

1.16
date	93.04.01.16.51.39;	author jont;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	93.03.12.18.55.08;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.03.10.15.21.16;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.03.04.11.07.27;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.03.03.16.51.19;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.02.22.15.54.46;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.02.08.18.36.11;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.12.04.12.51.28;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	92.11.26.17.19.39;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	92.11.04.17.26.13;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	92.09.04.08.47.02;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.08.12.10.23.37;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.07.16.12.43.47;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.06.26.14.26.40;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.21.16.44.48;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.35.03;	author colin;	state Exp;
branches;
next	;

1.16.1.1
date	93.04.01.16.51.39;	author jont;	state Exp;
branches;
next	;

1.32.1.1
date	96.09.13.11.41.59;	author hope;	state Exp;
branches;
next	;

1.32.2.1
date	96.10.07.16.35.06;	author hope;	state Exp;
branches;
next	;

1.32.3.1
date	96.10.17.11.54.11;	author hope;	state Exp;
branches;
next	;

1.33.1.1
date	96.11.14.13.22.07;	author hope;	state Exp;
branches
	1.33.1.1.1.1;
next	;

1.33.1.1.1.1
date	96.11.28.15.32.53;	author hope;	state Exp;
branches;
next	;

1.33.2.1
date	96.11.22.18.39.33;	author hope;	state Exp;
branches;
next	;

1.33.3.1
date	96.12.17.18.18.34;	author hope;	state Exp;
branches
	1.33.3.1.1.1;
next	;

1.33.3.1.1.1
date	97.02.24.12.12.49;	author hope;	state Exp;
branches;
next	;

1.33.4.1
date	96.12.18.10.13.52;	author hope;	state Exp;
branches;
next	;

1.33.5.1
date	97.05.12.10.52.06;	author hope;	state Exp;
branches
	1.33.5.1.1.1
	1.33.5.1.2.1
	1.33.5.1.3.1;
next	;

1.33.5.1.1.1
date	97.07.28.18.33.54;	author daveb;	state Exp;
branches
	1.33.5.1.1.1.1.1;
next	;

1.33.5.1.1.1.1.1
date	97.10.07.11.59.53;	author jkbrook;	state Exp;
branches;
next	;

1.33.5.1.2.1
date	97.09.08.17.26.59;	author daveb;	state Exp;
branches;
next	;

1.33.5.1.3.1
date	97.09.09.14.23.53;	author daveb;	state Exp;
branches;
next	;

1.34.1.1
date	97.09.10.19.42.49;	author brucem;	state Exp;
branches;
next	;

1.34.2.1
date	97.09.11.21.10.19;	author daveb;	state Exp;
branches;
next	;

1.34.3.1
date	99.04.01.18.08.50;	author daveb;	state Exp;
branches;
next	;


desc
@Top Level interface to the unification algorithm
@


1.34
log
@[bug #1563]
altering error message for when two explicit type vars don't match
@
text
@(* _control_unify.sml the functor *)
(*
$Log: _control_unify.sml,v $
 * Revision 1.33  1996/11/06  11:33:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.32  1996/08/05  16:29:44  andreww
 * [Bug #1521]
 * Propagating changes made to _test.sml --- essentially these
 * require passing "use_value_polymorphism" in the correct places.
 *
 * Revision 1.31  1996/04/29  14:02:59  matthew
 * Removing MLWorks.Integer.
 *
 * Revision 1.30  1996/04/15  12:19:34  matthew
 * Improving RECORD_DOMAIN error
 *
Revision 1.29  1995/09/06  14:14:43  jont
Modify messages about "equality required by T" to
"T does not admit equality"

Revision 1.28  1995/07/28  10:05:11  jont
Add handling for word_literal_tyvar

Revision 1.27  1995/05/11  15:25:35  matthew
Improving record domain error messages

Revision 1.26  1995/02/17  12:50:28  daveb
Improved printing of overloaded type variables.

Revision 1.25  1995/02/02  14:59:24  matthew
cout -s control_unify.sml
Rationalizations

Revision 1.24  1994/05/13  15:48:49  daveb
Added space to overloading error message.

Revision 1.23  1994/05/12  13:43:52  daveb
Changed previous log message.

Revision 1.22  1994/05/04  16:47:42  daveb
The error message for the overloaded case now prints the type variable.

Revision 1.21  1993/12/17  15:49:03  matthew
Added message for record domain mismatches where records are tuples.
,

Revision 1.20  1993/12/03  16:24:48  nickh
Removed TYNAME case (redundant), changed error texts.

Revision 1.19  1993/11/30  14:41:34  nickh
Marked certain error messages as "impossible".

Revision 1.18  1993/11/25  15:36:21  nosa
Modified unified to be optionally side-effect free, returning substitutions.

Revision 1.17  1993/11/24  16:17:17  nickh
Added code to encode type errors as a list of strings and types.

Revision 1.16  1993/04/01  16:51:39  jont
Allowed overloadin on strings to be controlled by an option

Revision 1.15  1993/03/12  18:55:08  matthew
Changed error message for record mismatch

Revision 1.14  1993/03/10  15:21:16  matthew
Options changes

Revision 1.13  1993/03/04  11:07:27  matthew
Options & Info changes

Revision 1.11  1993/02/22  15:54:46  matthew
Removed Types structure
Changed Completion interface

Revision 1.10  1993/02/08  18:36:11  matthew
Changes for BASISTYPES signature

Revision 1.9  1992/12/04  12:51:28  matthew
Error message revision

Revision 1.8  1992/11/26  17:19:39  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.7  1992/11/04  17:26:13  matthew
Changed Error structure to Info

Revision 1.6  1992/09/04  08:47:02  richard
Installed central error reporting mechanism.

Revision 1.5  1992/08/12  10:23:37  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.4  1992/07/16  12:43:47  jont
Fixed printing of records so it didn't come out backwards

Revision 1.3  1992/06/26  14:26:40  jont
Fixed string_domain to deal with unit

Revision 1.2  1991/11/21  16:44:48  jont
Added copyright message

Revision 1.1  91/06/07  11:35:03  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";

require "../utils/crash";
require "../utils/lists";
require "../basics/identprint";
require "../main/info";
require "types";
require "unify";
require "completion";
require "basis";

require "control_unify";

(****
 In this version of control_unify all calls to the type_debugger 
 has been replaced with calls to the error handling structure.
****)

functor Control_Unify
  (structure Crash : CRASH
   structure Lists : LISTS
   structure IdentPrint : IDENTPRINT
   structure Types : TYPES
   structure Unify : UNIFY
   structure Completion : COMPLETION
   structure Basis : BASIS
    structure Info : INFO

   sharing Completion.Options = IdentPrint.Options
   sharing Basis.BasisTypes.Datatypes = Unify.Datatypes = Completion.Datatypes = Types.Datatypes
   sharing IdentPrint.Ident = Basis.BasisTypes.Datatypes.Ident
   sharing type IdentPrint.Options.options = Unify.options
     ) : CONTROL_UNIFY = 

struct
  structure Info = Info
  structure BasisTypes = Basis.BasisTypes
  structure Datatypes = BasisTypes.Datatypes
  structure Options = IdentPrint.Options
  structure Ident = IdentPrint.Ident
  structure Symbol = Ident.Symbol

  (*****
  These functions call unification and analyse the result.
  *****)

  local
    (* these two functions are identical to the functions in _scheme *)
    fun string_labels [] = ""
      | string_labels [(label,_)] = (IdentPrint.printLab label)
      | string_labels ((label,_)::labels) = 
        (IdentPrint.printLab label) ^ ", " ^ (string_labels labels)

    fun string_domain (Unify.RIGID record) = 
      "{" ^ string_labels record ^ "}"
      | string_domain (Unify.FLEX record) = 
        case record of
          [] => "{...}"
        | _ => "{" ^ (string_labels record) ^ ", ...}"

    fun to_type (Unify.RIGID record) =
      let
        val ty = 
          Lists.reducel 
          (fn (t,(lab,t')) => Types.add_to_rectype (lab,t',t))
          (Types.empty_rectype,record)
      in
        ty
      end

      | to_type (Unify.FLEX record) =
        let
          val ty = 
            Lists.reducel 
            (fn (t,(lab,t')) => Types.add_to_rectype (lab,t',t))
            (Types.empty_rectype,record)
        in
         Datatypes.METARECTYPE (ref (0,false,ty,false, false))
        end

    fun is_tuple_domain (Unify.RIGID record) =
      let
        val lablist = map #1 record
        val len = Lists.length lablist
        fun check n = 
          if n > len then true
          else
            Lists.member (Ident.LAB (Symbol.find_symbol (Int.toString n)),lablist)
            andalso
            check (n+1)
      in
        check 1
      end
      | is_tuple_domain _ = false

    fun describe (Unify.FAILED (ty,ty')) =
      [Datatypes.Err_String "\n    Type clash between\n      ",
       Datatypes.Err_Type ty,
       Datatypes.Err_String "\n    and\n      ",
       Datatypes.Err_Type ty']
      
      | describe (Unify.RECORD_DOMAIN (domain,domain')) =
        if is_tuple_domain domain andalso is_tuple_domain domain'
          then
            [Datatypes.Err_String "\n    Lengths of tuples differ:\n      ",
             Datatypes.Err_Type (to_type domain),
             Datatypes.Err_String "\n    and\n      ",  
             Datatypes.Err_Type (to_type domain')]
        else
          [Datatypes.Err_String "\n    Domains of record types differ:\n      ",
           Datatypes.Err_String (string_domain domain),
           Datatypes.Err_String "\n    and\n      ",
           Datatypes.Err_String (string_domain domain')]
	
      | describe (Unify.EXPLICIT_TYVAR (ty,ty')) =
            [Datatypes.Err_String "\n     because the type variable ",
             Datatypes.Err_Type ty,
             Datatypes.Err_String " of the first type",
             Datatypes.Err_String " has a different scope from",
             Datatypes.Err_String "\n     the type variable ",
             Datatypes.Err_Type ty',
             Datatypes.Err_String " of the second type.",
             Datatypes.Err_String 
                 "\n        (One of them probably cannot be generalized.) "]

	
      | describe (Unify.EQ_AND_IMP (eq,imp,ty)) =
	[Datatypes.Err_String "\n    ",
	 Datatypes.Err_Type ty,
	 Datatypes.Err_String (case (eq, imp) of
				 (true, false) => " does not admit equality"
			       | (true, true) => " does not admit equality and is not imperative"
			       | (false, true) => " is not imperative"
			       | _ => Crash.impossible "Control_Unify.describe EQ_AND_IMP")]
	
      | describe (Unify.CIRCULARITY (ty,ty')) =
	[Datatypes.Err_String "\n    Circular type results from unifying\n      ",
	 Datatypes.Err_Type ty,
	 Datatypes.Err_String "\n    and\n      ",
	 Datatypes.Err_Type ty']
	
      | describe (Unify.OVERLOADED (tv, ty)) =
	let
	  (* If the overloaded tyvar has a default type, we report the
	     tyvar as if it were that type.  This produces clearer error
	     messages for examples such as 2 + 3.0. *)

	  val has_default =
	    (tv = Ident.real_literal_tyvar) orelse
	    (tv = Ident.int_literal_tyvar) orelse
	    (tv = Ident.word_literal_tyvar)

	  val initial_string =
	    if has_default then
	      "\n    Type clash between "
	    else
	      "\n    Type clash between overloaded type variable "
	in
	  [Datatypes.Err_String
	     (initial_string
	      ^ IdentPrint.printTyVar tv
	      ^ " and "), 
	   Datatypes.Err_Type ty]
	end
	
      | describe Unify.OK = Crash.impossible "ControlUnify.generate_message"
      | describe (Unify.SUBSTITUTION _) = Crash.impossible "SUBSTITUTION:ControlUnify.generate_message"
  in
    fun unify
      (error_info,options as Options.OPTIONS{print_options,...})
      {
       first  : Datatypes.Type,
       second : Datatypes.Type,
       result : Datatypes.Type,
       context : BasisTypes.Context,
       error : unit -> Info.Location.T * Datatypes.type_error_atom list * Datatypes.Type
      } =
      
      case Unify.unified(options, first, second, false) of
	Unify.OK => result
      | error_code =>
          let
            val (location, err_list, result) = error ()
	    val unify_err_list = describe error_code
	    val report =
	      Completion.report_type_error
	      (options, Basis.env_of_context context,
	       err_list@@unify_err_list)
          in
            (Info.error error_info
	     (Info.RECOVERABLE, location, report);
	     result)
          end
  end
end
@


1.34.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.34  1997/04/22  14:09:20  andreww
 * [bug #1563]
 * altering error message for when two explicit type vars don't match
 *
@


1.34.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.34  1997/04/22  14:09:20  andreww
 * [bug #1563]
 * altering error message for when two explicit type vars don't match
 *
@


1.34.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.34  1997/04/22  14:09:20  andreww
 * [bug #1563]
 * altering error message for when two explicit type vars don't match
 *
@


1.33
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d227 10
a236 4
	[Datatypes.Err_String "\n    Type clash between\n      ",
	 Datatypes.Err_Type ty,
	 Datatypes.Err_String "\n    and\n      ",
	 Datatypes.Err_Type ty']
@


1.33.5.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/11/06  11:33:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.33.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.33.5.1  1997/05/12  10:52:06  hope
 * branched from 1.33
 *
@


1.33.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.33.5.1  1997/05/12  10:52:06  hope
 * branched from 1.33
 *
@


1.33.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.33.5.1  1997/05/12  10:52:06  hope
 * branched from 1.33
 *
@


1.33.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.33.5.1.1.1  1997/07/28  18:33:54  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.33.4.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/11/06  11:33:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.33.3.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/11/06  11:33:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.33.3.1.1.1
log
@branched from 1.33.3.1
@
text
@a3 3
 * Revision 1.33.3.1  1996/12/17  18:18:34  hope
 * branched from 1.33
 *
@


1.33.2.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/11/06  11:33:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.33.1.1
log
@branched from 1.33
@
text
@a3 4
 * Revision 1.33  1996/11/06  11:33:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.33.1.1.1.1
log
@branched from 1.33.1.1
@
text
@a3 3
 * Revision 1.33.1.1  1996/11/14  13:22:07  hope
 * branched from 1.33
 *
@


1.32
log
@[Bug #1521]
Propagating changes made to _test.sml --- essentially these
require passing "use_value_polymorphism" in the correct places.
@
text
@d4 5
d108 1
a108 1
require "../basis/__integer";
@


1.32.3.1
log
@branched from 1.32
@
text
@a3 5
 * Revision 1.32  1996/08/05  16:29:44  andreww
 * [Bug #1521]
 * Propagating changes made to _test.sml --- essentially these
 * require passing "use_value_polymorphism" in the correct places.
 *
@


1.32.2.1
log
@branched from 1.32
@
text
@a3 5
 * Revision 1.32  1996/08/05  16:29:44  andreww
 * [Bug #1521]
 * Propagating changes made to _test.sml --- essentially these
 * require passing "use_value_polymorphism" in the correct places.
 *
@


1.32.1.1
log
@branched from 1.32
@
text
@a3 5
 * Revision 1.32  1996/08/05  16:29:44  andreww
 * [Bug #1521]
 * Propagating changes made to _test.sml --- essentially these
 * require passing "use_value_polymorphism" in the correct places.
 *
@


1.31
log
@Removing MLWorks.Integer.
@
text
@d4 3
d283 1
a283 1
	      (print_options, Basis.env_of_context context,
@


1.30
log
@Improving RECORD_DOMAIN error
@
text
@d4 3
d100 2
d187 1
a187 1
            Lists.member (Ident.LAB (Symbol.find_symbol (MLWorks.Integer.makestring n)),lablist)
@


1.29
log
@Modify messages about "equality required by T" to
"T does not admit equality"
@
text
@d4 4
d101 1
d117 1
d124 1
a124 1
   sharing Basis.BasisTypes.Datatypes = Unify.Datatypes = Completion.Datatypes
d149 1
a149 1
      "{" ^ (string_labels record) ^ "}"
d155 20
d196 1
a196 1
      | describe (Unify.RECORD_DOMAIN (domain, domain')) =
a198 2
            [Datatypes.Err_String "\n    Lengths of tuples differ"]
(*
d201 2
a202 3
             Datatypes.Err_String "\n    and\n      ",
             Datatypes.Err_Type (to_type domain)]
*)
@


1.28
log
@Add handling for word_literal_tyvar
@
text
@d4 3
d194 1
d196 4
a199 6
				 (true, false) => "Equality attribute"
			       | (true, true) => "Equality and imperative attributes"
			       | (false, true) => "Imperative attribute"
			       | _ => Crash.impossible "Control_Unify.describe EQ_AND_IMP"),
	 Datatypes.Err_String " required by ",
	 Datatypes.Err_Type ty]
@


1.27
log
@Improving record domain error messages
@
text
@d4 3
d213 2
a214 1
	    (tv = Ident.int_literal_tyvar)
@


1.26
log
@Improved printing of overloaded type variables.
@
text
@d4 3
d132 2
a133 2
      | string_labels [label] = (IdentPrint.printLab label)
      | string_labels (label::labels) = 
d136 4
a139 4
    fun string_domain (Unify.RIGID lablist) = 
      "{" ^ (string_labels lablist) ^	"}"
      | string_domain (Unify.FLEX lablist) = 
        case lablist of
d141 1
a141 1
        | _ => "{" ^ (string_labels lablist) ^ ", ...}"
d143 1
a143 1
    fun is_tuple_domain (Unify.RIGID lablist) =
d145 1
d168 6
d175 1
a175 1
          [Datatypes.Err_String "\n    Domains of record types differ\n      ",
@


1.25
log
@cout -s control_unify.sml
Rationalizations
@
text
@d4 4
d193 21
a213 5
	[Datatypes.Err_String
	   ("\n    Type clash between overloaded type variable "
	    ^ IdentPrint.printTyVar tv
	    ^ " and "), 
	 Datatypes.Err_Type ty]
@


1.24
log
@Added space to overloading error message.
@
text
@d4 3
@


1.23
log
@Changed previous log message.
@
text
@d4 3
d189 1
a189 1
	    ^ "and "), 
@


1.22
log
@testing the new overloading scheme.
@
text
@d4 3
@


1.21
log
@Added message for record domain mismatches where records are tuples.
,
@
text
@d4 4
d93 1
a93 1
   structure Info : INFO
d179 5
a183 2
      | describe (Unify.OVERLOADED ty) =
	[Datatypes.Err_String "\n    Type clash between overloaded type variable and ", 
@


1.20
log
@Removed TYNAME case (redundant), changed error texts.
@
text
@d4 3
d68 1
d84 1
d102 2
d123 14
d144 8
a151 4
	[Datatypes.Err_String "\n    Domains of record types differ\n      ",
	 Datatypes.Err_String (string_domain domain),
	 Datatypes.Err_String "\n    and\n      ",
	 Datatypes.Err_String (string_domain domain')]
@


1.19
log
@Marked certain error messages as "impossible".
@
text
@d4 3
d117 1
a117 1
      [Datatypes.Err_String "\n    Cannot unify\n      ",
a121 6
      | describe (Unify.TYNAME (name,name')) =
	[Datatypes.Err_String "\n impossible type error 1: Type name clash between\n      ",
	 Datatypes.Err_Type (Datatypes.CONSTYPE([], name)),
	 Datatypes.Err_String "\n    and\n      ",
	 Datatypes.Err_Type (Datatypes.CONSTYPE([], name'))]
	
d129 1
a129 1
	[Datatypes.Err_String "\n    Cannot unify\n      ",
d151 1
a151 1
	[Datatypes.Err_String "\n    Cannot unify overloaded type variable with ", 
@


1.18
log
@Modified unified to be optionally side-effect free, returning substitutions.
@
text
@d4 3
d120 1
a120 1
	[Datatypes.Err_String "\n    Type name clash between\n      ",
@


1.17
log
@Added code to encode type errors as a list of strings and types.
@
text
@d4 3
d155 1
d167 1
a167 1
      case Unify.unified(options, first, second) of
@


1.16
log
@Allowed overloadin on strings to be controlled by an option
@
text
@d4 3
d107 45
a151 56
    fun describe options (context, failure) =
      let
        fun print_type ty = Completion.print_type(options,Basis.env_of_context context,ty)
        fun desc (Unify.FAILED (ty,ty')) =
          implode
          ["\n    Cannot unify\n      ",
           print_type ty,
           "\n    and\n      ",
           print_type ty']

          | desc (Unify.TYNAME (name,name')) =
            implode
            ["\n    Type name clash between\n      ",
             print_type (Datatypes.CONSTYPE([], name)),
             "\n    and\n      ",
             print_type (Datatypes.CONSTYPE([], name'))]

          | desc (Unify.RECORD_DOMAIN (domain, domain')) =
            implode
            ["\n    Domains of record types differ\n      ",
             string_domain domain, "\n    and\n      ", string_domain domain']

          | desc (Unify.EXPLICIT_TYVAR (ty,ty')) =
            implode
            ["\n    Cannot unify\n      " ^
             print_type ty,
             "\n    and\n      ",
             print_type ty']

          | desc (Unify.EQ_AND_IMP (eq,imp,ty)) =
            implode
            ["\n    ",
             case (eq, imp) of
               (true, false) => "Equality attribute"
             | (true, true) => "Equality and imperative attributes"
             | (false, true) => "Imperative attribute"
             | _ => Crash.impossible "Control_Unify.describe EQ_AND_IMP",
                 " required by ",
                 print_type ty]

          | desc (Unify.CIRCULARITY (ty,ty')) =
            implode
            ["\n    Circular type results from unifying\n      ",
             print_type ty,
             "\n    and\n      ",
             print_type ty']
            
          | desc (Unify.OVERLOADED ty) =
            implode
            ["\n    Cannot unify overloaded type variable with " ^ 
             print_type ty]

          | desc Unify.OK = Crash.impossible "ControlUnify.generate_message"
      in
        desc failure
      end
d160 1
a160 1
       error : unit -> Info.Location.T * string * Datatypes.Type
d167 6
a172 1
            val (location, message, result) = error ()
d174 3
a176 4
            Info.error error_info
                       (Info.RECOVERABLE, location,
                        implode [message, describe print_options (context, error_code)]);
            result
@


1.16.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.16  1993/04/01  16:51:39  jont
Allowed overloadin on strings to be controlled by an option

@


1.15
log
@Changed error message for record mismatch
@
text
@d4 3
d76 3
a78 1
   sharing IdentPrint.Ident = Basis.BasisTypes.Datatypes.Ident) : CONTROL_UNIFY = 
d162 1
a162 1
      (error_info,Options.OPTIONS{print_options,...})
d171 1
a171 1
      case Unify.unified (first, second) of
@


1.14
log
@Options changes
@
text
@d4 3
d86 1
d88 1
d90 4
a93 12
	(IdentPrint.printLab label) ^ ": -," ^
	(string_labels labels)
	  
    fun string_domain (Unify.RIGID []) = "{}\n"
      | string_domain (Unify.RIGID lablist) =
	let
	  val the_list = string_labels lablist
	in
	  case rev(explode the_list) of
	    _ :: rest => implode("{" :: rev("}" :: rest))
	  | _ => Crash.impossible("Bad string_labels '" ^ the_list ^ "'")
	end
d95 3
a97 1
	"{" ^ (string_labels lablist) ^ "... }"
@


1.13
log
@Options & Info changes
@
text
@d4 3
d158 1
a158 1
      (error_info,print_options)
@


1.12
log
@Removed redundant require
@
text
@d45 1
d63 1
d65 1
a65 1
   sharing Basis.BasisTypes.Info = Completion.Info
d70 1
a70 1
  structure Info = Completion.Info
d73 2
a74 1
    
d155 1
a155 1
      options
d170 1
a170 1
            Info.error options
d172 1
a172 1
                        implode [message, describe options (context, error_code)]);
@


1.11
log
@Removed Types structure
Changed Completion interface
@
text
@d4 4
a44 1
require "../main/info";
@


1.10
log
@Changes for BASISTYPES signature
@
text
@d4 3
a41 2
require "control_unify";
require "types";
d46 2
a55 1
   structure Types : TYPES
d59 1
d61 2
a62 2
   sharing Basis.BasisTypes.Datatypes = Types.Datatypes = Unify.Datatypes = Completion.Datatypes
   sharing IdentPrint.Ident = Types.Datatypes.Ident) : CONTROL_UNIFY = 
a65 1
  structure Datatypes = Types.Datatypes
d67 1
a89 49
	  
    fun describe options (context, Unify.FAILED (ty,ty')) =
        implode
        ["\n    Cannot unify\n      ",
         Completion.print_type options (Basis.env_of_context context) ty,
         "\n    and\n      ",
         Completion.print_type options (Basis.env_of_context context) ty']

      | describe options (context, Unify.TYNAME (name,name')) =
        implode
        ["\n    Type name clash between\n      ",
         Completion.print_type options (Basis.env_of_context context) (Datatypes.CONSTYPE([], name)),
         "\n    and\n      ",
         Completion.print_type options (Basis.env_of_context context) (Datatypes.CONSTYPE([], name'))]

      | describe options (context, Unify.RECORD_DOMAIN (domain, domain')) =
        implode
        ["\n    Domains of record types differ\n      ",
         string_domain domain, "\n    and\n      ", string_domain domain']

      | describe options (context, Unify.EXPLICIT_TYVAR (ty,ty')) =
        implode
        ["\n    Cannot unify\n      " ^
         Completion.print_type options (Basis.env_of_context context) ty,
         "\n    and\n      ",
         Completion.print_type options (Basis.env_of_context context) ty']

      | describe options (context, Unify.EQ_AND_IMP (eq,imp,ty)) =
        implode
        ["\n    ",
         case (eq, imp) of
           (true, false) => "Equality attribute"
         | (true, true) => "Equality and imperative attributes"
         | (false, true) => "Imperative attribute"
         | _ => Crash.impossible "Control_Unify.describe EQ_AND_IMP",
         " required by ",
         Completion.print_type options (Basis.env_of_context context) ty]

      | describe options (context, Unify.CIRCULARITY (ty,ty')) =
        implode
        ["\n    Circular type results from unifying\n      ",
         Completion.print_type options (Basis.env_of_context context) ty,
         "\n    and\n      ",
         Completion.print_type options (Basis.env_of_context context) ty']

      | describe options (context, Unify.OVERLOADED ty) =
        implode
        ["\n    Cannot unify overloaded type variable with " ^ 
         Completion.print_type options (Basis.env_of_context context) ty]
d91 56
a146 1
      | describe options (_, Unify.OK) = Crash.impossible "ControlUnify.generate_message"
@


1.9
log
@Error message revision
@
text
@d4 3
d57 2
a58 1
   sharing Basis.Tyvarenv.Datatypes = Types.Datatypes = Unify.Datatypes = Completion.Datatypes
d64 1
a64 1
  structure Basis = Basis
d145 2
a146 2
       context : Basis.Context,
       error : unit -> Info.Location.T * string * Basis.Tyvarenv.Datatypes.Type
@


1.8
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d78 2
a79 2
	    _ :: rest => implode("{" :: rev("}\n" :: rest))
	  | _ => Crash.impossible("Bad string_labels '" ^ the_list ^ "'\n")
d82 1
a82 1
	"{" ^ (string_labels lablist) ^ "... }\n"
d86 1
a86 1
        ["\n  Cannot unify\n    ",
d88 1
a88 1
         "\n  and\n    ",
d93 1
a93 1
        ["\nType name clash between\n    ",
d95 1
a95 1
         "\n  and\n    ",
d100 2
a101 2
        ["\n  Domains of record types differ\n    ",
         string_domain domain, "\n  and\n    ", string_domain domain']
d105 1
a105 1
        ["\n  Cannot unify type variable\n    " ^
d107 1
a107 1
         "\n  with type\n    ",
d112 1
a112 1
        ["\n  ",
d123 1
a123 1
        ["\n  Circular type results from unifying\n    ",
d125 1
a125 1
         "\n  and\n    ",
d130 1
a130 1
        ["\n  Cannot unify overloaded type variable with " ^ 
@


1.7
log
@Changed Error structure to Info
@
text
@d4 3
a45 1
   structure Info : INFO
d54 1
a54 1
  structure Info = Info
d80 1
a80 1
    fun describe (context, Unify.FAILED (ty,ty')) =
d83 1
a83 1
         Completion.print_type (Basis.env_of_context context) ty,
d85 1
a85 1
         Completion.print_type (Basis.env_of_context context) ty']
d87 1
a87 1
      | describe (context, Unify.TYNAME (name,name')) =
d90 1
a90 1
         Completion.print_type (Basis.env_of_context context) (Datatypes.CONSTYPE([], name)),
d92 1
a92 1
         Completion.print_type (Basis.env_of_context context) (Datatypes.CONSTYPE([], name'))]
d94 1
a94 1
      | describe (context, Unify.RECORD_DOMAIN (domain, domain')) =
d99 1
a99 1
      | describe (context, Unify.EXPLICIT_TYVAR (ty,ty')) =
d102 1
a102 1
         Completion.print_type (Basis.env_of_context context) ty,
d104 1
a104 1
         Completion.print_type (Basis.env_of_context context) ty']
d106 1
a106 1
      | describe (context, Unify.EQ_AND_IMP (eq,imp,ty)) =
d115 1
a115 1
         Completion.print_type (Basis.env_of_context context) ty]
d117 1
a117 1
      | describe (context, Unify.CIRCULARITY (ty,ty')) =
d120 1
a120 1
         Completion.print_type (Basis.env_of_context context) ty,
d122 1
a122 1
         Completion.print_type (Basis.env_of_context context) ty']
d124 1
a124 1
      | describe (context, Unify.OVERLOADED ty) =
d127 1
a127 1
         Completion.print_type (Basis.env_of_context context) ty]
d129 1
a129 1
      | describe (_, Unify.OK) = Crash.impossible "ControlUnify.generate_message"
d149 1
a149 1
                        implode [message, describe (context, error_code)]);
@


1.6
log
@Installed central error reporting mechanism.
@
text
@d4 3
d28 1
a28 1
require "../main/error";
d43 1
a43 1
   structure Error : ERROR
d52 1
a52 1
  structure Error = Error
d130 1
d136 1
a136 1
       error : unit -> Error.Location.T * string * Basis.Tyvarenv.Datatypes.Type
d145 3
a147 3
            Error.report
            (Error.ERROR (Error.RECOVERABLE, location,
                          implode [message, describe (context, error_code)]));
@


1.5
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d25 6
a30 5
require "../typechecker/control_unify";
require "../typechecker/types";
require "../typechecker/unify";
require "../typechecker/completion";
require "../typechecker/errors";
d40 1
a40 1
   structure Errors : ERRORS
d44 3
a46 4
   sharing Errors.Basis.Tyvarenv.Datatypes = Types.Datatypes =
     Unify.Datatypes = Completion.Datatypes
   sharing IdentPrint.Ident = Types.Datatypes.Ident
     ) : CONTROL_UNIFY = 
d49 1
a49 1
  structure Errors    = Errors
d51 1
a51 1
  structure Basis     = Errors.Basis
d75 48
a122 46
    fun generate_message context error = 
      case error of
	Unify.FAILED (ty,ty') => 
	  "\ncannot unify \n  " ^
	  (Completion.print_type (Basis.env_of_context context) ty) ^ 
	  "\n    and\n  " ^ 
	  (Completion.print_type (Basis.env_of_context context) ty') ^ "\n"

      | Unify.TYNAME (name,name') =>
	  "\ntype name clash between \n  " ^
	  (Completion.print_type (Basis.env_of_context context)
	   (Datatypes.CONSTYPE([], name))) ^
	  "\n     and\n  " ^
	  (Completion.print_type (Basis.env_of_context context)
	   (Datatypes.CONSTYPE([], name'))) ^ "\n"

      | Unify.RECORD_DOMAIN (domain, domain') =>
	  "\ndomains of record types differ : \n  " ^
	  (string_domain domain) ^ "\n   and\n  " ^ 
	  (string_domain domain') ^ "\n"

      | Unify.EXPLICIT_TYVAR (ty,ty') =>
	  "\ncannot unify type variable \n  " ^
	  (Completion.print_type (Basis.env_of_context context) ty) ^ 
	  "\n    with type\n  " ^
	  (Completion.print_type (Basis.env_of_context context) ty') ^ "\n"

      | Unify.EQ_AND_IMP (eq,imp,ty) =>
	  "\n" ^ (Completion.print_type (Basis.env_of_context context) ty) ^ 
	  (if eq andalso not imp then
	     " requires equality attribute \n"
	   else
	     if eq andalso imp then
	       " requires equality as well as imperative attribute \n"
	     else
	       " requires imperative attribute\n")

      | Unify.CIRCULARITY (ty,ty') =>
	  "\ncircular type results from unifying \n  " ^ 
	  (Completion.print_type (Basis.env_of_context context) ty) ^ 
	  "\n    and\n  " ^
	  (Completion.print_type (Basis.env_of_context context) ty') ^ "\n"

      | Unify.OVERLOADED ty =>
	  "\ncannot unify overloaded type variable with \n  " ^ 
	  (Completion.print_type (Basis.env_of_context context) ty) ^ "\n"
d124 1
a124 1
      | Unify.OK => Crash.impossible "ControlUnify.generate_message"
d132 2
a133 3
       get_action : (unit -> Datatypes.Type Errors.action),
       get_error_messages  : (unit -> string list)
       } =
d137 9
a145 8
      | error =>
	  let
	    val action   = get_action ()
	    val messages = get_error_messages ()
	  in
	    Errors.announce_error context action 
	    (messages @@ ["\nReason : ", generate_message context error])
	  end
a147 5

   
   


@


1.4
log
@Fixed printing of records so it didn't come out backwards
@
text
@d4 3
d18 1
a18 1
require "../utils/lists";
d20 1
a21 1
require "../typechecker/datatypes";
a23 1
require "../typechecker/basis";
a31 2


d33 3
a35 8
  (structure Lists : LISTS
   structure Crash : CRASH

   structure Datatypes : DATATYPES

   structure Basis : BASIS
   sharing Basis.Datatypes = Datatypes

a36 2
   sharing Types.Datatypes = Datatypes

a37 6
   sharing Unify.Datatypes = Datatypes

   structure Errors : ERRORS
   sharing Errors.Datatypes = Datatypes
   sharing Errors.Basis = Basis

d39 3
a41 2
   sharing Completion.Datatypes = Datatypes

a44 3
  structure Datatypes = Datatypes
  structure Unify     = Unify
  structure Basis     = Basis
d46 2
d56 1
a56 1
	(Datatypes.IdentPrint.printLab label) ^ ": -," ^
@


1.3
log
@Fixed string_domain to deal with unit
@
text
@d4 3
d77 1
a77 1
	  case explode(the_list) of
@


1.2
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_control_unify.sml,v $
d69 9
a77 4
    fun string_domain (Unify.RIGID lablist) = 
        "{" ^
        (implode (rev (Lists.tl (rev (explode (string_labels lablist)))))) ^
        "}\n"
@


1.1
log
@Initial revision
@
text
@d1 1
d3 5
a7 1
$Log$
@
