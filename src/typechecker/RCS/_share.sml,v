head	1.25;
access;
symbols
	MLW_daveb_inline_1_4_99:1.25.3
	MLWorks_21c0_1999_03_25:1.25
	MLWorks_20c1_1998_08_20:1.25
	MLWorks_20c0_1998_08_04:1.25
	MLWorks_20b2c2_1998_06_19:1.25
	MLWorks_20b2_Windows_1998_06_12:1.25
	MLWorks_20b1c1_1998_05_07:1.25
	MLWorks_20b0_1998_04_07:1.25
	MLWorks_20b0_1998_03_20:1.25
	MLWorks_20m2_1998_02_16:1.25
	MLWorks_20m1_1997_10_23:1.25
	MLWorks_11r1:1.24.8.2.1.1.1
	MLWorks_workspace_97:1.25.2
	MLWorks_dt_wizard:1.25.1
	MLWorks_11c0_1997_09_09:1.24.8.2.1.1
	MLWorks_10r3:1.24.8.2.3
	MLWorks_10r2_551:1.24.8.2.2
	MLWorks_11:1.24.8.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.24.8.2
	MLWorks_20m0_1997_06_20:1.25
	MLWorks_1_0_r2c2_1997_06_14:1.24.8.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.24.8.2
	MLWorks_1_0_r2c1_1997_05_12:1.24.8
	MLWorks_BugFix_1997_04_24:1.25
	MLWorks_1_0_r2_Win32_1997_04_11:1.24
	MLWorks_1_0_r2_Unix_1997_04_04:1.24
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.24.6.1.1
	MLWorks_gui_1996_12_18:1.24.7
	MLWorks_1_0_Win32_1996_12_17:1.24.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.24.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.24.4.1
	MLWorks_1_0_Irix_1996_11_28:1.24.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.24.5
	MLWorks_1_0_Unix_1996_11_14:1.24.4
	MLWorks_Open_Beta2_1996_10_11:1.24.3
	MLWorks_License_dev:1.24.2
	MLWorks_1_open_beta_1996_09_13:1.24.1
	MLWorks_Open_Beta_1996_08_22:1.24
	MLWorks_Beta_1996_07_02:1.24
	MLWorks_Beta_1996_06_07:1.24
	MLWorks_Beta_1996_06_06:1.24
	MLWorks_Beta_1996_06_05:1.24
	MLWorks_Beta_1996_06_03:1.24
	MLWorks_Beta_1996_05_31:1.24
	MLWorks_Beta_1996_05_30:1.24
	ML_beta_release_12/08/94:1.22
	ML_beta_release_03/08/94:1.22
	ML_revised_beta_release_25/05/94:1.22
	ML_final_beta_release_02/03/94:1.22
	mlworks-28-01-1994:1.22
	Release:1.20
	mlworks-beta-01-09-1993:1.20
	MLWorks-1-0-4-29/01/1993:1.13
	MLWorks-1-0-3-21/12/1992:1.12
	MLWorks-1-0-2-15/12/1992:1.12
	MLWorks-1-0-1-04/12/1992:1.10
	checkpoint_17_08_92:1.7
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.25
date	97.04.08.14.51.10;	author andreww;	state Exp;
branches
	1.25.1.1
	1.25.2.1
	1.25.3.1;
next	1.24;

1.24
date	96.03.28.10.20.09;	author matthew;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1
	1.24.4.1
	1.24.5.1
	1.24.6.1
	1.24.7.1
	1.24.8.1;
next	1.23;

1.23
date	95.02.07.15.27.31;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.12.06.15.58.42;	author nickh;	state Exp;
branches;
next	1.21;

1.21
date	93.12.01.13.57.01;	author nickh;	state Exp;
branches;
next	1.20;

1.20
date	93.06.25.19.27.37;	author jont;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	93.05.25.15.32.33;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	93.05.24.10.29.19;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.05.21.12.00.05;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	93.05.20.16.52.58;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.03.17.19.01.50;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.02.08.19.12.24;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.12.22.15.55.35;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.12.07.11.13.06;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	92.12.04.19.27.47;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	92.12.03.17.33.48;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.09.08.13.53.40;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.20.18.19.23;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.08.12.11.09.23;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.08.06.17.38.14;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.08.04.13.50.06;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	92.04.28.15.00.11;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.01.27.20.15.02;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.19.19.07.01;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.37.41;	author colin;	state Exp;
branches;
next	;

1.20.1.1
date	93.06.25.19.27.37;	author jont;	state Exp;
branches;
next	;

1.24.1.1
date	96.09.13.11.41.07;	author hope;	state Exp;
branches;
next	;

1.24.2.1
date	96.10.07.16.34.09;	author hope;	state Exp;
branches;
next	;

1.24.3.1
date	96.10.17.11.53.17;	author hope;	state Exp;
branches;
next	;

1.24.4.1
date	96.11.14.13.20.53;	author hope;	state Exp;
branches
	1.24.4.1.1.1;
next	;

1.24.4.1.1.1
date	96.11.28.15.31.52;	author hope;	state Exp;
branches;
next	;

1.24.5.1
date	96.11.22.18.38.39;	author hope;	state Exp;
branches;
next	;

1.24.6.1
date	96.12.17.18.17.39;	author hope;	state Exp;
branches
	1.24.6.1.1.1;
next	;

1.24.6.1.1.1
date	97.02.24.12.11.55;	author hope;	state Exp;
branches;
next	;

1.24.7.1
date	96.12.18.10.12.55;	author hope;	state Exp;
branches;
next	;

1.24.8.1
date	97.05.12.10.51.14;	author hope;	state Exp;
branches;
next	1.24.8.2;

1.24.8.2
date	97.05.12.16.03.28;	author daveb;	state Exp;
branches
	1.24.8.2.1.1
	1.24.8.2.2.1
	1.24.8.2.3.1;
next	;

1.24.8.2.1.1
date	97.07.28.18.34.34;	author daveb;	state Exp;
branches
	1.24.8.2.1.1.1.1;
next	;

1.24.8.2.1.1.1.1
date	97.10.07.12.00.26;	author jkbrook;	state Exp;
branches;
next	;

1.24.8.2.2.1
date	97.09.08.17.27.30;	author daveb;	state Exp;
branches;
next	;

1.24.8.2.3.1
date	97.09.09.14.24.27;	author daveb;	state Exp;
branches;
next	;

1.25.1.1
date	97.09.10.19.43.23;	author brucem;	state Exp;
branches;
next	;

1.25.2.1
date	97.09.11.21.10.50;	author daveb;	state Exp;
branches;
next	;

1.25.3.1
date	99.04.01.18.09.07;	author daveb;	state Exp;
branches;
next	;


desc
@Handles Sharing Constraints in modules
@


1.25
log
@[Bug #2033]
making sure type dependencies are shared in correct order.
@
text
@(*
$Log: _share.sml,v $
 * Revision 1.24  1996/03/28  10:20:09  matthew
 * Updating for new language revisions
 *
 * Revision 1.23  1995/02/07  15:27:31  matthew
 * Removing debug stuff
 *
Revision 1.22  1993/12/06  15:58:42  nickh
Capitalize error messages.

Revision 1.21  1993/12/01  13:57:01  nickh
Marked certain error messages as "impossible".

Revision 1.20  1993/06/25  19:27:37  jont
Some tidying up

Revision 1.19  1993/05/25  15:32:33  jont
Changes because Assemblies now has Basistypes instead of Datatypes

Revision 1.18  1993/05/24  10:29:19  matthew
Changed name to name'

Revision 1.17  1993/05/21  12:00:05  jont
Fixed up to check for illegal sharing in functor result signatures
ie trying to force extra sharing on the functor parameter

Revision 1.16  1993/05/20  16:52:58  jont
Avoid updating flexible names in the basis (when doing sharng in functor results)

Revision 1.15  1993/03/17  19:01:50  matthew
Nameset signature changes

Revision 1.14  1993/02/08  19:12:24  matthew
Changes for BASISTYPES signature

Revision 1.13  1992/12/22  15:55:35  jont
Anel's last changes

Revision 1.12  1992/12/07  11:13:06  matthew
Changed error messages.

Revision 1.11  1992/12/04  19:27:47  matthew
Error message revisions.

Revision 1.10  1992/12/03  17:33:48  matthew
"they" => "they have"

Revision 1.9  1992/09/08  13:53:40  jont
Removed has_a_new_name, no longer needed

Revision 1.8  1992/08/20  18:19:23  jont
Various improvements to remove garbage, handlers etc.

Revision 1.7  1992/08/12  11:09:23  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.6  1992/08/06  17:38:14  jont
Anel's changes to use NewMap instead of Map

Revision 1.4  1992/04/28  15:00:11  jont
Anel's fixes

Revision 1.3  1992/01/27  20:15:02  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.2  1991/11/19  19:07:01  jont
Fixed inexhsustive matches

Revision 1.1  91/06/07  11:37:41  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/lists";
require "../utils/print";
require "../utils/crash";
require "../basics/identprint";
require "../typechecker/valenv";
require "../typechecker/strnames";
require "../typechecker/nameset";
require "../typechecker/sharetypes";
require "../typechecker/share";

functor Share(
  structure Lists : LISTS
  structure Print : PRINT
  structure Crash : CRASH
  structure IdentPrint : IDENTPRINT
  structure Sharetypes : SHARETYPES
  structure Valenv : VALENV
  structure Strnames : STRNAMES
  structure Nameset : NAMESET
    
  sharing Sharetypes.Assemblies.Basistypes.Datatypes = Valenv.Datatypes = 
    Nameset.Datatypes = Strnames.Datatypes
  sharing IdentPrint.Ident = Valenv.Datatypes.Ident

  sharing type Sharetypes.Assemblies.Basistypes.Nameset = Nameset.Nameset

) : SHARE = 
  struct
    structure Datatypes = Valenv.Datatypes
    structure Assemblies = Sharetypes.Assemblies
    structure BasisTypes = Assemblies.Basistypes

    structure Nameset = Nameset

    (****
     This functor contains the functions to do the sharing of structures.
     ****)

    open Datatypes

    fun ordered_sublist([], _) = true
      | ordered_sublist(first as (x :: xs), y :: ys) =
	if x = y then
	  ordered_sublist(xs, ys)
	else
	  ordered_sublist(first, ys)
      | ordered_sublist _ = false
  
    exception ShareError of string

    (* Note, the following three "global references" are initialised
     * by the function "findFixedpoint" below, and updated by the
     * function "one_type_share" immediately below.  The idea is that
     * when trying to share types in structures, we keep a track of
     * those types which cannot be shared.  Perhaps one of them cannot
     * be shared because it depends on a type which will be shared later.
     * Thus, we repeat the process until !old_share_failures and
     * !share_failures are equal, in which case we know that any remaining
     * type sharing errors cannot be resolved by sharing types that may
     * occur later in the structure's type name list.
     *)

    val share_failures = ref []
    val old_share_failures = ref []
    val failure_reasons = ref []

    (****
     Handles the sharing of types present in two structures being shared.
     ****)
    
    fun one_type_share(tycon, (tyfun, _), type_offspring, ty_ass, nameset) =
      if Assemblies.inTypeOffspringDomain(tycon, type_offspring) then
	let
	  val (tyfun',_) = Assemblies.lookupTyCon (tycon, type_offspring)
	in
	  Sharetypes.share_tyfun (true,tyfun,tyfun',ty_ass, nameset)
	  handle Sharetypes.ShareError s => 
            (share_failures:=tycon::(!share_failures);
             failure_reasons:= s::(!failure_reasons);
             (true,ty_ass))
        end
      else (true, ty_ass)

    (****
     Make sure that the two structures being shared are consistent.
     ****)

    and str_consistent ([],_,_,str_ass,ty_ass,_) = (true,str_ass,ty_ass)
      | str_consistent (strid::strids,str_offspring,str_offspring',str_ass,
			ty_ass,nameset) =
	let
	  val (strshare_successful,str_ass',ty_ass') = 
	    if Assemblies.inStrOffspringDomain(strid, str_offspring') then 
	      share_str(#1 (Assemblies.lookupStrId (strid,str_offspring)),
			#1 (Assemblies.lookupStrId (strid,str_offspring')),
			str_ass,ty_ass,nameset)
	    else (true,str_ass,ty_ass)
	  val (strshare_successful',str_ass'',ty_ass') = 
	    str_consistent (strids,str_offspring,str_offspring',str_ass',
			    ty_ass',nameset)
	in
	  if strshare_successful andalso strshare_successful' then
	    (true,str_ass'',ty_ass')
	  else (false,str_ass,ty_ass)
	end 
      
    and consistent (name,name',str_ass,ty_ass,nameset) =
        let
	   val (str_offspring,type_offspring) = 
	     Assemblies.lookupStrname (name,str_ass)
	   val stridlist = Assemblies.getStrIds str_offspring 
	   val tyconlist = Assemblies.getTyCons type_offspring
	   val (str_offspring',type_offspring') = 
	     Assemblies.lookupStrname (name',str_ass)
	   val (strshare_successful,str_ass',ty_ass') = 
	     str_consistent (stridlist,str_offspring,str_offspring',
			     str_ass,ty_ass,nameset)

           val _ = old_share_failures:=[]

            (* see comment above the old_share_failures declaration
             * above for a rationale for the findFixpoint function.
             *)
        
           fun findFixpoint () =
             (share_failures:=[];
              failure_reasons:=[];
              let val answer =
                NewMap.fold
                (fn (res as (ok, ty_ass), tycon, ran) =>
                 if ok then
                   one_type_share(tycon, ran, type_offspring', ty_ass, nameset)
                 else res)
                ((true, ty_ass'),Assemblies.getTypeOffspringMap type_offspring)
              in
                if !old_share_failures = !share_failures
                  then (* finished *)
                    if !share_failures=[]
                      then answer
                    else
                      let
                        fun makeE([],[]) = ""
                          | makeE([h1],[h2]) =
                              (IdentPrint.printTyCon h1)^": "^h2^"}"
                          | makeE(h1::t1,h2::t2) =
                              (IdentPrint.printTyCon h1)^": "^h2^"\n    "^
                              (makeE(t1,t2))
                          | makeE _ = Crash.impossible "makeE"
                          
                        fun makeErrorMesg() =
                          if Lists.length (!share_failures)=1
                            then 
                              ("Cannot share types with type constructor " ^
                               (IdentPrint.printTyCon
                                (Lists.hd(!share_failures))) ^ ": " ^ 
                               (Lists.hd(!failure_reasons)))
                          else
                            "Cannot share types with type constructors\n   {"^
                            makeE(!share_failures,!failure_reasons)
                      in
                        raise ShareError (makeErrorMesg())
                      end
                           
                else (old_share_failures:= !share_failures;
                      findFixpoint())
              end)

           val (tyshare_successful,ty_ass'') = findFixpoint()
        in
	   if strshare_successful andalso tyshare_successful then
	     (true,str_ass',ty_ass'')
	   else (false,str_ass,ty_ass)
        end

    (****
     To ensure that the structure assembly is updated correctly the entries
     corresponding to the strnames being shared are first removed from the 
     structure assembly (once it has been determined that the sharing is 
     possible), then the references are updated (sharing done), and 
     then they are both added to the structure assembly again. 
     There is a general problem here to do with sharing functor results with
     functor arguments. This is becase functor arguments look flexible, and
     so we may end up with functor arguments being side effected when we don't
     require it.
     ****)

    and share_str' (name as METASTRNAME (r as ref (NULLNAME _)),
		    name' as METASTRNAME (r' as ref (NULLNAME _)),
		    str_ass,ty_ass,nameset) =
      if Strnames.strname_eq (name, name') then
	(true,str_ass,ty_ass)
      else
	let
	  val (consist,str_ass',ty_ass') = 
	    consistent (name,name',str_ass,ty_ass,nameset) 
	in
	  if consist then
	    let
	      val (str_offspring,type_offspring) =
		Assemblies.lookupStrname (name,str_ass')
	      val (str_offspring',type_offspring') =
		Assemblies.lookupStrname (name',str_ass')
	      val str_ass'' = Assemblies.remfromStrAssembly 
		(name,Assemblies.remfromStrAssembly (name',str_ass'))
	    in
	      (* Here we should check if either name or name' is in nameset *)
	      (if Nameset.member_of_strnames(name, nameset) then
		 r' := name
	       else
		r := name');
	      (true,
	       Assemblies.add_to_StrAssembly 
	       (name, str_offspring, type_offspring,
		Assemblies.add_to_StrAssembly 
		(name', str_offspring', type_offspring',
		 str_ass'')),
	       ty_ass')
	    end
	  else 
            (* I think another error always occurs before this *)
	    raise ShareError "impossible type error 17: structures are not consistent"
	end
      | share_str' (name as METASTRNAME (r as ref (NULLNAME _)),
		   name',str_ass,ty_ass,nameset) = 
        let
          val (consist,str_ass',ty_ass') = 
            consistent (name,name',str_ass,ty_ass,nameset)
        in
          if consist then
            (****
             name' is a rigid structure name.
             ****)
            if cover (name',name,str_ass',nameset) then
              let
                val (str_offspring,type_offspring) =
                  Assemblies.lookupStrname (name,str_ass')
                val str_ass'' = Assemblies.remfromStrAssembly (name,
                                                               str_ass')
              in
                (r := name';
                 (true,
                  Assemblies.add_to_StrAssembly 
                  (name,str_offspring,type_offspring,
                   str_ass''),ty_ass'))
              end
            else 
              raise ShareError "Basis does not cover structure"
          else
            raise ShareError "impossible type error 18: structures are not consistent"
        end
      | share_str' (name,name' as METASTRNAME (r as ref (NULLNAME _)),
		    str_ass,ty_ass,nameset) =
	let
	  val (consist,str_ass',ty_ass') =
	    consistent (name,name',str_ass,ty_ass,nameset)
	in
	  if consist then
	    (****
	     name is a rigid structure name.
	     ****)
	    if cover (name,name',str_ass',nameset) then
	      let
		val (str_offspring,type_offspring) =
		  Assemblies.lookupStrname (name',str_ass')
		val str_ass'' = Assemblies.remfromStrAssembly (name',
							       str_ass')
	      in
		(r := name;
		 (true,
		  Assemblies.add_to_StrAssembly 
		  (name',str_offspring,type_offspring,
		   str_ass''),ty_ass'))
	      end
	    else 
	      raise ShareError "Basis does not cover structure"
	  else
	    raise ShareError "impossible type error 19: structures are not consistent"
	end
      | share_str' (name,name',str_ass,ty_ass,_) =
        if Strnames.strname_eq (name,name') then
          (true,str_ass,ty_ass)
        else
          raise ShareError "Rigid structures are not equal"

    (****
     Make sure that sharing the two structures will not violate covering.
     See The Definition p. 35.
     ****)

   and cover (name,name' as METASTRNAME (ref (NULLNAME _)),str_ass,nameset) =
     let
       val (str_offspring,type_offspring) = 
         Assemblies.lookupStrname (name,str_ass)
       val (str_offspring',type_offspring') = 
         Assemblies.lookupStrname (name',str_ass)
     in
       if Nameset.member_of_strnames (name,nameset) then
         let
           val stridlist = Assemblies.getStrIds str_offspring
           val tyconlist = Assemblies.getTyCons type_offspring
           val stridlist' = Assemblies.getStrIds str_offspring'
           val tyconlist' = Assemblies.getTyCons type_offspring'
         in
           ordered_sublist (stridlist',stridlist) andalso 
           ordered_sublist (tyconlist',tyconlist)
         end
       else true
     end
     | cover _ = Crash.impossible "cover bad parameters"

    and share_str(name,name',str_ass,ty_ass,nameset) =
      let
	val name = Strnames.strip name
	val name' = Strnames.strip name'
      in
	if Nameset.member_of_strnames(name, nameset) andalso
	  Nameset.member_of_strnames(name', nameset) then
	  (* This is to catch the case that the names are functor parameters *)
	  (* and are trying to be shared by the functor result *)
	  if Strnames.strname_eq (name, name') then
	    (true,str_ass,ty_ass)
	  else
	    raise ShareError "Rigid structures are not equal"
	else
	  share_str'(name, name',str_ass,ty_ass, nameset)
      end
	
  end
@


1.25.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.25  1997/04/08  14:51:10  andreww
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
@


1.25.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.25  1997/04/08  14:51:10  andreww
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
@


1.25.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.25  1997/04/08  14:51:10  andreww
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
@


1.24
log
@Updating for new language revisions
@
text
@d3 3
d128 16
d147 1
a147 1

d154 5
a158 4
	  handle Sharetypes.ShareError s => raise ShareError 
	    ("Cannot share types with type constructor " ^ 
	     (IdentPrint.printTyCon tycon) ^ ": " ^ s)
	end
d195 52
a246 8
	   val (tyshare_successful,ty_ass'') =
	     NewMap.fold
	     (fn (res as (ok, ty_ass), tycon, ran) =>
	      if ok then
		one_type_share(tycon, ran, type_offspring', ty_ass, nameset)
	      else res)
	     ((true, ty_ass'),Assemblies.getTypeOffspringMap type_offspring)
	 in
d250 1
a250 1
	 end
@


1.24.8.1
log
@branched from 1.24
@
text
@a2 3
 * Revision 1.24  1996/03/28  10:20:09  matthew
 * Updating for new language revisions
 *
@


1.24.8.2
log
@[Bug #2033]
making sure type dependencies are shared in correct order.
@
text
@a2 7
 * Revision 1.24.8.1  1997/05/12  10:51:14  hope
 * branched from 1.24
 *
 * Revision 1.25  1997/04/08  14:51:10  andreww
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
a127 16
    (* Note, the following three "global references" are initialised
     * by the function "findFixedpoint" below, and updated by the
     * function "one_type_share" immediately below.  The idea is that
     * when trying to share types in structures, we keep a track of
     * those types which cannot be shared.  Perhaps one of them cannot
     * be shared because it depends on a type which will be shared later.
     * Thus, we repeat the process until !old_share_failures and
     * !share_failures are equal, in which case we know that any remaining
     * type sharing errors cannot be resolved by sharing types that may
     * occur later in the structure's type name list.
     *)

    val share_failures = ref []
    val old_share_failures = ref []
    val failure_reasons = ref []

d131 1
a131 1
    
d138 4
a141 5
	  handle Sharetypes.ShareError s => 
            (share_failures:=tycon::(!share_failures);
             failure_reasons:= s::(!failure_reasons);
             (true,ty_ass))
        end
d178 8
a185 52

           val _ = old_share_failures:=[]

            (* see comment above the old_share_failures declaration
             * above for a rationale for the findFixpoint function.
             *)
        
           fun findFixpoint () =
             (share_failures:=[];
              failure_reasons:=[];
              let val answer =
                NewMap.fold
                (fn (res as (ok, ty_ass), tycon, ran) =>
                 if ok then
                   one_type_share(tycon, ran, type_offspring', ty_ass, nameset)
                 else res)
                ((true, ty_ass'),Assemblies.getTypeOffspringMap type_offspring)
              in
                if !old_share_failures = !share_failures
                  then (* finished *)
                    if !share_failures=[]
                      then answer
                    else
                      let
                        fun makeE([],[]) = ""
                          | makeE([h1],[h2]) =
                              (IdentPrint.printTyCon h1)^": "^h2^"}"
                          | makeE(h1::t1,h2::t2) =
                              (IdentPrint.printTyCon h1)^": "^h2^"\n    "^
                              (makeE(t1,t2))
                          | makeE _ = Crash.impossible "makeE"
                          
                        fun makeErrorMesg() =
                          if Lists.length (!share_failures)=1
                            then 
                              ("Cannot share types with type constructor " ^
                               (IdentPrint.printTyCon
                                (Lists.hd(!share_failures))) ^ ": " ^ 
                               (Lists.hd(!failure_reasons)))
                          else
                            "Cannot share types with type constructors\n   {"^
                            makeE(!share_failures,!failure_reasons)
                      in
                        raise ShareError (makeErrorMesg())
                      end
                           
                else (old_share_failures:= !share_failures;
                      findFixpoint())
              end)

           val (tyshare_successful,ty_ass'') = findFixpoint()
        in
d189 1
a189 1
        end
@


1.24.8.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 4
 * Revision 1.24.8.2  1997/05/12  16:03:28  daveb
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
@


1.24.8.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 4
 * Revision 1.24.8.2  1997/05/12  16:03:28  daveb
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
@


1.24.8.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 4
 * Revision 1.24.8.2  1997/05/12  16:03:28  daveb
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
@


1.24.8.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.24.8.2.1.1  1997/07/28  18:34:34  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.24.7.1
log
@branched from 1.24
@
text
@a2 3
 * Revision 1.24  1996/03/28  10:20:09  matthew
 * Updating for new language revisions
 *
@


1.24.6.1
log
@branched from 1.24
@
text
@a2 3
 * Revision 1.24  1996/03/28  10:20:09  matthew
 * Updating for new language revisions
 *
@


1.24.6.1.1.1
log
@branched from 1.24.6.1
@
text
@a2 3
 * Revision 1.24.6.1  1996/12/17  18:17:39  hope
 * branched from 1.24
 *
@


1.24.5.1
log
@branched from 1.24
@
text
@a2 3
 * Revision 1.24  1996/03/28  10:20:09  matthew
 * Updating for new language revisions
 *
@


1.24.4.1
log
@branched from 1.24
@
text
@a2 3
 * Revision 1.24  1996/03/28  10:20:09  matthew
 * Updating for new language revisions
 *
@


1.24.4.1.1.1
log
@branched from 1.24.4.1
@
text
@a2 3
 * Revision 1.24.4.1  1996/11/14  13:20:53  hope
 * branched from 1.24
 *
@


1.24.3.1
log
@branched from 1.24
@
text
@a2 3
 * Revision 1.24  1996/03/28  10:20:09  matthew
 * Updating for new language revisions
 *
@


1.24.2.1
log
@branched from 1.24
@
text
@a2 3
 * Revision 1.24  1996/03/28  10:20:09  matthew
 * Updating for new language revisions
 *
@


1.24.1.1
log
@branched from 1.24
@
text
@a2 3
 * Revision 1.24  1996/03/28  10:20:09  matthew
 * Updating for new language revisions
 *
@


1.23
log
@Removing debug stuff
@
text
@d3 3
d134 1
a134 1
	  Sharetypes.share_tyfun (tyfun,tyfun',ty_ass, nameset)
@


1.22
log
@Capitalize error messages.
@
text
@d3 3
a75 1
require "../typechecker/ty_debug";
a86 1
  structure Ty_Debug : TY_DEBUG
a91 5
  structure Debug :
    sig
      val set_debug_level : int -> unit
      val debug_level : unit -> int
    end
a104 1
    val do_debug = Ty_Debug.do_debug
d127 1
a127 1
      if Assemblies.InTypeOffspringDomain(tycon, type_offspring) then
d147 1
a147 1
	    if Assemblies.InStrOffspringDomain(strid, str_offspring') then 
d162 1
a162 4
      (if (do_debug andalso Debug.debug_level () > 10) then
	 (Print.print ("Share.consistent \n"))
       else ();
	 let
d183 1
a183 1
	 end)
a199 6
      (if do_debug andalso Debug.debug_level () > 10 then
	 (Print.print ("share_str' 1\n");
	  Print.print ((Strnames.string_strname name) ^ "\n");
	  Print.print ((Strnames.string_strname name') ^ "\n");
	  Print.print ("\n"))
       else ();
d232 1
a232 1
	end)
d235 26
a260 32
	(if (do_debug andalso Debug.debug_level () > 10) then
	   (Print.print ("share_str' 2 \n");
	    Print.print ((Strnames.string_strname name) ^ "\n");
	    Print.print ((Strnames.string_strname name') ^ "\n");
	    Print.print ("\n"))
	 else ();
	   let
	     val (consist,str_ass',ty_ass') = 
	       consistent (name,name',str_ass,ty_ass,nameset)
	   in
	     if consist then
	       (****
		name' is a rigid structure name.
		****)
	       if cover (name',name,str_ass',nameset) then
		 let
		   val (str_offspring,type_offspring) =
		     Assemblies.lookupStrname (name,str_ass')
		   val str_ass'' = Assemblies.remfromStrAssembly (name,
								  str_ass')
		 in
		   (r := name';
		    (true,
		     Assemblies.add_to_StrAssembly 
		     (name,str_offspring,type_offspring,
		      str_ass''),ty_ass'))
		 end
	       else 
		 raise ShareError "Basis does not cover structure"
	   else
	     raise ShareError "impossible type error 18: structures are not consistent"
	   end)
a262 6
	(if (do_debug andalso Debug.debug_level () > 10) then
	   (Print.print ("share_str' 3 \n");
	    Print.print ((Strnames.string_strname name) ^ "\n");
	    Print.print ((Strnames.string_strname name') ^ "\n");
	    Print.print ("\n"))
	 else ();
d288 1
a288 1
	end)
d290 4
a293 10
	(if (do_debug andalso Debug.debug_level () > 10) then
	   (Print.print ("share_str' 6 \n");
	    Print.print ((Strnames.string_strname name) ^ "\n");
	    Print.print ((Strnames.string_strname name') ^ "\n");
	    Print.print ("\n"))
	 else ();
	   if Strnames.strname_eq (name,name') then
	     (true,str_ass,ty_ass)
	   else
	     raise ShareError "Rigid structures are not equal")
d301 19
a319 29
     (if do_debug andalso Debug.debug_level ()> 10 then
	(Print.print (" cover... ");
	 Print.print (" name = " ^ Strnames.string_strname name);
	 Print.print (" name' = " ^ Strnames.string_strname name');
	 Print.print ("\n"))
      else ();
	let
	  val (str_offspring,type_offspring) = 
	    Assemblies.lookupStrname (name,str_ass)
	  val (str_offspring',type_offspring') = 
	    Assemblies.lookupStrname (name',str_ass)
	in
	  if Nameset.member_of_strnames (name,nameset) then
	    (if do_debug andalso Debug.debug_level () > 10 then 
	       (Print.print (" name is in nameset");
		Print.print ("\n"))
	     else ();
	       let
		 val stridlist = Assemblies.getStrIds str_offspring
		 val tyconlist = Assemblies.getTyCons type_offspring
		 val stridlist' = Assemblies.getStrIds str_offspring'
		 val tyconlist' = Assemblies.getTyCons type_offspring'
	       in
		 ordered_sublist (stridlist',stridlist) andalso 
		 ordered_sublist (tyconlist',tyconlist)
	       end)
	  else true
	end)
      | cover _ = Crash.impossible "cover bad parameters"
@


1.21
log
@Marked certain error messages as "impossible".
@
text
@d3 3
d277 1
a277 1
		 raise ShareError "basis does not cover structure"
d311 1
a311 1
	      raise ShareError "basis does not cover structure"
d325 1
a325 1
	     raise ShareError "rigid structures are not equal")
d375 1
a375 1
	    raise ShareError "rigid structures are not equal"
@


1.20
log
@Some tidying up
@
text
@d3 3
d242 1
a242 1
	    raise ShareError "structures are not consistent"
d276 1
a276 1
	     raise ShareError "structures are not consistent"
d310 1
a310 1
	    raise ShareError "structures are not consistent"
@


1.20.1.1
log
@Fork for bug fixing
@
text
@a2 3
Revision 1.20  1993/06/25  19:27:37  jont
Some tidying up

@


1.19
log
@Changes because Assemblies now has Basistypes instead of Datatypes
@
text
@d3 3
a136 23
    fun type_share([],_,_,ty_ass, nameset) = (true,ty_ass)
      | type_share(tycon::tycons,type_offspring,type_offspring',ty_ass, nameset) =
	(if (do_debug andalso Debug.debug_level () > 10) then
	   (Print.print ("Share.type_share ");
	    Print.print (IdentPrint.printTyCon tycon);
	    Print.print ("\n"))
	 else ();
	   if Assemblies.InTypeOffspringDomain(tycon, type_offspring') then
	     let
	       val (tyfun,_) = Assemblies.lookupTyCon (tycon,type_offspring)
	       val (tyfun',_) = Assemblies.lookupTyCon (tycon,type_offspring')
	       val (share_successful,ty_ass') = 
		 Sharetypes.share_tyfun (tyfun,tyfun',ty_ass, nameset)
		 handle Sharetypes.ShareError s => raise ShareError 
		   ("Cannot share types with type constructor " ^ 
		    (IdentPrint.printTyCon tycon) ^ ": " ^ s)
	     in
	       if share_successful then
		 type_share(tycons,type_offspring,type_offspring',ty_ass', nameset)
	       else (false,ty_ass)
	     end
	   else type_share(tycons,type_offspring,type_offspring',ty_ass, nameset))
	   
d138 1
a138 1
     Make sure that the two structures being shared is consistent.
d202 2
a203 2
      (if (do_debug andalso Debug.debug_level () > 10) then
	 (Print.print ("share_str' 1 \n");
@


1.18
log
@Changed name to name'
@
text
@d3 3
a68 2
require "basistypes";

a79 1
  structure BasisTypes : BASISTYPES
d87 2
a88 2
  sharing Sharetypes.Assemblies.Datatypes = Valenv.Datatypes = 
    Nameset.Datatypes = Strnames.Datatypes = BasisTypes.Datatypes
d91 1
a91 1
  sharing type BasisTypes.Nameset = Nameset.Nameset = Sharetypes.NamesetTypes.Nameset
d96 2
a97 1
    structure BasisTypes = BasisTypes
a98 1
    structure Assemblies = Sharetypes.Assemblies
@


1.17
log
@Fixed up to check for illegal sharing in functor result signatures
ie trying to force extra sharing on the functor parameter
@
text
@d3 4
d383 1
a383 1
	  Nameset.member_of_strnames(name, nameset) then
@


1.16
log
@Avoid updating flexible names in the basis (when doing sharng in functor results)
@
text
@d3 3
d373 16
a388 3
    and share_str (name,name',str_ass,ty_ass,nameset) =
      share_str' (Strnames.strip name,Strnames.strip name',str_ass,ty_ass,
		  nameset)
@


1.15
log
@Nameset signature changes
@
text
@d3 3
d84 1
a84 1
  sharing type BasisTypes.Nameset = Nameset.Nameset
d115 1
a115 1
    fun one_type_share (tycon, (tyfun, _), type_offspring, ty_ass) =
d120 1
a120 1
	  Sharetypes.share_tyfun (tyfun,tyfun',ty_ass)
d127 2
a128 2
    fun type_share ([],_,_,ty_ass) = (true,ty_ass)
      | type_share (tycon::tycons,type_offspring,type_offspring',ty_ass) =
d139 1
a139 1
		 Sharetypes.share_tyfun (tyfun,tyfun',ty_ass)
d145 1
a145 1
		 type_share (tycons,type_offspring,type_offspring',ty_ass')
d148 1
a148 1
	   else type_share (tycons,type_offspring,type_offspring',ty_ass))
d191 1
a191 1
		one_type_share (tycon, ran, type_offspring', ty_ass)
d206 4
d213 1
a213 1
		    name' as METASTRNAME (ref (NULLNAME _)),
d221 1
a221 1
      if Strnames.strname_eq (name,name') then
d224 3
a226 2
	let val (consist,str_ass',ty_ass') = 
	  consistent (name,name',str_ass,ty_ass,nameset) 
d237 8
a244 2
	      (r := name';
	       (true,
d246 3
a248 5
		(Strnames.strip name,str_offspring,type_offspring,
		 Assemblies.add_to_StrAssembly 
		 (Strnames.strip name',str_offspring',type_offspring',
		  str_ass'')),
		ty_ass'))
d252 1
a252 2
	    raise ShareError
	      "structures are not consistent"
d280 1
a280 1
		     (Strnames.strip name,str_offspring,type_offspring,
d314 1
a314 1
		  (Strnames.strip name',str_offspring,type_offspring,
@


1.14
log
@Changes for BASISTYPES signature
@
text
@d3 3
d56 2
d69 1
a71 3
  sharing Sharetypes.Assemblies.Datatypes = Valenv.Datatypes = 
    Nameset.BasisTypes.Datatypes = Strnames.Datatypes
  sharing IdentPrint.Ident = Valenv.Datatypes.Ident
d76 8
a83 1
    end) : SHARE = 
d86 1
a86 1
    structure BasisTypes = Nameset.BasisTypes
@


1.13
log
@Anel's last changes
@
text
@d3 3
d67 1
a67 1
    Nameset.Datatypes = Strnames.Datatypes
d76 2
@


1.12
log
@Changed error messages.
@
text
@d3 3
d97 1
a97 1
    fun one_type_share(tycon, (tyfun, _), type_offspring, ty_ass) =
d100 1
a100 2
	  val (tyfun',_) = 
	    Assemblies.lookupTyCon (tycon, type_offspring)
d107 1
a107 2
      else
	(true, ty_ass)
d114 1
a114 6
	    Print.print ("\n")
	 (*Print.print ("type_offspring = " ^ 
	  (Assemblies.stringTypeOffspring type_offspring));
	  Print.print ("type_offspring' = " ^ 
	  (Assemblies.stringTypeOffspring 
	  type_offspring'))*))
a115 5
(*
	   let 
	     val tyconlist = Assemblies.getTyCons type_offspring'
	   in
*)
d118 2
a119 4
	       val (tyfun,_) = 
		 Assemblies.lookupTyCon (tycon,type_offspring)
	       val (tyfun',_) = 
		 Assemblies.lookupTyCon (tycon,type_offspring')
d127 2
a128 4
		 type_share (tycons,type_offspring,type_offspring',
			     ty_ass')
	       else
		 (false,ty_ass)
d130 1
a130 3
	   else
	     type_share (tycons,type_offspring,type_offspring',ty_ass)
	     )
d145 1
a145 2
	    else
	      (true,str_ass,ty_ass)
d152 1
a152 2
	  else
	    (false,str_ass,ty_ass)
d173 3
a175 4
		one_type_share(tycon, ran, type_offspring', ty_ass)
	      else
		res)
	     ((true, ty_ass'), Assemblies.getTypeOffspringMap type_offspring)
d179 1
a179 2
	   else 
	     (false,str_ass,ty_ass)
d191 2
a192 2
		   name' as METASTRNAME (ref (NULLNAME _)),
		   str_ass,ty_ass,nameset) =
a227 1
(*
a228 20
		   name' as METASTRNAME (ref name''),str_ass,ty_ass,nameset) =
	(if (do_debug andalso Debug.debug_level () > 10) then
	   (Print.print ("share_str' 1b \n");
	    Print.print ((Strnames.string_strname name) ^ "\n");
	    Print.print ((Strnames.string_strname name') ^ "\n");
	    Print.print ("\n"))
	 else ();
	   share_str' (name,name'',str_ass,ty_ass,nameset))
      | share_str' (name as METASTRNAME (ref name'),
		   name'' as METASTRNAME (r as ref (NULLNAME _)),
		   str_ass,ty_ass,nameset) =
	(if (do_debug andalso Debug.debug_level () > 10) then
	   (Print.print ("share_str' 1c \n");
	    Print.print ((Strnames.string_strname name) ^ "\n");
	    Print.print ((Strnames.string_strname name'') ^ "\n");
	    Print.print ("\n"))
	 else ();
	   share_str' (name',name'',str_ass,ty_ass,nameset))
*)
      | share_str' (name as METASTRNAME (r as ref (NULLNAME _)),
d258 1
a258 1
		 raise ShareError ("basis does not cover structure")
d260 1
a260 2
	     raise ShareError 
	       ("structures are not consistent")
d263 1
a263 1
		   str_ass,ty_ass,nameset) =
d292 1
a292 1
	      raise ShareError ("basis does not cover structure")
d294 1
a294 2
	    raise ShareError 
	      ("structures are not consistent")
a295 18
(*
      | share_str' (METASTRNAME (ref name),name',str_ass,ty_ass,nameset) =
	(if (do_debug andalso Debug.debug_level () > 10) then
	   (Print.print ("share_str' 4 \n");
	    Print.print ((Strnames.string_strname name) ^ "\n");
	    Print.print ((Strnames.string_strname name') ^ "\n");
	    Print.print ("\n"))
	 else ();
	   share_str' (name,name',str_ass,ty_ass,nameset))
      | share_str' (name,METASTRNAME (ref name'),str_ass,ty_ass,nameset) =
	(if (do_debug andalso Debug.debug_level () > 10) then
	   (Print.print ("share_str' 5 \n");
	    Print.print ((Strnames.string_strname name) ^ "\n");
	    Print.print ((Strnames.string_strname name') ^ "\n");
	    Print.print ("\n"))
	 else ();
	   share_str' (name,name',str_ass,ty_ass,nameset))
*)
d306 1
a306 2
	     raise ShareError 
	       "rigid structures are not equal")
d342 1
a342 1
      | cover _ = Crash.impossible"cover bad parameters"
d344 3
a346 3
    and share_str(name, name', str_ass, ty_ass, nameset) =
      share_str'(Strnames.strip name, Strnames.strip name', str_ass, ty_ass,
		nameset)
@


1.11
log
@Error message revisions.
@
text
@d3 3
d103 1
a103 1
	     (IdentPrint.printTyCon tycon) ^ " because they have " ^ s)
d135 1
a135 1
		    (IdentPrint.printTyCon tycon) ^ " because they have " ^ s)
d243 1
@


1.10
log
@"they" => "they have"
@
text
@d3 3
d241 1
a241 1
	      "structures are not consistent\n"
d294 1
a294 1
		 raise ShareError ("basis does not cover structure\n")
d297 1
a297 1
	       ("structures are not consistent\n")
d329 1
a329 1
	      raise ShareError ("basis does not cover structure\n")
d332 1
a332 1
	      ("structures are not consistent\n")
d363 1
a363 1
	       "rigid structures are not equal\n")
@


1.9
log
@Removed has_a_new_name, no longer needed
@
text
@d3 3
d97 1
a97 1
	     (IdentPrint.printTyCon tycon) ^ " because they " ^ s)
d129 1
a129 1
		    (IdentPrint.printTyCon tycon) ^ " because they " ^ s)
@


1.8
log
@Various improvements to remove garbage, handlers etc.
@
text
@d3 3
d148 3
a150 3
	      share_str (#1 (Assemblies.lookupStrId (strid,str_offspring)),
			 #1 (Assemblies.lookupStrId (strid,str_offspring')),
			 str_ass,ty_ass,nameset)
a169 5
(*
	     handle Assemblies.LookupStrname => 
	       (Assemblies.empty_str_offspring,
		Assemblies.empty_type_offspring)
*)
a173 5
(*
	     handle Assemblies.LookupStrname => 
	       (Assemblies.empty_str_offspring,
		Assemblies.empty_type_offspring)
*)
a176 1
(*
a177 2
*)
	   val (tyshare_successful,ty_ass'') =
a184 3
(*
	     type_share (tyconlist,type_offspring,type_offspring',ty_ass')
*)
d200 1
a200 1
    and share_str (name as METASTRNAME (r as ref (NULLNAME _)),
d204 1
a204 1
	 (Print.print ("share_str 1 \n");
a218 5
(*
		handle Assemblies.LookupStrname => 
		  (Assemblies.empty_str_offspring,
		   Assemblies.empty_type_offspring)
*)
a220 5
(*
		handle Assemblies.LookupStrname => 
		  (Assemblies.empty_str_offspring,
		   Assemblies.empty_type_offspring)
*)
d237 2
a238 1
      | share_str (name as METASTRNAME (r as ref (NULLNAME _)),
d241 1
a241 1
	   (Print.print ("share_str 1b \n");
d246 2
a247 2
	   share_str (name,name'',str_ass,ty_ass,nameset))
      | share_str (name as METASTRNAME (ref name'),
d251 1
a251 1
	   (Print.print ("share_str 1c \n");
d256 3
a258 2
	   share_str (name',name'',str_ass,ty_ass,nameset))
      | share_str (name as METASTRNAME (r as ref (NULLNAME _)),
d261 1
a261 1
	   (Print.print ("share_str 2 \n");
a277 5
(*
		     handle Assemblies.LookupStrname => 
		       (Assemblies.empty_str_offspring,
			Assemblies.empty_type_offspring)
*)
d293 1
a293 1
      | share_str (name,name' as METASTRNAME (r as ref (NULLNAME _)),
d296 1
a296 1
	   (Print.print ("share_str 3 \n");
a312 5
(*
		  handle Assemblies.LookupStrname => 
		    (Assemblies.empty_str_offspring,
		     Assemblies.empty_type_offspring)
*)
d328 2
a329 1
      | share_str (METASTRNAME (ref name),name',str_ass,ty_ass,nameset) =
d331 1
a331 1
	   (Print.print ("share_str 4 \n");
d336 2
a337 2
	   share_str (name,name',str_ass,ty_ass,nameset))
      | share_str (name,METASTRNAME (ref name'),str_ass,ty_ass,nameset) =
d339 1
a339 1
	   (Print.print ("share_str 5 \n");
d344 3
a346 2
	   share_str (name,name',str_ass,ty_ass,nameset))
      | share_str (name,name',str_ass,ty_ass,_) =
d348 1
a348 1
	   (Print.print ("share_str 6 \n");
d357 1
a357 1
	       "two rigid structures are not equal\n")
a373 5
(*
	    handle Assemblies.LookupStrname => 
	      (Assemblies.empty_str_offspring,
	       Assemblies.empty_type_offspring)
*)
a375 5
(*
	    handle Assemblies.LookupStrname => 
	      (Assemblies.empty_str_offspring,
	       Assemblies.empty_type_offspring)
*)
d395 4
@


1.7
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d3 4
d68 8
d82 14
d98 9
a106 9
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("Share.type_share ");
		 Print.print (IdentPrint.printTyCon tycon);
		 Print.print ("\n")
		 (*Print.print ("type_offspring = " ^ 
			      (Assemblies.stringTypeOffspring type_offspring));
		 Print.print ("type_offspring' = " ^ 
			      (Assemblies.stringTypeOffspring 
			       type_offspring'))*))
d108 1
d112 23
a134 24
	     if Lists.member (tycon,tyconlist) 
	       then
		 let
		   val (tyfun,_) = 
		     Assemblies.lookupTyCon (tycon,type_offspring)
		   val (tyfun',_) = 
		     Assemblies.lookupTyCon (tycon,type_offspring')
		   val (share_successful,ty_ass') = 
		     Sharetypes.share_tyfun (tyfun,tyfun',ty_ass)
		     handle Sharetypes.ShareError s => raise ShareError 
		       ("Cannot share types with type constructor " ^ 
			(IdentPrint.printTyCon tycon) ^ " because they " ^ s)
		 in
		   if share_successful
		     then
		       type_share (tycons,type_offspring,type_offspring',
				   ty_ass')
		   else
		     (false,ty_ass)
		 end
	     else
	       type_share (tycons,type_offspring,type_offspring',ty_ass)
	   end)

a142 1
	  val stridlist = Assemblies.getStrIds str_offspring'
d144 4
a147 5
	    if Lists.member (strid,stridlist) 
	      then 
		share_str (#1 (Assemblies.lookupStrId (strid,str_offspring)),
			   #1 (Assemblies.lookupStrId (strid,str_offspring')),
			   str_ass,ty_ass,nameset)
d154 2
a155 3
	  if strshare_successful andalso strshare_successful'
	    then
	      (true,str_ass'',ty_ass')
d161 2
a162 2
      (if (do_debug andalso Debug.debug_level () > 10)
	 then (Print.print ("Share.consistent \n"))
d167 1
d171 1
d176 1
d180 1
d184 12
a195 1
	   val (tyshare_successful,ty_ass'') = 
d197 1
d199 2
a200 2
	   if strshare_successful andalso tyshare_successful
	     then (true,str_ass',ty_ass'')
d216 5
a220 5
      (if (do_debug andalso Debug.debug_level () > 10)
	 then (Print.print ("share_str 1 \n");
	       Print.print ((Strnames.string_strname name) ^ "\n");
	       Print.print ((Strnames.string_strname name') ^ "\n");
	       Print.print ("\n"))
d222 2
a223 2
      if Strnames.strname_eq (name,name') 
	then (true,str_ass,ty_ass)
d228 28
a255 25
	  if consist 
	    then 
	      let
		val (str_offspring,type_offspring) =
		  Assemblies.lookupStrname (name,str_ass')
		  handle Assemblies.LookupStrname => 
		    (Assemblies.empty_str_offspring,
		     Assemblies.empty_type_offspring)
		val (str_offspring',type_offspring') =
		  Assemblies.lookupStrname (name',str_ass')
		  handle Assemblies.LookupStrname => 
		    (Assemblies.empty_str_offspring,
		     Assemblies.empty_type_offspring)
		val str_ass'' = Assemblies.remfromStrAssembly 
		  (name,Assemblies.remfromStrAssembly (name',str_ass'))
	      in
		(r := name';
		 (true,
		  Assemblies.add_to_StrAssembly 
		  (Strnames.strip name,str_offspring,type_offspring,
		   Assemblies.add_to_StrAssembly 
		   (Strnames.strip name',str_offspring',type_offspring',
		    str_ass'')),
		  ty_ass'))
	      end
d258 1
a258 1
	    ("structures are not consistent\n")
d262 5
a266 5
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("share_str 1b \n");
		 Print.print ((Strnames.string_strname name) ^ "\n");
		 Print.print ((Strnames.string_strname name') ^ "\n");
		 Print.print ("\n"))
d268 1
a268 1
	share_str (name,name'',str_ass,ty_ass,nameset))
d272 5
a276 5
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("share_str 1c \n");
		 Print.print ((Strnames.string_strname name) ^ "\n");
		 Print.print ((Strnames.string_strname name'') ^ "\n");
		 Print.print ("\n"))
d278 1
a278 1
	share_str (name',name'',str_ass,ty_ass,nameset))
d281 5
a285 5
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("share_str 2 \n");
		 Print.print ((Strnames.string_strname name) ^ "\n");
		 Print.print ((Strnames.string_strname name') ^ "\n");
		 Print.print ("\n"))
d287 5
a291 5
	 let val (consist,str_ass',ty_ass') = 
	   consistent (name,name',str_ass,ty_ass,nameset)
	 in
	   if consist
	     then
d295 18
a312 18
	       if cover (name',name,str_ass',nameset)
		 then
		   let
		     val (str_offspring,type_offspring) =
		       Assemblies.lookupStrname (name,str_ass')
		       handle Assemblies.LookupStrname => 
			 (Assemblies.empty_str_offspring,
			  Assemblies.empty_type_offspring)
		     val str_ass'' = Assemblies.remfromStrAssembly (name,
								    str_ass')
		       
		   in
		     (r := name';
		      (true,
		       Assemblies.add_to_StrAssembly 
		       (Strnames.strip name,str_offspring,type_offspring,
			str_ass''),ty_ass'))
		   end
d318 1
a318 1
	 end)
d321 5
a325 5
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("share_str 3 \n");
		 Print.print ((Strnames.string_strname name) ^ "\n");
		 Print.print ((Strnames.string_strname name') ^ "\n");
		 Print.print ("\n"))
d327 3
a329 2
	let val (consist,str_ass',ty_ass') =
	  consistent (name,name',str_ass,ty_ass,nameset)
d331 24
a354 25
	  if consist 
	    then
	      (****
	       name is a rigid structure name.
	       ****)
	      if cover (name,name',str_ass',nameset) 
		then
		  let
		    val (str_offspring,type_offspring) =
		      Assemblies.lookupStrname (name',str_ass')
		      handle Assemblies.LookupStrname => 
			(Assemblies.empty_str_offspring,
			 Assemblies.empty_type_offspring)
		    val str_ass'' = Assemblies.remfromStrAssembly (name',
								   str_ass')

		  in
		    (r := name;
		     (true,
		      Assemblies.add_to_StrAssembly 
		      (Strnames.strip name',str_offspring,type_offspring,
		       str_ass''),ty_ass'))
		  end
	      else 
		raise ShareError ("basis does not cover structure\n")
d360 5
a364 5
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("share_str 4 \n");
		 Print.print ((Strnames.string_strname name) ^ "\n");
		 Print.print ((Strnames.string_strname name') ^ "\n");
		 Print.print ("\n"))
d366 1
a366 1
	share_str (name,name',str_ass,ty_ass,nameset))
d368 5
a372 5
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("share_str 5 \n");
		 Print.print ((Strnames.string_strname name) ^ "\n");
		 Print.print ((Strnames.string_strname name') ^ "\n");
		 Print.print ("\n"))
d374 1
a374 1
	share_str (name,name',str_ass,ty_ass,nameset))
d376 5
a380 5
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("share_str 6 \n");
		 Print.print ((Strnames.string_strname name) ^ "\n");
		 Print.print ((Strnames.string_strname name') ^ "\n");
		 Print.print ("\n"))
d382 5
a386 5
	if Strnames.strname_eq (name,name')
	  then (true,str_ass,ty_ass)
	else
	  raise ShareError 
	    ("two rigid structures are not equal\n"))
d394 1
a394 1
     (if do_debug andalso Debug.debug_level ()> 10 then 
d400 1
a400 1
	let 
d403 1
d407 1
a407 2
	  val stridlist = Assemblies.getStrIds str_offspring
	  val tyconlist = Assemblies.getTyCons type_offspring
d410 1
d414 1
a414 2
	  val stridlist' = Assemblies.getStrIds str_offspring'
	  val tyconlist' = Assemblies.getTyCons type_offspring'
d416 14
a429 8
	  if Nameset.member_of_strnames (name,nameset)
	    then
	      (if do_debug andalso Debug.debug_level () > 10 then 
		 (Print.print (" name is in nameset");
		  Print.print ("\n"))
	       else ();
		 Lists.sublist (stridlist',stridlist) andalso 
		 Lists.sublist (tyconlist',tyconlist))
@


1.6
log
@Anel's changes to use NewMap instead of Map
@
text
@d3 3
d44 1
a44 1
  sharing Sharetypes.Datatypes = Valenv.Datatypes = 
d46 1
@


1.5
log
@Removed redundant structure argument.
@
text
@d41 2
a42 1
  sharing Sharetypes.Datatypes = Valenv.Datatypes = Nameset.Datatypes = Strnames.Datatypes
d49 1
a49 1
    structure Datatypes = Sharetypes.Datatypes
d211 2
a212 1
	    raise ShareError "structures are not consistent\n"
d339 2
a340 1
	  raise ShareError "two rigid structures are not equal\n")
@


1.4
log
@Anel's fixes
@
text
@d3 3
a23 1
require "../typechecker/datatypes";
a26 1
require "../typechecker/assemblies";
a35 2
  structure Datatypes : DATATYPES
  structure Assemblies : ASSEMBLIES
d41 1
a41 4
  sharing Datatypes = Assemblies.Datatypes = 
    Sharetypes.Datatypes = Valenv.Datatypes = 
    Nameset.Datatypes = Strnames.Datatypes
  sharing Assemblies = Sharetypes.Assemblies
d48 2
a49 2
    structure Datatypes = Datatypes
    structure Assemblies = Assemblies
d210 1
a210 2
	    raise ShareError
	    ("structures are not consistent\n")
d337 1
a337 2
	  raise ShareError 
	    ("two rigid structures are not equal\n"))
@


1.3
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d3 4
d87 1
a87 1
		   val (tyfun,funcount) = 
d89 1
a89 1
		   val (tyfun',funcount') = 
a371 8
	  fun strid_cover ([],_) = true
	    | strid_cover (strid::strids,stridlist) = 
	      Lists.member (strid,stridlist) andalso
	      strid_cover (strids,stridlist)
	  fun tycon_cover ([],_) = true
	    | tycon_cover (tycon::tycons,tyconlist) =
	      Lists.member (tycon,tyconlist) andalso 
	      tycon_cover (tycons,tyconlist)
d379 2
a380 2
		 strid_cover (stridlist',stridlist) andalso 
		 tycon_cover (tyconlist',tyconlist))
@


1.2
log
@Fixed inexhsustive matches
@
text
@d2 4
a5 1
$Log:	_share.sml,v $
d11 1
d16 1
d25 22
a46 18
functor Share (structure Lists : LISTS
	       structure IdentPrint : IDENTPRINT
	       structure Datatypes : DATATYPES
	       structure Assemblies : ASSEMBLIES
	       structure Sharetypes : SHARETYPES
	       structure Valenv : VALENV
	       structure Strnames : STRNAMES
	       structure Nameset : NAMESET
	       structure Print : PRINT
	       structure Crash : CRASH

	       sharing Datatypes = Assemblies.Datatypes = 
		 Sharetypes.Datatypes = Valenv.Datatypes = 
		 Nameset.Datatypes = Strnames.Datatypes
	       sharing Assemblies = Sharetypes.Assemblies
	       structure Debug :  sig val set_debug_level : int -> unit
				      val debug_level : unit -> int
				  end) : SHARE = 
d51 1
d67 1
a67 1
	(if (Debug.debug_level () > 10)
d133 1
a133 1
      (if (Debug.debug_level () > 10)
d172 1
a172 1
      (if (Debug.debug_level () > 10)
d215 1
a215 1
	(if (Debug.debug_level () > 10)
d225 1
a225 1
	(if (Debug.debug_level () > 10)
d234 1
a234 1
	(if (Debug.debug_level () > 10)
d274 1
a274 1
	(if (Debug.debug_level () > 10)
d313 1
a313 1
	(if (Debug.debug_level () > 10)
d321 1
a321 1
	(if (Debug.debug_level () > 10)
d329 1
a329 1
	(if (Debug.debug_level () > 10)
d347 1
a347 1
     (if Debug.debug_level ()> 10 then 
d379 1
a379 1
	      (if Debug.debug_level () > 10 then 
@


1.1
log
@Initial revision
@
text
@d2 5
a6 1
$Log$
d10 1
d29 2
d377 2
@
