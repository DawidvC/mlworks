head	1.26;
access;
symbols
	MLW_daveb_inline_1_4_99:1.26.11
	MLWorks_21c0_1999_03_25:1.26
	MLWorks_20c1_1998_08_20:1.26
	MLWorks_20c0_1998_08_04:1.26
	MLWorks_20b2c2_1998_06_19:1.26
	MLWorks_20b2_Windows_1998_06_12:1.26
	MLWorks_20b1c1_1998_05_07:1.26
	MLWorks_20b0_1998_04_07:1.26
	MLWorks_20b0_1998_03_20:1.26
	MLWorks_20m2_1998_02_16:1.26
	MLWorks_20m1_1997_10_23:1.26
	MLWorks_11r1:1.26.8.1.1.1.1
	MLWorks_workspace_97:1.26.10
	MLWorks_dt_wizard:1.26.9
	MLWorks_11c0_1997_09_09:1.26.8.1.1.1
	MLWorks_10r3:1.26.8.1.3
	MLWorks_10r2_551:1.26.8.1.2
	MLWorks_11:1.26.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.26.8.1
	MLWorks_20m0_1997_06_20:1.26
	MLWorks_1_0_r2c2_1997_06_14:1.26.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.26.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.26.8
	MLWorks_BugFix_1997_04_24:1.26
	MLWorks_1_0_r2_Win32_1997_04_11:1.26
	MLWorks_1_0_r2_Unix_1997_04_04:1.26
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.26.6.1.1
	MLWorks_gui_1996_12_18:1.26.7
	MLWorks_1_0_Win32_1996_12_17:1.26.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.26.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.26.4.1
	MLWorks_1_0_Irix_1996_11_28:1.26.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.26.5
	MLWorks_1_0_Unix_1996_11_14:1.26.4
	MLWorks_Open_Beta2_1996_10_11:1.26.3
	MLWorks_License_dev:1.26.2
	MLWorks_1_open_beta_1996_09_13:1.26.1
	MLWorks_Open_Beta_1996_08_22:1.26
	MLWorks_Beta_1996_07_02:1.26
	MLWorks_Beta_1996_06_07:1.26
	MLWorks_Beta_1996_06_06:1.26
	MLWorks_Beta_1996_06_05:1.26
	MLWorks_Beta_1996_06_03:1.26
	MLWorks_Beta_1996_05_31:1.26
	MLWorks_Beta_1996_05_30:1.26
	ML_beta_release_12/08/94:1.24
	ML_beta_release_03/08/94:1.24
	ML_revised_beta_release_25/05/94:1.24
	ML_final_beta_release_02/03/94:1.24
	mlworks-28-01-1994:1.24
	Release:1.23
	mlworks-beta-01-09-1993:1.23
	MLWorks-1-0-4-29/01/1993:1.18
	MLWorks-1-0-3-21/12/1992:1.17
	MLWorks-1-0-2-15/12/1992:1.17
	MLWorks-1-0-1-04/12/1992:1.16
	checkpoint_17_08_92:1.10
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.26
date	96.03.27.17.01.06;	author matthew;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1
	1.26.4.1
	1.26.5.1
	1.26.6.1
	1.26.7.1
	1.26.8.1
	1.26.9.1
	1.26.10.1
	1.26.11.1;
next	1.25;

1.25
date	95.02.02.13.54.12;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.11.30.11.50.35;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.05.26.09.34.14;	author matthew;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	93.05.25.15.26.33;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	93.05.24.14.46.30;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.05.21.13.00.39;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	93.05.20.16.48.22;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.12.22.15.49.54;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.12.04.19.26.21;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	92.11.26.18.04.29;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	92.10.23.13.35.05;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.10.12.11.33.44;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.09.08.13.44.54;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.09.04.11.00.13;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.08.20.18.34.31;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.08.17.11.56.46;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.08.13.15.53.08;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.12.17.18.08;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.08.11.13.54.44;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.08.04.13.12.50;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.03.18.17.41.14;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.01.27.20.15.15;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.01.24.16.54.14;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.21.16.47.08;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.37.49;	author colin;	state Exp;
branches;
next	;

1.23.1.1
date	93.05.26.09.34.14;	author jont;	state Exp;
branches;
next	;

1.26.1.1
date	96.09.13.11.42.20;	author hope;	state Exp;
branches;
next	;

1.26.2.1
date	96.10.07.16.35.26;	author hope;	state Exp;
branches;
next	;

1.26.3.1
date	96.10.17.11.54.32;	author hope;	state Exp;
branches;
next	;

1.26.4.1
date	96.11.14.13.22.45;	author hope;	state Exp;
branches
	1.26.4.1.1.1;
next	;

1.26.4.1.1.1
date	96.11.28.15.33.17;	author hope;	state Exp;
branches;
next	;

1.26.5.1
date	96.11.22.18.39.52;	author hope;	state Exp;
branches;
next	;

1.26.6.1
date	96.12.17.18.18.55;	author hope;	state Exp;
branches
	1.26.6.1.1.1;
next	;

1.26.6.1.1.1
date	97.02.24.12.13.12;	author hope;	state Exp;
branches;
next	;

1.26.7.1
date	96.12.18.10.14.14;	author hope;	state Exp;
branches;
next	;

1.26.8.1
date	97.05.12.10.52.27;	author hope;	state Exp;
branches
	1.26.8.1.1.1
	1.26.8.1.2.1
	1.26.8.1.3.1;
next	;

1.26.8.1.1.1
date	97.07.28.18.34.16;	author daveb;	state Exp;
branches
	1.26.8.1.1.1.1.1;
next	;

1.26.8.1.1.1.1.1
date	97.10.07.12.00.13;	author jkbrook;	state Exp;
branches;
next	;

1.26.8.1.2.1
date	97.09.08.17.27.18;	author daveb;	state Exp;
branches;
next	;

1.26.8.1.3.1
date	97.09.09.14.24.15;	author daveb;	state Exp;
branches;
next	;

1.26.9.1
date	97.09.10.19.43.09;	author brucem;	state Exp;
branches;
next	;

1.26.10.1
date	97.09.11.21.10.38;	author daveb;	state Exp;
branches;
next	;

1.26.11.1
date	99.04.01.18.09.01;	author daveb;	state Exp;
branches;
next	;


desc
@Handles Sharing Constraints of types in modules
(see also share.sml)
@


1.26
log
@Updating for new language revisions
@
text
@(* _sharetypes.sml the functor *)
(*
$Log: _sharetypes.sml,v $
 * Revision 1.25  1995/02/02  13:54:12  matthew
 * Removing debug stuff
 *
Revision 1.24  1993/11/30  11:50:35  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.23  1993/05/26  09:34:14  matthew
Added sharing constraint

Revision 1.22  1993/05/25  15:26:33  jont
Changes because Assemblies now has Basistypes instead of Datatypes

Revision 1.21  1993/05/24  14:46:30  matthew
Removed debug statements.
Fixed bug with equality attributes.

Revision 1.20  1993/05/21  13:00:39  jont
Fixed up to check for illegal sharing in functor result signatures
ie trying to force extra sharing on the functor parameter

Revision 1.19  1993/05/20  16:48:22  jont
Avoid updating flexible names in the basis (when doing sharng in functor results)

Revision 1.18  1992/12/22  15:49:54  jont
Anel's last changes

Revision 1.17  1992/12/04  19:26:21  matthew
Error message revisions.

Revision 1.16  1992/11/26  18:04:29  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.15  1992/10/23  13:35:05  clive
Some bug fixes from Anel

Revision 1.14  1992/10/12  11:33:44  clive
Tynames now have a slot recording their definition point

Revision 1.13  1992/09/08  13:44:54  jont
Removed has_a_new_name, no longer needed

Revision 1.12  1992/09/04  11:00:13  jont
Stuff to understand type functions properly

Revision 1.11  1992/08/20  18:34:31  jont
Various improvements to remove garbage, handlers etc.

Revision 1.10  1992/08/17  11:56:46  jont
Modified to propagate valenvs from rigid types to flexible types

Revision 1.9  1992/08/13  15:53:08  jont
Added more checking for valenv consistency when sharing tyfuns

Revision 1.8  1992/08/12  17:18:08  jont
Fixed type sharing to propagate valenvs down whenever they're not empty

Revision 1.7  1992/08/11  13:54:44  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.6  1992/08/04  13:12:50  jont
Anel's changes to use NewMap instead of Map

Revision 1.5  1992/03/18  17:41:14  jont
Modified do_share_tyfun to ensure that when a type is shared with a
datatype the conenv is propagated into the type

Revision 1.4  1992/01/27  20:15:15  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.3  1992/01/24  16:54:14  jont
Updated to allow valenv in METATYNAME

Revision 1.2  1991/11/21  16:47:08  jont
Added copyright message

Revision 1.1  91/06/07  11:37:49  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/print";
require "../typechecker/sharetypes";
require "../typechecker/types";
require "../typechecker/valenv";
require "../typechecker/assemblies";
require "../typechecker/nameset";
require "../typechecker/namesettypes";

functor Sharetypes(
  structure Print : PRINT
  structure Types : TYPES
  structure Conenv : VALENV
  structure Assemblies : ASSEMBLIES
  structure Nameset : NAMESET
  structure NamesetTypes : NAMESETTYPES

  sharing Assemblies.Basistypes.Datatypes = 
    Types.Datatypes = Conenv.Datatypes = Nameset.Datatypes

  sharing type Nameset.Nameset = NamesetTypes.Nameset =
    Assemblies.Basistypes.Nameset
    ) : SHARETYPES =
  struct
    structure Assemblies = Assemblies
    structure Datatypes = Assemblies.Basistypes.Datatypes
    structure NamesetTypes = NamesetTypes

    (****
     Sharing of types are handled in this functor.
     ****)

    open Datatypes

    exception ShareError of string

    (****
     Determine the type function the flexible type name of the argument
     type function has been instantiated to.
     ****)

    fun strip (tyfun as ETA_TYFUN (METATYNAME{1=ref(NULL_TYFUN _), ...})) =
      tyfun
      | strip (ETA_TYFUN (METATYNAME{1=ref tyfun, ...})) = strip tyfun
      | strip tyfun = tyfun
	
    fun valenv_of_tyfun(ETA_TYFUN(TYNAME{5=ref valenv, ...})) = valenv
      | valenv_of_tyfun(TYFUN(CONSTYPE(_, TYNAME{5=ref valenv, ...}), _)) =
	valenv
      | valenv_of_tyfun _ = empty_valenv

    fun same_tyfun (ETA_TYFUN (METATYNAME{1=r as ref(NULL_TYFUN _), ...}),
		     ETA_TYFUN (METATYNAME{1=r' as ref(NULL_TYFUN _), ...})) = 
      r = r'
      | same_tyfun (TYFUN (CONSTYPE (_,METATYNAME{1=r as ref (NULL_TYFUN _),
						    ...}),_),
		     TYFUN (CONSTYPE (_,METATYNAME{1=r' as ref (NULL_TYFUN _),
						   ...}),_)) = r = r'
      | same_tyfun (ETA_TYFUN (METATYNAME{1=r as ref(NULL_TYFUN _), ...}),
		     TYFUN (CONSTYPE (_,METATYNAME{1=r' as ref (NULL_TYFUN _),
						   ...}),_)) = r = r'
      | same_tyfun (TYFUN (CONSTYPE (_,METATYNAME{1=r as ref(NULL_TYFUN _),
						   ...}),_),
		     ETA_TYFUN (METATYNAME{1=r' as ref(NULL_TYFUN _), ...})) =
	r = r'

      (****
       Otherwise one of them is instantiated to a tyfun of a rigid type
       and we can test for ordinary equality of tyfuns.
       ****)

      | same_tyfun (tyfun,tyfun') = Types.tyfun_eq (tyfun,tyfun')

    fun tystr_consistent (conenv,conenv') = 
      Conenv.empty_valenvp conenv
      orelse
      Conenv.empty_valenvp conenv'
      orelse
      Conenv.dom_valenv_eq (conenv,conenv')

    fun update_and_share
      (tyfun,tyfun',ce,ce',tyfun_ref,ty_ass,valenv_ref,valenv) = 
      let 
	val (ty_ass',count) = Assemblies.remfromTypeAssembly (tyfun, ty_ass)
	val (ty_ass'',count') = Assemblies.remfromTypeAssembly (tyfun',ty_ass')
	val _ = tyfun_ref := tyfun'
	val _ = valenv_ref := valenv
      in
	(true,Assemblies.add_to_TypeAssembly 
	 ((strip tyfun),ce,count,
	  Assemblies.add_to_TypeAssembly ((strip tyfun'),ce',count',ty_ass'')))
      end 

    fun update_eqrefs (eqref,eqref',neweq) =
      (eqref := neweq;
       eqref' := neweq)

    (****
     To ensure that the type assembly is updated correctly the entries
     corresponding to the tyfuns being shared are first removed from the 
     type assembly (once it has been determined that the sharing is 
     possible), then the references are updated (sharing done), and 
     then they are both added to the type assembly again. 
     There is also an attempt to ensure that flexible names in the basis
     are not updated by sharing constraints in functor result signatures.
     ****)

    fun do_share_tyfun(old_definition,
                       tyfun as ETA_TYFUN (meta as METATYNAME 
					   {1=r as ref (NULL_TYFUN _),
					    4=b,
					    5=ref_valenv,...}),
		       tyfun' as ETA_TYFUN (meta' as METATYNAME
					    {1=r' as ref (NULL_TYFUN _),
					     4=b',
					     5=ref_valenv',...}),ty_ass, nameset) =
      let
        val (ce as VE (_,vemap),_) = Assemblies.lookupTyfun (tyfun,ty_ass)
        val (ce' as VE(_,vemap'),_) = Assemblies.lookupTyfun (tyfun',ty_ass)
        val (ref_valenv, valenv) =
          if NewMap.is_empty vemap then
            (ref_valenv,ce')
          else (ref_valenv',ce)
      in
        if tystr_consistent (ce,ce') then
          if Types.arity (tyfun) = Types.arity (tyfun') then
            let
              val neweq =
                (* This extra check is necessary for the pathological ex 11.5 
                    in the Commentary *)
                if (not (NewMap.is_empty vemap)
                    andalso 
                    not (NewMap.is_empty vemap'))
                  then
                    (!b) andalso (!b')
                else
                  (!b) orelse (!b')
            in
              if Nameset.member_of_tynames(meta, nameset) then
                (if not(neweq = (!b))
                   then raise ShareError "incompatible equality attributes"
                 else ();
                 update_eqrefs(b,b',neweq);
                 update_and_share (tyfun',tyfun,ce',ce,r',ty_ass,
                                   ref_valenv,valenv))
              (* Point the non-basis one at the basis one *)
              else
                (if Nameset.member_of_tynames(meta',nameset) andalso
                   not(neweq = (!b'))
                   then raise ShareError "incompatible equality attributes"
                 else ();
                 update_eqrefs(b,b',neweq);
                 update_and_share (tyfun,tyfun',ce,ce',r,ty_ass,ref_valenv,valenv))
            end
          else
            raise ShareError "different arities"
        else
          raise ShareError "inconsistent value constructors"
      end

      | do_share_tyfun(old_definition,
                       tyfun as ETA_TYFUN (METATYNAME{1=r as ref(NULL_TYFUN _),
						     4=b as ref eq,
						     5=ref_valenv, ...}),
			tyfun',ty_ass, nameset) =
        if old_definition then
        let
          val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
          val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
        in
          if tystr_consistent (ce,ce') then
            if Types.arity (tyfun) = Types.arity (tyfun') then
              let
                val eq' = Types.equalityp tyfun'
              in
                if (eq andalso eq') orelse not eq then
                  (b := eq';
                   update_and_share (tyfun,tyfun',ce,ce',r,ty_ass,
                                     ref_valenv, ce'))
                else
                  raise ShareError "incompatible equality attributes"
              end
            else 
              raise ShareError "different arities"
          else
            raise ShareError "inconsistent value constructors"
        end
        else
      raise ShareError "sharing with rigid names"

	   
      | do_share_tyfun(old_definition,
                       tyfun,tyfun' as ETA_TYFUN(METATYNAME
						 {1=r as ref(NULL_TYFUN _),
						  4=b as ref eq,
						  5=ref_valenv,...}),
		       ty_ass, nameset) =
        if old_definition then
        let
          val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
          val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
        in
          if tystr_consistent (ce,ce') then
            if Types.arity (tyfun) = Types.arity (tyfun') then
              let
                val eq' = Types.equalityp tyfun
              in
                if (eq andalso eq') orelse not eq then
                  (b := eq';
                   update_and_share (tyfun',tyfun,ce',ce,r,ty_ass,
                                     ref_valenv,ce))
                else
                  raise ShareError "incompatible equality attributes"
              end
            else
              raise ShareError "different arities"
          else
            raise ShareError "inconsistent value constructors"
        end
      else
        raise ShareError "sharing with rigid names"
	     
      | do_share_tyfun(old_definition,tyfun, tyfun', ty_ass, nameset) =
        (false,ty_ass)

    fun get_meta(ETA_TYFUN meta) = meta
      | get_meta tyfun =
	METATYNAME(ref tyfun, "Bad tyname", 0, ref false, ref empty_valenv,ref false)

    fun share_tyfun (old_definition,tyfun, tyfun', ty_ass, nameset) = 
      let
        val tyfun = strip tyfun
        val tyfun' = strip tyfun'
      in
        if same_tyfun(tyfun, tyfun')
          then (true, ty_ass)
        else
          let
            val null = Types.null_tyfunp tyfun
            val null' = Types.null_tyfunp tyfun'
          in
            if null orelse null' then
              (* At least one is flexible *)
              let
                val bad =
                  (not null) orelse Nameset.member_of_tynames(get_meta tyfun, nameset)
                val bad' =
                  (not null') orelse Nameset.member_of_tynames(get_meta tyfun', nameset)
              (* Bad indicates rigid or flexible but in the nameset *)
              (* Can't share two such unless they are equal *)
              in
                if bad andalso bad' then
                  raise ShareError "different rigid types"
                else
                  do_share_tyfun(old_definition,tyfun, tyfun', ty_ass, nameset)
              end
            else
              raise ShareError "different rigid types"
          end
      end
  end
@


1.26.11.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.8.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.26.8.1  1997/05/12  10:52:27  hope
 * branched from 1.26
 *
@


1.26.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.26.8.1  1997/05/12  10:52:27  hope
 * branched from 1.26
 *
@


1.26.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.26.8.1  1997/05/12  10:52:27  hope
 * branched from 1.26
 *
@


1.26.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.26.8.1.1.1  1997/07/28  18:34:16  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.26.7.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.6.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.6.1.1.1
log
@branched from 1.26.6.1
@
text
@a3 3
 * Revision 1.26.6.1  1996/12/17  18:18:55  hope
 * branched from 1.26
 *
@


1.26.5.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.4.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.4.1.1.1
log
@branched from 1.26.4.1
@
text
@a3 3
 * Revision 1.26.4.1  1996/11/14  13:22:45  hope
 * branched from 1.26
 *
@


1.26.3.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.2.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.26.1.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/03/27  17:01:06  matthew
 * Updating for new language revisions
 *
@


1.25
log
@Removing debug stuff
@
text
@d4 3
d194 2
a195 1
    fun do_share_tyfun(tyfun as ETA_TYFUN (meta as METATYNAME 
d247 2
a248 1
      | do_share_tyfun(tyfun as ETA_TYFUN (METATYNAME{1=r as ref(NULL_TYFUN _),
d252 1
d274 3
d278 2
a279 1
      | do_share_tyfun(tyfun,tyfun' as ETA_TYFUN(METATYNAME
d284 1
d306 2
d309 1
a309 1
      | do_share_tyfun(tyfun, tyfun', ty_ass, nameset) =
d316 1
a316 1
    fun share_tyfun (tyfun, tyfun', ty_ass, nameset) = 
d341 1
a341 1
                  do_share_tyfun(tyfun, tyfun', ty_ass, nameset)
@


1.24
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
a85 1
require "../typechecker/ty_debug";
a94 1
  structure Ty_Debug : TY_DEBUG
d106 1
a106 6

  structure Debug :
    sig
      val set_debug_level : int -> unit
      val debug_level : unit -> int
    end) : SHARETYPES =
a111 1
    val do_debug = Ty_Debug.do_debug orelse true
@


1.23
log
@Added sharing constraint
@
text
@d4 3
d306 1
a306 1
	METATYNAME(ref tyfun, "Bad tyname", 0, ref false, ref empty_valenv)
@


1.23.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.23  1993/05/26  09:34:14  matthew
Added sharing constraint

@


1.22
log
@Changes because Assemblies now has Basistypes instead of Datatypes
@
text
@d4 3
d100 2
a101 1
  sharing type Nameset.Nameset = NamesetTypes.Nameset
@


1.21
log
@Removed debug statements.
Fixed bug with equality attributes.
@
text
@d4 4
a77 1
require "../typechecker/datatypes";
a87 1
  structure Datatypes : DATATYPES
d94 1
a94 1
  sharing Datatypes = Assemblies.Datatypes = 
a104 1
    structure Datatypes = Datatypes
d106 1
@


1.20
log
@Fixed up to check for illegal sharing in functor result signatures
ie trying to force extra sharing on the functor parameter
@
text
@d4 4
d161 1
a161 1
      (tyfun,tyfun',ce,ce',eq',tyfun_ref,eq_ref,ty_ass,valenv_ref,valenv) = 
a165 1
	val _ = eq_ref := eq'
d172 5
a176 1
      
d189 1
a189 1
					    4=b as ref eq,
d193 1
a193 1
					     4=b' as ref eq',
d195 43
a237 41
      (if (do_debug andalso Debug.debug_level () > 10)
	 then (Print.print ("do_share_tyfun 1 \n");
	       Print.print ((Types.string_tyfun tyfun) ^ "\n");
	       Print.print ((Types.string_tyfun tyfun') ^ "\n");
	       Print.print ("\n"))
       else ();
	 let
	   val (ce as VE (_,vemap),_) = Assemblies.lookupTyfun (tyfun,ty_ass)
	   val (ce' as VE(_,vemap'),_) = Assemblies.lookupTyfun (tyfun',ty_ass)
	   val (ref_valenv, valenv) =
	     if NewMap.is_empty vemap then
	       (ref_valenv,ce')
	     else (ref_valenv',ce)
	 in
	   if tystr_consistent (ce,ce') then
	     if Types.arity (tyfun) = Types.arity (tyfun') then
             (* This extra check is necessary for the pathological ex 11.5 
                in the Commentary *)
               if (not (NewMap.is_empty vemap)
                   andalso 
                   not (NewMap.is_empty vemap')) then
                 if Nameset.member_of_tynames(meta, nameset) orelse not eq then
                   update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass,
                                     ref_valenv,valenv)
		 (* Point the non-basis one at the basis one *)
                 else
		   update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass,
				     ref_valenv,valenv)
               else
	         if Nameset.member_of_tynames(meta', nameset) orelse eq' then
		   update_and_share (tyfun, tyfun',ce,ce',eq',r,b,ty_ass,
                                     ref_valenv,valenv)
		 (* Point the non-basis one at the basis one *)
	         else
		   update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass,
				     ref_valenv,valenv)
	     else
	       raise ShareError "different arities"
	   else
	     raise ShareError "inconsistent value constructors"
	 end)
d243 21
a263 26
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("do_share_tyfun 5 \n");
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   let
	     val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
	     val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
	   in
	     if tystr_consistent (ce,ce') then
	       if Types.arity (tyfun) = Types.arity (tyfun') then
		 let
		   val eq' = Types.equalityp tyfun'
		 in
		   if (eq andalso eq') orelse not eq then
		     update_and_share (tyfun,tyfun',ce,ce', eq',r,b,ty_ass,
                                       ref_valenv, ce')
		   else
		     raise ShareError "incompatible equality attributes"
		 end
	       else 
		 raise ShareError "different arities"
	     else
	       raise ShareError "inconsistent value constructors"
	   end)
d270 21
a290 26
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("do_share_tyfun 7 \n");
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   let
	     val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
	     val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
	   in
	     if tystr_consistent (ce,ce') then
	       if Types.arity (tyfun) = Types.arity (tyfun') then
		 let
		   val eq' = Types.equalityp tyfun
		 in
		   if (eq andalso eq') orelse not eq then
		     update_and_share (tyfun',tyfun,ce',ce, eq',r,b,ty_ass,
                                       ref_valenv,ce)
		   else
		     raise ShareError "incompatible equality attributes"
		 end
	       else
		 raise ShareError "different arities"
	     else
	       raise ShareError "inconsistent value constructors"
	   end)
d292 2
a293 8
       | do_share_tyfun(tyfun, tyfun', ty_ass, nameset) =
	 (if (do_debug andalso Debug.debug_level () > 10)
	    then (Print.print ("do_share_tyfun 9 \n");
		  Print.print ((Types.string_tyfun tyfun) ^ "\n");
		  Print.print ((Types.string_tyfun tyfun') ^ "\n");
		  Print.print ("\n"))
	  else ();
	   (false,ty_ass))
d300 30
a329 37
      (if (do_debug andalso Debug.debug_level () > 10)
	 then (Print.print ("share_tyfun \n");
	       Print.print ((Types.string_tyfun tyfun) ^ "\n");
	       Print.print ((Types.string_tyfun tyfun') ^ "\n");
	       Print.print ((Assemblies.stringTypeAssembly ty_ass) ^ "\n");
	       Print.print ("\n"))
       else ();
	 let
	   val tyfun = strip tyfun
	   val tyfun' = strip tyfun'
	 in
	   if same_tyfun(tyfun, tyfun')
	     then (true, ty_ass)
	   else
	     let
	       val null = Types.null_tyfunp tyfun
	       val null' = Types.null_tyfunp tyfun'
	     in
	       if null orelse null' then
		 (* At least one is flexible *)
		 let
		   val bad =
		     (not null) orelse Nameset.member_of_tynames(get_meta tyfun, nameset)
		   val bad' =
		     (not null') orelse Nameset.member_of_tynames(get_meta tyfun', nameset)
	         (* Bad indicates rigid or flexible but in the nameset *)
	         (* Can't share two such unless they are equal *)
		 in
		   if bad andalso bad' then
		     raise ShareError "different rigid types"
		   else
		     do_share_tyfun(tyfun, tyfun', ty_ass, nameset)
		 end
	       else
		 raise ShareError "different rigid types"
	     end
	 end)
@


1.19
log
@Avoid updating flexible names in the basis (when doing sharng in functor results)
@
text
@d4 3
d127 1
a127 1
    fun same_tyfun' (ETA_TYFUN (METATYNAME{1=r as ref(NULL_TYFUN _), ...}),
d130 1
a130 1
      | same_tyfun' (TYFUN (CONSTYPE (_,METATYNAME{1=r as ref (NULL_TYFUN _),
d134 1
a134 1
      | same_tyfun' (ETA_TYFUN (METATYNAME{1=r as ref(NULL_TYFUN _), ...}),
d137 1
a137 1
      | same_tyfun' (TYFUN (CONSTYPE (_,METATYNAME{1=r as ref(NULL_TYFUN _),
d147 1
a147 1
      | same_tyfun' (tyfun,tyfun') = Types.tyfun_eq (tyfun,tyfun')
a148 2
    fun same_tyfun (tyfun,tyfun') = same_tyfun' (strip tyfun,strip tyfun')
	      
d261 11
a271 11
	 | do_share_tyfun(tyfun,tyfun' as ETA_TYFUN(METATYNAME
						    {1=r as ref(NULL_TYFUN _),
						     4=b as ref eq,
						     5=ref_valenv,...}),
			  ty_ass, nameset) =
	   (if (do_debug andalso Debug.debug_level () > 10)
	      then (Print.print ("do_share_tyfun 7 \n");
		    Print.print ((Types.string_tyfun tyfun) ^ "\n");
		    Print.print ((Types.string_tyfun tyfun') ^ "\n");
		    Print.print ("\n"))
	    else ();
d287 1
a287 1
	       else 
d293 7
a299 7
      | do_share_tyfun(tyfun, tyfun', ty_ass, nameset) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("do_share_tyfun 9 \n");
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
		 Print.print ("\n"))
	 else ();
d301 5
a305 1
	  
d314 30
a343 7
	 if same_tyfun (tyfun,tyfun')
	   then (true,ty_ass)
	 else 
	   if Types.null_tyfunp tyfun orelse Types.null_tyfunp tyfun'
	     then
	       do_share_tyfun(strip tyfun, strip tyfun', ty_ass, nameset)
	   else raise ShareError "different rigid types")
@


1.18
log
@Anel's last changes
@
text
@d4 3
d72 2
d82 3
d86 4
a89 1
    Types.Datatypes = Conenv.Datatypes
d98 1
d175 2
d179 1
a179 1
    fun do_share_tyfun(tyfun as ETA_TYFUN (METATYNAME 
d183 1
a183 1
		       tyfun' as ETA_TYFUN (METATYNAME
d186 1
a186 1
					     5=ref_valenv',...}),ty_ass) =
d208 1
a208 1
                 if not eq then
d211 4
a214 2
                 else update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass,
                                        ref_valenv,valenv)
d216 2
a217 2
	         if eq' then
		   update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass,
d219 4
a222 2
	         else update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass,
                                        ref_valenv,valenv)
d232 1
a232 1
			tyfun',ty_ass) =
d260 5
a264 5
	 | do_share_tyfun (tyfun,tyfun' as ETA_TYFUN(METATYNAME
						     {1=r as ref(NULL_TYFUN _),
						      4=b as ref eq,
						      5=ref_valenv,...}),
			   ty_ass) = 
d292 1
a292 1
      | do_share_tyfun (tyfun,tyfun',ty_ass) = 
d301 1
a301 1
    fun share_tyfun (tyfun,tyfun',ty_ass) = 
d314 1
a314 1
	       do_share_tyfun (strip tyfun,strip tyfun',ty_ass)
a316 2


@


1.17
log
@Error message revisions.
@
text
@d4 3
a103 4
(*
      | strip (tyfun as TYFUN (CONSTYPE (_,METATYNAME{1=ref(NULL_TYFUN _),
						       ...}),_)) = tyfun
*)
a104 9
(*
      | strip (TYFUN (CONSTYPE ([],METATYNAME{1=ref tyfun, ...}),_)) = 
	strip tyfun
      | strip (tyf as TYFUN(CONSTYPE(types,METATYNAME{1=ref tyfun, ...}),_)) =
	if Types.check_debruijns(types, 0) then
	  strip tyfun
	else
	  tyf
*)
d165 8
a172 9
    fun do_share_tyfun(tyfun as ETA_TYFUN(METATYNAME 
					  {1=r as ref (NULL_TYFUN _),
					   4=b as ref eq,
					   5=ref_valenv, ...}),
		       tyfun' as ETA_TYFUN(METATYNAME
					   {1=r' as ref (NULL_TYFUN _),
					    4=b' as ref eq',
					    5=ref_valenv',
					      ...}),ty_ass) =
d180 2
a181 3
	   val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
	   val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
	   val VE(_, vemap) = ce
d184 2
a185 3
	       (ref_valenv, ce')
	     else
	       (ref_valenv', ce)
d189 16
a204 3
	       if eq' then
		 update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass,ref_valenv, valenv)
	       else update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass,ref_valenv, valenv)
d206 1
a206 2
	       raise ShareError
		 "different arities"
d208 1
a208 2
	     raise ShareError
	       "inconsistent value constructors"
d211 1
a211 2
      | do_share_tyfun(tyfun as ETA_TYFUN(METATYNAME{1=r as ref 
						     (NULL_TYFUN _),
d213 1
a213 2
						     5=ref_valenv,
						     ...}),
d231 2
a232 1
		     update_and_share (tyfun,tyfun',ce,ce', eq',r,b,ty_ass,ref_valenv, ce')
d234 1
a234 2
		     raise ShareError 
		       "incompatible equality attributes"
d237 1
a237 2
		 raise ShareError
		   "different arities"
d239 1
a239 2
	       raise ShareError 
		 "inconsistent value constructors"
d245 1
a245 2
						      5=ref_valenv,
						      ...}),
d263 2
a264 1
		     update_and_share (tyfun',tyfun,ce',ce, eq',r,b,ty_ass,ref_valenv,ce)
d266 1
a266 2
		     raise ShareError 
		       "incompatible equality attributes"
d269 1
a269 2
		 raise ShareError
		   "different arities"
d271 1
a271 2
	       raise ShareError 
		 "inconsistent value constructors"
d297 1
a297 2
	   else raise ShareError ("different rigid types"))

@


1.16
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d207 1
a207 1
		 "different arities \n"
d210 1
a210 1
	       "inconsistent value constructors \n"
d238 1
a238 1
		       "incompatible equality attributes \n"
d242 1
a242 1
		   "different arities \n"
d245 1
a245 1
		 "inconsistent value constructors \n"
d273 1
a273 1
		       "incompatible equality attributes\n"
d277 1
a277 1
		   "different arities \n"
d280 1
a280 1
		 "inconsistent value constructors \n"
d306 1
a306 1
	   else raise ShareError ("different rigid types\n"))
@


1.15
log
@Some bug fixes from Anel
@
text
@d4 3
d182 2
a183 2
	       Print.print ((Types.string_tyfun_using_default tyfun) ^ "\n");
	       Print.print ((Types.string_tyfun_using_default tyfun') ^ "\n");
d217 2
a218 2
		 Print.print ((Types.string_tyfun_using_default tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun_using_default tyfun') ^ "\n");
d252 2
a253 2
		    Print.print ((Types.string_tyfun_using_default tyfun) ^ "\n");
		    Print.print ((Types.string_tyfun_using_default tyfun') ^ "\n");
d282 2
a283 2
		 Print.print ((Types.string_tyfun_using_default tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun_using_default tyfun') ^ "\n");
d291 2
a292 2
	       Print.print ((Types.string_tyfun_using_default tyfun) ^ "\n");
	       Print.print ((Types.string_tyfun_using_default tyfun') ^ "\n");
@


1.14
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d171 1
a171 1
					   5=ref_valenv as ref valenv, ...}),
d175 1
a175 1
					    5=ref_valenv' as ref valenv',
d186 1
a186 2
	   val count_len = NewMap.fold (fn (n, _, _) => n+1)
	   val VE(_, vemap) = valenv
d189 1
a189 6
	       (ref_valenv, valenv')
	     else
	       (ref_valenv', valenv)
	   val _ =
	     if tystr_consistent(valenv', valenv) then
	       ()
d191 1
a191 7
	       raise ShareError
	       ("Inconsistent valenvs in metatynames when sharing " ^
		Types.string_tyfun_using_default tyfun ^ " and " ^
		Types.string_tyfun_using_default tyfun' ^ "\n" ^
		"valenv = " ^ Conenv.string_valenv(0, valenv) ^
		"\nvalenv' = " ^ Conenv.string_valenv(0, valenv') ^
		"\n")
d200 1
a200 1
		 "have different arities \n"
d203 1
a203 1
	       "have inconsistent value constructors \n"
a225 1
		   val valenv = valenv_of_tyfun tyfun'
d228 1
a228 1
		     update_and_share (tyfun,tyfun',ce,ce', eq',r,b,ty_ass,ref_valenv, valenv)
d231 1
a231 1
		       "have incompatible equality attributes \n"
d235 1
a235 1
		   "have different arities \n"
d238 1
a238 1
		 "have inconsistent value constructors \n"
a259 1
		   val valenv = valenv_of_tyfun tyfun
d263 1
a263 1
		     update_and_share (tyfun',tyfun,ce',ce, eq',r,b,ty_ass,ref_valenv, valenv)
d266 1
a266 1
		       "have incompatible equality attributes\n"
d270 1
a270 1
		   "have different arities \n"
d273 1
a273 1
		 "have inconsistent value constructors \n"
d299 1
a299 1
	   else raise ShareError ("are different rigid types\n"))
@


1.13
log
@Removed has_a_new_name, no longer needed
@
text
@d4 3
d176 2
a177 2
	       Print.print ((Types.string_tyfun tyfun) ^ "\n");
	       Print.print ((Types.string_tyfun tyfun') ^ "\n");
d196 2
a197 2
		Types.string_tyfun tyfun ^ " and " ^
		Types.string_tyfun tyfun' ^ "\n" ^
d223 2
a224 2
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
d259 2
a260 2
		    Print.print ((Types.string_tyfun tyfun) ^ "\n");
		    Print.print ((Types.string_tyfun tyfun') ^ "\n");
d290 2
a291 2
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
d299 2
a300 2
	       Print.print ((Types.string_tyfun tyfun) ^ "\n");
	       Print.print ((Types.string_tyfun tyfun') ^ "\n");
@


1.12
log
@Stuff to understand type functions properly
@
text
@d4 3
d88 1
d91 1
d93 1
d101 1
d208 2
a209 2
	     raise ShareError 
	       "have inconsistent type structures \n"
a211 156
(*
      | do_share_tyfun(tyfun as TYFUN(CONSTYPE(_,METATYNAME
					       {1=r as ref (NULL_TYFUN _),
						4=b as ref eq,
						5=ref_valenv as ref valenv,
						...}),_),
		       tyfun' as TYFUN(CONSTYPE(_,METATYNAME 
						{1=r' as ref
						 (NULL_TYFUN _),
						 4=b' as ref eq',
						 5=ref_valenv' as ref valenv',
						 ...}),_),
		       ty_ass)=
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("do_share_tyfun 2 \n");
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   let
	     val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
	     val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
	     val VE(_, vemap) = valenv
	     val (ref_valenv, valenv) =
	       if NewMap.is_empty vemap then
		 (ref_valenv, valenv')
	       else
		 (ref_valenv', valenv)
	   val _ =
	     if tystr_consistent(valenv', valenv) then
	       ()
	     else
	       raise ShareError
	       ("Inconsistent valenvs in metatynames when sharing " ^
		Types.string_tyfun tyfun ^ " and " ^
		Types.string_tyfun tyfun' ^ "\n" ^
		"valenv = " ^ Conenv.string_valenv(0, valenv) ^
		"\nvalenv' = " ^ Conenv.string_valenv(0, valenv') ^
		"\n")
	   in
	     if tystr_consistent (ce,ce') then
	       if Types.arity (tyfun) = Types.arity (tyfun') then
		 if eq' then
		   update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass,ref_valenv, valenv)
		 else 
		   update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass,ref_valenv, valenv)
	       else
		 raise ShareError
		   "have different arities \n"
	     else
	       raise ShareError 
		 "have inconsistent type structures \n"
	   end)
      | do_share_tyfun (tyfun as TYFUN (CONSTYPE (_,METATYNAME 
						  {1=r as ref(NULL_TYFUN _),
						   4=b as ref eq,
						   5=ref_valenv as ref valenv,
						   ...}),_),
			tyfun' as ETA_TYFUN (METATYNAME
					     {1=r' as ref (NULL_TYFUN _),
					      4=b' as ref eq',
					      5=ref_valenv' as ref valenv',
					      ...}),ty_ass) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("do_share_tyfun 3 \n");
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   let
	     val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
	     val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
	     val VE(_, vemap) = valenv
	     val (ref_valenv, valenv) =
	       if NewMap.is_empty vemap then
		 (ref_valenv, valenv')
	       else
		 (ref_valenv', valenv)
	   val _ =
	     if tystr_consistent(valenv', valenv) then
	       ()
	     else
	       raise ShareError
	       ("Inconsistent valenvs in metatynames when sharing " ^
		Types.string_tyfun tyfun ^ " and " ^
		Types.string_tyfun tyfun' ^ "\n" ^
		"valenv = " ^ Conenv.string_valenv(0, valenv) ^
		"\nvalenv' = " ^ Conenv.string_valenv(0, valenv') ^
		"\n")
	   in
	     if tystr_consistent (ce,ce') then
	       if Types.arity (tyfun) = Types.arity (tyfun') then
		 if eq' then
		   update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass,ref_valenv, valenv)
		 else
		    update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass,ref_valenv, valenv)
	       else
		 raise ShareError
		   "have different arities \n"
	     else
	       raise ShareError 
		 "have inconsistent type structures \n"
	   end)
	   
      | do_share_tyfun (tyfun' as ETA_TYFUN (METATYNAME
					     {1=r' as ref (NULL_TYFUN _),
					      4=b' as ref eq',
					      5=ref_valenv as ref valenv,
					      ...}),
			tyfun as TYFUN(CONSTYPE(_,METATYNAME
						{1=r as ref (NULL_TYFUN _),
						 4=b as ref eq,
						 5=ref_valenv' as ref valenv',
						 ...}),_),
			ty_ass) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("do_share_tyfun 4 \n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ("\n"))
	 else ();
	   let
	     val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
	     val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
	     val VE(_, vemap) = valenv
	     val (ref_valenv, valenv) =
	       if NewMap.is_empty vemap then
		 (ref_valenv, valenv')
	       else
		 (ref_valenv', valenv)
	   val _ =
	     if tystr_consistent(valenv', valenv) then
	       ()
	     else
	       raise ShareError
	       ("Inconsistent valenvs in metatynames when sharing " ^
		Types.string_tyfun tyfun ^ " and " ^
		Types.string_tyfun tyfun' ^ "\n" ^
		"valenv = " ^ Conenv.string_valenv(0, valenv) ^
		"\nvalenv' = " ^ Conenv.string_valenv(0, valenv') ^
		"\n")
	   in
	     if tystr_consistent (ce,ce') then
	       if Types.arity (tyfun) = Types.arity (tyfun') then
		 if eq' then
		   update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass,ref_valenv, valenv)
		 else
		    update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass,ref_valenv, valenv)
	       else
		 raise ShareError
		   "have different arities \n"
	     else
	       raise ShareError 
		 "have inconsistent type structures \n"
	   end)
*)
d245 1
a245 1
		 "have inconsistent type structures \n"
a246 37

(*
      | do_share_tyfun (tyfun as TYFUN (CONSTYPE (_,METATYNAME 
						  {1=r as ref (NULL_TYFUN _),
						   5=ref_valenv,
						   4=b as ref eq, ...}),_),
			tyfun',ty_ass) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("do_share_tyfun 6 \n");
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   let
	     val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
	     val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
	   in
	     if tystr_consistent (ce,ce') then
	       if Types.arity (tyfun) = Types.arity (tyfun') then
		 let
		   val valenv = valenv_of_tyfun tyfun'
		   val eq' = Types.equalityp tyfun'
		 in
		   if (eq andalso eq') orelse not eq then
		     update_and_share (tyfun,tyfun',ce,ce', eq',r,b,ty_ass,ref_valenv, valenv)
		   else
		     raise ShareError 
		       "have incompatible equality attributes \n"
		 end
	       else 
		 raise ShareError
		   "have different arities \n"
	     else
	       raise ShareError 
		 "have inconsistent type structures \n"
	   end)
*)
d281 1
a281 1
		 "have inconsistent type structures \n"
a282 38

(*
      | do_share_tyfun (tyfun, tyfun' as TYFUN 
			(CONSTYPE (_,METATYNAME{1=r as ref (NULL_TYFUN _),
						4=b as ref eq,
						5=ref_valenv,
						...}),_),
			ty_ass) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("do_share_tyfun 8 \n");
		 Print.print ((Types.string_tyfun tyfun) ^ "\n");
		 Print.print ((Types.string_tyfun tyfun') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   let
	     val (ce,_) = Assemblies.lookupTyfun (tyfun,ty_ass)
	     val (ce',_) = Assemblies.lookupTyfun (tyfun',ty_ass)
	   in
	     if tystr_consistent (ce,ce') then
	       if Types.arity (tyfun) = Types.arity (tyfun') then
		 let
		   val valenv = valenv_of_tyfun tyfun
		   val eq' = Types.equalityp tyfun
		 in
		   if (eq andalso eq') orelse not eq then
		     update_and_share (tyfun',tyfun,ce',ce, eq',r,b,ty_ass,ref_valenv, valenv)
		   else
		     raise ShareError 
		       "have incompatible equality attributes \n"
		 end
	       else
		 raise ShareError
		   "have different arities \n"
	     else
	       raise ShareError 
		 "have inconsistent type structures\n"
	   end)
*)
d304 1
a304 1
	   if Types.has_a_new_name (tyfun) orelse Types.has_a_new_name (tyfun')
@


1.11
log
@Various improvements to remove garbage, handlers etc.
@
text
@d4 3
d88 1
a88 1
      | strip (TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),_)) = 
d90 5
d205 1
a257 1

d360 1
a360 1
	   
d397 1
d432 1
d470 1
d506 1
@


1.10
log
@Modified to propagate valenvs from rigid types to flexible types
@
text
@d4 3
a163 1
	     handle Assemblies.LookupTyfun => (empty_valenv,0)
a164 1
	     handle Assemblies.LookupTyfun => (empty_valenv,0)
a216 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a217 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a267 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a268 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a319 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a320 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a366 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a367 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a401 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a402 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a437 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a438 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a473 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
a474 1
	       handle Assemblies.LookupTyfun => (empty_valenv,0)
@


1.9
log
@Added more checking for valenv consistency when sharing tyfuns
@
text
@d4 3
d86 5
d361 1
a361 1
						     5=ref_valenv as ref valenv,
d380 1
d398 1
a398 1
						   5=ref_valenv as ref valenv,
d416 1
d436 1
a436 1
						      5=ref_valenv as ref valenv,
d454 1
d474 1
a474 1
						5=ref_valenv as ref valenv,
d492 1
@


1.8
log
@Fixed type sharing to propagate valenvs down whenever they're not empty
@
text
@d4 3
d60 1
a60 1
    val do_debug = Ty_Debug.do_debug
d156 1
d163 11
d217 11
d270 11
d324 11
@


1.7
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d111 2
a112 1
    fun update_and_share (tyfun,tyfun',ce,ce',eq',tyfun_ref,eq_ref,ty_ass) = 
d118 1
d133 9
a141 6
    fun do_share_tyfun (tyfun as ETA_TYFUN (METATYNAME 
					    {1=r as ref (NULL_TYFUN _),
					     4=b as ref eq, ...}),
			tyfun' as ETA_TYFUN (METATYNAME
					     {1=r' as ref (NULL_TYFUN _),
					      4=b' as ref eq', ...}),ty_ass) =
d153 6
d160 8
a167 10
	   if tystr_consistent (ce,ce')
	     then
	       if Types.arity (tyfun) = Types.arity (tyfun')
		 then
		   if eq'
		     then update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass)
		   else update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass)
	       else
		 raise ShareError
		   "have different arities \n"
d173 12
a184 8
      | do_share_tyfun (tyfun as TYFUN (CONSTYPE (_,METATYNAME 
						  {1=r as ref (NULL_TYFUN _),
						   4=b as ref eq, ...}),_),
			tyfun' as TYFUN (CONSTYPE (_,METATYNAME 
						   {1=r' as ref
						    (NULL_TYFUN _),
						    4=b' as ref eq', ...}),_),
						    ty_ass)=
d196 6
d203 9
a211 12
	     if tystr_consistent (ce,ce')
	       then
		 if Types.arity (tyfun) = Types.arity (tyfun')
		   then
		     if eq'
		       then 
			 update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass)
		     else 
		       update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass)
		 else
		   raise ShareError
		     "have different arities \n"
d220 2
a221 1
						   5=ref valenv, ...}),_),
d225 2
a226 1
					      5=valenv_ref, ...}),ty_ass) =
d238 6
d245 4
a248 11
	     if tystr_consistent (ce,ce')
	       then
		 if Types.arity (tyfun) = Types.arity (tyfun')
		   then
		     if eq'
		       then
			 update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass)
		     else
		       (valenv_ref := valenv;
			update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass)
			)
d250 4
a253 2
		   raise ShareError
		     "have different arities \n"
d262 7
a268 5
					      5=valenv_ref, ...}),
			tyfun as TYFUN (CONSTYPE (_,METATYNAME 
						  {1=r as ref (NULL_TYFUN _),
						   4=b as ref eq,
						   5=ref valenv, ...}),_),
d281 6
d288 4
a291 11
	     if tystr_consistent (ce,ce')
	       then
		 if Types.arity (tyfun) = Types.arity (tyfun')
		   then
		     if eq'
		       then
			 update_and_share (tyfun,tyfun',ce,ce',eq',r,b,ty_ass)
		     else
		       (valenv_ref := valenv;
			update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass)
			)
d293 4
a296 2
		   raise ShareError
		     "have different arities \n"
d302 5
a306 3
      | do_share_tyfun (tyfun as ETA_TYFUN (METATYNAME{1=r as ref 
							(NULL_TYFUN _),
							4=b as ref eq, ...}),
d326 1
a326 1
		     update_and_share (tyfun,tyfun',ce,ce', eq',r,b,ty_ass)
d341 1
d362 1
a362 1
		     update_and_share (tyfun,tyfun',ce,ce', eq',r,b,ty_ass)
d377 3
a379 1
						      4=b as ref eq, ...}),
d399 1
a399 1
		     update_and_share (tyfun',tyfun,ce',ce, eq',r,b,ty_ass)
d414 3
a416 1
						4=b as ref eq, ...}),_),
d436 1
a436 1
		     update_and_share (tyfun',tyfun,ce',ce, eq',r,b,ty_ass)
@


1.6
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d292 14
a305 14
	     if tystr_consistent (ce,ce')
	       then
		 if Types.arity (tyfun) = Types.arity (tyfun') 
		   then
		     if (eq andalso Types.equalityp tyfun') orelse not eq
		       then
			 update_and_share (tyfun,tyfun',ce,ce',
					   Types.equalityp tyfun',r,b,ty_ass)
		     else
		       raise ShareError 
			 "have imcompatible equality attributes \n"
		 else 
		   raise ShareError
		     "have different arities \n"
d327 14
a340 14
	     if tystr_consistent (ce,ce')
	       then
		 if Types.arity (tyfun) = Types.arity (tyfun') 
		   then
		     if (eq andalso Types.equalityp tyfun') orelse not eq
		       then
			 update_and_share (tyfun,tyfun',ce,ce',
					   Types.equalityp tyfun',r,b,ty_ass)
		     else
		       raise ShareError 
			 "have imcompatible equality attributes \n"
		 else 
		   raise ShareError
		     "have different arities \n"
d362 14
a375 14
	     if tystr_consistent (ce,ce')
	       then
		 if Types.arity (tyfun) = Types.arity (tyfun') 
		   then
		     if (eq andalso Types.equalityp tyfun) orelse not eq
		       then
			 update_and_share (tyfun',tyfun,ce',ce,
					   Types.equalityp tyfun,r,b,ty_ass)
		     else
		       raise ShareError 
			 "have imcompatible equality attributes \n"
		 else 
		   raise ShareError
		     "have different arities \n"
d397 14
a410 14
	     if tystr_consistent (ce,ce')
	       then
		 if Types.arity (tyfun) = Types.arity (tyfun') 
		   then
		     if (eq andalso Types.equalityp tyfun) orelse not eq
		       then
			 update_and_share (tyfun',tyfun,ce',ce,
					   Types.equalityp tyfun,r,b,ty_ass)
		     else
		       raise ShareError 
			 "have imcompatible equality attributes \n"
		 else 
		   raise ShareError
		     "have different arities \n"
@


1.5
log
@Modified do_share_tyfun to ensure that when a type is shared with a
datatype the conenv is propagated into the type
@
text
@d4 4
d138 1
a138 1
	     handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d140 1
a140 1
	     handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d173 1
a173 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d175 1
a175 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d210 1
a210 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d212 1
a212 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d250 1
a250 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d252 1
a252 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d285 1
a285 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d287 1
a287 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d320 1
a320 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d322 1
a322 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d355 1
a355 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d357 1
a357 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d390 1
a390 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
d392 1
a392 1
	       handle Assemblies.LookupTyfun => (Conenv.empty_valenv,0)
@


1.4
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d192 2
a193 1
						   4=b as ref eq, ...}),_),
d196 2
a197 1
					      4=b' as ref eq', ...}),ty_ass) =
d217 4
a220 2
		     else 
		       update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass)
d231 2
a232 1
					      4=b' as ref eq', ...}),
d235 2
a236 1
						   4=b as ref eq, ...}),_),
d258 3
a260 1
		       update_and_share (tyfun',tyfun,ce',ce,eq,r',b',ty_ass)
@


1.3
log
@Updated to allow valenv in METATYNAME
@
text
@d4 3
d15 4
a19 1
require "../typechecker/datatypes";
a22 1
require "../utils/print";
d24 14
a37 10
functor Sharetypes (structure Datatypes : DATATYPES
		    structure Types : TYPES
		    structure Conenv : VALENV
		    structure Assemblies : ASSEMBLIES
		    structure Print : PRINT
		    sharing Datatypes = Assemblies.Datatypes = 
		      Types.Datatypes = Conenv.Datatypes
		    structure Debug : sig val set_debug_level : int -> unit
					  val debug_level : unit -> int
				      end) : SHARETYPES =
d42 1
d122 1
a122 1
      (if (Debug.debug_level () > 10)
d157 1
a157 1
	(if (Debug.debug_level () > 10)
d192 1
a192 1
	(if (Debug.debug_level () > 10)
d228 1
a228 1
	(if (Debug.debug_level () > 10)
d261 1
a261 1
	(if (Debug.debug_level () > 10)
d296 1
a296 1
	(if (Debug.debug_level () > 10)
d331 1
a331 1
	   (if (Debug.debug_level () > 10)
d366 1
a366 1
	(if (Debug.debug_level () > 10)
d398 1
a398 1
	(if (Debug.debug_level () > 10)
d407 1
a407 1
      (if (Debug.debug_level () > 10)
@


1.2
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_sharetypes.sml,v $
d46 1
a46 1
    fun strip (tyfun as ETA_TYFUN (METATYNAME (ref (NULL_TYFUN _),_,_,_))) =
d48 4
a51 4
      | strip (tyfun as TYFUN (CONSTYPE (_,METATYNAME (ref (NULL_TYFUN _),
						       _,_,_)),_)) = tyfun
      | strip (ETA_TYFUN (METATYNAME (ref tyfun,_,_,_))) = strip tyfun
      | strip (TYFUN (CONSTYPE (_,METATYNAME (ref tyfun,_,_,_)),_)) = 
d55 2
a56 2
    fun same_tyfun' (ETA_TYFUN (METATYNAME (r as ref (NULL_TYFUN _),_,_,_)),
		     ETA_TYFUN (METATYNAME (r' as ref (NULL_TYFUN _),_,_,_))) = 
d58 10
a67 10
      | same_tyfun' (TYFUN (CONSTYPE (_,METATYNAME (r as ref (NULL_TYFUN _),
						    _,_,_)),_),
		     TYFUN (CONSTYPE (_,METATYNAME(r' as ref (NULL_TYFUN _),
						   _,_,_)),_)) = r = r'
      | same_tyfun' (ETA_TYFUN (METATYNAME (r as ref (NULL_TYFUN _),_,_,_)),
		     TYFUN (CONSTYPE (_,METATYNAME (r' as ref (NULL_TYFUN _),
						    _,_,_)),_)) = r = r'
      | same_tyfun' (TYFUN (CONSTYPE (_,METATYNAME (r as ref (NULL_TYFUN _),
						    _,_,_)),_),
		     ETA_TYFUN (METATYNAME (r' as ref (NULL_TYFUN _),_,_,_))) =
d107 2
a108 2
					    (r as ref (NULL_TYFUN _),_,_,
					     b as ref eq)),
d110 2
a111 2
					     (r' as ref (NULL_TYFUN _),_,_,
					      b' as ref eq')),ty_ass) =
d140 2
a141 2
						  (r as ref (NULL_TYFUN _),_,_,
						   b as ref eq)),_),
d143 4
a146 3
						   (r' as ref
						    (NULL_TYFUN _),_,_,
						    b' as ref eq')),_),ty_ass)=
d177 2
a178 2
						  (r as ref (NULL_TYFUN _),_,_,
						   b as ref eq)),_),
d180 2
a181 2
					     (r' as ref (NULL_TYFUN _),_,_,
					      b' as ref eq')),ty_ass) =
d212 2
a213 2
					     (r' as ref (NULL_TYFUN _),_,_,
					      b' as ref eq')),
d215 3
a217 2
						  (r as ref (NULL_TYFUN _),_,
						   _,b as ref eq)),_),ty_ass) =
d247 3
a249 3
      | do_share_tyfun (tyfun as ETA_TYFUN (METATYNAME (r as ref 
							(NULL_TYFUN _),_,_,
							b as ref eq)),
d283 2
a284 2
						  (r as ref (NULL_TYFUN _),_,
						   _,b as ref eq)),_),
d317 4
a320 3
	 | do_share_tyfun (tyfun,tyfun' as ETA_TYFUN (METATYNAME 
						   (r as ref (NULL_TYFUN _),_,
						    _,b as ref eq)),ty_ass) = 
d353 3
a355 2
			(CONSTYPE (_,METATYNAME (r as ref (NULL_TYFUN _),_,_,
						 b as ref eq)),_),ty_ass) =
@


1.1
log
@Initial revision
@
text
@d1 1
d3 5
a7 1
$Log$
@
