head	1.46;
access;
symbols
	MLW_daveb_inline_1_4_99:1.46.1
	MLWorks_21c0_1999_03_25:1.46
	MLWorks_20c1_1998_08_20:1.46
	MLWorks_20c0_1998_08_04:1.46
	MLWorks_20b2c2_1998_06_19:1.46
	MLWorks_20b2_Windows_1998_06_12:1.46
	MLWorks_20b1c1_1998_05_07:1.46
	MLWorks_20b0_1998_04_07:1.46
	MLWorks_20b0_1998_03_20:1.46
	MLWorks_20m2_1998_02_16:1.45
	MLWorks_20m1_1997_10_23:1.45
	MLWorks_11r1:1.44.5.1.1.1.1
	MLWorks_workspace_97:1.45.2
	MLWorks_dt_wizard:1.45.1
	MLWorks_11c0_1997_09_09:1.44.5.1.1.1
	MLWorks_10r3:1.44.5.1.3
	MLWorks_10r2_551:1.44.5.1.2
	MLWorks_11:1.44.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.44.5.1
	MLWorks_20m0_1997_06_20:1.45
	MLWorks_1_0_r2c2_1997_06_14:1.44.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.44.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.44.5
	MLWorks_BugFix_1997_04_24:1.44
	MLWorks_1_0_r2_Win32_1997_04_11:1.44
	MLWorks_1_0_r2_Unix_1997_04_04:1.44
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.44.3.1.1
	MLWorks_gui_1996_12_18:1.44.4
	MLWorks_1_0_Win32_1996_12_17:1.44.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.44.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.44.1.1
	MLWorks_1_0_Irix_1996_11_28:1.44.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.44.2
	MLWorks_1_0_Unix_1996_11_14:1.44.1
	MLWorks_Open_Beta2_1996_10_11:1.42.1
	MLWorks_License_dev:1.41.2
	MLWorks_1_open_beta_1996_09_13:1.41.1
	MLWorks_Open_Beta_1996_08_22:1.41
	MLWorks_Beta_1996_07_02:1.41
	MLWorks_Beta_1996_06_07:1.41
	MLWorks_Beta_1996_06_06:1.41
	MLWorks_Beta_1996_06_05:1.41
	MLWorks_Beta_1996_06_03:1.41
	MLWorks_Beta_1996_05_31:1.41
	MLWorks_Beta_1996_05_30:1.41
	ML_beta_release_12/08/94:1.32
	ML_beta_release_03/08/94:1.32
	ML_revised_beta_release_25/05/94:1.32
	ML_final_beta_release_02/03/94:1.32
	mlworks-28-01-1994:1.31
	Release:1.30
	mlworks-beta-01-09-1993:1.30
	MLWorks-1-0-4-29/01/1993:1.23
	MLWorks-1-0-3-21/12/1992:1.23
	MLWorks-1-0-2-15/12/1992:1.22
	MLWorks-1-0-1-04/12/1992:1.21
	checkpoint_17_08_92:1.14
	Ten15_release_19-11-91:1.3
	Ten15_release_21-08-91:1.3
	Ten15_release_19-08-91:1.3
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.46
date	98.02.19.16.46.10;	author mitchell;	state Exp;
branches
	1.46.1.1;
next	1.45;

1.45
date	97.05.19.12.41.13;	author jont;	state Exp;
branches
	1.45.1.1
	1.45.2.1;
next	1.44;

1.44
date	96.11.06.11.33.16;	author matthew;	state Exp;
branches
	1.44.1.1
	1.44.2.1
	1.44.3.1
	1.44.4.1
	1.44.5.1;
next	1.43;

1.43
date	96.10.29.13.28.25;	author io;	state Exp;
branches;
next	1.42;

1.42
date	96.10.02.11.43.10;	author andreww;	state Exp;
branches
	1.42.1.1;
next	1.41;

1.41
date	96.04.30.17.41.57;	author jont;	state Exp;
branches
	1.41.1.1
	1.41.2.1;
next	1.40;

1.40
date	96.04.29.13.49.21;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	96.03.20.12.26.14;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	96.02.26.11.50.24;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.12.04.14.21.33;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	95.03.31.16.28.04;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	95.02.07.12.05.20;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	94.12.07.11.37.45;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.09.22.15.51.10;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	94.02.22.01.45.09;	author nosa;	state Exp;
branches;
next	1.31;

1.31
date	93.11.30.11.23.54;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	93.06.30.15.35.32;	author daveb;	state Exp;
branches
	1.30.1.1;
next	1.29;

1.29
date	93.05.21.14.38.03;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.05.19.16.43.12;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.03.04.10.27.54;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.02.19.12.44.36;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.02.17.15.38.51;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	93.02.02.18.19.34;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	92.12.18.15.55.12;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	92.12.04.19.39.43;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	92.12.03.12.59.08;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	92.10.30.15.50.01;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.10.27.19.08.10;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.10.02.16.05.57;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.08.27.20.14.46;	author davidt;	state Exp;
branches;
next	1.16;

1.16
date	92.08.26.13.13.40;	author davidt;	state Exp;
branches;
next	1.15;

1.15
date	92.08.18.15.36.23;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.08.11.18.00.59;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.08.06.14.23.40;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.07.28.14.50.19;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.07.27.14.00.40;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.07.17.13.23.01;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.05.04.22.04.54;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.04.15.13.25.03;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.02.11.10.04.28;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.01.27.20.13.52;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.11.21.16.45.24;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.11.13.13.50.32;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.07.16.17.16.03;	author colin;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.17.13.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.36.07;	author colin;	state Exp;
branches;
next	;

1.30.1.1
date	93.06.30.15.35.32;	author jont;	state Exp;
branches;
next	;

1.41.1.1
date	96.09.13.11.41.11;	author hope;	state Exp;
branches;
next	;

1.41.2.1
date	96.10.07.16.34.13;	author hope;	state Exp;
branches;
next	;

1.42.1.1
date	96.10.17.11.53.21;	author hope;	state Exp;
branches;
next	;

1.44.1.1
date	96.11.14.13.20.56;	author hope;	state Exp;
branches
	1.44.1.1.1.1;
next	;

1.44.1.1.1.1
date	96.11.28.15.31.56;	author hope;	state Exp;
branches;
next	;

1.44.2.1
date	96.11.22.18.38.42;	author hope;	state Exp;
branches;
next	;

1.44.3.1
date	96.12.17.18.17.43;	author hope;	state Exp;
branches
	1.44.3.1.1.1;
next	;

1.44.3.1.1.1
date	97.02.24.12.11.58;	author hope;	state Exp;
branches;
next	;

1.44.4.1
date	96.12.18.10.12.59;	author hope;	state Exp;
branches;
next	;

1.44.5.1
date	97.05.12.10.51.18;	author hope;	state Exp;
branches
	1.44.5.1.1.1
	1.44.5.1.2.1
	1.44.5.1.3.1;
next	;

1.44.5.1.1.1
date	97.07.28.18.34.39;	author daveb;	state Exp;
branches
	1.44.5.1.1.1.1.1;
next	;

1.44.5.1.1.1.1.1
date	97.10.07.12.00.29;	author jkbrook;	state Exp;
branches;
next	;

1.44.5.1.2.1
date	97.09.08.17.27.33;	author daveb;	state Exp;
branches;
next	;

1.44.5.1.3.1
date	97.09.09.14.24.30;	author daveb;	state Exp;
branches;
next	;

1.45.1.1
date	97.09.10.19.43.27;	author brucem;	state Exp;
branches;
next	;

1.45.2.1
date	97.09.11.21.10.53;	author daveb;	state Exp;
branches;
next	;

1.46.1.1
date	99.04.01.18.09.09;	author daveb;	state Exp;
branches;
next	;


desc
@Functions on environments (datatypes defined in datatypes.sml)
@


1.46
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _environment.sml the functor *)
(*
$Log: _environment.sml,v $
 * Revision 1.45  1997/05/19  12:41:13  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.44  1996/11/06  11:33:16  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.43  1996/10/29  13:28:25  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.42  1996/10/02  11:43:10  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
 * Revision 1.41  1996/04/30  17:41:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.40  1996/04/29  13:49:21  matthew
 * Integer changes
 *
 * Revision 1.39  1996/03/20  12:26:14  matthew
 * Changes to use of cast
 *
 * Revision 1.38  1996/02/26  11:50:24  jont
 * Change newhashtable to hashtable
 *
 * Revision 1.37  1995/12/04  14:21:33  jont
 * Modify no_imptyvars to return the offending tyvar if it exists
 *
Revision 1.36  1995/03/31  16:28:04  matthew
Changing tyfun_ids etc. to stamps

Revision 1.35  1995/02/07  12:05:20  matthew
Improvement to unbound long id errors

Revision 1.34  1994/12/07  11:37:45  matthew
Changing uses of cast

Revision 1.33  1994/09/22  15:51:10  matthew
Added environment lookup functions for vals  and tycons

Revision 1.32  1994/02/22  01:45:09  nosa
Extra TYNAME valenv for Modules Debugger.

Revision 1.31  1993/11/30  11:23:54  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.30  1993/06/30  15:35:32  daveb
Removed exception environments.

Revision 1.29  1993/05/21  14:38:03  matthew
> Simplified printing of envs.

Revision 1.28  1993/05/19  16:43:12  matthew
Fixed problem in compose_maps

Revision 1.27  1993/03/04  10:27:54  matthew
Options & Info changes

Revision 1.26  1993/02/19  12:44:36  matthew
Removed z from function names
Moved realisation stuff to _realise

Revision 1.25  1993/02/17  15:38:51  jont
Used tyname_copy from types

Revision 1.24  1993/02/02  18:19:34  matthew
Changed to structure representation
Experimental memoized structure functions.  These don't seem to work too
well and aren't currently used.

Revision 1.23  1992/12/18  15:55:12  matthew
Propagating options to signature matching error messages.

Revision 1.22  1992/12/04  19:39:43  matthew
Error message revisions.

Revision 1.21  1992/12/03  12:59:08  jont
Replaced some NewMap.fold calls with NewMap.forall

Revision 1.20  1992/10/30  15:50:01  jont
Added special maps for tyfun_id, tyname_id, strname_id

Revision 1.19  1992/10/27  19:08:10  jont
Modified to use less than functions for maps

Revision 1.18  1992/10/02  16:05:57  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.17  1992/08/27  20:14:46  davidt
Yet more changes to get structure copying working better.

Revision 1.16  1992/08/26  13:13:40  davidt
Made some changes to the NewMap signature.

Revision 1.15  1992/08/18  15:36:23  jont
Removed irrelevant handlers and new exceptions

Revision 1.14  1992/08/11  18:00:59  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.13  1992/08/06  14:23:40  jont
Anel's changes to use NewMap instead of Map

Revision 1.11  1992/07/27  14:00:40  jont
Improved enrichment efficiency

Revision 1.10  1992/07/17  13:23:01  jont
Changed to use btrees for renaming of tynames and strnames

Revision 1.9  1992/05/04  22:04:54  jont
Anel's fixes

Revision 1.8  1992/04/15  13:25:03  jont
Some improvements from Anel

Revision 1.7  1992/02/11  10:04:28  clive
New pervasive library code - cut some things out of the initial type basis

Revision 1.6  1992/01/27  20:13:52  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.5  1991/11/21  16:45:24  jont
Added copyright message

Revision 1.4  91/11/13  13:50:32  richard
Used the Strenv module to get the empty structure environment
and the initial structure environment.

Revision 1.3  91/07/16  17:16:03  colin
Replaced Map.domain with Varenv.ve_domain for valenvs (ve_domain makes
everything a Ident.VAR)

Revision 1.2  91/06/17  17:13:00  nickh
Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures.

Revision 1.1  91/06/07  11:36:07  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";

require "../utils/print";
require "../basics/identprint";
require "../typechecker/environment";
require "../typechecker/types";
require "../typechecker/valenv";
require "../typechecker/scheme";
require "../typechecker/strnames";
require "../typechecker/tyenv";
require "../typechecker/strenv";
require "stamp";
require "../utils/hashtable";

functor Environment(
  structure IdentPrint : IDENTPRINT
  structure Print : PRINT
  structure Types : TYPES
  structure Valenv : VALENV
  structure Scheme : TYPESCHEME
  structure Strnames : STRNAMES
  structure Tyenv : TYENV
  structure Strenv : STRENV
  structure HashTable : HASHTABLE
  structure Stamp : STAMP

  sharing Types.Datatypes = Valenv.Datatypes
    = Scheme.Datatypes = Strnames.Datatypes 
    = Tyenv.Datatypes = Strenv.Datatypes
  sharing IdentPrint.Ident = Types.Datatypes.Ident
  sharing type Types.Datatypes.Stamp = Stamp.Stamp
  sharing type Types.Datatypes.StampMap = Stamp.Map.T
    ) : ENVIRONMENT =
  struct
    structure Datatypes = Types.Datatypes

    structure Valenv = Valenv
    structure Exconenv = Valenv
    structure Ident = Datatypes.Ident

    open Datatypes
      
    exception LookupStrId of Ident.StrId
    exception EnrichError of string

    local

      fun strname_hash_fun (STRNAME id) = Stamp.stamp id
        | strname_hash_fun (METASTRNAME (ref strname)) = strname_hash_fun strname
        | strname_hash_fun (NULLNAME id) = Stamp.stamp id

      fun makememotable () =
        HashTable.new (16,Strnames.strname_eq,strname_hash_fun)

      fun lookup(strname,table) =
        case HashTable.tryLookup (table,strname) of
          SOME x => x
        | NONE => []

      fun update_table (table,strname,newentry) =
        HashTable.update (table,strname,newentry)
    in
      fun memoize_strfun (eqtest,f,str) =
        let
          val table = makememotable()
          exception NotFound
          fun f' str =
            let
              fun find [] = raise NotFound
                | find ((str',value)::l) =
                  if eqtest(str,str') then value
                  else find l
              fun get_strname (STR(strname,_,_)) = strname
                | get_strname (COPYSTR(_,str)) = get_strname str
              val strname = get_strname str
            in
              case lookup(strname,table) of
                [] =>
                  let val result = f f' str
                  in
                    update_table(table,strname,[(str,result)]);
                    result
                  end
              | entries => 
                  ((find entries)
		   handle NotFound =>
		     let
		       val result = f f' str
		     in
		       update_table(table,strname,(str,result)::entries);
		       result
		     end)
            end
        in
          f' str
        end
    end

    local
      val cast = MLWorks.Internal.Value.cast
    in
      fun struct_fast_eq (x,y) =
        ((cast x):int) = ((cast y):int)
    end
    fun struct_eq (str as STR(strname,_,ENV(SE se,TE te,ve)),
                   str' as STR(strname',_,ENV(SE se',TE te',ve'))) =
      let
        (* WARNING: this ignores constructor status *)
        val valenv_eq =
          Valenv.valenv_eq
        fun strenv_eq (se,se') =
          NewMap.eq struct_eq (se,se')
        fun tystr_eq (TYSTR (tyfun,valenv),TYSTR(tyfun',valenv')) =
          Types.tyfun_eq(tyfun,tyfun')
          andalso
          valenv_eq(valenv,valenv')
        fun tyenv_eq (te,te') =
          NewMap.eq tystr_eq (te,te')
      in
        (struct_fast_eq (str,str') (* andalso (output(std_out,"Hurray\n");true) *))
        orelse
        (Strnames.strname_eq(strname,strname')
         andalso
         valenv_eq(ve,ve')
         andalso
         tyenv_eq(te,te')
         andalso
         strenv_eq (se,se'))
      end
    | struct_eq (str as COPYSTR(maps,sstr),str' as COPYSTR(maps',sstr')) =
      let
        val smap_eq =
          Stamp.Map.eq Strnames.strname_eq
        val tmap_eq =
          Stamp.Map.eq Types.tyname_eq
        fun maps_eq((smap,tmap),(smap',tmap')) =
          smap_eq(smap,smap')
          andalso
          tmap_eq(tmap,tmap')
      in
        (struct_fast_eq (str,str')
         orelse
         (maps_eq(maps,maps')
          andalso
          struct_eq(sstr,sstr')))
      end
      | struct_eq _ = false

    fun struct_copy strcopyfun (STR(strname,r,ENV(SE se,te,ve))) =
      STR (strname,r,ENV(SE (NewMap.map (fn(_,a) => strcopyfun a) se),
                       te,ve))
      | struct_copy _ str = str

    fun compress_str str =
      let
        val result = memoize_strfun (struct_eq,struct_copy,str)
      in
        result
      end

    (****
     Functions for manipulating the environment (the semantic object).
     ****)

    val empty_env = ENV (Strenv.empty_strenv,
			 Tyenv.empty_tyenv,
			 empty_valenv)

    val initial_env = ENV (Strenv.initial_se,
			   Tyenv.initial_te,
			   Valenv.initial_ve)

    val initial_env_for_builtin_library = 
      ENV (Strenv.initial_se,
           Tyenv.initial_te_for_builtin_library,
           Valenv.initial_ve_for_builtin_library)

    fun empty_envp (ENV (se,te,ve)) = 
      (Strenv.empty_strenvp se) andalso 
      (Tyenv.empty_tyenvp te) andalso 
      (Valenv.empty_valenvp ve)

    fun env_plus_env (ENV (se,te,ve),ENV (se',te',ve')) =
      ENV (Strenv.se_plus_se (se,se'),
	   Tyenv.te_plus_te (te,te'),
	   Valenv.ve_plus_ve (ve,ve'))

    (* DOES THIS WORK? *)
    fun compose_maps ((smap1,tmap1),(smap2,tmap2)) =
      (* do *map1 then *map2, ie. apply map2 to range of map1 *)
      (* ie. *map1 is the inner map *)
      let
        val smap2 =
          Stamp.Map.map
          (fn (n1,n2) =>
           Strnames.strname_copy(n2,smap2))
          smap1
        val tmap2 =
          Stamp.Map.map
          (fn (tyfun,tyname) => Types.tyname_copy(tyname,tmap2))
          tmap1
      in
        (smap2,tmap2)
      end

    fun se_copy (SE amap,strname_copies,tyname_copies) =
      SE(NewMap.map (fn (_, str) => str_copy (str,strname_copies,tyname_copies)) amap)

    and env_copy (ENV (se,te,ve),strname_copies,tyname_copies) =
      ENV (se_copy (se,strname_copies,tyname_copies),
           Tyenv.te_copy (te,tyname_copies),
           Valenv.ve_copy (ve,tyname_copies))

    and str_copy (STR(name,r,env),strname_copies,tyname_copies) =
             STR(Strnames.strname_copy (name,strname_copies),
                 r,
                 env_copy (env,strname_copies,tyname_copies))
      | str_copy (COPYSTR(maps,str),strname_copies,tyname_copies) =
        let val (smap,tmap) = compose_maps (maps,(strname_copies,tyname_copies))
        in
          str_copy (str,smap,tmap)
        end

(*
    and str_copy (str, strname_copies, tyname_copies) =
      let
	fun copy_str copyfn (STR(name,_,ENV(se,te,ve))) =
	  STR(Strnames.strname_copy (name,strname_copies),
	      _,
	      ENV (se_copy (copyfn,se), Tyenv.te_copy (te,tyname_copies),
		   Valenv.ve_copy (ve,tyname_copies)))
          | copy_str copyfn (COPYSTR((smap,tmap),str)) =
            copyfn (str_copy (str,smap,tmap))
(*
            let val (smap,tmap) = compose_maps (maps,(strname_copies,tyname_copies))
            in
              str_copy (str,smap,tmap)
            end
*)
	and se_copy (copyfn,SE amap) =
	  SE(NewMap.map (fn (_, str) => copyfn str) amap)
        val result = memoize_strfun (struct_eq,copy_str,str)
     in
       result
     end
*)

    fun expand_str str =
      let
        fun expand (STR (strid,r,env)) =
          STR (strid,r,expand_env env)
          | expand (COPYSTR((smap,tmap),str)) =
            expand (str_copy (str,smap,tmap))
      in
        expand str
      end

    and expand_se (SE se) =
      SE (NewMap.map (fn (strid,str) => expand_str str) se)

    and expand_env (ENV(se,te,ve)) =
      ENV (expand_se se,te,ve)

    (* This should just copy out the top level of a structure.  Useful for OPEN *)

    fun resolve_top_level (str as STR _) = str
      | resolve_top_level (COPYSTR((smap,tmap),STR(name,r,ENV(se,te,ve)))) =
        let fun se_copy (SE amap) =
          SE(NewMap.map 
             (fn (_,COPYSTR(maps',str')) =>
              COPYSTR(compose_maps(maps',(smap,tmap)),str')
           | (_,str) => COPYSTR((smap,tmap),str))
             amap)
        in 
          STR(Strnames.strname_copy (name,smap),
	      r,
              ENV(se_copy se,
                  Tyenv.te_copy(te,tmap),
                  Valenv.ve_copy (ve,tmap)))
        end
      | resolve_top_level (COPYSTR (maps,str)) =
        resolve_top_level (COPYSTR (maps,resolve_top_level str))

    (****
     Implementation of the operation Abs as defined on p. 22 of The Definition.
     ****)

    fun tyname_make_abs (TYNAME (_,_,_,_,_,_,is_abs_ref,_,_)) = 
                                                      is_abs_ref := true
      | tyname_make_abs (METATYNAME (ref tyfun,_,_,_,_,is_abs_ref)) =
	(case tyfun of
           ETA_TYFUN tyname => tyname_make_abs tyname
         | NULL_TYFUN _ => is_abs_ref := true
         | TYFUN _ => ())

    fun make_abs (TYFUN (_)) = ()
      | make_abs (ETA_TYFUN (tyname)) = tyname_make_abs tyname
      | make_abs (NULL_TYFUN (_)) = ()

    fun abs (TE amap,ENV (se,te,ve)) =
      let 
        val abste =
	  TE(NewMap.fold
	     (fn (map, tycon, TYSTR (tyfun,_)) =>
	      (ignore(Types.make_false tyfun);
               make_abs tyfun;
	       NewMap.define(map, tycon, TYSTR (tyfun,empty_valenv))))
	     (NewMap.empty (Ident.tycon_lt, Ident.tycon_eq), amap))
      in
	ENV (se,Tyenv.te_plus_te (abste,te),ve)
      end
    
    fun lookup_strid (strid,ENV (se,_,_)) = 
      Strenv.lookup (strid,se)

    (* Test this with a "naive" definition *)
    fun lookup_longstrid (Ident.LONGSTRID (Ident.NOPATH,strid),ENV(se,_,_)) =
      (case Strenv.lookup(strid,se) of
         SOME str => str
       | _ => raise LookupStrId strid)
      | lookup_longstrid (Ident.LONGSTRID (Ident.PATH (sym,path),strid),ENV(se,_,_)) =
        let
          fun sort_out (STR (_,_,env)) =
            lookup_longstrid(Ident.LONGSTRID (path,strid), env)
           | sort_out (COPYSTR (maps,str)) =
             COPYSTR(maps,sort_out str)
        in
          case Strenv.lookup (Ident.STRID sym,se) of
            SOME str => sort_out str
          | _ => raise LookupStrId (Ident.STRID sym)
        end


    local
      fun lookup_str (STR (_,_,env),path,valid) =
        follow_path (path,valid,env)
        | lookup_str (COPYSTR ((smap,tmap),str),path,valid) =
          Scheme.scheme_copy (lookup_str (str,path,valid),tmap)

      and follow_path (Ident.NOPATH,valid,ENV (_,_,ve)) = Valenv.lookup (valid,ve)
        | follow_path (Ident.PATH (sym,path),valid,ENV (se,_,_)) =
          case Strenv.lookup (Ident.STRID sym,se) of
            SOME str => lookup_str (str,path,valid)
          | _ => raise LookupStrId (Ident.STRID sym)
    in
      fun lookup_longvalid (Ident.LONGVALID (path,valid),env) =
        follow_path (path,valid,env)
    end

    local
      fun lookup_str (STR (_,_,env),path,tycon) =
        follow_path (path,tycon,env)
        | lookup_str (COPYSTR ((smap,tmap),str),path,tycon) =
          Tyenv.tystr_copy (lookup_str (str,path,tycon),tmap)

      and follow_path (Ident.NOPATH,tycon,ENV (_,te,_)) = Tyenv.lookup (te,tycon)
        | follow_path (Ident.PATH (sym,path),tycon,ENV (se,_,_)) =
          (case Strenv.lookup (Ident.STRID sym,se) of
             SOME str => lookup_str (str,path,tycon)
           | _ => raise LookupStrId (Ident.STRID sym))
    in
      fun lookup_longtycon (Ident.LONGTYCON (path,tycon),env) = 
        follow_path (path,tycon,env)
    end

    fun SE_in_env se = ENV (se,Tyenv.empty_tyenv,empty_valenv)

    fun TE_in_env te = ENV (Strenv.empty_strenv,te,empty_valenv)

    fun VE_in_env ve = ENV (Strenv.empty_strenv,Tyenv.empty_tyenv,ve)

    fun VE_TE_in_env (ve,te) = ENV (Strenv.empty_strenv,te,ve)

    fun string_environment (ENV (se,te,ve)) =
      (if Strenv.empty_strenvp se 
	 then ""
       else
	 "SE\n" ^ (string_strenv se) ^ "\n") ^
	 (if Tyenv.empty_tyenvp te
	    then ""
	  else
	    "TE\n" ^ (Tyenv.string_tyenv te) ^ "\n") (* ^
	    (if Valenv.empty_valenvp ve
	       then ""
	     else
	       "VE\n" ^ (Valenv.string_valenv (0,ve)) ^ "\n") ^
	        *)
	
    and string_strenv (SE amap) = 
      let
        val strid_str_list = NewMap.to_list_ordered amap
	fun make_string (strid,str) = 
	  "structure " ^ IdentPrint.printStrId strid ^ " =\n" ^
	  string_str str ^ "\n"
      in
	concat(map make_string strid_str_list)
      end

    and string_str (STR (name,_,env)) =
      "(" ^ (Strnames.string_strname name) ^ "," ^ "\n" ^
      string_environment env ^ ")" ^ "\n"
      (* Need to string maps here also *)
      | string_str (COPYSTR ((smap,tmap),str)) = 
        let
          fun string_smap smap =
            let
              val strings =
                map (fn (strname_id,strname) =>
                     "(" ^ Stamp.string_stamp strname_id ^
                     " -> " ^  Strnames.string_strname strname ^ ")")
                (Stamp.Map.to_list smap)
            in
              concat ("{" :: strings @@ ["}"])
            end
          fun string_tmap tmap =
            let
              val strings =
                map (fn (tyfun_id,tyname) =>
                     "(" ^ Int.toString (Stamp.stamp tyfun_id) ^
                     " -> " ^  Types.debug_print_name tyname ^ ")")
                (Stamp.Map.to_list tmap)
            in
              concat ("{" :: strings @@ ["}"])
            end
        in
          "COPYSTR (" ^ string_tmap tmap ^ string_smap smap ^ string_str str ^ ")"
        end

    (* return true if the environment has no imperative type variables *)
    fun no_imptyvars (ENV (SE amap',_,VE (_,amap))) = 
      let 
	fun look_at_schemes(found as SOME _, _, scheme) =
	  found
	  | look_at_schemes(_, _, scheme) = Scheme.has_free_imptyvars scheme
        (* Would be nice not to copy out here *)
        fun aux (found as SOME _, _, STR(_,_,env)) = found
	  | aux (_, _, STR(_,_,env)) = no_imptyvars env
          | aux (found, x,COPYSTR((smap,tmap),str)) =
(*
            aux (found, x,str_copy(str,smap,tmap))
*)
	    aux (found, x, str) (* Ignore the copy, it's irrelevant for this *)
      in
	case NewMap.fold look_at_schemes (NONE, amap) of
	  NONE => NewMap.fold aux (NONE, amap')
	| x => x
      end

  end
@


1.46.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.46  1998/02/19  16:46:10  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.45
log
@[Bug #30090]
Translate output std_out to print
@
text
@d4 4
d458 1
a458 1
	      (Types.make_false tyfun;
@


1.45.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.45  1997/05/19  12:41:13  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.45.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.45  1997/05/19  12:41:13  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.44
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d234 8
a241 8
                  ((let val x = find entries in (* output(std_out,"Hit!\n");*) x end)
                      handle NotFound =>
                        let val result = f f' str
                        in
                          MLWorks.IO.output(MLWorks.IO.std_out,"Poo!\n");
                          update_table(table,strname,(str,result)::entries);
                          result
                        end)
d294 1
a294 3
          struct_eq(sstr,sstr')
          andalso
          (MLWorks.IO.output(MLWorks.IO.std_out,"Copystr match\n");true)))
@


1.44.5.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:33:16  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.44.5.1  1997/05/12  10:51:18  hope
 * branched from 1.44
 *
@


1.44.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.44.5.1  1997/05/12  10:51:18  hope
 * branched from 1.44
 *
@


1.44.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.44.5.1  1997/05/12  10:51:18  hope
 * branched from 1.44
 *
@


1.44.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.44.5.1.1.1  1997/07/28  18:34:39  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.44.4.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:33:16  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.3.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:33:16  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.3.1.1.1
log
@branched from 1.44.3.1
@
text
@a3 3
 * Revision 1.44.3.1  1996/12/17  18:17:43  hope
 * branched from 1.44
 *
@


1.44.2.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:33:16  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.1.1
log
@branched from 1.44
@
text
@a3 4
 * Revision 1.44  1996/11/06  11:33:16  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.44.1.1.1.1
log
@branched from 1.44.1.1
@
text
@a3 3
 * Revision 1.44.1.1  1996/11/14  13:20:56  hope
 * branched from 1.44
 *
@


1.43
log
@[Bug #1614]
basifying String
@
text
@d4 4
d146 1
a146 1
require "../basis/__integer";
@


1.42
log
@[Bug #1592]
Threading extra level argument through tynames.
@
text
@d4 4
d198 2
a199 2
          MLWorks.Option.SOME x => x
        | MLWorks.Option.NONE => []
d462 1
a462 1
         MLWorks.Option.SOME str => str
d472 1
a472 1
            MLWorks.Option.SOME str => sort_out str
d486 1
a486 1
            MLWorks.Option.SOME str => lookup_str (str,path,valid)
d502 1
a502 1
             MLWorks.Option.SOME str => lookup_str (str,path,tycon)
d539 1
a539 1
	String.implode(map make_string strid_str_list)
d556 1
a556 1
              String.implode ("{" :: strings @@ ["}"])
d566 1
a566 1
              String.implode ("{" :: strings @@ ["}"])
d575 1
a575 1
	fun look_at_schemes(found as MLWorks.Option.SOME _, _, scheme) =
d579 1
a579 1
        fun aux (found as MLWorks.Option.SOME _, _, STR(_,_,env)) = found
d587 2
a588 2
	case NewMap.fold look_at_schemes (MLWorks.Option.NONE, amap) of
	  MLWorks.Option.NONE => NewMap.fold aux (MLWorks.Option.NONE, amap')
@


1.42.1.1
log
@branched from 1.42
@
text
@a3 4
 * Revision 1.42  1996/10/02  11:43:10  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.41
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d427 2
a428 1
    fun tyname_make_abs (TYNAME (_,_,_,_,_,_,is_abs_ref,_)) = is_abs_ref := true
@


1.41.2.1
log
@branched from 1.41
@
text
@a3 6
 * Revision 1.41  1996/04/30  17:41:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a3 6
 * Revision 1.41  1996/04/30  17:41:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.40
log
@Integer changes
@
text
@d4 3
d220 1
a220 1
                          output(std_out,"Poo!\n");
d278 1
a278 1
          (output(std_out,"Copystr match\n");true)))
d528 1
a528 1
	implode(map make_string strid_str_list)
d545 1
a545 1
              implode ("{" :: strings @@ ["}"])
d555 1
a555 1
              implode ("{" :: strings @@ ["}"])
@


1.39
log
@Changes to use of cast
@
text
@d4 3
d129 2
d548 1
a548 1
                     "(" ^ MLWorks.Integer.makestring (Stamp.stamp tyfun_id) ^
@


1.38
log
@Change newhashtable to hashtable
@
text
@d4 3
d223 1
a223 1
      val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
d226 1
a226 1
        ((castit x):int) = ((castit y):int)
@


1.37
log
@Modify no_imptyvars to return the offending tyvar if it exists
@
text
@d4 3
d133 1
a133 1
require "../utils/newhashtable";
d144 1
a144 1
  structure HashTable : NEWHASHTABLE
d177 2
a178 2
          HashTable.YES x => x
        | HashTable.NO => []
@


1.36
log
@Changing tyfun_ids etc. to stamps
@
text
@d4 3
d550 3
a552 2
	fun look_at_schemes (_, scheme) =
	  not (Scheme.has_free_imptyvars (scheme))
d554 7
a560 3
        fun aux (_, STR(_,_,env)) = no_imptyvars env
          | aux (x,COPYSTR((smap,tmap),str)) = 
            aux (x,str_copy(str,smap,tmap))
d562 3
a564 2
	NewMap.forall look_at_schemes amap andalso
	NewMap.forall aux amap'
@


1.35
log
@Improvement to unbound long id errors
@
text
@d4 3
d126 1
d139 2
d144 4
a147 1
  sharing IdentPrint.Ident = Types.Datatypes.Ident) : ENVIRONMENT =
d162 3
a164 6
      fun strname_hash_fun (STRNAME id) =
        Strname_id.strname_id id
        | strname_hash_fun (METASTRNAME (ref strname)) =
          strname_hash_fun strname
        | strname_hash_fun (NULLNAME id) =
          Strname_id.strname_id id
d247 1
a247 1
          Strname_id.Map.eq Strnames.strname_eq
d249 1
a249 1
          Tyfun_id.Map.eq Types.tyname_eq
d307 1
d310 1
a310 1
          Strname_id.Map.map
d315 2
a316 4
          Tyfun_id.Map.map
          (fn (tyfun,tyname) =>
           Types.tyname_copy(tyname,tmap2)
           handle Tyfun_id.Map.Undefined => tyname)
d322 1
a322 14
    fun expand_str str =
      let
        fun expand (STR (strid,r,ENV(se,te,ve))) =
          (STR (strid,r,ENV(expand_se se,te,ve)))
          | expand (COPYSTR((smap,tmap),str)) =
            expand (str_copy (str,smap,tmap))
        and
          expand_se (SE se) =
          SE (NewMap.map (fn (strid,str) => expand_str str) se)
      in
        expand str
      end

    and se_copy (SE amap,strname_copies,tyname_copies) =
d364 16
d507 3
a509 8
	fun make_string(strid,STR (m,_,env)) = 
	  "structure " ^ 
	  IdentPrint.printStrId strid ^ 
	  " (" ^ (Strnames.string_strname m) ^ ") \n" ^ 
	  "struct\n\n" ^ 
	  (string_environment env) ^ "end\n"
          | make_string (strid,COPYSTR ((smap,tmap),str)) = 
            make_string (strid,str_copy (str,smap,tmap))
d517 1
d519 24
a542 1
        string_str (str_copy (str,smap,tmap))
d549 1
@


1.34
log
@Changing uses of cast
@
text
@d4 3
a115 1
require "../typechecker/ty_debug";
a122 1
require "../typechecker/tystr";
a126 5
  structure Debug :
    sig
      val set_debug_level : int -> unit
      val debug_level : unit -> int
    end
a127 1
  structure Ty_Debug : TY_DEBUG
a132 1
  structure Tystr : TYSTR
a137 1
    = Tystr.Datatypes
a145 1
    val do_debug = Ty_Debug.do_debug
d148 1
a148 2
    exception Lookup_StrId = Strenv.Lookup_in_SE
    exception Lookup_LongStrId = Lookup_StrId
a150 1

d421 1
a421 6
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("strid lookup \n");
	       Print.print (IdentPrint.printStrId strid);
	       Print.print ("\n"))
       else ();
	 Strenv.lookup (strid,se))
d424 4
a427 2
    fun lookup_longstrid (Ident.LONGSTRID (Ident.NOPATH,strid),ENV(se,_,_))=
      Strenv.lookup(strid,se)
d435 3
a437 1
          sort_out (Strenv.lookup(Ident.STRID sym,se))
d449 3
a451 1
          lookup_str (Strenv.lookup (Ident.STRID sym,se),path,valid)
d456 1
d461 1
a461 1
          Tystr.tystr_copy (lookup_str (str,path,tycon),tmap)
d465 3
a467 2
          lookup_str (Strenv.lookup (Ident.STRID sym,se),path,tycon)

a480 2
    fun te_of_env (ENV (_,te,_)) = te

a515 3

    fun get_env_from_str (STR (_,_,env)) = env
      | get_env_from_str str = get_env_from_str(resolve_top_level str)
@


1.33
log
@Added environment lookup functions for vals  and tycons
@
text
@d4 3
d217 6
a222 3
    fun struct_fast_eq (x,y) =
      ((MLWorks.Internal.Value.cast x):int) = ((MLWorks.Internal.Value.cast y):int)

@


1.32
log
@Extra TYNAME valenv for Modules Debugger.
@
text
@d4 3
d118 1
d135 1
d141 1
d333 19
a375 22
    and str_copy (str, strname_copies, tyname_copies) =
      let
	fun copy_str (STR(name,r,ENV(se,te,ve))) =
	  STR(Strnames.strname_copy (name,strname_copies),
	      r,
	      ENV (se_copy se, Tyenv.te_copy (te,tyname_copies),
		   Valenv.ve_copy (ve,tyname_copies)))
          | copy_str (COPYSTR(maps,str)) =
            let val (smap,tmap) = compose_maps (maps,(strname_copies,tyname_copies))
            in
              str_copy (str,smap,tmap)
            end


	and se_copy (SE amap) =
	  SE(NewMap.map (fn (_, str) => copy_str str) amap)
        val result = copy_str str
     in
       result
     end


a431 17
    fun find_env (strid,ENV (se,_,_)) = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("find_env \n");
	       Print.print (IdentPrint.printStrId strid);
	       Print.print ("\n"))
       else ();
         let fun get_env (STR (_,_,env)) = env
           | get_env (COPYSTR ((smap,tmap),str)) =
               get_env (str_copy (str,smap,tmap))
         in
           get_env (Strenv.lookup (strid,se))
         end)

(*
    fun lookup_longstrid (Ident.LONGSTRID (path,strid),env) =
      Lookup_strid (strid,Ident.followPath find_env (path,env)) 
*)
d444 29
@


1.31
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d397 1
a397 1
    fun tyname_make_abs (TYNAME (_,_,_,_,_,_,is_abs_ref)) = is_abs_ref := true
@


1.30
log
@Removed exception environments.
@
text
@d4 3
a29 1
,
d394 11
d411 1
@


1.30.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.30  1993/06/30  15:35:32  daveb
Removed exception environments.

@


1.29
log
@> Simplified printing of envs.
@
text
@d4 3
d206 2
a207 2
    fun struct_eq (str as STR(strname,_,ENV(SE se,TE te,ve,ee)),
                   str' as STR(strname',_,ENV(SE se',TE te',ve',ee'))) =
a226 2
         valenv_eq(ee,ee')
         andalso
d252 3
a254 3
    fun struct_copy strcopyfun (STR(strname,refint,ENV(SE se,te,ve,ee))) =
      STR (strname,refint,ENV(SE (NewMap.map (fn(_,a) => strcopyfun a) se),
                       te,ve,ee))
a269 1
			 empty_valenv,
d274 1
a274 2
			   Valenv.initial_ve,
			   Exconenv.initial_ee)
d279 1
a279 2
           Valenv.initial_ve_for_builtin_library,
           Exconenv.initial_ee)
d281 1
a281 1
    fun empty_envp (ENV (se,te,ve,ee)) = 
d284 1
a284 2
      (Valenv.empty_valenvp ve) andalso
      (Exconenv.empty_valenvp ee)
d286 1
a286 1
    fun env_plus_env (ENV (se,te,ve,ee),ENV (se',te',ve',ee')) =
d289 1
a289 2
	   Valenv.ve_plus_ve (ve,ve'),
	   Exconenv.ve_plus_ve (ee,ee'))
d312 2
a313 2
        fun expand (STR (strid,int,ENV(se,te,ve,ee))) =
          (STR (strid,int,ENV(expand_se se,te,ve,ee)))
d325 1
a325 1
	fun copy_str copyfn (STR(name,int,ENV(se,te,ve,ee))) =
d327 1
a327 1
              int,
d329 1
a329 2
		   Valenv.ve_copy (ve,tyname_copies),
		   Valenv.ve_copy (ee,tyname_copies)))
d348 1
a348 1
	fun copy_str (STR(name,int,ENV(se,te,ve,ee))) =
d350 1
a350 1
              int,
d352 1
a352 2
		   Valenv.ve_copy (ve,tyname_copies),
		   Valenv.ve_copy (ee,tyname_copies)))
d371 1
a371 1
      | resolve_top_level (COPYSTR((smap,tmap),STR(name,int,ENV(se,te,ve,ee)))) =
d379 2
a380 1
          STR(Strnames.strname_copy (name,smap),int,
d383 1
a383 2
                  Valenv.ve_copy (ve,tmap),
                  Valenv.ve_copy (ee,tmap)))
d392 1
a392 1
    fun abs (TE amap,ENV (se,te,ve,ee)) =
d401 1
a401 1
	ENV (se,Tyenv.te_plus_te (abste,te),ve,ee)
d404 1
a404 1
    fun lookup_strid (strid,ENV (se,_,_,_)) = 
d412 1
a412 1
    fun find_env (strid,ENV (se,_,_,_)) = 
d430 1
a430 1
    fun lookup_longstrid (Ident.LONGSTRID (Ident.NOPATH,strid),ENV(se,_,_,_))=
d432 1
a432 1
      | lookup_longstrid (Ident.LONGSTRID (Ident.PATH (sym,path),strid),ENV(se,_,_,_)) =
d442 1
a442 5
    fun SE_in_env se = ENV (se,Tyenv.empty_tyenv,empty_valenv,empty_valenv)

    fun TE_in_env te = ENV (Strenv.empty_strenv,te,empty_valenv,empty_valenv)

    fun VE_in_env ve = ENV (Strenv.empty_strenv,Tyenv.empty_tyenv,ve,empty_valenv)
d444 1
a444 1
    fun EE_in_env ee = ENV (Strenv.empty_strenv,Tyenv.empty_tyenv,empty_valenv,ee)
d446 1
a446 1
    fun VE_TE_in_env (ve,te) = ENV (Strenv.empty_strenv,te,ve,empty_valenv)
d448 1
a448 1
    fun VE_EE_in_env (ve,ee) = ENV (Strenv.empty_strenv,Tyenv.empty_tyenv,ve,ee)
d450 1
a450 1
    fun te_of_env (ENV (_,te,_,_)) = te
d452 1
a452 1
    fun string_environment (ENV (se,te,ve,ee)) =
d465 1
a465 3
	       (if Valenv.empty_valenvp ee
		  then ""
		else "EE\n" ^ (Valenv.string_valenv(0,ee)) ^ "\n") *)
d492 1
a492 1
    fun no_imptyvars (ENV (SE amap',_,VE (_,amap),_)) = 
@


1.28
log
@Fixed problem in compose_maps
@
text
@d4 3
d298 15
a312 10
      (Strname_id.Map.map
       (fn (n1,n2) =>
        Strnames.strname_copy(n2,smap2)
        handle Strname_id.Map.Undefined => n2)
       smap1,
       Tyfun_id.Map.map
       (fn (tyfun,tyname) =>
        Types.tyname_copy(tyname,tmap2)
        handle Tyfun_id.Map.Undefined => tyname)
       tmap1)
d470 1
a470 1
	    "TE\n" ^ (Tyenv.string_tyenv te) ^ "\n") ^
d477 1
a477 1
		else "EE\n" ^ (Valenv.string_valenv(0,ee)) ^ "\n")
@


1.27
log
@Options & Info changes
@
text
@d4 3
d295 10
a304 2
      (Strname_id.Map.map (fn (n1,n2) => Strnames.strname_copy(n2,smap2)) smap1,
       Tyfun_id.Map.map (fn (tyfun,tyname) => Types.tyname_copy(tyname,tmap2)) tmap1)
@


1.26
log
@Removed z from function names
Moved realisation stuff to _realise
@
text
@d4 4
a128 1
    structure Info = Types.Info
@


1.25
log
@Used tyname_copy from types
@
text
@d4 3
a117 1
  sharing Types.Info = Valenv.Info
d122 1
a122 1
    structure Varenv = Valenv
d155 1
a155 1
      fun zmemoize_strfun (eqtest,f,str) =
d191 1
a191 1
    fun zstruct_fast_eq (x,y) =
d194 1
a194 1
    fun zstruct_eq (str as STR(strname,_,ENV(SE se,TE te,ve,ee)),
d201 1
a201 1
          NewMap.eq zstruct_eq (se,se')
d209 1
a209 1
        (zstruct_fast_eq (str,str') (* andalso (output(std_out,"Hurray\n");true) *))
d221 1
a221 1
    | zstruct_eq (str as COPYSTR(maps,sstr),str' as COPYSTR(maps',sstr')) =
d232 1
a232 1
        (zstruct_fast_eq (str,str')
d236 1
a236 1
          zstruct_eq(sstr,sstr')
d240 1
a240 1
      | zstruct_eq _ = false
d242 1
a242 1
    fun zstruct_copy strcopyfun (STR(strname,refint,ENV(SE se,te,ve,ee))) =
d245 1
a245 1
      | zstruct_copy _ str = str
d247 1
a247 1
    fun zcompress_str str =
d249 1
a249 1
        val result = zmemoize_strfun (zstruct_eq,zstruct_copy,str)
d265 1
a265 1
			   Varenv.initial_ve,
d271 1
a271 1
           Varenv.initial_ve_for_builtin_library,
d277 1
a277 1
      (Varenv.empty_valenvp ve) andalso
d283 1
a283 1
	   Varenv.ve_plus_ve (ve,ve'),
d311 2
a312 2
		   Varenv.ve_copy (ve,tyname_copies),
		   Varenv.ve_copy (ee,tyname_copies)))
d323 1
a323 1
        val result = zmemoize_strfun (zstruct_eq,copy_str,str)
d335 2
a336 2
		   Varenv.ve_copy (ve,tyname_copies),
		   Varenv.ve_copy (ee,tyname_copies)))
d366 2
a367 2
                  Varenv.ve_copy (ve,tmap),
                  Varenv.ve_copy (ee,tmap)))
d449 1
a449 1
	    (if Varenv.empty_valenvp ve
d452 2
a453 2
	       "VE\n" ^ (Varenv.string_valenv (0,ve)) ^ "\n") ^
	       (if Varenv.empty_valenvp ee
d455 1
a455 1
		else "EE\n" ^ (Varenv.string_valenv(0,ee)) ^ "\n")
a477 70
    (****
     Enrichment test for environments. (See p. 34 of The Definition)
     ****)
    fun env_enriches options (level,ENV (se as SE se_map,te,ve,ee),
                                         ENV (se' as SE se_map',te',ve',ee')) = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("env_enriches \n");
	       Print.print ("SE = \n");
	       Print.print ((string_strenv se) ^ "\n");
	       Print.print ("SE' = \n");
	       Print.print ((string_strenv se') ^ "\n"))
       else ();
	 se_ran_enriches options (level,se,se')
	 andalso
	 Tyenv.te_ran_enriches (te,te')
         andalso  
	 Varenv.ve_ran_enriches options (level,ve,ve') 
         andalso
	 Varenv.ee_ran_eq (ee,ee'))
	 handle Tyenv.EnrichError s => raise EnrichError s
	      | Varenv.EnrichError s => raise EnrichError s
		  
    and str_enriches options (level,str,str') =
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("str_enriches");
	       Print.print ("\n"))
       else ();
         let
           val (STR (strname,_,env)) = str
           val (STR (strname',_,env')) = str'
         in
           Strnames.strname_eq (strname,strname')
           andalso
           env_enriches options (level,env,env')
         end)
      
    and se_ran_enriches options (level,SE amap,SE amap') = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("se_ran_enriches");
	       Print.print ("\n"))
       else ();
      let 
	fun ran_enriches(strid, str) =
	  let
	    val str' = case NewMap.tryApply'(amap', strid) of
	      NewMap.YES x => x
	    | _ =>
                (* this is caught by realise *)
		raise EnrichError ("Unmatched structure specification : " ^
				   (IdentPrint.printStrId strid) ^ "\n")
	  in
	    str_enriches options (level,str,str')
	  end

	val result = NewMap.forall ran_enriches amap

	val _ = 
	  if (do_debug andalso Debug.debug_level () > 10) 
	    then 
	      (if result 
		 then
		   Print.print ("se_ran_enriches successful\n")
	       else
		 Print.print ("se_ran_enriches unsuccessful\n"))
	  else 
	    ()
      in
	result
      end)
    
d481 1
a482 4
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("Env.no_imptyvars");
	       Print.print ("\n"))
       else ();
d492 1
a492 1
      end)
@


1.24
log
@Changed to structure representation
Experimental memoized structure functions.  These don't seem to work too
well and aren't currently used.
@
text
@d4 5
a283 9
    fun tyname_copy (METATYNAME {1 = ref (NULL_TYFUN id), ...}, tyname_copies) =
        Tyfun_id.Map.apply' (tyname_copies,id)
      | tyname_copy (METATYNAME {1 = ref (ETA_TYFUN meta), ...}, tyname_copies) =
	tyname_copy(meta, tyname_copies)
      | tyname_copy (METATYNAME(ref tyfun, name, a, ref eq, ref ve), tyname_copies) =
	METATYNAME(ref (Types.tyfun_copy(tyfun, tyname_copies)), name, a, ref eq, ref ve)
      | tyname_copy (tyname, _) = tyname


d288 1
a288 1
       Tyfun_id.Map.map (fn (tyfun,tyname) => tyname_copy(tyname,tmap2)) tmap1)
@


1.23
log
@Propagating options to signature matching error messages.
,
@
text
@d4 4
d89 1
d106 1
d127 120
d278 96
a373 1
    
d404 6
a409 5
	 let
	   val STR (_,env) = Strenv.lookup (strid,se)
	 in
	   env
	 end)
d411 1
d413 14
a426 1
      lookup_strid (strid,Ident.followPath find_env (path,env)) 
d462 1
a462 1
	fun make_string(strid,STR (m,env)) = 
d468 2
d474 1
a474 1
    and string_str (STR (name,env)) =
d477 2
d502 1
a502 1
    and str_enriches options (level,STR (strname,env),STR (strname',env')) =
d507 8
a514 3
	 Strnames.strname_eq (strname,strname')
	 andalso
	 env_enriches options (level,env,env'))
d550 2
a551 1
    fun get_env_from_str (STR (_,env)) = env
d561 3
d566 1
a566 1
	NewMap.forall (fn (_, STR(_, env)) => no_imptyvars env) amap'
d569 1
a569 14
    fun str_copy (str, strname_copies, tyname_copies) =
      let
	fun copy_str (STR(name, ENV(se,te,ve,ee))) =
	  STR(Strnames.strname_copy (name,strname_copies),
	      ENV (se_copy se, Tyenv.te_copy (te,tyname_copies),
		   Varenv.ve_copy (ve,tyname_copies),
		   Varenv.ve_copy (ee,tyname_copies)))
    
	and se_copy (SE amap) =
	  SE(NewMap.map (fn (_, str) => copy_str str) amap)
      in
	copy_str str
      end
  end;
@


1.22
log
@Error message revisions.
@
text
@d4 3
d104 1
d112 1
d243 2
a244 2
    fun env_enriches (level,ENV (se as SE se_map,te,ve,ee),
		      ENV (se' as SE se_map',te',ve',ee')) = 
d252 1
a252 1
	 se_ran_enriches (level,se,se')
d256 1
a256 1
	 Varenv.ve_ran_enriches (level,ve,ve') 
d262 1
a262 1
    and str_enriches (level,STR (strname,env),STR (strname',env')) =
d269 1
a269 1
	 env_enriches (level,env,env'))
d271 1
a271 1
    and se_ran_enriches (level,SE amap,SE amap') = 
d286 1
a286 1
	    str_enriches (level,str,str')
@


1.21
log
@Replaced some NewMap.fold calls with NewMap.forall
@
text
@d4 3
d277 1
@


1.20
log
@Added special maps for tyfun_id, tyname_id, strname_id
@
text
@d4 3
d261 1
a261 2
	 (env_enriches (level,env,env')
	  handle EnrichError s => raise EnrichError s))
d269 1
a269 1
	fun ran_enriches(res, strid, str) =
d277 1
a277 1
	    res andalso str_enriches (level,str,str')
d280 1
a280 1
	val result = NewMap.fold ran_enriches(true, amap)
@


1.19
log
@Modified to use less than functions for maps
@
text
@d4 3
a147 3
(*
        val tycon_tystr_list = NewMap.to_list amap
*)
d269 3
a271 2
	    val str' = NewMap.apply'(amap', strid)
	      handle NewMap.Undefined => 
@


1.18
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d98 1
a99 1

d153 1
a153 1
	     (NewMap.empty (tycon_order,tycon_equal), amap))
@


1.17
log
@Yet more changes to get structure copying working better.
@
text
@d4 3
d150 1
a150 1
	     (NewMap.empty tycon_order, amap))
@


1.16
log
@Made some changes to the NewMap signature.
@
text
@d4 3
d302 7
a308 19
    fun str_copy (STR (name,ENV (se,te,ve,ee)),strname_copies,tyname_copies,
		  strnamecopy_fun,tynamecopy_fun) = 
      let 
	val (name',strname_copies') = 
	  if Strnames.uninstantiated (name) 
	    then Strnames.strname_copy (name,strname_copies,strnamecopy_fun)
	  else (name,strname_copies)
	val (se',strname_copies'',tyname_copies') = 
	  se_copy (se,strname_copies',tyname_copies,strnamecopy_fun,
		   tynamecopy_fun)
	val (te',tyname_copies'') = Tyenv.te_copy (te,tyname_copies',
						   tynamecopy_fun)
	val (ve',tyname_copies''') = Varenv.ve_copy (ve,tyname_copies'',
						     tynamecopy_fun)
	val (ee',tyname_copies'''') = Varenv.ve_copy (ee,tyname_copies''',
						      tynamecopy_fun)
      in
	(STR (name',ENV (se',te',ve',ee')),strname_copies'',tyname_copies'''')
      end
d310 2
a311 11
    and se_copy (SE amap,strname_copies,tyname_copies,strnamecopy_fun,
                 tynamecopy_fun) = 
      let
	fun copy_strs((se', strname_copies,tyname_copies), strid, str) =
	  let 
	    val (str',strname_copies',tyname_copies') = 
	      str_copy (str,strname_copies,tyname_copies,
			strnamecopy_fun,tynamecopy_fun)
	  in
	    (Strenv.add_to_se(strid,str',se'),strname_copies',tyname_copies')
	  end
d313 1
a313 3
	NewMap.fold
	copy_strs
	((Strenv.empty_strenv, strname_copies,tyname_copies), amap)
a314 1

@


1.15
log
@Removed irrelevant handlers and new exceptions
@
text
@d4 3
d292 1
a292 1
	fun look_at_schemes scheme =
d295 2
a296 3
	NewMap.forall look_at_schemes amap
	andalso
	NewMap.forall (fn (STR(_, env)) => no_imptyvars env) amap'
@


1.14
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d91 2
a92 2
    exception Lookup_StrId
    exception Lookup_LongStrId
d152 1
a152 2
	 Strenv.lookup (strid,se) 
	 handle Strenv.Lookup_in_SE => raise Lookup_StrId)
d160 2
a161 2
	 let val STR (_,env) = Strenv.lookup (strid,se) 
	   handle Strenv.Lookup_in_SE => raise Lookup_StrId
a167 1
      handle Lookup_StrId => raise Lookup_LongStrId
d231 1
a231 2
	 (Tyenv.te_ran_enriches (te,te')
            handle Tyenv.EnrichError s => raise EnrichError s)
d233 1
a233 2
	 (Varenv.ve_ran_enriches (level,ve,ve') 
            handle Varenv.EnrichError s => raise EnrichError s)
d235 3
a237 2
	 (Varenv.ee_ran_eq (ee,ee')
	    handle Varenv.EnrichError s => raise EnrichError s))
@


1.13
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d38 1
a38 1
> Modified to take new ValEnv definition with ref unit to allow
a46 3
require "../utils/newmap";
require "../utils/lists";
require "../utils/crash";
d48 1
a49 1
require "../typechecker/datatypes";
d59 1
a59 3
  structure NewMap: NEWMAP
  structure Lists : LISTS
  structure Crash : CRASH
a66 1
  structure Datatypes : DATATYPES
d73 1
a73 2
  sharing NewMap = Valenv.NewMap = Tyenv.NewMap = Strnames.NewMap
  sharing Datatypes = Types.Datatypes = Valenv.Datatypes
d75 2
a76 2
    = Tyenv.Datatypes = Strenv.Datatypes) : ENVIRONMENT =
  
d78 1
a78 2
    structure NewMap = NewMap
    structure Datatypes = Datatypes
d129 1
d131 7
a137 7
        val abste = TE (NewMap.from_list 
                        tycon_order
                        (map 
                        (fn (tycon,TYSTR (tyfun,_)) =>
			 (Types.make_false tyfun;
			  (tycon,TYSTR (tyfun,empty_valenv))))
                        tycon_tystr_list))
d201 6
a206 8
	fun make_string ([]) = ""
	  | make_string ((strid,STR (m,env))::assoc) = 
	    "structure " ^ 
	    IdentPrint.printStrId strid ^ 
	    " (" ^ (Strnames.string_strname m) ^ ") \n" ^ 
	    "struct\n\n" ^ 
	    (string_environment env) ^ "end\n" ^
	    (make_string assoc)
d208 1
a208 1
	make_string strid_str_list
d254 9
a262 1
	val strid_str_list = NewMap.to_list_ordered amap
d264 1
a264 12
	fun ran_enriches [] = true
	  | ran_enriches ((strid,str)::strid_strs) =  
            let
              val str' = NewMap.apply amap' strid
                handle NewMap.Undefined => 
                  raise EnrichError ("Unmatched structure specification : " ^
                                     (IdentPrint.printStrId strid) ^ "\n")
            in
              str_enriches (level,str,str')
              andalso 
              ran_enriches strid_strs
           end
a265 2
	val result = ran_enriches strid_str_list

d288 2
a289 5
	fun look_at_schemes [] = true
	  | look_at_schemes ((var,scheme)::var_schemes) = 
	    (not (Scheme.has_free_imptyvars (scheme)))
	    andalso
	    look_at_schemes var_schemes
d291 1
a291 1
	look_at_schemes (NewMap.to_list amap)
d293 1
a293 1
	se_no_imptyvars (NewMap.to_list amap')
a295 6
    and se_no_imptyvars [] = true
      | se_no_imptyvars ((strid,STR (_,env))::strid_strs) =
	no_imptyvars env
	andalso 
	se_no_imptyvars strid_strs
      
d319 8
a326 14
	val strid_str_list = NewMap.to_list amap
	fun copy_strs ([],strname_copies,tyname_copies,se',_,_) = 
	  (se',strname_copies,tyname_copies)
	  | copy_strs ((strid,str)::strid_strs,strname_copies,tyname_copies,
                       se',strnamecopy_fun,tynamecopy_fun) = 
	    let 
	      val (str',strname_copies',tyname_copies') = 
		str_copy (str,strname_copies,tyname_copies,
			  strnamecopy_fun,tynamecopy_fun)
	    in
	      copy_strs (strid_strs,strname_copies',tyname_copies',
			 Strenv.add_to_se (strid,str',se'),strnamecopy_fun,
			 tynamecopy_fun)
	    end
d328 3
a330 2
	copy_strs (strid_str_list,strname_copies,tyname_copies,Strenv.empty_strenv,
		   strnamecopy_fun,tynamecopy_fun)
a331 1

@


1.12
log
@Removed use of Array parameter to allow pervasive Array to be used
@
text
@d88 1
a93 1
    exception Lookup_StrId_in_SE
d100 1
a100 1
    val empty_env = ENV (Strenv.empty_se,
d102 2
a103 2
			 Varenv.empty_valenv,
			 Exconenv.empty_valenv)
d111 1
a111 1
      ENV (Strenv.empty_se,
a115 2
fun empty_strenvp (SE amap) = Mapping.emptymap_p amap

d117 1
a117 1
      (empty_strenvp se) andalso 
d122 5
a126 10
    fun strenv_plus_strenv (SE strenv,SE strenv') =
      SE (Mapping.plus(strenv,strenv',Ident.strid_order))

    fun add_to_se (strid,str,SE amap) = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("add_to_se \n");
	       Print.print (IdentPrint.printStrId strid);
	       Print.print ("\n"))
       else ();
      SE (Mapping.add ((strid,str),amap,Ident.strid_order)))
a127 10
    fun member_of_se_domain (strid, SE amap) = 
      Mapping.domain_member (strid,amap)

    fun env_plus_env (ENV (SE strenv,tyenv,varenv,exconenv),
		      ENV (SE strenv',tyenv',varenv',exconenv')) =
      ENV (SE (Mapping.plus(strenv,strenv',Ident.strid_order)),
	   Tyenv.te_plus_te(tyenv,tyenv'),
	   Varenv.ve_plus_ve(varenv,varenv'),
	   Exconenv.ve_plus_ve(exconenv,exconenv'))
    
d132 10
a141 6
    fun abs (TE amap,ENV(se,te,ve,ee)) =
      let val abste = TE 
	(Mapping.mapit (amap,
			fn (TYSTR(atyfun,_)) =>
			(Types.make_false atyfun;
			 TYSTR (atyfun,Varenv.empty_valenv))))
d146 1
a146 1
    fun lookup_strid (astrid,ENV (SE (amap),_,_,_)) = 
d149 1
a149 1
	       Print.print (IdentPrint.printStrId astrid);
d152 2
a153 2
	 Mapping.lookup (astrid,amap) 
	 handle Mapping.Lookup => raise Lookup_StrId)
d155 1
a155 1
    fun find_env (astrid,ENV (SE (amap),_,_,_)) = 
d158 1
a158 1
	       Print.print (IdentPrint.printStrId astrid);
d161 2
a162 2
	 let val STR (_,env) = Mapping.lookup (astrid,amap) 
	   handle Mapping.Lookup => raise Lookup_StrId
d167 2
a168 2
    fun lookup_longstrid (Ident.LONGSTRID (apath,astrid),env) =
      lookup_strid (astrid,Ident.followPath find_env (apath,env)) 
d171 1
a171 8
    fun lookup_strid_in_SE (strid,SE amap) = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("strid lookup in SE \n");
	       Print.print (IdentPrint.printStrId strid);
	       Print.print ("\n"))
       else ();
      Mapping.lookup (strid,amap) 
      handle Mapping.Lookup => raise Lookup_StrId_in_SE)
d173 1
a173 2
    fun SE_in_env se = ENV (se,Tyenv.empty_tyenv,Varenv.empty_valenv,
			    Exconenv.empty_valenv)
d175 1
a175 2
    fun TE_in_env te = ENV (Strenv.empty_se,te,Varenv.empty_valenv,
			    Exconenv.empty_valenv)
d177 1
a177 2
    fun VE_in_env ve = ENV (Strenv.empty_se,Tyenv.empty_tyenv,ve,
			    Exconenv.empty_valenv)
d179 1
a179 2
    fun EE_in_env ee = ENV (Strenv.empty_se,Tyenv.empty_tyenv,
			    Varenv.empty_valenv,ee)
d181 1
a181 1
    fun VE_TE_in_env (ve,te) = ENV (Strenv.empty_se,te,ve,Exconenv.empty_valenv)
a182 2
    fun VE_EE_in_env (ve,ee) = ENV (Strenv.empty_se,Tyenv.empty_tyenv,ve,ee)

d186 1
a186 1
      (if empty_strenvp se 
d204 1
a204 1
        val strid_str_list = Mapping.assoc amap
d260 1
a260 1
	val strid_str_list = Mapping.assoc amap
d265 2
a266 2
              val str' = Mapping.lookup (strid,amap')
                handle Mapping.Lookup => 
a298 1
	val var_scheme_list = Mapping.assoc amap
d305 1
a305 1
	look_at_schemes var_scheme_list
d307 1
a307 1
	se_no_imptyvars (Mapping.assoc amap')
d312 1
a312 1
	no_imptyvars (env)
d339 1
a339 1
	val strid_str_list = Mapping.assoc amap
d350 1
a350 1
			 add_to_se (strid,str',se'),strnamecopy_fun,
d354 1
a354 1
	copy_strs (strid_str_list,strname_copies,tyname_copies,Strenv.empty_se,
a357 89
(*
    val tyfun_map =
      NewMap.from_list'
      (fn (id, id') =>
       Tyfun_id.tyfun_id id < Tyfun_id.tyfun_id id')

    val str_copy =
      fn (str, strname_copies, tyname_copies, strnamecopy_fun,
	  tynamecopy_fun) =>
      let
	val tyname_map = tyfun_map tyname_copies
	val (str, strname_copies, tyname_map) =
	  str_copy(str, strname_copies, tyname_map, strnamecopy_fun,
		   tynamecopy_fun)
      in
	(str, strname_copies, NewMap.to_list tyname_map)
      end
*)

(*
    fun str_copy_for_sigma(str, strname_copies, tyname_copies) = 
      let
	val strname_table = StrHashTable.new()
	val _ = Lists.iterate
	  (fn (id, strname) =>
	   StrHashTable.update(strname_table, id, strname))
	  (NewMap.to_list strname_copies)

	fun lookup_strname(id, name) =
	  StrHashTable.lookup(strname_table, id)
	  handle StrHashTable.Lookup _ =>
	    let
	      val new_name = Strnames.copy_metastrname name
	      val _ = StrHashTable.update(strname_table, id, new_name)
	    in
	      new_name
	    end

	fun internal_str_copy(STR(name, ENV(se,te,ve,ee)), tyname_copies) = 
	  let 
	    val name' =
	      if Strnames.uninstantiated name then
		Strnames.strname_copy_hash(name, lookup_strname)
	      else name
	    val (se',tyname_copies') = 
	      se_copy(se, tyname_copies)
	    val (te',tyname_copies'') = Tyenv.te_copy (te,tyname_copies',
						       Types.copy_metatyname)
	    val (ve',tyname_copies''') = Varenv.ve_copy (ve,tyname_copies'',
							 Types.copy_metatyname)
	    val (ee',tyname_copies'''') = Varenv.ve_copy (ee,tyname_copies''',
							  Types.copy_metatyname)
	  in
	    (STR(name',ENV (se',te',ve',ee')), tyname_copies'''')
	  end
    
	and se_copy (SE amap,tyname_copies) =
	  let
	    val strid_str_list = Mapping.assoc amap
	    fun copy_strs ([],tyname_copies,se') = 
	      (se',tyname_copies)
	      | copy_strs ((strid,str)::strid_strs,tyname_copies, se') = 
		let 
		  val (str',tyname_copies') = 
		    internal_str_copy(str,tyname_copies)
		in
		  copy_strs(strid_strs,tyname_copies',
			    add_to_se (strid,str',se'))
		end
	  in
	    copy_strs(strid_str_list,tyname_copies,Strenv.empty_se)
	  end
	val (str, tyname_copies) =
	  internal_str_copy(str, tyname_copies)
      in
	(str, NewMap.from_list' Strname_id.strname_id_lt
	 (StrHashTable.to_list strname_table), tyname_copies)
      end

    val str_copy_for_sigma =
      fn (str, strname_copies, tyname_copies) =>
      let
	val tyname_map = tyfun_map tyname_copies
	val (str, strnames, tynames) =
	  str_copy_for_sigma(str, strname_copies, tyname_map)
      in
	(str, strnames, NewMap.to_list tynames)
      end
*)
@


1.11
log
@Improved enrichment efficiency
@
text
@d4 3
a45 1
require "../utils/array";
a47 1
(*require "../utils/_newhashtable";*)
a60 1
  structure Array : ARRAY
a86 12

(*
    structure StrHashTable = NewHashTable(
      type Key = Datatypes.Strname_id.Strname_id
      type Value = Datatypes.Strname
      structure Array = Array
      structure Crash = Crash
      structure Lists = Lists
      val eq = op=
      val hash = Datatypes.Strname_id.strname_id
      val size = 512)
*)
@


1.10
log
@Changed to use btrees for renaming of tynames and strnames
@
text
@d4 3
d271 1
a271 3
      (if Lists.sublist (Mapping.domain se_map,Mapping.domain se_map')
	 then (se_ran_enriches (level,se,se'))
       else false)
d273 8
a280 15
	 (if Lists.sublist (Tyenv.te_domain te,Tyenv.te_domain te')
	    then (Tyenv.te_ran_enriches (te,te')
		  handle Tyenv.EnrichError s => raise EnrichError s)
	  else false)
	    andalso  
	    (if Lists.sublist (Varenv.ve_domain ve,Varenv.ve_domain ve')
	       then (Varenv.ve_ran_enriches (level,ve,ve') 
		     handle Varenv.EnrichError s => raise EnrichError s)
	     else
	       false)
	       andalso
	       (if Lists.sublist (Varenv.ve_domain ee,Varenv.ve_domain ee')
		  then (Varenv.ee_ran_eq (ee,ee')
			handle Varenv.EnrichError s => raise EnrichError s)
		else false))
d298 1
a298 1
	val strid_str_list = Mapping.assoc (amap')
d301 11
a311 12
	  | ran_enriches ((strid,str')::strid_strs) =  
	    if Mapping.domain_member (strid,amap)
	      then 
                let
		  val str = Mapping.lookup (strid,amap)
  	        in 
		  str_enriches (level,str,str')
		  andalso 
		  ran_enriches strid_strs
		end
	    else
	      ran_enriches strid_strs
@


1.9
log
@Anel's fixes
@
text
@d4 3
d38 1
d40 2
d43 1
d55 1
d57 2
d73 1
d79 1
d85 12
d404 5
a408 1
  end;
d410 12
d423 72
@


1.8
log
@Some improvements from Anel
@
text
@d4 3
d214 2
a215 1
      let val strid_list = Mapping.domain amap
d217 7
a223 10
	  | make_string (strid::stridlist) = 
	    let val STR (m,env) = Mapping.lookup (strid,amap)
	    in
	      "structure " ^ 
	      IdentPrint.printStrId strid ^ 
	      " (" ^ (Strnames.string_strname m) ^ ") \n" ^ 
	      "struct\n\n" ^ 
	      (string_environment env) ^ "end\n" ^
	      (make_string stridlist)
	    end
d225 1
a225 1
	make_string strid_list
d280 1
a280 1
	val domain = Mapping.domain (amap')
d282 11
a292 11
	fun ran_enriches ([],amap,amap') = true
	  | ran_enriches (h::t,amap,amap') =  
	    if Lists.member (h,Mapping.domain amap)
	      then let
		     val str = Mapping.lookup (h,amap)
		     val str' = Mapping.lookup (h,amap')
		   in 
		     str_enriches (level,str,str')
		     andalso 
		     ran_enriches (t,amap,amap')
		   end
d294 1
a294 1
	      ran_enriches (t,amap,amap')
d296 1
a296 1
	val result = ran_enriches (domain,amap,amap')
d314 1
a314 1
    fun no_imptyvars (ENV (se as SE amap',_,ve as VE (_,amap),_)) = 
d320 6
a325 10
	val varlist = Varenv.ve_domain ve
	val stridlist = Mapping.domain amap'
	fun look_at_schemes ([],_) = true
	  | look_at_schemes (var::varlist,ve) = 
	    let val scheme = Varenv.lookup (var,ve)
	    in
	      (not (Scheme.has_free_imptyvars (scheme)))
	      andalso
	      look_at_schemes (varlist,ve)
	    end
d327 1
a327 1
	look_at_schemes (varlist,ve)
d329 1
a329 1
	se_no_imptyvars (stridlist,se)
d332 5
a336 9
    and se_no_imptyvars ([],se) = true
      | se_no_imptyvars (strid::stridlist,se) =
	let 
	  val STR (_,env) = lookup_strid_in_SE (strid,se)
	in 
	  no_imptyvars (env)
	  andalso 
	  se_no_imptyvars (stridlist,se)
	end
d358 2
a359 2
    and se_copy (se as SE amap,strname_copies,tyname_copies,
		 strnamecopy_fun,tynamecopy_fun) = 
d361 5
a365 9
	val strid_list = Mapping.domain amap
	fun copy_strs ([],strname_copies,tyname_copies,se' as SE amap',_,_) = 
	  let
	    val strids = Mapping.domain amap'
	  in
	    (se',strname_copies,tyname_copies)
	  end
	  | copy_strs (strid::strids,strname_copies,tyname_copies,se',
		       strnamecopy_fun,tynamecopy_fun) = 
d367 1
a367 2
	      val str = lookup_strid_in_SE (strid,se)
	      val (copy as STR (m,_),strname_copies',tyname_copies') = 
d371 2
a372 2
	      copy_strs (strids,strname_copies',tyname_copies',
			 add_to_se (strid,copy,se'),strnamecopy_fun,
d376 1
a376 1
	copy_strs (strid_list,strname_copies,tyname_copies,Strenv.empty_se,
@


1.7
log
@New pervasive library code - cut some things out of the initial type basis
@
text
@d4 3
d32 1
a32 1
require "../utils/set";
d45 1
a45 1
  structure Set : SET
d243 1
a243 2
      (if Set.subset (Set.list_to_set (Mapping.domain se_map),
		      Set.list_to_set (Mapping.domain se_map'))
d247 1
a247 2
	 (if Set.subset (Set.list_to_set (Tyenv.te_domain te),
			 Set.list_to_set (Tyenv.te_domain te'))
d252 1
a252 2
	    (if Set.subset (Set.list_to_set (Varenv.ve_domain ve),
			    Set.list_to_set (Varenv.ve_domain ve'))
d258 1
a258 2
	       (if Set.subset (Set.list_to_set (Varenv.ve_domain ee),
			       Set.list_to_set (Varenv.ve_domain ee'))
d280 1
d283 1
a283 1
	    if Set.is_member (h,Set.list_to_set (Mapping.domain amap))
@


1.6
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d89 7
a95 1
    fun empty_strenvp (SE amap) = Mapping.emptymap_p amap
@


1.5
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_environment.sml,v $
d24 5
a29 1
require "../typechecker/datatypes";
a35 2
require "../utils/set";
require "../utils/print";
d37 19
a55 15
functor Environment(structure Datatypes : DATATYPES
		    structure Types : TYPES
		    structure Valenv : VALENV
		    structure Scheme : TYPESCHEME
		    structure Strnames : STRNAMES
		    structure Tyenv : TYENV
		    structure Strenv : STRENV
		    structure Set : SET
		    structure Debug :  sig val set_debug_level : int -> unit
					   val debug_level : unit -> int
				       end
		    structure Print : PRINT
		    sharing Datatypes = Types.Datatypes = Valenv.Datatypes
		      = Scheme.Datatypes = Strnames.Datatypes 
		      = Tyenv.Datatypes = Strenv.Datatypes) : ENVIRONMENT =
d63 1
d97 1
a97 1
      (if (Debug.debug_level () > 10) 
d129 1
a129 1
      (if (Debug.debug_level () > 10) 
d138 1
a138 1
      (if (Debug.debug_level () > 10) 
d154 1
a154 1
      (if (Debug.debug_level () > 10) 
d223 1
a223 1
      (if (Debug.debug_level () > 10) 
d255 1
a255 1
      (if (Debug.debug_level () > 10) 
d265 1
a265 1
      (if (Debug.debug_level () > 10) 
d288 1
a288 1
	  if (Debug.debug_level () > 10) 
d304 1
a304 1
      (if (Debug.debug_level () > 10) 
@


1.4
log
@Used the Strenv module to get the empty structure environment
and the initial structure environment.
@
text
@d1 1
d4 4
d19 1
@


1.3
log
@Replaced Map.domain with Varenv.ve_domain for valenvs (ve_domain makes
everything a Ident.VAR)
@
text
@d3 4
d22 1
d32 1
d40 1
a40 1
		      = Tyenv.Datatypes) : ENVIRONMENT =
d59 1
a59 3
    val empty_strenv = SE Mapping.empty_map

    val empty_env = ENV (empty_strenv,
d64 1
a64 1
    val initial_env = ENV (empty_strenv,
d149 1
a149 1
    fun TE_in_env te = ENV (empty_strenv,te,Varenv.empty_valenv,
d152 1
a152 1
    fun VE_in_env ve = ENV (empty_strenv,Tyenv.empty_tyenv,ve,
d155 1
a155 1
    fun EE_in_env ee = ENV (empty_strenv,Tyenv.empty_tyenv,
d158 1
a158 1
    fun VE_TE_in_env (ve,te) = ENV (empty_strenv,te,ve,Exconenv.empty_valenv)
d160 1
a160 1
    fun VE_EE_in_env (ve,ee) = ENV (empty_strenv,Tyenv.empty_tyenv,ve,ee)
d362 1
a362 1
	copy_strs (strid_list,strname_copies,tyname_copies,empty_strenv,
@


1.2
log
@> Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures.
@
text
@d3 4
d264 13
d278 1
a278 1
	ran_enriches (domain,amap,amap')
d289 1
a289 1
	val varlist = Mapping.domain amap
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d266 1
a266 1
    fun no_imptyvars (ENV (se as SE amap',_,ve as VE amap,_)) = 
@
