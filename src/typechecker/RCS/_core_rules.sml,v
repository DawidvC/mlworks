head	1.91;
access;
symbols
	MLW_daveb_inline_1_4_99:1.91.1
	MLWorks_21c0_1999_03_25:1.91
	MLWorks_20c1_1998_08_20:1.91
	MLWorks_20c0_1998_08_04:1.91
	MLWorks_20b2c2_1998_06_19:1.91
	MLWorks_20b2_Windows_1998_06_12:1.91
	MLWorks_20b1c1_1998_05_07:1.91
	MLWorks_20b0_1998_04_07:1.91
	MLWorks_20b0_1998_03_20:1.91
	MLWorks_20m2_1998_02_16:1.90
	MLWorks_20m1_1997_10_23:1.90
	MLWorks_11r1:1.89.5.1.1.1.1
	MLWorks_workspace_97:1.90.2
	MLWorks_dt_wizard:1.90.1
	MLWorks_11c0_1997_09_09:1.89.5.1.1.1
	MLWorks_10r3:1.89.5.1.3
	MLWorks_10r2_551:1.89.5.1.2
	MLWorks_11:1.89.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.89.5.1
	MLWorks_20m0_1997_06_20:1.90
	MLWorks_1_0_r2c2_1997_06_14:1.89.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.89.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.89.5
	MLWorks_BugFix_1997_04_24:1.89
	MLWorks_1_0_r2_Win32_1997_04_11:1.89
	MLWorks_1_0_r2_Unix_1997_04_04:1.89
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.89.3.1.1
	MLWorks_gui_1996_12_18:1.89.4
	MLWorks_1_0_Win32_1996_12_17:1.89.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.89.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.89.1.1
	MLWorks_1_0_Irix_1996_11_28:1.89.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.89.2
	MLWorks_1_0_Unix_1996_11_14:1.89.1
	MLWorks_Open_Beta2_1996_10_11:1.87.1
	MLWorks_License_dev:1.86.1
	MLWorks_1_open_beta_1996_09_13:1.84.1
	MLWorks_Open_Beta_1996_08_22:1.84
	MLWorks_Beta_1996_07_02:1.82
	MLWorks_Beta_1996_06_07:1.82
	MLWorks_Beta_1996_06_06:1.82
	MLWorks_Beta_1996_06_05:1.82
	MLWorks_Beta_1996_06_03:1.81
	MLWorks_Beta_1996_05_31:1.81
	MLWorks_Beta_1996_05_30:1.81
	ML_beta_release_12/08/94:1.64
	ML_beta_release_03/08/94:1.64
	ML_revised_beta_release_25/05/94:1.64
	ML_final_beta_release_02/03/94:1.63
	mlworks-28-01-1994:1.61
	Release:1.50
	mlworks-beta-01-09-1993:1.50
	MLWorks-1-0-4-29/01/1993:1.32
	MLWorks-1-0-3-21/12/1992:1.32
	MLWorks-1-0-2-15/12/1992:1.32
	MLWorks-1-0-1-04/12/1992:1.30
	checkpoint_17_08_92:1.20
	Ten15_release_19-11-91:1.3
	Ten15_release_21-08-91:1.3
	Ten15_release_19-08-91:1.3
	ten15_release:1.3;
locks; strict;
comment	@ * @;


1.91
date	98.02.19.16.49.55;	author mitchell;	state Exp;
branches
	1.91.1.1;
next	1.90;

1.90
date	97.05.01.13.19.43;	author jont;	state Exp;
branches
	1.90.1.1
	1.90.2.1;
next	1.89;

1.89
date	96.10.29.17.47.54;	author andreww;	state Exp;
branches
	1.89.1.1
	1.89.2.1
	1.89.3.1
	1.89.4.1
	1.89.5.1;
next	1.88;

1.88
date	96.10.12.14.05.18;	author io;	state Exp;
branches;
next	1.87;

1.87
date	96.10.04.16.27.05;	author andreww;	state Exp;
branches
	1.87.1.1;
next	1.86;

1.86
date	96.09.20.16.05.27;	author andreww;	state Exp;
branches
	1.86.1.1;
next	1.85;

1.85
date	96.09.20.10.07.34;	author andreww;	state Exp;
branches;
next	1.84;

1.84
date	96.08.06.11.28.06;	author andreww;	state Exp;
branches
	1.84.1.1;
next	1.83;

1.83
date	96.08.01.10.28.05;	author andreww;	state Exp;
branches;
next	1.82;

1.82
date	96.06.04.15.48.46;	author jont;	state Exp;
branches;
next	1.81;

1.81
date	96.04.30.15.56.41;	author jont;	state Exp;
branches;
next	1.80;

1.80
date	96.03.25.11.08.25;	author matthew;	state Exp;
branches;
next	1.79;

1.79
date	96.03.19.16.01.41;	author matthew;	state Exp;
branches;
next	1.78;

1.78
date	96.03.08.12.04.50;	author daveb;	state Exp;
branches;
next	1.77;

1.77
date	96.02.22.13.09.12;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	95.12.27.11.47.22;	author jont;	state Exp;
branches;
next	1.75;

1.75
date	95.12.18.12.23.35;	author matthew;	state Exp;
branches;
next	1.74;

1.74
date	95.09.19.15.14.19;	author matthew;	state Exp;
branches;
next	1.73;

1.73
date	95.09.08.15.42.56;	author daveb;	state Exp;
branches;
next	1.72;

1.72
date	95.08.29.14.58.01;	author jont;	state Exp;
branches;
next	1.71;

1.71
date	95.06.09.10.16.05;	author daveb;	state Exp;
branches;
next	1.70;

1.70
date	95.05.30.10.45.08;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	95.03.29.16.04.42;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	95.03.29.15.03.45;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	95.02.07.12.16.07;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	95.01.17.13.44.04;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	94.09.22.16.03.17;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	94.05.11.14.25.29;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	94.02.24.12.04.49;	author nosa;	state Exp;
branches;
next	1.62;

1.62
date	94.02.08.12.10.17;	author nickh;	state Exp;
branches;
next	1.61;

1.61
date	93.12.17.12.54.02;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	93.12.16.12.29.01;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	93.12.03.16.39.31;	author nickh;	state Exp;
branches;
next	1.58;

1.58
date	93.11.30.14.43.49;	author nickh;	state Exp;
branches;
next	1.57;

1.57
date	93.11.26.17.47.31;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	93.11.25.12.07.31;	author nickh;	state Exp;
branches;
next	1.55;

1.55
date	93.11.24.17.39.21;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	93.10.04.16.33.41;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	93.09.30.09.22.49;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	93.09.29.17.01.59;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	93.09.22.14.10.22;	author nosa;	state Exp;
branches;
next	1.50;

1.50
date	93.08.10.14.00.10;	author matthew;	state Exp;
branches
	1.50.1.1;
next	1.49;

1.49
date	93.08.10.09.53.46;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	93.07.30.15.49.43;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	93.07.09.13.17.27;	author nosa;	state Exp;
branches;
next	1.46;

1.46
date	93.06.30.15.52.23;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	93.06.04.09.26.09;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	93.05.28.13.54.04;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	93.05.25.17.46.22;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.05.25.15.14.19;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	93.04.08.08.41.42;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	93.03.31.13.54.23;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	93.03.10.14.45.46;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	93.03.09.11.51.06;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	93.03.02.15.55.18;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	93.02.23.12.22.42;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	93.02.22.15.58.59;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.02.08.19.04.30;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	93.01.28.10.19.56;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	92.12.10.18.59.48;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	92.12.08.15.41.26;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.12.04.15.43.27;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	92.12.03.13.22.17;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	92.12.02.17.03.09;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	92.12.01.18.34.43;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	92.11.26.19.34.00;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	92.11.04.18.06.21;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	92.10.12.11.30.32;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.09.08.15.11.02;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	92.09.04.09.31.11;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	92.08.26.13.12.08;	author davidt;	state Exp;
branches;
next	1.20;

1.20
date	92.08.12.11.01.10;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.08.06.15.24.18;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.08.04.13.06.10;	author davidt;	state Exp;
branches;
next	1.17;

1.17
date	92.06.29.10.57.45;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.06.15.09.45.07;	author clive;	state Exp;
branches;
next	1.15;

1.15
date	92.06.11.08.31.02;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.05.19.13.22.02;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.04.15.16.31.18;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.04.15.11.37.58;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.04.13.16.05.02;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.04.07.14.49.07;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.04.06.13.33.18;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.01.27.20.00.38;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.01.27.11.02.46;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.01.07.16.22.20;	author colin;	state Exp;
branches;
next	1.5;

1.5
date	91.11.21.16.44.59;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.11.19.18.12.42;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.06.19.17.38.00;	author colin;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.17.11.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.35.10;	author colin;	state Exp;
branches;
next	;

1.50.1.1
date	93.08.10.14.00.10;	author jont;	state Exp;
branches;
next	1.50.1.2;

1.50.1.2
date	93.09.29.15.31.08;	author daveb;	state Exp;
branches;
next	1.50.1.3;

1.50.1.3
date	93.10.04.16.17.53;	author daveb;	state Exp;
branches;
next	;

1.84.1.1
date	96.09.13.11.41.45;	author hope;	state Exp;
branches;
next	;

1.86.1.1
date	96.10.07.16.34.51;	author hope;	state Exp;
branches;
next	;

1.87.1.1
date	96.10.17.11.53.57;	author hope;	state Exp;
branches;
next	;

1.89.1.1
date	96.11.14.13.21.40;	author hope;	state Exp;
branches
	1.89.1.1.1.1;
next	;

1.89.1.1.1.1
date	96.11.28.15.32.37;	author hope;	state Exp;
branches;
next	;

1.89.2.1
date	96.11.22.18.39.17;	author hope;	state Exp;
branches;
next	;

1.89.3.1
date	96.12.17.18.18.19;	author hope;	state Exp;
branches
	1.89.3.1.1.1;
next	;

1.89.3.1.1.1
date	97.02.24.12.12.34;	author hope;	state Exp;
branches;
next	;

1.89.4.1
date	96.12.18.10.13.37;	author hope;	state Exp;
branches;
next	;

1.89.5.1
date	97.05.12.10.51.52;	author hope;	state Exp;
branches
	1.89.5.1.1.1
	1.89.5.1.2.1
	1.89.5.1.3.1;
next	;

1.89.5.1.1.1
date	97.07.28.18.33.40;	author daveb;	state Exp;
branches
	1.89.5.1.1.1.1.1;
next	;

1.89.5.1.1.1.1.1
date	97.10.07.11.59.40;	author jkbrook;	state Exp;
branches;
next	;

1.89.5.1.2.1
date	97.09.08.17.26.47;	author daveb;	state Exp;
branches;
next	;

1.89.5.1.3.1
date	97.09.09.14.23.38;	author daveb;	state Exp;
branches;
next	;

1.90.1.1
date	97.09.10.19.42.35;	author brucem;	state Exp;
branches;
next	;

1.90.2.1
date	97.09.11.21.10.05;	author daveb;	state Exp;
branches;
next	;

1.91.1.1
date	99.04.01.18.08.41;	author daveb;	state Exp;
branches;
next	;


desc
@Rules (1-52) See The Definition
@


1.91
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _core_rules.sml the functor *)
(*
$Log: _core_rules.sml,v $
 * Revision 1.90  1997/05/01  13:19:43  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.89  1996/10/29  17:47:54  andreww
 * [Bug #1708]
 * changing the syntax of datatype replication.
 *
 * Revision 1.88  1996/10/12  14:05:18  io
 * moving String from toplevel
 *
 * Revision 1.87  1996/10/04  16:27:05  andreww
 * [Bug #1592]
 * hidden type declarations shouldn't escape.
 *
 * Revision 1.86  1996/09/20  16:05:27  andreww
 * [Bug #1588]
 * Adding the "it" identifier to the list of proscribed identifiers
 * when in SML'96 mode.
 *
 * Revision 1.84  1996/08/06  11:28:06  andreww
 * [Bug #1521]
 * propagating changes made to _types.sml
 *
 * Revision 1.82  1996/06/04  15:48:46  jont
 * Add checks to ensure datatypes and exceptions don't rebind true, false, nil, :: or ref
 *
 * Revision 1.81  1996/04/30  15:56:41  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.80  1996/03/25  11:08:25  matthew
 * Extra field in VALdec
 *
 * Revision 1.79  1996/03/19  16:01:41  matthew
 * Added value_polymorphism option
 *
 * Revision 1.78  1996/03/08  12:04:50  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
 * Revision 1.77  1996/02/22  13:09:12  jont
 * Replacing Map with NewMap
 *
 * Revision 1.76  1995/12/27  11:47:22  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.75  1995/12/18  12:23:35  matthew
Changed interface to Basis.close

Revision 1.74  1995/09/19  15:14:19  matthew
Changing order of typechecking functions and arguments

Revision 1.73  1995/09/08  15:42:56  daveb
Added types for different lengths of words, ints and reals.

Revision 1.72  1995/08/29  14:58:01  jont
Reinstate error messages for unbound strid in open.
Some of these cannot be caught by the parser.

Revision 1.71  1995/06/09  10:16:05  daveb
Removed quotes around reconstructed source in error messagess.

Revision 1.70  1995/05/30  10:45:08  jont
Fix bug 940
Also fix bug provoked by fun f(x, y) = if x = x then x y else y,
which doesn't give source reference

Revision 1.69  1995/03/29  16:04:42  jont
Fix problems with result types from functors which instantaite to functions

Revision 1.67  1995/02/07  12:16:07  matthew
Removing debug stuff

Revision 1.66  1995/01/17  13:44:04  matthew
Rationalizing debugger

Revision 1.65  1994/09/22  16:03:17  matthew
Abstraction of debug information

Revision 1.64  1994/05/11  14:25:29  daveb
Datatypes.META_OVERLOADED has extra arguments, Basis.lookup_val takes an
extra location argument, and Basis.UnresolvedVar has been removed.

Revision 1.63  1994/02/24  12:04:49  nosa
Type function and TYNAME valenv recording for Modules Debugger.

Revision 1.62  1994/02/08  12:10:17  nickh
Found a way to generate some 'impossible' type errors.

Revision 1.61  1993/12/17  12:54:02  matthew
Added name of relevant function in recursive function binding error.

Revision 1.60  1993/12/16  12:29:01  matthew
Renamed Basis.level to Basis.context_level

Revision 1.59  1993/12/03  16:39:31  nickh
Remove old debugging code, fixup a couple of error messages, and
a few inexhaustive bindings.

Revision 1.58  1993/11/30  14:43:49  nickh
Marked certain error messages as "impossible".

Revision 1.57  1993/11/26  17:47:31  matthew
Return augmented environment rather than empty environment after a "cannot
generalize" error.

Revision 1.56  1993/11/25  12:07:31  nickh
Added code to encode type errors as a list of strings and types.

Revision 1.55  1993/11/24  17:39:21  matthew
Added absyn annotations

Revision 1.54  1993/10/04  16:33:41  daveb
Merged in bug fix.

Revision 1.53  1993/09/30  09:22:49  daveb
Fixed broken rcsmerge.

Revision 1.52  1993/09/29  17:01:59  daveb
Merged in bug fix.

Revision 1.51  1993/09/22  14:10:22  nosa
Runtime-instance recording in VALexps for polymorphic debugger.

Revision 1.50.1.3  1993/10/04  16:17:53  daveb
Fixed silly bug in the handling of errors in if, while, etc.

Revision 1.50.1.2  1993/09/29  15:31:08  daveb
Added code to print better error messages for if, case, andalso and orelse.

Revision 1.50.1.1  1993/08/10  14:00:10  jont
Fork for bug fixing

Revision 1.50  1993/08/10  14:00:10  matthew
Added location information to matches

Revision 1.49  1993/08/10  09:53:46  jont
Added context printing for unification errors

Revision 1.48  1993/07/30  15:49:43  matthew
Added some simple and hacky stuff for treating if and while errors specially

Revision 1.47  1993/07/09  13:17:27  nosa
structure Option.

Revision 1.46  1993/06/30  15:52:23  daveb
Removed exception environments.

Revision 1.45  1993/06/04  09:26:09  matthew
Changed equality type as function error message

Revision 1.44  1993/05/28  13:54:04  jont
Cleaned up after assembly changes

Revision 1.43  1993/05/25  17:46:22  jont
Revised way of using assemblies such that structure assemblies are constructed
from the incremental basis rather than on the fly. Fixes a number of
problems with incorrect shadowing

Revision 1.42  1993/05/25  15:14:19  jont
Changes because Assemblies now has Basistypes instead of Datatypes

Revision 1.41  1993/04/08  08:41:42  matthew
Changed treatment of Dynamic values

Revision 1.40  1993/03/31  13:54:23  daveb
Improved error message for rule 27a (val rec ...).

Revision 1.39  1993/03/10  14:45:46  matthew
Options change

Revision 1.38  1993/03/09  11:51:06  matthew
Options & Info changes

Revision 1.37  1993/03/02  15:55:18  matthew
empty_rec_type to empty_rectype

Revision 1.36  1993/02/23  12:22:42  matthew
Changed "free type variables in value declaration" message

Revision 1.35  1993/02/22  15:58:59  matthew
Changed Completion interface
Added DYNAMICexp and COERCEexp handling

Revision 1.34  1993/02/08  19:04:30  matthew
Changes for BASISTYPES signature

Revision 1.33  1993/01/28  10:19:56  matthew
Streamlined some functions
Changed for COPYSTR's

Revision 1.32  1992/12/10  18:59:48  matthew
Neatened up error messages so types align.

Revision 1.31  1992/12/08  15:41:26  jont
Removed a number of duplicated signatures and structures

Revision 1.30  1992/12/04  15:43:27  matthew
Error message revision

Revision 1.29  1992/12/03  13:22:17  jont
Modified tyenv for efficiency

Revision 1.28  1992/12/02  17:03:09  jont
Error message improvements

Revision 1.27  1992/12/01  18:34:43  matthew
Changed handling of overloaded variable errors.

Revision 1.26  1992/11/26  19:34:00  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.25  1992/11/04  18:06:21  matthew
Changed Error structure to Info

Revision 1.24  1992/10/12  11:30:32  clive
Tynames now have a slot recording their definition point

Revision 1.23  1992/09/08  15:11:02  matthew
Changed some Errors to Crashes.

Revision 1.22  1992/09/04  09:31:11  richard
Installed central error reporting mechanism.

Revision 1.21  1992/08/26  13:12:08  davidt
Made some changes to the NewMap signature.

Revision 1.20  1992/08/12  11:01:10  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.19  1992/08/06  15:24:18  jont
Anel's changes to use NewMap instead of Map

Revision 1.17  1992/06/29  10:57:45  clive
Appexp are annotated with their types

Revision 1.16  1992/06/15  09:45:07  clive
Added debug info to handlers so need to ignore this extra slot

Revision 1.15  1992/06/11  08:31:02  clive
Added some marks for error messages

Revision 1.14  1992/05/19  13:22:02  clive
Adjusted to give better error position reporting now marks have been added

Revision 1.13  1992/04/15  16:31:18  jont
Made a number of efficiency improvements

Revision 1.12  1992/04/15  11:37:58  jont
Made some efficiency improvements

Revision 1.11  1992/04/13  16:05:02  clive
First version of the profiler

Revision 1.10  1992/04/07  14:49:07  jont
Removed on the fly calculation of valenv for METATYNAMEs. This is
now done properly during signature elaboration in _mod_rules,
and encoded in the .mo files

Revision 1.9  1992/04/06  13:33:18  jont
Fixed bug in rule 15 whereby wrong context was supplied to
subsequent matches. Fixed spurious error messages in rule 10 by
supplying a return value of alpha for the failure case

Revision 1.8  1992/01/27  20:00:38  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.7  1992/01/27  11:02:46  jont
Updated to calculate the valenv for METATYNAMES in VALpat and APPpat

Revision 1.6  1992/01/07  16:22:20  colin
Removed last argument to calls to make_tyname

Revision 1.5  1991/11/21  16:44:59  jont
Added copyright message

Revision 1.4  91/11/19  18:12:42  jont
Fixed inexhaustive matches

Revision 1.3  91/06/19  17:38:00  colin
Updated to set extra type ref field in HANDLEexp to type of handler body

Revision 1.2  91/06/17  17:11:00  nickh
Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures.

Revision 1.1  91/06/07  11:35:10  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "^.basis.__string";
require "../utils/print";
require "../utils/lists";
require "../utils/crash";
require "../basics/identprint";
require "../typechecker/types";
require "../typechecker/scheme";
require "../typechecker/valenv";
require "../typechecker/tyenv";
require "../typechecker/strenv";
require "../typechecker/environment";
require "../typechecker/type_exp";
require "../typechecker/patterns";
require "../typechecker/control_unify";
require "../typechecker/completion";
require "../typechecker/basis";
require "../typechecker/context_print";

require "../typechecker/core_rules";

functor Core_rules(
  structure Print : PRINT
  structure Lists : LISTS
  structure Crash : CRASH
  structure IdentPrint : IDENTPRINT
  structure Types         : TYPES
  structure Scheme        : SCHEME
  structure Valenv        : VALENV
  structure Tyenv         : TYENV
  structure Strenv        : STRENV
  structure Env           : ENVIRONMENT
  structure Type_exp      : TYPE_EXP
  structure Patterns      : PATTERNS
  structure Basis         : BASIS
  structure Control_Unify : CONTROL_UNIFY
  structure Completion : COMPLETION
  structure Context_Print : CONTEXT_PRINT

  sharing Type_exp.BasisTypes = Patterns.BasisTypes = Control_Unify.BasisTypes =
          Basis.BasisTypes
  sharing Completion.Options = IdentPrint.Options = Patterns.Options =
    Scheme.Options = Control_Unify.Options = Context_Print.Options
  sharing Type_exp.Info = Patterns.Info = Control_Unify.Info
  sharing Basis.BasisTypes.Datatypes =
          Env.Datatypes =
	  Tyenv.Datatypes =
	  Types.Datatypes =
	  Completion.Datatypes =
	  Valenv.Datatypes =
	  Scheme.Datatypes =
          Type_exp.Absyn.Datatypes =
	  Strenv.Datatypes
  sharing IdentPrint.Ident.Location = Type_exp.Info.Location
  sharing Type_exp.Absyn = Patterns.Absyn = Context_Print.Absyn
  sharing Basis.BasisTypes.Set = Scheme.Set
  sharing IdentPrint.Ident = Types.Datatypes.Ident
  sharing type Patterns.Info.options = Basis.error_info
  sharing type Basis.print_options = IdentPrint.Options.print_options
  sharing type Basis.options = Scheme.Options.options = Types.Options.options
  sharing type Type_exp.Absyn.InstanceInfo = Basis.BasisTypes.Datatypes.InstanceInfo
  sharing type Type_exp.Absyn.Instance = Basis.BasisTypes.Datatypes.Instance
  sharing type Type_exp.Absyn.Tyfun = Basis.BasisTypes.Datatypes.Tyfun
    
) : CORE_RULES =
  struct
    structure Datatypes = Types.Datatypes
    structure Basistypes = Basis.BasisTypes
    structure Absyn = Patterns.Absyn
    structure Info = Patterns.Info
    structure Options = IdentPrint.Options
    structure Location = Absyn.Ident.Location
    structure Symbol = Absyn.Ident.Symbol
    structure Set = Basistypes.Set

    open Datatypes

    fun eq_scheme (_, s) = Scheme.equalityp s

    fun fresh_tyvar(acontext, eq, imp) =
      METATYVAR (ref (Basis.context_level acontext,NULLTYPE,NO_INSTANCE), eq, imp)

    (*****
    Printing out of debugging information.
    *****)

    fun get_option (_, SOME x) = x
      | get_option (error, _) = Crash.impossible error

    val bad_valids = ["true", "false", "it", "::", "nil", "ref"]

    val bad_valids_table = NewMap.from_list' Symbol.symbol_lt
      (map (fn s => (Symbol.find_symbol s, true)) bad_valids)



    fun check_dec
      (param as (error_info,options as Options.OPTIONS
                 {print_options,
                  compiler_options = Options.COMPILEROPTIONS{generate_moduler,
                                                             ...},
                  compat_options = Options.COMPATOPTIONS {old_definition,...},
                  ...})) args =
      let 
        val use_value_polymorphism = not old_definition
        val report_error  = Info.error error_info


        (* the following function is used to construct error messages
         concerning hidden type names that escape (forbidden in
         SML'96).  See rules 15 and 16, and rule 27 *)
                                 

        fun checkEscapingNames (location, escapingNames, message) =
          let
            fun printNames [] = ""
              | printNames [m,n] = (Types.print_name options m)^" and "^
                (Types.print_name options n)
              | printNames (h::t) = (Types.print_name options h) ^", "^
                (printNames t)
          in
            case (Lists.rev_remove_dups escapingNames)
              of [] => ()
               | [name] => report_error (Info.RECOVERABLE, location,
                                         "The hidden type name "^
                                         (Types.print_name options name)^
                                         " escapes "^message)
               | names => report_error (Info.RECOVERABLE, location,
                                    "The hidden type names "^
                                    (printNames names)^
                                    " escape "^message)
                   
          end
        

	fun check_valid(valid, location) =
	  if old_definition then
	    ()
	  else
	    let
	      val sym = case valid of
		Ident.VAR sy => sy
	      | Ident.CON sy => sy
	      | Ident.EXCON sy => sy
	      | Ident.TYCON' sy => sy
	    in
	      case NewMap.tryApply'(bad_valids_table, sym) of
		NONE => ()
	      | _ => report_error(Info.RECOVERABLE, 
				  location,
				  "Attempt to rebind fixed value constructor: " ^
				  IdentPrint.printValId print_options valid)
	    end

        fun report_strid_error (location,print_options,strid,lvalid) =
          report_error
          (Info.RECOVERABLE, 
           location,
           IdentPrint.valid_unbound_strid_message (strid,lvalid,print_options))

        val unify = Control_Unify.unify param

        val check_pat = Patterns.check_pat param
        val check_type = Type_exp.check_type error_info

        local
          val types : (Datatypes.Type ref * Absyn.RuntimeInfo ref) list ref = ref []
          val tyfuns : Datatypes.Tyfun ref list ref = ref []
          val ves : (Datatypes.Valenv ref * Datatypes.Valenv ref) list ref = ref []
          val tys1 : ((int * Datatypes.Type * Datatypes.Instance) ref
                      * (int * Datatypes.Type * Datatypes.Instance) ref) list ref = ref []
          val tys2 : (Datatypes.Type ref * Datatypes.Type ref) list ref = ref []
          val tys3 : ((int * bool * Type * bool * bool) ref
                      * (int * bool * Type * bool * bool) ref) list ref = ref []
          val tfs : (Datatypes.Tyfun ref * Datatypes.Tyfun ref) list ref = ref []

        in
          fun copy_type(Datatypes.CONSTYPE(tys,tyn)) =
                Datatypes.CONSTYPE(Lists.reducel
                                   (fn (tys,ty)=>copy_type(ty)::tys) (nil, tys),
                                   copy_tyname tyn)
              | copy_type (Datatypes.FUNTYPE(ty1,ty2)) = Datatypes.FUNTYPE(copy_type ty1,copy_type ty2)
              | copy_type (Datatypes.RECTYPE map) =
                    Datatypes.RECTYPE(NewMap.map (fn (_, ty) => copy_type ty) map)
              | copy_type (tyv as Datatypes.METATYVAR(ty1 as ref(n,ty,i),b1,b2)) =
                (Datatypes.METATYVAR(Lists.assoc(ty1,!tys1),b1,b2)
                 handle Lists.Assoc => 
                   (tys1 := (ty1,ty1)::(!tys1);
                    ty1 := (n,copy_type ty,i);
                    tyv))
              | copy_type (ovty as Datatypes.META_OVERLOADED(ty1 as ref(ty),tv,valid,loc)) =
                (Datatypes.META_OVERLOADED(Lists.assoc(ty1,!tys2),tv,valid,loc)
                 handle Lists.Assoc =>
                     (tys2 := (ty1,ty1)::(!tys2);
                      ty1 := copy_type ty;
                      ovty))
              | copy_type (tyv as Datatypes.TYVAR(ty1 as ref(n,ty,i),id)) =
                (Datatypes.TYVAR(Lists.assoc(ty1,!tys1),id)
                 handle Lists.Assoc =>
                   (tys1 := (ty1,ty1)::(!tys1);
                    ty1 := (n,copy_type ty,i);
                    tyv))
              | copy_type (recty as Datatypes.METARECTYPE(ty1 as ref(n,b1,ty,b2,b3))) =
                (Datatypes.METARECTYPE(Lists.assoc(ty1,!tys3))
                 handle Lists.Assoc =>
                   (tys3 := (ty1,ty1)::(!tys3);
                    ty1 := (n,b1,copy_type ty,b2,b3);
                    recty))
              | copy_type ty = ty
            and copy_typescheme (Datatypes.SCHEME(n,(ty,i))) = Datatypes.SCHEME(n,(copy_type ty,i))
              | copy_typescheme (Datatypes.UNBOUND_SCHEME(ty,i)) = Datatypes.UNBOUND_SCHEME(copy_type ty,i)
              | copy_typescheme sch = sch
            and copy_tyname
                  (m as Datatypes.METATYNAME(tf as ref(Datatypes.NULL_TYFUN(_)),name,n,b,
                                             ve' as ref(Datatypes.VE(n',ve)),abs)) =
                     (Datatypes.METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs)
                      handle Lists.Assoc =>
                        let
                          val map =
                           (ves := (ve',ve')::(!ves);
                            NewMap.fold (fn (map,valid,sch) => NewMap.define(map,valid,copy_typescheme sch))
                            (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
                        in
                          (ve' := Datatypes.VE(n',map);
                           Datatypes.METATYNAME(tf,name,n,b,ve',abs))
                        end)
              | copy_tyname (Datatypes.METATYNAME(tf as ref(Datatypes.ETA_TYFUN(tyn)),name,n,b,
                                                          ve' as ref(Datatypes.VE(n',ve)),abs)) =
                     let
                       val (tf1,tf_encountered) =
                         (Lists.assoc(tf,!tfs),true)
                         handle Lists.Assoc =>
                           (tf,false)
                       val (ve'',ve_encountered) =
                         (Lists.assoc(ve',!ves),true)
                         handle Lists.Assoc =>
                           (ve',false)
                       val _ =
                         if tf_encountered then ()
                         else
                           tfs := (tf,tf1)::(!tfs)
                       val _ =
                         if ve_encountered then ()
                         else
                           ves := (ve',ve'')::(!ves)
                       val _ =
                         if tf_encountered then ()
                         else
                           tf1 := Datatypes.ETA_TYFUN(copy_tyname tyn)
                       val _ =
                         if ve_encountered then ()
                         else
                            ve'' := Datatypes.VE(n',
                                                 NewMap.fold (fn (map,valid,sch) =>NewMap.define(map,valid,copy_typescheme sch))
                               (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
                     in
                       Datatypes.METATYNAME(tf1,name,n,b,ve'',abs)
                     end
              | copy_tyname (Datatypes.METATYNAME(tf as ref(Datatypes.TYFUN(ty,n)),name,n',b,
                                                          ve' as ref(Datatypes.VE(n'',ve)),abs)) =
                     let
                       val (tf1,tf_encountered) =
                         (Lists.assoc(tf,!tfs),true)
                         handle Lists.Assoc =>
                           (tf,false)
                       val (ve'',ve_encountered) =
                         (Lists.assoc(ve',!ves),true)
                         handle Lists.Assoc =>
                           (ve',false)
                       val _ =
                         if tf_encountered then ()
                         else
                           tfs := (tf,tf1)::(!tfs)
                       val _ =
                         if ve_encountered then ()
                         else
                           ves := (ve',ve'')::(!ves)
                       val _ =
                         if tf_encountered then ()
                         else
                           tf1 := Datatypes.TYFUN(copy_type ty,n)
                       val _ =
                         if ve_encountered then ()
                         else
                            ve'' := Datatypes.VE(n'',
                                                 NewMap.fold (fn (map,valid,sch) =>NewMap.define(map,valid,copy_typescheme sch))
                               (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
                     in
                       Datatypes.METATYNAME(tf1,name,n',b,ve'',abs)
                     end
              | copy_tyname (Datatypes.TYNAME(id,s,n,b,ve1 as ref(Datatypes.VE(n1,ve2)),s',abs,ve3,lev)) =
                          let
                            val (ve',ve,n') = (ve1,ve2,n1)
                          in
                     (Datatypes.TYNAME(id,s,n,b,ve',s',abs,
                                       Lists.assoc(ve',!ves),lev)
                      handle Lists.Assoc =>
                        let
                          val ve'' = ref(Datatypes.VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
                          val map =
                            (ves := (ve',ve'')::(!ves);
                             NewMap.fold (fn (map,valid,sch) =>
                                            NewMap.define(map,valid,copy_typescheme sch))
                             (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
                        in
                          (ve'' := Datatypes.VE(n',map);
                           Datatypes.TYNAME(id,s,n,b,ve',s',abs,ve'',lev))
                       end)
                          end
          local
            val dummy_false = ref(false)
            val dummy_ve = ref(Datatypes.empty_valenv)
            val dummy_tf = ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))
          in
            fun copy_tyfun tyf =
              (dummy_tf := tyf;
               case copy_tyname(Datatypes.METATYNAME(dummy_tf,"",0,
                                                     dummy_false,dummy_ve,
                                                     dummy_false)) of
                 Datatypes.METATYNAME(ref(tf),_,_,_,_,_) => tf
               | _ =>
                   Crash.impossible "copy_tyfun:generate_moduler:core_rules")
          end
          val copy_tynames =
            if generate_moduler then
              fn _ =>
              (Lists.iterate
               (fn (tyref,_) => tyref := copy_type (!tyref))
                (!types);
               Lists.iterate
               (fn tf => tf := copy_tyfun (!tf)) 
               (!tyfuns))
            else
                fn _ => ()
          val tyfun_types =
            fn tyfun => tyfuns := tyfun::(!tyfuns)
          val pat_types =
            if generate_moduler then
              fn pat_type => types := pat_type @@ (!types)
            else
              fn _ => ()
        end

	fun get_data (Absyn.FNexp(_,_,data,_)) = data
	|   get_data _ = ""

	val is_if_exp = String.isPrefix "<if>"
	val is_case_exp = String.isPrefix "<case>"
	val is_andalso_exp = String.isPrefix "<andalso>"
	val is_orelse_exp = String.isPrefix "<orelse>"
	val is_while_exp = String.isPrefix "While statement"


	(* context information for type errors : *)

	fun near exp =
	  concat ["Near: ", 
                          Context_Print.exp_to_string print_options exp]

	fun err_string_exp exp =
	  Datatypes.Err_String (Context_Print.exp_to_string print_options exp)

	fun err_string_pat pat =
	  Datatypes.Err_String (Context_Print.pat_to_string print_options pat)

	fun err_string_dec dec =
	  Datatypes.Err_String (Context_Print.dec_to_string print_options dec)

        (***** rule 1 *****)
        
	(* The third argument is used to pass the argument expression of
	   a function to the code that checks that function, for use in
	   error messages. *)

        fun check_exp (Absyn.SCONexp (scon, type_ref), _, _) =
	  let
	    val ty = Types.type_of scon
	  in
            type_ref := ty;
	    ty
	  end
      
          (***** rule 2,3,4 *****)      
        
  | check_exp (Absyn.VALexp (lvalid,type_ref,location,instance), acontext, _) =
             let
               val (atype,instance') =
		 Basis.lookup_val
		   (lvalid, acontext, location, generate_moduler)
                 handle Basis.LookupValId valid =>
                   (report_error
                    (Info.RECOVERABLE, 
                     location,
                     IdentPrint.unbound_longvalid_message (valid,lvalid,"value",print_options));
                    (fresh_tyvar (acontext, false, false),(ZERO,NONE)))
                      | Basis.LookupStrId strid =>
                          (report_strid_error (location,print_options,strid,lvalid);
                           (fresh_tyvar (acontext, false, false),(ZERO,NONE)))
             in
               (type_ref := atype;
                instance := instance';
                atype)
             end
	
      (***** rule 5 *****)

      | check_exp (Absyn.RECORDexp arecordlist, acontext, _) =
	 let
	   fun check_rec ([], rectype) = rectype
	     | check_rec ((alab, anexp)::t, rectype) =
	       let
		 val exptype = check_exp (anexp, acontext, NONE)
	       in
		 check_rec (t, Types.add_to_rectype (alab, exptype, rectype))
	       end
	 in
	   check_rec (arecordlist, Types.empty_rectype)
	 end
  
      (***** rule 6 *****)
  
      | check_exp(Absyn.LOCALexp (dec, exp, location), acontext, _) =
        let
          val env = check_dec (dec,acontext)
          val new_context = Basis.context_plus_env (acontext,env)
          val atype = check_exp (exp, new_context,
                                 NONE)

            (* the following line checks that no hidden type names
               escape the let binding.  This is disallowed in SML '96 *)

          val _ = if old_definition then ()
                  else checkEscapingNames 
                    (location,Basis.tynamesNotIn (atype,acontext),
                     "the local scope.")
         in
           atype
        end

        
          
	
      (* ****** Expressions ****** *)
	
      (***** rule 10 *****)

      | check_exp (arg_exp as Absyn.APPexp (exp1, exp2,location,argument_type,_), acontext, _) =
	 let 
	   val tyexp1 = check_exp (exp1, acontext, SOME exp2)
	   val tyexp2 = check_exp (exp2, acontext, NONE)

           val _ = argument_type := tyexp2

	   fun check_fun (FUNTYPE (arg,res),atype) = 
	     unify
	     {
	      first = arg, second = atype, result = res,
	      context = acontext,
              error = fn () =>
              (location,
	       let val near_string = Datatypes.Err_String (near arg_exp)
	       in
		 if is_if_exp (get_data exp1) then
		   [Datatypes.Err_String "Argument to 'if' must be of type bool\n",
		    near_string,
                    Datatypes.Err_String "\n  Argument type: ",
                    Datatypes.Err_Type atype]
		 else if is_case_exp (get_data exp1) then
		   [Datatypes.Err_String
		    "Pattern in 'case' has different type from choice expression\n",
		    near_string,
		    Datatypes.Err_String "\n  Required argument type: ",
		    Datatypes.Err_Type atype,
		    Datatypes.Err_String "\n  Actual argument type:   ",
		    Datatypes.Err_Type arg]
		 else if is_andalso_exp (get_data exp1) then
		   [Datatypes.Err_String "First argument of 'andalso' is not boolean\n",
		    near_string,
		    Datatypes.Err_String "\n  Actual argument type: ",
		    Datatypes.Err_Type atype]
		 else if is_orelse_exp (get_data exp1) then
		   [Datatypes.Err_String "First argument of 'orelse' is not boolean\n",
		    near_string,
		    Datatypes.Err_String "\n  Actual argument type: ",
		    Datatypes.Err_Type atype]
		 else
		   [Datatypes.Err_String "Function applied to argument of wrong type\n",
		    near_string,
		    Datatypes.Err_String "\n  Required argument type: ",
		    Datatypes.Err_Type arg,
		    Datatypes.Err_String "\n  Actual argument type:   ",
		    Datatypes.Err_Type atype]
	       end,
	       fresh_tyvar (acontext, false, false))
	      }
	     | check_fun (t as (METATYVAR
				(ref (_,NULLTYPE,_),eq,imp)),atype) =
	       if eq then
                 (report_error
                  (Info.RECOVERABLE, location,
		   concat ["Attempt to apply value of equality type as a function\n",
			    near arg_exp,
			    "\n  Applied type: ",
			    Completion.print_type
                                   (options,
                                    Basis.env_of_context acontext,t)]);
                  fresh_tyvar (acontext, false, false))
	       else
		 let
		   val newmeta = fresh_tyvar(acontext, false, imp)
		 in
		   unify
		   {
		    first = t, second = FUNTYPE (atype, newmeta),
		    result = newmeta, context = acontext,
                    error = fn () =>
                      (location, 
                       [Datatypes.Err_String "Circularity in function application\n",
			Datatypes.Err_String (near arg_exp),
			Datatypes.Err_String "\n  Required argument type: ",
			Datatypes.Err_Type t,
			Datatypes.Err_String "\n  Actual argument type:   ",
			Datatypes.Err_Type (FUNTYPE(atype, newmeta))],
                       fresh_tyvar (acontext, false, false))
                   }
		 end
	     | check_fun (METATYVAR (ref (_,t,_),eq,imp), atype) =
	       check_fun (t, atype)
	     | check_fun(t as CONSTYPE (tylist,METATYNAME{1=ref(NULL_TYFUN _), ...}), _) =
               (report_error
                (Info.RECOVERABLE, location,
		 concat ["Attempt to apply non-function type\n",
			  near arg_exp,
			  "\n  Applied type:",
			  Completion.print_type
                                 (options,
                                  Basis.env_of_context acontext,t)]);
		fresh_tyvar (acontext, false, false))
	     | check_fun(CONSTYPE (tylist,METATYNAME{1=ref tyfun, ...}), atype) =
	       check_fun(Types.apply(tyfun, tylist), atype)
	     | check_fun (t, _) =
               (report_error
                (Info.RECOVERABLE, location,
		 concat ["Attempt to apply non-function type\n",
			  near arg_exp,
			  "\n  Applied type:",
			  Completion.print_type
                                 (options,
                                  Basis.env_of_context acontext,t)]);
		fresh_tyvar (acontext, false, false))
	 in
           check_fun (tyexp1, tyexp2)
	end
      
      (***** rule 11 *****)

      | check_exp (arg_exp as Absyn.TYPEDexp (exp, ty,location), acontext, _) =
	 let 
	   val exp_ty  = check_exp (exp, acontext, NONE)
	   val ty_exp_ty = check_type (ty, acontext)
	 in
	   unify
	   {
	    first = exp_ty, second = ty_exp_ty, result = ty_exp_ty,
	    context = acontext,
            error = fn () =>
              (location,
	       [Datatypes.Err_String "Types of expression and constraint do not agree\n",
		Datatypes.Err_String (near arg_exp),
		Datatypes.Err_String "\n  Expression type: ",
		Datatypes.Err_Type   exp_ty,
		Datatypes.Err_String "\n  Constraint type: ",
		Datatypes.Err_Type   ty_exp_ty],
               ty_exp_ty)
           }
	 end
      
      
      (***** rule 12 *****)
    
    
      | check_exp (arg_exp as Absyn.HANDLEexp (exp,type_ref,match,location,_), acontext, _) =
	 let 
	   val exp_ty = check_exp (exp, acontext, NONE)
	     
	   val _ = type_ref := exp_ty

	   fun check_fun (FUNTYPE (arg, res)) = (arg, res)
	     | check_fun (METATYVAR (ref (_, t,_), eq, imp)) = check_fun t
	     | check_fun (_) =
               (report_error
                (* don't think this can happen *)
                (Info.RECOVERABLE, location, "impossible type error 2: Illegal match in ");
                (fresh_tyvar (acontext, false, false), fresh_tyvar (acontext, false, false)))
	       
	   val (arg, res) =
	     check_fun (check_match (match, acontext, "", NONE, location))
	     
	   val ? = unify
	     {
	      first = arg, second = Types.exn_type, result = Types.exn_type,
	      context = acontext,
              error = fn () =>
                (location,
		 [Datatypes.Err_String "Match in handler should have argument type exn\n",
		  Datatypes.Err_String (near arg_exp),
		  Datatypes.Err_String "\n  Match type: ",
		  Datatypes.Err_Type arg],
                 Types.exn_type)
             }
	 in
	   unify
	   {
	    first = res, second = exp_ty, result = res, context = acontext,
            error = fn () =>
              (location,
	       [Datatypes.Err_String "Handler disagrees with expression\n",
		Datatypes.Err_String (near arg_exp),
		Datatypes.Err_String "\n  Handler type:    ",
		Datatypes.Err_Type res,
		Datatypes.Err_String "\n  Expression type: ",
		Datatypes.Err_Type exp_ty],
               res)
	    }
	 end
       
      (***** rule 13 *****)          
    
      | check_exp (arg_exp as Absyn.RAISEexp (exp,location), acontext, _) =
	 let
	   val exp_ty = check_exp (exp, acontext, NONE)
	 in
	   unify
	   {
	    first = exp_ty, second = Types.exn_type,
	    result = fresh_tyvar(acontext, false, false),
	    context = acontext,
            error = fn () =>
              (location,
               [Datatypes.Err_String "Expression raised is not an exception\n",
		Datatypes.Err_String (near arg_exp),
		Datatypes.Err_String "\n  Expression type: ",
		Datatypes.Err_Type (exp_ty)],
               fresh_tyvar (acontext, false, false))
	    }
	 end
	
      (***** rule 14 *****)
	  
      | check_exp (Absyn.FNexp (amatch,type_ref,data,location), acontext, argexp) =
	 let 
	   val atype = check_match (amatch, acontext, data, argexp, location)
	   val _ = type_ref := atype
	 in
	   atype
	 end

      | check_exp (Absyn.DYNAMICexp (exp,explicit_tyvars,info_ref), acontext, _) =
        let
          val level = Basis.context_level acontext
	 val tyvars_scoped_here = 
           Set.setdiff (explicit_tyvars, Basis.get_tyvarset acontext)
          val atype = check_exp(exp,acontext,NONE)
        in
          (* the closure is done in the lambda translator *)
          info_ref := (atype,level,tyvars_scoped_here);
          Types.dynamic_type
        end
	
      | check_exp (arg_exp as Absyn.COERCEexp (exp,atype,tyref, location),
		   acontext, _) =
        let
          val exp_ty = check_exp(exp,acontext,NONE)
          val coerce_ty = check_type(atype,acontext)
        in
          ignore(
            unify {first = exp_ty,
                   second = Types.dynamic_type,
                   result = Types.dynamic_type,
                   context = acontext,
                   error = fn () =>
                   (location,
                    [Datatypes.Err_String "Expression coerced is not dynamic\n",
  		     Datatypes.Err_String (near arg_exp),
		     Datatypes.Err_String "\n  Expression type: ",
		     Datatypes.Err_Type exp_ty],
                    fresh_tyvar (acontext, false, false))
                   });
          tyref := coerce_ty;
          coerce_ty
        end

      (* MLVALUEexp's are just used internally, so this won't happen yet *)
      | check_exp (Absyn.MLVALUEexp mlvalue, acontext,_) =
        Types.ml_value_type

    (***** rules 15 and 16 *****)
	
    (* data - string from enclosing function (or empty string)
     * argexp - argument of enclosing function (option)
     * lastpat - pattern of previous branch (option)
     *)
    and check_match (matches, acontext, data, argexp, location) =
       check_rules
         (matches, acontext, fresh_tyvar(acontext, false, false),
	  NONE, data, argexp, location)
      
    and check_rules ([], _, atype, _, _, _, _) = atype
      | check_rules ((apat, anexp, matchloc) :: rules,
		     acontext, atype, lastpat, data, argexp, location) =
        let 
          val (new_ve, pat_ty, pat_type) = check_pat (apat, acontext)
          val new_context = Basis.context_plus_ve (acontext, new_ve)
          val exp_ty = check_exp (anexp, new_context, NONE)

            (* the following line checks the extra side condition on the
               matching rule in the revised definition.  It ensures that
               no hidden type names escape. *)


          val _ = if old_definition then () 
                  else checkEscapingNames(location,
                                Basis.valEnvTynamesNotIn (new_ve,acontext),
                                          "in the match.")


          val ftype = FUNTYPE (pat_ty, exp_ty)
	     
          val res =
            unify
            {first = atype, second = ftype, result = atype,
             context = acontext,
             error = fn () =>
             (matchloc,
              if is_if_exp data then
		let val (_, then_ty) = Types.argres atype
		    val argexp' = get_option ("argexp", argexp)
		in
		  [Datatypes.Err_String "Branches of 'if' have incompatible types:\n",
		   Datatypes.Err_String "Near: if ",
		   err_string_exp argexp',
		   Datatypes.Err_String " then ... else ...\n  'then' case: ",
		   Datatypes.Err_Type then_ty,
		   Datatypes.Err_String "\n  'else' case: ",
		   Datatypes.Err_Type exp_ty]
		end
              else if is_case_exp data then
		let val argexp' = get_option("argexp", argexp)
		    val lastpat' = get_option("lastpat", lastpat)
		in
                  [Datatypes.Err_String "Branches of 'case' have incompatible types:\n",
		   Datatypes.Err_String "Near: case ",
		   err_string_exp argexp',
		   Datatypes.Err_String " of ... ",
		   err_string_pat lastpat',
		   Datatypes.Err_String " => ... | ",
		   err_string_pat apat,
		   Datatypes.Err_String " => ...\n  Expected type: ",
		   Datatypes.Err_Type atype,
		   Datatypes.Err_String "\n  Rule type:     ",
		   Datatypes.Err_Type ftype]
		end
	      else if is_andalso_exp data then
		[Datatypes.Err_String "Second argument of 'andalso' is not boolean:\n",
		 Datatypes.Err_String "Near: ... andalso ",
		 err_string_exp anexp,
		 Datatypes.Err_String "\n  Actual argument type: ",
		 Datatypes.Err_Type exp_ty]
	      else if is_orelse_exp data then
		[Datatypes.Err_String "Second argument of 'orelse' is not boolean:\n",
		 Datatypes.Err_String "Near: ... orelse ",
		 err_string_exp anexp,
		 Datatypes.Err_String "\n  Actual argument type: ",
		 Datatypes.Err_Type exp_ty]
	      else
		[Datatypes.Err_String "Type disagreement between match rules\n",
		 Datatypes.Err_String "Near: ",
		 err_string_pat apat,
		 Datatypes.Err_String " => ...\n  Expected type: ",
                 Datatypes.Err_Type atype,
		 Datatypes.Err_String "\n  Rule type:     ",
		 Datatypes.Err_Type ftype],
              atype)}
	 in
           (pat_types pat_type;
            check_rules
            (rules, acontext, res, SOME apat, data, argexp, location))
	 end
       
    (* ****** Declarations ****** *)
  
    (***** rule 17 *****)
    and check_dec (Absyn.VALdec (avalbindlist1,
				 avalbindlist2,
				 inner_unguarded_tyvars,
                                 explicit_tyvars),
		   acontext) =
       let 
         (* Need to do something with the explicit tyvars here *)
	 val tyvars_scoped_here = 
           Set.union (Set.setdiff (inner_unguarded_tyvars,
                                   Basis.get_tyvarset acontext),
                      Set.list_to_set (explicit_tyvars))
	   
	 val new_context = 
           Basis.context_plus_tyvarset (acontext, tyvars_scoped_here)

	 val (expansive_vars, new_VE) =
	   check_valbind (avalbindlist1,
                          avalbindlist2,
                          new_context,
			  empty_valenv,
                          [])

         val location =
           (case (avalbindlist1,avalbindlist2) of
              ((_,_,location)::_,_) => location
            | (_,(_,_,location)::_) => location
            | _ => Crash.impossible "Empty valbind list")

	 val VE' = 	
           Basis.close (error_info,options,location)
                       (Basis.context_level acontext,
                        new_VE,expansive_vars,
                        tyvars_scoped_here,true)
	 val foo = 
           Set.intersection
           (tyvars_scoped_here,
            Set.list_to_set (Valenv.tyvars VE'))
       in
	 if Set.empty_setp (foo)
	   then ()
	 else
           (report_error
            (Info.RECOVERABLE, location,
	     concat ["Explicit type ",
                      (if (Lists.length (Set.set_to_list foo)) = 1
                         then "variable "
                       else "variables "),
                       Set.set_print (foo, IdentPrint.printTyVar),
                       " cannot be generalized in value declaration"]));
          ENV (Strenv.empty_strenv,
                Tyenv.empty_tyenv,
                VE')
       end

      (***** rule 18 *****)

      | check_dec (Absyn.TYPEdec atypbind,acontext) =
	ENV (Strenv.empty_strenv,
             check_typbind (atypbind,acontext),
             empty_valenv)
	   
      (***** rule 18 of SML'96 definition ****)

      | check_dec (Absyn.DATATYPErepl (location,(tycon,longtycon),
                                       associatedValEnv),
                   context)=
        (let
          val tyStr as Datatypes.TYSTR(tyFun,valEnv) 
            = Basis.lookup_longtycon(longtycon,context)
          (* Basis exceptions handled at end of rule *)
            
          val _ = associatedValEnv := SOME valEnv  
          
          (* record the list of constructors associated with this 
             datastructure for future reference (i.e., lambda
             code generation) *)

          val new_te = Tyenv.add_to_te(Tyenv.empty_tyenv,tycon,tyStr)
        in
          ENV(Strenv.empty_strenv,new_te,valEnv)
        end
      handle Basis.LookupTyCon tycon =>
        (report_error 
         (Info.RECOVERABLE, location,
          "The type constructor "^(IdentPrint.printTyCon tycon)
          ^" on the right hand side of the datatype replication\
           \ does not exist.");Env.empty_env)
        
           | Basis.LookupStrId strId =>
               (report_error
                (Info.RECOVERABLE, location,
                 "Structure "^ (IdentPrint.printStrId strId)
                 ^" does not exist.");Env.empty_env))
           
           
      (***** rule 19 *****)

      | check_dec (Absyn.DATATYPEdec (location,datbindlist),
		   context as Basistypes.CONTEXT (level,tyvarset,
                                                  ENV(se,te,ve),_)) =
	 let
           val dummy_tycons = map (fn (tyvars,tycon,_,_,_) => 
                                               (tyvars,tycon)) datbindlist
	   val new_context = Basis.context_for_datbind 
                           (context,Location.to_string location,dummy_tycons)

	   val (new_ve,new_te) = check_datbind (datbindlist,
                                                location,
						new_context,
						(empty_valenv,
                                                 Tyenv.empty_tyenv))

	   fun max_eq_pred (_, TYSTR (atyfun,VE (_,amap))) =
  	     if Types.equalityp atyfun then
	       NewMap.forall eq_scheme amap orelse 
	       Types.make_false atyfun
	     else
	       true

	   fun max_eq (TE amap) =
	     while not (NewMap.forall max_eq_pred amap) do ()
	 in
	   (max_eq (new_te);
	    ENV (Strenv.empty_strenv,new_te,new_ve))
	 end
      
      (***** rule 20 *****)

      | check_dec (Absyn.ABSTYPEdec (location,adatbindlist, dec), acontext) =
	 let
	   val new_env as (ENV (_,te,_)) =
	     check_dec (Absyn.DATATYPEdec (location,adatbindlist), acontext)
	 in
	   Env.abs (te, check_dec (dec, Basis.context_plus_env (acontext, 
                                                                new_env)))
	 end
      
      (***** rule 21 *****)

      | check_dec (Absyn.EXCEPTIONdec anexbindlist, acontext) =
	 let
	   val newve = check_exconbind (anexbindlist, acontext)
	 in
	   ENV (Strenv.empty_strenv, Tyenv.empty_tyenv, newve)
	 end
	
      (***** rule 22 *****)

      | check_dec (Absyn.LOCALdec (dec1,dec2),acontext) =
	 let
	   val env = check_dec (dec1, acontext)
	 in
           check_dec (dec2, Basis.context_plus_env (acontext, env))
	 end

      (***** rule 23 *****)

      | check_dec (Absyn.OPENdec (strids,location), acontext) =
	 let
	   val Basistypes.CONTEXT(_, _, E, _) = acontext
	     
	   fun collect_envs(env,lstrid) =
	     let
	       val new_env =
		 case Env.resolve_top_level (Env.lookup_longstrid (lstrid, E))
		   of (STR (_,_,x)) => x
		 | _ => Crash.impossible "lookup strid for open"
	     in
	       Env.env_plus_env(env, new_env)
	     end
             (* This should be handled in the parser *)
             (* except when the error is a semantic one *)
             (* eg a structure which fails to match its constraining signature *)
	     handle Env.LookupStrId strid =>
	       (report_error
		(Info.RECOVERABLE, location,
		 IdentPrint.strid_unbound_strid_message (strid,lstrid,print_options));
                env)
	 in
	   Lists.reducel collect_envs(Env.empty_env,strids)
	 end

      (***** rule 24 and 25 *****)

      | check_dec ((Absyn.SEQUENCEdec declist), context) =
	 let 
           fun check_one ((env,context),dec) =
             let
               val new_env = check_dec (dec,context)
               val new_context = Basis.context_plus_env(context,new_env)
             in
               (Env.env_plus_env (env,new_env),
                new_context)
             end
           val (new_env,_) = Lists.reducel check_one 
                                           ((Env.empty_env,context),declist)
         in
           new_env
	 end

      (***** rule 26 *****)

      (* check_valbind returns ve and list of vars "in" expansive exp. *)

  
    and check_valbind([],recvalbinds,acontext,ve,exp_vars) =
       check_recvalbind (recvalbinds,acontext,ve,exp_vars,[])

      | check_valbind ((apat,anexp,location)::valbinds,
		       recvalbinds,acontext,ve,exp_vars) =
	 let 
	   val (newve, aty, pat_type) = check_pat (apat, acontext)
	   val atype = check_exp (anexp, acontext, NONE)
	 in
	   ignore(unify
	   {
	    first = aty, second = atype, result = aty,
	    context = acontext,
            error = fn () =>
              (location,
	       [Datatypes.Err_String "Pattern and expression types do not agree\n",
		Datatypes.Err_String "Near: ",
		err_string_dec (apat, anexp),
		Datatypes.Err_String "\n  Pattern type:    ",
		Datatypes.Err_Type aty,
		Datatypes.Err_String "\n  Expression type: ",
		Datatypes.Err_Type atype],
               aty)
	    });

           pat_types pat_type;
	   
	   check_valbind (valbinds, recvalbinds, acontext,
			  Valenv.ve_plus_ve (ve, newve),
			  if Absyn.expansivep anexp then 
			    exp_vars @@ Valenv.ve_domain newve
			  else exp_vars)
	 end
	    
      (***** rule 27 *****)
	    
    and check_recvalbind ((apat,anexp,location)::recvalbind,acontext,ve,
			   expansive_vars,ty_exp) =
       let
	 val (newve, aty, pat_type) = check_pat (apat, acontext)

         (* the following line checks the extra side condition on the
            rec binding rule in the revised definition.  It ensures that
            hidden type names don't escape through recursive binding.
            see appendix G.7 for more detail. *)

         val _ = if old_definition then ()
                 else checkEscapingNames(location,
                                 Basis.valEnvTynamesNotIn (newve,acontext),
                                         "In the recursive binding.")

       in
	 check_recvalbind (recvalbind,acontext,
			   Valenv.ve_plus_ve (ve, newve),
			   if Absyn.expansivep anexp
			     then 
			       expansive_vars @@ (Valenv.ve_domain newve)
			   else expansive_vars,
			     ((aty,pat_type,anexp,location,apat)::ty_exp))
       end
    
      | check_recvalbind ([], acontext, ve, expansive_vars, ty_exp) = 
	 let 
	   val new_context = Basis.context_plus_ve (acontext,ve)
	     
	   fun f (atype, pat_type, anexp,location,apat) = 
	     let
               fun extract_fnname (Absyn.VALpat ((lvalid,_),_)) =
                            IdentPrint.printLongValId print_options lvalid
                 | extract_fnname (Absyn.TYPEDpat (pat,_,_)) = 
                            extract_fnname pat
                 | extract_fnname (Absyn.LAYEREDpat ((valid,_),_)) =
                            IdentPrint.printValId print_options valid
                 | extract_fnname _ = "_"
	       val atype' = check_exp (anexp, new_context, NONE)
	       val ? = 
		 unify
		 {
		  first = atype, second = atype', result = atype,
		  context = acontext,
                  error = fn () =>
                    (location,
		     [Datatypes.Err_String 
                         "Type mismatch in recursive value binding for ",
                      Datatypes.Err_String (extract_fnname apat),
                      Datatypes.Err_String "\n",
		      Datatypes.Err_String (near anexp),
		      Datatypes.Err_String "\n  Pattern type:    ",
		      Datatypes.Err_Type atype,
		      Datatypes.Err_String "\n  Expression type: ",
		      Datatypes.Err_Type atype'],
                     atype)
		  }
	     in
	       pat_types pat_type
	     end
	   
	   val _ = Lists.iterate f ty_exp
	 in
	   (expansive_vars, ve)
	 end

      (***** rule 28 *****)

    and check_typbind ([],acontext) = Tyenv.empty_tyenv

      | check_typbind ((tyvarseq,tycon,ty,tyfun)::typbinds,acontext) =
	 let
	   val tyenv = Basis.te_of_context acontext 
	 in
	   Tyenv.add_to_te(check_typbind (typbinds,acontext),
			   tycon,TYSTR
			   (let
                             val tyfun' = Types.make_tyfun(tyvarseq,check_type (ty,acontext))
                           in
                              (case tyfun of
                                 SOME (tyfun) =>
                                   (tyfun := tyfun';
                                    tyfun_types tyfun)
                               | _ => ();
                               tyfun')
                           end,
                         empty_valenv))
	 end
      (***** rule 29 *****)

    and check_datbind ([],_,_,(ve,te)) = (ve,te)
	   
      | check_datbind ((tyvarlist,tycon,type_ref,tyfun_ref,conbind)::datbinds,
                       location,
                       acontext,
		       (ve,te)) =
	 let
	   val new_context = Basis.context_plus_tyvarlist (acontext,tyvarlist)
	     
	   val TYSTR (tyfun, _) = Basis.lookup_tycon (tycon, new_context)
	     handle Basis.LookupTyCon tycon =>
               Crash.impossible "Garbled context in check_datbind 1"
                  | Basis.LookupStrId _ =>
                      Crash.impossible "Garbled context in check_datbind 2"

           val _ =
             case tyfun_ref of
               SOME (tyfun_ref) =>
                 (tyfun_ref := tyfun;
                  tyfun_types tyfun_ref)
             | _ => () 
	       
	   val tyvartypes =
	     (map
	      (fn x => check_type (Absyn.TYVARty x,new_context))
	      tyvarlist) 

	   val (new_ve,new_te,new_type) = check_conbind (conbind,
							 location,
							 tycon,
							 tyfun,
							 Types.apply
							 (tyfun,tyvartypes),
							 tyvartypes,
							 new_context,
							 empty_valenv,
							 (ve,te))
	   val _ = type_ref := new_type
	 in
	   check_datbind (datbinds,location,acontext,(new_ve,new_te))
	 end
       
      (***** rule 30 *****)

    and check_conbind ([],		   
		       location,
		       tycon,
		       tyfun,
		       tycon_type,
		       tyvartypes,
		       acontext,
		       conenv,
		       (ve,te)) = 
       let
	 val (tyvarlist, tyname, valenv_ref) = case tycon_type of
	   CONSTYPE (tyvarlist,tyname as TYNAME {5 = valenv_ref,...}) =>
	     (tyvarlist, tyname, valenv_ref)
	 | _ => Crash.impossible"bad tycon_type"

	 val metatyvarlist = 
	   let
	     fun subst [] = []
	       | subst (TYVAR (ref (level,_,_),_)::tyvars) =
		 METATYVAR (ref (level,NULLTYPE,NO_INSTANCE),
                            false,false)::(subst tyvars)
	       | subst _ = Crash.impossible"subst bad parameters"
	   in
	     subst tyvarlist
	   end
	 
	 val newtype = CONSTYPE (metatyvarlist,tyname)
	   
       in
	 valenv_ref := conenv;
	 (Valenv.ve_plus_ve (conenv,ve),
	  Tyenv.add_to_te (te, tycon, TYSTR (tyfun, conenv)),newtype)
       end

      | check_conbind (((valid,type_ref),NONE)::conbinds,
		       location,
		       tycon,
		       tyfun,
		       tycon_type,
		       tyvartypes,
		       acontext,
		       conenv,
		       (ve,te)) =
	 let
	   val _ = check_valid(valid, location)
	   val tyscheme = Scheme.make_scheme (tyvartypes,(tycon_type,
                                                          NONE))
	   val new_conenv = Valenv.add_to_ve (valid,tyscheme,conenv)
	 in
	   type_ref := tycon_type;
	   check_conbind
	   (conbinds, location, tycon, tyfun, tycon_type, tyvartypes,
	    acontext, new_conenv, (ve,te))
	 end
  
      | check_conbind (((valid,type_ref),SOME aty)::conbinds,
		       location,
		       tycon,
		       tyfun,
		       tycon_type,
		       tyvartypes,
		       acontext,
		       conenv,
		       (ve,te)) =
	 let 
	   val _ = check_valid(valid, location)
	   val atype = check_type (aty,acontext) 
	   val tyscheme = Scheme.make_scheme (tyvartypes,
					      (FUNTYPE (atype,tycon_type),
                                               NONE))
	   val new_conenv = Valenv.add_to_ve (valid,tyscheme,conenv)
	 in
	   type_ref := FUNTYPE (atype,tycon_type);
	   check_conbind
	   (conbinds, location, tycon, tyfun, tycon_type, tyvartypes,
	    acontext, new_conenv, (ve,te))
	 end

    (* ****** Exception Bindings ****** *)
    (***** rule 31 *****)

    and check_exconbind ([],_) = empty_valenv
      | check_exconbind ((Absyn.NEWexbind ((anexcon,type_ref),
					   SOME aty,location,_))::restbinds,
			 acontext) =
	 let
	   val _ = check_valid(anexcon, location)
	   val atype = check_type (aty, acontext)
	     
	   val ftype =
	     if use_value_polymorphism orelse (Types.imperativep atype) then 
	       FUNTYPE (atype, Types.exn_type)
	     else
	       let
		 val imp = fresh_tyvar (acontext, Types.type_equalityp atype,
                                        false)
	       in
                 report_error
                 (Info.RECOVERABLE, location,
                  concat ["Exception binding contains applicative type variable",
                           "\n  Type domain of exception constructor ",
			   IdentPrint.printValId print_options anexcon,
			   ": ",
                           Completion.print_type
                              (options,
                                Basis.env_of_context acontext,atype)]);
                 FUNTYPE(imp, Types.exn_type)
	       end
	 in
	   type_ref := ftype;
	   Valenv.add_to_ve
	   (anexcon, Scheme.make_scheme ([], (ftype,NONE)),
	    check_exconbind(restbinds, acontext))
	 end
       
      (***** rule 31 *****)

      | check_exconbind ((Absyn.NEWexbind ((anexcon,type_ref),
					   NONE,location,_))::restbinds,
			 acontext) = 
	(check_valid(anexcon, location);
	 type_ref := Types.exn_type;
	  Valenv.add_to_ve
	  (anexcon, Scheme.make_scheme ([],(Types.exn_type,NONE)),
	   check_exconbind(restbinds,acontext)))
	 
      (***** rule 32 *****)	  

      | check_exconbind (Absyn.OLDexbind  
                         ((anewexcon,type_ref), lvalid,location,_)
			 ::restbinds,acontext) =
	 let 
	   val _ = check_valid(anewexcon, location)
	   val atype =
	     #1(Basis.lookup_val (lvalid, acontext, location, generate_moduler))
             (* Need to handle LookupStrid *)
	     handle Basis.LookupValId valid =>
               (report_error
                (Info.RECOVERABLE, 
                 location,
                 IdentPrint.unbound_longvalid_message (valid,lvalid,"exception",print_options));
                Types.exn_type)
               | Basis.LookupStrId strid =>
               (report_strid_error (location,print_options,strid,lvalid);
                Types.exn_type)
	 in
	   type_ref := atype;
	   
	   Valenv.add_to_ve
	   (anewexcon, Scheme.make_scheme ([], (atype,NONE)),
	    check_exconbind(restbinds, acontext))
	 end
        val result = check_dec args
      in
        (copy_tynames();
         result)
      end

    val check_type = Type_exp.check_type
  end;
@


1.91.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.91  1998/02/19  16:49:55  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.90
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d975 13
a987 12
          unify {first = exp_ty,
                 second = Types.dynamic_type,
                 result = Types.dynamic_type,
                 context = acontext,
                 error = fn () =>
                 (location,
                  [Datatypes.Err_String "Expression coerced is not dynamic\n",
		   Datatypes.Err_String (near arg_exp),
		   Datatypes.Err_String "\n  Expression type: ",
		   Datatypes.Err_Type exp_ty],
                  fresh_tyvar (acontext, false, false))
                 };
d1306 1
a1306 1
	   unify
d1320 1
a1320 1
	    };
@


1.90.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.90  1997/05/01  13:19:43  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.90.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.90  1997/05/01  13:19:43  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.89
log
@[Bug #1708]
changing the syntax of datatype replication.
@
text
@d4 4
d443 1
a443 1
		MLWorks.Option.NONE => ()
d690 1
a690 1
                    (fresh_tyvar (acontext, false, false),(ZERO,MLWorks.Option.NONE)))
d693 1
a693 1
                           (fresh_tyvar (acontext, false, false),(ZERO,MLWorks.Option.NONE)))
d958 1
a958 1
          val atype = check_exp(exp,acontext,MLWorks.Option.NONE)
d968 1
a968 1
          val exp_ty = check_exp(exp,acontext,MLWorks.Option.NONE)
d1496 1
a1496 1
      | check_conbind (((valid,type_ref),MLWorks.Option.NONE)::conbinds,
d1517 1
a1517 1
      | check_conbind (((valid,type_ref),MLWorks.Option.SOME aty)::conbinds,
d1573 1
a1573 1
	   (anexcon, Scheme.make_scheme ([], (ftype,MLWorks.Option.NONE)),
d1585 1
a1585 1
	  (anexcon, Scheme.make_scheme ([],(Types.exn_type,MLWorks.Option.NONE)),
d1611 1
a1611 1
	   (anewexcon, Scheme.make_scheme ([], (atype,MLWorks.Option.NONE)),
@


1.89.5.1
log
@branched from 1.89
@
text
@a3 4
 * Revision 1.89  1996/10/29  17:47:54  andreww
 * [Bug #1708]
 * changing the syntax of datatype replication.
 *
@


1.89.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.89.5.1  1997/05/12  10:51:52  hope
 * branched from 1.89
 *
@


1.89.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.89.5.1  1997/05/12  10:51:52  hope
 * branched from 1.89
 *
@


1.89.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.89.5.1  1997/05/12  10:51:52  hope
 * branched from 1.89
 *
@


1.89.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.89.5.1.1.1  1997/07/28  18:33:40  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.89.4.1
log
@branched from 1.89
@
text
@a3 4
 * Revision 1.89  1996/10/29  17:47:54  andreww
 * [Bug #1708]
 * changing the syntax of datatype replication.
 *
@


1.89.3.1
log
@branched from 1.89
@
text
@a3 4
 * Revision 1.89  1996/10/29  17:47:54  andreww
 * [Bug #1708]
 * changing the syntax of datatype replication.
 *
@


1.89.3.1.1.1
log
@branched from 1.89.3.1
@
text
@a3 3
 * Revision 1.89.3.1  1996/12/17  18:18:19  hope
 * branched from 1.89
 *
@


1.89.2.1
log
@branched from 1.89
@
text
@a3 4
 * Revision 1.89  1996/10/29  17:47:54  andreww
 * [Bug #1708]
 * changing the syntax of datatype replication.
 *
@


1.89.1.1
log
@branched from 1.89
@
text
@a3 4
 * Revision 1.89  1996/10/29  17:47:54  andreww
 * [Bug #1708]
 * changing the syntax of datatype replication.
 *
@


1.89.1.1.1.1
log
@branched from 1.89.1.1
@
text
@a3 3
 * Revision 1.89.1.1  1996/11/14  13:21:40  hope
 * branched from 1.89
 *
@


1.88
log
@moving String from toplevel
@
text
@d4 3
d1146 1
a1146 1
      | check_dec (Absyn.DATATYPErepl (location,(tyvars,tycon,longtycon),
a1153 19
          fun check_arity (Datatypes.TYFUN(typ,n)) arity = n=arity
            | check_arity (Datatypes.ETA_TYFUN(tyName)) arity = 
              (case tyName
                 of Datatypes.TYNAME(_,_,n,_,_,_,_,_,_) => n=arity
                  | Datatypes.METATYNAME(_,_,n,_,_,_) => n=arity)
            | check_arity (Datatypes.NULL_TYFUN(_,ref tyFun)) arity =
              check_arity tyFun arity
              
              
              
          val _ = if check_arity tyFun (length tyvars) then ()
                  else report_error 
                    (Info.RECOVERABLE, location,
                     "Datatype "^ (IdentPrint.printLongTyCon longtycon)^
                     " does not have arity "^
                     (foldl (fn (item,acc) => acc^" "^
                                              (IdentPrint.printTyVar item))
                     "" tyvars)^".")
                    
@


1.87
log
@[Bug #1592]
hidden type declarations shouldn't escape.
@
text
@d4 4
d290 1
d375 1
a375 1
    fun get_option (_, MLWorks.Option.SOME x) = x
d464 1
d635 6
a640 15
	local
          fun test_data string =
            let val string_size = size string
            in
              fn data =>
                size data >= string_size andalso
                string = String.substring (data,0,string_size)
            end
	in
          val is_if_exp = test_data "<if>"
          val is_case_exp = test_data "<case>"
          val is_andalso_exp = test_data "<andalso>"
          val is_orelse_exp = test_data "<orelse>"
          val is_while_exp = test_data "While statement"
	end
d645 1
a645 1
	  String.implode ["Near: ", 
d700 1
a700 1
		 val exptype = check_exp (anexp, acontext, MLWorks.Option.NONE)
d715 1
a715 1
                                 MLWorks.Option.NONE)
d737 2
a738 2
	   val tyexp1 = check_exp (exp1, acontext, MLWorks.Option.SOME exp2)
	   val tyexp2 = check_exp (exp2, acontext, MLWorks.Option.NONE)
d789 1
a789 1
		   String.implode ["Attempt to apply value of equality type as a function\n",
d820 1
a820 1
		 String.implode ["Attempt to apply non-function type\n",
d832 1
a832 1
		 String.implode ["Attempt to apply non-function type\n",
d847 1
a847 1
	   val exp_ty  = check_exp (exp, acontext, MLWorks.Option.NONE)
d872 1
a872 1
	   val exp_ty = check_exp (exp, acontext, MLWorks.Option.NONE)
d885 1
a885 1
	     check_fun (check_match (match, acontext, "", MLWorks.Option.NONE, location))
d919 1
a919 1
	   val exp_ty = check_exp (exp, acontext, MLWorks.Option.NONE)
d993 1
a993 1
	  MLWorks.Option.NONE, data, argexp, location)
d1001 1
a1001 1
          val exp_ty = check_exp (anexp, new_context, MLWorks.Option.NONE)
d1074 1
a1074 1
            (rules, acontext, res, MLWorks.Option.SOME apat, data, argexp, location))
d1123 1
a1123 1
	     String.implode ["Explicit type ",
d1311 1
a1311 1
	   val atype = check_exp (anexp, acontext, MLWorks.Option.NONE)
d1378 1
a1378 1
	       val atype' = check_exp (anexp, new_context, MLWorks.Option.NONE)
d1420 1
a1420 1
                                 MLWorks.Option.SOME(tyfun) =>
d1447 1
a1447 1
               MLWorks.Option.SOME(tyfun_ref) =>
d1520 1
a1520 1
                                                          MLWorks.Option.NONE))
d1543 1
a1543 1
                                               MLWorks.Option.NONE))
d1557 1
a1557 1
					   MLWorks.Option.SOME aty,location,_))::restbinds,
d1573 1
a1573 1
                  String.implode ["Exception binding contains applicative type variable",
d1592 1
a1592 1
					   MLWorks.Option.NONE,location,_))::restbinds,
@


1.87.1.1
log
@branched from 1.87
@
text
@a3 4
 * Revision 1.87  1996/10/04  16:27:05  andreww
 * [Bug #1592]
 * hidden type declarations shouldn't escape.
 *
@


1.86
log
@[Bug #1588]
Adding the "it" identifier to the list of proscribed identifiers
when in SML'96 mode.
@
text
@d4 5
d343 1
a343 1
  sharing type Basis.options = Scheme.Options.options
d373 1
a373 5
    val bad_valids_sml90 = ["true", "false", "::", "nil", "ref"]
    val bad_valids_sml96 = ["true", "false", "it", "::", "nil", "ref"]

    val bad_valids_table_sml90 = NewMap.from_list' Symbol.symbol_lt
      (map (fn s => (Symbol.find_symbol s, true)) bad_valids_sml90)
d375 2
a376 2
    val bad_valids_table_sml96 = NewMap.from_list' Symbol.symbol_lt
      (map (fn s => (Symbol.find_symbol s, true)) bad_valids_sml96)
d381 6
a386 5
      (param as (error_info,options as
                 Options.OPTIONS{print_options,
                                 compiler_options = Options.COMPILEROPTIONS{generate_moduler, ...},
                                 compat_options = Options.COMPATOPTIONS {old_definition,...},
                                 ...})) args =
d390 28
a417 2
        val bad_valids_table = if old_definition then bad_valids_table_sml90
                               else bad_valids_table_sml96
d573 1
a573 1
              | copy_tyname (Datatypes.TYNAME(id,s,n,b,ve1 as ref(Datatypes.VE(n1,ve2)),s',abs,ve3)) =
d577 2
a578 1
                     (Datatypes.TYNAME(id,s,n,b,ve',s',abs,Lists.assoc(ve',!ves))
d589 1
a589 1
                           Datatypes.TYNAME(id,s,n,b,ve',s',abs,ve''))
d599 3
a601 1
               case copy_tyname(Datatypes.METATYNAME(dummy_tf,"",0,dummy_false,dummy_ve,dummy_false)) of
d603 2
a604 1
               | _ => Crash.impossible "copy_tyfun:generate_moduler:core_rules")
d648 2
a649 1
	  String.implode ["Near: ", Context_Print.exp_to_string print_options exp]
d675 2
a676 1
          | check_exp (Absyn.VALexp (lvalid,type_ref,location,instance), acontext, _) =
d713 20
a732 4
      | check_exp(Absyn.LOCALexp (dec, exp), acontext, _) =
	check_exp (exp,Basis.context_plus_env
		   (acontext,check_dec (dec,acontext)),
		   MLWorks.Option.NONE)
d1005 12
d1091 2
a1092 1
           Set.union (Set.setdiff (inner_unguarded_tyvars, Basis.get_tyvarset acontext),
d1133 2
a1134 2
               Tyenv.empty_tyenv,
               VE')
d1141 2
a1142 2
	     check_typbind (atypbind,acontext),
	     empty_valenv)
d1146 2
a1147 1
      | check_dec (Absyn.DATATYPErepl (location,(tyvars,tycon,longtycon),associatedValEnv),
d1157 1
a1157 1
                 of Datatypes.TYNAME(_,_,n,_,_,_,_,_) => n=arity
d1203 5
a1207 2
           val dummy_tycons = map (fn (tyvars,tycon,_,_,_) => (tyvars,tycon)) datbindlist
	   val new_context = Basis.context_for_datbind (context,Location.to_string location,dummy_tycons)
d1211 2
a1212 1
						(empty_valenv,Tyenv.empty_tyenv))
d1235 2
a1236 2
	   Env.abs (te, check_dec (dec, Basis.context_plus_env
				   (acontext, new_env)))
d1254 1
a1254 1
	   check_dec (dec2, Basis.context_plus_env (acontext, env))
d1293 2
a1294 1
               (Env.env_plus_env (env,new_env),new_context)
d1296 2
a1297 1
           val (new_env,_) = Lists.reducel check_one ((Env.empty_env,context),declist)
d1347 11
d1374 6
a1379 3
               fun extract_fnname (Absyn.VALpat ((lvalid,_),_)) = IdentPrint.printLongValId print_options lvalid
                 | extract_fnname (Absyn.TYPEDpat (pat,_,_)) = extract_fnname pat
                 | extract_fnname (Absyn.LAYEREDpat ((valid,_),_)) = IdentPrint.printValId print_options valid
d1389 2
a1390 1
		     [Datatypes.Err_String "Type mismatch in recursive value binding for ",
d1491 1
@


1.86.1.1
log
@branched from 1.86
@
text
@a3 5
 * Revision 1.86  1996/09/20  16:05:27  andreww
 * [Bug #1588]
 * Adding the "it" identifier to the list of proscribed identifiers
 * when in SML'96 mode.
 *
@


1.85
log
@[Bug #1577]
Adding typechecking rules for datatype replication.
@
text
@d368 10
a377 4
    val bad_valids = ["true", "false", "::", "nil", "ref"]
    val bad_valids_table = NewMap.from_list'
      Symbol.symbol_lt
      (map (fn s => (Symbol.find_symbol s, true)) bad_valids)
d388 3
@


1.84
log
@[Bug #1521]
propagating changes made to _types.sml
@
text
@d4 4
d330 1
d1072 52
@


1.84.1.1
log
@branched from 1.84
@
text
@a3 4
 * Revision 1.84  1996/08/06  11:28:06  andreww
 * [Bug #1521]
 * propagating changes made to _types.sml
 *
@


1.83
log
@[Bug #1524]
Inserting a test for old_definition in the rules for exception checking
to avoid confusions over imperative and applicative type vars, which
are not meaningful in SML '96.
@
text
@d333 1
d369 1
a369 1
      (param as (error_info,
d731 3
a733 1
			    Completion.print_type(print_options,Basis.env_of_context acontext,t)]);
d762 3
a764 1
			  Completion.print_type(print_options,Basis.env_of_context acontext,t)]);
d774 3
a776 1
			  Completion.print_type(print_options,Basis.env_of_context acontext,t)]);
d1035 1
a1035 1
           Basis.close (use_value_polymorphism,error_info,print_options,location)
d1428 3
a1430 1
                           Completion.print_type(print_options,Basis.env_of_context acontext,atype)]);
@


1.82
log
@Add checks to ensure datatypes and exceptions don't rebind true, false, nil, :: or ref
@
text
@d4 3
d1408 1
a1408 1
	     if (Types.imperativep atype) then 
@


1.81
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d342 1
d359 5
a363 1
  
d373 19
d1300 1
d1317 1
d1350 1
d1358 2
a1359 1
	 let 
d1366 1
a1366 1
	   (conbinds, tycon, tyfun, tycon_type, tyvartypes,
d1371 1
d1380 1
d1389 1
a1389 1
	   (conbinds, tycon, tyfun, tycon_type, tyvartypes,
d1401 1
d1433 2
a1434 1
	 (type_ref := Types.exn_type;
d1445 1
@


1.80
log
@Extra field in VALdec
@
text
@d4 3
d568 1
a568 1
	  implode ["Near: ", Context_Print.exp_to_string print_options exp]
d694 1
a694 1
		   implode ["Attempt to apply value of equality type as a function\n",
d723 1
a723 1
		 implode ["Attempt to apply non-function type\n",
d733 1
a733 1
		 implode ["Attempt to apply non-function type\n",
d1009 1
a1009 1
	     implode ["Explicit type ",
d1377 1
a1377 1
                  implode ["Exception binding contains applicative type variable",
@


1.79
log
@Added value_polymorphism option
@
text
@d4 3
d966 2
a967 1
				 inner_unguarded_tyvars),
d970 1
d972 2
a973 1
           Set.setdiff (inner_unguarded_tyvars, Basis.get_tyvarset acontext)
@


1.78
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@d4 3
d351 1
d354 1
d986 1
a986 1
           Basis.close (error_info,print_options,location)
@


1.77
log
@Replacing Map with NewMap
@
text
@d4 3
d858 1
a858 1
                  [Datatypes.Err_String "Expression coerced is not Dynamic\n",
@


1.76
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d375 2
a376 6
              | copy_type (Datatypes.RECTYPE(map)) =
                    Datatypes.RECTYPE(
                    Datatypes.Mapping.Fold
                    (fn lab=> fn ty=> fn map =>
                     Datatypes.Mapping.add((lab,copy_type ty),map,Ident.lab_order))
                                      Datatypes.Mapping.empty_map map)
@


1.75
log
@Changed interface to Basis.close
@
text
@d4 3
a306 1
  sharing Types.Datatypes.Option = Type_exp.Absyn.Option
a321 1
    structure Option = Datatypes.Option
d334 1
a334 1
    fun get_option (_, Option.PRESENT x) = x
d591 1
a591 1
                    (fresh_tyvar (acontext, false, false),(ZERO,Option.ABSENT)))
d594 1
a594 1
                           (fresh_tyvar (acontext, false, false),(ZERO,Option.ABSENT)))
d608 1
a608 1
		 val exptype = check_exp (anexp, acontext, Option.ABSENT)
d621 1
a621 1
		   Option.ABSENT)
d629 2
a630 2
	   val tyexp1 = check_exp (exp1, acontext, Option.PRESENT exp2)
	   val tyexp2 = check_exp (exp2, acontext, Option.ABSENT)
d733 1
a733 1
	   val exp_ty  = check_exp (exp, acontext, Option.ABSENT)
d758 1
a758 1
	   val exp_ty = check_exp (exp, acontext, Option.ABSENT)
d771 1
a771 1
	     check_fun (check_match (match, acontext, "", Option.ABSENT, location))
d805 1
a805 1
	   val exp_ty = check_exp (exp, acontext, Option.ABSENT)
d837 1
a837 1
          val atype = check_exp(exp,acontext,Option.ABSENT)
d847 1
a847 1
          val exp_ty = check_exp(exp,acontext,Option.ABSENT)
d879 1
a879 1
	  Option.ABSENT, data, argexp, location)
d887 1
a887 1
          val exp_ty = check_exp (anexp, new_context, Option.ABSENT)
d948 1
a948 1
            (rules, acontext, res, Option.PRESENT apat, data, argexp, location))
d1122 1
a1122 1
	   val atype = check_exp (anexp, acontext, Option.ABSENT)
d1175 1
a1175 1
	       val atype' = check_exp (anexp, new_context, Option.ABSENT)
d1216 1
a1216 1
                                 Option.PRESENT(tyfun) =>
d1243 1
a1243 1
               Option.PRESENT(tyfun_ref) =>
d1301 1
a1301 1
      | check_conbind (((valid,type_ref),Absyn.Option.ABSENT)::conbinds,
d1311 1
a1311 1
                                                          Option.ABSENT))
d1320 1
a1320 1
      | check_conbind (((valid,type_ref),Absyn.Option.PRESENT aty)::conbinds,
d1332 1
a1332 1
                                               Option.ABSENT))
d1346 1
a1346 1
					   Absyn.Option.PRESENT aty,location,_))::restbinds,
d1371 1
a1371 1
	   (anexcon, Scheme.make_scheme ([], (ftype,Option.ABSENT)),
d1378 1
a1378 1
					   Absyn.Option.ABSENT,location,_))::restbinds,
d1382 1
a1382 1
	  (anexcon, Scheme.make_scheme ([],(Types.exn_type,Option.ABSENT)),
d1407 1
a1407 1
	   (anewexcon, Scheme.make_scheme ([], (atype,Option.ABSENT)),
@


1.74
log
@Changing order of typechecking functions and arguments
@
text
@d4 3
d305 2
d978 4
a981 9
           (Basis.close (Basis.context_level acontext,
                         new_VE,expansive_vars,
                         tyvars_scoped_here,true)
            handle Basis.CloseError (s,ty) =>
              (report_error
               (Info.RECOVERABLE, location,
                implode [s, Completion.print_type(print_options,Basis.env_of_context acontext,ty)]);
               empty_valenv))

@


1.73
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
d623 1
a624 1
	   val tyexp1 = check_exp (exp1, acontext, Option.PRESENT exp2)
@


1.72
log
@Reinstate error messages for unbound strid in open.
Some of these cannot be caught by the parser.
@
text
@d4 4
d563 7
a569 1
        fun check_exp (Absyn.SCONexp scon, _, _) = Types.type_of scon
@


1.71
log
@Removed quotes around reconstructed source in error messagess.
@
text
@d4 3
d1069 6
a1074 6
             handle Env.LookupStrId strid =>
               Crash.impossible "Unbound structure in open"
(*
               (report_error
                (Info.RECOVERABLE, location,
                 IdentPrint.strid_unbound_strid_message (strid,lstrid,print_options));
a1075 1
*)
@


1.70
log
@Fix bug 940
Also fix bug provoked by fun f(x, y) = if x = x then x y else y,
which doesn't give source reference
@
text
@d4 5
d539 1
a539 3
	  implode ["Near '",
		   Context_Print.exp_to_string print_options exp,
		   "'"]
d879 1
a879 1
		   Datatypes.Err_String "Near 'if ",
d881 1
a881 1
		   Datatypes.Err_String " then ... else ...'\n  'then' case: ",
d891 1
a891 1
		   Datatypes.Err_String "Near 'case ",
d897 1
a897 1
		   Datatypes.Err_String " => ...'\n  Expected type: ",
d904 1
a904 1
		 Datatypes.Err_String "Near '... andalso ",
d906 1
a906 1
		 Datatypes.Err_String "'\n  Actual argument type: ",
d910 1
a910 1
		 Datatypes.Err_String "Near '... orelse ",
d912 1
a912 1
		 Datatypes.Err_String "'\n  Actual argument type: ",
d916 1
a916 1
		 Datatypes.Err_String "Near '",
d918 1
a918 1
		 Datatypes.Err_String " => ...'\n  Expected type: ",
d1115 1
a1115 1
		Datatypes.Err_String "Near '",
d1117 1
a1117 1
		Datatypes.Err_String "'\n  Pattern type:    ",
@


1.69
log
@Fix problems with result types from functors which instantaite to functions
@
text
@d4 3
d656 3
a658 1
		   implode ["Attempt to apply value of equality type as a function: ",
d685 2
a686 1
		 implode ["Attempt to apply non-function type",
d695 2
a696 1
		 implode ["Attempt to apply non-function type",
@


1.68
log
@Changed wording in error message.
@
text
@d677 9
d1157 1
a1157 1
		     [Datatypes.Err_String "Type mismatch in recursive function ",
@


1.67
log
@Removing debug stuff
@
text
@d4 3
d1148 1
a1148 1
		     [Datatypes.Err_String "Type mismatch in recursive value binding for ",
@


1.66
log
@Rationalizing debugger
@
text
@d4 3
a229 1
require "../typechecker/ty_debug";
a240 1
require "../typechecker/tyvarenv";
a249 1
  structure Ty_Debug     : TY_DEBUG
a260 1
  structure Tyvarenv   : TYVARENV
a261 7
  structure Debug :


    sig
      val set_debug_level : int -> unit
      val debug_level     : unit -> int
    end
d264 1
a264 1
          Basis.BasisTypes = Tyvarenv.BasisTypes
a295 2
    val do_debug = Ty_Debug.do_debug

a302 44
(*  (* not used anymore *)
    (***** Add together two environments (infix operator) *****)
      
    infix &&

    fun ve1 && ve2 = Valenv.ve_plus_ve(ve1, ve2)


    (***** Find the local context in an expression *****)

    local
      fun singleVE (valid, ts) =
	Valenv.add_to_ve (valid, ts, empty_valenv)
    in
      fun exp_context (Absyn.SCONexp _) =
	  empty_valenv
	| exp_context (Absyn.VALexp (Ident.LONGVALID (_, valid), ref ty,_)) =
	  singleVE (valid, UNBOUND_SCHEME ty)
	| exp_context (Absyn.RECORDexp fields) =
	  Lists.reducel
	  (fn (ve, (_, exp)) => exp_context exp && ve)
	  (empty_valenv, fields)
	| exp_context (Absyn.LOCALexp (_, exp)) =
	  exp_context exp
	| exp_context (Absyn.APPexp (exp1, exp2,_,_,_)) =
	  exp_context exp1 && exp_context exp2
	| exp_context (Absyn.TYPEDexp (exp, _,_)) =
	  exp_context exp
	| exp_context (Absyn.HANDLEexp (exp,_,match,_,_)) =
	  exp_context exp && match_context match
	| exp_context (Absyn.RAISEexp (exp,location)) =
	  exp_context exp
	| exp_context (Absyn.FNexp (match,_,_,_)) =
	  match_context match

      (***** Find the local context in a match *****)

      and match_context [] = empty_valenv
	| match_context ((pat, exp) :: rest) =
	  Patterns.pat_context pat && exp_context exp && match_context rest

    end
*)

a306 7
    fun debug L =
      if do_debug andalso Debug.debug_level () > 10 then
	(Lists.iterate Print.print L;
	 Print.print "\n")
      else
	()
	    
d309 1
d318 5
d348 1
a348 1
                    (fn lab=>fn ty=>fn map =>
d555 1
a555 1
                 handle Basis.LookupValId_in_Context =>
d557 3
a559 2
                    (Info.RECOVERABLE, location,
                                  implode ["Unbound value ", IdentPrint.printLongValId print_options lvalid]);
d561 3
d919 1
a919 1
           Basis.context_plus_tyvarset_and_tyvarenv (acontext, tyvars_scoped_here)
d974 3
a976 3
      | check_dec (Absyn.DATATYPEdec adatbindlist,
		   acontext as Basistypes.CONTEXT (level,tyvarset,
					      ENV(se,te,ve),_)) =
d978 4
a981 21
	   fun make_dummy_te ((_,[]),te) = te
	     | make_dummy_te ((location,(tyvars,tycon,_,_,conbinds)::t),te) = 
	       make_dummy_te((location,t),
			     Tyenv.add_to_te
			     (te, tycon,
			      TYSTR
			      (Types.make_eta_tyfun
			       (Types.make_tyname 
				(Lists.length tyvars,
				 true,
				 IdentPrint.printTyCon tycon,
				 Datatypes.Option.PRESENT(Location.to_string location))),
			       empty_valenv)))

	   val new_context = 
	     Basistypes.CONTEXT (level,tyvarset,
			    ENV (se,make_dummy_te (adatbindlist,te),
				 ve),
			    Tyvarenv.empty_tyvarenv)
	     
	   val (new_ve,new_te) = check_datbind (adatbindlist,
d1043 4
a1046 2
             handle
             Env.Lookup_LongStrId =>
d1049 1
a1049 2
                 implode ["Unbound structure identifier ", 
                          IdentPrint.printLongStrId lstrid]);
d1051 1
d1188 1
a1188 1
    and check_datbind ((_,[]),_,(ve,te)) = (ve,te)
d1190 3
a1192 2
      | check_datbind ((location,(tyvars,tycon,type_ref,tyfun_ref,conbind)::datbinds),
		       acontext as Basistypes.CONTEXT (level,tyvarset,env,_),
d1195 1
a1195 6
	   fun collect ([],amap) = amap
	     | collect (h::t,amap) =
	       Tyvarenv.add_to_tyvarenv (level,h,collect(t,amap))
	       
	   fun make_tyvarenv (tyvars) =
	     collect (tyvars, Tyvarenv.empty_tyvarenv)
a1196 3
	   val new_context =
	     Basistypes.CONTEXT (level, tyvarset, env, make_tyvarenv tyvars)
	     
d1198 4
a1201 2
	     handle Basis.LookupTyCon =>
               Crash.impossible "Garbled context in check_datbind"
d1213 1
a1213 1
	      tyvars) 
d1226 1
a1226 4
	   check_datbind 
	   ((location,datbinds),
	    acontext,
	    (new_ve,new_te))
d1355 2
a1356 1
	     handle Basis.LookupValId_in_Context =>
d1358 6
a1363 2
                (Info.RECOVERABLE, location,
                              implode ["Unbound exception ", IdentPrint.printLongValId print_options lvalid]);
@


1.65
log
@Abstraction of debug information
@
text
@d4 3
d289 1
d614 1
a614 1
                    (fresh_tyvar (acontext, false, false),(nil,Option.ABSENT)))
@


1.64
log
@Datatypes.META_OVERLOADED has extra arguments, Basis.lookup_val takes an
extra location argument, and Basis.UnresolvedVar has been removed.
@
text
@d4 4
d238 1
d261 2
d288 1
d381 1
a381 3
          val types
            : (Datatypes.Type * Datatypes.Instance ref Datatypes.Option.opt 
               * (Absyn.Tyfun ref * (int,int) Datatypes.Option.option ref) list) ref list ref = ref []
d540 6
a545 3
              (map (fn pat_ty as ref(ty,i,tfs) => pat_ty := (copy_type ty,i,tfs)) (!types);
               map (fn tf => tf := copy_tyfun (!tf)) (!tyfuns);
               ())
d601 1
a601 2
          | check_exp (Absyn.VALexp (lvalid as Ident.LONGVALID (apath,aval),
                                     type_ref,location,instance), acontext, _) =
d605 1
a605 1
		   (apath, aval, acontext, location, generate_moduler)
d1419 2
a1420 3
      | check_exconbind (Absyn.OLDexbind 
			 ((anewexcon,type_ref),
			  lvalid as Ident.LONGVALID (apath,anoldexcon),location,_)
d1424 1
a1424 2
	     #1(Basis.lookup_val
		  (apath, anoldexcon, acontext, location, generate_moduler))
@


1.63
log
@Type function and TYNAME valenv recording for Modules Debugger.
@
text
@d4 3
d274 1
d402 2
a403 2
              | copy_type (ovty as Datatypes.META_OVERLOADED(ty1 as ref(ty),v)) =
                (Datatypes.META_OVERLOADED(Lists.assoc(ty1,!tys2),v)
d595 3
a597 1
               val (atype,instance') = Basis.lookup_val (apath,aval,acontext, generate_moduler)
d981 2
a982 7
               empty_valenv)
                 | Basis.UnresolvedVar valid =>
                     (report_error
                      (Info.RECOVERABLE, location,
                       (* implode ["Cannot resolve type of overloaded operator: ",IdentPrint.printValId print_options valid] *)
                       "impossible type error 3: Cannot resolve type of overloaded operator");
                      empty_valenv))
d1416 3
a1418 1
	   val atype = #1(Basis.lookup_val (apath, anoldexcon, acontext, generate_moduler))
@


1.62
log
@Found a way to generate some 'impossible' type errors.
@
text
@d4 3
d275 2
a276 1
  sharing type Type_exp.Absyn.Instance = Basis.BasisTypes.Datatypes.instance
d351 1
a351 1

d354 6
a359 2

    fun check_dec (param as (error_info,Options.OPTIONS{print_options,...})) args =
d368 176
d591 1
a591 1
               val (atype,instance') = Basis.lookup_val (apath,aval,acontext)
d599 2
a600 5
               case instance of
                 Absyn.Option.PRESENT(instance) => 
                   instance := instance'
               | _ => ();
               atype)
d874 1
a874 1
          val (new_ve, pat_ty) = check_pat (apat, acontext)
d935 3
a937 2
	   check_rules
	     (rules, acontext, res, Option.PRESENT apat, data, argexp, location)
d1017 1
a1017 1
	     | make_dummy_te ((location,(tyvars,tycon,_,conbinds)::t),te) = 
d1136 1
a1136 1
	   val (newve, aty) = check_pat (apat, acontext)
d1154 2
d1169 1
a1169 1
	 val (newve, aty) = check_pat (apat, acontext)
d1177 1
a1177 1
			     ((aty,anexp,location,apat)::ty_exp))
d1184 1
a1184 1
	   fun f (atype, anexp,location,apat) = 
d1209 1
a1209 1
	       ()
d1221 1
a1221 1
      | check_typbind ((tyvarseq,tycon,ty)::typbinds,acontext) =
d1227 11
a1237 3
			   (Types.make_tyfun
			    (tyvarseq,check_type (ty,acontext)),
			    empty_valenv))
a1238 1
	  
d1243 1
a1243 1
      | check_datbind ((location,(tyvars,tycon,type_ref,conbind)::datbinds),
d1260 7
d1415 1
a1415 1
	   val atype = #1(Basis.lookup_val (apath, anoldexcon, acontext))
d1428 1
d1430 2
a1431 1
        check_dec args
@


1.61
log
@Added name of relevant function in recursive function binding error.
@
text
@d4 3
d920 1
a920 1
                 implode ["impossible type error 4: Unbound structure identifier ", 
@


1.60
log
@Renamed Basis.level to Basis.context_level
@
text
@d4 3
d990 1
a990 1
			     ((aty,anexp,location)::ty_exp))
d997 1
a997 1
	   fun f (atype, anexp,location) = 
d999 4
d1011 3
a1013 1
		     [Datatypes.Err_String "Type mismatch in recursive value binding\n",
@


1.59
log
@Remove old debugging code, fixup a couple of error messages, and
a few inexhaustive bindings.
@
text
@d4 4
d285 1
a285 1
      METATYVAR (ref (Basis.level acontext,NULLTYPE,NO_INSTANCE), eq, imp)
d636 1
a636 1
          val level = Basis.level acontext
d780 1
a780 1
           (Basis.close (Basis.level acontext,
@


1.58
log
@Marked certain error messages as "impossible".
@
text
@d4 3
d338 3
d391 1
a391 6
        fun check_exp (Absyn.SCONexp scon, _, _) =
          (if do_debug then
             debug ["check_exp 1", IdentPrint.printSCon scon]
           else ();

             (Types.type_of scon))
a395 2
            (debug ["check_exp 2,3,4"];
             
d410 1
a410 1
             end)
a414 2
	(debug ["check_exp 5,8"];

d425 1
a425 1
	 end)
d430 3
a432 4
	(debug ["check_exp 6"];
	 check_exp (exp,Basis.context_plus_env
		    (acontext,check_dec (dec,acontext)),
		    Option.ABSENT))
a438 2
	(debug ["check_exp 10"];

d455 1
a455 1
		   [Datatypes.Err_String "Argument to 'if' must be of type bool:\n",
d468 1
a468 1
		   [Datatypes.Err_String "First argument of 'andalso' is not boolean:\n",
d473 1
a473 1
		   [Datatypes.Err_String "First argument of 'orelse' is not boolean:\n",
d525 1
a525 1
	end)
a529 2
	(debug ["check_exp 11"];
	 
d548 1
a548 1
	 end)
a554 2
	(debug ["check_exp 12"];
	 
d597 1
a597 1
	 end)
a601 2
	(debug ["check_exp 13"];

d618 1
a618 1
	 end)
a622 2
	(debug ["check_exp 14"];
	 
d628 1
a628 1
	 end)
d642 2
a643 1
      | check_exp (arg_exp as Absyn.COERCEexp (exp,atype,tyref), acontext, _) =
d653 1
a653 1
                 (Location.UNKNOWN,
a674 1
      (debug ["check_match 15,16"];
d677 1
a677 1
	  Option.ABSENT, data, argexp, location))
d696 1
a696 3
		    val argexp' = case argexp
				  of Option.PRESENT x => x
				  |  Option.ABSENT => Crash.impossible "argexp"
d707 2
a708 9
		let val (pat_ty', _) = Types.argres atype
		    val argexp' =
		      case argexp
		      of Option.PRESENT x => x
		      |  Option.ABSENT => Crash.impossible "argexp"
		    val lastpat' =
		      case lastpat
		      of Option.PRESENT x => x
		      |  Option.ABSENT => Crash.impossible "lastpat"
d718 1
a718 1
		   Datatypes.Err_Type pat_ty',
d720 1
a720 1
		   Datatypes.Err_Type pat_ty]
a754 1
      (debug ["check_dec 17"];
d809 1
a809 1
       end)
d814 3
a816 4
	(if do_debug then debug ["check_dec 18"] else ();
	   (ENV (Strenv.empty_strenv,
		 check_typbind (atypbind,acontext),
		 empty_valenv)))
a822 2
	(debug ["check_dec 19"];
	 
d860 1
a860 1
	 end)
a864 2
	(debug ["check_dec 20"];
	 
d871 1
a871 1
	 end)
a875 2
	(debug ["check_dec 21"];
	 
d880 1
a880 1
	 end)
a884 2
	(debug ["check_dec 22"];
	 
d889 1
a889 1
	 end)
a893 1
	(debug ["check_dec 23"];
d899 4
a902 2
               val STR (_,_,new_env) =
		 Env.resolve_top_level (Env.lookup_longstrid (lstrid, E))
d915 1
a915 1
	 end)
a919 1
	(debug ["check_dec 25"];
d931 1
a931 1
	 end)
d939 1
a939 2
      (debug ["check_valbind 26"];
       (check_recvalbind (recvalbinds,acontext,ve,exp_vars,[])))
a942 2
	(debug ["check_valbind 26a"];
	 
d968 1
a968 1
	 end)
a973 2
      (debug ["check_valbind 27"];
       
d984 1
a984 1
       end)
a986 2
	(debug ["check_valbind 27a"];
	 
d1015 1
a1015 1
	 end)
d1019 1
a1019 3
    and check_typbind ([],acontext) = 
      (debug ["check_typbind 28"];
       Tyenv.empty_tyenv)
a1021 2
	(debug ["check_typbind 28a"];

d1030 1
a1030 1
	 end)
d1034 1
a1034 3
    and check_datbind ((_,[]),_,(ve,te)) =
      (debug ["check_datbind 29"];
       (ve,te))
a1038 2
	(debug ["check_datbind 29a"];
	 
d1074 1
a1074 1
	 end)
a1085 2
      (debug ["check_conbind 30"];

d1108 1
a1108 1
       end)
a1117 2
	(debug ["check_conbind 30a "];
	 
d1127 1
a1127 1
	 end)
a1136 8
	(if do_debug then
	   debug
	   ["check_conbind 30b \n tyfun =",
	    Types.string_tyfun tyfun,
	    " tycon_type = ",
	    Completion.print_type (print_options,Basis.env_of_context acontext,tycon_type)]
	 else ();

d1148 1
a1148 1
	 end)
a1156 2
	(debug ["check_exbind 31"];
	 
d1171 3
a1173 1
                           "\n  Type of exception: ",
d1182 1
a1182 1
	 end)
a1188 2
	(debug ["check_exbind 31a"];
	    
d1192 1
a1192 1
	   check_exconbind(restbinds,acontext))))
a1199 2
	(debug ["check_exbind 32"];
	 
d1213 1
a1213 1
	 end)
@


1.57
log
@Return augmented environment rather than empty environment after a "cannot
generalize" error.
@
text
@d4 4
d575 1
a575 1
                (Info.RECOVERABLE, location, "Illegal match in ");
d812 1
a812 1
                       "Cannot resolve type of overloaded operator");
d942 1
a942 1
                 implode ["Unbound structure identifier ", 
@


1.56
log
@Added code to encode type errors as a list of strings and types.
@
text
@d4 3
d816 1
a816 4
	   then
	     ENV (Strenv.empty_strenv,
		  Tyenv.empty_tyenv,
		  VE')
d825 4
a828 2
                       " cannot be generalized in value declaration"]);
             Env.empty_env)
@


1.55
log
@Added absyn annotations
@
text
@d4 3
d327 1
a327 1
	      
d356 16
d377 1
d451 34
a484 46
               if is_if_exp (get_data exp1) then
                 implode
		   ["Argument to 'if' must be of type bool:\n",
		    "Near '",
		    Context_Print.exp_to_string print_options arg_exp,
                    "'\n  Argument type: ",
                    Completion.print_type
		      (print_options, Basis.env_of_context acontext, atype)]
               else if is_case_exp (get_data exp1) then
                 implode
		   ["Pattern in 'case' has different type from choice expression\n",
		    "Near '", Context_Print.exp_to_string print_options arg_exp,
                    "'\n  Required argument type: ",
                    Completion.print_type
		      (print_options, Basis.env_of_context acontext, atype),
                    "\n  Actual argument type:   ",
                    Completion.print_type
		      (print_options, Basis.env_of_context acontext, arg)]
	       else if is_andalso_exp (get_data exp1) then
                 implode
		   ["First argument of 'andalso' is not boolean:\n",
		    "Near '",
		    Context_Print.exp_to_string print_options arg_exp,
		    "'\n  Actual argument type: ",
                    Completion.print_type
		      (print_options,Basis.env_of_context acontext,atype)]
	       else if is_orelse_exp (get_data exp1) then
                 implode
		   ["First argument of 'orelse' is not boolean:\n",
		    "Near '",
		    Context_Print.exp_to_string print_options arg_exp,
		    "'\n  Actual argument type: ",
                    Completion.print_type
		      (print_options,Basis.env_of_context acontext,atype)]
               else
                 implode ["Function applied to argument of wrong type\n",
			  "Near '", Context_Print.exp_to_string print_options arg_exp,
                          "'\n  Required argument type: ",
                          Completion.print_type (print_options,
                                                 Basis.env_of_context acontext,
                                                 arg),
                          "\n  Actual argument type:   ",
                          Completion.print_type (print_options,
                                                 Basis.env_of_context acontext,
                                                 atype)],
                 fresh_tyvar (acontext, false, false))
d504 6
a509 8
                       implode ["Circularity in function application\n",
				"Near '", Context_Print.exp_to_string print_options arg_exp,
                                "'\n  Required argument type: ",
                                Completion.print_type (print_options,Basis.env_of_context acontext,t),
                                "\n  Actual argument type:   ",
                                Completion.print_type (print_options,
                                                       Basis.env_of_context acontext, 
                                                       FUNTYPE (atype, newmeta))],
d541 6
a546 6
               implode ["Types of expression and constraint do not agree\n",
			"Near '", Context_Print.exp_to_string print_options arg_exp,
                        "'\n  Expression type: ",
                        Completion.print_type (print_options,Basis.env_of_context acontext, exp_ty),
                        "\n  Constraint type: ",
                        Completion.print_type(print_options,Basis.env_of_context acontext,ty_exp_ty)],
d580 4
a583 4
                 implode ["Match in handler should have argument type exn\n",
			  "Near '", Context_Print.exp_to_string print_options arg_exp,
                          "'\n  Match type: ",
                          Completion.print_type(print_options,Basis.env_of_context acontext,arg)],
d592 6
a597 6
               implode ["Handler disagrees with expression\n",
			"Near '", Context_Print.exp_to_string print_options arg_exp,
                        "'\n  Handler type:    ",
                        Completion.print_type (print_options,Basis.env_of_context acontext,res),
                        "\n  Expression type: ",
                        Completion.print_type (print_options,Basis.env_of_context acontext,exp_ty)],
d617 4
a620 4
               implode ["Expression raised is not an exception\n",
			"Near '", Context_Print.exp_to_string print_options arg_exp,
                        "'\n  Expression type: ",
                        Completion.print_type (print_options,Basis.env_of_context acontext,exp_ty)],
d660 4
a663 4
                  implode ["Expression coerced is not Dynamic\n",
			"Near '", Context_Print.exp_to_string print_options arg_exp,
                        "'\n  Expression type: ",
                        Completion.print_type(print_options,Basis.env_of_context acontext, exp_ty)],
d707 7
a713 10
                  implode
		    ["Branches of 'if' have incompatible types:\n",
		     "Near 'if ",
		     Context_Print.exp_to_string print_options argexp',
		     " then ... else ...'\n  'then' case: ",
                     Completion.print_type
		       (print_options,Basis.env_of_context acontext,then_ty),
                     "\n  'else' case: ",
                     Completion.print_type
		       (print_options,Basis.env_of_context acontext,exp_ty)]
d726 11
a736 14
                  implode
		    ["Branches of 'case' have incompatible types:\n",
		     "Near 'case ",
		     Context_Print.exp_to_string print_options argexp',
		     " of ... ",
		     Context_Print.pat_to_string print_options lastpat',
		     " => ... | ",
		     Context_Print.pat_to_string print_options apat,
		     " => ...'\n  Expected type: ",
                     Completion.print_type
		       (print_options,Basis.env_of_context acontext,pat_ty'),
                     "\n  Rule type:     ",
                     Completion.print_type
		       (print_options,Basis.env_of_context acontext,pat_ty)]
d739 5
a743 7
                implode
		  ["Second argument of 'andalso' is not boolean:\n",
		   "Near '... andalso ",
		   Context_Print.exp_to_string print_options anexp,
		   "'\n  Actual argument type: ",
                   Completion.print_type
		     (print_options,Basis.env_of_context acontext,exp_ty)]
d745 5
a749 7
                implode
		  ["Second argument of 'orelse' is not boolean:\n",
		   "Near '... orelse ",
		   Context_Print.exp_to_string print_options anexp,
		   "'\n  Actual argument type: ",
                   Completion.print_type
		     (print_options,Basis.env_of_context acontext,exp_ty)]
d751 7
a757 10
                implode
		  ["Type disagreement between match rules\n",
		   "Near '",
		   Context_Print.pat_to_string print_options apat,
		   " => ...'\n  Expected type: ",
                   Completion.print_type
		     (print_options,Basis.env_of_context acontext,atype),
                   "\n  Rule type:     ",
                   Completion.print_type
		     (print_options,Basis.env_of_context acontext,ftype)],
d983 7
a989 6
               implode ["Pattern and expression types do not agree\n",
			"Near '", Context_Print.dec_to_string print_options (apat, anexp),
                        "'\n  Pattern type:    ",
                        Completion.print_type(print_options,Basis.env_of_context acontext,aty),
                        "\n  Expression type: ", 
                        Completion.print_type(print_options,Basis.env_of_context acontext,atype)],
d1034 6
a1039 6
                     implode ["Type mismatch in recursive value binding\n",
			      "Near '", Context_Print.exp_to_string print_options anexp,
                              "'\n  Pattern type:    ",
                              Completion.print_type(print_options,Basis.env_of_context acontext,atype),
                              "\n  Expression type: ",
                              Completion.print_type (print_options,Basis.env_of_context acontext,atype')],
@


1.54
log
@Merged in bug fix.
@
text
@d4 3
d294 1
a294 1
	| exp_context (Absyn.APPexp (exp1, exp2,_,_)) =
d415 1
a415 1
      | check_exp (arg_exp as Absyn.APPexp (exp1, exp2,location,argument_type), acontext, _) =
@


1.53
log
@Fixed broken rcsmerge.
@
text
@d4 3
d13 3
d332 1
a332 1
	|   get_data _ = Crash.impossible "get_data"
d334 15
a348 13
        fun test_data string =
          let val string_size = size string
          in
            fn data =>
              size data >= string_size andalso
              string = String.substring (data,0,string_size)
          end

        val is_if_exp = test_data "<if>"
        val is_case_exp = test_data "<case>"
        val is_andalso_exp = test_data "<andalso>"
        val is_orelse_exp = test_data "<orelse>"
        val is_while_exp = test_data "While statement"
@


1.52
log
@Merged in bug fix.
@
text
@d4 3
d356 1
a356 1
                                     type_ref,location), acontext, _) =
@


1.51
log
@Runtime-instance recording in VALexps for polymorphic debugger.
@
text
@d4 9
d247 1
d322 17
d340 5
a344 1
        fun check_exp (Absyn.SCONexp scon,_) =
d353 1
a353 1
                                     type_ref,location,instance),acontext) =
d374 1
a374 1
      | check_exp (Absyn.RECORDexp arecordlist, acontext) =
d381 1
a381 1
		 val exptype = check_exp (anexp, acontext)
d391 1
a391 1
      | check_exp(Absyn.LOCALexp (dec, exp), acontext) =
d394 2
a395 1
		    (acontext,check_dec (dec,acontext))))
d401 1
a401 1
      | check_exp (arg_exp as Absyn.APPexp (exp1, exp2,location,argument_type), acontext) =
d405 2
a406 2
	   val tyexp1 = check_exp (exp1, acontext)
	   val tyexp2 = check_exp (exp2, acontext)
a409 11
           fun test_data string =
             let val string_size = size string
             in
               fn (Absyn.FNexp(_,_,data,_)) =>
               size data >= string_size andalso
               string = String.substring (data,0,string_size)
                | _ => false
             end
           val is_if_exp = test_data "<if>"
           val is_while_exp = test_data "While statement"

d417 34
a450 14
               if is_if_exp exp1
                 then
                   implode ["Argument to if must be of type bool:\n",
                            "Argument type: ",
                            Completion.print_type (print_options,
                                                   Basis.env_of_context acontext,
                                                   atype)]
               else if is_while_exp exp1
                 then
                   implode ["Argument to while must be of type bool:\n",
                            "Argument type: ",
                            Completion.print_type (print_options,
                                                   Basis.env_of_context acontext,
                                                   atype)]
d452 2
a453 2
                 implode ["Function applied to argument of wrong type",
			  " near '", Context_Print.exp_to_string print_options arg_exp,
d482 2
a483 2
                       implode ["Circularity in function application",
				" near '", Context_Print.exp_to_string print_options arg_exp,
d508 1
a508 1
      | check_exp (arg_exp as Absyn.TYPEDexp (exp, ty,location), acontext) =
d512 1
a512 1
	   val exp_ty  = check_exp (exp, acontext)
d521 2
a522 2
               implode ["Types of expression and constraint do not agree",
			" near '", Context_Print.exp_to_string print_options arg_exp,
d535 1
a535 1
      | check_exp (arg_exp as Absyn.HANDLEexp (exp,type_ref,match,location,_), acontext) =
d539 1
a539 1
	   val exp_ty = check_exp (exp, acontext)
d551 2
a552 1
	   val (arg, res) = check_fun (check_match (match, acontext,location))
d560 2
a561 2
                 implode ["Match in handler should have argument type exn",
			  " near '", Context_Print.exp_to_string print_options arg_exp,
d572 2
a573 2
               implode ["Handler disagrees with expression",
			" near '", Context_Print.exp_to_string print_options arg_exp,
d584 1
a584 1
      | check_exp (arg_exp as Absyn.RAISEexp (exp,location), acontext) =
d588 1
a588 1
	   val exp_ty = check_exp (exp, acontext)
d597 2
a598 2
               implode ["Expression raised is not an exception",
			" near '", Context_Print.exp_to_string print_options arg_exp,
d607 1
a607 1
      | check_exp (Absyn.FNexp (amatch,type_ref,_,location), acontext) =
d611 1
a611 1
	   val atype = check_match (amatch, acontext,location)
d617 1
a617 1
      | check_exp (Absyn.DYNAMICexp (exp,explicit_tyvars,info_ref), acontext) =
d622 1
a622 1
          val atype = check_exp(exp,acontext)
d629 1
a629 1
      | check_exp (arg_exp as Absyn.COERCEexp (exp,atype,tyref), acontext) =
d631 1
a631 1
          val exp_ty = check_exp(exp,acontext)
d640 2
a641 2
                  implode ["Expression coerced is not Dynamic",
			" near '", Context_Print.exp_to_string print_options arg_exp,
d651 1
a651 1
      | check_exp (Absyn.MLVALUEexp mlvalue, acontext) =
d656 5
a660 1
    and check_match (matches, acontext,location) =
d663 2
a664 1
       (matches, acontext, fresh_tyvar(acontext, false, false),location))
d666 3
a668 4
    and check_rules ([], acontext, atype,_) =
      atype

      | check_rules ((apat, anexp, matchloc) :: rules, acontext, atype,location) =
d672 1
a672 1
          val exp_ty = check_exp (anexp, new_context)
d677 1
a677 2
            {
             first = atype, second = ftype, result = atype,
d681 71
a751 8
              implode ["Type disagreement between match rules",
		       " near '", Context_Print.pat_to_string print_options apat, " => ...",
                       "'\n  Expected type: ",
                       Completion.print_type(print_options,Basis.env_of_context acontext,atype),
                       "\n  Rule type:     ",
                       Completion.print_type(print_options,Basis.env_of_context acontext,ftype)],
                 atype)
	      }
d753 2
a754 1
	   check_rules (rules, acontext, res,location)
d968 1
a968 1
	   val atype = check_exp (anexp, acontext)
d976 2
a977 2
               implode ["Pattern and expression types do not agree",
			" near '", Context_Print.dec_to_string print_options (apat, anexp),
d1018 1
a1018 1
	       val atype' = check_exp (anexp, new_context)
d1026 2
a1027 2
                     implode ["Type mismatch in recursive value binding",
			      " near '", Context_Print.exp_to_string print_options anexp,
@


1.50
log
@Added location information to matches
@
text
@d4 3
d227 2
d246 1
a246 1
      METATYVAR (ref (Basis.level acontext,NULLTYPE), eq, imp)
a312 1
        
d322 1
a322 1
                                     type_ref,location),acontext) =
d326 1
a326 1
               val atype = Basis.lookup_val (apath,aval,acontext)
d331 1
a331 1
                    fresh_tyvar (acontext, false, false))
d333 6
a338 2
               type_ref := atype;
               atype
d424 1
a424 1
				(ref (_,NULLTYPE),eq,imp)),atype) =
d452 1
a452 1
	     | check_fun (METATYVAR (ref (_,t),eq,imp), atype) =
d503 1
a503 1
	     | check_fun (METATYVAR (ref (_, t), eq, imp)) = check_fun t
d1021 3
a1023 2
	       | subst (TYVAR (ref level,_)::tyvars) =
		 METATYVAR (ref (level,NULLTYPE),false,false)::(subst tyvars)
d1048 2
a1049 1
	   val tyscheme = Scheme.make_scheme (tyvartypes,tycon_type)
d1077 2
a1078 1
					      FUNTYPE (atype,tycon_type))
d1117 1
a1117 1
	   (anexcon, Scheme.make_scheme ([], ftype),
d1130 1
a1130 1
	  (anexcon, Scheme.make_scheme ([],Types.exn_type),
d1142 1
a1142 1
	   val atype = Basis.lookup_val (apath, anoldexcon, acontext)
d1152 1
a1152 1
	   (anewexcon, Scheme.make_scheme ([], atype),
@


1.50.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.50  1993/08/10  14:00:10  matthew
Added location information to matches

@


1.50.1.2
log
@Added code to print better error messages for if, case, andalso and orelse.
@
text
@a3 3
Revision 1.50.1.1  1993/08/10  14:00:10  jont
Fork for bug fixing

a235 1
    structure Option = Datatypes.Option
a309 17
	fun get_data (Absyn.FNexp(_,_,data,_)) = data
	|   get_data _ = Crash.impossible "get_data"

        fun test_data string =
          let val string_size = size string
          in
            fn data =>
              size data >= string_size andalso
              string = String.substring (data,0,string_size)
          end

        val is_if_exp = test_data "<if>"
        val is_case_exp = test_data "<case>"
        val is_andalso_exp = test_data "<andalso>"
        val is_orelse_exp = test_data "<orelse>"
        val is_while_exp = test_data "While statement"

d312 1
a312 4
	(* The third argument is used to pass the argument expression of
	   a function to the code that checks that function, for use in
	   error messages. *)
        fun check_exp (Absyn.SCONexp scon, _, _) =
d321 1
a321 1
                                     type_ref,location), acontext, _) =
d338 1
a338 1
      | check_exp (Absyn.RECORDexp arecordlist, acontext, _) =
d345 1
a345 1
		 val exptype = check_exp (anexp, acontext, Option.ABSENT)
d355 1
a355 1
      | check_exp(Absyn.LOCALexp (dec, exp), acontext, _) =
d358 1
a358 2
		    (acontext,check_dec (dec,acontext)),
		    Option.ABSENT))
d364 1
a364 1
      | check_exp (arg_exp as Absyn.APPexp (exp1, exp2,location,argument_type), acontext, _) =
d368 2
a369 2
	   val tyexp2 = check_exp (exp2, acontext, Option.ABSENT)
	   val tyexp1 = check_exp (exp1, acontext, Option.PRESENT exp2)
d373 11
d391 14
a404 34
               if is_if_exp (get_data exp1) then
                 implode
		   ["Argument to 'if' must be of type bool:\n",
		    "Near '",
		    Context_Print.exp_to_string print_options arg_exp,
                    "'\n  Argument type: ",
                    Completion.print_type
		      (print_options, Basis.env_of_context acontext, atype)]
               else if is_case_exp (get_data exp1) then
                 implode
		   ["Pattern in 'case' has different type from choice expression\n",
		    "Near '", Context_Print.exp_to_string print_options arg_exp,
                    "'\n  Required argument type: ",
                    Completion.print_type
		      (print_options, Basis.env_of_context acontext, atype),
                    "\n  Actual argument type:   ",
                    Completion.print_type
		      (print_options, Basis.env_of_context acontext, arg)]
	       else if is_andalso_exp (get_data exp1) then
                 implode
		   ["First argument of 'andalso' is not boolean:\n",
		    "Near '",
		    Context_Print.exp_to_string print_options arg_exp,
		    "'\n  Actual argument type: ",
                    Completion.print_type
		      (print_options,Basis.env_of_context acontext,atype)]
	       else if is_orelse_exp (get_data exp1) then
                 implode
		   ["First argument of 'orelse' is not boolean:\n",
		    "Near '",
		    Context_Print.exp_to_string print_options arg_exp,
		    "'\n  Actual argument type: ",
                    Completion.print_type
		      (print_options,Basis.env_of_context acontext,atype)]
d406 2
a407 2
                 implode ["Function applied to argument of wrong type\n",
			  "Near '", Context_Print.exp_to_string print_options arg_exp,
d436 2
a437 2
                       implode ["Circularity in function application\n",
				"Near '", Context_Print.exp_to_string print_options arg_exp,
d462 1
a462 1
      | check_exp (arg_exp as Absyn.TYPEDexp (exp, ty,location), acontext, _) =
d466 1
a466 1
	   val exp_ty  = check_exp (exp, acontext, Option.ABSENT)
d475 2
a476 2
               implode ["Types of expression and constraint do not agree\n",
			"Near '", Context_Print.exp_to_string print_options arg_exp,
d489 1
a489 1
      | check_exp (arg_exp as Absyn.HANDLEexp (exp,type_ref,match,location,_), acontext, _) =
d493 1
a493 1
	   val exp_ty = check_exp (exp, acontext, Option.ABSENT)
d505 1
a505 2
	   val (arg, res) =
	     check_fun (check_match (match, acontext, "", Option.ABSENT, location))
d513 2
a514 2
                 implode ["Match in handler should have argument type exn\n",
			  "Near '", Context_Print.exp_to_string print_options arg_exp,
d525 2
a526 2
               implode ["Handler disagrees with expression\n",
			"Near '", Context_Print.exp_to_string print_options arg_exp,
d537 1
a537 1
      | check_exp (arg_exp as Absyn.RAISEexp (exp,location), acontext, _) =
d541 1
a541 1
	   val exp_ty = check_exp (exp, acontext, Option.ABSENT)
d550 2
a551 2
               implode ["Expression raised is not an exception\n",
			"Near '", Context_Print.exp_to_string print_options arg_exp,
d560 1
a560 1
      | check_exp (Absyn.FNexp (amatch,type_ref,data,location), acontext, argexp) =
d564 1
a564 1
	   val atype = check_match (amatch, acontext, data, argexp, location)
d570 1
a570 1
      | check_exp (Absyn.DYNAMICexp (exp,explicit_tyvars,info_ref), acontext, _) =
d575 1
a575 1
          val atype = check_exp(exp,acontext,Option.ABSENT)
d582 1
a582 1
      | check_exp (arg_exp as Absyn.COERCEexp (exp,atype,tyref), acontext, _) =
d584 1
a584 1
          val exp_ty = check_exp(exp,acontext,Option.ABSENT)
d593 2
a594 2
                  implode ["Expression coerced is not Dynamic\n",
			"Near '", Context_Print.exp_to_string print_options arg_exp,
d604 1
a604 1
      | check_exp (Absyn.MLVALUEexp mlvalue, acontext,_) =
d609 1
a609 5
    (* data - string from enclosing function (or empty string)
     * argexp - argument of enclosing function (option)
     * lastpat - pattern of previous branch (option)
     *)
    and check_match (matches, acontext, data, argexp, location) =
d612 1
a612 2
         (matches, acontext, fresh_tyvar(acontext, false, false),
	  Option.ABSENT, data, argexp, location))
d614 4
a617 3
    and check_rules ([], _, atype, _, _, _, _) = atype
      | check_rules ((apat, anexp, matchloc) :: rules,
		     acontext, atype, lastpat, data, argexp, location) =
d621 1
a621 1
          val exp_ty = check_exp (anexp, new_context, Option.ABSENT)
d626 2
a627 1
            {first = atype, second = ftype, result = atype,
d631 8
a638 71
              if is_if_exp data then
		let val (_, then_ty) = Types.argres atype
		    val argexp' = case argexp
				  of Option.PRESENT x => x
				  |  Option.ABSENT => Crash.impossible "argexp"
		in
                  implode
		    ["Branches of 'if' have incompatible types:\n",
		     "Near 'if ",
		     Context_Print.exp_to_string print_options argexp',
		     " then ... else ...'\n  'then' case: ",
                     Completion.print_type
		       (print_options,Basis.env_of_context acontext,then_ty),
                     "\n  'else' case: ",
                     Completion.print_type
		       (print_options,Basis.env_of_context acontext,exp_ty)]
		end
              else if is_case_exp data then
		let val (pat_ty', _) = Types.argres atype
		    val argexp' =
		      case argexp
		      of Option.PRESENT x => x
		      |  Option.ABSENT => Crash.impossible "argexp"
		    val lastpat' =
		      case lastpat
		      of Option.PRESENT x => x
		      |  Option.ABSENT => Crash.impossible "lastpat"
		in
                  implode
		    ["Branches of 'case' have incompatible types:\n",
		     "Near 'case ",
		     Context_Print.exp_to_string print_options argexp',
		     " of ... ",
		     Context_Print.pat_to_string print_options lastpat',
		     " => ... | ",
		     Context_Print.pat_to_string print_options apat,
		     " => ...'\n  Expected type: ",
                     Completion.print_type
		       (print_options,Basis.env_of_context acontext,pat_ty'),
                     "\n  Rule type:     ",
                     Completion.print_type
		       (print_options,Basis.env_of_context acontext,pat_ty)]
		end
	      else if is_andalso_exp data then
                implode
		  ["Second argument of 'andalso' is not boolean:\n",
		   "Near '... andalso ",
		   Context_Print.exp_to_string print_options anexp,
		   "'\n  Actual argument type: ",
                   Completion.print_type
		     (print_options,Basis.env_of_context acontext,exp_ty)]
	      else if is_orelse_exp data then
                implode
		  ["Second argument of 'orelse' is not boolean:\n",
		   "Near '... orelse ",
		   Context_Print.exp_to_string print_options anexp,
		   "'\n  Actual argument type: ",
                   Completion.print_type
		     (print_options,Basis.env_of_context acontext,exp_ty)]
	      else
                implode
		  ["Type disagreement between match rules\n",
		   "Near '",
		   Context_Print.pat_to_string print_options apat,
		   " => ...'\n  Expected type: ",
                   Completion.print_type
		     (print_options,Basis.env_of_context acontext,atype),
                   "\n  Rule type:     ",
                   Completion.print_type
		     (print_options,Basis.env_of_context acontext,ftype)],
              atype)}
d640 1
a640 2
	   check_rules
	     (rules, acontext, res, Option.PRESENT apat, data, argexp, location)
d854 1
a854 1
	   val atype = check_exp (anexp, acontext, Option.ABSENT)
d862 2
a863 2
               implode ["Pattern and expression types do not agree\n",
			"Near '", Context_Print.dec_to_string print_options (apat, anexp),
d904 1
a904 1
	       val atype' = check_exp (anexp, new_context, Option.ABSENT)
d912 2
a913 2
                     implode ["Type mismatch in recursive value binding\n",
			      "Near '", Context_Print.exp_to_string print_options anexp,
@


1.50.1.3
log
@Fixed silly bug in the handling of errors in if, while, etc.
@
text
@a3 3
Revision 1.50.1.2  1993/09/29  15:31:08  daveb
Added code to print better error messages for if, case, andalso and orelse.

d315 1
a315 1
	|   get_data _ = ""
d317 13
a329 15
	local
          fun test_data string =
            let val string_size = size string
            in
              fn data =>
                size data >= string_size andalso
                string = String.substring (data,0,string_size)
            end
	in
          val is_if_exp = test_data "<if>"
          val is_case_exp = test_data "<case>"
          val is_andalso_exp = test_data "<andalso>"
          val is_orelse_exp = test_data "<orelse>"
          val is_while_exp = test_data "While statement"
	end
@


1.49
log
@Added context printing for unification errors
@
text
@d4 3
d614 1
a614 1
      | check_rules ((apat, anexp) :: rules, acontext, atype,location) =
d627 1
a627 1
             (location,
@


1.48
log
@Added some simple and hacky stuff for treating if and while errors specially
@
text
@d4 3
d177 1
d198 1
d208 1
a208 1
    Scheme.Options = Control_Unify.Options
d218 1
a218 1
  sharing Type_exp.Absyn = Patterns.Absyn
d358 1
a358 1
      | check_exp (Absyn.APPexp (exp1, exp2,location,argument_type), acontext) =
d401 2
a402 1
                          "\n  Required argument type: ",
d431 2
a432 1
                                "\n  Required argument type: ",
d456 1
a456 1
      | check_exp (Absyn.TYPEDexp (exp, ty,location), acontext) =
d470 2
a471 1
                        "\n  Expression type: ",
d483 1
a483 1
      | check_exp (Absyn.HANDLEexp (exp,type_ref,match,location,_), acontext) =
d508 2
a509 1
                          "\n  Match type: ",
d520 2
a521 1
                        "\n  Handler type:    ",
d531 1
a531 1
      | check_exp (Absyn.RAISEexp (exp,location), acontext) =
d545 2
a546 1
                        "\n  Expression type: ",
d576 1
a576 1
      | check_exp (Absyn.COERCEexp (exp,atype,tyref), acontext) =
d588 2
a589 1
                        "\n  Expression type: ",
d626 2
a627 1
                       "\n  Expected type: ",
d857 2
a858 1
                        "\n  Pattern type:    ",
d907 2
a908 1
                              "\n  Pattern type:    ",
@


1.47
log
@structure Option.
@
text
@d4 3
d362 11
d379 16
a394 1
                (location,
d397 3
a399 1
                          Completion.print_type (print_options,Basis.env_of_context acontext, arg),
d401 3
a403 1
                          Completion.print_type (print_options,Basis.env_of_context acontext, atype)],
@


1.46
log
@Removed exception environments.
@
text
@d4 3
d683 1
a683 1
				 Datatypes.PRESENT(Location.to_string location))),
d977 1
a977 1
      | check_conbind (((valid,type_ref),Absyn.ABSENT)::conbinds,
d997 1
a997 1
      | check_conbind (((valid,type_ref),Absyn.PRESENT aty)::conbinds,
d1030 1
a1030 1
					   Absyn.PRESENT aty,location,_))::restbinds,
d1062 1
a1062 1
					   Absyn.ABSENT,location,_))::restbinds,
@


1.45
log
@Changed equality type as function error message
@
text
@d4 3
d640 1
a640 2
		  VE',
		  empty_valenv)
a658 1
		 empty_valenv,
d665 1
a665 1
					      ENV(se,te,ve,ee),_)) =
d686 1
a686 1
				 ve,ee),
d704 1
a704 1
	    ENV (Strenv.empty_strenv,new_te,new_ve,empty_valenv))
d713 1
a713 1
	   val new_env as (ENV (_,te,_,_)) =
d728 1
a728 1
	   ENV (Strenv.empty_strenv, Tyenv.empty_tyenv, newve, newve)
d751 2
a752 1
               val STR (_,_,new_env) = Env.resolve_top_level (Env.lookup_longstrid (lstrid, E))
@


1.44
log
@Cleaned up after assembly changes
@
text
@d4 3
d372 1
a372 1
		   implode ["Attempt to apply value of non-function type ",
@


1.43
log
@Revised way of using assemblies such that structure assemblies are constructed
from the incremental basis rather than on the fly. Fixes a number of
problems with incorrect shadowing
@
text
@d4 5
a159 1
require "../typechecker/assemblies";
a180 1
  structure Assemblies : ASSEMBLIES
a200 1
  sharing Assemblies.Basistypes = Basis.BasisTypes
d207 1
a207 1
    structure BasisTypes = Basis.BasisTypes
a208 1
    structure Assemblies = Assemblies
d212 1
a212 1
    structure Set = BasisTypes.Set
a277 4
    (* type assembly *)

    val ty_ass = ref Assemblies.empty_tyassembly

d660 1
a660 1
		   acontext as BasisTypes.CONTEXT (level,tyvarset,
d667 11
a677 22
	       ((*if Tyenv.member_of_te_domain (te, tycon)
		  then
		    let val TYSTR (tyfun',conenv') = Tyenv.lookup (te, tycon)
		    in
		      ty_ass := 
		      (Assemblies.subTypeAssembly (tyfun',conenv',!ty_ass)
		       handle Assemblies.LookupTyfun => !ty_ass)
		    end
		else
		  ();
		  *)
	       make_dummy_te ((location,t),
			       Tyenv.add_to_te
			       (te, tycon,
				TYSTR
				(Types.make_eta_tyfun
				 (Types.make_tyname 
				  (Lists.length tyvars,
				   true,
				   IdentPrint.printTyCon tycon,
                                   Datatypes.PRESENT(Location.to_string location))),
				 empty_valenv))))
d680 1
a680 1
	     BasisTypes.CONTEXT (level,tyvarset,
d743 1
a743 1
	   val BasisTypes.CONTEXT(_, _, E, _) = acontext
d879 5
a883 18
	   (*
	   if Tyenv.member_of_te_domain (tyenv, tycon)
	     then
	       let 
		 val TYSTR (tyfun,ce) = Tyenv.lookup (tyenv, tycon)
	       in
		ty_ass := 
		(Assemblies.subTypeAssembly (tyfun,ce,!ty_ass)
		 handle Assemblies.LookupTyfun => !ty_ass)
	       end
	   else ();
	     *)
	   Tyenv.add_to_te (check_typbind (typbinds,acontext),
			    tycon,TYSTR
			    (Types.make_tyfun
			     (tyvarseq,check_type (ty,acontext)),
			     empty_valenv)
			    )
d893 1
a893 1
		       acontext as BasisTypes.CONTEXT (level,tyvarset,env,_),
d906 1
a906 1
	     BasisTypes.CONTEXT (level, tyvarset, env, make_tyvarenv tyvars)
a964 3
(*
	 ty_ass := Assemblies.add_to_TypeAssembly (tyfun,conenv,1,!ty_ass);
*)	   
@


1.42
log
@Changes because Assemblies now has Basistypes instead of Datatypes
@
text
@d4 3
a280 1

d670 1
a670 1
	       (if Tyenv.member_of_te_domain (te, tycon)
d680 2
a681 2

		make_dummy_te ((location,t),
d893 1
d904 7
a910 7
	     
	     Tyenv.add_to_te (check_typbind (typbinds,acontext),
			      tycon,TYSTR
			      (Types.make_tyfun
			       (tyvarseq,check_type (ty,acontext)),
			       empty_valenv)
			      )
d992 1
d994 1
a994 1
	   
@


1.41
log
@Changed treatment of Dynamic values
@
text
@d4 3
a193 1
	  Assemblies.Datatypes =
d195 1
@


1.40
log
@Improved error message for rule 27a (val rec ...).
@
text
@d4 3
d205 1
d509 1
a509 1
      | check_exp (Absyn.DYNAMICexp (exp,type_ref), acontext) =
d511 3
d516 2
a517 1
          type_ref := atype;
d540 5
a544 1
	
d590 1
a590 5
	   (if do_debug then
	      debug ["inner_unguarded_tyvars = ",
		     BasisTypes.Set.set_print
		     (inner_unguarded_tyvars,IdentPrint.printTyVar)]
	    else ();
a591 3
	    (BasisTypes.Set.setdiff
	     (inner_unguarded_tyvars, Basis.get_tyvarset acontext)))
	   
d593 1
a593 8
	   (if do_debug then
	      debug ["tyvars_scoped_here = ",
		     BasisTypes.Set.set_print (tyvars_scoped_here,
					  IdentPrint.printTyVar)]
	    else ();
	   
	    (Basis.context_plus_tyvarset_and_tyvarenv
	     (acontext, tyvars_scoped_here)))
d596 5
a600 2
	   check_valbind (avalbindlist1, avalbindlist2, new_context,
			  empty_valenv,[])
a601 4
         val _ =
           if do_debug then
             debug ("expansive_vars = " :: (map IdentPrint.debug_printValId expansive_vars))
           else ()
d609 8
a616 13
	   (if do_debug then
	      debug ["ve before closing = ",
		     Valenv.string_valenv (0,new_VE)]
	    else ();

	    Basis.close (Basis.level acontext,
			 new_VE,expansive_vars,
			 tyvars_scoped_here,true)
	    handle Basis.CloseError (s,ty) =>
                     (report_error
                      (Info.RECOVERABLE, location,
                       implode [s, Completion.print_type(print_options,Basis.env_of_context acontext,ty)]);
                      empty_valenv)
d624 3
a626 14
	   (if do_debug then
	      debug ["ve after closing = ",Valenv.string_valenv (0,VE')]
	    else ();

	    BasisTypes.Set.intersection
	    (tyvars_scoped_here,
	     BasisTypes.Set.list_to_set (Valenv.tyvars VE')))

	 val _ =
	   if do_debug then
	     debug ["intersection = ", 
		    BasisTypes.Set.set_print (foo, IdentPrint.printTyVar)]
	   else ()

d628 1
a628 1
	 if BasisTypes.Set.empty_setp (foo)
d638 1
a638 1
                      (if (Lists.length (BasisTypes.Set.set_to_list foo)) = 1
d641 1
a641 1
                       BasisTypes.Set.set_print (foo, IdentPrint.printTyVar),
@


1.39
log
@Options change
@
text
@d4 3
d879 1
a879 1
                     implode ["Pattern and expression types do not agree",
@


1.38
log
@Options & Info changes
@
text
@d4 3
d269 1
a269 1
    fun check_dec (param as (error_info,print_options)) args =
@


1.37
log
@empty_rec_type to empty_rectype
@
text
@d4 3
d158 1
a158 1
  structure Pat           : PATTERNS
d170 1
a170 1
  sharing Type_exp.BasisTypes = Pat.BasisTypes = Control_Unify.BasisTypes =
d172 3
a174 1
  sharing Completion.Info = IdentPrint.Info = Basis.BasisTypes.Info
d184 1
a184 1
  sharing Type_exp.Absyn = Pat.Absyn
d191 1
a191 1
    structure Absyn = Pat.Absyn
d193 4
a196 1
    structure Info = BasisTypes.Info
d245 1
a245 1
	  Pat.pat_context pat && exp_context exp && match_context rest
d266 1
a266 1
    fun check_dec options args =
d268 1
a268 1
        val report_error  = Info.error options
d270 1
a270 1
        val unify = Control_Unify.unify options
d272 2
a273 2
        val check_pat = Pat.check_pat options
        val check_type = Type_exp.check_type options
d294 1
a294 1
                                  implode ["Unbound value ", IdentPrint.printLongValId options lvalid]);
d347 1
a347 1
                          Completion.print_type (options,Basis.env_of_context acontext, arg),
d349 1
a349 1
                          Completion.print_type (options,Basis.env_of_context acontext, atype)],
d358 1
a358 1
			    Completion.print_type(options,Basis.env_of_context acontext,t)]);
d372 1
a372 1
                                Completion.print_type (options,Basis.env_of_context acontext,t),
d374 1
a374 1
                                Completion.print_type (options,
d387 1
a387 1
			  Completion.print_type(options,Basis.env_of_context acontext,t)]);
d410 1
a410 1
                        Completion.print_type (options,Basis.env_of_context acontext, exp_ty),
d412 1
a412 1
                        Completion.print_type(options,Basis.env_of_context acontext,ty_exp_ty)],
d447 1
a447 1
                          Completion.print_type(options,Basis.env_of_context acontext,arg)],
d458 1
a458 1
                        Completion.print_type (options,Basis.env_of_context acontext,res),
d460 1
a460 1
                        Completion.print_type (options,Basis.env_of_context acontext,exp_ty)],
d482 1
a482 1
                        Completion.print_type (options,Basis.env_of_context acontext,exp_ty)],
d517 1
a517 1
                 (Absyn.Location.UNKNOWN,
d520 1
a520 1
                        Completion.print_type(options,Basis.env_of_context acontext, exp_ty)],
d553 1
a553 1
                       Completion.print_type(options,Basis.env_of_context acontext,atype),
d555 1
a555 1
                       Completion.print_type(options,Basis.env_of_context acontext,ftype)],
d617 1
a617 1
                       implode [s, Completion.print_type(options,Basis.env_of_context acontext,ty)]);
d622 1
a622 1
                       (* implode ["Cannot resolve type of overloaded operator: ",IdentPrint.printValId options valid] *)
d698 1
a698 1
                                   Datatypes.PRESENT(Absyn.Location.to_string location))),
d826 1
a826 1
                        Completion.print_type(options,Basis.env_of_context acontext,aty),
d828 1
a828 1
                        Completion.print_type(options,Basis.env_of_context acontext,atype)],
d875 1
a875 1
                              Completion.print_type(options,Basis.env_of_context acontext,atype),
d877 1
a877 1
                              Completion.print_type (options,Basis.env_of_context acontext,atype')],
d1038 1
a1038 1
	    Completion.print_type (options,Basis.env_of_context acontext,tycon_type)]
d1077 1
a1077 1
                           Completion.print_type(options,Basis.env_of_context acontext,atype)]);
d1112 1
a1112 1
                              implode ["Unbound exception ", IdentPrint.printLongValId options lvalid]);
@


1.36
log
@Changed "free type variables in value declaration" message
@
text
@d4 3
d307 1
a307 1
	   check_rec (arecordlist, Types.empty_rec_type)
@


1.35
log
@Changed Completion interface
Added DYNAMICexp and COERCEexp handling
@
text
@d4 4
d639 7
a645 4
	     "Free type variable(s) " ^ 
	     BasisTypes.Set.set_print (foo, IdentPrint.printTyVar) ^ 
	     " in value declaration");
            Env.empty_env)
@


1.34
log
@Changes for BASISTYPES signature
@
text
@d4 3
d191 1
d198 1
d233 1
d332 1
a332 1
                          Completion.print_type options (Basis.env_of_context acontext) arg,
d334 1
a334 1
                          Completion.print_type options (Basis.env_of_context acontext) atype],
d343 1
a343 1
			    Completion.print_type options (Basis.env_of_context acontext) t]);
d357 1
a357 1
                                Completion.print_type options (Basis.env_of_context acontext) t,
d359 3
a361 1
                                Completion.print_type options (Basis.env_of_context acontext) (FUNTYPE (atype, newmeta))],
d372 1
a372 1
			  Completion.print_type options (Basis.env_of_context acontext) t]);
d375 1
a375 10
	   if do_debug then
	     debug
	     ["in rule 10 tyexp1 = ",
	      Completion.print_type options (Basis.env_of_context acontext) tyexp1,
	      "\nin rule 10 tyexp2 = ",
	      Completion.print_type options (Basis.env_of_context acontext) tyexp2,
	      "\n"]
	   else ();

            (check_fun (tyexp1, tyexp2))
d394 4
a397 2
                        "\n  Expression type: ", Completion.print_type options (Basis.env_of_context acontext) exp_ty,
                        "\n  Constraint type: ", Completion.print_type options (Basis.env_of_context acontext) ty_exp_ty],
d431 2
a432 1
                          "\n  Match type: ", Completion.print_type options (Basis.env_of_context acontext) arg],
d443 1
a443 1
                        Completion.print_type options (Basis.env_of_context acontext) res,
d445 1
a445 1
                        Completion.print_type options (Basis.env_of_context acontext) exp_ty],
d467 1
a467 1
                        Completion.print_type options (Basis.env_of_context acontext) exp_ty],
d483 28
d520 1
a520 5
      (if do_debug then
	 debug ["check_rules\n", 
		Completion.print_type options (Basis.env_of_context acontext) atype]
       else ();
       atype)
d523 5
a527 9
	(if do_debug then
	   debug ["check_rules a \n", 
		  Completion.print_type options (Basis.env_of_context acontext) atype]
	 else ();
	 let 
	   val (new_ve, pat_ty) = check_pat (apat, acontext)
	   val new_context = Basis.context_plus_ve (acontext, new_ve)
	   val exp_ty = check_exp (anexp, new_context)
	   val ftype = FUNTYPE (pat_ty, exp_ty)
d529 12
a540 14
	   val res =
	     unify
	     {
	      first = atype, second = ftype, result = atype,
	      context = acontext,
              error = fn () =>
                (location,
                 implode ["Type disagreement between match rules",
                          "\n  Expected type: ",
                          Completion.print_type options (Basis.env_of_context acontext)
                          atype,
                          "\n  Rule type:     ",
                          Completion.print_type options (Basis.env_of_context acontext)
                          ftype],
d545 1
a545 1
	 end)
d602 1
a602 1
                       implode [s, Completion.print_type options (Basis.env_of_context acontext) ty]);
d808 1
a808 1
                        Completion.print_type options (Basis.env_of_context acontext) aty,
d810 1
a810 1
                        Completion.print_type options (Basis.env_of_context acontext) atype],
d857 1
a857 1
                              Completion.print_type options (Basis.env_of_context acontext) atype,
d859 1
a859 1
                              Completion.print_type options (Basis.env_of_context acontext) atype'],
d1020 1
a1020 1
	    Completion.print_type options (Basis.env_of_context acontext) tycon_type]
d1057 4
a1060 4
		  implode ["Exception binding contains applicative type variable",
			   "\n  Type of exception: ",
			   Completion.print_type options (Basis.env_of_context acontext) atype]);
		 FUNTYPE(imp, Types.exn_type)
@


1.33
log
@Streamlined some functions
Changed for COPYSTR's
@
text
@d4 4
d128 2
a129 3
require "../typechecker/sigma";
require "../typechecker/sigenv";
require "../typechecker/nameset";
d142 1
d146 1
d148 3
d157 5
a161 14
  structure Completion : COMPLETION
  structure Assemblies : ASSEMBLIES
  structure Strenv        : STRENV

  sharing Control_Unify.Info =
	  Type_exp.Info =
	  Pat.Info =
	  Completion.Info =
	  IdentPrint.Info =
	  Pat.Basis.Sigenv.Sigma.Nameset.Info
  sharing Control_Unify.Basis = Pat.Basis
  sharing Control_Unify.Info.Location = Pat.Absyn.Location
  sharing Pat.Absyn.Datatypes =
	  Env.Datatypes =
d168 4
a171 6
	  Strenv.Datatypes =
	  Pat.Basis.Tyvarenv.Datatypes
  sharing Pat.Absyn = Type_exp.Absyn
  sharing Pat.Basis = Type_exp.Basis
  sharing Pat.Basis.Set = Pat.Absyn.Set = Scheme.Set
  sharing IdentPrint.Ident = Valenv.Datatypes.Ident
d175 1
a176 1
    structure Basis = Pat.Basis
d178 1
a178 1
    structure Info = Control_Unify.Info
d539 1
a539 1
		     Basis.Set.set_print
d543 1
a543 1
	    (Basis.Set.setdiff
d549 1
a549 1
		     Basis.Set.set_print (tyvars_scoped_here,
d595 1
a595 1
	    Basis.Set.intersection
d597 1
a597 1
	     Basis.Set.list_to_set (Valenv.tyvars VE')))
d602 1
a602 1
		    Basis.Set.set_print (foo, IdentPrint.printTyVar)]
d606 1
a606 1
	 if Basis.Set.empty_setp (foo)
d616 1
a616 1
	     Basis.Set.set_print (foo, IdentPrint.printTyVar) ^ 
d633 1
a633 1
		   acontext as Basis.CONTEXT (level,tyvarset,
d664 1
a664 1
	     Basis.CONTEXT (level,tyvarset,
d667 1
a667 1
			    Basis.Tyvarenv.empty_tyvarenv)
d727 1
a727 1
	   val Basis.CONTEXT(_, _, E, _) = acontext
d889 1
a889 1
		       acontext as Basis.CONTEXT (level,tyvarset,env,_),
d896 1
a896 1
	       Basis.Tyvarenv.add_to_tyvarenv (level,h,collect(t,amap))
d899 1
a899 1
	     collect (tyvars, Basis.Tyvarenv.empty_tyvarenv)
d902 1
a902 1
	     Basis.CONTEXT (level, tyvarset, env, make_tyvarenv tyvars)
d1086 2
@


1.32
log
@Neatened up error messages so types align.
@
text
@d4 3
d563 4
d727 1
a727 1
      | check_dec (Absyn.OPENdec (strid_list,location), acontext) =
a728 1
	 
d732 1
a732 1
	   fun collect_envs(lstrid, env1) =
d734 1
a734 12
	       val env2 =
		 let
		   val STR (_, env2) = Env.lookup_longstrid (lstrid, E)
		 in
		   env2
		 end
	       handle Env.Lookup_LongStrId =>
                 (report_error
                  (Info.RECOVERABLE, location,
		   implode ["Unbound structure identifier ", 
			    IdentPrint.printLongStrId lstrid]);
                  Env.empty_env)
d736 1
a736 1
	       Env.env_plus_env(env2, env1)
d738 7
d746 1
a746 1
	   Lists.reducer collect_envs(strid_list, Env.empty_env)
d749 1
a749 5
      (***** rule 24 *****)

      | check_dec (Absyn.SEQUENCEdec [],acontext) = 
	(debug ["check_dec 24"];
	 Env.empty_env)
d751 1
a751 3
      (***** rule 25 *****)

      | check_dec (Absyn.SEQUENCEdec (h::t),acontext) =
a752 1
	 
d754 10
a763 5
	   val env1 = check_dec(h,acontext)
	   val env2 = check_dec(Absyn.SEQUENCEdec t,
				Basis.context_plus_env(acontext,env1))      
	 in
	   Env.env_plus_env(env1, env2)
@


1.31
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d327 1
a327 1
                          "\n  Actual argument type: ",
d352 1
a352 1
                                "\n  Actual argument type: ",
d440 1
a440 1
                        "\n  Handler type: ",
d518 1
a518 1
                          "\n  Rule type: ",
d790 1
a790 1
                        "\n  Pattern type: ",
d839 1
a839 1
                              "\n  Pattern type: ",
@


1.30
log
@Error message revision
@
text
@d4 3
a162 1
	  Pat.Absyn.Interface.Datatypes =
d168 1
a168 1
  sharing IdentPrint.Ident = Pat.Absyn.IdentClass
@


1.29
log
@Modified tyenv for efficiency
@
text
@d4 3
d175 1
d319 2
a320 1
                 implode ["\nRequired argument type: ",
d322 1
a322 1
                          "\nActual argument type: ",
d331 1
a331 2
		   implode ["Attempt to apply non-function type",
			    "\nApplied type: ", 
d344 2
a345 2
                       implode ["Circular type",
                                "\nRequired argument type: ",
d347 1
a347 1
                                "\nActual argument type: ",
d358 1
a358 1
			  "\nApplied type:",
d388 5
a392 1
              (location, "Types of expression and constraint do not agree", ty_exp_ty)
d412 1
d423 4
a426 1
                (location, "Match in handler should have argument type exn", Types.exn_type)
d434 2
a435 2
               implode ["Handler disagrees with expression\n",
                        "Handler type: ",
d437 1
a437 1
                        "\nExpression type: ",
d457 5
a461 1
              (location, "Expression raised is not an exception", fresh_tyvar (acontext, false, false))
d509 2
a510 2
                 implode ["Type disagreement between match rules\n",
                          "Expected type: ",
d513 1
a513 1
                          "\nRule type: ",
d578 2
a579 2
                       (* implode ["Unresolved overloaded variable: ",IdentPrint.printValId options valid] *)
                       "Unresolved overloaded variable");
d785 1
a785 1
                        "\nPattern type: ",
d787 1
a787 1
                        "\nExpression type: ", 
d834 1
a834 1
                              "\nType of pattern: ",
d836 1
a836 1
                              "\nType of expression: ",
d1036 1
a1036 1
			   "\nType of exception: ",
@


1.28
log
@Error message improvements
@
text
@d4 3
d615 1
a615 1
	       (if Tyenv.member_of_te_domain (tycon,te)
d617 1
a617 1
		    let val TYSTR (tyfun',conenv') = Tyenv.lookup (tycon,te)
d628 1
a628 1
			       (tycon,
d636 1
a636 2
				 empty_valenv),
				te)))
d845 1
a845 1
	   if Tyenv.member_of_te_domain (tycon,tyenv)
d848 1
a848 1
		 val TYSTR (tyfun,ce) = Tyenv.lookup (tycon,tyenv)
d856 2
a857 1
	     Tyenv.add_to_te (tycon,TYSTR
d860 2
a861 2
			       empty_valenv),
			      check_typbind (typbinds,acontext))
d946 1
a946 1
	  Tyenv.add_to_te (tycon, TYSTR (tyfun, conenv),te),newtype)
@


1.27
log
@Changed handling of overloaded variable errors.
@
text
@d4 3
d312 1
a312 2
                 implode ["Unification failed in rule 10",
                          "\nRequired argument type: ",
d323 3
a325 3
                                implode ["Attempt to apply non-function type in rule 10",
                                         "\nApplied type: ", 
                                         Completion.print_type options (Basis.env_of_context acontext) t]);
d336 7
a342 1
                      (location, "Unification failed in rule 10 (circularity)", fresh_tyvar (acontext, false, false))
d350 4
a353 3
                              implode ["Attempt to apply non-function type in rule 10 \nApplied type:",
                                       Completion.print_type options (Basis.env_of_context acontext) t]);
                fresh_tyvar (acontext, false, false))
d381 1
a381 1
              (location, "Unification failure between expression and constraint in rule 11", ty_exp_ty)
d401 1
a401 1
                (Info.RECOVERABLE, location, "Illegal match in rule 12");
d419 1
a419 1
               implode ["Handler disagrees with expression in rule 12\n",
d442 1
a442 1
              (location, "Expression raised is not an Exception in rule 13", fresh_tyvar (acontext, false, false))
d490 7
a496 1
                 "Type disagreement between match rules in rule 15",
d587 3
a589 1
                          "Free type variable in value declaration");
d714 2
a715 2
                                implode ["Unbound structure identifier", 
                                         IdentPrint.printLongStrId lstrid]);
d766 1
a766 1
               implode ["Pattern and expression types do not unify in rule 26",
d815 2
a816 2
                     implode ["Pattern and expression types do not unify in rule 27\n",
                              "Type of pattern: ",
d1011 2
a1012 1
		 val imp = fresh_tyvar(acontext, false, true)
d1016 4
a1019 3
                               implode ["Exception binding with applicative type in rule 31\nType of exception: ",
                                        Completion.print_type options (Basis.env_of_context acontext) atype]);
                 FUNTYPE(imp, Types.exn_type)
@


1.26
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d537 10
a546 5
              (report_error
               (Info.RECOVERABLE, location,
                             implode [s, Completion.print_type options (Basis.env_of_context acontext) ty]);
               empty_valenv))

@


1.25
log
@Changed Error structure to Info
@
text
@d4 3
d102 3
d131 6
a136 1
  sharing Control_Unify.Info = Type_exp.Info = Pat.Info
d139 11
a149 4
  sharing Pat.Absyn.Datatypes = Env.Datatypes
    = Tyenv.Datatypes = Types.Datatypes = Completion.Datatypes
    = Valenv.Datatypes = Scheme.Datatypes = Assemblies.Datatypes = Pat.Absyn.Interface.Datatypes
    = Strenv.Datatypes = Pat.Basis.Tyvarenv.Datatypes
d154 1
a154 1
    ) : CORE_RULES =
d254 1
a254 1
                                  implode ["Unbound value ", IdentPrint.printLongValId lvalid]);
d307 1
a307 1
                          Completion.print_type (Basis.env_of_context acontext) arg,
d309 1
a309 1
                          Completion.print_type (Basis.env_of_context acontext) atype],
d319 1
a319 1
                                         Completion.print_type (Basis.env_of_context acontext) t]);
d339 1
a339 1
                                       Completion.print_type (Basis.env_of_context acontext) t]);
d345 1
a345 1
	      Completion.print_type (Basis.env_of_context acontext) tyexp1,
d347 1
a347 1
	      Completion.print_type (Basis.env_of_context acontext) tyexp2,
d408 1
a408 1
                        Completion.print_type (Basis.env_of_context acontext) res,
d410 1
a410 1
                        Completion.print_type (Basis.env_of_context acontext) exp_ty],
d455 1
a455 1
		Completion.print_type (Basis.env_of_context acontext) atype]
d462 1
a462 1
		  Completion.print_type (Basis.env_of_context acontext) atype]
d535 1
a535 1
                             implode [s, Completion.print_type (Basis.env_of_context acontext) ty]);
d742 1
a742 1
                        Completion.print_type (Basis.env_of_context acontext) aty,
d744 1
a744 1
                        Completion.print_type (Basis.env_of_context acontext) atype],
d791 1
a791 1
                              Completion.print_type (Basis.env_of_context acontext) atype,
d793 1
a793 1
                              Completion.print_type (Basis.env_of_context acontext) atype'],
d951 1
a951 1
	    Types.string_tyfun_using_default tyfun,
d953 1
a953 1
	    Completion.print_type (Basis.env_of_context acontext) tycon_type]
d990 1
a990 1
                                        Completion.print_type (Basis.env_of_context acontext) atype]);
d1025 1
a1025 1
                              implode ["Unbound exception ", IdentPrint.printLongValId lvalid]);
@


1.24
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d125 1
d127 1
a127 1
  sharing Control_Unify.Error.Location = Pat.Absyn.Location
d142 1
a142 1
    structure Error = Control_Unify.Error
a206 6
    (***** rule 1 *****)
      
    fun check_exp (Absyn.SCONexp scon,_) =
      (if do_debug then
	 debug ["check_exp 1", IdentPrint.printSCon scon]
       else ();
d208 17
a224 1
       (Types.type_of scon))
d226 16
a241 16
      (***** rule 2,3,4 *****)      
      | check_exp (Absyn.VALexp (lvalid as Ident.LONGVALID (apath,aval),
				 type_ref,location),acontext) =
	(debug ["check_exp 2,3,4"];

	 let
	   val atype = Basis.lookup_val (apath,aval,acontext)
	     handle Basis.LookupValId_in_Context =>
               (Error.report
                (Error.ERROR (Error.RECOVERABLE, location,
                              implode ["Unbound value ", IdentPrint.printLongValId lvalid]));
                fresh_tyvar (acontext, false, false))
	 in
	   type_ref := atype;
	   atype
	 end)
d281 1
a281 1
	     Control_Unify.unify
d297 2
a298 2
                 (Error.report
                  (Error.ERROR (Error.RECOVERABLE, location,
d301 1
a301 1
                                         Completion.print_type (Basis.env_of_context acontext) t]));
d307 1
a307 1
		   Control_Unify.unify
d318 2
a319 2
               (Error.report
                (Error.ERROR (Error.RECOVERABLE, location,
d321 1
a321 1
                                       Completion.print_type (Basis.env_of_context acontext) t]));
d343 1
a343 1
	   val ty_exp_ty = Type_exp.check_type (ty, acontext)
d345 1
a345 1
	   Control_Unify.unify
d369 2
a370 2
               (Error.report
                (Error.ERROR (Error.RECOVERABLE, location, "Illegal match in rule 12"));
d375 1
a375 1
	   val ? = Control_Unify.unify
d383 1
a383 1
	   Control_Unify.unify
d405 1
a405 1
	   Control_Unify.unify
d447 1
a447 1
	   val (new_ve, pat_ty) = Pat.check_pat (apat, acontext)
d453 1
a453 1
	     Control_Unify.unify
d515 3
a517 3
              (Error.report
               (Error.ERROR (Error.RECOVERABLE, location,
                             implode [s, Completion.print_type (Basis.env_of_context acontext) ty]));
d543 3
a545 3
           (Error.report
            (Error.ERROR (Error.RECOVERABLE, location,
                          "Free type variable in value declaration"));
d668 2
a669 2
                 (Error.report
                  (Error.ERROR (Error.RECOVERABLE, location,
d671 1
a671 1
                                         IdentPrint.printLongStrId lstrid]));
d713 1
a713 1
	   val (newve, aty) = Pat.check_pat (apat, acontext)
d716 1
a716 1
	   Control_Unify.unify
d744 1
a744 1
	 val (newve, aty) = Pat.check_pat (apat, acontext)
d765 1
a765 1
		 Control_Unify.unify
d812 1
a812 1
			       (tyvarseq,Type_exp.check_type (ty,acontext)),
d845 1
a845 1
	      (fn x => Type_exp.check_type (Absyn.TYVARty x,new_context))
d939 1
a939 1
	   val atype = Type_exp.check_type (aty,acontext) 
d960 1
a960 1
	   val atype = Type_exp.check_type (aty, acontext)
d969 2
a970 2
                 Error.report
                 (Error.ERROR (Error.RECOVERABLE, location,
d972 1
a972 1
                                        Completion.print_type (Basis.env_of_context acontext) atype]));
d1005 3
a1007 3
               (Error.report
                (Error.ERROR (Error.RECOVERABLE, location,
                              implode ["Unbound exception ", IdentPrint.printLongValId lvalid]));
d1016 3
@


1.23
log
@Changed some Errors to Crashes.
@
text
@d4 3
d552 2
a553 2
	   fun make_dummy_te ([],te) = te
	     | make_dummy_te ((tyvars,tycon,_,conbinds)::t,te) = 
d565 1
a565 1
		make_dummy_te (t,
d573 2
a574 1
				   IdentPrint.printTyCon tycon)),
d604 1
a604 1
      | check_dec (Absyn.ABSTYPEdec (adatbindlist, dec), acontext) =
d609 1
a609 1
	     check_dec (Absyn.DATATYPEdec adatbindlist, acontext)
d805 1
a805 1
    and check_datbind ([],_,(ve,te)) =
d809 1
a809 1
      | check_datbind ((tyvars,tycon,type_ref,conbind)::datbinds,
d846 1
a846 1
	   (datbinds,
d919 1
a919 1
	    Types.string_tyfun tyfun,
@


1.22
log
@Installed central error reporting mechanism.
@
text
@d4 3
d486 1
a486 1
            | _ => Error.Location.UNKNOWN)
d823 1
a823 3
               Error.report'
               (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN,
                             implode ["Unbound type constructor ", IdentPrint.printTyCon tycon]))
@


1.21
log
@Made some changes to the NewMap signature.
@
text
@d4 3
d116 2
a117 1
  sharing Control_Unify.Errors.Basis = Pat.Basis
a127 1
    structure Errors = Control_Unify.Errors
d132 1
d169 1
a169 1
	| exp_context (Absyn.RAISEexp (exp,marks)) =
a198 12
    val circ_error =
      ["unification failed in rule 10 (circularity)"]

    val rule11_fail =
      ["unification failure between expression and constraint in rule 11"]

    val rule12_fail =
      ["Match in handler should have argument type exn"]

    val rule13_fail =
      ["expression raised is not an Exception in rule 13"]

d208 1
a208 1
				 type_ref,marks),acontext) =
d214 4
a217 5
	       Errors.announce_error acontext Errors.return_alpha
	       [Absyn.Source_marks_to_string marks,
                " unbound value ",
		IdentPrint.printLongValId lvalid,
		" in expression\n"]
d251 1
a251 1
      | check_exp (Absyn.APPexp (exp1, exp2,marks,argument_type), acontext) =
d264 9
a272 9
	      context = acontext ,
	      get_action = fn () => Errors.return_alpha,
	      get_error_messages = fn () =>
	      [Absyn.Source_marks_to_string marks,
               " unification failed in rule 10",
	       "\nRequired argument type : ",
	       Completion.print_type (Basis.env_of_context acontext) arg,
	       "\nActual argument type : ",
	       Completion.print_type (Basis.env_of_context acontext) atype]
d277 6
a282 6
		 Errors.announce_error acontext Errors.return_alpha
		 [Absyn.Source_marks_to_string marks,
                  " attempt to apply non-function type in rule 10",
		  "\nApplied type : ", 
		  (Completion.print_type (Basis.env_of_context acontext) t),
		  "\n"]
d291 3
a293 3
		    get_action = fn () => Errors.return_alpha,
		    get_error_messages = fn() => ((Absyn.Source_marks_to_string marks) :: circ_error)
		    }
d298 5
a302 6
	       Errors.announce_error acontext Errors.return_alpha
	       [Absyn.Source_marks_to_string marks,
                " attempt to apply non-function type in rule 10",
		"\nApplied type : ", 
		(Completion.print_type (Basis.env_of_context acontext) t),
		"\n"]
d318 1
a318 1
      | check_exp (Absyn.TYPEDexp (exp, ty,marks), acontext) =
a323 2
	     
	   fun return_value () = Errors.return_val ty_exp_ty
d329 3
a331 3
	    get_action = return_value,
	    get_error_messages = fn () => ((Absyn.Source_marks_to_string marks) :: rule11_fail)
	    }
d338 1
a338 1
      | check_exp (Absyn.HANDLEexp (exp,type_ref,match,marks,_), acontext) =
d349 3
a351 5
	       (Errors.announce_error acontext
		Errors.return_alpha
		[Absyn.Source_marks_to_string marks,
                 " illegal match in rule 12 \n"],
	       fresh_tyvar(acontext, false, false))
d353 1
a353 1
	   val (arg, res) = check_fun (check_match (match, acontext,marks))
d359 3
a361 5
	      get_action = fn () => Errors.return_val Types.exn_type,
	      get_error_messages = fn () => ((Absyn.Source_marks_to_string marks) :: rule12_fail)
	      }
	     
	   fun return_value () = Errors.return_val res
d366 8
a373 10
	    get_action = return_value,
	    get_error_messages = fn () =>
	    [Absyn.Source_marks_to_string marks,
             " handler disagrees with expression in rule 12\n",
	     "Handler type : ",
	     Completion.print_type (Basis.env_of_context acontext) res,
	     "\n",
	     "Expression type : ",
	     Completion.print_type (Basis.env_of_context acontext) exp_ty,
	     "\n"]
d379 1
a379 1
      | check_exp (Absyn.RAISEexp (exp,marks), acontext) =
d390 2
a391 2
	    get_action = fn () => Errors.return_alpha,
	    get_error_messages = fn () => ((Absyn.Source_marks_to_string marks) :: rule13_fail)
d397 1
a397 1
      | check_exp (Absyn.FNexp (amatch,type_ref,_,marks), acontext) =
d401 1
a401 1
	   val atype = check_match (amatch, acontext,marks)
d409 1
a409 1
    and check_match (matches, acontext,marks) =
d412 1
a412 1
       (matches, acontext, fresh_tyvar(acontext, false, false),marks))
d421 1
a421 1
      | check_rules ((apat, anexp) :: rules, acontext, atype,marks) =
a431 2
	   fun return_value () = Errors.return_val atype

d437 4
a440 8
	      get_action = return_value,
	      get_error_messages = fn () =>
	      [Absyn.Source_marks_to_string marks,
               "type disagreement between match rules in rule 15",
	       "\nCannot unify \n",
	       Completion.print_type (Basis.env_of_context acontext) atype,
	       "\nand\n",
	       Completion.print_type (Basis.env_of_context acontext) ftype]
d443 1
a443 1
	   check_rules (rules, acontext, res,marks)
d479 1
a479 1
         val error_position =
d481 3
a483 3
              ((_,_,marks)::_,_) => Absyn.Source_marks_to_string marks
            | (_,(_,_,marks)::_) => Absyn.Source_marks_to_string marks
            | _ => "")
d494 5
a498 5
	    handle Basis.CloseError (s,ty) => 
	      Errors.announce_error acontext 
	      (Errors.return_val empty_valenv)
	      [error_position,s,(Completion.print_type (Basis.env_of_context acontext) ty),
	       "\n"])
d523 4
a526 3
             Errors.announce_error acontext
             (Errors.return_val Env.empty_env)
             [error_position," free type variable in value declaration\n"]
d632 1
a632 1
      | check_dec (Absyn.OPENdec (strid_list,marks), acontext) =
d647 5
a651 5
		 Errors.announce_error acontext
		 (Errors.return_val Env.empty_env)
		 [Absyn.Source_marks_to_string marks,
                  " unbound structure identifier ",
		  IdentPrint.printLongStrId lstrid, "\n"]
d687 1
a687 1
      | check_valbind ((apat,anexp,marks)::valbinds,
a693 2
	     
	   fun return_value () = Errors.return_val aty
d699 8
a706 8
	    get_action = return_value,
	    get_error_messages = fn () =>
	    [Absyn.Source_marks_to_string marks,
             " pattern and expression types do not unify in rule 26",
	     "\nPattern type : ",
	     Completion.print_type (Basis.env_of_context acontext) aty,
	     "\nExpression type : ", 
	     Completion.print_type (Basis.env_of_context acontext) atype]
d718 1
a718 1
    and check_recvalbind ((apat,anexp,marks)::recvalbind,acontext,ve,
d731 1
a731 1
			     ((aty,anexp,marks)::ty_exp))
d740 1
a740 1
	   fun f (atype, anexp,marks) = 
d748 8
a755 10
		  get_action = fn () => Errors.return_val atype,
		  get_error_messages = fn () =>
		  [Absyn.Source_marks_to_string marks,
                   " pattern and expression types do not unify in rule 27\n",
		   "Type of pattern : ",
		   Completion.print_type (Basis.env_of_context acontext) atype,
		   "\nType of expression : ",
		   Completion.print_type 
		   (Basis.env_of_context acontext) atype',
		   "\n"]
d819 4
a822 4
	     handle Basis.LookupTyCon => 
	       (Print.print ("Type error : unbound type constructor " ^ 
			     (IdentPrint.printTyCon tycon) ^ "\n");
		raise Errors.Stop_compilation)
d936 1
a936 1
					   Absyn.PRESENT aty,marks,_))::restbinds,
d950 5
a954 8
		 Errors.announce_error acontext
		 (Errors.return_val (FUNTYPE(imp, Types.exn_type)))
		 [Absyn.Source_marks_to_string marks,
                  " exception binding with applicative type in rule 31",
		  "\nType of exception : ",
		  (Completion.print_type 
		   (Basis.env_of_context acontext) atype),
		  "\n"]
d966 1
a966 1
					   Absyn.ABSENT,marks,_))::restbinds,
d979 1
a979 1
			  lvalid as Ident.LONGVALID (apath,anoldexcon),marks,_)
d985 5
a989 6
	     handle Basis.LookupValId_in_Context => 
	       Errors.announce_error acontext
	       (Errors.return_val Types.exn_type)
	       [Absyn.Source_marks_to_string marks,
                " unbound exception ", IdentPrint.printLongValId lvalid,
		" in expression\n"]
@


1.20
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d132 2
d604 1
a604 1
	   fun max_eq_pred (TYSTR (atyfun,VE (_,amap))) =
d606 1
a606 1
	       NewMap.forall Scheme.equalityp amap orelse 
d612 1
a612 2
	     while not (NewMap.forall max_eq_pred amap)
	       do ()
@


1.19
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d70 1
d89 1
d109 3
a111 2
  sharing Pat.Absyn.Datatypes = Pat.Datatypes = Control_Unify.Datatypes = Env.Datatypes
    = Tyenv.Datatypes = Types.Datatypes = Type_exp.Datatypes = Completion.Datatypes
d113 1
a113 1
    = Strenv.Datatypes
d115 1
a115 2
  sharing Pat.Basis = Type_exp.Basis = Control_Unify.Basis
  sharing Pat.Basis.Sigma.Nameset = Pat.Absyn.Nameset
d117 1
a117 1
  sharing Pat.Datatypes.IdentPrint.Ident = Pat.Absyn.IdentClass
d121 1
a121 3
    structure Datatypes = Pat.Datatypes
    structure Ident = Datatypes.IdentPrint.Ident
    structure Mapping = Errors.Datatypes.Mapping
d599 3
a601 7
  	     if Types.equalityp atyfun
	       then
		 if Lists.forall Scheme.equalityp (NewMap.range amap)
		   then
		     true
		 else 
		   Types.make_false atyfun
d606 1
a606 1
	     while not (Lists.forall max_eq_pred (NewMap.range amap))
@


1.18
log
@Removed various redundant structure arguments.
@
text
@d63 1
a66 1
require "../basics/identprint";
d72 1
d76 1
a78 1
require "../typechecker/control_unify";
a84 1
  structure IdentPrint    : IDENTPRINT
d102 1
d107 1
d112 1
a112 1
  sharing IdentPrint.Ident = Pat.Absyn.IdentClass
d116 2
a117 1
    structure Ident = IdentPrint.Ident
a118 1
    structure Datatypes = Pat.Datatypes
a121 1

d138 1
a138 1
	Valenv.add_to_ve (valid, ts, Valenv.empty_valenv)
d141 1
a141 1
	  Valenv.empty_valenv
d147 1
a147 1
	  (Valenv.empty_valenv, fields)
d163 1
a163 1
      and match_context [] = Valenv.empty_valenv
d492 1
a492 1
			  Valenv.empty_valenv,[])
d511 1
a511 1
	      (Errors.return_val Valenv.empty_valenv)
d533 1
a533 1
	     ENV (SE Mapping.empty_map,
d536 1
a536 1
		  Valenv.empty_valenv)
d547 1
a547 1
	   (ENV (SE Mapping.empty_map,
d549 2
a550 2
		 Valenv.empty_valenv,
		 Valenv.empty_valenv)))
d582 1
a582 1
				 Valenv.empty_valenv),
d593 1
a593 14
						(Valenv.empty_valenv,
						 Tyenv.empty_tyenv))
	   fun max_eq_pred(TYSTR(atyfun,VE (_,aconenv))) =
	     (if Types.equalityp atyfun
		then
		  if Mapping.forall
		    (aconenv,
		     Scheme.equalityp)
		    then
		      true
		  else 
		    Types.make_false atyfun
	      else
		true)
d595 11
d607 2
a608 4
	     while 
	       not (Mapping.forall(amap, max_eq_pred))
	       do
	       ()
d611 1
a611 1
	    ENV (SE Mapping.empty_map,new_te,new_ve,Valenv.empty_valenv))
d635 1
a635 1
	   ENV (SE Mapping.empty_map, Tyenv.empty_tyenv, newve, newve)
d815 1
a815 1
			       Valenv.empty_valenv),
d859 1
a859 1
							 Valenv.empty_valenv,
d957 1
a957 1
    and check_exconbind ([],_) = Valenv.empty_valenv
@


1.17
log
@Appexp are annotated with their types
@
text
@d4 3
a65 3
require "../utils/map";
require "../basics/symbol";
require "../basics/ident";
a66 1
require "../basics/absyn";
a67 1
require "../typechecker/datatypes";
a72 1
require "../typechecker/basis";
a74 1
require "../typechecker/errors";
a83 3
  structure Mapping : MAP
  structure Symbol        : SYMBOL
  structure Ident         : IDENT
a84 1
  structure Absyn         : ABSYN
a85 1
  structure Datatypes     : DATATYPES
a90 1
  structure Basis         : BASIS
a99 4
  structure Errors : ERRORS
  sharing Errors.Datatypes = Datatypes
  and Errors.Basis         = Basis

a100 2
  sharing Completion.Datatypes = Datatypes

d103 8
a110 11
  sharing Datatypes = Absyn.Datatypes = Basis.Datatypes
    = Pat.Datatypes = Control_Unify.Datatypes = Env.Datatypes
    = Tyenv.Datatypes = Types.Datatypes = Type_exp.Datatypes
    = Valenv.Datatypes = Scheme.Datatypes = Assemblies.Datatypes
  sharing Absyn = Pat.Absyn = Type_exp.Absyn
  sharing Basis = Pat.Basis = Type_exp.Basis = Control_Unify.Basis
  sharing Errors = Control_Unify.Errors
  sharing Basis.Set = Absyn.Set = Scheme.Set
  sharing Ident = IdentPrint.Ident = Absyn.IdentClass
  sharing Symbol = Ident.Symbol
  sharing type Ident.Symbol.Symbol = Symbol.Symbol
d113 6
a118 4

    structure Datatypes = Datatypes
    structure Absyn = Absyn
    structure Basis = Basis
@


1.16
log
@Added debug info to handlers so need to ignore this extra slot
@
text
@d4 3
d166 1
a166 1
	| exp_context (Absyn.APPexp (exp1, exp2,_)) =
d267 1
a267 1
      | check_exp (Absyn.APPexp (exp1, exp2,marks), acontext) =
d273 2
@


1.15
log
@Added some marks for error messages
@
text
@d4 3
d974 1
a974 1
					   Absyn.PRESENT aty,marks))::restbinds,
d1007 1
a1007 1
					   Absyn.ABSENT,marks))::restbinds,
d1020 1
a1020 1
			  lvalid as Ident.LONGVALID (apath,anoldexcon),marks)
@


1.14
log
@Adjusted to give better error position reporting now marks have been added
@
text
@d4 3
d164 1
a164 1
	| exp_context (Absyn.HANDLEexp (exp,_,match,_)) =
d168 1
a168 1
	| exp_context (Absyn.FNexp (match,_,_)) =
d349 1
a349 1
      | check_exp (Absyn.HANDLEexp (exp,type_ref,match,marks), acontext) =
d366 1
a366 1
	   val (arg, res) = check_fun (check_match (match, acontext))
d414 1
a414 1
      | check_exp (Absyn.FNexp (amatch,type_ref,_), acontext) =
d418 1
a418 1
	   val atype = check_match (amatch, acontext)
d426 1
a426 1
    and check_match (matches, acontext) =
d429 1
a429 1
       (matches, acontext, fresh_tyvar(acontext, false, false)))
d431 1
a431 1
    and check_rules ([], acontext, atype) =
d438 1
a438 1
      | check_rules ((apat, anexp) :: rules, acontext, atype) =
d458 2
a459 1
	      ["type disagreement between match rules in rule 15",
d466 1
a466 1
	   check_rules (rules, acontext, res)
@


1.13
log
@Made a number of efficiency improvements
@
text
@d4 3
d149 1
a149 1
	| exp_context (Absyn.VALexp (Ident.LONGVALID (_, valid), ref ty)) =
d157 1
a157 1
	| exp_context (Absyn.APPexp (exp1, exp2)) =
d159 1
a159 1
	| exp_context (Absyn.TYPEDexp (exp, _)) =
d161 1
a161 1
	| exp_context (Absyn.HANDLEexp (exp,_,match)) =
d163 1
a163 1
	| exp_context (Absyn.RAISEexp (exp)) =
a166 2
	| exp_context (Absyn.TEN15exp _) =
	  Crash.impossible"exp_context (Absyn.TEN15exp _)"
d193 1
a193 1
    fun circ_error () =
d196 1
a196 1
    fun rule11_fail () =
d199 1
a199 1
    fun rule12fail () =
d202 1
a202 1
    fun rule13_fail () =
d214 1
a214 1
				 type_ref),acontext) =
d221 2
a222 1
	       ["unbound value ",
d258 1
a258 1
      | check_exp (Absyn.APPexp (exp1, exp2), acontext) =
d272 2
a273 1
	      ["unification failed in rule 10",
d283 2
a284 1
		 ["attempt to apply non-function type in rule 10",
d297 1
a297 1
		    get_error_messages = circ_error
d304 2
a305 1
	       ["attempt to apply non-function type in rule 10",
d324 1
a324 1
      | check_exp (Absyn.TYPEDexp (exp, ty), acontext) =
d338 1
a338 1
	    get_error_messages = rule11_fail
d346 1
a346 1
      | check_exp (Absyn.HANDLEexp (exp,type_ref,match), acontext) =
d359 2
a360 1
		["illegal match in rule 12 \n"],
d370 1
a370 1
	      get_error_messages = rule12fail
d380 2
a381 1
	    ["handler disagrees with expression in rule 12\n",
d393 1
a393 1
      | check_exp (Absyn.RAISEexp (exp), acontext) =
d405 1
a405 1
	    get_error_messages = rule13_fail
a420 3
      | check_exp(Absyn.TEN15exp _, _) =
	Crash.impossible"check_exp(Absyn.TEN15exp _)"

d498 6
d516 1
a516 1
	      [s,(Completion.print_type (Basis.env_of_context acontext) ty),
d542 3
a544 3
	   Errors.announce_error acontext
	   (Errors.return_val Env.empty_env)
	   ["free type variable in value declaration\n"]
d659 1
a659 1
      | check_dec (Absyn.OPENdec strid_list, acontext) =
d676 2
a677 1
		 ["unbound structure identifier ",
d714 1
a714 1
      | check_valbind ((apat,anexp)::valbinds,
d730 2
a731 1
	    ["pattern and expression types do not unify in rule 26",
d747 1
a747 1
    and check_recvalbind ((apat,anexp)::recvalbind,acontext,ve,
d760 1
a760 1
			     ((aty,anexp)::ty_exp))
d769 1
a769 1
	   fun f (atype, anexp) = 
d779 2
a780 1
		  ["pattern and expression types do not unify in rule 27\n",
d967 1
a967 1
					   Absyn.PRESENT aty))::restbinds,
d983 2
a984 1
		 ["exception binding with applicative type in rule 31",
d1000 1
a1000 1
					   Absyn.ABSENT))::restbinds,
d1013 1
a1013 1
			  lvalid as Ident.LONGVALID (apath,anoldexcon))
d1022 2
a1023 1
	       ["unbound exception ", IdentPrint.printLongValId lvalid,
@


1.12
log
@Made some efficiency improvements
@
text
@d4 3
d129 1
a129 1
    fun fresh_tyvar acontext eq imp =
d192 12
d205 3
a207 1
      (debug ["check_exp 1", IdentPrint.printSCon scon];
d286 1
a286 1
		   val newmeta = fresh_tyvar acontext false imp
d293 1
a293 2
		    get_error_messages = fn () =>
		    ["unification failed in rule 10 (circularity)"]
d305 8
a312 6
	   debug
	   ["in rule 10 tyexp1 = ",
	    Completion.print_type (Basis.env_of_context acontext) tyexp1,
	    "\nin rule 10 tyexp2 = ",
	    Completion.print_type (Basis.env_of_context acontext) tyexp2,
	    "\n"];
d333 1
a333 2
	    get_error_messages = fn () =>
	    ["unification failure between expression and constraint in rule 11"]
d355 1
a355 1
	       fresh_tyvar acontext false false)
d364 1
a364 2
	      get_error_messages = fn () =>
	      ["Match in handler should have argument type exn"]
d395 2
a396 1
	    result = fresh_tyvar acontext false false, context = acontext,
d398 1
a398 2
	    get_error_messages = fn () =>
	    ["expression raised is not an Exception in rule 13"]
d422 1
a422 1
       (matches, acontext, fresh_tyvar acontext false false))
d519 4
a522 2
	   debug ["intersection = ", 
		  Basis.Set.set_print (foo, IdentPrint.printTyVar)]
d540 5
a544 5
	(debug ["check_dec 18"];
	 (ENV (SE Mapping.empty_map,
	       check_typbind (atypbind,acontext),
	       Valenv.empty_valenv,
	       Valenv.empty_valenv)))
d589 13
d604 1
a604 16
	       not (Mapping.forall
		    (amap,
		     fn (TYSTR
			 (atyfun,VE (_,aconenv)))
		     =>
		       (if Types.equalityp atyfun
			  then
			    if Mapping.forall
			      (aconenv,
			       Scheme.equalityp)
			      then
				true
			    else 
			      Types.make_false atyfun
			else
			  true)))
d655 1
a655 1
	   fun collect_envs lstrid env1 =
d660 3
a662 1
		 in env2 end
d672 1
a672 1
	   Lists.foldr collect_envs Env.empty_env strid_list
d952 1
a952 1
    and check_exconbind ([],acontext) = Valenv.empty_valenv
d966 1
a966 1
		 val imp = fresh_tyvar acontext false true
@


1.11
log
@First version of the profiler
@
text
@d4 3
d146 3
a148 3
	  Lists.foldl
	  (fn (_, exp) => fn res => exp_context exp && res)
	  Valenv.empty_valenv fields
d247 12
a258 17
	    let
	      fun return_value () = Errors.return_val atype
	    in
	      Control_Unify.unify
	      {
	       first = arg, second = atype, result = res,
	       context = acontext ,
(*	       get_action = return_value, *)
	       get_action = fn () => Errors.return_alpha,
	       get_error_messages = fn () =>
	       ["unification failed in rule 10",
		"\nRequired argument type : ",
		Completion.print_type (Basis.env_of_context acontext) arg,
		"\nActual argument type : ",
		Completion.print_type (Basis.env_of_context acontext) atype]
	       }
	    end
d409 4
a412 2
      (debug ["check_rules\n", 
	      Completion.print_type (Basis.env_of_context acontext) atype];
d416 4
a419 2
	(debug ["check_rules a \n", 
		Completion.print_type (Basis.env_of_context acontext) atype];
d455 5
a459 3
	   (debug ["inner_unguarded_tyvars = ",
		   Basis.Set.set_print
		   (inner_unguarded_tyvars,IdentPrint.printTyVar)];
d465 5
a469 3
	   (debug ["tyvars_scoped_here = ",
		   Basis.Set.set_print (tyvars_scoped_here,
					IdentPrint.printTyVar)];
d479 4
a482 2
	   (debug ["ve before closing = ",
		   Valenv.string_valenv (0,new_VE)];
d494 3
a496 1
	   (debug ["ve after closing = ",Valenv.string_valenv (0,VE')];
d739 1
a739 1
	   fun f (atype, anexp) () = 
d761 1
a761 1
	   val ? = Lists.foldl f () ty_exp
d911 7
a917 5
	(debug
	 ["check_conbind 30b \n tyfun =",
	  Types.string_tyfun tyfun,
	  " tycon_type = ",
	  Completion.print_type (Basis.env_of_context acontext) tycon_type];
@


1.10
log
@Removed on the fly calculation of valenv for METATYNAMEs. This is
now done properly during signature elaboration in _mod_rules,
and encoded in the .mo files
@
text
@d4 5
d154 1
a154 1
	| exp_context (Absyn.RAISEexp (exp,_)) =
d372 1
a372 1
      | check_exp (Absyn.RAISEexp (exp,_), acontext) =
@


1.9
log
@Fixed bug in rule 15 whereby wrong context was supplied to
subsequent matches. Fixed spurious error messages in rule 10 by
supplying a return value of alpha for the failure case
@
text
@d4 5
a199 37
	   (case aval of
	      Ident.CON _ =>
		let
		  val ty = case atype of
		    Datatypes.FUNTYPE(_, ty) => ty
		  | Datatypes.CONSTYPE _ => atype
		  | _ => Crash.impossible"CON id is not constructed type(1)"
		  val valenv as Datatypes.VE(_, the_map) =
		    case ty of
		      Datatypes.CONSTYPE
		      (_, Datatypes.TYNAME{5=ref valenv, ...}) =>
			valenv
		    | Datatypes.CONSTYPE
		      (_, Datatypes.METATYNAME{2=str, 5=r as ref ve, ...}) =>
			let
			  val Datatypes.ENV(_, te, _, _) =
			    Ident.followPath
			    Env.find_env (apath, Basis.env_of_context acontext)
			  val Datatypes.TYSTR(_, valenv) =
			    Tyenv.lookup(Ident.TYCON(Symbol.find_symbol str),
					 te)
			in
			  (r := valenv;
			   valenv)
			end
		    | _ => Crash.impossible"CON id is not constructed type(2)"
		in
		  ()
		  (*
		  Print.print"Found valenv with valids\n";
		  Lists.iterate
		  (fn (v, _) => Print.print(IdentPrint.printValId v ^ "\n"))
		  (Mapping.assoc the_map)
		   *)
		end
	    | _ => ());

@


1.8
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d278 2
a279 1
	       get_action = return_value,
d467 1
a467 1
	   check_rules (rules, new_context, res)
@


1.7
log
@Updated to calculate the valenv for METATYNAMES in VALpat and APPpat
@
text
@d4 3
d36 1
d52 25
a76 24
functor Core_rules
  (structure Print : PRINT
   structure Lists : LISTS
   structure Crash : CRASH
   structure Mapping : MAP
   structure Symbol        : SYMBOL
   structure Ident         : IDENT
   structure IdentPrint    : IDENTPRINT
   structure Absyn         : ABSYN
   structure Datatypes     : DATATYPES
   structure Types         : TYPES
   structure Scheme        : SCHEME
   structure Valenv        : VALENV
   structure Tyenv         : TYENV
   structure Env           : ENVIRONMENT
   structure Basis         : BASIS
   structure Type_exp      : TYPE_EXP
   structure Pat           : PATTERNS
   structure Control_Unify : CONTROL_UNIFY
   structure Debug :
     sig
       val set_debug_level : int -> unit
       val debug_level     : unit -> int
     end
d78 3
a80 3
   structure Errors : ERRORS
   sharing Errors.Datatypes = Datatypes
   and Errors.Basis         = Basis
d82 2
a83 2
   structure Completion : COMPLETION
   sharing Completion.Datatypes = Datatypes
d85 1
a85 1
   structure Assemblies : ASSEMBLIES
d87 12
a98 12
   sharing Datatypes = Absyn.Datatypes = Basis.Datatypes
     = Pat.Datatypes = Control_Unify.Datatypes = Env.Datatypes
     = Tyenv.Datatypes = Types.Datatypes = Type_exp.Datatypes
     = Valenv.Datatypes = Scheme.Datatypes = Assemblies.Datatypes
   sharing Absyn = Pat.Absyn = Type_exp.Absyn
   sharing Basis = Pat.Basis = Type_exp.Basis = Control_Unify.Basis
   sharing Errors = Control_Unify.Errors
   sharing Basis.Set = Absyn.Set = Scheme.Set
   sharing Ident = IdentPrint.Ident = Absyn.IdentClass
   sharing Symbol = Ident.Symbol
   sharing type Ident.Symbol.Symbol = Symbol.Symbol
     ) : CORE_RULES =
d106 1
d159 6
a164 10
    local
      fun print_list [] = Print.print "\n"
	| print_list (h :: t) = (Print.print h ; print_list t)
    in
      fun debug L =
	if Debug.debug_level () > 10 then
	  (print_list L)
	else
	  ()
    end
@


1.6
log
@Removed last argument to calls to make_tyname
@
text
@d4 3
d28 4
d52 4
d90 3
d189 37
@


1.5
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_core_rules.sml,v $
d516 1
a516 2
				   IdentPrint.printTyCon tycon,
				   Lists.length conbinds)),
@


1.4
log
@Fixed inexhaustive matches
@
text
@d1 1
d4 3
d17 1
@


1.3
log
@Updated to set extra type ref field in HANDLEexp to type of handler body
@
text
@d3 3
d116 2
d361 3
d811 4
a814 2
	 val CONSTYPE (tyvarlist,tyname as TYNAME {5 = valenv_ref,...}) =
	   tycon_type 
d820 1
@


1.2
log
@Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures.
@
text
@d3 4
d107 1
a107 1
	| exp_context (Absyn.HANDLEexp (exp, match)) =
d282 1
a282 1
      | check_exp (Absyn.HANDLEexp (exp, match), acontext) =
d288 2
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d514 1
a514 1
			 (atyfun,VE aconenv))
@
