head	1.121;
access;
symbols
	MLW_daveb_inline_1_4_99:1.121.1
	MLWorks_21c0_1999_03_25:1.121
	MLWorks_20c1_1998_08_20:1.120
	MLWorks_20c0_1998_08_04:1.120
	MLWorks_20b2c2_1998_06_19:1.120
	MLWorks_20b2_Windows_1998_06_12:1.120
	MLWorks_20b1c1_1998_05_07:1.120
	MLWorks_20b0_1998_04_07:1.120
	MLWorks_20b0_1998_03_20:1.120
	MLWorks_20m2_1998_02_16:1.119
	MLWorks_20m1_1997_10_23:1.119
	MLWorks_11r1:1.117.5.2.1.1.1
	MLWorks_workspace_97:1.119.2
	MLWorks_dt_wizard:1.119.1
	MLWorks_11c0_1997_09_09:1.117.5.2.1.1
	MLWorks_10r3:1.117.5.2.3
	MLWorks_10r2_551:1.117.5.2.2
	MLWorks_11:1.117.5.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.117.5.2
	MLWorks_20m0_1997_06_20:1.119
	MLWorks_1_0_r2c2_1997_06_14:1.117.5.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.117.5.2
	MLWorks_1_0_r2c1_1997_05_12:1.117.5
	MLWorks_BugFix_1997_04_24:1.118
	MLWorks_1_0_r2_Win32_1997_04_11:1.117
	MLWorks_1_0_r2_Unix_1997_04_04:1.117
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.117.3.1.1
	MLWorks_gui_1996_12_18:1.117.4
	MLWorks_1_0_Win32_1996_12_17:1.117.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.117.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.117.1.1
	MLWorks_1_0_Irix_1996_11_28:1.117.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.117.2
	MLWorks_1_0_Unix_1996_11_14:1.117.1
	MLWorks_Open_Beta2_1996_10_11:1.114.1
	MLWorks_License_dev:1.112.1
	MLWorks_1_open_beta_1996_09_13:1.109.1
	MLWorks_Open_Beta_1996_08_22:1.109
	MLWorks_Beta_1996_07_02:1.107
	MLWorks_Beta_1996_06_07:1.106
	MLWorks_Beta_1996_06_06:1.106
	MLWorks_Beta_1996_06_05:1.106
	MLWorks_Beta_1996_06_03:1.105
	MLWorks_Beta_1996_05_31:1.105
	MLWorks_Beta_1996_05_30:1.105
	ML_beta_release_12/08/94:1.87
	ML_beta_release_03/08/94:1.87
	ML_revised_beta_release_25/05/94:1.86
	ML_final_beta_release_02/03/94:1.83
	mlworks-28-01-1994:1.81
	Release:1.75
	mlworks-beta-01-09-1993:1.75
	MLWorks-1-0-4-29/01/1993:1.50
	MLWorks-1-0-3-21/12/1992:1.49
	MLWorks-1-0-2-15/12/1992:1.48
	MLWorks-1-0-1-04/12/1992:1.45
	checkpoint_17_08_92:1.32
	Ten15_release_19-11-91:1.5
	Ten15_release_21-08-91:1.5
	Ten15_release_19-08-91:1.5
	ten15_release:1.5;
locks; strict;
comment	@ * @;


1.121
date	98.12.14.15.52.49;	author mitchell;	state Exp;
branches
	1.121.1.1;
next	1.120;

1.120
date	98.02.19.16.50.47;	author mitchell;	state Exp;
branches;
next	1.119;

1.119
date	97.05.19.12.49.39;	author jont;	state Exp;
branches
	1.119.1.1
	1.119.2.1;
next	1.118;

1.118
date	97.04.08.14.49.55;	author andreww;	state Exp;
branches;
next	1.117;

1.117
date	96.11.04.17.23.51;	author andreww;	state Exp;
branches
	1.117.1.1
	1.117.2.1
	1.117.3.1
	1.117.4.1
	1.117.5.1;
next	1.116;

1.116
date	96.10.29.17.48.36;	author andreww;	state Exp;
branches;
next	1.115;

1.115
date	96.10.29.13.32.36;	author io;	state Exp;
branches;
next	1.114;

1.114
date	96.10.09.09.55.41;	author andreww;	state Exp;
branches
	1.114.1.1;
next	1.113;

1.113
date	96.10.04.17.59.16;	author andreww;	state Exp;
branches;
next	1.112;

1.112
date	96.10.04.11.04.22;	author matthew;	state Exp;
branches
	1.112.1.1;
next	1.111;

1.111
date	96.09.23.11.00.59;	author andreww;	state Exp;
branches;
next	1.110;

1.110
date	96.09.20.10.10.15;	author andreww;	state Exp;
branches;
next	1.109;

1.109
date	96.08.06.11.32.58;	author andreww;	state Exp;
branches
	1.109.1.1;
next	1.108;

1.108
date	96.07.03.15.52.30;	author jont;	state Exp;
branches;
next	1.107;

1.107
date	96.07.02.14.43.01;	author daveb;	state Exp;
branches;
next	1.106;

1.106
date	96.06.04.11.21.10;	author jont;	state Exp;
branches;
next	1.105;

1.105
date	96.05.24.12.12.07;	author matthew;	state Exp;
branches;
next	1.104;

1.104
date	96.05.20.15.32.51;	author matthew;	state Exp;
branches;
next	1.103;

1.103
date	96.04.30.16.05.57;	author jont;	state Exp;
branches;
next	1.102;

1.102
date	96.04.03.13.16.05;	author matthew;	state Exp;
branches;
next	1.101;

1.101
date	96.03.26.16.30.47;	author matthew;	state Exp;
branches;
next	1.100;

1.100
date	96.03.19.16.02.06;	author matthew;	state Exp;
branches;
next	1.99;

1.99
date	96.01.16.12.37.45;	author daveb;	state Exp;
branches;
next	1.98;

1.98
date	95.12.27.11.55.28;	author jont;	state Exp;
branches;
next	1.97;

1.97
date	95.12.18.12.25.34;	author matthew;	state Exp;
branches;
next	1.96;

1.96
date	95.12.05.13.50.15;	author jont;	state Exp;
branches;
next	1.95;

1.95
date	95.10.30.10.39.18;	author jont;	state Exp;
branches;
next	1.94;

1.94
date	95.09.11.15.57.14;	author matthew;	state Exp;
branches;
next	1.93;

1.93
date	95.08.31.11.25.20;	author jont;	state Exp;
branches;
next	1.92;

1.92
date	95.05.02.11.16.11;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	95.04.06.10.01.10;	author matthew;	state Exp;
branches;
next	1.90;

1.90
date	95.02.13.11.42.50;	author matthew;	state Exp;
branches;
next	1.89;

1.89
date	95.02.07.16.42.24;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	94.09.22.13.15.07;	author matthew;	state Exp;
branches;
next	1.87;

1.87
date	94.06.10.16.52.17;	author jont;	state Exp;
branches;
next	1.86;

1.86
date	94.05.11.14.37.52;	author daveb;	state Exp;
branches;
next	1.85;

1.85
date	94.04.28.11.28.07;	author jont;	state Exp;
branches;
next	1.84;

1.84
date	94.04.13.13.48.09;	author jont;	state Exp;
branches;
next	1.83;

1.83
date	94.02.28.06.28.02;	author nosa;	state Exp;
branches;
next	1.82;

1.82
date	94.02.08.12.10.59;	author nickh;	state Exp;
branches;
next	1.81;

1.81
date	93.12.16.13.06.16;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	93.12.03.15.42.21;	author nickh;	state Exp;
branches;
next	1.79;

1.79
date	93.12.01.14.00.43;	author nickh;	state Exp;
branches;
next	1.78;

1.78
date	93.11.30.11.53.58;	author matthew;	state Exp;
branches;
next	1.77;

1.77
date	93.09.27.11.05.23;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	93.09.16.14.44.31;	author nosa;	state Exp;
branches;
next	1.75;

1.75
date	93.07.30.11.19.12;	author nosa;	state Exp;
branches
	1.75.1.1;
next	1.74;

1.74
date	93.07.12.16.26.46;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	93.07.02.15.55.13;	author daveb;	state Exp;
branches;
next	1.72;

1.72
date	93.06.25.19.28.51;	author jont;	state Exp;
branches
	1.72.1.1;
next	1.71;

1.71
date	93.06.02.18.21.41;	author jont;	state Exp;
branches;
next	1.70;

1.70
date	93.06.01.13.45.22;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	93.05.28.14.03.39;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	93.05.27.12.24.13;	author jont;	state Exp;
branches;
next	1.67;

1.67
date	93.05.25.15.37.42;	author jont;	state Exp;
branches;
next	1.66;

1.66
date	93.05.25.10.36.05;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	93.05.24.17.27.28;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	93.05.20.17.20.05;	author jont;	state Exp;
branches;
next	1.63;

1.63
date	93.05.19.16.51.10;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	93.05.17.14.33.55;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	93.05.11.12.07.04;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	93.05.05.15.46.36;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	93.04.14.15.42.45;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	93.04.13.14.39.10;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	93.04.05.15.02.21;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	93.03.17.19.03.51;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	93.03.10.15.32.55;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	93.03.09.11.57.55;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	93.02.22.13.40.35;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	93.02.09.14.45.28;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	93.02.05.15.09.33;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	92.12.22.16.59.20;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	92.12.18.16.18.40;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	92.12.08.20.06.02;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	92.12.07.11.13.26;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	92.12.04.19.31.53;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	92.12.03.18.46.33;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	92.12.03.13.24.05;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	92.12.02.13.51.58;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	92.11.26.19.06.43;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	92.11.04.18.02.44;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	92.10.15.15.55.13;	author clive;	state Exp;
branches;
next	1.39;

1.39
date	92.10.14.12.06.29;	author richard;	state Exp;
branches;
next	1.38;

1.38
date	92.09.08.17.54.07;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	92.09.08.13.07.59;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	92.09.04.10.03.16;	author richard;	state Exp;
branches;
next	1.35;

1.35
date	92.08.27.20.20.40;	author davidt;	state Exp;
branches;
next	1.34;

1.34
date	92.08.27.14.30.32;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.08.26.13.19.53;	author davidt;	state Exp;
branches;
next	1.32;

1.32
date	92.08.13.15.27.33;	author davidt;	state Exp;
branches;
next	1.31;

1.31
date	92.08.12.13.11.19;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.08.11.11.25.51;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	92.08.04.15.02.51;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	92.08.04.12.35.33;	author davidt;	state Exp;
branches;
next	1.27;

1.27
date	92.07.27.14.00.42;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	92.07.17.15.14.35;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	92.07.15.15.19.18;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.07.02.16.20.36;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.06.30.10.30.18;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.06.22.09.30.00;	author davida;	state Exp;
branches;
next	1.21;

1.21
date	92.05.19.14.51.46;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.05.18.10.24.34;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.05.07.14.10.02;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.04.27.13.24.47;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.04.27.12.11.29;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.04.22.10.58.33;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.04.16.16.14.43;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.04.15.12.04.24;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.04.13.14.36.45;	author clive;	state Exp;
branches;
next	1.12;

1.12
date	92.03.23.19.29.33;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.01.27.20.14.04;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.01.27.12.55.29;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.01.22.15.42.25;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.01.08.19.56.42;	author colin;	state Exp;
branches;
next	1.7;

1.7
date	91.11.20.10.28.32;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.11.19.19.21.20;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.07.11.14.18.04;	author colin;	state Exp;
branches;
next	1.4;

1.4
date	91.06.27.17.17.24;	author colin;	state Exp;
branches;
next	1.3;

1.3
date	91.06.27.09.12.24;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.17.14.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.36.39;	author colin;	state Exp;
branches;
next	;

1.72.1.1
date	93.07.09.16.47.34;	author jont;	state Exp;
branches;
next	;

1.75.1.1
date	93.07.30.11.19.12;	author jont;	state Exp;
branches;
next	1.75.1.2;

1.75.1.2
date	93.09.23.15.35.18;	author jont;	state Exp;
branches;
next	;

1.109.1.1
date	96.09.13.11.41.37;	author hope;	state Exp;
branches;
next	;

1.112.1.1
date	96.10.07.16.34.42;	author hope;	state Exp;
branches;
next	;

1.114.1.1
date	96.10.17.11.53.47;	author hope;	state Exp;
branches;
next	;

1.117.1.1
date	96.11.14.13.21.26;	author hope;	state Exp;
branches
	1.117.1.1.1.1;
next	;

1.117.1.1.1.1
date	96.11.28.15.32.26;	author hope;	state Exp;
branches;
next	;

1.117.2.1
date	96.11.22.18.39.09;	author hope;	state Exp;
branches;
next	;

1.117.3.1
date	96.12.17.18.18.09;	author hope;	state Exp;
branches
	1.117.3.1.1.1;
next	;

1.117.3.1.1.1
date	97.02.24.12.12.25;	author hope;	state Exp;
branches;
next	;

1.117.4.1
date	96.12.18.10.13.28;	author hope;	state Exp;
branches;
next	;

1.117.5.1
date	97.05.12.10.51.43;	author hope;	state Exp;
branches;
next	1.117.5.2;

1.117.5.2
date	97.05.12.16.03.08;	author daveb;	state Exp;
branches
	1.117.5.2.1.1
	1.117.5.2.2.1
	1.117.5.2.3.1;
next	;

1.117.5.2.1.1
date	97.07.28.18.33.33;	author daveb;	state Exp;
branches
	1.117.5.2.1.1.1.1;
next	;

1.117.5.2.1.1.1.1
date	97.10.07.11.59.32;	author jkbrook;	state Exp;
branches;
next	;

1.117.5.2.2.1
date	97.09.08.17.26.38;	author daveb;	state Exp;
branches;
next	;

1.117.5.2.3.1
date	97.09.09.14.23.29;	author daveb;	state Exp;
branches;
next	;

1.119.1.1
date	97.09.10.19.42.27;	author brucem;	state Exp;
branches;
next	;

1.119.2.1
date	97.09.11.21.09.58;	author daveb;	state Exp;
branches;
next	;

1.121.1.1
date	99.04.01.18.08.38;	author daveb;	state Exp;
branches;
next	;


desc
@Rules (53-102) See The Definition
@


1.121
log
@[Bug #190495]
Check for equality violations in "where type"s
@
text
@(* _mod_rules the functor *)
(*
$Log: _mod_rules.sml,v $
 * Revision 1.120  1998/02/19  16:50:47  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.119  1997/05/19  12:49:39  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.118  1997/04/08  14:49:55  andreww
 * [Bug #2033]
 * ordering type sharing constraints in structure sharing
 * to maintain correct dependency info between types.
 *
 * Revision 1.117  1996/11/04  17:23:51  andreww
 * [Bug #1712]
 * Where type instantiation shouldn't maximise equality.
 *
 * Revision 1.116  1996/10/29  17:48:36  andreww
 * [Bug #1708]
 * changing the syntax of datatype replication.
 *
 * Revision 1.115  1996/10/29  13:32:36  io
 * moving String from toplevel
 *
 * Revision 1.113  1996/10/04  17:59:16  andreww
 * [Bug #1592]
 * threading location into Absyn.LOCALexp.
 *
 * Revision 1.112  1996/10/04  11:04:22  matthew
 * [Bug #1622]
 * Make certain identifiers unspecifiable
 *
 * Revision 1.111  1996/09/23  11:00:59  andreww
 * [Bug #1589]
 * Where types to be elaborated only in the basis not the basis plus env.
 *
 * Revision 1.110  1996/09/20  10:10:15  andreww
 * [Bug #1577]
 * Adding typechecking rules for datatype replication.
 *
 * Revision 1.109  1996/08/06  11:32:58  andreww
 * [Bug #1521]
 * Propagating changes made to _test.sml that require the
 * use_value_polymorphism flag to be passed.
 *
 * Revision 1.108  1996/07/03  15:52:30  jont
 * Change check for free imperative type variables to return
 * the full type as well as the type variable
 *
 * Revision 1.107  1996/07/02  14:43:01  daveb
 * Made the error message for free imperative type variables at top level
 * depend on the old_definition option.
 *
 * Revision 1.106  1996/06/04  11:21:10  jont
 * Improve error messages for unbound tycons in sharing equations
 *
 * Revision 1.105  1996/05/24  12:12:07  matthew
 * lookupTyCon can also raise Strid exception
 *
 * Revision 1.104  1996/05/20  15:32:51  matthew
 * Fixing problem with lookupTycon
 *
 * Revision 1.103  1996/04/30  16:05:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.102  1996/04/03  13:16:05  matthew
 * Changing interface to sharing
 *
 * Revision 1.101  1996/03/26  16:30:47  matthew
 * New language features
 *
 * Revision 1.100  1996/03/19  16:02:06  matthew
 * Adding use_value_polymorphism option
 *
 * Revision 1.99  1996/01/16  12:37:45  daveb
 * Added location information to Absyn.SIGNATUREtopdec.
 *
Revision 1.98  1995/12/27  11:55:28  jont
Removing Option in favour of MLWorks.Option

Revision 1.97  1995/12/18  12:25:34  matthew
Changed interface to Basis.close

Revision 1.96  1995/12/05  13:50:15  jont
Add calls to discover exact location of free imperative type variable errors

Revision 1.95  1995/10/30  10:39:18  jont
Use modified form of expand_str to avoid full cost when
gathering strs. We only want the structure name in this case.

Revision 1.94  1995/09/11  15:57:14  matthew
Attempting to improve some error behaviour

Revision 1.93  1995/08/31  11:25:20  jont
Reinstate unbound strid in openspec error
The parser cannot catch some of these

Revision 1.92  1995/05/02  11:16:11  matthew
Removing debug_polyvariables option

Revision 1.91  1995/04/06  10:01:10  matthew
How much structure expansion is done is determined by whether we are doing
separate compilation

Revision 1.90  1995/02/13  11:42:50  matthew
Debugger changes

Revision 1.89  1995/02/07  16:42:24  matthew
Removing debug stuff

Revision 1.88  1994/09/22  13:15:07  matthew
Tidying up

Revision 1.87  1994/06/10  16:52:17  jont
Fix spelling of contructor to constructor

Revision 1.86  1994/05/11  14:37:52  daveb
Added call to Valenv.resolve_overloads, and location argument to
Scheme.instantiate.  Also added two sharing type equations.

Revision 1.85  1994/04/28  11:28:07  jont
Fix unbound type constructors in specifications problems

Revision 1.84  1994/04/13  13:48:09  jont
Remove Bind handler

Revision 1.83  1994/02/28  06:28:02  nosa
Debugger structure and structure recording for Modules Debugger.

Revision 1.82  1994/02/08  12:10:59  nickh
yes
Found a way to generate some 'impossible' type errors.

Revision 1.81  1993/12/16  13:06:16  matthew
Added level field to Basis.
Renamed Basis.level to Basis.context_level

Revision 1.80  1993/12/03  15:42:21  nickh
fixup various error messages, inexhaustive bindings, etc.

Revision 1.79  1993/12/01  14:00:43  nickh
Marked certain error messages as "impossible".

Revision 1.78  1993/11/30  11:53:58  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.77  1993/09/27  11:05:23  jont
Merging in bug fixes

Revision 1.76  1993/09/16  14:44:31  nosa
Instances in schemes for polymorphic debugger.

Revision 1.75.1.2  1993/09/23  15:35:18  jont
Modified equality_principal to recalculate equality attributes of all
flexible type constructors in the nameset which have non-empty
constructor environments
See the defn page 36 for what's supposed to happen

Revision 1.75.1.1  1993/07/30  11:19:12  jont
Fork for bug fixing

Revision 1.75  1993/07/30  11:19:12  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.

Revision 1.74  1993/07/12  16:26:46  jont
Merged in changes from 1.72.1.1


Revision 1.73  1993/07/02  15:55:13  daveb
Removed exception environments.
Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.

Revision 1.72.1.1  1993/07/09  16:47:34  jont
Fixed problem whereby erroneous signatures were being realised and
causing compiler faults

Revision 1.72  1993/06/25  19:28:51  jont
Various improvements, particularly to do with signatures embedded in structures

Revision 1.71  1993/06/02  18:21:41  jont
Changed type of check_topdec to take assemblies, thus making it functional
Removed all use of per functor application refs
Avoided calculating assemblies during/for structure elaboration

Revision 1.70  1993/06/01  13:45:22  jont
Fixed functor topdecs so that they know about the existing structure assemblies

Revision 1.69  1993/05/28  14:03:39  jont
Cleaned up after assembly changes

Revision 1.68  1993/05/27  12:24:13  jont
Revised way of using assemblies such that structure assemblies are constructed
from the incremental basis rather than on the fly. Fixes a number of
problems with incorrect shadowing

Revision 1.66  1993/05/25  10:36:05  matthew
Replaced abstraction variable name with do_abstraction, so NJ can compile it.

Revision 1.65  1993/05/24  17:27:28  matthew
Added code for abstractions.
Added newAssemblies for INCLUDEspecs

Revision 1.64  1993/05/20  17:20:05  jont
Avoid updating flexible names in the basis (when doing sharng in functor results)

Revision 1.63  1993/05/19  16:51:10  matthew
uses test implementation of nameset_diff

Revision 1.62  1993/05/17  14:33:55  daveb
nj_local_open compatibility option has changed to nj_signatures.

Revision 1.61  1993/05/11  12:07:04  matthew
Added (commented out) call to print type bindings of variables

Revision 1.60  1993/05/05  15:46:36  matthew
Restrict nameset of signature to names not in the basis
Add functor parameter nameset to basis nameset

Revision 1.59  1993/04/14  15:42:45  matthew
Changed default for print_times to false

Revision 1.58  1993/04/13  14:39:10  matthew
Simplified interface to Sigma.*names_of* functions
Rewrote circularity test to use assemblies
Rewrote well formed test to recurse properly

Revision 1.57  1993/04/05  15:02:21  jont
Added option for New Jersey compatible open specifications. Fixed poor
implementation in SEQUENCEspecs and SEQUENCEstrdecs

Revision 1.56  1993/03/17  19:03:51  matthew
NamesetType changes

Revision 1.55  1993/03/10  15:32:55  matthew
Options changes

Revision 1.54  1993/03/09  11:57:55  matthew
Options & Info changes

Revision 1.53  1993/02/22  13:40:35  matthew
Much fiddling.
Changed error handling behaviour
removed some silly bits to do with assemblies and namesets
removed most debug statements

Revision 1.52  1993/02/09  14:45:28  matthew
Changes to use BASISTYPES signature.
Removed some of the sillier bits to do with assemblies
Changes to nameset used in functor result signature

Revision 1.51  1993/02/05  15:09:33  matthew
Extensive changes:
Fixed bug with include
COPYSTR representation
Changed many functions to use Lists.reducel
Made many errors recoverable
General tidying up of code

Revision 1.50  1992/12/22  16:59:20  jont
Anel's last changes

Revision 1.49  1992/12/18  16:18:40  matthew
Propagating options to signature matching error messages.

Revision 1.48  1992/12/08  20:06:02  jont
Removed a number of duplicated signatures and structures

Revision 1.47  1992/12/07  11:13:26  matthew
Changed error messages.

Revision 1.46  1992/12/04  19:31:53  matthew
Error message revisions.

Revision 1.45  1992/12/03  18:46:33  matthew
Changes to error messages.

Revision 1.44  1992/12/03  13:24:05  jont
Modified tyenv for efficiency

Revision 1.43  1992/12/02  13:51:58  jont
Modified to remove redundant info signatures

Revision 1.42  1992/11/26  19:06:43  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.41  1992/11/04  18:02:44  matthew
Changed Error structure to Info

Revision 1.40  1992/10/15  15:55:13  clive
Anel's changes for encapsulating assemblies

Revision 1.39  1992/10/14  12:06:29  richard
Added location information to the `require' topdec.

Revision 1.38  1992/09/08  17:54:07  matthew
Added locations to errors

Revision 1.37  1992/09/08  13:07:59  jont
Removed has_a_new_name, no longer needed

Revision 1.36  1992/09/04  10:03:16  richard
Installed central error reporting mechanism.

Revision 1.35  1992/08/27  20:20:40  davidt
Yet more changes to get structure copying working better.

Revision 1.34  1992/08/27  14:30:32  jont
fixed bug in type_explicit.

Revision 1.33  1992/08/26  13:19:53  davidt
Made some changes to the NewMap signature.

Revision 1.32  1992/08/13  15:27:33  davidt
Removed redundant arguments to Assemblies.newAssemblies.

Revision 1.31  1992/08/12  13:11:19  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.30  1992/08/11  11:25:51  matthew
removed type_eq_matters from calls to sigmatch

Revision 1.29  1992/08/04  15:02:51  jont
Anel's changes to use NewMap instead of Map

Revision 1.27  1992/07/27  14:00:42  jont
Removed previous incorrect fix to do with subAssemblies

Revision 1.26  1992/07/17  15:14:35  jont
Fixed bug whereby structure a = a caused subassemblies

Revision 1.25  1992/07/15  15:19:18  jont
Changed exptyStrAssembly to be a function, in case we want an imperative
implementation ever

Revision 1.24  1992/07/02  16:20:36  jont
Added timing of unionTypeAssemblies. Made all timings able to be
turned off

Revision 1.23  1992/06/30  10:30:18  jont
Changed to imperative implementation of namesets with hashing

Revision 1.21  1992/05/19  14:51:46  clive
Adjusted to give better error position reporting now marks have been added

Revision 1.20  1992/05/18  10:24:34  jont
Removed incorrect whitespace from middle of nameset.empty_nameset.
Goodness knows why NJ allows this, I wish they didn't

Revision 1.19  1992/05/07  14:10:02  jont
Anel's fixes. Also included new version of nameset based on hashsets

Revision 1.18  1992/04/27  13:24:47  jont
Added second implementation of sigma for test purposes

Revision 1.15  1992/04/16  16:14:43  jont
Various improvements. Added timing functions

Revision 1.13  1992/04/13  14:36:45  clive
First version of the profiler

Revision 1.12  1992/03/23  19:29:33  jont
Reinstated the code to determine constructor environments for METATYNAMEs

Revision 1.11  1992/01/27  20:14:04  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.10  1992/01/27  12:55:29  jont
Updated to create empty valenv in METATYNAMEs

Revision 1.9  1992/01/22  15:42:25  jont
Stopped signatures and functors being duplicated from previous bases

Revision 1.8  1992/01/08  19:56:42  colin
added reset_assemblies

Revision 1.7  1991/11/20  10:28:32  richard
Moved the empty structure environment from Env to Strenv.

Revision 1.6  91/11/19  19:21:20  jont
Fixed inexhaustive matches

Revision 1.5  91/07/11  14:18:04  colin
Added exception Check_topdec - raised if any errors happened during
type checking in check_topdec

Revision 1.4  91/06/27  17:17:24  colin
changed to handle Interface annotations in signature expressions

Revision 1.3  91/06/27  09:12:24  nickh
Added null check on REQUIREtopdec.

Revision 1.2  91/06/17  17:14:00  nickh
Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures

Revision 1.1  91/06/07  11:36:39  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/lists";
require "../utils/print";
require "../utils/crash";
require "../basics/identprint";
require "../typechecker/types";
require "../typechecker/scheme";
require "../typechecker/valenv";
require "../typechecker/tyenv";
require "../typechecker/strenv";
require "../typechecker/environment";
require "../typechecker/strnames";
require "../typechecker/core_rules";
require "../typechecker/sharetypes";
require "../typechecker/share";
require "../typechecker/nameset";
require "../typechecker/sigma";
require "../typechecker/realise";
require "../typechecker/basis";
require "../typechecker/type_debugger";

require "../typechecker/mod_rules";

functor Module_rules (
  structure Lists      : LISTS
  structure Print      : PRINT
  structure Crash      : CRASH
  structure IdentPrint : IDENTPRINT
  structure Types      : TYPES
  structure Scheme     : SCHEME
  structure Valenv     : VALENV
  structure Tyenv      : TYENV
  structure Strenv     : STRENV
  structure Env        : ENVIRONMENT
  structure Strnames   : STRNAMES
  structure Core_rules : CORE_RULES
  structure Realise    : REALISE
  structure Basis      : BASIS
  structure Sigma      : SIGMA
  structure Sharetypes : SHARETYPES
  structure Share      : SHARE
  structure Nameset    : NAMESET
  structure TypeDebugger : TYPE_DEBUGGER

  sharing Core_rules.Basistypes = Realise.BasisTypes =
    Sigma.BasisTypes = Basis.BasisTypes = Sharetypes.Assemblies.Basistypes

  sharing Core_rules.Absyn = TypeDebugger.Absyn
  sharing Core_rules.Info = Realise.Info
  sharing Realise.Options = Types.Options = IdentPrint.Options = Core_rules.Options =
    TypeDebugger.Options = Sigma.Options = Nameset.Options

  sharing Core_rules.Info.Location = IdentPrint.Ident.Location

  sharing Strnames.Datatypes = Tyenv.Datatypes = Nameset.Datatypes =
    Valenv.Datatypes = Scheme.Datatypes = Types.Datatypes = Strenv.Datatypes =
    Env.Datatypes = Basis.BasisTypes.Datatypes = Core_rules.Absyn.Datatypes
  sharing Share.Assemblies = Sharetypes.Assemblies
  sharing IdentPrint.Ident = Types.Datatypes.Ident

  sharing type Nameset.Nameset = Basis.BasisTypes.Nameset =
    Sharetypes.NamesetTypes.Nameset
  sharing type Core_rules.Absyn.DebuggerStr = Strnames.Datatypes.DebuggerStr
  sharing type Basis.options = Core_rules.Options.options
  sharing type Valenv.Options  = Realise.Options.options
  sharing type Valenv.ErrorInfo  = Realise.Info.options = Basis.error_info
  sharing type IdentPrint.Options.print_options = Basis.print_options
    ) : MODULE_RULES =

  struct
    structure Absyn = Core_rules.Absyn
    structure BasisTypes = Basis.BasisTypes
    structure Assemblies = Sharetypes.Assemblies
    structure Info = Core_rules.Info
    structure Location = Info.Location
    structure Set = BasisTypes.Set
    structure Datatypes = Types.Datatypes
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Options = Core_rules.Options
    structure Basis = Basis


    datatype assembly =
      ASSEMBLY of (Assemblies.StrAssembly * Assemblies.TypeAssembly)
    | BASIS of BasisTypes.Basis

    val do_debug = false

    open Datatypes

    (* These exceptions signal failure of signature elaboration *)
    exception WellFormed of BasisTypes.Sigma
    exception TypeExplicit of BasisTypes.Sigma
    exception RespectEquality of BasisTypes.Sigma

    fun eq_scheme (_, s) = Scheme.equalityp s

    (* eager andalso *)
    fun aswell (a,b) = a andalso b

    fun fresh_tyvar(acontext, eq, imp) =
      METATYVAR (ref (Basis.context_level acontext,NULLTYPE,NO_INSTANCE), eq, imp)

    fun make_dummy_structures () =
      let
	val str = STR (STRNAME (Types.make_stamp ()),ref NONE,Env.empty_env)
      in
        (str,str)
      end

    fun set_intref (Absyn.OLDsigexp (_,intref,_),str) = intref := SOME str
      | set_intref (Absyn.NEWsigexp(_,intref),str) = intref := SOME str
      | set_intref (Absyn.WHEREsigexp (sigexp,_),str) = set_intref (sigexp,str)

    (* Structure and Type assemblies *)

    (* During elaboration of signatures these assemblies are updated;*)
    (* if shadowing occur new assemblies are built which are unioned *)
    (* with the above. After elaborating each topdec str_ass and ty_ass *)
    (* are assigned to sigstr_ass and sigty_ass respectively. *)
    (* This is all a bit out of date now *)
    (* Assemblies are built after elaboration of strdec topdecs *)
    (* Work is still in progress on the signature stuff *)
    (* Work is also in progress to try to make this stuff functional *)

    val empty_str_ass = Assemblies.empty_strassembly()
    val empty_ty_ass = Assemblies.empty_tyassembly

    (* ****** Structure Expressions ****** *)

    fun copystr_crash s = Crash.impossible ("Unexpanded structure in " ^ s)

    fun circularp (strname,strname',strass) =
      let
        fun offspring name = Assemblies.findStrOffspring (name,strass)
        fun checkok (strname,stroffspring) =
          let
	    val os_map = Assemblies.getStrOffspringMap stroffspring
          in
            NewMap.forall
            (fn (_,(subname,_)) =>
             (not (Strnames.strname_eq (strname,subname))
              andalso
              checkok (strname,offspring subname)))
            os_map
          end
      in
        not (checkok (strname,offspring strname'))
        orelse
        not (checkok (strname',offspring strname))
      end

    fun make_completion_env (basis,sigstr,strstr) =
      let
	val ENV (sE,tE,vE) = Basis.env_of_context (Basis.basis_to_context basis)
      in
	ENV(Strenv.add_to_se(Ident.STRID (Symbol.find_symbol "_sig"),
			     sigstr,
			     Strenv.add_to_se(Ident.STRID(Symbol.find_symbol "_str"),
					      strstr,
					      sE)),
	    tE,vE)
      end

    val generate_moduler_debug = false
    fun get_env_or_crash (_,STR (_,_,e)) = e
      | get_env_or_crash (error,_) = Crash.impossible error

    fun get_name_and_env (_,STR (m,_,e)) = (m,e)
      | get_name_and_env (error,_) = Crash.impossible error

    fun has_unbounds_te(TE amap) =
      NewMap.exists
      (fn (_, tystr) => has_unbounds_tystr tystr)
      amap

    and has_unbounds_ve(VE(_, amap)) =
      NewMap.exists
      (fn (_, scheme) => has_unbounds_scheme scheme)
      amap

    and has_unbounds_tystr(TYSTR(tyfun, valenv)) =
      Types.tyfun_has_unbound_tyvars tyfun orelse has_unbounds_ve valenv

    and has_unbounds_scheme(SCHEME(_, (ty, _))) = Types.type_has_unbound_tyvars ty
      | has_unbounds_scheme(UNBOUND_SCHEME(ty, _)) = Types.type_has_unbound_tyvars ty
      | has_unbounds_scheme(OVERLOADED_SCHEME _) = false

    val verboten_identifieren = 
      map 
      Symbol.find_symbol
      ["true","false","it","nil","::","ref"]

    fun check_topdec error_info(options as
				Options.OPTIONS
				{print_options,
				 compat_options=Options.COMPATOPTIONS{nj_signatures, 
                                                                      old_definition,...},
				 ...}, is_separate, topdec, basis, assembly) =
      let
        val use_value_polymorphism = not old_definition
	fun error_wrap error_info =
	  Info.wrap error_info
	  (Info.FATAL, Info.RECOVERABLE, Info.ADVICE, Location.UNKNOWN)
	val sigstr_ass = ref(Assemblies.empty_strassembly())
	val sigty_ass = ref Assemblies.empty_tyassembly
	val report_error = Info.error error_info
	val check_type = Core_rules.check_type error_info
	val check_dec = Core_rules.check_dec (error_info,options)
	val sigmatch = Realise.sigmatch (error_info,options)

        fun check_valid_ok (valid,location) =
          let
            fun valid_symbol v =
              case v of
                Ident.VAR s => s
              | Ident.CON s => s
              | Ident.EXCON s => s
              | Ident.TYCON' s => s
            val name = valid_symbol valid
          in
            if Lists.member (name,verboten_identifieren)
              then
                report_error (Info.RECOVERABLE, 
                              location,
                              "Trying to specify a reserved name: " ^ 
                              Symbol.symbol_name name)
            else
              ()
          end

	(* *** rule 53 *** *)

	fun check_strexp (Absyn.NEWstrexp strdec,basis) =
	  let
	    val strname = STRNAME (Types.make_stamp ())
	    val env = check_strdec (strdec,basis)
	    val str = STR (strname,ref NONE,env)
	    val exp_str = Env.expand_str str
	  in
	    (str,exp_str)
	  end

	  (* *** rule 54 *** *)

	  | check_strexp (Absyn.OLDstrexp (lstrid,location,interface),basis) =
	    (let
	       val str = Basis.lookup_longstrid (lstrid,basis)
	       val exp_str = Env.expand_str str
               val _ =
                 case interface of
                   SOME(interface) =>
                     interface := SOME(exp_str)
                 | _ => ()
	     in
	       (str,exp_str)
	     end
	   handle Basis.LookupStrId strid =>
	     (report_error (Info.RECOVERABLE, location,
                            IdentPrint.strid_unbound_strid_message (strid,lstrid,print_options));
	      make_dummy_structures ())) (* structure doesn't exist, so there you go *)

	  (* *** rule 55 *** *)

	  | check_strexp (Absyn.APPstrexp (funid,strexp,coerce_ref,location,
                                           debugger_str),basis) =
	    (let
	       val (str,exp_str) = check_strexp (strexp,basis)
	       val phi = Basis.lookup_funid (funid,basis)

             (****
              We have to copy both the body and the argument of the functor
              before we match the argument signature to the actual argument.
              This is necessary because sharing between the argument and result
              specified in the declaration of the functor is represented by the
              occurrence of the same name in both the body and the argument.
              This repeated occurrence is preserved by the realisation map,
              yielding sharing between the argument structure and the result
              structure of the functor application.
              ****)

              (* If we are doing separate compilation then expand the
                 copied structures *)
	       val BasisTypes.PHI (newnames,(newstr'',
                                             BasisTypes.SIGMA (newnames',
                                                               newstr'))) =
                 Sigma.phi_copy (phi,is_separate) (Basis.basis_level basis)

	       val exp_newstr' = Env.expand_str newstr' (* necessary *)
	       val exp_newstr'' = Env.expand_str newstr'' (* necessary *)
	       val sigma = BasisTypes.SIGMA(Nameset.union(newnames,newnames'),
                                            exp_newstr'')
	       val completion_env = make_completion_env(basis,exp_newstr'',
                                                        exp_str)
	       val (realise, do_coerce, debugger_str') =
		 (sigmatch (location,
			    completion_env,
			    Basis.context_level(Basis.basis_to_context basis),
			    sigma,
			    exp_str))
               val _ =
                 case debugger_str of
                   SOME(debugger_str) => debugger_str := debugger_str'
                 | _ => ()
	     in
	       if realise then ()
	       else
		 report_error
                 (Info.RECOVERABLE, location,
                  concat ["Argument signature of ", 
                                  IdentPrint.printFunId funid,
                                  " does not match the actual argument"]);
		 if do_coerce then coerce_ref := true else ();
		   (newstr',exp_newstr') 
                                 (* Approximately correct in error case *)
	     end
           handle Basis.LookupFunId =>
             (report_error(Info.RECOVERABLE,
                           location,
                           "impossible type error 6: unbound functor " ^ 
                           IdentPrint.printFunId funid);
              make_dummy_structures()))

	  (* *** rule 56 *** *)

	  | check_strexp (Absyn.LOCALstrexp (strdec,strexp),basis) =
	    let
	      val new_env = check_strdec (strdec,basis)
	    in
	      check_strexp (strexp,Basis.basis_plus_env (basis,new_env))
	    end

          | check_strexp (Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,
                                                  coerce_ref,location),
                          basis) =
            let
              val (str,exp_str) = check_strexp (strexp,basis)
	      val (str_ass, ty_ass) =
		Assemblies.new_assemblies_from_basis_inc_sig basis
	      (* Here we want to stop after signature elaboration 
                 on any error *)
	      val _ = (sigstr_ass := str_ass;
		       sigty_ass := ty_ass)
	      val (sigma,_) =
		error_wrap
		error_info
		(fn options =>
		 fn (sigexp,basis,location) =>
		 (check_sigexp_closed (sigexp,basis,location))
		 handle WellFormed sigma =>
		   (report_error
		    (Info.RECOVERABLE, location,
		     "Constraining signature is not well-formed");
		    (sigma,sigma))
		      | TypeExplicit sigma =>
			  (report_error
			   (Info.RECOVERABLE, location,
			    "Constraining signature is not type-explicit");
			   (sigma,sigma))
		      | RespectEquality sigma =>
			  (report_error
			   (Info.RECOVERABLE, location,
 		           "Constraining signature does not respect equality");
			   (sigma,sigma)))
		(sigexp,basis,location)

	      val sigma' as BasisTypes.SIGMA (names',str') = 
                                 Sigma.sig_copy (sigma,is_separate)
                                                (Basis.basis_level basis)
	      val exp_str' = Env.expand_str str'
	      val exp_sigma' = BasisTypes.SIGMA(names',exp_str')
	      val completion_env = make_completion_env (basis,exp_str',exp_str)
	      val (realise, do_coerce, debugger_str') =
	        sigmatch (location,completion_env,
			  Basis.context_level (Basis.basis_to_context basis),
			  exp_sigma',exp_str)
(*
              val _ =
                (case debugger_str of
                   SOME(debugger_str) => debugger_str := debugger_str'
                 | _ => ();
		     case debugger_str'' of
		       SOME(debugger_str'') =>
			 debugger_str'' := SOME(str')
		     | _ => ())
*)
	    in
	      if realise then ()
              else
		report_error
                (Info.RECOVERABLE, location,
                 concat ["Structure does not match signature"]);
 		if do_coerce then coerce_ref := true else ();
		  if abs then
		    let val BasisTypes.SIGMA(_,abs_str) =
		      Sigma.abstract_sigma sigma 
                                          (Basis.basis_level basis)
		    in 
                      (abs_str,Env.expand_str abs_str)
		    end
		  else
		    (str',Env.expand_str str')
	    end
              

	  (* ****** Structure-level Declarations ****** *)

	  (* *** rule 57 *** *)

        and check_strdec (Absyn.DECstrdec dec,basis) =
	  let val env = check_dec (dec,Basis.basis_to_context basis)
	  in
	    Valenv.resolve_overloads
	    error_info
	    (env, options);
            env
	  end

	  (* *** rule 58 *** *)

	  | check_strdec (Absyn.STRUCTUREstrdec strbindlist,basis) =
	    Env.SE_in_env (check_strbinds (strbindlist, basis,false))

	  (* *** Abstractions *** *)

	  | check_strdec (Absyn.ABSTRACTIONstrdec strbindlist,basis) =
	    Env.SE_in_env (check_strbinds (strbindlist, basis,true))

	  (* *** rule 59 *** *)

	  | check_strdec (Absyn.LOCALstrdec (strdec1,strdec2),basis) =
	    let
              val new_env = check_strdec (strdec1,basis)
	    in
	      check_strdec (strdec2, Basis.basis_plus_env (basis,new_env))
	    end

	  (* *** rules 60 and 61 *** *)

	  | check_strdec (Absyn.SEQUENCEstrdec strdeclist,basis) =
	    let
	      fun check_one ((basis,env),strdec) =
		let
		  val env' = check_strdec(strdec, basis)
		  val new_env = Env.env_plus_env(env, env')
		  val new_basis = Basis.basis_plus_env(basis, env')
		in
		  (new_basis, new_env)
		end
	      val (_,env) = Lists.reducel check_one ((basis,Env.empty_env),strdeclist)
	    in
	      env
	    end

        (* *** Structure Bindings *** *)

        (* *** rule 62 *** *)

        (* This function should be made tail recursive with reducel *)
	and check_strbinds ([],basis,do_abstraction) =
	  Strenv.empty_strenv

	  | check_strbinds ((strid,NONE,strexp,coerce_ref,_,_,
                             debugger_str)::strbinds,
			    basis as BasisTypes.BASIS (_,_,_,_,ENV (se,_,_)),
			    do_abstraction) =
	    let
	      val (str,strexp') = check_strexp (strexp,basis)
	      val (m,env) = get_name_and_env ("check_strexp",strexp')
		
	      (* we always generate new names for structures so dont need
		 to extend the basis nameset *)
	      val se' =
		check_strbinds (strbinds,basis,do_abstraction)
	    in
              (case debugger_str of
                 SOME(debugger_str) =>
                   debugger_str := SOME(str)
               | _ => ();
		   Strenv.add_to_se (strid,str,se'))
	    end

	  | check_strbinds ((strid,SOME (sigexp,abs),strexp,
                             coerce_ref,location,debugger_str,debugger_str'')::
			    strbinds,
			    basis,
			    do_abstraction) =
	    let
              val _ =
                if generate_moduler_debug then
                  print("\n STRBIND "^ Ident.Location.to_string location)
                else ()
	      val (str,exp_str) = check_strexp (strexp,basis)
	      (* This is a diabolical case. We need assemblies here *)
	      (* We even need the signature part, in case we're in a functor *)
	      val (str_ass, ty_ass) =
		Assemblies.new_assemblies_from_basis_inc_sig basis
	      (* Here we want to stop after signature elaboration
                 on any error *)
	      val _ = (sigstr_ass := str_ass;
		       sigty_ass := ty_ass)
	      val (sigma,_) =
		error_wrap
		error_info
		(fn options =>
		 fn (sigexp,basis,location) =>
		 (check_sigexp_closed (sigexp,basis,location))
		 handle WellFormed sigma =>
		   (report_error
		    (Info.RECOVERABLE, location,
		     "Constraining signature is not well-formed");
		    (sigma,sigma))
		      | TypeExplicit sigma =>
			  (report_error
			   (Info.RECOVERABLE, location,
			    "Constraining signature is not type-explicit");
			   (sigma,sigma))
		      | RespectEquality sigma =>
			  (report_error
			   (Info.RECOVERABLE, location,
			   "Constraining signature does not respect equality");
			   (sigma,sigma)))
		(sigexp,basis,location)

	      val sigma' as BasisTypes.SIGMA (names',str') = 
                                  Sigma.sig_copy (sigma,is_separate)
                                                 (Basis.basis_level basis)
	      val exp_str' = Env.expand_str str'
	      val exp_sigma' = BasisTypes.SIGMA(names',exp_str')
	      (* This recursion is in the wrong place *)
	      val se' = check_strbinds (strbinds,basis, do_abstraction)
	      val completion_env = make_completion_env (basis,exp_str',exp_str)
	
	      val (realise, do_coerce, debugger_str') =
	        sigmatch (location,completion_env,
			  Basis.context_level (Basis.basis_to_context basis),
			  exp_sigma',exp_str)
              val _ =
                (case debugger_str of
                   SOME(debugger_str) => debugger_str := debugger_str'
                 | _ => ();
		     case debugger_str'' of
		       SOME(debugger_str'') =>
			 debugger_str'' := SOME(str')
		     | _ => ())
	    in
	      if realise then ()
              else
		report_error
                (Info.RECOVERABLE, location,
                 concat ["Structure ",IdentPrint.printStrId strid,
                          " does not match signature"]);
		if do_coerce then coerce_ref := true else ();
		  if do_abstraction then
		    let val BasisTypes.SIGMA(_,abs_str) =
		      Sigma.abstract_sigma sigma 
                                           (Basis.basis_level basis)
		    in Strenv.add_to_se (strid,abs_str,se')
		    end
		  else
		    Strenv.add_to_se (strid,str',se')
	    end

        (* *** Signature Expressions *** *)

	(* *** rule 63 *** *)

	and check_sigexp_open (Absyn.NEWsigexp (spec,_),basis) =
	  let
	    val m = METASTRNAME (ref (NULLNAME (Types.make_stamp ())))
	    val (env, _) = check_spec (spec,basis)
	    val str = STR(m,ref NONE,env)
	    val exp_str = Env.expand_str str
	    val ENV (se,te,_) = get_env_or_crash ("expand_str",exp_str)
	    val type_offspring =
	      Assemblies.collectTypeOffspring (te,Assemblies.findTypeOffspring(m,!sigstr_ass))
	  in
	    sigstr_ass :=
	    Assemblies.add_to_StrAssembly
	    (m,
	     Assemblies.collectStrOffspring (se,Assemblies.findStrOffspring(m,!sigstr_ass)),
	     type_offspring,!sigstr_ass);
	    (str,exp_str)
	  end

        (* *** rule 64 *** *)

	  | check_sigexp_open (Absyn.OLDsigexp (sigid,_,location),basis) =
	    (let
	      val sigma = Basis.lookup_sigid (sigid,basis)

             (****
              It is necessary to copy the signature because sharing is done
              destructively.
              ****)
	      val BasisTypes.SIGMA (names',str') = 
                Sigma.sig_copy (sigma,is_separate) 
                               (Basis.basis_level basis)

	      val exp_str' = Env.expand_str str'
                          (* Only necessary for interpreter compilation *)

	      val (m,env) = get_name_and_env ("expand_str",exp_str')
	
	      val (sigstr_ass',sigty_ass') = Assemblies.newAssemblies (m,env)

	    (* put the old (uncopied) structure in the interface slot *)
	    in
	      (sigstr_ass := Assemblies.unionStrAssembly(!sigstr_ass,
                                                         sigstr_ass');
	       sigty_ass := Assemblies.unionTypeAssembly(!sigty_ass,
                                                         sigty_ass');
	       (str',exp_str'))
	    end
	  handle Basis.LookupSigId =>
	    (report_error (Info.RECOVERABLE, location,
			   "impossible type error 7: unbound signature "^
                           IdentPrint.printSigId sigid);
	     make_dummy_structures()))

          | check_sigexp_open (Absyn.WHEREsigexp (sigexp,typbinds),basis) =
            let
              val (str,exp_str) = check_sigexp_open (sigexp,basis)
              val env = case exp_str 
                          of STR (_,_,env) => env 
                           | _ => copystr_crash "WHEREsigexp copystr"
              fun check_one (tyvarlist,tycon,ty,location) =
                let
                  val context = Basis.basis_to_context basis
                  val atype = check_type (ty,context)
                  val tyfun = Types.make_tyfun (tyvarlist,atype)
                in
                  (tycon,tyfun,atype,location)
                end
              val tysubs = map check_one typbinds
              fun apply_tysub (longtycon,tyfun,ty,location) =
                let
                  val Datatypes.TYSTR (tyfun',valenv) = Env.lookup_longtycon (longtycon,env)
                in
                  if Types.equalityp tyfun'
                  andalso not (Types.equalityp tyfun)
                  then report_error
                        (Info.RECOVERABLE, location,
                         "The type " ^ (Types.print_type options ty) ^
                         " does not admit equality.\n")
                  else ();
                  if Types.null_tyfunp tyfun'
                    then
                      if Types.tyfun_eq (tyfun,tyfun') then
                        report_error
                        (Info.RECOVERABLE, location,
                         "circular where type")
                      else
                        case Types.meta_tyname tyfun' of
                          METATYNAME (tyfunref,s,i,b1,ve,b2) =>
                            tyfunref := tyfun
                        | _ => Crash.impossible "apply_tysub"
                  else 
                    report_error 
                    (Info.RECOVERABLE, location,
                     "where type not with flexible type")
                end
              handle Basis.LookupTyCon tycon =>
                report_error
                (Info.RECOVERABLE, location,
                 "where type: " ^ IdentPrint.unbound_longtycon_message (tycon,longtycon))
                   | Basis.LookupStrId strid =>
                       (report_error
                        (Info.RECOVERABLE, location,
                         "where type: " ^ IdentPrint.tycon_unbound_strid_message (strid,longtycon)))
            in
              Lists.iterate apply_tysub tysubs;
              (str,exp_str)
            end
                 
      (* *** rule 65 *** *)

	and check_sigexp_closed (sigexp,basis,location) =
	  let
	    val BasisTypes.BASIS(_,basis_names,_,_,_) = basis

	    val (str,exp_str) = check_sigexp_open(sigexp,basis)

	    val nameset = Sigma.new_names_of exp_str

	    val real_nameset = Nameset.diff(nameset,basis_names)

	    val sigma = BasisTypes.SIGMA(real_nameset,str)
	    val exp_sigma = BasisTypes.SIGMA(real_nameset, exp_str)

	    fun tystr_respect_equality (_, TYSTR (tyfun,VE (_,amap))) =
	      let
		fun eq_scheme (valid, s) =
		  Scheme.equalityp s orelse
		  (report_error
		   (Info.RECOVERABLE, location,
		    Types.print_type options
		    (#1(Types.argres 
                        (#1(Scheme.instantiate 
                            (1,s,location,false))))) ^
		    " does not admit equality: constructor is " ^
		    IdentPrint.printValId print_options valid);
		   false)
	      in
		if Types.equalityp tyfun then
		  (NewMap.forall eq_scheme amap)
		else true
	      end

	    fun se_respect_equality(_, str) =
	      let fun get_env (STR(_,_,env)) = env
		    | get_env (COPYSTR ((smap,tmap),str')) =
		      copystr_crash "se_respect_equality"
	      in
		env_respect_equality (get_env str)
	      end

	    and env_respect_equality (env as ENV (se as SE amap,
						  te as TE amap',_)) =
	      Env.empty_envp env orelse
	      aswell(NewMap.forall se_respect_equality amap,
		     NewMap.forall tystr_respect_equality amap')

	    fun respect_equality (BasisTypes.SIGMA (names,STR (_,_,env))) =
	      env_respect_equality env
	      | respect_equality _ = copystr_crash "respect_equality"

	    fun max_eq_pred (_, TYSTR (atyfun,VE (_,amap))) =
	      if (Types.equalityp atyfun) andalso 
                  not (NewMap.forall eq_scheme amap)
		then Types.make_false atyfun
	      else
		true

	    fun se_equality_principal (_,STR (_,_,env)) =
	      env_equality_principal env
	      | se_equality_principal _ = copystr_crash "se_equality_principal"

                (* note: although signatures should be equality principal
                   in both old and new definitions, the new definition
                   should not maximise equality, especially after Where
                   type instantiation. *)

	    and env_equality_principal (ENV (SE amap,TE amap',_)) =
	       if old_definition then NewMap.forall max_eq_pred amap' 
                 andalso NewMap.forall se_equality_principal amap
               else true


	    fun equality_principal 
                       (sigma as BasisTypes.SIGMA (names,STR(_,_,env))) =
	      let
		val tynames = Nameset.tynames_of_nameset names
		val _ = Lists.iterate
		  (fn tyname =>
		   let
		     val tyfun = ETA_TYFUN tyname
		   in
		     if Types.null_tyfunp tyfun andalso
		       not(Valenv.empty_valenvp
			   (#1(Assemblies.lookupTyfun(tyfun, !sigty_ass))))
                       andalso old_definition
		       then
			 Types.make_true tyname else ()
		   end)
		  tynames
	      in
		while not (env_equality_principal env) do ();
		  sigma
	      end

	      | equality_principal _ = copystr_crash "equality_principal"

	    (* this should probably report errors as it goes *)
	    fun well_formed (BasisTypes.SIGMA (names,STR (_,_,env))) =
	      let
		fun check_env (ENV (SE amap,_,_)) =
		  NewMap.forall check_one amap
		and check_one (strid,STR(m,_,env)) =
		  if
		    (* it is a local name *)
		    Nameset.member_of_strnames (m,names)
		    then
		      (* so check recursively *)
		      check_env env
		  else
		    (* check all substructures are non-local *)
		    Nameset.emptyp
		    (Nameset.intersection (names,
					   Sigma.names_of_env env))
		  | check_one _ = copystr_crash "check"
	      in
		check_env env
	      end
	      | well_formed _ = copystr_crash "well_formed"

	    fun te_type_explicit (names,[],name_copies) = name_copies
	      | te_type_explicit (names,(tycon,TYSTR(tyfun,_))::tycons,
				  name_copies) =
		if Types.null_tyfunp tyfun then
		  let
		    val type_name = Types.name tyfun
		    val name_copies' =
		      te_type_explicit (names,tycons,name_copies)
		  in
		    if Nameset.member_of_tynames (type_name, names) then
		      type_name:: name_copies'
		    else name_copies
		  end
		else te_type_explicit (names,tycons,name_copies)

	    fun se_type_explicit (names,[],name_copies) = name_copies
	      | se_type_explicit (names,(_,STR(_,_,env))::stridenvs,name_copies) =
		se_type_explicit (names,stridenvs,env_type_explicit (names,env,name_copies))
	      | se_type_explicit _ = copystr_crash "se_type_explicit"

	    and env_type_explicit (names,ENV (SE amap,TE amap',_),
				   name_copies) =
	      let
		val strid_str_list = NewMap.to_list amap
		val tycon_tystr_list = NewMap.to_list amap'
		val name_copies' = te_type_explicit (names,tycon_tystr_list,
						     name_copies)
	      in
		se_type_explicit (names,strid_str_list,name_copies')
	      end

	    fun type_explicit (BasisTypes.SIGMA (names,STR (_,_,env))) =
              let
                val name_copies = env_type_explicit (names,env,[])
              in
                Nameset.nameset_eq
                (Nameset.tynames_in_nameset((Nameset.tynames_of_nameset names),Nameset.empty_nameset ()),
                 Nameset.tynames_in_nameset(name_copies,Nameset.empty_nameset ()))
              end
	      | type_explicit _ = copystr_crash "type_explicit"
	  in
	    (* Only the last check ("equality principal") modifies the structure, and *)
	    (* then it is through modifications of tynames *)
            ignore
	    (if not (respect_equality exp_sigma)
	       then raise RespectEquality sigma
	     else ();
	     if not (type_explicit exp_sigma)
	       then raise TypeExplicit sigma
	     else ();
	     if not (well_formed exp_sigma)
	       then raise WellFormed sigma
	     else ();
          (* This should work by side-effecting the names in the sigma and the *)
          (* expanded sigma *)
	     equality_principal exp_sigma);
	    set_intref(sigexp,str);
	    (sigma,exp_sigma)
	  end

    (* *** Signature Declarations *** *)

    (* *** rules 66, 67 and 68 are parsed away *** *)

    (* *** Signature Bindings *** *)

    (* *** rule 69 *** *)

	and check_sigbind (Absyn.SIGBIND [],basis,sigenv, _) = sigenv

	  | check_sigbind (Absyn.SIGBIND ((sigid,sigexp,location)::sigbinds),basis,
			   sigenv, ass as (str_ass, ty_ass)) =
	    let
	      val _ = sigstr_ass := str_ass
	      val _ = sigty_ass := ty_ass
	      val (sigma as BasisTypes.SIGMA (names,str),BasisTypes.SIGMA(_,exp_str)) =
		(check_sigexp_closed (sigexp,basis,location))
		handle
		WellFormed sigma =>
		  (report_error
		   (Info.RECOVERABLE, location,
		    "Signature " ^ IdentPrint.printSigId sigid ^
		    " is not well-formed");
		   (sigma,sigma))
	      | TypeExplicit sigma =>
		  (report_error
		   (Info.RECOVERABLE, location,
		    "Signature "  ^ IdentPrint.printSigId sigid ^
		    " is not type-explicit");
		   (sigma,sigma))
	      | RespectEquality sigma =>
		  (report_error
		   (Info.RECOVERABLE, location,
		    "Signature "  ^ IdentPrint.printSigId sigid ^
		    " does not respect equality");
		   (sigma,sigma))
	    in
	      Basis.add_to_sigenv(sigid,BasisTypes.SIGMA(names,str),
				  check_sigbind(Absyn.SIGBIND sigbinds,
						basis,sigenv, ass))
	    end

    (* *** Specifications *** *)

    (* *** rule 70 *** *)

	and check_spec (Absyn.VALspec (valdesclist,location),basis) =
	  let
	    val context = Basis.basis_to_context basis
	    val new_ve = check_valdesc (valdesclist,context,location)
	    val new_env =
	      Env.VE_in_env (Basis.close 
                             (error_info,options,location)
                             (Basis.context_level context,new_ve,[],Set.empty_set,false))
	  in
	    (new_env, new_env)
	  end

      (* *** rule 71 *** *)

	  | check_spec (Absyn.TYPEspec typedesclist,basis) =
	    let
	      val new_te = check_typdesc (typedesclist,
					  Basis.basis_to_context basis,
					  false)
	      val new_env = Env.TE_in_env new_te
	    in
	      (new_env, new_env)
	    end

      (* *** rule 72 *** *)
      (* the type functions are constructed to admit equality in
       check_typdesc *)

	  | check_spec (Absyn.EQTYPEspec typedesclist,basis) =
	    let
	      val new_te = check_typdesc (typedesclist,
					  Basis.basis_to_context basis,
					  true)
	      val new_env = Env.TE_in_env new_te
	    in
	      (new_env, new_env)
	    end

      (* *** rule 73 *** *)

	  | check_spec (Absyn.DATATYPEspec datdesclist,
			basis as BasisTypes.BASIS (_,_,_,_,ENV (_,te,_))) =
	    let
	      fun make_dummy_te ([],te) = te
		| make_dummy_te ((tyvars,tycon,condescs)::datadescs,te) =
		  make_dummy_te (datadescs,
				 Tyenv.add_to_te
				 (te,tycon,
				  TYSTR
				  (Types.make_eta_tyfun
				   (METATYNAME (ref (NULL_TYFUN
						     (Types.make_stamp(),(ref(TYFUN(NULLTYPE,0))))),
						IdentPrint.printTyCon
						tycon,
						length tyvars,
						ref true,
						ref empty_valenv,
						ref false)),
				   empty_valenv)))

	      val new_context =
		Basis.context_plus_te (Basis.basis_to_context basis,
				       make_dummy_te (datdesclist,te))
	      val (new_ve,new_te) =
		check_datdesc (datdesclist,new_context,(empty_valenv,
							Tyenv.empty_tyenv))

	      (* can we use the similar function above instead of this? *)
	      fun max_eq (TE amap) =
		while
		  not (NewMap.forall
		       (fn (_, TYSTR (atyfun,VE (_,amap')))
			=>
			  if Types.equalityp atyfun then
			    NewMap.forall eq_scheme amap' orelse
			    Types.make_false atyfun
			  else
			    true)
		       amap)
		  do
		  ()
	      val _ = max_eq new_te

	      val new_env =
		if has_unbounds_te new_te orelse has_unbounds_ve new_ve then
		  Env.empty_env
		else
		  Env.VE_TE_in_env(new_ve,new_te)
	    in
	      (new_env, new_env)
	    end


       (* *** rule 72 of SML'96 definition *** *)


	  | check_spec (Absyn.DATATYPEreplSpec (location,tycon, longtycon,
                                                associatedConstructors),
			basis as BasisTypes.BASIS (_,_,_,_,
                                                   ENV (_,te as TE amap,_))) =

	    (let
              val tyStr as Datatypes.TYSTR(tyFun,valEnv) =
                Basis.lookup_longtycon(longtycon,Basis.basis_to_context basis)
              (* Basis exceptions handled at end of rule *)
                
                        
              fun valenvToConstructorList (Datatypes.VE(_,amap)) =
                map (fn (valid,Datatypes.SCHEME(_,(ty,_))) => 
                                    (valid,SOME ty,Location.UNKNOWN)
                      | (valid,Datatypes.UNBOUND_SCHEME(ty,_)) => 
                                    (valid, NONE,Location.UNKNOWN)
                      | _ => Crash.impossible 
                          "mod_rules:constructors with overloaded typescheme")
                    (Datatypes.NewMap.to_list_ordered amap)
                
              
              val _ = associatedConstructors := 
                                 SOME (valenvToConstructorList valEnv)

                 (* record the list of constructors associated with this 
                    datastructure for future reference (i.e., lambda
                    toplevel printing) *)

              val new_te = Tyenv.add_to_te(Tyenv.empty_tyenv,tycon,tyStr)
              val new_env = ENV(Strenv.empty_strenv,new_te,valEnv)
            in
              (new_env,new_env)
            end
          handle Basis.LookupTyCon tycon =>
            (report_error 
             (Info.RECOVERABLE, location,
              "The type constructor "^(IdentPrint.printTyCon tycon)
              ^" on the right hand side of the datatype replication\
               \ does not exist.");(Env.empty_env,Env.empty_env))
            
               | Basis.LookupStrId strId =>
                   (report_error
                    (Info.RECOVERABLE, location,
                     "Structure "^ (IdentPrint.printStrId strId)
                     ^" does not exist.");(Env.empty_env,Env.empty_env)))
               
               


      (* *** rule 74 *** *)

	  | check_spec (Absyn.EXCEPTIONspec exdesclist,basis) =
	    let
	      val ve = check_exdesc(exdesclist,Basis.basis_to_context basis)
	      val new_env = Env.VE_in_env ve
	    in
	      (new_env, new_env)
	    end

      (* *** rule 75 *** *)

	  | check_spec (Absyn.STRUCTUREspec strdesclist,basis) =
	    let
	      val new_env = Env.SE_in_env(check_strdesc (strdesclist,basis))
	    in
	      (new_env, new_env)
	    end

      (* *** rule 76 *** *)

	  | check_spec (Absyn.SHARINGspec (spec,shareqlist),basis) =
	    let
	      val (env,exp_env) = check_spec (spec,basis)
              val new_basis = Basis.basis_plus_env (basis,env)
              val _ = check_shareq (shareqlist,exp_env,basis,new_basis)
	    in
              (env,exp_env)
	    end

  (* Note: the above check_shareq clause takes both bases because it
     has to account for the different conception of sharing between the two
     definitions.  In the old definition, a sharing constraint was simply
     another spec, sequentially composed after the specs that were being
     shared.  Hence the basis would be updated by the first spec before
     the sharing was elaborated.  In the new definition, the sharing
     constraint is a spec *modifier*, and so the basis is not updated
     until after the spec (and then elsewhere).   This makes a difference
     because type names in the new definition can only be shared if they
     don't already occur in the basis.  See sec G.3 of revised defn.
     This fixes bug 1620. See the function check_shareq. *)



      (* *** rule 77 *** *)

	  | check_spec (Absyn.LOCALspec (spec1,spec2),basis) =
	    let
	      val (new_result, _) = check_spec (spec1,basis)
	    in
	      check_spec (spec2,Basis.basis_plus_env (basis, new_result))
	    end

      (* *** rule 78 *** *)


	  | check_spec (Absyn.OPENspec(longstridlist,location),basis) =
	    let
	      fun do_one (env,longstrid) =
		let
		  val newenv =
		    get_env_or_crash
		    ("resolve_top_level",
		     Env.resolve_top_level(Basis.lookup_longstrid (longstrid, basis)))
		in
		  Env.env_plus_env (env,newenv)
		end
	      handle Basis.LookupStrId strid =>
		(report_error
		 (Info.RECOVERABLE, location,
		  IdentPrint.strid_unbound_strid_message(strid, longstrid, print_options));
		 env)
	      val new_env = Lists.reducel do_one (Env.empty_env,longstridlist)
	    in
	      (* Fix here for NJ weird open *)
	      (if nj_signatures then Env.empty_env else new_env, new_env)
	    end

      (* *** rule 79 *** *)

	  | check_spec (Absyn.INCLUDEspec (sigexp,location),basis) =
	    let
	      fun new_instances (STR (strname, mlvalue, ENV (strenv, tyenv, VE (n,map)))) =
		let
		  fun new_instance (SCHEME (n, (ty, SOME (sch,_)))) =
		    SCHEME (n, (ty, SOME (sch, ref NONE)))
		    | new_instance (UNBOUND_SCHEME (ty,SOME (sch,_))) =
		      UNBOUND_SCHEME (ty, SOME (sch, ref NONE))
		    | new_instance scheme = scheme
		in
		  STR(strname, mlvalue, ENV (strenv, tyenv,
					     VE (n, NewMap.map (fn (_,tysch) => new_instance tysch) map)))
		end
		| new_instances (COPYSTR((strmap,tynmap),str)) =
		  COPYSTR((strmap,tynmap),new_instances str)

	      fun do_one sigexp =
		let
		  val (BasisTypes.SIGMA (names,str),_) = 
                         check_sigexp_closed (sigexp, basis, location)
		  val str = new_instances str
		  val (_,new_strnames,new_tynames) =
		    Nameset.new_names_from_scratch names
                                       (Basis.basis_level basis)
		  val str' =
		    Env.resolve_top_level (COPYSTR((new_strnames,new_tynames),
                                                   str))
		  val env1 = get_env_or_crash ("resolve_top_level",str')
		  val (m,exp_env) = get_name_and_env("expand_str",
						     Env.expand_str str')
		  val (sigstr_ass',sigty_ass') = 
                                 Assemblies.newAssemblies (m,exp_env)
		in
		  sigstr_ass := Assemblies.unionStrAssembly
                                                 (!sigstr_ass,sigstr_ass');
		  sigty_ass := Assemblies.unionTypeAssembly
                                                 (!sigty_ass,sigty_ass');
		  env1
		end
	      val new_env = do_one sigexp
	    in
	      (new_env, new_env)
	    end


      (* *** rules 80 and 81 *** *)

	  | check_spec (Absyn.SEQUENCEspec [],basis) =
	    (Env.empty_env, Env.empty_env)

	  | check_spec (Absyn.SEQUENCEspec speclist,basis) =
	    let
	      fun do_one ((result, env, basis),spec) =
		let
		  val (result', env') = check_spec(spec,basis)
		  val new_result = Env.env_plus_env(result, result')
		  (* What we'll return *)
		  val new_basis = Basis.basis_plus_env(basis, env')
		  (* What we carry on elaborating in *)
		  val new_env = Env.env_plus_env(env, env')
		in
		  (new_result, new_env, new_basis)
		end
	      val (new_result, new_env, _) =
		Lists.reducel do_one ((Env.empty_env, Env.empty_env, basis), speclist)
	    in
	      (new_result, new_env)
	    end

	(* *** Value Descriptions *** *)

	(* *** rule 82 *** *)

	and check_valdesc (l,context,location) =
	  let
	    fun do_one ((ve,context),(valid,ty,tyvarset)) =
	      let
		val tyvars_scoped_here = Set.setdiff (tyvarset,Basis.get_tyvarset context)
		val new_context = Basis.context_plus_tyvarset (context, tyvars_scoped_here)
		val atype = check_type (ty,new_context)
		val instance = NONE
		val ascheme = Scheme.make_scheme ([],(atype,instance))
	      in
                check_valid_ok (valid,location);
		(Valenv.add_to_ve (valid,ascheme,ve), new_context)
	      end
	    val (new_ve,_) = Lists.reducel do_one ((empty_valenv,context),l)
	  in
	    new_ve
	  end

    (* *** Type Descriptions *** *)

    (* *** rule 83 *** *)

	and check_typdesc (l,context,eq) =
	  let
	    fun do_one (te,(tyvarlist,tycon)) =
	      let
		val tyfun =
		  Types.make_eta_tyfun
		  (METATYNAME (ref (NULL_TYFUN(Types.make_stamp(),(ref(TYFUN(NULLTYPE,0))))),
			       IdentPrint.printTyCon tycon,
			       length tyvarlist,
			       ref eq,
			       ref empty_valenv,
			       ref false))
	      in
		Tyenv.add_to_te (te,tycon,TYSTR (tyfun,empty_valenv))
	      end

	  in
	    Lists.reducel do_one (Tyenv.empty_tyenv,l)
	  end

    (* *** Datatype Descriptions *** *)

    (* *** rule 84 *** *)

	and check_datdesc ([],_,(ve,te)) = (ve,te)

	  | check_datdesc ((tyvarlist,tycon,condescs)::datdescs,
			   context,
			   (ve,te)) =
	    let
	      val new_context = Basis.context_plus_tyvarlist (context,tyvarlist)
	      val TYSTR (tyfun,_) = Basis.lookup_tycon (tycon,new_context)
		handle Basis.LookupTyCon tycon =>
		  Crash.impossible ("Unbound type constructor in check_datdesc "
				    ^ IdentPrint.printTyCon tycon)
	      val tyvartypes = (map (fn x => check_type (Absyn.TYVARty x,new_context)) tyvarlist)
	    in
	      check_datdesc (datdescs,new_context,
			     check_condesc (condescs,
					    tycon,
					    tyfun,
					    Types.apply (tyfun,tyvartypes),
					    tyvartypes,
					    new_context,
					    empty_valenv,
					    (ve,te)))
	    end

    (* *** rule 85 *** *)

	and check_condesc ([],tycon,tyfun,tycon_type,tyvartypes,
			   acontext,conenv,(ve,te)) =
	  (sigty_ass := Assemblies.add_to_TypeAssembly (tyfun,conenv,1,!sigty_ass);
	   let
	     val valenv_ref = case tycon_type of
	       CONSTYPE(_, METATYNAME{5=valenv_ref, ...}) => valenv_ref
	     | _ => Crash.impossible"bad tycon_type in signature"
	   in
	     (valenv_ref := conenv;
	      (ve,(Tyenv.add_to_te (te, tycon,TYSTR (tyfun,conenv)))))
	   end)

	  | check_condesc ((valid,NONE,location)::condescs,
			   tycon,tyfun,tycon_type,tyvartypes,
			   acontext,conenv,(ve,te)) =
	    let
	      val tyscheme =
		Scheme.make_scheme (tyvartypes,(tycon_type,NONE))
	      val new_ve = Valenv.add_to_ve (valid,tyscheme,ve)
	      val new_conenv = Valenv.add_to_ve (valid,tyscheme,conenv)
	    in
              check_valid_ok (valid,location);
	      check_condesc (condescs,tycon,tyfun,tycon_type,tyvartypes,
			     acontext,new_conenv,(new_ve,te))
	    end

	  | check_condesc ((valid,SOME aty,location)::condescs,
			   tycon,tyfun,tycon_type,tyvartypes,
			   acontext,conenv,(ve,te)) =
	    let
	      val atype = check_type (aty,acontext)
	      val tyscheme = Scheme.make_scheme
		(tyvartypes,(FUNTYPE (atype,tycon_type),NONE))
	      val new_ve = Valenv.add_to_ve (valid,tyscheme,ve)
	      val new_conenv = Valenv.add_to_ve (valid,tyscheme,conenv)
	    in
              check_valid_ok (valid,location);
	      check_condesc (condescs,tycon,tyfun,tycon_type,tyvartypes,
			     acontext,new_conenv,(new_ve,te))
	    end

    (* *** Exception Descriptions *** *)

    (* *** rule 86 *** *)

	and check_exdesc (exdescs,context) =
	  let
	    fun do_one (ve, (excon,NONE,location)) =
              (check_valid_ok (excon,location);
               Valenv.add_to_ve (excon,Scheme.make_scheme ([],(Types.exn_type,
                                                               NONE)),ve))
	      | do_one (ve, (excon,SOME aty,location)) =
		let
		  val atype =
		    if Absyn.has_tyvar (aty) then
		      (report_error
		       (Info.RECOVERABLE, location,
			concat ["Exception description of ",
				 IdentPrint.printValId print_options excon,
				 " contains a type variable"]);
		       fresh_tyvar (context, false, false))
		    else
		      check_type (aty,context)
		in
                  check_valid_ok (excon,location);
		  if Types.type_has_unbound_tyvars atype then
		    ve
		  else
		    Valenv.add_to_ve (excon,
				      Scheme.make_scheme([],(FUNTYPE (atype,Types.exn_type),
							     NONE)),
				      ve)
		end
	  in
	    Lists.reducel do_one (empty_valenv,exdescs)
	  end

    (* *** Structure Descriptions *** *)

    (* *** rule 87 *** *)

	and check_strdesc (strdescs, basis) =
	  let
	    fun do_one (se,(strid,sigexp)) =
	      let
		val (str,_) = check_sigexp_open (sigexp,basis)
	      in
		Strenv.add_to_se (strid,str,se)
	      end
	  in
	    Lists.reducel do_one (Strenv.empty_strenv,strdescs)
	  end

    (* *** Sharing Equations *** *)

    (* *** rule 88 *** *)

    (* The syntax does not allow sharing of fewer than two structures *)
    (* or two types. *)

	and check_shareq (l,env,basis,new_basis) =
	  let
	    fun do_one (Absyn.STRUCTUREshareq stridlist,location) =
              if old_definition then check_str_share (stridlist,new_basis,
                                                      location)
              else new_check_str_share (stridlist,basis,new_basis,location)
	      | do_one (Absyn.TYPEshareq tyconlist,location) =
		check_type_share (tyconlist,env,
                                  if old_definition then new_basis
                                    else basis,location)

                (* see comment on rule 76 *)

	  in
	    Lists.iterate do_one l
	  end





	and check_str_share (sharelist,
                             basis as BasisTypes.BASIS(_,nameset,_,_,env),
                             location) =
	  let
	    fun do_two ((lstrid,STR(m,_,_)),(lstrid',STR(m',_,_))) =
	      if circularp (m,m',!sigstr_ass)
		then
		  report_error
		  (Info.RECOVERABLE, location,
		   concat ["Sharing ",
                           IdentPrint.printLongStrId lstrid,
                           " and ",
                           IdentPrint.printLongStrId lstrid',
                           " creates a cycle"])
	      else
		(let
		   val (share_successful,sigstr_ass',sigty_ass') =
		     Share.share_str (m,m',!sigstr_ass,!sigty_ass,nameset)
		 in
		   if share_successful
		     then (sigstr_ass := sigstr_ass';
			   sigty_ass := sigty_ass')
		   else
		     () (* do we need to print a message here? *)
		 end
	       handle Share.ShareError s =>
		 report_error
		 (Info.RECOVERABLE, location,
		  concat ["Failed to share structures ",
			   IdentPrint.printLongStrId lstrid, " and ",
			   IdentPrint.printLongStrId lstrid', ":\n  ", s]))
              | do_two _ = ()

	    fun get_structure_name_from_str((smap, _), str as STR(m, r, e)) =
	      STR(Strnames.strname_copy(m, smap), r, e)
	      | get_structure_name_from_str(maps, COPYSTR(maps', str)) =
		get_structure_name_from_str(Env.compose_maps(maps', maps), str)

	    val get_structure_name_from_str =
	      fn (str as STR _) => str
	       | COPYSTR arg => get_structure_name_from_str arg

	    fun gather_strs ([],acc) = rev acc
	      | gather_strs (lstrid::l,acc) =
		(let
	       (* nice if env was expanded *)
(* This is unnecessary. All we want is the structure name
               val str = Env.expand_str (Env.lookup_longstrid (lstrid,env))
*)
	       val str = get_structure_name_from_str
                                  (Env.lookup_longstrid(lstrid, env))
		 in
		   gather_strs(l,(lstrid,str)::acc)
		 end
	       handle Env.LookupStrId strid =>
		 (report_error
		  (Info.RECOVERABLE, location,
		   IdentPrint.strid_unbound_strid_message
                                        (strid,lstrid,print_options));
		  gather_strs (l,acc)))

	    fun aux (s::(l as s'::_)) = (do_two (s,s');aux l)
	      | aux _ = ()
	  in
	    aux (gather_strs (sharelist,[]))
	  end

           (* note, in the following, we have to look the structure ids
              up in the new basis, and then do the type constructor
              sharing in the old basis. *)


	and new_check_str_share (sharelist,old_basis,new_basis,location) =
	  let
	    val BasisTypes.BASIS(_,old_basis_names,_,_,old_env) = old_basis
	    val BasisTypes.BASIS(_,new_basis_names,_,_,new_env) = new_basis
	    fun gather_strs ([],acc) = rev acc
	      | gather_strs (lstrid::l,acc) =
		(let
                  (* We only really need the type and structure 
                     parts expanded here.  Look up strid in new env *)
                  val str = Env.expand_str(Env.lookup_longstrid 
                                              (lstrid,new_env))
                in
                  gather_strs(l,(lstrid,str)::acc)
                end
                handle Env.LookupStrId strid =>
                  (report_error
                   (Info.RECOVERABLE, location,
                    IdentPrint.strid_unbound_strid_message
                                           (strid,lstrid,print_options));
                   gather_strs (l,acc)))
            fun print_path ([],acc) = concat acc
              | print_path (s::rest,acc) = 
                     print_path (rest,IdentPrint.printStrId s :: "." :: acc)

                     (* the following local references are used to
                      * compute the fixpoint of our sharing checker.
                      * It stores the list of tycons for which
                      * type sharing has failed.  However, since
                      * failures may be due to the fact that
                      * the tycons are built out of others which
                      * haven't yet been shared, we must keep them
                      * ready to try again.  When the fixpoint has
                      * been reached (i.e., !old_share_failures =
                      * !share_failures) then we have finished.
                      *)

            val old_share_failures = ref []
            val share_failures = ref []
            val failure_reasons = ref []

            fun share_tystr (strid1, strid2, path, tycon,TYSTR (tyfun,_),
                             TYSTR (tyfun',_)) =
	      let
                   (* check type names occur in old basis *)

		val (share_successful,sigty_ass') =
		  Sharetypes.share_tyfun (old_definition,tyfun, tyfun',
					  !sigty_ass, old_basis_names)
                   handle Sharetypes.ShareError s =>
                     (share_failures:= tycon::(!share_failures);
                      failure_reasons:= s::(!failure_reasons);
                      (false,!sigty_ass))
	      in
		if share_successful
		  then sigty_ass := sigty_ass'
		else
		  ();
                true
	      end

            fun share_tyenvs (strid,strid',path,TE tymap,TE tymap') =
              (old_share_failures:=[];
               let
                 fun findFixpoint () =
                   (share_failures:=[];
                    failure_reasons:=[];
                    let val answer = 
                      NewMap.forall
                      (fn (tycon,tystr) =>
                       case NewMap.tryApply'(tymap',tycon) of
                         SOME tystr' =>
                           share_tystr (strid,strid',path,tycon,tystr,tystr')
                       | _ => true)
                      tymap
                   in
                     if !old_share_failures = !share_failures
                       then (* finished *)
                         if !share_failures=[]
                           then answer
                         else 
                           let
                             fun makeE([],[]) = ""
                               | makeE([h1],[h2]) =
                                  (IdentPrint.printTyCon h1)^": "^h2^"}"
                               | makeE(h1::t1,h2::t2) =
                                  (IdentPrint.printTyCon h1)^": "^h2^"\n    "^
                                  (makeE(t1,t2))
                               | makeE _ = Crash.impossible "makeE"

                             fun makeErrorMesg() =
                               if Lists.length (!share_failures)=1
                                 then 
                                   "Failed to share type "^
                                   print_path(path,[])^
                                   IdentPrint.printTyCon 
                                         (Lists.hd(!share_failures))^
                                   " because "^(Lists.hd(!failure_reasons))
                               else
                                   "Failed to share types "^
                                   print_path(path,[])^"\n   {"^
                                   makeE(!share_failures,!failure_reasons)
                           in
                             (report_error
                              (Info.RECOVERABLE, location,
                               concat(
                               [makeErrorMesg(),
                                "\n in structures ", 
                                IdentPrint.printLongStrId strid, " and ", 
                                IdentPrint.printLongStrId strid', "."]));
                              false)
                           end
                     else (old_share_failures:= !share_failures;
                           findFixpoint ())
                   end)
               in
                 findFixpoint ()
               end)

            fun share_str (strid',
                           strid,
                           path,
                           STR (m,_,ENV (strenv,tyenv,_)),
                           STR (m',_,ENV (strenv',tyenv',_))) =
              share_strenvs (strid,strid',path,strenv,strenv') andalso
              share_tyenvs (strid,strid',path,tyenv,tyenv')
              | share_str _ =
                Crash.impossible "COPYSTR in share_str"
            and share_strenvs (strid1,strid2,path,SE strmap,SE strmap') =
              NewMap.forall 
              (fn (strid,str) =>
               case NewMap.tryApply'(strmap',strid) of
                 SOME str' => share_str (strid1,strid2,strid::path,str,str')
               | _ => true)
              strmap

            fun do_two ((lstrid,str),(lstrid',str')) =
              share_str (lstrid,lstrid',[],str,str')
            (* This is unpleasantly n squared *)
            (* A better way could be found no doubt *)
	    fun aux (s::rest) = 
              (Lists.iterate (fn s' => do_two (s,s')) rest;
               aux rest)
	      | aux [] = ()
	  in
	    aux (gather_strs (sharelist,[]))
	  end

    (* *** rule 89 *** *)

	and check_type_share (sharelist,env,basis,location) =
	  let
	    val BasisTypes.BASIS(_,basis_names,_,_,_) = basis

	    fun do_two ((ltycon,tyfun),(ltycon',tyfun')) =
	      let
		val (share_successful,sigty_ass') =
		  Sharetypes.share_tyfun (old_definition,tyfun, tyfun',
					  !sigty_ass, basis_names)
		  handle Sharetypes.ShareError s =>
		    (report_error
		     (Info.RECOVERABLE, location,
		      concat
		      ["Failed to share types ",
		       IdentPrint.printLongTyCon ltycon, " and ",
		       IdentPrint.printLongTyCon ltycon', ": ", s]);
		     (false,!sigty_ass))
	      in
		if share_successful
		  then sigty_ass := sigty_ass'
		else
		  ()
	      end

            val context =
              if old_definition then Basis.basis_to_context basis
              else Basis.env_to_context env
	    val (unbound_strid, unbound_tycon) =
	      if old_definition then
		(IdentPrint.tycon_unbound_strid_message,
		 IdentPrint.unbound_longtycon_message)
	      else
		(IdentPrint.tycon_unbound_flex_strid_message,
		 IdentPrint.unbound_flex_longtycon_message)
	    fun gather_tyfuns ([],acc) = rev acc
	      | gather_tyfuns (ltycon::l,acc) =
		(let
		   val TYSTR (tyfun,_) =
		     Basis.lookup_longtycon (ltycon,context)
		 in
		   gather_tyfuns(l,(ltycon,tyfun)::acc)
		 end
		   handle Basis.LookupTyCon tycon =>
		     (report_error
		      (Info.RECOVERABLE, location,
		       unbound_tycon(tycon,ltycon));
		      gather_tyfuns (l,acc))
			| Basis.LookupStrId strid =>
			    (report_error
			     (Info.RECOVERABLE, location,
			      unbound_strid(strid,ltycon));
			     gather_tyfuns (l,acc)))


	    fun aux (s::(l as s'::_)) = (do_two (s,s');aux l)
	      | aux _ = ()
	  in
	    aux (gather_tyfuns (sharelist,[]))
	  end

    (* *** rule 90 *** *)

    (* *** Functor Declarations *** *)
    (* *** rules 96, 97 and 98 are parsed away *** *)

    (* *** Functor Bindings *** *)
    (* *** rule 99 *** *)

      fun check_funbind (Absyn.FUNBIND [],basis,funenv, _) = funenv

	| check_funbind (Absyn.FUNBIND
			 ((funid,strid,sigexp,strexp,NONE,_,
			   coerce_ref,location,_,debugger_str):: funbinds),
			 basis as BasisTypes.BASIS (_,nameset,_,_,_),funenv,
			 ass as (str_ass, ty_ass))=
	  let
	    val _ = sigstr_ass := str_ass
	    val _ = sigty_ass := ty_ass
	    val (BasisTypes.SIGMA (names,str),BasisTypes.SIGMA (_,exp_str)) =
	      (check_sigexp_closed (sigexp,basis,location))
	      handle WellFormed sigma =>
		(report_error
		 (Info.RECOVERABLE, location,
		  "Argument signature is not well-formed");
		 (sigma,sigma))
		   | TypeExplicit sigma =>
		       (report_error
			(Info.RECOVERABLE, location,
			 "Argument signature is not type-explicit");
			(sigma,sigma))
		   | RespectEquality sigma =>
		       (report_error
			(Info.RECOVERABLE, location,
			 "Argument signature does not respect equality");
			(sigma,sigma))
	    val _ = sigstr_ass := empty_str_ass
	    val _ = sigty_ass := empty_ty_ass
	    val new_basis =
	      Basis.basis_plus_names
	      (Basis.basis_plus_env (basis,
				     ENV (Strenv.add_to_se
					  (strid,exp_str,Strenv.empty_strenv),
					  Tyenv.empty_tyenv,
					  empty_valenv)),
	       names)
	    val (str',exp_str') = check_strexp (strexp,new_basis)
	    val names' =
	      Nameset.diff (Sigma.names_of exp_str',
			    Nameset.union (nameset,names))
	    val phi = BasisTypes.PHI (names,(str,
                                             BasisTypes.SIGMA (names',str')))
            val _ =
              case debugger_str of
                SOME(debugger_str) =>
                  debugger_str := SOME(exp_str)
              | _ => ()
	  in
            (let
	       val env' = get_env_or_crash ("exp_str'",exp_str')
	     in
               if Info.< (Info.NONSTANDARD, Info.worst_error (error_info))
                 then ()
               else
                 case Env.no_imptyvars env' of
                   NONE => ()
                 | SOME(ty, atype) =>
                     let
                       val loc = Absyn.check_strexp_for_free_imp(strexp, ty)
                       val location= case loc of
                         NONE =>
			   location
                       | SOME loc => loc
		       val atype_string = Types.print_type options atype
		       val ty_string = Types.print_type options ty
                     in
                       report_error(Info.RECOVERABLE, location,
                                    "Free type variable " ^ ty_string ^ 
                                    " in " ^ ty_string ^ " in functor body")
                     end
	     end;
	   Basis.add_to_funenv (funid,BasisTypes.PHI 
                                (names,(str,
                                        BasisTypes.SIGMA(names',str'))),
				check_funbind (Absyn.FUNBIND funbinds,basis,
					       funenv, ass)))
	  end

	| check_funbind (Absyn.FUNBIND ((funid,strid,sigexp,strexp,
					 SOME (sigexp',abs),_,
					 coerce_ref,location,debugger_str,
                                         debugger_str') :: funbinds),
			 basis as BasisTypes.BASIS (_,nameset,_,_,_),funenv,
			 ass as (str_ass, ty_ass))=
	  let
            val _ =
                if generate_moduler_debug then
                  print("\n FUNBIND " ^ Ident.Location.to_string location)
                else ()
	    val _ = sigstr_ass := str_ass
	    val _ = sigty_ass := ty_ass
	    val (sigma as BasisTypes.SIGMA (names,str),
                          BasisTypes.SIGMA (_,exp_str)) =
	      (check_sigexp_closed (sigexp,basis,location))
	       handle WellFormed sigma =>
		 (report_error
		  (Info.RECOVERABLE, location,
		   "Argument signature is not well-formed");
		  (sigma,sigma))
		    | TypeExplicit sigma =>
			(report_error
			 (Info.RECOVERABLE, location,
			  "Argument signature is not type-explicit");
			 (sigma,sigma))
		    | RespectEquality sigma =>
			(report_error
			 (Info.RECOVERABLE, location,
			  "Argument signature does not respect equality");
			 (sigma,sigma))
	
	    val new_basis =
              Basis.basis_plus_names
			  (Basis.basis_plus_env (basis,
						 ENV(Strenv.add_to_se
						     (strid,exp_str,
						      Strenv.empty_strenv),
						     Tyenv.empty_tyenv,
						     empty_valenv)),
			  names)

	    (* Check result structure *)
	    val (str',exp_str') = check_strexp(strexp,new_basis)

	    (* Check result signature *)
	    (* This fails, don't try sigmatch *)
	    val (sigma',_) =
	      error_wrap
	      error_info
	      (fn options =>
	       fn (sigexp,basis,location) =>
	       let
		 val ans =
                   (check_sigexp_closed (sigexp',new_basis,location))
			   handle WellFormed sigma =>
			     (report_error
			      (Info.RECOVERABLE, location,
			       "Constraining signature is not well-formed");
			      (sigma,sigma))
				| TypeExplicit sigma =>
				    (report_error
				     (Info.RECOVERABLE, location,
				      "Constraining signature is not type-explicit");
				     (sigma,sigma))
				| RespectEquality sigma =>
				    (report_error
				     (Info.RECOVERABLE, location,
				      "Constraining signature does not respect equality");
				     (sigma,sigma))
		 val _ = sigstr_ass := empty_str_ass
		 val _ = sigty_ass := empty_ty_ass
	       in
		 ans
	       end
	      )
	      (sigexp,basis,location)


	    val sigma'' as BasisTypes.SIGMA (names'',str'') = 
                            Sigma.sig_copy (sigma',is_separate) 
                                           (Basis.basis_level new_basis)

	    val exp_str'' = Env.expand_str str'' (* necessary *)
	    val completion_env = make_completion_env (new_basis,exp_str'',
                                                      exp_str')
	    val (realise, do_coerce, debugger_str'') =
              sigmatch (location,completion_env,
                        Basis.context_level (Basis.basis_to_context basis),
                        BasisTypes.SIGMA(names'',exp_str''),
                        exp_str')
            val _ =
              case (debugger_str,debugger_str') of
                (SOME(debugger_str),
                 SOME(debugger_str')) =>
                  (debugger_str := debugger_str'';
                   debugger_str' := SOME(exp_str))
              | _ => ()
            val _ =
              if realise then ()
              else
                report_error
                (Info.RECOVERABLE, location,
                 concat ["Functor body ", IdentPrint.printFunId funid,
                          " does not match result signature"])
            val names' =
              Nameset.diff (Sigma.names_of exp_str'',
                            Nameset.union (nameset,names))
            val phi = BasisTypes.PHI(names,(str,BasisTypes.SIGMA (names',str'')))
          in
            if do_coerce then coerce_ref := true else ();
              set_intref (sigexp',str'');
              Basis.add_to_funenv
              (funid,BasisTypes.PHI (names,(str,
                                            BasisTypes.SIGMA(names',str''))),
               check_funbind (Absyn.FUNBIND funbinds,
                              basis,funenv, ass))
          end

      fun check_sigdec ([],basis, sigenv, _) = sigenv

	| check_sigdec (sigbind::sigbindlist, basis, sigenv, ass) =
	  let
	    val new_sigenv = check_sigbind (sigbind,basis,sigenv, ass)
	    val new_basis = Basis.basis_plus_sigenv (basis,new_sigenv)
	  in
	    check_sigdec(sigbindlist, new_basis,
			 Basis.sigenv_plus_sigenv (new_sigenv, sigenv), ass)
	  end
	
      fun check_fundec([],basis, funenv, _) = funenv
	| check_fundec(funbind::funbindlist, basis, funenv, ass) =
	  let
	    val new_funenv = check_funbind(funbind,basis,funenv, ass)
	    val new_basis = Basis.basis_plus_funenv (basis,new_funenv)
	  in
	    check_fundec (funbindlist,new_basis,
			  Basis.funenv_plus_funenv (new_funenv, funenv), ass)
	  end

      (* *** rule 100 *** *)

      fun check_topdec (Absyn.STRDECtopdec (strdec,location),basis as BasisTypes.BASIS (_,nameset,_,_,_)) =
	let
	  val new_env = check_strdec (strdec,basis)
          val exp_new_env = Env.expand_env new_env (* Be nice not to have to expand this *)
          val final_env = if is_separate then exp_new_env else new_env
	  val basis_inc = Basis.env_in_basis final_env (* HACK for encapsulator here *)
	in
          (* This expands out any COPYSTRs *)
          case (Env.no_imptyvars exp_new_env) of (* get something expanded from check_strdec? *)
	    NONE =>
              (* So does names_of -- so use an expanded environment *)
	      Basis.basis_plus_names(basis_inc, Sigma.names_of_env exp_new_env)
	  | SOME(ty, atype) =>
	      (if Info.< (Info.NONSTANDARD, Info.worst_error (error_info))
                 then ()
               else
                 let
                   val loc = Absyn.check_strdec_for_free_imp(strdec, ty)
                   val location= case loc of
                     NONE =>
		       location
                   | SOME loc => loc
		   val atype_string = Types.print_type options atype
		   val ty_string = Types.print_type options ty
                 in
		   if old_definition then
                     report_error
                       (Info.RECOVERABLE, location,
                        "Free imperative type variable " ^ ty_string ^ " in " ^ atype_string ^ " at top level")
		   else
                     report_error
                       (Info.RECOVERABLE, location,
                        "Free type variable " ^ ty_string ^ " in " ^ atype_string ^ " at top level")
                 end;
              basis)
	end

	(* *** rule 101 *** *)

	| check_topdec (Absyn.SIGNATUREtopdec (sigbindlist, _), basis) =
	  let
	    val ass = case assembly of
	      ASSEMBLY assembly => assembly
	    | BASIS b => Assemblies.new_assemblies_from_basis b
	
	    val new_sigenv =
	      check_sigdec (sigbindlist,basis, Basis.empty_sigenv, ass)
	  in
            (sigstr_ass := Assemblies.empty_strassembly();
	    sigty_ass := Assemblies.empty_tyassembly;
	    (* Avoid hanging on to large unnecessary data structures *)

	    (* It is not necessary to check for the presence of free imperative
            type variables because they have all been caught by previous
	    checks. According to Mads Tofte the side condition in rule 101
	    is there for cosmetic reasons only. *)

	    Basis.sigenv_in_basis new_sigenv)
	  end

	(* *** rule 102 *** *)

	| check_topdec (Absyn.FUNCTORtopdec (funbindlist,location),basis) =
	  let
	    val ass = case assembly of
	      ASSEMBLY assembly => assembly
	    | BASIS b => Assemblies.new_assemblies_from_basis b
	    val new_funenv = check_fundec(funbindlist,basis, Basis.empty_funenv, ass)
	  in
	    Basis.funenv_in_basis new_funenv
	  end
	| check_topdec (Absyn.REQUIREtopdec (s, _),basis) = basis

      in
(*
      TypeDebugger.print_vartypes
      print_options
      (TypeDebugger.gather_vartypes topdec);
*)
	check_topdec (topdec,basis)
      end
  end
@


1.121.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.121  1998/12/14  15:52:49  mitchell
 * [Bug #190495]
 * Check for equality violations in "where type"s
 *
@


1.120
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d1046 1
a1046 1
                  (tycon,tyfun,location)
d1049 1
a1049 1
              fun apply_tysub (longtycon,tyfun,location) =
d1053 7
@


1.119
log
@[Bug #30090]
Translate output std_out to print
@
text
@d4 4
d1242 1
@


1.119.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.119  1997/05/19  12:49:39  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.119.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.119  1997/05/19  12:49:39  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.118
log
@[Bug #2033]
ordering type sharing constraints in structure sharing
to maintain correct dependency info between types.
@
text
@d4 5
d896 1
a896 3
                  MLWorks.IO.output(MLWorks.IO.std_out,
                                    "\n STRBIND "^
                                    Ident.Location.to_string location)
d1385 1
a1385 2
		  ((*output(MLWorks.IO.std_out, "datatype desc has unbound type constructors, ignoring\n");*)
		   Env.empty_env)
d1736 1
a1736 2
		    ((*output(MLWorks.IO.std_out, "Found bad exception spec, ignoring\n");*)
		     ve)
a2071 190
(*
	fun type_occurs(ty, ty') =
	  ((*output(MLWorks.IO.std_out, "type_occurs checking ty1 = " ^
		  Types.extra_debug_print_type ty ^ "\nwith ty2 = " ^
		  Types.extra_debug_print_type ty' ^ "\n");*)
	   Types.type_eq(ty', ty, true, true) orelse occurs_in(ty, ty'))

	and occurs_in(ty, METATYVAR(ref(_, ty', _), _, _)) =
	  type_occurs(ty, ty')
	  | occurs_in(ty, META_OVERLOADED(ref ty', _, _, _)) =
	    type_occurs(ty, ty')
	  | occurs_in(ty, TYVAR(ref(_, ty', _), _)) = type_occurs(ty, ty')
	  | occurs_in(ty, METARECTYPE(ref{3=ty', ...})) = type_occurs(ty, ty')
	  | occurs_in(ty, RECTYPE lab_ty_map) =
	    Lists.exists
	    (fn (_, ty') => type_occurs(ty, ty'))
	    (Mapping.assoc lab_ty_map)
	  | occurs_in(ty, FUNTYPE(ty', ty'')) =
	    type_occurs(ty, ty') orelse type_occurs(ty, ty'')
	  | occurs_in(ty, CONSTYPE(ty_list, _)) =
	    Lists.exists
	    (fn ty' => type_occurs(ty, ty'))
	    ty_list
	  | occurs_in(_, DEBRUIJN _) = false
	  | occurs_in(_, NULLTYPE) = false
    
	fun check_ty(ty, ty', loc) =
	  (* See if ty = ty' or ty occurs in ty' *)
	  if type_occurs(ty', ty) then
	    SOME loc
	  else
	    NONE

	fun get_loc_from_pat(Absyn.WILDpat loc) = SOME loc
	  | get_loc_from_pat(Absyn.SCONpat _) = NONE
	  | get_loc_from_pat(Absyn.VALpat(_, loc)) = SOME loc
	  | get_loc_from_pat(Absyn.RECORDpat(lab_pat_list, _, _)) =
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, (_, pat)) => get_loc_from_pat pat)
	    (NONE, lab_pat_list)
	  | get_loc_from_pat(Absyn.APPpat(_, _, loc, _)) =
	    SOME loc
	  | get_loc_from_pat(Absyn.TYPEDpat(_, _, loc)) =
	    SOME loc
	  | get_loc_from_pat(Absyn.LAYEREDpat(_, pat)) =
	    get_loc_from_pat pat

	fun check_pat_for_free_imp(Absyn.WILDpat _, _, _) = NONE
	  | check_pat_for_free_imp(Absyn.SCONpat _, _, _) = NONE
	  | check_pat_for_free_imp(Absyn.VALpat((_, (ref ty', _)), loc), ty, _) =
	    check_ty(ty', ty, loc)
	  | check_pat_for_free_imp(Absyn.RECORDpat(lab_pat_list, _, _), ty, loc') =
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, (_, pat)) => check_pat_for_free_imp(pat, ty, loc'))
	    (NONE, lab_pat_list)
	  | check_pat_for_free_imp(Absyn.APPpat(_, pat, _, _), ty, loc) =
	    check_pat_for_free_imp(pat, ty, loc)
	  | check_pat_for_free_imp(Absyn.TYPEDpat(pat, _, _), ty, loc) =
	    check_pat_for_free_imp(pat, ty, loc)
	  | check_pat_for_free_imp(Absyn.LAYEREDpat((_, (ref ty', _)), pat), ty, loc) =
	    if type_occurs(ty, ty') then
	      case get_loc_from_pat pat of
		(* Use this location if no other available *)
		NONE => SOME loc
	      | x => x
	    else
	      NONE

	fun check_exbind_for_free_imp(Absyn.NEWexbind((_, ref ty'), _, loc, _), ty) =
	  check_ty(ty, ty', loc)
	  | check_exbind_for_free_imp(Absyn.OLDexbind((_, ref ty'), _, loc, _), ty) =
	  check_ty(ty, ty', loc)

	fun check_dec_for_free_imp(Absyn.VALdec(dec_list1, dec_list2, _), ty) =
	  let
	    fun check_pat_exp(loc as SOME _, _) =
	      loc
	      | check_pat_exp(_, (pat, exp, loc)) =
		case check_pat_for_free_imp(pat, ty, loc) of
		  NONE =>
		    check_exp_for_free_imp(exp, ty)
		| x => x
	  in
	    case Lists.reducel
	      check_pat_exp
	      (NONE, dec_list1) of
	      NONE => Lists.reducel
		check_pat_exp
		(NONE, dec_list2)
	    | x => x
	  end
	  | check_dec_for_free_imp(Absyn.TYPEdec _, _) = NONE
	  | check_dec_for_free_imp(Absyn.DATATYPEdec _, _) = NONE
	  | check_dec_for_free_imp(Absyn.DATATYPErepl _, _) = NONE
	  | check_dec_for_free_imp(Absyn.ABSTYPEdec _, _) = NONE
	  | check_dec_for_free_imp(Absyn.EXCEPTIONdec e_list, ty) =
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, e_bind) => check_exbind_for_free_imp(e_bind, ty))
	    (NONE, e_list)
	  | check_dec_for_free_imp(Absyn.LOCALdec(dec, dec'), ty) =
	    (case check_dec_for_free_imp(dec, ty) of
	       loc as SOME _ => loc
	     | _ => check_dec_for_free_imp(dec', ty))
	  | check_dec_for_free_imp(Absyn.OPENdec _, _) = NONE
	  | check_dec_for_free_imp(Absyn.SEQUENCEdec dec_list, ty) =
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, dec) =>
		 check_dec_for_free_imp(dec, ty))
	    (NONE, dec_list)

	and check_exp_for_free_imp(Absyn.SCONexp _, ty) = NONE
	  | check_exp_for_free_imp(Absyn.VALexp _, ty) = NONE
	  | check_exp_for_free_imp(Absyn.RECORDexp lab_exp_list, ty) =
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, (_, exp)) =>
		 check_exp_for_free_imp(exp, ty))
	    (NONE, lab_exp_list)
	  | check_exp_for_free_imp(Absyn.LOCALexp(dec, exp,_), ty) =
	    (case check_dec_for_free_imp(dec, ty) of
	       NONE =>
		 check_exp_for_free_imp(exp, ty)
	     | x => x)
	  | check_exp_for_free_imp(Absyn.APPexp(exp1, exp2, _, _, _), ty) =
	    (case check_exp_for_free_imp(exp1, ty) of
	       NONE =>
		 check_exp_for_free_imp(exp2, ty)
	     | x => x)
	  | check_exp_for_free_imp(Absyn.TYPEDexp(exp, _, _), ty) =
	    check_exp_for_free_imp(exp, ty)
	  | check_exp_for_free_imp(Absyn.HANDLEexp(exp, _, pe_list, _, _), ty)=
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, (_, exp, _)) =>
		 check_exp_for_free_imp(exp, ty))
	    (NONE, pe_list)
	  | check_exp_for_free_imp(Absyn.RAISEexp(exp, _), ty) =
	    check_exp_for_free_imp(exp, ty)
	  | check_exp_for_free_imp(Absyn.FNexp(pe_list, _, _, _), ty) =
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, (_, exp, _)) =>
		 check_exp_for_free_imp(exp, ty))
	    (NONE, pe_list)
	  | check_exp_for_free_imp(Absyn.DYNAMICexp(exp, _, _), ty) =
	    check_exp_for_free_imp(exp, ty)
	  | check_exp_for_free_imp(Absyn.COERCEexp(exp, _, _, _), ty) =
	    check_exp_for_free_imp(exp, ty)
	  | check_exp_for_free_imp(MLVALUEexp _, ty) = NONE

	fun check_strexp_for_free_imp(Absyn.NEWstrexp strdec, ty) =
	  check_strdec_for_free_imp(strdec, ty)
	  | check_strexp_for_free_imp(Absyn.OLDstrexp _, ty) =
	    NONE
	  | check_strexp_for_free_imp(Absyn.APPstrexp _, ty) =
	    NONE
	  | check_strexp_for_free_imp(Absyn.LOCALstrexp(strdec, strexp), ty) =
	    case check_strdec_for_free_imp(strdec, ty) of
	      NONE =>
		check_strexp_for_free_imp(strexp, ty)
	    | x => x

	and check_strdec_for_free_imp(Absyn.DECstrdec dec, ty) =
	  check_dec_for_free_imp(dec, ty)
	  | check_strdec_for_free_imp(Absyn.STRUCTUREstrdec e_list, ty) =
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, (_, _, strexp, _, _, _, _)) =>
		 check_strexp_for_free_imp(strexp, ty))
	    (NONE, e_list)
	  | check_strdec_for_free_imp(Absyn.ABSTRACTIONstrdec abs_list, ty) =
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, {3=strexp, ...}) => check_strexp_for_free_imp(strexp, ty))
	    (NONE, abs_list)
	  | check_strdec_for_free_imp(Absyn.LOCALstrdec(strdec1, strdec2), ty) =
	    (case check_strdec_for_free_imp(strdec1, ty) of
	       NONE => check_strdec_for_free_imp(strdec2, ty)
	     | x => x)
	  | check_strdec_for_free_imp(Absyn.SEQUENCEstrdec s_list, ty) =
	    Lists.reducel
	    (fn (loc as SOME _, _) => loc
	     | (_, strdec) => check_strdec_for_free_imp(strdec, ty))
	    (NONE, s_list)
*)

d2142 1
a2142 3
                           (MLWorks.IO.output(MLWorks.IO.std_out, 
                                              "No location found\n");
                            location)
d2168 1
a2168 3
                  MLWorks.IO.output(MLWorks.IO.std_out,
                                    "\n FUNBIND "^
                                    Ident.Location.to_string location)
d2321 1
a2321 2
                       (MLWorks.IO.output(MLWorks.IO.std_out, "No location found\n");
                        location)
@


1.117
log
@[Bug #1712]
Where type instantiation shouldn't maximise equality.
@
text
@d4 4
d1790 3
a1792 1
	and check_str_share (sharelist,basis as BasisTypes.BASIS(_,nameset,_,_,env),location) =
d1799 5
a1803 2
		   concat ["Sharing ",IdentPrint.printLongStrId lstrid, " and ",
			    IdentPrint.printLongStrId lstrid', " creates a cycle"])
d1839 2
a1840 1
	       val str = get_structure_name_from_str(Env.lookup_longstrid(lstrid, env))
d1847 2
a1848 1
		   IdentPrint.strid_unbound_strid_message (strid,lstrid,print_options));
d1879 2
a1880 1
                    IdentPrint.strid_unbound_strid_message (strid,lstrid,print_options));
d1883 21
a1903 2
              | print_path (s::rest,acc) = print_path (rest,IdentPrint.printStrId s :: "." :: acc)
            fun share_tystr (strid1, strid2, path, tycon,TYSTR (tyfun,_),TYSTR (tyfun',_)) =
d1910 4
a1913 11
		  handle Sharetypes.ShareError s =>
		    (report_error
		     (Info.RECOVERABLE, location,
		      concat
		      ["Failed to share type ", 
                       print_path (path,[]), 
                       IdentPrint.printTyCon tycon,
                       " in structures ", 
                       IdentPrint.printLongStrId strid1, " and ", 
                       IdentPrint.printLongStrId strid2, ": ", s]);
		     (false,!sigty_ass))
d1919 1
a1919 1
                share_successful
d1921 1
d1923 57
a1979 6
              NewMap.forall
              (fn (tycon,tystr) =>
               case NewMap.tryApply'(tymap',tycon) of
                 SOME tystr' => share_tystr (strid,strid',path,tycon,tystr,tystr')
               | _ => true)
              tymap
@


1.117.5.1
log
@branched from 1.117
@
text
@a3 4
 * Revision 1.117  1996/11/04  17:23:51  andreww
 * [Bug #1712]
 * Where type instantiation shouldn't maximise equality.
 *
@


1.117.5.2
log
@[Bug #2033]
making sure type dependencies are shared in correct order.
@
text
@a3 8
 * Revision 1.117.5.1  1997/05/12  10:51:43  hope
 * branched from 1.117
 *
 * Revision 1.118  1997/04/08  14:49:55  andreww
 * [Bug #2033]
 * ordering type sharing constraints in structure sharing
 * to maintain correct dependency info between types.
 *
d1790 1
a1790 3
	and check_str_share (sharelist,
                             basis as BasisTypes.BASIS(_,nameset,_,_,env),
                             location) =
d1797 2
a1798 5
		   concat ["Sharing ",
                           IdentPrint.printLongStrId lstrid,
                           " and ",
                           IdentPrint.printLongStrId lstrid',
                           " creates a cycle"])
d1834 1
a1834 2
	       val str = get_structure_name_from_str
                                  (Env.lookup_longstrid(lstrid, env))
d1841 1
a1841 2
		   IdentPrint.strid_unbound_strid_message
                                        (strid,lstrid,print_options));
d1872 1
a1872 2
                    IdentPrint.strid_unbound_strid_message
                                           (strid,lstrid,print_options));
d1875 2
a1876 21
              | print_path (s::rest,acc) = 
                     print_path (rest,IdentPrint.printStrId s :: "." :: acc)

                     (* the following local references are used to
                      * compute the fixpoint of our sharing checker.
                      * It stores the list of tycons for which
                      * type sharing has failed.  However, since
                      * failures may be due to the fact that
                      * the tycons are built out of others which
                      * haven't yet been shared, we must keep them
                      * ready to try again.  When the fixpoint has
                      * been reached (i.e., !old_share_failures =
                      * !share_failures) then we have finished.
                      *)

            val old_share_failures = ref []
            val share_failures = ref []
            val failure_reasons = ref []

            fun share_tystr (strid1, strid2, path, tycon,TYSTR (tyfun,_),
                             TYSTR (tyfun',_)) =
d1883 11
a1893 4
                   handle Sharetypes.ShareError s =>
                     (share_failures:= tycon::(!share_failures);
                      failure_reasons:= s::(!failure_reasons);
                      (false,!sigty_ass))
d1899 1
a1899 1
                true
a1900 1

d1902 6
a1907 57
              (old_share_failures:=[];
               let
                 fun findFixpoint () =
                   (share_failures:=[];
                    failure_reasons:=[];
                    let val answer = 
                      NewMap.forall
                      (fn (tycon,tystr) =>
                       case NewMap.tryApply'(tymap',tycon) of
                         SOME tystr' =>
                           share_tystr (strid,strid',path,tycon,tystr,tystr')
                       | _ => true)
                      tymap
                   in
                     if !old_share_failures = !share_failures
                       then (* finished *)
                         if !share_failures=[]
                           then answer
                         else 
                           let
                             fun makeE([],[]) = ""
                               | makeE([h1],[h2]) =
                                  (IdentPrint.printTyCon h1)^": "^h2^"}"
                               | makeE(h1::t1,h2::t2) =
                                  (IdentPrint.printTyCon h1)^": "^h2^"\n    "^
                                  (makeE(t1,t2))
                               | makeE _ = Crash.impossible "makeE"

                             fun makeErrorMesg() =
                               if Lists.length (!share_failures)=1
                                 then 
                                   "Failed to share type "^
                                   print_path(path,[])^
                                   IdentPrint.printTyCon 
                                         (Lists.hd(!share_failures))^
                                   " because "^(Lists.hd(!failure_reasons))
                               else
                                   "Failed to share types "^
                                   print_path(path,[])^"\n   {"^
                                   makeE(!share_failures,!failure_reasons)
                           in
                             (report_error
                              (Info.RECOVERABLE, location,
                               concat(
                               [makeErrorMesg(),
                                "\n in structures ", 
                                IdentPrint.printLongStrId strid, " and ", 
                                IdentPrint.printLongStrId strid', "."]));
                              false)
                           end
                     else (old_share_failures:= !share_failures;
                           findFixpoint ())
                   end)
               in
                 findFixpoint ()
               end)

@


1.117.5.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 4
 * Revision 1.117.5.2  1997/05/12  16:03:08  daveb
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
@


1.117.5.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 4
 * Revision 1.117.5.2  1997/05/12  16:03:08  daveb
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
@


1.117.5.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 4
 * Revision 1.117.5.2  1997/05/12  16:03:08  daveb
 * [Bug #2033]
 * making sure type dependencies are shared in correct order.
 *
@


1.117.5.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.117.5.2.1.1  1997/07/28  18:33:33  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.117.4.1
log
@branched from 1.117
@
text
@a3 4
 * Revision 1.117  1996/11/04  17:23:51  andreww
 * [Bug #1712]
 * Where type instantiation shouldn't maximise equality.
 *
@


1.117.3.1
log
@branched from 1.117
@
text
@a3 4
 * Revision 1.117  1996/11/04  17:23:51  andreww
 * [Bug #1712]
 * Where type instantiation shouldn't maximise equality.
 *
@


1.117.3.1.1.1
log
@branched from 1.117.3.1
@
text
@a3 3
 * Revision 1.117.3.1  1996/12/17  18:18:09  hope
 * branched from 1.117
 *
@


1.117.2.1
log
@branched from 1.117
@
text
@a3 4
 * Revision 1.117  1996/11/04  17:23:51  andreww
 * [Bug #1712]
 * Where type instantiation shouldn't maximise equality.
 *
@


1.117.1.1
log
@branched from 1.117
@
text
@a3 4
 * Revision 1.117  1996/11/04  17:23:51  andreww
 * [Bug #1712]
 * Where type instantiation shouldn't maximise equality.
 *
@


1.117.1.1.1.1
log
@branched from 1.117.1.1
@
text
@a3 3
 * Revision 1.117.1.1  1996/11/14  13:21:26  hope
 * branched from 1.117
 *
@


1.116
log
@[Bug #1708]
changing the syntax of datatype replication.
@
text
@d4 4
d1120 2
a1121 1
	      if (Types.equalityp atyfun) andalso not (NewMap.forall eq_scheme amap)
d1130 5
d1136 4
a1139 2
	      NewMap.forall max_eq_pred amap' andalso
	      NewMap.forall se_equality_principal amap
d1141 2
a1142 1
	    fun equality_principal (sigma as BasisTypes.SIGMA (names,STR(_,_,env))) =
d1153 1
@


1.115
log
@moving String from toplevel
@
text
@d4 3
d1376 1
a1376 2
	  | check_spec (Absyn.DATATYPEreplSpec (location,tyvars,tycon,
                                                longtycon,
a1385 17
              fun check_arity (Datatypes.TYFUN(typ,n)) arity = n=arity
                | check_arity (Datatypes.ETA_TYFUN(tyName)) arity = 
                  (case tyName
                     of Datatypes.TYNAME(_,_,n,_,_,_,_,_,_) => n=arity
                      | Datatypes.METATYNAME(_,_,n,_,_,_) => n=arity)
                | check_arity (Datatypes.NULL_TYFUN(_,ref tyFun)) arity =
                  check_arity tyFun arity
                  
                  
              val _ = if check_arity tyFun (length tyvars) then ()
                      else report_error
                        (Info.RECOVERABLE, location,
                         "Datatype "^ (IdentPrint.printLongTyCon longtycon)^
                         " does not have arity "^
                         (foldl (fn (item,acc) => acc^" "^
                                                  (IdentPrint.printTyVar item))
                         "" tyvars)^".")
d1388 4
a1391 2
                map (fn (valid,Datatypes.SCHEME(_,(ty,_))) => (valid,SOME ty,Location.UNKNOWN)
                      | (valid,Datatypes.UNBOUND_SCHEME(ty,_)) => (valid, NONE,Location.UNKNOWN)
@


1.114
log
@[Bug #1622]
The identifiers that cannot be specified are only forbidden
in SML'96.
@
text
@a470 1
    structure Option = MLWorks.Option
d495 1
a495 1
	val str = STR (STRNAME (Types.make_stamp ()),ref Option.NONE,Env.empty_env)
d500 2
a501 2
    fun set_intref (Absyn.OLDsigexp (_,intref,_),str) = intref := Option.SOME str
      | set_intref (Absyn.NEWsigexp(_,intref),str) = intref := Option.SOME str
d611 1
a611 2
            if (not old_definition) andalso
                Lists.member (name,verboten_identifieren)
d627 1
a627 1
	    val str = STR (strname,ref Option.NONE,env)
d641 2
a642 2
                   Option.SOME(interface) =>
                     interface := Option.SOME(exp_str)
d692 1
a692 1
                   Option.SOME(debugger_str) => debugger_str := debugger_str'
d699 1
a699 1
                  String.implode ["Argument signature of ", 
d769 1
a769 1
                   Option.SOME(debugger_str) => debugger_str := debugger_str'
d772 2
a773 2
		       Option.SOME(debugger_str'') =>
			 debugger_str'' := Option.SOME(str')
d781 1
a781 1
                 String.implode ["Structure does not match signature"]);
d852 1
a852 1
	  | check_strbinds ((strid,Option.NONE,strexp,coerce_ref,_,_,
d866 2
a867 2
                 Option.SOME(debugger_str) =>
                   debugger_str := Option.SOME(str)
d872 1
a872 1
	  | check_strbinds ((strid,Option.SOME (sigexp,abs),strexp,
d931 1
a931 1
                   Option.SOME(debugger_str) => debugger_str := debugger_str'
d934 2
a935 2
		       Option.SOME(debugger_str'') =>
			 debugger_str'' := Option.SOME(str')
d942 1
a942 1
                 String.implode ["Structure ",IdentPrint.printStrId strid,
d963 1
a963 1
	    val str = STR(m,ref Option.NONE,env)
d1330 1
a1330 1
						Lists.length tyvars,
d1522 4
a1525 4
		  fun new_instance (SCHEME (n, (ty, Option.SOME (sch,_)))) =
		    SCHEME (n, (ty, Option.SOME (sch, ref (Option.NONE))))
		    | new_instance (UNBOUND_SCHEME (ty,Option.SOME (sch,_))) =
		      UNBOUND_SCHEME (ty, Option.SOME (sch, ref (Option.NONE)))
d1598 1
a1598 1
		val instance = Option.NONE
d1621 1
a1621 1
			       Lists.length tyvarlist,
d1675 1
a1675 1
	  | check_condesc ((valid,Option.NONE,location)::condescs,
d1680 1
a1680 1
		Scheme.make_scheme (tyvartypes,(tycon_type,Option.NONE))
d1689 1
a1689 1
	  | check_condesc ((valid,Option.SOME aty,location)::condescs,
d1695 1
a1695 1
		(tyvartypes,(FUNTYPE (atype,tycon_type),Option.NONE))
d1710 1
a1710 1
	    fun do_one (ve, (excon,Option.NONE,location)) =
d1713 2
a1714 2
                                                               Option.NONE)),ve))
	      | do_one (ve, (excon,Option.SOME aty,location)) =
d1720 1
a1720 1
			String.implode ["Exception description of ",
d1734 1
a1734 1
							     Option.NONE)),
d1792 1
a1792 1
		   String.implode ["Sharing ",IdentPrint.printLongStrId lstrid, " and ",
d1808 1
a1808 1
		  String.implode ["Failed to share structures ",
d1869 1
a1869 1
            fun print_path ([],acc) = String.implode acc
d1881 1
a1881 1
		      String.implode
d1900 1
a1900 1
                 Option.SOME tystr' => share_tystr (strid,strid',path,tycon,tystr,tystr')
d1916 1
a1916 1
                 Option.SOME str' => share_str (strid1,strid2,strid::path,str,str')
d1946 1
a1946 1
		      String.implode
d2023 1
a2023 1
	    Option.SOME loc
d2025 1
a2025 1
	    Option.NONE
d2027 3
a2029 3
	fun get_loc_from_pat(Absyn.WILDpat loc) = Option.SOME loc
	  | get_loc_from_pat(Absyn.SCONpat _) = Option.NONE
	  | get_loc_from_pat(Absyn.VALpat(_, loc)) = Option.SOME loc
d2032 1
a2032 1
	    (fn (loc as Option.SOME _, _) => loc
d2034 1
a2034 1
	    (Option.NONE, lab_pat_list)
d2036 1
a2036 1
	    Option.SOME loc
d2038 1
a2038 1
	    Option.SOME loc
d2042 2
a2043 2
	fun check_pat_for_free_imp(Absyn.WILDpat _, _, _) = Option.NONE
	  | check_pat_for_free_imp(Absyn.SCONpat _, _, _) = Option.NONE
d2048 1
a2048 1
	    (fn (loc as Option.SOME _, _) => loc
d2050 1
a2050 1
	    (Option.NONE, lab_pat_list)
d2059 1
a2059 1
		Option.NONE => Option.SOME loc
d2062 1
a2062 1
	      Option.NONE
d2071 1
a2071 1
	    fun check_pat_exp(loc as Option.SOME _, _) =
d2075 1
a2075 1
		  Option.NONE =>
d2081 2
a2082 2
	      (Option.NONE, dec_list1) of
	      Option.NONE => Lists.reducel
d2084 1
a2084 1
		(Option.NONE, dec_list2)
d2087 4
a2090 4
	  | check_dec_for_free_imp(Absyn.TYPEdec _, _) = Option.NONE
	  | check_dec_for_free_imp(Absyn.DATATYPEdec _, _) = Option.NONE
	  | check_dec_for_free_imp(Absyn.DATATYPErepl _, _) = Option.NONE
	  | check_dec_for_free_imp(Absyn.ABSTYPEdec _, _) = Option.NONE
d2093 1
a2093 1
	    (fn (loc as Option.SOME _, _) => loc
d2095 1
a2095 1
	    (Option.NONE, e_list)
d2098 1
a2098 1
	       loc as Option.SOME _ => loc
d2100 1
a2100 1
	  | check_dec_for_free_imp(Absyn.OPENdec _, _) = Option.NONE
d2103 1
a2103 1
	    (fn (loc as Option.SOME _, _) => loc
d2106 1
a2106 1
	    (Option.NONE, dec_list)
d2108 2
a2109 2
	and check_exp_for_free_imp(Absyn.SCONexp _, ty) = Option.NONE
	  | check_exp_for_free_imp(Absyn.VALexp _, ty) = Option.NONE
d2112 1
a2112 1
	    (fn (loc as Option.SOME _, _) => loc
d2115 1
a2115 1
	    (Option.NONE, lab_exp_list)
d2118 1
a2118 1
	       Option.NONE =>
d2123 1
a2123 1
	       Option.NONE =>
d2130 1
a2130 1
	    (fn (loc as Option.SOME _, _) => loc
d2133 1
a2133 1
	    (Option.NONE, pe_list)
d2138 1
a2138 1
	    (fn (loc as Option.SOME _, _) => loc
d2141 1
a2141 1
	    (Option.NONE, pe_list)
d2146 1
a2146 1
	  | check_exp_for_free_imp(MLVALUEexp _, ty) = Option.NONE
d2151 1
a2151 1
	    Option.NONE
d2153 1
a2153 1
	    Option.NONE
d2156 1
a2156 1
	      Option.NONE =>
d2164 1
a2164 1
	    (fn (loc as Option.SOME _, _) => loc
d2167 1
a2167 1
	    (Option.NONE, e_list)
d2170 1
a2170 1
	    (fn (loc as Option.SOME _, _) => loc
d2172 1
a2172 1
	    (Option.NONE, abs_list)
d2175 1
a2175 1
	       Option.NONE => check_strdec_for_free_imp(strdec2, ty)
d2179 1
a2179 1
	    (fn (loc as Option.SOME _, _) => loc
d2181 1
a2181 1
	    (Option.NONE, s_list)
d2195 1
a2195 1
			 ((funid,strid,sigexp,strexp,Option.NONE,_,
d2237 2
a2238 2
                Option.SOME(debugger_str) =>
                  debugger_str := Option.SOME(exp_str)
d2248 2
a2249 2
                   Option.NONE => ()
                 | Option.SOME(ty, atype) =>
d2253 1
a2253 1
                         Option.NONE =>
d2257 1
a2257 1
                       | Option.SOME loc => loc
d2274 1
a2274 1
					 Option.SOME (sigexp',abs),_,
d2368 2
a2369 2
                (Option.SOME(debugger_str),
                 Option.SOME(debugger_str')) =>
d2371 1
a2371 1
                   debugger_str' := Option.SOME(exp_str))
d2378 1
a2378 1
                 String.implode ["Functor body ", IdentPrint.printFunId funid,
d2426 1
a2426 1
	    Option.NONE =>
d2429 1
a2429 1
	  | Option.SOME(ty, atype) =>
d2436 1
a2436 1
                     Option.NONE =>
d2439 1
a2439 1
                   | Option.SOME loc => loc
@


1.114.1.1
log
@branched from 1.114
@
text
@a3 5
 * Revision 1.114  1996/10/09  09:55:41  andreww
 * [Bug #1622]
 * The identifiers that cannot be specified are only forbidden
 * in SML'96.
 *
@


1.113
log
@[Bug #1592]
threading location into Absyn.LOCALexp.
@
text
@d4 4
d612 2
a613 1
            if Lists.member (name,verboten_identifieren)
@


1.112
log
@[Bug #1622]
Make certain identifiers unspecifiable
@
text
@d4 4
d651 2
a652 1
	  | check_strexp (Absyn.APPstrexp (funid,strexp,coerce_ref,location,debugger_str),basis) =
d668 7
a674 3
              (* If we are doing separate compilation then expand the copied structures *)
	       val BasisTypes.PHI (newnames,(newstr'',BasisTypes.SIGMA (newnames',newstr'))) =
                 Sigma.phi_copy (phi,is_separate)
d677 4
a680 2
	       val sigma = BasisTypes.SIGMA (Nameset.union (newnames,newnames'),exp_newstr'')
	       val completion_env = make_completion_env(basis,exp_newstr'',exp_str)
d696 3
a698 2
                  String.implode ["Argument signature of ", IdentPrint.printFunId funid,
                           " does not match the actual argument"]);
d700 2
a701 1
		   (newstr',exp_newstr') (* Approximately correct in error case *)
d706 2
a707 1
                           "impossible type error 6: unbound functor " ^ IdentPrint.printFunId funid);
d719 3
a721 1
          | check_strexp (Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,coerce_ref,location),basis) =
d726 2
a727 1
	      (* Here we want to stop after signature elaboration on any error *)
d749 1
a749 1
			    "Constraining signature does not respect equality");
d753 3
a755 1
	      val sigma' as BasisTypes.SIGMA (names',str') = Sigma.sig_copy (sigma,is_separate)
d782 2
a783 1
		      Sigma.abstract_sigma sigma
d802 1
a802 1
	    env
d849 2
a850 1
	  | check_strbinds ((strid,Option.NONE,strexp,coerce_ref,_,_,debugger_str)::strbinds,
d877 3
a879 1
                  MLWorks.IO.output(MLWorks.IO.std_out,"\n STRBIND "^Ident.Location.to_string location)
d886 2
a887 1
	      (* Here we want to stop after signature elaboration on any error *)
d909 1
a909 1
			    "Constraining signature does not respect equality");
d913 3
a915 1
	      val sigma' as BasisTypes.SIGMA (names',str') = Sigma.sig_copy (sigma,is_separate)
d944 2
a945 1
		      Sigma.abstract_sigma sigma
d984 6
a989 1
	      val BasisTypes.SIGMA (names',str') = Sigma.sig_copy (sigma,is_separate)
a990 1
	      val exp_str' = Env.expand_str str' (* Only necessary for interpreter compilation *)
d994 1
d997 4
a1000 2
	      (sigstr_ass := Assemblies.unionStrAssembly(!sigstr_ass,sigstr_ass');
	       sigty_ass := Assemblies.unionTypeAssembly(!sigty_ass,sigty_ass');
d1005 2
a1006 1
			   "impossible type error 7: unbound signature "^ IdentPrint.printSigId sigid);
d1012 3
a1014 1
              val env = case exp_str of STR (_,_,env) => env | _ => copystr_crash "WHEREsigexp copystr"
d1384 1
a1384 1
                     of Datatypes.TYNAME(_,_,n,_,_,_,_,_) => n=arity
d1460 1
a1460 1
              val _ = check_shareq (shareqlist,exp_env,new_basis)
d1465 14
d1490 1
d1533 2
a1534 1
		  val (BasisTypes.SIGMA (names,str),_) = check_sigexp_closed (sigexp, basis, location)
d1538 1
d1540 2
a1541 1
		    Env.resolve_top_level (COPYSTR((new_strnames,new_tynames), str))
d1545 2
a1546 1
		  val (sigstr_ass',sigty_ass') = Assemblies.newAssemblies (m,exp_env)
d1548 4
a1551 2
		  sigstr_ass := Assemblies.unionStrAssembly(!sigstr_ass,sigstr_ass');
		  sigty_ass := Assemblies.unionTypeAssembly(!sigty_ass,sigty_ass');
d1761 1
a1761 1
	and check_shareq (l,env,basis) =
d1764 3
a1766 2
              if old_definition then check_str_share (stridlist,basis,location)
              else new_check_str_share (stridlist,basis,location)
d1768 6
a1773 1
		check_type_share (tyconlist,env,basis,location)
d1778 4
d1842 6
a1847 1
	and new_check_str_share (sharelist,basis as BasisTypes.BASIS(_,nameset,_,_,env),location) =
d1849 2
a1850 1
	    val BasisTypes.BASIS(_,basis_names,_,_,_) = basis
d1854 4
a1857 2
                  (* We only really need the type and structure parts expanded here *)
                  val str = Env.expand_str (Env.lookup_longstrid (lstrid,env))
d1870 2
d1874 1
a1874 1
					  !sigty_ass, basis_names)
d1879 5
a1883 2
		      ["Failed to share type ", print_path (path,[]), IdentPrint.printTyCon tycon,
                       " in structures ", IdentPrint.printLongStrId strid1, " and ", 
d2113 1
a2113 1
	  | check_exp_for_free_imp(Absyn.LOCALexp(dec, exp), ty) =
d2230 2
a2231 1
	    val phi = BasisTypes.PHI (names,(str,BasisTypes.SIGMA (names',str')))
d2251 2
a2252 1
                           (MLWorks.IO.output(MLWorks.IO.std_out, "No location found\n");
d2259 2
a2260 1
                                    "Free type variable " ^ ty_string ^ " in " ^ ty_string ^ " in functor body")
d2263 3
a2265 1
	   Basis.add_to_funenv (funid,BasisTypes.PHI (names,(str,BasisTypes.SIGMA(names',str'))),
d2272 2
a2273 1
					 coerce_ref,location,debugger_str,debugger_str') :: funbinds),
d2279 3
a2281 1
                  MLWorks.IO.output(MLWorks.IO.std_out,"\n FUNBIND "^Ident.Location.to_string location)
d2285 2
a2286 1
	    val (sigma as BasisTypes.SIGMA (names,str),BasisTypes.SIGMA (_,exp_str)) =
d2351 4
a2354 1
	    val sigma'' as BasisTypes.SIGMA (names'',str'') = Sigma.sig_copy (sigma',is_separate)
d2356 2
a2357 1
	    val completion_env = make_completion_env (new_basis,exp_str'',exp_str')
@


1.112.1.1
log
@branched from 1.112
@
text
@a3 4
 * Revision 1.112  1996/10/04  11:04:22  matthew
 * [Bug #1622]
 * Make certain identifiers unspecifiable
 *
@


1.111
log
@[Bug #1589]
Where types to be elaborated only in the basis not the basis plus env.
@
text
@d4 4
d571 5
d594 20
d1239 1
a1239 1
	    val new_ve = check_valdesc (valdesclist,context)
d1363 2
a1364 2
                map (fn (valid,Datatypes.SCHEME(_,(ty,_))) => (valid,SOME ty)
                      | (valid,Datatypes.UNBOUND_SCHEME(ty,_)) => (valid, NONE)
d1530 1
a1530 1
	and check_valdesc (l,context) =
d1540 1
d1614 1
a1614 1
	  | check_condesc ((valid,Option.NONE)::condescs,
d1623 1
d1628 1
a1628 1
	  | check_condesc ((valid,Option.SOME aty)::condescs,
d1638 1
d1650 3
a1652 2
	      Valenv.add_to_ve (excon,Scheme.make_scheme ([],(Types.exn_type,
							      Option.NONE)),ve)
d1666 1
@


1.110
log
@[Bug #1577]
Adding typechecking rules for datatype replication.
@
text
@d4 4
d951 1
a951 1
                  val context = Basis.context_plus_env (Basis.basis_to_context basis,env)
@


1.109
log
@[Bug #1521]
Propagating changes made to _test.sml that require the
use_value_polymorphism flag to be passed.
@
text
@d4 5
d429 1
a429 1
    Env.Datatypes = Basis.BasisTypes.Datatypes
d1296 69
d1967 1
@


1.109.1.1
log
@branched from 1.109
@
text
@a3 5
 * Revision 1.109  1996/08/06  11:32:58  andreww
 * [Bug #1521]
 * Propagating changes made to _test.sml that require the
 * use_value_polymorphism flag to be passed.
 *
@


1.108
log
@Change check for free imperative type variables to return
the full type as well as the type variable
@
text
@d4 4
d431 1
d1003 4
a1006 3
		    Types.print_type
		    print_options
		    (#1(Types.argres (#1(Scheme.instantiate (1,s,location,false))))) ^
d1204 1
a1204 1
                             (use_value_polymorphism,error_info,print_options,location)
d2001 1
a2001 1
			 ass as (str_ass, ty_ass)) =
d2059 2
a2060 2
		       val atype_string = Types.print_type print_options atype
		       val ty_string = Types.print_type print_options ty
d2075 1
a2075 1
			 ass as (str_ass, ty_ass)) =
d2230 2
a2231 2
		   val atype_string = Types.print_type print_options atype
		   val ty_string = Types.print_type print_options ty
@


1.107
log
@Made the error message for free imperative type variables at top level
depend on the old_definition option.
@
text
@d4 4
d2045 1
a2045 1
                 | Option.SOME ty =>
d2053 2
d2057 1
a2057 1
                                    "Free type variables in functor body")
d2213 1
a2213 1
	  | Option.SOME ty =>
d2224 2
d2230 1
a2230 1
                        "Free imperative type variables at top level")
d2234 1
a2234 1
                        "Free type variables at top level")
@


1.106
log
@Improve error messages for unbound tycons in sharing equations
@
text
@d4 3
d2219 8
a2226 3
                   report_error
                   (Info.RECOVERABLE, location,
                    "Free imperative type variables at top level")
@


1.105
log
@lookupTyCon can also raise Strid exception
@
text
@d4 3
d1749 1
a1749 1
            val context = 
d1752 7
d1770 1
a1770 1
		       IdentPrint.unbound_longtycon_message (tycon,ltycon));
d1775 1
a1775 1
			      IdentPrint.tycon_unbound_strid_message (strid,ltycon));
@


1.104
log
@Fixing problem with lookupTycon
@
text
@d4 3
d934 1
a934 1
              fun apply_tysub (tycon,tyfun,location) =
d936 1
a936 1
                  val Datatypes.TYSTR (tyfun',valenv) = Env.lookup_longtycon (tycon,env)
d954 8
a961 4
                handle Basis.LookupTyCon tycon =>
                  report_error
                  (Info.RECOVERABLE, location,
                   "Undefined type in where type: " ^ IdentPrint.printTyCon tycon)
@


1.103
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d951 4
a954 1
                        
@


1.102
log
@Changing interface to sharing
@
text
@d4 3
d623 1
a623 1
                  implode ["Argument signature of ", IdentPrint.printFunId funid,
d697 1
a697 1
                 implode ["Structure does not match signature"]);
d794 1
a794 1
                  output(std_out,"\n STRBIND "^Ident.Location.to_string location)
d851 1
a851 1
                 implode ["Structure ",IdentPrint.printStrId strid,
d1251 1
a1251 1
		  ((*output(std_out, "datatype desc has unbound type constructors, ignoring\n");*)
d1516 1
a1516 1
			implode ["Exception description of ",
d1524 1
a1524 1
		    ((*output(std_out, "Found bad exception spec, ignoring\n");*)
d1577 1
a1577 1
		   implode ["Sharing ",IdentPrint.printLongStrId lstrid, " and ",
d1593 1
a1593 1
		  implode ["Failed to share structures ",
d1646 1
a1646 1
            fun print_path ([],acc) = implode acc
d1656 1
a1656 1
		      implode
d1718 1
a1718 1
		      implode
d1761 1
a1761 1
	  ((*output(std_out, "type_occurs checking ty1 = " ^
d2017 1
a2017 1
                           (output(std_out, "No location found\n");
d2038 1
a2038 1
                  output(std_out,"\n FUNBIND "^Ident.Location.to_string location)
d2127 1
a2127 1
                 implode ["Functor body ", IdentPrint.printFunId funid,
d2186 1
a2186 1
                       (output(std_out, "No location found\n");
@


1.101
log
@New language features
@
text
@d4 3
d415 1
d423 2
d448 1
a448 1
	val str = STR (STRNAME (Types.make_stamp ()),ref MLWorks.Option.NONE,Env.empty_env)
d453 3
a455 3
    fun set_intref (Absyn.OLDsigexp (_,intref,_),str) = intref := MLWorks.Option.SOME str
      | set_intref (Absyn.NEWsigexp(_,intref),str) = intref := MLWorks.Option.SOME str
      | set_intref (Absyn.WHEREsigexp sigexp,str) = set_intref (sigexp,str)
d541 1
a541 2
	  (Info.FATAL, Info.RECOVERABLE, Info.ADVICE,
	   Info.Location.UNKNOWN)
d555 1
a555 1
	    val str = STR (strname,ref MLWorks.Option.NONE,env)
d569 2
a570 2
                   MLWorks.Option.SOME(interface) =>
                     interface := MLWorks.Option.SOME(exp_str)
d613 1
a613 1
                   MLWorks.Option.SOME(debugger_str) => debugger_str := debugger_str'
d640 1
a640 1
          | check_strexp (Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,coerce_ref),basis) =
a641 1
              val location = Ident.Location.UNKNOWN
d682 1
a682 1
                   MLWorks.Option.SOME(debugger_str) => debugger_str := debugger_str'
d685 2
a686 2
		       MLWorks.Option.SOME(debugger_str'') =>
			 debugger_str'' := MLWorks.Option.SOME(str')
d764 1
a764 1
	  | check_strbinds ((strid,MLWorks.Option.NONE,strexp,coerce_ref,_,_,debugger_str)::strbinds,
d777 2
a778 2
                 MLWorks.Option.SOME(debugger_str) =>
                   debugger_str := MLWorks.Option.SOME(str)
d783 1
a783 1
	  | check_strbinds ((strid,MLWorks.Option.SOME (sigexp,abs),strexp,
d837 1
a837 1
                   MLWorks.Option.SOME(debugger_str) => debugger_str := debugger_str'
d840 2
a841 2
		       MLWorks.Option.SOME(debugger_str'') =>
			 debugger_str'' := MLWorks.Option.SOME(str')
d868 1
a868 1
	    val str = STR(m,ref MLWorks.Option.NONE,env)
d909 38
a946 2
          | check_sigexp_open (Absyn.WHEREsigexp sigexp,basis) =
            check_sigexp_open (sigexp,basis)
d1163 1
a1163 1
	and check_spec (Absyn.VALspec valdesclist,basis) =
d1169 1
a1169 1
                             (use_value_polymorphism,error_info,print_options,Info.Location.UNKNOWN)
d1277 1
a1277 1
	  | check_spec (Absyn.SHARINGspec shareqlist,basis) =
d1279 3
a1281 1
	      val _ = check_shareq (shareqlist,basis)
d1283 1
a1283 1
	      (Env.empty_env, Env.empty_env)
d1325 4
a1328 4
		  fun new_instance (SCHEME (n, (ty, MLWorks.Option.SOME (sch,_)))) =
		    SCHEME (n, (ty, MLWorks.Option.SOME (sch, ref (MLWorks.Option.NONE))))
		    | new_instance (UNBOUND_SCHEME (ty,MLWorks.Option.SOME (sch,_))) =
		      UNBOUND_SCHEME (ty, MLWorks.Option.SOME (sch, ref (MLWorks.Option.NONE)))
d1395 1
a1395 1
		val instance = MLWorks.Option.NONE
d1471 1
a1471 1
	  | check_condesc ((valid,MLWorks.Option.NONE)::condescs,
d1476 1
a1476 1
		Scheme.make_scheme (tyvartypes,(tycon_type,MLWorks.Option.NONE))
d1484 1
a1484 1
	  | check_condesc ((valid,MLWorks.Option.SOME aty)::condescs,
d1490 1
a1490 1
		(tyvartypes,(FUNTYPE (atype,tycon_type),MLWorks.Option.NONE))
d1504 1
a1504 1
	    fun do_one (ve, (excon,MLWorks.Option.NONE,location)) =
d1506 2
a1507 2
							      MLWorks.Option.NONE)),ve)
	      | do_one (ve, (excon,MLWorks.Option.SOME aty,location)) =
d1526 1
a1526 1
							     MLWorks.Option.NONE)),
d1556 1
a1556 1
	and check_shareq (l,basis) =
d1559 2
a1560 1
	      check_str_share (stridlist,basis,location)
d1562 1
a1562 1
		check_type_share (tyconlist,basis,location)
d1627 74
d1703 1
a1703 1
	and check_type_share (sharelist,basis,location) =
d1710 1
a1710 1
		  Sharetypes.share_tyfun (tyfun, tyfun',
d1727 3
d1734 1
a1734 1
		     Basis.lookup_longtycon (ltycon,Basis.basis_to_context basis)
d1785 1
a1785 1
	    MLWorks.Option.SOME loc
d1787 1
a1787 1
	    MLWorks.Option.NONE
d1789 3
a1791 3
	fun get_loc_from_pat(Absyn.WILDpat loc) = MLWorks.Option.SOME loc
	  | get_loc_from_pat(Absyn.SCONpat _) = MLWorks.Option.NONE
	  | get_loc_from_pat(Absyn.VALpat(_, loc)) = MLWorks.Option.SOME loc
d1794 1
a1794 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1796 1
a1796 1
	    (MLWorks.Option.NONE, lab_pat_list)
d1798 1
a1798 1
	    MLWorks.Option.SOME loc
d1800 1
a1800 1
	    MLWorks.Option.SOME loc
d1804 2
a1805 2
	fun check_pat_for_free_imp(Absyn.WILDpat _, _, _) = MLWorks.Option.NONE
	  | check_pat_for_free_imp(Absyn.SCONpat _, _, _) = MLWorks.Option.NONE
d1810 1
a1810 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1812 1
a1812 1
	    (MLWorks.Option.NONE, lab_pat_list)
d1821 1
a1821 1
		MLWorks.Option.NONE => MLWorks.Option.SOME loc
d1824 1
a1824 1
	      MLWorks.Option.NONE
d1833 1
a1833 1
	    fun check_pat_exp(loc as MLWorks.Option.SOME _, _) =
d1837 1
a1837 1
		  MLWorks.Option.NONE =>
d1843 2
a1844 2
	      (MLWorks.Option.NONE, dec_list1) of
	      MLWorks.Option.NONE => Lists.reducel
d1846 1
a1846 1
		(MLWorks.Option.NONE, dec_list2)
d1849 3
a1851 3
	  | check_dec_for_free_imp(Absyn.TYPEdec _, _) = MLWorks.Option.NONE
	  | check_dec_for_free_imp(Absyn.DATATYPEdec _, _) = MLWorks.Option.NONE
	  | check_dec_for_free_imp(Absyn.ABSTYPEdec _, _) = MLWorks.Option.NONE
d1854 1
a1854 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1856 1
a1856 1
	    (MLWorks.Option.NONE, e_list)
d1859 1
a1859 1
	       loc as MLWorks.Option.SOME _ => loc
d1861 1
a1861 1
	  | check_dec_for_free_imp(Absyn.OPENdec _, _) = MLWorks.Option.NONE
d1864 1
a1864 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1867 1
a1867 1
	    (MLWorks.Option.NONE, dec_list)
d1869 2
a1870 2
	and check_exp_for_free_imp(Absyn.SCONexp _, ty) = MLWorks.Option.NONE
	  | check_exp_for_free_imp(Absyn.VALexp _, ty) = MLWorks.Option.NONE
d1873 1
a1873 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1876 1
a1876 1
	    (MLWorks.Option.NONE, lab_exp_list)
d1879 1
a1879 1
	       MLWorks.Option.NONE =>
d1884 1
a1884 1
	       MLWorks.Option.NONE =>
d1891 1
a1891 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1894 1
a1894 1
	    (MLWorks.Option.NONE, pe_list)
d1899 1
a1899 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1902 1
a1902 1
	    (MLWorks.Option.NONE, pe_list)
d1907 1
a1907 1
	  | check_exp_for_free_imp(MLVALUEexp _, ty) = MLWorks.Option.NONE
d1912 1
a1912 1
	    MLWorks.Option.NONE
d1914 1
a1914 1
	    MLWorks.Option.NONE
d1917 1
a1917 1
	      MLWorks.Option.NONE =>
d1925 1
a1925 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1928 1
a1928 1
	    (MLWorks.Option.NONE, e_list)
d1931 1
a1931 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1933 1
a1933 1
	    (MLWorks.Option.NONE, abs_list)
d1936 1
a1936 1
	       MLWorks.Option.NONE => check_strdec_for_free_imp(strdec2, ty)
d1940 1
a1940 1
	    (fn (loc as MLWorks.Option.SOME _, _) => loc
d1942 1
a1942 1
	    (MLWorks.Option.NONE, s_list)
d1956 1
a1956 1
			 ((funid,strid,sigexp,strexp,MLWorks.Option.NONE,_,
d1997 2
a1998 2
                MLWorks.Option.SOME(debugger_str) =>
                  debugger_str := MLWorks.Option.SOME(exp_str)
d2004 17
a2020 15
	       case Env.no_imptyvars env' of
		 MLWorks.Option.NONE => ()
	       | MLWorks.Option.SOME ty =>
		   let
		     val loc = Absyn.check_strexp_for_free_imp(strexp, ty)
		     val location= case loc of
		       MLWorks.Option.NONE =>
			 (output(std_out, "No location found\n");
			  location)
		     | MLWorks.Option.SOME loc => loc
		   in
		     report_error(Info.RECOVERABLE, location,
				  "Free imperative type variables in functor body" (*^
				  "\nwith type = " ^ Types.extra_debug_print_type ty*))
		   end
d2028 1
a2028 1
					 MLWorks.Option.SOME (sigexp',abs),_,
d2114 2
a2115 2
                (MLWorks.Option.SOME(debugger_str),
                 MLWorks.Option.SOME(debugger_str')) =>
d2117 1
a2117 1
                   debugger_str' := MLWorks.Option.SOME(exp_str))
d2172 1
a2172 1
	    MLWorks.Option.NONE =>
d2175 17
a2191 15
	  | MLWorks.Option.SOME ty =>
	      (let
		 val loc = Absyn.check_strdec_for_free_imp(strdec, ty)
		 val location= case loc of
		   MLWorks.Option.NONE =>
		     (output(std_out, "No location found\n");
		      location)
		 | MLWorks.Option.SOME loc => loc
	       in
		 report_error
		 (Info.RECOVERABLE, location,
		  "Free imperative type variables at top level"(* ^
		  "\nwith type = " ^ Types.extra_debug_print_type ty*))
	       end;
	       basis)
@


1.100
log
@Adding use_value_polymorphism option
@
text
@d4 3
d449 1
d635 68
d779 1
a779 1
	  | check_strbinds ((strid,MLWorks.Option.SOME sigexp,strexp,
d881 1
a881 1
	    let
d903 1
a903 1
	     make_dummy_structures())
d905 3
d1279 1
a1279 1
	  | check_spec (Absyn.INCLUDEspec (sigidlist,location),basis) =
d1295 1
a1295 1
	      fun do_one (env,sigid) =
d1297 1
a1297 1
		  val BasisTypes.SIGMA (names,str) = Basis.lookup_sigid (sigid,basis)
d1310 1
a1310 1
		  Env.env_plus_env (env,env1)
d1312 1
a1312 7
	      handle Basis.LookupSigId =>
		(report_error (Info.RECOVERABLE,
			       location,
			       "impossible type error 9: unbound signature " ^
			       IdentPrint.printSigId sigid);
		 env)
	      val new_env = Lists.reducel do_one (Env.empty_env,sigidlist)
d1906 1
a1906 1
					 MLWorks.Option.SOME sigexp',_,
@


1.99
log
@Added location information to Absyn.SIGNATUREtopdec.
@
text
@d4 3
d524 2
a525 1
				 compat_options=Options.COMPATOPTIONS{nj_signatures, ...},
d528 1
d1054 1
a1054 1
                             (error_info,print_options,Info.Location.UNKNOWN)
@


1.98
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d1998 1
a1998 1
	| check_topdec (Absyn.SIGNATUREtopdec sigbindlist,basis) =
@


1.97
log
@Changed interface to Basis.close
@
text
@d4 3
a388 1
  sharing Strnames.Datatypes.Option = Core_rules.Absyn.Option
d433 1
a433 1
	val str = STR (STRNAME (Types.make_stamp ()),ref Option.ABSENT,Env.empty_env)
d438 2
a439 2
    fun set_intref (Absyn.OLDsigexp (_,intref,_),str) = intref := Absyn.Option.PRESENT str
      | set_intref (Absyn.NEWsigexp(_,intref),str) = intref := Absyn.Option.PRESENT str
d538 1
a538 1
	    val str = STR (strname,ref Option.ABSENT,env)
d552 2
a553 2
                   Option.PRESENT(interface) =>
                     interface := Option.PRESENT(exp_str)
d596 1
a596 1
                   Option.PRESENT(debugger_str) => debugger_str := debugger_str'
d680 1
a680 1
	  | check_strbinds ((strid,Absyn.Option.ABSENT,strexp,coerce_ref,_,_,debugger_str)::strbinds,
d693 2
a694 2
                 Option.PRESENT(debugger_str) =>
                   debugger_str := Absyn.Option.PRESENT(str)
d699 1
a699 1
	  | check_strbinds ((strid,Absyn.Option.PRESENT sigexp,strexp,
d753 1
a753 1
                   Option.PRESENT(debugger_str) => debugger_str := debugger_str'
d756 2
a757 2
		       Option.PRESENT(debugger_str'') =>
			 debugger_str'' := Absyn.Option.PRESENT(str')
d784 1
a784 1
	    val str = STR(m,ref Option.ABSENT,env)
d1200 4
a1203 4
		  fun new_instance (SCHEME (n, (ty, Option.PRESENT (sch,_)))) =
		    SCHEME (n, (ty, Option.PRESENT (sch, ref (Option.ABSENT))))
		    | new_instance (UNBOUND_SCHEME (ty,Option.PRESENT (sch,_))) =
		      UNBOUND_SCHEME (ty, Option.PRESENT (sch, ref (Option.ABSENT)))
d1276 1
a1276 1
		val instance = Option.ABSENT
d1352 1
a1352 1
	  | check_condesc ((valid,Absyn.Option.ABSENT)::condescs,
d1357 1
a1357 1
		Scheme.make_scheme (tyvartypes,(tycon_type,Option.ABSENT))
d1365 1
a1365 1
	  | check_condesc ((valid,Absyn.Option.PRESENT aty)::condescs,
d1371 1
a1371 1
		(tyvartypes,(FUNTYPE (atype,tycon_type),Option.ABSENT))
d1385 1
a1385 1
	    fun do_one (ve, (excon,Absyn.Option.ABSENT,location)) =
d1387 2
a1388 2
							      Option.ABSENT)),ve)
	      | do_one (ve, (excon,Absyn.Option.PRESENT aty,location)) =
d1407 1
a1407 1
							     Option.ABSENT)),
d1710 1
a1710 1
	  | check_exp_for_free_imp(Absyn.MLVALUEexp _, ty) = MLWorks.Option.NONE
d1759 1
a1759 1
			 ((funid,strid,sigexp,strexp,Absyn.Option.ABSENT,_,
d1800 2
a1801 2
                Option.PRESENT(debugger_str) =>
                  debugger_str := Absyn.Option.PRESENT(exp_str)
d1829 1
a1829 1
					 Absyn.Option.PRESENT sigexp',_,
d1915 2
a1916 2
                (Option.PRESENT(debugger_str),
                 Option.PRESENT(debugger_str')) =>
d1918 1
a1918 1
                   debugger_str' := Absyn.Option.PRESENT(exp_str))
@


1.96
log
@Add calls to discover exact location of free imperative type variable errors
@
text
@d4 3
d392 2
a393 1
  sharing type Valenv.ErrorInfo  = Realise.Info.options
d1043 3
a1045 1
	      Env.VE_in_env (Basis.close (Basis.context_level context,new_ve,[],Set.empty_set,false))
@


1.95
log
@Use modified form of expand_str to avoid full cost when
gathering strs. We only want the structure name in this case.
@
text
@d4 4
d402 1
a402 1
structure Basis = Basis
d413 1
a413 1
    exception WellFormed of BasisTypes.Sigma 
d426 2
a427 1
      let val str = STR (STRNAME (Types.make_stamp ()),ref Option.ABSENT,Env.empty_env)
d452 1
a452 1
      
d461 1
a461 1
            (fn (_,(subname,_)) => 
d497 1
a497 1
     and has_unbounds_ve(VE(_, amap)) =
d528 1
a528 1
	fun check_strexp (Absyn.NEWstrexp strdec,basis) = 
d534 1
a534 1
	  in 
d537 1
a537 1
        
d539 1
a539 1
        
d541 1
a541 1
	    (let 
d549 1
a549 1
	     in 
d556 1
a556 1
	       
d558 1
a558 1
          
d561 2
a562 2
              val (str,exp_str) = check_strexp (strexp,basis)
              val phi = Basis.lookup_funid (funid,basis)
d565 1
a565 1
              We have to copy both the body and the argument of the functor 
d568 1
a568 1
              specified in the declaration of the functor is represented by the 
d571 1
a571 1
              yielding sharing between the argument structure and the result 
d574 1
a574 1
            
d576 1
a576 1
	       val BasisTypes.PHI (newnames,(newstr'',BasisTypes.SIGMA (newnames',newstr'))) = 
d583 5
a587 5
		  (sigmatch (location,
			     completion_env,
			     Basis.context_level(Basis.basis_to_context basis),
			     sigma,
			     exp_str))
d599 2
a600 2
	       if do_coerce then coerce_ref := true else ();
               (newstr',exp_newstr') (* Approximately correct in error case *)
d602 1
a602 1
           handle Basis.LookupFunId => 
d607 1
a607 1
          
d609 1
a609 1
          
d616 1
a616 1
          
d618 1
a618 1
          
a619 9
          
        and check_strdec (Absyn.DECstrdec dec,basis) = 
	      let val env = check_dec (dec,Basis.basis_to_context basis)
	      in
	        Valenv.resolve_overloads
		  error_info
		  (env, options);
		env
	      end
d621 8
d631 2
a632 1
	  | check_strdec (Absyn.STRUCTUREstrdec strbindlist,basis) = 
d634 1
a634 1
          
d636 2
a637 1
	  | check_strdec (Absyn.ABSTRACTIONstrdec strbindlist,basis) = 
d639 1
a639 1
          
d641 3
a643 3
          
	  | check_strdec (Absyn.LOCALstrdec (strdec1,strdec2),basis) = 
	    let 
d648 1
a648 1
          
d650 2
a651 2
          
	  | check_strdec (Absyn.SEQUENCEstrdec strdeclist,basis) = 
d665 1
a665 1
             
d667 1
a667 1
          
d673 1
a673 1
        
d676 1
a676 1
			    do_abstraction) = 
d680 1
a680 1

d687 1
a687 1
                 Option.PRESENT(debugger_str) => 
d690 1
a690 1
               Strenv.add_to_se (strid,str,se'))
d695 1
a695 1
			      strbinds,
d697 1
a697 1
			    do_abstraction) = 
d699 1
a699 1
              val _ = 
d717 1
a717 1
		 handle WellFormed sigma => 
d740 1
a740 1
	      
d749 4
a752 4
                 case debugger_str'' of
                   Option.PRESENT(debugger_str'') => 
                     debugger_str'' := Absyn.Option.PRESENT(str')
                 | _ => ())
d755 1
a755 1
              else 
d760 8
a767 8
	      if do_coerce then coerce_ref := true else ();
              if do_abstraction then
                let val BasisTypes.SIGMA(_,abs_str) =
                  Sigma.abstract_sigma sigma
                in Strenv.add_to_se (strid,abs_str,se')
                end
              else
                Strenv.add_to_se (strid,str',se')
d774 18
a791 22
      and check_sigexp_open (Absyn.NEWsigexp (spec,_),basis) = 
        let
          val m = METASTRNAME (ref (NULLNAME (Types.make_stamp ())))
          val (env, _) = check_spec (spec,basis)
          val str = STR(m,ref Option.ABSENT,env)
(*
          val _ = output (std_out,"check_sigexp_open:\n")
          val _ = output (std_out,Env.string_str str)
*)
          val exp_str = Env.expand_str str
	  val ENV (se,te,_) = get_env_or_crash ("expand_str",exp_str)
          val type_offspring =
            Assemblies.collectTypeOffspring (te,Assemblies.findTypeOffspring(m,!sigstr_ass))
        in
          sigstr_ass :=
          Assemblies.add_to_StrAssembly
          (m,
           Assemblies.collectStrOffspring (se,Assemblies.findStrOffspring(m,!sigstr_ass)),
           type_offspring,!sigstr_ass);
          (str,exp_str)
        end
        
d793 5
a797 5
        
        | check_sigexp_open (Absyn.OLDsigexp (sigid,_,location),basis) =
           let
             val sigma = Basis.lookup_sigid (sigid,basis)
               
d799 1
a799 1
              It is necessary to copy the signature because sharing is done 
d802 17
a818 17
             val BasisTypes.SIGMA (names',str') = Sigma.sig_copy (sigma,is_separate)
                                                 
             val exp_str' = Env.expand_str str' (* Only necessary for interpreter compilation *)
	     val (m,env) = get_name_and_env ("expand_str",exp_str')
	      
             val (sigstr_ass',sigty_ass') = Assemblies.newAssemblies (m,env)
               (* put the old (uncopied) structure in the interface slot *)
           in
             (sigstr_ass := Assemblies.unionStrAssembly(!sigstr_ass,sigstr_ass');
              sigty_ass := Assemblies.unionTypeAssembly(!sigty_ass,sigty_ass');
              (str',exp_str'))
           end
           handle Basis.LookupSigId => 
             (report_error (Info.RECOVERABLE, location,
                            "impossible type error 7: unbound signature "^ IdentPrint.printSigId sigid);
              make_dummy_structures())
          
a819 8
          
      and check_sigexp_closed (sigexp,basis,location) =
         let
           val BasisTypes.BASIS(_,basis_names,_,_,_) = basis

           val (str,exp_str) = check_sigexp_open(sigexp,basis)
          
           val nameset = Sigma.new_names_of exp_str
d821 5
a825 1
           val real_nameset = Nameset.diff(nameset,basis_names)
d827 1
a827 2
           val sigma = BasisTypes.SIGMA(real_nameset,str)
           val exp_sigma = BasisTypes.SIGMA(real_nameset, exp_str)
d829 76
a904 6
(*
           val _ = output(std_out,"New names:" ^ Nameset.string_nameset print_options nameset ^ "\n")
           val _ = output(std_out,"Basis names:" ^ Nameset.string_nameset print_options basis_names ^ "\n")
           val _ = output(std_out,"Real names:" ^ Nameset.string_nameset print_options real_nameset ^ "\n")
           val _ = output(std_out,"Sigma:" ^ Sigma.string_sigma print_options exp_sigma ^ "\n")
*)
d906 22
a927 60
           fun tystr_respect_equality (_, TYSTR (tyfun,VE (_,amap))) =
             let
               fun eq_scheme (valid, s) = 
                 Scheme.equalityp s orelse
                 (report_error
                  (Info.RECOVERABLE, location,
                   Types.print_type
                   print_options
                   (#1(Types.argres (#1(Scheme.instantiate (1,s,location,false))))) ^
                   " does not admit equality: constructor is " ^
                   IdentPrint.printValId print_options valid);
                  false)
             in
               if Types.equalityp tyfun then
                 (NewMap.forall eq_scheme amap)
               else true
             end
                  
           fun se_respect_equality(_, str) =
             let fun get_env (STR(_,_,env)) = env
                   | get_env (COPYSTR ((smap,tmap),str')) =
                     copystr_crash "se_respect_equality"
             in
               env_respect_equality (get_env str)
             end

           and env_respect_equality (env as ENV (se as SE amap,
                                                 te as TE amap',_)) =
             Env.empty_envp env orelse
             aswell(NewMap.forall se_respect_equality amap,
                    NewMap.forall tystr_respect_equality amap')
             
           fun respect_equality (BasisTypes.SIGMA (names,STR (_,_,env))) = 
             env_respect_equality env
             | respect_equality _ = copystr_crash "respect_equality"
             
(*
           fun te_equality_principal (TE amap) =
             let
               fun max_eq_pred (_, TYSTR (atyfun,VE (_,amap))) =
                 if (Types.equalityp atyfun) andalso not (NewMap.forall eq_scheme amap)
                   then Types.make_false atyfun
                 else
                   true
             in
               while not (NewMap.forall max_eq_pred amap) do ()
             end
               
           fun se_equality_principal (_,STR (_,_,env)) =
             env_equality_principal env
             | se_equality_principal _ = copystr_crash "se_equality_principal"
           and env_equality_principal (ENV (SE amap,te,_)) = 
             (te_equality_principal te;
              NewMap.forall se_equality_principal amap)
             
           fun equality_principal (sigma as BasisTypes.SIGMA (names,STR(_,_,env))) =
             (env_equality_principal env;
              sigma)
             | equality_principal _ = copystr_crash "equality_principal"
*)
d929 4
a932 19
	   fun max_eq_pred (_, TYSTR (atyfun,VE (_,amap))) =
	     if (Types.equalityp atyfun) andalso not (NewMap.forall eq_scheme amap)
	       then Types.make_false atyfun
	     else
	       true

           fun se_equality_principal (_,STR (_,_,env)) =
             env_equality_principal env
             | se_equality_principal _ = copystr_crash "se_equality_principal"

           and env_equality_principal (ENV (SE amap,TE amap',_)) = 
             NewMap.forall max_eq_pred amap' andalso
	     NewMap.forall se_equality_principal amap
             
           fun equality_principal (sigma as BasisTypes.SIGMA (names,STR(_,_,env))) =
	     let
	       val tynames = Nameset.tynames_of_nameset names
	       val _ = Lists.iterate
		 (fn tyname =>
d934 3
a936 1
		    val tyfun = ETA_TYFUN tyname
d938 21
a958 13
		    if Types.null_tyfunp tyfun andalso
		      not(Valenv.empty_valenvp
			  (#1(Assemblies.lookupTyfun(tyfun, !sigty_ass))))
		      then
			Types.make_true tyname else ()
		  end)
		 tynames
	     in
	       while not (env_equality_principal env) do ();
	       sigma
	     end

             | equality_principal _ = copystr_crash "equality_principal"
d960 2
a961 56
           (* this should probably report errors as it goes *)
           fun well_formed (BasisTypes.SIGMA (names,STR (_,_,env))) =
             let
               fun check_env (ENV (SE amap,_,_)) =
                 NewMap.forall check_one amap
               and check_one (strid,STR(m,_,env)) =
                 if
                   (* it is a local name *)
                   Nameset.member_of_strnames (m,names)
                   then
                     (* so check recursively *)
                     check_env env
                 else
                   (* check all substructures are non-local *)
                   Nameset.emptyp
                   (Nameset.intersection (names,
                                          Sigma.names_of_env env))
                 | check_one _ = copystr_crash "check"
             in
               check_env env
             end
             | well_formed _ = copystr_crash "well_formed"

           fun te_type_explicit (names,[],name_copies) = name_copies
             | te_type_explicit (names,(tycon,TYSTR(tyfun,_))::tycons,
                                 name_copies) =
               if Types.null_tyfunp tyfun then
                 let
                   val type_name = Types.name tyfun
                   val name_copies' = 
                     te_type_explicit (names,tycons,name_copies)
                 in
                   if Nameset.member_of_tynames (type_name, names) then
                     type_name:: name_copies'
                   else name_copies
                 end
               else te_type_explicit (names,tycons,name_copies)
                  
           fun se_type_explicit (names,[],name_copies) = name_copies
             | se_type_explicit (names,(_,STR(_,_,env))::stridenvs,name_copies) = 
               se_type_explicit (names,stridenvs,env_type_explicit (names,env,name_copies))
             | se_type_explicit _ = copystr_crash "se_type_explicit"
                  
           and env_type_explicit (names,ENV (SE amap,TE amap',_),
                                  name_copies) =
             let
               val strid_str_list = NewMap.to_list amap
               val tycon_tystr_list = NewMap.to_list amap'
               val name_copies' = te_type_explicit (names,tycon_tystr_list,
                                                    name_copies)
             in
               se_type_explicit (names,strid_str_list,name_copies')
             end
                
           fun type_explicit (BasisTypes.SIGMA (names,STR (_,_,env))) =
              let 
d966 1
a966 1
                 Nameset.tynames_in_nameset(name_copies,Nameset.empty_nameset ())) 
d968 13
a980 13
             | type_explicit _ = copystr_crash "type_explicit"
       in
         (* Only the last check ("equality principal") modifies the structure, and *)
         (* then it is through modifications of tynames *)
         (if not (respect_equality exp_sigma)
            then raise RespectEquality sigma
          else ();
          if not (type_explicit exp_sigma)
            then raise TypeExplicit sigma
          else ();
          if not (well_formed exp_sigma)
            then raise WellFormed sigma
          else ();
d983 4
a986 4
          equality_principal exp_sigma);
         set_intref(sigexp,str);
         (sigma,exp_sigma)
       end
d989 1
a989 1
  
d996 33
a1028 33
    and check_sigbind (Absyn.SIGBIND [],basis,sigenv, _) = sigenv
       
      | check_sigbind (Absyn.SIGBIND ((sigid,sigexp,location)::sigbinds),basis,
                       sigenv, ass as (str_ass, ty_ass)) =
	 let 
	   val _ = sigstr_ass := str_ass
	   val _ = sigty_ass := ty_ass
	   val (sigma as BasisTypes.SIGMA (names,str),BasisTypes.SIGMA(_,exp_str)) =
             (check_sigexp_closed (sigexp,basis,location))
             handle
             WellFormed sigma => 
               (report_error
                (Info.RECOVERABLE, location,
                 "Signature " ^ IdentPrint.printSigId sigid ^ 
                 " is not well-formed");
                (sigma,sigma))
           | TypeExplicit sigma =>
               (report_error
                (Info.RECOVERABLE, location,
                 "Signature "  ^ IdentPrint.printSigId sigid ^ 
                 " is not type-explicit");
                (sigma,sigma))
           | RespectEquality sigma =>
               (report_error
                (Info.RECOVERABLE, location,
                 "Signature "  ^ IdentPrint.printSigId sigid ^ 
                 " does not respect equality");
                (sigma,sigma))
	 in
           Basis.add_to_sigenv(sigid,BasisTypes.SIGMA(names,str),
				check_sigbind(Absyn.SIGBIND sigbinds,
					      basis,sigenv, ass))
	 end
d1034 9
a1042 9
    and check_spec (Absyn.VALspec valdesclist,basis) =
      let
	val context = Basis.basis_to_context basis
	val new_ve = check_valdesc (valdesclist,context)
	val new_env =
	  Env.VE_in_env (Basis.close (Basis.context_level context,new_ve,[],Set.empty_set,false))
      in
	(new_env, new_env)
      end
d1046 10
a1055 10
      | check_spec (Absyn.TYPEspec typedesclist,basis) =
	let
	  val new_te = check_typdesc (typedesclist,
				      Basis.basis_to_context basis,
				      false)
	  val new_env = Env.TE_in_env new_te
	in
	  (new_env, new_env)
	end
      
d1057 1
a1057 1
      (* the type functions are constructed to admit equality in 
d1060 9
a1068 9
      | check_spec (Absyn.EQTYPEspec typedesclist,basis) =
	let
	  val new_te = check_typdesc (typedesclist,
				      Basis.basis_to_context basis,
				      true)
	  val new_env = Env.TE_in_env new_te
	in
	  (new_env, new_env)
	end
d1071 53
a1123 53
 
      | check_spec (Absyn.DATATYPEspec datdesclist,
		    basis as BasisTypes.BASIS (_,_,_,_,ENV (_,te,_))) =
	let
	  fun make_dummy_te ([],te) = te
	    | make_dummy_te ((tyvars,tycon,condescs)::datadescs,te) = 
	      make_dummy_te (datadescs,
			     Tyenv.add_to_te
			     (te,tycon,
			      TYSTR 
			      (Types.make_eta_tyfun 
			       (METATYNAME (ref (NULL_TYFUN
						 (Types.make_stamp(),(ref(TYFUN(NULLTYPE,0))))),
					    IdentPrint.printTyCon
					    tycon,
					    Lists.length tyvars,
					    ref true,
					    ref empty_valenv,
					    ref false)),
			       empty_valenv)))

	  val new_context =
	    Basis.context_plus_te (Basis.basis_to_context basis,
				   make_dummy_te (datdesclist,te))
	  val (new_ve,new_te) =
	    check_datdesc (datdesclist,new_context,(empty_valenv,
						    Tyenv.empty_tyenv))

	  (* can we use the similar function above instead of this? *)
	  fun max_eq (TE amap) =
	    while 
	      not (NewMap.forall
		   (fn (_, TYSTR (atyfun,VE (_,amap')))
		    =>
		      if Types.equalityp atyfun then
			NewMap.forall eq_scheme amap' orelse
			Types.make_false atyfun
		      else
			true)
		   amap)
	      do
	      ()
	  val _ = max_eq new_te

	  val new_env =
	    if has_unbounds_te new_te orelse has_unbounds_ve new_ve then
	      ((*output(std_out, "datatype desc has unbound type constructors, ignoring\n");*)
	       Env.empty_env)
	    else
	      Env.VE_TE_in_env(new_ve,new_te)
	in
	  (new_env, new_env)
	end
d1126 8
a1133 8
    
      | check_spec (Absyn.EXCEPTIONspec exdesclist,basis) =
	let 
	  val ve = check_exdesc(exdesclist,Basis.basis_to_context basis)
	  val new_env = Env.VE_in_env ve
	in
	  (new_env, new_env)
	end
d1137 6
a1142 6
      | check_spec (Absyn.STRUCTUREspec strdesclist,basis) =
	let
	  val new_env = Env.SE_in_env(check_strdesc (strdesclist,basis))
	in
	  (new_env, new_env)
	end
d1146 6
a1151 6
      | check_spec (Absyn.SHARINGspec shareqlist,basis) =
	let 
	  val _ = check_shareq (shareqlist,basis)
	in
	  (Env.empty_env, Env.empty_env)
	end
d1155 6
a1160 6
      | check_spec (Absyn.LOCALspec (spec1,spec2),basis) =
	let
	  val (new_result, _) = check_spec (spec1,basis)
	in
	  check_spec (spec2,Basis.basis_plus_env (basis, new_result))
	end
d1164 1
a1164 3
      | check_spec (Absyn.OPENspec(longstridlist,location),basis) = 
	let 
	  fun do_one (env,longstrid) =
d1166 15
a1180 4
	      val newenv =
		get_env_or_crash
		("resolve_top_level",
		 Env.resolve_top_level(Basis.lookup_longstrid (longstrid, basis)))
d1182 2
a1183 1
	      Env.env_plus_env (env,newenv)
a1184 10
	  handle Basis.LookupStrId strid =>
	    (report_error
	     (Info.RECOVERABLE, location,
              IdentPrint.strid_unbound_strid_message(strid, longstrid, print_options));
	     env)
	  val new_env = Lists.reducel do_one (Env.empty_env,longstridlist)
	in
	  (* Fix here for NJ weird open *)
	  (if nj_signatures then Env.empty_env else new_env, new_env)
	end
a1186 16
  
      | check_spec (Absyn.INCLUDEspec (sigidlist,location),basis) =
	let
          fun new_instances (STR (strname, mlvalue, ENV (strenv, tyenv, VE (n,map)))) = 
            let
              fun new_instance (SCHEME (n, (ty, Option.PRESENT (sch,_)))) =
                SCHEME (n, (ty, Option.PRESENT (sch, ref (Option.ABSENT))))
                | new_instance (UNBOUND_SCHEME (ty,Option.PRESENT (sch,_))) =
                  UNBOUND_SCHEME (ty, Option.PRESENT (sch, ref (Option.ABSENT)))
                | new_instance scheme = scheme
            in
              STR(strname, mlvalue, ENV (strenv, tyenv,
                                         VE (n, NewMap.map (fn (_,tysch) => new_instance tysch) map)))
            end
            | new_instances (COPYSTR((strmap,tynmap),str)) = 
              COPYSTR((strmap,tynmap),new_instances str)
d1188 1
a1188 1
	  fun do_one (env,sigid) =
d1190 38
a1227 10
	      val BasisTypes.SIGMA (names,str) = Basis.lookup_sigid (sigid,basis)
	      val str = new_instances str
	      val (_,new_strnames,new_tynames) = 
		Nameset.new_names_from_scratch names
	      val str' = 
		Env.resolve_top_level (COPYSTR((new_strnames,new_tynames), str))
	      val env1 = get_env_or_crash ("resolve_top_level",str')
	      val (m,exp_env) = get_name_and_env("expand_str",
						 Env.expand_str str')
	      val (sigstr_ass',sigty_ass') = Assemblies.newAssemblies (m,exp_env)
d1229 1
a1229 3
	      sigstr_ass := Assemblies.unionStrAssembly(!sigstr_ass,sigstr_ass');
	      sigty_ass := Assemblies.unionTypeAssembly(!sigty_ass,sigty_ass');
	      Env.env_plus_env (env,env1)
a1230 10
	  handle Basis.LookupSigId =>
	    (report_error (Info.RECOVERABLE,
			   location,
			   "impossible type error 9: unbound signature " ^
			   IdentPrint.printSigId sigid);
             env)
	  val new_env = Lists.reducel do_one (Env.empty_env,sigidlist)
	in
	  (new_env, new_env)
	end
d1235 2
a1236 2
      | check_spec (Absyn.SEQUENCEspec [],basis) = 
	(Env.empty_env, Env.empty_env)
d1238 1
a1238 3
      | check_spec (Absyn.SEQUENCEspec speclist,basis) =
	let
	  fun do_one ((result, env, basis),spec) =
d1240 13
a1252 6
	      val (result', env') = check_spec(spec,basis)
	      val new_result = Env.env_plus_env(result, result')
	      (* What we'll return *)
	      val new_basis = Basis.basis_plus_env(basis, env')
	      (* What we carry on elaborating in *)
	      val new_env = Env.env_plus_env(env, env')
d1254 1
a1254 1
	      (new_result, new_env, new_basis)
d1256 1
a1256 6
	  val (new_result, new_env, _) =
	    Lists.reducel do_one ((Env.empty_env, Env.empty_env, basis), speclist)
	in
	  (new_result, new_env)
	end
        
d1261 16
a1276 16
   and check_valdesc (l,context) =
      let
        fun do_one ((ve,context),(valid,ty,tyvarset)) =
          let
            val tyvars_scoped_here = Set.setdiff (tyvarset,Basis.get_tyvarset context)
            val new_context = Basis.context_plus_tyvarset (context, tyvars_scoped_here)
            val atype = check_type (ty,new_context)
            val instance = Option.ABSENT
            val ascheme = Scheme.make_scheme ([],(atype,instance))
          in
            (Valenv.add_to_ve (valid,ascheme,ve), new_context)
          end
        val (new_ve,_) = Lists.reducel do_one ((empty_valenv,context),l)
      in
        new_ve
      end
d1282 22
a1303 22
    and check_typdesc (l,context,eq) =
       let 
         fun do_one (te,(tyvarlist,tycon)) =
	 let
	   val tyfun = 
	     Types.make_eta_tyfun 
	     (METATYNAME (ref (NULL_TYFUN(Types.make_stamp(),(ref(TYFUN(NULLTYPE,0))))),
			  IdentPrint.printTyCon tycon,
			  Lists.length tyvarlist,
			  ref eq,
			  ref empty_valenv,
                          ref false))
	 in
           Tyenv.add_to_te (te,tycon,TYSTR (tyfun,empty_valenv))
	 end
         
       in
         Lists.reducel do_one (Tyenv.empty_tyenv,l)
       end
       
    (* *** Datatype Descriptions *** *) 
  
d1306 23
a1328 2
    and check_datdesc ([],_,(ve,te)) =
      (ve,te)
a1329 22
      | check_datdesc ((tyvarlist,tycon,condescs)::datdescs,
		       context,
		       (ve,te)) =
	let
	  val new_context = Basis.context_plus_tyvarlist (context,tyvarlist)
	  val TYSTR (tyfun,_) = Basis.lookup_tycon (tycon,new_context)
	    handle Basis.LookupTyCon tycon =>
	      Crash.impossible ("Unbound type constructor in check_datdesc "
				^ IdentPrint.printTyCon tycon)
	  val tyvartypes = (map (fn x => check_type (Absyn.TYVARty x,new_context)) tyvarlist) 
	in
	  check_datdesc (datdescs,new_context,
			 check_condesc (condescs,
					tycon,
					tyfun,
					Types.apply (tyfun,tyvartypes),
					tyvartypes,
					new_context,
					empty_valenv,
					(ve,te)))
	end
      
d1331 40
a1370 40
  
    and check_condesc ([],tycon,tyfun,tycon_type,tyvartypes,
		       acontext,conenv,(ve,te)) = 
      (sigty_ass := Assemblies.add_to_TypeAssembly (tyfun,conenv,1,!sigty_ass);
       let
	 val valenv_ref = case tycon_type of
	   CONSTYPE(_, METATYNAME{5=valenv_ref, ...}) => valenv_ref
	 | _ => Crash.impossible"bad tycon_type in signature"
       in
	 (valenv_ref := conenv;
	  (ve,(Tyenv.add_to_te (te, tycon,TYSTR (tyfun,conenv)))))
       end)
      
      | check_condesc ((valid,Absyn.Option.ABSENT)::condescs,
		       tycon,tyfun,tycon_type,tyvartypes,
		       acontext,conenv,(ve,te)) =
        let 
          val tyscheme = 
            Scheme.make_scheme (tyvartypes,(tycon_type,Option.ABSENT))
          val new_ve = Valenv.add_to_ve (valid,tyscheme,ve)
          val new_conenv = Valenv.add_to_ve (valid,tyscheme,conenv)
        in
          check_condesc (condescs,tycon,tyfun,tycon_type,tyvartypes,
                         acontext,new_conenv,(new_ve,te))
        end
      
      | check_condesc ((valid,Absyn.Option.PRESENT aty)::condescs,
		       tycon,tyfun,tycon_type,tyvartypes,
		       acontext,conenv,(ve,te)) =
	 let 
	   val atype = check_type (aty,acontext)
	   val tyscheme = Scheme.make_scheme 
	     (tyvartypes,(FUNTYPE (atype,tycon_type),Option.ABSENT))
	   val new_ve = Valenv.add_to_ve (valid,tyscheme,ve)
	   val new_conenv = Valenv.add_to_ve (valid,tyscheme,conenv)
	 in
           check_condesc (condescs,tycon,tyfun,tycon_type,tyvartypes,
			  acontext,new_conenv,(new_ve,te))
	 end
     
d1375 30
a1404 30
    and check_exdesc (exdescs,context) = 
      let
        fun do_one (ve, (excon,Absyn.Option.ABSENT,location)) =
          Valenv.add_to_ve (excon,Scheme.make_scheme ([],(Types.exn_type,
                                                          Option.ABSENT)),ve)
          | do_one (ve, (excon,Absyn.Option.PRESENT aty,location)) =
            let 
              val atype = 
                if Absyn.has_tyvar (aty) then 
                  (report_error
                   (Info.RECOVERABLE, location,
                    implode ["Exception description of ",
                             IdentPrint.printValId print_options excon,
                             " contains a type variable"]);
                   fresh_tyvar (context, false, false))
                else
                  check_type (aty,context)
            in
	      if Types.type_has_unbound_tyvars atype then
		((*output(std_out, "Found bad exception spec, ignoring\n");*)
		 ve)
	      else
		Valenv.add_to_ve (excon,
				  Scheme.make_scheme([],(FUNTYPE (atype,Types.exn_type),
							 Option.ABSENT)),
				  ve)
            end
      in
        Lists.reducel do_one (empty_valenv,exdescs)
      end
d1410 12
a1421 12
      and check_strdesc (strdescs, basis) =
        let 
          fun do_one (se,(strid,sigexp)) =
          let
            val (str,_) = check_sigexp_open (sigexp,basis)
          in
            Strenv.add_to_se (strid,str,se)
          end
        in
          Lists.reducel do_one (Strenv.empty_strenv,strdescs)
        end
            
d1425 1
a1425 1
    
d1429 9
a1437 9
    and check_shareq (l,basis) = 
      let
        fun do_one (Absyn.STRUCTUREshareq stridlist,location) =
          check_str_share (stridlist,basis,location)
          | do_one (Absyn.TYPEshareq tyconlist,location) =
            check_type_share (tyconlist,basis,location)
      in
        Lists.iterate do_one l
      end
d1439 40
a1478 50
    and check_str_share (sharelist,basis as BasisTypes.BASIS(_,nameset,_,_,env),location) =
      let
        fun do_two ((lstrid,STR(m,_,_)),(lstrid',STR(m',_,_))) =
          if circularp (m,m',!sigstr_ass)
            then
              report_error
              (Info.RECOVERABLE, location,
               implode ["Sharing ",IdentPrint.printLongStrId lstrid, " and ",
                        IdentPrint.printLongStrId lstrid', " creates a cycle"])
          else
            (let 
              val (share_successful,sigstr_ass',sigty_ass') = 
                Share.share_str (m,m',!sigstr_ass,!sigty_ass,nameset)
            in		  
               if share_successful
                 then (sigstr_ass := sigstr_ass';
                       sigty_ass := sigty_ass')
               else
                 () (* do we need to print a message here? *)
            end
            handle Share.ShareError s =>
              report_error
              (Info.RECOVERABLE, location,
               implode ["Failed to share structures ",
                        IdentPrint.printLongStrId lstrid, " and ",
                        IdentPrint.printLongStrId lstrid', ":\n  ", s]))
          | do_two _ = ()

	fun get_structure_name_from_str((smap, _), str as STR(m, r, e)) =
	  STR(Strnames.strname_copy(m, smap), r, e)
	  | get_structure_name_from_str(maps, COPYSTR(maps', str)) =
	    get_structure_name_from_str(Env.compose_maps(maps', maps), str)

	val get_structure_name_from_str =
	  fn (str as STR _) => str
	   | COPYSTR arg => get_structure_name_from_str arg
(*
	fun get_structure_name_from_str(str as STR _) =
	  str
	  | get_structure_name_from_str(COPYSTR(maps as (smap, _), str)) =
	    case str of
	      STR(m, r, e) => STR(Strnames.strname_copy(m, smap), r, e)
	    | COPYSTR(maps', str') =>
		get_structure_name_from_str(COPYSTR(Env.compose_maps(maps', maps),
						    str'))
*)

        fun gather_strs ([],acc) = rev acc
          | gather_strs (lstrid::l,acc) =
            (let
d1484 40
a1523 14
	     in
               gather_strs(l,(lstrid,str)::acc)
	     end
	     handle Env.LookupStrId strid =>
	       (report_error
		(Info.RECOVERABLE, location,
		 IdentPrint.strid_unbound_strid_message (strid,lstrid,print_options));
		gather_strs (l,acc)))
        
        fun aux (s::(l as s'::_)) = (do_two (s,s');aux l)
          | aux _ = ()
      in
        aux (gather_strs (sharelist,[]))
      end
d1525 18
a1542 1
    (* *** rule 89 *** *)  
a1543 3
   and check_type_share (sharelist,basis,location) =
      let
	val BasisTypes.BASIS(_,basis_names,_,_,_) = basis
d1545 5
a1549 19
        fun do_two ((ltycon,tyfun),(ltycon',tyfun')) =
          let 
            val (share_successful,sigty_ass') = 
              Sharetypes.share_tyfun (tyfun, tyfun',
                                      !sigty_ass, basis_names)
              handle Sharetypes.ShareError s =>
                (report_error
                 (Info.RECOVERABLE, location,
                  implode
                  ["Failed to share types ",
                   IdentPrint.printLongTyCon ltycon, " and ",
                   IdentPrint.printLongTyCon ltycon', ": ", s]);
                 (false,!sigty_ass))
          in
            if share_successful
              then sigty_ass := sigty_ass'
            else
              ()
          end
d1551 32
a1582 19
        fun gather_tyfuns ([],acc) = rev acc
          | gather_tyfuns (ltycon::l,acc) =
            (let
              val TYSTR (tyfun,_) = 
                Basis.lookup_longtycon (ltycon,Basis.basis_to_context basis)
            in
               gather_tyfuns(l,(ltycon,tyfun)::acc)
            end
            handle Basis.LookupTyCon tycon =>
              (report_error
               (Info.RECOVERABLE, location,
                IdentPrint.unbound_longtycon_message (tycon,ltycon));
               gather_tyfuns (l,acc))
               | Basis.LookupStrId strid =>
              (report_error
               (Info.RECOVERABLE, location,
                IdentPrint.tycon_unbound_strid_message (strid,ltycon));
               gather_tyfuns (l,acc)))
                   
d1584 36
a1619 5
        fun aux (s::(l as s'::_)) = (do_two (s,s');aux l)
          | aux _ = ()
      in
        aux (gather_tyfuns (sharelist,[]))
      end
d1621 4
a1624 1
        
d1626 113
d1750 1
a1750 1
	| check_funbind (Absyn.FUNBIND 
d1754 1
a1754 1
			 ass as (str_ass, ty_ass)) = 
d1758 1
a1758 1
	    val (BasisTypes.SIGMA (names,str),BasisTypes.SIGMA (_,exp_str)) = 
d1760 1
a1760 1
	      handle WellFormed sigma => 
d1780 1
a1780 1
				     ENV (Strenv.add_to_se 
d1792 1
a1792 1
                Option.PRESENT(debugger_str) => 
d1798 20
a1817 10
	    in
	      if Env.no_imptyvars env'
		then ()
	      else
		report_error (Info.RECOVERABLE, location, 
			      "Free imperative type variables in functor body")
	    end;
	    Basis.add_to_funenv (funid,BasisTypes.PHI (names,(str,BasisTypes.SIGMA(names',str'))),
				  check_funbind (Absyn.FUNBIND funbinds,basis,
						 funenv, ass)))
d1819 1
a1819 1
       
d1824 1
a1824 1
			 ass as (str_ass, ty_ass)) = 
d1826 1
a1826 1
            val _ = 
d1834 1
a1834 1
	       handle WellFormed sigma => 
d1849 1
a1849 1
	      
d1873 1
a1873 1
			   handle WellFormed sigma => 
d1908 1
a1908 1
                 Option.PRESENT(debugger_str')) => 
d1919 1
a1919 1
            val names' = 
d1926 1
a1926 1
              Basis.add_to_funenv 
d1945 1
a1945 1
	| check_fundec(funbind::funbindlist, basis, funenv, ass) = 
d1955 3
a1957 3
  
      fun check_topdec (Absyn.STRDECtopdec (strdec,location),basis as BasisTypes.BASIS (_,nameset,_,_,_)) = 
	let 
d1964 2
a1965 2
          if (Env.no_imptyvars exp_new_env) (* get something expanded from check_strdec? *)
	    then 
d1968 15
a1982 5
	  else
	    (report_error
	     (Info.RECOVERABLE, location,
	      "Free imperative type variables at top level");
	     basis)
d1984 1
a1984 1
     
d1987 1
a1987 1
	| check_topdec (Absyn.SIGNATUREtopdec sigbindlist,basis) = 
d1992 1
a1992 1
	      
d2001 3
a2003 3
            type variables because they have all been caught by previous 
	    checks. According to Mads Tofte the side condition in rule 101 
	    is there for cosmetic reasons only. *) 
d2010 1
a2010 1
	| check_topdec (Absyn.FUNCTORtopdec (funbindlist,location),basis) = 
d2026 1
a2026 1
*)     
@


1.94
log
@Attempting to improve some error behaviour
@
text
@d4 3
d1472 1
a1472 1
        fun do_two ((lstrid,str as STR(m,_,_)),(lstrid',str' as STR(m',_,_))) =
d1498 19
d1520 6
a1525 3
              (* nice if env was expanded *)
              val str = Env.expand_str (Env.lookup_longstrid (lstrid,env))
            in
d1527 6
a1532 6
            end
            handle Env.LookupStrId strid =>
              (report_error
               (Info.RECOVERABLE, location,
                IdentPrint.strid_unbound_strid_message (strid,lstrid,print_options));
               gather_strs (l,acc)))
@


1.93
log
@Reinstate unbound strid in openspec error
The parser cannot catch some of these
@
text
@d4 4
d547 1
a547 1
	      make_dummy_structures ()))
d585 1
a585 4
	       if realise 
                 then
		 (if do_coerce then coerce_ref := true else ();
		  (newstr',exp_newstr'))
d587 6
a592 5
		 (report_error
		  (Info.RECOVERABLE, location,
		   implode ["Argument signature of ", IdentPrint.printFunId funid,
			    " does not match the actual argument"]);
		  make_dummy_structures())
d745 14
a758 15
	      if realise then
		(if do_coerce then coerce_ref := true else ();
		 if do_abstraction then
		   let val BasisTypes.SIGMA(_,abs_str) =
		         Sigma.abstract_sigma sigma
		   in Strenv.add_to_se (strid,abs_str,se')
		   end
	         else
		   Strenv.add_to_se (strid,str',se'))
	      else
		(report_error
		 (Info.RECOVERABLE, location,
		  implode ["Structure ",IdentPrint.printStrId strid,
			   " does not match signature"]);
		 Strenv.empty_strenv)
d1732 20
a1751 24
            
	  in
	    if realise then
	      let
		val names' = 
		  Nameset.diff (Sigma.names_of exp_str'',
				Nameset.union (nameset,names))
		val phi = BasisTypes.PHI(names,(str,BasisTypes.SIGMA (names',str'')))
	      in
		if do_coerce then coerce_ref := true else ();
		set_intref (sigexp',str'');
		Basis.add_to_funenv 
                (funid,BasisTypes.PHI (names,(str,
                         BasisTypes.SIGMA(names',str''))),
				      check_funbind (Absyn.FUNBIND funbinds,
						     basis,funenv, ass))
	      end
	    else
	      (report_error
	       (Info.RECOVERABLE, location,
		implode ["Functor body ", IdentPrint.printFunId funid,
			 " does not match result signature"]);
	       funenv)
	  end
@


1.92
log
@Removing debug_polyvariables option
@
text
@d4 3
d1193 13
a1205 17
	    (let 
	       val newenv =
		 get_env_or_crash
		 ("resolve_top_level",
		  Env.resolve_top_level(Basis.lookup_longstrid (longstrid,
								basis)))
             in
	       Env.env_plus_env (env,newenv)
	     end
	   handle Basis.LookupStrId strid =>
             Crash.impossible "open error should be caught by parser")
(*
	     (report_error
	      (Info.RECOVERABLE, location,
              IdentPrint.strid_unbound_strid_message (strid,lstrid,print_options));
              env))
*)
@


1.91
log
@How much structure expansion is done is determined by whether we are doing
separate compilation
@
text
@d4 4
a496 2
                                 compiler_options = 
                                 Options.COMPILEROPTIONS{debug_polyvariables,...},
d1295 1
a1295 5
            val instance = 
              if debug_polyvariables then 
                Option.PRESENT(ref NO_INSTANCE, ref Option.ABSENT)
              else
                Option.ABSENT
@


1.90
log
@Debugger changes
@
text
@d4 3
a306 1
require "../utils/timer";
a329 1
  structure Timer      : TIMER
a391 2
    val print_times = ref false

d408 1
a408 1
      let val str = STR (STRNAME (Strname_id.make_strname_id ()),ref Option.ABSENT,Env.empty_env)
d473 1
a473 10
    (* Not all of these are currently used *)
    fun has_unbounds(ENV(se, te, ve)) =
      has_unbounds_se se orelse has_unbounds_te te orelse has_unbounds_ve ve

    and has_unbounds_se(SE amap) =
      NewMap.exists
      (fn (_, str) => has_unbounds_str str)
      amap

    and has_unbounds_te(TE amap) =
d478 1
a478 1
    and has_unbounds_ve(VE(_, amap)) =
a482 3
    and has_unbounds_str(STR(_, _, env)) = has_unbounds env
      | has_unbounds_str(COPYSTR(_, str)) = has_unbounds_str str

d496 1
a496 1
				 ...}, topdec, basis, assembly) =
a508 2
	fun compress_str str = (* Env.compress_str *) str

d513 1
a513 1
	    val strname = STRNAME (Strname_id.make_strname_id ())
d516 1
a516 4
	    val exp_str = 
	      Timer.xtime ("expanding structure",
			   !print_times,
			   fn () => Env.expand_str str)
d543 3
a545 9
	    (let 
              val _ =
                if generate_moduler_debug then
                  output(std_out,"\n APPstrexp"^Ident.Location.to_string location)
                else ()
	       val (str,exp_str) =
		 Timer.xtime ("check_strexp 55", !print_times,fn () => check_strexp (strexp,basis))
	       val phi as BasisTypes.PHI (names,(str'',BasisTypes.SIGMA (names',str'))) = 
		 Basis.lookup_funid (funid,basis)
d557 4
a560 2
                 
	       val BasisTypes.PHI (newnames,(newstr'',BasisTypes.SIGMA (newnames',newstr'))) = Sigma.phi_copy phi
d563 1
a563 1
	       val sigma = BasisTypes.SIGMA (newnames,exp_newstr'')
a565 3
		 Timer.xtime
		 ("sigmatch 55", !print_times,
		  fn () =>
d570 1
a570 1
			     exp_str)))
d718 1
a718 1
	      val sigma' as BasisTypes.SIGMA (names',str') = Sigma.sig_copy sigma
d761 2
a762 3
          val m = METASTRNAME (ref (NULLNAME (Strname_id.make_strname_id ())))
          val (env, _) = Timer.xtime("check_spec", !print_times,
                                fn () => check_spec (spec,basis))
d764 4
d785 1
a785 3
             val BasisTypes.SIGMA (names,str) = Basis.lookup_sigid (sigid,basis)
             val (names',new_strnames,new_tynames) = 
               Nameset.new_names_from_scratch names
d791 3
a793 2
             val str' = COPYSTR((new_strnames,new_tynames),str)
             val exp_str' = Env.expand_str str' (* necessary *)
d814 1
a814 3
           val (str,exp_str) =
             Timer.xtime("check_sigexp_open", !print_times,
			 fn () => check_sigexp_open(sigexp,basis))
d816 1
a816 4
           val nameset = 
             Timer.xtime("new_names_of",
                         !print_times,
			 fn () => Sigma.new_names_of exp_str)
d820 1
a820 6

           val comp_str =
             Timer.xtime ("compressing sigma",
                          !print_times,
                          fn () => compress_str str)
           val sigma = BasisTypes.SIGMA(real_nameset,comp_str)
d991 16
a1006 18
         (Timer.xtime ("wellformedness checks", !print_times,
                      fn () => 
                      (* Only the last check ("equality principal") modifies the structure, and *)
                      (* then it is through modifications of tynames *)
                      (if not (respect_equality exp_sigma)
                         then raise RespectEquality sigma
                       else ();
                       if not (type_explicit exp_sigma)
                         then raise TypeExplicit sigma
                       else ();
                       if not (well_formed exp_sigma)
                         then raise WellFormed sigma
                       else ();
                       (* This should work by side-effecting the names in the sigma and the *)
                       (* expanded sigma *)
                       equality_principal exp_sigma));
         set_intref(sigexp,comp_str);
         (sigma,exp_sigma))
d1104 1
a1104 1
						 (Tyfun_id.make_tyfun_id(),(ref(TYFUN(NULLTYPE,0))))),
d1169 1
a1169 3
	  val _ = 
	    Timer.xtime ("check_shareq", !print_times,
			 fn () =>  check_shareq (shareqlist,basis))
d1215 14
a1231 13
	      fun new_instances (STR(strname,mlvalue,ENV(strenv,tyenv,VE(n,map)))) = 
		let
		  fun new_instance (SCHEME(n,(ty,Option.PRESENT(sch,_)))) =
		    SCHEME(n,(ty,Option.PRESENT(sch,ref(Option.ABSENT))))
		    | new_instance (UNBOUND_SCHEME(ty,Option.PRESENT(sch,_))) =
		      UNBOUND_SCHEME(ty,Option.PRESENT(sch,ref(Option.ABSENT)))
		    | new_instance scheme = scheme
		in
		  STR(strname,mlvalue,ENV(strenv,tyenv,
					  VE(n,NewMap.map (fn (_,tysch)=>new_instance tysch) map)))
		end
		| new_instances (COPYSTR((strmap,tynmap),str)) = 
		  COPYSTR((strmap,tynmap),new_instances str)
d1317 1
a1317 1
	     (METATYNAME (ref (NULL_TYFUN(Tyfun_id.make_tyfun_id(),(ref(TYFUN(NULLTYPE,0))))),
d1655 1
a1655 4
	      Timer.xtime 
	      ("check_sigexp_closed", !print_times,
	       fn () => 
	       (check_sigexp_closed (sigexp,basis,location))
d1670 1
a1670 1
			 (sigma,sigma)))
d1673 1
a1673 3
	      Timer.xtime("basis_plus_env", !print_times,
			  fn () =>
			  Basis.basis_plus_names
d1680 1
a1680 1
			  names))
d1683 1
a1683 2
	    val (str',exp_str') = Timer.xtime("check_strexp", !print_times,
					      fn () => check_strexp(strexp,new_basis))
d1694 1
a1694 3
	      Timer.xtime ("check_sigexp_closed", !print_times,
			   fn () =>
			   (check_sigexp_closed (sigexp',new_basis,location))
d1709 1
a1709 1
				     (sigma,sigma)))
d1719 1
a1719 2
	    (* This won't produce an expanded sigma *)
	    val sigma'' as BasisTypes.SIGMA (names'',str'') = Sigma.sig_copy sigma'
d1723 4
a1726 7
	       Timer.xtime("sigmatch",
			   !print_times,
			   fn () =>
			   (sigmatch (location,completion_env,
				      Basis.context_level (Basis.basis_to_context basis),
				      BasisTypes.SIGMA(names'',exp_str''),
				      exp_str')))
a1741 4
		val comp_str'' =
		  Timer.xtime ("Compressing result sig",
			       !print_times,
			       fn () => compress_str str'')
d1744 1
a1744 1
		set_intref (sigexp',comp_str'');
d1747 1
a1747 1
                         BasisTypes.SIGMA(names',comp_str''))),
d1785 3
a1787 1
	  val basis_inc = Basis.env_in_basis new_env
d1789 2
a1790 1
          if (Env.no_imptyvars new_env) (* get something expanded from check_strdec? *)
d1792 2
a1793 7
	      Basis.basis_plus_names(basis_inc, Sigma.names_of_env new_env)
(*
            (* This ought to be a smaller nameset *)
            Basis.basis_plus_names (Basis.env_in_basis new_env,
                                     Nameset.diff (Sigma.names_of_env new_env,
                                                   nameset))
*)
@


1.89
log
@Removing debug stuff
@
text
@d4 3
d1326 2
a1327 4
            val tyvars_scoped_here = 
              Set.setdiff (tyvarset,Basis.get_tyvarset context)
            val new_context = 
              Basis.context_plus_tyvarset (context, tyvars_scoped_here)
d1329 6
a1334 6
            val ascheme = Scheme.make_scheme ([],
                                              (atype,
                                               if debug_polyvariables then 
                                                 Option.PRESENT(ref(NO_INSTANCE),ref(Option.ABSENT))
                                               else
                                                 Option.ABSENT))
@


1.88
log
@Tidying up
@
text
@d4 3
a305 1
require "../typechecker/ty_debug";
a308 1
require "../typechecker/tystr";
a318 4
require "../typechecker/sigenv";
require "../typechecker/phi";
require "../typechecker/funenv";
require "../typechecker/tyvarenv";
a329 1
  structure Ty_Debug   : TY_DEBUG
a339 1
  structure Phi        : PHI
a340 3
  structure Funenv     : FUNENV
  structure Sigenv     : SIGENV
  structure Tyvarenv   : TYVARENV
a344 5
  structure Debug      :
    sig
      val set_debug_level : int -> unit
      val debug_level : unit -> int
    end
d347 1
a347 2
    Sigma.BasisTypes = Sigenv.BasisTypes = Funenv.BasisTypes = Phi.BasisTypes =
    Basis.BasisTypes = Tyvarenv.BasisTypes = Sharetypes.Assemblies.Basistypes
a410 7
    fun debug L  =
      if Debug.debug_level () > 10 then
	(Lists.iterate Print.print L;
	 Print.print"\n")
      else
	()

d437 1
a437 1
	    val os_map = Assemblies.StrOffspring_to_map stroffspring
d538 1
a538 1
	  | check_strexp (Absyn.OLDstrexp (longstrid,location,interface),basis) =
d540 1
a540 1
	       val str = Basis.lookup_longstrid (longstrid,basis)
d550 1
a550 1
	   handle Basis.LookupLongStrId =>
d552 1
a552 2
			    implode ["unbound structure identifier ",
				     IdentPrint.printLongStrId longstrid]);
d579 1
a579 1
	       val BasisTypes.PHI (newnames,(newstr'',BasisTypes.SIGMA (newnames',newstr'))) = Phi.phi_copy phi
d612 1
a612 1
                           "impossible type error 6: unbound functor identifier " ^ IdentPrint.printFunId funid);
d825 1
a825 1
                            "impossible type error 7: unbound signature identifier "^ IdentPrint.printSigId sigid);
d1078 1
a1078 1
           Sigenv.add_to_sigenv(sigid,BasisTypes.SIGMA(names,str),
a1086 13
(*
    and check_spec' x =
      let
	val result as (_, e2) = check_spec x
      in
	if has_unbounds e2 then
	  (output(std_out, "Unbound tyvars in spec, ignoring\n");
	   (Env.empty_env, Env.empty_env))
	else
	  result
      end
*)

d1231 3
a1233 1
	   handle Basis.LookupLongStrId =>
d1236 3
a1238 3
	       "unbound structure identifier " ^ 
	       IdentPrint.printLongStrId longstrid);
	      env))
d1282 1
a1282 1
			   "impossible type error 9: unbound signature identifier " ^
d1326 1
a1326 2
              Basis.context_plus_tyvarset_and_tyvarenv (context,
                                                        tyvars_scoped_here)
d1374 1
a1374 1
		       context as BasisTypes.CONTEXT (level,tyvarset,env,_),
d1377 1
a1377 7
	  fun collect ([],amap) = amap
	    | collect (h::t,amap) =
	      Tyvarenv.add_to_tyvarenv (level,h,collect(t,amap))
	  fun make_tyvarenv (tyvars) =
	    collect (tyvars,Tyvarenv.empty_tyvarenv)
	  val new_context = BasisTypes.CONTEXT (level,tyvarset,env,
						make_tyvarenv tyvarlist)
d1379 1
a1379 1
	    handle Basis.LookupTyCon =>
d1540 1
a1540 1
            handle Env.Lookup_LongStrId =>
d1543 2
a1544 3
                "Unbound structure identifier " ^
                IdentPrint.printLongStrId lstrid);
                gather_strs (l,acc)))
d1586 6
a1591 1
            handle Basis.LookupLongTyCon =>
d1594 1
a1594 1
                "Unbound type constructor "^ IdentPrint.printLongTyCon ltycon);
d1596 1
d1672 1
a1672 1
	    Funenv.add_to_funenv (funid,BasisTypes.PHI (names,(str,BasisTypes.SIGMA(names',str'))),
d1796 1
a1796 1
		Funenv.add_to_funenv 
d1818 1
a1818 1
			 Sigenv.sigenv_plus_sigenv (new_sigenv, sigenv), ass)
d1828 1
a1828 1
			  Funenv.funenv_plus_funenv (new_funenv, funenv), ass)
d1863 1
a1863 1
	      check_sigdec (sigbindlist,basis, Sigenv.empty_sigenv, ass)
d1884 1
a1884 1
	    val new_funenv = check_fundec(funbindlist,basis, Funenv.empty_funenv, ass)
@


1.87
log
@Fix spelling of contructor to constructor
@
text
@d4 3
d451 1
a451 1
    fun mycrash s = Crash.impossible ("Unexpanded structure in " ^ s)
d903 1
a903 1
                     mycrash "se_respect_equality"
d916 1
a916 1
             | respect_equality _ = mycrash "respect_equality"
d932 1
a932 1
             | se_equality_principal _ = mycrash "se_equality_principal"
d940 1
a940 1
             | equality_principal _ = mycrash "equality_principal"
d951 1
a951 1
             | se_equality_principal _ = mycrash "se_equality_principal"
d977 1
a977 1
             | equality_principal _ = mycrash "equality_principal"
d996 1
a996 1
                 | check_one _ = mycrash "check"
d1000 1
a1000 1
             | well_formed _ = mycrash "well_formed"
d1020 1
a1020 1
             | se_type_explicit _ = mycrash "se_type_explicit"
d1041 1
a1041 1
             | type_explicit _ = mycrash "type_explicit"
a1102 3
(*
	   handle Bind => mycrash "457"
*)
d1363 5
a1367 5
                           (atype,
                            if debug_polyvariables then 
                              Option.PRESENT(ref(NO_INSTANCE),ref(Option.ABSENT))
                            else
                              Option.ABSENT))
d1422 1
a1422 3
	  val tyvartypes = (map
			    (fn x =>	check_type (Absyn.TYVARty x,new_context))
			    tyvarlist) 
@


1.86
log
@Added call to Valenv.resolve_overloads, and location argument to
Scheme.instantiate.  Also added two sharing type equations.
@
text
@d4 4
d888 1
a888 1
                   " does not admit equality: contructor is " ^
@


1.85
log
@Fix unbound type constructors in specifications problems
@
text
@d4 3
d373 2
d644 9
a652 2
             check_dec (dec,Basis.basis_to_context basis)
        
d883 1
a883 1
                   (#1(Types.argres (#1(Scheme.instantiate (1,s,false))))) ^
@


1.84
log
@Remove Bind handler
@
text
@d4 3
d480 29
d1093 13
d1107 8
a1114 8
       let
	 val context = Basis.basis_to_context basis
	 val new_ve = check_valdesc (valdesclist,context)
	 val new_env =
	   Env.VE_in_env (Basis.close (Basis.context_level context,new_ve,[],Set.empty_set,false))
       in
	 (new_env, new_env)
       end
d1119 8
a1126 8
	 let
	   val new_te = check_typdesc (typedesclist,
				       Basis.basis_to_context basis,
				       false)
	   val new_env = Env.TE_in_env new_te
	 in
	   (new_env, new_env)
	 end
d1133 8
a1140 8
	 let
	   val new_te = check_typdesc (typedesclist,
				       Basis.basis_to_context basis,
				       true)
	   val new_env = Env.TE_in_env new_te
	 in
	   (new_env, new_env)
	 end
d1146 50
a1195 40
	 let
	   fun make_dummy_te ([],te) = te
	     | make_dummy_te ((tyvars,tycon,condescs)::datadescs,te) = 
	       make_dummy_te (datadescs,
			      Tyenv.add_to_te
			      (te,tycon,
			       TYSTR 
			       (Types.make_eta_tyfun 
				(METATYNAME (ref (NULL_TYFUN
					(Tyfun_id.make_tyfun_id(),(ref(TYFUN(NULLTYPE,0))))),
					     IdentPrint.printTyCon
					     tycon,
					     Lists.length tyvars,
					     ref true,
					     ref empty_valenv,
                                             ref false)),
				empty_valenv)))

	   val new_context = 
	     Basis.context_plus_te (Basis.basis_to_context basis,
				    make_dummy_te (datdesclist,te))
	   val (new_ve,new_te) = 
	     check_datdesc (datdesclist,new_context,(empty_valenv,
						     Tyenv.empty_tyenv))

           (* can we use the similar function above instead of this? *)
	   fun max_eq (TE amap) =
	     while 
	       not (NewMap.forall
                    (fn (_, TYSTR (atyfun,VE (_,amap')))
		     =>
		       if Types.equalityp atyfun then
			 NewMap.forall eq_scheme amap' orelse
			 Types.make_false atyfun
		       else
			 true)
		    amap)
	       do
	       ()
	   val _ = max_eq new_te
a1196 5
	   val new_env = Env.VE_TE_in_env(new_ve,new_te)
	 in
	   (new_env, new_env)
	 end
      
d1200 6
a1205 6
	 let 
           val ve = check_exdesc(exdesclist,Basis.basis_to_context basis)
	   val new_env = Env.VE_in_env ve
	 in
	   (new_env, new_env)
	 end
d1219 7
a1225 7
         let 
           val _ = 
             Timer.xtime ("check_shareq", !print_times,
                          fn () =>  check_shareq (shareqlist,basis))
         in
           (Env.empty_env, Env.empty_env)
         end
d1239 3
a1241 3
	 let 
	   fun do_one (env,longstrid) =
	     (let 
d1248 1
a1248 1
                Env.env_plus_env (env,newenv)
d1250 11
a1260 11
             handle Basis.LookupLongStrId =>
               (report_error
                (Info.RECOVERABLE, location,
                 "unbound structure identifier " ^ 
                 IdentPrint.printLongStrId longstrid);
                env))
	   val new_env = Lists.reducel do_one (Env.empty_env,longstridlist)
	 in
           (* Fix here for NJ weird open *)
	   (if nj_signatures then Env.empty_env else new_env, new_env)
	 end
d1265 36
a1300 36
         let
	   fun do_one (env,sigid) =
	     let
	       val BasisTypes.SIGMA (names,str) = Basis.lookup_sigid (sigid,basis)
               fun new_instances (STR(strname,mlvalue,ENV(strenv,tyenv,VE(n,map)))) = 
                 let
                   fun new_instance (SCHEME(n,(ty,Option.PRESENT(sch,_)))) =
                     SCHEME(n,(ty,Option.PRESENT(sch,ref(Option.ABSENT))))
                     | new_instance (UNBOUND_SCHEME(ty,Option.PRESENT(sch,_))) =
                       UNBOUND_SCHEME(ty,Option.PRESENT(sch,ref(Option.ABSENT)))
                     | new_instance scheme = scheme
                 in
                   STR(strname,mlvalue,ENV(strenv,tyenv,
                                    VE(n,NewMap.map (fn (_,tysch)=>new_instance tysch) map)))
                 end
                 | new_instances (COPYSTR((strmap,tynmap),str)) = 
                   COPYSTR((strmap,tynmap),new_instances str)
               val str = new_instances str
	       val (_,new_strnames,new_tynames) = 
		 Nameset.new_names_from_scratch names
	       val str' = 
                 Env.resolve_top_level (COPYSTR((new_strnames,new_tynames), str))
	       val env1 = get_env_or_crash ("resolve_top_level",str')
	       val (m,exp_env) = get_name_and_env("expand_str",
						  Env.expand_str str')
               val (sigstr_ass',sigty_ass') = Assemblies.newAssemblies (m,exp_env)
             in
               sigstr_ass := Assemblies.unionStrAssembly(!sigstr_ass,sigstr_ass');
               sigty_ass := Assemblies.unionTypeAssembly(!sigty_ass,sigty_ass');
	       Env.env_plus_env (env,env1)
	     end
           handle Basis.LookupSigId =>
             (report_error (Info.RECOVERABLE,
                            location,
                            "impossible type error 9: unbound signature identifier " ^
                            IdentPrint.printSigId sigid);
d1302 4
a1305 4
	   val new_env = Lists.reducel do_one (Env.empty_env,sigidlist)
         in 
           (new_env, new_env)
         end
d1311 1
a1311 1
	 (Env.empty_env, Env.empty_env)
d1314 17
a1330 17
         let
           fun do_one ((result, env, basis),spec) =
             let
	       val (result', env') = check_spec(spec,basis)
               val new_result = Env.env_plus_env(result, result')
	       (* What we'll return *)
               val new_basis = Basis.basis_plus_env(basis, env')
	       (* What we carry on elaborating in *)
	       val new_env = Env.env_plus_env(env, env')
             in
               (new_result, new_env, new_basis)
             end
           val (new_result, new_env, _) =
	     Lists.reducel do_one ((Env.empty_env, Env.empty_env, basis), speclist)
         in 
           (new_result, new_env)
         end
d1394 25
a1418 25
	 let 
           fun collect ([],amap) = amap
             | collect (h::t,amap) =
		 Tyvarenv.add_to_tyvarenv (level,h,collect(t,amap))
	     fun make_tyvarenv (tyvars) =
	       collect (tyvars,Tyvarenv.empty_tyvarenv)
	     val new_context = BasisTypes.CONTEXT (level,tyvarset,env,
					      make_tyvarenv tyvarlist)
	     val TYSTR (tyfun,_) = Basis.lookup_tycon (tycon,new_context)
	       handle Basis.LookupTyCon =>
                 Crash.impossible ("Unbound type constructor in check_datdesc "
                                   ^ IdentPrint.printTyCon tycon)
	     val tyvartypes = (map
			       (fn x =>	check_type (Absyn.TYVARty x,new_context))
			       tyvarlist) 
	 in
           check_datdesc (datdescs,new_context,
			  check_condesc (condescs,
					 tycon,
					 tyfun,
					 Types.apply (tyfun,tyvartypes),
					 tyvartypes,
					 new_context,
					 empty_valenv,
					 (ve,te)))
d1484 8
a1491 4
              Valenv.add_to_ve (excon,
                                Scheme.make_scheme([],(FUNTYPE (atype,Types.exn_type),
                                                       Option.ABSENT)),
                                ve)
@


1.83
log
@Debugger structure and structure recording for Modules Debugger.
@
text
@d4 3
d1052 1
d1054 1
@


1.82
log
@yes
Found a way to generate some 'impossible' type errors.
@
text
@d4 4
d359 1
d363 1
d467 1
d478 1
a478 2
                                 Options.COMPILEROPTIONS{debug_variables,
                                                         debug_polyvariables,...},
a481 18
        fun new_instances (STR(strname,mlvalue,ENV(strenv,tyenv,VE(n,map)))) = 
          let
            fun new_instance (SCHEME(n,(ty,Option.PRESENT(sch,_)))) =
                SCHEME(n,(ty,Option.PRESENT(sch,ref(Option.ABSENT))))
              | new_instance (UNBOUND_SCHEME(ty,Option.PRESENT(sch,_))) =
                UNBOUND_SCHEME(ty,Option.PRESENT(sch,ref(Option.ABSENT)))
              | new_instance scheme = scheme
          in
            STR(strname,mlvalue,ENV(strenv,tyenv,
                            VE(n,NewMap.map (fn (_,tysch)=>new_instance tysch) map)))
          end
          | new_instances (COPYSTR((strmap,tynmap),str)) = 
            COPYSTR((strmap,tynmap),new_instances str)
        val new_instances = 
          if debug_polyvariables then 
            fn str => new_instances str
          else 
            fn str => str
d512 1
a512 1
	  | check_strexp (Absyn.OLDstrexp (longstrid,location),basis) =
d516 5
d532 1
a532 1
	  | check_strexp (Absyn.APPstrexp (funid,strexp,coerce_ref,location),basis) =
d534 4
d559 1
a559 1
	       val (realise, do_coerce) =
d568 4
d648 1
a648 1
	  | check_strbinds ((strid,Absyn.Option.ABSENT,strexp,coerce_ref,_)::strbinds,
d660 5
a664 1
              Strenv.add_to_se (strid,str,se')
d667 5
a671 2
	  | check_strbinds ((strid,Absyn.Option.PRESENT sigexp,strexp,coerce_ref,location)::
			      strbinds, basis, do_abstraction) = 
d673 4
d715 1
a715 1
	      val (realise, do_coerce) =
d719 8
d836 2
a837 2
                   (#1(Types.argres (#1(Scheme.instantiate (1,s))))) ^
                   " does not admit equality; constructor is " ^
d1105 1
a1105 5
					(Tyfun_id.make_tyfun_id(),
                                         if debug_variables orelse debug_polyvariables then 
                                           Option.PRESENT(ref (TYFUN(NULLTYPE,0)))
                                         else 
                                           Option.ABSENT)),
d1214 13
d1315 1
a1315 5
	     (METATYNAME (ref (NULL_TYFUN(Tyfun_id.make_tyfun_id(),
                                         if debug_variables orelse debug_polyvariables then 
                                           Option.PRESENT(ref (TYFUN(NULLTYPE,0)))
                                         else 
                                           Option.ABSENT)),
d1529 2
a1530 1
              Sharetypes.share_tyfun (tyfun,tyfun',!sigty_ass, basis_names)
d1581 1
a1581 1
			   coerce_ref,location):: funbinds),
d1619 5
d1641 1
a1641 1
					 coerce_ref,location) :: funbinds),
d1645 4
d1728 1
a1728 1
	    val (realise, do_coerce) =
d1736 8
@


1.81
log
@Added level field to Basis.
Renamed Basis.level to Basis.context_level
@
text
@d4 4
d533 1
a533 1
			    implode ["impossible type error 5: unbound structure identifier ",
d1182 1
a1182 1
                 "impossible type error 8: unbound structure identifier " ^ 
@


1.80
log
@fixup various error messages, inexhaustive bindings, etc.
@
text
@d4 3
d389 1
a389 1
      METATYVAR (ref (Basis.level acontext,NULLTYPE,NO_INSTANCE), eq, imp)
d531 1
a531 1
	      make_dummy_structures()))
d564 1
a564 1
			     Basis.level(Basis.basis_to_context basis),
d568 2
a569 1
	       if realise then
d644 1
a644 1
			    basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_)),
d701 1
a701 1
			  Basis.level (Basis.basis_to_context basis),
d776 1
a776 1
           val BasisTypes.BASIS(basis_names,_,_,_) = basis
d1037 1
a1037 1
	   Env.VE_in_env (Basis.close (Basis.level context,new_ve,[],Set.empty_set,false))
d1071 1
a1071 1
		    basis as BasisTypes.BASIS (_,_,_,ENV (_,te,_))) =
d1442 1
a1442 1
    and check_str_share (sharelist,basis as BasisTypes.BASIS(nameset,_,_,env),location) =
d1495 1
a1495 1
	val BasisTypes.BASIS(basis_names,_,_,_) = basis
d1552 1
a1552 1
			 basis as BasisTypes.BASIS (nameset,_,_,_),funenv,
d1607 1
a1607 1
			 basis as BasisTypes.BASIS (nameset,_,_,_),funenv,
d1694 1
a1694 1
				      Basis.level (Basis.basis_to_context basis),
d1748 1
a1748 1
      fun check_topdec (Absyn.STRDECtopdec (strdec,location),basis as BasisTypes.BASIS (nameset,_,_,_)) = 
@


1.79
log
@Marked certain error messages as "impossible".
@
text
@d4 3
d454 6
d507 2
a508 2
	    val exp_str as STR(_,_,ENV (se,te,_)) =
	      Timer.xtime ("expanding structure structure",
d510 1
a510 1
			   fn () => Env.expand_str str) (* expanded structure needed *)
d520 1
a520 1
	       val exp_str as STR(m,_,ENV(se,te,_)) = Env.expand_str str (* nice if basis expanded  *)
d571 1
a571 1
		   implode ["argument signature of ", IdentPrint.printFunId funid,
d643 2
a644 1
	      val (str,STR(m,_,env)) = check_strexp (strexp,basis)
d655 1
a655 3
			      strbinds,
			    basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_)),
			    do_abstraction) = 
d657 1
a657 1
	      val (str,exp_str as STR(m,_,env)) = check_strexp (strexp,basis)
d674 1
a674 1
		     "constraining signature is not well-formed");
d679 1
a679 1
			    "constraining signature is not type-explicit");
d684 1
a684 1
			    "constraining signature does not respect equality");
d689 1
a689 1
	      val exp_str' as STR(m', _, env') = Env.expand_str str'
d692 1
a692 2
	      val se' = check_strbinds (strbinds,basis (* new_basis *),
					do_abstraction)
d712 1
a712 1
		  implode ["structure ",IdentPrint.printStrId strid,
d727 2
a728 1
          val exp_str as STR(_,_,ENV (se,te,_)) = Env.expand_str str
d753 3
a755 2
             val exp_str' as STR (m,_,env) = Env.expand_str str' (* necessary *)

d809 2
a810 2
                   " does not admit equality: contructor is " ^
                   IdentPrint.debug_printValId valid);
d1002 1
a1002 1
                 "signature " ^ IdentPrint.printSigId sigid ^ 
d1008 1
a1008 1
                 "signature "  ^ IdentPrint.printSigId sigid ^ 
d1014 1
a1014 1
                 "signature "  ^ IdentPrint.printSigId sigid ^ 
d1163 5
a1167 1
	       val STR (_,_,newenv) = Env.resolve_top_level(Basis.lookup_longstrid (longstrid,basis))
d1193 1
a1193 1
	       val str' as STR (_,_,env1) =
d1195 3
a1197 1
               val STR (m,_,exp_env) = Env.expand_str str'
d1445 1
a1445 1
               implode ["sharing ",IdentPrint.printLongStrId lstrid, " and ",
d1461 1
a1461 1
               implode ["failed to share structures ",
d1477 1
a1477 1
                "unbound structure identifier " ^
d1501 1
a1501 1
                  [" failed to share types ",
d1523 1
a1523 1
                "unbound type constructor "^ IdentPrint.printLongTyCon ltycon);
d1558 1
a1558 1
		  "argument signature is not well-formed");
d1563 1
a1563 1
			 "argument signature is not type-explicit");
d1568 1
a1568 1
			 "argument signature does not respect equality");
d1587 1
a1587 1
	      val STR (_,_,env') = exp_str'
d1593 1
a1593 1
			      "free imperative type variables in functor body")
d1616 1
a1616 1
		   "argument signature is not well-formed");
d1621 1
a1621 1
			  "argument signature is not type-explicit");
d1626 1
a1626 1
			  "argument signature does not respect equality");
d1660 1
a1660 1
			       "constraining signature is not well-formed");
d1665 1
a1665 1
				      "constraining signature is not type-explicit");
d1670 1
a1670 1
				      "constraining signature does not respect equality");
d1716 1
a1716 1
		implode ["functor body ", IdentPrint.printFunId funid,
d1761 1
a1761 1
	      "free imperative type variables at top level");
@


1.78
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d517 1
a517 1
			    implode ["unbound structure identifier ",
d569 1
a569 1
                           "unbound functor identifier " ^ IdentPrint.printFunId funid);
d756 1
a756 1
                            "unbound signature identifier "^ IdentPrint.printSigId sigid);
d1161 1
a1161 1
                 "unbound structure identifier " ^ 
d1192 1
a1192 1
                            "unbound signature identifier " ^
@


1.77
log
@Merging in bug fixes
@
text
@d4 3
d1074 2
a1075 1
					     ref empty_valenv)),
d1268 2
a1269 1
			  ref empty_valenv))
@


1.76
log
@Instances in schemes for polymorphic debugger.
@
text
@d4 12
d821 1
d843 37
@


1.75
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.
@
text
@d4 5
d342 1
d365 1
a365 1
      METATYVAR (ref (Basis.level acontext,NULLTYPE), eq, imp)
d436 3
a438 1
                                 compiler_options = Options.COMPILEROPTIONS{debug_variables,...},
d442 18
d781 1
a781 1
                   (#1(Types.argres (Scheme.instantiate (1,s)))) ^
d1013 1
a1013 1
                                         if debug_variables then 
d1120 1
d1183 5
a1187 1
                           atype)
d1207 1
a1207 1
                                         if debug_variables then 
d1279 1
a1279 1
            Scheme.make_scheme (tyvartypes,tycon_type)
d1293 1
a1293 1
	     (tyvartypes,FUNTYPE (atype,tycon_type))
d1308 2
a1309 1
          Valenv.add_to_ve (excon,Scheme.make_scheme ([],Types.exn_type),ve)
d1324 2
a1325 1
                                Scheme.make_scheme([],FUNTYPE (atype,Types.exn_type)),
@


1.75.1.1
log
@Fork for bug fixing
@
text
@a3 5
Revision 1.75  1993/07/30  11:19:12  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.

@


1.75.1.2
log
@Modified equality_principal to recalculate equality attributes of all
flexible type constructors in the nameset which have non-empty
constructor environments
See the defn page 36 for what's supposed to happen
@
text
@a3 3
Revision 1.75.1.1  1993/07/30  11:19:12  jont
Fork for bug fixing

a787 1
(*
a808 37
             | equality_principal _ = mycrash "equality_principal"
*)

	   fun max_eq_pred (_, TYSTR (atyfun,VE (_,amap))) =
	     if (Types.equalityp atyfun) andalso not (NewMap.forall eq_scheme amap)
	       then Types.make_false atyfun
	     else
	       true

           fun se_equality_principal (_,STR (_,_,env)) =
             env_equality_principal env
             | se_equality_principal _ = mycrash "se_equality_principal"

           and env_equality_principal (ENV (SE amap,TE amap',_)) = 
             NewMap.forall max_eq_pred amap' andalso
	     NewMap.forall se_equality_principal amap
             
           fun equality_principal (sigma as BasisTypes.SIGMA (names,STR(_,_,env))) =
	     let
	       val tynames = Nameset.tynames_of_nameset names
	       val _ = Lists.iterate
		 (fn tyname =>
		  let
		    val tyfun = ETA_TYFUN tyname
		  in
		    if Types.null_tyfunp tyfun andalso
		      not(Valenv.empty_valenvp
			  (#1(Assemblies.lookupTyfun(tyfun, !sigty_ass))))
		      then
			Types.make_true tyname else ()
		  end)
		 tynames
	     in
	       while not (env_equality_principal env) do ();
	       sigma
	     end

@


1.74
log
@Merged in changes from 1.72.1.1
@
text
@d4 2
d7 1
d362 1
a362 1
      let val str = STR (STRNAME (Strname_id.make_strname_id ()), ref ABSENT, Env.empty_env)
d374 2
a375 2
    fun set_intref (Absyn.OLDsigexp (_,intref,_),str) = intref := Absyn.PRESENT str
      | set_intref (Absyn.NEWsigexp(_,intref),str) = intref := Absyn.PRESENT str
d430 2
a431 1
				 compat_options=Options.COMPATOPTIONS{nj_signatures,...},
d442 1
a442 1
	val check_dec = Core_rules.check_dec (error_info,options) 
d453 1
a453 1
	    val str = STR (strname,ref ABSENT,env)
d458 1
a458 1
	  in
d468 1
a468 1
	     in
d542 1
a542 1
	  check_dec (dec,Basis.basis_to_context basis)
d555 2
a556 1
	    let val new_env = check_strdec (strdec1,basis)
d586 1
a586 1
	  | check_strbinds ((strid,Absyn.ABSENT,strexp,coerce_ref,_)::strbinds,
d600 1
a600 1
	  | check_strbinds ((strid,Absyn.PRESENT sigexp,strexp,coerce_ref,location)::
d675 1
a675 1
          val str = STR(m,ref ABSENT,env)
d756 1
a756 1
                   " does not admit equality: constructor is " ^
d870 1
a870 1
         Timer.xtime ("wellformedness checks", !print_times,
d887 1
a887 1
         (sigma,exp_sigma)
d902 1
a902 1
	 let
d986 5
a990 1
						  (Tyfun_id.make_tyfun_id())),
d1083 1
a1083 1
	   (* Fix here for NJ weird open *)
d1112 1
a1112 1
         in
d1137 1
a1137 1
         in
d1155 2
a1156 1
            val ascheme = Scheme.make_scheme ([],atype)
d1170 2
a1171 1
       let fun do_one (te,(tyvarlist,tycon)) =
d1175 5
a1179 1
	     (METATYNAME (ref (NULL_TYFUN(Tyfun_id.make_tyfun_id())),
d1187 1
d1202 3
a1204 2
	 let fun collect ([],amap) = amap
	       | collect (h::t,amap) =
d1218 1
a1218 1
	   check_datdesc (datdescs,new_context,
d1243 1
a1243 1
      | check_condesc ((valid,Absyn.ABSENT)::condescs,
d1256 1
a1256 1
      | check_condesc ((valid,Absyn.PRESENT aty)::condescs,
d1266 1
a1266 1
	   check_condesc (condescs,tycon,tyfun,tycon_type,tyvartypes,
d1276 1
a1276 1
        fun do_one (ve, (excon,Absyn.ABSENT,location)) =
d1278 1
a1278 1
          | do_one (ve, (excon,Absyn.PRESENT aty,location)) =
d1304 2
a1305 1
        let fun do_one (se,(strid,sigexp)) =
d1440 1
a1440 1
			 ((funid,strid,sigexp,strexp,Absyn.ABSENT,_,
d1480 1
a1480 1
	    let
d1491 1
a1491 1
						 funenv, ass))
d1495 1
a1495 1
					 Absyn.PRESENT sigexp',_,
d1601 3
a1603 2
		Funenv.add_to_funenv (funid,BasisTypes.PHI (names,(str,
								   BasisTypes.SIGMA(names',comp_str''))),
d1643 1
a1643 1
	  if (Env.no_imptyvars new_env) (* get something expanded from check_strdec? *)
d1670 1
a1670 1
	    sigstr_ass := Assemblies.empty_strassembly();
d1679 1
a1679 1
	    Basis.sigenv_in_basis new_sigenv
a1694 1
      val result = check_topdec (topdec,basis)
d1700 2
a1701 2
*)
	result
@


1.73
log
@Removed exception environments.
Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.
@
text
@d4 10
d430 4
d605 1
d609 21
a629 16
		(check_sigexp_closed (sigexp,basis,location))
		handle WellFormed sigma => 
		  (report_error
		   (Info.RECOVERABLE, location,
		    "constraining signature is not well-formed");
		   (sigma,sigma))
		     | TypeExplicit sigma =>
			 (report_error
			  (Info.RECOVERABLE, location,
			   "constraining signature is not type-explicit");
			  (sigma,sigma))
		     | RespectEquality sigma =>
			 (report_error
			  (Info.RECOVERABLE, location,
			   "constraining signature does not respect equality");
			  (sigma,sigma))
d1517 4
d1522 1
d1524 6
d1548 7
a1555 2
	    val _ = sigstr_ass := empty_str_ass
	    val _ = sigty_ass := empty_ty_ass
a1556 3
	    (* Check result structure *)
	    val (str',exp_str') = Timer.xtime("check_strexp", !print_times,
					      fn () => check_strexp(strexp,new_basis))
@


1.72
log
@Various improvements, particularly to do with signatures embedded in structures
@
text
@d4 3
d349 1
a349 1
      let val str = STR (STRNAME (Strname_id.make_strname_id ()),ref ABSENT,Env.empty_env)
d404 1
a404 1
	val ENV (sE,tE,vE,eE) = Basis.env_of_context (Basis.basis_to_context basis)
d411 1
a411 1
	    tE,vE,eE)
d436 1
a436 1
	    val exp_str as STR(_,_,ENV (se,te,_,_)) =
d449 1
a449 1
	       val exp_str as STR(m,_,ENV(se,te,_,_)) = Env.expand_str str (* nice if basis expanded  *)
d461 1
a461 1
	  | check_strexp (Absyn.APPstrexp (funid,strexp,location),basis) =
d484 1
a484 1
	       val realise =
d495 2
a496 5
		 let
		   val STR (m,_,ENV (se,te,_,_)) = exp_newstr' (* add result structure to assemblies *)
		 in
		   (newstr',exp_newstr')
		 end
d567 3
a569 2
	  | check_strbinds ((strid,Absyn.ABSENT,strexp,_)::strbinds,
			    basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_,_)),do_abstraction) = 
d573 4
a576 2
	      (* we always generate new names for structures so dont need to extend the basis nameset *)
	      val se' = check_strbinds (strbinds,basis,do_abstraction)
d581 4
a584 2
	  | check_strbinds ((strid,Absyn.PRESENT sigexp,strexp,location)::strbinds,
			    basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_,_)),do_abstraction) = 
d589 2
a590 2
	      (* I'll defer that bit for the moment *)
	      val (str_ass, ty_ass) = Assemblies.new_assemblies_from_basis_inc_sig basis
d615 2
a616 1
	      val se' = check_strbinds (strbinds,basis (* new_basis *),do_abstraction)
d618 5
d624 9
a632 13
	      if (sigmatch (location,completion_env,Basis.level (Basis.basis_to_context basis),
			    exp_sigma',exp_str))
		then
		  (
		  if do_abstraction then
		    let
		      val BasisTypes.SIGMA(_,abs_str) = Sigma.abstract_sigma sigma
		    in
		      Strenv.add_to_se (strid,abs_str(* str'*),se')
		    end
		  else
		    Strenv.add_to_se (strid,str',se')
		    )
d636 2
a637 1
		  implode ["structure ",IdentPrint.printStrId strid, " does not match signature"]);
d651 1
a651 1
          val exp_str as STR(_,_,ENV (se,te,_,_)) = Env.expand_str str
d749 1
a749 1
                                                 te as TE amap',_,_)) =
d772 1
a772 1
           and env_equality_principal (ENV (SE amap,te,_,_)) = 
d784 1
a784 1
               fun check_env (ENV (SE amap,_,_,_)) =
d824 1
a824 1
           and env_type_explicit (names,ENV (SE amap,TE amap',_,_),
d951 1
a951 1
		    basis as BasisTypes.BASIS (_,_,_,ENV (_,te,_,_))) =
d1002 1
a1002 1
	   val new_env = Env.VE_EE_in_env(ve, ve)
d1403 1
a1403 1
			   location):: funbinds),
a1433 1
					  empty_valenv,
d1458 1
a1458 1
					 location) :: funbinds),
a1493 1
						     empty_valenv,
d1528 2
a1529 2
	  in
	    if Timer.xtime("sigmatch",
d1532 6
a1537 2
			   (sigmatch (location,completion_env,Basis.level (Basis.basis_to_context basis),
				      BasisTypes.SIGMA(names'',exp_str''),exp_str'))) then
d1548 1
@


1.72.1.1
log
@Fixed problem whereby erroneous signatures were being realised and
causing compiler faults
@
text
@a3 3
Revision 1.72  1993/06/25  19:28:51  jont
Various improvements, particularly to do with signatures embedded in structures

a416 4
	fun error_wrap error_info =
	  Info.wrap error_info
	  (Info.FATAL, Info.RECOVERABLE, Info.ADVICE,
	   Info.Location.UNKNOWN)
d584 1
a585 1
	      (* Here we want to stop after signature elaboration on any error *)
a587 3
(*
	      val _ = output(std_out, "Check_sigexp_closed...\n")
*)
a588 29
		(
		error_wrap
		error_info
		(fn options =>
		 fn (sigexp,basis,location) =>
		 (check_sigexp_closed (sigexp,basis,location))
		 handle WellFormed sigma => 
		   (report_error
		    (Info.RECOVERABLE, location,
		     "constraining signature is not well-formed");
		    (sigma,sigma))
		      | TypeExplicit sigma =>
			  (report_error
			   (Info.RECOVERABLE, location,
			    "constraining signature is not type-explicit");
			   (sigma,sigma))
		      | RespectEquality sigma =>
			  (report_error
			   (Info.RECOVERABLE, location,
			    "constraining signature does not respect equality");
			   (sigma,sigma)))
		(sigexp,basis,location)
		) (*handle exn => (output(std_out, "Failed in the wrapper\n");
				 raise exn)*)
(*
	      val _ = output(std_out, "Done\n")
*)
(*
	      val (sigma,_) =
a604 1
*)
a1490 4
	    (* Check result structure *)
	    val (str',exp_str') = Timer.xtime("check_strexp", !print_times,
					      fn () => check_strexp(strexp,new_basis))

a1491 1
	    (* This fails, don't try sigmatch *)
a1492 6
	      error_wrap
	      error_info
	      (fn options =>
	       fn (sigexp,basis,location) =>
	       let
		 val ans =
a1510 7
		 val _ = sigstr_ass := empty_str_ass
		 val _ = sigty_ass := empty_ty_ass
	       in
		 ans
	       end
	      )
	      (sigexp,basis,location)
d1512 2
d1515 3
@


1.71
log
@Changed type of check_topdec to take assemblies, thus making it functional
Removed all use of per functor application refs
Avoided calculating assemblies during/for structure elaboration
@
text
@d4 5
d564 1
a564 1
	and check_strbinds ([],basis,do_abstraction) = 
d582 6
d685 1
a685 1
         let 
d778 1
a778 1
               and check_one (strid,STR(m,_,env)) = 
a789 1

d1421 8
a1428 6
	      Basis.basis_plus_env (basis,
				    ENV (Strenv.add_to_se 
					 (strid,exp_str,Strenv.empty_strenv),
					 Tyenv.empty_tyenv,
					 empty_valenv,
					 empty_valenv))
@


1.70
log
@Fixed functor topdecs so that they know about the existing structure assemblies
@
text
@d4 3
d317 4
a356 2
    val str_ass = ref (Assemblies.empty_strassembly ())
    val ty_ass = ref Assemblies.empty_tyassembly
d367 2
a368 2
    val sigstr_ass = ref(Assemblies.empty_strassembly())
    val sigty_ass = ref Assemblies.empty_tyassembly
a369 26
    (* Indicates whether any tycon or strid was shadowed during signature *)
    (* elaboration. *)
    val shadowing_occurred = ref false

    fun reset_assemblies () =
      let
	val _ = shadowing_occurred := false
	val _ = str_ass := Assemblies.empty_strassembly ()
	val _ = ty_ass := Assemblies.empty_tyassembly
	val _ = sigstr_ass := Assemblies.empty_strassembly ()
	val _ = sigty_ass := Assemblies.empty_tyassembly
      in
	()
      end

    fun set_assemblies (str_assembly,ty_assembly) =
      let
	val _ = shadowing_occurred := false
	val _ = str_ass := Assemblies.unionStrAssembly (!str_ass,str_assembly)
	val _ = ty_ass := Assemblies.unionTypeAssembly (!ty_ass,ty_assembly)
	val _ = sigstr_ass := Assemblies.empty_strassembly ()
	val _ = sigty_ass := Assemblies.empty_tyassembly
      in
	()
      end

d410 1
a410 1
				 ...}, topdec, basis) =
d412 2
a431 6
(*
          val type_offspring =
            Assemblies.collectTypeOffspring (te,Assemblies.empty_type_offspring)
          val str_offspring = 
            Assemblies.collectStrOffspring (se,Assemblies.empty_str_offspring)
*)
d433 1
a433 4

          ((*str_ass := Assemblies.add_to_StrAssembly (strname,str_offspring,type_offspring,!str_ass);
*)
	  (str,exp_str))
a441 5
	     (*
            val str_offs = Assemblies.collectStrOffspring (se,Assemblies.empty_str_offspring)
            val ty_offs = Assemblies.collectTypeOffspring (te,Assemblies.empty_type_offspring)
            val ty_ass' = Assemblies.updateTypeAssembly (te,!ty_ass)
*)
d443 1
a443 4
	       ((*str_ass := Assemblies.add_to_StrAssembly 
		 (m,str_offs,ty_offs,!str_ass);
		 ty_ass := ty_ass';*)
		(str,exp_str))
a456 9
             (* there shouldn't be any point in adding parameter to assemblies *)
             (*
             val (str_ass',ty_ass') =
               Timer.xtime ("subAssemblies 55",
                            !print_times,
                            fn () => Assemblies.subAssemblies (!str_ass,!ty_ass,exp_str))
             val _ = str_ass := str_ass'
             val _ = ty_ass := ty_ass'
               *)
a488 7
(*
		 val str_offs = Assemblies.collectStrOffspring
		   (se,Assemblies.empty_str_offspring)
		 val ty_offs = Assemblies.collectTypeOffspring 
		   (te,Assemblies.empty_type_offspring)
		 val ty_ass' = Assemblies.updateTypeAssembly (te,!ty_ass)
*)
d490 1
a490 4
		   ((*str_ass := Assemblies.add_to_StrAssembly 
		     (m,str_offs,ty_offs,!str_ass);
		     ty_ass := ty_ass';*)
		    (newstr',exp_newstr'))
a569 11
(*
            (* check for shadowing *)
            let
              val str' = Strenv.lookup (strid,se)
              val (str_ass',ty_ass') = 
                Assemblies.subAssemblies (!str_ass,!ty_ass,str')
            in
              (str_ass := str_ass';
               ty_ass := ty_ass')
            end handle Strenv.Lookup_in_SE => ();
*)
a605 20
(*
	       (* First get rid of shadowed out stuff *)
	       let
		 val str' = Strenv.lookup (strid,se)
		 val (str_ass',ty_ass') =
		   Assemblies.subAssemblies (!str_ass,!ty_ass,str')
	       in
                 (str_ass := str_ass';
                  ty_ass := ty_ass')
	       end handle Strenv.Lookup_in_SE => ();
	       (* Now handle contraction caused by signature constraint *)
	       let
		 val (str_ass', ty_ass') =
		   Assemblies.subAssemblies(!str_ass, !ty_ass, exp_str)
		 val (str_ass'', ty_ass'') = Assemblies.newAssemblies(m', env')
	       in
		 str_ass := Assemblies.unionStrAssembly(str_ass', str_ass'');
		 ty_ass := Assemblies.unionTypeAssembly(ty_ass', ty_ass'')
	       end;
*)
d855 1
a855 1
    and check_sigbind (Absyn.SIGBIND [],basis,sigenv) = sigenv
d858 4
a861 2
                       sigenv) =
	 let 
d884 4
a887 17
(*
	   if !shadowing_occurred
	     then
	       let
                 val STR(m,_,env) = exp_str
		 val (sigstr_ass',sigty_ass') = Assemblies.newAssemblies (m,env)
	       in
		 str_ass := 
		 Assemblies.unionStrAssembly (!str_ass,sigstr_ass');
                 ty_ass := Assemblies.unionTypeAssembly (!ty_ass,sigty_ass')
	       end
	   else (ty_ass := !sigty_ass;
		 str_ass := !sigstr_ass);
*)
           Sigenv.add_to_sigenv (sigid,BasisTypes.SIGMA(names,str),
                                 check_sigbind (Absyn.SIGBIND sigbinds,
                                                basis,sigenv)) handle Bind => mycrash "457"
d937 13
a949 18
	       (if Tyenv.member_of_te_domain (te, tycon)
		  then
		    shadowing_occurred := true
		else ();
		  
	        make_dummy_te (datadescs,
			       Tyenv.add_to_te
			       (te,tycon,
				TYSTR 
				(Types.make_eta_tyfun 
				 (METATYNAME (ref (NULL_TYFUN
						   (Tyfun_id.make_tyfun_id())),
					      IdentPrint.printTyCon
					      tycon,
					      Lists.length tyvars,
					      ref true,
					      ref empty_valenv)),
				 empty_valenv))))
a1131 5
	   if Tyenv.member_of_te_domain (Basis.te_of_context context, tycon)
	     then
	       shadowing_occurred := true
	   else
	     ();
a1252 3
            if Strenv.member_of_se_domain (strid,se) then
              shadowing_occurred := true
            else ();
d1381 1
a1381 1
      fun check_funbind (Absyn.FUNBIND [],basis,funenv) = funenv
d1386 2
a1387 1
			 basis as BasisTypes.BASIS (nameset,_,_,_),funenv) = 
d1389 2
d1408 2
a1421 9
	      
	  (****
	   Remove what has been added during elaboration of the functor 
	   body to the Assemblies.
	   ****)
(*
	   val (str_ass',ty_ass') = 
	     Assemblies.subAssemblies (!str_ass, !ty_ass, exp_str')
*)
a1422 4
(*
	   str_ass := str_ass';
	   ty_ass := ty_ass';
*)
d1434 1
a1434 1
						 funenv))
d1440 2
a1441 1
			 basis as BasisTypes.BASIS (nameset,_,_,_),funenv) = 
d1443 2
d1478 2
a1479 2
	    val (str',exp_str') = Timer.xtime("check_strexp", !print_times,
					      fn () => check_strexp(strexp,new_basis))
d1500 6
a1508 1
	    (* val (str_ass',ty_ass') = Assemblies.subAssemblies(!str_ass, !ty_ass, exp_str') *)
a1525 4
(*
		 str_ass := str_ass';
		 ty_ass := ty_ass';
*)
d1530 1
a1530 1
						     basis,funenv))
d1540 1
a1540 1
      fun check_sigdec ([],basis, sigenv) = sigenv
d1542 1
a1542 1
	| check_sigdec (sigbind::sigbindlist, basis, sigenv) =
d1544 1
a1544 1
	    val new_sigenv = check_sigbind (sigbind,basis,sigenv)
d1548 1
a1548 1
			 Sigenv.sigenv_plus_sigenv (new_sigenv, sigenv))
d1551 2
a1552 2
      fun check_fundec ([],basis, funenv) = funenv
	| check_fundec (funbind::funbindlist, basis, funenv) = 
d1554 1
a1554 1
	    val new_funenv = check_funbind (funbind,basis,funenv)
d1558 1
a1558 1
			  Funenv.funenv_plus_funenv (new_funenv, funenv))
a1566 4
	  val (str_ass', ty_ass') =
	    Assemblies.compose_assemblies(Assemblies.new_assemblies_from_basis basis_inc,
					  (!str_ass, !ty_ass),
					  basis_inc, basis)
a1567 2
	  str_ass := str_ass';
	  ty_ass := ty_ass';
d1570 1
a1570 1
	      Basis.basis_plus_names (basis_inc, Sigma.names_of_env new_env)
d1588 3
a1590 2
	    val _ = (sigstr_ass := !str_ass;
		     sigty_ass := !ty_ass)
d1593 1
a1593 1
	      check_sigdec (sigbindlist,basis, Sigenv.empty_sigenv)
d1611 4
a1614 3
	    val _ = (sigstr_ass := !str_ass;
		     sigty_ass := !ty_ass)
	    val new_funenv = check_fundec (funbindlist,basis, Funenv.empty_funenv)
a1615 4
	    sigstr_ass := Assemblies.empty_strassembly ();
	    sigty_ass := Assemblies.empty_tyassembly;
	    (* Avoid hanging on to large unnecessary data structures *)

a1629 1

@


1.69
log
@Cleaned up after assembly changes
@
text
@d4 3
d1716 2
a1717 5
	    (*
	     str_ass := Assemblies.empty_strassembly ();
	     ty_ass := Assemblies.empty_tyassembly;
	     *)
	   
d1730 2
d1736 2
a1737 4
(*
 str_ass := Assemblies.empty_strassembly ();
          ty_ass := Assemblies.empty_tyassembly;
*)
@


1.68
log
@Revised way of using assemblies such that structure assemblies are constructed
from the incremental basis rather than on the fly. Fixes a number of
problems with incorrect shadowing
@
text
@d4 5
d279 1
a279 1
  sharing Core_rules.Assemblies.Basistypes = Realise.BasisTypes =
d281 1
a281 1
    Basis.BasisTypes = Tyvarenv.BasisTypes
d293 1
a293 1
  sharing Share.Assemblies = Sharetypes.Assemblies = Core_rules.Assemblies
d303 1
a303 1
    structure Assemblies = Core_rules.Assemblies
d348 1
a348 1
    val ty_ass = Core_rules.ty_ass
d354 4
a1673 20
      fun make_new_assemblies(BasisTypes.BASIS(_, _, _, env as ENV(SE se, TE te, _, _))) =
	let
	  fun new_str((str_ass, ty_ass), _, str) =
	    let
	      val (m, env) = case Env.expand_str str of
		STR(m, _, env) => (m, env)
	      | _ => Crash.impossible"Expanded str is not STR"
	      val (str_ass', ty_ass') = Assemblies.newAssemblies(m, env)
	    in
	      (Assemblies.unionStrAssembly(str_ass, str_ass'),
	       Assemblies.unionTypeAssembly(ty_ass, ty_ass'))
	    end
	in
	  NewMap.fold
	  new_str
	  ((Assemblies.empty_strassembly(),
	    Assemblies.newTypeAssembly(env, Assemblies.empty_tyassembly)),
	   se)
	end

d1679 1
a1679 1
	    Assemblies.compose_assemblies(make_new_assemblies basis_inc,
@


1.67
log
@Changes because Assemblies now has Basistypes instead of Datatypes
@
text
@d347 1
a347 1
    (* with the above. After elaborating each topdec str_ass amd ty_ass *)
d349 1
a382 20
    (* This is used by check_str_share, structures should be expanded *)
    (* This is wrong, need to look at assemblies *)
    (*
    local
      fun proper_substr (str as STR (name,_,_),SE amap) =
	if NewMap.is_empty amap
	  then false
	else
	  NewMap.forall 
          (fn (_, STR (m,_,ENV (se',_,_,_))) => 
           m = name orelse proper_substr (str,se')
            | _ => mycrash "proper_substr2")
          amap
        | proper_substr _ = mycrash "proper_substr"
    in
      fun substr (str as STR (name,_,_),STR (name',_,ENV (se',_,_,_))) =
        proper_substr (str,se')
      | substr _ = mycrash "substr"
    end
*)
d387 2
a388 1
          let val os_map = Assemblies.StrOffspring_to_map stroffspring
d403 11
a413 11
  fun make_completion_env (basis,sigstr,strstr) =
    let
      val ENV (sE,tE,vE,eE) = Basis.env_of_context (Basis.basis_to_context basis)
    in
      ENV(Strenv.add_to_se(Ident.STRID (Symbol.find_symbol "_sig"),
                           sigstr,
                           Strenv.add_to_se(Ident.STRID(Symbol.find_symbol "_str"),
                                            strstr,
                                            sE)),
          tE,vE,eE)
    end
d415 10
a424 10
  fun check_topdec error_info(options as
			      Options.OPTIONS
			      {print_options,
			       compat_options=Options.COMPATOPTIONS{nj_signatures,...},
			       ...}, topdec, basis) =
    let
      val report_error = Info.error error_info
      val check_type = Core_rules.check_type error_info
      val check_dec = Core_rules.check_dec (error_info,options) 
      val sigmatch = Realise.sigmatch (error_info,options)
d426 1
a426 1
      fun compress_str str = (* Env.compress_str *) str
d428 1
a428 1
      (* *** rule 53 *** *)
d430 10
a439 9
      fun check_strexp (Absyn.NEWstrexp strdec,basis) = 
        let 
          val strname = STRNAME (Strname_id.make_strname_id ())
          val env = check_strdec (strdec,basis)
          val str = STR (strname,ref ABSENT,env)
          val exp_str as STR(_,_,ENV (se,te,_,_)) =
            Timer.xtime ("expanding structure structure",
                         !print_times,
                         fn () => Env.expand_str str) (* expanded structure needed *)
d444 7
a450 4
        in
          (str_ass := Assemblies.add_to_StrAssembly (strname,str_offspring,type_offspring,!str_ass);
           (str,exp_str))
        end
d452 1
a452 1
        (* *** rule 54 *** *)
d454 5
a458 4
        | check_strexp (Absyn.OLDstrexp (longstrid,location),basis) =
          (let 
            val str = Basis.lookup_longstrid (longstrid,basis)
            val exp_str as STR(m,_,ENV(se,te,_,_)) = Env.expand_str str (* nice if basis expanded  *)
d462 14
a475 11
          in
            (str_ass := Assemblies.add_to_StrAssembly 
             (m,str_offs,ty_offs,!str_ass);
             ty_ass := ty_ass';
             (str,exp_str))
          end
          handle Basis.LookupLongStrId =>
            (report_error (Info.RECOVERABLE, location,
                           implode ["unbound structure identifier ",
                                    IdentPrint.printLongStrId longstrid]);
             make_dummy_structures()))
d477 4
a480 6
        (* *** rule 55 *** *)
          
        | check_strexp (Absyn.APPstrexp (funid,strexp,location),basis) =
          (let 
             val (str,exp_str) =
               Timer.xtime ("check_strexp 55", !print_times,fn () => check_strexp (strexp,basis))
d490 2
a491 2
             val phi as BasisTypes.PHI (names,(str'',BasisTypes.SIGMA (names',str'))) = 
               Basis.lookup_funid (funid,basis)
d504 38
a541 37
             val BasisTypes.PHI (newnames,(newstr'',BasisTypes.SIGMA (newnames',newstr'))) = Phi.phi_copy phi
             val exp_newstr' = Env.expand_str newstr' (* necessary *)
             val exp_newstr'' = Env.expand_str newstr'' (* necessary *)
             val sigma = BasisTypes.SIGMA (newnames,exp_newstr'')
             val completion_env = make_completion_env(basis,exp_newstr'',exp_str)
             val realise =
               Timer.xtime
               ("sigmatch 55", !print_times,
                fn () =>
                (sigmatch (location,
                           completion_env,
                           Basis.level(Basis.basis_to_context basis),
                           sigma,
                           exp_str)))
           in
             if realise
               then
                 let
                   val STR (m,_,ENV (se,te,_,_)) = exp_newstr' (* add result structure to assemblies *)
                   val str_offs = Assemblies.collectStrOffspring
                     (se,Assemblies.empty_str_offspring)
                   val ty_offs = Assemblies.collectTypeOffspring 
                     (te,Assemblies.empty_type_offspring)
                   val ty_ass' = Assemblies.updateTypeAssembly (te,!ty_ass)
                 in
                   (str_ass := Assemblies.add_to_StrAssembly 
                    (m,str_offs,ty_offs,!str_ass);
                    ty_ass := ty_ass';
                    (newstr',exp_newstr'))
                 end
             else 
               (report_error
                (Info.RECOVERABLE, location,
                 implode ["argument signature of ", IdentPrint.printFunId funid,
                          " does not match the actual argument"]);
                make_dummy_structures())
           end
d548 1
a548 1
        (* *** rule 56 *** *)
d550 6
a555 5
        | check_strexp (Absyn.LOCALstrexp (strdec,strexp),basis) =
          let val new_env = check_strdec (strdec,basis)
          in
            check_strexp (strexp,Basis.basis_plus_env (basis,new_env))
          end
d557 1
a557 1
      (* ****** Structure-level Declarations ****** *)
d559 1
a559 1
      (* *** rule 57 *** *)
d561 2
a562 2
      and check_strdec (Absyn.DECstrdec dec,basis) = 
        check_dec (dec,Basis.basis_to_context basis)
d564 3
a566 3
        (* *** rule 58 *** *)
        | check_strdec (Absyn.STRUCTUREstrdec strbindlist,basis) = 
          Env.SE_in_env (check_strbinds (strbindlist, basis,false))
d568 3
a570 3
        (* *** Abstractions *** *)
        | check_strdec (Absyn.ABSTRACTIONstrdec strbindlist,basis) = 
          Env.SE_in_env (check_strbinds (strbindlist, basis,true))
d572 1
a572 1
        (* *** rule 59 *** *)
d574 5
a578 5
        | check_strdec (Absyn.LOCALstrdec (strdec1,strdec2),basis) = 
          let val new_env = check_strdec (strdec1,basis)
          in
            check_strdec (strdec2, Basis.basis_plus_env (basis,new_env))
          end
d580 1
a580 1
        (* *** rules 60 and 61 *** *)
d582 14
a595 14
        | check_strdec (Absyn.SEQUENCEstrdec strdeclist,basis) = 
          let
            fun check_one ((basis,env),strdec) =
              let
		val env' = check_strdec(strdec, basis)
                val new_env = Env.env_plus_env(env, env')
                val new_basis = Basis.basis_plus_env(basis, env')
              in
                (new_basis, new_env)
              end
            val (_,env) = Lists.reducel check_one ((basis,Env.empty_env),strdeclist)
          in
            env
          end
d597 1
a597 1
      (* *** Structure Bindings *** *)
d599 1
a599 1
      (* *** rule 62 *** *)
d601 3
a603 3
      (* This function should be made tail recursive with reducel *)
      and check_strbinds ([],basis,do_abstraction) = 
        Strenv.empty_strenv
d605 4
a608 4
        | check_strbinds ((strid,Absyn.ABSENT,strexp,_)::strbinds,
                          basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_,_)),do_abstraction) = 
          let 
            val (str,STR(m,_,env)) = check_strexp (strexp,basis)
d610 4
a613 3
            (* we always generate new names for structures so dont need to extend the basis nameset *)
            val se' = check_strbinds (strbinds,basis,do_abstraction)
          in
d623 1
d625 1
a625 1
          end
d627 21
a647 21
      | check_strbinds ((strid,Absyn.PRESENT sigexp,strexp,location)::strbinds,
			basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_,_)),do_abstraction) = 
        let
          val (str,exp_str as STR(m,_,env)) = check_strexp (strexp,basis)
          val (sigma,_) =
            (check_sigexp_closed (sigexp,basis,location))
            handle WellFormed sigma => 
              (report_error
               (Info.RECOVERABLE, location,
                "constraining signature is not well-formed");
               (sigma,sigma))
                 | TypeExplicit sigma =>
                     (report_error
                      (Info.RECOVERABLE, location,
                       "constraining signature is not type-explicit");
                      (sigma,sigma))
                 | RespectEquality sigma =>
                     (report_error
                      (Info.RECOVERABLE, location,
                       "constraining signature does not respect equality");
                      (sigma,sigma))
d649 12
a660 11
          val sigma' as BasisTypes.SIGMA (names',str') = Sigma.sig_copy sigma
          val exp_str' as STR(m', _, env') = Env.expand_str str'
          val exp_sigma' = BasisTypes.SIGMA(names',exp_str')
          (* This recursion is in the wrong place *)
          val se' = check_strbinds (strbinds,basis (* new_basis *),do_abstraction)
          val completion_env = make_completion_env (basis,exp_str',exp_str)
        in
          if (sigmatch (location,completion_env,Basis.level (Basis.basis_to_context basis),
                        exp_sigma',exp_str))
            then
              (
d679 16
a694 15
	       if do_abstraction then
		 let
		   val BasisTypes.SIGMA(_,abs_str) = Sigma.abstract_sigma sigma
		 in
		   Strenv.add_to_se (strid,abs_str(* str'*),se')
		 end
	       else
		 Strenv.add_to_se (strid,str',se')
		 )
          else
            (report_error
             (Info.RECOVERABLE, location,
              implode ["structure ",IdentPrint.printStrId strid, " does not match signature"]);
             Strenv.empty_strenv)
        end
d696 1
a696 1
    (* *** Signature Expressions *** *)
d698 1
a698 1
    (* *** rule 63 *** *)
a750 3
(*
	   val _ = Nameset.nameset_rehash basis_names
*)
a759 36
(* Lots of test code here *)
(*
           fun diff_nameset (s,s') =
             let
               fun diff ([],_,_,aux) = aux
                 | diff (a::b,l,eq,aux) =
                   let fun member (a,[]) = false
                     | member (a,b::c) =
                       if eq (a,b) then true
                       else member(a,c)
                   in
                     if member (a,l)
                       then diff (b,l,eq,aux)
                     else diff (b,l,eq,a::aux)
                   end
               val tynames = Nameset.tynames_of_nameset s
               val strnames = Nameset.strnames_of_nameset s
               val tynames' = Nameset.tynames_of_nameset s'
               val strnames' = Nameset.strnames_of_nameset s'
               val new_tynames = diff (tynames,tynames',Types.tyname_eq,[])
               val new_strnames = diff (strnames,strnames',Strnames.strname_eq,[])
             in
               Nameset.nameset_of_name_lists(new_tynames,new_strnames)
             end
*)
(*
	   val _ = Nameset.nameset_rehash nameset

*)
           (* It shouldn't be necessary to rehash the basis names as
              they shouldn't be side effected *)
(*
	   val _ = Nameset.nameset_rehash basis_names
*)


a761 32
(*
	   val other_nameset = Nameset.diff(nameset,basis_names)
	   val _ =
	     if Nameset.nameset_eq(real_nameset, other_nameset) then ()
	     else
	       let
		 val Options.OPTIONS{print_options, ...} = options
		 val string_tyname = Types.debug_print_name
		 val print_tyname =
		   fn tyname => output(std_out, string_tyname tyname ^ "\n")
		 val print_strname =
		   fn strname => output(std_out, Strnames.string_strname strname ^ "\n")
		 val _ = output(std_out, "tynames(nameset) = \n")
		 val _ = Lists.iterate print_tyname (Nameset.tynames_of_nameset nameset)
		 val _ = output(std_out, "strnames(nameset) = \n")
		 val _ = Lists.iterate print_strname (Nameset.strnames_of_nameset nameset)
		 val _ = output(std_out, "tynames(basis_names) = \n")
		 val _ = Lists.iterate print_tyname (Nameset.tynames_of_nameset basis_names)
		 val _ = output(std_out, "strnames(basis_names) = \n")
		 val _ = Lists.iterate print_strname (Nameset.strnames_of_nameset basis_names)
		 val _ = output(std_out, "tynames(real_nameset) = \n")
		 val _ = Lists.iterate print_tyname (Nameset.tynames_of_nameset real_nameset)
		 val _ = output(std_out, "strnames(real_nameset) = \n")
		 val _ = Lists.iterate print_strname (Nameset.strnames_of_nameset real_nameset)
		 val _ = output(std_out, "tynames(other_nameset) = \n")
		 val _ = Lists.iterate print_tyname (Nameset.tynames_of_nameset other_nameset)
		 val _ = output(std_out, "strnames(other_nameset) = \n")
		 val _ = Lists.iterate print_strname (Nameset.strnames_of_nameset other_nameset)
	       in
		 ()
	       end
*)
d956 1
d969 1
a969 1

d1479 1
a1479 1
    and check_funbind (Absyn.FUNBIND [],basis,funenv) = funenv
d1481 39
a1519 39
      | check_funbind (Absyn.FUNBIND 
		       ((funid,strid,sigexp,strexp,Absyn.ABSENT,_,
                         location):: funbinds),
		       basis as BasisTypes.BASIS (nameset,_,_,_),funenv) = 
	 let
	   val (BasisTypes.SIGMA (names,str),BasisTypes.SIGMA (_,exp_str)) = 
             (check_sigexp_closed (sigexp,basis,location))
             handle WellFormed sigma => 
               (report_error
                (Info.RECOVERABLE, location,
                 "argument signature is not well-formed");
                (sigma,sigma))
                  | TypeExplicit sigma =>
                      (report_error
                       (Info.RECOVERABLE, location,
                        "argument signature is not type-explicit");
                       (sigma,sigma))
                  | RespectEquality sigma =>
                      (report_error
                       (Info.RECOVERABLE, location,
                        "argument signature does not respect equality");
                       (sigma,sigma))
           val new_basis =
             Basis.basis_plus_env (basis,
                                   ENV (Strenv.add_to_se 
                                        (strid,exp_str,Strenv.empty_strenv),
                                        Tyenv.empty_tyenv,
                                        empty_valenv,
                                        empty_valenv))
	   val (str',exp_str') = check_strexp (strexp,new_basis)
	   val names' =
	     Nameset.diff (Sigma.names_of exp_str',
			   Nameset.union (nameset,names))
	   val phi = BasisTypes.PHI (names,(str,BasisTypes.SIGMA (names',str')))

	   (****
	    Remove what has been added during elaboration of the functor 
	    body to the Assemblies.
	    ****)
d1524 1
a1524 1
	 in
d1529 13
a1541 13
           let
             val STR (_,_,env') = exp_str'
           in
             if Env.no_imptyvars env'
               then ()
             else
               report_error (Info.RECOVERABLE, location, 
                             "free imperative type variables in functor body")
           end;
	   Funenv.add_to_funenv (funid,BasisTypes.PHI (names,(str,BasisTypes.SIGMA(names',str'))),
				 check_funbind (Absyn.FUNBIND funbinds,basis,
						funenv))
	 end
d1543 59
a1601 25
      | check_funbind (Absyn.FUNBIND ((funid,strid,sigexp,strexp,
				       Absyn.PRESENT sigexp',_,
                                       location) :: funbinds),
		       basis as BasisTypes.BASIS (nameset,_,_,_),funenv) = 
	 let
	   val (sigma as BasisTypes.SIGMA (names,str),BasisTypes.SIGMA (_,exp_str)) =
	     Timer.xtime 
               ("check_sigexp_closed", !print_times,
		 fn () => 
                 (check_sigexp_closed (sigexp,basis,location))
                 handle WellFormed sigma => 
                   (report_error
                    (Info.RECOVERABLE, location,
                     "argument signature is not well-formed");
                    (sigma,sigma))
                      | TypeExplicit sigma =>
                          (report_error
                           (Info.RECOVERABLE, location,
                            "argument signature is not type-explicit");
                           (sigma,sigma))
                      | RespectEquality sigma =>
                          (report_error
                           (Info.RECOVERABLE, location,
                            "argument signature does not respect equality");
                           (sigma,sigma)))
d1603 8
a1610 2
	   val new_basis =
	     Timer.xtime("basis_plus_env", !print_times,
d1612 12
a1623 53
                           Basis.basis_plus_names
                           (Basis.basis_plus_env (basis,
                                                  ENV(Strenv.add_to_se
                                                      (strid,exp_str,
                                                       Strenv.empty_strenv),
                                                      Tyenv.empty_tyenv,
                                                      empty_valenv,
                                                      empty_valenv)),
                           names))
	   val (str',exp_str') = Timer.xtime("check_strexp", !print_times,
				    fn () => check_strexp(strexp,new_basis))
	   val (sigma',_) = 
             Timer.xtime ("check_sigexp_closed", !print_times,
		          fn () =>
                          (check_sigexp_closed (sigexp',new_basis,location))
                          handle WellFormed sigma => 
                            (report_error
                             (Info.RECOVERABLE, location,
                              "constraining signature is not well-formed");
                             (sigma,sigma))
                               | TypeExplicit sigma =>
                                   (report_error
                                    (Info.RECOVERABLE, location,
                                     "constraining signature is not type-explicit");
                                    (sigma,sigma))
                               | RespectEquality sigma =>
                                   (report_error
                                    (Info.RECOVERABLE, location,
                                     "constraining signature does not respect equality");
                                    (sigma,sigma)))

           (* This won't produce an expanded sigma *)
	   val sigma'' as BasisTypes.SIGMA (names'',str'') = Sigma.sig_copy sigma'
           val exp_str'' = Env.expand_str str'' (* necessary *)
	   (* val (str_ass',ty_ass') = Assemblies.subAssemblies(!str_ass, !ty_ass, exp_str') *)
           val completion_env = make_completion_env (new_basis,exp_str'',exp_str')
	 in
	   if Timer.xtime("sigmatch",
                          !print_times,
                          fn () =>
                          (sigmatch (location,completion_env,Basis.level (Basis.basis_to_context basis),
                                     BasisTypes.SIGMA(names'',exp_str''),exp_str')))
             then
	       let
		 val names' = 
		   Nameset.diff (Sigma.names_of exp_str'',
				 Nameset.union (nameset,names))
		 val phi = BasisTypes.PHI(names,(str,BasisTypes.SIGMA (names',str'')))
                 val comp_str'' =
                   Timer.xtime ("Compressing result sig",
                                !print_times,
                                fn () => compress_str str'')
	       in
d1628 13
a1640 13
                 set_intref (sigexp',comp_str'');
                 Funenv.add_to_funenv (funid,BasisTypes.PHI (names,(str,
                                                             BasisTypes.SIGMA(names',comp_str''))),
				       check_funbind (Absyn.FUNBIND funbinds,
						      basis,funenv))
	       end
	   else
             (report_error
              (Info.RECOVERABLE, location,
               implode ["functor body ", IdentPrint.printFunId funid,
                        " does not match result signature"]);
              funenv)
	 end
d1642 1
a1642 1
    fun check_sigdec ([],basis, sigenv) = sigenv
d1644 18
a1661 8
      | check_sigdec (sigbind::sigbindlist, basis, sigenv) =
        let
          val new_sigenv = check_sigbind (sigbind,basis,sigenv)
          val new_basis = Basis.basis_plus_sigenv (basis,new_sigenv)
        in
          check_sigdec(sigbindlist, new_basis,
                       Sigenv.sigenv_plus_sigenv (new_sigenv, sigenv))
        end
d1663 21
a1683 9
    fun check_fundec ([],basis, funenv) = funenv
      | check_fundec (funbind::funbindlist, basis, funenv) = 
        let
          val new_funenv = check_funbind (funbind,basis,funenv)
          val new_basis = Basis.basis_plus_funenv (basis,new_funenv)
        in
          check_fundec (funbindlist,new_basis,
                        Funenv.funenv_plus_funenv (new_funenv, funenv))
        end
d1685 14
a1698 12
    (* *** rule 100 *** *)
  
    fun check_topdec (Absyn.STRDECtopdec (strdec,location),basis as BasisTypes.BASIS (nameset,_,_,_)) = 
      let 
        val new_env = check_strdec (strdec,basis)
      in
        sigstr_ass := !str_ass;
        sigty_ass := !ty_ass;
        if (Env.no_imptyvars new_env) (* get something expanded from check_strdec? *)
          then 
            Basis.basis_plus_names (Basis.env_in_basis new_env,
                                    Sigma.names_of_env new_env)
d1705 6
a1710 6
	 else
           (report_error
            (Info.RECOVERABLE, location,
             "free imperative type variables at top level");
            basis)
       end
d1712 1
a1712 1
      (* *** rule 101 *** *)
d1714 14
a1727 12
      | check_topdec (Absyn.SIGNATUREtopdec sigbindlist,basis) = 
	 let
	   val _ = (sigstr_ass := !str_ass;
		    sigty_ass := !ty_ass)

	   val new_sigenv =
	     check_sigdec (sigbindlist,basis, Sigenv.empty_sigenv)
	 in
	   sigstr_ass := Assemblies.empty_strassembly();
	   sigty_ass := Assemblies.empty_tyassembly;
	   str_ass := Assemblies.empty_strassembly ();
	   ty_ass := Assemblies.empty_tyassembly;
d1729 1
a1729 1
	 (* It is not necessary to check for the presence of free imperative
d1734 2
a1735 2
           Basis.sigenv_in_basis new_sigenv
	 end
d1737 1
a1737 1
      (* *** rule 102 *** *)
d1739 8
a1746 7
      | check_topdec (Absyn.FUNCTORtopdec (funbindlist,location),basis) = 
        let 
          val new_funenv = check_fundec (funbindlist,basis, Funenv.empty_funenv)
        in
          sigstr_ass := Assemblies.empty_strassembly ();
          sigty_ass := Assemblies.empty_tyassembly;
          str_ass := Assemblies.empty_strassembly ();
d1748 7
a1754 5
          Basis.funenv_in_basis new_funenv
        end
      | check_topdec (Absyn.REQUIREtopdec (s, _),basis) = basis
    val result = check_topdec (topdec,basis)
    in
d1760 2
a1761 2
      result
    end
d1763 1
@


1.66
log
@Replaced abstraction variable name with do_abstraction, so NJ can compile it.
@
text
@d4 3
d274 1
a274 1
  sharing Core_rules.BasisTypes = Realise.BasisTypes =
d276 1
a276 1
    Basis.BasisTypes = Share.BasisTypes = Tyvarenv.BasisTypes
d658 1
a658 1
          val exp_str' = Env.expand_str str'
d667 7
a673 5
              (let
                val str' = Strenv.lookup (strid,se)
                val (str_ass',ty_ass') = 
                  Assemblies.subAssemblies (!str_ass,!ty_ass,str')
              in
d676 19
a694 10
              end handle Strenv.Lookup_in_SE => ();
              if do_abstraction
                then
                  let val BasisTypes.SIGMA(_,abs_str) = Sigma.abstract_sigma sigma
                  in
                    Strenv.add_to_se (strid,abs_str(* str'*),se')
                  end
              else
                Strenv.add_to_se (strid,str',se')
                )
@


1.65
log
@Added code for abstractions.
Added newAssemblies for INCLUDEspecs
@
text
@d4 4
d609 1
a609 1
      and check_strbinds ([],basis,abstraction) = 
d613 1
a613 1
                          basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_,_)),abstraction) = 
d618 1
a618 1
            val se' = check_strbinds (strbinds,basis,abstraction)
d633 1
a633 1
			basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_,_)),abstraction) = 
d658 1
a658 1
          val se' = check_strbinds (strbinds,basis (* new_basis *),abstraction)
d672 1
a672 1
              if abstraction
a1796 1
                                                  @


1.64
log
@Avoid updating flexible names in the basis (when doing sharng in functor results)
@
text
@d4 3
d488 1
a488 1
val (str_ass',ty_ass') =
d569 5
a573 1
          Env.SE_in_env (check_strbinds (strbindlist, basis))
d605 1
a605 1
      and check_strbinds ([],basis) = 
d609 1
a609 1
                          basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_,_))) = 
d614 1
a614 1
            val se' = check_strbinds (strbinds,basis)
d629 1
a629 1
			basis as BasisTypes.BASIS (_,_,_,ENV (se,_,_,_))) = 
d654 1
a654 1
          val se' = check_strbinds (strbinds,basis (* new_basis *))
d668 9
a676 9
(*
              let val BasisTypes.SIGMA(_,abs_str) = Sigma.abstract_sigma sigma
              in
                Strenv.add_to_se (strid,abs_str(* str'*),se')
              end
*)
              Strenv.add_to_se (strid,str',se')

            )
d751 1
d776 2
d779 3
a782 1
	   val _ = Nameset.nameset_rehash nameset
d786 1
d788 1
d796 1
a796 1
		 val string_tyname = Types.print_name print_options
d835 1
d845 1
a845 1
                   " does not admit equality: contructor is " ^
d1105 1
d1121 1
d1197 7
a1203 2
	       val STR (_,_,env1) = Env.resolve_top_level (COPYSTR((new_strnames,new_tynames), str))
	     in
d1578 1
d1581 1
d1583 1
d1586 1
@


1.63
log
@uses test implementation of nameset_diff
@
text
@d4 3
d281 2
a282 1
  sharing type Nameset.Nameset = Basis.BasisTypes.Nameset
d730 5
d744 1
a744 2
           val BasisTypes.BASIS(basis_names,_,_,_) = basis

d767 1
d769 4
a772 1
           val real_nameset = diff_nameset(nameset,basis_names) (* Nameset.diff(nameset,basis_names) *)
d774 34
d1463 2
d1468 1
a1468 1
              Sharetypes.share_tyfun (tyfun,tyfun',!sigty_ass)
@


1.62
log
@nj_local_open compatibility option has changed to nj_signatures.
@
text
@d4 3
d268 1
a268 1
    TypeDebugger.Options
d729 1
a729 1
             
d737 22
a758 1
           val nameset = Nameset.diff(nameset,basis_names)
d760 2
d766 2
a767 2
           val sigma = BasisTypes.SIGMA(nameset,comp_str)
           val exp_sigma = BasisTypes.SIGMA(nameset, exp_str)
d769 6
@


1.61
log
@Added (commented out) call to print type bindings of variables
@
text
@d4 3
d419 1
a419 1
			       compat_options=Options.COMPATOPTIONS{nj_local_open,...},
d1090 1
a1090 1
	   (if nj_local_open then Env.empty_env else new_env, new_env)
@


1.60
log
@Restrict nameset of signature to names not in the basis
Add functor parameter nameset to basis nameset
@
text
@d4 4
d219 2
d248 1
d258 2
a259 1
    
d261 2
a262 1
  sharing Realise.Options = Types.Options = IdentPrint.Options = Core_rules.Options
d1674 1
d1676 6
a1681 1
      check_topdec (topdec,basis)
@


1.59
log
@Changed default for print_times to false
@
text
@d4 3
d720 4
d1511 10
a1520 7
			   fn () => Basis.basis_plus_env (basis,
						 ENV(Strenv.add_to_se
						     (strid,exp_str,
						      Strenv.empty_strenv),
						     Tyenv.empty_tyenv,
						     empty_valenv,
						     empty_valenv)))
@


1.58
log
@Simplified interface to Sigma.*names_of* functions
Rewrote circularity test to use assemblies
Rewrote well formed test to recurse properly
@
text
@d4 5
d276 1
a276 1
    val print_times = ref true
@


1.57
log
@Added option for New Jersey compatible open specifications. Fixed poor
implementation in SEQUENCEspecs and SEQUENCEstrdecs
@
text
@d4 4
d344 1
a344 1

d347 1
d364 19
d578 1
a578 5
(*
            val new_basis = Basis.basis_plus_names (basis,Sigma.names_of 
                                                    (str,
                                                     Nameset.empty_nameset()))
*)
a597 5
(*
          val new_basis = Basis.basis_plus_names (basis,Sigma.names_of 
                                                  (str,
                                                   Nameset.empty_nameset()))
*)
d634 9
a642 1
                Strenv.add_to_se (strid,str',se'))
d646 1
a646 1
              "signature does not match structure " ^ IdentPrint.printStrId strid);
d710 1
a710 1
			 fn () => Sigma.new_names_of (exp_str,Nameset.empty_nameset ()))
a711 1
(*            val _ = Print.print (Nameset.string_nameset print_options nameset) *)
d721 1
a721 1
               fun eq_scheme (_, s) = 
d728 2
a729 1
                   " does not admit equality");
d777 20
a796 13
               
           fun well_formed (BasisTypes.SIGMA (names,STR (_,_,ENV (SE amap,_,_,_)))) =
             let 
               fun check (strid,STR(m,_,env)) = 
                 (* either its a local name *)
                 Nameset.member_of_strnames (m,names)
                 orelse
                 (* or none of its substructures are local *)
                 Nameset.nameset_eq
                 (Nameset.intersection (names,
                                        Sigma.names_of_env (env,Nameset.empty_nameset ())),
                  Nameset.empty_nameset ())
                 | check _ = mycrash "check"
d798 1
a798 1
               NewMap.forall check amap 
d1311 1
a1311 2
          (* this is wrong, need to look at assemblies *)
          if (substr (str,str')) orelse (substr (str',str))
d1444 1
a1444 2
	     Nameset.diff (Sigma.names_of 
			   (exp_str',Nameset.empty_nameset ()),
d1542 1
a1542 2
		   Nameset.diff (Sigma.names_of 
				 (exp_str'',Nameset.empty_nameset ()),
d1600 1
a1600 2
                                    Sigma.names_of_env
                                    (new_env, Nameset.empty_nameset ()))
d1604 1
a1604 1
                                     Nameset.diff (Sigma.names_of_env (new_env,Nameset.empty_nameset ()),
@


1.56
log
@NamesetType changes
@
text
@d4 3
d372 5
a376 1
  fun check_topdec error_info (options as Options.OPTIONS{print_options,...},topdec,basis) =
d531 3
a533 2
                val new_env = Env.env_plus_env(env,check_strdec (strdec,basis))
                val new_basis = Basis.basis_plus_env (basis,new_env)
d535 1
a535 1
                (new_basis,new_env)
d634 1
a634 1
          val env = Timer.xtime("check_spec", !print_times,
d894 2
d897 1
a897 1
         Env.VE_in_env (Basis.close (Basis.level context,new_ve,[],Set.empty_set,false))
d903 5
a907 3
	 let val new_te = check_typdesc (typedesclist,
					 Basis.basis_to_context basis,
					 false)
d909 1
a909 1
	   Env.TE_in_env (new_te)
d917 5
a921 3
	 let val new_te = check_typdesc (typedesclist,
					 Basis.basis_to_context basis,
					 true)
d923 1
a923 1
	   Env.TE_in_env (new_te)
d972 2
d975 1
a975 2
	   (max_eq (new_te);
	    Env.VE_TE_in_env (new_ve,new_te))
d982 2
a983 1
           val ve = check_exdesc (exdesclist,Basis.basis_to_context basis)
d985 1
a985 1
	   Env.VE_EE_in_env (ve,ve)
d991 5
a995 1
	 Env.SE_in_env (check_strdesc (strdesclist,basis))
d1005 1
a1005 1
           Env.empty_env
d1011 5
a1015 1
	 check_spec (spec2,Basis.basis_plus_env (basis, check_spec (spec1,basis)))
d1033 1
d1035 2
a1036 1
	   Lists.reducel do_one (Env.empty_env,longstridlist)
d1042 10
a1051 9
         let fun do_one (env,sigid) =
           let
             val BasisTypes.SIGMA (names,str) = Basis.lookup_sigid (sigid,basis)
             val (_,new_strnames,new_tynames) = 
               Nameset.new_names_from_scratch names
             val STR (_,_,env1) = Env.resolve_top_level (COPYSTR((new_strnames,new_tynames), str))
           in
             Env.env_plus_env (env,env1)
           end
d1058 1
d1060 1
a1060 1
           Lists.reducel do_one (Env.empty_env,sigidlist)
d1067 1
a1067 1
	 Env.empty_env
d1071 1
a1071 1
           fun do_one ((env,basis),spec) =
d1073 6
a1078 2
               val new_env = Env.env_plus_env(env,check_spec(spec,basis))
               val new_basis = Basis.basis_plus_env(basis,new_env)
d1080 1
a1080 1
               (new_env,new_basis)
d1082 2
a1083 1
           val (new_env,_) = Lists.reducel do_one ((Env.empty_env,basis),speclist)
d1085 1
a1085 1
           new_env
@


1.55
log
@Options changes
@
text
@d4 3
d233 1
a233 1
  sharing Core_rules.BasisTypes = Realise.BasisTypes = Nameset.BasisTypes =
d242 1
a242 1
  sharing Strnames.Datatypes = Tyenv.Datatypes =
d247 2
@


1.54
log
@Options & Info changes
@
text
@d4 3
d364 1
a364 1
  fun check_topdec error_info (print_options,topdec,basis) =
d368 2
a369 2
      val check_dec = Core_rules.check_dec (error_info,print_options) 
      val sigmatch = Realise.sigmatch (error_info,print_options)
@


1.53
log
@Much fiddling.
Changed error handling behaviour
removed some silly bits to do with assemblies and namesets
removed most debug statements
@
text
@d4 6
d231 4
a234 1
  sharing Core_rules.BasisTypes.Info = IdentPrint.Info = Types.Info
d236 1
a236 1
  sharing Core_rules.Absyn.Datatypes = Strnames.Datatypes = Tyenv.Datatypes =
d238 1
a238 1
    Env.Datatypes
d247 1
a247 1
    structure Info = Types.Info
d252 1
d361 1
a361 1
  fun check_topdec options args =
d363 4
a366 4
      val report_error = Info.error options

      val check_type = Core_rules.check_type options
      val sigmatch = Realise.sigmatch options
d496 1
a496 1
        Core_rules.check_dec options (dec,Basis.basis_to_context basis)
d673 1
a673 1
(*            val _ = Print.print (Nameset.string_nameset options nameset) *)
d687 3
a689 1
                   Types.print_type Info.default_options (#1(Types.argres (Scheme.instantiate (1,s)))) ^
d1188 1
a1188 1
                             IdentPrint.printValId options excon,
d1584 1
a1584 1
      check_topdec args
@


1.52
log
@Changes to use BASISTYPES signature.
Removed some of the sillier bits to do with assemblies
Changes to nameset used in functor result signature
@
text
@d4 5
d240 3
d244 1
a244 1
    val do_debug = Ty_Debug.do_debug
d248 1
a248 1
    open Types.Datatypes
d257 3
d263 6
d270 1
a270 1
      if do_debug (* andalso Debug.debug_level () > 10 *) then
d276 3
a278 5
    fun set_intref (Absyn.OLDsigexp (_,intref,_),str) =
      intref := Absyn.PRESENT str
      | set_intref (Absyn.NEWsigexp(_,intref),str) =
        intref := Absyn.PRESENT str
      
d321 1
d335 14
a348 8
	(if do_debug andalso Debug.debug_level () > 5 then 
	   (Print.print (" substr... ");
	    Print.print (" name = " ^ Strnames.string_strname name);
	    Print.print (" name' = " ^ Strnames.string_strname name');
	    Print.print ("\n"))
	 else ();
	   proper_substr (str,se'))
        | substr _ = mycrash "substr"
a353 1
      val report_error' = Info.error' options
d358 1
a358 1
      fun compress_str str = (* Env.zcompress_str *) str
d363 16
a378 18
        (debug ["check_strexp 53"];
         let 
           val strname = STRNAME (Strname_id.make_strname_id ())
           val env = check_strdec (strdec,basis)
           val str = STR (strname,ref ABSENT,env)
           val exp_str as STR(_,_,ENV (se,te,_,_)) =
             Timer.xtime ("expanding structure structure",
                          !print_times,
                          fn () => Env.expand_str str) (* expanded structure needed *)
           val type_offspring =
             Assemblies.collectTypeOffspring (te,Assemblies.empty_type_offspring)
           val str_offspring = 
             Assemblies.collectStrOffspring (se,Assemblies.empty_str_offspring)
         in
           (str_ass := Assemblies.add_to_StrAssembly
            (strname,str_offspring,type_offspring,!str_ass);
            (str,exp_str))
         end)
d383 17
a399 18
          (debug ["check_strexp 54"];
           let 
             val str = (Basis.lookup_longstrid (longstrid,basis)
                        handle Basis.LookupLongStrId =>
                          report_error'
                          (Info.FATAL, location,
                           "unbound structure identifier " ^ IdentPrint.printLongStrId longstrid))
             val exp_str as STR(m,_,ENV(se,te,_,_)) = Env.expand_str str (* nice if basis expanded  *)

             val str_offs = Assemblies.collectStrOffspring (se,Assemblies.empty_str_offspring)
             val ty_offs = Assemblies.collectTypeOffspring (te,Assemblies.empty_type_offspring)
             val ty_ass' = Assemblies.updateTypeAssembly (te,!ty_ass)
           in
             (str_ass := Assemblies.add_to_StrAssembly 
              (m,str_offs,ty_offs,!str_ass);
              ty_ass := ty_ass';
              (str,exp_str))
           end)
d404 1
a404 2
          (debug ["check_strexp 55"];
           let 
d406 4
a409 3
               Timer.xtime ("check_strexp 55", !print_times,fn () => check_strexp (strexp,basis) )
(*
             val (str_ass',ty_ass') =
d418 1
a418 4
               handle Basis.LookupFunId => 
                 report_error'
                 (Info.FATAL, location, "unbound functor identifier " ^ IdentPrint.printFunId funid)
                 
d434 1
a434 1
             val STR (m,_,ENV (se,te,_,_)) = exp_newstr'' (* changed from exp_newstr''*)
d439 5
a443 5
                (sigmatch (Basis.level(Basis.basis_to_context basis), sigma,exp_str)
                 handle Realise.RealiseError s =>
                   (report_error
                    (Info.RECOVERABLE, location, s);
                    false)))
d448 1
d465 7
a471 2
                (str,exp_str))
           end)
d476 4
a479 5
          (debug ["check_strexp 56"];
           let val new_env = check_strdec (strdec,basis)
           in
             check_strexp (strexp,Basis.basis_plus_env (basis,new_env))
           end)
d486 1
a486 2
        (debug ["check_strdec 57"];
         Core_rules.check_dec options (dec,Basis.basis_to_context basis))
d490 1
a490 2
          (debug ["check_strdec 58"];
           Env.SE_in_env (check_strbinds (strbindlist, basis)))
d495 4
a498 5
          (debug ["check_strdec 59"];
           let val new_env = check_strdec (strdec1,basis)
           in
             check_strdec (strdec2, Basis.basis_plus_env (basis,new_env))
           end)
d503 12
a514 13
          (debug ["check_strdec 60 and 61"];
           let
             fun check_one ((basis,env),strdec) =
               let
                 val new_env = Env.env_plus_env(env,check_strdec (strdec,basis))
                 val new_basis = Basis.basis_plus_env (basis,new_env)
               in
                 (new_basis,new_env)
               end
             val (_,env) = Lists.reducel check_one ((basis,Env.empty_env),strdeclist)
           in
             env
           end)
d522 1
a522 2
        (debug ["check_strbinds 62"];
         Strenv.empty_strenv)
d526 22
a547 20
          (debug ["check_strbinds 62a"];
           let 
             val (str,STR(m,_,env)) = check_strexp (strexp,basis)
             val new_basis = Basis.basis_plus_names (basis,Sigma.names_of 
                                                     (str,
                                                      Nameset.empty_nameset()))
             val se' = check_strbinds (strbinds,new_basis)
           in
             (* check for shadowing *)
             let
               val str' = Strenv.lookup (strid,se)
               val (str_ass',ty_ass') = 
                 Assemblies.subAssemblies (!str_ass,!ty_ass,str')
             in
               (str_ass := str_ass';
                ty_ass := ty_ass')
             end handle Strenv.Lookup_in_SE => ();
	     Strenv.add_to_se (strid,str,se')
	 end)                             
	
d550 50
a599 49
	(debug ["check_strbinds 62b"];
	 let
	   val (str,exp_str as STR(m,_,env)) = check_strexp (strexp,basis)
	   val new_basis = Basis.basis_plus_names (basis,Sigma.names_of 
						   (str,
                                                    Nameset.empty_nameset()))
	   val (sigma,_) =
             (check_sigexp_closed (sigexp,basis,location))
             handle WellFormed sigma => 
               (report_error
                (Info.RECOVERABLE, location,
                 "constraining signature is not well-formed");
                (sigma,sigma))
           | TypeExplicit sigma =>
               (report_error
                (Info.RECOVERABLE, location,
                 "constraining signature is not type-explicit");
                (sigma,sigma))
           | RespectEquality sigma =>
               (report_error
                (Info.RECOVERABLE, location,
                 "constraining signature does not respect equality");
                (sigma,sigma))

	   val sigma' as BasisTypes.SIGMA (names',str') = Sigma.sig_copy sigma
           val exp_sigma' = BasisTypes.SIGMA(names',Env.expand_str str') (* necessary *)
	   val se' = check_strbinds (strbinds,new_basis)
	 in
	   if (sigmatch (Basis.level (Basis.basis_to_context basis),
                         exp_sigma',exp_str)
	       handle Realise.RealiseError s =>
                 (report_error
                  (Info.RECOVERABLE, location, s);
                  false)) then
	       (let
		  val str' = Strenv.lookup (strid,se)
		  val (str_ass',ty_ass') = 
		    Assemblies.subAssemblies (!str_ass,!ty_ass,str')
		in
		  (str_ass := str_ass';
		   ty_ass := ty_ass')
		end handle Strenv.Lookup_in_SE => ();
		  Strenv.add_to_se (strid,str',se'))
	   else
             (report_error
              (Info.RECOVERABLE, location,
               "signature does not match structure " ^ IdentPrint.printStrId strid);
              Strenv.empty_strenv)
	 end)
d606 16
a621 18
        (debug ["check_sigexp_open 63"];
         let
           val m = METASTRNAME (ref (NULLNAME (Strname_id.make_strname_id ())))
           val env = Timer.xtime("check_spec", !print_times,
                                 fn () => check_spec (spec,basis))
           val str = STR(m,ref ABSENT,env)
           val exp_str as STR(_,_,ENV (se,te,_,_)) = Env.expand_str str

           val type_offspring =
             Assemblies.collectTypeOffspring (te,Assemblies.findTypeOffspring(m,!sigstr_ass))
         in
           sigstr_ass :=
           Assemblies.add_to_StrAssembly
             (m,
              Assemblies.collectStrOffspring (se,Assemblies.findStrOffspring(m,!sigstr_ass)),
              type_offspring,!sigstr_ass);
           (str,exp_str)
         end)
a625 1
          (debug ["check_sigexp_open 64"];
a627 4
               handle Basis.LookupSigId => 
                 report_error'
                 (Info.FATAL, location,
                  "unbound signature identifier "^ IdentPrint.printSigId sigid)
d644 5
a648 1
           end)
a652 1
        (debug ["check_sigexp_closed 65"];
a660 1
                         (* I'm not sure this will work properly with unexpanded structures *)
d697 2
a698 2
             (NewMap.forall se_respect_equality amap andalso
              NewMap.forall tystr_respect_equality amap')
d744 1
a744 7
           fun te_type_explicit (names,[],name_copies) = 
             (if do_debug then
                debug ["te_type_explicit ",
                       "names in te_type_explicit = ",
                       (Nameset.string_nameset options names)]
              else ();
                name_copies)
d747 11
a757 16
               (if do_debug then
                  debug ["te_type_explicit a ",
                         "tycon = ",
                         (IdentPrint.printTyCon tycon)]
                else ();
                  if Types.null_tyfunp tyfun then
                    let
                      val type_name = Types.name tyfun
                      val name_copies' = 
                        te_type_explicit (names,tycons,name_copies)
                    in
                      if Nameset.member_of_tynames (type_name, names) then
                        type_name:: name_copies'
                      else name_copies
                    end
                  else te_type_explicit (names,tycons,name_copies))
d759 1
a759 7
           fun se_type_explicit (names,[],name_copies) = 
             (if do_debug then
                debug ["se_type_explicit ",
                       "names in se_type_explicit = ",
                       (Nameset.string_nameset options names)]
              else ();
                name_copies)
d761 1
a761 7
               (if do_debug then
                  debug  ["se_type_explicit a ",
                          "names in se_type_explicit a = ",
                          (Nameset.string_nameset options names)]
                else ();
                  se_type_explicit (names,stridenvs,
                                    env_type_explicit (names,env,name_copies)))
d766 8
a773 18
             (if do_debug then
                debug ["env_type_explicit ",
                       "names in env_type_explicit = ",
                       (Nameset.string_nameset options names)]
              else ();
                let
                  val strid_str_list = NewMap.to_list amap
                  val tycon_tystr_list = NewMap.to_list amap'
                  val name_copies' = te_type_explicit (names,tycon_tystr_list,
                                                       name_copies)
                in
                  if do_debug then
                    debug ["env_type_explicit after te_type_explicit ",
                           "names and copies in env_type_explicit = ",
                           (Nameset.string_nameset options names)]
                  else ();
                    se_type_explicit (names,strid_str_list,name_copies')
                end)
a775 1
             (debug ["type_explicit"];
d782 1
a782 1
              end)
d803 1
a803 1
       end)
d813 1
a813 3
    and check_sigbind (Absyn.SIGBIND [],basis,sigenv) =
      (debug ["check_sigbind 69"];
       sigenv)
a816 1
	(debug ["check_sigbinds 69a"];
d856 1
a856 1
	 end) handle Bind => mycrash "456"
a862 1
      (debug ["check_spec 70"];
a866 4
	 if do_debug then
	   debug ["signature ve before closing = ",
		  Valenv.string_valenv (0,new_ve)]
	 else ();
d868 1
a868 1
       end)
a872 1
	(debug ["check_spec 71"];
d878 1
a878 1
	 end)
a884 1
	(debug ["check_spec 72"];
d890 1
a890 1
	 end)
a895 1
	(debug ["check_spec 73"];
d941 1
a941 1
	 end)
a945 1
	(debug ["check_spec 74"];
d950 1
a950 1
	 end)
d955 1
a955 2
	(debug ["check_spec 75"];
	 Env.SE_in_env (check_strdesc (strdesclist,basis)))
a959 1
	(debug ["check_spec 76"];
d966 1
a966 1
         end)
d971 1
a971 3
	(debug ["check_spec 77"];
	 check_spec (spec2,Basis.basis_plus_env (basis,
						 check_spec (spec1,basis))))
a975 1
	(debug ["Check_spec 78"];
d991 1
a991 1
	 end)
a995 1
	(debug ["check_spec 79"];
a1001 1
(*              val STR (_,_,env1) = Env.str_copy(str,new_strnames,new_tynames) *)
d1013 1
a1013 1
         end)
d1019 1
a1019 2
	(debug ["check_spec 80"];
	 Env.empty_env)
a1021 1
	(debug ["check_spec 81"];
d1033 1
a1033 1
         end)
a1039 1
     (debug ["check_valdesc 82"];
d1056 1
a1056 1
      end)
a1062 1
      (debug ["check_typdesc 83"];
d1082 1
a1082 1
       end)
d1089 1
a1089 2
      (debug ["check_datdesc 84"];
       (ve,te))
a1093 1
	(debug ["check_datdesc 84a"];
d1118 1
a1118 1
	end)
d1124 1
a1124 3
      (debug ["check_condesc"];

       sigty_ass := Assemblies.add_to_TypeAssembly (tyfun,conenv,1,!sigty_ass);
a1131 1

d1137 9
a1145 10
	(debug ["check_condesc 85 absent"];
	 let 
	   val tyscheme = 
	     Scheme.make_scheme (tyvartypes,tycon_type)
	   val new_ve = Valenv.add_to_ve (valid,tyscheme,ve)
	   val new_conenv = Valenv.add_to_ve (valid,tyscheme,conenv)
	 in
	   check_condesc (condescs,tycon,tyfun,tycon_type,tyvartypes,
			  acontext,new_conenv,(new_ve,te))
	 end)
a1149 1
	(debug ["check_condesc 85 present"];
d1159 1
a1159 1
	 end)
d1218 1
a1218 2
          (debug ["check_shareq for structures"];
           check_str_share (stridlist,basis,location))
d1220 1
a1220 2
            (debug ["check_shareq for types"];
             check_type_share (tyconlist,basis,location))
d1225 53
a1277 1
    and check_str_share (sharelist,basis as BasisTypes.BASIS (nameset,funenv,sigenv,env),location) =
d1279 5
a1283 14
        exception Error
        fun do_two (lstrid as Ident.LONGSTRID (path,valid),lstrid' as Ident.LONGSTRID (path',valid')) =
          (let
            val str as STR (m,_,_) =
              Env.expand_str (Env.lookup_longstrid (lstrid,env)) (* nice if env was expanded *)
              handle Env.Lookup_LongStrId =>
                (report_error
                 (Info.RECOVERABLE, location,
                  "unbound structure identifier " ^
                  IdentPrint.printLongStrId lstrid);
                 raise Error)
            val str' as STR (m',_,_) = 
              Env.expand_str (Env.lookup_longstrid (lstrid',env)) (* nice if env was expanded *)
              handle Env.Lookup_LongStrId =>
d1286 5
a1290 3
                  "unbound structure identifier " ^
                  IdentPrint.printLongStrId lstrid');
                 raise Error)
d1292 2
a1293 7
            if (substr (str,str')) orelse (substr (str',str))
              then
                (report_error
                 (Info.RECOVERABLE, location,
                  implode ["sharing ",IdentPrint.printLongStrId lstrid, " and ",
                           IdentPrint.printLongStrId lstrid', " creates a cycle"]);
                 ())
d1295 12
a1306 11
              (let 
                val (share_successful,sigstr_ass',sigty_ass') = 
                  Share.share_str (m,m',!sigstr_ass,!sigty_ass,nameset)
              in		  
                 if share_successful
                   then (sigstr_ass := sigstr_ass';
                         sigty_ass := sigty_ass')
                 else
                   () (* do we need to print a message here? *)
              end 
            handle Share.ShareError s =>
d1309 3
a1311 6
                implode ["failed to share structures ",
                         IdentPrint.printLongStrId lstrid, " and ",
                         IdentPrint.printLongStrId lstrid', ":\n  ", s]);
               ()))
          end
          handle Error => ())
d1315 1
a1315 1
        aux sharelist
d1318 2
a1319 1
    (* *** rule 89 *** *)  
a1320 44
    and check_type_share ((ltycon as Ident.LONGTYCON (path,tycon))::
			  (sharelist as ((ltycon' as Ident.LONGTYCON
					 (path',tycon'))::shareqs)),
			  basis as BasisTypes.BASIS (nameset,funenv,sigenv,env),
                          location) =
	(debug ["check_type_shareq 89a"];
         let
           exception Error
         in
           let 
             val TYSTR (tyfun,_) = 
               Basis.lookup_longtycon (ltycon,Basis.basis_to_context basis)
               handle Basis.LookupLongTyCon =>
                 (report_error
                  (Info.RECOVERABLE, location,
                   "unbound type constructor " ^ IdentPrint.printLongTyCon ltycon);
                  raise Error)
             val TYSTR (tyfun',_) = 
               Basis.lookup_longtycon (ltycon',Basis.basis_to_context basis)
               handle Basis.LookupLongTyCon =>
                 (report_error
                  (Info.RECOVERABLE, location,
                   "unbound type constructor "^ IdentPrint.printLongTyCon ltycon');
                  raise Error)
             val (share_successful,sigty_ass') = 
               Sharetypes.share_tyfun (tyfun,tyfun',!sigty_ass)
               handle Sharetypes.ShareError s =>
                 (report_error
                  (Info.RECOVERABLE, location,
                   implode
                   [" failed to share types ",
                    IdentPrint.printLongTyCon ltycon, " and ",
                    IdentPrint.printLongTyCon ltycon', ": ", s]);
                  (false,!sigty_ass))
           in
             if share_successful
               then sigty_ass := sigty_ass'
             else
               ()
           end handle Error => ();
           check_type_share (sharelist,basis,location)
	 end)
      | check_type_share _ = ()
       
d1329 1
a1329 3
    and check_funbind (Absyn.FUNBIND [],basis,funenv) =
      (debug ["check_funbind 99"];
       funenv)
a1334 1
	(debug ["check_funbind 99a"];
d1353 8
a1360 8
(* 	   val _ = namesetref := names *)
	   val (str',exp_str') = 
	     check_strexp (strexp,Basis.basis_plus_env 
			   (basis,ENV (Strenv.add_to_se 
				       (strid,exp_str,Strenv.empty_strenv),
				       Tyenv.empty_tyenv,
				       empty_valenv,
				       empty_valenv)))
d1376 9
a1384 1
	   
d1388 1
a1388 1
	 end handle Bind => mycrash "check_funbind34")
a1393 1
	(debug ["check_funbind 99b"];
a1415 1
(*	   val _ = namesetref := names *)
d1430 16
a1445 16
             (((check_sigexp_closed (sigexp',new_basis,location))
               handle WellFormed sigma => 
                 (report_error
                  (Info.RECOVERABLE, location,
                   "constraining signature is not well-formed");
                  (sigma,sigma)))
              handle TypeExplicit sigma =>
                (report_error
                 (Info.RECOVERABLE, location,
                  "constraining signature is not type-explicit");
                 (sigma,sigma)))
             handle RespectEquality sigma =>
               (report_error
                (Info.RECOVERABLE, location,
                 "constraining signature does not respect equality");
                (sigma,sigma)))
d1451 1
d1456 2
a1457 6
                          (sigmatch (Basis.level (Basis.basis_to_context basis),
                                     BasisTypes.SIGMA(names'',exp_str''),exp_str')
                           handle Realise.RealiseError s =>
                             (report_error
                              (Info.RECOVERABLE, location, s);
                              false)))
a1474 1
(*		 Funenv.add_to_funenv (funid,phi, *)
a1480 1
             (* I think a realise error is produced before this *)
d1486 1
a1486 1
	 end handle Bind => mycrash "check_funbind39")
d1488 1
a1488 3
    fun check_sigdec ([],basis, sigenv) = 
      (debug ["check_sigdec"];
       sigenv)
d1491 9
a1499 12
	(debug ["check_sigdec a"];
	 let
	   val new_sigenv = check_sigbind (sigbind,basis,sigenv)
	   val new_basis = Basis.basis_plus_sigenv (basis,new_sigenv)
	 in
	   check_sigdec(sigbindlist, new_basis,
			Sigenv.sigenv_plus_sigenv (new_sigenv, sigenv))
	 end)

    fun check_fundec ([],basis, funenv) =
      (debug [ "check_fundec"];
       funenv)
d1501 7
a1507 8
	(debug ["check_fundec"];
	 let
	   val new_funenv = check_funbind (funbind,basis,funenv)
	   val new_basis = Basis.basis_plus_funenv (basis,new_funenv)
	 in
	   check_fundec (funbindlist,new_basis,
			 Funenv.funenv_plus_funenv (new_funenv, funenv))
	 end)
d1511 17
a1527 12
    fun check_topdec (Absyn.STRDECtopdec (strdec,location),basis) = 
      (debug ["check_topdec 100"];
       let 
	 val new_env = check_strdec (strdec,basis)
       in
	 sigstr_ass := !str_ass;
	 sigty_ass := !ty_ass;
	 if (Env.no_imptyvars new_env) (* get something expanded from check_strdec? *)
	   then 
	     Basis.basis_plus_names (Basis.env_in_basis new_env,
				     Sigma.names_of_env
				     (new_env, Nameset.empty_nameset ()))
d1533 1
a1533 1
       end)
a1537 1
	(debug ["check_topdec 101"];
d1555 2
a1556 3
	   Basis.basis_plus_names (Basis.sigenv_in_basis new_sigenv,
				   Sigenv.names_of_sigenv new_sigenv)
	 end)
d1561 10
a1570 24
	(debug ["check_topdec 102"];
	 let 
	   val new_funenv =
	     check_fundec (funbindlist,basis, Funenv.empty_funenv)
	 in

	   sigstr_ass := Assemblies.empty_strassembly ();
	   sigty_ass := Assemblies.empty_tyassembly;
	   str_ass := Assemblies.empty_strassembly ();
	   ty_ass := Assemblies.empty_tyassembly;
	   
	   if (Funenv.no_imptyvars new_funenv) (* get something expanded? *)
	     then 
	       Basis.basis_plus_names (Basis.funenv_in_basis new_funenv,
				       Funenv.names_of_funenv new_funenv)
	   else
             (report_error
              (Info.RECOVERABLE, location, 
               "free imperative type variables at top level");
              basis)
	 end)
	| check_topdec (Absyn.REQUIREtopdec (s, _),basis) = 
	  (debug ["check_topdec require"];
	   basis)
d1574 1
a1574 2

    end
@


1.51
log
@Extensive changes:
Fixed bug with include
COPYSTR representation
Changed many functions to use Lists.reducel
Made many errors recoverable
General tidying up of code
@
text
@d4 8
a161 1
require "../utils/set";
a171 1
require "../typechecker/type_exp";
a172 1
require "../typechecker/realise";
d175 8
a185 1
  structure Set        : SET
a194 1
  structure Tystr      : TYSTR
a198 1
  structure Type_exp   : TYPE_EXP
d201 6
d209 1
d216 10
a225 16
  sharing Core_rules.Basis.Sigenv.Sigma.Nameset.Info = Type_exp.Info =
    Realise.Info = IdentPrint.Info = Types.Info
  sharing Env.Datatypes = Strnames.Datatypes   = Tyenv.Datatypes =
    Tystr.Datatypes      = Valenv.Datatypes =
    Scheme.Datatypes     = Types.Datatypes = 
    Strenv.Datatypes = Core_rules.Basis.Tyvarenv.Datatypes =
    Core_rules.Absyn.Datatypes
  sharing Core_rules.Basis.Funenv.Phi.Sigma = Core_rules.Basis.Sigenv.Sigma =
    Realise.Sigma
  sharing Core_rules.Absyn = Type_exp.Absyn
  sharing Core_rules.Basis = Type_exp.Basis
  sharing Core_rules.Basis.Funenv.Phi.Sigma.Nameset =
    Core_rules.Basis.Sigenv.Sigma.Nameset = Core_rules.Absyn.Nameset =
    Share.Nameset
  sharing Share.Assemblies = 
    Sharetypes.Assemblies = Core_rules.Assemblies
a226 2
  (* ABSYN doesn't have full signature of Set *)
  sharing Set = Core_rules.Absyn.Set
a229 1
    structure Nameset = Share.Nameset
d231 1
a231 1
    structure Basis = Core_rules.Basis
d233 2
a234 5
    structure Sigenv = Basis.Sigenv
    structure Funenv = Basis.Funenv
    structure Phi = Funenv.Phi
    structure Sigma = Sigenv.Sigma
    structure Info = Type_exp.Info
d243 3
a245 3
    exception WellFormed of Sigma.Sigma 
    exception TypeExplicit of Sigma.Sigma
    exception RespectEquality of Sigma.Sigma
d334 1
a334 1
      val check_type = Type_exp.check_type options
d390 1
d397 2
a398 1
             val phi as Phi.PHI (names,(str'',Sigma.SIGMA (names',str'))) = 
d415 1
a415 1
             val Phi.PHI (newnames,(newstr'',Sigma.SIGMA (newnames',newstr'))) = Phi.phi_copy phi
d418 2
a419 2
             val sigma = Sigma.SIGMA (newnames,exp_newstr'')
             val STR (m,_,ENV (se,te,_,_)) = exp_newstr'
d510 1
a510 1
                          basis as Basis.BASIS (_,_,_,ENV (se,_,_,_))) = 
d532 1
a532 1
			basis as Basis.BASIS (_,_,_,ENV (se,_,_,_))) = 
d557 2
a558 2
	   val sigma' as Sigma.SIGMA (names',str') = Sigma.sig_copy sigma
           val exp_sigma' = Sigma.SIGMA(names',Env.expand_str str') (* necessary *)
d612 1
a612 1
             val Sigma.SIGMA (names,str) = Basis.lookup_sigid (sigid,basis)
d647 1
d655 2
a656 2
           val sigma = Sigma.SIGMA(nameset,comp_str)
           val exp_sigma = Sigma.SIGMA(nameset, exp_str)
d687 1
a687 1
           fun respect_equality (Sigma.SIGMA (names,STR (_,_,env))) = 
d709 1
a709 1
           fun equality_principal (sigma as Sigma.SIGMA (names,STR(_,_,env))) =
d714 1
a714 1
           fun well_formed (Sigma.SIGMA (names,STR (_,_,ENV (SE amap,_,_,_)))) =
d795 1
a795 1
           fun type_explicit (Sigma.SIGMA (names,STR (_,_,env))) =
d842 1
a842 1
	   val (sigma as Sigma.SIGMA (names,str),Sigma.SIGMA(_,exp_str)) =
d877 1
a877 1
           Sigenv.add_to_sigenv (sigid,Sigma.SIGMA(names,str),
d926 1
a926 1
		    basis as Basis.BASIS (_,_,_,ENV (_,te,_,_))) =
d1037 1
a1037 1
             val Sigma.SIGMA (names,str) = Basis.lookup_sigid (sigid,basis)
d1137 1
a1137 1
		       context as Basis.CONTEXT (level,tyvarset,env,_),
d1142 1
a1142 1
		 Basis.Tyvarenv.add_to_tyvarenv (level,h,collect(t,amap))
d1144 2
a1145 2
	       collect (tyvars,Basis.Tyvarenv.empty_tyvarenv)
	     val new_context = Basis.CONTEXT (level,tyvarset,env,
d1278 1
a1278 1
    and check_str_share (sharelist,basis as Basis.BASIS (nameset,funenv,sigenv,env),location) =
d1338 1
a1338 1
			  basis as Basis.BASIS (nameset,funenv,sigenv,env),
d1392 1
a1392 1
		       ((funid,strid,sigexp,namesetref,strexp,Absyn.ABSENT,_,
d1394 1
a1394 1
		       basis as Basis.BASIS (nameset,_,_,_),funenv) = 
d1397 1
a1397 1
	   val (Sigma.SIGMA (names,str),Sigma.SIGMA (_,exp_str)) = 
d1414 1
a1414 1
	   val _ = namesetref := names
d1426 1
a1426 1
	   val phi = Phi.PHI (names,(str,Sigma.SIGMA (names',str')))
d1438 1
a1438 1
	   Funenv.add_to_funenv (funid,Phi.PHI (names,(str,Sigma.SIGMA(names',str'))),
d1443 1
a1443 1
      | check_funbind (Absyn.FUNBIND ((funid,strid,sigexp,namesetref,strexp,
d1446 1
a1446 1
		       basis as Basis.BASIS (nameset,_,_,_),funenv) = 
d1449 1
a1449 1
	   val (sigma as Sigma.SIGMA (names,str),Sigma.SIGMA (_,exp_str)) =
d1470 1
a1470 1
	   val _ = namesetref := names
d1503 1
a1503 1
	   val sigma'' as Sigma.SIGMA (names'',str'') = Sigma.sig_copy sigma'
d1505 1
a1505 1
	   val (str_ass',ty_ass') = Assemblies.subAssemblies(!str_ass, !ty_ass, exp_str')
d1511 1
a1511 1
                                     Sigma.SIGMA(names'',exp_str''),exp_str')
d1520 1
a1520 1
				 (exp_str',Nameset.empty_nameset ()),
d1522 1
a1522 1
		 val phi = Phi.PHI(names,(str,Sigma.SIGMA (names',str'')))
d1528 1
d1531 1
d1534 2
a1535 2
                 Funenv.add_to_funenv (funid,Phi.PHI (names,(str,
                                                             Sigma.SIGMA(names',comp_str''))),
d1635 1
a1635 1
	   if (Basis.Funenv.no_imptyvars new_funenv) (* get something expanded? *)
@


1.50
log
@Anel's last changes
@
text
@d4 3
a169 2
require "../typechecker/nameset";
require "../typechecker/interface";
d173 1
a173 1
  structure Set : SET
a192 2
  structure Interface : INTERFACE
  structure Nameset : NAMESET
d201 1
a201 2
  sharing Env.Datatypes = Interface.Datatypes =
    Strnames.Datatypes   = Tyenv.Datatypes =
d212 1
a212 1
    Share.Nameset = Nameset
d216 1
a216 1
  sharing Interface = Core_rules.Absyn.Interface
d221 1
d233 1
a233 1
    val print_times = ref false
d237 1
d248 1
a248 1
      if do_debug andalso Debug.debug_level () > 10 then
d254 5
d298 3
d302 1
a302 1
      fun proper_substr (str as STR (name,_),SE amap) =
d307 3
a309 2
          (fn (_, STR (m,ENV (se',_,_,_))) => 
           m = name orelse proper_substr (str,se')) 
d311 1
d313 1
a313 1
      fun substr (str as STR (name,_),STR (name',ENV (se',_,_,_))) =
d321 1
d332 2
d340 6
a345 1
           val env as ENV (se,te,_,_) = check_strdec (strdec,basis)
d353 1
a353 1
            STR (strname,env))
d361 10
a370 11
             val str as STR (m,ENV (se,te,_,_)) = 
               Basis.lookup_longstrid (longstrid,basis)
               handle Basis.LookupLongStrId =>
                 report_error'
                 (Info.FATAL, location,
                  "unbound structure identifier " ^ IdentPrint.printLongStrId longstrid)
             val str_offs = Timer.xtime ("collectStrOffspring 54", !print_times, fn () => Assemblies.collectStrOffspring
                                         (se,Assemblies.empty_str_offspring))
             val ty_offs = Timer.xtime ("collectTypeOffspring 54", !print_times, fn () => Assemblies.collectTypeOffspring 
                                        (te,Assemblies.empty_type_offspring))
             val ty_ass' = Timer.xtime ("updateTypeAssembly 54", !print_times, fn () =>Assemblies.updateTypeAssembly (te,!ty_ass))
d375 1
a375 1
              str)
d383 6
a388 3
             val str = Timer.xtime ("check_strexp 55", !print_times,fn () => check_strexp (strexp,basis) )
             val (str_ass',ty_ass') = Timer.xtime ("subAssemblies 55", !print_times, fn () => Assemblies.subAssemblies (!str_ass,!ty_ass,
                                                                                                                        str))
d405 2
a406 2
structure of the functor application.
  ****)
d408 5
a412 5
             val Phi.PHI (newnames,(newstr'',
                                    Sigma.SIGMA (newnames',newstr'))) =
               Timer.xtime ("phi_copy 55", !print_times, fn () => Phi.phi_copy phi)
             val sigma = Sigma.SIGMA (newnames,newstr'')
             val STR (m,ENV (se,te,_,_)) = newstr' 
d417 1
a417 1
                (sigmatch (Basis.level(Basis.basis_to_context basis), sigma,str)
d435 1
a435 2
                    
                    newstr')
d442 1
a442 1
                str)
d480 9
a488 9
           let 
             fun check_strdec_seqs ([],_,env) = env
               | check_strdec_seqs (astrdec::strdecs,basis,env) = 
                 let val new_env = check_strdec (astrdec,basis)
                 in
                   check_strdec_seqs (strdecs, 
                                      Basis.basis_plus_env (basis,new_env),
                                      Env.env_plus_env (env,new_env))
                 end
d490 1
a490 1
             check_strdec_seqs (strdeclist,basis,Env.empty_env)
d492 1
a492 2
          
          
d496 2
a497 1
          
d506 1
a506 1
             val str as STR (m,env) = check_strexp (strexp,basis)
a510 9
             val _ =
               let
                 val str' = Strenv.lookup (strid,se)
                 val (str_ass',ty_ass') = 
                   Assemblies.subAssemblies (!str_ass,!ty_ass,str')
               in
                 (str_ass := str_ass';
                  ty_ass := ty_ass')
               end handle Strenv.Lookup_in_SE => ()
d512 9
a526 1

d528 17
a544 14
	   val str as STR (m,env) = check_strexp (strexp,basis)       
	   val sigma =
             (((check_sigexp_closed (sigexp,basis,location))
               handle WellFormed sigma => 
                 (report_error
                  (Info.RECOVERABLE, location,
                   "constraining signature is not well-formed");
                  sigma))
              handle TypeExplicit sigma =>
                (report_error
                 (Info.RECOVERABLE, location,
                  "constraining signature is not type-explicit");
                 sigma))
             handle RespectEquality sigma =>
d548 1
a548 1
                sigma)
d550 2
a551 8
	   val sigma' as Sigma.SIGMA (_,str') =
	     (if do_debug then
		debug ["sigma before copying :\n ",(Sigma.string_sigma options sigma)]
		else ();
	      Sigma.sig_copy sigma)
	   val new_basis = Basis.basis_plus_names (basis,Sigma.names_of 
						   (str,
                                                    Nameset.empty_nameset()))
d555 1
a555 1
				 sigma',str) 
d580 1
a580 1
      and check_sigexp_open (Absyn.NEWsigexp (spec,intref),basis) = 
a581 1

d584 5
a588 3
           val env as ENV (se,te,_,_) =
             Timer.xtime("check_spec", !print_times,
                         fn () => check_spec (spec,basis))
d590 1
a590 7
             Timer.xtime("collectTypeOffspring", !print_times,
                         fn () => Assemblies.collectTypeOffspring (te,
                                                                   Assemblies.findTypeOffspring 
                                                                   (m,!sigstr_ass)))
             
           val _ = intref := Interface.inter env
             
d593 5
a597 10
           Timer.xtime("add_to_StrAssembly", !print_times,
                       fn () =>
                       Assemblies.add_to_StrAssembly
                       (m,
                        Assemblies.collectStrOffspring (se,
                                                        Assemblies.findStrOffspring 
                                                        (m,!sigstr_ass)),
                        type_offspring,!sigstr_ass));
           
           STR (m,env)
d602 1
a602 1
        | check_sigexp_open (Absyn.OLDsigexp (sigid,intref,location),basis) =
d610 1
a610 1
             val (names',new_tynames,new_strnames) = 
d617 3
a619 3
             val (str' as STR (m,env)) = 
               Env.str_copy (str,new_tynames,new_strnames)
               
d621 1
a621 1
             val _ = intref := Interface.inter env
d623 3
a625 9
             (Timer.xtime
              ("unionStrAssembly 64", !print_times,
               fn () =>
               sigstr_ass := Assemblies.unionStrAssembly(!sigstr_ass,sigstr_ass'));
              Timer.xtime
              ("unionTypeAssembly 64", !print_times,
               fn () =>
               sigty_ass := Assemblies.unionTypeAssembly(!sigty_ass,sigty_ass'));
              str')
d633 1
a633 1
           val str =
d637 12
a648 11
           val sigma as (Sigma.SIGMA(nameset, _)) = 
             Timer.xtime("new_names_of", !print_times,
			 fn () =>
                         Sigma.SIGMA (Sigma.new_names_of (str,
                                      Nameset.empty_nameset ()),str))
             
           exception RespectEq of Type

           fun eq_scheme (_, s) = 
             if Scheme.equalityp s then true
             else raise RespectEq (Scheme.instantiate (1,s))
d651 3
a653 3
             if Types.equalityp tyfun then
               (NewMap.forall eq_scheme amap)
               handle RespectEq t => 
d656 1
a656 1
                   Types.print_type Info.default_options (#1(Types.argres t)) ^
d659 5
a663 1
             else true
d665 8
a672 3
           fun se_respect_equality(_, STR(_, env)) =
             env_respect_equality (env)
             
d679 1
a679 1
           fun respect_equality (Sigma.SIGMA (names,STR (_,env))) = 
d681 1
d683 10
a692 9
           fun max_eq_pred (_, TYSTR (atyfun,VE (_,amap))) =
             if Types.equalityp atyfun then
               if NewMap.forall eq_scheme amap then true
               else Types.make_false atyfun
             else
               true
               
           fun max_eq (TE amap) =
             while not (NewMap.forall max_eq_pred amap) do ()
d694 1
a694 4
           fun te_equality_principal te = 
             (max_eq (te); true)
             
           fun se_equality_principal (_,STR (_,env)) =
d696 1
a696 1
             
d698 2
a699 3
             te_equality_principal te 
             andalso
             NewMap.forall se_equality_principal amap
d701 4
a704 2
           fun equality_principal (sigma as Sigma.SIGMA (names,STR(_,env))) =
             if env_equality_principal env then sigma else sigma
d706 16
a721 32
           fun check ([],_,_) = true
             | check (strid::strids,names,env) = 
               let
                 val STR (m,env') = Env.lookup_strid (strid,env)
                   handle Env.Lookup_StrId =>
                     Crash.impossible 
                     ("Unbound structure identifier in mod_rules/crash " ^ 
                      IdentPrint.printStrId strid)
               in
                 if not (Nameset.member_of_strnames (m,names)) 
                   then
                     Nameset.nameset_eq 
                     (Nameset.intersection 
                      (names,
                       Sigma.names_of_env (env',
                                           Nameset.empty_nameset ())),
                      Nameset.empty_nameset ())
                     andalso check (strids,names,env)
                 else true
               end
             
           fun well_formed (Sigma.SIGMA (names,
                                         STR (_,env as ENV (SE amap,_,_,_)))) =
             (if do_debug then
                debug ["names in well_formed = ",
		       Nameset.string_nameset options names]
              else ();
                let 
                  val strids = NewMap.domain amap
                in
                  check (strids,names,env)
                end)
d756 1
a756 1
             | se_type_explicit (names,(_,STR(_,env))::stridenvs,name_copies) = 
d764 1
d787 1
a787 1
           fun type_explicit (Sigma.SIGMA (names,STR (_,env))) =
d792 3
a794 9
                if do_debug then
                  debug ["nameset in type_explicit = ",
                         (Nameset.string_nameset options names)]
                else ();
                  Nameset.nameset_eq (Nameset.tynames_in_nameset 
                                      ((Nameset.tynames_of_nameset names),
                                       Nameset.empty_nameset ()),
                                      Nameset.tynames_in_nameset
                                      (name_copies,Nameset.empty_nameset ())) 
d796 1
a796 1

d798 18
a815 14
	 if Timer.xtime("respect_equality", !print_times,
			  fn () => respect_equality sigma) then
	   if Timer.xtime("type_explicit", !print_times,
			    fn () => type_explicit sigma) then
	     if Timer.xtime("well_formed", !print_times,
			      fn () => well_formed sigma) then
	       Timer.xtime("equality_principal", !print_times,
			     fn () => equality_principal sigma)
	     else
               raise WellFormed sigma
	   else 
             raise TypeExplicit sigma
	 else
           raise RespectEquality sigma
d834 16
a849 15
	   val sigma as Sigma.SIGMA (_,STR (m,env)) =
             (((check_sigexp_closed (sigexp,basis,location))
               handle WellFormed sigma => 
                 (report_error
                  (Info.RECOVERABLE, location,
                   "signature " ^ IdentPrint.printSigId sigid ^ 
                   " is not well-formed");
                  sigma))
              handle TypeExplicit sigma =>
                (report_error
                 (Info.RECOVERABLE, location,
                  "signature "  ^ IdentPrint.printSigId sigid ^ 
                  " is not type-explicit");
                 sigma))
             handle RespectEquality sigma =>
d854 1
a854 2
                sigma)

d859 1
d864 1
a864 4
		 Timer.xtime
		 ("unionTypeAssembly 69", !print_times,
		  fn () =>
		  ty_ass := Assemblies.unionTypeAssembly (!ty_ass,sigty_ass'))
d868 5
a872 5
	     
	     Sigenv.add_to_sigenv (sigid,sigma,
				   check_sigbind (Absyn.SIGBIND sigbinds,
						  basis,sigenv))
	 end)
d888 1
a888 2
	 Env.VE_in_env (Basis.close (Basis.level context,new_ve,[],
				     Set.empty_set,false))
d890 1
a890 1
		
d948 1
a948 1
	     
d988 1
a988 1
           val env = 
d992 1
a992 1
           env
d1007 5
a1011 10
	   fun collect_envs (longstrid::[]) =
	     let 
	       val STR (name,env) = Basis.lookup_longstrid (longstrid,basis)
		 handle Basis.LookupLongStrId =>
                   report_error'
                   (Info.FATAL, location,
                    "unbound structure identifier " ^ 
                    IdentPrint.printLongStrId longstrid)
	     in
	       env
d1013 6
a1018 14
	     | collect_envs (longstrid::longstridlist) =
	       let
		 val STR (name,env1) = Basis.lookup_longstrid (longstrid,basis)
		   handle Basis.LookupLongStrId =>
                     report_error'
                     (Info.FATAL, location,
                      "unbound structure identifier " ^ 
                      IdentPrint.printLongStrId longstrid)
		 val env = collect_envs (longstridlist)
	       in
		 Env.env_plus_env (env1,env)
	       end
	     | collect_envs _ =
	       Crash.impossible"collect_envs bad parameters"
d1020 1
a1020 1
	   collect_envs longstridlist
d1027 20
a1046 30
	 let 
	   fun collect_envs (sigid::[],basis) =
	     let 
	       val Sigma.SIGMA (name,STR (_,env)) = 
		 Basis.lookup_sigid (sigid,basis)
		 handle Basis.LookupSigId =>
                   report_error'
                   (Info.FATAL, location,
                    "unbound signature identifier " ^
                    IdentPrint.printSigId sigid)
	     in
	       env
	     end
	     | collect_envs (sigid::sigidlist,basis) =
	       let
		 val Sigma.SIGMA (name,STR (_,env1)) =
		   Basis.lookup_sigid (sigid,basis)
		   handle Basis.LookupSigId =>
                     report_error'
                     (Info.FATAL, location,
                      "unbound signature identifier " ^
                      IdentPrint.printSigId sigid)
		 val env = collect_envs (sigidlist,basis)
	       in
		 Env.env_plus_env (env1,env)
	       end
	   | collect_envs _ = Crash.impossible"collect_envs bad parameters"
	 in
	   collect_envs (sigidlist,basis)
	 end)
d1054 1
a1054 1
      | check_spec (Absyn.SEQUENCEspec(the_list as (spec::speclist)),basis) =
d1056 13
a1068 25
(*
	 let 
	   val new_env = check_spec (spec,basis)
	   val new_basis = Basis.basis_plus_env (basis,new_env)
	 in
	   Env.env_plus_env (new_env,check_spec (Absyn.SEQUENCEspec speclist,
						 new_basis))
	 end
*)
	let
	  val e_list = do_seq([], the_list, basis)
	in
	  Lists.reducel
	  (fn (x, y) => Env.env_plus_env(y, x))
	  (Env.empty_env, e_list)
	end)

    and do_seq(acc, [], _) = acc
      | do_seq(acc, spec :: speclist, basis) =
	let
	  val new_env = check_spec(spec, basis)
	in
	  do_seq(new_env :: acc, speclist, Basis.basis_plus_env(basis,new_env))
	end

d1073 19
a1091 18
    and check_valdesc ([],context) = 
      (debug ["check_valdesc 82"];
       empty_valenv)

      | check_valdesc ((valid,ty,tyvarset)::valdescs,context) = 
	(debug ["check_valdesc 82a"];
	 let 
	   val tyvars_scoped_here = 
	     Set.setdiff (tyvarset,Basis.get_tyvarset context)
	   val new_context = 
	     Basis.context_plus_tyvarset_and_tyvarenv (context,
						       tyvars_scoped_here)
	   val atype = check_type (ty,new_context)
	   val ascheme = Scheme.make_scheme ([],atype)
	 in
	   Valenv.add_to_ve (valid,ascheme,
			     check_valdesc (valdescs,new_context))
	 end)
d1097 1
a1097 1
    and check_typdesc ([],context,eq) =
d1099 1
a1099 4
       Tyenv.empty_tyenv)

      | check_typdesc ((tyvarlist,tycon)::typdescs,context,eq) =
	(debug ["check_typdesc 83a"];
d1103 1
a1103 2
	     (METATYNAME (ref (NULL_TYFUN
			       (Tyfun_id.make_tyfun_id())),
d1114 5
a1118 4

	   Tyenv.add_to_te (check_typdesc (typdescs,context,eq),
			    tycon,TYSTR (tyfun,empty_valenv))
	 end)
a1140 4
(*                 report_error'
                   (Info.FATAL, location,
                    "unbound type constructor " ^
                     IdentPrint.printTyCon tycon) *)
d1144 1
a1144 3
			       (fn x =>
				check_type 
				(Absyn.TYVARty x,new_context))
d1151 1
a1151 2
					 Types.apply
					 (tyfun,tyvartypes),
d1208 24
a1231 27
    and check_exdesc ([],context) = 
      (debug ["check_exdesc 86"];
       empty_valenv)

      | check_exdesc ((excon,Absyn.ABSENT,location)::exdescs,context) =
	(debug ["check_exdesc 86 absent"];
	 Valenv.add_to_ve (excon,Scheme.make_scheme ([],Types.exn_type),
			   check_exdesc (exdescs,context)))
	
      | check_exdesc ((excon,Absyn.PRESENT aty,location)::exdescs,context) =
	(debug ["check_exdesc present 86"];
	 let 
	   val atype = 
	     if Absyn.has_tyvar (aty) then 
               (report_error
                (Info.RECOVERABLE, location,
                 implode ["Exception description of ",
                          IdentPrint.printValId options excon,
                          " contains a type variable"]);
                fresh_tyvar (context, false, false))
	     else
	       check_type (aty,context)
	 in
	   Valenv.add_to_ve (excon,Scheme.make_scheme 
			     ([],FUNTYPE (atype,Types.exn_type)),
			     check_exdesc (exdescs,context))
	 end)
d1237 14
a1250 28
    and check_strdesc ([],_) = 
      (debug ["check_strdesc 87"];
       Strenv.empty_strenv)

      | check_strdesc (the_list as (strid,sigexp)::strdescs,
		       basis as Basis.BASIS (_,_,_,env as ENV (se,_,_,_))) =
	(debug ["check_strdesc 87a"];
	let
	  val se_list = do_strdesc([], the_list, basis)
	in
	  Lists.reducel
	  (fn (x,(strid,str)) => Strenv.add_to_se (strid,str,x))
	  (Strenv.empty_strenv,se_list)
	end)

    and do_strdesc(acc, [], _) = acc
      | do_strdesc(acc, (strid,sigexp)::strdescs,
		   basis as Basis.BASIS(_,_,_,ENV(se,_,_,_))) =
	let
	  val str = check_sigexp_open (sigexp,basis)
	  val _ =
	    if Strenv.member_of_se_domain (strid,se) then
	      shadowing_occurred := true
	    else ();
	in
	  do_strdesc((strid, str) :: acc, strdescs, basis)
	end

d1258 66
a1323 69
    and check_shareq ([],_) = 
      (debug ["check_shareq  for []"];
       Env.empty_env)

     | check_shareq ((Absyn.STRUCTUREshareq stridlist,location)::shareqs,basis) =
       (debug ["check_shareq for structures"];
	Env.env_plus_env (check_str_share (stridlist,basis,location),
			  check_shareq (shareqs,basis)))

      | check_shareq ((Absyn.TYPEshareq tyconlist,location)::shareqs,basis) =
	(debug ["check_shareq for types"];
	 Env.env_plus_env (check_type_share (tyconlist,basis,location),
			   check_shareq (shareqs,basis)))
	 
    and check_str_share (Ident.LONGSTRID (path,valid)::[],_,_) =
      (debug ["check_str_share 88"];
       Env.empty_env)

      | check_str_share ((lstrid as Ident.LONGSTRID (path,valid))::
			 (sharelist as ((lstrid' as Ident.LONGSTRID
					 (path',valid'))::shareqs)),
			  basis as Basis.BASIS (nameset,funenv,sigenv,env),
                         location) =
	(debug ["check_str_share 88a"];
	 let 
	   val str as STR (m,_) =  Env.lookup_longstrid (lstrid,env)
	     handle Env.Lookup_LongStrId =>
               report_error'
               (Info.FATAL, location,
                "unbound structure identifier " ^ 
                IdentPrint.printLongStrId lstrid)
	   val str' as STR (m',_) = Env.lookup_longstrid (lstrid',env)
	     handle Env.Lookup_LongStrId =>
               report_error'
               (Info.FATAL, location,
                "unbound structure identifier " ^
                IdentPrint.printLongStrId lstrid')
	 in
	   if (not (substr (str,str')) andalso (not (substr (str',str)))) then
	     let 
	       val (share_successful,sigstr_ass',sigty_ass') = 
		 Share.share_str (m,m',!sigstr_ass,!sigty_ass,nameset)
		 handle Share.ShareError s =>
                   (report_error
                    (Info.RECOVERABLE, location,
                     implode
                     ["failed to share structures ",
                      IdentPrint.printLongStrId lstrid, " and ",
                      IdentPrint.printLongStrId lstrid', ":\n  ", s]);
                    (false,!sigstr_ass,!sigty_ass))

	     in		  
	       if share_successful
		 then (sigstr_ass := sigstr_ass';
		       sigty_ass := sigty_ass';
		       check_str_share (sharelist,basis,location))
	       else
		 Env.empty_env
	     end
	   else
             (report_error
              (Info.RECOVERABLE, location,
               implode
               ["sharing ",
                IdentPrint.printLongStrId lstrid, " and ",
                IdentPrint.printLongStrId lstrid', " creates a cycle"]);
              Env.empty_env)
	 end)
    | check_str_share _ = Crash.impossible"check_str_share bad parameters"
d1327 1
a1327 5
    and check_type_share (Ident.LONGTYCON (path,tycon)::[],_,location) =
      (debug ["check_type_shareq 89"];
       Env.empty_env)

      | check_type_share ((ltycon as Ident.LONGTYCON (path,tycon))::
d1333 35
a1367 29
	 let 
	   val TYSTR (tyfun,_) = 
	     Basis.lookup_longtycon (ltycon,Basis.basis_to_context basis)
	     handle Basis.LookupLongTyCon =>
               report_error'
               (Info.FATAL, location,
                "unbound type constructor " ^ IdentPrint.printLongTyCon ltycon)
	   val TYSTR (tyfun',_) = 
	     Basis.lookup_longtycon (ltycon',Basis.basis_to_context basis)
	     handle Basis.LookupLongTyCon =>
               report_error'
               (Info.FATAL, location,
                "unbound type constructor "^ IdentPrint.printLongTyCon ltycon')
	   val (share_successful,sigty_ass') = 
	     Sharetypes.share_tyfun (tyfun,tyfun',!sigty_ass)
	     handle Sharetypes.ShareError s =>
               (report_error
                (Info.RECOVERABLE, location,
                 implode
                 [" failed to share types ",
                  IdentPrint.printLongTyCon ltycon, " and ",
                  IdentPrint.printLongTyCon ltycon', ": ", s]);
               (false,!sigty_ass))
	 in
	   if share_successful
	     then (sigty_ass := sigty_ass';
		   check_type_share (sharelist,basis,location))
	   else
	     Env.empty_env
d1369 1
a1369 2
      | check_type_share _ =
	Crash.impossible"check_type_share bad parameters"
d1389 3
a1391 13
	   val Sigma.SIGMA (names,str) = 
             (((check_sigexp_closed (sigexp,basis,location))
               handle WellFormed sigma => 
                 (report_error
                  (Info.RECOVERABLE, location,
                   "argument signature is not well-formed");
                  sigma))
              handle TypeExplicit sigma =>
                (report_error
                 (Info.RECOVERABLE, location,
                  "argument signature is not type-explicit");
                 sigma))
             handle RespectEquality sigma =>
d1394 12
a1405 3
                 "argument signature does not respect equality");
                sigma)

d1407 1
a1407 1
	   val str' = 
d1410 1
a1410 1
				       (strid,str,Strenv.empty_strenv),
d1416 1
a1416 1
			   (str',Nameset.empty_nameset ()),
d1425 1
a1425 1
	     Assemblies.subAssemblies (!str_ass, !ty_ass, str')
d1430 1
a1430 1
	   Funenv.add_to_funenv (funid,phi,
d1433 1
a1433 1
	 end)
d1441 1
a1441 1
	   val sigma as Sigma.SIGMA (names,str) =
d1445 16
a1460 16
             (((check_sigexp_closed (sigexp,basis,location))
               handle WellFormed sigma => 
                 (report_error
                  (Info.RECOVERABLE, location,
                   "argument signature is not well-formed");
                  sigma))
              handle TypeExplicit sigma =>
                (report_error
                 (Info.RECOVERABLE, location,
                  "argument signature is not type-explicit");
                 sigma))
             handle RespectEquality sigma =>
               (report_error
                (Info.RECOVERABLE, location,
                 "argument signature does not respect equality");
                sigma))
d1467 1
a1467 1
						     (strid,str,
d1472 1
a1472 1
	   val str' = Timer.xtime("check_strexp", !print_times,
d1474 1
a1474 2

	   val sigma' = 
d1482 1
a1482 1
                  sigma))
d1487 1
a1487 1
                 sigma))
d1492 1
a1492 1
                sigma))
d1494 4
a1497 5
	   val sigma'' as Sigma.SIGMA (_,str'') = Timer.xtime("sig_copy", !print_times,
								      fn () => Sigma.sig_copy sigma')
	   val (str_ass',ty_ass') = 
	     Timer.xtime("subAssemblies", !print_times,
			   fn () => Assemblies.subAssemblies(!str_ass, !ty_ass, str'))
d1503 1
a1503 1
                                     sigma'',str')
d1505 1
a1505 1
                             (report_error'
d1507 2
a1508 1
                              false))) then
d1512 1
a1512 1
				 (str',Nameset.empty_nameset ()),
d1514 5
a1518 3
		 val phi = 
		   Timer.xtime("PHI", !print_times,
				 fn () => Phi.PHI(names,(str,Sigma.SIGMA (names',str''))))
d1522 4
a1525 1
		 Funenv.add_to_funenv (funid,phi,
d1536 1
a1536 1
	 end)
d1574 1
a1574 1
	 if (Env.no_imptyvars new_env)
d1625 1
a1625 1
	   if (Basis.Funenv.no_imptyvars new_funenv)
a1640 1
  end
d1642 1
a1642 1

@


1.49
log
@Propagating options to signature matching error messages.
,
@
text
@d4 3
d200 2
a201 1
  sharing Core_rules.Basis.Sigenv.Sigma.Nameset.Info = Type_exp.Info = Realise.Info = IdentPrint.Info
d234 1
a234 1
    val print_times = ref true
d236 6
a243 2
    open Types.Datatypes

d348 1
a348 1
                  "Unbound structure identifier " ^ IdentPrint.printLongStrId longstrid)
d375 1
a375 1
                 (Info.FATAL, location, "Unbound functor identifier " ^ IdentPrint.printFunId funid)
d421 1
a421 1
                 implode ["The argument signature of ", IdentPrint.printFunId funid,
a501 14
             (*
              if Strenv.member_of_se_domain (strid,se)
	     then
	       let
		 val str' = Strenv.lookup (strid,se)
		 val (str_ass',ty_ass') = 
		   Assemblies.subAssemblies (!str_ass,!ty_ass,str')
	       in
		 (str_ass := str_ass';
		  ty_ass := ty_ass')
	       end
	   else
	     ();	
*)
d511 18
a528 1
	   val sigma = check_sigexp_closed (sigexp,basis,location)
d557 1
a557 1
               "Signature does not match structure " ^ IdentPrint.printStrId strid);
d604 1
a604 1
                  "Unbound signature identifier " ^ IdentPrint.printSigId sigid)
d641 2
a642 1
                         Sigma.SIGMA (Sigma.new_names_of (str,Nameset.empty_nameset ()),str))
d644 6
d651 9
a659 10
             (if Types.equalityp tyfun then
                if NewMap.forall eq_scheme amap then true
                else
                  (report_error
                   (Info.RECOVERABLE, location,
                    "Type structure does not respect equality");
                   false)
              else
                true)
                handle RespectEquality => false
d686 1
a686 1
           fun se_equality_principal(_, STR (_,env)) =
d690 2
a691 1
             te_equality_principal te andalso
d694 1
a694 2
           fun equality_principal (sigma as Sigma.SIGMA 
                                   (names,STR (_,env as ENV (SE amap,te,_,_)))) =
d702 3
a704 1
                     Crash.impossible ("Unbound structure identifier in mod_rules/crash " ^ IdentPrint.printStrId strid)
d729 1
a729 1
                
d747 2
a748 1
                      val name_copies' = te_type_explicit (names,tycons,name_copies)
d772 2
a773 1
           and env_type_explicit (names,ENV (SE amap,TE amap',_,_),name_copies) =
a807 40
         (*
          fun te_type_explicit (names,[]) = 
          (if do_debug then
             debug ["te_type_explicit ",
             "names in te_type_explicit = ",
             (Nameset.string_nameset options names)]
	    else ();
	    names)
	 | te_type_explicit (names,(tycon,TYSTR(tyfun,_)) :: tycons) =
	   (if do_debug then
	      debug ["te_type_explicit a ",
		     "tycon = ",
		     (IdentPrint.printTyCon tycon)]
	    else ();
	    if Types.null_tyfunp tyfun then
	      let
		val type_name = Types.name tyfun
		val new_names = te_type_explicit (names,tycons)
	      in
		if Nameset.member_of_tynames (type_name, names) then
		  Nameset.remove_tyname(type_name, new_names)
		else new_names
	      end
	    else te_type_explicit (names,tycons)
	      )
	    
	 fun se_type_explicit (names,[]) = 
	   (if do_debug then
	      debug ["se_type_explicit ",
		     "names in se_type_explicit = ",
		     (Nameset.string_nameset options names)]
	    else ();
	    names)
	 | se_type_explicit (names,(_,STR(_,env))::stridenvs) = 
	   (if do_debug then
	      debug  ["se_type_explicit a ",
		      "names in se_type_explicit a = ",
		      (Nameset.string_nameset options names)]
	    else ();
	      se_type_explicit (env_type_explicit (names,env),stridenvs))
a808 30
	 and env_type_explicit (names,ENV (SE amap,TE amap',_,_)) =
	   (if do_debug then
	      debug ["env_type_explicit ",
		     "names in env_type_explicit = ",
		     (Nameset.string_nameset options names)]
	    else ();
	    let
	      val strid_str_list = NewMap.to_list amap
	      val tycon_tystr_list = NewMap.to_list amap'
	      val names' = te_type_explicit (names,tycon_tystr_list)
	    in
	      if do_debug then
		debug ["env_type_explicit after te_type_explicit ",
		       "names in env_type_explicit = ",
		       (Nameset.string_nameset options names')]
	      else ();
	      se_type_explicit (names',strid_str_list)
	    end)

	 fun type_explicit (Sigma.SIGMA (names,STR (_,env))) =
	   (debug ["type_explicit"];
	    let val nameset = env_type_explicit (names,env)
	    in
	      if do_debug then
		debug ["nameset in type_explicit = ",
		       (Nameset.string_nameset options nameset)]
	      else ();
	      Nameset.no_tynames (nameset) 
	    end)
*)
d819 1
a819 4
               (report_error
                (Info.RECOVERABLE, location,
                 "Signature is not well-formed");
                sigma)
d821 1
a821 4
             (report_error
              (Info.RECOVERABLE, location,
                            "Signature is not type-explicit");
              sigma)
d823 1
a823 4
           (report_error
            (Info.RECOVERABLE, location,
             "Signature does not respect equality");
            sigma)
d843 20
a862 1
	     check_sigexp_closed (sigexp,basis,location)
d998 4
a1001 1
         let val env = Timer.xtime ("check_shareq", !print_times,fn () =>  check_shareq (shareqlist,basis))
d1024 1
a1024 1
                    "Unbound structure identifier " ^ 
d1035 1
a1035 1
                      "Unbound structure identifier " ^ 
d1049 1
a1049 1
      | check_spec (Absyn.INCLUDEspec(sigidlist,location),basis) =
d1059 1
a1059 1
                    "Unbound signature identifier " ^
d1071 1
a1071 1
                      "Unbound signature identifier " ^
d1189 6
a1194 1
                 Crash.impossible ("Unbound type constructor in check_datdesc " ^ IdentPrint.printTyCon tycon)
d1359 1
a1359 1
                "Unbound structure identifier " ^ 
d1365 1
a1365 1
                "Unbound structure identifier " ^
d1368 1
a1368 1
	   if (not (substr (str,str')) andalso (not ( substr (str',str)))) then
d1376 1
a1376 1
                     ["Failed to share structures ",
d1393 1
a1393 1
               ["Sharing ",
d1418 1
a1418 1
                "Unbound type constructor " ^ IdentPrint.printLongTyCon ltycon)
d1424 1
a1424 1
                "Unbound type constructor " ^ IdentPrint.printLongTyCon ltycon')
d1431 1
a1431 1
                 [" Failed to share types ",
d1464 17
a1480 1
             check_sigexp_closed (sigexp,basis,location)
d1517 20
a1536 2
	     Timer.xtime("check_sigexp_closed", !print_times,
			   fn () => check_sigexp_closed (sigexp,basis,location))
d1549 21
a1569 2
	   val sigma' = Timer.xtime("check_sigexp_closed", !print_times,
				      fn () => check_sigexp_closed(sigexp',new_basis,location))
d1604 1
a1604 1
               implode ["Functor body ", IdentPrint.printFunId funid,
d1653 1
a1653 1
             "Free imperative type variables at top level");
d1702 2
a1703 1
              (Info.RECOVERABLE, location, "Free imperative type variables at top level");
@


1.48
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d197 1
a197 1
  sharing Core_rules.Basis.Sigenv.Sigma.Nameset.Info = Type_exp.Info
d311 1
d389 1
a389 1
                (Realise.sigmatch (Basis.level(Basis.basis_to_context basis), sigma,str)
d528 1
a528 1
	   if (Realise.sigmatch (Basis.level (Basis.basis_to_context basis),
d1311 1
a1311 1
                          IdentPrint.debug_printValId excon,
d1557 2
a1558 2
                          (Realise.sigmatch (Basis.level (Basis.basis_to_context basis),
                                             sigma'',str')
@


1.47
log
@Changed error messages.
@
text
@d4 3
d145 1
d162 1
d166 1
d186 2
d195 1
a195 1
  sharing Env.Datatypes = Core_rules.Absyn.Interface.Datatypes =
d203 1
a203 2
  sharing Core_rules.Absyn = 
    Type_exp.Absyn
d207 1
a207 1
    Share.Nameset
d210 3
a212 2
  sharing IdentPrint.Ident = Types.Datatypes.Ident =
    Core_rules.Absyn.IdentClass
a218 3
    structure Set = Absyn.Set
    structure Interface = Absyn.Interface
    structure Nameset = Absyn.Nameset
d221 1
a221 1
    structure Phi = Basis.Funenv.Phi
@


1.46
log
@Error message revisions.
@
text
@d4 3
d1400 1
a1400 1
                      IdentPrint.printLongStrId lstrid', ": ", s]);
d1455 1
a1455 1
                  IdentPrint.printLongTyCon ltycon', " because they have ", s]);
@


1.45
log
@Changes to error messages.
@
text
@d4 3
d1452 1
a1452 1
                  IdentPrint.printLongTyCon ltycon', "because they have ", s]);
d1567 1
@


1.44
log
@Modified tyenv for efficiency
@
text
@d4 3
d1449 1
a1449 1
                  IdentPrint.printLongTyCon ltycon', ": ", s]);
@


1.43
log
@Modified to remove redundant info signatures
@
text
@d4 3
d955 1
a955 1
	       (if Tyenv.member_of_te_domain (tycon,te)
d962 1
a962 1
			       (tycon,
d972 1
a972 2
				 empty_valenv),
				te)))
d1176 1
a1176 1
	   if Tyenv.member_of_te_domain (tycon,Basis.te_of_context context)
d1182 2
a1183 2
	   Tyenv.add_to_te (tycon,TYSTR (tyfun,empty_valenv),
			    check_typdesc (typdescs,context,eq))
d1239 1
a1239 1
	  (ve,(Tyenv.add_to_te (tycon,TYSTR (tyfun,conenv),te))))
@


1.42
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
a145 1
require "../main/info";
d174 1
a174 1
  sharing Core_rules.Info = Type_exp.Info
d206 1
a206 1
    structure Info = Core_rules.Info
d287 2
a288 2
      val report_error = Core_rules.Info.error options
      val report_error' = Core_rules.Info.error' options
d318 1
a318 1
                 (Core_rules.Info.FATAL, location,
d346 1
a346 1
                 (Core_rules.Info.FATAL, location, "Unbound functor identifier " ^ IdentPrint.printFunId funid)
d371 1
a371 1
                    (Core_rules.Info.RECOVERABLE, location, s);
d391 1
a391 1
                (Core_rules.Info.RECOVERABLE, location,
d511 1
a511 1
                  (Core_rules.Info.RECOVERABLE, location, s);
d524 1
a524 1
              (Core_rules.Info.RECOVERABLE, location,
d571 1
a571 1
                 (Core_rules.Info.FATAL, location,
d616 1
a616 1
                   (Core_rules.Info.RECOVERABLE, location,
d848 1
a848 1
                (Core_rules.Info.RECOVERABLE, location,
d853 1
a853 1
              (Core_rules.Info.RECOVERABLE, location,
d858 1
a858 1
            (Core_rules.Info.RECOVERABLE, location,
d1039 1
a1039 1
                   (Core_rules.Info.FATAL, location,
d1050 1
a1050 1
                     (Core_rules.Info.FATAL, location,
d1074 1
a1074 1
                   (Core_rules.Info.FATAL, location,
d1086 1
a1086 1
                     (Core_rules.Info.FATAL, location,
d1289 1
a1289 1
                (Core_rules.Info.RECOVERABLE, location,
d1369 1
a1369 1
               (Core_rules.Info.FATAL, location,
d1375 1
a1375 1
               (Core_rules.Info.FATAL, location,
d1385 1
a1385 1
                    (Core_rules.Info.RECOVERABLE, location,
d1402 1
a1402 1
              (Core_rules.Info.RECOVERABLE, location,
d1428 1
a1428 1
               (Core_rules.Info.FATAL, location,
d1434 1
a1434 1
               (Core_rules.Info.FATAL, location,
d1440 1
a1440 1
                (Core_rules.Info.RECOVERABLE, location,
d1541 1
a1541 1
                              (Core_rules.Info.RECOVERABLE, location, s);
d1560 1
a1560 1
              (Core_rules.Info.RECOVERABLE, location,
d1609 1
a1609 1
            (Core_rules.Info.RECOVERABLE, location,
d1659 1
a1659 1
              (Core_rules.Info.RECOVERABLE, location, "Free imperative type variables at top level");
@


1.41
log
@Changed Error structure to Info
@
text
@d4 3
d141 1
a164 1
  structure Info       : INFO
d171 1
a171 2
  sharing Info = Core_rules.Info = Type_exp.Info
  sharing Core_rules.Absyn.Location = Info.Location
d203 1
a203 1
    structure Info = Info
d284 2
a285 2
      val report_error = Info.error options
      val report_error' = Info.error' options
d315 1
a315 1
                 (Info.FATAL, location,
d343 1
a343 1
                 (Info.FATAL, location, "Unbound functor identifier " ^ IdentPrint.printFunId funid)
d368 1
a368 1
                    (Info.RECOVERABLE, location, s);
d388 1
a388 1
                (Info.RECOVERABLE, location,
d496 1
a496 1
		debug ["sigma before copying :\n ",(Sigma.string_sigma sigma)]
d508 1
a508 1
                  (Info.RECOVERABLE, location, s);
d521 1
a521 1
              (Info.RECOVERABLE, location,
d568 1
a568 1
                 (Info.FATAL, location,
d613 1
a613 1
                   (Info.RECOVERABLE, location,
d678 2
a679 1
                debug ["names in well_formed = ",Nameset.string_nameset names]
d691 1
a691 1
                       (Nameset.string_nameset names)]
d716 1
a716 1
                       (Nameset.string_nameset names)]
d723 1
a723 1
                          (Nameset.string_nameset names)]
d732 1
a732 1
                       (Nameset.string_nameset names)]
d743 1
a743 1
                           (Nameset.string_nameset names)]
d755 1
a755 1
                         (Nameset.string_nameset names)]
d768 1
a768 1
             (Nameset.string_nameset names)]
d793 1
a793 1
		     (Nameset.string_nameset names)]
d800 1
a800 1
		      (Nameset.string_nameset names)]
d808 1
a808 1
		     (Nameset.string_nameset names)]
d818 1
a818 1
		       (Nameset.string_nameset names')]
d829 1
a829 1
		       (Nameset.string_nameset nameset)]
d845 1
a845 1
                (Info.RECOVERABLE, location,
d850 1
a850 1
              (Info.RECOVERABLE, location,
d855 1
a855 1
            (Info.RECOVERABLE, location,
d1036 1
a1036 1
                   (Info.FATAL, location,
d1047 1
a1047 1
                     (Info.FATAL, location,
d1071 1
a1071 1
                   (Info.FATAL, location,
d1083 1
a1083 1
                     (Info.FATAL, location,
d1286 1
a1286 1
                (Info.RECOVERABLE, location,
d1288 1
a1288 1
                          IdentPrint.printValId excon,
d1366 1
a1366 1
               (Info.FATAL, location,
d1372 1
a1372 1
               (Info.FATAL, location,
d1382 1
a1382 1
                    (Info.RECOVERABLE, location,
d1399 1
a1399 1
              (Info.RECOVERABLE, location,
d1425 1
a1425 1
               (Info.FATAL, location,
d1431 1
a1431 1
               (Info.FATAL, location,
d1437 1
a1437 1
                (Info.RECOVERABLE, location,
d1538 1
a1538 1
                              (Info.RECOVERABLE, location, s);
d1557 1
a1557 1
              (Info.RECOVERABLE, location,
d1606 1
a1606 1
            (Info.RECOVERABLE, location,
d1656 1
a1656 1
              (Info.RECOVERABLE, location, "Free imperative type variables at top level");
@


1.40
log
@Anel's changes for encapsulating assemblies
@
text
@d4 3
d138 1
a138 1
require "../main/error";
d161 1
a161 1
  structure Error      : ERROR
d168 2
a169 1
  sharing Core_rules.Absyn.Location = Error.Location
d201 1
a201 1
    structure Error = Error
d280 4
a283 1
    (* *** rule 53 *** *)
d285 1
a285 39
    fun check_strexp (Absyn.NEWstrexp strdec,basis) = 
      (debug ["check_strexp 53"];
       let 
	 val strname = STRNAME (Strname_id.make_strname_id ())
	 val env as ENV (se,te,_,_) = check_strdec (strdec,basis)
	 val type_offspring =
	   Assemblies.collectTypeOffspring (te,Assemblies.empty_type_offspring)
	 val str_offspring = 
	   Assemblies.collectStrOffspring (se,Assemblies.empty_str_offspring)
       in
	 (str_ass := Assemblies.add_to_StrAssembly
	  (strname,str_offspring,type_offspring,!str_ass);
	  STR (strname,env))
       end)
      
      (* *** rule 54 *** *)
      
      | check_strexp (Absyn.OLDstrexp (longstrid,location),basis) =
	(debug ["check_strexp 54"];
	 let 
	   val str as STR (m,ENV (se,te,_,_)) = 
	     Basis.lookup_longstrid (longstrid,basis)
	     handle Basis.LookupLongStrId =>
               Error.report'
               (Error.ERROR (Error.FATAL, location,
                             "Unbound structure identifier " ^ IdentPrint.printLongStrId longstrid))
	   val str_offs = Timer.xtime ("collectStrOffspring 54", !print_times, fn () => Assemblies.collectStrOffspring
	     (se,Assemblies.empty_str_offspring))
	   val ty_offs = Timer.xtime ("collectTypeOffspring 54", !print_times, fn () => Assemblies.collectTypeOffspring 
	     (te,Assemblies.empty_type_offspring))
	   val ty_ass' = Timer.xtime ("updateTypeAssembly 54", !print_times, fn () =>Assemblies.updateTypeAssembly (te,!ty_ass))
	 in
	   (str_ass := Assemblies.add_to_StrAssembly 
	    (m,str_offs,ty_offs,!str_ass);
	    ty_ass := ty_ass';
	    str)
	 end)
	
      (* *** rule 55 *** *)
d287 1
a287 13
      | check_strexp (Absyn.APPstrexp (funid,strexp,location),basis) =
	(debug ["check_strexp 55"];
	 let 
	   val str = Timer.xtime ("check_strexp 55", !print_times,fn () => check_strexp (strexp,basis) )
	   val (str_ass',ty_ass') = Timer.xtime ("subAssemblies 55", !print_times, fn () => Assemblies.subAssemblies (!str_ass,!ty_ass,
							      str))
	   val _ = str_ass := str_ass'
	   val _ = ty_ass := ty_ass'
	   val phi as Phi.PHI (names,(str'',Sigma.SIGMA (names',str'))) = 
	     Basis.lookup_funid (funid,basis)
	     handle Basis.LookupFunId => 
               Error.report'
               (Error.ERROR (Error.FATAL, location, "Unbound functor identifier " ^ IdentPrint.printFunId funid))
d289 35
a323 46
	   (****
	    We have to copy both the body and the argument of the functor 
	    before we match the argument signature to the actual argument.
	    This is necessary because sharing between the argument and result
	    specified in the declaration of the functor is represented by the 
	    occurrence of the same name in both the body and the argument.
	    This repeated occurrence is preserved by the realisation map,
	    yielding sharing between the argument structure and the result 
            structure of the functor application.
	    ****)

	   val Phi.PHI (newnames,(newstr'',
				  Sigma.SIGMA (newnames',newstr'))) =
	     Timer.xtime ("phi_copy 55", !print_times, fn () => Phi.phi_copy phi)
	   val sigma = Sigma.SIGMA (newnames,newstr'')
	   val STR (m,ENV (se,te,_,_)) = newstr' 
           val realise =
             Timer.xtime
             ("sigmatch 55", !print_times,
              fn () =>
              (Realise.sigmatch (Basis.level(Basis.basis_to_context basis), sigma,str)
	       handle Realise.RealiseError s =>
                 (Error.report
                  (Error.ERROR (Error.RECOVERABLE, location, s));
                  false)))
	 in
           if realise
	     then
	       let
		 val str_offs = Assemblies.collectStrOffspring
		   (se,Assemblies.empty_str_offspring)
		 val ty_offs = Assemblies.collectTypeOffspring 
		   (te,Assemblies.empty_type_offspring)
		 val ty_ass' = Assemblies.updateTypeAssembly (te,!ty_ass)
	       in
		 (str_ass := Assemblies.add_to_StrAssembly 
		  (m,str_offs,ty_offs,!str_ass);
		  ty_ass := ty_ass';

		  newstr')
	       end
	   else 
	     (Error.report
              (Error.ERROR (Error.RECOVERABLE, location,
                            implode ["The argument signature of ", IdentPrint.printFunId funid,
                                     " does not match the actual argument"]));
d325 145
a469 80
	 end)

      (* *** rule 56 *** *)

      | check_strexp (Absyn.LOCALstrexp (strdec,strexp),basis) =
	(debug ["check_strexp 56"];
	 let val new_env = check_strdec (strdec,basis)
	 in
	   check_strexp (strexp,Basis.basis_plus_env (basis,new_env))
	 end)
	 
    (* ****** Structure-level Declarations ****** *)
  
    (* *** rule 57 *** *)

    and check_strdec (Absyn.DECstrdec dec,basis) = 
      (debug ["check_strdec 57"];
       Core_rules.check_dec (dec,Basis.basis_to_context basis))
       
      (* *** rule 58 *** *)
      | check_strdec (Absyn.STRUCTUREstrdec strbindlist,basis) = 
	(debug ["check_strdec 58"];
	 Env.SE_in_env (check_strbinds (strbindlist, basis)))

      (* *** rule 59 *** *)

      | check_strdec (Absyn.LOCALstrdec (strdec1,strdec2),basis) = 
	(debug ["check_strdec 59"];
	 let val new_env = check_strdec (strdec1,basis)
	 in
	   check_strdec (strdec2, Basis.basis_plus_env (basis,new_env))
	 end)
      
      (* *** rules 60 and 61 *** *)
    
      | check_strdec (Absyn.SEQUENCEstrdec strdeclist,basis) = 
	(debug ["check_strdec 60 and 61"];
	 let 
	   fun check_strdec_seqs ([],_,env) = env
	     | check_strdec_seqs (astrdec::strdecs,basis,env) = 
	       let val new_env = check_strdec (astrdec,basis)
	       in
		 check_strdec_seqs (strdecs, 
				    Basis.basis_plus_env (basis,new_env),
				    Env.env_plus_env (env,new_env))
	       end
	 in
	   check_strdec_seqs (strdeclist,basis,Env.empty_env)
	 end)
      

    (* *** Structure Bindings *** *)

    (* *** rule 62 *** *)

    and check_strbinds ([],basis) = 
      (debug ["check_strbinds 62"];
       Strenv.empty_strenv)

      | check_strbinds ((strid,Absyn.ABSENT,strexp,_)::strbinds,
			basis as Basis.BASIS (_,_,_,ENV (se,_,_,_))) = 
	(debug ["check_strbinds 62a"];
	 let 
	   val str as STR (m,env) = check_strexp (strexp,basis)
	   val new_basis = Basis.basis_plus_names (basis,Sigma.names_of 
						   (str,
                                                    Nameset.empty_nameset()))
	   val se' = check_strbinds (strbinds,new_basis)
	   val _ =
	     let
	       val str' = Strenv.lookup (strid,se)
	       val (str_ass',ty_ass') = 
		 Assemblies.subAssemblies (!str_ass,!ty_ass,str')
	     in
	       (str_ass := str_ass';
		ty_ass := ty_ass')
	     end handle Strenv.Lookup_in_SE => ()
	 in
(*
	   if Strenv.member_of_se_domain (strid,se)
d505 2
a506 2
                 (Error.report
                  (Error.ERROR (Error.RECOVERABLE, location, s));
d518 3
a520 3
             (Error.report
              (Error.ERROR (Error.RECOVERABLE, location,
                            "Signature does not match structure " ^ IdentPrint.printStrId strid));
d528 2
a529 2
  and check_sigexp_open (Absyn.NEWsigexp (spec,intref),basis) = 
    (debug ["check_sigexp_open 63"];
d531 68
a598 68
     let
       val m = METASTRNAME (ref (NULLNAME (Strname_id.make_strname_id ())))
       val env as ENV (se,te,_,_) =
	 Timer.xtime("check_spec", !print_times,
		       fn () => check_spec (spec,basis))
       val type_offspring =
	 Timer.xtime("collectTypeOffspring", !print_times,
		       fn () => Assemblies.collectTypeOffspring (te,
					  Assemblies.findTypeOffspring 
					  (m,!sigstr_ass)))

       val _ = intref := Interface.inter env

     in
       sigstr_ass :=
       Timer.xtime("add_to_StrAssembly", !print_times,
		     fn () =>
		     Assemblies.add_to_StrAssembly
       (m,
	Assemblies.collectStrOffspring (se,
					Assemblies.findStrOffspring 
					(m,!sigstr_ass)),
	type_offspring,!sigstr_ass));
       
       STR (m,env)
     end)
	 
    (* *** rule 64 *** *)
	 
    | check_sigexp_open (Absyn.OLDsigexp (sigid,intref,location),basis) =
      (debug ["check_sigexp_open 64"];
       let
	 val Sigma.SIGMA (names,str) = Basis.lookup_sigid (sigid,basis)
	   handle Basis.LookupSigId => 
             Error.report'
             (Error.ERROR (Error.FATAL, location,
                           "Unbound signature identifier " ^ IdentPrint.printSigId sigid))
	 val (names',new_tynames,new_strnames) = 
	   Nameset.new_names_from_scratch names

	 (****
	  It is necessary to copy the signature because sharing is done 
	  destructively.
	  ****)
	 val (str' as STR (m,env)) = 
	   Env.str_copy (str,new_tynames,new_strnames)

	 val (sigstr_ass',sigty_ass') = Assemblies.newAssemblies (m,env)
	 val _ = intref := Interface.inter env
       in
	 (Timer.xtime
	  ("unionStrAssembly 64", !print_times,
	   fn () =>
	   sigstr_ass := Assemblies.unionStrAssembly(!sigstr_ass,sigstr_ass'));
	  Timer.xtime
	  ("unionTypeAssembly 64", !print_times,
	   fn () =>
	   sigty_ass := Assemblies.unionTypeAssembly(!sigty_ass,sigty_ass'));
	  str')
       end)

    (* *** rule 65 *** *)

    and check_sigexp_closed (sigexp,basis,location) =
      (debug ["check_sigexp_closed 65"];
       let 
	 val str =
	   Timer.xtime("check_sigexp_open", !print_times,
d600 3
a602 3

	 val sigma as (Sigma.SIGMA(nameset, _)) = 
	   Timer.xtime("new_names_of", !print_times,
d604 162
a765 126
	   Sigma.SIGMA (Sigma.new_names_of (str,Nameset.empty_nameset ()),str))

	 fun tystr_respect_equality (_, TYSTR (tyfun,VE (_,amap))) =
	   (if Types.equalityp tyfun then
	      if NewMap.forall eq_scheme amap then true
	      else
                (Error.report
                 (Error.ERROR (Error.RECOVERABLE, location,
                               "Type structure does not respect equality"));
                 false)
	    else
              true)
	    handle RespectEquality => false
	   
	 fun se_respect_equality(_, STR(_, env)) =
	   env_respect_equality (env)

	 and env_respect_equality (env as ENV (se as SE amap,
					       te as TE amap',_,_)) =
	   Env.empty_envp env orelse
	   (NewMap.forall se_respect_equality amap andalso
	    NewMap.forall tystr_respect_equality amap')
	   
	 fun respect_equality (Sigma.SIGMA (names,STR (_,env))) = 
	   env_respect_equality env
	   
	 fun max_eq_pred (_, TYSTR (atyfun,VE (_,amap))) =
	   if Types.equalityp atyfun then
	     if NewMap.forall eq_scheme amap then true
	     else Types.make_false atyfun
	   else
	     true

	 fun max_eq (TE amap) =
	   while not (NewMap.forall max_eq_pred amap) do ()

	 fun te_equality_principal te = 
	   (max_eq (te); true)
	 
	 fun se_equality_principal(_, STR (_,env)) =
	   env_equality_principal env
	   
	 and env_equality_principal (ENV (SE amap,te,_,_)) = 
	   te_equality_principal te andalso
	   NewMap.forall se_equality_principal amap
	 
	 fun equality_principal (sigma as Sigma.SIGMA 
				 (names,STR (_,env as ENV (SE amap,te,_,_)))) =
	   if env_equality_principal env then sigma else sigma
	    
	 fun check ([],_,_) = true
	 | check (strid::strids,names,env) = 
	   let
	     val STR (m,env') = Env.lookup_strid (strid,env)
	       handle Env.Lookup_StrId =>
                 Crash.impossible ("Unbound structure identifier in mod_rules/crash " ^ IdentPrint.printStrId strid)
	   in
	     if not (Nameset.member_of_strnames (m,names)) 
	       then
		 Nameset.nameset_eq 
		 (Nameset.intersection 
		  (names,
		   Sigma.names_of_env (env',
				       Nameset.empty_nameset ())),
		  Nameset.empty_nameset ())
		 andalso check (strids,names,env)
	     else true
	   end

	 fun well_formed (Sigma.SIGMA (names,
				       STR (_,env as ENV (SE amap,_,_,_)))) =
	   (if do_debug then
	      debug ["names in well_formed = ",Nameset.string_nameset names]
	    else ();
	    let 
	      val strids = NewMap.domain amap
	    in
	      check (strids,names,env)
	    end)
	  
	 fun te_type_explicit (names,[],name_copies) = 
	   (if do_debug then
	      debug ["te_type_explicit ",
		     "names in te_type_explicit = ",
		     (Nameset.string_nameset names)]
	    else ();
	    name_copies)
	 | te_type_explicit (names,(tycon,TYSTR(tyfun,_))::tycons,
                             name_copies) =
	   (if do_debug then
	      debug ["te_type_explicit a ",
		     "tycon = ",
		     (IdentPrint.printTyCon tycon)]
	    else ();
	    if Types.null_tyfunp tyfun then
	      let
		val type_name = Types.name tyfun
		val name_copies' = te_type_explicit (names,tycons,name_copies)
	      in
		if Nameset.member_of_tynames (type_name, names) then
		   type_name:: name_copies'
		else name_copies
	      end
	    else te_type_explicit (names,tycons,name_copies))
	    
	 fun se_type_explicit (names,[],name_copies) = 
	   (if do_debug then
	      debug ["se_type_explicit ",
		     "names in se_type_explicit = ",
		     (Nameset.string_nameset names)]
	    else ();
	    name_copies)
	 | se_type_explicit (names,(_,STR(_,env))::stridenvs,name_copies) = 
	   (if do_debug then
	      debug  ["se_type_explicit a ",
		      "names in se_type_explicit a = ",
		      (Nameset.string_nameset names)]
	    else ();
	      se_type_explicit (names,stridenvs,
                                env_type_explicit (names,env,name_copies)))

	 and env_type_explicit (names,ENV (SE amap,TE amap',_,_),name_copies) =
	   (if do_debug then
	      debug ["env_type_explicit ",
		     "names in env_type_explicit = ",
		     (Nameset.string_nameset names)]
a766 36
	    let
	      val strid_str_list = NewMap.to_list amap
	      val tycon_tystr_list = NewMap.to_list amap'
	      val name_copies' = te_type_explicit (names,tycon_tystr_list,
                                                   name_copies)
	    in
	      if do_debug then
		debug ["env_type_explicit after te_type_explicit ",
		       "names and copies in env_type_explicit = ",
		       (Nameset.string_nameset names)]
	      else ();
	      se_type_explicit (names,strid_str_list,name_copies')
	    end)

	 fun type_explicit (Sigma.SIGMA (names,STR (_,env))) =
	   (debug ["type_explicit"];
	    let 
              val name_copies = env_type_explicit (names,env,[])
	    in
	      if do_debug then
		debug ["nameset in type_explicit = ",
		       (Nameset.string_nameset names)]
	      else ();
	      Nameset.nameset_eq (Nameset.tynames_in_nameset 
                                  ((Nameset.tynames_of_nameset names),
                                   Nameset.empty_nameset ()),
                                  Nameset.tynames_in_nameset
                                  (name_copies,Nameset.empty_nameset ())) 
	    end)
(*
	 fun te_type_explicit (names,[]) = 
	   (if do_debug then
	      debug ["te_type_explicit ",
		     "names in te_type_explicit = ",
		     (Nameset.string_nameset names)]
	    else ();
d841 3
a843 3
               (Error.report
                (Error.ERROR (Error.RECOVERABLE, location,
                              "Signature is not well-formed"));
d846 3
a848 3
             (Error.report
              (Error.ERROR (Error.RECOVERABLE, location,
                            "Signature is not type-explicit"));
d851 3
a853 3
           (Error.report
            (Error.ERROR (Error.RECOVERABLE, location,
                          "Signature does not respect equality"));
d1032 4
a1035 4
                   Error.report'
                   (Error.ERROR (Error.FATAL, location,
                                 "Unbound structure identifier " ^ 
                                 IdentPrint.printLongStrId longstrid))
d1043 4
a1046 4
                     Error.report'
                     (Error.ERROR (Error.FATAL, location,
                                   "Unbound structure identifier " ^ 
                                   IdentPrint.printLongStrId longstrid))
d1067 4
a1070 4
                   Error.report'
                   (Error.ERROR (Error.FATAL, location,
                                 "Unbound signature identifier " ^
                                 IdentPrint.printSigId sigid))
d1079 4
a1082 4
                     Error.report'
                     (Error.ERROR (Error.FATAL, location,
                                   "Unbound signature identifier " ^
                                   IdentPrint.printSigId sigid))
d1141 1
a1141 1
	   val atype = Type_exp.check_type (ty,new_context)
d1202 1
a1202 1
				Type_exp.check_type 
d1254 1
a1254 1
	   val atype = Type_exp.check_type (aty,acontext)
d1282 5
a1286 5
               (Error.report
                (Error.ERROR (Error.RECOVERABLE, location,
                              implode ["Exception description of ",
                                       IdentPrint.printValId excon,
                                       " contains a type variable"]));
d1289 1
a1289 1
	       Type_exp.check_type (aty,context)
d1362 4
a1365 4
               Error.report'
               (Error.ERROR (Error.FATAL, location,
                             "Unbound structure identifier " ^ 
                             IdentPrint.printLongStrId lstrid))
d1368 4
a1371 4
               Error.report'
               (Error.ERROR (Error.FATAL, location,
                             "Unbound structure identifier " ^
                             IdentPrint.printLongStrId lstrid'))
d1378 6
a1383 6
                   (Error.report
                    (Error.ERROR (Error.RECOVERABLE, location,
                                  implode
                                  ["Failed to share structures ",
                                   IdentPrint.printLongStrId lstrid, " and ",
                                   IdentPrint.printLongStrId lstrid', ": ", s]));
d1395 6
a1400 6
             (Error.report
              (Error.ERROR (Error.RECOVERABLE, location,
                            implode
                            ["Sharing ",
                             IdentPrint.printLongStrId lstrid, " and ",
                             IdentPrint.printLongStrId lstrid', " creates a cycle"]));
d1421 3
a1423 3
               Error.report'
               (Error.ERROR (Error.FATAL, location,
                             "Unbound type constructor " ^ IdentPrint.printLongTyCon ltycon))
d1427 3
a1429 3
               Error.report'
               (Error.ERROR (Error.FATAL, location,
                             "Unbound type constructor " ^ IdentPrint.printLongTyCon ltycon'))
d1433 7
a1439 7
               (Error.report
                (Error.ERROR (Error.RECOVERABLE, location,
                              implode
                              [" Failed to share types ",
                               IdentPrint.printLongTyCon ltycon, " and ",
                               IdentPrint.printLongTyCon ltycon', ": ", s]));
                (false,!sigty_ass))
d1534 2
a1535 2
                             (Error.report'
                              (Error.ERROR (Error.RECOVERABLE, location, s));
d1553 4
a1556 4
             (Error.report
              (Error.ERROR (Error.RECOVERABLE, location,
                            implode ["Functor body ", IdentPrint.printFunId funid,
                                     " does not match result signature"]));
d1602 3
a1604 3
           (Error.report
            (Error.ERROR (Error.RECOVERABLE, location,
                          "Free imperative type variables at top level"));
d1652 2
a1653 2
             (Error.report
              (Error.ERROR (Error.RECOVERABLE, location, "Free imperative type variables at top level"));
d1659 3
@


1.39
log
@Added location information to the `require' topdec.
@
text
@d4 3
d243 11
d1610 2
d1630 5
@


1.38
log
@Added locations to errors
@
text
@d4 3
d1624 1
a1624 1
	| check_topdec (Absyn.REQUIREtopdec s,basis) = 
@


1.37
log
@Removed has_a_new_name, no longer needed
@
text
@d4 3
d278 1
a278 1
      | check_strexp (Absyn.OLDstrexp longstrid,basis) =
d285 1
a285 1
               (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN,
d532 1
a532 1
    | check_sigexp_open (Absyn.OLDsigexp (sigid,intref),basis) =
d538 1
a538 1
             (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN,
d631 1
a631 3
                 Error.report'
                 (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN,
                               "Unbound structure identifier " ^ IdentPrint.printStrId strid))
d997 1
a997 1
      | check_spec (Absyn.OPENspec longstridlist,basis) = 
d1005 1
a1005 1
                   (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN,
d1016 1
a1016 1
                     (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN,
d1031 1
a1031 1
      | check_spec (Absyn.INCLUDEspec sigidlist,basis) =
d1040 1
a1040 1
                   (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN,
d1052 1
a1052 1
                     (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN,
d1171 1
a1171 4
                 Error.report'
                 (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN,
                               "Unbound type constructor " ^
                               IdentPrint.printTyCon tycon))
@


1.36
log
@Installed central error reporting mechanism.
@
text
@d4 3
d669 1
a669 1
	    if Types.has_a_new_name tyfun then
d745 1
a745 1
	    if Types.has_a_new_name tyfun then
@


1.35
log
@Yet more changes to get structure copying working better.
@
text
@d4 3
d123 1
a123 1
require "../typechecker/errors";
d146 1
a146 1
  structure Errors     : ERRORS
d153 1
d164 1
a164 1
  sharing Core_rules.Basis = Type_exp.Basis = Errors.Basis
d185 1
d195 3
a203 5
	      
    fun error_announce (astring:string) = (Print.print "Type error : ";
					   Print.print astring;
					   Print.print "\n";
					   raise Errors.Stop_compilation)
d278 3
a280 2
	       error_announce ("unbound structure identifier " ^ 
			       (IdentPrint.printLongStrId longstrid) ^ "\n")
d295 1
a295 1
      | check_strexp (Absyn.APPstrexp (funid,strexp,marks),basis) =
d306 2
a307 3
	       error_announce (Absyn.Source_marks_to_string marks ^ 
                               " unbound functor identifier " ^ 
			       (IdentPrint.printFunId funid) ^ "\n")
d325 9
a333 5
           val realise = Timer.xtime ("sigmatch 55", !print_times, fn () => (Realise.sigmatch(Basis.level(Basis.basis_to_context basis),
				sigma,str)
	       handle Realise.RealiseError s => (error_announce s;
						 false)))

a334 4
(*	   if (Realise.sigmatch(Basis.level(Basis.basis_to_context basis),
				sigma,str) 
	       handle Realise.RealiseError s => (error_announce s;
						 false))*)
d351 5
a355 5
	     Errors.announce_error (Basis.basis_to_context basis) 
	     (Errors.return_val str)
	     [Absyn.Source_marks_to_string marks,
              " The argument signature of ",(IdentPrint.printFunId funid),
	      " does not match the actual argument\n"]
d451 1
a451 1
      | check_strbinds ((strid,Absyn.PRESENT sigexp,strexp,marks)::strbinds,
d457 1
a457 1
	   val sigma = check_sigexp_closed (sigexp,basis,marks)
d470 4
a473 3
	       handle Realise.RealiseError s => (error_announce s;
						 false))
	     then
d484 4
a487 5
	     Errors.announce_error (Basis.basis_to_context basis) 
	     (Errors.return_val Strenv.empty_strenv)
	     [Absyn.Source_marks_to_string marks,
              " Signature does not match structure ",
	      (IdentPrint.printStrId strid),"\n"]
d531 3
a533 2
	     error_announce ("unbound signature identifier " ^
			     (IdentPrint.printSigId sigid) ^ "\n")
d560 1
a560 1
    and check_sigexp_closed (sigexp,basis,marks) =
d575 8
a582 7
	      else 
		Errors.announce_error (Basis.basis_to_context basis)
		(Errors.return_val false)
		[Absyn.Source_marks_to_string marks,
		 " Type structure does not respect equality\n"]
	    else true)
	      handle RespectEquality => false
d624 4
a627 3
	       handle Env.Lookup_StrId => 
		 error_announce ("unbound structure identifier " ^
				 (IdentPrint.printStrId strid) ^ "\n")
d809 4
a812 4
	       Errors.announce_error (Basis.basis_to_context basis)
	       (Errors.return_val sigma)
	       [Absyn.Source_marks_to_string marks,
                "Signature is not well_formed\n"]
d814 4
a817 4
	     Errors.announce_error (Basis.basis_to_context basis)
	     (Errors.return_val sigma)
	     [Absyn.Source_marks_to_string marks,
              " Signature is not type-explicit\n"]
d819 4
a822 4
	   Errors.announce_error (Basis.basis_to_context basis)
	   (Errors.return_val sigma)
	   [Absyn.Source_marks_to_string marks,
            " Signature does not respect equality\n"]
d837 1
a837 1
      | check_sigbind (Absyn.SIGBIND ((sigid,sigexp,marks)::sigbinds),basis,
d842 1
a842 1
	     check_sigexp_closed (sigexp,basis,marks)
d999 5
a1003 3
		 handle Basis.LookupLongStrId => 
		   error_announce ("unbound structure identifier " ^ 
				   (IdentPrint.printLongStrId longstrid) ^"\n")
d1010 5
a1014 4
		   handle Basis.LookupLongStrId => 
		     error_announce ("unbound structure identifier " ^ 
				     (IdentPrint.printLongStrId longstrid) ^
				     "\n")
d1034 5
a1038 3
		 handle Basis.LookupSigId => 
		   error_announce ("unbound signature identifier " ^
				   (IdentPrint.printSigId sigid) ^ "\n")
d1046 5
a1050 3
		   handle Basis.LookupSigId => 
		     error_announce ("unbound signature identifier " ^
				     (IdentPrint.printSigId sigid) ^ "\n")
d1166 5
a1170 3
	       handle Basis.LookupTyCon => 
		 error_announce ("unbound type constructor " ^ 
				 (IdentPrint.printTyCon tycon) ^ "\n")
d1243 1
a1243 1
      | check_exdesc ((excon,Absyn.ABSENT,marks)::exdescs,context) =
d1248 1
a1248 1
      | check_exdesc ((excon,Absyn.PRESENT aty,marks)::exdescs,context) =
d1252 7
a1258 7
	     if Absyn.has_tyvar (aty)
	       then 
		 Errors.announce_error context 
		 Errors.return_alpha
		 [Absyn.Source_marks_to_string marks,
                  " Exception description of ",IdentPrint.printValId excon,
		  " contains a type variable\n"]
d1310 1
a1310 1
     | check_shareq ((Absyn.STRUCTUREshareq stridlist,marks)::shareqs,basis) =
d1312 1
a1312 1
	Env.env_plus_env (check_str_share (stridlist,basis,marks),
d1315 1
a1315 1
      | check_shareq ((Absyn.TYPEshareq tyconlist,marks)::shareqs,basis) =
d1317 1
a1317 1
	 Env.env_plus_env (check_type_share (tyconlist,basis,marks),
d1328 1
a1328 1
                         marks) =
d1333 4
a1336 3
	       error_announce (Absyn.Source_marks_to_string marks ^
                               " unbound structure identifier " ^ 
			       (IdentPrint.printLongStrId lstrid) ^ "\n")
d1338 5
a1342 4
	     handle Env.Lookup_LongStrId => 
	       error_announce (Absyn.Source_marks_to_string marks ^
                               " unbound structure identifier " ^ 
			       (IdentPrint.printLongStrId lstrid') ^ "\n")
d1349 8
a1356 7
		   Errors.announce_error (Basis.basis_to_context basis)
		   (Errors.return_val (false,!sigstr_ass,!sigty_ass))
		   [Absyn.Source_marks_to_string marks,
                    " Failed to share structures ",
		    IdentPrint.printLongStrId lstrid, " and ",
		    IdentPrint.printLongStrId lstrid', "\n",
		    "\nReason : ",s]
d1361 1
a1361 1
		       check_str_share (sharelist,basis,marks))
d1366 7
a1372 5
	     Errors.announce_error (Basis.basis_to_context basis)
	     (Errors.return_val Env.empty_env)
	     [Absyn.Source_marks_to_string marks,
              " Sharing ",IdentPrint.printLongStrId lstrid, " and ",
	      IdentPrint.printLongStrId lstrid'," creates a cycle\n"]
d1378 1
a1378 1
    and check_type_share (Ident.LONGTYCON (path,tycon)::[],_,marks) =
d1386 1
a1386 1
                          marks) =
d1391 4
a1394 4
	     handle Basis.LookupLongTyCon => 
	       error_announce (Absyn.Source_marks_to_string marks ^
                               " unbound type constructor " ^ 
			       (IdentPrint.printLongTyCon ltycon) ^ "\n")
d1397 4
a1400 4
	     handle Basis.LookupLongTyCon => 
	       error_announce (Absyn.Source_marks_to_string marks ^
                               " unbound type constructor " ^
			       (IdentPrint.printLongTyCon ltycon') ^ "\n")
d1404 7
a1410 7
	       Errors.announce_error (Basis.basis_to_context basis)
	       (Errors.return_val (false,!sigty_ass))
	       [Absyn.Source_marks_to_string marks,
                " Failed to share types ",
		(IdentPrint.printLongTyCon ltycon), " and ",
		(IdentPrint.printLongTyCon ltycon'),
		" because they ",s]
d1414 1
a1414 1
		   check_type_share (sharelist,basis,marks))
d1435 1
a1435 1
                         marks):: funbinds),
d1440 1
a1440 1
             check_sigexp_closed (sigexp,basis,marks)
d1472 1
a1472 1
                                       marks) :: funbinds),
d1478 1
a1478 1
			   fn () => check_sigexp_closed (sigexp,basis,marks))
d1492 1
a1492 1
				      fn () => check_sigexp_closed(sigexp',new_basis,marks))
d1499 9
a1507 6
	   if Timer.xtime("sigmatch", !print_times,
			    fn () => (Realise.sigmatch (Basis.level (Basis.basis_to_context basis),
				 sigma'',str')
	       handle Realise.RealiseError s => (error_announce s;
						 false)))
	     then
d1524 5
a1528 5
	     Errors.announce_error (Basis.basis_to_context basis)
	     (Errors.return_val funenv)
	     [Absyn.Source_marks_to_string marks,
              "Functor body ",(IdentPrint.printFunId funid),
	      " does not match result signature\n"]
d1560 1
a1560 1
    fun in_check_topdec (Absyn.STRDECtopdec (strdec,marks),basis) = 
d1573 4
a1576 4
	   Errors.announce_error (Basis.basis_to_context basis)
	   (Errors.return_val basis)
	   [Absyn.Source_marks_to_string marks,
            " Free imperative type variables at top level\n"]
d1581 1
a1581 1
      | in_check_topdec (Absyn.SIGNATUREtopdec sigbindlist,basis) = 
d1604 1
a1604 1
      | in_check_topdec (Absyn.FUNCTORtopdec (funbindlist,marks),basis) = 
d1616 3
a1618 4
	     Errors.announce_error (Basis.basis_to_context basis)
	     (Errors.return_val basis)
	     [Absyn.Source_marks_to_string marks,
              " Free imperative type variables at top level\n"]
d1620 1
a1620 1
	| in_check_topdec (Absyn.REQUIREtopdec s,basis) = 
a1622 12

    exception Check_topdec of int

    fun check_topdec (topdec,basis) =
      let
	val _ = Errors.reset_error_count ()
	val basis' = in_check_topdec (topdec,basis)
      in
	case Errors.error_count () of
	  0 => basis'
	| n => raise (Check_topdec n)
      end
@


1.34
log
@fixed bug in type_explicit.
@
text
@d4 3
d537 2
a538 3
	 val (str' as STR (m,env),new_tynames',new_strnames') = 
	   Env.str_copy (str,new_tynames,new_strnames,Strnames.new_metastrname,
			 Types.new_metatyname)
@


1.33
log
@Made some changes to the NewMap signature.
@
text
@d4 3
d644 77
d790 1
@


1.32
log
@Removed redundant arguments to Assemblies.newAssemblies.
@
text
@d4 3
d180 2
d230 1
a230 1
          (fn (STR (m,ENV (se',_,_,_))) => 
d563 1
a563 1
	 fun tystr_respect_equality (TYSTR (tyfun,VE (_,amap))) =
d565 1
a565 2
	      if NewMap.forall Scheme.equalityp amap
		then true
d574 1
a574 1
	 fun se_respect_equality(STR(_, env)) =
d580 1
a580 2
	   (NewMap.forall se_respect_equality amap
	    andalso
d586 6
a591 10
	 fun max_eq_pred (TYSTR (atyfun,VE (_,amap))) =
	   if Types.equalityp atyfun
	     then
	       if NewMap.forall Scheme.equalityp amap
		 then
		   true
	       else 
		 Types.make_false atyfun
	    else
	      true
d594 1
a594 2
	   while not (NewMap.forall max_eq_pred amap)
	     do ()
d599 1
a599 1
	 fun se_equality_principal(STR (_,env)) =
d603 1
a603 2
	   te_equality_principal te
	   andalso
d855 1
a855 1
                    (fn (TYSTR (atyfun,VE (_,amap')))
d858 1
a858 1
			 NewMap.forall Scheme.equalityp amap' orelse
@


1.31
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d530 1
a530 5
	 val (sigstr_ass',sigty_ass') = 
	   Assemblies.newAssemblies (m,env,
				     Assemblies.empty_strassembly(),
				     Assemblies.empty_tyassembly)

a531 1

d761 1
a761 4
		 val (sigstr_ass',sigty_ass') = 
		   Assemblies.newAssemblies (m,env,
					     Assemblies.empty_strassembly (),
					     Assemblies.empty_tyassembly)
@


1.30
log
@removed type_eq_matters from calls to sigmatch
@
text
@d4 3
d87 1
a89 1
require "../utils/set";
d92 1
a92 2
require "../utils/integer";
require "../basics/absyn";
a93 1
require "../typechecker/datatypes";
a101 6
require "../typechecker/nameset";
require "../typechecker/sigma";
require "../typechecker/sigenv";
require "../typechecker/phi";
require "../typechecker/funenv";
require "../typechecker/basis";
a104 1
require "../typechecker/assemblies";
a107 1
require "../typechecker/interface";
a112 2
  structure Integer    : INTEGER
  structure Set        : SET
d115 1
a115 1
  structure Absyn      : ABSYN
a116 1
  structure Datatypes  : DATATYPES
a124 6
  structure Nameset    : NAMESET
  structure Sigma      : SIGMA
  structure Sigenv     : SIGENV
  structure Phi        : PHI
  structure Funenv     : FUNENV
  structure Basis      : BASIS
a127 1
  structure Assemblies : ASSEMBLIES
a130 1
  structure Interface  : INTERFACE
d137 1
a137 6
  sharing Datatypes      = Realise.Datatypes =
    Core_rules.Datatypes = Type_exp.Datatypes =
    Absyn.Datatypes      = Basis.Datatypes =
    Funenv.Datatypes     = Phi.Datatypes =
    Sigenv.Datatypes     = Sigma.Datatypes =
    Nameset.Datatypes    = Env.Datatypes =
d141 5
a145 7
    Assemblies.Datatypes = Share.Datatypes = 
    Sharetypes.Datatypes = Errors.Datatypes =
    Interface.Datatypes  = Strenv.Datatypes
  sharing Sigma = Realise.Sigma =
    Basis.Sigma = Phi.Sigma = 
    Sigenv.Sigma
  sharing Absyn = Core_rules.Absyn = 
d147 5
a151 13
  sharing Basis    = Core_rules.Basis = 
    Type_exp.Basis = Errors.Basis
  sharing Set = Absyn.Set = 
    Basis.Set = Scheme.Set
  sharing Phi = Basis.Phi = 
    Funenv.Phi
  sharing Sigenv = Basis.Sigenv
  sharing Funenv = Basis.Funenv
  sharing Nameset  = Basis.Nameset = 
    Funenv.Nameset = Phi.Nameset = 
    Sigma.Nameset  = Share.Nameset
    = Absyn.Nameset
  sharing Assemblies      = Share.Assemblies = 
d153 2
a154 2
  sharing Interface = Absyn.Interface
  sharing Env.NewMap = Nameset.NewMap
d158 10
a167 3
    structure Absyn = Absyn
    structure Basis = Basis
    structure Assemblies = Assemblies
d173 1
a173 1
    open Datatypes
d220 1
a220 1
	  Lists.forall 
d223 1
a223 1
          (NewMap.range amap)
d406 11
a416 1
	 in 
d429 1
d455 8
a462 13
	       (if Strenv.member_of_se_domain (strid,se)
		  then
		    let
		      val str' = Strenv.lookup (strid,se)
		      val (str_ass',ty_ass') = 
			Assemblies.subAssemblies (!str_ass,!ty_ass,str')
		    in
		      (str_ass := str_ass';
		       ty_ass := ty_ass')
		    end
		else
		  ();

d559 11
a569 60
(*	 val nameset' =
	   Timer.xtime("new_names_of'", !print_times,
			 fn () =>
	   NewSigma.new_names_of
		       (str, NewSigma.Nameset.nameset_of_name_lists([], [])))
	 val tl = Nameset.tynames_of_nameset nameset
	 val sl = Nameset.strnames_of_nameset nameset
	 val _ = Print.print
	   ("Number of new tynames in nameset = " ^
	    Integer.makestring(Lists.length tl) ^
	    "\nNumber of strnames in nameset = " ^
	    Integer.makestring(Lists.length sl) ^ "\n")
	 val tl' = NewSigma.Nameset.tynames_of_nameset nameset'
	 val sl' = NewSigma.Nameset.strnames_of_nameset nameset'
	 val _ = Print.print
	   ("Number of new tynames in nameset' = " ^
	    Integer.makestring(Lists.length tl') ^
	    "\nNumber of strnames in nameset' = " ^
	    Integer.makestring(Lists.length sl') ^ "\n")
	 val nameset' = Nameset.nameset_of_name_lists(tl', sl')
	 val _ =
	   Print.print
	   (if Nameset.nameset_eq(nameset, nameset') then
	      "Namesets equal\n"
	    else
	      "Namesets unequal (boo hoo!)\n")

	 val sigma as (Sigma.SIGMA(nameset, _)) = 
	   Timer.xtime
	   ("new_names_of", !print_times,
	    fn () =>
	    let
	      val nameset =
		NewSigma.new_names_of
		(str, NewSigma.Nameset.nameset_of_name_lists([], []))
	      val tl' = NewSigma.Nameset.tynames_of_nameset nameset
	      val sl' = NewSigma.Nameset.strnames_of_nameset nameset
	    in
	      Sigma.SIGMA(Nameset.nameset_of_name_lists(tl', sl'), str)
	    end)
*)
	 fun te_respect_equality ([]) = true
	   | te_respect_equality ((tycon,tystr)::tycons) = 
	     let 
	       fun tystr_respect_equality (TYSTR (tyfun,VE (_,amap))) =
		 if Types.equalityp tyfun 
		   then
		     if Lists.forall Scheme.equalityp (NewMap.range amap)
		       then true
		     else 
		       Errors.announce_error (Basis.basis_to_context basis)
		       (Errors.return_val false)
		       [Absyn.Source_marks_to_string marks,
                        " Type structure does not respect equality\n"]
		 else true
	     in
	       (tystr_respect_equality (tystr) handle RespectEquality => false)
		 andalso 
		 te_respect_equality (tycons)
	     end
d571 2
a572 5
	 fun se_respect_equality ([]) = true
	   | se_respect_equality ((_,STR(_, env))::strids) = 
	     env_respect_equality (env) 
	     andalso
	     se_respect_equality (strids)
d576 4
a579 10
	   if Env.empty_envp env then true
	   else
	     let
	       val strid_str_list = NewMap.to_list amap
	       val tycon_tystr_list = NewMap.to_list amap'
	     in
	       se_respect_equality (strid_str_list)
	       andalso
	       te_respect_equality (tycon_tystr_list)
	     end
d587 1
a587 1
	       if Lists.forall Scheme.equalityp (NewMap.range amap)
d596 1
a596 1
	   while not (Lists.forall max_eq_pred (NewMap.range amap))
d602 2
a603 5
	 fun se_equality_principal ([]) = true
	   | se_equality_principal ((strid, STR (_,env))::strids) =
	     env_equality_principal (env)
	     andalso 
	     se_equality_principal (strids)
d605 4
a608 8
	 and env_equality_principal (ENV (se as SE amap,te,_,_)) = 
	   let
	     val strid_str_list = NewMap.to_list amap
	   in
	     te_equality_principal (te)
	     andalso
	     se_equality_principal (strid_str_list)
	   end
d667 2
a668 2
	      else te_type_explicit (names,tycons)
		)
d861 1
a861 1
	       not (Lists.forall 
d863 7
a869 12
                       =>
		         (if Types.equalityp atyfun
			    then
			      if (Lists.forall Scheme.equalityp 
                                  (NewMap.range amap'))
			        then
				  true
			      else 
			        Types.make_false atyfun
			  else
			    true))
                    (NewMap.range amap))
a1186 12
(*
	 let 
	   val str = check_sigexp_open (sigexp,basis)
	 in 
	   if Strenv.member_of_se_domain (strid,se)
	     then
	       shadowing_occurred := true
	   else ();

	   Strenv.add_to_se (strid,str,check_strdesc (strdescs,basis))
	 end
*)
@


1.29
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d334 1
a334 1
				sigma,str, false)
d340 1
a340 1
				sigma,str, false) 
d466 1
a466 1
				 sigma',str,true) 
d1507 1
a1507 1
				 sigma'',str',true)
@


1.28
log
@Removed various redundant structure arguments. Tidied up check_shareq function.
@
text
@d83 1
d87 1
d89 1
d98 6
d107 1
d111 1
d114 1
a114 1
functor Module_rules(
d118 1
d121 1
d123 1
d132 6
a137 1
(*  structure NewSigma   : NEWSIGMA*)
d141 1
d145 1
d151 2
a152 1
  sharing Realise.Datatypes =
d154 31
a184 11
    Env.Datatypes = Strnames.Datatypes = Tyenv.Datatypes = Tystr.Datatypes =
    Valenv.Datatypes = Scheme.Datatypes = Types.Datatypes = Share.Datatypes = 
    Sharetypes.Datatypes = Errors.Datatypes = Strenv.Datatypes
    (* = NewSigma.Datatypes = NewSigma.Nameset.Datatypes *)
  sharing Realise.Sigma = Core_rules.Basis.Sigma
  sharing Core_rules.Basis.Set = Scheme.Set
  sharing Core_rules.Absyn = Type_exp.Absyn
  sharing Core_rules.Basis.Nameset = Share.Nameset
  sharing Core_rules.Basis = Type_exp.Basis = Errors.Basis
  sharing Share.Assemblies = Sharetypes.Assemblies = Core_rules.Assemblies
  sharing Env.NewMap = Core_rules.Basis.Nameset.NewMap
d188 3
a190 10
    structure Absyn = Core_rules.Absyn
    structure Basis = Core_rules.Basis
    structure Assemblies = Core_rules.Assemblies
    structure Set = Basis.Set
    structure Phi = Basis.Phi
    structure Sigma = Basis.Sigma
    structure Funenv = Basis.Funenv
    structure Sigenv = Basis.Sigenv
    structure Nameset = Basis.Nameset
    structure Interface = Absyn.Interface
d193 1
a194 1
    open Core_rules.Datatypes
d196 2
d211 1
a211 1
    val str_ass = ref(Assemblies.empty_strassembly())
d228 1
a228 1
	val _ = str_ass := Assemblies.empty_strassembly()
d230 1
a230 1
	val _ = sigstr_ass := Assemblies.empty_strassembly()
d240 1
a240 1
	if Mapping.emptymap_p amap
d243 4
a246 3
	  Mapping.forall (amap,fn (STR (m,ENV (se',_,_,_))) => 
			  m = name orelse proper_substr (str,se'))

d418 1
a418 1
       Strenv.empty_se)
d430 1
a430 1
	   if Env.member_of_se_domain (strid,se)
d433 1
a433 1
		 val str' = Env.lookup_strid_in_SE (strid,se)
d441 2
a442 2
	     ();
	     Env.add_to_se (strid,str,se')
d467 1
a467 2
	       
	       (if Env.member_of_se_domain (strid,se)
d470 1
a470 1
		      val str' = Env.lookup_strid_in_SE (strid,se)
d480 1
a480 1
		  Env.add_to_se (strid,str',se'))
d483 1
a483 1
	     (Errors.return_val Strenv.empty_se)
d620 1
a620 1
	       fun tystr_respect_equality (TYSTR (tyfun,VE (_,conenv))) =
d623 1
a623 1
		     if Mapping.forall (conenv,Scheme.equalityp)
d648 2
a649 2
	       val stridlist = Mapping.assoc amap
	       val tyconlist = Mapping.assoc amap'
d651 1
a651 1
	       se_respect_equality (stridlist)
d653 1
a653 1
	       te_respect_equality (tyconlist)
d659 1
a659 1
	 fun max_eq_pred(TYSTR (atyfun,VE (_,aconenv))) =
d662 1
a662 3
	       if Mapping.forall
		 (aconenv,
		  Scheme.equalityp)
d671 2
a672 5
	   while 
	     not (Mapping.forall
		  (amap, max_eq_pred))
	     do
	     ()
d685 1
a685 1
	     val stridlist = Mapping.assoc amap
d689 1
a689 1
	     se_equality_principal (stridlist)
d693 1
a693 1
				 (names,STR (_,env as ENV (SE amap,te,_,_)))) = 
d716 2
a717 2
	 fun well_formed(Sigma.SIGMA(names,
				     STR(_, env as ENV (SE amap,_,_,_))))=
d722 1
a722 1
	      val strids = Mapping.domain amap
d765 1
a765 2
	      se_type_explicit (env_type_explicit (names,env),stridenvs)
	      )
d767 1
a767 1
	 and env_type_explicit (names,ENV (se as SE amap,te as TE amap',_,_)) =
d774 3
a776 3
	      val stridlist = Mapping.assoc amap
	      val tyconlist = Mapping.assoc amap'
	      val names' = te_type_explicit (names,tyconlist)
d783 2
a784 3
	      se_type_explicit (names',stridlist)
	    end
	  )
d795 1
a795 2
	    end
	  )
d834 2
a835 1
      | check_sigbind (Absyn.SIGBIND ((sigid,sigexp,marks)::sigbinds),basis,sigenv) =
d846 1
a846 1
					     Assemblies.empty_strassembly(),
d930 2
a931 2
					      ref Valenv.empty_valenv)),
				 Valenv.empty_valenv),
d938 1
a938 1
	     check_datdesc (datdesclist,new_context,(Valenv.empty_valenv,
d943 14
a956 16
	       not (Mapping.forall
		    (amap,
		     fn (TYSTR
			 (atyfun,VE (_,aconenv)))
		     =>
		       (if Types.equalityp atyfun
			  then
			    if Mapping.forall
			      (aconenv,
			       Scheme.equalityp)
			      then
				true
			    else 
			      Types.make_false atyfun
			else
			  true)))
d984 4
a987 2
         Timer.xtime ("check_shareq", !print_times,fn () =>  check_shareq (shareqlist,basis));
	 Env.empty_env)
d1081 1
a1081 2
	end
)
d1097 1
a1097 1
       Valenv.empty_valenv)
d1132 1
a1132 1
			  ref Valenv.empty_valenv))
d1140 1
a1140 1
	   Tyenv.add_to_te (tycon,TYSTR (tyfun,Valenv.empty_valenv),
d1181 1
a1181 1
					 Valenv.empty_valenv,
d1200 1
a1200 2
       end
	  )
d1237 1
a1237 1
       Valenv.empty_valenv)
d1269 1
a1269 1
       Strenv.empty_se)
d1278 1
a1278 1
	   if Env.member_of_se_domain (strid,se)
d1283 1
a1283 1
	   Env.add_to_se (strid,str,check_strdesc (strdescs,basis))
d1290 3
a1292 4
	  (fn (x, (strid, str)) => Env.add_to_se(strid, str, x))
	  (Strenv.empty_se, se_list)
	end
)
d1300 1
a1300 1
	    if Env.member_of_se_domain (strid,se) then
d1315 2
a1316 1
        debug ["check_shareq  for []"]
d1318 4
a1321 4
      | check_shareq ((Absyn.STRUCTUREshareq stridlist,marks)::shareqs,basis) =
	(debug ["check_shareq for structures"];
	 check_str_share (stridlist,basis,marks);
	 check_shareq (shareqs,basis))
d1325 2
a1326 2
	 check_type_share (tyconlist,basis,marks);
	 check_shareq (shareqs,basis))
d1329 2
a1330 1
        debug ["check_str_share 88"]
d1335 2
a1336 1
			  basis as Basis.BASIS (nameset,funenv,sigenv,env),marks) =
d1363 4
a1366 4
	       if share_successful then
		 (sigstr_ass := sigstr_ass';
		  sigty_ass := sigty_ass';
		  check_str_share (sharelist,basis,marks))
d1368 1
a1368 1
		 ()
d1372 1
a1372 1
	     (Errors.return_val ())
d1382 2
a1383 1
        debug ["check_type_shareq 89"]
d1388 2
a1389 1
			  basis as Basis.BASIS (nameset,funenv,sigenv,env),marks) =
d1415 3
a1417 3
	   if share_successful then
	     (sigty_ass := sigty_ass';
	      check_type_share (sharelist,basis,marks))
d1419 1
a1419 1
	     ()
d1437 2
a1438 2
		       ((funid,strid,sigexp,namesetref,strexp,Absyn.ABSENT,_,marks)
				      :: funbinds),
d1442 2
a1443 1
	   val Sigma.SIGMA (names,str) = check_sigexp_closed (sigexp,basis,marks)
d1447 2
a1448 2
			   (basis,ENV (Env.add_to_se 
				       (strid,str,Strenv.empty_se),
d1450 2
a1451 2
				       Valenv.empty_valenv,
				       Valenv.empty_valenv)))
d1474 2
a1475 1
				       Absyn.PRESENT sigexp',_,marks) :: funbinds),
d1486 1
a1486 1
						 ENV(Env.add_to_se
d1488 1
a1488 1
						      Strenv.empty_se),
d1490 2
a1491 2
						     Valenv.empty_valenv,
						     Valenv.empty_valenv)))
@


1.27
log
@Removed previous incorrect fix to do with subAssemblies
@
text
@d4 3
a82 1
require "../utils/set";
a85 1
require "../basics/absyn";
a86 1
require "../typechecker/datatypes";
a94 6
require "../typechecker/nameset";
require "../typechecker/sigma";
require "../typechecker/sigenv";
require "../typechecker/phi";
require "../typechecker/funenv";
require "../typechecker/basis";
a97 1
require "../typechecker/assemblies";
a100 1
require "../typechecker/interface";
a106 1
  structure Set        : SET
a108 1
  structure Absyn      : ABSYN
a109 1
  structure Datatypes  : DATATYPES
a117 2
  structure Nameset    : NAMESET
  structure Sigma      : SIGMA
a118 4
  structure Sigenv     : SIGENV
  structure Phi        : PHI
  structure Funenv     : FUNENV
  structure Basis      : BASIS
a121 1
  structure Assemblies : ASSEMBLIES
a124 1
  structure Interface  : INTERFACE
d130 1
a130 1
  sharing Datatypes      = Realise.Datatypes =
d132 11
a142 29
    Absyn.Datatypes      = Basis.Datatypes =
    Funenv.Datatypes     = Phi.Datatypes =
    Sigenv.Datatypes     = Sigma.Datatypes =
    Nameset.Datatypes    = Env.Datatypes =
    Strnames.Datatypes   = Tyenv.Datatypes =
    Tystr.Datatypes      = Valenv.Datatypes =
    Scheme.Datatypes     = Types.Datatypes = 
    Assemblies.Datatypes = Share.Datatypes = 
    Sharetypes.Datatypes = Errors.Datatypes =
    Interface.Datatypes  = Strenv.Datatypes(* =
    NewSigma.Datatypes =*)
(*    NewSigma.Nameset.Datatypes*)
  sharing Sigma = Realise.Sigma =
    Basis.Sigma = Phi.Sigma = 
    Sigenv.Sigma
  sharing Absyn = Core_rules.Absyn = Type_exp.Absyn
  sharing Basis = Core_rules.Basis = Type_exp.Basis =
    Errors.Basis
  sharing Set = Absyn.Set = Basis.Set = Scheme.Set
  sharing Phi = Basis.Phi = Funenv.Phi
  sharing Sigenv = Basis.Sigenv
  sharing Funenv = Basis.Funenv
  sharing Nameset = Basis.Nameset = Funenv.Nameset
    = Phi.Nameset = Sigma.Nameset = Share.Nameset
    = Absyn.Nameset
  sharing Assemblies = Share.Assemblies = 
    Sharetypes.Assemblies = Core_rules.Assemblies
  sharing Interface = Absyn.Interface
  sharing Env.NewMap = Nameset.NewMap
d146 10
a155 3
    structure Absyn = Absyn
    structure Basis = Basis
    structure Assemblies = Assemblies
d159 1
a159 1
    open Datatypes
d956 2
a957 4
         let val env = Timer.xtime ("check_shareq", !print_times,fn () =>  check_shareq (shareqlist,basis))
         in
           env
         end)
d1288 1
a1288 2
      (debug ["check_shareq  for []"];
       Env.empty_env)
d1290 4
a1293 4
     | check_shareq ((Absyn.STRUCTUREshareq stridlist,marks)::shareqs,basis) =
       (debug ["check_shareq for structures"];
	Env.env_plus_env (check_str_share (stridlist,basis,marks),
			  check_shareq (shareqs,basis)))
d1297 2
a1298 2
	 Env.env_plus_env (check_type_share (tyconlist,basis,marks),
			   check_shareq (shareqs,basis)))
d1301 1
a1301 2
      (debug ["check_str_share 88"];
       Env.empty_env)
d1333 4
a1336 4
	       if share_successful
		 then (sigstr_ass := sigstr_ass';
		       sigty_ass := sigty_ass';
		       check_str_share (sharelist,basis,marks))
d1338 1
a1338 1
		 Env.empty_env
d1342 1
a1342 1
	     (Errors.return_val Env.empty_env)
d1352 1
a1352 2
      (debug ["check_type_shareq 89"];
       Env.empty_env)
d1383 3
a1385 3
	   if share_successful
	     then (sigty_ass := sigty_ass';
		   check_type_share (sharelist,basis,marks))
d1387 1
a1387 1
	     Env.empty_env
@


1.26
log
@Fixed bug whereby structure a = a caused subassemblies
@
text
@d4 3
d375 1
a375 1
	 Env.SE_in_env (check_strbinds (strbindlist, basis, Strenv.empty_se)))
a407 1
(*
d418 2
a419 1
						   (str,Nameset.empty_nameset()))
a421 1
	   
d450 2
a451 1
						   (str,Nameset.empty_nameset()))
a480 4
*)
    and check_strbinds ([],basis,se) = 
      (debug ["check_strbinds 62"];
       se)
a481 69
      | check_strbinds ((strid,Absyn.ABSENT,strexp,_)::strbinds,basis,se) =
	(debug ["check_strbinds 62a"];
	 let 
	   val str as STR (m,env) = check_strexp (strexp,basis)
	   val new_basis = 
             Basis.basis_plus_names (basis,
                                     Sigma.names_of (str,
                                                     Nameset.empty_nameset()))
	 in 
	   
	   if Env.member_of_se_domain (strid,se)
	     then
	       let
		 val str' = Env.lookup_strid_in_SE (strid,se)
		 val (str_ass',ty_ass') = 
		   Assemblies.subAssemblies (!str_ass,!ty_ass,str')
	       in
		 (str_ass := str_ass';
		  ty_ass := ty_ass')
	       end
	   else
	     ();
             check_strbinds (strbinds,new_basis,Env.add_to_se (strid,str,se))
	 end)                             
	
      | check_strbinds ((strid,Absyn.PRESENT sigexp,strexp,marks)::strbinds,
			basis,se) = 
	(debug ["check_strbinds 62b"];

	 let
	   val str as STR (m,env) = check_strexp (strexp,basis)       
	   val sigma = check_sigexp_closed (sigexp,basis,marks)
	   val sigma' as Sigma.SIGMA (_,str') =
	     (if do_debug then
		debug ["sigma before copying :\n ",(Sigma.string_sigma sigma)]
		else ();
	      Sigma.sig_copy sigma)
	   val new_basis = Basis.basis_plus_names (basis,Sigma.names_of 
						   (str,
                                                    Nameset.empty_nameset()))
	 in
	   if (Realise.sigmatch (Basis.level (Basis.basis_to_context basis),
				 sigma',str,true) 
	       handle Realise.RealiseError s => (error_announce s;
						 false))
	     then
	       
	       (if Env.member_of_se_domain (strid,se)
		  then
		    let
		      val str' = Env.lookup_strid_in_SE (strid,se)
		      val (str_ass',ty_ass') = 
			Assemblies.subAssemblies (!str_ass,!ty_ass,str')
		    in
		      (str_ass := str_ass';
		       ty_ass := ty_ass')
		    end
		else
		  ();
	          check_strbinds (strbinds,new_basis,
                                  Env.add_to_se (strid,str',se)))
	   else
	     Errors.announce_error (Basis.basis_to_context basis) 
	     (Errors.return_val Strenv.empty_se)
	     [Absyn.Source_marks_to_string marks,
              " Signature does not match structure ",
	      (IdentPrint.printStrId strid),"\n"]
	 end)
      
@


1.25
log
@Changed exptyStrAssembly to be a function, in case we want an imperative
implementation ever
@
text
@d4 4
d176 1
d372 1
a372 1
	 Env.SE_in_env (check_strbinds (strbindlist,basis)) )
d405 1
d478 73
d596 1
a596 1
	   Nameset.new_names (names,[],[])
@


1.24
log
@Added timing of unionTypeAssemblies. Made all timings able to be
turned off
@
text
@d4 4
d196 1
a196 1
    val str_ass = ref Assemblies.empty_strassembly
d203 1
a203 1
    val sigstr_ass = ref Assemblies.empty_strassembly
d213 1
a213 1
	val _ = str_ass := Assemblies.empty_strassembly
d215 1
a215 1
	val _ = sigstr_ass := Assemblies.empty_strassembly
d529 1
a529 1
				     Assemblies.empty_strassembly,
d535 4
a538 1
	 (sigstr_ass := Assemblies.unionStrAssembly (!sigstr_ass,sigstr_ass');
d542 1
a542 1
	   sigty_ass := Assemblies.unionTypeAssembly (!sigty_ass,sigty_ass'));
d837 1
a837 1
					     Assemblies.empty_strassembly,
d1582 1
a1582 1
	   sigstr_ass := Assemblies.empty_strassembly;
@


1.23
log
@Changed to imperative implementation of namesets with hashing
@
text
@d4 3
d265 1
a265 1
	   val str_offs = Timer.time_it ("collectStrOffspring 54", fn () => Assemblies.collectStrOffspring
d267 1
a267 1
	   val ty_offs = Timer.time_it ("collectTypeOffspring 54", fn () => Assemblies.collectTypeOffspring 
d269 1
a269 1
	   val ty_ass' = Timer.time_it ("updateTypeAssembly 54", fn () =>Assemblies.updateTypeAssembly (te,!ty_ass))
d282 2
a283 2
	   val str = Timer.time_it ("check_strexp 55",fn () => check_strexp (strexp,basis) )
	   val (str_ass',ty_ass') = Timer.time_it ("subAssemblies 55", fn () => Assemblies.subAssemblies (!str_ass,!ty_ass,
d307 1
a307 1
	     Timer.time_it ("phi_copy 55", fn () => Phi.phi_copy phi)
d310 1
a310 1
           val realise = Timer.time_it ("sigmatch 55", fn () => (Realise.sigmatch(Basis.level(Basis.basis_to_context basis),
d532 4
a535 2
	  sigty_ass := Assemblies.unionTypeAssembly (!sigty_ass,sigty_ass');
	  
d835 4
a838 1
		 ty_ass := Assemblies.unionTypeAssembly (!ty_ass,sigty_ass')
d970 1
a970 1
         let val env = Timer.time_it ("check_shareq",fn () =>  check_shareq (shareqlist,basis))
@


1.22
log
@Changed print_times into ref.
@
text
@d1 1
a82 1
require "../typechecker/newsigma";
d117 1
a117 1
  structure NewSigma   : NEWSIGMA
d146 3
a148 3
    Interface.Datatypes  = Strenv.Datatypes =
    NewSigma.Datatypes =
    NewSigma.Nameset.Datatypes
d403 1
a403 1
						   (str,Nameset.empty_nameset))
d435 1
a435 1
						   (str,Nameset.empty_nameset))
d542 1
a542 1
(*
d546 1
a546 1
	   Sigma.SIGMA (Sigma.new_names_of (str,Nameset.empty_nameset),str))
d548 1
a548 1
	 val nameset' =
d574 1
a574 1
*)
d588 1
a588 1

d687 2
a688 2
				       Nameset.empty_nameset)),
		  Nameset.empty_nameset)
d1432 1
a1432 1
			   (str',Nameset.empty_nameset),
d1488 1
a1488 1
				 (str',Nameset.empty_nameset),
d1548 1
a1548 1
				     (new_env, Nameset.empty_nameset))
@


1.21
log
@Adjusted to give better error position reporting now marks have been added
@
text
@d3 3
d173 1
a173 1
    val print_times = true
d476 1
a476 1
	 Timer.xtime("check_spec", print_times,
d479 1
a479 1
	 Timer.xtime("collectTypeOffspring", print_times,
d488 1
a488 1
       Timer.xtime("add_to_StrAssembly", print_times,
d540 1
a540 1
	   Timer.xtime("check_sigexp_open", print_times,
d544 1
a544 1
	   Timer.xtime("new_names_of", print_times,
d549 1
a549 1
	   Timer.xtime("new_names_of'", print_times,
d577 1
a577 1
	   ("new_names_of", print_times,
d777 1
a777 1
	 if Timer.xtime("respect_equality", print_times,
d779 1
a779 1
	   if Timer.xtime("type_explicit", print_times,
d781 1
a781 1
	     if Timer.xtime("well_formed", print_times,
d783 1
a783 1
	       Timer.xtime("equality_principal", print_times,
d1457 1
a1457 1
	     Timer.xtime("check_sigexp_closed", print_times,
d1461 1
a1461 1
	     Timer.xtime("basis_plus_env", print_times,
d1469 1
a1469 1
	   val str' = Timer.xtime("check_strexp", print_times,
d1471 1
a1471 1
	   val sigma' = Timer.xtime("check_sigexp_closed", print_times,
d1473 1
a1473 1
	   val sigma'' as Sigma.SIGMA (_,str'') = Timer.xtime("sig_copy", print_times,
d1476 1
a1476 1
	     Timer.xtime("subAssemblies", print_times,
d1479 1
a1479 1
	   if Timer.xtime("sigmatch", print_times,
d1491 1
a1491 1
		   Timer.xtime("PHI", print_times,
@


1.20
log
@Removed incorrect whitespace from middle of nameset.empty_nameset.
Goodness knows why NJ allows this, I wish they didn't
@
text
@d3 4
d273 1
a273 1
      | check_strexp (Absyn.APPstrexp (funid,strexp),basis) =
d284 2
a285 1
	       error_announce ("unbound functor identifier " ^ 
d332 2
a333 1
	     ["The argument signature of ",(IdentPrint.printFunId funid),
d394 1
a394 1
      | check_strbinds ((strid,Absyn.ABSENT,strexp)::strbinds,
d419 1
a419 1
      | check_strbinds ((strid,Absyn.PRESENT sigexp,strexp)::strbinds,
d425 1
a425 1
	   val sigma = check_sigexp_closed (sigexp,basis)
d458 2
a459 1
	     ["Signature does not match structure ",
d533 1
a533 1
    and check_sigexp_closed (sigexp,basis) =
d597 2
a598 1
		       ["Type structure does not respect equality\n"]
d785 2
a786 1
	       ["Signature is not well_formed\n"]
d790 2
a791 1
	     ["Signature is not type-explicit\n"]
d795 2
a796 1
	   ["Signature does not respect equality\n"]
d811 1
a811 1
      | check_sigbind (Absyn.SIGBIND ((sigid,sigexp)::sigbinds),basis,sigenv) =
d815 1
a815 1
	     check_sigexp_closed (sigexp,basis)
d943 2
a944 1
	 let val ve = check_exdesc (exdesclist,Basis.basis_to_context basis)
d974 1
a974 1
	(debug ["check_spec 78"];
d1216 1
a1216 1
      | check_exdesc ((excon,Absyn.ABSENT)::exdescs,context) =
d1221 1
a1221 1
      | check_exdesc ((excon,Absyn.PRESENT aty)::exdescs,context) =
d1229 2
a1230 1
		 ["Exception description of ",IdentPrint.printValId excon,
d1296 1
a1296 1
     | check_shareq ((Absyn.STRUCTUREshareq stridlist)::shareqs,basis) =
d1298 1
a1298 1
	Env.env_plus_env (check_str_share (stridlist,basis),
d1301 1
a1301 1
      | check_shareq ((Absyn.TYPEshareq tyconlist)::shareqs,basis) =
d1303 1
a1303 1
	 Env.env_plus_env (check_type_share (tyconlist,basis),
d1306 1
a1306 1
    and check_str_share (Ident.LONGSTRID (path,valid)::[],_) =
d1313 1
a1313 1
			  basis as Basis.BASIS (nameset,funenv,sigenv,env)) =
d1318 2
a1319 1
	       error_announce ("unbound structure identifier " ^ 
d1323 2
a1324 1
	       error_announce ("unbound structure identifier " ^ 
d1334 2
a1335 1
		   ["Failed to share structures ",
d1343 1
a1343 1
		       check_str_share (sharelist,basis))
d1350 2
a1351 1
	     ["Sharing ",IdentPrint.printLongStrId lstrid, " and ",
d1358 1
a1358 1
    and check_type_share (Ident.LONGTYCON (path,tycon)::[],_) =
d1365 1
a1365 1
			  basis as Basis.BASIS (nameset,funenv,sigenv,env)) =
d1371 2
a1372 1
	       error_announce ("unbound type constructor " ^ 
d1377 2
a1378 1
	       error_announce ("unbound type constructor " ^
d1385 2
a1386 1
	       ["Failed to share types ",
d1393 1
a1393 1
		   check_type_share (sharelist,basis))
d1413 1
a1413 1
		       ((funid,strid,sigexp,namesetref,strexp,Absyn.ABSENT,_)
d1418 1
a1418 1
	   val Sigma.SIGMA (names,str) = check_sigexp_closed (sigexp,basis)
d1449 1
a1449 1
				       Absyn.PRESENT sigexp',_) :: funbinds),
d1455 1
a1455 1
			   fn () => check_sigexp_closed (sigexp,basis))
d1469 1
a1469 1
				      fn () => check_sigexp_closed(sigexp',new_basis))
d1500 2
a1501 1
	     ["Functor body ",(IdentPrint.printFunId funid),
d1534 1
a1534 1
    fun in_check_topdec (Absyn.STRDECtopdec strdec,basis) = 
d1549 2
a1550 1
	   ["Free imperative type variables at top level\n"]
d1578 1
a1578 1
      | in_check_topdec (Absyn.FUNCTORtopdec funbindlist,basis) = 
d1592 2
a1593 1
	     ["Free imperative type variables at top level\n"]
@


1.19
log
@Anel's fixes. Also included new version of nameset based on hashsets
@
text
@d3 3
d1523 2
a1524 3
				     Sigma.names_of_env (new_env,
							 Nameset.
							 empty_nameset))
@


1.18
log
@Added second implementation of sigma for test purposes
@
text
@d3 3
d90 1
a90 1
  structure Integer      : INTEGER
d95 1
a95 1
  structure Ty_Debug  : TY_DEBUG
d102 1
a102 1
  structure Strenv	   : STRENV
d107 1
a107 1
  structure NewSigma      : NEWSIGMA
d252 5
a256 5
	   val str_offs = Assemblies.collectStrOffspring
	     (se,Assemblies.empty_str_offspring)
	   val ty_offs = Assemblies.collectTypeOffspring 
	     (te,Assemblies.empty_type_offspring)
	   val ty_ass' = Assemblies.updateTypeAssembly (te,!ty_ass)
d269 3
a271 3
	   val str = check_strexp (strexp,basis) 
	   val (str_ass',ty_ass') = Assemblies.subAssemblies (!str_ass,!ty_ass,
							      str)
d293 1
a293 1
	     Phi.phi_copy phi
d296 5
d302 1
a302 1
	   if (Realise.sigmatch(Basis.level(Basis.basis_to_context basis),
d305 2
a306 1
						 false))
d529 1
d535 1
a535 1
	 val nameset' = 
d561 14
d944 4
a947 1
	 check_shareq (shareqlist,basis))
d1309 1
a1309 1
	   if not (substr (str,str') orelse substr (str',str)) then
@


1.17
log
@Changed calling of sigmatch to indicate when equality attributes matter
@
text
@a2 3
Revision 1.16  1992/04/22  10:58:33  jont
Added integer parameter to functor

d69 1
d104 1
d133 3
a135 1
    Interface.Datatypes  = Strenv.Datatypes
d203 19
d285 1
a285 3
            structure of the functor application.  The boolean indicates that 
            equality of types can be ignored, since we are not doing proper 
            signature matching.  See rules 62 and 99.
d294 2
a295 2
	   if (Realise.sigmatch  (Basis.level (Basis.basis_to_context basis),
				  sigma,str,false) 
d525 5
d537 14
d934 1
a934 1
	   fun collect_envs (longstrid::[],basis) =
d943 1
a943 1
	     | collect_envs (longstrid::longstridlist,basis) =
d950 1
a950 1
		 val env = collect_envs (longstridlist,basis)
d957 1
a957 1
	   collect_envs (longstridlist,basis)
d997 1
a997 1
      | check_spec (Absyn.SEQUENCEspec (spec::speclist),basis) =
d999 1
d1006 10
a1015 1
	 end)
d1017 8
d1205 1
a1205 1
      | check_strdesc ((strid,sigexp)::strdescs,
d1208 1
d1218 10
a1227 1
	 end)
d1229 13
a1280 21
	   local
	     fun proper_substr (str as STR (name,env),SE amap) =
	       let 
		 val stridlist = Mapping.domain amap
	       in
		 if Mapping.emptymap_p amap
		   then false
		 else
		   Mapping.forall (amap,fn (STR (m,ENV (se',_,_,_))) => 
				   m = name orelse proper_substr (str,se'))
	       end
	   in
	     fun substr (str as STR (name,_),STR (name',ENV (se',_,_,_))) =
	       (if do_debug andalso Debug.debug_level () > 5 then 
		  (Print.print (" substr... ");
		   Print.print (" name = " ^ Strnames.string_strname name);
		   Print.print (" name' = " ^ Strnames.string_strname name');
		   Print.print ("\n"))
		else ();
		  proper_substr (str,se'))
	   end
d1282 19
a1300 20
	   if not (substr (str,str') orelse substr (str',str))
	     then
	       let 
		 val (share_successful,sigstr_ass',sigty_ass') = 
		   Share.share_str (m,m',!sigstr_ass,!sigty_ass,nameset)
		   handle Share.ShareError s =>
		     Errors.announce_error (Basis.basis_to_context basis)
		     (Errors.return_val (false,!sigstr_ass,!sigty_ass))
		     ["Failed to share structures ",
		      IdentPrint.printLongStrId lstrid, " and ",
		      IdentPrint.printLongStrId lstrid', "\n",
		      "\nReason : ",s]
	       in		  
		 if share_successful
		   then (sigstr_ass := sigstr_ass';
			 sigty_ass := sigty_ass';
			 check_str_share (sharelist,basis))
		 else
		   Env.empty_env
	       end
@


1.16
log
@Added integer parameter to functor
@
text
@d3 3
d265 3
a267 1
            structure of the functor application.
d277 1
a277 1
				  sigma,str) 
d400 1
a400 1
				 sigma',str) 
d1372 1
a1372 1
				 sigma'',str')
@


1.15
log
@Various improvements. Added timing functions
@
text
@d3 3
d55 1
d86 1
d506 1
a506 1
	    makestring(Lists.length tl) ^
d508 1
a508 1
	    makestring(Lists.length sl) ^ "\n")
@


1.14
log
@Made some efficiency improvements
@
text
@d47 1
d80 1
d151 1
d381 3
a383 1
	     (debug ["sigma before copying :\n ",(Sigma.string_sigma sigma)];
d425 6
a430 3
       val env as ENV (se,te,_,_) = check_spec (spec,basis)
       val type_offspring = 
	 Assemblies.collectTypeOffspring (te,
d432 1
a432 1
					  (m,!sigstr_ass))
d437 4
a440 1
       sigstr_ass := Assemblies.add_to_StrAssembly
d445 1
a445 1
	type_offspring,!sigstr_ass);
d489 16
a504 4
	 val str = check_sigexp_open (sigexp,basis)
	 val sigma = 
	   Sigma.SIGMA (Sigma.new_names_of (str,Nameset.empty_nameset),str)
	   
d692 16
a707 12
	 if respect_equality sigma 
	   then if type_explicit sigma
		  then if well_formed sigma
			 then equality_principal sigma
		       else
			 Errors.announce_error (Basis.basis_to_context basis)
			 (Errors.return_val sigma)
			 ["Signature is not well_formed\n"]
		else 
		  Errors.announce_error (Basis.basis_to_context basis)
		  (Errors.return_val sigma)
		  ["Signature is not type-explicit\n"]
d712 1
a712 1
      end)
d762 4
a765 2
	 debug ["signature ve before closing = ",
		Valenv.string_valenv (0,new_ve)];
d1338 2
a1339 1
	     check_sigexp_closed (sigexp,basis)
d1341 15
a1355 10
	   val new_basis = 
	     Basis.basis_plus_env (basis,ENV (Env.add_to_se 
					      (strid,str,
					       Strenv.empty_se),
					      Tyenv.empty_tyenv,
					      Valenv.empty_valenv,
					      Valenv.empty_valenv))
	   val str' = check_strexp (strexp,new_basis)
	   val sigma' = check_sigexp_closed (sigexp',new_basis)
	   val sigma'' as Sigma.SIGMA (_,str'') = Sigma.sig_copy sigma'
d1357 2
a1358 1
	     Assemblies.subAssemblies (!str_ass, !ty_ass, str')
d1360 2
a1361 1
	   if (Realise.sigmatch (Basis.level (Basis.basis_to_context basis),
d1364 1
a1364 1
						 false))
d1372 2
a1373 1
		   Phi.PHI (names,(str,Sigma.SIGMA (names',str'')))
@


1.13
log
@First version of the profiler
@
text
@d3 3
d151 6
a156 10
    local
      fun print_list [] = Print.print "\n"
	| print_list (h :: t) = (Print.print h ; print_list t)
    in
      fun debug L  =
	if do_debug andalso Debug.debug_level () > 10 then
	  (print_list L)
	else
	  ()
    end
d482 2
a483 2
	 fun te_respect_equality ([],_) = true
	   | te_respect_equality (tycon::tycons,te) = 
a484 4
	       val tystr = Tyenv.lookup (tycon,te)
		 handle Tyenv.Lookup_in_TE =>
		   error_announce ("unbound type constructor " ^
				   (IdentPrint.printTyCon tycon) ^ "\n")
a487 75
(*
		     if
		       let
			 fun do_forall true_fn err_fn the_map =
			   let
			     fun do_sub [] = true
			     | do_sub((x as (x1, x2)) :: xs) =
			       if true_fn x2 then
				 do_sub xs
			       else
				 (err_fn x;
				  false)
			   in
			     do_sub(Mapping.assoc the_map)
			   end
		       in
			 do_forall Scheme.equalityp
			 (fn (x, y) =>
			  let
			    val string1 =
			      "Fails at constructor '" ^
			      IdentPrint.printValId x ^
			      "'\n"
			    val ty1 = case y of
			      SCHEME (_,FUNTYPE (atype,atype')) => atype
			    | UNBOUND_SCHEME (FUNTYPE (atype,atype')) => atype
			    | _ => Crash.impossible"Bugger"
			    fun do_ty ty =
			      (case ty of
				 METATYVAR _ => "METATYVAR"
			       | META_OVERLOADED _ => "META_OVERLOADED"
			       | TYVAR _ => "TYVAR"
			       | METARECTYPE _ => "METARECTYPE"
			       | RECTYPE amap =>
				   let
				     fun err_fn(x, y) =
				       let
					 val str =
					   "of type '" ^ do_ty y ^ "'\n"
					 val (l, t) = case y of
					   CONSTYPE c => c
					 | _ => Crash.impossible"Bum"
					 val str = str ^
					   "List size " ^
					   (case l of
					      [] => "empty"
					    | _ => "non-empty") ^ "\n" ^
					      (case t of
						 TYNAME _ => "TYNAME"
					       | METATYNAME _ => "METATYNAME"
						   ) ^
						 "\n"
				       in
					 Print.print
					 ("Bad label '" ^
					  IdentPrint.printLab x ^
					  "'\n" ^ str)
				       end
				     val _ =
				       do_forall Types.type_equalityp
				       err_fn amap
				   in
				     "RECTYPE"
				   end
			       | FUNTYPE _ => "FUNTYPE"
			       | CONSTYPE _ => "CONSTYPE"
			       | DEBRUIJN _ => "DEBRUIJN"
			       | NULLTYPE => "NULLTYPE")
			  in
			    Print.print(string1 ^ "of type '" ^ do_ty ty1 ^
					"\n")
			  end)
			 conenv
		       end then true
*)(**)
a489 1
(**)
d498 1
a498 1
		 te_respect_equality (tycons,te)
d501 6
a506 9
	 fun se_respect_equality ([],se) = true
	   | se_respect_equality (strid::strids,se) = 
	     let val STR (_,env) = Env.lookup_strid_in_SE (strid,se)
	     in
	       env_respect_equality (env) 
	       andalso
	       se_respect_equality (strids,se)
	     end
	   
d512 2
a513 2
	       val stridlist = Mapping.domain amap
	       val tyconlist = Mapping.domain amap'
d515 1
a515 1
	       se_respect_equality (stridlist,se)
d517 1
a517 1
	       te_respect_equality (tyconlist,te)
d523 20
d544 1
a544 24
	   let
	     fun max_eq (TE amap) =
	       while 
		 not (Mapping.forall
		      (amap,
		       fn (TYSTR (atyfun,VE (_,aconenv)))
		       =>
			 (if Types.equalityp atyfun
			    then
			      if Mapping.forall
				(aconenv,
				 Scheme.equalityp)
				then
				  true
			      else 
				Types.make_false atyfun
			  else
			    true)))
		 do
		 ()
	   in
	     (max_eq (te);
	      true)
	   end
d546 5
a550 8
	 fun se_equality_principal ([],_) = true
	   | se_equality_principal (strid::strids,se) =
	     let val STR (_,env) = Env.lookup_strid_in_SE (strid,se)
	     in
	       env_equality_principal (env)
	       andalso 
	       se_equality_principal (strids,se)
	     end
d553 2
a554 1
	   let val stridlist = Mapping.domain amap
d558 1
a558 1
	     se_equality_principal (stridlist,se)
d565 25
a589 2
	 fun well_formed (Sigma.SIGMA (names,STR (_,env as ENV (se,_,_,_))))=
	   (debug ["names in well_formed = ",Nameset.string_nameset names];
a590 1
	      val SE amap = se
a591 18
	      fun check ([],_,_) = true
		| check (strid::strids,names,env) = 
		  let val STR (m,env') = Env.lookup_strid (strid,env)
		    handle Env.Lookup_StrId => 
		      error_announce ("unbound structure identifier " ^
				      (IdentPrint.printStrId strid) ^ "\n")
		  in
		    if not (Nameset.member_of_strnames (m,names)) 
		      then
			Nameset.nameset_eq 
			(Nameset.intersection 
			 (names,
			  Sigma.names_of_env (env',
					      Nameset.empty_nameset)),
			 Nameset.empty_nameset)
			andalso check (strids,names,env)
		    else true
		  end
d596 6
a601 4
	 fun te_type_explicit (names,[],_) = 
	   (debug ["te_type_explicit ",
		   "names in te_type_explicit = ",
		   (Nameset.string_nameset names)];
d603 3
a605 2
	   | te_type_explicit (names,tycon::tycons,te) = 
	     (debug ["te_type_explicit a ",
d607 6
a612 5
		     (IdentPrint.printTyCon tycon)];
	      let val TYSTR (tyfun,conenv) = Tyenv.lookup (tycon,te)
		handle Tyenv.Lookup_in_TE => 
		  error_announce ("unbound type constructor " ^
				  (IdentPrint.printTyCon tycon) ^ "\n")
d614 6
a619 8
		if Types.has_a_new_name tyfun
		  andalso
		  Nameset.member_of_tynames (Types.name tyfun,names)
		  then 
		    Nameset.remove_tyname 
		    (Types.name tyfun,te_type_explicit (names,tycons,te))
		else te_type_explicit (names,tycons,te)
	      end)
d621 6
a626 4
	 fun se_type_explicit (names,[],_) = 
	   (debug ["se_type_explicit ",
		   "names in se_type_explicit = ",
		   (Nameset.string_nameset names)];
d628 3
a630 2
	   | se_type_explicit (names,strid::strids,se) = 
	     (debug  ["se_type_explicit a ",
d632 4
a635 5
		      (Nameset.string_nameset names)];
	      let val STR (_,env) = Env.lookup_strid_in_SE (strid,se)
	      in
		se_type_explicit (env_type_explicit (names,env),strids,se)
	      end)
d638 5
a642 3
	   (debug ["env_type_explicit ",
		   "names in env_type_explicit = ",
		   (Nameset.string_nameset names)];
d644 3
a646 3
	      val stridlist = Mapping.domain amap
	      val tyconlist = Mapping.domain amap'
	      val names' = te_type_explicit (names,tyconlist,te)
d648 8
a655 5
	      debug ["env_type_explicit after te_type_explicit ",
		     "names in env_type_explicit = ",
		     (Nameset.string_nameset names')];
	      se_type_explicit (names',stridlist,se)
	    end)
d661 4
a664 2
	      debug ["nameset in type_explicit = ",
		     (Nameset.string_nameset nameset)];
d666 2
a667 2
	    end)
	     
@


1.12
log
@Reinstated the code to determine constructor environments for METATYNAMEs
@
text
@d3 3
d1342 1
a1342 1
		       ((funid,strid,sigexp,namesetref,strexp,Absyn.ABSENT)
d1378 1
a1378 1
				       Absyn.PRESENT sigexp') :: funbinds),
@


1.11
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d3 4
a1102 2

(*
d1109 1
a1109 2
*)
	  (ve,(Tyenv.add_to_te (tycon,TYSTR (tyfun,conenv),te)))
a1110 1
(*
a1111 1
*)
@


1.10
log
@Updated to create empty valenv in METATYNAMEs
@
text
@d3 3
d41 2
a64 1
require "../basics/absyn";
d68 64
a131 62
functor Module_rules (structure Lists      : LISTS
		      structure Set        : SET
		      structure Print      : PRINT
		      structure Crash      : CRASH
		      structure Datatypes  : DATATYPES
		      structure Types      : TYPES
		      structure Scheme     : SCHEME
		      structure Valenv     : VALENV
		      structure Tystr      : TYSTR
		      structure Tyenv      : TYENV
		      structure Strenv	   : STRENV
		      structure Env        : ENVIRONMENT
		      structure Strnames   : STRNAMES
		      structure Nameset    : NAMESET
		      structure Sigma      : SIGMA
		      structure Sigenv     : SIGENV
		      structure Phi        : PHI
		      structure Funenv     : FUNENV
		      structure Basis      : BASIS
		      structure Type_exp   : TYPE_EXP
		      structure Core_rules : CORE_RULES
		      structure Realise    : REALISE
		      structure Assemblies : ASSEMBLIES
		      structure Sharetypes : SHARETYPES
		      structure Share      : SHARE
		      structure Errors     : ERRORS
		      structure Absyn      : ABSYN
		      structure Interface  : INTERFACE
		      structure Debug      :  sig
						val set_debug_level :
						  int -> unit
						val debug_level : unit -> int
					      end
		      sharing Datatypes      = Realise.Datatypes =
			Core_rules.Datatypes = Type_exp.Datatypes =
			Absyn.Datatypes      = Basis.Datatypes =
			Funenv.Datatypes     = Phi.Datatypes =
			Sigenv.Datatypes     = Sigma.Datatypes =
			Nameset.Datatypes    = Env.Datatypes =
			Strnames.Datatypes   = Tyenv.Datatypes =
			Tystr.Datatypes      = Valenv.Datatypes =
			Scheme.Datatypes     = Types.Datatypes = 
			Assemblies.Datatypes = Share.Datatypes = 
			Sharetypes.Datatypes = Errors.Datatypes =
			Interface.Datatypes  = Strenv.Datatypes
		      sharing Sigma = Realise.Sigma =
			Basis.Sigma = Phi.Sigma = 
			Sigenv.Sigma
		      sharing Absyn = Core_rules.Absyn = Type_exp.Absyn
		      sharing Basis = Core_rules.Basis = Type_exp.Basis =
			Errors.Basis
		      sharing Set = Absyn.Set = Basis.Set = Scheme.Set
		      sharing Phi = Basis.Phi = Funenv.Phi
		      sharing Sigenv = Basis.Sigenv
		      sharing Funenv = Basis.Funenv
		      sharing Nameset = Basis.Nameset = Funenv.Nameset
			= Phi.Nameset = Sigma.Nameset = Share.Nameset
			= Absyn.Nameset
		      sharing Assemblies = Share.Assemblies = 
			Sharetypes.Assemblies = Core_rules.Assemblies
		      sharing Interface = Absyn.Interface
			) : MODULE_RULES =
d138 1
d146 1
a146 1
	if Debug.debug_level () > 10 then
d1249 1
a1249 1
	       (if Debug.debug_level () > 5 then 
@


1.9
log
@Stopped signatures and functors being duplicated from previous bases
@
text
@d3 3
d478 76
a553 1
		   then 
d556 1
d830 1
a830 1
	 let 
d848 2
a849 1
					      ref true)),
d1031 2
a1032 1
			  ref eq))
d1093 14
a1106 1
       (ve,(Tyenv.add_to_te (tycon,TYSTR (tyfun,conenv),te))))
@


1.8
log
@added reset_assemblies
@
text
@d3 3
d1321 1
a1321 1
    fun check_sigdec ([],basis) = 
d1323 1
a1323 1
       Sigenv.empty_sigenv)
d1325 1
a1325 2
      | check_sigdec (sigbind::sigbindlist,
		      basis as Basis.BASIS (_,_,sigenv,_)) =
d1331 2
a1332 2
	   Sigenv.sigenv_plus_sigenv (new_sigenv,
				      check_sigdec (sigbindlist,new_basis))
d1335 1
a1335 1
    fun check_fundec ([],basis) =
d1337 2
a1338 3
       Funenv.empty_funenv)
      | check_fundec (funbind::funbindlist,
		      basis as Basis.BASIS (_,funenv,_,_)) = 
d1344 2
a1345 2
	   Funenv.funenv_plus_funenv (new_funenv,
				      check_fundec (funbindlist,new_basis))
d1377 2
a1378 1
	   val new_sigenv = check_sigdec (sigbindlist,basis)
d1397 2
a1398 1
	   val new_funenv = check_fundec (funbindlist,basis)
@


1.7
log
@Moved the empty structure environment from Env to Strenv.
@
text
@d2 4
a5 1
$Log:	_mod_rules.sml,v $
d158 11
@


1.6
log
@Fixed inexhaustive matches
@
text
@d3 3
d35 1
d65 1
d99 1
a99 1
			Interface.Datatypes
d310 1
a310 1
       Env.empty_strenv)
d373 1
a373 1
	     (Errors.return_val Env.empty_strenv)
d1063 1
a1063 1
       Env.empty_strenv)
d1232 1
a1232 1
				       (strid,str,Env.empty_strenv),
d1268 1
a1268 1
					       Env.empty_strenv),
@


1.5
log
@Added exception Check_topdec - raised if any errors happened during
type checking in check_topdec
@
text
@d3 4
d20 1
d25 1
d54 1
d836 2
d868 1
d1161 1
d1201 2
@


1.4
log
@changed to handle Interface annotations in signature expressions
@
text
@d3 3
d1317 1
a1317 1
    fun check_topdec (Absyn.STRDECtopdec strdec,basis) = 
d1338 1
a1338 1
      | check_topdec (Absyn.SIGNATUREtopdec sigbindlist,basis) = 
d1360 1
a1360 1
      | check_topdec (Absyn.FUNCTORtopdec funbindlist,basis) = 
d1375 1
a1375 1
	| check_topdec (Absyn.REQUIREtopdec s,basis) = 
d1378 12
a1389 1
       
@


1.3
log
@Added null check on REQUIREtopdec.
@
text
@d3 3
d39 1
d67 1
d83 2
a84 1
			Sharetypes.Datatypes = Errors.Datatypes 
d100 1
d367 1
a367 1
  and check_sigexp_open (Absyn.NEWsigexp spec,basis) = 
d377 3
d393 1
a393 1
    | check_sigexp_open (Absyn.OLDsigexp sigid,basis) =
d415 2
@


1.2
log
@Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures
@
text
@d3 4
d1360 3
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d425 1
a425 1
	       fun tystr_respect_equality (TYSTR (tyfun,VE conenv)) =
d472 1
a472 1
		       fn (TYSTR (atyfun,VE aconenv))
d737 1
a737 1
			 (atyfun,VE aconenv))
@
