head	1.31;
access;
symbols
	MLW_daveb_inline_1_4_99:1.31.3
	MLWorks_21c0_1999_03_25:1.31
	MLWorks_20c1_1998_08_20:1.31
	MLWorks_20c0_1998_08_04:1.31
	MLWorks_20b2c2_1998_06_19:1.31
	MLWorks_20b2_Windows_1998_06_12:1.31
	MLWorks_20b1c1_1998_05_07:1.31
	MLWorks_20b0_1998_04_07:1.31
	MLWorks_20b0_1998_03_20:1.31
	MLWorks_20m2_1998_02_16:1.31
	MLWorks_20m1_1997_10_23:1.31
	MLWorks_11r1:1.30.6.1.1.1.1
	MLWorks_workspace_97:1.31.2
	MLWorks_dt_wizard:1.31.1
	MLWorks_11c0_1997_09_09:1.30.6.1.1.1
	MLWorks_10r3:1.30.6.1.3
	MLWorks_10r2_551:1.30.6.1.2
	MLWorks_11:1.30.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.30.6.1
	MLWorks_20m0_1997_06_20:1.31
	MLWorks_1_0_r2c2_1997_06_14:1.30.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.30.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.30.6
	MLWorks_BugFix_1997_04_24:1.30
	MLWorks_1_0_r2_Win32_1997_04_11:1.30
	MLWorks_1_0_r2_Unix_1997_04_04:1.30
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.30.4.1.1
	MLWorks_gui_1996_12_18:1.30.5
	MLWorks_1_0_Win32_1996_12_17:1.30.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.30.2.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.30.2.1
	MLWorks_1_0_Irix_1996_11_28:1.30.2.1.1
	MLWorks_1_0_Win32_1996_11_22:1.30.3
	MLWorks_1_0_Unix_1996_11_14:1.30.2
	MLWorks_Open_Beta2_1996_10_11:1.30.1
	MLWorks_License_dev:1.29.2
	MLWorks_1_open_beta_1996_09_13:1.29.1
	MLWorks_Open_Beta_1996_08_22:1.29
	MLWorks_Beta_1996_07_02:1.29
	MLWorks_Beta_1996_06_07:1.29
	MLWorks_Beta_1996_06_06:1.29
	MLWorks_Beta_1996_06_05:1.29
	MLWorks_Beta_1996_06_03:1.29
	MLWorks_Beta_1996_05_31:1.29
	MLWorks_Beta_1996_05_30:1.29
	ML_beta_release_12/08/94:1.24
	ML_beta_release_03/08/94:1.24
	ML_revised_beta_release_25/05/94:1.23
	ML_final_beta_release_02/03/94:1.22
	mlworks-28-01-1994:1.21
	Release:1.18
	mlworks-beta-01-09-1993:1.18
	MLWorks-1-0-4-29/01/1993:1.12
	MLWorks-1-0-3-21/12/1992:1.11
	MLWorks-1-0-2-15/12/1992:1.11
	MLWorks-1-0-1-04/12/1992:1.10
	checkpoint_17_08_92:1.7
	Ten15_release_19-11-91:1.2
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.31
date	97.05.01.12.53.49;	author jont;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1;
next	1.30;

1.30
date	96.10.04.15.35.44;	author andreww;	state Exp;
branches
	1.30.1.1
	1.30.2.1
	1.30.3.1
	1.30.4.1
	1.30.5.1
	1.30.6.1;
next	1.29;

1.29
date	96.02.23.16.53.31;	author jont;	state Exp;
branches
	1.29.1.1
	1.29.2.1;
next	1.28;

1.28
date	96.02.21.17.16.47;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	95.12.27.11.24.40;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	95.03.24.16.13.41;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	95.01.17.13.18.29;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	94.06.17.10.44.24;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	94.05.05.13.26.57;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	94.02.28.05.52.54;	author nosa;	state Exp;
branches;
next	1.21;

1.21
date	93.11.30.11.04.20;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.11.25.09.34.07;	author nickh;	state Exp;
branches;
next	1.19;

1.19
date	93.09.22.12.48.10;	author nosa;	state Exp;
branches;
next	1.18;

1.18
date	93.07.30.10.45.34;	author nosa;	state Exp;
branches
	1.18.1.1;
next	1.17;

1.17
date	93.07.06.13.14.30;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	93.04.06.12.04.32;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.03.09.12.53.20;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.02.08.11.49.34;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.02.05.15.07.20;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.12.22.15.19.42;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.12.08.14.50.07;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.10.27.19.04.52;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.10.09.14.12.40;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.10.02.15.58.20;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.08.11.10.55.09;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.07.30.14.35.39;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.01.24.14.43.43;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.01.14.16.23.16;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.21.16.45.11;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.17.13.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.35.21;	author colin;	state Exp;
branches;
next	;

1.18.1.1
date	93.07.30.10.45.34;	author jont;	state Exp;
branches;
next	;

1.29.1.1
date	96.09.13.11.41.40;	author hope;	state Exp;
branches;
next	;

1.29.2.1
date	96.10.07.16.34.46;	author hope;	state Exp;
branches;
next	;

1.30.1.1
date	96.10.17.11.53.51;	author hope;	state Exp;
branches;
next	;

1.30.2.1
date	96.11.14.13.21.32;	author hope;	state Exp;
branches
	1.30.2.1.1.1;
next	;

1.30.2.1.1.1
date	96.11.28.15.32.32;	author hope;	state Exp;
branches;
next	;

1.30.3.1
date	96.11.22.18.39.12;	author hope;	state Exp;
branches;
next	;

1.30.4.1
date	96.12.17.18.18.13;	author hope;	state Exp;
branches
	1.30.4.1.1.1;
next	;

1.30.4.1.1.1
date	97.02.24.12.12.28;	author hope;	state Exp;
branches;
next	;

1.30.5.1
date	96.12.18.10.13.31;	author hope;	state Exp;
branches;
next	;

1.30.6.1
date	97.05.12.10.51.47;	author hope;	state Exp;
branches
	1.30.6.1.1.1
	1.30.6.1.2.1
	1.30.6.1.3.1;
next	;

1.30.6.1.1.1
date	97.07.28.18.33.36;	author daveb;	state Exp;
branches
	1.30.6.1.1.1.1.1;
next	;

1.30.6.1.1.1.1.1
date	97.10.07.11.59.35;	author jkbrook;	state Exp;
branches;
next	;

1.30.6.1.2.1
date	97.09.08.17.26.42;	author daveb;	state Exp;
branches;
next	;

1.30.6.1.3.1
date	97.09.09.14.23.33;	author daveb;	state Exp;
branches;
next	;

1.31.1.1
date	97.09.10.19.42.30;	author brucem;	state Exp;
branches;
next	;

1.31.2.1
date	97.09.11.21.10.01;	author daveb;	state Exp;
branches;
next	;

1.31.3.1
date	99.04.01.18.08.39;	author daveb;	state Exp;
branches;
next	;


desc
@Datatypes for several core static semantic objects
(see also simpletypes and basis)
@


1.31
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* _datatypes.sml the functor *)
(*
$Log: _datatypes.sml,v $
 * Revision 1.30  1996/10/04  15:35:44  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
 * Revision 1.29  1996/02/23  16:53:31  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.28  1996/02/21  17:16:47  jont
 * Removing map in favour of newmap
 *
 * Revision 1.27  1995/12/27  11:24:40  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.26  1995/03/24  16:13:41  matthew
Change tyfun_id etc. to stamp

Revision 1.25  1995/01/17  13:18:29  matthew
Rationalizing debugger

Revision 1.24  1994/06/17  10:44:24  jont
Allow alternative printing of types to include quantifiers

Revision 1.23  1994/05/05  13:26:57  daveb
META_OVERLOADED now includes the overloaded type variable and the location.
Overloaded schemes include the type variable.

Revision 1.22  1994/02/28  05:52:54  nosa
Debugger structures and extra TYNAME valenv for Modules Debugger.

Revision 1.21  1993/11/30  11:04:20  matthew
> Added is_abs field to TYNAME and METATYNAME

Revision 1.20  1993/11/25  09:34:07  nickh
Added code to encode type errors as a list of strings and types.

Revision 1.19  1993/09/22  12:48:10  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.18  1993/07/30  10:45:34  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.

Revision 1.17  1993/07/06  13:14:30  daveb
Removed exception environments and interfaces.

Revision 1.16  1993/04/06  12:04:32  jont
Added push and pop functions for the id counters

Revision 1.15  1993/03/09  12:53:20  matthew
Str to Structure

Revision 1.14  1993/02/08  11:49:34  matthew
Rationalised substructures

Revision 1.13  1993/02/05  15:07:20  matthew
Added COPYSTR representation of structures

Revision 1.12  1992/12/22  15:19:42  jont
Anel's last changes

Revision 1.11  1992/12/08  14:50:07  jont
Removed a number of duplicated signatures and structures

Revision 1.10  1992/10/27  19:04:52  jont
Modified to use less than functions for maps

Revision 1.9  1992/10/09  14:12:40  clive
Tynames now have a slot recording their definition point

Revision 1.8  1992/10/02  15:58:20  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.7  1992/08/11  10:55:09  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.6  1992/07/30  14:35:39  jont
Anel's changes to use NewMap instead of Map

Revision 1.5  1992/01/24  14:43:43  jont
Updated to allow valenv in METATYNAME

Revision 1.4  1992/01/14  16:23:16  jont
Changed ref unit in valenv to ref int to assist encoder

Revision 1.3  1991/11/21  16:45:11  jont
Added copyright message

Revision 1.2  91/06/17  17:13:00  nickh
Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures.

Revision 1.1  91/06/07  11:35:21  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/map";
require "../basics/ident";
require "stamp";
require "datatypes";

functor Datatypes (structure Stamp : STAMP
    		   structure Ident : IDENT
    		   structure NewMap : MAP
                  ) : DATATYPES = 
  struct
    structure Ident = Ident
    structure NewMap = NewMap
    structure Stamp = Stamp

    type Stamp= Stamp.Stamp
    type 'a StampMap = 'a Stamp.Map.T

    (****
     OverLoaded is used to indicate the form of the type of the different
     overloaded operations in the type schemes of VE in the initial basis:
        UNARY for num -> num
	BINARY for num * num -> num
	PREDICATE for num * num -> bool
     ****)

    datatype OverLoaded = 
      UNARY of Ident.ValId * Ident.TyVar | 
      BINARY of Ident.ValId * Ident.TyVar |
      PREDICATE of Ident.ValId * Ident.TyVar

    (****
     METASTRNAME is used to name signatures, the names of which can change 
     through sharing.  Initially they point to NULLNAME (unique strname_id).
     ****)

    datatype Strname = 
      STRNAME of Stamp.Stamp | 
      METASTRNAME of Strname ref |
      NULLNAME of Stamp.Stamp

    datatype InstanceInfo = 
      ZERO
    | ONE of int
    | TWO of int * int

    (****
     The different fields in the TYNAME constructor contain the following 
     info for each type name:
        Stamp  --> a unique identifier
	string     --> string which is printed when this type name is printed
	int        --> arity of the type name
	bool ref   --> equality attribute of the type name
	Valenv ref --> Constructor environment, used to find out the ML 
	               type associated with this type name during code 
		       generation. Also to elaborate the set of all
		       constructors for indexing, exhaustiveness etc.
        string     --> string describing the locational information for
                       this datatype

        ...

        int        --> level information for the type name.  See bug
                       1592 fix report, and the documentation
                       .typechecker.levels.doc.tynames, which lives
                       in MLW/design/typechecker_levels.doc


     METATYNAME is used to name flexible types descibed in signature 
     declarations.  They point to type functions because
        o when types are shared their type functions must be the same
        o in a type realisation type names are mapped to type functions
     The string, int, bool ref and Valenv ref fields contain the same info
     as for the TYNAME constructor.
     ****)

    datatype Tyname = 
      TYNAME of (Stamp.Stamp * string * int * bool ref 
                 * Valenv ref * string option * bool ref
                 * Valenv ref * int) |
      METATYNAME of (Tyfun ref * string * int * bool ref * Valenv ref * bool ref)
      (* Valenv ref added for code generator's benefit *)
    
    and Type =

      (****
       METATYVAR is a constructor for implicit type variables used during
       type inference.
	 int         --> level of type variable - used to indicate whether 
	                 the type can be schemified, i.e. closed over.
	 first bool  --> equality attribute
	 second bool --> imperative attribute
       ****)

      METATYVAR of ((int * Type * Instance) ref * bool * bool) |

      (****
       META_OVERLOADED is a constructor for overloaded type variables during
       type inference.  The tyvar is the tyvar ot be instantiated; the type
       is what it's instantiated to.  The valid and location are for errors.
       ****)

      META_OVERLOADED of
	(Type ref * Ident.TyVar * Ident.ValId * Ident.Location.T)|

      (****
       TYVAR is a constructor for explicit type variables.
         int --> level of type variable
       ****)

      TYVAR of ((int * Type * Instance) ref * Ident.TyVar) |

      (****
       METARECTYPE is a constructor for flexible record types.
         int        --> level of flexible record type
         first bool --> indicates whether the flexible record type is 
	                uninstantiated (not all fields are known) or
			instantiated. 
			If the value of this field is true this is an
			uninstantiated flexible rectype with Type a
			rectype containing all the available info in the 
			flexible record type.
			If the value is false Type is a rectype giving the
			rigid rectype or another metarectype if the instance
			of this metarectype is another flexible record type.
	 second bool --> equality attribute
	 third bool  --> imperative attribute
       ****)

      METARECTYPE of ((int * bool * Type * bool * bool) ref) |

      (****
       RECTYPE is the constructor for RecTypes.  It is represented as
       a mapping from labels to Types.
       ****)

      RECTYPE of (Ident.Lab,Type) NewMap.map |

      (****
       FUNTYPE is the constructor for FunTypes with fields for the 
       argument and result types.
       ****)

      FUNTYPE of (Type * Type) |

      (****
       CONSTYPE is the constructor for ConsTypes with fields for the type 
       name and list of types.
       ****)

      CONSTYPE of ((Type list) * Tyname) |

      (****
       DEBRUIJN is the constructor for the place holders for type variables 
       (explicit as well as implicit) in closed over type schemes.
          int         --> identifier for the debruijn variable
	  first bool  --> equality attribute
	  second bool --> imperative attribute
       ****)

      DEBRUIJN of (int * bool * bool 
                   * (int * Type * Instance) ref option) |

      (****
       Initially METATYVARS point to NULLTYPES.  NULLTYPE is replaced with 
       the actual type during type inference.
       ****)

      NULLTYPE
    
    and Tyfun =

      (****
       TYFUN is the constructors for type functions with int indicating
       the arity of the type function.
       ****)

      TYFUN of Type * int |

      (****
       ETA_TYFUN is the constructor for eta-convertable type functions.
       ****)

      ETA_TYFUN of Tyname |

      (****
       METATYNAME is instantiated to NULL_TYFUN for new flexible type
       names.
       ****)

      NULL_TYFUN of Stamp.Stamp * Tyfun ref

    and Typescheme =

      (****
       SCHEME is the constructor for the type scheme generalising the type 
       Type.  
	  int --> arity of Type
       ****)

      SCHEME of (int * (Type * (Instance ref * Instance ref option ref) option)) | 

      (****
       UNBOUND_SCHEME is the type scheme for types without any type 
       variables or for types with type variables which are still to 
       be schemified.
       ****)

      UNBOUND_SCHEME of Type * (Instance ref * Instance ref option ref) option |

      (****
       OVERLOADED_SCHEME is used for the type schemes of overloaded operations
       in the initial basis.
       ****)

      OVERLOADED_SCHEME of OverLoaded

      (****
       Some of the other compound semantic objects.
       ****)

    (* An instance of a type variable; 
       this information is used by the polymorphic debugger; 
       integers are passed around at runtime that point to the particular 
       instance in question *)
    and Instance = 
        INSTANCE of (int * Type * Instance) ref list
      | SIGNATURE_INSTANCE of InstanceInfo
      | NO_INSTANCE

    and Valenv = VE of int ref * ((Ident.ValId,Typescheme) NewMap.map)

      (* unit ref is used for doing `eq' on valenv's for encoding and
       decoding these (circular) data structures *)

    and Tystr = TYSTR of (Tyfun * Valenv)

    and Tyenv = TE of (Ident.TyCon,Tystr) NewMap.map

    and Env = ENV of (Strenv * Tyenv * Valenv)

    and Structure =
      STR of (Strname * MLWorks.Internal.Value.ml_value option ref * Env) |
      COPYSTR of ((Strname StampMap * Tyname StampMap) * Structure)

    and Strenv = SE of (Ident.StrId,Structure) NewMap.map

    datatype DebuggerStr = 
      DSTR of (Ident.StrId,DebuggerStr) NewMap.map * (Ident.TyCon,int) NewMap.map 
      * (Ident.ValId,int option) NewMap.map |
      EMPTY_DSTR
  
    val empty_valenv = VE (ref 0,NewMap.empty (Ident.valid_lt, Ident.valid_eq))

    (* atoms for a type error message, which is a list of these atoms.
     This is so tyvars in separate types printed in a message match up; see
     Types.print_type_with_seen_tyvars and Completion.report_type_error *)

    datatype type_error_atom =
        Err_String of string
      | Err_Type of Type	(* print a type with remembered tyvars *)
      | Err_Scheme of Type      (* Print a type with quantifiers *)
      | Err_Reset		(* reset remembered tyvars *)

  end
@


1.31.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.31  1997/05/01  12:53:49  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.31.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.31  1997/05/01  12:53:49  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.31.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.31  1997/05/01  12:53:49  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.30
log
@[Bug #1592]
Threading extra level argument through tynames.
@
text
@d4 4
d180 1
a180 1
                 * Valenv ref * string MLWorks.Option.option * bool ref
d263 1
a263 1
                   * (int * Type * Instance) ref MLWorks.Option.option) |
d302 1
a302 1
      SCHEME of (int * (Type * (Instance ref * Instance ref MLWorks.Option.option ref) MLWorks.Option.option)) | 
d310 1
a310 1
      UNBOUND_SCHEME of Type * (Instance ref * Instance ref MLWorks.Option.option ref) MLWorks.Option.option |
d344 1
a344 1
      STR of (Strname * MLWorks.Internal.Value.ml_value MLWorks.Option.option ref * Env) |
d351 1
a351 1
      * (Ident.ValId,int MLWorks.Option.option) NewMap.map |
@


1.30.6.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:35:44  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.30.6.1  1997/05/12  10:51:47  hope
 * branched from 1.30
 *
@


1.30.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.30.6.1  1997/05/12  10:51:47  hope
 * branched from 1.30
 *
@


1.30.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.30.6.1  1997/05/12  10:51:47  hope
 * branched from 1.30
 *
@


1.30.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.30.6.1.1.1  1997/07/28  18:33:36  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.30.5.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:35:44  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.4.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:35:44  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.4.1.1.1
log
@branched from 1.30.4.1
@
text
@a3 3
 * Revision 1.30.4.1  1996/12/17  18:18:13  hope
 * branched from 1.30
 *
@


1.30.3.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:35:44  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.2.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:35:44  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.2.1.1.1
log
@branched from 1.30.2.1
@
text
@a3 3
 * Revision 1.30.2.1  1996/11/14  13:21:32  hope
 * branched from 1.30
 *
@


1.30.1.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:35:44  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.29
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
d155 10
a164 1
        string     --> string describing the locational information for this datatype
d176 2
a177 1
                 * Valenv ref * string MLWorks.Option.option * bool ref * Valenv ref) |
@


1.29.2.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/02/23  16:53:31  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.29.1.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/02/23  16:53:31  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.28
log
@Removing map in favour of newmap
@
text
@d4 3
d96 1
a96 1
require "../utils/newmap";
d103 1
a103 1
    		   structure NewMap : NEWMAP
d221 1
a221 1
      RECTYPE of (Ident.Lab,Type) NewMap.T |
d315 1
a315 1
    and Valenv = VE of int ref * ((Ident.ValId,Typescheme) NewMap.T)
d322 1
a322 1
    and Tyenv = TE of (Ident.TyCon,Tystr) NewMap.T
d330 1
a330 1
    and Strenv = SE of (Ident.StrId,Structure) NewMap.T
d333 2
a334 2
      DSTR of (Ident.StrId,DebuggerStr) NewMap.T * (Ident.TyCon,int) NewMap.T 
      * (Ident.ValId,int MLWorks.Option.option) NewMap.T |
@


1.27
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
a92 1
require "../utils/map";
d98 1
a98 2
functor Datatypes (structure Mapping : MAP
                   structure Stamp : STAMP
a104 1
    structure Mapping = Mapping
d218 1
a218 1
      RECTYPE of (Ident.Lab,Type) Mapping.Map |
@


1.26
log
@Change tyfun_id etc. to stamp
@
text
@d4 3
a90 1
require "../utils/option";
a96 1
                   structure Option : OPTION
a104 1
    structure Option = Option
d161 1
a161 1
                 * Valenv ref * string Option.opt * bool ref * Valenv ref) |
d243 1
a243 1
                   * (int * Type * Instance) ref Option.opt) |
d282 1
a282 1
      SCHEME of (int * (Type * (Instance ref * Instance ref Option.opt ref) Option.opt)) | 
d290 1
a290 1
      UNBOUND_SCHEME of Type * (Instance ref * Instance ref Option.opt ref) Option.opt |
d324 1
a324 1
      STR of (Strname * MLWorks.Internal.Value.ml_value Option.opt ref * Env) |
d331 1
a331 1
      * (Ident.ValId,int Option.opt) NewMap.T |
@


1.25
log
@Rationalizing debugger
@
text
@d4 3
d91 1
a91 1
require "simpletypes";
d96 1
a96 3
		   structure Tyname_id : TYNAME_ID
		   structure Tyfun_id : TYFUN_ID
		   structure Strname_id : STRNAME_ID
d105 4
a108 3
    structure Tyname_id = Tyname_id
    structure Tyfun_id = Tyfun_id
    structure Strname_id = Strname_id
d129 1
a129 1
      STRNAME of Strname_id.Strname_id | 
d131 1
a131 1
      NULLNAME of Strname_id.Strname_id
d141 1
a141 1
        Tyname_id  --> a unique identifier
d160 1
a160 1
      TYNAME of (Tyname_id.Tyname_id * string * int * bool ref 
d272 1
a272 1
      NULL_TYFUN of Tyfun_id.Tyfun_id * Tyfun ref
d325 1
a325 1
      COPYSTR of ((Strname Strname_id.Map.T * Tyname Tyfun_id.Map.T) * Structure)
a334 10

    fun push_counters() =
      (Tyname_id.push_counter();
       Strname_id.push_counter();
       Tyfun_id.push_counter())
       
    fun pop_counters() =
      (Tyname_id.pop_counter();
       Strname_id.pop_counter();
       Tyfun_id.pop_counter())
@


1.24
log
@Allow alternative printing of types to include quantifiers
@
text
@d4 3
d131 5
d307 1
a307 1
      | SIGNATURE_INSTANCE of int list
@


1.23
log
@META_OVERLOADED now includes the overloaded type variable and the location.
Overloaded schemes include the type variable.
@
text
@d4 4
d343 1
@


1.22
log
@Debugger structures and extra TYNAME valenv for Modules Debugger.
@
text
@d4 3
d102 2
a103 2
     Over_Loaded is used to indicate the type of the different overloaded 
     operations in the type schemes of VE in the initial basis:
d110 3
a112 3
      UNARY of Ident.ValId | 
      BINARY of Ident.ValId |
      PREDICATE of Ident.ValId
d166 2
a167 1
       type inference.
d170 2
a171 1
      META_OVERLOADED  of (Type ref * Ident.ValId)|
@


1.21
log
@> Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d144 1
a144 1
                 * Valenv ref * string Option.opt * bool ref) |
d159 1
a159 1
      METATYVAR of ((int * Type * instance) ref * bool * bool) |
d173 1
a173 1
      TYVAR of ((int * Type * instance) ref * Ident.TyVar) |
d224 1
a224 1
                   * (int * Type * instance) ref Option.opt) |
d253 1
a253 1
      NULL_TYFUN of Tyfun_id.Tyfun_id * Tyfun ref Option.opt
d263 1
a263 1
      SCHEME of (int * (Type * (instance ref * instance ref Option.opt ref) Option.opt)) | 
d271 1
a271 1
      UNBOUND_SCHEME of Type * (instance ref * instance ref Option.opt ref) Option.opt |
d288 2
a289 2
    and instance = 
        INSTANCE of (int * Type * instance) ref list 
d309 5
d316 1
a316 1
  
@


1.20
log
@Added code to encode type errors as a list of strings and types.
@
text
@d4 3
d141 2
a142 2
                 * Valenv ref * string Option.opt) |
      METATYNAME of (Tyfun ref * string * int * bool ref * Valenv ref)
@


1.19
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d315 10
@


1.18
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.
@
text
@d4 5
d150 1
a150 1
      METATYVAR of ((int * Type) ref * bool * bool) |
d164 1
a164 1
      TYVAR of (int ref * Ident.TyVar) |
d214 2
a215 1
      DEBRUIJN of (int * bool * bool) |
d254 1
a254 1
      SCHEME of (int * Type) | 
d262 1
a262 1
      UNBOUND_SCHEME of Type  |
d275 9
d302 1
a302 1

@


1.18.1.1
log
@Fork for bug fixing
@
text
@a3 5
Revision 1.18  1993/07/30  10:45:34  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.

@


1.17
log
@Removed exception environments and interfaces.
@
text
@d4 3
d61 1
d68 1
d79 1
a83 3

    datatype 'a opt = PRESENT of 'a | ABSENT

d129 2
a130 1
      TYNAME of (Tyname_id.Tyname_id * string * int * bool ref * Valenv ref * string opt) |
d238 1
a238 1
      NULL_TYFUN of Tyfun_id.Tyfun_id
d248 1
a248 1
      SCHEME of (int * Type) |
d256 1
a256 1
      UNBOUND_SCHEME of Type |
d281 1
a281 1
      STR of (Strname * MLWorks.Internal.Value.ml_value opt ref * Env) |
@


1.16
log
@Added push and pop functions for the id counters
@
text
@d4 3
d58 2
a59 1
require "interface";
d67 3
a69 2
                   structure Interface : INTERFACE
                     ) : DATATYPES = 
d71 2
a72 2
    structure Ident = Interface.Ident
    structure NewMap = Interface.NewMap
a76 1
    structure Interface = Interface
d274 1
a274 1
    and Env = ENV of (Strenv * Tyenv * Valenv * Valenv)
d277 1
a277 1
      STR of (Strname * Interface.Int opt ref * Env) |
@


1.15
log
@Str to Structure
@
text
@d4 3
d280 9
@


1.14
log
@Rationalised substructures
@
text
@d4 3
d269 1
a269 1
    and Str =
d271 1
a271 1
      COPYSTR of ((Strname Strname_id.Map.T * Tyname Tyfun_id.Map.T) * Str)
d273 1
a273 1
    and Strenv = SE of (Ident.StrId,Str) NewMap.T
@


1.13
log
@Added COPYSTR representation of structures
@
text
@d4 3
a47 1
require "datatypes";
a48 2
require "../utils/newmap";
require "../basics/ident";
d51 1
a53 2
		   structure NewMap : NEWMAP
		   structure Ident : IDENT
a57 2
                   sharing Interface.Ident = Ident
                   sharing Interface.NewMap = NewMap
d60 2
a62 2
    structure NewMap = NewMap
    structure Ident = Ident
@


1.12
log
@Anel's last changes
@
text
@d4 3
d49 1
d57 5
a61 1
		   structure Strname_id : STRNAME_ID) : DATATYPES = 
d69 4
a117 2
    datatype TypeLocation = PRESENT of string | ABSENT
 
d119 1
a119 1
      TYNAME of (Tyname_id.Tyname_id * string * int * bool ref * Valenv ref * TypeLocation) |
d269 3
a271 1
    and Str = STR of (Strname * Env)
a277 2


@


1.11
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d70 4
a73 1
    datatype Over_Loaded = UNARY | BINARY | PREDICATE
d131 1
a131 1
      META_OVERLOADED  of Type ref |
d242 1
a242 1
      OVERLOADED_SCHEME of Over_Loaded
@


1.10
log
@Modified to use less than functions for maps
@
text
@d4 3
a255 37

    fun strid_order x =
      Ident.strid_eq x 
      orelse Ident.strid_order x 

    fun tycon_order x =
      Ident.tycon_eq x 
      orelse Ident.tycon_order x 

    fun valid_order (id,id') = 
      let
        fun strip (Ident.VAR sym) = sym
          | strip (Ident.CON sym) = sym
          | strip (Ident.EXCON sym) = sym
        
        val sym = strip id
        val sym' = strip id'
      in
        sym = sym'
        orelse Ident.Symbol.symbol_order (sym,sym') 
      end
  
    val strid_equal = Ident.strid_eq 

    val tycon_equal = Ident.tycon_eq 

    fun valid_equal (id,id') = 
      let
        fun strip (Ident.VAR sym) = sym
          | strip (Ident.CON sym) = sym
          | strip (Ident.EXCON sym) = sym
        
        val sym = strip id
        val sym' = strip id'
      in
        sym = sym'
      end
@


1.9
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d291 1
a291 1
    val empty_valenv = VE (ref 0,NewMap.empty (valid_order,valid_equal))
@


1.8
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d84 1
d94 2
d97 1
a97 1
      TYNAME of (Tyname_id.Tyname_id * string * int * bool ref * Valenv ref) |
@


1.7
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d246 2
a247 6
      if Ident.strid_eq x 
        then NewMap.EQUAL
      else
        if Ident.strid_order x 
          then NewMap.LESS
        else NewMap.GREATER
d250 2
a251 6
      if Ident.tycon_eq x 
        then NewMap.EQUAL
      else
        if Ident.tycon_order x 
          then NewMap.LESS
        else NewMap.GREATER
d262 2
a263 6
        if sym = sym'
          then NewMap.EQUAL
        else
          if Ident.Symbol.symbol_order (sym,sym') 
            then NewMap.LESS
          else NewMap.GREATER
d266 17
a282 1
    val empty_valenv = VE (ref 0,NewMap.empty valid_order)
@


1.6
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d25 1
a29 1
require "../basics/identprint";
a34 1
		   structure IdentPrint : IDENTPRINT
d37 1
a37 2
		   structure Strname_id : STRNAME_ID
		   sharing IdentPrint.Ident = Ident) : DATATYPES = 
a41 1
    structure IdentPrint = IdentPrint
@


1.5
log
@Updated to allow valenv in METATYNAME
@
text
@d4 3
d24 1
d30 1
d39 1
d226 1
a226 1
    and Valenv = VE of int ref * ((Ident.ValId,Typescheme) Mapping.Map)
d233 1
a233 1
    and Tyenv = TE of (Ident.TyCon,Tystr) Mapping.Map
d239 36
a274 1
    and Strenv = SE of (Ident.StrId,Str) Mapping.Map
@


1.4
log
@Changed ref unit in valenv to ref int to assist encoder
@
text
@d4 3
d69 2
a70 1
		       generation.
d76 2
a77 2
     The string, int and bool ref fields contain the same info as for
     the TYNAME constructor.
d82 2
a83 1
      METATYNAME of (Tyfun ref * string * int * bool ref)
@


1.3
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_datatypes.sml,v $
d72 1
a72 1
     The string, int and bool ref fileds contain the same info as for
d215 1
a215 1
    and Valenv = VE of unit ref * ((Ident.ValId,Typescheme) Mapping.Map)
@


1.2
log
@Modified to take new ValEnv definition with ref unit to allow
reading and writing of circular data structures.
@
text
@d1 1
d4 4
d11 1
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d206 4
a209 1
    and Valenv = VE of (Ident.ValId,Typescheme) Mapping.Map
@
