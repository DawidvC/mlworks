head	1.26;
access;
symbols
	MLW_daveb_inline_1_4_99:1.26.1
	MLWorks_21c0_1999_03_25:1.26
	MLWorks_20c1_1998_08_20:1.25
	MLWorks_20c0_1998_08_04:1.25
	MLWorks_20b2c2_1998_06_19:1.25
	MLWorks_20b2_Windows_1998_06_12:1.25
	MLWorks_20b1c1_1998_05_07:1.25
	MLWorks_20b0_1998_04_07:1.25
	MLWorks_20b0_1998_03_20:1.25
	MLWorks_20m2_1998_02_16:1.25
	MLWorks_20m1_1997_10_23:1.25
	MLWorks_11r1:1.25.5.1.1.1.1
	MLWorks_workspace_97:1.25.7
	MLWorks_dt_wizard:1.25.6
	MLWorks_11c0_1997_09_09:1.25.5.1.1.1
	MLWorks_10r3:1.25.5.1.3
	MLWorks_10r2_551:1.25.5.1.2
	MLWorks_11:1.25.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.25.5.1
	MLWorks_20m0_1997_06_20:1.25
	MLWorks_1_0_r2c2_1997_06_14:1.25.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.25.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.25.5
	MLWorks_BugFix_1997_04_24:1.25
	MLWorks_1_0_r2_Win32_1997_04_11:1.25
	MLWorks_1_0_r2_Unix_1997_04_04:1.25
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.25.3.1.1
	MLWorks_gui_1996_12_18:1.25.4
	MLWorks_1_0_Win32_1996_12_17:1.25.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.25.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.25.1.1
	MLWorks_1_0_Irix_1996_11_28:1.25.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.25.2
	MLWorks_1_0_Unix_1996_11_14:1.25.1
	MLWorks_Open_Beta2_1996_10_11:1.23.3
	MLWorks_License_dev:1.23.2
	MLWorks_1_open_beta_1996_09_13:1.23.1
	MLWorks_Open_Beta_1996_08_22:1.23
	MLWorks_Beta_1996_07_02:1.23
	MLWorks_Beta_1996_06_07:1.23
	MLWorks_Beta_1996_06_06:1.23
	MLWorks_Beta_1996_06_05:1.23
	MLWorks_Beta_1996_06_03:1.23
	MLWorks_Beta_1996_05_31:1.23
	MLWorks_Beta_1996_05_30:1.23
	ML_beta_release_12/08/94:1.20
	ML_beta_release_03/08/94:1.20
	ML_revised_beta_release_25/05/94:1.20
	ML_final_beta_release_02/03/94:1.20
	mlworks-28-01-1994:1.20
	Release:1.17
	mlworks-beta-01-09-1993:1.17
	MLWorks-1-0-4-29/01/1993:1.12
	MLWorks-1-0-3-21/12/1992:1.12
	MLWorks-1-0-2-15/12/1992:1.12
	MLWorks-1-0-1-04/12/1992:1.12
	checkpoint_17_08_92:1.6
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.26
date	99.02.02.16.01.49;	author mitchell;	state Exp;
branches
	1.26.1.1;
next	1.25;

1.25
date	96.11.06.11.33.37;	author matthew;	state Exp;
branches
	1.25.1.1
	1.25.2.1
	1.25.3.1
	1.25.4.1
	1.25.5.1
	1.25.6.1
	1.25.7.1;
next	1.24;

1.24
date	96.10.28.17.38.53;	author io;	state Exp;
branches;
next	1.23;

1.23
date	96.04.30.15.33.36;	author jont;	state Exp;
branches
	1.23.1.1
	1.23.2.1
	1.23.3.1;
next	1.22;

1.22
date	96.04.29.14.03.11;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	95.02.07.16.08.50;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.12.16.11.39.54;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.12.08.11.08.04;	author nickh;	state Exp;
branches;
next	1.18;

1.18
date	93.08.16.10.54.13;	author nosa;	state Exp;
branches;
next	1.17;

1.17
date	93.05.18.18.15.41;	author jont;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	93.03.09.13.05.13;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.03.03.16.54.48;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.02.22.12.52.54;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.02.08.18.27.45;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.12.04.12.10.20;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	92.12.03.10.18.06;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	92.12.02.16.46.13;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.11.04.17.42.34;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	92.09.08.17.24.42;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	92.09.04.14.20.29;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	92.08.11.18.52.17;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.08.05.12.26.32;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.04.14.15.13.12;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.01.27.20.16.03;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.21.16.48.11;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.39.05;	author colin;	state Exp;
branches;
next	;

1.17.1.1
date	93.05.18.18.15.41;	author jont;	state Exp;
branches;
next	;

1.23.1.1
date	96.09.13.11.41.25;	author hope;	state Exp;
branches;
next	;

1.23.2.1
date	96.10.07.16.34.29;	author hope;	state Exp;
branches;
next	;

1.23.3.1
date	96.10.17.11.53.36;	author hope;	state Exp;
branches;
next	;

1.25.1.1
date	96.11.14.13.21.11;	author hope;	state Exp;
branches
	1.25.1.1.1.1;
next	;

1.25.1.1.1.1
date	96.11.28.15.32.14;	author hope;	state Exp;
branches;
next	;

1.25.2.1
date	96.11.22.18.38.57;	author hope;	state Exp;
branches;
next	;

1.25.3.1
date	96.12.17.18.17.58;	author hope;	state Exp;
branches
	1.25.3.1.1.1;
next	;

1.25.3.1.1.1
date	97.02.24.12.12.14;	author hope;	state Exp;
branches;
next	;

1.25.4.1
date	96.12.18.10.13.14;	author hope;	state Exp;
branches;
next	;

1.25.5.1
date	97.05.12.10.51.32;	author hope;	state Exp;
branches
	1.25.5.1.1.1
	1.25.5.1.2.1
	1.25.5.1.3.1;
next	;

1.25.5.1.1.1
date	97.07.28.18.33.23;	author daveb;	state Exp;
branches
	1.25.5.1.1.1.1.1;
next	;

1.25.5.1.1.1.1.1
date	97.10.07.11.59.21;	author jkbrook;	state Exp;
branches;
next	;

1.25.5.1.2.1
date	97.09.08.17.26.28;	author daveb;	state Exp;
branches;
next	;

1.25.5.1.3.1
date	97.09.09.14.23.18;	author daveb;	state Exp;
branches;
next	;

1.25.6.1
date	97.09.10.19.42.16;	author brucem;	state Exp;
branches;
next	;

1.25.7.1
date	97.09.11.21.09.47;	author daveb;	state Exp;
branches;
next	;

1.26.1.1
date	99.04.01.18.08.31;	author daveb;	state Exp;
branches;
next	;


desc
@Type Checking of explicit type constraints
@


1.26
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _type_exp.sml the functor *)
(*
$Log: _type_exp.sml,v $
 * Revision 1.25  1996/11/06  11:33:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.24  1996/10/28  17:38:53  io
 * moving String from toplevel
 *
 * Revision 1.23  1996/04/30  15:33:36  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.22  1996/04/29  14:03:11  matthew
 * Removing MLWorks.Integer.
 *
 * Revision 1.21  1995/02/07  16:08:50  matthew
 * Changes to lookup exceptions
 *
Revision 1.20  1993/12/16  11:39:54  matthew
Renamed Basis.level to Basis.context_level

Revision 1.19  1993/12/08  11:08:04  nickh
Suppress error message with unknown location; bugfix 355.

Revision 1.18  1993/08/16  10:54:13  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.17  1993/05/18  18:15:41  jont
Removed integer parameter

Revision 1.16  1993/03/09  13:05:13  matthew
Options & Info changes
Absyn changes

Revision 1.14  1993/02/22  12:52:54  matthew
Changed arity error message
Removed debug statements.

Revision 1.13  1993/02/08  18:27:45  matthew
Changes for BASISTYPES signature

Revision 1.12  1992/12/04  12:10:20  matthew
Error message revision

Revision 1.11  1992/12/03  10:18:06  daveb
Added Integer parameter to functor.

Revision 1.10  1992/12/02  16:46:13  jont
Error message improvements

Revision 1.9  1992/11/04  17:42:34  matthew
Changed Error structure to Info

Revision 1.8  1992/09/08  17:24:42  matthew
Added locations to error messages.

Revision 1.7  1992/09/04  14:20:29  richard
Installed central error reporting mechanism.

Revision 1.6  1992/08/11  18:52:17  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.5  1992/08/05  12:26:32  jont
Anel's changes to use NewMap instead of Map

Revision 1.4  1992/04/14  15:13:12  jont
Some improvements from Anel

Revision 1.3  1992/01/27  20:16:03  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.2  1991/11/21  16:48:11  jont
Added copyright message

Revision 1.1  91/06/07  11:39:05  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";

require "../basics/absyn";
require "../main/info";
require "../basics/identprint";
require "../typechecker/types";
require "../typechecker/basis";

require "../typechecker/type_exp";

functor Type_exp(
  structure IdentPrint: IDENTPRINT
  structure Absyn     : ABSYN
  structure Types     : TYPES
  structure Basis     : BASIS
  structure Info      : INFO
 
  sharing Types.Datatypes = Basis.BasisTypes.Datatypes
  sharing Absyn.Set = Basis.BasisTypes.Set
  sharing Absyn.Ident.Location = Info.Location
  sharing IdentPrint.Ident = Types.Datatypes.Ident = Absyn.Ident

  sharing type Absyn.Type = Types.Datatypes.Type
  sharing type Absyn.Structure = Types.Datatypes.Structure
) : TYPE_EXP =
  
  struct
    structure Datatypes = Types.Datatypes
    structure Absyn     = Absyn
    structure BasisTypes = Basis.BasisTypes
    structure Info = Info

    open Datatypes

    fun fresh_tyvar(acontext, eq, imp) =
      METATYVAR (ref (Basis.context_level acontext,NULLTYPE,NO_INSTANCE), eq, imp)


    fun check_type options args = 
      let 
        fun report_error args = Info.error options args
        

    (* ****** Type Expressions ****** *)
    
    (* rules 47, 48, 49, 50 *)

    (****
     If there is no type for the tyvar a new one is created with level ~1 
     thus it will never be closed over;  therefore escaping at top level.
     ****)

    fun check_type (Absyn.TYVARty tyvar,context) =
      (Basis.lookup_tyvar (tyvar,context)
       handle Basis.LookupTyvar => 
         TYVAR (ref (~1,NULLTYPE,NO_INSTANCE),tyvar))
      
      | check_type (Absyn.RECORDty (alab_ty_list),acontext) = 
        let 
          fun tyrowlist ([],context) = Types.empty_rectype
            | tyrowlist ((lab,ty)::rest,context) =
              Types.add_to_rectype (lab,check_type (ty,context),
                                    tyrowlist (rest,context))
        in
          tyrowlist (alab_ty_list,acontext) 
        end

      | check_type (Absyn.APPty (tylist,ltycon,location),acontext) =
        (let 
          val TYSTR (atyfun,x) =
            Basis.lookup_longtycon (ltycon,acontext)
          fun make_type_list [] = []
            | make_type_list (h::t) =
              check_type (h,acontext)::(make_type_list t)
        in
          if Types.arity (atyfun) = length (tylist) then
            Types.apply (atyfun,make_type_list tylist)
          else
            (report_error
             (Info.RECOVERABLE, location, 
              concat ["Wrong number of arguments to type constructor ",
                       IdentPrint.printLongTyCon ltycon,
                       ": ",
                       Int.toString(Types.arity atyfun),
                       " required, ",
                       Int.toString(length tylist),
                       " supplied"]);
             fresh_tyvar (acontext, false, false))
        end
        handle Basis.LookupTyCon tycon =>
	  (* if we hit an unbound tycon, we should usually report it.
	   * The exception is in the withtype derived forms, when
	   * we've substituted into the body of a datatype. We should
	   * not report tycons in the substitution, because they don't
	   * correspond to user code. The error will be reported later
	   * when we check the typedec.	 We mark these cases (when
	   * parsing the derived form) with an UNKNOWN location. *)
          (case location of
             Info.Location.UNKNOWN => ()
           | l => 
               report_error
               (Info.RECOVERABLE, l,
                IdentPrint.unbound_longtycon_message (tycon,ltycon));
           fresh_tyvar (acontext, false, false))
             | Basis.LookupStrId strid =>
                 (case location of
                    Info.Location.UNKNOWN => ()
                  | l => 
                      report_error
                      (Info.RECOVERABLE, l,
                       IdentPrint.tycon_unbound_strid_message (strid,ltycon));
                      fresh_tyvar (acontext, false, false)))
                 

      | check_type (Absyn.FNty (ty,ty'),acontext) =
        FUNTYPE (check_type (ty,acontext),check_type (ty',acontext))
      in
        check_type args
      end
  end;
@


1.26.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.26  1999/02/02  16:01:49  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.25
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
a88 1
require "../utils/lists";
@


1.25.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.25  1996/11/06  11:33:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.25.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.25  1996/11/06  11:33:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.25.5.1
log
@branched from 1.25
@
text
@a3 4
 * Revision 1.25  1996/11/06  11:33:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.25.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.25.5.1  1997/05/12  10:51:32  hope
 * branched from 1.25
 *
@


1.25.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.25.5.1  1997/05/12  10:51:32  hope
 * branched from 1.25
 *
@


1.25.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.25.5.1  1997/05/12  10:51:32  hope
 * branched from 1.25
 *
@


1.25.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.25.5.1.1.1  1997/07/28  18:33:23  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.25.4.1
log
@branched from 1.25
@
text
@a3 4
 * Revision 1.25  1996/11/06  11:33:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.25.3.1
log
@branched from 1.25
@
text
@a3 4
 * Revision 1.25  1996/11/06  11:33:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.25.3.1.1.1
log
@branched from 1.25.3.1
@
text
@a3 3
 * Revision 1.25.3.1  1996/12/17  18:17:58  hope
 * branched from 1.25
 *
@


1.25.2.1
log
@branched from 1.25
@
text
@a3 4
 * Revision 1.25  1996/11/06  11:33:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.25.1.1
log
@branched from 1.25
@
text
@a3 4
 * Revision 1.25  1996/11/06  11:33:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.25.1.1.1.1
log
@branched from 1.25.1.1
@
text
@a3 3
 * Revision 1.25.1.1  1996/11/14  13:21:11  hope
 * branched from 1.25
 *
@


1.24
log
@moving String from toplevel
@
text
@d4 3
d83 1
a83 1
require "../basis/__integer";
@


1.23
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
a91 1
  structure Lists     : LISTS
d156 1
a156 1
          if Types.arity (atyfun) = Lists.length (tylist) then
d161 1
a161 1
              String.implode ["Wrong number of arguments to type constructor ",
d166 1
a166 1
                       Int.toString(Lists.length tylist),
@


1.23.3.1
log
@branched from 1.23
@
text
@a3 6
 * Revision 1.23  1996/04/30  15:33:36  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.23.2.1
log
@branched from 1.23
@
text
@a3 6
 * Revision 1.23  1996/04/30  15:33:36  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.23.1.1
log
@branched from 1.23
@
text
@a3 6
 * Revision 1.23  1996/04/30  15:33:36  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.22
log
@Removing MLWorks.Integer.
@
text
@d4 3
d156 1
a156 1
              implode ["Wrong number of arguments to type constructor ",
@


1.21
log
@Changes to lookup exceptions
@
text
@d4 3
d71 2
d156 1
a156 1
                       MLWorks.Integer.makestring(Types.arity atyfun),
d158 1
a158 1
                       MLWorks.Integer.makestring(Lists.length tylist),
@


1.20
log
@Renamed Basis.level to Basis.context_level
@
text
@d4 3
d69 1
a69 1
require "../utils/print";
a71 1
require "../basics/absyn";
a72 1
require "../typechecker/tyvarenv";
a78 1
  structure Print     : PRINT
a81 1
  structure Tyvarenv  : TYVARENV
a84 1
  sharing Tyvarenv.BasisTypes = Basis.BasisTypes
d120 3
a122 3
    fun check_type (Absyn.TYVARty (tyvar),BasisTypes.CONTEXT (_,_,_,tyvarenv)) =
      (Tyvarenv.lookup (tyvar,tyvarenv) 
       handle Tyvarenv.Lookup_in_Tyvarenv => 
d135 1
a135 1
      | check_type (Absyn.APPty (tylist,longtycon,location),acontext) =
d138 1
a138 1
            Basis.lookup_longtycon (longtycon,acontext)
d149 1
a149 1
                       IdentPrint.printLongTyCon longtycon,
d157 1
a157 1
        handle Basis.LookupLongTyCon =>
d165 16
a180 7
          ((case location of
	      Info.Location.UNKNOWN => ()
	    | l => report_error
		(Info.RECOVERABLE, l,
		 "Unbound type constructor " ^ 
		 IdentPrint.printLongTyCon longtycon));
	   fresh_tyvar (acontext, false, false)))
@


1.19
log
@Suppress error message with unknown location; bugfix 355.
@
text
@d4 3
d105 1
a105 1
      METATYVAR (ref (Basis.level acontext,NULLTYPE,NO_INSTANCE), eq, imp)
@


1.18
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d157 14
a170 5
          (report_error
           (Info.RECOVERABLE, location,
            "Unbound type constructor " ^ 
            IdentPrint.printLongTyCon longtycon);
           fresh_tyvar (acontext, false, false)))
@


1.17
log
@Removed integer parameter
@
text
@d4 3
d99 1
a99 1
      METATYVAR (ref (Basis.level acontext,NULLTYPE), eq, imp)
d118 2
a119 1
       handle Tyvarenv.Lookup_in_Tyvarenv => TYVAR (ref (~1),tyvar))
@


1.17.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.17  1993/05/18  18:15:41  jont
Removed integer parameter

@


1.16
log
@Options & Info changes
Absyn changes
@
text
@d4 4
a56 1
require "../utils/integer";
a68 1
  structure Integer   : INTEGER
d143 1
a143 1
                       Integer.makestring(Types.arity atyfun),
d145 1
a145 1
                       Integer.makestring(Lists.length tylist),
@


1.15
log
@Rationalised use of Mapping structure
@
text
@d55 1
d73 1
d76 1
a76 1
  sharing Absyn.Datatypes = Types.Datatypes = Basis.BasisTypes.Datatypes
d78 5
a82 2
  sharing Absyn.Location = Basis.BasisTypes.Info.Location
  sharing IdentPrint.Ident = Types.Datatypes.Ident
d89 1
a89 1
    structure Info = Basis.BasisTypes.Info
@


1.14
log
@Changed arity error message
Removed debug statements.
@
text
@d4 4
d55 1
a56 2
require "../basics/identprint";
require "../main/info";
d59 2
a61 1
require "basis";
d72 1
a72 1

d112 1
a112 1
          fun tyrowlist ([],context) = RECTYPE (Mapping.empty_map)
a153 2

	   
a154 5
  




@


1.13
log
@Changes for BASISTYPES signature
@
text
@d4 3
a53 1
require "../typechecker/ty_debug";
a64 1
  structure Ty_Debug  : TY_DEBUG
d68 1
a68 5
  structure Debug     :
    sig
      val set_debug_level : int -> unit
      val debug_level : unit -> int
    end
a80 1
    val do_debug = Ty_Debug.do_debug
d103 2
a104 8
      (if do_debug andalso Debug.debug_level () > 10 then 
	 (Print.print ("check_type 47");
	  Print.print ("tyvar = ");
	  Print.print (IdentPrint.printTyVar (tyvar));
	  Print.print ("\n"))
       else ();
	 (Tyvarenv.lookup (tyvar,tyvarenv) 
	  handle Tyvarenv.Lookup_in_Tyvarenv => TYVAR (ref (~1),tyvar)))
d107 8
a114 12
	(if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("check_type 48");
	    Print.print ("\n"))
	 else ();
	   let 
	     fun tyrowlist ([],context) = RECTYPE (Mapping.empty_map)
	       | tyrowlist ((lab,ty)::rest,context) =
		 Types.add_to_rectype (lab,check_type (ty,context),
				       tyrowlist (rest,context))
	   in
	     tyrowlist (alab_ty_list,acontext) 
	   end)
d117 27
a143 35
	(if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("check_type 49");
	    Print.print ("\n"))
	 else ();
	   (let 
	      val TYSTR (atyfun,x) =
		Basis.lookup_longtycon (longtycon,acontext)
	      fun make_type_list [] = []
		| make_type_list (h::t) =
		  (if do_debug andalso Debug.debug_level () > 10 then 
		     (Print.print ("make_type_list in 49");
		      Print.print ("\n"))
		   else ();
		     check_type (h,acontext)::(make_type_list t))
	    in
	      if Types.arity (atyfun) = Lists.length (tylist) then
                Types.apply (atyfun,make_type_list tylist)
	      else
                (report_error
                 (Info.RECOVERABLE, location, 
                               implode ["Arity mismatch in type expression:",
                                        "\n  Arity of ",
                                        IdentPrint.printLongTyCon longtycon,
                                        ": ",
                                        Integer.makestring(Types.arity atyfun),
                                        "\n  Number of arguments: ",
                                        Integer.makestring(Lists.length tylist)]);
                 fresh_tyvar (acontext, false, false))
	    end)
	      handle Basis.LookupLongTyCon =>
                (report_error
                 (Info.RECOVERABLE, location,
                               "Unbound type constructor " ^ 
                               IdentPrint.printLongTyCon longtycon);
                 fresh_tyvar (acontext, false, false)))
d146 1
a146 5
	(if do_debug andalso Debug.debug_level () > 10 then 
	   (Print.print ("check_type 50");
	    Print.print ("\n"))
	 else ();
	   FUNTYPE (check_type (ty,acontext),check_type (ty',acontext)))
@


1.12
log
@Error message revision
@
text
@d4 3
d53 1
d65 2
a66 2
  structure Basis : BASIS
  structure Info : INFO
d72 4
a75 3
  sharing Absyn.Datatypes = Types.Datatypes = Basis.Tyvarenv.Datatypes
  sharing Absyn.Set = Basis.Set
  sharing Absyn.Location = Info.Location
d82 2
a83 3
    structure Basis     = Basis
    structure Tyvarenv = Basis.Tyvarenv  
    structure Info = Info
d85 1
d106 1
a106 1
    fun check_type (Absyn.TYVARty (tyvar),Basis.CONTEXT (_,_,_,tyvarenv)) =
@


1.11
log
@Added Integer parameter to functor.
@
text
@d4 3
d147 1
a147 1
                                        "\nArity of ",
d151 1
a151 1
                                        "\nNumber of arguments: ",
@


1.10
log
@Error message improvements
@
text
@d4 3
d40 1
d52 1
@


1.9
log
@Changed Error structure to Info
@
text
@d4 3
d49 1
a49 1
  structure IdentPrint : IDENTPRINT
d51 1
a51 1
  structure Ty_Debug : TY_DEBUG
d138 7
a144 1
                               "Error in type expression: Type function arity mismatch in rule 49");
d150 1
a150 1
                               "Error in type expression: Unbound type constructor " ^ 
@


1.8
log
@Added locations to error messages.
@
text
@d4 3
d37 1
a37 1
require "../main/error";
d51 1
a51 1
  structure Error : ERROR
d59 1
a59 1
  sharing Absyn.Location = Error.Location
d68 1
a68 1
    structure Error = Error
d75 6
d133 3
a135 3
                (Error.report
                 (Error.ERROR (Error.RECOVERABLE, location, 
                               "Error in type expression: Type function arity mismatch in rule 49"));
d139 2
a140 2
                (Error.report
                 (Error.ERROR (Error.RECOVERABLE, location,
d142 1
a142 1
                               IdentPrint.printLongTyCon longtycon));
d151 4
@


1.7
log
@Installed central error reporting mechanism.
@
text
@d4 3
d56 1
d105 1
a105 1
      | check_type (Absyn.APPty (tylist,longtycon),acontext) =
d125 1
a125 1
                 (Error.ERROR (Error.RECOVERABLE, Error.Location.UNKNOWN, 
d131 1
a131 1
                 (Error.ERROR (Error.RECOVERABLE, Error.Location.UNKNOWN,
@


1.6
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d31 1
a33 1
require "../typechecker/errors";
d35 1
d44 2
a45 1
  structure Errors    : ERRORS
d51 2
a52 3
  sharing Absyn.Datatypes
    = Types.Datatypes = Errors.Basis.Tyvarenv.Datatypes
  sharing Absyn.Set = Errors.Basis.Set
d59 3
a61 2
    structure Basis     = Errors.Basis
    structure Tyvarenv = Errors.Basis.Tyvarenv  
d65 3
d117 7
a123 5
	      if Types.arity (atyfun) = Lists.length (tylist)
		then Types.apply (atyfun,make_type_list tylist)
	      else Errors.announce_error acontext Errors.return_alpha
		["Error in type expression : ",
		 "Type function arity mismatch in rule_49\n"]
d125 6
a130 5
	      handle Basis.LookupLongTyCon => 
		Errors.announce_error acontext Errors.return_alpha 
		["Error in type expression : ",
		 "unbound type constructor ", 
		 IdentPrint.printLongTyCon longtycon, "\n"])
@


1.5
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d26 1
a27 1
require "../typechecker/datatypes";
a28 2
require "../typechecker/tyvarenv";
require "../typechecker/basis";
d35 1
a37 1
  structure Datatypes : DATATYPES
a38 2
  structure Tyvarenv  : TYVARENV
  structure Basis     : BASIS  
d45 5
a49 5
  sharing Datatypes = Basis.Datatypes = Absyn.Datatypes
    = Types.Datatypes = Tyvarenv.Datatypes = Errors.Datatypes
  sharing Basis = Errors.Basis
  sharing Absyn.Set = Basis.Set
  sharing Tyvarenv = Basis.Tyvarenv) : TYPE_EXP =
d52 1
a52 1
    structure Datatypes = Datatypes
d54 2
a55 2
    structure Basis     = Basis
  
@


1.4
log
@Some improvements from Anel
@
text
@d4 3
d77 1
a77 1
	  handle Mapping.Lookup => TYVAR (ref (~1),tyvar)))
@


1.3
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d98 2
a99 2
	      fun make_type_list ([],context) = []
		| make_type_list (h::t,context) =
d104 1
a104 1
		     check_type (h,context)::make_type_list (t,context))
d107 1
a107 1
		then Types.apply (atyfun,make_type_list (tylist,acontext))
@


1.2
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_type_exp.sml,v $
d12 1
d15 2
a20 1
require "../basics/absyn";
d24 20
a43 16
functor Type_exp (structure Lists     : LISTS
		  structure Print     : PRINT
		  structure Datatypes : DATATYPES
		  structure Types     : TYPES
		  structure Tyvarenv  : TYVARENV
		  structure Basis     : BASIS  
		  structure Absyn     : ABSYN
		  structure Errors    : ERRORS
		  structure Debug     : sig val set_debug_level : int -> unit
					    val debug_level : unit -> int
					end
		  sharing Datatypes = Basis.Datatypes = Absyn.Datatypes
		    = Types.Datatypes = Tyvarenv.Datatypes = Errors.Datatypes
		  sharing Basis = Errors.Basis
		  sharing Absyn.Set = Basis.Set
		  sharing Tyvarenv = Basis.Tyvarenv) : TYPE_EXP =
d50 1
d63 1
a63 1
      (if Debug.debug_level () > 10 then 
d73 1
a73 1
	(if Debug.debug_level () > 10 then 
d87 1
a87 1
	(if Debug.debug_level () > 10 then 
d96 1
a96 1
		  (if Debug.debug_level () > 10 then 
d115 1
a115 1
	(if Debug.debug_level () > 10 then 
@


1.1
log
@Initial revision
@
text
@d1 1
d3 5
a7 1
$Log$
@
