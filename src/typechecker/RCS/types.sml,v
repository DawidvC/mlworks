head	1.64;
access;
symbols
	MLW_daveb_inline_1_4_99:1.64.3
	MLWorks_21c0_1999_03_25:1.64
	MLWorks_20c1_1998_08_20:1.64
	MLWorks_20c0_1998_08_04:1.64
	MLWorks_20b2c2_1998_06_19:1.64
	MLWorks_20b2_Windows_1998_06_12:1.64
	MLWorks_20b1c1_1998_05_07:1.64
	MLWorks_20b0_1998_04_07:1.64
	MLWorks_20b0_1998_03_20:1.64
	MLWorks_20m2_1998_02_16:1.64
	MLWorks_20m1_1997_10_23:1.64
	MLWorks_11r1:1.62.1.1.1.1.1
	MLWorks_workspace_97:1.64.2
	MLWorks_dt_wizard:1.64.1
	MLWorks_11c0_1997_09_09:1.62.1.1.1.1
	MLWorks_10r3:1.62.1.1.3
	MLWorks_10r2_551:1.62.1.1.2
	MLWorks_11:1.62.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.62.1.1
	MLWorks_20m0_1997_06_20:1.64
	MLWorks_1_0_r2c2_1997_06_14:1.62.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.62.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.62.1
	MLWorks_BugFix_1997_04_24:1.62
	MLWorks_1_0_r2_Win32_1997_04_11:1.62
	MLWorks_1_0_r2_Unix_1997_04_04:1.62
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.61.3.1.1
	MLWorks_gui_1996_12_18:1.61.4
	MLWorks_1_0_Win32_1996_12_17:1.61.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.61.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.61.1.1
	MLWorks_1_0_Irix_1996_11_28:1.61.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.61.2
	MLWorks_1_0_Unix_1996_11_14:1.61.1
	MLWorks_Open_Beta2_1996_10_11:1.60.1
	MLWorks_License_dev:1.59.2
	MLWorks_1_open_beta_1996_09_13:1.59.1
	MLWorks_Open_Beta_1996_08_22:1.59
	MLWorks_Beta_1996_07_02:1.58
	MLWorks_Beta_1996_06_07:1.58
	MLWorks_Beta_1996_06_06:1.58
	MLWorks_Beta_1996_06_05:1.58
	MLWorks_Beta_1996_06_03:1.58
	MLWorks_Beta_1996_05_31:1.58
	MLWorks_Beta_1996_05_30:1.58
	ML_beta_release_12/08/94:1.45
	ML_beta_release_03/08/94:1.45
	ML_revised_beta_release_25/05/94:1.44
	ML_final_beta_release_02/03/94:1.42
	mlworks-28-01-1994:1.41
	Release:1.38
	mlworks-beta-01-09-1993:1.38
	MLWorks-1-0-4-29/01/1993:1.24
	MLWorks-1-0-3-21/12/1992:1.23
	MLWorks-1-0-2-15/12/1992:1.23
	MLWorks-1-0-1-04/12/1992:1.23
	checkpoint_17_08_92:1.15
	Ten15_release_19-11-91:1.2.1.1
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.64
date	97.05.01.12.56.21;	author jont;	state Exp;
branches
	1.64.1.1
	1.64.2.1
	1.64.3.1;
next	1.63;

1.63
date	97.04.25.16.27.40;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	96.12.18.16.31.58;	author andreww;	state Exp;
branches
	1.62.1.1;
next	1.61;

1.61
date	96.11.05.17.43.46;	author andreww;	state Exp;
branches
	1.61.1.1
	1.61.2.1
	1.61.3.1
	1.61.4.1;
next	1.60;

1.60
date	96.10.04.15.57.22;	author andreww;	state Exp;
branches
	1.60.1.1;
next	1.59;

1.59
date	96.08.05.14.16.13;	author andreww;	state Exp;
branches
	1.59.1.1
	1.59.2.1;
next	1.58;

1.58
date	96.03.08.12.07.30;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	95.12.27.11.25.54;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	95.12.05.11.37.14;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	95.09.08.17.49.44;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	95.08.22.16.00.59;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	95.07.27.16.39.43;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	95.07.20.14.08.03;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	95.07.19.13.32.23;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	95.07.13.12.38.20;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	95.04.10.10.20.17;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	95.03.28.16.20.52;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	95.02.16.12.33.46;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	95.02.02.14.32.52;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	94.06.17.11.08.29;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	94.05.11.14.38.45;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	94.04.27.15.17.49;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	94.02.21.23.21.39;	author nosa;	state Exp;
branches;
next	1.41;

1.41
date	93.11.24.15.48.18;	author nickh;	state Exp;
branches;
next	1.40;

1.40
date	93.09.27.11.03.33;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	93.08.16.10.22.01;	author nosa;	state Exp;
branches;
next	1.38;

1.38
date	93.07.30.15.12.08;	author nosa;	state Exp;
branches
	1.38.1.1;
next	1.37;

1.37
date	93.07.29.17.12.09;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	93.04.26.17.48.15;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	93.04.08.16.14.08;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.03.30.14.48.37;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	93.03.09.17.24.12;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	93.03.04.10.08.21;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	93.03.02.15.17.46;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	93.03.01.11.03.15;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.02.25.15.51.52;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.02.22.16.19.07;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.02.17.15.31.53;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	93.02.08.13.29.56;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.02.01.14.20.35;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	92.12.20.15.11.42;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.11.26.17.42.32;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	92.10.30.15.07.45;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.10.12.11.09.25;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.09.16.08.38.26;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	92.09.08.13.04.25;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.09.04.10.54.30;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.08.27.19.36.43;	author davidt;	state Exp;
branches;
next	1.16;

1.16
date	92.08.27.14.50.28;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.08.13.17.09.09;	author davidt;	state Exp;
branches;
next	1.14;

1.14
date	92.08.11.12.57.20;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.07.27.10.13.16;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.07.16.18.39.19;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.07.04.17.16.07;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.03.27.10.42.54;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.02.11.10.13.33;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.01.23.15.49.57;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.01.15.12.06.49;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.01.07.19.19.56;	author colin;	state Exp;
branches;
next	1.5;

1.5
date	92.01.07.16.20.53;	author colin;	state Exp;
branches;
next	1.4;

1.4
date	91.11.21.16.55.49;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.19.12.19.28;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.18.15.39.00;	author colin;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	91.06.07.11.46.30;	author colin;	state Exp;
branches;
next	;

1.2.1.1
date	91.11.19.11.13.11;	author jont;	state Exp;
branches;
next	;

1.38.1.1
date	93.07.30.15.12.08;	author jont;	state Exp;
branches;
next	1.38.1.2;

1.38.1.2
date	93.09.23.15.34.43;	author jont;	state Exp;
branches;
next	;

1.59.1.1
date	96.09.13.11.42.11;	author hope;	state Exp;
branches;
next	;

1.59.2.1
date	96.10.07.16.35.17;	author hope;	state Exp;
branches;
next	;

1.60.1.1
date	96.10.17.11.54.21;	author hope;	state Exp;
branches;
next	;

1.61.1.1
date	96.11.14.13.22.25;	author hope;	state Exp;
branches
	1.61.1.1.1.1;
next	;

1.61.1.1.1.1
date	96.11.28.15.33.07;	author hope;	state Exp;
branches;
next	;

1.61.2.1
date	96.11.22.18.39.44;	author hope;	state Exp;
branches;
next	;

1.61.3.1
date	96.12.17.18.18.45;	author hope;	state Exp;
branches
	1.61.3.1.1.1;
next	;

1.61.3.1.1.1
date	97.02.24.12.13.01;	author hope;	state Exp;
branches;
next	;

1.61.4.1
date	96.12.18.10.14.05;	author hope;	state Exp;
branches;
next	;

1.62.1.1
date	97.05.12.10.52.18;	author hope;	state Exp;
branches
	1.62.1.1.1.1
	1.62.1.1.2.1
	1.62.1.1.3.1;
next	;

1.62.1.1.1.1
date	97.07.28.18.34.04;	author daveb;	state Exp;
branches
	1.62.1.1.1.1.1.1;
next	;

1.62.1.1.1.1.1.1
date	97.10.07.12.00.02;	author jkbrook;	state Exp;
branches;
next	;

1.62.1.1.2.1
date	97.09.08.17.27.09;	author daveb;	state Exp;
branches;
next	;

1.62.1.1.3.1
date	97.09.09.14.24.06;	author daveb;	state Exp;
branches;
next	;

1.64.1.1
date	97.09.10.19.42.59;	author brucem;	state Exp;
branches;
next	;

1.64.2.1
date	97.09.11.21.10.29;	author daveb;	state Exp;
branches;
next	;

1.64.3.1
date	99.04.01.18.08.55;	author daveb;	state Exp;
branches;
next	;


desc
@Functions ranging over types and type functions
@


1.64
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* types.sml the signature *)
(*
$Log: types.sml,v $
 * Revision 1.63  1997/04/25  16:27:40  jont
 * [Bug #20017]
 * Add has_int32_equality function
 *
 * Revision 1.62  1996/12/18  16:31:58  andreww
 * [Bug #1818]
 * Adding new floatarray type name.
 *
 * Revision 1.61  1996/11/05  17:43:46  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
 * Revision 1.60  1996/10/04  15:57:22  andreww
 * [Bug #1592]
 * adding extra argument to create_tyname_copy (to pass a level
 * identifier around).
 *
 * Revision 1.59  1996/08/05  14:16:13  andreww
 * [Bug #1521]
 * Prevent imperative type variables being distinguished from applicative ones
 * under value polymorphism when being printed.
 *
 * Revision 1.58  1996/03/08  12:07:30  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
 * Revision 1.57  1995/12/27  11:25:54  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.56  1995/12/05  11:37:14  jont
Modify has_free_imptyvars to return the offending tyvar if it exists
Add type_occurs to find if such a type occurs within another more
complicated type

Revision 1.55  1995/09/08  17:49:44  daveb
Added types for different lengths of words, ints and reals.

Revision 1.54  1995/08/22  16:00:59  jont
Add has_int_equality, has_real_equality, has_string_equality

Revision 1.53  1995/07/27  16:39:43  jont
Add word_typep and wordint_typep

Revision 1.52  1995/07/20  14:08:03  jont
Add word_type and word_tyname

Revision 1.51  1995/07/19  13:32:23  jont
Add char_type

Revision 1.50  1995/07/13  12:38:20  jont
Add char type for new revised basis

Revision 1.49  1995/04/10  10:20:17  matthew
Adding simplify_type function
Moving some functions out of here

Revision 1.48  1995/03/28  16:20:52  matthew
Use Stamp structure for ids

Revision 1.47  1995/02/16  12:33:46  matthew
Adding combine_types for use by the debugger

Revision 1.46  1995/02/02  14:32:52  matthew
Rationalizations.

Revision 1.45  1994/06/17  11:08:29  jont
Export string_debruijn

Revision 1.44  1994/05/11  14:38:45  daveb
Added int_typep, real_typep, and resolve_overloading.

Revision 1.43  1994/04/27  15:17:49  jont
Added functions for checking for uninstantiated tyvars

Revision 1.42  1994/02/21  23:21:39  nosa
Global tyfun instantiations and extra TYNAME valenv recording for Modules Debugger.

Revision 1.41  1993/11/24  15:48:18  nickh
Added hooks to print types with a set of remembered type variables.

Revision 1.40  1993/09/27  11:03:33  jont
Merging in bug fixes

Revision 1.39  1993/08/16  10:22:01  nosa
Function all_tyvars that returns all METATYVAR- and TYVAR- refs
for polymorphic debugger.

Revision 1.38.1.2  1993/09/23  15:34:43  jont
Added make_true for doing equality_principal algorithm

Revision 1.38.1.1  1993/07/30  15:12:08  jont
Fork for bug fixing

Revision 1.38  1993/07/30  15:12:08  nosa
structure Option.

Revision 1.37  1993/07/29  17:12:09  jont
Extra extra information debug_print_type

Revision 1.36  1993/04/26  17:48:15  daveb
Added print_tyvars and make_tyvars.

Revision 1.35  1993/04/08  16:14:08  matthew
Added type_type and closed_type_equalityp

Revision 1.34  1993/03/30  14:48:37  jont
Put tyfun_strip into the signature

Revision 1.33  1993/03/09  17:24:12  jont
Added string_or_num_typep for spotting overloading of relationals to strings.

Revision 1.32  1993/03/04  10:08:21  matthew
Options & Info changes

Revision 1.31  1993/03/02  15:17:46  matthew
Added rectype functions so functions from Mapping not needed

Revision 1.30  1993/03/01  11:03:15  matthew
Added vector and bytearray tynames

Revision 1.29  1993/02/25  15:51:52  matthew
Added array_tyname

Revision 1.28  1993/02/22  16:19:07  matthew
Added dynamic_types

Revision 1.27  1993/02/17  15:31:53  jont
Put tyname_copy in the signature

Revision 1.26  1993/02/08  13:29:56  matthew
Removed open Datatypes

Revision 1.25  1993/02/01  14:20:35  matthew
Removed TypeLocation type from Datatypes

Revision 1.24  1992/12/20  15:11:42  jont
Anel's last changes

Revision 1.23  1992/11/26  17:42:32  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.22  1992/10/30  15:07:45  jont
Added special maps for tyfun_id, tyname_id, strname_id

Revision 1.21  1992/10/12  11:09:25  clive
Tynames now have a slot recording their definition point

Revision 1.20  1992/09/16  08:38:26  daveb
show_eq_info controls printing of equality attribute of tycons.

Revision 1.19  1992/09/08  13:04:25  jont
Removed has_a_new_name, no longer needed

Revision 1.18  1992/09/04  10:54:30  jont
Stuff to understand type functions properly

Revision 1.17  1992/08/27  19:36:43  davidt
Made various changes so that structure copying can be
done more efficiently.

Revision 1.16  1992/08/27  14:50:28  jont
removed val meta_tyname_eq

Revision 1.15  1992/08/13  17:09:09  davidt
Changed tyvars function to take a tuple of arguments.

Revision 1.14  1992/08/11  12:57:20  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.13  1992/07/27  10:13:16  richard
Added ml_value_tyname.

Revision 1.12  1992/07/16  18:39:19  jont
Changed to use btrees for renaming of tynames and strnames

Revision 1.11  1992/07/04  17:16:07  jont
Anel's changes for improved structure copying

Revision 1.10  1992/03/27  10:42:54  jont
Added new function tyvar_equalityp for where the equality attribute is
significant. The previous function type_equalityp now ignores the
equality attribute of type variables

Revision 1.9  1992/02/11  10:13:33  clive
New pervasive library code - cut some things out of the initial type basis

Revision 1.8  1992/01/23  15:49:57  jont
Added value giving tyfun_id_counter at end of defining pervasives

Revision 1.7  1992/01/15  12:06:49  clive
Added the array type

Revision 1.6  1992/01/07  19:19:56  colin
Added pervasive_tyname_count giving tyname id of first tyname after
the pervasives have been defined.

Revision 1.5  1992/01/07  16:20:53  colin
Removed last argument to calls to make_tyname
Removed no_of_cons

Revision 1.4  1991/11/21  16:55:49  jont
Added copyright message

Revision 1.3  91/11/19  12:19:28  jont
Merging in comments from Ten15 branch to main trunk

Revision 1.2.1.1  91/11/19  11:13:11  jont
Added comments for DRA on functions

Revision 1.2  91/06/18  15:39:00  colin
Added functions (isFunType) to check for a funtype and (argres) to extract
argument and result types.

Revision 1.1  91/06/07  11:46:30  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

(* The type Type is defined in datatypes.sml. This module defines a
host of simple functions on types and type names. *)


require "../typechecker/datatypes";
require "../main/options";

signature TYPES =
  sig
    structure Datatypes : DATATYPES
    structure Options: OPTIONS

    (* Tyname Utilities *)
    val make_tyname : (int * bool * string * string option
                       * int) -> Datatypes.Tyname
    val eq_attrib : Datatypes.Tyname -> bool
    (* test for a ref or array *)
    val has_ref_equality : Datatypes.Tyname -> bool
    val has_int_equality : Datatypes.Tyname -> bool
    val has_real_equality : Datatypes.Tyname -> bool
    val has_string_equality : Datatypes.Tyname -> bool
    val has_int32_equality : Datatypes.Tyname -> bool
    val print_name : Options.options -> Datatypes.Tyname  -> string
    val debug_print_name : Datatypes.Tyname  -> string
    val tyname_arity : Datatypes.Tyname -> int
    (* set the equality attribute to false *)
    val tyname_make_false : Datatypes.Tyname -> bool
    val tyname_eq : Datatypes.Tyname * Datatypes.Tyname -> bool
    val tyname_conenv : Datatypes.Tyname -> Datatypes.Valenv
    val tyname_strip : Datatypes.Tyname -> Datatypes.Tyname

    (* Builtin tynames *)
    val bool_tyname : Datatypes.Tyname
    val int_tyname : Datatypes.Tyname
    val word_tyname : Datatypes.Tyname 
    val int8_tyname : Datatypes.Tyname
    val word8_tyname : Datatypes.Tyname 
    val int16_tyname : Datatypes.Tyname
    val word16_tyname : Datatypes.Tyname 
    val int32_tyname : Datatypes.Tyname
    val word32_tyname : Datatypes.Tyname 
    val int64_tyname : Datatypes.Tyname
    val word64_tyname : Datatypes.Tyname 
    val real_tyname : Datatypes.Tyname
    val float32_tyname : Datatypes.Tyname
    val string_tyname : Datatypes.Tyname 
    val char_tyname : Datatypes.Tyname 
    val list_tyname : Datatypes.Tyname
    val ref_tyname : Datatypes.Tyname
    val exn_tyname : Datatypes.Tyname
    val ml_value_tyname : Datatypes.Tyname
    val array_tyname : Datatypes.Tyname
    val vector_tyname : Datatypes.Tyname
    val bytearray_tyname : Datatypes.Tyname
    val floatarray_tyname : Datatypes.Tyname
    val dynamic_tyname : Datatypes.Tyname
    val typerep_tyname : Datatypes.Tyname

    (* the equality attribute of the real tyname is going to be
       set whenever the oldDefinition option is set.  See
       interpreter/_shell_structure.sml *)
       
    val real_tyname_equality_attribute: bool ref

    (* Types *)

    val cons_typep : Datatypes.Type -> bool 
    val imperativep : Datatypes.Type -> bool
    val tyvar_equalityp : Datatypes.Type -> bool
    val type_equalityp : Datatypes.Type -> bool
    val closed_type_equalityp : Datatypes.Type -> bool
    val type_eq : Datatypes.Type * Datatypes.Type * bool * bool -> bool
    val simplify_type : Datatypes.Type -> Datatypes.Type

    (* Tests used for handling overloading *)
    val int_typep : Datatypes.Type -> bool
    val real_typep : Datatypes.Type -> bool
    val word_typep : Datatypes.Type -> bool
    val num_typep : Datatypes.Type -> bool
    val num_or_string_typep : Datatypes.Type -> bool
    val wordint_typep : Datatypes.Type -> bool
    val realint_typep : Datatypes.Type -> bool

    (* Print functions *)
    val print_type : Options.options -> Datatypes.Type -> string
    val debug_print_type : Options.options ->
                                 Datatypes.Type -> string
    val extra_debug_print_type : Datatypes.Type -> string
    val print_tyvars: Options.options -> Datatypes.Type list -> string

    (* Misc *)
    val type_of : Datatypes.Ident.SCon -> Datatypes.Type
    val has_free_imptyvars : Datatypes.Type -> Datatypes.Type option
    val type_occurs : Datatypes.Type * Datatypes.Type -> bool
    val the_type : Datatypes.Type -> Datatypes.Type
    (* accumulate non-meta tyvars *)
    val tyvars : Datatypes.Ident.TyVar list * Datatypes.Type -> Datatypes.Ident.TyVar list
    val all_tyvars : Datatypes.Type -> (int * Datatypes.Type * Datatypes.Instance) ref list
    val make_tyvars: int -> Datatypes.Type list

    (* Builtin types *)
    val int_type : Datatypes.Type
    val word_type : Datatypes.Type
    val int8_type : Datatypes.Type
    val word8_type : Datatypes.Type
    val int16_type : Datatypes.Type
    val word16_type : Datatypes.Type
    val int32_type : Datatypes.Type
    val word32_type : Datatypes.Type
    val int64_type : Datatypes.Type
    val word64_type : Datatypes.Type
    val real_type : Datatypes.Type
    val float32_type : Datatypes.Type
    val string_type : Datatypes.Type
    val char_type : Datatypes.Type
    val bool_type : Datatypes.Type
    val exn_type : Datatypes.Type
    val ml_value_type : Datatypes.Type
    val dynamic_type : Datatypes.Type
    val typerep_type : Datatypes.Type

    (* Return the size in bits of built-in numeric types. *)
    val sizeof: Datatypes.Type -> int option

    (* resolve overloaded types to their defaults.  The flag controls 
       whether functions such as + are resolved in this way as well. *)

    val resolve_overloading:
      bool * Datatypes.Type * 
      (Datatypes.Ident.ValId * Datatypes.Ident.Location.T -> unit) ->
      unit

    (* record types *)
    val empty_rectype : Datatypes.Type 
    val rectype_domain : Datatypes.Type -> Datatypes.Ident.Lab list
    val rectype_range : Datatypes.Type -> Datatypes.Type list
    val add_to_rectype : (Datatypes.Ident.Lab * Datatypes.Type 
                          * Datatypes.Type) -> Datatypes.Type 
    val get_type_from_lab : (Datatypes.Ident.Lab * Datatypes.Type) 
                            -> Datatypes.Type 

    val isFunType : Datatypes.Type -> bool

    exception ArgRes 
    (* extract the argument and result types from a funtype *)
    val argres : Datatypes.Type -> Datatypes.Type * Datatypes.Type

    (* Tyfun utilities *)

    val tyfun_strip : Datatypes.Tyfun -> Datatypes.Tyfun
    val null_tyfunp : Datatypes.Tyfun -> bool
    val make_tyfun :  Datatypes.Ident.TyVar list * Datatypes.Type -> 
                      Datatypes.Tyfun
    val make_eta_tyfun : Datatypes.Tyname -> Datatypes.Tyfun
    val apply : Datatypes.Tyfun * Datatypes.Type list -> Datatypes.Type

    val has_a_name : Datatypes.Tyfun -> bool
    val meta_tyname : Datatypes.Tyfun -> Datatypes.Tyname
    val name : Datatypes.Tyfun -> Datatypes.Tyname
    val arity : Datatypes.Tyfun -> int
    val tyfun_eq : Datatypes.Tyfun * Datatypes.Tyfun -> bool   
    val equalityp : Datatypes.Tyfun -> bool    
    val make_false : Datatypes.Tyfun -> bool
    val make_true : Datatypes.Tyname -> unit
    val string_tyfun : Datatypes.Tyfun -> string
    val update_tyfun_instantiations : Datatypes.Tyfun -> int
    val fetch_tyfun_instantiation : int -> Datatypes.Tyfun

    (* Debruijns *)
    val string_debruijn : Options.options * int * bool * bool -> string
    val check_debruijns : Datatypes.Type list * int -> bool

    (* Copying *)
    (* the bool indicates if copying is done rigidly *)
    val create_tyname_copy :
      bool -> int ->
      Datatypes.Tyname Datatypes.StampMap * Datatypes.Tyname ->
      Datatypes.Tyname Datatypes.StampMap

    val tyname_copy : Datatypes.Tyname * Datatypes.Tyname Datatypes.StampMap 
                      -> Datatypes.Tyname
    val tyfun_copy : Datatypes.Tyfun * Datatypes.Tyname Datatypes.StampMap
                      -> Datatypes.Tyfun
    val type_copy : Datatypes.Type * Datatypes.Tyname Datatypes.StampMap
                     -> Datatypes.Type

    (* Tyvars *)
    type seen_tyvars (* used to record which tyvars have been printed *)
    val no_tyvars : seen_tyvars
    val print_type_with_seen_tyvars :
      Options.options * Datatypes.Type * seen_tyvars -> string * seen_tyvars
    val type_has_unbound_tyvars : Datatypes.Type -> bool
    val tyfun_has_unbound_tyvars : Datatypes.Tyfun -> bool

    (* Used in the debugger *)
    exception CombineTypes
    val combine_types : Datatypes.Type * Datatypes.Type -> Datatypes.Type

    (* Stamps *)

    val stamp_num : Datatypes.Stamp -> int
    val make_stamp : unit -> Datatypes.Stamp
    val pervasive_stamp_count : int
  end;
@


1.64.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.64  1997/05/01  12:56:21  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.64.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.64  1997/05/01  12:56:21  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.64.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.64  1997/05/01  12:56:21  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.63
log
@[Bug #20017]
Add has_int32_equality function
@
text
@d4 4
d237 1
a237 1
    val make_tyname : (int * bool * string * string MLWorks.Option.option
d316 1
a316 1
    val has_free_imptyvars : Datatypes.Type -> Datatypes.Type MLWorks.Option.option
d346 1
a346 1
    val sizeof: Datatypes.Type -> int MLWorks.Option.option
@


1.62
log
@[Bug #1818]
Adding new floatarray type name.
@
text
@d4 4
d241 1
@


1.62.1.1
log
@branched from 1.62
@
text
@a3 4
 * Revision 1.62  1996/12/18  16:31:58  andreww
 * [Bug #1818]
 * Adding new floatarray type name.
 *
@


1.62.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.62.1.1  1997/05/12  10:52:18  hope
 * branched from 1.62
 *
@


1.62.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.62.1.1  1997/05/12  10:52:18  hope
 * branched from 1.62
 *
@


1.62.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.62.1.1  1997/05/12  10:52:18  hope
 * branched from 1.62
 *
@


1.62.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.62.1.1.1.1  1997/07/28  18:34:04  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.61
log
@[Bug #1711]
Punning real tyname equality attribute with old_definition option.
@
text
@d4 4
d269 1
@


1.61.4.1
log
@branched from 1.61
@
text
@a3 4
 * Revision 1.61  1996/11/05  17:43:46  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
@


1.61.3.1
log
@branched from 1.61
@
text
@a3 4
 * Revision 1.61  1996/11/05  17:43:46  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
@


1.61.3.1.1.1
log
@branched from 1.61.3.1
@
text
@a3 3
 * Revision 1.61.3.1  1996/12/17  18:18:45  hope
 * branched from 1.61
 *
@


1.61.2.1
log
@branched from 1.61
@
text
@a3 4
 * Revision 1.61  1996/11/05  17:43:46  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
@


1.61.1.1
log
@branched from 1.61
@
text
@a3 4
 * Revision 1.61  1996/11/05  17:43:46  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
@


1.61.1.1.1.1
log
@branched from 1.61.1.1
@
text
@a3 3
 * Revision 1.61.1.1  1996/11/14  13:22:25  hope
 * branched from 1.61
 *
@


1.60
log
@[Bug #1592]
adding extra argument to create_tyname_copy (to pass a level
identifier around).
@
text
@d4 5
d268 6
d334 3
a336 2
    (* resolve overloaded types to their defaults.  The flag controls whether *)
    (* functions such as + are resolved in this way as well. *)
d338 2
a339 1
      bool * Datatypes.Type * (Datatypes.Ident.ValId * Datatypes.Ident.Location.T -> unit) ->
d346 4
a349 2
    val add_to_rectype : (Datatypes.Ident.Lab * Datatypes.Type * Datatypes.Type) -> Datatypes.Type 
    val get_type_from_lab : (Datatypes.Ident.Lab * Datatypes.Type) -> Datatypes.Type 
d361 2
a362 1
    val make_tyfun :  Datatypes.Ident.TyVar list * Datatypes.Type -> Datatypes.Tyfun
d389 6
a394 3
    val tyname_copy : Datatypes.Tyname * Datatypes.Tyname Datatypes.StampMap  -> Datatypes.Tyname
    val tyfun_copy : Datatypes.Tyfun * Datatypes.Tyname Datatypes.StampMap -> Datatypes.Tyfun
    val type_copy : Datatypes.Type * Datatypes.Tyname Datatypes.StampMap -> Datatypes.Type
@


1.60.1.1
log
@branched from 1.60
@
text
@a3 5
 * Revision 1.60  1996/10/04  15:57:22  andreww
 * [Bug #1592]
 * adding extra argument to create_tyname_copy (to pass a level
 * identifier around).
 *
@


1.59
log
@[Bug #1521]
Prevent imperative type variables being distinguished from applicative ones
under value polymorphism when being printed.
@
text
@d4 5
d220 2
a221 1
    val make_tyname : (int * bool * string * string MLWorks.Option.option) -> Datatypes.Tyname
d369 1
a369 1
      bool ->
@


1.59.2.1
log
@branched from 1.59
@
text
@a3 5
 * Revision 1.59  1996/08/05  14:16:13  andreww
 * [Bug #1521]
 * Prevent imperative type variables being distinguished from applicative ones
 * under value polymorphism when being printed.
 *
@


1.59.1.1
log
@branched from 1.59
@
text
@a3 5
 * Revision 1.59  1996/08/05  14:16:13  andreww
 * [Bug #1521]
 * Prevent imperative type variables being distinguished from applicative ones
 * under value polymorphism when being printed.
 *
@


1.58
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@d4 3
d222 1
a222 1
    val print_name : Options.print_options -> Datatypes.Tyname  -> string
d277 3
a279 2
    val print_type : Options.print_options -> Datatypes.Type -> string
    val debug_print_type : Datatypes.Type -> string
d281 1
a281 1
    val print_tyvars: Datatypes.Type list -> string
d340 1
a340 1
    val make_tyfun : Datatypes.Ident.TyVar list * Datatypes.Type -> Datatypes.Tyfun
d357 1
a357 1
    val string_debruijn : int * bool * bool -> string
d375 1
a375 1
      Options.print_options * Datatypes.Type * seen_tyvars -> string * seen_tyvars
@


1.57
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d252 1
a252 1
    val type_tyname : Datatypes.Tyname
d308 1
a308 1
    val type_type : Datatypes.Type
@


1.56
log
@Modify has_free_imptyvars to return the offending tyvar if it exists
Add type_occurs to find if such a type occurs within another more
complicated type
@
text
@d4 5
d209 1
a209 1
    val make_tyname : (int * bool * string * string Datatypes.Option.opt) -> Datatypes.Tyname
@


1.55
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
d273 2
a274 1
    val has_free_imptyvars : Datatypes.Type -> bool
@


1.54
log
@Add has_int_equality, has_real_equality, has_string_equality
@
text
@d4 3
d220 9
d230 1
a232 1
    val word_tyname : Datatypes.Tyname 
d260 1
d279 9
d289 1
a291 1
    val word_type : Datatypes.Type
d297 3
@


1.53
log
@Add word_typep and wordint_typep
@
text
@d4 3
d202 3
@


1.52
log
@Add word_type and word_tyname
@
text
@d4 3
d238 1
d241 1
@


1.51
log
@Add char_type
@
text
@d4 3
d211 1
d258 1
@


1.50
log
@Add char type for new revised basis
@
text
@d4 3
d253 1
@


1.49
log
@Adding simplify_type function
Moving some functions out of here
@
text
@d4 4
d204 1
@


1.48
log
@Use Stamp structure for ids
@
text
@d4 3
d181 1
d184 2
d189 1
d192 2
d195 1
a208 2
    val pervasive_stamp_count : int
    val tyname_conenv : Datatypes.Tyname -> Datatypes.Valenv
a212 11
    val int_type : Datatypes.Type
    val real_type : Datatypes.Type
    val string_type : Datatypes.Type
    val bool_type : Datatypes.Type
    val exn_type : Datatypes.Type
    val ml_value_type : Datatypes.Type
    val dynamic_type : Datatypes.Type
    val type_type : Datatypes.Type
    val eq_and_imp : (bool * bool * Datatypes.Type) -> bool
    val not_occurs : Datatypes.Type * Datatypes.Type -> bool
    val propagate_level : int -> Datatypes.Type -> Datatypes.Type
d217 4
a220 1
    val type_eq : Datatypes.Type * Datatypes.Type * bool * bool -> bool 
d225 2
d230 3
d236 1
a236 2
    val tyfun_strip : Datatypes.Tyfun -> Datatypes.Tyfun
    val tyname_strip : Datatypes.Tyname -> Datatypes.Tyname
d240 10
a249 1
    val print_tyvars: Datatypes.Type list -> string
d251 2
a252 2
    (* resolve overloaded types to their defaults.  The flag controls whether
       functions such as + are resolved in this way as well. *)
d254 2
a255 3
      bool * Datatypes.Type
      * (Datatypes.Ident.ValId * Datatypes.Ident.Location.T -> unit)
      -> unit
d265 1
d270 1
a270 1
    (* Typefun *)
d272 1
d287 2
d290 1
d292 1
a292 3

    val update_tyfun_instantiations : Datatypes.Tyfun -> int
    val fetch_tyfun_instantiation : int -> Datatypes.Tyfun
d294 2
d301 3
a303 9
    val tyname_copy :
      Datatypes.Tyname * Datatypes.Tyname Datatypes.StampMap  -> Datatypes.Tyname
    val tyfun_copy : 
      Datatypes.Tyfun * Datatypes.Tyname Datatypes.StampMap -> Datatypes.Tyfun
    val type_copy :
      Datatypes.Type * Datatypes.Tyname Datatypes.StampMap -> Datatypes.Type
    val check_debruijns : Datatypes.Type list * int -> bool

    type seen_tyvars
d305 2
a311 1
    val tyname_has_unbound_tyvars : Datatypes.Tyname -> bool
d313 1
d317 1
a317 1
  (* Stamps *)
d321 1
@


1.47
log
@Adding combine_types for use by the debugger
@
text
@d4 3
a179 1
    val get_tyname_id :  Datatypes.Tyname -> Datatypes.Tyname_id.Tyname_id
d199 1
a199 2
    val pervasive_tyname_count : int
    val pervasive_tyfun_count : int
d279 4
a282 6
    val copy_metatyname : Datatypes.Tyname -> Datatypes.Tyname
    val new_metatyname : Datatypes.Tyname -> Datatypes.Tyname

    val create_tyname_copies :
      Datatypes.Tyname * (Datatypes.Tyname) Datatypes.Tyfun_id.Map.T * 
      (Datatypes.Tyname -> Datatypes.Tyname) -> (Datatypes.Tyname) Datatypes.Tyfun_id.Map.T
d285 1
a285 1
      Datatypes.Tyname * (Datatypes.Tyname) Datatypes.Tyfun_id.Map.T  -> Datatypes.Tyname
d287 1
a287 1
      Datatypes.Tyfun * (Datatypes.Tyname) Datatypes.Tyfun_id.Map.T -> Datatypes.Tyfun
d289 1
a289 1
      Datatypes.Type * (Datatypes.Tyname) Datatypes.Tyfun_id.Map.T -> Datatypes.Type
d303 5
@


1.46
log
@Rationalizations.
@
text
@d4 3
d302 2
@


1.45
log
@Export string_debruijn
@
text
@d4 3
@


1.44
log
@Added int_typep, real_typep, and resolve_overloading.
@
text
@d4 3
d266 2
@


1.43
log
@Added functions for checking for uninstantiated tyvars
@
text
@d4 3
d211 2
d227 7
@


1.42
log
@Global tyfun instantiations and extra TYNAME valenv recording for Modules Debugger.
@
text
@d4 3
d275 3
@


1.41
log
@Added hooks to print types with a set of remembered type variables.
@
text
@d4 3
d216 1
a216 1
    val all_tyvars : Datatypes.Type -> (int * Datatypes.Type * Datatypes.instance) ref list
d248 3
@


1.40
log
@Merging in bug fixes
@
text
@d4 3
d260 6
@


1.39
log
@Function all_tyvars that returns all METATYVAR- and TYVAR- refs
for polymorphic debugger.
@
text
@d4 10
d240 1
@


1.38
log
@structure Option.
@
text
@d4 3
d200 1
@


1.38.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.38  1993/07/30  15:12:08  nosa
structure Option.

@


1.38.1.2
log
@Added make_true for doing equality_principal algorithm
@
text
@a3 3
Revision 1.38.1.1  1993/07/30  15:12:08  jont
Fork for bug fixing

a228 1
    val make_true : Datatypes.Tyname -> unit
@


1.37
log
@Extra extra information debug_print_type
@
text
@d4 3
d141 1
a141 1
    val make_tyname : (int * bool * string * string Datatypes.opt) -> Datatypes.Tyname
@


1.36
log
@Added print_tyvars and make_tyvars.
@
text
@d4 3
d187 1
@


1.35
log
@Added type_type and closed_type_equalityp
@
text
@d4 3
d190 2
@


1.34
log
@Put tyfun_strip into the signature
@
text
@d4 3
d153 1
d166 1
d168 1
d175 1
@


1.33
log
@Added string_or_num_typep for spotting overloading of relationals to strings.
@
text
@d4 3
d14 1
a14 1
> Added vector and bytearray tynames
d177 2
@


1.32
log
@Options & Info changes
@
text
@d4 3
d168 1
@


1.31
log
@Added rectype functions so functions from Mapping not needed
@
text
@d4 3
d116 1
a116 1
require "../main/info";
d121 1
a121 3
    structure Info: INFO

    sharing Info.Location = Datatypes.Ident.Location
d126 1
a126 1
    val print_name : Info.options -> Datatypes.Tyname  -> string
d165 1
a165 1
    val print_type : Info.options -> Datatypes.Type -> string
@


1.30
log
@> Added vector and bytearray tynames
@
text
@d4 3
a155 2
    val add_to_rectype : (Datatypes.Ident.Lab * Datatypes.Type * Datatypes.Type) -> Datatypes.Type 
    val get_type_from_lab : (Datatypes.Ident.Lab * Datatypes.Type) -> Datatypes.Type 
a163 1
    val empty_rec_type : Datatypes.Type 
d170 7
@


1.29
log
@Added array_tyname
@
text
@d4 3
d137 2
@


1.28
log
@Added dynamic_types
@
text
@d4 3
d133 1
@


1.27
log
@Put tyname_copy in the signature
@
text
@d4 3
d130 1
d143 1
@


1.26
log
@Removed open Datatypes
@
text
@d4 3
d185 2
@


1.25
log
@Removed TypeLocation type from Datatypes
@
text
@d4 3
d107 17
a123 19
    open Datatypes

    val make_tyname : (int * bool * string * string Datatypes.opt) -> Tyname
    val eq_attrib : Tyname -> bool
    val get_tyname_id :  Tyname -> Tyname_id.Tyname_id
    val print_name : Info.options -> Tyname  -> string
    val debug_print_name : Tyname  -> string
    val tyname_arity : Tyname -> int
    val tyname_make_false : Tyname -> bool
    val tyname_eq : Tyname * Tyname -> bool

    val bool_tyname : Tyname
    val int_tyname : Tyname
    val real_tyname : Tyname
    val string_tyname : Tyname 
    val list_tyname : Tyname
    val ref_tyname : Tyname
    val exn_tyname : Tyname
    val ml_value_tyname : Tyname
d126 1
a126 1
    val tyname_conenv : Tyname -> Valenv
d130 23
a152 23
    val cons_typep : Type -> bool 
    val int_type : Type
    val real_type : Type
    val string_type : Type
    val bool_type : Type
    val exn_type : Type
    val add_to_rectype : (Ident.Lab * Type * Type) -> Type 
    val get_type_from_lab : (Ident.Lab * Type) -> Type 
    val eq_and_imp : (bool * bool * Type) -> bool
    val not_occurs : Type * Type -> bool
    val propagate_level : int -> Type -> Type
    val imperativep : Type -> bool
    val tyvar_equalityp : Type -> bool
    val type_equalityp : Type -> bool
    val type_eq : Type * Type * bool * bool -> bool 
    val num_typep : Type -> bool
    val empty_rec_type : Type 
    val print_type : Info.options -> Type -> string
    val debug_print_type : Type -> string
    val type_of : Ident.SCon -> Type
    val has_free_imptyvars : Type -> bool
    val the_type : Type -> Type
    val tyvars : Ident.TyVar list * Type -> Ident.TyVar list
d154 1
a154 1
    val isFunType : Type -> bool
d157 1
a157 1
    val argres : Type -> Type * Type
d161 13
a173 13
    val null_tyfunp : Tyfun -> bool
    val make_tyfun : Ident.TyVar list * Type -> Tyfun
    val make_eta_tyfun : Tyname -> Tyfun
    val apply : Tyfun * Type list -> Type

    val has_a_name : Tyfun -> bool
    val meta_tyname : Tyfun -> Tyname
    val name : Tyfun -> Tyname
    val arity : Tyfun -> int
    val tyfun_eq : Tyfun * Tyfun -> bool   
    val equalityp : Tyfun -> bool    
    val make_false : Tyfun -> bool
    val string_tyfun : Tyfun -> string
d175 2
a176 2
    val copy_metatyname : Tyname -> Tyname
    val new_metatyname : Tyname -> Tyname
d179 2
a180 2
      Tyname * (Tyname) Tyfun_id.Map.T * 
      (Tyname -> Tyname) -> (Tyname) Tyfun_id.Map.T
d183 1
a183 1
      Tyfun * (Tyname) Tyfun_id.Map.T -> Tyfun
d185 2
a186 2
      Type * (Tyname) Tyfun_id.Map.T -> Type
    val check_debruijns : Type list * int -> bool
@


1.24
log
@Anel's last changes
@
text
@d4 3
d102 2
d106 1
a106 1
    val make_tyname : (int * bool * string * Datatypes.TypeLocation) -> Tyname
@


1.23
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
a154 1
    exception Instantiated
@


1.22
log
@Added special maps for tyfun_id, tyname_id, strname_id
@
text
@d4 3
d88 1
d93 1
a96 4
    type PrintTypeOptions
    val default_PrintType_option : PrintTypeOptions
    val default_interpreter_PrintType_option : PrintTypeOptions

d100 2
a101 1
    val print_name : Tyname  -> string
d137 2
a138 2
    val print_type : Type -> string
    val print_type_with_options : Type * PrintTypeOptions -> string
d164 1
a164 1
    val string_tyfun_using_default : Tyfun -> string
@


1.21
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d168 2
a169 2
      Tyname * (Tyfun_id.Tyfun_id, Tyname) NewMap.T * 
      (Tyname -> Tyname) -> (Tyfun_id.Tyfun_id, Tyname) NewMap.T
d172 1
a172 1
      Tyfun * (Tyfun_id.Tyfun_id, Tyname) NewMap.T -> Tyfun
d174 1
a174 1
      Type * (Tyfun_id.Tyfun_id, Tyname) NewMap.T -> Type
@


1.20
log
@show_eq_info controls printing of equality attribute of tycons.
@
text
@d4 3
d89 3
a91 1
    val show_eq_info : bool ref
d93 1
a93 1
    val make_tyname : (int * bool * string) -> Tyname
d96 1
a96 1
    val print_name : Tyname -> string
d100 1
a100 3
(*
    val meta_tyname_eq : Tyname * Tyname -> bool
*)
d133 1
d151 1
a151 3
(*
    val has_a_new_name : Tyfun -> bool
*)
d159 1
a159 1
    val string_tyfun : Tyfun -> string
d173 1
@


1.19
log
@Removed has_a_new_name, no longer needed
@
text
@d4 3
d85 2
@


1.18
log
@Stuff to understand type functions properly
@
text
@d4 3
d142 1
d144 1
@


1.17
log
@Made various changes so that structure copying can be
done more efficiently.
@
text
@d4 4
d160 1
@


1.16
log
@removed val meta_tyname_eq
@
text
@d4 3
d148 8
a155 12
(*    val tyname_copy : Tyname * (Tyname * Tyname) list * (Tyname -> Tyname) ->
      Tyname * (Tyname * Tyname) list
    val tyfun_copy : Tyfun * (Tyname * Tyname) list  * (Tyname -> Tyname) ->
      Tyfun * (Tyname * Tyname) list
    val type_copy : Type * (Tyname * Tyname) list * (Tyname -> Tyname) ->
      Type * (Tyname * Tyname) list*)
    val tyname_copy : Tyname * (Tyfun_id.Tyfun_id, Tyname) NewMap.T * 
      (Tyname -> Tyname) -> Tyname * (Tyfun_id.Tyfun_id, Tyname) NewMap.T
    val tyfun_copy : Tyfun * (Tyfun_id.Tyfun_id, Tyname) NewMap.T *
      (Tyname -> Tyname) -> Tyfun * (Tyfun_id.Tyfun_id, Tyname) NewMap.T
    val type_copy : Type * (Tyfun_id.Tyfun_id, Tyname) NewMap.T *
      (Tyname -> Tyname) -> Type * (Tyfun_id.Tyfun_id, Tyname) NewMap.T
@


1.15
log
@Changed tyvars function to take a tuple of arguments.
@
text
@d4 3
d80 1
d82 1
@


1.14
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d113 1
a113 1
    val tyvars : Type -> Ident.TyVar list -> Ident.TyVar list
@


1.13
log
@Added ml_value_tyname.
@
text
@d4 3
a57 1
require "../utils/newmap";
a61 1
    structure NewMap : NEWMAP
@


1.12
log
@Changed to use btrees for renaming of tynames and strnames
@
text
@d4 3
d80 1
@


1.11
log
@Anel's changes for improved structure copying
@
text
@d4 3
d52 1
d57 1
d137 6
a142 6
    val tyname_copy : Tyname * (Tyfun_id.Tyfun_id * Tyname) list * 
      (Tyname -> Tyname) -> Tyname * (Tyfun_id.Tyfun_id * Tyname) list
    val tyfun_copy : Tyfun * (Tyfun_id.Tyfun_id * Tyname) list  * 
      (Tyname -> Tyname) -> Tyfun * (Tyfun_id.Tyfun_id * Tyname) list
    val type_copy : Type * (Tyfun_id.Tyfun_id * Tyname) list * 
      (Tyname -> Tyname) -> Type * (Tyfun_id.Tyfun_id * Tyname) list
a143 2


@


1.10
log
@Added new function tyvar_equalityp for where the equality attribute is
significant. The previous function type_equalityp now ignores the
equality attribute of type variables
@
text
@d4 5
d126 1
a126 1
    val tyname_copy : Tyname * (Tyname * Tyname) list * (Tyname -> Tyname) ->
d131 7
a137 1
      Type * (Tyname * Tyname) list
@


1.9
log
@New pervasive library code - cut some things out of the initial type basis
@
text
@d4 3
d85 1
@


1.8
log
@Added value giving tyfun_id_counter at end of defining pervasives
@
text
@d4 3
a63 3
    val instream_tyname : Tyname	  
    val outstream_tyname : Tyname
    val array_tyname : Tyname
@


1.7
log
@Added the array type
@
text
@d4 3
d65 1
@


1.6
log
@Added pervasive_tyname_count giving tyname id of first tyname after
the pervasives have been defined.
@
text
@d4 4
d60 1
@


1.5
log
@Removed last argument to calls to make_tyname
Removed no_of_cons
@
text
@d4 4
d56 1
@


1.4
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	types.sml,v $
d35 1
a35 1
    val make_tyname : (int * bool * string * int) -> Tyname
a40 1
    val no_of_cons : Tyname -> int
@


1.3
log
@Merging in comments from Ten15 branch to main trunk
@
text
@d1 1
d4 3
d17 1
@


1.2
log
@Added functions (isFunType) to check for a funtype and (argres) to extract
argument and result types.
@
text
@d3 7
d14 5
@


1.2.1.1
log
@Added comments for DRA on functions
@
text
@a2 4
Revision 1.2  91/06/18  15:39:00  colin
Added functions (isFunType) to check for a funtype and (argres) to extract
argument and result types.

a6 5

(* The type Type is defined in datatypes.sml. This module defines a
host of simple functions on types and type names. *)


@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d58 5
@
