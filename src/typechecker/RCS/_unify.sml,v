head	1.43;
access;
symbols
	MLW_daveb_inline_1_4_99:1.43.1
	MLWorks_21c0_1999_03_25:1.43
	MLWorks_20c1_1998_08_20:1.43
	MLWorks_20c0_1998_08_04:1.43
	MLWorks_20b2c2_1998_06_19:1.43
	MLWorks_20b2_Windows_1998_06_12:1.43
	MLWorks_20b1c1_1998_05_07:1.43
	MLWorks_20b0_1998_04_07:1.43
	MLWorks_20b0_1998_03_20:1.43
	MLWorks_20m2_1998_02_16:1.42
	MLWorks_20m1_1997_10_23:1.42
	MLWorks_11r1:1.40.5.1.1.1.1
	MLWorks_workspace_97:1.42.2
	MLWorks_dt_wizard:1.42.1
	MLWorks_11c0_1997_09_09:1.40.5.1.1.1
	MLWorks_10r3:1.40.5.1.3
	MLWorks_10r2_551:1.40.5.1.2
	MLWorks_11:1.40.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.40.5.1
	MLWorks_20m0_1997_06_20:1.42
	MLWorks_1_0_r2c2_1997_06_14:1.40.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.40.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.40.5
	MLWorks_BugFix_1997_04_24:1.40
	MLWorks_1_0_r2_Win32_1997_04_11:1.40
	MLWorks_1_0_r2_Unix_1997_04_04:1.40
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.40.3.1.1
	MLWorks_gui_1996_12_18:1.40.4
	MLWorks_1_0_Win32_1996_12_17:1.40.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.40.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.40.1.1
	MLWorks_1_0_Irix_1996_11_28:1.40.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.40.2
	MLWorks_1_0_Unix_1996_11_14:1.40.1
	MLWorks_Open_Beta2_1996_10_11:1.39.3
	MLWorks_License_dev:1.39.2
	MLWorks_1_open_beta_1996_09_13:1.39.1
	MLWorks_Open_Beta_1996_08_22:1.39
	MLWorks_Beta_1996_07_02:1.38
	MLWorks_Beta_1996_06_07:1.38
	MLWorks_Beta_1996_06_06:1.38
	MLWorks_Beta_1996_06_05:1.38
	MLWorks_Beta_1996_06_03:1.38
	MLWorks_Beta_1996_05_31:1.38
	MLWorks_Beta_1996_05_30:1.38
	ML_beta_release_12/08/94:1.28
	ML_beta_release_03/08/94:1.28
	ML_revised_beta_release_25/05/94:1.28
	ML_final_beta_release_02/03/94:1.26
	mlworks-28-01-1994:1.25
	Release:1.22
	mlworks-beta-01-09-1993:1.22
	MLWorks-1-0-4-29/01/1993:1.16
	MLWorks-1-0-3-21/12/1992:1.15
	MLWorks-1-0-2-15/12/1992:1.15
	MLWorks-1-0-1-04/12/1992:1.13
	checkpoint_17_08_92:1.7
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.43
date	98.02.19.16.48.31;	author mitchell;	state Exp;
branches
	1.43.1.1;
next	1.42;

1.42
date	97.05.19.13.01.55;	author jont;	state Exp;
branches
	1.42.1.1
	1.42.2.1;
next	1.41;

1.41
date	97.05.01.13.20.16;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	96.11.04.19.11.21;	author andreww;	state Exp;
branches
	1.40.1.1
	1.40.2.1
	1.40.3.1
	1.40.4.1
	1.40.5.1;
next	1.39;

1.39
date	96.08.01.14.37.17;	author andreww;	state Exp;
branches
	1.39.1.1
	1.39.2.1
	1.39.3.1;
next	1.38;

1.38
date	96.04.30.15.47.59;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	96.03.19.10.34.06;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	96.02.22.12.50.38;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	95.10.25.17.06.07;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	95.09.11.11.10.49;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	95.07.28.10.06.35;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	95.05.11.14.45.38;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	95.04.10.09.42.15;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	95.02.02.14.59.16;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	95.01.03.17.13.25;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	94.05.13.15.35.25;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	94.05.11.15.12.58;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	94.02.22.01.55.55;	author nosa;	state Exp;
branches;
next	1.25;

1.25
date	93.12.03.17.07.07;	author nickh;	state Exp;
branches;
next	1.24;

1.24
date	93.11.26.09.14.39;	author nosa;	state Exp;
branches;
next	1.23;

1.23
date	93.09.22.09.45.16;	author nosa;	state Exp;
branches;
next	1.22;

1.22
date	93.05.25.16.15.44;	author matthew;	state Exp;
branches
	1.22.1.1;
next	1.21;

1.21
date	93.05.18.18.22.11;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	93.04.01.16.32.23;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	93.03.12.17.28.59;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.03.05.13.09.11;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	93.02.08.12.01.54;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	92.12.22.15.38.38;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.12.10.18.48.32;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	92.12.10.18.32.14;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.12.03.12.35.04;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.11.27.12.11.41;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	92.11.25.15.41.36;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.10.27.15.01.47;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.10.23.13.36.15;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.08.27.19.38.41;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.06.16.08.21.31;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.05.06.21.33.04;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.04.16.17.51.03;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.01.27.20.16.22;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.01.24.16.19.00;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.21.16.48.53;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.41.50;	author colin;	state Exp;
branches;
next	;

1.22.1.1
date	93.05.25.16.15.44;	author jont;	state Exp;
branches;
next	;

1.39.1.1
date	96.09.13.11.42.00;	author hope;	state Exp;
branches;
next	;

1.39.2.1
date	96.10.07.16.35.07;	author hope;	state Exp;
branches;
next	;

1.39.3.1
date	96.10.17.11.54.12;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	96.11.14.13.22.09;	author hope;	state Exp;
branches
	1.40.1.1.1.1;
next	;

1.40.1.1.1.1
date	96.11.28.15.32.54;	author hope;	state Exp;
branches;
next	;

1.40.2.1
date	96.11.22.18.39.34;	author hope;	state Exp;
branches;
next	;

1.40.3.1
date	96.12.17.18.18.35;	author hope;	state Exp;
branches
	1.40.3.1.1.1;
next	;

1.40.3.1.1.1
date	97.02.24.12.12.50;	author hope;	state Exp;
branches;
next	;

1.40.4.1
date	96.12.18.10.13.53;	author hope;	state Exp;
branches;
next	;

1.40.5.1
date	97.05.12.10.52.07;	author hope;	state Exp;
branches
	1.40.5.1.1.1
	1.40.5.1.2.1
	1.40.5.1.3.1;
next	;

1.40.5.1.1.1
date	97.07.28.18.33.55;	author daveb;	state Exp;
branches
	1.40.5.1.1.1.1.1;
next	;

1.40.5.1.1.1.1.1
date	97.10.07.11.59.54;	author jkbrook;	state Exp;
branches;
next	;

1.40.5.1.2.1
date	97.09.08.17.27.00;	author daveb;	state Exp;
branches;
next	;

1.40.5.1.3.1
date	97.09.09.14.23.54;	author daveb;	state Exp;
branches;
next	;

1.42.1.1
date	97.09.10.19.42.50;	author brucem;	state Exp;
branches;
next	;

1.42.2.1
date	97.09.11.21.10.20;	author daveb;	state Exp;
branches;
next	;

1.43.1.1
date	99.04.01.18.08.50;	author daveb;	state Exp;
branches;
next	;


desc
@Unification Algorithm
(see also control_unify.sml)
@


1.43
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _unify.sml the functor *)
(*
$Log: _unify.sml,v $
 * Revision 1.42  1997/05/19  13:01:55  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.41  1997/05/01  13:20:16  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.40  1996/11/04  19:11:21  andreww
 * [Bug #1711]
 * Altering eq_and_imp to take account of real literals.
 *
 * Revision 1.39  1996/08/01  14:37:17  andreww
 * [Bug #1521]
 * Adding check for value polymorphism in unification of imperative variables
 * eq_and_imp.
 *
 * Revision 1.38  1996/04/30  15:47:59  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.37  1996/03/19  10:34:06  matthew
 * Removing string_inequalities option
 *
 * Revision 1.36  1996/02/22  12:50:38  jont
 * Replacing Map with NewMap
 *
 * Revision 1.35  1995/10/25  17:06:07  jont
 * Pretty up require statements
 *
Revision 1.34  1995/09/11  11:10:49  daveb
Added unification code for new overloaded tyvars.

Revision 1.33  1995/07/28  10:06:35  jont
Handle overloading of mod and div on ints and words

Revision 1.32  1995/05/11  14:45:38  matthew
Improving record domain error messages

Revision 1.31  1995/04/10  09:42:15  matthew
Moving various functions in here from Types

Revision 1.30  1995/02/02  14:59:16  matthew
Removing debug structure

Revision 1.29  1995/01/03  17:13:25  matthew
Change to substitution datatype

Revision 1.28  1994/05/13  15:35:25  daveb
Fixed erroneous boolean  expressions in do_overload.

Revision 1.27  1994/05/11  15:12:58  daveb
New overloading scheme.

Revision 1.26  1994/02/22  01:55:55  nosa
Changed Datatypes.instance to Datatypes.Instance.

Revision 1.25  1993/12/03  17:07:07  nickh
Remove TYNAME, fix substitution reference, remove old debugging code,
tidy up comments.

Revision 1.24  1993/11/26  09:14:39  nosa
Modified unified to be optionally side-effect free, returning substitutions;
Can apply resulting substitutions to types.

Revision 1.23  1993/09/22  09:45:16  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.22  1993/05/25  16:15:44  matthew
Change to output statements/

Revision 1.21  1993/05/18  18:22:11  jont
Removed integer parameter

Revision 1.20  1993/04/01  16:32:23  jont
Allowed overloadin on strings to be controlled by an option

Revision 1.19  1993/03/12  17:28:59  matthew
Reinstated record domain mismatch error.
./

Revision 1.18  1993/03/05  13:09:11  jont
Allowed overloading of relationals on strings

Revision 1.17  1993/02/08  12:01:54  matthew
Rationalised substructures

Revision 1.16  1992/12/22  15:38:38  jont
Anel's last changes

Revision 1.15  1992/12/10  18:48:32  matthew
RECORD_DOMAIN failure no longer generated.

Revision 1.14  1992/12/10  18:32:14  jont
Avoided stringifying types etc as debug unless really required

Revision 1.13  1992/12/03  12:35:04  matthew
Changed fail TYNAME ... to fail FAIL ...

Revision 1.12  1992/11/27  12:11:41  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.11  1992/11/25  15:41:36  jont
Modified unify to avoid so much recursion by stripping off various
METAs first

Revision 1.10  1992/10/27  15:01:47  jont
Fail bad unification on flexible records properly instead of crashing

Revision 1.9  1992/10/23  13:36:15  clive
Some bug fixes from Anel

Revision 1.8  1992/08/27  19:38:41  jont
Improved unify pattern matching

Revision 1.7  1992/06/16  08:21:31  jont
Modifications to sort out unification of flexible record types in order
to provide full information to the lambda translation

Revision 1.6  1992/05/06  21:33:04  jont
Fixed bug in unification of flexible record types.

Revision 1.5  1992/04/16  17:51:03  jont
Added lists parameter

Revision 1.4  1992/01/27  20:16:22  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.3  1992/01/24  16:19:00  jont
Updated to allow valenv in METATYNAME

Revision 1.2  1991/11/21  16:48:53  jont
Added copyright message

Revision 1.1  91/06/07  11:41:50  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/lists";
require "../utils/print";
require "../utils/crash";
require "../main/options";
require "../typechecker/types";
require "unify";

functor Unify(
  structure Lists   : LISTS
  structure Print   : PRINT
  structure Crash   : CRASH
  structure Options : OPTIONS
  structure Types : TYPES

    ) : UNIFY =
  struct
    structure Datatypes = Types.Datatypes
    structure NewMap = Datatypes.NewMap
    structure Ident = Datatypes.Ident
    type options = Options.options

    open Datatypes

    (* Datatype for record domains in error results. *)

    datatype record =
      RIGID of (Ident.Lab * Type) list
    | FLEX  of (Ident.Lab * Type) list

    (* a substitution is returned for unification without side-effects *)

    type 'a refargs = 'a ref * 'a

    datatype substitution = 
      SUBST of ((int * Datatypes.Type * Datatypes.Instance) refargs list *
                (int * bool * Type * bool * bool) refargs list *
                Type refargs list)

    (* result of unification *)

    datatype unify_result =

      (* Unification succeeded. *)
      OK

      (* General failure. Returns the sub-types which could not be unified. *)

    | FAILED of Type * Type

      (* Different domains. Returns the two conflicting records. *)

    | RECORD_DOMAIN of record * record

      (* Explicit tyvars.
         Returns the explicit tyvar and the type it couldn't unify with. *)

    | EXPLICIT_TYVAR of Type * Type

      (* Wrong equality and imperative attributes.
         The first boolean is the equality attribute required, the
         second is the imperative attribute. *)

    | EQ_AND_IMP of bool * bool * Type

      (* Circularity.
         Returns the tyvar and the type which it couldn't unify to. *)

    | CIRCULARITY of Type * Type

      (* Overloading.
         Returns the type which could not be unified to the overloaded type. *)

    | OVERLOADED of Ident.TyVar * Type

      (* Substitution. side-effect free, returning a substitution *)

    | SUBSTITUTION of substitution

      (* the three assignment operations used in unification;
        we make them refs so we can record assignments in a substitution *)

    val assign1 : (((int * Type * Instance) ref
                    * (int * Type * Instance)) -> unit) ref = ref(fn _ => ())
    val assign2 : (((int * bool * Type * bool * bool) ref 
                    * (int * bool * Type * bool * bool)) -> unit) ref = ref(fn _ => ())
    val assign3 : ((Type ref * Type) -> unit) ref = ref(fn _ => ())

    fun apply_sub1(tyv,SUBST S) = ref(Lists.assoc(tyv,#1(S)))
    fun apply_sub2(recty,SUBST S) = ref(Lists.assoc(recty,#2(S)))
    fun apply_sub3(ty,SUBST S) = ref(Lists.assoc(ty,#3(S)))

    fun apply(SUBSTITUTION S,ty) = 
      let
        fun substitute_type(ty as TYVAR(tyv as ref(_,NULLTYPE,_),id)) =
            (TYVAR(apply_sub1(tyv,S),id)
             handle Lists.Assoc => ty)
          | substitute_type(ty as METATYVAR(tyv as ref(_,NULLTYPE,_),b1,b2)) = 
            (METATYVAR(apply_sub1(tyv,S),b1,b2)
             handle Lists.Assoc => ty)
          | substitute_type(METATYVAR (ref (_,ty,_),_,_)) = substitute_type ty
          | substitute_type(ty as META_OVERLOADED 
                            (tyv as ref NULLTYPE,v,valid,loc)) = 
            (META_OVERLOADED(apply_sub3(tyv,S),v,valid,loc)
             handle Lists.Assoc => ty)
          | substitute_type(META_OVERLOADED (ref ty,_,_,_)) = substitute_type ty
          | substitute_type(ty as METARECTYPE (tyv as ref (_,_,NULLTYPE,_,_))) = 
            (METARECTYPE(apply_sub2(tyv,S))
             handle Lists.Assoc => ty)
          | substitute_type(METARECTYPE (ref (_,_,ty,_,_))) = 
            substitute_type(ty)
          | substitute_type((RECTYPE amap)) =
            RECTYPE(NewMap.map substitute_type_map amap)
          | substitute_type(FUNTYPE(arg,res)) =
            FUNTYPE(substitute_type(arg),substitute_type(res))
          | substitute_type(CONSTYPE (tylist,tyname)) =
            CONSTYPE(map substitute_type tylist,tyname)
          | substitute_type ty = ty

	and substitute_type_map(_, ty) = substitute_type ty

      in
        substitute_type(ty)
      end
      | apply _ = Crash.impossible "NOT SUBSTITUTION:apply:unify"
    local

      (* Exception raised in the event of failure. *)

      exception Failed of unify_result

      (* Fail with a result. *)

      fun fail ex res = raise (Failed (ex res))

      fun remove_cons_meta (ty as META_OVERLOADED (ref ty',_,_,_)) =
	  (case ty' of
	     NULLTYPE => ty
	   | _ => remove_cons_meta ty')
	| remove_cons_meta (ty as METARECTYPE (ref {2 = b,3 = t,...})) =
	  if (not b) orelse (case t of METARECTYPE _ => true | _ => false) then
	    remove_cons_meta t
	  else
	    ty
	| remove_cons_meta (ty as CONSTYPE (l, tyname)) =
	  (case tyname of
	     METATYNAME {1 = ref tyfun,...} =>
	       (case tyfun of
		  ETA_TYFUN _ => remove_cons_meta (Types.apply (tyfun, l))
		| TYFUN _ => remove_cons_meta (Types.apply (tyfun, l))
		| _ => ty
		  )
	   | _ => ty)
	| remove_cons_meta ty = ty

      fun propagate_level level
        (recty as (METARECTYPE (r as ref (level',flex,ty,eq,imp)))) =
        (if level < level'
           then r := (level, flex, propagate_level level ty, eq, imp)
         else ();
           recty)
        | propagate_level level (RECTYPE amap) = 
          RECTYPE(NewMap.map (propagate_level_map level) amap)
        | propagate_level level (ty as (METATYVAR (r as ref (level',t,i),_,_))) =
          (if level < level' 
             then r := (level,propagate_level level t,i)
           else ();
             ty)
        | propagate_level _ ty = 
          ty

      and propagate_level_map level (_, ty) = propagate_level level ty

    (****
     eq_and_imp does the manipulation of the equality and imperative attributes
     during unification.
     Note: we must check that we can unify "imperative" and
     "applicative" type variables --- this is the case with value polymorphism
     ****)

        (* NOTE here: eq=true implies var doesn't admit equality
                      imp=true implies var is not imperative *)

      fun eq_and_imp (options,eq,imp,(TYVAR (_,Ident.TYVAR (_,eq',imp')))) = 
        let 
          val Options.OPTIONS{compat_options=
                              Options.COMPATOPTIONS{old_definition,...}
                              ,...} = options
            
          val imp = imp andalso old_definition
          val imp' = imp' andalso old_definition
        in
          if eq 
            then (eq' andalso (if imp
                                 then imp' 
                               else true))
          else (if imp
                  then imp'
                else true)
        end
        | eq_and_imp (options,eq,imp,FUNTYPE (a,r)) =
          if eq 
            then false 
          else (eq_and_imp (options,eq,imp,a)) andalso 
               (eq_and_imp (options,eq,imp,r))
        | eq_and_imp (options,eq,imp,DEBRUIJN (_,eq',imp',_)) =
        let 
          val Options.OPTIONS{compat_options=
                              Options.COMPATOPTIONS{old_definition,...}
                              ,...} = options
            
          val imp = imp andalso old_definition
          val imp' = imp' andalso old_definition
        in
          if eq 
            then (eq' andalso (if imp
                                 then imp' 
                               else true))
          else (if imp
                  then imp'
                else true)
        end
        | eq_and_imp (options,eq,imp,
                      CONSTYPE (tylist,METATYNAME{1 = ref tyfun,
                                                  4 = ref eq',...})) =
          (eq_and_imp (options,eq,imp,Types.apply (tyfun,tylist))
           handle NullTyfun =>
             let fun collect [] = true
                   | collect (h::t) = eq_and_imp (options,eq,imp,h) andalso 
                     (collect t)
             in
               ((not eq) 
                orelse
                (eq' andalso collect tylist))
             end)
        | eq_and_imp (options,eq,imp,CONSTYPE ([],name)) =
          if eq 
            then Types.eq_attrib name
          else true
        | eq_and_imp (options,eq,imp,CONSTYPE ([h],name)) =
          if eq then
            if Types.has_ref_equality name then
              eq_and_imp (options,false,imp,h)
            else Types.eq_attrib name andalso eq_and_imp (options,eq,imp,h)
          else eq_and_imp (options,eq,imp,h)
        | eq_and_imp (options,eq,imp,CONSTYPE (t,n)) = 
          let fun collect [] = true
                | collect (h::t) = eq_and_imp (options,eq,imp,h) 
                  andalso (collect t)
          in
            ((not eq) orelse (Types.eq_attrib n)) andalso (collect(t))
          end
        | eq_and_imp (options,eq,imp,RECTYPE amap) = 
          NewMap.forall (fn (_, x) => eq_and_imp(options,eq, imp, x)) amap
        | eq_and_imp (options,eq,imp,NULLTYPE) = true
        | eq_and_imp (options,eq,imp,
                      METATYVAR (x as ref (n,NULLTYPE,i),eq',imp')) =
          if (eq andalso not eq') orelse (imp andalso not imp')
            then (x := (n,
                        METATYVAR (ref (n,NULLTYPE,NO_INSTANCE),
                                   eq orelse eq',imp orelse imp'),i);
                  true)
          else true
        | eq_and_imp (options,eq,imp,METATYVAR (ref (_,t,_),eq',imp')) =
          if (eq andalso not eq') orelse (imp andalso not imp')
            then (eq_and_imp (options,eq,imp,t))
          else true
        | eq_and_imp (options,eq,imp,META_OVERLOADED(ref NULLTYPE,tv,_,_)) =
            (!Types.real_tyname_equality_attribute) orelse
            ( (* in this case, (i.e., in SML'96 mode), reals have no
                 equality attribute, and so can only be matched against
                 things which have no equality attribute. *)
            (not(tv=Ident.real_tyvar orelse tv=Ident.real_literal_tyvar))
            orelse (not eq))

        | eq_and_imp (options,eq,imp,m as META_OVERLOADED _) = true
        | eq_and_imp (options,eq,imp,
                      METARECTYPE (r as ref (n,true,t,eq',imp'))) =
          if (eq andalso not eq') orelse (imp andalso not imp')
            then (r := (n,true,t,eq orelse eq',imp orelse imp');
                  true)
          else true
        | eq_and_imp (options,eq,imp,
                      METARECTYPE (r as ref (n,false,t,eq',imp'))) =
          if (eq andalso not eq') orelse (imp andalso not imp')
            then (eq_and_imp (options,eq,imp,t))
          else true
            
      (****
       Occurs check in unification.
       ****)

      (* was - not_occurs (ameta,TYVAR _) = true  - changed 28/5/91 *)
          
      fun not_occurs_tyfun (ty,TYFUN (ty',_)) =
        not_occurs (ty,ty')
        | not_occurs_tyfun (ty,ETA_TYFUN tyname) =
          not_occurs_tyname (ty,tyname)
      | not_occurs_tyfun (ty,NULL_TYFUN _) =
        true
      and not_occurs_tyname (ty,TYNAME _) = true
        | not_occurs_tyname (ty,METATYNAME (ref tyfun,_,_,_,_,_)) =
          not_occurs_tyfun (ty,tyfun)
      and not_occurs (METATYVAR (ref (tyv as (n,_,_)),_,_),
                      TYVAR (r' as ref (n',_,_),_)) =
        (n > n')
        orelse
        (r' := tyv;
         true)
        | not_occurs (ameta,TYVAR _) = true
        | not_occurs (ameta,FUNTYPE(a,r)) = 
          not_occurs (ameta,a) andalso not_occurs (ameta,r)
        | not_occurs (ameta,t as DEBRUIJN _) = true
        | not_occurs (ameta,CONSTYPE (tylist,tyname)) =
          not_occurs_tyname (ameta, tyname)
          andalso
          Lists.forall (fn x => not_occurs(ameta,x)) tylist
        | not_occurs (ameta,RECTYPE amap)	= 
          NewMap.forall (fn (_, x) => not_occurs(ameta, x)) amap
        | not_occurs (ameta,NULLTYPE) = true
        | not_occurs (ameta as METATYVAR (ref (n,NULLTYPE,i),_,_),
                      ameta' as METATYVAR (x as ref (n',NULLTYPE,_),_,_)) = 
          if (Types.type_eq (ameta,ameta',true,true))
            then false
          else
            (n > n') 
            orelse
            (x := (n,NULLTYPE,i);
             true)
        | not_occurs (ameta as METATYVAR (ref (n,_,i),_,_),
                      ameta' as METATYVAR (x as ref (n',NULLTYPE,_),_,_)) = 
          if (Types.type_eq (ameta,ameta',true,true))
            then false
          else
            (n > n') 
            orelse
            (x := (n,NULLTYPE,i);
             true)
        | not_occurs (ameta,t as METATYVAR (ref (_,NULLTYPE,_),eq',imp')) =
          not (Types.type_eq (ameta,t,true,true))
        | not_occurs (ameta as METATYVAR (ref (n,_,i),_,_),
                      METATYVAR (x as ref (n',t,_),_,_)) = 
          (if (n > n') then () else x := (n,t,i);
             not_occurs (ameta,t))
        | not_occurs (ameta,METATYVAR (ref (_,t,_),_,_)) = not_occurs (ameta,t)
        | not_occurs (ameta,META_OVERLOADED _) = true
        | not_occurs (ameta,t as METARECTYPE (ref (_,true,arec,_,_))) = 
          not_occurs (ameta,arec)
        | not_occurs (ameta,METARECTYPE (ref (_,false,t,_,_))) = 
          not_occurs (ameta,t)

      exception NotRectype

      (* Unify a list of types. *)

      fun check set =
	let
	  fun check(Ident.VAR sy) =
	    let
	      val sy = Ident.Symbol.symbol_name sy
	    in
	      Lists.member(sy, set)
	    end
	    | check _ = false
	in
	  check
	end
	    
      val predicates = ["<", ">", "<=", ">="]
      val check_predicate = check predicates
      val mod_div = ["mod", "div"]
      val check_mod_or_div = check mod_div

      fun unify_lists (options,[], []) = ()
	| unify_lists (options,h :: t, h' :: t') = 
	  (unify' (options,h, h');
	   unify_lists (options,t, t'))
	| unify_lists _ =
	  Crash.impossible "Unify.unify_lists"

      and unify'(options,atype, atype') =
	let
	  val atype = remove_cons_meta atype
	  val atype' = remove_cons_meta atype'
	in
	  unify (options, atype, atype')
	end

      (* Unify two types. *)

      and unify(options,atype, atype') =
	case (atype, atype') of

	  (TYVAR (ref (n,_,_), id), TYVAR (ref (n',_,_), id')) =>
	    if (n = n' andalso id = id') then
	      ()
	    else
	      fail EXPLICIT_TYVAR (atype, atype')
		
	| (DEBRUIJN debruijn, DEBRUIJN debruijn') =>
	    if ((fn ty=>(#1(ty),#2(ty),#3(ty)))debruijn) = 
	      ((fn ty=>(#1(ty),#2(ty),#3(ty)))debruijn')
	      then ()
	    else
	      fail FAILED (atype, atype')

	| (FUNTYPE (a, r), FUNTYPE (a', r')) =>
	    (unify'(options,a, a');
	     unify'(options,r, r'))

	| (RECTYPE amap, RECTYPE amap') =>
	    let
	      (* Note that unify' fails using an exception *)
	      fun unify'' (ty, ty') = (unify'(options,ty, ty') ; true)
	      val res = NewMap.eq unify'' (amap, amap')
	    in
	      if res then ()
	      else
		let
		  val rec1 = NewMap.to_list_ordered amap
		  val rec2 = NewMap.to_list_ordered amap'
		in
		  fail RECORD_DOMAIN (RIGID rec1, RIGID rec2)
		end
(*
	      case res of
		Mapping.EQUAL =>
		  ()
	      | Mapping.NOT_EQUAL =>
		  (* Note that unify'' fails using an exception *)
		  Crash.impossible "Unify.unify RECTYPE and RECTYPE"
	      | Mapping.DIFFERENT_DOMAINS =>
		  let
		    val rec1 = Mapping.assoc amap
		    val rec2 = Mapping.assoc amap'
		  in
		    fail RECORD_DOMAIN (RIGID rec1, RIGID rec2)
		  end
*)
	    end

	| (METATYVAR (r as ref (n, NULLTYPE,_), eq, imp), _) =>
	    do_unify(options,r, eq, imp, atype')

	| (_, METATYVAR (r' as ref (n', NULLTYPE,_), eq', imp')) =>
	    do_unify(options,r', eq', imp', atype)
	     
	| (METATYVAR (ref (n, t,_), _, _), _) =>
	    unify'(options,t, atype')

	| (_, METATYVAR (ref (n', t',_), _, _)) =>
	    unify'(options,atype, t')

	| (META_OVERLOADED (ol as (r as ref NULLTYPE, tv, _, _)), _) =>
	     do_overload(ol, atype')

	| (_, META_OVERLOADED (ol as (r' as ref NULLTYPE, tv, _, _))) =>
	    do_overload(ol, atype)

	| (METARECTYPE (r as ref (_, true, RECTYPE _, _, _)), _) =>
	    (do_unify_rec(options,r, atype') 
	     handle NotRectype => fail FAILED (atype,atype'))

	| (_, METARECTYPE (r' as ref (_, true, RECTYPE _, _, _))) =>
	    (do_unify_rec(options,r', atype)
	     handle NotRectype => fail FAILED (atype,atype'))

	| (CONSTYPE (l, n), CONSTYPE (l', n')) =>
	    if Types.tyname_eq (n, n') then
	      unify_lists(options,l, l')
	    else
	      fail FAILED (atype, atype')

	| (_, _) => fail FAILED (atype, atype')

      (* Do the unification between a metatyvar and a type. *)

      and do_unify(options,r as ref (n, NULLTYPE,inst), eq, imp, t') =
	(case t' of
	   METATYVAR (r' as ref (n', NULLTYPE,inst'), eq', imp') =>

	     if r = r'
	       then ()
	     else
	       (let
		  val n'' = if n < n' then n else n'
		in
		  ((!assign1)(r',(n'', NULLTYPE,inst'));
		   (!assign1)(r,(n'', t',inst)))
		end;
		if eq_and_imp (options,eq, imp, t') 
		  then ()
		else Crash.impossible "Unify.do_unify METATYVAR and METATYVAR")
	   
	 | METATYVAR (r' as ref (n', t'',inst'), _, _) =>
	     if (n > n') andalso eq_and_imp (options,eq, imp, t') then
	       (!assign1)(r,(n', t',inst))
	     else do_unify(options,r, eq, imp, t'')
	       
	 | CONSTYPE (l, METATYNAME{1=ref(tyfun as ETA_TYFUN _), ...}) =>
	     do_unify(options,r, eq, imp, Types.apply (tyfun, l))
	     
	 | CONSTYPE (l, METATYNAME{1=ref(tyfun as TYFUN _), ...}) =>
	     do_unify(options,r, eq, imp, Types.apply (tyfun, l))
	     
	 | TYVAR (r' as ref (n',t,inst'),_) =>
	     if eq_and_imp (options,eq, imp, t')
	       then
		 let
		   val n'' = if n < n' then n else n'
		 in
		   ((!assign1)(r,(n'', t',inst));
		    (!assign1)(r',(n'',t,inst')))
		 end
	     else fail EQ_AND_IMP (eq, imp, t')
	       
	 | METARECTYPE (r' as ref (n', true, ty, eq', imp')) =>
	     if not_occurs (METATYVAR (r, eq, imp), t')
	       then
		 if eq_and_imp (options,eq, imp, t')
		   then
		     let 
		       val n'' = if n < n' then n else n'
		     in
		       ((!assign1)(r,(n'', t',inst));
			(!assign2)(r',(n'', true, propagate_level n'' ty, 
				       eq orelse eq',
				       imp orelse imp')))
		     end
		 else fail EQ_AND_IMP (eq, imp, t')
	     else fail CIRCULARITY (METATYVAR (r, eq, imp), t')
	       
	 | ty =>
	     if not_occurs (METATYVAR (r, eq, imp), t') 
	       then
		 if eq_and_imp (options,eq, imp, t') then
		   ((case t' of
		       NULLTYPE => Crash.impossible "nulltype"
		     | _ => ());
		       (!assign1)(r,(n, t',inst)))
		 else
		   fail EQ_AND_IMP (eq, imp, t')
	     else
	       fail CIRCULARITY (METATYVAR (r, eq, imp), t'))

	| do_unify _ = Crash.impossible "Unify.do_unify"

      (* Unify a meta-overloaded tyvar.
         The second argument will not be a metatyvar. *)

      and do_overload (ol as (r, tv, valid, loc), t') =
	case t' of
	  META_OVERLOADED(r' as ref NULLTYPE,tv',_,_) =>
	    (* We have two overloaded tyvars.  We have to check that they
	       are compatible, and make the most specific case the leaf. *)
	    if (r = r') then
	      ()
	    else if tv = Ident.numtext_tyvar then
	      (!assign3)(r, t')
	    else if tv' = Ident.numtext_tyvar then
	      (!assign3)(r', META_OVERLOADED ol)
	    else if tv = Ident.num_tyvar then
	      (!assign3)(r, t')
	    else if tv' = Ident.num_tyvar then
	      (!assign3)(r', META_OVERLOADED ol)
	    else if tv = Ident.wordint_tyvar then
	      if (tv' = Ident.real_tyvar orelse
		  tv' = Ident.real_literal_tyvar) then
	        fail OVERLOADED (tv, t')
	      else
	        (!assign3)(r, t')
	    else if tv' = Ident.wordint_tyvar then
	      if (tv = Ident.real_tyvar orelse
		  tv = Ident.real_literal_tyvar) then
	        fail OVERLOADED (tv', META_OVERLOADED ol)
	      else
	        (!assign3)(r', META_OVERLOADED ol)
	    else if tv = Ident.realint_tyvar then
	      if tv' = Ident.word_literal_tyvar then
	        fail OVERLOADED (tv, t')
	      else
	        (!assign3)(r, t')
	    else if tv' = Ident.realint_tyvar then
	      if tv = Ident.word_literal_tyvar then
	        fail OVERLOADED (tv', META_OVERLOADED ol)
	      else
	        (!assign3)(r', META_OVERLOADED ol)
	    else if tv = Ident.real_tyvar then
	      if (tv' = Ident.real_tyvar orelse
		  tv' = Ident.real_literal_tyvar) then
	        (!assign3)(r, t')
	      else
	        fail OVERLOADED (tv, t')
	    else if tv' = Ident.real_tyvar then
	      if tv = Ident.real_literal_tyvar then
	        (!assign3)(r', META_OVERLOADED ol)
	      else
	        fail OVERLOADED (tv, t')
	    else if tv' = tv then
	      (* E.g. two integer literals. *)
	      (!assign3)(r, t')
	    else
	      fail OVERLOADED (tv, t')

	| META_OVERLOADED(ref t'',_,_,_) =>
	    (* Traverse the list of existing instantiations. *)
	    do_overload(ol, t'')

	| _ =>
	    (* Unification of an overloaded type variable with an
	       ordinary type. *)
	    if tv = Ident.num_tyvar
	    andalso Types.num_typep t' then
	      (!assign3)(r,t')
	    else if tv = Ident.numtext_tyvar
	    andalso (Types.num_typep t'
	       	     orelse Types.num_or_string_typep t') then
	      (!assign3)(r,t')
	    else if tv = Ident.wordint_tyvar
	    andalso (Types.wordint_typep t') then
	      (!assign3)(r,t')
	    else if tv = Ident.realint_tyvar
	    andalso (Types.realint_typep t') then
	      (!assign3)(r,t')
	    else if tv = Ident.int_literal_tyvar
	    andalso Types.int_typep t' then
	      (!assign3)(r,t')
	    else if (tv = Ident.real_tyvar orelse tv = Ident.real_literal_tyvar)
	    andalso Types.real_typep t' then
	      (!assign3)(r,t')
	    else if tv = Ident.word_literal_tyvar
	    andalso Types.word_typep t' then
	      (!assign3)(r,t')
	    else fail OVERLOADED (tv, t')

      (* Unify a flexible record type.
         The second argument will not be a metatyvar. *)

      and do_unify_rec(options,
                       r as ref (level, _,ty as RECTYPE amap, eq, imp), t') =
	let
	  val t = METARECTYPE r
	in
	  case t' of
	    RECTYPE amap' =>
	      if not_occurs (t, t') then
		if eq_and_imp (options,eq,imp,t') then
		  let
		    fun unify'' (options,ty1, ty2) =
		      if (eq orelse imp) then
			if eq_and_imp (options,eq, imp, ty2) then
			  (unify'(options,ty1, ty2); true)
			else fail EQ_AND_IMP (eq, imp, ty2)
		      else (unify'(options,ty1, ty2); true)
		  in
		    NewMap.iterate
		    (fn (lab, ty) =>
		     let
		       val ty' = case NewMap.tryApply'(amap', lab) of
			 SOME ty' => ty'
		       | _ => 
			   let
			     val rec1 = NewMap.to_list_ordered amap
			     val rec2 = NewMap.to_list_ordered amap'
			   in
			     fail RECORD_DOMAIN (FLEX rec1, RIGID rec2)
			   end
		     in
		       if unify''(options,ty, ty') then
			 ()
		       else
			 Crash.impossible "Unify.do_unify_rec"
		     end)
		    amap;
		    (!assign2)(r,(level, false,
				  propagate_level level t', eq, imp))
(*
		    case Mapping.size (amap', amap, Ident.lab_order, 
				       unify'') of
		      Mapping.BIGGER =>
			(!assign2)(r,(level, false,
				      propagate_level level t', eq, imp))
		    | Mapping.NOT_BIGGER =>
			let
			  val rec1  = Mapping.assoc amap
			  val rec2 = Mapping.assoc amap'
			in
			  fail RECORD_DOMAIN (FLEX rec1, RIGID rec2)
			end
		    | Mapping.DIFFERENT_RANGE =>
			Crash.impossible "Unify.Mapping.size"
*)
		  end
		else fail EQ_AND_IMP (eq,imp,t')
	      else fail CIRCULARITY (t, t')
		 
	  | METARECTYPE (r' as ref (level', true, RECTYPE amap', eq', imp')) =>
	      if (r = r') 
                then ()
	      else
		if not_occurs (t, t') andalso not_occurs (t', t)
		  then
		    let 
		      infix andnot
		      fun (true, _) andnot (false, _) = true
			| (_, true) andnot (_, false) = true
			|     _     andnot     _      = false
			      
		      val leftfun =
			if (eq', imp') andnot (eq, imp) 
			  then
			    fn x =>
			    if eq_and_imp (options,eq', imp', x) 
			      then x
			    else
			      fail EQ_AND_IMP (eq', imp', x)
			else 
			  fn x => x
			  
		      val rightfun =
			if (eq, imp) andnot (eq', imp') 
			  then
			    fn x =>
			    if eq_and_imp (options,eq, imp, x)
			      then x
			    else
			      fail EQ_AND_IMP (eq, imp, x)
			else 
			  fn x => x
			  
		      fun unify''(options,x, y) =
			(unify'(options,leftfun x, rightfun y); true)

		      fun do_difference(in_map, out_map, res, in_fun) =
			NewMap.fold
			(fn (res, lab, ty) =>
			 case NewMap.tryApply'(out_map, lab) of
			   NONE =>
			     NewMap.define'(res, (lab, in_fun ty))
			 | _ => res)
			(res, in_map)

		      val new_map =
			do_difference(NewMap.empty' Ident.lab_lt, amap, amap', leftfun)
		      val new_map = do_difference(new_map, amap', amap, rightfun)
		      val new_map =
			NewMap.fold
			(fn (res, lab, ty) =>
			 case NewMap.tryApply'(amap', lab) of
			   SOME ty' =>
			     (ignore(unify''(options,ty, ty'));
			      NewMap.define'(res, (lab, ty)))
			 | _ => res)
			(new_map, amap)
(*
		      val new_map =
			Mapping.splice_maps
			(amap, amap', leftfun, rightfun, unify'', 
			 Ident.lab_order)
*)
			
		      val level'' = if level < level' then level else level'
			
		    in
		      (!assign2)(r,(level'', true, 
                                    propagate_level level'' t',eq, imp));
		      (!assign2)(r',(level'', true, 
                                     propagate_level level'' (RECTYPE new_map),
                                     eq', imp'))
		    end
		else
		  fail CIRCULARITY (t, t')

	 | _ => raise NotRectype
	 end

      | do_unify_rec _ = Crash.impossible "Unify.do_unify_rec(2)"

    in

      (* Top level unification function. *)

      fun unified(options, x, y, return_substitution) =
	let
	  val substitution = ref (nil,nil,nil)
	  fun add1 x = let val (s1,s2,s3) = !substitution
		       in substitution := (x::s1,s2,s3) end
	  fun add2 x = let val (s1,s2,s3) = !substitution
		       in substitution := (s1,x::s2,s3) end
	  fun add3 x = let val (s1,s2,s3) = !substitution
		       in substitution := (s1,s2,x::s3) end
	in
	  (assign1 := (if return_substitution then add1 else op :=);
	   assign2 := (if return_substitution then add2 else op :=);
	   assign3 := (if return_substitution then add3 else op :=);
	   unify'(options, x, y);
	   if return_substitution then
	     SUBSTITUTION (SUBST (!substitution))
	   else OK)
	  handle Failed res => 
	    if return_substitution then 
	      (print"\nWarning: Unification Failure; recipes may not be generated correctly\n";
	       SUBSTITUTION (SUBST (!substitution)))
           else res
	end
    end
  end;



@


1.43.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.43  1998/02/19  16:48:31  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.42
log
@[Bug #30090]
Translate output std_out to print
@
text
@d4 4
d897 1
a897 1
			     (unify''(options,ty, ty');
@


1.42.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.42  1997/05/19  13:01:55  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.42.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.42  1997/05/19  13:01:55  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.41
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d944 1
a944 2
	      (MLWorks.IO.output(MLWorks.IO.std_out,
		      "\nWarning: Unification Failure; recipes may not be generated correctly\n");
@


1.40
log
@[Bug #1711]
Altering eq_and_imp to take account of real literals.
@
text
@d4 4
d798 1
a798 1
			 MLWorks.Option.SOME ty' => ty'
d876 1
a876 1
			   MLWorks.Option.NONE =>
d888 1
a888 1
			   MLWorks.Option.SOME ty' =>
@


1.40.5.1
log
@branched from 1.40
@
text
@a3 4
 * Revision 1.40  1996/11/04  19:11:21  andreww
 * [Bug #1711]
 * Altering eq_and_imp to take account of real literals.
 *
@


1.40.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.40.5.1  1997/05/12  10:52:07  hope
 * branched from 1.40
 *
@


1.40.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.40.5.1  1997/05/12  10:52:07  hope
 * branched from 1.40
 *
@


1.40.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.40.5.1  1997/05/12  10:52:07  hope
 * branched from 1.40
 *
@


1.40.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.40.5.1.1.1  1997/07/28  18:33:55  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.40.4.1
log
@branched from 1.40
@
text
@a3 4
 * Revision 1.40  1996/11/04  19:11:21  andreww
 * [Bug #1711]
 * Altering eq_and_imp to take account of real literals.
 *
@


1.40.3.1
log
@branched from 1.40
@
text
@a3 4
 * Revision 1.40  1996/11/04  19:11:21  andreww
 * [Bug #1711]
 * Altering eq_and_imp to take account of real literals.
 *
@


1.40.3.1.1.1
log
@branched from 1.40.3.1
@
text
@a3 3
 * Revision 1.40.3.1  1996/12/17  18:18:35  hope
 * branched from 1.40
 *
@


1.40.2.1
log
@branched from 1.40
@
text
@a3 4
 * Revision 1.40  1996/11/04  19:11:21  andreww
 * [Bug #1711]
 * Altering eq_and_imp to take account of real literals.
 *
@


1.40.1.1
log
@branched from 1.40
@
text
@a3 4
 * Revision 1.40  1996/11/04  19:11:21  andreww
 * [Bug #1711]
 * Altering eq_and_imp to take account of real literals.
 *
@


1.40.1.1.1.1
log
@branched from 1.40.1.1
@
text
@a3 3
 * Revision 1.40.1.1  1996/11/14  13:22:09  hope
 * branched from 1.40
 *
@


1.39
log
@[Bug #1521]
Adding check for value polymorphism in unification of imperative variables
eq_and_imp.
@
text
@d4 5
d402 9
a410 1
        | eq_and_imp (options,eq,imp,META_OVERLOADED _) = true
@


1.39.3.1
log
@branched from 1.39
@
text
@a3 5
 * Revision 1.39  1996/08/01  14:37:17  andreww
 * [Bug #1521]
 * Adding check for value polymorphism in unification of imperative variables
 * eq_and_imp.
 *
@


1.39.2.1
log
@branched from 1.39
@
text
@a3 5
 * Revision 1.39  1996/08/01  14:37:17  andreww
 * [Bug #1521]
 * Adding check for value polymorphism in unification of imperative variables
 * eq_and_imp.
 *
@


1.39.1.1
log
@branched from 1.39
@
text
@a3 5
 * Revision 1.39  1996/08/01  14:37:17  andreww
 * [Bug #1521]
 * Adding check for value polymorphism in unification of imperative variables
 * eq_and_imp.
 *
@


1.38
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d306 2
d309 22
a330 10
          
      fun eq_and_imp (eq,imp,(TYVAR (_,Ident.TYVAR (_,eq',imp')))) = 
        if eq 
          then (eq' andalso (if imp
                               then imp' 
                             else true))
        else (if imp
                then imp'
              else true)
        | eq_and_imp (eq,imp,FUNTYPE (a,r)) =
d333 11
a343 2
          else (eq_and_imp (eq,imp,a)) andalso (eq_and_imp (eq,imp,r))
        | eq_and_imp (eq,imp,DEBRUIJN (_,eq',imp',_)) =
d351 2
a352 1
        | eq_and_imp (eq,imp,
d355 1
a355 1
          (eq_and_imp (eq,imp,Types.apply (tyfun,tylist))
d358 2
a359 1
                   | collect (h::t) = eq_and_imp (eq,imp,h) andalso (collect t)
d365 1
a365 1
        | eq_and_imp (eq,imp,CONSTYPE ([],name)) =
d369 1
a369 1
        | eq_and_imp (eq,imp,CONSTYPE ([h],name)) =
d372 4
a375 4
              eq_and_imp (false,imp,h)
            else Types.eq_attrib name andalso eq_and_imp (eq,imp,h)
          else eq_and_imp (eq,imp,h)
        | eq_and_imp (eq,imp,CONSTYPE (t,n)) = 
d377 2
a378 1
                | collect (h::t) = eq_and_imp (eq,imp,h) andalso (collect t)
d382 5
a386 4
        | eq_and_imp (eq,imp,RECTYPE amap) = 
          NewMap.forall (fn (_, x) => eq_and_imp(eq, imp, x)) amap
        | eq_and_imp (eq,imp,NULLTYPE) = true
        | eq_and_imp (eq,imp,METATYVAR (x as ref (n,NULLTYPE,i),eq',imp')) =
d393 1
a393 1
        | eq_and_imp (eq,imp,METATYVAR (ref (_,t,_),eq',imp')) =
d395 1
a395 1
            then (eq_and_imp (eq,imp,t))
d397 3
a399 2
        | eq_and_imp (eq,imp,META_OVERLOADED _) = true
        | eq_and_imp (eq,imp,METARECTYPE (r as ref (n,true,t,eq',imp'))) =
d404 2
a405 1
        | eq_and_imp (eq,imp,METARECTYPE (r as ref (n,false,t,eq',imp'))) =
d407 1
a407 1
            then (eq_and_imp (eq,imp,t))
d495 4
a498 4
      fun unify_lists ([], []) = ()
	| unify_lists (h :: t, h' :: t') = 
	  (unify' (h, h');
	   unify_lists (t, t'))
d502 1
a502 1
      and unify'(atype, atype') =
d507 1
a507 1
	  unify (atype, atype')
d512 1
a512 1
      and unify(atype, atype') =
d529 2
a530 2
	    (unify'(a, a');
	     unify'(r, r'))
d535 1
a535 1
	      fun unify'' (ty, ty') = (unify'(ty, ty') ; true)
d564 1
a564 1
	    do_unify(r, eq, imp, atype')
d567 1
a567 1
	    do_unify(r', eq', imp', atype)
d570 1
a570 1
	    unify'(t, atype')
d573 1
a573 1
	    unify'(atype, t')
d582 1
a582 1
	    (do_unify_rec(r, atype') 
d586 1
a586 1
	    (do_unify_rec(r', atype)
d591 1
a591 1
	      unify_lists(l, l')
d599 1
a599 1
      and do_unify(r as ref (n, NULLTYPE,inst), eq, imp, t') =
d612 1
a612 1
		if eq_and_imp (eq, imp, t') 
d617 1
a617 1
	     if (n > n') andalso eq_and_imp (eq, imp, t') then
d619 1
a619 1
	     else do_unify(r, eq, imp, t'')
d622 1
a622 1
	     do_unify(r, eq, imp, Types.apply (tyfun, l))
d625 1
a625 1
	     do_unify(r, eq, imp, Types.apply (tyfun, l))
d628 1
a628 1
	     if eq_and_imp (eq, imp, t')
d641 1
a641 1
		 if eq_and_imp (eq, imp, t')
d657 1
a657 1
		 if eq_and_imp (eq, imp, t') then
d672 1
a672 2
      and do_overload 
	    (ol as (r, tv, valid, loc), t') =
d760 2
a761 1
      and do_unify_rec(r as ref (level, _,ty as RECTYPE amap, eq, imp), t') =
d768 1
a768 1
		if eq_and_imp (eq,imp,t') then
d770 1
a770 1
		    fun unify'' (ty1, ty2) =
d772 2
a773 2
			if eq_and_imp (eq, imp, ty2) then
			  (unify'(ty1, ty2); true)
d775 1
a775 1
		      else (unify'(ty1, ty2); true)
d790 1
a790 1
		       if unify''(ty, ty') then
d834 1
a834 1
			    if eq_and_imp (eq', imp', x) 
d845 1
a845 1
			    if eq_and_imp (eq, imp, x)
d852 2
a853 2
		      fun unify''(x, y) =
			(unify'(leftfun x, rightfun y); true)
d872 1
a872 1
			     (unify''(ty, ty');
d917 1
a917 1
	   unify'(x, y);
d930 2
@


1.37
log
@Removing string_inequalities option
@
text
@d4 3
d888 1
a888 1
	      (output(std_out,
@


1.36
log
@Replacing Map with NewMap
@
text
@d4 3
d457 4
a460 4
      fun unify_lists (allow_string, [], []) = ()
	| unify_lists (allow_string, h :: t, h' :: t') = 
	  (unify' (allow_string, h, h');
	   unify_lists (allow_string, t, t'))
d464 1
a464 1
      and unify'(allow_string, atype, atype') =
d469 1
a469 1
	  unify (allow_string, atype, atype')
d474 1
a474 1
      and unify(allow_string, atype, atype') =
d491 2
a492 2
	    (unify'(allow_string, a, a');
	     unify'(allow_string, r, r'))
d497 1
a497 1
	      fun unify'' (ty, ty') = (unify'(allow_string, ty, ty') ; true)
d526 1
a526 1
	    do_unify(allow_string, r, eq, imp, atype')
d529 1
a529 1
	    do_unify(allow_string, r', eq', imp', atype)
d532 1
a532 1
	    unify'(allow_string, t, atype')
d535 1
a535 1
	    unify'(allow_string, atype, t')
d538 1
a538 1
	     do_overload(allow_string, ol, atype')
d541 1
a541 1
	    do_overload(allow_string, ol, atype)
d544 1
a544 1
	    (do_unify_rec(allow_string, r, atype') 
d548 1
a548 1
	    (do_unify_rec(allow_string, r', atype)
d553 1
a553 1
	      unify_lists(allow_string, l, l')
d561 1
a561 1
      and do_unify(allow_string, r as ref (n, NULLTYPE,inst), eq, imp, t') =
d581 1
a581 1
	     else do_unify(allow_string, r, eq, imp, t'')
d584 1
a584 1
	     do_unify(allow_string, r, eq, imp, Types.apply (tyfun, l))
d587 1
a587 1
	     do_unify(allow_string, r, eq, imp, Types.apply (tyfun, l))
d635 1
a635 1
	    (allow_string, ol as (r, tv, valid, loc), t') =
d691 1
a691 1
	    do_overload(allow_string, ol, t'')
d701 1
a701 2
	       	     orelse (allow_string
			     andalso Types.num_or_string_typep t')) then
d723 1
a723 1
      and do_unify_rec(allow_string, r as ref (level, _,ty as RECTYPE amap, eq, imp), t') =
d735 1
a735 1
			  (unify'(allow_string, ty1, ty2); true)
d737 1
a737 1
		      else (unify'(allow_string, ty1, ty2); true)
d815 1
a815 1
			(unify'(allow_string, leftfun x, rightfun y); true)
d866 1
a866 4
      fun unified(Options.OPTIONS
		  {compat_options=Options.COMPATOPTIONS
		   {string_inequalities=allow_string, ...}, ...}, x, y,
		  return_substitution) =
d879 1
a879 1
	   unify'(allow_string, x, y);
@


1.35
log
@Pretty up require statements
@
text
@d4 3
d136 1
d230 1
a230 1
            RECTYPE (Mapping.mapit(amap,substitute_type))
d236 3
d280 1
a280 1
          RECTYPE (Mapping.mapit (amap, propagate_level level))
d289 2
d345 1
a345 1
          Mapping.forall (amap,fn x => eq_and_imp (eq,imp,x)) 
d399 1
a399 1
          Mapping.forall (amap,fn x => not_occurs (ameta,x)) 
d495 1
a495 1
	      val res = Mapping.compare (amap, amap', unify'')
d497 9
d514 1
a514 1
		    val rec1  = Mapping.assoc amap
d519 1
d737 22
d773 1
d815 22
d841 1
@


1.34
log
@Added unification code for new overloaded tyvars.
@
text
@d4 3
d118 1
a118 1
require  "../utils/crash";
@


1.33
log
@Handle overloading of mod and div on ints and words
@
text
@d4 3
d609 2
a610 1
      and do_overload(allow_string, ol as (r, tv, valid, loc), t') =
d613 2
d617 44
a660 4
	    else if tv = Ident.int_literal_tyvar
		    orelse tv = Ident.real_literal_tyvar
		    orelse tv = Ident.word_literal_tyvar then
	      (!assign3)(r',META_OVERLOADED(r, tv, valid, loc))
d662 1
a662 1
	      (!assign3)(r,t')
d665 1
d669 2
d682 4
a685 1
	    else if (tv = Ident.int_tyvar orelse tv = Ident.int_literal_tyvar)
d691 1
a691 1
	    else if (tv = Ident.word_tyvar orelse tv = Ident.word_literal_tyvar)
@


1.32
log
@Improving record domain error messages
@
text
@d4 3
d421 1
a421 2
      val predicates = ["<", ">", "<=", ">="]
      fun check_predicate(Ident.VAR sy) =
d423 7
a429 1
	  val sy = Ident.Symbol.symbol_name sy
d431 1
a431 1
	  Lists.member(sy, predicates)
d433 5
a437 1
	| check_predicate _ = false
d612 2
a613 1
		    orelse tv = Ident.real_literal_tyvar then
d630 3
d634 1
a634 1
		 andalso Types.int_typep t' then
d637 4
a640 1
		 andalso Types.real_typep t' then
@


1.31
log
@Moving various functions in here from Types
@
text
@d4 3
d131 3
a133 3
    datatype domain =
      RIGID of Ident.Lab list
    | FLEX  of Ident.Lab list
d155 1
a155 1
      (* Different domains. Returns the two conflicting record domains. *)
d157 1
a157 1
    | RECORD_DOMAIN of domain * domain
d478 2
a479 2
		    val dom  = Mapping.domain amap
		    val dom' = Mapping.domain amap'
d481 1
a481 1
		    fail RECORD_DOMAIN (RIGID dom, RIGID dom')
d651 2
a652 2
			  val dom  = Mapping.domain amap
			  val dom' = Mapping.domain amap'
d654 1
a654 1
			  fail RECORD_DOMAIN (FLEX dom, RIGID dom')
@


1.30
log
@Removing debug structure
@
text
@d4 3
d254 157
d531 1
a531 1
		if Types.eq_and_imp (eq, imp, t') 
d536 1
a536 1
	     if (n > n') andalso Types.eq_and_imp (eq, imp, t') then
d547 1
a547 1
	     if Types.eq_and_imp (eq, imp, t')
d558 1
a558 1
	     if Types.not_occurs (METATYVAR (r, eq, imp), t')
d560 1
a560 1
		 if Types.eq_and_imp (eq, imp, t')
d566 1
a566 1
			(!assign2)(r',(n'', true, Types.propagate_level n'' ty, 
d574 1
a574 1
	     if Types.not_occurs (METATYVAR (r, eq, imp), t') 
d576 1
a576 1
		 if Types.eq_and_imp (eq, imp, t') then
d631 2
a632 2
	      if Types.not_occurs (t, t') then
		if Types.eq_and_imp (eq,imp,t') then
d636 1
a636 1
			if Types.eq_and_imp (eq, imp, ty2) then
d645 1
a645 1
				      Types.propagate_level level t', eq, imp))
d663 1
a663 1
		if Types.not_occurs (t, t') andalso Types.not_occurs (t', t)
d675 1
a675 1
			    if Types.eq_and_imp (eq', imp', x) 
d686 1
a686 1
			    if Types.eq_and_imp (eq, imp, x)
d705 1
a705 1
                                    Types.propagate_level level'' t',eq, imp));
d707 1
a707 1
                                     Types.propagate_level level'' (RECTYPE new_map),
@


1.29
log
@Change to substitution datatype
@
text
@d4 3
a104 1
require "../typechecker/ty_debug";
a112 1
  structure Ty_Debug : TY_DEBUG
a113 6

  structure Debug :
	      sig
		val set_debug_level : int -> unit
		val debug_level     : unit -> int
	      end
@


1.28
log
@Fixed erroneous boolean  expressions in do_overload.
@
text
@d4 3
d138 4
a141 4
    type substitution = 
      ((int * Datatypes.Type * Datatypes.Instance) refargs list *
       (int * bool * Type * bool * bool) refargs list *
       Type refargs list)
d192 3
a194 3
    fun apply_sub1(tyv,S:substitution) = ref(Lists.assoc(tyv,#1(S)))
    fun apply_sub2(recty,S:substitution) = ref(Lists.assoc(recty,#2(S)))
    fun apply_sub3(ty,S:substitution) = ref(Lists.assoc(ty,#3(S)))
d585 1
a585 1
	     SUBSTITUTION (!substitution)
d591 1
a591 1
	       SUBSTITUTION (!substitution))
@


1.27
log
@New overloading scheme.
@
text
@d4 3
d456 1
a456 1
	    else if tv = Ident.int_tyvar orelse tv = Ident.int_literal_tyvar
d459 1
a459 1
	    else if tv = Ident.real_tyvar orelse tv = Ident.real_literal_tyvar
@


1.26
log
@Changed Datatypes.instance to Datatypes.Instance.
@
text
@d4 3
d171 1
a171 1
    | OVERLOADED of Type
d200 2
a201 2
                            (tyv as ref NULLTYPE,v)) = 
            (META_OVERLOADED(apply_sub3(tyv,S),v)
d203 1
a203 1
          | substitute_type(META_OVERLOADED (ref ty,_)) = substitute_type ty
d230 1
a230 1
      fun remove_cons_meta (ty as META_OVERLOADED (ref ty',_)) =
d333 2
a334 2
	| (META_OVERLOADED (r as ref NULLTYPE, id), _) =>
	     do_unify_num(allow_string, r, id, atype')
d336 2
a337 2
	| (_, META_OVERLOADED (r' as ref NULLTYPE, id)) =>
	    do_unify_num(allow_string, r', id, atype)
d430 10
a439 5
      and do_unify_num(allow_string, r, id, t) =
	case t of
	  META_OVERLOADED(r' as ref NULLTYPE,_) =>
	    if (r = r') then ()
	    else (!assign3)(r,t)
d441 2
a442 1
	| META_OVERLOADED(ref t',_) => do_unify_num(allow_string, r, id, t')
d445 15
a459 4
	    if Types.num_typep t orelse
	      (allow_string andalso check_predicate id andalso Types.num_or_string_typep t)
	      then (!assign3)(r,t)
	    else fail OVERLOADED t
@


1.25
log
@Remove TYNAME, fix substitution reference, remove old debugging code,
tidy up comments.
@
text
@d4 4
d130 1
a130 1
      ((int * Datatypes.Type * Datatypes.instance) refargs list *
d177 2
a178 2
    val assign1 : (((int * Type * instance) ref
                    * (int * Type * instance)) -> unit) ref = ref(fn _ => ())
d357 1
@


1.24
log
@Modified unified to be optionally side-effect free, returning substitutions;
Can apply resulting substitutions to types.
@
text
@d4 4
a111 14
    (*****
    Printing out of debugging information.
    *****)

    val do_debug = Ty_Debug.do_debug andalso Debug.debug_level() > 10

    fun debug L =
      if do_debug then
	(Lists.iterate Print.print L)
      else
	()

    fun outit l =
      Lists.iterate Print.print l
a112 2
    val showit = false

d115 1
a115 3
    (*****
    Datatype for record domains in error results.
    *****)
d121 3
a123 3
    (*****
    The result of unification.
    *****)
d126 6
a131 4
      ((int * Datatypes.Type * Datatypes.instance) ref 
                    * (int * Datatypes.Type * Datatypes.instance)) list *
      ((int * bool * Type * bool * bool) ref * (int * bool * Type * bool * bool)) list *
      (Type ref * Type) list
d134 1
a134 3
      (*****
      Unification succeeded.
      *****)
d137 1
a137 5
      (*****
      General failure.
      ******
      Returns the sub-types which could not be unified.
      *****)
d141 1
a141 13
      (*****
      Type name clash.
      ******
      Returns the type names which are different.
      *****)

    | TYNAME of Tyname * Tyname

      (*****
      Different domains.
      ******
      Returns the two conflicting record domains.
      *****)
d145 2
a146 5
      (*****
      Explicit tyvars.
      ******
      Returns the explicit tyvar and the type it couldn't unify with.
      *****)
d150 3
a152 6
      (*****
      Wrong equality and imperative attributes.
      ******
      The first boolean is the equality attribute required, the
      second is the imperative attribute.
      *****)
d156 2
a157 5
      (*****
      Circularity.
      ******
      Returns the tyvar and the type which it couldn't unify to.
      *****)
d161 2
a162 5
      (*****
      Overloading.
      ******
      Returns the type which could not be unified to the overloaded type.
      *****)
d166 2
d170 3
a172 1
    val S : substitution ref = ref(nil,nil,nil)
d178 1
d182 1
d215 1
a215 3
      (*****
      Exception raised in the event of failure.
      *****)
d219 1
a219 3
      (*****
      Fail with a result.
      *****)
d245 1
a245 3
      (*****
      Unify a list of types.
      *****)
d258 2
a259 3
	  (if do_debug then debug ["unifying lists"] else ();
	   (unify' (allow_string, h, h');
	    unify_lists (allow_string, t, t')))
d271 1
a271 3
      (*****
      Unify two types.
      *****)
a273 1

d277 4
a280 5
	    (if do_debug then debug ["unifying TYVAR and TYVAR"] else ();
	     (if (n = n' andalso id = id') then
		()
	      else
		fail EXPLICIT_TYVAR (atype, atype')))
d283 5
a287 6
	    (if do_debug then debug ["unifying DEBRUIJN and DEBRUIJN"] else ();
	     (if ((fn ty=>(#1(ty),#2(ty),#3(ty)))debruijn) = 
                ((fn ty=>(#1(ty),#2(ty),#3(ty)))debruijn')
		then ()
	      else
		fail FAILED (atype, atype')))
d290 2
a291 2
	    (if do_debug then debug ["unifying FUNTYPE and FUNTYPE"] else ();
	     (unify'(allow_string, a, a') ; unify'(allow_string, r, r')))
d294 8
a301 9
	    (if do_debug then debug ["unifying RECTYPE and RECTYPE"] else ();
	     let
	       (* Note that unify' fails using an exception *)
	       fun unify'' (ty, ty') = (unify'(allow_string, ty, ty') ; true)
	       val res = Mapping.compare (amap, amap', unify'')
	     in
	       case res of
		 Mapping.EQUAL =>
		   ()
d312 1
a312 4
(*
                  fail FAILED (atype,atype')
*)
	    end)
d315 1
a315 5
	    (if do_debug then debug
	       ["unifying uninstantiated METATYVAR ", MLWorks.Integer.makestring n,
		"and ", Types.debug_print_type atype']
	     else ();
	     do_unify(allow_string, r, eq, imp, atype'))
d318 1
a318 5
	    (if do_debug then debug
	       ["unifying ",Types.debug_print_type atype, 
		" and uninstantiated METATYVAR ", MLWorks.Integer.makestring n']
	     else ();
	     do_unify(allow_string, r', eq', imp', atype))
d321 1
a321 4
	    (if do_debug then debug
	       ["unifying instantiated METATYVAR ", MLWorks.Integer.makestring n,
		"and ", Types.debug_print_type atype'] else ();
	     unify'(allow_string, t, atype'))
d324 1
a324 5
	    (if do_debug then debug
	       ["unifying ",Types.debug_print_type atype, 
		" and instantiated METATYVAR ", MLWorks.Integer.makestring n']
	     else ();
	     unify'(allow_string, atype, t'))
d327 1
a327 6
	    (if do_debug then
	       debug
	       ["unifying uninstantiated META_OVERLOADED and ",
		Types.debug_print_type atype']
	     else ();
	     do_unify_num(allow_string, r, id, atype'))
d330 1
a330 5
	    (if do_debug then debug
	       ["unifying ", Types.debug_print_type atype,
		" and uninstantiated META_OVERLOADED"]
	     else ();
	     do_unify_num(allow_string, r', id, atype))
d333 2
a334 6
	    (if do_debug then debug
	       ["unifying METARECTYPE (flex) and ",
		Types.debug_print_type atype']
	     else ();
	     do_unify_rec(allow_string, r, atype') 
               handle NotRectype => fail FAILED (atype,atype'))
d337 2
a338 6
	    (if do_debug then debug
	       ["unifying ",Types.debug_print_type atype,
		" and METARECTYPE (flex)"]
	     else ();
	     do_unify_rec(allow_string, r', atype)
               handle NotRectype => fail FAILED (atype,atype'))
d341 4
a344 9
	    (if do_debug then debug
	       ["unifying CONSTYPE and CONSTYPE \n",
		"n = ", Types.debug_print_name n,
		" n' = ", Types.debug_print_name n']
	     else ();
	     (if Types.tyname_eq (n, n') then
		unify_lists(allow_string, l, l')
	      else
		fail FAILED (atype, atype')))
d348 1
a348 3
      (*****
      Do the unification between a metatyvar and a type.
      *****)
d353 13
a365 19
	     (if do_debug then debug
		["do_unify two uninstantiated metatyvars ",
		 MLWorks.Integer.makestring n, " and ", MLWorks.Integer.makestring n']
	      else ();
	      if r = r'
		then ()
	      else
		(let
		   val n'' = if n < n' then n else n'
		 in
		   ((!assign1)(r',(n'', NULLTYPE,inst'));
		    (!assign1)(r,(n'', t',inst)))
		 end;
		 if Types.eq_and_imp (eq, imp, t') 
		   then
		     ()
		 else
		   Crash.impossible "Unify.do_unify METATYVAR and METATYVAR"))
	     
d367 4
a370 9
	     (if do_debug then debug
		["do_unify uninstantiated and instantiated metas ",
		 MLWorks.Integer.makestring n, " and ", MLWorks.Integer.makestring n']
	      else ();
	      if (n > n') andalso Types.eq_and_imp (eq, imp, t') then
                (!assign1)(r,(n', t',inst))
	      else
		do_unify(allow_string, r, eq, imp, t''))

d372 2
a373 5
	     (if do_debug then debug 
		["do_unify uninstantiated meta and CONSTYPE ... ETA_TYFUN"]
	      else ();
	      do_unify(allow_string, r, eq, imp, Types.apply (tyfun, l)))

d375 2
a376 5
	     (if do_debug then
		debug ["do_unify uninstantiated meta and CONSTYPE ... TYFUN"]
	      else ();
	      do_unify(allow_string, r, eq, imp, Types.apply (tyfun, l)))

d378 10
a387 14
	     (if do_debug then
		debug ["do_unify uninstantiated meta and TYVAR"]
	      else ();
	      if Types.eq_and_imp (eq, imp, t')
		then
		  let
		    val n'' = if n < n' then n else n'
		  in
		    ((!assign1)(r,(n'', t',inst));
		     (!assign1)(r',(n'',t,inst')))
		  end
	      else
		fail EQ_AND_IMP (eq, imp, t'))
		
d389 15
a403 22
	     (if do_debug then debug
		["do_unify uninstantiated meta and flex METARECTYPE\n",
		 "level of METATYVAR = ", MLWorks.Integer.makestring n,
		 "level of flex METARECTYPE = ", MLWorks.Integer.makestring n']
	      else ();
	      if Types.not_occurs (METATYVAR (r, eq, imp), t')
		then
		  if Types.eq_and_imp (eq, imp, t')
		    then
		      let 
			val n'' = if n < n' then n else n'
		      in
			((!assign1)(r,(n'', t',inst));
			 (!assign2)(r',(n'', true, Types.propagate_level n'' ty, 
                                        eq orelse eq',
                                        imp orelse imp')))
		      end
		  else
		    fail EQ_AND_IMP (eq, imp, t')
	      else
		fail CIRCULARITY (METATYVAR (r, eq, imp), t'))

d405 11
a415 15
	     (if do_debug then debug
		["do_unify uninstantiated meta and ",
		 (Types.debug_print_type ty)]
	      else ();
	      if Types.not_occurs (METATYVAR (r, eq, imp), t') 
		then
		  if Types.eq_and_imp (eq, imp, t') then
                    ((case t' of
                        NULLTYPE => output(std_out,"\n ***** NULLTYPE ******\n")
                      | _ => ());
                        (!assign1)(r,(n, t',inst)))
		  else
		    fail EQ_AND_IMP (eq, imp, t')
	      else
		fail CIRCULARITY (METATYVAR (r, eq, imp), t')))
d419 2
a420 5
      (*****
      Unify a meta-overloaded tyvar.
      ******
      The second argument will not be a metatyvar.
      *****)
d425 2
a426 4
	    (if (r = r') then
	       ()
	     else
	       (!assign3)(r,t))
d431 4
a434 6
	    (if Types.num_typep t orelse
	       (allow_string andalso check_predicate id andalso Types.num_or_string_typep t)
	       then
		 (!assign3)(r,t)
	     else
	       fail OVERLOADED t)
d436 2
a437 5
      (*****
      Unify a flexible record type.
      ******
      The second argument will not be a metatyvar.
      *****)
d440 32
a471 51
	(if do_debug then
	   debug ["do_unify_rec: ty = ",Types.debug_print_type ty," and t' = ",
		  Types.debug_print_type t',
		  "level of flex METARECTYPE = ", MLWorks.Integer.makestring level]
	 else ();
	 let
	   val t = METARECTYPE r
	 in
	   case t' of
	     RECTYPE amap' =>
	       if Types.not_occurs (t, t') then
		 if Types.eq_and_imp (eq,imp,t') then
		   let
		     fun unify'' (ty1, ty2) =
		       (if do_debug then debug
			  ["unify'' ",Types.debug_print_type ty1," and ",
			   Types.debug_print_type ty2]
			else ();
			  if (eq orelse imp) then
			    if Types.eq_and_imp (eq, imp, ty2) then
			      (unify'(allow_string, ty1, ty2); true)
			    else
			      fail EQ_AND_IMP (eq, imp, ty2)
			  else
			    (unify'(allow_string, ty1, ty2); true))
		   in
		     case Mapping.size (amap', amap, Ident.lab_order, 
					unify'') of
		       Mapping.BIGGER =>
			 (if do_debug then debug
			    ["BIGGER ", Types.debug_print_type t']
			  else ();
			    (!assign2)(r,(level, false,
                                          Types.propagate_level level t', eq, imp)))
		     | Mapping.NOT_BIGGER =>
			 let
			   val dom  = Mapping.domain amap
			   val dom' = Mapping.domain amap'
			 in
			   fail RECORD_DOMAIN (FLEX dom, RIGID dom')
			 end
(*
                             fail FAILED (t,t')
*)
		     | Mapping.DIFFERENT_RANGE =>
			 Crash.impossible "Unify.Mapping.size"
		   end
		 else
		   fail EQ_AND_IMP (eq,imp,t')
	       else
		 fail CIRCULARITY (t, t')
d528 1
a528 1
	 end)
d534 1
a534 3
      (*****
      Top level unification function.
      *****)
d538 23
a560 21
		   {string_inequalities=allow_string, ...}, ...}, x, y, return_substitution) =
        (assign1 := (if return_substitution then (fn r=>S := (r:: #1(!S),#2(!S),#3(!S)))
                     else (fn (r,r')=>r:=r'));
         assign2 := (if return_substitution then (fn r=>S := (#1(!S),r:: #2(!S),#3(!S)))
                     else (fn (r,r')=>r:=r'));
         assign3 := (if return_substitution then (fn r=>S := (#1(!S),#2(!S),r:: #3(!S)))
                     else (fn (r,r')=>r:=r'));
         if showit andalso not (Types.type_eq (x,y,true,true))
           then (* do_debug then debug *)
             outit [Types.debug_print_type x," && ",
                    Types.debug_print_type y,"\n"]
         else ();
         unify'(allow_string, x, y);
         if return_substitution then
           SUBSTITUTION(!S)
         else OK)
         handle Failed res => 
           if return_substitution then 
            (output(std_out,
                    "\nWarning: Unification Failure; recipes may not be generated correctly\n");
             SUBSTITUTION(!S))
d562 1
@


1.23
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d139 5
d208 41
d454 2
a455 2
		   (r' := (n'', NULLTYPE,inst');
		    r := (n'', t',inst))
d469 1
a469 1
                r := (n', t',inst)
d494 2
a495 2
		    (r  := (n'', t',inst);
		     r' := (n'',t,inst'))
d513 4
a516 4
			(r := (n'', t',inst);
			 r' := (n'', true, Types.propagate_level n'' ty, 
				eq orelse eq',
				imp orelse imp'))
d534 1
a534 1
                        r := (n, t',inst))
d554 1
a554 1
	       r := t)
d562 1
a562 1
		 r := t
d605 2
a606 2
			    r := (level, false,
				  Types.propagate_level level t', eq, imp))
d670 5
a674 5
		      r  := (level'', true, 
			     Types.propagate_level level'' t',eq, imp);
		      r' := (level'', true, 
			     Types.propagate_level level'' (RECTYPE new_map),
			     eq', imp')
d692 8
a699 2
		   {string_inequalities=allow_string, ...}, ...}, x, y) =
	(if showit andalso not (Types.type_eq (x,y,true,true))
d705 9
a713 2
         OK)
         handle Failed res => res
@


1.22
log
@Change to output statements/
@
text
@d4 3
d201 1
d273 1
a273 1
	  (TYVAR (ref n, id), TYVAR (ref n', id')) =>
d282 2
a283 1
	     (if debruijn = debruijn'
d317 1
a317 1
	| (METATYVAR (r as ref (n, NULLTYPE), eq, imp), _) =>
d324 1
a324 1
	| (_, METATYVAR (r' as ref (n', NULLTYPE), eq', imp')) =>
d331 1
a331 1
	| (METATYVAR (ref (n, t), _, _), _) =>
d337 1
a337 1
	| (_, METATYVAR (ref (n', t'), _, _)) =>
d392 1
a392 1
      and do_unify(allow_string, r as ref (n, NULLTYPE), eq, imp, t') =
d394 1
a394 1
	   METATYVAR (r' as ref (n', NULLTYPE), eq', imp') =>
d405 2
a406 2
		   (r' := (n'', NULLTYPE);
		    r := (n'', t'))
d414 1
a414 1
	 | METATYVAR (ref (n', t''), _, _) =>
d420 1
a420 1
		r := (n', t')
d436 1
a436 1
	 | TYVAR (r' as ref n',_) =>
d445 2
a446 2
		    (r  := (n'', t');
		     r' := n'')
d464 1
a464 1
			(r := (n'', t');
d482 4
a485 1
		    r := (n, t')
@


1.22.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.22  1993/05/25  16:15:44  matthew
Change to output statements/

@


1.21
log
@Removed integer parameter
@
text
@d4 3
d114 5
d636 8
a643 13
	( if do_debug then debug
	    ["\nUNIFY \n", Types.debug_print_type x,
	     "\n AND \n", Types.debug_print_type y]
	  else ();
	  (unify'(allow_string, x, y);
	   if do_debug then debug ["Unification successful\n"] else ();
	     OK
	  )
	  handle Failed res =>
	  (if do_debug then debug ["Unification unsuccessful\n"] else ();
	    res
	  )
	)
@


1.20
log
@Allowed overloadin on strings to be controlled by an option
@
text
@d4 3
a73 1
require "../utils/integer";
a82 1
  structure Integer : INTEGER
d306 1
a306 1
	       ["unifying uninstantiated METATYVAR ", Integer.makestring n,
d314 1
a314 1
		" and uninstantiated METATYVAR ", Integer.makestring n']
d320 1
a320 1
	       ["unifying instantiated METATYVAR ", Integer.makestring n,
d327 1
a327 1
		" and instantiated METATYVAR ", Integer.makestring n']
d384 1
a384 1
		 Integer.makestring n, " and ", Integer.makestring n']
d404 1
a404 1
		 Integer.makestring n, " and ", Integer.makestring n']
d441 2
a442 2
		 "level of METATYVAR = ", Integer.makestring n,
		 "level of flex METARECTYPE = ", Integer.makestring n']
d511 1
a511 1
		  "level of flex METARECTYPE = ", Integer.makestring level]
@


1.19
log
@Reinstated record domain mismatch error.
./
@
text
@d4 4
d73 1
d83 1
d97 1
a97 1

d236 2
a237 2
      fun unify_lists ([], []) = ()
	| unify_lists (h :: t, h' :: t') = 
d239 3
a241 3
	   (unify' (h, h');
	    unify_lists (t, t')))
	| unify_lists (_, _) =
d244 1
a244 1
      and unify'(atype, atype') =
d249 1
a249 1
	  unify (atype, atype')
d256 1
a256 1
      and unify (atype, atype') =
d276 1
a276 1
	     (unify' (a, a') ; unify' (r, r')))
d282 1
a282 1
	       fun unify'' (ty, ty') = (unify' (ty, ty') ; true)
d308 1
a308 1
	     do_unify (r, eq, imp, atype'))
d315 1
a315 1
	     do_unify (r', eq', imp', atype))
d321 1
a321 1
	     unify' (t, atype'))
d328 1
a328 1
	     unify' (atype, t'))
d336 1
a336 1
	     do_unify_num (r, id, atype'))
d343 1
a343 1
	     do_unify_num (r', id, atype))
d350 1
a350 1
	     do_unify_rec (r, atype') 
d358 1
a358 1
	     do_unify_rec (r', atype)
d368 1
a368 1
		unify_lists (l, l')
d378 1
a378 2
      and do_unify (r as ref (n, NULLTYPE), eq, imp, t') =

d408 1
a408 1
		do_unify (r, eq, imp, t''))
d414 1
a414 1
	      do_unify (r, eq, imp, Types.apply (tyfun, l)))
d420 1
a420 1
	      do_unify (r, eq, imp, Types.apply (tyfun, l)))
d482 1
a482 1
      and do_unify_num (r, id, t) =
d484 1
a484 1
	  META_OVERLOADED (r' as ref NULLTYPE,_) =>
d490 1
a490 2
	| META_OVERLOADED (ref t',_) =>
	    do_unify_num (r, id, t')
d493 4
a496 3
	    (if (check_predicate id andalso Types.num_or_string_typep t) orelse
	       Types.num_typep t then
	       r := t
d506 1
a506 1
      and do_unify_rec (r as ref (level, _,ty as RECTYPE amap, eq, imp), t') =
d517 11
a527 15
	       if Types.not_occurs (t, t') 
		 then
		   if Types.eq_and_imp (eq,imp,t')
		     then
		       let
			 fun unify'' (ty1, ty2) =
			   (if do_debug then debug
			      ["unify'' ",Types.debug_print_type ty1," and ",
			       Types.debug_print_type ty2]
			    else ();
			    if (eq orelse imp) then
			      if Types.eq_and_imp (eq, imp, ty2) then
				(unify' (ty1, ty2) ; true)
			      else
				fail EQ_AND_IMP (eq, imp, ty2)
d529 19
a547 17
			      (unify' (ty1, ty2) ; true))
		       in
			 case Mapping.size (amap', amap, Ident.lab_order, 
					    unify'') of
			   Mapping.BIGGER =>
			     (if do_debug then debug
				["BIGGER ", Types.debug_print_type t']
			      else ();
			      r := (level, false,
				    Types.propagate_level level t', eq, imp))
			 | Mapping.NOT_BIGGER =>
			     let
			       val dom  = Mapping.domain amap
			       val dom' = Mapping.domain amap'
			     in
                               fail RECORD_DOMAIN (FLEX dom, RIGID dom')
			     end
d551 5
a555 5
			 | Mapping.DIFFERENT_RANGE =>
			     Crash.impossible "Unify.Mapping.size"
		       end
		   else
		     fail EQ_AND_IMP (eq,imp,t')
d593 2
a594 2
		      fun unify'' (x, y) =
			(unify' (leftfun x, rightfun y) ; true)
d624 3
a626 1
      fun unified (x, y) =
d631 1
a631 1
	  (unify' (x, y);
@


1.18
log
@Allowed overloading of relationals on strings
@
text
@d4 3
a285 1
(*
d292 2
a294 1
                  fail FAILED (atype,atype')
a538 1
(*
d545 2
a547 1
                             fail FAILED (t,t')
@


1.17
log
@Rationalised substructures
@
text
@d4 3
d218 9
d321 1
a321 1
	| (META_OVERLOADED (r as ref NULLTYPE,_), _) =>
d327 1
a327 1
	     do_unify_num (r, atype'))
d329 1
a329 1
	| (_, META_OVERLOADED (r' as ref NULLTYPE,_)) =>
d334 1
a334 1
	     do_unify_num (r', atype))
d474 1
a474 1
      and do_unify_num (r, t) =
d483 1
a483 1
	    do_unify_num (r, t')
d486 2
a487 1
	    (if (Types.num_typep t) then
@


1.16
log
@Anel's last changes
@
text
@d4 3
d59 1
a60 1
require "../utils/lists";
a62 3
require "../basics/ident";
require "../basics/identprint";
require "unify";
a63 1
require "../typechecker/datatypes";
d65 1
a72 4
  structure Datatypes : DATATYPES
  structure Ident : IDENT
  sharing Ident = Datatypes.Ident

a73 1
  sharing Types.Datatypes = Datatypes
d83 2
a84 1
    structure Datatypes = Datatypes
@


1.15
log
@RECORD_DOMAIN failure no longer generated.
@
text
@d4 3
d193 1
a193 1
      fun remove_cons_meta(ty as META_OVERLOADED(ref ty')) =
d197 1
a197 1
	| remove_cons_meta(ty as METARECTYPE(ref{2 = b, 3 = t, ...})) =
d202 1
a202 1
	| remove_cons_meta(ty as CONSTYPE(l, tyname)) =
d204 1
a204 1
	     METATYNAME{1 = ref tyfun, ...} =>
d206 2
a207 2
		  ETA_TYFUN _ => remove_cons_meta(Types.apply(tyfun, l))
		| TYFUN _ => remove_cons_meta(Types.apply(tyfun, l))
a210 6
(*
	| remove_cons_meta(CONSTYPE(l, METATYNAME{1=ref(tf as ETA_TYFUN _), ...})) =
	remove_cons_meta(Types.apply(tf, l))
	| remove_cons_meta(CONSTYPE(l, METATYNAME{1=ref(tf as TYFUN _), ...})) =
	  remove_cons_meta(Types.apply(tf, l))
*)
d232 1
a232 1
	  unify(atype, atype')
a241 6
(*
	(CONSTYPE (l, METATYNAME{1=ref (tf as (ETA_TYFUN _)), ...}), _) =>
	    (if do_debug then debug
	       ["unifying CONSTYPE (_,METATYNAME ETA_TYFUN) and ",
	       Types.debug_print_type atype'] else ();
	     unify (Types.apply (tf, l), atype'))
a242 19
	| (CONSTYPE (l, METATYNAME{1=ref(tf as TYFUN _), ...}), _) =>
	    (if do_debug then debug
	       ["unifying CONSTYPE (_,METATYNAME TYFUN) and ",
		Types.debug_print_type atype'] else ();
	     unify (Types.apply (tf, l), atype'))

	| (_, CONSTYPE (l', METATYNAME{1=ref (tf' as (ETA_TYFUN _)), ...})) =>
	    (if do_debug then debug
	       ["unifying ",Types.debug_print_type atype, 
                " and CONSTYPE (_,METATYNAME ETA_TYFUN)"] else ();
	     unify (atype, Types.apply (tf', l')))

	| (_, CONSTYPE (l', METATYNAME{1=ref(tf' as TYFUN _), ...})) =>
	    (if do_debug then debug
	       ["unifying ",Types.debug_print_type atype,
                " and CONSTYPE (_,METATYNAME TYFUN)"] else ();
	     unify (atype, Types.apply (tf', l')))
*)

d313 3
a315 2
	| (META_OVERLOADED (r as ref NULLTYPE), _) =>
	    (if do_debug then debug
d321 1
a321 1
	| (_, META_OVERLOADED (r' as ref NULLTYPE)) =>
a327 45
(*
	| (META_OVERLOADED (ref t), _) =>
	    (if do_debug then debug
	       ["unifying instantiated META_OVERLOADED and ",
		Types.debug_print_type atype']
             else ();
	     unify' (t, atype'))

	| (_, META_OVERLOADED (ref t')) =>
	    (if do_debug then debug
	       ["unifying ",Types.debug_print_type atype,
		" and instantiated META_OVERLOADED"]
             else ();
	     unify' (atype, t'))
*)

(*
	| (METARECTYPE (r as ref (_, true, t as METARECTYPE _, _, _)), _) =>
	    (if do_debug then debug
	       ["unifying METARECTYPE (instantiated flex) and ", 
                Types.debug_print_type atype']
             else ();
	     unify' (t, atype'))

	| (METARECTYPE (ref (_, false, t, _, _)), _) =>
	    (if do_debug then debug
	       ["unifying METARECTYPE and ", Types.debug_print_type atype']
             else ();
	     
	     unify' (t, atype'))

	| (_, METARECTYPE (r' as ref (_, true, t' as METARECTYPE _, _, _))) =>
	    (if do_debug then debug
	       ["unifying ",Types.debug_print_type atype, 
                "and METARECTYPE (instantiated flex)"]
             else ();
	     unify' (atype,t'))

	| (_, METARECTYPE (ref (_, false, t', _, _))) =>
	    (if do_debug then debug
	       ["unifying ",Types.debug_print_type atype, " and METARECTYPE"]
             else ();
	     unify' (atype, t'))
*)
	     
a431 8
(*
			fun andnot (abool, abool') = 
			  if (abool andalso not abool') 
			    then abool orelse abool'
			  else abool'
			fun andnot(true, false) = true
			  | andnot(_, ok) = ok
*)
a432 1

d436 2
a437 2
				(*andnot (eq,eq')*) eq orelse eq',
				(*andnot (imp,imp')*) imp orelse imp'))
d468 1
a468 1
	  META_OVERLOADED (r' as ref NULLTYPE) =>
d474 1
a474 1
	| META_OVERLOADED (ref t') =>
a543 5
(*
          | METARECTYPE (ref (_, false, t', _, _)) =>
	      do_unify_rec (r, t')
*)

d600 1
a600 6
(*
      | do_unify_rec (ref (_, _, METARECTYPE (r as ref (_,true,_, eq, imp)),
		      _, _), t') =
	do_unify_rec (r, t')
*)
	
d602 1
d604 1
d625 1
@


1.14
log
@Avoided stringifying types etc as debug unless really required
@
text
@d4 3
d303 1
d310 2
d608 1
d613 1
a613 1
			       fail RECORD_DOMAIN (FLEX dom, RIGID dom')
d615 2
@


1.13
log
@Changed fail TYNAME ... to fail FAIL ...
@
text
@d4 3
d88 2
d91 1
a91 1
      if Ty_Debug.do_debug andalso Debug.debug_level() > 10 then
d221 1
a221 2
	  (debug ["unifying lists"];
	   
d244 1
a244 1
	    (debug
d246 1
a246 2
		Types.debug_print_type atype'];

d250 1
a250 1
	    (debug
d252 1
a252 2
		Types.debug_print_type atype'];
	     
d256 1
a256 1
	    (debug
d258 1
a258 2
                " and CONSTYPE (_,METATYNAME ETA_TYFUN)"];
	     
d262 1
a262 1
	    (debug
d264 1
a264 2
                " and CONSTYPE (_,METATYNAME TYFUN)"];
	     
d269 1
a269 2
	    (debug ["unifying TYVAR and TYVAR"];

d276 1
a276 2
	    (debug ["unifying DEBRUIJN and DEBRUIJN"];
	     
d283 1
a283 2
	    (debug ["unifying FUNTYPE and FUNTYPE"];
	     
d287 1
a287 1
	    (debug ["unifying RECTYPE and RECTYPE"];
d309 1
a309 1
	    (debug
d311 2
a312 2
		"and ", Types.debug_print_type atype'];
	     
d316 1
a316 1
	    (debug
d318 2
a319 2
		" and uninstantiated METATYVAR ", Integer.makestring n'];
	     
d323 1
a323 1
	    (debug
d325 1
a325 2
		"and ", Types.debug_print_type atype'];
	     
d329 1
a329 1
	    (debug
d331 2
a332 2
		" and instantiated METATYVAR ", Integer.makestring n'];
	     
d336 1
a336 1
	    (debug
d338 2
a339 2
		Types.debug_print_type atype'];
	     
d343 1
a343 1
	    (debug
d345 2
a346 2
		" and uninstantiated META_OVERLOADED"];
	     
d351 1
a351 1
	    (debug
d353 2
a354 2
		Types.debug_print_type atype'];
	     
d358 1
a358 1
	    (debug
d360 2
a361 2
		" and instantiated META_OVERLOADED"];
	     
d367 1
a367 1
	    (debug
d369 2
a370 2
                Types.debug_print_type atype'];
	     
d374 3
a376 2
	    (debug
	       ["unifying METARECTYPE and ", Types.debug_print_type atype'];
d381 1
a381 1
	    (debug
d383 2
a384 2
                "and METARECTYPE (instantiated flex)"];
	     
d388 3
a390 3
	    (debug
	       ["unifying ",Types.debug_print_type atype, " and METARECTYPE"];
	     
d395 4
a398 3
	    (debug
	       ["unifying METARECTYPE (flex) and ", Types.debug_print_type atype'];
	     
d403 4
a406 3
	    (debug
	       ["unifying ",Types.debug_print_type atype," and METARECTYPE (flex)"];
	     
d411 1
a411 1
	    (debug
d414 2
a415 2
		" n' = ", Types.debug_print_name n'];
	     
d431 1
a431 1
	     (debug
d433 2
a434 2
		 Integer.makestring n, " and ", Integer.makestring n'];
	      
d451 1
a451 1
	     (debug
d453 2
a454 2
		 Integer.makestring n, " and ", Integer.makestring n'];
	      
d461 3
a463 3
	     (debug 
		["do_unify uninstantiated meta and CONSTYPE ... ETA_TYFUN"];
	      
d467 3
a469 2
	     (debug ["do_unify uninstantiated meta and CONSTYPE ... TYFUN"];
	      
d473 3
a475 2
	     (debug ["do_unify uninstantiated meta and TYVAR"];
	      
d488 5
a492 4
	     (debug ["do_unify uninstantiated meta and flex METARECTYPE\n",
		      "level of METATYVAR = ", Integer.makestring n,
		      "level of flex METARECTYPE = ", Integer.makestring n'];
	     
d520 4
a523 3
	     (debug ["do_unify uninstantiated meta and ",
		       (Types.debug_print_type ty)];

d565 5
a569 4
	(debug ["do_unify_rec: ty = ",Types.debug_print_type ty," and t' = ",
                 Types.debug_print_type t',
		"level of flex METARECTYPE = ", Integer.makestring level];

d581 4
a584 2
			   (debug ["unify'' ",Types.debug_print_type ty1," and ",
				   Types.debug_print_type ty2];
d596 3
a598 1
			     (debug ["BIGGER ", Types.debug_print_type t'];
d690 1
a690 1
	( debug
d692 5
a696 5
	     "\n AND \n", Types.debug_print_type y];
	 
	  ( unify' (x, y);
	    debug ["Unification successful\n"];
	    OK
d699 1
a699 1
	  ( debug ["Unification unsuccessful\n"];
@


1.12
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d420 1
a420 1
		fail TYNAME (n, n')))
@


1.11
log
@Modified unify to avoid so much recursion by stripping off various
METAs first
@
text
@d4 4
a76 1
    val do_debug = Ty_Debug.do_debug
d82 1
a82 1
      if do_debug andalso Debug.debug_level() > 10 then
d212 1
a212 1
	  (if do_debug then debug ["unifying lists"] else ();
d236 1
a236 2
	    (if do_debug then
	       debug
d238 1
a238 2
		Types.print_type atype']
	     else ();
d243 1
a243 2
	    (if do_debug then
	       debug
d245 1
a245 2
		Types.print_type atype']
	     else ();
d250 3
a252 5
	    (if do_debug then
	       debug
	       ["unifying ",Types.print_type atype, 
                " and CONSTYPE (_,METATYNAME ETA_TYFUN)"]
	     else ();
d257 3
a259 5
	    (if do_debug then
	       debug
	       ["unifying ",Types.print_type atype,
                " and CONSTYPE (_,METATYNAME TYFUN)"]
	     else ();
d265 1
a265 1
	    (if do_debug then debug ["unifying TYVAR and TYVAR"] else ();
d273 1
a273 1
	    (if do_debug then debug ["unifying DEBRUIJN and DEBRUIJN"] else ();
d281 1
a281 1
	    (if do_debug then debug ["unifying FUNTYPE and FUNTYPE"] else ();
d286 1
a286 2
	    (if do_debug then debug ["unifying RECTYPE and RECTYPE"] else ();
	     
d308 1
a308 2
	    (if do_debug then
	       debug
d310 1
a310 2
		"and ", Types.print_type atype']
	     else ();
d315 3
a317 5
	    (if do_debug then
	       debug
	       ["unifying ",Types.print_type atype, 
		" and uninstantiated METATYVAR ", Integer.makestring n']
	     else ();
d322 1
a322 2
	    (if do_debug then
	       debug
d324 1
a324 2
		"and ", Types.print_type atype']
	     else ();
d329 3
a331 5
	    (if do_debug then
	       debug
	       ["unifying ",Types.print_type atype, 
		" and instantiated METATYVAR ", Integer.makestring n']
	     else ();
d336 1
a336 2
	    (if do_debug then
	       debug
d338 1
a338 2
		Types.print_type atype']
	     else ();
d343 3
a345 5
	    (if do_debug then
	       debug
	       ["unifying ", Types.print_type atype,
		" and uninstantiated META_OVERLOADED"]
	     else ();
d351 1
a351 2
	    (if do_debug then
	       debug
d353 1
a353 2
		Types.print_type atype']
	     else ();
d358 3
a360 5
	    (if do_debug then
	       debug
	       ["unifying ",Types.print_type atype,
		" and instantiated META_OVERLOADED"]
	     else ();
d367 1
a367 2
	    (if do_debug then
	       debug
d369 1
a369 2
                Types.print_type atype']
	     else ();
d374 2
a375 4
	    (if do_debug then
	       debug
	       ["unifying METARECTYPE and ", Types.print_type atype']
	     else ();
d380 3
a382 5
	    (if do_debug then
	       debug
	       ["unifying ",Types.print_type atype, 
                "and METARECTYPE (instantiated flex)"]
	     else ();
d387 2
a388 4
	    (if do_debug then
	       debug
	       ["unifying ",Types.print_type atype, " and METARECTYPE"]
	     else ();
d394 2
a395 4
	    (if do_debug then
	       debug
	       ["unifying METARECTYPE (flex) and ", Types.print_type atype']
	     else ();
d401 2
a402 4
	    (if do_debug then
	       debug
	       ["unifying ",Types.print_type atype," and METARECTYPE (flex)"]
	     else ();
d408 1
a408 2
	    (if do_debug then
	       debug
d410 2
a411 3
		"n = ", Types.print_name n,
		" n' = ", Types.print_name n']
	     else ();
d428 1
a428 2
	     (if do_debug then
	       debug
d430 1
a430 2
		 Integer.makestring n, " and ", Integer.makestring n']
	      else ();
d448 1
a448 2
	     (if do_debug then
	       debug
d450 1
a450 2
		 Integer.makestring n, " and ", Integer.makestring n']
	      else ();
d458 2
a459 4
	     (if do_debug then
	       debug 
		["do_unify uninstantiated meta and CONSTYPE ... ETA_TYFUN"]
	      else ();
d464 1
a464 1
	     (if do_debug then debug ["do_unify uninstantiated meta and CONSTYPE ... TYFUN"] else ();
d469 1
a469 1
	     (if do_debug then debug ["do_unify uninstantiated meta and TYVAR"] else ();
d483 1
a483 2
	     (if do_debug then
	       debug ["do_unify uninstantiated meta and flex METARECTYPE\n",
d485 1
a485 2
		      "level of flex METARECTYPE = ", Integer.makestring n']
	      else ();
d514 2
a515 4
	     (if do_debug then
		debug ["do_unify uninstantiated meta and ",
		       (Types.print_type ty)]
	      else ();
d558 3
a560 5
	(if do_debug then
	   debug ["do_unify_rec: ty = ",Types.print_type ty," and t' = ",
                  Types.print_type t',
		  "level of flex METARECTYPE = ", Integer.makestring level]
	 else ();
d573 2
a574 4
			   (if do_debug then
			      debug ["unify'' ",Types.print_type ty1," and ",
				     Types.print_type ty2]
			    else ();
d586 1
a586 3
			     (if do_debug then
				debug ["BIGGER ", Types.print_type t']
			      else ();
d678 3
a680 4
	(if do_debug then
	   debug
	   ["\nUNIFY \n", Types.print_type x, "\n AND \n", Types.print_type y]
	 else ();
d682 9
a690 9
	 let
	   val debug = do_debug andalso Debug.debug_level() > 10
	   val res = (unify' (x, y) ; OK) handle Failed (res) => res
	 in
	   case (debug, res) of
	     (false, res) => res
	   | (true , OK ) => (Print.print "Unification successful\n" ; OK)
	   | (true , err) => (Print.print "Unification unsuccessful\n" ; err)
	 end)
@


1.10
log
@Fail bad unification on flexible records properly instead of crashing
@
text
@d4 3
d175 20
a194 1
      fun remove_cons_meta(CONSTYPE(l, METATYNAME{1=ref(tf as ETA_TYFUN _), ...})) =
d198 1
d209 1
a209 1
	  (debug ["unifying lists"];
d270 1
a270 1
	    (debug ["unifying TYVAR and TYVAR"];
d278 1
a278 1
	    (debug ["unifying DEBRUIJN and DEBRUIJN"];
d286 1
a286 1
	    (debug ["unifying FUNTYPE and FUNTYPE"];
d291 1
a291 1
	    (debug ["unifying RECTYPE and RECTYPE"];
d367 1
d385 1
d387 1
d421 1
d506 1
a506 1
	     (debug ["do_unify uninstantiated meta and CONSTYPE ... TYFUN"];
d511 1
a511 1
	     (debug ["do_unify uninstantiated meta and TYVAR"];
d656 1
d659 1
d717 1
d721 1
@


1.9
log
@Some bug fixes from Anel
@
text
@d4 3
d178 2
d402 2
a403 1
	     do_unify_rec (r, atype'))
d411 2
a412 1
	     do_unify_rec (r', atype))
a676 3
(*		      r  := (level'', true, 
			     Types.propagate_level level'' (RECTYPE new_map),
			     eq, imp);*)
d686 1
a686 1
	  | _ => fail FAILED (ty, t')
@


1.8
log
@Improved unify pattern matching
@
text
@d4 3
d682 1
a682 1
	  | _ => Crash.impossible "Unify.do_unify_rec(1)"
@


1.7
log
@Modifications to sort out unification of flexible record types in order
to provide full information to the lambda translation
@
text
@d4 4
d166 6
d180 1
a180 1
	   (unify (h, h');
d185 8
d200 1
a200 1

d236 1
d238 1
a238 1
	 | (TYVAR (ref n, id), TYVAR (ref n', id')) =>
d257 1
a257 1
	     (unify (a, a') ; unify (r, r')))
d264 2
a265 2
	       fun unify' (ty, ty') = (unify (ty, ty') ; true)
	       val res = Mapping.compare (amap, amap', unify')
d271 1
a271 1
		  (* Note that unify' fails using an exception *)
d307 1
a307 1
	     unify (t, atype'))
d316 1
a316 1
	     unify (atype, t'))
d343 1
a343 1
	     unify (t, atype'))
d352 1
a352 1
	     unify (atype, t'))
d361 1
a361 1
	     unify (t, atype'))
d369 1
a369 1
	     unify (t, atype'))
d378 1
a378 1
	     unify (atype,t'))
d386 1
a386 1
	     unify (atype, t'))
d499 1
d504 3
a506 1
			
d512 2
a513 1
				andnot (eq,eq'), andnot (imp,imp')))
d583 1
a583 1
			 fun unify' (ty1, ty2) =
d585 1
a585 1
			      debug ["unify' ",Types.print_type ty1," and ",
d590 1
a590 1
				(unify (ty1, ty2) ; true)
d594 1
a594 1
			      (unify (ty1, ty2) ; true))
d597 1
a597 1
					    unify') of
d656 2
a657 2
		      fun unify' (x, y) =
			(unify (leftfun x, rightfun y) ; true)
d661 1
a661 1
			(amap, amap', leftfun, rightfun, unify', 
d699 1
a699 1
	   val res = (unify (x, y) ; OK) handle Failed (res) => res
@


1.6
log
@Fixed bug in unification of flexible record types.
@
text
@d4 3
d31 1
d335 1
a335 1
	| (METARECTYPE (r as ref (_, true, _, eq, imp)), _) =>
d338 2
a339 1
	       ["unifying METARECTYPE (flex) and ", Types.print_type atype']
d342 1
a342 1
	     do_unify_rec (r, atype'))
d352 1
a352 1
	| (_, METARECTYPE (r' as ref (_, true, _, eq', imp'))) =>
d355 2
a356 1
	       ["unifying ",Types.print_type atype," and METARECTYPE (flex)"]
d359 1
a359 1
	     do_unify_rec (r', atype))
d369 16
d600 2
a601 2
	      if (r = r') then
		()
d644 3
d648 1
a648 2
			     Types.propagate_level level'' (RECTYPE new_map),
			     eq, imp);
d655 1
a655 1
		  
@


1.5
log
@Added lists parameter
@
text
@d4 3
d179 37
a215 1
	  (TYVAR (ref n, id), TYVAR (ref n', id')) =>
a362 36
	| (CONSTYPE (l, METATYNAME{1=ref(tf as ETA_TYFUN _), ...}), _) =>
	    (if do_debug then
	       debug
	       ["unifying CONSTYPE (_,METATYNAME ETA_TYFUN) and ",
		Types.print_type atype']
	     else ();

	     unify (Types.apply (tf, l), atype'))

	| (CONSTYPE (l, METATYNAME{1=ref(tf as TYFUN _), ...}), _) =>
	    (if do_debug then
	       debug
	       ["unifying CONSTYPE (_,METATYNAME TYFUN) and ",
		Types.print_type atype']
	     else ();
	     
	     unify (Types.apply (tf, l), atype'))

	| (_, CONSTYPE (l', METATYNAME{1=ref(tf' as ETA_TYFUN _), ...})) =>
	    (if do_debug then
	       debug
	       ["unifying CONSTYPE (_,METATYNAME ETA_TYFUN) and ",
		Types.print_type atype]
	     else ();
	     
	     unify (atype, Types.apply (tf', l')))

	| (_, CONSTYPE (l', METATYNAME{1=ref(tf' as TYFUN _), ...})) =>
	    (if do_debug then
	       debug
	       ["unifying CONSTYPE (_,METATYNAME TYFUN) and ",
		Types.print_type atype]
	     else ();
	     
	     unify (atype, Types.apply (tf', l')))
	     
d521 1
a521 1
      and do_unify_rec (r as ref (level, _, RECTYPE amap, eq, imp), t') =
d523 2
a524 1
	   debug ["do_unify_rec flex METARECTYPE and ", Types.print_type t',
@


1.4
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d21 1
d31 1
d58 5
a62 10
    local
      fun print_list [] = Print.print "\n"
	| print_list (h :: t) = (Print.print h ; print_list t)
    in
      fun debug L =
	if do_debug andalso Debug.debug_level() > 10 then
	  (print_list L)
	else
	  ()
    end
d221 5
a225 3
	    (debug
	     ["unifying uninstantiated METATYVAR ", Integer.makestring n,
	      "and ", Types.print_type atype'];
d230 5
a234 3
	    (debug
	     ["unifying ",Types.print_type atype, 
	      " and uninstantiated METATYVAR ", Integer.makestring n'];
d239 5
a243 3
	    (debug
	     ["unifying instantiated METATYVAR ", Integer.makestring n,
	      "and ", Types.print_type atype'];
d248 5
a252 3
	    (debug
	     ["unifying ",Types.print_type atype, 
	      " and instantiated METATYVAR ", Integer.makestring n'];
d257 5
a261 3
	    (debug
	     ["unifying uninstantiated META_OVERLOADED and ",
	      Types.print_type atype'];
d266 5
a270 3
	    (debug
	     ["unifying ", Types.print_type atype,
	      " and uninstantiated META_OVERLOADED"];
d275 5
a279 3
	    (debug
	     ["unifying instantiated META_OVERLOADED and ",
	      Types.print_type atype'];
d284 5
a288 3
	    (debug
	     ["unifying ",Types.print_type atype,
	      " and instantiated META_OVERLOADED"];
d293 4
a296 2
	    (debug
	     ["unifying METARECTYPE (flex) and ", Types.print_type atype'];
d301 4
a304 2
	    (debug
	     ["unifying METARECTYPE and ", Types.print_type atype'];
d309 4
a312 2
	    (debug
	     ["unifying ",Types.print_type atype," and METARECTYPE (flex)"];
d317 4
a320 2
	    (debug
	     ["unifying ",Types.print_type atype, " and METARECTYPE"];
d325 5
a329 3
	    (debug
	     ["unifying CONSTYPE (_,METATYNAME ETA_TYFUN) and ",
	      Types.print_type atype'];
d334 5
a338 3
	    (debug
	     ["unifying CONSTYPE (_,METATYNAME TYFUN) and ",
	      Types.print_type atype'];
d343 5
a347 3
	    (debug
	     ["unifying CONSTYPE (_,METATYNAME ETA_TYFUN) and ",
	      Types.print_type atype];
d352 5
a356 3
	    (debug
	     ["unifying CONSTYPE (_,METATYNAME TYFUN) and ",
	      Types.print_type atype];
d361 6
a366 4
	    (debug
	     ["unifying CONSTYPE and CONSTYPE \n",
	      "n = ", Types.print_name n,
	      " n' = ", Types.print_name n'];
d383 5
a387 3
	     (debug
	      ["do_unify two uninstantiated metatyvars ",
	       Integer.makestring n, " and ", Integer.makestring n'];
d405 5
a409 3
	     (debug
	      ["do_unify uninstantiated and instantiated metas ",
	       Integer.makestring n, " and ", Integer.makestring n'];
d417 4
a420 2
	     (debug 
	      ["do_unify uninstantiated meta and CONSTYPE ... ETA_TYFUN"];
d444 5
a448 3
	     (debug ["do_unify uninstantiated meta and flex METARECTYPE\n",
		     "level of METATYVAR = ", Integer.makestring n,
		     "level of flex METARECTYPE = ", Integer.makestring n'];
d473 4
a476 2
	     (debug ["do_unify uninstantiated meta and ",
		     (Types.print_type ty)];
d519 4
a522 2
	(debug ["do_unify_rec flex METARECTYPE and ", Types.print_type t',
		"level of flex METARECTYPE = ", Integer.makestring level];
d535 4
a538 2
			   (debug ["unify' ",Types.print_type ty1," and ",
				   Types.print_type ty2];
d550 3
a552 1
			     (debug ["BIGGER ", Types.print_type t'];
d641 4
a644 2
	(debug
	 ["\nUNIFY \n", Types.print_type x, "\n AND \n", Types.print_type y];
@


1.3
log
@Updated to allow valenv in METATYNAME
@
text
@d4 3
d15 5
d21 1
a23 4
require "../basics/ident";
require "../utils/print";
require "../utils/integer";
require  "../utils/crash";
d25 8
a32 2
functor Unify
  (structure Datatypes : DATATYPES
d34 2
a35 2
   structure Ident : IDENT
   sharing Ident = Datatypes.Ident
d37 5
a41 2
   structure Types : TYPES
   sharing Types.Datatypes = Datatypes
d43 1
a43 10
   structure Debug :
     sig
       val set_debug_level : int -> unit
       val debug_level     : unit -> int
     end

   structure Print   : PRINT
   structure Integer : INTEGER
   structure Crash   : CRASH
     ) : UNIFY =
d47 1
d57 1
a57 1
	if Debug.debug_level() > 10 then
d594 1
a594 1
	   val debug = Debug.debug_level() > 10
@


1.2
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_unify.sml,v $
d293 1
a293 1
	| (CONSTYPE (l, METATYNAME (ref (tf as ETA_TYFUN _), _, _, _)), _) =>
d300 1
a300 1
	| (CONSTYPE (l, METATYNAME (ref (tf as TYFUN _), _, _, _)), _) =>
d307 1
a307 1
	| (_, CONSTYPE (l', METATYNAME (ref (tf' as ETA_TYFUN _), _, _, _))) =>
d314 1
a314 1
	| (_, CONSTYPE (l', METATYNAME (ref (tf' as TYFUN _), _, _, _))) =>
d371 1
a371 1
	 | CONSTYPE (l, METATYNAME (ref (tyfun as ETA_TYFUN _), _, _, _)) =>
d377 1
a377 1
	 | CONSTYPE (l, METATYNAME (ref (tyfun as TYFUN _), _, _, _)) =>
@


1.1
log
@Initial revision
@
text
@d1 1
d3 5
a7 1
$Log$
@
