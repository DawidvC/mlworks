head	1.14;
access;
symbols
	MLW_daveb_inline_1_4_99:1.14.1
	MLWorks_21c0_1999_03_25:1.14
	MLWorks_20c1_1998_08_20:1.13
	MLWorks_20c0_1998_08_04:1.13
	MLWorks_20b2c2_1998_06_19:1.13
	MLWorks_20b2_Windows_1998_06_12:1.13
	MLWorks_20b1c1_1998_05_07:1.13
	MLWorks_20b0_1998_04_07:1.13
	MLWorks_20b0_1998_03_20:1.13
	MLWorks_20m2_1998_02_16:1.13
	MLWorks_20m1_1997_10_23:1.13
	MLWorks_11r1:1.13.5.1.1.1.1
	MLWorks_workspace_97:1.13.7
	MLWorks_dt_wizard:1.13.6
	MLWorks_11c0_1997_09_09:1.13.5.1.1.1
	MLWorks_10r3:1.13.5.1.3
	MLWorks_10r2_551:1.13.5.1.2
	MLWorks_11:1.13.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.13.5.1
	MLWorks_20m0_1997_06_20:1.13
	MLWorks_1_0_r2c2_1997_06_14:1.13.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.13.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.13.5
	MLWorks_BugFix_1997_04_24:1.13
	MLWorks_1_0_r2_Win32_1997_04_11:1.13
	MLWorks_1_0_r2_Unix_1997_04_04:1.13
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.13.3.1.1
	MLWorks_gui_1996_12_18:1.13.4
	MLWorks_1_0_Win32_1996_12_17:1.13.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.13.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.13.1.1
	MLWorks_1_0_Irix_1996_11_28:1.13.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.13.2
	MLWorks_1_0_Unix_1996_11_14:1.13.1
	MLWorks_Open_Beta2_1996_10_11:1.11.1
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.10
	MLWorks_Beta_1996_06_07:1.10
	MLWorks_Beta_1996_06_06:1.10
	MLWorks_Beta_1996_06_05:1.10
	MLWorks_Beta_1996_06_03:1.10
	MLWorks_Beta_1996_05_31:1.10
	MLWorks_Beta_1996_05_30:1.10
	ML_beta_release_12/08/94:1.5
	ML_beta_release_03/08/94:1.5
	ML_revised_beta_release_25/05/94:1.5
	ML_final_beta_release_02/03/94:1.5
	mlworks-28-01-1994:1.5
	Release:1.2
	mlworks-beta-01-09-1993:1.2;
locks; strict;
comment	@ * @;


1.14
date	99.02.02.16.01.45;	author mitchell;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	96.11.06.11.32.58;	author matthew;	state Exp;
branches
	1.13.1.1
	1.13.2.1
	1.13.3.1
	1.13.4.1
	1.13.5.1
	1.13.6.1
	1.13.7.1;
next	1.12;

1.12
date	96.10.29.12.13.12;	author io;	state Exp;
branches;
next	1.11;

1.11
date	96.09.25.17.31.17;	author andreww;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	96.04.30.15.49.41;	author jont;	state Exp;
branches
	1.10.1.1
	1.10.2.1;
next	1.9;

1.9
date	96.04.29.14.02.36;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.09.05.14.10.17;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	95.08.31.13.38.32;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	95.05.11.13.39.42;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.11.25.10.34.12;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.10.04.16.54.29;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	93.08.12.11.41.13;	author nosa;	state Exp;
branches;
next	1.2;

1.2
date	93.08.11.15.16.51;	author jont;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	93.08.10.10.44.31;	author jont;	state Exp;
branches;
next	;

1.2.1.1
date	93.08.11.15.16.51;	author jont;	state Exp;
branches;
next	1.2.1.2;

1.2.1.2
date	93.10.04.16.31.42;	author daveb;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.41.42;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.34.47;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	96.10.17.11.53.54;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	96.11.14.13.21.35;	author hope;	state Exp;
branches
	1.13.1.1.1.1;
next	;

1.13.1.1.1.1
date	96.11.28.15.32.34;	author hope;	state Exp;
branches;
next	;

1.13.2.1
date	96.11.22.18.39.14;	author hope;	state Exp;
branches;
next	;

1.13.3.1
date	96.12.17.18.18.15;	author hope;	state Exp;
branches
	1.13.3.1.1.1;
next	;

1.13.3.1.1.1
date	97.02.24.12.12.30;	author hope;	state Exp;
branches;
next	;

1.13.4.1
date	96.12.18.10.13.33;	author hope;	state Exp;
branches;
next	;

1.13.5.1
date	97.05.12.10.51.49;	author hope;	state Exp;
branches
	1.13.5.1.1.1
	1.13.5.1.2.1
	1.13.5.1.3.1;
next	;

1.13.5.1.1.1
date	97.07.28.18.33.38;	author daveb;	state Exp;
branches
	1.13.5.1.1.1.1.1;
next	;

1.13.5.1.1.1.1.1
date	97.10.07.11.59.37;	author jkbrook;	state Exp;
branches;
next	;

1.13.5.1.2.1
date	97.09.08.17.26.44;	author daveb;	state Exp;
branches;
next	;

1.13.5.1.3.1
date	97.09.09.14.23.35;	author daveb;	state Exp;
branches;
next	;

1.13.6.1
date	97.09.10.19.42.32;	author brucem;	state Exp;
branches;
next	;

1.13.7.1
date	97.09.11.21.10.02;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	99.04.01.18.08.40;	author daveb;	state Exp;
branches;
next	;


desc
@@


1.14
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _context_print.sml the functor *)
(*
$Log: _context_print.sml,v $
 * Revision 1.13  1996/11/06  11:32:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.12  1996/10/29  12:13:12  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.11  1996/09/25  17:31:17  andreww
 * [Bug #1592]
 * threading locations into Absyn.LOCALexp
 *
 * Revision 1.10  1996/04/30  15:49:41  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.9  1996/04/29  14:02:36  matthew
 * Removing MLWorks.Integer.
 *
 * Revision 1.8  1995/09/05  14:10:17  daveb
 * Added new types for different sizes of ints, words and reals.
 *
Revision 1.7  1995/08/31  13:38:32  jont
Add location info to wild pats

Revision 1.6  1995/05/11  13:39:42  matthew
Improving function printing

Revision 1.5  1993/11/25  10:34:12  matthew
General improvements
Print infix expressions & pats.
Print tuple expressions as tuples

Revision 1.4  1993/10/04  16:54:29  daveb
Merged in bug fix.

Revision 1.3  1993/08/12  11:41:13  nosa
Runtime-instance in VALpats and LAYEREDpats and Compilation-instance
in VALexps for polymorphic debugger.

Revision 1.2.1.2  1993/10/04  16:31:42  daveb
Now prints if, while, andalso and orelse as the underived forms.

Revision 1.2.1.1  1993/08/11  15:16:51  jont
Fork for bug fixing

Revision 1.2  1993/08/11  15:16:51  jont
Ensured all pattern types printable

Revision 1.1  1993/08/10  10:44:31  jont
Initial revision

Copyright (c) 1993 Harlequin Ltd.
*)

require "^.basis.__int";
require "^.basis.__string";
require "^.basics.absyn";
require "^.basics.identprint";
require "context_print";

functor Context_Print(
  structure Absyn : ABSYN
  structure IdentPrint : IDENTPRINT
  sharing Absyn.Ident = IdentPrint.Ident
    ) : CONTEXT_PRINT =
  struct
    structure Absyn = Absyn
    structure Ident = Absyn.Ident
    structure Symbol = Ident.Symbol
    structure Options = IdentPrint.Options

    fun get_data (Absyn.FNexp(_,_,data,_)) = data
    |   get_data _ = ""

    val is_if_exp = String.isPrefix "<if>"
    val is_case_exp = String.isPrefix "<case>"
    val is_andalso_exp = String.isPrefix "<andalso>"
    val is_orelse_exp = String.isPrefix "<orelse>"
    val is_while_exp = String.isPrefix "While statement"

    fun is_tuple [] = true
      | is_tuple [_] = false
      | is_tuple l =
        let 
          fun aux ([],n) = true
            | aux ((Ident.LAB s,_)::l,n) =
            (Int.toString n = Symbol.symbol_name s)
            andalso
            aux (l,n+1)
        in
          aux (l,1)
        end

    fun pat_needs_brackets (Absyn.WILDpat _) = false
      | pat_needs_brackets (Absyn.SCONpat _) = false
      | pat_needs_brackets (Absyn.VALpat _) = false
      | pat_needs_brackets (Absyn.RECORDpat _) = false
      | pat_needs_brackets _ = true

    fun lab_list_to_string [] = ["}"]
      | lab_list_to_string [(x, _)] = [IdentPrint.printLab x, "=...}"]
      | lab_list_to_string((x, _) :: xs) =
	IdentPrint.printLab x :: "=..., " :: lab_list_to_string xs

    fun simple_tuple_to_string [] = [")"]
      | simple_tuple_to_string [(x, _)] = ["...)"]
      | simple_tuple_to_string((x, _) :: xs) =
	"..., " :: simple_tuple_to_string xs

    fun simple_pat_to_string options (Absyn.WILDpat _) = "_"
      | simple_pat_to_string options (Absyn.SCONpat (scon, _)) =
        IdentPrint.printSCon scon
      | simple_pat_to_string options (Absyn.VALpat((lvalid, _), _)) =
	IdentPrint.printLongValId options lvalid
      | simple_pat_to_string options (Absyn.RECORDpat(list, _, _)) =
        if is_tuple list
          then
            concat ("(" :: simple_tuple_to_string list)
        else
          (case list of
             [] => "()"
           | _ => concat ("{" :: lab_list_to_string list))
      | simple_pat_to_string options (Absyn.APPpat((lvalid, ref ty), pat,_,is_infix)) =
        if is_infix
          then
            (case pat of
               Absyn.RECORDpat ([(_,p1),(_,p2)],_,_) =>
                 "... " ^ IdentPrint.printLongValId options lvalid ^ " ..."
             | _ => "<Strange infix pattern>")
        else
          IdentPrint.printLongValId options lvalid ^ " ..."
      | simple_pat_to_string options (Absyn.TYPEDpat(pat, _, _)) =
	"_ : type"
      | simple_pat_to_string options (Absyn.LAYEREDpat((valid, _), _)) =
	IdentPrint.printValId options valid ^ " as ..."

    fun lab_pat_list_to_string options [] = ["}"]
      | lab_pat_list_to_string options [(x, pat)] =
	[IdentPrint.printLab x, "=", simple_pat_to_string options pat, "}"]
      | lab_pat_list_to_string options ((x, pat) :: rest) =
	IdentPrint.printLab x :: "=" :: simple_pat_to_string options pat :: ", " ::
	lab_pat_list_to_string options rest

    fun tuple_pat_to_string options [] = [")"]
      | tuple_pat_to_string options [(x, pat)] =
	[simple_pat_to_string options pat, ")"]
      | tuple_pat_to_string options ((x, pat) :: rest) =
	simple_pat_to_string options pat :: ", " ::
	tuple_pat_to_string options rest

    fun pat_to_string options (Absyn.WILDpat _) = "_"
      | pat_to_string options (Absyn.SCONpat (scon, _)) =
	IdentPrint.printSCon scon
      | pat_to_string options (Absyn.VALpat((lvalid, _), _)) =
	IdentPrint.printLongValId options lvalid
      | pat_to_string options (Absyn.RECORDpat(list, _, _)) =
        if is_tuple list
          then
            concat ("(" :: tuple_pat_to_string options list)
        else
          (case list of
             [] => "()"
           | _ => concat ("{" :: lab_pat_list_to_string options list))
      | pat_to_string options (Absyn.APPpat((lvalid, ref ty), pat,_,is_infix)) =
        if is_infix
          then
            (case pat of
               Absyn.RECORDpat ([(_,p1),(_,p2)],_,_) =>
                 simple_pat_to_string options p1 ^ " " ^
                 IdentPrint.printLongValId options lvalid ^ " " ^
                 simple_pat_to_string options p2
             | _ => "<Strange infix pattern>")
        else
          IdentPrint.printLongValId options lvalid ^ 
          (if pat_needs_brackets pat
             then "(" ^ pat_to_string options pat ^ ")"
           else " " ^ pat_to_string options pat)
      | pat_to_string options (Absyn.TYPEDpat(pat, _, _)) =
	simple_pat_to_string options pat ^ " : type"
      | pat_to_string options  (Absyn.LAYEREDpat((valid, _), pat)) =
	IdentPrint.printValId options valid ^ " as " ^ simple_pat_to_string options pat

    fun needs_brackets (Absyn.SCONexp _) = false
      | needs_brackets (Absyn.VALexp _) = false
      | needs_brackets (Absyn.RECORDexp _) = false
      | needs_brackets _ = true;

    fun exp_to_string options (Absyn.SCONexp (scon, _)) = 
	IdentPrint.printSCon scon
      | exp_to_string options (Absyn.VALexp(lvalid, _, _,_)) =
	IdentPrint.printLongValId options lvalid
      | exp_to_string options (Absyn.RECORDexp list) =
        if is_tuple list
          then
            concat ("(" :: tuple_to_string options list)
        else
          (case list of
             [] => "()"
           | _ => concat ("{" :: lab_exp_list_to_string options list))
      | exp_to_string options (Absyn.LOCALexp(_, _,_)) = "let ... in ... end"
        (* This should use the infix field to control printing *)
      | exp_to_string options (Absyn.APPexp(e1, e2, _, _,is_infix)) =
        if is_infix then
          (case (e1,e2) of
             (Absyn.VALexp (lvalid,_,_,_),Absyn.RECORDexp [(_,a1),(_,a2)]) =>
               exp_to_string options a1 ^ " " ^ IdentPrint.printLongValId options lvalid ^ " " ^ exp_to_string options a2
           | _ => "<Strange infix expression>")
        else if is_if_exp (get_data e1) then
	  "if " ^ exp_to_string options e2 ^ " then ... else ..."
	else if is_case_exp (get_data e1) then
	  "case " ^ exp_to_string options e2 ^ " of ..."
	else if is_andalso_exp (get_data e1) then
	  exp_to_string options e2 ^ " andalso ..."
	else if is_orelse_exp (get_data e1) then
	  exp_to_string options e2 ^ " orelse ..."
	else
	  exp_to_string options e1 ^ 
          (if needs_brackets e2 
             then "(" ^ exp_to_string options e2 ^ ")" 
           else " " ^ exp_to_string options e2)
      | exp_to_string options (Absyn.TYPEDexp(e, _, _)) = exp_to_string options e ^ " : type"
      | exp_to_string options (Absyn.HANDLEexp(e, _, _, _, _)) =
	"(" ^ exp_to_string options e ^ ") handle ..." 
      | exp_to_string options (Absyn.RAISEexp _) = "raise ..."
      | exp_to_string options (Absyn.FNexp (pel,_,_,_)) = 
        (case pel of
           (p,e,l) :: _ => "fn " ^ pat_to_string options p ^ " => ..."
         | _ => "fn ... => ...")
      | exp_to_string options (Absyn.DYNAMICexp _) = "dynamic"
      | exp_to_string options (Absyn.COERCEexp _) = "coerce"
      | exp_to_string options (Absyn.MLVALUEexp _) = "(hidden)"

    and lab_exp_list_to_string options [] = ["}"]
      | lab_exp_list_to_string options [(x, y)] =
	IdentPrint.printLab x :: ["=", exp_to_string options y, "}"]
      | lab_exp_list_to_string options ((x, y) :: xs) =
	IdentPrint.printLab x :: "=" :: exp_to_string options y :: ", " ::
	lab_exp_list_to_string options xs

    and tuple_to_string options [] = [")"]
      | tuple_to_string options [(x, y)] =
	[exp_to_string options y, ")"]
      | tuple_to_string options ((x, y) :: xs) =
	exp_to_string options y :: ", " :: tuple_to_string options xs

    fun dec_to_string options (pat, exp) =
      "val " ^ simple_pat_to_string options pat ^ " = " ^ exp_to_string options exp

  end
@


1.14.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.14  1999/02/02  16:01:45  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.13
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
a62 1
require "^.main.options";
@


1.13.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.13  1996/11/06  11:32:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.13  1996/11/06  11:32:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.5.1
log
@branched from 1.13
@
text
@a3 4
 * Revision 1.13  1996/11/06  11:32:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.13.5.1  1997/05/12  10:51:49  hope
 * branched from 1.13
 *
@


1.13.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.13.5.1  1997/05/12  10:51:49  hope
 * branched from 1.13
 *
@


1.13.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.13.5.1  1997/05/12  10:51:49  hope
 * branched from 1.13
 *
@


1.13.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.13.5.1.1.1  1997/07/28  18:33:38  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.13.4.1
log
@branched from 1.13
@
text
@a3 4
 * Revision 1.13  1996/11/06  11:32:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.3.1
log
@branched from 1.13
@
text
@a3 4
 * Revision 1.13  1996/11/06  11:32:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.3.1.1.1
log
@branched from 1.13.3.1
@
text
@a3 3
 * Revision 1.13.3.1  1996/12/17  18:18:15  hope
 * branched from 1.13
 *
@


1.13.2.1
log
@branched from 1.13
@
text
@a3 4
 * Revision 1.13  1996/11/06  11:32:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.1.1
log
@branched from 1.13
@
text
@a3 4
 * Revision 1.13  1996/11/06  11:32:58  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.13.1.1.1.1
log
@branched from 1.13.1.1
@
text
@a3 3
 * Revision 1.13.1.1  1996/11/14  13:21:35  hope
 * branched from 1.13
 *
@


1.12
log
@[Bug #1614]
basifying String
@
text
@d4 4
d57 1
a57 1
require "^.basis.__integer";
@


1.11
log
@[Bug #1592]
threading locations into Absyn.LOCALexp
@
text
@d4 4
d53 5
a57 6
require "../basis/__integer";

require "../utils/lists";
require "../main/options";
require "../basics/absyn";
require "../basics/identprint";
a60 1
  structure Lists   : LISTS
d74 5
a78 15
    local
      fun test_data string =
        let val string_size = size string
        in
          fn data =>
            size data >= string_size andalso
            string = String.substring (data,0,string_size)
        end
    in
      val is_if_exp = test_data "<if>"
      val is_case_exp = test_data "<case>"
      val is_andalso_exp = test_data "<andalso>"
      val is_orelse_exp = test_data "<orelse>"
      val is_while_exp = test_data "While statement"
    end
d117 1
a117 1
            String.implode ("(" :: simple_tuple_to_string list)
d121 1
a121 1
           | _ => String.implode("{" :: lab_list_to_string list))
d158 1
a158 1
            String.implode ("(" :: tuple_pat_to_string options list)
d162 1
a162 1
           | _ => String.implode("{" :: lab_pat_list_to_string options list))
d194 1
a194 1
            String.implode ("(" :: tuple_to_string options list)
d198 1
a198 1
           | _ => String.implode("{" :: lab_exp_list_to_string options list))
@


1.11.1.1
log
@branched from 1.11
@
text
@a3 4
 * Revision 1.11  1996/09/25  17:31:17  andreww
 * [Bug #1592]
 * threading locations into Absyn.LOCALexp
 *
@


1.10
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d207 1
a207 1
      | exp_to_string options (Absyn.LOCALexp(_, _)) = "let ... in ... end"
@


1.10.2.1
log
@branched from 1.10
@
text
@a3 6
 * Revision 1.10  1996/04/30  15:49:41  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a3 6
 * Revision 1.10  1996/04/30  15:49:41  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.9
log
@Removing MLWorks.Integer.
@
text
@d4 3
d119 1
a119 1
            implode ("(" :: simple_tuple_to_string list)
d123 1
a123 1
           | _ => implode("{" :: lab_list_to_string list))
d160 1
a160 1
            implode ("(" :: tuple_pat_to_string options list)
d164 1
a164 1
           | _ => implode("{" :: lab_pat_list_to_string options list))
d196 1
a196 1
            implode ("(" :: tuple_to_string options list)
d200 1
a200 1
           | _ => implode("{" :: lab_exp_list_to_string options list))
@


1.8
log
@Added new types for different sizes of ints, words and reals.
@
text
@d4 3
d40 2
d85 1
a85 1
            (MLWorks.Integer.makestring n = Symbol.symbol_name s)
@


1.7
log
@Add location info to wild pats
@
text
@d4 3
d104 2
a105 1
      | simple_pat_to_string options (Absyn.SCONpat scon) = IdentPrint.printSCon scon
d145 2
a146 1
      | pat_to_string options (Absyn.SCONpat scon) = IdentPrint.printSCon scon
d181 2
a182 1
    fun exp_to_string options (Absyn.SCONexp scon) = IdentPrint.printSCon scon
@


1.6
log
@Improving function printing
@
text
@d4 3
d84 1
a84 1
    fun pat_needs_brackets Absyn.WILDpat = false
d100 1
a100 1
    fun simple_pat_to_string options Absyn.WILDpat = "_"
d140 1
a140 1
    fun pat_to_string options Absyn.WILDpat = "_"
@


1.5
log
@General improvements
Print infix expressions & pats.
Print tuple expressions as tuples
@
text
@d4 5
d209 4
a212 1
      | exp_to_string options (Absyn.FNexp _) = "fn match => ..."
@


1.4
log
@Merged in bug fix.
@
text
@d4 3
a35 1

d40 2
d63 19
d87 5
d97 16
a112 5
	(case list of
	   [] => "()"
	 | _ => implode("{" :: lab_list_to_string list))
      | simple_pat_to_string options (Absyn.APPpat((lvalid, ref ty), pat, _)) =
	IdentPrint.printLongValId options lvalid ^ "(...)"
d125 7
d137 21
a157 5
	(case list of
	   [] => "()"
	 | _ => implode("{" :: lab_pat_list_to_string options list))
      | pat_to_string options (Absyn.APPpat((lvalid, ref ty), pat, _)) =
	IdentPrint.printLongValId options lvalid ^ "(" ^ simple_pat_to_string options pat ^ ")"
d163 5
d172 7
a178 3
	(case list of
	   [] => "()"
	 | _ => implode("{" :: lab_exp_list_to_string options list))
d180 8
a187 2
      | exp_to_string options (Absyn.APPexp(e1, e2, _, _)) =
	if is_if_exp (get_data e1) then
d196 4
a199 1
	  exp_to_string options e1 ^ "(" ^ exp_to_string options e2 ^ ")"
d207 1
a207 2
      | exp_to_string options (Absyn.MLVALUEexp _) =
	"(hidden)"
d215 6
@


1.3
log
@Runtime-instance in VALpats and LAYEREDpats and Compilation-instance
in VALexps for polymorphic debugger.
@
text
@d4 10
d40 19
d110 10
a119 1
	exp_to_string options e1 ^ "(" ^ exp_to_string options e2 ^ ")"
@


1.2
log
@Ensured all pattern types printable
@
text
@d4 3
d73 1
a73 1
      | exp_to_string options (Absyn.VALexp(lvalid, _, _)) =
@


1.2.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.2  1993/08/11  15:16:51  jont
Ensured all pattern types printable

@


1.2.1.2
log
@Now prints if, while, andalso and orelse as the underived forms.
@
text
@a3 3
Revision 1.2.1.1  1993/08/11  15:16:51  jont
Fork for bug fixing

a29 19
    fun get_data (Absyn.FNexp(_,_,data,_)) = data
    |   get_data _ = ""

    local
      fun test_data string =
        let val string_size = size string
        in
          fn data =>
            size data >= string_size andalso
            string = String.substring (data,0,string_size)
        end
    in
      val is_if_exp = test_data "<if>"
      val is_case_exp = test_data "<case>"
      val is_andalso_exp = test_data "<andalso>"
      val is_orelse_exp = test_data "<orelse>"
      val is_while_exp = test_data "While statement"
    end

d81 1
a81 10
	if is_if_exp (get_data e1) then
	  "if " ^ exp_to_string options e2 ^ " then ... else ..."
	else if is_case_exp (get_data e1) then
	  "case " ^ exp_to_string options e2 ^ " of ..."
	else if is_andalso_exp (get_data e1) then
	  exp_to_string options e2 ^ " andalso ..."
	else if is_orelse_exp (get_data e1) then
	  exp_to_string options e2 ^ " orelse ..."
	else
	  exp_to_string options e1 ^ "(" ^ exp_to_string options e2 ^ ")"
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
a10 1
require "../utils/crash";
a17 1
  structure Crash   : CRASH
d28 1
a28 1
      | lab_list_to_string [(x, _)] = IdentPrint.printLab x :: ["=...}"]
d47 15
a61 4
    fun pat_to_string options Absyn.WILDpat = Crash.impossible"pat_to_string(WILD)"
      | pat_to_string options (Absyn.SCONpat _) = Crash.impossible"pat_to_string(SCON)"
      | pat_to_string options (Absyn.VALpat _) = Crash.impossible"pat_to_string(VAL)"
      | pat_to_string options (Absyn.RECORDpat _) = Crash.impossible"pat_to_string(RECORD)"
d66 2
a67 1
      | pat_to_string options (Absyn.LAYEREDpat _) = Crash.impossible"pat_to_string(LAYERED)"
@
