head	1.32;
access;
symbols
	MLW_daveb_inline_1_4_99:1.32.1
	MLWorks_21c0_1999_03_25:1.32
	MLWorks_20c1_1998_08_20:1.31
	MLWorks_20c0_1998_08_04:1.31
	MLWorks_20b2c2_1998_06_19:1.31
	MLWorks_20b2_Windows_1998_06_12:1.31
	MLWorks_20b1c1_1998_05_07:1.31
	MLWorks_20b0_1998_04_07:1.31
	MLWorks_20b0_1998_03_20:1.31
	MLWorks_20m2_1998_02_16:1.31
	MLWorks_20m1_1997_10_23:1.31
	MLWorks_11r1:1.30.6.1.1.1.1
	MLWorks_workspace_97:1.31.2
	MLWorks_dt_wizard:1.31.1
	MLWorks_11c0_1997_09_09:1.30.6.1.1.1
	MLWorks_10r3:1.30.6.1.3
	MLWorks_10r2_551:1.30.6.1.2
	MLWorks_11:1.30.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.30.6.1
	MLWorks_20m0_1997_06_20:1.31
	MLWorks_1_0_r2c2_1997_06_14:1.30.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.30.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.30.6
	MLWorks_BugFix_1997_04_24:1.30
	MLWorks_1_0_r2_Win32_1997_04_11:1.30
	MLWorks_1_0_r2_Unix_1997_04_04:1.30
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.30.4.1.1
	MLWorks_gui_1996_12_18:1.30.5
	MLWorks_1_0_Win32_1996_12_17:1.30.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.30.2.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.30.2.1
	MLWorks_1_0_Irix_1996_11_28:1.30.2.1.1
	MLWorks_1_0_Win32_1996_11_22:1.30.3
	MLWorks_1_0_Unix_1996_11_14:1.30.2
	MLWorks_Open_Beta2_1996_10_11:1.30.1
	MLWorks_License_dev:1.29.2
	MLWorks_1_open_beta_1996_09_13:1.29.1
	MLWorks_Open_Beta_1996_08_22:1.29
	MLWorks_Beta_1996_07_02:1.29
	MLWorks_Beta_1996_06_07:1.29
	MLWorks_Beta_1996_06_06:1.29
	MLWorks_Beta_1996_06_05:1.29
	MLWorks_Beta_1996_06_03:1.29
	MLWorks_Beta_1996_05_31:1.29
	MLWorks_Beta_1996_05_30:1.29
	ML_beta_release_12/08/94:1.24
	ML_beta_release_03/08/94:1.24
	ML_revised_beta_release_25/05/94:1.23
	ML_final_beta_release_02/03/94:1.21
	mlworks-28-01-1994:1.20
	Release:1.17
	mlworks-beta-01-09-1993:1.17
	MLWorks-1-0-4-29/01/1993:1.11
	MLWorks-1-0-3-21/12/1992:1.10
	MLWorks-1-0-2-15/12/1992:1.10
	MLWorks-1-0-1-04/12/1992:1.9
	checkpoint_17_08_92:1.7
	Ten15_release_19-11-91:1.2
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.32
date	99.02.02.16.01.51;	author mitchell;	state Exp;
branches
	1.32.1.1;
next	1.31;

1.31
date	97.05.01.12.55.14;	author jont;	state Exp;
branches
	1.31.1.1
	1.31.2.1;
next	1.30;

1.30
date	96.10.04.15.36.34;	author andreww;	state Exp;
branches
	1.30.1.1
	1.30.2.1
	1.30.3.1
	1.30.4.1
	1.30.5.1
	1.30.6.1;
next	1.29;

1.29
date	96.02.23.16.53.05;	author jont;	state Exp;
branches
	1.29.1.1
	1.29.2.1;
next	1.28;

1.28
date	96.02.21.17.15.32;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	95.12.27.11.23.28;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	95.03.24.16.13.23;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	95.01.17.13.18.13;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	94.06.17.10.44.09;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	94.05.12.11.07.20;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	94.05.05.13.08.21;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	94.02.28.05.52.47;	author nosa;	state Exp;
branches;
next	1.20;

1.20
date	93.11.30.11.04.43;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.11.25.09.34.19;	author nickh;	state Exp;
branches;
next	1.18;

1.18
date	93.09.22.12.46.50;	author nosa;	state Exp;
branches;
next	1.17;

1.17
date	93.07.09.11.45.20;	author nosa;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	93.07.07.16.41.59;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	93.04.06.12.02.56;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	93.03.09.12.52.49;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.02.08.16.02.33;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.02.05.15.07.33;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	92.12.22.15.16.49;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.12.08.14.50.04;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.10.09.14.12.06;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.10.02.15.53.49;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.08.11.10.52.14;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.07.30.14.32.56;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.01.24.14.42.11;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.01.14.16.22.05;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.21.16.51.08;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.17.27.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.43.01;	author colin;	state Exp;
branches;
next	;

1.17.1.1
date	93.07.09.11.45.20;	author jont;	state Exp;
branches;
next	;

1.29.1.1
date	96.09.13.11.41.03;	author hope;	state Exp;
branches;
next	;

1.29.2.1
date	96.10.07.16.34.05;	author hope;	state Exp;
branches;
next	;

1.30.1.1
date	96.10.17.11.53.13;	author hope;	state Exp;
branches;
next	;

1.30.2.1
date	96.11.14.13.20.49;	author hope;	state Exp;
branches
	1.30.2.1.1.1;
next	;

1.30.2.1.1.1
date	96.11.28.15.31.48;	author hope;	state Exp;
branches;
next	;

1.30.3.1
date	96.11.22.18.38.34;	author hope;	state Exp;
branches;
next	;

1.30.4.1
date	96.12.17.18.17.35;	author hope;	state Exp;
branches
	1.30.4.1.1.1;
next	;

1.30.4.1.1.1
date	97.02.24.12.11.50;	author hope;	state Exp;
branches;
next	;

1.30.5.1
date	96.12.18.10.12.50;	author hope;	state Exp;
branches;
next	;

1.30.6.1
date	97.05.12.10.51.09;	author hope;	state Exp;
branches
	1.30.6.1.1.1
	1.30.6.1.2.1
	1.30.6.1.3.1;
next	;

1.30.6.1.1.1
date	97.07.28.18.34.28;	author daveb;	state Exp;
branches
	1.30.6.1.1.1.1.1;
next	;

1.30.6.1.1.1.1.1
date	97.10.07.12.00.22;	author jkbrook;	state Exp;
branches;
next	;

1.30.6.1.2.1
date	97.09.08.17.27.25;	author daveb;	state Exp;
branches;
next	;

1.30.6.1.3.1
date	97.09.09.14.24.23;	author daveb;	state Exp;
branches;
next	;

1.31.1.1
date	97.09.10.19.43.18;	author brucem;	state Exp;
branches;
next	;

1.31.2.1
date	97.09.11.21.10.46;	author daveb;	state Exp;
branches;
next	;

1.32.1.1
date	99.04.01.18.09.04;	author daveb;	state Exp;
branches;
next	;


desc
@Datatypes for several core static semantic objects
> (see also simpletypes and basis)

@


1.32
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* datatypes.sml the signature *)
(*
$Log: datatypes.sml,v $
 * Revision 1.31  1997/05/01  12:55:14  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.30  1996/10/04  15:36:34  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
 * Revision 1.29  1996/02/23  16:53:05  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.28  1996/02/21  17:15:32  jont
 * Removing map in favour of newmap
 *
 * Revision 1.27  1995/12/27  11:23:28  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.26  1995/03/24  16:13:23  matthew
Adding tyname map to COPYSTR's

Revision 1.25  1995/01/17  13:18:13  matthew
Rationalizing debugger

Revision 1.24  1994/06/17  10:44:09  jont
Allow alternative printing of types to include quantifiers

Revision 1.23  1994/05/12  11:07:20  daveb
Revised previous log message.

Revision 1.22  1994/05/05  13:08:21  daveb
META_OVERLOADED now includes the overloaded type variable and the location.
Overloaded schemes include the type variable.

Revision 1.21  1994/02/28  05:52:47  nosa
Debugger structures and extra TYNAME valenv for Modules Debugger.

Revision 1.20  1993/11/30  11:04:43  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.19  1993/11/25  09:34:19  nickh
Added code to encode type errors as a list of strings and types.

Revision 1.18  1993/09/22  12:46:50  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.17  1993/07/09  11:45:20  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.

Revision 1.16  1993/07/07  16:41:59  daveb
Removed exception environments and interfaces.

Revision 1.15  1993/04/06  12:02:56  jont
Added push and pop functions for the id counters

Revision 1.14  1993/03/09  12:52:49  matthew
Str to Structure

Revision 1.13  1993/02/08  16:02:33  matthew
not much changed here

Revision 1.12  1993/02/05  15:07:33  matthew
New representation of structures
Removed TypeLocation type

Revision 1.11  1992/12/22  15:16:49  jont
Anel's last changes

Revision 1.10  1992/12/08  14:50:04  jont
Removed a number of duplicated signatures and structures

Revision 1.9  1992/10/09  14:12:06  clive
Tynames now have a slot recording their definition point

Revision 1.8  1992/10/02  15:53:49  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.7  1992/08/11  10:52:14  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.6  1992/07/30  14:32:56  jont
Anel's changes to use NewMap instead of Map

Revision 1.5  1992/01/24  14:42:11  jont
Updated to allow valenv in METATYNAME

Revision 1.4  1992/01/14  16:22:05  jont
Changed ref unit in valenv to ref int to assist encoder

Revision 1.3  1991/11/21  16:51:08  jont
Added copyright message

Revision 1.2  91/06/17  17:27:00  nickh
Gives new ValEnv definition with ref unit to allow reading and
writing circular data structures.

Revision 1.1  91/06/07  11:43:01  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)
require "../utils/map";
require "../basics/ident";

signature DATATYPES =
  sig
    structure NewMap  : MAP
    structure Ident   : IDENT

    eqtype Stamp
    type 'a StampMap

    (****
     For detailed comments see the functor Datatypes.
     ****)

    datatype OverLoaded =
      UNARY of Ident.ValId * Ident.TyVar | 
      BINARY of Ident.ValId * Ident.TyVar |
      PREDICATE of Ident.ValId * Ident.TyVar

    datatype Strname = 
      STRNAME of Stamp | 
      METASTRNAME of Strname ref |
      NULLNAME of Stamp

    datatype InstanceInfo = 
      ZERO
    | ONE of int
    | TWO of int * int

    datatype Tyname = 
      TYNAME of (Stamp * string * int * bool ref 
                 * Valenv ref * string option * bool ref
                 * Valenv ref * int) |
      METATYNAME of (Tyfun ref * string * int * bool ref * Valenv ref
                     * bool ref)
      (* Valenv ref added for code generator's benefit *)
    
    and Type =
      METATYVAR of ((int * Type * Instance) ref * bool * bool) |
      META_OVERLOADED of
	(Type ref * Ident.TyVar * Ident.ValId * Ident.Location.T) |
      TYVAR of ((int * Type * Instance) ref * Ident.TyVar) |
      METARECTYPE of ((int * bool * Type * bool * bool) ref) |
      (* bool1 == this is an uninstantiated flex rectype,
       Type is a rectype giving flex contents if bool1 true 
       If bool1 is false, Type is a rectype giving rigid rectype 
       or a metarectype if instance of metarectype is another metarectype,
       bool2 == eq , bool3 == imp *)
      RECTYPE of (Ident.Lab,Type) NewMap.map |
      FUNTYPE of (Type * Type) |
      CONSTYPE of ((Type list) * Tyname) |
      DEBRUIJN of (int * bool * bool 
                   * (int * Type * Instance) ref option) |
      NULLTYPE
    
    and Tyfun =
      TYFUN of Type * int |
      ETA_TYFUN of Tyname |
      NULL_TYFUN of Stamp * Tyfun ref

          
    and Typescheme =
        SCHEME of (int * (Type * (Instance ref * Instance ref option ref) option))
      | UNBOUND_SCHEME of Type * (Instance ref * Instance ref option ref) option
      | OVERLOADED_SCHEME of OverLoaded

    and Instance = 
        INSTANCE of (int * Type * Instance) ref list
      | SIGNATURE_INSTANCE of InstanceInfo
      | NO_INSTANCE


    and Valenv = VE of int ref * ((Ident.ValId,Typescheme) NewMap.map)

    and Tystr = TYSTR of (Tyfun * Valenv)

    and Tyenv = TE of (Ident.TyCon,Tystr) NewMap.map

    and Env = ENV of (Strenv * Tyenv * Valenv)

    and Structure =
      STR of (Strname * MLWorks.Internal.Value.ml_value option ref * Env) |
      COPYSTR of ((Strname StampMap * Tyname StampMap) * Structure)

    and Strenv = SE of (Ident.StrId,Structure) NewMap.map

    datatype DebuggerStr = 
      DSTR of (Ident.StrId,DebuggerStr) NewMap.map * (Ident.TyCon,int) NewMap.map 
      * (Ident.ValId,int option) NewMap.map |
      EMPTY_DSTR

    val empty_valenv : Valenv

    (* atoms for a type error message, which is a list of these atoms.
     This is so tyvars in separate types printed in a message match up; see
     Types.print_type_with_seen_tyvars and Completion.report_type_error *)

    datatype type_error_atom =
        Err_String of string
      | Err_Type of Type	(* print a type with remembered tyvars *)
      | Err_Scheme of Type      (* Print a type with quantifiers *)
      | Err_Reset		(* reset remembered tyvars *)

end
@


1.32.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.32  1999/02/02  16:01:51  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.31
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
a108 1
require "stamp";
@


1.31.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.31  1997/05/01  12:55:14  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.31.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.31  1997/05/01  12:55:14  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.30
log
@[Bug #1592]
Threading extra level argument through tynames.
@
text
@d4 4
d136 1
a136 1
                 * Valenv ref * string MLWorks.Option.option * bool ref
d157 1
a157 1
                   * (int * Type * Instance) ref MLWorks.Option.option) |
d167 2
a168 2
        SCHEME of (int * (Type * (Instance ref * Instance ref MLWorks.Option.option ref) MLWorks.Option.option))
      | UNBOUND_SCHEME of Type * (Instance ref * Instance ref MLWorks.Option.option ref) MLWorks.Option.option
d186 1
a186 1
      STR of (Strname * MLWorks.Internal.Value.ml_value MLWorks.Option.option ref * Env) |
d193 1
a193 1
      * (Ident.ValId,int MLWorks.Option.option) NewMap.map |
@


1.30.6.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:36:34  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.30.6.1  1997/05/12  10:51:09  hope
 * branched from 1.30
 *
@


1.30.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.30.6.1  1997/05/12  10:51:09  hope
 * branched from 1.30
 *
@


1.30.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.30.6.1  1997/05/12  10:51:09  hope
 * branched from 1.30
 *
@


1.30.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.30.6.1.1.1  1997/07/28  18:34:28  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.30.5.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:36:34  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.4.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:36:34  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.4.1.1.1
log
@branched from 1.30.4.1
@
text
@a3 3
 * Revision 1.30.4.1  1996/12/17  18:17:35  hope
 * branched from 1.30
 *
@


1.30.3.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:36:34  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.2.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:36:34  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.30.2.1.1.1
log
@branched from 1.30.2.1
@
text
@a3 3
 * Revision 1.30.2.1  1996/11/14  13:20:49  hope
 * branched from 1.30
 *
@


1.30.1.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/10/04  15:36:34  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.29
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
d132 4
a135 2
                 * Valenv ref * string MLWorks.Option.option * bool ref * Valenv ref) |
      METATYNAME of (Tyfun ref * string * int * bool ref * Valenv ref * bool ref)
@


1.29.2.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/02/23  16:53:05  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.29.1.1
log
@branched from 1.29
@
text
@a3 3
 * Revision 1.29  1996/02/23  16:53:05  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.28
log
@Removing map in favour of newmap
@
text
@d4 3
d96 1
a96 1
require "../utils/newmap";
d102 1
a102 1
    structure NewMap  : NEWMAP
d144 1
a144 1
      RECTYPE of (Ident.Lab,Type) NewMap.T |
d168 1
a168 1
    and Valenv = VE of int ref * ((Ident.ValId,Typescheme) NewMap.T)
d172 1
a172 1
    and Tyenv = TE of (Ident.TyCon,Tystr) NewMap.T
d180 1
a180 1
    and Strenv = SE of (Ident.StrId,Structure) NewMap.T
d183 2
a184 2
      DSTR of (Ident.StrId,DebuggerStr) NewMap.T * (Ident.TyCon,int) NewMap.T 
      * (Ident.ValId,int MLWorks.Option.option) NewMap.T |
@


1.27
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
a92 1
require "../utils/map";
a98 1
    structure Mapping : MAP
d141 1
a141 1
      RECTYPE of (Ident.Lab,Type) Mapping.Map |
@


1.26
log
@Adding tyname map to COPYSTR's
@
text
@d4 3
a91 1
require "../utils/option";
a99 1
    structure Option : OPTION
d125 1
a125 1
                 * Valenv ref * string Option.opt * bool ref * Valenv ref) |
d144 1
a144 1
                   * (int * Type * Instance) ref Option.opt) |
d154 2
a155 2
        SCHEME of (int * (Type * (Instance ref * Instance ref Option.opt ref) Option.opt))
      | UNBOUND_SCHEME of Type * (Instance ref * Instance ref Option.opt ref) Option.opt
d173 1
a173 1
      STR of (Strname * MLWorks.Internal.Value.ml_value Option.opt ref * Env) |
d180 1
a180 1
      * (Ident.ValId,int Option.opt) NewMap.T |
@


1.25
log
@Rationalizing debugger
@
text
@d4 3
d91 1
a91 1
require "simpletypes";
d100 2
a101 3
    structure Tyname_id : TYNAME_ID
    structure Tyfun_id : TYFUN_ID
    structure Strname_id : STRNAME_ID
d113 1
a113 1
      STRNAME of Strname_id.Strname_id | 
d115 1
a115 1
      NULLNAME of Strname_id.Strname_id
d123 1
a123 1
      TYNAME of (Tyname_id.Tyname_id * string * int * bool ref 
d149 1
a149 1
      NULL_TYFUN of Tyfun_id.Tyfun_id * Tyfun ref
d173 1
a173 1
      COPYSTR of ((Strname Strname_id.Map.T * Tyname Tyfun_id.Map.T) * Structure)
a182 3

    val push_counters : unit -> unit
    val pop_counters : unit -> unit
@


1.24
log
@Allow alternative printing of types to include quantifiers
@
text
@d4 3
d115 5
d157 1
a157 1
      | SIGNATURE_INSTANCE of int list
@


1.23
log
@Revised previous log message.
@
text
@d4 3
d184 1
@


1.22
log
@testing the new overloading scheme.
@
text
@d4 4
@


1.21
log
@Debugger structures and extra TYNAME valenv for Modules Debugger.
@
text
@d4 3
d96 3
a98 3
      UNARY of Ident.ValId | 
      BINARY of Ident.ValId |
      PREDICATE of Ident.ValId
d113 2
a114 1
      META_OVERLOADED  of (Type ref * Ident.ValId) |
@


1.20
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d104 1
a104 1
                 * Valenv ref * string Option.opt * bool ref) |
d109 1
a109 1
      METATYVAR of ((int * Type * instance) ref * bool * bool) |
d111 1
a111 1
      TYVAR of ((int * Type * instance) ref * Ident.TyVar) |
d122 1
a122 1
                   * (int * Type * instance) ref Option.opt) |
d128 1
a128 1
      NULL_TYFUN of Tyfun_id.Tyfun_id * Tyfun ref Option.opt
d132 2
a133 2
        SCHEME of (int * (Type * (instance ref * instance ref Option.opt ref) Option.opt))
      | UNBOUND_SCHEME of Type * (instance ref * instance ref Option.opt ref) Option.opt
d136 2
a137 2
    and instance = 
        INSTANCE of (int * Type * instance) ref list
d155 5
@


1.19
log
@Added code to encode type errors as a list of strings and types.
@
text
@d4 3
d101 2
a102 2
                 * Valenv ref * string Option.opt) |
      METATYNAME of (Tyfun ref * string * int * bool ref * Valenv ref)
@


1.18
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d154 10
@


1.17
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.
@
text
@d4 5
d100 1
a100 1
      METATYVAR of ((int * Type) ref * bool * bool) |
d102 1
a102 1
      TYVAR of (int ref * Ident.TyVar) |
d112 2
a113 1
      DEBRUIJN of (int * bool * bool) |
d122 3
a124 3
    and Typescheme = 
        SCHEME of (int * Type)
      | UNBOUND_SCHEME of Type
d126 6
@


1.17.1.1
log
@Fork for bug fixing
@
text
@a3 5
Revision 1.17  1993/07/09  11:45:20  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.

@


1.16
log
@Removed exception environments and interfaces.
@
text
@d4 3
d59 1
d68 1
a77 2
    datatype 'a opt = PRESENT of 'a | ABSENT

d89 2
a90 1
      TYNAME of (Tyname_id.Tyname_id * string * int * bool ref * Valenv ref * string opt) |
d113 1
a113 1
      NULL_TYFUN of Tyfun_id.Tyfun_id
d116 2
a117 1
    and Typescheme = SCHEME of (int * Type)
d130 1
a130 1
      STR of (Strname * MLWorks.Internal.Value.ml_value opt ref * Env) |
@


1.15
log
@Added push and pop functions for the id counters
@
text
@d4 3
a56 1
require "interface";
a67 4
    structure Interface : INTERFACE

    sharing Ident = Interface.Ident
    sharing NewMap = Interface.NewMap
d122 1
a122 1
    and Env = ENV of (Strenv * Tyenv * Valenv * Valenv)
d125 1
a125 1
      STR of (Strname * Interface.Int opt ref * Env) |
@


1.14
log
@Str to Structure
@
text
@d4 3
d134 2
@


1.13
log
@not much changed here
@
text
@d4 3
d123 1
a123 1
    and Str =
d125 1
a125 1
      COPYSTR of ((Strname Strname_id.Map.T * Tyname Tyfun_id.Map.T) * Str)
d127 1
a127 1
    and Strenv = SE of (Ident.StrId,Str) NewMap.T
@


1.12
log
@New representation of structures
Removed TypeLocation type
@
text
@d4 4
d127 1
@


1.11
log
@Anel's last changes
@
text
@d4 3
d44 1
d56 4
d65 2
a76 2
      datatype TypeLocation = PRESENT of string | ABSENT

d78 1
a78 1
      TYNAME of (Tyname_id.Tyname_id * string * int * bool ref * Valenv ref * TypeLocation) |
d115 5
a119 1
    and Str = STR of (Strname * Env)
a122 1

@


1.10
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d57 4
a60 1
    datatype Over_Loaded = UNARY | BINARY | PREDICATE
d76 1
a76 1
      META_OVERLOADED  of Type ref |
d98 1
a98 1
      | OVERLOADED_SCHEME of Over_Loaded
@


1.9
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
a104 6
    val strid_order : Ident.StrId * Ident.StrId -> bool
    val tycon_order : Ident.TyCon * Ident.TyCon -> bool
    val valid_order : Ident.ValId * Ident.ValId -> bool
    val strid_equal : Ident.StrId * Ident.StrId -> bool
    val tycon_equal : Ident.TyCon * Ident.TyCon -> bool
    val valid_equal : Ident.ValId * Ident.ValId -> bool
a106 2


@


1.8
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d58 2
d61 1
a61 1
      TYNAME of (Tyname_id.Tyname_id * string * int * bool ref * Valenv ref) |
@


1.7
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d97 6
a102 3
    val strid_order : Ident.StrId * Ident.StrId -> NewMap.relation
    val tycon_order : Ident.TyCon * Ident.TyCon -> NewMap.relation
    val valid_order : Ident.ValId * Ident.ValId -> NewMap.relation
@


1.6
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
a27 1
require "../basics/identprint";
a34 3
    structure IdentPrint : IDENTPRINT
      
    sharing IdentPrint.Ident = Ident
@


1.5
log
@Updated to allow valenv in METATYNAME
@
text
@d4 3
d23 1
d31 2
a32 1
    structure Ident : IDENT
d83 1
a83 1
    and Valenv = VE of int ref * ((Ident.ValId,Typescheme) Mapping.Map)
d87 1
a87 1
    and Tyenv = TE of (Ident.TyCon,Tystr) Mapping.Map
d91 6
a96 1
    and Strenv = SE of (Ident.StrId,Str) Mapping.Map
@


1.4
log
@Changed ref unit in valenv to ref int to assist encoder
@
text
@d4 3
d49 2
a50 1
      METATYNAME of (Tyfun ref * string * int * bool ref)
@


1.3
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	datatypes.sml,v $
d74 1
a74 1
    and Valenv = VE of unit ref * ((Ident.ValId,Typescheme) Mapping.Map)
@


1.2
log
@Gives new ValEnv definition with ref unit to allow reading and
writing circular data structures.
@
text
@d1 1
d4 4
d11 1
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d65 1
a65 1
    and Valenv = VE of (Ident.ValId,Typescheme) Mapping.Map
@
