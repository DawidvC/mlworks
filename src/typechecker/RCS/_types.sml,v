head	1.122;
access;
symbols
	MLW_daveb_inline_1_4_99:1.122.1
	MLWorks_21c0_1999_03_25:1.122
	MLWorks_20c1_1998_08_20:1.122
	MLWorks_20c0_1998_08_04:1.122
	MLWorks_20b2c2_1998_06_19:1.122
	MLWorks_20b2_Windows_1998_06_12:1.122
	MLWorks_20b1c1_1998_05_07:1.122
	MLWorks_20b0_1998_04_07:1.122
	MLWorks_20b0_1998_03_20:1.122
	MLWorks_20m2_1998_02_16:1.121
	MLWorks_20m1_1997_10_23:1.121
	MLWorks_11r1:1.120.1.1.1.1.1
	MLWorks_workspace_97:1.121.2
	MLWorks_dt_wizard:1.121.1
	MLWorks_11c0_1997_09_09:1.120.1.1.1.1
	MLWorks_10r3:1.120.1.1.3
	MLWorks_10r2_551:1.120.1.1.2
	MLWorks_11:1.120.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.120.1.1
	MLWorks_20m0_1997_06_20:1.121
	MLWorks_1_0_r2c2_1997_06_14:1.120.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.120.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.120.1
	MLWorks_BugFix_1997_04_24:1.120
	MLWorks_1_0_r2_Win32_1997_04_11:1.120
	MLWorks_1_0_r2_Unix_1997_04_04:1.120
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.119.3.1.1
	MLWorks_gui_1996_12_18:1.119.4
	MLWorks_1_0_Win32_1996_12_17:1.119.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.119.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.119.1.1
	MLWorks_1_0_Irix_1996_11_28:1.119.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.119.2
	MLWorks_1_0_Unix_1996_11_14:1.119.1
	MLWorks_Open_Beta2_1996_10_11:1.116.1
	MLWorks_License_dev:1.115.2
	MLWorks_1_open_beta_1996_09_13:1.115.1
	MLWorks_Open_Beta_1996_08_22:1.115
	MLWorks_Beta_1996_07_02:1.114
	MLWorks_Beta_1996_06_07:1.114
	MLWorks_Beta_1996_06_06:1.114
	MLWorks_Beta_1996_06_05:1.114
	MLWorks_Beta_1996_06_03:1.114
	MLWorks_Beta_1996_05_31:1.114
	MLWorks_Beta_1996_05_30:1.114
	ML_beta_release_12/08/94:1.82
	ML_beta_release_03/08/94:1.82
	ML_revised_beta_release_25/05/94:1.82
	ML_final_beta_release_02/03/94:1.78
	mlworks-28-01-1994:1.77
	Release:1.69
	mlworks-beta-01-09-1993:1.69
	MLWorks-1-0-4-29/01/1993:1.50
	MLWorks-1-0-3-21/12/1992:1.49
	MLWorks-1-0-2-15/12/1992:1.48
	MLWorks-1-0-1-04/12/1992:1.47
	checkpoint_17_08_92:1.30
	Ten15_release_19-11-91:1.4
	Ten15_release_21-08-91:1.4
	Ten15_release_19-08-91:1.4
	ten15_release:1.4;
locks; strict;
comment	@ * @;


1.122
date	98.02.19.16.32.51;	author mitchell;	state Exp;
branches
	1.122.1.1;
next	1.121;

1.121
date	97.04.25.16.28.32;	author jont;	state Exp;
branches
	1.121.1.1
	1.121.2.1;
next	1.120;

1.120
date	96.12.18.16.38.04;	author andreww;	state Exp;
branches
	1.120.1.1;
next	1.119;

1.119
date	96.11.06.13.38.56;	author andreww;	state Exp;
branches
	1.119.1.1
	1.119.2.1
	1.119.3.1
	1.119.4.1;
next	1.118;

1.118
date	96.11.06.11.33.49;	author matthew;	state Exp;
branches;
next	1.117;

1.117
date	96.10.29.14.01.39;	author io;	state Exp;
branches;
next	1.116;

1.116
date	96.10.04.15.40.11;	author andreww;	state Exp;
branches
	1.116.1.1;
next	1.115;

1.115
date	96.08.05.14.16.31;	author andreww;	state Exp;
branches
	1.115.1.1
	1.115.2.1;
next	1.114;

1.114
date	96.05.24.11.52.45;	author matthew;	state Exp;
branches;
next	1.113;

1.113
date	96.05.23.15.02.28;	author matthew;	state Exp;
branches;
next	1.112;

1.112
date	96.05.07.10.35.05;	author jont;	state Exp;
branches;
next	1.111;

1.111
date	96.04.30.17.44.13;	author jont;	state Exp;
branches;
next	1.110;

1.110
date	96.04.29.13.27.21;	author matthew;	state Exp;
branches;
next	1.109;

1.109
date	96.03.08.12.07.14;	author daveb;	state Exp;
branches;
next	1.108;

1.108
date	96.02.22.11.14.27;	author jont;	state Exp;
branches;
next	1.107;

1.107
date	95.12.27.11.28.05;	author jont;	state Exp;
branches;
next	1.106;

1.106
date	95.12.05.12.10.02;	author jont;	state Exp;
branches;
next	1.105;

1.105
date	95.11.03.10.17.06;	author matthew;	state Exp;
branches;
next	1.104;

1.104
date	95.10.18.13.58.27;	author matthew;	state Exp;
branches;
next	1.103;

1.103
date	95.09.11.11.11.31;	author daveb;	state Exp;
branches;
next	1.102;

1.102
date	95.08.22.16.09.12;	author jont;	state Exp;
branches;
next	1.101;

1.101
date	95.08.01.10.43.49;	author jont;	state Exp;
branches;
next	1.100;

1.100
date	95.07.28.14.27.20;	author jont;	state Exp;
branches;
next	1.99;

1.99
date	95.07.27.16.41.31;	author jont;	state Exp;
branches;
next	1.98;

1.98
date	95.07.26.13.35.07;	author jont;	state Exp;
branches;
next	1.97;

1.97
date	95.07.24.15.55.53;	author jont;	state Exp;
branches;
next	1.96;

1.96
date	95.07.21.13.18.03;	author jont;	state Exp;
branches;
next	1.95;

1.95
date	95.07.19.10.26.42;	author jont;	state Exp;
branches;
next	1.94;

1.94
date	95.07.13.13.14.22;	author jont;	state Exp;
branches;
next	1.93;

1.93
date	95.05.02.10.11.02;	author matthew;	state Exp;
branches;
next	1.92;

1.92
date	95.04.10.11.04.14;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	95.04.06.12.56.19;	author matthew;	state Exp;
branches;
next	1.90;

1.90
date	95.04.05.09.52.17;	author jont;	state Exp;
branches;
next	1.89;

1.89
date	95.03.17.17.24.22;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	95.03.02.13.15.31;	author matthew;	state Exp;
branches;
next	1.87;

1.87
date	95.02.17.11.40.12;	author daveb;	state Exp;
branches;
next	1.86;

1.86
date	95.02.02.14.35.45;	author matthew;	state Exp;
branches;
next	1.85;

1.85
date	94.10.13.10.28.10;	author matthew;	state Exp;
branches;
next	1.84;

1.84
date	94.09.22.11.44.27;	author matthew;	state Exp;
branches;
next	1.83;

1.83
date	94.08.31.16.12.07;	author matthew;	state Exp;
branches;
next	1.82;

1.82
date	94.05.13.15.20.56;	author daveb;	state Exp;
branches;
next	1.81;

1.81
date	94.05.11.14.41.21;	author daveb;	state Exp;
branches;
next	1.80;

1.80
date	94.05.04.14.20.42;	author jont;	state Exp;
branches;
next	1.79;

1.79
date	94.04.27.15.56.29;	author jont;	state Exp;
branches;
next	1.78;

1.78
date	94.02.28.09.00.37;	author nosa;	state Exp;
branches;
next	1.77;

1.77
date	93.11.30.11.10.20;	author matthew;	state Exp;
branches;
next	1.76;

1.76
date	93.11.25.11.56.02;	author nickh;	state Exp;
branches;
next	1.75;

1.75
date	93.11.24.18.56.40;	author nickh;	state Exp;
branches;
next	1.74;

1.74
date	93.11.24.10.13.53;	author nickh;	state Exp;
branches;
next	1.73;

1.73
date	93.11.23.16.54.27;	author nickh;	state Exp;
branches;
next	1.72;

1.72
date	93.11.16.20.40.34;	author jont;	state Exp;
branches;
next	1.71;

1.71
date	93.09.27.11.04.26;	author jont;	state Exp;
branches;
next	1.70;

1.70
date	93.09.03.11.11.09;	author nosa;	state Exp;
branches;
next	1.69;

1.69
date	93.08.23.13.51.05;	author jont;	state Exp;
branches
	1.69.1.1;
next	1.68;

1.68
date	93.08.03.12.24.14;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	93.07.30.15.11.00;	author nosa;	state Exp;
branches;
next	1.66;

1.66
date	93.07.29.17.27.07;	author jont;	state Exp;
branches;
next	1.65;

1.65
date	93.06.11.14.20.03;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	93.06.04.09.37.51;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	93.05.20.15.07.20;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	93.05.18.18.20.43;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	93.05.05.15.47.18;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	93.04.26.17.55.59;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	93.04.08.16.14.37;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	93.03.31.12.27.42;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	93.03.09.17.24.59;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	93.03.04.10.10.16;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	93.03.02.16.24.02;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	93.03.01.11.04.16;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	93.02.25.16.03.24;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	93.02.18.16.49.29;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	93.02.01.14.49.21;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	92.12.22.15.32.40;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	92.12.16.15.25.26;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	92.12.09.10.11.18;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	92.11.28.16.43.10;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	92.11.26.20.03.12;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	92.11.25.17.08.59;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	92.10.30.15.13.58;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	92.10.27.12.12.49;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	92.10.12.11.15.08;	author clive;	state Exp;
branches;
next	1.41;

1.41
date	92.09.25.14.51.53;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	92.09.25.12.31.16;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	92.09.16.08.38.26;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	92.09.11.10.26.08;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	92.09.08.13.34.08;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	92.09.02.13.40.04;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.08.28.16.00.13;	author davidt;	state Exp;
branches;
next	1.34;

1.34
date	92.08.28.00.46.25;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.08.27.19.38.34;	author davidt;	state Exp;
branches;
next	1.32;

1.32
date	92.08.27.15.30.33;	author davidt;	state Exp;
branches;
next	1.31;

1.31
date	92.08.17.10.09.29;	author clive;	state Exp;
branches;
next	1.30;

1.30
date	92.08.14.10.41.30;	author davidt;	state Exp;
branches;
next	1.29;

1.29
date	92.08.13.15.34.00;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	92.08.13.10.20.12;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.08.11.13.27.37;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	92.08.10.16.53.02;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	92.08.06.17.43.41;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.07.28.14.49.24;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.07.27.11.47.35;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	92.07.21.09.02.42;	author clive;	state Exp;
branches;
next	1.21;

1.21
date	92.07.16.18.43.45;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	92.07.04.17.16.00;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.06.16.14.07.26;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.06.02.10.49.51;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.05.05.14.09.25;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.04.13.13.37.29;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.04.01.14.51.37;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.02.11.10.14.28;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.01.27.20.11.32;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.01.24.16.02.11;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.01.23.15.50.34;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.01.15.12.07.19;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.01.14.16.41.11;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.01.14.11.50.15;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.01.07.19.21.14;	author colin;	state Exp;
branches;
next	1.6;

1.6
date	92.01.07.16.19.42;	author colin;	state Exp;
branches;
next	1.5;

1.5
date	91.11.19.17.11.14;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.07.12.14.15.22;	author colin;	state Exp;
branches;
next	1.3;

1.3
date	91.06.18.15.42.00;	author colin;	state Exp;
branches;
next	1.2;

1.2
date	91.06.17.17.16.00;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.39.10;	author colin;	state Exp;
branches;
next	;

1.69.1.1
date	93.08.23.13.51.05;	author jont;	state Exp;
branches;
next	1.69.1.2;

1.69.1.2
date	93.09.23.15.35.00;	author jont;	state Exp;
branches;
next	;

1.115.1.1
date	96.09.13.11.41.31;	author hope;	state Exp;
branches;
next	;

1.115.2.1
date	96.10.07.16.34.35;	author hope;	state Exp;
branches;
next	;

1.116.1.1
date	96.10.17.11.53.41;	author hope;	state Exp;
branches;
next	;

1.119.1.1
date	96.11.14.13.21.17;	author hope;	state Exp;
branches
	1.119.1.1.1.1;
next	;

1.119.1.1.1.1
date	96.11.28.15.32.19;	author hope;	state Exp;
branches;
next	;

1.119.2.1
date	96.11.22.18.39.02;	author hope;	state Exp;
branches;
next	;

1.119.3.1
date	96.12.17.18.18.03;	author hope;	state Exp;
branches
	1.119.3.1.1.1;
next	;

1.119.3.1.1.1
date	97.02.24.12.12.19;	author hope;	state Exp;
branches;
next	;

1.119.4.1
date	96.12.18.10.13.19;	author hope;	state Exp;
branches;
next	;

1.120.1.1
date	97.05.12.10.51.36;	author hope;	state Exp;
branches
	1.120.1.1.1.1
	1.120.1.1.2.1
	1.120.1.1.3.1;
next	;

1.120.1.1.1.1
date	97.07.28.18.33.27;	author daveb;	state Exp;
branches
	1.120.1.1.1.1.1.1;
next	;

1.120.1.1.1.1.1.1
date	97.10.07.11.59.26;	author jkbrook;	state Exp;
branches;
next	;

1.120.1.1.2.1
date	97.09.08.17.26.33;	author daveb;	state Exp;
branches;
next	;

1.120.1.1.3.1
date	97.09.09.14.23.23;	author daveb;	state Exp;
branches;
next	;

1.121.1.1
date	97.09.10.19.42.21;	author brucem;	state Exp;
branches;
next	;

1.121.2.1
date	97.09.11.21.09.51;	author daveb;	state Exp;
branches;
next	;

1.122.1.1
date	99.04.01.18.08.35;	author daveb;	state Exp;
branches;
next	;


desc
@Functions ranging over types and type functions
@


1.122
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _types.sml the functor *)
(*
$Log: _types.sml,v $
 * Revision 1.121  1997/04/25  16:28:32  jont
 * [Bug #20017]
 * Add has_int32_equality function
 *
 * Revision 1.120  1996/12/18  16:38:04  andreww
 * [Bug #1818]
 * Adding new floatarray type name.
 *
 * Revision 1.119  1996/11/06  13:38:56  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
 * Revision 1.118  1996/11/06  11:33:49  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.117  1996/10/29  14:01:39  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.116  1996/10/04  15:40:11  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
 * Revision 1.115  1996/08/05  14:16:31  andreww
 * [Bug #1521]
 * Prevent type variables being distinguished as imperative when using
 * value polymorphism.
 *
 * Revision 1.114  1996/05/24  11:52:45  matthew
 * Improving tyfun_strip
 *
 * Revision 1.113  1996/05/23  15:02:28  matthew
 * Removing Crash.impossible in type_copy
 *
 * Revision 1.112  1996/05/07  10:35:05  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.111  1996/04/30  17:44:13  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.110  1996/04/29  13:27:21  matthew
 * Integer changes
 *
 * Revision 1.109  1996/03/08  12:07:14  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
 * Revision 1.108  1996/02/22  11:14:27  jont
 * Replacing Map with NewMap
 *
 * Revision 1.107  1995/12/27  11:28:05  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.106  1995/12/05  12:10:02  jont
Modify has_free_imptyvars to return the offending tyvar if it exists
Add type_occurs to find if such a type occurs within another more
complicated type

Revision 1.105  1995/11/03  10:17:06  matthew
Extended check on free type variables to include non-imperative tyvars.
These shouldn't occur with normal semantics and should be caught with
value-polymorphism semantics.

Revision 1.104  1995/10/18  13:58:27  matthew
Removing a compiler fault that can happen with error recoveru

Revision 1.103  1995/09/11  11:11:31  daveb
Added types for different lengths of words, ints and reals.

Revision 1.102  1995/08/22  16:09:12  jont
Add has_int_equality, has_real_equality, has_string_equality

Revision 1.101  1995/08/01  10:43:49  jont
Add bytearray to has_ref_equality

Revision 1.100  1995/07/28  14:27:20  jont
Sort out resolve_overloading to handle word types

Revision 1.99  1995/07/27  16:41:31  jont
Add word_typep and wordint_typep

Revision 1.98  1995/07/26  13:35:07  jont
Fix word_type to refer to word_tyname

Revision 1.97  1995/07/24  15:55:53  jont
Add word literal support

Revision 1.96  1995/07/21  13:18:03  jont
Add word_type and word_tyname

Revision 1.95  1995/07/19  10:26:42  jont
Add Ident.CHAR to type_of function

Revision 1.94  1995/07/13  13:14:22  jont
Add char type for new revised basis

Revision 1.93  1995/05/02  10:11:02  matthew
Removing special case for printing bytearray type

Revision 1.92  1995/04/10  11:04:14  matthew
Added simplify_type function

Revision 1.91  1995/04/06  12:56:19  matthew
stuff

Revision 1.90  1995/04/05  09:52:17  jont
Ensure that arrays have reference semantics with respect to equality

Revision 1.89  1995/03/17  17:24:22  matthew
Fixing problem with printing flexible record types.
Use NewMap.map more.

Revision 1.87  1995/02/17  11:40:12  daveb
Improved printing of overloaded type variables.

Revision 1.86  1995/02/02  14:35:45  matthew
Removing debug stuff

Revision 1.85  1994/10/13  10:28:10  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.84  1994/09/22  11:44:27  matthew
Abstraction of debug information
Tidying up

Revision 1.83  1994/08/31  16:12:07  matthew
Minor efficiency improvements to copy_type

Revision 1.82  1994/05/13  15:20:56  daveb
Fixed type_of: integer literals were assigned int_tyvar instead of
int_literal_tyvar.

Revision 1.81  1994/05/11  14:41:21  daveb
New overloading scheme.

Revision 1.80  1994/05/04  14:20:42  jont
Fix tyfun_strip to ensure arity preserved
Fixed typos in debug_print_type and friends

Revision 1.79  1994/04/27  15:56:29  jont
Added functions for checking for uninstantiated tyvars

Revision 1.78  1994/02/28  09:00:37  nosa
Changed Datatypes.instance to Datatypes.Instance.

Revision 1.77  1993/11/30  11:10:20  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.76  1993/11/25  11:56:02  nickh
Added hooks to print types with a set of remembered type variables.

Revision 1.75  1993/11/24  18:56:40  nickh
Bug fixes 481 and 489: constypes with multiple metarectypes were
printing poorly, and the 26th, 52nd, etc type variables were printing
incorrectly.

Revision 1.74  1993/11/24  10:13:53  nickh
Patch up silent failure in RCS.

Revision 1.73  1993/11/23  16:54:27  nickh
Fixed the way record types are printed (killed a space and improved
tail-recursion).

Revision 1.72  1993/11/16  20:40:34  jont
Made app_subst substitute for instantiated META_OVERLOADED types, which result
from top level resolution of overloading

Revision 1.71  1993/09/27  11:04:26  jont
Merging in bug fixes

Revision 1.70  1993/09/03  11:11:09  nosa
Instances for METATYVARs and TYVARs and DEBRUIJNs;
function all_tyvars that returns all METATYVAR- and TYVAR- refs
for polymorphic debugger.

Revision 1.69.1.2  1993/09/23  15:35:00  jont
Added make_true for doing equality_principal algorithm

Revision 1.69.1.1  1993/08/23  13:51:05  jont
Fork for bug fixing

Revision 1.69  1993/08/23  13:51:05  jont
Improved type_copy and associated functions

Revision 1.68  1993/08/03  12:24:14  matthew
Changed printing of overloaded types.

Revision 1.67  1993/07/30  15:11:00  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.

Revision 1.66  1993/07/29  17:27:07  jont
Extra extra information debug_print_type

Revision 1.65  1993/06/11  14:20:03  matthew
 Fixed some problems with type printing

Revision 1.64  1993/06/04  09:37:51  matthew
Fixed type circularity check

Revision 1.63  1993/05/20  15:07:20  matthew
Removed debuggery
Changed debug_print_name a little.

Revision 1.62  1993/05/18  18:20:43  jont
Removed integer parameter

Revision 1.61  1993/05/05  15:47:18  matthew
Corrected name of vector_tyname
Changed tyname_copy to handle flexible names not in the mapping.

Revision 1.60  1993/04/26  17:55:59  daveb
Added print_tyvars and make_tyvars.

Revision 1.59  1993/04/08  16:14:37  matthew
Added closed_type_equalityp for getting equality attributes of
closed types.

Revision 1.58  1993/03/31  12:27:42  jont
Fixed bug in tyname_strip which didn't remove the simple TYFUN(CONSTYPE) case
This caused completion to fail

Revision 1.57  1993/03/09  17:24:59  jont
Added string_or_num_typep for spotting overloading of relationals to strings.

Revision 1.56  1993/03/04  10:10:16  matthew
Options & Info changes

Revision 1.55  1993/03/02  16:24:02  matthew
Rationalised use of Mapping structure

Revision 1.54  1993/03/01  11:04:16  matthew
Added vector and bytearray tynames

Revision 1.53  1993/02/25  16:03:24  matthew
Added array_tyname

Revision 1.52  1993/02/18  16:49:29  matthew
Added dynamic type definition

Revision 1.51  1993/02/01  14:49:21  matthew
Added sharing

Revision 1.50  1992/12/22  15:32:40  jont
Anel's last changes

Revision 1.49  1992/12/16  15:25:26  jont
Allow make_new_type to deal with METATYVAR returned by other failures

Revision 1.48  1992/12/09  10:11:18  matthew
Fixed type printing.

Revision 1.47  1992/11/28  16:43:10  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.46  1992/11/26  20:03:12  daveb
Fixed typo in type_strip.

Revision 1.45  1992/11/25  17:08:59  jont
Improved type_eq by stripping rubbish off types before matching

Revision 1.44  1992/10/30  15:13:58  jont
Added special maps for tyfun_id, tyname_id, strname_id

Revision 1.43  1992/10/27  12:12:49  jont
Fixes to print flexible records properly

Revision 1.42  1992/10/12  11:15:08  clive
Tynames now have a slot recording their definition point

Revision 1.41  1992/09/25  14:51:53  jont
Changed type of Map.fold

Revision 1.40  1992/09/25  12:31:16  jont
Removed simpletypes and its structures, they're in datatypes

Revision 1.39  1992/09/16  08:38:26  daveb
Improved printing of types, including placing of brackets.
Meta status of types, etc., only printed when do_debug is true

Revision 1.38  1992/09/11  10:26:08  jont
Improved versions of tyfun_eq and tyname_eq

Revision 1.37  1992/09/08  13:34:08  jont
Removed has_a_new_name, no longer needed. Recoded meta_tyname

Revision 1.36  1992/09/02  13:40:04  jont
Stuff to understand type functions properly

Revision 1.35  1992/08/28  16:00:13  davidt
Fixed bug in tyname_copy which copied too much stuff.

Revision 1.34  1992/08/28  00:46:25  jont
Ensured new names propagated through tyfuns and tynames

Revision 1.33  1992/08/27  19:38:34  davidt
Made various changes so that structure copying can be
done more efficiently.

Revision 1.32  1992/08/27  15:30:33  davidt
Added Anel's changes, and changed some stuff to do better
equality checking of valenvs etc.

Revision 1.31  1992/08/17  10:09:29  clive
Simple hack-fix to the print_name failing on most of its possible inputs

Revision 1.30  1992/08/14  10:41:30  davidt
Changed tyvars function to take a tuple of arguments.
l with Lists.reducel.

Revision 1.29  1992/08/13  15:34:00  jont
Fixed copy_metatyname and new_metatyname to duplicate the
valenv ref as well as all the other refs

Revision 1.28  1992/08/13  10:20:12  clive
Changed the tuple-type printing to use *

Revision 1.27  1992/08/11  13:27:37  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.26  1992/08/10  16:53:02  matthew
Changed eq_attrib so it follows META chains.

Revision 1.25  1992/08/06  17:43:41  jont
Anel's changes to use NewMap instead of Map

Revision 1.24  1992/07/28  14:49:24  jont
Removed use of Array parameter to allow pervasive Array to be used

Revision 1.23  1992/07/27  11:47:35  richard
Added ml_value_tyname.

Revision 1.22  1992/07/21  09:02:42  clive
Fixed the string_types function - if didn't bracket a funtype with a funtype as its first
argument

Revision 1.21  1992/07/16  18:43:45  jont
Changed to use btrees for renaming of tynames and strnames

Revision 1.20  1992/07/04  17:16:00  jont
Anel's changes for improved structure copying

Revision 1.19  1992/06/16  14:07:26  jont
Modifications to sort out unification of flexible record types in order
to provide full information to the lambda translation

Revision 1.17  1992/05/05  14:09:25  jont
Anel's fixes

Revision 1.16  1992/04/13  13:37:29  jont
Fixed bug in type matching shown up my _miropttypes

Revision 1.15  1992/04/01  14:51:37  jont
Added new function tyvar_equalityp for where the equality attribute is
significant. The previous function type_equalityp now ignores the
equality attribute of type variables

Revision 1.14  1992/02/11  10:14:28  clive
New pervasive library code - cut some things out of the initial type basis

Revision 1.13  1992/01/27  20:11:32  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.12  1992/01/24  16:02:11  jont
Updated to allow valenv in METATYNAME

Revision 1.11  1992/01/23  15:50:34  jont
Added value giving tyfun_id_counter at end of defining pervasives

Revision 1.10  1992/01/15  12:07:19  clive
Added the array type

Revision 1.9  1992/01/14  16:41:11  jont
Changed ref unit in valenv to ref int to assist encoder

Revision 1.8  1992/01/14  11:50:15  jont
Changed comparison with ref_tyname to use tyname_eq, in order to assist
separate compilation system

Revision 1.7  1992/01/07  19:21:14  colin
Added pervasive_tyname_count giving tyname id of first tyname after
the pervasives have been defined and added code to reset tyname counter
prior to defining the pervasives.

Revision 1.6  1992/01/07  16:19:42  colin
Removed last argument to calls to make_tyname
Removed no_of_cons

Revision 1.5  1991/11/19  17:11:14  jont
Removed inexhaustive matches

Revision 1.4  91/07/12  14:15:22  colin
Made eq tynames print with a [t] otherwise an [f] in print_name
This makes debugging easier than before ;-)

Revision 1.3  91/06/18  15:42:00  colin
Added functions (isFunType) to check for a funtype and (argres) to extract
argument and result types.

Revision 1.2  91/06/17  17:16:00  nickh
Modified to take new ValEnv definition with ref unit to allow
reading and writing circular data structures.

Revision 1.1  91/06/07  11:39:10  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "^.basis.__int";
require "^.basis.__list";

require "../utils/lists";
require "../utils/print";
require "../utils/crash";
require "../basics/identprint";
require "datatypes";
require "stamp";
require "types";

functor Types (
  structure Lists : LISTS
  structure Print : PRINT
  structure Crash : CRASH
  structure Datatypes : DATATYPES
  structure Stamp : STAMP
  structure IdentPrint : IDENTPRINT

  sharing IdentPrint.Ident = Datatypes.Ident
  sharing type Datatypes.Stamp = Stamp.Stamp
  sharing type Datatypes.StampMap = Stamp.Map.T

) : TYPES =
  struct
    structure Datatypes = Datatypes
    structure Options = IdentPrint.Options

    val do_debug = false
    val generate_moduler_debug = false

    (****
     In this functor all operations on the three mutually recursive data
     structures Types, Tyname and Tyfun are declared.  See the structure 
     Datatypes for the datatype declarations.
     ****)

    open Datatypes

    type PrintTypeOptions = {show_eq_info : bool
                             }

    val debug_print_options = {show_eq_info = true}

    fun show_eq ({show_eq_info, ...}: PrintTypeOptions) = show_eq_info

      (* note that in the following, level is an integer reference.
         See DATATYPEdec case for check_dec in typechecker/_core_rules.sml
         for an explanation. *)

    fun make_tyname (n,eq,pname,location,level) = 
      TYNAME (Stamp.make_stamp (),pname,n,ref eq, ref empty_valenv,location,
              ref false,ref empty_valenv,level)

    fun tyname_arity (TYNAME (_,_,n,_,_,_,_,_,_)) = n
      | tyname_arity (METATYNAME (_,_,n,_,_,_)) = n

    (****
     Used in maximising equality - rules 19 and 20.
     ****)

    fun tyname_make_false (TYNAME (_,_,_,r,_,_,_,_,_)) = (r := false; false)
      | tyname_make_false (METATYNAME (ref tyfun,_,_,r,_,_)) =
	case tyfun of
	  ETA_TYFUN tyname => tyname_make_false tyname
      | NULL_TYFUN _ =>
	  (r := false; false)
      | TYFUN _ => Crash.impossible "Types.make_false"

    (****
     make_false is used in maximising equality - rules 19 and 20.
     ****)
    and make_false (TYFUN (_)) = Crash.impossible "Types.make_false"
      | make_false (ETA_TYFUN (tyname)) = tyname_make_false tyname
      | make_false (NULL_TYFUN (_)) = false

    (****
     make_true is used in maximising equality - rules 19 and 20.
     ****)
    fun make_true (TYNAME (_,_,_,r,_,_,_,_,_)) = r := true
      | make_true (METATYNAME (ref tyfun,_,_,r,_,_)) =
	case tyfun of
	  ETA_TYFUN tyname => make_true tyname
      | NULL_TYFUN _ =>
	  r := true
      | TYFUN _ => Crash.impossible "Types.make_true"

    val _ = Stamp.reset_counter 0

      (* NOTE: if you're going to add a new tyname, put it at the end of
         the list.  This will ensure that the stamps of the old tynames
         will remain unchanged (and so avoid strange types like
         "bool char" for "bool list" in the decapsulation process.) *)

    val bool_tyname = make_tyname (0,true,"bool",NONE,0)
    val int_tyname = make_tyname (0,true,"int",NONE,0)
    val word_tyname = make_tyname (0,true,"word",NONE,0)
    val int8_tyname = make_tyname (0,true,"int8",NONE,0)
    val word8_tyname = make_tyname (0,true,"word8",NONE,0)
    val int16_tyname = make_tyname (0,true,"int16",NONE,0)
    val word16_tyname = make_tyname (0,true,"word16",NONE,0)
    val int32_tyname = make_tyname (0,true,"int32",NONE,0)
    val word32_tyname = make_tyname (0,true,"word32",NONE,0)
    val int64_tyname = make_tyname (0,true,"int64",NONE,0)
    val word64_tyname = make_tyname (0,true,"word64",NONE,0)
    val real_tyname = make_tyname (0,false,"real",NONE,0)
    val float32_tyname = make_tyname (0,true,"float32",NONE,0)
    val string_tyname = make_tyname (0,true,"string",NONE,0)
    val char_tyname = make_tyname (0,true,"char",NONE,0)
    val list_tyname = make_tyname (1,true,"list",NONE,0)
    val ref_tyname = make_tyname (1,true,"ref",NONE,0)
    val exn_tyname = make_tyname (0,false,"exn",NONE,0)
    val ml_value_tyname = make_tyname (0,true,"ml_value",NONE,0)
    val array_tyname = make_tyname (1,true,"array",NONE, 0)
    val vector_tyname = make_tyname (1,true,"vector",NONE, 0)
    val bytearray_tyname = make_tyname (0,true,"bytearray", NONE, 0)
    val dynamic_tyname = make_tyname (0,false,"dynamic",NONE,0)
    val typerep_tyname = make_tyname (0,false,"type_rep",NONE,0)
    val floatarray_tyname = make_tyname (0,true,"floatarray", NONE, 0)

      (* it is important that the following is exactly the reference
         to the equality attribute reference in real_tyname: we don't
         just want its value:  we want to share this reference with
         the oldDefinition option, so that whenever we set one, we
         "set the other" automatically. *)

    val real_tyname_equality_attribute =
      let
        val eqRef = (fn (TYNAME(_,_,_,eqRef,_,_,_,_,_)) => eqRef
                      | _ => Crash.impossible
                          "types: accessing real tyname attribute") real_tyname
      in
        eqRef
      end


    fun tyname_sizeof (TYNAME {2 = "int8", ...}) = SOME 8
    |   tyname_sizeof (TYNAME {2 = "word8", ...}) = SOME 8
    |   tyname_sizeof (TYNAME {2 = "int16", ...}) = SOME 16
    |   tyname_sizeof (TYNAME {2 = "word16", ...}) = SOME 16
    |   tyname_sizeof (TYNAME {2 = "int32", ...}) = SOME 32
    |   tyname_sizeof (TYNAME {2 = "word32", ...}) = SOME 32
    |   tyname_sizeof (TYNAME {2 = "int64", ...}) = SOME 64
    |   tyname_sizeof (TYNAME {2 = "word64", ...}) = SOME 64
    |   tyname_sizeof (TYNAME {2 = "float32", ...}) = SOME 32
    |   tyname_sizeof _ = NONE

    val pervasive_stamp_count = Stamp.read_counter ()

    (****
     For determining the constructors associated with a Constype.
     ****)

    fun tyname_conenv (TYNAME {5 = ref conenv,...}) = conenv
    | tyname_conenv (METATYNAME _) = 
      Crash.impossible "Types.tyname_conenv METATYNAME"

    (****
     NullTyfun is raised by the function apply. This function 
     is never applied in other functors before doing the necessary tests 
     to determine whether the function they are applied to is NULL_TYFUN.
     Thus NullTyfun is not in the signature matching this functor.
     ****)

    exception NullTyfun
    exception WrongArity

    val int_type = CONSTYPE ([],int_tyname)
    val word_type = CONSTYPE ([],word_tyname)
    val int8_type = CONSTYPE ([],int8_tyname)
    val word8_type = CONSTYPE ([],word8_tyname)
    val int16_type = CONSTYPE ([],int16_tyname)
    val word16_type = CONSTYPE ([],word16_tyname)
    val int32_type = CONSTYPE ([],int32_tyname)
    val word32_type = CONSTYPE ([],word32_tyname)
    val int64_type = CONSTYPE ([],int64_tyname)
    val word64_type = CONSTYPE ([],word64_tyname)
    val real_type =  CONSTYPE ([],real_tyname)
    val float32_type =  CONSTYPE ([],float32_tyname)
    val string_type = CONSTYPE ([],string_tyname)
    val char_type = CONSTYPE ([],char_tyname)
    val bool_type = CONSTYPE ([],bool_tyname)
    val exn_type =  CONSTYPE ([],exn_tyname)
    val ml_value_type = CONSTYPE ([],ml_value_tyname)
    val dynamic_type = CONSTYPE ([],dynamic_tyname) 
    val typerep_type = CONSTYPE ([],typerep_tyname)

    (* Return the size of a numeric SCON *)

    fun sizeof (CONSTYPE ([],tyname)) = tyname_sizeof tyname
    |   sizeof (META_OVERLOADED (ref ty, _, _, _)) = sizeof ty
    |   sizeof _ = NONE


    (* Return the type of a SCON *)

    fun type_of (Ident.INT (_, loc)) =
	  META_OVERLOADED
	    (ref NULLTYPE, Ident.int_literal_tyvar,
	     Ident.VAR (Ident.Symbol.find_symbol ""),
	     loc)
      | type_of (Ident.REAL (_, loc)) =
	  META_OVERLOADED
	    (ref NULLTYPE, Ident.real_literal_tyvar,
	     Ident.VAR (Ident.Symbol.find_symbol ""),
	     loc)
      | type_of (Ident.STRING _) = string_type
      | type_of(Ident.CHAR _) = char_type
      | type_of(Ident.WORD (_, loc)) =
	  META_OVERLOADED
	    (ref NULLTYPE, Ident.word_literal_tyvar,
	     Ident.VAR (Ident.Symbol.find_symbol ""),
	     loc)

    fun cons_typep (CONSTYPE _) = true
      | cons_typep _ = false 

    (****
     the_type determines the type that a flexible type has been instantiated
     to; or if it is uninstantiated the flexible type itself.
     ****)

    fun the_type (atype as (METATYVAR (ref (_,NULLTYPE,_),_,_))) = atype
      | the_type (METATYVAR (ref (_,atype,_),_,_)) = the_type atype
      | the_type (atype as (META_OVERLOADED {1=ref NULLTYPE,...})) = atype
      | the_type (META_OVERLOADED {1=ref atype,...}) = the_type atype
      | the_type (METARECTYPE (ref (_,true,atype as METARECTYPE _,_,_))) = the_type atype
      | the_type (atype as METARECTYPE (ref (_,true,_,_,_))) = atype
      | the_type (METARECTYPE (ref (_,false,atype,_,_))) = atype
      | the_type (atype) = atype

    fun check_debruijns([], _) = true
      | check_debruijns(DEBRUIJN(n, _, _,_) :: t, n') =
	n = n' andalso check_debruijns(t, n+1)
      | check_debruijns _ = false

    fun valid_to_string (Ident.VAR(sym)) = Ident.Symbol.symbol_name(sym)
      | valid_to_string (Ident.CON(sym)) = Ident.Symbol.symbol_name(sym)
      | valid_to_string (Ident.EXCON(sym)) = Ident.Symbol.symbol_name(sym)
      | valid_to_string _ = Crash.impossible "valid_to_string:types"

    fun tyfun_strip(ETA_TYFUN (METATYNAME {1=ref tyfun, ...})) 
                                                = tyfun_strip tyfun
      | tyfun_strip(TYFUN (ty, i)) =
        (case simplify_type ty of
           ty' as CONSTYPE (types, tyname) => 
             if tyname_arity tyname = i andalso check_debruijns(types, 0) 
               then
                 (case tyname of
                    METATYNAME{1=ref tyfun, ...} => tyfun_strip tyfun
                  | tyname => ETA_TYFUN tyname)
             else TYFUN (ty',i)
                  | ty' => TYFUN (ty',i))
      | tyfun_strip tyfun = tyfun
        
    and tyname_strip (METATYNAME{1=ref(ETA_TYFUN tyname), ...}) = tyname_strip tyname
      | tyname_strip(tyname as METATYNAME{1=ref(TYFUN(CONSTYPE(types, tyname'), i)), ...})=
	if tyname_arity tyname = i andalso check_debruijns(types, 0) 
          then tyname_strip tyname'
	else tyname
      | tyname_strip tyname = tyname
 
    and has_ref_equality tyname =
      tyname_eq(ref_tyname, tyname) orelse
      tyname_eq(array_tyname, tyname) orelse
      tyname_eq(bytearray_tyname, tyname) orelse
      tyname_eq(floatarray_tyname, tyname)

    and has_int_equality tyname =
      tyname_eq(tyname, int_tyname) orelse
      tyname_eq(tyname, int8_tyname) orelse
      tyname_eq(tyname, int16_tyname) orelse
      tyname_eq(tyname, char_tyname) orelse
      tyname_eq(tyname, word8_tyname) orelse
      tyname_eq(tyname, word16_tyname) orelse
      tyname_eq(tyname, word_tyname)

    and has_real_equality tyname =
      (tyname_eq(tyname, real_tyname) orelse
       tyname_eq(tyname, float32_tyname))

    and has_string_equality tyname =
      tyname_eq(tyname, string_tyname) orelse
      tyname_eq(tyname, int64_tyname) orelse
      tyname_eq(tyname, word64_tyname)

    and has_int32_equality tyname =
      tyname_eq(tyname, int32_tyname) orelse
      tyname_eq(tyname, word32_tyname)

    (* We might be able to use this instead of type_strip *)
    (* Currently used for type printing *)
        
    and simplify_type (ty as METATYVAR(ref(_, ty',_), _, _)) =
      (case ty' of
	 NULLTYPE => ty
       | _ => simplify_type ty')
      | simplify_type(ty as META_OVERLOADED {1=ref ty',...}) =
	(case ty' of
	   NULLTYPE => ty
	 | _ => simplify_type ty')
      | simplify_type (METARECTYPE (ref (i,b1,ty,eq,imp))) =
        if b1 then simplify_type ty
        (* We could update the ref here *)
        else METARECTYPE (ref (i,b1,simplify_type ty,eq,imp))
      | simplify_type (RECTYPE map) =
        RECTYPE (NewMap.map simplify_type_map map)
      | simplify_type (FUNTYPE (ty1,ty2)) =
        FUNTYPE (simplify_type ty1,simplify_type ty2)
      | simplify_type(ty as CONSTYPE(l, METATYNAME{1 = ref tyfun, ...})) =
	(case tyfun of
	   NULL_TYFUN _ => ty
	 | _ => simplify_type(apply (tyfun, l)))
      | simplify_type ty = ty

    and simplify_type_map(_, ty) = simplify_type ty

    and type_strip(ty as METATYVAR(ref(_, ty',_), _, _)) =
      (case ty' of
	 NULLTYPE => ty
       | _ => type_strip ty')
      | type_strip(ty as META_OVERLOADED {1=ref ty',...}) =
	(case ty' of
	   NULLTYPE => ty
	 | _ => type_strip ty')
      (* Should this leave uninstantiated metarecs alone? *)
      | type_strip(METARECTYPE(ref{3 = ty, ...})) = type_strip ty
      | type_strip(ty as CONSTYPE(l, METATYNAME{1 = ref tyfun, ...})) =
	(case tyfun of
	   NULL_TYFUN _ => ty
	 | _ => type_strip(apply (tyfun, l)))
      | type_strip ty = ty

    (****
     type_equalityp determines the equality attribute of a type.
     ****)

    and type_equalityp (TYVAR (_,Ident.TYVAR (_,eq,_))) = eq
      | type_equalityp (METATYVAR (ref (_,NULLTYPE,_),eq,_)) = eq
      | type_equalityp (METATYVAR (ref (_,t,_),_,_)) = type_equalityp t
      | type_equalityp (META_OVERLOADED _) = true
      | type_equalityp (METARECTYPE (ref (_,_,t,_,_))) = type_equalityp t
      | type_equalityp (CONSTYPE ([],n)) = eq_attrib n
      | type_equalityp (CONSTYPE (tylist as h::t,n)) =
	has_ref_equality n
	orelse
	((eq_attrib n) andalso (List.all type_equalityp tylist))
      | type_equalityp (RECTYPE amap) = NewMap.forall type_equalityp_forall amap
      | type_equalityp (FUNTYPE _) = false
      | type_equalityp (DEBRUIJN _) = true
      | type_equalityp NULLTYPE = true
  
    and type_equalityp_forall(_, ty) = type_equalityp ty

    (* exactly the same as above, but eq attribs of debruijns are noticed *)
    and closed_type_equalityp (TYVAR (_,Ident.TYVAR (_,eq,_))) = eq
      | closed_type_equalityp (METATYVAR (ref (_,NULLTYPE,_),eq,_)) = eq
      | closed_type_equalityp (METATYVAR (ref (_,t,_),_,_)) = closed_type_equalityp t
      | closed_type_equalityp (META_OVERLOADED _) = true
      | closed_type_equalityp (METARECTYPE (ref (_,_,t,_,_))) = closed_type_equalityp t
      | closed_type_equalityp (CONSTYPE ([],n)) = eq_attrib n
      | closed_type_equalityp (CONSTYPE (tylist as h::t,n)) =
	has_ref_equality n
	orelse
	((eq_attrib n) andalso (List.all closed_type_equalityp tylist))
      | closed_type_equalityp (RECTYPE amap) =
	NewMap.forall closed_type_equalityp_forall amap
      | closed_type_equalityp (FUNTYPE _) = false
      | closed_type_equalityp (DEBRUIJN (_,eq,_,_)) = eq
      | closed_type_equalityp NULLTYPE = true
  
    and closed_type_equalityp_forall(_, ty) = closed_type_equalityp ty

    and eq_attrib (TYNAME (_,_,_,ref eq,_,_,_,_,_)) = eq
      | eq_attrib (METATYNAME (ref (NULL_TYFUN _),_,_,ref eq,_,_)) = eq
      | eq_attrib (METATYNAME (ref tyfun,_,_,_,_,_)) = equalityp tyfun

    and equalityp (TYFUN (atype,a)) = type_equalityp atype
      | equalityp (ETA_TYFUN (tyname)) = eq_attrib tyname
      | equalityp (NULL_TYFUN (_)) = false

    (* Equality between types *)

    and tyfun_eq(tyfun, tyfun') =
      let
        val tyfun = tyfun_strip tyfun
        val tyfun' = tyfun_strip tyfun'
      in
        (* MLWorks.IO.output (MLWorks.IO.std_out, string_tyfun tyfun ^ "&" ^ string_tyfun tyfun' ^ "\n"); *)
        tyfun_eq' (tyfun,tyfun')
      end

    and tyfun_eq' (t as TYFUN (atype,a),t' as TYFUN (atype',a')) =
      (a = a' andalso type_eq (atype,atype',false,false))
      | tyfun_eq' (t as ETA_TYFUN(tyname as TYNAME{1=tyname_id, ...}),
		   t' as ETA_TYFUN(tyname' as TYNAME{1=tyname_id', ...})) = 
        Stamp.stamp_eq(tyname_id, tyname_id')
      | tyfun_eq' (t as NULL_TYFUN (id,_),t' as NULL_TYFUN (id',_)) = id = id'
      | tyfun_eq' (tyfun,tyfun') = false

    and tyname_eq(tyname, tyname') =
      tyname_eq'(tyname_strip tyname, tyname_strip tyname')

    and tyname_eq' (t as TYNAME (id,_,_,_,_,_,_,_,_),
                    t' as TYNAME (id',_,_,_,_,_,_,_,_)) =
      (*Stamp.stamp_eq (id,id')*) id = id'

      | tyname_eq' (t as METATYNAME{1=ref tyfun, 3=arity, 4=eq, ...},
		   t' as METATYNAME{1=ref tyfun', 3=arity', 4=eq', ...}) = 
        tyfun_eq (tyfun,tyfun')
      | tyname_eq' (t,t') = 
        false

    and type_eq' (t as TYVAR (_,Ident.TYVAR (sym,eq,imp)),
		 t' as TYVAR (_,Ident.TYVAR (sym',eq',imp')),
		 eq_matters,imp_matters) =
      (sym = sym') 
      andalso
      (if eq_matters then eq = eq' else true)
      andalso
      (if imp_matters then imp = imp' else true)
      | type_eq' (t as FUNTYPE(ty1,ty2),t' as FUNTYPE(ty1',ty2'),
                 eq_matters,imp_matters) = 
        type_eq (ty1,ty1',eq_matters,imp_matters)
        andalso
        type_eq (ty2,ty2',eq_matters,imp_matters)
      | type_eq' (t as CONSTYPE(l,name as METATYNAME{1=ref (NULL_TYFUN _),...}),
                 t' as CONSTYPE(l',name' as METATYNAME{1=ref (NULL_TYFUN _),
                                                      ...}),
		 eq_matters,imp_matters) =
        let
          fun collect ([],[]) = true
            | collect ([],h::t) = false
            | collect (h::t,[]) = false
            | collect (h::t,h'::t') = 
              type_eq (h,h',eq_matters,imp_matters) andalso collect (t,t')
        in
          tyname_eq (name,name') andalso collect (l,l')
        end
      | type_eq' (t as CONSTYPE (tylist,name as METATYNAME 
			        {1=ref(NULL_TYFUN _), ...}),
		 t' as CONSTYPE (tylist',name'),
		 eq_matters,imp_matters) =
	let 
	  fun collect ([],[]) = true
	    | collect ([],h::t) = false
	    | collect (h::t,[]) = false
	    | collect (h::t,h'::t') = 
	      (type_eq (h,h',eq_matters,imp_matters)) andalso (collect (t,t'))
	in
	  (tyname_eq (name,name')) andalso (collect (tylist,tylist'))
	end
      | type_eq' (t as CONSTYPE (tylist,name),
		 t' as CONSTYPE (tylist',
			         name' as METATYNAME{1=ref(NULL_TYFUN _),...}),
		 eq_matters,imp_matters) =
	let 
	  fun collect ([],[]) = true
	    | collect ([],h::t) = false
	    | collect (h::t,[]) = false
	    | collect (h::t,h'::t') = 
	      (type_eq (h,h',eq_matters,imp_matters)) andalso (collect (t,t'))
	in
	  (tyname_eq (name,name')) andalso (collect (tylist,tylist'))
	end
      | type_eq' (t as CONSTYPE ([],tyname),t' as CONSTYPE ([],tyname'),_,_) =
	tyname_eq (tyname,tyname')
      | type_eq' (ty as CONSTYPE (tylist as h::t,tyname),
		 ty' as CONSTYPE (tylist' as h'::t',tyname'),
		 eq_matters,imp_matters) = 
	let 
	  fun collect ([],[]) = true
	    | collect ([],h::t) = false
	    | collect (h::t,[]) = false
	    | collect (h::t,h'::t') = 
	      (type_eq (h,h',eq_matters,imp_matters)) andalso (collect (t,t'))
	in
	  (tyname_eq (tyname,tyname')) andalso (collect (tylist,tylist'))
	end
      | type_eq' (t as RECTYPE amap,t' as RECTYPE amap',eq_matters,imp_matters)=
	NewMap.eq (fn (x,y) => type_eq (x,y,eq_matters,imp_matters)) (amap, amap')
      | type_eq' (t as DEBRUIJN (d,eq,imp,_),t' as DEBRUIJN (d',eq',imp',_),
		 eq_matters,imp_matters) =
	d = d'
	andalso
	if eq_matters then eq = eq' else true
	andalso
	if imp_matters then imp = imp' else true
      | type_eq' (NULLTYPE,NULLTYPE,_,_) = true
      | type_eq' (METATYVAR (t as ref (_,NULLTYPE,_),_,_),
		  METATYVAR (t' as ref (_,NULLTYPE,_),_,_),_,_) = 
	(t = t')
      | type_eq' (META_OVERLOADED {1 = t as ref NULLTYPE,...}, 
		  META_OVERLOADED {1 = t' as ref NULLTYPE,...},_,_) = 
	(t = t')
      | type_eq' (ty,ty',_,_) = 
	false

    and type_eq(ty, ty', eq_matters, imp_matters) =
      let
	val ty = type_strip ty
	val ty' = type_strip ty'
      in
	type_eq'(ty, ty', eq_matters, imp_matters)
      end

    (* Printing functions *)
    and string_tyfun (TYFUN (aty,n)) = 
      concat ["LAMBDA{", Int.toString n, "}.", extra_debug_print_type aty]
      | string_tyfun (ETA_TYFUN aname) = 
	concat ["ETA{", Int.toString (tyname_arity aname), "}.", debug_print_name aname]
      | string_tyfun (NULL_TYFUN (id,_)) = 
	concat ["NULL_TYFUN", Stamp.string_stamp id]

    and print_name' show_eq_info
                    (tyname as TYNAME (stamp,name,_,ref eq,_,_,_,_,_)) =
      let
        val real_name =
	  (*
          if tyname_eq (tyname,bool_tyname) then "bool"
          else if tyname_eq (tyname,real_tyname) then "real"
          else if tyname_eq (tyname,int_tyname) then "int"
          else if tyname_eq (tyname,string_tyname) then "string"
          else if tyname_eq (tyname,exn_tyname) then "exn"
          else *) name
      in
	real_name ^ 
        (if show_eq_info then
           if eq then "[t]" else "[f]"
         else "") 
      end
      | print_name' show_eq_info
                    (METATYNAME (ref (NULL_TYFUN id),name,_,ref eq,_,_)) = 
        name ^ (if show_eq_info then
                  if eq then "[t]" else "[f]"
                else "")
      | print_name' show_eq_info (METATYNAME (ref tyfun,name,_,_,_,_)) =
        name ^ (if show_eq_info then
                  if equalityp tyfun then "[t]" else "[f]"
                else "")
	   
    and print_name options t = 
      let val Options.OPTIONS{print_options=Options.PRINTOPTIONS
                              {show_eq_info,...},...}=options
        in
          print_name' show_eq_info t
      end

    and debug_print_ve (ve as ref(VE(_,map))) =
      if generate_moduler_debug then
        "VE%" ^
        NewMap.fold 
        (fn (str,v,t) => 
         str^"\n" ^ valid_to_string v ^ ":" ^
         (case t of
            SCHEME (_,(t,_))=>"SCHEME:" ^ extra_debug_print_type t
          | UNBOUND_SCHEME (t,_)=>"UNBOUND_SCHEME:" ^ extra_debug_print_type t
          | OVERLOADED_SCHEME _ => "OVERLOADED_SCHEME"))
        ("",map) ^
        "]"
      else ""
        
    (* A more verbose tyname printer *)
    and debug_print_name (TYNAME (id,name,_,ref eq,ve,location,_,_,_)) =
      "TYNAME" ^ Stamp.string_stamp id ^ "(" ^ name ^ ")" ^
      (if eq then "[t]" else "[f]") ^ debug_print_ve ve
      | debug_print_name (METATYNAME (tf as ref (NULL_TYFUN (id,_)),name,_,ref eq,ve,_)) = 
        "METATYNAME" ^  Stamp.string_stamp id ^ "(" ^ name ^ ")" ^ (if eq then "[t]" else "[f]") ^
        debug_print_ve (ve)
      | debug_print_name (METATYNAME (ref tyfun,name,_,_,ve,_)) =
	"METATYNAME{" ^ string_tyfun tyfun ^ "}" ^ "(" ^ name ^ ")" ^ debug_print_ve ve
	   
    and make_string n =
      let 
	val rep =  (n-1) div 26
	val char_no = 97 + ((n-1) mod 26)
	fun rep_chars (~1,c,s) = s
	    | rep_chars (rep,c,s) = rep_chars (rep-1,c,c^s)
      in
	rep_chars (rep,(str o chr) char_no,"")
      end
	
    and find_depth (_,0,[]) = 0
      | find_depth (t,n,t'::ts') = if type_eq (t,t',true,true)
				     then
				       n
				   else
				     find_depth (t,n-1,ts')
      | find_depth (_,_,_) = Crash.impossible "Types.find_depth" 
	
    and string_metatyvar (options,t as (METATYVAR (_,eq,imp)),depth,metastack)=
      let 
        val Options.OPTIONS{compat_options=
                            Options.COMPATOPTIONS{old_definition,...},...}=
          options
	val how_deep = find_depth (t,depth,metastack)
	val meta_str = if do_debug then "meta-" else ""
	val (alpha,new_depth,new_metas) = 
	  if how_deep = 0
	    then
	      (meta_str ^ (make_string (depth+1)),depth+1,t::metastack)
	  else
	    (meta_str ^ (make_string how_deep),depth,metastack)
	val eq_bit = if eq then "'" else ""
	val imp_bit = if imp andalso old_definition then "_" else ""
      in
	("'"^ eq_bit ^ imp_bit ^ alpha,new_depth,new_metas)
      end 
      | string_metatyvar (_,depth,metastack,_) =
	Crash.impossible "Types.string_metatyvar"    
	  
    and string_debruijn (options,depth,eq,imp) =
      let
        val Options.OPTIONS{compat_options=
                            Options.COMPATOPTIONS{old_definition,...},...}=
          options
      in
        "'" ^ (if eq then "'" else "") ^ 
        (if imp andalso old_definition then "_" else "") ^
        (if do_debug then "deb-" else "") ^ make_string (depth+1)
      end
    
    and string_constype (options,t as (CONSTYPE ([],name)),depth,stack,
                         acc_string,_) = 
      if acc_string = "" then
	(print_name options name,depth,stack)
      else
	("(" ^ acc_string ^ ")" ^ (print_name options name),depth,stack)

      |  string_constype (options,CONSTYPE ([h],name),depth,stack,
                          acc_string,extras) =
	  let 
	    val (s,depth,stack) = string_types (options,h,depth,stack,extras)
	  in
	    if acc_string = ""
              then 
                if is_a_function_type h
                  then
                    (concat ["(",s,") ",print_name options name],depth,stack)
                else
                  (concat [s," ",print_name options name],depth,stack)
	    else
	      (concat ["(", acc_string, ", ", s, ") ", 
                        print_name options name],
	       depth,stack)
	  end

	| string_constype (options,CONSTYPE (h::t,name),depth,stack,
                           acc_string,extras) =
	  let 
	    val (s,depth,stack) = string_types (options,h,depth,stack,extras)
	  in
	    if acc_string = "" then 
	      string_constype (options,CONSTYPE (t, name),depth,stack,s,extras)
	    else
	      string_constype (options,CONSTYPE (t,name),
			       depth,stack,acc_string ^ ", " ^ s,extras)
	  end
      | string_constype _ = Crash.impossible "Types.string_constype"
	
    and is_a_function_type (FUNTYPE _) = true
      | is_a_function_type (METATYVAR 
                            (ref (_,NULLTYPE,_),_,_)) = false
      | is_a_function_type (METATYVAR (ref (_,ty,_),_,_)) = 
        is_a_function_type ty
      | is_a_function_type _ = false

    and is_a_record_type (RECTYPE _) = true
      | is_a_record_type _ = false

    and string_rectype (options,amap,flexible,depth,stack,extras) =
	let
          val Options.OPTIONS
            {print_options=Options.PRINTOPTIONS{show_eq_info,...},...}=options
	  val stack_ref = ref stack
	  val depth_ref = ref depth
	  fun print_member t =
	    let 
	      val (s,new_depth,new_stack) =
		string_types(options,t,!depth_ref,!stack_ref,extras)
	    in
	      (stack_ref := new_stack;
	       depth_ref := new_depth;
	       s)
	    end
	  val len = NewMap.size amap
	  val is_a_tuple =
            not flexible andalso
	    let
	      fun check_elem 0 = true
		| check_elem n =
		  case NewMap.tryApply'(amap, Ident.LAB(Ident.Symbol.find_symbol
							(Int.toString
							 n))) of
		    NONE => false
		  | _ => check_elem(n-1)
	    in
	      len > 1 andalso check_elem len
	    end
	  fun print_as_a_tuple acc 0 = acc
	    | print_as_a_tuple acc n = 
	      let 
		val element_type =
		  NewMap.apply'(amap, Ident.LAB (Ident.Symbol.find_symbol
						 (Int.toString n)))
		val element_string =
		  if is_a_function_type element_type then
		    "(" ^ print_member element_type ^ ")"
		  else print_member element_type
	      in 
		if n = 1 then (element_string :: acc) else
		  print_as_a_tuple (" * " :: element_string :: acc) (n-1)
	      end
	in
	  if len = 0 then
	    (* for the empty tuple, "()" is wrong.  "unit" can be
	     * redefined, but it's what people usually expect to see. *)
            if show_eq_info then ("unit[t]",depth, stack)
	    else ("unit",depth,stack)
	  else
	    if is_a_tuple then 
	      (concat ("(" :: (print_as_a_tuple [")"] len)),
	       !depth_ref, !stack_ref)
	    else
	      (* not a tuple, so print labels *)
	      let
		val named_list =
		  map
		  (fn (lab,ty) => concat [IdentPrint.printLab lab,
					   ": ", print_member ty])
		  (NewMap.to_list_ordered amap)
		fun commas (_,[]) = 
		  Crash.impossible "Types.string_type.commas passed nil.\n"
		  | commas (acc,l as [x]) = rev ((if flexible then ", ...}" else "}")::x::acc)
		  | commas (acc,x::(xs as (y::ys))) =
		    commas (", "::x::acc, xs)
		val list_with_commas = commas (["{"],named_list)
	      in
		(concat list_with_commas,!depth_ref,!stack_ref)
	      end
	end
      
    and string_types (options,t as (METATYVAR (ref(_,NULLTYPE,_),_,_)),depth,stack,_) =
      string_metatyvar (options,t,depth,stack)
      | string_types (options,METATYVAR (ref(_,t,_),_,_),depth,stack,extras)=
	string_types (options,t,depth,stack,extras)
      | string_types (options,META_OVERLOADED (ref NULLTYPE, tv, _, _),
                      depth,stack,extras) =
	((IdentPrint.printTyVar tv),depth,stack)
      | string_types (options,META_OVERLOADED {1=ref t,...},depth,stack,
                      extras) =
	string_types (options,t,depth,stack,extras)
      | string_types (options,METARECTYPE (ref (_,true,t as METARECTYPE _,_,_)), depth,stack,extras) =
	string_types (options,t,depth,stack,extras)
      | string_types (options,METARECTYPE (ref (_,true,RECTYPE amap,_,_)),depth,stack,extras) =
	string_rectype (options,amap,true,depth,stack,extras)
      | string_types (options,METARECTYPE (ref (_,true,_,_,_)),depth,stack,
                      extras) =
        Crash.impossible "Types.string_types: bad METARECTYPE"
      | string_types (options,METARECTYPE (ref(_,false,t,_,_)),depth,stack,
                      extras) =
	string_types (options,t,depth,stack,extras)
      | string_types (options,DEBRUIJN (n,n',n'',_),depth,stack,_)=
	(string_debruijn (options,n,n',n''),depth,stack)
      | string_types (options,TYVAR (_,t),depth,stack,_) =
	((IdentPrint.printTyVar t),depth,stack)
      | string_types (options,NULLTYPE,depth,stack,_) = 
        ("Nulltype ",depth,stack)
      | string_types (options,FUNTYPE (a,r),depth,stack,extras)=
	let
	  val (s,d,m) = string_types (options,a,depth,stack,extras)
	  val (s',d',m') = string_types (options,r,d,m,extras)
	in
	  ((if is_a_function_type a
	      then "(" ^ s ^ ")"
	    else s)
	      ^ " -> " ^ s',d',m')
	end
      | string_types (options,t as (CONSTYPE (_,_)),depth,stack,extras)=
	string_constype (options,t,depth,stack,"",extras)
      | string_types (options,RECTYPE amap,depth,stack,extras)=
        string_rectype (options,amap,false,depth,stack,extras)

    and print_type options t =
      #1 (string_types (options,t,0,[],""))
                        

    and debug_print_type options t
                  = #1 (string_types (options,t,0,[],""))

      (****
       When applying type functions the argument types must be substituted for
       the debruijns.  Previously debruijns were substituted for type 
       variables when type functions were made.  See the function 
       make_tyfun.
       ****)

    and app_subst (DEBRUIJN (d,_,_,_),array_of_types) =
      MLWorks.Internal.Array.sub (array_of_types,d)
      | app_subst (RECTYPE (amap),array_of_types) =
	RECTYPE(NewMap.map (fn (_, x) => app_subst (x,array_of_types)) amap)
      | app_subst (FUNTYPE (atype,atype'),array_of_types) =
	FUNTYPE (app_subst (atype,array_of_types),
		 app_subst (atype',array_of_types))
      | app_subst (CONSTYPE (atylist,atyname),array_of_types) =
	let
	  val new_ty_list =
	    map (fn x => app_subst (x,array_of_types)) atylist
	in
	  case atyname of
	    TYNAME _ => CONSTYPE(new_ty_list, atyname)
	  | METATYNAME{1=ref(NULL_TYFUN _), ...} =>
	      CONSTYPE(new_ty_list, atyname)
	  | METATYNAME{1=ref tyfun, ...} =>
	      apply(tyfun, new_ty_list)
	end
      | app_subst (NULLTYPE,array_of_types) = NULLTYPE 
      (* for signature matching in funbinds *)
      | app_subst (ty as METATYVAR (ref (_,NULLTYPE,_),_,_),array_of_types) =
	ty
      | app_subst (METATYVAR (ref (_,ty,_),_,_),array_of_types) = 
	app_subst (ty,array_of_types)
      | app_subst (ty as META_OVERLOADED{1=ref ty',...}, array_of_types) =
	(case ty' of
	   NULLTYPE => ty
	 | _ => app_subst(ty', array_of_types))
      | app_subst (ty as METARECTYPE _,_) = ty
      | app_subst (ty as TYVAR _,_) = ty

    and apply (TYFUN (atype,0),[]) = atype
      | apply (TYFUN (atype,arity),tylist) =
      if arity = length tylist
	then app_subst (atype,MLWorks.Internal.Array.arrayoflist (tylist))
      else raise WrongArity
      | apply (ETA_TYFUN (name as METATYNAME {1=ref (NULL_TYFUN _), ...}),
	       tylist) =
        CONSTYPE (tylist,name)
      | apply (ETA_TYFUN (METATYNAME {1=ref tyfun, ...}),tylist) =
	apply (tyfun,tylist)
      | apply (ETA_TYFUN (tyname),tylist) =
	CONSTYPE (tylist,tyname)
      | apply (NULL_TYFUN _,_) = raise NullTyfun


    and print_bool true = "true"
      | print_bool false = "false"

    and extra_debug_print_type(METATYVAR(ref (i, ty,_), b1, b2)) =
      "METATYVAR(ref(" ^ Int.toString i ^ ", " ^ extra_debug_print_type ty ^
      "), " ^ print_bool b1 ^ ", " ^ print_bool b2 ^ ")"
      | extra_debug_print_type(META_OVERLOADED(ref ty, tyvar, _, _)) =
	"META_OVERLOADED(ref " ^ extra_debug_print_type ty ^ ", " ^
	IdentPrint.printTyVar tyvar ^ ")"
      | extra_debug_print_type(TYVAR(ref (i,_,_), tyvar)) =
	"TYVAR(ref " ^ Int.toString i ^ ", " ^
	IdentPrint.printTyVar tyvar ^ ")"
      | extra_debug_print_type(METARECTYPE(ref(i, b1, ty, b2, b3))) =
	"METARECTYPE(ref(" ^ Int.toString i ^ ", " ^
	print_bool b1 ^ ", " ^ extra_debug_print_type ty ^ ", " ^ print_bool b2 ^
	", " ^ print_bool b3 ^ "))"
      | extra_debug_print_type(RECTYPE map) =
	NewMap.string
	IdentPrint.printLab
	extra_debug_print_type
	{start="RECTYPE(", domSep=", ", itemSep="", finish=")"}
	map
      | extra_debug_print_type(FUNTYPE(ty1, ty2)) =
	"FUNTYPE(" ^ extra_debug_print_type ty1 ^ ", " ^ extra_debug_print_type ty2 ^ ")"
      | extra_debug_print_type(CONSTYPE(ty_list, tyname)) =
	"CONSTYPE(" ^ concat(map extra_debug_print_type ty_list) ^ ", " ^
	debug_print_name tyname ^ ")"
      | extra_debug_print_type(DEBRUIJN(i, b1, b2,_)) =
	"DEBRUIJN(" ^ Int.toString i ^ ", " ^ print_bool b1 ^
	", " ^ print_bool b2 ^ ")"
      | extra_debug_print_type NULLTYPE = "NULLTYPE"

    (****
     Used in Realise to determine whether a tyname has been instantiated 
     before meta_tyname (tyfun) is called.
     ****)

    fun null_tyfunp(NULL_TYFUN _) = true
      | null_tyfunp(ETA_TYFUN(METATYNAME{1=ref tyfun, ...})) =
	null_tyfunp tyfun
      | null_tyfunp _ = false

    fun resolve_overloading
      (default_overloads, ty, error_fn) =
      let
        fun resolve_ty
              (META_OVERLOADED
	       (r as ref NULLTYPE, tv, valid, loc)) =
	  if default_overloads then
            if tv = Ident.int_literal_tyvar then
              (r := int_type)
            else if tv = Ident.real_tyvar orelse
	       tv = Ident.real_literal_tyvar then
              (r := real_type)
            else if tv = Ident.word_literal_tyvar then
              (r := word_type)
            else if tv = Ident.num_tyvar then
              (r := int_type)
            else if tv = Ident.numtext_tyvar then
              (r := int_type)
            else if tv = Ident.wordint_tyvar then
              (r := int_type)
            else if tv = Ident.realint_tyvar then
              (r := int_type)
            else
              ()
          else
	    if tv = Ident.int_literal_tyvar then
	      r := int_type
	    else if tv = Ident.real_literal_tyvar then
	      r := real_type
	    else if tv = Ident.word_literal_tyvar then
	      r := word_type
            else
	      error_fn (valid, loc)
	  | resolve_ty (META_OVERLOADED {1=ref ty,...}) =
	    resolve_ty ty
	  | resolve_ty (METATYVAR (ref (_,ty,_),_,_)) =
	    resolve_ty ty
	  | resolve_ty (METARECTYPE (ref (_,true,ty as METARECTYPE _,_,_))) =
	    resolve_ty ty
	  | resolve_ty (METARECTYPE (ref (_,_,ty,_,_))) =
	    resolve_ty ty
	  | resolve_ty (RECTYPE amap) =
	    (ignore(NewMap.map resolve_ty_map amap); ())
	  | resolve_ty (FUNTYPE(arg, res)) =
	    (resolve_ty arg;
	     resolve_ty res)
	  | resolve_ty (CONSTYPE (tylist, tyname)) =
	    app resolve_ty tylist
	  | resolve_ty ty = ()

	and resolve_ty_map(_, ty) = resolve_ty ty
      in
        resolve_ty ty
      end

    (****
     imperativep determine the imperative attribute of a type.
     ****)

    fun imperativep (TYVAR (_,Ident.TYVAR (_,_,imp))) = imp
      | imperativep (METATYVAR (ref (_,NULLTYPE,_),_,imp)) = imp
      | imperativep (METATYVAR (ref (_,t,_),_,_)) = imperativep t
      | imperativep (META_OVERLOADED _) = true
      | imperativep (METARECTYPE (ref (_,_,t,_,_))) = imperativep t
      | imperativep (CONSTYPE (tylist,METATYNAME{1=ref tyfun, ...})) =
	(imperativep (apply (tyfun,tylist)) handle NullTyfun => true)
      | imperativep (CONSTYPE ([],n)) = true
      | imperativep (CONSTYPE (tylist as h::t,n)) =
	  List.all imperativep tylist
      | imperativep (RECTYPE amap) = NewMap.forall imperativep_forall amap
      | imperativep (FUNTYPE (a,r)) = (imperativep a) andalso (imperativep r)
      | imperativep (DEBRUIJN (_,_,imp,_)) = imp 
      | imperativep NULLTYPE = true

    and imperativep_forall(_, ty) = imperativep ty

    fun get_type_from_lab' (lab,RECTYPE amap) = NewMap.apply' (amap, lab)
      | get_type_from_lab' (lab,METARECTYPE (ref(_,_,t,_,_))) =
	get_type_from_lab' (lab,t)
      | get_type_from_lab' (lab,_) = Crash.impossible "Types.get_type_from_lab"

    and get_type_from_lab (lab,atype) = 
      get_type_from_lab' (lab,atype)

    fun add_to_rectype (lab,value,RECTYPE(amap)) =
      RECTYPE(NewMap.define'(amap, (lab,value)))
      | add_to_rectype (lab,value,_) = Crash.impossible "Types.add_to_rectype"

    val empty_rectype = RECTYPE(NewMap.empty' Ident.lab_lt)
      
    fun rectype_domain (RECTYPE(amap)) =
      NewMap.domain amap
      | rectype_domain _ = Crash.impossible "Types.rectype_domain"

    fun rectype_range (RECTYPE(amap)) =
      NewMap.range amap
      | rectype_range _ = Crash.impossible "Types.rectype_range"

    fun make_tyvars n =
      let
        fun name n =
          if n < 26 then
            (str o chr) (ord #"a" + n)
          else
            (str o chr) (ord #"a" + (n mod 26)) ^ name (n div 26)

        fun make_tyvar n =
          TYVAR (ref (0,NULLTYPE,NO_INSTANCE), 
                 Ident.TYVAR (Ident.Symbol.find_symbol ("'" ^ name n),
                                                    true,
                                                    true))

        fun make_tyvars' (list, 0) = list
          | make_tyvars' (list, n) =
            make_tyvars' (make_tyvar (n-1) :: list, n-1)
      in
        make_tyvars' ([], n)
      end

    fun print_tyvars _ [] = ""
      | print_tyvars options [tyvar] =
                     debug_print_type options tyvar
      | print_tyvars options l =
        let 
          fun print_tyvars' options [] = [")"]
            | print_tyvars' options [tyvar] =
              [debug_print_type options tyvar ,")"]
            | print_tyvars' options (tyvar::tyvars) =
              debug_print_type options tyvar
                   :: ", " :: (print_tyvars' options tyvars)
        in
          concat ("(" :: print_tyvars' options l)
        end

    local
	  
      (****
       In making a type function debruijns are used as place holders for type
       variables.
       ****)

      fun make_substlist ([],n,list_acc) = list_acc
	| make_substlist (h::t,n,list_acc) =
	  let
	    val new_debruijn = DEBRUIJN (n,true,true,NONE) (* arbitrary choice *)
	  in
	    make_substlist (t,n+1,(h,new_debruijn)::list_acc)
	  end
	
      fun subst (_,[]) = Crash.impossible "Types.subst 1"
	| subst (atyvar as TYVAR (_,Ident.TYVAR (id,eq,imp)),
		 (Ident.TYVAR (id',eq',imp'),adebruijn)::t) =
	  if id = id'
	    then 
	      adebruijn
	  else
	    subst (atyvar,t)
	| subst (_,_) = Crash.impossible "Types.subst 2"
	  
      fun make_new_type (tyvar as TYVAR (_,atyvar),substlist) =
	subst (tyvar,substlist)
	| make_new_type (RECTYPE (amap),substlist) =
	  RECTYPE (NewMap.map (fn (_, x) => 
                               make_new_type (x,substlist)) amap)
	| make_new_type (FUNTYPE (atype,atype'),substlist) =
	  FUNTYPE (make_new_type (atype,substlist),
		   make_new_type (atype',substlist))
	| make_new_type (CONSTYPE (atylist,atyname),substlist) =
	  CONSTYPE (map
		    (fn x => make_new_type (x,substlist))
		    atylist,atyname)
	| make_new_type (NULLTYPE,substlist) = NULLTYPE 
	| make_new_type (ty as METATYVAR _, _) = ty
	| make_new_type (ty, substlist) =
	  Crash.impossible("Types.make_new_type with type = " ^
			   debug_print_type Options.default_options ty ^ "\n")
            (* use default_options because this error should never occur *)
	  
    in
      
      fun make_tyfun ([],atype) = TYFUN (atype,0)
	| make_tyfun (tyvarlist,atype) =
	  let
	    val substlist = make_substlist (tyvarlist,0,[])
	  in 
	    TYFUN (make_new_type (atype,substlist),
                   length tyvarlist)
	  end
    end
  
    (****
     eta-convertible type function
     ****)

    fun make_eta_tyfun (tyname) = ETA_TYFUN (tyname)

    (****
     Follow the pointers to the last uninstantiated METATYNAME.
     ****)
    fun meta_tyname(ETA_TYFUN(meta as METATYNAME{1=ref(NULL_TYFUN _),
						 ...})) = meta
      | meta_tyname(ETA_TYFUN(METATYNAME{1=ref tyfun, ...})) =
	meta_tyname tyfun
      | meta_tyname _ = Crash.impossible "Types.meta_tyname"

    fun arity (TYFUN (atype,a)) = a
      | arity (ETA_TYFUN (t)) = tyname_arity t 
      | arity (NULL_TYFUN (_)) = 0
	
    fun int_typep (CONSTYPE ([],name)) =
      tyname_eq(name,int_tyname) orelse
      tyname_eq(name,int8_tyname) orelse
      tyname_eq(name,int16_tyname) orelse
      tyname_eq(name,int32_tyname) orelse
      tyname_eq(name,int64_tyname)
      | int_typep (META_OVERLOADED {1=ref t,...}) = int_typep t
      | int_typep _ = false

    fun real_typep (CONSTYPE ([],name)) =
      tyname_eq(name,real_tyname) orelse
      tyname_eq(name,float32_tyname)
      | real_typep (META_OVERLOADED {1=ref t,...}) = real_typep t
      | real_typep _ = false

    fun word_typep (CONSTYPE ([],name)) =
      tyname_eq(name,word_tyname) orelse
      tyname_eq(name,word8_tyname) orelse
      tyname_eq(name,word16_tyname) orelse
      tyname_eq(name,word32_tyname) orelse
      tyname_eq(name,word64_tyname)
      | word_typep (META_OVERLOADED {1=ref t,...}) = word_typep t
      | word_typep _ = false

    fun num_typep (ty as CONSTYPE ([],_)) =
      real_typep ty orelse int_typep ty orelse word_typep ty
      | num_typep (META_OVERLOADED {1=ref t,...}) = num_typep t
      | num_typep _ = false

    fun num_or_string_typep(ty as CONSTYPE([], name)) =
      tyname_eq(name, string_tyname) orelse
      tyname_eq(name, char_tyname) orelse
      num_typep ty
      | num_or_string_typep (META_OVERLOADED {1=ref t,...}) =
      num_or_string_typep t
      | num_or_string_typep _ = false

    fun wordint_typep ty = int_typep ty orelse word_typep ty

    fun realint_typep ty = int_typep ty orelse real_typep ty

    fun tyvar_equalityp (TYVAR (_,Ident.TYVAR (_,eq,_))) = eq
      | tyvar_equalityp (METATYVAR (ref (_,NULLTYPE,_),eq,_)) = eq
      | tyvar_equalityp (METATYVAR (ref (_,t,_),eq,_)) = 
                             tyvar_equalityp t
      | tyvar_equalityp t = 
        Crash.impossible ("tyvar_equalityp "^
                          (debug_print_type Options.default_options t))
                    (* see above for the "false" argument" *)

    (***
     Test if a type occurs within another type
     Used for finding xact location of free imperative type variable errors
     ***)

    fun type_occurs(ty, ty') =
      ((*output(std_out, "type_occurs checking ty1 = " ^
	Types.extra_debug_print_type ty ^ "\nwith ty2 = " ^
	Types.extra_debug_print_type ty' ^ "\n");*)
       type_eq(ty', ty, true, true) orelse occurs_in(ty, ty'))

    and occurs_in(ty, METATYVAR(ref(_, ty', _), _, _)) =
      type_occurs(ty, ty')
      | occurs_in(ty, META_OVERLOADED(ref ty', _, _, _)) =
	type_occurs(ty, ty')
      | occurs_in(ty, TYVAR(ref(_, ty', _), _)) = type_occurs(ty, ty')
      | occurs_in(ty, METARECTYPE(ref{3=ty', ...})) = type_occurs(ty, ty')
      | occurs_in(ty, RECTYPE lab_ty_map) =
	List.exists
	(fn ty' => type_occurs(ty, ty'))
	(NewMap.range lab_ty_map)
      | occurs_in(ty, FUNTYPE(ty', ty'')) =
	type_occurs(ty, ty') orelse type_occurs(ty, ty'')
      | occurs_in(ty, CONSTYPE(ty_list, _)) =
	List.exists
	(fn ty' => type_occurs(ty, ty'))
	ty_list
      | occurs_in(_, DEBRUIJN _) = false
      | occurs_in(_, NULLTYPE) = false

    (****
     Test for presence of imperative type variables.
     ****)
    (* This also checks for non-imperative tyvars, a check that is necessary *)
    (* for value-polymorphism and doesn't affect normal semantics *)
    fun has_free_imptyvars (ty as METATYVAR (ref (_,NULLTYPE,_),_,_)) =
      SOME ty
      | has_free_imptyvars (METATYVAR (ref (_,ty,_),_,_)) = has_free_imptyvars ty
      | has_free_imptyvars (ty as TYVAR (_,Ident.TYVAR (_,_,_))) =
	SOME ty
      | has_free_imptyvars (METARECTYPE (ref (_,true,t as METARECTYPE _,_,
                                              imp))) = has_free_imptyvars t
      | has_free_imptyvars (ty as METARECTYPE (ref (_,true,_,_,imp))) =
	SOME ty
      | has_free_imptyvars (METARECTYPE (ref (_,false,ty,_,_))) = 
	has_free_imptyvars ty
      | has_free_imptyvars (RECTYPE amap) = 
	NewMap.fold
	(fn (NONE, _, ty) => has_free_imptyvars ty
         | (found, _, _) => found)
	(NONE, amap)
      | has_free_imptyvars (FUNTYPE (arg,res)) = 
	(case has_free_imptyvars arg of
	   NONE => has_free_imptyvars res
	 | x => x)
      | has_free_imptyvars (CONSTYPE (tylist,name)) =
	let 
	  fun collect ([]) = NONE
	    | collect (h::t) =
	      case has_free_imptyvars h of
		NONE => collect t
	      | x => x
	in
	  collect (tylist)
	end
      | has_free_imptyvars _ = NONE
	
    (****
     Determine whether a type function is eta-convertible.
     ****)

    fun has_a_name (ETA_TYFUN (METATYNAME {1=ref(NULL_TYFUN _), ...})) = true
      | has_a_name (ETA_TYFUN (METATYNAME {1=ref tyfun, ...})) =
        has_a_name tyfun
      | has_a_name (ETA_TYFUN tyname) = true
      | has_a_name _ = false

    fun name (ETA_TYFUN (meta as METATYNAME {1=ref(NULL_TYFUN _),...})) = meta
      | name (ETA_TYFUN (METATYNAME {1=ref tyfun,...})) = name tyfun
      | name (ETA_TYFUN tyname) = tyname
      | name tyfun = Crash.impossible ("Types.name " ^ string_tyfun tyfun)

    (****
     Copying of Tynames, Types and Tyfuns - used when signatures are copied.
     ****)

    fun create_tyname_copy rigid level =
      let
        fun copy (tyname_copies,
                  METATYNAME (ref (NULL_TYFUN (id,tf)),printname,arity,
                              ref eq, ref ve,ref is_abs)) =
        (case Stamp.Map.tryApply'(tyname_copies,id) of
	   SOME _ => tyname_copies
	 | NONE =>
             let
               val newname =
                 if rigid
                   then TYNAME (Stamp.make_stamp(),printname,arity,ref eq,
                                ref ve,NONE,ref is_abs,
                                ref empty_valenv,level)
                 else METATYNAME (ref (NULL_TYFUN (Stamp.make_stamp (),tf)),
                                  printname,arity,ref eq, ref ve,ref is_abs)
             in
               Stamp.Map.define(tyname_copies, id, newname)
             end)

          | copy (tyname_copies,
                  METATYNAME {1 = ref (ETA_TYFUN (meta as 
                                                  METATYNAME {1 = ref tyfun,
                                                              ...})),...}) =
            copy (tyname_copies,meta)
          | copy (tyname_copies,METATYNAME _) = tyname_copies
          (* Need to copy the tynames too *)
          | copy (tyname_copies,TYNAME (id, name,arity, ref eq, ref ve1,
                                        loc, ref bool2, ref ve2,level)) =
            Stamp.Map.define (tyname_copies, id,
                              TYNAME (Stamp.make_stamp (), name, arity, 
                                      ref eq, ref ve1,loc, ref bool2, 
                                      ref ve2,level))
      in
        copy
      end

    fun type_has_unbound_tyvars(METATYVAR (ref (_,ty,_),_,_)) = 
        type_has_unbound_tyvars ty
      | type_has_unbound_tyvars (METARECTYPE (ref (_,false,ty,_,_))) = 
        type_has_unbound_tyvars ty
      | type_has_unbound_tyvars (RECTYPE amap) =
	NewMap.exists type_has_unbound_tyvars_exists amap
      | type_has_unbound_tyvars (FUNTYPE (ty,ty')) =
	type_has_unbound_tyvars ty orelse type_has_unbound_tyvars ty'
      | type_has_unbound_tyvars (CONSTYPE (l, name)) = 
	List.exists type_has_unbound_tyvars l orelse
	tyname_has_unbound_tyvars name
      | type_has_unbound_tyvars (ty as (TYVAR _)) = false
      | type_has_unbound_tyvars (ty as (DEBRUIJN _)) = false
      | type_has_unbound_tyvars ty = true

    and type_has_unbound_tyvars_exists(_, ty) = type_has_unbound_tyvars ty

    and tyname_has_unbound_tyvars (tyname as METATYNAME {1 = ref (NULL_TYFUN _), ...}) =
      false
      | tyname_has_unbound_tyvars (METATYNAME {1 = ref (ETA_TYFUN meta), ...}) =
	tyname_has_unbound_tyvars meta
      | tyname_has_unbound_tyvars (METATYNAME{1=ref tyfun, ...}) =
	tyfun_has_unbound_tyvars tyfun
      | tyname_has_unbound_tyvars tyname = false

    and tyfun_has_unbound_tyvars (ETA_TYFUN (METATYNAME {1=ref(NULL_TYFUN _), ...})) =
      false
      | tyfun_has_unbound_tyvars (ETA_TYFUN (METATYNAME{1 = ref tyfun, ...})) =
	tyfun_has_unbound_tyvars tyfun
      | tyfun_has_unbound_tyvars (TYFUN(CONSTYPE([], tyname), a)) =
	tyfun_has_unbound_tyvars(ETA_TYFUN tyname)
      | tyfun_has_unbound_tyvars (TYFUN(ty, a)) = type_has_unbound_tyvars ty
      | tyfun_has_unbound_tyvars tyfun = false

    fun type_copy (METATYVAR (ref (_,ty,_),_,_),tyname_copies) = type_copy (ty,tyname_copies)
      | type_copy (METARECTYPE (ref (_,false,ty,_,_)),tyname_copies) = type_copy (ty,tyname_copies)
      | type_copy (METARECTYPE (ref (_,true,ty,_,_)),tyname_copies) = Crash.impossible "Types.type_copy"
      | type_copy (RECTYPE amap,tyname_copies) =
	RECTYPE(NewMap.map (fn (_, ty) => type_copy(ty,tyname_copies)) amap)
      | type_copy (FUNTYPE (ty,ty'),tyname_copies) = FUNTYPE(type_copy (ty,tyname_copies), type_copy (ty',tyname_copies))
      | type_copy (CONSTYPE ([], name),tyname_copies) =
        CONSTYPE([], tyname_copy (name,tyname_copies))
      | type_copy (CONSTYPE (l, name),tyname_copies) =
        CONSTYPE(map (fn ty => type_copy (ty,tyname_copies)) l, tyname_copy (name,tyname_copies))
      | type_copy (ty as (TYVAR _),tyname_copies) = ty
      | type_copy (ty as (DEBRUIJN _),tyname_copies) = ty
      | type_copy (META_OVERLOADED {1=ref ty, ...},tyname_copies) = ty
      | type_copy (NULLTYPE, tyname_copies) = NULLTYPE

    and tyname_copy (tyname as METATYNAME {1 = ref (NULL_TYFUN (id,_)), ...},tyname_copies) =
      Stamp.Map.apply_default'(tyname_copies, tyname, id)
      | tyname_copy (METATYNAME {1 = ref (ETA_TYFUN meta), ...},tyname_copies) =
        tyname_copy (meta,tyname_copies)
      | tyname_copy (METATYNAME(ref tyfun, name, a, ref eq, ref ve,ref is_abs),tyname_copies) =
        METATYNAME(ref (tyfun_copy (tyfun,tyname_copies)), name, a, ref eq, ref ve,ref is_abs)
      | tyname_copy (tyname as TYNAME {1=id,...},tyname_copies) =
        Stamp.Map.apply_default'(tyname_copies, tyname, id)

    and tyfun_copy (ETA_TYFUN (meta as METATYNAME {1=ref (NULL_TYFUN _), ...}),tyname_copies) =
      ETA_TYFUN (tyname_copy (meta,tyname_copies))
      | tyfun_copy (ETA_TYFUN (METATYNAME {1 = ref tyfun, ...}), tyname_copies) = tyfun_copy (tyfun,tyname_copies)
      | tyfun_copy (ETA_TYFUN tyname,tyname_copies) = ETA_TYFUN (tyname_copy (tyname,tyname_copies))
      | tyfun_copy (TYFUN (CONSTYPE ([], tyname), a),tyname_copies) = tyfun_copy(ETA_TYFUN tyname,tyname_copies)
      | tyfun_copy (TYFUN(ty, a),tyname_copies) = TYFUN(type_copy (ty,tyname_copies), a)
      | tyfun_copy (tyfun,tyname_copies) = tyfun

(*
    val type_copy = fn (ty,copies) => (output(std_out,debug_print_type ty ^ "\n"); type_copy (ty,copies))
*)

    fun tyvars (tyvarlist, METATYVAR (ref (_,NULLTYPE,_),_,_)) = tyvarlist
      | tyvars (tyvarlist, METATYVAR (ref (_,atype,_),_,_)) = 
	tyvars (tyvarlist, atype)
      | tyvars (tyvarlist, TYVAR (_,tyvar)) = tyvar :: tyvarlist
      | tyvars (tyvarlist, METARECTYPE (ref (_,_,atype,_,_))) =
	tyvars (tyvarlist, atype)
      | tyvars (tyvarlist, RECTYPE amap) = 
	NewMap.fold
	tyvars_fold
	(tyvarlist, amap)
      | tyvars (tyvarlist, FUNTYPE (atype,atype')) = 
	tyvars (tyvars (tyvarlist, atype), atype')
      | tyvars (tyvarlist, CONSTYPE (tylist,_)) =
        Lists.reducel tyvars (tyvarlist, tylist)
      | tyvars (tyvarlist, _) = tyvarlist
	
    and tyvars_fold(tyvarlist, _, ty) = tyvars(tyvarlist, ty)

    local
     fun tyvars (tyvarlist, METATYVAR (tyvar as ref(_,NULLTYPE,_),_,_)) = tyvar::tyvarlist
       | tyvars (tyvarlist, TYVAR (tyvar as ref(_,NULLTYPE,_),_)) = tyvar :: tyvarlist
       | tyvars (tyvarlist, METATYVAR (tyvar as ref(_,ty,_),_,_)) = 
         tyvars (tyvarlist,ty)
       | tyvars (tyvarlist, TYVAR (tyvar as ref(_,ty,_),_)) = 
         tyvars (tyvarlist,ty)
       | tyvars (tyvarlist, METARECTYPE (ref (_,_,atype,_,_))) =
         tyvars (tyvarlist, atype)
       | tyvars (tyvarlist, RECTYPE amap) = 
         NewMap.fold
         tyvars_fold
         (tyvarlist, amap)
       | tyvars (tyvarlist, FUNTYPE (atype,atype')) = 
         tyvars (tyvars (tyvarlist, atype), atype')
       | tyvars (tyvarlist, CONSTYPE (tylist,_)) =
         Lists.reducel tyvars (tyvarlist, tylist)
       | tyvars (tyvarlist, DEBRUIJN(_,_,_,SOME tyvar)) = tyvar::tyvarlist
       | tyvars (tyvarlist, _) = tyvarlist

     and tyvars_fold(tyvarlist, _, ty) = tyvars(tyvarlist, ty)

   in
     fun all_tyvars ty = tyvars(nil,ty)
   end

   fun isFunType ty =
     case the_type ty of 
       FUNTYPE _ => true
     | _ => false

   exception ArgRes
    
   fun argres ty =
     case the_type ty of
       FUNTYPE ar => ar
     | _ => raise ArgRes

   type seen_tyvars = Type list * int

   val no_tyvars : seen_tyvars = ([],0)

   fun print_type_with_seen_tyvars (options,t,(stack,depth)) =
     let
       val (s,depth,stack) =
	 string_types (options,t,depth,stack,"")
     in
       (s,(stack,depth))
     end

   (* What is this stuff for ? *)
   (* It only gets activated with module debugging on *)

   local
     val tyfun_instantiations : Tyfun list ref = ref [] (* GLOBAL REF *)

     (* many GLOBAL REFs *)
     val ves : (Valenv ref * Valenv ref) list ref = ref []
     val tys1 : ((int * Type * Instance) ref
                 * (int * Type * Instance) ref) list ref = ref []
     val tys2 : (Type ref * Type ref) list ref = ref []
     val tys3 : ((int * bool * Type * bool * bool) ref
                 * (int * bool * Type * bool * bool) ref) list ref = ref []
     val tfs : (Tyfun ref * Tyfun ref) list ref = ref []

     fun copy_type(CONSTYPE(tys,tyn)) =
       CONSTYPE(Lists.reducel
                (fn (tys,ty) => copy_type ty ::tys) (nil, tys),
                copy_tyname tyn)
       | copy_type (FUNTYPE(ty1,ty2)) = FUNTYPE(copy_type ty1,copy_type ty2)
       | copy_type (RECTYPE(map)) =
         RECTYPE(NewMap.fold
		 (fn (map, lab, ty) => NewMap.define'(map, (lab,copy_type ty)))
		 (NewMap.empty' Ident.lab_lt, map))
       | copy_type (tyv as METATYVAR(ty1 as ref(n,ty,i),b1,b2)) =
         (METATYVAR(Lists.assoc(ty1,!tys1),b1,b2)
          handle Lists.Assoc => 
            (tys1 := (ty1,ty1)::(!tys1);
             ty1 := (n,copy_type ty,i);
             tyv))
       | copy_type
         (ovty as META_OVERLOADED
          (ty1 as ref(ty),tv,valid,loc)) =
         (META_OVERLOADED(Lists.assoc(ty1,!tys2),tv,valid,loc)
          handle Lists.Assoc =>
            (tys2 := (ty1,ty1)::(!tys2);
             ty1 := copy_type ty;
             ovty))
       | copy_type (tyv as TYVAR(ty1 as ref(n,ty,i),id)) =
         (TYVAR(Lists.assoc(ty1,!tys1),id)
          handle Lists.Assoc =>
            (tys1 := (ty1,ty1)::(!tys1);
             ty1 := (n,copy_type ty,i);
             tyv))
       | copy_type (recty as METARECTYPE(ty1 as ref(n,b1,ty,b2,b3))) =
         (METARECTYPE(Lists.assoc(ty1,!tys3))
          handle Lists.Assoc =>
            (tys3 := (ty1,ty1)::(!tys3);
             ty1 := (n,b1,copy_type ty,b2,b3);
             recty))
       | copy_type ty = ty
     and copy_typescheme (SCHEME(n,(ty,i))) = SCHEME(n,(copy_type ty,i))
       | copy_typescheme (UNBOUND_SCHEME(ty,i)) = UNBOUND_SCHEME(copy_type ty,i)
       | copy_typescheme sch = sch
     and copy_tyname
       (m as METATYNAME(tf as ref(NULL_TYFUN(_)),name,n,b,
                        ve' as ref(VE(n',ve)),abs)) =
       (METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs)
        handle Lists.Assoc =>
          let
            val map =
              (ves := (ve',ve')::(!ves);
               NewMap.map (fn (valid,sch) => copy_typescheme sch) ve)
          in
            (ve' := VE(n',map);
             METATYNAME(tf,name,n,b,ve',abs))
          end)
       | copy_tyname (METATYNAME(tf as ref(ETA_TYFUN(tyn)),name,n,b,
                                 ve' as ref(VE(n',ve)),abs)) =
         let
           val (tf1,tf_encountered) =
             (Lists.assoc(tf,!tfs),true)
             handle Lists.Assoc =>
               (tf,false)
           val (ve'',ve_encountered) =
             (Lists.assoc(ve',!ves),true)
             handle Lists.Assoc =>
               (ve',false)
           val _ =
             if tf_encountered then ()
             else
               tfs := (tf,tf1)::(!tfs)
           val _ =
             if ve_encountered then ()
             else
               ves := (ve',ve'')::(!ves)
           val _ =
             if tf_encountered then ()
             else
               tf1 := ETA_TYFUN(copy_tyname tyn)
           val _ =
             if ve_encountered then ()
             else
               ve'' := VE(n',NewMap.map (fn (valid,sch) => copy_typescheme sch) ve)
         in
           METATYNAME(tf1,name,n,b,ve'',abs)
         end
       | copy_tyname (METATYNAME(tf as ref(TYFUN(ty,n)),name,n',b,
                                 ve' as ref(VE(n'',ve)),abs)) =
         let
           val (tf1,tf_encountered) =
             (Lists.assoc(tf,!tfs),true)
             handle Lists.Assoc =>
               (tf,false)
           val (ve'',ve_encountered) =
             (Lists.assoc(ve',!ves),true)
             handle Lists.Assoc =>
               (ve',false)
           val _ =
             if tf_encountered then ()
             else
               tfs := (tf,tf1)::(!tfs)
           val _ =
             if ve_encountered then ()
             else
               ves := (ve',ve'')::(!ves)
           val _ =
             if tf_encountered then ()
             else
               tf1 := TYFUN(copy_type ty,n)
           val _ =
             if ve_encountered then ()
             else
               ve'' := VE(n'', NewMap.map (fn (valid,sch) => copy_typescheme sch) ve)
         in
           METATYNAME(tf1,name,n',b,ve'',abs)
         end
       | copy_tyname (TYNAME(id,s,n,b,ve1 as ref(VE(n1,ve2)),s',
                             abs,ve3 as ref(VE(_,ve4)),lev)) =
         (TYNAME(id,s,n,b,ve1,s',abs,Lists.assoc(ve1,!ves),lev)
          handle Lists.Assoc =>
            let
              val ve'' = ref(VE(n1,NewMap.empty (Ident.valid_lt, 
                                                 Ident.valid_eq)))
              val map =
                (ves := (ve1,ve'')::(!ves);
                 NewMap.map (fn (valid,sch) => copy_typescheme sch) ve2)
            in
              (ve'' := VE(n1,map);
               TYNAME(id,s,n,b,ve1,s',abs,ve'',lev))
            end)
     val dummy_false = ref false
     val dummy_ve = ref empty_valenv
     val dummy_tf = ref (TYFUN(NULLTYPE,0))

     fun copy_tyfun tyf =
       (dummy_tf := tyf;
        ves := [];
        tys1 := [];
        tys2 := [];
        tys3 := [];
        tfs := [];
        case copy_tyname(METATYNAME(dummy_tf,"",0,dummy_false,dummy_ve,
                                    dummy_false)) of
          METATYNAME(ref(tf),_,_,_,_,_) => tf
        | _ => Crash.impossible "copy_tyfun:generate_moduler:core_rules")
   in
     fun update_tyfun_instantiations tyf =
       (tyfun_instantiations := copy_tyfun tyf :: (!tyfun_instantiations);
        length (!tyfun_instantiations))

     fun fetch_tyfun_instantiation tyfun =
       Lists.nth(tyfun-1,rev(!tyfun_instantiations))
   end

   exception CombineTypes

   (* The idea of this function is to combine two types, which should match each other *)
   (* And to return a composite type maximizing the constructor information available *)
   (* This is just used for printing values, so we could probably discard more information *)

   fun combine_types (t1,t2) =
     let
       val t1 = type_strip t1
       val t2 = type_strip t2
       fun empty_valenvp (VE (_,amap)) = NewMap.is_empty amap
       fun aux (NULLTYPE,t) = t
         | aux (t,NULLTYPE) = t
         | aux (METATYVAR (ref (_,t1,_),_,_),t2) = aux (t1,t2)
         | aux (t1,METATYVAR (ref (_,t2,_),_,_)) = aux (t1,t2)
         | aux (META_OVERLOADED (ref t1,_,_,_),t2) = aux (t1,t2)
         | aux (t1,META_OVERLOADED (ref t2,_,_,_)) = aux (t1,t2)
         | aux (TYVAR (ref (_,t1,_),_),t2) = aux (t1,t2)
         | aux (t1,TYVAR (ref (_,t2,_),_)) = aux (t1,t2)
         | aux (METARECTYPE (ref (_,_,t1,_,_)),t2) = aux (t1,t2)
         | aux (t1,METARECTYPE (ref (_,_,t2,_,_))) = aux (t1,t2)
         | aux (RECTYPE map1,RECTYPE map2) =
	   if NewMap.size map1 <> NewMap.size map2 then
	     raise Lists.Zip (* Not sure if this can happen *)
	   else
	     RECTYPE
	     (NewMap.fold
	      (fn (map, lab, ty) =>
	       case NewMap.tryApply'(map, lab) of
		 SOME ty' => NewMap.define'(map, (lab, aux(ty, ty')))
	       | _ => raise CombineTypes)
	      (map1, map2))
(*
           let
             val assoc1 = Mapping.assoc map1
             val assoc2 = Mapping.assoc map2
             fun merge (((lab1,ty1),(lab2,ty2))::rest,map) =
               if lab1 = lab2 then
		 merge (rest,Mapping.add ((lab1,aux (ty1,ty2)),map,Ident.lab_order))
               else
		 raise CombineTypes
	       | merge ([],map) = map
           in
             RECTYPE(merge(Lists.zip (assoc1,assoc2),NewMap.empty' Ident.lab_lt))
           end
*)
         | aux (FUNTYPE (arg1,res1),FUNTYPE (arg2,res2)) =
           FUNTYPE (aux (arg1,arg2),aux (res1,res2))
         (* Note that the two type constructors need not be the same here *)
         (* If not, what should we do? *)
         | aux (CONSTYPE (tl1,tyname1),CONSTYPE (tl2,tyname2)) =
           CONSTYPE (map aux (Lists.zip (tl1,tl2)),
                     tyname_aux (tyname1,tyname2))
         | aux (DEBRUIJN t1,t2) = t2
         | aux (t1,DEBRUIJN t2) = t1
         | aux _ = raise CombineTypes
       and tyname_aux (tyname1 as TYNAME (_,_,_,_,_,_,_,ref ve1,_),
                       tyname2 as TYNAME (_,_,_,_,_,_,_,ref ve2,_)) =
         if empty_valenvp ve1 then tyname2 else tyname1
         | tyname_aux (tyname1 as TYNAME _,tyname2) = tyname1
         | tyname_aux (tyname1,tyname2 as TYNAME _) = tyname2
         | tyname_aux (tyname1 as METATYNAME (_,_,_,_,ref ve1,_),
                       tyname2 as METATYNAME (_,_,_,_,ref ve2,_)) =
           if empty_valenvp ve1 then tyname2 else tyname1
     in
       aux (t1,t2) 
       handle Lists.Zip => raise CombineTypes
     end

   (* Stamps *)

   val stamp_num = Stamp.stamp
   val make_stamp = Stamp.make_stamp
  end
@


1.122.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.122  1998/02/19  16:32:51  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.121
log
@[Bug #20017]
Add has_int32_equality function
@
text
@d4 4
d1348 1
a1348 1
	    (NewMap.map resolve_ty_map amap; ())
d1353 1
a1353 1
	    (map (fn x => resolve_ty x) tylist; ())
@


1.121.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.121  1997/04/25  16:28:32  jont
 * [Bug #20017]
 * Add has_int32_equality function
 *
@


1.121.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.121  1997/04/25  16:28:32  jont
 * [Bug #20017]
 * Add has_int32_equality function
 *
@


1.120
log
@[Bug #1818]
Adding new floatarray type name.
@
text
@d4 4
a698 2
      tyname_eq(tyname, int32_tyname) orelse
      tyname_eq(tyname, word32_tyname) orelse
d701 4
@


1.120.1.1
log
@branched from 1.120
@
text
@a3 4
 * Revision 1.120  1996/12/18  16:38:04  andreww
 * [Bug #1818]
 * Adding new floatarray type name.
 *
@


1.120.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.120.1.1  1997/05/12  10:51:36  hope
 * branched from 1.120
 *
@


1.120.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.120.1.1  1997/05/12  10:51:36  hope
 * branched from 1.120
 *
@


1.120.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.120.1.1  1997/05/12  10:51:36  hope
 * branched from 1.120
 *
@


1.120.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.120.1.1.1.1  1997/07/28  18:33:27  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.119
log
@[Bug #1711]
Punning real tyname equality attribute with old_definition option.
@
text
@d4 4
d530 1
d677 2
a678 1
      tyname_eq(bytearray_tyname, tyname)
@


1.119.4.1
log
@branched from 1.119
@
text
@a3 4
 * Revision 1.119  1996/11/06  13:38:56  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
@


1.119.3.1
log
@branched from 1.119
@
text
@a3 4
 * Revision 1.119  1996/11/06  13:38:56  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
@


1.119.3.1.1.1
log
@branched from 1.119.3.1
@
text
@a3 3
 * Revision 1.119.3.1  1996/12/17  18:18:03  hope
 * branched from 1.119
 *
@


1.119.2.1
log
@branched from 1.119
@
text
@a3 4
 * Revision 1.119  1996/11/06  13:38:56  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
@


1.119.1.1
log
@branched from 1.119
@
text
@a3 4
 * Revision 1.119  1996/11/06  13:38:56  andreww
 * [Bug #1711]
 * Punning real tyname equality attribute with old_definition option.
 *
@


1.119.1.1.1.1
log
@branched from 1.119.1.1
@
text
@a3 3
 * Revision 1.119.1.1  1996/11/14  13:21:17  hope
 * branched from 1.119
 *
@


1.118
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d497 5
d513 1
a513 1
    val real_tyname = make_tyname (0,true,"real",NONE,0)
d523 19
a541 6
    val bytearray_tyname = make_tyname (0,true,"bytearray",
                                        NONE, 0)
    val dynamic_tyname = make_tyname (0,false,"dynamic",NONE,
                                      0)
    val typerep_tyname = make_tyname (0,false,"type_rep",NONE,
                                      0)
d684 2
a685 2
      tyname_eq(tyname, real_tyname) orelse
      tyname_eq(tyname, float32_tyname)
@


1.117
log
@[Bug #1614]
basifying String
@
text
@d4 4
d404 1
a404 1
require "^.basis.__integer";
@


1.116
log
@[Bug #1592]
Threading extra level argument through tynames.
@
text
@d4 4
d400 2
a401 1
require "../basis/__integer";
d489 21
a509 21
    val bool_tyname = make_tyname (0,true,"bool",MLWorks.Option.NONE,0)
    val int_tyname = make_tyname (0,true,"int",MLWorks.Option.NONE,0)
    val word_tyname = make_tyname (0,true,"word",MLWorks.Option.NONE,0)
    val int8_tyname = make_tyname (0,true,"int8",MLWorks.Option.NONE,0)
    val word8_tyname = make_tyname (0,true,"word8",MLWorks.Option.NONE,0)
    val int16_tyname = make_tyname (0,true,"int16",MLWorks.Option.NONE,0)
    val word16_tyname = make_tyname (0,true,"word16",MLWorks.Option.NONE,0)
    val int32_tyname = make_tyname (0,true,"int32",MLWorks.Option.NONE,0)
    val word32_tyname = make_tyname (0,true,"word32",MLWorks.Option.NONE,0)
    val int64_tyname = make_tyname (0,true,"int64",MLWorks.Option.NONE,0)
    val word64_tyname = make_tyname (0,true,"word64",MLWorks.Option.NONE,0)
    val real_tyname = make_tyname (0,true,"real",MLWorks.Option.NONE,0)
    val float32_tyname = make_tyname (0,true,"float32",MLWorks.Option.NONE,0)
    val string_tyname = make_tyname (0,true,"string",MLWorks.Option.NONE,0)
    val char_tyname = make_tyname (0,true,"char",MLWorks.Option.NONE,0)
    val list_tyname = make_tyname (1,true,"list",MLWorks.Option.NONE,0)
    val ref_tyname = make_tyname (1,true,"ref",MLWorks.Option.NONE,0)
    val exn_tyname = make_tyname (0,false,"exn",MLWorks.Option.NONE,0)
    val ml_value_tyname = make_tyname (0,true,"ml_value",MLWorks.Option.NONE,0)
    val array_tyname = make_tyname (1,true,"array",MLWorks.Option.NONE, 0)
    val vector_tyname = make_tyname (1,true,"vector",MLWorks.Option.NONE, 0)
d511 2
a512 2
                                        MLWorks.Option.NONE, 0)
    val dynamic_tyname = make_tyname (0,false,"dynamic",MLWorks.Option.NONE,
d514 1
a514 1
    val typerep_tyname = make_tyname (0,false,"type_rep",MLWorks.Option.NONE,
d517 10
a526 10
    fun tyname_sizeof (TYNAME {2 = "int8", ...}) = MLWorks.Option.SOME 8
    |   tyname_sizeof (TYNAME {2 = "word8", ...}) = MLWorks.Option.SOME 8
    |   tyname_sizeof (TYNAME {2 = "int16", ...}) = MLWorks.Option.SOME 16
    |   tyname_sizeof (TYNAME {2 = "word16", ...}) = MLWorks.Option.SOME 16
    |   tyname_sizeof (TYNAME {2 = "int32", ...}) = MLWorks.Option.SOME 32
    |   tyname_sizeof (TYNAME {2 = "word32", ...}) = MLWorks.Option.SOME 32
    |   tyname_sizeof (TYNAME {2 = "int64", ...}) = MLWorks.Option.SOME 64
    |   tyname_sizeof (TYNAME {2 = "word64", ...}) = MLWorks.Option.SOME 64
    |   tyname_sizeof (TYNAME {2 = "float32", ...}) = MLWorks.Option.SOME 32
    |   tyname_sizeof _ = MLWorks.Option.NONE
d572 1
a572 1
    |   sizeof _ = MLWorks.Option.NONE
d724 1
a724 1
	((eq_attrib n) andalso (Lists.forall type_equalityp tylist))
d742 1
a742 1
	((eq_attrib n) andalso (Lists.forall closed_type_equalityp tylist))
d886 1
a886 1
      String.implode ["LAMBDA{", Int.toString n, "}.", extra_debug_print_type aty]
d888 1
a888 1
	String.implode ["ETA{", Int.toString (tyname_arity aname), "}.", debug_print_name aname]
d890 1
a890 1
	String.implode ["NULL_TYFUN", Stamp.string_stamp id]
d957 1
a957 1
	rep_chars (rep,String.chr char_no,"")
d1016 1
a1016 1
                    (String.implode ["(",s,") ",print_name options name],depth,stack)
d1018 1
a1018 1
                  (String.implode [s," ",print_name options name],depth,stack)
d1020 1
a1020 1
	      (String.implode ["(", acc_string, ", ", s, ") ", 
d1072 1
a1072 1
		    MLWorks.Option.NONE => false
d1099 1
a1099 1
	      (String.implode ("(" :: (print_as_a_tuple [")"] len)),
d1106 1
a1106 1
		  (fn (lab,ty) => String.implode [IdentPrint.printLab lab,
d1116 1
a1116 1
		(String.implode list_with_commas,!depth_ref,!stack_ref)
d1209 1
a1209 1
      if arity = Lists.length (tylist)
d1247 1
a1247 1
	"CONSTYPE(" ^ String.implode(map extra_debug_print_type ty_list) ^ ", " ^
d1332 1
a1332 1
	  Lists.forall imperativep tylist
d1366 1
a1366 1
            String.chr (String.ord "a" + n)
d1368 1
a1368 1
            String.chr (String.ord "a" + (n mod 26)) ^ name (n div 26)
d1395 1
a1395 1
          String.implode ("(" :: print_tyvars' options l)
d1408 1
a1408 1
	    val new_debruijn = DEBRUIJN (n,true,true,MLWorks.Option.NONE) (* arbitrary choice *)
d1450 1
a1450 1
                   Lists.length (tyvarlist))
d1541 1
a1541 1
	Lists.exists
d1547 1
a1547 1
	Lists.exists
d1559 1
a1559 1
      MLWorks.Option.SOME ty
d1562 1
a1562 1
	MLWorks.Option.SOME ty
d1566 1
a1566 1
	MLWorks.Option.SOME ty
d1571 1
a1571 1
	(fn (MLWorks.Option.NONE, _, ty) => has_free_imptyvars ty
d1573 1
a1573 1
	(MLWorks.Option.NONE, amap)
d1576 1
a1576 1
	   MLWorks.Option.NONE => has_free_imptyvars res
d1580 1
a1580 1
	  fun collect ([]) = MLWorks.Option.NONE
d1583 1
a1583 1
		MLWorks.Option.NONE => collect t
d1588 1
a1588 1
      | has_free_imptyvars _ = MLWorks.Option.NONE
d1615 2
a1616 2
	   MLWorks.Option.SOME _ => tyname_copies
	 | MLWorks.Option.NONE =>
d1621 1
a1621 1
                                ref ve,MLWorks.Option.NONE,ref is_abs,
d1655 1
a1655 1
	Lists.exists type_has_unbound_tyvars l orelse
d1751 1
a1751 1
       | tyvars (tyvarlist, DEBRUIJN(_,_,_,MLWorks.Option.SOME(tyvar))) = tyvar::tyvarlist
d1943 1
a1943 1
        Lists.length(!tyfun_instantiations))
d1978 1
a1978 1
		 MLWorks.Option.SOME ty' => NewMap.define'(map, (lab, aux(ty, ty')))
@


1.116.1.1
log
@branched from 1.116
@
text
@a3 4
 * Revision 1.116  1996/10/04  15:40:11  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.115
log
@[Bug #1521]
Prevent type variables being distinguished as imperative when using
value polymorphism.
@
text
@d4 5
d441 7
a447 2
    fun make_tyname (n,eq,pname,location) = 
      TYNAME (Stamp.make_stamp (),pname,n,ref eq, ref empty_valenv,location,ref false,ref empty_valenv)
d449 1
a449 1
    fun tyname_arity (TYNAME (_,_,n,_,_,_,_,_)) = n
d456 1
a456 1
    fun tyname_make_false (TYNAME (_,_,_,r,_,_,_,_)) = (r := false; false)
d474 1
a474 1
    fun make_true (TYNAME (_,_,_,r,_,_,_,_)) = r := true
d484 27
a510 24
    val bool_tyname = make_tyname (0,true,"bool",MLWorks.Option.NONE)
    val int_tyname = make_tyname (0,true,"int",MLWorks.Option.NONE)
    val word_tyname = make_tyname (0,true,"word",MLWorks.Option.NONE)
    val int8_tyname = make_tyname (0,true,"int8",MLWorks.Option.NONE)
    val word8_tyname = make_tyname (0,true,"word8",MLWorks.Option.NONE)
    val int16_tyname = make_tyname (0,true,"int16",MLWorks.Option.NONE)
    val word16_tyname = make_tyname (0,true,"word16",MLWorks.Option.NONE)
    val int32_tyname = make_tyname (0,true,"int32",MLWorks.Option.NONE)
    val word32_tyname = make_tyname (0,true,"word32",MLWorks.Option.NONE)
    val int64_tyname = make_tyname (0,true,"int64",MLWorks.Option.NONE)
    val word64_tyname = make_tyname (0,true,"word64",MLWorks.Option.NONE)
    val real_tyname = make_tyname (0,true,"real",MLWorks.Option.NONE)
    val float32_tyname = make_tyname (0,true,"float32",MLWorks.Option.NONE)
    val string_tyname = make_tyname (0,true,"string",MLWorks.Option.NONE)
    val char_tyname = make_tyname (0,true,"char",MLWorks.Option.NONE)
    val list_tyname = make_tyname (1,true,"list",MLWorks.Option.NONE)
    val ref_tyname = make_tyname (1,true,"ref",MLWorks.Option.NONE)
    val exn_tyname = make_tyname (0,false,"exn",MLWorks.Option.NONE)
    val ml_value_tyname = make_tyname (0,true,"ml_value",MLWorks.Option.NONE)
    val array_tyname = make_tyname (1,true,"array",MLWorks.Option.NONE)
    val vector_tyname = make_tyname (1,true,"vector",MLWorks.Option.NONE)
    val bytearray_tyname = make_tyname (0,true,"bytearray",MLWorks.Option.NONE)
    val dynamic_tyname = make_tyname (0,false,"dynamic",MLWorks.Option.NONE)
    val typerep_tyname = make_tyname (0,false,"type_rep",MLWorks.Option.NONE)
d746 1
a746 1
    and eq_attrib (TYNAME (_,_,_,ref eq,_,_,_,_)) = eq
d776 2
a777 1
    and tyname_eq' (t as TYNAME (id,_,_,_,_,_,_,_),t' as TYNAME (id',_,_,_,_,_,_,_)) =
d888 1
a888 1
                    (tyname as TYNAME (stamp,name,_,ref eq,_,_,_,_)) =
d936 1
a936 1
    and debug_print_name (TYNAME (id,name,_,ref eq,ve,location,_,_)) =
d1604 1
a1604 1
    fun create_tyname_copy rigid =
d1607 2
a1608 1
                  METATYNAME (ref (NULL_TYFUN (id,tf)),printname,arity,ref eq, ref ve,ref is_abs)) =
d1616 2
a1617 1
                                ref ve,MLWorks.Option.NONE,ref is_abs,ref empty_valenv)
d1625 3
a1627 1
                  METATYNAME {1 = ref (ETA_TYFUN (meta as METATYNAME {1 = ref tyfun,...})),...}) =
d1631 2
a1632 1
          | copy (tyname_copies,TYNAME (id, name,arity, ref eq, ref ve1, loc, ref bool2, ref ve2)) =
d1634 3
a1636 1
                              TYNAME (Stamp.make_stamp (), name, arity, ref eq, ref ve1,loc, ref bool2, ref ve2))
d1641 4
a1644 2
    fun type_has_unbound_tyvars(METATYVAR (ref (_,ty,_),_,_)) = type_has_unbound_tyvars ty
      | type_has_unbound_tyvars (METARECTYPE (ref (_,false,ty,_,_))) = type_has_unbound_tyvars ty
d1906 3
a1908 2
       | copy_tyname (TYNAME(id,s,n,b,ve1 as ref(VE(n1,ve2)),s',abs,ve3 as ref(VE(_,ve4)))) =
         (TYNAME(id,s,n,b,ve1,s',abs,Lists.assoc(ve1,!ves))
d1911 2
a1912 1
              val ve'' = ref(VE(n1,NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
d1918 1
a1918 1
               TYNAME(id,s,n,b,ve1,s',abs,ve''))
d1931 2
a1932 1
        case copy_tyname(METATYNAME(dummy_tf,"",0,dummy_false,dummy_ve,dummy_false)) of
d2000 2
a2001 2
       and tyname_aux (tyname1 as TYNAME (_,_,_,_,_,_,_,ref ve1),
                       tyname2 as TYNAME (_,_,_,_,_,_,_,ref ve2)) =
@


1.115.2.1
log
@branched from 1.115
@
text
@a3 5
 * Revision 1.115  1996/08/05  14:16:31  andreww
 * [Bug #1521]
 * Prevent type variables being distinguished as imperative when using
 * value polymorphism.
 *
@


1.115.1.1
log
@branched from 1.115
@
text
@a3 5
 * Revision 1.115  1996/08/05  14:16:31  andreww
 * [Bug #1521]
 * Prevent type variables being distinguished as imperative when using
 * value polymorphism.
 *
@


1.114
log
@Improving tyfun_strip
@
text
@d4 3
d604 2
a605 1
    fun tyfun_strip(ETA_TYFUN (METATYNAME {1=ref tyfun, ...})) = tyfun_strip tyfun
d873 2
a874 1
    and print_name' options (tyname as TYNAME (stamp,name,_,ref eq,_,_,_,_)) =
d886 1
a886 1
        (if show_eq options then
d890 3
a892 2
      | print_name' options (METATYNAME (ref (NULL_TYFUN id),name,_,ref eq,_,_)) = 
        name ^ (if show_eq options then
d895 2
a896 2
      | print_name' options (METATYNAME (ref tyfun,name,_,_,_,_)) =
        name ^ (if show_eq options then
d900 6
a905 2
    and print_name (Options.PRINTOPTIONS {show_eq_info, ...}) t =
      print_name' {show_eq_info = show_eq_info} t
d949 1
a949 1
    and string_metatyvar (t as (METATYVAR (_,eq,imp)),depth,metastack) =
d951 3
d963 1
a963 1
	val imp_bit = if imp then "_" else ""
d967 1
a967 1
      | string_metatyvar (_,depth,metastack) =
d970 13
a982 5
    and string_debruijn (depth,eq,imp) =
      "'" ^ (if eq then "'" else "") ^ (if imp then "_" else "") ^
      (if do_debug then "deb-" else "") ^ make_string (depth+1)
      
    and string_constype (t as (CONSTYPE ([],name)),depth,stack,acc_string,_,option) = 
d984 1
a984 1
	(print_name' option name,depth,stack)
d986 4
a989 2
	("(" ^ acc_string ^ ")" ^ (print_name' option name),depth,stack)
	| string_constype (CONSTYPE ([h],name),depth,stack,acc_string,extras,option) =
d991 1
a991 1
	    val (s,depth,stack) = string_types (h,depth,stack,extras,option)
d997 1
a997 1
                    (String.implode ["(",s,") ",print_name' option name],depth,stack)
d999 1
a999 1
                  (String.implode [s," ",print_name' option name],depth,stack)
d1002 1
a1002 1
                        print_name' option name],
d1005 3
a1007 1
	| string_constype (CONSTYPE (h::t,name),depth,stack,acc_string,extras,option) =
d1009 1
a1009 1
	    val (s,depth,stack) = string_types (h,depth,stack,extras,option)
d1012 1
a1012 1
	      string_constype (CONSTYPE (t, name),depth,stack,s,extras,option)
d1014 2
a1015 2
	      string_constype (CONSTYPE (t,name),
			       depth,stack,acc_string ^ ", " ^ s,extras,option)
d1029 1
a1029 1
    and string_rectype (amap,flexible,depth,stack,extras,option) =
d1031 2
d1038 1
a1038 1
		string_types(t,!depth_ref,!stack_ref,extras,option)
d1076 1
a1076 1
	    if show_eq option then ("unit[t]",depth, stack)
d1101 6
a1106 5
    and string_types (t as (METATYVAR (ref(_,NULLTYPE,_),_,_)),depth,stack,_,option) =
      string_metatyvar (t,depth,stack)
      | string_types (METATYVAR (ref(_,t,_),_,_),depth,stack,extras,option) =
	string_types (t,depth,stack,extras,option)
      | string_types (META_OVERLOADED (ref NULLTYPE, tv, _, _),depth,stack,extras,option) =
d1108 9
a1116 8
      | string_types (META_OVERLOADED {1=ref t,...},depth,stack,extras,option) =
	string_types (t,depth,stack,extras,option)
      | string_types (METARECTYPE (ref (_,true,t as METARECTYPE _,_,_)),
		      depth,stack,extras,option) = 
	string_types (t,depth,stack,extras,option)
      | string_types (METARECTYPE (ref (_,true,RECTYPE amap,_,_)),depth,stack,extras,option) =
	string_rectype (amap,true,depth,stack,extras,option)
      | string_types (METARECTYPE (ref (_,true,_,_,_)),depth,stack,extras,option) =
d1118 6
a1123 5
      | string_types (METARECTYPE (ref(_,false,t,_,_)),depth,stack,extras,option) =
	string_types (t,depth,stack,extras,option)
      | string_types (DEBRUIJN (n,n',n'',_),depth,stack,_,option) =
	(string_debruijn (n,n',n''),depth,stack)
      | string_types (TYVAR (_,t),depth,stack,_,option) =
d1125 3
a1127 2
      | string_types (NULLTYPE,depth,stack,_,option) = ("Nulltype ",depth,stack)
      | string_types (FUNTYPE (a,r),depth,stack,extras,option) =
d1129 2
a1130 2
	  val (s,d,m) = string_types (a,depth,stack,extras,option)
	  val (s',d',m') = string_types (r,d,m,extras,option)
d1137 8
a1144 7
      | string_types (t as (CONSTYPE (_,_)),depth,stack,extras,option) =
	string_constype (t,depth,stack,"",extras,option)
      | string_types (RECTYPE amap,depth,stack,extras,option) =
        string_rectype (amap,false,depth,stack,extras,option)

    and print_type (Options.PRINTOPTIONS {show_eq_info, ...}) t =
      #1 (string_types (t,0,[],"",{show_eq_info = show_eq_info}))
d1146 2
a1147 1
    and debug_print_type t = #1 (string_types (t,0,[],"",debug_print_options))
d1364 4
a1367 3
    fun print_tyvars [] = ""
      | print_tyvars [tyvar] = debug_print_type tyvar
      | print_tyvars l =
d1369 6
a1374 5
          fun print_tyvars' [] = [")"]
            | print_tyvars' [tyvar] =
              [debug_print_type tyvar,")"]
            | print_tyvars' (tyvar::tyvars) =
              debug_print_type tyvar :: ", " :: print_tyvars' tyvars
d1376 1
a1376 1
          String.implode ("(" :: print_tyvars' l)
d1407 2
a1408 1
	  RECTYPE (NewMap.map (fn (_, x) => make_new_type (x,substlist)) amap)
d1417 1
a1417 1
	| make_new_type(ty as METATYVAR _, _) = ty
d1420 2
a1421 1
			   debug_print_type ty ^ "\n")
d1430 2
a1431 1
	    TYFUN (make_new_type (atype,substlist),Lists.length (tyvarlist))
d1497 2
a1498 1
      | tyvar_equalityp (METATYVAR (ref (_,t,_),eq,_)) = tyvar_equalityp t
d1500 3
a1502 1
        Crash.impossible ("tyvar_equalityp "^(debug_print_type t))
d1748 1
a1748 3
   fun print_type_with_seen_tyvars (Options.PRINTOPTIONS
				    {show_eq_info,...},
				    t,(stack,depth)) =
d1751 1
a1751 1
	 string_types (t,depth,stack,"",{show_eq_info = show_eq_info})
@


1.113
log
@Removing Crash.impossible in type_copy
@
text
@d4 3
d596 16
a611 9
    fun tyfun_strip(ETA_TYFUN(METATYNAME{1=ref tyfun, ...})) = tyfun_strip tyfun
      | tyfun_strip(tyfun as TYFUN(CONSTYPE(types, tyname), i)) =
	if tyname_arity tyname = i andalso check_debruijns(types, 0) 
          then
            case tyname of
              METATYNAME{1=ref tyfun, ...} => tyfun_strip tyfun
            | tyname => ETA_TYFUN tyname
	else
	  tyfun
d613 2
a614 2

    fun tyname_strip (METATYNAME{1=ref(ETA_TYFUN tyname), ...}) = tyname_strip tyname
d621 1
a621 6
    fun valid_to_string (Ident.VAR(sym)) = Ident.Symbol.symbol_name(sym)
      | valid_to_string (Ident.CON(sym)) = Ident.Symbol.symbol_name(sym)
      | valid_to_string (Ident.EXCON(sym)) = Ident.Symbol.symbol_name(sym)
      | valid_to_string _ = Crash.impossible "valid_to_string:types"

    fun has_ref_equality tyname =
d740 7
a746 1
      tyfun_eq'(tyfun_strip tyfun, tyfun_strip tyfun')
@


1.112
log
@Array moving to MLWorks.Array
@
text
@d4 3
d1613 1
a1613 1
      | type_copy (NULLTYPE, tyname_copies) = Crash.impossible "type_copy: NULLTYPE"
@


1.111
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d1110 1
a1110 1
      Array.sub (array_of_types,d)
d1144 1
a1144 1
	then app_subst (atype,Array.arrayoflist (tylist))
@


1.110
log
@Integer changes
@
text
@d4 3
d843 1
a843 1
      implode ["LAMBDA{", Int.toString n, "}.", extra_debug_print_type aty]
d845 1
a845 1
	implode ["ETA{", Int.toString (tyname_arity aname), "}.", debug_print_name aname]
d847 1
a847 1
	implode ["NULL_TYFUN", Stamp.string_stamp id]
d908 1
a908 1
	rep_chars (rep,chr char_no,"")
d954 1
a954 1
                    (implode ["(",s,") ",print_name' option name],depth,stack)
d956 1
a956 1
                  (implode [s," ",print_name' option name],depth,stack)
d958 1
a958 1
	      (implode ["(", acc_string, ", ", s, ") ", 
d1033 1
a1033 1
	      (implode ("(" :: (print_as_a_tuple [")"] len)),
d1040 1
a1040 1
		  (fn (lab,ty) => implode [IdentPrint.printLab lab,
d1050 1
a1050 1
		(implode list_with_commas,!depth_ref,!stack_ref)
d1175 1
a1175 1
	"CONSTYPE(" ^ implode(map extra_debug_print_type ty_list) ^ ", " ^
d1294 1
a1294 1
            chr (ord "a" + n)
d1296 1
a1296 1
            chr (ord "a" + (n mod 26)) ^ name (n div 26)
d1321 1
a1321 1
          implode ("(" :: print_tyvars' l)
@


1.109
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@d4 3
d373 2
d840 1
a840 1
      implode ["LAMBDA{", MLWorks.Integer.makestring n, "}.", extra_debug_print_type aty]
d842 1
a842 1
	implode ["ETA{", MLWorks.Integer.makestring (tyname_arity aname), "}.", debug_print_name aname]
d1001 1
a1001 1
							(MLWorks.Integer.makestring
d1013 1
a1013 1
						 (MLWorks.Integer.makestring n)))
d1151 1
a1151 1
      "METATYVAR(ref(" ^ MLWorks.Integer.makestring i ^ ", " ^ extra_debug_print_type ty ^
d1157 1
a1157 1
	"TYVAR(ref " ^ MLWorks.Integer.makestring i ^ ", " ^
d1160 1
a1160 1
	"METARECTYPE(ref(" ^ MLWorks.Integer.makestring i ^ ", " ^
d1175 1
a1175 1
	"DEBRUIJN(" ^ MLWorks.Integer.makestring i ^ ", " ^ print_bool b1 ^
@


1.108
log
@Replacing Map with NewMap
@
text
@d4 3
d473 2
a474 2
    val dynamic_tyname = make_tyname (0,false,"Dynamic",MLWorks.Option.NONE)
    val type_tyname = make_tyname (0,false,"Type",MLWorks.Option.NONE)
d525 1
a525 1
    val type_type = CONSTYPE ([],type_tyname)
@


1.107
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d637 1
a637 1
        RECTYPE (Mapping.mapit (map,simplify_type))
d645 3
a647 1
          
d678 1
a678 1
      | type_equalityp (RECTYPE amap) = Mapping.forall (amap,type_equalityp)
d683 2
d696 2
a697 1
      | closed_type_equalityp (RECTYPE amap) = Mapping.forall (amap,closed_type_equalityp)
d702 2
d804 1
a804 2
	Mapping.eqmaps (amap,amap',
			fn (x,y) => type_eq (x,y,eq_matters,imp_matters))
d986 1
a986 1
	  val len = Lists.length (Mapping.assoc amap)
d992 5
a996 5
		  Mapping.domain_member (Ident.LAB (Ident.Symbol.find_symbol
						    (MLWorks.Integer.makestring
						     n)),
					 amap)
		  andalso check_elem (n-1)
d1004 2
a1005 3
		  Mapping.lookup (Ident.LAB (Ident.Symbol.find_symbol
					     (MLWorks.Integer.makestring n)),
				  amap)
d1013 1
a1013 1
	    end
d1015 9
a1023 5
	    if len = 0 then
	      (* for the empty tuple, "()" is wrong.  "unit" can be
	       * redefined, but it's what people usually expect to see. *)
	      if show_eq option then ("unit[t]",depth, stack)
	      else ("unit",depth,stack)
d1025 16
a1040 20
	      if is_a_tuple then 
		(implode ("(" :: (print_as_a_tuple [")"] len)),
		 !depth_ref, !stack_ref)
	      else
		(* not a tuple, so print labels *)
		let
		  val named_list =
		    map
		    (fn (lab,ty) => implode [IdentPrint.printLab lab,
					     ": ", print_member ty])
		    (Mapping.assoc amap)
		  fun commas (_,[]) = 
		    Crash.impossible "Types.string_type.commas passed nil.\n"
		    | commas (acc,l as [x]) = rev ((if flexible then ", ...}" else "}")::x::acc)
		    | commas (acc,x::(xs as (y::ys))) =
		      commas (", "::x::acc, xs)
		  val list_with_commas = commas (["{"],named_list)
		in
		  (implode list_with_commas,!depth_ref,!stack_ref)
		end
d1095 1
a1095 3
	RECTYPE(Mapping.mapit
		(amap,
		 fn x => app_subst (x,array_of_types)))
d1156 5
a1160 2
	"RECTYPE(" ^ Mapping.print_map(map, IdentPrint.printLab, extra_debug_print_type,
				       ", ") ^ ")"
d1182 1
a1182 1
          (default_overloads, ty, error_fn) =
d1186 2
a1187 2
                   (r as ref NULLTYPE, tv, valid, loc)) =
          if default_overloads then
d1214 18
a1231 16
        |   resolve_ty (META_OVERLOADED {1=ref ty,...}) =
              resolve_ty ty
        |   resolve_ty (METATYVAR (ref (_,ty,_),_,_)) =
              resolve_ty ty
        |   resolve_ty (METARECTYPE (ref (_,true,ty as METARECTYPE _,_,_))) =
              resolve_ty ty
        |   resolve_ty (METARECTYPE (ref (_,_,ty,_,_))) =
              resolve_ty ty
        |   resolve_ty (RECTYPE amap) =
              (Mapping.mapit (amap,resolve_ty); ())
        |   resolve_ty (FUNTYPE(arg, res)) =
              (resolve_ty arg;
               resolve_ty res)
        |   resolve_ty (CONSTYPE (tylist, tyname)) =
             (map (fn x => resolve_ty x) tylist; ())
        |   resolve_ty ty = ()
d1250 1
a1250 1
      | imperativep (RECTYPE amap) = Mapping.forall (amap,imperativep)
d1255 3
a1257 1
    fun get_type_from_lab' (lab,RECTYPE amap) = Mapping.lookup (lab,amap)
d1266 1
a1266 1
      RECTYPE (Mapping.add((lab,value),amap,Ident.lab_order))
d1269 1
a1269 1
    val empty_rectype = RECTYPE (Mapping.empty_map)
d1272 1
a1272 1
      Mapping.domain amap
d1276 1
a1276 1
      Mapping.range amap
d1341 1
a1341 3
	  RECTYPE (Mapping.mapit
		   (amap,
		    fn x => make_new_type (x,substlist)))   
d1451 2
a1452 2
	(fn (_, ty') => type_occurs(ty, ty'))
	(Mapping.assoc lab_ty_map)
d1479 3
a1481 3
	Mapping.fold
	(fn (MLWorks.Option.NONE, ty) => has_free_imptyvars ty
         | (found, _) => found)
d1551 1
a1551 1
	Mapping.exists (amap, type_has_unbound_tyvars)
d1561 2
a1579 56
  (*
    fun t_copy tyname_copies =
      let
	fun copy_type (METATYVAR (ref (_,ty,_),_,_)) = copy_type ty
	  | copy_type (METARECTYPE (ref (_,false,ty,_,_))) = copy_type ty
	  | copy_type (METARECTYPE (ref (_,true,ty,_,_))) = Crash.impossible "Types.type_copy"
	  | copy_type (RECTYPE amap) = RECTYPE(Mapping.mapit(amap, copy_type))
	  | copy_type (FUNTYPE (ty,ty')) = FUNTYPE(copy_type ty, copy_type ty')
	  | copy_type (CONSTYPE (l, name)) =
	    CONSTYPE(map copy_type l, tyname_copy name)
	  | copy_type (ty as (TYVAR _)) = ty
	  | copy_type (ty as (DEBRUIJN _)) = ty
	  | copy_type (META_OVERLOADED {1=ref ty, ...}) = ty
	  | copy_type NULLTYPE = Crash.impossible "Types.type_copy"

	and tyname_copy (tyname as METATYNAME {1 = ref (NULL_TYFUN (id,_)), ...}) =
	  Stamp.Map.apply_default'(tyname_copies, tyname, id)
	  | tyname_copy (METATYNAME {1 = ref (ETA_TYFUN meta), ...}) =
	    tyname_copy meta
	  | tyname_copy (METATYNAME(ref tyfun, name, a, ref eq, ref ve,ref is_abs)) =
	    METATYNAME(ref (copy_tyfun tyfun), name, a, ref eq, ref ve,ref is_abs)
	  | tyname_copy tyname = tyname

	and copy_tyfun (ETA_TYFUN (meta as METATYNAME {1=ref(NULL_TYFUN _), ...})) =
	  ETA_TYFUN (tyname_copy meta)
	  | copy_tyfun (ETA_TYFUN (METATYNAME{1 = ref tyfun, ...})) = copy_tyfun tyfun
	  | copy_tyfun (TYFUN(CONSTYPE([], tyname), a)) = copy_tyfun(ETA_TYFUN tyname)
	  | copy_tyfun (TYFUN(ty, a)) = TYFUN(copy_type ty, a)
	  | copy_tyfun tyfun = tyfun

      in
	(fn t => ((* MLWorks.Debugger.break "copy_type";*) copy_type t), tyname_copy, copy_tyfun)
      end

    fun type_copy(ty, copies) =
      let
	val (copy, _, _) = t_copy copies
      in
	copy ty
      end

    fun tyname_copy(tyname, copies) =
      let
	val (_, copy, _) = t_copy copies
      in
	copy tyname
      end

    fun tyfun_copy(tyfun, copies) =
      let
	val (_, _, copy) = t_copy copies
      in
	copy tyfun
      end
    *)

d1583 2
a1584 1
      | type_copy (RECTYPE amap,tyname_copies) = RECTYPE(Mapping.mapit (amap, fn ty => type_copy(ty,tyname_copies)))
d1616 13
a1628 13
   fun tyvars (tyvarlist, METATYVAR (ref (_,NULLTYPE,_),_,_)) = tyvarlist
     | tyvars (tyvarlist, METATYVAR (ref (_,atype,_),_,_)) = 
       tyvars (tyvarlist, atype)
     | tyvars (tyvarlist, TYVAR (_,tyvar)) = tyvar :: tyvarlist
     | tyvars (tyvarlist, METARECTYPE (ref (_,_,atype,_,_))) =
       tyvars (tyvarlist, atype)
     | tyvars (tyvarlist, RECTYPE amap) = 
       Mapping.fold
       tyvars
       (tyvarlist, amap)
     | tyvars (tyvarlist, FUNTYPE (atype,atype')) = 
       tyvars (tyvars (tyvarlist, atype), atype')
     | tyvars (tyvarlist, CONSTYPE (tylist,_)) =
d1630 3
a1632 1
     | tyvars (tyvarlist, _) = tyvarlist
d1634 1
a1634 1
   local
d1644 2
a1645 2
         Mapping.fold
         tyvars
d1653 3
d1707 3
a1709 4
         RECTYPE(Mapping.Fold
                 (fn lab => fn ty => fn map =>
                  Mapping.add ((lab,copy_type ty),map,Ident.lab_order))
                 Mapping.empty_map map)
a1748 4
          (*
           NewMap.fold (fn (map,valid,sch) => NewMap.define(map,valid,copy_typescheme sch))
           (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
              *)
a1779 4
         (*
          NewMap.fold (fn (map,valid,sch) =>NewMap.define(map,valid,copy_typescheme sch))
          (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
               *)
a1809 4
         (*
          NewMap.fold (fn (map,valid,sch) =>NewMap.define(map,valid,copy_typescheme sch))
          (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
               *)
d1870 11
d1885 5
a1889 4
               if lab1 = lab2
                 then merge (rest,Mapping.add ((lab1,aux (ty1,ty2)),map,Ident.lab_order))
               else raise CombineTypes
                 | merge ([],map) = map
d1891 1
a1891 1
             RECTYPE (merge (Lists.zip (assoc1,assoc2),Mapping.empty_map))
d1893 1
@


1.106
log
@Modify has_free_imptyvars to return the offending tyvar if it exists
Add type_occurs to find if such a type occurs within another more
complicated type
@
text
@d4 5
d445 24
a468 24
    val bool_tyname = make_tyname (0,true,"bool",Option.ABSENT)
    val int_tyname = make_tyname (0,true,"int",Option.ABSENT)
    val word_tyname = make_tyname (0,true,"word",Option.ABSENT)
    val int8_tyname = make_tyname (0,true,"int8",Option.ABSENT)
    val word8_tyname = make_tyname (0,true,"word8",Option.ABSENT)
    val int16_tyname = make_tyname (0,true,"int16",Option.ABSENT)
    val word16_tyname = make_tyname (0,true,"word16",Option.ABSENT)
    val int32_tyname = make_tyname (0,true,"int32",Option.ABSENT)
    val word32_tyname = make_tyname (0,true,"word32",Option.ABSENT)
    val int64_tyname = make_tyname (0,true,"int64",Option.ABSENT)
    val word64_tyname = make_tyname (0,true,"word64",Option.ABSENT)
    val real_tyname = make_tyname (0,true,"real",Option.ABSENT)
    val float32_tyname = make_tyname (0,true,"float32",Option.ABSENT)
    val string_tyname = make_tyname (0,true,"string",Option.ABSENT)
    val char_tyname = make_tyname (0,true,"char",Option.ABSENT)
    val list_tyname = make_tyname (1,true,"list",Option.ABSENT)
    val ref_tyname = make_tyname (1,true,"ref",Option.ABSENT)
    val exn_tyname = make_tyname (0,false,"exn",Option.ABSENT)
    val ml_value_tyname = make_tyname (0,true,"ml_value",Option.ABSENT)
    val array_tyname = make_tyname (1,true,"array",Option.ABSENT)
    val vector_tyname = make_tyname (1,true,"vector",Option.ABSENT)
    val bytearray_tyname = make_tyname (0,true,"bytearray",Option.ABSENT)
    val dynamic_tyname = make_tyname (0,false,"Dynamic",Option.ABSENT)
    val type_tyname = make_tyname (0,false,"Type",Option.ABSENT)
d1310 1
a1310 1
	    val new_debruijn = DEBRUIJN (n,true,true,Option.ABSENT) (* arbitrary choice *)
d1518 1
a1518 1
                                ref ve,Option.ABSENT,ref is_abs,ref empty_valenv)
d1691 1
a1691 1
       | tyvars (tyvarlist, DEBRUIJN(_,_,_,Option.PRESENT(tyvar))) = tyvar::tyvarlist
@


1.105
log
@Extended check on free type variables to include non-imperative tyvars.
These shouldn't occur with normal semantics and should be caught with
value-polymorphism semantics.
@
text
@d4 5
d1416 30
d1451 2
a1452 1
    fun has_free_imptyvars (METATYVAR (ref (_,NULLTYPE,_),_,_)) = true
d1454 2
a1455 1
      | has_free_imptyvars (TYVAR (_,Ident.TYVAR (_,_,_))) = true
d1458 2
a1459 1
      | has_free_imptyvars (METARECTYPE (ref (_,true,_,_,imp))) = imp
d1463 4
a1466 1
	Mapping.exists (amap,has_free_imptyvars)
d1468 3
a1470 1
	has_free_imptyvars (arg) orelse has_free_imptyvars (res)
d1473 5
a1477 2
	  fun collect ([]) = false
	    | collect (h::t) = has_free_imptyvars (h) orelse collect (t)
d1481 1
a1481 1
      | has_free_imptyvars _ = false
@


1.104
log
@Removing a compiler fault that can happen with error recoveru
@
text
@d4 3
d1414 3
a1416 2

    fun has_free_imptyvars (METATYVAR (ref (_,NULLTYPE,_),_,imp)) = imp
d1418 1
a1418 1
      | has_free_imptyvars (TYVAR (_,Ident.TYVAR (_,_,imp))) = imp
d1584 1
a1584 1
      | type_copy (NULLTYPE, tyname_copies) = Crash.impossible "Types.type_copy"
@


1.103
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
d1102 3
a1104 3
      | app_subst (ty,_) = 
	Crash.impossible ("Types.app_subst " ^ (debug_print_type ty))
	  
@


1.102
log
@Add has_int_equality, has_real_equality, has_string_equality
@
text
@d4 3
d431 9
d441 1
a443 1
    val word_tyname = make_tyname (0,true,"word",Option.ABSENT)
d454 11
d486 9
d496 1
a498 1
    val word_type = CONSTYPE ([],word_tyname)
d505 7
d519 5
a523 1
      | type_of (Ident.REAL _) = real_type
d526 5
a530 1
      | type_of(Ident.WORD _) = word_type
d584 2
d587 2
d592 2
a593 1
      tyname_eq(tyname, real_tyname)
d596 5
a600 1
      tyname_eq(tyname, string_tyname)
d816 1
d822 1
a822 1
          else name
d1163 1
a1163 2
            if tv = Ident.int_tyvar orelse
               tv = Ident.int_literal_tyvar then
d1168 2
a1173 3
            else if tv = Ident.word_tyvar orelse
	       tv = Ident.word_literal_tyvar then
              (r := word_type)
d1175 3
a1177 1
              (r := word_type)
d1182 1
a1182 1
	      (r := int_type)
d1184 1
a1184 1
	      (r := real_type)
d1186 1
a1186 1
	      (r := word_type)
d1358 6
a1363 1
    fun int_typep (CONSTYPE ([],name)) = tyname_eq(name,int_tyname)
d1368 2
a1369 1
      tyname_eq(name,real_tyname)
d1374 5
a1378 1
      tyname_eq(name,word_tyname)
d1382 2
a1383 2
    fun num_typep (ty as CONSTYPE ([],name)) =
      tyname_eq (name,real_tyname) orelse int_typep ty orelse tyname_eq(name, word_tyname)
d1396 2
@


1.101
log
@Add bytearray to has_ref_equality
@
text
@d4 3
d534 11
@


1.100
log
@Sort out resolve_overloading to handle word types
@
text
@d4 3
d529 2
a530 1
      tyname_eq(array_tyname, tyname)
@


1.99
log
@Add word_typep and wordint_typep
@
text
@d4 3
d1098 5
d1110 2
a1119 4
        (*
        |   resolve_ty (ty as METARECTYPE (ref (_,true,_,_,_))) =
              raise MakeScheme ("Unresolved flexible record of type ",ty)
        *)
@


1.98
log
@Fix word_type to refer to word_tyname
@
text
@d4 3
d1286 5
d1303 2
@


1.97
log
@Add word literal support
@
text
@d4 3
d454 1
a454 1
    val word_type = CONSTYPE ([],char_tyname)
@


1.96
log
@Add word_type and word_tyname
@
text
@d4 3
d468 1
@


1.95
log
@Add Ident.CHAR to type_of function
@
text
@d4 3
d413 1
d448 1
d1277 1
a1277 1
      tyname_eq (name,real_tyname) orelse int_typep ty
d1283 2
a1284 1
      tyname_eq(name, char_tyname) orelse num_typep ty
@


1.94
log
@Add char type for new revised basis
@
text
@d4 3
d443 1
d459 1
@


1.93
log
@Removing special case for printing bytearray type
@
text
@d4 3
d406 1
d1272 2
a1273 1
      tyname_eq(name, string_tyname) orelse num_typep ty
@


1.92
log
@Added simplify_type function
@
text
@d4 3
a719 1
          else if tyname_eq (tyname,bytearray_tyname) then "bytearray"
@


1.91
log
@stuff
@
text
@d4 3
a493 3
    (* What is this for? *)
    val ves : Valenv ref list ref = ref []

d498 25
d709 12
a720 2
    and print_name' options (TYNAME (_,name,_,ref eq,_,_,_,_)) =
	name ^ 
d724 1
d739 10
a748 14
        ("[" ^ (("VE:"^MLWorks.Integer.makestring (Lists.find(ve,!ves)+1) ^
                 (if NewMap.is_empty map then ":EMPTY" else ":FULL"))
                handle Lists.Find =>
                  (ves := (!ves) @@ [ve];
                   "VE%"^MLWorks.Integer.makestring(Lists.length(!ves)) ^ ":" ^
                   NewMap.fold 
                   (fn (str,v,t) => 
                    str^"\n"^valid_to_string v^":"^
                    (case t of
                       SCHEME(_,(t,_))=>"SCHEME:"^extra_debug_print_type t
                     | UNBOUND_SCHEME(t,_)=>"UNBOUND_SCHEME:"^extra_debug_print_type t
                     | OVERLOADED_SCHEME _ => "OVERLOADED_SCHEME"))
                   ("",map))) ^
        "]")
d1091 1
a1091 1
              (Mapping.mapit (amap, (fn x => resolve_ty x)); ())
d1257 1
a1257 2
      | real_typep (META_OVERLOADED {1=ref t,...}) =
      int_typep t
a1277 159
     eq_and_imp does the manipulation of the equality and imperative attributes
     during unification.
     ****)

    fun eq_and_imp (eq,imp,(TYVAR (_,Ident.TYVAR (_,eq',imp')))) = 
      if eq 
	then (eq' andalso (if imp
			     then imp' 
			   else true))
      else (if imp
	      then imp'
	    else true)
      | eq_and_imp (eq,imp,FUNTYPE (a,r)) =
	if eq 
	  then false 
	else (eq_and_imp (eq,imp,a)) andalso (eq_and_imp (eq,imp,r))
      | eq_and_imp (eq,imp,DEBRUIJN (_,eq',imp',_)) =
	if eq 
	  then (eq' andalso (if imp
			       then imp' 
			     else true))
	else (if imp
		then imp'
	      else true)
      | eq_and_imp (eq,imp,
		    CONSTYPE (tylist,METATYNAME{1 = ref tyfun,
                                                4 = ref eq',...})) =
	(eq_and_imp (eq,imp,apply (tyfun,tylist))
	 handle NullTyfun =>
           let fun collect [] = true
                 | collect (h::t) = eq_and_imp (eq,imp,h) andalso (collect t)
           in
             ((not eq) 
              orelse
              (eq' andalso collect tylist))
           end)
      | eq_and_imp (eq,imp,CONSTYPE ([],name)) =
	if eq 
	  then eq_attrib name
	else true
      | eq_and_imp (eq,imp,CONSTYPE ([h],name)) =
	if eq then
	  if has_ref_equality name then
	    eq_and_imp (false,imp,h)
	  else eq_attrib name andalso eq_and_imp (eq,imp,h)
	else eq_and_imp (eq,imp,h)
      | eq_and_imp (eq,imp,CONSTYPE (t,n)) = 
	let fun collect [] = true
	      | collect (h::t) = eq_and_imp (eq,imp,h) andalso (collect t)
	in
	  ((not eq) orelse (eq_attrib n)) andalso (collect(t))
	end
      | eq_and_imp (eq,imp,RECTYPE amap) = 
	Mapping.forall (amap,fn x => eq_and_imp (eq,imp,x)) 
      | eq_and_imp (eq,imp,NULLTYPE) = true
      | eq_and_imp (eq,imp,METATYVAR (x as ref (n,NULLTYPE,i),eq',imp')) =
	if (eq andalso not eq') orelse (imp andalso not imp')
	  then (x := (n,
		      METATYVAR (ref (n,NULLTYPE,NO_INSTANCE),
				 eq orelse eq',imp orelse imp'),i);
		true)
	else true
      | eq_and_imp (eq,imp,METATYVAR (ref (_,t,_),eq',imp')) =
	if (eq andalso not eq') orelse (imp andalso not imp')
	  then (eq_and_imp (eq,imp,t))
	else true
      | eq_and_imp (eq,imp,META_OVERLOADED _) = true
      | eq_and_imp (eq,imp,METARECTYPE (r as ref (n,true,t,eq',imp'))) =
	if (eq andalso not eq') orelse (imp andalso not imp')
	  then (r := (n,true,t,eq orelse eq',imp orelse imp');
		true)
	else true
      | eq_and_imp (eq,imp,METARECTYPE (r as ref (n,false,t,eq',imp'))) =
	if (eq andalso not eq') orelse (imp andalso not imp')
	  then (eq_and_imp (eq,imp,t))
	else true
      
    (****
     Occurs check in unification.
     ****)

    (* was - not_occurs (ameta,TYVAR _) = true  - changed 28/5/91 *)
          
    fun not_occurs_tyfun (ty,TYFUN (ty',_)) =
      not_occurs (ty,ty')
      | not_occurs_tyfun (ty,ETA_TYFUN tyname) =
        not_occurs_tyname (ty,tyname)
      | not_occurs_tyfun (ty,NULL_TYFUN _) =
        true
    and not_occurs_tyname (ty,TYNAME _) = true
      | not_occurs_tyname (ty,METATYNAME (ref tyfun,_,_,_,_,_)) =
        not_occurs_tyfun (ty,tyfun)
    and not_occurs (METATYVAR (ref (tyv as (n,_,_)),_,_),
                    TYVAR (r' as ref (n',_,_),_)) =
      (n > n')
      orelse
      (r' := tyv;
       true)
      | not_occurs (ameta,TYVAR _) = true
      | not_occurs (ameta,FUNTYPE(a,r)) = 
        not_occurs (ameta,a) andalso not_occurs (ameta,r)
      | not_occurs (ameta,t as DEBRUIJN _) = true
      | not_occurs (ameta,CONSTYPE (tylist,tyname)) =
        not_occurs_tyname (ameta, tyname)
        andalso
        Lists.forall (fn x => not_occurs(ameta,x)) tylist
      | not_occurs (ameta,RECTYPE amap)	= 
        Mapping.forall (amap,fn x => not_occurs (ameta,x)) 
      | not_occurs (ameta,NULLTYPE) = true
      | not_occurs (ameta as METATYVAR (ref (n,NULLTYPE,i),_,_),
		    ameta' as METATYVAR (x as ref (n',NULLTYPE,_),_,_)) = 
	if (type_eq (ameta,ameta',true,true))
	  then false
	else
	  (n > n') 
	  orelse
	  (x := (n,NULLTYPE,i);
	   true)
      | not_occurs (ameta as METATYVAR (ref (n,_,i),_,_),
		    ameta' as METATYVAR (x as ref (n',NULLTYPE,_),_,_)) = 
        if (type_eq (ameta,ameta',true,true))
          then false
        else
          (n > n') 
          orelse
	(x := (n,NULLTYPE,i);
	 true)
      | not_occurs (ameta,t as METATYVAR (ref (_,NULLTYPE,_),eq',imp')) =
	not (type_eq (ameta,t,true,true))
      | not_occurs (ameta as METATYVAR (ref (n,_,i),_,_),
		    METATYVAR (x as ref (n',t,_),_,_)) = 
	(if (n > n') then () else x := (n,t,i);
	  not_occurs (ameta,t))
      | not_occurs (ameta,METATYVAR (ref (_,t,_),_,_)) = not_occurs (ameta,t)
      | not_occurs (ameta,META_OVERLOADED _) = true
      | not_occurs (ameta,t as METARECTYPE (ref (_,true,arec,_,_))) = 
        not_occurs (ameta,arec)
      | not_occurs (ameta,METARECTYPE (ref (_,false,t,_,_))) = 
        not_occurs (ameta,t)

    fun propagate_level level
      (recty as (METARECTYPE (r as ref (level',flex,ty,eq,imp)))) =
      (if level < level'
         then r := (level, flex, propagate_level level ty, eq, imp)
       else ();
       recty)

      | propagate_level level (RECTYPE amap) = 
	RECTYPE (Mapping.mapit (amap, propagate_level level))
      | propagate_level level (ty as (METATYVAR (r as ref (level',t,i),_,_))) =
        (if level < level' 
	   then r := (level,propagate_level level t,i)
	 else ();
	 ty)
	   
      | propagate_level _ ty = 
        ty

    (****
d1538 1
a1538 1
   val tyfun_instantiations : Tyfun list ref = ref []
d1541 3
d1678 25
a1702 41
         let
           (*val _ =
            if NewMap.is_empty ve4 then
              output(std_out,"\n EMPTY TYNAME \n")
             else
               output(std_out,"\n FULL TYNAME \n")*)
           val (ve',ve,n') = (ve1,ve2,n1)
         in
           (TYNAME(id,s,n,b,ve',s',abs,Lists.assoc(ve',!ves))
            handle Lists.Assoc =>
              let
                val ve'' = ref(VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
                val map =
                  (ves := (ve',ve'')::(!ves);
                   NewMap.map (fn (valid,sch) => copy_typescheme sch) ve)
              (*
               NewMap.fold (fn (map,valid,sch) =>
               NewMap.define(map,valid,copy_typescheme sch))
               (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
                  *)
              in
                (ve'' := VE(n',map);
                 TYNAME(id,s,n,b,ve',s',abs,ve''))
              end)
         end
          local
            val dummy_false = ref(false)
            val dummy_ve = ref(empty_valenv)
            val dummy_tf = ref(TYFUN(NULLTYPE,0))
          in
            fun copy_tyfun tyf =
              (dummy_tf := tyf;
               ves := [];
               tys1 := [];
               tys2 := [];
               tys3 := [];
               tfs := [];
               case copy_tyname(METATYNAME(dummy_tf,"",0,dummy_false,dummy_ve,dummy_false)) of
                 METATYNAME(ref(tf),_,_,_,_,_) => tf
               | _ => Crash.impossible "copy_tyfun:generate_moduler:core_rules")
          end
a1703 1

@


1.90
log
@Ensure that arrays have reference semantics with respect to equality
@
text
@d4 3
d317 1
d325 1
d329 2
d348 2
a349 3
    type PrintTypeOptions = {
           show_eq_info : bool
         }
d356 1
a356 5
      TYNAME (Tyname_id.make_tyname_id (),pname,n,ref eq, ref empty_valenv,location,ref false,ref empty_valenv)

    fun get_tyname_id (TYNAME (id,_,_,_,_,_,_,_)) = id
      | get_tyname_id (METATYNAME _) =
          Crash.impossible"get_tyname_id METATYNAME"
d391 1
a391 2
    val _ = Tyname_id.reset_counter 0
    val _ = Tyfun_id.reset_counter 0
d407 1
a407 2
    val pervasive_tyname_count = Tyname_id.read_counter ()
    val pervasive_tyfun_count = Tyfun_id.read_counter ()
d436 2
d458 1
a458 2
      | the_type (METARECTYPE (ref (_,true,atype as METARECTYPE _,_,_))) = 
        the_type atype
d468 7
a474 8
    fun tyfun_strip(ETA_TYFUN(METATYNAME{1=ref tyfun, ...})) =
      tyfun_strip tyfun
      | tyfun_strip(tyfun as
		    TYFUN(CONSTYPE(types, tyname), i)) =
	if tyname_arity tyname = i andalso check_debruijns(types, 0) then
	  case tyname of
	    METATYNAME{1=ref tyfun, ...} => tyfun_strip tyfun
	  | tyname => ETA_TYFUN tyname
d479 5
a483 8
    fun tyname_strip(METATYNAME{1=ref(ETA_TYFUN tyname), ...}) =
      tyname_strip tyname
      | tyname_strip(tyname as METATYNAME{1=ref(TYFUN(CONSTYPE(types, tyname'),
						      i)), ...})=
	if tyname_arity tyname = i andalso check_debruijns(types, 0) then
	  tyname_strip tyname'
	else
	  tyname
d491 2
a492 1
    val ves : Valenv ref list ref = ref([])
d506 1
d511 1
a511 1
	 | _ => type_strip(apply(tyfun, l)))
d556 3
a558 1
	
d562 2
a563 3

      and tyfun_eq' (t as TYFUN (atype,a),t' as TYFUN (atype',a')) =
        (a = a' andalso type_eq (atype,atype',false,false))
d566 3
a568 7
        Tyname_id.tyname_id_eq(tyname_id, tyname_id')

      | tyfun_eq' (t as NULL_TYFUN (id,_),t' as NULL_TYFUN (id',_)) =
	id = id'

      | tyfun_eq' (tyfun,tyfun') =
	false
d574 1
a574 1
      (*Tyname_id.tyname_id_eq (id,id')*) id = id'
d676 1
d678 1
a678 2
        "LAMBDA{" ^ (MLWorks.Integer.makestring n) ^ "}." ^
	  (extra_debug_print_type aty)
d680 1
a680 2
	"ETA{" ^ (MLWorks.Integer.makestring (tyname_arity aname)) ^ "}." ^
	(debug_print_name aname)
d682 1
a682 1
	"NULL_TYFUN" ^ (Tyfun_id.string_tyfun_id id)
d701 27
a727 37
    and debug_print_name (TYNAME (id,name,_,ref eq,ve' as ref(VE(_,ve)),location,_,_)) =
	name ^ "(" ^ MLWorks.Integer.makestring(Tyname_id.tyname_id id) ^ ")" ^
	(if eq then "[t]" else "[f]")^
           (if generate_moduler_debug then
             ("["^(("VE:"^MLWorks.Integer.makestring(Lists.find(ve',!ves)+1)^(if NewMap.is_empty ve then ":EMPTY" else ":FULL"))
handle Lists.Find =>
(ves := (!ves)@@[ve']; "VE%"^MLWorks.Integer.makestring(Lists.length(!ves))^":"^
           NewMap.fold (fn (str,v,t)=>str^"\n"^valid_to_string v^":"^
                                         (case t of
                                            SCHEME(_,(t,_))=>"SCHEME:"^extra_debug_print_type t
                                          | UNBOUND_SCHEME(t,_)=>"UNBOUND_SCHEME:"^extra_debug_print_type t
                                          | OVERLOADED_SCHEME _ => "OVERLOADED_SCHEME")) ("",ve)))^"]")
            else "")
      | debug_print_name (METATYNAME (tf as ref (NULL_TYFUN (id,_)),name,_,ref eq,ve' as ref(VE(_,ve)),_)) = 
        name ^ Tyfun_id.string_tyfun_id id ^ (if eq then "[t]" else "[f]")^"["^string_tyfun(!tf)^"]"^
        (if generate_moduler_debug then
             ("["^(("VE:"^MLWorks.Integer.makestring(Lists.find(ve',!ves)+1))
handle Lists.Find =>
(ves := (!ves)@@[ve'];"VE%"^MLWorks.Integer.makestring(Lists.length(!ves))^":"^
           NewMap.fold (fn (str,v,t)=>str^"\n"^valid_to_string v^":"^
                                         (case t of
                                            SCHEME(_,(t,_))=>"SCHEME:"^extra_debug_print_type t
                                          | UNBOUND_SCHEME(t,_)=>"UNBOUND_SCHEME:"^extra_debug_print_type t
                                          | OVERLOADED_SCHEME _ => "OVERLOADED_SCHEME")) ("",ve)))^"]")
         else "")
      | debug_print_name (METATYNAME (ref tyfun,name,_,_,ve' as ref(VE(_,ve)),_)) =
	"METATYNAME(" ^ name ^ "{" ^ string_tyfun tyfun ^ "}" ^ ")"^
        (if generate_moduler_debug then
             ("["^(("VE:"^MLWorks.Integer.makestring(Lists.find(ve',!ves)+1))
handle Lists.Find =>
(ves := (!ves)@@[ve'];"VE%"^MLWorks.Integer.makestring(Lists.length(!ves))^":"^
           NewMap.fold (fn (str,v,t)=>str^"\n"^valid_to_string v^":"^
                                         (case t of
                                            SCHEME(_,(t,_))=>"SCHEME:"^extra_debug_print_type t
                                          | UNBOUND_SCHEME(t,_)=>"UNBOUND_SCHEME:"^extra_debug_print_type t
                                          | OVERLOADED_SCHEME _ => "OVERLOADED_SCHEME")) ("",ve)))^"]")
         else "")
d1449 1
a1449 7
    fun copy_metatyname (METATYNAME(ref(NULL_TYFUN id), printname,
				     arity,ref eq, ref ve,ref is_abs)) =
      METATYNAME (ref (NULL_TYFUN id),printname,arity, ref eq, ref ve,ref is_abs)
      | copy_metatyname _ = Crash.impossible "Types.copy_metatyname"

    fun new_metatyname (METATYNAME (ref (NULL_TYFUN (id',tf)),printname,
				    arity,ref eq, ref ve,ref is_abs)) =
d1451 24
a1474 2
        (*val _ = output(std_out,"\n"^Tyfun_id.string_tyfun_id id'^"->"^Tyfun_id.string_tyfun_id id)*)
        (*val _ = tfs := (id,new_tf):: !tfs*)
d1476 1
a1476 2
        METATYNAME (ref (NULL_TYFUN (Tyfun_id.make_tyfun_id (),tf)),printname,
                    arity,ref eq, ref ve,ref is_abs)
a1477 14
      | new_metatyname _ = Crash.impossible "Types.new_metatyname"

    fun create_tyname_copies (meta as METATYNAME {1=ref (NULL_TYFUN (id,_)), ...}, tyname_copies,copy_fun) =
        (case Tyfun_id.Map.tryApply'(tyname_copies,id) of
	   MLWorks.Option.SOME _ => tyname_copies
	 | MLWorks.Option.NONE =>
	     Tyfun_id.Map.define(tyname_copies, id, copy_fun meta))

      | create_tyname_copies (METATYNAME {1 = ref (ETA_TYFUN 
	                                  (meta as METATYNAME 
					   {1 = ref tyfun,...})),...},
		     tyname_copies,copy_fun) =
	create_tyname_copies (meta,tyname_copies,copy_fun)
      | create_tyname_copies (_, tyname_copies,_) = tyname_copies
d1509 1
d1525 1
a1525 1
	  Tyfun_id.Map.apply_default'(tyname_copies, tyname, id)
d1563 36
d1665 1
d1669 159
a1827 160
          val ves : (Valenv ref * Valenv ref) list ref = ref []
          val tys1 : ((int * Type * Instance) ref
                      * (int * Type * Instance) ref) list ref = ref []
          val tys2 : (Type ref * Type ref) list ref = ref []
          val tys3 : ((int * bool * Type * bool * bool) ref
                      * (int * bool * Type * bool * bool) ref) list ref = ref []
          val tfs : (Tyfun ref * Tyfun ref) list ref = ref []
        in
          fun copy_type(CONSTYPE(tys,tyn)) =
                CONSTYPE(Lists.reducel
                                   (fn (tys,ty)=>copy_type(ty)::tys) (nil, tys),
                                   copy_tyname tyn)
              | copy_type (FUNTYPE(ty1,ty2)) = FUNTYPE(copy_type ty1,copy_type ty2)
              | copy_type (RECTYPE(map)) =
                    RECTYPE(
                    Mapping.Fold
                    (fn lab => fn ty => fn map =>
                     Mapping.add ((lab,copy_type ty),map,Ident.lab_order))
                    Mapping.empty_map map)
              | copy_type (tyv as METATYVAR(ty1 as ref(n,ty,i),b1,b2)) =
                (METATYVAR(Lists.assoc(ty1,!tys1),b1,b2)
                 handle Lists.Assoc => 
                   (tys1 := (ty1,ty1)::(!tys1);
                    ty1 := (n,copy_type ty,i);
                    tyv))
              | copy_type
		  (ovty as META_OVERLOADED
		     (ty1 as ref(ty),tv,valid,loc)) =
                (META_OVERLOADED(Lists.assoc(ty1,!tys2),tv,valid,loc)
                 handle Lists.Assoc =>
                     (tys2 := (ty1,ty1)::(!tys2);
                      ty1 := copy_type ty;
                      ovty))
              | copy_type (tyv as TYVAR(ty1 as ref(n,ty,i),id)) =
                (TYVAR(Lists.assoc(ty1,!tys1),id)
                 handle Lists.Assoc =>
                   (tys1 := (ty1,ty1)::(!tys1);
                    ty1 := (n,copy_type ty,i);
                    tyv))
              | copy_type (recty as METARECTYPE(ty1 as ref(n,b1,ty,b2,b3))) =
                (METARECTYPE(Lists.assoc(ty1,!tys3))
                 handle Lists.Assoc =>
                   (tys3 := (ty1,ty1)::(!tys3);
                    ty1 := (n,b1,copy_type ty,b2,b3);
                    recty))
              | copy_type ty = ty
            and copy_typescheme (SCHEME(n,(ty,i))) = SCHEME(n,(copy_type ty,i))
              | copy_typescheme (UNBOUND_SCHEME(ty,i)) = UNBOUND_SCHEME(copy_type ty,i)
              | copy_typescheme sch = sch
            and copy_tyname
                  (m as METATYNAME(tf as ref(NULL_TYFUN(_)),name,n,b,
                                             ve' as ref(VE(n',ve)),abs)) =
                     (METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs)
                      handle Lists.Assoc =>
                        let
                          val map =
                           (ves := (ve',ve')::(!ves);
                            NewMap.map (fn (valid,sch) => copy_typescheme sch) ve)
(*
                            NewMap.fold (fn (map,valid,sch) => NewMap.define(map,valid,copy_typescheme sch))
                            (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
*)
                        in
                          (ve' := VE(n',map);
                           METATYNAME(tf,name,n,b,ve',abs))
                        end)
              | copy_tyname (METATYNAME(tf as ref(ETA_TYFUN(tyn)),name,n,b,
                                                          ve' as ref(VE(n',ve)),abs)) =
                     let
                       val (tf1,tf_encountered) =
                         (Lists.assoc(tf,!tfs),true)
                         handle Lists.Assoc =>
                           (tf,false)
                       val (ve'',ve_encountered) =
                         (Lists.assoc(ve',!ves),true)
                         handle Lists.Assoc =>
                           (ve',false)
                       val _ =
                         if tf_encountered then ()
                         else
                           tfs := (tf,tf1)::(!tfs)
                       val _ =
                         if ve_encountered then ()
                         else
                           ves := (ve',ve'')::(!ves)
                       val _ =
                         if tf_encountered then ()
                         else
                           tf1 := ETA_TYFUN(copy_tyname tyn)
                       val _ =
                         if ve_encountered then ()
                         else
                            ve'' := VE(n',NewMap.map (fn (valid,sch) => copy_typescheme sch) ve)
(*
                                       NewMap.fold (fn (map,valid,sch) =>NewMap.define(map,valid,copy_typescheme sch))
                                       (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
*)
                     in
                       METATYNAME(tf1,name,n,b,ve'',abs)
                     end
              | copy_tyname (METATYNAME(tf as ref(TYFUN(ty,n)),name,n',b,
                                                          ve' as ref(VE(n'',ve)),abs)) =
                     let
                       val (tf1,tf_encountered) =
                         (Lists.assoc(tf,!tfs),true)
                         handle Lists.Assoc =>
                           (tf,false)
                       val (ve'',ve_encountered) =
                         (Lists.assoc(ve',!ves),true)
                         handle Lists.Assoc =>
                           (ve',false)
                       val _ =
                         if tf_encountered then ()
                         else
                           tfs := (tf,tf1)::(!tfs)
                       val _ =
                         if ve_encountered then ()
                         else
                           ves := (ve',ve'')::(!ves)
                       val _ =
                         if tf_encountered then ()
                         else
                           tf1 := TYFUN(copy_type ty,n)
                       val _ =
                         if ve_encountered then ()
                         else
                            ve'' := VE(n'', NewMap.map (fn (valid,sch) => copy_typescheme sch) ve)
(*
                                       NewMap.fold (fn (map,valid,sch) =>NewMap.define(map,valid,copy_typescheme sch))
                                       (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
*)
                     in
                       METATYNAME(tf1,name,n',b,ve'',abs)
                     end
              | copy_tyname (TYNAME(id,s,n,b,ve1 as ref(VE(n1,ve2)),s',abs,ve3 as ref(VE(_,ve4)))) =
                          let
                            (*val _ =
                              if NewMap.is_empty ve4 then
                                output(std_out,"\n EMPTY TYNAME \n")
                              else
                                output(std_out,"\n FULL TYNAME \n")*)
                            val (ve',ve,n') = (ve1,ve2,n1)
                          in
                     (TYNAME(id,s,n,b,ve',s',abs,Lists.assoc(ve',!ves))
                      handle Lists.Assoc =>
                        let
                          val ve'' = ref(VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
                          val map =
                            (ves := (ve',ve'')::(!ves);
                             NewMap.map (fn (valid,sch) => copy_typescheme sch) ve)
(*
                             NewMap.fold (fn (map,valid,sch) =>
                                            NewMap.define(map,valid,copy_typescheme sch))
                             (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
*)
                        in
                          (ve'' := VE(n',map);
                           TYNAME(id,s,n,b,ve',s',abs,ve''))
                       end)
                          end
a1843 2
   end
   local
d1845 1
d1849 1
d1859 1
d1909 5
@


1.89
log
@Fixing problem with printing flexible record types.
Use NewMap.map more.
@
text
@d4 4
d489 10
a498 6
      fun valid_to_string (Ident.VAR(sym)) = Ident.Symbol.symbol_name(sym)
        | valid_to_string (Ident.CON(sym)) = Ident.Symbol.symbol_name(sym)
        | valid_to_string (Ident.EXCON(sym)) = Ident.Symbol.symbol_name(sym)
        | valid_to_string _ = Crash.impossible "valid_to_string:types"

      val ves : Valenv ref list ref = ref([])
d500 1
a500 1
    fun type_strip(ty as METATYVAR(ref(_, ty',_), _, _)) =
d526 2
a527 2
	tyname_eq (ref_tyname, n)
         orelse
d542 2
a543 2
	tyname_eq (ref_tyname, n)
         orelse
d1303 4
a1306 6
	if eq 
	  then if tyname_eq (name,ref_tyname)
		 then eq_and_imp (false,imp,h)
	       else (eq_attrib name
		     andalso
		     eq_and_imp (eq,imp,h))
@


1.88
log
@Adding combine_types for use by the debugger
.;
@
text
@a775 5
    and string_metarec (ref (_,true,t',eq,imp), depth,metastack,option) =
      string_types (t',depth,metastack,", ...",option)
      | string_metarec (_,depth,metastack,option) =
	Crash.impossible "Types.string_metarec"      
	  
d819 1
a819 33
    and string_types (t as (METATYVAR (ref(_,NULLTYPE,_),_,_)),depth,stack,_,option) =
      string_metatyvar (t,depth,stack)
      | string_types (METATYVAR (ref(_,t,_),_,_),depth,stack,extras,option) =
	string_types (t,depth,stack,extras,option)
      | string_types (META_OVERLOADED (ref NULLTYPE, tv, _, _),depth,stack,extras,option) =
	((IdentPrint.printTyVar tv),depth,stack)
      | string_types (META_OVERLOADED {1=ref t,...},depth,stack,extras,option) =
	string_types (t,depth,stack,extras,option)
      | string_types (METARECTYPE (ref (_,true,t as METARECTYPE _,_,_)),
		      depth,stack,extras,option) = 
	string_types (t,depth,stack,extras,option)
      | string_types (METARECTYPE (t as (ref (_,true,_,_,_))),depth,stack,_,option) =
	string_metarec (t,depth,stack,option)
      | string_types (METARECTYPE (ref(_,_,t,_,_)),depth,stack,extras,option) =
	string_types (t,depth,stack,extras,option)
      | string_types (DEBRUIJN (n,n',n'',_),depth,stack,_,option) =
	(string_debruijn (n,n',n''),depth,stack)
      | string_types (TYVAR (_,t),depth,stack,_,option) =
	((IdentPrint.printTyVar t),depth,stack)
      | string_types (NULLTYPE,depth,stack,_,option) = ("Nulltype ",depth,stack)
      | string_types (FUNTYPE (a,r),depth,stack,extras,option) =
	let
	  val (s,d,m) = string_types (a,depth,stack,extras,option)
	  val (s',d',m') = string_types (r,d,m,extras,option)
	in
	  ((if is_a_function_type a
	      then "(" ^ s ^ ")"
	    else s)
	      ^ " -> " ^ s',d',m')
	end
      | string_types (t as (CONSTYPE (_,_)),depth,stack,extras,option) =
	string_constype (t,depth,stack,"",extras,option)
      | string_types (RECTYPE amap,depth,stack,extras,option) =
d834 1
d881 1
a881 1
		    | commas (acc,l as [x]) = rev ("}"::x::acc)
d889 37
d1521 1
a1523 5
          (* Special cases for small lists *)
	  | copy_type (CONSTYPE ([], name)) =
	    CONSTYPE([], tyname_copy name)
	  | copy_type (CONSTYPE ([ty], name)) =
	    CONSTYPE([copy_type ty], tyname_copy name)
d1529 1
a1529 1
	  | copy_type ty = Crash.impossible "Types.type_copy"
d1547 1
a1547 1
	(copy_type, tyname_copy, copy_tyfun)
d1696 2
d1700 1
d1731 5
a1735 3
                            ve'' := VE(n',
                                                 NewMap.fold (fn (map,valid,sch) =>NewMap.define(map,valid,copy_typescheme sch))
                               (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
d1765 5
a1769 3
                            ve'' := VE(n'',
                                                 NewMap.fold (fn (map,valid,sch) =>NewMap.define(map,valid,copy_typescheme sch))
                               (NewMap.empty (Ident.valid_lt, Ident.valid_eq), ve))
d1788 2
d1793 1
@


1.87
log
@Improved printing of overloaded type variables.
@
text
@d4 3
d776 2
a777 10
    and string_metarec (t as (METARECTYPE (ref (_,true,t',eq,imp))),
			depth,metastack,option) =
      let
	val (s,new_depth,stack) = 
          string_types (t',depth,metastack,", ...",option)
	val eq_bit = if eq then "''" else ""
	val imp_bit = if imp then "_" else ""
      in
        (eq_bit ^ imp_bit ^ s,new_depth,stack)
      end
d835 1
a835 1
      | string_types (t as (METARECTYPE (ref (_,true,_,_,_))),depth,stack,_,option) =
d1658 3
a1660 3
                    (fn lab=>fn ty=>fn map =>
                     Mapping.add((lab,copy_type ty),map,Ident.lab_order))
                                      Mapping.empty_map map)
d1817 2
a1818 1
   
d1820 52
a1872 1

@


1.86
log
@Removing debug stuff
@
text
@d4 3
a750 2
    and string_tyvar (Ident.TYVAR (id,_,_)) = Ident.Symbol.symbol_name id
	  
d834 1
a834 1
	((string_tyvar tv)^"(overloaded)",depth,stack)
d847 1
a847 1
	((string_tyvar t),depth,stack)
@


1.85
log
@Use pervasive Option.option for return values in NewMap
@
text
@d4 3
a303 1
require "ty_debug";
a309 5
  structure Debug : sig
		      val set_debug_level : int -> unit
		      val debug_level : unit -> int
		    end
  structure Ty_Debug : TY_DEBUG
d320 1
a320 1
    val do_debug = Ty_Debug.do_debug
@


1.84
log
@Abstraction of debug information
Tidying up
@
text
@d4 4
d1482 2
a1483 2
	   Tyfun_id.Map.YES _ => tyname_copies
	 | Tyfun_id.Map.NO =>
@


1.83
log
@Minor efficiency improvements to copy_type
@
text
@d4 3
d426 1
a426 1
	  Datatypes.META_OVERLOADED
d482 1
d819 1
a819 1
                            (ref (_,Datatypes.NULLTYPE,_),_,_)) = false
d975 2
a976 1
    and apply (TYFUN (atype,arity),tylist) =
d1468 1
a1468 1
        (*val _ = output(std_out,"\n"^Datatypes.Tyfun_id.string_tyfun_id id'^"->"^Datatypes.Tyfun_id.string_tyfun_id id)*)
d1618 1
a1618 1
       Datatypes.FUNTYPE _ => true
d1625 1
a1625 1
       Datatypes.FUNTYPE ar => ar
d1628 1
a1628 1
   type seen_tyvars = Datatypes.Type list * int
d1641 3
a1643 1
     val tyfun_instantiations : Datatypes.Tyfun list ref = ref []
d1645 4
a1648 8
          val types
            : (Datatypes.Type * Datatypes.Instance ref Datatypes.Option.opt 
               * (Datatypes.Tyfun ref * (int,int) Datatypes.Option.option ref) list) ref list ref = ref []
          val tyfuns : Datatypes.Tyfun ref list ref = ref []
          val ves : (Datatypes.Valenv ref * Datatypes.Valenv ref) list ref = ref []
          val tys1 : ((int * Datatypes.Type * Datatypes.Instance) ref
                      * (int * Datatypes.Type * Datatypes.Instance) ref) list ref = ref []
          val tys2 : (Datatypes.Type ref * Datatypes.Type ref) list ref = ref []
d1651 1
a1651 1
          val tfs : (Datatypes.Tyfun ref * Datatypes.Tyfun ref) list ref = ref []
d1653 2
a1654 2
          fun copy_type(Datatypes.CONSTYPE(tys,tyn)) =
                Datatypes.CONSTYPE(Lists.reducel
d1657 4
a1660 4
              | copy_type (Datatypes.FUNTYPE(ty1,ty2)) = Datatypes.FUNTYPE(copy_type ty1,copy_type ty2)
              | copy_type (Datatypes.RECTYPE(map)) =
                    Datatypes.RECTYPE(
                    Datatypes.Mapping.Fold
d1662 4
a1665 4
                     Datatypes.Mapping.add((lab,copy_type ty),map,Ident.lab_order))
                                      Datatypes.Mapping.empty_map map)
              | copy_type (tyv as Datatypes.METATYVAR(ty1 as ref(n,ty,i),b1,b2)) =
                (Datatypes.METATYVAR(Lists.assoc(ty1,!tys1),b1,b2)
d1671 1
a1671 1
		  (ovty as Datatypes.META_OVERLOADED
d1673 1
a1673 1
                (Datatypes.META_OVERLOADED(Lists.assoc(ty1,!tys2),tv,valid,loc)
d1678 2
a1679 2
              | copy_type (tyv as Datatypes.TYVAR(ty1 as ref(n,ty,i),id)) =
                (Datatypes.TYVAR(Lists.assoc(ty1,!tys1),id)
d1684 2
a1685 2
              | copy_type (recty as Datatypes.METARECTYPE(ty1 as ref(n,b1,ty,b2,b3))) =
                (Datatypes.METARECTYPE(Lists.assoc(ty1,!tys3))
d1691 2
a1692 2
            and copy_typescheme (Datatypes.SCHEME(n,(ty,i))) = Datatypes.SCHEME(n,(copy_type ty,i))
              | copy_typescheme (Datatypes.UNBOUND_SCHEME(ty,i)) = Datatypes.UNBOUND_SCHEME(copy_type ty,i)
d1695 3
a1697 3
                  (m as Datatypes.METATYNAME(tf as ref(Datatypes.NULL_TYFUN(_)),name,n,b,
                                             ve' as ref(Datatypes.VE(n',ve)),abs)) =
                     (Datatypes.METATYNAME(tf,name,n,b,Lists.assoc(ve',!ves),abs)
d1705 2
a1706 2
                          (ve' := Datatypes.VE(n',map);
                           Datatypes.METATYNAME(tf,name,n,b,ve',abs))
d1708 2
a1709 2
              | copy_tyname (Datatypes.METATYNAME(tf as ref(Datatypes.ETA_TYFUN(tyn)),name,n,b,
                                                          ve' as ref(Datatypes.VE(n',ve)),abs)) =
d1730 1
a1730 1
                           tf1 := Datatypes.ETA_TYFUN(copy_tyname tyn)
d1734 1
a1734 1
                            ve'' := Datatypes.VE(n',
d1738 1
a1738 1
                       Datatypes.METATYNAME(tf1,name,n,b,ve'',abs)
d1740 2
a1741 2
              | copy_tyname (Datatypes.METATYNAME(tf as ref(Datatypes.TYFUN(ty,n)),name,n',b,
                                                          ve' as ref(Datatypes.VE(n'',ve)),abs)) =
d1762 1
a1762 1
                           tf1 := Datatypes.TYFUN(copy_type ty,n)
d1766 1
a1766 1
                            ve'' := Datatypes.VE(n'',
d1770 1
a1770 1
                       Datatypes.METATYNAME(tf1,name,n',b,ve'',abs)
d1772 1
a1772 1
              | copy_tyname (Datatypes.TYNAME(id,s,n,b,ve1 as ref(Datatypes.VE(n1,ve2)),s',abs,ve3 as ref(Datatypes.VE(_,ve4)))) =
d1781 1
a1781 1
                     (Datatypes.TYNAME(id,s,n,b,ve',s',abs,Lists.assoc(ve',!ves))
d1784 1
a1784 1
                          val ve'' = ref(Datatypes.VE(n',NewMap.empty (Ident.valid_lt, Ident.valid_eq)))
d1791 2
a1792 2
                          (ve'' := Datatypes.VE(n',map);
                           Datatypes.TYNAME(id,s,n,b,ve',s',abs,ve''))
d1797 2
a1798 2
            val dummy_ve = ref(Datatypes.empty_valenv)
            val dummy_tf = ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))
a1801 2
               types := [];
               tyfuns := [];
d1807 2
a1808 3
(*output(std_out,"\n copy_tyfun ... \n");*)
               case copy_tyname(Datatypes.METATYNAME(dummy_tf,"",0,dummy_false,dummy_ve,dummy_false)) of
                 Datatypes.METATYNAME(ref(tf),_,_,_,_,_) => tf
@


1.82
log
@Fixed type_of: integer literals were assigned int_tyvar instead of
int_literal_tyvar.
@
text
@d4 4
d1520 5
@


1.81
log
@New overloading scheme.
@
text
@d4 3
d420 1
a420 1
	    (ref NULLTYPE, Ident.int_tyvar,
@


1.80
log
@Fix tyfun_strip to ensure arity preserved
Fixed typos in debug_print_type and friends
@
text
@d4 4
d415 5
a419 1
    fun type_of (Ident.INT _) = int_type
d433 2
a434 2
      | the_type (atype as (META_OVERLOADED (ref NULLTYPE,_))) = atype
      | the_type (META_OVERLOADED (ref atype,_)) = the_type atype
d478 1
a478 1
      | type_strip(ty as META_OVERLOADED(ref ty',_)) =
d637 2
a638 2
      | type_eq' (ty as METATYVAR (t as ref (_,NULLTYPE,_),_,_),
		 ty' as METATYVAR (t' as ref (_,NULLTYPE,_),_,_),_,_) = 
d640 2
a641 2
      | type_eq' (ty as META_OVERLOADED (t as ref  NULLTYPE,_), 
		 ty' as META_OVERLOADED (t' as ref  NULLTYPE,_),_,_) = 
d820 3
a822 6
      | string_types (t as (META_OVERLOADED (ref NULLTYPE,id)),depth,stack,extras,option) =
	("Overloaded(" ^
         IdentPrint.printValId Options.default_print_options id ^
         ")"
         ,depth,stack)
      | string_types (META_OVERLOADED (ref t,_),depth,stack,extras,option) =
d957 1
a957 1
      | app_subst (ty as META_OVERLOADED(ref ty', _), array_of_types) =
d984 1
a984 1
      | extra_debug_print_type(META_OVERLOADED(ref ty, valid)) =
d986 1
a986 1
	IdentPrint.printValId Options.default_print_options valid ^ ")"
d1017 50
d1216 13
a1228 2
    fun num_typep (CONSTYPE ([],name)) =
      tyname_eq(name,int_tyname) orelse tyname_eq (name,real_tyname)
d1233 2
d1380 1
a1380 2
      | not_occurs (ameta,t as META_OVERLOADED (ref NULLTYPE,_)) = true
      | not_occurs (ameta,META_OVERLOADED (ref t,_)) = true
d1517 1
d1655 4
a1658 2
              | copy_type (ovty as Datatypes.META_OVERLOADED(ty1 as ref(ty),v)) =
                (Datatypes.META_OVERLOADED(Lists.assoc(ty1,!tys2),v)
@


1.79
log
@Added functions for checking for uninstantiated tyvars
@
text
@d4 3
d441 2
a442 2
		    TYFUN(CONSTYPE(types, tyname), _)) =
	if check_debruijns(types, 0) then
d453 2
a454 2
						      _)), ...})=
	if check_debruijns(types, 0) then
d674 1
a674 1
	(if eq then "[t]" else "[f]")^"["^
d676 1
a676 1
             ((("VE:"^MLWorks.Integer.makestring(Lists.find(ve',!ves)+1)^(if NewMap.is_empty ve then ":EMPTY" else ":FULL"))
d686 1
a686 1
        name ^ Tyfun_id.string_tyfun_id id ^ (if eq then "[t]" else "[f]")^"["^string_tyfun(!tf)^"]"^"["^
d688 1
a688 1
             ((("VE:"^MLWorks.Integer.makestring(Lists.find(ve',!ves)+1))
d698 1
a698 1
	"METATYNAME(" ^ name ^ "{" ^ string_tyfun tyfun ^ "}" ^ ")"^"["^
d700 1
a700 1
             ((("VE:"^MLWorks.Integer.makestring(Lists.find(ve',!ves)+1))
@


1.78
log
@Changed Datatypes.instance to Datatypes.Instance.
@
text
@d4 3
d1407 29
a1435 41
(*
    fun tyname_copy (tyname as METATYNAME {1 = ref (NULL_TYFUN (id,_)), ...}, tyname_copies) =
      (case Tyfun_id.Map.tryApply'(tyname_copies,id) of
	 Tyfun_id.Map.YES x => x
       | _ => tyname)
(*
      (Tyfun_id.Map.apply' (tyname_copies,id) handle Tyfun_id.Map.Undefined => tyname)
*)
      | tyname_copy (METATYNAME {1 = ref (ETA_TYFUN meta), ...}, tyname_copies) =
	tyname_copy(meta, tyname_copies)
      | tyname_copy (METATYNAME(ref tyfun, name, a, ref eq, ref ve,ref is_abs), tyname_copies) =
	METATYNAME(ref (tyfun_copy(tyfun, tyname_copies)), name, a, ref eq, ref ve,ref is_abs)
      | tyname_copy (tyname, _) = tyname

    and tyfun_copy (tyfun, tyname_copies) = 
      let
	fun copy (ETA_TYFUN (meta as METATYNAME {1=ref(NULL_TYFUN _), ...})) =
  	    ETA_TYFUN (tyname_copy (meta, tyname_copies))
	  | copy (ETA_TYFUN (METATYNAME{1 = ref tyfun, ...})) = copy tyfun
	  | copy (TYFUN(CONSTYPE([], tyname), a)) = copy(ETA_TYFUN tyname)
	  | copy (TYFUN(ty, a)) = TYFUN(type_copy(ty, tyname_copies), a)
	  | copy tyfun = tyfun
      in
	copy tyfun
      end

    and type_copy (ty, tyname_copies) =
      let
	fun copy (METATYVAR (ref (_,ty,_),_,_)) = copy ty
	  | copy (METARECTYPE (r as ref (_,false,ty,_,_))) = copy ty
	  | copy (RECTYPE amap) = RECTYPE(Mapping.mapit(amap, copy))
	  | copy (FUNTYPE (ty,ty')) = FUNTYPE(copy ty, copy ty')
	  | copy (CONSTYPE (l, name)) = 
            CONSTYPE(map copy l, tyname_copy(name,tyname_copies))
	  | copy (ty as (TYVAR _)) = ty
	  | copy (ty as (DEBRUIJN _)) = ty
	  | copy ty = Crash.impossible "Types.type_copy"
      in
	copy ty
      end
*)
d1440 1
a1440 1
	  | copy_type (METARECTYPE (r as ref (_,false,ty,_,_))) = copy_type ty
@


1.77
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d300 1
d319 1
a319 1
      TYNAME (Tyname_id.make_tyname_id (),pname,n,ref eq, ref empty_valenv,location,ref false)
d321 1
a321 1
    fun get_tyname_id (TYNAME (id,_,_,_,_,_,_)) = id
d325 1
a325 1
    fun tyname_arity (TYNAME (_,_,n,_,_,_,_)) = n
d332 1
a332 1
    fun tyname_make_false (TYNAME (_,_,_,r,_,_,_)) = (r := false; false)
d350 1
a350 1
    fun make_true (TYNAME (_,_,_,r,_,_,_)) = r := true
d453 6
d510 1
a510 1
    and eq_attrib (TYNAME (_,_,_,ref eq,_,_,_)) = eq
d537 1
a537 1
    and tyname_eq' (t as TYNAME (id,_,_,_,_,_,_),t' as TYNAME (id',_,_,_,_,_,_)) =
d642 1
a642 1
	  (debug_print_type aty)
d649 1
a649 1
    and print_name' options (TYNAME (_,name,_,ref eq,_,location,_)) =
d666 1
a666 1
    and debug_print_name (TYNAME (id,name,_,ref eq,_,location,_)) =
d668 35
a702 5
	(if eq then "[t]" else "[f]")
      | debug_print_name (METATYNAME (ref (NULL_TYFUN (id,_)),name,_,ref eq,_,_)) = 
        name ^ Tyfun_id.string_tyfun_id id ^ (if eq then "[t]" else "[f]")
      | debug_print_name (METATYNAME (ref tyfun,name,_,_,_,_)) =
	"METATYNAME(" ^ name ^ "{" ^ string_tyfun tyfun ^ "}" ^ ")"
d959 1
a959 1
	CONSTYPE (tylist,name)
d964 1
a964 1
      | apply (NULL_TYFUN _,tylist) = raise NullTyfun
d967 1
a967 1
    fun print_bool true = "true"
d970 1
a970 1
    fun extra_debug_print_type(METATYVAR(ref (i, ty,_), b1, b2)) =
d1380 1
a1380 1
    fun new_metatyname (METATYNAME (ref (NULL_TYFUN (id,ve')),printname,
d1382 7
a1388 2
      METATYNAME (ref (NULL_TYFUN (Tyfun_id.make_tyfun_id (),ve')),printname,
		  arity,ref eq, ref ve,ref is_abs)
d1436 2
a1437 1
	  | copy (CONSTYPE (l, name)) = CONSTYPE(map copy l, tyname_copy(name,tyname_copies))
d1440 1
a1440 1
	  | copy _ = Crash.impossible "Types.type_copy"
d1456 1
a1456 1
	  | copy_type _ = Crash.impossible "Types.type_copy"
d1562 183
d1747 1
@


1.76
log
@Added hooks to print types with a set of remembered type variables.
@
text
@d4 3
d315 1
a315 1
      TYNAME (Tyname_id.make_tyname_id (),pname,n,ref eq, ref empty_valenv,location)
d317 1
a317 1
    fun get_tyname_id (TYNAME (id,_,_,_,_,_)) = id
d321 2
a322 2
    fun tyname_arity (TYNAME (_,_,n,_,_,_)) = n
      | tyname_arity (METATYNAME (_,_,n,_,_)) = n
d328 2
a329 2
    fun tyname_make_false (TYNAME (_,_,_,r,_,_)) = (r := false; false)
      | tyname_make_false (METATYNAME (ref tyfun,_,_,r,_)) =
d346 2
a347 2
    fun make_true (TYNAME (_,_,_,r,_,_)) = r := true
      | make_true (METATYNAME (ref tyfun,_,_,r,_)) =
d500 3
a502 3
    and eq_attrib (TYNAME (_,_,_,ref eq,_,_)) = eq
      | eq_attrib (METATYNAME (ref (NULL_TYFUN _),_,_,ref eq,_)) = eq
      | eq_attrib (METATYNAME (ref tyfun,_,_,_,_)) = equalityp tyfun
d527 1
a527 1
    and tyname_eq' (t as TYNAME (id,_,_,_,_,_),t' as TYNAME (id',_,_,_,_,_)) =
d639 1
a639 1
    and print_name' options (TYNAME (_,name,_,ref eq,_,location)) =
d644 1
a644 1
      | print_name' options (METATYNAME (ref (NULL_TYFUN id),name,_,ref eq,_)) = 
d648 1
a648 1
      | print_name' options (METATYNAME (ref tyfun,name,_,_,_)) =
d656 1
a656 1
    and debug_print_name (TYNAME (id,name,_,ref eq,_,location)) =
d659 1
a659 1
      | debug_print_name (METATYNAME (ref (NULL_TYFUN (id,_)),name,_,ref eq,_)) = 
d661 1
a661 1
      | debug_print_name (METATYNAME (ref tyfun,name,_,_,_)) =
d1222 1
a1222 1
      | not_occurs_tyname (ty,METATYNAME (ref tyfun,_,_,_,_)) =
d1336 2
a1337 2
				     arity,ref eq, ref ve)) =
      METATYNAME (ref (NULL_TYFUN id),printname,arity, ref eq, ref ve)
d1341 1
a1341 1
				    arity,ref eq, ref ve)) =
d1343 1
a1343 1
		  arity,ref eq, ref ve)
d1369 2
a1370 2
      | tyname_copy (METATYNAME(ref tyfun, name, a, ref eq, ref ve), tyname_copies) =
	METATYNAME(ref (tyfun_copy(tyfun, tyname_copies)), name, a, ref eq, ref ve)
d1416 2
a1417 2
	  | tyname_copy (METATYNAME(ref tyfun, name, a, ref eq, ref ve)) =
	    METATYNAME(ref (copy_tyfun tyfun), name, a, ref eq, ref ve)
@


1.75
log
@Bug fixes 481 and 489: constypes with multiple metarectypes were
printing poorly, and the 26th, 52nd, etc type variables were printing
incorrectly.
@
text
@d4 5
d1499 14
@


1.74
log
@Patch up silent failure in RCS.
@
text
@d4 3
d658 2
a659 2
	val rep =  n div 26
	val char_no = 96 + (n mod 26)
d718 1
a718 1
	    val (s,_,_) = string_types (h,depth,stack,extras,option)
d734 1
a734 1
	    val (s,_,_) = string_types (h,depth,stack,extras,option)
@


1.73
log
@Fixed the way record types are printed (killed a space and improved
tail-recursion).
@
text
@d4 4
d1489 4
a1492 1
       Datatypes.FUNTYPE @


1.72
log
@Made app_subst substitute for instantiated META_OVERLOADED types, which result
from top level resolution of overloading
@
text
@d4 4
d784 11
d801 2
a802 1
						    (MLWorks.Integer.makestring n)),
d808 14
a821 32
	  val stack_ref = ref stack
	  val depth_ref = ref depth
	  fun ref_printer t =
	    let 
	      val ref stack = stack_ref
	      val ref depth = depth_ref
	      val (s,new_depth,new_stack) = string_types(t,depth,stack,extras,option)
	    in
	      (stack_ref := new_stack;
	       depth_ref := new_depth;
	       s)
	    end
	  val comma_rec_string = Mapping.print_map
	    (amap,
	     fn x => ", " ^ (IdentPrint.printLab x),
	     ref_printer,
	     " : ")
	  fun rec_list([]) = []
	    | rec_list(_::t) = t
	  fun print_as_a_tuple n =
	    let 
	      val element_type =
		Mapping.lookup (Ident.LAB (Ident.Symbol.find_symbol
					   (MLWorks.Integer.makestring n)),amap)
	      val element_string =
		if is_a_function_type element_type (* orelse
						    is_a_record_type element_type *) then
		  "(" ^ ref_printer element_type ^ ")"
		else ref_printer element_type
	    in 
	      if n = len then [element_string]
	      else element_string :: " * " :: print_as_a_tuple (n+1)
d823 1
a823 4
	  val string_res = 
	    (* for the empty tuple, "()" is wrong.  "unit" can be
	     * redefined, but it's what people usually expect to see.
	     *)
d825 4
a828 1
	      if show_eq option then "unit[t]" else "unit"
d831 19
a849 5
		"(" ^ implode (print_as_a_tuple 1) ^ ")"
	      else "{"^ (implode (rec_list (explode comma_rec_string))) ^ 
		extras ^ "}"
	in
	  (string_res, !depth_ref,!stack_ref)
@


1.71
log
@Merging in bug fixes
@
text
@d4 3
d879 4
@


1.70
log
@Instances for METATYVARs and TYVARs and DEBRUIJNs;
function all_tyvars that returns all METATYVAR- and TYVAR- refs
for polymorphic debugger.
@
text
@d4 11
d307 6
a312 1
      | tyname_make_false (METATYNAME (_,_,_,r,_)) = (r := false; false)
d314 18
a1076 7
    (****
     make_false is used in maximising equality - rules 19 and 20.
     ****)
    fun make_false (TYFUN (_)) = Crash.impossible "Types.make_false"
      | make_false (ETA_TYFUN (tyname)) = tyname_make_false tyname
      | make_false (NULL_TYFUN (_)) = false
	
@


1.69
log
@Improved type_copy and associated functions
@
text
@d4 3
d357 2
a358 2
    fun the_type (atype as (METATYVAR (ref (_,NULLTYPE),_,_))) = atype
      | the_type (METATYVAR (ref (_,atype),_,_)) = the_type atype
d368 1
a368 1
      | check_debruijns(DEBRUIJN(n, _, _) :: t, n') =
d394 1
a394 1
    fun type_strip(ty as METATYVAR(ref(_, ty'), _, _)) =
d414 2
a415 2
      | type_equalityp (METATYVAR (ref (_,NULLTYPE),eq,_)) = eq
      | type_equalityp (METATYVAR (ref (_,t),_,_)) = type_equalityp t
d430 2
a431 2
      | closed_type_equalityp (METATYVAR (ref (_,NULLTYPE),eq,_)) = eq
      | closed_type_equalityp (METATYVAR (ref (_,t),_,_)) = closed_type_equalityp t
d441 1
a441 1
      | closed_type_equalityp (DEBRUIJN (_,eq,_)) = eq
d549 1
a549 1
      | type_eq' (t as DEBRUIJN (d,eq,imp),t' as DEBRUIJN (d',eq',imp'),
d557 2
a558 2
      | type_eq' (ty as METATYVAR (t as ref (_,NULLTYPE),_,_),
		 ty' as METATYVAR (t' as ref (_,NULLTYPE),_,_),_,_) = 
d698 2
a699 2
                            (ref (_,Datatypes.NULLTYPE),_,_)) = false
      | is_a_function_type (METATYVAR (ref (_,ty),_,_)) = 
d706 1
a706 1
    and string_types (t as (METATYVAR (ref(_,NULLTYPE),_,_)),depth,stack,_,option) =
d708 1
a708 1
      | string_types (METATYVAR (ref(_,t),_,_),depth,stack,extras,option) =
d724 2
a725 2
      | string_types (DEBRUIJN n,depth,stack,_,option) =
	(string_debruijn n,depth,stack)
d815 1
a815 1
    and app_subst (DEBRUIJN (d,_,_),array_of_types) =
d838 1
a838 1
      | app_subst (ty as METATYVAR (ref (_,NULLTYPE),_,_),array_of_types) =
d840 1
a840 1
      | app_subst (METATYVAR (ref (_,ty),_,_),array_of_types) = 
d862 1
a862 1
    fun extra_debug_print_type(METATYVAR(ref (i, ty), b1, b2)) =
d868 1
a868 1
      | extra_debug_print_type(TYVAR(ref i, tyvar)) =
d883 1
a883 1
      | extra_debug_print_type(DEBRUIJN(i, b1, b2)) =
d903 2
a904 2
      | imperativep (METATYVAR (ref (_,NULLTYPE),_,imp)) = imp
      | imperativep (METATYVAR (ref (_,t),_,_)) = imperativep t
d914 1
a914 1
      | imperativep (DEBRUIJN (_,_,imp)) = imp 
d948 1
a948 1
          TYVAR (ref (0), 
d983 1
a983 1
	    val new_debruijn = DEBRUIJN (n,true,true) (* arbitrary choice *)
d1063 2
a1064 2
      | tyvar_equalityp (METATYVAR (ref (_,NULLTYPE),eq,_)) = eq
      | tyvar_equalityp (METATYVAR (ref (_,t),eq,_)) = tyvar_equalityp t
d1085 1
a1085 1
      | eq_and_imp (eq,imp,DEBRUIJN (_,eq',imp')) =
d1126 1
a1126 1
      | eq_and_imp (eq,imp,METATYVAR (x as ref (n,NULLTYPE),eq',imp')) =
d1129 2
a1130 2
		      METATYVAR (ref (n,NULLTYPE),
				 eq orelse eq',imp orelse imp'));
d1133 1
a1133 1
      | eq_and_imp (eq,imp,METATYVAR (ref (_,t),eq',imp')) =
d1163 2
a1164 2
    and not_occurs (METATYVAR (ref (n,_),_,_),
                    TYVAR (r' as ref (n'),_)) =
d1167 1
a1167 1
      (r' := (n);
d1180 2
a1181 2
      | not_occurs (ameta as METATYVAR (ref (n,NULLTYPE),_,_),
		    ameta' as METATYVAR (x as ref (n',NULLTYPE),_,_)) = 
d1187 1
a1187 1
	  (x := (n,NULLTYPE);
d1189 2
a1190 2
      | not_occurs (ameta as METATYVAR (ref (n,_),_,_),
		    ameta' as METATYVAR (x as ref (n',NULLTYPE),_,_)) = 
d1196 1
a1196 1
	(x := (n,NULLTYPE);
d1198 1
a1198 1
      | not_occurs (ameta,t as METATYVAR (ref (_,NULLTYPE),eq',imp')) =
d1200 3
a1202 3
      | not_occurs (ameta as METATYVAR (ref (n,_),_,_),
		    METATYVAR (x as ref (n',t),_,_)) = 
	(if (n > n') then () else x := (n,t);
d1204 1
a1204 1
      | not_occurs (ameta,METATYVAR (ref (_,t),_,_)) = not_occurs (ameta,t)
d1221 1
a1221 1
      | propagate_level level (ty as (METATYVAR (r as ref (level',t),_,_))) =
d1223 1
a1223 1
	   then r := (level,propagate_level level t)
d1234 2
a1235 2
    fun has_free_imptyvars (METATYVAR (ref (_,NULLTYPE),_,imp)) = imp
      | has_free_imptyvars (METATYVAR (ref (_,ty),_,_)) = has_free_imptyvars ty
d1326 1
a1326 1
	fun copy (METATYVAR (ref (_,ty),_,_)) = copy ty
d1341 1
a1341 1
	fun copy_type (METATYVAR (ref (_,ty),_,_)) = copy_type ty
d1391 2
a1392 2
   fun tyvars (tyvarlist, METATYVAR (ref (_,NULLTYPE),_,_)) = tyvarlist
     | tyvars (tyvarlist, METATYVAR (ref (_,atype),_,_)) = 
d1406 23
@


1.69.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.69  1993/08/23  13:51:05  jont
Improved type_copy and associated functions

@


1.69.1.2
log
@Added make_true for doing equality_principal algorithm
@
text
@a3 3
Revision 1.69.1.1  1993/08/23  13:51:05  jont
Fork for bug fixing

d296 1
a296 6
      | tyname_make_false (METATYNAME (ref tyfun,_,_,r,_)) =
	case tyfun of
	  ETA_TYFUN tyname => tyname_make_false tyname
      | NULL_TYFUN _ =>
	  (r := false; false)
      | TYFUN _ => Crash.impossible "Types.make_false"
a297 18
    (****
     make_false is used in maximising equality - rules 19 and 20.
     ****)
    and make_false (TYFUN (_)) = Crash.impossible "Types.make_false"
      | make_false (ETA_TYFUN (tyname)) = tyname_make_false tyname
      | make_false (NULL_TYFUN (_)) = false

    (****
     make_true is used in maximising equality - rules 19 and 20.
     ****)
    fun make_true (TYNAME (_,_,_,r,_,_)) = r := true
      | make_true (METATYNAME (ref tyfun,_,_,r,_)) =
	case tyfun of
	  ETA_TYFUN tyname => make_true tyname
      | NULL_TYFUN _ =>
	  r := true
      | TYFUN _ => Crash.impossible "Types.make_true"

d1043 7
@


1.68
log
@Changed printing of overloaded types.
@
text
@d4 3
d1295 1
d1297 4
d1302 1
d1333 53
@


1.67
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger;
structure Option.
@
text
@d4 5
d705 4
a708 1
	(IdentPrint.printValId Options.default_print_options id,depth,stack)
@


1.66
log
@Extra extra information debug_print_type
@
text
@d4 3
d290 13
a302 13
    val bool_tyname = make_tyname (0,true,"bool",ABSENT)
    val int_tyname = make_tyname (0,true,"int",ABSENT)
    val real_tyname = make_tyname (0,true,"real",ABSENT)
    val string_tyname = make_tyname (0,true,"string",ABSENT)
    val list_tyname = make_tyname (1,true,"list",ABSENT)
    val ref_tyname = make_tyname (1,true,"ref",ABSENT)
    val exn_tyname = make_tyname (0,false,"exn",ABSENT)
    val ml_value_tyname = make_tyname (0,true,"ml_value",ABSENT)
    val array_tyname = make_tyname (1,true,"array",ABSENT)
    val vector_tyname = make_tyname (1,true,"vector",ABSENT)
    val bytearray_tyname = make_tyname (0,true,"bytearray",ABSENT)
    val dynamic_tyname = make_tyname (0,false,"Dynamic",ABSENT)
    val type_tyname = make_tyname (0,false,"Type",ABSENT)
d451 1
a451 1
      | tyfun_eq' (t as NULL_TYFUN (id),t' as NULL_TYFUN (id')) =
d569 1
a569 1
      | string_tyfun (NULL_TYFUN id) = 
d592 1
a592 1
      | debug_print_name (METATYNAME (ref (NULL_TYFUN id),name,_,ref eq,_)) = 
d934 4
a937 4
          Datatypes.TYVAR (ref 0, Ident.TYVAR (
                                    Ident.Symbol.find_symbol ("'" ^ name n),
                                    true,
                                    true))
d1150 1
a1150 1
                    TYVAR (r' as ref n',_)) =
d1153 1
a1153 1
      (r' := n;
d1167 8
a1174 8
                    ameta' as METATYVAR (x as ref (n',NULLTYPE),_,_)) = 
        if (type_eq (ameta,ameta',true,true))
          then false
        else
          (n > n') 
          orelse
          (x := (n,NULLTYPE);
           true)
d1176 1
a1176 1
                    ameta' as METATYVAR (x as ref (n',NULLTYPE),_,_)) =
d1182 2
a1183 2
          (x := (n,NULLTYPE);
           true)
d1185 1
a1185 1
        not (type_eq (ameta,t,true,true))
d1187 3
a1189 3
                    METATYVAR (x as ref (n',t),_,_)) = 
        (if (n > n') then () else x := (n,t);
           not_occurs (ameta,t))
a1206 1

d1265 1
a1265 1
    fun new_metatyname (METATYNAME (ref (NULL_TYFUN id),printname,
d1267 1
a1267 1
      METATYNAME (ref (NULL_TYFUN (Tyfun_id.make_tyfun_id ())),printname,
d1271 1
a1271 1
    fun create_tyname_copies (meta as METATYNAME {1=ref (NULL_TYFUN id), ...}, tyname_copies,copy_fun) =
d1284 1
a1284 1
    fun tyname_copy (tyname as METATYNAME {1 = ref (NULL_TYFUN id), ...}, tyname_copies) =
@


1.65
log
@ Fixed some problems with type printing
@
text
@d4 3
d458 1
a458 1
      Tyname_id.tyname_id_eq (id,id')
d586 3
a588 2
    and debug_print_name (TYNAME (_,name,_,ref eq,_,location)) =
	name ^ (if eq then "[t]" else "[f]")
d693 92
a784 92
	  string_metatyvar (t,depth,stack)
	| string_types (METATYVAR (ref(_,t),_,_),depth,stack,extras,option) =
	  string_types (t,depth,stack,extras,option)
	| string_types (t as (META_OVERLOADED (ref NULLTYPE,id)),depth,stack,extras,option) =
	  (IdentPrint.printValId Options.default_print_options id,depth,stack)
	| string_types (META_OVERLOADED (ref t,_),depth,stack,extras,option) =
	  string_types (t,depth,stack,extras,option)
	| string_types (METARECTYPE (ref (_,true,t as METARECTYPE _,_,_)),
                        depth,stack,extras,option) = 
          string_types (t,depth,stack,extras,option)
	| string_types (t as (METARECTYPE (ref (_,true,_,_,_))),depth,stack,_,option) =
	  string_metarec (t,depth,stack,option)
	| string_types (METARECTYPE (ref(_,_,t,_,_)),depth,stack,extras,option) =
	  string_types (t,depth,stack,extras,option)
	| string_types (DEBRUIJN n,depth,stack,_,option) =
	  (string_debruijn n,depth,stack)
	| string_types (TYVAR (_,t),depth,stack,_,option) =
	  ((string_tyvar t),depth,stack)
	| string_types (NULLTYPE,depth,stack,_,option) = ("Nulltype ",depth,stack)
	| string_types (FUNTYPE (a,r),depth,stack,extras,option) =
	  let
	    val (s,d,m) = string_types (a,depth,stack,extras,option)
	    val (s',d',m') = string_types (r,d,m,extras,option)
	  in
	    ((if is_a_function_type a
                then "(" ^ s ^ ")"
                  else s)
                ^ " -> " ^ s',d',m')
	  end
	| string_types (t as (CONSTYPE (_,_)),depth,stack,extras,option) =
	  string_constype (t,depth,stack,"",extras,option)
	| string_types (RECTYPE amap,depth,stack,extras,option) =
	  let
            val len = Lists.length (Mapping.assoc amap)
            val is_a_tuple =
              let
                fun check_elem 0 = true
                  | check_elem n =
                    Mapping.domain_member (Ident.LAB (Ident.Symbol.find_symbol
                                                      (MLWorks.Integer.makestring n)),
                                           amap)
                    andalso check_elem (n-1)
              in
                len > 1 andalso check_elem len
              end
	    val stack_ref = ref stack
	    val depth_ref = ref depth
	    fun ref_printer t =
	      let 
		val ref stack = stack_ref
		val ref depth = depth_ref
		val (s,new_depth,new_stack) = string_types(t,depth,stack,extras,option)
	      in
		(stack_ref := new_stack;
		 depth_ref := new_depth;
		 s)
	      end
	    val comma_rec_string = Mapping.print_map
	      (amap,
	       fn x => ", " ^ (IdentPrint.printLab x),
	       ref_printer,
	       " : ")
	    fun rec_list([]) = []
	      | rec_list(_::t) = t
            fun print_as_a_tuple n =
	      let 
                val element_type =
		  Mapping.lookup (Ident.LAB (Ident.Symbol.find_symbol
			                     (MLWorks.Integer.makestring n)),amap)
		val element_string = 
		  if is_a_function_type element_type (* orelse
		      is_a_record_type element_type *) then
		    "(" ^ ref_printer element_type ^ ")"
		  else ref_printer element_type
              in 
                if n = len then [element_string]
                else element_string :: " * " :: print_as_a_tuple (n+1)
	      end
	    val string_res = 
	       (* for the empty tuple, "()" is wrong.  "unit" can be
		* redefined, but it's what people usually expect to see.
	        *)
	      if len = 0 then
		if show_eq option then "unit[t]" else "unit"
	      else
                if is_a_tuple then 
                  "(" ^ implode (print_as_a_tuple 1) ^ ")"
                else "{"^ (implode (rec_list (explode comma_rec_string))) ^ 
                  extras ^ "}"
	  in
	     (string_res, !depth_ref,!stack_ref)
	  end
a790 2
(*    local*)
      
d798 29
a826 29
      and app_subst (DEBRUIJN (d,_,_),array_of_types) =
	Array.sub (array_of_types,d)
	| app_subst (RECTYPE (amap),array_of_types) =
	  RECTYPE(Mapping.mapit
		  (amap,
		   fn x => app_subst (x,array_of_types)))
	| app_subst (FUNTYPE (atype,atype'),array_of_types) =
	  FUNTYPE (app_subst (atype,array_of_types),
		   app_subst (atype',array_of_types))
	| app_subst (CONSTYPE (atylist,atyname),array_of_types) =
	  let
	    val new_ty_list =
	      map (fn x => app_subst (x,array_of_types)) atylist
	  in
	    case atyname of
	      TYNAME _ => CONSTYPE(new_ty_list, atyname)
	    | METATYNAME{1=ref(NULL_TYFUN _), ...} =>
		CONSTYPE(new_ty_list, atyname)
	    | METATYNAME{1=ref tyfun, ...} =>
		apply(tyfun, new_ty_list)
	  end
	| app_subst (NULLTYPE,array_of_types) = NULLTYPE 
	  (* for signature matching in funbinds *)
	| app_subst (ty as METATYVAR (ref (_,NULLTYPE),_,_),array_of_types) =
	  ty
	| app_subst (METATYVAR (ref (_,ty),_,_),array_of_types) = 
          app_subst (ty,array_of_types)
	| app_subst (ty,_) = 
          Crash.impossible ("Types.app_subst " ^ (debug_print_type ty))
d828 12
a839 12
       and apply (TYFUN (atype,arity),tylist) =
         if arity = Lists.length (tylist)
           then app_subst (atype,Array.arrayoflist (tylist))
	  else raise WrongArity
	| apply (ETA_TYFUN (name as METATYNAME {1=ref (NULL_TYFUN _), ...}),
		 tylist) =
	  CONSTYPE (tylist,name)
	| apply (ETA_TYFUN (METATYNAME {1=ref tyfun, ...}),tylist) =
	  apply (tyfun,tylist)
	| apply (ETA_TYFUN (tyname),tylist) =
	  CONSTYPE (tylist,tyname)
	| apply (NULL_TYFUN _,tylist) = raise NullTyfun
d841 29
a869 1
(*    end*)
@


1.64
log
@Fixed type circularity check
@
text
@d4 3
d654 7
a660 2
	    if acc_string = "" then 
	      (s ^ " " ^ (print_name' option name),depth,stack)
d662 1
a662 1
	      (implode ["(", acc_string, ", ", s, ")", 
d916 9
a924 7
	  let fun print_tyvars' [] = [")"]
	        | print_tyvars' (tyvar::tyvars) =
		    debug_print_type tyvar :: ", " ::
		      print_tyvars' tyvars
	  in
            implode ("(" :: print_tyvars' l)
	  end
@


1.63
log
@Removed debuggery
Changed debug_print_name a little.
@
text
@d4 4
d1040 8
a1047 1
	 handle NullTyfun => ((not eq) orelse eq'))
d1096 16
a1111 7

    fun not_occurs (METATYVAR (ref (n,_),_,_),
		    TYVAR (r' as ref n',_)) =
	(n > n')
	orelse
	(r' := n;
	 true)
d1114 1
a1114 1
	not_occurs (ameta,a) andalso not_occurs (ameta,r)
d1116 4
a1119 5
      | not_occurs (ameta,CONSTYPE (tylist,METATYNAME{1=ref tyfun, ...})) = 
	not_occurs (ameta, 
		    apply (tyfun,tylist) handle NullTyfun => NULLTYPE)
      | not_occurs (ameta,CONSTYPE(t,n)) = 
	Lists.forall (fn x => not_occurs(ameta, x)) t
d1121 1
a1121 1
	Mapping.forall (amap,fn x => not_occurs (ameta,x)) 
d1124 17
a1140 14
		    ameta' as METATYVAR (x as ref (n',NULLTYPE),_,_)) = 
	if (type_eq (ameta,ameta',true,true))
	  then false
	else
	  (n > n') 
	  orelse
	  (x := (n,NULLTYPE);
	   true)
      | not_occurs (METATYVAR (ref (n,_),_,_),
		    METATYVAR (x as ref (n',NULLTYPE),_,_)) = 
	(n > n') 
	orelse
	(x := (n,NULLTYPE);
	 true)
d1142 1
a1142 1
	not (type_eq (ameta,t,true,true))
d1144 3
a1146 5
		    METATYVAR (x as ref (n',t),_,_)) = 
	((n > n') 
	 orelse
	 (x := (n,t);
	  not_occurs (ameta,t)))
d1151 1
a1151 1
	not_occurs (ameta,arec)
d1153 1
a1153 1
	not_occurs (ameta,t)
@


1.62
log
@Removed integer parameter
@
text
@d4 3
d433 1
a433 6
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("TYFUN = " ^ (string_tyfun t) ^ 
                              " and TYFUN = " ^ (string_tyfun t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   (a = a' andalso type_eq (atype,atype',false,false)))
d436 1
a436 7
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("ETA_TYFUN = " ^ (string_tyfun t) ^
                              " and ETA_TYFUN = " ^ (string_tyfun t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   Tyname_id.tyname_id_eq(tyname_id, tyname_id')
	)
d439 2
a440 6
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ((string_tyfun t) ^ " and " ^ (string_tyfun t') ^
                              "\n");
		 Print.print ("\n"))
	 else ();
	id = id')
d442 1
a442 6
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("two other tyfuns : " ^ (string_tyfun tyfun) ^
                              " and " ^ (string_tyfun tyfun') ^ "\n");
		 Print.print ("\n"))
	 else ();
	false)
d448 1
a448 6
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print("TYNAME  = " ^ (debug_print_name t) ^
                             " and TYNAME = " ^ (debug_print_name t') ^ "\n");
		 Print.print("\n"))
	 else ();
	   Tyname_id.tyname_id_eq (id,id'))
d452 1
a452 7
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print
		 ("METATYNAME (ref tyfun... = " ^ (debug_print_name t) ^
                  " and METATYNAME (ref tyfun'... = " ^(debug_print_name t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   tyfun_eq (tyfun,tyfun'))
d454 1
a454 6
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("two other tynames : " ^ (debug_print_name t) ^ 
                              " and " ^ (debug_print_name t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   false)
d459 5
a463 10
      (if (do_debug andalso Debug.debug_level () > 10)
	 then (Print.print ("TYVAR = " ^ (debug_print_type t) ^ 
                            " and TYVAR = " ^ (debug_print_type t') ^ "\n");
	       Print.print ("\n"))
       else ();
	 (sym = sym') 
	 andalso
	 (if eq_matters then eq = eq' else true)
	    andalso
	    (if imp_matters then imp = imp' else true))
d466 3
a468 8
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("FUNTYPE = " ^ (debug_print_type t) ^ 
                              " and FUNTYPE = " ^ (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   type_eq (ty1,ty1',eq_matters,imp_matters)
	   andalso
	   type_eq (ty2,ty2',eq_matters,imp_matters))
d473 9
a481 16
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("CONSTYPE (METATYNAME (NULL_TYFUN)) = " ^ 
                              (debug_print_type t) ^
                              " and CONSTYPE (METATYNAME (NULL_TYFUN)) = " ^
                              (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
          let
            fun collect ([],[]) = true
	      | collect ([],h::t) = false
	      | collect (h::t,[]) = false
	      | collect (h::t,h'::t') = 
	        type_eq (h,h',eq_matters,imp_matters) andalso collect (t,t')
          in
	    tyname_eq (name,name') andalso collect (l,l')
          end)
a485 6
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print 
		 ("CONSTYPE (METATYNAME (NULL_TYFUN),_) = " ^ (debug_print_type t) ^
                  " and CONSTYPE (name') = " ^ (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
d494 1
a494 1
	end)
a498 7
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print
		 ("CONSTYPE (name) = " ^ (debug_print_type t) ^ 
                  " and CONSTYPE (METATYNAME (NULL_TYFUN)) = " ^(debug_print_type t')
                  ^ "\n");
		 Print.print ("\n"))
	 else ();
d507 1
a507 1
	end)
d509 1
a509 7
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("CONSTYPE ([],_) = " ^ (debug_print_type t) ^ 
                              " and CONSTYPE ([],_))... = " ^ (debug_print_type t') ^
                              "\n");
		 Print.print ("\n"))
	 else ();
	tyname_eq (tyname,tyname'))
a512 6
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print
		 ("CONSTYPE (h::t,_) = " ^ (debug_print_type ty) ^ 
                  " and CONSTYPE (h::t,_) = " ^ (debug_print_type ty') ^ "\n");
		 Print.print ("\n"))
	 else ();
d521 1
a521 1
	end)
d535 1
a535 7
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print
		 ("METATYVAR (NULLTYPE) = " ^ (debug_print_type ty) ^ 
                  " and METATYVAR (NULLTYPE) = " ^ (debug_print_type ty') ^ "\n");
		 Print.print ("\n"))
	 else ();
	(t = t'))
d538 1
a538 7
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print 
		 ("META_OVERLOADED (NULLTYPE) = " ^ (debug_print_type ty) ^ 
                  " and META_OVERLOADED (NULLTYPE) = "^(debug_print_type ty') ^"\n");
		 Print.print ("\n"))
	 else ();
	(t = t'))
d540 1
a540 6
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("two other types : " ^ (debug_print_type ty) ^ " and "
                              ^ (debug_print_type ty') ^ "\n");
		 Print.print ("\n"))
	 else ();
	false)
d561 1
a561 1
        (if do_debug orelse show_eq options then
d565 3
a567 5
	if do_debug then
	  name ^ Tyfun_id.string_tyfun_id id ^ (if eq then "[t]" else "[f]")
        else name ^ (if show_eq options then
                      if eq then "[t]" else "[f]"
                     else "")
d569 3
a571 4
	if do_debug then "METATYNAME(" ^ name ^ "{" ^ string_tyfun tyfun ^ "}"
	else name ^ (if show_eq options then
                       if equalityp tyfun then "[t]" else "[f]"
                     else "")
d576 7
a582 2
    and debug_print_name t = print_name' debug_print_options t

d815 3
a817 8
	  (if (do_debug andalso Debug.debug_level () > 10) then
	     Print.print ("tyfun3 " ^ MLWorks.Integer.makestring arity ^ "\n")
	   else ();
	  if arity = Lists.length (tylist)
	    then
	      app_subst (atype,Array.arrayoflist (tylist))
	  else 
	    raise WrongArity)
d820 1
a820 5
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun4 ");
		   Print.print ("\n"))
	   else ();
	  CONSTYPE (tylist,name))
d822 1
a822 6
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun5 ");
                   Print.print (string_tyfun tyfun);
		   Print.print ("\n"))
	   else ();
	  apply (tyfun,tylist))
d824 1
a824 5
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun6 ");
		   Print.print ("\n"))
	   else ();
	  CONSTYPE (tylist,tyname))
d864 1
a864 6
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("label lookup \n");
	       Print.print (IdentPrint.printLab lab);
	       Print.print ("\n"))
       else ();
	 get_type_from_lab' (lab,atype))
d1137 2
a1138 7
      (if (do_debug andalso Debug.debug_level () > 5)
	 then (Print.print ("propagate " ^ (debug_print_type recty));
	       Print.print ("\n"))
	 else ();

       if level < level'
	 then r := (level, flex, propagate_level level ty, eq, imp)
a1139 1
	 
d1143 1
a1143 6
	(if (do_debug andalso Debug.debug_level () > 5)
	   then (Print.print ("propagate " ^ (debug_print_type (RECTYPE amap)));
		 Print.print ("\n"))
	 else ();

	RECTYPE (Mapping.mapit (amap, propagate_level level)))
d1146 1
a1146 6
	(if (do_debug andalso Debug.debug_level () > 5)
	   then (Print.print ("propagate " ^ (debug_print_type ty));
		 Print.print ("\n"))
	 else ();

	 if level < level' 
a1148 1
	   
d1152 1
a1152 6
	(if (do_debug andalso Debug.debug_level () > 5)
	   then (Print.print ("propagate " ^ (debug_print_type ty));
		 Print.print ("\n"))
	 else ();

	 ty)
@


1.61
log
@Corrected name of vector_tyname
Changed tyname_copy to handle flexible names not in the mapping.
@
text
@d4 4
a209 1
require "../utils/integer";
a218 1
  structure Integer : INTEGER
d643 1
a643 1
        "LAMBDA{" ^ (Integer.makestring n) ^ "}." ^
d646 1
a646 1
	"ETA{" ^ (Integer.makestring (tyname_arity aname)) ^ "}." ^
d806 1
a806 1
                                                      (Integer.makestring n)),
d835 1
a835 1
			                     (Integer.makestring n)),amap)
d905 2
a906 4
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun3 ");
		   Integer.print (arity);
		   Print.print ("\n"))
@


1.60
log
@Added print_tyvars and make_tyvars.
@
text
@d4 3
d281 1
a281 1
    val vector_tyname = make_tyname (1,true,"array",ABSENT)
d1357 2
a1358 2
    fun tyname_copy (METATYNAME {1 = ref (NULL_TYFUN id), ...}, tyname_copies) =
        Tyfun_id.Map.apply' (tyname_copies,id)
@


1.59
log
@Added closed_type_equalityp for getting equality attributes of
closed types.
@
text
@d4 4
d989 32
@


1.58
log
@Fixed bug in tyname_strip which didn't remove the simple TYFUN(CONSTYPE) case
This caused completion to fail
@
text
@d4 4
d277 1
d305 3
a307 1
    val dynamic_type = CONSTYPE ([],dynamic_tyname)
d392 16
a588 5
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("RECTYPE = " ^ (debug_print_type t) ^ 
                              " and RECTYPE = " ^ (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
d590 1
a590 1
			fn (x,y) => type_eq (x,y,eq_matters,imp_matters)))
a592 5
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("DEBRUIJN = " ^ (debug_print_type t) ^ 
                              " and DEBRUIJN = " ^ (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
d597 2
a598 7
	if imp_matters then imp = imp' else true)
      | type_eq' (NULLTYPE,NULLTYPE,_,_) = 
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("NULLTYPE and NULLTYPE \n");
		 Print.print ("\n"))
	 else ();
	   true)
@


1.57
log
@Added string_or_num_typep for spotting overloading of relationals to strings.
@
text
@d4 3
d343 6
@


1.56
log
@Options & Info changes
@
text
@d4 3
d1051 1
a1051 3
      (tyname_eq (name,int_tyname)
       orelse 
       tyname_eq (name,real_tyname))
d1053 4
@


1.55
log
@Rationalised use of Mapping structure
@
text
@d4 3
a210 2
  sharing IdentPrint.Info.Location = Datatypes.Ident.Location

d215 1
a215 1
    structure Info = IdentPrint.Info
d639 1
a639 1
    and print_name (Info.OPTIONS {show_eq_info, ...}) t =
d742 1
a742 1
	  (IdentPrint.printValId IdentPrint.Info.default_options id,depth,stack)
d831 1
a831 1
    and print_type (IdentPrint.Info.OPTIONS {show_eq_info, ...}) t =
@


1.54
log
@Added vector and bytearray tynames
@
text
@d4 3
d206 1
d955 1
a955 1
    val empty_rec_type = RECTYPE (Mapping.empty_map)
d957 8
@


1.53
log
@Added array_tyname
@
text
@d4 3
d259 2
@


1.52
log
@Added dynamic type definition
@
text
@d4 3
d255 1
@


1.51
log
@Added sharing
@
text
@d4 3
d252 1
d280 1
@


1.50
log
@Anel's last changes
@
text
@d4 3
d195 3
@


1.49
log
@Allow make_new_type to deal with METATYVAR returned by other failures
@
text
@d4 3
d256 2
a257 2
     NullTyfun is raised by the functions apply and name. These functions 
     are never applied in other functors before doing the necessary tests 
d259 1
a259 1
     Thus NullTyfun is not in the signature TYPES.
d263 1
a264 2
    exception Wrong_Arity

d285 2
a286 2
      | the_type (atype as (META_OVERLOADED (ref NULLTYPE))) = atype
      | the_type (META_OVERLOADED (ref atype)) = the_type atype
d318 1
a318 1
      | type_strip(ty as META_OVERLOADED(ref ty')) =
d335 1
a335 1
      | type_equalityp (METATYVAR (ref (_,t),eq,_)) = type_equalityp t
d340 2
a341 1
	tyname_eq(ref_tyname, n) orelse
d344 2
a345 2
      | type_equalityp (FUNTYPE(a,r)) = false
      | type_equalityp (DEBRUIJN (_,eq,_)) = true
a411 3
          (* andalso
	   arity = arity'
	   andalso eq = eq')*)
a462 26
(*
      | type_eq' (t as CONSTYPE (_,METATYNAME {1=ref(NULL_TYFUN _), ...}),
                 t' as CONSTYPE (l,METATYNAME {1=ref tyfun, ...}),
		 eq_matters,imp_matters) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("CONSTYPE (METATYNAME (NULL_TYFUN)) = " ^ 
                              (debug_print_type t) ^
                              " and CONSTYPE (METATYNAME ...,_) = " ^
                              (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (t,apply (tyfun,l),eq_matters,imp_matters)
	 handle NullTyfun => false)
      | type_eq' (t as CONSTYPE (l,METATYNAME{1=ref tyfun, ...}),
		 t' as CONSTYPE (_,name' as METATYNAME {1=ref(NULL_TYFUN _),
                                                        ...}),
		 eq_matters,imp_matters) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("CONSTYPE (METATYNAME ...,_) = "^(debug_print_type t) ^
                              " and CONSTYPE (METATYNAME (NULL_TYFUN)) = " ^
                              (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (apply (tyfun,l),t',eq_matters,imp_matters)
	 handle NullTyfun => false)
*)
a501 21
(*
      | type_eq' (t as CONSTYPE (l,METATYNAME{1=ref tyfun, ...}),ty,
		 eq_matters,imp_matters) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("CONSTYPE (METATYNAME ...,_) = " ^ (debug_print_type t)
                              ^ " and ty = " ^ (debug_print_type ty) ^ "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (apply (tyfun,l),ty,eq_matters,imp_matters)
	 handle NullTyfun => false)
      | type_eq' (ty,t as CONSTYPE (l,METATYNAME{1=ref tyfun, ...}),
		 eq_matters,imp_matters) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("ty = " ^ (debug_print_type ty) ^ 
                              " and CONSTYPE (METATYNAME ...,_) = " ^ 
                              (debug_print_type t) ^ "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (ty,apply (tyfun,l),eq_matters,imp_matters)
	 handle NullTyfun => false)
*)
d563 2
a564 2
      | type_eq' (ty as META_OVERLOADED (t as ref  NULLTYPE), 
		 ty' as META_OVERLOADED (t' as ref  NULLTYPE),_,_) = 
a571 66
(*
      | type_eq' (ty as METARECTYPE (ref (_,true,t,_,_)),ty',eq_matters,
                 imp_matters) = 
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print
		 ("METARECTYPE (true) = " ^ (debug_print_type ty) ^ 
                  " and " ^ (debug_print_type ty') ^ "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (t,ty',eq_matters,imp_matters))
      | type_eq' (ty,ty' as METARECTYPE (ref (_,true,t',_,_)),eq_matters,
                 imp_matters) = 
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print
		 ((debug_print_type ty) ^ 
                  " and METARECTYPE (true) = " ^ (debug_print_type ty') ^ "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (ty,t',eq_matters,imp_matters))
      | type_eq' (ty as METATYVAR (ref(_,t),_,_),t',eq_matters,imp_matters) = 
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("METATYVAR (t) = " ^ (debug_print_type ty) ^ 
                              " and t' = )" ^ (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (t,t',eq_matters,imp_matters))
      | type_eq' (t',ty as METATYVAR (ref(_,t),_,_),eq_matters,imp_matters) = 
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("t' = " ^ (debug_print_type t') ^ 
                              " and METATYVAR (t) = " ^ (debug_print_type ty) ^"\n");
		 Print.print ("\n"))
	 else ();
	type_eq (t,t',eq_matters,imp_matters))
      | type_eq' (ty as META_OVERLOADED (ref t),t',eq_matters,imp_matters) = 
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("META_OVERLOADED (t) = " ^ (debug_print_type ty) ^ 
                              " and t' = " ^ (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (t,t',eq_matters,imp_matters))
      | type_eq' (t',ty as META_OVERLOADED (ref t),eq_matters,imp_matters) = 
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("t' = " ^ (debug_print_type t') ^ 
                              " and META_OVERLOADED (t) = " ^ (debug_print_type ty) ^ 
                              "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (t,t',eq_matters,imp_matters))
      | type_eq' (ty as METARECTYPE (ref (_,false,t,_,_)),t',eq_matters,
                 imp_matters) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("METARECTYPE (false) = " ^ (debug_print_type ty) ^ 
                              " and t' = " ^ (debug_print_type t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (t,t',eq_matters,imp_matters))
      | type_eq' (t',ty as METARECTYPE (ref (_,false,t,_,_)),eq_matters,
                 imp_matters) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("t' = " ^ (debug_print_type t') ^ 
                              " and METARECTYPE (false) = " ^ (debug_print_type ty) ^
                              "\n");
		 Print.print ("\n"))
	 else ();
	type_eq (t,t',eq_matters,imp_matters))
*)
a601 8
	 (* ^
           (if #show_location_data options
              then 
                case location of
                  PRESENT x => (" from " ^ x)
                | _ => ""
            else "")
	 *)
a660 12
    and string_overloaded (t,depth,metastack) =
      let
	val how_deep = find_depth (t,depth,metastack)
	val num_str = if do_debug then "num-" else ""
      in
	if how_deep = 0
	  then
	    (num_str ^ (make_string (depth+1)),depth+1,t::metastack)
	else
	  (num_str ^ (make_string how_deep),depth,metastack)
      end
      
d716 3
a718 3
	| string_types (t as (META_OVERLOADED (ref NULLTYPE)),depth,stack,extras,option) =
	  string_overloaded (t,depth,stack)
	| string_types (META_OVERLOADED (ref t),depth,stack,extras,option) =
a840 5
(*
	  CONSTYPE (map
		    (fn x => app_subst (x,array_of_types))
		    atylist,atyname)
*)
d860 1
a860 1
	    raise Wrong_Arity)
d1147 2
a1148 2
      | not_occurs (ameta,t as META_OVERLOADED (ref NULLTYPE)) = true
      | not_occurs (ameta,META_OVERLOADED (ref t)) = true
a1237 2

    exception Instantiated
@


1.48
log
@Fixed type printing.
@
text
@d4 3
d1110 4
a1113 1
	| make_new_type (_,substlist) = Crash.impossible "Types.make_new_type"
d1119 2
a1120 1
	  let val substlist = make_substlist (tyvarlist,0,[])
@


1.47
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d886 1
a886 1
                check_elem len
d913 2
a914 2
		  if (is_a_function_type element_type orelse
		      is_a_record_type element_type) then
d929 1
a929 1
                  implode (print_as_a_tuple 1)
@


1.46
log
@Fixed typo in type_strip.
@
text
@d4 3
d165 3
a167 3
require "../typechecker/datatypes";
require "../typechecker/ty_debug";
require "../typechecker/types";
d185 2
d197 3
a199 5
    type PrintTypeOptions = 
      {
       show_eq_info : bool,
       show_location_data : bool
       }
d201 1
a201 2
    val default_PrintType_option = {show_eq_info = true,show_location_data = false}
    val default_interpreter_PrintType_option = {show_eq_info = true,show_location_data = true}
d203 2
d352 2
a353 2
	   then (Print.print ("TYFUN = " ^ (string_tyfun_using_default t) ^ 
                              " and TYFUN = " ^ (string_tyfun_using_default t') ^ "\n");
d360 2
a361 2
	   then (Print.print ("ETA_TYFUN = " ^ (string_tyfun_using_default t) ^
                              " and ETA_TYFUN = " ^ (string_tyfun_using_default t') ^ "\n");
d369 1
a369 1
	   then (Print.print ((string_tyfun_using_default t) ^ " and " ^ (string_tyfun_using_default t') ^
d376 2
a377 2
	   then (Print.print ("two other tyfuns : " ^ (string_tyfun_using_default tyfun) ^
                              " and " ^ (string_tyfun_using_default tyfun') ^ "\n");
d387 2
a388 2
	   then (Print.print("TYNAME  = " ^ (print_name t) ^
                             " and TYNAME = " ^ (print_name t') ^ "\n");
d397 2
a398 2
		 ("METATYNAME (ref tyfun... = " ^ (print_name t) ^
                  " and METATYNAME (ref tyfun'... = " ^(print_name t') ^ "\n");
d407 2
a408 2
	   then (Print.print ("two other tynames : " ^ (print_name t) ^ 
                              " and " ^ (print_name t') ^ "\n");
d417 2
a418 2
	 then (Print.print ("TYVAR = " ^ (print_type t) ^ 
                            " and TYVAR = " ^ (print_type t') ^ "\n");
d429 2
a430 2
	   then (Print.print ("FUNTYPE = " ^ (print_type t) ^ 
                              " and FUNTYPE = " ^ (print_type t') ^ "\n");
d442 1
a442 1
                              (print_type t) ^
d444 1
a444 1
                              (print_type t') ^ "\n");
d462 1
a462 1
                              (print_type t) ^
d464 1
a464 1
                              (print_type t') ^ "\n");
d474 1
a474 1
	   then (Print.print ("CONSTYPE (METATYNAME ...,_) = "^(print_type t) ^
d476 1
a476 1
                              (print_type t') ^ "\n");
d488 2
a489 2
		 ("CONSTYPE (METATYNAME (NULL_TYFUN),_) = " ^ (print_type t) ^
                  " and CONSTYPE (name') = " ^ (print_type t') ^ "\n");
d507 2
a508 2
		 ("CONSTYPE (name) = " ^ (print_type t) ^ 
                  " and CONSTYPE (METATYNAME (NULL_TYFUN)) = " ^(print_type t')
d525 2
a526 2
	   then (Print.print ("CONSTYPE (METATYNAME ...,_) = " ^ (print_type t)
                              ^ " and ty = " ^ (print_type ty) ^ "\n");
d534 1
a534 1
	   then (Print.print ("ty = " ^ (print_type ty) ^ 
d536 1
a536 1
                              (print_type t) ^ "\n");
d544 2
a545 2
	   then (Print.print ("CONSTYPE ([],_) = " ^ (print_type t) ^ 
                              " and CONSTYPE ([],_))... = " ^ (print_type t') ^
d555 2
a556 2
		 ("CONSTYPE (h::t,_) = " ^ (print_type ty) ^ 
                  " and CONSTYPE (h::t,_) = " ^ (print_type ty') ^ "\n");
d570 2
a571 2
	   then (Print.print ("RECTYPE = " ^ (print_type t) ^ 
                              " and RECTYPE = " ^ (print_type t') ^ "\n");
d579 2
a580 2
	   then (Print.print ("DEBRUIJN = " ^ (print_type t) ^ 
                              " and DEBRUIJN = " ^ (print_type t') ^ "\n");
d598 2
a599 2
		 ("METATYVAR (NULLTYPE) = " ^ (print_type ty) ^ 
                  " and METATYVAR (NULLTYPE) = " ^ (print_type ty') ^ "\n");
d607 2
a608 2
		 ("META_OVERLOADED (NULLTYPE) = " ^ (print_type ty) ^ 
                  " and META_OVERLOADED (NULLTYPE) = "^(print_type ty') ^"\n");
d617 2
a618 2
		 ("METARECTYPE (true) = " ^ (print_type ty) ^ 
                  " and " ^ (print_type ty') ^ "\n");
d626 2
a627 2
		 ((print_type ty) ^ 
                  " and METARECTYPE (true) = " ^ (print_type ty') ^ "\n");
d633 2
a634 2
	   then (Print.print ("METATYVAR (t) = " ^ (print_type ty) ^ 
                              " and t' = )" ^ (print_type t') ^ "\n");
d640 2
a641 2
	   then (Print.print ("t' = " ^ (print_type t') ^ 
                              " and METATYVAR (t) = " ^ (print_type ty) ^"\n");
d647 2
a648 2
	   then (Print.print ("META_OVERLOADED (t) = " ^ (print_type ty) ^ 
                              " and t' = " ^ (print_type t') ^ "\n");
d654 2
a655 2
	   then (Print.print ("t' = " ^ (print_type t') ^ 
                              " and META_OVERLOADED (t) = " ^ (print_type ty) ^ 
d663 2
a664 2
	   then (Print.print ("METARECTYPE (false) = " ^ (print_type ty) ^ 
                              " and t' = " ^ (print_type t') ^ "\n");
d671 2
a672 2
	   then (Print.print ("t' = " ^ (print_type t') ^ 
                              " and METARECTYPE (false) = " ^ (print_type ty) ^
d680 2
a681 2
	   then (Print.print ("two other types : " ^ (print_type ty) ^ " and "
                              ^ (print_type ty') ^ "\n");
d694 4
a697 3
    and string_tyfun (TYFUN (aty,n),options) = 
        "LAMBDA{" ^ (Integer.makestring n) ^ "}." ^ (print_type_with_option (aty,options))
      | string_tyfun (ETA_TYFUN aname,options) = 
d699 2
a700 2
	(print_name_using_option (aname,options))
      | string_tyfun (NULL_TYFUN (id),_) = 
d703 1
a703 5
    and string_tyfun_using_default t = string_tyfun(t,default_PrintType_option)

    and print_name t = print_name_using_option (t,default_PrintType_option)

    and print_name_using_option (TYNAME (_,name,_,ref eq,_,location),options) =
d705 1
a705 1
        (if do_debug orelse (#show_eq_info options) then
d707 2
a708 1
         else "") ^
d715 2
a716 1
      | print_name_using_option (METATYNAME (ref (NULL_TYFUN id),name,_,ref eq,_),options) = 
d719 1
a719 1
        else name ^ (if #show_eq_info options then
d722 3
a724 3
      | print_name_using_option (METATYNAME (ref tyfun,name,_,_,_),options) =
	if do_debug then "METATYNAME(" ^ name ^ "{" ^ string_tyfun_using_default tyfun ^ "}"
	else name ^ (if #show_eq_info options then
d728 5
d802 1
a802 1
	(print_name_using_option (name,option),depth,stack)
d804 1
a804 1
	("(" ^ acc_string ^ ")" ^ (print_name_using_option (name,option)),depth,stack)
d810 1
a810 1
	      (s ^ " " ^ (print_name_using_option (name,option)),depth,stack)
d813 1
a813 1
                        print_name_using_option (name,option)],
d922 1
a922 1
		if #show_eq_info option then "unit[t]" else "unit"
d932 2
a933 4
     and print_type_with_option (t,option) = 
          #1 (string_types (t,0,[],"",option))

    and print_type t = #1 (string_types (t,0,[],"",default_PrintType_option))
d935 1
a935 1
    and print_type_with_options (t,option) = #1 (string_types (t,0,[],"",option))
d979 1
a979 1
          Crash.impossible ("Types.app_subst " ^ (print_type ty))
d1002 1
a1002 1
                   Print.print (string_tyfun_using_default tyfun);
d1151 1
a1151 1
        Crash.impossible ("tyvar_equalityp "^(print_type t))
d1284 1
a1284 1
	 then (Print.print ("propagate " ^ (print_type recty));
d1296 1
a1296 1
	   then (Print.print ("propagate " ^ (print_type (RECTYPE amap)));
d1304 1
a1304 1
	   then (Print.print ("propagate " ^ (print_type ty));
d1316 1
a1316 1
	   then (Print.print ("propagate " ^ (print_type ty));
d1360 1
a1360 1
      | name tyfun = Crash.impossible ("Types.name " ^ string_tyfun_using_default tyfun)
@


1.45
log
@Improved type_eq by stripping rubbish off types before matching
@
text
@d4 3
d304 1
a304 1
       | _ => type_strip ty)
d308 1
a308 1
	 | _ => type_strip ty)
@


1.44
log
@Added special maps for tyfun_id, tyname_id, strname_id
@
text
@d4 3
d298 15
d317 1
a317 1
    fun type_equalityp (TYVAR (_,Ident.TYVAR (_,eq,_))) = eq
d406 1
a406 1
    and type_eq (t as TYVAR (_,Ident.TYVAR (sym,eq,imp)),
d419 1
a419 1
      | type_eq (t as FUNTYPE(ty1,ty2),t' as FUNTYPE(ty1',ty2'),
d429 1
a429 1
      | type_eq (t as CONSTYPE(l,name as METATYNAME{1=ref (NULL_TYFUN _),...}),
d449 2
a450 1
      | type_eq (t as CONSTYPE (_,METATYNAME {1=ref(NULL_TYFUN _), ...}),
d462 1
a462 1
      | type_eq (t as CONSTYPE (l,METATYNAME{1=ref tyfun, ...}),
d474 2
a475 1
      | type_eq (t as CONSTYPE (tylist,name as METATYNAME 
d494 1
a494 1
      | type_eq (t as CONSTYPE (tylist,name),
d514 2
a515 1
      | type_eq (t as CONSTYPE (l,METATYNAME{1=ref tyfun, ...}),ty,
d524 1
a524 1
      | type_eq (ty,t as CONSTYPE (l,METATYNAME{1=ref tyfun, ...}),
d534 2
a535 1
      | type_eq (t as CONSTYPE ([],tyname),t' as CONSTYPE ([],tyname'),_,_) =
d543 1
a543 1
      | type_eq (ty as CONSTYPE (tylist as h::t,tyname),
d561 1
a561 1
      | type_eq (t as RECTYPE amap,t' as RECTYPE amap',eq_matters,imp_matters)=
d569 1
a569 1
      | type_eq (t as DEBRUIJN (d,eq,imp),t' as DEBRUIJN (d',eq',imp'),
d581 1
a581 1
      | type_eq (NULLTYPE,NULLTYPE,_,_) = 
d587 1
a587 1
      | type_eq (ty as METATYVAR (t as ref (_,NULLTYPE),_,_),
d596 1
a596 1
      | type_eq (ty as META_OVERLOADED (t as ref  NULLTYPE), 
d605 2
a606 1
      | type_eq (ty as METARECTYPE (ref (_,true,t,_,_)),ty',eq_matters,
d615 1
a615 1
      | type_eq (ty,ty' as METARECTYPE (ref (_,true,t',_,_)),eq_matters,
d624 1
a624 1
      | type_eq (ty as METATYVAR (ref(_,t),_,_),t',eq_matters,imp_matters) = 
d631 1
a631 1
      | type_eq (t',ty as METATYVAR (ref(_,t),_,_),eq_matters,imp_matters) = 
d638 1
a638 1
      | type_eq (ty as META_OVERLOADED (ref t),t',eq_matters,imp_matters) = 
d645 1
a645 1
      | type_eq (t',ty as META_OVERLOADED (ref t),eq_matters,imp_matters) = 
d653 1
a653 1
      | type_eq (ty as METARECTYPE (ref (_,false,t,_,_)),t',eq_matters,
d661 1
a661 1
      | type_eq (t',ty as METARECTYPE (ref (_,false,t,_,_)),eq_matters,
d670 2
a671 1
      | type_eq (ty,ty',_,_) = 
d678 8
@


1.43
log
@Fixes to print flexible records properly
@
text
@d4 3
d1339 4
a1342 3
        (case NewMap.tryApply'(tyname_copies,id) of
	   NewMap.YES _ => tyname_copies
	 | NewMap.NO => NewMap.define(tyname_copies, id, copy_fun meta))
d1352 1
a1352 1
        NewMap.apply' (tyname_copies,id)
@


1.42
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d744 2
a745 2
	val how_deep = find_depth (t,depth,metastack)
	val (s,new_depth,stack) = string_types (t',depth,metastack,option)
a747 1
	val meta_str = if do_debug then "metarec-" else ""
d749 1
a749 7
	if how_deep = 0
	  then
	    (eq_bit ^ imp_bit ^ meta_str ^ (make_string(new_depth+1)) ^ "-",
	     new_depth+1,t::stack)
	else
	  (eq_bit ^ imp_bit ^ meta_str ^ (make_string how_deep) ^ "-",
	   new_depth,stack)
d754 6
a759 7
    and string_constype (t as (CONSTYPE ([],name)),depth,stack,acc_string,option) 
      = if acc_string = "" 
	  then
	      (print_name_using_option (name,option),depth,stack)
	  else
	    ("(" ^ acc_string ^ ")" ^ (print_name_using_option (name,option)),depth,stack)
	| string_constype (CONSTYPE ([h],name),depth,stack,acc_string,option) =
d761 1
a761 1
	    val (s,_,_) = string_types (h,depth,stack,option)
d770 1
a770 1
	| string_constype (CONSTYPE (h::t,name),depth,stack,acc_string,option) =
d772 1
a772 1
	    val (s,_,_) = string_types (h,depth,stack,option)
d775 1
a775 1
	      string_constype (CONSTYPE (t, name), depth, stack, s,option)
d778 1
a778 1
			       depth,stack,acc_string ^ ", " ^ s,option)
d792 1
a792 1
    and string_types (t as (METATYVAR (ref(_,NULLTYPE),_,_)),depth,stack,option) =
d794 3
a796 3
	| string_types (METATYVAR (ref(_,t),_,_),depth,stack,option) =
	  string_types (t,depth,stack,option)
	| string_types (t as (META_OVERLOADED (ref NULLTYPE)),depth,stack,option) =
d798 2
a799 2
	| string_types (META_OVERLOADED (ref t),depth,stack,option) =
	  string_types (t,depth,stack,option)
d801 3
a803 2
                        depth,stack,option) = string_types (t,depth,stack,option)
	| string_types (t as (METARECTYPE (ref (_,true,_,_,_))),depth,stack,option) =
d805 3
a807 3
	| string_types (METARECTYPE (ref(_,_,t,_,_)),depth,stack,option) =
	  string_types (t,depth,stack,option)
	| string_types (DEBRUIJN n,depth,stack,option) =
d809 1
a809 1
	| string_types (TYVAR (_,t),depth,stack,option) =
d811 2
a812 2
	| string_types (NULLTYPE,depth,stack,option) = ("Nulltype ",depth,stack)
	| string_types (FUNTYPE (a,r),depth,stack,option) =
d814 2
a815 2
	    val (s,d,m) = string_types (a,depth,stack,option)
	    val (s',d',m') = string_types (r,d,m,option)
d822 3
a824 3
	| string_types (t as (CONSTYPE (_,_)),depth,stack,option) =
	  string_constype (t,depth,stack,"",option)
	| string_types (RECTYPE amap,depth,stack,option) =
d833 1
a833 1
                                         amap)
d844 1
a844 1
		val (s,new_depth,new_stack) = string_types(t,depth,stack,option)
d858 12
a869 11
	      let val element_type =
			Mapping.lookup (Ident.LAB (Ident.Symbol.find_symbol
							(Integer.makestring n)),
					amap)
		  val element_string = 
			if is_a_function_type element_type orelse
			   is_a_record_type element_type then
			  "(" ^ ref_printer element_type ^ ")"
			else ref_printer element_type
              in if n = len then [element_string]
                 else element_string :: " * " :: print_as_a_tuple (n+1)
d877 5
a881 2
	      else if is_a_tuple then implode (print_as_a_tuple 1)
              else "{"^ (implode (rec_list (explode comma_rec_string))) ^ "}"
d887 1
a887 1
          #1 (string_types (t,0,[],option))
d889 1
a889 1
    and print_type t = #1 (string_types (t,0,[],default_PrintType_option))
d891 1
a891 1
    and print_type_with_options (t,option) = #1 (string_types (t,0,[],option))
a977 9
(*
      | null_tyfunp(TYFUN(CONSTYPE([],METATYNAME{1=ref tyfun, ...}),_)) = 
	null_tyfunp tyfun
      | null_tyfunp(TYFUN(CONSTYPE(types, METATYNAME{1=ref tyfun, ...}),_)) = 
	if check_debruijns(types, 0) then
	  null_tyfunp tyfun
	else
	  false
*)
a994 6
(*
	let 
	  fun collect [] = true
	    | collect (h::t) = (imperativep h) andalso (collect t)
	in
*)
a995 3
(*
	end
*)
a1201 7
(*
	let fun collect [] = true
	      | collect (h::t) = not_occurs (ameta,h) andalso (collect t)
	in
	  collect t
	end
*)
a1303 10
     Determine whether the type function has an uninstantiated type name.
     ****)

(*
    fun has_a_new_name (ETA_TYFUN (METATYNAME{1=ref(NULL_TYFUN _), ...})) = true
      | has_a_new_name (ETA_TYFUN (METATYNAME{1=ref tyfun, ...})) = has_a_new_name tyfun
      | has_a_new_name _ = false
*)

    (****
d1308 2
a1309 1
      | has_a_name (ETA_TYFUN (METATYNAME {1=ref tyfun, ...})) = has_a_name tyfun
a1388 3
(*
       (fn ty => fn tyvs => tyvars (tyvs, ty)) tyvarlist amap
*)
@


1.41
log
@Changed type of Map.fold
@
text
@d4 3
d180 5
a184 3
    (****
     show_eq_info controls the printing of equality information of types.
     ****)
d186 2
a187 1
    val show_eq_info = ref false;
d189 2
a190 2
    fun make_tyname (n,eq,pname) = 
      TYNAME (Tyname_id.make_tyname_id (),pname,n,ref eq, ref empty_valenv)
d192 1
a192 1
    fun get_tyname_id (TYNAME (id,_,_,_,_)) = id
d196 1
a196 1
    fun tyname_arity (TYNAME (_,_,n,_,_)) = n
d203 1
a203 1
    fun tyname_make_false (TYNAME (_,_,_,r,_)) = (r := false; false)
d209 8
a216 8
    val bool_tyname = make_tyname (0,true,"bool")
    val int_tyname = make_tyname (0,true,"int")
    val real_tyname = make_tyname (0,true,"real")
    val string_tyname = make_tyname (0,true,"string")
    val list_tyname = make_tyname (1,true,"list")
    val ref_tyname = make_tyname (1,true,"ref")
    val exn_tyname = make_tyname (0,false,"exn")
    val ml_value_tyname = make_tyname (0,true,"ml_value")
d307 1
a307 1
    and eq_attrib (TYNAME (_,_,_,ref eq,_)) = eq
d318 1
a318 45
(*
    and tyfun_eq' (t as ETA_TYFUN (METATYNAME{1=ref tyfun, ...}),t' as tyfun') =
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("ETA_TYFUN (METATYNAME... = " ^ (string_tyfun t) 
                              ^ " and tyfun = " ^ (string_tyfun t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	 tyfun_eq (tyfun,tyfun'))
      | tyfun_eq' (t as tyfun,t' as ETA_TYFUN (METATYNAME {1=ref tyfun', ...}))=
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("tyfun = " ^ (string_tyfun t) ^
                              " and ETA_TYFUN (METATYNAME... = " ^ 
                              (string_tyfun t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	tyfun_eq (tyfun,tyfun'))
      | tyfun_eq' (t as TYFUN (ty as CONSTYPE (_,METATYNAME _),_),
                 t' as TYFUN (ty' as CONSTYPE (_,METATYNAME _),_)) =
        (if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("TYFUN (CONSTYPE (METATYNAME... = " ^
                              (string_tyfun t) ^
                              "TYFUN (CONSTYPE (METATYNAME... = " ^
                              (string_tyfun t') ^ "\n");
	         Print.print ("\n"))
         else ();
	   type_eq (ty,ty',false,false))
      | tyfun_eq' (t as TYFUN (CONSTYPE([],METATYNAME{1=ref tyfun, ...}),_),
                  t' as tyfun') =
        (if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("TYFUN (CONSTYPE (METATYNAME... = " ^
                              (string_tyfun t) ^
                              " and tyfun' = " ^ (string_tyfun t') ^ "\n");
	         Print.print ("\n"))
         else ();
	   tyfun_eq' (tyfun,tyfun'))
      | tyfun_eq' (t as tyfun,
                  t' as TYFUN (CONSTYPE([],METATYNAME{1=ref tyfun', ...}),_)) =
	(if (do_debug andalso Debug.debug_level () > 10)
	   then (Print.print ("tyfun = " ^ (string_tyfun t) ^ 
                              " and TYFUN (CONSTYPE (METATYNAME... = " ^
                              (string_tyfun t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   tyfun_eq' (tyfun,tyfun'))
*)
d321 2
a322 2
	   then (Print.print ("TYFUN = " ^ (string_tyfun t) ^ 
                              " and TYFUN = " ^ (string_tyfun t') ^ "\n");
d329 2
a330 2
	   then (Print.print ("ETA_TYFUN = " ^ (string_tyfun t) ^
                              " and ETA_TYFUN = " ^ (string_tyfun t') ^ "\n");
a333 3
(*
	tyname_eq (tyname,tyname')
*)
d335 1
a335 32
(*
      | tyfun_eq' (t as TYFUN (CONSTYPE (types,tyname),_),
                  t' as ETA_TYFUN (tyname')) =
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("TYFUN = " ^ (string_tyfun t) ^ 
                              " and ETA_TYFUN = " ^ (string_tyfun t') ^ "\n");
		 Print.print ("\n"))
	 else ();
(*
	   Print.print"Funny tyfun_eq case of TYFUN(CONS) and ETA_TYFUN\n";
*)
	   if check_debruijns(types, 0) then
	     tyname_eq (tyname,tyname')
	   else
	     (Print.print"Funny tyfun_eq case of TYFUN(CONS) and ETA_TYFUN fails on debruijns\n";
	      false))
      | tyfun_eq' (t as ETA_TYFUN (tyname),
                  t' as TYFUN (CONSTYPE (types,tyname'),_)) =
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("ETA_TYFUN = " ^ (string_tyfun t) ^
                              " and ETA_TYFUN = " ^ (string_tyfun t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	   if check_debruijns(types, 0) then
	     tyname_eq (tyname,tyname')
	   else
	     (Print.print"Funny tyfun_eq case of TYFUN(CONS) and ETA_TYFUN fails on debruijns\n";
	      false))
(*
	   Print.print"Funny tyfun_eq case of ETA_TYFUN and TYFUN(CONS)\n";
*)
*)
d338 1
a338 1
	   then (Print.print ((string_tyfun t) ^ " and " ^ (string_tyfun t') ^
d345 2
a346 2
	   then (Print.print ("two other tyfuns : " ^ (string_tyfun tyfun) ^
                              " and " ^ (string_tyfun tyfun') ^ "\n");
d354 1
a354 1
    and tyname_eq' (t as TYNAME (id,_,_,_,_),t' as TYNAME (id',_,_,_,_)) =
d361 1
a361 20
(*
      | tyname_eq (t as METATYNAME{1=ref(ETA_TYFUN tyname),...},t' as tyname')=
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print
		 ("METATYNAME (ref ETA_TYFUN tyname ... = " ^ (print_name t) ^
                  " and tyname' = " ^ (print_name t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	tyname_eq (tyname,tyname'))
      | tyname_eq (t as tyname,
                   t' as METATYNAME{1=ref(ETA_TYFUN tyname'), ...}) =
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print
		 ("tyname = " ^ (print_name t) ^
                  " and METATYNAME (ref (ETA_TYFUN tyname' ... = " ^ 
                  (print_name t') ^ "\n");
		 Print.print ("\n"))
	 else ();
 	tyname_eq (tyname,tyname'))
*)
d649 3
a651 5
    (* string_tyfun should only be called when printing debugging
       information. *)
    and string_tyfun (TYFUN (aty,n)) = 
        "LAMBDA{" ^ (Integer.makestring n) ^ "}." ^ (print_type aty)
      | string_tyfun (ETA_TYFUN aname) = 
d653 2
a654 2
	(print_name aname)
      | string_tyfun (NULL_TYFUN (id)) = 
d657 16
a672 5
    and print_name (TYNAME (_,name,_,ref eq,_)) =
	name ^ (if do_debug orelse !show_eq_info then
		  if eq then "[t]" else "[f]"
		else "")
      | print_name (METATYNAME (ref (NULL_TYFUN id),name,_,ref eq,_)) = 
d675 1
a675 1
        else name ^ (if !show_eq_info then
d678 3
a680 3
      | print_name (METATYNAME (ref tyfun,name,_,_,_)) =
	if do_debug then "METATYNAME(" ^ name ^ "{" ^ string_tyfun tyfun ^ "}"
	else name ^ (if !show_eq_info then
d739 1
a739 1
			depth,metastack) =
d742 1
a742 1
	val (s,new_depth,stack) = string_types (t',depth,metastack)
d755 1
a755 1
      | string_metarec (_,depth,metastack) =
d758 1
a758 1
    and string_constype (t as (CONSTYPE ([],name)),depth,stack,acc_string) 
d761 1
a761 1
	      (print_name name,depth,stack)
d763 2
a764 2
	    ("(" ^ acc_string ^ ")" ^ (print_name name),depth,stack)
	| string_constype (CONSTYPE ([h],name),depth,stack,acc_string) =
d766 1
a766 1
	    val (s,_,_) = string_types (h,depth,stack)
d769 1
a769 1
	      (s ^ " " ^ (print_name name),depth,stack)
d771 2
a772 1
	      (implode ["(", acc_string, ", ", s, ")", print_name name],
d775 1
a775 1
	| string_constype (CONSTYPE (h::t,name),depth,stack,acc_string) =
d777 1
a777 1
	    val (s,_,_) = string_types (h,depth,stack)
d780 1
a780 1
	      string_constype (CONSTYPE (t, name), depth, stack, s)
d783 1
a783 1
			       depth,stack,acc_string ^ ", " ^ s)
d797 1
a797 1
    and string_types (t as (METATYVAR (ref(_,NULLTYPE),_,_)),depth,stack) =
d799 3
a801 3
	| string_types (METATYVAR (ref(_,t),_,_),depth,stack) =
	  string_types (t,depth,stack)
	| string_types (t as (META_OVERLOADED (ref NULLTYPE)),depth,stack) =
d803 2
a804 2
	| string_types (META_OVERLOADED (ref t),depth,stack) =
	  string_types (t,depth,stack)
d806 6
a811 6
                        depth,stack) = string_types (t,depth,stack)
	| string_types (t as (METARECTYPE (ref (_,true,_,_,_))),depth,stack) =
	  string_metarec (t,depth,stack)
	| string_types (METARECTYPE (ref(_,_,t,_,_)),depth,stack) =
	  string_types (t,depth,stack)
	| string_types (DEBRUIJN n,depth,stack) =
d813 1
a813 1
	| string_types (TYVAR (_,t),depth,stack) =
d815 2
a816 2
	| string_types (NULLTYPE,depth,stack) = ("Nulltype ",depth,stack)
	| string_types (FUNTYPE (a,r),depth,stack) =
d818 2
a819 2
	    val (s,d,m) = string_types (a,depth,stack)
	    val (s',d',m') = string_types (r,d,m)
d826 3
a828 3
	| string_types (t as (CONSTYPE (_,_)),depth,stack) =
	  string_constype (t,depth,stack,"")
	| string_types (RECTYPE amap,depth,stack) =
d848 1
a848 1
		val (s,new_depth,new_stack) = string_types(t,depth,stack)
d879 1
a879 1
		if !show_eq_info then "unit[t]" else "unit"
d886 2
a887 1
    and print_type t = #1 (string_types (t,0,[]))
d889 4
a936 26
(*    in*)
      
(*
      and apply (TYFUN (atype as CONSTYPE (_,METATYNAME 
					   {1=ref (NULL_TYFUN _), ...}),
			arity),tylist) = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("tyfun1 ");
	       Integer.print (arity);
	       Print.print ("\n"))
       else ();
	  if arity = Lists.length (tylist)
	    then
	      app_subst (atype,Array.arrayoflist (tylist))
	  else 
	    raise Wrong_Arity)
	| apply (TYFUN (CONSTYPE (_,METATYNAME {1=ref tyfun, ...}),arity),
		 tylist) = 
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun2 ");
		   Integer.print (arity);
                   Print.print (string_tyfun tyfun);
		   Print.print ("\n"))
	   else ();
	     apply (tyfun,tylist))
*)
d958 1
a958 1
                   Print.print (string_tyfun tyfun);
d1350 1
a1350 1
      | name tyfun = Crash.impossible ("Types.name " ^ string_tyfun tyfun)
d1445 1
@


1.40
log
@Removed simpletypes and its structures, they're in datatypes
@
text
@d4 3
d911 1
a911 1
            val len = Lists.length (Mapping.domain amap)
d1524 6
a1529 1
       Mapping.fold (fn ty => fn tyvs => tyvars (tyvs, ty)) tyvarlist amap
@


1.39
log
@Improved printing of types, including placing of brackets.
Meta status of types, etc., only printed when do_debug is true
@
text
@d4 4
a139 1
require "../utils/map";
a143 1
require "../typechecker/simpletypes";
a149 1
  structure Mapping : MAP
a157 2
  structure Tyname_id : TYNAME_ID
  structure Tyfun_id : TYFUN_ID
a163 1

@


1.38
log
@Improved versions of tyfun_eq and tyname_eq
@
text
@d4 3
d176 6
d282 27
a308 1
    fun tyfun_eq(tyfun, tyfun') =
d319 1
a319 1
      | tyfun_eq (t as tyfun,t' as ETA_TYFUN (METATYNAME {1=ref tyfun', ...}))=
d739 2
d750 3
a752 1
        if eq then name ^ "[t]" else name ^ "[f]"
d754 5
a758 2
	if eq then name ^ Tyfun_id.string_tyfun_id id ^ "[t]"
        else name ^ Tyfun_id.string_tyfun_id id ^ "[f]"
d760 4
a763 1
	"METATYNAME(" ^ name ^ "{" ^ string_tyfun tyfun ^ "}"
d788 1
d792 1
a792 1
	      ("meta-" ^ (make_string (depth+1)),depth+1,t::metastack)
d794 1
a794 1
	    ("meta-" ^ (make_string how_deep),depth,metastack)
d805 1
a805 1
      "deb-" ^ make_string (depth+1)
d810 1
d814 1
a814 1
	    ("num-" ^ (make_string (depth+1)),depth+1,t::metastack)
d816 1
a816 1
	  ("num-" ^ (make_string how_deep),depth,metastack)
d826 1
d830 1
a830 1
	    (eq_bit ^ imp_bit ^ "metarec-" ^ (make_string(new_depth+1))^"-",
d833 1
a833 1
	  (eq_bit ^ imp_bit ^ "metarec-" ^ (make_string how_deep) ^ "-",
d845 10
d867 10
d878 1
a878 1
	string_metatyvar (t,depth,stack)
a899 7
            fun is_a_function_type (Datatypes.FUNTYPE _) = true
              | is_a_function_type (Datatypes.METATYVAR 
                                    (ref (_,Datatypes.NULLTYPE),_,_)) = false
              | is_a_function_type (Datatypes.METATYVAR (ref (_,ty),_,_)) = 
                is_a_function_type ty
              | is_a_function_type _ = false
            val need_brackets = is_a_function_type a
d901 1
a901 1
	    ((if need_brackets 
d917 1
a917 1
                                          amap)
d936 1
a936 1
	       fn x => "," ^ (IdentPrint.printLab x),
d942 20
a961 11
              if n = len
                then 
                  [ref_printer (Mapping.lookup (Ident.LAB 
                                                (Ident.Symbol.find_symbol
                                                 (Integer.makestring n)),
                                                amap))]
              else (ref_printer (Mapping.lookup (Ident.LAB
                                                 (Ident.Symbol.find_symbol
                                                  (Integer.makestring n)),
                                                 amap)) 
                    :: " * " :: print_as_a_tuple (n+1))
d963 1
a963 5
	    (if is_a_tuple then 
	       if len = 0 then "()"
	       else "(" ^ implode (print_as_a_tuple 1) ^ ")"
             else "{"^ (implode (rec_list (explode comma_rec_string))) ^ "}",
	     !depth_ref,!stack_ref)
a1227 26
    (****
     type_equalityp determines the equality attribute of a type.
     ****)

    fun type_equalityp (TYVAR (_,Ident.TYVAR (_,eq,_))) = eq
      | type_equalityp (METATYVAR (ref (_,NULLTYPE),eq,_)) = eq
      | type_equalityp (METATYVAR (ref (_,t),eq,_)) = type_equalityp t
      | type_equalityp (META_OVERLOADED _) = true
      | type_equalityp (METARECTYPE (ref (_,_,t,_,_))) = type_equalityp t
      | type_equalityp (CONSTYPE ([],n)) = eq_attrib n
      | type_equalityp (CONSTYPE (tylist as h::t,n)) =
	tyname_eq(ref_tyname, n) orelse
	((eq_attrib n) andalso (Lists.forall type_equalityp tylist))
      | type_equalityp (RECTYPE amap) = Mapping.forall (amap,type_equalityp)
      | type_equalityp (FUNTYPE(a,r)) = false
      | type_equalityp (DEBRUIJN (_,eq,_)) = true
      | type_equalityp NULLTYPE = true
  
    and eq_attrib (TYNAME (_,_,_,ref eq,_)) = eq
      | eq_attrib (METATYNAME (ref (NULL_TYFUN _),_,_,ref eq,_)) = eq
      | eq_attrib (METATYNAME (ref tyfun,_,_,_,_)) = equalityp tyfun

    and equalityp (TYFUN (atype,a)) = type_equalityp atype
      | equalityp (ETA_TYFUN (tyname)) = eq_attrib tyname
      | equalityp (NULL_TYFUN (_)) = false
	
@


1.37
log
@Removed has_a_new_name, no longer needed. Recoded meta_tyname
@
text
@d4 3
d257 21
a277 1
    fun tyfun_eq (t as ETA_TYFUN (METATYNAME{1=ref tyfun, ...}),t' as tyfun') =
d292 1
a292 1
      | tyfun_eq (t as TYFUN (ty as CONSTYPE (_,METATYNAME _),_),
d302 1
a302 1
      | tyfun_eq (t as TYFUN (CONSTYPE([],METATYNAME{1=ref tyfun, ...}),_),
d310 2
a311 2
	   tyfun_eq (tyfun,tyfun'))
      | tyfun_eq (t as tyfun,
d319 3
a321 2
	   tyfun_eq (tyfun,tyfun'))
      | tyfun_eq (t as TYFUN (atype,a),t' as TYFUN (atype',a')) =
d328 2
a329 1
      | tyfun_eq (t as ETA_TYFUN (tyname),t' as ETA_TYFUN (tyname')) = 
d335 7
a341 2
	tyname_eq (tyname,tyname'))
      | tyfun_eq (t as TYFUN (CONSTYPE (types,tyname),_),
d356 1
a356 1
      | tyfun_eq (t as ETA_TYFUN (tyname),
d371 2
a372 1
      | tyfun_eq (t as NULL_TYFUN (id),t' as NULL_TYFUN (id')) =
d379 1
a379 1
      | tyfun_eq (tyfun,tyfun') =
d387 4
a390 1
    and tyname_eq (t as TYNAME (id,_,_,_,_),t' as TYNAME (id',_,_,_,_)) =
d397 1
d416 2
a417 1
      | tyname_eq (t as METATYNAME{1=ref tyfun, 3=arity, 4=eq, ...},
d429 1
a429 1
      | tyname_eq (t,t') = 
@


1.36
log
@Stuff to understand type functions properly
@
text
@d4 3
d912 1
a925 1
(*
d936 1
a936 1
        | apply (TYFUN (atype,arity),tylist) =
d977 1
d985 1
d1097 4
a1100 28
    local
      fun follow_names(TYFUN(CONSTYPE(types,name as METATYNAME
				      {1=ref (NULL_TYFUN _),...}),_),name') =
	if check_debruijns(types, 0) then
	  name
	else
	  name'
	| follow_names (TYFUN (CONSTYPE (types,name as METATYNAME 
					 {1=ref tyfun,...}),_),name') =
	  if check_debruijns(types, 0) then
	    follow_names (tyfun,name)
	  else
	    name'
	| follow_names (ETA_TYFUN (name as METATYNAME {1=ref(NULL_TYFUN _),...}
				   ),_) = name
	| follow_names (ETA_TYFUN (name as METATYNAME {1=ref tyfun,...}),_) = 
	  follow_names (tyfun,name)
	| follow_names (tyfun,name) = name
    in
      fun meta_tyname(ETA_TYFUN(meta as METATYNAME{1=ref tyfun, ...})) =
	follow_names (tyfun,meta)
      | meta_tyname
	(tyf as TYFUN(CONSTYPE
		      (types,meta as METATYNAME{1=ref tyfun, 2=s, ...}),_)) =
	if check_debruijns(types, 0) then
	  follow_names(tyfun,meta)
	else
	  METATYNAME(ref tyf, s, 0, ref false, ref empty_valenv)
a1101 1
    end
d1357 1
d1361 1
@


1.35
log
@Fixed bug in tyname_copy which copied too much stuff.
@
text
@d4 3
d246 5
d308 1
a308 1
      | tyfun_eq (t as TYFUN (CONSTYPE (_,tyname),_),
d315 8
a322 1
	tyname_eq (tyname,tyname'))
d324 1
a324 1
                  t' as TYFUN (CONSTYPE (_,tyname'),_)) =
d330 8
a337 1
	tyname_eq (tyname,tyname'))
d882 12
d897 1
d922 1
d932 1
d973 2
a974 4
    fun null_tyfunp (NULL_TYFUN (_)) = true
      | null_tyfunp (TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),_)) = 
	null_tyfunp (tyfun)
      | null_tyfunp (ETA_TYFUN (METATYNAME{1=ref tyfun, ...})) =
d976 7
d998 1
d1003 3
a1005 1
	  collect (tylist)
d1007 1
d1041 2
a1042 1
	  let val new_debruijn = DEBRUIJN (n,true,true) (* arbitrary choice *)
d1093 12
a1104 6
      fun follow_names (TYFUN (CONSTYPE (_,name as METATYNAME 
					 {1=ref (NULL_TYFUN _),...}),_),_) = 
	name
	| follow_names (TYFUN (CONSTYPE (_,name as METATYNAME 
					 {1=ref tyfun,...}),_),_) =
	  follow_names (tyfun,name)
d1111 1
a1111 1
      fun meta_tyname (ETA_TYFUN (meta as METATYNAME {1=ref tyfun, ...})) = 
d1113 7
a1119 3
      | meta_tyname (TYFUN (CONSTYPE
			    (_,meta as METATYNAME {1=ref tyfun, ...}),_)) = 
	follow_names (tyfun,meta)
d1265 1
d1271 2
@


1.34
log
@Ensured new names propagated through tyfuns and tynames
@
text
@d4 3
d1364 1
a1364 1
    fun tyname_copy (meta as METATYNAME {1=ref (NULL_TYFUN id), ...}, tyname_copies) =
d1366 2
d1371 1
d1377 1
@


1.33
log
@Made various changes so that structure copying can be
done more efficiently.
@
text
@d4 4
d265 1
a265 1
      | tyfun_eq (t as TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),_),
d275 1
a275 1
                  t' as TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun', ...}),_)) =
d641 1
a641 1
      "LAMBDA{" ^ (Integer.makestring n) ^ "}." ^ (print_type aty)
d649 1
a649 1
      if eq then name ^ "[t]" else name ^ "[f]"
d651 1
a651 2
	if eq then 
          name ^ Tyfun_id.string_tyfun_id id ^ "[t]"
d653 2
a654 1
      | print_name (METATYNAME (ref tyfun,_,_,_,_)) = string_tyfun tyfun
d1363 4
a1366 8
      | tyname_copy (METATYNAME {1 = ref (ETA_TYFUN 
	                                  (meta as METATYNAME 
					   {1 = ref tyfun,...})),...},
		     tyname_copies) =
	tyname_copy (meta,tyname_copies)
      | tyname_copy (tyname,_) = tyname

    fun tyfun_copy (tyfun,tyname_copies) = 
d1371 1
d1377 1
a1377 1
    fun type_copy (ty, tyname_copies) =
@


1.32
log
@Added Anel's changes, and changed some stuff to do better
equality checking of valenvs etc.
@
text
@d4 4
d1310 3
a1312 9
    fun has_a_new_name (ETA_TYFUN (METATYNAME{1=ref(NULL_TYFUN _), ...})) = 
      true
    | has_a_new_name (ETA_TYFUN (METATYNAME{1=ref tyfun, ...})) =
      has_a_new_name (tyfun)
    | has_a_new_name (TYFUN (CONSTYPE (_,METATYNAME 
				       {1=ref(NULL_TYFUN _), ...}),_)) = true
    | has_a_new_name (TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),_)) =
      has_a_new_name (tyfun)
    | has_a_new_name _ = false
d1318 7
a1324 13
    fun has_a_name (t as ETA_TYFUN (METATYNAME {1=ref(NULL_TYFUN _), ...})) = 
      true
      | has_a_name (t as ETA_TYFUN (METATYNAME {1=ref tyfun, ...})) =
	has_a_name tyfun
      | has_a_name (t as ETA_TYFUN tyname) = true
      | has_a_name (t as TYFUN (CONSTYPE (_,METATYNAME {1=ref tyfun, ...}),_))=
	has_a_name tyfun
      | has_a_name t = false

    fun name (ETA_TYFUN (meta as METATYNAME {1=ref(NULL_TYFUN _),...})) = 
      meta
      | name (ETA_TYFUN (meta as METATYNAME {1=ref tyfun,...})) =
	name (tyfun)
d1326 1
a1326 6
      | name (TYFUN (CONSTYPE (_,meta as METATYNAME
			       {1 = ref(NULL_TYFUN _),...}),_)) = meta
      | name (TYFUN (CONSTYPE (_,meta as METATYNAME {1 = ref tyfun,...}),_)) = 
	name (tyfun)
      | name (TYFUN (CONSTYPE (_,tyname),_)) = tyname
      | name tyfun = Crash.impossible ("Types.name " ^ (string_tyfun tyfun))
d1345 4
a1348 9
    fun tyname_copy (meta as METATYNAME {1=ref (NULL_TYFUN id), ...},
                     tyname_copies,copy_fun) =
      ((NewMap.apply' (tyname_copies,id),tyname_copies)
	 handle NewMap.Undefined => Crash.impossible "STRANGE!!"
	   (*let
	     val meta' = copy_fun meta 
	   in 
	     (meta',NewMap.define (tyname_copies,id,meta'))
	   end*))
d1350 6
a1355 5
      (****
       What follows may seem like a duplication of tyfun_copy but is
       necessary to avoid keeping an association list for type functions
       as for type names.
       ****)
d1357 2
d1362 3
a1364 11
		     tyname_copies,copy_fun) =
	tyname_copy (meta,tyname_copies,copy_fun)
      | tyname_copy (METATYNAME{1 = ref (TYFUN 
	                                 (CONSTYPE (_,meta as METATYNAME 
					            {1 = ref tyfun,...}),
					  _)),...},tyname_copies,copy_fun) =
	tyname_copy (meta,tyname_copies,copy_fun)
      | tyname_copy (tyname as METATYNAME{1=ref tyfun, ...},
	             tyname_copies,_) = (tyname,tyname_copies)
      | tyname_copy (tyname as TYNAME _,tyname_copies,_) = 
        (tyname,tyname_copies)
d1366 1
a1366 1
    fun tyfun_copy (tyfun,tyname_copies,copy_fun) = 
d1368 4
a1371 27
	fun make_copy (ETA_TYFUN (meta as METATYNAME 
	                          {1=ref(NULL_TYFUN _), ...}),
		       tyname_copies,copy_fun) =
          let 
            val (name,tyname_copies') =
	      tyname_copy (meta,tyname_copies,copy_fun)
	    in
	      (ETA_TYFUN (name),tyname_copies')
	    end
	  | make_copy (eta as ETA_TYFUN (METATYNAME{1=r as ref tyfun, ...}),
		       tyname_copies,copy_fun) = 
	    make_copy (tyfun,tyname_copies,copy_fun)
	  | make_copy (TYFUN (CONSTYPE (l,meta as METATYNAME 
		                        {1=ref(NULL_TYFUN _), ...}),arity),
		       tyname_copies,copy_fun) =
	    let 
              val (name,tyname_copies') = tyname_copy (meta,tyname_copies,
		                                       copy_fun)
	    in
	      (TYFUN (CONSTYPE (l,name),arity),tyname_copies')
	    end
	  | make_copy (lambda as TYFUN 
		       (CONSTYPE (_,METATYNAME{1=r as ref tyfun, ...}),_),
		       tyname_copies,copy_fun) =
	    make_copy (tyfun,tyname_copies,copy_fun)
	  | make_copy (_,_,_) = Crash.impossible "Types.make_copy"
	    
d1373 1
a1373 3
	if has_a_new_name (tyfun) then
	  make_copy (tyfun,tyname_copies,copy_fun)
	else (tyfun,tyname_copies)
d1376 13
a1388 79
    fun type_copy (ty as METATYVAR (r as ref (level,atype),_,_),
	           tyname_copies,copy_fun) = 
      (type_copy (atype,tyname_copies,copy_fun) 
        handle Instantiated => (ty,tyname_copies))
      | type_copy (ty as METARECTYPE (r as ref (_,false,atype,_,_)),
	           tyname_copies,copy_fun) = 
	(type_copy (atype,tyname_copies,copy_fun)
	 handle Instantiated => (ty,tyname_copies))
      | type_copy (RECTYPE amap,tyname_copies,copy_fun) =
	let 
	  val (amap',tyname_copies') = Mapping.mapit2 (amap,tyname_copies,
	                                               copy_fun,type_copy)
	    handle Instantiated => (amap,tyname_copies)
	in
	  (RECTYPE amap',tyname_copies')
	end
      | type_copy (FUNTYPE (atype,atype'),tyname_copies,copy_fun) = 
	let
	  val (new_ty,tyname_copies') = 
	    type_copy (atype,tyname_copies,copy_fun)
	    handle Instantiated => (atype,tyname_copies)
	  val (new_ty',tyname_copies'') =
	    type_copy (atype',tyname_copies',copy_fun)
	    handle Instantiated => (atype',tyname_copies')
	in
	  (FUNTYPE (new_ty,new_ty'),tyname_copies'')
	end
      | type_copy (CONSTYPE (l,meta as METATYNAME {1=ref (NULL_TYFUN _),...}),
                   tyname_copies,copy_fun) = 
	let 
	  fun collect ([],tyname_copies,alist) = (alist,tyname_copies)
	    | collect (h::t,tyname_copies,alist) = 
	      let 
                val (copy,tyname_copies') = 
		  type_copy (h,tyname_copies,copy_fun)
		  handle Instantiated => (h,tyname_copies)
	      in
		collect (t,tyname_copies',alist @@ [copy])
	      end
	  val (name,tyname_copies') = tyname_copy (meta,tyname_copies,copy_fun)
	  val (tylist,tyname_copies'') = collect (l,tyname_copies',[])
	in
	  (CONSTYPE (tylist,name),tyname_copies'')
	end
      | type_copy (CONSTYPE (l,name as METATYNAME{1=r as ref tyfun, ...}),
	           tyname_copies,copy_fun) = 
	let 
	  fun collect ([],tyname_copies,alist) = (alist,tyname_copies)
	    | collect (h::t,tyname_copies,alist) = 
	      let
                val (copy,tyname_copies') =
		  type_copy (h,tyname_copies,copy_fun)
		  handle Instantiated => (h,tyname_copies)
	      in
		collect (t,tyname_copies',alist @@ [copy])
	      end
	  val (tylist,tyname_copies') = collect (l,tyname_copies,[])
	  val (name',tyname_copies'') = 
            tyname_copy (name,tyname_copies',copy_fun)
	in 
	  (CONSTYPE (tylist,name'),tyname_copies'')
	end
      | type_copy (CONSTYPE (l,tyname),tyname_copies,copy_fun) = 
	let 
	  fun collect ([],tyname_copies,alist) = (alist,tyname_copies)
	    | collect (h::t,tyname_copies,alist) = 
	      let val (copy,tyname_copies') = 
		type_copy (h,tyname_copies,copy_fun)
		handle Instantiated => (h,tyname_copies)
	      in
		collect (t,tyname_copies',alist @@ [copy])
	      end
	  val (tylist,tyname_copies') = collect (l,tyname_copies,[])
	in
	  (CONSTYPE (tylist,tyname),tyname_copies')
	end
       | type_copy (ty as (TYVAR _),tyname_copies,_) = (ty,tyname_copies)
       | type_copy (ty as (DEBRUIJN _),tyname_copies,_) = (ty,tyname_copies)
       | type_copy (ty,_,_) = raise Instantiated
@


1.31
log
@Simple hack-fix to the print_name failing on most of its possible inputs
@
text
@d4 3
d144 1
d190 2
a191 1
    | tyname_conenv (METATYNAME _) = Crash.impossible"tyname_conenv METATYNAME"
d232 26
a257 254
	
    local
      
      (****
       When applying type functions the argument types must be substituted for
       the debruijns.  Previously debruijns were substituted for type 
       variables when type functions were made.  See the function 
       make_tyfun.
       ****)

      fun app_subst (DEBRUIJN (d,_,_),array_of_types) =
	Array.sub (array_of_types,d)
	| app_subst (RECTYPE (amap),array_of_types) =
	  RECTYPE(Mapping.mapit
		  (amap,
		   fn x => app_subst (x,array_of_types)))
	| app_subst (FUNTYPE (atype,atype'),array_of_types) =
	  FUNTYPE (app_subst (atype,array_of_types),
		   app_subst (atype',array_of_types))
	| app_subst (CONSTYPE (atylist,atyname),array_of_types) =
	  CONSTYPE (map
		    (fn x => app_subst (x,array_of_types))
		    atylist,atyname)
	| app_subst (NULLTYPE,array_of_types) = NULLTYPE 
	  (* for signature matching in funbinds *)
	| app_subst (ty as METATYVAR (ref (_,NULLTYPE),_,_),array_of_types) =
	  ty
	| app_subst (_,array_of_types) = Crash.impossible "Types.app_subst"
	  
    in
      
      fun apply (TYFUN (atype as CONSTYPE (_,METATYNAME 
					   {1=ref(NULL_TYFUN _), ...}),
			arity),tylist) = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("tyfun1 \n");
	       Integer.print (arity);
	       Print.print ("\n"))
       else ();
	  if arity = Lists.length (tylist)
	    then
	      app_subst (atype,Array.arrayoflist (tylist))
	  else 
	    raise Wrong_Arity)
	| apply (TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),arity),
		 tylist) = 
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun2 \n");
		   Integer.print (arity);
		   Print.print ("\n"))
	   else ();
	     apply (tyfun,tylist))
        | apply (TYFUN (atype,arity),tylist) =
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun3 \n");
		   Integer.print (arity);
		   Print.print ("\n"))
	   else ();
	  if arity = Lists.length (tylist)
	    then
	      app_subst (atype,Array.arrayoflist (tylist))
	  else 
	    raise Wrong_Arity)
	| apply (ETA_TYFUN (name as METATYNAME{1=ref(NULL_TYFUN _), ...}),
		 tylist) =
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun4 \n");
		   Print.print ("\n"))
	   else ();
	  CONSTYPE (tylist,name))
	| apply (ETA_TYFUN (METATYNAME{1=ref tyfun, ...}),tylist) =
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun5 \n");
		   Print.print ("\n"))
	   else ();
	  apply (tyfun,tylist))
	| apply (ETA_TYFUN (tyname),tylist) =
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("tyfun6 \n");
		   Print.print ("\n"))
	   else ();
	  CONSTYPE (tylist,tyname))
	| apply (NULL_TYFUN (_),tylist) = raise NullTyfun

    end

    (****
     Used in Realise to determine whether a tyname has been instantiated 
     before meta_tyname (tyfun) is called.
     ****)

    fun null_tyfunp (NULL_TYFUN (_)) = true
      | null_tyfunp (TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),_)) = 
	null_tyfunp (tyfun)
      | null_tyfunp (ETA_TYFUN (METATYNAME{1=ref tyfun, ...})) =
	null_tyfunp tyfun
      | null_tyfunp _ = false

    (****
     imperativep determine the imperative attribute of a type.
     ****)

    fun imperativep (TYVAR (_,Ident.TYVAR (_,_,imp))) = imp
      | imperativep (METATYVAR (ref (_,NULLTYPE),_,imp)) = imp
      | imperativep (METATYVAR (ref (_,t),_,_)) = imperativep t
      | imperativep (META_OVERLOADED _) = true
      | imperativep (METARECTYPE (ref (_,_,t,_,_))) = imperativep t
      | imperativep (CONSTYPE (tylist,METATYNAME{1=ref tyfun, ...})) =
	(imperativep (apply (tyfun,tylist)) handle NullTyfun => true)
      | imperativep (CONSTYPE ([],n)) = true
      | imperativep (CONSTYPE (tylist as h::t,n)) =
	let 
	  fun collect [] = true
	    | collect (h::t) = (imperativep h) andalso (collect t)
	in
	  collect (tylist)
	end
      | imperativep (RECTYPE amap) = Mapping.forall (amap,imperativep)
      | imperativep (FUNTYPE (a,r)) = (imperativep a) andalso (imperativep r)
      | imperativep (DEBRUIJN (_,_,imp)) = imp 
      | imperativep NULLTYPE = true

    fun get_type_from_lab' (lab,RECTYPE amap) = Mapping.lookup (lab,amap)
      | get_type_from_lab' (lab,METARECTYPE (ref(_,_,t,_,_))) =
	get_type_from_lab' (lab,t)
      | get_type_from_lab' (lab,_) = Crash.impossible "Types.get_type_from_lab"

    and get_type_from_lab (lab,atype) = 
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("label lookup \n");
	       Print.print (IdentPrint.printLab lab);
	       Print.print ("\n"))
       else ();
	 get_type_from_lab' (lab,atype))

    fun add_to_rectype (lab,value,RECTYPE(amap)) =
      RECTYPE (Mapping.add((lab,value),amap,Ident.lab_order))
      | add_to_rectype (lab,value,_) = Crash.impossible "Types.add_to_rectype"

    val empty_rec_type = RECTYPE (Mapping.empty_map)
      
    local
	  
      (****
       In making a type function debruijns are used as place holders for type
       variables.
       ****)

      fun make_substlist ([],n,list_acc) = list_acc
	| make_substlist (h::t,n,list_acc) =
	  let val new_debruijn = DEBRUIJN (n,true,true) (* arbitrary choice *)
	  in
	    make_substlist (t,n+1,(h,new_debruijn)::list_acc)
	  end
	
      fun subst (_,[]) = Crash.impossible "Types.subst 1"
	| subst (atyvar as TYVAR (_,Ident.TYVAR (id,eq,imp)),
		 (Ident.TYVAR (id',eq',imp'),adebruijn)::t) =
	  if id = id'
	    then 
	      adebruijn
	  else
	    subst (atyvar,t)
	| subst (_,_) = Crash.impossible "Types.subst 2"
	  
      fun make_new_type (tyvar as TYVAR (_,atyvar),substlist) =
	subst (tyvar,substlist)
	| make_new_type (RECTYPE (amap),substlist) =
	  RECTYPE (Mapping.mapit
		   (amap,
		    fn x => make_new_type (x,substlist)))   
	| make_new_type (FUNTYPE (atype,atype'),substlist) =
	  FUNTYPE (make_new_type (atype,substlist),
		   make_new_type (atype',substlist))
	| make_new_type (CONSTYPE (atylist,atyname),substlist) =
	  CONSTYPE (map
		    (fn x => make_new_type (x,substlist))
		    atylist,atyname)
	| make_new_type (NULLTYPE,substlist) = NULLTYPE 
	| make_new_type (_,substlist) = Crash.impossible "Types.make_new_type"
	  
    in
      
      fun make_tyfun ([],atype) = TYFUN (atype,0)
	| make_tyfun (tyvarlist,atype) =
	  let val substlist = make_substlist (tyvarlist,0,[])
	  in 
	    TYFUN (make_new_type (atype,substlist),Lists.length (tyvarlist))
	  end
    end
  
    (****
     eta-convertible type function
     ****)

    fun make_eta_tyfun (tyname) = ETA_TYFUN (tyname)

    (****
     Follow the pointers to the last uninstantiated METATYNAME.
     ****)
    local
      fun follow_names (TYFUN (CONSTYPE (_,name as METATYNAME 
					 {1=ref(NULL_TYFUN _), ...}),_),_) = 
	name
	| follow_names (TYFUN (CONSTYPE (_,name as METATYNAME 
					 {1=ref tyfun, ...}),_),_) =
	  follow_names (tyfun,name)
	| follow_names (ETA_TYFUN (name as METATYNAME{1=ref(NULL_TYFUN _), ...}
				   ),_) = name
	| follow_names (ETA_TYFUN (name as METATYNAME{1=ref tyfun, ...}),_) = 
	  follow_names (tyfun,name)
	| follow_names (tyfun,name) = name
    in
      fun meta_tyname (ETA_TYFUN (meta as METATYNAME{1=ref tyfun, ...})) = 
	follow_names (tyfun,meta)
      | meta_tyname (TYFUN (CONSTYPE
			    (_,meta as METATYNAME{1=ref tyfun, ...}),_)) = 
	follow_names (tyfun,meta)
      | meta_tyname _ = Crash.impossible "Types.meta_tyname"
    end

    (****
     Determine whether the type function has an uninstantiated type name.
     ****)
    fun has_a_new_name (ETA_TYFUN (METATYNAME{1=ref(NULL_TYFUN _), ...})) = 
      true
    | has_a_new_name (ETA_TYFUN (METATYNAME{1=ref tyfun, ...})) =
      has_a_new_name (tyfun)
    | has_a_new_name (TYFUN (CONSTYPE (_,METATYNAME 
				       {1=ref(NULL_TYFUN _), ...}),_)) = true
    | has_a_new_name (TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),_)) =
      has_a_new_name (tyfun)
    | has_a_new_name _ = false

    (****
     meta_tyname_eq is used in realise maps.
     ****)
    fun meta_tyname_eq (METATYNAME{1=r (*as ref tyfun*), ...},
			METATYNAME{1=r' (*as ref tyfun'*), ...}) = r = r'
    | meta_tyname_eq (_,_) = false
    (* Matching against refs above is irrelevant *)

    (****
     make_false is used in maximising equality - rules 19 and 20.
     ****)
    fun make_false (TYFUN (_)) = Crash.impossible "Types.make_false"
      | make_false (ETA_TYFUN (tyname)) = tyname_make_false tyname
      | make_false (NULL_TYFUN (_)) = false
	
    fun arity (TYFUN (atype,a)) = a
      | arity (ETA_TYFUN (t)) = tyname_arity t 
      | arity (NULL_TYFUN (_)) = 0
	
    fun tyfun_eq (t as TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),_),
d259 9
a267 9
      (if (do_debug andalso Debug.debug_level () > 10) 
	 then (Print.print ("TYFUN (CONSTYPE (METATYNAME... = " ^
                            (string_tyfun t) ^
                            " and tyfun' = " ^ (string_tyfun t') ^ "\n");
	       Print.print ("\n"))
       else ();
	 tyfun_eq (tyfun,tyfun'))
    | tyfun_eq (t as tyfun,
                t' as TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun', ...}),_)) =
a281 15
      | tyfun_eq (t as ETA_TYFUN (METATYNAME{1=ref tyfun, ...}),t' as tyfun') =
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("ETA_TYFUN (METATYNAME... = " ^ (string_tyfun t) ^
                              " and tyfun = " ^ (string_tyfun t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	 tyfun_eq (tyfun,tyfun'))
      | tyfun_eq (t as tyfun,t' as ETA_TYFUN (METATYNAME {1=ref tyfun', ...})) =
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("tyfun = " ^ (string_tyfun t) ^
                              " and ETA_TYFUN (METATYNAME... = " ^ 
                              (string_tyfun t') ^ "\n");
		 Print.print ("\n"))
	 else ();
	tyfun_eq (tyfun,tyfun'))
d289 2
a290 1
      | tyfun_eq (t as TYFUN (CONSTYPE (_,tyname),_),t' as ETA_TYFUN (tyname')) =
d297 2
a298 1
      | tyfun_eq (t as ETA_TYFUN (tyname),t' as TYFUN (CONSTYPE (_,tyname'),_)) =
d327 1
a327 1
      | tyname_eq (t as METATYNAME{1=ref(ETA_TYFUN tyname),...},t' as tyname') = 
d335 2
a336 1
      | tyname_eq (t as tyname,t' as METATYNAME{1=ref(ETA_TYFUN tyname'), ...}) =
d350 1
a350 1
                  " and METATYNAME (ref tyfun'... = " ^ (print_name t') ^ "\n");
d388 3
a390 2
      | type_eq (t as CONSTYPE (_,name as METATYNAME {1=ref (NULL_TYFUN _),...}),
                 t' as CONSTYPE (_,name' as METATYNAME {1=ref (NULL_TYFUN _),...}),
d399 9
a407 1
	tyname_eq (name,name'))
d421 2
a422 1
		 t' as CONSTYPE (_,name' as METATYNAME{1=ref(NULL_TYFUN _), ...}),
d425 1
a425 1
	   then (Print.print ("CONSTYPE (METATYNAME ...,_) = " ^ (print_type t) ^
d453 1
a453 1
			         name' as METATYNAME{1=ref(NULL_TYFUN _), ...}),
d458 1
a458 1
                  " and CONSTYPE (METATYNAME (NULL_TYFUN)) = " ^ (print_type t') 
d474 2
a475 2
	   then (Print.print ("CONSTYPE (METATYNAME ...,_) = " ^ (print_type t) ^
                              " and ty = " ^ (print_type ty) ^ "\n");
d516 1
a516 1
      | type_eq (t as RECTYPE amap,t' as RECTYPE amap',eq_matters,imp_matters) = 
d556 1
a556 1
                  " and META_OVERLOADED (NULLTYPE) = " ^ (print_type ty') ^"\n");
d588 1
a588 1
                              " and METATYVAR (t) = " ^ (print_type ty) ^ "\n");
d626 2
a627 2
	   then (Print.print ("two other types : " ^ (print_type ty) ^ " and " ^
                              (print_type ty') ^ "\n");
a639 12
    and name (ETA_TYFUN (meta as METATYNAME{1=ref(NULL_TYFUN _), ...})) = 
      meta
      | name (ETA_TYFUN (meta as METATYNAME{1=ref tyfun, ...})) =
	name (tyfun)
      | name (ETA_TYFUN tyname) = tyname
      | name (TYFUN (CONSTYPE (_,meta as METATYNAME
			       {1=ref(NULL_TYFUN _), ...}),_)) = meta
      | name (TYFUN (CONSTYPE (_,meta as METATYNAME{1=ref tyfun, ...}),_)) = 
	name (tyfun)
      | name (TYFUN (CONSTYPE (_,tyname),_)) = tyname
      | name tyfun = Crash.impossible ("Types.name " ^ (string_tyfun tyfun))

d642 5
a646 4
      | print_name (METATYNAME(ref(NULL_TYFUN _),name,_,ref eq,_)) = 
	if eq then name ^ "[t]" else name ^ "[f]"
      | print_name (METATYNAME(ref tyfun,name,_,_,_)) = 
        name	(* print_name(name tyfun) *)
d760 5
a764 3
            fun is_a_function_type(Datatypes.FUNTYPE _) = true
              | is_a_function_type(Datatypes.METATYVAR(ref(_,Datatypes.NULLTYPE),_,_)) = false
              | is_a_function_type(Datatypes.METATYVAR(ref(_,ty),_,_)) = is_a_function_type ty
d782 2
a783 1
                    Mapping.domain_member(Ident.LAB(Ident.Symbol.find_symbol(Integer.makestring n)),
d809 1
a809 1
              if n= len
d811 9
a819 3
                  [ref_printer(Mapping.lookup(Ident.LAB(Ident.Symbol.find_symbol(Integer.makestring n)),amap))]
              else (ref_printer(Mapping.lookup(Ident.LAB(Ident.Symbol.find_symbol(Integer.makestring n)),amap)) 
                    :: " * " :: print_as_a_tuple(n+1))
d823 2
a824 2
	       else "(" ^ implode(print_as_a_tuple 1) ^ ")"
             else "{"^ (implode (rec_list(explode comma_rec_string))) ^ "}",
d830 236
d1130 2
a1131 1
		    CONSTYPE (tylist,METATYNAME{1=ref tyfun, 4=ref eq', ...})) =
a1234 3
(*
      | not_occurs _ = Crash.impossible"not_occurs bad parameters"
*)
d1303 14
d1320 1
a1320 1
    fun has_a_name (t as ETA_TYFUN (METATYNAME{1=ref(NULL_TYFUN _), ...})) = 
d1322 1
a1322 1
      | has_a_name (t as ETA_TYFUN (METATYNAME{1=ref tyfun, ...})) =
d1324 2
a1325 3
      | has_a_name (t as ETA_TYFUN tyname) = 
	true
      | has_a_name (t as TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),_)) =
d1329 12
d1358 15
a1372 2
(*    local
      exception NoTynameCopy
d1374 19
a1392 25
      fun find_copy (name,[]) = raise NoTynameCopy
	| find_copy (name,(name',copy)::t) = 
	  if tyname_eq (name,name') 
	    then copy
	  else find_copy (name,t)
    in
      fun tyname_copy (meta as METATYNAME {1=ref (NULL_TYFUN id), ...},
                       tyname_copies,copy_fun) =
	((find_copy (meta,tyname_copies),tyname_copies)
           handle NoTynameCopy => 
             (let 
                val meta' = copy_fun meta 
              in 
                (meta',(meta,meta')::tyname_copies)
               end))

	(****
	 What follows may seem like a duplication of tyfun_copy but is
	 necessary to avoid keeping an association list for type functions
	 as for type names.
	 ****)

	| tyname_copy (METATYNAME{1=ref(ETA_TYFUN 
					(meta as METATYNAME 
					 {1=ref tyfun, ...})), ...},
d1394 2
a1395 17
	  tyname_copy (meta,tyname_copies,copy_fun)
	| tyname_copy (METATYNAME{1=ref(TYFUN 
					(CONSTYPE (_,meta as METATYNAME 
						   {1=ref tyfun, ...}),
					 _)), ...},tyname_copies,copy_fun) = 
	  tyname_copy (meta,tyname_copies,copy_fun)
	| tyname_copy (tyname as METATYNAME{1=ref tyfun, ...},
		       tyname_copies,_) = (tyname,tyname_copies)
	| tyname_copy (tyname as TYNAME _,tyname_copies,_) = 
	  (tyname,tyname_copies)

      fun tyfun_copy (tyfun,tyname_copies,copy_fun) = 
	let
	  fun make_copy (ETA_TYFUN (meta as METATYNAME 
				    {1=ref(NULL_TYFUN _), ...}),
			 tyname_copies,copy_fun) =
	    let val (name,tyname_copies') =
d1400 17
a1416 16
	    | make_copy (eta as ETA_TYFUN (METATYNAME{1=r as ref tyfun, ...}),
			 tyname_copies,copy_fun) = 
	      make_copy (tyfun,tyname_copies,copy_fun)
	    | make_copy (TYFUN (CONSTYPE (l,meta as METATYNAME 
					  {1=ref(NULL_TYFUN _), ...}),arity),
			 tyname_copies,copy_fun) =
	      let val (name,tyname_copies') = tyname_copy (meta,tyname_copies,
							   copy_fun)
	      in
		(TYFUN (CONSTYPE (l,name),arity),tyname_copies')
	      end
	    | make_copy (lambda as TYFUN 
			 (CONSTYPE (_,METATYNAME{1=r as ref tyfun, ...}),_),
			 tyname_copies,copy_fun) =
	      make_copy (tyfun,tyname_copies,copy_fun)
	    | make_copy (_,_,_) = Crash.impossible "Types.make_copy"
d1418 30
d1449 1
a1449 5
	  if has_a_new_name (tyfun) 
	    then
	      make_copy (tyfun,tyname_copies,copy_fun)
	  else
	    (tyfun,tyname_copies)
d1451 7
a1457 36

      fun type_copy (ty as METATYVAR (r as ref (level,atype),_,_),
		     tyname_copies,copy_fun) = 
	(type_copy (atype,tyname_copies,copy_fun) 
	 handle Instantiated => (ty,tyname_copies))
	| type_copy (ty as METARECTYPE (r as ref (_,false,atype,_,_)),
		     tyname_copies,copy_fun) = 
	  (type_copy (atype,tyname_copies,copy_fun)
	   handle Instantiated => (ty,tyname_copies))
	| type_copy (RECTYPE amap,tyname_copies,copy_fun) =
	  let 
	    val (amap',tyname_copies') = Mapping.mapit2 (amap,tyname_copies,
							 copy_fun,type_copy)
	      handle Instantiated => (amap,tyname_copies)
	  in
	    (RECTYPE amap',tyname_copies')
	  end
	| type_copy (FUNTYPE (atype,atype'),tyname_copies,copy_fun) = 
	  let
	    val (new_ty,tyname_copies') = 
	      type_copy (atype,tyname_copies,copy_fun)
	      handle Instantiated => (atype,tyname_copies)
	    val (new_ty',tyname_copies'') =
	      type_copy (atype',tyname_copies',copy_fun)
	      handle Instantiated => (atype',tyname_copies')
	  in
	    (FUNTYPE (new_ty,new_ty'),tyname_copies'')
	  end
	| type_copy (CONSTYPE (l,meta as METATYNAME 
			       {1=ref(NULL_TYFUN _),2=printname,3=arity,4=eq,
				...}),
		     tyname_copies,copy_fun) = 
	  let 
	    fun collect ([],tyname_copies,alist) = (alist,tyname_copies)
	      | collect (h::t,tyname_copies,alist) = 
		let val (copy,tyname_copies') = 
d1460 15
a1474 15
		in
		  collect (t,tyname_copies',alist @@ [copy])
		end
	    val (name,tyname_copies') =
	      tyname_copy (meta,tyname_copies,copy_fun)
	    val (tylist,tyname_copies'') = collect (l,tyname_copies',[])
	  in
	    (CONSTYPE (tylist,name),tyname_copies'')
	  end
	| type_copy (CONSTYPE (l,name as METATYNAME{1=r as ref tyfun, ...}),
		     tyname_copies,copy_fun) = 
	  let 
	    fun collect ([],tyname_copies,alist) = (alist,tyname_copies)
	      | collect (h::t,tyname_copies,alist) = 
		let val (copy,tyname_copies') =
d1477 16
a1492 89
		in
		  collect (t,tyname_copies',alist @@ [copy])
		end
	    val (tylist,tyname_copies') = collect (l,tyname_copies,[])
	    val (name',tyname_copies'') = 
	      tyname_copy (name,tyname_copies',copy_fun)
	  in 
	    (CONSTYPE (tylist,name'),tyname_copies'')
	  end
	| type_copy (CONSTYPE (l,tyname),tyname_copies,copy_fun) = 
	  let 
	    fun collect ([],tyname_copies,alist) = (alist,tyname_copies)
	      | collect (h::t,tyname_copies,alist) = 
		let val (copy,tyname_copies') = 
		  type_copy (h,tyname_copies,copy_fun)
		  handle Instantiated => (h,tyname_copies)
		in
		  collect (t,tyname_copies',alist @@ [copy])
		end
	    val (tylist,tyname_copies') = collect (l,tyname_copies,[])
	  in
	    (CONSTYPE (tylist,tyname),tyname_copies')
	  end
	| type_copy (ty as (TYVAR _),tyname_copies,_) = (ty,tyname_copies)
	| type_copy (ty as (DEBRUIJN _),tyname_copies,_) = (ty,tyname_copies)
	| type_copy (ty,_,_) = raise Instantiated
    end	  
*)
    local
      exception NoTynameCopy

(*
      fun find_copy (id,[]) = raise NoTynameCopy
	| find_copy (id,(id',copy)::t) = 
	  if id = id'
	    then copy
	  else find_copy (id,t)
*)
      fun find_copy (id,map) = (NewMap.apply'(map, id), map)
    in
      fun tyname_copy (meta as METATYNAME {1=ref (NULL_TYFUN id), ...},
                       tyname_copies,copy_fun) =
	((NewMap.apply'(tyname_copies, id),tyname_copies)
	 handle NewMap.Undefined => 
	   let
	     val meta' = copy_fun meta 
	   in 
	     (meta',NewMap.define(tyname_copies, id, meta'))
	   end)

	(****
	 What follows may seem like a duplication of tyfun_copy but is
	 necessary to avoid keeping an association list for type functions
	 as for type names.
	 ****)

	| tyname_copy (METATYNAME {1 = ref (ETA_TYFUN 
					    (meta as METATYNAME 
					     {1 = ref tyfun,...})),...},
		       tyname_copies,copy_fun) =
	  tyname_copy (meta,tyname_copies,copy_fun)
	| tyname_copy (METATYNAME{1 = ref (TYFUN 
					   (CONSTYPE (_,meta as METATYNAME 
						      {1 = ref tyfun,...}),
					    _)),...},tyname_copies,copy_fun) =
	  tyname_copy (meta,tyname_copies,copy_fun)
	| tyname_copy (tyname as METATYNAME{1=ref tyfun, ...},
		       tyname_copies,_) = (tyname,tyname_copies)
	| tyname_copy (tyname as TYNAME _,tyname_copies,_) = 
	  (tyname,tyname_copies)

      fun tyfun_copy (tyfun,tyname_copies,copy_fun) = 
	let
	  fun make_copy (ETA_TYFUN (meta as METATYNAME 
				    {1=ref(NULL_TYFUN _), ...}),
			 tyname_copies,copy_fun) =
	    let val (name,tyname_copies') =
	      tyname_copy (meta,tyname_copies,copy_fun)
	    in
	      (ETA_TYFUN (name),tyname_copies')
	    end
	    | make_copy (eta as ETA_TYFUN (METATYNAME{1=r as ref tyfun, ...}),
			 tyname_copies,copy_fun) = 
	      make_copy (tyfun,tyname_copies,copy_fun)
	    | make_copy (TYFUN (CONSTYPE (l,meta as METATYNAME 
					  {1=ref(NULL_TYFUN _), ...}),arity),
			 tyname_copies,copy_fun) =
	      let val (name,tyname_copies') = tyname_copy (meta,tyname_copies,
							   copy_fun)
d1494 1
a1494 1
		(TYFUN (CONSTYPE (l,name),arity),tyname_copies')
d1496 1
a1496 6
	    | make_copy (lambda as TYFUN 
			 (CONSTYPE (_,METATYNAME{1=r as ref tyfun, ...}),_),
			 tyname_copies,copy_fun) =
	      make_copy (tyfun,tyname_copies,copy_fun)
	    | make_copy (_,_,_) = Crash.impossible "Types.make_copy"
	    
d1498 1
a1498 5
	  if has_a_new_name (tyfun) 
	    then
	      make_copy (tyfun,tyname_copies,copy_fun)
	  else
	    (tyfun,tyname_copies)
d1500 3
a1502 83


      fun type_copy (ty as METATYVAR (r as ref (level,atype),_,_),
		     tyname_copies,copy_fun) = 
	(type_copy (atype,tyname_copies,copy_fun) 
	 handle Instantiated => (ty,tyname_copies))
	| type_copy (ty as METARECTYPE (r as ref (_,false,atype,_,_)),
		     tyname_copies,copy_fun) = 
	  (type_copy (atype,tyname_copies,copy_fun)
	   handle Instantiated => (ty,tyname_copies))
	| type_copy (RECTYPE amap,tyname_copies,copy_fun) =
	  let 
	    val (amap',tyname_copies') = Mapping.mapit2 (amap,tyname_copies,
							 copy_fun,type_copy)
	      handle Instantiated => (amap,tyname_copies)
	  in
	    (RECTYPE amap',tyname_copies')
	  end
	| type_copy (FUNTYPE (atype,atype'),tyname_copies,copy_fun) = 
	  let
	    val (new_ty,tyname_copies') = 
	      type_copy (atype,tyname_copies,copy_fun)
	      handle Instantiated => (atype,tyname_copies)
	    val (new_ty',tyname_copies'') =
	      type_copy (atype',tyname_copies',copy_fun)
	      handle Instantiated => (atype',tyname_copies')
	  in
	    (FUNTYPE (new_ty,new_ty'),tyname_copies'')
	  end
	| type_copy (CONSTYPE (l,meta as METATYNAME 
			       {1=ref(NULL_TYFUN _),2=printname,3=arity,4=eq,
				5=ref valenv}),
		     tyname_copies,copy_fun) = 
	  let 
	    fun collect ([],tyname_copies,alist) = (alist,tyname_copies)
	      | collect (h::t,tyname_copies,alist) = 
		let val (copy,tyname_copies') = 
		  type_copy (h,tyname_copies,copy_fun)
		  handle Instantiated => (h,tyname_copies)
		in
		  collect (t,tyname_copies',alist @@ [copy])
		end
	    val (name,tyname_copies') =
	      tyname_copy (meta,tyname_copies,copy_fun)
	    val (tylist,tyname_copies'') = collect (l,tyname_copies',[])
	  in
	    (CONSTYPE (tylist,name),tyname_copies'')
	  end
 	| type_copy (CONSTYPE (l,name as METATYNAME{1=r as ref tyfun, ...}),
		     tyname_copies,copy_fun) = 
	  let 
	    fun collect ([],tyname_copies,alist) = (alist,tyname_copies)
	      | collect (h::t,tyname_copies,alist) = 
		let val (copy,tyname_copies') =
		  type_copy (h,tyname_copies,copy_fun)
		  handle Instantiated => (h,tyname_copies)
		in
		  collect (t,tyname_copies',alist @@ [copy])
		end
	    val (tylist,tyname_copies') = collect (l,tyname_copies,[])
	    val (name',tyname_copies'') = 
	      tyname_copy (name,tyname_copies',copy_fun)
	  in 
	    (CONSTYPE (tylist,name'),tyname_copies'')
	  end
	| type_copy (CONSTYPE (l,tyname),tyname_copies,copy_fun) = 
	  let 
	    fun collect ([],tyname_copies,alist) = (alist,tyname_copies)
	      | collect (h::t,tyname_copies,alist) = 
		let val (copy,tyname_copies') = 
		  type_copy (h,tyname_copies,copy_fun)
		  handle Instantiated => (h,tyname_copies)
		in
		  collect (t,tyname_copies',alist @@ [copy])
		end
	    val (tylist,tyname_copies') = collect (l,tyname_copies,[])
	  in
	    (CONSTYPE (tylist,tyname),tyname_copies')
	  end
	| type_copy (ty as (TYVAR _),tyname_copies,_) = (ty,tyname_copies)
	| type_copy (ty as (DEBRUIJN _),tyname_copies,_) = (ty,tyname_copies)
	| type_copy (ty,_,_) = raise Instantiated
    end	  
d1505 2
a1506 1
     | tyvars (tyvarlist, METATYVAR (ref (_,atype),_,_)) = tyvars(tyvarlist, atype)
d1508 8
a1515 4
     | tyvars (tyvarlist, METARECTYPE (ref (_,_,atype,_,_))) = tyvars(tyvarlist, atype)
     | tyvars (tyvarlist, RECTYPE amap) = Mapping.fold (fn ty => fn tyvs => tyvars(tyvs, ty)) tyvarlist amap
     | tyvars (tyvarlist, FUNTYPE (atype,atype')) = tyvars(tyvars(tyvarlist, atype), atype')
     | tyvars (tyvarlist, CONSTYPE (tylist,_)) = Lists.reducel tyvars (tyvarlist, tylist)
@


1.30
log
@Changed tyvars function to take a tuple of arguments.
l with Lists.reducel.
@
text
@d4 4
d881 2
a882 2
      | print_name (METATYNAME(ref tyfun,_,_,_,_)) = 
	print_name(name tyfun)
@


1.29
log
@Fixed copy_metatyname and new_metatyname to duplicate the
valenv ref as well as all the other refs
@
text
@d4 4
d1044 3
a1046 5
	    (if is_a_tuple
               then 
                 if len = 0 
                   then "()"
                 else "(" ^ implode(rev(print_as_a_tuple 1)) ^ ")"
d1640 13
a1652 17
   fun tyvars (METATYVAR (ref (_,NULLTYPE),_,_)) tyvarlist = tyvarlist
      | tyvars (METATYVAR (ref (_,atype),_,_)) tyvarlist = 
	tyvars atype tyvarlist
      | tyvars (TYVAR (_,tyvar)) tyvarlist = tyvar :: tyvarlist
      | tyvars (METARECTYPE (ref (_,_,atype,_,_))) tyvarlist =
	tyvars atype tyvarlist
      | tyvars (RECTYPE amap) tyvarlist = Mapping.fold tyvars tyvarlist amap
      | tyvars (FUNTYPE (atype,atype')) tyvarlist = 
	(tyvars atype tyvarlist) @@ (tyvars atype' tyvarlist)
      | tyvars (CONSTYPE (tylist,_)) tyvarlist = 
	Lists.foldl tyvars tyvarlist tylist
      | tyvars ty tyvarlist = tyvarlist

    fun isFunType ty =
      case the_type ty of 
	Datatypes.FUNTYPE _ => true
      | _ => false
d1654 1
a1654 1
    exception ArgRes
d1656 4
a1659 5
    fun argres ty =
      case the_type ty of
	Datatypes.FUNTYPE ar => ar
      | _ => raise ArgRes

@


1.28
log
@Changed the tuple-type printing to use *
@
text
@d4 3
d1310 2
a1311 2
				     arity,ref eq, r)) =
      METATYNAME (ref (NULL_TYFUN id),printname,arity, ref eq, r)
d1315 1
a1315 1
				    arity,ref eq, r)) =
d1317 1
a1317 1
		  arity,ref eq, r)
d1424 1
a1424 1
				5=ref valenv}),
@


1.27
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d1000 11
d1030 6
d1037 6
a1042 1
	    ("{"^ (implode (rec_list(explode comma_rec_string))) ^ "}",
@


1.26
log
@Changed eq_attrib so it follows META chains.
@
text
@d4 3
a95 1
require "../utils/newmap";
a98 1
require "../basics/ident";
d101 1
a102 1
require "../typechecker/datatypes";
a106 1
  structure NewMap : NEWMAP
a115 1
  structure Datatypes : DATATYPES
d118 1
a118 1
  structure Ident : IDENT
d120 1
a122 1
    structure NewMap = NewMap
d850 18
a867 8
    and print_name (TYNAME (_,name,_,ref eq,_)) = (if eq then
						     name ^ "[t]"
						   else
						     name ^ "[f]")
      | print_name (METATYNAME(ref tyfun,name,_,ref eq,_)) = 
	(if (do_debug andalso Debug.debug_level () > 5)
	   then (name ^ " = " ^ "METATYNAME[" ^ (if eq then "t" else "f")^"](" ^ string_tyfun (tyfun) ^ ")")
	 else name)
d1045 2
a1046 7
	let 
	  fun collect [] = true
	    | collect (h::t) = (type_equalityp h) andalso (collect t)
	in
	  tyname_eq(ref_tyname, n) orelse
	  ((eq_attrib n) andalso (collect tylist))
	end
a1272 13

    fun name (ETA_TYFUN (meta as METATYNAME{1=ref(NULL_TYFUN _), ...})) = 
      meta
      | name (ETA_TYFUN (meta as METATYNAME{1=ref tyfun, ...})) =
	name (tyfun)
      | name (ETA_TYFUN tyname) = tyname
      | name (TYFUN (CONSTYPE (_,meta as METATYNAME
			       {1=ref(NULL_TYFUN _), ...}),_)) = meta
      | name (TYFUN (CONSTYPE (_,meta as METATYNAME{1=ref tyfun, ...}),_)) = 
	name (tyfun)
      | name (TYFUN (CONSTYPE (_,tyname),_)) = tyname
      | name (NULL_TYFUN _) = raise NullTyfun
      | name tyfun = Crash.impossible ("Types.name " ^ (string_tyfun tyfun))
@


1.25
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
a137 3
    fun eq_attrib (TYNAME (_,_,_,ref eq,_)) = eq
      | eq_attrib (METATYNAME (_,_,_,ref eq,_)) = eq

d855 1
a855 1
      | print_name (METATYNAME{1=ref tyfun, 2=name, ...}) = 
d857 1
a857 1
	   then (name ^ " = " ^ "METATYNAME (" ^ string_tyfun (tyfun) ^ ")")
d1048 5
a1052 1
    fun equalityp (TYFUN (atype,a)) = type_equalityp atype
@


1.24
log
@Removed use of Array parameter to allow pervasive Array to be used
@
text
@d1 1
d4 3
d133 1
a133 2
      TYNAME (Tyname_id.make_tyname_id (),pname,n,ref eq, 
	      ref (VE (ref 0,Mapping.empty_map)))
@


1.23
log
@Added ml_value_tyname.
@
text
@d3 3
a88 1
require "../utils/array";
a102 1
  structure Array : ARRAY
@


1.22
log
@Fixed the string_types function - if didn't bracket a funtype with a funtype as its first
argument
@
text
@d3 4
d158 1
@


1.21
log
@Changed to use btrees for renaming of tynames and strnames
@
text
@d3 3
a958 7
	| string_types (FUNTYPE (a as (FUNTYPE _),r),depth,stack) =
	  let 
	    val (s,d,m) = string_types (a,depth,stack)
	    val (s',d',m') = string_types (r,d,m)
	  in
	    ("(" ^ s ^ ")" ^ " -> " ^ s',d',m')
	  end
d963 5
d969 4
a972 1
	    (s ^ " -> " ^ s',d',m')
@


1.20
log
@Anel's changes for improved structure copying
@
text
@d3 3
d76 1
d90 1
d108 1
d1443 2
a1444 1
      fun find_copy (_,[]) = raise NoTynameCopy
d1449 2
d1454 7
a1460 7
	((find_copy (id,tyname_copies),tyname_copies)
           handle NoTynameCopy => 
             (let 
                val meta' = copy_fun meta 
              in 
                (meta',(id,meta')::tyname_copies)
               end))
@


1.19
log
@Modifications to sort out unification of flexible record types in order
to provide full information to the lambda translation
@
text
@d3 4
d1277 1
a1277 1
    local
d1433 3
d1437 156
a1592 1
    fun tyvars (METATYVAR (ref (_,NULLTYPE),_,_)) tyvarlist = tyvarlist
@


1.18
log
@Fixed problem in not_occurs with missing case for explicit tyvars
@
text
@d177 2
a178 2
     the_type determine the type that a flexible type has been instantiated to;
     or if it is uninstantiated the flexible type itself.
d185 2
d188 1
a188 1
      | the_type (METARECTYPE (ref (_,false,atype,_,_))) = the_type atype
d749 2
a750 2
      | type_eq (ty as METARECTYPE (t as ref (_,true,_,_,_)), 
		 ty' as METARECTYPE (t' as ref (_,true,_,_,_)),_,_) = 
d754 9
d766 1
a766 1
	(t = t'))
d935 2
d1113 1
a1113 1
      | not_occurs (_, TYVAR _) = true
a1155 2
	(not (type_eq (ameta,t,true,true)))
	andalso
d1211 2
@


1.17
log
@Anel's fixes
@
text
@d3 3
d1100 1
a1100 1
		
d1148 1
d1150 1
@


1.16
log
@Fixed bug in type matching shown up my _miropttypes
@
text
@d3 3
a1255 2
      (* This exception should never be raised, thus it's not *)
      (* handled anywhere *)
a1257 4
      fun member (name,[]) = false 
	| member (name,(name',_)::t) =
	  (tyname_eq (name,name')) orelse member (name,t) 
	  
d1264 10
a1273 12
      fun tyname_copy (meta as METATYNAME{1=ref(NULL_TYFUN id), 2=printname,
					   3=arity,4=ref eq, ...},tyname_copies,
		       copy_fun) =
	if member (meta,tyname_copies) 
	  then 
	     (find_copy (meta,tyname_copies),tyname_copies)
	 else
	   let val meta' = copy_fun meta
	   in
	      (meta',(meta,meta')::tyname_copies)
	   end
	   
a1293 4
(*
	| tyname_copy (tyname,_,_) = 
	  Crash.impossible ("Types.tyname_copy (tyname = "
			    ^ (print_name tyname) ^ ")")
a1294 1
*)
@


1.15
log
@Added new function tyvar_equalityp for where the equality attribute is
significant. The previous function type_equalityp now ignores the
equality attribute of type variables
@
text
@d3 5
d436 2
a437 1
    fun tyfun_eq (TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun, ...}),_),tyfun') =
d439 3
a441 1
	 then (Print.print ("TYFUN (CONSTYPE (METATYNAME... and tyfun \n");
d445 2
a446 1
    | tyfun_eq (tyfun,TYFUN (CONSTYPE (_,METATYNAME{1=ref tyfun', ...}),_)) =
d448 3
a450 1
	   then (Print.print ("tyfun and TYFUN (CONSTYPE (METATYNAME... \n");
d454 1
a454 1
      | tyfun_eq (TYFUN (atype,a),TYFUN (atype',a')) =
d456 2
a457 1
	   then (Print.print ("TYFUN and TYFUN \n");
d461 1
a461 1
      | tyfun_eq (ETA_TYFUN (METATYNAME{1=ref tyfun, ...}),tyfun') =
d463 2
a464 1
	   then (Print.print ("ETA_TYFUN (METATYNAME... and tyfun \n");
d468 1
a468 1
      | tyfun_eq (tyfun,ETA_TYFUN (METATYNAME{1=ref tyfun', ...})) =
d470 3
a472 1
	   then (Print.print ("tyfun and ETA_TYFUN (METATYNAME... \n");
d476 1
a476 1
      | tyfun_eq (ETA_TYFUN (tyname),ETA_TYFUN (tyname')) = 
d478 2
a479 1
	   then (Print.print ("ETA_TYFUN and ETA_TYFUN \n");
d483 1
a483 1
      | tyfun_eq (TYFUN (CONSTYPE (_,tyname),_),ETA_TYFUN (tyname')) = 
d485 2
a486 1
	   then (Print.print ("TYFUN and ETA_TYFUN \n");
d490 1
a490 1
      | tyfun_eq (ETA_TYFUN (tyname),TYFUN (CONSTYPE (_,tyname'),_)) = 
d492 2
a493 1
	   then (Print.print ("ETA_TYFUN and ETA_TYFUN \n");
d497 1
a497 1
      | tyfun_eq (NULL_TYFUN (id),NULL_TYFUN (id')) =
d499 2
a500 1
	   then (Print.print ("NULL_TYFUN and NULL_TYFUN \n");
d506 2
a507 1
	   then (Print.print ("two other tyfuns \n");
d512 1
a512 1
    and tyname_eq (TYNAME (id,_,_,_,_),TYNAME (id',_,_,_,_)) =
d514 2
a515 1
	   then (Print.print("TYNAME and TYNAME \n");
d519 1
a519 1
      | tyname_eq (METATYNAME{1=ref(ETA_TYFUN tyname),...},tyname') = 
d522 2
a523 1
		 ("METATYNAME (ref ETA_TYFUN tyname ... and tyname' \n");
d527 1
a527 1
      | tyname_eq (tyname,METATYNAME{1=ref(ETA_TYFUN tyname'), ...}) =
d530 3
a532 1
		 ("tyname and METATYNAME (ref (ETA_TYFUN tyname' ...\n");
d536 2
a537 2
      | tyname_eq (METATYNAME{1=ref tyfun, 3=arity, 4=eq, ...},
		   METATYNAME{1=ref tyfun', 3=arity', 4=eq', ...}) = 
d540 2
a541 1
		 ("METATYNAME (ref tyfun... and METATYNAME (ref tyfun'... \n");
d548 1
a548 1
      | tyname_eq (_,_) = 
d550 2
a551 1
	   then (Print.print ("tyname_eq (_,_)...");
d556 2
a557 2
    and type_eq (TYVAR (_,Ident.TYVAR (sym,eq,imp)),
		 TYVAR (_,Ident.TYVAR (sym',eq',imp')),
d560 2
a561 1
	 then (Print.print ("type_eq (TYVAR,TYVAR)...");
d569 2
a570 1
      | type_eq (FUNTYPE(ty1,ty2),FUNTYPE(ty1',ty2'),eq_matters,imp_matters) = 
d572 2
a573 1
	   then (Print.print ("type_eq (FUNTYPE,FUNTYPE)...");
d579 2
a580 3
      | type_eq (CONSTYPE (tylist,name as METATYNAME 
			   {1=ref(NULL_TYFUN _), ...}),
		 CONSTYPE (tylist',name'),
d583 35
d619 2
a620 1
		 ("type_eq (CONSTYPE (METATYNAME (NULL_TYFUN),_),CONSTYPE (name'))");
d632 3
a634 3
      | type_eq (CONSTYPE (tylist,name),
		 CONSTYPE (tylist',
			   name' as METATYNAME{1=ref(NULL_TYFUN _), ...}),
d638 3
a640 1
		 ("type_eq (CONSTYPE (name),CONSTYPE (METATYNAME (NULL_TYFUN)))");
d652 1
a652 1
      | type_eq (CONSTYPE (l,METATYNAME{1=ref tyfun, ...}),ty,
d655 2
a656 1
	   then (Print.print ("type_eq (CONSTYPE (METATYNAME ...,_),ty)");
d661 1
a661 1
      | type_eq (ty,CONSTYPE (l,METATYNAME{1=ref tyfun, ...}),
d664 3
a666 1
	   then (Print.print ("type_eq (ty,CONSTYPE (METATYNAME ...,_))");
d671 1
a671 1
      | type_eq (CONSTYPE ([],tyname),CONSTYPE ([],tyname'),_,_) =
d673 3
a675 1
	   then (Print.print ("type_eq (CONSTYPE ([],_),CONSTYPE ([],_))...");
d679 2
a680 2
      | type_eq (CONSTYPE (tylist as h::t,tyname),
		 CONSTYPE (tylist' as h'::t',tyname'),
d684 2
a685 1
		 ("type_eq (CONSTYPE (h::t,_),CONSTYPE (h::t,_))...");
d697 1
a697 1
      | type_eq (RECTYPE amap,RECTYPE amap',eq_matters,imp_matters) = 
d699 2
a700 1
	   then (Print.print ("type_eq (RECTYPE,RECTYPE)...");
d705 1
a705 1
      | type_eq (DEBRUIJN (d,eq,imp),DEBRUIJN (d',eq',imp'),
d708 2
a709 1
	   then (Print.print ("type_eq (DEBRUIJN,DEBRUIJN)...");
d719 1
a719 1
	   then (Print.print ("type_eq (NULLTYPE,NULLTYPE)...");
d723 2
a724 2
      | type_eq (METATYVAR (t as ref (_,NULLTYPE),_,_),
		 METATYVAR (t' as ref (_,NULLTYPE),_,_),_,_) = 
d727 2
a728 1
		 ("type_eq (METATYVAR (NULLTYPE),METATYVAR (NULLTYPE))...");
d732 2
a733 2
      | type_eq (META_OVERLOADED (t as ref  NULLTYPE), 
		 META_OVERLOADED (t' as ref  NULLTYPE),_,_) = 
d736 2
a737 1
		 ("type_eq (META_OVERLOADED (NULLTYPE),META_OVERLOADED (NULLTYPE))...");
d741 2
a742 2
      | type_eq (METARECTYPE (t as ref (_,true,_,_,_)), 
		 METARECTYPE (t' as ref (_,true,_,_,_)),_,_) = 
d745 2
a746 1
		 ("type_eq (METARECTYPE (true),METARECTYPE (true))");
d750 1
a750 1
      | type_eq (METATYVAR (ref(_,t),_,_),t',eq_matters,imp_matters) = 
d752 2
a753 1
	   then (Print.print ("type_eq (METATYVAR (t),t')");
d757 1
a757 1
      | type_eq (t',METATYVAR (ref(_,t),_,_),eq_matters,imp_matters) = 
d759 2
a760 1
	   then (Print.print ("type_eq (t',METATYVAR (t))");
d764 1
a764 1
      | type_eq (META_OVERLOADED (ref t),t',eq_matters,imp_matters) = 
d766 2
a767 1
	   then (Print.print ("type_eq (META_OVERLOADED (t),t')");
d771 1
a771 1
      | type_eq (t',META_OVERLOADED (ref t),eq_matters,imp_matters) = 
d773 3
a775 1
	   then (Print.print ("type_eq (t',META_OVERLOADED (t))");
d779 2
a780 1
      | type_eq (METARECTYPE (ref (_,false,t,_,_)),t',eq_matters,imp_matters) =
d782 2
a783 1
	   then (Print.print ("type_eq (METARECTYPE (false),t')");
d787 2
a788 1
      | type_eq (t',METARECTYPE (ref (_,false,t,_,_)),eq_matters,imp_matters) =
d790 3
a792 1
	   then (Print.print ("type_eq (t',METARECTYPE (false))");
d796 1
a796 1
      | type_eq (_,_,_,_) = 
d798 2
a799 1
	   then (Print.print ("type_eq (_,_)");
d804 1
a804 170
    (****
     type_equalityp determines the equality attribute of a type.
     ****)

    fun type_equalityp (TYVAR (_,Ident.TYVAR (_,eq,_))) = eq
      | type_equalityp (METATYVAR (ref (_,NULLTYPE),eq,_)) = eq
      | type_equalityp (METATYVAR (ref (_,t),eq,_)) = type_equalityp t
      | type_equalityp (META_OVERLOADED _) = true
      | type_equalityp (METARECTYPE (ref (_,_,t,_,_))) = type_equalityp t
      | type_equalityp (CONSTYPE ([],n)) = eq_attrib n
      | type_equalityp (CONSTYPE (tylist as h::t,n)) =
	let 
	  fun collect [] = true
	    | collect (h::t) = (type_equalityp h) andalso (collect t)
	in
	  tyname_eq(ref_tyname, n) orelse
	  ((eq_attrib n) andalso (collect tylist))
	end
      | type_equalityp (RECTYPE amap) = Mapping.forall (amap,type_equalityp)
      | type_equalityp (FUNTYPE(a,r)) = false
      | type_equalityp (DEBRUIJN (_,eq,_)) = true
      | type_equalityp NULLTYPE = true
  
    fun equalityp (TYFUN (atype,a)) = type_equalityp atype
      | equalityp (ETA_TYFUN (tyname)) = eq_attrib tyname
      | equalityp (NULL_TYFUN (_)) = false
	
    fun num_typep (CONSTYPE ([],name)) =
      (tyname_eq (name,int_tyname)
       orelse 
       tyname_eq (name,real_tyname))
      | num_typep _ = false

    (****
     eq_and_imp does the manipulation of the equality and imperative attributes
     during unification.
     ****)

    fun eq_and_imp (eq,imp,(TYVAR (_,Ident.TYVAR (_,eq',imp')))) = 
      if eq 
	then (eq' andalso (if imp
			     then imp' 
			   else true))
      else (if imp
	      then imp'
	    else true)
      | eq_and_imp (eq,imp,FUNTYPE (a,r)) =
	if eq 
	  then false 
	else (eq_and_imp (eq,imp,a)) andalso (eq_and_imp (eq,imp,r))
      | eq_and_imp (eq,imp,DEBRUIJN (_,eq',imp')) =
	if eq 
	  then (eq' andalso (if imp
			       then imp' 
			     else true))
	else (if imp
		then imp'
	      else true)
      | eq_and_imp (eq,imp,
		    CONSTYPE (tylist,METATYNAME{1=ref tyfun, 4=ref eq', ...})) =
	(eq_and_imp (eq,imp,apply (tyfun,tylist))
	 handle NullTyfun => ((not eq) orelse eq'))
      | eq_and_imp (eq,imp,CONSTYPE ([],name)) =
	if eq 
	  then eq_attrib name
	else true
      | eq_and_imp (eq,imp,CONSTYPE ([h],name)) =
	if eq 
	  then if tyname_eq (name,ref_tyname)
		 then eq_and_imp (false,imp,h)
	       else (eq_attrib name
		     andalso
		     eq_and_imp (eq,imp,h))
	else eq_and_imp (eq,imp,h)
      | eq_and_imp (eq,imp,CONSTYPE (t,n)) = 
	let fun collect [] = true
	      | collect (h::t) = eq_and_imp (eq,imp,h) andalso (collect t)
	in
	  ((not eq) orelse (eq_attrib n)) andalso (collect(t))
	end
      | eq_and_imp (eq,imp,RECTYPE amap) = 
	Mapping.forall (amap,fn x => eq_and_imp (eq,imp,x)) 
      | eq_and_imp (eq,imp,NULLTYPE) = true
      | eq_and_imp (eq,imp,METATYVAR (x as ref (n,NULLTYPE),eq',imp')) =
	if (eq andalso not eq') orelse (imp andalso not imp')
	  then (x := (n,
		      METATYVAR (ref (n,NULLTYPE),
				 eq orelse eq',imp orelse imp'));
		true)
	else true
      | eq_and_imp (eq,imp,METATYVAR (ref (_,t),eq',imp')) =
	if (eq andalso not eq') orelse (imp andalso not imp')
	  then (eq_and_imp (eq,imp,t))
	else true
      | eq_and_imp (eq,imp,META_OVERLOADED _) = true
      | eq_and_imp (eq,imp,METARECTYPE (r as ref (n,true,t,eq',imp'))) =
	if (eq andalso not eq') orelse (imp andalso not imp')
	  then (r := (n,true,t,eq orelse eq',imp orelse imp');
		true)
	else true
      | eq_and_imp (eq,imp,METARECTYPE (r as ref (n,false,t,eq',imp'))) =
	if (eq andalso not eq') orelse (imp andalso not imp')
	  then (eq_and_imp (eq,imp,t))
	else true
      
    (****
     Occurs check in unification.
     ****)



    (* was - not_occurs (ameta,TYVAR _) = true  - changed 28/5/91 *)

    fun not_occurs (METATYVAR (ref (n,_),_,_),
		    TYVAR (r' as ref n',_)) =
	(n > n')
	orelse
	(r' := n;
	 true)
		
      | not_occurs (ameta,FUNTYPE(a,r)) = 
	not_occurs (ameta,a) andalso not_occurs (ameta,r)
      | not_occurs (ameta,t as DEBRUIJN _) = true
      | not_occurs (ameta,CONSTYPE (tylist,METATYNAME{1=ref tyfun, ...})) = 
	not_occurs (ameta, 
		    apply (tyfun,tylist) handle NullTyfun => NULLTYPE)
      | not_occurs (ameta,CONSTYPE(t,n)) = 
	let fun collect [] = true
	      | collect (h::t) = not_occurs (ameta,h) andalso (collect t)
	in
	  collect t
	end
      | not_occurs (ameta,RECTYPE amap)	= 
	Mapping.forall (amap,fn x => not_occurs (ameta,x)) 
      | not_occurs (ameta,NULLTYPE) = true
      | not_occurs (ameta as METATYVAR (ref (n,NULLTYPE),_,_),
		    ameta' as METATYVAR (x as ref (n',NULLTYPE),_,_)) = 
	if (type_eq (ameta,ameta',true,true))
	  then false
	else
	  (n > n') 
	  orelse
	  (x := (n,NULLTYPE);
	   true)
      | not_occurs (METATYVAR (ref (n,_),_,_),
		    METATYVAR (x as ref (n',NULLTYPE),_,_)) = 
	(n > n') 
	orelse
	(x := (n,NULLTYPE);
	 true)
      | not_occurs (ameta,t as METATYVAR (ref (_,NULLTYPE),eq',imp')) =
	not (type_eq (ameta,t,true,true))
      | not_occurs (ameta as METATYVAR (ref (n,_),_,_),
		    METATYVAR (x as ref (n',t),_,_)) = 
	((n > n') 
	 orelse
	 (x := (n,t);
	  not_occurs (ameta,t)))
      | not_occurs (ameta,METATYVAR (ref (_,t),_,_)) = not_occurs (ameta,t)
      | not_occurs (ameta,t as META_OVERLOADED (ref NULLTYPE)) = true
      | not_occurs (ameta,META_OVERLOADED (ref t)) = true
      | not_occurs (ameta,t as METARECTYPE (ref (_,true,arec,_,_))) = 
	(not (type_eq (ameta,t,true,true)))
	andalso
	not_occurs (ameta,arec)
      | not_occurs (ameta,METARECTYPE (ref (_,false,t,_,_))) = 
	not_occurs (ameta,t)
      | not_occurs _ = Crash.impossible"not_occurs bad parameters"

    fun string_tyfun (TYFUN (aty,n)) = 
d971 6
d982 161
@


1.14
log
@New pervasive library code - cut some things out of the initial type basis
@
text
@d3 3
d104 1
a104 1
    | eq_attrib (METATYNAME (_,_,_,ref eq,_)) = eq
d107 2
a108 1
    | get_tyname_id (METATYNAME _) = Crash.impossible"get_tyname_id METATYNAME"
d111 1
a111 1
    | tyname_arity (METATYNAME (_,_,n,_,_)) = n
d118 1
a118 1
    | tyname_make_false (METATYNAME (_,_,_,r,_)) = (r := false; false)
d735 3
a737 3
      | type_equalityp (FUNTYPE(a,r)) = false 
      | type_equalityp (DEBRUIJN (_,eq,_)) = eq		      
      | type_equalityp NULLTYPE = true 
d754 1
a754 1
    fun eq_and_imp (eq,imp,(TYVAR (_,Ident.TYVAR (_,eq',imp')))) =
d1051 6
@


1.13
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d3 4
a125 3
    val instream_tyname = make_tyname (0,false,"instream")	  
    val outstream_tyname = make_tyname (0,false,"outstream")
    val array_tyname = make_tyname (1,true,"array")
@


1.12
log
@Updated to allow valenv in METATYNAME
@
text
@d3 3
d48 1
a48 2
require "../typechecker/types";
require "../typechecker/datatypes";
d50 1
d55 6
d62 18
a79 9
functor Types (structure Datatypes : DATATYPES
	       structure Lists : LISTS
	       structure Integer : INTEGER
	       structure Print : PRINT
	       structure Array : ARRAY
	       structure Crash : CRASH
	       structure Debug : sig val set_debug_level : int -> unit
				     val debug_level : unit -> int
				 end) : TYPES =
d83 1
d113 1
d207 1
a207 1
      (if (Debug.debug_level () > 10) 
d219 1
a219 1
	  (if (Debug.debug_level () > 10) 
d226 1
a226 1
	  (if (Debug.debug_level () > 10) 
d238 1
a238 1
	  (if (Debug.debug_level () > 10) 
d244 1
a244 1
	  (if (Debug.debug_level () > 10) 
d250 1
a250 1
	  (if (Debug.debug_level () > 10) 
d301 1
a301 1
      (if (Debug.debug_level () > 10) 
d410 2
a411 2
    fun meta_tyname_eq (METATYNAME{1=r as ref tyfun, ...},
			METATYNAME{1=r' as ref tyfun', ...}) = r = r'
d413 2
a414 1
      
d427 1
a427 1
      (if (Debug.debug_level () > 10) 
d433 1
a433 1
	(if (Debug.debug_level () > 10)
d439 1
a439 1
	(if (Debug.debug_level () > 10) 
d445 1
a445 1
	(if (Debug.debug_level () > 10) 
d451 1
a451 1
	(if (Debug.debug_level () > 10) 
d457 1
a457 1
	(if (Debug.debug_level () > 10) 
d463 1
a463 1
	(if (Debug.debug_level () > 10) 
d469 1
a469 1
	(if (Debug.debug_level () > 10) 
d475 1
a475 1
	(if (Debug.debug_level () > 10) 
d481 1
a481 1
	(if (Debug.debug_level () > 10) 
d488 1
a488 1
	(if (Debug.debug_level () > 10) 
d494 1
a494 1
	(if (Debug.debug_level () > 10) 
d501 1
a501 1
	(if (Debug.debug_level () > 10) 
d509 1
a509 1
	(if (Debug.debug_level () > 10) 
d519 1
a519 1
	(if (Debug.debug_level () > 10)
d528 1
a528 1
      (if (Debug.debug_level () > 10)
d538 1
a538 1
	(if (Debug.debug_level () > 10)
d549 1
a549 1
	(if (Debug.debug_level () > 10)
d567 1
a567 1
	(if (Debug.debug_level () > 10)
d583 1
a583 1
	(if (Debug.debug_level () > 10)
d591 1
a591 1
	(if (Debug.debug_level () > 10)
d598 1
a598 1
	(if (Debug.debug_level () > 10)
d606 1
a606 1
	(if (Debug.debug_level () > 10)
d621 1
a621 1
	(if (Debug.debug_level () > 10)
d629 1
a629 1
	(if (Debug.debug_level () > 10)
d639 1
a639 1
	(if (Debug.debug_level () > 10)
d646 1
a646 1
	(if (Debug.debug_level () > 10)
d654 1
a654 1
	(if (Debug.debug_level () > 10)
d662 1
a662 1
	(if (Debug.debug_level () > 10)
d669 1
a669 1
	(if (Debug.debug_level () > 10)
d675 1
a675 1
	(if (Debug.debug_level () > 10)
d681 1
a681 1
	(if (Debug.debug_level () > 10)
d687 1
a687 1
	(if (Debug.debug_level () > 10)
d693 1
a693 1
	(if (Debug.debug_level () > 10)
d699 1
a699 1
	(if (Debug.debug_level () > 10)
d705 1
a705 1
	(if (Debug.debug_level () > 10)
d893 1
a893 1
	(if (Debug.debug_level () > 5)
d1049 1
a1049 1
      (if (Debug.debug_level () > 5)
d1061 1
a1061 1
	(if (Debug.debug_level () > 5)
d1069 1
a1069 1
	(if (Debug.debug_level () > 5)
d1081 1
a1081 1
	(if (Debug.debug_level () > 5)
@


1.11
log
@Added value giving tyfun_id_counter at end of defining pervasives
@
text
@d3 3
d78 1
a78 1
      | eq_attrib (METATYNAME (_,_,_,ref eq)) = eq
d84 1
a84 1
      | tyname_arity (METATYNAME (_,_,n,_)) = n
d90 2
a91 4
    fun tyname_make_false (TYNAME (_,_,_,r,_)) = (r := false;
						  false)
      | tyname_make_false (METATYNAME (_,_,_,r)) = (r := false;
						    false)
d185 1
a185 1
					   (ref (NULL_TYFUN _),_,_,_)),
d197 1
a197 2
	| apply (TYFUN (CONSTYPE (_,METATYNAME (ref
						tyfun,_,_,_)),arity),
d216 1
a216 1
	| apply (ETA_TYFUN (name as METATYNAME (ref (NULL_TYFUN _),_,_,_)),
d223 1
a223 1
	| apply (ETA_TYFUN (METATYNAME (ref tyfun,_,_,_)),tylist) =
d245 1
a245 1
      | null_tyfunp (TYFUN (CONSTYPE (_,METATYNAME (ref tyfun,_,_,_)),_)) = 
d247 1
a247 1
      | null_tyfunp (ETA_TYFUN (METATYNAME (ref tyfun,_,_,_))) =
d260 1
a260 1
      | imperativep (CONSTYPE (tylist,METATYNAME (ref tyfun,_,_,_))) =
d355 1
a355 1
					 (ref (NULL_TYFUN _),_,_,_)),_),_) = 
d358 1
a358 1
					 (ref tyfun,_,_,_)),_),_) =
d360 3
a362 3
	| follow_names (ETA_TYFUN (name as METATYNAME (ref (NULL_TYFUN _),
						       _,_,_)),_) = name
	| follow_names (ETA_TYFUN (name as METATYNAME (ref tyfun,_,_,_)),_) = 
d366 1
a366 1
      fun meta_tyname (ETA_TYFUN (meta as METATYNAME (ref tyfun,_,_,_))) = 
d368 4
a371 4
	| meta_tyname (TYFUN (CONSTYPE 
			      (_,meta as METATYNAME (ref tyfun,_,_,_)),_)) = 
	  follow_names (tyfun,meta)
	| meta_tyname _ = Crash.impossible "Types.meta_tyname"
d377 1
a377 1
    fun has_a_new_name (ETA_TYFUN (METATYNAME (ref (NULL_TYFUN _),_,_,_))) = 
d379 7
a385 7
      | has_a_new_name (ETA_TYFUN (METATYNAME (ref tyfun,_,_,_))) = 
	has_a_new_name (tyfun)
      | has_a_new_name (TYFUN (CONSTYPE (_,METATYNAME 
					 (ref (NULL_TYFUN _),_,_,_)),_)) = true
      | has_a_new_name (TYFUN (CONSTYPE (_,METATYNAME (ref tyfun,_,_,_)),_)) =
	has_a_new_name (tyfun)
      | has_a_new_name _ = false
d390 3
a392 3
    fun meta_tyname_eq (METATYNAME (r as ref tyfun,_,_,_),
			METATYNAME (r' as ref tyfun',_,_,_)) = r = r'
      | meta_tyname_eq (_,_) = false
d405 1
a405 1
    fun tyfun_eq (TYFUN (CONSTYPE (_,METATYNAME (ref tyfun,_,_,_)),_),tyfun') =
d411 2
a412 2
      | tyfun_eq (tyfun,TYFUN (CONSTYPE (_,METATYNAME (ref tyfun',_,_,_)),_)) =
	(if (Debug.debug_level () > 10) 
d423 1
a423 1
      | tyfun_eq (ETA_TYFUN (METATYNAME (ref tyfun,_,_,_)),tyfun') =
d429 1
a429 1
      | tyfun_eq (tyfun,ETA_TYFUN (METATYNAME (ref tyfun',_,_,_))) =
d472 1
a472 1
      | tyname_eq (METATYNAME (ref (ETA_TYFUN tyname),_,_,_),tyname') = 
d479 1
a479 1
      | tyname_eq (tyname,METATYNAME (ref (ETA_TYFUN tyname'),_,_,_)) =
d486 2
a487 2
      | tyname_eq (METATYNAME (ref tyfun,_,arity,eq),
		   METATYNAME (ref tyfun',_,arity',eq')) = 
d525 1
a525 1
			   (ref (NULL_TYFUN _),_,_,_)),
d544 1
a544 1
			   name' as METATYNAME (ref (NULL_TYFUN _),_,_,_)),
d560 1
a560 1
      | type_eq (CONSTYPE (l,METATYNAME (ref tyfun,_,_,_)),ty,
d568 1
a568 1
      | type_eq (ty,CONSTYPE (l,METATYNAME (ref tyfun,_,_,_)),
d749 1
a749 1
		    CONSTYPE (tylist,METATYNAME (ref tyfun,_,_,ref eq'))) =
d813 1
a813 1
      | not_occurs (ameta,CONSTYPE (tylist,METATYNAME (ref tyfun,_,_,_))) = 
d871 1
a871 1
      | print_name (METATYNAME (ref tyfun,name,_,_)) = 
d1094 1
a1094 1
    fun has_a_name (t as ETA_TYFUN (METATYNAME (ref (NULL_TYFUN _),_,_,_))) = 
d1096 1
a1096 1
      | has_a_name (t as ETA_TYFUN (METATYNAME (ref tyfun,_,_,_))) = 
d1100 1
a1100 1
      | has_a_name (t as TYFUN (CONSTYPE (_,METATYNAME (ref tyfun,_,_,_)),_)) =
d1104 1
a1104 1
    fun name (ETA_TYFUN (meta as METATYNAME (ref (NULL_TYFUN _),_,_,_))) = 
d1106 1
a1106 1
      | name (ETA_TYFUN (meta as METATYNAME (ref tyfun,_,_,_))) =
d1109 3
a1111 3
      | name (TYFUN (CONSTYPE (_,meta as METATYNAME 
			       (ref (NULL_TYFUN _),_,_,_)),_)) = meta
      | name (TYFUN (CONSTYPE (_,meta as METATYNAME (ref tyfun,_,_,_)),_)) = 
d1123 3
a1125 3
    fun copy_metatyname (METATYNAME (ref (NULL_TYFUN id),printname,
				     arity,ref eq)) = 
      METATYNAME (ref (NULL_TYFUN id),printname,arity, ref eq)
d1129 1
a1129 1
				    arity,ref eq)) =
d1131 1
a1131 1
		  arity,ref eq)
d1149 2
a1150 2
      fun tyname_copy (meta as METATYNAME (ref (NULL_TYFUN id),printname,
					   arity,ref eq),tyname_copies,
d1167 1
a1167 1
	| tyname_copy (METATYNAME (ref (ETA_TYFUN 
d1169 1
a1169 1
					 (ref tyfun,_,_,_))),_,_,_),
d1172 1
a1172 1
	| tyname_copy (METATYNAME (ref (TYFUN 
d1174 2
a1175 2
						   (ref tyfun,_,_,_)),
					 _)),_,_,_),tyname_copies,copy_fun) = 
d1177 1
a1177 1
	| tyname_copy (tyname as METATYNAME (ref tyfun,_,_,_),
d1190 1
a1190 1
				    (ref (NULL_TYFUN _),_,_,_)),
d1197 1
a1197 1
	    | make_copy (eta as ETA_TYFUN (METATYNAME (r as ref tyfun,_,_,_)),
d1201 1
a1201 1
					  (ref (NULL_TYFUN _),_,_,_)),arity),
d1209 1
a1209 1
			 (CONSTYPE (_,METATYNAME (r as ref tyfun,_,_,_)),_),
d1250 2
a1251 1
			       (ref (NULL_TYFUN _),printname,arity,eq)),
d1268 1
a1268 1
	| type_copy (CONSTYPE (l,name as METATYNAME (r as ref tyfun,_,_,_)),
@


1.10
log
@Added the array type
@
text
@d3 3
d106 1
@


1.9
log
@Changed ref unit in valenv to ref int to assist encoder
@
text
@d3 3
d100 1
@


1.8
log
@Changed comparison with ref_tyname to use tyname_eq, in order to assist
separate compilation system
@
text
@d3 4
d66 1
a66 1
	      ref (VE (ref (),Mapping.empty_map)))
@


1.7
log
@Added pervasive_tyname_count giving tyname id of first tyname after
the pervasives have been defined and added code to reset tyname counter
prior to defining the pervasives.
@
text
@d3 5
a262 26
    (****
     type_equalityp determines the equality attribute of a type.
     ****)

    fun type_equalityp (TYVAR (_,Ident.TYVAR (_,eq,_))) = eq
      | type_equalityp (METATYVAR (ref (_,NULLTYPE),eq,_)) = eq
      | type_equalityp (METATYVAR (ref (_,t),eq,_)) = type_equalityp t
      | type_equalityp (META_OVERLOADED _) = true
      | type_equalityp (METARECTYPE (ref (_,_,t,_,_))) = type_equalityp t
      | type_equalityp (CONSTYPE ([],n)) = eq_attrib n
      | type_equalityp (CONSTYPE (tylist as h::t,n)) =
	let 
	  fun collect [] = true
	    | collect (h::t) = (type_equalityp h) andalso (collect t)
	in
	  if n = ref_tyname
	    then
	      true
	  else
	    (eq_attrib n) andalso (collect tylist)
	end
      | type_equalityp (RECTYPE amap) = Mapping.forall (amap,type_equalityp)
      | type_equalityp (FUNTYPE(a,r)) = false 
      | type_equalityp (DEBRUIJN (_,eq,_)) = eq		      
      | type_equalityp NULLTYPE = true 
  
a392 4
    fun equalityp (TYFUN (atype,a)) = type_equalityp atype
      | equalityp (ETA_TYFUN (tyname)) = eq_attrib tyname
      | equalityp (NULL_TYFUN (_)) = false
	
d678 27
@


1.6
log
@Removed last argument to calls to make_tyname
Removed no_of_cons
@
text
@d3 4
d77 2
d88 2
@


1.5
log
@Removed inexhaustive matches
@
text
@d2 4
a5 1
$Log:	_types.sml,v $
d51 2
a52 2
    fun make_tyname (n,eq,pname,no_cons) = 
      TYNAME (Tyname_id.make_tyname_id no_cons,pname,n,ref eq, 
d73 9
a81 12
    fun no_of_cons (TYNAME (id,_,_,_,_)) = Tyname_id.no_of_cons id
    | no_of_cons (METATYNAME _) = Crash.impossible"no_of_cons METATYNAME"
    
    val bool_tyname = make_tyname (0,true,"bool",2)
    val int_tyname = make_tyname (0,true,"int",0)
    val real_tyname = make_tyname (0,true,"real",0)
    val string_tyname = make_tyname (0,true,"string",0)
    val list_tyname = make_tyname (1,true,"list",2)
    val ref_tyname = make_tyname (1,true,"ref",1)
    val exn_tyname = make_tyname (0,false,"exn",0)
    val instream_tyname = make_tyname (0,false,"instream",0)	  
    val outstream_tyname = make_tyname (0,false,"outstream",0)
@


1.4
log
@Made eq tynames print with a [t] otherwise an [f] in print_name
This makes debugging easier than before ;-)
@
text
@d3 4
d18 1
d56 1
d71 1
d88 1
d835 1
a836 1

d1159 1
d1164 1
@


1.3
log
@Added functions (isFunType) to check for a funtype and (argres) to extract
argument and result types.
@
text
@d3 4
d838 1
a838 1
						     name ^ "[f]"
d840 1
a840 1
						     name ^ "[t]")
@


1.2
log
@Modified to take new ValEnv definition with ref unit to allow
reading and writing circular data structures.
@
text
@d3 4
d1280 13
a1292 1
  end;
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d37 1
a37 1
	      ref (VE (Mapping.empty_map)))
@
