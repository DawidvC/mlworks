head	1.18;
access;
symbols
	MLW_daveb_inline_1_4_99:1.18.3
	MLWorks_21c0_1999_03_25:1.18
	MLWorks_20c1_1998_08_20:1.18
	MLWorks_20c0_1998_08_04:1.18
	MLWorks_20b2c2_1998_06_19:1.18
	MLWorks_20b2_Windows_1998_06_12:1.18
	MLWorks_20b1c1_1998_05_07:1.18
	MLWorks_20b0_1998_04_07:1.18
	MLWorks_20b0_1998_03_20:1.18
	MLWorks_20m2_1998_02_16:1.18
	MLWorks_20m1_1997_10_23:1.18
	MLWorks_11r1:1.17.5.1.1.1.1
	MLWorks_workspace_97:1.18.2
	MLWorks_dt_wizard:1.18.1
	MLWorks_11c0_1997_09_09:1.17.5.1.1.1
	MLWorks_10r3:1.17.5.1.3
	MLWorks_10r2_551:1.17.5.1.2
	MLWorks_11:1.17.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.17.5.1
	MLWorks_20m0_1997_06_20:1.18
	MLWorks_1_0_r2c2_1997_06_14:1.17.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.17.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.17.5
	MLWorks_BugFix_1997_04_24:1.17
	MLWorks_1_0_r2_Win32_1997_04_11:1.17
	MLWorks_1_0_r2_Unix_1997_04_04:1.17
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.17.3.1.1
	MLWorks_gui_1996_12_18:1.17.4
	MLWorks_1_0_Win32_1996_12_17:1.17.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.17.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.17.1.1
	MLWorks_1_0_Irix_1996_11_28:1.17.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.17.2
	MLWorks_1_0_Unix_1996_11_14:1.17.1
	MLWorks_Open_Beta2_1996_10_11:1.16.3
	MLWorks_License_dev:1.16.2
	MLWorks_1_open_beta_1996_09_13:1.16.1
	MLWorks_Open_Beta_1996_08_22:1.16
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.15
	MLWorks_Beta_1996_06_06:1.15
	MLWorks_Beta_1996_06_05:1.15
	MLWorks_Beta_1996_06_03:1.15
	MLWorks_Beta_1996_05_31:1.15
	MLWorks_Beta_1996_05_30:1.15
	ML_beta_release_12/08/94:1.8
	ML_beta_release_03/08/94:1.8
	ML_revised_beta_release_25/05/94:1.8
	ML_final_beta_release_02/03/94:1.8
	mlworks-28-01-1994:1.7
	Release:1.5
	mlworks-beta-01-09-1993:1.5;
locks; strict;
comment	@ * @;


1.18
date	97.05.01.15.40.12;	author jont;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1;
next	1.17;

1.17
date	96.11.06.11.33.44;	author matthew;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1
	1.17.5.1;
next	1.16;

1.16
date	96.08.06.11.54.31;	author andreww;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1;
next	1.15;

1.15
date	96.04.29.14.03.27;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	96.03.19.16.05.28;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	96.03.08.12.08.45;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	96.02.21.17.04.24;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	95.12.27.12.09.43;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.12.18.12.29.27;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	95.01.17.14.04.04;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	94.02.21.22.53.21;	author nosa;	state Exp;
branches;
next	1.7;

1.7
date	93.11.24.17.40.18;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.09.16.14.56.18;	author nosa;	state Exp;
branches;
next	1.5;

1.5
date	93.05.18.18.18.09;	author jont;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	93.04.08.08.28.32;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	93.03.09.12.25.04;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	93.03.02.17.34.29;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	93.02.19.15.32.00;	author matthew;	state Exp;
branches;
next	;

1.5.1.1
date	93.05.18.18.18.09;	author jont;	state Exp;
branches;
next	;

1.16.1.1
date	96.09.13.11.41.14;	author hope;	state Exp;
branches;
next	;

1.16.2.1
date	96.10.07.16.34.16;	author hope;	state Exp;
branches;
next	;

1.16.3.1
date	96.10.17.11.53.24;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.11.14.13.20.59;	author hope;	state Exp;
branches
	1.17.1.1.1.1;
next	;

1.17.1.1.1.1
date	96.11.28.15.31.59;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.11.22.18.38.45;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.12.17.18.17.46;	author hope;	state Exp;
branches
	1.17.3.1.1.1;
next	;

1.17.3.1.1.1
date	97.02.24.12.12.02;	author hope;	state Exp;
branches;
next	;

1.17.4.1
date	96.12.18.10.13.02;	author hope;	state Exp;
branches;
next	;

1.17.5.1
date	97.05.12.10.51.21;	author hope;	state Exp;
branches
	1.17.5.1.1.1
	1.17.5.1.2.1
	1.17.5.1.3.1;
next	;

1.17.5.1.1.1
date	97.07.28.18.34.43;	author daveb;	state Exp;
branches
	1.17.5.1.1.1.1.1;
next	;

1.17.5.1.1.1.1.1
date	97.10.07.12.00.32;	author jkbrook;	state Exp;
branches;
next	;

1.17.5.1.2.1
date	97.09.08.17.27.35;	author daveb;	state Exp;
branches;
next	;

1.17.5.1.3.1
date	97.09.09.14.24.34;	author daveb;	state Exp;
branches;
next	;

1.18.1.1
date	97.09.10.19.43.30;	author brucem;	state Exp;
branches;
next	;

1.18.2.1
date	97.09.11.21.10.56;	author daveb;	state Exp;
branches;
next	;

1.18.3.1
date	99.04.01.18.09.10;	author daveb;	state Exp;
branches;
next	;


desc
@New stuff for type dynamic
@


1.18
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* _typerep_utils.sml the functor *)
(*
$Log: _typerep_utils.sml,v $
 * Revision 1.17  1996/11/06  11:33:44  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.16  1996/08/06  11:54:31  andreww
 * [Bug #1521]
 * propagating changes made to
 * _types.sml
 *
 * Revision 1.15  1996/04/29  14:03:27  matthew
 * Removing MLWorks.Integer.
 *
 * Revision 1.14  1996/03/19  16:05:28  matthew
 * Changed type of Scheme functions
 *
 * Revision 1.13  1996/03/08  12:08:45  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
 * Revision 1.12  1996/02/21  17:04:24  daveb
 * Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
 * some functionality to the Shell structure.
 *
 * Revision 1.11  1995/12/27  12:09:43  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.10  1995/12/18  12:29:27  matthew
Passing error info to schemify

Revision 1.9  1995/01/17  14:04:04  matthew
Debugger changes

Revision 1.8  1994/02/21  22:53:21  nosa
Changed Datatypes.instance to Datatypes.Instance.

Revision 1.7  1993/11/24  17:40:18  matthew
Added absyn annotations

Revision 1.6  1993/09/16  14:56:18  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.5  1993/05/18  18:18:09  jont
Removed integer parameter

Revision 1.4  1993/04/08  08:28:32  matthew
Removed a lot of rubbish
Added convert_dynamic_type to do closure
Simplified lambda code for coercion

Revision 1.3  1993/03/09  12:25:04  matthew
Absyn changes

Revision 1.2  1993/03/02  17:34:29  matthew
empty_rec_type to empty_rectype

Revision 1.1  1993/02/19  15:32:00  matthew
Initial revision


Copyright (c) 1993 Harlequin Ltd.
*)

(* This functor does the business of converting a type into an absyn
 expression that constructs the corresponding representation value *)

require "../basis/__int";

require "../utils/lists";
require "../utils/crash";
require "../typechecker/types";
require "../typechecker/scheme";
require "../basics/absyn";

require "typerep_utils";

functor TyperepUtils (
                      structure Lists : LISTS
                      structure Crash : CRASH
                      structure Types : TYPES
                      structure Scheme :SCHEME
                      structure Absyn : ABSYN

                      sharing Absyn.Ident = Types.Datatypes.Ident
                      sharing Absyn.Set = Scheme.Set
                      sharing Types.Datatypes = Scheme.Datatypes

                      sharing type Absyn.Type = Types.Datatypes.Type
                      sharing type Absyn.Instance = Types.Datatypes.Instance
                      sharing type Absyn.InstanceInfo = Types.Datatypes.InstanceInfo
                        ) : TYPEREP_UTILS =
  struct
    structure Datatypes = Types.Datatypes
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol
    structure Location = Ident.Location
    structure Absyn = Absyn

    fun make_tuple_exp exps =
      let fun do_one ((index,l),exp) =
        (index+1,(Ident.LAB (Symbol.find_symbol(Int.toString index)),exp) :: l)
        val (_,result) = Lists.reducel do_one ((0,[]),exps)
      in
        Absyn.RECORDexp result
      end

    val dynamic_path =
      Ident.PATH (Symbol.find_symbol "MLWorks",
                  Ident.PATH (Symbol.find_symbol "Internal",
                              Ident.PATH(Symbol.find_symbol "Dynamic",
                                         Ident.NOPATH)))

    val coerce_id = Ident.LONGVALID(dynamic_path,Ident.VAR(Symbol.find_symbol"coerce"))

    val coerce_type = Datatypes.FUNTYPE(Types.add_to_rectype
                                     (Ident.LAB (Symbol.find_symbol "1"),
                                      Types.dynamic_type,
                                      Types.add_to_rectype
                                      (Ident.LAB (Symbol.find_symbol "2"),
                                       Types.typerep_type,
                                       Types.empty_rectype)),
                                     Types.ml_value_type)

    fun make_coerce_expression (exp,atype) =
      Absyn.APPexp (Absyn.VALexp (coerce_id,ref coerce_type, 
                                  Location.UNKNOWN, 
                                  ref(Datatypes.ZERO,NONE)),
                    make_tuple_exp [exp,Absyn.MLVALUEexp (MLWorks.Internal.Value.cast atype)],
                    Location.UNKNOWN,
                    ref Types.ml_value_type,
                    false)

    exception ConvertDynamicType

    fun convert_dynamic_type (use_value_polymorphism,ty,level,tyvars) =
      if Scheme.check_closure (use_value_polymorphism,ty,level,tyvars)
        then
          case Scheme.schemify'(level,
                                true,
                                Datatypes.UNBOUND_SCHEME (ty,NONE),
                                tyvars,
                                true) of
            Datatypes.SCHEME(_,(scheme_type,_)) => scheme_type
          | Datatypes.UNBOUND_SCHEME (scheme_type,_) => scheme_type
          | _ => Crash.impossible "convert_dynamic_type"
      else 
        raise ConvertDynamicType
  end;
@


1.18.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.18  1997/05/01  15:40:12  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.18.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.18  1997/05/01  15:40:12  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.18.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.18  1997/05/01  15:40:12  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.17
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d128 1
a128 1
                                  ref(Datatypes.ZERO,MLWorks.Option.NONE)),
d141 1
a141 1
                                Datatypes.UNBOUND_SCHEME (ty,MLWorks.Option.NONE),
@


1.17.5.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/11/06  11:33:44  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.17.5.1  1997/05/12  10:51:21  hope
 * branched from 1.17
 *
@


1.17.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.17.5.1  1997/05/12  10:51:21  hope
 * branched from 1.17
 *
@


1.17.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.17.5.1  1997/05/12  10:51:21  hope
 * branched from 1.17
 *
@


1.17.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.17.5.1.1.1  1997/07/28  18:34:43  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.17.4.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/11/06  11:33:44  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.3.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/11/06  11:33:44  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.3.1.1.1
log
@branched from 1.17.3.1
@
text
@a3 3
 * Revision 1.17.3.1  1996/12/17  18:17:46  hope
 * branched from 1.17
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/11/06  11:33:44  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/11/06  11:33:44  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.1.1.1.1
log
@branched from 1.17.1.1
@
text
@a3 3
 * Revision 1.17.1.1  1996/11/14  13:20:59  hope
 * branched from 1.17
 *
@


1.16
log
@[Bug #1521]
propagating changes made to
_types.sml
@
text
@d4 5
d64 1
a64 1
require "../basis/__integer";
@


1.16.3.1
log
@branched from 1.16
@
text
@a3 5
 * Revision 1.16  1996/08/06  11:54:31  andreww
 * [Bug #1521]
 * propagating changes made to
 * _types.sml
 *
@


1.16.2.1
log
@branched from 1.16
@
text
@a3 5
 * Revision 1.16  1996/08/06  11:54:31  andreww
 * [Bug #1521]
 * propagating changes made to
 * _types.sml
 *
@


1.16.1.1
log
@branched from 1.16
@
text
@a3 5
 * Revision 1.16  1996/08/06  11:54:31  andreww
 * [Bug #1521]
 * propagating changes made to
 * _types.sml
 *
@


1.15
log
@Removing MLWorks.Integer.
@
text
@d4 3
d130 1
a130 2
          case Scheme.schemify'(use_value_polymorphism,
                                level,
@


1.14
log
@Changed type of Scheme functions
@
text
@d4 3
d56 2
d90 1
a90 1
        (index+1,(Ident.LAB (Symbol.find_symbol(MLWorks.Integer.makestring index)),exp) :: l)
@


1.13
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@d4 3
d119 2
a120 2
    fun convert_dynamic_type (ty,level,tyvars) =
      if Scheme.check_closure (ty,level,tyvars)
d122 2
a123 1
          case Scheme.schemify'(level,
@


1.12
log
@Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
some functionality to the Shell structure.
@
text
@d4 4
d101 1
a101 1
                                       Types.type_type,
@


1.11
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d84 5
a88 3
    val dynamic_path = Ident.PATH(Symbol.find_symbol"MLWorks",
                                  Ident.PATH(Symbol.find_symbol"Dynamic",
                                             Ident.NOPATH))
@


1.10
log
@Passing error info to schemify
@
text
@d4 3
d99 1
a99 1
                                  ref(Datatypes.ZERO,Absyn.Option.ABSENT)),
d112 1
a112 1
                                Datatypes.UNBOUND_SCHEME (ty,Datatypes.Option.ABSENT),
@


1.9
log
@Debugger changes
@
text
@d4 3
d107 5
a111 5
          case Scheme.schemify(level,
                               true,
                               Datatypes.UNBOUND_SCHEME (ty,Datatypes.Option.ABSENT),
                               tyvars,
                               true) of
@


1.8
log
@Changed Datatypes.instance to Datatypes.Instance.
@
text
@d4 3
d58 1
d93 1
a93 1
                                  ref(nil,Absyn.Option.ABSENT)),
@


1.7
log
@Added absyn annotations
@
text
@d4 3
d54 1
a54 1
                      sharing type Absyn.Instance = Types.Datatypes.instance
d88 2
a89 1
                                  Location.UNKNOWN, Absyn.Option.ABSENT),
@


1.6
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d88 2
a89 1
                    ref Types.ml_value_type)
@


1.5
log
@Removed integer parameter
@
text
@d4 3
d48 1
d81 2
a82 1
      Absyn.APPexp (Absyn.VALexp (coerce_id,ref coerce_type, Location.UNKNOWN),
d94 1
a94 1
                               Datatypes.UNBOUND_SCHEME ty,
d97 2
a98 2
            Datatypes.SCHEME(_,scheme_type) => scheme_type
          | Datatypes.UNBOUND_SCHEME (scheme_type) => scheme_type
@


1.5.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.5  1993/05/18  18:18:09  jont
Removed integer parameter

@


1.4
log
@Removed a lot of rubbish
Added convert_dynamic_type to do closure
Simplified lambda code for coercion
@
text
@d4 5
a24 1
require "../utils/integer";
d33 1
a33 1
functor TyperepUtils (structure Integer : INTEGER
d55 1
a55 1
        (index+1,(Ident.LAB (Symbol.find_symbol(Integer.makestring index)),exp) :: l)
@


1.3
log
@Absyn changes
@
text
@d4 3
d20 3
d26 1
a26 2
require "../utils/integer";
require "../utils/lists";
d29 10
a38 5
functor Typerep_Utils (structure Types : TYPES
                       structure Scheme :SCHEME
                       structure Absyn : ABSYN
                       structure Integer : INTEGER
                       structure Lists : LISTS
d40 2
a41 5
                       sharing Absyn.Ident = Types.Datatypes.Ident
                       sharing Types.Datatypes = Scheme.Datatypes

                       sharing type Absyn.Type = Types.Datatypes.Type
                         ) : TYPEREP_UTILS =
a48 112
    structure TypeRep = MLWorks.Internal.TypeRep

    exception CantPrint
    exception PrintRepList

    fun print_typerep typerep =
      let 
        fun print_seplist (l,acc,start,ends,sep,pfun) = 
            let fun aux ([],acc) = acc
                  | aux ([x],acc) = pfun (x,acc)
                  | aux (x :: l, acc) = pfun(x,sep::aux(l,acc))
            in
              start :: aux (l, ends :: acc)
            end

        fun print_tyvar (n,eq,imp) =
          let fun get_name (n,acc) =
            if n div 26 = 0
              then
                (n mod 26) :: acc
            else
              get_name((n div 26)-1,(n mod 26) :: acc)
          in
            implode ("'" ::
                     (if eq then "'" else "") ::
                     (if imp then "_" else "") ::
                      map (fn c => chr(c+(ord"a")))(get_name (n,[])))
          end

        fun print_tyname(TypeRep.TYNAME(_,s,_)) = s

        fun print (TypeRep.TYVAR tyvar,acc) = (print_tyvar tyvar) :: acc
          | print (TypeRep.RECTYPE labreplist,acc) =
            print_seplist(labreplist,acc,"{","}",", ",
                          fn ((TypeRep.LABEL lab,rep),acc) => lab :: " = " :: (print (rep,acc)))
          | print (TypeRep.FUNTYPE (typerep1,typerep2),acc) =
            print (typerep1," -> ":: (print (typerep2,acc)))
          | print (TypeRep.CONSTYPE (replist,tyname),acc) =
            case replist of
              [] => (print_tyname tyname) :: acc
            | _ => print_seplist(replist, (print_tyname tyname)::acc,"(",")",", ",print)
      in
        implode (print (typerep,[]))
      end

    exception MakeScheme
    fun make_scheme ty =
      let val tyvars = Types.tyvars ([],ty)
      in
        case Scheme.schemify(0,false,Datatypes.UNBOUND_SCHEME ty,Scheme.Set.list_to_set tyvars,false) of
          Datatypes.SCHEME(_,scheme_type) => scheme_type
        | Datatypes.UNBOUND_SCHEME (scheme_type) => scheme_type
        | _ => raise MakeScheme
      end

    fun print_tyvar (n,eq,imp) =
      let fun get_name (n,acc) =
        if n div 26 = 0
          then
            (n mod 26) :: acc
        else
          get_name((n div 26)-1,(n mod 26) :: acc)
      in
        implode ("'" ::
                 (if eq then "'" else "") ::
                 (if imp then "_" else "") ::
                 map (fn c => chr(c+(ord"a")))(get_name (n,[])))
      end

    exception BadType of string

    fun type_to_typerep ty =
      let
        fun convert_tyname(Datatypes.METATYNAME _) = raise BadType "METATYNAME"
          | convert_tyname(Datatypes.TYNAME(tyname_id,name,_,ref eq,_,_)) =
            TypeRep.TYNAME(Datatypes.Tyname_id.tyname_id tyname_id,name,eq)
        fun conv (Datatypes.METATYVAR (ref (_,t),_,_)) = conv t
          | conv (Datatypes.META_OVERLOADED (ref t,_)) = conv t
          | conv (Datatypes.TYVAR _) = raise BadType "Free Tyvar"
          | conv (Datatypes.METARECTYPE (ref (_,_,t,_,_))) = conv t
          | conv (Datatypes.RECTYPE amap) =
            TypeRep.RECTYPE
            (map 
             (fn (Ident.LAB s,t) => (TypeRep.LABEL (Symbol.symbol_name s), conv t))
             (Datatypes.Mapping.assoc amap))
          | conv (Datatypes.FUNTYPE(t,t')) = TypeRep.FUNTYPE(conv t,conv t')
          | conv (Datatypes.CONSTYPE (tlist,tyname)) =
            let
              fun get_tyfun (Datatypes.METATYNAME (ref (Datatypes.ETA_TYFUN(tyname)),_,_,_,_)) = get_tyfun tyname
                | get_tyfun (Datatypes.METATYNAME (ref tyfun,_,_,_,_)) = tyfun
                | get_tyfun tyname = Datatypes.ETA_TYFUN tyname
              val tyfun = get_tyfun (tyname)
            in
              case tyfun of
                Datatypes.TYFUN _ => (conv (Types.apply (tyfun,tlist)))
              | Datatypes.ETA_TYFUN (tyname) => TypeRep.CONSTYPE(map conv tlist, convert_tyname tyname)
              | Datatypes.NULL_TYFUN _ => raise BadType "NULL_TYFUN"
            end
          | conv (Datatypes.DEBRUIJN (i,eq,imp)) = TypeRep.TYVAR(i,eq,imp)
          | conv Datatypes.NULLTYPE = raise BadType "NULLTYPE"
      in
        conv ty
      end

    (* We make some gross assumptions about the representations of Dynamic values here *)

    fun make_int_scon n = Absyn.SCONexp(Ident.INT (Integer.makestring n,Location.UNKNOWN))

    fun make_string_scon s = Absyn.SCONexp (Ident.STRING s)

    fun int_from_bool b = if b then 1 else 0

d57 14
a70 2
    fun make_tagged_exp(n, exp) =
      make_tuple_exp [make_int_scon n, exp]
a71 51
    fun make_list_exp [] = make_int_scon 1
      | make_list_exp (a::l) = make_tuple_exp[a,make_list_exp l]
      
    fun make_typerep_exp (TypeRep.CONSTYPE (typereplist,TypeRep.TYNAME (n,s,eq))) =
      make_tagged_exp (0,
                       make_tuple_exp [make_list_exp (map make_typerep_exp typereplist),
                                       make_tuple_exp [make_int_scon n,
                                                       make_string_scon s,
                                                       make_int_scon (int_from_bool eq)]])
      | make_typerep_exp (TypeRep.FUNTYPE (typerep1,typerep2)) =
        make_tagged_exp (1,make_tuple_exp [make_typerep_exp typerep1,make_typerep_exp typerep2])
      | make_typerep_exp (TypeRep.RECTYPE labreplist) =
        let fun do_one (TypeRep.LABEL s,typerep) =
          make_tuple_exp [make_string_scon s,make_typerep_exp typerep]
        in
          make_tagged_exp (2, make_list_exp (map do_one labreplist))
        end
      | make_typerep_exp (TypeRep.TYVAR (n,eq,imp)) =
        make_tagged_exp (3,make_tuple_exp(map make_int_scon [n,int_from_bool eq,int_from_bool imp]))
      
    fun make_typerep_expression (exp,atype) =
    (* Make an absyn expression constructing the relevant dynamic types *)
    let
      val typerep = type_to_typerep (make_scheme atype)
      val typerep_exp = make_typerep_exp typerep
    in
      make_tuple_exp[exp,typerep_exp]
    end

    val true_id = Ident.LONGVALID(Ident.NOPATH,Ident.CON (Symbol.find_symbol "true"))
    val false_id = Ident.LONGVALID(Ident.NOPATH,Ident.CON (Symbol.find_symbol "false"))

    val typerep_path = Ident.PATH(Symbol.find_symbol"MLWorks",
                               Ident.PATH(Symbol.find_symbol"Internal",
                                          Ident.PATH(Symbol.find_symbol"TypeRep",
                                                     Ident.NOPATH)))

    val get_value_id = Ident.LONGVALID(typerep_path,Ident.VAR(Symbol.find_symbol"get_value"))
    val get_type_id = Ident.LONGVALID(typerep_path,Ident.VAR(Symbol.find_symbol"get_type"))
    val generalises_id = Ident.LONGVALID(typerep_path,Ident.VAR(Symbol.find_symbol"generalises"))
    val coerce_exn_id = Ident.LONGVALID(typerep_path,Ident.EXCON(Symbol.find_symbol"Coerce"))

    fun bin_pred_type atype= Datatypes.FUNTYPE(Types.add_to_rectype
                                               (Ident.LAB (Symbol.find_symbol "1"),
                                                atype,
                                                Types.add_to_rectype
                                                (Ident.LAB (Symbol.find_symbol "2"),
                                                 atype,
                                                 Types.empty_rectype)),
                                               Types.bool_type)

d73 2
a74 31
      (* and should be done by the parser *)(* note that exp is evaluated twice also *)
      (* make an expression of:
       "if generalises (get_type exp,<type_rep atype>) then get_value exp else raise Coerce"
       *)
      Absyn.APPexp
      (Absyn.FNexp ([(Absyn.VALpat((true_id,
                                    ref Types.bool_type),
                                   Location.UNKNOWN),
                      (Absyn.APPexp (Absyn.VALexp (get_value_id,ref Datatypes.NULLTYPE,Location.UNKNOWN),
                                     exp,
                                     Location.UNKNOWN,
                                     ref atype))),
                     (Absyn.VALpat((false_id,
                                    ref Types.bool_type),
                                   Location.UNKNOWN),
                      Absyn.RAISEexp (Absyn.VALexp (coerce_exn_id,ref Types.exn_type,Location.UNKNOWN),
                                      Location.UNKNOWN))],
                      ref (Datatypes.FUNTYPE(Types.bool_type,atype)),
                      "No information",
                      Location.UNKNOWN),
      Absyn.APPexp (Absyn.VALexp (generalises_id,ref (bin_pred_type Datatypes.NULLTYPE), Location.UNKNOWN),
                    (* compare the second element of the expression against the given type *)
                    make_tuple_exp [Absyn.APPexp (Absyn.VALexp (get_type_id,ref Datatypes.NULLTYPE,Location.UNKNOWN),
                                                   exp,
                                                   Location.UNKNOWN,
                                                   ref Types.dynamic_type),
                                    let val typerep = (type_to_typerep (make_scheme atype))
                                    in
                                      output(std_out,print_typerep typerep ^ "\n");
                                      make_typerep_exp typerep
                                    end],
d76 17
a92 3
                    ref Types.bool_type),
      Location.UNKNOWN,
      ref atype)
@


1.2
log
@empty_rec_type to empty_rectype
@
text
@d4 3
d29 5
a33 1
                       sharing Absyn.Datatypes = Types.Datatypes = Scheme.Datatypes
@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
d206 1
a206 1
                                                 Types.empty_rec_type)),
@
