head	1.42;
access;
symbols
	MLW_daveb_inline_1_4_99:1.42.1
	MLWorks_21c0_1999_03_25:1.42
	MLWorks_20c1_1998_08_20:1.42
	MLWorks_20c0_1998_08_04:1.42
	MLWorks_20b2c2_1998_06_19:1.42
	MLWorks_20b2_Windows_1998_06_12:1.42
	MLWorks_20b1c1_1998_05_07:1.42
	MLWorks_20b0_1998_04_07:1.42
	MLWorks_20b0_1998_03_20:1.42
	MLWorks_20m2_1998_02_16:1.41
	MLWorks_20m1_1997_10_23:1.41
	MLWorks_11r1:1.41.5.1.1.1.1
	MLWorks_workspace_97:1.41.7
	MLWorks_dt_wizard:1.41.6
	MLWorks_11c0_1997_09_09:1.41.5.1.1.1
	MLWorks_10r3:1.41.5.1.3
	MLWorks_10r2_551:1.41.5.1.2
	MLWorks_11:1.41.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.41.5.1
	MLWorks_20m0_1997_06_20:1.41
	MLWorks_1_0_r2c2_1997_06_14:1.41.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.41.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.41.5
	MLWorks_BugFix_1997_04_24:1.41
	MLWorks_1_0_r2_Win32_1997_04_11:1.41
	MLWorks_1_0_r2_Unix_1997_04_04:1.41
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.41.3.1.1
	MLWorks_gui_1996_12_18:1.41.4
	MLWorks_1_0_Win32_1996_12_17:1.41.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.41.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.41.1.1
	MLWorks_1_0_Irix_1996_11_28:1.41.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.41.2
	MLWorks_1_0_Unix_1996_11_14:1.41.1
	MLWorks_Open_Beta2_1996_10_11:1.40.1
	MLWorks_License_dev:1.39.2
	MLWorks_1_open_beta_1996_09_13:1.39.1
	MLWorks_Open_Beta_1996_08_22:1.39
	MLWorks_Beta_1996_07_02:1.38
	MLWorks_Beta_1996_06_07:1.38
	MLWorks_Beta_1996_06_06:1.38
	MLWorks_Beta_1996_06_05:1.38
	MLWorks_Beta_1996_06_03:1.38
	MLWorks_Beta_1996_05_31:1.38
	MLWorks_Beta_1996_05_30:1.38
	ML_beta_release_12/08/94:1.29
	ML_beta_release_03/08/94:1.29
	ML_revised_beta_release_25/05/94:1.28
	ML_final_beta_release_02/03/94:1.25
	mlworks-28-01-1994:1.23
	Release:1.20
	mlworks-beta-01-09-1993:1.20
	MLWorks-1-0-4-29/01/1993:1.9
	MLWorks-1-0-3-21/12/1992:1.8
	MLWorks-1-0-2-15/12/1992:1.8
	MLWorks-1-0-1-04/12/1992:1.8
	checkpoint_17_08_92:1.6
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.42
date	98.03.20.16.14.44;	author jont;	state Exp;
branches
	1.42.1.1;
next	1.41;

1.41
date	96.10.09.12.58.28;	author io;	state Exp;
branches
	1.41.1.1
	1.41.2.1
	1.41.3.1
	1.41.4.1
	1.41.5.1
	1.41.6.1
	1.41.7.1;
next	1.40;

1.40
date	96.10.02.11.42.14;	author andreww;	state Exp;
branches
	1.40.1.1;
next	1.39;

1.39
date	96.08.05.13.36.15;	author andreww;	state Exp;
branches
	1.39.1.1
	1.39.2.1;
next	1.38;

1.38
date	96.04.30.15.21.43;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	96.02.26.11.38.56;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	96.02.22.11.33.13;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	95.04.11.10.00.10;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	95.04.10.10.48.38;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	95.03.28.12.00.28;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	95.02.07.11.06.16;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	95.01.11.13.59.56;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	94.09.15.16.48.54;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	94.06.17.16.52.13;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	94.05.12.14.34.04;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	94.05.06.12.57.10;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	94.05.04.16.16.26;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	94.02.28.06.01.43;	author nosa;	state Exp;
branches;
next	1.24;

1.24
date	94.02.08.14.49.11;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.11.30.11.17.33;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.11.25.09.34.55;	author nickh;	state Exp;
branches;
next	1.21;

1.21
date	93.08.16.10.36.45;	author nosa;	state Exp;
branches;
next	1.20;

1.20
date	93.07.09.12.37.50;	author nosa;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	93.06.30.15.23.49;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	93.05.18.19.35.18;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	93.04.02.16.17.37;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.03.31.13.52.42;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.03.04.10.17.26;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.03.02.16.26.46;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.02.24.14.26.48;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.02.24.13.07.07;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.02.22.16.27.29;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.01.27.14.17.54;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.12.07.16.38.50;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.11.24.17.01.49;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	92.10.09.14.38.43;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.08.11.12.00.05;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.08.04.12.21.14;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.07.22.12.31.06;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.01.24.16.30.38;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.21.16.44.36;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.34.54;	author colin;	state Exp;
branches;
next	;

1.20.1.1
date	93.07.09.12.37.50;	author jont;	state Exp;
branches;
next	;

1.39.1.1
date	96.09.13.11.42.13;	author hope;	state Exp;
branches;
next	;

1.39.2.1
date	96.10.07.16.35.19;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	96.10.17.11.54.24;	author hope;	state Exp;
branches;
next	;

1.41.1.1
date	96.11.14.13.22.29;	author hope;	state Exp;
branches
	1.41.1.1.1.1;
next	;

1.41.1.1.1.1
date	96.11.28.15.33.09;	author hope;	state Exp;
branches;
next	;

1.41.2.1
date	96.11.22.18.39.46;	author hope;	state Exp;
branches;
next	;

1.41.3.1
date	96.12.17.18.18.47;	author hope;	state Exp;
branches
	1.41.3.1.1.1;
next	;

1.41.3.1.1.1
date	97.02.24.12.13.03;	author hope;	state Exp;
branches;
next	;

1.41.4.1
date	96.12.18.10.14.07;	author hope;	state Exp;
branches;
next	;

1.41.5.1
date	97.05.12.10.52.20;	author hope;	state Exp;
branches
	1.41.5.1.1.1
	1.41.5.1.2.1
	1.41.5.1.3.1;
next	;

1.41.5.1.1.1
date	97.07.28.18.34.07;	author daveb;	state Exp;
branches
	1.41.5.1.1.1.1.1;
next	;

1.41.5.1.1.1.1.1
date	97.10.07.12.00.05;	author jkbrook;	state Exp;
branches;
next	;

1.41.5.1.2.1
date	97.09.08.17.27.11;	author daveb;	state Exp;
branches;
next	;

1.41.5.1.3.1
date	97.09.09.14.24.09;	author daveb;	state Exp;
branches;
next	;

1.41.6.1
date	97.09.10.19.43.02;	author brucem;	state Exp;
branches;
next	;

1.41.7.1
date	97.09.11.21.10.32;	author daveb;	state Exp;
branches;
next	;

1.42.1.1
date	99.04.01.18.08.56;	author daveb;	state Exp;
branches;
next	;


desc
@Long type constructor name completion
@


1.42
log
@[Bug #30090]
Remove MLWorks.IO in favour of print
@
text
@(* _completion.sml the functor *)
(*
$Log: _completion.sml,v $
 * Revision 1.41  1996/10/09  12:58:28  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.40  1996/10/02  11:42:14  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
 * Revision 1.39  1996/08/05  13:36:15  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml
 *
 * Revision 1.38  1996/04/30  15:21:43  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.37  1996/02/26  11:38:56  jont
 * Change newhashtable to hashtable
 *
 * Revision 1.36  1996/02/22  11:33:13  jont
 * Replacing Map with NewMap
 *
 * Revision 1.35  1995/04/11  10:00:10  matthew
 * Adding cached completion functions
 *
Revision 1.34  1995/04/10  10:48:38  matthew
Fixing problem with tyfuns without stamps

Revision 1.33  1995/03/28  12:00:28  matthew
Use Stamp instead of Tyname_id etc.

Revision 1.32  1995/02/07  11:06:16  matthew
Rationalizations

Revision 1.31  1995/01/11  13:59:56  jont
Modified COPYSTR case of searchSE so as to search the inner str in
the case where the requested tyname is not in the range of the copy map

Revision 1.30  1994/09/15  16:48:54  jont
Remove use of myoutput

Revision 1.29  1994/06/17  16:52:13  jont
Allow alternative printing of types to include quantifiers

Revision 1.28  1994/05/12  14:34:04  daveb
Datatypes.META_OVERLOADED has extra arguments.

Revision 1.27  1994/05/06  12:57:10  jont
Fix the type completion problems, which were due to tynames
sometimes having multiple pre-images in the copy maps.
Also removed several redundant handlers around name copying functions

Revision 1.26  1994/05/04  16:16:26  jont
Fix use of check_debruijns to be safe

Revision 1.25  1994/02/28  06:01:43  nosa
Replaced option in NULL_TYFUNs for polymorphic debugger.

Revision 1.24  1994/02/08  14:49:11  matthew
Added diagnostics.  This is not a permanent change.

Revision 1.23  1993/11/30  11:17:33  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.22  1993/11/25  09:34:55  nickh
Added function to report a type error as a list of types and strings.
Also changed the treatment of unbound type variables in completion;
they need to test equal on separate calls to print_type_with_seen_tyvars,
so we need to retain the ref cell.

Revision 1.21  1993/08/16  10:36:45  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.20  1993/07/09  12:37:50  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.

Revision 1.19  1993/06/30  15:23:49  daveb
Removed exception environments.

Revision 1.18  1993/05/18  19:35:18  jont
Removed integer parameter

Revision 1.17  1993/04/02  16:17:37  matthew
Changed debug_print_type to print_type

Revision 1.16  1993/03/31  13:52:42  jont
Redone using hash tables instead of abusing maps. Fixed a minor potential
fault to do with not stripping TYFUN(CONSTYPE)

Revision 1.15  1993/03/04  10:17:26  matthew
Options & Info changes

Revision 1.14  1993/03/02  16:26:46  matthew
Trivia

Revision 1.13  1993/02/24  14:26:48  matthew
Fixed problem with completing tynames

Revision 1.11  1993/02/22  16:27:29  matthew
Various tidyings and mucking around.  This file needs rewriting.

Revision 1.10  1993/01/27  14:17:54  matthew
Changes for COPYSTR's
This is grossly inefficient and must be fixed.

Revision 1.9  1992/12/07  16:38:50  jont
Anel's last changes

Revision 1.8  1992/11/24  17:01:49  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.7  1992/10/09  14:38:43  clive
Tynames now have a slot recording their definition point

Revision 1.6  1992/08/11  12:00:05  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.5  1992/08/04  12:21:14  jont
Anel's changes to use NewMap instead of Map

Revision 1.4  1992/07/22  12:31:06  jont
Removed references to Lists.foldl and Lists.foldr

Revision 1.3  1992/01/24  16:30:38  jont
Update to allow valenv in METATYNAME

Revision 1.2  1991/11/21  16:44:36  jont
Added copyright message

Revision 1.1  91/06/07  11:34:54  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basics/identprint";
require "../utils/lists";
require "../utils/hashtable";
require "types";
require "namehash";
require "stamp";
require "completion";

(*****
Long type constructor name completion
*****)

functor Completion(
  structure Types : TYPES
  structure Lists : LISTS
  structure IdentPrint : IDENTPRINT
  structure NameHash : NAMEHASH
  structure HashTable : HASHTABLE
  structure Stamp : STAMP

  sharing NameHash.Datatypes = Types.Datatypes
  sharing IdentPrint.Ident = Types.Datatypes.Ident
  sharing type Types.Datatypes.Stamp = Stamp.Stamp
  sharing type Types.Datatypes.StampMap = Stamp.Map.T
		   ): COMPLETION =

struct
  structure Datatypes = Types.Datatypes
  structure NewMap = Datatypes.NewMap
  structure Options = Types.Options

  (* poor old NJ can't cope with some of the uses of #1, so ... *)
  fun first (a,b) = a

  (*****
  Functions for manipulating mappings.
  *****)

  open Datatypes

(*
  fun print_tyname(TYNAME{1=id, 2=s, ...}) =
    "TYNAME{id=" ^ Stamp.string_stamp id ^
    ",s=" ^ s ^ "}"
    | print_tyname(METATYNAME{1=ref tyfun, 2=s, ...}) =
      "METATYNAME{tyfun=" ^ print_tyfun tyfun ^ ",s=" ^ s ^ "}"

and print_tyfun(ETA_TYFUN tyname) =
    "ETA_TYFUN(" ^ print_tyname tyname ^ ")"
    | print_tyfun(TYFUN(ty, i)) =
      "TYFUN(" ^
      (case ty of
	 CONSTYPE(ty_list, tyname) =>
	   if Types.tyname_arity tyname = i andalso Types.check_debruijns(ty_list, 0) then
	     print_tyfun(ETA_TYFUN tyname)
	   else
	     "Complicated type"
       | _ => "Complicated type") ^ ")"
    | print_tyfun(NULL_TYFUN id) =
      "NULL_TYFUN(" ^ Stamp.string_stamp id ^ ")"
*)

  fun tyname_eq (id, TYNAME {1=id',...}) = id = id'
    | tyname_eq (id, METATYNAME {1=ref tyfun,...}) =
      tyfun_eq (id,tyfun)

  and tyfun_eq (id,TYFUN _) = false
    | tyfun_eq (id,ETA_TYFUN tyname) = tyname_eq (id,tyname)
    | tyfun_eq (id,NULL_TYFUN (id',ref tyfun)) = id = id'

  exception TyfunStamp
  fun tyname_stamp (TYNAME {1=id,...}) = id
    | tyname_stamp (METATYNAME {1=ref tyfun,...}) = tyfun_stamp tyfun

  and tyfun_stamp (TYFUN _) = raise TyfunStamp (* Crash.impossible "tyfun_stamp" *)
    | tyfun_stamp (ETA_TYFUN tyname) = tyname_stamp tyname
    | tyfun_stamp (NULL_TYFUN (id,ref tyfun)) = id

  type Cache = ((Type,Type) HashTable.HashTable *
                (Stamp.Stamp,string) HashTable.HashTable)

  local
    fun type_eq(ty1, ty2) = Types.type_eq(ty1, ty2, false, false)
  in
    fun empty_cache () = (HashTable.new(10, type_eq, NameHash.type_hash),
                          HashTable.new(10, (op =), Stamp.stamp))
  end

  (*****
  Result datatype.
  *****)

  datatype 'a result = YES of 'a | NO

  (*****
  Search an environment for a type name, returning a list of strings which
  is the path name. Returns [] if no occurrence was found in E.
  *****)

  fun searchE (ENV(strenv, tyenv, _), tyname_id) =
    case searchTE(tyenv, tyname_id) of
      YES tycon => [IdentPrint.printTyCon tycon]
    | NO => searchSE(strenv, tyname_id)

  (*****
  Search a structure environment for a type name, returning a list of
  strings which is the path name. Returns [] if no occurrence was
  found in SE.
  *****)

  and searchSE (SE mapping, tyname_id) =
    let
      fun check ([], strid, (STR(_,_,env)),tyname_id) =
	  (case searchE(env, tyname_id) of
	     [] => []
	   | namelist => (IdentPrint.printStrId strid ^ ".") :: namelist)
	| check (namelist, strid, (STR(_,_,env)), tyname_id) =
	  (case searchE(env, tyname_id) of
	     [] => namelist
	   | namelist' =>
	       let
		 val len  = length namelist
		 val len' = length namelist'
	       in
		 if len'+1 < len then
		   (IdentPrint.printStrId strid ^ ".") :: namelist'
		 (* Prefer the latter list only if it will be shorter *)
		 else
		   namelist
	       end)
        | check (namelist,strid,COPYSTR((smap,tmap),str),tyname_id) =
(* The old way of doing it
          check (namelist,strid,Env.str_copy (str,smap,tmap),tyname_id)
*)
          let
            val result =
              Stamp.Map.fold
              (fn (result, tyfun_id, tyname') =>
	       if tyname_eq(tyname_id, tyname') then
		 tyfun_id :: result
	       else
		 result)
              ([], tmap)
          in
	    (* this stuff may be bogus *)
            case result of
              [] => check(namelist, strid, str, tyname_id)
            | tyfun_id_list =>
                let
		  fun check_one(namelist, tyfun_id) =
		    check(namelist, strid, str, tyfun_id)

		  val new_namelist = Lists.reducel check_one (namelist, tyfun_id_list)
                in
		  new_namelist
                end
          end
    in
      NewMap.fold (fn (a,b,c) => check(a,b,c,tyname_id)) ([],mapping)
    end

  and searchTE (TE mapping, tyname_id) =
    let
      fun print (args as (_,_,TYSTR(tyfun,_))) =
        args
      fun check(NO, tycon, (TYSTR(ETA_TYFUN tyname', _))) =
	if tyname_eq(tyname_id, tyname') then
	  YES tycon
	else
	  NO
	| check(NO, tycon, (TYSTR(tyfun as TYFUN _, _))) =
	  let
	    val tyfun' = Types.tyfun_strip tyfun
	  in
	    case tyfun' of
	      ETA_TYFUN tyname' =>
		if tyname_eq(tyname_id, tyname') then
		  YES tycon
		else
		  NO
	    | _ => NO
	  end
	| check(NO, _, _) = NO
	| check(arg as YES _, _, _) = arg
    in
      NewMap.fold (check o print) (NO, mapping)
    end

  (*****
  Check if we managed to find a path, append "(hidden)" to the
  original name if we didn't.
  *****)

  fun check_tyname (env, (map1, map2), tyname, name) =
    case HashTable.tryLookup(map2, tyname) of
      SOME result => result
    | _ =>
	(case searchE(env, tyname) of
	   [] => name ^ "(hidden)"
	 | namelist => concat namelist)
  
  (*****
  This function changes the name component of each type name so that
  it contains a path to an occurrence of that type name in the supplied
  environment. The path returned is always the shortest path. Note that
  references in METATYVAR's etc are NOT updated, they are copied, otherwise
  this function could change types in the basis.
  *****)

  fun complete_tycons (env, m as (m1, _), 
                       t as METATYVAR(ref (x, ty,i), eq, imp)) =
    (case HashTable.tryLookup(m1, t) of
        SOME result => (result, m)
     | _ =>
	 (case ty of
	    NULLTYPE =>
	      (t,m)
	  | _ =>
	      let
		val (ty', m as (m1, _)) = complete_tycons (env, m, ty)
		val t' = METATYVAR(ref (x, ty',i), eq, imp)
		val _ = HashTable.update(m1, t, t')
	      in
		(t', m)
	      end))
    | complete_tycons (env, m as (m1, _),
		       t as META_OVERLOADED(ref ty,tv,valid,loc)) =
      (case HashTable.tryLookup(m1, t) of
	 SOME result => (result, m)
       | _ =>
	   let
	     val (ty', m as (m1, _)) = complete_tycons (env, m, ty)
	     val t' = META_OVERLOADED(ref ty',tv,valid,loc)
	     val _ = HashTable.update(m1, t, t')
	   in
	     (t', m)
	   end)
    | complete_tycons (env, m, ty as (TYVAR _)) = (ty, m)
    | complete_tycons (env, m, METARECTYPE (ref (level, flex, ty, eq, imp))) =
      let
	val (ty', m') = complete_tycons (env, m, ty)
      in
	(METARECTYPE(ref (level, flex, ty, eq, imp)), m')
      end
    | complete_tycons (env, m, RECTYPE fields) =
      let
	fun f((fields, m), lab, ty) =
	  let
	    val (ty', m') = complete_tycons(env, m, ty)
	  in
	    (NewMap.define'(fields, (lab, ty')), m')
	  end
	val (fields', m') = NewMap.fold f ((NewMap.empty' Ident.lab_lt, m), fields)
      in
	(RECTYPE fields', m')
      end
    | complete_tycons (env, m, FUNTYPE(ty1, ty2)) =
      let
	val (ty1', m1) = complete_tycons(env, m , ty1)
	val (ty2', m2) = complete_tycons(env, m1, ty2)
      in
	(FUNTYPE(ty1', ty2'), m2)
      end
    | complete_tycons (env, m, CONSTYPE(type_list, tyname)) =
      let
	fun f (ty, (ty_list, m1)) =
	  let
	    val (ty', m2) = complete_tycons(env, m1, ty)
	  in
	    (ty' :: ty_list, m2)
	  end

	val (tyname', m') = change_name (env, m, tyname)
	val (type_list', m'') = Lists.reducer f (type_list, ([], m'))
      in
	(CONSTYPE(type_list', tyname'), m'')
      end
    | complete_tycons (env, m, ty as (DEBRUIJN _)) = (ty, m)
    | complete_tycons (env, m, ty as NULLTYPE) = (ty, m)

  and change_name (env, m as (_, m2), tyname) =
    case tyname of
      METATYNAME(ref tyfun, name, arity, ref eq, ref valenv,ref is_abs) =>
	(let
          val stamp = tyname_stamp tyname
	  val name' = check_tyname(env, m, stamp, name)
          val tyname' = METATYNAME(ref tyfun, name', arity, ref eq, ref valenv,ref is_abs)
	  val _ = HashTable.update(m2, stamp, name')
	in
	  (tyname', m)
	end
        handle TyfunStamp => (tyname,m))

    | TYNAME(stamp, name, arity, ref eq, ref valenv,location,ref is_abs,
             ve_copy, level) =>
	let
	  val name' = check_tyname(env, m, stamp, name)
	  val tyname' = TYNAME(stamp, name', arity, ref eq, ref valenv,
                               location,ref is_abs,ve_copy,level)
	  val _ = HashTable.update(m2, stamp, name')
	in
	  (tyname', m)
	end
    
  (*****
  The top level call to complete_tycons
  *****)

  val complete_tycons =
    fn (env,cache,ty) => first(complete_tycons(env,cache, Types.simplify_type ty))

  (* Print out a type using tycon name completion *)
    
  fun print_type (options,env,ty) =
    let
      val ty' = complete_tycons (env,empty_cache (),ty)
    in
      Types.print_type options ty'
    end

  (* The cache is just side effected so we just return it *)
  fun cached_print_type (options,env,ty,cache) =
    let
      val ty' = complete_tycons (env,cache,ty)
    in
      (Types.print_type options ty',cache)
    end

  fun has_debruijns(deb_list, METATYVAR(ref(_, ty, _), _, _)) =
    has_debruijns(deb_list, ty)
    | has_debruijns(deb_list, META_OVERLOADED _) = deb_list
    | has_debruijns(deb_list, TYVAR _) = deb_list
    | has_debruijns(deb_list, METARECTYPE(ref{3= ty, ...})) =
      has_debruijns(deb_list, ty)
    | has_debruijns(deb_list, RECTYPE map) =
      NewMap.fold
      (fn (deb_list, _, ty) => has_debruijns(deb_list, ty))
      (deb_list, map)
    | has_debruijns(deb_list, FUNTYPE(ty, ty')) =
      has_debruijns(has_debruijns(deb_list, ty), ty')
    | has_debruijns(deb_list, CONSTYPE(ty_list, _)) =
      Lists.reducel has_debruijns (deb_list, ty_list)
    | has_debruijns(deb_list, DEBRUIJN deb) =
      if Lists.member (deb, deb_list) then deb_list else deb :: deb_list
    | has_debruijns(deb_list, NULLTYPE) = deb_list

  fun string_debruijn options (i, eq, imp, _) 
    = Types.string_debruijn(options,i, eq, imp)

  fun print_debs _ [] = []
    | print_debs options [a] = [string_debruijn options a]
    | print_debs options (a :: rest) = string_debruijn options a 
                               :: ", " :: print_debs options rest

  fun print_debruijns _ [] = ""
    | print_debruijns options [a] 
             = "(for all " ^ string_debruijn options a ^ ")."
    | print_debruijns options list  = "(for all " 
      ^ concat(print_debs options list) ^ ")."

  fun report_type_error (options,env,l) =
    let
      val cache = empty_cache ()
      fun f (Err_String s,tyvars) = (s,tyvars)
	| f (Err_Type t,tyvars) = 
	  Types.print_type_with_seen_tyvars
          (options,complete_tycons (env,cache,t),tyvars)
	| f (Err_Scheme t,tyvars) = 
	  let
	    val result as (str, tyvars) =
	      Types.print_type_with_seen_tyvars
              (options,complete_tycons (env,cache,t),tyvars)
	  in
	    case has_debruijns([], t) of
	      [] => result
	    | deb_list => (print_debruijns options deb_list
                           ^ str, tyvars)
	  end
	| f (Err_Reset, _) = ("",Types.no_tyvars)
      fun foldmap ([],tyvars,acc) = rev acc
	| foldmap (ty::tys,tyvars,acc) =
	  let
	    val (name,tyvars) = f(ty,tyvars)
	  in
	    foldmap (tys,tyvars,name::acc)
	  end
    in
      concat (foldmap (l,Types.no_tyvars,[]))
    end
end









@


1.42.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.42  1998/03/20  16:14:44  jont
 * [Bug #30090]
 * Remove MLWorks.IO in favour of print
 *
@


1.41
log
@[Bug #1614]
basifying String
@
text
@d4 4
a181 3
  val domyoutput = true
  fun myoutput (str,s) = if domyoutput then MLWorks.IO.output (str,s) else ()

d257 1
a257 2
	  ((*myoutput(std_out,"Checking " ^ IdentPrint.printStrId strid ^ "\n");*)
           case searchE(env, tyname_id) of
d261 1
a261 2
	  ((*myoutput(std_out,"Checking " ^ concat ((IdentPrint.printStrId strid ^ ".") :: namelist) ^ "\n");*)
           case searchE(env, tyname_id) of
a278 3
(*
            val _ = myoutput(std_out,"Checking " ^ concat ((IdentPrint.printStrId strid ^ ".") :: namelist) ^ "\n")
*)
a292 3
(*
                  val _ = myoutput(std_out, "Checking ...")
*)
d298 1
a298 6
                  if new_namelist = namelist then
		    ((* myoutput(std_out,"Name `" ^ Stamp.string_stamp tyname_id ^
			      "' not found though in nameset\n"); *)
		     new_namelist)
                  else
                    new_namelist
d308 1
a308 2
        ((*myoutput(std_out,"Comparing with " ^ Types.string_tyfun tyfun ^ "\n");*)
         args)
@


1.41.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.41  1996/10/09  12:58:28  io
 * [Bug #1614]
 * basifying String
 *
@


1.41.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.41  1996/10/09  12:58:28  io
 * [Bug #1614]
 * basifying String
 *
@


1.41.5.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/10/09  12:58:28  io
 * [Bug #1614]
 * basifying String
 *
@


1.41.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.41.5.1  1997/05/12  10:52:20  hope
 * branched from 1.41
 *
@


1.41.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.41.5.1  1997/05/12  10:52:20  hope
 * branched from 1.41
 *
@


1.41.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.41.5.1  1997/05/12  10:52:20  hope
 * branched from 1.41
 *
@


1.41.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.41.5.1.1.1  1997/07/28  18:34:07  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.41.4.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/10/09  12:58:28  io
 * [Bug #1614]
 * basifying String
 *
@


1.41.3.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/10/09  12:58:28  io
 * [Bug #1614]
 * basifying String
 *
@


1.41.3.1.1.1
log
@branched from 1.41.3.1
@
text
@a3 3
 * Revision 1.41.3.1  1996/12/17  18:18:47  hope
 * branched from 1.41
 *
@


1.41.2.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/10/09  12:58:28  io
 * [Bug #1614]
 * basifying String
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/10/09  12:58:28  io
 * [Bug #1614]
 * basifying String
 *
@


1.41.1.1.1.1
log
@branched from 1.41.1.1
@
text
@a3 3
 * Revision 1.41.1.1  1996/11/14  13:22:29  hope
 * branched from 1.41
 *
@


1.40
log
@[Bug #1592]
Threading extra level argument through tynames.
@
text
@d4 4
d261 1
a261 1
	  ((*myoutput(std_out,"Checking " ^ String.implode ((IdentPrint.printStrId strid ^ ".") :: namelist) ^ "\n");*)
d266 2
a267 2
		 val length  = Lists.length namelist
		 val length' = Lists.length namelist'
d269 1
a269 1
		 if length'+1 < length then
d281 1
a281 1
            val _ = myoutput(std_out,"Checking " ^ String.implode ((IdentPrint.printStrId strid ^ ".") :: namelist) ^ "\n")
d352 1
a352 1
      MLWorks.Option.SOME result => result
d356 1
a356 1
	 | namelist => String.implode namelist)
d369 1
a369 1
        MLWorks.Option.SOME result => (result, m)
d385 1
a385 1
	 MLWorks.Option.SOME result => (result, m)
d515 1
a515 1
      ^ String.implode(print_debs options list) ^ ")."
d544 1
a544 1
      String.implode (foldmap (l,Types.no_tyvars,[]))
@


1.40.1.1
log
@branched from 1.40
@
text
@a3 4
 * Revision 1.40  1996/10/02  11:42:14  andreww
 * [Bug #1592]
 * Threading extra level argument through tynames.
 *
@


1.39
log
@[Bug #1521]
Propagating changes to _types.sml
@
text
@d4 4
d446 2
a447 1
    | TYNAME(stamp, name, arity, ref eq, ref valenv,location,ref is_abs,ve_copy) =>
d450 2
a451 1
	  val tyname' = TYNAME(stamp, name', arity, ref eq, ref valenv,location,ref is_abs,ve_copy)
@


1.39.2.1
log
@branched from 1.39
@
text
@a3 4
 * Revision 1.39  1996/08/05  13:36:15  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml
 *
@


1.39.1.1
log
@branched from 1.39
@
text
@a3 4
 * Revision 1.39  1996/08/05  13:36:15  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml
 *
@


1.38
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d493 2
a494 1
  fun string_debruijn(i, eq, imp, _) = Types.string_debruijn(i, eq, imp)
d496 10
a505 7
  fun print_debs [] = []
    | print_debs [a] = [string_debruijn a]
    | print_debs (a :: rest) = string_debruijn a :: ", " :: print_debs rest

  fun print_debruijns [] = ""
    | print_debruijns [a] = "(for all " ^ string_debruijn a ^ ")."
    | print_debruijns list = "(for all " ^ String.implode(print_debs list) ^ ")."
d512 2
a513 1
	  Types.print_type_with_seen_tyvars(options,complete_tycons (env,cache,t),tyvars)
d517 2
a518 1
	      Types.print_type_with_seen_tyvars(options,complete_tycons (env,cache,t),tyvars)
d522 2
a523 1
	    | deb_list => (print_debruijns deb_list ^ str, tyvars)
d537 9
@


1.37
log
@Change newhashtable to hashtable
@
text
@d4 3
d165 1
a165 1
  fun myoutput (str,s) = if domyoutput then output (str,s) else ()
d247 1
a247 1
	  ((*myoutput(std_out,"Checking " ^ implode ((IdentPrint.printStrId strid ^ ".") :: namelist) ^ "\n");*)
d267 1
a267 1
            val _ = myoutput(std_out,"Checking " ^ implode ((IdentPrint.printStrId strid ^ ".") :: namelist) ^ "\n")
d342 1
a342 1
	 | namelist => implode namelist)
d495 1
a495 1
    | print_debruijns list = "(for all " ^ implode(print_debs list) ^ ")."
d521 1
a521 1
      implode (foldmap (l,Types.no_tyvars,[]))
@


1.36
log
@Replacing Map with NewMap
@
text
@d4 3
d125 1
a125 1
require "../utils/newhashtable";
d140 1
a140 1
  structure NewHashTable : NEWHASHTABLE
d204 2
a205 2
  type Cache = ((Type,Type) NewHashTable.HashTable *
                (Stamp.Stamp,string) NewHashTable.HashTable)
d210 2
a211 2
    fun empty_cache () = (NewHashTable.new(10, type_eq, NameHash.type_hash),
                          NewHashTable.new(10, (op =), Stamp.stamp))
d334 2
a335 2
    case NewHashTable.tryLookup(map2, tyname) of
      NewHashTable.YES result => result
d351 2
a352 2
    (case NewHashTable.tryLookup(m1, t) of
       NewHashTable.YES result => (result, m)
d361 1
a361 1
		val _ = NewHashTable.update(m1, t, t')
d367 2
a368 2
      (case NewHashTable.tryLookup(m1, t) of
	 NewHashTable.YES result => (result, m)
d373 1
a373 1
	     val _ = NewHashTable.update(m1, t, t')
d427 1
a427 1
	  val _ = NewHashTable.update(m2, stamp, name')
d437 1
a437 1
	  val _ = NewHashTable.update(m2, stamp, name')
@


1.35
log
@Adding cached completion functions
@
text
@d4 3
a149 1
  structure Mapping = Datatypes.Mapping
a184 2
  val empty = Mapping.empty_map

d383 1
a383 1
	fun f lab ty (fields, m) =
d387 1
a387 1
	    (Mapping.add((lab, ty'), fields, op=), m')
d389 1
a389 1
	val (fields', m') = Mapping.Fold f (empty, m) fields
d470 3
a472 3
      Lists.reducel
      (fn (deb_list, (_, ty)) => has_debruijns(deb_list, ty))
      (deb_list, Mapping.assoc map)
@


1.34
log
@Fixing problem with tyfuns without stamps
@
text
@d4 3
d201 3
d207 2
a208 2
    fun empty_pair() = (NewHashTable.new(10, type_eq, NameHash.type_hash),
			NewHashTable.new(10, (op =), Stamp.stamp))
d444 1
a444 1
    fn (env, ty) => first(complete_tycons(env, empty_pair(), Types.simplify_type ty))
d446 1
a446 3
  (*****
   Print out a type using tycon name completion
   *****)
d450 1
a450 1
      val ty' = complete_tycons (env, ty)
d455 7
a461 39
  fun print_name (options,env,tyname) =
    Types.print_name options (first(change_name (env,empty_pair(),tyname)))

(*
  fun has_tyvars(tyvar_list, METATYVAR(ref(_, ty, _), _, _)) =
    has_tyvars(tyvar_list, ty)
    | has_tyvars(tyvar_list, META_OVERLOADED _) = tyvar_list
    | has_tyvars(tyvar_list, TYVAR(_, tyvar)) =
      if Lists.member(tyvar, tyvar_list) then tyvar_list else tyvar :: tyvar_list
    | has_tyvars(tyvar_list, METARECTYPE(ref{3= ty, ...})) =
      has_tyvars(tyvar_list, ty)
    | has_tyvars(tyvar_list, RECTYPE map) =
      Lists.reducel
      (fn (tyvar_list, (_, ty)) => has_tyvars(tyvar_list, ty))
      (tyvar_list, Mapping.assoc map)
    | has_tyvars(tyvar_list, FUNTYPE(ty, ty')) =
      has_tyvars(has_tyvars(tyvar_list, ty), ty')
    | has_tyvars(tyvar_list, CONSTYPE(ty_list, _)) =
      Lists.reducel has_tyvars (tyvar_list, ty_list)
    | has_tyvars(tyvar_list, DEBRUIJN deb) = tyvar_list
    | has_tyvars(tyvar_list, NULLTYPE) = tyvar_list

  fun has_metatyvars(tyvar_list, METATYVAR(tyvar as ref(_, ty, _), _, _)) =
    if Lists.member(tyvar, tyvar_list) then tyvar_list else tyvar :: tyvar_list
    | has_metatyvars(tyvar_list, META_OVERLOADED _) = tyvar_list
    | has_metatyvars(tyvar_list, TYVAR(_, tyvar)) = tyvar_list
    | has_metatyvars(tyvar_list, METARECTYPE(ref{3= ty, ...})) =
      has_metatyvars(tyvar_list, ty)
    | has_metatyvars(tyvar_list, RECTYPE map) =
      Lists.reducel
      (fn (tyvar_list, (_, ty)) => has_metatyvars(tyvar_list, ty))
      (tyvar_list, Mapping.assoc map)
    | has_metatyvars(tyvar_list, FUNTYPE(ty, ty')) =
      has_metatyvars(has_metatyvars(tyvar_list, ty), ty')
    | has_metatyvars(tyvar_list, CONSTYPE(ty_list, _)) =
      Lists.reducel has_metatyvars (tyvar_list, ty_list)
    | has_metatyvars(tyvar_list, DEBRUIJN deb) = tyvar_list
    | has_metatyvars(tyvar_list, NULLTYPE) = tyvar_list
*)
d493 1
d496 1
a496 2
	  Types.print_type_with_seen_tyvars(options,complete_tycons (env,t),
					    tyvars)
d500 1
a500 10
	      Types.print_type_with_seen_tyvars(options,complete_tycons (env,t),
						tyvars)
(*
	    val _ = case has_tyvars([], t) of
	      [] => ()
	    | _ => output(std_out, "Following type has free tyvars\n")
	    val _ = case has_metatyvars([], t) of
	      [] => ()
	    | _ => output(std_out, "Following type has free metatyvars\n")
*)
@


1.33
log
@Use Stamp instead of Tyname_id etc.
@
text
@d4 3
d438 1
a438 1
    fn (env, ty) => first(complete_tycons(env, empty_pair(), ty))
@


1.32
log
@Rationalizations
@
text
@d4 3
d116 1
d129 1
d133 2
d150 1
a150 1
  val domyoutput = false
d157 1
a157 1
    "TYNAME{id=" ^ MLWorks.Integer.makestring(Tyname_id.tyname_id id) ^
d174 1
a174 1
      "NULL_TYFUN(" ^ MLWorks.Integer.makestring(Tyfun_id.tyfun_id id) ^ ")"
d179 16
a194 14
  fun tyname_eq (t1,t2) =
    let
      val result = Types.tyname_eq (t1,t2)
    in
(*
      myoutput (std_out,
              "`" ^ Types.debug_print_name t1 ^
              "' and `" ^ Types.debug_print_name t2 ^
              (if result then "' are" else "' are not") ^
              " equal\n");
*)
      result
    end
              
d199 1
a199 1
			NewHashTable.new(10, tyname_eq, NameHash.tyname_hash))
a201 7
  fun make_dummy_tyname(id,TYNAME(_,s,n,b,ve,so,is_abs,_)) =
    METATYNAME(ref(NULL_TYFUN (id,(ref(TYFUN(NULLTYPE,0))))),
			 s,n,b,ve,is_abs)
    | make_dummy_tyname(id,METATYNAME(_,s,n,b,ve,is_abs)) =
      METATYNAME(ref(NULL_TYFUN (id,(ref(TYFUN(NULLTYPE,0))))),
			   s,n,b,ve,is_abs)

d213 2
a214 2
  fun searchE (ENV(strenv, tyenv, _), tyname) =
    case searchTE(tyenv, tyname) of
d216 1
a216 1
    | NO => searchSE(strenv, tyname)
d224 1
a224 1
  and searchSE (SE mapping, tyname) =
d226 1
a226 1
      fun check ([], strid, (STR(_,_,env)),tyname) =
d228 1
a228 1
           case searchE(env, tyname) of
d231 1
a231 1
	| check (namelist, strid, (STR(_,_,env)), tyname) =
d233 1
a233 1
           case searchE(env, tyname) of
d246 1
a246 1
        | check (namelist,strid,COPYSTR((smap,tmap),str),tyname) =
d248 1
a248 1
          check (namelist,strid,Env.str_copy (str,smap,tmap),tyname)
d255 1
a255 1
              Tyfun_id.Map.fold
d257 1
a257 1
	       if tyname_eq(tyname, tyname') then
d265 1
a265 1
              [] => check(namelist, strid, str, tyname)
d272 1
a272 1
		    check(namelist, strid, str, make_dummy_tyname(tyfun_id, tyname))
d277 2
a278 2
		    ((*myoutput(std_out,"Name `" ^ Types.debug_print_name tyname ^
			      "' not found though in nameset\n");*)
d285 1
a285 1
      NewMap.fold (fn (a,b,c) => check(a,b,c,tyname)) ([],mapping)
d288 1
a288 1
  and searchTE (TE mapping, tyname) =
d294 1
a294 1
	if tyname_eq(tyname, tyname') then
d304 1
a304 1
		if tyname_eq(tyname, tyname') then
d411 3
a413 2
	let
	  val name' = check_tyname(env, m, tyname, name)
d415 1
a415 1
	  val _ = NewHashTable.update(m2, tyname, name')
d419 1
d421 1
a421 1
    | TYNAME(id, name, arity, ref eq, ref valenv,location,ref is_abs,ve_copy) =>
d423 3
a425 3
	  val name' = check_tyname(env, m, tyname, name)
	  val tyname' = TYNAME(id, name', arity, ref eq, ref valenv,location,ref is_abs,ve_copy)
	  val _ = NewHashTable.update(m2, tyname, name')
@


1.31
log
@Modified COPYSTR case of searchSE so as to search the inner str in
the case where the requested tyname is not in the range of the copy map
@
text
@d4 4
d146 2
d149 2
a150 2
  fun print_tyname(Datatypes.TYNAME{1=id, 2=s, ...}) =
    "TYNAME{id=" ^ MLWorks.Integer.makestring(Datatypes.Tyname_id.tyname_id id) ^
d152 1
a152 1
    | print_tyname(Datatypes.METATYNAME{1=ref tyfun, 2=s, ...}) =
d155 1
a155 1
and print_tyfun(Datatypes.ETA_TYFUN tyname) =
d157 1
a157 1
    | print_tyfun(Datatypes.TYFUN(ty, i)) =
d160 1
a160 1
	 Datatypes.CONSTYPE(ty_list, tyname) =>
d162 1
a162 1
	     print_tyfun(Datatypes.ETA_TYFUN tyname)
d166 2
a167 2
    | print_tyfun(Datatypes.NULL_TYFUN id) =
      "NULL_TYFUN(" ^ MLWorks.Integer.makestring(Datatypes.Tyfun_id.tyfun_id id) ^ ")"
d193 2
a194 91

  local
    open Datatypes
    fun strname_copy (name as METASTRNAME (ref (NULLNAME id)), strname_copies) = 
      Strname_id.Map.apply_default'(strname_copies, name, id)
      | strname_copy (METASTRNAME (ref strname), strname_copies) = 
	strname_copy (strname,strname_copies)
      | strname_copy (strname, _) = strname

    fun compose_maps ((smap1,tmap1),(smap2,tmap2)) =
      (* do *map1 then *map2, ie. apply map2 to range of map1 *)
      let
        val smap2 =
          Strname_id.Map.map
          (fn (n1,n2) =>
           strname_copy(n2,smap2))
          smap1
        val tmap2 =
          Tyfun_id.Map.map
          (fn (tyfun,tyname) =>
           Types.tyname_copy(tyname,tmap2))
(* This handler shouldn't be necessary
           handle Tyfun_id.Map.Undefined => tyname
*)
          tmap1
      in
        (smap2,tmap2)
      end

    fun scheme_copy (s as SCHEME (n,(atype,instance)),tyname_copies) = 
        SCHEME(n, (Types.type_copy(atype, tyname_copies),instance))
      | scheme_copy (UNBOUND_SCHEME (atype,instance),tyname_copies) =
	UNBOUND_SCHEME(Types.type_copy(atype,tyname_copies),instance)
      | scheme_copy (scheme as OVERLOADED_SCHEME _, _) = 
	scheme

    fun ve_copy (VE (_,amap),tyname_copies) = 
      let
	fun copy (_, s) = scheme_copy (s,tyname_copies)
      in
	VE(ref 0, NewMap.map copy amap)
      end


    fun tystr_copy (TYSTR (tyfun,conenv), tyname_copies) = 
      TYSTR(Types.tyfun_copy (tyfun,tyname_copies), ve_copy(conenv,tyname_copies))

    fun te_copy (TE amap,tyname_copies) = 
      let
	fun copy (_, tystr) = tystr_copy (tystr, tyname_copies)
      in
	TE(NewMap.map copy amap)
      end

  in
    fun expand_str str =
      let
        fun expand (STR (strid,r,ENV(se,te,ve))) =
          (STR (strid,r,ENV(expand_se se,te,ve)))
          | expand (COPYSTR((smap,tmap),str)) =
            expand (str_copy (str,smap,tmap))
        and
          expand_se (SE se) =
          SE (NewMap.map (fn (strid,str) => expand_str str) se)
      in
        expand str
      end

    and str_copy (str, strname_copies, tyname_copies) =
      let
	fun copy_str (STR(name,r,ENV(se,te,ve))) =
	  STR(strname_copy (name,strname_copies),
	      r,
	      ENV (se_copy se, te_copy (te,tyname_copies),
		   ve_copy (ve,tyname_copies)))
          | copy_str (COPYSTR(maps,str)) =
            let val (smap,tmap) = compose_maps (maps,(strname_copies,tyname_copies))
            in
              str_copy (str,smap,tmap)
            end

	and se_copy (SE amap) =
	  SE(NewMap.map (fn (_, str) => copy_str str) amap)
        val result = copy_str str
     in
       result
     end
  end

  fun make_dummy_tyname(id,Datatypes.TYNAME(_,s,n,b,ve,so,is_abs,_)) =
    Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN (id,(ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))))),
d196 2
a197 2
    | make_dummy_tyname(id,Datatypes.METATYNAME(_,s,n,b,ve,is_abs)) =
      Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN (id,(ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))))),
d211 1
a211 1
  fun searchE (Datatypes.ENV(strenv, tyenv, _), tyname) =
d222 1
a222 1
  and searchSE (Datatypes.SE mapping, tyname) =
d224 1
a224 1
      fun check ([], strid, (Datatypes.STR(_,_,env)),tyname) =
d229 1
a229 1
	| check (namelist, strid, (Datatypes.STR(_,_,env)), tyname) =
d244 1
a244 1
        | check (namelist,strid,Datatypes.COPYSTR((smap,tmap),str),tyname) =
d246 1
a246 1
          check (namelist, strid,str_copy (str,smap,tmap),tyname)
d253 1
a253 1
              Datatypes.Tyfun_id.Map.fold
d286 1
a286 1
  and searchTE (Datatypes.TE mapping, tyname) =
d288 1
a288 1
      fun print (args as (_,_,Datatypes.TYSTR(tyfun,_))) =
d291 1
a291 1
      fun check(NO, tycon, (Datatypes.TYSTR(Datatypes.ETA_TYFUN tyname', _))) =
d296 1
a296 1
	| check(NO, tycon, (Datatypes.TYSTR(tyfun as Datatypes.TYFUN _, _))) =
d301 1
a301 1
	      Datatypes.ETA_TYFUN tyname' =>
d336 1
a336 1
                       t as Datatypes.METATYVAR(ref (x, ty,i), eq, imp)) =
d341 1
a341 1
	    Datatypes.NULLTYPE =>
d346 1
a346 1
		val t' = Datatypes.METATYVAR(ref (x, ty',i), eq, imp)
d352 1
a352 1
		       t as Datatypes.META_OVERLOADED(ref ty,tv,valid,loc)) =
d358 1
a358 1
	     val t' = Datatypes.META_OVERLOADED(ref ty',tv,valid,loc)
d363 2
a364 2
    | complete_tycons (env, m, ty as (Datatypes.TYVAR _)) = (ty, m)
    | complete_tycons (env, m, Datatypes.METARECTYPE (ref (level, flex, ty, eq, imp))) =
d368 1
a368 1
	(Datatypes.METARECTYPE(ref (level, flex, ty, eq, imp)), m')
d370 1
a370 1
    | complete_tycons (env, m, Datatypes.RECTYPE fields) =
d380 1
a380 1
	(Datatypes.RECTYPE fields', m')
d382 1
a382 1
    | complete_tycons (env, m, Datatypes.FUNTYPE(ty1, ty2)) =
d387 1
a387 1
	(Datatypes.FUNTYPE(ty1', ty2'), m2)
d389 1
a389 1
    | complete_tycons (env, m, Datatypes.CONSTYPE(type_list, tyname)) =
d401 1
a401 1
	(Datatypes.CONSTYPE(type_list', tyname'), m'')
d403 2
a404 2
    | complete_tycons (env, m, ty as (Datatypes.DEBRUIJN _)) = (ty, m)
    | complete_tycons (env, m, ty as Datatypes.NULLTYPE) = (ty, m)
d408 1
a408 1
      Datatypes.METATYNAME(ref tyfun, name, arity, ref eq, ref valenv,ref is_abs) =>
d411 1
a411 1
          val tyname' = Datatypes.METATYNAME(ref tyfun, name', arity, ref eq, ref valenv,ref is_abs)
d417 1
a417 1
    | Datatypes.TYNAME(id, name, arity, ref eq, ref valenv,location,ref is_abs,ve_copy) =>
d420 1
a420 1
	  val tyname' = Datatypes.TYNAME(id, name', arity, ref eq, ref valenv,location,ref is_abs,ve_copy)
d448 1
a448 1
  fun has_tyvars(tyvar_list, Datatypes.METATYVAR(ref(_, ty, _), _, _)) =
d450 2
a451 2
    | has_tyvars(tyvar_list, Datatypes.META_OVERLOADED _) = tyvar_list
    | has_tyvars(tyvar_list, Datatypes.TYVAR(_, tyvar)) =
d453 1
a453 1
    | has_tyvars(tyvar_list, Datatypes.METARECTYPE(ref{3= ty, ...})) =
d455 1
a455 1
    | has_tyvars(tyvar_list, Datatypes.RECTYPE map) =
d459 1
a459 1
    | has_tyvars(tyvar_list, Datatypes.FUNTYPE(ty, ty')) =
d461 1
a461 1
    | has_tyvars(tyvar_list, Datatypes.CONSTYPE(ty_list, _)) =
d463 2
a464 2
    | has_tyvars(tyvar_list, Datatypes.DEBRUIJN deb) = tyvar_list
    | has_tyvars(tyvar_list, Datatypes.NULLTYPE) = tyvar_list
d466 1
a466 1
  fun has_metatyvars(tyvar_list, Datatypes.METATYVAR(tyvar as ref(_, ty, _), _, _)) =
d468 3
a470 3
    | has_metatyvars(tyvar_list, Datatypes.META_OVERLOADED _) = tyvar_list
    | has_metatyvars(tyvar_list, Datatypes.TYVAR(_, tyvar)) = tyvar_list
    | has_metatyvars(tyvar_list, Datatypes.METARECTYPE(ref{3= ty, ...})) =
d472 1
a472 1
    | has_metatyvars(tyvar_list, Datatypes.RECTYPE map) =
d476 1
a476 1
    | has_metatyvars(tyvar_list, Datatypes.FUNTYPE(ty, ty')) =
d478 1
a478 1
    | has_metatyvars(tyvar_list, Datatypes.CONSTYPE(ty_list, _)) =
d480 2
a481 2
    | has_metatyvars(tyvar_list, Datatypes.DEBRUIJN deb) = tyvar_list
    | has_metatyvars(tyvar_list, Datatypes.NULLTYPE) = tyvar_list
d484 1
a484 1
  fun has_debruijns(deb_list, Datatypes.METATYVAR(ref(_, ty, _), _, _)) =
d486 3
a488 3
    | has_debruijns(deb_list, Datatypes.META_OVERLOADED _) = deb_list
    | has_debruijns(deb_list, Datatypes.TYVAR _) = deb_list
    | has_debruijns(deb_list, Datatypes.METARECTYPE(ref{3= ty, ...})) =
d490 1
a490 1
    | has_debruijns(deb_list, Datatypes.RECTYPE map) =
d494 1
a494 1
    | has_debruijns(deb_list, Datatypes.FUNTYPE(ty, ty')) =
d496 1
a496 1
    | has_debruijns(deb_list, Datatypes.CONSTYPE(ty_list, _)) =
d498 1
a498 1
    | has_debruijns(deb_list, Datatypes.DEBRUIJN deb) =
d500 1
a500 1
    | has_debruijns(deb_list, Datatypes.NULLTYPE) = deb_list
d514 2
a515 2
      fun f (Datatypes.Err_String s,tyvars) = (s,tyvars)
	| f (Datatypes.Err_Type t,tyvars) = 
d518 1
a518 1
	| f (Datatypes.Err_Scheme t,tyvars) = 
d536 1
a536 1
	| f (Datatypes.Err_Reset, _) = ("",Types.no_tyvars)
@


1.30
log
@Remove use of myoutput
@
text
@d4 3
d346 1
a346 1
              [] => namelist
d353 2
a354 5
		    let
		      val new_tyname = make_dummy_tyname(tyfun_id, tyname)
		    in
		      check(namelist, strid, str, make_dummy_tyname(tyfun_id, tyname))
		    end
@


1.29
log
@Allow alternative printing of types to include quantifiers
@
text
@d4 3
d167 1
d173 1
d305 1
a305 1
	  (myoutput(std_out,"Checking " ^ IdentPrint.printStrId strid ^ "\n");
d310 1
a310 1
	  (myoutput(std_out,"Checking " ^ implode ((IdentPrint.printStrId strid ^ ".") :: namelist) ^ "\n");
d329 1
d331 1
d346 1
d348 1
d358 2
a359 2
		    (myoutput(std_out,"Name `" ^ Types.debug_print_name tyname ^
			      "' not found though in nameset\n");
d372 1
a372 1
        (myoutput(std_out,"Comparing with " ^ Types.string_tyfun tyfun ^ "\n");
@


1.28
log
@Datatypes.META_OVERLOADED has extra arguments.
@
text
@d4 3
d521 100
a620 17
   fun report_type_error (options,env,l) =
     let
       fun f (Datatypes.Err_String s,tyvars) = (s,tyvars)
	 | f (Datatypes.Err_Type t,tyvars) = 
	   Types.print_type_with_seen_tyvars(options,complete_tycons (env,t),
					     tyvars)
	 | f (Datatypes.Err_Reset, _) = ("",Types.no_tyvars)
       fun foldmap ([],tyvars,acc) = rev acc
	 | foldmap (ty::tys,tyvars,acc) =
	   let
	     val (name,tyvars) = f(ty,tyvars)
	   in
	     foldmap (tys,tyvars,name::acc)
	   end
     in
       implode (foldmap (l,Types.no_tyvars,[]))
     end
@


1.27
log
@Fix the type completion problems, which were due to tynames
sometimes having multiple pre-images in the copy maps.
Also removed several redundant handlers around name copying functions
@
text
@d4 5
d422 2
a423 1
    | complete_tycons (env, m as (m1, _), t as Datatypes.META_OVERLOADED(ref ty,id)) =
d429 1
a429 1
	     val t' = Datatypes.META_OVERLOADED(ref ty',id)
@


1.26
log
@Fix use of check_debruijns to be safe
@
text
@d4 3
d175 1
a175 2
      (Strname_id.Map.apply'(strname_copies, id)
       handle Strname_id.Map.Undefined => name)
d191 4
a194 2
           Types.tyname_copy(tyname,tmap2)
           handle Tyfun_id.Map.Undefined => tyname)
d215 3
a217 3
  fun tystr_copy (TYSTR (tyfun,conenv), tyname_copies) = 
    TYSTR(Types.tyfun_copy (tyfun,tyname_copies), ve_copy(conenv,tyname_copies))
  
a251 1

d260 7
d312 1
a312 1
(*          
a316 6
            fun make_dummy_tyname (id,Datatypes.TYNAME(_,s,n,b,ve,so,is_abs,_)) =
              Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN (id,(ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))))),
                                   s,n,b,ve,is_abs)
              | make_dummy_tyname(id,Datatypes.METATYNAME(_,s,n,b,ve,is_abs)) =
                Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN (id,(ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))))),
                                     s,n,b,ve,is_abs)
d319 6
a324 6
              (fn (result as YES tyfun_id,_,_) => result
               | (NO,tyfun_id,tyname') =>
		   if tyname_eq (tyname,tyname')
		     then YES tyfun_id
		   else NO)
              (NO,tmap)
d328 2
a329 2
              NO => namelist
            | YES tyfun_id =>
d332 7
a338 1
                  val new_namelist = check(namelist, strid, str, make_dummy_tyname(tyfun_id, tyname))
d340 4
a343 4
                  if new_namelist = namelist
                    then
                      (myoutput(std_out,"Name `" ^ Types.debug_print_name tyname ^ "' not found though in nameset\n");
                       new_namelist)
@


1.25
log
@Replaced option in NULL_TYFUNs for polymorphic debugger.
@
text
@d4 3
d134 1
a134 1
    | print_tyfun(Datatypes.TYFUN(ty, _)) =
d138 1
a138 1
	   if Types.check_debruijns(ty_list, 0) then
@


1.24
log
@Added diagnostics.  This is not a permanent change.
@
text
@d4 3
d304 2
a305 2
            fun make_dummy_tyname (id,Datatypes.TYNAME(_,s,n,b,ve,so,is_abs)) =
              Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN (id,Datatypes.Option.ABSENT)),
d308 1
a308 1
                Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN (id,Datatypes.Option.ABSENT)),
d469 1
a469 1
    | Datatypes.TYNAME(id, name, arity, ref eq, ref valenv,location,ref is_abs) =>
d472 1
a472 1
	  val tyname' = Datatypes.TYNAME(id, name', arity, ref eq, ref valenv,location,ref is_abs)
@


1.23
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d116 3
d143 12
d159 1
a159 1
			NewHashTable.new(10, Types.tyname_eq, NameHash.tyname_hash))
d163 88
d276 2
a277 1
	  (case searchE(env, tyname) of
d281 2
a282 1
	  (case searchE(env, tyname) of
d295 4
a298 1
        | check (namelist,strid,Datatypes.COPYSTR((_,tmap),str),tyname) =
d300 1
a300 3
(*
            datatype Result = YES of Datatypes.Tyfun_id.Tyfun_id | NO
*)
d311 1
a311 1
		   if Types.tyname_eq (tyname,tyname')
d320 11
a330 1
                check(namelist, strid, str, make_dummy_tyname(tyfun_id, tyname))
d338 3
d342 1
a342 1
	if Types.tyname_eq(tyname, tyname') then
d352 1
a352 1
		if Types.tyname_eq(tyname, tyname') then
d361 1
a361 1
      NewMap.fold check (NO, mapping)
@


1.22
log
@Added function to report a type error as a list of types and strings.
Also changed the treatment of unbound type variables in completion;
they need to test equal on separate calls to print_type_with_seen_tyvars,
so we need to retain the ref cell.
@
text
@d4 6
d120 1
a120 1
  and print_tyfun(Datatypes.ETA_TYFUN tyname) =
d192 1
a192 1
            fun make_dummy_tyname (id,Datatypes.TYNAME(_,s,n,b,ve,so)) =
d194 2
a195 2
                                   s,n,b,ve)
              | make_dummy_tyname(id,Datatypes.METATYNAME(_,s,n,b,ve)) =
d197 1
a197 1
                                     s,n,b,ve)
d335 1
a335 1
      Datatypes.METATYNAME(ref tyfun, name, arity, ref eq, ref valenv) =>
d338 1
a338 1
          val tyname' = Datatypes.METATYNAME(ref tyfun, name', arity, ref eq, ref valenv)
d344 1
a344 1
    | Datatypes.TYNAME(id, name, arity, ref eq, ref valenv,location) =>
d347 1
a347 1
	  val tyname' = Datatypes.TYNAME(id, name', arity, ref eq, ref valenv,location)
@


1.21
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d262 11
a272 7
	 let
	   val (ty', m as (m1, _)) = complete_tycons (env, m, ty)
	   val t' = Datatypes.METATYVAR(ref (x, ty',i), eq, imp)
	   val _ = NewHashTable.update(m1, t, t')
	 in
	   (t', m)
	 end)
d367 19
a385 1
end;
@


1.20
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.
@
text
@d4 4
d255 1
a255 1
                       t as Datatypes.METATYVAR(ref (x, ty), eq, imp)) =
d261 1
a261 1
	   val t' = Datatypes.METATYVAR(ref (x, ty'), eq, imp)
@


1.20.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.20  1993/07/09  12:37:50  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.

@


1.19
log
@Removed exception environments.
@
text
@d4 3
d180 2
a181 1
              Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN id),s,n,b,ve)
d183 2
a184 1
                Datatypes.METATYNAME(ref(Datatypes.NULL_TYFUN id),s,n,b,ve)
d250 2
a251 1
  fun complete_tycons (env, m as (m1, _), t as Datatypes.METATYVAR(ref (x, ty), eq, imp)) =
@


1.18
log
@Removed integer parameter
@
text
@d4 3
d140 1
a140 1
  fun searchE (Datatypes.ENV(strenv, tyenv, _, _), tyname) =
@


1.17
log
@Changed debug_print_type to print_type
@
text
@d4 3
a64 1
require "../utils/__integer";
d96 1
a96 1
    "TYNAME{id=" ^ Integer_.makestring(Datatypes.Tyname_id.tyname_id id) ^
d113 1
a113 1
      "NULL_TYFUN(" ^ Integer_.makestring(Datatypes.Tyfun_id.tyfun_id id) ^ ")"
@


1.16
log
@Redone using hash tables instead of abusing maps. Fixed a minor potential
fault to do with not stripping TYFUN(CONSTYPE)
@
text
@d4 4
d340 1
a340 1
      Types.debug_print_type (*options*) ty'
@


1.15
log
@Options & Info changes
@
text
@d4 3
d54 3
a56 2
require "../typechecker/types";

d58 1
d64 6
a69 3
functor Completion (structure Types : TYPES
                    structure Lists : LISTS
                    structure IdentPrint : IDENTPRINT
d71 3
a73 2
                    sharing IdentPrint.Ident = Types.Datatypes.Ident
                      ): COMPLETION =
d88 6
a93 1
  val empty = Mapping.empty_map
d95 14
a108 2
  infix 4 ++
  fun m ++ m' = Mapping.plus (m, m', op =)
d110 1
a110 2
  infix 5 |->
  fun key |-> value = Mapping.add ((key, value), empty, op =)
d113 1
a113 3
    fun type_eq (ty1, ty2) = Types.type_eq(ty1, ty2, false, false)
    val empty_type = Mapping.empty_eqfunmap type_eq
    val empty_tyname = Mapping.empty_eqfunmap Types.tyname_eq
d115 3
a117 4
    infix 5 -->
    fun key --> value =
      (Mapping.add((key, value), empty_type, type_eq), empty_tyname) :
      (Datatypes.Type, Datatypes.Type) Mapping.Map * (Datatypes.Tyname, string) Mapping.Map
a118 4
    infix 5 ->>
    fun key ->> value =
      (empty_type, Mapping.add ((key, value), empty_tyname, Types.tyname_eq)) :
      (Datatypes.Type, Datatypes.Type) Mapping.Map * (Datatypes.Tyname, string) Mapping.Map
a119 7
    val empty_pair = (empty_type, empty_tyname)

    infix 4 plus
    fun (m1, m2) plus (m3, m4) =
      (Mapping.plus(m1, m3, type_eq), Mapping.plus(m2, m4, Types.tyname_eq))
  end

d156 4
a159 1
		 if length < (length' + 1) then
a160 2
		 else
		   (IdentPrint.printStrId strid ^ ".") :: namelist'
d164 1
d166 1
d168 1
a168 1
              Datatypes.METATYNAME(ref (Datatypes.NULL_TYFUN id),s,n,b,ve)
d170 1
a170 1
                Datatypes.METATYNAME(ref (Datatypes.NULL_TYFUN id),s,n,b,ve)
d174 4
a177 4
            | (NO,tyfun_id,tyname') =>
                if Types.tyname_eq (tyname,tyname')
                  then YES tyfun_id
                else NO)
d180 1
d183 2
a184 2
            | YES tyfun_id => 
                check (namelist,strid,str,make_dummy_tyname (tyfun_id,tyname))
d192 1
a192 1
      fun check (NO, tycon, (Datatypes.TYSTR(Datatypes.ETA_TYFUN tyname', _))) =
d197 12
d210 1
a210 1
	| check(YES tycon, _, _) = YES tycon
d220 7
a226 6
  fun check_tyname (env, (map1,map2), tyname, name) = 
    Mapping.lookup(tyname,map2)
    handle Mapping.Lookup =>
      (case searchE(env, tyname) of
	 [] => name ^ "(hidden)"
       | namelist => implode namelist)
d236 22
a257 18
  fun complete_tycons (env, m, t as Datatypes.METATYVAR(ref (x, ty),  eq, imp)) =
      ((Mapping.lookup(t, first m), m)
       handle Mapping.Lookup =>
       let
	 val (ty', m') = complete_tycons (env, m, ty)
	 val t' = Datatypes.METATYVAR(ref (x, ty'), eq, imp)
       in
	 (t', t --> t' plus m')
       end)
    | complete_tycons (env, m, t as Datatypes.META_OVERLOADED(ref ty,id)) =
      ((Mapping.lookup(t, first m), m)
       handle Mapping.Lookup =>
       let
	 val (ty', m') = complete_tycons (env, m, ty)
	 val t' = Datatypes.META_OVERLOADED(ref ty',id)
       in
	 (t', t --> t' plus m') 
       end)
d271 1
a271 1
	    (lab |-> ty' ++ fields, m')
a272 1

d301 1
a301 1
  and change_name (env, m, tyname) =
d307 1
d309 1
a309 1
	  (tyname',tyname ->> name' plus m)
d316 1
d318 1
a318 1
	  (tyname', tyname ->> name' plus m)
a320 36
(*
    case tyname of

      Datatypes.METATYNAME(ref(Datatypes.TYFUN(ty, x)), name, arity, ref eq, ref valenv) =>
	let
	  val (ty', m') = complete_tycons(env, m, ty)
	in
	  (Datatypes.METATYNAME(ref (Datatypes.TYFUN(ty', x)), name, arity, ref eq, ref valenv),
	   m')
	end

    | Datatypes.METATYNAME{1=ref(Datatypes.ETA_TYFUN tyname'), ...} =>
	let
	  val (tyname'', m') = change_name (env, m, tyname')
	in
	  (tyname'', m')
	end

    | Datatypes.METATYNAME(ref (Datatypes.NULL_TYFUN id), name, arity, ref eq, ref valenv) =>
	let
	  val name' = check_tyname(env, m, tyname, name)
	  val tyname' = Datatypes.METATYNAME(ref (Datatypes.NULL_TYFUN id), name', arity, ref eq,
				   ref valenv)
	in
	  (tyname', tyname ->> name' plus m)
	end

    | Datatypes.TYNAME(id, name, arity, ref eq, ref valenv,location) =>
	let
	  val name' = check_tyname(env, m, tyname, name)
	  val tyname' = Datatypes.TYNAME(id, name', arity, ref eq, ref valenv,location)
	in
	  (tyname', tyname ->> name' plus m)
	end
*)

d326 1
a326 1
    fn (env, ty) => first(complete_tycons(env, empty_pair, ty))
d336 1
a336 1
      Types.print_type options ty'
d340 1
a340 1
    Types.print_name options (first(change_name (env,empty_pair,tyname)))
@


1.14
log
@Trivia
@
text
@d4 3
d69 1
a69 1
  structure Info = Types.Info
@


1.13
log
@Fixed problem with completing tynames
@
text
@d4 3
a45 1
require "completion";
d47 1
d49 2
a50 1
require "../utils/lists";
d59 1
a64 1
  structure Mapping = Datatypes.Mapping
d67 1
@


1.12
log
@Reinstated code that ensured that the same tyvar always printed the same
@
text
@d264 18
d314 1
@


1.11
log
@Various tidyings and mucking around.  This file needs rewriting.
@
text
@d4 3
d207 1
a207 2
	 (* (t', t --> t' plus m') *)
	 (t', m')
d216 1
a216 2
	 (* (t', t --> t' plus m') *)
	 (t', m')
a285 1
(*
a286 2
*)
	  (tyname', m)
a293 1
(*
a294 3
*)
	  (tyname', m)

@


1.10
log
@Changes for COPYSTR's
This is grossly inefficient and must be fixed.
@
text
@d4 4
a41 1
require "../typechecker/environment";
a49 1
                    structure Env : ENVIRONMENT
a52 1
                    sharing Env.Datatypes = Types.Datatypes
d57 2
d61 2
a62 1
  open Datatypes
d84 1
a84 1
      (Type, Type) Mapping.Map * (Tyname, string) Mapping.Map
d89 1
a89 1
      (Type, Type) Mapping.Map * (Tyname, string) Mapping.Map
d109 1
a109 1
  fun searchE (ENV(strenv, tyenv, _, _), tyname) =
d120 1
a120 1
  and searchSE (SE mapping, tyname) =
d122 2
a123 2
      fun check ([], strid, (STR(_,_,E))) =
	  (case searchE(E, tyname) of
d125 5
a129 5
	   | name_list => (IdentPrint.printStrId strid ^ ".") :: name_list)
	| check (name_list, strid, (STR(_,_,E))) =
	  (case searchE(E, tyname) of
	     [] => name_list
	   | name_list' =>
d131 2
a132 2
		 val length  = Lists.length name_list
		 val length' = Lists.length name_list'
d135 1
a135 1
		   name_list
d137 1
a137 1
		   (IdentPrint.printStrId strid ^ ".") :: name_list'
d139 21
a159 3
        (* this should do something more sensible *)(* HACK *)
        | check (namelist,strid,str) =
          check (namelist,strid,Env.expand_str str)
d161 1
a161 1
      NewMap.fold check ([], (*strid_str_list*)mapping)
d164 1
a164 1
  and searchTE (TE mapping, tyname) =
d166 1
a166 1
      fun check (NO, tycon, (TYSTR(ETA_TYFUN tyname', _))) =
d182 2
a183 4
  type mpair = (Type, Type) Mapping.Map * (Tyname, string) Mapping.Map

  fun check_tyname (E, m : mpair, tyname, name) = 
    Mapping.lookup(tyname, #2 m)
d185 1
a185 1
      (case searchE(E, tyname) of
d187 1
a187 1
       | name_list => implode name_list)
d197 2
a198 2
  fun complete_tycons (E, m, t as METATYVAR(ref (x, ty),  eq, imp)) =
      ((Mapping.lookup(t, #1 m), m)
d201 2
a202 2
	 val (ty', m') = complete_tycons (E, m, ty)
	 val t' = METATYVAR(ref (x, ty'), eq, imp)
d204 2
a205 1
	 (t', t --> t' plus m')
d207 2
a208 2
    | complete_tycons (E, m, t as META_OVERLOADED(ref ty,id)) =
      ((Mapping.lookup(t, #1 m), m)
d211 2
a212 2
	 val (ty', m') = complete_tycons (E, m, ty)
	 val t' = META_OVERLOADED(ref ty',id)
d214 2
a215 1
	 (t', t --> t' plus m')
d217 2
a218 2
    | complete_tycons (E, m, ty as (TYVAR _)) = (ty, m)
    | complete_tycons (E, m, METARECTYPE (ref (level, flex, ty, eq, imp))) =
d220 1
a220 1
	val (ty', m') = complete_tycons (E, m, ty)
d222 1
a222 1
	(METARECTYPE(ref (level, flex, ty, eq, imp)), m')
d224 1
a224 1
    | complete_tycons (E, m, RECTYPE fields) =
d228 1
a228 1
	    val (ty', m') = complete_tycons(E, m, ty)
d235 1
a235 1
	(RECTYPE fields', m')
d237 1
a237 1
    | complete_tycons (E, m, FUNTYPE(ty1, ty2)) =
d239 2
a240 2
	val (ty1', m1) = complete_tycons(E, m , ty1)
	val (ty2', m2) = complete_tycons(E, m1, ty2)
d242 1
a242 1
	(FUNTYPE(ty1', ty2'), m2)
d244 1
a244 1
    | complete_tycons (E, m, CONSTYPE(type_list, tyname)) =
d248 1
a248 1
	    val (ty', m2) = complete_tycons(E, m1, ty)
d253 1
a253 1
	val (tyname', m') = change_name (E, m, tyname)
d256 1
a256 1
	(CONSTYPE(type_list', tyname'), m'')
d258 2
a259 2
    | complete_tycons (E, m, ty as (DEBRUIJN _)) = (ty, m)
    | complete_tycons (E, m, ty as NULLTYPE) = (ty, m)
d261 1
a261 1
  and change_name (E, m, tyname) =
d264 1
a264 1
      METATYNAME(ref(TYFUN(ty, x)), name, arity, ref eq, ref valenv) =>
d266 1
a266 1
	  val (ty', m') = complete_tycons(E, m, ty)
d268 1
a268 1
	  (METATYNAME(ref (TYFUN(ty', x)), name, arity, ref eq, ref valenv),
d272 1
a272 1
    | METATYNAME{1=ref(ETA_TYFUN tyname'), ...} =>
d274 1
a274 1
	  val (tyname'', m') = change_name (E, m, tyname')
d279 1
a279 1
    | METATYNAME(ref (NULL_TYFUN id), name, arity, ref eq, ref valenv) =>
d281 2
a282 2
	  val name' = check_tyname(E, m, tyname, name)
	  val tyname' = METATYNAME(ref (NULL_TYFUN id), name', arity, ref eq,
d285 1
d287 2
d291 1
a291 1
    | TYNAME(id, name, arity, ref eq, ref valenv,location) =>
d293 2
a294 2
	  val name' = check_tyname(E, m, tyname, name)
	  val tyname' = TYNAME(id, name', arity, ref eq, ref valenv,location)
d296 1
d298 3
d308 1
a308 1
    fn (E, ty) => #1(complete_tycons(E, empty_pair, ty))
d314 1
a314 1
  fun print_type options E ty =
d316 1
a316 1
      val ty' = complete_tycons (E, ty)
d321 2
@


1.9
log
@Anel's last changes
@
text
@d4 3
d38 1
a38 1
require "../typechecker/datatypes";
d46 7
a52 6
functor Completion (
  structure Types : TYPES
  structure Lists : LISTS
  structure IdentPrint : IDENTPRINT
    sharing IdentPrint.Ident = Types.Datatypes.Ident
): COMPLETION =
d118 1
a118 1
      fun check ([], strid, (STR(_, E))) =
d122 1
a122 1
	| check (name_list, strid, (STR(_, E))) =
d135 3
@


1.8
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d179 1
a179 1
    | complete_tycons (E, m, t as META_OVERLOADED(ref ty)) =
d184 1
a184 1
	 val t' = META_OVERLOADED(ref ty')
@


1.7
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d39 6
a44 12
functor Completion
  (structure Datatypes : DATATYPES

   structure IdentPrint : IDENTPRINT
   sharing IdentPrint.Ident = Datatypes.Ident

   structure Types : TYPES
   sharing Types.Datatypes = Datatypes

   structure Lists : LISTS)

     : COMPLETION =
d47 2
a48 1
  structure Datatypes = Datatypes
d274 1
a274 1
  fun print_type E ty =
d278 1
a278 1
      Types.print_type ty'
@


1.6
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d257 1
a257 1
    | TYNAME(id, name, arity, ref eq, ref valenv) =>
d260 1
a260 1
	  val tyname' = TYNAME(id, name', arity, ref eq, ref valenv)
@


1.5
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d95 4
a98 4
  fun searchE (ENV(strenv, tyenv, _, _)) tyname =
    case (searchTE tyenv tyname) of
      YES(tycon) => [IdentPrint.printTyCon tycon]
    | NO => searchSE strenv tyname
d106 1
a106 1
  and searchSE (SE mapping) tyname =
d108 2
a109 3
      val strid_str_list = NewMap.to_list mapping
      fun check (strid,(STR(_, E))) [] =
	  (case (searchE E tyname) of
d112 2
a113 2
	| check (strid,(STR(_, E))) name_list =
	  (case (searchE E tyname) of
d126 1
a126 2
(*      Mapping.Fold check [] mapping*)
      Lists.foldl check [] strid_str_list
d129 1
a129 1
  and searchTE (TE mapping) tyname =
d131 7
a137 8
      val tycon_tystr_list = NewMap.to_list mapping
      fun check (tycon,(TYSTR(ETA_TYFUN tyname', _))) NO =
	  if Types.tyname_eq(tyname, tyname') then
	    YES tycon
	  else
	    NO
	| check _ NO = NO
	| check _ (YES tycon) = YES tycon
d139 1
a139 2
(*      Mapping.Fold check NO mapping*)
      Lists.foldl check NO tycon_tystr_list
d152 1
a152 1
      (case (searchE E tyname) of
@


1.4
log
@Removed references to Lists.foldl and Lists.foldr
@
text
@d4 3
d105 2
a106 1
      fun check strid (STR(_, E)) [] =
d110 1
a110 1
	| check strid (STR(_, E)) name_list =
d124 2
a125 1
      Mapping.Fold check [] mapping
d130 2
a131 1
      fun check tycon (TYSTR(ETA_TYFUN tyname', _)) NO =
d133 1
a133 1
	    YES(tycon)
d136 2
a137 4
	| check _ _ NO =
	  NO
	| check _ _ (YES tycon) =
	  YES(tycon)
d139 2
a140 1
      Mapping.Fold check NO mapping
@


1.3
log
@Update to allow valenv in METATYNAME
@
text
@d4 3
d207 1
a207 1
	fun f ty (ty_list, m1) =
d215 1
a215 1
	val (type_list', m'') = Lists.foldr f ([], m') type_list
@


1.2
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_completion.sml,v $
d222 1
a222 1
      METATYNAME(ref (TYFUN(ty, x)), name, arity, ref eq) =>
d226 2
a227 1
	  (METATYNAME(ref (TYFUN(ty', x)), name, arity, ref eq), m')
d230 1
a230 1
    | METATYNAME(ref (ETA_TYFUN tyname'), _, _, _) =>
d237 1
a237 1
    | METATYNAME(ref (NULL_TYFUN id), name, arity, ref eq) =>
d240 2
a241 1
	  val tyname' = METATYNAME(ref (NULL_TYFUN id), name', arity, ref eq)
@


1.1
log
@Initial revision
@
text
@d1 1
d3 5
a7 1
$Log$
@
