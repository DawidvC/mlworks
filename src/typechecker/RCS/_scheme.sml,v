head	1.66;
access;
symbols
	MLW_daveb_inline_1_4_99:1.66.1
	MLWorks_21c0_1999_03_25:1.66
	MLWorks_20c1_1998_08_20:1.66
	MLWorks_20c0_1998_08_04:1.66
	MLWorks_20b2c2_1998_06_19:1.66
	MLWorks_20b2_Windows_1998_06_12:1.66
	MLWorks_20b1c1_1998_05_07:1.66
	MLWorks_20b0_1998_04_07:1.66
	MLWorks_20b0_1998_03_20:1.66
	MLWorks_20m2_1998_02_16:1.65
	MLWorks_20m1_1997_10_23:1.64
	MLWorks_11r1:1.64.5.1.1.1.1
	MLWorks_workspace_97:1.64.7
	MLWorks_dt_wizard:1.64.6
	MLWorks_11c0_1997_09_09:1.64.5.1.1.1
	MLWorks_10r3:1.64.5.1.3
	MLWorks_10r2_551:1.64.5.1.2
	MLWorks_11:1.64.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.64.5.1
	MLWorks_20m0_1997_06_20:1.64
	MLWorks_1_0_r2c2_1997_06_14:1.64.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.64.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.64.5
	MLWorks_BugFix_1997_04_24:1.64
	MLWorks_1_0_r2_Win32_1997_04_11:1.64
	MLWorks_1_0_r2_Unix_1997_04_04:1.64
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.64.3.1.1
	MLWorks_gui_1996_12_18:1.64.4
	MLWorks_1_0_Win32_1996_12_17:1.64.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.64.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.64.1.1
	MLWorks_1_0_Irix_1996_11_28:1.64.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.64.2
	MLWorks_1_0_Unix_1996_11_14:1.64.1
	MLWorks_Open_Beta2_1996_10_11:1.62.2
	MLWorks_License_dev:1.62.1
	MLWorks_1_open_beta_1996_09_13:1.61.1
	MLWorks_Open_Beta_1996_08_22:1.61
	MLWorks_Beta_1996_07_02:1.58
	MLWorks_Beta_1996_06_07:1.58
	MLWorks_Beta_1996_06_06:1.58
	MLWorks_Beta_1996_06_05:1.58
	MLWorks_Beta_1996_06_03:1.58
	MLWorks_Beta_1996_05_31:1.58
	MLWorks_Beta_1996_05_30:1.58
	ML_beta_release_12/08/94:1.43
	ML_beta_release_03/08/94:1.43
	ML_revised_beta_release_25/05/94:1.41
	ML_final_beta_release_02/03/94:1.40
	mlworks-28-01-1994:1.39
	Release:1.35
	mlworks-beta-01-09-1993:1.35
	MLWorks-1-0-4-29/01/1993:1.26
	MLWorks-1-0-3-21/12/1992:1.25
	MLWorks-1-0-2-15/12/1992:1.24
	MLWorks-1-0-1-04/12/1992:1.22
	checkpoint_17_08_92:1.12
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.66
date	98.02.19.16.42.17;	author mitchell;	state Exp;
branches
	1.66.1.1;
next	1.65;

1.65
date	98.02.02.16.26.42;	author mitchell;	state Exp;
branches;
next	1.64;

1.64
date	96.11.06.11.33.21;	author matthew;	state Exp;
branches
	1.64.1.1
	1.64.2.1
	1.64.3.1
	1.64.4.1
	1.64.5.1
	1.64.6.1
	1.64.7.1;
next	1.63;

1.63
date	96.10.29.13.49.19;	author io;	state Exp;
branches;
next	1.62;

1.62
date	96.09.24.10.02.29;	author matthew;	state Exp;
branches
	1.62.1.1
	1.62.2.1;
next	1.61;

1.61
date	96.08.20.12.32.44;	author andreww;	state Exp;
branches
	1.61.1.1;
next	1.60;

1.60
date	96.08.06.13.24.30;	author andreww;	state Exp;
branches;
next	1.59;

1.59
date	96.07.03.15.29.52;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	96.05.07.10.40.58;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	96.04.30.17.42.39;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	96.04.29.13.40.11;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	96.03.19.15.52.30;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	96.03.08.12.18.02;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	96.02.26.16.23.24;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	96.02.22.15.20.31;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	96.02.21.13.16.14;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	95.12.27.11.32.55;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	95.12.18.12.43.22;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	95.11.02.11.57.32;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	95.05.11.11.45.36;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	95.03.24.12.02.26;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	95.02.13.17.09.08;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	95.01.30.11.54.15;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	94.07.01.14.40.42;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	94.06.17.16.52.36;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	94.05.11.14.26.33;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	94.02.21.22.42.19;	author nosa;	state Exp;
branches;
next	1.39;

1.39
date	93.12.03.15.49.37;	author nickh;	state Exp;
branches;
next	1.38;

1.38
date	93.11.30.14.50.16;	author nickh;	state Exp;
branches;
next	1.37;

1.37
date	93.11.24.17.29.52;	author nickh;	state Exp;
branches;
next	1.36;

1.36
date	93.09.23.12.22.01;	author nosa;	state Exp;
branches;
next	1.35;

1.35
date	93.05.21.15.34.35;	author matthew;	state Exp;
branches
	1.35.1.1;
next	1.34;

1.34
date	93.05.18.18.11.59;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	93.04.20.09.26.14;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	93.04.08.16.22.01;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	93.04.01.16.43.37;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	93.03.15.13.45.58;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.03.05.14.12.02;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.03.02.16.12.42;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.02.22.15.45.48;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	92.12.22.15.32.01;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	92.12.18.15.49.53;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	92.12.10.11.28.17;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	92.12.04.19.24.46;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	92.12.04.14.16.31;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	92.12.03.20.24.39;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	92.12.01.15.47.44;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	92.11.30.10.32.24;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.11.26.19.54.43;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	92.11.25.15.12.16;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.10.30.15.26.31;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.10.02.14.37.08;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	92.09.08.13.36.16;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.08.27.19.56.58;	author davidt;	state Exp;
branches;
next	1.12;

1.12
date	92.08.13.17.19.18;	author davidt;	state Exp;
branches;
next	1.11;

1.11
date	92.08.11.17.50.43;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.07.28.14.49.47;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.07.16.18.57.45;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.06.16.15.48.19;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.06.16.08.21.17;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.03.27.10.42.07;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.01.27.20.14.45;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.01.24.16.14.32;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.21.16.46.53;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.10.08.17.37.52;	author davidt;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.37.32;	author colin;	state Exp;
branches;
next	;

1.35.1.1
date	93.05.21.15.34.35;	author jont;	state Exp;
branches;
next	;

1.61.1.1
date	96.09.13.11.41.09;	author hope;	state Exp;
branches;
next	;

1.62.1.1
date	96.10.07.16.34.11;	author hope;	state Exp;
branches;
next	;

1.62.2.1
date	96.10.17.11.53.20;	author hope;	state Exp;
branches;
next	;

1.64.1.1
date	96.11.14.13.20.55;	author hope;	state Exp;
branches
	1.64.1.1.1.1;
next	;

1.64.1.1.1.1
date	96.11.28.15.31.55;	author hope;	state Exp;
branches;
next	;

1.64.2.1
date	96.11.22.18.38.41;	author hope;	state Exp;
branches;
next	;

1.64.3.1
date	96.12.17.18.17.41;	author hope;	state Exp;
branches
	1.64.3.1.1.1;
next	;

1.64.3.1.1.1
date	97.02.24.12.11.57;	author hope;	state Exp;
branches;
next	;

1.64.4.1
date	96.12.18.10.12.58;	author hope;	state Exp;
branches;
next	;

1.64.5.1
date	97.05.12.10.51.16;	author hope;	state Exp;
branches
	1.64.5.1.1.1
	1.64.5.1.2.1
	1.64.5.1.3.1;
next	;

1.64.5.1.1.1
date	97.07.28.18.34.37;	author daveb;	state Exp;
branches
	1.64.5.1.1.1.1.1;
next	;

1.64.5.1.1.1.1.1
date	97.10.07.12.00.28;	author jkbrook;	state Exp;
branches;
next	;

1.64.5.1.2.1
date	97.09.08.17.27.31;	author daveb;	state Exp;
branches;
next	;

1.64.5.1.3.1
date	97.09.09.14.24.29;	author daveb;	state Exp;
branches;
next	;

1.64.6.1
date	97.09.10.19.43.25;	author brucem;	state Exp;
branches;
next	;

1.64.7.1
date	97.09.11.21.10.52;	author daveb;	state Exp;
branches;
next	;

1.66.1.1
date	99.04.01.18.09.08;	author daveb;	state Exp;
branches;
next	;


desc
@Type Schemes 
(datatype defined in datatypes)
@


1.66
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _scheme.sml the functor *)
(*
$Log: _scheme.sml,v $
 * Revision 1.65  1998/02/02  16:26:42  mitchell
 * [Bug #50006]
 * Fix is_polymorphic for Debruijn variables
 *
 * Revision 1.64  1996/11/06  11:33:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.63  1996/10/29  13:49:19  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.62  1996/09/24  10:02:29  matthew
 * Adding monotype instantiations of metatyvars in signature matching
 *
 * Revision 1.61  1996/08/20  12:32:44  andreww
 * [Bug #1522]
 * Modified the signature matching error message to report if a free
 * (explicit) type variable was trying to match a bound type var.
 *
 * Revision 1.60  1996/08/06  13:24:30  andreww
 * [Bug #1521]
 * Propagating changes to _types.sml and _completion.sml
 * and dividing the dynamic_generalises function into two:
 * one for sml'90 and one for sml'96 (to take into account the
 * differences in treatment of "imperative" variables.
 *
 * Revision 1.59  1996/07/03  15:29:52  jont
 * Change check for free imperative type variables to return
 * the full type as well as the type variable
 *
 * Revision 1.58  1996/05/07  10:40:58  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.57  1996/04/30  17:42:39  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.56  1996/04/29  13:40:11  matthew
 * Integer changes
 *
 * Revision 1.55  1996/03/19  15:52:30  matthew
 * Adding option for value polymorphism
 *
 * Revision 1.54  1996/03/08  12:18:02  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
 * Revision 1.53  1996/02/26  16:23:24  matthew
 * Improve message about imperative type variables
 *
 * Revision 1.52  1996/02/22  15:20:31  jont
 * Replacing Map with NewMap
 *
 * Revision 1.51  1996/02/21  13:16:14  daveb
 * Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
 * some functionality to the Shell structure.
 *
 * Revision 1.50  1995/12/27  11:32:55  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.49  1995/12/18  12:43:22  matthew
Changing error behaviour for unresolved records.

Revision 1.48  1995/11/02  11:57:32  matthew
Adding (optional) support for value polymorphism

Revision 1.47  1995/05/11  11:45:36  matthew
Improving error messages

Revision 1.46  1995/03/24  12:02:26  matthew
Use Stamp instead of Tyname_id etc.

Revision 1.45  1995/02/13  17:09:08  matthew
Debugger stuff

Revision 1.44  1995/01/30  11:54:15  matthew
Rationalizing debugger

Revision 1.43  1994/07/01  14:40:42  jont
Fix error messages for attempted unification during signature matching

Revision 1.42  1994/06/17  16:52:36  jont
Allow alternative printing of types to include quantifiers

Revision 1.41  1994/05/11  14:26:33  daveb
New overloading scheme.

Revision 1.40  1994/02/21  22:42:19  nosa
Only return real instance of type variables in Modules Debugger.

Revision 1.39  1993/12/03  15:49:37  nickh
Removed dead code, removed colons in an error message.

Revision 1.38  1993/11/30  14:50:16  nickh
Marked certain error messages as "impossible".

Revision 1.37  1993/11/24  17:29:52  nickh
Added code to encode type errors as a list of strings and types.

Revision 1.36  1993/09/23  12:22:01  nosa
Typechecker now records instances in closed-over type variables
for polymorphic debugger.

Revision 1.35  1993/05/21  15:34:35  matthew
Removed output statement

Revision 1.34  1993/05/18  18:11:59  jont
Removed integer parameter

Revision 1.33  1993/04/20  09:26:14  matthew
 Added generalises_map and apply_instantiation functions

Revision 1.32  1993/04/08  16:22:01  matthew
Changed type generalisation test from using unification to using the
a type variable mapping.
This needs better treatment of error messages.

Revision 1.31  1993/04/01  16:43:37  jont
Allowed overloading on strings to be controlled by an option

Revision 1.30  1993/03/15  13:45:58  matthew
Changed error message for record mismatch
Stopped raising error for unresolved overloading
This should be controlled by an option really

Revision 1.29  1993/03/05  14:12:02  matthew
Options & Info changes

Revision 1.28  1993/03/02  16:12:42  matthew
Rationalised use of Mapping structure

Revision 1.27  1993/02/22  15:45:48  matthew
Added Completion parameter

Revision 1.26  1992/12/22  15:32:01  jont
Anel's last changes

Revision 1.25  1992/12/18  15:49:53  matthew
Propagating options to signature matching error messages.

Revision 1.24  1992/12/10  11:28:17  matthew
Expanded structure does not match signature errors.

Revision 1.23  1992/12/04  19:24:46  matthew
Error message revisions.

Revision 1.22  1992/12/04  14:16:31  matthew
Error message revision

Revision 1.21  1992/12/03  20:24:39  matthew
Changes to error messages.
Fixed problem of silent error in scheme_generalises

Revision 1.20  1992/12/01  15:47:44  matthew
Changed handling of overloaded variable errors.

Revision 1.19  1992/11/30  10:32:24  jont
Further improvements to gather_names

Revision 1.18  1992/11/26  19:54:43  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.17  1992/11/25  15:12:16  jont
Redid instance to make sub_vec constant and remove a parameter

Revision 1.16  1992/10/30  15:26:31  jont
Added special maps for tyfun_id, tyname_id, strname_id

Revision 1.15  1992/10/02  14:37:08  matthew
Fixed problem with printing record domains.

Revision 1.14  1992/09/08  13:36:16  jont
Modified gather_names to be simpler

Revision 1.13  1992/08/27  19:56:58  davidt
Yet more changes to get structure copying working better.

Revision 1.12  1992/08/13  17:19:18  davidt
Changed tyvars function to take a tuple of arguments.

Revision 1.11  1992/08/11  17:50:43  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.10  1992/07/28  14:49:47  jont
Removed use of Array parameter to allow pervasive Array to be used

Revision 1.9  1992/07/16  18:57:45  jont
Changed to use btrees for renaming of tynames and strnames

Revision 1.8  1992/06/16  15:48:19  clive
Added the printing of the name of the relevant identifier in a couple of error messages

Revision 1.7  1992/06/16  08:21:17  jont
Modifications to sort out unification of flexible record types in order
to provide full information to the lambda translation

Revision 1.6  1992/03/27  10:42:07  jont
Changed call of type_equalityp to call of tyvar_erqualityp in order to
preserve significance of the equality attribute of type variables.

Revision 1.5  1992/01/27  20:14:45  jont
Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons

Revision 1.4  1992/01/24  16:14:32  jont
Updated to allow valenv in METATYNAME

Revision 1.3  1991/11/21  16:46:53  jont
Added copyright message

Revision 1.2  91/10/08  17:37:52  davidt
Put in a catch-all and Crash.impossible to avoid a match
not exhaustive warning.

Revision 1.1  91/06/07  11:37:32  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";
require "^.basis.__list";
require "../utils/set";
require "../utils/lists";
require "../utils/print";
require "../utils/crash";
require "../main/info";
require "../basics/identprint";
require "../typechecker/scheme";
require "../typechecker/types";
require "../typechecker/completion";

functor Scheme(
  structure Set : SET
  structure Lists : LISTS
  structure Info : INFO
  structure IdentPrint : IDENTPRINT
  structure Types : TYPES
  structure Print : PRINT
  structure Crash : CRASH
  structure Completion : COMPLETION

  sharing Info.Location = IdentPrint.Ident.Location
  sharing Types.Options = IdentPrint.Options = Completion.Options
  sharing Types.Datatypes = Completion.Datatypes
  sharing IdentPrint.Ident = Types.Datatypes.Ident
    ) : TYPESCHEME =
  struct
    structure Datatypes = Types.Datatypes
    structure Options = Types.Options
    structure Set = Set
    structure Location = Info.Location

    type print_options = Options.print_options
    type error_info = Info.options
    open Datatypes

    exception EnrichError of string

    fun err_valid (Options.OPTIONS{print_options,...}, vname) = 
      Err_String (IdentPrint.printValId print_options vname)

    (****
     Non closed over metavariable remains as a metavariable, while closed over
     metavariable becomes a debruijn.
     ****)    

    local 

      fun stack_depth [] = 0
	| stack_depth ((_,DEBRUIJN(n,_,_,_))::_) = n+1
	| stack_depth _ = Crash.impossible "Scheme.stack_depth"

      fun generalise (error_info,options, location) (subfun,ty) = 
        let
          fun generalise (t as (TYVAR(_))) = subfun t
            | generalise (t as (METATYVAR (ref (_,NULLTYPE,_),_,_))) = subfun t
            | generalise (METATYVAR (ref (_,ty,_),_,_)) =
              generalise ty
            | generalise (ty as META_OVERLOADED {1=ref NULLTYPE,...}) = ty
            | generalise (META_OVERLOADED {1=ref ty,...}) = generalise ty
            | generalise (METARECTYPE (ref (_,true,ty as METARECTYPE _,_,_))) = 
              generalise ty
            | generalise (ty as METARECTYPE (ref (_,true,subty,_,_))) = 
              (Info.error error_info
               (Info.RECOVERABLE,
                location,
                "Unresolved flexible record of type " ^
                Types.print_type options ty);
               generalise subty)
            | generalise (METARECTYPE (ref (_,_,ty,_,_))) = 
              generalise ty
            | generalise ((RECTYPE amap)) =
              RECTYPE (NewMap.map generalise_map amap)
            | generalise (FUNTYPE(arg,res)) =
              FUNTYPE (generalise arg,generalise res)
            | generalise (CONSTYPE (tylist,tyname)) =
              CONSTYPE (map generalise tylist,tyname)
            | generalise (ty as DEBRUIJN _) = Crash.impossible ("impossible type error 15: debruijn ")
            | generalise (ty as NULLTYPE) = ty

	  and generalise_map(_, ty) = generalise ty

        in
          generalise ty
        end

      (* accumulate instances for polymorphic debugger *)
      fun make_new_instance instance tyvar = 
        case instance of
          NONE => ()
        (* instance is a ref *)
        | SOME (instance,_) => 
            let 
              val tyvar_info =
                case tyvar of
                  (METATYVAR (info,_,_)) => info
                | (TYVAR (info,_)) => info
                | _ => Crash.impossible "tyvar_info:make_new_instance:scheme"
            in
              (* Add the extracted tyvar info, if not present *)
              case !instance of
                NO_INSTANCE => instance := INSTANCE([tyvar_info])
              | INSTANCE tyvars =>
                  if Lists.member(tyvar_info,tyvars) then ()
                  else 
                    instance := INSTANCE(tyvar_info::tyvars)
              | _ => Crash.impossible "make_new_instance:scheme"
            end

      (* Substitute for a tyvar * debruijn assoc list *)
      (* newinstance is either the function above or the unit function *)
      fun subst new_instance (subst_list,tyvar) = 
        let
          fun subst ([],ty) = ty
            | subst (((atyvar'' as TYVAR (atyvar as _), adebruijn)::t),
                     ty as TYVAR atyvar') =
              if atyvar = atyvar' 
                then (ignore(new_instance atyvar'');
                      adebruijn)
              else 
                subst (t,ty)
            | subst (((tyvar as METATYVAR (x',_,_), adebruijn)::t),
                     ty as METATYVAR (x,_,_)) = 
              if x = x'
                then (ignore(new_instance tyvar);
                      adebruijn)
              else 
                subst (t,ty)
            | subst (((TYVAR _, _)::t),ty as METATYVAR _) = 
              subst (t,ty)
            | subst (((METATYVAR _, _)::t),ty as TYVAR _) = 
              subst (t,ty)
            | subst ((x,y)::t,ty) = Crash.impossible "Scheme.subst"
        in
          subst (subst_list,tyvar)
        end
	  
      fun make_subst_list options ([],n,substacc) = (n,substacc)
	| make_subst_list options (h::t,n,substacc) = 
	  let val new_debruijn = 
            DEBRUIJN (n,Types.tyvar_equalityp h,
                      Types.imperativep h,
                      case h of
                        METATYVAR(tyv,_,_) => SOME (tyv)
                      | TYVAR(tyv,_) => SOME (tyv)
                      | _ => Crash.impossible 
                          "new_debruijn:make_subst_list:scheme")
	  in
	    make_subst_list options (t,n+1,(h,new_debruijn) :: substacc)
	  end
    in 
      fun make_scheme' (error_info,options,location) ([],tyexp) = 
        UNBOUND_SCHEME (tyexp)
	(****
	 So in effect make_scheme already schemifies the type scheme when
	 the number of type variables are not zero.
	 ****)
	| make_scheme' (error_info,options,location)
                       (tylist,tyexp as (ty,instance)) = 
	  let 
            val (no_of_bound_vars,substlist) = 
                       make_subst_list options (tylist,0,[])
            val new_instance = make_new_instance instance
	  in
	    SCHEME (no_of_bound_vars,
		    (generalise (error_info,options,location)
                                (fn tyvar => subst new_instance 
                                                   (substlist,tyvar),
                                 ty),
                     instance))
	  end

      val default_values = (Info.make_default_options (),
                            Options.default_options,
                            Location.UNKNOWN)


      (* Generally this won't produce errors (I think) *)
      val make_scheme = make_scheme' default_values



      (****
       schemify is used when closing variable environments - type variables
       which can be closed over are substituted by debruijns.
       ****)
      fun schemify (error_info,options,location)
                   (alevel,exp_varp,
                    UNBOUND_SCHEME (atype as (atype',instance'')),
                    tyvars_scoped,asig) =
	let

          val Options.OPTIONS{compat_options=
                              Options.COMPATOPTIONS{old_definition,...},...}
            = options

	  (****
	   Scoping is done by levels - only explicit type variables scoped 
	   at the current level, alevel, can be closed over. 
	   ****)
	  fun levels_ok (avar as TYVAR (ref (var_level,_,_),id)) =
            var_level >= alevel
	    | levels_ok (avar as METATYVAR (ref (var_level,_,_),_,_)) =
              var_level >= alevel
	    | levels_ok _ = Crash.impossible "Scheme.levels_ok"

	  fun tyvarp (TYVAR _) = true
	    | tyvarp _ = false

	  fun extract_tyvar (TYVAR (_,atyvar)) = atyvar
	    | extract_tyvar _ = Crash.impossible "Scheme.extract_tyvar"

	  (****
	   valbind indicates that we are closing a VE that stems from the
	   elaboration of a valbind.
	   ****)
	  fun substp (avar,valbind) =
	    if valbind 
	      then
		(not (exp_varp andalso 
                      ((not old_definition) orelse Types.imperativep avar)))
		andalso
		(levels_ok avar)
		andalso
		(if tyvarp avar then
		   (Set.is_member (extract_tyvar (avar),tyvars_scoped))
		 else
		   true)
	    else 
	      true

          (****
	   Substitution function for schemify - debruijns are substituted
	   for type variables.
	   ****)

          val new_instance = make_new_instance instance''

	  val sub_stack = ref []

	  fun subfun (avar) =
	    if substp (avar,asig)
	      then
		let 
		  val stack = !sub_stack
		  val asub = subst (fn _ => ()) (!sub_stack,avar) 
		  fun debruijnp (DEBRUIJN _) = true
		    | debruijnp _ = false
		in
		  if debruijnp asub 
		    then asub
		  else
		    let 
		      val new_debruijn = 
			DEBRUIJN (stack_depth  stack,
				  Types.tyvar_equalityp avar,
                                  Types.imperativep avar,
                                  case avar of
                                    METATYVAR(tyv,_,_) => SOME (tyv)
                                  | TYVAR(tyv,_) => SOME (tyv)
                                  | _ => Crash.impossible "new_debruijn:subfun:scheme")
		    in
                      (new_instance avar;
                       sub_stack := (avar,new_debruijn)::stack;
                       new_debruijn)
		    end
		end
	    else avar

	  val scheme_type = (generalise (error_info,options,location) 
                                        (subfun,atype'),instance'')

	in
          SCHEME (stack_depth (!sub_stack),scheme_type)
	end
	| schemify _ _ = Crash.impossible "Scheme.schemify"

      (* Call this when we are reasonably confident no errors can arise *)
      val schemify' = schemify default_values
    end

    fun check_closure (use_value_polymorphism,atype,alevel,tyvars_scoped) =
      let
        fun levels_ok (avar as TYVAR (ref (var_level,_,_),id)) =
          var_level >= alevel
          | levels_ok (avar as METATYVAR (ref (var_level,_,_),_,_)) =
            var_level >= alevel
          | levels_ok _ = Crash.impossible "Scheme.levels_ok"

        fun tyvarp (TYVAR _) = true
          | tyvarp _ = false

        fun extract_tyvar (TYVAR (_,atyvar)) = atyvar
          | extract_tyvar _ = Crash.impossible "Scheme.extract_tyvar"

        fun check_var avar =
          not (use_value_polymorphism orelse Types.imperativep avar)
          andalso
          (levels_ok avar)
          andalso
          (if tyvarp avar then
             (Set.is_member (extract_tyvar (avar),tyvars_scoped))
           else
             true)

        exception CheckClosure of string

        fun check (t as (TYVAR _)) = check_var t
          | check (t as (METATYVAR (ref (_,NULLTYPE,_),_,_))) = check_var t
          | check (METATYVAR (ref (_,ty,_),_,_)) = check ty
          | check (META_OVERLOADED {1=ref NULLTYPE,...}) =
            raise CheckClosure ("Unresolved overloaded function")
          | check (META_OVERLOADED {1=ref ty,...}) = check ty
          | check (METARECTYPE (ref (_,true,ty as METARECTYPE _,_,_))) = check ty
          | check (ty as METARECTYPE (ref (_,true,_,_,_))) = 
            raise CheckClosure ("Unresolved flexible record of type ")
          | check (METARECTYPE (ref (_,_,ty,_,_))) = check ty
          | check (RECTYPE amap) = NewMap.forall check_forall amap
          | check (FUNTYPE(arg,res)) = check arg andalso check res
          | check (CONSTYPE (tylist,tyname)) = List.all check tylist
          | check (ty as DEBRUIJN _) = raise CheckClosure ("debruijn")
          | check (ty as NULLTYPE) = true

	and check_forall(_, ty) = check ty

      in
        check atype
      end

    fun unary_overloaded_scheme x =
      OVERLOADED_SCHEME (UNARY x)
    fun binary_overloaded_scheme x =
      OVERLOADED_SCHEME (BINARY x)
    fun predicate_overloaded_scheme x =
      OVERLOADED_SCHEME (PREDICATE x)

    (****
     instantiate returns the appropriate generic type given a scheme.
     ****)
    fun instantiate (_,UNBOUND_SCHEME (tyexp,instance),_,_) = 
      (tyexp,
       case instance of
         NONE => (ZERO,NONE)
       | SOME (instance,instance') =>
           case instance' of
             ref(instance' as SOME (ref (SIGNATURE_INSTANCE instance_info))) => 
               (instance_info,instance')
           | _ => (ZERO,SOME(instance)))
      | instantiate (_,OVERLOADED_SCHEME (UNARY (valid, tyvar)),loc,_) = 
	let
	  val olvar = META_OVERLOADED (ref NULLTYPE, tyvar, valid, loc)
	in
	  (FUNTYPE (olvar,olvar),(ZERO,NONE))
	end
      | instantiate (_,OVERLOADED_SCHEME (BINARY (valid, tyvar)),loc,_) = 
	let 
          val olvar = META_OVERLOADED (ref NULLTYPE, tyvar, valid, loc)
	in
	  (FUNTYPE (Types.add_to_rectype 
		   (Ident.LAB (Ident.Symbol.find_symbol ("1")),olvar,
		    Types.add_to_rectype 
		    (Ident.LAB (Ident.Symbol.find_symbol ("2")),olvar,
		     Types.empty_rectype)),olvar),
          (ZERO,NONE))
        end
      | instantiate (_,OVERLOADED_SCHEME (PREDICATE (valid, tyvar)),loc,_) = 
	let
	  val olvar = META_OVERLOADED (ref NULLTYPE, tyvar, valid, loc)
	in
	  (FUNTYPE (Types.add_to_rectype 
		   (Ident.LAB (Ident.Symbol.find_symbol("1")),olvar,
		    Types.add_to_rectype 
		    (Ident.LAB (Ident.Symbol.find_symbol("2")),olvar,
		     Types.empty_rectype)),Types.bool_type),
          (ZERO,NONE))
	end
      | instantiate (alevel,SCHEME (n,(tyexp,instance')),_,generate_moduler) =
	let
          val (instance',instance'') =
            case instance' of
              SOME (instance',ref instance'') => 
                (SOME instance',instance'')
            | _ => (NONE,NONE)

	  val sub_vec = MLWorks.Internal.Array.array(n, NULLTYPE)

	  fun instance_map(_, ty) = instance ty

	  and instance (t as (TYVAR _)) = t
	    | instance ((RECTYPE amap)) =
	      RECTYPE (NewMap.map instance_map amap)
	    | instance (FUNTYPE(arg,res)) =
	      FUNTYPE (instance (arg),instance (res))
	    | instance (CONSTYPE (tylist,tyname)) =
	      CONSTYPE (map instance tylist,tyname)
	    | instance (DEBRUIJN (n,eq,imp,tyvar)) = 
	      let 
		val asub = MLWorks.Internal.Array.sub (sub_vec,n)
	      in
		case asub of
		  NULLTYPE =>
		    let
		      val new_meta' = ref (alevel,NULLTYPE,NO_INSTANCE)
		      val new_meta = METATYVAR(new_meta',eq,imp)
                      (* accumulate instances for polymorphic debugger;
                         record every instance of the type variable *)
                      val _ =
                        case instance' of
                          NONE => ()
                        | SOME instance => 
                           (case !instance of
                              NO_INSTANCE => ()
                            | INSTANCE(_) =>
                                 (case tyvar of
                                    SOME (tyvar as ref(n,ty,instances)) => 
                                      tyvar := 
                                      (n,ty,INSTANCE(new_meta'::
                                       (case instances of
                                          NO_INSTANCE => nil
                                        | INSTANCE(instances) => instances
                                        | _ => Crash.impossible 
                                            "1:instance:instantiate:scheme")))
                                  | _ => Crash.impossible "2:instance:instantiate:scheme")
                            | _ => Crash.impossible "3:instance:instantiate:scheme")
		    in
		      (MLWorks.Internal.Array.update (sub_vec,n,new_meta);
		       new_meta)
		    end
		| _ => asub
	      end
	    | instance (NULLTYPE) =
	      Crash.impossible "impossible type error 16: nulltype in scheme"
	    | instance(t as  (METATYVAR (ref (_,ty,_),_,_))) =
	      (case ty of
		 NULLTYPE => t
	       | _ => instance ty)
	    | instance (t as (META_OVERLOADED {1=ref ty,...})) =
	      (case ty of
		 NULLTYPE => t
	       | _ => instance ty)
	    | instance (t as METARECTYPE (ref (_,b,ty,_,_))) =
	      if b then
		(case ty of
		   METARECTYPE _ => instance ty
		 | _ => t)
	      else
		ty
          val ty = instance (tyexp)

          (* Don't understand this stuff at all *)
          (* compute integer-instance to be eventually passed round at runtime 
             for the polymorphic debugger *)

          fun instance_length (NO_INSTANCE) = ZERO
            | instance_length (INSTANCE instances) = ONE (length(instances))
            | instance_length _ = Crash.impossible "length:instantiate:scheme"

          (* Yurk *)
          fun combine_instances (ZERO,inst) = inst
            | combine_instances (inst,ZERO) = inst
            | combine_instances (ONE n,ONE m) = TWO (n,m)
            | combine_instances _ = Crash.impossible "combine_instances"

          val length = 
            case instance' of
              NONE => ZERO
            | SOME instance => 
                (case !instance of
                   NO_INSTANCE => 
                     (case instance'' of
                        SOME (ref (SIGNATURE_INSTANCE instance_info)) => 
                          if generate_moduler 
                            then ZERO (* Why? *)
                          else instance_info
                      | _ => ZERO)
                 | INSTANCE((tyvar as ref(_,_,instances))::_) => 
                     (case instance'' of
                        SOME (ref (SIGNATURE_INSTANCE instance_info)) => 
                          if generate_moduler 
                            then instance_length instances (* Why? *)
                          else combine_instances (instance_info,instance_length instances)
                      | _ => instance_length instances)
                 | _ => Crash.impossible "instance:instantiate:scheme")
	in
           (ty,(length,case instance'' of
                         SOME (ref (SIGNATURE_INSTANCE _)) => instance''
                       | _ => instance'))
	end
      
      (****
       skolemize removes the quantifier from a type scheme - used in 
       enrichment.
       ****)
    fun skolemize (UNBOUND_SCHEME (atype,_)) = atype
      | skolemize (SCHEME (n,(atype,_))) = atype
      (****
       This should never occur because the only OVERLOADED_SCHEMEs are
       to be found in the initial basis.
       ****)
      | skolemize (OVERLOADED_SCHEME _) = Crash.impossible "Scheme.skolemize"

    (* This tells us if the scheme respects equality when considered as a type function *)
    (* hence the call to type_equalityp and not closed_type_equalityp *)
    fun equalityp (SCHEME (_,(FUNTYPE (atype,atype'),_))) = 
      Types.type_equalityp (atype)
      | equalityp (UNBOUND_SCHEME ((FUNTYPE (atype,atype'),_))) =
	Types.type_equalityp (atype)
      | equalityp (_) = true
	
    fun string_scheme (OVERLOADED_SCHEME (UNARY (_, tyvar))) = 
	  let val olvar = IdentPrint.printTyVar tyvar
	  in
	    concat ["ALL ", olvar, ".", olvar, " -> ", olvar]
	  end
      | string_scheme (OVERLOADED_SCHEME (BINARY (_, tyvar))) = 
	  let val olvar = IdentPrint.printTyVar tyvar
	  in
	    concat ["ALL ", olvar, ".", olvar, " * ", olvar, " -> ", olvar]
	  end
      | string_scheme (OVERLOADED_SCHEME (PREDICATE (_, tyvar))) = 
	  let val olvar = IdentPrint.printTyVar tyvar
	  in
	    concat ["ALL ", olvar, ".", olvar, " * ", olvar, " -> bool"]
	  end
      | string_scheme (UNBOUND_SCHEME (aty,_)) = 
	  "ALL{}." ^ (Types.extra_debug_print_type aty)
      | string_scheme (SCHEME (n,(aty,_))) =
	 "ALL{"^ (Int.toString n)^"}." ^ (Types.extra_debug_print_type aty)

    (* used to return an error from generalisation - should be better than this *)
    exception Error of Type * Type * string
    exception Mismatch

    fun internal_generalises_map isSML90 (ty1,ty2) =
      (* This function attempts to construct a mapping from the deBruijns
         of ty1 to the subtypes of ty2 such that the ty1 = ty2 under the
         mapping *)
      let
        (* put the debruijn bindings here *)
        val binding_list = ref []

        fun check_debruijn (stuff as (n,eq,imp,tyvar),ty) =
         (let val ty' = Lists.assoc (n,!binding_list)
          in
            if Types.type_eq (ty,ty',true,true)
              then ()
            (* Debruijns instantiated differently *)
            else raise Error (ty,ty',"types clash")
          end
          handle
          Lists.Assoc =>
            ((* need to check the equality and imperative attributes *)
             if eq andalso not(Types.closed_type_equalityp ty)
               then raise Error (DEBRUIJN stuff,ty,
                                 "equality attribute missing") 
             else ();
             if imp andalso isSML90
                    andalso not (Types.imperativep ty)
               then raise Error (DEBRUIJN stuff,ty,
                                 "imperative attribute missing") 
             else ();
             case tyvar of
               SOME (tyvar) =>
                 (* record the signature type corresponding to the structure *)
                 (* type variable as instance - crucial for application of the *)
                 (* polymorphic debugger to the modules language *)
                 (case tyvar of 
                    ref(n,t,instance) => 
                      tyvar := (n,t,
                                (case ty of
                                   DEBRUIJN(_,_,_,SOME(tyv)) => 
                                     (* prevent unneccessary duplication of tyvars *)
                                     if tyv = tyvar then 
                                       instance
                                     else
                                       INSTANCE (tyv::
                                                 (case instance of
                                                    NO_INSTANCE => nil
                                                  | INSTANCE(instances) => instances
                                                  | _ => Crash.impossible "2:check_debruijn:scheme"))
                                 | DEBRUIJN _ => instance
                                 | _ => INSTANCE(ref(0,ty,NO_INSTANCE)::
                                                 (case instance of
                                                    NO_INSTANCE => nil
                                                  | INSTANCE(instances) => instances
                                                  | _ => Crash.impossible "2:check_debruijn:scheme")))))
             | _ => ();
             binding_list := (n,ty)::(!binding_list)))

        fun type_strip(ty as METATYVAR(ref(_, ty',_), _, _)) =
          (case ty' of
             NULLTYPE => ty
           | _ => type_strip ty')
          | type_strip(ty as META_OVERLOADED {1=ref ty',...}) =
            (case ty' of
               NULLTYPE => ty
             | _ => type_strip ty')
          | type_strip(METARECTYPE(ref{3 = ty, ...})) = type_strip ty
          | type_strip(ty as CONSTYPE(l, METATYNAME{1 = ref tyfun, ...})) =
            (case tyfun of
               NULL_TYFUN _ => ty
             | _ => type_strip(Types.apply(tyfun, l)))
          | type_strip ty = ty

        fun is_polymorphic (DEBRUIJN _) = true
          | is_polymorphic ty =
            not (Types.all_tyvars ty = [])

        (* check_type always raises an exception if a type match failure occurs *)
        fun check_type (ty,ty') = check_type' (type_strip ty,type_strip ty')

        and check_type' (DEBRUIJN stuff,ty) =
          check_debruijn (stuff,ty)
          | check_type' (ty1 as RECTYPE map,ty2 as RECTYPE map') =
            if NewMap.eq (fn (ty1,ty2) => (check_type (ty1,ty2); true)) (map, map') then
	      ()
	    else
	      raise Error (ty1,ty2,"record types have different domains")
(*
               Mapping.EQUAL => ()
             | Mapping.NOT_EQUAL => Crash.impossible "scheme:check_type'"
             | Mapping.DIFFERENT_DOMAINS => raise Error (ty1,ty2,"record types have different domains")
*)
          | check_type' (FUNTYPE (ran,dom),FUNTYPE(ran',dom')) =
            (check_type (ran,ran');
             check_type (dom,dom'))
          | check_type' (ty1 as CONSTYPE (tys,tyname), ty2 as CONSTYPE (tys',tyname')) =
            if not (Types.tyname_eq (tyname,tyname'))
              then raise Error (ty1,ty2,"types clash")
            else
              Lists.iterate check_type (Lists.zip (tys,tys'))
          | check_type' (ty1 as METATYVAR(r as ref (_,NULLTYPE,_), eq, imp), ty2) =
              if isSML90 then raise Error(ty1,ty2,"")
              else if is_polymorphic ty2 then raise Error(ty1,ty2,"trying to instantiate to a polytype")
              else if eq andalso not(Types.closed_type_equalityp ty2)
                then raise Error(ty1,ty2,"missing equality attribute")
              else (* can instantiate the type *)
                r := (0,ty2,NO_INSTANCE)
          | check_type' (ty,ty') =
            if Types.type_eq (ty,ty',true,true)
              then 
                ()
            else raise Error(ty,ty',"")
      in
        (* Error is raised by check_type *)
        (check_type (ty1,ty2);
         !binding_list)
      end

    fun generalises isSML90 (ty1,ty2) =
      (ignore(internal_generalises_map isSML90 (ty1,ty2)); true)
      handle Error _ => raise Mismatch

    fun generalises_map isSML90 (ty1,ty2) =
      internal_generalises_map isSML90 (ty1,ty2)
      handle Error _ => raise Mismatch


        (* note that the two functions, SML9?_dynamic_generalises
           are set here and in the functions 
           select_sml'90, select_sml'96 in interpreter/_shell_structure.sml
         *)


    fun SML90_dynamic_generalises
	  (ty1 : MLWorks.Internal.Dynamic.type_rep,
	   ty2 : MLWorks.Internal.Dynamic.type_rep) =
      let
        val cast : 'a -> 'b = MLWorks.Internal.Value.cast
      in
        generalises true (cast ty1,cast ty2)
        handle Mismatch => 
          raise MLWorks.Internal.Dynamic.Coerce(ty1, ty2)
      end


    fun SML96_dynamic_generalises
	  (ty1 : MLWorks.Internal.Dynamic.type_rep,
	   ty2 : MLWorks.Internal.Dynamic.type_rep) =
      let
        val cast : 'a -> 'b = MLWorks.Internal.Value.cast
      in
        generalises false (cast ty1,cast ty2)
        handle Mismatch => 
          raise MLWorks.Internal.Dynamic.Coerce(ty1, ty2)
      end

    (* And set the pervasive generalizes function *)

    val _ = MLWorks.Internal.Dynamic.generalises_ref := 
      let val Options.OPTIONS{compat_options=
                              Options.COMPATOPTIONS{old_definition,...},...}
        = Options.default_options
       in
         if old_definition then SML90_dynamic_generalises
         else SML96_dynamic_generalises
      end

    (* Note similarity of code with instantiate above *)
    fun apply_instantiation (ty,binding_list) =
      let
	fun instance_map(_, ty) = instance ty

        and instance (t as (TYVAR _)) = t
          | instance ((RECTYPE amap)) =
            RECTYPE (NewMap.map instance_map amap)
          | instance (FUNTYPE(arg,res)) =
            FUNTYPE (instance arg,instance res)
          | instance (CONSTYPE (tylist,tyname)) =
            CONSTYPE (map instance tylist,tyname)
          | instance (t as DEBRUIJN (n,_,_,_)) = 
            ((Lists.assoc (n,binding_list))
             handle Lists.Assoc => t)
          | instance (t as NULLTYPE) = t
          | instance(t as (METATYVAR (ref (_,ty,_),_,_))) =
            (case ty of
               NULLTYPE => t
             | _ => instance ty)
          | instance (t as (META_OVERLOADED {1=ref ty,...})) =
	    (case ty of
               NULLTYPE => t
             | _ => instance ty)
          | instance (t as METARECTYPE (ref (_,b,ty,_,_))) =
            if b then
              (case ty of
                 METARECTYPE _ => instance ty
               | _ => t)
            else
              ty
      in
        instance ty
      end

    fun is_meta(Datatypes.METATYVAR _) = true
      | is_meta _ = false

    fun is_deb(Datatypes.DEBRUIJN _) = true
      | is_deb _ = false

    fun is_tyvar (Datatypes.TYVAR _) = true
      | is_tyvar _ = false

    (* This alas takes params in opposite order to generalises *)
    fun scheme_generalises options (name,completion_env,_,scheme,scheme') =
      let
        val atype = skolemize scheme
        val atype' = skolemize scheme'
        val Options.OPTIONS{compat_options=
                            Options.COMPATOPTIONS{old_definition,...},...}
          = options
      in
        (* note reversal of parameter order *)
        (ignore(internal_generalises_map old_definition (atype',atype)); true)
        handle Error(ty',ty,reason) =>
	  let
	    val same_types = Types.type_eq(atype, ty, true, true)
            fun dbx ty = [Err_Type ty, Err_String ": ",
                          if is_meta ty then Err_String "Meta " else
                            Err_String "",
                          if is_deb ty then Err_String "Deb " else
                            Err_String "",
                          if is_tyvar ty then Err_String "Tyvar " else
                            Err_String ""]
            fun expand_reason "" = "type clash"
              | expand_reason r = r
	  in
	    raise EnrichError
	      (Completion.report_type_error
	       (options, completion_env,
		[Err_String "Type mismatch in signature and structure:",
                 Err_String "\n    id : ", err_valid (options, name),
                 Err_String "\n    spec :   ", Err_Scheme atype,
                 Err_String "\n    actual : ", Err_Scheme atype']@@
		(if same_types then
		   [Err_String ("\n      (" ^ expand_reason reason ^ ")")]
		 else
		   Err_String "\n      because" ::
		   Err_String "\n         " ::
		   (if (is_meta ty') orelse (is_tyvar ty')(*special*) then
		      (Err_Scheme ty' ::
                       Err_String "\n      is a" ::
                       (if is_tyvar ty' then Err_String "n explicit "
                        else Err_String " ") ::
                          (if Types.imperativep ty'
                             then Err_String "free imperative type variable"
                           else Err_String "free type variable") ::
                             (if is_deb ty then
                                [Err_String "\n      which cannot be instantiated to the bound variable",
                                 Err_String "\n         ", Err_Type ty]
                              else
                                [Err_String "\n      which cannot be instantiated to",
                                 Err_String "\n         ", Err_Type ty])) @@
                      (if reason = "" then [] else [Err_String ("\n     (" ^ reason ^ ")")])
                    else [Err_Type ty',
		       Err_String "\n      is not an instance of",
		       Err_String "\n         ", Err_Type ty,
                       Err_String ("\n      (" ^ expand_reason reason ^ ")")]))))
	  end
      end

    fun typescheme_eq (OVERLOADED_SCHEME (UNARY (_,tv)),
                       OVERLOADED_SCHEME (UNARY (_,tv'))) = tv = tv'
      | typescheme_eq (OVERLOADED_SCHEME (UNARY _),_) = false
      | typescheme_eq (OVERLOADED_SCHEME (BINARY (_,tv)),
                       OVERLOADED_SCHEME (BINARY (_,tv'))) = tv = tv'
      | typescheme_eq (OVERLOADED_SCHEME (BINARY _),_) = false
      | typescheme_eq (OVERLOADED_SCHEME (PREDICATE (_,tv)),
		       OVERLOADED_SCHEME (PREDICATE (_,tv'))) = tv = tv'
      | typescheme_eq (OVERLOADED_SCHEME (PREDICATE _),_) = false
      | typescheme_eq (UNBOUND_SCHEME (atype,_),UNBOUND_SCHEME (atype',_)) = 
	Types.type_eq (atype,atype',true,false)
      | typescheme_eq (SCHEME(n,(atype,_)),SCHEME(n',(atype',_))) = 
	n = n andalso Types.type_eq (atype,atype',true,false)
      | typescheme_eq _ = Crash.impossible "Scheme.typescheme_eq"

    local

      fun follow (name as METATYNAME{1=ref(NULL_TYFUN _), ...}) =
	name
	| follow (METATYNAME{1=ref(ETA_TYFUN (name)), ...}) =
	  follow (name)
	| follow _ = Crash.impossible "Scheme.follow"

      fun uninstantiated (METATYNAME{1=ref(NULL_TYFUN _), ...}) = true
	| uninstantiated (METATYNAME{1=ref(ETA_TYFUN (name)), ...}) =
	  uninstantiated (name)
	| uninstantiated (_) = false

      fun gather_names (namelist, CONSTYPE (tylist,tyname)) = 
	let
	  val names = Lists.reducel gather_names (namelist, tylist)
	in
	  if (uninstantiated tyname) then
	    follow tyname :: names
	  else
	    names
	end
	| gather_names(namelist, FUNTYPE (atype,atype')) = 
	  gather_names(gather_names(namelist, atype), atype')
	| gather_names(namelist, ty as RECTYPE _) =
	  Lists.reducel
	  (fn (list, ty') => gather_names(list, ty'))
	  (namelist, Types.rectype_range ty)
	| gather_names(namelist, METATYVAR (ref (_,atype,_),_,_)) =
	  gather_names(namelist, atype)
	| gather_names(namelist, META_OVERLOADED {1=ref atype,...}) =
	  gather_names(namelist, atype)
	| gather_names(namelist, METARECTYPE (ref (_,_,atype,_,_))) =
	  gather_names(namelist, atype)
	| gather_names(namelist, _) = namelist
    in
      fun gather_tynames (UNBOUND_SCHEME (atype,_)) = gather_names ([], atype)
	| gather_tynames (SCHEME (_,(atype,_))) = gather_names ([], atype)
	| gather_tynames (OVERLOADED_SCHEME _) = []
    end

    fun return_both atype =
      case Types.has_free_imptyvars atype of
	SOME ty => SOME (ty, atype)
      | _ => NONE

    fun has_free_imptyvars (SCHEME (_,(atype,_))) = 
      return_both atype
      | has_free_imptyvars (UNBOUND_SCHEME ((atype,_))) = 
	return_both atype
      (* only in final ve for exceptions *)
      | has_free_imptyvars _ = Crash.impossible "Scheme.has_free_imptyvar"
	
    (****
     scheme_copy is used in copying of signatures.
     ****)  

    fun scheme_copy (s as SCHEME (n,(atype,instance)),tyname_copies) = 
        SCHEME(n, (Types.type_copy(atype, tyname_copies),instance))
      | scheme_copy (UNBOUND_SCHEME (atype,instance),tyname_copies) =
	UNBOUND_SCHEME(Types.type_copy(atype,tyname_copies),instance)
      | scheme_copy (scheme as OVERLOADED_SCHEME _, _) = 
	scheme

    fun tyvars (tyvarlist, SCHEME (_,(atype,_))) = Types.tyvars(tyvarlist, atype)
      | tyvars (tyvarlist, UNBOUND_SCHEME (atype,_)) = 
        Types.tyvars(tyvarlist, atype)
      | tyvars _ = Crash.impossible "Scheme.tyvars"
  end;
@


1.66.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.66  1998/02/19  16:42:17  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.65
log
@[Bug #50006]
Fix is_polymorphic for Debruijn variables
@
text
@d4 4
d346 1
a346 1
                then (new_instance atyvar'';
d353 1
a353 1
                then (new_instance tyvar;
d879 1
a879 1
      (internal_generalises_map isSML90 (ty1,ty2);true)
d981 1
a981 1
        (internal_generalises_map old_definition (atype',atype); true)
@


1.64
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d829 3
a831 2
        fun is_polymorphic ty =
          not (Types.all_tyvars ty = [])
@


1.64.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.64  1996/11/06  11:33:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.64.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.64  1996/11/06  11:33:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.64.5.1
log
@branched from 1.64
@
text
@a3 4
 * Revision 1.64  1996/11/06  11:33:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.64.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.64.5.1  1997/05/12  10:51:16  hope
 * branched from 1.64
 *
@


1.64.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.64.5.1  1997/05/12  10:51:16  hope
 * branched from 1.64
 *
@


1.64.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.64.5.1  1997/05/12  10:51:16  hope
 * branched from 1.64
 *
@


1.64.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.64.5.1.1.1  1997/07/28  18:34:37  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.64.4.1
log
@branched from 1.64
@
text
@a3 4
 * Revision 1.64  1996/11/06  11:33:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.64.3.1
log
@branched from 1.64
@
text
@a3 4
 * Revision 1.64  1996/11/06  11:33:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.64.3.1.1.1
log
@branched from 1.64.3.1
@
text
@a3 3
 * Revision 1.64.3.1  1996/12/17  18:17:41  hope
 * branched from 1.64
 *
@


1.64.2.1
log
@branched from 1.64
@
text
@a3 4
 * Revision 1.64  1996/11/06  11:33:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.64.1.1
log
@branched from 1.64
@
text
@a3 4
 * Revision 1.64  1996/11/06  11:33:21  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.64.1.1.1.1
log
@branched from 1.64.1.1
@
text
@a3 3
 * Revision 1.64.1.1  1996/11/14  13:20:55  hope
 * branched from 1.64
 *
@


1.63
log
@[Bug #1614]
basifying String
@
text
@d4 4
d220 1
a220 1
require "../basis/__integer";
@


1.62
log
@Adding monotype instantiations of metatyvars in signature matching
@
text
@d4 3
d217 1
a217 1

d306 1
a306 1
          MLWorks.Option.NONE => ()
d308 1
a308 1
        | MLWorks.Option.SOME (instance,_) => 
d360 2
a361 2
                        METATYVAR(tyv,_,_) => MLWorks.Option.SOME(tyv)
                      | TYVAR(tyv,_) => MLWorks.Option.SOME(tyv)
d475 2
a476 2
                                    METATYVAR(tyv,_,_) => MLWorks.Option.SOME(tyv)
                                  | TYVAR(tyv,_) => MLWorks.Option.SOME(tyv)
d536 1
a536 1
          | check (CONSTYPE (tylist,tyname)) = Lists.forall check tylist
d559 2
a560 2
         MLWorks.Option.NONE => (ZERO,MLWorks.Option.NONE)
       | MLWorks.Option.SOME(instance,instance') =>
d562 1
a562 1
             ref(instance' as MLWorks.Option.SOME (ref (SIGNATURE_INSTANCE instance_info))) => 
d564 1
a564 1
           | _ => (ZERO,MLWorks.Option.SOME(instance)))
d569 1
a569 1
	  (FUNTYPE (olvar,olvar),(ZERO,MLWorks.Option.NONE))
d580 1
a580 1
          (ZERO,MLWorks.Option.NONE))
d591 1
a591 1
          (ZERO,MLWorks.Option.NONE))
d597 3
a599 3
              MLWorks.Option.SOME (instance',ref instance'') => 
                (MLWorks.Option.SOME instance',instance'')
            | _ => (MLWorks.Option.NONE,MLWorks.Option.NONE)
d625 2
a626 2
                          MLWorks.Option.NONE => ()
                        | MLWorks.Option.SOME instance => 
d631 1
a631 1
                                    MLWorks.Option.SOME(tyvar as ref(n,ty,instances)) => 
d671 1
a671 1
            | instance_length (INSTANCE instances) = ONE (Lists.length(instances))
d682 2
a683 2
              MLWorks.Option.NONE => ZERO
            | MLWorks.Option.SOME instance => 
d687 1
a687 1
                        MLWorks.Option.SOME (ref (SIGNATURE_INSTANCE instance_info)) => 
d694 1
a694 1
                        MLWorks.Option.SOME (ref (SIGNATURE_INSTANCE instance_info)) => 
d702 1
a702 1
                         MLWorks.Option.SOME (ref (SIGNATURE_INSTANCE _)) => instance''
d729 1
a729 1
	    String.implode ["ALL ", olvar, ".", olvar, " -> ", olvar]
d734 1
a734 1
	    String.implode ["ALL ", olvar, ".", olvar, " * ", olvar, " -> ", olvar]
d739 1
a739 1
	    String.implode ["ALL ", olvar, ".", olvar, " * ", olvar, " -> bool"]
d779 1
a779 1
               MLWorks.Option.SOME(tyvar) =>
d787 1
a787 1
                                   DEBRUIJN(_,_,_,MLWorks.Option.SOME(tyv)) => 
d1074 2
a1075 2
	MLWorks.Option.SOME ty => MLWorks.Option.SOME(ty, atype)
      | _ => MLWorks.Option.NONE
@


1.62.2.1
log
@branched from 1.62
@
text
@a3 3
 * Revision 1.62  1996/09/24  10:02:29  matthew
 * Adding monotype instantiations of metatyvars in signature matching
 *
@


1.62.1.1
log
@branched from 1.62
@
text
@a3 3
 * Revision 1.62  1996/09/24  10:02:29  matthew
 * Adding monotype instantiations of metatyvars in signature matching
 *
@


1.61
log
@[Bug #1522]
Modified the signature matching error message to report if a free
(explicit) type variable was trying to match a bound type var.
@
text
@d4 5
d818 3
d844 7
d855 1
a855 1
            else raise Error(ty,ty',"type clash")
d976 2
d987 1
a987 1
		   [Err_String ("\n      (" ^ reason ^ ")")]
d992 14
a1005 14
		      Err_Scheme ty' ::
                      Err_String "\n      is a" ::
                      (if is_tyvar ty' then Err_String "n explicit "
                                       else Err_String " ") ::
		      (if Types.imperativep ty'
                         then Err_String "free imperative type variable"
                         else Err_String "free type variable") ::
		      (if is_deb ty then
			 [Err_String "\n      which cannot be instantiated to the bound variable",
			  Err_String "\n         ", Err_Type ty]
		       else
			 [Err_String "\n      which cannot be instantiated to",
			  Err_String "\n         ", Err_Type ty]
			 )
d1009 1
a1009 1
                       Err_String ("\n      (" ^ reason ^ ")")]))))
@


1.61.1.1
log
@branched from 1.61
@
text
@a3 5
 * Revision 1.61  1996/08/20  12:32:44  andreww
 * [Bug #1522]
 * Modified the signature matching error message to report if a free
 * (explicit) type variable was trying to match a bound type var.
 *
@


1.60
log
@[Bug #1521]
Propagating changes to _types.sml and _completion.sml
and dividing the dynamic_generalises function into two:
one for sml'90 and one for sml'96 (to take into account the
differences in treatment of "imperative" variables.
@
text
@d4 7
d937 3
d954 7
d967 2
a968 2
                 Err_String "\n    spec :   ", Err_Type atype,
                 Err_String "\n    actual : ", Err_Type atype'] @@
d974 1
a974 1
		   (if is_meta ty'(*special*) then
d976 3
d980 2
a981 2
                         then Err_String "\n      is a free imperative type variable"
                       else Err_String "\n      is a free type variable") ::
d983 2
a984 2
			 [Err_String "\n      which cannot match the bound variable in",
			  Err_String "\n         ", Err_Scheme ty]
d986 1
a986 1
			 [Err_String "\n      which cannot match",
d989 1
a989 2
		    else
		      [Err_Type ty,
d991 1
a991 1
		       Err_String "\n         ", Err_Type ty',
@


1.59
log
@Change check for free imperative type variables to return
the full type as well as the type variable
@
text
@d4 4
d240 2
a241 1
    fun err_valid (opts, vname) = Err_String (IdentPrint.printValId opts vname)
d254 1
a254 1
      fun generalise (error_info,print_options, location) (subfun,ty) = 
d269 1
a269 1
                Types.print_type print_options ty);
d339 2
a340 2
      fun make_subst_list ([],n,substacc) = (n,substacc)
	| make_subst_list (h::t,n,substacc) = 
d347 2
a348 1
                      | _ => Crash.impossible "new_debruijn:make_subst_list:scheme")
d350 1
a350 1
	    make_subst_list(t,n+1,(h,new_debruijn) :: substacc)
d353 1
a353 1
      fun make_scheme' (error_info,print_options,location) ([],tyexp) = 
d359 2
a360 1
	| make_scheme' (error_info,print_options,location)(tylist,tyexp as (ty,instance)) = 
d362 2
a363 1
            val (no_of_bound_vars,substlist) = make_subst_list (tylist,0,[])
d367 3
a369 2
		    (generalise (error_info,print_options,location)
                                (fn tyvar => subst new_instance (substlist,tyvar),
d375 1
a375 1
                            Options.default_print_options,
d378 1
d383 1
d388 3
a390 2
      fun schemify (error_info,print_options,location)
                   (use_value_polymorphism,alevel,exp_varp,UNBOUND_SCHEME (atype as (atype',instance'')),
d394 4
d421 2
a422 1
		(not (exp_varp andalso (use_value_polymorphism orelse Types.imperativep avar)))
d471 2
a472 1
	  val scheme_type = (generalise (error_info,print_options,location) (subfun,atype'),instance'')
d735 4
a738 3
    fun internal_generalises_map (use_value_polymorphism,ty1,ty2) =
      (* This function attempts to construct a mapping from the deBruijns of ty1 to the subtypes
       of ty2 such that the ty1 = ty2 under the mapping *)
d755 2
a756 1
               then raise Error (DEBRUIJN stuff,ty,"equality attribute missing") 
d758 4
a761 2
             if imp andalso not (use_value_polymorphism orelse Types.imperativep ty)
               then raise Error (DEBRUIJN stuff,ty,"imperative attribute missing") 
d840 2
a841 2
    fun generalises (use_value_polymorphism,ty1,ty2) =
      (internal_generalises_map (use_value_polymorphism,ty1,ty2);true)
d844 2
a845 2
    fun generalises_map (use_value_polymorphism,ty1,ty2) =
      internal_generalises_map (use_value_polymorphism,ty1,ty2)
d849 7
a855 1
    fun dynamic_generalises
d861 13
a873 1
        generalises (true,cast ty1,cast ty2)
d880 8
a887 1
    val _ = MLWorks.Internal.Dynamic.generalises_ref := dynamic_generalises
d931 1
a931 2
    fun scheme_generalises (Options.OPTIONS{print_options=options, compat_options, ...})
      (name,completion_env,_,scheme,scheme') =
d935 3
a937 1
        val Options.COMPATOPTIONS {old_definition,...} = compat_options
d940 1
a940 1
        (internal_generalises_map (not old_definition,atype',atype); true)
@


1.58
log
@Array moving to MLWorks.Array
@
text
@d4 3
d985 5
d991 1
a991 1
      Types.has_free_imptyvars (atype)
d993 1
a993 1
	Types.has_free_imptyvars (atype)
@


1.57
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d565 1
a565 1
	  val sub_vec = Array.array(n, NULLTYPE)
d578 1
a578 1
		val asub = Array.sub (sub_vec,n)
d606 1
a606 1
		      (Array.update (sub_vec,n,new_meta);
@


1.56
log
@Integer changes
@
text
@d4 3
d687 1
a687 1
	    implode ["ALL ", olvar, ".", olvar, " -> ", olvar]
d692 1
a692 1
	    implode ["ALL ", olvar, ".", olvar, " * ", olvar, " -> ", olvar]
d697 1
a697 1
	    implode ["ALL ", olvar, ".", olvar, " * ", olvar, " -> bool"]
@


1.55
log
@Adding option for value polymorphism
@
text
@d4 3
d185 2
d699 1
a699 1
	 "ALL{"^ (MLWorks.Integer.makestring n)^"}." ^ (Types.extra_debug_print_type aty)
@


1.54
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@d4 3
a218 2
    val use_value_polymorphism = ref false

d361 1
a361 1
                   (alevel,exp_varp,UNBOUND_SCHEME (atype as (atype',instance'')),
d388 1
a388 1
		(not (exp_varp andalso (!use_value_polymorphism orelse Types.imperativep avar)))
d448 1
a448 1
    fun check_closure (atype,alevel,tyvars_scoped) =
d463 1
a463 1
          not (!use_value_polymorphism orelse Types.imperativep avar)
d700 1
a700 1
    fun internal_generalises_map (ty1,ty2) =
d721 1
a721 1
             if imp andalso not (!use_value_polymorphism orelse Types.imperativep ty)
d801 2
a802 2
    fun generalises (ty1,ty2) =
      (internal_generalises_map (ty1,ty2);true)
d805 2
a806 2
    fun generalises_map (ty1,ty2) =
      internal_generalises_map (ty1,ty2)
d816 1
a816 1
        generalises (cast ty1,cast ty2)
d867 1
a867 1
    fun scheme_generalises (Options.OPTIONS{print_options=options, ...})
d872 1
d875 1
a875 1
        (internal_generalises_map (atype',atype); true)
@


1.53
log
@Improve message about imperative type variables
@
text
@d4 3
d810 2
a811 2
	  (ty1 : MLWorks.Internal.Dynamic.Type,
	   ty2 : MLWorks.Internal.Dynamic.Type) =
@


1.52
log
@Replacing Map with NewMap
@
text
@d4 3
d889 3
a891 1
		      Err_String "\n      is a free imperative type variable" ::
@


1.51
log
@Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
some functionality to the Shell structure.
@
text
@d4 4
d245 1
a245 1
              RECTYPE (Mapping.mapit (amap,generalise))
d252 3
d477 1
a477 1
          | check (RECTYPE amap) = Mapping.forall (amap,check)
d482 3
d546 3
a548 1
	  fun instance (t as (TYVAR _)) = t
d550 1
a550 1
	      RECTYPE (Mapping.mapit (amap, instance))
d766 5
a770 1
            (case Mapping.compare (map,map',fn (ty1,ty2) => (check_type (ty1,ty2); true)) of
d773 2
a774 1
             | Mapping.DIFFERENT_DOMAINS => raise Error (ty1,ty2,"record types have different domains"))
d821 3
a823 1
        fun instance (t as (TYVAR _)) = t
d825 1
a825 1
            RECTYPE (Mapping.mapit (amap, instance))
d834 1
a834 1
          | instance(t as  (METATYVAR (ref (_,ty,_),_,_))) =
@


1.50
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d786 3
a788 1
    fun dynamic_generalises (ty1 : MLWorks.Dynamic.Type, ty2 : MLWorks.Dynamic.Type) =
d794 1
a794 1
          raise MLWorks.Dynamic.Coerce(ty1, ty2)
d799 1
a799 1
    val _ = MLWorks.Dynamic.generalises_ref := dynamic_generalises
@


1.49
log
@Changing error behaviour for unresolved records.
@
text
@d4 3
d252 1
a252 1
          Option.ABSENT => ()
d254 1
a254 1
        | Option.PRESENT (instance,_) => 
d306 2
a307 2
                        METATYVAR(tyv,_,_) => Option.PRESENT(tyv)
                      | TYVAR(tyv,_) => Option.PRESENT(tyv)
d409 2
a410 2
                                    METATYVAR(tyv,_,_) => Option.PRESENT(tyv)
                                  | TYVAR(tyv,_) => Option.PRESENT(tyv)
d489 2
a490 2
         Option.ABSENT => (ZERO,Option.ABSENT)
       | Option.PRESENT(instance,instance') =>
d492 1
a492 1
             ref(instance' as Option.PRESENT (ref (SIGNATURE_INSTANCE instance_info))) => 
d494 1
a494 1
           | _ => (ZERO,Option.PRESENT(instance)))
d496 2
a497 1
	let val olvar = META_OVERLOADED (ref NULLTYPE, tyvar, valid, loc)
d499 1
a499 1
	  (FUNTYPE (olvar,olvar),(ZERO,Option.ABSENT))
d510 1
a510 1
          (ZERO,Option.ABSENT))
d513 2
a514 1
	let val olvar = META_OVERLOADED (ref NULLTYPE, tyvar, valid, loc)
d521 1
a521 1
          (ZERO,Option.ABSENT))
d527 3
a529 3
              Option.PRESENT (instance',ref instance'') => 
                (Option.PRESENT instance',instance'')
            | _ => (Option.ABSENT,Option.ABSENT)
d553 2
a554 2
                          Option.ABSENT => ()
                        | Option.PRESENT instance => 
d559 1
a559 1
                                    Option.PRESENT(tyvar as ref(n,ty,instances)) => 
d610 2
a611 2
              Option.ABSENT => ZERO
            | Option.PRESENT instance => 
d615 1
a615 1
                        Option.PRESENT (ref (SIGNATURE_INSTANCE instance_info)) => 
d622 1
a622 1
                        Option.PRESENT (ref (SIGNATURE_INSTANCE instance_info)) => 
d630 1
a630 1
                         Option.PRESENT (ref (SIGNATURE_INSTANCE _)) => instance''
d703 1
a703 1
               Option.PRESENT(tyvar) =>
d711 1
a711 1
                                   DEBRUIJN(_,_,_,Option.PRESENT(tyv)) => 
@


1.48
log
@Adding (optional) support for value polymorphism
@
text
@d4 3
d167 1
d176 1
d183 1
d192 1
d194 2
a197 1
    exception MakeScheme of string * Type
d215 1
a215 1
      fun generalise(subfun,ty) = 
d225 7
a231 2
            | generalise (ty as METARECTYPE (ref (_,true,_,_,_))) = 
              raise MakeScheme ("Unresolved flexible record of type ",ty)
d240 1
a240 1
            | generalise (ty as DEBRUIJN _) = raise MakeScheme ("impossible type error 15: debruijn ",ty)
d310 1
a310 1
      fun make_scheme ([],tyexp) = 
d316 1
a316 1
	| make_scheme (tylist,tyexp as (ty,instance)) = 
d322 2
a323 1
		    (generalise (fn tyvar => subst new_instance (substlist,tyvar),
d328 8
d340 2
a341 1
      fun schemify (alevel,exp_varp,UNBOUND_SCHEME (atype as (atype',instance'')),
d417 1
a417 1
	  val scheme_type = (generalise (subfun,atype'),instance'')
d422 4
a425 1
	| schemify _ = Crash.impossible "Scheme.schemify"
d571 1
a571 1
	      raise MakeScheme ("impossible type error 16: nulltype in scheme ",NULLTYPE)
@


1.47
log
@Improving error messages
@
text
@d4 3
d192 1
d345 1
a345 1
		(not (exp_varp andalso (Types.imperativep avar)))
d381 1
a381 1
				  Types.imperativep avar,
d417 1
a417 1
          not (Types.imperativep avar)
d668 1
a668 1
             if imp andalso not(Types.imperativep ty)
@


1.46
log
@Use Stamp instead of Tyname_id etc.
@
text
@d4 3
d640 2
a641 1
    exception MisMatch of Type * Type
d643 1
a643 1
    fun generalises_map (ty1,ty2) =
d654 3
a656 2
              then true
            else raise MisMatch (ty,ty')
d662 1
a662 1
               then raise MisMatch (DEBRUIJN stuff,ty) 
d665 1
a665 1
               then raise MisMatch (DEBRUIJN stuff,ty) 
d667 27
a693 28
               case tyvar of
                 Option.PRESENT(tyvar) =>
                (* record the signature type corresponding to the structure 
                   type variable as instance - crucial for application of the 
                   polymorphic debugger to the modules language *)
               (case tyvar of 
                 ref(n,t,instance) => 
                   tyvar := (n,t,
                      (case ty of
                         DEBRUIJN(_,_,_,Option.PRESENT(tyv)) => 
                           (* prevent unneccessary duplication of tyvars *)
                           if tyv = tyvar then 
                             instance
                           else
                           INSTANCE (tyv::
                         (case instance of
                            NO_INSTANCE => nil
                          | INSTANCE(instances) => instances
                          | _ => Crash.impossible "2:check_debruijn:scheme"))
                       | DEBRUIJN _ => instance
                       | _ => INSTANCE(ref(0,ty,NO_INSTANCE)::
                         (case instance of
                            NO_INSTANCE => nil
                          | INSTANCE(instances) => instances
                          | _ => Crash.impossible "2:check_debruijn:scheme")))))
               | _ => ();
             binding_list := (n,ty)::(!binding_list);
             true))
d710 1
d715 5
a719 2
          | check_type' (RECTYPE map,RECTYPE map') =
            Mapping.eqmaps (map,map',check_type)
d721 7
a727 7
            check_type (ran,ran')
            andalso
            check_type (dom,dom')
          | check_type' (CONSTYPE (tys,tyname),CONSTYPE (tys',tyname')) =
            Types.tyname_eq (tyname,tyname')
            andalso
            Lists.forall check_type (Lists.zip (tys,tys'))
d731 2
a732 2
                true
            else raise MisMatch(ty,ty')
d734 3
a736 4
        if check_type (ty1,ty2)
          then
            !binding_list
        else raise MisMatch (ty1,ty2)
d740 18
a757 1
      (generalises_map (ty1,ty2);true)
d759 2
a793 19
(*
    fun has_metatyvars(tyvar_list, Datatypes.METATYVAR(tyvar as ref(_, ty, _), _, _)) =
      if Lists.member(tyvar, tyvar_list) then tyvar_list else tyvar :: tyvar_list
      | has_metatyvars(tyvar_list, Datatypes.META_OVERLOADED _) = tyvar_list
      | has_metatyvars(tyvar_list, Datatypes.TYVAR(_, tyvar)) = tyvar_list
      | has_metatyvars(tyvar_list, Datatypes.METARECTYPE(ref{3= ty, ...})) =
	has_metatyvars(tyvar_list, ty)
      | has_metatyvars(tyvar_list, Datatypes.RECTYPE map) =
	Lists.reducel
	(fn (tyvar_list, (_, ty)) => has_metatyvars(tyvar_list, ty))
	(tyvar_list, Mapping.assoc map)
      | has_metatyvars(tyvar_list, Datatypes.FUNTYPE(ty, ty')) =
	has_metatyvars(has_metatyvars(tyvar_list, ty), ty')
      | has_metatyvars(tyvar_list, Datatypes.CONSTYPE(ty_list, _)) =
	Lists.reducel has_metatyvars (tyvar_list, ty_list)
      | has_metatyvars(tyvar_list, Datatypes.DEBRUIJN deb) = tyvar_list
      | has_metatyvars(tyvar_list, Datatypes.NULLTYPE) = tyvar_list
*)

a796 20
(*
    fun has_debruijns(deb_list, Datatypes.METATYVAR(ref(_, ty, _), _, _)) =
      has_debruijns(deb_list, ty)
      | has_debruijns(deb_list, Datatypes.META_OVERLOADED _) = deb_list
      | has_debruijns(deb_list, Datatypes.TYVAR _) = deb_list
      | has_debruijns(deb_list, Datatypes.METARECTYPE(ref{3= ty, ...})) =
	has_debruijns(deb_list, ty)
      | has_debruijns(deb_list, Datatypes.RECTYPE map) =
	Lists.reducel
	(fn (deb_list, (_, ty)) => has_debruijns(deb_list, ty))
	(deb_list, Mapping.assoc map)
      | has_debruijns(deb_list, Datatypes.FUNTYPE(ty, ty')) =
	has_debruijns(has_debruijns(deb_list, ty), ty')
      | has_debruijns(deb_list, Datatypes.CONSTYPE(ty_list, _)) =
	Lists.reducel has_debruijns (deb_list, ty_list)
      | has_debruijns(deb_list, Datatypes.DEBRUIJN deb) =
	if Lists.member (deb, deb_list) then deb_list else deb :: deb_list
      | has_debruijns(deb_list, Datatypes.NULLTYPE) = deb_list
*)

d808 2
a809 2
        generalises (atype',atype)
        handle MisMatch(ty',ty) =>
a810 9
(*
	    val has_deb = case has_debruijns([], ty) of
	      [] => false
	    |_ => true
	    val has_meta = case has_metatyvars([], ty') of
	      [] => false
	    | _ => true
	    val special = is_meta ty' (*andalso is_deb ty*)
*)
d816 4
a819 4
		Err_String "Type mismatch in signature and structure:" ::
		Err_String "\n    id : " :: err_valid (options, name) ::
		Err_String "\n    spec :   " :: Err_Type atype ::
		Err_String "\n    actual : " :: Err_Type atype' ::
d821 1
a821 1
		   []
d838 2
a839 1
		       Err_String "\n         ", Err_Type ty']))))
@


1.45
log
@Debugger stuff
@
text
@d4 3
d632 1
a632 1
	  "ALL{}." ^ (Types.debug_print_type aty)
d634 1
a634 1
	 "ALL{"^ (MLWorks.Integer.makestring n)^"}." ^ (Types.debug_print_type aty)
@


1.44
log
@Rationalizing debugger
@
text
@d4 3
d197 1
a197 1
      fun generalise(subfun,(ty,_)) = 
d202 1
a202 1
              generalise (ty)
d206 1
a206 1
              generalise (ty)
d210 1
a210 1
              generalise (ty)
d212 1
a212 4
              RECTYPE (Mapping.mapit
                       (amap,
                        (fn x => 
                         generalise (x))))
d214 1
a214 1
              FUNTYPE (generalise (arg),generalise (res))
d216 1
a216 1
              CONSTYPE (map (fn x => generalise (x))tylist,tyname)
d220 1
a220 1
          generalise(ty)
d228 1
a228 1
        | Option.PRESENT instance => 
d295 2
a296 8
            val (no_of_bound_vars,substlist) = 
              make_subst_list (tylist,0,[])
            val instance' =
                 case instance of
                   Option.PRESENT(instance',_) => 
                     Option.PRESENT(instance')
                 | _ => Option.ABSENT
            val new_instance = make_new_instance instance'
d300 2
a301 1
                                 (ty,instance')),instance))
d351 1
a351 7
          val (instance,instance') =
            case instance'' of
              Option.PRESENT(instance', ref instance'') => 
                (Option.PRESENT instance', instance'')
            | _ => (Option.ABSENT,Option.ABSENT)

          val new_instance = make_new_instance instance
d384 1
a384 1
	  val scheme_type = (generalise (subfun,(atype',instance)),instance'')
d486 2
a487 2
              Option.PRESENT(instance',ref(instance'')) => 
                (Option.PRESENT(instance'),instance'')
d489 1
d491 1
d513 1
a513 1
                        | Option.PRESENT(instance) => 
d552 1
d556 1
d560 1
d566 1
d581 1
a581 1
                        Option.PRESENT(ref(SIGNATURE_INSTANCE instance_info)) => 
d589 1
a589 1
                         Option.PRESENT(ref(SIGNATURE_INSTANCE(_))) => instance''
@


1.43
log
@Fix error messages for attempted unification during signature matching
@
text
@d4 3
a152 1
require "../typechecker/ty_debug";
a159 5
  structure Debug :
	       sig
		 val set_debug_level : int -> unit
		 val debug_level : unit -> int
	       end
a160 1
  structure Ty_Debug : TY_DEBUG
a174 1
    val do_debug = Ty_Debug.do_debug
d224 1
a224 1
      fun new_instance instance = 
d226 3
a228 2
          Option.ABSENT => (fn _ => ())
        | Option.PRESENT(instance) => 
d230 5
a234 15
              fun new_instance(tyvar) = 
                let
                  fun fetch_tyvar(METATYVAR(tyvar,_,_)) = tyvar
                    | fetch_tyvar(TYVAR(tyvar,_)) = tyvar
                    | fetch_tyvar _ = Crash.impossible "fetch_tyvar:new_instance:scheme"
                  val tyvar' = fetch_tyvar tyvar
                in
                  case !instance of
                    NO_INSTANCE => instance := INSTANCE([tyvar'])
                  | INSTANCE(tyvars) =>
                      if Lists.member(tyvar',tyvars) then ()
                      else 
                        instance := INSTANCE(tyvar'::tyvars)
                  | _ => Crash.impossible "new_instance:scheme"
                end
d236 8
a243 1
              new_instance
d245 4
a248 2
	  
      fun subst tyvs new_instance = 
d251 1
a251 1
            | subst (((atyvar'' as TYVAR(atyvar as (_)), adebruijn)::t),
d254 1
a254 1
                then (new_instance(atyvar'');
d261 1
a261 1
                then (new_instance(tyvar);
d271 1
a271 1
          subst tyvs
d295 2
d302 1
a302 3
            val (no_of_bound_vars,substlist) = 
              make_subst_list (tylist,0,[])
            val new_instance = new_instance instance'
d305 1
a305 1
		    (generalise (fn x => subst (substlist,x) new_instance,
a315 6
          val (instance,instance') =
                 case instance'' of
                   Option.PRESENT(instance',ref(instance'')) => 
                     (Option.PRESENT(instance'),instance'')
                 | _ => (Option.ABSENT,Option.ABSENT)
	  val sub_stack = ref []
d356 9
a364 1
          val new_instance = new_instance instance
d371 1
a371 1
		  val asub = subst (!sub_stack,avar) (fn _ => ())
d388 1
a388 1
                      (new_instance(avar);
d461 1
a461 1
         Option.ABSENT => (nil,Option.ABSENT)
d464 3
a466 3
               ref(instance' as Option.PRESENT(ref(SIGNATURE_INSTANCE(instances)))) => 
                 (instances,instance')
             | _ => (nil,Option.PRESENT(instance)))
d470 1
a470 1
	  (FUNTYPE (olvar,olvar),(nil,Option.ABSENT))
d473 2
a474 1
	let val olvar = META_OVERLOADED (ref NULLTYPE, tyvar, valid, loc)
d480 2
a481 1
		     Types.empty_rectype)),olvar),(nil,Option.ABSENT))
d490 2
a491 1
		     Types.empty_rectype)),Types.bool_type),(nil,Option.ABSENT))
d496 4
a499 4
                 case instance' of
                   Option.PRESENT(instance',ref(instance'')) => 
                     (Option.PRESENT(instance'),instance'')
                 | _ => (Option.ABSENT,Option.ABSENT)
d519 1
a519 1
                      fun new_instance() = 
d538 1
a538 2
		      (new_instance();
                       Array.update (sub_vec,n,new_meta);
d561 1
d564 8
a571 3
          fun length (NO_INSTANCE) = nil
            | length (INSTANCE(instances)) = [Lists.length(instances)]
            | length _ = Crash.impossible "length:instantiate:scheme"
d574 2
a575 2
              Option.ABSENT => nil
            | Option.PRESENT(instance) => 
d579 5
a583 4
                        Option.PRESENT(ref(SIGNATURE_INSTANCE(instances'))) => 
                          if generate_moduler then []
                          else instances'
                      | _ => nil)
d586 5
a590 4
                        Option.PRESENT(ref(SIGNATURE_INSTANCE(instances'))) => 
                          if generate_moduler then length(instances)
                          else instances'@@length(instances)
                      | _ => length(instances))
@


1.42
log
@Allow alternative printing of types to include quantifiers
@
text
@d4 3
d826 1
a827 1
	    val special = is_meta ty' andalso is_deb ty
d842 10
a851 5
		   (if special then
		      [Err_Scheme ty',
		       Err_String "\n      is a free type variable",
		       Err_String "\n      which cannot match the bound variable in",
		       Err_String "\n         ", Err_Scheme ty]
@


1.41
log
@New overloading scheme.
@
text
@d4 3
d760 45
d815 34
a848 11
          raise EnrichError
            (Completion.report_type_error
	     (options, completion_env,
	      [Err_String "Type mismatch in signature and structure:",
	       Err_String "\n    id : ", err_valid (options, name),
	       Err_String "\n    spec :   ", Err_Type atype,
	       Err_String "\n    actual : ", Err_Type atype',
	       Err_String "\n      because",
	       Err_String "\n         ", Err_Type ty,
	       Err_String "\n      does not match",
	       Err_String "\n         ", Err_Type ty']))
@


1.40
log
@Only return real instance of type variables in Modules Debugger.
@
text
@d4 3
a31 2


d35 1
a35 1
Allowed overloadin on strings to be controlled by an option
a175 1
    exception UnresolvedVar of Ident.ValId
d199 2
a200 5
            | generalise (ty as META_OVERLOADED (ref NULLTYPE,id)) =
              (* lets try not signalling just yet *)
              ty (* raise UnresolvedVar id *)
            | generalise (META_OVERLOADED (ref ty,_)) =
              generalise (ty)
d429 1
a429 1
          | check (ty as META_OVERLOADED (ref NULLTYPE,id)) =
d431 1
a431 1
          | check (META_OVERLOADED (ref ty,_)) = check ty
d445 6
a450 3
    fun unary_overloaded_scheme id = OVERLOADED_SCHEME (UNARY id)
    fun binary_overloaded_scheme id = OVERLOADED_SCHEME (BINARY id)
    fun predicate_overloaded_scheme id = OVERLOADED_SCHEME (PREDICATE id)
d455 1
a455 1
    fun instantiate (_,UNBOUND_SCHEME (tyexp,instance),_) = 
d464 2
a465 2
      | instantiate (_,OVERLOADED_SCHEME (UNARY id),_) = 
	let val num = META_OVERLOADED (ref NULLTYPE,id)
d467 1
a467 1
	  (FUNTYPE (num,num),(nil,Option.ABSENT))
d469 2
a470 2
      | instantiate (_,OVERLOADED_SCHEME (BINARY id),_) = 
	let val num = META_OVERLOADED (ref NULLTYPE,id)
d473 1
a473 1
		   (Ident.LAB (Ident.Symbol.find_symbol ("1")),num,
d475 2
a476 2
		    (Ident.LAB (Ident.Symbol.find_symbol ("2")),num,
		     Types.empty_rectype)),num),(nil,Option.ABSENT))
d478 2
a479 2
      | instantiate (_,OVERLOADED_SCHEME (PREDICATE id),_) = 
	let val num = META_OVERLOADED (ref NULLTYPE,id)
d482 1
a482 1
		   (Ident.LAB (Ident.Symbol.find_symbol("1")),num,
d484 1
a484 1
		    (Ident.LAB (Ident.Symbol.find_symbol("2")),num,
d487 1
a487 1
      | instantiate (alevel,SCHEME (n,(tyexp,instance')),generate_moduler) =
d544 1
a544 1
	    | instance (t as (META_OVERLOADED (ref ty,_))) =
d605 15
a619 6
    fun string_scheme (OVERLOADED_SCHEME (UNARY _)) = 
	  "ALL{}.num -> num"
      | string_scheme (OVERLOADED_SCHEME (BINARY _)) = 
	  "ALL{}.num * num -> num"
      | string_scheme (OVERLOADED_SCHEME (PREDICATE _)) = 
	  "ALL{}.num * num -> bool"
d684 1
a684 1
          | type_strip(ty as META_OVERLOADED(ref ty',_)) =
d742 2
a743 2
          | instance (t as (META_OVERLOADED (ref ty,_))) =
            (case ty of
d780 2
a781 2
    fun typescheme_eq (OVERLOADED_SCHEME (UNARY id),
                       OVERLOADED_SCHEME (UNARY id')) = id = id'
d783 2
a784 2
      | typescheme_eq (OVERLOADED_SCHEME (BINARY id),
                       OVERLOADED_SCHEME (BINARY id')) = id = id'
d786 2
a787 2
      | typescheme_eq (OVERLOADED_SCHEME (PREDICATE id),
		       OVERLOADED_SCHEME (PREDICATE id')) = id = id'
d825 1
a825 1
	| gather_names(namelist, META_OVERLOADED (ref atype,_)) =
@


1.39
log
@Removed dead code, removed colons in an error message.
@
text
@d4 3
d455 1
a455 1
    fun instantiate (_,UNBOUND_SCHEME (tyexp,instance)) = 
d464 1
a464 1
      | instantiate (_,OVERLOADED_SCHEME (UNARY id)) = 
d469 1
a469 1
      | instantiate (_,OVERLOADED_SCHEME (BINARY id)) = 
d478 1
a478 1
      | instantiate (_,OVERLOADED_SCHEME (PREDICATE id)) = 
d487 1
a487 1
      | instantiate (alevel,SCHEME (n,(tyexp,instance'))) =
d569 2
a570 1
                          instances'
d575 2
a576 1
                            instances'@@length(instances)
@


1.38
log
@Marked certain error messages as "impossible".
@
text
@d4 3
a142 1
require "../typechecker/unify";
a155 1
  structure Unify : UNIFY
d161 1
a161 1
  sharing Types.Datatypes = Unify.Datatypes = Completion.Datatypes
a162 1
  sharing type Types.Options.options = Unify.options
a610 108
(* 
    (* keep this here for reference - MLA *)
    local
      (* these two functions are identical to the functions in _scheme *)
      fun string_labels [] = ""
        | string_labels [label] = (IdentPrint.printLab label)
	| string_labels (label::labels) = 
	  (IdentPrint.printLab label) ^ ", " ^ (string_labels labels)
	  
      fun string_domain (Unify.RIGID lablist) = 
	"{" ^ (string_labels lablist) ^	"}"
	| string_domain (Unify.FLEX lablist) = 
          case lablist of
            [] => "{...}"
          | _ => "{" ^ (string_labels lablist) ^ ", ...}"

      fun instancep (full_options as Options.OPTIONS{print_options=options, ...})
	(val_name,completion_env,(type1,instance),type2) =
        let 
          val result =  Unify.unified(true,full_options, type1,type2)
        in
          case result of
            Unify.OK => true
          | _ => 
              let
                fun print_name name = Completion.print_name(options,completion_env,name)
              in
                raise EnrichError
                  (Completion.report_type_error (options, completion_env,
                   (case result
                      of Unify.OK => []
                      | Unify.FAILED (ty,ty') => 
                          [Err_String "Type mismatch in signature and structure:",
                           Err_String "\n  id : ", err_valid (options, val_name),
                           Err_String "\n  spec   : ", Err_Type type1,
                           Err_String "\n  actual : ", Err_Type type2,
                           Err_String "\n    because",
                           Err_String "\n    in spec   : ", Err_Type ty,
                           Err_String "\n    in actual : ", Err_Type ty']
                      | Unify.TYNAME (name,name') =>
                          [Err_String "Type mismatch in signature and structure:",
                           Err_String "\n  id : ", err_valid (options, val_name),
                           Err_String "\n  spec   : ", Err_Type type1,
                           Err_String "\n  actual : ", Err_Type type2,
                           Err_String "\n    because ",
                           Err_String "\n    in spec   : ", Err_String (print_name name),
                           Err_String "\n    in actual : ", Err_String (print_name name')]
                      | Unify.RECORD_DOMAIN (domain, domain') =>
                          [Err_String "Type mismatch in signature and structure:",
                           Err_String "\n    domains of record types differ :",
                           Err_String "\n    id : ", err_valid (options, val_name),
                           Err_String "\n    spec   : ", Err_String (string_domain domain), 
                           Err_String "\n    actual : ", Err_String (string_domain domain')]
                      | Unify.EXPLICIT_TYVAR (ty,ty') =>
                          [Err_String "Type mismatch in signature and structure:",
                           Err_String "\n  id : ", err_valid (options, val_name),
                           Err_String "\n  spec   : ", Err_Type type1,
                           Err_String "\n  actual : ", Err_Type type2,
                           Err_String "\n    because ",
                           Err_String "\n    in spec   : ", Err_Type ty, 
                           Err_String "\n    in actual : ", Err_Type ty']
                      | Unify.EQ_AND_IMP (eq,imp,ty) =>
                          [Err_String "Type mismatch in signature and structure:",
                           Err_String "\n  id : ", err_valid (options, val_name),
                           Err_String "\n  spec   : ", Err_Type type1,
                           Err_String "\n  actual : ", Err_Type type2,
                           Err_String "\n  ", Err_Type ty, 
                           Err_String
			   (if eq andalso not imp then
                              " requires equality attribute"
                            else
                              if eq andalso imp then
                                " requires equality as well as imperative attributes"
                              else
                                " requires imperative attribute")]
                      | Unify.CIRCULARITY (ty,ty') =>
                          [Err_String "Type mismatch in signature and structure:",
                           Err_String "\n    id : ", err_valid (options, val_name),
                           Err_String "\ncircular type results from unifying \n",
                           Err_Type ty, Err_String "\n    and\n  ",
                           Err_Type ty']
                      | Unify.OVERLOADED ty =>
                          [Err_String "Type mismatch in signature and structure:",
                           Err_String "\nCannot unify overloaded type with ",
                           Err_Type ty])))
              end
        end
    in
      (****
       scheme_generalises is used in enrichment.
       ****)
      fun scheme_generalises (Options.OPTIONS{print_options=options, ...})
	(name,completion_env,_,UNBOUND_SCHEME (atype,_),UNBOUND_SCHEME (atype',_)) =
        Types.type_eq (atype,atype',true,true) orelse
        raise EnrichError
          (Completion.report_type_error
	   (options, completion_env,
	    [Err_String "Type mismatch in signature and structure:",
	     Err_String "\n    id : ", err_valid (options, name),
	     Err_String "\n    spec : ", Err_Type atype,
	     Err_String "\n    actual : ", Err_Type atype']))

	| scheme_generalises options (name,completion_env,level,scheme,scheme') = 
          instancep options (name,completion_env,skolemize scheme,
                             #1(instantiate (level,scheme')))
    end
*)

d758 1
a758 1
	       Err_String "\n    spec : ", Err_Type atype,
d760 1
a760 1
	       Err_String "\n      because:",
d762 1
a762 1
	       Err_String "\n      does not match:",
@


1.37
log
@Added code to encode type errors as a list of strings and types.
@
text
@d4 3
d216 1
a216 1
            | generalise (ty as DEBRUIJN _) = raise MakeScheme ("debruijn ",ty)
d536 1
a536 1
	      raise MakeScheme ("nulltype in scheme ",NULLTYPE)
@


1.36
log
@Typechecker now records instances in closed-over type variables
for polymorphic debugger.
@
text
@d4 4
d173 3
a632 1
                fun print_type ty = Completion.print_type(options,completion_env,ty)
d636 1
a636 1
                  (implode
d640 7
a646 7
                          ["Type mismatch in signature and structure:",
                           "\n  id : ", (IdentPrint.printValId options val_name),
                           "\n  spec   : ", print_type type1,
                           "\n  actual : ", print_type type2,
                           "\n    because",
                           "\n    in spec   : ", (print_type ty),
                           "\n    in actual : ", (print_type ty')]
d648 7
a654 7
                          ["Type mismatch in signature and structure:",
                           "\n  id : ", (IdentPrint.printValId options val_name),
                           "\n  spec   : ", print_type type1,
                           "\n  actual : ", print_type type2,
                           "\n    because ",
                           "\n    in spec   : ", print_name name,
                           "\n    in actual : ", print_name name']
d656 5
a660 5
                          ["Type mismatch in signature and structure:",
                           "\n    domains of record types differ :",
                           "\n    id : ", IdentPrint.printValId options val_name,
                           "\n    spec   : ", string_domain domain, 
                           "\n    actual : ", string_domain domain']
d662 7
a668 7
                          ["Type mismatch in signature and structure:",
                           "\n  id : ", IdentPrint.printValId options val_name,
                           "\n  spec   : ", print_type type1,
                           "\n  actual : ", print_type type2,
                           "\n    because ",
                           "\n    in spec   : ", print_type ty, 
                           "\n    in actual : ", print_type ty']
d670 7
a676 6
                          ["Type mismatch in signature and structure:",
                           "\n  id : ", IdentPrint.printValId options val_name,
                           "\n  spec   : ", print_type type1,
                           "\n  actual : ", print_type type2,
                           "\n  ", print_type ty, 
                           (if eq andalso not imp then
d684 5
a688 5
                          ["Type mismatch in signature and structure:",
                           "\n    id : ", IdentPrint.printValId options val_name,
                           "\ncircular type results from unifying \n",
                           print_type ty, "\n    and\n  ",
                           print_type ty']
d690 3
a692 3
                          ["Type mismatch in signature and structure:",
                           "\nCannot unify overloaded type with ",
                           print_type ty]))
d703 6
a708 4
          (implode ["Type mismatch in signature and structure:",
                    "\n    id : ", IdentPrint.printValId options name,
                    "\n    spec : ", Completion.print_type (options,completion_env,atype),
                    "\n    actual : ", Completion.print_type (options,completion_env,atype')])
d859 10
a868 9
            (implode ["Type mismatch in signature and structure:",
                      "\n    id : ", IdentPrint.printValId options name,
                      "\n    spec : ", Completion.print_type (options,completion_env,atype),
                      "\n    actual : ", Completion.print_type (options,completion_env,atype'),
                      "\n      because:",
                      "\n         ", Completion.print_type(options,completion_env,ty),
                      "\n      does not match:",
                      "\n         ", Completion.print_type(options,completion_env,ty')
                      ])
@


1.35
log
@Removed output statement
@
text
@d4 3
d177 1
a177 1
	| stack_depth ((_,DEBRUIJN(n,_,_))::_) = n+1
d180 56
a235 28
      fun generalise (sub_fun,t as (TYVAR _)) = sub_fun t
	| generalise (sub_fun,t as (METATYVAR 
				    (ref (_,NULLTYPE),_,_))) = sub_fun t
	| generalise (sub_fun,METATYVAR (ref (_,ty),_,_)) =
	  generalise (sub_fun,ty)
	| generalise (sub_fun,ty as META_OVERLOADED (ref NULLTYPE,id)) =
          (* lets try not signalling just yet *)
          ty (* raise UnresolvedVar id *)
	| generalise (sub_fun,META_OVERLOADED (ref ty,_)) =
	  generalise (sub_fun,ty)
	| generalise (sub_fun,
                      METARECTYPE (ref (_,true,ty as METARECTYPE _,_,_))) = 
	  generalise (sub_fun,ty)
	| generalise (_,ty as METARECTYPE (ref (_,true,_,_,_))) = 
	  raise MakeScheme ("Unresolved flexible record of type ",ty)
	| generalise (sub_fun,METARECTYPE (ref (_,_,ty,_,_))) = 
	  generalise (sub_fun,ty)
	| generalise (sub_fun,(RECTYPE amap)) =
	  RECTYPE (Mapping.mapit
		   (amap,
		    (fn x => 
		     generalise (sub_fun,x))))
	| generalise (sub_fun, FUNTYPE(arg,res)) =
	  FUNTYPE (generalise (sub_fun,arg),generalise (sub_fun,res))
	| generalise (sub_fun, CONSTYPE (tylist,tyname)) =
	  CONSTYPE (map (fn x => generalise (sub_fun,x))tylist,tyname)
	| generalise (_,ty as DEBRUIJN _) = raise MakeScheme ("debruijn ",ty)
	| generalise (_,ty as NULLTYPE) = ty
d237 25
a261 18
      fun subst ([],ty) = ty
	| subst (((TYVAR atyvar, adebruijn)::t),
		 ty as TYVAR atyvar') =
	  if atyvar = atyvar' 
	    then adebruijn
	  else 
	    subst (t,ty)
	| subst (((METATYVAR (x',_,_), adebruijn)::t),
		 ty as METATYVAR (x,_,_)) = 
	  if x = x'
	    then adebruijn
	  else 
	    subst (t,ty)
	| subst (((TYVAR _, _)::t),ty as METATYVAR _) = 
	  subst (t,ty)
	| subst (((METATYVAR _, _)::t),ty as TYVAR _) = 
	  subst (t,ty)
	| subst ((x,y)::t,ty) = Crash.impossible "Scheme.subst"
d265 7
a271 2
	  let val new_debruijn = DEBRUIJN (n,Types.tyvar_equalityp h,
					   Types.imperativep h)
d276 2
a277 1
      fun make_scheme ([],tyexp) = UNBOUND_SCHEME tyexp
d282 10
a291 3
	| make_scheme (tylist,tyexp) = 
	  let val (no_of_bound_vars,substlist) = 
	    make_subst_list (tylist,0,[])
d294 2
a295 2
		    generalise (fn x => subst (substlist,x),
				tyexp))
d302 2
a303 1
      fun schemify (alevel,exp_varp,UNBOUND_SCHEME atype,tyvars_scoped,asig) =
d305 5
d316 1
a316 1
	  fun levels_ok (avar as TYVAR (ref var_level,id)) =
d318 1
a318 1
	    | levels_ok (avar as METATYVAR (ref (var_level,_),_,_)) =
d350 3
d358 1
a358 1
		  val asub = subst (!sub_stack,avar)
d369 5
a373 1
				  Types.imperativep avar)
d375 3
a377 2
 		      sub_stack := (avar,new_debruijn)::stack;
		      new_debruijn
d382 1
a382 1
	  val scheme_type = generalise (subfun,atype)
d392 1
a392 1
        fun levels_ok (avar as TYVAR (ref var_level,id)) =
d394 1
a394 1
          | levels_ok (avar as METATYVAR (ref (var_level,_),_,_)) =
d417 2
a418 2
          | check (t as (METATYVAR (ref (_,NULLTYPE),_,_))) = check_var t
          | check (METATYVAR (ref (_,ty),_,_)) = check ty
d442 9
a450 1
    fun instantiate (_,UNBOUND_SCHEME tyexp) = tyexp
d454 1
a454 1
	  FUNTYPE (num,num)
d459 1
a459 1
	  FUNTYPE (Types.add_to_rectype 
d463 2
a464 2
		     Types.empty_rectype)),num)
	  end
d468 1
a468 1
	  FUNTYPE (Types.add_to_rectype 
d472 1
a472 1
		     Types.empty_rectype)),Types.bool_type)
d474 1
a474 1
      | instantiate (alevel,SCHEME (n,tyexp)) =
d476 5
d489 1
a489 1
	    | instance (DEBRUIJN (n,eq,imp)) = 
d496 22
a517 1
		      val new_meta = METATYVAR (ref (alevel,NULLTYPE),eq,imp)
d519 2
a520 1
		      (Array.update (sub_vec,n,new_meta);
d527 1
a527 1
	    | instance(t as  (METATYVAR (ref (_,ty),_,_))) =
d542 22
d565 3
a567 1
          instance (tyexp)
d574 2
a575 2
    fun skolemize (UNBOUND_SCHEME atype) = atype
      | skolemize (SCHEME (n,atype)) = atype
d584 1
a584 1
    fun equalityp (SCHEME (_,FUNTYPE (atype,atype'))) = 
d586 1
a586 1
      | equalityp (UNBOUND_SCHEME (FUNTYPE (atype,atype'))) =
d596 1
a596 1
      | string_scheme (UNBOUND_SCHEME aty) = 
d598 1
a598 1
      | string_scheme (SCHEME (n,aty)) =
d618 3
a620 2
	(val_name,completion_env,type1,type2) =
        let val result =  Unify.unified(full_options, type1,type2)
d693 1
a693 1
	(name,completion_env,_,UNBOUND_SCHEME atype,UNBOUND_SCHEME atype') =
d702 2
a703 1
          instancep options (name,completion_env,skolemize scheme,instantiate (level,scheme'))
d717 2
a718 2
        fun check_debruijn (stuff as (n,eq,imp),ty) =
          let val ty' = Lists.assoc (n,!binding_list)
d733 26
d760 3
a762 2
             true)
        fun type_strip(ty as METATYVAR(ref(_, ty'), _, _)) =
d816 1
a816 1
          | instance (t as DEBRUIJN (n,_,_)) = 
d820 1
a820 1
          | instance(t as  (METATYVAR (ref (_,ty),_,_))) =
d870 1
a870 1
      | typescheme_eq (UNBOUND_SCHEME atype,UNBOUND_SCHEME atype') = 
d872 1
a872 1
      | typescheme_eq (SCHEME(n,atype),SCHEME(n',atype')) = 
d904 1
a904 1
	| gather_names(namelist, METATYVAR (ref (_,atype),_,_)) =
d912 2
a913 2
      fun gather_tynames (UNBOUND_SCHEME atype) = gather_names ([], atype)
	| gather_tynames (SCHEME (_,atype)) = gather_names ([], atype)
d917 1
a917 1
    fun has_free_imptyvars (SCHEME (_,atype)) = 
d919 1
a919 1
      | has_free_imptyvars (UNBOUND_SCHEME (atype)) = 
d928 4
a931 4
    fun scheme_copy (s as SCHEME (n,atype),tyname_copies) = 
        SCHEME(n, Types.type_copy(atype, tyname_copies))
      | scheme_copy (UNBOUND_SCHEME atype,tyname_copies) =
	UNBOUND_SCHEME(Types.type_copy(atype,tyname_copies))
d935 2
a936 2
    fun tyvars (tyvarlist, SCHEME (_,atype)) = Types.tyvars(tyvarlist, atype)
      | tyvars (tyvarlist, UNBOUND_SCHEME atype) = 
@


1.35.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.35  1993/05/21  15:34:35  matthew
Removed output statement

@


1.34
log
@Removed integer parameter
@
text
@d4 3
a366 1
        output(std_out,"Checking closure\n");
@


1.33
log
@ Added generalises_map and apply_instantiation functions
@
text
@d4 3
a121 1
require "../utils/integer";
a137 1
  structure Integer : INTEGER
d473 1
a473 1
	 "ALL{"^ (Integer.makestring n)^"}." ^ (Types.debug_print_type aty)
@


1.32
log
@Changed type generalisation test from using unification to using the
a type variable mapping.


This needs better treatment of error messages.
@
text
@d4 7
d581 1
a581 2
    (* return true if ty1 is a generalisation of ty2 *)
    fun generalises (ty1,ty2) =
d641 40
a680 1
        check_type (ty1,ty2)
@


1.31
log
@Allowed overloadin on strings to be controlled by an option
@
text
@d4 3
a240 8
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("level of context = ");
		 Integer.print alevel;
		 Print.print ("\n");
		 Print.print "tyvars_scoped in schemify = ";
		 Print.print (Set.set_print 
			      (tyvars_scoped,IdentPrint.printTyVar)))
	 else ();
d249 1
a249 7
	    (if (do_debug andalso Debug.debug_level () > 10) 
	       then (Print.print ("in levels_ok (TYVAR)... \n");
		     Integer.print var_level;
		     Print.print "\n";
		     Integer.print alevel)
	     else ();
	       var_level >= alevel)
d251 1
a251 7
	      (if (do_debug andalso Debug.debug_level () > 10) 
		 then (Print.print ("in levels_ok (METATYVAR)... \n");
		       Integer.print var_level;
		       Print.print "\n";
		       Integer.print alevel)
	       else ();
		 var_level >= alevel)
a282 6
	  (if (do_debug andalso Debug.debug_level () > 10)
	     then (Print.print ("in subfun... \n");
		   Print.print ("avar = ");
		   Print.print (Types.debug_print_type avar);
		   Print.print ("\n"))
	   else ();
d304 1
a304 1
	    else avar)
d309 2
a310 6
	  (if (do_debug andalso Debug.debug_level () > 10)
	     then (Print.print ("scheme_type = " ^
				(Types.debug_print_type scheme_type)))
	   else ();
	     SCHEME (stack_depth (!sub_stack),scheme_type))
	end)
d314 46
d433 1
a433 10
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("in Scheme.instantiate ...");
		   Print.print (Types.debug_print_type (tyexp));
		   Print.print ("the no of bound variables in the scheme is ");
		   Integer.print n;
		   Print.print ("\nalevel = ");
		   Integer.print alevel;
		   Print.print ("\n"))
	   else ();
	     instance (tyexp))
d448 2
d466 3
a468 1
	
d485 1
a485 3
        let
          fun print_type ty = Completion.print_type(options,completion_env,ty)
          fun print_name name = Completion.print_name(options,completion_env,name)
d487 65
a551 62
          case Unify.unified(full_options, type1,type2)
            of Unify.OK => true
             | Unify.FAILED (ty,ty') => 
                 raise EnrichError
                   ("Type mismatch in signature and structure:" ^
                    "\n  id : " ^ (IdentPrint.printValId options val_name) ^
                    "\n  spec   : " ^ print_type type1 ^
                    "\n  actual : " ^ print_type type2 ^
                    "\n    because" ^
                    "\n    in spec   : " ^ (print_type ty) ^
                    "\n    in actual : " ^ (print_type ty'))
             | Unify.TYNAME (name,name') =>
                 raise EnrichError
                   ("Type mismatch in signature and structure:" ^
                    "\n  id : " ^ (IdentPrint.printValId options val_name) ^
                    "\n  spec   : " ^ print_type type1 ^
                    "\n  actual : " ^ print_type type2 ^
                    "\n    because " ^
                    "\n    in spec   : " ^ print_name name ^
                    "\n    in actual : " ^ print_name name')
             | Unify.RECORD_DOMAIN (domain, domain') =>
                 raise EnrichError
                   ("Type mismatch in signature and structure:" ^
                    "\n    domains of record types differ :" ^
                    "\n    id : " ^ IdentPrint.printValId options val_name ^
                    "\n    spec   : " ^ string_domain domain ^ 
                    "\n    actual : " ^ string_domain domain')
             | Unify.EXPLICIT_TYVAR (ty,ty') =>
                 raise EnrichError
                   ("Type mismatch in signature and structure:" ^
                    "\n  id : " ^ IdentPrint.printValId options val_name ^
                    "\n  spec   : " ^ print_type type1 ^
                    "\n  actual : " ^ print_type type2 ^
                    "\n    because " ^
                    "\n    in spec   : " ^ print_type ty ^ 
                    "\n    in actual : " ^ print_type ty')
             | Unify.EQ_AND_IMP (eq,imp,ty) =>
                 raise EnrichError
                   ("Type mismatch in signature and structure:" ^
                    "\n  id : " ^ IdentPrint.printValId options val_name ^
                    "\n  spec   : " ^ print_type type1 ^
                    "\n  actual : " ^ print_type type2 ^
                    "\n  " ^ print_type ty ^ 
                    (if eq andalso not imp then
                       " requires equality attribute"
                     else
                       if eq andalso imp then
                         " requires equality as well as imperative attributes"
                       else
                         " requires imperative attribute"))
             | Unify.CIRCULARITY (ty,ty') =>
                 raise EnrichError
                   (implode ["Type mismatch in signature and structure:",
                             "\n    id : ", IdentPrint.printValId options val_name,
                             "\ncircular type results from unifying \n",
                             print_type ty, "\n    and\n  ",
                             print_type ty'])
             | Unify.OVERLOADED ty =>
                 raise EnrichError
                   (implode ["Type mismatch in signature and structure:",
                             "\nCannot unify overloaded type with ",
                             print_type ty])
d569 91
a659 1
  
d670 1
a670 8
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("typescheme_eq ");
		   Print.print ("UNBOUND and UNBOUND \n");
		   Print.print ("atype = " ^ Types.debug_print_type (atype));
		   Print.print ("atype' = " ^ Types.debug_print_type (atype'));
		   Print.print ("\n"))
	   else ();
	Types.type_eq (atype,atype',true,false))
d672 1
a672 8
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("typescheme_eq ");
		   Print.print ("SCHEME and SCHEME \n");
		   Print.print ("atype = " ^ Types.debug_print_type (atype));
		   Print.print ("atype' = " ^ Types.debug_print_type (atype'));
		   Print.print ("\n"))
	   else ();
	n = n andalso Types.type_eq (atype,atype',true,false))
@


1.30
log
@Changed error message for record mismatch
Stopped raising error for unresolved overloading
This should be controlled by an option really
@
text
@d4 5
d138 1
d469 2
a470 1
      fun instancep options (val_name,completion_env,type1,type2) = 
d475 1
a475 1
          case Unify.unified (type1,type2)
d542 1
a542 1
      fun scheme_generalises options
@


1.29
log
@Options & Info changes
@
text
@d4 3
d163 2
a164 1
          sub_fun ty (* raise UnresolvedVar id *)
d294 1
a294 1
	  (if (do_debug andalso Debug.debug_level () > 10) 
d326 1
a326 1
	  (if (do_debug andalso Debug.debug_level () > 10) 
d450 1
d452 1
a452 1
        | string_labels [label] = (IdentPrint.printLab label) ^ ": -"
d454 1
a454 2
	  (IdentPrint.printLab label) ^ ": -," ^
	  (string_labels labels)
d460 2
a461 2
            [] => "{ ... }"
          | _ => "{" ^ (string_labels lablist) ^ ", ... }"
@


1.28
log
@Rationalised use of Mapping structure
@
text
@d4 3
d127 1
a127 1
  sharing Types.Info = IdentPrint.Info = Completion.Info
d133 1
a133 1
    structure Info = Types.Info
d159 2
a160 2
	| generalise (_,ty as META_OVERLOADED (ref NULLTYPE,id)) =
	  raise UnresolvedVar id
@


1.27
log
@Added Completion parameter
@
text
@d4 3
d348 1
a348 1
		     Types.empty_rec_type)),num)
d357 1
a357 1
		     Types.empty_rec_type)),Types.bool_type)
d594 1
a594 1
	| gather_names(namelist, RECTYPE amap) =
d596 2
a597 2
	  (fn (list, (_, ty)) => gather_names(list, ty))
	  (namelist, Mapping.assoc amap)
@


1.26
log
@Anel's last changes
@
text
@d4 3
d102 1
d119 1
d121 2
a122 2
  sharing Types.Info = IdentPrint.Info
  sharing Types.Datatypes = Unify.Datatypes
d453 68
a520 64
      fun instancep options (val_name,type1,type2) = 
	case Unify.unified (type1,type2)
	  of Unify.OK => true
	| Unify.FAILED (ty,ty') => 
	    raise EnrichError
	      ("Type mismatch in signature and structure:" ^
	       "\n  id : " ^ (IdentPrint.printValId options val_name) ^
	       "\n  spec   : " ^ Types.print_type options type1 ^
	       "\n  actual : " ^ Types.print_type options type2 ^
	       "\n    because" ^
	       "\n    in spec   : " ^ (Types.print_type options ty) ^
	       "\n    in actual : " ^ (Types.print_type options ty'))
	| Unify.TYNAME (name,name') =>
	    raise EnrichError
	      ("Type mismatch in signature and structure:" ^
	       "\n  id : " ^ (IdentPrint.printValId options val_name) ^
	       "\n  spec   : " ^ Types.print_type options type1 ^
	       "\n  actual : " ^ Types.print_type options type2 ^
	       "\n    because " ^
	       "\n    in spec   : " ^ (Types.print_name options name) ^
	       "\n    in actual : " ^ (Types.print_name options name'))
	| Unify.RECORD_DOMAIN (domain, domain') =>
	    raise EnrichError
	      ("Type mismatch in signature and structure:" ^
	       "\n    domains of record types differ :" ^
	       "\n    id : " ^ (IdentPrint.printValId options val_name) ^
	       "\n    spec   : " ^ (string_domain domain) ^ 
	       "\n    actual : " ^ 
	       (string_domain domain'))
	| Unify.EXPLICIT_TYVAR (ty,ty') =>
	    raise EnrichError
	      ("Type mismatch in signature and structure:" ^
	       "\n  id : " ^ (IdentPrint.printValId options val_name) ^
	       "\n  spec   : " ^ Types.print_type options type1 ^
	       "\n  actual : " ^ Types.print_type options type2 ^
	       "\n    because " ^
	       "\n    in spec   : " ^ (Types.print_type options ty) ^ 
	       "\n    in actual : " ^ (Types.print_type options ty'))
	| Unify.EQ_AND_IMP (eq,imp,ty) =>
	    raise EnrichError
	      ("Type mismatch in signature and structure:" ^
	       "\n  id : " ^ (IdentPrint.printValId options val_name) ^
	       "\n  spec   : " ^ Types.print_type options type1 ^
	       "\n  actual : " ^ Types.print_type options type2 ^
	       "\n  " ^ (Types.print_type options ty) ^ 
	       (if eq andalso not imp then
		  " requires equality attribute"
		else
		  if eq andalso imp then
		    " requires equality as well as imperative attributes"
		  else
		    " requires imperative attribute"))
	| Unify.CIRCULARITY (ty,ty') =>
	    raise EnrichError
	      ("Type mismatch in signature and structure:" ^
	       "\n    id : " ^ (IdentPrint.printValId options val_name) ^
	       "\ncircular type results from unifying \n"^
	       (Types.print_type options ty) ^ "\n    and\n  " ^
	       (Types.print_type options ty'))
	| Unify.OVERLOADED ty =>
	    raise EnrichError
	      ("Type mismatch in signature and structure:" ^
	       "\nCannot unify overloaded type with " ^ 
	       (Types.print_type options ty))
d526 7
a532 14
	(name,_,UNBOUND_SCHEME atype,UNBOUND_SCHEME atype') =
	(if (do_debug andalso Debug.debug_level () > 10) 
	   then (Print.print ("scheme_generalises \n");
		 Print.print ("UNBOUND_SCHEME and UNBOUND_SCHEME \n");
		 Print.print ("atype = " ^ Types.debug_print_type (atype) ^ "\n");
		 Print.print ("atype' = " ^ Types.debug_print_type (atype'));
		 Print.print ("\n"))
	 else ();
	   (Types.type_eq (atype,atype',true,true) orelse
            raise EnrichError
	      (implode ["Type mismatch in signature and structure:",
			"\n    id : ", (IdentPrint.printValId options name),
			"\n    spec : ", (Types.print_type options atype),
			"\n    actual : ", (Types.print_type options atype')])))
d534 2
a535 8
	| scheme_generalises options (name,level,scheme,scheme') = 
	  (if (do_debug andalso Debug.debug_level () > 10) 
	     then (Print.print ("scheme_generalises \n");
		   Print.print ("scheme = " ^ string_scheme (scheme) ^ "\n");
		   Print.print ("scheme' = " ^ string_scheme (scheme'));
		   Print.print ("\n"))
	   else ();
	     instancep options (name,skolemize scheme,instantiate (level,scheme')))
@


1.25
log
@Propagating options to signature matching error messages.
,
@
text
@d4 3
d128 1
a128 1
    exception UnresolvedVar
d148 3
a150 3
	| generalise (_,ty as META_OVERLOADED (ref NULLTYPE)) =
	  raise UnresolvedVar
	| generalise (sub_fun,META_OVERLOADED (ref ty)) =
d168 1
a168 2
	| generalise (_,ty as DEBRUIJN _) = 
	  raise MakeScheme ("debruijn ",ty)
d320 3
a322 3
    val unary_overloaded_scheme = OVERLOADED_SCHEME (UNARY)
    val binary_overloaded_scheme = OVERLOADED_SCHEME (BINARY)
    val predicate_overloaded_scheme = OVERLOADED_SCHEME (PREDICATE)
d328 2
a329 2
      | instantiate (_,OVERLOADED_SCHEME UNARY) = 
	let val num = META_OVERLOADED (ref NULLTYPE)
d333 2
a334 2
      | instantiate (_,OVERLOADED_SCHEME BINARY) = 
	let val num = META_OVERLOADED (ref NULLTYPE)
d342 2
a343 2
      | instantiate (_,OVERLOADED_SCHEME PREDICATE) = 
	let val num = META_OVERLOADED (ref NULLTYPE)
d381 1
a381 6
(*
	    | instance (t as (METATYVAR (ref (_,NULLTYPE),_,_))) = t
	    | instance ((METATYVAR (ref (_,ty),_,_))) = 
              instance (ty)
*)
	    | instance (t as (META_OVERLOADED (ref ty))) =
a384 4
(*
	    | instance (t as (META_OVERLOADED (ref NULLTYPE))) = t
	    | instance (t as (META_OVERLOADED (ref ty))) = ty
*)
a391 6
(*
	    | instance ((METARECTYPE (ref (_,true,t as METARECTYPE _,_,_)))) =
              instance (t)
	    | instance (t as (METARECTYPE (ref (_,true,_,_,_)))) = t
	    | instance (METARECTYPE (ref (_,_,ty,_,_))) = ty
*)
d423 1
a423 1
    fun string_scheme (OVERLOADED_SCHEME UNARY) = 
d425 1
a425 1
      | string_scheme (OVERLOADED_SCHEME BINARY) = 
d427 1
a427 1
      | string_scheme (OVERLOADED_SCHEME PREDICATE) = 
d452 8
a459 7
	    raise EnrichError ("Type mismatch in signature and structure:" ^
                               "\n  Name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n  Spec   : " ^ Types.print_type options type1 ^
                               "\n  Actual : " ^ Types.print_type options type2 ^
                               "\n    because" ^
                               "\n    in Spec   : " ^ (Types.print_type options ty) ^
			       "\n    in Actual : " ^ (Types.print_type options ty'))
d461 8
a468 7
	    raise EnrichError ("Type mismatch in signature and structure:" ^
                               "\n  Name : " ^ (IdentPrint.printValId options val_name) ^
                               "\n  Spec   : " ^ Types.print_type options type1 ^
                               "\n  Actual : " ^ Types.print_type options type2 ^
                               "\n    because " ^
                               "\n    in Spec   : " ^ (Types.print_name options name) ^
			       "\n    in Actual : " ^ (Types.print_name options name'))
d470 7
a476 6
	    raise EnrichError ("Type mismatch in signature and structure:" ^
                               "\n    Name : " ^ (IdentPrint.printValId options val_name) ^
                               "\n    Domains of record types differ :" ^
			       "\n    Spec   : " ^ (string_domain domain) ^ 
			       "\n    Actual : " ^ 
			       (string_domain domain'))
d478 8
a485 7
	    raise EnrichError ("Type mismatch in signature and structure:" ^
                               "\n  Name : " ^ (IdentPrint.printValId options val_name) ^
                               "\n  Spec   : " ^ Types.print_type options type1 ^
                               "\n  Actual : " ^ Types.print_type options type2 ^
                               "\n    because " ^
                               "\n    in Spec   : " ^ (Types.print_type options ty) ^ 
			       "\n    in Actual : " ^ (Types.print_type options ty'))
d489 11
a499 12
                               "\n  Name : " ^ (IdentPrint.printValId options val_name) ^
                               "\n  Spec   : " ^ Types.print_type options type1 ^
                               "\n  Actual : " ^ Types.print_type options type2 ^
                               "\n  " ^ (Types.print_type options ty) ^ 
                               (if eq andalso not imp then
                                  " requires equality attribute"
                                else
                                  if eq andalso imp 
                                    then
                                      " requires equality as well as imperative attributes"
                                  else
                                    " requires imperative attribute"))
d501 6
a506 5
	    raise EnrichError ("Type mismatch in signature and structure:" ^
                               "\n    Name : " ^ (IdentPrint.printValId options val_name) ^
                               "\nCircular type results from unifying \n"^
			       (Types.print_type options ty) ^ "\n    and\n  " ^
			       (Types.print_type options ty'))
d508 4
a511 3
	    raise EnrichError ("Type mismatch in signature and structure:" ^
                               "\nCannot unify overloaded type with " ^ 
			       (Types.print_type options ty))
d516 2
a517 1
      fun scheme_generalises options (name,_,UNBOUND_SCHEME atype,UNBOUND_SCHEME atype') =
d526 5
a530 4
            raise EnrichError (implode ["Type mismatch in signature and structure:",
                                        "\n    Name : ", (IdentPrint.printValId options name),
                                        "\n    Spec : ", (Types.print_type options atype),
                                        "\n    Actual : ", (Types.print_type options atype')])))
d542 9
a550 8
    fun typescheme_eq (OVERLOADED_SCHEME UNARY,OVERLOADED_SCHEME UNARY) = true
      | typescheme_eq (OVERLOADED_SCHEME UNARY,_) = false
      | typescheme_eq (OVERLOADED_SCHEME BINARY,OVERLOADED_SCHEME BINARY) = 
	true
      | typescheme_eq (OVERLOADED_SCHEME BINARY,_) = false
      | typescheme_eq (OVERLOADED_SCHEME PREDICATE,
		       OVERLOADED_SCHEME PREDICATE) = true
      | typescheme_eq (OVERLOADED_SCHEME PREDICATE,_) = false
d601 1
a601 1
	| gather_names(namelist, META_OVERLOADED (ref atype)) =
d631 2
a632 1
      | tyvars (tyvarlist, UNBOUND_SCHEME atype) = Types.tyvars(tyvarlist, atype)
@


1.24
log
@Expanded structure does not match signature errors.
@
text
@d4 3
d112 2
d119 1
d461 1
a461 1
      fun instancep (val_name,type1,type2) = 
d467 2
a468 2
                               "\n  Spec   : " ^ Types.debug_print_type type1 ^
                               "\n  Actual : " ^ Types.debug_print_type type2 ^
d470 2
a471 2
                               "\n    in Spec   : " ^ (Types.debug_print_type ty) ^
			       "\n    in Actual : " ^ (Types.debug_print_type ty'))
d474 3
a476 3
                               "\n  Name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n  Spec   : " ^ Types.debug_print_type type1 ^
                               "\n  Actual : " ^ Types.debug_print_type type2 ^
d478 2
a479 2
                               "\n    in Spec   : " ^ (Types.debug_print_name name) ^
			       "\n    in Actual : " ^ (Types.debug_print_name name'))
d482 1
a482 1
                               "\n    Name : " ^ (IdentPrint.debug_printValId val_name) ^
d489 3
a491 3
                               "\n  Name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n  Spec   : " ^ Types.debug_print_type type1 ^
                               "\n  Actual : " ^ Types.debug_print_type type2 ^
d493 2
a494 2
                               "\n    in Spec   : " ^ (Types.debug_print_type ty) ^ 
			       "\n    in Actual : " ^ (Types.debug_print_type ty'))
d498 4
a501 4
                               "\n  Name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n  Spec   : " ^ Types.debug_print_type type1 ^
                               "\n  Actual : " ^ Types.debug_print_type type2 ^
                               "\n  " ^ (Types.debug_print_type ty) ^ 
d512 1
a512 1
                               "\n    Name : " ^ (IdentPrint.debug_printValId val_name) ^
d514 2
a515 2
			       (Types.debug_print_type ty) ^ "\n    and\n  " ^
			       (Types.debug_print_type ty'))
d519 1
a519 1
			       (Types.debug_print_type ty))
d524 1
a524 1
      fun scheme_generalises (name,_,UNBOUND_SCHEME atype,UNBOUND_SCHEME atype') =
d534 3
a536 3
                                        "\n    Name : ", (IdentPrint.debug_printValId name),
                                        "\n    Spec : ", (Types.debug_print_type atype),
                                        "\n    Actual : ", (Types.debug_print_type atype')])))
d538 1
a538 1
	| scheme_generalises (name,level,scheme,scheme') = 
d545 1
a545 1
	     instancep (name,skolemize scheme,instantiate (level,scheme')))
@


1.23
log
@Error message revisions.
@
text
@d4 3
d460 6
a465 3
                               "\n    Name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n    Spec : " ^ (Types.debug_print_type ty) ^
			       "\n    Actual : " ^ (Types.debug_print_type ty'))
d468 6
a473 3
                               "\n    Name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n    Spec : " ^ (Types.debug_print_name name) ^
			       "\n    Actual :  " ^ (Types.debug_print_name name'))
d478 1
a478 1
			       "\n    Spec : " ^ (string_domain domain) ^ 
d483 6
a488 3
                               "\n    Name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n    Spec : " ^ (Types.debug_print_type ty) ^ 
			       "\n    Actual : " ^ (Types.debug_print_type ty'))
d491 13
a503 10
	      ("\n    Name : " ^ (IdentPrint.debug_printValId val_name) ^
               ", " ^ (Types.debug_print_type ty) ^ 
	       (if eq andalso not imp then
		  " requires equality attribute"
		else
		  if eq andalso imp 
		    then
		      " requires equality as well as imperative attributes"
		  else
		    " requires imperative attribute"))
@


1.22
log
@Error message revision
@
text
@d4 3
d446 1
a446 1
	"{" ^ (string_labels lablist) ^	"}\n"
d449 2
a450 2
            [] => "{ ... }\n"
          | _ => "{" ^ (string_labels lablist) ^ ", ... }\n"
d456 4
a459 4
	    raise EnrichError ("\n    name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n    spec : " ^ (Types.debug_print_type ty) ^
			       "\n    actual : " ^ (Types.debug_print_type ty') ^
			       "\n")
d461 4
a464 3
	    raise EnrichError ("\n    name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n    spec : " ^ (Types.debug_print_name name) ^
			       "\n    actual :  " ^ (Types.debug_print_name name') ^ "\n")
d466 6
a471 5
	    raise EnrichError ("\n    name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\nDomains of record types differ : \n  " ^
			       "    spec : " ^ (string_domain domain) ^ 
			       "\n    actual : " ^ 
			       (string_domain domain') ^ "\n")
d473 4
a476 3
	    raise EnrichError ("\n    name : " ^ (IdentPrint.debug_printValId val_name) ^
                               "\n    spec : " ^ (Types.debug_print_type ty) ^ 
			       "\n    actual : " ^ (Types.debug_print_type ty') ^ "\n")
d479 1
a479 1
	      ("\n    name : " ^ (IdentPrint.debug_printValId val_name) ^
d488 1
a488 1
		    " requires imperative attribute\n"))
d490 2
a491 1
	    raise EnrichError ("\n    name : " ^ (IdentPrint.debug_printValId val_name) ^
d496 2
a497 1
	    raise EnrichError ("\nCannot unify overloaded type with " ^ 
d512 4
a515 3
            raise EnrichError (implode ["\n    name : ", (IdentPrint.debug_printValId name),
                                        "\n    spec : ", (Types.debug_print_type atype),
                                        "\n    actual : ", (Types.debug_print_type atype')])))
@


1.21
log
@Changes to error messages.
Fixed problem of silent error in scheme_generalises
@
text
@d4 4
d141 1
a141 1
	  raise MakeScheme ("unresolved flexible record ",ty)
@


1.20
log
@Changed handling of overloaded variable errors.
@
text
@d4 3
d456 1
a456 2
			       "\n    actual :  " ^
			       (Types.debug_print_name name') ^ "\n")
d466 1
a466 2
			       "\n    actual : \n  " ^
			       (Types.debug_print_type ty') ^ "\n")
d470 1
a470 1
               "\n" ^ (Types.debug_print_type ty) ^ 
d499 5
a503 1
	   Types.type_eq (atype,atype',true,true))
@


1.19
log
@Further improvements to gather_names
@
text
@d4 3
d106 2
a107 1
    exception MakeScheme of (string * Type)
d127 1
a127 1
	  raise MakeScheme ("unresolved overloaded variable ",ty)
@


1.18
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d546 22
a567 27
      fun gather_names (CONSTYPE (tylist,tyname),namelist) = 
	if (uninstantiated tyname) then
	  (follow tyname :: (gather_tylist_names (tylist,namelist)))
	else gather_tylist_names (tylist,namelist)
	| gather_names (FUNTYPE (atype,atype'),namelist) = 
	  gather_names (atype,gather_names (atype',namelist))
	| gather_names (RECTYPE amap,namelist) =
	  gather_tylist_names (Mapping.range amap,namelist)
(*
	| gather_names (TYVAR _,namelist) = namelist
*)
	| gather_names (METATYVAR (ref (_,atype),_,_),namelist) =
	  gather_names (atype,namelist)
	| gather_names (META_OVERLOADED (ref atype),namelist) =
	  gather_names (atype,namelist)
	| gather_names (METARECTYPE (ref (_,_,atype,_,_)),namelist) =
	  gather_names (atype,namelist)
(*
	| gather_names (DEBRUIJN _,namelist) = namelist
	| gather_names (NULLTYPE,namelist) = namelist
*)
	| gather_names(_, namelist) = namelist
	  
    and gather_tylist_names ([],namelist) = namelist
      | gather_tylist_names (ty::tys,namelist) = 
	gather_tylist_names (tys,gather_names (ty,namelist))

d569 2
a570 2
      fun gather_tynames (UNBOUND_SCHEME atype) = gather_names (atype,[])
	| gather_tynames (SCHEME (_,atype)) = gather_names (atype,[])
d573 1
a573 1
    
@


1.17
log
@Redid instance to make sub_vec constant and remove a parameter
@
text
@d4 3
d253 1
a253 1
		   Print.print (Types.print_type avar);
d284 1
a284 1
				(Types.print_type scheme_type)))
d381 1
a381 1
		   Print.print (Types.print_type (tyexp));
d409 10
a418 6
    fun string_scheme (OVERLOADED_SCHEME UNARY) = "ALL{}.num -> num"
      | string_scheme (OVERLOADED_SCHEME BINARY) = "ALL{}.num * num -> num"
      | string_scheme (OVERLOADED_SCHEME PREDICATE) = "ALL{}.num * num -> bool"
      | string_scheme (UNBOUND_SCHEME aty) = "ALL{}." ^ (Types.print_type aty)
      | string_scheme (SCHEME (n,aty)) = "ALL{"^ (Integer.makestring n)^"}."
	^ (Types.print_type aty)
d438 3
a440 3
	    raise EnrichError ("\n    name : " ^ (IdentPrint.printValId val_name) ^
                               "\n    spec : " ^ (Types.print_type ty) ^
			       "\n    actual : " ^ (Types.print_type ty') ^
d443 2
a444 2
	    raise EnrichError ("\n    name : " ^ (IdentPrint.printValId val_name) ^
                               "\n    spec : " ^ (Types.print_name name) ^
d446 1
a446 1
			       (Types.print_name name') ^ "\n")
d448 1
a448 1
	    raise EnrichError ("\n    name : " ^ (IdentPrint.printValId val_name) ^
d454 2
a455 2
	    raise EnrichError ("\n    name : " ^ (IdentPrint.printValId val_name) ^
                               "\n    spec : " ^ (Types.print_type ty) ^ 
d457 1
a457 1
			       (Types.print_type ty') ^ "\n")
d460 2
a461 2
	      ("\n    name : " ^ (IdentPrint.printValId val_name) ^
               "\n" ^ (Types.print_type ty) ^ 
d471 1
a471 1
	    raise EnrichError ("\n    name : " ^ (IdentPrint.printValId val_name) ^
d473 2
a474 2
			       (Types.print_type ty) ^ "\n    and\n  " ^
			       (Types.print_type ty'))
d477 1
a477 1
			       (Types.print_type ty))
d486 2
a487 2
		 Print.print ("atype = " ^ Types.print_type (atype) ^ "\n");
		 Print.print ("atype' = " ^ Types.print_type (atype'));
d513 2
a514 2
		   Print.print ("atype = " ^ Types.print_type (atype));
		   Print.print ("atype' = " ^ Types.print_type (atype'));
d522 2
a523 2
		   Print.print ("atype = " ^ Types.print_type (atype));
		   Print.print ("atype' = " ^ Types.print_type (atype'));
@


1.16
log
@Added special maps for tyfun_id, tyname_id, strname_id
@
text
@d4 3
d320 10
a329 9
	let 
	  fun instance (_,t as (TYVAR _)) = t
	    | instance (sub_vec,(RECTYPE amap)) =
	      RECTYPE (Mapping.mapit (amap, (fn x => (instance (sub_vec,x)))))
	    | instance (sub_vec, FUNTYPE(arg,res)) =
	      FUNTYPE (instance (sub_vec,arg),instance (sub_vec,res))
	    | instance (sub_vec, CONSTYPE (tylist,tyname)) =
	      CONSTYPE (map (fn x => (instance (sub_vec,x))) tylist,tyname)
	    | instance (sub_vec,DEBRUIJN (n,eq,imp)) = 
a331 2
		fun nulltypep NULLTYPE = true
		  | nulltypep _ = false
d333 4
a336 3
		if nulltypep (asub)
		  then
		    let val new_meta = METATYVAR (ref (alevel,NULLTYPE),eq,imp)
d341 1
a341 2
		else
		  asub
d343 1
a343 1
	    | instance (_,NULLTYPE) =
d345 30
a374 10
	    | instance (_,t as (METATYVAR (ref (_,NULLTYPE),_,_))) = t
	    | instance (sub_vec,(METATYVAR (ref (_,ty),_,_))) = 
              instance (sub_vec,ty)
	    | instance (_,t as (META_OVERLOADED (ref NULLTYPE))) = t
	    | instance (_,t as (META_OVERLOADED (ref ty))) = ty
	    | instance (sub_vec,
                        (METARECTYPE (ref (_,true,t as METARECTYPE _,_,_)))) =
              instance (sub_vec,t)
	    | instance (_,t as (METARECTYPE (ref (_,true,_,_,_)))) = t
	    | instance (_,METARECTYPE (ref (_,_,ty,_,_))) = ty
d385 1
a385 1
	     instance (Array.array (n,NULLTYPE),tyexp))
@


1.15
log
@Fixed problem with printing record domains.
@
text
@d4 3
a83 3
(*
  sharing NewMap = Types.NewMap
*)
a88 1
    structure NewMap = Datatypes.NewMap
@


1.14
log
@Modified gather_names to be simpler
@
text
@d4 3
d394 1
d400 1
a400 4
	"{" ^
	(implode (rev (Lists.tl (rev (explode
				      (string_labels lablist)))))) ^
	"}\n"
d402 3
a404 1
	  "{" ^ (string_labels lablist) ^ "... }\n"
@


1.13
log
@Yet more changes to get structure copying working better.
@
text
@d4 3
d519 1
d521 1
d528 1
d531 2
@


1.12
log
@Changed tyvars function to take a tuple of arguments.
@
text
@d4 3
d547 6
a552 16
    fun scheme_copy (s as SCHEME (n,atype),tyname_copies,tynamecopy_fun) = 
      let val (atype',tyname_copies') = 
	Types.type_copy (atype,tyname_copies,tynamecopy_fun) 
        handle Types.Instantiated => (atype,tyname_copies)
      in 
	(SCHEME (n,atype'),tyname_copies')
      end
      | scheme_copy (UNBOUND_SCHEME atype,tyname_copies,tynamecopy_fun) =
	let val (atype',tyname_copies') = 
	  Types.type_copy (atype,tyname_copies,tynamecopy_fun)
	  handle Types.Instantiated => (atype,tyname_copies)
	in 
	  (UNBOUND_SCHEME atype',tyname_copies')
	end
      | scheme_copy (scheme as OVERLOADED_SCHEME _,tyname_copies,_) = 
	(scheme,tyname_copies)
@


1.11
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d561 3
a563 5
    fun tyvars (SCHEME (_,atype)) tyvarlist = Types.tyvars atype tyvarlist
      | tyvars (UNBOUND_SCHEME atype) tyvarlist = 
	Types.tyvars atype tyvarlist
      | tyvars _ _ =
	Crash.impossible "Scheme.tyvars"
@


1.10
log
@Removed use of Array parameter to allow pervasive Array to be used
@
text
@d4 3
a41 1
require "../utils/newmap";
a47 1
require "../typechecker/datatypes";
a52 1
  structure NewMap : NEWMAP
a62 1
  structure Datatypes : DATATYPES
d67 2
a68 1
  sharing Types.Datatypes = Unify.Datatypes = Datatypes
d70 2
d74 1
a74 1
    structure Datatypes = Datatypes
d76 1
a76 1
    structure NewMap = NewMap
d382 1
a382 1
	  (Datatypes.IdentPrint.printLab label) ^ ": -," ^
d397 1
a397 1
	    raise EnrichError ("\n    name : " ^ (Datatypes.IdentPrint.printValId val_name) ^
d402 1
a402 1
	    raise EnrichError ("\n    name : " ^ (Datatypes.IdentPrint.printValId val_name) ^
d407 1
a407 1
	    raise EnrichError ("\n    name : " ^ (Datatypes.IdentPrint.printValId val_name) ^
d413 1
a413 1
	    raise EnrichError ("\n    name : " ^ (Datatypes.IdentPrint.printValId val_name) ^
d419 1
a419 1
	      ("\n    name : " ^ (Datatypes.IdentPrint.printValId val_name) ^
d430 1
a430 1
	    raise EnrichError ("\n    name : " ^ (Datatypes.IdentPrint.printValId val_name) ^
@


1.9
log
@Changed to use btrees for renaming of tynames and strnames
@
text
@d4 3
a41 1
require "../utils/array";
a59 1
  structure Array : ARRAY
@


1.8
log
@Added the printing of the name of the relevant identifier in a couple of error messages
@
text
@d4 3
d36 1
d50 1
d67 3
a69 2
  sharing Types.Datatypes = Unify.Datatypes = Datatypes) 
  : TYPESCHEME =
d73 1
@


1.7
log
@Modifications to sort out unification of flexible record types in order
to provide full information to the lambda translation
@
text
@d4 4
d383 1
a383 1
      fun instancep (type1,type2) = 
d387 2
a388 1
	    raise EnrichError ("\n    spec : " ^ (Types.print_type ty) ^
d392 2
a393 1
	    raise EnrichError ("\n    spec : " ^ (Types.print_name name) ^
d397 2
a398 1
	    raise EnrichError ("\nDomains of record types differ : \n  " ^
d403 2
a404 1
	    raise EnrichError ("\n    spec : " ^ (Types.print_type ty) ^ 
d409 2
a410 1
	      ("\n" ^ (Types.print_type ty) ^ 
d420 2
a421 1
	    raise EnrichError ("\nCircular type results from unifying \n"^
d431 1
a431 1
      fun scheme_generalises (_,UNBOUND_SCHEME atype,UNBOUND_SCHEME atype') =
d440 1
a440 1
	| scheme_generalises (level,scheme,scheme') = 
d447 1
a447 1
	     instancep (skolemize scheme,instantiate (level,scheme')))
@


1.6
log
@Changed call of type_equalityp to call of tyvar_erqualityp in order to
preserve significance of the equality attribute of type variables.
@
text
@d4 4
d90 4
a93 1
	| generalise (_ ,ty as METARECTYPE (ref (_,true,_,_,_))) = 
d307 1
a307 2
		    let val new_meta = METATYVAR 
		      (ref (alevel,NULLTYPE),eq,imp)
d318 2
a319 1
	    | instance (_,(METATYVAR (ref (_,ty),_,_))) = ty
d322 3
@


1.5
log
@Added use of variable from ty_debug, with local copy, to control
debug output. For efficiency reasons
@
text
@d4 4
d124 1
a124 1
	  let val new_debruijn = DEBRUIJN (n,Types.type_equalityp h,
d231 1
a231 1
				  Types.type_equalityp avar,
@


1.4
log
@Updated to allow valenv in METATYNAME
@
text
@d4 3
d19 1
a19 5
require "../typechecker/scheme";
require "../typechecker/types";
require "../typechecker/datatypes";
require "../typechecker/unify";
require "../basics/identprint";
d26 6
d33 18
a50 14
functor Scheme (structure Types : TYPES
		structure Datatypes : DATATYPES
		structure Unify : UNIFY
		structure Set : SET
		structure Lists : LISTS
		structure Debug : sig val set_debug_level : int -> unit
				      val debug_level : unit -> int
				  end
		structure Array : ARRAY
		structure Integer : INTEGER
		structure IdentPrint : IDENTPRINT
		structure Print : PRINT
		structure Crash : CRASH
		sharing Types.Datatypes = Unify.Datatypes = Datatypes) 
d56 1
d145 1
a145 1
	(if (Debug.debug_level () > 10) 
d161 1
a161 1
	    (if (Debug.debug_level () > 10) 
d169 1
a169 1
	      (if (Debug.debug_level () > 10) 
d207 1
a207 1
	  (if (Debug.debug_level () > 10) 
d239 1
a239 1
	  (if (Debug.debug_level () > 10) 
d314 1
a314 1
	  (if (Debug.debug_level () > 10) 
d408 1
a408 1
	(if (Debug.debug_level () > 10) 
d417 1
a417 1
	  (if (Debug.debug_level () > 10) 
d435 1
a435 1
	  (if (Debug.debug_level () > 10) 
d444 1
a444 1
	  (if (Debug.debug_level () > 10) 
@


1.3
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_scheme.sml,v $
d446 1
a446 1
      fun follow (name as METATYNAME (ref (NULL_TYFUN _),_,_,_)) =
d448 1
a448 1
	| follow (METATYNAME (ref (ETA_TYFUN (name)),_,_,_)) =
d452 2
a453 2
      fun uninstantiated (METATYNAME (ref (NULL_TYFUN _),_,_,_)) = true
	| uninstantiated (METATYNAME (ref (ETA_TYFUN (name)),_,_,_)) =
@


1.2
log
@Put in a catch-all and Crash.impossible to avoid a match
not exhaustive warning.
@
text
@d1 1
d4 4
d11 1
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d507 2
a508 1

a509 4




@
