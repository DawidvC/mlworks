head	1.24;
access;
symbols
	MLW_daveb_inline_1_4_99:1.24.3
	MLWorks_21c0_1999_03_25:1.24
	MLWorks_20c1_1998_08_20:1.24
	MLWorks_20c0_1998_08_04:1.24
	MLWorks_20b2c2_1998_06_19:1.24
	MLWorks_20b2_Windows_1998_06_12:1.24
	MLWorks_20b1c1_1998_05_07:1.24
	MLWorks_20b0_1998_04_07:1.24
	MLWorks_20b0_1998_03_20:1.24
	MLWorks_20m2_1998_02_16:1.24
	MLWorks_20m1_1997_10_23:1.24
	MLWorks_11r1:1.23.8.1.1.1.1
	MLWorks_workspace_97:1.24.2
	MLWorks_dt_wizard:1.24.1
	MLWorks_11c0_1997_09_09:1.23.8.1.1.1
	MLWorks_10r3:1.23.8.1.3
	MLWorks_10r2_551:1.23.8.1.2
	MLWorks_11:1.23.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.23.8.1
	MLWorks_20m0_1997_06_20:1.24
	MLWorks_1_0_r2c2_1997_06_14:1.23.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.23.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.23.8
	MLWorks_BugFix_1997_04_24:1.23
	MLWorks_1_0_r2_Win32_1997_04_11:1.23
	MLWorks_1_0_r2_Unix_1997_04_04:1.23
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.23.6.1.1
	MLWorks_gui_1996_12_18:1.23.7
	MLWorks_1_0_Win32_1996_12_17:1.23.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.23.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.23.4.1
	MLWorks_1_0_Irix_1996_11_28:1.23.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.23.5
	MLWorks_1_0_Unix_1996_11_14:1.23.4
	MLWorks_Open_Beta2_1996_10_11:1.23.3
	MLWorks_License_dev:1.23.2
	MLWorks_1_open_beta_1996_09_13:1.23.1
	MLWorks_Open_Beta_1996_08_22:1.23
	MLWorks_Beta_1996_07_02:1.22
	MLWorks_Beta_1996_06_07:1.22
	MLWorks_Beta_1996_06_06:1.22
	MLWorks_Beta_1996_06_05:1.22
	MLWorks_Beta_1996_06_03:1.22
	MLWorks_Beta_1996_05_31:1.22
	MLWorks_Beta_1996_05_30:1.22
	ML_beta_release_12/08/94:1.15
	ML_beta_release_03/08/94:1.15
	ML_revised_beta_release_25/05/94:1.15
	ML_final_beta_release_02/03/94:1.15
	mlworks-28-01-1994:1.15
	Release:1.14
	mlworks-beta-01-09-1993:1.14
	MLWorks-1-0-4-29/01/1993:1.13
	MLWorks-1-0-3-21/12/1992:1.13
	MLWorks-1-0-2-15/12/1992:1.13
	MLWorks-1-0-1-04/12/1992:1.13
	checkpoint_17_08_92:1.8;
locks; strict;
comment	@ * @;


1.24
date	97.05.01.13.15.39;	author jont;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1;
next	1.23;

1.23
date	96.08.05.17.55.49;	author andreww;	state Exp;
branches
	1.23.1.1
	1.23.2.1
	1.23.3.1
	1.23.4.1
	1.23.5.1
	1.23.6.1
	1.23.7.1
	1.23.8.1;
next	1.22;

1.22
date	96.02.22.13.20.20;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	95.12.27.12.01.04;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	95.08.10.14.48.46;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	95.07.14.11.26.19;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	95.05.01.10.16.22;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	95.03.17.19.28.06;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	95.02.07.14.15.35;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.09.16.14.48.54;	author nosa;	state Exp;
branches;
next	1.14;

1.14
date	93.07.12.09.01.43;	author nosa;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	92.11.24.16.57.39;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	92.10.12.09.58.52;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.09.25.12.09.16;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.09.10.10.18.31;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.08.24.19.34.34;	author davidt;	state Exp;
branches;
next	1.8;

1.8
date	92.08.12.17.44.26;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.08.06.16.03.54;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.08.03.14.24.50;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	92.06.16.08.25.57;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.03.23.11.17.00;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.01.24.23.27.12;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	92.01.24.17.29.19;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	92.01.23.12.11.31;	author jont;	state Exp;
branches;
next	;

1.14.1.1
date	93.07.12.09.01.43;	author jont;	state Exp;
branches;
next	;

1.23.1.1
date	96.09.13.11.19.16;	author hope;	state Exp;
branches;
next	;

1.23.2.1
date	96.10.07.16.09.08;	author hope;	state Exp;
branches;
next	;

1.23.3.1
date	96.10.17.11.27.24;	author hope;	state Exp;
branches;
next	;

1.23.4.1
date	96.11.14.12.52.56;	author hope;	state Exp;
branches
	1.23.4.1.1.1;
next	;

1.23.4.1.1.1
date	96.11.28.15.03.56;	author hope;	state Exp;
branches;
next	;

1.23.5.1
date	96.11.22.18.11.59;	author hope;	state Exp;
branches;
next	;

1.23.6.1
date	96.12.17.17.50.28;	author hope;	state Exp;
branches
	1.23.6.1.1.1;
next	;

1.23.6.1.1.1
date	97.02.24.11.40.48;	author hope;	state Exp;
branches;
next	;

1.23.7.1
date	96.12.18.09.44.37;	author hope;	state Exp;
branches;
next	;

1.23.8.1
date	97.05.12.10.37.08;	author hope;	state Exp;
branches
	1.23.8.1.1.1
	1.23.8.1.2.1
	1.23.8.1.3.1;
next	;

1.23.8.1.1.1
date	97.07.28.18.22.24;	author daveb;	state Exp;
branches
	1.23.8.1.1.1.1.1;
next	;

1.23.8.1.1.1.1.1
date	97.10.07.11.48.04;	author jkbrook;	state Exp;
branches;
next	;

1.23.8.1.2.1
date	97.09.08.17.15.47;	author daveb;	state Exp;
branches;
next	;

1.23.8.1.3.1
date	97.09.09.14.11.41;	author daveb;	state Exp;
branches;
next	;

1.24.1.1
date	97.09.10.19.27.45;	author brucem;	state Exp;
branches;
next	;

1.24.2.1
date	97.09.11.20.57.42;	author daveb;	state Exp;
branches;
next	;

1.24.3.1
date	99.04.01.17.58.26;	author daveb;	state Exp;
branches;
next	;


desc
@A collection of utilities for extracting constructor information from types
@


1.24
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* _type_utils.sml the functor *)
(*
$Log: _type_utils.sml,v $
 * Revision 1.23  1996/08/05  17:55:49  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml: passing
 * use_value_polymorphism argument everywhere.
 *
 * Revision 1.22  1996/02/22  13:20:20  jont
 * Replacing Map with NewMap
 *
 * Revision 1.21  1995/12/27  12:01:04  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.20  1995/08/10  14:48:46  daveb
Added words to the set of integral types.

Revision 1.19  1995/07/14  11:26:19  jont
Allow char to be an integral type

Revision 1.18  1995/05/01  10:16:22  matthew
Fixing problem with flexible record types

Revision 1.17  1995/03/17  19:28:06  daveb
Removed unused parameter Print.

Revision 1.16  1995/02/07  14:15:35  matthew
Log: Adding the_type for use by mir_cg

Revision 1.15  1993/09/16  14:48:54  nosa
Instances in schemes for polymorphic debugger.

Revision 1.14  1993/07/12  09:01:43  nosa
structure Option.

Revision 1.13  1992/11/24  16:57:39  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.12  1992/10/12  09:58:52  clive
Tynames now have a slot recording their definition point

Revision 1.11  1992/09/25  12:09:16  jont
Changed get_no_cons to use NewMap.size

Revision 1.10  1992/09/10  10:18:31  jont
Added predicates for has nullary constructors and has value carrying
constructors. Should be more efficient

Revision 1.9  1992/08/24  19:34:34  davidt
Took out message about following empty valenvs.

Revision 1.8  1992/08/12  17:44:26  jont
Fixed get_valenv to follow TYFUN(CONSTYPE) as well as ETA_TYFUN

Revision 1.7  1992/08/06  16:03:54  jont
Anel's changes to use NewMap instead of Map

Revision 1.5  1992/06/16  08:25:57  jont
Modifications to sort out unification of flexible record types in order
to provide full information to the lambda translation

Revision 1.4  1992/03/23  11:17:00  jont
Changed length for Lists.length

Revision 1.3  1992/01/24  23:27:12  jont
Added functionality to get valenvs from METATYNAMES and get domain
of record types

Revision 1.2  1992/01/24  17:29:19  jont
Modified the reference to METATYNAME to be flexible

Revision 1.1  1992/01/23  12:11:31  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/crash";
require "../utils/lists";
require "../typechecker/types";
require "type_utils";

functor TypeUtils(
  structure Crash : CRASH
  structure Lists : LISTS
  structure Types : TYPES
 ) : TYPE_UTILS =
  struct
    structure Datatypes = Types.Datatypes
    structure NewMap = Datatypes.NewMap
    structure Ident = Datatypes.Ident
    structure Symbol = Ident.Symbol

    fun get_cons_type(Datatypes.FUNTYPE(_, ty2)) = ty2
    | get_cons_type(ty as Datatypes.CONSTYPE _) = ty
    | get_cons_type _ = Crash.impossible "get_cons_type on non-constructed type"

    fun get_valenv (Datatypes.CONSTYPE
		    (_, Datatypes.TYNAME {5=ref (Datatypes.VE (_, valenv)),6=location,
					  ...})) =
      (case location of SOME x => x | NONE => "",valenv)
    | get_valenv(Datatypes.CONSTYPE
		   (_, tyname as Datatypes.METATYNAME{1 = ref tyfun,
					    5=ref(Datatypes.VE(_, valenv)),
					    ...})) =
      if NewMap.is_empty valenv then
	let
	  val (new_tyname, ok) = case tyfun of
	    Datatypes.TYFUN(Datatypes.CONSTYPE(_, tyname), _) =>
	      (tyname, true)
	  | Datatypes.ETA_TYFUN tyname => (tyname, true)
	  | _ => (tyname, false)
	in
	  if ok then
	    get_valenv(Datatypes.CONSTYPE([], new_tyname))
	  else
	    ("",valenv)
	end
      else
	("",valenv)
    | get_valenv ty =
      Crash.impossible("bad ty '" ^ Types.debug_print_type 
                                    Types.Options.default_options ty
                       ^ "' in get_valenv")

      (* any old options should do for the impossible case *)


    fun get_no_cons ty =
      NewMap.size (#2(get_valenv (get_cons_type ty)))

    fun type_from_scheme(Datatypes.SCHEME(_, (the_type,_))) = the_type
    | type_from_scheme(Datatypes.UNBOUND_SCHEME (the_type,_)) = the_type
    | type_from_scheme _ = Crash.impossible"OVERLOADED_SCHEME"

    fun is_vcc(Datatypes.FUNTYPE _) = true
    | is_vcc(Datatypes.CONSTYPE _) = false
    | is_vcc Datatypes.NULLTYPE = false
    | is_vcc _ = Crash.impossible"is_vcc on non-constructed type"

    val vcc_fun = is_vcc o type_from_scheme
    val null_fun = not o vcc_fun
    val null_exists = NewMap.exists (null_fun o #2) 
    val vcc_exists = NewMap.exists (vcc_fun o #2) 
    val vcc_len = Lists.filter_length vcc_fun
    val null_len = Lists.filter_length null_fun

    val get_no_vcc_cons = vcc_len o NewMap.range o #2 o get_valenv o get_cons_type

    val get_no_null_cons = null_len o NewMap.range o #2 o get_valenv o get_cons_type

    val has_null_cons = null_exists o #2 o get_valenv o get_cons_type

    val has_value_cons = vcc_exists o #2 o get_valenv o get_cons_type

    (*
     * A type is integral if it either has no value carrying constructors,
     * or it is int or char. Note that string and real are not integral.
     *)

    fun is_integral ty =
      case Types.the_type ty of
	(ty as Datatypes.CONSTYPE(_,tyname)) =>
	  Types.tyname_eq(tyname, Types.int_tyname) orelse
	  Types.tyname_eq(tyname, Types.word_tyname) orelse
	  Types.tyname_eq(tyname, Types.char_tyname) orelse
	  (case NewMap.to_list(#2(get_valenv ty)) of
	     [] =>
	       false
	   | assoc => 
	       Lists.forall (not o is_vcc o type_from_scheme o #2) assoc)
      | _ => false
          
  (* The two type utilities we need in _mir_cg *)

    fun is_integral2 primTy =
      case Types.the_type primTy of
        ty as Datatypes.RECTYPE _ =>
          is_integral(Types.get_type_from_lab (Ident.LAB(Symbol.find_symbol "2"), ty))
      | _ => false

    fun is_integral3 primTy =
      case Types.the_type primTy of
        ty as Datatypes.RECTYPE _ =>
          is_integral(Types.get_type_from_lab (Ident.LAB(Symbol.find_symbol "3"), ty))
      | _ => false


  end
@


1.24.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.24  1997/05/01  13:15:39  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.24.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.24  1997/05/01  13:15:39  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.24.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.24  1997/05/01  13:15:39  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.23
log
@[Bug #1521]
propagating changes to typechecker/_types.sml: passing
use_value_polymorphism argument everywhere.
@
text
@d4 5
d102 1
a102 1
      (case location of MLWorks.Option.SOME x => x | MLWorks.Option.NONE => "",valenv)
@


1.23.8.1
log
@branched from 1.23
@
text
@a3 5
 * Revision 1.23  1996/08/05  17:55:49  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml: passing
 * use_value_polymorphism argument everywhere.
 *
@


1.23.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.23.8.1  1997/05/12  10:37:08  hope
 * branched from 1.23
 *
@


1.23.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.23.8.1  1997/05/12  10:37:08  hope
 * branched from 1.23
 *
@


1.23.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.23.8.1  1997/05/12  10:37:08  hope
 * branched from 1.23
 *
@


1.23.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.23.8.1.1.1  1997/07/28  18:22:24  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.23.7.1
log
@branched from 1.23
@
text
@a3 5
 * Revision 1.23  1996/08/05  17:55:49  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml: passing
 * use_value_polymorphism argument everywhere.
 *
@


1.23.6.1
log
@branched from 1.23
@
text
@a3 5
 * Revision 1.23  1996/08/05  17:55:49  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml: passing
 * use_value_polymorphism argument everywhere.
 *
@


1.23.6.1.1.1
log
@branched from 1.23.6.1
@
text
@a3 3
 * Revision 1.23.6.1  1996/12/17  17:50:28  hope
 * branched from 1.23
 *
@


1.23.5.1
log
@branched from 1.23
@
text
@a3 5
 * Revision 1.23  1996/08/05  17:55:49  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml: passing
 * use_value_polymorphism argument everywhere.
 *
@


1.23.4.1
log
@branched from 1.23
@
text
@a3 5
 * Revision 1.23  1996/08/05  17:55:49  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml: passing
 * use_value_polymorphism argument everywhere.
 *
@


1.23.4.1.1.1
log
@branched from 1.23.4.1
@
text
@a3 3
 * Revision 1.23.4.1  1996/11/14  12:52:56  hope
 * branched from 1.23
 *
@


1.23.3.1
log
@branched from 1.23
@
text
@a3 5
 * Revision 1.23  1996/08/05  17:55:49  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml: passing
 * use_value_polymorphism argument everywhere.
 *
@


1.23.2.1
log
@branched from 1.23
@
text
@a3 5
 * Revision 1.23  1996/08/05  17:55:49  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml: passing
 * use_value_polymorphism argument everywhere.
 *
@


1.23.1.1
log
@branched from 1.23
@
text
@a3 5
 * Revision 1.23  1996/08/05  17:55:49  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml: passing
 * use_value_polymorphism argument everywhere.
 *
@


1.22
log
@Replacing Map with NewMap
@
text
@d4 3
d118 6
a123 1
      Crash.impossible("bad ty '" ^ Types.debug_print_type ty ^ "' in get_valenv")
@


1.21
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
a83 1
    structure Map = Datatypes.Mapping
@


1.20
log
@Added words to the set of integral types.
@
text
@d4 3
d92 1
a92 1
      (case location of Datatypes.Option.PRESENT x => x | Datatypes.Option.ABSENT => "",valenv)
@


1.19
log
@Allow char to be an integral type
@
text
@d4 3
d148 1
@


1.18
log
@Fixing problem with flexible record types
@
text
@d4 3
d138 1
a138 1
     * or it is int. Note that string and real are not integral.
d145 1
@


1.17
log
@Removed unused parameter Print.
@
text
@d4 3
a131 18

    fun record_domain(Datatypes.RECTYPE map) = Map.domain map
    | record_domain(Datatypes.METARECTYPE(ref (_,flex,
                                               ty as Datatypes.METARECTYPE _,
                                               _,_))) =
      if flex 
        then record_domain ty 
      else 
        Crash.impossible 
          "contradiction between boolean and type in METARECTYPE 1"
    | record_domain(Datatypes.METARECTYPE(ref (_,flex,
                                               ty as Datatypes.RECTYPE _,
                                               _,_))) =
      if flex 
        then Crash.impossible 
               "contradiction between boolean and type in METARECTYPE 2"
      else record_domain ty
    | record_domain _ = Crash.impossible ("record_tag(2)")
@


1.16
log
@Log: Adding the_type for use by mir_cg
@
text
@d4 3
a57 1
require "../utils/print";
a63 1
  structure Print : PRINT
@


1.15
log
@Instances in schemes for polymorphic debugger.
@
text
@d4 3
d59 1
a59 1
functor Type_Utils(
d66 5
a70 4
    structure DataTypes = Types.Datatypes
    structure NewMap = DataTypes.NewMap
    structure Map = DataTypes.Mapping
    structure Ident = DataTypes.Ident
d72 2
a73 2
    fun get_cons_type(DataTypes.FUNTYPE(_, ty2)) = ty2
    | get_cons_type(ty as DataTypes.CONSTYPE _) = ty
d76 2
a77 2
    fun get_valenv (DataTypes.CONSTYPE
		    (_, DataTypes.TYNAME {5=ref (DataTypes.VE (_, valenv)),6=location,
d79 4
a82 4
      (case location of DataTypes.Option.PRESENT x => x | DataTypes.Option.ABSENT => "",valenv)
    | get_valenv(DataTypes.CONSTYPE
		   (_, tyname as DataTypes.METATYNAME{1 = ref tyfun,
					    5=ref(DataTypes.VE(_, valenv)),
d87 1
a87 1
	    DataTypes.TYFUN(DataTypes.CONSTYPE(_, tyname), _) =>
d89 1
a89 1
	  | DataTypes.ETA_TYFUN tyname => (tyname, true)
d93 1
a93 1
	    get_valenv(DataTypes.CONSTYPE([], new_tyname))
d105 2
a106 2
    fun type_from_scheme(DataTypes.SCHEME(_, (the_type,_))) = the_type
    | type_from_scheme(DataTypes.UNBOUND_SCHEME (the_type,_)) = the_type
d109 3
a111 3
    fun is_vcc(DataTypes.FUNTYPE _) = true
    | is_vcc(DataTypes.CONSTYPE _) = false
    | is_vcc DataTypes.NULLTYPE = false
d129 3
a131 3
    fun record_domain(DataTypes.RECTYPE map) = Map.domain map
    | record_domain(DataTypes.METARECTYPE(ref (_,flex,
                                               ty as DataTypes.METARECTYPE _,
d138 2
a139 2
    | record_domain(DataTypes.METARECTYPE(ref (_,flex,
                                               ty as DataTypes.RECTYPE _,
d154 1
a154 1
	(ty as DataTypes.CONSTYPE(_,tyname)) =>
d162 16
@


1.14
log
@structure Option.
@
text
@d4 3
d101 2
a102 2
    fun type_from_scheme(DataTypes.SCHEME(_, the_type)) = the_type
    | type_from_scheme(DataTypes.UNBOUND_SCHEME the_type) = the_type
@


1.14.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.14  1993/07/12  09:01:43  nosa
structure Option.

@


1.13
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d72 1
a72 1
      (case location of DataTypes.PRESENT x => x | DataTypes.ABSENT => "",valenv)
d109 2
a110 2
    val null_exists = NewMap.exists (null_fun o #2)
    val vcc_exists = NewMap.exists (vcc_fun o #2)
@


1.12
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d89 1
a89 1
      Crash.impossible("bad ty '" ^ Types.print_type ty ^ "' in get_valenv")
@


1.11
log
@Changed get_no_cons to use NewMap.size
@
text
@d4 3
d63 1
a63 1
		    (_, DataTypes.TYNAME {5=ref (DataTypes.VE (_, valenv)),
d65 1
a65 1
      valenv
d81 1
a81 1
	    valenv
d84 1
a84 1
	valenv
d89 1
a89 1
      NewMap.size (get_valenv (get_cons_type ty))
d107 1
a107 1
    val get_no_vcc_cons = vcc_len o NewMap.range o get_valenv o get_cons_type
d109 1
a109 1
    val get_no_null_cons = null_len o NewMap.range o get_valenv o get_cons_type
d111 1
a111 1
    val has_null_cons = null_exists o get_valenv o get_cons_type
d113 1
a113 1
    val has_value_cons = vcc_exists o get_valenv o get_cons_type
d142 1
a142 1
	  (case NewMap.to_list(get_valenv ty) of
@


1.10
log
@Added predicates for has nullary constructors and has value carrying
constructors. Should be more efficient
@
text
@d4 4
d86 1
a86 1
      Lists.length (NewMap.domain (get_valenv (get_cons_type ty)))
@


1.9
log
@Took out message about following empty valenvs.
@
text
@d4 3
d90 1
d93 6
a98 3
    fun get_no_vcc_cons ty =
      Lists.filter_length (is_vcc o type_from_scheme)
      (NewMap.range (get_valenv (get_cons_type ty)))
d100 7
a106 3
    fun get_no_null_cons ty =
      Lists.filter_length (not o is_vcc o type_from_scheme)
      (NewMap.range (get_valenv (get_cons_type ty)))
@


1.8
log
@Fixed get_valenv to follow TYFUN(CONSTYPE) as well as ETA_TYFUN
@
text
@d4 3
d41 1
a41 2

) : TYPE_UTILS =
d50 1
a50 2
    | get_cons_type _ =
      Crash.impossible "get_cons_type on non-constructed type"
d61 12
a72 19
	(Print.print"get_valenv finds empty valenv, trying to follow\n";
	 let
	   val (new_tyname, ok) = case tyfun of
	     DataTypes.TYFUN(DataTypes.CONSTYPE(_, tyname), _) =>
	       (tyname, true)
	   | DataTypes.ETA_TYFUN tyname => (tyname, true)
	   | _ => (tyname, false)
	 in
	   if ok then
	     let
	       val valenv = get_valenv(DataTypes.CONSTYPE([], new_tyname))
	       val _ = Print.print"Got new valenv\n"
	     in
	       valenv
	     end
	   else
	     (Print.print"get_valenv fails to follow tyfun\n";
	      valenv)
	 end)
d76 1
a76 25
      let
	val _ = Print.print
	  (case ty of
	     DataTypes.METATYVAR _ => "METATYVAR"
	   | DataTypes.META_OVERLOADED _ => "META_OVERLOADED"
	   | DataTypes.TYVAR _ => "TYVAR"
	   | DataTypes.METARECTYPE _ => "METARECTYPE"
	   | DataTypes.RECTYPE _ => "RECTYPE"
	   | DataTypes.FUNTYPE _ => "FUNTYPE"
	   | DataTypes.CONSTYPE(l, t) =>
	       "CONSTYPE\n" ^
	       (case t of
		  DataTypes.TYNAME _ => "TYNAME"
		| DataTypes.METATYNAME{1=ref tyfun, ...} =>
		    "METATYNAME\n" ^
		    (case tyfun of
		       DataTypes.TYFUN _ => "TYFUN"
		     | DataTypes.ETA_TYFUN _ => "ETA_TYFUN"
		     | DataTypes.NULL_TYFUN _ => "NULL_TYFUN")
		       )
	   | DataTypes.DEBRUIJN _ => "DEBRUIJN"
	   | DataTypes.NULLTYPE => "NULLTYPE")
      in
	Crash.impossible("bad ty '" ^ Types.print_type ty ^ "' in get_valenv")
      end
@


1.7
log
@Anel's changes to use NewMap instead of Map
@
text
@d4 3
d63 2
a64 1
	     DataTypes.TYFUN _ => (tyname, false)
d66 1
a66 1
	   | DataTypes.NULL_TYFUN _ => (tyname, false)
@


1.6
log
@Added is_integral function.
@
text
@a25 1
require "../utils/map";
a26 2
require "../basics/ident";
require "../typechecker/datatypes";
a32 1
  structure Map : MAP
a33 2
  structure Ident : IDENTCLASS
  structure DataTypes : DATATYPES
a35 3
  sharing Map = DataTypes.Mapping
  sharing DataTypes = Types.Datatypes
  sharing Ident = DataTypes.Ident
d38 4
a41 3
    structure Map = Map
    structure Ident = Ident
    structure DataTypes = DataTypes
d48 3
a50 3
    fun get_valenv(DataTypes.CONSTYPE
		   (_, DataTypes.TYNAME{5=ref(DataTypes.VE(_, valenv)),
					...})) =
d53 2
a54 1
		   (_, DataTypes.METATYNAME{5=ref(DataTypes.VE(_, valenv)),
d56 21
a76 1
      valenv
d105 1
a105 1
      Lists.length(Map.domain(get_valenv(get_cons_type ty)))
d117 1
a117 1
      (Map.range(get_valenv(get_cons_type ty)))
d121 1
a121 1
      (Map.range(get_valenv(get_cons_type ty)))
d133 2
a134 1
                                               ty as DataTypes.RECTYPE _,_,_)))=
d150 1
a150 1
	  (case Map.assoc(get_valenv ty) of
@


1.5
log
@Modifications to sort out unification of flexible record types in order
to provide full information to the lambda translation
@
text
@d4 4
d127 15
@


1.4
log
@Changed length for Lists.length
@
text
@d4 3
d107 14
a120 2
    | record_domain(DataTypes.METARECTYPE(ref{3=ty, ...})) =
      record_domain ty
@


1.3
log
@Added functionality to get valenvs from METATYNAMES and get domain
of record types
@
text
@d4 4
d85 1
a85 1
      length(Map.domain(get_valenv(get_cons_type ty)))
@


1.2
log
@Modified the reference to METATYNAME to be flexible
@
text
@d4 3
d17 1
d27 1
d33 1
d36 2
d40 4
a43 4
    fun get_cons_type ty = case ty of
      DataTypes.FUNTYPE(_, ty2) => ty2
    | DataTypes.CONSTYPE _ => ty
    | _ => Crash.impossible "get_cons_type on non-constructed type"
d45 8
a52 2
    fun get_valenv(DataTypes.CONSTYPE(_,
				      DataTypes.TYNAME(_, _, _, _, ref (DataTypes.VE(_, valenv))))) = valenv
d98 5
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d53 1
a53 1
		| DataTypes.METATYNAME(ref tyfun, _, _, _) =>
@
