head	1.32;
branch	1;
access;
symbols
	MLW_daveb_inline_1_4_99:1.32.3
	MLWorks_21c0_1999_03_25:1.32
	MLWorks_20c1_1998_08_20:1.32
	MLWorks_20c0_1998_08_04:1.32
	MLWorks_20b2c2_1998_06_19:1.32
	MLWorks_20b2_Windows_1998_06_12:1.32
	MLWorks_20b1c1_1998_05_07:1.32
	MLWorks_20b0_1998_04_07:1.32
	MLWorks_20b0_1998_03_20:1.32
	MLWorks_20m2_1998_02_16:1.32
	MLWorks_20m1_1997_10_23:1.32
	MLWorks_11r1:1.31.8.1.1.1.1
	MLWorks_workspace_97:1.32.2
	MLWorks_dt_wizard:1.32.1
	MLWorks_11c0_1997_09_09:1.31.8.1.1.1
	MLWorks_10r3:1.31.8.1.3
	MLWorks_10r2_551:1.31.8.1.2
	MLWorks_11:1.31.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.31.8.1
	MLWorks_20m0_1997_06_20:1.32
	MLWorks_1_0_r2c2_1997_06_14:1.31.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.31.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.31.8
	MLWorks_BugFix_1997_04_24:1.31
	MLWorks_1_0_r2_Win32_1997_04_11:1.31
	MLWorks_1_0_r2_Unix_1997_04_04:1.31
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.31.6.1.1
	MLWorks_gui_1996_12_18:1.31.7
	MLWorks_1_0_Win32_1996_12_17:1.31.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.31.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.31.4.1
	MLWorks_1_0_Irix_1996_11_28:1.31.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.31.5
	MLWorks_1_0_Unix_1996_11_14:1.31.4
	MLWorks_Open_Beta2_1996_10_11:1.31.3
	MLWorks_License_dev:1.31.2
	MLWorks_1_open_beta_1996_09_13:1.31.1
	MLWorks_Open_Beta_1996_08_22:1.31
	MLWorks_Beta_1996_07_02:1.31
	MLWorks_Beta_1996_06_07:1.31
	MLWorks_Beta_1996_06_06:1.31
	MLWorks_Beta_1996_06_05:1.31
	MLWorks_Beta_1996_06_03:1.31
	MLWorks_Beta_1996_05_31:1.31
	MLWorks_Beta_1996_05_30:1.31
	ML_beta_release_12/08/94:1.25
	ML_beta_release_03/08/94:1.25
	ML_revised_beta_release_25/05/94:1.21
	ML_final_beta_release_02/03/94:1.21
	mlworks-28-01-1994:1.20
	Release:1.17
	mlworks-beta-01-09-1993:1.17
	MLWorks-1-0-4-29/01/1993:1.12
	MLWorks-1-0-3-21/12/1992:1.11
	MLWorks-1-0-2-15/12/1992:1.11
	MLWorks-1-0-1-04/12/1992:1.11
	checkpoint_17_08_92:1.8
	Ten15_release_19-11-91:1.2.1.1
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.32
date	97.05.01.15.35.30;	author jont;	state Exp;
branches
	1.32.1.1
	1.32.2.1
	1.32.3.1;
next	1.31;

1.31
date	95.12.11.16.06.30;	author jont;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1
	1.31.4.1
	1.31.5.1
	1.31.6.1
	1.31.7.1
	1.31.8.1;
next	1.30;

1.30
date	95.09.05.15.02.40;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	95.08.10.10.28.42;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	95.08.03.14.55.51;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	95.01.09.12.25.44;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	94.09.14.12.46.27;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	94.06.28.10.15.44;	author nosa;	state Exp;
branches;
next	1.24;

1.24
date	94.06.27.16.43.28;	author nosa;	state Exp;
branches;
next	1.23;

1.23
date	94.06.27.09.46.44;	author nosa;	state Exp;
branches;
next	1.22;

1.22
date	94.06.21.09.19.52;	author nosa;	state Exp;
branches;
next	1.21;

1.21
date	94.02.21.20.41.53;	author nosa;	state Exp;
branches;
next	1.20;

1.20
date	94.01.17.10.42.02;	author nosa;	state Exp;
branches;
next	1.19;

1.19
date	93.08.12.10.25.44;	author nosa;	state Exp;
branches;
next	1.18;

1.18
date	93.08.12.09.25.44;	author nosa;	state Exp;
branches;
next	1.17;

1.17
date	93.08.06.14.39.50;	author matthew;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	93.07.30.10.43.21;	author nosa;	state Exp;
branches;
next	1.15;

1.15
date	93.07.21.15.01.53;	author nosa;	state Exp;
branches;
next	1.14;

1.14
date	93.03.09.12.12.13;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.02.01.16.36.37;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.01.12.11.31.46;	author nosa;	state Exp;
branches;
next	1.11;

1.11
date	92.11.26.12.35.45;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	92.11.04.15.19.11;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.09.24.09.09.07;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.07.22.09.37.46;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	92.01.24.11.26.47;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.01.23.13.42.09;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.01.22.19.38.05;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.11.21.16.34.09;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.19.12.16.38;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.24.13.50.17;	author colin;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	91.06.07.11.06.27;	author colin;	state Exp;
branches;
next	;

1.2.1.1
date	91.11.19.11.12.23;	author jont;	state Exp;
branches;
next	;

1.17.1.1
date	93.08.06.14.39.50;	author jont;	state Exp;
branches;
next	;

1.31.1.1
date	96.09.13.11.19.13;	author hope;	state Exp;
branches;
next	;

1.31.2.1
date	96.10.07.16.09.06;	author hope;	state Exp;
branches;
next	;

1.31.3.1
date	96.10.17.11.27.21;	author hope;	state Exp;
branches;
next	;

1.31.4.1
date	96.11.14.12.52.53;	author hope;	state Exp;
branches
	1.31.4.1.1.1;
next	;

1.31.4.1.1.1
date	96.11.28.15.03.53;	author hope;	state Exp;
branches;
next	;

1.31.5.1
date	96.11.22.18.11.56;	author hope;	state Exp;
branches;
next	;

1.31.6.1
date	96.12.17.17.50.26;	author hope;	state Exp;
branches
	1.31.6.1.1.1;
next	;

1.31.6.1.1.1
date	97.02.24.11.40.45;	author hope;	state Exp;
branches;
next	;

1.31.7.1
date	96.12.18.09.44.34;	author hope;	state Exp;
branches;
next	;

1.31.8.1
date	97.05.12.10.37.05;	author hope;	state Exp;
branches
	1.31.8.1.1.1
	1.31.8.1.2.1
	1.31.8.1.3.1;
next	;

1.31.8.1.1.1
date	97.07.28.18.22.21;	author daveb;	state Exp;
branches
	1.31.8.1.1.1.1.1;
next	;

1.31.8.1.1.1.1.1
date	97.10.07.11.48.01;	author jkbrook;	state Exp;
branches;
next	;

1.31.8.1.2.1
date	97.09.08.17.15.45;	author daveb;	state Exp;
branches;
next	;

1.31.8.1.3.1
date	97.09.09.14.11.38;	author daveb;	state Exp;
branches;
next	;

1.32.1.1
date	97.09.10.19.27.43;	author brucem;	state Exp;
branches;
next	;

1.32.2.1
date	97.09.11.20.57.40;	author daveb;	state Exp;
branches;
next	;

1.32.3.1
date	99.04.01.17.58.24;	author daveb;	state Exp;
branches;
next	;


desc
@Match Compiler
@


1.32
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* match.sml the signature *)
(*
$Log: match.sml,v $
 * Revision 1.31  1995/12/11  16:06:30  jont
 * Add some comments to clarify some of the interface
 *
Revision 1.30  1995/09/05  15:02:40  daveb
Added optional size information to SCONs.

Revision 1.29  1995/08/10  10:28:42  jont
Modifications to allow defaults to be optional in special constant matches

Revision 1.28  1995/08/03  14:55:51  jont
Remove Option in favour of MLWorks.Option

Revision 1.27  1995/01/09  12:25:44  matthew
Tidying up

Revision 1.26  1994/09/14  12:46:27  matthew
Abstraction of debug information

Revision 1.25  1994/06/28  10:15:44  nosa
Matchvars in special constructors.

Revision 1.24  1994/06/27  16:43:28  nosa
Bindings in Match DEFAULT trees.

Revision 1.23  1994/06/27  09:46:44  nosa
Exhaustiveness and Redundancy Checking Revision.

Revision 1.22  1994/06/21  09:19:52  nosa
Spurious redundancy Bug Fix by removing side-effects in exhaustiveness checking.

Revision 1.21  1994/02/21  20:41:53  nosa
Type function spills for Modules Debugger.

Revision 1.20  1994/01/17  10:42:02  nosa
Dynamic pattern-redundancy reporting;
Correct Exception Pattern Matching

Revision 1.18  1993/08/12  09:25:44  nosa
Compilation instances paired in type refs for polymorphic debugger.

Revision 1.17  1993/08/06  14:39:50  matthew
Added location information to matches

Revision 1.16  1993/07/30  10:43:21  nosa
Type information in LEAFs for local and closure variable inspection
in the debugger; structure Option.

Revision 1.15  1993/07/21  15:01:53  nosa
More informative inexhaustiveness reporting

Revision 1.14  1993/03/09  12:12:13  matthew
Options & Info changes
Absyn changes

Revision 1.13  1993/02/01  16:36:37  matthew
Added sharing constraint

Revision 1.12  1993/01/12  11:31:46  nosa
Deleted label handling in lambda translator.

Revision 1.10  1992/11/04  15:19:11  jont
Changes to allow IntNewMap to be used on MatchVar

Revision 1.9  1992/09/24  09:09:07  clive
Allowed the compiler to change the order of the clauses if it could prove them to be disjoint
 Allowed the system to choose the order for looking at tuple elements (used to be left to right)

Revision 1.8  1992/07/22  09:37:46  matthew
Changed interface to match compiler to for passing back of redundancy and exhaustiveness information

Revision 1.7  1992/01/24  11:26:47  jont
Removed superfluous space from middle of a longid which NJ erroneously
failed to notice (but we did!)

Revision 1.6  1992/01/23  13:42:09  jont
Removed open datatypes

Revision 1.5  1992/01/22  19:38:05  jont
Removed exception impossible (now done by Crash.impossible)

Revision 1.4  1991/11/21  16:34:09  jont
Added copyright message

Revision 1.3  91/11/19  12:16:38  jont
Merging in comments from Ten15 branch to main trunk

Revision 1.2.1.1  91/11/19  11:12:23  jont
Added comments for DRA on functions

Revision 1.2  91/06/24  13:50:17  colin
Changed match tree to give LongValIds rather than ValIds in CONSTRUCTOR
nodes - needed to code generate longexcons where the path must be kept

Revision 1.1  91/06/07  11:06:27  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

(* The match compiler. For efficient pattern-matching, one must match
against all patterns in a set simultaneously, rather than
sequentially. This means that pattern-matches (which occur in all
function expressions and exception handlers in ML) must be transformed
into lambda calculus by a special algorithm. The function
compile_match in this module performs the difficult part of this
transformation: from match expressions to match trees (the other part,
match-trees to lambda-calculus, is done in codegen/cg). The essential
algorithm and datastructures used are as described by Philip Wadler in
"Efficient Compilation of Pattern-Matching", chapter 5 of "The
Implementation of Functional Programming Languages", Simon L.
Peyton-Jones, Prentice-Hall 1987.

Unfortunately, neither Wadler's algorithm nor this (modified) version
is capable of handling the full generality of ML pattern-matching, so
it does not identify all cases of redundancy and exhuastiveness *)

require "../basics/absyn" ;
require "../main/options" ;

signature MATCH =
  sig
    structure Options : OPTIONS
    structure Absyn : ABSYN

    eqtype Matchvar
    eqtype lvar

    val to_Matchvar : int -> Matchvar
    val from_Matchvar : Matchvar -> int

    datatype ('a, 'b) union = INL of 'a | INR of 'b

    datatype Constructors =
      CON1 of int list
    | CON2 of Absyn.Ident.LongValId * Matchvar
    | SCON1 of string list
    | SCON2 of string * Matchvar
    | REC of (Absyn.Ident.Lab * Matchvar) list

    datatype 'env Tree =
        LEAF of Absyn.Exp * int * (Matchvar * Absyn.Ident.ValId * (Absyn.Type ref * Absyn.RuntimeInfo ref)) list
      | SCON of Matchvar * (Absyn.Ident.SCon * 'env Tree) list
	* 'env DefaultTree ref option *
        ((int * 'env Tree),lvar) union ref option ref option
	* int option
      | CONSTRUCTOR of
          Absyn.Type * Matchvar
	  * (Absyn.Ident.LongValId * Matchvar
	     * ('env Tree,((int * 'env Tree),lvar) union ref) union) list
	  * ('env DefaultTree ref option,((int * 'env Tree),lvar) union ref) union *
	  (((int * 'env Tree),lvar) union ref option ref,
	   ((int * 'env Tree),lvar) union ref * Matchvar) union list * bool
      | RECORD of Absyn.Type * Matchvar
	* (Absyn.Ident.Lab * Matchvar) list * 'env Tree
      | DEFAULT of 'env DefaultTree ref *
        ((int * 'env Tree),lvar) union ref option ref option

    and 'env DefaultTree =
      UNBUILT of ('env -> 'env Tree)
      * ((int * 'env Tree),lvar) union ref option ref * 'env * bool
      | UNBUILT' of ('env -> 'env Tree)
        * ((int * 'env Tree),lvar) union ref option ref * 'env * bool
      | BUILT of ((int * 'env Tree),lvar) union ref
      | ERROR of (Absyn.Type * Absyn.Ident.ValId list) list -> unit

    (* NB, UNBUILT & UNBUILT' above are only used internally *)
    (* by the match compiler, and should never occur outside *)

    datatype expression =
      && of expression * expression |
      || of expression * expression |
      == of Absyn.Ident.LongValId * Absyn.Ident.LongValId |
      TRUE |
      FALSE

    val compile_match :
      (Absyn.Pat * Absyn.Exp * Absyn.Ident.Location.T) list ->
      Matchvar *
      (int * Constructors) list list Tree *
      (int * expression) list *
      (Absyn.Type * Absyn.Ident.ValId list) list option

    val unparseTree : Options.print_options -> '_env Tree -> string -> string list

  end
@


1.32.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.32  1997/05/01  15:35:30  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.32.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.32  1997/05/01  15:35:30  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.32.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.32  1997/05/01  15:35:30  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.31
log
@Add some comments to clarify some of the interface
@
text
@d4 3
d134 2
d146 3
a148 3
	* 'env DefaultTree ref MLWorks.Option.option *
        ((int * 'env Tree),lvar) MLWorks.Option.union ref MLWorks.Option.option ref MLWorks.Option.option
	* int MLWorks.Option.option
d152 4
a155 4
	     * ('env Tree,((int * 'env Tree),lvar) MLWorks.Option.union ref) MLWorks.Option.union) list
	  * ('env DefaultTree ref MLWorks.Option.option,((int * 'env Tree),lvar) MLWorks.Option.union ref) MLWorks.Option.union *
	  (((int * 'env Tree),lvar) MLWorks.Option.union ref MLWorks.Option.option ref,
	   ((int * 'env Tree),lvar) MLWorks.Option.union ref * Matchvar) MLWorks.Option.union list * bool
d159 1
a159 1
        ((int * 'env Tree),lvar) MLWorks.Option.union ref MLWorks.Option.option ref MLWorks.Option.option
d163 1
a163 1
      * ((int * 'env Tree),lvar) MLWorks.Option.union ref MLWorks.Option.option ref * 'env * bool
d165 2
a166 2
        * ((int * 'env Tree),lvar) MLWorks.Option.union ref MLWorks.Option.option ref * 'env * bool
      | BUILT of ((int * 'env Tree),lvar) MLWorks.Option.union ref
d184 1
a184 1
      (Absyn.Type * Absyn.Ident.ValId list) list MLWorks.Option.option
@


1.31.8.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1995/12/11  16:06:30  jont
 * Add some comments to clarify some of the interface
 *
@


1.31.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.31.8.1  1997/05/12  10:37:05  hope
 * branched from 1.31
 *
@


1.31.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.31.8.1  1997/05/12  10:37:05  hope
 * branched from 1.31
 *
@


1.31.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.31.8.1  1997/05/12  10:37:05  hope
 * branched from 1.31
 *
@


1.31.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.31.8.1.1.1  1997/07/28  18:22:21  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.31.7.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1995/12/11  16:06:30  jont
 * Add some comments to clarify some of the interface
 *
@


1.31.6.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1995/12/11  16:06:30  jont
 * Add some comments to clarify some of the interface
 *
@


1.31.6.1.1.1
log
@branched from 1.31.6.1
@
text
@a3 3
 * Revision 1.31.6.1  1996/12/17  17:50:26  hope
 * branched from 1.31
 *
@


1.31.5.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1995/12/11  16:06:30  jont
 * Add some comments to clarify some of the interface
 *
@


1.31.4.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1995/12/11  16:06:30  jont
 * Add some comments to clarify some of the interface
 *
@


1.31.4.1.1.1
log
@branched from 1.31.4.1
@
text
@a3 3
 * Revision 1.31.4.1  1996/11/14  12:52:53  hope
 * branched from 1.31
 *
@


1.31.3.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1995/12/11  16:06:30  jont
 * Add some comments to clarify some of the interface
 *
@


1.31.2.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1995/12/11  16:06:30  jont
 * Add some comments to clarify some of the interface
 *
@


1.31.1.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1995/12/11  16:06:30  jont
 * Add some comments to clarify some of the interface
 *
@


1.30
log
@Added optional size information to SCONs.
@
text
@d4 3
d121 1
a121 1
  sig   
d131 1
a131 1
    datatype Constructors = 
d136 1
a136 1
    | REC of (Absyn.Ident.Lab * Matchvar) list 
d140 1
a140 1
      | SCON of Matchvar * (Absyn.Ident.SCon * 'env Tree) list 
d144 2
a145 2
      | CONSTRUCTOR of 
          Absyn.Type * Matchvar 
d147 2
a148 2
	     * ('env Tree,((int * 'env Tree),lvar) MLWorks.Option.union ref) MLWorks.Option.union) list 
	  * ('env Default,((int * 'env Tree),lvar) MLWorks.Option.union ref) MLWorks.Option.union * 
d151 3
a153 3
      | RECORD of Absyn.Type * Matchvar 
	* (Absyn.Ident.Lab * Matchvar) list * 'env Tree 
      | DEFAULT of 'env DefaultTree ref * 
d156 2
a157 4
    and 'env Default = PRESENT of  'env DefaultTree ref | ABSENT 

    and 'env DefaultTree = 
      UNBUILT of ('env -> 'env Tree) 
d159 1
a159 1
      | UNBUILT' of ('env -> 'env Tree) 
d161 1
a161 1
      | BUILT of ((int * 'env Tree),lvar) MLWorks.Option.union ref 
d164 3
d174 3
a176 3
    val compile_match : 
      (Absyn.Pat * Absyn.Exp * Absyn.Ident.Location.T) list -> 
      Matchvar * 
@


1.29
log
@Modifications to allow defaults to be optional in special constant matches
@
text
@d4 3
d140 1
@


1.28
log
@Remove Option in favour of MLWorks.Option
@
text
@d4 3
d135 1
a135 1
                 * 'env DefaultTree ref * 
d139 5
a143 5
                         * (Absyn.Ident.LongValId * Matchvar
                            * ('env Tree,((int * 'env Tree),lvar) MLWorks.Option.union ref) MLWorks.Option.union) list 
                          * ('env Default,((int * 'env Tree),lvar) MLWorks.Option.union ref) MLWorks.Option.union * 
        (((int * 'env Tree),lvar) MLWorks.Option.union ref MLWorks.Option.option ref,
         ((int * 'env Tree),lvar) MLWorks.Option.union ref * Matchvar) MLWorks.Option.union list * bool
d145 1
a145 1
                         * (Absyn.Ident.Lab * Matchvar) list * 'env Tree 
d152 2
a153 2
        UNBUILT of ('env -> 'env Tree) 
        * ((int * 'env Tree),lvar) MLWorks.Option.union ref MLWorks.Option.option ref * 'env * bool
@


1.27
log
@Tidying up
@
text
@d4 3
a108 1
require "../utils/option";
a114 1
    structure Option : OPTION
d133 1
a133 1
        ((int * 'env Tree),lvar) Option.option ref Option.opt ref Option.opt
d137 4
a140 4
                            * ('env Tree,((int * 'env Tree),lvar) Option.option ref) Option.option) list 
                          * ('env Default,((int * 'env Tree),lvar) Option.option ref) Option.option * 
        (((int * 'env Tree),lvar) Option.option ref Option.opt ref,
         ((int * 'env Tree),lvar) Option.option ref * Matchvar) Option.option list * bool
d144 1
a144 1
        ((int * 'env Tree),lvar) Option.option ref Option.opt ref Option.opt
d150 1
a150 1
        * ((int * 'env Tree),lvar) Option.option ref Option.opt ref * 'env * bool
d152 2
a153 2
        * ((int * 'env Tree),lvar) Option.option ref Option.opt ref * 'env * bool
      | BUILT of ((int * 'env Tree),lvar) Option.option ref 
d168 1
a168 1
      (Absyn.Type * Absyn.Ident.ValId list) list Option.opt
@


1.26
log
@Abstraction of debug information
@
text
@d4 3
d121 7
a127 6
    datatype constructors = 
	  Con1 of int list
	| Con2 of Absyn.Ident.LongValId * Matchvar
        | SCon1 of string list
        | SCon2 of string * Matchvar
        | Rec of (Absyn.Ident.Lab * Matchvar) list 
d131 1
a131 1
                 * 'env defaultTree ref * 
d142 1
a142 1
      | DEFAULT of 'env defaultTree ref * 
d144 4
a147 2
    and 'env Default = PRESENT of  'env defaultTree ref | ABSENT 
    and 'env defaultTree = 
d162 7
a168 4
    val compile_match : (Absyn.Pat * Absyn.Exp * Absyn.Ident.Location.T) list -> 
	Matchvar * (int * constructors) list list Tree *
        (int * expression) list *
        (Absyn.Type * Absyn.Ident.ValId list) list Option.opt
@


1.25
log
@Matchvars in special constructors.
@
text
@d4 3
d125 1
a125 3
        LEAF of Absyn.Exp * int * (Matchvar 
                   * Absyn.Ident.ValId * (Absyn.Type * Absyn.Instance ref Option.opt 
                           * (Absyn.Tyfun ref * (int,int) Option.option ref) list) ref) list
@


1.24
log
@Bindings in Match DEFAULT trees.
@
text
@d4 3
d119 1
a119 1
        | SCon2 of string
@


1.23
log
@Exhaustiveness and Redundancy Checking Revision.
@
text
@d4 3
d134 2
a135 1
      | DEFAULT of 'env defaultTree ref
@


1.22
log
@Spurious redundancy Bug Fix by removing side-effects in exhaustiveness checking.
@
text
@d4 3
d110 5
a114 9
	 Con1 of ((Absyn.Ident.SCon list,Absyn.Ident.LongValId list) Option.option 
		   * int * (Absyn.Ident.SCon list,
			    Absyn.Ident.LongValId list) Option.option * bool) * int 
	|Con2 of (Absyn.Ident.SCon,Absyn.Ident.LongValId) Option.option * bool
        |Rec of (Absyn.Ident.Lab * Matchvar) list 
    datatype 'entry environment = 
		NIL
	       |CONS of 'entry * 'entry environment
	       |CONS' of 'entry * ('entry environment * 'entry Option.opt ref) 
d131 1
d149 1
a149 3
	Matchvar * (Matchvar list * Matchvar Option.opt * ((int * (Absyn.Ident.SCon list,
			Absyn.Ident.LongValId list) Option.option) * int,
					constructors) Option.option) environment list Tree *
@


1.21
log
@Type function spills for Modules Debugger.
@
text
@d4 3
d109 2
a110 2
			    Absyn.Ident.LongValId list) Option.option * bool) ref * int 
	|Con2 of (Absyn.Ident.SCon,Absyn.Ident.LongValId) Option.option * bool ref
d150 1
a150 1
			Absyn.Ident.LongValId list) Option.option) ref * int,
@


1.20
log
@Dynamic pattern-redundancy reporting;
Correct Exception Pattern Matching
@
text
@d4 4
d115 2
a116 1
                   * Absyn.Ident.ValId * (Absyn.Type * Absyn.Instance ref Option.opt) ref) list
@


1.19
log
@Dynamic pattern-redundancy reporting;
Correct Exception Pattern Matching
@
text
@d113 2
a114 2
                 * 'env defaultTree ref * ((int * 'env Tree),lvar) 
        Option.option ref Option.opt ref
d117 5
a121 3
                         * (Absyn.Ident.LongValId * Matchvar * 'env Tree) list 
                          * 'env Default * ((int * 'env Tree),lvar) 
          Option.option ref Option.opt ref
d133 7
d141 1
a141 1
	(Matchvar * (Matchvar list * Matchvar Option.opt * ((int * (Absyn.Ident.SCon list,
d143 3
a145 2
					constructors) Option.option) environment list Tree 
        * int list * (Absyn.Type * Absyn.Ident.ValId list) list Option.opt)
@


1.18
log
@Compilation instances paired in type refs for polymorphic debugger.
@
text
@d4 3
@


1.17
log
@Added location information to matches
@
text
@d4 3
d108 1
a108 1
                   * Absyn.Ident.ValId * Absyn.Type ref) list
@


1.17.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.17  1993/08/06  14:39:50  matthew
Added location information to matches

@


1.16
log
@Type information in LEAFs for local and closure variable inspection
in the debugger; structure Option.
@
text
@d4 4
d125 1
a125 1
    val compile_match : (Absyn.Pat * Absyn.Exp) list -> 
@


1.15
log
@More informative inexhaustiveness reporting
@
text
@d4 3
d74 1
d81 1
a88 2
    datatype 'a option = SOME of 'a | NONE
    datatype ('a,'b) option' = SOME1 of 'a | SOME2 of 'b
d90 1
a90 1
	 Con1 of ((Absyn.Ident.SCon list,Absyn.Ident.LongValId list) option' 
d92 2
a93 2
			    Absyn.Ident.LongValId list) option' * bool) ref * int 
	|Con2 of (Absyn.Ident.SCon,Absyn.Ident.LongValId) option' * bool ref
d98 1
a98 1
	       |CONS' of 'entry * ('entry environment * 'entry option ref) 
d100 2
a101 2
        LEAF of Absyn.Exp * int 
                  * (Matchvar * Absyn.Ident.ValId * Absyn.Type) list
d103 2
a104 1
                 * 'env defaultTree ref * ((int * 'env Tree),lvar) option' ref option ref
d108 2
a109 1
                          * 'env Default * ((int * 'env Tree),lvar) option' ref option ref
d113 7
a119 6
    and 'env defaultTree = UNBUILT of ('env -> 'env Tree) 
                             * ((int * 'env Tree),lvar) option' ref option ref * 'env * bool
                          |UNBUILT' of ('env -> 'env Tree) 
                             * ((int * 'env Tree),lvar) option' ref option ref * 'env * bool
                          |BUILT of ((int * 'env Tree),lvar) option' ref 
                          |ERROR of (Absyn.Type * Absyn.Ident.ValId list) list -> unit
d122 4
a125 4
	(Matchvar * (Matchvar list * Matchvar option * ((int * (Absyn.Ident.SCon list,
			Absyn.Ident.LongValId list) option') ref * int,
					constructors) option') environment list Tree
        * int list * (Absyn.Type * Absyn.Ident.ValId list) list option)
@


1.14
log
@Options & Info changes
Absyn changes
@
text
@d4 4
d97 1
a97 2
        ERROR
      | LEAF of Absyn.Exp * int 
d113 1
d118 2
a119 2
					constructors) option') environment list Tree 
									     * int list * bool)
@


1.13
log
@Added sharing constraint
@
text
@d4 3
d67 1
a67 1
require "../main/info" ;
d71 1
a71 1
    structure Info : INFO
a73 2
    sharing Info.Location = Absyn.Location

d83 5
a87 5
	 Con1 of ((Absyn.Datatypes.Ident.SCon list,Absyn.Datatypes.Ident.LongValId list) option' 
		   * int * (Absyn.Datatypes.Ident.SCon list,
			    Absyn.Datatypes.Ident.LongValId list) option' * bool) ref * int 
	|Con2 of (Absyn.Datatypes.Ident.SCon,Absyn.Datatypes.Ident.LongValId) option' * bool ref
        |Rec of (Absyn.Datatypes.Ident.Lab * Matchvar) list 
d95 2
a96 2
                  * (Matchvar * Absyn.Datatypes.Ident.ValId * Absyn.Datatypes.Type) list
      | SCON of Matchvar * (Absyn.Datatypes.Ident.SCon * 'env Tree) list 
d99 2
a100 2
          Absyn.Datatypes.Type * Matchvar 
                         * (Absyn.Datatypes.Ident.LongValId * Matchvar * 'env Tree) list 
d102 2
a103 2
      | RECORD of Absyn.Datatypes.Type * Matchvar 
                         * (Absyn.Datatypes.Ident.Lab * Matchvar) list * 'env Tree 
d112 2
a113 2
	(Matchvar * (Matchvar list * Matchvar option * ((int * (Absyn.Datatypes.Ident.SCon list,
			Absyn.Datatypes.Ident.LongValId list) option') ref * int,
d116 1
a116 1
    val unparseTree : Info.options -> '_env Tree -> string -> string list
@


1.12
log
@Deleted label handling in lambda translator.
@
text
@d4 3
d69 1
d71 1
a71 1
    structure Absyn : ABSYN
@


1.11
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@a59 1
require "../utils/mononewmap";
d65 2
a67 2
    structure MatchMap : MONONEWMAP
    structure Info : INFO
d70 1
a70 2
    eqtype Label
    sharing type Matchvar = MatchMap.object
a73 29
    val label_number : Label -> int
    val referenced_only_once : Label -> bool

(** In case during debugging we raise an exception, it would be useful
    to be able to catch it.  Perhaps this should be from elsewhere
    though.
**)

    val do_debug : bool ref    (* so we can turn debugging on/off *)
    val do_reorder : bool ref  (* just in case I forget *)

    datatype Tree =
      
      ERROR |
      (* int is the index of the leaf, used in redundancy checking *)
      LEAF of Absyn.Exp * int * (Matchvar * Absyn.Datatypes.Ident.ValId * Absyn.Datatypes.Type) list |

      SCON of Matchvar * (Absyn.Datatypes.Ident.SCon * Tree) list * Default |

      CONSTRUCTOR of Absyn.Datatypes.Type * Matchvar * 
                     (Absyn.Datatypes.Ident.LongValId * Matchvar * Tree) list
                     * Default |

      RECORD of Absyn.Datatypes.Type * Matchvar * (Absyn.Datatypes.Ident.Lab * Matchvar) list * Tree |

      LABEL of Label * Tree |
      GOTO of Label

    and Default = PRESENT of Tree | ABSENT
d75 37
a111 3
    val compile_match : 
      Info.options -> (Absyn.Pat * Absyn.Exp) list -> (Matchvar * Tree * int list * bool)
    val unparseTree : Info.options -> Tree -> string -> string list
@


1.10
log
@Changes to allow IntNewMap to be used on MatchVar
@
text
@d4 3
d62 1
d68 1
d107 2
a108 2
      (Absyn.Pat * Absyn.Exp) list -> (Matchvar * Tree * int list * bool)
    val unparseTree : Tree -> string -> string list
@


1.9
log
@Allowed the compiler to change the order of the clauses if it could prove them to be disjoint
 Allowed the system to choose the order for looking at tuple elements (used to be left to right)
@
text
@d4 4
d57 1
a57 1
require "../typechecker/datatypes" ;
a61 1
    structure DataTypes : DATATYPES
d63 1
a64 2
    sharing Absyn.Datatypes = DataTypes

d67 1
d86 1
a86 1
      LEAF of Absyn.Exp * int * (Matchvar * DataTypes.Ident.ValId * DataTypes.Type) list |
d88 1
a88 1
      SCON of Matchvar * (DataTypes.Ident.SCon * Tree) list * Default |
d90 2
a91 2
      CONSTRUCTOR of DataTypes.Type * Matchvar * 
                     (DataTypes.Ident.LongValId * Matchvar * Tree) list
d94 1
a94 1
      RECORD of DataTypes.Type * Matchvar * (DataTypes.Ident.Lab * Matchvar) list * Tree |
@


1.8
log
@Changed interface to match compiler to for passing back of redundancy and exhaustiveness information
@
text
@d4 3
@


1.7
log
@Removed superfluous space from middle of a longid which NJ erroneously
failed to notice (but we did!)
@
text
@d4 4
d79 2
a80 1
      LEAF of Absyn.Exp * (Matchvar * DataTypes.Ident.ValId * DataTypes.Type) list |
d96 1
a96 1
      (Absyn.Pat * Absyn.Exp) list -> (Matchvar * Tree)
@


1.6
log
@Removed open datatypes
@
text
@d4 3
d83 1
a83 1
      RECORD of DataTypes.Type * Matchvar * (DataTypes.Ident .Lab * Matchvar) list * Tree |
@


1.5
log
@Removed exception impossible (now done by Crash.impossible)
@
text
@d4 3
d48 1
a48 1
    structure Datatypes : DATATYPES
d51 1
a51 1
    sharing Absyn.Datatypes = Datatypes
a52 2
    open Datatypes

d72 1
a72 1
      LEAF of Absyn.Exp * (Matchvar * Ident.ValId * Type) list |
d74 1
a74 1
      SCON of Matchvar * (Ident.SCon * Tree) list * Default |
d76 2
a77 2
      CONSTRUCTOR of Type * Matchvar * 
                     (Ident.LongValId * Matchvar * Tree) list
d80 1
a80 1
      RECORD of Type * Matchvar * (Ident.Lab * Matchvar) list * Tree |
@


1.4
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	match.sml,v $
a63 1
    exception impossible of string
@


1.3
log
@Merging in comments from Ten15 branch to main trunk
@
text
@d1 1
d4 3
d17 1
@


1.2
log
@Changed match tree to give LongValIds rather than ValIds in CONSTRUCTOR
nodes - needed to code generate longexcons where the path must be kept
@
text
@d3 7
d14 18
@


1.2.1.1
log
@Added comments for DRA on functions
@
text
@a2 4
Revision 1.2  91/06/24  13:50:17  colin
Changed match tree to give LongValIds rather than ValIds in CONSTRUCTOR
nodes - needed to code generate longexcons where the path must be kept

a6 18

(* The match compiler. For efficient pattern-matching, one must match
against all patterns in a set simultaneously, rather than
sequentially. This means that pattern-matches (which occur in all
function expressions and exception handlers in ML) must be transformed
into lambda calculus by a special algorithm. The function
compile_match in this module performs the difficult part of this
transformation: from match expressions to match trees (the other part,
match-trees to lambda-calculus, is done in codegen/cg). The essential
algorithm and datastructures used are as described by Philip Wadler in
"Efficient Compilation of Pattern-Matching", chapter 5 of "The
Implementation of Functional Programming Languages", Simon L.
Peyton-Jones, Prentice-Hall 1987.

Unfortunately, neither Wadler's algorithm nor this (modified) version
is capable of handling the full generality of ML pattern-matching, so
it does not identify all cases of redundancy and exhuastiveness *)

@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d44 1
a44 1
                     (Ident.ValId * Matchvar * Tree) list
@
