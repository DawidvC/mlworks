head	1.71;
branch	1;
access;
symbols
	MLW_daveb_inline_1_4_99:1.71.1
	MLWorks_21c0_1999_03_25:1.71
	MLWorks_20c1_1998_08_20:1.71
	MLWorks_20c0_1998_08_04:1.71
	MLWorks_20b2c2_1998_06_19:1.71
	MLWorks_20b2_Windows_1998_06_12:1.71
	MLWorks_20b1c1_1998_05_07:1.71
	MLWorks_20b0_1998_04_07:1.71
	MLWorks_20b0_1998_03_20:1.71
	MLWorks_20m2_1998_02_16:1.70
	MLWorks_20m1_1997_10_23:1.70
	MLWorks_11r1:1.67.5.1.1.1.1
	MLWorks_workspace_97:1.69.2
	MLWorks_dt_wizard:1.69.1
	MLWorks_11c0_1997_09_09:1.67.5.1.1.1
	MLWorks_10r3:1.67.5.1.3
	MLWorks_10r2_551:1.67.5.1.2
	MLWorks_11:1.67.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.67.5.1
	MLWorks_20m0_1997_06_20:1.69
	MLWorks_1_0_r2c2_1997_06_14:1.67.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.67.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.67.5
	MLWorks_BugFix_1997_04_24:1.67
	MLWorks_1_0_r2_Win32_1997_04_11:1.67
	MLWorks_1_0_r2_Unix_1997_04_04:1.67
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.67.3.1.1
	MLWorks_gui_1996_12_18:1.67.4
	MLWorks_1_0_Win32_1996_12_17:1.67.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.67.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.67.1.1
	MLWorks_1_0_Irix_1996_11_28:1.67.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.67.2
	MLWorks_1_0_Unix_1996_11_14:1.67.1
	MLWorks_Open_Beta2_1996_10_11:1.64.3
	MLWorks_License_dev:1.64.2
	MLWorks_1_open_beta_1996_09_13:1.64.1
	MLWorks_Open_Beta_1996_08_22:1.64
	MLWorks_Beta_1996_07_02:1.64
	MLWorks_Beta_1996_06_07:1.64
	MLWorks_Beta_1996_06_06:1.64
	MLWorks_Beta_1996_06_05:1.64
	MLWorks_Beta_1996_06_03:1.64
	MLWorks_Beta_1996_05_31:1.64
	MLWorks_Beta_1996_05_30:1.64
	ML_beta_release_12/08/94:1.45
	ML_beta_release_03/08/94:1.45
	ML_revised_beta_release_25/05/94:1.40
	ML_final_beta_release_02/03/94:1.40
	mlworks-28-01-1994:1.39
	Release:1.32
	mlworks-beta-01-09-1993:1.32
	MLWorks-1-0-4-29/01/1993:1.27
	MLWorks-1-0-3-21/12/1992:1.20
	MLWorks-1-0-2-15/12/1992:1.18
	MLWorks-1-0-1-04/12/1992:1.17
	checkpoint_17_08_92:1.10
	Ten15_release_19-11-91:1.2
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.71
date	98.02.20.09.14.20;	author mitchell;	state Exp;
branches
	1.71.1.1;
next	1.70;

1.70
date	97.09.18.16.01.14;	author brucem;	state Exp;
branches;
next	1.69;

1.69
date	97.05.19.11.23.04;	author jont;	state Exp;
branches
	1.69.1.1
	1.69.2.1;
next	1.68;

1.68
date	97.05.01.15.35.59;	author jont;	state Exp;
branches;
next	1.67;

1.67
date	96.11.06.11.30.33;	author matthew;	state Exp;
branches
	1.67.1.1
	1.67.2.1
	1.67.3.1
	1.67.4.1
	1.67.5.1;
next	1.66;

1.66
date	96.10.29.18.30.02;	author io;	state Exp;
branches;
next	1.65;

1.65
date	96.10.25.12.16.05;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	96.05.17.09.25.13;	author matthew;	state Exp;
branches
	1.64.1.1
	1.64.2.1
	1.64.3.1;
next	1.63;

1.63
date	96.04.30.16.24.43;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	96.04.29.14.54.45;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	95.12.27.12.02.08;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	95.12.11.16.11.58;	author jont;	state Exp;
branches;
next	1.59;

1.59
date	95.09.05.15.12.52;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	95.08.31.13.55.42;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	95.08.10.12.49.02;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	95.08.08.16.30.54;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	95.07.26.13.16.54;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	95.07.19.15.32.14;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	95.07.19.13.30.57;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	95.07.18.15.26.26;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	95.05.12.11.45.02;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	95.03.17.19.24.40;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	95.02.07.14.17.00;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	95.01.09.12.24.26;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	94.09.14.12.50.20;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	94.08.31.16.41.46;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	94.06.28.10.16.08;	author nosa;	state Exp;
branches;
next	1.44;

1.44
date	94.06.27.17.13.17;	author nosa;	state Exp;
branches;
next	1.43;

1.43
date	94.06.27.16.44.13;	author nosa;	state Exp;
branches;
next	1.42;

1.42
date	94.06.27.09.48.07;	author nosa;	state Exp;
branches;
next	1.41;

1.41
date	94.06.21.09.20.37;	author nosa;	state Exp;
branches;
next	1.40;

1.40
date	94.02.27.21.31.03;	author nosa;	state Exp;
branches;
next	1.39;

1.39
date	94.01.25.16.12.49;	author nosa;	state Exp;
branches;
next	1.38;

1.38
date	94.01.24.15.49.58;	author nosa;	state Exp;
branches;
next	1.37;

1.37
date	94.01.20.11.49.58;	author nosa;	state Exp;
branches;
next	1.36;

1.36
date	93.12.08.13.11.57;	author nosa;	state Exp;
branches;
next	1.35;

1.35
date	93.11.25.09.34.25;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.10.12.16.59.08;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	93.08.12.09.27.25;	author nosa;	state Exp;
branches;
next	1.32;

1.32
date	93.08.06.14.40.21;	author matthew;	state Exp;
branches
	1.32.1.1;
next	1.31;

1.31
date	93.07.30.10.38.04;	author nosa;	state Exp;
branches;
next	1.30;

1.30
date	93.07.21.15.09.19;	author nosa;	state Exp;
branches;
next	1.29;

1.29
date	93.05.18.17.06.31;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	93.03.09.13.38.36;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.01.25.13.42.23;	author nosa;	state Exp;
branches;
next	1.26;

1.26
date	93.01.19.19.04.14;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	93.01.15.12.52.59;	author nosa;	state Exp;
branches;
next	1.24;

1.24
date	93.01.14.17.10.56;	author nosa;	state Exp;
branches;
next	1.23;

1.23
date	93.01.14.17.06.21;	author nosa;	state Exp;
branches;
next	1.22;

1.22
date	93.01.14.16.59.14;	author nosa;	state Exp;
branches;
next	1.21;

1.21
date	93.01.13.12.28.01;	author nosa;	state Exp;
branches;
next	1.20;

1.20
date	92.12.21.20.10.54;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	92.12.17.18.19.07;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	92.12.08.18.34.51;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.11.26.12.35.11;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	92.11.04.15.28.35;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.10.28.10.24.30;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.09.30.10.09.15;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.09.25.16.07.14;	author clive;	state Exp;
branches;
next	1.12;

1.12
date	92.09.08.18.19.03;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	92.08.19.16.12.18;	author davidt;	state Exp;
branches;
next	1.10;

1.10
date	92.07.23.16.35.40;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.07.22.13.40.34;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	92.07.22.11.27.14;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	92.03.23.11.22.47;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.01.23.14.02.35;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.01.07.16.56.50;	author colin;	state Exp;
branches;
next	1.4;

1.4
date	91.11.27.12.47.06;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.21.16.33.28;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.24.14.03.20;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.11.06.16;	author colin;	state Exp;
branches;
next	;

1.32.1.1
date	93.08.06.14.40.21;	author jont;	state Exp;
branches;
next	;

1.64.1.1
date	96.09.13.11.19.11;	author hope;	state Exp;
branches;
next	;

1.64.2.1
date	96.10.07.16.09.03;	author hope;	state Exp;
branches;
next	;

1.64.3.1
date	96.10.17.11.27.19;	author hope;	state Exp;
branches;
next	;

1.67.1.1
date	96.11.14.12.52.49;	author hope;	state Exp;
branches
	1.67.1.1.1.1;
next	;

1.67.1.1.1.1
date	96.11.28.15.03.51;	author hope;	state Exp;
branches;
next	;

1.67.2.1
date	96.11.22.18.11.54;	author hope;	state Exp;
branches;
next	;

1.67.3.1
date	96.12.17.17.50.24;	author hope;	state Exp;
branches
	1.67.3.1.1.1;
next	;

1.67.3.1.1.1
date	97.02.24.11.40.43;	author hope;	state Exp;
branches;
next	;

1.67.4.1
date	96.12.18.09.44.32;	author hope;	state Exp;
branches;
next	;

1.67.5.1
date	97.05.12.10.37.02;	author hope;	state Exp;
branches
	1.67.5.1.1.1
	1.67.5.1.2.1
	1.67.5.1.3.1;
next	;

1.67.5.1.1.1
date	97.07.28.18.22.18;	author daveb;	state Exp;
branches
	1.67.5.1.1.1.1.1;
next	;

1.67.5.1.1.1.1.1
date	97.10.07.11.47.59;	author jkbrook;	state Exp;
branches;
next	;

1.67.5.1.2.1
date	97.09.08.17.15.42;	author daveb;	state Exp;
branches;
next	;

1.67.5.1.3.1
date	97.09.09.14.11.36;	author daveb;	state Exp;
branches;
next	;

1.69.1.1
date	97.09.10.19.27.40;	author brucem;	state Exp;
branches;
next	;

1.69.2.1
date	97.09.11.20.57.37;	author daveb;	state Exp;
branches;
next	;

1.71.1.1
date	99.04.01.17.58.23;	author daveb;	state Exp;
branches;
next	;


desc
@Match Compiler
@


1.71
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(*
$Log: _match.sml,v $
 * Revision 1.70  1997/09/18  16:01:14  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.69  1997/05/19  11:23:04  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.68  1997/05/01  15:35:59  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.67  1996/11/06  11:30:33  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.66  1996/10/29  18:30:02  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.65  1996/10/25  12:16:05  matthew
 * [Bug #1653]
 * Fixing problem with comparisons of same constructors in different structures
 *
 * Revision 1.64  1996/05/17  09:25:13  matthew
 * Moving Bits to MLWorks.Internal
 *
 * Revision 1.63  1996/04/30  16:24:43  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.62  1996/04/29  14:54:45  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.61  1995/12/27  12:02:08  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.60  1995/12/11  16:11:58  jont
Remove Default type constructor and its value constructors PRESENT and ABSENT
Use MLWorks.Option.option instead

Revision 1.59  1995/09/05  15:12:52  daveb
Added new types for different sizes of ints, words, and reals.

Revision 1.58  1995/08/31  13:55:42  jont
Add location info to wild pats

Revision 1.57  1995/08/10  12:49:02  jont
More tidying up and work on exhaustiveness on chars

Revision 1.56  1995/08/08  16:30:54  jont
Towards exhaustiveness checking on chars

Revision 1.55  1995/07/26  13:16:54  jont
Deal with word literal patterns

Revision 1.54  1995/07/19  15:32:14  jont
Add scons structure for scon_eqval

Revision 1.53  1995/07/19  13:30:57  jont
Add special constant chars

Revision 1.52  1995/07/18  15:26:26  jont
Sort out problems with redundancy on integer patterns
Add checking for equality between decimals and hexadecimals

Revision 1.51  1995/05/12  11:45:02  jont
Fix bug with multiple exception constructors over records

Revision 1.50  1995/03/17  19:24:40  daveb
removed redundant require.

Revision 1.49  1995/02/07  14:17:00  matthew
Renaming structures

Revision 1.48  1995/01/09  12:24:26  matthew
Tidying up

Revision 1.47  1994/09/14  12:50:20  matthew
Abstraction of debug information

Revision 1.46  1994/08/31  16:41:46  matthew
Better implementation of power

Revision 1.45  1994/06/28  10:16:08  nosa
Matchvars in special constructors.

Revision 1.44  1994/06/27  17:13:17  nosa
Oops - had forgotten to turn off show_match.

Revision 1.43  1994/06/27  16:44:13  nosa
Bindings in Match DEFAULT trees.

Revision 1.42  1994/06/27  09:48:07  nosa
Exhaustiveness and Redundancy Checking Revision.

Revision 1.41  1994/06/21  09:20:37  nosa
Spurious redundancy Bug Fix by removing side-effects in exhaustiveness checking.

Revision 1.40  1994/02/27  21:31:03  nosa
Type function spills for Modules Debugger;
Propagation of exception tree indicators in tree generation.

Revision 1.39  1994/01/25  16:12:49  nosa
Several removes and inserts now possible on redundant patterns.

Revision 1.38  1994/01/24  15:49:58  nosa
Pattern Duplication replaces swapping in exception trees.

Revision 1.37  1994/01/20  11:49:58  nosa
Dynamic pattern-redundancy reporting;
Correct Exception Pattern Matching

Revision 1.36  1993/12/08  13:11:57  nosa
Removed incorrect assumptions about distinction of exception constructors.

Revision 1.35  1993/11/25  09:34:25  matthew
Added fixity annotations to APPexps and APPpats

Revision 1.34  1993/10/12  16:59:08  jont
Removed an unnecessary map, using domain instead

Revision 1.33  1993/08/12  09:27:25  nosa
Compilation instances paired in type refs for polymorphic debugger.

Revision 1.32  1993/08/06  14:40:21  matthew
Added location information to matches

Revision 1.31  1993/07/30  10:38:04  nosa
Type information in LEAFs for local and closure variable inspection
in the debugger; structure Option.

Revision 1.30  1993/07/21  15:09:19  nosa
More informative inexhaustiveness reporting

Revision 1.29  1993/05/18  17:06:31  jont
Removed integer parameter

Revision 1.28  1993/03/09  13:38:36  matthew
Options & Info changes
Absyn changes

Revision 1.27  1993/01/25  13:42:23  nosa
re-coded a function to remove recursive handle

Revision 1.26  1993/01/19  19:04:14  daveb
Ensured that the type in a CONSTRUCTOR node is the actual datatype,
not just the type of the constructor.

Revision 1.25  1993/01/15  12:52:59  nosa
deleted output message

Revision 1.24  1993/01/14  17:10:56  nosa
fixed bug in RCS log

Revision 1.23  1993/01/14  17:06:21  nosa
restored RCS log

Revision 1.22  1993/01/14  16:59:14  nosa
added Log keyword for RCS

Revision 1.21  1993/01/14  16:59:14  nosa
completely rewritten; improvements are :
1. chooses better random order for pattern matching in all cases
2. passes on vital information to the match-tree-translator thereby greatly improving
   the efficiency of the translator
3. takes advantage of the swappability of patterns but avoids using a swap-table
4. builds an optimum match-tree by doing much more at build-time

Revision 1.20  1992/12/21  20:10:54  matthew
Removed polymorphic equality on SCONs

Revision 1.19  1992/12/17  18:19:07  matthew
Changed int and real scons to carry a location around

Revision 1.18  1992/12/08  18:34:51  jont
Removed a number of duplicated signatures and structures

Revision 1.17  1992/11/26  12:35:11  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.16  1992/11/04  15:28:35  jont
Changes to allow IntNewMap to be used on MatchVar

Revision 1.15  1992/10/28  10:24:30  jont
Changed to use less than functions for maps.

Revision 1.14  1992/09/30  10:09:15  clive
A type constraint was missing

Revision 1.13  1992/09/25  16:07:14  clive
Allowed the compiler to change the order of the clauses if it could prove them to be disjoint
 Allowed the system to choose the order for looking at tuple elements (used to be left to right)

Revision 1.12  1992/09/08  18:19:03  matthew
Changes to absyn

Revision 1.11  1992/08/19  16:12:18  davidt
Took out various redundant structure arguments.

Revision 1.10  1992/07/23  16:35:40  matthew
Fixed a problem with redundancy checking and record patterns

Revision 1.9  1992/07/22  13:40:34  matthew
Last version has redundancy checking commented out.  This is the real thing.

Revision 1.8  1992/07/22  11:27:14  matthew
Changed interface to match compiler to for passing back of redundancy and exhaustiveness information

Revision 1.7  1992/03/23  11:22:47  jont
Changed length for Lists.length

Revision 1.6  1992/01/23  14:02:35  jont
Added type_utils parameter

Revision 1.5  1992/01/07  16:56:50  colin
updated code for finding out number of constructors to look at
length of domain of constructor environment. (tyname_id no longer has
no_of_cons field)

Revision 1.4  1991/11/27  12:47:06  jont
Changed references to Match_utils.Qsort to Lists.qsort

Revision 1.3  91/11/21  16:33:28  jont
Added copyright message

Revision 1.2  91/06/24  14:03:20  colin
Changed match tree to give LongValIds rather than ValIds in CONSTRUCTOR
nodes - needed to code generate longexcons where the path must be kept

Revision 1.1  91/06/07  11:06:16  colin
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "^.basis.__int";
require "^.basis.__list";
require "^.basis.__string";

require "../utils/lists";
require "../utils/crash";
require "../utils/counter";
require "../basics/scons";
require "../basics/identprint";
require "../basics/absynprint";
require "../typechecker/types";
require "type_utils";
require "match";

(**
    The pattern matching compiler
**)

functor Match (
  structure Lists : LISTS
  structure Crash : CRASH
  structure MVCounter : COUNTER
  structure Scons : SCONS
  structure IdentPrint : IDENTPRINT
  structure AbsynPrint : ABSYNPRINT
  structure Types : TYPES
  structure TypeUtils : TYPE_UTILS

  sharing Types.Datatypes = TypeUtils.Datatypes
  sharing AbsynPrint.Absyn.Ident = Types.Datatypes.Ident = IdentPrint.Ident
  sharing AbsynPrint.Options = IdentPrint.Options = Types.Options

  sharing type AbsynPrint.Absyn.Type = Types.Datatypes.Type
  sharing type AbsynPrint.Absyn.Tyfun = Types.Datatypes.Tyfun
  sharing type AbsynPrint.Absyn.Instance = Types.Datatypes.Instance
  sharing type AbsynPrint.Absyn.Structure = Types.Datatypes.Structure
  sharing type IdentPrint.Ident.SCon = Scons.SCon
) : MATCH =
  struct
    structure DataTypes = Types.Datatypes
    structure Absyn = AbsynPrint.Absyn
    structure Ident = IdentPrint.Ident
    structure Options = IdentPrint.Options

    structure Bits = MLWorks.Internal.Bits

(** The Matchvar is a unique number given to each match variable.
**)
    type Matchvar = int
    type lvar = int

(** These are required from outside the Match compiler **)
    fun to_Matchvar x = x
    fun from_Matchvar x = x

    (* When comparing constructors, we assume that constructors of different types are *)
    (* never compared, therefore we can ignore any structure path that is present.  In fact, *)
    (* we must do this, other we get confusion between the same constructor in different structures *)
    (* This doesn't apply to exception constructors *)

    infix ===

    fun (Ident.LONGVALID (_,Ident.CON con)) === (Ident.LONGVALID (_,Ident.CON con')) =
      con = con'
      | id === id' = id = id'

    datatype ('a, 'b) union = INL of 'a | INR of 'b

    (** Define the datatype 'Tree' (the type we return).  This defines a
        decision tree to allow the efficient determining of which pattern a
        value matches, and therefore which expression to execute.
        SCON and CONSTRUCTOR each take at least four arguments - a matchvar, a list of
        present constructors and trees, a default, and a list of bindings. This
        default is a default-tree which is either built or unbuilt;unbuilt trees
        are never encountered by the translator. Bindings tell the translator all the
        default-trees present in this branch of the match-tree. Also, CONSTRUCTORs take
        an optional tree in normal nodes, or boundtree for delayed pattern matching in
        some exception nodes, in their tree list. Correspondingly, bindings optionally
        take a matchvar which is the rootvar for the boundtree. The bool indicates that
        this is the special node.
        Defaults are either present or absent.
        Boundtrees are references to a pair of an integer(solely for debug printing) and a
        default-tree during Match-compilation, and references to a lambda variable
        during translation. This tree is to be shared.
        Default-trees are crucial to correct determining of redundancy and exhaustiveness, and
        improve efficiency by enabling decision-tree formation by need. Only default-trees
        which are actually needed are formed and included in the resulting match-tree.
        References to stages are needed because a stage is to be shared amongst several
        branches of the match-tree, and it is obviously undesirable that any particular
        tree be built more than once. The constructor UNBUILT means the present default-tree
	is unbuilt and not needed; UNBUILT' means it is unbuilt but needed and so will later
	be built (this delaying of building is crucial to determining of redundancy and
	exhaustiveness - see Environments below); BUILT means it is BUILT and needed.
	Environments are a collection of constructors for redundancy and exhaustiveness
	determining; a list of environments is passed as parameter at each stage of tree
	generation.
	Constructors are entries in the environments. They are records of user-defined and
	special constructors and records. Con1 is a collection of already-encountered constructors
        and CON2 is the present constructor for which the tree is being built. SCon1 and SCON2 are
        similar but represent special constructors: int,real,string, and exn. Rec is used to establish
        a correspondence in matchvars between records in default and non-default trees.
     **)

    type 'Tree BoundTree = ((int * 'Tree),lvar) union ref
    datatype Constructors =
      CON1 of int list |
      CON2 of Ident.LongValId * Matchvar |
      SCON1 of string list |
      SCON2 of string * Matchvar |
      REC of (Ident.Lab * Matchvar) list

    type Entry = int * Constructors

    datatype 'env Tree =
      LEAF of Absyn.Exp * int * (Matchvar * Ident.ValId * (DataTypes.Type ref * Absyn.RuntimeInfo ref)) list
      | SCON of Matchvar * (Ident.SCon * 'env Tree) list *
	'env DefaultTree ref option
        * 'env Tree BoundTree option ref option
	* int option
      | CONSTRUCTOR of DataTypes.Type * Matchvar *
	(Ident.LongValId * Matchvar *
	 ('env Tree,'env Tree BoundTree) union) list
	* ('env DefaultTree ref option,'env Tree BoundTree) union
        * ('env Tree BoundTree option ref,
           'env Tree BoundTree * Matchvar) union list * bool
      | RECORD of DataTypes.Type * Matchvar * (Ident.Lab * Matchvar) list * 'env Tree
      | DEFAULT of 'env DefaultTree ref * 'env Tree BoundTree option ref option

    and 'env DefaultTree =
      UNBUILT of ('env -> 'env Tree)
      * 'env Tree BoundTree option ref * 'env * bool
      | UNBUILT' of ('env -> 'env Tree)
        * 'env Tree BoundTree option ref * 'env * bool
      | BUILT of 'env Tree BoundTree
      | ERROR of (DataTypes.Type * Ident.ValId list) list -> unit

    (** A boolean expression of exception constructors in conflict;
        this boolean expression is SWITCHed on in the lambda translator
        in producing a dynamic redundancy report.
     **)
    datatype expression =
      && of expression * expression |
      || of expression * expression |
      == of Ident.LongValId * Ident.LongValId |
      TRUE |
      FALSE

    infix &&
    infix ||
    infix ==

    val show_match : bool ref = ref(false)
    val _ = MVCounter.reset_counter 0
    val next_Matchvar = MVCounter.counter
    val Dummy_MV = (~1):Matchvar         (* for use in nullary constructors *)

    fun rev_app([], ys) = ys
      | rev_app(x :: xs, ys) = rev_app(xs, x :: ys)
    fun isnt_nil [] = false
      | isnt_nil _ = true
    fun rev_filter f =
      let
	fun rf([], acc) = acc
	  | rf([] :: xs, acc) = rf(xs, acc)
	  | rf(x :: xs, acc) = rf(xs, x :: acc)
      in
	rf
      end
    val rev_filter =
      fn f => fn x => rev_filter f (x, [])

    fun printSCon (Ident.INT (x,_)) = x
      | printSCon (Ident.REAL (x,_)) = x
      | printSCon (Ident.WORD (x,_)) = x
      | printSCon (Ident.STRING x) = x
      | printSCon (Ident.CHAR x) = x

    local
      fun hd (x::_) = x
	| hd _ = Crash.impossible "hd:match"
      fun tl (_::xs) = xs
	| tl _ = Crash.impossible "tl:match"
    (** fetch_pat fetches a real pattern, ignoring layered and typed patterns if asked to do
        so NONE and updating environments from them otherwise(SOME(...)).
     **)
      (* Return a pattern after dealing with layering, typed patterns and valpats *)
      (* If we've got an environment, update it with any valids we find *)
      fun fetch_pat env =
	let
	  val set_env = case env of
	    NONE => (fn _ => ())
	  | (SOME(matchvar,env)) =>
	      fn (vi, ty) => (env := (matchvar,vi,ty)::(!env))

	  fun fp (Absyn.LAYEREDpat((vi,ty),pat)) =
	    (set_env (vi,ty); fp pat)
	    | fp (Absyn.TYPEDpat(pat,_,_)) = fp pat
	    | fp (Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _), ty),_)) =
	      (set_env (vi,ty); Absyn.WILDpat Ident.Location.UNKNOWN)
	    | fp pat = pat
	in
	  fp
	end
    (** A pattern during match-compilation will be thus ... . The SOME option paired with
        patterns denotes a pattern which was previously a labelled pattern in a record as
        opposed to what a ABSENT option denotes. Such a pattern will have a matchvar already
        assigned to it, and will have a LongValid assigned to it during sorting if a
        non-WILDpat. Each object matching this type will be translated into one path in the
        resulting decision tree.
    **)

      type 'env pattern =
	((Matchvar * Ident.LongValId option) option * Absyn.Pat) list
	* ((Absyn.Exp * int * (Ident.LongValId * (Matchvar * 'env DefaultTree ref)) list)
	   * (Matchvar * Ident.ValId
	      * (DataTypes.Type ref * Absyn.RuntimeInfo ref)) list)

      val match_vars : Matchvar list list ref = ref []

      infix :::
      fun x:::(xs,y) = (x::xs,y)
      local
      (** look up a match-variable in an environment returning a constructor and the same
	  environment;
	  share this result so that the already-searched environment(s) need never be
	  searched again;
	  if the match-variable is not recorded in the environment, create an entry for it
       **)
	fun fetch_environment'' rootvar env =
	  let
	    val mv = !match_vars
	    val l = length mv

	    fun member(mvar,_) = Lists.member(rootvar, Lists.nth(l-mvar, mv))

	    fun insert() = (match_vars := [rootvar]::mv; l+1)

	    fun fetch_environment' [] _ = (insert(),CON1 [])::env
	      | fetch_environment' (entry::envs) env =
                if member entry then
		  entry::(rev_app(env, envs))
                else
		  fetch_environment' envs (entry::env)
	  in
	    fetch_environment' env []
	  end
      in
    (** look up a match-variable in a list of environments;
	undo sharing for future searches
     **)

	fun simple_fetch_env env rootvar =
	  map (fn e => fetch_environment'' rootvar e) env

	fun complex_fetch_env env rootvar =
	  map (fn e => (fetch_environment'' rootvar e, [])) env

	fun fetch_environment' env rootvar =
	  map
	  (fn ((env,mvars)) => (fetch_environment'' rootvar env,mvars))
	  env

	fun power n = Bits.lshift(1, n)

	(* A bit pattern with the most significant part at the list head *)
	(* Seems a bit silly, why not put it at the tail? *)
	(* Now changed to put least significant part at head *)
	(* This means andb and orb don't need to reverse *)
	(* Now removed andb and orb in favour of bit_set and is_set *)

	fun bit_set(n, [], acc) =
	  if n >= 29 then
	    bit_set(n-29, [], 0 :: acc)
	  else
	    if n < 0 then
	      Crash.impossible"bit_set: negative integer"
	    else
	      rev(power n :: acc)
	  | bit_set(n, word :: words, acc) =
	    if n >= 29 then
	      bit_set(n-29, words, word :: acc)
	    else
	      if n < 0 then
		Crash.impossible"bit_set: negative integer"
	      else
		rev_app(Bits.orb(power n, word) :: acc, words)
	  
	fun is_set(n, []) = false
	  | is_set(n, word :: words) =
	    if n < 0 then
	      Crash.impossible"is_set: negative integer"
	    else
	      if n >= 29 then
		is_set(n-29, words)
	      else Bits.andb(word, power n) <> 0

    (** update a list of environments by appending to them a new record for a constructor;
        filter environments for this particular constructor thuswise:
          if CON1 entry
            if constructor is present
              delete environment from branch
            else
              indicate tree is being built for this constructor in branch
          if CON2 entry
            if tree is being built for this constructor delete environment from this node
            else delete environment from branch;
        also do some redundancy checking
     **)
	val redundant : bool ref = ref(true)
	fun update_env (pat,mvar) env ty =
	  let
	    exception Fetch
	    val _ = redundant := true

	    fun insert (mvar,mvar') =
	      (* Insert mvar into the mvar' th list from the tail *)
	      (* Starting at 1 *)
	      (* This is the same as inserting at position l-mvar' from the head *)
	      (* where l is the list length *)
	      let
		val mv = !match_vars
		val l = length mv
		fun add_member mvars =
		  if Lists.member(mvar, mvars) then mvars else mvar :: mvars
		fun insert([], _, _) = Crash.impossible "insert:update_env:match"
		  | insert(mvars::mvarss, acc, 0) =
		    rev_app(acc, add_member mvars :: mvarss)
		  | insert(mvars::mvarss, acc, n) = insert(mvarss, mvars :: acc, n-1)
	      in
		match_vars := insert (mv, [], l-mvar');
		mvar'
	      end

	    datatype scon_type =
	      INT of string
	      | WORD of string
	      | OTHER of string

	    fun scon_test(INT s, t) =
	      Scons.scon_eqval(Ident.INT(s, Ident.Location.UNKNOWN),
			       Ident.INT(t, Ident.Location.UNKNOWN))
	      | scon_test(WORD s, t)=
		Scons.scon_eqval(Ident.WORD(s, Ident.Location.UNKNOWN),
				 Ident.WORD(t, Ident.Location.UNKNOWN))
	      | scon_test(OTHER s, t) = s = t

	    fun scon_val(INT s) = s
	      | scon_val(WORD s) = s
	      | scon_val(OTHER s) = s

	    fun member(s as INT _, ss) = List.exists (fn t => scon_test(s, t)) ss
	      | member(s as WORD _, ss) = List.exists (fn t => scon_test(s, t)) ss
	      | member(OTHER s, ss) = Lists.member(s, ss)

	    fun make_scon_entry scon =
	      let
		val scon_val = scon_val scon
	      in
		(fn env' as (mvar',SCON1 scons)::env =>
		 if member(scon,scons) then (env', [])
		 else
		   (redundant := false;
		    ((mvar',SCON1(scon_val::scons))::env,
		     (mvar',SCON2(scon_val,mvar))::env))
	         | env' as (mvar',CON1[])::env =>
		     (redundant := false;
		      ((mvar',SCON1[scon_val])::env,
		       (mvar',SCON2(scon_val,mvar))::env))
		 | env' as (mvar'',SCON2(scon',mvar'))::env =>
		     if scon_test(scon, scon') then
		       (redundant := false;
			([],
			 if mvar = Dummy_MV then env'
			 else
			   let
			     (* let matchvars in environment correspond *)
			     val env =
			       case fetch_environment'' mvar' env of
				 (mv,cons)::env => (insert(mvar,mv),cons)::env
			       | _ => Crash.impossible "1:make_entry:update_env:match"
			   in
			     (mvar'',SCON2(scon',mvar))::env
			   end))
		     else
		       (env', [])
		 | _ => Crash.impossible "2:make_entry:update_env:match")
	      end

	    val make_entry =
	      case pat of
		Absyn.WILDpat _ =>
		  (fn (mvar',cons)::env => ([],(insert(mvar,mvar'),cons)::env)
		| _ => Crash.impossible "3:make_entry:update_env:match")
	      | Absyn.SCONpat (scon, _) =>
		  let
		    val scon_val = printSCon scon
		  in
		    make_scon_entry
		    (case scon of
		       Ident.INT _ => INT scon_val
		     | Ident.WORD _ => WORD scon_val
		     | _ => OTHER scon_val)
		  end
	      | _ =>
		  let
		    val con =
		      case pat of
			Absyn.VALpat((con,_),_) => con
		      | Absyn.APPpat((con,_),_,_,_) => con
		      | _ => Crash.impossible "4:make_entry:update_env:match"
		  in
		    case con of
		      Ident.LONGVALID(_,Ident.EXCON(con)) =>
			make_scon_entry(OTHER(Ident.Symbol.symbol_name con))
		    | _ =>
			let
			  val con' = case pat of
			    Absyn.VALpat((Ident.LONGVALID(_,con),_),_) => con
			  | Absyn.APPpat((Ident.LONGVALID(_,con),_),_,_,_) => con
			  | _ => Crash.impossible "constructor_word:make_entry:match"
			  val bit' = DataTypes.NewMap.rank'
			    (#2(TypeUtils.get_valenv(TypeUtils.get_cons_type ty)), con')
			in
			  fn env' as (mvar',CON1(word))::env =>
			  if is_set(bit', word) then
			    (env', [])
			  else
			    (redundant := false;
			     ((mvar',CON1(bit_set(bit', word, [])))::env,
			      (mvar',CON2(con,mvar))::env))
			   | env' as (mvar'',CON2(con',mvar'))::env =>
			       if con===con' then (* con isn't an excon here *)
				 (redundant := false;
				  ([],
				   if mvar = Dummy_MV then env'
				   else
				     let
				       (* let matchvars in environment correspond *)
				       val env =
					 case fetch_environment'' mvar' env of
					   (mv,cons)::env => (insert(mvar,mv),cons)::env
					 | _ => Crash.impossible "5:make_entry:update_env:match"
				     in
				       (mvar'',CON2(con',mvar))::env
				     end))
			       else (env', [])
			   | _ => Crash.impossible "6:make_entry:update_env:match"
			end
		  end
	    fun update_env env =
	      let
		val (env1, env2) =
		  Lists.reducel
		  (fn ((l1, l2), e) =>
		   let
		     val (e1, e2) = make_entry  e
		   in
		     (e1 :: l1, e2 :: l2)
		   end)
		  (([], []), env)
	      in
		(rev_filter isnt_nil env1, rev_filter isnt_nil env2)
	      end
	  in
	    (update_env env, !redundant)
	  end
      end
      (** check for exhaustiveness at the present stage of match-compilation;
          filter environments for inexhaustiveness
       **)

      fun all_constructors_present env lvis ty arity =
	let
	  (* n is <= 28, so no overflow *)

	  fun set_n_bits(n, acc) =
	    if n < 0 then
	      acc
	    else
	      set_n_bits(n-1, Bits.lshift(acc, 1) + 1)

	  val every_bit = set_n_bits(28, 0)

	  fun all_bits_set(n, acc) =
	    if n < 0 then
	      Crash.impossible "all_bits_set:all_constructors_present:match"
	    else
	      if n >= 29 then
		all_bits_set(n-29, every_bit :: acc)
	      else
		rev(set_n_bits(n, 0) :: acc)

	  val word =
	    case arity of
	      0 => []
	    | _ => all_bits_set (arity-1, [])

	  val arity_non_zero = arity <> 0

	  fun char_makestring i = "#\"" ^ MLWorks.String.ml_string((str o chr) i, 3) ^ "\""
	    
	  fun string_list_to_ints s_list =
	    Lists.reducel
	    (fn (ints, s) => bit_set(ord (String.sub(s, 0)), ints, []))
	    ([], s_list)

	  fun fetch_missing_constructors word =
	    let
	      val ve = #2(TypeUtils.get_valenv ty)
	      val cons = DataTypes.NewMap.domain ve
	    in
	      (ty,
	       List.filter
	       (fn con =>
		let
		  val bit' = DataTypes.NewMap.rank'(ve,con)
		in
		  not(is_set(bit', word))
		end) cons)
	    end

	  fun fetch_missing_char_constructors word' =
	    let
	      fun int_list(0, acc) = 0 :: acc
		| int_list(n, acc) = int_list(n-1, n :: acc)
	      val word = int_list(arity-1, [])
	    in
	      map
	      (fn s => Ident.CON(Ident.Symbol.find_symbol(char_makestring s)))
	      (List.filter (fn i => not(is_set(i, word'))) word)
	    end

	  fun all_constructors_present nil result = result
	    | all_constructors_present ([]::env) result = all_constructors_present env result
	    | all_constructors_present ((entry as (_,CON1(word'))::_)::env) (result as (env',_,missing_cons)) =
	      if word = word' then
		all_constructors_present env result
	      else
		all_constructors_present env
		(entry::env',false,
		 (fn ()=>fetch_missing_constructors word')::missing_cons)
	    | all_constructors_present ((entry as (_,CON2(_))::_)::env) (env',_,missing_cons) =
	      all_constructors_present env (entry::env',false,missing_cons)
	    | all_constructors_present ((entry as (_,SCON1 strings)::_)::env) (result as (env',_,missing_cons)) =
	      let
		val word' = if arity_non_zero then string_list_to_ints strings else []
	      in
		if arity_non_zero andalso word = word' then
		  all_constructors_present env result
		else
		  all_constructors_present env
		  (entry::env',false,
		   (fn ()=>(ty,
			    if arity_non_zero then
			      fetch_missing_char_constructors word'
			    else
			      []))::missing_cons)
	      end
	    | all_constructors_present ((entry as (_,SCON2 _)::_)::env) (env',_,missing_cons) =
	      all_constructors_present env (entry::env',false,missing_cons)
	    | all_constructors_present _ _ = Crash.impossible "all_constructors_present:match"
	in
	  all_constructors_present env (nil,true,nil)
	end

      val redundant_patterns : (int * expression) list ref = ref nil
      val inexhaustive : (DataTypes.Type * Ident.ValId list) list option ref =
	ref NONE
      (** record and record-type are references used to indicate that records are present in
       the present stage of match-compiling; we do not wish match-compiling to break off
       into several branches on records as this would complicate match-compilation
       unnecessarilly.
       **)
      val record = ref false
      val record_type : DataTypes.Type option ref = ref NONE
      val label_count : int ref = ref 0
      fun next_label() =
	let
	  val lc = (!label_count)+1
	in
	  label_count := lc;
	  lc
	end
      (**
       if old_default then
	 environments still being accumulated;
	 for ERROR trees only, accumulate missing constructors for warning message
       else
	 default-tree has outlived its usefulness;
	 generate, passing to it the environments for all uses
	 **)
      fun make_default new_default_tree old_default missing_constructors =
	if old_default then
	  case new_default_tree of
	    ref(ERROR inexhaustive)=>
	      inexhaustive(map (fn f=>f()) missing_constructors)
	  | _ => ()
	else
	  case new_default_tree of
	    ref(UNBUILT'(make_tree,binding,env,_)) =>
	      let
		val tree = make_tree env
		val boundtree = ref(INL(next_label(),tree))
	      in
		binding := SOME boundtree;
		new_default_tree := BUILT boundtree
	      end
	  | ref(ERROR inexhaustive)=>
	      inexhaustive(map (fn f=>f()) missing_constructors)
	  | _ => ()
      (** Form a default;
       if previously unused (UNBUILT), indicate that it is now used (UNBUILT');
	 indicate that this default-tree is old for future builds
	 **)
      fun MakeDefaultTree (default_tree as ref(UNBUILT(default,binding,env',_))) env =
	(default_tree := UNBUILT'(default,binding,env@@env',true);
	 default_tree)
	| MakeDefaultTree (default_tree as ref(UNBUILT'(default,binding,env',old_default))) env =
          (default_tree := UNBUILT'(default,binding,env@@env',old_default);
           default_tree)
	| MakeDefaultTree default_tree _ = default_tree
      (** Form a binding, information for the match-tree translator that the default-tree
       is bound here and so all invocations of it will be in this branch of the
       match-tree
       **)
      fun make_binding(default_tree as ref(UNBUILT(default,binding,env,old_default))) =
	(default_tree := UNBUILT(default,binding,env,true);
	 if old_default then NONE
	 else SOME binding)
	| make_binding(ref(UNBUILT' _)) = NONE
	| make_binding(ref(BUILT _)) = NONE
	| make_binding(ref(ERROR _)) = NONE
      fun generate_tree'' generate_tree patterns
	(default as (_,_,new_default_tree)) env old_default =
	let
	  val tree = generate_tree patterns default env
	in
	  (make_default new_default_tree old_default nil;
	   tree)
	end
      fun generate_tree rootvars ((nil,((exp,n,exns),env))::patterns) _ _ =
	let
	  (** form boolean expressions for exception constructors in conflict and insert them
	      in list of redundant patterns for the lambda translator
	   **)
	  fun insert_redundant_patterns exns =
	    let
	      exception Insert
	      fun insert_redundant_patterns m =
                let
                  fun insert_redundant_pattern (_,nil) = []
                    | insert_redundant_pattern ((n,exp),ns) =
                      let
                        fun insert_redundant_pattern nil = []
                          | insert_redundant_pattern ((n',exp')::ns) =
                            if n=n' then (n,case exp' of
					  TRUE => exp
					| _ => exp&&exp')::ns
                            else (n',exp')::insert_redundant_pattern ns
                      in
                        insert_redundant_pattern ns
                      end
                  fun fetch_exns _ nil _ = raise Insert
                    | fetch_exns 1 (exn::exns) exns' = (exn,rev exns')
                    | fetch_exns m (exn::exns) exns' = fetch_exns (m-1) exns (exn::exns')
                  fun expression exns exn =
                    let
                      exception True
                      fun expression' (nil,nil) = TRUE
                        | expression' ((lvi,_)::exn,(lvi',_)::exn') =
                          if lvi===lvi' then expression' (exn,exn')
                          else
                            lvi==lvi'&&expression' (exn,exn')
                        | expression' _ = Crash.impossible "expression':insert_redundant_patterns:match"
                      fun expression nil = FALSE
                        | expression ((_,exn')::exns) =
                          case expression' (exn,exn') of
                            TRUE =>
                              raise True (* exceptions identity determinable at match-compile-time *)
                          | bexp => bexp || expression exns
                    in
                      expression exns
                      handle True => TRUE
                    end
                  val (((_,n,_),exn),exns') = fetch_exns m exns nil
                in
                  (redundant_patterns :=
                   insert_redundant_pattern((n,expression exns' exn),!redundant_patterns);
                   insert_redundant_patterns(m+1))
                end
              handle Insert => ()
	    in
	      insert_redundant_patterns 2
	    end
       (** Perform all exception pattern matching delayed in the matching process;
           Pass enhanced default-trees to eliminate runtime errors - these default-trees
           not only include the normal default-tree but also a CONSTRUCTOR node of all
           conflicting exceptions possibly not yet encountered in runtime use of match-tree.
        **)
	  fun generate_exception_tree ((_,[])::_) _ =
            Crash.impossible "1:generate_exception_tree:match"
	    | generate_exception_tree [] _ =
	      Crash.impossible "2:generate_exception_tree:match"
	    | generate_exception_tree exns default_tree =
	      let
		fun fetch_constructor_info ((_,(_,info)::_)::_) = info
		  | fetch_constructor_info _ =
		    Crash.impossible "fetch_constructor_info:generate_exception_tree:match"
		val (mv,default_tree') = fetch_constructor_info exns
		fun EXNsplit (exns as (_,(exn,_)::_)::_) =
		  let
		    fun insplit [] (e1,e2) = (e1, rev e2)
		      | insplit ((exn'' as (exp,(exn',_)::exns))::el) (e1,e2) =
			if exn' === exn then
			  insplit el ((exp,exns)::e1,e2)
			else
			  insplit el (e1,exn''::e2)
		      | insplit _ _ =
			Crash.impossible "insplit:EXNsplit:generate_exception_tree:match"
		  in
		    case insplit exns ([],[]) of
		      (e1 as (exp,_)::_, e2) => (e1, e2, (exp,exn))
		    | _ =>
			Crash.impossible "1:EXNsplit:generate_exception_tree:match"
		  end
		  | EXNsplit _ =
		    Crash.impossible "2:EXNsplit:generate_exception_tree:match"
		fun make_tree_list (exns as _::_) (trees,boundtrees) default_tree =
		  let
		    val (exns,exns',(exp,exn)) = EXNsplit exns
		  in
		    case exns' of
		      nil =>
			(case exns of
			   (_,[])::_ =>
			     ((exn,Dummy_MV,INL(LEAF(exp)))::trees,rev(boundtrees))
			 | _ =>
			     ((exn,Dummy_MV,
			       INL(generate_exception_tree exns default_tree))::trees,
			      rev(boundtrees)))
		    | _ =>
			case exns of
			  (_,[])::_ =>
			    make_tree_list exns'
			    ((exn,Dummy_MV,INL(LEAF(exp)))::trees,boundtrees) default_tree
			| _ =>
			    let
			      val tree =
				ref(INL
				    (next_label(),
				     generate_exception_tree exns default_tree))
			      val tree_entry = (exn,Dummy_MV,INR tree)
			      val default_tree =
				case default_tree of
				  INL _ =>
				    ref(INL
					(next_label(),
					 CONSTRUCTOR(Types.exn_type,mv,[tree_entry],default_tree,[],true)))
				  | INR
				    (ref(INL
					 (_, CONSTRUCTOR(ty,mv,trees,default_tree,boundtrees,b)))) =>
				    ref(INL
					(next_label(),
					 CONSTRUCTOR(ty,mv,tree_entry::trees,default_tree,boundtrees,b)))
				  | _ =>
				      Crash.impossible "1:make_tree_list:generate_exception_tree:match"
			    in
			      make_tree_list exns'
			      (tree_entry::trees,
			       INR(default_tree,Dummy_MV)
			       ::INR(tree,Dummy_MV)::boundtrees)
			      (INR(default_tree))
			    end
		  end
		  | make_tree_list _ _ _ =
		    Crash.impossible "2:make_tree_list:generate_exception_tree:match"
		fun choose_default_tree(INL _) =
		  INL(SOME default_tree')
		  | choose_default_tree(INR _) = default_tree
		val default_tree = choose_default_tree default_tree

		val (trees,boundtrees) =
		  make_tree_list (rev exns) (nil,nil) default_tree
	      in
		CONSTRUCTOR(Types.exn_type,mv,trees,default_tree,boundtrees,true)
	      end
	in
	  (redundant_patterns :=
	   List.filter (fn (m, _) => m <> n) (!redundant_patterns));
	   case exns of
	     nil => LEAF(exp,n,env)
	   | _ =>
	       let
		 fun fetch_exns exns =
		   map
		   (fn (_,((exp,n,exns),env)) => ((exp,n,env),rev exns))
		   exns
		 fun fetch_default_tree ((_,(_,default_tree))::_) =
                   INL(SOME default_tree)
		   | fetch_default_tree _ =
		     Crash.impossible "fetch_default_tree:generate_tree:match"
		 val exns' = ((exp,n,env),rev exns)::fetch_exns patterns
	       in
		 insert_redundant_patterns exns';
		 generate_exception_tree exns' (fetch_default_tree exns)
	       end
	end
	| generate_tree (rootvars' as rootvar::rootvars) patterns (separate,exception_tree,default_tree) env =
	  let
	    (**  Bring similar rules together. Redundant patterns are also removed from the
              matching process at this stage. Two patterns are swappable if no value is
              matched by both; two patterns are 'irredundant' if there is a value that is
              matched by both and they are relatively irredundant. A swap-table is not
              necessary because any two patterns which are tested for irredundancy are never
              tested again. This is because there are two classes of rules present at every
              stage of match-compilation : variable rules and one type of non-variable rule;
              only patterns in different classes need be paired in tests, and since match-
              compilation branches off at this stage, any such pair will never be
              re-encountered in such tests.
          **)
	    fun the_construc(Absyn.APPpat((lvi,_),_,_,_)) = lvi
	      | the_construc(Absyn.VALpat((lvi,_),_)) = lvi
	      | the_construc(Absyn.SCONpat (scon, _)) =
		(* fake a LONGVALID for a SCon. *)
		Ident.LONGVALID
		(Ident.mkPath [], Ident.VAR(Ident.Symbol.find_symbol(printSCon scon)))
	      | the_construc(Absyn.TYPEDpat(p,_,_)) = the_construc p
	      | the_construc(Absyn.LAYEREDpat(_,p)) = the_construc p
	      | the_construc(Absyn.WILDpat _) =
		Crash.impossible "the_construc:generate_tree:match:WILD"
	      | the_construc(Absyn.RECORDpat _) =
		Crash.impossible "the_construc:generate_tree:match:RECORD"
	    local
	      datatype irredundancy = REDUNDANT | SWAPPABLE | IRREDUNDANT
	      fun swap_patterns pats patterns =
		let
		  fun swap_patterns _ nil patterns = (nil,(nil,rev patterns))
		    | swap_patterns pats (patterns' as pattern::patterns) patterns'' =
		      let
			fun irredundancy nil nil = REDUNDANT
			  | irredundancy ((_,pat1)::pats1) ((_,pat2)::pats2) =
			    let
			      fun Irredundancy pat1 pat2 =
				(case (pat1,pat2) of
				   (Absyn.WILDpat _,_) => REDUNDANT
				 | (Absyn.VALpat ((Ident.LONGVALID(_,Ident.VAR _),_),_),_) => REDUNDANT
				 | (_,Absyn.WILDpat _) => IRREDUNDANT
				 | (_, Absyn.VALpat ((Ident.LONGVALID(_,Ident.VAR _),_),_)) => IRREDUNDANT
				 | (Absyn.LAYEREDpat(_,pat1),pat2) => Irredundancy pat1 pat2
				 | (Absyn.TYPEDpat(pat1,_,_),pat2) => Irredundancy pat1 pat2
				 | (pat1,Absyn.LAYEREDpat(_,pat2)) => Irredundancy pat1 pat2
				 | (pat1,Absyn.TYPEDpat(pat2,_,_)) => Irredundancy pat1 pat2
				 | (Absyn.APPpat((Ident.LONGVALID( _, val_id1),_),arg,_,_),
				   Absyn.APPpat((Ident.LONGVALID( _, val_id2),_),arg',_,_)) =>
				  (case  Irredundancy'' val_id1 val_id2  of
				     REDUNDANT => Irredundancy arg arg'
				   |irredundancy => irredundancy)
				 | (Absyn.VALpat((Ident.LONGVALID( _, val_id1),_),_),
				    Absyn.VALpat((Ident.LONGVALID( _, val_id2),_),_)) =>
                                                      Irredundancy'' val_id1 val_id2
				 | (Absyn.RECORDpat(name_pat_list,_,_),
				    Absyn.RECORDpat(name_pat_list',_,_)) =>
				   Irredundancy' name_pat_list name_pat_list'
                                 | (_,_) => SWAPPABLE)
			      and Irredundancy' nil nil = REDUNDANT
				| Irredundancy' ((lab,pat1)::pats1) (pats2 as _::_) =
				  let
				    fun fetch_pat([], acc) =
				      (rev acc, Absyn.WILDpat Ident.Location.UNKNOWN)
				      | fetch_pat((entry as (lab2,pat))::pats, acc) =
					if Ident.lab_eq(lab,lab2) then
					  (rev_app(acc, pats), pat)
					else
					  fetch_pat(pats, entry :: acc)
				    val (pats2,pat2) = fetch_pat(pats2, [])
				  in
				    case Irredundancy pat1 pat2 of
				      SWAPPABLE => SWAPPABLE
				    | IRREDUNDANT =>
				       (fn REDUNDANT => IRREDUNDANT
				     |  other => other) (Irredundancy' pats1 pats2)
				     | REDUNDANT => Irredundancy' pats1 pats2
				  end
				| Irredundancy' pats1 nil =
				  let
				    fun non_WILDpat_in nil = false
				      | non_WILDpat_in((_,Absyn.WILDpat _)::pats) =
					non_WILDpat_in pats
				      | non_WILDpat_in((_,Absyn.VALpat((Ident.LONGVALID(_, Ident.VAR _),_),_))::pats) =
					non_WILDpat_in pats
				      | non_WILDpat_in((lab,Absyn.LAYEREDpat(_,pat))::pats) =
					non_WILDpat_in((lab,pat)::pats)
				      | non_WILDpat_in((lab,Absyn.TYPEDpat(pat,_,_))::pats) =
					non_WILDpat_in((lab,pat)::pats)
				      | non_WILDpat_in _ = true
				  in
				    if non_WILDpat_in pats1 then IRREDUNDANT
				    else REDUNDANT
				  end
				| Irredundancy' nil pats2 = REDUNDANT
			      and Irredundancy'' val_id val_id' =
				(case (val_id,val_id') of
				   (Ident.CON name,Ident.CON name') =>
				     if name=name' then REDUNDANT else SWAPPABLE
				 |(Ident.EXCON name,Ident.EXCON name') =>
				    if name=name' then REDUNDANT else IRREDUNDANT
				 | _ => Crash.impossible
				     "Irredundancy'':Irredundancy:generate_tree:match")
			    in
			      case Irredundancy pat1 pat2 of
				SWAPPABLE => SWAPPABLE
			      | IRREDUNDANT =>
				  (fn REDUNDANT => IRREDUNDANT
				   | other => other) (irredundancy pats1 pats2)
			      | REDUNDANT => irredundancy pats1 pats2
			    end
			  | irredundancy _ _ =
			    Crash.impossible "irredundancy:generate_tree:match"
			fun irredundancy' nil _ = SWAPPABLE
			  | irredundancy' (pats::rest) pats' =
			    case irredundancy pats pats' of
			      SWAPPABLE => irredundancy' rest pats'
			    | other => other

		      in
			case pattern of
			  ((_,Absyn.WILDpat _)::pats',_) =>
			    swap_patterns (pats'::pats) patterns (pattern::patterns'')
			  | ((option,Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
						   ty),_))::pats',(exp,env)) =>
			    swap_patterns (pats'::pats) patterns (((option,Absyn.WILDpat Ident.Location.UNKNOWN)::pats',
								   (exp,(rootvar,vi,ty)::env))::patterns'')
			  | ((option,Absyn.LAYEREDpat((vi,ty),pat))::pats',(exp,env)) =>
			      swap_patterns pats (((option,pat)::pats',
						   (exp,(rootvar,vi,ty)::env))::patterns) patterns''
			  | ((option,Absyn.TYPEDpat(pat,_,_))::pats',env) =>
			      swap_patterns pats (((option,pat)::pats',env)::patterns) patterns''
			  | ((_,pat)::pats',_) =>
			      (case irredundancy' pats pats' of
				 REDUNDANT => swap_patterns pats patterns patterns''
			       | IRREDUNDANT => (nil,(patterns',rev patterns''))
			       | SWAPPABLE =>
				   (case pat of
				      Absyn.RECORDpat(_,_,ref ty) =>
					(record := true;record_type := SOME(ty))
				    | _ => ();
					pattern:::swap_patterns pats patterns patterns''))
			  | _ => Crash.impossible "swap_patterns:generate_tree:match"
		      end
		in
		  swap_patterns [pats] patterns nil
		end
	    in
	      fun separate_defaults nil = (nil,nil)
		| separate_defaults (pat::pats) =
		  case pat of
		    ((_,Absyn.WILDpat _)::pats',_) =>
		      let
			val (pats,(defaults,defaults')) = swap_patterns pats' pats
			val (defaults,default_defaults) = separate_defaults defaults
		      in
			(pats,(pat::defaults')::
			 (case defaults of
			    nil => default_defaults
			  | _ => defaults::default_defaults))
		      end
		  | ((option,Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
					   ty),_))::pats',(exp,env)) =>
		    let
		      val (pats,(defaults,defaults')) = swap_patterns pats' pats
		      val (defaults,default_defaults) = separate_defaults defaults
		    in
		      (pats,(((option,Absyn.WILDpat Ident.Location.UNKNOWN)::pats',
			      (exp,(rootvar,vi,ty)::env))::defaults')::
		       (case defaults of
			  nil => default_defaults
			| _ => defaults::default_defaults))
		    end
		  | ((option,Absyn.LAYEREDpat((vi,ty),pat))::pats',(exp,env)) =>
		      separate_defaults (((option,pat)::pats',
					  (exp,(rootvar,vi,ty)::env))::pats)
		  | ((option,Absyn.TYPEDpat(pat,_,_))::pats',env) =>
		      separate_defaults (((option,pat)::pats',env)::pats)
		  | ((_,pat')::_,_) =>
		      (case pat' of
			 Absyn.RECORDpat(_,_,ref ty) =>
			   (record := true;record_type := SOME(ty))
		       | _ => ();
			   pat:::separate_defaults pats)
		  | _ => Crash.impossible "separate_defaults:generate_tree:match"
	    end
         (** For trees in which conflicting exception constructors have already been encountered,
             duplicate patterns in separating defaults;
             inefficient, but produces the correct boolean expressions for dynamic redundancy checking
             and the correct match tree
          **)
	    fun separate_defaults' nil = (nil,nil)
	      | separate_defaults' pats =
		let
		  fun duplicate_pattern _ nil = nil
		    | duplicate_pattern pat' pats =
		      let
			fun duplicate_pattern [] = []
			  | duplicate_pattern (pat::pats) =
			    case pat of
			      ((opt,Absyn.WILDpat _)::pats',exp) =>
				((opt,pat')::pats',exp)::duplicate_pattern pats
			    | _ => []
		      in
			duplicate_pattern pats
		      end
		  fun duplicate_pattern' _ nil = ([],[])
		    | duplicate_pattern' pat' pats =
		      let
			fun duplicate_pattern [] (pats,pats') = (rev pats,pats')
			  | duplicate_pattern (pat::pats) (pats''',pats') =
			    case pat of
			      ((opt,Absyn.WILDpat _)::pats'',exp) =>
				duplicate_pattern pats (pat::pats''',((opt,pat')::pats'',exp)::pats')
			  | ((option,Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
						   ty),_))::pats'',(exp,env)) =>
			    duplicate_pattern pats (pat::pats''',((option,pat')::pats'',
								  (exp,(rootvar,vi,ty)::env))::pats')
			  | ((option,Absyn.LAYEREDpat((vi,ty),pat))::pats'',(exp,env)) =>
			      duplicate_pattern (((option,pat)::pats'',
						  (exp,(rootvar,vi,ty)::env))::pats) (pats''',pats')
			  | ((option,Absyn.TYPEDpat(pat,_,_))::pats'',env) =>
			      duplicate_pattern (((option,pat)::pats'',env)::pats) (pats''',pats')
			  | ((_,Absyn.RECORDpat(_))::_,_) => duplicate_pattern pats (pats''',pat::pats')
			  | ((_,pat'')::_,_) =>
			      if the_construc pat' === the_construc pat'' then
				duplicate_pattern pats (pats''',pat::pats')
			      else
				duplicate_pattern pats (pat::pats''',pats')
			  | _ => Crash.impossible "duplicate_pattern':separate_defaults':generate_tree:match"
		      in
			duplicate_pattern pats ([],[])
		      end
		  fun separate_wildpats ((wildpat as ((_,Absyn.WILDpat _)::_,_))::pats) wildpats =
		    separate_wildpats pats (wildpat::wildpats)
		    | separate_wildpats pats wildpats =
		      (rev pats,case wildpats of
		       [] => []
		     | _ => [wildpats])
		  fun duplicate_patterns nil pats = separate_wildpats pats []
		    | duplicate_patterns (pat::pats) pats' =
		      case pat of
			((_,Absyn.WILDpat _)::_,_) => duplicate_patterns pats (pat::pats')
		    | ((option,Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
					     ty),_))::pats'',(exp,env)) =>
		      duplicate_patterns pats (((option,Absyn.WILDpat Ident.Location.UNKNOWN)::pats'',
						(exp,(rootvar,vi,ty)::env))::pats')
		    | ((option,Absyn.LAYEREDpat((vi,ty),pat))::pats'',(exp,env)) =>
			duplicate_patterns (((option,pat)::pats'',
					     (exp,(rootvar,vi,ty)::env))::pats) pats'
		    | ((option,Absyn.TYPEDpat(pat,_,_))::pats'',env) =>
			duplicate_patterns (((option,pat)::pats'',env)::pats) pats'
		    | ((_,pat')::_,_) =>
			(case pat' of
			   Absyn.RECORDpat(_,_,ref ty) =>
			     (record := true;
			      record_type := SOME(ty))
			 | _ => ();
			     let
			       val (pats,pats'') = duplicate_pattern' pat' pats
			     in
			       duplicate_patterns pats
			       (pats'@@pats''@@(pat::duplicate_pattern pat' pats'))
			     end)
		    | _ => Crash.impossible "duplicate_patterns:separate_defaults':generate_tree:match"
		in
		  duplicate_patterns pats []
		end
	    val separate_defaults =
	      if exception_tree then separate_defaults' else separate_defaults
         (**  fun generate_tree' determines what rootvar to call fun generate_tree with;
              if this pattern is a labelled-pattern, this rootvar is stored in the pattern;
              if it is not, the rootvar is already stored in the present rootvars.
          **)
	    fun generate_tree' (patterns as ((option,_)::_,_)::_) default env =
	      (case option of
                 NONE => generate_tree rootvars patterns default env
	       | SOME(matchvar,_) =>
		   generate_tree (matchvar::rootvars) patterns default env)
	      | generate_tree' patterns default env = generate_tree rootvars patterns default env
	 (** construct a unique longvalid identifier for certain patterns
	  **)
	    fun make_construc pat opt =
	      case opt of
		NONE => the_construc pat
	      | SOME(_,SOME(construc)) => construc
	      | _ =>    Crash.impossible "make_construc:generate_tree:match"
	    val (non_defaults,defaults') =
	      if separate then (record := false;
				separate_defaults patterns)
	      else (patterns,nil)
	    val (defaults,include_non_defaults) =
	      case non_defaults of
		nil => (tl defaults',true)
	      | _ => (defaults',false)
	    fun flat nil = nil
	      | flat (xs::xss) = xs@@flat xss
	    fun strip nil = nil
	      | strip ((pat::pats',env)::rest) = (pats',env)::strip rest
	      | strip _ = Crash.impossible "strip:generate_tree:match"
	 (** Create a new default-tree from the default-patterns;
	     delay the generation of a default-tree;
	     indicate whether resulting default-tree is generated here
	  **)
	    local
	      val don't = not
	    in
	      fun new_default_tree nil = (true,default_tree)
		| new_default_tree defaults =
		  let
		    fun new_default_tree nil _ = default_tree
		      | new_default_tree (default::defaults) include_non_defaults =
			let
			  val (default,separate,generate_tree) =
                            if include_non_defaults then (default,false,generate_tree rootvars')
                            else (strip default,true,generate_tree')
			  val old_default =
			    case defaults of
			      [] => true
			    | _ => false
			in
			  ref(UNBUILT(fn env =>
				      generate_tree'' generate_tree default (separate,false,
									     new_default_tree defaults (don't include_non_defaults))
				      env old_default,
				      ref NONE,nil,false))
			end
		  in
		    (false,new_default_tree defaults include_non_defaults)
		  end
	    end
	    local
	   (** filter patterns with same longvalid;
               accumulate exception constructors of same type(possibly identical at runtime).
	    **)
	      fun CONsplit (add_pat,exception_constructor) (patterns as (((opt,pat)::_,_),tree)::_) =
	        let
		  val construc_pat = make_construc pat opt
		  val same_pattern =
		    case exception_constructor of
		      SOME(_) =>
			let
			  fun pattern_type (Absyn.APPpat((_,ref ty),_,_,_)) = ty
			    | pattern_type (Absyn.VALpat((_,(ref ty,_)),_)) = ty
			    | pattern_type _ = Crash.impossible "pattern_type:CONsplit:match"
			  val construc_pat_type = pattern_type pat
			in
			  (fn (p,lvi) =>
			   if lvi === construc_pat then
			     (true,false)
			   else
			     if Types.type_eq(pattern_type p, construc_pat_type, true, true) then
			       (case tree of
				  SOME(tree) =>
				    (case !tree of
				       NONE =>
					 (tree :=
					  SOME(INL(ref(
									  INL(0,LEAF(Absyn.RECORDexp(nil),0,nil)))));
					  (true,true))
				     | SOME(_) => (true,true))
				| NONE => Crash.impossible "same_pattern:CONsplit:match")
			     else (false,true))
			end
		    | NONE =>
			fn (_,lvi) => (lvi === construc_pat,false)
		  fun add_exn (lvi,info,exp' as ((exp,n,exns),mvs)) = ((exp,n,(lvi,info)::exns),mvs)
		  fun add_exns pats =
		    let
		      val info =
			case exception_constructor of
			  SOME(info) => info
			| NONE => Crash.impossible "info:add_exns:CONsplit:match"
		      fun add_exns nil = nil
			| add_exns ((lvi,(pp,exp))::pats) = (pp,add_exn(lvi,info,exp))::add_exns pats
		    in
		      add_exns pats
		    end
		  fun insplit [] (p1,p2) =
		    (case tree of
		       SOME(ref(SOME(_))) => add_exns (rev p1)
		     | _ => map (fn (_,p)=>p) (rev p1), rev p2, pat, tree)
		    | insplit ((pats as ((opt,p)::pp,exp),tree')::pl) (p1,p2) =
		      let
			val lvi = make_construc p opt
			val (same_pattern,different_exception_pattern) = same_pattern(p,lvi)
		      in
			if same_pattern then
			  insplit pl ((lvi,(add_pat p pp,exp))::p1,
				      if different_exception_pattern then (pats,tree)::p2
				      else p2)
			else
			  insplit pl (p1,(pats,tree')::p2)
		      end
		    | insplit _ _ =
                      Crash.impossible "insplit:CONsplit:generate_tree:match"
	        in
		  insplit patterns ([],[])
	        end
		| CONsplit _ _ =
		  Crash.impossible "CONsplit:generate_tree:match"
	    in
	  (** form a SCON match-tree;
	      some exhaustiveness/redundancy checking is done here
	   **)
	      fun scon_rule patterns Type =
		let
		  val arity =
		    if Types.type_eq(Type, Types.char_type, false, false)
		    orelse Types.type_eq(Type, Types.word8_type, false, false)
		    orelse Types.type_eq(Type, Types.int8_type, false, false)
		    then 256
		    else 0
		  val SCONsplit = CONsplit ((fn _ => fn pats => pats),NONE)
		  val (old_default,default_tree) = new_default_tree defaults
		  val binding = make_binding default_tree
		  val env = simple_fetch_env env rootvar
		  fun Make_tree_list nil result = result
		    | Make_tree_list patterns (trees,lvis,env) =
		      let
			val (same_patterns,rest,pat,_) = SCONsplit patterns
		      in
			(case pat of
			   Absyn.SCONpat (scon, _) =>
			     let
			       val ((env, new_env),redundant) =
				 update_env (pat,Dummy_MV) env Type
			     in
			       if redundant then
				 Make_tree_list rest (trees,lvis,env)
			       else
				 Make_tree_list rest
				 ((scon,generate_tree' same_patterns (true,exception_tree,default_tree) new_env)::trees,
				  scon::lvis,
				  env)
			     end
			 | _  => Crash.impossible
			     "Make_tree_list:scon_rule:generate_tree:match")
		      end
		  val (trees,lvis,env) = Make_tree_list (map (fn pat=>(pat,NONE)) patterns) (nil,nil,env)
		  val (env, exhaustive, missing_cons) =
		    all_constructors_present env (INL lvis) Type arity
		  val (default, default') =
		    if exhaustive then
		      (NONE, NONE)
		    else
		      let
			val def = MakeDefaultTree default_tree env
		      in
			(SOME def, SOME def)
		      end
		in
		  (make_default default_tree old_default missing_cons;
		   case trees of
		     [] => DEFAULT
		       (case default of
			  SOME default => (default, binding)
			| _ => Crash.impossible "DEFAULT:scon_rule:match")
		   | _ =>
		     SCON(rootvar, trees, default', binding, Types.sizeof Type))
		end

          (** form a CONSTRUCTOR match-tree;
	      some exhaustiveness/redundancy checks are done here
	   **)
	      fun constructor_rule patterns Type =
		let
		  val (old_default,default_tree) = new_default_tree defaults
		  val (exception_constructor,info) =
                    case patterns of
                      ((_,Absyn.APPpat((Ident.LONGVALID(_,Ident.EXCON(_)),_),_,_,_))::_,_)::_ =>
                        (SOME(rootvar,default_tree),fn ()=>SOME(ref NONE))
                    | ((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.EXCON(_)),(ref ty,_)),_))::_,_)::_ =>
                        (SOME(rootvar,default_tree),fn ()=>SOME(ref NONE))
                    | _ => (NONE,fn ()=>NONE)
		  val CONsplit = CONsplit
		    ((fn pat => fn pats =>
		      case pat of
			Absyn.APPpat(_,newpat,_,_) => (NONE,newpat)::pats
		      | _ => pats), exception_constructor)
		  val binding =
		    case make_binding default_tree of
		      SOME(bd) => [INL(bd)]
		    | NONE => []
		  val env = simple_fetch_env env rootvar
		  (** If possibility of runtime exception identity,
		   share trees and bind in this node effectively delaying real pattern matching
                   else
                     build trees as normal
                   **)
		  fun Make_tree_list nil (trees,boundtrees,lvis,env) = (rev trees,rev boundtrees,rev lvis,env)
		    | Make_tree_list patterns (trees,boundtrees,lvis,env) =
		      let
			val (same_patterns,rest,pat,tree) = CONsplit patterns
		      in
			(case pat of
			   Absyn.VALpat((lvi,_),_) =>
			     Make_tree_list rest
			     (case tree of
				NONE =>
				  let
				    val ((env, new_env),redundant) = update_env (pat,Dummy_MV) env Type
				  in
				    if redundant then (trees,boundtrees,lvis,env)
				    else
				      ((lvi,Dummy_MV,
					INL(generate_tree'
						     same_patterns (true,exception_tree,default_tree) new_env))::trees,
				       boundtrees,
				       lvi::lvis,
				       env)
				  end
			      | SOME(tree) =>
				  (case !tree of
				     NONE =>
				       let
					 val ((env, new_env),redundant) = update_env (pat,Dummy_MV) env Type
				       in
					 if redundant then (trees,boundtrees,lvis,env)
					 else
					   ((lvi,Dummy_MV,
					     INL(generate_tree' same_patterns
							  (true,exception_tree,default_tree) new_env))::trees,
					    boundtrees,
					    lvi::lvis,
					    env)
				       end
				   | SOME(INL(tree')) =>
				       let
					 val ((env, new_env),redundant) = update_env (pat,Dummy_MV) env Type
				       in
					 if redundant then (trees,boundtrees,lvis,env)
					 else
					   (tree' :=
					    INL(next_label(),
							 generate_tree' same_patterns (true,true,default_tree) new_env);
					    tree := SOME(INR(tree',Dummy_MV));
					    ((lvi,Dummy_MV,INR(tree'))::trees,
					     INR(tree',Dummy_MV)::boundtrees,
					     lvi::lvis,
					     env))
				       end
				   | SOME(INR(tree,_)) =>
				       ((lvi,Dummy_MV,INR(tree))::trees,
					boundtrees,
					lvi::lvis,
					env)))
			 | Absyn.APPpat((lvi,_),_,_,_) =>
			     Make_tree_list rest
			     (case tree of
				NONE =>
				  let
				    val matchvar = next_Matchvar()
				    val ((env, new_env),redundant) = update_env (pat,matchvar) env Type
				  in
				    if redundant then (trees,boundtrees,lvis,env)
				    else
				      ((lvi,matchvar,
					INL(generate_tree (matchvar::rootvars)
						     same_patterns (true,exception_tree,default_tree) new_env))::trees,
				       boundtrees,
				       lvi::lvis,
				       env)
				  end
			      | SOME(tree) =>
				  (case !tree of
				     NONE =>
				       let
					 val matchvar = next_Matchvar()
					 val ((env, new_env),redundant) = update_env (pat,matchvar) env Type
				       in
					 if redundant then (trees,boundtrees,lvis,env)
					 else
					   ((lvi,matchvar,
					     INL(generate_tree (matchvar::rootvars) same_patterns
							  (true,exception_tree,default_tree) new_env))::trees,
					    boundtrees,
					    lvi::lvis,
					    env)
				       end
				   | SOME(INL(tree')) =>
				       let
					 val matchvar = next_Matchvar()
					 val ((env, new_env),redundant) = update_env (pat,matchvar) env Type
				       in
					 if redundant then (trees,boundtrees,lvis,env)
					 else
					   (tree' :=
					    INL(next_label(),
							 generate_tree (matchvar::rootvars)
							 same_patterns (true,true,default_tree) new_env);
					    tree := SOME(INR(tree',matchvar));
					    ((lvi,matchvar,INR(tree'))::trees,
					     INR(tree',matchvar)::boundtrees,
					     lvi::lvis,
					     env))
				       end
				   | SOME(INR(tree,matchvar)) =>
				       ((lvi,matchvar,INR(tree))::trees,
					boundtrees,
					lvi::lvis,
					env)))
			 | _ => Crash.impossible
			     "Make_tree_list:constructor_rule:generate_tree:match")
		      end
		  val (trees,boundtrees,lvis,env) =
		    Make_tree_list (map (fn pat=>(pat,info())) patterns) (nil,nil,nil,env)
		  val Type = TypeUtils.get_cons_type(Types.the_type(Type))
		  val (env,all_constructors_present,missing_constructors) =
		    all_constructors_present env (INR lvis) Type (TypeUtils.get_no_cons Type)
		  val default =
		    if all_constructors_present then
		      NONE
		    else
		      SOME(MakeDefaultTree default_tree env)
		in
		  (make_default default_tree old_default missing_constructors;
		   case trees of
		     [] => DEFAULT(case (default,binding) of
				     (SOME(default),[]) => (default,NONE)
				   | (SOME(default),[INL(binding)]) =>  (default,SOME(binding))
				   | _ => Crash.impossible "DEFAULT:constructor_rule:match")
		   | _ => CONSTRUCTOR(Type,rootvar,trees,INL(default),binding@@boundtrees,false))
		end

	    end

         (** form RECORD-match-trees;
	     all nested records are taken into account so that the match-compiler looks ahead
	     infinitely in choosing best order for matching patterns
	  **)
	    fun record_rule patterns Type =
	      let
		(** an indicator that a nested record pattern has been encountered while processing
		  a record pattern
	       **)
		datatype pattern =
		  Record of DataTypes.Type * Matchvar * (Ident.Lab * Matchvar) list ref
                | NONRecord
	      (** a collection of parameters from which RECORD-match-trees are subsequently
		  formed
	       **)
		val nested_records : (DataTypes.Type * Matchvar *
				      (Ident.Lab * Matchvar) list ref) list ref = ref nil
		fun (x,y):::(xs,ys) = (x::xs,y::ys)
		(** re-order all patterns in a record and all its nested records in order of the
		 number of non-variable patterns and also the number of repeated constructors
		 **)
		fun fetchLabelledPatterns (ty,matchvar,matchvars) toplevel patterns =
		  let
		    fun fetch_labelled_patterns nil patterns =
		      (case patterns of
			 [(nil,_)] => nil
		       | _ => patterns)
		      |   fetch_labelled_patterns (((NONE,pattern),env)::rest) patterns =
			  let
			    datatype flag = ABSENT | PRESENT
			    (** for all labelled patterns missing in the last record pattern, insert a
			     wild pattern
			     **)
			    fun add_dummy_patterns (nil,nil) = nil
			      | add_dummy_patterns ((record,pats)::patterns,ABSENT::checklist) =
				(record,((NONE,Absyn.WILDpat Ident.Location.UNKNOWN),env)::pats)
				::add_dummy_patterns (patterns,checklist)
			      | add_dummy_patterns ((record,pats)::patterns,nil) =
				(record,((NONE,Absyn.WILDpat Ident.Location.UNKNOWN),env)::pats)
				::add_dummy_patterns (patterns,nil)
			      | add_dummy_patterns (pats::patterns,PRESENT::checklist) =
				pats::add_dummy_patterns (patterns,checklist)
			      | add_dummy_patterns _ = Crash.impossible
				("add_dummy_patterns:fetch_labelled_patterns:"^
				 "record_rule:match")
			  in
			    (case (if toplevel then fetch_pat (SOME(matchvar,env)) pattern
				   else pattern)  of
			       Absyn.RECORDpat(pats,_,_) =>
				 let
				   fun Fetch_labelled_patterns pats patterns =
				     let
				       fun Fetch_labelled_patterns nil patterns_checklist = patterns_checklist
					 | Fetch_labelled_patterns ((lab,pat)::rest)
					   (patterns_checklist as (patterns,checklist)) =
					   let
					     fun duplicate_ABSENT nil = nil
					       |   duplicate_ABSENT (_::rest) = ABSENT::duplicate_ABSENT rest
					     fun pat_type pat_type' matchvar =
					       case fetch_pat (SOME(matchvar,env)) pat of
						 pat as Absyn.RECORDpat((_,_,ref ty)) =>
						   (case pat_type' of
						      NONRecord =>
							let
							  val refnil = ref nil
							in
							  (nested_records := (ty,matchvar,refnil)::(!nested_records);
							   (Record(ty,matchvar,refnil),pat))
							end
						    | record as Record(_) => (record,pat))
					       | pat => (pat_type',pat)
					     (** for every labelled-pattern, update the collections by labels of all
					      the labelled-patterns encountered so far
					      **)
					     fun add_labelled_pattern nil nil =
					       let
						 val matchvar = next_Matchvar()
						 val (pat_type,pat) = pat_type NONRecord matchvar
						 val _ = matchvars := (lab,matchvar)::(!matchvars)
						 fun add_labelled_wildpat (nil,nil) = nil
						   | add_labelled_wildpat (((_,pats)::_),checklist) =
						     let
						       fun add_labelled_wildpat nil = nil
							 | add_labelled_wildpat (_::rest) =
							   ((NONE,Absyn.WILDpat Ident.Location.UNKNOWN),env)
							   ::add_labelled_wildpat rest
						     in
						       case checklist of
							 PRESENT::_ => add_labelled_wildpat (tl pats)
						       | ABSENT::_ => add_labelled_wildpat pats
						       | nil => add_labelled_wildpat pats
						     end
						   | add_labelled_wildpat _ = Crash.impossible
						     ("add_labelled_wildpat:fetch_labelled_patterns:"^
						      "record_rule:match")
					       in
						 ([([(lab,matchvar,pat_type)],((NONE,pat),env)
						    ::add_labelled_wildpat patterns_checklist)],[PRESENT])
					       end
					       | add_labelled_pattern [(nil,pats)] nil =
						 let
						   val matchvar = next_Matchvar()
						   val (pat_type,pat) = pat_type NONRecord matchvar
						   val _ = matchvars := (lab,matchvar)::(!matchvars)
						 in
						   ([([(lab,matchvar,pat_type)],((NONE,pat),env)::pats)],
						    [PRESENT])
						 end
					       | add_labelled_pattern ((entry as ([(label,matchvar,pat_type')],pats))
								       ::patterns) (check::checklist) =
						 if Ident.lab_eq(lab,label)
						   then
						     let val (pat_type,pat) = pat_type pat_type' matchvar
						     in
						       (([(label,matchvar,pat_type)],
							 ((NONE,pat),env)::pats)::patterns,
							PRESENT::checklist)
						     end
						 else (entry,check):::add_labelled_pattern patterns checklist
					       | add_labelled_pattern
						 ((entry as ([(label,matchvar,pat_type')],pats))::patterns) nil =
						 if Ident.lab_eq(lab,label)
						   then
						     let val (pat_type,pat) = pat_type pat_type' matchvar
						     in
						       (([(label,matchvar,pat_type)],
							 ((NONE,pat),env)::pats)::patterns,
							PRESENT::duplicate_ABSENT patterns)
						     end
						 else (entry,ABSENT):::add_labelled_pattern patterns nil
					       | add_labelled_pattern _ _ = Crash.impossible
						 ("1:add_labelled_pattern:fetch_labelled_patterns"^
						  ":record_rule:match")
					   in
					     case pat of
					       Absyn.WILDpat _ =>
						 Fetch_labelled_patterns rest patterns_checklist
					     | _ =>
						 Fetch_labelled_patterns rest
						 (add_labelled_pattern patterns checklist)
					   end
				     in
				       case Fetch_labelled_patterns pats (patterns,nil) of
					 (_,nil) =>
					   fetch_labelled_patterns (((NONE,Absyn.WILDpat Ident.Location.UNKNOWN),env)::rest)
					   patterns
				       | patterns =>
					   fetch_labelled_patterns rest (add_dummy_patterns patterns)
				     end
				 in
				   Fetch_labelled_patterns pats patterns
				 end
			     | pat as Absyn.WILDpat _ =>
				 fetch_labelled_patterns rest
				 (case patterns of
				    nil => [(nil,[((NONE,pat),env)])]
				  | [(nil,entry)] =>
				      [(nil,((NONE,pat),env)::entry)]
				  | _ => add_dummy_patterns (patterns,nil))
			     | _ => Crash.impossible "1:fetch_labelled_patterns:record_rule:match")
			  end
		      | fetch_labelled_patterns _ _ =
			Crash.impossible "2:fetch_labelled_patterns:record_rule:match"
		    (** repeat operation for all nested records
		     **)
		    fun fetch_nested_labelled_patterns nil = nil
		      | fetch_nested_labelled_patterns
			(([(label,matchvar,NONRecord)],pats)::patterns) =
			(matchvar,pats)::fetch_nested_labelled_patterns patterns
		      | fetch_nested_labelled_patterns
			(([(label,matchvar,Record(record))],pats)::patterns) =
			fetchLabelledPatterns record false (rev pats) @@
			fetch_nested_labelled_patterns patterns
		      | fetch_nested_labelled_patterns  _ =
			Crash.impossible "fetch_nested_labelled_patterns:record_rule:match"
		  in
		    fetch_nested_labelled_patterns (fetch_labelled_patterns patterns nil)
		  end
		(** a heuristic for ordering patterns : the number of stages of matching
	      in the pattern
		 **)
		infix <
		fun (Absyn.VALpat(_)) < _ = true
		  | (Absyn.APPpat(_,pat,_,_)) < (Absyn.APPpat(_,pat',_,_)) = pat<pat'
		  | _ < (Absyn.APPpat(_)) = true
		  | (Absyn.APPpat(_)) < _ = false
		  | _ < _ = true
		(** find the number of repeated constructors in a set of patterns
		 **)
		fun inner_sort nil = nil
		  | inner_sort ((matchvar,patterns)::rest) =
		    let
		      fun calculate_scores patterns =
			let
			  fun a':::(a,(b,c,d)) = (a'::a,(b,c,d))
			  fun split (((NONE,pat),env)::rest) =
			    let
			      fun Split nil _ (score,rest,pat) =
				(nil,(score,rest,pat))
				| Split (((NONE,pattern''),env)::rest)
				  construc (score,rest_so_far,pattern') =
				  (case pattern'' of
				     Absyn.WILDpat _ =>
				       ((SOME(matchvar,NONE),pattern''),env)
				       :::(Split rest construc (score,rest_so_far,pattern'))
				   | _ =>
				       let
					 val construc_pattern = the_construc pattern''
					 val pattern =
					   ((SOME(matchvar,SOME(construc_pattern)),
					     pattern''),env)
				       in
					 pattern:::(Split rest construc
						    (if construc===construc_pattern
						       then (score+1,rest_so_far,
							     if pattern'<pattern'' then pattern''
							     else pattern')
						     else (score,pattern::rest_so_far,
							   if pattern'<pattern'' then pattern''
							   else pattern')))
				       end)
				| Split _ _ _ =
				  Crash.impossible "1:Split:inner_sort:record_rule:match"
			    in
			      case pat of
				Absyn.WILDpat _ =>
				  ((SOME(matchvar,NONE),pat),env):::(split rest)
			      | _ =>
				  let
				    val construc_pattern = the_construc pat
				  in
				    ((SOME(matchvar,SOME(construc_pattern)),
				      pat),env)
				    :::(Split rest construc_pattern (1,nil,pat))
				  end
			    end
			    | split ((pattern as
				      (SOME(_, SOME(construc_pattern)),
				       pat),env)::rest) =
			      let
				fun Split nil _ (score,rest) =
				  (score,rest,Absyn.WILDpat Ident.Location.UNKNOWN)
				  | Split ((pattern as
					    ((SOME(_, SOME(construc_pattern)),_),env))::rest)
				    construc (score,rest_so_far) =
				    Split rest construc
				    (if construc===construc_pattern
				       then (score+1,rest_so_far)
				     else (score,pattern::rest_so_far))
				  | Split _ _ _ =
				    Crash.impossible "2:Split:inner_sort:record_rule:match"
			      in
				(nil,Split rest construc_pattern (1,nil))
			      end
			    | split nil = (nil,(0,nil,Absyn.WILDpat Ident.Location.UNKNOWN))
			    | split _ = Crash.impossible "split:inner_sort:record_rule:match"
			  fun calculate_scores patterns =
			    let
			      fun calculate_scores (scores,nil) = scores
				| calculate_scores (scores,rest) =
				  let val (_,(score,rest,_)) = split rest
				  in
				    calculate_scores (score::scores,rest)
				  end
			      val (patterns,(score,rest,pattern)) = split patterns
			    in
			      (patterns,pattern,calculate_scores ([score],rest))
			    end
			  val score =
			    Lists.reducel
			    (fn (score, pat) =>
			     case pat of
			       ((NONE,Absyn.WILDpat _),_) => score
			     | _ => score+1)
			    (0, patterns)
			  val (patterns,pattern,scores) =
			    calculate_scores(rev patterns)
			in
			  (score,patterns,pattern,scores)
			end
		      val sort =
                        Lists.reducel
			(fn (score1:int,score2:int) =>
			 if score1>score2 then score1
			 else score2)
		      val (score,patterns,pattern,scores) = calculate_scores patterns
		    in
		      (patterns,pattern,score,sort (0,scores))::inner_sort rest
		    end
	      (** sort patterns by the number of repeated constructors and the number of
		  non-variables
	       **)
		val sort = Lists.qsort
		  (fn ((_,pattern,score11 : int,score21 : int),
		       (_,pattern',score12,score22)) =>
		   score11 > score12 orelse
		   score11 = score12 andalso
		   (score21>score22 orelse score21=score22
		    andalso pattern<pattern'))
		(** put result back into format required by the generation process
		 **)
		fun merge remaining_patterns patterns =
		  let
		    fun merge nil nil = nil
		      | merge patterns
			((remaining_pattern,(exp,remaining_env))::remaining_patterns) =
                        let
			  infix @@@@
			  infix @@@@@@
			  fun (pat,pattern)@@@@(pats,patterns) = (pat::pats,pattern::patterns)
			  fun pat@@@@@@(pats,patterns) = (pat::pats,patterns)
			  fun reduce [(((opt,pattern),_)::patterns,pat,
				       score1,score2)] =
			    (case patterns of
			       nil => ([(opt,pattern)],nil)
			     | _ =>
				 ([(opt,pattern)],[(patterns,pat,score1,score2)]))
                            | reduce ((((opt,pattern),_)::patterns,pat,
				       score1,score2)::rest) =
			      (case patterns of
				 nil => (opt,pattern)@@@@@@reduce rest
			       | _ =>
				   ((opt,pattern),(patterns,pat,score1,score2))@@@@reduce rest)
                            | reduce nil = (nil,nil)
                            | reduce _ =
			      Crash.impossible "reduce:merge:record_rule:generate_tree:match"
			  val (patterns,rest) = reduce patterns
                        in
			  (patterns@@remaining_pattern,(exp,!remaining_env))
			  ::merge rest remaining_patterns
                        end
		      | merge _ _ =
			Crash.impossible "merge:record_rule:generate_tree:match"
		  in
                    merge patterns remaining_patterns
		  end
	      (** place patterns into format suitable for processing that follows
	       **)
		fun refer_to_envs _ nil = (nil,nil)
		  | refer_to_envs f ((pattern::patterns,(exp,env))::rest) =
		    let val refenv = ref env
		    in
		      ((f pattern,refenv),(patterns,(exp,refenv))):::refer_to_envs f rest
		    end
		  | refer_to_envs _ _ = Crash.impossible "refer_to_envs:match"
		      
		val (patterns,remaining_patterns) =
		  refer_to_envs (fn (opt,pat)=>(opt,pat)) (patterns@@flat defaults)
		val matchvars = ref nil
		val patterns =
		  (merge remaining_patterns o sort o inner_sort o
		   fetchLabelledPatterns (Type,rootvar,matchvars) true) patterns
		fun reverse nil result = result
		  | reverse ((ty,mv,mvs)::rest) result = reverse rest ((ty,mv,!mvs)::result)
		val nested_records = (Type,rootvar,!matchvars)::reverse (!nested_records) nil
		(** update environments by matchvars assigned to labelled-patterns for later
		 exhaustiveness and redundancy checking
		 **)
		local
		  fun update_record_env f envs =
		    let
		      fun update_record_env' ([env],nil) = f env
			| update_record_env' (env,((mvar,mvar')::mvars)) =
			  update_record_env' (#2(#1(update_env (Absyn.WILDpat Ident.Location.UNKNOWN,mvar)
						    (simple_fetch_env env mvar')
						    DataTypes.NULLTYPE)),mvars)
			| update_record_env' _ =
			  Crash.impossible "update_record_env:generate_tree:match"
		    in
		      map
		      (fn (env, mvars) => update_record_env'([env], mvars))
		      envs
		    end
		in
		  fun match_matchvars nil env =
		    Crash.impossible "1:match_matchvars:generate_tree:match"
		    | match_matchvars (mvars as (_,rootvar,_)::_) env =
		      let
			fun match_matchvars nil env =
			  update_record_env (fn env=>env) env
			  | match_matchvars [(_,_,nil)] env =
			    update_record_env (fn env=>env) env
			  | match_matchvars ((_,_,nil)::(mvars as (_,rootvar,_)::_)) env =
			    match_matchvars mvars
			    (fetch_environment'
			     (update_record_env (fn env=>(env,nil)) env) rootvar)
			  | match_matchvars ((ty,root,(mvar' as (lab,mvar))::mvars)::matchvars) env =
			    let
			      fun fetch_mvar nil = NONE
				| fetch_mvar ((lab',mvar')::l') =
				  if Ident.lab_eq (lab,lab') then SOME(mvar')
				  else fetch_mvar l'
			    in
			      match_matchvars ((ty,root,mvars)::matchvars)
			      (map (fn ((entry as (mvs,REC(mvars')))::env,mvars'') =>
				    (case fetch_mvar mvars' of
				       SOME(mvar') => (entry::env,(mvar,mvar')::mvars'')
				     | NONE =>
					 ((mvs,REC(mvar'::mvars'))::env,mvars''))
			            | ((mvs,CON1([]))::env,mvars'') =>
                       	              ((mvs,REC(mvar'::nil))::env,mvars'')
				    | _ =>
					Crash.impossible "2:match_matchvars:generate_tree:match")
			      env)
			    end
		      in
			match_matchvars mvars (complex_fetch_env env rootvar)
		      end
		end
	      (** generate all the record-trees for this record-pattern
	       **)
		fun generate_record_tree nil =
		  generate_tree' patterns (true,exception_tree,default_tree)
		  (match_matchvars nested_records env)
		  | generate_record_tree ((ty,matchvar,matchvars)::records) =
		    RECORD(Types.the_type(ty),matchvar,matchvars,generate_record_tree records)
	      in
            	generate_record_tree nested_records
	      end
	  in
	    case non_defaults of
	      ((_,Absyn.RECORDpat(_,_,ref ty))::_,_)::_ =>
		(record := false; record_rule non_defaults ty)
	    | ((_,Absyn.APPpat((_,ref ty),_,_,_))::_,_)::_ => constructor_rule non_defaults ty
	    | ((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.CON(_)),(ref ty,_)),_))::_,_)::_ =>
		constructor_rule non_defaults ty
	    | ((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.EXCON(_)),(ref ty,_)),_))::_,_)::_ =>
		constructor_rule non_defaults ty
	    | ((_,Absyn.SCONpat (pat, ty))::_,_)::_ =>
		scon_rule non_defaults (!ty)
		(*
		(case pat of
		   Ident.INT _ => Types.int_type
		 | Ident.REAL _ => Types.real_type
		 | Ident.CHAR _ => Types.char_type
		 | Ident.WORD _ => Types.word_type
		 | Ident.STRING _ => Types.string_type)
		 *)
	    | nil =>
		if (!record) then
		  (record := false;
		   record_rule (hd defaults')
		   (case (!record_type) of
		      NONE =>
			Crash.impossible "1:generate_tree:match"
		    | SOME ty => ty))
		else
		  let val (old_default,new_default_tree) = new_default_tree defaults
		  in
		    generate_tree'' generate_tree' (strip (hd defaults'))
		    (true,exception_tree,new_default_tree) env old_default
		  end
		    | _ => Crash.impossible "2:generate_tree:match"
	  end
	| generate_tree _ _ _ _ = Crash.impossible "3:generate_tree:match"
    in
      (** General purpose routines for printing out the Trees. **)
      fun unparseTree options tree space_out =
	let
	  fun unparseDef (INL(def)) =
            (case def of
               NONE => "Absent default"
             | SOME(ref(BUILT(ref(INL(n,_))))) =>
		 "Present default of "^"'TREE "^Int.toString n^"'"
             | SOME(ref(ERROR _)) =>
                 "Present default of 'ERROR'"
             | _ =>
                 Crash.impossible "1:unparseDef:unparseTree:match")
            | unparseDef (INR(ref(INL(n,_)))) =
	      "Present default of "^"'TREE "^Int.toString n^"'"
            | unparseDef (INR _) =
	      Crash.impossible "2:unparseDef:unparseTree:match"

	  fun list_subs [] rest = rest
	    | list_subs ((m, vi, _)::ll) rest =
	      list_subs ll
	      (rest @@ [" '", IdentPrint.printValId options vi, "'/#",
		       Int.toString m])

	  fun list_fields [] rest = rest
	    | list_fields ((m, vi)::ll) rest =
	      list_fields ll
	      (rest @@ [" '", IdentPrint.printLab m, "'=#", Int.toString vi])

	  fun list_scons [] rest = rest
	    | list_scons ((m, vi)::ll) rest =
	      ["\n", space_out, "'", IdentPrint.printSCon m,
	       "' =>\n"] @@ unparseTree options vi ("  " ^ space_out) @@ list_scons ll rest

	  fun list_cons [] rest = rest
	    | list_cons ((lvi, mv, tr)::ll) rest =
	      ["\n", space_out, "'", IdentPrint.printLongValId options lvi,
	       "' --(#", Int.toString mv, ")\n"]
	      @@ (case tr of
		   INL(tr) => unparseTree options tr ("  " ^ space_out)
		 | INR(ref(INL(n,_))) =>
		     ["  " ^ space_out^"'TREE "^Int.toString n^"'"]
		 | _ => Crash.impossible "list_cons:unparseTree:match") @@ list_cons ll rest
	  fun print_binding binding =
	    Lists.reducel
	    (fn (str,binding) =>
	     str@@
             (case binding of
		INL(ref(SOME(ref(INL(n,tr))))) =>
		  "\n"::space_out::"   "::"'TREE "::Int.toString n::"'"
		  ::" is bound to \n"::unparseTree options tr ("       "^space_out)
              | INL(ref NONE) => nil
              | INR(ref(INL(n,tr)),_) =>
		  "\n"::space_out::"   "::"'TREE "::Int.toString n::"'"
		  ::" is bound to \n"::unparseTree options tr ("       "^space_out)
              | _ => Crash.impossible "print_binding:unparseTree:match"))
	    ("\n"::space_out::"BINDING :"::[],binding)
	in
	  (case tree of
	     LEAF (exp,n,ll) =>
	       (list_subs ll [space_out, "LEAF ",
			      AbsynPrint.unparseExp options exp, " {"]) @@ [" }"]
	   | SCON (mv, ll, def, binding, _) =>
	       ([space_out, "SCON #", Int.toString mv]@@list_scons ll [])
	       @@ (("\n"^space_out)::
		  (unparseDef
		   (INL
		    (case def of
		       SOME def => SOME def
		     | _ => NONE))::
		   (case binding of
		      NONE => []
		    | SOME(bd) =>
			print_binding [INL(bd)])))
	   | CONSTRUCTOR (_, mv, ll, def,binding,_) =>
	       ([space_out, "CONSTRUCTOR #", Int.toString mv]@@list_cons ll [])
	       @@ (("\n"^space_out)::(unparseDef def::(case binding of
							nil => []
						      | _ => print_binding binding)))
	   | RECORD (_, mv, ll, tr) =>
	       (list_fields ll [space_out, "RECORD #", Int.toString mv])
	     @@ ["\n"] @@ (unparseTree options tr ("  " ^ space_out))
	   | DEFAULT(default,binding) => [space_out,unparseDef(INL(SOME(default)))]@@
	       (case binding of
		  NONE => []
		| SOME(bd) => print_binding [INL(bd)]))
	end

      fun compile_match pats =
	let
	  (** Do the set-up **)
	  val rootvar = next_Matchvar()

	  (** convert a '(Absyn.Pat * exp) list' to a pattern list
	   **)

	  fun convert nil _ (redundant_pats,pats) = (tl(rev redundant_pats),rev pats)
	    | convert (pat::pats) true (redundant_pats,pats') =
	      convert pats true (((#1(hd redundant_pats)) + 1,TRUE)::redundant_pats,pats')
	    | convert ((pat,exp,_)::pats) false (redundant_pats,pats') =
	      let
		val n = (#1(hd redundant_pats)) + 1
		val redundant =
		  case fetch_pat NONE pat of
		    Absyn.WILDpat _ => true
		  |_ => false
	      in
		convert pats redundant
		((n,TRUE)::redundant_pats,
		 ([(NONE,pat)],((exp,n,[]),[]))::pats')
	      end
	  val (redundant_pats,pats) = convert pats false ([(0,TRUE)],[])

	  (** Calculate the match tree **)
	  val the_tree =
	    (label_count := 0;redundant_patterns := redundant_pats;
	     inexhaustive := NONE;
	     match_vars := [];
	     generate_tree''
	     (generate_tree [rootvar])
	     pats
	     (true,false,
	      ref(ERROR
		  (fn nil => ()
		   | cons =>
		       inexhaustive :=
		       (case !inexhaustive of
			  SOME cons' =>
			    SOME(cons'@@cons)
			| NONE =>
			    SOME cons)))) [[]] false)
	in
	  (if !show_match then
	     app (ignore o print)
	      ("\n"::unparseTree Options.default_print_options the_tree ""@@["\n"])
	   else
	     ();
             (rootvar,the_tree,!redundant_patterns,!inexhaustive))
	end
    end


  end (* of functor Match *)
@


1.71.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.71  1998/02/20  09:14:20  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.70
log
@[Bug #30153]
Remove references to Old.
@
text
@d3 4
d2262 2
a2263 3
	     (map print
	      ("\n"::unparseTree Options.default_print_options the_tree ""@@["\n"]);
	      ())
@


1.69
log
@[Bug #30090]
Translate output std_out to print
@
text
@d3 4
d240 1
a240 1
require "^.basis.__old";
d741 1
a741 1
	    (fn (ints, s) => bit_set(Old.ord s, ints, []))
@


1.69.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.69  1997/05/19  11:23:04  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.69.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.69  1997/05/19  11:23:04  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.68
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d3 4
d2254 1
a2254 1
	     (map (fn str => MLWorks.IO.output(MLWorks.IO.std_out,str))
@


1.67
log
@[Bug #1728]
__integer becomes __int
@
text
@d3 4
d296 2
d333 1
a333 1
    type 'Tree BoundTree = ((int * 'Tree),lvar) MLWorks.Option.union ref
d346 3
a348 3
	'env DefaultTree ref MLWorks.Option.option
        * 'env Tree BoundTree MLWorks.Option.option ref MLWorks.Option.option
	* int MLWorks.Option.option
d351 4
a354 4
	 ('env Tree,'env Tree BoundTree) MLWorks.Option.union) list
	* ('env DefaultTree ref MLWorks.Option.option,'env Tree BoundTree) MLWorks.Option.union
        * ('env Tree BoundTree MLWorks.Option.option ref,
           'env Tree BoundTree * Matchvar) MLWorks.Option.union list * bool
d832 1
a832 1
		val boundtree = ref(MLWorks.Option.INL(next_label(),tree))
d965 1
a965 1
			     ((exn,Dummy_MV,MLWorks.Option.INL(LEAF(exp)))::trees,rev(boundtrees))
d968 1
a968 1
			       MLWorks.Option.INL(generate_exception_tree exns default_tree))::trees,
d974 1
a974 1
			    ((exn,Dummy_MV,MLWorks.Option.INL(LEAF(exp)))::trees,boundtrees) default_tree
d978 1
a978 1
				ref(MLWorks.Option.INL
d981 1
a981 1
			      val tree_entry = (exn,Dummy_MV,MLWorks.Option.INR tree)
d984 2
a985 2
				  MLWorks.Option.INL _ =>
				    ref(MLWorks.Option.INL
d988 2
a989 2
				  | MLWorks.Option.INR
				    (ref(MLWorks.Option.INL
d991 1
a991 1
				    ref(MLWorks.Option.INL
d999 3
a1001 3
			       MLWorks.Option.INR(default_tree,Dummy_MV)
			       ::MLWorks.Option.INR(tree,Dummy_MV)::boundtrees)
			      (MLWorks.Option.INR(default_tree))
d1006 3
a1008 3
		fun choose_default_tree(MLWorks.Option.INL _) =
		  MLWorks.Option.INL(MLWorks.Option.SOME default_tree')
		  | choose_default_tree(MLWorks.Option.INR _) = default_tree
d1028 1
a1028 1
                   MLWorks.Option.INL(SOME default_tree)
d1392 2
a1393 2
					  SOME(MLWorks.Option.INL(ref(
									  MLWorks.Option.INL(0,LEAF(Absyn.RECORDexp(nil),0,nil)))));
d1476 1
a1476 1
		    all_constructors_present env (MLWorks.Option.INL lvis) Type arity
d1517 1
a1517 1
		      SOME(bd) => [MLWorks.Option.INL(bd)]
d1541 1
a1541 1
					MLWorks.Option.INL(generate_tree'
d1556 1
a1556 1
					     MLWorks.Option.INL(generate_tree' same_patterns
d1562 1
a1562 1
				   | SOME(MLWorks.Option.INL(tree')) =>
d1569 1
a1569 1
					    MLWorks.Option.INL(next_label(),
d1571 3
a1573 3
					    tree := SOME(MLWorks.Option.INR(tree',Dummy_MV));
					    ((lvi,Dummy_MV,MLWorks.Option.INR(tree'))::trees,
					     MLWorks.Option.INR(tree',Dummy_MV)::boundtrees,
d1577 2
a1578 2
				   | SOME(MLWorks.Option.INR(tree,_)) =>
				       ((lvi,Dummy_MV,MLWorks.Option.INR(tree))::trees,
d1593 1
a1593 1
					MLWorks.Option.INL(generate_tree (matchvar::rootvars)
d1609 1
a1609 1
					     MLWorks.Option.INL(generate_tree (matchvar::rootvars) same_patterns
d1615 1
a1615 1
				   | SOME(MLWorks.Option.INL(tree')) =>
d1623 1
a1623 1
					    MLWorks.Option.INL(next_label(),
d1626 3
a1628 3
					    tree := SOME(MLWorks.Option.INR(tree',matchvar));
					    ((lvi,matchvar,MLWorks.Option.INR(tree'))::trees,
					     MLWorks.Option.INR(tree',matchvar)::boundtrees,
d1632 2
a1633 2
				   | SOME(MLWorks.Option.INR(tree,matchvar)) =>
				       ((lvi,matchvar,MLWorks.Option.INR(tree))::trees,
d1644 1
a1644 1
		    all_constructors_present env (MLWorks.Option.INR lvis) Type (TypeUtils.get_no_cons Type)
d1655 1
a1655 1
				   | (SOME(default),[MLWorks.Option.INL(binding)]) =>  (default,SOME(binding))
d1657 1
a1657 1
		   | _ => CONSTRUCTOR(Type,rootvar,trees,MLWorks.Option.INL(default),binding@@boundtrees,false))
d2121 1
a2121 1
	  fun unparseDef (MLWorks.Option.INL(def)) =
d2124 1
a2124 1
             | SOME(ref(BUILT(ref(MLWorks.Option.INL(n,_))))) =>
d2130 1
a2130 1
            | unparseDef (MLWorks.Option.INR(ref(MLWorks.Option.INL(n,_)))) =
d2132 1
a2132 1
            | unparseDef (MLWorks.Option.INR _) =
d2156 2
a2157 2
		   MLWorks.Option.INL(tr) => unparseTree options tr ("  " ^ space_out)
		 | MLWorks.Option.INR(ref(MLWorks.Option.INL(n,_))) =>
d2165 1
a2165 1
		MLWorks.Option.INL(ref(SOME(ref(MLWorks.Option.INL(n,tr))))) =>
d2168 2
a2169 2
              | MLWorks.Option.INL(ref NONE) => nil
              | MLWorks.Option.INR(ref(MLWorks.Option.INL(n,tr)),_) =>
d2183 1
a2183 1
		   (MLWorks.Option.INL
d2190 1
a2190 1
			print_binding [MLWorks.Option.INL(bd)])))
d2199 1
a2199 1
	   | DEFAULT(default,binding) => [space_out,unparseDef(MLWorks.Option.INL(SOME(default)))]@@
d2202 1
a2202 1
		| SOME(bd) => print_binding [MLWorks.Option.INL(bd)]))
@


1.67.5.1
log
@branched from 1.67
@
text
@a2 4
 * Revision 1.67  1996/11/06  11:30:33  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.67.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.67.5.1  1997/05/12  10:37:02  hope
 * branched from 1.67
 *
@


1.67.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.67.5.1  1997/05/12  10:37:02  hope
 * branched from 1.67
 *
@


1.67.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.67.5.1  1997/05/12  10:37:02  hope
 * branched from 1.67
 *
@


1.67.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.67.5.1.1.1  1997/07/28  18:22:18  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.67.4.1
log
@branched from 1.67
@
text
@a2 4
 * Revision 1.67  1996/11/06  11:30:33  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.67.3.1
log
@branched from 1.67
@
text
@a2 4
 * Revision 1.67  1996/11/06  11:30:33  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.67.3.1.1.1
log
@branched from 1.67.3.1
@
text
@a2 3
 * Revision 1.67.3.1  1996/12/17  17:50:24  hope
 * branched from 1.67
 *
@


1.67.2.1
log
@branched from 1.67
@
text
@a2 4
 * Revision 1.67  1996/11/06  11:30:33  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.67.1.1
log
@branched from 1.67
@
text
@a2 4
 * Revision 1.67  1996/11/06  11:30:33  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.67.1.1.1.1
log
@branched from 1.67.1.1
@
text
@a2 3
 * Revision 1.67.1.1  1996/11/14  12:52:49  hope
 * branched from 1.67
 *
@


1.66
log
@[Bug #1614]
removing toplevel String.
@
text
@d3 4
d226 1
a226 1
require "^.basis.__integer";
@


1.65
log
@[Bug #1653]
Fixing problem with comparisons of same constructors in different structures
@
text
@d3 4
d222 3
a224 1
require "../basis/__integer";
d346 1
a346 1
      | DEFAULT of 'env DefaultTree ref * 'env Tree BoundTree MLWorks.Option.option ref MLWorks.Option.option
d350 1
a350 1
      * 'env Tree BoundTree MLWorks.Option.option ref * 'env * bool
d352 1
a352 1
        * 'env Tree BoundTree MLWorks.Option.option ref * 'env * bool
d403 1
a403 1
        so(MLWorks.Option.NONE) and updating environments from them otherwise(MLWorks.Option.SOME(...)).
d410 2
a411 2
	    MLWorks.Option.NONE => (fn _ => ())
	  | (MLWorks.Option.SOME(matchvar,env)) =>
d432 1
a432 1
	((Matchvar * Ident.LongValId MLWorks.Option.option) MLWorks.Option.option * Absyn.Pat) list
d451 1
a451 1
	    val l = Lists.length mv
d541 1
a541 1
		val l = Lists.length mv
d570 2
a571 2
	    fun member(s as INT _, ss) = Lists.exists (fn t => scon_test(s, t)) ss
	      | member(s as WORD _, ss) = Lists.exists (fn t => scon_test(s, t)) ss
d719 1
a719 1
	  fun char_makestring i = "#\"" ^ MLWorks.String.ml_string(String.chr i, 3) ^ "\""
d723 1
a723 1
	    (fn (ints, s) => bit_set(String.ord s, ints, []))
d732 1
a732 1
	       Lists.filterp
d749 1
a749 1
	      (Lists.filterp (fn i => not(is_set(i, word'))) word)
d786 2
a787 2
      val inexhaustive : (DataTypes.Type * Ident.ValId list) list MLWorks.Option.option ref =
	ref(MLWorks.Option.NONE)
d794 1
a794 1
      val record_type : DataTypes.Type MLWorks.Option.option ref = ref MLWorks.Option.NONE
d824 1
a824 1
		binding := MLWorks.Option.SOME boundtree;
d847 5
a851 5
	 if old_default then MLWorks.Option.NONE
	 else MLWorks.Option.SOME binding)
	| make_binding(ref(UNBUILT' _)) = MLWorks.Option.NONE
	| make_binding(ref(BUILT _)) = MLWorks.Option.NONE
	| make_binding(ref(ERROR _)) = MLWorks.Option.NONE
d1008 1
a1008 1
	   Lists.filterp (fn (m, _) => m <> n) (!redundant_patterns));
d1018 1
a1018 1
                   MLWorks.Option.INL(MLWorks.Option.SOME default_tree)
d1164 1
a1164 1
					(record := true;record_type := MLWorks.Option.SOME(ty))
d1206 1
a1206 1
			   (record := true;record_type := MLWorks.Option.SOME(ty))
d1281 1
a1281 1
			      record_type := MLWorks.Option.SOME(ty))
d1301 2
a1302 2
                 MLWorks.Option.NONE => generate_tree rootvars patterns default env
	       | MLWorks.Option.SOME(matchvar,_) =>
d1309 2
a1310 2
		MLWorks.Option.NONE => the_construc pat
	      | MLWorks.Option.SOME(_,MLWorks.Option.SOME(construc)) => construc
d1350 1
a1350 1
				      ref MLWorks.Option.NONE,nil,false))
d1365 1
a1365 1
		      MLWorks.Option.SOME(_) =>
d1378 1
a1378 1
				  MLWorks.Option.SOME(tree) =>
d1380 1
a1380 1
				       MLWorks.Option.NONE =>
d1382 1
a1382 1
					  MLWorks.Option.SOME(MLWorks.Option.INL(ref(
d1385 2
a1386 2
				     | MLWorks.Option.SOME(_) => (true,true))
				| MLWorks.Option.NONE => Crash.impossible "same_pattern:CONsplit:match")
d1389 1
a1389 1
		    | MLWorks.Option.NONE =>
d1396 2
a1397 2
			  MLWorks.Option.SOME(info) => info
			| MLWorks.Option.NONE => Crash.impossible "info:add_exns:CONsplit:match"
d1405 1
a1405 1
		       MLWorks.Option.SOME(ref(MLWorks.Option.SOME(_))) => add_exns (rev p1)
d1438 1
a1438 1
		  val SCONsplit = CONsplit ((fn _ => fn pats => pats),MLWorks.Option.NONE)
d1464 1
a1464 1
		  val (trees,lvis,env) = Make_tree_list (map (fn pat=>(pat,MLWorks.Option.NONE)) patterns) (nil,nil,env)
d1469 1
a1469 1
		      (MLWorks.Option.NONE, MLWorks.Option.NONE)
d1474 1
a1474 1
			(MLWorks.Option.SOME def, MLWorks.Option.SOME def)
d1481 1
a1481 1
			  MLWorks.Option.SOME default => (default, binding)
d1496 1
a1496 1
                        (MLWorks.Option.SOME(rootvar,default_tree),fn ()=>MLWorks.Option.SOME(ref(MLWorks.Option.NONE)))
d1498 2
a1499 2
                        (MLWorks.Option.SOME(rootvar,default_tree),fn ()=>MLWorks.Option.SOME(ref(MLWorks.Option.NONE)))
                    | _ => (MLWorks.Option.NONE,fn ()=>MLWorks.Option.NONE)
d1503 1
a1503 1
			Absyn.APPpat(_,newpat,_,_) => (MLWorks.Option.NONE,newpat)::pats
d1507 2
a1508 2
		      MLWorks.Option.SOME(bd) => [MLWorks.Option.INL(bd)]
		    | MLWorks.Option.NONE => []
d1524 1
a1524 1
				MLWorks.Option.NONE =>
d1537 1
a1537 1
			      | MLWorks.Option.SOME(tree) =>
d1539 1
a1539 1
				     MLWorks.Option.NONE =>
d1552 1
a1552 1
				   | MLWorks.Option.SOME(MLWorks.Option.INL(tree')) =>
d1561 1
a1561 1
					    tree := MLWorks.Option.SOME(MLWorks.Option.INR(tree',Dummy_MV));
d1567 1
a1567 1
				   | MLWorks.Option.SOME(MLWorks.Option.INR(tree,_)) =>
d1575 1
a1575 1
				MLWorks.Option.NONE =>
d1589 1
a1589 1
			      | MLWorks.Option.SOME(tree) =>
d1591 1
a1591 1
				     MLWorks.Option.NONE =>
d1605 1
a1605 1
				   | MLWorks.Option.SOME(MLWorks.Option.INL(tree')) =>
d1616 1
a1616 1
					    tree := MLWorks.Option.SOME(MLWorks.Option.INR(tree',matchvar));
d1622 1
a1622 1
				   | MLWorks.Option.SOME(MLWorks.Option.INR(tree,matchvar)) =>
d1637 1
a1637 1
		      MLWorks.Option.NONE
d1639 1
a1639 1
		      MLWorks.Option.SOME(MakeDefaultTree default_tree env)
d1644 2
a1645 2
				     (MLWorks.Option.SOME(default),[]) => (default,MLWorks.Option.NONE)
				   | (MLWorks.Option.SOME(default),[MLWorks.Option.INL(binding)]) =>  (default,MLWorks.Option.SOME(binding))
d1679 1
a1679 1
		      |   fetch_labelled_patterns (((MLWorks.Option.NONE,pattern),env)::rest) patterns =
d1687 1
a1687 1
				(record,((MLWorks.Option.NONE,Absyn.WILDpat Ident.Location.UNKNOWN),env)::pats)
d1690 1
a1690 1
				(record,((MLWorks.Option.NONE,Absyn.WILDpat Ident.Location.UNKNOWN),env)::pats)
d1698 1
a1698 1
			    (case (if toplevel then fetch_pat (MLWorks.Option.SOME(matchvar,env)) pattern
d1711 1
a1711 1
					       case fetch_pat (MLWorks.Option.SOME(matchvar,env)) pat of
d1736 1
a1736 1
							   ((MLWorks.Option.NONE,Absyn.WILDpat Ident.Location.UNKNOWN),env)
d1748 1
a1748 1
						 ([([(lab,matchvar,pat_type)],((MLWorks.Option.NONE,pat),env)
d1757 1
a1757 1
						   ([([(lab,matchvar,pat_type)],((MLWorks.Option.NONE,pat),env)::pats)],
d1767 1
a1767 1
							 ((MLWorks.Option.NONE,pat),env)::pats)::patterns,
d1778 1
a1778 1
							 ((MLWorks.Option.NONE,pat),env)::pats)::patterns,
d1796 1
a1796 1
					   fetch_labelled_patterns (((MLWorks.Option.NONE,Absyn.WILDpat Ident.Location.UNKNOWN),env)::rest)
d1807 1
a1807 1
				    nil => [(nil,[((MLWorks.Option.NONE,pat),env)])]
d1809 1
a1809 1
				      [(nil,((MLWorks.Option.NONE,pat),env)::entry)]
d1847 1
a1847 1
			  fun split (((MLWorks.Option.NONE,pat),env)::rest) =
d1851 1
a1851 1
				| Split (((MLWorks.Option.NONE,pattern''),env)::rest)
d1855 1
a1855 1
				       ((MLWorks.Option.SOME(matchvar,MLWorks.Option.NONE),pattern''),env)
d1861 1
a1861 1
					   ((MLWorks.Option.SOME(matchvar,MLWorks.Option.SOME(construc_pattern)),
d1878 1
a1878 1
				  ((MLWorks.Option.SOME(matchvar,MLWorks.Option.NONE),pat),env):::(split rest)
d1883 1
a1883 1
				    ((MLWorks.Option.SOME(matchvar,MLWorks.Option.SOME(construc_pattern)),
d1889 1
a1889 1
				      (MLWorks.Option.SOME(_, MLWorks.Option.SOME(construc_pattern)),
d1895 1
a1895 1
					    ((MLWorks.Option.SOME(_, MLWorks.Option.SOME(construc_pattern)),_),env))::rest)
d1924 1
a1924 1
			       ((MLWorks.Option.NONE,Absyn.WILDpat _),_) => score
d2040 1
a2040 1
			      fun fetch_mvar nil = MLWorks.Option.NONE
d2042 1
a2042 1
				  if Ident.lab_eq (lab,lab') then MLWorks.Option.SOME(mvar')
d2048 2
a2049 2
				       MLWorks.Option.SOME(mvar') => (entry::env,(mvar,mvar')::mvars'')
				     | MLWorks.Option.NONE =>
d2095 1
a2095 1
		      MLWorks.Option.NONE =>
d2097 1
a2097 1
		    | MLWorks.Option.SOME ty => ty))
d2113 2
a2114 2
               MLWorks.Option.NONE => "Absent default"
             | MLWorks.Option.SOME(ref(BUILT(ref(MLWorks.Option.INL(n,_))))) =>
d2116 1
a2116 1
             | MLWorks.Option.SOME(ref(ERROR _)) =>
d2155 1
a2155 1
		MLWorks.Option.INL(ref(MLWorks.Option.SOME(ref(MLWorks.Option.INL(n,tr))))) =>
d2158 1
a2158 1
              | MLWorks.Option.INL(ref(MLWorks.Option.NONE)) => nil
d2175 2
a2176 2
		       MLWorks.Option.SOME def => MLWorks.Option.SOME def
		     | _ => MLWorks.Option.NONE))::
d2178 2
a2179 2
		      MLWorks.Option.NONE => []
		    | MLWorks.Option.SOME(bd) =>
d2189 1
a2189 1
	   | DEFAULT(default,binding) => [space_out,unparseDef(MLWorks.Option.INL(MLWorks.Option.SOME(default)))]@@
d2191 2
a2192 2
		  MLWorks.Option.NONE => []
		| MLWorks.Option.SOME(bd) => print_binding [MLWorks.Option.INL(bd)]))
d2210 1
a2210 1
		  case fetch_pat MLWorks.Option.NONE pat of
d2216 1
a2216 1
		 ([(MLWorks.Option.NONE,pat)],((exp,n,[]),[]))::pats')
d2223 1
a2223 1
	     inexhaustive := MLWorks.Option.NONE;
d2234 4
a2237 4
			  MLWorks.Option.SOME cons' =>
			    MLWorks.Option.SOME(cons'@@cons)
			| MLWorks.Option.NONE =>
			    MLWorks.Option.SOME cons)))) [[]] false)
@


1.64
log
@Moving Bits to MLWorks.Internal
@
text
@d3 3
d271 10
d645 1
a645 1
			       if con=con' then
d884 1
a884 1
                          if lvi=lvi' then expression' (exn,exn')
d927 1
a927 1
			if exn' = exn then
d1244 1
a1244 1
			      if the_construc pat' = the_construc pat'' then
d1367 1
a1367 1
			   if lvi = construc_pat then
d1384 1
a1384 1
			fn (_,lvi) => (lvi = construc_pat,false)
d1859 1
a1859 1
						    (if construc=construc_pattern
d1892 1
a1892 1
				    (if construc=construc_pattern
@


1.64.3.1
log
@branched from 1.64
@
text
@a2 3
 * Revision 1.64  1996/05/17  09:25:13  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.64.2.1
log
@branched from 1.64
@
text
@a2 3
 * Revision 1.64  1996/05/17  09:25:13  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.64.1.1
log
@branched from 1.64
@
text
@a2 3
 * Revision 1.64  1996/05/17  09:25:13  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.63
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d257 2
d486 1
a486 1
		rev_app(MLWorks.Bits.orb(power n, word) :: acc, words)
d495 1
a495 2
	      else
		MLWorks.Bits.andb(word, power n) <> 0
@


1.62
log
@Removing MLWorks.Integer
@
text
@d3 3
d693 1
a693 1
	  fun char_makestring i = "#\"" ^ MLWorks.String.ml_string(chr i, 3) ^ "\""
d697 1
a697 1
	    (fn (ints, s) => bit_set(ord s, ints, []))
d2214 1
a2214 1
	     (map (fn str => output(std_out,str))
@


1.61
log
@Removing Option in favour of MLWorks.Option
@
text
@d3 3
d206 2
d2086 1
a2086 1
		 "Present default of "^"'TREE "^MLWorks.Integer.makestring n^"'"
d2092 1
a2092 1
	      "Present default of "^"'TREE "^MLWorks.Integer.makestring n^"'"
d2100 1
a2100 1
		       MLWorks.Integer.makestring m])
d2105 1
a2105 1
	      (rest @@ [" '", IdentPrint.printLab m, "'=#", MLWorks.Integer.makestring vi])
d2115 1
a2115 1
	       "' --(#", MLWorks.Integer.makestring mv, ")\n"]
d2119 1
a2119 1
		     ["  " ^ space_out^"'TREE "^MLWorks.Integer.makestring n^"'"]
d2127 1
a2127 1
		  "\n"::space_out::"   "::"'TREE "::MLWorks.Integer.makestring n::"'"
d2131 1
a2131 1
		  "\n"::space_out::"   "::"'TREE "::MLWorks.Integer.makestring n::"'"
d2141 1
a2141 1
	       ([space_out, "SCON #", MLWorks.Integer.makestring mv]@@list_scons ll [])
d2153 1
a2153 1
	       ([space_out, "CONSTRUCTOR #", MLWorks.Integer.makestring mv]@@list_cons ll [])
d2158 1
a2158 1
	       (list_fields ll [space_out, "RECORD #", MLWorks.Integer.makestring mv])
@


1.60
log
@Remove Default type constructor and its value constructors PRESENT and ABSENT
Use MLWorks.Option.option instead
@
text
@d3 4
a229 1
  sharing Types.Datatypes.Option = AbsynPrint.Absyn.Option
@


1.59
log
@Added new types for different sizes of ints, words, and reals.
@
text
@d3 3
d304 1
a304 1
	* ('env Default,'env Tree BoundTree) MLWorks.Option.union
d309 1
a316 1
    and 'env Default = PRESENT of 'env DefaultTree ref | ABSENT
d960 1
a960 1
		  MLWorks.Option.INL(PRESENT default_tree')
d981 1
a981 1
                   MLWorks.Option.INL(PRESENT default_tree)
d1432 1
a1432 1
		      (ABSENT, MLWorks.Option.NONE)
d1437 1
a1437 1
			(PRESENT def, MLWorks.Option.SOME def)
d1444 1
a1444 1
			  PRESENT default => (default, binding)
d1600 1
a1600 1
		      ABSENT
d1602 1
a1602 1
		      PRESENT(MakeDefaultTree default_tree env)
d1607 2
a1608 2
				     (PRESENT(default),[]) => (default,MLWorks.Option.NONE)
				   | (PRESENT(default),[MLWorks.Option.INL(binding)]) =>  (default,MLWorks.Option.SOME(binding))
d1643 2
a1644 1
			  let datatype flag = ABSENT | PRESENT
d2076 2
a2077 2
               ABSENT => "Absent default"
             | PRESENT(ref(BUILT(ref(MLWorks.Option.INL(n,_))))) =>
d2079 1
a2079 1
             | PRESENT(ref(ERROR _)) =>
d2138 2
a2139 2
		       MLWorks.Option.SOME def => PRESENT def
		     | _ => ABSENT))::
d2152 1
a2152 1
	   | DEFAULT(default,binding) => [space_out,unparseDef(MLWorks.Option.INL(PRESENT(default)))]@@
@


1.58
log
@Add location info to wild pats
@
text
@d3 3
d297 1
d573 1
a573 1
	      | Absyn.SCONpat scon =>
d1002 1
a1002 1
	      | the_construc(Absyn.SCONpat scon) =
d1393 4
a1396 1
		    if Types.type_eq(Type, Types.char_type, false, false) then 256
d1408 1
a1408 1
			   Absyn.SCONpat scon =>
d1410 2
a1411 1
			       val ((env, new_env),redundant) = update_env (pat,Dummy_MV) env Type
d1443 2
a1444 1
		   | _ => SCON(rootvar,trees,default',binding))
d2039 3
a2041 2
	    | ((_,Absyn.SCONpat pat)::_,_)::_ =>
		scon_rule non_defaults
d2048 1
d2128 1
a2128 1
	   | SCON (mv, ll, def, binding) =>
@


1.57
log
@More tidying up and work on exhaustiveness on chars
@
text
@d3 3
d373 1
a373 1
	      (set_env (vi,ty); Absyn.WILDpat)
d566 1
a566 1
		Absyn.WILDpat =>
d1004 1
a1004 1
	      | the_construc Absyn.WILDpat =
d1020 1
a1020 1
				   (Absyn.WILDpat,_) => REDUNDANT
d1022 1
a1022 1
				 | (_,Absyn.WILDpat) => IRREDUNDANT
d1043 2
a1044 1
				    fun fetch_pat([], acc) = (rev acc, Absyn.WILDpat)
d1062 1
a1062 1
				      | non_WILDpat_in((_,Absyn.WILDpat)::pats) =
d1102 1
a1102 1
			  ((_,Absyn.WILDpat)::pats',_) =>
d1106 1
a1106 1
			    swap_patterns (pats'::pats) patterns (((option,Absyn.WILDpat)::pats',
d1132 1
a1132 1
		    ((_,Absyn.WILDpat)::pats',_) =>
d1148 1
a1148 1
		      (pats,(((option,Absyn.WILDpat)::pats',
d1181 1
a1181 1
			      ((opt,Absyn.WILDpat)::pats',exp) =>
d1193 1
a1193 1
			      ((opt,Absyn.WILDpat)::pats'',exp) =>
d1214 1
a1214 1
		  fun separate_wildpats ((wildpat as ((_,Absyn.WILDpat)::_,_))::pats) wildpats =
d1223 1
a1223 1
			((_,Absyn.WILDpat)::_,_) => duplicate_patterns pats (pat::pats')
d1226 1
a1226 1
		      duplicate_patterns pats (((option,Absyn.WILDpat)::pats'',
d1637 1
a1637 1
				(record,((MLWorks.Option.NONE,Absyn.WILDpat),env)::pats)
d1640 1
a1640 1
				(record,((MLWorks.Option.NONE,Absyn.WILDpat),env)::pats)
d1686 1
a1686 1
							   ((MLWorks.Option.NONE,Absyn.WILDpat),env)
d1737 1
a1737 1
					       Absyn.WILDpat =>
d1746 1
a1746 1
					   fetch_labelled_patterns (((MLWorks.Option.NONE,Absyn.WILDpat),env)::rest)
d1754 1
a1754 1
			     | Absyn.WILDpat =>
d1757 1
a1757 1
				    nil => [(nil,[((MLWorks.Option.NONE,Absyn.WILDpat),env)])]
d1759 1
a1759 1
				      [(nil,((MLWorks.Option.NONE,Absyn.WILDpat),env)::entry)]
d1804 1
a1804 1
				     Absyn.WILDpat =>
d1827 1
a1827 1
				Absyn.WILDpat =>
d1843 1
a1843 1
				  (score,rest,Absyn.WILDpat)
d1856 1
a1856 1
			    | split nil = (nil,(0,nil,Absyn.WILDpat))
d1874 1
a1874 1
			       ((MLWorks.Option.NONE,Absyn.WILDpat),_) => score
d1965 1
a1965 1
			  update_record_env' (#2(#1(update_env (Absyn.WILDpat,mvar)
d2159 1
a2159 1
		    Absyn.WILDpat => true
@


1.56
log
@Towards exhaustiveness checking on chars
@
text
@d3 3
d288 2
a289 1
      | SCON of Matchvar * (Ident.SCon * 'env Tree) list * 'env DefaultTree ref
d342 7
a560 6
	    fun printSCon (Ident.INT (x,_)) = x
	      | printSCon (Ident.REAL (x,_)) = x
	      | printSCon (Ident.WORD (x,_)) = x
	      | printSCon (Ident.STRING x) = x
	      | printSCon (Ident.CHAR x) = x

a621 12
(*
	    fun (env,env'):::(envs,envs') =
	      (case env of
		 [] => envs
	       | _ => env::envs,
		   case env' of
		     [] => envs'
		   | _ => env' ::envs')
	    fun update_env nil = (nil,nil)
	      | update_env ((env as _::_)::envs) = make_entry env:::update_env envs
	      | update_env _ = Crash.impossible "update_env:match"
*)
d643 1
d670 47
a716 8
        fun fetch_missing_constructors word =
	  let
	    val ve = #2(TypeUtils.get_valenv ty)
	    val cons = DataTypes.NewMap.domain ve
	  in
	    (ty,
	     Lists.filterp
	     (fn con =>
d718 1
a718 1
		val bit' = DataTypes.NewMap.rank'(ve,con)
d720 14
a733 21
		not(*andb(word,word')=word'*)(is_set(bit', word))
	      end) cons)
	  end
        fun all_constructors_present nil result = result
	  | all_constructors_present ([]::env) result = all_constructors_present env result
	  | all_constructors_present ((entry as (_,CON1(word'))::_)::env) (result as (env',_,missing_cons)) =
	    if word = word' then
	      all_constructors_present env result
	    else
	      all_constructors_present env
	      (entry::env',false,
	       (fn ()=>fetch_missing_constructors word')::missing_cons)
	  | all_constructors_present ((entry as (_,CON2(_))::_)::env) (env',_,missing_cons) =
            all_constructors_present env (entry::env',false,missing_cons)
	  | all_constructors_present ((entry as (_,SCON1 _)::_)::env) (result as (env',_,missing_cons)) =
	    all_constructors_present env
	    (entry::env',false,
	     (fn ()=>(ty,[]))::missing_cons)
	  | all_constructors_present ((entry as (_,SCON2 _)::_)::env) (env',_,missing_cons) =
            all_constructors_present env (entry::env',false,missing_cons)
	  | all_constructors_present _ _ = Crash.impossible "all_constructors_present:match"
d789 1
a789 1
	 PRESENT(default_tree))
d792 2
a793 2
           PRESENT(default_tree))
	| MakeDefaultTree default_tree _ = PRESENT(default_tree)
a814 4
(*
	  fun remove _ nil = []
	    | remove n ((m' as (m,_))::ns) = if n=m  then ns  else m'::remove n ns
*)
a960 1
	   (*remove n (!redundant_patterns)*)
d966 1
a966 4
(*
		 fun fetch_exns nil = nil
		   | fetch_exns ((_,((exp,n,exns),env))::rest) = ((exp,n,env),rev exns)::fetch_exns rest
*)		 fun fetch_exns exns =
d993 12
a1004 20
	    fun the_construc pat =
              case pat of
		Absyn.APPpat((lvi,_),_,_,_) => lvi
	      | Absyn.VALpat((lvi,_),_) => lvi
	      | Absyn.SCONpat scon =>
		  let  (* fake a LONGVALID for a SCon. *)
		    fun mkLONGVI s = Ident.LONGVALID
		      (Ident.mkPath [], Ident.VAR (Ident.Symbol.find_symbol s))
		  in
		    (case scon of
		       Ident.INT (s,_)           => mkLONGVI s
		     |Ident.REAL (s,_)          => mkLONGVI s
		     |Ident.WORD (s,_)          => mkLONGVI s
		     |Ident.CHAR s              => mkLONGVI s
		     |Ident.STRING s            => mkLONGVI s)
		  end
	      | Absyn.TYPEDpat(p,_,_)        => the_construc p
	      | Absyn.LAYEREDpat(_,p)      => the_construc p
	      | Absyn.WILDpat => Crash.impossible "the_construc:generate_tree:match:WILD"
	      | Absyn.RECORDpat _ => Crash.impossible "the_construc:generate_tree:match:RECORD"
d1040 7
a1046 5
				    fun fetch_pat nil = (nil,Absyn.WILDpat)
				      | fetch_pat ((entry as (lab2,pat))::pats) =
					if Ident.lab_eq(lab,lab2) then (pats,pat)
					else entry:::fetch_pat pats
				    val (pats2,pat2) = fetch_pat pats2
d1058 3
a1060 2
				      | non_WILDpat_in ((_,Absyn.WILDpat)::pats) = non_WILDpat_in pats
				      | non_WILDpat_in ((_,Absyn.VALpat((Ident.LONGVALID(_, Ident.VAR _),_),_))::pats) =
d1062 4
a1065 4
				      | non_WILDpat_in ((lab,Absyn.LAYEREDpat(_,pat))::pats) =
					non_WILDpat_in ((lab,pat)::pats)
				      | non_WILDpat_in ((lab,Absyn.TYPEDpat(pat,_,_))::pats) =
					non_WILDpat_in ((lab,pat)::pats)
d1129 2
a1130 1
		      let val (pats,(defaults,defaults')) = swap_patterns pats' pats
d1140 2
a1141 1
		    let val (pats,(defaults,defaults')) = swap_patterns pats' pats
d1384 3
d1413 11
a1423 8
		  val (env,missing_cons) =
		    case all_constructors_present env (MLWorks.Option.INL(lvis)) Type 0 of
		      (env,false,missing_cons) => (env,missing_cons)
		    |  _ => Crash.impossible "1:scon_rule:generate_tree:match"
		  val default =
		    case MakeDefaultTree default_tree env of
		      PRESENT(default) => default
		    | _ => Crash.impossible "2:scon_rule:generate_tree:match"
d1427 5
a1431 2
		     [] => DEFAULT(default,binding)
		   | _ => SCON(rootvar,trees,default,binding))
d1581 1
a1581 1
		    all_constructors_present env (MLWorks.Option.INR(lvis)) Type (TypeUtils.get_no_cons Type)
d1583 4
a1586 2
		    if all_constructors_present then ABSENT
		    else MakeDefaultTree default_tree env
d2026 1
a2026 1
	    | ((_,Absyn.SCONpat(pat))::_,_)::_ =>
d2115 10
a2124 4
	       @@ (("\n"^space_out)::(unparseDef (MLWorks.Option.INL(PRESENT(def)))::
				     (case binding of
					MLWorks.Option.NONE => []
				      | MLWorks.Option.SOME(bd) => print_binding [MLWorks.Option.INL(bd)])))
a2155 3
		  (*This case can't happen given the defn of fetch_pat
		  | Absyn.VALpat((Ident.LONGVALID( _, Ident.VAR _ ), _),_) => true
		      *)
d2178 1
a2178 1
			  MLWorks.Option.SOME(cons') =>
@


1.55
log
@Deal with word literal patterns
@
text
@d3 3
a189 1
require "../utils/option";
d197 1
a197 1
(** 
a203 1
  structure Option : OPTION
d210 1
a210 1
 
d214 1
a214 1
  sharing Types.Datatypes.Option = Option = AbsynPrint.Absyn.Option
a226 1
    structure Option = Option
d230 1
a230 1
    type Matchvar = int 
d235 1
a235 1
    fun from_Matchvar x = x 
d240 1
a240 1
        value matches, and therefore which expression to execute.  
d242 12
a253 12
          present constructors and trees, a default, and a list of bindings. This 
          default is a default-tree which is either built or unbuilt;unbuilt trees 
          are never encountered by the translator. Bindings tell the translator all the 
          default-trees present in this branch of the match-tree. Also, CONSTRUCTORs take
          an optional tree in normal nodes, or boundtree for delayed pattern matching in
          some exception nodes, in their tree list. Correspondingly, bindings optionally
          take a matchvar which is the rootvar for the boundtree. The bool indicates that
          this is the special node.
        Defaults are either present or absent. 
        Boundtrees are references to a pair of an integer(solely for debug printing) and a 
          default-tree during Match-compilation, and references to a lambda variable
          during translation. This tree is to be shared.
d255 8
a262 8
          improve efficiency by enabling decision-tree formation by need. Only default-trees
          which are actually needed are formed and included in the resulting match-tree.
          References to stages are needed because a stage is to be shared amongst several
          branches of the match-tree, and it is obviously undesirable that any particular 
          tree be built more than once. The constructor UNBUILT means the present default-tree 
	  is unbuilt and not needed; UNBUILT' means it is unbuilt but needed and so will later 
	  be built (this delaying of building is crucial to determining of redundancy and 
	  exhaustiveness - see Environments below); BUILT means it is BUILT and needed.
d264 7
a270 7
	  determining; a list of environments is passed as parameter at each stage of tree
	  generation.
	Constructors are entries in the environments. They are records of user-defined and 
	  special constructors and records. Con1 is a collection of already-encountered constructors
          and CON2 is the present constructor for which the tree is being built. SCon1 and SCON2 are
          similar but represent special constructors: int,real,string, and exn. Rec is used to establish
          a correspondence in matchvars between records in default and non-default trees.
d273 2
a274 2
    type 'Tree BoundTree = ((int * 'Tree),lvar) Option.option ref
    datatype Constructors = 
d284 1
a284 1
        LEAF of Absyn.Exp * int * (Matchvar * Ident.ValId * (DataTypes.Type ref * Absyn.RuntimeInfo ref)) list
d286 7
a292 6
        * 'env Tree BoundTree Option.opt ref Option.opt
      | CONSTRUCTOR of DataTypes.Type * Matchvar * (Ident.LongValId * Matchvar
                         * ('env Tree,'env Tree BoundTree) Option.option) list 
           * ('env Default,'env Tree BoundTree) Option.option
        * ('env Tree BoundTree Option.opt ref,
           'env Tree BoundTree * Matchvar) Option.option list * bool
d294 4
a297 4
      | DEFAULT of 'env DefaultTree ref * 'env Tree BoundTree Option.opt ref Option.opt
    and 'env DefaultTree = 
        UNBUILT of ('env -> 'env Tree)
        * 'env Tree BoundTree Option.opt ref * 'env * bool
d299 2
a300 2
        * 'env Tree BoundTree Option.opt ref * 'env * bool
      | BUILT of 'env Tree BoundTree 
d324 19
a342 5
   local 
    fun hd (x::_) = x
    |   hd _ = Crash.impossible "hd:match"
    fun tl (_::xs) = xs
    |   tl _ = Crash.impossible "tl:match"
d344 1
a344 1
        so(Option.ABSENT) and updating environments from them otherwise(Option.PRESENT(...)).
d346 20
a365 16
    local
       fun set_env env' (vi,ty,pat) continue = 
                 case env' of 
                  Option.ABSENT => continue pat env'
                 |Option.PRESENT(matchvar,env) => (env := (matchvar,vi,ty)::(!env);
                                                   continue pat env')
    in
     fun fetch_pat (Absyn.LAYEREDpat((vi,ty),pat)) env = set_env env (vi,ty,pat) fetch_pat
     |   fetch_pat (Absyn.TYPEDpat(pat,_,_)) env  = fetch_pat pat env
     |   fetch_pat (Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
                                ty),_)) env =  
                set_env env (vi,ty,Absyn.WILDpat) (fn _ => fn _ => Absyn.WILDpat)
     |   fetch_pat pat env = pat
    end
    (** A pattern during match-compilation will be thus ... . The PRESENT option paired with
        patterns denotes a pattern which was previously a labelled pattern in a record as 
d367 2
a368 2
        assigned to it, and will have a LongValid assigned to it during sorting if a 
        non-WILDpat. Each object matching this type will be translated into one path in the 
d370 1
a370 1
    **) 
d372 12
a383 12
    type 'env pattern =
      ((Matchvar * Ident.LongValId Option.opt) Option.opt * Absyn.Pat) list
      * ((Absyn.Exp * int * (Ident.LongValId * (Matchvar * 'env DefaultTree ref)) list)
         * (Matchvar * Ident.ValId 
            * (DataTypes.Type ref * Absyn.RuntimeInfo ref)) list)

    val match_vars : Matchvar list list ref = ref []

    infix :::
    fun x:::(xs,y) = (x::xs,y)
    local
      (** look up a match-variable in an environment returning a constructor and the same 
d389 19
a407 13
      fun fetch_environment'' rootvar env = 
        let 
          fun member(mvar,_) = Lists.member(rootvar,Lists.nth(mvar-1,rev(!match_vars)))
          fun insert() = (match_vars := [rootvar]::(!match_vars);
                          Lists.length(!match_vars))
          fun fetch_environment' [] _ = (insert(),CON1([]))::env
            | fetch_environment' (entry::envs) env = 
                if member(entry) then entry::(rev env)@@envs
                else fetch_environment' envs (entry::env)
        in
          fetch_environment' env []
        end
    in
a410 18
    local
      fun Fetch_environment env rootvar modify = 
       let 
           fun fetch_environment nil = nil
           |   fetch_environment (env::envs) = 
               modify(env,fetch_environment'' rootvar)::fetch_environment envs
       in
              fetch_environment env
       end
    in
      fun fetch_environment env rootvar modify = 
	Fetch_environment env rootvar 
		(fn (env,fetch_environment)=> modify(fetch_environment env))

      fun fetch_environment' env rootvar = 
	Fetch_environment env rootvar 
		(fn ((env,mvars),fetch_environment) => (fetch_environment env,mvars))
    end
d412 45
a456 26
    fun bit_pattern 0 = [1]
      | bit_pattern n =
        if n>28 then
          bit_pattern(n-29)@@[0]
        else
          case bit_pattern(n-1) of
            byte::bytes => 2 * byte::bytes
          | _ => Crash.impossible "bit_pattern:match"
    fun andb(word1,word2) =
      let
        fun andb([],_) = []
          | andb(_,[]) = []
          | andb(byte1::bytes1,byte2::bytes2) =
            MLWorks.Bits.andb(byte1,byte2)::andb(bytes1,bytes2)
      in
        (rev o andb) (rev word1,rev word2)
      end
    fun orb(word1,word2) =
      let
        fun orb([],word) = word
          | orb(word,[]) = word
          | orb(byte1::bytes1,byte2::bytes2) =
            MLWorks.Bits.orb(byte1,byte2)::orb(bytes1,bytes2)
      in
        (rev o orb) (rev word1,rev word2)
      end
d460 1
a460 1
          if CON1 entry 
d470 113
a582 60
    val redundant : bool ref = ref(true)
    fun update_env (pat,mvar) env ty = 
       let
         exception Fetch
         val _ = redundant := true
           
         fun insert (mvar,mvar') =
           let
             fun insert ([],_) = Crash.impossible "insert:update_env:match"
               | insert (mvars::mvarss,n) =
                 if n = mvar' then
                   (if Lists.member(mvar,mvars) then mvars
                    else mvar::mvars)::mvarss
                 else
                   mvars::insert(mvarss,(n+1))
           in
             (match_vars := (rev o insert) (rev(!match_vars),1);
              mvar')
           end
	 datatype scon_type =
	   INT of string
	   | WORD of string
	   | OTHER of string

	 fun scon_test(INT s, t) =
	   Scons.scon_eqval(Ident.INT(s, Ident.Location.UNKNOWN),
			    Ident.INT(t, Ident.Location.UNKNOWN))
	   | scon_test(WORD s, t)=
	     Scons.scon_eqval(Ident.WORD(s, Ident.Location.UNKNOWN),
			      Ident.WORD(t, Ident.Location.UNKNOWN))
	   | scon_test(OTHER s, t) = s = t

	 fun scon_val(INT s) = s
	   | scon_val(WORD s) = s
	   | scon_val(OTHER s) = s

	 fun member(s as INT _, ss) = Lists.exists (fn t => scon_test(s, t)) ss
	   | member(s as WORD _, ss) = Lists.exists (fn t => scon_test(s, t)) ss
	   | member(OTHER s, ss) = Lists.member(s, ss)

         fun make_scon_entry scon =
	   let
	     val scon_val = scon_val scon
	   in
	     (fn env' as (mvar',SCON1(scons))::env =>
	      if member(scon,scons) then (env', [])
	      else
		(redundant := false;
		 ((mvar',SCON1(scon_val::scons))::env,
		  (mvar',SCON2(scon_val,mvar))::env))
	      | env' as (mvar',CON1[])::env =>
		  (redundant := false;
		   ((mvar',SCON1([scon_val]))::env,
		    (mvar',SCON2(scon_val,mvar))::env))
	      | env' as (mvar'',SCON2(scon',mvar'))::env =>
		  if scon_test(scon, scon') then
		    (redundant := false;
		     ([],
		      if mvar = Dummy_MV then env'
		      else
d584 6
a589 5
			  (* let matchvars in environment correspond *)
			  val env =
			    case fetch_environment'' mvar' env of
			      (mv,cons)::env => (insert(mvar,mv),cons)::env
			    | _ => Crash.impossible "1:make_entry:update_env:match"
d591 55
a645 85
			  (mvar'',SCON2(scon',mvar))::env
			end))
		  else
		    (env', [])
	      | _ => Crash.impossible "2:make_entry:update_env:match")
	   end

         fun printSCon (Ident.INT (x,_)) = x
           | printSCon (Ident.REAL (x,_)) = x
           | printSCon (Ident.WORD (x,_)) = x
           | printSCon (Ident.STRING x) = x
           | printSCon (Ident.CHAR x) = x

         val make_entry = 
           case pat of
             Absyn.WILDpat => 
               (fn (mvar',cons)::env => ([],(insert(mvar,mvar'),cons)::env)
                 | _ => Crash.impossible "3:make_entry:update_env:match")
           | Absyn.SCONpat(scon) =>
	       (case scon of
		  Ident.INT _ => make_scon_entry(INT(printSCon scon))
		| Ident.WORD _ => make_scon_entry(WORD(printSCon scon))
		| _ => make_scon_entry(OTHER(printSCon scon)))
           | _ =>
               let
                 val con =
                   case pat of
                     Absyn.VALpat((con,_),_) => con
                   | Absyn.APPpat((con,_),_,_,_) => con
                   | _ => Crash.impossible "4:make_entry:update_env:match"
               in
                 case con of
                   Ident.LONGVALID(_,Ident.EXCON(con)) =>
		     make_scon_entry(OTHER(Ident.Symbol.symbol_name con))
                 | _ =>
                     let
                       fun constructor_word() =
                           case pat of
                             Absyn.VALpat((Ident.LONGVALID(_,con),_),_) =>
                               bit_pattern(DataTypes.NewMap.rank'
                                           (#2(TypeUtils.get_valenv (TypeUtils.get_cons_type ty)), con))
                           | Absyn.APPpat((Ident.LONGVALID(_,con),_),_,_,_) => 
                               bit_pattern(DataTypes.NewMap.rank'
                                           (#2(TypeUtils.get_valenv (TypeUtils.get_cons_type ty)), con))
                           | _ => Crash.impossible "constructor_word:make_entry:match"
                       val word' = constructor_word()
                     in
                       fn env' as (mvar',CON1(word))::env =>
                       if andb(word,word') = word' then (env', [])
                       else
                         (redundant := false;
                          ((mvar',CON1(orb(word,word')))::env,
                           (mvar',CON2(con,mvar))::env))
                        | env' as (mvar'',CON2(con',mvar'))::env =>
                            if con=con' then
                              (redundant := false;
                               ([],
                                if mvar = Dummy_MV then env'
                                else
                                  let
                                    (* let matchvars in environment correspond *)
                                    val env =
                                      case fetch_environment'' mvar' env of
                                        (mv,cons)::env => (insert(mvar,mv),cons)::env
                                      | _ => Crash.impossible "5:make_entry:update_env:match"
                                  in
                                    (mvar'',CON2(con',mvar))::env
                                  end))
                            else (env', [])
                        | _ => Crash.impossible "6:make_entry:update_env:match"
                     end
               end
          fun (env,env'):::(envs,envs') =
            (case env of
               [] => envs
             | _ => env::envs,
             case env' of
               [] => envs'
             | _ => env' ::envs')
          fun update_env nil = (nil,nil)
          |   update_env ((env as _::_)::envs) = make_entry env:::update_env envs
	  |   update_env _ = Crash.impossible "update_env:match"
       in
             (update_env env, !redundant)
       end
d651 39
a689 32
       let 
         (* n is <= 28, so no overflow *)
         fun power n = Bits.lshift (1,n)
(*
        fun power 0 = 1
          | power n = 2*power(n-1)
*)
        fun all_bits_set 0 = [1]
          | all_bits_set n =
            if n>28 then
              all_bits_set(n-29)@@all_bits_set(28)
            else
              case all_bits_set(n-1) of
                byte :: bytes => power n + byte :: bytes
              | _ => Crash.impossible "all_bits_set:all_constructors_present:match"
        val word =
          case arity of
            0 => []
          | _ => all_bits_set (arity-1)
        fun fetch_missing_constructors word = 
            let 
              val ve = #2(TypeUtils.get_valenv ty)
              val cons = DataTypes.NewMap.domain(ve)
            in
              (ty,
               Lists.filterp (fn con=>
                              let
                                val word' = bit_pattern(DataTypes.NewMap.rank'(ve,con))
                              in
                                not(andb(word,word')=word')
                              end) cons)
            end
d691 9
a699 9
        |   all_constructors_present ([]::env) result = all_constructors_present env result
        |   all_constructors_present ((entry as (_,CON1(word'))::_)::env) (result as (env',_,missing_cons)) = 
              if word = word' then
                all_constructors_present env result
              else
                all_constructors_present env
                (entry::env',false,
                 (fn ()=>fetch_missing_constructors word')::missing_cons)
        |   all_constructors_present ((entry as (_,CON2(_))::_)::env) (env',_,missing_cons) =
d701 5
a705 5
        |   all_constructors_present ((entry as (_,SCON1(_))::_)::env) (result as (env',_,missing_cons)) = 
                  all_constructors_present env
                  (entry::env',false,
                   (fn ()=>(ty,[]))::missing_cons)
        |   all_constructors_present ((entry as (_,SCON2(_))::_)::env) (env',_,missing_cons) =
d707 12
a718 47
        |   all_constructors_present _ _ = Crash.impossible "all_constructors_present:match"
       in
		all_constructors_present env (nil,true,nil)
       end

    val redundant_patterns : (int * expression) list ref =
      ref nil
    val inexhaustive : (DataTypes.Type * Ident.ValId list) list Option.opt ref = 
      ref(Option.ABSENT)
    (** record and record-type are references used to indicate that records are present in 
        the present stage of match-compiling; we do not wish match-compiling to break off 
        into several branches on records as this would complicate match-compilation
        unnecessarilly.
    **)
    val record : bool ref = ref false
    val record_type : DataTypes.Type Option.opt ref = ref Option.ABSENT
    val label_count : int ref = ref 0
    fun next_label() = (label_count := (!label_count)+1;(!label_count))
    (** 
     if old-default then 
       environments still being accumulated;
       for ERROR trees only, accumulate missing constructors for warning message
     else 
        default-tree has outlived its usefulness;
	generate, passing to it the environments for all uses
     **)
    fun make_default new_default_tree old_default missing_constructors = 
                         if old_default then 
                           case new_default_tree of
                             ref(ERROR(inexhaustive))=>
                               inexhaustive(map (fn f=>f()) missing_constructors)
                           | _ => ()
                         else
			 case new_default_tree of
                           ref(UNBUILT'(make_tree,binding,env,_)) => 
                            let val tree = make_tree env
                      		val boundtree = ref(Option.SOME1(next_label(),tree))
                            in
                              (binding := Option.PRESENT(boundtree);
                               new_default_tree := BUILT(boundtree))
                            end
                         | ref(ERROR(inexhaustive))=>
                               inexhaustive(map (fn f=>f()) missing_constructors)
                         | _ => ()
    (** Form a default; 
        if previously unused (UNBUILT), indicate that it is now used (UNBUILT');
        indicate that this default-tree is old for future builds
d720 45
a764 4
    fun MakeDefaultTree (default_tree as ref(UNBUILT(default,binding,env',_))) env = 
          (default_tree := UNBUILT'(default,binding,env@@env',true);
           PRESENT(default_tree))
      |   MakeDefaultTree (default_tree as ref(UNBUILT'(default,binding,env',old_default))) env = 
d767 33
a799 32
      |   MakeDefaultTree default_tree _ = PRESENT(default_tree)
    (** Form a binding, information for the match-tree translator that the default-tree
        is bound here and so all invocations of it will be in this branch of the 
        match-tree
     **)
    fun make_binding default_tree = 
      case default_tree of
        ref(UNBUILT(default,binding,env,old_default)) => 
          (default_tree := UNBUILT(default,binding,env,true);
           if old_default then Option.ABSENT
           else  Option.PRESENT(binding))
      | ref(UNBUILT'(_)) => Option.ABSENT
      | ref(BUILT(_)) => Option.ABSENT
      | ref(ERROR(_)) => Option.ABSENT
    fun generate_tree'' generate_tree patterns 
				(default as (_,_,new_default_tree)) env old_default = 
                       let val tree = generate_tree patterns default env
                       in
			(make_default new_default_tree old_default nil;
                         tree)
                       end
    fun generate_tree rootvars ((nil,((exp,n,exns),env))::patterns) _ _ =
      let
        fun remove _ nil = []
          | remove n ((m' as (m,_))::ns) = if n=m  then ns  else m'::remove n ns
       (** form boolean expressions for exception constructors in conflict and insert them
           in list of redundant patterns for the lambda translator
        **)
        fun insert_redundant_patterns exns =
          let
            exception Insert
            fun insert_redundant_patterns m =
d807 2
a808 2
                                              TRUE => exp
                                            | _ => exp&&exp')::ns
d816 1
a816 1
                  fun expression exns exn = 
d838 2
a839 2
                   insert_redundant_pattern ((n,expression exns' exn),!redundant_patterns);
                   insert_redundant_patterns (m+1))
d842 3
a844 3
          in
            insert_redundant_patterns 2
          end
d850 1
a850 1
        fun generate_exception_tree ((_,[])::_) _ =
d852 116
a967 103
          | generate_exception_tree [] _ =
            Crash.impossible "2:generate_exception_tree:match"
          | generate_exception_tree exns default_tree =
          let
            fun fetch_constructor_info ((_,(_,info)::_)::_) = info
              | fetch_constructor_info _ =
                Crash.impossible "fetch_constructor_info:generate_exception_tree:match"
            val (mv,default_tree') = fetch_constructor_info exns
            fun EXNsplit (exns as (_,(exn,_)::_)::_) =
              let
                fun insplit [] (e1,e2) = (e1, rev e2)
                  | insplit ((exn'' as (exp,(exn',_)::exns))::el) (e1,e2) =
                    if exn' = exn then   
                      insplit el ((exp,exns)::e1,e2)
                    else
                      insplit el (e1,exn''::e2)
                  | insplit _ _ = 
                    Crash.impossible "insplit:EXNsplit:generate_exception_tree:match"
              in
                  case insplit exns ([],[]) of
                    (e1 as (exp,_)::_, e2) => (e1, e2, (exp,exn))
                  | _ =>  
                      Crash.impossible "1:EXNsplit:generate_exception_tree:match"             
              end
              | EXNsplit _ =
                      Crash.impossible "2:EXNsplit:generate_exception_tree:match" 
            fun make_tree_list (exns as _::_) (trees,boundtrees) default_tree =
                let
                  val (exns,exns',(exp,exn)) = EXNsplit exns
                in
                  case exns' of
                    nil => 
                     (case exns of
                        (_,[])::_ => 
                          ((exn,Dummy_MV,Option.SOME1(LEAF(exp)))::trees,rev(boundtrees))
                      | _ =>
                          ((exn,Dummy_MV,
                            Option.SOME1(generate_exception_tree exns default_tree))::trees,
                           rev(boundtrees)))
                  | _ =>
                      case exns of
                        (_,[])::_ => 
                          make_tree_list exns'
                          ((exn,Dummy_MV,Option.SOME1(LEAF(exp)))::trees,boundtrees) default_tree
                      | _ =>
                          let
                            val tree =
                              ref(Option.SOME1(next_label(),
                                               generate_exception_tree exns default_tree))
                            val tree_entry = (exn,Dummy_MV,Option.SOME2(tree))
                            val default_tree =
                              case default_tree of
                                Option.SOME1(_) =>
                                  ref(Option.SOME1(next_label(),
                                      CONSTRUCTOR(Types.exn_type,mv,[tree_entry],default_tree,[],true)))
                                | Option.SOME2(ref(Option.SOME1(_,
                                               CONSTRUCTOR(ty,mv,trees,default_tree,boundtrees,b)))) =>
                                  ref(Option.SOME1(next_label(),
                                      CONSTRUCTOR(ty,mv,tree_entry::trees,default_tree,boundtrees,b)))
                                | _ =>
                                     Crash.impossible "1:make_tree_list:generate_exception_tree:match"
                          in
                            make_tree_list exns'
                            (tree_entry::trees,
                             Option.SOME2(default_tree,Dummy_MV)
                              ::Option.SOME2(tree,Dummy_MV)::boundtrees)
                            (Option.SOME2(default_tree))
                          end
                end
              | make_tree_list _ _ _ =
                Crash.impossible "2:make_tree_list:generate_exception_tree:match"
            fun choose_default_tree (Option.SOME1(_)) = Option.SOME1(PRESENT(default_tree'))
              | choose_default_tree (Option.SOME2(_)) = default_tree
            val default_tree = choose_default_tree default_tree

            val (trees,boundtrees) =
              make_tree_list (rev exns) (nil,nil) default_tree
          in
            CONSTRUCTOR(Types.exn_type,mv,trees,default_tree,boundtrees,true)
          end
      in
        (redundant_patterns := remove n (!redundant_patterns);
         case exns of
           nil => LEAF(exp,n,env)
         | _ =>
             let
               fun fetch_exns nil = nil
                 | fetch_exns ((_,((exp,n,exns),env))::rest) = ((exp,n,env),rev exns)::fetch_exns rest
               fun fetch_default_tree ((_,(_,default_tree))::_) =
                   Option.SOME1(PRESENT(default_tree))
                 | fetch_default_tree _ =
                   Crash.impossible "fetch_default_tree:generate_tree:match"
               val exns' = ((exp,n,env),rev exns)::fetch_exns patterns
             in
               (insert_redundant_patterns exns';
                generate_exception_tree exns' (fetch_default_tree exns))
             end)
      end
    |   generate_tree (rootvars' as rootvar::rootvars) patterns (separate,exception_tree,default_tree) env =
     let (**  Bring similar rules together. Redundant patterns are also removed from the 
              matching process at this stage. Two patterns are swappable if no value is 
              matched by both; two patterns are 'irredundant' if there is a value that is 
              matched by both and they are relatively irredundant. A swap-table is not 
d972 1
a972 1
              compilation branches off at this stage, any such pair will never be 
d975 1
a975 1
         fun the_construc pat = 
d977 171
a1147 170
	       Absyn.APPpat((lvi,_),_,_,_) => lvi
             | Absyn.VALpat((lvi,_),_) => lvi
             | Absyn.SCONpat scon =>
	         let  (* fake a LONGVALID for a SCon. *)
	           fun mkLONGVI s = Ident.LONGVALID
	             (Ident.mkPath [], Ident.VAR (Ident.Symbol.find_symbol s))
	         in
	           (case scon of
	             Ident.INT (s,_)           => mkLONGVI s
	            |Ident.REAL (s,_)          => mkLONGVI s
	            |Ident.WORD (s,_)          => mkLONGVI s
	            |Ident.CHAR s              => mkLONGVI s
	            |Ident.STRING s            => mkLONGVI s)
	         end
             | Absyn.TYPEDpat(p,_,_)        => the_construc p
             | Absyn.LAYEREDpat(_,p)      => the_construc p
             | Absyn.WILDpat => Crash.impossible "the_construc:generate_tree:match:WILD"
             | Absyn.RECORDpat _ => Crash.impossible "the_construc:generate_tree:match:RECORD"
         local 
           datatype irredundancy = REDUNDANT | SWAPPABLE | IRREDUNDANT
           fun swap_patterns pats patterns = 
           let
            fun swap_patterns _ nil patterns = (nil,(nil,rev patterns))
            |   swap_patterns pats (patterns' as pattern::patterns) patterns'' =
               let 
                fun irredundancy nil nil = REDUNDANT
                |   irredundancy ((_,pat1)::pats1) ((_,pat2)::pats2) = 
                 let fun Irredundancy pat1 pat2 = 
                      (case (pat1,pat2) of 
                        (Absyn.WILDpat,_) => REDUNDANT
                       |(Absyn.VALpat ((Ident.LONGVALID(_,Ident.VAR _),_),_),_) => REDUNDANT
                       |(_,Absyn.WILDpat) => IRREDUNDANT
                       |(_,
                         Absyn.VALpat ((Ident.LONGVALID(_,Ident.VAR _),_),_)) => IRREDUNDANT
                       |(Absyn.LAYEREDpat(_,pat1),pat2) => Irredundancy pat1 pat2
                       |(Absyn.TYPEDpat(pat1,_,_),pat2) => Irredundancy pat1 pat2
                       |(pat1,Absyn.LAYEREDpat(_,pat2)) => Irredundancy pat1 pat2
                       |(pat1,Absyn.TYPEDpat(pat2,_,_)) => Irredundancy pat1 pat2
                       |(Absyn.APPpat((Ident.LONGVALID( _, val_id1),_),arg,_,_),
                         Absyn.APPpat((Ident.LONGVALID( _, val_id2),_),arg',_,_)) => 
                               (case  Irredundancy'' val_id1 val_id2  of
                                 REDUNDANT => Irredundancy arg arg'
                                |irredundancy => irredundancy)
                       |(Absyn.VALpat((Ident.LONGVALID( _, val_id1),_),_),
                         Absyn.VALpat((Ident.LONGVALID( _, val_id2),_),_)) => 
                                                     Irredundancy'' val_id1 val_id2
                       |(Absyn.RECORDpat(name_pat_list,_,_),
                         Absyn.RECORDpat(name_pat_list',_,_)) =>
                                             Irredundancy' name_pat_list name_pat_list'
                       |(_,_) => SWAPPABLE)
                      and Irredundancy' nil nil = REDUNDANT
                      |   Irredundancy' ((lab,pat1)::pats1) (pats2 as _::_) = 
                            let fun fetch_pat nil = (nil,Absyn.WILDpat)
                                |   fetch_pat ((entry as (lab2,pat))::pats) = 
                                     if Ident.lab_eq(lab,lab2) then (pats,pat)
                                     else entry:::fetch_pat pats
                                val (pats2,pat2) = fetch_pat pats2
                            in
                              case Irredundancy pat1 pat2 of
                               SWAPPABLE => SWAPPABLE
                              |IRREDUNDANT => 
                                 (fn REDUNDANT => IRREDUNDANT
                                  |  other => other) (Irredundancy' pats1 pats2)
                              |REDUNDANT => Irredundancy' pats1 pats2
                            end
                      |   Irredundancy' pats1 nil = 
                         let fun non_WILDpat_in nil = false
                             |   non_WILDpat_in ((_,Absyn.WILDpat)::pats) = non_WILDpat_in pats
                             |   non_WILDpat_in ((_,Absyn.VALpat((Ident.LONGVALID(_,
                                                                Ident.VAR _),_),_))::pats) = 
                                     non_WILDpat_in pats
                             |   non_WILDpat_in ((lab,Absyn.LAYEREDpat(_,pat))::pats) =
                                           non_WILDpat_in ((lab,pat)::pats)
                             |   non_WILDpat_in ((lab,Absyn.TYPEDpat(pat,_,_))::pats) =
                                           non_WILDpat_in ((lab,pat)::pats)
                             |   non_WILDpat_in _ = true
                         in
                              if non_WILDpat_in pats1 then IRREDUNDANT
                              else REDUNDANT
                         end
                      |   Irredundancy' nil pats2 = REDUNDANT
                      and Irredundancy'' val_id val_id' =
                           (case (val_id,val_id') of
                             (Ident.CON name,Ident.CON name') => 
                               if name=name' then REDUNDANT else SWAPPABLE
                            |(Ident.EXCON name,Ident.EXCON name') => 
                               if name=name' then REDUNDANT else IRREDUNDANT
                            | _ => Crash.impossible 
                              "Irredundancy'':Irredundancy:generate_tree:match")
                 in 
                     case Irredundancy pat1 pat2 of
                      SWAPPABLE => SWAPPABLE
                     |IRREDUNDANT => 
                       (fn REDUNDANT => IRREDUNDANT
                        |  other => other) (irredundancy pats1 pats2)
                     |REDUNDANT => irredundancy pats1 pats2
                 end
                |   irredundancy _ _ = 
                       Crash.impossible "irredundancy:generate_tree:match"
                fun irredundancy' nil _ = SWAPPABLE
                |   irredundancy' (pats::rest) pats' = 
                   case irredundancy pats pats' of 
                    SWAPPABLE => irredundancy' rest pats'
                   |other => other
                       
             in
                    case pattern of
                      ((_,Absyn.WILDpat)::pats',_) => 
                        swap_patterns (pats'::pats) patterns (pattern::patterns'')
                    | ((option,Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
                                             ty),_))::pats',(exp,env)) => 
                      swap_patterns (pats'::pats) patterns (((option,Absyn.WILDpat)::pats',
                                                           (exp,(rootvar,vi,ty)::env))::patterns'')
                    | ((option,Absyn.LAYEREDpat((vi,ty),pat))::pats',(exp,env)) => 
                        swap_patterns pats (((option,pat)::pats',
                                             (exp,(rootvar,vi,ty)::env))::patterns) patterns''
                    |((option,Absyn.TYPEDpat(pat,_,_))::pats',env) => 
                       swap_patterns pats (((option,pat)::pats',env)::patterns) patterns''
                    |((_,pat)::pats',_) => 
                       (case irredundancy' pats pats' of 
                          REDUNDANT => swap_patterns pats patterns patterns''
                        |IRREDUNDANT => (nil,(patterns',rev patterns''))
                        |SWAPPABLE => 
                           (case pat of 
                              Absyn.RECORDpat(_,_,ref ty) => 
                                (record := true;record_type := Option.PRESENT(ty))
                            | _ => ();
                                pattern:::swap_patterns pats patterns patterns''))
                    | _ => Crash.impossible "swap_patterns:generate_tree:match"
             end
           in
               swap_patterns [pats] patterns nil
           end
         in
         fun separate_defaults nil = (nil,nil)
         |   separate_defaults (pat::pats) =
          case pat of 
            ((_,Absyn.WILDpat)::pats',_) => 
              let val (pats,(defaults,defaults')) = swap_patterns pats' pats
                  val (defaults,default_defaults) = separate_defaults defaults
              in
                 (pats,(pat::defaults')::
                  (case defaults of
                    nil => default_defaults
                   | _ => defaults::default_defaults))
              end
           |((option,Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
                                ty),_))::pats',(exp,env)) => 
              let val (pats,(defaults,defaults')) = swap_patterns pats' pats
                  val (defaults,default_defaults) = separate_defaults defaults
              in
                  (pats,(((option,Absyn.WILDpat)::pats',
                           (exp,(rootvar,vi,ty)::env))::defaults')::
                   (case defaults of
                     nil => default_defaults
                    | _ => defaults::default_defaults))
              end
           |((option,Absyn.LAYEREDpat((vi,ty),pat))::pats',(exp,env)) => 
                 separate_defaults (((option,pat)::pats',
                                       (exp,(rootvar,vi,ty)::env))::pats)
           |((option,Absyn.TYPEDpat(pat,_,_))::pats',env) => 
                 separate_defaults (((option,pat)::pats',env)::pats)
           |((_,pat')::_,_) => 
                 (case pat' of 
                   Absyn.RECORDpat(_,_,ref ty) => 
                     (record := true;record_type := Option.PRESENT(ty))
                  | _ => ();
                  pat:::separate_defaults pats)
           | _ => Crash.impossible "separate_defaults:generate_tree:match"
         end
d1153 79
a1231 79
         fun separate_defaults' nil = (nil,nil)
           | separate_defaults' pats =
             let
               fun duplicate_pattern _ nil = nil
                 | duplicate_pattern pat' pats =
                   let
                     fun duplicate_pattern [] = []
                       | duplicate_pattern (pat::pats) =
                         case pat of
                           ((opt,Absyn.WILDpat)::pats',exp) =>
                             ((opt,pat')::pats',exp)::duplicate_pattern pats
                         | _ => []
                   in
                     duplicate_pattern pats
                   end
               fun duplicate_pattern' _ nil = ([],[])
                 | duplicate_pattern' pat' pats =
                   let 
                     fun duplicate_pattern [] (pats,pats') = (rev pats,pats')
                       | duplicate_pattern (pat::pats) (pats''',pats') =
                       case pat of
                         ((opt,Absyn.WILDpat)::pats'',exp) =>
                           duplicate_pattern pats (pat::pats''',((opt,pat')::pats'',exp)::pats')
                       | ((option,Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
                                                ty),_))::pats'',(exp,env)) => 
                         duplicate_pattern pats (pat::pats''',((option,pat')::pats'',
                                                   (exp,(rootvar,vi,ty)::env))::pats')
                       | ((option,Absyn.LAYEREDpat((vi,ty),pat))::pats'',(exp,env)) => 
                           duplicate_pattern (((option,pat)::pats'',
                                                (exp,(rootvar,vi,ty)::env))::pats) (pats''',pats')
                       | ((option,Absyn.TYPEDpat(pat,_,_))::pats'',env) => 
                           duplicate_pattern (((option,pat)::pats'',env)::pats) (pats''',pats')
                       | ((_,Absyn.RECORDpat(_))::_,_) => duplicate_pattern pats (pats''',pat::pats')
                       | ((_,pat'')::_,_) =>
                           if the_construc pat' = the_construc pat'' then
                             duplicate_pattern pats (pats''',pat::pats')
                           else
                             duplicate_pattern pats (pat::pats''',pats')
                       | _ => Crash.impossible "duplicate_pattern':separate_defaults':generate_tree:match"
                   in
                     duplicate_pattern pats ([],[])
                   end
               fun separate_wildpats ((wildpat as ((_,Absyn.WILDpat)::_,_))::pats) wildpats =
                   separate_wildpats pats (wildpat::wildpats)
                 | separate_wildpats pats wildpats =
                   (rev pats,case wildpats of
                               [] => []
                             | _ => [wildpats])
               fun duplicate_patterns nil pats = separate_wildpats pats []
                 | duplicate_patterns (pat::pats) pats' =
                   case pat of
                     ((_,Absyn.WILDpat)::_,_) => duplicate_patterns pats (pat::pats')
                   | ((option,Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
                                            ty),_))::pats'',(exp,env)) => 
                     duplicate_patterns pats (((option,Absyn.WILDpat)::pats'',
                                               (exp,(rootvar,vi,ty)::env))::pats')
                   | ((option,Absyn.LAYEREDpat((vi,ty),pat))::pats'',(exp,env)) => 
                       duplicate_patterns (((option,pat)::pats'',
                                            (exp,(rootvar,vi,ty)::env))::pats) pats'
                   | ((option,Absyn.TYPEDpat(pat,_,_))::pats'',env) => 
                       duplicate_patterns (((option,pat)::pats'',env)::pats) pats'
                   | ((_,pat')::_,_) => 
                       (case pat' of 
                          Absyn.RECORDpat(_,_,ref ty) => 
                            (record := true;
                             record_type := Option.PRESENT(ty))
                        | _ => ();
                        let
                          val (pats,pats'') = duplicate_pattern' pat' pats
                        in
                            duplicate_patterns pats
                            (pats'@@pats''@@(pat::duplicate_pattern pat' pats'))
                        end)
                   | _ => Crash.impossible "duplicate_patterns:separate_defaults':generate_tree:match"
             in
               duplicate_patterns pats []
             end
         val separate_defaults = if exception_tree then separate_defaults'
                                 else separate_defaults
d1233 1
a1233 1
              if this pattern is a labelled-pattern, this rootvar is stored in the pattern; 
d1236 6
a1241 6
         fun generate_tree' (patterns as ((option,_)::_,_)::_) default env = 
               (case option of
                 Option.ABSENT => generate_tree rootvars patterns default env
                |Option.PRESENT(matchvar,_) => 
                   generate_tree (matchvar::rootvars) patterns default env)
         |   generate_tree' patterns default env = generate_tree rootvars patterns default env
d1244 18
a1261 17
         fun make_construc pat opt = 
                case opt of
                 Option.ABSENT => the_construc pat
                |Option.PRESENT(_,Option.PRESENT(construc)) => construc
                | _ =>    Crash.impossible "make_construc:generate_tree:match"     
         val (non_defaults,defaults') = if separate then (record := false;
							  separate_defaults patterns)
                                        else (patterns,nil)
         val (defaults,include_non_defaults) =
                     case non_defaults of
                      nil => (tl defaults',true)
                     | _ => (defaults',false)
         fun flat nil = nil
         |   flat (xs::xss) = xs@@flat xss
         fun strip nil = nil
         |   strip ((pat::pats',env)::rest) = (pats',env)::strip rest
         |   strip _ = Crash.impossible "strip:generate_tree:match"
d1266 10
a1275 9
         local
             val don't = not
         in
            fun new_default_tree nil = (true,default_tree)
            |   new_default_tree defaults = 
             let 
              fun new_default_tree nil _ = default_tree
              |   new_default_tree (default::defaults) include_non_defaults =
                   let val (default,separate,generate_tree) = 
d1278 16
a1293 16
                       val old_default =
                         case defaults of
                           [] => true
                         | _ => false
                   in
                     ref(UNBUILT(fn env => 
                                 generate_tree'' generate_tree default (separate,false,
                                new_default_tree defaults (don't include_non_defaults)) 
						env old_default,
                                                ref Option.ABSENT,nil,false))
                   end
             in
                  (false,new_default_tree defaults include_non_defaults)
             end
         end
         local
d1297 1
a1297 1
           fun CONsplit (add_pat,exception_constructor) (patterns as (((opt,pat)::_,_),tree)::_) =
d1299 58
a1356 58
                 val construc_pat = make_construc pat opt
                 val same_pattern =
                   case exception_constructor of
                     Option.PRESENT(_) =>
                       let
                         fun pattern_type (Absyn.APPpat((_,ref ty),_,_,_)) = ty
                           | pattern_type (Absyn.VALpat((_,(ref ty,_)),_)) = ty
                           | pattern_type _ = Crash.impossible "pattern_type:CONsplit:match"
                         val construc_pat_type = pattern_type pat
                       in
                         (fn (p,lvi) =>
                          if lvi = construc_pat then
                            (true,false)
                          else
                            if Types.type_eq(pattern_type p, construc_pat_type, true, true) then
                              (case tree of
                                 Option.PRESENT(tree) =>
                                   (case !tree of
                                      Option.ABSENT =>
                                        (tree :=
                                         Option.PRESENT(Option.SOME1(ref(
                                                 Option.SOME1(0,LEAF(Absyn.RECORDexp(nil),0,nil)))));
                                         (true,true))
                                    | Option.PRESENT(_) => (true,true))
                               | Option.ABSENT => Crash.impossible "same_pattern:CONsplit:match")
                            else (false,true))
                       end
                   | Option.ABSENT =>
                       fn (_,lvi) => (lvi = construc_pat,false)
                 fun add_exn (lvi,info,exp' as ((exp,n,exns),mvs)) = ((exp,n,(lvi,info)::exns),mvs)
                 fun add_exns pats =
                   let
                     val info =
                       case exception_constructor of
                         Option.PRESENT(info) => info
                       | Option.ABSENT => Crash.impossible "info:add_exns:CONsplit:match"
                     fun add_exns nil = nil
                       | add_exns ((lvi,(pp,exp))::pats) = (pp,add_exn(lvi,info,exp))::add_exns pats
                   in
                     add_exns pats
                   end
	         fun insplit [] (p1,p2) =
                     (case tree of
                        Option.PRESENT(ref(Option.PRESENT(_))) => add_exns (rev p1)
                      | _ => map (fn (_,p)=>p) (rev p1), rev p2, pat, tree)
	         |   insplit ((pats as ((opt,p)::pp,exp),tree')::pl) (p1,p2) =
                     let
                       val lvi = make_construc p opt
                       val (same_pattern,different_exception_pattern) = same_pattern(p,lvi)
                     in
	               if same_pattern then
                         insplit pl ((lvi,(add_pat p pp,exp))::p1,
                                     if different_exception_pattern then (pats,tree)::p2
                                     else p2)
	               else
                         insplit pl (p1,(pats,tree')::p2)
                     end
                 |   insplit _ _ = 
d1358 6
a1363 6
	        in  
	             insplit patterns ([],[]) 
	        end 
           |   CONsplit _ _ = 
                      Crash.impossible "CONsplit:generate_tree:match"
         in
d1367 43
a1409 41
          fun scon_rule patterns Type =
           let val SCONsplit = CONsplit ((fn _ => fn pats => pats),Option.ABSENT)
               val (old_default,default_tree) = new_default_tree defaults 
	       val binding = make_binding default_tree
	       val env = fetch_environment env rootvar (fn env=>env)
               fun Make_tree_list nil result = result
               |   Make_tree_list patterns (trees,lvis,env) = 
	         let val (same_patterns,rest,pat,_) = SCONsplit patterns
	         in
		    (case pat of
		      Absyn.SCONpat scon => 
                        let
                          val ((env, new_env),redundant) = update_env (pat,Dummy_MV) env Type
                        in
                          if redundant then
                            Make_tree_list rest (trees,lvis,env)
                          else
                            Make_tree_list rest
                            ((scon,generate_tree' same_patterns (true,exception_tree,default_tree) new_env)::trees,
                             scon::lvis,
                             env)
                        end
                     | _  => Crash.impossible 
                                "Make_tree_list:scon_rule:generate_tree:match")
                 end
               val (trees,lvis,env) = Make_tree_list (map (fn pat=>(pat,Option.ABSENT)) patterns) (nil,nil,env)
	       val (env,missing_cons) = 
                 case  all_constructors_present env (Option.SOME1(lvis)) Type 0 of
                   (env,false,missing_cons) => (env,missing_cons)
                 |  _ => Crash.impossible "1:scon_rule:generate_tree:match"
	       val default = 
                      case MakeDefaultTree default_tree env of
                       PRESENT(default) => default
                      | _ => Crash.impossible "2:scon_rule:generate_tree:match"
            in
                 (make_default default_tree old_default missing_cons;
                  case trees of
                    [] => DEFAULT(default,binding)
                  | _ => SCON(rootvar,trees,default,binding))
            end
                
d1413 4
a1416 4
	  fun constructor_rule patterns Type =
            let
               val (old_default,default_tree) = new_default_tree defaults
               val (exception_constructor,info) =
d1419 16
a1434 16
                        (Option.PRESENT(rootvar,default_tree),fn ()=>Option.PRESENT(ref(Option.ABSENT)))
                    |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.EXCON(_)),(ref ty,_)),_))::_,_)::_ =>
                        (Option.PRESENT(rootvar,default_tree),fn ()=>Option.PRESENT(ref(Option.ABSENT)))
                    | _ => (Option.ABSENT,fn ()=>Option.ABSENT)
               val CONsplit = CONsplit 
                      ((fn pat => fn pats => 
                         case pat of
                          Absyn.APPpat(_,newpat,_,_) => (Option.ABSENT,newpat)::pats
                         | _ => pats), exception_constructor)
               val binding =
                 case make_binding default_tree of
                   Option.PRESENT(bd) => [Option.SOME1(bd)]
                 | Option.ABSENT => []
	       val env = fetch_environment env rootvar (fn env=>env)
               (** If possibility of runtime exception identity,
                     share trees and bind in this node effectively delaying real pattern matching
d1438 132
a1569 131
               fun Make_tree_list nil (trees,boundtrees,lvis,env) = (rev trees,rev boundtrees,rev lvis,env)
               |   Make_tree_list patterns (trees,boundtrees,lvis,env) = 
	         let 
                   val (same_patterns,rest,pat,tree) = CONsplit patterns
	         in
		   (case pat of
		     Absyn.VALpat((lvi,_),_) => 
                       Make_tree_list rest
                       (case tree of
                          Option.ABSENT => 
                            let
                              val ((env, new_env),redundant) = update_env (pat,Dummy_MV) env Type
                            in
                              if redundant then (trees,boundtrees,lvis,env)
                              else
                                ((lvi,Dummy_MV,
                                  Option.SOME1(generate_tree'
                                               same_patterns (true,exception_tree,default_tree) new_env))::trees,
                                boundtrees,
                                lvi::lvis,
                                env)
                            end
                        | Option.PRESENT(tree) =>
                            (case !tree of
                               Option.ABSENT => 
                                 let
                                   val ((env, new_env),redundant) = update_env (pat,Dummy_MV) env Type
                                 in
                                   if redundant then (trees,boundtrees,lvis,env)
                                   else
                                     ((lvi,Dummy_MV,
                                       Option.SOME1(generate_tree' same_patterns
                                                    (true,exception_tree,default_tree) new_env))::trees,
                                     boundtrees,
                                     lvi::lvis,
                                     env)
                                 end
                             | Option.PRESENT(Option.SOME1(tree')) => 
                                 let
                                   val ((env, new_env),redundant) = update_env (pat,Dummy_MV) env Type
                                 in
                                   if redundant then (trees,boundtrees,lvis,env)
                                   else
                                     (tree' := 
                                      Option.SOME1(next_label(),
                                                   generate_tree' same_patterns (true,true,default_tree) new_env);
                                      tree := Option.PRESENT(Option.SOME2(tree',Dummy_MV));
                                      ((lvi,Dummy_MV,Option.SOME2(tree'))::trees,
                                       Option.SOME2(tree',Dummy_MV)::boundtrees,
                                       lvi::lvis,
                                       env))
                                 end
                             | Option.PRESENT(Option.SOME2(tree,_)) =>
                                 ((lvi,Dummy_MV,Option.SOME2(tree))::trees,
                                  boundtrees,
                                  lvi::lvis,
                                  env)))
                    |Absyn.APPpat((lvi,_),_,_,_) => 
                        Make_tree_list rest
                       (case tree of
                          Option.ABSENT => 
                            let
                              val matchvar = next_Matchvar()
                              val ((env, new_env),redundant) = update_env (pat,matchvar) env Type
                            in 
                              if redundant then (trees,boundtrees,lvis,env)
                              else
                                ((lvi,matchvar,
                                  Option.SOME1(generate_tree (matchvar::rootvars)
                                               same_patterns (true,exception_tree,default_tree) new_env))::trees,
                                boundtrees,
                                lvi::lvis,
                                env)
                            end
                        | Option.PRESENT(tree) =>
                            (case !tree of
                               Option.ABSENT => 
                                 let
                                   val matchvar = next_Matchvar()
                                   val ((env, new_env),redundant) = update_env (pat,matchvar) env Type
                                 in
                                   if redundant then (trees,boundtrees,lvis,env)
                                   else
                                     ((lvi,matchvar,
                                       Option.SOME1(generate_tree (matchvar::rootvars) same_patterns
                                                    (true,exception_tree,default_tree) new_env))::trees,
                                     boundtrees,
                                     lvi::lvis,
                                     env)
                                 end
                             | Option.PRESENT(Option.SOME1(tree')) => 
                                 let
                                   val matchvar = next_Matchvar()
                                   val ((env, new_env),redundant) = update_env (pat,matchvar) env Type
                                 in
                                   if redundant then (trees,boundtrees,lvis,env)
                                   else
                                     (tree' := 
                                      Option.SOME1(next_label(),
                                                   generate_tree (matchvar::rootvars)
                                                   same_patterns (true,true,default_tree) new_env);
                                      tree := Option.PRESENT(Option.SOME2(tree',matchvar));
                                      ((lvi,matchvar,Option.SOME2(tree'))::trees,
                                       Option.SOME2(tree',matchvar)::boundtrees,
                                       lvi::lvis,
                                       env))
                                 end
                             | Option.PRESENT(Option.SOME2(tree,matchvar)) =>
                                 ((lvi,matchvar,Option.SOME2(tree))::trees,
                                  boundtrees,
                                  lvi::lvis,
                                  env)))
                     | _ => Crash.impossible 
                                "Make_tree_list:constructor_rule:generate_tree:match")
                 end
               val (trees,boundtrees,lvis,env) =
                 Make_tree_list (map (fn pat=>(pat,info())) patterns) (nil,nil,nil,env)
               val Type = TypeUtils.get_cons_type(Types.the_type(Type))
	       val (env,all_constructors_present,missing_constructors) = 
                 all_constructors_present env (Option.SOME2(lvis)) Type (TypeUtils.get_no_cons Type)
	       val default = if all_constructors_present then ABSENT
                             else MakeDefaultTree default_tree env
            in
                (make_default default_tree old_default missing_constructors;
                 case trees of
                   [] => DEFAULT(case (default,binding) of
                                   (PRESENT(default),[]) => (default,Option.ABSENT)
                                 | (PRESENT(default),[Option.SOME1(binding)]) =>  (default,Option.PRESENT(binding))
                                 | _ => Crash.impossible "DEFAULT:constructor_rule:match")
		 | _ => CONSTRUCTOR(Type,rootvar,trees,Option.SOME1(default),binding@@boundtrees,false))
            end
d1571 1
a1571 1
         end
d1577 3
a1579 2
	 fun record_rule patterns Type = 
          let (** an indicator that a nested record pattern has been encountered while processing
d1582 3
a1584 3
	      datatype pattern = 
                 Record of DataTypes.Type * Matchvar * (Ident.Lab * Matchvar) list ref
                |NONRecord
d1588 1
a1588 1
              val nested_records : (DataTypes.Type * Matchvar * 
d1590 263
a1852 253
              fun (x,y):::(xs,ys) = (x::xs,y::ys)
              (** re-order all patterns in a record and all its nested records in order of the 
		  number of non-variable patterns and also the number of repeated constructors
	       **)
	      fun fetchLabelledPatterns (ty,matchvar,matchvars) toplevel patterns = 
              let
               fun fetch_labelled_patterns nil patterns = 
                    (case patterns of 
                      [(nil,_)] => nil
                     | _ => patterns)
               |   fetch_labelled_patterns (((Option.ABSENT,pattern),env)::rest) patterns =
               let datatype flag = ABSENT | PRESENT
                   (** for all labelled patterns missing in the last record pattern, insert a 
		       wild pattern
		    **)
		   fun add_dummy_patterns (nil,nil) = nil
                   |   add_dummy_patterns ((record,pats)::patterns,ABSENT::checklist) =
                          (record,((Option.ABSENT,Absyn.WILDpat),env)::pats)
                                              ::add_dummy_patterns (patterns,checklist)
                   |   add_dummy_patterns ((record,pats)::patterns,nil) =
                          (record,((Option.ABSENT,Absyn.WILDpat),env)::pats)
                                              ::add_dummy_patterns (patterns,nil)
                   |   add_dummy_patterns (pats::patterns,PRESENT::checklist) =
                          pats::add_dummy_patterns (patterns,checklist)
                   |   add_dummy_patterns _ = Crash.impossible 
                                    ("add_dummy_patterns:fetch_labelled_patterns:"^
                                    "record_rule:match")
               in
               (case (if toplevel then fetch_pat pattern (Option.PRESENT(matchvar,env))
                      else pattern)  of
                 Absyn.RECORDpat(pats,_,_) =>
                  let fun Fetch_labelled_patterns pats patterns = 
		      let
		      fun Fetch_labelled_patterns nil patterns_checklist = patterns_checklist
                      |   Fetch_labelled_patterns ((lab,pat)::rest) 
                                       (patterns_checklist as (patterns,checklist)) =
                      let 
                       fun duplicate_ABSENT nil = nil
                       |   duplicate_ABSENT (_::rest) = ABSENT::duplicate_ABSENT rest
                       fun pat_type pat_type' matchvar = 
                         case fetch_pat pat (Option.PRESENT(matchvar,env)) of 
                          pat as Absyn.RECORDpat((_,_,ref ty)) => 
                           (case pat_type' of
                             NONRecord => 
                              let val refnil = ref nil
                              in
                               (nested_records := (ty,matchvar,refnil)::(!nested_records);
                                (Record(ty,matchvar,refnil),pat))
                              end
                            |record as Record(_) => (record,pat))
                         |pat => (pat_type',pat)
		       (** for every labelled-pattern, update the collections by labels of all 
			   the labelled-patterns encountered so far
			**)
                       fun add_labelled_pattern nil nil =
                        let val matchvar = next_Matchvar()
                            val (pat_type,pat) = pat_type NONRecord matchvar
			    val _ = matchvars := (lab,matchvar)::(!matchvars)
                            fun add_labelled_wildpat (nil,nil) = nil
                            |   add_labelled_wildpat (((_,pats)::_),checklist) = 
                              let fun add_labelled_wildpat nil = nil
                                  |   add_labelled_wildpat (_::rest) = 
                                       ((Option.ABSENT,Absyn.WILDpat),env)
                                       ::add_labelled_wildpat rest
                              in
                                  case checklist of
                                   PRESENT::_ => add_labelled_wildpat (tl pats)
                                  |ABSENT::_ => add_labelled_wildpat pats
                                  | nil => add_labelled_wildpat pats
                              end
                            |   add_labelled_wildpat _ = Crash.impossible 
                                    ("add_labelled_wildpat:fetch_labelled_patterns:"^
                                    "record_rule:match")
                        in
                          ([([(lab,matchvar,pat_type)],((Option.ABSENT,pat),env)
                                 ::add_labelled_wildpat patterns_checklist)],[PRESENT])
                        end
                       |   add_labelled_pattern [(nil,pats)] nil = 
                        let val matchvar = next_Matchvar()
                            val (pat_type,pat) = pat_type NONRecord matchvar
			    val _ = matchvars := (lab,matchvar)::(!matchvars)
                        in
                          ([([(lab,matchvar,pat_type)],((Option.ABSENT,pat),env)::pats)],
                           [PRESENT])
                        end
                       |   add_labelled_pattern ((entry as ([(label,matchvar,pat_type')],pats))
                                                              ::patterns) (check::checklist) =
                          if Ident.lab_eq(lab,label) 
                          then 
                           let val (pat_type,pat) = pat_type pat_type' matchvar
                           in
                               (([(label,matchvar,pat_type)],
                                 ((Option.ABSENT,pat),env)::pats)::patterns,
                                 PRESENT::checklist)
                           end
                          else (entry,check):::add_labelled_pattern patterns checklist
                       |   add_labelled_pattern 
                           ((entry as ([(label,matchvar,pat_type')],pats))::patterns) nil =
                          if Ident.lab_eq(lab,label) 
                          then 
                           let val (pat_type,pat) = pat_type pat_type' matchvar
                           in
                               (([(label,matchvar,pat_type)],
                                 ((Option.ABSENT,pat),env)::pats)::patterns,
                                 PRESENT::duplicate_ABSENT patterns)
                           end
                          else (entry,ABSENT):::add_labelled_pattern patterns nil 
                       |   add_labelled_pattern _ _ = Crash.impossible 
                              ("1:add_labelled_pattern:fetch_labelled_patterns"^
                                  ":record_rule:match")
                      in
                        case pat of 
                         Absyn.WILDpat =>
                          Fetch_labelled_patterns rest patterns_checklist 
                        | _ => 
                          Fetch_labelled_patterns rest 
                               (add_labelled_pattern patterns checklist)
                      end
                      in
                         case Fetch_labelled_patterns pats (patterns,nil) of
                          (_,nil) => 
                            fetch_labelled_patterns (((Option.ABSENT,Absyn.WILDpat),env)::rest)
                            patterns 
                         |patterns => 
                            fetch_labelled_patterns rest (add_dummy_patterns patterns)
                      end
                 in
                     Fetch_labelled_patterns pats patterns
                 end
                 |Absyn.WILDpat =>
                   fetch_labelled_patterns rest 
                        (case patterns of
                          nil => [(nil,[((Option.ABSENT,Absyn.WILDpat),env)])]
                         |[(nil,entry)] => 
                            [(nil,((Option.ABSENT,Absyn.WILDpat),env)::entry)]
                         | _ => add_dummy_patterns (patterns,nil))
                 | _ => Crash.impossible "1:fetch_labelled_patterns:record_rule:match")
               end
               |   fetch_labelled_patterns _ _ = 
                     Crash.impossible "2:fetch_labelled_patterns:record_rule:match"
	       (** repeat operation for all nested records
		**)
               fun fetch_nested_labelled_patterns nil = nil
               |   fetch_nested_labelled_patterns 
                         (([(label,matchvar,NONRecord)],pats)::patterns) =
                            (matchvar,pats)::fetch_nested_labelled_patterns patterns 
               |   fetch_nested_labelled_patterns 
                    (([(label,matchvar,Record(record))],pats)::patterns) =
                          fetchLabelledPatterns record false (rev pats) @@
                                           fetch_nested_labelled_patterns patterns
               |   fetch_nested_labelled_patterns  _ = 
                       Crash.impossible "fetch_nested_labelled_patterns:record_rule:match"
              in
                 fetch_nested_labelled_patterns (fetch_labelled_patterns patterns nil)
              end
	      (** a heuristic for ordering patterns : the number of stages of matching 
		  in the pattern
	       **)
              infix <
              fun (Absyn.VALpat(_)) < _ = true
              |   (Absyn.APPpat(_,pat,_,_)) < (Absyn.APPpat(_,pat',_,_)) = pat<pat'
              |   _ < (Absyn.APPpat(_)) = true
              |   (Absyn.APPpat(_)) < _ = false
              |   _ < _ = true
	      (** find the number of repeated constructors in a set of patterns
	       **)
              fun inner_sort nil = nil
              |   inner_sort ((matchvar,patterns)::rest) = 
               let fun calculate_scores patterns = 
                    let 
                     fun a':::(a,(b,c,d)) = (a'::a,(b,c,d))
                     fun split (((Option.ABSENT,pat),env)::rest) = 
                       let fun Split nil _ (score,rest,pat) = 
                                              (nil,(score,rest,pat))
                           |   Split (((Option.ABSENT,pattern''),env)::rest) 
                                           construc (score,rest_so_far,pattern') = 
                            (case pattern'' of
                              Absyn.WILDpat => 
                                ((Option.PRESENT(matchvar,Option.ABSENT),pattern''),env)
                                    :::(Split rest construc (score,rest_so_far,pattern'))
                             | _ =>
                              let val construc_pattern = the_construc pattern''
                                  val pattern = 
                                    ((Option.PRESENT(matchvar,Option.PRESENT(construc_pattern)),
                                      pattern''),env)
                              in
                                 pattern:::(Split rest construc 
                                            (if construc=construc_pattern 
                                             then (score+1,rest_so_far,
                                                   if pattern'<pattern'' then pattern'' 
                                                   else pattern')
                                             else (score,pattern::rest_so_far,
                                                   if pattern'<pattern'' then pattern'' 
                                                   else pattern')))
                              end)
                           |   Split _ _ _ = 
                             Crash.impossible "1:Split:inner_sort:record_rule:match"
                       in
                            case pat of
                             Absyn.WILDpat => 
                               ((Option.PRESENT(matchvar,Option.ABSENT),pat),env):::(split rest)
                            | _ => 
                             let val construc_pattern = the_construc pat
                             in
                                ((Option.PRESENT(matchvar,Option.PRESENT(construc_pattern)),
                                  pat),env)
                                     :::(Split rest construc_pattern (1,nil,pat))
                             end
                       end
                     |   split ((pattern as (Option.PRESENT(_,
                                               Option.PRESENT(construc_pattern)),
                                             pat),env)::rest) =
                       let fun Split nil _ (score,rest) = 
                                              (score,rest,Absyn.WILDpat)
                           |   Split ((pattern as ((Option.PRESENT(_,
                                        Option.PRESENT(construc_pattern)),_),env))::rest) 
                                           construc (score,rest_so_far) = 
                                 Split rest construc 
                                   (if construc=construc_pattern 
                                    then (score+1,rest_so_far)
                                    else (score,pattern::rest_so_far))
                           |   Split _ _ _ = 
                             Crash.impossible "2:Split:inner_sort:record_rule:match"
                       in
                           (nil,Split rest construc_pattern (1,nil))
                       end
                     |   split nil = (nil,(0,nil,Absyn.WILDpat))
                     |   split _ = Crash.impossible "split:inner_sort:record_rule:match"
                     fun calculate_scores patterns =
                     let 
                      fun calculate_scores (scores,nil) = scores
                      |   calculate_scores (scores,rest) = 
                        let val (_,(score,rest,_)) = split rest
                        in
                             calculate_scores (score::scores,rest)
                        end
                      val (patterns,(score,rest,pattern)) = split patterns
                     in
                        (patterns,pattern,calculate_scores ([score],rest))
                     end
                     fun count_non_variables nil result = result
                     |   count_non_variables (pat::rest) (score,pats) =
                        count_non_variables rest 
                          (case pat of
                            ((Option.ABSENT,Absyn.WILDpat),_) => score
                           | _ => score+1,
                           pat::pats)
                     val (score,patterns) = count_non_variables patterns (0,nil)
                     val (patterns,pattern,scores) = calculate_scores patterns
                    in
                        (score,patterns,pattern,scores)
                    end
                   val sort = 
d1854 8
a1861 8
                         (fn (score1:int,score2:int) => 
                               if score1>score2 then score1
                               else score2)
                   val (score,patterns,pattern,scores) = calculate_scores patterns
                in
                     (patterns,pattern,score,sort (0,scores))::inner_sort rest
                end
	      (** sort patterns by the number of repeated constructors and the number of 
d1864 35
a1898 33
              val sort = Lists.qsort 
                        (fn ((_,pattern,score11 : int,score21 : int),
                             (_,pattern',score12,score22)) => 
                             score11 > score12 orelse 
                             score11 = score12 andalso  
                               (score21>score22 orelse score21=score22
                                 andalso pattern<pattern'))
	      (** put result back into format required by the generation process
	       **)
              fun merge remaining_patterns patterns = 
                 let 
                   fun merge nil nil = nil
                   |   merge patterns 
                           ((remaining_pattern,(exp,remaining_env))::remaining_patterns) = 
                        let infix @@@@ infix @@@@@@
                            fun (pat,pattern)@@@@(pats,patterns) = (pat::pats,pattern::patterns)
                            fun pat@@@@@@(pats,patterns) = (pat::pats,patterns)
                            fun reduce [(((opt,pattern),_)::patterns,pat,
                                                    score1,score2)] = 
                                 (case patterns of
                                   nil => ([(opt,pattern)],nil)
                                  | _ => 
                                   ([(opt,pattern)],[(patterns,pat,score1,score2)]))
                            |   reduce ((((opt,pattern),_)::patterns,pat,
                                                     score1,score2)::rest) = 
                                 (case patterns of
                                   nil => (opt,pattern)@@@@@@reduce rest
                                  | _ => 
                                    ((opt,pattern),(patterns,pat,score1,score2))@@@@reduce rest)
                            |   reduce nil = (nil,nil)
                            |   reduce _ = 
                             Crash.impossible "reduce:merge:record_rule:generate_tree:match"
                            val (patterns,rest) = reduce patterns 
d1900 2
a1901 2
                             (patterns@@remaining_pattern,(exp,!remaining_env))
                                                  ::merge rest remaining_patterns
d1903 5
a1907 5
                    |   merge _ _ = 
                          Crash.impossible "merge:record_rule:generate_tree:match"
                 in
                    merge patterns remaining_patterns 
                 end
d1910 35
a1944 30
              fun refer_to_envs _ nil = (nil,nil)
              |   refer_to_envs f ((pattern::patterns,(exp,env))::rest) = 
                   let val refenv = ref env
                   in
                     ((f pattern,refenv),(patterns,(exp,refenv))):::refer_to_envs f rest
                   end
              |   refer_to_envs _ _ = Crash.impossible "refer_to_envs:match"
              fun Map f nil = nil
              |   Map f (optpat::pats) = f optpat::Map f pats
              val (patterns,remaining_patterns) = 
                 refer_to_envs (fn (opt,pat)=>(opt,pat)) (patterns@@flat defaults)
              val matchvars = ref nil
              val patterns =
                      (merge remaining_patterns o sort o inner_sort o 
                               fetchLabelledPatterns (Type,rootvar,matchvars) true) patterns
	      fun reverse nil result = result
	      |   reverse ((ty,mv,mvs)::rest) result = reverse rest ((ty,mv,!mvs)::result)
	      val nested_records = (Type,rootvar,!matchvars)::reverse (!nested_records) nil
	      (** update environments by matchvars assigned to labelled-patterns for later
		  exhaustiveness and redundancy checking
	       **)
	      local
	       fun update_record_env nil _ = nil
               |   update_record_env ((env,mvars)::envs) f = 
  		let fun update_record_env' ([env],nil) = f env
		    |   update_record_env' (env,((mvar,mvar')::mvars)) = 
		         update_record_env' (#2(#1(update_env (Absyn.WILDpat,mvar) 
			(fetch_environment env mvar' (fn env=>env)) DataTypes.NULLTYPE)),mvars)
		    |   update_record_env' _ = 
				Crash.impossible "update_record_env:generate_tree:match"
d1946 26
a1971 24
			update_record_env' ([env],mvars)::update_record_env envs f
		end
	      in
	       fun match_matchvars nil env = 
			Crash.impossible "1:match_matchvars:generate_tree:match"
	       |   match_matchvars (mvars as (_,rootvar,_)::_) env = 
	       let fun match_matchvars nil env = update_record_env env (fn env=>env)
	           |   match_matchvars [(_,_,nil)] env = update_record_env env (fn env=>env)
	           |   match_matchvars ((_,_,nil)::(mvars as (_,rootvar,_)::_)) env = 
		    	match_matchvars mvars 
                        (fetch_environment' (update_record_env env (fn env=>(env,nil))) rootvar)
	           |   match_matchvars ((ty,root,(mvar' as (lab,mvar))::mvars)::matchvars) env =
                      let fun fetch_mvar nil = Option.ABSENT
                          |   fetch_mvar ((lab',mvar')::l') = 
                                 if Ident.lab_eq (lab,lab') then Option.PRESENT(mvar')
                                 else fetch_mvar l'
                      in
			match_matchvars ((ty,root,mvars)::matchvars)
			(map (fn ((entry as (mvs,REC(mvars')))::env,mvars'') => 
                       	       (case fetch_mvar mvars' of
                                 Option.PRESENT(mvar') => (entry::env,(mvar,mvar')::mvars'')
                                |Option.ABSENT => 
				  ((mvs,REC(mvar'::mvars'))::env,mvars''))
		              |  ((mvs,CON1([]))::env,mvars'') => 
d1973 7
a1979 7
			      | _ => 
				Crash.impossible "2:match_matchvars:generate_tree:match")
					env)
                      end
		in
			match_matchvars mvars (fetch_environment env rootvar 
                                               (fn env=>(env,nil)))
a1980 1
	      end
d1983 6
a1988 6
              fun generate_record_tree nil = 
		   generate_tree' patterns (true,exception_tree,default_tree) 
				(match_matchvars nested_records env)
              |   generate_record_tree ((ty,matchvar,matchvars)::records) = 
                      RECORD(Types.the_type(ty),matchvar,matchvars,generate_record_tree records)
          in
d1990 36
a2025 36
          end
     in
         case non_defaults of
          ((_,Absyn.RECORDpat(_,_,ref ty))::_,_)::_ => 
                       (record := false; record_rule non_defaults ty)
         |((_,Absyn.APPpat((_,ref ty),_,_,_))::_,_)::_ => constructor_rule non_defaults ty
         |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.CON(_)),(ref ty,_)),_))::_,_)::_ =>
                                  constructor_rule non_defaults ty
         |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.EXCON(_)),(ref ty,_)),_))::_,_)::_ =>
                                            constructor_rule non_defaults ty
         |((_,Absyn.SCONpat(pat))::_,_)::_ =>  
            scon_rule non_defaults 
            (case pat of
               Ident.INT(_) => Types.int_type
             | Ident.REAL(_) => Types.real_type
             | Ident.CHAR(_) => Types.char_type
             | Ident.WORD(_) => Types.word_type
             | Ident.STRING(_) => Types.string_type)
         |nil => 
           if (!record) then 
                   (record := false;
                    record_rule (hd defaults') 
                                  (case (!record_type) of
                                    Option.ABSENT => 
                                      Crash.impossible "1:generate_tree:match"
                                   |Option.PRESENT(ty) => ty))
           else  
	    let val (old_default,new_default_tree) = new_default_tree defaults
	    in
		generate_tree'' generate_tree' (strip (hd defaults')) 
					(true,exception_tree,new_default_tree) env old_default
	    end
         | _ => Crash.impossible "2:generate_tree:match"
     end
    |   generate_tree _ _ _ _ = Crash.impossible "3:generate_tree:match"
   in      
d2027 3
a2029 3
      fun unparseTree options tree space_out = 
      let
	  fun unparseDef (Option.SOME1(def)) =
d2032 3
a2034 3
             | PRESENT(ref(BUILT(ref(Option.SOME1(n,_))))) => 
               "Present default of "^"'TREE "^MLWorks.Integer.makestring n^"'"
             | PRESENT(ref(ERROR(_))) =>
d2038 34
a2071 34
            | unparseDef (Option.SOME2(ref(Option.SOME1(n,_)))) =
               "Present default of "^"'TREE "^MLWorks.Integer.makestring n^"'"
            | unparseDef (Option.SOME2(_)) =
                 Crash.impossible "2:unparseDef:unparseTree:match"

	fun list_subs [] rest = rest
	  | list_subs ((m, vi, _)::ll) rest =
	    list_subs ll
	    (rest @@ [" '", IdentPrint.printValId options vi, "'/#", 
                     MLWorks.Integer.makestring m])

	fun list_fields [] rest = rest
	  | list_fields ((m, vi)::ll) rest =
	    list_fields ll
	    (rest @@ [" '", IdentPrint.printLab m, "'=#", MLWorks.Integer.makestring vi])

	fun list_scons [] rest = rest
	  | list_scons ((m, vi)::ll) rest =
	    ["\n", space_out, "'", IdentPrint.printSCon m,
		     "' =>\n"] @@ unparseTree options vi ("  " ^ space_out) @@ list_scons ll rest

	fun list_cons [] rest = rest
	  | list_cons ((lvi, mv, tr)::ll) rest =
	    ["\n", space_out, "'", IdentPrint.printLongValId options lvi,
		     "' --(#", MLWorks.Integer.makestring mv, ")\n"] 
                  @@ (case tr of
                       Option.SOME1(tr) => unparseTree options tr ("  " ^ space_out)
                     | Option.SOME2(ref(Option.SOME1(n,_))) => 
                         ["  " ^ space_out^"'TREE "^MLWorks.Integer.makestring n^"'"]
                     | _ => Crash.impossible "list_cons:unparseTree:match") @@ list_cons ll rest
        fun print_binding binding = 
          Lists.reducel
          (fn (str,binding) =>
           str@@
d2073 7
a2079 7
               Option.SOME1(ref(Option.PRESENT(ref(Option.SOME1(n,tr))))) => 
                     "\n"::space_out::"   "::"'TREE "::MLWorks.Integer.makestring n::"'"
			::" is bound to \n"::unparseTree options tr ("       "^space_out)
              |Option.SOME1(ref(Option.ABSENT)) => nil
              | Option.SOME2(ref(Option.SOME1(n,tr)),_) => 
                     "\n"::space_out::"   "::"'TREE "::MLWorks.Integer.makestring n::"'"
			::" is bound to \n"::unparseTree options tr ("       "^space_out)
d2081 19
a2099 19
          ("\n"::space_out::"BINDING :"::[],binding)
      in
	(case tree of
	   LEAF (exp,n,ll) =>
	     (list_subs ll [space_out, "LEAF ", 
                         AbsynPrint.unparseExp options exp, " {"]) @@ [" }"]
	 | SCON (mv, ll, def, binding) => 
	     ([space_out, "SCON #", MLWorks.Integer.makestring mv]@@list_scons ll [])
	     @@ (("\n"^space_out)::(unparseDef (Option.SOME1(PRESENT(def)))::
                                   (case binding of
                                      Option.ABSENT => []
                                    | Option.PRESENT(bd) => print_binding [Option.SOME1(bd)])))
	 | CONSTRUCTOR (_, mv, ll, def,binding,_) =>
	     ([space_out, "CONSTRUCTOR #", MLWorks.Integer.makestring mv]@@list_cons ll [])
	     @@ (("\n"^space_out)::(unparseDef def::(case binding of
                                                      nil => []
                                                    | _ => print_binding binding)))
	 | RECORD (_, mv, ll, tr) => 
	     (list_fields ll [space_out, "RECORD #", MLWorks.Integer.makestring mv])
d2101 33
a2133 5
         | DEFAULT(default,binding) => [space_out,unparseDef(Option.SOME1(PRESENT(default)))]@@
                                   (case binding of
                                      Option.ABSENT => []
                                    | Option.PRESENT(bd) => print_binding [Option.SOME1(bd)]))
      end
d2135 25
a2159 52
     fun compile_match pats = 
          let 
              (** Do the set-up **)
              val rootvar = next_Matchvar()
              
              (** convert a '(Absyn.Pat * exp) list' to a pattern list
               **)

              local
                 fun convert nil _ (redundant_pats,pats) = (tl(rev redundant_pats),rev pats)
                 |   convert (pat::pats) true (redundant_pats,pats') = 
                       convert pats true (((#1(hd redundant_pats)) + 1,TRUE)::redundant_pats,pats')
                 |   convert ((pat,exp,_)::pats) false (redundant_pats,pats') = 
                      let val n = (#1(hd redundant_pats)) + 1
                          val redundant =
                            case fetch_pat pat Option.ABSENT of
                             Absyn.WILDpat => true
                            |Absyn.VALpat((Ident.LONGVALID( _, Ident.VAR _ ), _),_) => true
                            |_ => false
                      in
                         convert pats redundant 
                                  ((n,TRUE)::redundant_pats,
                                   ([(Option.ABSENT,pat)],((exp,n,[]),[]))::pats')
                      end
              in
                 val (redundant_pats,pats) = convert pats false ([(0,TRUE)],[])
              end
              
              (** Calculate the match tree **)
              val the_tree = 
		(label_count := 0;redundant_patterns := redundant_pats; 
                 inexhaustive := Option.ABSENT;
                 match_vars := [];
		 generate_tree'' 
                 (generate_tree [rootvar]) pats (true,false,
                   ref(ERROR
                       (fn cons => 
                        (case cons of
                           nil => ()
                         | _ => 
                             inexhaustive := 
                             (case !inexhaustive of
                                Option.PRESENT(cons') => 
                                  Option.PRESENT(cons'@@cons)
                              | Option.ABSENT => Option.PRESENT(cons)))))) [[]] false)
          in
            (if !show_match then
              (map (fn str => output(std_out,str))
               ("\n"::unparseTree Options.default_print_options the_tree ""@@["\n"]);
               ())
             else
               ();
d2161 3
a2163 3
          end
   end
      
@


1.54
log
@Add scons structure for scon_eqval
@
text
@d3 3
d465 1
d471 3
d477 1
d481 1
d520 1
d532 1
d910 1
d1904 1
@


1.53
log
@Add special constant chars
@
text
@d3 3
d185 1
d201 1
d216 1
d465 1
a465 1
	   Ident.scon_eqrep(Ident.INT(s, Ident.Location.UNKNOWN),
@


1.52
log
@Sort out problems with redundancy on integer patterns
Add checking for equality between decimals and hexadecimals
@
text
@d3 4
d506 2
d893 2
a894 1
	            |Ident.STRING s        => mkLONGVI s)
d1885 1
@


1.51
log
@Fix bug with multiple exception constructors over records
@
text
@d3 3
a10 1
/
d450 15
d466 33
a498 27
                (fn env' as (mvar',SCON1(scons))::env =>
                   if Lists.member(scon,scons) then (env', [])
                   else
                     (redundant := false;
                      ((mvar',SCON1(scon::scons))::env,
                       (mvar',SCON2(scon,mvar))::env))
                  | env' as (mvar',CON1[])::env =>
                     (redundant := false;
                      ((mvar',SCON1([scon]))::env,
                       (mvar',SCON2(scon,mvar))::env))
                  | env' as (mvar'',SCON2(scon',mvar'))::env =>
                       if scon=scon' then 
                         (redundant := false;
                          ([],
                           if mvar = Dummy_MV then env'
                           else
                             let
                               (* let matchvars in environment correspond *)
                               val env =
                                 case fetch_environment'' mvar' env of
                                   (mv,cons)::env => (insert(mvar,mv),cons)::env
                                 | _ => Crash.impossible "1:make_entry:update_env:match"
                             in
                               (mvar'',SCON2(scon',mvar))::env
                             end))
                       else (env', [])
                  | _ => Crash.impossible "2:make_entry:update_env:match")
d507 4
a510 1
           | Absyn.SCONpat(scon) => make_scon_entry (printSCon scon)
d520 2
a521 1
                   Ident.LONGVALID(_,Ident.EXCON(con)) => make_scon_entry (Ident.Symbol.symbol_name con)
@


1.50
log
@removed redundant require.
@
text
@d3 3
d864 2
a865 1
             | _ => Crash.impossible "the_construc:generate_tree:match"
d1040 1
a1040 2
                   let
                     val lvi' = the_construc pat'
d1057 1
a1057 1
                           if lvi' = the_construc pat'' then
@


1.49
log
@Renaming structures
/
@
text
@d3 4
a169 1
require "../utils/print";
@


1.48
log
@Tidying up
@
text
@d3 3
d188 1
a188 1
  structure Type_Utils : TYPE_UTILS
d190 1
a190 1
  sharing Types.Datatypes = Type_Utils.DataTypes
d495 1
a495 1
                                           (#2(Type_Utils.get_valenv (Type_Utils.get_cons_type ty)), con))
d498 1
a498 1
                                           (#2(Type_Utils.get_valenv (Type_Utils.get_cons_type ty)), con))
d566 1
a566 1
              val ve = #2(Type_Utils.get_valenv ty)
d1415 1
a1415 1
               val Type = Type_Utils.get_cons_type(Types.the_type(Type))
d1417 1
a1417 1
                 all_constructors_present env (Option.SOME2(lvis)) Type (Type_Utils.get_no_cons Type)
@


1.47
log
@Abstraction of debug information
@
text
@d3 3
d244 1
a244 1
          and Con2 is the present constructor for which the tree is being built. SCon1 and SCon2 are
d250 8
a257 7
    datatype constructors = 
		  Con1 of int list
                | Con2 of Ident.LongValId * Matchvar
                | SCon1 of string list
                | SCon2 of string * Matchvar
                | Rec of (Ident.Lab * Matchvar) list 
    type entry = int * constructors
d261 1
a261 1
      | SCON of Matchvar * (Ident.SCon * 'env Tree) list * 'env defaultTree ref
d269 2
a270 2
      | DEFAULT of 'env defaultTree ref * 'env Tree BoundTree Option.opt ref Option.opt
    and 'env defaultTree = 
d277 1
a277 1
    and 'env Default = PRESENT of 'env defaultTree ref | ABSENT
d331 1
a331 1
      * ((Absyn.Exp * int * (Ident.LongValId * (Matchvar * 'env defaultTree ref)) list)
d351 1
a351 1
          fun fetch_environment' [] _ = (insert(),Con1([]))::env
d410 1
a410 1
          if Con1 entry 
d415 1
a415 1
          if Con2 entry
d440 1
a440 1
                (fn env' as (mvar',SCon1(scons))::env =>
d444 3
a446 3
                      ((mvar',SCon1(scon::scons))::env,
                       (mvar',SCon2(scon,mvar))::env))
                  | env' as (mvar',Con1[])::env =>
d448 3
a450 3
                      ((mvar',SCon1([scon]))::env,
                       (mvar',SCon2(scon,mvar))::env))
                  | env' as (mvar'',SCon2(scon',mvar'))::env =>
d463 1
a463 1
                               (mvar'',SCon2(scon',mvar))::env
d499 1
a499 1
                       fn env' as (mvar',Con1(word))::env =>
d503 3
a505 3
                          ((mvar',Con1(orb(word,word')))::env,
                           (mvar',Con2(con,mvar))::env))
                        | env' as (mvar'',Con2(con',mvar'))::env =>
d518 1
a518 1
                                    (mvar'',Con2(con',mvar))::env
d576 1
a576 1
        |   all_constructors_present ((entry as (_,Con1(word'))::_)::env) (result as (env',_,missing_cons)) = 
d583 1
a583 1
        |   all_constructors_present ((entry as (_,Con2(_))::_)::env) (env',_,missing_cons) =
d585 1
a585 1
        |   all_constructors_present ((entry as (_,SCon1(_))::_)::env) (result as (env',_,missing_cons)) = 
d589 1
a589 1
        |   all_constructors_present ((entry as (_,SCon2(_))::_)::env) (env',_,missing_cons) =
d1802 1
a1802 1
			(map (fn ((entry as (mvs,Rec(mvars')))::env,mvars'') => 
d1806 3
a1808 3
				  ((mvs,Rec(mvar'::mvars'))::env,mvars''))
		              |  ((mvs,Con1([]))::env,mvars'') => 
                       	              ((mvs,Rec(mvar'::nil))::env,mvars'')
@


1.46
log
@Better implementation of power
@
text
@d3 3
d256 2
a257 6
        LEAF of Absyn.Exp * int * (Matchvar * Ident.ValId 
                                   * (DataTypes.Type * DataTypes.Instance ref Option.opt 
                                      * (DataTypes.Tyfun ref * (int,int) Option.option ref) 
                                      list) ref) list
      | SCON of Matchvar * (Ident.SCon * 'env Tree) list 
                    * 'env defaultTree ref
d329 1
a329 2
            * (DataTypes.Type * DataTypes.Instance ref Option.opt 
                           * (DataTypes.Tyfun ref * (int,int) Option.option ref) list) ref) list)
d1160 1
a1160 1
                           | pattern_type (Absyn.VALpat((_,ref (ty,_,_)),_)) = ty
d1273 1
a1273 1
                    |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.EXCON(_)),ref (ty,_,_)),_))::_,_)::_ =>
d1829 1
a1829 1
         |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.CON(_)),ref (ty,_,_)),_))::_,_)::_ =>
d1831 1
a1831 1
         |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.EXCON(_)),ref (ty,_,_)),_))::_,_)::_ =>
@


1.45
log
@Matchvars in special constructors.
@
text
@d3 3
d541 3
d546 1
d553 1
a553 1
                byte::bytes => power(n)+byte::bytes
a1997 3



@


1.44
log
@Oops - had forgotten to turn off show_match.
@
text
@d3 3
d245 1
a245 1
                | SCon2 of string
d440 1
a440 1
                       (mvar',SCon2(scon))::env))
d444 2
a445 2
                       (mvar',SCon2(scon))::env))
                  | env' as (_,SCon2(scon'))::_ =>
d448 12
a459 1
                          ([], env'))
d469 1
a469 1
                 | _ => Crash.impossible "1:make_entry:update_env:match")
d477 1
a477 1
                   | _ => Crash.impossible "3:make_entry:update_env:match"
d511 1
a511 1
                                      | _ => Crash.impossible "4:make_entry:update_env:match"
d516 1
a516 1
                        | _ => Crash.impossible "5:make_entry:update_env:match"
@


1.43
log
@Bindings in Match DEFAULT trees.
@
text
@d3 3
d285 1
a285 1
    val show_match : bool ref = ref(true)
@


1.42
log
@Exhaustiveness and Redundancy Checking Revision.
@
text
@d3 3
d226 1
a226 4
	  generation. Environments are largely duplicated and so a special datatype for them is
	  created to improve efficiency. The aim is that results of searching environments are
	  shared. CONS is the ordinary cons operator; CONS',however, also indicates the result 
	  of searching the environment.
d229 1
a229 1
          and Con2 is the present constructor for which the tree is being built. Scon1 and SCon2 are
d257 1
a257 1
      | DEFAULT of 'env defaultTree ref
d282 1
a282 1
    val show_match : bool ref = ref(false)
d409 1
d413 1
a413 1
         val redundant : bool ref = ref(true)
d1237 1
a1237 1
                    [] => DEFAULT(default)
d1394 4
a1397 3
                   [] => DEFAULT(case default of
                                   ABSENT => Crash.impossible "DEFAULT:constructor_rule:match"
                                 | PRESENT(default) => default)
d1910 4
a1913 1
         | DEFAULT(default) => ["\n"^space_out,unparseDef(Option.SOME1(PRESENT(default)))])
@


1.41
log
@Spurious redundancy Bug Fix by removing side-effects in exhaustiveness checking.
@
text
@d3 3
d228 4
a231 4
	  special constructors and records. Con1 is a collection of already-encountered 
	  constructors and Con2 is the present constructor for which the tree is being built. 
	  Rec is used to establish a correspondence in matchvars between records in default 
	  and non-default trees.
d236 6
a241 12
		 Con1 of ((Ident.SCon list,Ident.LongValId list) Option.option * int 
			    * (Ident.SCon list,Ident.LongValId list) 
                          Option.option * bool) * int
		|Con2 of (Ident.SCon,Ident.LongValId) Option.option * bool
                |Rec of (Ident.Lab * Matchvar) list 
    type entry = Matchvar list * Matchvar Option.opt * ((int * (Ident.SCon list,
					Ident.LongValId list) Option.option) ref,
                                                        constructors) Option.option
    datatype 'entry environment = 
		NIL
	       |CONS of 'entry * 'entry environment
	       |CONS' of 'entry * ('entry environment * 'entry Option.opt ref)
d256 2
a257 1
      | RECORD of DataTypes.Type * Matchvar * (Ident.Lab * Matchvar) list * 'env Tree 
d324 2
d335 12
a346 42
      local
        val member = fn (mvars,_,_) => fn rootvar => Lists.member (rootvar,mvars)
      in
        fun fetch_environment'' rootvar make_entry make_env env = 
	    let fun assign _ nil = ()
		|   assign entry ((result as ref(Option.ABSENT))::envs) = 
				(result := Option.PRESENT(entry);assign entry envs)
		|   assign _ _ = 
			Crash.impossible "assign:fetch_environment'':match"
		fun make_entry' (entry,env) envs = 
		       (assign entry envs;
			(case env of
			  CONS'(_) => CONS(entry,env)
			 | _ => CONS'(entry,(env,ref(Option.ABSENT))),envs))
		fun fetch_environment' NIL envs = 
		  make_entry' (make_entry ([rootvar],Option.ABSENT,
                                           Option.SOME1((0,Option.SOME1(nil)),0)),env) envs
		|   fetch_environment' (CONS'(entry as (_,Option.ABSENT,Option.SOME1(_,0)),
								(envs,result))) env's = 
                     (case !result of 
		       Option.ABSENT => 
			if member entry rootvar then 
				make_entry' (make_entry entry,env) (make_env (result,env's))
		        else fetch_environment' envs (make_env (result,env's))
		      |Option.PRESENT(entry) => make_entry' (entry,env) env's)
		|   fetch_environment' (CONS'(entry,(envs,result))) env's = 
                     (case !result of 
		       Option.ABSENT => if member entry rootvar then 
					make_entry' (entry,env) (make_env (result,env's))
		     	       else fetch_environment' envs (make_env (result,env's))
		      |Option.PRESENT(entry) => make_entry' (entry,env) env's)
                |   fetch_environment' (CONS((entry as (_,
                                             Option.ABSENT,Option.SOME1(_,0))),envs)) env's = 
                     if member entry rootvar then make_entry' (make_entry entry,env) env's
		     else fetch_environment' envs env's
                |   fetch_environment' (CONS(entry,envs)) env's = 
                     if member entry rootvar then make_entry' (entry,env) env's
		     else fetch_environment' envs env's
            in
              fetch_environment' env nil
            end
      end
d352 5
a356 16
      fun Fetch_environment env arity rootvar modify = 
       let fun reassign nil = ()
	   |   reassign ((result as ref(Option.PRESENT(_)))::envs) = 
               (result := Option.ABSENT;reassign envs)
	   |   reassign _ = 
		Crash.impossible "reassign:fetch_environment:match"
	   fun fetch_environment nil env's = (map reassign env's;nil)
           |   fetch_environment (env::envs) env'ss = 
		let val (env,env's) = 
                      modify(env,fetch_environment'' rootvar 
			(fn (mvs,_,Option.SOME1(ref0,_)) => (mvs,Option.ABSENT,arity(ref0))
			 |   _ => Crash.impossible "fetch_environment:match")
			(fn (env,envs) => env::envs))
		in 
			env::fetch_environment envs (env's::env'ss)
		end
d358 1
a358 1
              fetch_environment env nil
d361 7
a367 14
      fun fetch_environment env arity rootvar modify = 
	Fetch_environment env arity rootvar 
		(fn (env,fetch_environment)=> 
			let val (env,env') = fetch_environment env
			in
				(modify(env),env')
			end)
      fun fetch_environment' env arity rootvar = 
	Fetch_environment env arity rootvar 
		(fn ((env,mvars),fetch_environment) => 
			let val (env,env') = fetch_environment env
			in
				((env,mvars),env')
			end)
d369 28
d398 10
a407 2
	filter the list of environments appropriately for this particular constructor;
	update present environments for later exhaustiveness checking
d409 99
a507 108
    fun update_env constructor env = 
       let val make_entry1 = fn con => 
		let infix ===
		in
		 fn (Con,op ===,op :::,Lists_member) => 
                 (fn (entry as (mvars,Option.ABSENT,
                       Option.SOME2(Con1((cons,n,prev,member),arity))),_,make_env) =>
		       if Lists_member (con,prev) then
                         (make_env(entry),
                          if member then NIL
                          else make_env(mvars,Option.ABSENT,Option.SOME2(Con2(Con con,false))))
		       else
			if Lists_member (con,cons) then
                          (make_env(mvars,Option.ABSENT,Option.SOME2(Con1((cons,n,con:::prev,true),arity))),
                           NIL)
			else
                          (make_env(mvars,Option.ABSENT,Option.SOME2(Con1((con:::cons,n+1,con:::prev,false),arity))),
                           make_env(mvars,Option.ABSENT,
                                    Option.SOME2(Con2(Con con,false))))
	  	  |  (entry as (mvs,Option.ABSENT,Option.SOME2(Con2(con',_))),_,make_env) => 
			if con===con' then
                          (make_env(mvs,Option.ABSENT,Option.SOME2(Con2(con',true))),
                           make_env(mvs,Option.ABSENT,Option.SOME2(Con2(con',false))))
			else
                          (make_env(entry), NIL)
		  |  (entry as (_,Option.PRESENT(_),Option.SOME2(Con2(_))),_,make_env) =>
                       (make_env(entry), NIL)
                  |  (entry as (mvars,Option.ABSENT,
                       Option.SOME1((n,prev),arity)),_,make_env) => 
			(if Lists_member (con,prev) then make_env(entry)
			 else make_env(mvars,Option.ABSENT,Option.SOME1((n+1,con:::prev),arity)),
                         make_env(mvars,Option.ABSENT,Option.SOME2(Con2(Con con,false))))
                  |    _ => Crash.impossible "1:update_env:match")
		end
	   val make_entry = 
            case constructor of
	     Option.SOME1(Absyn.SCONpat(scon)) => 
		make_entry1 scon (Option.SOME1,
		  fn (scon,Option.SOME1(scon'))=>scon=scon'
		  |     _ => Crash.impossible "1:make_entry:update_env:match",
		  fn (scon,Option.SOME1(scons))=>Option.SOME1(scon::scons)
		  |     _ => Crash.impossible "2:make_entry:update_env:match",
		  fn (scon,Option.SOME1(scons))=>Lists.member (scon,scons)
		  |     _ => Crash.impossible "3:make_entry:update_env:match")
            |Option.SOME2(Absyn.WILDpat,mvar) => 
                  (fn ((mvars,mv,cons),_,make_env) => (NIL,make_env(mvar::mvars,mv,cons)))
	    | _ => 
		let infix ===
		    val params as (Con,op ===,op :::,Lists_member) = (Option.SOME2,
		  fn (con,Option.SOME2(con'))=>con=con'
		  |     _ => Crash.impossible "4:make_entry:update_env:match",
		  fn (con,Option.SOME2(cons))=>Option.SOME2(con::cons)
		  |  (con,Option.SOME1([]))=>Option.SOME2([con])
		  |     _ => Crash.impossible "5:make_entry:update_env:match",
		  fn (con,Option.SOME2(cons))=>Lists.member (con,cons)
		  |  (_,Option.SOME1(nil))=>false
		  |     _ => Crash.impossible "6:make_entry:update_env:match")
		in
		  case constructor of 
		   Option.SOME1(Absyn.VALpat((con,_),_)) => make_entry1 con params
		  |Option.SOME2(Absyn.APPpat((con,_),_,_,_),mvar) => 
                    (fn (entry as (mvars,Option.ABSENT,
			Option.SOME2(Con1((cons,n,prev,member),arity))),_,make_env) => 
		         if Lists_member (con,prev) then
			  (make_env(entry),
                           if member then NIL
                           else CONS((mvars,Option.PRESENT(mvar),
                                      Option.SOME2(Con2(Con con,false))),
                                     make_env([mvar],Option.ABSENT,
                                              Option.SOME1((0,Option.SOME1(nil)),0))))
		         else
			  if Lists_member (con,cons) then
                            (make_env(mvars,Option.ABSENT,Option.SOME2(Con1((cons,n,con:::prev,true),arity))),
                             NIL)
                          else 
		           (make_env(mvars,Option.ABSENT,Option.SOME2(Con1((con:::cons,n+1,con:::prev,false),arity))),
			    CONS((mvars,Option.PRESENT(mvar),
                                  Option.SOME2(Con2(Con con,false))),
			     make_env([mvar],Option.ABSENT,
                                      Option.SOME1((0,Option.SOME1(nil)),0))))
		     |  (entry as (mvars,mv' as Option.PRESENT(mv),
                          Option.SOME2(Con2(con',_))),env,make_env) => 
			if con===con' then
			(make_env(mvars,mv',Option.SOME2(Con2(con',true))),
			 let val env = 
			      case fetch_environment'' mv (fn entry=>entry) (fn _ => nil) env of
				(CONS'((mvs,mv,cons),_),nil) => make_env(mvar::mvs,mv,cons)
			       |(CONS((mvs,mv,cons),_),nil) => make_env(mvar::mvs,mv,cons)
			       | _ => Crash.impossible "2:update_env:match"
			 in
		             CONS((mvars,mv',Option.SOME2(Con2(con',false))),env)
			 end)
			else (make_env(entry), NIL)
		     |  (entry as (_,Option.ABSENT,Option.SOME2(Con2(_))),_,make_env) => (make_env(entry), NIL)
                     |  (entry as (mvars,Option.ABSENT,
                          Option.SOME1((n,prev),arity)),_,make_env) => 
		        (if Lists_member (con,prev) then make_env(entry)
			 else
                           make_env(mvars,Option.ABSENT,Option.SOME1((n+1,con:::prev),arity)),
                         CONS((mvars,Option.PRESENT(mvar),
                               Option.SOME2(Con2(Con con,false))),
                              make_env([mvar],Option.ABSENT,
                                       Option.SOME1((0,Option.SOME1(nil)),0))))
                        |    _ => Crash.impossible "3:update_env:match")
                  | _ => Crash.impossible "4:update_env:match"
		end
          fun (env,NIL):::(envs,envs') = (env::envs,envs')
           |   (env,env'):::(envs,envs') = (env::envs,env' ::envs')
d509 2
a510 5
          |   update_env (CONS'(entry,env' as (env,ref(Option.ABSENT)))::envs) = 
			make_entry (entry,env,fn entry=>CONS'(entry,env')):::update_env envs
          |   update_env (CONS(entry,env)::envs) = 
			make_entry (entry,env,fn entry=>CONS(entry,env)):::update_env envs
	  |   update_env _ = Crash.impossible "5:update_env:match"
d512 1
a512 1
             update_env env
a514 3
      fun fetch_env (CONS(entry,env)) = (entry,fn entry=>CONS(entry,env))
      |   fetch_env (CONS'(entry,env)) = (entry,fn entry=>CONS'(entry,env))
      |   fetch_env NIL = Crash.impossible "fetch_env:match"
d516 1
a516 1
	  filter environments for inexhaustiveness
d518 1
a518 1
      fun all_constructors_present env lvis ty =
d520 15
a534 2
        fun fetch_missing_constructors (Option.SOME1(_)) = (ty,nil)
          | fetch_missing_constructors (Option.SOME2(cons)) = 
d536 2
a537 2
              val ve = DataTypes.NewMap.domain(#2(Type_Utils.get_valenv ty))
              val cons = map (fn Ident.LONGVALID(_,vi)=>vi) cons
d539 7
a545 1
              (ty,Lists.filterp (fn id=>not(Lists.member(id,cons))) ve)
d548 17
a564 25
        |   all_constructors_present (entry::env) (result as (env',_,missing_cons)) = 
		(case fetch_env entry of 
		  ((mvs,Option.ABSENT,Option.SOME2(Con1((cons,n,_,_),arity))),make_env) => 
			if n=arity then
                           all_constructors_present env result
			else  all_constructors_present env (make_env (mvs,Option.ABSENT,
				Option.SOME2(Con1((cons,n,
                                                   Option.SOME1(nil),false),arity)))::env',false,
                           (fn ()=>fetch_missing_constructors cons)::missing_cons)
		 |((mvs,option,Option.SOME2(Con2(con,already_present))),make_env) => 
		  	if already_present then 
                          all_constructors_present env result
		  	else  all_constructors_present env 
                          (make_env(mvs,option,Option.SOME2(Con2(con,false)))::env',false,
                           case con of
                             Option.SOME2(Ident.LONGVALID(_,con)) => 
                               (fn ()=>(ty,[con]))::missing_cons
                           | _ => (fn ()=>(ty,[]))::missing_cons)
		 |((mvs,Option.ABSENT,Option.SOME1((n,cons),arity)),make_env) => 
		 	if n=arity then all_constructors_present env result
		 	else all_constructors_present env (make_env (mvs,Option.ABSENT,
				Option.SOME2(Con1((lvis,n,
                                              Option.SOME1(nil),false),arity)))::env',false,
                                     (fn ()=>fetch_missing_constructors cons)::missing_cons)
		 | _ => Crash.impossible "all_constructors_present:match")
d1110 4
d1118 1
a1118 1
						env false,
d1203 1
a1203 2
	       val env = fetch_environment env 
                 (fn ref0=>Option.SOME1(ref0,0)) rootvar (fn env=>env)
d1211 1
a1211 1
                          val (env, new_env) = update_env (Option.SOME1(pat)) env
d1213 7
a1219 4
                          Make_tree_list rest
                          ((scon,generate_tree' same_patterns (true,exception_tree,default_tree) new_env)::trees,
                           scon::lvis,
                           env)
d1226 1
a1226 1
                 case  all_constructors_present env (Option.SOME1(lvis)) Type  of
d1235 3
a1237 1
		  SCON(rootvar,trees,default,binding))
d1262 1
a1262 3
	       val env = fetch_environment env 
		  	 (fn ref0=>Option.SOME1(ref0,Type_Utils.get_no_cons Type)) 
                         rootvar (fn env=>env)
d1279 1
a1279 1
                              val (env, new_env) = update_env (Option.SOME1(pat)) env
d1281 8
a1288 6
                              ((lvi,Dummy_MV,
                                Option.SOME1(generate_tree'
                                             same_patterns (true,exception_tree,default_tree) new_env))::trees,
                              boundtrees,
                              lvi::lvis,
                              env)
d1294 1
a1294 1
                                   val (env, new_env) = update_env (Option.SOME1(pat)) env
d1296 8
a1303 6
                                   ((lvi,Dummy_MV,
                                     Option.SOME1(generate_tree'
                                                  same_patterns (true,exception_tree,default_tree) new_env))::trees,
                                   boundtrees,
                                   lvi::lvis,
                                   env)
d1307 1
a1307 1
                                   val (env, new_env) = update_env (Option.SOME1(pat)) env
d1309 10
a1318 8
                                   (tree' := 
                                    Option.SOME1(next_label(),
                                                 generate_tree' same_patterns (true,true,default_tree) new_env);
                                    tree := Option.PRESENT(Option.SOME2(tree',Dummy_MV));
                                    ((lvi,Dummy_MV,Option.SOME2(tree'))::trees,
                                     Option.SOME2(tree',Dummy_MV)::boundtrees,
                                     lvi::lvis,
                                     env))
d1331 1
a1331 1
                              val (env, new_env) = update_env (Option.SOME2(pat,matchvar)) env
d1333 8
a1340 6
                              ((lvi,matchvar,
                                Option.SOME1(generate_tree (matchvar::rootvars)
                                             same_patterns (true,exception_tree,default_tree) new_env))::trees,
                               boundtrees,
                               lvi::lvis,
                               env)
d1347 1
a1347 1
                                   val (env, new_env) = update_env (Option.SOME2(pat,matchvar)) env
d1349 8
a1356 6
                                   ((lvi,matchvar,
                                     Option.SOME1(generate_tree (matchvar::rootvars)
                                                  same_patterns (true,exception_tree,default_tree) new_env))::trees,
                                   boundtrees,
                                   lvi::lvis,
                                   env)
d1361 1
a1361 1
                                   val (env, new_env) = update_env (Option.SOME2(pat,matchvar)) env
d1363 11
a1373 9
                                   (tree' := 
                                    Option.SOME1(next_label(),
                                                 generate_tree (matchvar::rootvars)
                                                 same_patterns (true,true,default_tree) new_env);
                                    tree := Option.PRESENT(Option.SOME2(tree',matchvar));
                                    ((lvi,matchvar,Option.SOME2(tree'))::trees,
                                     Option.SOME2(tree',matchvar)::boundtrees,
                                     lvi::lvis,
                                     env))
d1387 1
a1387 1
                 all_constructors_present env (Option.SOME2(lvis)) Type
d1392 5
a1396 1
		 CONSTRUCTOR(Type,rootvar,trees,Option.SOME1(default),binding@@boundtrees,false))
d1751 2
a1752 3
		         update_record_env' (#2(update_env (Option.SOME2(Absyn.WILDpat,mvar)) 
			(fetch_environment env (fn ref0=>Option.SOME1(ref0,0)) 
							mvar' (fn env=>env))),mvars)
d1766 1
a1766 2
                        (fetch_environment' (update_record_env env (fn env=>(env,nil))) 
                         (fn ref0=>Option.SOME1(ref0,0)) rootvar)
d1774 1
a1774 3
			(map (fn (env,mvars'') => 
			      case fetch_env env of
			       (entry as (mvs,mv,Option.SOME2(Rec(mvars'))),make_env) =>
d1776 1
a1776 1
                                 Option.PRESENT(mvar') => (make_env entry,(mvar,mvar')::mvars'')
d1778 3
a1780 4
				  (make_env (mvs,mv,Option.SOME2(Rec(mvar'::mvars'))),mvars''))
		              |  ((mvs,Option.ABSENT,Option.SOME1(_,0)),make_env) => 
                       	              (make_env(mvs,Option.ABSENT,
                                                Option.SOME2(Rec(mvar'::nil))),mvars'')
d1786 1
a1786 2
			match_matchvars mvars (fetch_environment env 
					(fn ref0=>Option.SOME1(ref0,0)) rootvar 
d1907 2
a1908 1
	     @@ ["\n"] @@ (unparseTree options tr ("  " ^ space_out)))
d1943 1
d1955 1
a1955 1
                              | Option.ABSENT => Option.PRESENT(cons)))))) [NIL] false)
@


1.40
log
@Type function spills for Modules Debugger;
Propagation of exception tree indicators in tree generation.
@
text
@d3 4
d235 2
a236 2
                          Option.option * bool) ref * int
		|Con2 of (Ident.SCon,Ident.LongValId) Option.option * bool ref
d351 1
a351 1
                                           Option.SOME1(ref (0,Option.SOME1(nil)),0)),env) envs
d419 1
a419 1
	update variables for later exhaustiveness checking
d422 1
a422 3
       let fun NIL:::env = env
	   |   x:::env = x::env
	   val make_entry1 = fn con => 
d426 2
a427 2
                 (fn ((mvars,Option.ABSENT,
                       Option.SOME2(Con1(cons' as ref(cons,n,prev,member),_))),_,make_env) =>
d429 3
a431 2
			if member then NIL
			else make_env(mvars,Option.ABSENT,Option.SOME2(Con2(Con con,ref false)))
d434 19
a452 15
                          (cons' := (cons,n,con:::prev,true);NIL)
			else (cons' := (con:::cons,n+1,con:::prev,false);
			      make_env(mvars,Option.ABSENT,
                                       Option.SOME2(Con2(Con con,ref false))))
	  	  |  ((mvs,Option.ABSENT,Option.SOME2(Con2(con',present))),_,make_env) => 
			if con===con' then (present := true;
					  make_env(mvs,Option.ABSENT,
                                                   Option.SOME2(Con2(con',ref false))))
			else NIL
		  |  ((_,Option.PRESENT(_),Option.SOME2(Con2(_))),_,_) => NIL
                  |  ((mvars,Option.ABSENT,
                       Option.SOME1(cons' as ref(n,prev),_)),_,make_env) => 
			(if Lists_member (con,prev) then ()
			 else cons' := (n+1,con:::prev);
			  make_env(mvars,Option.ABSENT,Option.SOME2(Con2(Con con,ref false))))
d466 1
a466 1
                  (fn ((mvars,mv,cons),_,make_env) => make_env(mvar::mvars,mv,cons))
d482 2
a483 2
                    (fn ((mvars,Option.ABSENT,
			Option.SOME2(Con1(cons' as ref(cons,n,prev,member),_))),_,make_env) => 
d485 6
a490 5
			  if member then NIL
			  else CONS((mvars,Option.PRESENT(mvar),
                                     Option.SOME2(Con2(Con con,ref false))),
			     	make_env([mvar],Option.ABSENT,
                                         Option.SOME1(ref (0,Option.SOME1(nil)),0)))
d492 5
a496 3
			  if Lists_member (con,cons) then (cons' := (cons,n,con:::prev,true);NIL)
			  else 
		           (cons' := (con:::cons,n+1,con:::prev,false);
d498 1
a498 1
                                  Option.SOME2(Con2(Con con,ref false))),
d500 3
a502 3
                                      Option.SOME1(ref (0,Option.SOME1(nil)),0))))
		     |  ((mvars,mv' as Option.PRESENT(mv),
                          Option.SOME2(Con2(con',present))),env,make_env) => 
d504 1
a504 1
			(present := true;
d511 1
a511 1
		             CONS((mvars,mv',Option.SOME2(Con2(con',ref false))),env)
d513 12
a524 11
			else NIL
		     |  ((_,Option.ABSENT,Option.SOME2(Con2(_))),_,_) => NIL
                     |  ((mvars,Option.ABSENT,
                          Option.SOME1(cons' as ref(n,prev),_)),_,make_env) => 
		        (if Lists_member (con,prev) then ()
			 else cons' := (n+1,con:::prev);
			    CONS((mvars,Option.PRESENT(mvar),
                                  Option.SOME2(Con2(Con con,ref false))),
				make_env([mvar],Option.ABSENT,
                                         Option.SOME1(ref (0,Option.SOME1(nil)),0))))
                     |    _ => Crash.impossible "3:update_env:match")
d527 3
a529 1
          fun update_env nil = nil
d558 1
a558 2
		  ((mvs,Option.ABSENT,Option.SOME2(Con1(ref(cons,n,_,_),
                                                        arity))),make_env) => 
d562 2
a563 2
				Option.SOME2(Con1(ref(cons,n,
                                           Option.SOME1(nil),false),arity)))::env',false,
d565 3
a567 3
		 |(entry as (_,_,Option.SOME2(Con2(con,already_present))),make_env) => 
		  	if !already_present then 
				(already_present := false;all_constructors_present env result)
d569 1
a569 1
                          (make_env entry::env',false,
d574 1
a574 1
		 |((mvs,Option.ABSENT,Option.SOME1(ref(n,cons),arity)),make_env) => 
d577 1
a577 1
				Option.SOME2(Con1(ref(lvis,n,
d1218 1
a1218 1
               |   Make_tree_list patterns (trees,lvis) = 
d1222 9
a1230 4
		      Absyn.SCONpat scon => Make_tree_list rest 
			((scon,generate_tree' same_patterns (true,exception_tree,default_tree) 
				           (update_env (Option.SOME1(pat)) env))::trees,
                         scon::lvis)
d1234 1
a1234 1
               val (trees,lvis) = Make_tree_list (map (fn pat=>(pat,Option.ABSENT)) patterns) (nil,nil)
d1278 2
a1279 2
               fun Make_tree_list nil (trees,boundtrees,lvis) = (rev trees,rev boundtrees,rev lvis)
               |   Make_tree_list patterns (trees,boundtrees,lvis) = 
d1288 10
a1297 6
                                 ((lvi,Dummy_MV,
                                   Option.SOME1(generate_tree'
                                                same_patterns (true,exception_tree,default_tree) 
                                                (update_env (Option.SOME1(pat)) env)))::trees,
                                 boundtrees,
                                 lvi::lvis)
d1301 10
a1310 6
                                 ((lvi,Dummy_MV,
                                   Option.SOME1(generate_tree'
                                                same_patterns (true,exception_tree,default_tree) 
                                                (update_env (Option.SOME1(pat)) env)))::trees,
                                 boundtrees,
                                 lvi::lvis)
d1312 12
a1323 8
                                 (tree' := 
                                  Option.SOME1(next_label(),
                                               generate_tree' same_patterns (true,true,default_tree) 
                                               (update_env (Option.SOME1(pat)) env));
                                  tree := Option.PRESENT(Option.SOME2(tree',Dummy_MV));
                                  ((lvi,Dummy_MV,Option.SOME2(tree'))::trees,
                                   Option.SOME2(tree',Dummy_MV)::boundtrees,
                                   lvi::lvis))
d1327 2
a1328 1
                                  lvi::lvis)))
d1335 1
d1339 4
a1342 4
                                             same_patterns (true,exception_tree,default_tree) 
                                             (update_env (Option.SOME2(pat,matchvar)) env)))::trees,
                              boundtrees,
                              lvi::lvis)
d1349 1
d1353 1
a1353 2
                                                  same_patterns (true,exception_tree,default_tree) 
                                                  (update_env (Option.SOME2(pat,matchvar)) env)))::trees,
d1355 2
a1356 1
                                   lvi::lvis)
d1361 1
d1366 1
a1366 2
                                                 same_patterns (true,true,default_tree) 
                                                 (update_env (Option.SOME2(pat,matchvar)) env));
d1370 2
a1371 1
                                     lvi::lvis))
d1376 2
a1377 1
                                  lvi::lvis)))
d1381 2
a1382 2
               val (trees,boundtrees,lvis) =
                 Make_tree_list (map (fn pat=>(pat,info())) patterns) (nil,nil,nil)
d1745 1
a1745 1
		         update_record_env' (update_env (Option.SOME2(Absyn.WILDpat,mvar)) 
d1747 1
a1747 1
							mvar' (fn env=>env)),mvars)
@


1.39
log
@Several removes and inserts now possible on redundant patterns.
@
text
@d3 3
d168 2
a169 1
  sharing type AbsynPrint.Absyn.Instance = Types.Datatypes.instance
d243 4
a246 2
        LEAF of Absyn.Exp * int * (Matchvar 
                   * Ident.ValId * (DataTypes.Type * DataTypes.instance ref Option.opt) ref) list
d314 1
d319 2
a320 1
            * (DataTypes.Type * DataTypes.instance ref Option.opt) ref) list)
d1137 1
a1137 1
                           | pattern_type (Absyn.VALpat((_,ref (ty,_)),_)) = ty
d1211 1
a1211 1
			((scon,generate_tree' same_patterns (true,false,default_tree) 
d1241 1
a1241 1
                    |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.EXCON(_)),ref (ty,_)),_))::_,_)::_ =>
d1272 2
a1273 1
                                   Option.SOME1(generate_tree' same_patterns (true,false,default_tree) 
d1281 2
a1282 1
                                   Option.SOME1(generate_tree' same_patterns (true,false,default_tree) 
d1308 1
a1308 1
                                             same_patterns (true,false,default_tree) 
d1321 1
a1321 1
                                                  same_patterns (true,false,default_tree) 
d1759 1
a1759 1
		   generate_tree' patterns (true,false,default_tree) 
d1771 3
a1773 3
         |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.CON(_)),ref (ty,_)),_))::_,_)::_ =>
                                            constructor_rule non_defaults ty
         |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.EXCON(_)),ref (ty,_)),_))::_,_)::_ =>
d1793 1
a1793 1
					(true,false,new_default_tree) env old_default
@


1.38
log
@Pattern Duplication replaces swapping in exception trees.
@
text
@d3 3
d637 1
a637 2
        fun remove _ nil =
            Crash.impossible "remove:generate_tree:match"
d647 1
a647 2
                  fun insert_redundant_pattern (_,nil) =
                      Crash.impossible "1:insert_redundant_pattern:generate_tree:match"
d650 1
a650 2
                        fun insert_redundant_pattern nil =
                          Crash.impossible "2:insert_redundant_pattern:generate_tree:match"
@


1.37
log
@Dynamic pattern-redundancy reporting;
Correct Exception Pattern Matching
@
text
@d3 4
d278 1
a278 1
    |   hd _ = Crash.impossible "hd:generate_tree:match"
d280 1
a280 1
    |   tl _ = Crash.impossible "tl:generate_tree:match"
d328 1
a328 1
			Crash.impossible "assign:fetch_environment'':generate_tree:match"
d372 1
a372 1
		Crash.impossible "reassign:fetch_environment:generate_tree:match"
d378 1
a378 1
			 |   _ => Crash.impossible "fetch_environment:generate_tree:match")
d435 1
a435 1
                  |    _ => Crash.impossible "1:update_env:generate_tree:match")
d442 1
a442 1
		  |     _ => Crash.impossible "1:make_entry:update_env:generate_tree:match",
d444 1
a444 1
		  |     _ => Crash.impossible "2:make_entry:update_env:generate_tree:match",
d446 1
a446 1
		  |     _ => Crash.impossible "3:make_entry:update_env:generate_tree:match")
d453 1
a453 1
		  |     _ => Crash.impossible "4:make_entry:update_env:generate_tree:match",
d456 1
a456 1
		  |     _ => Crash.impossible "5:make_entry:update_env:generate_tree:match",
d459 1
a459 1
		  |     _ => Crash.impossible "6:make_entry:update_env:generate_tree:match")
d488 1
a488 1
			       | _ => Crash.impossible "2:update_env:generate_tree:match"
d502 2
a503 2
                     |    _ => Crash.impossible "3:update_env:generate_tree:match")
                  | _ => Crash.impossible "4:update_env:generate_tree:match"
d510 1
a510 1
	  |   update_env _ = Crash.impossible "5:update_env:generate_tree:match"
d517 1
a517 1
      |   fetch_env NIL = Crash.impossible "fetch_env:generate_tree:match"
d557 1
a557 1
		 | _ => Crash.impossible "all_constructors_present:generate_tree:match")
d626 1
a626 1
				(default as (_,new_default_tree)) env old_default = 
d646 2
a647 2
                    Crash.impossible "1:insert_redundant_pattern:generate_tree:match"
                    | insert_redundant_pattern (n as (n',_),ns) =
d651 5
a655 3
                          | insert_redundant_pattern ((n'',exp)::ns) =
                            if n'=n'' then n::ns
                            else (n'',exp)::insert_redundant_pattern ns
d796 1
a796 1
    |   generate_tree (rootvars' as rootvar::rootvars) patterns (separate,default_tree) env =
d808 17
d944 1
a944 1
            ((_,Absyn.WILDpat)::pats',(exp,env)) => 
d977 85
a1073 17
         fun the_construc pat = 
              case pat of
	       Absyn.APPpat((lvi,_),_,_,_) => lvi
             | Absyn.VALpat((lvi,_),_) => lvi
             | Absyn.SCONpat scon =>
	         let  (* fake a LONGVALID for a SCon. *)
	           fun mkLONGVI s = Ident.LONGVALID
	             (Ident.mkPath [], Ident.VAR (Ident.Symbol.find_symbol s))
	         in
	           (case scon of
	             Ident.INT (s,_)           => mkLONGVI s
	            |Ident.REAL (s,_)          => mkLONGVI s
	            |Ident.STRING s        => mkLONGVI s)
	         end
             | Absyn.TYPEDpat(p,_,_)        => the_construc p
             | Absyn.LAYEREDpat(_,p)      => the_construc p
             | _ => Crash.impossible "the_construc:generate_tree:match"
d1108 1
a1108 1
                                 generate_tree'' generate_tree default (separate,
d1203 1
a1203 1
			((scon,generate_tree' same_patterns (true,default_tree) 
d1264 1
a1264 1
                                   Option.SOME1(generate_tree' same_patterns (true,default_tree) 
d1272 1
a1272 1
                                   Option.SOME1(generate_tree' same_patterns (true,default_tree) 
d1279 1
a1279 1
                                               generate_tree' same_patterns (true,default_tree) 
d1298 1
a1298 1
                                             same_patterns (true,default_tree) 
d1311 1
a1311 1
                                                  same_patterns (true,default_tree) 
d1323 1
a1323 1
                                                 same_patterns (true,default_tree) 
d1749 1
a1749 1
		   generate_tree' patterns (true,default_tree) 
d1783 1
a1783 1
					(true,new_default_tree) env old_default
d1899 1
a1899 1
                 (generate_tree [rootvar]) pats (true,
@


1.36
log
@Removed incorrect assumptions about distinction of exception constructors.
@
text
@d3 3
d181 1
a181 1
        SCON and CONSTRUCTOR each take four arguments - a matchvar, a list of
d185 5
a189 1
          default-trees present in this branch of the match-tree.
d215 1
d229 2
a230 1
	       |CONS' of 'entry * ('entry environment * 'entry Option.opt ref) 
d235 7
a241 3
                    * 'env defaultTree ref * 'env Tree BoundTree Option.opt ref
      | CONSTRUCTOR of DataTypes.Type * Matchvar * (Ident.LongValId * Matchvar * 'env Tree) list 
                          * 'env Default * 'env Tree BoundTree Option.opt ref
d250 16
a265 1
    and 'env Default = PRESENT of 'env defaultTree ref | ABSENT 
d267 1
d274 1
a274 1
    |   hd _ = Crash.impossible "hd:generate_tree:_match.sml"
d276 1
a276 1
    |   tl _ = Crash.impossible "tl:generate_tree:_match.sml"
d301 5
a305 3
    type pattern = ((Matchvar * Ident.LongValId Option.opt) Option.opt * Absyn.Pat) list
                   * ((Absyn.Exp * int) * (Matchvar * Ident.ValId 
                           * (DataTypes.Type * DataTypes.instance ref Option.opt) ref) list)
d324 1
a324 1
			Crash.impossible "assign:fetch_environment'':generate_tree:_match.sml"
d368 1
a368 1
		Crash.impossible "reassign:fetch_environment:generate_tree:_match.sml"
d374 1
a374 1
			 |   _ => Crash.impossible "fetch_environment:generate_tree:_match.sml")
d406 1
a406 1
		let infix ==
d408 1
a408 1
		 fn (Con,op ==,op :::,Lists_member) => 
d415 2
a416 1
			if Lists_member (con,cons) then (cons' := (cons,n,con:::prev,true);NIL)
d421 1
a421 1
			if con==con' then (present := true;
d426 2
a427 1
                  |  ((mvars,Option.ABSENT,Option.SOME1(cons' as ref(n,prev),_)),_,make_env) => 
d431 1
a431 1
                  |    _ => Crash.impossible "1:update_env:generate_tree:_match.sml")
d438 1
a438 1
		  |     _ => Crash.impossible "1:make_entry:update_env:generate_tree:_match.sml",
d440 1
a440 1
		  |     _ => Crash.impossible "2:make_entry:update_env:generate_tree:_match.sml",
d442 1
a442 1
		  |     _ => Crash.impossible "3:make_entry:update_env:generate_tree:_match.sml")
d445 3
a447 3
	    | opt => 
		let infix ==
		    val params as (Con,op ==,op :::,Lists_member) = (Option.SOME2,
d449 1
a449 1
		  |     _ => Crash.impossible "4:make_entry:update_env:generate_tree:_match.sml",
d452 1
a452 1
		  |     _ => Crash.impossible "5:make_entry:update_env:generate_tree:_match.sml",
d455 1
a455 1
		  |     _ => Crash.impossible "6:make_entry:update_env:generate_tree:_match.sml")
d457 1
a457 1
		  case opt of 
d478 1
a478 1
			if con==con' then
d484 1
a484 1
			       | _ => Crash.impossible "2:update_env:generate_tree:_match.sml"
d498 2
a499 2
                     |    _ => Crash.impossible "3:update_env:generate_tree:_match.sml")
                  | _ => Crash.impossible "4:update_env:generate_tree:_match.sml"
d506 1
a506 1
	  |   update_env _ = Crash.impossible "5:update_env:generate_tree:_match.sml"
d513 1
a513 1
      |   fetch_env NIL = Crash.impossible "fetch_env:generate_tree:_match.sml"
d532 2
a533 1
			if n=arity then all_constructors_present env result
d537 1
a537 1
                                        (fn ()=>fetch_missing_constructors cons)::missing_cons)
d553 1
a553 1
		 | _ => Crash.impossible "all_constructors_present:generate_tree:_match.sml")
d558 2
a559 1
    val redundant_patterns : int list ref = ref nil
a570 2
    fun remove _ nil = nil
    |   remove n (m::ns) = if n=m  then ns  else m::remove n ns
d597 24
d628 162
a789 2
    fun generate_tree rootvars ((nil,((exp,n),env))::_) _ _ = 
         (redundant_patterns := remove n (!redundant_patterns);LEAF(exp,n,env))
d872 1
a872 1
                              "Irredundancy'':Irredundancy:generate_tree:match/_match.sml")
d882 1
a882 1
                       Crash.impossible "irredundancy:generate_tree:match/_match.sml"
d890 23
a912 23
               case pattern of
                ((_,Absyn.WILDpat)::pats',(exp,env)) => 
                          swap_patterns (pats'::pats) patterns (pattern::patterns'')
               |((option,Absyn.VALpat((Ident.LONGVALID(_,vi as Ident.VAR _),
                                ty),_))::pats',(exp,env)) => 
                  swap_patterns (pats'::pats) patterns (((option,Absyn.WILDpat)::pats',
                         (exp,(rootvar,vi,ty)::env))::patterns'')
               |((option,Absyn.LAYEREDpat((vi,ty),pat))::pats',(exp,env)) => 
                 swap_patterns pats (((option,pat)::pats',
                                      (exp,(rootvar,vi,ty)::env))::patterns) patterns''
               |((option,Absyn.TYPEDpat(pat,_,_))::pats',env) => 
                 swap_patterns pats (((option,pat)::pats',env)::patterns) patterns''
               |((_,pat)::pats',(_,_)) => 
                  (case irredundancy' pats pats' of 
                    REDUNDANT => swap_patterns pats patterns patterns''
                   |IRREDUNDANT => (nil,(patterns',rev patterns''))
                   |SWAPPABLE => 
                     (case pat of 
                       Absyn.RECORDpat(_,_,ref ty) => 
                         (record := true;record_type := Option.PRESENT(ty))
                      | _ => ();
                       pattern:::swap_patterns pats patterns patterns''))
               | _ => Crash.impossible "swap_patterns:generate_tree:_match.sml"
d946 1
a946 1
           |((_,pat')::_,(_,_)) => 
d952 1
a952 1
           | _ => Crash.impossible "separate_defaults:generate_tree:_match.sml"
d982 1
a982 1
             | _ => Crash.impossible "the_construc:generate_tree:match/_match.sml"
d987 1
a987 1
                | _ =>    Crash.impossible "make_construc:generate_tree:_match.sml"     
d999 1
a999 1
         |   strip _ = Crash.impossible "strip:generate_tree:_match.sml"
d1027 2
a1028 1
	   (** filter patterns with same longvalid
d1030 1
a1030 1
           fun CONsplit add_pat (patterns as ((opt,pat)::_,_)::_) =  
d1032 57
a1088 6
                 val construc_pat = make_construc pat opt 
	         fun insplit [] (p1,p2) = (rev p1, rev p2, pat)
	         |   insplit ((pats as ((opt,p)::pp,tree))::pl) (p1,p2) =
	               if make_construc p opt = construc_pat then   
                             insplit pl ((add_pat p pp,tree)::p1,p2)
	               else   insplit pl (p1,pats::p2)
d1090 1
a1090 1
                      Crash.impossible "insplit:CONsplit:generate_tree:_match.sml"
d1092 1
a1092 1
	              insplit patterns ([],[])
d1095 1
a1095 25
                      Crash.impossible "CONsplit:generate_tree:_match.sml"
	   (** Form a default; 
	       if previously unused (UNBUILT), indicate that it is now used (UNBUILT');
	       indicate that this default-tree is old for future builds
	    **)
           fun MakeDefaultTree 
                (default_tree as ref(UNBUILT(default,binding,env',_))) env = 
                 (default_tree := UNBUILT'(default,binding,env@@env',true);PRESENT(default_tree))
           |   MakeDefaultTree 
                 (default_tree as ref(UNBUILT'(default,binding,env',old_default))) env = 
                    (default_tree := UNBUILT'(default,binding,env@@env',old_default);
                     PRESENT(default_tree))
           |   MakeDefaultTree default_tree _ = PRESENT(default_tree)
	   (** Form a binding, information for the match-tree translator that the default-tree
	       is bound here and so all invocations of it will be in this branch of the 
	       match-tree
	    **)
	   fun make_binding default_tree = 
                          case default_tree of
                            ref(UNBUILT(default,binding,env,old_default)) => 
                            (default_tree := UNBUILT(default,binding,env,true);
                             if old_default then ref(Option.ABSENT) else  binding)
			  | ref(UNBUILT'(_)) => ref(Option.ABSENT)
			  | ref(BUILT(_)) => ref(Option.ABSENT)
                          | ref(ERROR(_)) => ref(Option.ABSENT)
d1101 1
a1101 1
           let val SCONsplit = CONsplit (fn _ => fn pats => pats)
d1108 1
a1108 1
	         let val (same_patterns,rest,pat) = SCONsplit patterns
d1116 1
a1116 1
                                "Make_tree_list:scon_rule:generate_tree:_match.sml")
d1118 1
a1118 1
               val (trees,lvis) = Make_tree_list patterns (nil,nil)
d1122 1
a1122 1
                 |  _ => Crash.impossible "1:scon_rule:generate_tree:_match.sml"
d1126 1
a1126 1
                      | _ => Crash.impossible "2:scon_rule:generate_tree:_match.sml"
d1136 11
a1146 2
           let val CONsplit = CONsplit 
                       (fn pat => fn pats => 
d1149 5
a1153 3
                         | _ => pats)
               val (old_default,default_tree) = new_default_tree defaults
               val binding = make_binding default_tree
d1157 9
a1165 3
               fun Make_tree_list nil (trees,lvis) = (rev trees,rev lvis)
               |   Make_tree_list patterns (trees,lvis) = 
	         let val (same_patterns,rest,pat) = CONsplit patterns
d1169 29
a1197 3
                       Make_tree_list rest ((lvi,Dummy_MV,
			 generate_tree' same_patterns (true,default_tree) 
				(update_env (Option.SOME1(pat)) env))::trees,lvi::lvis)
d1199 44
a1242 6
                      let val matchvar = next_Matchvar()
                      in
                       Make_tree_list rest ((lvi,matchvar,generate_tree (matchvar::rootvars)
                              same_patterns (true,default_tree) 
				(update_env (Option.SOME2(pat,matchvar)) env))::trees,lvi::lvis)
                      end
d1244 1
a1244 1
                                "Make_tree_list:constructor_rule:generate_tree:_match.sml")
d1246 2
a1247 1
               val (trees,lvis) = Make_tree_list patterns (nil,nil)
d1255 1
a1255 1
		 CONSTRUCTOR(Type,rootvar,trees,default,binding))
d1302 1
a1302 1
                                    "record_rule:_match.sml")
d1348 1
a1348 1
                                    "record_rule:_match.sml")
d1385 1
a1385 1
                                  ":record_rule:_match.sml")
d1412 1
a1412 1
                 | _ => Crash.impossible "1:fetch_labelled_patterns:record_rule:_match.sml")
d1415 1
a1415 1
                     Crash.impossible "2:fetch_labelled_patterns:record_rule:_match.sml"
d1427 1
a1427 1
                       Crash.impossible "fetch_nested_labelled_patterns:record_rule:_match.sml"
d1472 1
a1472 1
                             Crash.impossible "1:Split:inner_sort:record_rule:_match.sml"
d1498 1
a1498 1
                             Crash.impossible "2:Split:inner_sort:record_rule:_match.sml"
d1503 1
a1503 1
                     |   split _ = Crash.impossible "split:inner_sort:record_rule:_match.sml"
d1571 1
a1571 1
                             Crash.impossible "reduce:merge:record_rule:generate_tree:_match.sml"
d1578 1
a1578 1
                          Crash.impossible "merge:record_rule:generate_tree:_match.sml"
d1590 1
a1590 1
              |   refer_to_envs _ _ = Crash.impossible "refer_to_envs:_match.sml"
d1614 1
a1614 1
				Crash.impossible "update_record_env:generate_tree:_match.sml"
d1620 1
a1620 1
			Crash.impossible "1:match_matchvars:generate_tree:_match.sml"
d1646 1
a1646 1
				Crash.impossible "2:match_matchvars:generate_tree:_match.sml")
d1686 1
a1686 1
                                      Crash.impossible "1:generate_tree:match/_match.sml"
d1694 1
a1694 1
         | _ => Crash.impossible "2:generate_tree:match/_match.sml"
d1696 79
a1774 2
    |   generate_tree _ _ _ _ = Crash.impossible "3:generate_tree:match/_match.sml"
   in
d1786 1
a1786 1
                       convert pats true (hd redundant_pats + 1::redundant_pats,pats')
d1788 1
a1788 1
                      let val n = hd redundant_pats + 1
d1796 2
a1797 1
                                  (n::redundant_pats,([(Option.ABSENT,pat)],((exp,n),[]))::pats')
d1800 1
a1800 1
                 val (redundant_pats,pats) = convert pats false ([0],[])
d1820 7
a1826 1
             (rootvar,the_tree,!redundant_patterns,!inexhaustive)
a1829 57
      
      (** General purpose routines for printing out the Trees. **)
      fun unparseTree options tree space_out = 
      let
	  fun unparseDef ABSENT = "Absent default"
	  |   unparseDef (PRESENT(ref(BUILT(ref(Option.SOME1(n,tree)))))) = 
               "Present default of "^"'TREE "^MLWorks.Integer.makestring n^"'"
	  |   unparseDef (PRESENT(ref(ERROR(_)))) = 
               "Present default of 'ERROR'"
          |   unparseDef _ = 
                 Crash.impossible "unparseDef:unparseTree:_match.sml"

	fun list_subs [] rest = rest
	  | list_subs ((m, vi, _)::ll) rest =
	    list_subs ll
	    (rest @@ [" '", IdentPrint.printValId options vi, "'/#", 
                     MLWorks.Integer.makestring m])

	fun list_fields [] rest = rest
	  | list_fields ((m, vi)::ll) rest =
	    list_fields ll
	    (rest @@ [" '", IdentPrint.printLab m, "'=#", MLWorks.Integer.makestring vi])

	fun list_scons [] rest = rest
	  | list_scons ((m, vi)::ll) rest =
	    list_scons ll
	     rest @@ ["\n", space_out, "'", IdentPrint.printSCon m,
		     "' =>\n"] @@ unparseTree options vi ("  " ^ space_out)

	fun list_cons [] rest = rest
	  | list_cons ((lvi, mv, tr)::ll) rest =
	    list_cons ll
	     rest @@ ["\n", space_out, "'", IdentPrint.printLongValId options lvi,
		     "' --(#", MLWorks.Integer.makestring mv, ")\n"] 
                  @@ unparseTree options tr ("  " ^ space_out)
        fun print_binding binding = 
              case binding of
               ref(Option.PRESENT(ref(Option.SOME1(n,tr)))) => 
                     "\n"::space_out::"BINDING :"::"'TREE "::MLWorks.Integer.makestring n::"'"
			::" is bound to \n"::unparseTree options tr ("       "^space_out)
              |ref(Option.ABSENT) => nil 
              | _ => Crash.impossible "print_binding:unparseTree:_match.sml"
      in
	(case tree of
	   LEAF (exp,n,ll) =>
	     (list_subs ll [space_out, "LEAF ", 
                         AbsynPrint.unparseExp options exp, " {"]) @@ [" }"]
	 | SCON (mv, ll, def, binding) => 
	     (list_scons ll [space_out, "SCON #", MLWorks.Integer.makestring mv])
	     @@ (("\n"^space_out^unparseDef (PRESENT(def))) ::print_binding binding)
	 | CONSTRUCTOR (_, mv, ll, def,binding) =>
	     (list_cons ll [space_out, "CONSTRUCTOR #", MLWorks.Integer.makestring mv])
	     @@ (("\n"^space_out^unparseDef def) ::print_binding binding)
	 | RECORD (_, mv, ll, tr) => 
	     (list_fields ll [space_out, "RECORD #", MLWorks.Integer.makestring mv])
	     @@ ["\n"] @@ (unparseTree options tr ("  " ^ space_out)))
      end
@


1.35
log
@Added fixity annotations to APPexps and APPpats
@
text
@d3 3
d609 1
a609 3
                                |SWAPPABLE => SWAPPABLE
                                | _ => 
                                 Crash.impossible "Irredundancy:generate_tree:_match.sml")
d653 1
a653 1
                               if name=name' then REDUNDANT else SWAPPABLE
d901 1
a901 1
               fun Make_tree_list nil result = result
@


1.34
log
@Removed an unnecessary map, using domain instead
@
text
@d3 3
d423 1
a423 1
		  |Option.SOME2(Absyn.APPpat((con,_),_,_),mvar) => 
d602 2
a603 2
                       |(Absyn.APPpat((Ident.LONGVALID( _, val_id1),_),arg,_),
                         Absyn.APPpat((Ident.LONGVALID( _, val_id2),_),arg',_)) => 
d750 1
a750 1
	       Absyn.APPpat((lvi,_),_,_) => lvi
d893 1
a893 1
                          Absyn.APPpat(_,newpat,_) => (Option.ABSENT,newpat)::pats
d909 1
a909 1
                    |Absyn.APPpat((lvi,_),_,_) => 
d1108 1
a1108 1
              |   (Absyn.APPpat(_,pat,_)) < (Absyn.APPpat(_,pat',_)) = pat<pat'
d1341 1
a1341 1
         |((_,Absyn.APPpat((_,ref ty),_,_))::_,_)::_ => constructor_rule non_defaults ty
@


1.33
log
@Compilation instances paired in type refs for polymorphic debugger.
@
text
@d3 3
d483 1
a483 1
              val ve = map #1 (DataTypes.NewMap.to_list(#2(Type_Utils.get_valenv ty)))
@


1.32
log
@Added location information to matches
@
text
@d3 3
d146 1
d215 1
a215 1
                   * Ident.ValId * DataTypes.Type ref) list
d265 1
a265 1
                           * DataTypes.Type ref) list)
d1336 1
a1336 1
         |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.CON(_)),ref ty),_))::_,_)::_ =>
d1338 1
a1338 1
         |((_,Absyn.VALpat((Ident.LONGVALID(_,Ident.EXCON(_)),ref ty),_))::_,_)::_ =>
@


1.32.1.1
log
@Fork for bug fixing
@
text
@a2 3
Revision 1.32  1993/08/06  14:40:21  matthew
Added location information to matches

@


1.31
log
@Type information in LEAFs for local and closure variable inspection
in the debugger; structure Option.
@
text
@d3 4
d1372 1
a1372 1
                 |   convert ((pat,exp)::pats) false (redundant_pats,pats') = 
@


1.30
log
@More informative inexhaustiveness reporting
@
text
@d3 3
d112 1
d126 1
d136 1
d146 1
d191 1
a191 3
    datatype 'a option = SOME of 'a | NONE
    datatype ('a,'b) option' = SOME1 of 'a | SOME2 of 'b
    type 'Tree BoundTree = ((int * 'Tree),lvar) option' ref
d193 4
a196 3
		 Con1 of ((Ident.SCon list,Ident.LongValId list) option' * int 
			    * (Ident.SCon list,Ident.LongValId list) option' * bool) ref * int
		|Con2 of (Ident.SCon,Ident.LongValId) option' * bool ref
d198 3
a200 2
    type entry = Matchvar list * Matchvar option * ((int * (Ident.SCon list,
					Ident.LongValId list) option') ref,constructors) option'
d204 1
a204 1
	       |CONS' of 'entry * ('entry environment * 'entry option ref) 
d206 2
a207 1
        LEAF of Absyn.Exp * int * (Matchvar * Ident.ValId * DataTypes.Type) list
d209 1
a209 1
                    * 'env defaultTree ref * 'env Tree BoundTree option ref
d211 1
a211 1
                          * 'env Default * 'env Tree BoundTree option ref
d213 7
a219 6
    and 'env defaultTree = UNBUILT of ('env -> 'env Tree) 
						* 'env Tree BoundTree option ref * 'env * bool
                          |UNBUILT' of ('env -> 'env Tree) 
						* 'env Tree BoundTree option ref * 'env * bool
                     	  |BUILT of 'env Tree BoundTree 
                          |ERROR of (DataTypes.Type * Ident.ValId list) list -> unit
d232 1
a232 1
        so(NONE) and updating environments from them otherwise(SOME(...)).
d237 3
a239 2
                  NONE => continue pat env'
                 |SOME(matchvar,env) => (env := (matchvar,vi,ty)::(!env);continue pat env')
d241 1
a241 1
     fun fetch_pat (Absyn.LAYEREDpat((vi,ref ty),pat)) env = set_env env (vi,ty,pat) fetch_pat
d244 1
a244 1
                                ref ty),_)) env =  
d248 1
a248 1
    (** A pattern during match-compilation will be thus ... . The SOME option paired with
d250 1
a250 1
        opposed to what a NONE option denotes. Such a pattern will have a matchvar already
d255 3
a257 2
    type pattern = ((Matchvar * Ident.LongValId option) option * Absyn.Pat) list
                   * ((Absyn.Exp * int) * (Matchvar * Ident.ValId * DataTypes.Type) list)
d273 2
a274 2
		|   assign entry ((result as ref(NONE))::envs) = 
				(result := SOME(entry);assign entry envs)
d281 1
a281 1
			 | _ => CONS'(entry,(env,ref(NONE))),envs))
d283 3
a285 2
		  make_entry' (make_entry ([rootvar],NONE,SOME1(ref (0,SOME1(nil)),0)),env) envs
		|   fetch_environment' (CONS'(entry as (_,NONE,SOME1(_,0)),
d288 1
a288 1
		       NONE => 
d292 1
a292 1
		      |SOME(entry) => make_entry' (entry,env) env's)
d295 1
a295 1
		       NONE => if member entry rootvar then 
d298 3
a300 2
		      |SOME(entry) => make_entry' (entry,env) env's)
                |   fetch_environment' (CONS((entry as (_,NONE,SOME1(_,0))),envs)) env's = 
d317 2
a318 1
	   |   reassign ((result as ref(SOME(_)))::envs) = (result := NONE;reassign envs)
d325 1
a325 1
			(fn (mvs,_,SOME1(ref0,_)) => (mvs,NONE,arity(ref0))
d361 2
a362 1
                 (fn ((mvars,NONE,SOME2(Con1(cons' as ref(cons,n,prev,member),_))),_,make_env) =>
d365 1
a365 1
			else make_env(mvars,NONE,SOME2(Con2(Con con,ref false)))
d369 3
a371 2
			      make_env(mvars,NONE,SOME2(Con2(Con con,ref false))))
	  	  |  ((mvs,NONE,SOME2(Con2(con',present))),_,make_env) => 
d373 2
a374 1
					  make_env(mvs,NONE,SOME2(Con2(con',ref false))))
d376 2
a377 2
		  |  ((_,SOME(_),SOME2(Con2(_))),_,_) => NIL
                  |  ((mvars,NONE,SOME1(cons' as ref(n,prev),_)),_,make_env) => 
d380 1
a380 1
			  make_env(mvars,NONE,SOME2(Con2(Con con,ref false))))
d385 3
a387 3
	     SOME1(Absyn.SCONpat(scon)) => 
		make_entry1 scon (SOME1,
		  fn (scon,SOME1(scon'))=>scon=scon'
d389 1
a389 1
		  fn (scon,SOME1(scons))=>SOME1(scon::scons)
d391 1
a391 1
		  fn (scon,SOME1(scons))=>Lists.member (scon,scons)
d393 1
a393 1
            |SOME2(Absyn.WILDpat,mvar) => 
d397 2
a398 2
		    val params as (Con,op ==,op :::,Lists_member) = (SOME2,
		  fn (con,SOME2(con'))=>con=con'
d400 2
a401 2
		  fn (con,SOME2(cons))=>SOME2(con::cons)
		  |  (con,SOME1([]))=>SOME2([con])
d403 2
a404 2
		  fn (con,SOME2(cons))=>Lists.member (con,cons)
		  |  (_,SOME1(nil))=>false
d408 4
a411 4
		   SOME1(Absyn.VALpat((con,_),_)) => make_entry1 con params
		  |SOME2(Absyn.APPpat((con,_),_,_),mvar) => 
                    (fn ((mvars,NONE,
			SOME2(Con1(cons' as ref(cons,n,prev,member),_))),_,make_env) => 
d414 4
a417 2
			  else CONS((mvars,SOME(mvar),SOME2(Con2(Con con,ref false))),
			     	make_env([mvar],NONE,SOME1(ref (0,SOME1(nil)),0)))
d422 6
a427 3
			    CONS((mvars,SOME(mvar),SOME2(Con2(Con con,ref false))),
			     make_env([mvar],NONE,SOME1(ref (0,SOME1(nil)),0))))
		     |  ((mvars,mv' as SOME(mv),SOME2(Con2(con',present))),env,make_env) => 
d436 1
a436 1
		             CONS((mvars,mv',SOME2(Con2(con',ref false))),env)
d439 3
a441 2
		     |  ((_,NONE,SOME2(Con2(_))),_,_) => NIL
                     |  ((mvars,NONE,SOME1(cons' as ref(n,prev),_)),_,make_env) => 
d444 4
a447 2
			    CONS((mvars,SOME(mvar),SOME2(Con2(Con con,ref false))),
				make_env([mvar],NONE,SOME1(ref (0,SOME1(nil)),0))))
d452 1
a452 1
          |   update_env (CONS'(entry,env' as (env,ref(NONE)))::envs) = 
d469 2
a470 2
        fun fetch_missing_constructors (SOME1(_)) = (ty,nil)
          | fetch_missing_constructors (SOME2(cons)) = 
d472 1
a472 2
              val ve = map #1 (DataTypes.NewMap.to_list(#2(Type_Utils.get_valenv 
                                         (Type_Utils.get_cons_type (Types.the_type(ty))))))
d480 2
a481 1
		  ((mvs,NONE,SOME2(Con1(ref(cons,n,_,_),arity))),make_env) => 
d483 3
a485 2
			else  all_constructors_present env (make_env (mvs,NONE,
				SOME2(Con1(ref(cons,n,SOME1(nil),false),arity)))::env',false,
d487 1
a487 1
		 |(entry as (_,_,SOME2(Con2(con,already_present))),make_env) => 
d490 2
a491 1
		  	else  all_constructors_present env (make_env entry::env',false,
d493 1
a493 1
                             SOME2(Ident.LONGVALID(_,con)) => 
d495 2
a496 2
                           | _ => missing_cons)
		 |((mvs,NONE,SOME1(ref(n,cons),arity)),make_env) => 
d498 3
a500 2
		 	else all_constructors_present env (make_env (mvs,NONE,
				SOME2(Con1(ref(lvis,n,SOME1(nil),false),arity)))::env',false,
d508 2
a509 2
    val inexhaustive : (DataTypes.Type * Ident.ValId list) list option ref = 
      ref(NONE)
d516 1
a516 1
    val record_type : DataTypes.Type option ref = ref NONE
d537 1
a537 1
                          ref(UNBUILT'(make_tree,binding,env,_)) => 
d539 1
a539 1
                      		val boundtree = ref(SOME1(next_label(),tree))
d541 1
a541 1
                              (binding := SOME(boundtree);
d662 1
a662 1
                                ref ty),_))::pats',(exp,env)) => 
d665 1
a665 1
               |((option,Absyn.LAYEREDpat((vi,ref ty),pat))::pats',(exp,env)) => 
d676 2
a677 1
                       Absyn.RECORDpat(_,_,ref ty) => (record := true;record_type := SOME(ty))
d699 1
a699 1
                                ref ty),_))::pats',(exp,env)) => 
d709 1
a709 1
           |((option,Absyn.LAYEREDpat((vi,ref ty),pat))::pats',(exp,env)) => 
d716 2
a717 1
                   Absyn.RECORDpat(_,_,ref ty) => (record := true;record_type := SOME(ty))
d728 3
a730 2
                 NONE => generate_tree rootvars patterns default env
                |SOME(matchvar,_) => generate_tree (matchvar::rootvars) patterns default env)
d753 2
a754 2
                 NONE => the_construc pat
                |SOME(_,SOME(construc)) => construc
d784 2
a785 1
                     ref(UNBUILT(fn env=> generate_tree'' generate_tree default (separate,
d787 2
a788 1
						env false,ref NONE,nil,false))
d830 1
a830 1
                           ref(UNBUILT(default,binding,env,old_default)) => 
d832 4
a835 4
                             if old_default then ref(NONE) else  binding)
			  |ref(UNBUILT'(_)) => ref(NONE)
			  |ref(BUILT(_)) => ref(NONE)
                          |ref(ERROR(_)) => ref(NONE)
d844 2
a845 1
	       val env = fetch_environment env (fn ref0=>SOME1(ref0,0)) rootvar (fn env=>env)
d853 2
a854 1
				           (update_env (SOME1(pat)) env))::trees,scon::lvis)
d859 3
a861 3
	       val (env,missing_constructors) = 
                 case  all_constructors_present env (SOME1(lvis)) Type of
                   (env,false,missing_constructors) => (env,missing_constructors)
d868 1
a868 1
                 (make_default default_tree old_default missing_constructors;
d879 1
a879 1
                          Absyn.APPpat(_,newpat,_) => (NONE,newpat)::pats
d884 2
a885 1
		  	 (fn ref0=>SOME1(ref0,Type_Utils.get_no_cons Type)) rootvar (fn env=>env)
d894 1
a894 1
				(update_env (SOME1(pat)) env))::trees,lvi::lvis)
d900 1
a900 1
				(update_env (SOME2(pat,matchvar)) env))::trees,lvi::lvis)
d906 1
d908 1
a908 1
                 all_constructors_present env (SOME2(lvis)) Type
d913 1
a913 2
		 CONSTRUCTOR(Type_Utils.get_cons_type(Types.the_type(Type)),
                             rootvar,trees,default,binding))
d944 1
a944 1
               |   fetch_labelled_patterns (((NONE,pattern),env)::rest) patterns =
d951 1
a951 1
                          (record,((NONE,Absyn.WILDpat),env)::pats)
d954 1
a954 1
                          (record,((NONE,Absyn.WILDpat),env)::pats)
d962 1
a962 1
               (case (if toplevel then fetch_pat pattern (SOME(matchvar,env))
d974 1
a974 1
                         case fetch_pat pat (SOME(matchvar,env)) of 
d996 2
a997 1
                                       ((NONE,Absyn.WILDpat),env)::add_labelled_wildpat rest
d1008 1
a1008 1
                          ([([(lab,matchvar,pat_type)],((NONE,pat),env)
d1016 2
a1017 1
                          ([([(lab,matchvar,pat_type)],((NONE,pat),env)::pats)],[PRESENT])
d1026 1
a1026 1
                                 ((NONE,pat),env)::pats)::patterns,
d1037 1
a1037 1
                                 ((NONE,pat),env)::pats)::patterns,
d1055 2
a1056 1
                            fetch_labelled_patterns (((NONE,Absyn.WILDpat),env)::rest) patterns 
d1066 1
a1066 1
                          nil => [(nil,[((NONE,Absyn.WILDpat),env)])]
d1068 1
a1068 1
                            [(nil,((NONE,Absyn.WILDpat),env)::entry)]
d1105 1
a1105 1
                     fun split (((NONE,pat),env)::rest) = 
d1108 1
a1108 1
                           |   Split (((NONE,pattern''),env)::rest) 
d1112 1
a1112 1
                                ((SOME(matchvar,NONE),pattern''),env)
d1117 2
a1118 1
                                    ((SOME(matchvar,SOME(construc_pattern)),pattern''),env)
d1134 1
a1134 1
                               ((SOME(matchvar,NONE),pat),env):::(split rest)
d1138 2
a1139 1
                                ((SOME(matchvar,SOME(construc_pattern)),pat),env)
d1143 3
a1145 2
                     |   split ((pattern as (SOME(_,
                                               SOME(construc_pattern)),pat),env)::rest) =
d1148 2
a1149 2
                           |   Split ((pattern as ((SOME(_,
                                        SOME(construc_pattern)),_),env))::rest) 
d1178 1
a1178 1
                            ((NONE,Absyn.WILDpat),_) => score
d1268 2
a1269 2
		         update_record_env' (update_env (SOME2(Absyn.WILDpat,mvar)) 
			(fetch_environment env (fn ref0=>SOME1(ref0,0)) 
d1283 3
a1285 2
		    	match_matchvars mvars (fetch_environment' (update_record_env env 
					(fn env=>(env,nil))) (fn ref0=>SOME1(ref0,0)) rootvar)
d1287 1
a1287 1
                      let fun fetch_mvar nil = NONE
d1289 1
a1289 1
                                 if Ident.lab_eq (lab,lab') then SOME(mvar')
d1295 1
a1295 1
			       (entry as (mvs,mv,SOME2(Rec(mvars'))),make_env) =>
d1297 6
a1302 5
                                 SOME(mvar') => (make_env entry,(mvar,mvar')::mvars'')
                                |NONE => 
				  (make_env (mvs,mv,SOME2(Rec(mvar'::mvars'))),mvars''))
		              |  ((mvs,NONE,SOME1(_,0)),make_env) => 
                       	              (make_env(mvs,NONE,SOME2(Rec(mvar'::nil))),mvars'')
d1309 2
a1310 1
					(fn ref0=>SOME1(ref0,0)) rootvar (fn env=>(env,nil)))
d1332 1
a1332 1
         |((_,Absyn.SCONpat(pat))::_,_)::_ =>   
d1343 3
a1345 2
                                    NONE => Crash.impossible "1:generate_tree:match/_match.sml"
                                   |SOME(ty) => ty))
d1371 1
a1371 1
                            case fetch_pat pat NONE of
d1377 1
a1377 1
                                  (n::redundant_pats,([(NONE,pat)],((exp,n),[]))::pats')
d1386 1
a1386 1
                 inexhaustive := NONE;
d1396 3
a1398 3
                                SOME(cons') => 
                                  SOME(cons'@@cons)
                              | NONE => SOME(cons)))))) [NIL] false)
d1409 1
a1409 1
	  |   unparseDef (PRESENT(ref(BUILT(ref(SOME1(n,tree)))))) = 
d1419 2
a1420 1
	    (rest @@ [" '", IdentPrint.printValId options vi, "'/#", MLWorks.Integer.makestring m])
d1441 1
a1441 1
               ref(SOME(ref(SOME1(n,tr)))) => 
d1444 1
a1444 1
              |ref(NONE) => nil 
@


1.29
log
@Removed integer parameter
@
text
@d3 3
d199 1
a199 2
        ERROR
      | LEAF of Absyn.Exp * int * (Matchvar * Ident.ValId * DataTypes.Type) list
d210 1
d442 1
a442 1
      fun all_constructors_present env lvis =
d444 9
d454 1
a454 1
        |   all_constructors_present (entry::env) (result as (env',_)) = 
d459 3
a461 2
				SOME2(Con1(ref(cons,n,SOME1(nil),false),arity)))::env',false)
		 |(entry as (_,_,SOME2(Con2(_,already_present))),make_env) => 
d464 6
a469 2
		  	else  all_constructors_present env (make_env entry::env',false)
		 |((mvs,NONE,SOME1(ref(n,_),arity)),make_env) => 
d472 2
a473 1
				SOME2(Con1(ref(lvis,n,SOME1(nil),false),arity)))::env',false)
d476 1
a476 1
		all_constructors_present env (nil,true)
d480 2
a481 1
    val inexhaustive : bool ref = ref false
d493 6
a498 1
    (** default-tree has outlived its usefulness;
d501 6
a506 2
    fun make_default new_default_tree old_default = 
                         if old_default then ()
d516 2
d523 1
a523 1
			(make_default new_default_tree old_default;
d802 1
d807 1
a807 1
          fun scon_rule patterns =
d824 4
a827 3
	       val env = case  all_constructors_present env (SOME1(lvis))  of
			  (env,false) => env
			 |  _ => Crash.impossible "1:scon_rule:generate_tree:_match.sml"
d833 1
a833 1
                 (make_default default_tree old_default;
d870 2
a871 1
	       val (env,all_constructors_present) = all_constructors_present env (SOME2(lvis)) 
d875 1
a875 1
                (make_default default_tree old_default;
d1287 6
a1292 1
         |((_,Absyn.SCONpat(_))::_,_)::_ =>  scon_rule non_defaults 
d1339 2
a1340 1
		(label_count := 0;redundant_patterns := redundant_pats; inexhaustive := false;
d1343 10
a1352 2
                   ref(UNBUILT(fn _ => 
		    (inexhaustive := true;ERROR),ref NONE,nil,false))) [NIL] false)
d1365 2
d1401 1
a1401 2
	   ERROR => [space_out, "ERROR"]
	 | LEAF (exp,n,ll) =>
@


1.28
log
@Options & Info changes
Absyn changes
@
text
@d3 4
a101 1
require "../utils/integer";
a116 1
  structure Integer : INTEGER
d1317 1
a1317 1
               "Present default of "^"'TREE "^Integer.makestring n^"'"
d1324 1
a1324 1
	    (rest @@ [" '", IdentPrint.printValId options vi, "'/#", Integer.makestring m])
d1329 1
a1329 1
	    (rest @@ [" '", IdentPrint.printLab m, "'=#", Integer.makestring vi])
d1341 1
a1341 1
		     "' --(#", Integer.makestring mv, ")\n"] 
d1346 1
a1346 1
                     "\n"::space_out::"BINDING :"::"'TREE "::Integer.makestring n::"'"
d1357 1
a1357 1
	     (list_scons ll [space_out, "SCON #", Integer.makestring mv])
d1360 1
a1360 1
	     (list_cons ll [space_out, "CONSTRUCTOR #", Integer.makestring mv])
d1363 1
a1363 1
	     (list_fields ll [space_out, "RECORD #", Integer.makestring mv])
@


1.27
log
@re-coded a function to remove recursive handle
@
text
@d3 3
d123 6
a128 3
  sharing Types.Datatypes = AbsynPrint.Absyn.Datatypes = Type_Utils.DataTypes
  sharing AbsynPrint.Absyn.Datatypes.Ident = Types.Datatypes.Ident = IdentPrint.Ident
  sharing AbsynPrint.Info = IdentPrint.Info = Types.Info
d134 1
a134 1
    structure Info = IdentPrint.Info
@


1.26
log
@Ensured that the type in a CONSTRUCTOR node is the actual datatype,
not just the type of the constructor.
@
text
@d3 4
d836 1
a836 1
			     rootvar,trees,default,binding))
d888 1
a888 2
                  let exception no_entries
		      fun Fetch_labelled_patterns pats patterns = 
d975 4
a978 2
                          (_,nil) => raise no_entries
                         |patterns => patterns
d981 1
a981 4
                     fetch_labelled_patterns rest 
                        (add_dummy_patterns (Fetch_labelled_patterns pats patterns))
                      handle no_entries => 
                         fetch_labelled_patterns (((NONE,Absyn.WILDpat),env)::rest) patterns 
@


1.25
log
@deleted output message
@
text
@d3 3
d831 2
a832 1
		 CONSTRUCTOR(Types.the_type(Type),rootvar,trees,default,binding))
@


1.24
log
@fixed bug in RCS log
@
text
@d3 3
d1293 1
a1293 2
             (output (std_out,"\n tree built\n");
              (rootvar,the_tree,!redundant_patterns,!inexhaustive))
@


1.23
log
@restored RCS log
@
text
@d3 3
d7 1
a7 1
added $Log$ for RCS
@


1.22
log
@added $Log$ for RCS
@
text
@d2 76
a77 1
$Log$
@


1.21
log
@completely rewritten; improvements are :
1. chooses better random order for pattern matching in all cases
2. passes on vital information to the match-tree-translator thereby greatly improving
   the efficiency of the translator
3. takes advantage of the swappability of patterns but avoids using a swap-table
4. builds an optimum match-tree by doing much more at build-time
@
text
@d2 1
a2 7
The new Match Compiler :
 improvements on the former compiler :
1. chooses better random order for pattern matching in all cases 
2. passes on vital information to the match-tree-translator thereby greatly improving 
   the efficiency of the translator
3. takes advantage of the swappability of patterns but avoids using a swap-table
4. builds an optimum match-tree by doing much more at build-time
@


1.20
log
@Removed polymorphic equality on SCONs
@
text
@a0 1
(* _match.sml the functor *)
d2 7
a8 3
$Log: _match.sml,v $
Revision 1.19  1992/12/17  18:19:07  matthew
Changed int and real scons to carry a location around
d10 1
a10 60
Revision 1.18  1992/12/08  18:34:51  jont
Removed a number of duplicated signatures and structures

Revision 1.17  1992/11/26  12:35:11  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.16  1992/11/04  15:28:35  jont
Changes to allow IntNewMap to be used on MatchVar

Revision 1.15  1992/10/28  10:24:30  jont
Changed to use less than functions for maps.

Revision 1.14  1992/09/30  10:09:15  clive
A type constraint was missing

Revision 1.13  1992/09/25  16:07:14  clive
Allowed the compiler to change the order of the clauses if it could prove them to be disjoint
 Allowed the system to choose the order for looking at tuple elements (used to be left to right)

Revision 1.12  1992/09/08  18:19:03  matthew
Changes to absyn

Revision 1.11  1992/08/19  16:12:18  davidt
Took out various redundant structure arguments.

Revision 1.10  1992/07/23  16:35:40  matthew
Fixed a problem with redundancy checking and record patterns

Revision 1.9  1992/07/22  13:40:34  matthew
Last version has redundancy checking commented out.  This is the real thing.

Revision 1.8  1992/07/22  11:27:14  matthew
Changed interface to match compiler to for passing back of redundancy and exhaustiveness information

Revision 1.7  1992/03/23  11:22:47  jont
Changed length for Lists.length

Revision 1.6  1992/01/23  14:02:35  jont
Added type_utils parameter

Revision 1.5  1992/01/07  16:56:50  colin
updated code for finding out number of constructors to look at
length of domain of constructor environment. (tyname_id no longer has
no_of_cons field)

Revision 1.4  1991/11/27  12:47:06  jont
Changed references to Match_utils.Qsort to Lists.qsort

Revision 1.3  91/11/21  16:33:28  jont
Added copyright message

Revision 1.2  91/06/24  14:03:20  colin
Changed match tree to give LongValIds rather than ValIds in CONSTRUCTOR
nodes - needed to code generate longexcons where the path must be kept

Revision 1.1  91/06/07  11:06:16  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
a17 1
require "../utils/intnewmap";
a21 1
require "match_utils";
a25 4
    Last updated : Tue Jan 22 11:37:48 1991
    
    Does no checking of redundancy/exhaustivness, except as found in
    the variable-rule (by trivial inspection.)
a30 1
  structure Print : PRINT
a31 2
  structure MatchMap : INTNEWMAP
  structure LabelCounter : COUNTER
d37 1
a37 2
  structure Match_Utils : MATCH_UTILS
		 
d39 1
a39 1
  sharing Types.Datatypes.Ident = IdentPrint.Ident
a45 2
    structure NewMap = DataTypes.NewMap
    structure MatchMap = MatchMap
a47 155
(** For constructor types, return something that can be tested for
    equality easily.  In this case a LONGVALID will do nicely, but
    SCON's don't have one, so we construct a LONGVALID for them.
**)
    fun The_construc pat =
      case pat of
	Absyn.APPpat ((lvi, _), _,_)   => lvi
      | Absyn.VALpat ((lvi, _),_)        => lvi
      | Absyn.SCONpat scon           =>
	  let  (* fake a LONGVALID for a SCon. *)
	    fun mkLONGVI s = Ident.LONGVALID
	      (Ident.mkPath [], Ident.VAR (Ident.Symbol.find_symbol s))
	  in
	    (case scon of
	       Ident.INT (s,_)           => mkLONGVI s
	     | Ident.REAL (s,_)          => mkLONGVI s
	     | Ident.STRING s        => mkLONGVI s)
	  end
      | Absyn.TYPEDpat (p, _,_)        => The_construc p
      | Absyn.LAYEREDpat (_, p)      => The_construc p
      | _ => Crash.impossible "Not a CONstructor, The_construc expected one"
	      
(** Return true/false depending on whether the pattern is a
    constructor. **)
    fun is_constructor_pat pat =
      case pat of
	Absyn.WILDpat            => false
      | Absyn.SCONpat _          => true
      | Absyn.APPpat _           => true
      | Absyn.RECORDpat _        => false
      | Absyn.TYPEDpat (p, _,_)    => is_constructor_pat p
      | Absyn.LAYEREDpat (_, p)  => is_constructor_pat p
      | Absyn.VALpat ((Ident.LONGVALID (_, vi), _),_) =>
	  (case vi of
	     Ident.VAR _   => false
	   | Ident.CON _   => true
	   | Ident.EXCON _ => true)

(** Return true/false depending on whether the pattern is a
    variable (or wild-pattern). **)
    fun is_variable_pat pat =
      case pat of
	Absyn.WILDpat            => true
      | Absyn.SCONpat _          => false
      | Absyn.APPpat _           => false
      | Absyn.RECORDpat _        => false
      | Absyn.TYPEDpat (p, _,_)    => is_variable_pat p
      | Absyn.LAYEREDpat (_, p)  => is_variable_pat p
      | Absyn.VALpat ((Ident.LONGVALID (_, vi), _),_) =>
	  (case vi of
	     Ident.VAR _   => true
	   | Ident.CON _   => false
	   | Ident.EXCON _ => false)

(** Extract any type info present from the heads of a
 list of list of patterns **)
    fun get_type all =
      let
	fun get_t (((pat::_), _)::rest) =
	  let
	    fun f_t (Absyn.VALpat ((_, ref ty),_))        = ty
	      | f_t (Absyn.APPpat ((_, ref ty), _,_))   = ty
	      | f_t (Absyn.RECORDpat (_, _, ref ty))  = ty
	      | f_t (Absyn.LAYEREDpat ((_, ref ty), _))= ty
	      | f_t (Absyn.TYPEDpat (p, _,_))           = f_t p
	      | f_t _                                 = get_t rest
	  in
	    f_t pat
	  end
	  | get_t _ = Crash.impossible "No pattern to get_type"
      in
	Types.the_type (get_t all)
      end
	  
(** Remove all WILDpats from a record, and make the record flex if we
    found any.  Also follow TYPEDpats to give the pattern they point
    to. **)
    fun make_flex (Absyn.RECORDpat (ll, bool, _)) =
      let
	fun rem_wild [] rest bool = (rest, bool)
	  | rem_wild ((head as (lab, pat))::ll) rest bool =
	    (case pat of
	       Absyn.WILDpat          => rem_wild ll rest true
	     | Absyn.TYPEDpat (p, _,_)  => rem_wild ((lab, p)::ll) rest bool
	     | _                      => rem_wild ll (head::rest) bool)
      in
	rem_wild ll [] bool
      end
      | make_flex _ =
	Crash.impossible "Not a RECORD pattern in make_flex_record"

(** Call make_flex on a list of patterns. **)
    fun make_flex_list [] rest = rev rest
      | make_flex_list (([], _)::_) _ =
	Crash.impossible "Empty pattern found but RECORD expected"
      | make_flex_list (((head::_), _)::more) rest =
	let
	  val fields = make_flex head
	in
	  make_flex_list more (fields::rest)
	end

(** Add WILDpats to a record, for all fields that are needed.   Only do
    this if the record is a flex. **)
    fun make_rigid (fields, false) _ = fields
      | make_rigid (fields, _) needed =
	let

(** Add a single label to the list of (label * pattern)s. **)
	  fun add_to first [] rest = ((first, Absyn.WILDpat)::rest)
	    | add_to first (fields as ((head as (one, _))::more)) rest =
	      if first = one then
		(fields @@ rest)
	      else
		add_to first more (head::rest)

(** Add a list of fields to the (label * pattern) list. **)
	  fun add_field [] rest = rest
	    | add_field (first::more) rest =
	      add_field more (add_to first rest [])

	in
	  add_field needed fields
	end

(** Apply make_rigid to a list of patterns.  The first argument is a
    sort function to be applied to the list of fields. **)
    fun make_rigid_list do_sort all needed =
      let
	fun internal [] rest = rev rest
	  | internal (head::tail) rest =
	    internal tail ((do_sort (make_rigid head needed))::rest)
      in
	internal all []
      end

(** From a list of (labels * 'a) generate a list of labels **)
    fun make_labels [] rest = rest
      | make_labels ((lab, _)::ll) rest =
	make_labels ll (lab::rest)

(** Find the list of needed labels, there are two ways:
    1. Find a non-flex record, so this has ALL the records in it.
    2. Find the union of all the labels used in the flex records.
**)
    fun find_needed_labels [] rest = rest
      | find_needed_labels ((head, false)::_) _ = make_labels head []
      | find_needed_labels ((head, _)::more) rest =
	find_needed_labels more (Match_Utils.union_lists rest
				 (make_labels head []))

(** End of 'library' routines, now start the real part of the match
    compiler.  **)


a48 2
    Labels, are unique in their first field, and the second, (a ref)
    tells how many times they appear in the match tree.
d51 1
a51 1
    type Label = (int * int ref)
d56 51
a106 106
    fun label_number(x,_) = x 
    fun referenced_only_once(_, ref 1) = true
      | referenced_only_once _ = false

(** Various things that need setting up **)
    val do_debug = ref false
    val do_reorder = ref true

(** if do_debug is true, then output a message to the std_out **)
    val write = Print.print
    fun print the_list = (map write the_list; ())

    fun debug str =
      if (!do_debug) then
	print str
      else
	()

(** Define a VarMatch.  It is either just a Matchvar, or a list of
    VarMatch.

    The VarMatch data type represents the structure of the match
    variables at a given stage of the pattern match.  This corresponds
    roughly to the structure of the pattern.  We also define routines
    for handling these structures, extracting values, removing and
    adding sections.
**)
    datatype VarMatch =
      S of Matchvar |
      D of VarMatch list

(** Get the matchvars with the first one missing.
    Scan the structure, depth first, removing the first
    object of type (S m) that we find.  **)
    fun get_NMatchvar (all as (S _)) = all
      | get_NMatchvar (D mm) =
	let
	  fun inner [] = ([], true)
	    | inner [ S m ] = ([], false)
	    | inner [ D mm ] =
	      let
		val (foo, bool) = inner mm
	      in
		(case foo of
		   [] => ([], bool)
		 | _  => ([ D foo ], bool))
	      end
	    | inner (m::mm) =
	      let
		val foo = inner [ m ]
	      in
		(case foo of
		   ([], true) => inner mm
		 | ([], _) => (mm, false)
		 | (it, _) => ((it @@ mm), false))
	      end
	  val (done, _) = inner mm
	in
	  D done
	end

(** Get the first actual Matchvar from a VarMatch structure
    We follow the structure until we find the first (S m) value **)
    fun get_SMatchvar (S m) = m   (* just what we want *)
      | get_SMatchvar (D mm) =
	let
	  fun inner [] = Crash.impossible "Missing matchvar in get_SMatchvar"
	    | inner ((S m)::_) = m
	    | inner ((D m)::more) = inner (m @@ more)
	in
	  inner mm
	end

(** Replace the topmost innermost matchvars with the one passed, this
    basically does the same as get_NMatchvar to find the position, them
    replaces it with the value that we were passed. **)
    fun replace_SMatchvar (S _) mat = mat
      | replace_SMatchvar (D mm) mat =
	let
	  fun inner [] = []
	    | inner [ S _ ] = [ mat ]
	    | inner [ D mm ] =
	      let
		val foo = inner mm
	      in
		(case foo of
		   [] => []
		 | _  => [ D foo ])
	      end
	    | inner (m::mm) =
	      let
		val foo = inner [ m ]
	      in
		(case foo of
		   [] => inner mm
		 | it => (it @@ mm))
	      end
	in
	  D (inner mm)
	end

(** Define the datatype 'Tree' (the type we return.)  This defines a
    decision tree to allow the efficient determining of which pattern a
    value matches, and therefore which expression to execute.  **)
    datatype Tree =
      ERROR
d108 15
a122 41
      | SCON of Matchvar * (Ident.SCon * Tree) list * Default
      | CONSTRUCTOR of DataTypes.Type * Matchvar *
	(Ident.LongValId * Matchvar * Tree) list * Default
      | RECORD of DataTypes.Type * Matchvar * (Ident.Lab * Matchvar) list * Tree
      | LABEL of Label * Tree
      | GOTO of Label

    and Default = PRESENT of Tree | ABSENT

(* redundancy checking *)
(* need this when two matchvars are identified *)
(* could do it on the fly with a mapping *)
(*
fun subst_matchvars(bindings,tree) =
  let
    fun subst1 mv =
      Lists.assoc(mv,bindings) handle Lists.Assoc => mv
    fun subst ERROR = ERROR
      | subst (LEAF(exp,n,bindinglist)) =
        LEAF(exp,n,(subst_in_bindinglist bindinglist))
      | subst (SCON(mv,cases,default)) =
        SCON(subst1 mv,subst_in_scon_cases cases,subst_default default)
      | subst (CONSTRUCTOR (ty,mv,cases,default)) =
        CONSTRUCTOR(ty,subst1 mv,subst_in_cons_cases cases,subst_default default)
      | subst (RECORD (ty,mv,labels,tree)) =
        RECORD (ty,subst1 mv,labels, subst tree)
      | subst (LABEL(lab,tree)) =
        LABEL(lab,subst tree)
      | subst (x as GOTO lab) = x
    and subst_in_bindinglist bindinglist =
      map (fn (mv,valid,ty) => (subst1 mv,valid,ty)) bindinglist
    and subst_in_scon_cases cases =
      map (fn (scon,tree) => (scon,subst tree)) cases
    and subst_in_cons_cases cases =
      map (fn (valid,matchvar,tree) => (valid,matchvar,subst tree)) cases
    and subst_default (PRESENT tree) = PRESENT(subst tree)
      | subst_default ABSENT = ABSENT
  in
    subst tree
  end
*)
d124 299
a422 67
fun find_labels (tree) =
  let
    val lablist = ref []
    fun find ERROR = ()
      | find (LEAF(exp,n,bindinglist)) = ()
      | find (SCON(mv,cases,default)) =
        (find_in_scon_cases cases;
         find_default default)
      | find (CONSTRUCTOR (ty,mv,cases,default)) =
        (find_in_cons_cases cases;
         find_default default)
      | find (RECORD (ty,mv,labels,tree)) =
        find tree
      | find (LABEL(x as (lab,tree))) =
        (lablist := x :: (!lablist); find tree)
      | find (x as GOTO lab) = ()
    and find_in_scon_cases cases =
      (map (fn (scon,tree) => find tree) cases,())
    and find_in_cons_cases cases =
      (map (fn (valid,matchvar,tree) => find tree) cases;())
    and find_default (PRESENT tree) = find tree
      | find_default ABSENT = ()
  in
    (find tree;
     rev (!lablist)) (* return in order of occurrence *)
  end

datatype 'a Opt = SOME of 'a | NONE

datatype MatchBindings =
  (* list of "tested so far" constructors, current constructors,total no. of constructors for type *)
  CONSBIND of Ident.LongValId list * (Ident.LongValId * Matchvar) Opt * int
  (* list of "tested so far constants, current constant (or nothing if in an else) *)
  | SCONBIND of Ident.SCon list * Ident.SCon Opt
  | RECORDBIND of (Ident.Lab * Matchvar) list
  | MVARBIND of Matchvar

fun get_match_binding(mvar,env) =
  case Lists.assoc(mvar,env) of
    MVARBIND mvar' => get_match_binding(mvar',env)
  | x => x

fun extend_env ([],env) = env
  | extend_env ((mvar,mvar')::l,env) =
    extend_env (l,(mvar,MVARBIND(mvar'))::env)

fun find_leaves (tree,label_bindings) =
  let
    val leaves = ref [] : int list ref
    val error_found = ref false
    fun add_leaf n =
      if (Lists.member(n,(!leaves))) then () else leaves:= n :: (!leaves)
    fun mapc f [] = ()
      | mapc f (a::l) = (f a; mapc f l)
    fun lookup_label label = Lists.assoc(label,label_bindings) handle Lists.Assoc => Crash.impossible "Bad label in get_leaves"
    fun scan (ERROR,env) = error_found := true
      | scan (x as (LEAF(exp,n,bindinglist)),env) = add_leaf n
      | scan (SCON(mv,cases,default),env) =
        scan_scon (mv,cases,default,env)
      | scan (CONSTRUCTOR (ty,mv,cases,default),env) =
        scan_cons (ty,mv,cases,default,env)
      | scan (RECORD (ty,mv,labels,tree),env) = scan_record_tree(mv,labels,tree,env)
      | scan (LABEL(lab,tree),env) = scan (tree,env)
      | scan (GOTO lab,env) = scan (lookup_label lab,env)
    and scan_record_tree(mv,labels,tree,env) =
      (case get_match_binding(mv,env) of
         RECORDBIND labels' =>
d424 109
a532 20
             (* This takes advantage of the fact that record labels are ordered *)
             (* Take two label-matchvar mappings and produce a list of pairs of *)
             (* corresponding matchvars. *)
             (* merge the record bindings to produce a new environment object *)
             fun match_matchvars([],[],old,new) = (old,rev new)
               | match_matchvars([],a::l,old,new) = match_matchvars([],l,old,a::new)
               | match_matchvars(a::l,[],old,new) = match_matchvars(l,[],old,a::new)
               | match_matchvars(all as ((lm as (lab,mvar))::l),all' as ((lm' as (lab',mvar'))::l'),old,new) =
                 if Ident.lab_eq (lab,lab')
                   then
                     match_matchvars(l,l',(mvar,mvar')::old,lm'::new)
                 else
                   if Ident.lab_order(lab,lab')
                     then match_matchvars(l,all',old,lm::new)
                   else match_matchvars(all,l',old,lm'::new)
             val (bindings,new_labels) = match_matchvars(labels,labels',[],[])
             val new_env =
               if Lists.length new_labels = Lists.length labels'
                 then env
               else (mv,RECORDBIND new_labels)::env
d534 1
a534 1
             scan (tree,extend_env (bindings,new_env))
a535 58
       | _ => Crash.impossible "Bad MatchVar binding for record")
         handle Lists.Assoc =>
           scan(tree,(mv,RECORDBIND labels)::env)
    and scan_scon (mv,cases,default,env) =
      let fun scan_cases ((mv,seenlist),cases,env) =
        mapc (fn (scon,tree) =>
             scan(tree,(mv,SCONBIND(seenlist,SOME scon))::env))
        cases
          fun scan_scon_default(default,(mv,seenlist),env) =
            scan_default(default,(mv,SCONBIND(seenlist,NONE))::env)
      in
        (case get_match_binding (mv,env) of
           SCONBIND (seenlist,SOME scon) =>
             let
               fun find_case [] =
                 (case default of
                    PRESENT tree => scan (tree,env)
                  | ABSENT => Crash.impossible"Default missing -- find_case (scon)")
                 | find_case ((scon',tree)::cases) =
                   if Ident.scon_eqrep(scon,scon')
                     then
                       scan(tree,env)
                   else
                     find_case cases
             in
               find_case cases
             end
         | SCONBIND (seenlist,NONE) =>
             (* we are in the else clause of a higher-up match *)
             (* so remove cases that have been tested for and extend environment *)
             let
               (* find the relevant cases *)
               (* don't scan subtrees yet *)
               fun get_valid_cases [] = []
                 | get_valid_cases ((x as (scon,tree))::cases) =
                   if Lists.exists (fn scon' => Ident.scon_eqrep(scon,scon')) seenlist
                     then get_valid_cases cases
                   else x :: (get_valid_cases cases)
               val new_cases = get_valid_cases cases
             in
               case new_cases of
                 [] =>
                   (case default of
                      PRESENT tree => scan(tree,env)
                    | ABSENT => Crash.impossible"Default missing -- scon_default")
               | _ =>
                   let
                     val new_seenlist = seenlist @@ (map #1 new_cases)
                     val entry = (mv,new_seenlist)
                   in
                     (scan_cases(entry,new_cases,env);scan_scon_default(default,entry,env))
                   end
             end
         | _ => Crash.impossible "Bad MatchVar Binding for scon in scan_tree")
       handle Lists.Assoc =>
         let
           val seenlist = map #1 cases
           val entry = (mv,seenlist)
d537 34
a570 2
           (scan_cases(entry,cases,env);
            scan_scon_default(default,entry,env))
d572 60
a631 50
      end
    and scan_cons (ty,mv,cases,default,env) =
      let fun scan_cases ((mv,seenlist,total),cases,env) =
        mapc (fn (id,matchvar,tree) =>
             scan(tree,(mv,CONSBIND(seenlist,SOME(id,matchvar),total))::env))
        cases
          fun scan_cons_default(default,(mv,seenlist,total),env) =
            scan_default(default,(mv,CONSBIND(seenlist,NONE,total))::env)
      in
        (case get_match_binding(mv,env) of
           CONSBIND (seenlist,SOME(id,mvar),total) =>
             let
               fun find_case [] =
                 (case default of
                    PRESENT tree => scan (tree,env)
                  | ABSENT => Crash.impossible"Default missing -- find_case (cons)")
                 | find_case ((id',mvar',tree)::cases) =
                   if id = id'
                     then
                       (* doing this substitution shouldn't be necessary *)
                       (* could use a substitution map *)
                       scan(tree,extend_env([(mvar,mvar')],env))
                   else
                     find_case cases
             in
               find_case cases
             end
         | CONSBIND (seenlist,NONE,total) =>
             (* we are in the else clause of a higher-up match *)
             (* so remove cases that have been tested for and extend environment *)
             let
               (* find the relevant cases *)
               (* don't scan subtrees yet *)
               fun get_valid_cases [] = []
                 | get_valid_cases ((x as (id,mvar,tree))::cases) =
                   if Lists.member (id,seenlist)
                     then get_valid_cases cases
                   else x :: (get_valid_cases cases)
               val new_cases = get_valid_cases cases
             in
               case new_cases of
                 [] =>
                   (case default of
                      PRESENT tree => scan(tree,env)
                    | ABSENT => Crash.impossible"Default missing -- cons default")
               | _ =>
                   let
                     val new_seenlist = seenlist @@ (map (fn(x,_,_) => x) new_cases)
                     val length = Lists.length new_seenlist
                     val entry = (mv,new_seenlist,total)
d633 3
a635 4
                     if length = total
                       then scan_cases(entry,new_cases,env)
                     else
                       (scan_cases(entry,new_cases,env);scan_cons_default(default,entry,env))
d637 2
d640 42
a681 5
         | _ => Crash.impossible "Bad MatchVar Binding for cons in scan_tree")
       handle Lists.Assoc =>
         let
           val seenlist = map (fn (x,_,_) => x) cases
           val entry = (mv,seenlist,(Type_Utils.get_no_cons ty))
d683 73
a755 2
           (scan_cases(entry,cases,env);
            scan_cons_default(default,entry,env))
a756 27
      end
    and scan_default (PRESENT tree,env) = scan(tree,env)
      | scan_default (ABSENT,_) = ()
  in
    scan(tree,[]);
    (rev (!leaves),!error_found)
  end

fun check_tree tree =
  let
    val labels = find_labels(tree)
  in
    find_leaves(tree,labels)
  end

fun get_redundant_clauses(n,leaves)=
  (* return the list of numbers <= n and not in leaves *)
  let
    fun do_one(m,result) =
      if m > n
        then
          rev result
      else
        do_one(m+1,if Lists.member(m,leaves) then result else m::result)
  in
    do_one(1,[])
  end
d758 261
a1018 451
(** Has a label been refered to ? **)
    fun refered_to ((_, ref label):Label) = (label > 0)

(** Make a counter, that is a closure of a reference, and a function to
    increment the value. **)
(*
    fun make_counter x =
      let val foo = ref x   (* the initial value of the counter *)
      in
	(fn () => (foo := (!foo) + 1; (!foo)))
      end
*)

    val _ = LabelCounter.reset_counter 0
    val _ = MVCounter.reset_counter 0
    val next_Label = fn () => (LabelCounter.counter(), ref 0)
(*
      let
	val counter = make_counter 0
      in
	fn () => (counter (), ref 0) : Label
      end
*)

    val next_Matchvar = MVCounter.counter
(*
(make_counter 0):(unit -> Matchvar)
*)
    val Dummy_MV = (~1):Matchvar         (* for use in nullary constructors *)
    val Dummy_Label = (0, ref 0):Label   (* for use in mixture_rule *)
    val Default_Label = next_Label ()

(** The various rules for the pattern match **)
    datatype Rules = 
      Variable_rule
      | Constructor_rule
      | Scon_rule
      | Record_rule
      | Mixture_rule
      | Empty_rule

(** This takes a (Label * tree), and returns an equivalent tree.  If this is
    the first time that the Label has been used, then return a LABEL
    node containing the tree, otherwise return a GOTO node, pointing
    to that label.
**)
    fun share_lab (label as (_, count), tree) =
      (count := (!count) + 1 ; 
       if (!count = 1) then
	 LABEL(label, tree)
       else
	 GOTO label)

(** Determine what rule to use on the patterns, we just ignore
    LAYEREDpats and TYPEDpats, they will be dealt with by other
    routines **)
    fun find_rules [] rest = rest
      | find_rules (([], _)::ll) rest = Empty_rule::(find_rules ll rest)
      | find_rules ((pattern::pats, exp)::ll) rest =
	case pattern of
	  Absyn.WILDpat            => Variable_rule::(find_rules ll rest)
	| Absyn.SCONpat _          => Scon_rule::(find_rules ll rest)
	| Absyn.RECORDpat _        => Record_rule::(find_rules ll rest)
	| Absyn.APPpat _           => Constructor_rule::(find_rules ll rest)
	| Absyn.TYPEDpat (p, _,_)    => find_rules (([p], exp)::ll) rest
	| Absyn.LAYEREDpat (_, p)  => find_rules (([p], exp)::ll) rest 
	| Absyn.VALpat ((Ident.LONGVALID( _, val_id ), _),_) =>
	    (case val_id of   (* VAR, CON, or EXCON -- choose the right rule *)
	       Ident.VAR _            => Variable_rule::(find_rules ll rest)
	     | Ident.CON _            => Constructor_rule::(find_rules ll rest)
	     | Ident.EXCON _          => Constructor_rule::(find_rules ll rest))

(** Given a list of possible rules (one per expression), this routine
    chooses the one it can use (ie if they are all the same we can use
    that rule, otherwise we use the Mixture_rule.)  If the list is
    empty then raise impossible, since that should never happen.  **)
    fun choose_rule [ single ] = single
      | choose_rule (first::((rest as (second::_)))) =
	if (first = second) then
	  choose_rule rest
	else
	  Mixture_rule
      | choose_rule [] =
	Crash.impossible "Empty list of rules in choose_rule" 

(** This routine takes a (pattern list * tree) list, and returns a
    tuple of two (pattern list * tree) lists, and a pattern.  The first
    list is made from all the elements of the input list which have the
    same first pattern, in their pattern list as the first pattern of
    the first element of the input, but with that first pattern
    removed.  The second list is the remaining elements of the input.
    The pattern is the first pattern of the first element of the input.
    This is basically an optimised version of CONsplit which just copes
    with SCON patterns.

    We only ever call the routine with the required form of input, and
    raise an exception if the input is wrong. **)
    fun SCONsplit [] = Crash.impossible "Empty pattern list in SCONsplit"
      | SCONsplit (all as ([], _)::_) =
	Crash.impossible "No pattern in list in SCONsplit"
      | SCONsplit ((pat::pats, tree)::pl) =  (* this is the one *)
	let
          fun sconpat_eq (Absyn.SCONpat scon,Absyn.SCONpat scon') =
            Ident.scon_eqrep (scon,scon')
            | sconpat_eq _ = Crash.impossible "Bad sconpat int sconpat_eq"
	  fun insplit [] (p1, p2) = (rev p1, rev p2, pat)
	    | insplit (([], _)::pl) rest = insplit pl rest
	    | insplit ((pats as(p::pp, tree))::pl) (p1, p2) =
	      if (* p = pat *) sconpat_eq(p,pat) then
		insplit pl ((pp, tree)::p1, p2)
	      else
		insplit pl (p1, pats::p2)
	in  (* go for it *)
	  insplit pl ([(pats, tree)], [])
	end

(** This does much the same as SCONsplit, but for CON nodes.  It has to
    cope with adding patterns back on in the case of non-nullary
    constructors (APPpat nodes), but is generally the same structure as
    above. **)
    fun CONsplit [] = Crash.impossible "Empty pattern list in CONsplit"
      | CONsplit (all as ([], _)::_) =
	Crash.impossible "No pattern in list in CONsplit"
      | CONsplit ((pat::pats, tree)::pl) =  (* this is the one *)
	let

	  fun addvp (Absyn.APPpat (_, newpat,_)) rest = newpat::rest
	    | addvp _ rest = rest

	  val check = The_construc pat

	  fun insplit [] (p1, p2) = (rev p1, rev p2, pat)
	    | insplit (([], _)::pl) rest = insplit pl rest
	    | insplit ((pats as(p::pp, tree))::pl) (p1, p2) =
	      if (The_construc p) = check then
		insplit pl ((addvp p pp, tree)::p1, p2)
	      else
		insplit pl (p1, pats::p2)
	in  (* go for it *)
	  insplit pl ([(addvp pat pats, tree)], [])
	end

(** This routine checks for TYPEDpats and LAYEREDpats at the start of
    patterns, deals with them and removes them.   This is used by the
    scon_rule, the constructor_rule and the record_rule as these
    routines need such patterns removed beore continuing. **)
    fun checkstart [] rest _ = rev rest
      | checkstart ((head as ([], _))::pp) rest match =
	checkstart pp (head::rest) match
      | checkstart ((head as (pat::pats, tree as (exp, subs)))::pp) rest match =
	(case pat of
	   Absyn.TYPEDpat (p, _,_) => checkstart ((p::pats, tree)::pp) rest match
	 | Absyn.LAYEREDpat ((vi, ref ty), p) =>
	     (debug ["matchvar = ",
		     Integer.makestring (get_SMatchvar match),
		     "\n" ];
	      checkstart ((p::pats,
			   (exp, (get_SMatchvar match, vi, ty)::subs))::pp)
	      rest match)
	 | _ => checkstart pp (head::rest) match)

(** Determine if all possible constructors of a type are present. **)
    fun all_constructors_present [] _ = false
      | all_constructors_present (([], _)::_) _ = false
      | all_constructors_present ll thetype =
	let

(** Get the number of constructors, and print it out if debug is true. **)
	  val Arity = Type_Utils.get_no_cons thetype
	  val _ = debug ["Arity of constructor is ",
			 Integer.makestring Arity, "\n"]

(** generate a list of all constructors in the pattern **)
	  fun make_l [] rest = rest
	    | make_l (([], _)::ll) rest = make_l ll rest
	    | make_l ((pat::_, _)::ll) rest =
	      make_l ll ((The_construc pat)::rest)

(** remove all occurences of a constructor from a list of constructors **)
	  fun remove _ [] rest = rest
	    | remove p (c::cc) rest =
	      if p = c then
		remove p cc rest
	      else
		remove p cc (c::rest)

(** Count the number of unique constructors present, and print it if
    debug is true. **)
	  fun count [] rest =
	    (debug ["constructors present = ",
		    Integer.makestring rest, "\n"] ;
	     rest)
	    | count (head::tail) rest =
	      count (remove head tail []) (rest + 1)

	in      (* Do we have all the constructors ? *)
	  ((count (make_l ll []) 0) = Arity)
	end

    datatype rule_severity = EQUAL | POSSIBLE | NOTPOSSIBLE

(** The internal matching routine **)
    fun internal_match options _ [] _ = ERROR
      | internal_match options swap_table pats lab =
	let
(** The variable rule.  Basically we remove the variable, and set up
    bindings for the matchvar that the variable will match. **)
	  fun variable_rule [] rest (match, lab) =
	    let
	      val mat = get_NMatchvar match
	    in
	      internal_match options swap_table (rev rest) (mat, lab)
	    end
	    | variable_rule (([], _)::_) _ _ =
	      Crash.impossible "Empty pattern in variable_rule"
	    | variable_rule ((pat::pats, (tree as (exp, subs)))::pl)
	      rest (vars as (match, lab)) =
	      let val redundant =
		(case pats of
		   [] => (case pl of
			    [] => false
			  | _  => true)
		 | _  => false)
	      in
		if redundant then
(** we throw away the other cases now, so that the match will be
    faster (as we don't have to consider maching them) **)
		    (debug ["redundant patterns ignored in variable-rule\n"];
		     variable_rule [ (pat::pats, tree) ] rest vars)
		else
		  let
		    val mat = get_SMatchvar match
		  in 
		    case pat of
		      Absyn.WILDpat => variable_rule pl ((pats, tree)::rest) vars
		    | Absyn.VALpat ((Ident.LONGVALID(_, vi), ref ty),_) =>
			variable_rule pl ((pats, (exp, (mat, vi, ty)::subs))::rest) vars
(** in an 'as' statement, we match the variable to the matchvar for the
    match (as well) **)
		    | Absyn.LAYEREDpat ((vi, ref ty), pat) =>
			variable_rule (((pat::pats), (exp, (mat, vi, ty)::subs))::pl)rest vars
(** Ignore the type information (at least for now) **)
		    | Absyn.TYPEDpat (pat, _,_) =>
			variable_rule (((pat::pats), tree)::pl) rest vars
		    | _ => Crash.impossible "Missing Variable-pattern in variable_rule"
		  end
	      end

(** Generate the list of Scon * tree **)
	  fun make_SCtree_list [] rest lab = rev rest
	    | make_SCtree_list all rest lab =
	      let
		val (same, ll, pat) = SCONsplit all 
		val _ = debug ["S same = ",
			       Integer.makestring (Lists.length same), "\n"]
	      in
		case pat of
		  (Absyn.SCONpat scp) =>
		    make_SCtree_list ll ((scp,
					  internal_match options swap_table same lab
					  )::rest) lab
		| _ => Crash.impossible "Not SCON pattern in SCON matching"
	      end

(** Generate the list of Cons * tree * Matchvar **)
	  fun make_COtree_list [] rest lab = rev rest
	    | make_COtree_list all rest (lab as (matches, lm)) =
	      let
		val (same, ll, pat) = CONsplit all 
		val _ = (* output debugging messages. *)
		  if (!do_debug) then
		    print ["C same = ", Integer.makestring (Lists.length same), " l = ",
			   Integer.makestring (Lists.length ll), " all = ",
			   Integer.makestring (Lists.length all), "\n" ]
		  else
		    ()
	      in
		(case pat of
		   (Absyn.VALpat ((lvi, _),_)) =>
		     (make_COtree_list ll
		      ((lvi, Dummy_MV, internal_match options swap_table same
			(get_NMatchvar matches, lm))::rest) lab)
		 | (Absyn.APPpat ((lvi, _),newpat,_)) =>
		     let
		       val newmatchvar = next_Matchvar ()
		     in
		       (make_COtree_list ll
			((lvi, newmatchvar, internal_match options swap_table same
			  (replace_SMatchvar matches
			   (S newmatchvar), lm))::rest) lab)
		     end
		 | _ => Crash.impossible "Not Constructor pattern in CON matching"
		     )
	      end

(** Create a Scon node.  Get the matchvar, list of scon * tree, and the
    default tree, and build up the node. **)
	  fun scon_rule pats (match, lab) =
	    let
	      val thepats = checkstart pats [] match
	    in
	      SCON (get_SMatchvar match,
		    make_SCtree_list thepats [] (get_NMatchvar match, lab),
		    PRESENT (share_lab lab))
	    end

(** Create a CONSTRUCTOR node.  First work out if we need the default
    tree, then get the matchvar, list of valid * matchvar * tree, and
    the default tree, and build up the node. **) 
	  fun constructor_rule pats (rest as (match, lab)) =
	    let
	      val thepats = checkstart pats [] match
	      val thetype = Type_Utils.get_cons_type (get_type thepats)
	      val default_tree =
		if (all_constructors_present thepats thetype) then
		  ABSENT
		else
		  PRESENT (share_lab lab)
	    in
	      CONSTRUCTOR (thetype, get_SMatchvar match,
			   make_COtree_list thepats []
			   rest,
			   default_tree)
	    end

(** Create a RECORD node.  Get a list of all the needed records and
    patterns.  We then replace the head pattern by the list of patterns
    each contains (same length by now), and replace the matchvar of the
    record by the list of matchvars.  We then call internal_match to
    generate a match tree, and build up the RECORD node which we
    return. **)
	  fun record_rule pats (match, lab) =
	    let
	      fun our_order ((x, _), (y, _)) = Ident.lab_order(x, y)
	      val sort_fields = Lists.qsort our_order
	      val the_old_match = get_SMatchvar match
	      val thepats = checkstart pats [] match
	      val thetype = get_type thepats

	      val flexpats = make_flex_list thepats []
	      val needed_fields =
		Lists.qsort
		Ident.lab_order
		(find_needed_labels flexpats [])
	      val rigidpats = make_rigid_list sort_fields flexpats needed_fields

(** For debugging purposes, print out the fields needed, in the order
    of extraction. **)
	      fun print_fields f =
		let
		  fun internal [] = write " ]\n"
		    | internal [ (h, n) ] =
		      print ["'", IdentPrint.printLab h, "':( ",
			     Integer.makestring n, ") ]\n" ]
		    | internal ((h, n)::t) =
		      (print ["'", IdentPrint.printLab h, "':( ",
			      Integer.makestring n, ") , " ] ;
		       internal t)
		in
		  if (!do_debug) then
		    (write "Selected fields are: [ "; internal f)
		  else
		    ()
		end

(** Remove the other fields, leaving just the labels.  We want them in
    reverse order of their heuristic choice, so that when placed at the
    head of the lists, the patterns end up in the right order. **)
	      fun just_labels [] rest = rest
		| just_labels ((lab, _)::more) rest =
		  just_labels more (lab::rest)

(** Given the list of labels in the correct order, generate the new
    pattern list. **)
	      fun make_newpatterns [] patterns = rev patterns
		| make_newpatterns (lab::t) patterns =
		  let

(** Merge in a list to the generated patterns. **)
		    fun merge [] _ rest = rev rest
		      | merge (l::ls) [] rest =
			merge ls [] ([l]::rest)
		      | merge (l::ls) (h::hs) rest =
			merge ls hs ((l::h)::rest)

(** Extract a row of needed patterns, from the rigid-pattern list. **)
		    fun get_patterns [] rest = rest
		      | get_patterns (nil::more) rest =
			get_patterns more rest
		      | get_patterns (head::tail) rest =
			let
			  fun get_pat [] rest = rest
			    | get_pat ((l, pat)::more) rest =
			      if lab = l then
				(pat::rest)
			      else
				get_pat more rest
			in
			  get_patterns tail (get_pat head rest)
			end
		  in
		    make_newpatterns t
		    (merge (get_patterns rigidpats []) patterns [])
		  end

(** Define a function which returns a list of N new matchvars... **)
	      fun make_matchvars 0 rest = rest
		| make_matchvars n rest =
		  make_matchvars (n - 1) (next_Matchvar()::rest)

(** And get the needed new matchvars **)
	      val thematchvars = make_matchvars (Lists.length needed_fields) []

(** Split off patterns from pairs of labels and patterns **)
	      fun patterns [] rest = rev rest
		| patterns ((_, head)::tail) rest =
		  patterns tail (head::rest)

(** Add a list of patterns replacing the head pattern, for each match
    rule in the list of rules. **)
	      fun add_patt [] _ rest = rev rest
		| add_patt _ [] rest = rev rest
		| add_patt (h::t) (([], more)::b) rest =
		  add_patt t b ((patterns h [], more)::rest)
		| add_patt (h::t) (((_::a), more)::b) rest =
		  add_patt t b ((((patterns h []) @@ a), more)::rest)

	      fun add_reordered [] _ rest = rev rest
		| add_reordered _ [] rest = rev rest
		| add_reordered (h::t) (([], more)::b) rest =
		  add_reordered t b ((h, more)::rest)
		| add_reordered (h::t) (((_::a), more)::b) rest =
		  add_reordered t b (((h @@ a), more)::rest)

	      fun add_empty [] rest = rev rest
		| add_empty ((m as ([], _))::b) rest =
		  add_empty b (m::rest)
		| add_empty (((_::a), more)::b) rest =
		  add_empty b ((a, more)::rest)

(** Give each of the fields a heuristic value for determining their order of testing
    We use the number of Non-variable rules in the columns **)
              fun calculate_scores rigidpats =
                let
                  val mapping = NewMap.empty' Ident.lab_lt
                  fun add_to_map (mapping,lab,y) =
                    let
                      val x =
                        case NewMap.tryApply'(mapping, lab) of
                          NewMap.YES x => x + (y : int)
                        | NewMap.NO => y
d1020 1
a1020 1
                      NewMap.define(mapping,lab,x)
d1022 6
d1029 1
a1029 8
                  NewMap.to_list(Lists.reducel
                                 (fn (mapping,pats) =>
                                  Lists.reducel
                                  (fn (mapping,(lab,Absyn.WILDpat)) => add_to_map(mapping,lab,0)
                                | (mapping,(lab,Absyn.VALpat((Ident.LONGVALID( _, Ident.VAR _), _),_))) => add_to_map(mapping,lab,0)
                                | (mapping,(lab,_)) => add_to_map(mapping,lab,1))
                                  (mapping,pats))
                                 (mapping,rigidpats))
d1031 110
a1140 93

(** Merge two lists together, giving a list of the pairs.  Terminates
    with the shorter of the two lists if they arn't of equal length. **) 
	      fun merge_in [] _ rest = rev rest
		| merge_in _ [] rest = rev rest
		| merge_in (h::t) (a::b) rest =
		  merge_in t b ((h, a)::rest)

	      val number_of_fields = Lists.length needed_fields

	      val (the_new_pats, matchlabs) =
		if number_of_fields > 0 then
		  (if (!do_reorder) 
                     andalso (number_of_fields > 1) then
		     let
(** Get the best order to extract the fields of the record. **)
		       val ordered_fields =
			 Lists.qsort 
                         (fn ((_,x : int),(_,y)) => (x >= y)) 
                         (calculate_scores rigidpats)

		       val _ = print_fields ordered_fields

		       val reordered_labels = just_labels ordered_fields []
		       val reordered_patterns = make_newpatterns reordered_labels []
		     in
		       (debug ["Reordering fields of record.\n"] ;
			(add_reordered reordered_patterns thepats [],
			 merge_in (rev reordered_labels) thematchvars []))
		     end
		   else
		     let
		       val _ = (debug ["Not reordering record fields\n"] ;
				print_fields (map (fn x => (x, 0))
					      needed_fields))
		     in
		       (add_patt rigidpats thepats [],
			merge_in needed_fields thematchvars [])
		     end)
		else
		  (debug ["Empty record, no needed fields.\n"] ;
		   (add_empty thepats [], []))
	    in
(** Make up the record node, by making a recursive call to
    internal_match, and filling in the matchvar, and list of
    field names/matchvars. **)
	      RECORD (thetype, the_old_match, matchlabs,
		      (internal_match options swap_table the_new_pats
		       (replace_SMatchvar match
			(D (map (fn x => S x) thematchvars)), lab)))
	    end

(** Split the rules up into those with the same front, and the rest,
    and make a doubly recursive call to internal_match **)
	  fun mixture_rule pats (all as (match, lab)) the_rules =
	    let

(** Count the number of elements the same at the top of a list **)
	      fun count [] = 0
		| count (head::rest) =
		  let
		    fun internal [] num = num
		      | internal (top::tail) num =
			if top = head then
			  internal tail (num + 1)
			else
			  num
		  in
		    internal rest 1
		  end

(** generate the list of patterns with the same 'match-rule' **)
	      fun samelist [] _ = []
		| samelist (all as (head::_)) rules =
		  let
		    fun internal [] _ rest = rev rest
		      | internal _ [] rest = rev rest
		      | internal (first::more) (a::b) rest =
			if (first = head) then
			  internal more b (a::rest)
			else
			  internal more b rest
		  in
		    internal all rules []
		  end

(** Split a list into two parts, the first is n long **)
	      fun split n all =
		let
		  fun internal 0 (first, rest) = (rev first, rest)
		    | internal n (first, []) = (rev first, [])
		    | internal n (first, (head::tail)) =
		      internal (n - 1) ((head::first), tail)
d1142 2
a1143 1
		  internal n ([], all)
d1145 30
a1174 39

	      fun recordp (Record_rule::_) = true
		| recordp _ = false

	      fun variablep (Variable_rule::_) = true
		| variablep _ = false

(** If one of the fields is a record, then we know all must be either
    records or variables (from the type), so we can just convert all
    of them to records (WILDpats go to empty flex record, VALpats go
    to a LAYERED pat (to get the binding), and an empty flex record.)
    This allows us to bypass the mixture rule for efficiency! **)
	      fun rec_special [] rest _ = rev rest
		| rec_special (((Absyn.WILDpat::ll), more)::mm) rest ty =
		  rec_special mm (((Absyn.RECORDpat ([], true, ty))::ll, more)::rest) ty
		| rec_special (((Absyn.VALpat((Ident.LONGVALID(_, vi), _),_)::ll), more)::mm) rest ty =
		  rec_special mm (((Absyn.LAYEREDpat ((vi, ty), Absyn.RECORDpat ([], true, ty)))::ll, more)::rest) ty
		| rec_special (any::mm) rest ty =
		  rec_special mm (any::rest) ty

(** If we can apply the rec_special rule then do it, otherwise go for
    the full mixture rule.  **)
	      val the_tree =
		if (recordp the_rules) then  (* special case with records *)
		  (debug [ "Record special mixture\n" ];
		   internal_match options swap_table (rec_special pats [] (ref (get_type pats))) all)
		else
		  let
		    val number_of_rules = count the_rules
		    val (front, back) = split number_of_rules pats
		    val the_new_label = next_Label ()

(** The new default tree is a defered application node. **)
		    val new_default = (the_new_label, internal_match options swap_table back all)
		      
		  in
(** generate the new tree **)
		    internal_match options swap_table front (match, new_default)
		  end
d1176 2
a1177 1
	      the_tree
d1179 11
d1191 11
a1201 39
(** The rules are empty.  So either return the top expression
    (if present), or the default tree.  We do some checking for
    redundant rules here too. **)
	  fun empty_rule pats (_, lab) =
	    (case pats of
	       []                        =>  share_lab lab
	     | [(_, ((exp, n), ll))]     =>  LEAF (exp,n,ll)
	     | ((_,((exp, n), ll))::_)  =>
		 (debug ["redundant patterns ignored in empty-rule\n"] ;
		  LEAF (exp,n,ll))
		 )

(** Move similar rules together **)

          fun bring_rules_together([],[]) = ([],[])
            | bring_rules_together(pats,types as (top_type::_)) =
            let

              fun push_down(pat,ty,[],[]) = ([pat],[ty])
                | push_down(pat as (_,((_,n),_)),ty,
                            arg as ((this_pat as (_,((_,n'),_)))::rest_pats),arg' as (this_type::rest_types)) =
                  if Array.sub(Array.sub(swap_table,n-1),n'-1) 
                    then 
                      let
                        val (x,y) = push_down(pat,ty,rest_pats,rest_types)
                      in
                        (this_pat::x,this_type::y)
                      end
                  else
                    (pat::arg,ty::arg')
                | push_down _ =
                  Crash.impossible "in _match the rule list and pats list disagree in length"

              fun walk_rules([],[],sofar_pats,sofar_types) = (rev sofar_pats,rev sofar_types)
                | walk_rules(arg as (pat::pats), arg' as (ty::types),sofar_pats,sofar_types) =
                  if ty = top_type orelse (top_type = Variable_rule andalso ty <> Variable_rule)
                    then 
                      let
                        val (x,y) = push_down(pat,ty,sofar_pats,sofar_types)
d1203 2
a1204 1
                        walk_rules(pats,types,x,y)
d1206 3
a1208 96
                  else 
                    walk_rules(pats,types,pat::sofar_pats,ty::sofar_types)
                | walk_rules _ = Crash.impossible "in _match the rule list and pats list disagree in length"
                    
            in
              walk_rules(pats,types,[],[])
            end
          | bring_rules_together _ = 
            Crash.impossible "in _match bad argument to bring_rules_together"

          fun output_the_rule_lists [] = ()
            | output_the_rule_lists ((pat_list,_)::rest_pats) =
            let
              val _ = 
                map (fn x => (Print.print(AbsynPrint.unparsePat options x ^ " "))) pat_list
              val _ = 
                Print.print "\n"
            in
              output_the_rule_lists rest_pats
            end

          val _ = 
            if !do_debug
              then
                (Print.print "Patterns before re-ordering\n";
                 output_the_rule_lists pats)
            else ()
            
(** get the rules, and choose one. **)
	  val rule_list = find_rules pats []
          val (pats,rule_list) = bring_rules_together(pats,rule_list)
	  val the_rule = choose_rule (rule_list)

          val _ = 
            if !do_debug
              then
                (Print.print "Patterns after re-ordering\n";
                 output_the_rule_lists pats)
            else ()

	in
	  case the_rule of
	    Variable_rule      =>  variable_rule pats [] lab
	  | Constructor_rule   =>  constructor_rule pats lab
	  | Scon_rule          =>  scon_rule pats lab
	  | Record_rule        =>  record_rule pats lab
	  | Mixture_rule       =>  mixture_rule pats lab rule_list
	  | Empty_rule         =>  empty_rule pats lab
	end

    (* This compares some rules to determine if we are free to swap them *)
    fun generate_swap_table options pats =
      let
        fun safe_to_swap_longvalid(Ident.LONGVALID( _, val_id),Ident.LONGVALID( _, val_id')) =
          (case (val_id,val_id') of
             (Ident.CON name,Ident.CON name') =>
               if name=name'
                 then EQUAL
               else POSSIBLE
           | (Ident.EXCON name,Ident.EXCON name') =>
               if name=name'
                 then EQUAL
               else POSSIBLE
           | (Ident.VAR _,_) => EQUAL
           | (_,Ident.VAR _) => EQUAL
           | _ => POSSIBLE)
             
        fun combine (_,NOTPOSSIBLE) = NOTPOSSIBLE
          | combine (NOTPOSSIBLE,_) = NOTPOSSIBLE
          | combine (EQUAL,EQUAL) = EQUAL
          | combine _ = POSSIBLE
            
        fun safe_to_swap_rules(Absyn.APPpat((name,_),arg,_),
                               Absyn.APPpat((name',_),arg',_)) =
          combine(safe_to_swap_longvalid(name,name'),
                  safe_to_swap_rules(arg,arg'))
          | safe_to_swap_rules(Absyn.VALpat ((long,_),_),Absyn.VALpat((long',_),_)) =
            safe_to_swap_longvalid(long,long')
          | safe_to_swap_rules(Absyn.VALpat ((Ident.LONGVALID(_,Ident.CON _),_),_),Absyn.WILDpat) =
            EQUAL
          | safe_to_swap_rules(Absyn.VALpat ((Ident.LONGVALID(_,Ident.EXCON _),_),_),Absyn.WILDpat) =
            EQUAL
          | safe_to_swap_rules(Absyn.VALpat ((Ident.LONGVALID(_,Ident.CON _),_),_),Absyn.APPpat _) =
            POSSIBLE
          | safe_to_swap_rules(Absyn.VALpat ((Ident.LONGVALID(_,Ident.EXCON _),_),_),Absyn.APPpat _) =
            POSSIBLE
          | safe_to_swap_rules(Absyn.RECORDpat(name_pat_list,_,_),Absyn.RECORDpat(name_pat_list',_,_)) =
            if Lists.length(name_pat_list) <> Lists.length(name_pat_list')
              then POSSIBLE
            else
              Lists.reducel(fn (x,((name,pat),(name',pat'))) => 
                            if name=name' 
                              then 
                                combine(x,safe_to_swap_rules(pat,pat'))
                            else NOTPOSSIBLE)
              (EQUAL,Lists.zip(name_pat_list,name_pat_list'))
d1210 7
a1216 27
          | safe_to_swap_rules _ = NOTPOSSIBLE
            
        fun is_safe_to_swap([],_,sofar) = sofar
          | is_safe_to_swap(_,[],sofar) = sofar
          | is_safe_to_swap(_,_,NOTPOSSIBLE) = NOTPOSSIBLE
          | is_safe_to_swap(h::t,a::b,sofar) = 
            is_safe_to_swap(t,b,combine(sofar,safe_to_swap_rules(h,a)))
            
        fun swappable((pat_list,_),(pat_list',_)) = 
          let
            val result = is_safe_to_swap(pat_list,pat_list',EQUAL) = POSSIBLE
            val _ =
              if !do_debug
                then 
                  let
                    val patterns =
                      implode(map (AbsynPrint.unparsePat options) pat_list)
                      ^ " and " 
                      ^ implode(map (AbsynPrint.unparsePat options) pat_list')
                  in
                    if result
                      then
                        output(std_out,"Swappable " ^ patterns ^ "\n")
                    else 
                      output(std_out,"Not swappable " ^ patterns ^ "\n")
                  end
              else ()
d1218 2
a1219 1
            result
d1221 5
a1225 55

        val number = Lists.length pats
        val result = Array.array(number,Array.array(number,false))

        fun set_index 0 = ()
          | set_index n = (Array.update(result,n-1,Array.array(number,false));
                           set_index (n-1))

        val _ = set_index number
            
        fun scan_all([],_) = ()
          | scan_all(h::t,[]) = scan_all(t,pats)
          | scan_all(arg as ((h as (_,((_,n),_)))::_),(a as (_,((_,n'),_)))::b) =
                     (Array.update(Array.sub(result,n-1),n'-1,swappable(h,a));
                      scan_all(arg,b))
      in
        scan_all(pats,pats);
        result
      end

    fun compile_match options pat_exp =
      let

(** convert a '(pattern * exp) list' to a
    '(pattern list * ((exp * int) * ((matchvar * valid) list))) list' **)
	fun convert_form all =
	  let
	    fun internal [] rest _ = rev rest
	      | internal ((a, b)::ll) rest n =
		internal ll (([ a ], ((b, n), []))::rest) (n + 1)
	  in
	    internal all [] 1
	  end

        (** Do the set-up **)
	val _ = (case Default_Label of
		   (_, count) => count := 0)
	val rootvar = next_Matchvar()

        val pats = convert_form pat_exp

        (** Calculate the match tree **)
	val the_tree = (internal_match 
			options
                        (generate_swap_table options pats)
                        pats
			(S rootvar, (Default_Label, ERROR)))
        val (labels,error_present) = check_tree the_tree
        val redundant_clauses = get_redundant_clauses (Lists.length pat_exp,labels)
      in
        (rootvar,the_tree,redundant_clauses,error_present)
      end

(** General purpose routines for printing out the Trees. **)
    and unparseTree options tree space_out =
d1227 5
a1231 2
	fun unparseDef ABSENT _ = [ "Absent default" ]
	  | unparseDef (PRESENT t) n = "Present default of\n" :: (unparseTree options t n)
d1246 2
a1247 2
	    (rest @@ ["\n", space_out, "'", IdentPrint.printSCon m,
		     "' =>\n"] @@ unparseTree options vi ("  " ^ space_out))
d1252 10
a1261 3
	    (rest @@ ["\n", space_out, "'", IdentPrint.printLongValId options lvi,
		     "' --(#", Integer.makestring mv, ")\n"] @@
	     unparseTree options tr ("  " ^ space_out))
d1266 3
a1268 2
	     (list_subs ll [space_out, "LEAF ", AbsynPrint.unparseExp options exp, " {"]) @@ [" }"]
	 | SCON (mv, ll, def) =>
d1270 2
a1271 2
	     @@ ["\n", space_out] @@ (unparseDef def space_out)
	 | CONSTRUCTOR (_, mv, ll, def) =>
d1273 1
a1273 1
	     @@ ["\n", space_out] @@ (unparseDef def space_out)
d1276 1
a1276 7
	     @@ ["\n"] @@ (unparseTree options tr ("  " ^ space_out))
	 | LABEL ((num, ref lab), tr) =>
	     [space_out, "Lab $", Integer.makestring num, "$ rc=",
	      Integer.makestring lab, " --->\n"] @@ (unparseTree options tr space_out)
	 | GOTO (num, ref lab) =>
	     [space_out, "GOTO lab $", Integer.makestring num, "$ rc=",
	      Integer.makestring lab])
a1277 3
    and new_unparse_tree options (tree,space_out) =
      let
        val printValId = IdentPrint.printValId
d1279 1
a1279 15
        fun printLongValId options (Ident.LONGVALID (_,valid)) =
	      printValId options valid

	fun unparseDef ABSENT _ = [ ]
	  | unparseDef (PRESENT t) n = "ELSE\n" :: (new_unparse_tree options (t,n ^ "  "))

	fun list_subs [] rest = rest
	  | list_subs ((m, vi, _)::ll) rest =
	    list_subs ll
	    ([printValId options vi, "=#", Integer.makestring m," "] @@ rest)

	fun list_fields [] rest = rest
	  | list_fields ((m, vi)::ll) rest =
	    list_fields ll
	    (rest @@ [" '", IdentPrint.printLab m, "'=#", Integer.makestring vi])
a1280 5
	fun list_scons [] rest = rest
	  | list_scons ((m, vi)::ll) rest =
	    list_scons ll
	    (rest @@ ["\n", space_out^"  ", IdentPrint.printSCon m,
		     " =>\n"] @@ new_unparse_tree options (vi,("    " ^ space_out)))
a1281 32
	fun list_cons [] rest = rest
	  | list_cons ((lvi, mv, tr)::ll) rest =
	    list_cons ll
	    (rest @@
             ["\n", space_out^"  ", printLongValId options lvi] @@
             (if mv > 0 then [" #", Integer.makestring mv] else []) @@
             [" =>\n"] @@
	     new_unparse_tree options (tr,("    " ^ space_out)))
      in
	(case tree of
	   ERROR => [space_out, "ERROR"]
	 | LEAF (exp,n, ll) =>
             [space_out,"LEAF ",Integer.makestring n]
             (* [space_out,"LET "] @@ (list_subs ll ["IN LEAF ", AbsynPrint.unparseExp exp]) *)
	 | SCON (mv, ll, def) =>
	     (list_scons ll [space_out, "CASE #", Integer.makestring mv, " of"])
	     @@ ["\n", space_out] @@ (unparseDef def space_out)
	 | CONSTRUCTOR (_, mv, ll, def) =>
	     (list_cons ll [space_out, "CASE #", Integer.makestring mv," of "])
	     @@ ["\n", space_out] @@ (unparseDef def space_out)
	 | RECORD (_, mv, ll, tr) => 
             [space_out,"LET {"] @@
	     (list_fields ll []) @@
             ["} = #",Integer.makestring mv]
	     @@ ["\n"] @@ (new_unparse_tree options (tr,("  " ^ space_out)))
	 | LABEL ((num, ref lab), tr) =>
	     [space_out, "Lab $", Integer.makestring num, "$ rc=",
	      Integer.makestring lab, " --->\n"] @@ (new_unparse_tree options (tr,space_out))
	 | GOTO (num, ref lab) =>
	     [space_out, "GOTO lab $", Integer.makestring num, "$ rc=",
	      Integer.makestring lab])
      end
a1282 1
  end (* of functor Match *)
@


1.19
log
@Changed int and real scons to carry a location around
@
text
@d4 3
d540 1
a540 1
                   if scon = scon'
d556 1
a556 1
                   if Lists.member (scon,seenlist)
d779 3
d785 1
a785 1
	      if p = pat then
@


1.18
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d127 2
a128 2
	       Ident.INT s           => mkLONGVI s
	     | Ident.REAL s          => mkLONGVI s
@


1.17
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d99 1
a99 1
  sharing AbsynPrint.Absyn.IdentClass = Types.Datatypes.Ident = IdentPrint.Ident
@


1.16
log
@Changes to allow IntNewMap to be used on MatchVar
@
text
@d4 3
d96 1
d104 1
d866 2
a867 2
    fun internal_match _ [] _ = ERROR
      | internal_match swap_table pats lab =
d875 1
a875 1
	      internal_match swap_table (rev rest) (mat, lab)
d923 1
a923 1
					  internal_match swap_table same lab
d944 1
a944 1
		      ((lvi, Dummy_MV, internal_match swap_table same
d951 1
a951 1
			((lvi, newmatchvar, internal_match swap_table same
d976 1
a976 1
	      val thetype = get_type thepats
d1175 1
a1175 1
		      (internal_match swap_table the_new_pats
d1249 1
a1249 1
		   internal_match swap_table (rec_special pats [] (ref (get_type pats))) all)
d1257 1
a1257 1
		    val new_default = (the_new_label, internal_match swap_table back all)
d1261 1
a1261 1
		    internal_match swap_table front (match, new_default)
d1323 1
a1323 1
                map (fn x => (Print.print(AbsynPrint.unparsePat x ^ " "))) pat_list
d1360 1
a1360 1
    fun generate_swap_table pats =
d1422 1
a1422 1
                      implode(map AbsynPrint.unparsePat pat_list)
d1424 1
a1424 1
                      ^ implode(map AbsynPrint.unparsePat pat_list')
d1456 1
a1456 1
    fun compile_match pat_exp =
d1479 2
a1480 1
                        (generate_swap_table pats)
d1490 1
a1490 1
    and unparseTree tree space_out =
d1493 1
a1493 1
	  | unparseDef (PRESENT t) n = "Present default of\n" :: (unparseTree t n)
d1498 1
a1498 1
	    (rest @@ [" '", IdentPrint.printValId vi, "'/#", Integer.makestring m])
d1509 1
a1509 1
		     "' =>\n"] @@ unparseTree vi ("  " ^ space_out))
d1514 1
a1514 1
	    (rest @@ ["\n", space_out, "'", IdentPrint.printLongValId lvi,
d1516 1
a1516 1
	     unparseTree tr ("  " ^ space_out))
d1521 1
a1521 1
	     (list_subs ll [space_out, "LEAF ", AbsynPrint.unparseExp exp, " {"]) @@ [" }"]
d1530 1
a1530 1
	     @@ ["\n"] @@ (unparseTree tr ("  " ^ space_out))
d1533 1
a1533 1
	      Integer.makestring lab, " --->\n"] @@ (unparseTree tr space_out)
d1538 1
a1538 1
    and new_unparse_tree (tree,space_out) =
d1540 1
a1540 3
        fun printValId(Ident.VAR s) = Ident.Symbol.symbol_name s
          | printValId(Ident.CON s) = Ident.Symbol.symbol_name s
          | printValId(Ident.EXCON s) = Ident.Symbol.symbol_name s
d1542 2
a1543 1
        fun printLongValId (Ident.LONGVALID (_,valid)) = printValId valid
d1546 1
a1546 1
	  | unparseDef (PRESENT t) n = "ELSE\n" :: (new_unparse_tree(t,n ^ "  "))
d1551 1
a1551 1
	    ([printValId vi, "=#", Integer.makestring m," "] @@ rest)
d1562 1
a1562 1
		     " =>\n"] @@ new_unparse_tree(vi,("    " ^ space_out)))
d1568 1
a1568 1
             ["\n", space_out^"  ", printLongValId lvi] @@
d1571 1
a1571 1
	     new_unparse_tree(tr,("    " ^ space_out)))
d1588 1
a1588 1
	     @@ ["\n"] @@ (new_unparse_tree(tr,("  " ^ space_out)))
d1591 1
a1591 1
	      Integer.makestring lab, " --->\n"] @@ (new_unparse_tree(tr,space_out))
@


1.15
log
@Changed to use less than functions for maps.
@
text
@d4 3
d61 1
d82 1
d99 1
d267 2
a268 1
    fun referenced_only_once(_,x) = !x = 1
d1107 1
a1107 1
                        case NewMap.tryApply mapping lab of
@


1.14
log
@A type constraint was missing
@
text
@d4 3
d1096 1
a1096 1
                  val mapping = NewMap.empty' Ident.lab_order
@


1.13
log
@Allowed the compiler to change the order of the clauses if it could prove them to be disjoint
 Allowed the system to choose the order for looking at tuple elements (used to be left to right)
@
text
@d4 4
d1098 1
a1098 1
                          NewMap.YES x => x + y
@


1.12
log
@Changes to absyn
@
text
@d4 3
d86 1
d258 1
a258 1
    val do_reorder = ref false
a352 167
(** Find out branching factor information, and arity...

    These routines define the heuristics used to select the order to
    examine the fields of a record pattern.
**)
    fun branching_arity_factors labels all_rules =
      let

(** generate a list of all constructors in the pattern **)
	fun make_row [] rest = rest
	  | make_row ([]::ll) rest = make_row ll rest
	  | make_row (((lab, pat)::_)::ll) rest =
	    if (is_constructor_pat pat) then
	      make_row ll ((lab, The_construc pat)::rest)
	    else
	      make_row ll rest

(** Return 1 if there is a variable in the pattern, or 0 otherwise. **)
	fun variable_p [] = 0
	  | variable_p ([]::ll) = variable_p ll
	  | variable_p (((_, pat)::_)::ll) =
	    if (is_variable_pat pat) then
	      1
	    else
	      variable_p ll

	fun take [] rest = rev rest
	  | take ([]::ll) rest = take ll rest
	  | take ((_::m)::ll) rest =
	    take ll (m::rest)

(** remove all occurences of a constructor from a list of constructors **)
	fun remove _ [] rest = rest
	  | remove p ((l as (_, c))::cc) rest =
	    if p = c then
	      remove p cc rest
	    else
	      remove p cc (l::rest)

(** Count the number of unique constructors present, and print it if
    debug is true. **)
	fun count_con [] rest =
	  (debug ["In branch_f constructors present = ",
		  Integer.makestring rest, "\n"] ; rest)
	  | count_con ((_, head)::tail) rest =
	    count_con (remove head tail []) (rest + 1)

	fun the_label (((lab, _)::_)::_) = lab
	  | the_label (nil::_) = Crash.impossible "Werp1 can't find label"
	  | the_label nil = Crash.impossible "Werp2 can't find label"

	fun the_arity all =
	  let
	    fun make_full_row [] rest = rest
	      | make_full_row ([]::ll) rest = make_full_row ll rest
	      | make_full_row (((_, pat)::_)::ll) rest =
		make_full_row ll (pat::rest)

	    fun ar pat =
	      (case pat of
		 Absyn.WILDpat            => 0
	       | Absyn.SCONpat _          => 1
	       | Absyn.APPpat (_, p,_)      => 1 + ar p
	       | Absyn.RECORDpat (pl, _,_)  => Lists.length pl
	       | Absyn.TYPEDpat (p, _,_)    => ar p
	       | Absyn.LAYEREDpat (_, p)  => ar p
	       | Absyn.VALpat _           =>
		   if is_constructor_pat pat then 1 else 0)

	    fun arity [] n = n
	      | arity (head::tail) n =
		arity tail (n + ar head)
	  in
	    arity (make_full_row all []) 0
	  end

	fun branch [] rest = rest
	  | branch ([]::_) rest = rest
	  | branch head rest =
	    let
	      val the_list = make_row head []
	    in
	      branch (take head [])
	      ((the_label head,
		((variable_p head) + 2 * count_con the_list 0),
		the_arity head)::rest)
	    end

	val branch_fact = branch all_rules []

	fun replace [] rest _ = rest
	  | replace ((lab, n, m)::more) rest the_input =
	    let
	      fun repl [] all = all
		| repl ((l, nn)::t) all =
		  if l = lab then
		    repl t ((l, nn, n, m)::all)
		  else
		    repl t all
	    in
	      replace more (repl the_input rest) the_input
	    end

	fun internal [] rest = rev rest
	  | internal ((h, _)::t) rest =
	    internal t (h::rest)
      in
	replace branch_fact [] labels
      end

(** Find out which rules are most relevant.  Done by starting at the
    bottom of the patterns and looking upwards.  Each time we find a
    relevant pattern for a label, we replace it's older value with the
    new one.  The number returned is the height from the bottom of the
    patterns to the highest relevant pattern, or zero if none are
    relevant.  We treat RECORDs as not relevant, and don't expand them
    since record expansion is expensive, and we want to pospone this
    'til later if possible. **)
    fun relevant all =
      let
	fun add_l (all as (_, _)) [] rest = all::rest
	  | add_l (all as (lab, _)) ((test as (l, _))::t) rest =
	    if l = lab then
	      (all::(t @@ rest))
	    else
	      add_l all t (test::rest)

	fun nums [] _ rest = rest
	  | nums ((lab, h)::t) n rest =
	    if (is_constructor_pat h) then
	      nums t n (add_l (lab, n) rest [])
	    else
	      nums t n rest

	fun make_rest [] rest = rest
	  | make_rest ((lab, _)::t) rest =
	    make_rest t ((lab, 0)::rest)

	fun fit [] = []
	  | fit (all as (head::_)) =
	    let
	      val the_initial_rest = make_rest head []
	      fun generate [] _ rest = rest
		| generate (x::xs) n rest =
		  generate xs (n + 1) (nums x n rest)
	    in
	      generate all 1 the_initial_rest
	    end
      in
	fit (rev all)
      end

(** A function to determine the order of fields, based on the results
    returned by the the above tests.
**)
    fun heuristic_order ((l1, x1, x2, x3), (l2:Ident.Lab, y1:int, y2:int, y3:int)) =
      (if x1 = y1 then
	 if x2 = y2 then
	   if x3 = y3 then
	     Ident.lab_order(l1, l2) (* Just name order ! *)
	   else
	     x3 < y3  (* Arity, lowest best *)
	 else
	   x2 < y2    (* Branching, lowest best *)
       else
	 x1 > y1)     (* Relevant, highest best *)

d844 2
d847 2
a848 2
    fun internal_match [] _ = ERROR
      | internal_match pats lab =
d856 1
a856 1
	      internal_match (rev rest) (mat, lab)
d904 1
a904 1
					  internal_match same lab
d925 1
a925 1
		      ((lvi, Dummy_MV, internal_match same
d932 1
a932 1
			((lvi, newmatchvar, internal_match same
d996 1
a996 1
		    | internal [ (h, n1, n2, n3) ] =
d998 2
a999 4
			     Integer.makestring n1, ", ",
			     Integer.makestring n2, ", ",
			     Integer.makestring n3, ") ]\n" ]
		    | internal ((h, n1, n2, n3)::t) =
d1001 1
a1001 3
			      Integer.makestring n1, ", ",
			      Integer.makestring n2, ", ",
			      Integer.makestring n3, ") , " ] ;
d1014 1
a1014 1
		| just_labels ((lab, _, _, _)::more) rest =
d1085 25
d1121 2
a1122 1
		  (if (!do_reorder) andalso (number_of_fields > 1) then
d1126 3
a1128 3
			 Lists.qsort heuristic_order
			 (branching_arity_factors
			  (relevant rigidpats) rigidpats)
d1135 1
a1135 1
		       (debug ["Reordering record.\n"] ;
d1142 1
a1142 1
				print_fields (map (fn x => (x, 0,0,0))
d1156 1
a1156 1
		      (internal_match the_new_pats
d1230 1
a1230 1
		   internal_match (rec_special pats [] (ref (get_type pats))) all)
d1238 1
a1238 1
		    val new_default = (the_new_label, internal_match back all)
d1242 1
a1242 1
		    internal_match front (match, new_default)
d1260 58
d1320 1
d1323 7
d1340 77
d1418 19
d1456 2
d1459 3
a1461 1
	val the_tree = (internal_match (convert_form pat_exp)
@


1.11
log
@Took out various redundant structure arguments.
@
text
@d4 3
d90 2
a91 2
	Absyn.APPpat ((lvi, _), _)   => lvi
      | Absyn.VALpat (lvi, _)        => lvi
d102 1
a102 1
      | Absyn.TYPEDpat (p, _)        => The_construc p
d114 1
a114 1
      | Absyn.TYPEDpat (p, _)    => is_constructor_pat p
d116 1
a116 1
      | Absyn.VALpat (Ident.LONGVALID (_, vi), _) =>
d130 1
a130 1
      | Absyn.TYPEDpat (p, _)    => is_variable_pat p
d132 1
a132 1
      | Absyn.VALpat (Ident.LONGVALID (_, vi), _) =>
d144 2
a145 2
	    fun f_t (Absyn.VALpat (_, ref ty))        = ty
	      | f_t (Absyn.APPpat ((_, ref ty), _))   = ty
d148 1
a148 1
	      | f_t (Absyn.TYPEDpat (p, _))           = f_t p
d167 1
a167 1
	     | Absyn.TYPEDpat (p, _)  => rem_wild ((lab, p)::ll) rest bool
d411 1
a411 1
	       | Absyn.APPpat (_, p)      => 1 + ar p
d413 1
a413 1
	       | Absyn.TYPEDpat (p, _)    => ar p
d875 1
a875 1
	| Absyn.TYPEDpat (p, _)    => find_rules (([p], exp)::ll) rest
d877 1
a877 1
	| Absyn.VALpat (Ident.LONGVALID( _, val_id ), _) =>
d934 1
a934 1
	  fun addvp (Absyn.APPpat (_, newpat)) rest = newpat::rest
d959 1
a959 1
	   Absyn.TYPEDpat (p, _) => checkstart ((p::pats, tree)::pp) rest match
d1041 1
a1041 1
		    | Absyn.VALpat (Ident.LONGVALID(_, vi), ref ty) =>
d1048 1
a1048 1
		    | Absyn.TYPEDpat (pat, _) =>
d1084 1
a1084 1
		   (Absyn.VALpat (lvi, _)) =>
d1088 1
a1088 1
		 | (Absyn.APPpat ((lvi, _),newpat)) =>
d1359 1
a1359 1
		| rec_special (((Absyn.VALpat(Ident.LONGVALID(_, vi), _)::ll), more)::mm) rest ty =
@


1.10
log
@Fixed a problem with redundancy checking and record patterns
@
text
@d4 3
d39 1
a39 1
require "../utils/map";
a44 1
require "../basics/ident";
a45 1
require "../basics/absyn";
a46 1
require "../typechecker/datatypes";
a60 1
  structure Mapping : MAP
a66 1
  structure Ident : IDENT
a67 1
  structure Absyn : ABSYN
a68 1
  structure DataTypes : DATATYPES
d73 2
a74 4
  sharing DataTypes = Types.Datatypes = Absyn.Datatypes = Type_Utils.DataTypes
  sharing Mapping = DataTypes.Mapping
  sharing Absyn = AbsynPrint.Absyn
  sharing Absyn.IdentClass = DataTypes.Ident = Ident = IdentPrint.Ident
d77 3
a79 2
    structure DataTypes = DataTypes
    structure Absyn = Absyn
@


1.9
log
@Last version has redundancy checking commented out.  This is the real thing.
@
text
@d4 3
d382 1
a382 1
(** remove all occurances of a constructor from a list of constructors **)
d536 2
a537 1
fun subst_matchvar(mv1,mv2,tree) =
d539 2
a540 1
    fun subst1 mv = if mv = mv2 then mv1 else mv
d564 1
d600 2
d603 9
d627 1
a627 1
      | scan (RECORD (ty,mv,labels,tree),env) = scan(tree,env)
d630 30
d668 1
a668 1
        (case Lists.assoc(mv,env) of
d728 1
a728 1
        (case Lists.assoc(mv,env) of
d740 1
a740 1
                       scan(subst_matchvar(mvar,mvar',tree),env)
d776 1
a776 1
         | _ => Crash.impossible "Bad MatchVar Binding for scon in scan_tree")
@


1.8
log
@Changed interface to match compiler to for passing back of redundancy and exhaustiveness information
@
text
@d4 3
d1383 1
a1383 1
(** Do the set-up **)
d1388 1
a1388 1
(** Calculate the match tree **)
d1391 2
a1392 2
(*        val (labels,error_present) = check_tree the_tree
          val redundant_clauses = get_redundant_clauses (Lists.length pat_exp,labels) *)
d1394 1
a1394 2
(*        (rootvar,the_tree,redundant_clauses,error_present) *)
          (rootvar,the_tree,[],false)
@


1.7
log
@Changed length for Lists.length
@
text
@d4 3
d517 1
a517 1
      | LEAF of Absyn.Exp * (Matchvar * Ident.ValId * DataTypes.Type) list
d527 236
d1345 2
a1346 2
	     | [(_, ((exp, _), ll))]     =>  LEAF (exp, ll)
	     | ((_,((exp, _), ll))::_)  =>
d1348 1
a1348 1
		  LEAF (exp, ll))
d1386 1
a1386 1
	val The_Tree = (internal_match (convert_form pat_exp)
d1388 2
d1391 2
a1392 1
	(rootvar, The_Tree)
d1426 1
a1426 1
	 | LEAF (exp, ll) =>
d1440 59
@


1.6
log
@Added type_utils parameter
@
text
@d4 3
d405 1
a405 1
	       | Absyn.RECORDpat (pl, _,_)  => length pl
d773 1
a773 1
			       Integer.makestring (length same), "\n"]
d790 3
a792 3
		    print ["C same = ", Integer.makestring (length same), " l = ",
			   Integer.makestring (length ll), " all = ",
			   Integer.makestring (length all), "\n" ]
d934 1
a934 1
	      val thematchvars = make_matchvars (length needed_fields) []
d970 1
a970 1
	      val number_of_fields = length needed_fields
@


1.5
log
@updated code for finding out number of constructors to look at
length of domain of constructor environment. (tyname_id no longer has
no_of_cons field)
@
text
@d4 5
a23 4
require "../typechecker/datatypes";
require "../basics/absyn";
require "../basics/absynprint";
require "../typechecker/types";
d28 9
d48 16
a63 9
functor Match (structure Datatypes : DATATYPES
	       structure Absyn : ABSYN
	       structure AbsynPrint : ABSYNPRINT
	       structure Types : TYPES
	       structure Mapping : MAP
	       structure Integer : INTEGER
	       structure Lists : LISTS
	       structure Print : PRINT
	       structure Match_Utils : MATCH_UTILS
d65 8
a72 5
	       sharing Datatypes = Types.Datatypes = Absyn.Datatypes
	       sharing Mapping = Datatypes.Mapping
	       sharing Absyn = AbsynPrint.Absyn
	       sharing Absyn.IdentClass = Datatypes.Ident) : MATCH =
    struct
a73 29
      structure Datatypes = Datatypes
      structure Absyn = Absyn

      open Datatypes
(*
      open Match_utils
*)

      fun length l = Lists.length l
(** This exception is raised in places that we should not be able to
    reach from the code.  If this exception is raised, then there is
    probably a bug in the match compiler.  The string it returns
    contains information about what was happening when it all went
    wrong.
**)
      exception impossible of string

      fun get_cons_type ty = case ty of
	Datatypes.FUNTYPE(_, ty2) => ty2
      | Datatypes.CONSTYPE _ => ty
      | _ => raise (impossible "get_cons_type on non-constructed type")

      fun get_valenv(Datatypes.CONSTYPE(_,
       Datatypes.TYNAME(_, _, _, _, ref (Datatypes.VE(_, valenv))))) = valenv
	| get_valenv _ =
	  raise (impossible "bad ty in get_valenv")

      fun get_no_cons ty = length(Mapping.domain(get_valenv(get_cons_type ty)))

d78 17
a94 17
      fun The_construc pat =
	  case pat of
	    Absyn.APPpat ((lvi, _), _)   => lvi
	  | Absyn.VALpat (lvi, _)        => lvi
	  | Absyn.SCONpat scon           =>
	      let  (* fake a LONGVALID for a SCon. *)
		fun mkLONGVI s = Ident.LONGVALID
		  (Ident.mkPath [], Ident.VAR (Ident.Symbol.find_symbol s))
	      in
		(case scon of
		   Ident.INT s           => mkLONGVI s
		 | Ident.REAL s          => mkLONGVI s
		 | Ident.STRING s        => mkLONGVI s)
	      end
	  | Absyn.TYPEDpat (p, _)        => The_construc p
	  | Absyn.LAYEREDpat (_, p)      => The_construc p
	  | _ => raise impossible "Not a CONstructor, The_construc expected one"
d98 13
a110 13
      fun is_constructor_pat pat =
	  case pat of
	    Absyn.WILDpat            => false
	  | Absyn.SCONpat _          => true
	  | Absyn.APPpat _           => true
	  | Absyn.RECORDpat _        => false
	  | Absyn.TYPEDpat (p, _)    => is_constructor_pat p
	  | Absyn.LAYEREDpat (_, p)  => is_constructor_pat p
	  | Absyn.VALpat (Ident.LONGVALID (_, vi), _) =>
	      (case vi of
		 Ident.VAR _   => false
	       | Ident.CON _   => true
	       | Ident.EXCON _ => true)
d114 13
a126 13
      fun is_variable_pat pat =
	  case pat of
	    Absyn.WILDpat            => true
	  | Absyn.SCONpat _          => false
	  | Absyn.APPpat _           => false
	  | Absyn.RECORDpat _        => false
	  | Absyn.TYPEDpat (p, _)    => is_variable_pat p
	  | Absyn.LAYEREDpat (_, p)  => is_variable_pat p
	  | Absyn.VALpat (Ident.LONGVALID (_, vi), _) =>
	      (case vi of
		 Ident.VAR _   => true
	       | Ident.CON _   => false
	       | Ident.EXCON _ => false)
d129 4
a132 2
    list of list of patterns **)
      fun get_type all =
d134 6
a139 12
	    fun get_t (((pat::_), _)::rest) =
		let
		  fun f_t (Absyn.VALpat (_, ref ty))        = ty
		    | f_t (Absyn.APPpat ((_, ref ty), _))   = ty
		    | f_t (Absyn.RECORDpat (_, _, ref ty))  = ty
		    | f_t (Absyn.LAYEREDpat ((_, ref ty), _))= ty
		    | f_t (Absyn.TYPEDpat (p, _))           = f_t p
		    | f_t _                                 = get_t rest
		in
		  f_t pat
		end
	      | get_t _ = raise impossible "No pattern to get_type"
d141 1
a141 1
	    Types.the_type (get_t all)
d143 4
d151 13
a163 13
      fun make_flex (Absyn.RECORDpat (ll, bool, _)) =
	  let
	    fun rem_wild [] rest bool = (rest, bool)
	      | rem_wild ((head as (lab, pat))::ll) rest bool =
		(case pat of
		   Absyn.WILDpat          => rem_wild ll rest true
		 | Absyn.TYPEDpat (p, _)  => rem_wild ((lab, p)::ll) rest bool
		 | _                      => rem_wild ll (head::rest) bool)
	  in
	    rem_wild ll [] bool
	  end
	| make_flex _ =
	    raise impossible "Not a RECORD pattern in make_flex_record"
d166 9
a174 9
      fun make_flex_list [] rest = rev rest
	| make_flex_list (([], _)::_) _ =
	    raise impossible "Empty pattern found but RECORD expected"
	| make_flex_list (((head::_), _)::more) rest =
	  let
	    val fields = make_flex head
	  in
	    make_flex_list more (fields::rest)
	  end
d178 3
a180 3
      fun make_rigid (fields, false) _ = fields
	| make_rigid (fields, _) needed =
	  let
d183 6
a188 6
	    fun add_to first [] rest = ((first, Absyn.WILDpat)::rest)
	      | add_to first (fields as ((head as (one, _))::more)) rest =
		if first = one then
		  (fields @@ rest)
		else
		  add_to first more (head::rest)
d191 3
a193 3
	    fun add_field [] rest = rest
	      | add_field (first::more) rest =
		  add_field more (add_to first rest [])
d195 3
a197 3
	  in
	    add_field needed fields
	  end
d201 8
a208 8
      fun make_rigid_list do_sort all needed =
	  let
	    fun internal [] rest = rev rest
	      | internal (head::tail) rest =
		  internal tail ((do_sort (make_rigid head needed))::rest)
	  in
	    internal all []
	  end
d211 3
a213 3
      fun make_labels [] rest = rest
	| make_labels ((lab, _)::ll) rest =
	    make_labels ll (lab::rest)
d219 5
a223 5
      fun find_needed_labels [] rest = rest
	| find_needed_labels ((head, false)::_) _ = make_labels head []
	| find_needed_labels ((head, _)::more) rest =
	    find_needed_labels more (Match_Utils.union_lists rest
				     (make_labels head []))
d233 2
a234 2
      type Matchvar = int 
      type Label = (int * int ref)
d237 4
a240 4
      fun to_Matchvar(x) = x
      fun from_Matchvar(x) = x 
      fun label_number ((x,_)) = x 
      fun referenced_only_once ((_,x)) = (!x = 1)
d243 2
a244 2
      val do_debug = ref false
      val do_reorder = ref false
d247 2
a248 2
      val write = Print.print
      fun print the_list = (map write the_list; ())
d250 5
a254 5
      fun debug str =
	  if (!do_debug) then
	    print str
	  else
	    ()
d265 3
a267 3
      datatype VarMatch =
	  S of Matchvar |
	  D of VarMatch list
d272 26
a297 26
      fun get_NMatchvar (all as (S _)) = all
	| get_NMatchvar (D mm) =
	  let
	    fun inner [] = ([], true)
	      | inner [ S m ] = ([], false)
	      | inner [ D mm ] =
		let
		  val (foo, bool) = inner mm
		in
		  (case foo of
		     [] => ([], bool)
		   | _  => ([ D foo ], bool))
		end
	      | inner (m::mm) =
		let
		  val foo = inner [ m ]
		in
		  (case foo of
		     ([], true) => inner mm
		   | ([], _) => (mm, false)
		   | (it, _) => ((it @@ mm), false))
		end
	    val (done, _) = inner mm
	  in
	    D done
	  end
d301 9
a309 9
      fun get_SMatchvar (S m) = m   (* just what we want *)
	| get_SMatchvar (D mm) =
	  let
	    fun inner [] = raise impossible "Missing matchvar in get_SMatchvar"
	      | inner ((S m)::_) = m
	      | inner ((D m)::more) = inner (m @@ more)
	  in
	    inner mm
	  end
d314 24
a337 24
      fun replace_SMatchvar (S _) mat = mat
	| replace_SMatchvar (D mm) mat =
	  let
	    fun inner [] = []
	      | inner [ S _ ] = [ mat ]
	      | inner [ D mm ] =
		let
		  val foo = inner mm
		in
		  (case foo of
		     [] => []
		   | _  => [ D foo ])
		end
	      | inner (m::mm) =
		let
		  val foo = inner [ m ]
		in
		  (case foo of
		     [] => inner mm
		   | it => (it @@ mm))
		end
	  in
	    D (inner mm)
	  end
d344 2
a345 2
      fun branching_arity_factors labels all_rules =
	  let
d348 7
a354 7
	    fun make_row [] rest = rest
	      | make_row ([]::ll) rest = make_row ll rest
	      | make_row (((lab, pat)::_)::ll) rest =
		if (is_constructor_pat pat) then
		  make_row ll ((lab, The_construc pat)::rest)
		else
		  make_row ll rest
d357 7
a363 7
	    fun variable_p [] = 0
	      | variable_p ([]::ll) = variable_p ll
	      | variable_p (((_, pat)::_)::ll) =
		if (is_variable_pat pat) then
		  1
		else
		  variable_p ll
d365 4
a368 4
	    fun take [] rest = rev rest
	      | take ([]::ll) rest = take ll rest
	      | take ((_::m)::ll) rest =
		  take ll (m::rest)
d371 6
a376 6
	    fun remove _ [] rest = rest
	      | remove p ((l as (_, c))::cc) rest =
		if p = c then
		  remove p cc rest
		else
		  remove p cc (l::rest)
d380 5
a384 5
	    fun count_con [] rest =
		  (debug ["In branch_f constructors present = ",
			  Integer.makestring rest, "\n"] ; rest)
	      | count_con ((_, head)::tail) rest =
		  count_con (remove head tail []) (rest + 1)
d386 3
a388 3
	    fun the_label (((lab, _)::_)::_) = lab
	      | the_label (nil::_) = raise impossible "Werp1 can't find label"
	      | the_label nil = raise impossible "Werp2 can't find label"
d390 6
a395 6
	    fun the_arity all =
		let
		  fun make_full_row [] rest = rest
		    | make_full_row ([]::ll) rest = make_full_row ll rest
		    | make_full_row (((_, pat)::_)::ll) rest =
			make_full_row ll (pat::rest)
d397 10
a406 10
		  fun ar pat =
		      (case pat of
			 Absyn.WILDpat            => 0
		       | Absyn.SCONpat _          => 1
		       | Absyn.APPpat (_, p)      => 1 + ar p
		       | Absyn.RECORDpat (pl, _,_)  => length pl
		       | Absyn.TYPEDpat (p, _)    => ar p
		       | Absyn.LAYEREDpat (_, p)  => ar p
		       | Absyn.VALpat _           =>
			   if is_constructor_pat pat then 1 else 0)
d408 6
a413 6
		  fun arity [] n = n
		    | arity (head::tail) n =
			arity tail (n + ar head)
		in
		  arity (make_full_row all []) 0
		end
d415 11
a425 11
	    fun branch [] rest = rest
	      | branch ([]::_) rest = rest
	      | branch head rest =
		let
		  val the_list = make_row head []
		in
		  branch (take head [])
		  ((the_label head,
		    ((variable_p head) + 2 * count_con the_list 0),
		    the_arity head)::rest)
		end
d427 1
a427 1
	    val branch_fact = branch all_rules []
d429 12
a440 12
	    fun replace [] rest _ = rest
	      | replace ((lab, n, m)::more) rest the_input =
		let
		  fun repl [] all = all
		    | repl ((l, nn)::t) all =
		      if l = lab then
			repl t ((l, nn, n, m)::all)
		      else
			repl t all
		in
		  replace more (repl the_input rest) the_input
		end
d442 6
a447 6
	    fun internal [] rest = rev rest
	      | internal ((h, _)::t) rest =
		  internal t (h::rest)
	  in
	    replace branch_fact [] labels
	  end
d457 8
a464 8
      fun relevant all =
	  let
	    fun add_l (all as (_, _)) [] rest = all::rest
	      | add_l (all as (lab, _)) ((test as (l, _))::t) rest =
		if l = lab then
		  (all::(t @@ rest))
		else
		  add_l all t (test::rest)
d466 6
a471 6
	    fun nums [] _ rest = rest
	      | nums ((lab, h)::t) n rest =
		if (is_constructor_pat h) then
		  nums t n (add_l (lab, n) rest [])
		else
		  nums t n rest
d473 3
a475 3
	    fun make_rest [] rest = rest
	      | make_rest ((lab, _)::t) rest =
		  make_rest t ((lab, 0)::rest)
d477 13
a489 13
	    fun fit [] = []
	      | fit (all as (head::_)) =
		let
		  val the_initial_rest = make_rest head []
		  fun generate [] _ rest = rest
		    | generate (x::xs) n rest =
			generate xs (n + 1) (nums x n rest)
		in
		  generate all 1 the_initial_rest
		end
	  in
	    fit (rev all)
	  end
d494 5
a498 9
      fun heuristic_order ((l1, x1, x2, x3), (l2:Ident.Lab, y1:int, y2:int, y3:int)) =
	  (if x1 = y1 then
	     if x2 = y2 then
	       if x3 = y3 then
		 Ident.lab_order(l1, l2) (* Just name order ! *)
	       else
		 x3 < y3  (* Arity, lowest best *)
	     else
	       x2 < y2    (* Branching, lowest best *)
d500 5
a504 1
	     x1 > y1)     (* Relevant, highest best *)
d509 9
a517 9
      datatype Tree =
	  ERROR
	| LEAF of Absyn.Exp * (Matchvar * Ident.ValId * Type) list
	| SCON of Matchvar * (Ident.SCon * Tree) list * Default
	| CONSTRUCTOR of Type * Matchvar *
	  (Ident.LongValId * Matchvar * Tree) list * Default
	| RECORD of Type * Matchvar * (Ident.Lab * Matchvar) list * Tree
	| LABEL of Label * Tree
	| GOTO of Label
d519 1
a519 1
      and Default = PRESENT of Tree | ABSENT
d522 1
a522 1
      fun refered_to ((_, ref label):Label) = (label > 0)
d526 7
a532 5
      fun make_counter x =
	  let val foo = ref x   (* the initial value of the counter *)
	  in
	    (fn () => (foo := (!foo) + 1; (!foo)))
	  end
d534 10
a543 6
      val next_Label =
	  let
	    val counter = make_counter 0
	  in
	    fn () => (counter (), ref 0) : Label
	  end
d545 7
a551 4
      val next_Matchvar = (make_counter 0):(unit -> Matchvar)
      val Dummy_MV = (~1):Matchvar         (* for use in nullary constructors *)
      val Dummy_Label = (0, ref 0):Label   (* for use in mixture_rule *)
      val Default_Label = next_Label ()
d554 7
a560 7
      datatype Rules = 
	  Variable_rule
	| Constructor_rule
	| Scon_rule
	| Record_rule
	| Mixture_rule
	| Empty_rule
d567 6
a572 6
      fun share_lab (label as (_, count), tree) =
	    (count := (!count) + 1 ; 
	     if (!count = 1) then
	       LABEL(label, tree)
	     else
	       GOTO label)
d577 15
a591 15
      fun find_rules [] rest = rest
	| find_rules (([], _)::ll) rest = Empty_rule::(find_rules ll rest)
	| find_rules ((pattern::pats, exp)::ll) rest =
	  case pattern of
	    Absyn.WILDpat            => Variable_rule::(find_rules ll rest)
	  | Absyn.SCONpat _          => Scon_rule::(find_rules ll rest)
	  | Absyn.RECORDpat _        => Record_rule::(find_rules ll rest)
	  | Absyn.APPpat _           => Constructor_rule::(find_rules ll rest)
	  | Absyn.TYPEDpat (p, _)    => find_rules (([p], exp)::ll) rest
	  | Absyn.LAYEREDpat (_, p)  => find_rules (([p], exp)::ll) rest 
	  | Absyn.VALpat (Ident.LONGVALID( _, val_id ), _) =>
	      (case val_id of   (* VAR, CON, or EXCON -- choose the right rule *)
		 Ident.VAR _            => Variable_rule::(find_rules ll rest)
	       | Ident.CON _            => Constructor_rule::(find_rules ll rest)
	       | Ident.EXCON _          => Constructor_rule::(find_rules ll rest))
d597 8
a604 8
      fun choose_rule [ single ] = single
	| choose_rule (first::((rest as (second::_)))) =
	  if (first = second) then
	    choose_rule rest
	  else
	    Mixture_rule
	| choose_rule [] =
	    raise impossible "Empty list of rules in choose_rule" 
d618 15
a632 15
      fun SCONsplit [] = raise impossible "Empty pattern list in SCONsplit"
	| SCONsplit (all as ([], _)::_) =
	    raise impossible "No pattern in list in SCONsplit"
	| SCONsplit ((pat::pats, tree)::pl) =  (* this is the one *)
	  let
	    fun insplit [] (p1, p2) = (rev p1, rev p2, pat)
	      | insplit (([], _)::pl) rest = insplit pl rest
	      | insplit ((pats as(p::pp, tree))::pl) (p1, p2) =
		if p = pat then
		  insplit pl ((pp, tree)::p1, p2)
		else
		  insplit pl (p1, pats::p2)
	  in  (* go for it *)
	    insplit pl ([(pats, tree)], [])
	  end
d638 5
a642 5
      fun CONsplit [] = raise impossible "Empty pattern list in CONsplit"
	| CONsplit (all as ([], _)::_) =
	    raise impossible "No pattern in list in CONsplit"
	| CONsplit ((pat::pats, tree)::pl) =  (* this is the one *)
	  let
d644 2
a645 2
	    fun addvp (Absyn.APPpat (_, newpat)) rest = newpat::rest
	      | addvp _ rest = rest
d647 1
a647 1
	    val check = The_construc pat
d649 10
a658 10
	    fun insplit [] (p1, p2) = (rev p1, rev p2, pat)
	      | insplit (([], _)::pl) rest = insplit pl rest
	      | insplit ((pats as(p::pp, tree))::pl) (p1, p2) =
		if (The_construc p) = check then
		  insplit pl ((addvp p pp, tree)::p1, p2)
		else
		  insplit pl (p1, pats::p2)
	  in  (* go for it *)
	    insplit pl ([(addvp pat pats, tree)], [])
	  end
d664 14
a677 14
      fun checkstart [] rest _ = rev rest
	| checkstart ((head as ([], _))::pp) rest match =
	    checkstart pp (head::rest) match
	| checkstart ((head as (pat::pats, tree as (exp, subs)))::pp) rest match =
	  (case pat of
	     Absyn.TYPEDpat (p, _) => checkstart ((p::pats, tree)::pp) rest match
	   | Absyn.LAYEREDpat ((vi, ref ty), p) =>
	       (debug ["matchvar = ",
		       Integer.makestring (get_SMatchvar match),
		       "\n" ];
		checkstart ((p::pats,
			     (exp, (get_SMatchvar match, vi, ty)::subs))::pp)
		rest match)
	   | _ => checkstart pp (head::rest) match)
d680 4
a683 4
      fun all_constructors_present [] _ = false
	| all_constructors_present (([], _)::_) _ = false
	| all_constructors_present ll thetype =
	  let
d686 3
a688 3
	    val Arity = get_no_cons thetype
	    val _ = debug ["Arity of constructor is ",
			   Integer.makestring Arity, "\n"]
d691 4
a694 4
	    fun make_l [] rest = rest
	      | make_l (([], _)::ll) rest = make_l ll rest
	      | make_l ((pat::_, _)::ll) rest =
		  make_l ll ((The_construc pat)::rest)
d696 7
a702 7
(** remove all occurances of a constructor from a list of constructors **)
	    fun remove _ [] rest = rest
	      | remove p (c::cc) rest =
		if p = c then
		  remove p cc rest
		else
		  remove p cc (c::rest)
d706 6
a711 6
	    fun count [] rest =
		  (debug ["constructors present = ",
			  Integer.makestring rest, "\n"] ;
		   rest)
	      | count (head::tail) rest =
		  count (remove head tail []) (rest + 1)
d713 3
a715 3
	  in      (* Do we have all the constructors ? *)
	    ((count (make_l ll []) 0) = Arity)
	  end
d718 3
a720 3
      fun internal_match [] _ = ERROR
	| internal_match pats lab =
	  let
d723 18
a740 18
	    fun variable_rule [] rest (match, lab) =
		let
		  val mat = get_NMatchvar match
		in
		  internal_match (rev rest) (mat, lab)
		end
	      | variable_rule (([], _)::_) _ _ =
		  raise impossible "Empty pattern in variable_rule"
	      | variable_rule ((pat::pats, (tree as (exp, subs)))::pl)
		rest (vars as (match, lab)) =
		let val redundant =
			(case pats of
			   [] => (case pl of
				  [] => false
				| _  => true)
			 | _  => false)
		in
		  if redundant then
d745 8
a752 8
		  else
		    let
		      val mat = get_SMatchvar match
		    in 
		      case pat of
			Absyn.WILDpat => variable_rule pl ((pats, tree)::rest) vars
		      | Absyn.VALpat (Ident.LONGVALID(_, vi), ref ty) =>
			  variable_rule pl ((pats, (exp, (mat, vi, ty)::subs))::rest) vars
d755 2
a756 2
		      | Absyn.LAYEREDpat ((vi, ref ty), pat) =>
			  variable_rule (((pat::pats), (exp, (mat, vi, ty)::subs))::pl)rest vars
d758 5
a762 5
		      | Absyn.TYPEDpat (pat, _) =>
			  variable_rule (((pat::pats), tree)::pl) rest vars
		      | _ => raise impossible "Missing Variable-pattern in variable_rule"
		    end
		end
d765 14
a778 14
	    fun make_SCtree_list [] rest lab = rev rest
	      | make_SCtree_list all rest lab =
		let
		  val (same, ll, pat) = SCONsplit all 
		  val _ = debug ["S same = ",
				 Integer.makestring (length same), "\n"]
		in
		  case pat of
		    (Absyn.SCONpat scp) =>
		      make_SCtree_list ll ((scp,
					    internal_match same lab
					    )::rest) lab
		  | _ => raise impossible "Not SCON pattern in SCON matching"
		end
d781 21
a801 14
	    fun make_COtree_list [] rest lab = rev rest
	      | make_COtree_list all rest (lab as (matches, lm)) =
		let
		  val (same, ll, pat) = CONsplit all 
		  val _ = (* output debugging messages. *)
		      if (!do_debug) then
			print ["C same = ", Integer.makestring (length same), " l = ",
			       Integer.makestring (length ll), " all = ",
			       Integer.makestring (length all), "\n" ]
		      else
			()
		in
		  (case pat of
		     (Absyn.VALpat (lvi, _)) =>
d803 7
a809 14
			((lvi, Dummy_MV, internal_match same
			  (get_NMatchvar matches, lm))::rest) lab)
		   | (Absyn.APPpat ((lvi, _),newpat)) =>
		       let
			 val newmatchvar = next_Matchvar ()
		       in
			 (make_COtree_list ll
			  ((lvi, newmatchvar, internal_match same
			    (replace_SMatchvar matches
			     (S newmatchvar), lm))::rest) lab)
		       end
		   | _ => raise impossible "Not Constructor pattern in CON matching"
		       )
		end
d813 8
a820 8
	    fun scon_rule pats (match, lab) =
		let
		  val thepats = checkstart pats [] match
		in
		  SCON (get_SMatchvar match,
			make_SCtree_list thepats [] (get_NMatchvar match, lab),
			PRESENT (share_lab lab))
		end
d825 15
a839 15
	    fun constructor_rule pats (rest as (match, lab)) =
		let
		  val thepats = checkstart pats [] match
		  val thetype = get_type thepats
		  val default_tree =
		      if (all_constructors_present thepats thetype) then
			ABSENT
		      else
			PRESENT (share_lab lab)
		in
		  CONSTRUCTOR (thetype, get_SMatchvar match,
			       make_COtree_list thepats []
			       rest,
			       default_tree)
		end
d847 7
a853 7
	    fun record_rule pats (match, lab) =
		let
		  fun our_order ((x, _), (y, _)) = Ident.lab_order(x, y)
		  val sort_fields = Lists.qsort our_order
		  val the_old_match = get_SMatchvar match
		  val thepats = checkstart pats [] match
		  val thetype = get_type thepats
d855 6
a860 6
		  val flexpats = make_flex_list thepats []
		  val needed_fields =
		    Lists.qsort
		    Ident.lab_order
		    (find_needed_labels flexpats [])
		  val rigidpats = make_rigid_list sort_fields flexpats needed_fields
d864 20
a883 20
		  fun print_fields f =
		      let
			fun internal [] = write " ]\n"
			  | internal [ (h, n1, n2, n3) ] =
			      print ["'", IdentPrint.printLab h, "':( ",
				     Integer.makestring n1, ", ",
				     Integer.makestring n2, ", ",
				     Integer.makestring n3, ") ]\n" ]
			  | internal ((h, n1, n2, n3)::t) =
			      (print ["'", IdentPrint.printLab h, "':( ",
				      Integer.makestring n1, ", ",
				      Integer.makestring n2, ", ",
				      Integer.makestring n3, ") , " ] ;
			       internal t)
		      in
			if (!do_debug) then
			  (write "Selected fields are: [ "; internal f)
			else
			  ()
		      end
d888 3
a890 3
		  fun just_labels [] rest = rest
		    | just_labels ((lab, _, _, _)::more) rest =
			just_labels more (lab::rest)
d894 3
a896 3
		  fun make_newpatterns [] patterns = rev patterns
		    | make_newpatterns (lab::t) patterns =
		      let
d899 5
a903 5
			fun merge [] _ rest = rev rest
			  | merge (l::ls) [] rest =
			      merge ls [] ([l]::rest)
			  | merge (l::ls) (h::hs) rest =
			      merge ls hs ((l::h)::rest)
d906 18
a923 18
			fun get_patterns [] rest = rest
			  | get_patterns (nil::more) rest =
			      get_patterns more rest
			  | get_patterns (head::tail) rest =
			    let
			      fun get_pat [] rest = rest
				| get_pat ((l, pat)::more) rest =
				  if lab = l then
				    (pat::rest)
				  else
				    get_pat more rest
			    in
			      get_patterns tail (get_pat head rest)
			    end
		      in
			make_newpatterns t
			(merge (get_patterns rigidpats []) patterns [])
		      end
d926 3
a928 3
		  fun make_matchvars 0 rest = rest
		    | make_matchvars n rest =
			make_matchvars (n - 1) (next_Matchvar()::rest)
d931 1
a931 1
		  val thematchvars = make_matchvars (length needed_fields) []
d934 3
a936 3
		  fun patterns [] rest = rev rest
		    | patterns ((_, head)::tail) rest =
			patterns tail (head::rest)
d940 6
a945 6
		  fun add_patt [] _ rest = rev rest
		    | add_patt _ [] rest = rev rest
		    | add_patt (h::t) (([], more)::b) rest =
			add_patt t b ((patterns h [], more)::rest)
		    | add_patt (h::t) (((_::a), more)::b) rest =
			add_patt t b ((((patterns h []) @@ a), more)::rest)
d947 6
a952 6
		  fun add_reordered [] _ rest = rev rest
		    | add_reordered _ [] rest = rev rest
		    | add_reordered (h::t) (([], more)::b) rest =
			add_reordered t b ((h, more)::rest)
		    | add_reordered (h::t) (((_::a), more)::b) rest =
			add_reordered t b (((h @@ a), more)::rest)
d954 5
a958 5
		  fun add_empty [] rest = rev rest
		    | add_empty ((m as ([], _))::b) rest =
			add_empty b (m::rest)
		    | add_empty (((_::a), more)::b) rest =
			add_empty b ((a, more)::rest)
d962 4
a965 4
		  fun merge_in [] _ rest = rev rest
		    | merge_in _ [] rest = rev rest
		    | merge_in (h::t) (a::b) rest =
			merge_in t b ((h, a)::rest)
d967 1
a967 1
		  val number_of_fields = length needed_fields
d969 4
a972 4
		  val (the_new_pats, matchlabs) =
		      if number_of_fields > 0 then
			(if (!do_reorder) andalso (number_of_fields > 1) then
			   let
d974 4
a977 4
			     val ordered_fields =
				   Lists.qsort heuristic_order
				   (branching_arity_factors
				    (relevant rigidpats) rigidpats)
d979 1
a979 1
			     val _ = print_fields ordered_fields
d981 20
a1000 20
			     val reordered_labels = just_labels ordered_fields []
			     val reordered_patterns = make_newpatterns reordered_labels []
			   in
			     (debug ["Reordering record.\n"] ;
			      (add_reordered reordered_patterns thepats [],
			       merge_in (rev reordered_labels) thematchvars []))
			   end
			 else
			   let
			     val _ = (debug ["Not reordering record fields\n"] ;
				      print_fields (map (fn x => (x, 0,0,0))
						    needed_fields))
			   in
			     (add_patt rigidpats thepats [],
			      merge_in needed_fields thematchvars [])
			   end)
		      else
			(debug ["Empty record, no needed fields.\n"] ;
			 (add_empty thepats [], []))
		in
d1004 5
a1008 5
		  RECORD (thetype, the_old_match, matchlabs,
			  (internal_match the_new_pats
			   (replace_SMatchvar match
			    (D (map (fn x => S x) thematchvars)), lab)))
		end
d1012 2
a1013 2
	    fun mixture_rule pats (all as (match, lab)) the_rules =
		let
d1016 12
a1027 12
		  fun count [] = 0
		    | count (head::rest) =
		      let
			fun internal [] num = num
			  | internal (top::tail) num =
			    if top = head then
			      internal tail (num + 1)
			    else
			      num
		      in
			internal rest 1
		      end
d1030 13
a1042 13
		  fun samelist [] _ = []
		    | samelist (all as (head::_)) rules =
		      let
			fun internal [] _ rest = rev rest
			  | internal _ [] rest = rev rest
			  | internal (first::more) (a::b) rest =
			    if (first = head) then
			      internal more b (a::rest)
			    else
			      internal more b rest
		      in
			internal all rules []
		      end
d1045 9
a1053 9
		  fun split n all =
		      let
			fun internal 0 (first, rest) = (rev first, rest)
			  | internal n (first, []) = (rev first, [])
			  | internal n (first, (head::tail)) =
			      internal (n - 1) ((head::first), tail)
		      in
			internal n ([], all)
		      end
d1055 2
a1056 2
		  fun recordp (Record_rule::_) = true
		    | recordp _ = false
d1058 2
a1059 2
		  fun variablep (Variable_rule::_) = true
		    | variablep _ = false
d1066 8
a1073 8
		  fun rec_special [] rest _ = rev rest
		    | rec_special (((Absyn.WILDpat::ll), more)::mm) rest ty =
			rec_special mm (((Absyn.RECORDpat ([], true, ty))::ll, more)::rest) ty
		    | rec_special (((Absyn.VALpat(Ident.LONGVALID(_, vi), _)::ll), more)::mm) rest ty =
			rec_special mm (((Absyn.LAYEREDpat ((vi, ty), Absyn.RECORDpat ([], true, ty)))::ll, more)::rest) ty
		    | rec_special (any::mm) rest ty =
			rec_special mm (any::rest) ty
			
d1076 9
a1084 9
		  val the_tree =
		      if (recordp the_rules) then  (* special case with records *)
			(debug [ "Record special mixture\n" ];
			 internal_match (rec_special pats [] (ref (get_type pats))) all)
		      else
			let
			  val number_of_rules = count the_rules
			  val (front, back) = split number_of_rules pats
			  val the_new_label = next_Label ()
d1087 1
a1087 1
			  val new_default = (the_new_label, internal_match back all)
d1089 1
a1089 1
			in
d1091 5
a1095 5
			  internal_match front (match, new_default)
			end
		in
		  the_tree
		end
d1100 8
a1107 8
	    fun empty_rule pats (_, lab) =
		(case pats of
		   []                        =>  share_lab lab
		 | [(_, ((exp, _), ll))]     =>  LEAF (exp, ll)
		 | ((_,((exp, _), ll))::_)  =>
		     (debug ["redundant patterns ignored in empty-rule\n"] ;
		      LEAF (exp, ll))
		     )
d1110 2
a1111 2
	    val rule_list = find_rules pats []
	    val the_rule = choose_rule (rule_list)
d1113 9
a1121 9
	  in
	    case the_rule of
	      Variable_rule      =>  variable_rule pats [] lab
	    | Constructor_rule   =>  constructor_rule pats lab
	    | Scon_rule          =>  scon_rule pats lab
	    | Record_rule        =>  record_rule pats lab
	    | Mixture_rule       =>  mixture_rule pats lab rule_list
	    | Empty_rule         =>  empty_rule pats lab
	  end
d1124 2
a1125 2
      fun compile_match pat_exp =
	  let
d1129 8
a1136 8
	    fun convert_form all =
		let
		  fun internal [] rest _ = rev rest
		    | internal ((a, b)::ll) rest n =
			internal ll (([ a ], ((b, n), []))::rest) (n + 1)
		in
		  internal all [] 1
		end
d1139 3
a1141 3
	    val _ = (case Default_Label of
		     (_, count) => count := 0)
	    val rootvar = next_Matchvar()
d1144 5
a1148 5
	    val The_Tree = (internal_match (convert_form pat_exp)
			    (S rootvar, (Default_Label, ERROR)))
	  in
	    (rootvar, The_Tree)
	  end
d1151 4
a1154 4
      and unparseTree tree space_out =
	  let
	    fun unparseDef ABSENT _ = [ "Absent default" ]
	      | unparseDef (PRESENT t) n = "Present default of\n" :: (unparseTree t n)
d1156 4
a1159 4
	    fun list_subs [] rest = rest
	      | list_subs ((m, vi, _)::ll) rest =
		  list_subs ll
		  (rest @@ [" '", IdentPrint.printValId vi, "'/#", Integer.makestring m])
d1161 4
a1164 4
	    fun list_fields [] rest = rest
	      | list_fields ((m, vi)::ll) rest =
		  list_fields ll
		  (rest @@ [" '", IdentPrint.printLab m, "'=#", Integer.makestring vi])
d1166 5
a1170 5
	    fun list_scons [] rest = rest
	      | list_scons ((m, vi)::ll) rest =
		  list_scons ll
		  (rest @@ ["\n", space_out, "'", IdentPrint.printSCon m,
			   "' =>\n"] @@ unparseTree vi ("  " ^ space_out))
d1172 27
a1198 27
	    fun list_cons [] rest = rest
	      | list_cons ((lvi, mv, tr)::ll) rest =
		  list_cons ll
		  (rest @@ ["\n", space_out, "'", IdentPrint.printLongValId lvi,
			   "' --(#", Integer.makestring mv, ")\n"] @@
		   unparseTree tr ("  " ^ space_out))
	  in
	    (case tree of
	       ERROR => [space_out, "ERROR"]
	     | LEAF (exp, ll) =>
		 (list_subs ll [space_out, "LEAF ", AbsynPrint.unparseExp exp, " {"]) @@ [" }"]
	     | SCON (mv, ll, def) =>
		 (list_scons ll [space_out, "SCON #", Integer.makestring mv])
		 @@ ["\n", space_out] @@ (unparseDef def space_out)
	     | CONSTRUCTOR (_, mv, ll, def) =>
		 (list_cons ll [space_out, "CONSTRUCTOR #", Integer.makestring mv])
		 @@ ["\n", space_out] @@ (unparseDef def space_out)
	     | RECORD (_, mv, ll, tr) => 
		 (list_fields ll [space_out, "RECORD #", Integer.makestring mv])
		 @@ ["\n"] @@ (unparseTree tr ("  " ^ space_out))
	     | LABEL ((num, ref lab), tr) =>
		 [space_out, "Lab $", Integer.makestring num, "$ rc=",
		  Integer.makestring lab, " --->\n"] @@ (unparseTree tr space_out)
	     | GOTO (num, ref lab) =>
		 [space_out, "GOTO lab $", Integer.makestring num, "$ rc=",
		  Integer.makestring lab])
	  end
d1200 1
a1200 1
    end (* of functor Match *)
@


1.4
log
@Changed references to Match_utils.Qsort to Lists.qsort
@
text
@d3 4
a6 1
$Log:	_match.sml,v $
d71 4
d76 7
a684 9
(** Return the part of a type used to look up the constructor arity, if
    it is present. **)
	    fun get_tyname ty =
		(case ty of
		   CONSTYPE (_, t) => t
		 | FUNTYPE  (_, t) => get_tyname t
		 | _ =>
		     raise impossible "Not a CONSTYPE in all_constructors_present")

d686 1
a686 1
	    val Arity = Types.no_of_cons (get_tyname thetype)
@


1.3
log
@Added copyright message
@
text
@d4 3
d43 1
a43 1
	       structure Match_utils : MATCH_UTILS
d55 1
d57 1
d217 1
a217 1
	    find_needed_labels more (union_lists rest
d845 1
a845 1
		  val sort_fields = Qsort our_order
d851 4
a854 1
		  val needed_fields = Qsort Ident.lab_order (find_needed_labels flexpats [])
d970 1
a970 1
				   Qsort heuristic_order
@


1.2
log
@Changed match tree to give LongValIds rather than ValIds in CONSTRUCTOR
nodes - needed to code generate longexcons where the path must be kept
@
text
@d1 1
d4 4
d11 1
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d498 1
a498 1
	  (Ident.ValId * Matchvar * Tree) list * Default
d778 1
a778 1
		     (Absyn.VALpat ((Ident.LONGVALID(_, vi), _))) =>
d780 1
a780 1
			((vi, Dummy_MV, internal_match same
d782 1
a782 1
		   | (Absyn.APPpat (((Ident.LONGVALID(_, vi), _)), newpat)) =>
d787 1
a787 1
			  ((vi, newmatchvar, internal_match same
d1154 1
a1154 1
	      | list_cons ((vi, mv, tr)::ll) rest =
d1156 1
a1156 1
		  (rest @@ ["\n", space_out, "'", IdentPrint.printValId vi,
@
