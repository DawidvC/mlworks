head	1.17;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.1
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.17
	MLWorks_20c0_1998_08_04:1.17
	MLWorks_20b2c2_1998_06_19:1.17
	MLWorks_20b2_Windows_1998_06_12:1.17
	MLWorks_20b1c1_1998_05_07:1.17
	MLWorks_20b0_1998_04_07:1.17
	MLWorks_20b0_1998_03_20:1.17
	MLWorks_20m2_1998_02_16:1.16
	MLWorks_20m1_1997_10_23:1.16
	MLWorks_11r1:1.15.5.1.1.1.1
	MLWorks_workspace_97:1.16.2
	MLWorks_dt_wizard:1.16.1
	MLWorks_11c0_1997_09_09:1.15.5.1.1.1
	MLWorks_10r3:1.15.5.1.3
	MLWorks_10r2_551:1.15.5.1.2
	MLWorks_11:1.15.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.5.1
	MLWorks_20m0_1997_06_20:1.16
	MLWorks_1_0_r2c2_1997_06_14:1.15.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.5
	MLWorks_BugFix_1997_04_24:1.15
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.3.1.1
	MLWorks_gui_1996_12_18:1.15.4
	MLWorks_1_0_Win32_1996_12_17:1.15.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.1.1
	MLWorks_1_0_Irix_1996_11_28:1.15.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.2
	MLWorks_1_0_Unix_1996_11_14:1.15.1
	MLWorks_Open_Beta2_1996_10_11:1.14.3
	MLWorks_License_dev:1.14.2
	MLWorks_1_open_beta_1996_09_13:1.14.1
	MLWorks_Open_Beta_1996_08_22:1.14
	MLWorks_Beta_1996_07_02:1.14
	MLWorks_Beta_1996_06_07:1.14
	MLWorks_Beta_1996_06_06:1.14
	MLWorks_Beta_1996_06_05:1.14
	MLWorks_Beta_1996_06_03:1.14
	MLWorks_Beta_1996_05_31:1.14
	MLWorks_Beta_1996_05_30:1.14
	ML_beta_release_12/08/94:1.13
	ML_beta_release_03/08/94:1.13
	ML_revised_beta_release_25/05/94:1.12
	ML_final_beta_release_02/03/94:1.10
	mlworks-28-01-1994:1.10
	Release:1.9
	mlworks-beta-01-09-1993:1.9
	MLWorks-1-0-4-29/01/1993:1.7
	MLWorks-1-0-3-21/12/1992:1.6
	MLWorks-1-0-2-15/12/1992:1.6
	MLWorks-1-0-1-04/12/1992:1.6
	checkpoint_17_08_92:1.6;
locks; strict;
comment	@ * @;


1.17
date	98.02.20.09.32.18;	author mitchell;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	97.05.22.13.19.06;	author jont;	state Exp;
branches
	1.16.1.1
	1.16.2.1;
next	1.15;

1.15
date	96.10.29.18.09.35;	author io;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1
	1.15.5.1;
next	1.14;

1.14
date	96.04.30.17.09.04;	author jont;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1;
next	1.13;

1.13
date	94.03.24.11.07.19;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	94.03.23.17.35.50;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	94.03.21.16.21.17;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.12.17.15.12.10;	author io;	state Exp;
branches;
next	1.9;

1.9
date	93.05.28.15.19.59;	author matthew;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	93.03.12.11.55.38;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.01.05.15.28.00;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.02.27.16.03.42;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.02.07.12.48.56;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.11.14.10.55.11;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.10.16.13.16.15;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.10.08.18.58.07;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.10.04.14.37.38;	author jont;	state Exp;
branches;
next	;

1.9.1.1
date	93.05.28.15.19.59;	author jont;	state Exp;
branches;
next	;

1.14.1.1
date	96.09.13.11.26.39;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.10.07.16.17.10;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.10.17.11.36.54;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.11.14.13.04.46;	author hope;	state Exp;
branches
	1.15.1.1.1.1;
next	;

1.15.1.1.1.1
date	96.11.28.15.14.13;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.11.22.18.22.14;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.12.17.18.00.14;	author hope;	state Exp;
branches
	1.15.3.1.1.1;
next	;

1.15.3.1.1.1
date	97.02.24.11.51.53;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.12.18.09.55.35;	author hope;	state Exp;
branches;
next	;

1.15.5.1
date	97.05.12.10.50.16;	author hope;	state Exp;
branches
	1.15.5.1.1.1
	1.15.5.1.2.1
	1.15.5.1.3.1;
next	;

1.15.5.1.1.1
date	97.07.28.18.32.29;	author daveb;	state Exp;
branches
	1.15.5.1.1.1.1.1;
next	;

1.15.5.1.1.1.1.1
date	97.10.07.11.58.37;	author jkbrook;	state Exp;
branches;
next	;

1.15.5.1.2.1
date	97.09.08.17.25.45;	author daveb;	state Exp;
branches;
next	;

1.15.5.1.3.1
date	97.09.09.14.22.23;	author daveb;	state Exp;
branches;
next	;

1.16.1.1
date	97.09.10.19.41.28;	author brucem;	state Exp;
branches;
next	;

1.16.2.1
date	97.09.11.21.09.02;	author daveb;	state Exp;
branches;
next	;

1.17.1.1
date	99.04.01.18.07.50;	author daveb;	state Exp;
branches;
next	;


desc
@Printing Sparc output
@


1.17
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _machprint.sml the functor *)
(*
$Log: _machprint.sml,v $
 * Revision 1.16  1997/05/22  13:19:06  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.15  1996/10/29  18:09:35  io
 * moving String from toplevel
 *
 * Revision 1.14  1996/04/30  17:09:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.13  1994/03/24  11:07:19  matthew
 * Cope with alignment of code properly.
 *
Revision 1.12  1994/03/23  17:35:50  matthew
Fixed bug with mutually recursive functions.
Printing improvements

Revision 1.11  1994/03/21  16:21:17  matthew
Added labels to assembler output

Revision 1.10  1993/12/17  15:12:10  io
moved machprint to main/

Revision 1.9  1993/05/28  15:19:59  matthew
Align comments.

Revision 1.8  1993/03/12  11:55:38  matthew
Added type OpCode

Revision 1.7  1993/01/05  15:28:00  jont
Modified to print final machine code

Revision 1.6  1992/02/27  16:03:42  richard
Changed the way virtual registers are handled.  See MirTypes.

Revision 1.5  1992/02/07  12:48:56  richard
Abolished PRESERVE_ALL_REGS.

Copyright (c) 1991 Harlequin Ltd.
*)

require "^.basis.__string_cvt";
require "^.basis.__text_io";

require "../utils/lists";
require "sparc_assembly";
require "../main/machprint";

functor MachPrint(
  structure Lists : LISTS
  structure Sparc_Assembly : SPARC_ASSEMBLY
) : MACHPRINT =
struct
  structure Sparc_Assembly = Sparc_Assembly

  type Opcode = Sparc_Assembly.opcode

  val opcol = 35
  val labcol = 5

  fun pad columns x = StringCvt.padRight #" " columns x
  fun align n = if n mod 2 = 0 then n else n+1

  (* This could be somewhat better coded *)
  (* The diddling with +2 & align is to cope with backptr slots * alignment *)
  fun print_code (stream,labmap) (n,((tag, code),name)) =
    (TextIO.output(stream, ("[Sparc_Assembly Code]" ^ " for " ^ name ^ "\n"));
     Lists.reducel
     (fn (n,(x,y)) =>
      let
        val (lab,ass) = Sparc_Assembly.labprint (x,n,labmap)
        val line =
          if size y = 0
            then concat [pad labcol lab,ass,"\n"]
          else
            concat [pad labcol lab,pad opcol ass,"; ",y,"\n"]
      in
        TextIO.output(stream,line);
        n+1
      end)
     (align (n+2),code))

  fun print_mach_code code_list_list stream =
    let
      val labmap = 
        Sparc_Assembly.make_labmap 
        (map
         (fn code_list =>
          map 
          (fn ((tag,code),name) => (map (fn (x,y) => x) code))
          code_list)
         code_list_list)
    in
      ignore(
        Lists.reducel
        (fn (n,code_list) => Lists.reducel (print_code (stream,labmap)) (align n,code_list))
        (0,code_list_list));
      ()
    end
end

@


1.17.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.17  1998/02/20  09:32:18  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.16
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d4 4
d100 4
a103 3
      Lists.reducel
      (fn (n,code_list) => Lists.reducel (print_code (stream,labmap)) (align n,code_list))
      (0,code_list_list);
@


1.16.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.16  1997/05/22  13:19:06  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.16.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.16  1997/05/22  13:19:06  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.15
log
@moving String from toplevel
@
text
@d4 3
d44 3
a49 1
require "^.basis.__string_cvt";
d69 1
a69 1
    (MLWorks.IO.output(stream, ("[Sparc_Assembly Code]" ^ " for " ^ name ^ "\n"));
d80 1
a80 1
        MLWorks.IO.output(stream,line);
@


1.15.5.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1996/10/29  18:09:35  io
 * moving String from toplevel
 *
@


1.15.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.15.5.1  1997/05/12  10:50:16  hope
 * branched from 1.15
 *
@


1.15.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.15.5.1  1997/05/12  10:50:16  hope
 * branched from 1.15
 *
@


1.15.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.15.5.1  1997/05/12  10:50:16  hope
 * branched from 1.15
 *
@


1.15.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.15.5.1.1.1  1997/07/28  18:32:29  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.15.4.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1996/10/29  18:09:35  io
 * moving String from toplevel
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1996/10/29  18:09:35  io
 * moving String from toplevel
 *
@


1.15.3.1.1.1
log
@branched from 1.15.3.1
@
text
@a3 3
 * Revision 1.15.3.1  1996/12/17  18:00:14  hope
 * branched from 1.15
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1996/10/29  18:09:35  io
 * moving String from toplevel
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a3 3
 * Revision 1.15  1996/10/29  18:09:35  io
 * moving String from toplevel
 *
@


1.15.1.1.1.1
log
@branched from 1.15.1.1
@
text
@a3 3
 * Revision 1.15.1.1  1996/11/14  13:04:46  hope
 * branched from 1.15
 *
@


1.14
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d44 1
d58 1
a58 14
  fun make_spaces (string,n) =
    let
      fun mk (0,acc) = acc
        | mk (n,acc) = mk (n-1," " :: acc)
    in
      String.implode (string :: mk (n,[]))
    end

  fun pad columns x =
    if size x < columns
      then 
        make_spaces (x,columns-size x)
    else x

d71 1
a71 1
            then String.implode [pad labcol lab,ass,"\n"]
d73 1
a73 1
            String.implode [pad labcol lab,pad opcol ass,"; ",y,"\n"]
@


1.14.3.1
log
@branched from 1.14
@
text
@a3 6
 * Revision 1.14  1996/04/30  17:09:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.14.2.1
log
@branched from 1.14
@
text
@a3 6
 * Revision 1.14  1996/04/30  17:09:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.14.1.1
log
@branched from 1.14
@
text
@a3 6
 * Revision 1.14  1996/04/30  17:09:04  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.13
log
@Cope with alignment of code properly.
@
text
@d4 3
d56 1
a56 1
      implode (string :: mk (n,[]))
d70 1
a70 1
    (output(stream, ("[Sparc_Assembly Code]" ^ " for " ^ name ^ "\n"));
d77 1
a77 1
            then implode [pad labcol lab,ass,"\n"]
d79 1
a79 1
            implode [pad labcol lab,pad opcol ass,"; ",y,"\n"]
d81 1
a81 1
        output(stream,line);
@


1.12
log
@Fixed bug with mutually recursive functions.
Printing improvements
@
text
@d4 4
d62 2
d65 1
a65 1
  (* The diddling with +- 2 is to cope with backptr slots *)
d81 1
a81 1
     (n+2,code))
d95 1
a95 1
      (fn (n,code_list) => Lists.reducel (print_code (stream,labmap)) (n-2,code_list))
@


1.11
log
@Added labels to assembler output
@
text
@d4 3
d41 1
a41 1
  val opcol = 20
d58 2
d75 1
a75 1
     (n,code))
a76 1
  (* This could be somewhat better coded *)
d89 1
a89 1
      (fn (n,code_list) => Lists.reducel (print_code (stream,labmap)) (n,code_list))
@


1.10
log
@moved machprint to main/
@
text
@d4 3
d38 2
a39 1
  val columns = 20
d48 2
a49 1
  fun pad x =
d55 1
a55 1
  fun print_code stream ((tag, code),name) =
d57 2
a58 2
     Lists.iterate
     (fn (x,y) =>
d60 1
a60 1
        val ass = Sparc_Assembly.print x
d63 1
a63 1
            then ass ^ "\n"
d65 1
a65 1
            implode [pad ass,"; ",y,"\n"]
d67 2
a68 1
        output(stream,line)
d70 1
a70 1
     code)
d72 1
d74 15
a88 3
    Lists.iterate
    (fn code_list => Lists.iterate (print_code stream) code_list)
    code_list_list
@


1.9
log
@Align comments.
@
text
@d4 3
d24 1
a24 1
require "machprint";
@


1.9.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.9  1993/05/28  15:19:59  matthew
Align comments.

@


1.8
log
@Added type OpCode
@
text
@d4 3
d32 15
d50 11
a60 3
     (fn (x,y) => output(stream,
			 (Sparc_Assembly.print x ^
			  (if size y = 0 then "" else " ; " ^ y) ^ "\n")))
@


1.7
log
@Modified to print final machine code
@
text
@d4 3
d26 2
@


1.6
log
@Changed the way virtual registers are handled.  See MirTypes.
@
text
@d4 3
d14 1
a14 6
require "../utils/integer";
require "../utils/crash";
require "../basics/identprint";
require "../lambda/pretty";
require "../lambda/lambdasub";
require "machtypes";
d19 1
a19 6
  structure Integer : INTEGER
  structure Crash : CRASH
  structure IdentPrint : IDENTPRINT
  structure Pretty : PRETTY
  structure LambdaSub : LAMBDASUB
  structure MachTypes : MACHTYPES
d22 1
a22 2
  structure MachTypes = MachTypes
  structure P = Pretty
d24 7
a30 4
  fun decode_module_element(MachTypes.REAL(i, x)) = P.str "REAL"
  | decode_module_element(MachTypes.STRING(i, x)) = P.str "STRING"
  | decode_module_element(MachTypes.WORDSET x) = P.str "WORDSET"
  | decode_module_element(MachTypes.EXTERNAL(i, x)) = P.str "EXTERNAL"
d32 4
a35 3
  fun print_mach_code(MachTypes.MODULE(module_element_list)) =
    P.string_of_T(P.blk(0, P.lst("", [P.nl], "")
			(map decode_module_element module_element_list)))
a36 1
(*
a37 252
  fun decode_binary MirTypes.ADD = "ADD "
  | decode_binary MirTypes.SUB = "SUB "
  | decode_binary MirTypes.MULU = "MULU "
  | decode_binary MirTypes.MULS = "MULS "
  | decode_binary MirTypes.DIVU = "DIVU "
  | decode_binary MirTypes.DIVS = "DIVS "
  | decode_binary MirTypes.MODU = "MODU "
  | decode_binary MirTypes.MODS = "MODS "
  | decode_binary MirTypes.AND = "AND "
  | decode_binary MirTypes.OR = "OR "
  | decode_binary MirTypes.BIC = "BIC "
  | decode_binary MirTypes.EOR = "EOR "
  | decode_binary MirTypes.LSR = "LSR "
  | decode_binary MirTypes.ASL = "ASL "
  | decode_binary MirTypes.ASR = "ASR "

  fun decode_tagged_binary MirTypes.ADDV = "ADDV "
  | decode_tagged_binary MirTypes.SUBV = "SUBV "
  | decode_tagged_binary MirTypes.MULV = "MULV "
  | decode_tagged_binary MirTypes.DIVV = "DIVV "
  | decode_tagged_binary MirTypes.MODV = "MODV "

  fun decode_unary MirTypes.MOVE = "MOVE "
  | decode_unary MirTypes.NOT = "NOT "

  fun decode_binary_fp MirTypes.FADD = "FADD "
  | decode_binary_fp MirTypes.FSUB = "FSUB "
  | decode_binary_fp MirTypes.FMUL = "FMUL "
  | decode_binary_fp MirTypes.FDIV = "FDIV "

  fun decode_unary_fp MirTypes.FABS = "FABS "
  | decode_unary_fp MirTypes.FNEG = "FNEG "
  | decode_unary_fp MirTypes.FMOVE = "FMOVE "
  | decode_unary_fp MirTypes.FINT = "FINT "
  | decode_unary_fp MirTypes.FSQRT = "FSQRT "
  | decode_unary_fp MirTypes.FLOG10 = "FLOG10 "
  | decode_unary_fp MirTypes.FLOG2 = "FLOG2 "
  | decode_unary_fp MirTypes.FLOGE = "FLOGE "
  | decode_unary_fp MirTypes.FLOGEP1 = "FLOGEP1 "
  | decode_unary_fp MirTypes.F10TOX = "F10TOX "
  | decode_unary_fp MirTypes.F2TOX = "F2TOX "
  | decode_unary_fp MirTypes.FETOX = "FETOX "
  | decode_unary_fp MirTypes.TETOXM1 = "TETOXM1 "
  | decode_unary_fp MirTypes.FSIN = "FSIN "
  | decode_unary_fp MirTypes.FCOS = "FCOS "
  | decode_unary_fp MirTypes.FTAN = "FTAN "
  | decode_unary_fp MirTypes.FASIN = "FASIN "
  | decode_unary_fp MirTypes.FACOS = "FACOS "
  | decode_unary_fp MirTypes.FATAN = "FATAN "

  fun decode_store MirTypes.LD = "LD "
  | decode_store MirTypes.ST = "ST "
  | decode_store MirTypes.LDB = "LDB "
  | decode_store MirTypes.STB = "STB "
  | decode_store MirTypes.LDREF = "LDREF "
  | decode_store MirTypes.STREF = "STREF "

  fun decode_storefp MirTypes.FLD = "FLD "
  | decode_storefp MirTypes.FST = "FST "

  fun decode_convop MirTypes.ITOF = "ITOF "
  | decode_convop MirTypes.FTOI = "FTOI "

  fun decode_allocate MirTypes.ALLOC = "ALLOC "
  | decode_allocate MirTypes.ALLOC_REAL = "ALLOC_REAL "
  | decode_allocate MirTypes.ALLOC_STRING = "ALLOC_STRING "
  | decode_allocate MirTypes.ALLOC_REF = "ALLOC_REF "
  | decode_allocate MirTypes.ALLOC_STACK = "ALLOC_STACK "

  fun decode_branch MirTypes.BRA = "BRA "

  fun decode_test MirTypes.BEQ = "BEQ "
  | decode_test MirTypes.BNE = "BNE "
  | decode_test MirTypes.BHI = "BHI "
  | decode_test MirTypes.BLS = "BLS "
  | decode_test MirTypes.BHS = "BHS "
  | decode_test MirTypes.BLO = "BLO "
  | decode_test MirTypes.BGT = "BGT "
  | decode_test MirTypes.BLE = "BLE "
  | decode_test MirTypes.BGE = "BGE "
  | decode_test MirTypes.BLT = "BLT "

  fun decode_ftest MirTypes.FBEQ = "FBEQ "
  | decode_ftest MirTypes.FBNE = "FBNE "
  | decode_ftest MirTypes.FBLE = "FBLE "
  | decode_ftest MirTypes.FBLT = "FBLT "

  fun decode_adr MirTypes.LEA = "LEA "

  fun decode_stack_op MirTypes.PUSH = "PUSH "
  | decode_stack_op MirTypes.POP = "POP "

  fun decode_bl MirTypes.BSR = "BSR "
  | decode_bl MirTypes.BLR = "BLR "

  fun decode_gc_register gc_reg =
    let
      val fn_arg = MirRegisters.fn_arg;
      val cl_arg = MirRegisters.cl_arg;
      val fp = MirRegisters.fp;
      val sp = MirRegisters.sp;
      val handler = MirRegisters.handler
    in
      if gc_reg = fn_arg then "argument"
      else if gc_reg = cl_arg then "closure"
	   else if gc_reg = fp then "frame"
		else if gc_reg = sp then "stack"
		     else if gc_reg = handler then "handler"
			  else MirTypes.GC.to_string gc_reg
    end

  fun decode_reg_operand(MirTypes.GC_REG gc_reg) =
    "GC(" ^ decode_gc_register gc_reg ^ ") "
  | decode_reg_operand(MirTypes.NON_GC_REG non_gc_reg) =
    "NON_GC(" ^ MirTypes.NonGC.to_string non_gc_reg ^ ") "

  fun decode_fp_operand(MirTypes.FP_REG fp_reg) =
    "FP(" ^ MirTypes.FP.to_string fp_reg ^ ") "

  fun decode_any_reg(MirTypes.GC gc_reg) =
    "GC(" ^ decode_gc_register gc_reg ^ ") "
  | decode_any_reg(MirTypes.NON_GC non_gc_reg) =
    "NON_GC(" ^ MirTypes.NonGC.to_string non_gc_reg ^ ") "
  | decode_any_reg(MirTypes.FLOAT fp_reg) =
    "FLOAT(" ^ MirTypes.FP.to_string fp_reg ^ ") "

  fun decode_symb MirTypes.GC_SPILL_SIZE = "GC_SPILL_SIZE"
  | decode_symb MirTypes.NON_GC_SPILL_SIZE = "NON_GC_SPILL_SIZE"

  fun decode_gp_op(MirTypes.GP_GC_REG gc_reg) =
    "GC(" ^ decode_gc_register gc_reg ^ ") "
  | decode_gp_op(MirTypes.GP_NON_GC_REG non_gc_reg) =
    "NON_GC(" ^ MirTypes.NonGC.to_string non_gc_reg ^ ") "
  | decode_gp_op(MirTypes.GP_IMM_INT imm) =
    "Int(" ^ Integer.makestring imm ^ ") "
  | decode_gp_op(MirTypes.GP_IMM_ANY imm) =
    "Any(" ^ Integer.makestring imm ^ ") "
  | decode_gp_op(MirTypes.GP_IMM_SYMB symb) =
    "Symbol(" ^ decode_symb symb ^ ") "

  fun decode_bl_dest(MirTypes.TAG tag) = MirTypes.print_tag tag
  | decode_bl_dest(MirTypes.REG reg) = decode_reg_operand reg

  fun decode_op(MirTypes.BINARY(binary_op, reg_op, gp_op1, gp_op2)) =
    decode_binary binary_op ^ decode_reg_operand reg_op ^
    decode_gp_op gp_op1 ^ decode_gp_op gp_op2
  | decode_op(MirTypes.TBINARY(tagged_binary_op, tag, reg_op, gp_op1,
			       gp_op2)) =
    decode_tagged_binary tagged_binary_op ^ MirTypes.print_tag tag ^ " " ^
    decode_reg_operand reg_op ^ decode_gp_op gp_op1 ^ decode_gp_op gp_op2
  | decode_op(MirTypes.UNARY(unary_op, reg_op, gp_op)) =
    decode_unary unary_op ^ decode_reg_operand reg_op ^ decode_gp_op gp_op
  | decode_op(MirTypes.STOREOP(store_op, reg_op1, reg_op2, gp_op)) =
    decode_store store_op ^ decode_reg_operand reg_op1 ^
    decode_reg_operand reg_op2 ^ decode_gp_op gp_op
  | decode_op(MirTypes.ALLOCATE(allocate, reg_operand, imm)) =
    decode_allocate allocate ^ decode_reg_operand reg_operand ^
    (case allocate of MirTypes.ALLOC_REAL => "" | _ => Integer.makestring imm)
  | decode_op(MirTypes.BRANCH(branch, bl_dest)) =
    decode_branch branch ^ decode_bl_dest bl_dest
  | decode_op(MirTypes.TEST(cond_branch, tag, gp_op, gp_op')) =
    decode_test cond_branch ^ MirTypes.print_tag tag ^ " " ^
    decode_gp_op gp_op ^ decode_gp_op gp_op'
  | decode_op(MirTypes.FTEST(fcond_branch, tag, fp, fp')) =
    decode_ftest fcond_branch ^ MirTypes.print_tag tag ^ " " ^
    decode_fp_operand fp ^ decode_fp_operand fp'
  | decode_op(MirTypes.SWITCH(cgt, reg_op, tag_list)) =
    Lists.reducel
    (fn (s, tag) => s ^ " " ^ MirTypes.print_tag tag)
    ("CGT " ^ decode_reg_operand reg_op, tag_list)
  | decode_op(MirTypes.VALUE scon) = (case scon of
      IdentPrint.Ident.REAL _ => "Real "
    | IdentPrint.Ident.STRING _ => "String "
    | _ => raise(LambdaSub.LambdaTypes.impossible"VALUE(int)")) ^ 
    IdentPrint.printSCon scon
  | decode_op(MirTypes.ADR(adr, reg_op, tag)) =
    decode_adr adr ^ decode_reg_operand reg_op ^ " " ^ MirTypes.print_tag tag
    (* Information points *)
  | decode_op(MirTypes.LOC_REF tag_list) =
    Lists.reducel op ^
    ("Local references\n  ",
      map (fn tag => MirTypes.print_tag tag ^ " ") tag_list)
  | decode_op(MirTypes.EXT_REF string_list) =
    Lists.reducel op ^
    ("External references\n  ",
      map (fn chars => chars ^ " ") string_list)
  | decode_op(MirTypes.FN_CALL(tag1, tag2)) =
    "Fn call " ^ MirTypes.print_tag tag1 ^ " " ^ MirTypes.print_tag tag2
  | decode_op MirTypes.ENTER  = "Procedure entry"
  | decode_op MirTypes.RTS = "Procedure exit"
  | decode_op(MirTypes.PRESERVE_REGS(reg_list, fp_list)) =
    "Preserve registers"
  | decode_op(MirTypes.RESTORE_REGS(reg_list, fp_list)) =
    "Restore registers"
  | decode_op(MirTypes.NEW_HANDLER(tag)) =
    "New exception handler at tag " ^ (MirTypes.print_tag tag)
  | decode_op(MirTypes.OLD_HANDLER) =
    "Restore previous exception handler"
  | decode_op(MirTypes.RAISE) =
    "Raise exception"
  | decode_op MirTypes.END = "End of code"
  | decode_op(MirTypes.BINARYFP(binary_fp_op, fp_reg1, fp_reg2, fp_reg3)) =
    decode_binary_fp binary_fp_op ^ 
    decode_fp_operand fp_reg1 ^
    decode_fp_operand fp_reg2 ^
    decode_fp_operand fp_reg3
  | decode_op(MirTypes.UNARYFP(unary_fp_op, fp_reg, fp_reg')) =
    decode_unary_fp unary_fp_op ^ decode_fp_operand fp_reg ^
    decode_fp_operand fp_reg'
  | decode_op(MirTypes.STACKOP(stack_op, reg_op)) =
    decode_stack_op stack_op ^ decode_reg_operand reg_op
  | decode_op(MirTypes.STOREFPOP(store_fp_op, fp_reg, reg_op, gp_op)) =
    decode_storefp store_fp_op ^ decode_fp_operand fp_reg ^
    decode_reg_operand reg_op ^ decode_gp_op gp_op
  | decode_op(MirTypes.CONVOP(int_to_float, fp_reg, gp_op)) =
    decode_convop int_to_float ^ decode_fp_operand fp_reg ^
    decode_gp_op gp_op
  | decode_op(MirTypes.BRANCH_AND_LINK(branch_and_link, bl_dest)) =
    decode_bl branch_and_link ^ decode_bl_dest bl_dest
(*
  | decode_op(MirTypes.INIT any_reg) = "INIT " ^ decode_any_reg any_reg
  | decode_op(MirTypes.USE any_reg) = "USE " ^ decode_any_reg any_reg
  | decode_op(MirTypes.DISCARD any_reg) = "DISCARD " ^ decode_any_reg any_reg
*)
  | decode_op(MirTypes.COMMENT s) = "; " ^ s
(*
  | decode_op _ = raise(pretty_not_done_yet"unknown")
*)

  fun decode_block(MirTypes.BLOCK(tag, op_list)) =
    P.blk(0, P.lst("", [P.nl], "")
      (P.blk(2, [P.str("Tag "), P.str(MirTypes.print_tag tag)]) ::
        (map (fn x => P.str("  " ^ decode_op x)) op_list)))

  fun print_mir_code(MirTypes.CODE block_list) =
    P.string_of_T(P.blk(0, P.lst("", [P.nl], "")
			(map decode_block block_list)))

  val block = P.string_of_T o decode_block
  val opcode = decode_op
  val gp_operand = decode_gp_op
  val reg_operand = decode_reg_operand
  val any_reg = decode_any_reg
  val binary_op = decode_binary
  val unary_op = decode_unary
  val binary_fp_op = decode_binary_fp
  val unary_fp_op = decode_unary_fp
  val store_op = decode_store
  val store_fp_op = decode_storefp

end
*)
@


1.5
log
@Abolished PRESERVE_ALL_REGS.
@
text
@d3 4
a6 1
$Log$
d151 1
a151 1
			  else MirTypes.print_gc_register gc_reg
d157 1
a157 1
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^ ") "
d160 1
a160 1
    "FP(" ^ MirTypes.print_fp_register fp_reg ^ ") "
d165 1
a165 1
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^ ") "
d167 1
a167 1
    "FLOAT(" ^ MirTypes.print_fp_register fp_reg ^ ") "
d175 1
a175 1
    "NON_GC(" ^ MirTypes.print_non_gc_register non_gc_reg ^ ") "
@


1.4
log
@Removed references to fp_double registers.
@
text
@d3 1
a3 1
$Log
a231 2
  | decode_op MirTypes.PRESERVE_ALL_REGS =
    "Preserve all registers (including pc)"
@


1.3
log
@Updated to reflect new simplified module structure
@
text
@a164 2
  | decode_any_reg(MirTypes.DOUBLE double_reg) =
    "DOUBLE(" ^ MirTypes.print_fp_double_register double_reg ^ ") "
@


1.2
log
@Changed to accommodate new module structure with lists of functions
@
text
@d29 2
a30 11
  fun decode_record_element(MachTypes.INT i) = P.str(Integer.makestring i)
  | decode_record_element(MachTypes.LOC_REF local_ref) = Crash.unimplemented"LOC_REF"
  | decode_record_element(MachTypes.EXT_REF ext_ref) = Crash.unimplemented"EXT_REF"

  fun decode_record(MachTypes.REC rec_list) =
    P.blk(0, P.lst("", [P.nl], "")
	  (P.blk(2, [P.str"Record"]) ::
		map decode_record_element rec_list))

  fun decode_module_element(MachTypes.REAL x) = P.str "REAL"
  | decode_module_element(MachTypes.STRING x) = P.str "STRING"
d32 1
a32 3
  | decode_module_element(MachTypes.RECORD x) = decode_record x
  | decode_module_element(MachTypes.INTEGER x) = P.str "INTEGER"
  | decode_module_element(MachTypes.FN_CALL x) = P.str "FN_CALL"
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
  | decode_module_element(MachTypes.WORDS x) = P.str "WORDS"
@
