head	1.37;
access;
symbols
	MLW_daveb_inline_1_4_99:1.37.4
	MLWorks_21c0_1999_03_25:1.37
	MLWorks_20c1_1998_08_20:1.37
	MLWorks_20c0_1998_08_04:1.37
	MLWorks_20b2c2_1998_06_19:1.37
	MLWorks_20b2_Windows_1998_06_12:1.37
	MLWorks_20b1c1_1998_05_07:1.37
	MLWorks_20b0_1998_04_07:1.37
	MLWorks_20b0_1998_03_20:1.37
	MLWorks_20m2_1998_02_16:1.37
	MLWorks_20m1_1997_10_23:1.37
	MLWorks_11r1:1.37.1.1.1.1.1
	MLWorks_workspace_97:1.37.3
	MLWorks_dt_wizard:1.37.2
	MLWorks_11c0_1997_09_09:1.37.1.1.1.1
	MLWorks_10r3:1.37.1.1.3
	MLWorks_10r2_551:1.37.1.1.2
	MLWorks_11:1.37.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.37.1.1
	MLWorks_20m0_1997_06_20:1.37
	MLWorks_1_0_r2c2_1997_06_14:1.37.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.37.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.37.1
	MLWorks_BugFix_1997_04_24:1.37
	MLWorks_1_0_r2_Win32_1997_04_11:1.37
	MLWorks_1_0_r2_Unix_1997_04_04:1.37
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.36.3.1.1
	MLWorks_gui_1996_12_18:1.36.4
	MLWorks_1_0_Win32_1996_12_17:1.36.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.36.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.36.1.1
	MLWorks_1_0_Irix_1996_11_28:1.36.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.36.2
	MLWorks_1_0_Unix_1996_11_14:1.36.1
	MLWorks_Open_Beta2_1996_10_11:1.34.3
	MLWorks_License_dev:1.34.2
	MLWorks_1_open_beta_1996_09_13:1.34.1
	MLWorks_Open_Beta_1996_08_22:1.34
	MLWorks_Beta_1996_07_02:1.34
	MLWorks_Beta_1996_06_07:1.34
	MLWorks_Beta_1996_06_06:1.34
	MLWorks_Beta_1996_06_05:1.34
	MLWorks_Beta_1996_06_03:1.34
	MLWorks_Beta_1996_05_31:1.34
	MLWorks_Beta_1996_05_30:1.34
	ML_beta_release_12/08/94:1.28
	ML_beta_release_03/08/94:1.28
	ML_revised_beta_release_25/05/94:1.26
	ML_final_beta_release_02/03/94:1.23
	mlworks-28-01-1994:1.23
	Release:1.23
	mlworks-beta-01-09-1993:1.23
	MLWorks-1-0-4-29/01/1993:1.20
	MLWorks-1-0-3-21/12/1992:1.17
	MLWorks-1-0-2-15/12/1992:1.17
	MLWorks-1-0-1-04/12/1992:1.16
	checkpoint_17_08_92:1.15;
locks; strict;
comment	@ * @;


1.37
date	97.01.17.16.18.31;	author matthew;	state Exp;
branches
	1.37.1.1
	1.37.2.1
	1.37.3.1
	1.37.4.1;
next	1.36;

1.36
date	96.11.06.11.10.24;	author matthew;	state Exp;
branches
	1.36.1.1
	1.36.2.1
	1.36.3.1
	1.36.4.1;
next	1.35;

1.35
date	96.10.29.18.09.42;	author io;	state Exp;
branches;
next	1.34;

1.34
date	96.04.30.17.00.37;	author jont;	state Exp;
branches
	1.34.1.1
	1.34.2.1
	1.34.3.1;
next	1.33;

1.33
date	96.04.29.15.31.46;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	95.12.22.13.00.22;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	95.07.28.09.18.32;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	95.02.10.10.15.34;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	94.10.18.10.25.40;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	94.06.27.15.32.29;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	94.03.24.11.06.49;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	94.03.23.17.53.11;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	94.03.21.18.11.39;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	94.03.10.12.18.32;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	93.08.23.16.54.30;	author jont;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	93.07.29.15.24.44;	author nosa;	state Exp;
branches;
next	1.21;

1.21
date	93.05.18.16.39.48;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	93.01.25.15.37.55;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	93.01.15.12.42.47;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.12.24.11.34.05;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.12.08.11.13.35;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.08.26.16.06.09;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.07.03.13.49.46;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.06.29.10.28.39;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.06.22.13.57.50;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.06.12.16.35.20;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.03.09.13.49.26;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.02.19.19.25.14;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.11.25.16.58.41;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.11.20.18.32.54;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.11.12.16.36.21;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.11.08.15.47.35;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.10.29.12.42.07;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.10.11.15.01.34;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.10.09.16.02.33;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.10.08.17.07.44;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.10.07.15.30.20;	author jont;	state Exp;
branches;
next	;

1.23.1.1
date	93.08.23.16.54.30;	author jont;	state Exp;
branches;
next	;

1.34.1.1
date	96.09.13.11.26.26;	author hope;	state Exp;
branches;
next	;

1.34.2.1
date	96.10.07.16.16.56;	author hope;	state Exp;
branches;
next	;

1.34.3.1
date	96.10.17.11.36.32;	author hope;	state Exp;
branches;
next	;

1.36.1.1
date	96.11.14.13.04.33;	author hope;	state Exp;
branches
	1.36.1.1.1.1;
next	;

1.36.1.1.1.1
date	96.11.28.15.13.59;	author hope;	state Exp;
branches;
next	;

1.36.2.1
date	96.11.22.18.22.01;	author hope;	state Exp;
branches;
next	;

1.36.3.1
date	96.12.17.17.59.58;	author hope;	state Exp;
branches
	1.36.3.1.1.1;
next	;

1.36.3.1.1.1
date	97.02.24.11.51.37;	author hope;	state Exp;
branches;
next	;

1.36.4.1
date	96.12.18.09.55.20;	author hope;	state Exp;
branches;
next	;

1.37.1.1
date	97.05.12.10.50.01;	author hope;	state Exp;
branches
	1.37.1.1.1.1
	1.37.1.1.2.1
	1.37.1.1.3.1;
next	;

1.37.1.1.1.1
date	97.07.28.18.32.14;	author daveb;	state Exp;
branches
	1.37.1.1.1.1.1.1;
next	;

1.37.1.1.1.1.1.1
date	97.10.07.11.58.21;	author jkbrook;	state Exp;
branches;
next	;

1.37.1.1.2.1
date	97.09.08.17.25.29;	author daveb;	state Exp;
branches;
next	;

1.37.1.1.3.1
date	97.09.09.14.22.08;	author daveb;	state Exp;
branches;
next	;

1.37.2.1
date	97.09.10.19.41.11;	author brucem;	state Exp;
branches;
next	;

1.37.3.1
date	97.09.11.21.08.47;	author daveb;	state Exp;
branches;
next	;

1.37.4.1
date	99.04.01.18.07.38;	author daveb;	state Exp;
branches;
next	;


desc
@An assembler for the sparc opcodes
@


1.37
log
@Adding multiply instructions
@
text
@(* _sparc_assembly.sml the functor *)
(*
$Log: _sparc_assembly.sml,v $
 * Revision 1.36  1996/11/06  11:10:24  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.35  1996/10/29  18:09:42  io
 * moving String from toplevel
 *
 * Revision 1.34  1996/04/30  17:00:37  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.33  1996/04/29  15:31:46  matthew
 * removing MLWorks.Integer
 *
 * Revision 1.32  1995/12/22  13:00:22  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
Revision 1.31  1995/07/28  09:18:32  matthew
Putting sources registers for various instructions in correct order

Revision 1.30  1995/02/10  10:15:34  matthew
Adding debug information to Call instructions

Revision 1.29  1994/10/18  10:25:40  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.28  1994/06/27  15:32:29  jont
Fix reverse_branch to understand unsigned comparisons

Revision 1.27  1994/03/24  11:06:49  matthew
No reason?

Revision 1.26  1994/03/23  17:53:11  matthew
Improved printing:
  names for registers
  alignment of arguments
Fixed bug with mutually recursive functions

Revision 1.25  1994/03/21  18:11:39  matthew
Print opcodes etc. in lower case
Print moves as MOV.
Add labels to printed output

Revision 1.24  1994/03/10  12:18:32  jont
Adding load offset instructions

Revision 1.23  1993/08/23  16:54:30  jont
Added extra function inverse_branch to handle flow control alterations.
reverse_branch is for handling comparing arithmetic quantities in
reversed order. This fixes a long standing unobserved bug.

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";

require "../utils/crash";
require "../utils/lists";
require "../utils/intnewmap";
require "../mir/mirtypes";
require "sparc_opcodes";
require "sparc_assembly";

functor Sparc_Assembly(
  structure Crash : CRASH
  structure Lists : LISTS
  structure Map : INTNEWMAP
  structure MirTypes : MIRTYPES
  structure Sparc_Opcodes : SPARC_OPCODES
  ) : SPARC_ASSEMBLY =
struct
  structure MirTypes = MirTypes
  structure Set = MirTypes.Set
  structure Sparc_Opcodes = Sparc_Opcodes
  structure MachTypes = Sparc_Opcodes.MachTypes
  structure Debugger_Types = MirTypes.Debugger_Types

  datatype load_and_store =
    LDSB |
    LDSH |
    LDUB |
    LDUH |
    LD |
    LDD |
    STB |
    STH |
    ST |
    STD

  datatype load_and_store_float =
    LDF |
    LDDF |
    STF |
    STDF

  datatype arithmetic_and_logical =
    ADD |
    ADDCC |
    ADDX |
    ADDXCC |
    SUB |
    SUBCC |
    SUBX |
    SUBXCC |
    AND |
    ANDCC |
    ANDN |
    ANDNCC |
    OR |
    ORCC |
    ORN |
    ORNCC |
    XOR |
    XORCC |
    XORN |
    XORNCC |
    SLL |
    SRL |
    SRA |
    UMUL |
    SMUL |
    UMULCC |
    SMULCC |
    UDIV |
    SDIV |
    UDIVCC |
    SDIVCC

  datatype load_offset = LEO

  datatype special_arithmetic = ADD_AND_MASK

  datatype special_load_offset =
    LOAD_OFFSET_AND_MASK |
    LOAD_OFFSET_HIGH

  datatype tagged_arithmetic =
    TADDCC |
    TADDCCTV |
    TSUBCC |
    TSUBCCTV

  datatype sethi = SETHI

  datatype save_and_restore =
    SAVE |
    RESTORE

  datatype branch =
    BA |
    BN |
    BNE |
    BE |
    BG |
    BLE |
    BGE |
    BL |
    BGU |
    BLEU |
    BCC |
    BCS |
    BPOS |
    BNEG |
    BVC |
    BVS

  datatype call = CALL

  datatype jump_and_link = JMPL

  datatype conv_op =
    FITOS |
    FITOD |
    FITOX |
    FSTOI |
    FDTOI |
    FXTOI

  datatype funary =
    FMOV |
    FNEG |
    FABS |
    FSQRTS |
    FSQRTD |
    FSQRTX |
    FCMPS |
    FCMPD |
    FCMPX

  datatype fbinary =
    FADDS |
    FADDD |
    FADDX |
    FSUBS |
    FSUBD |
    FSUBX |
    FMULS |
    FMULD |
    FMULX |
    FDIVS |
    FDIVD |
    FDIVX

  datatype fbranch =
    FBA |
    FBN |
    FBU |
    FBG |
    FBUG |
    FBL |
    FBUL |
    FBLG |
    FBNE |
    FBE |
    FBUE |
    FBGE |
    FBUGE |
    FBLE |
    FBULE |
    FBO

  datatype reg_or_imm =
    REG of MachTypes.Sparc_Reg |
    IMM of int

  datatype read_state = RDY
  datatype write_state = WRY

  datatype opcode =
    LOAD_AND_STORE of
      load_and_store * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * reg_or_imm |
    LOAD_AND_STORE_FLOAT of
      load_and_store_float * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * reg_or_imm |
    ARITHMETIC_AND_LOGICAL of
      arithmetic_and_logical * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * reg_or_imm |
    SPECIAL_ARITHMETIC of
      special_arithmetic * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * reg_or_imm |
    TAGGED_ARITHMETIC of
      tagged_arithmetic *  MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * reg_or_imm |
    SetHI of sethi * MachTypes.Sparc_Reg * int |
    SAVE_AND_RESTORE of
      save_and_restore * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * reg_or_imm |
    BRANCH of branch * int |
    BRANCH_ANNUL of branch * int |
    Call of call * int * MirTypes.Debugger_Types.Backend_Annotation |
    JUMP_AND_LINK of jump_and_link * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * reg_or_imm * 
    Debugger_Types.Backend_Annotation |
    FBRANCH of fbranch * int |
    FBRANCH_ANNUL of fbranch * int |
    CONV_OP of conv_op * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg |
    FUNARY of funary * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg |
    FBINARY of fbinary * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg *
    MachTypes.Sparc_Reg |
    LOAD_OFFSET of load_offset * Sparc_Opcodes.MachTypes.Sparc_Reg * int |
    SPECIAL_LOAD_OFFSET of special_load_offset * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * int |
    READ_STATE of read_state * Sparc_Opcodes.MachTypes.Sparc_Reg |
    WRITE_STATE of write_state * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm

  fun assemble(LOAD_AND_STORE(load_and_store, rd, rs1, reg_or_imm)) =
    let
      val op3 = case load_and_store of
	LDSB => 9
      | LDSH => 10
      | LDUB => 1
      | LDUH => 2
      | LD => 0
      | LDD => 3
      | STB => 5
      | STH => 6
      | ST => 4
      | STD => 7
    in
      case reg_or_imm of
	REG reg =>
	  Sparc_Opcodes.FORMAT3A(3, rd, op3, rs1, false, 0, reg)
      | IMM simm13 =>
	  Sparc_Opcodes.FORMAT3B(3, rd, op3, rs1, true, simm13)
    end
  | assemble(LOAD_AND_STORE_FLOAT(load_and_store, rd, rs1, reg_or_imm)) =
    let
      val op3 = case load_and_store of
	LDF => 32
      | LDDF => 35
      | STF => 36
      | STDF => 39
    in
      case reg_or_imm of
	REG reg =>
	  Sparc_Opcodes.FORMAT3A(3, rd, op3, rs1, false, 0, reg)
      | IMM simm13 =>
	  Sparc_Opcodes.FORMAT3B(3, rd, op3, rs1, true, simm13)
    end
  | assemble(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical, rd, rs1,reg_or_imm)) =
    let
      val op3 = case arithmetic_and_logical of
	ADD => 0
      | ADDCC => 16
      | ADDX => 8
      | ADDXCC => 24
      | SUB => 4
      | SUBCC => 20
      | SUBX => 12
      | SUBXCC => 28
      | AND => 1
      | ANDCC => 17
      | ANDN => 5
      | ANDNCC => 21
      | OR => 2
      | ORCC => 18
      | ORN => 6
      | ORNCC => 22
      | XOR => 3
      | XORCC => 19
      | XORN => 7
      | XORNCC => 23
      | SLL => 37
      | SRL => 38
      | SRA => 39
      | UMUL => 10
      | SMUL => 11
      | UMULCC => 26
      | SMULCC => 27
      | UDIV => 14
      | SDIV => 15
      | UDIVCC => 30
      | SDIVCC => 31
    in
      case reg_or_imm of
	REG rs2 => Sparc_Opcodes.FORMAT3A(2, rd, op3, rs1, false, 0, rs2)
      | IMM simm13 => Sparc_Opcodes.FORMAT3B(2, rd, op3, rs1, true, simm13)
    end
  | assemble(TAGGED_ARITHMETIC(tagged_arithmetic, rd, rs1, reg_or_imm)) =
    let
      val op3 = case tagged_arithmetic of
        TADDCC => 32
      | TADDCCTV => 34
      | TSUBCC => 33
      | TSUBCCTV => 35
    in
      case reg_or_imm of
	REG rs2 => Sparc_Opcodes.FORMAT3A(2, rd, op3, rs1, false, 0, rs2)
      | IMM simm13 => Sparc_Opcodes.FORMAT3B(2, rd, op3, rs1, true, simm13)
    end
  | assemble(SetHI(_, rd, imm22)) =
    Sparc_Opcodes.FORMAT2A(rd, 4, imm22)
  | assemble(SAVE_AND_RESTORE(save_and_restore, rd, rs1, reg_or_imm)) =
    let
      val op3 = case save_and_restore of
	SAVE => 60
      | RESTORE => 61
    in
      case reg_or_imm of
	REG rs2 => Sparc_Opcodes.FORMAT3A(2, rd, op3, rs1, false, 0, rs2)
      | IMM simm13 => Sparc_Opcodes.FORMAT3B(2, rd, op3, rs1, true, simm13)
    end
  | assemble(BRANCH(branch, disp22)) =
    let
      val cond = case branch of
        BA => 8
      | BN => 0
      | BNE => 9
      | BE => 1
      | BG => 10
      | BLE => 2
      | BGE => 11
      | BL => 3
      | BGU => 12
      | BLEU => 4
      | BCC => 13
      | BCS => 5
      | BPOS => 14
      | BNEG => 6
      | BVC => 15
      | BVS => 7
    in
      Sparc_Opcodes.FORMAT2B(false, cond, 2, disp22)
    end
  | assemble(BRANCH_ANNUL(branch, disp22)) =
    let
      val cond = case branch of
        BA => 8
      | BN => 0
      | BNE => 9
      | BE => 1
      | BG => 10
      | BLE => 2
      | BGE => 11
      | BL => 3
      | BGU => 12
      | BLEU => 4
      | BCC => 13
      | BCS => 5
      | BPOS => 14
      | BNEG => 6
      | BVC => 15
      | BVS => 7
    in
      Sparc_Opcodes.FORMAT2B(true, cond, 2, disp22)
    end
  | assemble(Call(call, disp30,_)) =
    Sparc_Opcodes.FORMAT1 disp30
  | assemble(JUMP_AND_LINK(jump_and_link, rd, rs1, reg_or_imm,_)) =
    let
      val op3 = 56
    in
      case reg_or_imm of
	REG rs2 => Sparc_Opcodes.FORMAT3A(2, rd, op3, rs1, false, 0, rs2)
      | IMM simm13 => Sparc_Opcodes.FORMAT3B(2, rd, op3, rs1, true, simm13)
    end
  | assemble(FBRANCH(fbranch, disp22)) =
    let
      val cond = case fbranch of
	FBA => 8
      | FBN => 0
      | FBU => 7
      | FBG => 6
      | FBUG => 5
      | FBL => 4
      | FBUL => 3
      | FBLG => 2
      | FBNE => 1
      | FBE => 9
      | FBUE => 10
      | FBGE => 11
      | FBUGE => 12
      | FBLE => 13
      | FBULE => 14
      | FBO => 15
    in
      Sparc_Opcodes.FORMAT2B(false, cond, 6, disp22)
    end
  | assemble(FBRANCH_ANNUL(fbranch, disp22)) =
    let
      val cond = case fbranch of
	FBA => 8
      | FBN => 0
      | FBU => 7
      | FBG => 6
      | FBUG => 5
      | FBL => 4
      | FBUL => 3
      | FBLG => 2
      | FBNE => 1
      | FBE => 9
      | FBUE => 10
      | FBGE => 11
      | FBUGE => 12
      | FBLE => 13
      | FBULE => 14
      | FBO => 15
    in
      Sparc_Opcodes.FORMAT2B(true, cond, 6, disp22)
    end
  | assemble(CONV_OP(conv_op, rd, rs2)) =
    let
      val opf = case conv_op of
	FITOS => 196
      | FITOD => 200
      | FITOX => 204
      | FSTOI => 209
      | FDTOI => 210
      | FXTOI => 211
    in
      Sparc_Opcodes.FORMAT3C(2, rd, 52, MachTypes.G0, opf, rs2)
    end
  | assemble(FUNARY(FMOV, rd, rs2))   = Sparc_Opcodes.FORMAT3C(2, rd, 52, MachTypes.G0,  1, rs2)
  | assemble(FUNARY(FNEG, rd, rs2))   = Sparc_Opcodes.FORMAT3C(2, rd, 52, MachTypes.G0,  5, rs2)
  | assemble(FUNARY(FABS, rd, rs2))   = Sparc_Opcodes.FORMAT3C(2, rd, 52, MachTypes.G0,  9, rs2)
  | assemble(FUNARY(FSQRTS, rd, rs2)) = Sparc_Opcodes.FORMAT3C(2, rd, 52, MachTypes.G0, 41, rs2)
  | assemble(FUNARY(FSQRTD, rd, rs2)) = Sparc_Opcodes.FORMAT3C(2, rd, 52, MachTypes.G0, 42, rs2)
  | assemble(FUNARY(FSQRTX, rd, rs2)) = Sparc_Opcodes.FORMAT3C(2, rd, 52, MachTypes.G0, 43, rs2)
  | assemble(FUNARY(FCMPS, rd, rs2))  = Sparc_Opcodes.FORMAT3C(2, MachTypes.G0, 53, rd, 81, rs2)
  | assemble(FUNARY(FCMPD, rd, rs2))  = Sparc_Opcodes.FORMAT3C(2, MachTypes.G0, 53, rd, 82, rs2)
  | assemble(FUNARY(FCMPX, rd, rs2))  = Sparc_Opcodes.FORMAT3C(2, MachTypes.G0, 53, rd, 83, rs2)
  | assemble(FBINARY(fbinary, rd, rs1, rs2)) =
    let
      val opf = case fbinary of
	FADDS => 65
      | FADDD => 66
      | FADDX => 67
      | FSUBS => 69
      | FSUBD => 70
      | FSUBX => 71
      | FMULS => 73
      | FMULD => 74
      | FMULX => 75
      | FDIVS => 77
      | FDIVD => 78
      | FDIVX => 79
    in
      Sparc_Opcodes.FORMAT3C(2, rd, 52, rs1, opf, rs2)
    end
  | assemble(READ_STATE (opcode,rd)) =
    let
      val (rs1,op3) = case opcode of
        RDY => (MachTypes.G0 (* For register value 0 *),
                40)
    in
      Sparc_Opcodes.FORMAT3A(2,rd, op3, rs1,false,0,MachTypes.G0)
    end
  | assemble(WRITE_STATE (opcode,rs1,reg_or_imm)) =
    let
      val (rd,op3) = case opcode of
        WRY => (MachTypes.G0 (* For register value 0 *),
                48)
    in
      case reg_or_imm of
        REG rs2 => Sparc_Opcodes.FORMAT3A(2,rd, op3, rs1,false,0,rs2)
      | IMM simm13 => Sparc_Opcodes.FORMAT3B(2,rd, op3, rs1,true,simm13)
    end
  | assemble(SPECIAL_ARITHMETIC _) = Crash.impossible"assemble SPECIAL_ARITHMETIC"
  | assemble(LOAD_OFFSET _) = Crash.impossible"assemble LOAD_OFFSET"
  | assemble(SPECIAL_LOAD_OFFSET _) = Crash.impossible"assemble SPECIAL_LOAD_OFFSET"

  val opwidth = 9

  fun make_spaces (string,n) =
    let
      fun mk (0,acc) = acc
        | mk (n,acc) = mk (n-1," " :: acc)
    in
      concat (string :: mk (n,[]))
    end

  fun pad columns x =
    if size x < columns
      then 
        make_spaces (x,columns-size x)
    (* ensure at least one space *)
    else x ^ " "

  val padit = pad opwidth

  fun decode_load_and_store' LDSB = "ldsb"
  | decode_load_and_store' LDSH = "ldsh"
  | decode_load_and_store' LDUB = "ldub"
  | decode_load_and_store' LDUH = "lduh"
  | decode_load_and_store' LD = "ld"
  | decode_load_and_store' LDD = "ldd"
  | decode_load_and_store' STB = "stb"
  | decode_load_and_store' STH = "sth"
  | decode_load_and_store' ST = "st"
  | decode_load_and_store' STD = "std"

  val decode_load_and_store = (padit o decode_load_and_store')

  fun decode_load_and_store_float' LDF = "ldf"
  | decode_load_and_store_float' LDDF = "lddf"
  | decode_load_and_store_float' STF = "stf"
  | decode_load_and_store_float' STDF = "stdf"

  val decode_load_and_store_float = padit o decode_load_and_store_float'

  fun decode_arith' ADD = "add"
  | decode_arith' ADDCC = "addcc"
  | decode_arith' ADDX = "addx"
  | decode_arith' ADDXCC = "addxcc"
  | decode_arith' SUB = "sub"
  | decode_arith' SUBCC = "subcc"
  | decode_arith' SUBX = "subx"
  | decode_arith' SUBXCC = "subxcc"
  | decode_arith' AND = "and"
  | decode_arith' ANDCC = "andcc"
  | decode_arith' ANDN = "andn"
  | decode_arith' ANDNCC = "andncc"
  | decode_arith' OR = "or"
  | decode_arith' ORCC = "orcc"
  | decode_arith' ORN = "orn"
  | decode_arith' ORNCC = "orncc"
  | decode_arith' XOR = "xor"
  | decode_arith' XORCC = "xorcc"
  | decode_arith' XORN = "xorn"
  | decode_arith' XORNCC = "xorncc"
  | decode_arith' SLL = "sll"
  | decode_arith' SRL = "srl"
  | decode_arith' SRA = "sra"
  | decode_arith' UMUL = "umul"
  | decode_arith' SMUL = "smul"
  | decode_arith' UMULCC = "umulcc"
  | decode_arith' SMULCC = "smulcc"
  | decode_arith' UDIV = "udiv"
  | decode_arith' SDIV = "sdiv"
  | decode_arith' UDIVCC = "udivcc"
  | decode_arith' SDIVCC = "sdivcc"

  val decode_arith = padit o decode_arith'

  fun decode_tagged_arithmetic' TADDCC = "taddcc"
  | decode_tagged_arithmetic' TADDCCTV = "taddcctv"
  | decode_tagged_arithmetic' TSUBCC = "tsubcc"
  | decode_tagged_arithmetic' TSUBCCTV = "tsubcctv"

  val decode_tagged_arithmetic = padit o decode_tagged_arithmetic'

  fun decode_save_and_restore' SAVE = "save"
  | decode_save_and_restore' RESTORE = "restore"

  val decode_save_and_restore = padit o decode_save_and_restore'

  fun decode_branch' BA = "ba"
  | decode_branch' BN = "bn"
  | decode_branch' BNE = "bne"
  | decode_branch' BE = "be"
  | decode_branch' BG = "bg"
  | decode_branch' BLE = "ble"
  | decode_branch' BGE = "bge"
  | decode_branch' BL = "bl"
  | decode_branch' BGU = "bgu"
  | decode_branch' BLEU = "bleu"
  | decode_branch' BCC = "bcc"
  | decode_branch' BCS = "bcs"
  | decode_branch' BPOS = "bpos"
  | decode_branch' BNEG = "bneg"
  | decode_branch' BVC = "bvc"
  | decode_branch' BVS = "bvs"

  fun decode_branch opcode = padit (decode_branch' opcode)
  fun decode_branch_annulled opcode = padit (decode_branch' opcode ^ " a")

  fun decode_fbranch' FBA = "fba"
  | decode_fbranch' FBN = "fbn"
  | decode_fbranch' FBU = "fbu"
  | decode_fbranch' FBG = "fbg"
  | decode_fbranch' FBUG = "fbug"
  | decode_fbranch' FBL = "fbl"
  | decode_fbranch' FBUL = "fbul"
  | decode_fbranch' FBLG = "fblg"
  | decode_fbranch' FBNE = "fbne"
  | decode_fbranch' FBE = "fbe"
  | decode_fbranch' FBUE = "fbue"
  | decode_fbranch' FBGE = "fbge"
  | decode_fbranch' FBUGE = "fbuge"
  | decode_fbranch' FBLE = "fble"
  | decode_fbranch' FBULE = "fbule"
  | decode_fbranch' FBO = "fbo"

  fun decode_fbranch opcode = pad opwidth (decode_fbranch' opcode)
  fun decode_fbranch_annulled opcode = pad opwidth (decode_fbranch' opcode ^ " a")

  fun decode_conv_op' FITOS = "fitos"
  | decode_conv_op' FITOD = "fitod"
  | decode_conv_op' FITOX = "fitox"
  | decode_conv_op' FSTOI = "fstoi"
  | decode_conv_op' FDTOI = "fdtoi"
  | decode_conv_op' FXTOI = "fxtoi"

  val decode_conv_op = padit o decode_conv_op'

  fun decode_funary' FMOV = "fmov"
  | decode_funary' FNEG = "fneg"
  | decode_funary' FABS = "fabs"
  | decode_funary' FSQRTS = "fsqrts"
  | decode_funary' FSQRTD = "fsqrtd"
  | decode_funary' FSQRTX = "fsqrtx"
  | decode_funary' FCMPS = "fcmps"
  | decode_funary' FCMPD = "fcmpd"
  | decode_funary' FCMPX = "fcmpx"

  val decode_funary = padit o decode_funary'

  fun decode_fbinary' FADDS = "fadds"
  | decode_fbinary' FADDD = "faddd"
  | decode_fbinary' FADDX = "faddx"
  | decode_fbinary' FSUBS = "fsubs"
  | decode_fbinary' FSUBD = "fsubd"
  | decode_fbinary' FSUBX = "fsubx"
  | decode_fbinary' FMULS = "fmuls"
  | decode_fbinary' FMULD = "fmuld"
  | decode_fbinary' FMULX = "fmulx"
  | decode_fbinary' FDIVS = "fdivs"
  | decode_fbinary' FDIVD = "fdivd"
  | decode_fbinary' FDIVX = "fdivx"

  val decode_fbinary = padit o decode_fbinary'

  fun decode_reg_or_imm (REG reg) = MachTypes.reg_to_string reg
  | decode_reg_or_imm (IMM i) = "#" ^ Int.toString i

  local
    fun add_branch (i,(n,labs)) =
      (n+1,(i+n)::labs)
  in
    fun get_lab (w,BRANCH (_,i)) =
      add_branch (i,w)
      | get_lab (w,BRANCH_ANNUL (_,i)) =
        add_branch (i,w)
      | get_lab (w,FBRANCH (_,i)) =
        add_branch (i,w)
      | get_lab (w,FBRANCH_ANNUL (_,i)) =
        add_branch (i,w)
      | get_lab (w,Call(_,i,_)) =
        add_branch (i,w)
      | get_lab ((n,labs),_) = (n+1,labs)
  end

  type LabMap = string Map.T

  fun make_labmap_from_list l =
    let
      fun remove_duplicates ([],acc) = acc
        | remove_duplicates ([a],acc) = a::acc
        | remove_duplicates (a::(rest as (b :: c)),acc) =
          if a = b 
            then remove_duplicates (a::c,acc)
          else remove_duplicates (rest,a::acc)
      val sorted = rev (remove_duplicates (Lists.qsort (op <) l,[]))
      fun print_label i =
        "L" ^ Int.toString i
      val (labmap,_) =
        Lists.reducel
        (fn ((map,n),m) => (Map.define (map,m,print_label n),n+1))
        ((Map.empty,0),sorted)
    in
      labmap
    end

  fun align n = if n mod 2 = 0 then n else n+1

  (* The diddling with +2 & align is to cope with backptr slots and alignment *)
  fun make_labmap (codelistlist) =
    let
      val (_,lablist) =
        Lists.reducel 
        (fn ((n,acc),codelist) => 
         (Lists.reducel 
          (fn ((n,acc),code) => Lists.reducel get_lab ((align (n+2),acc),code))
          ((align n,acc),codelist)))
        ((0,[]),codelistlist)
    in
      make_labmap_from_list lablist
    end

  fun print_label (labmap,current,index) =
    Map.apply'(labmap,current+index)
    handle Map.Undefined => "<Undefined:" ^ Int.toString index ^ ">"

  fun print' (LOAD_AND_STORE(load_and_store, rd, rs1, reg_or_imm),n,labmap) =
    concat
    [decode_load_and_store load_and_store,
     MachTypes.reg_to_string rd,
     ", [",
     MachTypes.reg_to_string rs1,
     ", ",
     decode_reg_or_imm reg_or_imm ^ "]"]
    | print'(LOAD_AND_STORE_FLOAT(load_and_store_float, rd, rs1, reg_or_imm),n,labmap) =
      concat
      [decode_load_and_store_float load_and_store_float,
       MachTypes.fp_reg_to_string rd,
       ", [",
       MachTypes.reg_to_string rs1,
       ", ",
       decode_reg_or_imm reg_or_imm ^ "]"]
    | print'(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical, rd, rs1,reg_or_imm),n,labmap) =
      (* Put in a little hack to print moves separately *)
      (case (arithmetic_and_logical,rd,reg_or_imm,rs1) of
        (OR,_,REG (MachTypes.G0),_) =>
          concat [padit "mov",
                   MachTypes.reg_to_string rd,
                   ", ",
                   MachTypes.reg_to_string rs1]
      | (OR,_,_,MachTypes.G0) =>
          concat [padit "mov",
                   MachTypes.reg_to_string rd,
                   ", ",
                   decode_reg_or_imm reg_or_imm]
      | (AND,MachTypes.G0,IMM 0,MachTypes.G0) =>
          padit "nop"
      | (ADD,_,IMM _,MachTypes.G0) =>
          concat
          [padit "li",
           MachTypes.reg_to_string rd,
           ", ",
           decode_reg_or_imm reg_or_imm]
      | _ =>
          concat
          [decode_arith arithmetic_and_logical,
           MachTypes.reg_to_string rd,
           ", ",
           MachTypes.reg_to_string rs1,
           ", ",
           decode_reg_or_imm reg_or_imm])
    | print'(TAGGED_ARITHMETIC(tagged_arithmetic, rd, rs1, reg_or_imm),n,labmap) =
      concat
      [decode_tagged_arithmetic tagged_arithmetic,
       MachTypes.reg_to_string rd,
       ", ",
       MachTypes.reg_to_string rs1,
       ", ",
       decode_reg_or_imm reg_or_imm]
    | print'(SetHI(sethi, MachTypes.G0, 0),n,labmap) =
      padit "inop"
    | print'(SetHI(sethi, rd, i),n,labmap) =
      concat
      [padit "sethi",
       MachTypes.reg_to_string rd,
       " ",
       Int.toString i]
    | print'(SAVE_AND_RESTORE(RESTORE, MachTypes.G0, MachTypes.G0, IMM 0),n,labmap) =
      padit "restore"
    | print'(SAVE_AND_RESTORE(save_and_restore, rd, rs1, reg_or_imm),n,labmap) =
      concat
      [decode_save_and_restore save_and_restore,
       MachTypes.reg_to_string rd,
       ", ",
       MachTypes.reg_to_string rs1,
       ", ",
       decode_reg_or_imm reg_or_imm]
    | print'(BRANCH(branch, i),n,labmap) =
      concat
      [decode_branch branch,
       print_label (labmap,n,i)]
    | print'(BRANCH_ANNUL(branch, i),n,labmap) =
      concat
      [decode_branch_annulled branch,print_label(labmap,n,i)]
    | print'(Call(call, i,_),n,labmap) =
      concat
      [padit "call",
       print_label(labmap,n,i)]
    | print'(JUMP_AND_LINK(jump_and_link, MachTypes.G0,MachTypes.O7, IMM 8, _),n,labmap) =
      padit "retl"
    | print'(JUMP_AND_LINK(jump_and_link, MachTypes.G0,MachTypes.I7, IMM 8, _),n,labmap) =
      padit "ret"
    | print'(JUMP_AND_LINK(jump_and_link, MachTypes.G0, rs1, reg_or_imm,_),n,labmap) =
      concat
      [padit "jmp",
       MachTypes.reg_to_string rs1,
       ", ",
       decode_reg_or_imm reg_or_imm]
    | print'(JUMP_AND_LINK(jump_and_link, rd, rs1, reg_or_imm,_),n,labmap) =
      concat
      [padit "jmpl",
       MachTypes.reg_to_string rd,
       ", ",
       MachTypes.reg_to_string rs1,
       ", ",
       decode_reg_or_imm reg_or_imm]
    | print'(FBRANCH(fbranch, i),n,labmap) =
      concat
      [decode_fbranch fbranch,
       print_label(labmap,n,i)]
    | print'(FBRANCH_ANNUL(fbranch, i),n,labmap) =
      concat
      [decode_fbranch_annulled fbranch,print_label(labmap,n,i)]
    | print'(CONV_OP(conv_op, rd, rs2),n,labmap) =
      concat
      [decode_conv_op conv_op,
       MachTypes.fp_reg_to_string rd,
       ", ",
       MachTypes.fp_reg_to_string rs2]
    | print'(FUNARY(funary, rd, rs2),n,labmap) =
      concat
      [decode_funary funary,
       MachTypes.fp_reg_to_string rd,
       ", ",
       MachTypes.fp_reg_to_string rs2]
    | print'(FBINARY(fbinary, rd, rs1, rs2),n,labmap) =
      concat
      [decode_fbinary fbinary,
       MachTypes.fp_reg_to_string rd,
       ", ",
       MachTypes.fp_reg_to_string rs1,
       ", ",
       MachTypes.fp_reg_to_string rs2]
    | print'(LOAD_OFFSET(_, rd, i),n,labmap) =
      concat
      [padit "load_offset",
       MachTypes.reg_to_string rd,
       " plus ",
       Int.toString i]
    | print'(READ_STATE (RDY, rd),n,labmap) =
      concat
      [padit "rd",
       MachTypes.reg_to_string rd,
       ", %y"]
    | print'(WRITE_STATE (WRY, rd,reg_or_imm),n,labmap) =
      concat
      [padit "wr",
       "%y, ",
       MachTypes.reg_to_string rd,
       ", ",
       decode_reg_or_imm reg_or_imm]
    | print'(SPECIAL_ARITHMETIC _,n,labmap) = Crash.impossible"print SPECIAL_ARITHMETIC"
    | print'(SPECIAL_LOAD_OFFSET _,n,labmap) = Crash.impossible"print SPECIAL_LOAD_OFFSET"

  fun labprint (args as (_,n,labmap)) =
    let
      val line = print' args
    in
      case Map.tryApply' (labmap,n) of
        SOME s => (s ^ ":",line)
      | _ => ("",line)
    end

  fun print opcode =
    #2 (labprint (opcode,0,Map.empty))

  fun reverse_branch BA = BA
    | reverse_branch BN = BN
    | reverse_branch BNE = BNE
    | reverse_branch BE = BE
    | reverse_branch BG = BL
    | reverse_branch BLE = BGE
    | reverse_branch BGE = BLE
    | reverse_branch BL = BG
    | reverse_branch BGU = BCS
    | reverse_branch BLEU = BCC
    | reverse_branch BCC = BLEU
    | reverse_branch BCS = BGU
    | reverse_branch BPOS = Crash.impossible"reverse_branch BPOS"
    | reverse_branch BNEG = Crash.impossible"reverse_branch BNEG"
    | reverse_branch BVC = Crash.impossible"reverse_branch BVC"
    | reverse_branch BVS = Crash.impossible"reverse_branch BVS"

  fun inverse_branch BA = BN
    | inverse_branch BN = BA
    | inverse_branch BNE = BE
    | inverse_branch BE = BNE
    | inverse_branch BG = BLE
    | inverse_branch BLE = BG
    | inverse_branch BGE = BL
    | inverse_branch BL = BGE
    | inverse_branch BGU = BLEU
    | inverse_branch BLEU = BGU
    | inverse_branch BCC = BCS
    | inverse_branch BCS = BCC
    | inverse_branch BPOS = BNEG
    | inverse_branch BNEG = BPOS
    | inverse_branch BVC = BVS
    | inverse_branch BVS = BVC

  val all_windowed_regs =
    Set.list_to_set
    [MachTypes.I0,
     MachTypes.I1,
     MachTypes.I2,
     MachTypes.I3,
     MachTypes.I4,
     MachTypes.I5,
     MachTypes.I6,
     MachTypes.I7,
     MachTypes.L0,
     MachTypes.L1,
     MachTypes.L2,
     MachTypes.L3,
     MachTypes.L4,
     MachTypes.L5,
     MachTypes.L6,
     MachTypes.L7,
     MachTypes.O0,
     MachTypes.O1,
     MachTypes.O2,
     MachTypes.O3,
     MachTypes.O4,
     MachTypes.O5,
     MachTypes.O6,
     MachTypes.O7,
     MachTypes.stack]

  fun defines_and_uses(LOAD_AND_STORE(operation, rd, rs1, reg_or_imm)) =
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
      val is_nil = rs1 = MachTypes.G5 orelse rs2 = MachTypes.G5
      val is_stack = rs1 = MachTypes.I6 orelse rs2 = MachTypes.I6
      val is_heap = (not is_nil) andalso (not is_stack)
      val is_load = case operation of
	STB => false
      | STH => false
      | ST => false
      | STD => false
      | _ => true
      val next_reg = case operation of
	STD => true
      | LDD => true
      | _ => false
      val main_uses = [rs1, rs2]
      val store =
	if is_nil then MachTypes.nil_v
	else
	  if is_stack then MachTypes.stack
	  else MachTypes.heap
    in
      (Set.list_to_set
       (if is_load then
	  if next_reg then [rd, MachTypes.next_reg rd] else [rd]
	else [store]),
	  Set.list_to_set
	  (if is_load then
	     store :: main_uses
	   else
	     if next_reg then rd :: MachTypes.next_reg rd :: main_uses
	     else rd :: main_uses),
	  if is_load then Set.empty_set else Set.singleton store,
	    if is_load then Set.singleton store else Set.empty_set)
    end
  | defines_and_uses(LOAD_AND_STORE_FLOAT(operation, rd, rs1,reg_or_imm)) =
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
      val is_nil = rs1 = MachTypes.G5 orelse rs2 = MachTypes.G5
      val is_stack = rs1 = MachTypes.I6 orelse rs2 = MachTypes.I6
      val is_heap = (not is_nil) andalso (not is_stack)
      val is_load = case operation of
	STF => false
      | STDF => false
      | _ => true
      val store =
	if is_nil then MachTypes.nil_v
	else
	  if is_stack then MachTypes.stack
	  else MachTypes.heap
      val main_uses =
	if is_load then
	  Set.list_to_set[store, rs1, rs2]
	else
	  Set.list_to_set[rs1, rs2]
    in
      (if is_load then Set.empty_set else Set.singleton store,
	 main_uses,
	 Set.singleton(if is_load then rd else store),
	 Set.singleton(if is_load then store else rd))
    end
  | defines_and_uses(ARITHMETIC_AND_LOGICAL(opcode, rd, rs1, reg_or_imm)) =
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
      val (defines_cond, uses_cond,defines_y) =
	case opcode of
	  ADD => (false, false, false)
	| ADDCC => (true, false, false)
	| ADDX => (false, true, false)
	| ADDXCC => (true, true, false)
	| SUB => (false, false, false)
	| SUBCC => (true, false, false)
	| SUBX => (false, true, false)
	| SUBXCC => (true, true, false)
	| AND => (false, false, false)
	| ANDCC => (true, false, false)
	| ANDN => (false, false, false)
	| ANDNCC => (true, false, false)
	| OR => (false, false, false)
	| ORCC => (true, false, false)
	| ORN => (false, false, false)
	| ORNCC => (true, false, false)
	| XOR => (false, false, false)
	| XORCC => (true, false, false)
	| XORN => (false, false, false)
	| XORNCC => (true, false, false)
	| SLL => (false, false, false)
	| SRL => (false, false, false)
	| SRA => (false, false, false)
        | UMUL => (false,false, true)
        | SMUL => (false,false, true)
        | UMULCC => (true,false, true)
        | SMULCC => (true,false, true)
        | UDIV => (false,false, true)
        | SDIV => (false,false, true)
        | UDIVCC => (true,false, true)
        | SDIVCC => (true,false, true)
    in
      (Set.list_to_set ((if defines_y then [MachTypes.y_reg] else []) @@
                        (if defines_cond then [MachTypes.cond] else []) @@
                        [rd]),
       if uses_cond then Set.list_to_set[MachTypes.cond, rs1, rs2]
       else Set.list_to_set[rs1, rs2],
       Set.empty_set, Set.empty_set)
    end
  | defines_and_uses(TAGGED_ARITHMETIC(_, rd, rs1,reg_or_imm)) =
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
    in
      (Set.list_to_set[MachTypes.cond, rd], Set.list_to_set[rs1, rs2],
       Set.empty_set, Set.empty_set)
    end
  | defines_and_uses(SetHI(_, rd, i)) =
    (Set.singleton rd, Set.empty_set,
       Set.empty_set, Set.empty_set)
  | defines_and_uses(SAVE_AND_RESTORE(_, rd, rs1, reg_or_imm)) =
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
    in
      (Set.add_member(rd, all_windowed_regs),
       Set.add_member(rs1, Set.add_member(rs2, all_windowed_regs)),
       Set.empty_set, Set.empty_set)
    end
  | defines_and_uses(BRANCH(branch, _)) =
    (Set.empty_set,
      (case branch of
	BA => Set.empty_set
      | BN => Set.empty_set
      | _ => Set.singleton MachTypes.cond),
	 Set.empty_set, Set.empty_set)
  | defines_and_uses(BRANCH_ANNUL(branch, _)) =
    (Set.empty_set,
      (case branch of
	BA => Set.empty_set
      | BN => Set.empty_set
      | _ => Set.singleton MachTypes.cond),
       Set.empty_set, Set.empty_set)
  | defines_and_uses(Call _) =
    (Set.singleton MachTypes.lr, Set.empty_set,
     Set.empty_set, Set.empty_set)
  | defines_and_uses(JUMP_AND_LINK(_, rd, rs1, reg_or_imm,_)) =
    let
      val rs2 = case reg_or_imm of
	REG rs2 => rs2
      | _ => rs1
    in
      (Set.singleton rd, Set.list_to_set[rs1, rs2],
       Set.empty_set, Set.empty_set)
    end
  | defines_and_uses(FBRANCH(fbranch, _)) =
    (Set.empty_set,
     Set.empty_set,
     Set.empty_set,
      (case fbranch of
	FBA => Set.empty_set
      | FBN => Set.empty_set
      | _ => Set.singleton MachTypes.cond))
  | defines_and_uses(FBRANCH_ANNUL(fbranch, _)) =
    (Set.empty_set,
     Set.empty_set,
     Set.empty_set,
      (case fbranch of
	FBA => Set.empty_set
      | FBN => Set.empty_set
      | _ => Set.singleton MachTypes.cond))
  | defines_and_uses(CONV_OP(conv_op, rd, rs2)) =
	(Set.empty_set, Set.empty_set, Set.singleton rd, Set.singleton rs2)
  | defines_and_uses(FUNARY(funary, rd, rs2)) =
    let
      val defines_cond = case funary of
	FCMPS => true
      | FCMPD => true
      | FCMPX => true
      | _ => false
    in
      (Set.empty_set, Set.empty_set,
       Set.singleton(if defines_cond then MachTypes.cond else rd),
       if defines_cond then Set.list_to_set[rd, rs2] else Set.singleton rs2)
    end
  | defines_and_uses(FBINARY(fbinary, rd, rs1, rs2)) =
    (Set.empty_set, Set.empty_set, Set.singleton rd,
     Set.list_to_set[rs1, rs2])
  | defines_and_uses(LOAD_OFFSET(_, rd, _)) =
    (Set.singleton rd, Set.empty_set,
     Set.empty_set, Set.empty_set)
  | defines_and_uses(READ_STATE(RDY,rd)) =
    (Set.singleton rd,
     Set.singleton MachTypes.y_reg,
     Set.empty_set,
     Set.empty_set)
  | defines_and_uses(WRITE_STATE(WRY,rs1,reg_or_imm)) =
    (Set.singleton MachTypes.y_reg,
     case reg_or_imm of
       REG rs2 => Set.list_to_set [rs1,rs2]
     | _ => Set.singleton rs1,
     Set.empty_set,
     Set.empty_set)
  | defines_and_uses(SPECIAL_ARITHMETIC _) = Crash.impossible"defines_and_uses"
  | defines_and_uses(SPECIAL_LOAD_OFFSET _) = Crash.impossible"defines_and_uses"

(*
  fun post_save_or_restore_reg_or_imm conv_fun =
    let
      fun post(REG r) = REG(conv_fun r)
      | post arg = arg
    in
      post
    end
  
  fun post_save_or_restore(conv_fun, opcode) =
    let
      val post_reg_or_imm = post_save_or_restore_reg_or_imm conv_fun
      fun post(LOAD_AND_STORE(load_and_store, rd, rs1,
			      reg_or_imm)) =
	LOAD_AND_STORE(load_and_store, conv_fun rd,
		       conv_fun rs1,
		       post_reg_or_imm reg_or_imm)
      | post(LOAD_AND_STORE_FLOAT(load_and_store_float, f,
				  rs1, reg_or_imm)) =
	LOAD_AND_STORE_FLOAT(load_and_store_float, f,
			     conv_fun rs1,
			     post_reg_or_imm reg_or_imm)
      | post(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical,
				    rd, rs1, reg_or_imm)) =
	ARITHMETIC_AND_LOGICAL(arithmetic_and_logical,
			       conv_fun rd,
			       conv_fun rs1,
			       post_reg_or_imm reg_or_imm)
      | post(TAGGED_ARITHMETIC(tagged_arithmetic, rd,
			       rs1, reg_or_imm)) =
	TAGGED_ARITHMETIC(tagged_arithmetic,
			  conv_fun rd,
			  conv_fun rs1,
                          post_reg_or_imm reg_or_imm)
      | post(SetHI(sethi, rd, i)) =
	SetHI(sethi, conv_fun rd, i)
      | post(SAVE_AND_RESTORE _) =
	Crash.impossible"post SAVE_AND_RESTORE"
      | post(opcode as BRANCH _) = opcode
      | post(opcode as BRANCH_ANNUL _) = opcode
      | post(opcode as Call _) = opcode
      | post(JUMP_AND_LINK(jump_and_link, rd, rs1, reg_or_imm,debug)) =
	JUMP_AND_LINK(jump_and_link, conv_fun rd,
                      conv_fun rs1,
                      post_reg_or_imm reg_or_imm,
                      debug)
      | post(opcode as FBRANCH _) = opcode
      | post(opcode as FBRANCH_ANNUL _) = opcode
      | post(CONV_OP(conv_op, rd, rs1)) =
	(case conv_op of
	  FITOS => CONV_OP(conv_op, rd, conv_fun rs1)
	| FITOD => CONV_OP(conv_op, rd, conv_fun rs1)
	| FITOX => CONV_OP(conv_op, rd, conv_fun rs1)
	| FSTOI => CONV_OP(conv_op, conv_fun rd, rs1)
	| FDTOI => CONV_OP(conv_op, conv_fun rd, rs1)
	| FXTOI => CONV_OP(conv_op, conv_fun rd, rs1))
      | post(opcode as FUNARY _) = opcode
      | post(opcode as FBINARY _) = opcode
      | post(SPECIAL_ARITHMETIC _) = Crash.impossible"post"
    in
      post opcode
    end

  fun post_restore opcode =
    post_save_or_restore(MachTypes.after_restore, opcode)

  fun post_save opcode =
    post_save_or_restore(MachTypes.after_preserve, opcode)
*)
  val nop_code =
    ARITHMETIC_AND_LOGICAL(AND, MachTypes.G0, MachTypes.G0, IMM 0)
  val nop = (nop_code, NONE, "Delay slot")

  val other_nop_code =
    SetHI(SETHI, MachTypes.G0, 0)

end
@


1.37.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 3
 * Revision 1.37  1997/01/17  16:18:31  matthew
 * Adding multiply instructions
 *
@


1.37.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.37  1997/01/17  16:18:31  matthew
 * Adding multiply instructions
 *
@


1.37.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.37  1997/01/17  16:18:31  matthew
 * Adding multiply instructions
 *
@


1.37.1.1
log
@branched from 1.37
@
text
@a3 3
 * Revision 1.37  1997/01/17  16:18:31  matthew
 * Adding multiply instructions
 *
@


1.37.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.37.1.1  1997/05/12  10:50:01  hope
 * branched from 1.37
 *
@


1.37.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.37.1.1  1997/05/12  10:50:01  hope
 * branched from 1.37
 *
@


1.37.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.37.1.1  1997/05/12  10:50:01  hope
 * branched from 1.37
 *
@


1.37.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.37.1.1.1.1  1997/07/28  18:32:14  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.36
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d125 9
a133 1
    SRA
d232 3
d261 3
a263 1
    SPECIAL_LOAD_OFFSET of special_load_offset * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * int
d325 8
d499 18
a520 1

d583 8
d876 12
d1036 1
a1036 1
      val (defines_cond, uses_cond) =
d1038 37
a1074 29
	  ADD => (false, false)
	| ADDCC => (true, false)
	| ADDX => (false, true)
	| ADDXCC => (true, true)
	| SUB => (false, false)
	| SUBCC => (true, false)
	| SUBX => (false, true)
	| SUBXCC => (true, true)
	| AND => (false, false)
	| ANDCC => (true, false)
	| ANDN => (false, false)
	| ANDNCC => (true, false)
	| OR => (false, false)
	| ORCC => (true, false)
	| ORN => (false, false)
	| ORNCC => (true, false)
	| XOR => (false, false)
	| XORCC => (true, false)
	| XORN => (false, false)
	| XORNCC => (true, false)
	| SLL => (false, false)
	| SRL => (false, false)
	| SRA => (false, false)

    in
      (if defines_cond then Set.list_to_set[MachTypes.cond, rd]
       else Set.singleton rd,
	 if uses_cond then Set.list_to_set[MachTypes.cond, rs1, rs2]
	 else Set.list_to_set[rs1, rs2],
d1158 15
a1172 3
    | defines_and_uses(LOAD_OFFSET(_, rd, _)) =
      (Set.singleton rd, Set.empty_set,
       Set.empty_set, Set.empty_set)
@


1.36.4.1
log
@branched from 1.36
@
text
@a3 4
 * Revision 1.36  1996/11/06  11:10:24  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.36.3.1
log
@branched from 1.36
@
text
@a3 4
 * Revision 1.36  1996/11/06  11:10:24  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.36.3.1.1.1
log
@branched from 1.36.3.1
@
text
@a3 3
 * Revision 1.36.3.1  1996/12/17  17:59:58  hope
 * branched from 1.36
 *
@


1.36.2.1
log
@branched from 1.36
@
text
@a3 4
 * Revision 1.36  1996/11/06  11:10:24  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.36.1.1
log
@branched from 1.36
@
text
@a3 4
 * Revision 1.36  1996/11/06  11:10:24  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.36.1.1.1.1
log
@branched from 1.36.1.1
@
text
@a3 3
 * Revision 1.36.1.1  1996/11/14  13:04:33  hope
 * branched from 1.36
 *
@


1.35
log
@moving String from toplevel
@
text
@d4 3
d57 1
a57 1
require "../basis/__integer";
@


1.34
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d483 1
a483 1
      String.implode (string :: mk (n,[]))
d691 1
a691 1
    String.implode
d699 1
a699 1
      String.implode
d710 1
a710 1
          String.implode [padit "mov",
d715 1
a715 1
          String.implode [padit "mov",
d722 1
a722 1
          String.implode
d728 1
a728 1
          String.implode
d736 1
a736 1
      String.implode
d746 1
a746 1
      String.implode
d754 1
a754 1
      String.implode
d762 1
a762 1
      String.implode
d766 1
a766 1
      String.implode
d769 1
a769 1
      String.implode
d777 1
a777 1
      String.implode
d783 1
a783 1
      String.implode
d791 1
a791 1
      String.implode
d795 1
a795 1
      String.implode
d798 1
a798 1
      String.implode
d804 1
a804 1
      String.implode
d810 1
a810 1
      String.implode
d818 1
a818 1
      String.implode
d831 1
a831 1
        MLWorks.Option.SOME s => (s ^ ":",line)
d1162 1
a1162 1
  val nop = (nop_code, MLWorks.Option.NONE, "Delay slot")
@


1.34.3.1
log
@branched from 1.34
@
text
@a3 6
 * Revision 1.34  1996/04/30  17:00:37  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.34.2.1
log
@branched from 1.34
@
text
@a3 6
 * Revision 1.34  1996/04/30  17:00:37  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.34.1.1
log
@branched from 1.34
@
text
@a3 6
 * Revision 1.34  1996/04/30  17:00:37  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.33
log
@removing MLWorks.Integer
@
text
@d4 3
d477 1
a477 1
      implode (string :: mk (n,[]))
d685 1
a685 1
    implode
d693 1
a693 1
      implode
d704 1
a704 1
          implode [padit "mov",
d709 1
a709 1
          implode [padit "mov",
d716 1
a716 1
          implode
d722 1
a722 1
          implode
d730 1
a730 1
      implode
d740 1
a740 1
      implode
d748 1
a748 1
      implode
d756 1
a756 1
      implode
d760 1
a760 1
      implode
d763 1
a763 1
      implode
d771 1
a771 1
      implode
d777 1
a777 1
      implode
d785 1
a785 1
      implode
d789 1
a789 1
      implode
d792 1
a792 1
      implode
d798 1
a798 1
      implode
d804 1
a804 1
      implode
d812 1
a812 1
      implode
@


1.32
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d4 4
d45 2
d621 1
a621 1
  | decode_reg_or_imm (IMM i) = "#" ^ MLWorks.Integer.makestring i
d652 1
a652 1
        "L" ^ MLWorks.Integer.makestring i
d679 1
a679 1
    handle Map.Undefined => "<Undefined:" ^ MLWorks.Integer.makestring index ^ ">"
d741 1
a741 1
       MLWorks.Integer.makestring i]
d813 1
a813 1
       MLWorks.Integer.makestring i]
@


1.31
log
@Putting sources registers for various instructions in correct order
@
text
@d4 3
d1147 1
a1147 1
  val nop = (nop_code, MirTypes.Option.ABSENT, "Delay slot")
@


1.30
log
@Adding debug information to Call instructions
@
text
@d4 3
d203 1
a203 2
      load_and_store_float * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg *
      reg_or_imm |
d205 1
a205 2
      arithmetic_and_logical * MachTypes.Sparc_Reg * reg_or_imm *
      MachTypes.Sparc_Reg |
d207 1
a207 2
      special_arithmetic * MachTypes.Sparc_Reg * reg_or_imm *
      MachTypes.Sparc_Reg |
d209 1
a209 2
      tagged_arithmetic *  MachTypes.Sparc_Reg * reg_or_imm *
      MachTypes.Sparc_Reg |
d212 1
a212 2
      save_and_restore * MachTypes.Sparc_Reg * reg_or_imm *
      MachTypes.Sparc_Reg |
d216 2
a217 2
    JUMP_AND_LINK of jump_and_link * MachTypes.Sparc_Reg * reg_or_imm *
    MachTypes.Sparc_Reg * Debugger_Types.Backend_Annotation |
d261 1
a261 2
  | assemble(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical, rd, reg_or_imm,
				    rs1)) =
d292 1
a292 1
  | assemble(TAGGED_ARITHMETIC(tagged_arithmetic, rd, reg_or_imm, rs1)) =
d306 1
a306 1
  | assemble(SAVE_AND_RESTORE(save_and_restore, rd, reg_or_imm, rs1)) =
d362 1
a362 1
  | assemble(JUMP_AND_LINK(jump_and_link, rd, reg_or_imm, rs1,_)) =
d688 1
a688 2
    | print'(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical, rd, reg_or_imm,
				   rs1),n,labmap) =
d717 1
a717 1
    | print'(TAGGED_ARITHMETIC(tagged_arithmetic, rd, reg_or_imm, rs1),n,labmap) =
d733 1
a733 1
    | print'(SAVE_AND_RESTORE(RESTORE, MachTypes.G0, IMM 0, MachTypes.G0),n,labmap) =
d735 1
a735 1
    | print'(SAVE_AND_RESTORE(save_and_restore, rd, reg_or_imm, rs1),n,labmap) =
d754 1
a754 1
    | print'(JUMP_AND_LINK(jump_and_link, MachTypes.G0,IMM 8, MachTypes.O7,_),n,labmap) =
d756 1
a756 1
    | print'(JUMP_AND_LINK(jump_and_link, MachTypes.G0,IMM 8, MachTypes.I7,_),n,labmap) =
d758 1
a758 1
    | print'(JUMP_AND_LINK(jump_and_link, MachTypes.G0, reg_or_imm, rs1,_),n,labmap) =
d764 1
a764 1
    | print'(JUMP_AND_LINK(jump_and_link, rd, reg_or_imm, rs1,_),n,labmap) =
d920 1
a920 2
  | defines_and_uses(LOAD_AND_STORE_FLOAT(operation, rd, rs1,
							 reg_or_imm)) =
d948 1
a948 1
  | defines_and_uses(ARITHMETIC_AND_LOGICAL(opcode, rd, reg_or_imm, rs1)) =
d986 1
a986 2
  | defines_and_uses(TAGGED_ARITHMETIC(_, rd, reg_or_imm,
						      rs1)) =
d998 1
a998 1
  | defines_and_uses(SAVE_AND_RESTORE(_, rd, reg_or_imm, rs1)) =
d1025 1
a1025 1
  | defines_and_uses(JUMP_AND_LINK(_, rd, reg_or_imm, rs1,_)) =
d1096 1
a1096 1
				    rd, reg_or_imm, rs1)) =
d1099 2
a1100 2
			       post_reg_or_imm reg_or_imm,
			       conv_fun rs1)
d1102 1
a1102 1
			       reg_or_imm, rs1)) =
d1105 2
a1106 2
			  post_reg_or_imm reg_or_imm,
			  conv_fun rs1)
d1114 1
a1114 2
      | post(JUMP_AND_LINK(jump_and_link, rd, reg_or_imm,
			   rs1,debug)) =
d1116 3
a1118 2
		      post_reg_or_imm reg_or_imm,
		      conv_fun rs1,debug)
d1143 1
a1143 1
    ARITHMETIC_AND_LOGICAL(AND, MachTypes.G0, IMM 0, MachTypes.G0)
@


1.29
log
@Use pervasive Option.option for return values in NewMap
@
text
@d4 3
d217 1
a217 1
    Call of call * int |
d363 1
a363 1
  | assemble(Call(call, disp30)) =
d629 1
a629 1
      | get_lab (w,Call(_,i)) =
d754 1
a754 1
    | print'(Call(call, i),n,labmap) =
@


1.28
log
@Fix reverse_branch to understand unsigned comparisons
@
text
@d4 3
d814 1
a814 1
        Map.YES s => (s ^ ":",line)
@


1.27
log
@No reason?
@
text
@d4 3
d819 15
a833 15
  | reverse_branch BN = BN
  | reverse_branch BNE = BNE
  | reverse_branch BE = BE
  | reverse_branch BG = BL
  | reverse_branch BLE = BGE
  | reverse_branch BGE = BLE
  | reverse_branch BL = BG
  | reverse_branch BGU = Crash.impossible"reverse_branch BGU"
  | reverse_branch BLEU = Crash.impossible"reverse_branch BLEU"
  | reverse_branch BCC = Crash.impossible"reverse_branch BCC"
  | reverse_branch BCS = Crash.impossible"reverse_branch BCS"
  | reverse_branch BPOS = Crash.impossible"reverse_branch BPOS"
  | reverse_branch BNEG = Crash.impossible"reverse_branch BNEG"
  | reverse_branch BVC = Crash.impossible"reverse_branch BVC"
  | reverse_branch BVS = Crash.impossible"reverse_branch BVS"
d836 15
a850 15
  | inverse_branch BN = BA
  | inverse_branch BNE = BE
  | inverse_branch BE = BNE
  | inverse_branch BG = BLE
  | inverse_branch BLE = BG
  | inverse_branch BGE = BL
  | inverse_branch BL = BGE
  | inverse_branch BGU = BLEU
  | inverse_branch BLEU = BGU
  | inverse_branch BCC = BCS
  | inverse_branch BCS = BCC
  | inverse_branch BPOS = BNEG
  | inverse_branch BNEG = BPOS
  | inverse_branch BVC = BVS
  | inverse_branch BVS = BVC
d855 24
a878 24
    MachTypes.I1,
    MachTypes.I2,
    MachTypes.I3,
    MachTypes.I4,
    MachTypes.I5,
    MachTypes.I6,
    MachTypes.I7,
    MachTypes.L0,
    MachTypes.L1,
    MachTypes.L2,
    MachTypes.L3,
    MachTypes.L4,
    MachTypes.L5,
    MachTypes.L6,
    MachTypes.L7,
    MachTypes.O0,
    MachTypes.O1,
    MachTypes.O2,
    MachTypes.O3,
    MachTypes.O4,
    MachTypes.O5,
    MachTypes.O6,
    MachTypes.O7,
    MachTypes.stack]
@


1.26
log
@Improved printing:
  names for registers
  alignment of arguments
Fixed bug with mutually recursive functions
@
text
@d4 6
d646 3
a648 1
  (* The diddling with +- 2 is to cope with backptr slots *)
d655 2
a656 2
          (fn ((n,acc),code) => Lists.reducel get_lab ((n+2,acc),code))
          ((n-2,acc),codelist)))
@


1.25
log
@Print opcodes etc. in lower case
Print moves as MOV.
Add labels to printed output
@
text
@d4 5
d446 150
a595 111
  fun decode_load_and_store LDSB = "ldsb "
  | decode_load_and_store LDSH = "ldsh "
  | decode_load_and_store LDUB = "ldub "
  | decode_load_and_store LDUH = "lduh "
  | decode_load_and_store LD = "ld "
  | decode_load_and_store LDD = "ldd "
  | decode_load_and_store STB = "stb "
  | decode_load_and_store STH = "sth "
  | decode_load_and_store ST = "st "
  | decode_load_and_store STD = "std "

  fun decode_load_and_store_float LDF = "ldf "
  | decode_load_and_store_float LDDF = "lddf "
  | decode_load_and_store_float STF = "stf "
  | decode_load_and_store_float STDF = "stdf "

  fun decode_arith ADD = "add "
  | decode_arith ADDCC = "addcc "
  | decode_arith ADDX = "addx "
  | decode_arith ADDXCC = "addxcc "
  | decode_arith SUB = "sub "
  | decode_arith SUBCC = "subcc "
  | decode_arith SUBX = "subx "
  | decode_arith SUBXCC = "subxcc "
  | decode_arith AND = "and "
  | decode_arith ANDCC = "andcc "
  | decode_arith ANDN = "andn "
  | decode_arith ANDNCC = "andncc "
  | decode_arith OR = "or "
  | decode_arith ORCC = "orcc "
  | decode_arith ORN = "orn "
  | decode_arith ORNCC = "orncc "
  | decode_arith XOR = "xor "
  | decode_arith XORCC = "xorcc "
  | decode_arith XORN = "xorn "
  | decode_arith XORNCC = "xorncc "
  | decode_arith SLL = "sll "
  | decode_arith SRL = "srl "
  | decode_arith SRA = "sra "

  fun decode_tagged_arithmetic TADDCC = "taddcc "
  | decode_tagged_arithmetic TADDCCTV = "taddcctv "
  | decode_tagged_arithmetic TSUBCC = "tsubcc "
  | decode_tagged_arithmetic TSUBCCTV = "tsubcctv "

  fun decode_save_and_restore SAVE = "save "
  | decode_save_and_restore RESTORE = "restore "

  fun decode_branch BA = "ba "
  | decode_branch BN = "bn "
  | decode_branch BNE = "bne "
  | decode_branch BE = "be "
  | decode_branch BG = "bg "
  | decode_branch BLE = "ble "
  | decode_branch BGE = "bge "
  | decode_branch BL = "bl "
  | decode_branch BGU = "bgu "
  | decode_branch BLEU = "bleu "
  | decode_branch BCC = "bcc "
  | decode_branch BCS = "bcs "
  | decode_branch BPOS = "bpos "
  | decode_branch BNEG = "bneg "
  | decode_branch BVC = "bvc "
  | decode_branch BVS = "bvs "

  fun decode_fbranch FBA = "fba "
  | decode_fbranch FBN = "fbn "
  | decode_fbranch FBU = "fbu "
  | decode_fbranch FBG = "fbg "
  | decode_fbranch FBUG = "fbug "
  | decode_fbranch FBL = "fbl "
  | decode_fbranch FBUL = "fbul "
  | decode_fbranch FBLG = "fblg "
  | decode_fbranch FBNE = "fbne "
  | decode_fbranch FBE = "fbe "
  | decode_fbranch FBUE = "fbue "
  | decode_fbranch FBGE = "fbge "
  | decode_fbranch FBUGE = "fbuge "
  | decode_fbranch FBLE = "fble "
  | decode_fbranch FBULE = "fbule "
  | decode_fbranch FBO = "fbo "

  fun decode_conv_op FITOS = "fitos "
  | decode_conv_op FITOD = "fitod "
  | decode_conv_op FITOX = "fitox "
  | decode_conv_op FSTOI = "fstoi "
  | decode_conv_op FDTOI = "fdtoi "
  | decode_conv_op FXTOI = "fxtoi "

  fun decode_funary FMOV = "fmov "
  | decode_funary FNEG = "fneg "
  | decode_funary FABS = "fabs "
  | decode_funary FSQRTS = "fsqrts "
  | decode_funary FSQRTD = "fsqrtd "
  | decode_funary FSQRTX = "fsqrtx "
  | decode_funary FCMPS = "fcmps "
  | decode_funary FCMPD = "fcmpd "
  | decode_funary FCMPX = "fcmpx "

  fun decode_fbinary FADDS = "fadds "
  | decode_fbinary FADDD = "faddd "
  | decode_fbinary FADDX = "faddx "
  | decode_fbinary FSUBS = "fsubs "
  | decode_fbinary FSUBD = "fsubd "
  | decode_fbinary FSUBX = "fsubx "
  | decode_fbinary FMULS = "fmuls "
  | decode_fbinary FMULD = "fmuld "
  | decode_fbinary FMULX = "fmulx "
  | decode_fbinary FDIVS = "fdivs "
  | decode_fbinary FDIVD = "fdivd "
  | decode_fbinary FDIVX = "fdivx "
d597 1
a597 2
  fun decode_reg_or_imm(REG reg) = MachTypes.reg_to_string reg
  | decode_reg_or_imm(IMM i) = "#" ^ MLWorks.Integer.makestring i
d599 2
d639 2
a640 1
        
d645 4
a648 1
        (Lists.reducel (Lists.reducel get_lab))
d677 3
a679 3
      (case (arithmetic_and_logical,reg_or_imm,rs1) of
        (OR,REG (MachTypes.G0),_) =>
          implode ["mov ",
d683 2
a684 2
      | (OR,_,MachTypes.G0) =>
          implode ["mov ",
d688 8
d712 2
d716 1
a716 1
      ["sethi ",
d720 2
a732 1
       " ",
d736 1
a736 1
      [decode_branch branch, "a", " ",print_label(labmap,n,i)]
d739 1
a739 1
      ["call ",
d741 10
d753 1
a753 1
      ["jmpl ",
a761 1
       " ",
d765 1
a765 1
      [decode_fbranch fbranch, "A", " ", print_label(labmap,n,i)]
a768 1
       " ",
a774 1
       " ",
a780 1
       " ",
d788 1
a788 1
      ["load_offset ",
@


1.24
log
@Adding load offset instructions
@
text
@d4 3
d16 2
d24 2
d440 112
a551 111
  fun decode_load_and_store LDSB = "LDSB "
  | decode_load_and_store LDSH = "LDSH "
  | decode_load_and_store LDUB = "LDUB "
  | decode_load_and_store LDUH = "LDUH "
  | decode_load_and_store LD = "LD "
  | decode_load_and_store LDD = "LDD "
  | decode_load_and_store STB = "STB "
  | decode_load_and_store STH = "STH "
  | decode_load_and_store ST = "ST "
  | decode_load_and_store STD = "STD "

  fun decode_load_and_store_float LDF = "LDF "
  | decode_load_and_store_float LDDF = "LDDF "
  | decode_load_and_store_float STF = "STF "
  | decode_load_and_store_float STDF = "STDF "

  fun decode_arith ADD = "ADD "
  | decode_arith ADDCC = "ADDCC "
  | decode_arith ADDX = "ADDX "
  | decode_arith ADDXCC = "ADDXCC "
  | decode_arith SUB = "SUB "
  | decode_arith SUBCC = "SUBCC "
  | decode_arith SUBX = "SUBX "
  | decode_arith SUBXCC = "SUBXCC "
  | decode_arith AND = "AND "
  | decode_arith ANDCC = "ANDCC "
  | decode_arith ANDN = "ANDN "
  | decode_arith ANDNCC = "ANDNCC "
  | decode_arith OR = "OR "
  | decode_arith ORCC = "ORCC "
  | decode_arith ORN = "ORN "
  | decode_arith ORNCC = "ORNCC "
  | decode_arith XOR = "XOR "
  | decode_arith XORCC = "XORCC "
  | decode_arith XORN = "XORN "
  | decode_arith XORNCC = "XORNCC "
  | decode_arith SLL = "SLL "
  | decode_arith SRL = "SRL "
  | decode_arith SRA = "SRA "

  fun decode_tagged_arithmetic TADDCC = "TADDCC "
  | decode_tagged_arithmetic TADDCCTV = "TADDCCTV "
  | decode_tagged_arithmetic TSUBCC = "TSUBCC "
  | decode_tagged_arithmetic TSUBCCTV = "TSUBCCTV "

  fun decode_save_and_restore SAVE = "SAVE "
  | decode_save_and_restore RESTORE = "RESTORE "

  fun decode_branch BA = "BA "
  | decode_branch BN = "BN "
  | decode_branch BNE = "BNE "
  | decode_branch BE = "BE "
  | decode_branch BG = "BG "
  | decode_branch BLE = "BLE "
  | decode_branch BGE = "BGE "
  | decode_branch BL = "BL "
  | decode_branch BGU = "BGU "
  | decode_branch BLEU = "BLEU "
  | decode_branch BCC = "BCC "
  | decode_branch BCS = "BCS "
  | decode_branch BPOS = "BPOS "
  | decode_branch BNEG = "BNEG "
  | decode_branch BVC = "BVC "
  | decode_branch BVS = "BVS "

  fun decode_fbranch FBA = "FBA "
  | decode_fbranch FBN = "FBN "
  | decode_fbranch FBU = "FBU "
  | decode_fbranch FBG = "FBG "
  | decode_fbranch FBUG = "FBUG "
  | decode_fbranch FBL = "FBL "
  | decode_fbranch FBUL = "FBUL "
  | decode_fbranch FBLG = "FBLG "
  | decode_fbranch FBNE = "FBNE "
  | decode_fbranch FBE = "FBE "
  | decode_fbranch FBUE = "FBUE "
  | decode_fbranch FBGE = "FBGE "
  | decode_fbranch FBUGE = "FBUGE "
  | decode_fbranch FBLE = "FBLE "
  | decode_fbranch FBULE = "FBULE "
  | decode_fbranch FBO = "FBO "

  fun decode_conv_op FITOS = "FITOS "
  | decode_conv_op FITOD = "FITOD "
  | decode_conv_op FITOX = "FITOX "
  | decode_conv_op FSTOI = "FSTOI "
  | decode_conv_op FDTOI = "FDTOI "
  | decode_conv_op FXTOI = "FXTOI "

  fun decode_funary FMOV = "FMOV "
  | decode_funary FNEG = "FNEG "
  | decode_funary FABS = "FABS "
  | decode_funary FSQRTS = "FSQRTS "
  | decode_funary FSQRTD = "FSQRTD "
  | decode_funary FSQRTX = "FSQRTX "
  | decode_funary FCMPS = "FCMPS "
  | decode_funary FCMPD = "FCMPD "
  | decode_funary FCMPX = "FCMPX "

  fun decode_fbinary FADDS = "FADDS "
  | decode_fbinary FADDD = "FADDD "
  | decode_fbinary FADDX = "FADDX "
  | decode_fbinary FSUBS = "FSUBS "
  | decode_fbinary FSUBD = "FSUBD "
  | decode_fbinary FSUBX = "FSUBX "
  | decode_fbinary FMULS = "FMULS "
  | decode_fbinary FMULD = "FMULD "
  | decode_fbinary FMULX = "FMULX "
  | decode_fbinary FDIVS = "FDIVS "
  | decode_fbinary FDIVD = "FDIVD "
  | decode_fbinary FDIVX = "FDIVX "
d556 54
a609 1
  fun print(LOAD_AND_STORE(load_and_store, rd, rs1, reg_or_imm)) =
d617 1
a617 1
    | print(LOAD_AND_STORE_FLOAT(load_and_store_float, rd, rs1, reg_or_imm)) =
d625 23
a647 10
    | print(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical, rd, reg_or_imm,
				   rs1)) =
      implode
      [decode_arith arithmetic_and_logical,
       MachTypes.reg_to_string rd,
       ", ",
       MachTypes.reg_to_string rs1,
       ", ",
       decode_reg_or_imm reg_or_imm]
    | print(TAGGED_ARITHMETIC(tagged_arithmetic, rd, reg_or_imm, rs1)) =
d655 1
a655 1
    | print(SetHI(sethi, rd, i)) =
d657 1
a657 1
      ["SETHI ",
d661 1
a661 1
    | print(SAVE_AND_RESTORE(save_and_restore, rd, reg_or_imm, rs1)) =
d669 1
a669 1
    | print(BRANCH(branch, i)) =
d673 2
a674 2
       MLWorks.Integer.makestring i]
    | print(BRANCH_ANNUL(branch, i)) =
d676 2
a677 2
      [decode_branch branch, "A", " ",MLWorks.Integer.makestring i]
    | print(Call(call, i)) =
d679 3
a681 3
      ["CALL ",
       MLWorks.Integer.makestring i]
    | print(JUMP_AND_LINK(jump_and_link, rd, reg_or_imm, rs1,_)) =
d683 1
a683 1
      ["JMPL ",
d689 1
a689 1
    | print(FBRANCH(fbranch, i)) =
d693 2
a694 2
       MLWorks.Integer.makestring i]
    | print(FBRANCH_ANNUL(fbranch, i)) =
d696 2
a697 2
      [decode_fbranch fbranch, "A", " ", MLWorks.Integer.makestring i]
    | print(CONV_OP(conv_op, rd, rs2)) =
d704 1
a704 1
    | print(FUNARY(funary, rd, rs2)) =
d711 1
a711 1
    | print(FBINARY(fbinary, rd, rs1, rs2)) =
d720 1
a720 1
    | print(LOAD_OFFSET(_, rd, i)) =
d726 14
a739 2
    | print(SPECIAL_ARITHMETIC _) = Crash.impossible"print SPECIAL_ARITHMETIC"
    | print(SPECIAL_LOAD_OFFSET _) = Crash.impossible"print SPECIAL_LOAD_OFFSET"
@


1.23
log
@Added extra function inverse_branch to handle flow control alterations.
reverse_branch is for handling comparing arithmetic quantities in
reversed order. This fixes a long standing unobserved bug.
@
text
@d3 6
a8 1
$Log$
d72 2
d76 4
d198 3
a200 1
    MachTypes.Sparc_Reg
d429 3
a431 1
  | assemble(SPECIAL_ARITHMETIC _) = Crash.impossible"assemble"
d556 98
a653 91
  | print(LOAD_AND_STORE_FLOAT(load_and_store_float, rd, rs1, reg_or_imm)) =
    implode
    [decode_load_and_store_float load_and_store_float,
     MachTypes.fp_reg_to_string rd,
     ", [",
     MachTypes.reg_to_string rs1,
     ", ",
     decode_reg_or_imm reg_or_imm ^ "]"]
  | print(ARITHMETIC_AND_LOGICAL(arithmetic_and_logical, rd, reg_or_imm,
				 rs1)) =
    implode
    [decode_arith arithmetic_and_logical,
     MachTypes.reg_to_string rd,
     ", ",
     MachTypes.reg_to_string rs1,
     ", ",
     decode_reg_or_imm reg_or_imm]
  | print(TAGGED_ARITHMETIC(tagged_arithmetic, rd, reg_or_imm, rs1)) =
    implode
    [decode_tagged_arithmetic tagged_arithmetic,
     MachTypes.reg_to_string rd,
     ", ",
     MachTypes.reg_to_string rs1,
     ", ",
     decode_reg_or_imm reg_or_imm]
  | print(SetHI(sethi, rd, i)) =
    implode
    ["SETHI ",
     MachTypes.reg_to_string rd,
     " ",
     MLWorks.Integer.makestring i]
  | print(SAVE_AND_RESTORE(save_and_restore, rd, reg_or_imm, rs1)) =
    implode
    [decode_save_and_restore save_and_restore,
     MachTypes.reg_to_string rd,
     ", ",
     MachTypes.reg_to_string rs1,
     ", ",
     decode_reg_or_imm reg_or_imm]
  | print(BRANCH(branch, i)) =
    implode
    [decode_branch branch,
     " ",
     MLWorks.Integer.makestring i]
  | print(BRANCH_ANNUL(branch, i)) =
    implode
    [decode_branch branch, "A", " ",MLWorks.Integer.makestring i]
  | print(Call(call, i)) =
    implode
    ["CALL ",
     MLWorks.Integer.makestring i]
  | print(JUMP_AND_LINK(jump_and_link, rd, reg_or_imm, rs1,_)) =
    implode
    ["JMPL ",
     MachTypes.reg_to_string rd,
     ", ",
     MachTypes.reg_to_string rs1,
     ", ",
     decode_reg_or_imm reg_or_imm]
  | print(FBRANCH(fbranch, i)) =
    implode
    [decode_fbranch fbranch,
     " ",
     MLWorks.Integer.makestring i]
  | print(FBRANCH_ANNUL(fbranch, i)) =
    implode
    [decode_fbranch fbranch, "A", " ", MLWorks.Integer.makestring i]
  | print(CONV_OP(conv_op, rd, rs2)) =
    implode
    [decode_conv_op conv_op,
     " ",
     MachTypes.fp_reg_to_string rd,
     ", ",
     MachTypes.fp_reg_to_string rs2]
  | print(FUNARY(funary, rd, rs2)) =
    implode
    [decode_funary funary,
     " ",
     MachTypes.fp_reg_to_string rd,
     ", ",
     MachTypes.fp_reg_to_string rs2]
  | print(FBINARY(fbinary, rd, rs1, rs2)) =
    implode
    [decode_fbinary fbinary,
     " ",
     MachTypes.fp_reg_to_string rd,
     ", ",
     MachTypes.fp_reg_to_string rs1,
     ", ",
     MachTypes.fp_reg_to_string rs2]
  | print(SPECIAL_ARITHMETIC _) = Crash.impossible"print"
d904 3
d908 1
d910 1
d978 1
@


1.23.1.1
log
@Fork for bug fixing
@
text
@d3 1
a3 6
$Log: _sparc_assembly.sml,v $
Revision 1.23  1993/08/23  16:54:30  jont
Added extra function inverse_branch to handle flow control alterations.
reverse_branch is for handling comparing arithmetic quantities in
reversed order. This fixes a long standing unobserved bug.

@


1.22
log
@structure Option.
@
text
@d3 1
a3 1
$Log
d633 33
a665 16
  fun reverse_branch BA = BN
  | reverse_branch BN = BA
  | reverse_branch BNE = BE
  | reverse_branch BE = BNE
  | reverse_branch BG = BLE
  | reverse_branch BLE = BG
  | reverse_branch BGE = BL
  | reverse_branch BL = BGE
  | reverse_branch BGU = BLEU
  | reverse_branch BLEU = BGU
  | reverse_branch BCC = BCS
  | reverse_branch BCS = BCC
  | reverse_branch BPOS = BNEG
  | reverse_branch BNEG = BPOS
  | reverse_branch BVC = BVS
  | reverse_branch BVS = BVS
@


1.21
log
@Removed integer parameter
@
text
@d936 1
a936 1
  val nop = (nop_code, MirTypes.ABSENT, "Delay slot")
@


1.20
log
@Removed different names for anulled and non-anulled branches. The constructor
distinguishes these adequately
@
text
@a7 1
require "../utils/integer";
a13 1
  structure Integer : INTEGER
d531 1
a531 1
  | decode_reg_or_imm(IMM i) = "#" ^ Integer.makestring i
d571 1
a571 1
     Integer.makestring i]
d584 1
a584 1
     Integer.makestring i]
d587 1
a587 1
    [decode_branch branch, "A", " ",Integer.makestring i]
d591 1
a591 1
     Integer.makestring i]
d604 1
a604 1
     Integer.makestring i]
d607 1
a607 1
    [decode_fbranch fbranch, "A", " ", Integer.makestring i]
@


1.19
log
@Split store into three areas of heap, stack and nil vector for scheduling improvement
@
text
@a100 18
  datatype branch_annul =
    BAA |
    BNA |
    BNEA |
    BEA |
    BGA |
    BLEA |
    BGEA |
    BLA |
    BGUA |
    BLEUA |
    BCCA |
    BCSA |
    BPOSA |
    BNEGA |
    BVCA |
    BVSA

a155 18
  datatype fbranch_annul =
    FBAA |
    FBNA |
    FBUA |
    FBGA |
    FBUGA |
    FBLA |
    FBULA |
    FBLGA |
    FBNEA |
    FBEA |
    FBUEA |
    FBGEA |
    FBUGEA |
    FBLEA |
    FBULEA |
    FBOA

d180 1
a180 1
    BRANCH_ANNUL of branch_annul * int |
d185 1
a185 1
    FBRANCH_ANNUL of fbranch_annul * int |
d303 1
a303 1
  | assemble(BRANCH_ANNUL(branch_annul, disp22)) =
d305 17
a321 17
      val cond = case branch_annul of
        BAA => 8
      | BNA => 0
      | BNEA => 9
      | BEA => 1
      | BGA => 10
      | BLEA => 2
      | BGEA => 11
      | BLA => 3
      | BGUA => 12
      | BLEUA => 4
      | BCCA => 13
      | BCSA => 5
      | BPOSA => 14
      | BNEGA => 6
      | BVCA => 15
      | BVSA => 7
d357 1
a357 1
  | assemble(FBRANCH_ANNUL(fbranch_annul, disp22)) =
d359 17
a375 17
      val cond = case fbranch_annul of
	FBAA => 8
      | FBNA => 0
      | FBUA => 7
      | FBGA => 6
      | FBUGA => 5
      | FBLA => 4
      | FBULA => 3
      | FBLGA => 2
      | FBNEA => 1
      | FBEA => 9
      | FBUEA => 10
      | FBGEA => 11
      | FBUGEA => 12
      | FBLEA => 13
      | FBULEA => 14
      | FBOA => 15
a484 17
  fun decode_branch_annul BAA = "BAA "
  | decode_branch_annul BNA = "BNA "
  | decode_branch_annul BNEA = "BNEA "
  | decode_branch_annul BEA = "BEA "
  | decode_branch_annul BGA = "BGA "
  | decode_branch_annul BLEA = "BLEA "
  | decode_branch_annul BGEA = "BGEA "
  | decode_branch_annul BLA = "BLA "
  | decode_branch_annul BGUA = "BGUA "
  | decode_branch_annul BLEUA = "BLEUA "
  | decode_branch_annul BCCA = "BCCA "
  | decode_branch_annul BCSA = "BCSA "
  | decode_branch_annul BPOSA = "BPOSA "
  | decode_branch_annul BNEGA = "BNEGA "
  | decode_branch_annul BVCA = "BVCA "
  | decode_branch_annul BVSA = "BVSA "

a501 17
  fun decode_fbranch_annul FBAA = "FBAA "
  | decode_fbranch_annul FBNA = "FBNA "
  | decode_fbranch_annul FBUA = "FBUA "
  | decode_fbranch_annul FBGA = "FBGA "
  | decode_fbranch_annul FBUGA = "FBUGA "
  | decode_fbranch_annul FBLA = "FBLA "
  | decode_fbranch_annul FBULA = "FBULA "
  | decode_fbranch_annul FBLGA = "FBLGA "
  | decode_fbranch_annul FBNEA = "FBNEA "
  | decode_fbranch_annul FBEA = "FBEA "
  | decode_fbranch_annul FBUEA = "FBUEA "
  | decode_fbranch_annul FBGEA = "FBGEA "
  | decode_fbranch_annul FBUGEA = "FBUGEA "
  | decode_fbranch_annul FBLEA = "FBLEA "
  | decode_fbranch_annul FBULEA = "FBULEA "
  | decode_fbranch_annul FBOA = "FBOA "

d587 1
a587 1
  | print(BRANCH_ANNUL(branch_annul, i)) =
d589 1
a589 3
    [decode_branch_annul branch_annul,
     " ",
     Integer.makestring i]
d607 1
a607 1
  | print(FBRANCH_ANNUL(fbranch_annul, i)) =
d609 1
a609 3
    [decode_fbranch_annul fbranch_annul,
     " ",
     Integer.makestring i]
a651 17
  fun reverse_branch_annul BAA = BNA
  | reverse_branch_annul BNA = BAA
  | reverse_branch_annul BNEA = BEA
  | reverse_branch_annul BEA = BNEA
  | reverse_branch_annul BGA = BLEA
  | reverse_branch_annul BLEA = BGA
  | reverse_branch_annul BGEA = BLA
  | reverse_branch_annul BLA = BGEA
  | reverse_branch_annul BGUA = BLEUA
  | reverse_branch_annul BLEUA = BGUA
  | reverse_branch_annul BCCA = BCSA
  | reverse_branch_annul BCSA = BCCA
  | reverse_branch_annul BPOSA = BNEGA
  | reverse_branch_annul BNEGA = BPOSA
  | reverse_branch_annul BVCA = BVSA
  | reverse_branch_annul BVSA = BVSA

d818 2
a819 2
	BAA => Set.empty_set
      | BNA => Set.empty_set
d842 1
a842 1
  | defines_and_uses(FBRANCH_ANNUL(fbranch_annul, _)) =
d846 3
a848 3
      (case fbranch_annul of
	FBAA => Set.empty_set
      | FBNA => Set.empty_set
@


1.18
log
@Conv_op use-defines were incorrectly specified
@
text
@d769 1
a769 1
    MachTypes.store]
d776 3
d790 5
d799 1
a799 1
	else [MachTypes.store]),
d802 1
a802 1
	     MachTypes.store :: main_uses
d806 2
a807 2
	  if is_load then Set.empty_set else Set.singleton MachTypes.store,
	    if is_load then Set.singleton MachTypes.store else Set.empty_set)
d815 3
d822 5
d829 1
a829 1
	  Set.list_to_set[MachTypes.store, rs1, rs2]
d833 1
a833 1
      (if is_load then Set.empty_set else Set.singleton MachTypes.store,
d835 2
a836 2
	 Set.singleton(if is_load then rd else MachTypes.store),
	 Set.singleton(if is_load then MachTypes.store else rd))
@


1.17
log
@Changed the type of nop used for tracing to store it being moved by the scheduler
@
text
@d926 1
a926 14
    let
      val to_fp = case conv_op of
	FITOS => true
      | FITOD => true
      | FITOX => true
      | FSTOI => false
      | FDTOI => false
      | FXTOI => false
    in
      if to_fp then
	(Set.empty_set, Set.singleton rs2, Set.singleton rd, Set.empty_set)
      else
	(Set.singleton rd, Set.empty_set, Set.empty_set, Set.singleton rs2)
    end
@


1.16
log
@Removed some redundant structures and sharing
@
text
@d1028 3
@


1.15
log
@Corrected fault in defines_and_uses for std and ldd
@
text
@a8 1
require "../utils/set";
a9 2
require "../debugger/debugger_types";
require "machtypes";
a15 1
  structure Set : SET
a16 1
  structure MachTypes : MACHTYPES
a17 4
  structure Debugger_Types : DEBUGGER_TYPES

  sharing Debugger_Types = MirTypes.Debugger_Types
  sharing Sparc_Opcodes.MachTypes = MachTypes
a19 2
  structure Set = Set
  structure MachTypes = MachTypes
d21 1
d23 2
a24 1
  structure Debugger_Types = Debugger_Types
@


1.14
log
@Added type annotation information at application points
@
text
@d791 5
a795 1
      val main_uses = Set.list_to_set[rs1, rs2]
d797 12
a808 5
      (Set.singleton(if is_load then rd else MachTypes.store),
       Set.union(main_uses,
		 Set.singleton(if is_load then MachTypes.store else rd)),
       if is_load then Set.empty_set else Set.singleton MachTypes.store,
	 if is_load then Set.singleton MachTypes.store else Set.empty_set)
@


1.13
log
@Corrected the assembly of FCMPp instructions.
@
text
@d11 1
d23 1
d25 1
d33 2
a34 1
    
d228 1
a228 1
    MachTypes.Sparc_Reg |
d372 1
a372 1
  | assemble(JUMP_AND_LINK(jump_and_link, rd, reg_or_imm, rs1)) =
d675 1
a675 1
  | print(JUMP_AND_LINK(jump_and_link, rd, reg_or_imm, rs1)) =
d898 1
a898 1
  | defines_and_uses(JUMP_AND_LINK(_, rd, reg_or_imm, rs1)) =
d996 1
a996 1
			   rs1)) =
d999 1
a999 1
		      conv_fun rs1)
@


1.12
log
@Made save and restore clash with all window register references
@
text
@d432 9
a440 15
  | assemble(FUNARY(funary, rd, rs2)) =
    let
      val (opf, op3) = case funary of
	FMOV => (1, 52)
      | FNEG => (5, 52)
      | FABS => (9, 52)
      | FSQRTS => (41, 52)
      | FSQRTD => (42, 52)
      | FSQRTX => (43, 52)
      | FCMPS => (81, 53)
      | FCMPD => (82, 53)
      | FCMPX => (83, 53)
    in
      Sparc_Opcodes.FORMAT3C(2, rd, op3, MachTypes.G0, opf, rs2)
    end
@


1.11
log
@Added SPECIAL_ARITHMETIC opcode type for doing add and mask for
long range ADR instructions
@
text
@d754 29
a782 2
  fun defines_and_uses(LOAD_AND_STORE(operation, rd, rs1,
						     reg_or_imm)) =
d879 2
a880 1
      (Set.singleton rd, Set.list_to_set[rs1, rs2],
@


1.10
log
@Modified defines_and_uses to indicate store clashes between real and
integer operations
@
text
@d74 2
d210 3
d465 1
d718 1
d927 1
d986 1
@


1.9
log
@Changed printing of conversion opcodes. Added nop
@
text
@d764 2
a765 1
       Set.empty_set, Set.empty_set)
d777 5
a781 1
      val main_uses = Set.list_to_set[rs1, rs2]
d783 4
a786 4
      (Set.empty_set,
       main_uses,
       Set.singleton(if is_load then rd else MachTypes.store),
       Set.singleton(if is_load then MachTypes.store else rd))
d788 1
a788 2
  | defines_and_uses(ARITHMETIC_AND_LOGICAL(opcode, rd,
							   reg_or_imm, rs1)) =
@


1.8
log
@Moved defines_and_uses from _sparc_schedule.
Added functions for transforming instructions past save/restore
@
text
@d10 1
d19 1
d28 1
d690 6
a695 22
    let
      val to_fp = case conv_op of
	FITOS => true
      | FITOD => true
      | FITOX => true
      | FSTOI => false
      | FDTOI => false
      | FXTOI => false
    in
      implode
      [decode_conv_op conv_op,
       " ",
       if to_fp then
	 MachTypes.fp_reg_to_string rd
       else
	 MachTypes.reg_to_string rd,
       ", ",
       if to_fp then
	 MachTypes.reg_to_string rs2
       else
	 MachTypes.fp_reg_to_string rs2]
    end
d983 4
@


1.7
log
@Correct disassembly of conversion operations
@
text
@d9 1
d17 1
d24 1
d760 236
@


1.6
log
@Added printing and assembly of floating point instructions
@
text
@d702 1
a702 1
	 MachTypes.fp_reg_to_string rs2
d704 1
a704 1
	 MachTypes.reg_to_string rs2]
@


1.5
log
@Fixed bug whereby offsets in branches were displayed four times too big
@
text
@d120 69
d196 3
a198 1
    LOAD_AND_STORE_FLOAT (* Not yet determined *) |
d213 6
d241 14
a254 2
  | assemble(LOAD_AND_STORE_FLOAT (* Not yet determined *)) =
    Crash.unimplemented"Sparc_Assembly.opcode"
d365 89
d466 5
d537 64
d612 8
a619 2
  | print LOAD_AND_STORE_FLOAT =
    Crash.unimplemented"Sparc_Assembly.print LOAD_AND_STORE_FLOAT"
d673 49
@


1.4
log
@Merged LOADs and STOREs, and LOAD_FLOATs and STORE_FLOATs,
and got rid of alternate address space instructions.
@
text
@d358 7
a364 2
    decode_load_and_store load_and_store ^ MachTypes.reg_to_string rd ^ ", [" ^
    MachTypes.reg_to_string rs1 ^ ", " ^ decode_reg_or_imm reg_or_imm ^ "]"
d369 7
a375 2
    decode_arith arithmetic_and_logical ^ MachTypes.reg_to_string rd ^ ", " ^
    decode_reg_or_imm reg_or_imm ^ ", " ^ MachTypes.reg_to_string rs1
d377 7
a383 2
    decode_tagged_arithmetic tagged_arithmetic ^ MachTypes.reg_to_string rd ^
    ", " ^ decode_reg_or_imm reg_or_imm ^ ", " ^ MachTypes.reg_to_string rs1
d385 5
a389 1
    "SETHI " ^ MachTypes.reg_to_string rd ^ " " ^ Integer.makestring i
d391 7
a397 2
    decode_save_and_restore save_and_restore ^ MachTypes.reg_to_string rd ^
    ", " ^ decode_reg_or_imm reg_or_imm ^ ", " ^ MachTypes.reg_to_string rs1
d399 4
a402 1
    decode_branch branch ^ " " ^ Integer.makestring(i * 4)
d404 4
a407 1
    decode_branch_annul branch_annul ^ " " ^ Integer.makestring i
d409 3
a411 1
    "CALL " ^ Integer.makestring i
d413 7
a419 2
    "JMPL " ^ MachTypes.reg_to_string rd ^ ", " ^
    decode_reg_or_imm reg_or_imm ^ ", " ^ MachTypes.reg_to_string rs1
@


1.3
log
@Added inversion of branch sense functions
@
text
@d25 1
a25 1
  datatype load =
d31 1
a31 15
    LDD

  datatype load_alternate =
    LDSBA |
    LDSHA |
    LDUBA |
    LDUHA |
    LDA |
    LDDA

  datatype load_float =
    LDF |
    LDDF

  datatype store =
d37 3
a39 7
  datatype store_alternate =
    STBA |
    STHA |
    STA |
    STDA

  datatype store_float =
d125 3
a127 10
    LOAD of load * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * int |
    LOAD_ALTERNATE of
      load_alternate * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg *
      MachTypes.Sparc_Reg * int |
    LOAD_FLOAT (* Not yet determined *) |
    STORE of store * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * int |
    STORE_ALTERNATE of
      store_alternate * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg *
      MachTypes.Sparc_Reg * int |
    STORE_FLOAT (* Not yet determined *) |
d144 1
a144 1
  fun assemble(LOAD(load, rd, rs1, simm13)) =
d146 1
a146 1
      val op3 = case load of
d153 1
a153 11
    in
      Sparc_Opcodes.FORMAT3B(3, rd, op3, rs1, true, simm13)
    end
  | assemble(LOAD_ALTERNATE(load_alternate, rd, rs1, rs2, asi)) =
    Crash.impossible"Sparc_Assembly.assemble LOAD_ALTERNATE"
  | assemble(LOAD_FLOAT (* Not yet determined *)) =
    Crash.unimplemented"Sparc_Assembly.opcode"
  | assemble(STORE(store, rd, rs1, simm13)) =
    let
      val op3 = case store of
	STB => 5
d158 5
a162 1
      Sparc_Opcodes.FORMAT3B(3, rd, op3, rs1, true, simm13)
d164 1
a164 3
  | assemble(STORE_ALTERNATE(store_alternate, rd, rs1, rs2, asi)) =
    Crash.impossible"Sparc_Assembly.assemble STORE_ALTERNATE"
  | assemble(STORE_FLOAT (* Not yet determined *)) =
d277 10
a286 6
  fun decode_load LDSB = "LDSB "
  | decode_load LDSH = "LDSH "
  | decode_load LDUB = "LDUB "
  | decode_load LDUH = "LDUH "
  | decode_load LD = "LD "
  | decode_load LDD = "LDD "
a287 17
  fun decode_load_alternate LDSBA = "LDBSA "
  | decode_load_alternate LDSHA = "LDSHA "
  | decode_load_alternate LDUBA = "LDUBA "
  | decode_load_alternate LDUHA = "LDUHA "
  | decode_load_alternate LDA = "LDA "
  | decode_load_alternate LDDA = "LDDA "

  fun decode_store STB = "STB "
  | decode_store STH = "STH "
  | decode_store ST = "ST "
  | decode_store STD = "STD "

  fun decode_store_alternate STBA = "STBA "
  | decode_store_alternate STHA = "STHAA "
  | decode_store_alternate STA = "STA "
  | decode_store_alternate STDA = "STDA "

d357 5
a361 17
  fun print(LOAD(load, rd, rs1, i)) =
    decode_load load ^ MachTypes.reg_to_string rd ^ ", [" ^
    MachTypes.reg_to_string rs1 ^ ", " ^ Integer.makestring i ^ "]"
  | print(LOAD_ALTERNATE(load_alternate, rd, rs1, rs2, i)) =
    decode_load_alternate load_alternate ^ MachTypes.reg_to_string rd ^ ", [" ^
    MachTypes.reg_to_string rs1 ^ ", " ^ MachTypes.reg_to_string rs2 ^ "], "
    ^ Integer.makestring i
  | print LOAD_FLOAT = Crash.unimplemented"Sparc_Assembly.print LOAD_FLOAT"
  | print(STORE(store, rd, rs1, i)) =
    decode_store store ^ MachTypes.reg_to_string rd ^ ", [" ^
    MachTypes.reg_to_string rs1 ^ ", " ^ Integer.makestring i ^ "]"
  | print(STORE_ALTERNATE(store_alternate, rd, rs1, rs2, i)) =
    decode_store_alternate store_alternate ^ MachTypes.reg_to_string rd ^
    ", [" ^ MachTypes.reg_to_string rs1 ^ ", " ^ MachTypes.reg_to_string rs2 ^
    "], " ^ Integer.makestring i
  | print(STORE_FLOAT) =
    Crash.unimplemented"Sparc_Assembly.print"
@


1.2
log
@Added opcode printing
@
text
@d442 34
@


1.1
log
@Initial revision
@
text
@d8 1
d15 1
d309 133
@
