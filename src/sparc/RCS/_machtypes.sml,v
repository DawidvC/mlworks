head	1.41;
access;
symbols
	MLW_daveb_inline_1_4_99:1.41.1
	MLWorks_21c0_1999_03_25:1.41
	MLWorks_20c1_1998_08_20:1.41
	MLWorks_20c0_1998_08_04:1.41
	MLWorks_20b2c2_1998_06_19:1.41
	MLWorks_20b2_Windows_1998_06_12:1.41
	MLWorks_20b1c1_1998_05_07:1.41
	MLWorks_20b0_1998_04_07:1.41
	MLWorks_20b0_1998_03_20:1.41
	MLWorks_20m2_1998_02_16:1.41
	MLWorks_20m1_1997_10_23:1.41
	MLWorks_11r1:1.40.1.1.1.1.1
	MLWorks_workspace_97:1.40.3
	MLWorks_dt_wizard:1.40.2
	MLWorks_11c0_1997_09_09:1.40.1.1.1.1
	MLWorks_10r3:1.40.1.1.3
	MLWorks_10r2_551:1.40.1.1.2
	MLWorks_11:1.40.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.40.1.1
	MLWorks_20m0_1997_06_20:1.40
	MLWorks_1_0_r2c2_1997_06_14:1.40.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.40.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.40.1
	MLWorks_BugFix_1997_04_24:1.40
	MLWorks_1_0_r2_Win32_1997_04_11:1.40
	MLWorks_1_0_r2_Unix_1997_04_04:1.40
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.39.3.1.1
	MLWorks_gui_1996_12_18:1.39.4
	MLWorks_1_0_Win32_1996_12_17:1.39.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.39.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.39.1.1
	MLWorks_1_0_Irix_1996_11_28:1.39.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.39.2
	MLWorks_1_0_Unix_1996_11_14:1.39.1
	MLWorks_Open_Beta2_1996_10_11:1.38.3
	MLWorks_License_dev:1.38.2
	MLWorks_1_open_beta_1996_09_13:1.38.1
	MLWorks_Open_Beta_1996_08_22:1.38
	MLWorks_Beta_1996_07_02:1.38
	MLWorks_Beta_1996_06_07:1.38
	MLWorks_Beta_1996_06_06:1.38
	MLWorks_Beta_1996_06_05:1.38
	MLWorks_Beta_1996_06_03:1.38
	MLWorks_Beta_1996_05_31:1.38
	MLWorks_Beta_1996_05_30:1.38
	ML_beta_release_12/08/94:1.34
	ML_beta_release_03/08/94:1.34
	ML_revised_beta_release_25/05/94:1.33
	ML_final_beta_release_02/03/94:1.30
	mlworks-28-01-1994:1.30
	Release:1.30
	mlworks-beta-01-09-1993:1.30
	MLWorks-1-0-4-29/01/1993:1.25
	MLWorks-1-0-3-21/12/1992:1.24
	MLWorks-1-0-2-15/12/1992:1.24
	MLWorks-1-0-1-04/12/1992:1.24
	checkpoint_17_08_92:1.23
	Ten15_release_19-08-91:1.1;
locks; strict;
comment	@ * @;


1.41
date	97.09.19.08.29.22;	author brucem;	state Exp;
branches
	1.41.1.1;
next	1.40;

1.40
date	97.01.17.13.07.40;	author matthew;	state Exp;
branches
	1.40.1.1
	1.40.2.1
	1.40.3.1;
next	1.39;

1.39
date	96.10.29.18.09.38;	author io;	state Exp;
branches
	1.39.1.1
	1.39.2.1
	1.39.3.1
	1.39.4.1;
next	1.38;

1.38
date	96.04.30.16.18.36;	author jont;	state Exp;
branches
	1.38.1.1
	1.38.2.1
	1.38.3.1;
next	1.37;

1.37
date	95.08.14.11.28.16;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	95.07.25.10.31.12;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	94.08.08.11.00.31;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	94.07.25.10.44.58;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.03.23.15.17.30;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	94.03.21.13.09.01;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	94.03.08.18.14.01;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	93.07.14.11.12.37;	author jont;	state Exp;
branches
	1.30.1.1;
next	1.29;

1.29
date	93.03.18.10.08.35;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	93.03.11.11.07.13;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.03.01.14.27.46;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.02.03.15.34.53;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.01.15.12.29.42;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.09.15.10.56.24;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.06.18.11.01.06;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.01.13.14.19.26;	author clive;	state Exp;
branches;
next	1.21;

1.21
date	92.01.07.09.07.08;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	91.11.25.15.48.57;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	91.11.20.17.34.43;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	91.11.13.12.41.08;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	91.11.11.18.03.25;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	91.11.08.11.31.49;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	91.10.28.11.55.25;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.10.24.15.26.26;	author davidt;	state Exp;
branches;
next	1.13;

1.13
date	91.10.24.13.26.44;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.10.16.12.47.12;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.10.15.16.54.01;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.10.09.14.33.15;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.10.09.10.55.13;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.10.08.18.47.05;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.10.07.11.46.17;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.10.03.09.42.44;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.10.02.10.32.43;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.09.06.13.27.36;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.08.27.12.51.31;	author davida;	state Exp;
branches;
next	1.2;

1.2
date	91.08.22.11.02.02;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.08.09.17.22.25;	author jont;	state Exp;
branches;
next	;

1.30.1.1
date	93.07.14.11.12.37;	author jont;	state Exp;
branches;
next	;

1.38.1.1
date	96.09.13.11.26.20;	author hope;	state Exp;
branches;
next	;

1.38.2.1
date	96.10.07.16.16.50;	author hope;	state Exp;
branches;
next	;

1.38.3.1
date	96.10.17.11.36.24;	author hope;	state Exp;
branches;
next	;

1.39.1.1
date	96.11.14.13.04.27;	author hope;	state Exp;
branches
	1.39.1.1.1.1;
next	;

1.39.1.1.1.1
date	96.11.28.15.13.54;	author hope;	state Exp;
branches;
next	;

1.39.2.1
date	96.11.22.18.21.54;	author hope;	state Exp;
branches;
next	;

1.39.3.1
date	96.12.17.17.59.52;	author hope;	state Exp;
branches
	1.39.3.1.1.1;
next	;

1.39.3.1.1.1
date	97.02.24.11.51.30;	author hope;	state Exp;
branches;
next	;

1.39.4.1
date	96.12.18.09.55.15;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	97.05.12.10.49.56;	author hope;	state Exp;
branches
	1.40.1.1.1.1
	1.40.1.1.2.1
	1.40.1.1.3.1;
next	;

1.40.1.1.1.1
date	97.07.28.18.32.09;	author daveb;	state Exp;
branches
	1.40.1.1.1.1.1.1;
next	;

1.40.1.1.1.1.1.1
date	97.10.07.11.58.16;	author jkbrook;	state Exp;
branches;
next	;

1.40.1.1.2.1
date	97.09.08.17.25.23;	author daveb;	state Exp;
branches;
next	;

1.40.1.1.3.1
date	97.09.09.14.22.03;	author daveb;	state Exp;
branches;
next	;

1.40.2.1
date	97.09.10.19.41.06;	author brucem;	state Exp;
branches;
next	;

1.40.3.1
date	97.09.11.21.08.42;	author daveb;	state Exp;
branches;
next	;

1.41.1.1
date	99.04.01.18.07.32;	author daveb;	state Exp;
branches;
next	;


desc
@Machine limits etc
@


1.41
log
@[Bug #30153]
Remove references to Old.
@
text
@(* _machtypes.sml the functor *)
(*
$Log: _machtypes.sml,v $
 * Revision 1.40  1997/01/17  13:07:40  matthew
 * Adding y register
 *
 * Revision 1.39  1996/10/29  18:09:38  io
 * moving String from toplevel
 *
 * Revision 1.38  1996/04/30  16:18:36  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.37  1995/08/14  11:28:16  jont
 * Add bits_per_word, remove max and min integer s and words
 *
Revision 1.36  1995/07/25  10:31:12  jont
Add largest_word machine limit

Revision 1.35  1994/08/08  11:00:31  matthew
Added *_arg_regs, removed *_arg2

Revision 1.34  1994/07/25  10:44:58  matthew
Added extra argument register

Revision 1.33  1994/03/23  15:17:30  matthew
Proper names for registers

Revision 1.31  1994/03/08  18:14:01  jont
Remove module type to separate file

Revision 1.30  1993/07/14  11:12:37  jont
Fixed maximum and minimum integer sizes for lambda optimiser

Revision 1.29  1993/03/18  10:08:35  jont
Added leaf and offsets lists into WORDSET

Revision 1.28  1993/03/11  11:07:13  matthew
Added type Module

Revision 1.27  1993/03/01  14:27:46  matthew
Added MLVALUEs

Revision 1.26  1993/02/03  15:34:53  jont
Changes for code vector reform.

Revision 1.25  1993/01/15  12:29:42  jont
Split store into three areas of heap, stack and nil vector for scheduling improvement

Revision 1.24  1992/09/15  10:56:24  clive
Checked and corrected the specification for the floating point registers

Revision 1.23  1992/06/18  11:01:06  jont
Added furhter constructors to the module element type to express
interpretive stuff

Revision 1.22  1992/01/13  14:19:26  clive
Added code for non_gc spills number in front of code objects in a closure

Revision 1.21  1992/01/07  09:07:08  clive
Added stack limit register definitions

Revision 1.20  1991/11/25  15:48:57  jont
Added fp_global as a temporary for conversions from fp to int

Revision 1.19  91/11/20  17:34:43  jont
Added check_reg function from mach_cg to see when save/restore is needed

Revision 1.18  91/11/13  12:41:08  jont
Added next_reg to give the next register up. Needed for doubel and extended
moves, abs, neg, and extended store operations

Revision 1.17  91/11/11  18:03:25  jont
Added a maximum number of real digits, and a type to determine the
type of floating point in use

Revision 1.16  91/11/08  11:31:49  jont
Added printing of floating point registers

Revision 1.15  91/10/28  11:55:25  jont
Added store register for detection of load/store interaction

Revision 1.14  91/10/24  15:26:26  davidt
Now knows about the `implicit' register.

Revision 1.13  91/10/24  13:26:44  jont
Added cond register to represent the condition for the benefit of the
instruction scheduler

Revision 1.12  91/10/16  12:47:12  jont
New improved simplified module structure

Revision 1.11  91/10/15  16:54:01  jont
Changed defn of FN_CALL

Revision 1.10  91/10/09  14:33:15  richard
Added some new register definitions

Revision 1.9  91/10/09  10:55:13  jont
Changed some register allocations

Revision 1.8  91/10/08  18:47:05  jont
New module structure with lists of functions

Revision 1.7  91/10/07  11:46:17  richard
Moved some machine specific information to MachSpec.
Changed Bad_Reg exception to include a value. It is now called
OutOfScope.

Revision 1.6  91/10/03  09:42:44  richard
Changed the name of spillable_regs to gc_registers for consistency,
and added fp_registers and fp_double_registers.

Revision 1.5  91/10/02  10:32:43  jont
More register names and fixed translations

Revision 1.4  91/09/06  13:27:36  jont
Added register definitions etc

Revision 1.3  91/08/27  12:51:31  davida
Added exceptions Ord and Chr

Revision 1.2  91/08/22  11:02:02  jont
Added string to int and int to string conversion functions in case we
want variations between host and target

Revision 1.1  91/08/09  17:22:25  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "$.basis.__string";
require "../utils/crash";
require "machtypes";


functor MachTypes(
  structure Crash : CRASH
  ) : MACHTYPES =

struct
  datatype Sparc_Reg =
    I0 |
    I1 |
    I2 |
    I3 |
    I4 |
    I5 |
    I6 |
    I7 |
    L0 |
    L1 |
    L2 |
    L3 |
    L4 |
    L5 |
    L6 |
    L7 |
    O0 |
    O1 |
    O2 |
    O3 |
    O4 |
    O5 |
    O6 |
    O7 |
    G0 |
    G1 |
    G2 |
    G3 |
    G4 |
    G5 |
    G6 |
    G7 |
    cond |
    heap |
    stack |
    y_reg |
    nil_v

  val F0 = G0
  val F1 = G1
  val F2 = G2
  val F3 = G3
  val F4 = G4
  val F5 = G5
  val F6 = G6
  val F7 = G7
  val F8 = O0
  val F9 = O1
  val F10 = O2
  val F11 = O3
  val F12 = O4
  val F13 = O5
  val F14 = O6
  val F15 = O7
  val F16 = L0
  val F17 = L1
  val F18 = L2
  val F19 = L3
  val F20 = L4
  val F21 = L5
  val F22 = L6
  val F23 = L7
  val F24 = I0
  val F25 = I1
  val F26 = I2
  val F27 = I3
  val F28 = I4
  val F29 = I5
  val F30 = I6
  val F31 = I7

  fun next_reg I0 = I1
  | next_reg I1 = I2
  | next_reg I2 = I3
  | next_reg I3 = I4
  | next_reg I4 = I5
  | next_reg I5 = I6
  | next_reg I6 = I7
  | next_reg I7 = Crash.impossible"Next reg of register 31"
  | next_reg L0 = L1
  | next_reg L1 = L2
  | next_reg L2 = L3
  | next_reg L3 = L4
  | next_reg L4 = L5
  | next_reg L5 = L6
  | next_reg L6 = L7
  | next_reg L7 = I0
  | next_reg O0 = O1
  | next_reg O1 = O2
  | next_reg O2 = O3
  | next_reg O3 = O4
  | next_reg O4 = O5
  | next_reg O5 = O6
  | next_reg O6 = O7
  | next_reg O7 = L0
  | next_reg G0 = G1
  | next_reg G1 = G2
  | next_reg G2 = G3
  | next_reg G3 = G4
  | next_reg G4 = G5
  | next_reg G5 = G6
  | next_reg G6 = G7
  | next_reg G7 = O0
  | next_reg cond = Crash.impossible"next_reg cond"
  | next_reg heap = Crash.impossible"next_reg heap"
  | next_reg stack = Crash.impossible"next_reg stack"
  | next_reg y_reg = Crash.impossible"next_reg y_reg"
  | next_reg nil_v = Crash.impossible"next_reg nil_v"

  datatype fp_type = single | double | extended

  val fp_used = double

  fun reg_to_string I0 = "carg"
    | reg_to_string I1 = "cclos"
    | reg_to_string I2 = "i2"
    | reg_to_string I3 = "i3"
    | reg_to_string I4 = "i4"
    | reg_to_string I5 = "i5"
    | reg_to_string I6 = "fp"
    | reg_to_string I7 = "i7"
    | reg_to_string L0 = "l0"
    | reg_to_string L1 = "l1"
    | reg_to_string L2 = "l2"
    | reg_to_string L3 = "l3"
    | reg_to_string L4 = "l4"
    | reg_to_string L5 = "l5"
    | reg_to_string L6 = "l6"
    | reg_to_string L7 = "l7"
    | reg_to_string O0 = "arg"
    | reg_to_string O1 = "clos"
    | reg_to_string O2 = "o2"
    | reg_to_string O3 = "o3"
    | reg_to_string O4 = "o4"
    | reg_to_string O5 = "o5"
    | reg_to_string O6 = "sp"
    | reg_to_string O7 = "lr"
    | reg_to_string G0 = "zero"
    | reg_to_string G1 = "alloc"
    | reg_to_string G2 = "limit"
    | reg_to_string G3 = "handler"
    | reg_to_string G4 = "temp"
    | reg_to_string G5 = "implicit"
    | reg_to_string G6 = "stacklimit"
    | reg_to_string G7 = "g7"
    | reg_to_string cond = "the condition codes"
    | reg_to_string heap = "the heap"
    | reg_to_string stack = "the stack"
    | reg_to_string y_reg = "the y register"
    | reg_to_string nil_v = "the nil vector"
      
  fun fp_reg_to_string I0 = "f24"
    | fp_reg_to_string I1 = "f25"
    | fp_reg_to_string I2 = "f26"
    | fp_reg_to_string I3 = "f27"
    | fp_reg_to_string I4 = "f28"
    | fp_reg_to_string I5 = "f29"
    | fp_reg_to_string I6 = "f30"
    | fp_reg_to_string I7 = "f31"
    | fp_reg_to_string L0 = "f16"
    | fp_reg_to_string L1 = "f17"
    | fp_reg_to_string L2 = "f18"
    | fp_reg_to_string L3 = "f19"
    | fp_reg_to_string L4 = "f20"
    | fp_reg_to_string L5 = "f21"
    | fp_reg_to_string L6 = "f22"
    | fp_reg_to_string L7 = "f23"
    | fp_reg_to_string O0 = "f8"
    | fp_reg_to_string O1 = "f9"
    | fp_reg_to_string O2 = "f10"
    | fp_reg_to_string O3 = "f11"
    | fp_reg_to_string O4 = "f12"
    | fp_reg_to_string O5 = "f13"
    | fp_reg_to_string O6 = "f14"
    | fp_reg_to_string O7 = "f15"
    | fp_reg_to_string G0 = "f0"
    | fp_reg_to_string G1 = "f1"
    | fp_reg_to_string G2 = "f2"
    | fp_reg_to_string G3 = "f3"
    | fp_reg_to_string G4 = "f4"
    | fp_reg_to_string G5 = "f5"
    | fp_reg_to_string G6 = "f6"
    | fp_reg_to_string G7 = "f7"
    | fp_reg_to_string cond = "the condition codes"
    | fp_reg_to_string heap = "the heap"
    | fp_reg_to_string stack = "the stack"
    | fp_reg_to_string y_reg = "the y register"
    | fp_reg_to_string nil_v = "the nil vector"
      
  val caller_arg = O0
  val callee_arg = I0
  val caller_arg_regs = [O0,O2,O3,O4,O5]
  val callee_arg_regs = [I0,I2,I3,I4,I5]
  val caller_closure = O1
  val callee_closure = I1
  val fp = I6
  val sp = O6
  val lr = O7
  val handler = G3
  val gc1 = G1
  val gc2 = G2
  val global = G4
  val fp_global = G4
  val implicit = G5
  val stack_limit = G6
    
  exception OutOfScope of Sparc_Reg
  
  fun after_preserve I0 = raise OutOfScope I0
    | after_preserve I1 = raise OutOfScope I1
    | after_preserve I2 = raise OutOfScope I2
    | after_preserve I3 = raise OutOfScope I3
    | after_preserve I4 = raise OutOfScope I4
    | after_preserve I5 = raise OutOfScope I5
    | after_preserve I6 = raise OutOfScope I6
    | after_preserve I7 = raise OutOfScope I7
    | after_preserve L0 = raise OutOfScope L0
    | after_preserve L1 = raise OutOfScope L1
    | after_preserve L2 = raise OutOfScope L2
    | after_preserve L3 = raise OutOfScope L3
    | after_preserve L4 = raise OutOfScope L4
    | after_preserve L5 = raise OutOfScope L5
    | after_preserve L6 = raise OutOfScope L6
    | after_preserve L7 = raise OutOfScope L7
    | after_preserve O0 = I0
    | after_preserve O1 = I1
    | after_preserve O2 = I2
    | after_preserve O3 = I3
    | after_preserve O4 = I4
    | after_preserve O5 = I5
    | after_preserve O6 = I6
    | after_preserve O7 = I7
    | after_preserve G0 = G0
    | after_preserve G1 = G1
    | after_preserve G2 = G2
    | after_preserve G3 = G3
    | after_preserve G4 = G4
    | after_preserve G5 = G5
    | after_preserve G6 = G6
    | after_preserve G7 = G7
    | after_preserve cond = Crash.impossible"after_preserve cond"
    | after_preserve heap = Crash.impossible"after_preserve heap"
    | after_preserve stack = Crash.impossible"after_preserve stack"
    | after_preserve y_reg = Crash.impossible"after_preserve y_reg"
    | after_preserve nil_v = Crash.impossible"after_preserve nil_v"

  fun after_restore I0 = O0
    | after_restore I1 = O1
    | after_restore I2 = O2
    | after_restore I3 = O3
    | after_restore I4 = O4
    | after_restore I5 = O5
    | after_restore I6 = O6
    | after_restore I7 = O7
    | after_restore L0 = raise OutOfScope L0
    | after_restore L1 = raise OutOfScope L1
    | after_restore L2 = raise OutOfScope L2
    | after_restore L3 = raise OutOfScope L3
    | after_restore L4 = raise OutOfScope L4
    | after_restore L5 = raise OutOfScope L5
    | after_restore L6 = raise OutOfScope L6
    | after_restore L7 = raise OutOfScope L7
    | after_restore O0 = raise OutOfScope O0
    | after_restore O1 = raise OutOfScope O1
    | after_restore O2 = raise OutOfScope O2
    | after_restore O3 = raise OutOfScope O3
    | after_restore O4 = raise OutOfScope O4
    | after_restore O5 = raise OutOfScope O5
    | after_restore O6 = raise OutOfScope O6
    | after_restore O7 = raise OutOfScope O7
    | after_restore G0 = G0
    | after_restore G1 = G1
    | after_restore G2 = G2
    | after_restore G3 = G3
    | after_restore G4 = G4
    | after_restore G5 = G5
    | after_restore G6 = G6
    | after_restore G7 = G7
    | after_restore cond = Crash.impossible"after_restore cond"    
    | after_restore heap = Crash.impossible"after_restore heap"
    | after_restore stack = Crash.impossible"after_restore stack"
    | after_restore y_reg = Crash.impossible"after_restore y_reg"
    | after_restore nil_v = Crash.impossible"after_restore nil_v"

  val bits_per_word = 30
  val digits_in_real = 64

  exception Ord and Chr

  val ord = fn x=>(ord (String.sub(x, 0))) handle ? => raise Ord
  val chr = fn x=>(String.str(chr x)) handle ? => raise Chr
  exception NeedsPreserve

  fun check_reg L0 = raise NeedsPreserve
  | check_reg L1 = raise NeedsPreserve
  | check_reg L2 = raise NeedsPreserve
  | check_reg L3 = raise NeedsPreserve
  | check_reg L4 = raise NeedsPreserve
  | check_reg L5 = raise NeedsPreserve
  | check_reg L6 = raise NeedsPreserve
  | check_reg L7 = raise NeedsPreserve
  | check_reg O0 = raise NeedsPreserve
  | check_reg O1 = raise NeedsPreserve
  | check_reg O2 = raise NeedsPreserve
  | check_reg O3 = raise NeedsPreserve
  | check_reg O4 = raise NeedsPreserve
  | check_reg O5 = raise NeedsPreserve
    (* We don't count this as an output
     *| check_reg O6 = raise NeedsPreserve
     *)
  | check_reg O7 = raise NeedsPreserve
  | check_reg _ = ()

end
@


1.41.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.41  1997/09/19  08:29:22  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
@


1.40
log
@Adding y register
@
text
@d4 3
d135 1
a137 1
require "^.basis.__old";
d435 2
a436 2
  val ord = fn x=>(Old.ord x) handle ? => raise Ord
  val chr = fn x=>(Old.chr x) handle ? => raise Chr
@


1.40.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.40  1997/01/17  13:07:40  matthew
 * Adding y register
 *
@


1.40.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.40  1997/01/17  13:07:40  matthew
 * Adding y register
 *
@


1.40.1.1
log
@branched from 1.40
@
text
@a3 3
 * Revision 1.40  1997/01/17  13:07:40  matthew
 * Adding y register
 *
@


1.40.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.40.1.1  1997/05/12  10:49:56  hope
 * branched from 1.40
 *
@


1.40.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.40.1.1  1997/05/12  10:49:56  hope
 * branched from 1.40
 *
@


1.40.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.40.1.1  1997/05/12  10:49:56  hope
 * branched from 1.40
 *
@


1.40.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.40.1.1.1.1  1997/07/28  18:32:09  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.39
log
@moving String from toplevel
@
text
@d4 3
d178 1
d249 1
d291 1
d329 1
d386 1
d424 1
@


1.39.4.1
log
@branched from 1.39
@
text
@a3 3
 * Revision 1.39  1996/10/29  18:09:38  io
 * moving String from toplevel
 *
@


1.39.3.1
log
@branched from 1.39
@
text
@a3 3
 * Revision 1.39  1996/10/29  18:09:38  io
 * moving String from toplevel
 *
@


1.39.3.1.1.1
log
@branched from 1.39.3.1
@
text
@a3 3
 * Revision 1.39.3.1  1996/12/17  17:59:52  hope
 * branched from 1.39
 *
@


1.39.2.1
log
@branched from 1.39
@
text
@a3 3
 * Revision 1.39  1996/10/29  18:09:38  io
 * moving String from toplevel
 *
@


1.39.1.1
log
@branched from 1.39
@
text
@a3 3
 * Revision 1.39  1996/10/29  18:09:38  io
 * moving String from toplevel
 *
@


1.39.1.1.1.1
log
@branched from 1.39.1.1
@
text
@a3 3
 * Revision 1.39.1.1  1996/11/14  13:04:27  hope
 * branched from 1.39
 *
@


1.38
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d131 1
d423 2
a424 2
  val ord = fn x=>(String.ord x) handle ? => raise Ord
  val chr = fn x=>(String.chr x) handle ? => raise Chr
@


1.38.3.1
log
@branched from 1.38
@
text
@a3 6
 * Revision 1.38  1996/04/30  16:18:36  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.38.2.1
log
@branched from 1.38
@
text
@a3 6
 * Revision 1.38  1996/04/30  16:18:36  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.38.1.1
log
@branched from 1.38
@
text
@a3 6
 * Revision 1.38  1996/04/30  16:18:36  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.37
log
@Add bits_per_word, remove max and min integer s and words
@
text
@d4 3
d416 2
a417 2
  val ord = fn x=>(ord x) handle ? => raise Ord
  val chr = fn x=>(chr x) handle ? => raise Chr
@


1.36
log
@Add largest_word machine limit
@
text
@d4 3
d408 1
a408 3
  val largest_int = "536870911"
  val smallest_int = "~536870912"
  val largest_word = "1073741823"
@


1.35
log
@Added *_arg_regs, removed *_arg2
@
text
@d4 3
d407 1
@


1.34
log
@Added extra argument register
@
text
@d4 3
d262 1
a262 1
    | reg_to_string G3 = "g3"
d311 2
a312 2
  val caller_arg2 = O2
  val callee_arg2 = I2
@


1.33
log
@Proper names for registers
@
text
@d4 3
d308 2
@


1.32
log
@Print registers as lower case name
@
text
@d229 2
a230 2
  fun reg_to_string I0 = "i0"
    | reg_to_string I1 = "i1"
d235 1
a235 1
    | reg_to_string I6 = "i6"
d245 2
a246 2
    | reg_to_string O0 = "o0"
    | reg_to_string O1 = "o1"
d251 5
a255 5
    | reg_to_string O6 = "o6"
    | reg_to_string O7 = "o7"
    | reg_to_string G0 = "g0"
    | reg_to_string G1 = "g1"
    | reg_to_string G2 = "g2"
d257 3
a259 3
    | reg_to_string G4 = "g4"
    | reg_to_string G5 = "g5"
    | reg_to_string G6 = "g6"
@


1.31
log
@Remove module type to separate file
@
text
@d4 3
d229 32
a260 32
  fun reg_to_string I0 = "I0"
    | reg_to_string I1 = "I1"
    | reg_to_string I2 = "I2"
    | reg_to_string I3 = "I3"
    | reg_to_string I4 = "I4"
    | reg_to_string I5 = "I5"
    | reg_to_string I6 = "I6"
    | reg_to_string I7 = "I7"
    | reg_to_string L0 = "L0"
    | reg_to_string L1 = "L1"
    | reg_to_string L2 = "L2"
    | reg_to_string L3 = "L3"
    | reg_to_string L4 = "L4"
    | reg_to_string L5 = "L5"
    | reg_to_string L6 = "L6"
    | reg_to_string L7 = "L7"
    | reg_to_string O0 = "O0"
    | reg_to_string O1 = "O1"
    | reg_to_string O2 = "O2"
    | reg_to_string O3 = "O3"
    | reg_to_string O4 = "O4"
    | reg_to_string O5 = "O5"
    | reg_to_string O6 = "O6"
    | reg_to_string O7 = "O7"
    | reg_to_string G0 = "G0"
    | reg_to_string G1 = "G1"
    | reg_to_string G2 = "G2"
    | reg_to_string G3 = "G3"
    | reg_to_string G4 = "G4"
    | reg_to_string G5 = "G5"
    | reg_to_string G6 = "G6"
    | reg_to_string G7 = "G7"
d266 32
a297 32
  fun fp_reg_to_string I0 = "F24"
    | fp_reg_to_string I1 = "F25"
    | fp_reg_to_string I2 = "F26"
    | fp_reg_to_string I3 = "F27"
    | fp_reg_to_string I4 = "F28"
    | fp_reg_to_string I5 = "F29"
    | fp_reg_to_string I6 = "F30"
    | fp_reg_to_string I7 = "F31"
    | fp_reg_to_string L0 = "F16"
    | fp_reg_to_string L1 = "F17"
    | fp_reg_to_string L2 = "F18"
    | fp_reg_to_string L3 = "F19"
    | fp_reg_to_string L4 = "F20"
    | fp_reg_to_string L5 = "F21"
    | fp_reg_to_string L6 = "F22"
    | fp_reg_to_string L7 = "F23"
    | fp_reg_to_string O0 = "F8"
    | fp_reg_to_string O1 = "F9"
    | fp_reg_to_string O2 = "F10"
    | fp_reg_to_string O3 = "F11"
    | fp_reg_to_string O4 = "F12"
    | fp_reg_to_string O5 = "F13"
    | fp_reg_to_string O6 = "F14"
    | fp_reg_to_string O7 = "F15"
    | fp_reg_to_string G0 = "F0"
    | fp_reg_to_string G1 = "F1"
    | fp_reg_to_string G2 = "F2"
    | fp_reg_to_string G3 = "F3"
    | fp_reg_to_string G4 = "F4"
    | fp_reg_to_string G5 = "F5"
    | fp_reg_to_string G6 = "F6"
    | fp_reg_to_string G7 = "F7"
@


1.30
log
@Fixed maximum and minimum integer sizes for lambda optimiser
@
text
@d4 3
a113 14
  datatype wordset = WORD_SET of string list * (int * int * string) list * bool list * int list
  datatype module_element =
    REAL of int * string |
    STRING of int * string |
    MLVALUE of int * MLWorks.Internal.Value.ml_value |
    WORDSET of wordset |
    EXTERNAL of int * string |
    VAR of int * string |
    EXN of int * string |
    STRUCT of int * string |
    FUNCT of int * string

  datatype Module = MODULE of module_element list

@


1.30.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.30  1993/07/14  11:12:37  jont
Fixed maximum and minimum integer sizes for lambda optimiser

@


1.29
log
@Added leaf and offsets lists into WORDSET
@
text
@d4 3
d402 2
a403 2
  val largest_int = "1073741823"
  val smallest_int = "~1073741824"
@


1.28
log
@Added type Module
@
text
@d4 3
d108 1
a108 1
  datatype wordset = WORD_SET of string list * (int * int * string) list
@


1.27
log
@Added MLVALUEs
@
text
@d4 3
d117 1
a117 1
  datatype module = MODULE of module_element list
@


1.26
log
@Changes for code vector reform.
@
text
@d4 3
d106 1
@


1.25
log
@Split store into three areas of heap, stack and nil vector for scheduling improvement
@
text
@d4 3
d99 1
a99 1
  datatype wordset = WORD_SET of (int * int * string) list
@


1.24
log
@Checked and corrected the specification for the floating point registers
@
text
@d4 3
d143 3
a145 1
    store
d213 3
a215 1
  | next_reg store = Crash.impossible"next_reg store"
d254 3
a256 1
    | reg_to_string store = "the memory"
d291 3
a293 1
    | fp_reg_to_string store = "the memory"
d344 4
a347 2
    | after_preserve cond = Crash.impossible"after_preserve cond"    
    | after_preserve store = Crash.impossible"after_preserve store"    
d382 3
a384 1
    | after_restore store = Crash.impossible"after_restore store"    
@


1.23
log
@Added furhter constructors to the module element type to express
interpretive stuff
@
text
@d4 4
d141 33
@


1.22
log
@Added code for non_gc spills number in front of code objects in a closure
@
text
@d4 3
d94 6
a99 1
    EXTERNAL of int * string
@


1.21
log
@Added stack limit register definitions
@
text
@d4 3
d86 1
a86 1
  datatype wordset = WORD_SET of (int * string) list
@


1.20
log
@Added fp_global as a temporary for conversions from fp to int
@
text
@d3 4
a6 1
$Log:	_machtypes.sml,v $
d249 1
@


1.19
log
@Added check_reg function from mach_cg to see when save/restore is needed
@
text
@d4 3
d244 1
@


1.18
log
@Added next_reg to give the next register up. Needed for doubel and extended
moves, abs, neg, and extended store operations
@
text
@d4 4
d323 23
a345 1
end;
@


1.17
log
@Added a maximum number of real digits, and a type to determine the
type of floating point in use
@
text
@d4 4
d116 35
@


1.16
log
@Added printing of floating point registers
@
text
@d4 3
d113 4
d274 1
@


1.15
log
@Added store register for detection of load/store interaction
@
text
@d4 3
d144 35
@


1.14
log
@Now knows about the `implicit' register.
@
text
@d4 3
d104 2
a105 1
    cond
d140 1
d190 1
d225 1
@


1.13
log
@Added cond register to represent the condition for the benefit of the
instruction scheduler
@
text
@d4 4
d104 33
a136 33
  | reg_to_string I1 = "I1"
  | reg_to_string I2 = "I2"
  | reg_to_string I3 = "I3"
  | reg_to_string I4 = "I4"
  | reg_to_string I5 = "I5"
  | reg_to_string I6 = "I6"
  | reg_to_string I7 = "I7"
  | reg_to_string L0 = "L0"
  | reg_to_string L1 = "L1"
  | reg_to_string L2 = "L2"
  | reg_to_string L3 = "L3"
  | reg_to_string L4 = "L4"
  | reg_to_string L5 = "L5"
  | reg_to_string L6 = "L6"
  | reg_to_string L7 = "L7"
  | reg_to_string O0 = "O0"
  | reg_to_string O1 = "O1"
  | reg_to_string O2 = "O2"
  | reg_to_string O3 = "O3"
  | reg_to_string O4 = "O4"
  | reg_to_string O5 = "O5"
  | reg_to_string O6 = "O6"
  | reg_to_string O7 = "O7"
  | reg_to_string G0 = "G0"
  | reg_to_string G1 = "G1"
  | reg_to_string G2 = "G2"
  | reg_to_string G3 = "G3"
  | reg_to_string G4 = "G4"
  | reg_to_string G5 = "G5"
  | reg_to_string G6 = "G6"
  | reg_to_string G7 = "G7"
  | reg_to_string cond = "the condition codes"

d148 2
a149 1

d151 34
a184 33
fun after_preserve I0 = raise OutOfScope I0
  | after_preserve I1 = raise OutOfScope I1
  | after_preserve I2 = raise OutOfScope I2
  | after_preserve I3 = raise OutOfScope I3
  | after_preserve I4 = raise OutOfScope I4
  | after_preserve I5 = raise OutOfScope I5
  | after_preserve I6 = raise OutOfScope I6
  | after_preserve I7 = raise OutOfScope I7
  | after_preserve L0 = raise OutOfScope L0
  | after_preserve L1 = raise OutOfScope L1
  | after_preserve L2 = raise OutOfScope L2
  | after_preserve L3 = raise OutOfScope L3
  | after_preserve L4 = raise OutOfScope L4
  | after_preserve L5 = raise OutOfScope L5
  | after_preserve L6 = raise OutOfScope L6
  | after_preserve L7 = raise OutOfScope L7
  | after_preserve O0 = I0
  | after_preserve O1 = I1
  | after_preserve O2 = I2
  | after_preserve O3 = I3
  | after_preserve O4 = I4
  | after_preserve O5 = I5
  | after_preserve O6 = I6
  | after_preserve O7 = I7
  | after_preserve G0 = G0
  | after_preserve G1 = G1
  | after_preserve G2 = G2
  | after_preserve G3 = G3
  | after_preserve G4 = G4
  | after_preserve G5 = G5
  | after_preserve G6 = G6
  | after_preserve G7 = G7
  | after_preserve cond = Crash.impossible"after_preserve cond"    
d186 33
a218 33
fun after_restore I0 = O0
  | after_restore I1 = O1
  | after_restore I2 = O2
  | after_restore I3 = O3
  | after_restore I4 = O4
  | after_restore I5 = O5
  | after_restore I6 = O6
  | after_restore I7 = O7
  | after_restore L0 = raise OutOfScope L0
  | after_restore L1 = raise OutOfScope L1
  | after_restore L2 = raise OutOfScope L2
  | after_restore L3 = raise OutOfScope L3
  | after_restore L4 = raise OutOfScope L4
  | after_restore L5 = raise OutOfScope L5
  | after_restore L6 = raise OutOfScope L6
  | after_restore L7 = raise OutOfScope L7
  | after_restore O0 = raise OutOfScope O0
  | after_restore O1 = raise OutOfScope O1
  | after_restore O2 = raise OutOfScope O2
  | after_restore O3 = raise OutOfScope O3
  | after_restore O4 = raise OutOfScope O4
  | after_restore O5 = raise OutOfScope O5
  | after_restore O6 = raise OutOfScope O6
  | after_restore O7 = raise OutOfScope O7
  | after_restore G0 = G0
  | after_restore G1 = G1
  | after_restore G2 = G2
  | after_restore G3 = G3
  | after_restore G4 = G4
  | after_restore G5 = G5
  | after_restore G6 = G6
  | after_restore G7 = G7
  | after_restore cond = Crash.impossible"after_restore cond"    
d227 1
a227 1
end
@


1.12
log
@New improved simplified module structure
@
text
@d4 3
d47 1
a47 1
require "../utils/set";
d51 3
a53 1
functor MachTypes() : MACHTYPES =
d96 2
a97 1
    G7
d131 1
d178 2
a179 1
    
d212 1
@


1.11
log
@Changed defn of FN_CALL
@
text
@d4 3
d51 1
a51 9
  datatype ext_ref = EXT of string (* Note index not required *)
  datatype local_ref = LOC of int
  datatype record_element =
    INT of int |
    LOC_REF of local_ref |
    EXT_REF of ext_ref
  datatype record = REC of record_element list
  datatype fn_call = CALL of int * int
  datatype wordset = WORD_SET of string list
d53 2
a54 2
    REAL of string |
    STRING of string |
d56 1
a56 3
    RECORD of record |
    INTEGER of string |
    FN_CALL of fn_call
@


1.10
log
@Added some new register definitions
@
text
@d4 3
d55 1
a55 1
  datatype fn_call = CALL of int * record_element
@


1.9
log
@Changed some register allocations
@
text
@d4 3
d130 4
a133 2
  val fn_arg = O0
  val cl_arg = O1
@


1.8
log
@New module structure with lists of functions
@
text
@d4 3
d127 5
a131 5
  val fn_arg = I0
  val cl_arg = I1
  val fp = I5
  val sp = I6
  val lr = I7
d171 8
a178 8
fun after_restore I0 = I0
  | after_restore I1 = I1
  | after_restore I2 = I2
  | after_restore I3 = I3
  | after_restore I4 = I4
  | after_restore I5 = I5
  | after_restore I6 = I6
  | after_restore I7 = I7
@


1.7
log
@Moved some machine specific information to MachSpec.
Changed Bad_Reg exception to include a value. It is now called
OutOfScope.
@
text
@d4 5
a38 1

d47 1
d51 1
a51 1
    WORDS of string |
@


1.6
log
@Changed the name of spillable_regs to gc_registers for consistency,
and added fp_registers and fp_double_registers.
@
text
@d4 4
d30 3
a32 3
functor MachTypes(
  structure Set : SET
) : MACHTYPES =
d34 1
a34 1
  structure Set = Set
d85 1
a118 5
  val gc_registers =
    Set.list_to_set [I0, I1, I2, I3, I4, O1, O2, O3, O4, O5, L0, L1, L2, L3, L4, L5, L6, L7, G5, G6]
  val non_gc_registers = Set.list_to_set [G7]
  val fp_registers = Set.empty_set
  val fp_double_registers = Set.empty_set
d128 18
a145 17
  exception Bad_Reg
  fun after_preserve I0 = raise Bad_Reg
  | after_preserve I1 = raise Bad_Reg
  | after_preserve I2 = raise Bad_Reg
  | after_preserve I3 = raise Bad_Reg
  | after_preserve I4 = raise Bad_Reg
  | after_preserve I5 = raise Bad_Reg
  | after_preserve I6 = raise Bad_Reg
  | after_preserve I7 = raise Bad_Reg
  | after_preserve L0 = raise Bad_Reg
  | after_preserve L1 = raise Bad_Reg
  | after_preserve L2 = raise Bad_Reg
  | after_preserve L3 = raise Bad_Reg
  | after_preserve L4 = raise Bad_Reg
  | after_preserve L5 = raise Bad_Reg
  | after_preserve L6 = raise Bad_Reg
  | after_preserve L7 = raise Bad_Reg
d162 2
a163 2

  fun after_restore I0 = I0
d171 16
a186 16
  | after_restore L0 = raise Bad_Reg
  | after_restore L1 = raise Bad_Reg
  | after_restore L2 = raise Bad_Reg
  | after_restore L3 = raise Bad_Reg
  | after_restore L4 = raise Bad_Reg
  | after_restore L5 = raise Bad_Reg
  | after_restore L6 = raise Bad_Reg
  | after_restore L7 = raise Bad_Reg
  | after_restore O0 = raise Bad_Reg
  | after_restore O1 = raise Bad_Reg
  | after_restore O2 = raise Bad_Reg
  | after_restore O3 = raise Bad_Reg
  | after_restore O4 = raise Bad_Reg
  | after_restore O5 = raise Bad_Reg
  | after_restore O6 = raise Bad_Reg
  | after_restore O7 = raise Bad_Reg
@


1.5
log
@More register names and fixed translations
@
text
@d4 3
d114 1
a114 1
  val spillable_regs =
d117 2
@


1.4
log
@Added register definitions etc
@
text
@d4 3
d28 17
d78 33
a110 1
  val fixed_regs = Set.list_to_set [I5, I6, I7, O5, O6, O7]
d112 2
a113 3
    Set.list_to_set [I0, I1, I2, I3, I4, O1, O2, O3, O4, O5, L0, L1, L2, L3, L4, L5, L6, L7, G3, G4, G5, G6, G7]
  val scratch_regs =
    Set.list_to_set [L0, L1, L2, L3, L4, L5, L6, L7, G3, G4, G5, G6, G7]
a115 1
  val cl_arg' = O1
d119 4
@


1.3
log
@Added exceptions Ord and Chr
@
text
@d4 3
d17 1
d21 1
d24 112
@


1.2
log
@Added string to int and int to string conversion functions in case we
want variations between host and target
@
text
@d4 4
d21 5
a25 2
  val ord = ord
  val chr = chr
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d17 2
@
