head	1.72;
access;
symbols
	MLW_daveb_inline_1_4_99:1.72.1
	MLWorks_21c0_1999_03_25:1.72
	MLWorks_20c1_1998_08_20:1.71
	MLWorks_20c0_1998_08_04:1.71
	MLWorks_20b2c2_1998_06_19:1.71
	MLWorks_20b2_Windows_1998_06_12:1.71
	MLWorks_20b1c1_1998_05_07:1.71
	MLWorks_20b0_1998_04_07:1.71
	MLWorks_20b0_1998_03_20:1.71
	MLWorks_20m2_1998_02_16:1.71
	MLWorks_20m1_1997_10_23:1.71
	MLWorks_11r1:1.68.1.1.1.1.1
	MLWorks_workspace_97:1.71.2
	MLWorks_dt_wizard:1.71.1
	MLWorks_11c0_1997_09_09:1.68.1.1.1.1
	MLWorks_10r3:1.68.1.1.3
	MLWorks_10r2_551:1.68.1.1.2
	MLWorks_11:1.68.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.68.1.1
	MLWorks_20m0_1997_06_20:1.71
	MLWorks_1_0_r2c2_1997_06_14:1.68.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.68.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.68.1
	MLWorks_BugFix_1997_04_24:1.68
	MLWorks_1_0_r2_Win32_1997_04_11:1.68
	MLWorks_1_0_r2_Unix_1997_04_04:1.68
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.64.3.1.1
	MLWorks_gui_1996_12_18:1.64.4
	MLWorks_1_0_Win32_1996_12_17:1.64.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.64.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.64.1.1
	MLWorks_1_0_Irix_1996_11_28:1.64.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.64.2
	MLWorks_1_0_Unix_1996_11_14:1.64.1
	MLWorks_Open_Beta2_1996_10_11:1.63.3
	MLWorks_License_dev:1.63.2
	MLWorks_1_open_beta_1996_09_13:1.63.1
	MLWorks_Open_Beta_1996_08_22:1.63
	MLWorks_Beta_1996_07_02:1.63
	MLWorks_Beta_1996_06_07:1.63
	MLWorks_Beta_1996_06_06:1.63
	MLWorks_Beta_1996_06_05:1.63
	MLWorks_Beta_1996_06_03:1.63
	MLWorks_Beta_1996_05_31:1.63
	MLWorks_Beta_1996_05_30:1.63
	ML_beta_release_12/08/94:1.50
	ML_beta_release_03/08/94:1.50
	ML_revised_beta_release_25/05/94:1.46
	ML_final_beta_release_02/03/94:1.43
	mlworks-28-01-1994:1.43
	Release:1.43
	mlworks-beta-01-09-1993:1.43
	MLWorks-1-0-4-29/01/1993:1.43
	MLWorks-1-0-3-21/12/1992:1.43
	MLWorks-1-0-2-15/12/1992:1.43
	MLWorks-1-0-1-04/12/1992:1.43
	checkpoint_17_08_92:1.37;
locks; strict;
comment	@ * @;


1.72
date	98.08.27.12.14.04;	author jont;	state Exp;
branches
	1.72.1.1;
next	1.71;

1.71
date	97.05.13.13.37.01;	author jont;	state Exp;
branches
	1.71.1.1
	1.71.2.1;
next	1.70;

1.70
date	97.05.01.13.17.54;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	97.04.24.15.47.03;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	97.03.25.13.46.51;	author matthew;	state Exp;
branches
	1.68.1.1;
next	1.67;

1.67
date	97.03.25.10.09.56;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	97.01.21.16.17.30;	author jont;	state Exp;
branches;
next	1.65;

1.65
date	97.01.02.12.33.25;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	96.11.01.13.28.15;	author jont;	state Exp;
branches
	1.64.1.1
	1.64.2.1
	1.64.3.1
	1.64.4.1;
next	1.63;

1.63
date	96.03.20.14.31.28;	author matthew;	state Exp;
branches
	1.63.1.1
	1.63.2.1
	1.63.3.1;
next	1.62;

1.62
date	95.12.22.12.55.26;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	95.08.14.16.15.53;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	95.08.14.11.48.58;	author jont;	state Exp;
branches;
next	1.59;

1.59
date	95.07.25.10.25.18;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	95.05.31.10.04.31;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	94.11.15.13.49.08;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	94.11.15.12.53.31;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	94.10.06.11.32.10;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	94.09.21.16.07.45;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	94.09.15.17.54.23;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	94.09.02.11.35.07;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	94.08.12.13.04.46;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	94.07.25.11.43.55;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	94.07.13.10.28.14;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	94.06.24.10.48.35;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	94.05.27.16.55.07;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	94.05.10.14.46.29;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	94.03.08.18.14.34;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	94.03.04.12.58.22;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	92.11.21.19.33.38;	author jont;	state Exp;
branches
	1.43.1.1;
next	1.42;

1.42
date	92.10.02.17.05.26;	author clive;	state Exp;
branches;
next	1.41;

1.41
date	92.09.15.11.05.20;	author clive;	state Exp;
branches;
next	1.40;

1.40
date	92.08.20.18.20.37;	author richard;	state Exp;
branches;
next	1.39;

1.39
date	92.08.19.12.14.25;	author richard;	state Exp;
branches;
next	1.38;

1.38
date	92.08.17.13.56.42;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	92.08.10.13.03.48;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	92.07.28.15.20.38;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.06.19.15.51.44;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	92.06.18.16.45.43;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.06.17.09.40.18;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	92.06.15.17.29.55;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	92.06.15.15.53.53;	author richard;	state Exp;
branches;
next	1.30;

1.30
date	92.06.11.09.21.26;	author clive;	state Exp;
branches;
next	1.29;

1.29
date	92.06.10.17.09.08;	author richard;	state Exp;
branches;
next	1.28;

1.28
date	92.06.08.15.25.12;	author richard;	state Exp;
branches;
next	1.27;

1.27
date	92.06.03.16.26.07;	author richard;	state Exp;
branches;
next	1.26;

1.26
date	92.05.20.10.30.09;	author clive;	state Exp;
branches;
next	1.25;

1.25
date	92.05.13.11.09.34;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.04.07.10.09.24;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	92.03.06.12.23.55;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.03.02.15.22.33;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	92.02.11.10.45.19;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.02.06.16.16.46;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.01.23.09.35.47;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.01.21.12.23.50;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.01.16.09.32.40;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.01.10.11.49.54;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.01.07.09.29.44;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.01.03.16.36.12;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	91.12.04.13.30.48;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	91.11.29.15.28.49;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	91.11.25.15.49.13;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.11.14.14.34.41;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.11.14.10.55.57;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	91.11.12.16.50.55;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.10.29.14.16.37;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.10.24.15.28.13;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	91.10.15.15.14.58;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.10.14.14.37.58;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.10.10.14.29.52;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.10.09.14.28.07;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.10.07.11.44.56;	author richard;	state Exp;
branches;
next	;

1.43.1.1
date	92.11.21.19.33.38;	author jont;	state Exp;
branches;
next	;

1.63.1.1
date	96.09.13.11.26.33;	author hope;	state Exp;
branches;
next	;

1.63.2.1
date	96.10.07.16.17.04;	author hope;	state Exp;
branches;
next	;

1.63.3.1
date	96.10.17.11.36.43;	author hope;	state Exp;
branches;
next	;

1.64.1.1
date	96.11.14.13.04.41;	author hope;	state Exp;
branches
	1.64.1.1.1.1;
next	;

1.64.1.1.1.1
date	96.11.28.15.14.07;	author hope;	state Exp;
branches;
next	;

1.64.2.1
date	96.11.22.18.22.08;	author hope;	state Exp;
branches;
next	;

1.64.3.1
date	96.12.17.18.00.07;	author hope;	state Exp;
branches
	1.64.3.1.1.1;
next	;

1.64.3.1.1.1
date	97.02.24.11.51.46;	author hope;	state Exp;
branches;
next	;

1.64.4.1
date	96.12.18.09.55.28;	author hope;	state Exp;
branches;
next	;

1.68.1.1
date	97.05.12.10.50.10;	author hope;	state Exp;
branches
	1.68.1.1.1.1
	1.68.1.1.2.1
	1.68.1.1.3.1;
next	;

1.68.1.1.1.1
date	97.07.28.18.32.23;	author daveb;	state Exp;
branches
	1.68.1.1.1.1.1.1;
next	;

1.68.1.1.1.1.1.1
date	97.10.07.11.58.30;	author jkbrook;	state Exp;
branches;
next	;

1.68.1.1.2.1
date	97.09.08.17.25.38;	author daveb;	state Exp;
branches;
next	;

1.68.1.1.3.1
date	97.09.09.14.22.17;	author daveb;	state Exp;
branches;
next	;

1.71.1.1
date	97.09.10.19.41.21;	author brucem;	state Exp;
branches;
next	;

1.71.2.1
date	97.09.11.21.08.56;	author daveb;	state Exp;
branches;
next	;

1.72.1.1
date	99.04.01.18.07.45;	author daveb;	state Exp;
branches;
next	;


desc
@Machine independent parameters. This is the functor.
@


1.72
log
@[Bug #70040]
Modify register colourer to use stack colourer only if requested from machspec
@
text
@(*   ==== MACHINE SPECIFICATION ====
 *              FUNCTOR
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 *  $Log: _machspec.sml,v $
 * Revision 1.71  1997/05/13  13:37:01  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
 * Revision 1.70  1997/05/01  13:17:54  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.69  1997/04/24  15:47:03  jont
 * [Bug #20007]
 * Adding reserved_but_preferencable registers
 *
 * Revision 1.68  1997/03/25  13:46:51  matthew
 * Adding mach_type value
 *
 * Revision 1.67  1997/03/25  10:09:56  matthew
 * Adding F4 to corrupted_by_callee FP registers
 *
 * Revision 1.66  1997/01/21  16:17:30  jont
 * Add in corrupted_by_alloc and leaf_regs
 *
 * Revision 1.65  1997/01/02  12:33:25  matthew
 * Adding fp_arg_regs
 *
 * Revision 1.64  1996/11/01  13:28:15  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
 * Revision 1.63  1996/03/20  14:31:28  matthew
 * Changes for new language definition
 *
 * Revision 1.62  1995/12/22  12:55:26  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
 *  Revision 1.61  1995/08/14  16:15:53  jont
 *  Remove bignum_inf stuff, not needed
 *
 *  Revision 1.60  1995/08/14  11:48:58  jont
 *  Add bits_per_word
 *
 *  Revision 1.59  1995/07/25  10:25:18  jont
 *  Add largest_word machine limit
 *
 *  Revision 1.58  1995/05/31  10:04:31  matthew
 *  Adding debugger_reserved register set
 *
 *  Revision 1.57  1994/11/15  13:49:08  jont
 *  Add has_immediate_store flag
 *
 *  Revision 1.56  1994/11/15  12:53:31  matthew
 *  Moved fp_global from gc reserved to fp reserved
 *
 *  Revision 1.55  1994/10/06  11:32:10  matthew
 *  Make callee_arg reserved so backtraces have a chance of working.
 *  This is not a real solution -- we need to make the set of reserved registers
 *  depend on the compiler options in force.
 *
 *  Revision 1.54  1994/09/21  16:07:45  jont
 *  Add do_unspill value to control register allocator
 *
 *  Revision 1.53  1994/09/15  17:54:23  jont
 *  Add chr and ord
 *  Also add Chr and Ord
 *
 *  Revision 1.52  1994/09/02  11:35:07  jont
 *  Reducing to two gc temporaries
 *  The two temporaries are L4 and O7
 *
 *  Revision 1.51  1994/08/12  13:04:46  matthew
 *  Removed caller_arg2 and tidied up
 *  Now have lists, caller_arg_regs and callee_arg_regs
 *
 *  Revision 1.50  1994/07/25  11:43:55  matthew
 *  Added some new argument registers.
 *
 *  Revision 1.49  1994/07/13  10:28:14  jont
 *  Add annotation about temporary register ordering
 *
 *  Revision 1.48  1994/06/24  10:48:35  jont
 *  Updates to use lr as unspill register
 *
 *  Revision 1.47  1994/05/27  16:55:07  jont
 *  Added floating point temporaries to the reserved list
 *
 *  Revision 1.46  1994/05/10  14:46:29  jont
 *  Remove lr, gc1, gc2, stack_limit from register interface
 *
 *  Revision 1.45  1994/03/08  18:14:34  jont
 *  Add digits_in_real
 *
 *  Revision 1.44  1994/03/04  12:58:22  jont
 *  Moved machspec into main
 *
 *  Revision 1.43  1992/11/21  19:33:38  jont
 *  Removed is_inline to machperv in order to remove dependence of entire
 *  mir stage on pervasives
 *
 *  Revision 1.42  1992/10/02  17:05:26  clive
 *  Change to NewMap.empty which now takes < and = functions instead of the single-function
 *
 *  Revision 1.41  1992/09/15  11:05:20  clive
 *  Checked and corrected the specification for the floating point registers
 *
 *  Revision 1.40  1992/08/20  18:20:37  richard
 *  Added ByteArray primitives.
 *
 *  Revision 1.39  1992/08/19  12:14:25  richard
 *  Added UNSAFE_SUB and UNSAFE_UPDATE to the pervasives.
 *
 *  Revision 1.38  1992/08/17  13:56:42  jont
 *  Added inline ordof
 *
 *  Revision 1.37  1992/08/10  13:03:48  richard
 *  Changed the set of corruptible floating point registers to make
 *  calling C easier.
 *
 *  Revision 1.36  1992/07/28  15:20:38  jont
 *  Added fp registers corrupted and allocation preference
 *
 *  Revision 1.35  1992/06/19  15:51:44  jont
 *  Added ML_REQUIRE builtin for interpreter to get builtin library
 *
 *  Revision 1.34  1992/06/18  16:45:43  jont
 *  Added new builtin ML_OFFSET for computing pointers into middles of
 *  letrec code vectors
 *
 *  Revision 1.33  1992/06/17  09:40:18  jont
 *  Made call_ml_value inline
 *
 *  Revision 1.32  1992/06/15  17:29:55  jont
 *  Added various builtins for interpreter
 *
 *  Revision 1.31  1992/06/15  15:53:53  richard
 *  Added extra temporary for GC and FP registers.
 *
 *  Revision 1.30  1992/06/11  09:21:26  clive
 *  Save argument for the debugger to use
 *
 *  Revision 1.29  1992/06/10  17:09:08  richard
 *  Improved register ordering for allocation.
 *
 *  Revision 1.29  1992/06/10  12:02:30  richard
 *  Improved register colouring order.
 *
 *  Revision 1.28  1992/06/08  15:25:12  richard
 *  Added allocation_order.
 *
 *  Revision 1.27  1992/06/03  16:26:07  richard
 *  The temporary registers are now complete sets rather than preferences.
 *  They are also reserved registers.
 *
 *  Revision 1.26  1992/05/20  10:30:09  clive
 *  Added arithmetic right shift
 *
 *  Revision 1.25  1992/05/13  11:09:34  clive
 *  Added the Bits structure
 *
 *  Revision 1.24  1992/04/07  10:09:24  richard
 *  Partitioned corrupted_by_callee according to register type to
 *  avoid naming clashes.
 *
 *  Revision 1.23  1992/03/06  12:23:55  clive
 *  G7 missed off the corrupted by callee list
 *
 *  Revision 1.22  1992/03/02  15:22:33  richard
 *  Added EQFUN pervasive (not inline) and changed EQ to be inline.
 *  See Mir_Cg.
 *
 *  Revision 1.21  1992/02/11  10:45:19  clive
 *  New pervasive library
 *
 *  Revision 1.20  1992/02/06  16:16:46  richard
 *  Added temporary.
 *
 *  Revision 1.19  1992/01/23  09:35:47  clive
 *  Added the EXSUBSCRIPTVAL and EXSIZEVAL
 *
 *  Revision 1.18  1992/01/21  12:23:50  clive
 *  Added some code to support the ref_chain
 *
 *  Revision 1.17  1992/01/16  09:32:40  clive
 *  Added arrays and made most of the functions in this structure inline coded
 *
 *  Revision 1.16  1992/01/10  11:49:54  richard
 *  Added substring pervasive as a temporary measure until compiler is bootstrapped.
 *
 *  Revision 1.15  1992/01/07  09:29:44  clive
 *  Added stack limit register definitions
 *
 *  Revision 1.14  1992/01/03  16:36:12  richard
 *  Added the zero register.  Added exception values to the is_inline
 *  function.  Tidied up documentation.
 *
 *  Revision 1.13  1991/12/04  13:30:48  richard
 *  Added the callee_closure to the reserved registers so that the
 *  garbage collector can always find the closure.
 *
 *  Revision 1.12  91/11/29  15:28:49  richard
 *  Added `reserved' to prevent register allocation from very special
 *  registers.
 *  
 *  Revision 1.11  91/11/25  15:49:13  jont
 *  Added fp_global as a temporary for conversions from fp to int
 *  
 *  Revision 1.10  91/11/14  14:34:41  richard
 *  Added is_inline clause for CALL_C and SYSTEM.
 *  
 *  Revision 1.9  91/11/14  10:55:57  richard
 *  Removed references to fp_double registers.
 *  
 *  Revision 1.8  91/11/12  16:50:55  jont
 *  Added is_inline function on the pervasives, this is where it should be
 *  Removed specific subfunctions to do with multiply etc capability
 *  
 *  Revision 1.7  91/10/29  14:16:37  jont
 *  Added values indicating existence on machin level multiply, divide
 *  and modulus
 *  
 *  Revision 1.6  91/10/24  15:28:13  davidt
 *  Now knows about the `implicit' register.
 *  
 *  Revision 1.5  91/10/15  15:14:58  richard
 *  Changed corrupted_by_callee to a set rather than a list.
 *  
 *  Revision 1.4  91/10/14  14:37:58  richard
 *  Added corrupted_by_callee and fixed the gc register list.
 *  
 *  Revision 1.3  91/10/10  14:29:52  richard
 *  indicates allocation preferences. after_preserve and after_restore
 *  discarded.
 *  
 *  Revision 1.2  91/10/09  14:28:07  richard
 *  Added some new register definitions
 *  
 *  Revision 1.1  91/10/07  11:44:56  richard
 *  Initial revision
 *)


require "../utils/set";
require "../utils/crash";
require "../main/machspec";
require "machtypes";


functor MachSpec (

  structure MachTypes	: MACHTYPES
  structure Set		: SET
  structure Crash       : CRASH
) : MACHSPEC =

struct

  structure Set = Set


  (* === What sort of machine is it? === *)

  datatype MachType = SPARC | MIPS | I386

  val mach_type : MachType = SPARC

  (*  === MACHINE REGISTERS ===  *)


  type register = MachTypes.Sparc_Reg



  local
    open MachTypes
  in

    (*  == Special registers ==  *)

    val caller_arg =		MachTypes.caller_arg
    val callee_arg =		MachTypes.callee_arg
    val caller_arg_regs =	MachTypes.caller_arg_regs
    val callee_arg_regs =	MachTypes.callee_arg_regs
    val caller_closure =	MachTypes.caller_closure
    val callee_closure =	MachTypes.callee_closure
    (* No F4 here as this is fp_global *)
    val fp_arg_regs =           [F0,F2,F6,F8,F10,F12,F14,F16]
    val tail_arg =		callee_arg
    val tail_closure = 		callee_closure
    val fp =			MachTypes.fp
    val sp =			MachTypes.sp
    val handler =		MachTypes.handler
    val global =		MachTypes.global
    val implicit =		MachTypes.implicit
    val fp_global =		MachTypes.fp_global

    val zero = SOME G0


    (*  == General registers ==
     *
     *  gcs:		int/ptr visible to garbage collector
     *  non_gcs:	int/ptr not visible to garbage collector
     *  fps:		floating point registers
     *)
    
    (* Version for new lambda optimiser -- I2 and O2 are for argument passing *)
    val gcs = [I0,I2,I3, I4, I5,
	       L0, L1, L2, L3, L4, L5, L6, L7,
               O0,O2,O3, O4, O5, lr, G7]

    val non_gcs = []

    val fps = case MachTypes.fp_used of
      MachTypes.single =>
        Crash.impossible "machspec not configured for single-float case"
    | MachTypes.double =>
        [F24,F26,F28,F30, F16,F18,F20,F22, F8,F10,F12,F14, F0,F2,F6]
    | MachTypes.extended =>
        Crash.impossible "machspec not configured for extended-float case"

    val empty_register_set = Set.empty_set : register Set.Set
    (* Until problems with restoring callee-save fp registers on exception raise *)
    (* is sorted out, we make all fp registers be caller-save *)
    val corrupted_by_callee =
      {gc = Set.list_to_set [O1, O2, O3, O4, O5, lr, G4, G5, G7],
       non_gc = empty_register_set,
       fp = Set.list_to_set[F0, F2, F4, F6, F8, F10, F12, F14, 
                            F16, F18, F20, F22, F24, F26, F28, F30] }

    val corrupted_by_alloc =
      {gc = Set.list_to_set [lr],
       non_gc = empty_register_set,
       fp = empty_register_set }

    val defined_on_entry =
      {gc = empty_register_set,
       non_gc = empty_register_set,
       fp = empty_register_set }

    val referenced_by_alloc =
      {gc = Set.list_to_set [callee_closure],
       (* This is to prevent callee_closure from being updated before an alloc *)
       (* which would then break the gc *)
       non_gc = empty_register_set,
       fp = empty_register_set }

    (*  == Reserved registers ==
     *
     *  These can never be used for anything except their special purpose,
     *  they can't even be temporarily spilled.  This list includes the
     *  temporary registers.
     *)

    (* Want to be able to experiment with this set *)
    val normal_temporaries = [L5]

    val reserved =
      {gc = Set.list_to_set ([callee_closure, sp, fp, global,
                             lr, gc1, gc2, implicit,
                             G0, stack_limit, handler] @@ normal_temporaries),
       non_gc = empty_register_set,
       fp = Set.list_to_set [fp_global, F24, F26, F28]}

    (* For debugging code, reserve callee_arg *)
    val debugging_reserved =
      {gc = Set.list_to_set([callee_arg] @@ [callee_closure, sp, fp, global,
					    lr, gc1, gc2, implicit,
					    G0, stack_limit, handler] @@ normal_temporaries),
       non_gc = empty_register_set,
       fp = Set.list_to_set[fp_global, F24, F26, F28]}

    val reserved_but_preferencable =
      {gc = [callee_closure, global, lr],
       non_gc = [],
       fp = [fp_global]}

    (* For debugging code, no extra preferencing *)
    val debugging_reserved_but_preferencable =
      {gc = [],
       non_gc = [],
       fp = []}

    (*  == Temporary registers ==
     *
     *  These are the registers reserved for use as temporaries for the
     *  register allocator.  Currently, two are required for each used
     *  register type.  It's best to use the O registers first for
     *  temporaries as these tend to be corrupted by subroutine calls in any
     *  case.
     *  The use of temporaries is preferenced, such that instruction requiring only
     *  one temporary will use the first in the list, etc. The ordering should be
     *  preserved in order to ensure that lr is not used as the destination of ALLOC
     *
     *)

    val temporary =
      {gc = normal_temporaries @@ [lr],
       non_gc = [] : register list,
       fp = [F24,F26,F28]}


    (*  == Allocation order ==
     *
     *  On the SPARC the I registers should be allocated randomly, since
     *  they cost nothing to save.  After that, the O registers should be
     *  used in preference to the L registers because this will tend to
     *  leave the L's free for variables which _need_ to be preserved across
     *  calls.
     *)

    local
      fun rank I0 = 0
        | rank I1 = 0
        | rank I2 = 0
        | rank I3 = 0
        | rank I4 = 0
        | rank I5 = 0
        | rank I6 = 0
        | rank I7 = 0
        | rank G0 = 0
        | rank G1 = 0
        | rank G2 = 0
        | rank G3 = 0
        | rank G4 = 0
        | rank G5 = 0
        | rank G6 = 0
        | rank G7 = 0
        | rank O0 = 1
        | rank O1 = 1
        | rank O2 = 1
        | rank O3 = 1
        | rank O4 = 1
        | rank O5 = 1
        | rank O6 = 1
        | rank O7 = 1
        | rank L0 = 2
        | rank L1 = 2
        | rank L2 = 2
        | rank L3 = 2
        | rank L4 = 2
        | rank L5 = 2
        | rank L6 = 2
        | rank L7 = 2
        | rank _ = 3

      fun order (reg, reg') =
        let
          val r = rank reg
          val r' = rank reg'
        in
          r < r' 
        end
 
     fun equal (reg, reg') =
        let
          val r = rank reg
          val r' = rank reg'
        in
          r = r' 
        end

      fun fp_order(reg, reg') =
	let
	  val b1 = Set.is_member(reg, #fp corrupted_by_callee)
	  val b2 = Set.is_member(reg', #fp corrupted_by_callee)
	in
          b1 andalso not b2
	end

     fun fp_equal(reg, reg') =
	let
	  val b1 = Set.is_member(reg, #fp corrupted_by_callee)
	  val b2 = Set.is_member(reg', #fp corrupted_by_callee)
	in
          b1 = b2
	end

    in
      val allocation_order =
        {gc = order,
         non_gc = order,
         fp = fp_order}
     val allocation_equal =
        {gc = equal,
         non_gc = equal,
         fp = fp_equal}
    end

  end


  (*  == Spill handling == *)

  val do_unspilling = true

  (*  == Register printing ==  *)

  val print_register = MachTypes.reg_to_string

  (* Immediate stores for CISCs *)

  val has_immediate_stores = false

  (*  === MACHINE LIMITS ===  *)

  val digits_in_real = MachTypes.digits_in_real
  val bits_per_word = MachTypes.bits_per_word
  val leaf_regs = 6

  (* === REGISTER ALLOCATION STRATEGY === *)

  val use_stack_colourer = true

  (*  === MACHINE FUNCTIONS === *)

  exception Ord = MachTypes.Ord
  exception Chr = MachTypes.Chr

  val ord = MachTypes.ord
  val chr = MachTypes.chr

end
@


1.72.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 4
 * Revision 1.72  1998/08/27  12:14:04  jont
 * [Bug #70040]
 * Modify register colourer to use stack colourer only if requested from machspec
 *
@


1.71
log
@[Bug #20038]
Add referenced_by_alloc
@
text
@d9 4
d516 4
@


1.71.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a8 4
 * Revision 1.71  1997/05/13  13:37:01  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.71.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a8 4
 * Revision 1.71  1997/05/13  13:37:01  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.70
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d9 4
d334 11
a344 1
      {gc = Set.list_to_set [lr, callee_closure],
a348 1

@


1.69
log
@[Bug #20007]
[Bug #20007]
Adding reserved_but_preferencable registers
@
text
@d9 4
d295 1
a295 1
    val zero = MLWorks.Option.SOME G0
@


1.68
log
@Adding mach_type value
@
text
@d9 3
d272 22
d326 3
a328 1
      {gc = Set.list_to_set [lr],
a332 22
    (*  == Special registers ==  *)

    val caller_arg =		MachTypes.caller_arg
    val callee_arg =		MachTypes.callee_arg
    val caller_arg_regs =	MachTypes.caller_arg_regs
    val callee_arg_regs =	MachTypes.callee_arg_regs
    val caller_closure =	MachTypes.caller_closure
    val callee_closure =	MachTypes.callee_closure
    (* No F4 here as this is fp_global *)
    val fp_arg_regs =           [F0,F2,F6,F8,F10,F12,F14,F16]
    val tail_arg =		callee_arg
    val tail_closure = 		callee_closure
    val fp =			MachTypes.fp
    val sp =			MachTypes.sp
    val handler =		MachTypes.handler
    val global =		MachTypes.global
    val implicit =		MachTypes.implicit
    val fp_global =		MachTypes.fp_global

    val zero = MLWorks.Option.SOME G0


d352 3
a354 3
      {gc = Set.list_to_set ([callee_arg] @@  [callee_closure, sp, fp, global,
                             lr, gc1, gc2, implicit,
                             G0, stack_limit, handler] @@ normal_temporaries),
d356 12
a367 1
       fp = Set.list_to_set [fp_global, F24, F26, F28]}
@


1.68.1.1
log
@branched from 1.68
@
text
@a8 3
 * Revision 1.68  1997/03/25  13:46:51  matthew
 * Adding mach_type value
 *
@


1.68.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 * Revision 1.68.1.1  1997/05/12  10:50:10  hope
 * branched from 1.68
 *
@


1.68.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 * Revision 1.68.1.1  1997/05/12  10:50:10  hope
 * branched from 1.68
 *
@


1.68.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 * Revision 1.68.1.1  1997/05/12  10:50:10  hope
 * branched from 1.68
 *
@


1.68.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 * Revision 1.68.1.1.1.1  1997/07/28  18:32:23  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.67
log
@Adding F4 to corrupted_by_callee FP registers
/
@
text
@d9 3
d251 6
@


1.66
log
@Add in corrupted_by_alloc and leaf_regs
@
text
@d9 3
d283 2
d288 2
a289 1
       fp = Set.list_to_set[F0, F2, F6, F8,F10,F12,F14, F16,F18,F20,F22, F24,F26,F28,F30] }
d305 2
a306 1
    val fp_arg_regs =           [F0,F2,F4,F6,F8,F10,F12,F14]
@


1.65
log
@Adding fp_arg_regs
@
text
@d9 3
d285 5
d462 1
@


1.64
log
@[Bug #1683]
Make all fp registers caller save
@
text
@d9 4
a226 1
require "../utils/lists";
a234 1
  structure Lists	: LISTS
d262 1
a262 2
    val gcs = Lists.difference 
             ([I0,I2,I3, I4, I5,
d264 1
a264 2
               O0,O2,O3, O4, O5, lr, G7],
              MachTypes.callee_arg_regs @@ MachTypes.caller_arg_regs)
d291 1
@


1.64.4.1
log
@branched from 1.64
@
text
@a8 4
 * Revision 1.64  1996/11/01  13:28:15  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
@


1.64.3.1
log
@branched from 1.64
@
text
@a8 4
 * Revision 1.64  1996/11/01  13:28:15  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
@


1.64.3.1.1.1
log
@branched from 1.64.3.1
@
text
@a8 3
 * Revision 1.64.3.1  1996/12/17  18:00:07  hope
 * branched from 1.64
 *
@


1.64.2.1
log
@branched from 1.64
@
text
@a8 4
 * Revision 1.64  1996/11/01  13:28:15  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
@


1.64.1.1
log
@branched from 1.64
@
text
@a8 4
 * Revision 1.64  1996/11/01  13:28:15  jont
 * [Bug #1683]
 * Make all fp registers caller save
 *
@


1.64.1.1.1.1
log
@branched from 1.64.1.1
@
text
@a8 3
 * Revision 1.64.1.1  1996/11/14  13:04:41  hope
 * branched from 1.64
 *
@


1.63
log
@Changes for new language definition
@
text
@d9 3
d280 1
a280 1
       fp = Set.list_to_set[F8,F10,F12,F14, F16,F18,F20,F22, F24,F26,F28,F30] }
@


1.63.3.1
log
@branched from 1.63
@
text
@a8 3
 * Revision 1.63  1996/03/20  14:31:28  matthew
 * Changes for new language definition
 *
@


1.63.2.1
log
@branched from 1.63
@
text
@a8 3
 * Revision 1.63  1996/03/20  14:31:28  matthew
 * Changes for new language definition
 *
@


1.63.1.1
log
@branched from 1.63
@
text
@a8 3
 * Revision 1.63  1996/03/20  14:31:28  matthew
 * Changes for new language definition
 *
@


1.62
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d9 4
d273 1
d276 1
a276 1
       non_gc = Set.empty_set,
d314 1
a314 1
       non_gc = Set.empty_set,
d322 1
a322 1
       non_gc = Set.empty_set,
d340 1
a340 1
       non_gc = [],
@


1.61
log
@Remove bignum_inf stuff, not needed
@
text
@d9 3
a215 1
require "../utils/option";
a226 1
  structure Option	: OPTION
a231 1
  structure Option = Option
d292 1
a292 1
    val zero = Option.PRESENT G0
@


1.60
log
@Add bits_per_word
@
text
@d9 3
a214 1
require "../utils/bignum";
a225 1
  structure BigNum      : BIGNUM
@


1.59
log
@Add largest_word machine limit
@
text
@d9 3
d212 1
d224 1
a224 1

a441 3
  val largest_int = MachTypes.largest_int
  val smallest_int = MachTypes.smallest_int
  val largest_word = MachTypes.largest_word
d443 1
@


1.58
log
@Adding debugger_reserved register set
@
text
@d9 3
d440 1
@


1.57
log
@Add has_immediate_store flag
@
text
@d9 3
d244 1
a244 8
(*
    val gcs = [I2, I3, I4, I5,
	       L0, L1, L2, L3, L4, L5, L6, L7,
               O2, O3, O4, O5, lr, G7]
*)

(* Really need to do something with this *)
(* Version for new lambda optimiser -- I2 and O2 are for argument passing *)
d298 8
@


1.56
log
@Moved fp_global from gc reserved to fp reserved
@
text
@d9 3
d424 4
@


1.55
log
@Make callee_arg reserved so backtraces have a chance of working.
This is not a real solution -- we need to make the set of reserved registers
depend on the compiler options in force.
@
text
@d9 5
d300 1
a300 1
                             lr, gc1, gc2, fp_global, implicit,
d303 1
a303 1
       fp = Set.list_to_set [F24, F26, F28]}
@


1.54
log
@Add do_unspill value to control register allocator
@
text
@d9 3
d294 1
a294 1
      {gc = Set.list_to_set ((* callee_arg_regs @@ *) [callee_closure, sp, fp, global,
@


1.53
log
@Add chr and ord
Also add Chr and Ord
@
text
@d9 4
d406 1
d408 1
d414 1
a414 3


    (*  === MACHINE LIMITS ===  *)
@


1.52
log
@Reducing to two gc temporaries
The two temporaries are L4 and O7
@
text
@d9 4
d415 8
@


1.51
log
@Removed caller_arg2 and tidied up
Now have lists, caller_arg_regs and callee_arg_regs
@
text
@d9 4
d280 1
a280 1
    val normal_temporaries = [L5,L6,L7]
d303 1
a303 1
      {gc = normal_temporaries (* @@ [lr] *),
@


1.50
log
@Added some new argument registers.
@
text
@d9 3
d179 1
d188 1
d218 1
d222 1
a222 1

d224 1
d226 2
a227 2
(*
    val gcs = [I3, I4, I5,
d229 2
a230 2
               O3, O4, O5, lr, G7]
*)
d252 2
a253 2
    val caller_arg2 =		MachTypes.caller_arg2
    val callee_arg2 =		MachTypes.callee_arg2
a256 1
    val tail_arg2 =		callee_arg2
d275 3
d279 1
a279 1
      {gc = Set.list_to_set [callee_arg, callee_closure, sp, fp, global,
d281 1
a281 1
                             G0, stack_limit, handler, O5, O4],
d299 1
a299 1
      {gc = [O5, O4, lr],
@


1.49
log
@Add annotation about temporary register ordering
@
text
@d9 3
d215 9
a223 1
	       O2, O3, O4, O5, lr, G7]
d245 2
d250 1
@


1.48
log
@Updates to use lr as unspill register
@
text
@d9 3
d269 4
@


1.47
log
@Added floating point temporaries to the reserved list
@
text
@d9 3
d209 1
a209 1
	       O2, O3, O4, O5, G7]
d222 1
a222 1
      {gc = Set.list_to_set [O1, O2, O3, O4, O5, G4, G5, G7],
d255 1
a255 1
                             G0, stack_limit, handler, O5, O4, O3],
d269 1
a269 1
      {gc = [O5, O4, O3],
@


1.46
log
@Remove lr, gc1, gc2, stack_limit from register interface
@
text
@d9 3
d254 1
a254 1
       fp = Set.list_to_set []}
@


1.45
log
@Add digits_in_real
@
text
@d9 3
a230 1
    val lr =			MachTypes.lr
a231 2
    val gc1 =			MachTypes.gc1
    val gc2 =			MachTypes.gc2
a234 2
    val implicit =		MachTypes.implicit
    val stack_limit =           MachTypes.stack_limit 
@


1.44
log
@Moved machspec into main
@
text
@d9 3
d372 1
@


1.43
log
@Removed is_inline to machperv in order to remove dependence of entire
mir stage on pervasives
@
text
@d9 4
d158 1
a158 1
require "machspec";
d221 2
@


1.43.1.1
log
@Fork for bug fixing
@
text
@a8 4
 *  Revision 1.43  1992/11/21  19:33:38  jont
 *  Removed is_inline to machperv in order to remove dependence of entire
 *  mir stage on pervasives
 *
@


1.42
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d9 3
a153 1
require "../main/pervasives";
a162 1
  structure Pervasives	: PERVASIVES
a169 1
  structure Pervasives = Pervasives
a362 138

  (*  === MACHINE CAPABILITIES ===  *)

  fun is_inline Pervasives.REF = true
    | is_inline Pervasives.EXABS = false
    | is_inline Pervasives.EXORD = false
    | is_inline Pervasives.EXCHR = false
    | is_inline Pervasives.EXDIV = false
    | is_inline Pervasives.EXMOD = false
    | is_inline Pervasives.EXQUOT = false
    | is_inline Pervasives.EXPROD = false
    | is_inline Pervasives.EXNEG = false
    | is_inline Pervasives.EXSUM = false
    | is_inline Pervasives.EXDIFF = false
    | is_inline Pervasives.EXFLOOR = false
    | is_inline Pervasives.EXSQRT = false
    | is_inline Pervasives.EXEXP = false
    | is_inline Pervasives.EXLN = false
    | is_inline Pervasives.EXIO = false
    | is_inline Pervasives.EXMATCH = false
    | is_inline Pervasives.EXBIND = false
    | is_inline Pervasives.EXINTERRUPT = false
    | is_inline Pervasives.EXRANGE = false
    | is_inline Pervasives.EXABSVAL = false
    | is_inline Pervasives.EXORDVAL = false
    | is_inline Pervasives.EXCHRVAL = false
    | is_inline Pervasives.EXDIVVAL = false
    | is_inline Pervasives.EXMODVAL = false
    | is_inline Pervasives.EXQUOTVAL = false
    | is_inline Pervasives.EXPRODVAL = false
    | is_inline Pervasives.EXNEGVAL = false
    | is_inline Pervasives.EXSUMVAL = false
    | is_inline Pervasives.EXDIFFVAL = false
    | is_inline Pervasives.EXFLOORVAL = false
    | is_inline Pervasives.EXSQRTVAL = false
    | is_inline Pervasives.EXEXPVAL = false
    | is_inline Pervasives.EXLNVAL = false
    | is_inline Pervasives.EXIOVAL = false
    | is_inline Pervasives.EXMATCHVAL = false
    | is_inline Pervasives.EXBINDVAL = false
    | is_inline Pervasives.EXINTERRUPTVAL = false
    | is_inline Pervasives.EXRANGEVAL = false
    | is_inline Pervasives.MAP = false
    | is_inline Pervasives.REV = false
    | is_inline Pervasives.NOT = false
    | is_inline Pervasives.ABS = true
    | is_inline Pervasives.FLOOR = true
    | is_inline Pervasives.REAL = true
  | is_inline Pervasives.SQRT = true
  | is_inline Pervasives.SIN = false
  | is_inline Pervasives.COS = false
  | is_inline Pervasives.ARCTAN = false
  | is_inline Pervasives.EXP = false
  | is_inline Pervasives.LN = false
  | is_inline Pervasives.SIZE = true
  | is_inline Pervasives.CHR = true
  | is_inline Pervasives.ORD = true
  | is_inline Pervasives.ORDOF = true
  | is_inline Pervasives.EXPLODE = false
  | is_inline Pervasives.IMPLODE = false
  | is_inline Pervasives.DEREF = true
  | is_inline Pervasives.FDIV = true
  | is_inline Pervasives.DIV = false
  | is_inline Pervasives.MOD = false
  | is_inline Pervasives.PLUS = false
  | is_inline Pervasives.STAR = false
  | is_inline Pervasives.MINUS = false
  | is_inline Pervasives.HAT = false
  | is_inline Pervasives.AT = false
  | is_inline Pervasives.NE = false
  | is_inline Pervasives.LESS = false
  | is_inline Pervasives.GREATER = false
  | is_inline Pervasives.LESSEQ = false
  | is_inline Pervasives.GREATEREQ = false
  | is_inline Pervasives.BECOMES = true
  | is_inline Pervasives.O = false
  | is_inline Pervasives.UMINUS = false
  | is_inline Pervasives.EQ = true
  | is_inline Pervasives.EQFUN = false
  | is_inline Pervasives.LOAD_STRING = true
  | is_inline Pervasives.REALPLUS = true
  | is_inline Pervasives.INTPLUS = true
  | is_inline Pervasives.REALSTAR = true
  | is_inline Pervasives.INTSTAR = false
  | is_inline Pervasives.REALMINUS = true
  | is_inline Pervasives.INTMINUS = true
  | is_inline Pervasives.REALUMINUS = true
  | is_inline Pervasives.INTUMINUS = true
  | is_inline Pervasives.INTLESS = true
  | is_inline Pervasives.REALLESS = true
  | is_inline Pervasives.INTGREATER = true
  | is_inline Pervasives.REALGREATER = true
  | is_inline Pervasives.INTLESSEQ = true
  | is_inline Pervasives.REALLESSEQ = true
  | is_inline Pervasives.INTGREATEREQ = true
  | is_inline Pervasives.REALGREATEREQ = true
  | is_inline Pervasives.INTEQ = true
  | is_inline Pervasives.INTNE = true
  | is_inline Pervasives.REALEQ = true
  | is_inline Pervasives.REALNE = true
  | is_inline Pervasives.STRINGEQ = false
  | is_inline Pervasives.STRINGNE = false
  | is_inline Pervasives.INTABS = true
  | is_inline Pervasives.REALABS = true
  | is_inline Pervasives.CALL_C = true
    | is_inline Pervasives.ARRAY_FN = true
    | is_inline Pervasives.LENGTH = true
    | is_inline Pervasives.SUB  = true
    | is_inline Pervasives.UPDATE = true
    | is_inline Pervasives.UNSAFE_SUB  = true
    | is_inline Pervasives.UNSAFE_UPDATE = true
    | is_inline Pervasives.BYTEARRAY = true
    | is_inline Pervasives.BYTEARRAY_LENGTH = true
    | is_inline Pervasives.BYTEARRAY_SUB  = true
    | is_inline Pervasives.BYTEARRAY_UPDATE = true
    | is_inline Pervasives.BYTEARRAY_UNSAFE_SUB  = true
    | is_inline Pervasives.BYTEARRAY_UNSAFE_UPDATE = true
    | is_inline Pervasives.EXSIZE = false
    | is_inline Pervasives.EXSUBSCRIPT = false
    | is_inline Pervasives.EXSIZEVAL = false
    | is_inline Pervasives.EXSUBSCRIPTVAL = false
    | is_inline Pervasives.ANDB = true
    | is_inline Pervasives.LSHIFT = true
    | is_inline Pervasives.NOTB = true
    | is_inline Pervasives.ORB = true
    | is_inline Pervasives.RSHIFT = true 
    | is_inline Pervasives.ARSHIFT = true 
    | is_inline Pervasives.XORB = true 
    | is_inline Pervasives.IDENT_FN = false
    | is_inline Pervasives.ML_OFFSET = true
    | is_inline Pervasives.ENTUPLE = false
    | is_inline Pervasives.ML_CALL = true
    | is_inline Pervasives.ML_REQUIRE = false
    | is_inline Pervasives.LOAD_VAR = true
    | is_inline Pervasives.LOAD_EXN = true
    | is_inline Pervasives.LOAD_STRUCT = true
    | is_inline Pervasives.LOAD_FUNCT = true

@


1.41
log
@Checked and corrected the specification for the floating point registers
@
text
@d9 3
a269 2
    datatype relation = LESS | EQUAL | GREATER

d310 1
a310 1
          if r = r' then EQUAL else if r < r' then LESS else GREATER
d312 8
d326 1
a326 4
	  if b1 then
	    if b2 then EQUAL else LESS
	  else
	    if b2 then GREATER else EQUAL
d329 8
d342 4
@


1.40
log
@Added ByteArray primitives.
@
text
@d9 3
d146 1
d157 1
d196 1
a196 2
	[I0, I1, I2, I3, I4, I5, I6, I7, L0, L1, L2, L3, L4, L5, L6, L7,
	 O0, O1, O2, O3, O4, O5, O6, O7, G0, G1, G2, G3(*, G4*), G5, G6, G7]
d198 1
a198 1
	[I0, I2, I4, I6, L0, L2, L4, L6, O0, O2, O4, O6, G0, G2(*, G4*), G6]
d200 1
a200 1
	[I0, I4, L0, L4, O0, O4, G0(*, G4*)]
d205 1
a205 1
       fp = Set.list_to_set[O0, O2, O4, O6, L0, L2, L4, L6, I0, I2, I4, I6]}
d241 1
a241 1
       fp = Set.list_to_set [I0, I2]}
d255 1
a255 1
       fp = [I0, I2, I4]}
@


1.39
log
@Added UNSAFE_SUB and UNSAFE_UPDATE to the pervasives.
@
text
@d9 3
d363 1
d382 1
d452 6
@


1.38
log
@Added inline ordof
@
text
@d9 3
d445 2
@


1.37
log
@Changed the set of corruptible floating point registers to make
calling C easier.
@
text
@d9 4
d390 1
@


1.36
log
@Added fp registers corrupted and allocation preference
@
text
@d9 3
d191 1
a191 1
       fp = Set.list_to_set[O0, O2, O4, O6, G0, G2, G6]}
d297 1
@


1.35
log
@Added ML_REQUIRE builtin for interpreter to get builtin library
@
text
@d9 3
d188 1
a188 1
       fp = Set.empty_set}
d294 11
d309 1
a309 1
         fp = fn (r, r') => EQUAL}
@


1.34
log
@Added new builtin ML_OFFSET for computing pointers into middles of
letrec code vectors
@
text
@d9 4
d434 1
@


1.33
log
@Made call_ml_value inline
@
text
@d9 3
d427 1
@


1.32
log
@Added various builtins for interpreter
@
text
@d9 3
d425 1
a425 1
    | is_inline Pervasives.ML_CALL = false
@


1.31
log
@Added extra temporary for GC and FP registers.
@
text
@d9 3
d420 7
@


1.30
log
@Save argument for the debugger to use
@
text
@d9 3
d204 1
a204 1
      {gc = Set.list_to_set [callee_arg,callee_closure, sp, fp, global,
d206 1
a206 1
                             G0, stack_limit, handler, O5, O4],
d220 1
a220 1
      {gc = [O5, O4],
d222 1
a222 1
       fp = [I0, I2]}
@


1.29
log
@Improved register ordering for allocation.
@
text
@d9 3
d201 1
a201 1
      {gc = Set.list_to_set [callee_closure, sp, fp, global,
@


1.28
log
@Added allocation_order.
@
text
@d9 6
d222 4
a225 2
     *  they cost nothing to save.  Once the L and O registers have been
     *  broached they should be used also.
d231 33
a263 9
        fun is_in I0 = true
          | is_in I1 = true
          | is_in I2 = true
          | is_in I3 = true
          | is_in I4 = true
          | is_in I5 = true
          | is_in I6 = true
          | is_in I7 = true
          | is_in _  = false
d265 7
a271 5
        fun i_before_o (r, r') =
          if is_in r then
            if is_in r' then EQUAL else LESS
          else
            if is_in r' then GREATER else EQUAL
d274 2
a275 2
        {gc = i_before_o,
         non_gc = i_before_o,
@


1.27
log
@The temporary registers are now complete sets rather than preferences.
They are also reserved registers.
@
text
@d9 4
d211 33
@


1.26
log
@Added arithmetic right shift
@
text
@d9 3
d183 2
a184 1
     *  they can't even be temporarily spilled.
d188 5
a192 3
      Set.list_to_set [callee_closure, sp, fp, global,
                       lr, gc1, gc2, fp_global, implicit,
                       G0, stack_limit, handler]
d196 5
a200 4
     *  These are recommendations.  It's best to use the O registers first
     *  for temporaries as these tend to be corrupted by subroutine calls in
     *  any case.  There is no particular preference for floating point
     *  registers.
d204 1
a204 1
      {gc = [O5, O4, O3, O2, G7, L7, L6, L5, L4, L3, L2, L1, L0],
d206 1
a206 1
       fp = fps}
@


1.25
log
@Added the Bits structure
@
text
@d9 3
d331 1
@


1.24
log
@Partitioned corrupted_by_callee according to register type to
avoid naming clashes.
@
text
@d9 4
d217 42
a258 42
  | is_inline Pervasives.EXABS = false
  | is_inline Pervasives.EXORD = false
  | is_inline Pervasives.EXCHR = false
  | is_inline Pervasives.EXDIV = false
  | is_inline Pervasives.EXMOD = false
  | is_inline Pervasives.EXQUOT = false
  | is_inline Pervasives.EXPROD = false
  | is_inline Pervasives.EXNEG = false
  | is_inline Pervasives.EXSUM = false
  | is_inline Pervasives.EXDIFF = false
  | is_inline Pervasives.EXFLOOR = false
  | is_inline Pervasives.EXSQRT = false
  | is_inline Pervasives.EXEXP = false
  | is_inline Pervasives.EXLN = false
  | is_inline Pervasives.EXIO = false
  | is_inline Pervasives.EXMATCH = false
  | is_inline Pervasives.EXBIND = false
  | is_inline Pervasives.EXINTERRUPT = false
  | is_inline Pervasives.EXABSVAL = false
  | is_inline Pervasives.EXORDVAL = false
  | is_inline Pervasives.EXCHRVAL = false
  | is_inline Pervasives.EXDIVVAL = false
  | is_inline Pervasives.EXMODVAL = false
  | is_inline Pervasives.EXQUOTVAL = false
  | is_inline Pervasives.EXPRODVAL = false
  | is_inline Pervasives.EXNEGVAL = false
  | is_inline Pervasives.EXSUMVAL = false
  | is_inline Pervasives.EXDIFFVAL = false
  | is_inline Pervasives.EXFLOORVAL = false
  | is_inline Pervasives.EXSQRTVAL = false
  | is_inline Pervasives.EXEXPVAL = false
  | is_inline Pervasives.EXLNVAL = false
  | is_inline Pervasives.EXIOVAL = false
  | is_inline Pervasives.EXMATCHVAL = false
  | is_inline Pervasives.EXBINDVAL = false
  | is_inline Pervasives.EXINTERRUPTVAL = false
  | is_inline Pervasives.MAP = false
  | is_inline Pervasives.REV = false
  | is_inline Pervasives.NOT = false
  | is_inline Pervasives.ABS = true
  | is_inline Pervasives.FLOOR = true
  | is_inline Pervasives.REAL = true
d315 14
a328 8
  | is_inline Pervasives.ARRAY_FN = true
  | is_inline Pervasives.LENGTH = true
  | is_inline Pervasives.SUB  = true
  | is_inline Pervasives.UPDATE = true
  | is_inline Pervasives.EXSIZE = false
  | is_inline Pervasives.EXSUBSCRIPT = false
  | is_inline Pervasives.EXSIZEVAL = false
  | is_inline Pervasives.EXSUBSCRIPTVAL = false
@


1.23
log
@G7 missed off the corrupted by callee list
@
text
@d9 3
d144 3
a146 1
      Set.list_to_set [O1, O2, O3, O4, O5, G4, G5, G7 ]
@


1.22
log
@Added EQFUN pervasive (not inline) and changed EQ to be inline.
See Mir_Cg.
@
text
@d9 4
d141 1
a141 1
      Set.list_to_set [O1, O2, O3, O4, O5, G4, G5 (*, G6 no one changes the stack limit *) ]
@


1.21
log
@New pervasive library
@
text
@d9 3
d274 2
a275 1
  | is_inline Pervasives.EQ = false
d302 8
a309 8
    | is_inline Pervasives.ARRAY_FN = true
    | is_inline Pervasives.LENGTH = true
    | is_inline Pervasives.SUB  = true
    | is_inline Pervasives.UPDATE = true
    | is_inline Pervasives.EXSIZE = false
    | is_inline Pervasives.EXSUBSCRIPT = false
    | is_inline Pervasives.EXSIZEVAL = false
    | is_inline Pervasives.EXSUBSCRIPTVAL = false
@


1.20
log
@Added temporary.
@
text
@d9 3
d239 1
a239 1
  | is_inline Pervasives.NOT = true
d269 1
a269 1
  | is_inline Pervasives.O = true
a271 10
  | is_inline Pervasives.STD_IN = true
  | is_inline Pervasives.STD_OUT = true
  | is_inline Pervasives.OPEN_IN = false
  | is_inline Pervasives.OPEN_OUT = false
  | is_inline Pervasives.INPUT = false
  | is_inline Pervasives.LOOKAHEAD = false
  | is_inline Pervasives.CLOSE_IN = false
  | is_inline Pervasives.END_OF_STREAM = false
  | is_inline Pervasives.OUTPUT = false
  | is_inline Pervasives.CLOSE_OUT = false
a297 3
  | is_inline Pervasives.SYSTEM = false
  | is_inline Pervasives.SUBSTRING = false
    | is_inline Pervasives.ARRAY = false
a298 1
    | is_inline Pervasives.ARRAY_OF_LIST = false
a300 1
    | is_inline Pervasives.TABULATE = false
@


1.19
log
@Added the EXSUBSCRIPTVAL and EXSIZEVAL
@
text
@d9 3
d117 1
a117 3
	       O2, O3, O4, O5,
	       (* G6, now stack limit - I presume this is needed only if the register is ever spilled, but this is not possible as this particular register is marked as special *)
	       G7]
d163 15
a177 1
                       lr, gc1, gc2, fp_global, implicit, G0,stack_limit (* can't place this on the stack *) ]
@


1.18
log
@Added some code to support the ref_chain
@
text
@d9 3
d301 3
@


1.17
log
@Added arrays and made most of the functions in this structure inline coded
@
text
@d9 3
d143 1
@


1.16
log
@Added substring pervasive as a temporary measure until compiler is bootstrapped.
@
text
@d9 3
d285 9
@


1.15
log
@Added stack limit register definitions
@
text
@d9 3
d281 1
@


1.14
log
@Added the zero register.  Added exception values to the is_inline
function.  Tidied up documentation.
@
text
@d9 4
d103 2
a104 1
	       G6, G7]
d118 1
a118 1
      Set.list_to_set [O1, O2, O3, O4, O5, G4, G5, G6]
d136 1
d149 1
a149 1
                       lr, gc1, gc2, fp_global, implicit, G0]
@


1.13
log
@Added the callee_closure to the reserved registers so that the
garbage collector can always find the closure.
@
text
@d1 52
a52 1
(* machspec.sml the functor *)
a53 4
(* $Log:	_machspec.sml,v $
Revision 1.12  91/11/29  15:28:49  richard
Added `reserved' to prevent register allocation from very special
registers.
a54 39
Revision 1.11  91/11/25  15:49:13  jont
Added fp_global as a temporary for conversions from fp to int

Revision 1.10  91/11/14  14:34:41  richard
Added is_inline clause for CALL_C and SYSTEM.

Revision 1.9  91/11/14  10:55:57  richard
Removed references to fp_double registers.

Revision 1.8  91/11/12  16:50:55  jont
Added is_inline function on the pervasives, this is where it should be
Removed specific subfunctions to do with multiply etc capability

Revision 1.7  91/10/29  14:16:37  jont
Added values indicating existence on machin level multiply, divide
and modulus

Revision 1.6  91/10/24  15:28:13  davidt
Now knows about the `implicit' register.

Revision 1.5  91/10/15  15:14:58  richard
Changed corrupted_by_callee to a set rather than a list.

Revision 1.4  91/10/14  14:37:58  richard
Added corrupted_by_callee and fixed the gc register list.

Revision 1.3  91/10/10  14:29:52  richard
indicates allocation preferences. after_preserve and after_restore
discarded.

Revision 1.2  91/10/09  14:28:07  richard
Added some new register definitions

Revision 1.1  91/10/07  11:44:56  richard
Initial revision

Copyright (C) 1991 Harlequin Ltd
*)

d56 1
d66 3
a68 1
  structure Pervasives : PERVASIVES
d75 1
d132 1
d134 1
d143 1
a143 1
                       lr, gc1, gc2, fp_global, implicit]
d182 18
@


1.12
log
@Added `reserved' to prevent register allocation from very special
registers.
@
text
@d4 4
d65 1
d128 2
a129 1
      Set.list_to_set [sp, fp, global, lr, gc1, gc2, fp_global, implicit]
@


1.11
log
@Added fp_global as a temporary for conversions from fp to int
@
text
@d4 3
d114 11
d128 2
a206 1
  | is_inline Pervasives.MAKE_NEW_UNIQUE = false
@


1.10
log
@Added is_inline clause for CALL_C and SYSTEM.
@
text
@d4 3
d86 1
a86 1
	 O0, O1, O2, O3, O4, O5, O6, O7, G0, G1, G2, G3, G4, G5, G6, G7]
d88 1
a88 1
	[I0, I2, I4, I6, L0, L2, L4, L6, O0, O2, O4, O6, G0, G2, G4, G6]
d90 1
a90 1
	[I0, I4, L0, L4, O0, O4, G0, G4]
d109 1
@


1.9
log
@Removed references to fp_double registers.
@
text
@d4 3
d213 2
a214 1
  | is_inline Pervasives.CALL_C = false
@


1.8
log
@Added is_inline function on the pervasives, this is where it should be
Removed specific subfunctions to do with multiply etc capability
@
text
@d4 4
a67 1
     *  fp_doubles:	double floating point registers
a84 2

    val fp_doubles = []
@


1.7
log
@Added values indicating existence on machin level multiply, divide
and modulus
@
text
@d4 4
d31 1
d40 1
a40 1

d43 1
a43 1
  struct
d45 2
a46 1
    structure Set = Set
d48 1
a49 1
    (*  === MACHINE REGISTERS ===  *)
d51 1
a52 1
    type register = MachTypes.Sparc_Reg
d55 3
d59 12
a70 3
    local
      open MachTypes
    in
d72 1
a72 7
      (*  == General registers ==
       *
       *  gcs:		int/ptr visible to garbage collector
       *  non_gcs:	int/ptr not visible to garbage collector
       *  fps:		floating point registers
       *  fp_doubles:	double floating point registers
       *)
d74 8
a81 4
      val gcs = [I2, I3, I4, I5,
		 L0, L1, L2, L3, L4, L5, L6, L7,
		 O2, O3, O4, O5,
		 G6]
d83 1
a83 1
      val non_gcs = [G7]
d85 2
a86 1
      val fps = []
a87 1
      val fp_doubles = []
d89 1
a89 2
      val corrupted_by_callee =
	Set.list_to_set [O1, O2, O3, O4, O5, G4, G5, G6]
d91 13
a104 1
      (*  == Special registers ==  *)
d106 1
a106 13
      val caller_arg =		MachTypes.caller_arg
      val callee_arg =		MachTypes.callee_arg
      val caller_closure =	MachTypes.caller_closure
      val callee_closure =	MachTypes.callee_closure
      val fp =			MachTypes.fp
      val sp =			MachTypes.sp
      val lr =			MachTypes.lr
      val handler =		MachTypes.handler
      val gc1 =			MachTypes.gc1
      val gc2 =			MachTypes.gc2
      val global =		MachTypes.global
      val implicit =		MachTypes.implicit
    end
d108 1
a109 1
    (*  == Register printing ==  *)
a110 1
    val print_register = MachTypes.reg_to_string
a111 2


d114 2
a115 2
    val largest_int = MachTypes.largest_int
    val smallest_int = MachTypes.smallest_int
d117 1
a117 1
    (*  === MACHINE CAPABILITIES ===  *)
d119 91
a209 3
    val has_mul	= false
    val has_div	= false
    val has_mod	= false
d211 1
a211 1
  end
@


1.6
log
@Now knows about the `implicit' register.
@
text
@d4 3
d105 5
@


1.5
log
@Changed corrupted_by_callee to a set rather than a list.
@
text
@d4 3
d62 1
a62 1
		 G5, G6]
d87 1
a87 1

@


1.4
log
@Added corrupted_by_callee and fixed the gc register list.
@
text
@d4 3
d20 1
d28 1
d34 1
d36 1
d67 2
a68 1
      val corrupted_by_callee = [O1, O2, O3, O4, O5, G4, G5, G6]
@


1.3
log
@indicates allocation preferences. after_preserve and after_restore
discarded.
@
text
@d4 4
d49 1
a49 2
      val gcs = [I0, I1, I2, I3, I4,
		 O1, O2, O3, O4, O5,
d51 1
d59 2
@


1.2
log
@Added some new register definitions
@
text
@d4 3
a12 1
require "../utils/set";
a19 1
  structure Set		: SET
a25 3
    structure Set = Set


d45 4
a48 5
      val gcs : register Set.Set =
	Set.list_to_set [I0, I1, I2, I3, I4,
			 O1, O2, O3, O4, O5,
			 L0, L1, L2, L3, L4, L5, L6, L7,
			 G5, G6]
d50 1
a50 2
      val non_gcs : register Set.Set =
	Set.list_to_set [G7]
d52 1
a52 2
      val fps : register Set.Set =
	Set.empty_set
d54 1
a54 2
      val fp_doubles : register Set.Set =
	Set.empty_set
a71 7


    (*  == Support for register windows ==  *)

    exception OutOfScope = MachTypes.OutOfScope
    val after_preserve = MachTypes.after_preserve
    val after_restore  = MachTypes.after_restore
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
(* $Log$
d65 11
a75 9
      val fn_arg =	MachTypes.fn_arg
      val cl_arg =	MachTypes.cl_arg
      val fp =		MachTypes.fp
      val sp =		MachTypes.sp
      val lr =		MachTypes.lr
      val handler =	MachTypes.handler
      val gc1 =		MachTypes.gc1
      val gc2 =		MachTypes.gc2
      val global =	MachTypes.global
@
