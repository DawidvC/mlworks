head	1.22;
access;
symbols
	MLW_daveb_inline_1_4_99:1.22.3
	MLWorks_21c0_1999_03_25:1.22
	MLWorks_20c1_1998_08_20:1.22
	MLWorks_20c0_1998_08_04:1.22
	MLWorks_20b2c2_1998_06_19:1.22
	MLWorks_20b2_Windows_1998_06_12:1.22
	MLWorks_20b1c1_1998_05_07:1.22
	MLWorks_20b0_1998_04_07:1.22
	MLWorks_20b0_1998_03_20:1.22
	MLWorks_20m2_1998_02_16:1.22
	MLWorks_20m1_1997_10_23:1.22
	MLWorks_11r1:1.21.1.1.1.1.1
	MLWorks_workspace_97:1.22.2
	MLWorks_dt_wizard:1.22.1
	MLWorks_11c0_1997_09_09:1.21.1.1.1.1
	MLWorks_10r3:1.21.1.1.3
	MLWorks_10r2_551:1.21.1.1.2
	MLWorks_11:1.21.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.21.1.1
	MLWorks_20m0_1997_06_20:1.22
	MLWorks_1_0_r2c2_1997_06_14:1.21.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.21.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.21.1
	MLWorks_BugFix_1997_04_24:1.21
	MLWorks_1_0_r2_Win32_1997_04_11:1.21
	MLWorks_1_0_r2_Unix_1997_04_04:1.21
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.20.6.1.1
	MLWorks_gui_1996_12_18:1.20.7
	MLWorks_1_0_Win32_1996_12_17:1.20.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.20.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.20.4.1
	MLWorks_1_0_Irix_1996_11_28:1.20.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.20.5
	MLWorks_1_0_Unix_1996_11_14:1.20.4
	MLWorks_Open_Beta2_1996_10_11:1.20.3
	MLWorks_License_dev:1.20.2
	MLWorks_1_open_beta_1996_09_13:1.20.1
	MLWorks_Open_Beta_1996_08_22:1.20
	MLWorks_Beta_1996_07_02:1.20
	MLWorks_Beta_1996_06_07:1.20
	MLWorks_Beta_1996_06_06:1.20
	MLWorks_Beta_1996_06_05:1.20
	MLWorks_Beta_1996_06_03:1.20
	MLWorks_Beta_1996_05_31:1.20
	MLWorks_Beta_1996_05_30:1.20
	ML_beta_release_12/08/94:1.17
	ML_beta_release_03/08/94:1.17
	ML_revised_beta_release_25/05/94:1.17
	ML_final_beta_release_02/03/94:1.15
	mlworks-28-01-1994:1.15
	Release:1.15
	mlworks-beta-01-09-1993:1.15
	MLWorks-1-0-4-29/01/1993:1.12
	MLWorks-1-0-3-21/12/1992:1.11
	MLWorks-1-0-2-15/12/1992:1.11
	MLWorks-1-0-1-04/12/1992:1.10
	checkpoint_17_08_92:1.9;
locks; strict;
comment	@ * @;


1.22
date	97.05.01.12.53.08;	author jont;	state Exp;
branches
	1.22.1.1
	1.22.2.1
	1.22.3.1;
next	1.21;

1.21
date	97.01.17.13.56.03;	author matthew;	state Exp;
branches
	1.21.1.1;
next	1.20;

1.20
date	95.12.22.12.57.30;	author jont;	state Exp;
branches
	1.20.1.1
	1.20.2.1
	1.20.3.1
	1.20.4.1
	1.20.5.1
	1.20.6.1
	1.20.7.1;
next	1.19;

1.19
date	95.07.28.09.08.45;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.02.10.10.14.44;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	94.03.21.15.51.42;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	94.03.09.17.10.26;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.08.24.11.53.44;	author jont;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	93.08.23.15.07.07;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	93.07.29.15.23.04;	author nosa;	state Exp;
branches;
next	1.12;

1.12
date	93.01.25.15.37.59;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.12.08.11.03.09;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.08.26.16.03.52;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.06.29.10.02.13;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.03.09.13.44.47;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.11.25.16.56.32;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.11.20.18.28.54;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.11.08.15.35.18;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.10.11.14.50.23;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.10.09.15.59.22;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.10.08.15.54.28;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.10.07.14.45.54;	author jont;	state Exp;
branches;
next	;

1.15.1.1
date	93.08.24.11.53.44;	author jont;	state Exp;
branches;
next	;

1.20.1.1
date	96.09.13.11.26.27;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.10.07.16.16.57;	author hope;	state Exp;
branches;
next	;

1.20.3.1
date	96.10.17.11.36.34;	author hope;	state Exp;
branches;
next	;

1.20.4.1
date	96.11.14.13.04.34;	author hope;	state Exp;
branches
	1.20.4.1.1.1;
next	;

1.20.4.1.1.1
date	96.11.28.15.14.00;	author hope;	state Exp;
branches;
next	;

1.20.5.1
date	96.11.22.18.22.02;	author hope;	state Exp;
branches;
next	;

1.20.6.1
date	96.12.17.17.59.59;	author hope;	state Exp;
branches
	1.20.6.1.1.1;
next	;

1.20.6.1.1.1
date	97.02.24.11.51.38;	author hope;	state Exp;
branches;
next	;

1.20.7.1
date	96.12.18.09.55.21;	author hope;	state Exp;
branches;
next	;

1.21.1.1
date	97.05.12.10.50.03;	author hope;	state Exp;
branches
	1.21.1.1.1.1
	1.21.1.1.2.1
	1.21.1.1.3.1;
next	;

1.21.1.1.1.1
date	97.07.28.18.32.15;	author daveb;	state Exp;
branches
	1.21.1.1.1.1.1.1;
next	;

1.21.1.1.1.1.1.1
date	97.10.07.11.58.23;	author jkbrook;	state Exp;
branches;
next	;

1.21.1.1.2.1
date	97.09.08.17.25.30;	author daveb;	state Exp;
branches;
next	;

1.21.1.1.3.1
date	97.09.09.14.22.09;	author daveb;	state Exp;
branches;
next	;

1.22.1.1
date	97.09.10.19.41.12;	author brucem;	state Exp;
branches;
next	;

1.22.2.1
date	97.09.11.21.08.48;	author daveb;	state Exp;
branches;
next	;

1.22.3.1
date	99.04.01.18.07.39;	author daveb;	state Exp;
branches;
next	;


desc
@An assembler for the sparc opcodes
@


1.22
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* sparc_assembly.sml the signature *)
(*
$Log: sparc_assembly.sml,v $
 * Revision 1.21  1997/01/17  13:56:03  matthew
 * Adding multiply instructions
 *
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
Revision 1.19  1995/07/28  09:08:45  matthew
Putting sources registers for various instructions in correct order

Revision 1.18  1995/02/10  10:14:44  matthew
Adding debug information to Call instructions

Revision 1.17  1994/03/21  15:51:42  matthew
Added functions for labels in printout

Revision 1.16  1994/03/09  17:10:26  jont
Adding load offset isntructions

Revision 1.15  1993/08/24  11:53:44  jont
Changed $Log to $Log: sparc_assembly.sml,v $
 * Revision 1.21  1997/01/17  13:56:03  matthew
 * Adding multiply instructions
 *
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
Revision 1.19  1995/07/28  09:08:45  matthew
Putting sources registers for various instructions in correct order

Revision 1.18  1995/02/10  10:14:44  matthew
Adding debug information to Call instructions

Revision 1.17  1994/03/21  15:51:42  matthew
Added functions for labels in printout

Revision 1.16  1994/03/09  17:10:26  jont
Adding load offset isntructions
 to get the change log

Copyright (c) 1991 Harlequin Ltd.
*)

require "../mir/mirtypes";
require "sparc_opcodes";

signature SPARC_ASSEMBLY = sig
  structure MirTypes : MIRTYPES
  structure Sparc_Opcodes : SPARC_OPCODES

  datatype load_and_store =
    LDSB |
    LDSH |
    LDUB |
    LDUH |
    LD |
    LDD |
    STB |
    STH |
    ST |
    STD

  datatype load_and_store_float =
    LDF |
    LDDF |
    STF |
    STDF

  datatype arithmetic_and_logical =
    ADD |
    ADDCC |
    ADDX |
    ADDXCC |
    SUB |
    SUBCC |
    SUBX |
    SUBXCC |
    AND |
    ANDCC |
    ANDN |
    ANDNCC |
    OR |
    ORCC |
    ORN |
    ORNCC |
    XOR |
    XORCC |
    XORN |
    XORNCC |
    SLL |
    SRL |
    SRA |
    UMUL |
    SMUL |
    UMULCC |
    SMULCC |
    UDIV |
    SDIV |
    UDIVCC |
    SDIVCC

  datatype load_offset = LEO

  datatype special_arithmetic = ADD_AND_MASK

  datatype special_load_offset =
    LOAD_OFFSET_AND_MASK |
    LOAD_OFFSET_HIGH

  datatype tagged_arithmetic =
    TADDCC |
    TADDCCTV |
    TSUBCC |
    TSUBCCTV

  datatype sethi = SETHI

  datatype save_and_restore =
    SAVE |
    RESTORE

  datatype branch =
    BA |
    BN |
    BNE |
    BE |
    BG |
    BLE |
    BGE |
    BL |
    BGU |
    BLEU |
    BCC |
    BCS |
    BPOS |
    BNEG |
    BVC |
    BVS

  datatype call = CALL

  datatype jump_and_link = JMPL

  datatype conv_op =
    FITOS |
    FITOD |
    FITOX |
    FSTOI |
    FDTOI |
    FXTOI

  datatype funary =
    FMOV |
    FNEG |
    FABS |
    FSQRTS |
    FSQRTD |
    FSQRTX |
    FCMPS |
    FCMPD |
    FCMPX

  datatype fbinary =
    FADDS |
    FADDD |
    FADDX |
    FSUBS |
    FSUBD |
    FSUBX |
    FMULS |
    FMULD |
    FMULX |
    FDIVS |
    FDIVD |
    FDIVX

  datatype fbranch =
    FBA |
    FBN |
    FBU |
    FBG |
    FBUG |
    FBL |
    FBUL |
    FBLG |
    FBNE |
    FBE |
    FBUE |
    FBGE |
    FBUGE |
    FBLE |
    FBULE |
    FBO

  datatype reg_or_imm =
    REG of Sparc_Opcodes.MachTypes.Sparc_Reg |
    IMM of int

  datatype read_state = RDY
  datatype write_state = WRY

  datatype opcode =
    LOAD_AND_STORE of
      load_and_store * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm |
    LOAD_AND_STORE_FLOAT of
      load_and_store_float * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm |
    ARITHMETIC_AND_LOGICAL of
      arithmetic_and_logical * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm |
    SPECIAL_ARITHMETIC of
      special_arithmetic * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm |
    TAGGED_ARITHMETIC of
      tagged_arithmetic * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm |
    SetHI of sethi * Sparc_Opcodes.MachTypes.Sparc_Reg * int |
    SAVE_AND_RESTORE of save_and_restore * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm |
    BRANCH of branch * int |
    BRANCH_ANNUL of branch * int |
    Call of call * int * MirTypes.Debugger_Types.Backend_Annotation |
    JUMP_AND_LINK of jump_and_link * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm * 
    MirTypes.Debugger_Types.Backend_Annotation |
    FBRANCH of fbranch * int |
    FBRANCH_ANNUL of fbranch * int |
    CONV_OP of conv_op * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg |
    FUNARY of funary * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg |
    FBINARY of fbinary * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg *
    Sparc_Opcodes.MachTypes.Sparc_Reg |
    LOAD_OFFSET of load_offset * Sparc_Opcodes.MachTypes.Sparc_Reg * int |
    SPECIAL_LOAD_OFFSET of special_load_offset * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * int |
    READ_STATE of read_state * Sparc_Opcodes.MachTypes.Sparc_Reg |
    WRITE_STATE of write_state * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm

  val assemble : opcode -> Sparc_Opcodes.opcode

  type LabMap

  val make_labmap : opcode list list list -> LabMap

  val print : opcode -> string
  val labprint : opcode * int * LabMap -> string * string
  val reverse_branch : branch -> branch

  (* Produce rel' where a rel b == b rel' a *)

  val inverse_branch : branch -> branch
  (* Produce rel' where a rel b == not(a rel' b) *)
  val defines_and_uses :
    opcode ->
    Sparc_Opcodes.MachTypes.Sparc_Reg MirTypes.Set.Set * Sparc_Opcodes.MachTypes.Sparc_Reg MirTypes.Set.Set *
    Sparc_Opcodes.MachTypes.Sparc_Reg MirTypes.Set.Set * Sparc_Opcodes.MachTypes.Sparc_Reg MirTypes.Set.Set
  val nop_code : opcode
  val other_nop_code : opcode
  val nop : opcode * MirTypes.tag option * string
end
@


1.22.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.22  1997/05/01  12:53:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
a24 4
 * Revision 1.22  1997/05/01  12:53:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.22.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.22  1997/05/01  12:53:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
a24 4
 * Revision 1.22  1997/05/01  12:53:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.22.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.22  1997/05/01  12:53:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
a24 4
 * Revision 1.22  1997/05/01  12:53:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.21
log
@Adding multiply instructions
@
text
@d4 3
d25 3
d255 1
a255 1
  val nop : opcode * MirTypes.tag MLWorks.Option.option * string
@


1.21.1.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1997/01/17  13:56:03  matthew
 * Adding multiply instructions
 *
a21 3
 * Revision 1.21  1997/01/17  13:56:03  matthew
 * Adding multiply instructions
 *
@


1.21.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.21.1.1  1997/05/12  10:50:03  hope
 * branched from 1.21
 *
a24 3
 * Revision 1.21.1.1  1997/05/12  10:50:03  hope
 * branched from 1.21
 *
@


1.21.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.21.1.1  1997/05/12  10:50:03  hope
 * branched from 1.21
 *
a24 3
 * Revision 1.21.1.1  1997/05/12  10:50:03  hope
 * branched from 1.21
 *
@


1.21.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.21.1.1  1997/05/12  10:50:03  hope
 * branched from 1.21
 *
a24 3
 * Revision 1.21.1.1  1997/05/12  10:50:03  hope
 * branched from 1.21
 *
@


1.21.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.21.1.1.1.1  1997/07/28  18:32:15  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a27 3
 * Revision 1.21.1.1.1.1  1997/07/28  18:32:15  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.20
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d4 4
d22 4
d90 9
a98 1
    SRA
d197 3
d225 3
a227 1
    SPECIAL_LOAD_OFFSET of special_load_offset * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg * int
@


1.20.7.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
a17 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.20.6.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
a17 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.20.6.1.1.1
log
@branched from 1.20.6.1
@
text
@a3 3
 * Revision 1.20.6.1  1996/12/17  17:59:59  hope
 * branched from 1.20
 *
a21 3
 * Revision 1.20.6.1  1996/12/17  17:59:59  hope
 * branched from 1.20
 *
@


1.20.5.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
a17 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.20.4.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
a17 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.20.4.1.1.1
log
@branched from 1.20.4.1
@
text
@a3 3
 * Revision 1.20.4.1  1996/11/14  13:04:34  hope
 * branched from 1.20
 *
a21 3
 * Revision 1.20.4.1  1996/11/14  13:04:34  hope
 * branched from 1.20
 *
@


1.20.3.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
a17 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.20.2.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
a17 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
a17 4
 * Revision 1.20  1995/12/22  12:57:30  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.19
log
@Putting sources registers for various instructions in correct order
@
text
@d4 3
d18 3
d228 1
a228 1
  val nop : opcode * MirTypes.tag MirTypes.Option.opt * string
@


1.18
log
@Adding debug information to Call instructions
@
text
@d4 3
d15 3
d179 1
a179 2
      load_and_store_float * Sparc_Opcodes.MachTypes.Sparc_Reg * Sparc_Opcodes.MachTypes.Sparc_Reg *
      reg_or_imm |
d181 1
a181 2
      arithmetic_and_logical * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm *
      Sparc_Opcodes.MachTypes.Sparc_Reg |
d183 1
a183 2
      special_arithmetic * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm *
      Sparc_Opcodes.MachTypes.Sparc_Reg |
d185 1
a185 2
      tagged_arithmetic * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm *
      Sparc_Opcodes.MachTypes.Sparc_Reg |
d187 1
a187 3
    SAVE_AND_RESTORE of
      save_and_restore * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm *
      Sparc_Opcodes.MachTypes.Sparc_Reg |
d191 2
a192 2
    JUMP_AND_LINK of jump_and_link * Sparc_Opcodes.MachTypes.Sparc_Reg * reg_or_imm *
    Sparc_Opcodes.MachTypes.Sparc_Reg * MirTypes.Debugger_Types.Backend_Annotation |
@


1.17
log
@Added functions for labels in printout
@
text
@d4 3
d12 3
d190 1
a190 1
    Call of call * int |
d192 1
a192 1
    Sparc_Opcodes.MachTypes.Sparc_Reg * MirTypes.Debugger_Types.Backend_Annotation|
@


1.16
log
@Adding load offset isntructions
@
text
@d4 3
d8 4
a11 1
Changed $Log to $Log$ to get the change log
d197 5
d203 1
d205 1
@


1.15
log
@Changed $Log to $Log$ to get the change log
@
text
@d3 4
a6 1
$Log$
d60 2
d64 4
d186 3
a188 1
    Sparc_Opcodes.MachTypes.Sparc_Reg
a200 2
  val post_restore : opcode -> opcode
  val post_save : opcode -> opcode
@


1.15.1.1
log
@Fork for bug fixing
@
text
@d3 1
a3 4
$Log: sparc_assembly.sml,v $
Revision 1.15  1993/08/24  11:53:44  jont
Changed $Log to $Log$ to get the change log

@


1.14
log
@Added extra function inverse_branch to handle flow control alterations.
reverse_branch is for handling comparing arithmetic quantities in
reversed order
@
text
@d3 1
a3 1
$Log
@


1.13
log
@structure Option.
@
text
@d182 4
@


1.12
log
@Removed different names for anulled and non-anulled branches. The constructor
distinguishes these adequately
@
text
@d190 1
a190 1
  val nop : opcode * MirTypes.tag MirTypes.Opt * string
@


1.11
log
@Changed the type of nop used for tracing to store it being moved by the scheduler
@
text
@a88 18
  datatype branch_annul =
    BAA |
    BNA |
    BNEA |
    BEA |
    BGA |
    BLEA |
    BGEA |
    BLA |
    BGUA |
    BLEUA |
    BCCA |
    BCSA |
    BPOSA |
    BNEGA |
    BVCA |
    BVSA

a143 18
  datatype fbranch_annul =
    FBAA |
    FBNA |
    FBUA |
    FBGA |
    FBUGA |
    FBLA |
    FBULA |
    FBLGA |
    FBNEA |
    FBEA |
    FBUEA |
    FBGEA |
    FBUGEA |
    FBLEA |
    FBULEA |
    FBOA

d168 1
a168 1
    BRANCH_ANNUL of branch_annul * int |
d173 1
a173 1
    FBRANCH_ANNUL of fbranch_annul * int |
a181 1
  val reverse_branch_annul : branch_annul -> branch_annul
@


1.10
log
@Removed some redundant structures and sharing
@
text
@d226 1
@


1.9
log
@Added type annotation information at application points
@
text
@a6 1
require "../utils/set";
a7 2
require "../debugger/debugger_types";
require "machtypes";
a10 1
  structure Set : SET
a11 1
  structure MachTypes : MACHTYPES
a12 1
  structure Debugger_Types : DEBUGGER_TYPES
a13 1
  sharing Sparc_Opcodes.MachTypes = MachTypes
d181 1
a181 1
    REG of MachTypes.Sparc_Reg |
d186 1
a186 1
      load_and_store * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * reg_or_imm |
d188 1
a188 1
      load_and_store_float * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg *
d191 2
a192 2
      arithmetic_and_logical * MachTypes.Sparc_Reg * reg_or_imm *
      MachTypes.Sparc_Reg |
d194 2
a195 2
      special_arithmetic * MachTypes.Sparc_Reg * reg_or_imm *
      MachTypes.Sparc_Reg |
d197 3
a199 3
      tagged_arithmetic * MachTypes.Sparc_Reg * reg_or_imm *
      MachTypes.Sparc_Reg |
    SetHI of sethi * MachTypes.Sparc_Reg * int |
d201 2
a202 2
      save_and_restore * MachTypes.Sparc_Reg * reg_or_imm *
      MachTypes.Sparc_Reg |
d206 2
a207 2
    JUMP_AND_LINK of jump_and_link * MachTypes.Sparc_Reg * reg_or_imm *
    MachTypes.Sparc_Reg * Debugger_Types.Backend_Annotation|
d210 4
a213 4
    CONV_OP of conv_op * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg |
    FUNARY of funary * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg |
    FBINARY of fbinary * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg *
    MachTypes.Sparc_Reg
d221 2
a222 2
    MachTypes.Sparc_Reg Set.Set * MachTypes.Sparc_Reg Set.Set *
    MachTypes.Sparc_Reg Set.Set * MachTypes.Sparc_Reg Set.Set
@


1.8
log
@Added SPECIAL_ARITHMETIC opcode type for doing add and mask for
long range ADR instructions
@
text
@d9 1
d18 1
d214 1
a214 1
    MachTypes.Sparc_Reg |
@


1.7
log
@Added nop and nop_code
@
text
@d62 2
d198 3
d202 1
a202 1
      tagged_arithmetic *  MachTypes.Sparc_Reg * reg_or_imm *
@


1.6
log
@Added functions for transforming instructions past save/restore
Moved defines_and_uses from _sparc_schedule.
@
text
@d8 1
d14 1
d17 2
a18 1
    
d225 2
@


1.5
log
@Added floating point instruction types
@
text
@d7 1
d12 1
d216 6
@


1.4
log
@Merged LOADs and STOREs, and LOAD_FLOATs and STORE_FLOATs,
and got rid of alternate address space instructions.
@
text
@d109 69
d181 1
d185 3
a187 1
    LOAD_AND_STORE_FLOAT (* Not yet determined *) |
d202 6
@


1.3
log
@Added inversion of branch sense functions
@
text
@d14 1
a14 1
  datatype load =
d20 1
a20 15
    LDD

  datatype load_alternate =
    LDSBA |
    LDSHA |
    LDUBA |
    LDUHA |
    LDA |
    LDDA

  datatype load_float =
    LDF |
    LDDF

  datatype store =
d26 3
a28 7
  datatype store_alternate =
    STBA |
    STHA |
    STA |
    STDA

  datatype store_float =
d113 3
a115 10
    LOAD of load * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * int |
    LOAD_ALTERNATE of
      load_alternate * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg *
      MachTypes.Sparc_Reg * int |
    LOAD_FLOAT (* Not yet determined *) |
    STORE of store * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg * int |
    STORE_ALTERNATE of
      store_alternate * MachTypes.Sparc_Reg * MachTypes.Sparc_Reg *
      MachTypes.Sparc_Reg * int |
    STORE_FLOAT (* Not yet determined *) |
@


1.2
log
@Added opcode printing function
@
text
@d159 2
@


1.1
log
@Initial revision
@
text
@d158 1
@
