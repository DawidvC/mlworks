head	1.12;
access;
symbols
	MLW_daveb_inline_1_4_99:1.12.4
	MLWorks_21c0_1999_03_25:1.12
	MLWorks_20c1_1998_08_20:1.12
	MLWorks_20c0_1998_08_04:1.12
	MLWorks_20b2c2_1998_06_19:1.12
	MLWorks_20b2_Windows_1998_06_12:1.12
	MLWorks_20b1c1_1998_05_07:1.12
	MLWorks_20b0_1998_04_07:1.12
	MLWorks_20b0_1998_03_20:1.12
	MLWorks_20m2_1998_02_16:1.12
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.12.1.1.1.1.1
	MLWorks_workspace_97:1.12.3
	MLWorks_dt_wizard:1.12.2
	MLWorks_11c0_1997_09_09:1.12.1.1.1.1
	MLWorks_10r3:1.12.1.1.3
	MLWorks_10r2_551:1.12.1.1.2
	MLWorks_11:1.12.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.12.1.1
	MLWorks_20m0_1997_06_20:1.12
	MLWorks_1_0_r2c2_1997_06_14:1.12.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.12.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.12.1
	MLWorks_BugFix_1997_04_24:1.12
	MLWorks_1_0_r2_Win32_1997_04_11:1.12
	MLWorks_1_0_r2_Unix_1997_04_04:1.12
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.11.6.1.1
	MLWorks_gui_1996_12_18:1.11.7
	MLWorks_1_0_Win32_1996_12_17:1.11.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.11.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.11.4.1
	MLWorks_1_0_Irix_1996_11_28:1.11.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.11.5
	MLWorks_1_0_Unix_1996_11_14:1.11.4
	MLWorks_Open_Beta2_1996_10_11:1.11.3
	MLWorks_License_dev:1.11.2
	MLWorks_1_open_beta_1996_09_13:1.11.1
	MLWorks_Open_Beta_1996_08_22:1.11
	MLWorks_Beta_1996_07_02:1.11
	MLWorks_Beta_1996_06_07:1.11
	MLWorks_Beta_1996_06_06:1.11
	MLWorks_Beta_1996_06_05:1.11
	MLWorks_Beta_1996_06_03:1.11
	MLWorks_Beta_1996_05_31:1.11
	MLWorks_Beta_1996_05_30:1.11
	ML_beta_release_12/08/94:1.8
	ML_beta_release_03/08/94:1.8
	ML_revised_beta_release_25/05/94:1.8
	ML_final_beta_release_02/03/94:1.8
	mlworks-28-01-1994:1.8
	Release:1.8
	mlworks-beta-01-09-1993:1.8
	MLWorks-1-0-4-29/01/1993:1.8
	MLWorks-1-0-3-21/12/1992:1.7
	MLWorks-1-0-2-15/12/1992:1.7
	MLWorks-1-0-1-04/12/1992:1.7
	checkpoint_17_08_92:1.4;
locks; strict;
comment	@ * @;


1.12
date	97.01.17.13.18.26;	author matthew;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1
	1.12.4.1;
next	1.11;

1.11
date	96.05.17.09.43.59;	author matthew;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1
	1.11.4.1
	1.11.5.1
	1.11.6.1
	1.11.7.1;
next	1.10;

1.10
date	95.03.17.13.25.18;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	94.09.12.13.37.39;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.01.15.12.37.51;	author jont;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	92.08.26.14.53.53;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	92.08.19.19.06.09;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.08.18.19.09.27;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.10.28.11.59.04;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.10.24.13.29.45;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.10.21.10.43.57;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.09.26.09.58.29;	author jont;	state Exp;
branches;
next	;

1.8.1.1
date	93.01.15.12.37.51;	author jont;	state Exp;
branches;
next	;

1.11.1.1
date	96.09.13.11.26.37;	author hope;	state Exp;
branches;
next	;

1.11.2.1
date	96.10.07.16.17.08;	author hope;	state Exp;
branches;
next	;

1.11.3.1
date	96.10.17.11.36.51;	author hope;	state Exp;
branches;
next	;

1.11.4.1
date	96.11.14.13.04.44;	author hope;	state Exp;
branches
	1.11.4.1.1.1;
next	;

1.11.4.1.1.1
date	96.11.28.15.14.11;	author hope;	state Exp;
branches;
next	;

1.11.5.1
date	96.11.22.18.22.12;	author hope;	state Exp;
branches;
next	;

1.11.6.1
date	96.12.17.18.00.12;	author hope;	state Exp;
branches
	1.11.6.1.1.1;
next	;

1.11.6.1.1.1
date	97.02.24.11.51.51;	author hope;	state Exp;
branches;
next	;

1.11.7.1
date	96.12.18.09.55.33;	author hope;	state Exp;
branches;
next	;

1.12.1.1
date	97.05.12.10.50.14;	author hope;	state Exp;
branches
	1.12.1.1.1.1
	1.12.1.1.2.1
	1.12.1.1.3.1;
next	;

1.12.1.1.1.1
date	97.07.28.18.32.27;	author daveb;	state Exp;
branches
	1.12.1.1.1.1.1.1;
next	;

1.12.1.1.1.1.1.1
date	97.10.07.11.58.35;	author jkbrook;	state Exp;
branches;
next	;

1.12.1.1.2.1
date	97.09.08.17.25.43;	author daveb;	state Exp;
branches;
next	;

1.12.1.1.3.1
date	97.09.09.14.22.21;	author daveb;	state Exp;
branches;
next	;

1.12.2.1
date	97.09.10.19.41.26;	author brucem;	state Exp;
branches;
next	;

1.12.3.1
date	97.09.11.21.09.00;	author daveb;	state Exp;
branches;
next	;

1.12.4.1
date	99.04.01.18.07.49;	author daveb;	state Exp;
branches;
next	;


desc
@Translating to strings
@


1.12
log
@Multiply instructions
@
text
@(* _sparc_opcodes.sml the functor *)
(*
$Log: _sparc_opcodes.sml,v $
 * Revision 1.11  1996/05/17  09:43:59  matthew
 * Moved Bits to MLWorks.Internal
 *
 * Revision 1.10  1995/03/17  13:25:18  matthew
 * Replacing implode with implode_char
 *
Revision 1.9  1994/09/12  13:37:39  matthew
Replaced ^ by implodes.  This is because the new optimizer can't do hat optimizations yet.

Revision 1.8  1993/01/15  12:37:51  jont
Split store into three areas of heap, stack and nil vector for scheduling improvement

Revision 1.7  1992/08/26  14:53:53  richard
Changed MLWorks.Bits to Bits to improve performance under
New Jersey.

Revision 1.6  1992/08/19  19:06:09  jont
Changed most of the multiplies, divides and mods into bit operations

Revision 1.5  1992/08/18  19:09:27  jont
Improved implementation of output_opcode

Revision 1.4  1991/10/28  11:59:04  jont
Added store register for detection of load/store interaction

Revision 1.3  91/10/24  13:29:45  jont
Fixed inexhaustive match

Revision 1.2  91/10/21  10:43:57  jont
Fixed coding of larger integers

Revision 1.1  91/09/26  09:58:29  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/crash";
require "machtypes";
require "sparc_opcodes";

functor Sparc_Opcodes(
  structure Crash : CRASH
  structure MachTypes : MACHTYPES
) : SPARC_OPCODES =
struct
  structure MachTypes = MachTypes

  structure Bits = MLWorks.Internal.Bits

  exception not_done_yet

  datatype opcode =
    FORMAT1 of int (*disp30*)
  | FORMAT2A of MachTypes.Sparc_Reg (*rd*) * int (*op2*) * int (*imm22*)
  | FORMAT2B of bool (*a*) * int (*cond*) * int (*op2*) * int (*disp22*)
  | FORMAT3A of int (*op*) * MachTypes.Sparc_Reg (*rd*) * int (*op3*) *
    MachTypes.Sparc_Reg (*rs1*) * bool (*i*) * int (*asi*) *
    MachTypes.Sparc_Reg (*rs2*)
  | FORMAT3B of int (*op*) * MachTypes.Sparc_Reg (*rd*) * int (*op3*) *
    MachTypes.Sparc_Reg (*rs1*) * bool (*i*) * int (*simm13*)
  | FORMAT3C of int (*op*) * MachTypes.Sparc_Reg (*rd*) * int (*op3*) *
    MachTypes.Sparc_Reg (*rs1*) * int (*opf*) * MachTypes.Sparc_Reg (*rs2*)

  fun register_val MachTypes.I0 = 24
  | register_val MachTypes.I1 = 25
  | register_val MachTypes.I2 = 26
  | register_val MachTypes.I3 = 27
  | register_val MachTypes.I4 = 28
  | register_val MachTypes.I5 = 29
  | register_val MachTypes.I6 = 30
  | register_val MachTypes.I7 = 31
  | register_val MachTypes.L0 = 16
  | register_val MachTypes.L1 = 17
  | register_val MachTypes.L2 = 18
  | register_val MachTypes.L3 = 19
  | register_val MachTypes.L4 = 20
  | register_val MachTypes.L5 = 21
  | register_val MachTypes.L6 = 22
  | register_val MachTypes.L7 = 23
  | register_val MachTypes.O0 = 8
  | register_val MachTypes.O1 = 9
  | register_val MachTypes.O2 = 10
  | register_val MachTypes.O3 = 11
  | register_val MachTypes.O4 = 12
  | register_val MachTypes.O5 = 13
  | register_val MachTypes.O6 = 14
  | register_val MachTypes.O7 = 15
  | register_val MachTypes.G0 = 0
  | register_val MachTypes.G1 = 1
  | register_val MachTypes.G2 = 2
  | register_val MachTypes.G3 = 3
  | register_val MachTypes.G4 = 4
  | register_val MachTypes.G5 = 5
  | register_val MachTypes.G6 = 6
  | register_val MachTypes.G7 = 7
  | register_val MachTypes.cond = Crash.impossible"register_val cond"
  | register_val MachTypes.heap = Crash.impossible"register_val heap"
  | register_val MachTypes.stack = Crash.impossible"register_val stack"
  | register_val MachTypes.y_reg = Crash.impossible"register_val y_reg"
  | register_val MachTypes.nil_v = Crash.impossible"register_val nil_v"

  fun bool_val false = 0
  | bool_val true = 1

  fun make_list(bytes, value, acc) =
    if bytes <= 0 then acc
    else
      make_list(bytes-1, value div 256, (value mod 256) :: acc)

  fun output_int(bytes, value) =
    make_list(bytes, value, [])

  val implode_char = MLWorks.String.implode_char

  fun output_opcode(FORMAT1 disp30) =
    let
      val top = Bits.andb(Bits.rshift(disp30, 24), 63)
      val bottom3 = Bits.andb(disp30, (256*256*256)-1)
    in
      implode_char((64 + top) :: output_int(3, bottom3))
    end
  | output_opcode(FORMAT2A(rd, op2, imm22)) =
    let
      val top = Bits.andb(Bits.rshift(imm22, 16), 63)
      val bottom2 = Bits.andb(imm22, (256*256)-1)
    in
      implode_char
      ((Bits.lshift(register_val rd, 1) + op2 div 4) ::
       (Bits.lshift((op2 mod 4), 6) + top) ::
       output_int(2, bottom2))
    end
  | output_opcode(FORMAT2B(a, cond, op2, disp22)) =
    let
      val top = Bits.andb(Bits.rshift(disp22, 16), 63)
      val bottom2 = Bits.andb(disp22, (256*256)-1)
    in
      implode_char
      ((Bits.lshift(bool_val a, 5) + Bits.lshift(cond, 1) +
	   op2 div 4) ::
       (Bits.lshift((op2 mod 4), 6) + top) ::
       output_int(2, bottom2))
    end
  | output_opcode(FORMAT3A(op1, rd, op3, rs1, i, asi, rs2)) =
    implode_char [(Bits.lshift(op1, 6) +
                 Bits.lshift(register_val rd, 1) + op3 div 32),
             (Bits.lshift((op3 mod 32), 3) + register_val rs1 div 4),
             (Bits.lshift(register_val rs1 mod 4, 6) +
                 Bits.lshift(bool_val i, 5) + asi div 8),
             (Bits.lshift(asi mod 8, 5) + register_val rs2)]
  | output_opcode(FORMAT3B(op1, rd, op3, rs1, i, simm13)) =
    let
      val top = Bits.andb(Bits.rshift(simm13, 8), 31)
      val bottom = Bits.andb(simm13, 256-1)
    in
      implode_char [(Bits.lshift(op1, 6) +
                   Bits.lshift(register_val rd, 1) + op3 div 32),
               (Bits.lshift(op3 mod 32, 3) + register_val rs1 div 4),
               (Bits.lshift(register_val rs1 mod 4, 6) +
                   Bits.lshift(bool_val i, 5) + top),
                bottom]
    end
  | output_opcode(FORMAT3C(op1, rd, op3, rs1, opf, rs2)) =
    implode_char [(Bits.lshift(op1, 6) +
                 Bits.lshift(register_val rd, 1) + op3 div 32),
                  (Bits.lshift(op3 mod 32, 3) + register_val rs1 div 4),
                  (Bits.lshift(register_val rs1 mod 4, 6) + opf div 8),
                  (Bits.lshift(opf mod 8, 5) + register_val rs2)]

end
@


1.12.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 3
 * Revision 1.12  1997/01/17  13:18:26  matthew
 * Multiply instructions
 *
@


1.12.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.12  1997/01/17  13:18:26  matthew
 * Multiply instructions
 *
@


1.12.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.12  1997/01/17  13:18:26  matthew
 * Multiply instructions
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a3 3
 * Revision 1.12  1997/01/17  13:18:26  matthew
 * Multiply instructions
 *
@


1.12.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.12.1.1  1997/05/12  10:50:14  hope
 * branched from 1.12
 *
@


1.12.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.12.1.1  1997/05/12  10:50:14  hope
 * branched from 1.12
 *
@


1.12.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.12.1.1  1997/05/12  10:50:14  hope
 * branched from 1.12
 *
@


1.12.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.12.1.1.1.1  1997/07/28  18:32:27  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.11
log
@Moved Bits to MLWorks.Internal
@
text
@d4 3
d103 1
@


1.11.7.1
log
@branched from 1.11
@
text
@a3 3
 * Revision 1.11  1996/05/17  09:43:59  matthew
 * Moved Bits to MLWorks.Internal
 *
@


1.11.6.1
log
@branched from 1.11
@
text
@a3 3
 * Revision 1.11  1996/05/17  09:43:59  matthew
 * Moved Bits to MLWorks.Internal
 *
@


1.11.6.1.1.1
log
@branched from 1.11.6.1
@
text
@a3 3
 * Revision 1.11.6.1  1996/12/17  18:00:12  hope
 * branched from 1.11
 *
@


1.11.5.1
log
@branched from 1.11
@
text
@a3 3
 * Revision 1.11  1996/05/17  09:43:59  matthew
 * Moved Bits to MLWorks.Internal
 *
@


1.11.4.1
log
@branched from 1.11
@
text
@a3 3
 * Revision 1.11  1996/05/17  09:43:59  matthew
 * Moved Bits to MLWorks.Internal
 *
@


1.11.4.1.1.1
log
@branched from 1.11.4.1
@
text
@a3 3
 * Revision 1.11.4.1  1996/11/14  13:04:44  hope
 * branched from 1.11
 *
@


1.11.3.1
log
@branched from 1.11
@
text
@a3 3
 * Revision 1.11  1996/05/17  09:43:59  matthew
 * Moved Bits to MLWorks.Internal
 *
@


1.11.2.1
log
@branched from 1.11
@
text
@a3 3
 * Revision 1.11  1996/05/17  09:43:59  matthew
 * Moved Bits to MLWorks.Internal
 *
@


1.11.1.1
log
@branched from 1.11
@
text
@a3 3
 * Revision 1.11  1996/05/17  09:43:59  matthew
 * Moved Bits to MLWorks.Internal
 *
@


1.10
log
@Replacing implode with implode_char
@
text
@d4 3
d48 2
@


1.9
log
@Replaced ^ by implodes.  This is because the new optimizer can't do hat optimizations yet.
@
text
@d4 3
d103 1
a103 1
      make_list(bytes-1, value div 256, chr(value mod 256) :: acc)
d108 2
d115 1
a115 1
      implode(chr(64 + top) :: output_int(3, bottom3))
d122 3
a124 3
      implode
      (chr(Bits.lshift(register_val rd, 1) + op2 div 4) ::
       chr(Bits.lshift((op2 mod 4), 6) + top) ::
d132 2
a133 2
      implode
      (chr(Bits.lshift(bool_val a, 5) + Bits.lshift(cond, 1) +
d135 1
a135 1
       chr(Bits.lshift((op2 mod 4), 6) + top) ::
d139 1
a139 1
    implode [chr(Bits.lshift(op1, 6) +
d141 2
a142 2
             chr(Bits.lshift((op3 mod 32), 3) + register_val rs1 div 4),
             chr(Bits.lshift(register_val rs1 mod 4, 6) +
d144 1
a144 1
             chr(Bits.lshift(asi mod 8, 5) + register_val rs2)]
d150 1
a150 1
      implode [chr(Bits.lshift(op1, 6) +
d152 2
a153 2
               chr(Bits.lshift(op3 mod 32, 3) + register_val rs1 div 4),
               chr(Bits.lshift(register_val rs1 mod 4, 6) +
d155 1
a155 1
               chr bottom]
d158 1
a158 1
    implode [chr(Bits.lshift(op1, 6) +
d160 3
a162 3
             chr(Bits.lshift(op3 mod 32, 3) + register_val rs1 div 4),
             chr(Bits.lshift(register_val rs1 mod 4, 6) + opf div 8),
             chr(Bits.lshift(opf mod 8, 5) + register_val rs2)]
@


1.8
log
@Split store into three areas of heap, stack and nil vector for scheduling improvement
@
text
@d4 3
d134 6
a139 6
    chr(Bits.lshift(op1, 6) +
	Bits.lshift(register_val rd, 1) + op3 div 32) ^
    chr(Bits.lshift((op3 mod 32), 3) + register_val rs1 div 4) ^
    chr(Bits.lshift(register_val rs1 mod 4, 6) +
	Bits.lshift(bool_val i, 5) + asi div 8) ^
    chr(Bits.lshift(asi mod 8, 5) + register_val rs2)
d145 6
a150 6
      chr(Bits.lshift(op1, 6) +
	  Bits.lshift(register_val rd, 1) + op3 div 32) ^
      chr(Bits.lshift(op3 mod 32, 3) + register_val rs1 div 4) ^
      chr(Bits.lshift(register_val rs1 mod 4, 6) +
	  Bits.lshift(bool_val i, 5) + top) ^
      chr bottom
d153 5
a157 5
    chr(Bits.lshift(op1, 6) +
	Bits.lshift(register_val rd, 1) + op3 div 32) ^
    chr(Bits.lshift(op3 mod 32, 3) + register_val rs1 div 4) ^
    chr(Bits.lshift(register_val rs1 mod 4, 6) + opf div 8) ^
    chr(Bits.lshift(opf mod 8, 5) + register_val rs2)
@


1.8.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.8  1993/01/15  12:37:51  jont
Split store into three areas of heap, stack and nil vector for scheduling improvement

@


1.7
log
@Changed MLWorks.Bits to Bits to improve performance under
New Jersey.
@
text
@d4 4
d87 3
a89 1
  | register_val MachTypes.store = Crash.impossible"register_val store"
@


1.6
log
@Changed most of the multiplies, divides and mods into bit operations
@
text
@d4 3
d98 2
a99 2
      val top = MLWorks.Bits.andb(MLWorks.Bits.rshift(disp30, 24), 63)
      val bottom3 = MLWorks.Bits.andb(disp30, (256*256*256)-1)
d105 2
a106 2
      val top = MLWorks.Bits.andb(MLWorks.Bits.rshift(imm22, 16), 63)
      val bottom2 = MLWorks.Bits.andb(imm22, (256*256)-1)
d109 2
a110 2
      (chr(MLWorks.Bits.lshift(register_val rd, 1) + op2 div 4) ::
       chr(MLWorks.Bits.lshift((op2 mod 4), 6) + top) ::
d115 2
a116 2
      val top = MLWorks.Bits.andb(MLWorks.Bits.rshift(disp22, 16), 63)
      val bottom2 = MLWorks.Bits.andb(disp22, (256*256)-1)
d119 1
a119 1
      (chr(MLWorks.Bits.lshift(bool_val a, 5) + MLWorks.Bits.lshift(cond, 1) +
d121 1
a121 1
       chr(MLWorks.Bits.lshift((op2 mod 4), 6) + top) ::
d125 6
a130 6
    chr(MLWorks.Bits.lshift(op1, 6) +
	MLWorks.Bits.lshift(register_val rd, 1) + op3 div 32) ^
    chr(MLWorks.Bits.lshift((op3 mod 32), 3) + register_val rs1 div 4) ^
    chr(MLWorks.Bits.lshift(register_val rs1 mod 4, 6) +
	MLWorks.Bits.lshift(bool_val i, 5) + asi div 8) ^
    chr(MLWorks.Bits.lshift(asi mod 8, 5) + register_val rs2)
d133 2
a134 2
      val top = MLWorks.Bits.andb(MLWorks.Bits.rshift(simm13, 8), 31)
      val bottom = MLWorks.Bits.andb(simm13, 256-1)
d136 5
a140 5
      chr(MLWorks.Bits.lshift(op1, 6) +
	  MLWorks.Bits.lshift(register_val rd, 1) + op3 div 32) ^
      chr(MLWorks.Bits.lshift(op3 mod 32, 3) + register_val rs1 div 4) ^
      chr(MLWorks.Bits.lshift(register_val rs1 mod 4, 6) +
	  MLWorks.Bits.lshift(bool_val i, 5) + top) ^
d144 5
a148 5
    chr(MLWorks.Bits.lshift(op1, 6) +
	MLWorks.Bits.lshift(register_val rd, 1) + op3 div 32) ^
    chr(MLWorks.Bits.lshift(op3 mod 32, 3) + register_val rs1 div 4) ^
    chr(MLWorks.Bits.lshift(register_val rs1 mod 4, 6) + opf div 8) ^
    chr(MLWorks.Bits.lshift(opf mod 8, 5) + register_val rs2)
@


1.5
log
@Improved implementation of output_opcode
@
text
@d4 3
d95 2
a96 6
      val top =
	if disp30 < 0 then
	  (disp30 div (256*256*256)) mod 64
	else
	  disp30 div (256*256*256)
      val bottom3 = disp30 mod (256*256*256)
d102 2
a103 6
      val top =
	if imm22 < 0 then
	  (imm22 div (256*256)) mod 64
	else
	  imm22 div (256*256)
      val bottom2 = imm22 mod (256*256)
d106 2
a107 1
      (chr(register_val rd * 2 + op2 div 4) :: chr((op2 mod 4) * 64 + top) ::
d112 2
a113 6
      val top =
	if disp22 < 0 then
	  (disp22 div (256*256)) mod 64
	else
	  disp22 div (256*256)
      val bottom2 = disp22 mod (256*256)
d116 3
a118 2
      (chr(bool_val a * 32 + cond * 2 + op2 div 4) ::
       chr((op2 mod 4) * 64 + top) ::
d122 6
a127 4
    chr(64 * op1 + register_val rd * 2 + op3 div 32) ^
    chr((op3 mod 32) * 8 + register_val rs1 div 4) ^
    chr((register_val rs1 mod 4) * 64 + bool_val i * 32 + asi div 8) ^
    chr((asi mod 8) * 32 + register_val rs2)
d130 2
a131 6
      val top =
	if simm13 < 0 then
	  (simm13 div 256) mod 32
	else
	  simm13 div 256
      val bottom = simm13 mod 256
d133 5
a137 3
      chr(64 * op1 + register_val rd * 2 + op3 div 32) ^
      chr((op3 mod 32) * 8 + register_val rs1 div 4) ^
      chr((register_val rs1 mod 4) * 64 + bool_val i * 32 + top) ^
d141 5
a145 4
    chr(64 * op1 + register_val rd * 2 + op3 div 32) ^
    chr((op3 mod 32) * 8 + register_val rs1 div 4) ^
    chr((register_val rs1 mod 4) * 64 + opf div 8) ^
    chr((opf mod 8) * 32 + register_val rs2)
@


1.4
log
@Added store register for detection of load/store interaction
@
text
@d3 4
a6 1
$Log:	_sparc_opcodes.sml,v $
d82 5
d88 1
a88 8
    let
      fun make_list(bytes, value) =
	if bytes <= 0 then []
	else
	  chr(value mod 256) :: make_list(bytes-1, value div 256)
    in
      implode(rev(make_list(bytes, value)))
    end
d99 1
a99 1
      chr(64 + top) ^ output_int(3, bottom3)
d110 3
a112 2
      chr(register_val rd * 2 + op2 div 4) ^ chr((op2 mod 4) * 64 + top) ^
      output_int(2, bottom2)
d123 4
a126 3
      chr(bool_val a * 32 + cond * 2 + op2 div 4) ^
      chr((op2 mod 4) * 64 + top) ^
      output_int(2, bottom2)
@


1.3
log
@Fixed inexhaustive match
@
text
@d4 3
d74 1
@


1.2
log
@Fixed coding of larger integers
@
text
@d4 3
d13 1
d18 1
d70 1
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d86 1
a86 1
      val bottom3 = disp30 mod 256*256*256
d97 1
a97 1
      val bottom2 = imm22 mod 256*256
d109 1
a109 1
      val bottom2 = disp22 mod 256*256
@
