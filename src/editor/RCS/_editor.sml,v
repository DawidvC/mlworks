head	1.19;
access;
symbols
	ML_beta_release_12/08/94:1.14
	ML_beta_release_03/08/94:1.14
	ML_revised_beta_release_25/05/94:1.11
	ML_final_beta_release_02/03/94:1.11
	mlworks-28-01-1994:1.11
	Release:1.11
	mlworks-beta-01-09-1993:1.11;
locks; strict;


1.19
date	95.10.23.12.51.08;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.10.20.16.43.48;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	95.10.02.13.23.44;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	95.01.13.17.14.02;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	94.12.08.18.04.03;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	94.08.03.09.24.12;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	94.08.02.16.26.01;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	94.07.29.16.19.00;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.08.31.11.29.18;	author matthew;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	93.08.27.17.20.41;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.08.25.15.06.30;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.06.04.14.12.35;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	93.05.18.16.33.29;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	93.04.22.13.00.22;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.15.23.51;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	93.04.08.17.42.49;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	93.04.08.15.00.45;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	93.03.23.18.35.09;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	93.03.10.17.24.30;	author jont;	state Exp;
branches;
next	;

1.11.1.1
date	93.08.31.11.29.18;	author jont;	state Exp;
branches;
next	;


desc
@Implementation of interface to external editors
@


1.19
log
@Changed name of e-lisp highlight function to mlworks-highlight.
@
text
@(* _editor.sml the functor *)
(*
$Log: _editor.sml,v $
Revision 1.18  1995/10/20  16:43:48  daveb
Sent the emacs commands as separate S-expressions, to avoid buffer
overflow problems.

Revision 1.17  1995/10/02  13:23:44  daveb
Made emacs highlight errors.
Removed next_error and no_more_errors.

Revision 1.16  1995/01/13  17:14:02  daveb
Replaced Option structure with references to MLWorks.Option.

Revision 1.15  1994/12/08  18:04:03  jont
Move OS specific stuff into a system link directory

Revision 1.14  1994/08/03  09:24:12  matthew
Reinstate call to makestring

Revision 1.13  1994/08/02  16:26:01  daveb
Added support for user-defined editors.

Revision 1.12  1994/07/29  16:19:00  daveb
Moved preferences into separate structure.

Revision 1.11  1993/08/31  11:29:18  matthew
reversed arguments to kill
added handler for Unix exception

Revision 1.10  1993/08/27  17:20:41  matthew
Added call to Unix.kill

Revision 1.9  1993/08/25  15:06:30  matthew
Return quit function from ShellUtils.edit_string
Need to uncomment call to kill]

Revision 1.8  1993/06/04  14:12:35  daveb
Removed filename component of error result for edit functions.

Revision 1.7  1993/05/18  16:33:29  daveb
Changed Integer.makestring to MLWorks.Integer.makestring and removed
the Integer structure.

Revision 1.6  1993/04/22  13:00:22  richard
The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.

Revision 1.5  1993/04/14  15:23:51  jont
Added editing from location. Added a function to do next error from a list

Revision 1.4  1993/04/08  17:42:49  jont
Modify edit and edit_from_location to use the relevant editor

Revision 1.3  1993/04/08  15:00:45  jont
Added options parameter

Revision 1.2  1993/03/23  18:35:09  jont
Changed editor implementastion slightly.

Revision 1.1  1993/03/10  17:24:30  jont
Initial revision

Copyright (C) 1993 Harlequin Ltd
*)

require "../make/os";
require "../main/preferences";
require "../basics/location";
require "../utils/crash";
require "editor";

functor Editor
  (structure Preferences: PREFERENCES
   structure Crash : CRASH
   structure Location : LOCATION
   structure Os : OS
   val server_socket_name : string
  ) : EDITOR =
struct
    structure Location = Location

    type preferences = Preferences.preferences

    fun line_from_location(Location.UNKNOWN) = 0
      | line_from_location(Location.FILE _) = 0
      | line_from_location(Location.LINE(_, i)) = i
      | line_from_location(Location.POSITION(_, i, _)) = i
      | line_from_location(Location.EXTENT{s_line=i, ...}) = i

    fun null_fun () = ()


    fun emacs (filename, s_line, s_col, e_line, e_col, raise_window) =
      let
        val s = MLWorks.OS.Unix.socket (1, 1, 0)
      in
	let
	  val find_file =
            ["(find-file \"", filename, "\")\n"]

          val goto_line =
            ["(goto-line ", MLWorks.Integer.makestring s_line, ")\n"]

          val forward_char =
            ["(forward-char ", MLWorks.Integer.makestring s_col, ")\n"]
  
	  val set_highlight =
	    if e_line <> ~1 then
	      ["(mlworks-highlight ",
	       MLWorks.Integer.makestring s_line, " ",
	       MLWorks.Integer.makestring s_col, " ",
	       MLWorks.Integer.makestring e_line, " ",
	       MLWorks.Integer.makestring e_col, ")\n"]
	    else
	      ["\n"]
  
	  val raise_code =
	    if raise_window then
	      ["(raise-this-window)\n"]
	    else
	      []
        in
	  MLWorks.OS.Unix.connect
            (s, MLWorks.OS.Unix.SOCKADDR_UNIX
	          (implode [Os.home "", "/", server_socket_name]));
          MLWorks.OS.Unix.write (s, implode find_file);
          MLWorks.OS.Unix.write
	    (s, implode (["(progn "] @@ goto_line @@ forward_char
			 @@ set_highlight @@ raise_code @@ [")"]));
          MLWorks.OS.Unix.close s;
          (MLWorks.Option.NONE, null_fun)
        end
	handle
	MLWorks.OS.Unix.Unix msg =>
          (MLWorks.OS.Unix.close s;
           (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server",
	    null_fun))
      end
      handle MLWorks.OS.Unix.Unix _ =>
        (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server", null_fun)

    fun parse_command (s, filename, line) =
      let fun parse (~1, [], list) = list
          |   parse (~1, word, list) = implode word :: list
	  |   parse (i, word, list) =
	    let val ch = String.ordof (s, i)
	    in
	      if ch = ord " " then
		case word of
		  [] => parse (i-1, [], list)
	        | _  => parse (i-1, [], implode (word) :: list)
	      else if ch = ord "l" andalso i > 0
		   andalso String.ordof (s, i-1) = ord "%" then
                   parse (i-2, MLWorks.Integer.makestring line :: word, list)
	      else
	        parse (i-1, chr ch :: word, list)
	    end
      in
	parse (size s - 1, [], [filename])
      end

    fun xterm parsed_command =
      let
        val pid = 
          (MLWorks.OS.Unix.vfork_execvp
             ("xterm", ["xterm", "-name", "visual", "-e"] @@ parsed_command))
      in
        (MLWorks.Option.NONE,fn () =>
         MLWorks.OS.Unix.kill (pid,9)
         handle MLWorks.OS.Unix.Unix _ => ())
      end
      handle MLWorks.OS.Unix.Unix _ =>
        (MLWorks.Option.SOME ("Unable to launch xterm editor processes"),null_fun)

    fun x (parsed_command as command :: _) =
      (let
         val pid = 
           (MLWorks.OS.Unix.vfork_execvp
              (command, parsed_command))
       in
         (MLWorks.Option.NONE,fn () =>
          MLWorks.OS.Unix.kill (pid,9)
          handle MLWorks.OS.Unix.Unix _ => ())
       end
       handle MLWorks.OS.Unix.Unix _ =>
         (MLWorks.Option.SOME ("Unable to launch x editor process"),null_fun))
    |  x nil = Crash.impossible "nil argument to x editor"

    fun edit
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
	        {editor, x_editor_command, xterm_editor_command, ...},
	      ...})
          (string, i) =
      case !editor of
        "emacs_server" => emacs (string, i, 0, ~1, ~1, true)
      | "xterm" => xterm (parse_command (!xterm_editor_command, string, i))
      | "x" =>
	x (parse_command (!x_editor_command, string, i))
      | _ => (MLWorks.Option.SOME ("Unknown editor `" ^ !editor ^ "'"),null_fun)

    fun edit_from_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
	        {editor, x_editor_command, xterm_editor_command, ...},
	      ...})
          (string, location) =
      case !editor of
        "emacs_server" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   emacs (string, s_line, s_col, e_line, e_col, true)
	 |  _ => emacs (string, line_from_location location, 0, ~1, ~1, true))
      | "xterm" =>
	xterm (parse_command
		 (!xterm_editor_command, string, line_from_location location))
      | "x" =>
	x (parse_command
	     (!x_editor_command, string, line_from_location location))
      | _ => (MLWorks.Option.SOME ("Unknown editor `" ^ !editor ^ "'"),null_fun)

    fun show_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
	        {editor, x_editor_command, xterm_editor_command, ...},
	      ...})
          (string, location) =
      case !editor of
        "emacs_server" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   emacs (string, s_line, s_col, e_line, e_col, false)
	 |  _ => emacs (string, line_from_location location, 0, ~1, ~1, false))
      | _ => (MLWorks.Option.SOME ("Show location require emacs"), null_fun)
  end
@


1.18
log
@Sent the emacs commands as separate S-expressions, to avoid buffer
overflow problems.
@
text
@d4 4
d111 1
a111 1
	      ["(set-highlight ",
@


1.17
log
@Made emacs highlight errors.
Removed next_error and no_more_errors.
@
text
@d4 4
d90 2
a91 1
    fun emacs (filename, s_line, s_col, e_line, e_col) =
a93 19

	val find_file =
	  ["(progn (find-file \"",
           filename,
           "\") (goto-line ",
           MLWorks.Integer.makestring s_line,
           ") (forward-char ",
	   MLWorks.Integer.makestring s_col,
	   ")"]
	
	val set_highlight =
	  if e_line <> ~1 then
	    ["(set-highlight ",
	     MLWorks.Integer.makestring s_line, " ",
	     MLWorks.Integer.makestring s_col, " ",
	     MLWorks.Integer.makestring e_line, " ",
	     MLWorks.Integer.makestring e_col, "))\n"]
	  else
	    [")\n"]
d95 41
a135 6
        MLWorks.OS.Unix.connect
          (s, MLWorks.OS.Unix.SOCKADDR_UNIX
	        (implode [Os.home "", "/", server_socket_name]));
        MLWorks.OS.Unix.write (s, implode (find_file @@ set_highlight));
        MLWorks.OS.Unix.close s;
        (MLWorks.Option.NONE, null_fun)
d138 1
a138 1
        (MLWorks.Option.SOME ("Unable to contact MLWorks Emacs server"), null_fun)
d194 1
a194 1
        "emacs_server" => emacs (string, i, 0, ~1, ~1)
d210 2
a211 2
	   emacs (string, s_line, s_col, e_line, e_col)
	 |  _ => emacs (string, line_from_location location, 0, ~1, ~1))
d219 14
@


1.16
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d4 3
a77 2
    exception no_more_errors

d86 1
a86 1
    fun emacs (filename, line) =
d89 19
d110 3
a112 6
        (s, MLWorks.OS.Unix.SOCKADDR_UNIX (implode [Os.home "", "/", server_socket_name]));
        MLWorks.OS.Unix.write (s, implode ["(progn (find-file \"",
                                           filename,
                                           "\") (goto-line ",
                                           MLWorks.Integer.makestring line,
                                           "))\n"]);
d114 1
a114 1
        (MLWorks.Option.NONE,null_fun)
d167 5
a171 5
      (Preferences.PREFERENCES
         {editor_options=Preferences.EDITOR_OPTIONS
	    {editor, x_editor_command, xterm_editor_command, ...},
	  ...})
      (string, i) =
d173 1
a173 1
        "emacs_server" => emacs (string, i)
d179 19
a197 17
    fun edit_from_location options (string, location) =
      edit options (string, line_from_location location)

    fun next_error options [] = raise no_more_errors
      | next_error options ((location, string) :: rest) =
	let
	  val file = case location of
	    Location.UNKNOWN => Crash.impossible("Unknown error location")
	  | Location.FILE file => file
	  | Location.LINE(file, _) => file
	  | Location.POSITION(file, _, _) => file
	  | Location.EXTENT{name=file, ...} => file
	in
	  output(std_out, string ^ "\n");
	  edit_from_location options (file, location);
	  rest
	end
@


1.15
log
@Move OS specific stuff into a system link directory
@
text
@d4 3
a57 1
require "../main/options";
a59 1
require "../utils/option";
a64 1
   structure Option : OPTION
a71 1
    structure Option = Option
d97 1
a97 1
        (Option.ABSENT,null_fun)
d100 1
a100 1
        (Option.PRESENT ("Unable to contact MLWorks Emacs server"), null_fun)
d128 1
a128 1
        (Option.ABSENT,fn () =>
d133 1
a133 1
        (Option.PRESENT ("Unable to launch xterm editor processes"),null_fun)
d141 1
a141 1
         (Option.ABSENT,fn () =>
d146 1
a146 1
         (Option.PRESENT ("Unable to launch x editor process"),null_fun))
d160 1
a160 1
      | _ => (Option.PRESENT ("Unknown editor `" ^ !editor ^ "'"),null_fun)
@


1.14
log
@Reinstate call to makestring
@
text
@d4 3
d54 1
a59 1
require "../make/unix";
d67 1
a67 1
   structure Unix : UNIX
d91 1
a91 1
        (s, MLWorks.OS.Unix.SOCKADDR_UNIX (implode [Unix.home "", "/", server_socket_name]));
@


1.13
log
@Added support for user-defined editors.
@
text
@d4 3
d112 1
a112 1
	        parse (i-2, (* MLWorks.Integer.makestring line *) "23" :: word, list)
@


1.12
log
@Moved preferences into separate structure.
@
text
@d4 3
d97 21
a117 1
    fun vi (filename, line) =
d121 1
a121 2
           ("xterm", ["xterm", "-name", "visual",
                      "-e", "vi", "+" ^ MLWorks.Integer.makestring line, filename]))
d128 15
a142 1
        (Option.PRESENT ("Unable to launch vi process"),null_fun)
d146 3
a148 1
         {editor_options=Preferences.EDITOR_OPTIONS{editor, ...}, ...})
d151 4
a154 2
        "emacs" => emacs (string, i)
      | "vi" => vi (string, i)
@


1.11
log
@reversed arguments to kill
added handler for Unix exception
@
text
@d4 4
d46 1
d53 9
a61 8
functor Editor(
  structure Options : OPTIONS
  structure Option : OPTION
  structure Crash : CRASH
  structure Location : LOCATION
  structure Unix : UNIX
  val server_socket_name : string) : EDITOR =
  struct
d64 2
a65 1
    structure Options = Options
d109 2
a110 2
      (Options.OPTIONS
       {editor_options=Options.EDITOR_OPTIONS{editor, ...}, ...})
@


1.11.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.11  1993/08/31  11:29:18  matthew
reversed arguments to kill
added handler for Unix exception

@


1.10
log
@Added call to Unix.kill
@
text
@d4 3
d94 3
a96 1
        (Option.ABSENT,fn () => MLWorks.OS.Unix.kill (9,pid))
@


1.9
log
@Return quit function from ShellUtils.edit_string
Need to uncomment call to kill]
@
text
@d4 4
d91 1
a91 1
        (Option.ABSENT,fn () => output(std_out,"Poo\n") (* MLWorks.OS.Unix.kill pid *))
@


1.8
log
@Removed filename component of error result for edit functions.
@
text
@d4 3
d61 2
d75 1
a75 1
        Option.ABSENT
d78 1
a78 1
        Option.PRESENT ("Unable to contact MLWorks Emacs server")
d81 8
a88 4
      (MLWorks.OS.Unix.vfork_execvp
       ("xterm", ["xterm", "-name", "visual",
                  "-e", "vi", "+" ^ MLWorks.Integer.makestring line, filename]);
       Option.ABSENT)
d90 1
a90 1
        Option.PRESENT ("Unable to launch vi process")
d99 1
a99 1
      | _ => Option.PRESENT ("Unknown editor `" ^ !editor ^ "'")
@


1.7
log
@Changed Integer.makestring to MLWorks.Integer.makestring and removed
the Integer structure.
@
text
@d4 4
d73 1
a73 1
        Option.PRESENT (filename, "Unable to contact MLWorks Emacs server")
d81 1
a81 1
        Option.PRESENT (filename, "Unable to launch vi process")
d90 1
a90 1
      | _ => Option.PRESENT (string, "Unknown editor `" ^ !editor ^ "'")
@


1.6
log
@The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.
@
text
@d4 5
a29 1
require "../utils/integer";
a36 1
  structure Integer : INTEGER
d63 1
a63 1
                                           Integer.makestring line,
d74 1
a74 1
                  "-e", "vi", "+" ^ Integer.makestring line, filename]);
d83 1
a83 1
      case editor of
d86 1
a86 1
      | _ => Option.PRESENT (string, "Unknown editor `" ^ editor ^ "'")
@


1.5
log
@Added editing from location. Added a function to do next error from a list
@
text
@d4 3
d27 1
d35 3
a37 1
  structure Location : LOCATION) : EDITOR =
d45 5
a49 5
    fun line_from_location(Location.UNKNOWN) = "+0"
      | line_from_location(Location.FILE _) = "+0"
      | line_from_location(Location.LINE(_, i)) = "+" ^ Integer.makestring i
      | line_from_location(Location.POSITION(_, i, _)) = "+" ^ Integer.makestring i
      | line_from_location(Location.EXTENT{s_line=i, ...}) = "+" ^ Integer.makestring i
d51 16
a66 10
    fun edit_from_location
      (Options.OPTIONS
       {editor_options=Options.EDITOR_OPTIONS{editor, ...}, ...})
      (string, location) =
      ((case editor of
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file [string]
	| MLWorks.Editor.VI =>
	    MLWorks.Editor.vi_file [line_from_location location, string]);
	  Option.ABSENT)
      handle MLWorks.Editor.NotFound arg => Option.PRESENT arg
d68 8
d80 7
a86 6
      ((case editor of
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file[string]
	| MLWorks.Editor.VI =>
	    MLWorks.Editor.vi_file["+" ^ Integer.makestring i, string]);
	  Option.ABSENT)
      handle MLWorks.Editor.NotFound arg => Option.PRESENT arg
@


1.4
log
@Modify edit and edit_from_location to use the relevant editor
@
text
@d4 3
d22 2
d29 2
d37 8
d50 3
a52 3
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file
	| MLWorks.Editor.VI => MLWorks.Editor.vi_file)
	  [string];
d61 3
a63 2
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file
	| MLWorks.Editor.VI => MLWorks.Editor.vi_file)[string];
d66 15
@


1.3
log
@Added options parameter
@
text
@d4 3
d34 5
a38 2
      (MLWorks.Editor.load_file[string];
       Option.ABSENT)
d45 4
a48 2
      (MLWorks.Editor.load_file[string];
       Option.ABSENT)
@


1.2
log
@Changed editor implementastion slightly.
@
text
@d4 3
d13 1
d19 1
d25 1
d27 4
a30 1
    fun edit_from_location (string, location) =
d35 4
a38 1
    fun edit(string, i) =
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d22 1
a22 1
      (MLWorks.Editor.load_file string;
d27 1
a27 1
      (MLWorks.Editor.load_file string;
@
