head	1.3;
access;
symbols
	MLW_daveb_inline_1_4_99:1.3.8
	MLWorks_21c0_1999_03_25:1.3
	MLWorks_20c1_1998_08_20:1.3
	MLWorks_20c0_1998_08_04:1.3
	MLWorks_20b2c2_1998_06_19:1.3
	MLWorks_20b2_Windows_1998_06_12:1.3
	MLWorks_20b1c1_1998_05_07:1.3
	MLWorks_20b0_1998_04_07:1.3
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_20m1_1997_10_23:1.3
	MLWorks_11r1:1.3.5.1.1.1.1
	MLWorks_workspace_97:1.3.7
	MLWorks_dt_wizard:1.3.6
	MLWorks_11c0_1997_09_09:1.3.5.1.1.1
	MLWorks_10r3:1.3.5.1.3
	MLWorks_10r2_551:1.3.5.1.2
	MLWorks_11:1.3.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.5.1
	MLWorks_20m0_1997_06_20:1.3
	MLWorks_1_0_r2c2_1997_06_14:1.3.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.3.5
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.3.3.1.1
	MLWorks_gui_1996_12_18:1.3.4
	MLWorks_1_0_Win32_1996_12_17:1.3.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.1.1
	MLWorks_1_0_Irix_1996_11_28:1.3.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.2
	MLWorks_1_0_Unix_1996_11_14:1.3.1
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1;
locks; strict;
comment	@ *  @;


1.3
date	96.11.06.14.02.55;	author brianm;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1
	1.3.5.1
	1.3.6.1
	1.3.7.1
	1.3.8.1;
next	1.2;

1.2
date	96.10.25.13.26.47;	author io;	state Exp;
branches;
next	1.1;

1.1
date	96.08.30.10.55.28;	author davids;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	96.09.13.11.12.26;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.03.08;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.21.25;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.11.14.12.45.11;	author hope;	state Exp;
branches
	1.3.1.1.1.1;
next	;

1.3.1.1.1.1
date	96.11.28.14.57.05;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.11.22.18.05.41;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.12.17.17.44.28;	author hope;	state Exp;
branches
	1.3.3.1.1.1;
next	;

1.3.3.1.1.1
date	97.02.24.11.33.52;	author hope;	state Exp;
branches;
next	;

1.3.4.1
date	96.12.18.09.38.27;	author hope;	state Exp;
branches;
next	;

1.3.5.1
date	97.05.12.10.30.45;	author hope;	state Exp;
branches
	1.3.5.1.1.1
	1.3.5.1.2.1
	1.3.5.1.3.1;
next	;

1.3.5.1.1.1
date	97.07.28.18.15.51;	author daveb;	state Exp;
branches
	1.3.5.1.1.1.1.1;
next	;

1.3.5.1.1.1.1.1
date	97.10.07.11.40.53;	author jkbrook;	state Exp;
branches;
next	;

1.3.5.1.2.1
date	97.09.08.17.09.24;	author daveb;	state Exp;
branches;
next	;

1.3.5.1.3.1
date	97.09.09.14.04.46;	author daveb;	state Exp;
branches;
next	;

1.3.6.1
date	97.09.10.19.19.03;	author brucem;	state Exp;
branches;
next	;

1.3.7.1
date	97.09.11.20.50.13;	author daveb;	state Exp;
branches;
next	;

1.3.8.1
date	99.04.01.17.53.52;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.3
log
@Fixing samples.
@
text
@(*  ==== FI EXAMPLES : Regular expression parser ====
 *
 *  Copyright (C) 1996 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This module provides ML functions to parse regular expressions, using
 *  the foreign functions defined in regexp.c.
 *
 *  Revision Log
 *  ------------
 *  $Log: samples:Unix:regexp.sml,v $
 *  Revision 1.2  1996/10/25  13:26:47  io
 *  update for naming conventions
 *
 *  Revision 1.1  1996/08/30  10:55:28  davids
 *  new unit
 *
 *
 *)

require "$.foreign.__interface";


local

  structure Store = Interface.Store
  structure CStructure = Interface.C.Structure
  structure CSignature = Interface.C.Signature
  structure CFunction = Interface.C.Function
  structure CType = Interface.C.Type
  structure CValue = Interface.C.Value

  (* The maximum string length allowed in the regular expression or string
   to search. *)

  val maxLength = 1000;


  (* Loading a Structure *)
  val regexpStruct = 
    CStructure.loadObjectFile ("foreign/samples/regexp.so", CStructure.IMMEDIATE_LOAD)
   (* the filename is relative to the current directory that MLWorks is using *)


  (* Defining a c_signature object *)

  val regexpSig = CSignature.newSignature ();


  (* Adding signature entries *)
    
  val _ = 
    CSignature.defEntry (regexpSig,
			  CSignature.FUN_DECL 
			    {name   = "regexp_search",
		             source = [CType.STRING_TYPE {length = maxLength}, 
				       CType.STRING_TYPE {length = maxLength}],
			     target = CType.INT_TYPE })

  val _ = 
    CSignature.defEntry (regexpSig,
			  CSignature.FUN_DECL 
			    {name   = "get_rest",
			     source = [],
			     target = CType.STRING_TYPE {length = maxLength} })

  val _ = 
    CSignature.defEntry (regexpSig,
			  CSignature.FUN_DECL 
			    {name   = "get_match",
			     source = [],
			     target = CType.STRING_TYPE {length = maxLength} })

  val _ = 
    CSignature.defEntry (regexpSig,
			  CSignature.FUN_DECL 
			    {name   = "get_error",
			     source = [],
			     target = CType.INT_TYPE })


  (* Make a `callable object' lookup function for our foreign code *)
    
  val regexpFF = 
    CFunction.defineForeignFun (regexpStruct, regexpSig)
    

  (* Extract foreign function objects as ML values *) 
    
  val regexpSearchFF = regexpFF "regexp_search"

  val getRestFF = regexpFF "get_rest"

  val getMatchFF = regexpFF "get_match"

  val getErrorFF = regexpFF "get_error"


  (* Building a store *)

  val regexpStore =
    Store.store {alloc    = Store.ALIGNED_4,
		 overflow = Store.BREAK,
		 size     = maxLength * 10 + 20,
		 status   = Store.RDWR_STATUS}


  (* Create objects. *)

  val stringObject1 = 
    CValue.object {ctype = CType.STRING_TYPE {length = maxLength},
  		   store = regexpStore}

  val stringObject2 = 
    CValue.object {ctype = CType.STRING_TYPE {length = maxLength},
		   store = regexpStore}

  val stringObject3 = 
    CValue.object {ctype = CType.STRING_TYPE {length = maxLength},
  		   store = regexpStore}

  val stringObject4 = 
    CValue.object {ctype = CType.STRING_TYPE {length = maxLength},
		   store = regexpStore}

  val intObject1 =
    CValue.object {ctype = CType.INT_TYPE,
		   store = regexpStore}

  val intObject2 =
    CValue.object {ctype = CType.INT_TYPE,
		   store = regexpStore}

  val voidObject =
    CValue.object {ctype = CType.VOID_TYPE,
		   store = regexpStore}

in
  (* This could be flaky, give it maxLength arguments for the time being *)
  fun regexpSearch (string, regexpString) =
    (CValue.setString (stringObject1, string);
     CValue.setString (stringObject2, regexpString);
     print (CValue.getString (stringObject1) ^ "\n");
     print (CValue.getString (stringObject2) ^ "\n");	    
     CFunction.call regexpSearchFF ([stringObject1, stringObject2],
				    intObject1);
     CFunction.call getErrorFF ([], intObject2);
     if CValue.getInt (intObject2) <> 0 then
       raise Fail "Error in parsing regular expression.\n"
     else
       case CValue.getInt (intObject1) of
	 0 => NONE
       | x => (CFunction.call getRestFF ([], stringObject3);
	       CFunction.call getMatchFF ([], stringObject4);
	       SOME (CValue.getString stringObject3,
		     CValue.getString stringObject4)))

  (* A quick example -

          regexpSearch ("abcdefghijk", "def");

     The first argument is a string to be searched and the second argment
     is a UNIX style regular expression.  In the above example, this is simply
     a substring.

   *)
   
end
@


1.3.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 3
 *  Revision 1.3  1996/11/06  14:02:55  brianm
 *  Fixing samples.
 *
@


1.3.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 3
 *  Revision 1.3  1996/11/06  14:02:55  brianm
 *  Fixing samples.
 *
@


1.3.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 3
 *  Revision 1.3  1996/11/06  14:02:55  brianm
 *  Fixing samples.
 *
@


1.3.5.1
log
@branched from 1.3
@
text
@a12 3
 *  Revision 1.3  1996/11/06  14:02:55  brianm
 *  Fixing samples.
 *
@


1.3.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 *  Revision 1.3.5.1  1997/05/12  10:30:45  hope
 *  branched from 1.3
 *
@


1.3.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 *  Revision 1.3.5.1  1997/05/12  10:30:45  hope
 *  branched from 1.3
 *
@


1.3.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 *  Revision 1.3.5.1  1997/05/12  10:30:45  hope
 *  branched from 1.3
 *
@


1.3.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 3
 *  Revision 1.3.5.1.1.1  1997/07/28  18:15:51  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.3.4.1
log
@branched from 1.3
@
text
@a12 3
 *  Revision 1.3  1996/11/06  14:02:55  brianm
 *  Fixing samples.
 *
@


1.3.3.1
log
@branched from 1.3
@
text
@a12 3
 *  Revision 1.3  1996/11/06  14:02:55  brianm
 *  Fixing samples.
 *
@


1.3.3.1.1.1
log
@branched from 1.3.3.1
@
text
@a12 3
 *  Revision 1.3.3.1  1996/12/17  17:44:28  hope
 *  branched from 1.3
 *
@


1.3.2.1
log
@branched from 1.3
@
text
@a12 3
 *  Revision 1.3  1996/11/06  14:02:55  brianm
 *  Fixing samples.
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a12 3
 *  Revision 1.3  1996/11/06  14:02:55  brianm
 *  Fixing samples.
 *
@


1.3.1.1.1.1
log
@branched from 1.3.1.1
@
text
@a12 3
 *  Revision 1.3.1.1  1996/11/14  12:45:11  hope
 *  branched from 1.3
 *
@


1.2
log
@update for naming conventions
@
text
@d13 3
d42 2
a43 7
    CStructure.loadObjectFile ("foreign/samples/Unix/regexp.so", CStructure.IMMEDIATE_LOAD)


   (* I prefer to do it relative to MLWORKS_SRC_PATH
    * I use "foreign/samples/Unix/hello.so"
    * instead of "./hello.so"
    *)
d56 2
a57 2
			    {name = "regexp_search",
		     source = [CType.STRING_TYPE {length = maxLength}, 
d64 1
a64 1
			    {name = "get_rest",
d71 1
a71 1
			    {name = "get_match",
d78 1
a78 1
			    {name = "get_error",
d158 11
a168 1
	   
@


1.1
log
@new unit
@
text
@d12 4
a15 1
 *  $Log$
d19 1
a19 1
require "foreign.__foreign";
d24 6
a29 6
  structure Store = ForeignInterface.Store
  structure CStructure = ForeignInterface.C.Structure
  structure CSignature = ForeignInterface.C.Signature
  structure CFunction = ForeignInterface.C.Function
  structure CType = ForeignInterface.C.Type
  structure CValue = ForeignInterface.C.Value
d38 2
d41 5
a45 2
  val regexpStruct = 
    CStructure.load_object_file ("./reg.so", CStructure.IMMEDIATE_LOAD)
d50 1
a50 1
  val regexpSig = CSignature.new_signature ();
d56 1
a56 1
    CSignature.def_entry (regexpSig,
d64 1
a64 1
    CSignature.def_entry (regexpSig,
d71 1
a71 1
    CSignature.def_entry (regexpSig,
d78 1
a78 1
    CSignature.def_entry (regexpSig,
d88 1
a88 1
    CFunction.define_foreign_fun (regexpStruct, regexpSig)
d142 1
a142 1
  
d144 4
a147 4
    (CValue.set_string (stringObject1, string);
     CValue.set_string (stringObject2, regexpString);
     print (CValue.get_string (stringObject1) ^ "\n");
     print (CValue.get_string (stringObject2) ^ "\n");	    
d151 1
a151 1
     if CValue.get_int (intObject2) <> 0 then
d154 1
a154 1
       case CValue.get_int (intObject1) of
d158 2
a159 2
	       SOME (CValue.get_string stringObject3,
		     CValue.get_string stringObject4)))
@


1.1.3.1
log
@branched from 1.1
@
text
@d12 1
a12 4
 *  $Log: samples:Unix:regexp.sml,v $
 *  Revision 1.1  1996/08/30  10:55:28  davids
 *  new unit
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d12 1
a12 4
 *  $Log: samples:Unix:regexp.sml,v $
 *  Revision 1.1  1996/08/30  10:55:28  davids
 *  new unit
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d12 1
a12 4
 *  $Log: samples:Unix:regexp.sml,v $
 *  Revision 1.1  1996/08/30  10:55:28  davids
 *  new unit
 *
@
