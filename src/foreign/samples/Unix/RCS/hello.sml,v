head	1.6;
access;
symbols
	MLW_daveb_inline_1_4_99:1.6.3
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.6
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.5.5.2.1.1.1
	MLWorks_workspace_97:1.6.2
	MLWorks_dt_wizard:1.6.1
	MLWorks_11c0_1997_09_09:1.5.5.2.1.1
	MLWorks_10r3:1.5.5.2.3
	MLWorks_10r2_551:1.5.5.2.2
	MLWorks_11:1.5.5.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.5.2
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.5.5.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.5.2
	MLWorks_1_0_r2c1_1997_05_12:1.5.5
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.3.1.1
	MLWorks_gui_1996_12_18:1.5.4
	MLWorks_1_0_Win32_1996_12_17:1.5.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.1.1
	MLWorks_1_0_Irix_1996_11_28:1.5.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.2
	MLWorks_1_0_Unix_1996_11_14:1.5.1
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.1;
locks; strict;
comment	@ *  @;


1.6
date	97.06.16.10.41.48;	author jkbrook;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1;
next	1.5;

1.5
date	96.11.06.14.12.38;	author brianm;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1
	1.5.5.1;
next	1.4;

1.4
date	96.10.24.13.58.18;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.10.22.09.49.50;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.08.11.20.02.27;	author brianm;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	96.05.24.14.31.33;	author brianm;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.11.58;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.16.02.41;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.20.56;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.11.14.12.44.38;	author hope;	state Exp;
branches
	1.5.1.1.1.1;
next	;

1.5.1.1.1.1
date	96.11.28.14.56.36;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.11.22.18.05.03;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.12.17.17.43.59;	author hope;	state Exp;
branches
	1.5.3.1.1.1;
next	;

1.5.3.1.1.1
date	97.02.24.11.33.18;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.12.18.09.37.57;	author hope;	state Exp;
branches;
next	;

1.5.5.1
date	97.05.12.10.30.15;	author hope;	state Exp;
branches;
next	1.5.5.2;

1.5.5.2
date	97.05.15.13.04.11;	author daveb;	state Exp;
branches
	1.5.5.2.1.1
	1.5.5.2.2.1
	1.5.5.2.3.1;
next	;

1.5.5.2.1.1
date	97.07.28.18.16.10;	author daveb;	state Exp;
branches
	1.5.5.2.1.1.1.1;
next	;

1.5.5.2.1.1.1.1
date	97.10.07.11.41.06;	author jkbrook;	state Exp;
branches;
next	;

1.5.5.2.2.1
date	97.09.08.17.09.45;	author daveb;	state Exp;
branches;
next	;

1.5.5.2.3.1
date	97.09.09.14.05.10;	author daveb;	state Exp;
branches;
next	;

1.6.1.1
date	97.09.10.19.19.28;	author brucem;	state Exp;
branches;
next	;

1.6.2.1
date	97.09.11.20.50.40;	author daveb;	state Exp;
branches;
next	;

1.6.3.1
date	99.04.01.17.54.20;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.6
log
@[Bug #30127]
Merging changes from 1.0r2c1 into 2.0m0
@
text
@(* Hello example ML FI interface code.
 * 
 * Copyright (C) 1996 The Harlequin Group Limited.  All rights reserved.
 *)


require "$.foreign.__interface";

(* ML FI structure mapping *)

local
   structure Store  = Interface.Store
   structure Structure  = Interface.C.Structure
   structure Signature  = Interface.C.Signature
   structure Function  = Interface.C.Function
   structure Type  = Interface.C.Type
   structure Value  = Interface.C.Value
in
   val ALIGNED_4     = Store.ALIGNED_4
   val BREAK         = Store.BREAK
   val RDWR_STATUS   = Store.RDWR_STATUS
   val store         = Store.store

   val loadObjectFile = Structure.loadObjectFile
   val IMMEDIATE_LOAD   = Structure.IMMEDIATE_LOAD

   val newSignature = Signature.newSignature
   val defEntry = Signature.defEntry
   val FUN_DECL = Signature.FUN_DECL
     
   val defineForeignFun = Function.defineForeignFun
   val call               = Function.call

   type c_type = Type.c_type

   val VOID_TYPE     = Type.VOID_TYPE
   val STRING_TYPE   = Type.STRING_TYPE
   val INT_TYPE      = Type.INT_TYPE
   val CHAR_TYPE     = Type.CHAR_TYPE
   val ptrType       = Type.ptrType

   val object          = Value.object
   val setString       = Value.setString
   val getString       = Value.getString
   val setInt          = Value.setInt
   val getInt          = Value.getInt
   val setPtrType     = Value.setPtrType
   val setPtrAddrOf  = Value.setPtrAddrOf
   val castPtrType    = Value.castPtrType
end


(* Loading a Structure *)

   val hello_struct = loadObjectFile("foreign/samples/hello.so",IMMEDIATE_LOAD);
   (* the filename is relative to the current directory that MLWorks is using *)


(* Building a store *)

    val hello_store =
          store{ alloc    = ALIGNED_4,
                 overflow = BREAK,
                 size     = 60,
                 status   = RDWR_STATUS   };


(* Creating objects *)

   val void_object =
         object { ctype  = VOID_TYPE,
                  store  = hello_store };

   val str_object =
         object { ctype  = STRING_TYPE{ length = 30 },
                  store  = hello_store };

   val int_object1 =
         object { ctype  = INT_TYPE,
                  store  = hello_store };

   val int_object2 =
         object { ctype  = INT_TYPE,
                  store  = hello_store };

   val ptr_object =
         object { ctype  = ptrType(VOID_TYPE),
                  store  = hello_store };



(* Initialising object values - these will be our arguments *)

	 setString(str_object, "What is 65 - 42? ---- Ans is ");
	 setInt(int_object1, 23);

(* Examining object values *)

	 getString(str_object);
	 getInt(int_object1);


(* Defining a c_signature object *)

   val hello_sig = newSignature ();


(* Adding a new Signature entry *)

     defEntry(hello_sig,
	      FUN_DECL { name = "hello",
                        source = [ptrType(CHAR_TYPE), INT_TYPE] : c_type list,
                        target = INT_TYPE }
            );


(* Make a `callable object' lookup function for our foreign code *)

   val def_hello = defineForeignFun( hello_struct, hello_sig );


(* Extract a foreign function object as an ML value *) 

   val hello = def_hello "hello";;


(* Setting up string pointers ... *)

     setPtrType    { ptr = ptr_object, data = str_object };
     setPtrAddrOf { ptr = ptr_object, data = str_object };
     castPtrType   { ptr = ptr_object, ctype = CHAR_TYPE };


(* Call the foreign function *)

   call hello ( [ptr_object,int_object1], int_object2 );


(* Extracting the result data *)

   getInt(int_object2);

@


1.6.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@@


1.6.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.6.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@@


1.5
log
@Fixing samples.
@
text
@d1 5
a5 2
(* ++++ Hello example ML FI interface code ++++ *)
(* ++++ ================================== ++++ *)
@


1.5.5.1
log
@branched from 1.5
@
text
@@


1.5.5.2
log
@[Bug #30127]
Added copyright notice.
@
text
@d1 2
a2 5
(* Hello example ML FI interface code.
 * 
 * Copyright (C) 1996 The Harlequin Group Limited.  All rights reserved.
 *)

@


1.5.5.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.5.5.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.5.5.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.5.5.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.5.4.1
log
@branched from 1.5
@
text
@@


1.5.3.1
log
@branched from 1.5
@
text
@@


1.5.3.1.1.1
log
@branched from 1.5.3.1
@
text
@@


1.5.2.1
log
@branched from 1.5
@
text
@@


1.5.1.1
log
@branched from 1.5
@
text
@@


1.5.1.1.1.1
log
@branched from 1.5.1.1
@
text
@@


1.4
log
@[Bug #1547]
updating for current naming conventions
@
text
@d52 2
a53 6
   val hello_struct = loadObjectFile("foreign/samples/Unix/hello.so",IMMEDIATE_LOAD);

   (* I prefer to do it relative to MLWORKS_SRC_PATH
    * I use "foreign/samples/Unix/hello.so"
    *)
      
@


1.3
log
@Add missing require declaration for __interface
@
text
@d21 1
a21 1
   val load_object_file = Structure.load_object_file
d24 5
a28 5
   val new_signature = Signature.new_signature
   val def_entry     = Signature.def_entry
   val FUN_DECL      = Signature.FUN_DECL

   val define_foreign_fun = Function.define_foreign_fun
d39 8
a46 8
   val object           = Value.object
   val set_string       = Value.set_string
   val get_string       = Value.get_string
   val set_int          = Value.set_int
   val get_int          = Value.get_int
   val set_ptr_type     = Value.set_ptr_type
   val set_ptr_addr_of  = Value.set_ptr_addr_of
   val cast_ptr_type    = Value.cast_ptr_type
d49 1
d52 6
a57 1
   val hello_struct = load_object_file("./hello.so",IMMEDIATE_LOAD);
d95 2
a96 2
   set_string(str_object, "What is 65 - 42? ---- Ans is ");
   set_int(int_object1, 23);
d100 2
a101 2
   get_string(str_object);
   get_int(int_object1);
d106 1
a106 1
   val hello_sig = new_signature();
d111 2
a112 2
   def_entry(hello_sig,
             FUN_DECL { name = "hello",
d120 1
a120 1
   val def_hello = define_foreign_fun( hello_struct, hello_sig );
d130 3
a132 3
   set_ptr_type    { ptr = ptr_object, data = str_object };
   set_ptr_addr_of { ptr = ptr_object, data = str_object };
   cast_ptr_type   { ptr = ptr_object, ctype = CHAR_TYPE };
d142 1
a142 1
   get_int(int_object2);
@


1.2
log
@Removing open's in examples ...
@
text
@d4 1
@


1.2.3.1
log
@branched from 1.2
@
text
@@


1.2.2.1
log
@branched from 1.2
@
text
@@


1.2.1.1
log
@branched from 1.2
@
text
@@


1.1
log
@new unit
New file.
@
text
@d5 1
a5 16
(* Opening the ML FI structures *)


   open ForeignInterface;
   open Store;
   open Object;
   open Diagnostic;
   open LibML;
   open C;
   open Structure;
   open Type;
   open Value;
   open Signature;
   open Function;
   open Diagnostic;

d7 40
d56 1
a56 1
         store{ alloc    = ALIGNED_4,
d69 1
a69 1
         object { ctype  = STRING_TYPE{ length = 20 },
d136 1
@
