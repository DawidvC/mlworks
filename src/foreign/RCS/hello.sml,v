head	1.3;
access;
symbols
	MLW_daveb_inline_1_4_99:1.3.8
	MLWorks_21c0_1999_03_25:1.3
	MLWorks_20c1_1998_08_20:1.3
	MLWorks_20c0_1998_08_04:1.3
	MLWorks_20b2c2_1998_06_19:1.3
	MLWorks_20b2_Windows_1998_06_12:1.3
	MLWorks_20b1c1_1998_05_07:1.3
	MLWorks_20b0_1998_04_07:1.3
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_20m1_1997_10_23:1.3
	MLWorks_11r1:1.3.5.1.1.1.1
	MLWorks_workspace_97:1.3.7
	MLWorks_dt_wizard:1.3.6
	MLWorks_11c0_1997_09_09:1.3.5.1.1.1
	MLWorks_10r3:1.3.5.1.3
	MLWorks_10r2_551:1.3.5.1.2
	MLWorks_11:1.3.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.5.1
	MLWorks_20m0_1997_06_20:1.3
	MLWorks_1_0_r2c2_1997_06_14:1.3.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.3.5
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.3.3.1.1
	MLWorks_gui_1996_12_18:1.3.4
	MLWorks_1_0_Win32_1996_12_17:1.3.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.1.1
	MLWorks_1_0_Irix_1996_11_28:1.3.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.2
	MLWorks_1_0_Unix_1996_11_14:1.3.1
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ * @;


1.3
date	96.10.22.17.27.52;	author io;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1
	1.3.5.1
	1.3.6.1
	1.3.7.1
	1.3.8.1;
next	1.2;

1.2
date	96.05.24.01.19.17;	author brianm;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	95.09.10.22.30.37;	author brianm;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.11.51;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.16.02.34;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.20.49;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.11.14.12.44.32;	author hope;	state Exp;
branches
	1.3.1.1.1.1;
next	;

1.3.1.1.1.1
date	96.11.28.14.56.29;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.11.22.18.04.56;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.12.17.17.43.53;	author hope;	state Exp;
branches
	1.3.3.1.1.1;
next	;

1.3.3.1.1.1
date	97.02.24.11.33.08;	author hope;	state Exp;
branches;
next	;

1.3.4.1
date	96.12.18.09.37.51;	author hope;	state Exp;
branches;
next	;

1.3.5.1
date	97.05.12.10.30.07;	author hope;	state Exp;
branches
	1.3.5.1.1.1
	1.3.5.1.2.1
	1.3.5.1.3.1;
next	;

1.3.5.1.1.1
date	97.07.28.18.15.47;	author daveb;	state Exp;
branches
	1.3.5.1.1.1.1.1;
next	;

1.3.5.1.1.1.1.1
date	97.10.07.11.40.49;	author jkbrook;	state Exp;
branches;
next	;

1.3.5.1.2.1
date	97.09.08.17.09.20;	author daveb;	state Exp;
branches;
next	;

1.3.5.1.3.1
date	97.09.09.14.04.38;	author daveb;	state Exp;
branches;
next	;

1.3.6.1
date	97.09.10.19.18.57;	author brucem;	state Exp;
branches;
next	;

1.3.7.1
date	97.09.11.20.50.06;	author daveb;	state Exp;
branches;
next	;

1.3.8.1
date	99.04.01.17.53.44;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.3
log
@[Bug #1547]
current naming conventions
@
text
@(* ++++ Hello example ML FI interface code ++++ *)
(* ++++ ================================== ++++ *)

(* Opening the ML FI structures *)

use "open";

(* Loading a fStructure *)

   val hello_cset = loadObjectFile("/u/io/ml/3/MLW/src/foreign/hello.so",IMMEDIATE_LOAD);


(* Building a store *)

    val hello_store =
         store{ alloc    = ALIGNED_4,
                 overflow = BREAK,
                 size     = 60,
                 status   = RDWR_STATUS   };



(* Creating objects *)

   val void_object =
         object { ctype     = VOID_TYPE,
               store    = hello_store };

   val str_object =
         object { ctype     = STRING_TYPE{ length = 20 },
               store    = hello_store };

   val int_object1 =
         object { ctype     = INT_TYPE,
               store    = hello_store };

   val int_object2 =
         object { ctype     = INT_TYPE,
               store    = hello_store };

   val ptr_object =
         object { ctype     = ptrType(VOID_TYPE),
               store    = hello_store };



(* Initialising object values - these will be our arguments *)

   setString(str_object, "ML Forever!");
   setInt(int_object1, 23);



(* Examining object values *)

   getString(str_object);
   getInt(int_object1);


(* Defining a c_signature object *)

   val hello_cinfo = newSignature();


(* Adding a new fSignature entry *)

   defEntry(hello_cinfo,
             FUN_DECL { name = "hello",
                       source = ([ptrType(CHAR_TYPE), INT_TYPE] : c_type list),
                       target = (INT_TYPE) }
            );


(* Make a `callable object' lookup function for our foreign code *)

   val def_hello = defineForeignFun(hello_cset,hello_cinfo);


(* Extract a foreign function object as an ML value *) 

   val hello = def_hello "hello";;


(* Setting up string pointers ... *)

   setPtrType { ptr = ptr_object, data = str_object };
   setPtrAddrOf { ptr = ptr_object, data = str_object };
   castPtrType { ptr = ptr_object, ctype = CHAR_TYPE };


(* Call the foreign function *)

   call hello ([ptr_object,int_object1], int_object2);


(* Extracting the result data *)

   getInt(int_object2);
@


1.3.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@@


1.3.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.3.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@@


1.3.5.1
log
@branched from 1.3
@
text
@@


1.3.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.3.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.3.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.3.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.3.4.1
log
@branched from 1.3
@
text
@@


1.3.3.1
log
@branched from 1.3
@
text
@@


1.3.3.1.1.1
log
@branched from 1.3.3.1
@
text
@@


1.3.2.1
log
@branched from 1.3
@
text
@@


1.3.1.1
log
@branched from 1.3
@
text
@@


1.3.1.1.1.1
log
@branched from 1.3.1.1
@
text
@@


1.2
log
@Beta release modifications.
@
text
@a3 1

d6 1
a6 15

   open ForeignInterface;
   open Store;
   open Object;
   open Diagnostic;
   open LibML;
   open C;
   open Structure;
   open Type;
   open Value;
   open Signature;
   open Function;
   open Diagnostic;


d10 1
a10 2
   val hello_cset = load_object_file("./hello.so",IMMEDIATE_LOAD);

d49 2
a50 2
   set_string(str_object, "ML Forever!");
   set_int(int_object1, 23);
d56 2
a57 2
   get_string(str_object);
   get_int(int_object1);
d62 1
a62 1
   val hello_cinfo = new_signature();
d67 1
a67 1
   def_entry(hello_cinfo,
d69 2
a70 2
                       source = makeBox([ptrType(CHAR_TYPE), INT_TYPE] : c_type list),
                       target = makeBox(INT_TYPE) }
d76 1
a76 1
   val def_hello = define_foreign_fun(hello_cset,hello_cinfo);
d86 3
a88 3
   set_ptr_type { ptr = ptr_object, data = str_object };
   set_ptr_addr_of { ptr = ptr_object, data = str_object };
   cast_ptr_type { ptr = ptr_object, ctype = CHAR_TYPE };
d98 1
a98 1
   get_int(int_object2);
@


1.2.3.1
log
@branched from 1.2
@
text
@@


1.2.2.1
log
@branched from 1.2
@
text
@@


1.2.1.1
log
@branched from 1.2
@
text
@@


1.1
log
@new unit
New file.
@
text
@d9 2
a10 2
   open Hostel;
   open Pod;
d14 1
a14 1
   open CodeSet;
d17 1
a17 1
   open CodeInfo;
d23 1
a23 1
(* Loading a codeset *)
d25 1
a25 1
   val hello_cset = load_codeset("./hello.so",IMMEDIATE_LM);
d29 1
a29 1
(* Building a hostel *)
d31 3
a33 3
    val hello_hostel =
         hostel{ alloc    = ALIGNED_4_AP,
                 overflow = BREAK_OV,
d35 1
a35 1
                 status   = RDWR_HS   };
d39 1
a39 1
(* Creating pods *)
d41 3
a43 3
   val void_pod =
         pod { ctype     = VOID_CT,
               hostel    = hello_hostel };
d45 3
a47 3
   val str_pod =
         pod { ctype     = STRING_CT{ length = 20 },
               hostel    = hello_hostel };
d49 3
a51 3
   val int_pod1 =
         pod { ctype     = INT_CT,
               hostel    = hello_hostel };
d53 3
a55 3
   val int_pod2 =
         pod { ctype     = INT_CT,
               hostel    = hello_hostel };
d57 3
a59 3
   val ptr_pod =
         pod { ctype     = mk_star_t(VOID_CT),
               hostel    = hello_hostel };
d63 1
a63 1
(* Initialising pod values - these will be our arguments *)
d65 2
a66 2
   set_string(str_pod, "ML Forever!");
   set_int(int_pod1, 23);
d70 1
a70 1
(* Examining pod values *)
d72 2
a73 2
   get_string(str_pod);
   get_int(int_pod1);
d76 1
a76 1
(* Defining a c_codeinfo object *)
d78 1
a78 1
   val hello_cinfo = new_codeinfo();
d81 1
a81 1
(* Adding a new codeinfo entry *)
d84 3
a86 3
             CODE_DI { name = "hello",
                       source = makeBOX([mk_star_t(CHAR_CT), INT_CT] : c_type list),
                       target = makeBOX(INT_CT) }
d92 1
a92 1
   val def_hello = attach(hello_cset,hello_cinfo);
d102 3
a104 3
   set_ptr_type { ptr = ptr_pod, data = str_pod };
   set_ptr_addr_of { ptr = ptr_pod, data = str_pod };
   cast_ptr_type { ptr = ptr_pod, ctype = CHAR_CT };
d109 1
a109 1
   call hello ([ptr_pod,int_pod1], int_pod2);
d114 1
a114 1
   get_int(int_pod2);
@
