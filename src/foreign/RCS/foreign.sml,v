head	1.14;
access;
symbols
	MLW_daveb_inline_1_4_99:1.14.8
	MLWorks_21c0_1999_03_25:1.14
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.14
	MLWorks_20b2_Windows_1998_06_12:1.14
	MLWorks_20b1c1_1998_05_07:1.14
	MLWorks_20b0_1998_04_07:1.14
	MLWorks_20b0_1998_03_20:1.14
	MLWorks_20m2_1998_02_16:1.14
	MLWorks_20m1_1997_10_23:1.14
	MLWorks_11r1:1.14.5.1.1.1.1
	MLWorks_workspace_97:1.14.7
	MLWorks_dt_wizard:1.14.6
	MLWorks_11c0_1997_09_09:1.14.5.1.1.1
	MLWorks_10r3:1.14.5.1.3
	MLWorks_10r2_551:1.14.5.1.2
	MLWorks_11:1.14.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.14.5.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.14.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.14.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.14.5
	MLWorks_BugFix_1997_04_24:1.14
	MLWorks_1_0_r2_Win32_1997_04_11:1.14
	MLWorks_1_0_r2_Unix_1997_04_04:1.14
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.14.3.1.1
	MLWorks_gui_1996_12_18:1.14.4
	MLWorks_1_0_Win32_1996_12_17:1.14.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.14.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.14.1.1
	MLWorks_1_0_Irix_1996_11_28:1.14.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.14.2
	MLWorks_1_0_Unix_1996_11_14:1.14.1
	MLWorks_Open_Beta2_1996_10_11:1.13.2
	MLWorks_License_dev:1.13.1
	MLWorks_1_open_beta_1996_09_13:1.12.1
	MLWorks_Open_Beta_1996_08_22:1.12
	MLWorks_Beta_1996_07_02:1.11
	MLWorks_Beta_1996_06_07:1.11
	MLWorks_Beta_1996_06_06:1.11
	MLWorks_Beta_1996_06_05:1.11
	MLWorks_Beta_1996_06_03:1.11
	MLWorks_Beta_1996_05_31:1.11
	MLWorks_Beta_1996_05_30:1.11;
locks; strict;
comment	@ * @;


1.14
date	96.10.25.12.52.15;	author io;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1
	1.14.4.1
	1.14.5.1
	1.14.6.1
	1.14.7.1
	1.14.8.1;
next	1.13;

1.13
date	96.09.20.14.49.01;	author io;	state Exp;
branches
	1.13.1.1
	1.13.2.1;
next	1.12;

1.12
date	96.08.18.21.55.32;	author brianm;	state Exp;
branches
	1.12.1.1;
next	1.11;

1.11
date	96.05.24.01.19.17;	author brianm;	state Exp;
branches;
next	1.10;

1.10
date	96.04.18.17.00.01;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	96.03.28.14.21.12;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	96.03.20.15.26.27;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.09.10.18.42.18;	author brianm;	state Exp;
branches;
next	1.6;

1.6
date	95.09.07.22.43.45;	author brianm;	state Exp;
branches;
next	1.5;

1.5
date	95.07.20.17.01.31;	author brianm;	state Exp;
branches;
next	1.4;

1.4
date	95.07.18.12.29.23;	author brianm;	state Exp;
branches;
next	1.3;

1.3
date	95.07.07.11.09.18;	author brianm;	state Exp;
branches;
next	1.2;

1.2
date	95.06.25.18.35.31;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	95.05.29.18.06.34;	author brianm;	state Exp;
branches;
next	;

1.12.1.1
date	96.09.13.11.11.58;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	96.10.07.16.02.42;	author hope;	state Exp;
branches;
next	;

1.13.2.1
date	96.10.17.11.20.56;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	96.11.14.12.44.39;	author hope;	state Exp;
branches
	1.14.1.1.1.1;
next	;

1.14.1.1.1.1
date	96.11.28.14.56.36;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.11.22.18.05.04;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.12.17.17.44.00;	author hope;	state Exp;
branches
	1.14.3.1.1.1;
next	;

1.14.3.1.1.1
date	97.02.24.11.33.19;	author hope;	state Exp;
branches;
next	;

1.14.4.1
date	96.12.18.09.37.58;	author hope;	state Exp;
branches;
next	;

1.14.5.1
date	97.05.12.10.30.16;	author hope;	state Exp;
branches
	1.14.5.1.1.1
	1.14.5.1.2.1
	1.14.5.1.3.1;
next	;

1.14.5.1.1.1
date	97.07.28.18.16.28;	author daveb;	state Exp;
branches
	1.14.5.1.1.1.1.1;
next	;

1.14.5.1.1.1.1.1
date	97.10.07.11.41.22;	author jkbrook;	state Exp;
branches;
next	;

1.14.5.1.2.1
date	97.09.08.17.10.02;	author daveb;	state Exp;
branches;
next	;

1.14.5.1.3.1
date	97.09.09.14.05.30;	author daveb;	state Exp;
branches;
next	;

1.14.6.1
date	97.09.10.19.19.54;	author brucem;	state Exp;
branches;
next	;

1.14.7.1
date	97.09.11.20.51.06;	author daveb;	state Exp;
branches;
next	;

1.14.8.1
date	99.04.01.17.54.48;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Top level file defining the ForeignInterface.
@


1.14
log
@[Bug #1547]
current naming conventions
@
text
@(*  ==== FOREIGN INTERFACE : Top Level ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  The top-level of the Foreign Interface.  This contains common components:
 *     Utilities,  Store,  Aliens
 *  and specific interfaces
 *
 *  Revision Log
 *  ------------
 *  $Log: foreign.sml,v $
 * Revision 1.13  1996/09/20  14:49:01  io
 * [Bug #1603]
 * convert ByteArray to Internal.ByteArray
 *
 * Revision 1.12  1996/08/18  21:55:32  brianm
 * Adding pointer comparison functions ...
 *
 * Revision 1.11  1996/05/24  01:19:17  brianm
 * Beta release modifications.
 *
 * Revision 1.10  1996/04/18  17:00:01  jont
 * initbasis becomes basis
 *
 * Revision 1.9  1996/03/28  14:21:12  matthew
 * Sharing changes
 *
 * Revision 1.8  1996/03/20  15:26:27  matthew
 * Language changes -- no more open in signatures
 * /
 *
 * Revision 1.7  1995/09/10  18:42:18  brianm
 * Further modification for updates and general reorganisation.
 *
 *  Revision 1.6  1995/09/07  22:43:45  brianm
 *  Modifications for reorganisation & documentation.
 *
 *  Revision 1.5  1995/07/20  17:01:31  brianm
 *  adding new_object.
 *
 *  Revision 1.4  1995/07/18  12:29:23  brianm
 *  Changing names of deferred data-type operators (stream-edit)
 *
 *  Revision 1.3  1995/07/07  11:09:18  brianm
 *  Adding external value support - LIB-ML.
 *
 *  Revision 1.2  1995/06/25  18:35:31  brianm
 *  Adding remote access, diagnostics and other facilities.
 *
 *  Revision 1.1  1995/05/29  18:06:34  brianm
 *  new unit
 *  Top level file defining the ForeignInterface.
 *
 *
 *)

require "^.basis.__word32";
require "^.basis.__word8";

signature FOREIGN_INTERFACE =
   sig

      type 'a option = 'a option

      type word32    = Word32.word
      type address   = word32
      type bytearray = MLWorks.Internal.ByteArray.bytearray
      type name      = string
      type filename  = string

      structure Store :
      sig

	 type store

	 exception ReadOnly
	 exception WriteOnly

	 datatype store_status = LOCKED_STATUS | RD_STATUS | WR_STATUS | RDWR_STATUS 

	 val storeStatus     : store -> store_status
	 val setStoreStatus : (store * store_status) -> unit

	 datatype alloc_policy = ORIGIN | SUCC | ALIGNED_4 | ALIGNED_8

         datatype overflow_policy = BREAK | EXTEND | RECYCLE

	 val store : { alloc    : alloc_policy,
		       overflow : overflow_policy,
		       status   : store_status,
		       size     : int } -> store

	 val storeSize     : store -> int
	 val storeAlloc    : store -> alloc_policy
	 val storeOverflow : store -> overflow_policy

	 exception ExpandStore

	 val isStandardStore  : store -> bool
	 val isEphemeralStore : store -> bool

	 val expand  : (store * int) -> unit
      end

      structure Object :
      sig
         type ('a) object

	 datatype object_mode = LOCAL_OBJECT | REMOTE_OBJECT
	 datatype object_status = PERMANENT_OBJECT | TEMPORARY_OBJECT

	 exception OutOfBounds
	 exception ReadOnly
	 exception WriteOnly
	 exception Currency

	 val objectStatus       : ('l_type) object -> object_status
	 val objectCurrency     : ('l_type) object -> bool
	 val objectMode         : ('l_type) object -> object_mode
	 val objectSize         : ('l_type) object -> int
	 val objectLocation     : ('l_type) object -> int
	 val objectAddress      : ('l_type) object -> address
      end;
      
      structure Aliens :
      sig

	 val ensureAliens  : unit -> unit
	 val resetAliens   : unit -> unit
	 val refreshAliens : unit -> unit

      end

      structure LibML :
      sig

	val registerExternalValue   :  string * 'a -> unit
	val   deleteExternalValue   :  string -> unit

	val         externalValues   :  unit -> string list
	val   clearExternalValues   :  unit -> unit

      end

      structure C :
      sig

	 (* C STRUCTURE *)
	 structure Structure :
	 sig

	    type c_structure

	    datatype load_mode = IMMEDIATE_LOAD | DEFERRED_LOAD

	    val loadObjectFile : filename * load_mode -> c_structure
	    val fileInfo : c_structure -> (filename * load_mode)

	    val filesLoaded : unit -> filename list
	    val symbols      : c_structure -> name list

	    datatype value_type = CODE_VALUE | VAR_VALUE | UNKNOWN_VALUE

	    val symbolInfo : c_structure * name -> value_type

	 end

	 (* C TYPE *)
	 structure Type :
	 sig

	    (* C TYPE INFORMATION *)

	    (* Pointer information may be interpreted in the following ways:
	       - LOCAL_PTR     = Machine address pointing within the associated store
	       - REMOTE_PTR    = Machine address pointing outside associated store
	       - RELATIVE_PTR  = Index value accessing location within associated store
	     *)
	    datatype pointer_kind = LOCAL_PTR | RELATIVE_PTR | REMOTE_PTR

	    (* The ML type c_type provides a representation of a C type descriptor
	       as an ML value.
	     *)
	    datatype c_type =
	       VOID_TYPE
	    |
	       CHAR_TYPE           | UNSIGNED_CHAR_TYPE | SIGNED_CHAR_TYPE
	    |
	       SHORT_TYPE          | INT_TYPE           | LONG_TYPE
	    |
	       UNSIGNED_SHORT_TYPE | UNSIGNED_INT_TYPE  | UNSIGNED_LONG_TYPE
	    |
	       FLOAT_TYPE          | DOUBLE_TYPE        | LONG_DOUBLE_TYPE
	    |
	       STRING_TYPE   of { length : int }
	    |
	       TYPENAME      of { name : name,
				  size : int option }
	    |
	       FUNCTION_TYPE of { source : c_type list,
				  target : c_type
				}
	    |
	       POINTER_TYPE  of { ctype : c_type, mode : pointer_kind }
	    |
	       STRUCT_TYPE   of { tag    : name option,
				  fields : c_field list,
				  size   : int option }
	    |
	       UNION_TYPE    of { tag      : name option,
				  variants : c_variant list,
				  size     : int option,
				  current  : c_variant }
	    |
	       ARRAY_TYPE    of { length : int, ctype : c_type, size : int option }
	    |
	       ENUM_TYPE     of { tag   : name option,
				  elems : name list,
				  card  : int }

	    and  c_variant = VARIANT of { name  : name,
				          ctype : c_type,
				          size  : int option }

	    and  c_field   = FIELD of { name    : name,
				        ctype   : c_type,
				        size    : int option,
				        padding : int,
				        offset  : int option }

            exception UnknownTypeName of string

	    val sizeOf      : c_type -> int

	    val equalType   : c_type * c_type -> bool

	    val structType   : string * (string * c_type) list -> c_type
	    val unionType    : string * (string * c_type) list -> c_type
	    val ptrType      : c_type -> c_type
	    val typeName     : string -> c_type
	    val enumType     : string * string list -> c_type

	 end


	 (* C VALUE STRUCTURE *)
	 structure Value :
	 sig

            type store         = Store.store
            type object_mode   = Object.object_mode
            type c_type        = Type.c_type

	    type c_object

	    val object : { ctype  : c_type,
			   store  : store } -> c_object

            val setObjectMode   :  c_object * object_mode -> unit

	    val objectType       :  c_object -> c_type
	    val castObjectType  :  c_object * c_type -> unit

	    val newObject  : c_object -> c_object
	    val dupObject  : c_object -> c_object
	    val tmpObject  : c_object -> c_object

	    type c_char

	    type c_short_int
	    type c_int
	    type c_long_int

	    type c_real
	    type c_double
	    type c_long_double

	    exception ForeignType
	    exception StoreAccess

	    val setChar           : c_object * c_char -> unit
	    val setUnsignedChar  : c_object * c_char -> unit
	    val setSignedChar    : c_object * c_char -> unit

	    val setShort          : c_object * c_short_int -> unit
	    val setInt            : c_object * c_int -> unit
	    val setLong           : c_object * c_long_int -> unit

	    val setUnsignedShort : c_object * c_short_int -> unit
	    val setUnsigned       : c_object * c_int -> unit
	    val setUnsignedLong  : c_object * c_long_int -> unit

	    val setWord32         : c_object * word32 -> unit

	    val setFloat          : c_object * c_real -> unit
	    val setDouble         : c_object * c_double -> unit
	    val setLongDouble    : c_object * c_long_double -> unit

	    val setString         : c_object * string -> unit

	    val setAddr           : { obj:c_object, addr:c_object } -> unit

	    val setPtrAddr       : { ptr:c_object, addr:c_object   } -> unit
	    val setPtrAddrOf    : { ptr:c_object, data:c_object   } -> unit
            val setPtrData       : { ptr:c_object, data:c_object   } -> unit
            val setPtrType       : { ptr:c_object, data:c_object   } -> unit
            val castPtrType      : { ptr:c_object, ctype:c_type } -> unit

	    val setLocalPtr      : c_object -> unit
	    val setRelativePtr   : c_object -> unit
	    val setRemotePtr     : c_object -> unit

            val isEqPtr          : c_object * c_object -> bool
            val isNullPtr        : c_object -> bool

	    val setStruct  : c_object * (c_object list) -> unit
            val setField   : { record:c_object, field:name, data:c_object } -> unit

	    val setMember  : { union:c_object, member:name } -> unit
	    val setUnion   : { union:c_object, data:c_object } -> unit

	    val setArray   : c_object * (c_object list) * int -> unit
	    val setEnum    : c_object * int -> unit


	    (* Selectors ... *)

	    val indexObject   : { array:c_object,  tgt:c_object, index:int } -> unit
	    val derefObject   : { ptr:c_object,    tgt:c_object } -> unit
	    val selectObject  : { record:c_object, tgt:c_object, field:name } -> unit
	    val coerceObject  : { union:c_object,  tgt:c_object } -> unit

	    val copyIndexObject     : c_object * int -> c_object
	    val copyDerefObject     : c_object -> c_object
	    val copySelectObject    : c_object * name -> c_object
	    val copyCoerceObject    : c_object -> c_object

	    val indexObjectType     : c_object -> c_type
	    val derefObjectType     : c_object -> c_type
	    val selectObjectType    : c_object * name -> c_type
	    val coerceObjectType    : c_object -> c_type 

	    val indexObjectSize     : c_object -> int
	    val derefObjectSize     : c_object -> int
	    val selectObjectSize    : c_object * name -> int
	    val coerceObjectSize    : c_object -> int

	    val nextArrayItem       : c_object -> unit
	    val prevArrayItem       : c_object -> unit

	    (* Getters ... *)

	    val getChar           : c_object -> c_char
	    val getUnsignedChar  : c_object -> c_char
	    val getSignedChar    : c_object -> c_char

	    val getShort          : c_object -> c_short_int
	    val getInt            : c_object -> c_int
	    val getLong           : c_object -> c_long_int

	    val getUnsignedShort : c_object -> c_short_int
	    val getUnsigned       : c_object -> c_int
	    val getUnsignedLong  : c_object -> c_long_int

	    val getWord32         : c_object -> word32

	    val getFloat          : c_object -> c_real
	    val getDouble         : c_object -> c_double
	    val getLongDouble    : c_object -> c_long_double

	    val getString         : c_object -> string

	    val getData           : c_object -> c_object
	    (* dereference pointer *)

	    val getStruct         : c_object -> c_object list
	    (* field components of a structure *)

	    val getField          : c_object * name -> c_object
	    (* field of a structure *)

	    val getUnion          : c_object -> c_object
	    val getArray          : c_object -> c_object list

	    val getEnum           : c_object -> int
	 end


	 (* C Signature *)
	 structure Signature :
	 sig
            type c_type = Type.c_type
	    type c_signature

	    datatype c_decl =
		UNDEF_DECL
	    |
		VAR_DECL of { name : name, ctype : c_type }
	    |
		FUN_DECL of { name   : name,
			      source : c_type list,
			      target : c_type }
	    |
		TYPE_DECL of { name : name,
			       defn : c_type,
			       size : int }
	    |
		CONST_DECL of { name : name, ctype : c_type }

	    val newSignature      : unit -> c_signature

	    val lookupEntry   : c_signature -> name -> c_decl
	    val defEntry      : c_signature * c_decl -> unit
	    val removeEntry   : c_signature * name -> unit

	    val showEntries   : c_signature -> c_decl list

	    val normaliseType : c_signature -> c_type -> c_type

	    val loadHeader : filename -> c_signature
	 end

	 (* C FUNCTION *)
	 structure Function :
	 sig
 
            type c_type = Type.c_type
            type c_object = Value.c_object
            type c_structure = Structure.c_structure
            type c_signature = Signature.c_signature

	    type c_function

	    val defineForeignFun : (c_structure * c_signature) -> name -> c_function

	    val call   : c_function -> (c_object list * c_object) -> unit
	 end

         structure Diagnostic :
         sig

            type store     = Store.store
            type c_type    = Type.c_type
            type c_object  = Value.c_object

	    val cTypeInfo : c_type -> string

            val viewObject : c_object -> string
            val dispObject : c_object -> c_object

	    val objectInfo : c_object ->
		       { store     : store,
			 status    : string,
			 currency  : string,
			 mode      : string,
			 langtype  : string,
			 size      : int,
			 base      : address option,
			 offset    : int
		       }

	    val objectData         : c_object -> int list
	    val objectDataHex     : c_object -> string
	    val objectDataAscii   : c_object -> string
         end
      end (* C_INTERFACE *)

      structure Diagnostic :
      sig
        type store = Store.store

        val viewStore : store -> string
        val dispStore : store -> store

        val storeInfo : store ->
	       { kind     : string,
		 origin   : address,
		 status   : string,
		 alloc    : string,
		 overflow : string,
		 size     : int,
		 top      : int,
		 free     : int }

        val storeData :
            { store : store,
              start  : int,
              length : int } -> int list

        val storeDataHex :
            { store : store,
              start  : int,
              length : int } -> string

        val storeDataAscii :
            { store : store,
              start  : int,
              length : int } -> string

        val diffAddr : address -> address -> int
        val incrAddr : address * int -> address
      end
   end; (* signature FOREIGN_INTERFACE *)
@


1.14.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a13 4
 * Revision 1.14  1996/10/25  12:52:15  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.14.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 4
 * Revision 1.14  1996/10/25  12:52:15  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.14.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 4
 * Revision 1.14  1996/10/25  12:52:15  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.14.5.1
log
@branched from 1.14
@
text
@a13 4
 * Revision 1.14  1996/10/25  12:52:15  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.14.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.14.5.1  1997/05/12  10:30:16  hope
 * branched from 1.14
 *
@


1.14.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.14.5.1  1997/05/12  10:30:16  hope
 * branched from 1.14
 *
@


1.14.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.14.5.1  1997/05/12  10:30:16  hope
 * branched from 1.14
 *
@


1.14.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.14.5.1.1.1  1997/07/28  18:16:28  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.14.4.1
log
@branched from 1.14
@
text
@a13 4
 * Revision 1.14  1996/10/25  12:52:15  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.14.3.1
log
@branched from 1.14
@
text
@a13 4
 * Revision 1.14  1996/10/25  12:52:15  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.14.3.1.1.1
log
@branched from 1.14.3.1
@
text
@a13 3
 * Revision 1.14.3.1  1996/12/17  17:44:00  hope
 * branched from 1.14
 *
@


1.14.2.1
log
@branched from 1.14
@
text
@a13 4
 * Revision 1.14  1996/10/25  12:52:15  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.14.1.1
log
@branched from 1.14
@
text
@a13 4
 * Revision 1.14  1996/10/25  12:52:15  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.14.1.1.1.1
log
@branched from 1.14.1.1
@
text
@a13 3
 * Revision 1.14.1.1  1996/11/14  12:44:39  hope
 * branched from 1.14
 *
@


1.13
log
@[Bug #1603]
convert ByteArray to Internal.ByteArray
@
text
@d14 4
d59 2
a60 4
require "../basis/__general";
require "../basis/__word32";
require "../basis/__word8";

d65 1
a65 1
      type 'a option = 'a General.option
d83 2
a84 2
	 val store_status     : store -> store_status
	 val set_store_status : (store * store_status) -> unit
d95 3
a97 3
	 val store_size     : store -> int
	 val store_alloc    : store -> alloc_policy
	 val store_overflow : store -> overflow_policy
d101 2
a102 2
	 val is_standard_store  : store -> bool
	 val is_ephemeral_store : store -> bool
d119 6
a124 6
	 val object_status       : ('l_type) object -> object_status
	 val object_currency     : ('l_type) object -> bool
	 val object_mode         : ('l_type) object -> object_mode
	 val object_size         : ('l_type) object -> int
	 val object_location     : ('l_type) object -> int
	 val object_address      : ('l_type) object -> address
d130 3
a132 3
	 val ensure_aliens  : unit -> unit
	 val reset_aliens   : unit -> unit
	 val refresh_aliens : unit -> unit
d139 2
a140 2
	val register_external_value   :  string * 'a -> unit
	val   delete_external_value   :  string -> unit
d142 2
a143 2
	val         external_values   :  unit -> string list
	val   clear_external_values   :  unit -> unit
d158 2
a159 2
	    val load_object_file : filename * load_mode -> c_structure
	    val file_info : c_structure -> (filename * load_mode)
d161 1
a161 1
	    val files_loaded : unit -> filename list
d166 1
a166 1
	    val symbol_info : c_structure * name -> value_type
d235 1
a235 1
	    val size_of      : c_type -> int
d237 1
a237 1
	    val equal_type   : c_type * c_type -> bool
d261 1
a261 1
            val set_object_mode   :  c_object * object_mode -> unit
d263 2
a264 2
	    val object_type       :  c_object -> c_type
	    val cast_object_type  :  c_object * c_type -> unit
d266 3
a268 3
	    val new_object  : c_object -> c_object
	    val dup_object  : c_object -> c_object
	    val tmp_object  : c_object -> c_object
d283 3
a285 3
	    val set_char           : c_object * c_char -> unit
	    val set_unsigned_char  : c_object * c_char -> unit
	    val set_signed_char    : c_object * c_char -> unit
d287 3
a289 3
	    val set_short          : c_object * c_short_int -> unit
	    val set_int            : c_object * c_int -> unit
	    val set_long           : c_object * c_long_int -> unit
d291 3
a293 3
	    val set_unsigned_short : c_object * c_short_int -> unit
	    val set_unsigned       : c_object * c_int -> unit
	    val set_unsigned_long  : c_object * c_long_int -> unit
d295 1
a295 1
	    val set_word32         : c_object * word32 -> unit
d297 3
a299 3
	    val set_float          : c_object * c_real -> unit
	    val set_double         : c_object * c_double -> unit
	    val set_long_double    : c_object * c_long_double -> unit
d301 1
a301 1
	    val set_string         : c_object * string -> unit
d303 1
a303 1
	    val set_addr           : { obj:c_object, addr:c_object } -> unit
d305 5
a309 5
	    val set_ptr_addr       : { ptr:c_object, addr:c_object   } -> unit
	    val set_ptr_addr_of    : { ptr:c_object, data:c_object   } -> unit
            val set_ptr_data       : { ptr:c_object, data:c_object   } -> unit
            val set_ptr_type       : { ptr:c_object, data:c_object   } -> unit
            val cast_ptr_type      : { ptr:c_object, ctype:c_type } -> unit
d311 3
a313 3
	    val set_local_ptr      : c_object -> unit
	    val set_relative_ptr   : c_object -> unit
	    val set_remote_ptr     : c_object -> unit
d315 2
a316 2
            val is_eq_ptr          : c_object * c_object -> bool
            val is_null_ptr        : c_object -> bool
d318 2
a319 2
	    val set_struct  : c_object * (c_object list) -> unit
            val set_field   : { record:c_object, field:name, data:c_object } -> unit
d321 2
a322 2
	    val set_member  : { union:c_object, member:name } -> unit
	    val set_union   : { union:c_object, data:c_object } -> unit
d324 2
a325 2
	    val set_array   : c_object * (c_object list) * int -> unit
	    val set_enum    : c_object * int -> unit
d330 19
a348 19
	    val index_object   : { array:c_object,  tgt:c_object, index:int } -> unit
	    val deref_object   : { ptr:c_object,    tgt:c_object } -> unit
	    val select_object  : { record:c_object, tgt:c_object, field:name } -> unit
	    val coerce_object  : { union:c_object,  tgt:c_object } -> unit

	    val copy_index_object     : c_object * int -> c_object
	    val copy_deref_object     : c_object -> c_object
	    val copy_select_object    : c_object * name -> c_object
	    val copy_coerce_object    : c_object -> c_object

	    val index_object_type     : c_object -> c_type
	    val deref_object_type     : c_object -> c_type
	    val select_object_type    : c_object * name -> c_type
	    val coerce_object_type    : c_object -> c_type 

	    val index_object_size     : c_object -> int
	    val deref_object_size     : c_object -> int
	    val select_object_size    : c_object * name -> int
	    val coerce_object_size    : c_object -> int
d350 2
a351 2
	    val next_array_item        : c_object -> unit
	    val prev_array_item         : c_object -> unit
d355 3
a357 3
	    val get_char           : c_object -> c_char
	    val get_unsigned_char  : c_object -> c_char
	    val get_signed_char    : c_object -> c_char
d359 3
a361 3
	    val get_short          : c_object -> c_short_int
	    val get_int            : c_object -> c_int
	    val get_long           : c_object -> c_long_int
d363 3
a365 3
	    val get_unsigned_short : c_object -> c_short_int
	    val get_unsigned       : c_object -> c_int
	    val get_unsigned_long  : c_object -> c_long_int
d367 1
a367 1
	    val get_word32         : c_object -> word32
d369 3
a371 3
	    val get_float          : c_object -> c_real
	    val get_double         : c_object -> c_double
	    val get_long_double    : c_object -> c_long_double
d373 1
a373 1
	    val get_string         : c_object -> string
d375 2
a376 2
	    val get_data           : c_object -> c_object
		(* dereference pointer *)
d378 2
a379 2
	    val get_struct         : c_object -> c_object list
		(* field components of a structure *)
d381 2
a382 2
	    val get_field          : c_object * name -> c_object
		(* field of a structure *)
d384 2
a385 2
	    val get_union          : c_object -> c_object
	    val get_array          : c_object -> c_object list
d387 1
a387 1
	    val get_enum           : c_object -> int
d412 1
a412 1
	    val new_signature      : unit -> c_signature
d414 3
a416 3
	    val lookup_entry   : c_signature -> name -> c_decl
	    val def_entry      : c_signature * c_decl -> unit
	    val remove_entry   : c_signature * name -> unit
d418 1
a418 1
	    val show_entries   : c_signature -> c_decl list
d420 1
a420 1
	    val normalise_type : c_signature -> c_type -> c_type
d422 1
a422 1
	    val load_header : filename -> c_signature
d436 1
a436 1
	    val define_foreign_fun : (c_structure * c_signature) -> name -> c_function
d448 1
a448 1
	    val c_type_info : c_type -> string
d450 2
a451 2
            val view_object : c_object -> string
            val disp_object : c_object -> c_object
d453 1
a453 1
	    val object_info : c_object ->
d464 3
a466 3
	    val object_data         : c_object -> int list
	    val object_data_hex     : c_object -> string
	    val object_data_ascii   : c_object -> string
d474 2
a475 2
        val view_store : store -> string
        val disp_store : store -> store
d477 1
a477 1
        val store_info : store ->
d487 1
a487 1
        val store_data :
d492 1
a492 1
        val store_data_hex :
d497 1
a497 1
        val store_data_ascii :
d502 2
a503 2
        val diff_addr : address -> address -> int
        val incr_addr : address * int -> address
@


1.13.2.1
log
@branched from 1.13
@
text
@a13 4
 * Revision 1.13  1996/09/20  14:49:01  io
 * [Bug #1603]
 * convert ByteArray to Internal.ByteArray
 *
@


1.13.1.1
log
@branched from 1.13
@
text
@a13 4
 * Revision 1.13  1996/09/20  14:49:01  io
 * [Bug #1603]
 * convert ByteArray to Internal.ByteArray
 *
@


1.12
log
@Adding pointer comparison functions ...
@
text
@d14 3
d67 1
a67 1
      type bytearray = MLWorks.ByteArray.bytearray
@


1.12.1.1
log
@branched from 1.12
@
text
@a13 3
 * Revision 1.12  1996/08/18  21:55:32  brianm
 * Adding pointer comparison functions ...
 *
@


1.11
log
@Beta release modifications.
@
text
@d14 3
d296 3
a298 1
	    val set_string      : c_object * string -> unit
d300 9
a308 1
	    val set_addr        : { obj:c_object, addr:c_object } -> unit
d310 2
a311 9
	    val set_ptr_addr    : { ptr:c_object, addr:c_object   } -> unit
	    val set_ptr_addr_of : { ptr:c_object, data:c_object   } -> unit
            val set_ptr_data    : { ptr:c_object, data:c_object   } -> unit
            val set_ptr_type    : { ptr:c_object, data:c_object   } -> unit
            val cast_ptr_type   : { ptr:c_object, ctype:c_type } -> unit

	    val set_local_ptr     : c_object -> unit
	    val set_relative_ptr  : c_object -> unit
	    val set_remote_ptr    : c_object -> unit
@


1.10
log
@initbasis becomes basis
@
text
@d8 1
a8 1
 *     Utilities,  Hostel,  Aliens
d14 3
d31 1
a31 1
 *  adding new_pod.
d59 5
a63 19
      structure Utilities :
      sig

	 type word32 = Word32.word

	 type address = word32

	 type bytearray = MLWorks.ByteArray.bytearray

	 type name = string

	 type filename = string


	 (* DEFERRED ELEMENTS *)

	 datatype 'a box = BOX of ('a option ref)

	 (* Operations for box values *)
d65 1
a65 17
	 val someBOX    :  'a box -> bool

	 val getBOX     :  'a box -> 'a
	 val setBOX     :  'a box -> 'a -> unit

	 val extractBOX :  'a box -> 'a option
	 val updateBOX  :  'a box -> 'a option -> unit

	 val resetBOX   :  'a box -> unit

	 val makeBOX    :  '_a -> '_a box
	 val newBOX     :  '_a box -> '_a box

	 val voidBOX    :  unit -> '_a box
      end

      structure Hostel :
d68 1
a68 1
	 type hostel
d73 1
a73 1
	 datatype hostel_status = LOCKED_HS | RD_HS | WR_HS | RDWR_HS 
d75 2
a76 2
	 val hostel_status     : hostel -> hostel_status
	 val set_hostel_status : (hostel * hostel_status) -> unit
d78 1
a78 1
	 datatype alloc_policy = ORIGIN_AP | SUCC_AP | ALIGNED_4_AP | ALIGNED_8_AP
d80 1
a80 1
         datatype overflow_policy = BREAK_OV | EXTEND_OV | RECYCLE_OV
d82 4
a85 4
	 val hostel : { alloc    : alloc_policy,
			overflow : overflow_policy,
			status   : hostel_status,
			size     : int } -> hostel
d87 3
a89 3
	 val hostel_size     : hostel -> int
	 val hostel_alloc    : hostel -> alloc_policy
	 val hostel_overflow : hostel -> overflow_policy
d91 1
a91 1
	 exception ExpandHostel
d93 2
a94 2
	 val is_standard_hostel  : hostel -> bool
	 val is_ephemeral_hostel : hostel -> bool
d96 1
a96 1
	 val expand  : (hostel * int) -> unit
d99 1
a99 1
      structure Pod :
d101 1
a101 1
         type ('a)pod
d103 2
a104 2
	 datatype pod_mode = LOCAL_PM | REMOTE_PM
	 datatype pod_status = PERMANENT_PS | TEMPORARY_PS
d111 8
a118 13
	 val pod_status       : ('l_type) pod -> pod_status

	 val pod_currency     : ('l_type) pod -> bool

	 val pod_mode         : ('l_type) pod -> pod_mode

	 val pod_size         : ('l_type) pod -> int

	 val pod_location     : ('l_type) pod -> int

	 val pod_address      : ('l_type) pod -> Utilities.address
      end

d121 1
a122 1

a123 1

a138 1

d142 2
a143 2
	 (* C STRUCT *)
	 structure CodeSet :
a144 1
	    type c_codeset
d146 3
a148 1
	    datatype load_mode = IMMEDIATE_LM | DEFERRED_LM
d150 2
a151 2
	    val load_codeset : Utilities.filename * load_mode -> c_codeset
	    val file_info : c_codeset -> (Utilities.filename * load_mode)
d153 2
a154 2
	    val files_loaded : unit -> Utilities.filename list
	    val symbols      : c_codeset -> Utilities.name list
d156 3
a158 1
	    datatype value_type = CODE_VT | VAR_VT | UNKNOWN_VT
a159 1
	    val symbol_info : c_codeset * Utilities.name -> value_type
a164 2
	    type enum_value = string
	    type tag = string 
d169 3
a171 3
	       - LOCAL_PK     = Machine address pointing within the associated hostel
	       - REMOTE_PK    = Machine address pointing outside associated hostel
	       - RELATIVE_PK  = Index value accessing location within associated hostel
d173 1
a173 1
	    datatype pointer_kind = LOCAL_PK | RELATIVE_PK | REMOTE_PK
d179 1
a179 1
	       SIZE_OF of { size : int Utilities.box, ctype : c_type }
d181 1
a181 1
	       VOID_CT
d183 1
a183 1
	       CHAR_CT           | UNSIGNED_CHAR_CT | SIGNED_CHAR_CT
d185 1
a185 1
	       SHORT_CT          | INT_CT           | LONG_CT
d187 1
a187 1
	       UNSIGNED_SHORT_CT | UNSIGNED_INT_CT  | UNSIGNED_LONG_CT
d189 1
a189 1
	       FLOAT_CT          | DOUBLE_CT        | LONG_DOUBLE_CT
d191 2
a192 1
	       STRING_CT   of { length : int }
d194 3
a196 3
	       TYPENAME_CT of { name : Utilities.name,
			        defn : c_type Utilities.box,
			        size : int Utilities.box }
d198 1
a198 1
	       STAR_CT     of { ctype : c_type, mode : pointer_kind ref }
d200 3
a202 3
	       STRUCT_CT   of { tag    : tag option,
			        fields : c_field list,
			        size   : int Utilities.box }
d204 4
a207 4
	       UNION_CT    of { tag      : tag option,
			        variants : c_variant list ref,
			        size     : int Utilities.box,
			        current  : c_variant Utilities.box }
d209 1
a209 1
	       ARRAY_CT    of { length : int, ctype : c_type }
d211 3
a213 8
	       ENUM_CT     of { tag   : tag option,
 			        elems : enum_value list,
			        card  : int Utilities.box
			     }

	    and  c_variant = CVNT of { name  : Utilities.name,
				       ctype : c_type,
				       size  : int Utilities.box }
d215 3
a217 5
	    and  c_field   = CFLD of { name    : Utilities.name,
				       ctype   : c_type,
				       size    : int Utilities.box,
				       padding : int Utilities.box,
				       offset  : int Utilities.box }
d219 5
a223 1
	    val size_of : c_type -> int
d225 1
a225 1
	    val equal_type : c_type * c_type -> bool
d227 1
a227 1
            val dup_type : c_type -> c_type
d229 1
d231 5
a235 7
            (* convenience interface functions *)

	    val mk_struct_t   : string * (string * c_type) list -> c_type
	    val mk_union_t    : string * (string * c_type) list -> c_type
	    val mk_star_t     : c_type -> c_type
	    val mk_typename   : string -> c_type
	    val mk_enum_t     : string * string list -> c_type
d244 3
a246 3
            type hostel = Hostel.hostel

            type pod_mode = Pod.pod_mode
d248 1
a248 1
            type c_type = Type.c_type
d250 2
a251 1
	    type c_pod
d253 1
a253 2
	    val pod : { ctype    : c_type,
			hostel   : hostel } -> c_pod
d255 2
a256 1
            val set_pod_mode   :  c_pod * pod_mode -> unit
d258 3
a260 6
	    val pod_type       :  c_pod -> c_type
	    val cast_pod_type  :  c_pod * c_type -> unit

	    val dup_pod     : c_pod -> c_pod
	    val new_pod     : c_pod -> c_pod
	    val tmp_pod     : c_pod -> c_pod
d275 3
a277 3
	    val set_char           : c_pod * c_char -> unit
	    val set_unsigned_char  : c_pod * c_char -> unit
	    val set_signed_char    : c_pod * c_char -> unit
d279 3
a281 3
	    val set_short          : c_pod * c_short_int -> unit
	    val set_int            : c_pod * c_int -> unit
	    val set_long           : c_pod * c_long_int -> unit
d283 3
a285 3
	    val set_unsigned_short : c_pod * c_short_int -> unit
	    val set_unsigned       : c_pod * c_int -> unit
	    val set_unsigned_long  : c_pod * c_long_int -> unit
d287 1
a287 1
	    val set_word32         : c_pod * Utilities.word32 -> unit
d289 3
a291 3
	    val set_float          : c_pod * c_real -> unit
	    val set_double         : c_pod * c_double -> unit
	    val set_long_double    : c_pod * c_long_double -> unit
d293 1
a293 1
	    val set_string      : c_pod * string -> unit
d295 1
a295 1
	    val set_addr        : { obj:c_pod, addr:c_pod } -> unit
d297 5
a301 5
	    val set_ptr_addr    : { ptr:c_pod, addr:c_pod   } -> unit
	    val set_ptr_addr_of : { ptr:c_pod, data:c_pod   } -> unit
            val set_ptr_data    : { ptr:c_pod, data:c_pod   } -> unit
            val set_ptr_type    : { ptr:c_pod, data:c_pod   } -> unit
            val cast_ptr_type   : { ptr:c_pod, ctype:c_type } -> unit
d303 3
a305 3
	    val set_local_ptr     : c_pod -> unit
	    val set_relative_ptr  : c_pod -> unit
	    val set_remote_ptr    : c_pod -> unit
d307 2
a308 2
	    val set_struct  : c_pod * (c_pod list) -> unit
            val set_field   : { record:c_pod, field:Utilities.name, data:c_pod } -> unit
d310 2
a311 2
	    val set_member  : { union:c_pod, member:Utilities.name } -> unit
	    val set_union   : { union:c_pod, data:c_pod } -> unit
d313 2
a314 2
	    val set_array   : c_pod * (c_pod list) * int -> unit
	    val set_enum    : c_pod * int -> unit
d319 19
a337 19
	    val index_pod   : { array:c_pod,  tgt:c_pod, index:int } -> unit
	    val deref_pod   : { ptr:c_pod,    tgt:c_pod } -> unit
	    val select_pod  : { record:c_pod, tgt:c_pod, field:Utilities.name } -> unit
	    val coerce_pod  : { union:c_pod,  tgt:c_pod } -> unit

	    val copy_index_pod     : c_pod * int -> c_pod
	    val copy_deref_pod     : c_pod -> c_pod
	    val copy_select_pod    : c_pod * Utilities.name -> c_pod
	    val copy_coerce_pod    : c_pod -> c_pod

	    val index_pod_type     : c_pod -> c_type
	    val deref_pod_type     : c_pod -> c_type
	    val select_pod_type    : c_pod * Utilities.name -> c_type
	    val coerce_pod_type    : c_pod -> c_type 

	    val index_pod_size     : c_pod -> int
	    val deref_pod_size     : c_pod -> int
	    val select_pod_size    : c_pod * Utilities.name -> int
	    val coerce_pod_size    : c_pod -> int
d339 2
a340 2
	    val advance_pod        : c_pod -> unit
	    val retard_pod         : c_pod -> unit
d344 3
a346 3
	    val get_char           : c_pod -> c_char
	    val get_unsigned_char  : c_pod -> c_char
	    val get_signed_char    : c_pod -> c_char
d348 3
a350 3
	    val get_short          : c_pod -> c_short_int
	    val get_int            : c_pod -> c_int
	    val get_long           : c_pod -> c_long_int
d352 3
a354 3
	    val get_unsigned_short : c_pod -> c_short_int
	    val get_unsigned       : c_pod -> c_int
	    val get_unsigned_long  : c_pod -> c_long_int
d356 1
a356 1
	    val get_word32         : c_pod -> Utilities.word32
d358 3
a360 3
	    val get_float          : c_pod -> c_real
	    val get_double         : c_pod -> c_double
	    val get_long_double    : c_pod -> c_long_double
d362 1
a362 1
	    val get_string         : c_pod -> string
d364 1
a364 1
	    val get_data           : c_pod -> c_pod
d367 1
a367 1
	    val get_struct         : c_pod -> c_pod list
d370 1
a370 1
	    val get_field          : c_pod * Utilities.name -> c_pod
d373 2
a374 2
	    val get_union          : c_pod -> c_pod
	    val get_array          : c_pod -> c_pod list
d376 1
a376 1
	    val get_enum           : c_pod -> int
d380 2
a381 2
	 (* C CODEINFO *)
	 structure CodeInfo :
d384 1
d386 2
a387 4
	    type c_codeinfo

	    datatype c_decl_entry =
		UNDEF_DI
d389 1
a389 1
		VAR_DI of { name : Utilities.name, ctype : c_type Utilities.box }
d391 3
a393 3
		CODE_DI of { name   : Utilities.name,
			     source : c_type list Utilities.box,
			     target : c_type Utilities.box }
d395 3
a397 3
		TYPE_DI of { name : Utilities.name,
			     defn : c_type Utilities.box,
			     size : int Utilities.box }
d399 1
a399 1
		CONST_DI of { name : Utilities.name, ctype : c_type Utilities.box }
d401 1
a401 1
	    val new_codeinfo      : unit -> c_codeinfo
d403 3
a405 3
	    val lookup_entry : c_codeinfo -> Utilities.name -> c_decl_entry
	    val def_entry    : c_codeinfo * c_decl_entry -> unit
	    val hide_entry   : c_codeinfo * Utilities.name -> unit
d407 1
a407 1
	    val show_entries : c_codeinfo -> c_decl_entry list
d409 1
a409 1
	    val elaborate_type : c_codeinfo -> (c_type -> c_type)
d411 1
a411 1
	    val load_header : Utilities.filename -> c_codeinfo
a417 4
            type c_codeset = CodeSet.c_codeset

            type c_codeinfo = CodeInfo.c_codeinfo

d419 3
a421 2

            type c_pod = Value.c_pod
d425 1
a425 1
	    val attach : (c_codeset * c_codeinfo) -> (Utilities.name -> c_function)
d427 1
a427 1
	    val call   : c_function -> (c_pod list * c_pod) -> unit
a431 3
            type hostel = Hostel.hostel

            type c_type = Type.c_type
d433 3
a435 1
            type c_pod = Value.c_pod
d439 2
a440 2
            val view_pod : c_pod -> string
            val disp_pod : c_pod -> c_pod
d442 2
a443 2
	    val pod_info : c_pod ->
		       { hostel    : hostel,
d449 1
a449 1
			 base      : Utilities.address option,
d453 3
a455 3
	    val pod_data         : c_pod -> int list
	    val pod_data_hex     : c_pod -> string
	    val pod_data_ascii   : c_pod -> string
d461 1
a461 1
        type hostel = Hostel.hostel
d463 2
a464 2
        val view_hostel : hostel -> string
        val disp_hostel : hostel -> hostel
d466 1
a466 1
        val hostel_info : hostel ->
d468 1
a468 1
		 origin   : Utilities.address,
d476 2
a477 2
        val hostel_data :
            { hostel : hostel,
d481 2
a482 2
        val hostel_data_hex :
            { hostel : hostel,
d486 2
a487 2
        val hostel_data_ascii :
            { hostel : hostel,
d491 2
a492 2
        val diff_addr : Utilities.address -> Utilities.address -> int
        val incr_addr : Utilities.address * int -> Utilities.address
@


1.9
log
@Sharing changes
@
text
@d14 3
d46 3
a48 3
require "../initbasis/__general";
require "../initbasis/__word32";
require "../initbasis/__word8";
@


1.8
log
@Language changes -- no more open in signatures
/
@
text
@d14 4
d51 1
a51 2
      type 'a option
	sharing type option = General.option
d56 1
a56 2
	 type word32
	   sharing type word32 = Word32.word
d58 1
a58 2
	 type address
	   sharing type address = word32
d60 1
a60 2
	 type bytearray
	   sharing type bytearray = MLWorks.ByteArray.bytearray
d62 1
a62 2
	 type name
	   sharing type name = string
d64 1
a64 2
	 type filename
	   sharing type filename = string
d194 2
a195 4
	    type enum_value
	    type tag

	    sharing type Utilities.name = tag = enum_value = string
d278 1
a278 2
            type hostel
               sharing type hostel = Hostel.hostel
d280 1
a280 2
            type pod_mode
               sharing type pod_mode = Pod.pod_mode
d282 1
a282 2
            type c_type
               sharing type c_type = Type.c_type
d419 1
a419 2
            type c_type
               sharing type c_type = Type.c_type
d455 1
a455 2
            type c_codeset
               sharing type c_codeset = CodeSet.c_codeset
d457 1
a457 2
            type c_codeinfo
               sharing type c_codeinfo = CodeInfo.c_codeinfo
d459 1
a459 2
            type c_type
               sharing type c_type = Type.c_type
d461 1
a461 2
            type c_pod
               sharing type c_pod = Value.c_pod
d472 1
a472 2
            type hostel
               sharing type hostel = Hostel.hostel
d474 1
a474 2
            type c_type
               sharing type c_type = Type.c_type
d476 1
a476 2
            type c_pod
               sharing type c_pod = Value.c_pod
d502 1
a502 2
        type hostel
           sharing type hostel = Hostel.hostel
@


1.7
log
@Further modification for updates and general reorganisation.
@
text
@d14 3
a90 2
      open Utilities

d147 1
a147 1
	 val pod_address      : ('l_type) pod -> address
d182 2
a183 2
	    val load_codeset : filename * load_mode -> c_codeset
	    val file_info : c_codeset -> (filename * load_mode)
d185 2
a186 2
	    val files_loaded : unit -> filename list
	    val symbols      : c_codeset -> name list
d190 1
a190 1
	    val symbol_info : c_codeset * name -> value_type
d199 1
a199 1
	    sharing type name = tag = enum_value = string
d214 1
a214 1
	       SIZE_OF of { size : int box, ctype : c_type }
d228 3
a230 3
	       TYPENAME_CT of { name : name,
			        defn : c_type box,
			        size : int box }
d236 1
a236 1
			        size   : int box }
d240 2
a241 2
			        size     : int box,
			        current  : c_variant box }
d247 1
a247 1
			        card  : int box
d250 1
a250 1
	    and  c_variant = CVNT of { name  : name,
d252 1
a252 1
				       size  : int box }
d254 1
a254 1
	    and  c_field   = CFLD of { name    : name,
d256 3
a258 3
				       size    : int box,
				       padding : int box,
				       offset  : int box }
d330 1
a330 1
	    val set_word32         : c_pod * word32 -> unit
d351 1
a351 1
            val set_field   : { record:c_pod, field:name, data:c_pod } -> unit
d353 1
a353 1
	    val set_member  : { union:c_pod, member:name } -> unit
d364 1
a364 1
	    val select_pod  : { record:c_pod, tgt:c_pod, field:name } -> unit
d369 1
a369 1
	    val copy_select_pod    : c_pod * name -> c_pod
d374 1
a374 1
	    val select_pod_type    : c_pod * name -> c_type
d379 1
a379 1
	    val select_pod_size    : c_pod * name -> int
d399 1
a399 1
	    val get_word32         : c_pod -> word32
d413 1
a413 1
	    val get_field          : c_pod * name -> c_pod
d434 1
a434 1
		VAR_DI of { name : name, ctype : c_type box }
d436 3
a438 3
		CODE_DI of { name   : name,
			     source : c_type list box,
			     target : c_type box }
d440 3
a442 3
		TYPE_DI of { name : name,
			     defn : c_type box,
			     size : int box }
d444 1
a444 1
		CONST_DI of { name : name, ctype : c_type box }
d448 1
a448 1
	    val lookup_entry : c_codeinfo -> name -> c_decl_entry
d450 1
a450 1
	    val hide_entry   : c_codeinfo * name -> unit
d456 1
a456 1
	    val load_header : filename -> c_codeinfo
d477 1
a477 1
	    val attach : (c_codeset * c_codeinfo) -> (name -> c_function)
d505 1
a505 1
			 base      : address option,
d525 1
a525 1
		 origin   : address,
d548 2
a549 2
        val diff_addr : address -> address -> int
        val incr_addr : address * int -> address
@


1.6
log
@Modifications for reorganisation & documentation.
@
text
@d14 3
d124 25
d151 6
a156 14
	 val ensure_aliens        : unit -> unit
	     (* Ensures that all objects and associated values are available.
		This preserves any existing entities that are present.
	      *)
	 val reset_aliens        : unit -> unit
	     (* Reset all objects and associated values - so that they are
		obtained afresh when they are next requested - and not before.
		This allows lazy semantics for establishing associations.
	      *)
	 val refresh_aliens        : unit -> unit
	     (* Refresh objects and associated values immeadiately.
		This reobtains all entities - even if they are
		already present.
	      *)
a194 2
	    type field
	    type member
d198 1
a198 1
	    sharing type name = tag = field = member = enum_value = string
d228 2
a229 2
			       defn : c_type box,
			       size : int box }
d234 2
a235 2
			       fields : c_field list,
			       size   : int box }
d238 3
a240 3
			       variants : c_variant list ref,
			       size     : int box,
			       current  : c_variant box }
d245 2
a246 2
			       elems : enum_value list,
			       card  : int box
d284 3
a289 6
            type member
               sharing type member = Type.member

            type field
               sharing type field = Type.field

a291 2
            datatype pod_mode = LOCAL_PM | REMOTE_PM

d295 1
a295 2
	    val pod_mode       :  c_pod -> pod_mode
	    val set_pod_mode   :  c_pod * pod_mode -> unit
a302 1
	    val is_tmp_pod  : c_pod -> bool
a315 2
	    exception OutOfBounds
	    exception Currency
d350 1
a350 1
            val set_field   : { record:c_pod, field:field, data:c_pod } -> unit
d352 1
a352 1
	    val set_member  : { union:c_pod, member:member } -> unit
d363 1
a363 1
	    val select_pod  : { record:c_pod, tgt:c_pod, field:field } -> unit
d368 1
a368 1
	    val copy_select_pod    : c_pod * field -> c_pod
d373 1
a373 1
	    val select_pod_type    : c_pod * field -> c_type
d378 1
a378 1
	    val select_pod_size    : c_pod * field -> int
d412 1
a412 1
	    val get_field          : c_pod * field -> c_pod
d422 1
a422 1
	 (* C SIGNATURE *)
d453 2
a475 2
	    val elaborate_type : c_codeinfo -> (c_type -> c_type)

d481 1
a481 1
         structure Debug :
d514 1
a514 1
      structure Debug :
@


1.5
log
@adding new_pod.
@
text
@d14 3
d65 1
a65 1
	 datatype 'a deferred = DF of ('a option ref)
d67 1
a67 1
	 (* Operations for deferred values *)
d69 1
a69 1
	 val someDF    :  'a deferred -> bool
d71 2
a72 2
	 val getDF     :  'a deferred -> 'a
	 val setDF     :  'a deferred -> 'a -> unit
d74 2
a75 2
	 val extractDF :  'a deferred -> 'a option
	 val updateDF  :  'a deferred -> 'a option -> unit
d77 1
a77 1
	 val resetDF   :  'a deferred -> unit
d79 2
a80 2
	 val makeDF    :  '_a -> '_a deferred
	 val newDF     :  '_a deferred -> '_a deferred
d82 1
a82 1
	 val voidDF    :  unit -> '_a deferred
d95 1
a95 1
	 datatype hostel_status = LOCKED_H | RD_H | WR_H | RDWR_H 
d100 1
a100 1
	 datatype alloc_policy = ORIGIN_AP | FLOAT_AP | ALIGNED_4_AP | ALIGNED_8_AP
d155 1
a155 1
	 structure Structure :
d157 1
a157 1
	    type c_structure
d159 1
a159 1
	    datatype load_mode = IMMEADIATE_LM | DEFERRED_LM
d161 2
a162 2
	    val load_structure : filename * load_mode -> c_structure
	    val file_info : c_structure -> (filename * load_mode)
d165 1
a165 1
	    val symbols      : c_structure -> name list
d167 1
a167 1
	    datatype value_type = CODE_VT | VAR_VT | NONE_VT
d169 1
a169 1
	    val symbol_info : c_structure * name -> value_type
d185 3
a187 3
	       - LOCAL_PTR     = Machine address pointing within the associated hostel
	       - REMOTE_PTR    = Machine address pointing outside associated hostel
	       - RELATIVE_PTR  = Index value accessing location within associated hostel
d189 1
a189 1
	    datatype pointer_mode = LOCAL_PTR | RELATIVE_PTR | REMOTE_PTR
d195 1
a195 1
	       SIZE_OF of { size : int deferred, ctype : c_type }
d197 1
a197 1
	       VOID_T
d199 1
a199 1
	       CHAR_T           | UNSIGNED_CHAR_T | SIGNED_CHAR_T
d201 1
a201 1
	       SHORT_T          | INT_T           | LONG_T
d203 1
a203 1
	       UNSIGNED_SHORT_T | UNSIGNED_INT_T  | UNSIGNED_LONG_T
d205 1
a205 1
	       FLOAT_T          | DOUBLE_T        | LONG_DOUBLE_T
d207 1
a207 1
	       STRING_T   of { length : int }
d209 3
a211 3
	       TYPENAME_T of { name : name,
			       defn : c_type deferred,
			       size : int deferred }
d213 1
a213 1
	       STAR_T     of { ctype : c_type, mode : pointer_mode ref }
d215 1
a215 1
	       STRUCT_T   of { tag    : tag option,
d217 1
a217 1
			       size   : int deferred }
d219 1
a219 1
	       UNION_T    of { tag      : tag option,
d221 2
a222 2
			       size     : int deferred,
			       current  : c_variant deferred }
d224 1
a224 1
	       ARRAY_T    of { length : int, ctype : c_type }
d226 1
a226 1
	       ENUM_T     of { tag   : tag option,
d228 1
a228 1
			       card  : int deferred
d233 1
a233 1
				       size  : int deferred }
d237 3
a239 3
				       size    : int deferred,
				       padding : int deferred,
				       offset  : int deferred }
a281 1

d326 1
a326 1
	    val set_string  : c_pod * string -> unit
d328 1
a328 1
	    val set_addr    : { obj:c_pod, addr:c_pod } -> unit
d330 5
a334 4
	    val set_ptr_addr    : { ptr:c_pod, addr:c_pod } -> unit
	    val set_ptr_addr_of : { ptr:c_pod, data:c_pod } -> unit
            val set_ptr_data    : { ptr:c_pod, data:c_pod } -> unit
            val set_ptr_type    : { ptr:c_pod, data:c_pod } -> unit
d414 1
a414 1
	 structure Signature :
d419 1
a419 1
	    type c_signature
d421 2
a422 2
	    datatype c_sig_entry =
		UNDEF_SE
d424 1
a424 1
		VAR_SE of { name : name, ctype : c_type deferred }
d426 3
a428 3
		CODE_SE of { name   : name,
			     source : c_type list deferred,
			     target : c_type deferred }
d430 3
a432 3
		TYPE_SE of { name : name,
			     defn : c_type deferred,
			     size : int deferred }
d434 1
a434 1
		CONST_SE of { name : name, ctype : c_type deferred }
d436 1
a436 1
	    val new_sig      : unit -> c_signature
d438 3
a440 3
	    val lookup_entry : c_signature -> name -> c_sig_entry
	    val def_entry    : c_signature * c_sig_entry -> unit
	    val hide_entry   : c_signature * name -> unit
d442 1
a442 1
	    val show_entries : c_signature -> c_sig_entry list
d444 1
a444 1
	    val load_header : filename -> c_signature
d451 2
a452 2
            type c_structure
               sharing type c_structure = Structure.c_structure
d454 2
a455 2
            type c_signature
               sharing type c_signature = Signature.c_signature
d465 1
a465 1
	    val elaborate_type : c_signature -> (c_type -> c_type)
d467 1
a467 1
	    val attach : (c_structure * c_signature) -> (name -> c_function)
d538 1
a538 1
        val conv_addr : address -> address -> int
@


1.4
log
@Changing names of deferred data-type operators (stream-edit)
@
text
@d14 3
d242 2
d287 1
@


1.3
log
@Adding external value support - LIB-ML.
@
text
@d14 3
d61 1
a61 1
	 (* Primitive operations for deferred values *)
d65 5
a69 2
	 val getDF     :  'a deferred -> 'a option
	 val extractDF :  'a deferred -> 'a
a70 1
	 val setDF     :  'a deferred -> 'a -> unit
a71 1
	 val updateDF  :  'a deferred -> 'a option -> unit
d73 1
d75 1
a75 1
	 val makeDF    :  '_a -> '_a deferred
@


1.2
log
@Adding remote access, diagnostics and other facilities.
@
text
@d14 3
d28 1
d127 12
@


1.1
log
@new unit
Top level file defining the ForeignInterface.
@
text
@d13 4
a16 1
 *  $Log$
d18 1
d87 1
a87 3
	 datatype overflow_policy = BREAK_OV       | EXTEND_OV
				  | EPHEM_BREAK_OV | EPHEM_EXTEND_OV
				  | EPHEM_RECYCLE_OV
d153 1
a153 3
	    sharing type name = field = member = enum_value = string
		and type tag = int

a156 7
	    datatype 'a nameitem =
		NI of { name   : name,
			item   : 'a,
			offset : int deferred }

	    datatype 'a itemlist = NL of 'a nameitem list

d189 1
a189 1
			       fields : c_type itemlist,
d193 1
a193 1
			       variants : c_type itemlist,
d195 1
a195 1
			       current  : c_type nameitem deferred }
d204 10
d217 10
d246 18
d276 2
a277 6

	    type c_pod

	    val pod : { ctype    : c_type,
			currency : bool,
			hostel   : hostel } -> c_pod
d291 2
d297 8
a304 1
	    val set_string         : c_pod * string -> unit
d306 3
a308 1
	    val set_star           : { ptr:c_pod, value: c_pod } -> unit
d310 2
a311 3
	    val set_local_ptr      : c_pod -> unit
	    val set_relative_ptr   : c_pod -> unit
	    val set_remote_ptr     : c_pod -> unit
d313 2
a314 3
	    val set_struct         : c_pod * (c_pod list) -> unit
	    val set_member         : { pod:c_pod, member:member } -> unit
	    val set_union          : { pod:c_pod, datum:c_pod } -> unit
d316 2
a317 2
	    val set_array          : c_pod * (c_pod list) * int -> unit
	    val set_enum           : c_pod * int -> unit
d322 4
a325 4
	    val index_pod   : { src:c_pod, tgt:c_pod, index:int } -> unit
	    val deref_pod   : { src:c_pod, tgt:c_pod } -> unit
	    val select_pod  : { src:c_pod, tgt:c_pod, field:field } -> unit
	    val coerce_pod  : { src:c_pod, tgt:c_pod } -> unit
a331 5
	    val index_pod_location   : c_pod * int -> int 
	    val deref_pod_location   : c_pod -> int 
	    val select_pod_location  : c_pod * field -> int 
	    val coerce_pod_location  : c_pod -> int 

d359 2
d367 1
a367 1
	    val get_star           : c_pod -> c_pod
a379 5

	    val pod_type       : c_pod -> c_type
	    val cast_pod_type  : c_pod * c_type -> unit

	    val dup_pod : c_pod -> c_pod
d442 31
d475 36
@
