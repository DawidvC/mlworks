head	1.6;
access;
symbols
	MLW_daveb_inline_1_4_99:1.6.8
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.6
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.6.5.1.1.1.1
	MLWorks_workspace_97:1.6.7
	MLWorks_dt_wizard:1.6.6
	MLWorks_11c0_1997_09_09:1.6.5.1.1.1
	MLWorks_10r3:1.6.5.1.3
	MLWorks_10r2_551:1.6.5.1.2
	MLWorks_11:1.6.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.5.1
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.6.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.5
	MLWorks_BugFix_1997_04_24:1.6
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.3.1.1
	MLWorks_gui_1996_12_18:1.6.4
	MLWorks_1_0_Win32_1996_12_17:1.6.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.1.1
	MLWorks_1_0_Irix_1996_11_28:1.6.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.2
	MLWorks_1_0_Unix_1996_11_14:1.6.1
	MLWorks_Open_Beta2_1996_10_11:1.5.3
	MLWorks_License_dev:1.5.2
	MLWorks_1_open_beta_1996_09_13:1.5.1
	MLWorks_Open_Beta_1996_08_22:1.5
	MLWorks_Beta_1996_07_02:1.4
	MLWorks_Beta_1996_06_07:1.4
	MLWorks_Beta_1996_06_06:1.4
	MLWorks_Beta_1996_06_05:1.4
	MLWorks_Beta_1996_06_03:1.4
	MLWorks_Beta_1996_05_31:1.4
	MLWorks_Beta_1996_05_30:1.4;
locks; strict;
comment	@# @;


1.6
date	96.10.25.16.08.13;	author io;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1
	1.6.6.1
	1.6.7.1
	1.6.8.1;
next	1.5;

1.5
date	96.08.20.11.50.29;	author brianm;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1;
next	1.4;

1.4
date	96.05.24.17.47.34;	author brianm;	state Exp;
branches;
next	1.3;

1.3
date	95.09.10.22.25.40;	author brianm;	state Exp;
branches;
next	1.2;

1.2
date	95.09.07.22.43.36;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	95.08.01.12.50.16;	author brianm;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.11.50;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.07.16.02.33;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.10.17.11.20.48;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.11.14.12.44.31;	author hope;	state Exp;
branches
	1.6.1.1.1.1;
next	;

1.6.1.1.1.1
date	96.11.28.14.56.28;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.11.22.18.04.55;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.12.17.17.43.51;	author hope;	state Exp;
branches
	1.6.3.1.1.1;
next	;

1.6.3.1.1.1
date	97.02.24.11.33.06;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.12.18.09.37.50;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	97.05.12.10.30.08;	author hope;	state Exp;
branches
	1.6.5.1.1.1
	1.6.5.1.2.1
	1.6.5.1.3.1;
next	;

1.6.5.1.1.1
date	97.07.28.18.16.20;	author daveb;	state Exp;
branches
	1.6.5.1.1.1.1.1;
next	;

1.6.5.1.1.1.1.1
date	97.10.07.11.41.14;	author jkbrook;	state Exp;
branches;
next	;

1.6.5.1.2.1
date	97.09.08.17.09.53;	author daveb;	state Exp;
branches;
next	;

1.6.5.1.3.1
date	97.09.09.14.05.21;	author daveb;	state Exp;
branches;
next	;

1.6.6.1
date	97.09.10.19.19.40;	author brucem;	state Exp;
branches;
next	;

1.6.7.1
date	97.09.11.20.50.52;	author daveb;	state Exp;
branches;
next	;

1.6.8.1
date	99.04.01.17.54.34;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.6
log
@[Bug #1547]
updating for current naming conventions
@
text
@(*  ==== FOREIGN INTERFACE : Internal Documentation ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 * $Log: foreign.doc,v $
 * Revision 1.5  1996/08/20  11:50:29  brianm
 * Adding documentation for is_eq_ptr and is_null_ptr ...
 *
 * Revision 1.4  1996/05/24  17:47:34  brianm
 * Beta release modifications.
 *
 * Revision 1.3  1995/09/10  22:25:40  brianm
 * Further modification for updates and general reorganisation.
 *
 * Revision 1.2  1995/09/07  22:43:36  brianm
 * Edits due to reorganisation and added short tutorial section.
 *
 * Revision 1.1  1995/08/01  12:50:16  brianm
 * new unit
 * New file.
 *
 *
 *)


0.  Introduction - Caveat
========================

This document describes the visible interface to the MLWorks Foreign
Interface (or FI for short).  The intended audience is MLWorkers and
technical documenters.  This document will take the form of annotated
ML signatures to explain and motivate the design.  Accordingly, most
sections of the document map naturally onto an ML structure and
signature.

   To users of MLWorks - a caveat and a plea:

   It should be emphasised that this interface is presently of an
   experimental nature and may be subject to revision and redesign in
   future releases of MLWorks.  This interface should be regarded as part
   of an initial offering and will be improved as time goes on.
   Consequently, it is very important for us to receive significant user
   feedback on it's use - without this, it is hard to tell where
   improvements would be needed the most.  So please try this out and let
   us know how you get on.

Some terminology.  In general, all ML expressions evaluate to
_values_.  In addition, an ML _object_ is simply an ML value which is
also _stateful_ and so has persistent effect.  ML computes values
which can therefore be either stateful or not.  For emphasis, ML
values that are _stateless_ can be called _pure_ ML values.

Within general ML programming, transient values tend not to be
stateful, with objects used mainly when information persists from
transaction to transaction.  However, the programming model when using
the MLWorks FI is usually procedural and imperative, relying upon very
much upon persistent state.  This situation is almost forced here
since the languages being interfaced to are static and imperative
themselves.  In particular, function calling requires addresses and
pointers to stay consistent during a foreign function call - this can
be acheived by providing static memory and having ML operators
construct and analyse corresponding data in these static areas.

Finally, you may also be wondering why we are not following convention
and calling this part a Foreign Function Interface (FFI).  The reason
is that ML is strongly typed and so the interface has to be also
concerned with the differences in typing between different languages.
Also, the concept of function is central within ML and is certainly
not `neutral' from an ML perspective.  For this reason, it seemed best
to use terminology that suggested breadth - hence we use the simpler
term `Foreign Interface'.


0.1.  Acknowledgements
======================

Various people have been very helpful and influential in the
development of this work.  In general, all of the MLWorkers (Jon
Thackray, Nick Barnes, Dave Berry, Matthew Arcus, Stephen Bevan and
Schzen Ooi) have been very ready with advice, suggestions and other
helpful information.  Outside the immediate group, Paul Gardner has
been very helpful in pointing me towards useful sources concerning
link-loaders, dynamic shared libraries and the required ABI's.  I have
also been strongly influenced by some very useful conversations with
Richard Brooksby who had had some earlier thoughts about the
fundamental technical issues.


1.  A small example
===================

By way of an introduction to the approach, a small example is
given showing some of the key features.  To perform this
exercise using the system, you will need to build a `guii.img'
(prefereably for SunOS 4.1) and use this as follows:

     rts/runtime-g -load images/guii.img

The `guii.img' extends the standard MLWorks gui.img with the
MLWorks FI loaded as user-level code.

The following code will be found under hello.c, hello.make and hello.sml.

1.1  On the C side ...
======================

Suppose we have the following short piece of C code:

   #include <stdio.h>

   int hello(char *str, int num)
   {
      printf("%s %i\n", str, num);
      return(42 + num);
   }

in a file called "hello.c". Note that hello.c does not contain a
`main' function - it is instead providing a `shared library', albeit
a rather trivial example of one.

This is then compiled using our favourite C compiler, creating an
object file and from that, a shared object file.  A sample makefile to
do this (on SunOS 4.1.3) might look like:

   hello.o: hello.c
	$(CC) $(CFLAGS) -c hello.c -o hello.o

   hello.so: hello.o
        $(LD) -Bdynamic hello.o -o hello.so

The variants for Solaris and Irix are fairly trivial.

To make use of Unix shared libraries in general, _including_ from
MLWorks, it is __very__ important to have the LD_LIBRARY_PATH
environment variable set appropriately.  For correct operation, the
path _must_ include the current directory (.) and the standard shared
object systems directory (usually /usr/lib).  This path is very
sensitive to ordering, so if there seem to be problems, experiment
with different orderings and don't just rely upon the documented
defaults.


1.2  And on the ML side ...
===========================
 
Having constructed a `shared library' in C, we now want to make use of
it from ML.  To do this within MLWorks, we use the tools provided via
the ForeignInterface structure.  For ease of presentation, it is
assumed that the ForeignInterface structure and the substructures
concerned with the C interface have all been opened. The ML side of
the interface now goes as follows - note that system responses will
be prefixed by "> ".

The first step is to load the foreign code itself, thereby creating an
ML object called a c_structure:


     val hello_struct = loadObjectFile("foreign/hello.so",IMMEDIATE_LOAD);
     > val hello_struct : c_structure = _

This has loaded the raw code into MLWorks.  But now we need to be able
to make use of this.  To do that, we basiclly need to feed data as
arguments to foreign functions and then to accept their results.

This involves building ML entities which can access and manipulate
foreign data.  As such, foreign data has to have an ML type associated
with it.  Moreover, there also has to be some way of describing how
such data is to be interpreted and `understood'.  From an operational
point of view, this `understanding' amounts to a qualification of what
operations this data may participate in and hence what form this
participation could take.

So, in the FI, each piece of foreign data will come equipped with a
`certificate' which describes what the interpretation is at any given
time.  Since the `certificates' are information-bearing, they must
themselves be represented in terms of ML values.

However, the FI further seperates the data storage of data values from
their representation, by mapping the actual values into `workspace'
objects called stores.  The interpretation of these data values is
then contained in another kind of ML entity called a `c_object' (rather
like a disembodied `container').  The idea is that objects are generally
associated with a place within some store containing the object's data
value.  This indirection between object value and the interpretation of
that value provides considerable flexibility, even within a strongly
typed framework such as ML.  Such flexibility will prove necessary in
order to mimic enough of a foreign data typing scheme.

So the next step is to build a `store' object which will contain the
data values - such as the arguments and the results to foreign calls.


    val hello_store =
        store{ alloc     = ALIGNED_4,
               overflow = BREAK,
               size     = 60,
               status   = RDWR_STATUS   };
    > val hello_store : store = _

So we now have a workspace for data values to `live' in.  The
parameters say that:

    - allocation is 4-byte aligned
    - an error is raised if too much memory is requested.
    - has size 60 bytes
    - both read and write status.

The next step is to build some objects through which foreign data
can be manipulated and accessed.

   val void_object =
         object { ctype     = VOID_TYPE,
                  store     = hello_store };

   val str_object =
         object { ctype     = STRING_TYPE{ length = 20 },
                  store     = hello_store };

   val int_object1 =
         object { ctype     = INT_TYPE,
                  store     = hello_store };

   val int_object2 =
         object { ctype     = INT_TYPE,
                  store     = hello_store };

   val ptr_object =
         object { ctype     = ptrType(VOID_TYPE),
                  store     = hello_store };


   > val void_object : c_type object = _
   > val str_object  : c_type object = _
   > val int_object1 : c_type object = _
   > val int_object2 : c_type object = _
   > val ptr_object  : c_type object = _

These objects are associated with particular places in the
`hello_store'.  However, they haven't yet been assigned to and hence
assumed to be invalid for reading.  Once they have been written to,
they can then be read safely.  The following code initialises some of
these objects:

   setString(str_object,  "What is 65 - 42? ---"); 

   (* note only 20 characters , not including null character,
    * any more, the MLWorks Debugger should raise a StoreAccess exception
    *)

   setInt(int_object1, 23);

and the following extracts their values:
 
   getString str_object;
   > val it : string = "What is 65 - 42? ---"

   getInt int_object1;
   > val it : int = 23

Having now set up this data, we need to use them in conjunction with
the foreign code we have already loaded.  To do this, we need some
`signature' information concerning the foreign functions we want to
use.  To do this, an empty `c_signature' object is first generated:

   val hello_sig = newSignature();
   > val hello_sig : c_signature = _

and the following entry is then added, corresponding to the foreign
function that we wish to use:

   defEntry(hello_sig,
             FUN_DECL { name = "hello",
                        source = [ptrType(CHAR_TYPE), INT_TYPE] : c_type list,
                        target = INT_TYPE }
            );

Note how the form of the signature information follows the structure
of the ANSI C prototype for the function.  We hope to automate the
construction of this signature information by reading in C header
information and analysing it sufficiently to construct these entries
above.  This should form an integral part of the `stubs generator'
software to be provided.

So, we can now use the c_signature and c_structure information we have
obtained to extract `callable entries' for the foreign functions they
provide:

   val def_hello = defineForeignFun (hello_struct, hello_sig);
   (* val def_hello = defineForeignFun(hello_cset, hello_cinfo); *)
   > val def_hello : filename -> c_function = fn

Using this, we can obtain a `c_function' object that can then be
called directly. 

   val hello = def_hello "hello";
   > val hello : c_function = _

The above allows foreign functions to be extracted as ML values and
bound to ML identifiers in the usual way.

We have almost reached the point at which we can call our foreign
function.  Before we do, we need to set up the first argument as a
character pointer to some string data.  The following does this:

   setPtrType     { ptr = ptr_object, data = str_object };
   setPtrAddr_of  { ptr = ptr_object, data = str_object };
   castPtrType    { ptr = ptr_object, ctype = CHAR_TYPE };

This first sets the pointer to the corresponding type of str_object, the
pointer is then set to point at the data and finally the pointer is
cast to the required argument type.

In fact, because strings are such a frequent case, the FI can accept
STRING_TYPE values directly and convert them into an appropriate CHAR_TYPE
pointer, for both argument and result from a foreign function.

So finally, we can call our foreign function hello() using all we have
put together:

   call hello ([ptr_object,int_object1], int_object2);
   What is 65 - 42? ---- Ans is  23
   > val it : unit = ()

The above call required two objects to give the argument values and a object
to accept the result.  Calling this function should have deposited the
result value into int_object2 - we can extract this value by doing:

   getInt(int_object2);
   > val it : int = 65

This completes our example.

1.3  Summary
============

So, the above shows briefly how the ML FI provides a `data model' of
each foreign language.  The interface provided offers the means to
manipulate data in a way consistent with the original foreign
language.  The support offered by the FI for a foreign language is
provided by a general component common to all languages supported and
a specific part dealing with just that language.



2.  structure Interface : INTERFACE
===================================

This is the top-level structure and signature for the FI and contains
the following sub-structures:

      structure Store
      structure Object
      structure Aliens
      structure LibML
      structure Diagnostic

      structure C
      structure C.Structure
      structure C.Type
      structure C.Value
      structure C.Signature
      structure C.Function
      structure C.Diagnostic


The following sections document each of these sub-structures.  A final
section describes known limitations of this interface and possible
future developments and enhancements.

In addition, various standard types used throughout the interface are
exported - these are:

   type word32     (= Word32.word)
   -- Gives a standard 32-bit value

   type address    (= word32)
   -- Address type is 32-bit addresses

   type bytearray  (= MLWorks.Internal.ByteArray.bytearray)
   -- Bytearray values are supplied using standard MLWorks bytearrays

   type name       (= string)
   -- Names used are strings

   type filename   (= string)
   -- Filenames used are strings


3.  structure Store
====================

This structure defines store objects and operations upon them.  The
idea behind stores is straightforward.  They provide the underlying
workspace in which foreign data is represented.  To access and
manipulate foreign data, the user declares  objects associated
with particular locations within stores and it is via these
objects that foreign data can be read and also be written.  These
objects can be relocated under user control within their associated
store.

So, a store represents a staticlly allocated, uniformly addressable
(i.e. contiguous) `workspace' in which interfacing can take place as
direct actions upon memory.  Naturally, the store has additional
structure to make their use more robust and convenient for
programming.  For example, the programmer has control over what
happens if and when the store `overflows'.  One such overflow
`policy' is to raise an exception, another policy will automatically
`expand' a store and increase the workspace available.

The use of stores is not specific to any particular language
interface (e.g. C) and could be used for other interfaces added later.
These can therefore be implemented once and for all.


3.1. Why stores _and_ objects?
==============================

The original idea was that each `obj' object would have local storage
to contain it's foreign data - but it turns out that this would have
limited programmatic access to that data.  For example, the programmer
may want to have several object's inspecting the same piece of foreign
data - and this is clearly `difficult' to arrange if they all have
seperate storage.

Also, we want this data to be static - not movable by the Garbage
Collector.  Although the GC knows about the liveness of static objects
etc., it obviously cannot compact static blocks.  If there wasn't a
sufficiently large turnover of these static objects, then this could
eventually lead to memory management difficulties (i.e. excessive
fragmentation) if an ML application using the FI had to remain in
operation over a reasonable stretch of time.

Hence, stores are intended to give the programmer control and to
allow for pre-allocation of space for their needs.  Of course, it is
possible to rely on store `expansion' as necessary - this involves
copying of static bytearrays to preserve the uniform address space.
[A static bytearray is identical to a standard ML bytearray, except
that it is a static object and has an extra operation that yields the
machine address of any byte it contains.]  However, as the next
section explains, this may not be what the programmer needs to do.
Hence the need for several options.


3.2. Machine pointers and stores
=================================

Much foreign data can consist of pointers, represented as machine
addresses, and generally speaking, such data would be stored within a
store.  However, as mentioned above, stores can grow in size, by
expanding them.  To ensure the uniformity of addressing, this
expansion is implemented by copying.  Such an operation may of course
invalidate any machine pointers that were pointing at `local'
storage associated with the store.

For this reason, explicit machine pointers need to be treated with
care and respect.  In the C interface below, there is a facility for
providing `local' pointers represented as a local offset from the base
address of the store.  The use of small indices here means that
conventional array indexing can be used directly from ML.  Of course,
this facility also needs the ability to interconvert between local
indices and actual machine addresses.

The advantage of using `local' pointers is that they remain invariant
under expansion of the store.  However, their disadvantage is that
they are meaningless if used out of context.  Hence, local pointers
must not be passed into foreign code - they must first be turned into
machine addresses.  Tools are provided to facilitate this.

One way of avoiding these difficulties is to work with stores that
cannot be expanded - sufficient static space is pre-allocated.  In
this case, machine addresses cannot be invalidated due to store
expansion and so can be passed to foreign code with impunity.


3.3. Stores
============

   type store
   -- An encapsulated type representing store objects.

   datatype store_status
   -- Each store possesses a `status' which can take the following
      values:

      + LOCKED_STATUS
        - store data may not be accessed or modified by ML.

      + RD_STATUS
        - store data is read-only from ML.

      + WR_STATUS
        - store data is write-only from ML.

      + RDWR_STATUS
        - store data is readable/writeable from ML (normal).

   exception ReadOnly
   -- This exception is raised if an attempt to write data is made to
      a store whose status forbids writing (i.e. LOCKED_STATUS, RD_STATUS).

   exception WriteOnly
   -- This exception is raised if an attempt to read data is made from
      a store whose status forbids reading (i.e. LOCKED_STATUS, WR_STATUS).

   val storeStatus     : store -> store_status
   -- Function for inspecting the status of a store.   

   val setStoreStatus : (store * store_status) -> unit
   -- Function for setting the status of a store object.

   datatype alloc_policy
   -- Each store object is created just like any other ML value (except
      that it is static - not relocatable by the GC) and given some memory
      for its representation.  However, the store is involved in managing a
      number of `obj' objects associated with the store's workspace area.
      The `alloc_policy' datatype is used to specify the manner in which
      space is given to these `obj' objects from within the store's
      workspace:
  
      + ORIGIN
        - Each fresh object is located at the origin.  This implies that the
          applications programmer has to control the arrangement of
          objects within the store.  To use the associated objects, these
          would be relocated under programmatic control.  Operations
          that perform such relocation are subject to the semantics
          of the data model for the foreign language being interfaced
          to.  Because of this, operations that involve relocation
          actions are provided by specific foreign language interfaces.

      + SUCC
        - Each fresh object is located at the `top' of the workspace,
          immediately following all the other objects.

      + ALIGNED_4
        - As for SUCC, but each fresh object is allocated on a
          4-byte address boundary (i.e. address is 0 mod 4). 

      + ALIGNED_8
        - As for SUCC, but each fresh object is allocated on a
          8-byte address boundary (i.e. address is 0 mod 8).

      It is possible to have several stores being used at the same
      time - and each could have different allocation policies,
      perhaps because each is handling different kinds of data.


   datatype overflow_policy
   -- Each store object in effect manages a piece of workspace memory on
      ML's behalf, and objects are associated with bits of this workspace.  So,
      what then happens when the workspace memory is fully allocated to
      existing objects and more space is requested?

      Various courses of action are reasonable and the overflow_policy
      datatype reflects the choices made available to the applications
      programmer.  A store is said to have _overflowed_ when an attempt is
      made to use more space then is presently available in the associated
      workspace.

      + BREAK
	- The exception ExpandStore is raised when the store has overflowed
	  and an attempt to expand it is made (possibly via the expand()
	  function (see below)).

	  In effect, the store is of fixed size and cannot be expanded.

      + EXTEND
	- The store automatically expands (by some internal rule) to
	  accomodate whatever fresh allocation requests are made.  Clearly, this
	  expansion is subject to system limits on the amount of memory that a
	  process can have mapped at any one moment.

	  Explicit calls to expand() need advice on how much extra space needs
	  to be allocated.

	  In effect, stores with this overflow policy are flexible in size and
	  can be expanded (automatically or manually) as necessary.

      + RECYCLE
	- With this policy, the store contains `ephemeral' objects whose lifetimes
	  are known in advance to be short.  When the store overflows,
	  allocation simply resumes at the origin and continues apace.  Clearly,
	  there is a danger that data could be overwritten inadvertently, if
	  insufficient workspace isn't available to cater for all objects
          that are live at any one time.

	  Stores with this overflow policy may be explicitly expanded.  If a
	  request to allocate space which cannot be met is given then the
          ExpandStore exception is raised.


   val store : { alloc    : alloc_policy,
		  overflow : overflow_policy,
		  status   : store_status,
		  size     : int } -> store
   -- This function is used to generate fresh stores.  The initial size,
      allocation policy, overflow policy, and initial store status
      can be supplied.  Note that the store_status may be modified
      using the setStoreStatus() function, and the size may be
      explicitly increased (when possible) using the expand() function. 
      The other attributes cannot be modified dynamically.

   val storeSize     : store -> int
   -- This function returns the current size of the store.

   val storeAlloc    : store -> alloc_policy
   -- This function returns the allocation policy for the store.

   val storeOverflow : store -> overflow_policy
   -- This function returns the overflow policy for the store.

   val isStandardStore  : store -> bool
   -- This predicate determines if the store is deemed to be
      `standard'.   A store is _standard_ when the allocation policy isn't
      ORIGIN or if the overflow policy isn't RECYCLE.

   val isEphemeralStore : store -> bool
   -- This predicate determines if the store is deemed to be
      `ephemeral'.  A store is _ephemeral_ when the allocation policy isn't
      ORIGIN and the overflow policy _is_ RECYCLE.

   exception ExpandStore
   -- This exception is raised when an attempt is made to expand a
      store which cannot be fulfilled.

   val expand  : (store * int) -> unit
   -- This function expands a store by at least the specified size
      (given in bytes) or fails with exception ExpandStore.


4. structure Object
===================

This section discusses the generic aspects of foreign objects.  A
foreign object provides the means to both access and modify foreign
data from ML.  They do not themselves contain this data, but instead
they are generally associated with a location in some store and it is
these stores which contain foreign data.  In short, a foreign object provides
_indirect_ access to foreign data, thus permitting greater freedom.

Now, for each language specific interface, some specific idea of
foreign object is thus required.  Fortunately, many features of
objects would be common to each of their language-specific
counterparts and these common, language-independent, operations can be
provided here.

However, the objects are also likely to have some very language
specific aspects as well.  In particular, any notion of `typing' will
be very language specific.  For this reason, the ML type that
represents object objects turn out to be polymorphic, to allow for
this dependence on language specific aspects, such as typing.

As you will see below, there are several generic ways of inspecting a
foreign object, but _no_ (generic) ways of generating objects directly
or modifying any existing characteristics they may have.  The reason
is that these are very much subject to the language-specific semantics
of the appropriate data model.  Accordingly, such operations are
provided within the language specific interfaces.

   type ('l_type)object
   -- Any foreign object consists of two main components - a `value'
      part and a `type' part.  The value part generally refers to some raw
      information contained in an associated store workspace, whereas the
      `type' part determines how this information is to be interpreted.

      This `value' part can be implemented generically, since this just
      amounts to some location in the associated store.

      The ML type of the language-specific information is provided via
      the ML type-parameter 'l_type.


   exception ReadOnly   (= Store.ReadOnly)
   exception WriteOnly  (= Store.WriteOnly)
   -- These exceptions are raised when a object attempts to access or
      update a store in a manner that is forbidden according to it's
      current status.

   datatype object_mode
   -- Each object also has an associated `mode' which governs the way in
      which foreign data can be accessed.  In general, foreign objects access
      foreign data that is present `locally' within their associated store.
      However, there are occasions when a programmer wishes to `inspect'
      some foreign data without doing anything to it (e.g. selecting a
      component from a record value).

      Using the approach described above, such data could only be inspected
      by first arranging for it to be copied to a store and then accessed.
      This is clearly inefficient and far too unwieldy.

      To counter this, a object may actually be in one of two `modes': local or
      remote.  A object in local mode can only access and modify data present
      within its associated store.  A object in remote mode is located
      remotely to enable it to access foreign data without having first
      copied it back.  In addition, a `remote' object cannot modify or affect
      foreign data.

      The modes provided are:

      + LOCAL_OBJECT
        -- Foreign data is sited _locally_ within a store workspace.
           Such data can be read and written by ML and foreign code.

           Pointer values are not restricted i.e. they can be simple
           indices (i.e. relative) or machine addresses.

      + REMOTE_OBJECT
        -- Foreign data is sited remotely somewhere in the users
           address space.  Such data can only be read - and
           *not* written to - from ML.

           Pointer values are restricted to being machine addresses.

   val objectMode         : ('l_type) object -> object_mode
   -- The current `object_mode' can be inspected using this function.


   datatype object_status
   -- As foreign data is not stored directly as part of a foreign object,
      objects can be cheaply replicated without changing the meaning of the
      foreign data.  However, it is also sometimes useful to be able to
      control the way in which foreign objects are replicated.

      To do this, each object is given a status value, which can be either
      `permanent' or `temporary'.  The purpose of the object status is that
      permanent foreign objects can be duplicated but temporary objects are _never_
      duplicated and would be returned unmodified.  Temporary objects are made
      by an operation that first duplicates a permanent object and changes the
      status of the duplicate to temporary.

      The functions which perform such duplication may need to take suitable
      care of the language-specific part of a object.  As such, these function
      are provided as part of the language specific interfaces.

      The object status values are:
      + PERMANENT_OBJECT
        -- A object with permanent status usually represents
           some sort of `live' object which is in some way persistent.
           By default, newly built objects are given permanent status.

      + TEMPORARY_OBJECT
        -- A object with temporary status usually represents an ephemeral
           short-lived object that is summoned into existence to perform
           a very specific role within code.

   val objectStatus       : ('l_type) object -> object_status
   -- This function yields the current status of the given object.

   exception OutOfBounds
   -- This exception is raised if an attempt is made to `move' or
      `relocate' a object to some location outside the current store.
      This is analogous to the Subscript error that is raised when
      an attempt is made to update an array at an invalid index.

   exception Currency
   -- This exception is raised when an attempt is made to perform some
      action upon a object when the association between object and foreign data is
      assumed to be `corrupt' or `invalid'.

      Of course this is a highly semantic notion, heavily dependent upon the
      interpretation placed on the semantics of the data model for the
      language being interfaced with.  In general, a object is taken to _not_
      be current if it has just been moved, relocated or otherwise changed
      without having adjusted it's language-dependent interpretation
      (i.e. it's `type') accordingly.

      Hence, the manner in which the currency of a object is changed and
      brought up-to-date is entirely language-dependent.

   val objectCurrency     : ('l_type) object -> bool
   -- This predicate reports true iff the given object is assumed to
      represent current data.

   val objectSize         : ('l_type) object -> int
   -- This function returns the current size (in bytes) occupied by the
      associated foreign data located in the store.

   val objectLocation     : ('l_type) object -> int
   -- This function returns the location of the associated foreign
      data located in the store.

   val objectAddress      : ('l_type) object -> address
   -- This function returns the machine address corresponding to the
      location returned by object_location().


5.  structure Aliens
====================

This structure is involved with managing externally linked foreign
code objects.  This interface uses dynamic linking of foreign code
(supplied via the underlying OS) and ML makes a record of what objects
have been linked in so far.  The basic interface for linking foreign
code allows code to either be linked immediately (i.e. at link time)
or when something actually makes use of the code (i.e. at call time).

The following functions are used to ensure that the appropriate
associations between ML values representing external objects are in
the desired state:

   val ensureAliens  :  unit -> unit
   -- Ensures that all objects and associated values are available.
      This preserves any existing entities that are present.

   val resetAliens   :  unit -> unit
   -- Reset all objects and associated values - so that they are
      obtained afresh when they are next requested - and not before.
      This allows lazy semantics for establishing associations.

   val refreshAliens  :  unit -> unit
   -- Refresh objects and associated values immediately.
      This reobtains all external entities - even if they are
      already present (apparently).

For example, these facilities may be used to `reset' associations between
foreign code and ML representations and also ensure that up-to-date
versions have been obtained.


6.  structure LibML
===================

This structure provides the ML side of a C programmers interface for
accessing ML values and calling ML functions from C.  This facility is
provided only for C code that has already been called from ML.
Applications of this is to provide windowing `callback' functions as
ML functions.  To make use of this, ML values have first to be
registered by ML for access from C.  The following functions provide
facilities for this registration - values so registered are called
`external values':

   val registerExternalValue  :  string * 'a -> unit
   -- Associates a given value with a string.  This string is then
      used from C as a handle for the C version of the object.

      If a value is already associated then an exception is raised.

   val deleteExternalValue  :  string -> unit
   -- Provides means for deleting a specific evternal value entry.

   val externalValues  :  unit -> string list
   -- Provides a list of all strings used to name the external values.

   val clearExternalValues  :  unit -> unit
   -- Provides an efficient way to clear all the external value
      entries in a single operation.


7.  structure Diagnostic
========================

This structure contains a general collection of tools to assist with
the provision of diagnostics involving general elements of the FI,
such as stores.  It is not envisaged that these would be used to
provide functionality within applications - but, of course, this is
not prohibited either.

These tools are provided here on the understanding that the interface
may be changed arbitrarily,  In particular, there is no guarantee to
preserve any functionality in future versions.  However, such
interfaces are not changed without there being just cause.

   val viewStore : store -> string
   -- Outputs a string containing information about stores.

   val dispStore : store -> store
   -- Outputs the string produced by view_store() on the standard
      output stream and returns the store.

   val storeInfo : store ->
	  { kind     : string,
	    origin   : address,
	    status   : string,
	    alloc    : string,
	    overflow : string,
	    size     : int,
	    top      : int,
	    free     : int }
   -- Provides a structured, diagnostic `view' of the internals of a
      store.  This can be used by programmers to monitor what is happening
      within a store and also encourages the construction of additional
      diagnostic tools for their own purposes.

   val storeData :
       { store : store,
	 start  : int,
	 length : int } -> int list
   -- Provides a region of the store workspace as a list of integers
      (actually positive numbers from 0 to 255 inc.). 

   val storeDataHex :
       { store : store,
	 start  : int,
	 length : int } -> string
   -- Provides a region of the store workspace as a hex string.

   val storeDataAscii :
       { store : store,
	 start  : int,
	 length : int } -> string
   -- Provides a region of the store workspace as an ASCII string.

   val diffAddr : address -> address -> int
   -- Yeilds the difference of two addresses - useful for relative
      address computations.

   val incrAddr : address * int -> address
   -- Offsets a given address by an integer (note that the offset may
      be positive or negative).


8.  structure C
===============

This structure contains the language specific part of the interface
providing support for C.  It has the following sub-structures:

      structure Structure
      structure Type
      structure Value
      structure Signature
      structure Function
      structure Diagnostic

The basic idea behind this part of the FI is to provide support for a
C-compatible data model from within ML.  Object is provided under this
model via things called _objects_.  These may be considered to have two
main components: a `value' part and a `type' part.  The `value' part
of a object consists of the raw information concerning what is being
denoted, whereas the `type' part specifies how the `value' part can be
interpreted.  Both components of objects are under the control of the ML
programmer and can be manipulated in ways that are familiar to a C
programmer.  Furthermore, the value parts of objects are associated with
physical storage via a given store workspace, thereby ensuring
that memory allocation is (a) static and (b) decoupled from the
representation of specific data values. 

This structure also provides an interface for robustly managing
dynamically linked foreign code and invoking it.  This is provided via
the Structure and Signature sub-structures.  The basic idea here is
that linked-in foreign code provides raw behaviour, which is kept
locked within a `c_structure' object.  To acces and use this raw
behaviour, another object called a `c_signature' is needed to provide
signature information as `c_type' values.  When appropriately matching
c_signature and c_structure objects are combined, this then permits
the raw behaviour contained within the c_structure to be invoked.


8.1.  structure C.Structure
=========================

This structure provides facilities for loading and dynamiclly linking
foreign code for use with the C data model.

   type c_structure
   -- Objects of type c_structure are containers of foreign code.
      Each c_structure object is created as a result of dynamically
      linking foreign code from a file.  At present, no attempt is
      made to cache this code when images is saved, and so this would have
      to be restored when an image is restarted.  Fortunately, this is made
      trivial by using the tools provided via the Aliens structure.

   datatype load_mode
   -- When foreign code is loaded, the dynamic linking of that code
      may occur immediately (now, at load time) or may be
      (to call time).  These options are reflected here by:

      + IMMEDIATE_LOAD   - link foreign code immediately

      + DEFERRED_LOAD    - link foreign code at first-call to the library.


   val loadObjectFile  :  filename * load_mode -> c_structure
   -- This function generates a c_structure by dynamiclly linking
      foreign code associated with the specified file, in accordance
      with the given load_mode.

   val fileInfo  :  c_structure -> (filename * load_mode)
   -- This function obtains both the filename and the load_mode used
      to create the c_structure.

   val filesLoaded  :  unit -> filename list
   -- This yeilds a list of all foreign code files loaded so far.

   val symbols  :  c_structure -> name list
   -- Extracts symbol table info concerning the foreign code contained
      within a given c_structure.  This info might indicate name of
      object, what kind of object it is and even a relocatable address
      associated with the code.

   datatype value_type
   -- This specifies a coarse classification of foreign code objects.

      + CODE_VALUE   - object appears to be functional code of some description.

      + VAR_VALUE    - object appears to be a (visible) variable containing 
                    foreign data.

      + UNKNOWN_VALUE   - object cannot be classified as above (but might be either
                    one of the above, in fact).

   val symbolInfo : c_structure * name -> value_type
   -- This function attempts to classify named foreign code objects
      according to the scheme given above.  The function could always
      be implemented by returning UNKNOWN_VALUE, but such behaviour would not
      be very helpful to programmers.


8.2.  structure C.Type
======================
This structure provides support for representing C type information in
a manipulable form as ML data.

   type enum_value  (= string)
   -- This type is used to model enumerated values.  There are
      conversion functions to and from integers.

   type tag         (= string)
   -- This is used to provide convenient `type' tags.

   datatype pointer_kind
   -- As described in earlier sections, machine pointers need to be
      treated with special care.  To provide this care, the idea of a
      `pointer kind' is introduced.  This provides qualification of pointer
      values and determines how they can be used; 

      A pointer kind is one of the following:
      + LOCAL_PTR
        -- Machine address pointing within the associated store

      + REMOTE_PTR
        -- Machine address pointing to arbitrary (user accessible)
           memory.

      + RELATIVE_PTR
        -- Index value accessing location within associated store

   datatype c_type
   -- The ML type c_type provides a representation of C type information
      accessable as an ML value.  These values are used to provide
      information on how to interpret the `value' parts of `c_object' objects
      used to represent foreign data.

      In actual fact, c_type values are generally objects since certain
      types contain internally cached information, mainly relating to its
      `size'.  Since this attribute is functionally determined by it's
      components (i.e. a synthesised attribute), consistency can be easily
      maintained. The function sizeOf() has the additional task of defining
      the value of size attributes (see below).

      However, there are some other attributes which make c_type objects
      stateful (e.g. see POINTER_TYPE and UNION_TYPE below).  These constructors will
      therefore need to be copied on an instance-by-instance basis.  The
      function dupType() is provided to make copies as necessary.  This
      function is also used internally where necessary so that it is
      generally unnecessary for this to be used externally.

      + SIZE_OF of { size : int, ctype : c_type }
        -- Component for adding size attribute to arbitrary c_type
           objects.  This may now be redundent and unnecessary.

      + VOID_TYPE
        -- This represents the C type `void' - it has size 0.

      + CHAR_TYPE
        -- This represents the C type char - it has size 1 (byte).  It
           may be associated with either signed or unsigned chars by
           the particular C compiler used.

      + UNSIGNED_CHAR_TYPE
        -- This represents the C type `unsigned char'.

      + SIGNED_CHAR_TYPE
        -- This represents the C type `signed char'.
      
      + SHORT_TYPE
        -- This represents the C type `short int'.

      + INT_TYPE
        -- This represents the C type `int'.

      + LONG_TYPE
        -- This represents the C type `long int'.

      + UNSIGNED_SHORT_TYPE
        -- This represents the C type `unsigned short int'.

      + UNSIGNED_INT_TYPE
        -- This represents the C type `unsigned int'.

      + UNSIGNED_LONG_TYPE
        -- This represents the C type `unsigned long int'.

      + FLOAT_TYPE
        -- This represents the C type `float'.

      + DOUBLE_TYPE
        -- This represents the C type `double'.

      + LONG_DOUBLE_TYPE
        -- This represents the C type `long double'.

      + STRING_TYPE   of { length : int }
        -- This represents C string type `char *' where each string
           has an explicit amount of storage allocated for it.  This
           length should include room for the null byte sentinel.

      + TYPENAME of { name : name,
		 	 defn : c_type,
		 	 size : int }
        -- This represents the use of a named type (i.e. typedef'd) within
           a C type.

      + POINTER_TYPE     of { ctype : c_type, mode : pointer_kind ref }
        -- This represents ANSI C's idea of typed pointers.  The additional
           pointer mode information concerns how ML encodes and treats
           this pointer information.  In particular, `relative' pointers
           are simply small indices which make indirection within a store
           workspace more direct and efficient.  The representation also
           caters for `remote' pointers which can refer to arbitrary places
           in memory and `local' pointers are remote pointers which
           are known to refer to places in the associated store workspace.  

           The pointer mode data is provided on an instance-by-instance basis
           and 

      + STRUCT_TYPE   of { tag    : tag option,
		 	 fields : c_field list,
			 size   : int }
        -- This represents the structured record type in C.  Such
           types may be tagged or untagged.

      + UNION_TYPE of { tag      : tag option,
		      variants : c_variant list ref,
		      size     : int,
		      current  : c_variant }
        -- This represents the union type in C.  Such types may be
           tagged or untagged.

      + ARRAY_TYPE of { length : int, ctype : c_type }
        -- This represents the array type in C.

      + ENUM_TYPE  of { tag   : tag option,
	 	      elems : enum_value list,
		      card  : int
		   }
        -- This represents (simple) enumerated types as provided by C.
           Tools are provided for mapping strings to and from
           representing integers.  Such types may be tagged or untagged.

      datatype c_variant = VARIANT of { name  : name,
		                     ctype : c_type,
		                     size  : int }
      -- This is used to encode members of C unions.  Note that each
         variant object contains it's size.

      datatype c_field  =  FIELD of { name    : name,
		                     ctype   : c_type,
		                     size    : int,
		                     padding : int,
	                             offset  : int }
      -- This is used to encode field components of C structs.  In
         addition to it's size, this representation also has the
         offset for the field from the start of the record (useful
         for indexing) and also takes account of any `padding' required
         within each field.  This padding will be dependent upon the
         particular compiler used to compile foreign code.

   val sizeOf : c_type -> int
   -- This function computes the size of a c_type object and fills in
      any size attributes that have not already been computed.
      Clearly, this requires named types to have had declarations
      filled in - with failure if not.

   val equalType : c_type * c_type -> bool
   -- Because c_type values can contain size attribute (which may be
      set to NONE), this function is
      used to make equality comparisons between two c_types which
      disregard the attribute components they may possess.

Some convenience functions for building compound c_type objects:

   val structType  :  string * (string * c_type) list -> c_type
   -- Builds C struct type representations.
      Notice that these C type objects are tagged.

   val unionType  :  string * (string * c_type) list -> c_type
   -- Builds C union type representations.
      Notice that these C type objects are tagged.

   val ptrType  :  c_type -> c_type
   -- builds C pointer type representations.

   val typeName  :  string -> c_type
   -- builds C named type objects.

   val enumType  :  string * string list -> c_type
   -- builds C enumerated type representations


8.3.  structure C.Value
=======================
This structure provides support for foreign data values as ML data
structures.

   type store     (= Store.store)

   type object_mode   (= Object.object_mode)

   type c_type     (= Type.c_type)

   type c_object
   -- This is an encapsulated ML type used to represent foreign data
      and is equivalent to (c_type)Object.object.

   val object : { ctype    : c_type,
	          store   : store } -> c_object
   -- This generates fresh c_objects, given specific type
      information and a particular store to contain the raw value
      information.

   val setObjectMode  :  c_object * object_mode -> unit
   -- This is used to change the current object mode.

   val objectType  :  c_object -> c_type
   -- This is used to inspect the current c_type.

   val castObjectType  :  c_object * c_type -> unit
   -- This is used to change the current c_type.

   val tmpObject  :  c_object -> c_object
   -- This maps permanent objects into a duplicate except that the status
      of the duplicate is mapped to temporary.  Temporary objects are
      simply returned.

   val dupObject  :  c_object -> c_object
   -- Duplicates permanent objects, but doesn't duplicate objects whose status
      is temporary.

   val newObject  :  c_object -> c_object
   -- This generates a fresh foreign object, including making a duplicate type
      component (using dupType()), irrespective of the object's status.

   type c_char
   -- This ML type is compatible with the C type `char'.

   type c_short_int
   -- This ML type is compatible with the C type `short int'.

   type c_int
   -- This ML type is compatible with the C type `int'.

   type c_long_int
   -- This ML type should be compatible with the C type `long int'.

   type c_real
   -- This ML type is compatible with the C type `float'.

   type c_double
   -- This ML type is compatible with the C type `double'.

   type c_long_double
   -- This ML type should be compatible with the C type `long double'.

   exception ForeignType
   exception StoreAccess
   exception OutOfBounds
   exception Currency


The following are generally `setter' functions for particular kinds of
C data - in particular, these expect the foreign objects to have an
appropriate c_type already set.  If not, then they fail with exception
ForeignType.

   val setChar  :  c_object * c_char -> unit
   -- This function sets the object value to a value representing a C char.

   val setUnsignedChar  :  c_object * c_char -> unit
   -- This function sets the object value to a value representing an
      unsigned C char (i.e. 0 <= char <= 255).

   val setSignedChar  :  c_object * c_char -> unit
   -- This function sets the object value to a value representing an
      unsigned C char (i.e. -127 <= char <= 128).

   val setShort  :  c_object * c_short_int -> unit
   -- This function sets the object value to a value representing a C
      short int.

   val setInt  :  c_object * c_int -> unit
   -- This function sets the object value to a value representing a C
      integer.

   val setLong  :  c_object * c_long_int -> unit
   -- This function sets the object value to a value representing a C
      long integer.

   val setUnsignedShort  :  c_object * c_short_int -> unit
   -- This function sets the object value to a value representing a C
      unsigned short integer.

   val setUnsigned  :  c_object * c_int -> unit
   -- This function sets the object value to a value representing a C
      unsigned integer.

   val setUnsignedLong  :  c_object * c_long_int -> unit
   -- This function sets the object value to a value representing a C
      unsigned long integer.

   val setWord32  :  c_object * word32 -> unit
   -- This function sets the object value from an ML 32-bit value.

   val setFloat  :  c_object * c_real -> unit
   -- This function sets the object value to a value representing a C
      floating point real value.

   val setDouble  :  c_object * c_double -> unit
   -- This function sets the object value to a value representing a C
      double floating point real value.

   val setLongDouble  :  c_object * c_long_double -> unit
   -- This function sets the object value to a value representing a C
      long double floating point real value.

   val setString : c_object * string -> unit
   -- This function sets the object value to a value representing a C
      string.  In general, ML strings can contain embedded NULL
      characters - so only the string up to the first NULL is
      significant.  However, if no NULL is included then one is
      added.  Finally, the foreign object must have a suitable string
      c_type whose length (including any NULL sentinel) is sufficient
      to contain this data.


Functions for mainpulating and testing pointer objects:

   val setAddr  :  { obj:c_object, addr:c_object } -> unit
   -- This makes the value part of the `obj' object coincide with the value
      based at the address given by the `addr' object.  The c_type of `obj'
      may be arbitrary and the c_type of `addr' should be a numeric type
      capable of representing a machine address or an appropriate pointer
      type.

      In a sense, this makes the `obj' object inspect value data at a given
      address.

   val setPtrAddr  :  { ptr:c_object, addr:c_object } -> unit
   -- This sets the given pointer object `ptr' to reference the address
      value given by `addr' (see above).  The c_type of `ptr' is any
      pointer c_type and the c_type of `addr' is any numeric type
      capable of representing a machine address or an appropriate
      pointer type.

      This function makes a pointer object refer to a given address.

   val setPtrAddrOf : { ptr:c_object, data:c_object } -> unit
   -- This sets the given pointer object, `ptr', to reference the value
      referred to by the `data' object.  The c_type of `ptr' is any
      pointer c_type and the c_type of `data' must be compatible with
      this.

      This function makes a pointer object refer to a given piece of
      data of compatible type.

   val setPtrData    : { ptr:c_object, data:c_object } -> unit
   -- This sets the data that is addressed by the pointer object, `ptr',
      to the data specified by the object `data'.  The c_type of `ptr'
      can be any pointer c_type and the c_type of `data' must be
      compatible with this.

      This function indirectly assigns data into the space referred to
      by pointer.

   val setPtrType  : { ptr:c_object, data:c_object } -> unit
   -- This sets the c_type of the data addressed by the pointer `ptr'
      to the c_type specified by the object `data'.  The c_type of `ptr'
      can be any pointer c_type and the c_type of `data' can be
      arbitrary.  The current pointer mode is preserved.

      This function performs an implicit `type cast' of the pointer to
      match that of the given data object.

   val castPtrType : { ptr : c_object, ctype : c_type } -> unit
   -- This sets the c_type of the data addressed by the pointer `ptr'
      to the c_type specified.  This function performs an explicit
      `type cast' of the given pointer, while preserving the current
      pointer mode.

   val setLocalPtr : c_object -> unit
   -- This converts the current pointer into a local pointer i.e. a machine
      address located within the associated store workspace.  This
      may fail if the given pointer is a remote pointer that points
      outside of this workspace.

   val setRelativePtr : c_object -> unit
   -- This converts the current pointer into a relative pointer i.e. a small
      index value giving the relative offset from the origin address of the
      store workspace.  This fails if the given pointer points outside
      the associated store workspace.

   val setRemotePtr : c_object -> unit
   -- This converts the current pointer into a remote pointer i.e. a machine
      address.

   val isEqPtr : c_object * c_object -> bool
   -- Tests for equality of pointers - must have compatible
      types.  Fails on non-pointers.

   val isNullPtr : c_object -> bool
   -- Tests for NULL pointer - must have compatible types.
      Fails on non-pointers.


Functions for manipulating structured objects:

   val setStruct  : c_object * (c_object list) -> unit
   -- This function takes a object specifying a structure and updates it's
      fields from the given list of data items.  This relies upon fields
      being ordered in a structure and that the c_types of corresponding
      items and fields are matched. If there are fewer items than fields
      then only the corresponding leading prefix of fields are updated.
      Also, if there are more items then fields then the excess items are
      ignored.

   val setField   : { record:c_object, field:name, data:c_object } -> unit
   -- This function updates a specific field of a C struct with the
      given data.

   val setMember  : { union:c_object, member:name } -> unit
   -- This updates a object with union c_type by selecting a particular
      member.  The selected member must be one of the known options.

   val setUnion   : { union:c_object, data:c_object } -> unit
   -- This updates a object with union c_type with given data.  The
      c_type of the current member of the union object must be compatible
      with the c_type of the data.

   val setArray   : c_object * (c_object list) * int -> unit
   -- This updates an array object  with a `slice' of items, based at a
      given index.  This allows several elements of an array to be updated
      together.  The array elements updated begin with the given index
      and continue with consecutive indices until either the list is
      exhausted or the array ends. 

   val setEnum    : c_object * int -> unit
   -- This updates a object containing enumerated values.  The integer
      must be in the appropriate range defined by the c_type of the
      object.  The c_type of the object should be an enumerated type.


The following are particular selection functions for particular kinds
of structured C data - these expect the foreign objects to have an
appropriate c_type already set.  If not, then they fail with exception
ForeignType.


   val indexObject   : { array:c_object,  tgt:c_object, index:int } -> unit
   -- This selects an array element from the given array at the given index
      and copies the data to the target object, `tgt'.  The index must be
      in the range of the array, the c_type of `array' should be an
      array type and the target object should have compatible c_type.

   val derefObject   : { ptr:c_object,    tgt:c_object } -> unit
   -- This locates the data pointed at by the pointer object and copies it
      to the target object.

   val selectObject  : { record:c_object, tgt:c_object, field:name } -> unit
   -- This selects data from a field of a given record and copies it
      to the target object.  The field has to be one of those associated
      with the C struct type of the `record'; the c_type of the target
      object must also be compatible with the field.

   val coerceObject  : { union:c_object,  tgt:c_object } -> unit
   -- This extracts the content of the union object and copies it to the target
      object.  The c_types of the union and the target do not have to
      match (i.e. implict coercion).

   val copyIndexObject     : c_object * int -> c_object
   -- As for indexObject() above, but generates a new object to provide the
      result.

   val copyDerefObject     : c_object -> c_object
   -- As for derefObject() above, but generates a new object to provide the
      result.

   val copySelectObject    : c_object * name -> c_object
   -- As for selectObject() above, but generates a new object to provide the
      result.

   val copyCoerceObject    : c_object -> c_object
   -- As for coerceObject() above, but generates a new object to provide the
      result.

   val indexObjectType  :  c_object -> c_type
   -- This gives the c_type of an element of the array.

   val derefObjectType  :  c_object -> c_type
   -- This gives the c_type of the value pointed at by the pointer object.

   val selectObjectType  :  c_object * name -> c_type
   -- This gives the c_type of the field selected from the C struct object.

   val coerceObjectType  :  c_object -> c_type
   -- This gives the c_type of the current member of the C union object.

   val indexObjectSize  :  c_object -> int
   -- This gives the size (in bytes) of an element of the specified array.

   val derefObjectSize  :  c_object -> int
   -- This gives the size (in bytes) of the value pointed at by the
      pointer object.

   val selectObjectSize  :  c_object * name -> int
   -- This gives the size (in bytes) of the field selected from the C
      struct object.

   val coerceObjectSize  :  c_object -> int
   -- This gives the size (in bytes) of the current member for the C
      union object.

   val nextArrayItem  :  c_object -> unit
   -- This `shifts' the object forwards through the workspace by an amount
      equal to its size.  This is useful when `stepping through' an array.

   val prevArrayItem  :  c_object -> unit
   -- As for nextArrayItem(), except that the object is shifted `backwards'.


The following are generally `getter' functions for particular kinds of
C data - as for the related `setter' functions, these expect the object
objects to have an appropriate c_type already set.  If not, then they
fail with exception ForeignType.


   val getChar  :  c_object -> c_char
   -- Extracts from a object with appropriate c_type, a C character
      represented as an ML value.

   val getUnsignedChar  :  c_object -> c_char
   -- Extracts  from a object with appropriate c_type, a C unsigned
      character represented as an ML value (0 - 255).

   val getSignedChar    : c_object -> c_char
   -- Extracts a C signed character represented as an ML value
      (-127 - 127) from a object with appropriate c_type.

   val getShort          : c_object -> c_short_int
   -- Extracts  from a object with appropriate c_type, a C short value
      represented as an ML value.

   val getInt            : c_object -> c_int
   -- Extracts  from a object with appropriate c_type, a C int value
      represented as an ML value.

   val getLong           : c_object -> c_long_int
   -- Extracts  from a object with appropriate c_type, a C long value
      represented as an ML value.

   val getUnsignedShort  :  c_object -> c_short_int
   -- Extracts from a object with appropriate c_type, a C unsigned short
      value represented as an ML value.

   val getUnsigned  :  c_object -> c_int
   -- Extracts from a object with appropriate c_type, a C unsigned int
      value represented as an ML value.

   val getUnsignedLong  :  c_object -> c_long_int
   -- Extracts from a object with appropriate c_type, a C unsigned long
      value represented as an ML value.

   val getWord32  :  c_object -> word32
   -- Extracts from a object with appropriate c_type a 4-byte quantity
      (i.e. C unsigned) represented as a Word32 ML value.

   val getFloat  :  c_object -> c_real
   -- Extracts from a object with appropriate c_type, a C float represented as an
      ML value.

   val getDouble  :  c_object -> c_double
   -- Extracts from a object with appropriate c_type, a C double float
      represented as an ML value.

   val getLongDouble  :  c_object -> c_long_double
   -- Extracts from a object with appropriate c_type, a C long double float
      represented as an ML value.

   val getString  :  c_object -> string
   -- Extracts from a object with appropriate c_type, an ASCII character string
      represented as an ML value.

   val getData  :  c_object -> c_object
   -- Yields a object containing the dereferenced value of the given pointer.
      This is a synonym for the copy_deref_object() function.

   val getStruct  :  c_object -> c_object list
   -- Yields a list of objects each corresponding to a field of the given
      C struct object.

   val getField  :  c_object * name -> c_object
   -- Yields the value of a given field.  This is a synonym for the
      copySelectObject() function.

   val getUnion  :  c_object -> c_object
   -- Yields a object whose value and c_type corresponds to the current member
      of the given union object.  This is a synonym for the copyCoerceObject()
      function.

   val getArray  :  c_object -> c_object list
   -- Yields a list of objects corresponding to the elements of the given
      array object.

   val getEnum  :  c_object -> int
   -- Yields an integer corresponding to the enumerated value
      represented by the given object.


8.4.  structure C.Signature
==========================

This structure defines how external signature information is
represented and provides operators for manipulating this information.

   type c_type (= Type.c_type)
   -- This makes use of the represented C-type information.

   type c_signature
   -- This is an encapsulated abstract type for representing consistent
      collections of C declaration information for types, functions
      and variables.


   datatype c_decl =
   -- This data type is used to represent C type declaration info and
      has the following structure:
      + UNDEF_DECL
        -- This value is included as a default return value for queries
           rather than using option values (i.e. NONE and SOME)
           for wrapping and unwrapping these values.

      + VAR_DECL of { name : name, ctype : c_type }
        -- C variable declarations can be recorded in this form.  The
           type information may be updated and modified.

      + FUN_DECL of { name   : name,
	 	     source : c_type list,
		     target : c_type }
        -- C function declaration information can be recorded in this
           form.  The type information may be updated and modified.

      + TYPE_DECL of { name : name,
	 	     defn : c_type,
		     size : int }

        -- C type information associated with a name (i.e. typedef and
           struct/union/enum decls) can be recorded in this form.  The
           associated type and size information may be updated and
           modified.
       
      + CONST_DECL of { name : name, ctype : c_type }
        -- Type information associated with simple literal `#define'
           constants can be recorded in this form.

   val newSignature      : unit -> c_signature
   -- This generates a fresh c_signature object.

   val lookupEntry : c_signature -> name -> c_decl
   -- This takes a c_signature and a name and returns up a declaration
      value having that name, if one exists.

   val defEntry    : c_signature * c_decl -> unit
   -- This updates a c_signature object by adding a given entry.

   val removeEntry   : c_signature * name -> unit
   -- This removes the named entry from the given c_signature object.

   val showEntries : c_signature -> c_decl list
   -- This yields a list of all the entries contained within a given
      c_signature.

   val normaliseType : c_signature -> (c_type -> c_type)
   -- This function takes a c_type object and ensures that size information
      is correct and up to date.  Normalised types can have their
      sizes computed using sizeOf().

   val loadHeader : filename -> c_signature
   -- When implemented, this will scan a C header file for declaration
      info and construct a corresponding C signature.



8.5.  structure C.Function
==========================

   type c_structure (= Structure.c_structure)

   type c_signature (= Signature.c_signature)

   type c_type      (= Type.c_type)

   type c_object       (= Value.c_object)

   type c_function
   -- This is an encapsulated abstract type used for representing foreign
      function data.  It supports sufficient information to enable these
      functions to be called with appropriate arguments and for its
      results to be interpreted.

   val defineForeignFun : (c_structure * c_signature) -> (name -> c_function)
   -- This is the main function in which all the key elements of the C
      interface are combined.  This function is used to extract named
      foreign code from a c_structure and then combined with the type
      information associated with the c_signature for that name.  The result
      is a c_function object which can then be supplied with arguments and
      called.

   val call   : c_function -> (c_object list * c_object) -> unit
   -- This function takes a c_function object and a list of objects
      representing the arguments, calls the associated foreign function and
      returns the result to the other given object.  Of course, all the type
      information for c_function, argument objects and result object must match
      accordingly.



8.6.  structure C.Diagnostic
============================

This structure contains a general collection of tools to help provide
diagnostic services for C specific parts of the FI such as c_objects.  It
is not envisaged that these would be used to provide functionality
within applications - but, of course, this is not prohibited either.

These tools are provided here on the understanding that this part of
the interface may be changed arbitrarily, In particular, there is no
guarantee to preserve any functionality in future versions.  However,
such interfaces are not changed without there being just cause.

   type store  (= Store.store)

   type c_type  (= Type.c_type)

   type c_object   (= Value.c_object)

   val cTypeInfo : c_type -> string
   -- This provides a string describing the given c_type value.

   val viewObject : c_object -> string
   -- This provides a string describing the given c_object.

   val dispObject : c_object -> c_object
   -- Outputs the string produced by view_object() on the standard
      output stream and returns the c_object.

   val objectInfo : c_object ->
	      { store     : store,
		status    : string,
		currency  : string,
		mode      : string,
		langtype  : string,
		size      : int,
		base      : address option,
		offset    : int
	      }
   -- This provides a structured, diagnostic `view' of the internals of a
      c_object.  This can be used by programmers to construct additional
      diagnostic tools based upon these.


   val objectData         : c_object -> int list
   -- This function presents the data associated with a object in the
      form of a list of integers.

   val objectDataHex     : c_object -> string
   -- This function presents the data associated with a object in the
      form of string of hex digits.

   val objectDataAscii   : c_object -> string
   -- This function presents the data associated with a object in the
      form of an ASCII string.


9.  Some limitations and future extensions
===========================================

The main limitation at present is that the foreign function call is
not completely general.  Both arguments and results are limited to
being values of size at most 4 bytes.  Such values can be:

   - characters
   - standard integers (short, long, signed or unsigned)
   - simple floats (not doubles)
   - enumerated constants
   - machine pointers to general values (incl. structures and functions).

The final case allows general strings to be handled and general data to
be used.  In practice, this is only a limitation when a general
`struct' value or a `double' needs to be passed or returned directly.

The present FI is felt to be reasonably comprehensive, if a litlle
intimidating to use.  It is hoped that future revisions will
incorporate support for automatic stub generation that makes use of
header file information.

----------------------------- End of foreign.doc ----------------------------------
@


1.6.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
# Revision 1.6  1996/10/25  16:08:13  io
# [Bug #1547]
# updating for current naming conventions
#
@


1.6.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
# Revision 1.6  1996/10/25  16:08:13  io
# [Bug #1547]
# updating for current naming conventions
#
@


1.6.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
# Revision 1.6  1996/10/25  16:08:13  io
# [Bug #1547]
# updating for current naming conventions
#
@


1.6.5.1
log
@branched from 1.6
@
text
@a7 4
# Revision 1.6  1996/10/25  16:08:13  io
# [Bug #1547]
# updating for current naming conventions
#
@


1.6.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
# Revision 1.6.5.1  1997/05/12  10:30:08  hope
# branched from 1.6
#
@


1.6.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
# Revision 1.6.5.1  1997/05/12  10:30:08  hope
# branched from 1.6
#
@


1.6.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
# Revision 1.6.5.1  1997/05/12  10:30:08  hope
# branched from 1.6
#
@


1.6.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
# Revision 1.6.5.1.1.1  1997/07/28  18:16:20  daveb
# branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
#
@


1.6.4.1
log
@branched from 1.6
@
text
@a7 4
# Revision 1.6  1996/10/25  16:08:13  io
# [Bug #1547]
# updating for current naming conventions
#
@


1.6.3.1
log
@branched from 1.6
@
text
@a7 4
# Revision 1.6  1996/10/25  16:08:13  io
# [Bug #1547]
# updating for current naming conventions
#
@


1.6.3.1.1.1
log
@branched from 1.6.3.1
@
text
@a7 3
# Revision 1.6.3.1  1996/12/17  17:43:51  hope
# branched from 1.6
#
@


1.6.2.1
log
@branched from 1.6
@
text
@a7 4
# Revision 1.6  1996/10/25  16:08:13  io
# [Bug #1547]
# updating for current naming conventions
#
@


1.6.1.1
log
@branched from 1.6
@
text
@a7 4
# Revision 1.6  1996/10/25  16:08:13  io
# [Bug #1547]
# updating for current naming conventions
#
@


1.6.1.1.1.1
log
@branched from 1.6.1.1
@
text
@a7 3
# Revision 1.6.1.1  1996/11/14  12:44:31  hope
# branched from 1.6
#
@


1.5
log
@Adding documentation for is_eq_ptr and is_null_ptr ...
@
text
@d7 3
a9 6
 *  $Log: foreign.doc,v $
# Revision 1.4  1996/05/24  17:47:34  brianm
# Beta release modifications.
#
 *  Revision 1.3  1995/09/10  22:25:40  brianm
 *  Further modification for updates and general reorganisation.
d11 2
a12 2
 *  Revision 1.2  1995/09/07  22:43:36  brianm
 *  Edits due to reorganisation and added short tutorial section.
d14 9
a22 3
 *  Revision 1.1  1995/08/01  12:50:16  brianm
 *  new unit
 *  New file.
d96 1
a96 1
exercise using the system, you will need to build a `motifi.img'
d99 1
a99 1
     rts/runtime-g -load images/motifi.img
d101 1
a101 1
The `motifi.img' extends the standard MLWorks motif.img with the
d160 1
a160 1
     val hello_struct = load_object_file("./hello.so",IMMEDIATE_LOAD);
d246 7
a252 2
   set_string(str_object,  "What is 65 - 42? ---- Ans is ");
   set_int(int_object1, 23);
d256 2
a257 2
   get_string(str_object);
   > val it : string = "What is 65 - 42? ---- Ans is "
d259 1
a259 1
   get_int(int_object1);
d267 1
a267 1
   val hello_sig = new_signature();
d273 1
a273 1
   def_entry(hello_sig,
d290 2
a291 1
   val def_hello = define_foreign_fun(hello_cset, hello_cinfo);
d307 3
a309 3
   set_ptr_type     { ptr = ptr_object, data = str_object };
   set_ptr_addr_of  { ptr = ptr_object, data = str_object };
   cast_ptr_type    { ptr = ptr_object, ctype = CHAR_TYPE };
d330 1
a330 1
   get_int(int_object2);
d381 1
a381 1
   type bytearray  (= MLWorks.ByteArray.bytearray)
d507 1
a507 1
   val store_status     : store -> store_status
d510 1
a510 1
   val set_store_status : (store * store_status) -> unit
d600 1
a600 1
      using the set_store_status() function, and the size may be
d604 1
a604 1
   val store_size     : store -> int
d607 1
a607 1
   val store_alloc    : store -> alloc_policy
d610 1
a610 1
   val store_overflow : store -> overflow_policy
d613 1
a613 1
   val is_standard_store  : store -> bool
d618 1
a618 1
   val is_ephemeral_store : store -> bool
d715 1
a715 1
   val object_mode         : ('l_type) object -> object_mode
d747 1
a747 1
   val object_status       : ('l_type) object -> object_status
d771 1
a771 1
   val object_currency     : ('l_type) object -> bool
d775 1
a775 1
   val object_size         : ('l_type) object -> int
d779 1
a779 1
   val object_location     : ('l_type) object -> int
d783 1
a783 1
   val object_address      : ('l_type) object -> address
d802 1
a802 1
   val ensure_aliens  :  unit -> unit
d806 1
a806 1
   val reset_aliens   :  unit -> unit
d811 1
a811 1
   val refresh_aliens  :  unit -> unit
d833 1
a833 1
   val register_external_value  :  string * 'a -> unit
d839 1
a839 1
   val delete_external_value  :  string -> unit
d842 1
a842 1
   val external_values  :  unit -> string list
d845 1
a845 1
   val clear_external_values  :  unit -> unit
d864 1
a864 1
   val view_store : store -> string
d867 1
a867 1
   val disp_store : store -> store
d871 1
a871 1
   val store_info : store ->
d885 1
a885 1
   val store_data :
d892 1
a892 1
   val store_data_hex :
d898 1
a898 1
   val store_data_ascii :
d904 1
a904 1
   val diff_addr : address -> address -> int
d908 1
a908 1
   val incr_addr : address * int -> address
d974 1
a974 1
   val load_object_file  :  filename * load_mode -> c_structure
d979 1
a979 1
   val file_info  :  c_structure -> (filename * load_mode)
d983 1
a983 1
   val files_loaded  :  unit -> filename list
d1003 1
a1003 1
   val symbol_info : c_structure * name -> value_type
d1049 1
a1049 1
      maintained. The function size_of() has the additional task of defining
d1055 1
a1055 1
      function dup_type() is provided to make copies as necessary.  This
d1170 1
a1170 1
   val size_of : c_type -> int
d1176 1
a1176 1
   val equal_type : c_type * c_type -> bool
d1223 1
a1223 1
   val set_object_mode  :  c_object * object_mode -> unit
d1226 1
a1226 1
   val object_type  :  c_object -> c_type
d1229 1
a1229 1
   val cast_object_type  :  c_object * c_type -> unit
d1232 1
a1232 1
   val tmp_object  :  c_object -> c_object
d1237 1
a1237 1
   val dup_object  :  c_object -> c_object
d1241 1
a1241 1
   val new_object  :  c_object -> c_object
d1243 1
a1243 1
      component (using dup_type()), irrespective of the object's status.
d1277 1
a1277 1
   val set_char  :  c_object * c_char -> unit
d1280 1
a1280 1
   val set_unsigned_char  :  c_object * c_char -> unit
d1284 1
a1284 1
   val set_signed_char  :  c_object * c_char -> unit
d1288 1
a1288 1
   val set_short  :  c_object * c_short_int -> unit
d1292 1
a1292 1
   val set_int  :  c_object * c_int -> unit
d1296 1
a1296 1
   val set_long  :  c_object * c_long_int -> unit
d1300 1
a1300 1
   val set_unsigned_short  :  c_object * c_short_int -> unit
d1304 1
a1304 1
   val set_unsigned  :  c_object * c_int -> unit
d1308 1
a1308 1
   val set_unsigned_long  :  c_object * c_long_int -> unit
d1312 1
a1312 1
   val set_word32  :  c_object * word32 -> unit
d1315 1
a1315 1
   val set_float  :  c_object * c_real -> unit
d1319 1
a1319 1
   val set_double  :  c_object * c_double -> unit
d1323 1
a1323 1
   val set_long_double  :  c_object * c_long_double -> unit
d1327 1
a1327 1
   val set_string : c_object * string -> unit
d1339 1
a1339 1
   val set_addr  :  { obj:c_object, addr:c_object } -> unit
d1349 1
a1349 1
   val set_ptr_addr  :  { ptr:c_object, addr:c_object } -> unit
d1358 1
a1358 1
   val set_ptr_addr_of : { ptr:c_object, data:c_object } -> unit
d1367 1
a1367 1
   val set_ptr_data    : { ptr:c_object, data:c_object } -> unit
d1376 1
a1376 1
   val set_ptr_type  : { ptr:c_object, data:c_object } -> unit
d1385 1
a1385 1
   val cast_ptr_type : { ptr : c_object, ctype : c_type } -> unit
d1391 1
a1391 1
   val set_local_ptr : c_object -> unit
d1397 1
a1397 1
   val set_relative_ptr : c_object -> unit
d1403 1
a1403 1
   val set_remote_ptr : c_object -> unit
d1407 1
a1407 1
   val is_eq_ptr : c_object * c_object -> bool
d1411 1
a1411 1
   val is_null_ptr : c_object -> bool
d1418 1
a1418 1
   val set_struct  : c_object * (c_object list) -> unit
d1427 1
a1427 1
   val set_field   : { record:c_object, field:name, data:c_object } -> unit
d1431 1
a1431 1
   val set_member  : { union:c_object, member:name } -> unit
d1435 1
a1435 1
   val set_union   : { union:c_object, data:c_object } -> unit
d1440 1
a1440 1
   val set_array   : c_object * (c_object list) * int -> unit
d1447 1
a1447 1
   val set_enum    : c_object * int -> unit
d1459 1
a1459 1
   val index_object   : { array:c_object,  tgt:c_object, index:int } -> unit
d1465 1
a1465 1
   val deref_object   : { ptr:c_object,    tgt:c_object } -> unit
d1469 1
a1469 1
   val select_object  : { record:c_object, tgt:c_object, field:name } -> unit
d1475 1
a1475 1
   val coerce_object  : { union:c_object,  tgt:c_object } -> unit
d1480 2
a1481 2
   val copy_index_object     : c_object * int -> c_object
   -- As for index_object() above, but generates a new object to provide the
d1484 2
a1485 2
   val copy_deref_object     : c_object -> c_object
   -- As for deref_object() above, but generates a new object to provide the
d1488 2
a1489 2
   val copy_select_object    : c_object * name -> c_object
   -- As for select_object() above, but generates a new object to provide the
d1492 2
a1493 2
   val copy_coerce_object    : c_object -> c_object
   -- As for coerce_object() above, but generates a new object to provide the
d1496 1
a1496 1
   val index_object_type  :  c_object -> c_type
d1499 1
a1499 1
   val deref_object_type  :  c_object -> c_type
d1502 1
a1502 1
   val select_object_type  :  c_object * name -> c_type
d1505 1
a1505 1
   val coerce_object_type  :  c_object -> c_type 
d1508 1
a1508 1
   val index_object_size  :  c_object -> int
d1511 1
a1511 1
   val deref_object_size  :  c_object -> int
d1515 1
a1515 1
   val select_object_size  :  c_object * name -> int
d1519 1
a1519 1
   val coerce_object_size  :  c_object -> int
d1523 1
a1523 1
   val next_array_item  :  c_object -> unit
d1527 2
a1528 2
   val prev_array_item  :  c_object -> unit
   -- As for next_array_item(), except that the object is shifted `backwards'.
d1537 1
a1537 1
   val get_char  :  c_object -> c_char
d1541 1
a1541 1
   val get_unsigned_char  :  c_object -> c_char
d1545 1
a1545 1
   val get_signed_char    : c_object -> c_char
d1549 1
a1549 1
   val get_short          : c_object -> c_short_int
d1553 1
a1553 1
   val get_int            : c_object -> c_int
d1557 1
a1557 1
   val get_long           : c_object -> c_long_int
d1561 1
a1561 1
   val get_unsigned_short  :  c_object -> c_short_int
d1565 1
a1565 1
   val get_unsigned  :  c_object -> c_int
d1569 1
a1569 1
   val get_unsigned_long  :  c_object -> c_long_int
d1573 1
a1573 1
   val get_word32  :  c_object -> word32
d1577 1
a1577 1
   val get_float  :  c_object -> c_real
d1581 1
a1581 1
   val get_double  :  c_object -> c_double
d1585 1
a1585 1
   val get_long_double  :  c_object -> c_long_double
d1589 1
a1589 1
   val get_string  :  c_object -> string
d1593 1
a1593 1
   val get_data  :  c_object -> c_object
d1597 1
a1597 1
   val get_struct  :  c_object -> c_object list
d1601 1
a1601 1
   val get_field  :  c_object * name -> c_object
d1603 1
a1603 1
      copy_select_object() function.
d1605 1
a1605 1
   val get_union  :  c_object -> c_object
d1607 1
a1607 1
      of the given union object.  This is a synonym for the copy_coerce_object()
d1610 1
a1610 1
   val get_array  :  c_object -> c_object list
d1614 2
a1615 2
   val get_enum  :  c_object -> int
   -- Yeilds an integer corresponding to the enumerated value
d1665 1
a1665 1
   val new_signature      : unit -> c_signature
d1668 1
a1668 1
   val lookup_entry : c_signature -> name -> c_decl
d1672 1
a1672 1
   val def_entry    : c_signature * c_decl -> unit
d1675 1
a1675 1
   val remove_entry   : c_signature * name -> unit
d1678 1
a1678 1
   val show_entries : c_signature -> c_decl list
d1682 1
a1682 1
   val normalise_type : c_signature -> (c_type -> c_type)
d1685 1
a1685 1
      sizes computed using size_of().
d1687 1
a1687 1
   val load_header : filename -> c_signature
d1710 1
a1710 1
   val define_foreign_fun : (c_structure * c_signature) -> (name -> c_function)
d1746 1
a1746 1
   val c_type_info : c_type -> string
d1749 1
a1749 1
   val view_object : c_object -> string
d1752 1
a1752 1
   val disp_object : c_object -> c_object
d1756 1
a1756 1
   val object_info : c_object ->
d1771 1
a1771 1
   val object_data         : c_object -> int list
d1775 1
a1775 1
   val object_data_hex     : c_object -> string
d1779 1
a1779 1
   val object_data_ascii   : c_object -> string
@


1.5.3.1
log
@branched from 1.5
@
text
@a7 3
# Revision 1.5  1996/08/20  11:50:29  brianm
# Adding documentation for is_eq_ptr and is_null_ptr ...
#
@


1.5.2.1
log
@branched from 1.5
@
text
@a7 3
# Revision 1.5  1996/08/20  11:50:29  brianm
# Adding documentation for is_eq_ptr and is_null_ptr ...
#
@


1.5.1.1
log
@branched from 1.5
@
text
@a7 3
# Revision 1.5  1996/08/20  11:50:29  brianm
# Adding documentation for is_eq_ptr and is_null_ptr ...
#
@


1.4
log
@Beta release modifications.
@
text
@d8 3
d1328 1
a1328 1
Functions for mainpulating pointer objects:
d1397 9
@


1.3
log
@Further modification for updates and general reorganisation.
@
text
@d8 10
a17 7
# Revision 1.2  1995/09/07  22:43:36  brianm
# Edits due to reorganisation and added short tutorial section.
#
# Revision 1.1  1995/08/01  12:50:16  brianm
# new unit
# New file.
#
d22 2
a23 2
0.  Introduction
================
d25 1
a25 1
This document describes the published interface to the MLWorks Foreign
d32 11
d75 8
a82 8
Thackray, Nick Barnes, Dave Berry, Matthew Arcus and Schzen Ooi) have
been very ready with advice, suggestions and other helpful
information.  Outside the immediate group, Paul Gardner has been very
helpful in pointing me towards useful sources concerning link-loaders,
dynamic shared libraries and the required ABI's.  I have also been
strongly influenced by some very useful conversations with Richard
Brooksby who had had some earlier thoughts about the fundamental
technical issues.
d151 1
a151 1
ML object called a c_codeset:
d154 2
a155 2
     val hello_cset = load_codeset("./hello.so",IMMEDIATE_LM);
     > val hello_cset : c_codeset = _
d161 1
a161 1
This involves building ML objects which can access and manipulate
d176 5
a180 5
objects called hostels.  The interpretation of these data values is
then contained in another kind of ML object called a `pod' (rather
like a disembodied `container').  The idea is that pods are generally
associated with a place within some hostel containing the pod's data
value.  This indirection between pod value and the interpretation of
d185 1
a185 1
So the next step is to build a `hostel' object which will contain the
d189 44
a232 38
    val hello_hostel =
        hostel{ alloc    = ALIGNED_4_AP,
                overflow = BREAK_OV,
                size     = 60,
                status   = RDWR_HS   };
    val hello_hostel : hostel = _

So we now have a workspace for data values to `live' in.  The next
step is to build some pods through which foreign values can be
manipulated and accessed.


   val void_pod =
         pod { ctype     = VOID_CT,
               hostel    = hello_hostel };

   val str_pod =
         pod { ctype     = STRING_CT{ length = 20 },
               hostel    = hello_hostel };

   val int_pod1 =
         pod { ctype     = INT_CT,
               hostel    = hello_hostel };

   val int_pod2 =
         pod { ctype     = INT_CT,
               hostel    = hello_hostel };

   val ptr_pod =
         pod { ctype     = mk_star_t(VOID_CT),
               hostel    = hello_hostel };


   > val void_pod : c_type pod = _
   > val str_pod  : c_type pod = _
   > val int_pod1 : c_type pod = _
   > val int_pod1 : c_type pod = _
   > val ptr_pod  : c_type pod = _
d234 2
a235 2
These pods are associated with particular places in the
`hello_hostel'.  However, they haven't yet been assigned to and hence
d238 1
a238 1
these pods:
d240 2
a241 2
   set_string(str_pod, "ML Forever!");
   set_int(int_pod1, 23);
d245 2
a246 2
   get_string(str_pod);
   > val it : string = "ML Forever!"
d248 1
a248 1
   get_int(int_pod1);
d254 1
a254 1
use.  To do this, an empty `c_codeinfo' object is first generated:
d256 2
a257 2
   val hello_sig = new_codeinfo();
   > val hello_cinfo : c_codeinfo = _
d262 4
a265 4
   def_entry(hello_cinfo,
             CODE_DI { name = "hello",
                       source = makeBOX([mk_star_t(CHAR_CT), INT_CT] : c_type list),
                       target = makeBOX(INT_CT) }
d275 1
a275 1
So, we can now use the c_codeinfo and c_codeset information we have
d279 2
a280 2
   val def_hello = attach(hello_cset, hello_cinfo);
   > val def_hello : string -> c_function = fn
d295 3
a297 3
   set_ptr_type { ptr = ptr_pod, data = str_pod };
   set_ptr_addr_of { ptr = ptr_pod, data = str_pod };
   cast_ptr_type { ptr = ptr_pod, ctype = CHAR_CT };
d299 1
a299 1
This first sets the pointer to the corresponding type of str_pod, the
d304 1
a304 1
STRING_CT values directly and convert them into an appropriate CHAR_CT
d310 2
a311 2
   call hello ([ptr_pod,int_pod1], int_pod2);
   ML Forever! 23
d314 1
a314 1
The above call required two pods to give the argument values and a pod
d316 1
a316 1
result value into int_pod2 - we can extract this value by doing:
d318 1
a318 1
   get_int(int_pod2);
d335 2
a336 2
2.  structure ForeignInterface : FOREIGN_INTERFACE
==================================================
d341 2
a342 3
      structure Utilities
      structure Hostel
      structure Pod
d348 1
a348 1
      structure C.CodeSet
d351 1
a351 1
      structure C.CodeInfo
a354 1
In addition, the standard `option' type is also exported.
d360 2
a361 9

3.  structure Utilities
=======================

The Utilities structure describes some common tools used throughout
the FI.  Because of their pervasive nature, this structure is opened
for use within the context of the FI.  In future, many of these may
exist pervasively as user libraries and made available more widely
than the FI.
d379 1
a379 45
3.1.  Deferred Elements - the box datatype
==========================================

Deferred elements are objects which act rather like disembodied
variables (e.g. like ML refs) but can additionally be either set to a
value or not (i.e. like the standard option type).  Importantly, such
objects can also be unset once they have been set.


   datatype 'a box = BOX of ('a option ref)
   -- The box objects are encapsulated optional references.

Available operations for box objects are:

   val someBOX    :  'a box -> bool
   -- Predicate to determine if the box object conatins a value.

   val getBOX     :  'a box -> 'a
   -- obtains contents when possible (raising Option otherwise)

   val setBOX     :  'a box -> 'a -> unit
   -- puts contents into the given box object.

   val extractBOX :  'a box -> 'a option
   -- obtains an optional value from the box object (for case
      analysis).

   val updateBOX  :  'a box -> 'a option -> unit
   -- sets the optional value component of the box object to the
      given optional value.

   val resetBOX   :  'a box -> unit
   -- empties the given box object.

   val makeBOX    :  '_a -> '_a box
   -- constructs a box containing the given value.

   val newBOX     :  '_a box -> '_a box
   -- generates a fresh box object with identical contents to the given box.

   val voidBOX    :  unit -> '_a box
   -- generates an empty box object of type as specified by context.


4.  structure Hostel
d382 2
a383 2
This structure defines hostel objects and operations upon them.  The
idea behind hostels is straightforward.  They provide the underlying
d385 2
a386 2
manipulate foreign data, the user declares `pod' objects associated
with particular locations within hostels and it is via these `pod'
d388 2
a389 2
`pods' can be relocated under user control within their associated
hostel.
d391 1
a391 1
So, a hostel represents a staticlly allocated, uniformly addressable
d393 1
a393 1
direct actions upon memory.  Naturally, the hostel has additional
d396 1
a396 1
happens if and when the hostel `overflows'.  One such overflow
d398 1
a398 1
`expand' a hostel and increase the workspace available.
d400 1
a400 1
The use of hostels is not specific to any particular language
d405 2
a406 2
4.1. Why hostels _and_ pods?
============================
d408 1
a408 1
The original idea was that each `pod' object would have local storage
d411 1
a411 1
may want to have several pod's inspecting the same piece of foreign
d423 1
a423 1
Hence, hostels are intended to give the programmer control and to
d425 1
a425 1
possible to rely on hostel `expansion' as necessary - this involves
d434 1
a434 1
4.2. Machine pointers and hostels
d439 1
a439 1
hostel.  However, as mentioned above, hostels can grow in size, by
d443 1
a443 1
storage associated with the hostel.
d448 1
a448 1
address of the hostel.  The use of small indices here means that
d454 1
a454 1
under expansion of the hostel.  However, their disadvantage is that
d459 1
a459 1
One way of avoiding these difficulties is to work with hostels that
d461 1
a461 1
this case, machine addresses cannot be invalidated due to hostel
d465 1
a465 1
4.3. Hostels
d468 2
a469 2
   type hostel
   -- An encapsulated type representing hostel objects.
d471 2
a472 2
   datatype hostel_status
   -- Each hostel possesses a `status' which can take the following
d475 2
a476 2
      + LOCKED_HS
        - hostel data may not be accessed or modified by ML.
d478 2
a479 2
      + RD_HS
        - hostel data is read-only from ML.
d481 2
a482 2
      + WR_HS
        - hostel data is write-only from ML.
d484 2
a485 2
      + RDWR_HS
        - hostel data is readable/writeable from ML (normal).
d489 1
a489 1
      a hostel whose status forbids writing (i.e. LOCKED_HS, RD_HS).
d493 1
a493 1
      a hostel whose status forbids reading (i.e. LOCKED_HS, WR_HS).
d495 2
a496 2
   val hostel_status     : hostel -> hostel_status
   -- Function for inspecting the status of a hostel.   
d498 2
a499 2
   val set_hostel_status : (hostel * hostel_status) -> unit
   -- Function for setting the status of a hostel object.
d502 1
a502 1
   -- Each hostel object is created just like any other ML value (except
d504 2
a505 2
      for its representation.  However, the hostel is involved in managing a
      number of `pod' objects associated with the hostel's workspace area.
d507 1
a507 1
      space is given to these `pod' objects from within the hostel's
d510 2
a511 2
      + ORIGIN_AP
        - Each fresh pod is located at the origin.  This implies that the
d513 1
a513 1
          pods within the hostel.  To use the associated pods, these
d520 3
a522 3
      + SUCC_AP
        - Each fresh pod is located at the `top' of the workspace,
          immediately following all the other pods.
d524 2
a525 2
      + ALIGNED_4_AP
        - As for SUCC_AP, but each fresh pod is allocated on a
d528 2
a529 2
      + ALIGNED_8_AP
        - As for SUCC_AP, but each fresh pod is allocated on a
d532 1
a532 1
      It is possible to have several hostels being used at the same
d538 2
a539 2
   -- Each hostel object in effect manages a piece of workspace memory on
      ML's behalf, and pods are associated with bits of this workspace.  So,
d541 1
a541 1
      existing pods and more space is requested?
d545 1
a545 1
      programmer.  A hostel is said to have _overflowed_ when an attempt is
d549 2
a550 2
      + BREAK_OV
	- The exception ExpandHostel is raised when the hostel has overflowed
d554 1
a554 1
	  In effect, the hostel is of fixed size and cannot be expanded.
d556 2
a557 2
      + EXTEND_OV
	- The hostel automatically expands (by some internal rule) to
d565 1
a565 1
	  In effect, hostels with this overflow policy are flexible in size and
d568 3
a570 3
      + RECYCLE_OV
	- With this policy, the hostel contains `ephemeral' pods whose lifetimes
	  are known in advance to be short.  When the hostel overflows,
d573 1
a573 1
	  insufficient workspace isn't available to cater for all pods
d576 1
a576 1
	  Hostels with this overflow policy may be explicitly expanded.  If a
d578 1
a578 1
          ExpandHostel exception is raised.
d581 1
a581 1
   val hostel : { alloc    : alloc_policy,
d583 6
a588 6
		  status   : hostel_status,
		  size     : int } -> hostel
   -- This function is used to generate fresh hostels.  The initial size,
      allocation policy, overflow policy, and initial hostel status
      can be supplied.  Note that the hostel_status may be modified
      using the set_hostel_status() function, and the size may be
d592 2
a593 2
   val hostel_size     : hostel -> int
   -- This function returns the current size of the hostel.
d595 2
a596 2
   val hostel_alloc    : hostel -> alloc_policy
   -- This function returns the allocation policy for the hostel.
d598 2
a599 2
   val hostel_overflow : hostel -> overflow_policy
   -- This function returns the overflow policy for the hostel.
d601 9
a609 9
   val is_standard_hostel  : hostel -> bool
   -- This predicate determines if the hostel is deemed to be
      `standard'.   A hostel is _standard_ when the allocation policy isn't
      ORIGIN_AP or if the overflow policy isn't RECYCLE_OV.

   val is_ephemeral_hostel : hostel -> bool
   -- This predicate determines if the hostel is deemed to be
      `ephemeral'.  A hostel is _ephemeral_ when the allocation policy isn't
      ORIGIN_AP and the overflow policy _is_ RECYCLE_OV.
d611 1
a611 1
   exception ExpandHostel
d613 1
a613 1
      hostel which cannot be fulfilled.
d615 3
a617 3
   val expand  : (hostel * int) -> unit
   -- This function expands a hostel by at least the specified size
      (given in bytes) or fails with exception ExpandHostel.
d620 2
a621 2
5. structure Pod
================
d623 5
a627 5
This section discusses the generic aspects of pod objects.  A pod
object provides the means to both access and modify foreign data from
ML.  They do not themselves contain this foreign data, but instead
pod's are generally associated with a location in some hostel and it
is these hostels which contain foreign data.  In short, a pod provides
d630 11
a640 10
Now, for each language specific interface, a notion of pod is thus
required.  Fortunately, many features of pods would be common to each
of their language-specific counterparts and these common,
language-independent, operations can be provided here.

However, the pods are likely to have some very language specific
aspects as well.  In particular, any notion of `typing' will be highly
language specific.  For this reason, the ML type that represents pod
objects turn out to be polymorphic, to allow for this dependence on
language specific aspects, such as typing.
d643 5
a647 5
pod object, but _no_ ways of generating them directly or modifying any
existing characteristics they may have.  The reason is that these are
very much subject to the language-specific semantics of the
appropriate data model.  Accordingly, such operations are provided
within the language specific interfaces.
d649 2
a650 2
   type ('l_type)pod
   -- Any pod onject essentially consists of two main components - a `value'
d652 1
a652 1
      information contained in an associated hostel workspace, whereas the
d656 1
a656 1
      amounts to some location in the associated hostel.
d662 4
a665 4
   exception ReadOnly   (= Hostel.ReadOnly)
   exception WriteOnly  (= Hostel.WriteOnly)
   -- These exceptions are raised when a pod attempts to access or
      update a hostel in a manner that is forbidden according to it's
d668 4
a671 4
   datatype pod_mode
   -- Each pod also has an associated `mode' which governs the way in
      which foreign data can be accessed.  In general, pod objects access
      foreign data that is present `locally' within their associated hostel.
d677 1
a677 1
      by first arranging for it to be copied to a hostel and then accessed.
d680 3
a682 3
      To counter this, a pod may actually be in one of two `modes': local or
      remote.  A pod in local mode can only access and modify data present
      within its associated hostel.  A pod in remote mode is located
d684 1
a684 1
      copied it back.  In addition, a `remote' pod cannot modify or affect
d689 2
a690 2
      + LOCAL_PM
        -- Foreign data is sited _locally_ within a hostel workspace.
d696 1
a696 1
      + REMOTE_PM
d703 2
a704 2
   val pod_mode         : ('l_type) pod -> pod_mode
   -- The current `pod_mode' can be inspected using this function.
d707 3
a709 3
   datatype pod_status
   -- As foreign data is not stored directly as part of a pod object,
      pods can be cheaply replicated without changing the meaning of the
d711 1
a711 1
      control the way in which pod objects are replicated.
d713 5
a717 5
      To do this, each pod is given a status value, which can be either
      `permanent' or `temporary'.  The purpose of the pod status is that
      permanent pod objects can be duplicated but temporary pods are _never_
      duplicated and would be returned unmodified.  Temporary pods are made
      by an operation that first duplicates a permanent pod and changes the
d721 1
a721 1
      care of the language-specific part of a pod.  As such, these function
d724 3
a726 3
      The pod status values are:
      + PERMANENT_PS
        -- A pod with permanent status usually represents
d728 1
a728 1
           By default, newly built pods are given permanent status.
d730 2
a731 2
      + TEMPORARY_PS
        -- A pod with temporary status usually represents an ephemeral
d735 2
a736 2
   val pod_status       : ('l_type) pod -> pod_status
   -- This function yields the current status of the given pod.
d740 1
a740 1
      `relocate' a pod to some location outside the current hostel.
d746 1
a746 1
      action upon a pod when the association between pod and foreign data is
d751 1
a751 1
      language being interfaced with.  In general, a pod is taken to _not_
d756 1
a756 1
      Hence, the manner in which the currency of a pod is changed and
d759 2
a760 2
   val pod_currency     : ('l_type) pod -> bool
   -- This predicate reports true iff the given pod is assumed to
d763 1
a763 1
   val pod_size         : ('l_type) pod -> int
d765 1
a765 1
      associated foreign data located in the hostel.
d767 1
a767 1
   val pod_location     : ('l_type) pod -> int
d769 1
a769 1
      data located in the hostel.
d771 1
a771 1
   val pod_address      : ('l_type) pod -> address
d773 1
a773 1
      location returned by pod_location().
d776 1
a776 1
6.  structure Aliens
d809 1
a809 1
7.  structure LibML
d838 1
a838 1
8.  structure Diagnostic
d843 1
a843 1
such as hostels.  It is not envisaged that these would be used to
d852 2
a853 2
   val view_hostel : hostel -> string
   -- Outputs a string containing information about hostels.
d855 3
a857 3
   val disp_hostel : hostel -> hostel
   -- Outputs the string produced by view_hostel() on the standard
      output stream and returns the hostel.
d859 1
a859 1
   val hostel_info : hostel ->
d869 2
a870 2
      hostel.  This can be used by programmers to monitor what is happening
      within a hostel and also encourages the construction of additional
d873 2
a874 2
   val hostel_data :
       { hostel : hostel,
d877 1
a877 1
   -- Provides a region of the hostel workspace as a list of integers
d880 2
a881 2
   val hostel_data_hex :
       { hostel : hostel,
d884 1
a884 1
   -- Provides a region of the hostel workspace as a hex string.
d886 2
a887 2
   val hostel_data_ascii :
       { hostel : hostel,
d890 1
a890 1
   -- Provides a region of the hostel workspace as an ASCII string.
d901 1
a901 1
9.  structure C
d907 1
a907 1
      structure CodeSet
d910 1
a910 1
      structure CodeInfo
d915 2
a916 2
C-compatible data model from within ML.  Data is provided under this
model via objects called _pods_.  These may be considered to have two
d918 1
a918 1
of a pod consists of the raw information concerning what is being
d920 1
a920 1
interpreted.  Both components of pods are under the control of the ML
d922 2
a923 2
programmer.  Furthermore, the value parts of pods are associated with
physical storage via a given hostel workspace, thereby ensuring
d929 1
a929 1
the CodeSet and CodeInfo sub-structures.  The basic idea here is
d931 2
a932 2
locked within a `c_codeset' object.  To acces and use this raw
behaviour, another object called a `c_codeinfo' is needed to provide
d934 2
a935 2
c_codeinfo and c_codeset objects are combined, this then permits
the raw behaviour contained within the c_codeset to be invoked.
d938 1
a938 1
9.1.  structure C.CodeSet
d944 3
a946 3
   type c_codeset
   -- Objects of type c_codeset are containers of foreign code.
      Each c_codeset object is created as a result of dynamically
d954 1
a954 1
      may occur immediately (now, at load time) or may be box
d957 1
a957 1
      + IMMEDIATE_LM   - link foreign code immediately
d959 1
a959 1
      + DEFERRED_LM    - link foreign code at first-call to the library.
d962 2
a963 2
   val load_codeset  :  filename * load_mode -> c_codeset
   -- This function generates a c_codeset by dynamiclly linking
d967 1
a967 1
   val file_info  :  c_codeset -> (filename * load_mode)
d969 1
a969 1
      to create the c_codeset.
d974 1
a974 1
   val symbols  :  c_codeset -> name list
d976 1
a976 1
      within a given c_codeset.  This info might indicate name of
d983 1
a983 1
      + CODE_VT   - object appears to be functional code of some description.
d985 1
a985 1
      + VAR_VT    - object appears to be a (visible) variable containing 
d988 1
a988 1
      + UNKNOWN_VT   - object cannot be classified as above (but might be either
d991 1
a991 1
   val symbol_info : c_codeset * name -> value_type
d994 1
a994 1
      be implemented by returning UNKNOWN_VT, but such behaviour would not
d998 1
a998 1
9.2.  structure C.Type
d1017 2
a1018 2
      + LOCAL_PK
        -- Machine address pointing within the associated hostel
d1020 1
a1020 1
      + REMOTE_PK
d1024 2
a1025 2
      + RELATIVE_PK
        -- Index value accessing location within associated hostel
d1030 1
a1030 1
      information on how to interpret the `value' parts of `c_pod' objects
d1041 1
a1041 1
      stateful (e.g. see STAR_CT and UNION_CT below).  These constructors will
d1047 1
a1047 1
      + SIZE_OF of { size : int box, ctype : c_type }
d1051 1
a1051 1
      + VOID_CT
d1054 1
a1054 1
      + CHAR_CT
d1059 1
a1059 1
      + UNSIGNED_CHAR_CT
d1062 1
a1062 1
      + SIGNED_CHAR_CT
d1065 1
a1065 1
      + SHORT_CT
d1068 1
a1068 1
      + INT_CT
d1071 1
a1071 1
      + LONG_CT
d1074 1
a1074 1
      + UNSIGNED_SHORT_CT
d1077 1
a1077 1
      + UNSIGNED_INT_CT
d1080 1
a1080 1
      + UNSIGNED_LONG_CT
d1083 1
a1083 1
      + FLOAT_CT
d1086 1
a1086 1
      + DOUBLE_CT
d1089 1
a1089 1
      + LONG_DOUBLE_CT
d1092 1
a1092 1
      + STRING_CT   of { length : int }
d1097 3
a1099 3
      + TYPENAME_CT of { name : name,
		 	 defn : c_type box,
		 	 size : int box }
d1103 1
a1103 1
      + STAR_CT     of { ctype : c_type, mode : pointer_kind ref }
d1107 1
a1107 1
           are simply small indices which make indirection within a hostel
d1111 1
a1111 1
           are known to refer to places in the associated hostel workspace.  
d1116 1
a1116 1
      + STRUCT_CT   of { tag    : tag option,
d1118 1
a1118 1
			 size   : int box }
d1122 1
a1122 1
      + UNION_CT of { tag      : tag option,
d1124 2
a1125 2
		      size     : int box,
		      current  : c_variant box }
d1129 1
a1129 1
      + ARRAY_CT of { length : int, ctype : c_type }
d1132 1
a1132 1
      + ENUM_CT  of { tag   : tag option,
d1134 1
a1134 1
		      card  : int box
d1140 1
a1140 1
      datatype c_variant = CVNT of { name  : name,
d1142 1
a1142 1
		                     size  : int box }
d1146 1
a1146 1
      datatype c_field  =  CFLD of { name    : name,
d1148 3
a1150 3
		                     size    : int box,
		                     padding : int box,
	                             offset  : int box }
d1165 2
a1166 1
   -- Because c_type values are not pure ML values, this function is
d1168 1
a1168 9
      disregard any attribute components they may possess.

   val dup_type : c_type -> c_type
   -- This function is provided to ensure consistent copying of c_types
      on an instance-by-instance basis.  This additionally ensures that a
      minimum of copying is done to acheive seperation as necessary.  This
      function is used internally to acheive this, thereby minimising the
      need for programmers to use this externally.  Consequently, it is safe
      to assume that c_type objects are sufficiently different.
d1172 2
a1173 2
   val mk_struct_t  :  string * (string * c_type) list -> c_type
   -- Builds C struct type representations in a straightforward way.
d1176 2
a1177 2
   val mk_union_t  :  string * (string * c_type) list -> c_type
   -- Builds C union type representations in a straightforward way.
d1180 2
a1181 2
   val mk_star_t  :  c_type -> c_type
   -- builds C pointer type representations in a straightforward way.
d1183 2
a1184 4
   val mk_typename  :  string -> c_type
   -- builds C named type objects in a straightforward way.  The
      declaration associated with the name is filled in with respect
      to some given set of C type declarations. 
d1186 2
a1187 3
   val mk_enum_t  :  string * string list -> c_type
   -- builds C enumerated type representations in a straightforward
      way.  
d1190 1
a1190 1
9.3.  structure C.Value
d1195 1
a1195 1
   type hostel     (= Hostel.hostel)
d1197 1
a1197 1
   type pod_mode   (= Pod.pod_mode)
d1201 1
a1201 1
   type c_pod
d1203 1
a1203 1
      and is equivalent to (c_type)Pod.pod.
d1205 4
a1208 4
   val pod : { ctype    : c_type,
	       hostel   : hostel } -> c_pod
   -- This generates fresh c_pod objects, given specific type
      information and a particular hostel to contain the raw value
d1211 2
a1212 2
   val set_pod_mode  :  c_pod * pod_mode -> unit
   -- This is used to change the current pod mode.
d1214 1
a1214 1
   val pod_type  :  c_pod -> c_type
d1217 1
a1217 1
   val cast_pod_type  :  c_pod * c_type -> unit
d1220 3
a1222 3
   val tmp_pod  :  c_pod -> c_pod
   -- This maps permanent pods into a duplicate except that the status
      of the duplicate is mapped to temporary.  Temporary pods are
d1225 2
a1226 2
   val dup_pod  :  c_pod -> c_pod
   -- Duplicates permanent pods, but doesn't duplicate pods whose status
d1229 3
a1231 3
   val new_pod  :  c_pod -> c_pod
   -- This generates a fresh pod object, including making a duplicate type
      component (using dup_type()), irrespective of the pod's status.
d1261 1
a1261 1
C data - in particular, these expect the pod objects to have an
d1265 2
a1266 2
   val set_char  :  c_pod * c_char -> unit
   -- This function sets the pod value to a value representing a C char.
d1268 2
a1269 2
   val set_unsigned_char  :  c_pod * c_char -> unit
   -- This function sets the pod value to a value representing an
d1272 2
a1273 2
   val set_signed_char  :  c_pod * c_char -> unit
   -- This function sets the pod value to a value representing an
d1276 2
a1277 2
   val set_short  :  c_pod * c_short_int -> unit
   -- This function sets the pod value to a value representing a C
d1280 2
a1281 2
   val set_int  :  c_pod * c_int -> unit
   -- This function sets the pod value to a value representing a C
d1284 2
a1285 2
   val set_long  :  c_pod * c_long_int -> unit
   -- This function sets the pod value to a value representing a C
d1288 2
a1289 2
   val set_unsigned_short  :  c_pod * c_short_int -> unit
   -- This function sets the pod value to a value representing a C
d1292 2
a1293 2
   val set_unsigned  :  c_pod * c_int -> unit
   -- This function sets the pod value to a value representing a C
d1296 2
a1297 2
   val set_unsigned_long  :  c_pod * c_long_int -> unit
   -- This function sets the pod value to a value representing a C
d1300 2
a1301 2
   val set_word32  :  c_pod * word32 -> unit
   -- This function sets the pod value from an ML 32-bit value.
d1303 2
a1304 2
   val set_float  :  c_pod * c_real -> unit
   -- This function sets the pod value to a value representing a C
d1307 2
a1308 2
   val set_double  :  c_pod * c_double -> unit
   -- This function sets the pod value to a value representing a C
d1311 2
a1312 2
   val set_long_double  :  c_pod * c_long_double -> unit
   -- This function sets the pod value to a value representing a C
d1315 2
a1316 2
   val set_string : c_pod * string -> unit
   -- This function sets the pod value to a value representing a C
d1320 1
a1320 1
      added.  Finally, the pod object must have a suitable string
d1325 1
a1325 1
Functions for mainpulating pointer pods:
d1327 3
a1329 3
   val set_addr  :  { obj:c_pod, addr:c_pod } -> unit
   -- This makes the value part of the `obj' pod coincide with the value
      based at the address given by the `addr' pod.  The c_type of `obj'
d1334 1
a1334 1
      In a sense, this makes the `obj' pod inspect value data at a given
d1337 2
a1338 2
   val set_ptr_addr  :  { ptr:c_pod, addr:c_pod } -> unit
   -- This sets the given pointer pod `ptr' to reference the address
d1346 3
a1348 3
   val set_ptr_addr_of : { ptr:c_pod, data:c_pod } -> unit
   -- This sets the given pointer pod, `ptr', to reference the value
      referred to by the `data' pod.  The c_type of `ptr' is any
d1355 3
a1357 3
   val set_ptr_data    : { ptr:c_pod, data:c_pod } -> unit
   -- This sets the data that is addressed by the pointer pod, `ptr',
      to the data specified by the pod `data'.  The c_type of `ptr'
d1364 1
a1364 1
   val set_ptr_type  : { ptr:c_pod, data:c_pod } -> unit
d1366 1
a1366 1
      to the c_type specified by the pod `data'.  The c_type of `ptr'
d1373 1
a1373 1
   val cast_ptr_type : { ptr : c_pod, ctype : c_type } -> unit
d1379 1
a1379 1
   val set_local_ptr : c_pod -> unit
d1381 1
a1381 1
      address located within the associated hostel workspace.  This
d1385 1
a1385 1
   val set_relative_ptr : c_pod -> unit
d1388 2
a1389 2
      hostel workspace.  This fails if the given pointer points outside
      the associated hostel workspace.
d1391 1
a1391 1
   val set_remote_ptr : c_pod -> unit
d1395 1
a1395 1
Functions for manipulating structured pods:
d1397 2
a1398 2
   val set_struct  : c_pod * (c_pod list) -> unit
   -- This function takes a pod specifying a structure and updates it's
d1406 1
a1406 1
   val set_field   : { record:c_pod, field:name, data:c_pod } -> unit
d1410 2
a1411 2
   val set_member  : { union:c_pod, member:name } -> unit
   -- This updates a pod with union c_type by selecting a particular
d1414 3
a1416 3
   val set_union   : { union:c_pod, data:c_pod } -> unit
   -- This updates a pod with union c_type with given data.  The
      c_type of the current member of the union pod must be compatible
d1419 2
a1420 2
   val set_array   : c_pod * (c_pod list) * int -> unit
   -- This updates an array pod  with a `slice' of items, based at a
d1426 2
a1427 2
   val set_enum    : c_pod * int -> unit
   -- This updates a pod containing enumerated values.  The integer
d1429 1
a1429 1
      pod.  The c_type of the pod should be an enumerated type.
d1433 1
a1433 1
of structured C data - these expect the pod objects to have an
d1438 1
a1438 1
   val index_pod   : { array:c_pod,  tgt:c_pod, index:int } -> unit
d1440 1
a1440 1
      and copies the data to the target pod, `tgt'.  The index must be
d1442 1
a1442 1
      array type and the target pod should have compatible c_type.
d1444 3
a1446 3
   val deref_pod   : { ptr:c_pod,    tgt:c_pod } -> unit
   -- This locates the data pointed at by the pointer pod and copies it
      to the target pod.
d1448 1
a1448 1
   val select_pod  : { record:c_pod, tgt:c_pod, field:name } -> unit
d1450 1
a1450 1
      to the target pod.  The field has to be one of those associated
d1452 1
a1452 1
      pod must also be compatible with the field.
d1454 3
a1456 3
   val coerce_pod  : { union:c_pod,  tgt:c_pod } -> unit
   -- This extracts the content of the union pod and copies it to the target
      pod.  The c_types of the union and the target do not have to
d1459 2
a1460 2
   val copy_index_pod     : c_pod * int -> c_pod
   -- As for index_pod() above, but generates a new pod to provide the
d1463 2
a1464 2
   val copy_deref_pod     : c_pod -> c_pod
   -- As for deref_pod() above, but generates a new pod to provide the
d1467 2
a1468 2
   val copy_select_pod    : c_pod * name -> c_pod
   -- As for select_pod() above, but generates a new pod to provide the
d1471 2
a1472 2
   val copy_coerce_pod    : c_pod -> c_pod
   -- As for coerce_pod() above, but generates a new pod to provide the
d1475 1
a1475 1
   val index_pod_type  :  c_pod -> c_type
d1478 2
a1479 2
   val deref_pod_type  :  c_pod -> c_type
   -- This gives the c_type of the value pointed at by the pointer pod.
d1481 2
a1482 2
   val select_pod_type  :  c_pod * name -> c_type
   -- This gives the c_type of the field selected from the C struct pod.
d1484 2
a1485 2
   val coerce_pod_type  :  c_pod -> c_type 
   -- This gives the c_type of the current member of the C union pod.
d1487 1
a1487 1
   val index_pod_size  :  c_pod -> int
d1490 1
a1490 1
   val deref_pod_size  :  c_pod -> int
d1492 1
a1492 1
      pointer pod.
d1494 1
a1494 1
   val select_pod_size  :  c_pod * name -> int
d1496 1
a1496 1
      struct pod.
d1498 1
a1498 1
   val coerce_pod_size  :  c_pod -> int
d1500 1
a1500 1
      union pod.
d1502 2
a1503 2
   val advance_pod  :  c_pod -> unit
   -- This `shifts' the pod forwards through the workspace by an amount
d1506 2
a1507 2
   val retard_pod  :  c_pod -> unit
   -- As for advance_pod(), except that the pod is shifted `backwards'.
d1511 1
a1511 1
C data - as for the related `setter' functions, these expect the pod
d1516 2
a1517 2
   val get_char  :  c_pod -> c_char
   -- Extracts from a pod with appropriate c_type, a C character
d1520 2
a1521 2
   val get_unsigned_char  :  c_pod -> c_char
   -- Extracts  from a pod with appropriate c_type, a C unsigned
d1524 1
a1524 1
   val get_signed_char    : c_pod -> c_char
d1526 1
a1526 1
      (-127 - 127) from a pod with appropriate c_type.
d1528 2
a1529 2
   val get_short          : c_pod -> c_short_int
   -- Extracts  from a pod with appropriate c_type, a C short value
d1532 2
a1533 2
   val get_int            : c_pod -> c_int
   -- Extracts  from a pod with appropriate c_type, a C int value
d1536 2
a1537 2
   val get_long           : c_pod -> c_long_int
   -- Extracts  from a pod with appropriate c_type, a C long value
d1540 2
a1541 2
   val get_unsigned_short  :  c_pod -> c_short_int
   -- Extracts from a pod with appropriate c_type, a C unsigned short
d1544 2
a1545 2
   val get_unsigned  :  c_pod -> c_int
   -- Extracts from a pod with appropriate c_type, a C unsigned int
d1548 2
a1549 2
   val get_unsigned_long  :  c_pod -> c_long_int
   -- Extracts from a pod with appropriate c_type, a C unsigned long
d1552 2
a1553 2
   val get_word32  :  c_pod -> word32
   -- Extracts from a pod with appropriate c_type a 4-byte quantity
d1556 2
a1557 2
   val get_float  :  c_pod -> c_real
   -- Extracts from a pod with appropriate c_type, a C float represented as an
d1560 2
a1561 2
   val get_double  :  c_pod -> c_double
   -- Extracts from a pod with appropriate c_type, a C double float
d1564 2
a1565 2
   val get_long_double  :  c_pod -> c_long_double
   -- Extracts from a pod with appropriate c_type, a C long double float
d1568 2
a1569 2
   val get_string  :  c_pod -> string
   -- Extracts from a pod with appropriate c_type, an ASCII character string
d1572 7
a1578 7
   val get_data  :  c_pod -> c_pod
   -- Yields a pod containing the dereferenced value of the given pointer.
      This is a synonym for the copy_deref_pod() function.

   val get_struct  :  c_pod -> c_pod list
   -- Yields a list of pods each corresponding to a field of the given
      C struct pod.
d1580 1
a1580 1
   val get_field  :  c_pod * name -> c_pod
d1582 1
a1582 1
      copy_select_pod() function.
d1584 3
a1586 3
   val get_union  :  c_pod -> c_pod
   -- Yields a pod whose value and c_type corresponds to the current member
      of the given union pod.  This is a synonym for the copy_coerce_pod()
d1589 3
a1591 3
   val get_array  :  c_pod -> c_pod list
   -- Yields a list of pods corresponding to the elements of the given
      array pod.
d1593 1
a1593 1
   val get_enum  :  c_pod -> int
d1595 1
a1595 1
      represented by the given pod.
d1598 1
a1598 1
9.4.  structure C.CodeInfo
d1607 1
a1607 1
   type c_codeinfo
d1613 1
a1613 1
   datatype c_decl_entry =
d1616 1
a1616 1
      + UNDEF_DI
d1621 1
a1621 1
      + VAR_DI of { name : name, ctype : c_type box }
d1625 3
a1627 3
      + CODE_DI of { name   : name,
	 	     source : c_type list box,
		     target : c_type box }
d1631 3
a1633 3
      + TYPE_DI of { name : name,
	 	     defn : c_type box,
		     size : int box }
d1640 1
a1640 1
      + CONST_DI of { name : name, ctype : c_type box }
d1644 2
a1645 2
   val new_codeinfo      : unit -> c_codeinfo
   -- This generates a fresh c_codeinfo object.
d1647 2
a1648 2
   val lookup_entry : c_codeinfo -> name -> c_decl_entry
   -- This takes a c_codeinfo and a name and returns up a declaration
d1651 2
a1652 2
   val def_entry    : c_codeinfo * c_decl_entry -> unit
   -- This updates a c_codeinfo object by adding a given entry.
d1654 2
a1655 2
   val hide_entry   : c_codeinfo * name -> unit
   -- This removes the named entry from the given c_codeinfo object.
d1657 1
a1657 1
   val show_entries : c_codeinfo -> c_decl_entry list
d1659 1
a1659 1
      c_codeinfo.
d1661 4
a1664 3
   val elaborate_type : c_codeinfo -> (c_type -> c_type)
   -- This function takes a c_type object and ensures that any
      typenames it contains is used are kept consistent and up-to-date.
d1666 1
a1666 1
   val load_header : filename -> c_codeinfo
d1672 1
a1672 1
9.5.  structure C.Function
d1675 1
a1675 1
   type c_codeset (= CodeSet.c_codeset)
d1677 1
a1677 1
   type c_codeinfo (= CodeInfo.c_codeinfo)
d1681 1
a1681 1
   type c_pod       (= Value.c_pod)
d1689 1
a1689 1
   val attach : (c_codeset * c_codeinfo) -> (name -> c_function)
d1692 2
a1693 2
      foreign code from a c_codeset and then combined with the type
      information associated with the c_codeinfo for that name.  The result
d1697 2
a1698 2
   val call   : c_function -> (c_pod list * c_pod) -> unit
   -- This function takes a c_function object and a list of pods
d1700 2
a1701 2
      returns the result to the other given pod.  Of course, all the type
      information for c_function, argument pods and result pod must match
d1706 1
a1706 1
9.6.  structure C.Diagnostic
d1710 1
a1710 1
diagnostic services for C specific parts of the FI such as c_pods.  It
d1719 1
a1719 1
   type hostel  (= Hostel.hostel)
d1723 1
a1723 1
   type c_pod   (= Value.c_pod)
d1728 2
a1729 2
   val view_pod : c_pod -> string
   -- This provides a string describing the given c_pod object.
d1731 3
a1733 3
   val disp_pod : c_pod -> c_pod
   -- Outputs the string produced by view_pod() on the standard
      output stream and returns the c_pod.
d1735 2
a1736 2
   val pod_info : c_pod ->
	      { hostel    : hostel,
d1746 2
a1747 3
      c_pod.  This can be used by programmers to monitor what is happening
      within a c_pod object and also encourages the construction of additional
      diagnostic tools for their own purposes.
d1750 2
a1751 2
   val pod_data         : c_pod -> int list
   -- This function produces the data associated with a pod in the
d1754 2
a1755 2
   val pod_data_hex     : c_pod -> string
   -- This function produces the data associated with a pod in the
d1758 2
a1759 2
   val pod_data_ascii   : c_pod -> string
   -- This function produces the data associated with a pod in the
d1763 1
a1763 1
10.  Some limitations and future extensions
d1771 2
a1772 1
   - integers
d1774 1
a1774 1
   - machine pointers to general values.
d1778 1
a1778 5
`struct' value or a `float' needs to be passed or returned directly.

It is hoped that this limitation may be removed or at least made less
pressing, perhaps by adding support for foreign calls of functions
whose arguments and results are all 8 bytes in length.
@


1.2
log
@Edits due to reorganisation and added short tutorial section.
@
text
@d8 3
d46 1
a46 1
Finally, you may well be wondering why we are not following convention
d61 1
a61 1
Thackery, Nick Barnes, Dave Berry, Matthew Arcus and Schzen Ooi) have
d65 4
a68 3
dynamic shared libraries and the required ABI's.  I also had some
useful conversations at an early stage with Richard Brooksby who had
had some earlier thoughts about the basic technical issues.
d74 2
a75 2
By way of an introduction to the approach taken, a small example is
now given which shows some of the key features.  To perform this
a83 1

d140 2
a141 2
     val hello_struct = load_codeset("./hello.so",IMMEDIATE_LM);
     > val hello_struct : c_codeset = _
d208 5
a212 5
   > val void_pod : c_type pod(hidden) = _
   > val str_pod : c_type pod(hidden) = _
   > val int_pod1 : c_type pod(hidden) = _
   > val int_pod1 : c_type pod(hidden) = _
   > val ptr_pod : c_type pod(hidden) = _
d237 1
a237 1
   > val hello_sig : c_decl_entry foreign_codeinfo(hidden) = _
d242 1
a242 1
   def_entry(hello_sig,
d259 1
a259 1
   val def_hello = attach(hello_struct,hello_sig);
d301 1
a301 1
This completes this example.
d315 1
a315 2

1.  structure ForeignInterface : FOREIGN_INTERFACE
d323 1
d326 1
a326 1
      structure Debug
d334 1
a334 1
      structure C.Debug
d343 1
a343 2

2.  structure Utilities
d368 2
a369 2
2.1.  Deferred Elements
=======================
d374 1
a374 1
objectss can also be unset once they have been set.
a379 1

d383 1
a383 2
   -- Predicate to determine if the box object has a base value set.

d386 1
a386 1
   -- obtains base value when possible (raising Option otherwise)
d389 1
a389 2
   -- sets the base value of the given box object.

a398 1

d400 1
a400 2
   -- unsets the given box object.

d403 1
a403 1
   -- generates a new box object containing the given base value.
d406 1
a406 3
   -- regenerates the given box objects, so that it contains the
      same optional component.

d409 1
a409 2
   -- generates uninitialised box objects (note that the type is
      specified by context)
d412 1
a412 1
3.  structure Hostel
d415 17
a431 5
This structure defines hostel objects and operations upon them.  A
hostel represents a staticlly allocated `workspace' in which
interfacing can take place as direct actions upon memory.  Naturally,
the hostel has additional structure to make their use more robust and
also convenient.
d435 65
a503 4
   exception ReadOnly
   exception WriteOnly


d509 1
a509 1
        - hostel data may not be accessed by ML.
d512 1
a512 1
        - hostel data is read-only from ML (but not written by ML).
d515 1
a515 1
        - hostel data is write-only from ML (but not readable by ML).
d518 9
a526 1
        - hostel data is readable/writeable from ML (normal status).
a533 1

d538 4
a541 4
      number of other objects (genericly called `pods' here) and these are
      associated with the hostel's workspace area.  The `alloc_policy'
      datatype is used to specify the manner in which space is given to
      these `pod' objects from within the hostel's workspace:
d546 6
a551 1
          pods within the hostel.
d555 1
a555 2
          immediately following all the other pods.  This is the usual
          mode in which hostels are used.
d571 10
a580 8
   -- Each hostel object in effect manages the use by ML of a piece of
      workspace memory and pods are associated with bits of this workspace.
      So, the issue arises of what happens when the workspace memory is
      fully allocated to existing pods.  Various courses of action are
      reasonable and the overflow_policy datatype reflects the choices made
      available to the applications programmer.  A hostel is said to have
      _overflowed_ when an attempt is made to use more space then is
      presently available in the associated workspace.
d595 1
a595 1
	  Explicit calls to expand() give advice on how much extra space needs
d604 1
a604 1
	  allocation simply resumes at the origin and continues on.  Clearly,
d606 2
a607 1
	  insufficient workspace isn't available to cater for all the live pods.
d653 156
a808 1
4.  structure Aliens
d841 1
a841 1
5.  structure LibML
d870 2
a871 2
6.  structure Debug
===================
d933 1
a933 1
7.  structure C
d944 1
a944 1
      structure Debug
d970 2
a971 2
7.1.  structure C.CodeSet
===========================
d1030 1
a1030 1
7.2.  structure C.Type
a1034 6
   type field       (= string)
   -- This type is used to represent names of `C struct' components.

   type member      (= string)
   -- This type is used to name different variants of `C union' objects.

d1043 12
a1054 7
   -- Pointer information may be interpreted in the following ways:

     + LOCAL_PK
       -- Machine address pointing within the associated hostel

     + REMOTE_PK
       -- Machine address pointing to arbitrary memory.
d1056 2
a1057 2
     + RELATIVE_PK
       -- Index value accessing location within associated hostel
d1130 2
a1131 2
			defn : c_type box,
			size : int box }
d1149 2
a1150 2
			fields : c_field list,
			size   : int box }
d1155 3
a1157 3
		     variants : c_variant list ref,
		     size     : int box,
		     current  : c_variant box }
d1165 2
a1166 2
		     elems : enum_value list,
		     card  : int box
d1232 1
a1232 1
7.3.  structure C.Value
d1237 1
a1237 1
   type hostel   (= Hostel.hostel)
d1239 1
a1239 1
   type c_type   (= Type.c_type)
d1241 1
a1241 3
   type member   (= Type.member)

   type field    (= Type.field)
d1244 2
a1245 5
   -- This is an encapsulated ML type used to represent foreign data.
      It consists of two main components - a `value' part and a `type' part.
      The value part generally refers to some raw information contained in an
      associated hostel workspace, whereas the `type' part determines how
      this information is to be interpreted.
a1252 31
      Note that space for foreign data is not directly associated with the
      pod itself, but is generally `reserved' within the associated hostel
      workspace (except `remote' pods - see below).  In particular, it
      is possible, and indeed useful, to have many pod objects accessing
      the same hostel, even at the same location.

   datatype pod_mode
   -- Each pod has an associated `mode' which determines their operational
      characteristics concerning the way in which foreign data is treated.
      The default mode used when a pod is generated is LOCAL_PM; it is
      possible to change the mode that a particular pod is using. The modes
      provided are:

      + LOCAL_PM
        -- Foreign data is sited _locally_ within a hostel workspace.
           Such data can be read and written by both ML and C.

           Pointer values are not restricted i.e. they can be remote,
           local or relative (see Type.pointer_kind above).

      + REMOTE_PM
        -- Foreign data is sited remotely somewhere in the users
           address space.  Such data can only be read - and
           *not* written to - from ML.

           Pointer values are restricted to being remote.


   val pod_mode  :  c_pod -> pod_mode
   -- This is used to inspect the current pod_mode.

a1255 1

a1261 12

   val is_tmp_pod  :  c_pod -> bool
   -- Each pod has a status - either `permanent' or `temporary' and this
      predicate determines if the pod is temporary.  The default status of
      a pod when generated is `permanent'.

      The purpose of the pod status is that permanent pod objects can be
      duplicated (using dup_pod() below) but temporary pods are _not_ duplicated
      and are simply returned.  The function tmp_pod() below duplicates a
      permanent pod AND changes its status to permanent; applying tmp_pod()
      to a temporary pod does nothing except return the argument.

d1263 3
a1265 2
   -- This maps permanent pods into a duplicate except that its status
      becomes temporary.  Temporary pods are simply returned.
a1274 5
      Recall that, just like when creating a pod object, no specific storage
      as such is allocated for foreign data - instead space for this is
      `reserved' within the associated hostel workspace.


d1448 1
a1448 1
   val set_field   : { record:c_pod, field:field, data:c_pod } -> unit
d1452 1
a1452 1
   val set_member  : { union:c_pod, member:member } -> unit
d1490 1
a1490 1
   val select_pod  : { record:c_pod, tgt:c_pod, field:field } -> unit
d1509 1
a1509 1
   val copy_select_pod    : c_pod * field -> c_pod
d1523 1
a1523 1
   val select_pod_type  :  c_pod * field -> c_type
d1536 1
a1536 1
   val select_pod_size  :  c_pod * field -> int
d1622 1
a1622 1
   val get_field  :  c_pod * field -> c_pod
d1640 2
a1641 2
7.4.  structure C.CodeInfo
===========================
d1703 4
d1713 1
a1713 1
7.5.  structure C.Function
a1729 4
   val elaborate_type : c_codeinfo -> (c_type -> c_type)
   -- This function takes a c_type object and ensures that any
      typenames it contains is used are kept consistent and up-to-date.

d1747 2
a1748 2
7.6.  structure C.Debug
=======================
a1765 2


d1803 28
@


1.1
log
@new unit
New file.
@
text
@d7 5
a11 1
 *  $Log$
d28 1
a28 1
also _stateful_ and so has persistent affect.  ML computes values
d32 279
a310 11
Within general ML programming, the assumption is mainly that transient
values tend not to be stateful, with objects being used mainly when
information persists from transaction to transaction.  However, the
programming model taken when using the FI is more procedural and
imperative, relying upon persistent state.  This situation is almost
forced here since the languages being interfaced to are static and
imperative themselves.  In particular, function calling requires
addresses and pointers to stay consistent within a foreign function
call - this can be acheived by providing static memory and having ML
operators construct and analyse corresponding data in these static
areas.
d326 1
a326 1
      structure C.Structure
d329 1
a329 1
      structure C.Signature
d375 2
a376 2
   datatype 'a deferred = DF of ('a option ref)
   -- The deferred objects are encapsulated optional references.
d379 1
a379 1
Available operations for deferred objects are:
d381 2
a382 2
   val someDF    :  'a deferred -> bool
   -- Predicate to determine if the deferred object has a base value set.
d385 1
a385 1
   val getDF     :  'a deferred -> 'a
d388 2
a389 2
   val setDF     :  'a deferred -> 'a -> unit
   -- sets the base value of the given deferred object.
d392 2
a393 2
   val extractDF :  'a deferred -> 'a option
   -- obtains an optional value from the deferred object (for case
d396 2
a397 2
   val updateDF  :  'a deferred -> 'a option -> unit
   -- sets the optional value component of the deferred object to the
d401 2
a402 2
   val resetDF   :  'a deferred -> unit
   -- unsets the given deferred object.
d405 2
a406 2
   val makeDF    :  '_a -> '_a deferred
   -- generates a new deferred object containing the given base value.
d408 2
a409 2
   val newDF     :  '_a deferred -> '_a deferred
   -- regenerates the given deferred objects, so that it contains the
d413 2
a414 2
   val voidDF    :  unit -> '_a deferred
   -- generates uninitialised deferred objects (note that the type is
d441 1
a441 1
      + LOCKED_H
d444 1
a444 1
      + RD_H
d447 1
a447 1
      + WR_H
d450 1
a450 1
      + RDWR_H
d474 1
a474 1
      + FLOAT_AP
d476 1
a476 1
          immeadiately following all the other pods.  This is the usual
d480 1
a480 1
        - As for FLOAT_AP, but each fresh pod is allocated on a
d484 1
a484 1
        - As for FLOAT_AP, but each fresh pod is allocated on a
d493 1
a493 1
   -- Each hostel object in effect manages the use by ML of a peice of
d579 1
a579 1
code allows code to either be linked immeadiately (i.e. at link time)
d596 1
a596 1
   -- Refresh objects and associated values immeadiately.
d688 1
a688 1
   val conv_addr : address -> address -> int
d703 1
a703 1
      structure Structure
d706 1
a706 1
      structure Signature
d725 1
a725 1
the Structure and Signature sub-structures.  The basic idea here is
d727 2
a728 2
locked within a `c_structure' object.  To acces and use this raw
behaviour, another object called a `c_signature' is needed to provide
d730 2
a731 2
c_signature and c_structure objects are combined, this then permits
the raw behaviour contained within the c_structure to be invoked.
d734 1
a734 1
7.1.  structure C.Structure
d740 3
a742 3
   type c_structure
   -- Objects of type c_structure are containers of foreign code.
      Each c_structure object is created as a result of dynamically
d750 1
a750 1
      may occur immeadiately (now, at load time) or may be deferred
d753 1
a753 1
      + IMMEADIATE_LM  - link foreign code immeadiately
d758 2
a759 2
   val load_structure  :  filename * load_mode -> c_structure
   -- This function generates a c_structure by dynamiclly linking
d763 1
a763 1
   val file_info  :  c_structure -> (filename * load_mode)
d765 1
a765 1
      to create the c_structure.
d770 1
a770 1
   val symbols  :  c_structure -> name list
d772 1
a772 1
      within a given c_structure.  This info might indicate name of
d784 1
a784 1
      + NONE_VT   - object cannot be classified as above (but might be either
d787 1
a787 1
   val symbol_info : c_structure * name -> value_type
d790 1
a790 1
      be implemented by returning NONE_VT, but such behaviour would not
d812 1
a812 1
   datatype pointer_mode
d815 1
a815 1
     + LOCAL_PTR
d818 1
a818 1
     + REMOTE_PTR
d821 1
a821 1
     + RELATIVE_PTR
d838 1
a838 1
      stateful (e.g. see STAR_T and UNION_T below).  These constructors will
d844 1
a844 1
      + SIZE_OF of { size : int deferred, ctype : c_type }
d848 1
a848 1
      + VOID_T
d851 1
a851 1
      + CHAR_T
d856 1
a856 1
      + UNSIGNED_CHAR_T
d859 1
a859 1
      + SIGNED_CHAR_T
d862 1
a862 1
      + SHORT_T
d865 1
a865 1
      + INT_T
d868 1
a868 1
      + LONG_T
d871 1
a871 1
      + UNSIGNED_SHORT_T
d874 1
a874 1
      + UNSIGNED_INT_T
d877 1
a877 1
      + UNSIGNED_LONG_T
d880 1
a880 1
      + FLOAT_T
d883 1
a883 1
      + DOUBLE_T
d886 1
a886 1
      + LONG_DOUBLE_T
d889 1
a889 1
      + STRING_T   of { length : int }
d894 3
a896 3
      + TYPENAME_T of { name : name,
			defn : c_type deferred,
			size : int deferred }
d900 1
a900 1
      + STAR_T     of { ctype : c_type, mode : pointer_mode ref }
d913 1
a913 1
      + STRUCT_T   of { tag    : tag option,
d915 1
a915 1
			size   : int deferred }
d919 1
a919 1
      + UNION_T of { tag      : tag option,
d921 2
a922 2
		     size     : int deferred,
		     current  : c_variant deferred }
d926 1
a926 1
      + ARRAY_T of { length : int, ctype : c_type }
d929 1
a929 1
      + ENUM_T  of { tag   : tag option,
d931 1
a931 1
		     card  : int deferred
d939 1
a939 1
		                     size  : int deferred }
d945 3
a947 3
		                     size    : int deferred,
		                     padding : int deferred,
	                             offset  : int deferred }
d1041 1
a1041 1
           local or relative (see Type.pointer_mode above).
d1228 4
a1231 1
      arbitrary.
d1233 5
a1237 2
      This function performs a `type cast' of the pointer to match
      that of the given data object.
d1458 1
a1458 1
7.4.  structure C.Signature
d1467 1
a1467 1
   type c_signature
d1473 1
a1473 1
   datatype c_sig_entry =
d1476 1
a1476 1
      + UNDEF_SE
d1481 1
a1481 1
      + VAR_SE of { name : name, ctype : c_type deferred }
d1485 3
a1487 3
      + CODE_SE of { name   : name,
	 	     source : c_type list deferred,
		     target : c_type deferred }
d1491 3
a1493 3
      + TYPE_SE of { name : name,
	 	     defn : c_type deferred,
		     size : int deferred }
d1500 1
a1500 1
      + CONST_SE of { name : name, ctype : c_type deferred }
d1504 2
a1505 2
   val new_sig      : unit -> c_signature
   -- This generates a fresh c_signature object.
d1507 2
a1508 2
   val lookup_entry : c_signature -> name -> c_sig_entry
   -- This takes a c_signature and a name and returns up a declaration
d1511 2
a1512 2
   val def_entry    : c_signature * c_sig_entry -> unit
   -- This updates a c_signature object by adding a given entry.
d1514 2
a1515 2
   val hide_entry   : c_signature * name -> unit
   -- This removes the named entry from the given c_signature object.
d1517 1
a1517 1
   val show_entries : c_signature -> c_sig_entry list
d1519 1
a1519 1
      c_signature.
d1521 1
a1521 1
   val load_header : filename -> c_signature
d1530 1
a1530 1
   type c_structure (= Structure.c_structure)
d1532 1
a1532 1
   type c_signature (= Signature.c_signature)
d1544 1
a1544 1
   val elaborate_type : c_signature -> (c_type -> c_type)
d1548 1
a1548 1
   val attach : (c_structure * c_signature) -> (name -> c_function)
d1551 2
a1552 2
      foreign code from a c_structure and then combined with the type
      information associated with the c_signature for that name.  The result
@
