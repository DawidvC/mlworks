head	1.4;
access;
symbols
	MLW_daveb_inline_1_4_99:1.4.8
	MLWorks_21c0_1999_03_25:1.4
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.4
	MLWorks_20b0_1998_03_20:1.4
	MLWorks_20m2_1998_02_16:1.4
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.4.5.1.1.1.1
	MLWorks_workspace_97:1.4.7
	MLWorks_dt_wizard:1.4.6
	MLWorks_11c0_1997_09_09:1.4.5.1.1.1
	MLWorks_10r3:1.4.5.1.3
	MLWorks_10r2_551:1.4.5.1.2
	MLWorks_11:1.4.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.4.5.1
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.4.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.4.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.4.5
	MLWorks_BugFix_1997_04_24:1.4
	MLWorks_1_0_r2_Win32_1997_04_11:1.4
	MLWorks_1_0_r2_Unix_1997_04_04:1.4
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.3.1.1
	MLWorks_gui_1996_12_18:1.4.4
	MLWorks_1_0_Win32_1996_12_17:1.4.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.4.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.4.1.1
	MLWorks_1_0_Irix_1996_11_28:1.4.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.2
	MLWorks_1_0_Unix_1996_11_14:1.4.1
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ *  @;


1.4
date	96.11.06.11.25.15;	author matthew;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1
	1.4.4.1
	1.4.5.1
	1.4.6.1
	1.4.7.1
	1.4.8.1;
next	1.3;

1.3
date	96.10.25.11.12.16;	author io;	state Exp;
branches;
next	1.2;

1.2
date	96.10.18.12.31.47;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	96.05.24.01.19.14;	author brianm;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1;
next	;

1.1.1.1
date	96.09.13.11.11.49;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.02.32;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.20.47;	author hope;	state Exp;
branches;
next	;

1.4.1.1
date	96.11.14.12.44.30;	author hope;	state Exp;
branches
	1.4.1.1.1.1;
next	;

1.4.1.1.1.1
date	96.11.28.14.56.27;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.11.22.18.04.54;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.12.17.17.43.50;	author hope;	state Exp;
branches
	1.4.3.1.1.1;
next	;

1.4.3.1.1.1
date	97.02.24.11.33.02;	author hope;	state Exp;
branches;
next	;

1.4.4.1
date	96.12.18.09.37.49;	author hope;	state Exp;
branches;
next	;

1.4.5.1
date	97.05.12.10.30.06;	author hope;	state Exp;
branches
	1.4.5.1.1.1
	1.4.5.1.2.1
	1.4.5.1.3.1;
next	;

1.4.5.1.1.1
date	97.07.28.18.15.45;	author daveb;	state Exp;
branches
	1.4.5.1.1.1.1.1;
next	;

1.4.5.1.1.1.1.1
date	97.10.07.11.40.46;	author jkbrook;	state Exp;
branches;
next	;

1.4.5.1.2.1
date	97.09.08.17.09.18;	author daveb;	state Exp;
branches;
next	;

1.4.5.1.3.1
date	97.09.09.14.04.33;	author daveb;	state Exp;
branches;
next	;

1.4.6.1
date	97.09.10.19.18.55;	author brucem;	state Exp;
branches;
next	;

1.4.7.1
date	97.09.11.20.50.04;	author daveb;	state Exp;
branches;
next	;

1.4.8.1
date	99.04.01.17.53.42;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.4
log
@[Bug #1728]
__integer becomes __int
@
text
@(*  ==== FOREIGN INTERFACE : C SIGNATURES ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *
 *
 *  Revision Log
 *  ------------
 *  $Log: __c_signature.sml,v $
 *  Revision 1.3  1996/10/25  11:12:16  io
 *  [Bug #1547]
 *  updating for current naming conventions
 *
 *  Revision 1.2  1996/10/18  12:31:47  brianm
 *  Fixing problems with normalise_type & size of chars ...
 *
 *  Revision 1.1  1996/05/24  01:19:14  brianm
 *  new unit
 *  New file.
 *
 * Revision 1.4  1996/05/16  14:11:06  brianm
 * Removing dependency on Crash etc. for beta release.
 *
 * Revision 1.3  1996/04/18  16:55:45  jont
 * initbasis becomes basis
 *
 * Revision 1.2  1995/09/08  14:00:15  brianm
 * Further modification for updates and general reorganisation.
 *
 * Revision 1.1  1995/09/07  22:46:46  brianm
 * new unit
 * Rename due to reorganisation & documentation of FI.
 *
 *  Revision 1.1  1995/04/25  11:31:57  brianm
 *  new unit
 *  New file.
 *
 *)

require "^.basis.__int";

require "c_object";
require "signature";
require "types";

require "__c_object";
require "__signature";
require "__types";

require "c_signature";

structure CSignature_ : C_SIGNATURE =
  struct

    structure FISignature : FOREIGN_SIGNATURE = Signature_
    structure FITypes : FOREIGN_TYPES = ForeignTypes_
    open FITypes
      
    structure CObject = CObject_
    open CObject

    type name = CObject.name
    (* filename? *)
    type c_type = CObject.c_type

  (* Mapping *)

    type 'l_type fSignature = 'l_type FISignature.fSignature

    val extract_default  =  fn a => fn x => getOpt(x,a)

  (* Signature ENTRY *)

    datatype c_decl =
        UNDEF_DECL
    |
        VAR_DECL of { name : name, ctype : c_type }
    |
        FUN_DECL of { name   : name,
                      source : c_type list,
                      target : c_type }
    |
        TYPE_DECL of { name : name,
                       defn : c_type,
                       size : int }
    |
        CONST_DECL of { name : name, ctype : c_type }

    local

       fun lookup_entry' cinfo s =
	   extract_default UNDEF_DECL (FISignature.lookupEntry (cinfo,s))

       fun normalise_type' (c_cinfo) =
	 let val lookup'  =  lookup_entry' (c_cinfo)

	       fun field_size (FIELD{size=SOME(sz), ...}, cur_offset) =
                     cur_offset + sz
		 | field_size (FIELD{ctype, ...}, cur_offset) =
		     cur_offset + sizeOf ctype

	       fun size_of_fields (flds) = foldl field_size 0 flds

	       fun variant_size (VARIANT{size=SOME(sz), ...}, cur_size) =
		     Int.max(cur_size, sz)
		 | variant_size (VARIANT{ctype, ...}, cur_size) =
		     Int.max(cur_size,sizeOf ctype)

	       fun size_of_variants (flds) = foldl variant_size 0 flds

	       fun norm_type (ty as TYPENAME{name=nm, size=NONE}) =
		      ( case lookup'(nm) of
			   TYPE_DECL{size=sz, ...} =>
			     TYPENAME{name=nm, size=SOME(sz)}
			|  UNDEF_DECL => ty
			|  _ => raise UnknownTypeName(nm)
		      )

		  | norm_type(FUNCTION_TYPE{source,target}) =
		       FUNCTION_TYPE { source=map norm_type source,
				       target=norm_type target }

		  | norm_type (POINTER_TYPE{ctype, mode}) =
		       POINTER_TYPE {ctype=norm_type(ctype), mode=mode}

		  | norm_type (STRUCT_TYPE{tag,fields,size=NONE}) =
		       let val fields' = norm_fields fields
			   val size'   = size_of_fields fields'
		       in
			   STRUCT_TYPE { tag=tag,
					 fields=fields',
					 size=SOME(size') }
		       end

		  | norm_type (UNION_TYPE{tag,variants,size=NONE,current}) =
		       let val variants' = map norm_variant variants
			   val size'     = size_of_variants variants'
			   val VARIANT{name=cur_name, ...} = current
			   val current' = lookup_variant (variants',cur_name)
		       in
			   UNION_TYPE { tag=tag,
					variants=sort_variant_list(variants'),
					size=SOME(size'),
					current=current' }
		       end

		  | norm_type (ARRAY_TYPE { length, ctype, size=NONE}) =
		       let val ctype' = norm_type ctype
			   val size'  = length * sizeOf ctype'
		       in
			   ARRAY_TYPE { length = length,
					ctype = ctype',
					size = SOME(size')
				      }
		       end

		  | norm_type (ENUM_TYPE { tag, elems, card }) =
		       ENUM_TYPE { tag=tag, elems=elems, card=length elems }

		  | norm_type (ty) = ty

	       and norm_variant (VARIANT{name,ctype,size}) =
		     let val ctype' = norm_type(ctype)
		     in 
			 VARIANT {name=name,ctype=ctype',size=SOME(sizeOf ctype')}
		     end

               and norm_fields (flds) =
   	           let val offset = ref (0)
                       fun norm_field (FIELD{name,ctype,size,padding, ...}) =
		           let val ctype'  = norm_type(ctype)
                               val size'   = sizeOf ctype'
                               val offset' = !offset
		           in 
		               offset := offset' + size';
			       FIELD { name=name,
				       ctype=ctype',
				       size=SOME(size'),
				       padding=padding,
				       offset=SOME offset' }
                           end
                  in
                      map norm_field flds   
 		  end
	   in
	       norm_type                  
	   end

       fun norm_decl cinfo =
	   let val Tnorm = normalise_type' cinfo

	       fun Dnorm (VAR_DECL {name, ctype}) =
                   VAR_DECL {name=name, ctype=Tnorm ctype}

		 | Dnorm (FUN_DECL {name, source, target}) =
		   FUN_DECL { name   = name,
			      source = map Tnorm source,
			      target = Tnorm target
			      }

		 | Dnorm (TYPE_DECL {name,defn, ...}) =
		   let val defn' = Tnorm defn
		   in
		       TYPE_DECL {name=name, defn=defn', size=sizeOf defn'}
		   end

		 | Dnorm (CONST_DECL {name, ctype}) =
		   CONST_DECL {name=name, ctype=Tnorm ctype}

                 | Dnorm (_) = UNDEF_DECL
	   in
	       Dnorm
	   end

    in

       (* C Signature operations *)

       abstype c_signature = AC of c_decl fSignature
       with

	  val newSignature : unit -> c_signature = fn () => AC (FISignature.newSignature ())
	  val lookupEntry : c_signature -> string -> c_decl =
	      fn (AC(cinfo)) => lookup_entry' (cinfo)

	  local
	     exception NameOfEntry
	  in
	     fun name_of_entry(UNDEF_DECL)             = raise NameOfEntry
	       | name_of_entry(VAR_DECL{name, ...})    = name
	       | name_of_entry(FUN_DECL{name, ...})    = name
	       | name_of_entry(TYPE_DECL{name, ...})   = name
	       | name_of_entry(CONST_DECL{name, ...})  = name
	  end

	  val defEntry    : c_signature * c_decl -> unit =
	      fn (_,UNDEF_DECL) => ()
	       | (AC(cinfo),ent) =>
		   let val str   = name_of_entry(ent)
                       val ent'  = norm_decl cinfo ent
		   in
		     FISignature.defEntry (cinfo,(str,ent'))
		   end

	  val removeEntry   : c_signature * name -> unit =
	      fn (AC(cinfo),str) => FISignature.removeEntry (cinfo,str)

	  val showEntries : c_signature -> c_decl list =
	      fn (AC(cinfo)) => map (fn (_,ent) => ent) (FISignature.showEntries cinfo)

	  local
	     exception LoadHeaderUnimplemented
	  in
	     val loadHeader : filename -> c_signature =
		 fn (_) => raise LoadHeaderUnimplemented
	  end

          val normaliseType : c_signature -> (c_type -> c_type) =
              fn (AC(cinfo)) => normalise_type' cinfo

       end
    end
  end;
@


1.4.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 *  Revision 1.4  1996/11/06  11:25:15  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 *  Revision 1.4  1996/11/06  11:25:15  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 *  Revision 1.4  1996/11/06  11:25:15  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.5.1
log
@branched from 1.4
@
text
@a11 4
 *  Revision 1.4  1996/11/06  11:25:15  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 *  Revision 1.4.5.1  1997/05/12  10:30:06  hope
 *  branched from 1.4
 *
@


1.4.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 *  Revision 1.4.5.1  1997/05/12  10:30:06  hope
 *  branched from 1.4
 *
@


1.4.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 *  Revision 1.4.5.1  1997/05/12  10:30:06  hope
 *  branched from 1.4
 *
@


1.4.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 *  Revision 1.4.5.1.1.1  1997/07/28  18:15:45  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.4.4.1
log
@branched from 1.4
@
text
@a11 4
 *  Revision 1.4  1996/11/06  11:25:15  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.3.1
log
@branched from 1.4
@
text
@a11 4
 *  Revision 1.4  1996/11/06  11:25:15  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.3.1.1.1
log
@branched from 1.4.3.1
@
text
@a11 3
 *  Revision 1.4.3.1  1996/12/17  17:43:50  hope
 *  branched from 1.4
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a11 4
 *  Revision 1.4  1996/11/06  11:25:15  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a11 4
 *  Revision 1.4  1996/11/06  11:25:15  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.4.1.1.1.1
log
@branched from 1.4.1.1
@
text
@a11 3
 *  Revision 1.4.1.1  1996/11/14  12:44:30  hope
 *  branched from 1.4
 *
@


1.3
log
@[Bug #1547]
updating for current naming conventions
@
text
@d12 4
d42 1
a42 1
require "^.basis.__integer";
@


1.2
log
@Fixing problems with normalise_type & size of chars ...
@
text
@d12 3
d38 1
a38 6

require "../utils/lists";
require "../utils/__lists";

require "../basis/__integer";
require "../basis/__general";
a52 2
    structure Lists       : LISTS            = Lists_
    structure CObject     : C_OBJECT         = CObject_
d55 3
a57 2

    open General
a58 1
    open FITypes
d60 2
d68 1
a68 18
    val FInew_signature  =  FISignature.new_signature
    val FIlookup_entry  =  FISignature.lookup_entry 
    val FIdef_entry     =  FISignature.def_entry 
    val FIremove_entry    =  FISignature.remove_entry 
    val FIshow_entries  =  FISignature.show_entries

    val unzip    =  Lists.unzip
    val iterate  =  Lists.iterate
    val member   =  Lists.member
    val llength  =  Lists.length
    val tl       =  Lists.tl

    val hd           =    Lists.hd
    val reducel      =    Lists.reducel

    val max          =    Int.max

    val extract_default  =  fn a => fn x => General.getOpt(x,a)
d90 1
a90 1
	   extract_default UNDEF_DECL (FIlookup_entry(cinfo,s))
d93 1
a93 1
	   let val lookup'  =  lookup_entry' (c_cinfo)
d95 1
a95 1
	       fun field_size (cur_offset, FIELD{size=SOME(sz), ...}) =
d97 2
a98 2
		 | field_size (cur_offset, FIELD{ctype, ...}) =
		     cur_offset + size_of(ctype)
d100 1
a100 1
	       fun size_of_fields (flds) = reducel field_size (0,flds)
d102 4
a105 4
	       fun variant_size (cur_size, VARIANT{size=SOME(sz), ...}) =
		     max(cur_size, sz)
		 | variant_size (cur_size, VARIANT{ctype, ...}) =
		     max(cur_size,size_of(ctype))
d107 1
a107 1
	       fun size_of_variants (flds) = reducel variant_size (0,flds)
d147 1
a147 1
			   val size'  = length * size_of(ctype')
d156 1
a156 1
		       ENUM_TYPE { tag=tag, elems=elems, card=llength elems }
d163 1
a163 1
			 VARIANT {name=name,ctype=ctype',size=SOME(size_of(ctype'))}
d170 1
a170 1
                               val size'   = size_of(ctype')
d202 1
a202 1
		       TYPE_DECL {name=name, defn=defn', size=size_of(defn')}
d220 2
a221 3
	  val new_signature : unit -> c_signature = fn () => AC(FInew_signature())

	  val lookup_entry : c_signature -> string -> c_decl =
d234 1
a234 1
	  val def_entry    : c_signature * c_decl -> unit =
d240 1
a240 1
		       FIdef_entry(cinfo,(str,ent'))
d243 2
a244 2
	  val remove_entry   : c_signature * name -> unit =
	      fn (AC(cinfo),str) => FIremove_entry(cinfo,str)
d246 2
a247 2
	  val show_entries : c_signature -> c_decl list =
	      fn (AC(cinfo)) => map (fn (_,ent) => ent) (FIshow_entries cinfo)
d252 1
a252 1
	     val load_header : filename -> c_signature =
d256 1
a256 1
          val normalise_type : c_signature -> (c_type -> c_type) =
a260 1

@


1.1
log
@new unit
New file.
@
text
@d11 5
a15 1
 *  $Log: _c_signature.sml,v $
d106 1
d108 2
d111 2
a112 1
    (* C Signature operations *)
d114 161
a274 2
    abstype c_signature = AC of c_decl fSignature
    with
d276 2
a277 1
       val new_signature : unit -> c_signature = fn () => AC(FInew_signature())
a278 34
       val lookup_entry : c_signature -> string -> c_decl =
	   fn (AC(cinfo)) => fn (s) =>
	      extract_default UNDEF_DECL (FIlookup_entry(cinfo,s))


       local
          exception NameOfEntry
       in
	  fun name_of_entry(UNDEF_DECL)             = raise NameOfEntry
	    | name_of_entry(VAR_DECL{name, ...})    = name
	    | name_of_entry(FUN_DECL{name, ...})    = name
	    | name_of_entry(TYPE_DECL{name, ...})   = name
	    | name_of_entry(CONST_DECL{name, ...})  = name
       end

       val def_entry    : c_signature * c_decl -> unit =
	   fn (_,UNDEF_DECL) => ()
	    | (AC(cinfo),ent) =>
		let val str = name_of_entry(ent)
		in
		    FIdef_entry(cinfo,(str,ent))
		end

       val remove_entry   : c_signature * name -> unit =
	   fn (AC(cinfo),str) => FIremove_entry(cinfo,str)

       val show_entries : c_signature -> c_decl list =
	   fn (AC(cinfo)) => map (fn (_,ent) => ent) (FIshow_entries cinfo)

       local
          exception LoadHeaderUnimplemented
       in
          val load_header : filename -> c_signature =
	      fn (_) => raise LoadHeaderUnimplemented
a281 86
    fun normalise_type(c_cinfo) =
	let val lookup'  =  lookup_entry(c_cinfo)

            fun field_size (cur_offset, FIELD{size=SOME(sz), ...}) =
	          cur_offset + sz
              | field_size (cur_offset, FIELD{ctype, ...}) =
                  cur_offset + size_of(ctype)

            fun size_of_fields (flds) = reducel field_size (0,flds)

            fun variant_size (cur_size, VARIANT{size=SOME(sz), ...}) =
                  max(cur_size, sz)
              | variant_size (cur_size, VARIANT{ctype, ...}) =
                  max(cur_size,size_of(ctype))

            fun size_of_variants (flds) = reducel variant_size (0,flds)

	    fun norm_type (ty as TYPENAME{name=nm, size=NONE}) =
		   ( case lookup'(nm) of
		        TYPE_DECL{size=sz, ...} =>
                          TYPENAME{name=nm, size=SOME(sz)}
                     |  UNDEF_DECL => ty
		     |  _ => raise UnknownTypeName(nm)
                   )
	      
	       | norm_type(FUNCTION_TYPE{source,target}) =
		    FUNCTION_TYPE { source=map norm_type source,
                                    target=norm_type target }

	       | norm_type (POINTER_TYPE{ctype, mode}) =
		    POINTER_TYPE {ctype=norm_type(ctype), mode=mode}

	       | norm_type (STRUCT_TYPE{tag,fields,size=NONE}) =
                    let val fields' = map norm_field fields
                        val size'   = size_of_fields fields'
                    in
                        STRUCT_TYPE { tag=tag,
                                      fields=fields',
                                      size=SOME(size') }
                    end

	       | norm_type (UNION_TYPE{tag,variants,size=NONE,current}) =
                    let val variants' = map norm_variant variants
                        val size'     = size_of_variants variants'
                        val VARIANT{name=cur_name, ...} = current
                        val current' = lookup_variant (variants',cur_name)
                    in
                        UNION_TYPE { tag=tag,
                                     variants=sort_variant_list(variants'),
                                     size=SOME(size'),
                                     current=current' }
                    end

	       | norm_type (ARRAY_TYPE { length, ctype, size=NONE}) =
                    let val ctype' = norm_type ctype
                        val size'  = length * size_of(ctype')
                    in
		        ARRAY_TYPE { length = length,
				     ctype = ctype',
				     size = SOME(size')
				   }
                    end

	       | norm_type (ENUM_TYPE { tag, elems, card }) =
   	            ENUM_TYPE { tag=tag, elems=elems, card=llength elems }

               | norm_type (ty) = ty

	    and norm_variant (VARIANT{name,ctype,size}) =
		  let val ctype' = norm_type(ctype)
		  in 
		      VARIANT {name=name,ctype=ctype',size=SOME(size_of(ctype'))}
		  end

	    and norm_field (FIELD{name,ctype,size,padding,offset}) =
		  let val ctype' = norm_type(ctype)
		  in 
		      FIELD { name=name,
			      ctype=ctype',
			      size=SOME(size_of(ctype')),
			      padding=padding,
			      offset=offset }
		  end
	in
	    norm_type                  
	end
@


1.1.3.1
log
@branched from 1.1
@
text
@d11 1
a11 5
 *  $Log: __c_signature.sml,v $
 *  Revision 1.1  1996/05/24  01:19:14  brianm
 *  new unit
 *  New file.
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d11 1
a11 5
 *  $Log: __c_signature.sml,v $
 *  Revision 1.1  1996/05/24  01:19:14  brianm
 *  new unit
 *  New file.
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d11 1
a11 5
 *  $Log: __c_signature.sml,v $
 *  Revision 1.1  1996/05/24  01:19:14  brianm
 *  new unit
 *  New file.
 *
@
