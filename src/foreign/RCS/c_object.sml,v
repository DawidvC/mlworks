head	1.5;
access;
symbols
	MLW_daveb_inline_1_4_99:1.5.8
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.5
	MLWorks_20c0_1998_08_04:1.5
	MLWorks_20b2c2_1998_06_19:1.5
	MLWorks_20b2_Windows_1998_06_12:1.5
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_11r1:1.5.5.1.1.1.1
	MLWorks_workspace_97:1.5.7
	MLWorks_dt_wizard:1.5.6
	MLWorks_11c0_1997_09_09:1.5.5.1.1.1
	MLWorks_10r3:1.5.5.1.3
	MLWorks_10r2_551:1.5.5.1.2
	MLWorks_11:1.5.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.5.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.5.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.5
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.3.1.1
	MLWorks_gui_1996_12_18:1.5.4
	MLWorks_1_0_Win32_1996_12_17:1.5.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.1.1
	MLWorks_1_0_Irix_1996_11_28:1.5.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.2
	MLWorks_1_0_Unix_1996_11_14:1.5.1
	MLWorks_Open_Beta2_1996_10_11:1.3.3
	MLWorks_License_dev:1.3.2
	MLWorks_1_open_beta_1996_09_13:1.3.1
	MLWorks_Open_Beta_1996_08_22:1.3
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ *  @;


1.5
date	96.11.05.10.34.21;	author andreww;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1
	1.5.5.1
	1.5.6.1
	1.5.7.1
	1.5.8.1;
next	1.4;

1.4
date	96.10.25.11.38.46;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.00.42.47;	author brianm;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1;
next	1.2;

1.2
date	96.05.24.01.19.16;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	96.05.19.13.59.08;	author brianm;	state Exp;
branches;
next	;

1.3.1.1
date	96.09.13.11.11.54;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.10.07.16.02.37;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.10.17.11.20.52;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.11.14.12.44.35;	author hope;	state Exp;
branches
	1.5.1.1.1.1;
next	;

1.5.1.1.1.1
date	96.11.28.14.56.32;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.11.22.18.04.59;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.12.17.17.43.55;	author hope;	state Exp;
branches
	1.5.3.1.1.1;
next	;

1.5.3.1.1.1
date	97.02.24.11.33.14;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.12.18.09.37.54;	author hope;	state Exp;
branches;
next	;

1.5.5.1
date	97.05.12.10.30.11;	author hope;	state Exp;
branches
	1.5.5.1.1.1
	1.5.5.1.2.1
	1.5.5.1.3.1;
next	;

1.5.5.1.1.1
date	97.07.28.18.16.36;	author daveb;	state Exp;
branches
	1.5.5.1.1.1.1.1;
next	;

1.5.5.1.1.1.1.1
date	97.10.07.11.41.29;	author jkbrook;	state Exp;
branches;
next	;

1.5.5.1.2.1
date	97.09.08.17.10.11;	author daveb;	state Exp;
branches;
next	;

1.5.5.1.3.1
date	97.09.09.14.05.40;	author daveb;	state Exp;
branches;
next	;

1.5.6.1
date	97.09.10.19.20.04;	author brucem;	state Exp;
branches;
next	;

1.5.7.1
date	97.09.11.20.51.17;	author daveb;	state Exp;
branches;
next	;

1.5.8.1
date	99.04.01.17.55.00;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Renamed file.
@


1.5
log
@[Bug #1711]
real type is no longer an equality type
@
text
@(*  ==== FOREIGN INTERFACE : C DATA/TYPE STRUCTURES ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  See foreign.doc for documentation.
 *
 *  Revision Log
 *  ------------
 *  $Log: c_object.sml,v $
 *  Revision 1.4  1996/10/25  11:38:46  io
 *  [Bug #1547]
 *  update to current naming conventions
 *
 *  Revision 1.3  1996/08/19  00:42:47  brianm
 *  Adding pointer comparison functions ...
 *
 *  Revision 1.2  1996/05/24  01:19:16  brianm
 *  Beta release modifications.
 *
 *  Revision 1.1  1996/05/19  13:59:08  brianm
 *  new unit
 *  Renamed file.
 *
 * Revision 1.8  1996/04/18  16:58:42  jont
 * initbasis becomes basis
 *
 * Revision 1.7  1996/03/28  14:01:57  matthew
 * Sharing changes
 *
 * Revision 1.6  1995/09/10  17:43:41  brianm
 * Further modification for updates and general reorganisation.
 *
 * Revision 1.5  1995/09/07  22:43:42  brianm
 * Modifications for reorganisation & documentation.
 *
 * Revision 1.4  1995/07/20  16:45:35  brianm
 * adding new_object.
 *
 * Revision 1.3  1995/06/25  18:30:12  brianm
 * Adding remote access, diagnostics and other facilities.
 *
 * Revision 1.2  1995/04/22  01:40:18  brianm
 * General updating to reach prototype level for ML FI.
 *
 * Revision 1.1  1995/03/27  15:49:53  brianm
 * new unit
 * New file.
 *
 *)

require "object";

signature C_OBJECT = 
   sig

     type 'a option = 'a option
     type bytearray
     type name     
     type address  
     type word32
   
     type store

     (* C TYPE INFORMATION *)
 
     (* Pointer information may be interpreted in the following ways:
        - LOCAL_PTR     = Machine address pointing within the associated store
        - REMOTE_PTR    = Machine address pointing outside associated store
        - RELATIVE_PTR  = Index value accessing location within associated store
      *)
     datatype pointer_kind = LOCAL_PTR | RELATIVE_PTR | REMOTE_PTR

     (* The ML type c_type provides a representation of a C type descriptor
        as an ML value.
      *)
     datatype c_type =
        VOID_TYPE
     |
        CHAR_TYPE           | UNSIGNED_CHAR_TYPE | SIGNED_CHAR_TYPE
     |
        SHORT_TYPE          | INT_TYPE           | LONG_TYPE
     |
        UNSIGNED_SHORT_TYPE | UNSIGNED_INT_TYPE  | UNSIGNED_LONG_TYPE
     |
        FLOAT_TYPE          | DOUBLE_TYPE        | LONG_DOUBLE_TYPE
     |
        STRING_TYPE   of { length : int }
     |
        TYPENAME      of { name : name,
                           size : int option }
     |
        FUNCTION_TYPE of { source : c_type list,
                           target : c_type
                         }
     |
        POINTER_TYPE  of { ctype : c_type, mode : pointer_kind }
     |
        STRUCT_TYPE   of { tag    : name option,
                           fields : c_field list,
                           size   : int option }
     |
        UNION_TYPE    of { tag      : name option,
                           variants : c_variant list,
                           size     : int option,
                           current  : c_variant }
     |
        ARRAY_TYPE    of { length : int, ctype : c_type, size : int option }
     |
        ENUM_TYPE     of { tag   : name option,
                           elems : name list,
                           card  : int }

     and  c_variant = VARIANT of { name  : name,
                                   ctype : c_type,
                                   size  : int option }

     and  c_field   = FIELD of { name    : name,
                                 ctype   : c_type,
                                 size    : int option,
                                 padding : int,
                                 offset  : int option }

     exception UnknownTypeName of string

     val sizeOf      : c_type -> int

     val lookup_variant    : (c_variant list * name) -> c_variant
     val sort_variant_list : c_variant list -> c_variant list

     val equalType   : c_type * c_type -> bool

     val structType   : string * (string * c_type) list -> c_type
     val unionType    : string * (string * c_type) list -> c_type
     val ptrType      : c_type -> c_type
     val typeName     : string -> c_type
     val enumType     : string * string list -> c_type


  (* C VALUE STRUCTURE *)

     exception ForeignType
     exception StoreAccess

     exception OutOfBounds
     exception Currency

     exception ReadOnly
     exception WriteOnly

     type c_object

     val object : { ctype:c_type, store:store } -> c_object

     datatype object_mode = LOCAL_OBJECT | REMOTE_OBJECT

     val object_mode       :  c_object -> object_mode
     val setObjectMode   :  c_object * object_mode -> unit

     val objectType       :  c_object -> c_type
     val castObjectType  :  c_object * c_type -> unit

     val newObject    : c_object -> c_object
     val dupObject    : c_object -> c_object
     val tmpObject    : c_object -> c_object

     eqtype c_char

     eqtype c_short_int
     eqtype c_int
     eqtype c_long_int

     type c_real
     type c_double
     type c_long_double

     val setChar           : c_object * c_char -> unit
     val setUnsignedChar  : c_object * c_char -> unit
     val setSignedChar    : c_object * c_char -> unit

     val setShort          : c_object * c_short_int -> unit
     val setInt            : c_object * c_int -> unit
     val setLong           : c_object * c_long_int -> unit

     val setUnsignedShort : c_object * c_short_int -> unit
     val setUnsigned       : c_object * c_int -> unit
     val setUnsignedLong  : c_object * c_long_int -> unit

     val setWord32         : c_object * word32 -> unit

     val setFloat          : c_object * c_real -> unit
     val setDouble         : c_object * c_double -> unit
     val setLongDouble    : c_object * c_long_double -> unit

     val setString         : c_object * string -> unit

     val setAddr           : { obj:c_object, addr:c_object } -> unit

     val setPtrAddr       : { ptr:c_object, addr:c_object } -> unit
     val setPtrAddrOf    : { ptr:c_object, data:c_object } -> unit
     val setPtrData       : { ptr:c_object, data:c_object } -> unit
     val setPtrType       : { ptr:c_object, data:c_object } -> unit
     val castPtrType      : { ptr:c_object, ctype:c_type } -> unit

     val setLocalPtr      : c_object -> unit
     val setRelativePtr   : c_object -> unit
     val setRemotePtr     : c_object -> unit

     val isEqPtr   : c_object * c_object -> bool
     val isNullPtr : c_object -> bool

     val setStruct  : c_object * (c_object list) -> unit
     val setField   : { record:c_object, field:name, data:c_object } -> unit 

     val setMember  : { union:c_object, member:name } -> unit
     val setUnion   : { union:c_object, data:c_object } -> unit

     val setArray   : c_object * (c_object list) * int -> unit
     val setEnum    : c_object * int -> unit


     (* Selectors ... *)

     val indexObject   : { array:c_object,  tgt:c_object, index:int } -> unit
     val derefObject   : { ptr:c_object,    tgt:c_object } -> unit
     val selectObject  : { record:c_object, tgt:c_object, field:name } -> unit
     val coerceObject  : { union:c_object,  tgt:c_object } -> unit

     val copyIndexObject       : c_object * int -> c_object
     val copyDerefObject       : c_object -> c_object
     val copySelectObject      : c_object * name -> c_object
     val copyCoerceObject      : c_object -> c_object

     val indexObjectLocation   : c_object * int -> int 
     val derefObjectLocation   : c_object -> int 
     val selectObjectLocation  : c_object * name -> int 
     val coerceObjectLocation  : c_object -> int 

     val indexObjectType       : c_object -> c_type
     val derefObjectType       : c_object -> c_type
     val selectObjectType      : c_object * name -> c_type
     val coerceObjectType      : c_object -> c_type 

     val indexObjectSize       : c_object -> int
     val derefObjectSize       : c_object -> int
     val selectObjectSize      : c_object * name -> int
     val coerceObjectSize      : c_object -> int

     val nextArrayItem          : c_object -> unit
     val prevArrayItem           : c_object -> unit

     (* Getters ... *)

     val getChar           : c_object -> c_char
     val getUnsignedChar  : c_object -> c_char
     val getSignedChar    : c_object -> c_char

     val getShort          : c_object -> c_short_int
     val getInt            : c_object -> c_int
     val getLong           : c_object -> c_long_int

     val getUnsignedShort : c_object -> c_short_int
     val getUnsigned       : c_object -> c_int
     val getUnsignedLong  : c_object -> c_long_int

     val getWord32         : c_object -> word32

     val getFloat          : c_object -> c_real
     val getDouble         : c_object -> c_double
     val getLongDouble    : c_object -> c_long_double

     val getString         : c_object -> string

     val getData           : c_object -> c_object
         (* dereference pointer *)

     val getStruct         : c_object -> c_object list
         (* field components of a structure *)

     val getField          : c_object * name -> c_object
         (* field of a structure *)

     val getUnion          : c_object -> c_object
     val getArray          : c_object -> c_object list

     val getEnum           : c_object -> int


     (* Diagnostic tools *)

     val cTypeInfo : c_type -> string

     val viewObject : c_object -> string
     val dispObject : c_object -> c_object

     val objectInfo : c_object ->
		{ store    : store,
		  status    : string,
		  currency  : string,
		  mode      : string,
                  langtype  : string,
                  size      : int,
                  base      : address option,
                  offset    : int
                }

     val objectData         : c_object -> int list
     val objectDataHex     : c_object -> string
     val objectDataAscii   : c_object -> string



     (* Additional low-level operations - not for general use *)

     val examine_object    : c_object * address -> unit
     val object_address    : c_object -> address

     val object_value      : c_object * bytearray * int -> unit
     val set_object_value  : c_object * bytearray * int -> unit


   end; (* signature C_OBJECT *)
@


1.5.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 *  Revision 1.5  1996/11/05  10:34:21  andreww
 *  [Bug #1711]
 *  real type is no longer an equality type
 *
@


1.5.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 *  Revision 1.5  1996/11/05  10:34:21  andreww
 *  [Bug #1711]
 *  real type is no longer an equality type
 *
@


1.5.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 *  Revision 1.5  1996/11/05  10:34:21  andreww
 *  [Bug #1711]
 *  real type is no longer an equality type
 *
@


1.5.5.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/05  10:34:21  andreww
 *  [Bug #1711]
 *  real type is no longer an equality type
 *
@


1.5.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 *  Revision 1.5.5.1  1997/05/12  10:30:11  hope
 *  branched from 1.5
 *
@


1.5.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 *  Revision 1.5.5.1  1997/05/12  10:30:11  hope
 *  branched from 1.5
 *
@


1.5.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 *  Revision 1.5.5.1  1997/05/12  10:30:11  hope
 *  branched from 1.5
 *
@


1.5.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 *  Revision 1.5.5.1.1.1  1997/07/28  18:16:36  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.5.4.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/05  10:34:21  andreww
 *  [Bug #1711]
 *  real type is no longer an equality type
 *
@


1.5.3.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/05  10:34:21  andreww
 *  [Bug #1711]
 *  real type is no longer an equality type
 *
@


1.5.3.1.1.1
log
@branched from 1.5.3.1
@
text
@a11 3
 *  Revision 1.5.3.1  1996/12/17  17:43:55  hope
 *  branched from 1.5
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/05  10:34:21  andreww
 *  [Bug #1711]
 *  real type is no longer an equality type
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/05  10:34:21  andreww
 *  [Bug #1711]
 *  real type is no longer an equality type
 *
@


1.5.1.1.1.1
log
@branched from 1.5.1.1
@
text
@a11 3
 *  Revision 1.5.1.1  1996/11/14  12:44:35  hope
 *  branched from 1.5
 *
@


1.4
log
@[Bug #1547]
update to current naming conventions
@
text
@d12 4
d174 3
a176 3
     eqtype c_real
     eqtype c_double
     eqtype c_long_double
@


1.3
log
@Adding pointer comparison functions ...
@
text
@d12 3
a48 1
require "../basis/__general";
d54 1
a54 1
     type 'a option = 'a General.option
d123 1
a123 1
     val size_of      : c_type -> int
d128 1
a128 1
     val equal_type   : c_type * c_type -> bool
d155 1
a155 1
     val set_object_mode   :  c_object * object_mode -> unit
d157 2
a158 2
     val object_type       :  c_object -> c_type
     val cast_object_type  :  c_object * c_type -> unit
d160 3
a162 3
     val new_object    : c_object -> c_object
     val dup_object    : c_object -> c_object
     val tmp_object    : c_object -> c_object
d174 3
a176 3
     val set_char           : c_object * c_char -> unit
     val set_unsigned_char  : c_object * c_char -> unit
     val set_signed_char    : c_object * c_char -> unit
d178 3
a180 3
     val set_short          : c_object * c_short_int -> unit
     val set_int            : c_object * c_int -> unit
     val set_long           : c_object * c_long_int -> unit
d182 3
a184 3
     val set_unsigned_short : c_object * c_short_int -> unit
     val set_unsigned       : c_object * c_int -> unit
     val set_unsigned_long  : c_object * c_long_int -> unit
d186 1
a186 1
     val set_word32         : c_object * word32 -> unit
d188 3
a190 3
     val set_float          : c_object * c_real -> unit
     val set_double         : c_object * c_double -> unit
     val set_long_double    : c_object * c_long_double -> unit
d192 1
a192 1
     val set_string         : c_object * string -> unit
d194 1
a194 1
     val set_addr           : { obj:c_object, addr:c_object } -> unit
d196 5
a200 5
     val set_ptr_addr       : { ptr:c_object, addr:c_object } -> unit
     val set_ptr_addr_of    : { ptr:c_object, data:c_object } -> unit
     val set_ptr_data       : { ptr:c_object, data:c_object } -> unit
     val set_ptr_type       : { ptr:c_object, data:c_object } -> unit
     val cast_ptr_type      : { ptr:c_object, ctype:c_type } -> unit
d202 3
a204 3
     val set_local_ptr      : c_object -> unit
     val set_relative_ptr   : c_object -> unit
     val set_remote_ptr     : c_object -> unit
d206 2
a207 2
     val is_eq_ptr   : c_object * c_object -> bool
     val is_null_ptr : c_object -> bool
d209 2
a210 2
     val set_struct  : c_object * (c_object list) -> unit
     val set_field   : { record:c_object, field:name, data:c_object } -> unit 
d212 2
a213 2
     val set_member  : { union:c_object, member:name } -> unit
     val set_union   : { union:c_object, data:c_object } -> unit
d215 2
a216 2
     val set_array   : c_object * (c_object list) * int -> unit
     val set_enum    : c_object * int -> unit
d221 24
a244 24
     val index_object   : { array:c_object,  tgt:c_object, index:int } -> unit
     val deref_object   : { ptr:c_object,    tgt:c_object } -> unit
     val select_object  : { record:c_object, tgt:c_object, field:name } -> unit
     val coerce_object  : { union:c_object,  tgt:c_object } -> unit

     val copy_index_object       : c_object * int -> c_object
     val copy_deref_object       : c_object -> c_object
     val copy_select_object      : c_object * name -> c_object
     val copy_coerce_object      : c_object -> c_object

     val index_object_location   : c_object * int -> int 
     val deref_object_location   : c_object -> int 
     val select_object_location  : c_object * name -> int 
     val coerce_object_location  : c_object -> int 

     val index_object_type       : c_object -> c_type
     val deref_object_type       : c_object -> c_type
     val select_object_type      : c_object * name -> c_type
     val coerce_object_type      : c_object -> c_type 

     val index_object_size       : c_object -> int
     val deref_object_size       : c_object -> int
     val select_object_size      : c_object * name -> int
     val coerce_object_size      : c_object -> int
d246 2
a247 2
     val next_array_item          : c_object -> unit
     val prev_array_item           : c_object -> unit
d251 3
a253 3
     val get_char           : c_object -> c_char
     val get_unsigned_char  : c_object -> c_char
     val get_signed_char    : c_object -> c_char
d255 3
a257 3
     val get_short          : c_object -> c_short_int
     val get_int            : c_object -> c_int
     val get_long           : c_object -> c_long_int
d259 3
a261 3
     val get_unsigned_short : c_object -> c_short_int
     val get_unsigned       : c_object -> c_int
     val get_unsigned_long  : c_object -> c_long_int
d263 1
a263 1
     val get_word32         : c_object -> word32
d265 3
a267 3
     val get_float          : c_object -> c_real
     val get_double         : c_object -> c_double
     val get_long_double    : c_object -> c_long_double
d269 1
a269 1
     val get_string         : c_object -> string
d271 1
a271 1
     val get_data           : c_object -> c_object
d274 1
a274 1
     val get_struct         : c_object -> c_object list
d277 1
a277 1
     val get_field          : c_object * name -> c_object
d280 2
a281 2
     val get_union          : c_object -> c_object
     val get_array          : c_object -> c_object list
d283 1
a283 1
     val get_enum           : c_object -> int
d288 1
a288 1
     val c_type_info : c_type -> string
d290 2
a291 2
     val view_object : c_object -> string
     val disp_object : c_object -> c_object
d293 1
a293 1
     val object_info : c_object ->
d304 3
a306 3
     val object_data         : c_object -> int list
     val object_data_hex     : c_object -> string
     val object_data_ascii   : c_object -> string
@


1.3.3.1
log
@branched from 1.3
@
text
@a11 3
 *  Revision 1.3  1996/08/19  00:42:47  brianm
 *  Adding pointer comparison functions ...
 *
@


1.3.2.1
log
@branched from 1.3
@
text
@a11 3
 *  Revision 1.3  1996/08/19  00:42:47  brianm
 *  Adding pointer comparison functions ...
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a11 3
 *  Revision 1.3  1996/08/19  00:42:47  brianm
 *  Adding pointer comparison functions ...
 *
@


1.2
log
@Beta release modifications.
@
text
@d12 3
d192 1
a192 1
     val set_addr    : { obj:c_object, addr:c_object } -> unit
d203 3
@


1.1
log
@new unit
Renamed file.
@
text
@d11 5
a15 1
 *  $Log: c_data.sml,v $
d44 1
a44 4

require "types";

require "c_store";
d50 6
a55 20

     structure CStore : C_STORE

     structure FITypes : FOREIGN_TYPES
     sharing FITypes = CStore.FITypes

     type 'a box = 'a FITypes.box
     type bytearray  = FITypes.bytearray
     type name       = FITypes.name
     type address    = FITypes.address
     type word32     = FITypes.word32

     type store = CStore.store 

     (* C TYPE STRUCTURE *)

     type field = string 
     type member = string 
     type enum_value = string
     type tag = string
a65 1

a69 2
        SIZE_OF of { size : int box, ctype : c_type }
     |
d82 6
a87 3
        TYPENAME_TYPE of { name : name,
                        defn : c_type box,
                        size : int box }
d89 1
a89 1
        POINTER_TYPE     of { ctype : c_type, mode : pointer_kind ref }
d91 3
a93 3
        STRUCT_TYPE   of { tag    : tag option,
                        fields : c_field list,
                        size   : int box }
d95 4
a98 4
        UNION_TYPE    of { tag      : tag option,
                        variants : c_variant list ref,
                        size     : int box,
                        current  : c_variant box }
d100 1
a100 1
        ARRAY_TYPE    of { length : int, ctype : c_type }
d102 3
a104 3
        ENUM_TYPE     of { tag   : tag option,
                        elems : enum_value list,
                        card  : int box }
d106 3
a108 3
     and  c_variant = CVNT of { name  : name,
                                ctype : c_type,
                                size  : int box }
d110 5
a114 5
     and  c_field   = CFLD of { name    : name,
                                ctype   : c_type,
                                size    : int box,
                                padding : int box,
                                offset  : int box }
d116 1
a116 1
     val dup_type   : c_type -> c_type
d118 1
a118 1
     val size_of : c_type -> int
d120 2
a121 1
     val equal_type : c_type * c_type -> bool
d123 7
a129 5
     val mk_struct_t   : string * (string * c_type) list -> c_type
     val mk_union_t    : string * (string * c_type) list -> c_type
     val mk_star_t     : c_type -> c_type
     val mk_typename   : string -> c_type
     val mk_enum_t     : string * string list -> c_type
a142 1
     type 'a object
d145 2
a148 3
     val object_to_c_object   :  c_type object -> c_object
     val c_object_to_object   :  c_object -> c_type object

a168 2
     val object : { ctype:c_type, store:store } -> c_object

d202 1
a202 1
     val set_field   : { record:c_object, field:field, data:c_object } -> unit 
d204 1
a204 1
     val set_member  : { union:c_object, member:member } -> unit
d215 1
a215 1
     val select_object  : { record:c_object, tgt:c_object, field:field } -> unit
d220 1
a220 1
     val copy_select_object      : c_object * field -> c_object
d225 1
a225 1
     val select_object_location  : c_object * field -> int 
d230 1
a230 1
     val select_object_type      : c_object * field -> c_type
d235 1
a235 1
     val select_object_size      : c_object * field -> int
d238 2
a239 2
     val advance_object          : c_object -> unit
     val retard_object           : c_object -> unit
d269 1
a269 1
     val get_field          : c_object * field -> c_object
d299 11
@
