head	1.8;
access;
symbols
	MLW_daveb_inline_1_4_99:1.8.8
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.8
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.8
	MLWorks_20b0_1998_04_07:1.8
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.8
	MLWorks_20m1_1997_10_23:1.8
	MLWorks_workspace_97:1.8.7
	MLWorks_dt_wizard:1.8.6
	MLWorks_10r3:1.8.5.1.3
	MLWorks_10r2_551:1.8.5.1.2
	MLWorks_11:1.8.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.8.5.1
	MLWorks_20m0_1997_06_20:1.8
	MLWorks_1_0_r2c2_1997_06_14:1.8.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.8.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.8.5
	MLWorks_BugFix_1997_04_24:1.8
	MLWorks_1_0_r2_Win32_1997_04_11:1.8
	MLWorks_1_0_r2_Unix_1997_04_04:1.8
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.3.1.1
	MLWorks_gui_1996_12_18:1.8.4
	MLWorks_1_0_Win32_1996_12_17:1.8.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.1.1
	MLWorks_1_0_Irix_1996_11_28:1.8.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.2
	MLWorks_1_0_Unix_1996_11_14:1.8.1
	MLWorks_Open_Beta2_1996_10_11:1.5.2
	MLWorks_License_dev:1.5.1
	MLWorks_1_open_beta_1996_09_13:1.4.1
	MLWorks_Open_Beta_1996_08_22:1.4
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ *  @;


1.8
date	96.11.06.11.25.22;	author matthew;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1
	1.8.5.1
	1.8.6.1
	1.8.7.1
	1.8.8.1;
next	1.7;

1.7
date	96.10.25.11.51.32;	author io;	state Exp;
branches;
next	1.6;

1.6
date	96.10.18.12.07.34;	author brianm;	state Exp;
branches;
next	1.5;

1.5
date	96.09.20.14.48.58;	author io;	state Exp;
branches
	1.5.1.1
	1.5.2.1;
next	1.4;

1.4
date	96.08.20.00.51.23;	author brianm;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	96.08.19.10.52.32;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	96.05.24.01.19.14;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	96.05.19.13.59.04;	author brianm;	state Exp;
branches;
next	;

1.4.1.1
date	96.09.13.11.12.42;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.10.07.16.03.25;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.17.11.21.41;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.11.14.12.45.27;	author hope;	state Exp;
branches
	1.8.1.1.1.1;
next	;

1.8.1.1.1.1
date	96.11.28.14.57.20;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.11.22.18.06.00;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.12.17.17.44.43;	author hope;	state Exp;
branches
	1.8.3.1.1.1;
next	;

1.8.3.1.1.1
date	97.02.24.11.34.09;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.12.18.09.38.43;	author hope;	state Exp;
branches;
next	;

1.8.5.1
date	97.05.12.10.31.02;	author hope;	state Exp;
branches
	1.8.5.1.1.1
	1.8.5.1.2.1
	1.8.5.1.3.1;
next	;

1.8.5.1.1.1
date	97.07.28.18.15.50;	author daveb;	state Exp;
branches;
next	;

1.8.5.1.2.1
date	97.09.08.17.09.23;	author daveb;	state Exp;
branches;
next	;

1.8.5.1.3.1
date	97.09.09.14.04.44;	author daveb;	state Exp;
branches;
next	;

1.8.6.1
date	97.09.10.19.18.59;	author brucem;	state Exp;
branches;
next	;

1.8.7.1
date	97.09.11.20.50.09;	author daveb;	state Exp;
branches;
next	;

1.8.8.1
date	99.04.01.17.53.48;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Renamed file.
@


1.8
log
@[Bug #1728]
__integer becomes __int
@
text
@(*  ==== FOREIGN INTERFACE : C DATA/TYPE STRUCTURES ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *
 *
 *  Revision Log
 *  ------------
 *  $Log: __c_object.sml,v $
 *  Revision 1.7  1996/10/25  11:51:32  io
 *  [Bug #1547]
 *  [Bug #1547]
 *  updating for current naming conventions
 *
 *  Revision 1.6  1996/10/18  12:07:34  brianm
 *  Fixing problems with normalise_type & size of chars ...
 *
 *  Revision 1.5  1996/09/20  14:48:58  io
 *  [Bug #1603]
 *  convert ByteArray to Internal.ByteArray
 *
 *  Revision 1.4  1996/08/20  00:51:23  brianm
 *  Adding pointer comparison functions ...
 *
 *  Revision 1.3  1996/08/19  10:52:32  daveb
 *  [Bug #1551]
 *  Fixed offset problem in get_string.
 *
 *  Revision 1.2  1996/05/24  01:19:14  brianm
 *  Beta release modifications.
 *
 *  Revision 1.1  1996/05/19  13:59:06  brianm
 *  new unit
 *  Renamed file.
 *
 * Revision 1.11  1996/05/01  11:48:18  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.10  1996/04/30  15:03:06  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.9  1996/04/18  16:56:02  jont
 * initbasis becomes basis
 *
 * Revision 1.8  1996/02/15  12:29:19  brianm
 * Modifications due to byte-ordering considerations.
 *
 *  Revision 1.7  1995/09/10  17:46:44  brianm
 *  Further modification for updates and general reorganisation.
 *
 *  Revision 1.5  1995/09/07  22:43:38  brianm
 *  Modifications for reorganisation & documentation.
 *
 *  Revision 1.4  1995/07/20  23:07:25  brianm
 *  adding new_object.
 *
 *  Revision 1.3  1995/07/18  12:17:12  brianm
 *  Changing names of deferred data-type operators (stream-edit)
 *
 *  Revision 1.2  1995/06/26  10:40:45  brianm
 *  Adding remote access, diagnostics and other facilities.
 *
 *  Revision 1.1  1995/04/25  11:28:19  brianm
 *  new unit
 *  New file.
 *
 * Revision 1.1  1995/03/27  15:49:53  brianm
 * new unit
 * New file.
 *
 *)

require "^.basis.__int";
require "^.basis.__list";
require "^.utils.__lists";

require "types";
require "structure";
require "object";
require "utils";
require "c_store";

require "__types";
require "__structure";
require "__object";
require "__utils";
require "__store";   (* Matches signature constraint C_STORE *)

require "c_object";

structure CObject_ : C_OBJECT = 
   struct

     structure Lists = Lists_
     structure FIStructure  : FOREIGN_STRUCTURE  = Structure_
     structure FIObject     : FOREIGN_OBJECT   = ForeignObject_
     structure FIUtils      : FOREIGN_UTILS    = ForeignUtils_
     structure CStore       : C_STORE          = ForeignStore_

     open FIUtils
     open FIObject

     structure CStore = CStore
     structure FITypes = CStore.FITypes

     open CStore
     open FITypes

   (* Mapping *)

     (* This stuff should be converted to use Basis word8array material
      * but not done so due to lack of time and
      * uncertainty wrt runtime repercussions
      *)
       
     (* Internal ByteArray operators *)

     structure ByteArray  = MLWorks.Internal.ByteArray

     val bytearray    =  ByteArray.array
 
     val sub_ba       =  ByteArray.sub
     val update_ba    =  ByteArray.update
     val find_ba      =  ByteArray.find_default
     val subarray_ba  =  ByteArray.subarray

     val from_string  =  ByteArray.from_string
     val to_string    =  ByteArray.to_string

     val unsafe_sub_ba      =  MLWorks.Internal.Value.unsafe_bytearray_sub
     val unsafe_update_ba   =  MLWorks.Internal.Value.unsafe_bytearray_update

     (* OBJECT operators *)

     type 'a object  =  'a FIObject.object

     val object'               =    FIObject.object

     val object_address        =    FIObject.objectAddress
     val object_location       =    FIObject.objectLocation

     val to_address            =    FIObject.to_address
     val to_location           =    FIObject.to_location

     val move_object           =    FIObject.move_object
     val offset_object         =    FIObject.offset_object
     val examine_object        =    FIObject.examine_object

     val set_object_address'   =    FIObject.set_object_address'

     val new_object'           =    FIObject.new_object
     val dup_object'           =    FIObject.dup_object
     val tmp_object'           =    FIObject.tmp_object

     val copy_object_value     =    FIObject.copy_object_value
     val copy_object_value'    =    FIObject.copy_object_value'  (* non-checking version *)

     val objectType           =    FIObject.object_type
     val set_object_type       =    FIObject.set_object_type

     val object_size           =    FIObject.objectSize
     val set_object_size       =    FIObject.set_object_size'


     (* Modified OBJECT operators *)

     val object_value      =  FIObject.object_value
     val object_value'     =  FIObject.object_value'
     val set_object_value  =  FIObject.set_object_value 

     (* Implementation Utilities *)

     fun new(ref(x)) = ref(x)

  (* C TYPE STRUCTURE *)
 
     (* Pointer information may be interpreted in the following ways:
        - LOCAL_PTR     = Machine address pointing within the associated store
        - REMOTE_PTR    = Machine address pointing outside associated store
        - RELATIVE_PTR  = Index value accessing location within associated store
      *)
     datatype pointer_kind  = LOCAL_PTR | RELATIVE_PTR | REMOTE_PTR

     (* A representation of C type's in ML ...

	The ML type c_type provides a representation of a C type descriptor
	as an ML value.
     *)
     datatype c_type =
        VOID_TYPE
     |
        CHAR_TYPE           | UNSIGNED_CHAR_TYPE | SIGNED_CHAR_TYPE
     |
        SHORT_TYPE          | INT_TYPE           | LONG_TYPE
     |
        UNSIGNED_SHORT_TYPE | UNSIGNED_INT_TYPE  | UNSIGNED_LONG_TYPE
     |
        FLOAT_TYPE          | DOUBLE_TYPE        | LONG_DOUBLE_TYPE
     |
        STRING_TYPE   of { length : int }
     |
        TYPENAME      of { name : name,
                           size : int option }
     |
        FUNCTION_TYPE of { source : c_type list,
                           target : c_type
                         }
     |
        POINTER_TYPE  of { ctype : c_type, mode : pointer_kind }
     |
        STRUCT_TYPE   of { tag    : name option,
                           fields : c_field list,
                           size   : int option }
     |
        UNION_TYPE    of { tag      : name option,
                           variants : c_variant list,
                           size     : int option,
                           current  : c_variant }
     |
        ARRAY_TYPE    of { length : int, ctype : c_type, size : int option }
     |
        ENUM_TYPE     of { tag   : name option,
                           elems : name list,
                           card  : int }

     and  c_variant = VARIANT of { name  : name,
                                   ctype : c_type,
                                   size  : int option }

     and  c_field   = FIELD of { name    : name,
                                 ctype   : c_type,
                                 size    : int option,
                                 padding : int,
                                 offset  : int option }

     local
	fun lookup_itemlist p (ni_lst, nm) = 
	  valOf (* could raise Option *) (List.find (p nm) ni_lst)

	fun find_field   nm (FIELD{name, ...}) =  (name = nm)

	fun find_variant nm (VARIANT{name, ...}) =  (name = nm)
     in
        val lookup_variant  = lookup_itemlist find_variant
        val lookup_field    = lookup_itemlist find_field
     end


     fun variant_name (VARIANT{name, ...}) = name
     fun field_name   (FIELD{name, ...}) = name

     (* Size constants *)
     val char_size                = 4
     val short_int_size           = 2
     val int_size                 = 4
     val long_int_size            = 4
     val real_size                = 4

     local
       val unsigned_short_int_size  = short_int_size
       val unsigned_int_size        = int_size
       val unsigned_long_int_size   = long_int_size

       val double_size              = real_size
       val long_double_size         = real_size

       val pointer_size             = int_size
       val enum_size                = int_size
       val void_size                = 0

       fun pad_size_of (CHAR_TYPE             ,_)   = int_size
         | pad_size_of (UNSIGNED_CHAR_TYPE    ,_)   = int_size
         | pad_size_of (SIGNED_CHAR_TYPE      ,_)   = int_size
         | pad_size_of (SHORT_TYPE            ,_)   = int_size
         | pad_size_of (UNSIGNED_SHORT_TYPE   ,_)   = int_size
         | pad_size_of (_, size) = size

       fun padding_adjustment(_,_,_) = 0
     in

       exception UnknownTypeName of string

       fun sizeOf(VOID_TYPE)             = void_size

         | sizeOf(CHAR_TYPE)             = char_size
         | sizeOf(UNSIGNED_CHAR_TYPE)    = char_size
         | sizeOf(SIGNED_CHAR_TYPE)      = char_size

         | sizeOf(SHORT_TYPE)            = short_int_size
         | sizeOf(INT_TYPE)              = int_size
         | sizeOf(LONG_TYPE)             = long_int_size

         | sizeOf(UNSIGNED_SHORT_TYPE)   = unsigned_short_int_size
         | sizeOf(UNSIGNED_INT_TYPE)     = unsigned_int_size
         | sizeOf(UNSIGNED_LONG_TYPE)    = unsigned_long_int_size

         | sizeOf(FLOAT_TYPE)            = real_size
         | sizeOf(DOUBLE_TYPE)           = double_size
         | sizeOf(LONG_DOUBLE_TYPE)      = long_double_size

         | sizeOf(STRING_TYPE{length})   = length  (* includes null sentinel *)
         
         | sizeOf(TYPENAME{size=SOME(size), ...}) = size          

         | sizeOf(TYPENAME{name, ...}) = raise UnknownTypeName(name)

         | sizeOf(POINTER_TYPE _)  = pointer_size

         | sizeOf(FUNCTION_TYPE _) = pointer_size

         | sizeOf(STRUCT_TYPE{size=SOME(size), ...}) = size

         | sizeOf(STRUCT_TYPE{fields, ...}) = size_of_struct(fields)

         | sizeOf(UNION_TYPE{size=SOME(size), ...}) = size

         | sizeOf(UNION_TYPE{variants, ...}) = size_of_union(variants)

         | sizeOf(ARRAY_TYPE { size=SOME(size), ... }) = size

         | sizeOf(ARRAY_TYPE { length, ctype, ... }) = length * sizeOf(ctype)

         | sizeOf(ENUM_TYPE _) = enum_size

       and size_of_field (FIELD{size=SOME sz, ...},cur_offset) = sz + cur_offset
         | size_of_field (FIELD{ctype, ...}, cur_offset) =
           let val new_size    = sizeOf ctype
               val pad_size    = pad_size_of (ctype,new_size)
           in
               pad_size + cur_offset
           end

       and size_of_struct fld_lst = foldl size_of_field 0 fld_lst

       and size_of_variant(VARIANT{size=SOME(size), ctype, ...}, cur_size) =
	 Int.max (size,cur_size)
         | size_of_variant(VARIANT{size, ctype, ...}, cur_size) = 
	 Int.max (sizeOf ctype,cur_size)

       and size_of_union(vnt_lst) = foldl size_of_variant 0 vnt_lst
     end


     local
        fun variant_leq (VARIANT{name=nm1, ...}, VARIANT{name=nm2, ...}) =
            (nm1 <= nm2)
     in
        fun sort_variant_list(vnt_l) =
            if Lists.check_order variant_leq vnt_l
            then vnt_l
            else Lists.msort variant_leq vnt_l
     end;

     local
       fun equal_type'
             ( TYPENAME{name=nm1, ...}
             , TYPENAME{name=nm2, ...}
             ) = (nm1 = nm2)

         | equal_type'
             ( POINTER_TYPE{ctype=cty1, ...}
             , POINTER_TYPE{ctype=cty2, ...}
             ) = equal_type'(cty1,cty2)

         | equal_type'
             ( STRUCT_TYPE{tag=SOME(tg1), ...}
             , STRUCT_TYPE{tag=SOME(tg2), ...}
             ) = (tg1 = tg2)

         | equal_type'
             ( STRUCT_TYPE{tag=NONE,fields=fld_lst1, ...}
             , STRUCT_TYPE{tag=NONE,fields=fld_lst2, ...}
             ) = equal_fields(fld_lst1,fld_lst2)

         | equal_type'
             ( UNION_TYPE{tag=SOME(tg1), ...}
             , UNION_TYPE{tag=SOME(tg2), ...}
             ) = (tg1 = tg2)

         | equal_type'
             ( UNION_TYPE{tag=NONE,variants=vnt_lst1, ...}
             , UNION_TYPE{tag=NONE,variants=vnt_lst2, ...}
             ) = equal_variants(vnt_lst1,vnt_lst2)

         | equal_type'(cty1,cty2) = (cty1 = cty2)    

       and equal_variants (vl1, vl2) = 
           if (length vl1 = length vl2)
           then let val vl1' = sort_variant_list(vl1)
                    val vl2' = sort_variant_list(vl2)
                in
                   equal_variants'(vl1',vl2')
                end
           else false

       and equal_variants' 
             ( VARIANT{name=nm1, ctype=cty1, ...}::vnt_lst1
             , VARIANT{name=nm2, ctype=cty2, ...}::vnt_lst2
             ) = (nm1 = nm2) andalso equal_type'(cty1,cty2)
                             andalso equal_variants'(vnt_lst1,vnt_lst2)

         | equal_variants'([],[])  = true

         | equal_variants'(_,_)    = false

       and equal_fields
             ( FIELD{name=nm1, ctype=cty1, ...}::fld_lst1
             , FIELD{name=nm2, ctype=cty2, ...}::fld_lst2
             ) = (nm1 = nm2) andalso equal_type'(cty1,cty2)
                             andalso equal_fields(fld_lst1,fld_lst2)

         | equal_fields([],[])  = true

         | equal_fields(_,_)    = false
     in

       fun equalType(cty1,cty2) =
             (cty1 = cty2) orelse equal_type'(cty1,cty2)

     end

     local
       fun mk_field (str,ty) =
           FIELD { name    = str,
                   ctype   = ty,
                   size    = NONE,
                   padding = 0,
                   offset  = NONE }

       fun mk_variant (str,ty) =
           VARIANT { name    = str,
                     ctype   = ty,
                     size    = NONE }
     in

       fun structType (nm,flds) =
	   STRUCT_TYPE { tag    = SOME(nm),
 		         fields = map mk_field flds, 
		         size   = NONE
		       }

       fun unionType (nm,vnts) =
	     let val variants' = sort_variant_list(map mk_variant vnts)
	     in
		 UNION_TYPE { tag      = SOME(nm),
			      variants = variants',
			      size     = NONE,
			      current  = hd variants'
			    }
	     end

       fun ptrType (ty) =
           POINTER_TYPE { ctype = ty, mode = LOCAL_PTR }

       fun typeName (nm) =
           TYPENAME { name = nm,
                      size = NONE
                    }

       fun enumType (nm,elem_lst) =
           ENUM_TYPE { tag   = SOME(nm),
                       elems = elem_lst,
                       card  = length elem_lst
                     }
     end


  (* C VALUE STRUCTURE *)

     type c_object  =  c_type object

     val object_mode      : c_object -> object_mode         =  objectMode
     val setObjectMode  : c_object * object_mode -> unit  =  set_object_mode

     val examine_object   : c_object * address -> unit  =  examine_object
     val object_address   : c_object -> address         =  object_address

     val object_value     : c_object * bytearray * int -> unit  =  object_value
     val set_object_value : c_object * bytearray * int -> unit  =  set_object_value

     type c_char   =  int

     type c_short_int = int
     type c_int       = int
     type c_long_int  = int

     type c_real         = real
     type c_double       = real
     type c_long_double  = real

     exception ForeignType
     exception StoreAccess

     val newObject : c_object -> c_object =
	 fn (obj) =>
	   let val new_object   =  new_object'(obj)
	       val new_ctype =  objectType(obj)
	   in
	     set_object_type(new_object,new_ctype);
	     new_object
	   end

     val dupObject : c_object -> c_object =
	 fn (obj) =>
	   let val new_object   =  dup_object'(obj)
	       val new_ctype =  objectType(obj)
	   in
	     set_object_type(new_object,new_ctype);
	     new_object
	   end

     val tmpObject : c_object -> c_object =
	 fn (obj) =>
	   let val new_object   =  tmp_object'(obj)
	       val new_ctype =  objectType(obj)
	   in
	     set_object_type(new_object,new_ctype);
	     new_object
	   end

     fun object{ctype,store} =
	 let val object_size = sizeOf(ctype)
	 in
	     object'{ lang_type  =  ctype,
  		      status     =  PERMANENT_OBJECT,
		      size       =  object_size,
		      mode       =  LOCAL_OBJECT,
		      currency   =  true,
		      store      =  store }
	 end

     fun copy_object_info{from=src_pd,to=tgt_pd} =
         let val from_type = objectType(src_pd)
             val from_size = object_size(src_pd)
         in
           set_object_type(tgt_pd,from_type);
           set_object_size(tgt_pd,from_size);
           copy_object_value{from=src_pd,to=tgt_pd}
         end


     (* Object extraction/insertion utilities *)

     local
	val data_buffer = bytearray(sizeOf(LONG_DOUBLE_TYPE),0)
	(* To cut down on allocation, a fixed data buffer is used
	   for passing small items such as characters, integers and
	   reals (of various standard sizes).

	   !! NOT THREAD-SAFE !!
	 *)


        val half_int = int_size div 2

     in

	fun f_object_value(obj) =
	      ( object_value(obj,data_buffer,0);
		data_buffer
	      )

	fun f_object_value'(obj) =
	      ( object_value'(obj,data_buffer,0);
		data_buffer
	      )

	fun set_int'(obj,i) =
	  ( int_to_bytearray{len=int_size,arr=data_buffer,src=i,st=0};
	    set_object_value(obj,data_buffer,0)
	  ) handle _ => raise StoreAccess

	fun get_int'(obj)  =
	    bytearray_to_int{arr=f_object_value(obj),st=0,len=int_size}

        fun get_int2' (hi_ref,lo_ref) =
            let fun get2 (obj) =
                    let val ba = f_object_value (obj)
                    in
		        hi_ref := bytearray_to_int {arr=ba,st=0,len=half_int} ;
		        lo_ref := bytearray_to_int {arr=ba,st=half_int,len=half_int}
                    end
            in
                get2
            end

	fun set_word32'(obj,wd) =
	  ( word32_to_bytearray{arr=data_buffer,src=wd,st=0};
	    set_object_value(obj,data_buffer,0)
	  ) handle _ => raise StoreAccess

	fun get_word32'(obj)  =  bytearray_to_word32{arr=f_object_value(obj),st=0}

	fun set_char'(obj,ch) =
	    if (0 <= ch) andalso (ch < 256)
	    then ( update_ba(data_buffer,0,ch);
		   set_object_value(obj,data_buffer,0)
		 )
	    else raise StoreAccess

	fun get_char'(obj) =
	    ( object_value(obj,data_buffer,0);
	      sub_ba(data_buffer,0)
	    )

	fun get_signed_char'(obj) =
	    let val ch = get_char'(obj)
	    in
		if (ch < 128) then ch else (ch - 256)
	    end

	fun address_to_bytearray(addr) =
	      ( word32_to_bytearray{arr=data_buffer,src=addr,st=0};
		data_buffer
	      )

	fun bytearray_to_address(ba)  =  bytearray_to_word32{arr=ba,st=0}

	local
	   val real_size = sizeOf(LONG_DOUBLE_TYPE)
	in
	   fun get_real'(obj) =
	       let val buffer   = f_object_value(obj)
		   val repn_str = bytearray_to_string{arr=buffer,st=0,len=real_size}
	       in
		 MLWorks.Internal.Value.string_to_real repn_str
	       end
	end

	fun set_real'(obj,r) =
	    let val real_str = MLWorks.Internal.Value.real_to_string r
	    in
		string_to_bytearray{arr=data_buffer,src=real_str,st=0};
		set_object_value(obj,data_buffer,0)
	    end

	local

	   fun zerop (i) = (i = 0)

	   fun find_string_end(length,buffer) = find_ba (zerop,length-1) buffer

           val cache_size   = ref 256
           val string_cache = ref (bytearray (!cache_size,0))

           fun get_buffer (len) =
               if len <= !cache_size then !string_cache else
               let val new_cache = bytearray (len,0)
               in
 		   string_cache := new_cache ;
		   cache_size   := len ;
		   new_cache
               end

	in

	   fun get_string' (obj,length) =
	       let val buffer = get_buffer (length)
	       in
		   object_value(obj,buffer,0);
		   let val end_idx = find_string_end(length,buffer)
		       val str_buf = subarray_ba(buffer,0,end_idx+1)
		   in
		       to_string(str_buf)
		   end
	       end

	   fun setString' (obj,length,str) =
               if (size(str) <= length)
               then set_object_value(obj,from_string(str),0)
               else raise StoreAccess
	end
     end

     (* Setters ... *)

     fun setUnsignedChar(obj,ch) =
         case objectType(obj) of
           CHAR_TYPE          => set_char'(obj,ch)
         |
           UNSIGNED_CHAR_TYPE => set_char'(obj,ch)
         |
           _ => raise ForeignType

     val setChar = setUnsignedChar

     fun setSignedChar(obj,ch) =
         case objectType(obj) of
           CHAR_TYPE        => set_char'(obj,(ch mod 256))
         |
           SIGNED_CHAR_TYPE => set_char'(obj,(ch mod 256))
         |
           _ => raise ForeignType

     fun setShort(obj,i) =
         case objectType(obj) of
           SHORT_TYPE  => set_int'(obj,i)
         |
           _ => raise ForeignType

     fun setInt(obj,i) =
         case objectType(obj) of
           INT_TYPE  => set_int'(obj,i)
         |
           _ => raise ForeignType

     fun setLong(obj,i) =
         case objectType(obj) of
           LONG_TYPE  => set_int'(obj,i)
         |
           _ => raise ForeignType

     fun setUnsignedShort(obj,i) =
         case objectType(obj) of
           UNSIGNED_SHORT_TYPE  => set_int'(obj,i)
         |
           _ => raise ForeignType

     fun setUnsigned(obj,i) =
         case objectType(obj) of
           UNSIGNED_INT_TYPE  => set_int'(obj,i)
         |
           _ => raise ForeignType

     fun setUnsignedLong(obj,i) =
         case objectType(obj) of
           UNSIGNED_LONG_TYPE  => set_int'(obj,i)
         |
           _ => raise ForeignType

     fun setWord32(obj,wd) =
         case objectType(obj) of
           UNSIGNED_INT_TYPE  => set_word32'(obj,wd)
         |
           _ => raise ForeignType

     fun setEnum(obj,i) =
         case objectType(obj) of
           ENUM_TYPE{card, ...} =>
             (
              (if (0 <= i) andalso (i < card)
               then set_int'(obj,i)
               else raise ForeignType
              ) handle Option => raise ForeignType
             )
         |
           _ => raise ForeignType


     fun setFloat(obj,r) =
         case objectType(obj) of
           FLOAT_TYPE  => set_real'(obj,r)
         |
           _ => raise ForeignType

     fun setDouble(obj,r) =
         case objectType(obj) of
           DOUBLE_TYPE  => set_real'(obj,r)
         |
           _ => raise ForeignType

     fun setLongDouble(obj,r) =
         case objectType(obj) of
           LONG_DOUBLE_TYPE  => set_real'(obj,r)
         |
           _ => raise ForeignType

 
     fun setString(obj, str) =
         case objectType(obj) of
           STRING_TYPE{length}  => setString' (obj,length,str)
         |
           _ => raise ForeignType


     fun setLocalPtr(ptr_object) =
         case objectType(ptr_object) of
           POINTER_TYPE{mode=RELATIVE_PTR, ctype} =>
              let val rel_ptr = f_object_value(ptr_object)
                  val idx     = bytearray_to_int{arr=rel_ptr,st=0,len=int_size}
                  val addr    = to_address(ptr_object,idx)
                  val ba      = address_to_bytearray(addr)          
              in
                  set_object_type(ptr_object,POINTER_TYPE{ctype=ctype,mode=LOCAL_PTR});
                  set_object_value(ptr_object,ba,0);
		  ()
              end
         |
           POINTER_TYPE(_) => ()
         |
           _ => raise ForeignType


     fun setRelativePtr(ptr_object) =
         case objectType(ptr_object) of
           POINTER_TYPE{mode=LOCAL_PTR, ctype} =>
              let val abs_ptr = f_object_value(ptr_object)
                  val addr    = bytearray_to_address(abs_ptr)
                  val idx     = to_location(ptr_object,addr)
              in
                  set_int'(ptr_object,idx);
                  set_object_type(ptr_object,POINTER_TYPE{ctype=ctype,mode=LOCAL_PTR});
		  ()
              end
         |
           POINTER_TYPE(_) => ()
         |
           _ => raise ForeignType


     fun setRemotePtr(ptr_object) =
         case objectType(ptr_object) of
           POINTER_TYPE{mode=REMOTE_PTR, ...} => ()
         |
           POINTER_TYPE{mode=LOCAL_PTR, ctype} =>
             ( set_object_type(ptr_object,POINTER_TYPE{ctype=ctype,mode=REMOTE_PTR}) )
         |
           POINTER_TYPE{mode, ctype} =>
             ( setLocalPtr(ptr_object);
               set_object_type(ptr_object,POINTER_TYPE{ctype=ctype,mode=REMOTE_PTR})
             )
         |
           _ => raise ForeignType

     local
         fun set_array'(elem_object,rel_offset,contents,buf) =
             let fun doit([]) = ()
                   | doit(p::pl) =
                     ( object_value(p,buf,0);
                       set_object_value(elem_object,buf,0);
                       offset_object(elem_object,rel_offset);
                       doit(pl)
                     )
             in
                doit(contents)
             end
     in
       (* length is overloaded here and so the horrid qualification *)
         fun setArray(obj,contents,st) =
             case objectType(obj) of
                ARRAY_TYPE{length,ctype,size} =>
                  if (st + FullPervasiveLibrary_.length contents > length)
                  then raise StoreAccess
                  else let val elem_size   =  sizeOf ctype
                           val elem_object    =  dup_object'(obj)
                           val init_posn   =  st * elem_size
                           val elem_buffer =  bytearray(elem_size,0)
                       in
                           set_object_type(elem_object,ctype);
                           set_object_size(elem_object,elem_size);
                           offset_object(elem_object,init_posn);
                           set_array'(elem_object,elem_size,contents,elem_buffer);
                           set_object_currency(obj,true)
                       end
             |
                _ => raise ForeignType
     end

     local
        fun set_struct'(fld_object,fld_lst,object_lst) =
            let fun doit(offset,FIELD{size, ...}::fld_lst,p::pl) =
                    ( offset_object(fld_object,offset);
                      copy_object_info{from=p,to=fld_object};
                      doit(valOf size,fld_lst,pl)
                    )
                  | doit(_,_::_,_) = raise ForeignType
                  | doit(_,_,_)    = ()
            in
                doit(0,fld_lst,object_lst)
            end
     in
         fun setStruct(obj,items) =
             case objectType(obj) of
               STRUCT_TYPE{fields, ...} =>
                  if (length fields <> length items)
                  then raise StoreAccess
                  else ( set_struct'(dup_object'(obj),fields,items);
			 set_object_currency(obj,true)
                       )
             |
                _ => raise ForeignType

	 fun setField{record=obj,field=name,data} =
	     case objectType(obj) of
	       STRUCT_TYPE{fields, ...} =>
		  let val FIELD{ctype, offset, ...} = lookup_field(fields,name)
		  in
		      if not(equalType(objectType(data),ctype))
                      then raise StoreAccess
                      else let val size   = sizeOf(ctype)
			       val offset = valOf offset
			       val obj'   = dup_object'(obj)
			   in
			       set_object_type(obj',ctype);
			       set_object_size(obj',size);
			       offset_object(obj',offset);
			       copy_object_value{from=data,to=obj'}
			   end
		  end
	     |
		_ =>  raise ForeignType
     end

     fun setUnion{union=obj,data} =
         case objectType(obj) of
           UNION_TYPE{current=variant, ...} =>
              let val VARIANT{ctype, ...} = variant
              in
                  if not(equalType(objectType(data),ctype))
                  then raise StoreAccess
                  else copy_object_value{from=data,to=obj}
              end
         |
            _ => raise ForeignType

     fun setMember{union=obj,member} =
         case objectType(obj) of
           UNION_TYPE{tag,variants,size, ...} =>
              let val current'  = lookup_variant(variants,member)
                  val union_ty' = UNION_TYPE { tag=tag,
					       variants=variants,
					       size=size,
					       current=current' }
              in
                  set_object_type(obj,union_ty')
              end
         |
            _ => raise ForeignType

     fun indexObject{array=src_pd,tgt=tgt_pd,index=idx} =
         case objectType(src_pd) of
           ARRAY_TYPE{length,ctype, ...} =>
              if (0 <= idx) andalso (idx < length)
              then let val elem_size = sizeOf(ctype)
                       val base_posn = object_location(src_pd)
                       val abs_posn  = base_posn + (idx * elem_size)
                   in
                       set_object_type(tgt_pd,ctype);
                       set_object_size(tgt_pd,elem_size);          
                       move_object(tgt_pd,abs_posn);
		       set_object_currency(tgt_pd,true)
                   end
              else raise StoreAccess
         |
            _ => raise ForeignType

     fun derefObject{ptr=src_pd,tgt=tgt_pd} =
         case objectType(src_pd) of
           POINTER_TYPE{ctype, mode=RELATIVE_PTR} =>
              let val item_size = sizeOf(ctype)
                  val rel_ptr   = f_object_value(src_pd)
                  val loc_posn  = bytearray_to_int{arr=rel_ptr,st=0,len=int_size}
              in
                  set_object_type(tgt_pd,ctype);
                  set_object_size(tgt_pd,item_size);               
                  move_object(tgt_pd,loc_posn);
		  set_object_currency(tgt_pd,true)
              end
         |
           POINTER_TYPE{ctype, mode=LOCAL_PTR} =>
              let val item_size = sizeOf(ctype)
                  val loc_ptr   = f_object_value(src_pd)
                  val addr      = bytearray_to_address(loc_ptr)
                  val loc_posn  = to_location(src_pd,addr)
              in
                  set_object_type(tgt_pd,ctype);
                  set_object_size(tgt_pd,item_size);               
                  move_object(tgt_pd,loc_posn);
		  set_object_currency(tgt_pd,true)
              end
         |
           POINTER_TYPE{ctype, mode=REMOTE_PTR} =>
              let val item_size = sizeOf(ctype)
                  val far_ptr   = f_object_value(src_pd)
                  val addr      = bytearray_to_word32{arr=far_ptr,st=0}
              in
                  set_object_type(tgt_pd,ctype);
                  set_object_size(tgt_pd,item_size);               
                  examine_object(tgt_pd,addr)
              end
         |
            _ => raise ForeignType

     fun selectObject{record=src_pd,tgt=tgt_pd,field=name} =
	 case objectType(src_pd) of
	   STRUCT_TYPE{fields, ...} =>
	     let val field     =  lookup_field(fields,name)
		 val FIELD{offset,ctype, ...}  =  field
		 val obj_size  =  sizeOf(ctype)
		 val fld_posn  =  valOf offset
                 val src_posn  =  object_location(src_pd)
                 val abs_posn  =  fld_posn + src_posn
	     in
		 set_object_type(tgt_pd,ctype);
		 set_object_size(tgt_pd,obj_size);
		 move_object(tgt_pd,abs_posn);
		 set_object_currency(tgt_pd,true)
	     end
	 |
	    _ => raise ForeignType

     fun coerceObject{union=src_pd,tgt=tgt_pd} =
         case objectType(src_pd) of
           UNION_TYPE{current=variant, ...} =>
              let val VARIANT{ctype, ...} = variant
                  val new_size = sizeOf(ctype)
              in
                  set_object_type(tgt_pd,ctype);
                  set_object_size(tgt_pd,new_size);
		  set_object_currency(tgt_pd,objectCurrency(src_pd))
              end
         |
            _ => raise ForeignType


     fun copyIndexObject(obj,idx) =
         let val new_object = newObject(obj)
         in
             indexObject{array=obj,tgt=new_object,index=idx};
             new_object
         end

     fun copyDerefObject(obj) =
         let val new_object = newObject(obj)
         in
             derefObject{ptr=obj,tgt=new_object};
             new_object
         end

     fun copySelectObject(obj,name) =
         let val new_object = newObject(obj)
         in
             selectObject{record=obj,tgt=new_object,field=name};
             new_object
         end

     fun copyCoerceObject(obj) =
         let val new_object = newObject(obj)
         in
             coerceObject{union=obj,tgt=new_object};
             new_object
         end

     fun setAddr {obj,addr} =
         let val object_addr = get_word32'(addr)
         in
             set_object_address'(obj,object_addr);
	     set_object_currency(obj,true)
         end

     local

        fun set_addr(ptr_object,addr_object) =
            if object_size(addr_object) = object_size(ptr_object)
            then copy_object_value'{from=addr_object,to=ptr_object}
            else raise StoreAccess

        fun set_addr_of(ptr_object,val_object) =
            let val addr = object_address(val_object)
                val ba   = address_to_bytearray(addr)
            in
                set_object_value(ptr_object,ba,0)
            end

     in

       fun setPtrAddr{ptr=ptr_object,addr=addr_object} =
            case objectType(ptr_object) of
              POINTER_TYPE{mode=LOCAL_PTR, ...}  => set_addr(ptr_object,addr_object)
            |
              POINTER_TYPE{mode=REMOTE_PTR, ...} => set_addr(ptr_object,addr_object)
            |
              _ => raise ForeignType

        fun setPtrAddrOf{ptr=ptr_object,data=val_object} =
            case objectType(ptr_object) of
              POINTER_TYPE{mode=LOCAL_PTR, ...} => set_addr_of(ptr_object,val_object)
            |
              POINTER_TYPE{mode=REMOTE_PTR, ...} => set_addr_of(ptr_object,val_object)
            |
              POINTER_TYPE{mode=RELATIVE_PTR, ...} =>
                 let val loc_posn = object_location(val_object)
                 in
                     set_int'(ptr_object,loc_posn)
                 end
            |
              _ => raise ForeignType
     end

     fun setPtrData{ptr=src_object,data=from_object} =
         let val to_object  = copyDerefObject(src_object)
         in
             copy_object_info{from=from_object,to=to_object}
         end

     fun setPtrType{ptr=src_object,data=from_object} =
         case objectType(src_object) of
            POINTER_TYPE{mode, ...} =>
	       let val ty       = objectType(from_object)
		   val ptr_type = POINTER_TYPE{mode=mode,ctype=ty}
		   val ptr_size = sizeOf(ptr_type)
	       in
		   set_object_type(src_object,ptr_type);
		   set_object_size(src_object,ptr_size)
	       end
          |
            _ => raise ForeignType

     fun castPtrType{ptr=src_object,ctype} =
         case objectType(src_object) of
            POINTER_TYPE{mode, ...} =>
	       let val ptr_type' = POINTER_TYPE{mode=mode,ctype=ctype}
		   val ptr_size' = sizeOf(ptr_type')
	       in
		   set_object_type(src_object,ptr_type');
		   set_object_size(src_object,ptr_size')
	       end
          |
            _ => raise ForeignType


     local
        val hi = ref 0
        val lo = ref 0

        val get_int = get_int2' (hi,lo)

        fun is_int_eq (int1,int2) =
            let val _ = get_int (int1)
                val h1 = !hi
                val l1 = !lo

                val _ = get_int (int2)
                val h2 = !hi
                val l2 = !lo
            in
                (h1 = h2) andalso (l1 = l2)
            end

        fun ptr_kind (ptr_obj) =
            case objectType (ptr_obj) of
              POINTER_TYPE {mode=LOCAL_PTR, ...}    => REMOTE_PTR
            | POINTER_TYPE {mode=REMOTE_PTR, ...}   => REMOTE_PTR
            | POINTER_TYPE {mode=RELATIVE_PTR, ...} => RELATIVE_PTR
            | _ => raise ForeignType

     in

        fun isEqPtr (ptr1,ptr2) =
            if ptr_kind(ptr1) = ptr_kind(ptr2)
            then is_int_eq (ptr1,ptr2)
            else false

        fun isNullPtr (ptr_obj) =
            case objectType (ptr_obj) of
              POINTER_TYPE {mode=RELATIVE_PTR, ...} => false
            | POINTER_TYPE (_) =>             
                 let val _ = get_int (ptr_obj)
                 in
                     (!hi = 0) andalso (!lo = 0)
                 end
            | _ => raise ForeignType

     end


     fun indexObjectLocation(obj,idx) =
         case objectType(obj) of
           ARRAY_TYPE{length,ctype, ...} =>
              if (0 <= idx) andalso (idx < length)
              then let val elem_size = sizeOf(ctype)
                       val rel_posn  = idx * elem_size
                   in
                       object_location(obj) + rel_posn
                   end
              else raise StoreAccess
         |
            _ => raise ForeignType

     fun derefObjectLocation(obj) =
         case objectType(obj) of
           POINTER_TYPE{mode=RELATIVE_PTR, ...} => get_int'(obj)
         |
           POINTER_TYPE{mode=LOCAL_PTR, ...} =>
              let val loc_ptr   = f_object_value(obj)
                  val addr      = bytearray_to_address(loc_ptr)
                  val loc_posn  = to_location(obj,addr)
              in
                  loc_posn
              end
         |
            _ => raise ForeignType

     fun selectObjectLocation(obj,name) =
         case objectType(obj) of
           STRUCT_TYPE{fields, ...} =>
             let val field = lookup_field(fields,name)
                 val FIELD{offset, ...} = field
                 val rel_posn = valOf offset
             in
                 object_location(obj) + rel_posn
             end
         |
            _ => raise ForeignType

     val coerceObjectLocation = object_location


     fun indexObjectType(obj) =
         case objectType(obj) of
           ARRAY_TYPE{ctype, ...} => ctype 
         |
            _ => raise ForeignType

     fun derefObjectType(obj) =
         case objectType(obj) of
           POINTER_TYPE{ctype, ...} => ctype
         |
            _ => raise ForeignType

     fun selectObjectType(obj,name) =
         case objectType(obj) of
           STRUCT_TYPE{fields, ...} =>
             let val FIELD{ctype, ...} = lookup_field(fields,name)
             in
                 ctype
             end
         |
            _ => raise ForeignType

     fun coerceObjectType(obj) =
         case objectType(obj) of
           UNION_TYPE{current, ...} =>
              let val VARIANT{ctype, ...} = current
              in
                  ctype
              end
         |
            _ => raise ForeignType


     fun indexObjectSize(obj)        = sizeOf(indexObjectType(obj))
     fun derefObjectSize(obj)        = sizeOf(derefObjectType(obj))
     fun selectObjectSize(obj,name)  = sizeOf(selectObjectType(obj,name))
     fun coerceObjectSize(obj)       = sizeOf(coerceObjectType(obj))

     fun nextArrayItem(obj) = offset_object(obj,object_size(obj))
     fun prevArrayItem(obj)  = offset_object(obj,~(object_size(obj)))
         

     (* Getters ... *)

     fun getUnsignedChar(obj) =
         case objectType(obj) of
           CHAR_TYPE          => get_char'(obj)
         |
           UNSIGNED_CHAR_TYPE => get_char'(obj)
         |
           _ => raise ForeignType

     val getChar = getUnsignedChar

     fun getSignedChar(obj) =
         case objectType(obj) of
           CHAR_TYPE        => get_signed_char'(obj)
         |
           SIGNED_CHAR_TYPE => get_signed_char'(obj)
         |
           _ => raise ForeignType


     fun getShort(obj) =
         case objectType(obj) of
           SHORT_TYPE  => get_int'(obj)
         |
           _ => raise ForeignType

     fun getInt(obj) =
         case objectType(obj) of
           INT_TYPE  => get_int'(obj)
         |
           _ => raise ForeignType

     fun getLong(obj) =
         case objectType(obj) of
           LONG_TYPE  => get_int'(obj)
         |
           _ => raise ForeignType

     fun getUnsignedShort(obj) =
         case objectType(obj) of
           UNSIGNED_SHORT_TYPE  => get_int'(obj)
         |
           _ => raise ForeignType

     fun getUnsigned(obj) =
         case objectType(obj) of
           UNSIGNED_INT_TYPE  => get_int'(obj)
         |
           _ => raise ForeignType

     fun getUnsignedLong(obj) =
         case objectType(obj) of
           UNSIGNED_LONG_TYPE  => get_int'(obj)
         |
           _ => raise ForeignType

     fun getWord32(obj) =
         case objectType(obj) of
           UNSIGNED_INT_TYPE  => get_word32'(obj)
         |
           _ => raise ForeignType

     fun getEnum(obj) =
         case objectType(obj) of
           ENUM_TYPE{card, ...} =>
             let val i = get_int'(obj)
             in
                if (0 <= i) andalso (i < card)
                then i
                else raise ForeignType
             end
         |
           _ => raise ForeignType

     fun getFloat(obj) =
         case objectType(obj) of
           FLOAT_TYPE  => get_real'(obj)
         |
           _ => raise ForeignType

     fun getDouble(obj) =
         case objectType(obj) of
           DOUBLE_TYPE  => get_real'(obj)
         |
           _ => raise ForeignType

     fun getLongDouble(obj) =
         case objectType(obj) of
           LONG_DOUBLE_TYPE  => get_real'(obj)
         |
           _ => raise ForeignType

     fun getString(obj) =
	 case objectType(obj) of
	   STRING_TYPE{length}  => get_string'(obj,length)
	 |
	   _ => raise ForeignType

     val getData = copyDerefObject

     fun getStruct(obj) =
         case objectType(obj) of
           STRUCT_TYPE{fields, ...} =>
             let fun doit(fld::fld_lst,pl) =
                     let val FIELD{offset,ctype, ...} = fld
                         val new_object   =  newObject obj
                         val rel_posn  =  valOf offset
                         val size      =  sizeOf ctype
                     in
                         set_object_type(new_object,ctype);
                         set_object_size(new_object,size);
                         offset_object(new_object,rel_posn);
                         doit(fld_lst,new_object::pl)
                     end
                   | doit([],object_lst) = rev object_lst
             in
                 doit(fields,[])
             end
         |
            _ => raise ForeignType

     val getField = copySelectObject

     val getUnion = copyCoerceObject

     local
         fun get_array'(obj,len,rel_offset) =
             let fun doit(k,rel_posn,pl) =
                     if (k < 0) then rev pl else
                     let val new_object = newObject(obj)
                     in
                       offset_object(new_object,rel_posn);
                       doit(k-1,rel_posn + rel_offset,new_object::pl)
                     end
             in
                doit(len-1,object_location(obj),[])
             end
     in
         fun getArray(obj) =
             case objectType(obj) of
                ARRAY_TYPE{length,ctype, ...} =>
                  let val elem_size   =  sizeOf ctype
                      val elem_object    =  dup_object'(obj)
                  in
                      set_object_type(elem_object,ctype);
                      set_object_size(elem_object,elem_size);
                      get_array'(elem_object,length,elem_size)
                  end
             |
                _ => raise ForeignType
     end

     val objectType : c_object -> c_type  =  objectType

     fun castObjectType(obj,ctype) =
       ( set_object_size(obj,sizeOf ctype);
         set_object_type(obj,ctype)
       )

     (* Diagnostic tools *)

     local

        fun str_ptr_mode(LOCAL_PTR)     = "local"
          | str_ptr_mode(RELATIVE_PTR)  = "relative"
          | str_ptr_mode(REMOTE_PTR)    = "remote"

        fun str_field_list (sep,FIELD{name=name', ...}::nml') =
	    let fun doit(FIELD{name, ...}::nml,strl) = doit(nml,name::sep::strl)
                  | doit(_,strl) = rev strl
            in
                concat (doit(nml',[name']))
            end
          | str_field_list (_,[]) = ""

        fun str_current(VARIANT{name, ...}) = name

     in

	fun cTypeInfo(VOID_TYPE)             = "VOID_TYPE" 

	  | cTypeInfo(CHAR_TYPE)             = "CHAR_TYPE"
	  | cTypeInfo(UNSIGNED_CHAR_TYPE)    = "UNSIGNED_CHAR_TYPE"
	  | cTypeInfo(SIGNED_CHAR_TYPE)      = "SIGNED_CHAR_TYPE"

	  | cTypeInfo(SHORT_TYPE)            = "SHORT_TYPE"
	  | cTypeInfo(INT_TYPE)              = "INT_TYPE"
	  | cTypeInfo(LONG_TYPE)             = "LONG_TYPE"

	  | cTypeInfo(UNSIGNED_SHORT_TYPE)   = "UNSIGNED_SHORT_TYPE"
	  | cTypeInfo(UNSIGNED_INT_TYPE)     = "UNSIGNED_INT_TYPE"
	  | cTypeInfo(UNSIGNED_LONG_TYPE)    = "UNSIGNED_LONG_TYPE"

	  | cTypeInfo(FLOAT_TYPE)            = "FLOAT_TYPE"
	  | cTypeInfo(DOUBLE_TYPE)           = "DOUBLE_TYPE"
	  | cTypeInfo(LONG_DOUBLE_TYPE)      = "LONG_DOUBLE_TYPE"

	  | cTypeInfo(STRING_TYPE{length})   = "STRING_TYPE[" ^ Int.toString length ^ "]"

	  | cTypeInfo(TYPENAME{name, ...}) = "TYPENAME[" ^ name ^ "]"

	  | cTypeInfo(FUNCTION_TYPE{source,target}) =
	    "FUNCTION_TYPE[" ^ c_type_info_list(source) ^ ";" ^ cTypeInfo(target) ^ "]"

	  | cTypeInfo(POINTER_TYPE{ctype,mode}) =
	    "POINTER_TYPE[" ^ str_ptr_mode(mode) ^ ";" ^ cTypeInfo(ctype) ^ "]"

	  | cTypeInfo(STRUCT_TYPE{tag=NONE, fields, ...}) =
	    "STRUCT_TYPE[<none>;" ^ str_field_list (",",fields) ^ "]"

	  | cTypeInfo(STRUCT_TYPE{tag=SOME(name), fields, ...}) =
	    "STRUCT_TYPE[" ^ name ^ ";" ^ str_field_list(",",fields) ^ "]"

	  | cTypeInfo(UNION_TYPE{tag=NONE, current, ...}) =
	    "UNION_TYPE[<none>;" ^ str_current(current) ^ "]"

	  | cTypeInfo(UNION_TYPE{tag=SOME(name), current, ...}) =
	    "UNION_TYPE[" ^ name ^ ";" ^ str_current(current) ^ "]"

	  | cTypeInfo(ARRAY_TYPE { length, ctype, ... }) =
            "ARRAY_TYPE[" ^ cTypeInfo(ctype) ^ "," ^ Int.toString length ^ "]"

	  | cTypeInfo(ENUM_TYPE{tag=NONE, ...}) =
	    "ENUM_TYPE[<none>]"

	  | cTypeInfo(ENUM_TYPE{tag=SOME(name), ...}) =
	    "ENUM_TYPE[" ^ name ^ "]"

        and c_type_info_list(cty::[])   = cTypeInfo(cty)
          | c_type_info_list(cty::ctyl) = cTypeInfo(cty) ^ "," ^ c_type_info_list(ctyl)
          | c_type_info_list([]) = ""

        val objectInfo = fn (object : c_object) => object_info cTypeInfo object

	val objectData         : c_object -> int list  = object_data
	val objectDataHex     : c_object -> string    = object_data_hex
	val objectDataAscii   : c_object -> string    = object_data_ascii

        fun viewObject object =
            let val { store, status, currency, mode, langtype, size, base, offset } =
                    objectInfo object

                val data = objectDataHex object
            in
	      concat [ "\n\n",
                            "   Object (", mode, ", ", status, ", ", currency, ")\n",
                            "       type      = ", langtype, "\n",
                            "       size      = ", Int.toString(size), "\n",
                (case base of
                   NONE =>  ""
                 | SOME(addr) =>
                            "       position  = " ^  word32_to_hex(addr) ^ "\n"),
                            "       offset    = ", Int.toString(offset), "\n",
                            "       data      = 0x[", data, "]\n",
                            "\n\n" ]
            end

	val dispObject = disp viewObject

     end
       

   end; (* signature C_OBJECT *)
@


1.8.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 *  Revision 1.8  1996/11/06  11:25:22  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 *  Revision 1.8  1996/11/06  11:25:22  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 *  Revision 1.8  1996/11/06  11:25:22  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.5.1
log
@branched from 1.8
@
text
@a11 4
 *  Revision 1.8  1996/11/06  11:25:22  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 *  Revision 1.8.5.1  1997/05/12  10:31:02  hope
 *  branched from 1.8
 *
@


1.8.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 *  Revision 1.8.5.1  1997/05/12  10:31:02  hope
 *  branched from 1.8
 *
@


1.8.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 *  Revision 1.8.5.1  1997/05/12  10:31:02  hope
 *  branched from 1.8
 *
@


1.8.4.1
log
@branched from 1.8
@
text
@a11 4
 *  Revision 1.8  1996/11/06  11:25:22  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.3.1
log
@branched from 1.8
@
text
@a11 4
 *  Revision 1.8  1996/11/06  11:25:22  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.3.1.1.1
log
@branched from 1.8.3.1
@
text
@a11 3
 *  Revision 1.8.3.1  1996/12/17  17:44:43  hope
 *  branched from 1.8
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a11 4
 *  Revision 1.8  1996/11/06  11:25:22  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a11 4
 *  Revision 1.8  1996/11/06  11:25:22  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.1.1.1.1
log
@branched from 1.8.1.1
@
text
@a11 3
 *  Revision 1.8.1.1  1996/11/14  12:45:27  hope
 *  branched from 1.8
 *
@


1.7
log
@[Bug #1547]
[Bug #1547]
updating for current naming conventions
@
text
@d12 5
d78 1
a78 1
require "^.basis.__integer";
@


1.6
log
@Fixing problems with normalise_type & size of chars ...
@
text
@d12 3
d73 3
a75 4
require "../basis/__integer";
require "../basis/__general";
require "../utils/lists";
require "../utils/__lists";
d94 1
a94 1
     structure Lists        : LISTS            = Lists_
a99 1
     open General
d111 5
a115 7
     (* Internal utilities *)

     val MLWcast  =  MLWorks.Internal.Value.cast : 'a -> 'b

     val to_real_repn    =  MLWorks.Internal.Value.real_to_string
     val from_real_repn  =  MLWorks.Internal.Value.string_to_real

a132 4

     val int_string   =  Int.toString


d139 2
a140 2
     val object_address        =    FIObject.object_address
     val object_location       =    FIObject.object_location
d158 1
a158 1
     val object_type           =    FIObject.object_type
d161 1
a161 1
     val object_size           =    FIObject.object_size
a170 17

     (* Utilities mapping *)

     val int_string   =    Int.toString

     val extract      =    General.valOf

     val hd           =    Lists.hd
     val reducel      =    Lists.reducel
     val llength      =    Lists.length
     val zip          =    Lists.zip   
     val findp        =    Lists.findp
     val check_order  =    Lists.check_order   
     val sort         =    Lists.msort

     val max          =    Int.max

d237 2
a238 1
	fun lookup_itemlist p (ni_lst,nm) =  findp (p nm) ni_lst
d283 1
a283 1
       fun size_of(VOID_TYPE)             = void_size
d285 3
a287 3
         | size_of(CHAR_TYPE)             = char_size
         | size_of(UNSIGNED_CHAR_TYPE)    = char_size
         | size_of(SIGNED_CHAR_TYPE)      = char_size
d289 3
a291 3
         | size_of(SHORT_TYPE)            = short_int_size
         | size_of(INT_TYPE)              = int_size
         | size_of(LONG_TYPE)             = long_int_size
d293 3
a295 3
         | size_of(UNSIGNED_SHORT_TYPE)   = unsigned_short_int_size
         | size_of(UNSIGNED_INT_TYPE)     = unsigned_int_size
         | size_of(UNSIGNED_LONG_TYPE)    = unsigned_long_int_size
d297 3
a299 3
         | size_of(FLOAT_TYPE)            = real_size
         | size_of(DOUBLE_TYPE)           = double_size
         | size_of(LONG_DOUBLE_TYPE)      = long_double_size
d301 1
a301 1
         | size_of(STRING_TYPE{length})   = length  (* includes null sentinel *)
d303 1
a303 1
         | size_of(TYPENAME{size=SOME(size), ...}) = size          
d305 1
a305 1
         | size_of(TYPENAME{name, ...}) = raise UnknownTypeName(name)
d307 1
a307 1
         | size_of(POINTER_TYPE _)  = pointer_size
d309 1
a309 1
         | size_of(FUNCTION_TYPE _) = pointer_size
d311 1
a311 1
         | size_of(STRUCT_TYPE{size=SOME(size), ...}) = size
d313 1
a313 1
         | size_of(STRUCT_TYPE{fields, ...}) = size_of_struct(fields)
d315 1
a315 1
         | size_of(UNION_TYPE{size=SOME(size), ...}) = size
d317 1
a317 1
         | size_of(UNION_TYPE{variants, ...}) = size_of_union(variants)
d319 1
a319 1
         | size_of(ARRAY_TYPE { size=SOME(size), ... }) = size
d321 1
a321 1
         | size_of(ARRAY_TYPE { length, ctype, ... }) = length * size_of(ctype)
d323 1
a323 1
         | size_of(ENUM_TYPE _) = enum_size
d325 3
a327 5
       and size_of_field(cur_offset,FIELD{size=SOME(size), ...}) =
           size + cur_offset

         | size_of_field(cur_offset,FIELD{ctype, ...}) =
           let val new_size    = size_of (ctype)
d333 1
a333 4
       and size_of_struct(fld_lst) = reducel size_of_field (0,fld_lst)

       and size_of_variant(cur_size,VARIANT{size=SOME(size), ctype, ...}) =
           max(size,cur_size)
d335 4
a338 2
         | size_of_variant(cur_size,VARIANT{size, ctype, ...}) = 
           max(size_of(ctype),cur_size)
d340 1
a340 1
       and size_of_union(vnt_lst) = reducel size_of_variant (0,vnt_lst)
d349 1
a349 1
            if check_order variant_leq vnt_l
d351 1
a351 1
            else sort variant_leq vnt_l
d388 1
a388 1
           if (llength vl1 = llength vl2)
d417 1
a417 1
       fun equal_type(cty1,cty2) =
d463 1
a463 1
                       card  = llength elem_lst
d472 2
a473 2
     val object_mode      : c_object -> object_mode         =  object_mode
     val set_object_mode  : c_object * object_mode -> unit  =  set_object_mode
d494 1
a494 1
     val new_object : c_object -> c_object =
d497 1
a497 1
	       val new_ctype =  object_type(obj)
d503 1
a503 1
     val dup_object : c_object -> c_object =
d506 1
a506 1
	       val new_ctype =  object_type(obj)
d512 1
a512 1
     val tmp_object : c_object -> c_object =
d515 1
a515 1
	       val new_ctype =  object_type(obj)
d522 1
a522 1
	 let val object_size = size_of(ctype)
d533 1
a533 1
         let val from_type = object_type(src_pd)
d545 1
a545 1
	val data_buffer = bytearray(size_of(LONG_DOUBLE_TYPE),0)
d620 1
a620 1
	   val real_size = size_of(LONG_DOUBLE_TYPE)
d626 1
a626 1
		   from_real_repn(repn_str)
d631 1
a631 1
	    let val real_str = to_real_repn(r)
d668 1
a668 1
	   fun set_string' (obj,length,str) =
d677 2
a678 2
     fun set_unsigned_char(obj,ch) =
         case object_type(obj) of
d685 1
a685 1
     val set_char = set_unsigned_char
d687 2
a688 2
     fun set_signed_char(obj,ch) =
         case object_type(obj) of
d695 2
a696 2
     fun set_short(obj,i) =
         case object_type(obj) of
d701 2
a702 2
     fun set_int(obj,i) =
         case object_type(obj) of
d707 2
a708 2
     fun set_long(obj,i) =
         case object_type(obj) of
d713 2
a714 2
     fun set_unsigned_short(obj,i) =
         case object_type(obj) of
d719 2
a720 2
     fun set_unsigned(obj,i) =
         case object_type(obj) of
d725 2
a726 2
     fun set_unsigned_long(obj,i) =
         case object_type(obj) of
d731 2
a732 2
     fun set_word32(obj,wd) =
         case object_type(obj) of
d737 2
a738 2
     fun set_enum(obj,i) =
         case object_type(obj) of
d750 2
a751 2
     fun set_float(obj,r) =
         case object_type(obj) of
d756 2
a757 2
     fun set_double(obj,r) =
         case object_type(obj) of
d762 2
a763 2
     fun set_long_double(obj,r) =
         case object_type(obj) of
d769 3
a771 3
     fun set_string(obj, str) =
         case object_type(obj) of
           STRING_TYPE{length}  => set_string' (obj,length,str)
d776 2
a777 2
     fun set_local_ptr(ptr_object) =
         case object_type(ptr_object) of
d794 2
a795 2
     fun set_relative_ptr(ptr_object) =
         case object_type(ptr_object) of
d811 2
a812 2
     fun set_remote_ptr(ptr_object) =
         case object_type(ptr_object) of
d819 1
a819 1
             ( set_local_ptr(ptr_object);
d838 3
a840 2
         fun set_array(obj,contents,st) =
             case object_type(obj) of
d842 1
a842 1
                  if (st + llength(contents) > length)
d844 1
a844 1
                  else let val elem_size   =  size_of ctype
d864 1
a864 1
                      doit(extract(size),fld_lst,pl)
d872 2
a873 2
         fun set_struct(obj,items) =
             case object_type(obj) of
d875 1
a875 1
                  if (llength(fields) <> llength(items))
d883 2
a884 2
	 fun set_field{record=obj,field=name,data} =
	     case object_type(obj) of
d888 1
a888 1
		      if not(equal_type(object_type(data),ctype))
d890 2
a891 2
                      else let val size   = size_of(ctype)
			       val offset = extract(offset)
d904 2
a905 2
     fun set_union{union=obj,data} =
         case object_type(obj) of
d909 1
a909 1
                  if not(equal_type(object_type(data),ctype))
d916 2
a917 2
     fun set_member{union=obj,member} =
         case object_type(obj) of
d930 2
a931 2
     fun index_object{array=src_pd,tgt=tgt_pd,index=idx} =
         case object_type(src_pd) of
d934 1
a934 1
              then let val elem_size = size_of(ctype)
d947 2
a948 2
     fun deref_object{ptr=src_pd,tgt=tgt_pd} =
         case object_type(src_pd) of
d950 1
a950 1
              let val item_size = size_of(ctype)
d961 1
a961 1
              let val item_size = size_of(ctype)
d973 1
a973 1
              let val item_size = size_of(ctype)
d984 2
a985 2
     fun select_object{record=src_pd,tgt=tgt_pd,field=name} =
	 case object_type(src_pd) of
d989 2
a990 2
		 val obj_size  =  size_of(ctype)
		 val fld_posn  =  extract(offset)
d1002 2
a1003 2
     fun coerce_object{union=src_pd,tgt=tgt_pd} =
         case object_type(src_pd) of
d1006 1
a1006 1
                  val new_size = size_of(ctype)
d1010 1
a1010 1
		  set_object_currency(tgt_pd,object_currency(src_pd))
d1016 2
a1017 2
     fun copy_index_object(obj,idx) =
         let val new_object = new_object(obj)
d1019 1
a1019 1
             index_object{array=obj,tgt=new_object,index=idx};
d1023 2
a1024 2
     fun copy_deref_object(obj) =
         let val new_object = new_object(obj)
d1026 1
a1026 1
             deref_object{ptr=obj,tgt=new_object};
d1030 2
a1031 2
     fun copy_select_object(obj,name) =
         let val new_object = new_object(obj)
d1033 1
a1033 1
             select_object{record=obj,tgt=new_object,field=name};
d1037 2
a1038 2
     fun copy_coerce_object(obj) =
         let val new_object = new_object(obj)
d1040 1
a1040 1
             coerce_object{union=obj,tgt=new_object};
d1044 1
a1044 1
     fun set_addr {obj,addr} =
d1067 2
a1068 2
       fun set_ptr_addr{ptr=ptr_object,addr=addr_object} =
            case object_type(ptr_object) of
d1075 2
a1076 2
        fun set_ptr_addr_of{ptr=ptr_object,data=val_object} =
            case object_type(ptr_object) of
d1090 2
a1091 2
     fun set_ptr_data{ptr=src_object,data=from_object} =
         let val to_object  = copy_deref_object(src_object)
d1096 2
a1097 2
     fun set_ptr_type{ptr=src_object,data=from_object} =
         case object_type(src_object) of
d1099 1
a1099 1
	       let val ty       = object_type(from_object)
d1101 1
a1101 1
		   val ptr_size = size_of(ptr_type)
d1109 2
a1110 2
     fun cast_ptr_type{ptr=src_object,ctype} =
         case object_type(src_object) of
d1113 1
a1113 1
		   val ptr_size' = size_of(ptr_type')
d1141 1
a1141 1
            case object_type (ptr_obj) of
d1149 1
a1149 1
        fun is_eq_ptr (ptr1,ptr2) =
d1154 2
a1155 2
        fun is_null_ptr (ptr_obj) =
            case object_type (ptr_obj) of
d1167 2
a1168 2
     fun index_object_location(obj,idx) =
         case object_type(obj) of
d1171 1
a1171 1
              then let val elem_size = size_of(ctype)
d1180 2
a1181 2
     fun deref_object_location(obj) =
         case object_type(obj) of
d1194 2
a1195 2
     fun select_object_location(obj,name) =
         case object_type(obj) of
d1199 1
a1199 1
                 val rel_posn = extract(offset)
d1206 1
a1206 1
     val coerce_object_location = object_location
d1209 2
a1210 2
     fun index_object_type(obj) =
         case object_type(obj) of
d1215 2
a1216 2
     fun deref_object_type(obj) =
         case object_type(obj) of
d1221 2
a1222 2
     fun select_object_type(obj,name) =
         case object_type(obj) of
d1231 2
a1232 2
     fun coerce_object_type(obj) =
         case object_type(obj) of
d1242 4
a1245 4
     fun index_object_size(obj)        = size_of(index_object_type(obj))
     fun deref_object_size(obj)        = size_of(deref_object_type(obj))
     fun select_object_size(obj,name)  = size_of(select_object_type(obj,name))
     fun coerce_object_size(obj)       = size_of(coerce_object_type(obj))
d1247 2
a1248 2
     fun next_array_item(obj) = offset_object(obj,object_size(obj))
     fun prev_array_item(obj)  = offset_object(obj,~(object_size(obj)))
d1253 2
a1254 2
     fun get_unsigned_char(obj) =
         case object_type(obj) of
d1261 1
a1261 1
     val get_char = get_unsigned_char
d1263 2
a1264 2
     fun get_signed_char(obj) =
         case object_type(obj) of
d1272 2
a1273 2
     fun get_short(obj) =
         case object_type(obj) of
d1278 2
a1279 2
     fun get_int(obj) =
         case object_type(obj) of
d1284 2
a1285 2
     fun get_long(obj) =
         case object_type(obj) of
d1290 2
a1291 2
     fun get_unsigned_short(obj) =
         case object_type(obj) of
d1296 2
a1297 2
     fun get_unsigned(obj) =
         case object_type(obj) of
d1302 2
a1303 2
     fun get_unsigned_long(obj) =
         case object_type(obj) of
d1308 2
a1309 2
     fun get_word32(obj) =
         case object_type(obj) of
d1314 2
a1315 2
     fun get_enum(obj) =
         case object_type(obj) of
d1326 2
a1327 2
     fun get_float(obj) =
         case object_type(obj) of
d1332 2
a1333 2
     fun get_double(obj) =
         case object_type(obj) of
d1338 2
a1339 2
     fun get_long_double(obj) =
         case object_type(obj) of
d1344 2
a1345 2
     fun get_string(obj) =
	 case object_type(obj) of
d1350 1
a1350 1
     val get_data = copy_deref_object
d1352 2
a1353 2
     fun get_struct(obj) =
         case object_type(obj) of
d1357 3
a1359 3
                         val new_object   =  new_object(obj)
                         val rel_posn  =  extract(offset)
                         val size      =  size_of(ctype)
d1373 1
a1373 1
     val get_field = copy_select_object
d1375 1
a1375 1
     val get_union = copy_coerce_object
d1381 1
a1381 1
                     let val new_object = new_object(obj)
d1390 2
a1391 2
         fun get_array(obj) =
             case object_type(obj) of
d1393 1
a1393 1
                  let val elem_size   =  size_of ctype
d1404 1
a1404 1
     val object_type : c_object -> c_type  =  object_type
d1406 2
a1407 2
     fun cast_object_type(obj,ctype) =
       ( set_object_size(obj,size_of ctype);
d1423 1
a1423 1
                String.implode(doit(nml',[name']))
d1431 1
a1431 1
	fun c_type_info(VOID_TYPE)             = "VOID_TYPE" 
d1433 3
a1435 3
	  | c_type_info(CHAR_TYPE)             = "CHAR_TYPE"
	  | c_type_info(UNSIGNED_CHAR_TYPE)    = "UNSIGNED_CHAR_TYPE"
	  | c_type_info(SIGNED_CHAR_TYPE)      = "SIGNED_CHAR_TYPE"
d1437 3
a1439 3
	  | c_type_info(SHORT_TYPE)            = "SHORT_TYPE"
	  | c_type_info(INT_TYPE)              = "INT_TYPE"
	  | c_type_info(LONG_TYPE)             = "LONG_TYPE"
d1441 3
a1443 3
	  | c_type_info(UNSIGNED_SHORT_TYPE)   = "UNSIGNED_SHORT_TYPE"
	  | c_type_info(UNSIGNED_INT_TYPE)     = "UNSIGNED_INT_TYPE"
	  | c_type_info(UNSIGNED_LONG_TYPE)    = "UNSIGNED_LONG_TYPE"
d1445 3
a1447 3
	  | c_type_info(FLOAT_TYPE)            = "FLOAT_TYPE"
	  | c_type_info(DOUBLE_TYPE)           = "DOUBLE_TYPE"
	  | c_type_info(LONG_DOUBLE_TYPE)      = "LONG_DOUBLE_TYPE"
d1449 1
a1449 1
	  | c_type_info(STRING_TYPE{length})   = "STRING_TYPE[" ^ int_string(length) ^ "]"
d1451 1
a1451 1
	  | c_type_info(TYPENAME{name, ...}) = "TYPENAME[" ^ name ^ "]"
d1453 2
a1454 2
	  | c_type_info(FUNCTION_TYPE{source,target}) =
	    "FUNCTION_TYPE[" ^ c_type_info_list(source) ^ ";" ^ c_type_info(target) ^ "]"
d1456 2
a1457 2
	  | c_type_info(POINTER_TYPE{ctype,mode}) =
	    "POINTER_TYPE[" ^ str_ptr_mode(mode) ^ ";" ^ c_type_info(ctype) ^ "]"
d1459 1
a1459 1
	  | c_type_info(STRUCT_TYPE{tag=NONE, fields, ...}) =
d1462 1
a1462 1
	  | c_type_info(STRUCT_TYPE{tag=SOME(name), fields, ...}) =
d1465 1
a1465 1
	  | c_type_info(UNION_TYPE{tag=NONE, current, ...}) =
d1468 1
a1468 1
	  | c_type_info(UNION_TYPE{tag=SOME(name), current, ...}) =
d1471 2
a1472 2
	  | c_type_info(ARRAY_TYPE { length, ctype, ... }) =
            "ARRAY_TYPE[" ^ c_type_info(ctype) ^ "," ^ int_string(length) ^ "]"
d1474 1
a1474 1
	  | c_type_info(ENUM_TYPE{tag=NONE, ...}) =
d1477 1
a1477 1
	  | c_type_info(ENUM_TYPE{tag=SOME(name), ...}) =
d1480 2
a1481 2
        and c_type_info_list(cty::[])   = c_type_info(cty)
          | c_type_info_list(cty::ctyl) = c_type_info(cty) ^ "," ^ c_type_info_list(ctyl)
d1484 1
a1484 1
        val object_info = fn (object : c_object) => object_info c_type_info object
d1486 3
a1488 3
	val object_data         : c_object -> int list  = object_data
	val object_data_hex     : c_object -> string    = object_data_hex
	val object_data_ascii   : c_object -> string    = object_data_ascii
d1490 1
a1490 1
        fun view_object object =
d1492 1
a1492 1
                    object_info object
d1494 1
a1494 1
                val data = object_data_hex object
d1496 1
a1496 1
                String.implode   [ "\n\n",
d1499 1
a1499 1
                            "       size      = ", int_string(size), "\n",
d1504 1
a1504 1
                            "       offset    = ", int_string(offset), "\n",
d1509 1
a1509 1
	val disp_object = disp view_object
@


1.5
log
@[Bug #1603]
convert ByteArray to Internal.ByteArray
@
text
@d12 4
d274 1
a274 1
     val char_size                = 1
@


1.5.2.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/09/20  14:48:58  io
 *  [Bug #1603]
 *  convert ByteArray to Internal.ByteArray
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/09/20  14:48:58  io
 *  [Bug #1603]
 *  convert ByteArray to Internal.ByteArray
 *
@


1.4
log
@Adding pointer comparison functions ...
@
text
@d12 3
d115 1
a115 1
     structure ByteArray  = MLWorks.ByteArray
@


1.4.1.1
log
@branched from 1.4
@
text
@a11 3
 *  Revision 1.4  1996/08/20  00:51:23  brianm
 *  Adding pointer comparison functions ...
 *
@


1.3
log
@[Bug #1551]
Fixed offset problem in get_string.
@
text
@d12 4
d561 5
a565 4
     val data_buffer = bytearray(size_of(LONG_DOUBLE_TYPE),0)
     (* To cut down on allocation, a fixed data buffer is used
        for passing small items such as characters, integers and
        reals (of various standard sizes).
d567 2
a568 2
        !! NOT THREAD-SAFE !!
      *)
a569 36
     fun f_object_value(obj) =
           ( object_value(obj,data_buffer,0);
             data_buffer
           )

     fun f_object_value'(obj) =
           ( object_value'(obj,data_buffer,0);
             data_buffer
           )

     fun set_int'(obj,i) =
       ( int_to_bytearray{len=int_size,arr=data_buffer,src=i,st=0};
         set_object_value(obj,data_buffer,0)
       ) handle _ => raise StoreAccess

     fun get_int'(obj)  =
         bytearray_to_int{arr=f_object_value(obj),st=0,len=int_size}

     fun set_word32'(obj,wd) =
       ( word32_to_bytearray{arr=data_buffer,src=wd,st=0};
         set_object_value(obj,data_buffer,0)
       ) handle _ => raise StoreAccess

     fun get_word32'(obj)  =  bytearray_to_word32{arr=f_object_value(obj),st=0}

     fun set_char'(obj,ch) =
         if (0 <= ch) andalso (ch < 256)
         then ( update_ba(data_buffer,0,ch);
                set_object_value(obj,data_buffer,0)
              )
         else raise StoreAccess

     fun get_char'(obj) =
         ( object_value(obj,data_buffer,0);
           sub_ba(data_buffer,0)
         )
d571 1
a571 5
     fun get_signed_char'(obj) =
         let val ch = get_char'(obj)
         in
             if (ch < 128) then ch else (ch - 256)
         end
d573 1
a573 6
     fun address_to_bytearray(addr) =
           ( word32_to_bytearray{arr=data_buffer,src=addr,st=0};
             data_buffer
           )

     fun bytearray_to_address(ba)  =  bytearray_to_word32{arr=ba,st=0}
d575 25
a599 6
     local
        val real_size = size_of(LONG_DOUBLE_TYPE)
     in
        fun get_real'(obj) =
            let val buffer   = f_object_value(obj)
                val repn_str = bytearray_to_string{arr=buffer,st=0,len=real_size}
d601 1
a601 1
                from_real_repn(repn_str)
a602 1
     end
d604 80
a683 6
     fun set_real'(obj,r) =
         let val real_str = to_real_repn(r)
         in
             string_to_bytearray{arr=data_buffer,src=real_str,st=0};
             set_object_value(obj,data_buffer,0)
         end
d685 6
d788 1
a788 4
           STRING_TYPE{length}  =>
              if (size(str) <= length)
              then set_object_value(obj,from_string(str),0)
              else raise StoreAccess
d1137 46
d1360 5
a1364 19
     local
        fun zerop (i) = (i = 0)
        fun find_string_end(length,buffer) = find_ba (zerop,length-1) buffer
     in
        fun get_string(obj) =
            case object_type(obj) of
              STRING_TYPE{length}  =>
                 let val buffer = bytearray(length,0)
                 in
                     object_value(obj,buffer,0);
                     let val end_idx = find_string_end(length,buffer)
                         val str_buf = subarray_ba(buffer,0,end_idx+1)
                     in
                         to_string(str_buf)
                     end
                 end
            |
              _ => raise ForeignType
     end
@


1.2
log
@Beta release modifications.
@
text
@d11 4
a14 1
 *  $Log: _c_object.sml,v $
d1261 1
a1261 1
        fun find_string_end(length,buffer) = find_ba (zerop,length) buffer
d1270 1
a1270 1
                         val str_buf = subarray_ba(buffer,0,end_idx)
@


1.1
log
@new unit
Renamed file.
@
text
@d5 4
d11 10
a20 3
 *  $Log: __c_data.sml,v $
 * Revision 1.5  1996/04/30  15:03:35  matthew
 * Removing utils/*integer
d22 4
a25 1
 * Revision 1.4  1996/04/18  16:54:49  jont
d28 11
a38 2
 * Revision 1.3  1995/09/07  22:43:36  brianm
 * Modifications for reorganisation & documentation.
d40 2
a41 2
 *  Revision 1.2  1995/06/15  14:56:06  brianm
 *  Adding FI diagnostics, more facilities including remote access.
d43 4
a46 1
 *  Revision 1.1  1995/04/25  11:09:13  brianm
d50 3
d56 1
d58 1
d61 9
a69 2
require "__codeset";
require "__data";
d71 1340
d1412 3
a1414 2
require "__store";
require "_c_data";
d1416 3
a1418 1
structure CObject_  =  CObject(
d1420 14
a1433 3
   structure FICodeSet = ForeignCodeSet_
   structure FIObject   = ForeignObject_
   structure FIUtils  = ForeignUtils_
d1435 1
a1435 1
   structure CStore  = ForeignStore_
d1437 2
a1438 1
   structure Lists    = Lists_
d1440 1
a1440 1
);
@
