head	1.3;
access;
symbols
	MLW_daveb_inline_1_4_99:1.3.8
	MLWorks_21c0_1999_03_25:1.3
	MLWorks_20c1_1998_08_20:1.3
	MLWorks_20c0_1998_08_04:1.3
	MLWorks_20b2c2_1998_06_19:1.3
	MLWorks_20b2_Windows_1998_06_12:1.3
	MLWorks_20b1c1_1998_05_07:1.3
	MLWorks_20b0_1998_04_07:1.3
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_20m1_1997_10_23:1.3
	MLWorks_11r1:1.3.5.1.1.1.1
	MLWorks_workspace_97:1.3.7
	MLWorks_dt_wizard:1.3.6
	MLWorks_11c0_1997_09_09:1.3.5.1.1.1
	MLWorks_10r3:1.3.5.1.3
	MLWorks_10r2_551:1.3.5.1.2
	MLWorks_11:1.3.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.5.1
	MLWorks_20m0_1997_06_20:1.3
	MLWorks_1_0_r2c2_1997_06_14:1.3.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.3.5
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.3.3.1.1
	MLWorks_gui_1996_12_18:1.3.4
	MLWorks_1_0_Win32_1996_12_17:1.3.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.1.1
	MLWorks_1_0_Irix_1996_11_28:1.3.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.2
	MLWorks_1_0_Unix_1996_11_14:1.3.1
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ * @;


1.3
date	96.10.25.14.10.20;	author io;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1
	1.3.5.1
	1.3.6.1
	1.3.7.1
	1.3.8.1;
next	1.2;

1.2
date	96.05.24.01.19.19;	author brianm;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	96.02.15.14.17.14;	author brianm;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.12.11;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.16.02.55;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.21.10;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.11.14.12.44.56;	author hope;	state Exp;
branches
	1.3.1.1.1.1;
next	;

1.3.1.1.1.1
date	96.11.28.14.56.50;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.11.22.18.05.21;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.12.17.17.44.13;	author hope;	state Exp;
branches
	1.3.3.1.1.1;
next	;

1.3.3.1.1.1
date	97.02.24.11.33.33;	author hope;	state Exp;
branches;
next	;

1.3.4.1
date	96.12.18.09.38.11;	author hope;	state Exp;
branches;
next	;

1.3.5.1
date	97.05.12.10.30.29;	author hope;	state Exp;
branches
	1.3.5.1.1.1
	1.3.5.1.2.1
	1.3.5.1.3.1;
next	;

1.3.5.1.1.1
date	97.07.28.18.16.24;	author daveb;	state Exp;
branches
	1.3.5.1.1.1.1.1;
next	;

1.3.5.1.1.1.1.1
date	97.10.07.11.41.18;	author jkbrook;	state Exp;
branches;
next	;

1.3.5.1.2.1
date	97.09.08.17.09.57;	author daveb;	state Exp;
branches;
next	;

1.3.5.1.3.1
date	97.09.09.14.05.26;	author daveb;	state Exp;
branches;
next	;

1.3.6.1
date	97.09.10.19.19.49;	author brucem;	state Exp;
branches;
next	;

1.3.7.1
date	97.09.11.20.51.01;	author daveb;	state Exp;
branches;
next	;

1.3.8.1
date	99.04.01.17.54.43;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.3
log
@[Bug #1547]
update naming conventions
@
text
@(* test script for foreign interface *)


(* *)

use "open";




   (* TEST 1 - C Interface *)

    val my_store =
         store{ alloc    = SUCC,
                 overflow = EXTEND,
                 size     = 1000,
                 status   = RDWR_STATUS   };

    val my_store_a4 =
         store{ alloc    = ALIGNED_4,
                 overflow = BREAK,
                 size     = 80,
                 status   = RDWR_STATUS   };

   (*  TEST 1.1 - Building C structures *)

   val f_name = "tstNT.dll";
  
   val my_struct = loadObjectFile(f_name,IMMEDIATE_LOAD);

   filesLoaded();
   fileInfo my_struct;
   symbols(my_struct);
   symbolInfo(my_struct,"hw");


   (* TEST 1.2 - Building C OBJECT's *)

   val my_object =
         object { ctype     = VOID_TYPE,
               store    = my_store };
   
   val my_object1 = dupObject(my_object);

   val int_object1 =
         object { ctype     = INT_TYPE,
               store    = my_store };

   setInt(int_object1, 3);
   
   val int_object2 =
         object { ctype     = INT_TYPE,
               store    = my_store };

   setInt(int_object2, 5);
   getInt(int_object1);
   getInt(int_object2);

   val my_sig = newSignature();


   (* TEST 1.3 - Building C Signatures *)

   defEntry(my_sig, FUN_DECL { name = "hw",
                               source = [] : c_type list,
                               target = VOID_TYPE });
   
  
   defEntry(my_sig, VAR_DECL { name  = "my_value",
	 		      ctype = INT_TYPE});
   
   showEntries(my_sig);
   
   val lookup_my_sig =  lookupEntry my_sig;


   (* TEST 1.4 - Extracting C function objects & calling them *)

   val hw = defineForeignFun(my_struct,my_sig)("hw");

   call(hw)([],my_object);


   (* TEST 1.5 - Returning a result *)

   defEntry(my_sig, FUN_DECL { name = "hw1",
			      source = [] : c_type list,
			      target = INT_TYPE});
   
   showEntries my_sig;

   val hw1 = defineForeignFun(my_struct,my_sig)("hw1");

   call(hw1)([],int_object1);

   getInt(int_object1);


   (* TEST 1.6 - Argument passing and returning results *)
   (* TEST 1.7 - Argument passing and returning results *)

   defEntry(my_sig, FUN_DECL { name = "hw2",
                               source = [INT_TYPE] : c_type list,
                               target = INT_TYPE });
   
   showEntries(my_sig);

   val hw2 = defineForeignFun(my_struct,my_sig)("hw2");

   setInt(int_object1,4);

   call(hw2)([int_object1],int_object2);

   getInt(int_object2);


   (* TEST 1.8 - Creating C-string object's *)

   val str_object1 =
         object { ctype     = STRING_TYPE{ length = 64 },
               store    = my_store };

   setString(str_object1,"Hello World");
   getString(str_object1);
   
   val str_object1_1 = dupObject(str_object1);
   castObjectType(str_object1_1, ARRAY_TYPE{ ctype = CHAR_TYPE, length = 64 });

   val char_object1 =
         object { ctype     = CHAR_TYPE,
               store    = my_store };

   indexObject{array=str_object1_1,tgt=char_object1,index=0};
   getChar(char_object1);

   indexObject{array=str_object1_1,tgt=char_object1,index=1};
   getChar(char_object1);

   val str_object2 =
         object { ctype     = STRING_TYPE{ length = 64 },
               store    = my_store };

   setString(str_object2,"");
	 

   (* TEST 1.9 - Argument passing and returning results *)

   defEntry(my_sig, FUN_DECL { name = "hw3",
                               source = [INT_TYPE] : c_type list,
                               target = STRING_TYPE{ length = 64 } });
   
   showEntries(my_sig);

   val hw3 = defineForeignFun(my_struct,my_sig)("hw3");

   setInt(int_object1,24);

   call(hw3)([int_object1],str_object2);

   getString(str_object2);

	 
(*
   (* TEST 1.10 - loading other code ... *)
 

   val libc = loadObjectFile("/lib/libc.so.1",IMMEDIATE_LOAD)
              handle _ => loadObjectFile("/usr/lib/libc.so",IMMEDIATE_LOAD)
              handle _ => loadObjectFile("/usr/lib/libc.so.1.8",IMMEDIATE_LOAD)
              handle _ => loadObjectFile("/usr/lib/libc.so.1.8.1",IMMEDIATE_LOAD);
       
   symbols(libc);

   val libxm = loadObjectFile("/usr/lib/libXm.so.2.12",IMMEDIATE_LOAD)
               handle _ => loadObjectFile("/usr/lib/libXm.so.2.11",IMMEDIATE_LOAD)
               handle _ => loadObjectFile("/usr/lib/libXm.so.1.2",IMMEDIATE_LOAD);

   symbols(libxm);


   (* TEST 1.11 - Argument passing and returning results *)

   defEntry(my_sig, FUN_DECL { name = "hw4",
                               source = [STRING_TYPE{ length = 64 }],
                               target = INT_TYPE
                             }
            );
   
   showEntries(my_sig);

   val hw4 = defineForeignFun(my_struct,my_sig)("hw4");

   setString(str_object1,"Hope springs Eternal"); 

   call(hw4)([str_object1],int_object1);

   getInt(int_object1);



   (* TEST 1.12 - Structures and foreign data maniputlation *)

   val my_type =
       structType("my_type",
                   [  ("num",  INT_TYPE),
                      ("ch",   CHAR_TYPE),
                      ("iptr", ptrType(INT_TYPE))
                   ]
		  );

   defEntry(my_sig, TYPE_DECL { name = "my_type",
                               defn = my_type,
                               size = sizeOf my_type}
	    );

   val void_object_a4_1 = object { ctype = VOID_TYPE, store = my_store_a4 };

   val struct_object_a4_1 =
         object { ctype     = my_type,
               store    = my_store_a4 };

   val ch_object_a4_1 =
         object { ctype     = CHAR_TYPE,
               store    = my_store_a4 };

   val int_object_a4_1 =
         object { ctype     = INT_TYPE,
               store    = my_store_a4 };

   val int_object_a4_2 =
         object { ctype     = INT_TYPE,
               store    = my_store_a4 };

   val tmp_object_a4_1 = tmpObject( void_object_a4_1 );


(* *)     
   selectObject{ record=struct_object_a4_1, field="num",  tgt=tmp_object_a4_1};
   setInt(tmp_object_a4_1,45);

   dispObject tmp_object_a4_1;

   selectObject{ record=struct_object_a4_1, field="ch",   tgt=tmp_object_a4_1};
   setChar(tmp_object_a4_1,81);

   dispObject tmp_object_a4_1;

   selectObject{ record=struct_object_a4_1, field="iptr", tgt=tmp_object_a4_1};

   dispObject tmp_object_a4_1;

   setPtrAddr_of{ ptr=tmp_object_a4_1, data=int_object_a4_1 };

   dispObject tmp_object_a4_1;

   setInt(int_object_a4_1,2020);

   dispObject tmp_object_a4_1;

   setPtrType{ ptr=tmp_object_a4_1, data=struct_object_a4_1};
   setPtrAddr_of{ ptr=tmp_object_a4_1, data=struct_object_a4_1};

   dispObject tmp_object_a4_1;

   dispObject struct_object_a4_1;

   defEntry(my_sig, FUN_DECL { name = "hw5",
                               source = [ptrType(my_type)],
                               target = INT_TYPE
                             }
            );
   
   showEntries(my_sig);

   val hw5 = defineForeignFun(my_struct,my_sig)("hw5");

   call(hw5)([tmp_object_a4_1],int_object_a4_2);

   getInt(int_object_a4_2);



   (* TEST 1.13 - Structures and foreign data maniputlation *)

   
   defEntry(my_sig, FUN_DECL { name = "hw6",
                               source = [],
                               target = UNSIGNED_INT_TYPE
                             }
            );
   
   showEntries my_sig;

   val uint_object_a4_1 = object{ ctype = UNSIGNED_INT_TYPE, store = my_store_a4 };

   val hw6 = defineForeignFun(my_struct,my_sig)("hw6");

   call(hw6)([],uint_object_a4_1);

   getWord32(uint_object_a4_1);

   setObjectMode(int_object_a4_1,REMOTE_OBJECT);
   
   setAddr{obj=int_object_a4_1,addr=uint_object_a4_1};

   getInt(int_object_a4_1);


   (*  Loading X libraries *)

   val libX11 = loadObjectFile("/usr/lib/libX11.so.5.0",IMMEDIATE_LOAD);
   val libXt  = loadObjectFile("/usr/lib/libXt.so.5.0",IMMEDIATE_LOAD);
   val libXm  = loadObjectFile("/usr/lib/libXm.so.1.2",IMMEDIATE_LOAD);

   (*  TEST 2.1 - Building C structures *)

   val x_store =
         store{ alloc    = SUCC,
                 overflow = EXTEND,
                 size     = 1000,
                 status   = RDWR_STATUS   };

   val x_name = "./xtst.so";
  
   val x_struct = loadObjectFile(x_name,IMMEDIATE_LOAD);

   symbols(x_struct);
   symbolInfo(x_struct,"demo_box");



   (* TEST 2.2 - Building C OBJECT's *)

   val x_object =
         object { ctype     = STRING_TYPE{ length = 64 },
               store    = x_store };
   
   val x_object1 = dupObject(x_object);


   val void_object =
         object { ctype     = VOID_TYPE,
               store    = x_store };


   (* TEST 2.3 - Building C Signatures *)

   val x_sig = newSignature();

   defEntry(x_sig,
             FUN_DECL 
               { name = "demo_box",
                 source = [STRING_TYPE{ length = 64 }],
                 target = VOID_TYPE });
   
   val demo_box = defineForeignFun(x_struct,x_sig)("demo_box");

   setString(x_object1,"Hope springs Eternal"); 

   call(demo_box)([x_object1],void_object);
*)




(* DEPRECATED TESTS:

   (* TEST 0 - Basic Core *)

   open ForeignCore_;


   (*
   val fpath = "./tst.so";
   val fpath = "./nickb.so";
   *)

   val fpath = "./tst.so";

   val fobj = loadObject (fpath,LOAD_LATER);

   val obj_lst = list_content fobj;

   val hw = find_value (fobj, "hw");

   val my_value = find_value (fobj, "my_value");

   call_unit_fun hw;
*)
@


1.3.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@@


1.3.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.3.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@@


1.3.5.1
log
@branched from 1.3
@
text
@@


1.3.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.3.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.3.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.3.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.3.4.1
log
@branched from 1.3
@
text
@@


1.3.3.1
log
@branched from 1.3
@
text
@@


1.3.3.1.1.1
log
@branched from 1.3.3.1
@
text
@@


1.3.2.1
log
@branched from 1.3
@
text
@@


1.3.1.1
log
@branched from 1.3
@
text
@@


1.3.1.1.1.1
log
@branched from 1.3.1.1
@
text
@@


1.2
log
@Beta release modifications.
@
text
@d29 1
a29 1
   val my_struct = load_object_file(f_name,IMMEDIATE_LOAD);
d31 2
a32 2
   files_loaded();
   file_info(my_struct);
d34 1
a34 1
   symbol_info(my_struct,"hw");
d43 1
a43 1
   val my_object1 = dup_object(my_object);
d49 1
a49 1
   set_int(int_object1, 3);
d55 3
a57 3
   set_int(int_object2, 5);
   get_int(int_object1);
   get_int(int_object2);
d59 1
a59 1
   val my_sig = new_signature();
d64 3
a66 3
   def_entry(my_sig, FUN_DECL { name = "hw",
                               source = makeBox([] : c_type list),
                               target = makeBox(VOID_TYPE) });
d69 2
a70 2
   def_entry(my_sig, VAR_DECL { name  = "my_value",
	 		      ctype = voidBox() });
d72 1
a72 1
   show_entries(my_sig);
d74 1
a74 1
   val lookup_my_sig =  lookup_entry(my_sig);
d79 1
a79 1
   val hw = define_foreign_fun(my_struct,my_sig)("hw");
a83 1

d86 3
a88 3
   def_entry(my_sig, FUN_DECL { name = "hw1",
                               source = makeBox([] : c_type list),
                               target = makeBox(INT_TYPE) });
d90 1
a90 1
   show_entries(my_sig);
d92 1
a92 1
   val hw1 = define_foreign_fun(my_struct,my_sig)("hw1");
d96 1
a96 1
   get_int(int_object1);
d102 3
a104 3
   def_entry(my_sig, FUN_DECL { name = "hw2",
                               source = makeBox([INT_TYPE] : c_type list),
                               target = makeBox(INT_TYPE) });
d106 1
a106 1
   show_entries(my_sig);
d108 1
a108 1
   val hw2 = define_foreign_fun(my_struct,my_sig)("hw2");
d110 1
a110 1
   set_int(int_object1,4);
d114 1
a114 1
   get_int(int_object2);
d123 2
a124 2
   set_string(str_object1,"Hello World");
   get_string(str_object1);
d126 2
a127 2
   val str_object1_1 = dup_object(str_object1);
   cast_object_type(str_object1_1, ARRAY_TYPE{ ctype = CHAR_TYPE, length = 64 });
d133 2
a134 2
   index_object{array=str_object1_1,tgt=char_object1,index=0};
   get_char(char_object1);
d136 2
a137 2
   index_object{array=str_object1_1,tgt=char_object1,index=1};
   get_char(char_object1);
d143 1
a143 1
   set_string(str_object2,"");
a145 1

d148 3
a150 3
   def_entry(my_sig, FUN_DECL { name = "hw3",
                               source = makeBox([INT_TYPE] : c_type list),
                               target = makeBox(STRING_TYPE{ length = 64 }) });
d152 1
a152 1
   show_entries(my_sig);
d154 1
a154 1
   val hw3 = define_foreign_fun(my_struct,my_sig)("hw3");
d156 1
a156 1
   set_int(int_object1,24);
d160 1
a160 1
   get_string(str_object2);
d167 4
a170 4
   val libc = load_object_file("/lib/libc.so.1",IMMEDIATE_LOAD)
              handle _ => load_object_file("/usr/lib/libc.so",IMMEDIATE_LOAD)
              handle _ => load_object_file("/usr/lib/libc.so.1.8",IMMEDIATE_LOAD)
              handle _ => load_object_file("/usr/lib/libc.so.1.8.1",IMMEDIATE_LOAD);
d174 3
a176 3
   val libxm = load_object_file("/usr/lib/libXm.so.2.12",IMMEDIATE_LOAD)
               handle _ => load_object_file("/usr/lib/libXm.so.2.11",IMMEDIATE_LOAD)
               handle _ => load_object_file("/usr/lib/libXm.so.1.2",IMMEDIATE_LOAD);
d183 3
a185 3
   def_entry(my_sig, FUN_DECL { name = "hw4",
                               source = makeBox([STRING_TYPE{ length = 64 }]),
                               target = makeBox(INT_TYPE)
d189 1
a189 1
   show_entries(my_sig);
d191 1
a191 1
   val hw4 = define_foreign_fun(my_struct,my_sig)("hw4");
d193 1
a193 1
   set_string(str_object1,"Hope springs Eternal"); 
d197 1
a197 1
   get_int(int_object1);
d211 3
a213 3
   def_entry(my_sig, TYPE_DECL { name = "my_type",
                               defn = makeBox(my_type),
                               size = voidBox() }
d234 1
a234 1
   val tmp_object_a4_1 = tmp_object( void_object_a4_1 );
d238 2
a239 2
   select_object{ record=struct_object_a4_1, field="num",  tgt=tmp_object_a4_1};
   set_int(tmp_object_a4_1,45);
d241 1
a241 1
   disp_object tmp_object_a4_1;
d243 2
a244 2
   select_object{ record=struct_object_a4_1, field="ch",   tgt=tmp_object_a4_1};
   set_char(tmp_object_a4_1,81);
d246 1
a246 1
   disp_object tmp_object_a4_1;
d248 1
a248 1
   select_object{ record=struct_object_a4_1, field="iptr", tgt=tmp_object_a4_1};
d250 1
a250 1
   disp_object tmp_object_a4_1;
d252 1
a252 1
   set_ptr_addr_of{ ptr=tmp_object_a4_1, data=int_object_a4_1 };
d254 1
a254 1
   disp_object tmp_object_a4_1;
d256 1
a256 1
   set_int(int_object_a4_1,2020);
d258 1
a258 1
   disp_object tmp_object_a4_1;
d260 2
a261 2
   set_ptr_type{ ptr=tmp_object_a4_1, data=struct_object_a4_1};
   set_ptr_addr_of{ ptr=tmp_object_a4_1, data=struct_object_a4_1};
d263 1
a263 1
   disp_object tmp_object_a4_1;
d265 1
a265 1
   disp_object struct_object_a4_1;
d267 3
a269 3
   def_entry(my_sig, FUN_DECL { name = "hw5",
                               source = makeBox([ptrType(my_type)]),
                               target = makeBox(INT_TYPE)
d273 1
a273 1
   show_entries(my_sig);
d275 1
a275 1
   val hw5 = define_foreign_fun(my_struct,my_sig)("hw5");
d279 1
a279 1
   get_int(int_object_a4_2);
d286 3
a288 3
   def_entry(my_sig, FUN_DECL { name = "hw6",
                               source = makeBox([]),
                               target = makeBox(UNSIGNED_INT_TYPE)
d292 1
a292 1
   show_entries(my_sig);
d296 1
a296 1
   val hw6 = define_foreign_fun(my_struct,my_sig)("hw6");
d300 1
a300 1
   get_word32(uint_object_a4_1);
d302 1
a302 1
   set_object_mode(int_object_a4_1,REMOTE_OBJECT);
d304 1
a304 1
   set_addr{obj=int_object_a4_1,addr=uint_object_a4_1};
d306 1
a306 1
   get_int(int_object_a4_1);
d311 3
a313 3
   val libX11 = load_object_file("/usr/lib/libX11.so.5.0",IMMEDIATE_LOAD);
   val libXt  = load_object_file("/usr/lib/libXt.so.5.0",IMMEDIATE_LOAD);
   val libXm  = load_object_file("/usr/lib/libXm.so.1.2",IMMEDIATE_LOAD);
d325 1
a325 1
   val x_struct = load_object_file(x_name,IMMEDIATE_LOAD);
d328 1
a328 1
   symbol_info(x_struct,"demo_box");
d338 1
a338 1
   val x_object1 = dup_object(x_object);
d348 1
a348 1
   val x_sig = new_signature();
d350 1
a350 1
   def_entry(x_sig,
d353 2
a354 2
                 source = makeBox([STRING_TYPE{ length = 64 }]),
                 target = makeBox(VOID_TYPE) });
d356 1
a356 1
   val demo_box = define_foreign_fun(x_struct,x_sig)("demo_box");
d358 1
a358 1
   set_string(x_object1,"Hope springs Eternal"); 
d380 1
a380 1
   val fobj = load_object (fpath,LOAD_LATER);
@


1.2.3.1
log
@branched from 1.2
@
text
@@


1.2.2.1
log
@branched from 1.2
@
text
@@


1.2.1.1
log
@branched from 1.2
@
text
@@


1.1
log
@new unit
New file.
@
text
@d13 3
a15 3
    val my_hostel =
         hostel{ alloc    = SUCC_AP,
                 overflow = EXTEND_OV,
d17 1
a17 1
                 status   = RDWR_HS   };
d19 3
a21 3
    val my_hostel_a4 =
         hostel{ alloc    = ALIGNED_4_AP,
                 overflow = BREAK_OV,
d23 1
a23 1
                 status   = RDWR_HS   };
d29 1
a29 1
   val my_struct = load_codeset(f_name,IMMEDIATE_LM);
d37 1
a37 1
   (* TEST 1.2 - Building C POD's *)
d39 3
a41 3
   val my_pod =
         pod { ctype     = VOID_CT,
               hostel    = my_hostel };
d43 1
a43 1
   val my_pod1 = dup_pod(my_pod);
d45 3
a47 3
   val int_pod1 =
         pod { ctype     = INT_CT,
               hostel    = my_hostel };
d49 1
a49 1
   set_int(int_pod1, 3);
d51 3
a53 3
   val int_pod2 =
         pod { ctype     = INT_CT,
               hostel    = my_hostel };
d55 3
a57 3
   set_int(int_pod2, 5);
   get_int(int_pod1);
   get_int(int_pod2);
d59 1
a59 1
   val my_sig = new_codeinfo();
d62 1
a62 1
   (* TEST 1.3 - Building C CodeInfos *)
d64 3
a66 3
   def_entry(my_sig, CODE_DI { name = "hw",
                               source = makeBOX([] : c_type list),
                               target = makeBOX(VOID_CT) });
d69 2
a70 2
   def_entry(my_sig, VAR_DI { name  = "my_value",
	 		      ctype = voidBOX() });
d79 1
a79 1
   val hw = attach(my_struct,my_sig)("hw");
d81 1
a81 1
   call(hw)([],my_pod);
d87 3
a89 3
   def_entry(my_sig, CODE_DI { name = "hw1",
                               source = makeBOX([] : c_type list),
                               target = makeBOX(INT_CT) });
d93 1
a93 1
   val hw1 = attach(my_struct,my_sig)("hw1");
d95 1
a95 1
   call(hw1)([],int_pod1);
d97 1
a97 1
   get_int(int_pod1);
d103 3
a105 3
   def_entry(my_sig, CODE_DI { name = "hw2",
                               source = makeBOX([INT_CT] : c_type list),
                               target = makeBOX(INT_CT) });
d109 1
a109 1
   val hw2 = attach(my_struct,my_sig)("hw2");
d111 1
a111 1
   set_int(int_pod1,4);
d113 1
a113 1
   call(hw2)([int_pod1],int_pod2);
d115 1
a115 1
   get_int(int_pod2);
d118 1
a118 1
   (* TEST 1.8 - Creating C-string pod's *)
d120 3
a122 3
   val str_pod1 =
         pod { ctype     = STRING_CT{ length = 64 },
               hostel    = my_hostel };
d124 2
a125 2
   set_string(str_pod1,"Hello World");
   get_string(str_pod1);
d127 2
a128 2
   val str_pod1_1 = dup_pod(str_pod1);
   cast_pod_type(str_pod1_1, ARRAY_CT{ ctype = CHAR_CT, length = 64 });
d130 3
a132 3
   val char_pod1 =
         pod { ctype     = CHAR_CT,
               hostel    = my_hostel };
d134 2
a135 2
   index_pod{array=str_pod1_1,tgt=char_pod1,index=0};
   get_char(char_pod1);
d137 2
a138 2
   index_pod{array=str_pod1_1,tgt=char_pod1,index=1};
   get_char(char_pod1);
d140 3
a142 3
   val str_pod2 =
         pod { ctype     = STRING_CT{ length = 64 },
               hostel    = my_hostel };
d144 1
a144 1
   set_string(str_pod2,"");
d150 3
a152 3
   def_entry(my_sig, CODE_DI { name = "hw3",
                               source = makeBOX([INT_CT] : c_type list),
                               target = makeBOX(STRING_CT{ length = 64 }) });
d156 1
a156 1
   val hw3 = attach(my_struct,my_sig)("hw3");
d158 1
a158 1
   set_int(int_pod1,24);
d160 1
a160 1
   call(hw3)([int_pod1],str_pod2);
d162 1
a162 1
   get_string(str_pod2);
d169 4
a172 4
   val libc = load_codeset("/lib/libc.so.1",IMMEDIATE_LM)
              handle _ => load_codeset("/usr/lib/libc.so",IMMEDIATE_LM)
              handle _ => load_codeset("/usr/lib/libc.so.1.8",IMMEDIATE_LM)
              handle _ => load_codeset("/usr/lib/libc.so.1.8.1",IMMEDIATE_LM);
d176 3
a178 3
   val libxm = load_codeset("/usr/lib/libXm.so.2.12",IMMEDIATE_LM)
               handle _ => load_codeset("/usr/lib/libXm.so.2.11",IMMEDIATE_LM)
               handle _ => load_codeset("/usr/lib/libXm.so.1.2",IMMEDIATE_LM);
d185 3
a187 3
   def_entry(my_sig, CODE_DI { name = "hw4",
                               source = makeBOX([STRING_CT{ length = 64 }]),
                               target = makeBOX(INT_CT)
d193 1
a193 1
   val hw4 = attach(my_struct,my_sig)("hw4");
d195 1
a195 1
   set_string(str_pod1,"Hope springs Eternal"); 
d197 1
a197 1
   call(hw4)([str_pod1],int_pod1);
d199 1
a199 1
   get_int(int_pod1);
d203 1
a203 1
   (* TEST 1.12 - CodeSets and foreign data maniputlation *)
d206 4
a209 4
       mk_struct_t("my_type",
                   [  ("num",  INT_CT),
                      ("ch",   CHAR_CT),
                      ("iptr", mk_star_t(INT_CT))
d213 3
a215 3
   def_entry(my_sig, TYPE_DI { name = "my_type",
                               defn = makeBOX(my_type),
                               size = voidBOX() }
d218 1
a218 1
   val void_pod_a4_1 = pod { ctype = VOID_CT, hostel = my_hostel_a4 };
d220 3
a222 3
   val struct_pod_a4_1 =
         pod { ctype     = my_type,
               hostel    = my_hostel_a4 };
d224 3
a226 3
   val ch_pod_a4_1 =
         pod { ctype     = CHAR_CT,
               hostel    = my_hostel_a4 };
d228 3
a230 3
   val int_pod_a4_1 =
         pod { ctype     = INT_CT,
               hostel    = my_hostel_a4 };
d232 3
a234 3
   val int_pod_a4_2 =
         pod { ctype     = INT_CT,
               hostel    = my_hostel_a4 };
d236 1
a236 1
   val tmp_pod_a4_1 = tmp_pod( void_pod_a4_1 );
d240 2
a241 2
   select_pod{ record=struct_pod_a4_1, field="num",  tgt=tmp_pod_a4_1};
   set_int(tmp_pod_a4_1,45);
d243 1
a243 1
   disp_pod tmp_pod_a4_1;
d245 2
a246 2
   select_pod{ record=struct_pod_a4_1, field="ch",   tgt=tmp_pod_a4_1};
   set_char(tmp_pod_a4_1,81);
d248 1
a248 1
   disp_pod tmp_pod_a4_1;
d250 1
a250 1
   select_pod{ record=struct_pod_a4_1, field="iptr", tgt=tmp_pod_a4_1};
d252 1
a252 1
   disp_pod tmp_pod_a4_1;
d254 1
a254 1
   set_ptr_addr_of{ ptr=tmp_pod_a4_1, data=int_pod_a4_1 };
d256 1
a256 1
   disp_pod tmp_pod_a4_1;
d258 1
a258 1
   set_int(int_pod_a4_1,2020);
d260 1
a260 1
   disp_pod tmp_pod_a4_1;
d262 2
a263 2
   set_ptr_type{ ptr=tmp_pod_a4_1, data=struct_pod_a4_1};
   set_ptr_addr_of{ ptr=tmp_pod_a4_1, data=struct_pod_a4_1};
d265 1
a265 1
   disp_pod tmp_pod_a4_1;
d267 1
a267 1
   disp_pod struct_pod_a4_1;
d269 3
a271 3
   def_entry(my_sig, CODE_DI { name = "hw5",
                               source = makeBOX([mk_star_t(my_type)]),
                               target = makeBOX(INT_CT)
d277 1
a277 1
   val hw5 = attach(my_struct,my_sig)("hw5");
d279 1
a279 1
   call(hw5)([tmp_pod_a4_1],int_pod_a4_2);
d281 1
a281 1
   get_int(int_pod_a4_2);
d285 1
a285 1
   (* TEST 1.13 - CodeSets and foreign data maniputlation *)
d288 3
a290 3
   def_entry(my_sig, CODE_DI { name = "hw6",
                               source = makeBOX([]),
                               target = makeBOX(UNSIGNED_INT_CT)
d296 1
a296 1
   val uint_pod_a4_1 = pod{ ctype = UNSIGNED_INT_CT, hostel = my_hostel_a4 };
d298 1
a298 1
   val hw6 = attach(my_struct,my_sig)("hw6");
d300 1
a300 1
   call(hw6)([],uint_pod_a4_1);
d302 1
a302 1
   get_word32(uint_pod_a4_1);
d304 1
a304 1
   set_pod_mode(int_pod_a4_1,REMOTE_PM);
d306 1
a306 1
   set_addr{obj=int_pod_a4_1,addr=uint_pod_a4_1};
d308 1
a308 1
   get_int(int_pod_a4_1);
d313 3
a315 3
   val libX11 = load_codeset("/usr/lib/libX11.so.5.0",IMMEDIATE_LM);
   val libXt  = load_codeset("/usr/lib/libXt.so.5.0",IMMEDIATE_LM);
   val libXm  = load_codeset("/usr/lib/libXm.so.1.2",IMMEDIATE_LM);
d319 3
a321 3
   val x_hostel =
         hostel{ alloc    = SUCC_AP,
                 overflow = EXTEND_OV,
d323 1
a323 1
                 status   = RDWR_HS   };
d327 1
a327 1
   val x_struct = load_codeset(x_name,IMMEDIATE_LM);
d334 1
a334 1
   (* TEST 2.2 - Building C POD's *)
d336 3
a338 3
   val x_pod =
         pod { ctype     = STRING_CT{ length = 64 },
               hostel    = x_hostel };
d340 1
a340 1
   val x_pod1 = dup_pod(x_pod);
d343 3
a345 3
   val void_pod =
         pod { ctype     = VOID_CT,
               hostel    = x_hostel };
d348 1
a348 1
   (* TEST 2.3 - Building C CodeInfos *)
d350 1
a350 1
   val x_sig = new_codeinfo();
d353 1
a353 1
             CODE_DI 
d355 2
a356 2
                 source = makeBOX([STRING_CT{ length = 64 }]),
                 target = makeBOX(VOID_CT) });
d358 1
a358 1
   val demo_box = attach(x_struct,x_sig)("demo_box");
d360 1
a360 1
   set_string(x_pod1,"Hope springs Eternal"); 
d362 1
a362 1
   call(demo_box)([x_pod1],void_pod);
@
