head	1.5;
access;
symbols
	MLW_daveb_inline_1_4_99:1.5.8
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.5
	MLWorks_20c0_1998_08_04:1.5
	MLWorks_20b2c2_1998_06_19:1.5
	MLWorks_20b2_Windows_1998_06_12:1.5
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_workspace_97:1.5.7
	MLWorks_dt_wizard:1.5.6
	MLWorks_10r3:1.5.5.1.3
	MLWorks_10r2_551:1.5.5.1.2
	MLWorks_11:1.5.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.5.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.5.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.5
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.3.1.1
	MLWorks_gui_1996_12_18:1.5.4
	MLWorks_1_0_Win32_1996_12_17:1.5.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.1.1
	MLWorks_1_0_Irix_1996_11_28:1.5.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.2
	MLWorks_1_0_Unix_1996_11_14:1.5.1
	MLWorks_Open_Beta2_1996_10_11:1.3.2
	MLWorks_License_dev:1.3.1
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ *  @;


1.5
date	96.11.06.11.25.04;	author matthew;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1
	1.5.5.1
	1.5.6.1
	1.5.7.1
	1.5.8.1;
next	1.4;

1.4
date	96.10.25.12.57.21;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.09.20.14.57.40;	author io;	state Exp;
branches
	1.3.1.1
	1.3.2.1;
next	1.2;

1.2
date	96.05.19.16.12.16;	author brianm;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	96.05.19.11.46.36;	author brianm;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.12.33;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.10.07.16.03.16;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.10.17.11.21.32;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.11.14.12.45.18;	author hope;	state Exp;
branches
	1.5.1.1.1.1;
next	;

1.5.1.1.1.1
date	96.11.28.14.57.12;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.11.22.18.05.50;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.12.17.17.44.35;	author hope;	state Exp;
branches
	1.5.3.1.1.1;
next	;

1.5.3.1.1.1
date	97.02.24.11.34.00;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.12.18.09.38.34;	author hope;	state Exp;
branches;
next	;

1.5.5.1
date	97.05.12.10.30.53;	author hope;	state Exp;
branches
	1.5.5.1.1.1
	1.5.5.1.2.1
	1.5.5.1.3.1;
next	;

1.5.5.1.1.1
date	97.07.28.18.16.00;	author daveb;	state Exp;
branches;
next	;

1.5.5.1.2.1
date	97.09.08.17.09.33;	author daveb;	state Exp;
branches;
next	;

1.5.5.1.3.1
date	97.09.09.14.04.57;	author daveb;	state Exp;
branches;
next	;

1.5.6.1
date	97.09.10.19.19.14;	author brucem;	state Exp;
branches;
next	;

1.5.7.1
date	97.09.11.20.50.24;	author daveb;	state Exp;
branches;
next	;

1.5.8.1
date	99.04.01.17.54.05;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Renamed file.
@


1.5
log
@[Bug #1728]
__integer becomes __int
@
text
@(*  ==== FOREIGN INTERFACE : FOREIGN_STORE ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  
 *
 *  Revision Log
 *  ------------
 *  $Log: __store.sml,v $
 *  Revision 1.4  1996/10/25  12:57:21  io
 *  current naming conventions
 *
 *  Revision 1.3  1996/09/20  14:57:40  io
 *  [Bug #1603]
 *  convert ByteArray to Internal.ByteArray
 *
 *  Revision 1.2  1996/05/19  16:12:16  brianm
 *  Beta release modifications.
 *
 *  Revision 1.1  1996/05/19  13:59:07  brianm
 *  new unit
 *  Renamed file.
 *
 * Revision 1.9  1996/05/13  10:02:07  matthew
 * Changes to basis.
 *
 * Revision 1.8  1996/05/01  11:41:39  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.7  1996/04/30  14:59:08  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.6  1996/04/18  16:57:16  jont
 * initbasis becomes basis
 *
 * Revision 1.5  1995/09/12  16:23:04  daveb
 * Word conversion functions have changed.
 *
 *  Revision 1.4  1995/09/07  22:43:41  brianm
 *  Modifications for reorganisation & documentation.
 *
 *  Revision 1.3  1995/06/21  16:31:53  brianm
 *  Adding remote access, diagnostics and other facilities.
 *
 *  Revision 1.2  1995/05/04  19:23:38  brianm
 *  Removing restrictive eqtype constraints & introduce abstypes in
 *  various implementing types.
 *
 *  Revision 1.1  1995/04/25  11:35:59  brianm
 *  new unit
 *  New file.
 *
 *
 *)

require "^.basis.__int";
require "^.basis.__word32";

require "static_bytearray";
require "types";
require "utils";

require "__static_bytearray";
require "__types";
require "__utils";

require "store";

structure ForeignStore_ : FOREIGN_STORE =
   struct

     structure StaticByteArray : STATIC_BYTEARRAY = StaticByteArray_
     structure FIUtils : FOREIGN_UTILS = ForeignUtils_
     structure FITypes : FOREIGN_TYPES = ForeignTypes_

   (* Mapping *)

     open FITypes

     structure ByteArray = MLWorks.Internal.ByteArray

     type static_bytearray  = StaticByteArray.static_bytearray

     val static_array       = StaticByteArray.alloc_array

     val static_addr        = StaticByteArray.address_of

     val to_bytearray : static_bytearray -> bytearray  =
           StaticByteArray.to_bytearray

     val copy_ba'           = ByteArray.copy
     val copy_ba  =
         fn (src,src_st,len,tgt,tgt_st) =>
            copy_ba'(src,src_st,src_st+len,tgt,tgt_st)

     val sub_bytearray  =  ByteArray.subarray
     val length_ba      =  ByteArray.length
     val to_list        =  ByteArray.to_list

     val disp                 =  FIUtils.disp
     val sep_list             =  FIUtils.sep_items

     val word32_to_hex        =  FIUtils.word32_to_hex
     val bytearray_to_hex     =  FIUtils.bytearray_to_hex
     val bytearray_to_string  =  FIUtils.bytearray_to_string

     val addrToInt          =  Word32.toIntX
     val intToAddr          =  Word32.fromInt
     val pl32               =  Word32.+
     val mi32               =  Word32.-

     infix 6 pl32 mi32


   (* Implementation auxiliaries *)

     fun static_copy(src_sba,st,len,dest_sba,offset) =
         let val src_ba    = to_bytearray(src_sba)
             val dest_ba   = to_bytearray(dest_sba)
         in 
             copy_ba(src_ba,st,len,dest_ba,offset)
         end


     fun addr_plus(a,i)    = a pl32 (intToAddr i)
     fun addr_minus(a1,a2) = addrToInt(a1 mi32 a2)

   (* Exported Definitions *)

     datatype store_status = LOCKED_STATUS | RD_STATUS | WR_STATUS | RDWR_STATUS 

     datatype alloc_policy = ORIGIN | SUCC | ALIGNED_4 | ALIGNED_8

     datatype overflow_policy = BREAK | EXTEND | RECYCLE

     abstype store =
              STORE of
                {
                     origin : address ref,
                     status : store_status ref,
                      alloc : alloc_policy,
                   overflow : overflow_policy,
                       size : int ref,
                        top : int ref,
                    content : static_bytearray ref
                }
     with
	fun storeAlloc(STORE{alloc, ...})         =  alloc
	fun storeOverflow(STORE{overflow, ...})   =  overflow
	fun store_origin(STORE{origin, ...})       = !origin
	fun storeSize(STORE{size, ...})           = !size

	fun storeStatus(STORE{status, ...}) = !status
	fun setStoreStatus(STORE{status, ...}, new_status) = (status := new_status)

	fun store_content(STORE{content, ...}) = to_bytearray(!content)

	fun isStandardStore(STORE{alloc=ORIGIN, ...})    =  false
	  | isStandardStore(STORE{overflow=BREAK, ...})  =  true
	  | isStandardStore(_)  =  false

	fun isEphemeralStore(STORE{alloc=ORIGIN, ...})      =  false
	  | isEphemeralStore(STORE{overflow=RECYCLE, ...})  =  true
	  | isEphemeralStore(_)  =  false


	exception ReadOnly
	exception WriteOnly

	local
	   fun round_up(size,base) =
	       let val spill = (size mod base)
	       in
		   size + (base - spill)
	       end

	   fun round_down(size,base) =
	       let val spill = (size mod base)
	       in
		   size - spill
	       end

	   fun adjust_size_up(ORIGIN,    size) = size
	     | adjust_size_up(SUCC,     size) = size
	     | adjust_size_up(ALIGNED_4, size) = round_up(size,4)
	     | adjust_size_up(ALIGNED_8, size) = round_up(size,8)

	   fun adjust_size_down(ORIGIN,    size) = size
	     | adjust_size_down(SUCC,     size) = size
	     | adjust_size_down(ALIGNED_4, size) = round_down(size,4)
	     | adjust_size_down(ALIGNED_8, size) = round_down(size,8)
	in
	   val adjust_store_size       = adjust_size_up
	   val adjust_object_size_above = adjust_size_up
	   val adjust_object_size_below = adjust_size_down
	end

	fun store {alloc,overflow,status,size} =
	    let val size' = adjust_store_size(alloc,size)
		val store = static_array(size')
		val addr  = static_addr(store,0)
	    in
		STORE{ origin   =  ref(addr),
			status   =  ref(status),
			alloc    =  alloc,
			overflow =  overflow,
			size     =  ref(size'),
			top      =  ref(0),
			content  =  ref(store)
		      }
	    end

	exception ExpandStore

	local
	   val min_expand = 512
	   val max_expand = min_expand * min_expand

	   fun adjust_increment(n) = Int.min(max_expand, Int.max(n,min_expand))

	   fun expand_content(STORE{origin,content,size,alloc, ...},increment) =
	       let val new_size  = adjust_store_size(alloc,!size + increment)
		   val new_store = static_array(new_size)
		   val new_addr  = static_addr(new_store,0)
	       in
		   static_copy(!content,0,!size,new_store,0);
		   content := new_store;
		   size := new_size;
		   origin := new_addr
	       end

	   fun expand_store(store,increment') =
	       let val increment = adjust_increment(increment')
	       in
		   case storeStatus(store) of
		      RDWR_STATUS => expand_content(store,increment)
		   |
		      WR_STATUS   => expand_content(store,increment)
		   |
		      _      => raise ExpandStore
	       end

	   fun expand_store'(store,space_required) =
	       let val size = storeSize(store)
		   val increment = Int.min(2 * space_required, size)
	       in
		   expand_store(store,increment)
	       end
	in

	   fun expand(store,increment) =
	       if isStandardStore(store) 
	       then expand_store(store,increment)
	       else expand_store'(store,increment)

	   fun expand_managed(store,space_required) =
	       if isStandardStore(store) 
	       then raise ExpandStore
	       else expand_store'(store,space_required)

	end



	(* ==== OVERFLOW & ALLOCATION MANAGEMENT ====


	In general we have the following relationships holding:

	  %--- .. ---%---------------%---- .. ----%--------%---------
	  %          %    OBJECT     %            % free   %     
	  %          %               %            % space  %     
	  %--- .. ---%---------------%---- .. ----%--------%---------
	  0          |---obj_size---> ^            ^       ^
		     ^                |            |       |
		     |                |            |       |
	  offset ---/                 |            |       |
				      |            |       |
	  obj_end -------------------/             |       |
						   |       |
	  top (= next_offset) --------------------/        |
							   |
	  store_size ------------------------------------/

	So:

	       0 <= offset < obj_end = offset + obj_size
			   <= top = next_offset
			   <= store_size

               free_space = store_size - top

               Each object : offset <= i < obj_end 


	When objects are either originally allocated or (conceptually)
	moved, this may cause:

	   - allocation of (some) remaining free space in the store
	     to be used by an object.

	   - overflow of the store by consuming all remaining
	     free space.  This may lead to an ML exception being
	     raised or to the store being extended in some way.

	In either case the object has a putative value for the index just
	beyond the end, called new_obj_end.

	  The store needs allocation iff:   new_obj_end > top
	  The store has overflowed iff:     new_obj_end > store_size

	*)

	local

	   fun adjust_next_top( ORIGIN, _ ) = 0
	     | adjust_next_top( _, next_top )  = next_top

	in

	   fun fresh_object_offset(store,obj_size) =
	       let val STORE{alloc,top,size,overflow, ...} = store
		   val new_offset = !top
		   val new_obj_end' = new_offset + obj_size
		   val new_obj_end = adjust_object_size_above(alloc,new_obj_end')
		   val free_space = !size - new_obj_end
	       in 
		   ( if free_space < 0
		     then case overflow of
			    EXTEND   =>
			      ( expand(store,~free_space);
				top := adjust_next_top(alloc,new_obj_end)
			      )
			  | RECYCLE  => top := 0
			  | BREAK    => raise ExpandStore
		     else top := adjust_next_top(alloc,new_obj_end)
		   );
		   new_offset
	       end

	   fun adjust_store(store,obj_offset,obj_size) =
	       let val STORE{top, ...} = store
		   val next_offset = !top
		   val new_obj_end = obj_offset + obj_size
		   val remaining_space = next_offset - new_obj_end
	       in 
		   if remaining_space < 0
		   then ignore( fresh_object_offset(store,obj_size) )
		   else ()
	       end
	end

        (* Diagnostic tools *)
        local
           fun push_if b x stk = if b then x :: stk else stk

           fun str_kind(store) =
               let val strl = push_if (isStandardStore store) "standard" []
                   val strl = push_if (isEphemeralStore store) "ephemeral" strl
               in
                   if strl = [] then "non-standard" else
		     concat (sep_list ", " strl)
               end

           fun str_status(LOCKED_STATUS)  = "LOCKED_STATUS (locked - no access)"
             | str_status(RD_STATUS)      = "RD_STATUS (read-only access)"
             | str_status(WR_STATUS)      = "WR_STATUS (write-only access)"
             | str_status(RDWR_STATUS)    = "RDWR_STATUS (read/write access)"

           fun str_alloc(ORIGIN)  =
                 "ORIGIN     (allocate objects at the origin)"
             | str_alloc(SUCC)   =
                 "SUCC      (allocate objects at the top end)"
             | str_alloc(ALIGNED_4)  =
                 "ALIGNED_4  (allocate objects at the top end - 4-byte aligned)"
             | str_alloc(ALIGNED_8)  =
                 "ALIGNED_8  (allocate objects at the top end - 8-byte aligned)"
  
           fun str_overflow(BREAK) =
                 "BREAK    (raise exception on overflow)"
             | str_overflow(EXTEND) =
                 "EXTEND   (extend store on overflow)"
             | str_overflow(RECYCLE) =
                 "RECYCLE  (restart at origin on overflow)"
        in

	   fun storeInfo (store) =
               let val STORE{origin, status, alloc, overflow, size, top, ...} = store
                   val size = !size
                   val top  = !top
               in
		   { kind     = str_kind(store),
                     origin   = !origin,
		     status   = str_status(!status),
		     alloc    = str_alloc(alloc),
		     overflow = str_overflow(overflow),
		     size     = size,
		     top      = top,
		     free     = (size - top) }
               end

	   fun storeData {store, start, length} =
               let val data = store_content(store)
                   val ba = sub_bytearray(data,start,(start + length))
               in
                   to_list(ba)
               end

	   fun storeDataHex {store, start, length} =
               let val data = store_content(store)
               in
                   bytearray_to_hex{arr=data,st=start,len=length}
               end

	   fun storeDataAscii {store, start, length} =
               let val data = store_content(store)
               in
                   bytearray_to_string{arr=data,st=start,len=length}
               end


           fun viewStore (store) =
	       let val { kind, origin, status, alloc, overflow, size, top, free } =
		       storeInfo store
	       in
		 concat [ "\n\n",
			       "   Store (", kind, ", ", status, ")\n",
			       "          alloc      = ", alloc, "\n",
                               "          overflow   = ", overflow, "\n",
			       "          origin     = ", word32_to_hex(origin), "\n",
			       "          top (size) = ", Int.toString top,
                                          " (", Int.toString size, ")", "\n",
			       "          free = (size - top) = ",
                                          Int.toString free, "\n",
			       "\n\n" ]
	       end

           val dispStore = disp viewStore

	   fun diffAddr a1 a2 = addr_minus(a1,a2)

	   val incrAddr = addr_plus
        end

     end
   end;
@


1.5.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:04  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:04  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:04  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.5.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:04  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 *  Revision 1.5.5.1  1997/05/12  10:30:53  hope
 *  branched from 1.5
 *
@


1.5.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 *  Revision 1.5.5.1  1997/05/12  10:30:53  hope
 *  branched from 1.5
 *
@


1.5.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 *  Revision 1.5.5.1  1997/05/12  10:30:53  hope
 *  branched from 1.5
 *
@


1.5.4.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:04  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.3.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:04  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.3.1.1.1
log
@branched from 1.5.3.1
@
text
@a11 3
 *  Revision 1.5.3.1  1996/12/17  17:44:35  hope
 *  branched from 1.5
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:04  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:04  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.1.1.1.1
log
@branched from 1.5.1.1
@
text
@a11 3
 *  Revision 1.5.1.1  1996/11/14  12:45:18  hope
 *  branched from 1.5
 *
@


1.4
log
@current naming conventions
@
text
@d12 3
d61 1
a61 1
require "^.basis.__integer";
@


1.3
log
@[Bug #1603]
convert ByteArray to Internal.ByteArray
@
text
@d12 4
d58 2
a59 3
require "../basis/__integer";
require "../basis/__general";
require "../basis/__word32";
a70 3



a80 1
     open General
a108 6
     val extract            =  General.valOf
     val int_string         =  Int.toString

     val min                =  Int.min
     val max                =  Int.max

d150 2
a151 2
	fun store_alloc(STORE{alloc, ...})         =  alloc
	fun store_overflow(STORE{overflow, ...})   =  overflow
d153 1
a153 1
	fun store_size(STORE{size, ...})           = !size
d155 2
a156 2
	fun store_status(STORE{status, ...}) = !status
	fun set_store_status(STORE{status, ...}, new_status) = (status := new_status)
d160 7
a166 7
	fun is_standard_store(STORE{alloc=ORIGIN, ...})    =  false
	  | is_standard_store(STORE{overflow=BREAK, ...})  =  true
	  | is_standard_store(_)  =  false

	fun is_ephemeral_store(STORE{alloc=ORIGIN, ...})      =  false
	  | is_ephemeral_store(STORE{overflow=RECYCLE, ...})  =  true
	  | is_ephemeral_store(_)  =  false
d221 1
a221 1
	   fun adjust_increment(n) = min(max_expand,max(n,min_expand))        
d237 1
a237 1
		   case store_status(store) of
d246 2
a247 2
	       let val size = store_size(store)
		   val increment = min(2 * space_required, size)
d254 1
a254 1
	       if is_standard_store(store) 
d259 1
a259 1
	       if is_standard_store(store) 
d360 2
a361 2
               let val strl = push_if (is_standard_store store) "standard" []
                   val strl = push_if (is_ephemeral_store store) "ephemeral" strl
d364 1
a364 1
                   String.implode(sep_list ", " strl)
d389 1
a389 1
	   fun store_info (store) =
d404 1
a404 1
	   fun store_data {store, start, length} =
d411 1
a411 1
	   fun store_data_hex {store, start, length} =
d417 1
a417 1
	   fun store_data_ascii {store, start, length} =
d424 1
a424 1
           fun view_store (store) =
d426 1
a426 1
		       store_info store
d428 1
a428 1
		   String.implode   [ "\n\n",
d433 2
a434 2
			       "          top (size) = ", int_string(top),
                                          " (", int_string(size), ")", "\n",
d436 1
a436 1
                                          int_string(free), "\n",
d440 1
a440 1
           val disp_store = disp view_store
d442 1
a442 1
	   fun diff_addr a1 a2 = addr_minus(a1,a2)
d444 1
a444 1
	   val incr_addr = addr_plus
@


1.3.2.1
log
@branched from 1.3
@
text
@a11 4
 *  Revision 1.3  1996/09/20  14:57:40  io
 *  [Bug #1603]
 *  convert ByteArray to Internal.ByteArray
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a11 4
 *  Revision 1.3  1996/09/20  14:57:40  io
 *  [Bug #1603]
 *  convert ByteArray to Internal.ByteArray
 *
@


1.2
log
@Beta release modifications.
@
text
@d11 4
a14 1
 *  $Log: _store.sml,v $
d83 1
a83 1
     structure ByteArray = MLWorks.ByteArray
@


1.2.1.1
log
@branched from 1.2
@
text
@d11 1
a11 4
 *  $Log: __store.sml,v $
 *  Revision 1.2  1996/05/19  16:12:16  brianm
 *  Beta release modifications.
 *
@


1.1
log
@new unit
Renamed file.
@
text
@d11 25
a35 3
 *  $Log: __store.sml,v $
 * Revision 1.3  1996/04/30  14:59:58  matthew
 * Removing utils/*integer
d37 2
a38 2
 * Revision 1.2  1995/06/15  14:59:47  brianm
 * Adding FI diagnostics, more facilities including remote access.
d40 5
a44 1
 *  Revision 1.1  1995/04/25  11:23:42  brianm
a47 5
# Revision 1.1  1995/03/27  15:47:52  brianm
# new unit
#
# New file.
#
d51 8
a59 1

a61 1
require "_store";
d63 390
a452 5
structure ForeignStore_ = ForeignStore(
   structure StaticByteArray = StaticByteArray_
   structure FITypes = ForeignTypes_
   structure FIUtils = ForeignUtils_
);
@
