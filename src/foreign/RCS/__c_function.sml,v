head	1.6;
access;
symbols
	MLW_daveb_inline_1_4_99:1.6.8
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.6
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_workspace_97:1.6.7
	MLWorks_dt_wizard:1.6.6
	MLWorks_10r3:1.6.5.1.3
	MLWorks_10r2_551:1.6.5.1.2
	MLWorks_11:1.6.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.5.1
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.6.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.5
	MLWorks_BugFix_1997_04_24:1.6
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.3.1.1
	MLWorks_gui_1996_12_18:1.6.4
	MLWorks_1_0_Win32_1996_12_17:1.6.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.1.1
	MLWorks_1_0_Irix_1996_11_28:1.6.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.2
	MLWorks_1_0_Unix_1996_11_14:1.6.1
	MLWorks_Open_Beta2_1996_10_11:1.5.2
	MLWorks_License_dev:1.5.1
	MLWorks_1_open_beta_1996_09_13:1.4.1
	MLWorks_Open_Beta_1996_08_22:1.4
	MLWorks_Beta_1996_07_02:1.4
	MLWorks_Beta_1996_06_07:1.4
	MLWorks_Beta_1996_06_06:1.4
	MLWorks_Beta_1996_06_05:1.4
	MLWorks_Beta_1996_06_03:1.4
	MLWorks_Beta_1996_05_31:1.4
	MLWorks_Beta_1996_05_30:1.4;
locks; strict;
comment	@ * @;


1.6
date	96.10.23.16.47.44;	author io;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1
	1.6.6.1
	1.6.7.1
	1.6.8.1;
next	1.5;

1.5
date	96.09.20.14.48.56;	author io;	state Exp;
branches
	1.5.1.1
	1.5.2.1;
next	1.4;

1.4
date	96.05.24.01.19.14;	author brianm;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	96.04.18.16.55.02;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	95.09.07.22.43.36;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	95.04.25.11.14.52;	author brianm;	state Exp;
branches;
next	;

1.4.1.1
date	96.09.13.11.12.13;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.10.07.16.02.55;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.17.11.21.11;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.11.14.12.44.57;	author hope;	state Exp;
branches
	1.6.1.1.1.1;
next	;

1.6.1.1.1.1
date	96.11.28.14.56.51;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.11.22.18.05.23;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.12.17.17.44.15;	author hope;	state Exp;
branches
	1.6.3.1.1.1;
next	;

1.6.3.1.1.1
date	97.02.24.11.33.35;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.12.18.09.38.13;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	97.05.12.10.30.31;	author hope;	state Exp;
branches
	1.6.5.1.1.1
	1.6.5.1.2.1
	1.6.5.1.3.1;
next	;

1.6.5.1.1.1
date	97.07.28.18.15.58;	author daveb;	state Exp;
branches;
next	;

1.6.5.1.2.1
date	97.09.08.17.09.32;	author daveb;	state Exp;
branches;
next	;

1.6.5.1.3.1
date	97.09.09.14.04.55;	author daveb;	state Exp;
branches;
next	;

1.6.6.1
date	97.09.10.19.19.12;	author brucem;	state Exp;
branches;
next	;

1.6.7.1
date	97.09.11.20.50.22;	author daveb;	state Exp;
branches;
next	;

1.6.8.1
date	99.04.01.17.54.02;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.6
log
@[Bug #1547]
current naming conventions
@
text
@(*  ==== FOREIGN INTERFACE : C FUNCTION ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *
 *  Revision Log
 *  ------------
 *  $Log: __c_function.sml,v $
 * Revision 1.5  1996/09/20  14:48:56  io
 * [Bug #1603]
 * convert ByteArray to Internal.ByteArray
 *
 * Revision 1.4  1996/05/24  01:19:14  brianm
 * Beta release modifications.
 *
 * Revision 1.8  1996/04/18  17:05:51  jont
 * initbasis becomes basis
 *
 * Revision 1.7  1996/03/20  15:12:46  matthew
 * Language revision
 *
 * Revision 1.6  1995/09/08  14:00:15  brianm
 * Further modification for updates and general reorganisation.
 *
 *  Revision 1.5  1995/09/07  22:43:38  brianm
 *  Modifications for reorganisation & documentation.
 *
 *  Revision 1.4  1995/07/18  12:17:13  brianm
 *  Changing names of deferred data-type operators (stream-edit)
 *
 *  Revision 1.3  1995/06/26  12:01:06  brianm
 *  Adding remote access, diagnostics and other facilities.
 *
 *  Revision 1.2  1995/05/04  19:30:19  brianm
 *  Removing restrictive eqtype constraints & introduce abstypes in
 *  various implementing types.
 *
 *  Revision 1.1  1995/04/25  11:29:08  brianm
 *  new unit
 *  New file.
 *
 *
 *)

require "^.basis.__list";
require "c_signature";
require "c_structure";
require "static_bytearray";
require "aliens";
require "structure";
require "object";
require "utils";

require "__static_bytearray";
require "__c_signature";
require "__c_structure";
require "__aliens";
require "__structure";
require "__object";
require "__utils";

require "c_function";


structure CFunction_ : C_FUNCTION =
  struct

    structure StaticByteArray : STATIC_BYTEARRAY    = StaticByteArray_
    structure CSignature      : C_SIGNATURE         = CSignature_
    structure CStructure      : C_STRUCTURE         = CStructure_
    structure FIAliens        : FOREIGN_ALIENS      = ForeignAliens_
    structure FIStructure     : FOREIGN_STRUCTURE   = Structure_
    structure FIObject        : FOREIGN_OBJECT      = ForeignObject_
    structure FIUtils         : FOREIGN_UTILS       = ForeignUtils_

    structure CObject       = CSignature.CObject

    open FIUtils

    structure FITypes       = FITypes
    open FITypes

    open CStructure
    open CSignature
    open CObject

 (* Internal utilities *)

    val MLWcast  =  MLWorks.Internal.Value.cast

 (* ByteArray operators *)

    structure ByteArray  =  MLWorks.Internal.ByteArray

    type static_bytearray = StaticByteArray.static_bytearray

(*
    val null_byte     =  Word8.intToWord(0)
    val static_array  =  fn sz => StaticByteArray.array(sz,null_byte)
 *)

    val static_array  =  StaticByteArray.alloc_array
    val to_bytearray  =  StaticByteArray.to_bytearray
    val address_of    =  StaticByteArray.address_of

    val module  =  fn (c_str) => FIStructure.module(to_struct c_str)

    type foreign_item    =  FIAliens.foreign_item

    val get_item_later   =  FIAliens.get_item_later
    val get_item_now     =  FIAliens.get_item_now
 
    val call_alien_code  =  FIAliens.call_alien_code

    val examine_object    =  CObject.examine_object
    val object_value      =  CObject.object_value
    val set_object_value  =  CObject.set_object_value
    val object_address    =  CObject.object_address

    val int_to_bytearray  =  FIUtils.int_to_bytearray
    val bytearray_to_int  =  FIUtils.bytearray_to_int

    val string_to_bytearray  =  FIUtils.string_to_bytearray
    val bytearray_to_string  =  FIUtils.bytearray_to_string

    val word32_to_bytearray  =  FIUtils.word32_to_bytearray
    val bytearray_to_word32  =  FIUtils.bytearray_to_word32

  (* Exported Definitions *)

    type c_structure  = CStructure.c_structure
    type c_signature  = CSignature.c_signature

    abstype c_function =
             CFUN of { source : c_type list,
                       target : c_type,
                       code   : foreign_item }
    with

       fun defineForeignFun(c_str,c_sig) =
	   let fun value_info nm = symbolInfo(c_str,nm)
	       val value_decl = lookupEntry(c_sig)

	       val f_mod = module(c_str)
	       val (_,l_mode) = fileInfo(c_str)
	       val get_item  =
		   case l_mode of
		     IMMEDIATE_LOAD =>  get_item_later
		   |
		     DEFERRED_LOAD   =>  get_item_now

	       fun get_code nm = get_item(f_mod,nm)            

	       fun get_fun (nm) = 
		   case value_info(nm) of
		     CODE_VALUE =>
		       ( case value_decl(nm) of
			   FUN_DECL{source,target, ...} =>
			      CFUN{ source = source,
				    target = target,
				    code   = get_code(nm) }
			 |
			   _ => raise Fail "code item has wrong type"
		       )
		   | UNKNOWN_VALUE => raise Fail "unrecognised name"
		   | _ => raise Fail "non code item"
	   in
	      get_fun
	   end

       local

	  val max_call_args = 32

	  fun check_types(len,ty_lst) =
	      let fun chk_ty'(ty::ty_lst,pd::pd_lst) =
		      let val pdty = objectType(pd)
		      in
			  equalType(ty,pdty)
			  andalso
			  chk_ty'(ty_lst,pd_lst)
		      end
		    | chk_ty'(_,_) = true

		  fun chk_ty(pd_lst) =
			(length pd_lst = len)
			andalso
			chk_ty'(ty_lst,pd_lst)
	      in
		  chk_ty
	      end

	  fun check_callable_type(STRING_TYPE(_)) = true
	    | check_callable_type(ARRAY_TYPE(_)) = true
	    | check_callable_type(ty) = sizeOf(ty) <= 4

	  fun check_callable_types(ty_lst) =
		(List.all check_callable_type ty_lst)
		andalso
		(length ty_lst <= max_call_args)

	  local
	     val arg_size = sizeOf(INT_TYPE)

	     val args_buffer_size = arg_size * max_call_args

	     val args_buffer   =  static_array(args_buffer_size)
	     val args_addr     =  address_of(args_buffer,0)
	     val args_buffer'  =  to_bytearray(args_buffer)

	     fun copy_object_addr(obj,i) =
		 let val addr = object_address(obj)
		 in
		     word32_to_bytearray{src=addr,arr=args_buffer',st=i}
		 end

	     fun copy_arg_data(obj,i) =
		 case objectType(obj) of
		   STRING_TYPE(_) => copy_object_addr(obj,i)
		 |
		   ARRAY_TYPE(_)  => copy_object_addr(obj,i)
		 |
		   _ => object_value(obj,args_buffer',i)

	     val result_buffer   =  static_array(arg_size)
	     val result_addr     =  address_of(result_buffer,0)

	     val result_buffer'  =  to_bytearray(result_buffer)

	     fun copy_result_object(obj) =
		 let val addr = bytearray_to_word32{arr=result_buffer',st=0}
		 in
		     examine_object(obj,addr)
		 end

	     fun copy_tgt_data(obj) =
		 case objectType(obj) of
		   STRING_TYPE(_) => copy_result_object(obj)
		 |
		   ARRAY_TYPE(_)  => copy_result_object(obj)
		 |
		   _ => set_object_value(obj,result_buffer',0)
	  in
	     fun call_code(code,arg_list,arity,tgt) =
		 let fun wrap_args(idx,pd::pd_lst) =
			 ( copy_arg_data(pd,idx);
			   wrap_args(idx+arg_size,pd_lst)
			 )
		       | wrap_args(_) = ()
		 in

		   wrap_args(0,arg_list);
		   call_alien_code(code,args_addr,arity,result_addr);
		   copy_tgt_data(tgt)
		 end
	  end
       in
	  fun call (CFUN{source,target,code}) =
	      let val ty_lst = target :: source
	      in
		  if check_callable_types(ty_lst)
		  then let val arity  = length source
			   val chk_ty = check_types(1+arity,ty_lst)

			   fun make_call(src_pdlst,tgt_pd) =
			       let val pdlst = tgt_pd :: src_pdlst
			       in
				   if chk_ty(pdlst)
				   then call_code(code,src_pdlst,arity,tgt_pd)
				   else raise Fail "runtime type failure"
			       end
		       in
			   make_call
		       end
		  else raise Fail "infeasible calling types"
	      end
       end
    end
  end;
@


1.6.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.6  1996/10/23  16:47:44  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.6.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 4
 * Revision 1.6  1996/10/23  16:47:44  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.6.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 4
 * Revision 1.6  1996/10/23  16:47:44  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.6.5.1
log
@branched from 1.6
@
text
@a10 4
 * Revision 1.6  1996/10/23  16:47:44  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.6.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
 * Revision 1.6.5.1  1997/05/12  10:30:31  hope
 * branched from 1.6
 *
@


1.6.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
 * Revision 1.6.5.1  1997/05/12  10:30:31  hope
 * branched from 1.6
 *
@


1.6.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
 * Revision 1.6.5.1  1997/05/12  10:30:31  hope
 * branched from 1.6
 *
@


1.6.4.1
log
@branched from 1.6
@
text
@a10 4
 * Revision 1.6  1996/10/23  16:47:44  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a10 4
 * Revision 1.6  1996/10/23  16:47:44  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.6.3.1.1.1
log
@branched from 1.6.3.1
@
text
@a10 3
 * Revision 1.6.3.1  1996/12/17  17:44:15  hope
 * branched from 1.6
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a10 4
 * Revision 1.6  1996/10/23  16:47:44  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a10 4
 * Revision 1.6  1996/10/23  16:47:44  io
 * [Bug #1547]
 * current naming conventions
 *
@


1.6.1.1.1.1
log
@branched from 1.6.1.1
@
text
@a10 3
 * Revision 1.6.1.1  1996/11/14  12:44:57  hope
 * branched from 1.6
 *
@


1.5
log
@[Bug #1603]
convert ByteArray to Internal.ByteArray
@
text
@d11 4
d47 1
a47 6
require "../basis/__general";
require "../basis/__word8";

require "../utils/lists";
require "../utils/__lists";

a70 1
    structure Lists           :  LISTS              = Lists_
a79 2

    open General
a121 13

 (* General imports *)

    exception Fail  =  General.Fail

    val extract  =  General.valOf

    val llength  =  Lists.length
    val forall   =  Lists.forall
    val iterate  =  Lists.iterate
    val member   =  Lists.member
    val tl       =  Lists.tl

d142 3
a144 3
       fun define_foreign_fun(c_str,c_sig) =
	   let fun value_info nm = symbol_info(c_str,nm)
	       val value_decl = lookup_entry(c_sig)
d147 1
a147 1
	       val (_,l_mode) = file_info(c_str)
d179 1
a179 1
		      let val pdty = object_type(pd)
d181 1
a181 1
			  equal_type(ty,pdty)
d188 1
a188 1
			(llength pd_lst = len)
d197 1
a197 1
	    | check_callable_type(ty) = size_of(ty) <= 4
d200 1
a200 1
		(forall check_callable_type ty_lst)
d202 1
a202 1
		(llength ty_lst <= max_call_args)
d205 1
a205 1
	     val arg_size = size_of(INT_TYPE)
d220 1
a220 1
		 case object_type(obj) of
d239 1
a239 1
		 case object_type(obj) of
d264 1
a264 1
		  then let val arity  = llength source
@


1.5.2.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/09/20  14:48:56  io
 * [Bug #1603]
 * convert ByteArray to Internal.ByteArray
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/09/20  14:48:56  io
 * [Bug #1603]
 * convert ByteArray to Internal.ByteArray
 *
@


1.4
log
@Beta release modifications.
@
text
@d10 4
a13 1
 *  $Log: _c_function.sml,v $
d99 1
a99 1
    structure ByteArray  =  MLWorks.ByteArray
@


1.4.1.1
log
@branched from 1.4
@
text
@d10 1
a10 4
 *  $Log: __c_function.sml,v $
 * Revision 1.4  1996/05/24  01:19:14  brianm
 * Beta release modifications.
 *
@


1.3
log
@initbasis becomes basis
@
text
@d5 3
d10 15
a24 3
 *  $Log: __c_function.sml,v $
 * Revision 1.2  1995/09/07  22:43:36  brianm
 * Modifications for reorganisation & documentation.
d26 8
a33 1
 *  Revision 1.1  1995/04/25  11:14:52  brianm
d41 1
d43 1
d46 7
a52 2
require "__c_codeinfo";
require "__c_codeset";
d55 9
d65 2
a66 4
require "__fi_aliens";
require "__fi_codeset";
require "__fi_data";
require "__fi_utils";
d68 8
a75 1
require "_c_function";
d77 1
a77 1
structure CFunction_ = CFunction(
a78 2
   structure StaticByteArray = StaticByteArray_
   structure Lists           = Lists_
d80 2
a81 2
   structure CCodeInfo      = CCodeInfo_
   structure CCodeSet         = CCodeSet_
d83 21
a103 4
   structure FIAliens        = ForeignAliens_
   structure FICodeSet        = ForeignCodeSet_
   structure FIData          = ForeignData_
   structure FIUtils         = ForeignUtils_
d105 191
a295 1
);
@


1.2
log
@Modifications for reorganisation & documentation.
@
text
@d8 3
d18 1
a18 1
require "../initbasis/__general";
@


1.1
log
@new unit
New file.
@
text
@d7 5
a11 1
 *  $Log$
d19 2
a20 2
require "__c_sig";
require "__c_struct";
d25 1
a25 1
require "__fi_struct";
d36 2
a37 2
   structure CSignature      = CSignature_
   structure CStruct         = CStruct_
d40 1
a40 1
   structure FIStruct        = ForeignStruct_
@
