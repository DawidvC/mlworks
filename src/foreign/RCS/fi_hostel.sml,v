head	1.5;
access;
symbols
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5;
locks; strict;
comment	@ * @;


1.5
date	96.03.28.13.51.45;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.09.07.22.43.44;	author brianm;	state Exp;
branches;
next	1.3;

1.3
date	95.06.21.15.09.41;	author brianm;	state Exp;
branches;
next	1.2;

1.2
date	95.05.04.19.35.35;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	95.04.25.11.45.36;	author brianm;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.5
log
@Sharing constraints
@
text
@(*  ==== FOREIGN INTERFACE : FOREIGN_HOSTEL ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *
 *  A _Hostel_ is an area of memory reserved for the purpose of
 *  reading/writing data from ML for use in foreign computations.  A
 *  hostel possesses a size (in 8-bit bytes) and can either be
 *  _Standard_ or _Managed_.  A Standard hostel generally remains
 *  fixed in size, and can only be expanded by an explicit call of
 *  function expand_hostel().  A Managed hostel, on the other hand,
 *  can be expanded automatically as needed - in principle, the memory
 *  used can be allocated as needed.
 *
 *  The use of hostels helps the user programmer to control the
 *  memory mgmt.  overhead when dealing with foreign data - although a
 *  Managed hostel is most convenient, a Standard hostel of a fixed
 *  size might be all that is actually required.
 *
 *  Also associated with a hostel is a status field - this is
 *  provided to help the user provide low-level support for avoiding
 *  inadvertent corruption of data.
 * 
 *  
 *    - If the status is Rd then only reading is permitted, but writing is not.
 *    - If the status is Wr then only writing is permitted but reading is not.
 *    - If the status is RdWr then both reading and writing are permitted.
 *
 *  In the presence of concurrency within ML, this form of locking
 *  would have to be additionally protected by an appropriate monitor
 *
 *  Revision Log
 *  ------------
 *  $Log: fi_hostel.sml,v $
 * Revision 1.4  1995/09/07  22:43:44  brianm
 * Modifications for reorganisation & documentation.
 *
 *  Revision 1.3  1995/06/21  15:09:41  brianm
 *  Adding remote access, diagnostics and other facilities.
 *
 *  Revision 1.2  1995/05/04  19:35:35  brianm
 *  Removing restrictive eqtype constraints & introduce abstypes in
 *  various implementing types.
 *
 *  Revision 1.1  1995/04/25  11:45:36  brianm
 *  new unit
 *  New file.
 *
# Revision 1.1  1995/03/27  15:47:52  brianm
# new unit
#
# New file.
#
 *
 *)

require "fi_types";

signature FOREIGN_HOSTEL =
   sig

     structure FITypes : FOREIGN_TYPES

     type bytearray = FITypes.bytearray
     type address = FITypes.address

     type hostel

     exception ReadOnly
     exception WriteOnly

     datatype hostel_status = LOCKED_HS | RD_HS | WR_HS | RDWR_HS 

     val hostel_status  : hostel -> hostel_status
     val set_hostel_status : (hostel * hostel_status) -> unit

     datatype alloc_policy = ORIGIN_AP | SUCC_AP | ALIGNED_4_AP | ALIGNED_8_AP

     datatype overflow_policy = BREAK_OV | EXTEND_OV | RECYCLE_OV

     val hostel : { alloc    : alloc_policy,
                    overflow : overflow_policy,
                    status   : hostel_status,
                    size     : int } -> hostel

     val hostel_size     : hostel -> int
     val hostel_origin   : hostel -> address
     val hostel_alloc    : hostel -> alloc_policy
     val hostel_overflow : hostel -> overflow_policy
     val hostel_content  : hostel -> bytearray

     exception ExpandHostel

     val is_standard_hostel  : hostel -> bool
     val is_ephemeral_hostel : hostel -> bool

     val expand          : (hostel * int) -> unit
     val expand_managed  : (hostel * int) -> unit

     val fresh_object_offset  : (hostel * int) -> int
     val adjust_hostel        : (hostel * int * int) -> unit


     (* Diagnostic tools *)

     val view_hostel : hostel -> string
     val disp_hostel : hostel -> hostel

     val hostel_info : hostel ->
	    { kind     : string,
              origin   : address,
	      status   : string,
	      alloc    : string,
	      overflow : string,
	      size     : int,
	      top      : int,
              free     : int }

     val hostel_data :
	 { hostel : hostel,
	   start  : int,
	   length : int } -> int list

     val hostel_data_hex :
	 { hostel : hostel,
	   start  : int,
	   length : int } -> string

     val hostel_data_ascii :
	 { hostel : hostel,
	   start  : int,
	   length : int } -> string

     val diff_addr : address -> address -> int
     val incr_addr : address * int -> address

   end;
@


1.4
log
@Modifications for reorganisation & documentation.
@
text
@d37 3
d66 2
a67 5
     type bytearray
     type address

       sharing type bytearray  = FITypes.bytearray
       sharing type address    = FITypes.address
@


1.3
log
@Adding remote access, diagnostics and other facilities.
@
text
@d37 3
d74 1
a74 1
     datatype hostel_status = LOCKED_H | RD_H | WR_H | RDWR_H 
d79 1
a79 1
     datatype alloc_policy = ORIGIN_AP | FLOAT_AP | ALIGNED_4_AP | ALIGNED_8_AP
d136 1
a136 1
     val conv_addr : address -> address -> int
@


1.2
log
@Removing restrictive eqtype constraints & introduce abstypes in
various implementing types.
@
text
@d37 4
d78 1
a78 3
     datatype overflow_policy = BREAK_OV       | EXTEND_OV
                              | EPHEM_BREAK_OV | EPHEM_EXTEND_OV
                              | EPHEM_RECYCLE_OV
d101 34
@


1.1
log
@new unit
New file.
@
text
@d36 5
a40 1
 *  $Log: fi_data.sml,v $
d62 1
a62 1
     eqtype hostel
@
