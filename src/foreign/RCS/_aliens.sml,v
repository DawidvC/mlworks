head	1.1;
access;
symbols
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ *  @;


1.1
date	96.05.19.11.46.37;	author brianm;	state Exp;
branches;
next	;


desc
@new unit
Renamed file.
@


1.1
log
@new unit
Renamed file.
@
text
@(*  ==== FOREIGN INTERFACE : ALIENS INTERFACE ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *
 *  Revision Log
 *  ------------
 *  $Log: _aliens.sml,v $
 * Revision 1.5  1996/04/18  16:56:20  jont
 * initbasis becomes basis
 *
 * Revision 1.4  1996/03/07  11:48:56  jont
 * Changing newmap to map, NEWMAP to MAP, T to map
 *
 * Revision 1.3  1995/09/07  22:43:40  brianm
 * Modifications for reorganisation & documentation.
 *
 *  Revision 1.2  1995/07/18  12:17:13  brianm
 *  Changing names of deferred data-type operators (stream-edit)
 *
 *  Revision 1.1  1995/04/25  11:33:35  brianm
 *  new unit
 *  New file.
 *
 *
 *)

require "../basis/__general";

require "../utils/stringlib";
require "../utils/map";
require "../utils/lists";

require "types";
require "core";
require "aliens";

functor ForeignAliens(

   structure StringLib : STRING_LIB
   structure Map       : MAP
   structure Lists     : LISTS
   structure FICore    : FOREIGN_CORE

     structure FITypes : FOREIGN_TYPES

) : FOREIGN_ALIENS =
   struct

      structure FITypes = FITypes
      open FITypes
      open General

   (* Mapping *)

      type ('a,'b)Map    = ('a,'b)Map.map

      type foreign_object = FICore.foreign_object
      type foreign_value  = FICore.foreign_value

      type info      = string

      val str_lt          = String.<

      exception Option    = General.Option
      val extract         = General.valOf
      val extract_default = fn (a) => fn (x) => General.getOpt(x,a)

      val iterate         = Lists.iterate

      val load_object       = fn s => FICore.load_object(s,FICore.LOAD_NOW)
      val find_value        = FICore.find_value
      val list_content      = FICore.list_content
      val call_foreign_fun  = FICore.call_foreign_fun

      val empty_map       = Map.empty'(str_lt) : (string,string)Map
      val from_list       = Map.from_list'(str_lt)

      val memstr          = StringLib.memstr
      val trim_left       = StringLib.trim_left
      val leading         = StringLib.leading
      val leading_split   = StringLib.leading_split


   (* Implementation auxiliaries *)

      val is_sp = memstr " "

      fun prefix s = leading(is_sp,s)

      fun prefix_split s =
          let val (sl,sr) = leading_split(is_sp,s)
          in
             (sl, trim_left(is_sp,sr))
          end

      fun make_info_map sl = from_list (map prefix_split sl)


   (* Definitions *)

      abstype foreign_module =
              FMODULE of
                 { filename   : string,
                   object     : ( foreign_object      )box,
                   item_names : ( (string)list        )box,
                   info_map   : ( (string, string)Map )box
                 }

      with

      (* Implementations : auxilliaries *)

         val FI_module_register = ref([] : foreign_module list)

         fun fetch_module(f_mod as
                          FMODULE{filename,object,item_names,info_map}) =
             let val f_obj = load_object(filename)
             in
                 setBox object f_obj;
                 resetBox(item_names);   (* Reset these `cached' values *)
                 resetBox(info_map);     (* Reset these `cached' values *)
                 f_mod
             end

         fun extract_foreign_object(FMODULE{object, ...}) = getBox(object)

      (* Exported Definitions *)

         fun ensure_module(f_mod as FMODULE{object, ...}) =
             case extractBox(object) of
               NONE    => fetch_module(f_mod)
             |
               SOME(_) => f_mod

         fun reset_module(f_mod as
                          FMODULE{filename,object,item_names,info_map}) =
             (
               resetBox(object);
               resetBox(item_names);
               resetBox(info_map);
               f_mod
             )

         fun get_module_later(str) =
             let val f_mod =
                     FMODULE { filename   = str,
                               object     = voidBox(),
                               item_names = voidBox(),
                               info_map   = voidBox()
                             }
             in
                 FI_module_register := f_mod :: !FI_module_register;
                 f_mod
             end

         fun get_module_now(str) =
             let val f_mod = get_module_later(str)
             in
                 ensure_module(f_mod)
             end;
             

         fun get_item_names(FMODULE{item_names, object, ...}) =
             case extractBox(item_names) of
               NONE =>
                 (
                    case extractBox(object) of
                       NONE        => []
                    |
                       SOME(f_obj) =>
                          let val names = map prefix (list_content(f_obj))
                          in
                            (
                             setBox item_names names;
                             names
                            )
                          end
                 )
             |
               SOME(names) => names

         fun get_item_info(FMODULE{info_map, object, ...}) =
             case extractBox(info_map) of
               NONE =>
                 (
                    case extractBox(object) of
                      NONE        => empty_map
                    |
                      SOME(f_obj) =>
                         let val info = make_info_map (list_content(f_obj))
                         in
                           setBox (info_map) (info);
                           info
                         end
                 )
             |
               SOME(info) => info
      end


      abstype foreign_item =
              FITEM of
                 { name    : string,
                   value   : ( foreign_value  )box,
                   module  : ( foreign_module )box
                 }
      with

      (* Implementation auxiliaries *)

         val FI_item_register = ref([] : foreign_item list)

         local
             fun fetch_item'(f_item as FITEM{name,value,module}) =
                 let val f_mod = getBox(module)
                     val f_obj = extract_foreign_object(f_mod)
                     val f_val = find_value(f_obj,name)
                 in
                     setBox(value)(f_val);
                     f_item
                 end

             fun fetch_item''(f_item as FITEM{name,value,module}) =
                 let val f_mod = ensure_module(getBox(module))
                     val f_obj = extract_foreign_object(f_mod)
                     val f_val = find_value(f_obj,name)
                 in
                     setBox(module)(f_mod);
                     setBox(value)(f_val);
                     f_item
                 end
         in
             fun fetch_item(f_item) =
                 case f_item of
                    FITEM{module=(ref(SOME(_))), value=(ref(NONE)), ...} =>
                      fetch_item'(f_item)
                 |   
                    FITEM{module=(ref(NONE)), ...} =>
                      fetch_item''(f_item)
                 |
                   _ => f_item
         end

         fun extract_foreign_value(FITEM{value, ...}) = getBox(value)


      (* Exported Definitions *) 

         fun ensure_item(f_item as FITEM{name,value,module}) =
             case extractBox(value) of
               NONE    => fetch_item(f_item)
             |
               SOME(_) => f_item

         fun reset_item(f_item as FITEM{value, ...}) =
             (
 	       resetBox(value);
               (* Note that the module component isn't reset - this would
                  make the item useless (since it could not be reestablished)
                *)
               f_item
             )

         fun get_item_later(f_mod, name) =
             let val f_item =
                     FITEM { name   = name,
                             value  = voidBox(),
                             module = makeBox(f_mod)
                           }
             in
                 FI_item_register := f_item :: !FI_item_register;
                 f_item
             end

         fun get_item_now(f_mod, name) =
             let val f_item = get_item_later(f_mod, name)
             in
                 ensure_item(f_item)
             end
         end



      fun ensure_alien_modules () =
          iterate ensure_module (!FI_module_register)

      fun ensure_alien_items () =
          iterate ensure_item (!FI_item_register)

      fun ensure_aliens () =
          (
             ensure_alien_modules();
             ensure_alien_items()
          )


      fun refresh_module (f_mod) =
          let val f_mod' = reset_module(f_mod)
          in
              ensure_module(f_mod')
          end


      fun refresh_item (f_item) =
          let val f_item' = reset_item(f_item)
          in
              ensure_item(f_item')
          end

      fun refresh_alien_modules () =
          iterate refresh_module (!FI_module_register)

      fun refresh_alien_items () =
          iterate refresh_item (!FI_item_register)

      fun refresh_aliens () =
          (
             refresh_alien_modules();
             refresh_alien_items()
          )


      fun reset_alien_modules () =
          iterate reset_module (!FI_module_register)

      fun reset_alien_items () =
          iterate reset_item (!FI_item_register)

      fun reset_aliens () =
          (
             reset_alien_modules();
             reset_alien_items()
          )


   (* FOREIGN FUNCTION CALLING *)

      fun call_alien_code(item,args,arity,res) =
          let val ffun = extract_foreign_value(ensure_item(item))
          in
              call_foreign_fun(ffun,args,arity,res)
          end
   end;
@
