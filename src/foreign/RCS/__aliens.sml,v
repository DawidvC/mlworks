head	1.4;
access;
symbols
	MLW_daveb_inline_1_4_99:1.4.8
	MLWorks_21c0_1999_03_25:1.4
	MLWorks_20c1_1998_08_20:1.4
	MLWorks_20c0_1998_08_04:1.4
	MLWorks_20b2c2_1998_06_19:1.4
	MLWorks_20b2_Windows_1998_06_12:1.4
	MLWorks_20b1c1_1998_05_07:1.4
	MLWorks_20b0_1998_04_07:1.4
	MLWorks_20b0_1998_03_20:1.4
	MLWorks_20m2_1998_02_16:1.4
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_workspace_97:1.4.7
	MLWorks_dt_wizard:1.4.6
	MLWorks_10r3:1.4.5.1.3
	MLWorks_10r2_551:1.4.5.1.2
	MLWorks_11:1.4.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.4.5.1
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.4.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.4.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.4.5
	MLWorks_BugFix_1997_04_24:1.4
	MLWorks_1_0_r2_Win32_1997_04_11:1.4
	MLWorks_1_0_r2_Unix_1997_04_04:1.4
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.3.1.1
	MLWorks_gui_1996_12_18:1.4.4
	MLWorks_1_0_Win32_1996_12_17:1.4.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.4.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.4.1.1
	MLWorks_1_0_Irix_1996_11_28:1.4.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.2
	MLWorks_1_0_Unix_1996_11_14:1.4.1
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ *  @;


1.4
date	96.11.02.15.10.13;	author daveb;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1
	1.4.4.1
	1.4.5.1
	1.4.6.1
	1.4.7.1
	1.4.8.1;
next	1.3;

1.3
date	96.10.25.13.39.13;	author io;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.13.50.12;	author brianm;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	96.05.19.11.46.35;	author brianm;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.12.28;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.16.03.10;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.21.26;	author hope;	state Exp;
branches;
next	;

1.4.1.1
date	96.11.14.12.45.12;	author hope;	state Exp;
branches
	1.4.1.1.1.1;
next	;

1.4.1.1.1.1
date	96.11.28.14.57.07;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.11.22.18.05.43;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.12.17.17.44.30;	author hope;	state Exp;
branches
	1.4.3.1.1.1;
next	;

1.4.3.1.1.1
date	97.02.24.11.33.54;	author hope;	state Exp;
branches;
next	;

1.4.4.1
date	96.12.18.09.38.29;	author hope;	state Exp;
branches;
next	;

1.4.5.1
date	97.05.12.10.30.47;	author hope;	state Exp;
branches
	1.4.5.1.1.1
	1.4.5.1.2.1
	1.4.5.1.3.1;
next	;

1.4.5.1.1.1
date	97.07.28.18.16.08;	author daveb;	state Exp;
branches;
next	;

1.4.5.1.2.1
date	97.09.08.17.09.43;	author daveb;	state Exp;
branches;
next	;

1.4.5.1.3.1
date	97.09.09.14.05.07;	author daveb;	state Exp;
branches;
next	;

1.4.6.1
date	97.09.10.19.19.25;	author brucem;	state Exp;
branches;
next	;

1.4.7.1
date	97.09.11.20.50.37;	author daveb;	state Exp;
branches;
next	;

1.4.8.1
date	99.04.01.17.54.17;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Renamed file.
@


1.4
log
@Replaced use of utils/__stringlib.
@
text
@(*  ==== FOREIGN INTERFACE : ALIENS INTERFACE ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *
 *  Revision Log
 *  ------------
 *  $Log: __aliens.sml,v $
 *  Revision 1.3  1996/10/25  13:39:13  io
 *  [Bug #1547]
 *  updating for current naming conventions
 *
 *  Revision 1.2  1996/05/22  13:50:12  brianm
 *  Beta release modifications.
 *
 *  Revision 1.1  1996/05/19  11:46:37  brianm
 *  new unit
 *  Renamed file.
 *
 * Revision 1.5  1996/04/18  16:56:20  jont
 * initbasis becomes basis
 *
 * Revision 1.4  1996/03/07  11:48:56  jont
 * Changing newmap to map, NEWMAP to MAP, T to map
 *
 * Revision 1.3  1995/09/07  22:43:40  brianm
 * Modifications for reorganisation & documentation.
 *
 *  Revision 1.2  1995/07/18  12:17:13  brianm
 *  Changing names of deferred data-type operators (stream-edit)
 *
 *  Revision 1.1  1995/04/25  11:33:35  brianm
 *  new unit
 *  New file.
 *
 *
 *)

require "../utils/map";
require "../utils/lists";
require "types";
require "core";
require "utils";

require "../basis/__substring";
require "../utils/__btree";
require "../utils/__lists";
require "__types";
require "__core";
require "__utils";

require "aliens";

structure ForeignAliens_ : FOREIGN_ALIENS =
   struct

      structure Map       : MAP            = BTree_
      structure Lists = Lists_
      structure FICore    : FOREIGN_CORE   = ForeignCore_
      structure FIUtils   : FOREIGN_UTILS  = ForeignUtils_
      structure FITypes   : FOREIGN_TYPES  = ForeignTypes_

      open FITypes
      open FIUtils

   (* Mapping *)

      type ('a,'b)Map     = ('a,'b)Map.map

      type foreign_object = FICore.foreign_object
      type foreign_value  = FICore.foreign_value

      type info           = string

      val load_object       = fn s => FICore.load_object(s,FICore.LOAD_NOW)
      val find_value        = FICore.find_value
      val list_content      = FICore.list_content
      val call_foreign_fun  = FICore.call_foreign_fun

      val empty_map       = Map.empty'((op<):string*string->bool) : (string,string) Map
      val from_list       = Map.from_list'((op<):string*string->bool)

   (* Implementation auxiliaries *)

      fun is_sp c = c = #" "

      fun prefix s =
        Substring.string (Substring.takel (not o is_sp) (Substring.all s))

      fun prefix_split s =
        let val (x, y) = (Substring.splitl (not o is_sp) (Substring.all s))
        in 
          (Substring.string x, Substring.string (Substring.dropl is_sp y))
        end

      fun make_info_map sl = from_list (map prefix_split sl)


   (* Definitions *)

      abstype foreign_module =
              FMODULE of
                 { filename   : string,
                   object     : ( foreign_object      )box,
                   item_names : ( (string)list        )box,
                   info_map   : ( (string, string)Map )box
                 }

      with

      (* Implementations : auxilliaries *)

         val FI_module_register = ref([] : foreign_module list)

         fun fetch_module(f_mod as
                          FMODULE{filename,object,item_names,info_map}) =
             let val f_obj = load_object(filename)
             in
                 setBox object f_obj;
                 resetBox(item_names);   (* Reset these `cached' values *)
                 resetBox(info_map);     (* Reset these `cached' values *)
                 f_mod
             end

         fun extract_foreign_object(FMODULE{object, ...}) = getBox(object)

      (* Exported Definitions *)

         fun ensure_module(f_mod as FMODULE{object, ...}) =
             case extractBox(object) of
               NONE    => fetch_module(f_mod)
             |
               SOME(_) => f_mod

         fun reset_module(f_mod as
                          FMODULE{filename,object,item_names,info_map}) =
             (
               resetBox(object);
               resetBox(item_names);
               resetBox(info_map);
               f_mod
             )

         fun get_module_later(str) =
             let val f_mod =
                     FMODULE { filename   = str,
                               object     = voidBox(),
                               item_names = voidBox(),
                               info_map   = voidBox()
                             }
             in
                 FI_module_register := f_mod :: !FI_module_register;
                 f_mod
             end

         fun get_module_now(str) =
             let val f_mod = get_module_later(str)
             in
                 ensure_module(f_mod)
             end;
             

         fun get_item_names(FMODULE{item_names, object, ...}) =
             case extractBox(item_names) of
               NONE =>
                 (
                    case extractBox(object) of
                       NONE        => []
                    |
                       SOME(f_obj) =>
                          let val names = map prefix (list_content(f_obj))
                          in
                            (
                             setBox item_names names;
                             names
                            )
                          end
                 )
             |
               SOME(names) => names

         fun get_item_info(FMODULE{info_map, object, ...}) =
             case extractBox(info_map) of
               NONE =>
                 (
                    case extractBox(object) of
                      NONE        => empty_map
                    |
                      SOME(f_obj) =>
                         let val info = make_info_map (list_content(f_obj))
                         in
                           setBox (info_map) (info);
                           info
                         end
                 )
             |
               SOME(info) => info
      end


      abstype foreign_item =
              FITEM of
                 { name    : string,
                   value   : ( foreign_value  )box,
                   module  : ( foreign_module )box
                 }
      with

      (* Implementation auxiliaries *)

         val FI_item_register = ref([] : foreign_item list)

         local
             fun fetch_item'(f_item as FITEM{name,value,module}) =
                 let val f_mod = getBox(module)
                     val f_obj = extract_foreign_object(f_mod)
                     val f_val = find_value(f_obj,name)
                 in
                     setBox(value)(f_val);
                     f_item
                 end

             fun fetch_item''(f_item as FITEM{name,value,module}) =
                 let val f_mod = ensure_module(getBox(module))
                     val f_obj = extract_foreign_object(f_mod)
                     val f_val = find_value(f_obj,name)
                 in
                     setBox(module)(f_mod);
                     setBox(value)(f_val);
                     f_item
                 end
         in
             fun fetch_item(f_item) =
                 case f_item of
                    FITEM{module=(ref(SOME(_))), value=(ref(NONE)), ...} =>
                      fetch_item'(f_item)
                 |   
                    FITEM{module=(ref(NONE)), ...} =>
                      fetch_item''(f_item)
                 |
                   _ => f_item
         end

         fun extract_foreign_value(FITEM{value, ...}) = getBox(value)


      (* Exported Definitions *) 

         fun ensure_item(f_item as FITEM{name,value,module}) =
             case extractBox(value) of
               NONE    => fetch_item(f_item)
             |
               SOME(_) => f_item

         fun reset_item(f_item as FITEM{value, ...}) =
             (
 	       resetBox(value);
               (* Note that the module component isn't reset - this would
                  make the item useless (since it could not be reestablished)
                *)
               f_item
             )

         fun get_item_later(f_mod, name) =
             let val f_item =
                     FITEM { name   = name,
                             value  = voidBox(),
                             module = makeBox(f_mod)
                           }
             in
                 FI_item_register := f_item :: !FI_item_register;
                 f_item
             end

         fun get_item_now(f_mod, name) =
             let val f_item = get_item_later(f_mod, name)
             in
                 ensure_item(f_item)
             end
         end



      fun ensure_alien_modules () =
	Lists.iterate ensure_module (!FI_module_register)

      fun ensure_alien_items () =
	Lists.iterate ensure_item (!FI_item_register)

      fun ensureAliens () =
          (
             ensure_alien_modules();
             ensure_alien_items()
          )


      fun refresh_module (f_mod) =
          let val f_mod' = reset_module(f_mod)
          in
              ensure_module(f_mod')
          end


      fun refresh_item (f_item) =
          let val f_item' = reset_item(f_item)
          in
              ensure_item(f_item')
          end

      fun refresh_alien_modules () =
	Lists.iterate refresh_module (!FI_module_register)

      fun refresh_alien_items () =
	Lists.iterate refresh_item (!FI_item_register)

      fun refreshAliens () =
          (
             refresh_alien_modules();
             refresh_alien_items()
          )


      fun reset_alien_modules () =
	Lists.iterate reset_module (!FI_module_register)

      fun reset_alien_items () =
	Lists.iterate reset_item (!FI_item_register)

      fun resetAliens () =
          (
             reset_alien_modules();
             reset_alien_items()
          )


   (* FOREIGN FUNCTION CALLING *)

      fun call_alien_code(item,args,arity,res) =
          let val ffun = extract_foreign_value(ensure_item(item))
          in
              call_foreign_fun(ffun,args,arity,res)
          end
   end;
@


1.4.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 3
 *  Revision 1.4  1996/11/02  15:10:13  daveb
 *  Replaced use of utils/__stringlib.
 *
@


1.4.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 3
 *  Revision 1.4  1996/11/02  15:10:13  daveb
 *  Replaced use of utils/__stringlib.
 *
@


1.4.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 3
 *  Revision 1.4  1996/11/02  15:10:13  daveb
 *  Replaced use of utils/__stringlib.
 *
@


1.4.5.1
log
@branched from 1.4
@
text
@a10 3
 *  Revision 1.4  1996/11/02  15:10:13  daveb
 *  Replaced use of utils/__stringlib.
 *
@


1.4.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
 *  Revision 1.4.5.1  1997/05/12  10:30:47  hope
 *  branched from 1.4
 *
@


1.4.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
 *  Revision 1.4.5.1  1997/05/12  10:30:47  hope
 *  branched from 1.4
 *
@


1.4.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
 *  Revision 1.4.5.1  1997/05/12  10:30:47  hope
 *  branched from 1.4
 *
@


1.4.4.1
log
@branched from 1.4
@
text
@a10 3
 *  Revision 1.4  1996/11/02  15:10:13  daveb
 *  Replaced use of utils/__stringlib.
 *
@


1.4.3.1
log
@branched from 1.4
@
text
@a10 3
 *  Revision 1.4  1996/11/02  15:10:13  daveb
 *  Replaced use of utils/__stringlib.
 *
@


1.4.3.1.1.1
log
@branched from 1.4.3.1
@
text
@a10 3
 *  Revision 1.4.3.1  1996/12/17  17:44:30  hope
 *  branched from 1.4
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a10 3
 *  Revision 1.4  1996/11/02  15:10:13  daveb
 *  Replaced use of utils/__stringlib.
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a10 3
 *  Revision 1.4  1996/11/02  15:10:13  daveb
 *  Replaced use of utils/__stringlib.
 *
@


1.4.1.1.1.1
log
@branched from 1.4.1.1
@
text
@a10 3
 *  Revision 1.4.1.1  1996/11/14  12:45:12  hope
 *  branched from 1.4
 *
@


1.3
log
@[Bug #1547]
updating for current naming conventions
@
text
@d11 4
a40 1
require "../utils/stringlib";
d47 1
a47 1
require "../utils/__stringlib";
a58 1
      structure StringLib : STRING_LIB     = StringLib_
a84 4
      val trim_left       = StringLib.trim_left
      val leading         = StringLib.leading
      val leading_split   = StringLib.leading_split

d87 1
a87 2
      val is_sp = fn i=> (chr i) = #" "
	  
d89 2
a90 1
      fun prefix s = leading(is_sp,s)
d93 4
a96 4
          let val (sl,sr) = leading_split(is_sp,s)
          in
             (sl, trim_left(is_sp,sr))
          end
@


1.2
log
@Beta release modifications.
@
text
@d10 4
a13 1
 *  $Log: _aliens.sml,v $
a36 2
require "../basis/__general";

d58 1
a58 1
      structure Lists     : LISTS          = Lists_
a64 1
      open General
a74 8
      val str_lt          = String.<

      exception Option    = General.Option
      val extract         = General.valOf
      val extract_default = fn (a) => fn (x) => General.getOpt(x,a)

      val iterate         = Lists.iterate

d80 2
a81 2
      val empty_map       = Map.empty'(str_lt) : (string,string)Map
      val from_list       = Map.from_list'(str_lt)
a82 1
      val memstr          = StringLib.memstr
d89 2
a90 1
      val is_sp = memstr " "
d289 1
a289 1
          iterate ensure_module (!FI_module_register)
d292 1
a292 1
          iterate ensure_item (!FI_item_register)
d294 1
a294 1
      fun ensure_aliens () =
d315 1
a315 1
          iterate refresh_module (!FI_module_register)
d318 1
a318 1
          iterate refresh_item (!FI_item_register)
d320 1
a320 1
      fun refresh_aliens () =
d328 1
a328 1
          iterate reset_module (!FI_module_register)
d331 1
a331 1
          iterate reset_item (!FI_item_register)
d333 1
a333 1
      fun reset_aliens () =
@


1.2.3.1
log
@branched from 1.2
@
text
@d10 1
a10 4
 *  $Log: __aliens.sml,v $
 *  Revision 1.2  1996/05/22  13:50:12  brianm
 *  Beta release modifications.
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@d10 1
a10 4
 *  $Log: __aliens.sml,v $
 *  Revision 1.2  1996/05/22  13:50:12  brianm
 *  Beta release modifications.
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@d10 1
a10 4
 *  $Log: __aliens.sml,v $
 *  Revision 1.2  1996/05/22  13:50:12  brianm
 *  Beta release modifications.
 *
@


1.1
log
@new unit
Renamed file.
@
text
@d10 20
a29 4
 *  $Log: __aliens.sml,v $
 * Revision 1.1  1995/04/25  11:21:20  brianm
 * new unit
 * New file.
d34 8
a45 1

d48 292
a339 1
require "_aliens";
d341 5
a346 1
structure ForeignAliens_ = ForeignAliens(
d348 1
a348 5
   structure StringLib  =  StringLib_
   structure Map        =  BTree_
   structure Lists      =  Lists_
   structure FICore     =  ForeignCore_
     structure FITypes = ForeignTypes_
d350 6
a355 1
);
@
