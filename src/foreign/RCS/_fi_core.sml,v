head	1.3;
access;
symbols
	MLWorks_Beta_1996_06_07:1.3
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.3
	MLWorks_Beta_1996_05_31:1.3
	MLWorks_Beta_1996_05_30:1.3;
locks; strict;
comment	@ * @;


1.3
date	96.03.20.15.06.16;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.05.03.19.28.49;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	95.03.27.15.31.12;	author brianm;	state Exp;
branches;
next	;


desc
@new unit
Core Foreign interface (was _foreign_interface.sml).
@


1.3
log
@Language revision
@
text
@(*  ==== FOREIGN INTERFACE : CORE INTERFACE ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  The implementation uses Word values of appropriate size to
 *  represent addresses and memory pointers.  The interface is
 *  provided via the libdl conformant C library provided by the
 *  underlying OS (see rts/foreign_loader.h and
 *  also rts/OS/*/arch/*/foreign_loader.c).
 *
 *  Revision Log
 *  ------------
 *  $Log: _fi_core.sml,v $
 * Revision 1.2  1995/05/03  19:28:49  brianm
 * Updated due to changes of low-level libdl interface.
 * Changed construction of list_content - string list is now
 * built inside ML not C (for GC safety).
 * Also added a load_mode flag to load_object ...
 *
# Revision 1.1  1995/03/27  15:31:12  brianm
# new unit
# Core Foreign interface (was _foreign_interface.sml).
#
 *  Revision 1.3  1995/03/24  15:31:14  brianm
 *  Updated to use Word32.word values (instead of int * int) to
 *  encode addresses.
 * 
 *  Revision 1.2  1995/03/08  14:22:13  brianm
 *  Minor corrections.
 * 
 *  Revision 1.1  1995/03/01  11:02:10  brianm
 *  new unit
 *  Foreign Interface functor body.
 * 
 *
 *)

require "fi_core";
require "fi_types";

functor ForeignCore(
     structure FITypes : FOREIGN_TYPES
) : FOREIGN_CORE =
  struct

    structure FITypes = FITypes
    open FITypes

  (* Mapping *)

    val MLWcast         = MLWorks.Internal.Value.cast
    val MLWenvironment  = MLWorks.Internal.Runtime.environment

    val env = MLWenvironment


  (* Implementation auxiliaries *)

    exception Unavailable   

    local

       val open_symtab_file  : string -> bool  =  env "open symtab file";
       val next_symtab_entry : unit -> string  =  env "next symtab entry";
       val close_symtab_file : unit -> unit    =  env "close symtab file";

    in

       fun get_item_list(sofar) =
           let val next = next_symtab_entry()
           in
             if next = "" then sofar
                          else get_item_list(next :: sofar)
           end

       fun get_symtab(file) =
           let val check = open_symtab_file(file)
           in
               if check
               then let val content = get_item_list([])
                    in
                      close_symtab_file();
                      content
                    end
               else raise Unavailable
           end
    end


  (* Exported definitions *)

    datatype load_mode = LOAD_LATER | LOAD_NOW

    abstype foreign_object = FOBJ of (string * (string list) * address)
    with
        val load_foreign_object : (string * load_mode) -> address
            =  env "load foreign object"

        fun load_object(s:string,lm:load_mode) =
            let val mem    = load_foreign_object(s,lm)
                val symtab = get_symtab(s)
            in
                FOBJ(s,symtab,mem)
            end

        fun list_content (FOBJ(_,obj_lst,_)) = obj_lst;  
    end

    abstype foreign_value  = FVAL of word32
    with

       val find_value  : (foreign_object * string) -> foreign_value
           =  env "lookup foreign value"
  
       val call_unit_fun : foreign_value -> unit
           =  env "call unit function"

       val call_foreign_fun : (foreign_value * address * int * address) -> unit 
           =  env "call foreign function"

    end

  end;
@


1.2
log
@Updated due to changes of low-level libdl interface.
Changed construction of list_content - string list is now
built inside ML not C (for GC safety).
Also added a load_mode flag to load_object ...
@
text
@d16 6
d53 2
a54 2
    val MLWcast         = MLWorks.Internal.Value.cast (fn x => x) : 'a -> 'b;
    val MLWenvironment  = MLWorks.Internal.Runtime.environment;
d56 1
a56 1
    fun env s = MLWcast(MLWenvironment s);
@


1.1
log
@new unit
Core Foreign interface (was _foreign_interface.sml).
@
text
@d15 5
a19 1
 *  $Log$
d35 1
a35 1
require "../initbasis/__word32";
d37 7
d45 1
a45 2
functor ForeignCore() : FOREIGN_CORE =
  struct
d52 39
a90 1
    abstype foreign_object = FObj of (string * (string list) * int)
d92 2
a93 3
        val load_object = env "load foreign object";
        fun list_content (FObj(_,obj_lst,_)) = obj_lst;  
    end;
d95 11
a105 1
    abstype foreign_value  = FVal of Word32.word
d107 9
a115 18
        val find_value        =  env "lookup foreign value";
        val call_unit_fun     =  env "call unit function";
        val call_foreign_fun  =  env "call foreign function";
    end;

    type memory = Word32.word;
      
    val load_object : string -> foreign_object
      = load_object;
      
    val find_value   : (foreign_object * string) -> foreign_value
      = find_value;

    val list_content :  foreign_object -> string list
      = list_content
      
    val call_unit_fun : foreign_value -> unit
      = call_unit_fun;
d117 1
a117 2
    val call_foreign_fun : (foreign_object * memory * int * memory) -> unit 
      = call_foreign_fun;  (* unimplemented *)
@
