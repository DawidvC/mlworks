head	1.14;
access;
symbols
	MLW_daveb_inline_1_4_99:1.14.8
	MLWorks_21c0_1999_03_25:1.14
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.14
	MLWorks_20b2_Windows_1998_06_12:1.14
	MLWorks_20b1c1_1998_05_07:1.14
	MLWorks_20b0_1998_04_07:1.14
	MLWorks_20b0_1998_03_20:1.14
	MLWorks_20m2_1998_02_16:1.14
	MLWorks_20m1_1997_10_23:1.14
	MLWorks_11r1:1.14.5.1.1.1.1
	MLWorks_workspace_97:1.14.7
	MLWorks_dt_wizard:1.14.6
	MLWorks_11c0_1997_09_09:1.14.5.1.1.1
	MLWorks_10r3:1.14.5.1.3
	MLWorks_10r2_551:1.14.5.1.2
	MLWorks_11:1.14.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.14.5.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.14.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.14.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.14.5
	MLWorks_BugFix_1997_04_24:1.14
	MLWorks_1_0_r2_Win32_1997_04_11:1.14
	MLWorks_1_0_r2_Unix_1997_04_04:1.14
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.14.3.1.1
	MLWorks_gui_1996_12_18:1.14.4
	MLWorks_1_0_Win32_1996_12_17:1.14.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.14.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.14.1.1
	MLWorks_1_0_Irix_1996_11_28:1.14.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.14.2
	MLWorks_1_0_Unix_1996_11_14:1.14.1
	MLWorks_Open_Beta2_1996_10_11:1.12.3
	MLWorks_License_dev:1.12.2
	MLWorks_1_open_beta_1996_09_13:1.12.1
	MLWorks_Open_Beta_1996_08_22:1.12
	MLWorks_Beta_1996_07_02:1.10
	MLWorks_Beta_1996_06_07:1.10
	MLWorks_Beta_1996_06_06:1.10
	MLWorks_Beta_1996_06_05:1.10
	MLWorks_Beta_1996_06_03:1.10
	MLWorks_Beta_1996_05_31:1.10
	MLWorks_Beta_1996_05_30:1.10;
locks; strict;
comment	@ * @;


1.14
date	96.10.25.14.10.43;	author io;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1
	1.14.4.1
	1.14.5.1
	1.14.6.1
	1.14.7.1
	1.14.8.1;
next	1.13;

1.13
date	96.10.18.12.23.22;	author brianm;	state Exp;
branches;
next	1.12;

1.12
date	96.08.20.15.05.44;	author brianm;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1;
next	1.11;

1.11
date	96.08.20.10.46.53;	author brianm;	state Exp;
branches;
next	1.10;

1.10
date	96.05.24.01.19.19;	author brianm;	state Exp;
branches;
next	1.9;

1.9
date	95.09.07.22.43.46;	author brianm;	state Exp;
branches;
next	1.8;

1.8
date	95.07.14.14.08.02;	author brianm;	state Exp;
branches;
next	1.7;

1.7
date	95.06.26.12.20.59;	author brianm;	state Exp;
branches;
next	1.6;

1.6
date	95.06.26.10.33.15;	author brianm;	state Exp;
branches;
next	1.5;

1.5
date	95.05.29.18.31.54;	author brianm;	state Exp;
branches;
next	1.4;

1.4
date	95.05.09.14.26.19;	author brianm;	state Exp;
branches;
next	1.3;

1.3
date	95.05.04.19.52.06;	author brianm;	state Exp;
branches;
next	1.2;

1.2
date	95.05.03.19.34.18;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	95.03.13.13.38.06;	author brianm;	state Exp;
branches;
next	;

1.12.1.1
date	96.09.13.11.11.56;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.10.07.16.02.39;	author hope;	state Exp;
branches;
next	;

1.12.3.1
date	96.10.17.11.20.54;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	96.11.14.12.44.38;	author hope;	state Exp;
branches
	1.14.1.1.1.1;
next	;

1.14.1.1.1.1
date	96.11.28.14.56.35;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.11.22.18.05.02;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.12.17.17.43.58;	author hope;	state Exp;
branches
	1.14.3.1.1.1;
next	;

1.14.3.1.1.1
date	97.02.24.11.33.17;	author hope;	state Exp;
branches;
next	;

1.14.4.1
date	96.12.18.09.37.56;	author hope;	state Exp;
branches;
next	;

1.14.5.1
date	97.05.12.10.30.14;	author hope;	state Exp;
branches
	1.14.5.1.1.1
	1.14.5.1.2.1
	1.14.5.1.3.1;
next	;

1.14.5.1.1.1
date	97.07.28.18.16.40;	author daveb;	state Exp;
branches
	1.14.5.1.1.1.1.1;
next	;

1.14.5.1.1.1.1.1
date	97.10.07.11.41.32;	author jkbrook;	state Exp;
branches;
next	;

1.14.5.1.2.1
date	97.09.08.17.10.15;	author daveb;	state Exp;
branches;
next	;

1.14.5.1.3.1
date	97.09.09.14.05.45;	author daveb;	state Exp;
branches;
next	;

1.14.6.1
date	97.09.10.19.20.10;	author brucem;	state Exp;
branches;
next	;

1.14.7.1
date	97.09.11.20.51.23;	author daveb;	state Exp;
branches;
next	;

1.14.8.1
date	99.04.01.17.55.05;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
No reason given
@


1.14
log
@naming conventions
@
text
@(* test script for foreign interface *)



(* *)

use "open";



   (* TEST 1 - C Interface *)

    val my_store =
         store{ alloc    = SUCC,
                 overflow = EXTEND,
                 size     = 1000,
                 status   = RDWR_STATUS   };

    val my_store_a4 =
         store{ alloc    = ALIGNED_4,
                 overflow = BREAK,
                 size     = 80,
                 status   = RDWR_STATUS   };

   (*  TEST 1.1 - Building C structures *)

   val f_name = "foreign/tst.so";
  
   val my_struct = loadObjectFile(f_name,IMMEDIATE_LOAD);

   filesLoaded();
   fileInfo my_struct;
   symbols my_struct;
   symbolInfo(my_struct,"hw");



   (* TEST 1.2 - Building C OBJECT's *)

   val my_object =
         object { ctype     = VOID_TYPE,
               store    = my_store };
   
   val my_object1 = dupObject(my_object);

   val int_object1 =
         object { ctype     = INT_TYPE,
               store    = my_store };

   setInt(int_object1, 3);
   
   val int_object2 =
         object { ctype     = INT_TYPE,
               store    = my_store };

   setInt(int_object2, 5);
   getInt(int_object1);
   getInt(int_object2);

   val my_sig = newSignature();


(* *)


   (* TEST 1.3 - Building C Signatures *)

   defEntry(my_sig, FUN_DECL { name = "hw",
                               source = [] : c_type list,
                               target = VOID_TYPE });
   
  
   defEntry(my_sig, VAR_DECL { name  = "my_value",
	 		      ctype = INT_TYPE});
   
   showEntries(my_sig);
   
   val lookup_my_sig =  lookupEntry my_sig;


   (* TEST 1.4 - Extracting C function objects & calling them *)

   val hw = defineForeignFun(my_struct,my_sig)("hw");

   call(hw)([],my_object);


   (* TEST 1.5 - Returning a result *)

   defEntry(my_sig, FUN_DECL { name = "hw1",
			      source = [] : c_type list,
			      target = INT_TYPE});
   
   showEntries my_sig;

   val hw1 = defineForeignFun(my_struct,my_sig)("hw1");

   call(hw1)([],int_object1);

   getInt(int_object1);


   (* TEST 1.6 - Argument passing and returning results *)

   defEntry(my_sig, FUN_DECL { name = "hw2",
                               source = [INT_TYPE] : c_type list,
                               target = INT_TYPE });
   
   showEntries(my_sig);

   val hw2 = defineForeignFun(my_struct,my_sig)("hw2");

   setInt(int_object1,4);

   call(hw2)([int_object1],int_object2);

   getInt(int_object2);


   (* TEST 1.7 - Argument passing and returning results *)

   defEntry(my_sig, FUN_DECL { name = "hw2",
                               source = [INT_TYPE] : c_type list,
                               target = INT_TYPE });
   
   showEntries(my_sig);

   val hw2 = defineForeignFun(my_struct,my_sig)("hw2");

   setInt(int_object1,4);

   call(hw2)([int_object1],int_object2);

   getInt(int_object2);


   (* TEST 1.8 - Creating C-string object's *)

   val str_object1 =
         object { ctype     = STRING_TYPE{ length = 64 },
               store    = my_store };

   setString(str_object1,"Hello World");
   getString(str_object1);
   
   val str_object1_1 = dupObject(str_object1);
   castObjectType(str_object1_1, ARRAY_TYPE{ ctype = CHAR_TYPE, length = 64, size = NONE });

   val char_object1 =
         object { ctype     = CHAR_TYPE,
               store    = my_store };

   indexObject{array=str_object1_1,tgt=char_object1,index=0};
   getChar(char_object1);

   indexObject{array=str_object1_1,tgt=char_object1,index=1};
   getChar(char_object1);

   val str_object2 =
         object { ctype     = STRING_TYPE{ length = 64 },
               store    = my_store };

   setString(str_object2,"");
	 

   (* TEST 1.9 - Argument passing and returning results *)

   defEntry(my_sig, FUN_DECL { name = "hw3",
                               source = [INT_TYPE] : c_type list,
                               target = STRING_TYPE{ length = 64 } });
   
   showEntries(my_sig);

   val hw3 = defineForeignFun(my_struct,my_sig)("hw3");

   setInt(int_object1,24);

   call(hw3)([int_object1],str_object2);

   getString(str_object2);



   (* TEST 1.10 - loading other code ... *)
 

   val libc = loadObjectFile("/lib/libc.so.1",IMMEDIATE_LOAD)
              handle _ => loadObjectFile("/usr/lib/libc.so",IMMEDIATE_LOAD)
              handle _ => loadObjectFile("/usr/lib/libc.so.1.8",IMMEDIATE_LOAD)
              handle _ => loadObjectFile("/usr/lib/libc.so.1.8.1",IMMEDIATE_LOAD);
       
   symbols(libc);

   val libxm = loadObjectFile("/usr/lib/libXm.so.2.12",IMMEDIATE_LOAD)
               handle _ => loadObjectFile("/usr/lib/libXm.so.2.11",IMMEDIATE_LOAD)
               handle _ => loadObjectFile("/usr/lib/libXm.so.1.2",IMMEDIATE_LOAD);

   symbols(libxm);


   (* TEST 1.11 - Argument passing and returning results *)

   defEntry(my_sig, FUN_DECL { name = "hw4",
                               source = [STRING_TYPE{ length = 64 }],
                               target = INT_TYPE
                             }
            );
   
   showEntries(my_sig);

   val hw4 = defineForeignFun(my_struct,my_sig)("hw4");

   setString(str_object1,"Hope springs Eternal"); 

   call(hw4)([str_object1],int_object1);

   getInt(int_object1);


   (* TEST 1.12 - Structures and foreign data maniputlation *)


   val Tnorm = normaliseType my_sig

   val my_type =
       Tnorm  (structType("my_type",
                          [  ("num",  INT_TYPE),
                             ("ch",   CHAR_TYPE),
                             ("iptr", ptrType(INT_TYPE))
                          ]
		         ));

   defEntry(my_sig, TYPE_DECL { name = "my_type",
                               defn = my_type,
                               size = sizeOf(my_type) }
	    );

   val void_object_a4_1 = object { ctype = VOID_TYPE, store = my_store_a4 };

   val struct_object_a4_1 =
         object { ctype    = my_type,
                  store    = my_store_a4 };

   val ch_object_a4_1 =
         object { ctype    = CHAR_TYPE,
                  store    = my_store_a4 };

   val int_object_a4_1 =
         object { ctype     = INT_TYPE,
                  store    = my_store_a4 };

   val int_object_a4_2 =
     object { ctype     = INT_TYPE,
	      store    = my_store_a4 };


   val tmp_object_a4_1 = tmpObject void_object_a4_1;

   dispObject void_object_a4_1;
   dispObject struct_object_a4_1;
     
   selectObject{ record=struct_object_a4_1, field="num",  tgt=tmp_object_a4_1};
   setInt(tmp_object_a4_1,45);

   dispObject tmp_object_a4_1;

   selectObject{ record=struct_object_a4_1, field="ch",   tgt=tmp_object_a4_1};
   setChar(tmp_object_a4_1,81);

   dispObject tmp_object_a4_1;

   selectObject{ record=struct_object_a4_1, field="iptr", tgt=tmp_object_a4_1};

   dispObject tmp_object_a4_1;

   setPtrAddrOf{ ptr=tmp_object_a4_1, data=int_object_a4_1 };

   dispObject tmp_object_a4_1;

   setInt(int_object_a4_1,2020);

   dispObject tmp_object_a4_1;

   setPtrType{ ptr=tmp_object_a4_1, data=struct_object_a4_1};
   setPtrAddrOf{ ptr=tmp_object_a4_1, data=struct_object_a4_1};

   dispObject tmp_object_a4_1;

   dispObject struct_object_a4_1;

   defEntry(my_sig, FUN_DECL { name = "hw5",
                               source = [ptrType(my_type)],
                               target = INT_TYPE
                             }
            );
   
   showEntries(my_sig);

   val hw5 = defineForeignFun(my_struct,my_sig)("hw5");

   call(hw5)([tmp_object_a4_1],int_object_a4_2);

   getInt(int_object_a4_2);


   (* TEST 1.13 - Structures and foreign data maniputlation *)

   
   defEntry(my_sig, FUN_DECL { name = "hw6",
                               source = [],
                               target = UNSIGNED_INT_TYPE
                             }
            );
   
   showEntries(my_sig);

   val uint_object_a4_1 = object{ ctype = UNSIGNED_INT_TYPE, store = my_store_a4 };

   val hw6 = defineForeignFun(my_struct,my_sig)("hw6");

   call(hw6)([],uint_object_a4_1);

   getWord32(uint_object_a4_1);

   setObjectMode(int_object_a4_1,REMOTE_OBJECT);
   
   setAddr{obj=int_object_a4_1,addr=uint_object_a4_1};

   getInt(int_object_a4_1);


   (*  Loading X libraries *)

   val libX11 = loadObjectFile("/usr/lib/libX11.so.5.0",IMMEDIATE_LOAD);
   val libXt  = loadObjectFile("/usr/lib/libXt.so.5.0",IMMEDIATE_LOAD);
   val libXm  = loadObjectFile("/usr/lib/libXm.so",IMMEDIATE_LOAD);


   (*  TEST 2.1 - Building C structures *)

   val x_store =
          store{ alloc    = SUCC,
                 overflow = EXTEND,
                 size     = 1000,
                 status   = RDWR_STATUS   };

   val x_name = "foreign/xtst.so";
  
   val x_struct = loadObjectFile(x_name,IMMEDIATE_LOAD);

   symbols(x_struct);
   symbolInfo(x_struct,"demo_box");


   (* TEST 2.2 - Building C OBJECT's *)

   val x_object =
         object { ctype     = STRING_TYPE{ length = 64 },
               store    = x_store };
   
   val x_object1 = dupObject(x_object);


   val void_object =
         object { ctype     = VOID_TYPE,
                  store     = x_store };


   (* TEST 2.3 - Building C Signatures *)

   val x_sig = newSignature();

   defEntry(x_sig,
             FUN_DECL 
               { name = "demo_box",
                 source = [STRING_TYPE{ length = 64 }],
                 target = VOID_TYPE });
   
   val demo_box = defineForeignFun(x_struct,x_sig)("demo_box");

   setString(x_object1,"Hope springs Eternal"); 

   call(demo_box)([x_object1],void_object);



   (* Test of pointer equality functions *)

     setString (str_object1, "Hi There!");
     setString (str_object2, "FooBar");
     
     val str_ptr1 =
         object { ctype     = ptrType (STRING_TYPE {length=30}), 
                  store     = my_store };

     val str_ptr2 =
         object { ctype     = ptrType (STRING_TYPE {length=30}),
                  store     = my_store };
     
     (true = isEqPtr (str_ptr1, str_ptr2));

     setPtrAddrOf {ptr=str_ptr2, data=str_object2};
     
     (false = isEqPtr (str_ptr1, str_ptr2));

     getString (str_object1);
     getString (str_object2);

     objectType (str_ptr1);
     objectType (str_ptr2);
     
     (true =  (isNullPtr str_ptr1));
     (false = (isNullPtr str_ptr2));

     fun string_to_char_ptr {string=str, ptr=char_ptr} =
         case objectType (str) of
            STRING_TYPE (_) =>
              ( setPtrAddrOf { ptr=char_ptr, data=str } ;
                castPtrType   { ptr=char_ptr, ctype=CHAR_TYPE }
              )
         |  _ => raise ForeignType

     fun char_ptr_to_string {ptr=char_ptr, string=str} =
         let val str_type =  objectType (str)
         in
	     case str_type of
                STRING_TYPE (_) =>
                  ( castPtrType { ptr=char_ptr, ctype=str_type } ;
   	            derefObject  { ptr=char_ptr, tgt=str }
                  )
             |  _ => raise ForeignType
         end;
	 

   objectType (str_ptr1);

   string_to_char_ptr { string=str_object1, ptr=str_ptr1};

   objectType (str_ptr1);

   getString (str_object1);

   char_ptr_to_string { string=str_object2, ptr=str_ptr1 };

   getString (str_object2);
   
(* DEPRECATED TESTS:

   (* TEST 0 - Basic Core *)

   open ForeignCore_;


   (*
   val fpath = "foreign/tst.so";
   val fpath = "foreign/nickb.so";
   *)

   val fpath = "foreign/tst.so";

   val fobj = load_object (fpath,LOAD_LATER);

   val obj_lst = list_content fobj;

   val hw = find_value (fobj, "hw");

   val my_value = find_value (fobj, "my_value");

   call_unit_fun hw;
*)
	 
@


1.14.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@@


1.14.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.14.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@@


1.14.5.1
log
@branched from 1.14
@
text
@@


1.14.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.14.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.14.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.14.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.14.4.1
log
@branched from 1.14
@
text
@@


1.14.3.1
log
@branched from 1.14
@
text
@@


1.14.3.1.1.1
log
@branched from 1.14.3.1
@
text
@@


1.14.2.1
log
@branched from 1.14
@
text
@@


1.14.1.1
log
@branched from 1.14
@
text
@@


1.14.1.1.1.1
log
@branched from 1.14.1.1
@
text
@@


1.13
log
@Fixing problems with normalise_type & size of chars ...
@
text
@d29 1
a29 1
   val my_struct = load_object_file(f_name,IMMEDIATE_LOAD);
d31 4
a34 4
   files_loaded();
   file_info(my_struct);
   symbols(my_struct);
   symbol_info(my_struct,"hw");
d44 1
a44 1
   val my_object1 = dup_object(my_object);
d50 1
a50 1
   set_int(int_object1, 3);
d56 3
a58 3
   set_int(int_object2, 5);
   get_int(int_object1);
   get_int(int_object2);
d60 1
a60 1
   val my_sig = new_signature();
d68 1
a68 1
   def_entry(my_sig, FUN_DECL { name = "hw",
d73 2
a74 2
   def_entry(my_sig, VAR_DECL { name  = "my_value",
	 		      ctype = INT_TYPE });
d76 1
a76 1
   show_entries(my_sig);
d78 1
a78 1
   val lookup_my_sig =  lookup_entry(my_sig);
d83 1
a83 1
   val hw = define_foreign_fun(my_struct,my_sig)("hw");
d90 3
a92 3
   def_entry(my_sig, FUN_DECL { name = "hw1",
                               source = [] : c_type list,
                               target = INT_TYPE });
d94 1
a94 1
   show_entries(my_sig);
d96 1
a96 1
   val hw1 = define_foreign_fun(my_struct,my_sig)("hw1");
d100 1
a100 1
   get_int(int_object1);
d105 1
a105 1
   def_entry(my_sig, FUN_DECL { name = "hw2",
d109 1
a109 1
   show_entries(my_sig);
d111 1
a111 1
   val hw2 = define_foreign_fun(my_struct,my_sig)("hw2");
d113 1
a113 1
   set_int(int_object1,4);
d117 1
a117 1
   get_int(int_object2);
d122 1
a122 1
   def_entry(my_sig, FUN_DECL { name = "hw2",
d126 1
a126 1
   show_entries(my_sig);
d128 1
a128 1
   val hw2 = define_foreign_fun(my_struct,my_sig)("hw2");
d130 1
a130 1
   set_int(int_object1,4);
d134 1
a134 1
   get_int(int_object2);
d143 2
a144 2
   set_string(str_object1,"Hello World");
   get_string(str_object1);
d146 2
a147 2
   val str_object1_1 = dup_object(str_object1);
   cast_object_type(str_object1_1, ARRAY_TYPE{ ctype = CHAR_TYPE, length = 64, size = NONE });
d153 2
a154 2
   index_object{array=str_object1_1,tgt=char_object1,index=0};
   get_char(char_object1);
d156 2
a157 2
   index_object{array=str_object1_1,tgt=char_object1,index=1};
   get_char(char_object1);
d163 1
a163 1
   set_string(str_object2,"");
d168 1
a168 1
   def_entry(my_sig, FUN_DECL { name = "hw3",
d172 1
a172 1
   show_entries(my_sig);
d174 1
a174 1
   val hw3 = define_foreign_fun(my_struct,my_sig)("hw3");
d176 1
a176 1
   set_int(int_object1,24);
d180 1
a180 1
   get_string(str_object2);
a181 1
	 
d187 4
a190 4
   val libc = load_object_file("/lib/libc.so.1",IMMEDIATE_LOAD)
              handle _ => load_object_file("/usr/lib/libc.so",IMMEDIATE_LOAD)
              handle _ => load_object_file("/usr/lib/libc.so.1.8",IMMEDIATE_LOAD)
              handle _ => load_object_file("/usr/lib/libc.so.1.8.1",IMMEDIATE_LOAD);
d194 3
a196 3
   val libxm = load_object_file("/usr/lib/libXm.so.2.12",IMMEDIATE_LOAD)
               handle _ => load_object_file("/usr/lib/libXm.so.2.11",IMMEDIATE_LOAD)
               handle _ => load_object_file("/usr/lib/libXm.so.1.2",IMMEDIATE_LOAD);
d203 1
a203 1
   def_entry(my_sig, FUN_DECL { name = "hw4",
d209 1
a209 1
   show_entries(my_sig);
d211 1
a211 1
   val hw4 = define_foreign_fun(my_struct,my_sig)("hw4");
d213 1
a213 1
   set_string(str_object1,"Hope springs Eternal"); 
d217 1
a217 1
   get_int(int_object1);
d223 1
a223 1
   val Tnorm = normalise_type my_sig
d233 1
a233 1
   def_entry(my_sig, TYPE_DECL { name = "my_type",
d235 1
a235 1
                               size = size_of(my_type) }
d253 2
a254 2
         object { ctype     = INT_TYPE,
                  store    = my_store_a4 };
a255 1
   val tmp_object_a4_1 = tmp_object( void_object_a4_1 );
d257 1
d259 5
a263 5
disp_object ( void_object_a4_1 );
disp_object ( struct_object_a4_1 );
	 
   select_object{ record=struct_object_a4_1, field="num",  tgt=tmp_object_a4_1};
   set_int(tmp_object_a4_1,45);
d265 1
a265 1
   disp_object tmp_object_a4_1;
d267 2
a268 2
   select_object{ record=struct_object_a4_1, field="ch",   tgt=tmp_object_a4_1};
   set_char(tmp_object_a4_1,81);
d270 1
a270 1
   disp_object tmp_object_a4_1;
d272 1
a272 1
   select_object{ record=struct_object_a4_1, field="iptr", tgt=tmp_object_a4_1};
d274 1
a274 1
   disp_object tmp_object_a4_1;
d276 1
a276 1
   set_ptr_addr_of{ ptr=tmp_object_a4_1, data=int_object_a4_1 };
d278 1
a278 1
   disp_object tmp_object_a4_1;
d280 1
a280 1
   set_int(int_object_a4_1,2020);
d282 1
a282 1
   disp_object tmp_object_a4_1;
d284 2
a285 2
   set_ptr_type{ ptr=tmp_object_a4_1, data=struct_object_a4_1};
   set_ptr_addr_of{ ptr=tmp_object_a4_1, data=struct_object_a4_1};
d287 1
a287 1
   disp_object tmp_object_a4_1;
d289 1
a289 1
   disp_object struct_object_a4_1;
d291 1
a291 1
   def_entry(my_sig, FUN_DECL { name = "hw5",
d297 1
a297 1
   show_entries(my_sig);
d299 1
a299 1
   val hw5 = define_foreign_fun(my_struct,my_sig)("hw5");
d303 1
a303 2
   get_int(int_object_a4_2);

d309 1
a309 1
   def_entry(my_sig, FUN_DECL { name = "hw6",
d315 1
a315 1
   show_entries(my_sig);
d319 1
a319 1
   val hw6 = define_foreign_fun(my_struct,my_sig)("hw6");
d323 1
a323 1
   get_word32(uint_object_a4_1);
d325 1
a325 1
   set_object_mode(int_object_a4_1,REMOTE_OBJECT);
d327 1
a327 1
   set_addr{obj=int_object_a4_1,addr=uint_object_a4_1};
d329 1
a329 1
   get_int(int_object_a4_1);
d334 3
a336 4
   val libX11 = load_object_file("/usr/lib/libX11.so.5.0",IMMEDIATE_LOAD);
   val libXt  = load_object_file("/usr/lib/libXt.so.5.0",IMMEDIATE_LOAD);
   val libXm  = load_object_file("/usr/lib/libXm.so",IMMEDIATE_LOAD);

d349 1
a349 1
   val x_struct = load_object_file(x_name,IMMEDIATE_LOAD);
d352 1
a352 1
   symbol_info(x_struct,"demo_box");
d361 1
a361 1
   val x_object1 = dup_object(x_object);
d371 1
a371 1
   val x_sig = new_signature();
d373 1
a373 1
   def_entry(x_sig,
d379 1
a379 1
   val demo_box = define_foreign_fun(x_struct,x_sig)("demo_box");
d381 1
a381 1
   set_string(x_object1,"Hope springs Eternal"); 
d389 2
a390 2
     set_string (str_object1, "Hi There!");
     set_string (str_object2, "FooBar");
d400 1
a400 1
     (true = is_eq_ptr (str_ptr1, str_ptr2));
d402 1
a402 1
     set_ptr_addr_of {ptr=str_ptr2, data=str_object2};
d404 1
a404 1
     (false = is_eq_ptr (str_ptr1, str_ptr2));
d406 2
a407 2
     get_string (str_object1);
     get_string (str_object2);
d409 2
a410 2
     object_type (str_ptr1);
     object_type (str_ptr2);
d412 2
a413 2
     (true =  (is_null_ptr str_ptr1));
     (false = (is_null_ptr str_ptr2));
d416 1
a416 1
         case object_type (str) of
d418 2
a419 2
              ( set_ptr_addr_of { ptr=char_ptr, data=str } ;
                cast_ptr_type   { ptr=char_ptr, ctype=CHAR_TYPE }
d424 1
a424 1
         let val str_type =  object_type (str)
d428 2
a429 2
                  ( cast_ptr_type { ptr=char_ptr, ctype=str_type } ;
   	            deref_object  { ptr=char_ptr, tgt=str }
d435 1
a435 1
   object_type (str_ptr1);
d439 1
a439 1
   object_type (str_ptr1);
d441 1
a441 1
   get_string (str_object1);
d445 1
a445 1
   get_string (str_object2);
d455 2
a456 2
   val fpath = "./tst.so";
   val fpath = "./nickb.so";
d459 1
a459 1
   val fpath = "./tst.so";
@


1.12
log
@More tests - for string/char types etc.
@
text
@d223 3
d227 6
a232 6
       structType("my_type",
                   [  ("num",  INT_TYPE),
                      ("ch",   CHAR_TYPE),
                      ("iptr", ptrType(INT_TYPE))
                   ]
		  );
d260 3
a262 2
(* *)     

d338 1
a338 1
   val libXm  = load_object_file("/usr/lib/libXm.so.1.2",IMMEDIATE_LOAD);
d350 1
a350 1
   val x_name = "./xtst.so";
@


1.12.3.1
log
@branched from 1.12
@
text
@@


1.12.2.1
log
@branched from 1.12
@
text
@@


1.12.1.1
log
@branched from 1.12
@
text
@@


1.11
log
@Adding some tests for new code ...
@
text
@a10 2


d65 1
d385 1
a412 1
     
d414 32
@


1.10
log
@Beta release modifications.
@
text
@d4 1
d10 2
a11 1
(*
d29 1
a29 1
   val f_name = "./tst.so";
d64 1
a64 1
	 
d70 2
a71 2
                               source = makeBox([] : c_type list),
                               target = makeBox(VOID_TYPE) });
d75 1
a75 1
	 		      ctype = voidBox() });
d92 2
a93 2
                               source = makeBox([] : c_type list),
                               target = makeBox(INT_TYPE) });
d107 2
a108 2
                               source = makeBox([INT_TYPE] : c_type list),
                               target = makeBox(INT_TYPE) });
d124 2
a125 2
                               source = makeBox([INT_TYPE] : c_type list),
                               target = makeBox(INT_TYPE) });
d148 1
a148 1
   cast_object_type(str_object1_1, ARRAY_TYPE{ ctype = CHAR_TYPE, length = 64 });
a166 1

d170 2
a171 2
                               source = makeBox([INT_TYPE] : c_type list),
                               target = makeBox(STRING_TYPE{ length = 64 }) });
d206 2
a207 2
                               source = makeBox([STRING_TYPE{ length = 64 }]),
                               target = makeBox(INT_TYPE)
a221 1

d233 2
a234 2
                               defn = makeBox(my_type),
                               size = voidBox() }
d240 2
a241 2
         object { ctype     = my_type,
               store    = my_store_a4 };
d244 2
a245 2
         object { ctype     = CHAR_TYPE,
               store    = my_store_a4 };
d249 1
a249 1
               store    = my_store_a4 };
d253 1
a253 1
               store    = my_store_a4 };
d259 1
d290 2
a291 2
                               source = makeBox([ptrType(my_type)]),
                               target = makeBox(INT_TYPE)
d309 2
a310 2
                               source = makeBox([]),
                               target = makeBox(UNSIGNED_INT_TYPE)
a329 1
*)
d337 2
d342 1
a342 1
         store{ alloc    = SUCC,
a354 1

d366 1
a366 1
               store    = x_store };
d376 2
a377 2
                 source = makeBox([STRING_TYPE{ length = 64 }]),
                 target = makeBox(VOID_TYPE) });
d386 1
d388 26
d439 1
@


1.9
log
@Modifications for reorganisation & documentation.
@
text
@d13 3
a15 3
    val my_hostel =
         hostel{ alloc    = SUCC_AP,
                 overflow = EXTEND_OV,
d17 1
a17 1
                 status   = RDWR_HS   };
d19 3
a21 3
    val my_hostel_a4 =
         hostel{ alloc    = ALIGNED_4_AP,
                 overflow = BREAK_OV,
d23 1
a23 1
                 status   = RDWR_HS   };
d29 1
a29 1
   val my_struct = load_codeset(f_name,IMMEDIATE_LM);
d38 1
a38 1
   (* TEST 1.2 - Building C POD's *)
d40 3
a42 3
   val my_pod =
         pod { ctype     = VOID_CT,
               hostel    = my_hostel };
d44 1
a44 1
   val my_pod1 = dup_pod(my_pod);
d46 3
a48 3
   val int_pod1 =
         pod { ctype     = INT_CT,
               hostel    = my_hostel };
d50 1
a50 1
   set_int(int_pod1, 3);
d52 3
a54 3
   val int_pod2 =
         pod { ctype     = INT_CT,
               hostel    = my_hostel };
d56 3
a58 3
   set_int(int_pod2, 5);
   get_int(int_pod1);
   get_int(int_pod2);
d60 1
a60 1
   val my_sig = new_codeinfo();
d65 1
a65 1
   (* TEST 1.3 - Building C CodeInfos *)
d67 3
a69 3
   def_entry(my_sig, CODE_DI { name = "hw",
                               source = makeBOX([] : c_type list),
                               target = makeBOX(VOID_CT) });
d72 2
a73 2
   def_entry(my_sig, VAR_DI { name  = "my_value",
	 		      ctype = voidBOX() });
d82 1
a82 1
   val hw = attach(my_struct,my_sig)("hw");
d84 1
a84 1
   call(hw)([],my_pod);
d89 3
a91 3
   def_entry(my_sig, CODE_DI { name = "hw1",
                               source = makeBOX([] : c_type list),
                               target = makeBOX(INT_CT) });
d95 1
a95 1
   val hw1 = attach(my_struct,my_sig)("hw1");
d97 1
a97 1
   call(hw1)([],int_pod1);
d99 1
a99 1
   get_int(int_pod1);
d104 3
a106 3
   def_entry(my_sig, CODE_DI { name = "hw2",
                               source = makeBOX([INT_CT] : c_type list),
                               target = makeBOX(INT_CT) });
d110 1
a110 1
   val hw2 = attach(my_struct,my_sig)("hw2");
d112 1
a112 1
   set_int(int_pod1,4);
d114 1
a114 1
   call(hw2)([int_pod1],int_pod2);
d116 1
a116 1
   get_int(int_pod2);
d121 3
a123 3
   def_entry(my_sig, CODE_DI { name = "hw2",
                               source = makeBOX([INT_CT] : c_type list),
                               target = makeBOX(INT_CT) });
d127 1
a127 1
   val hw2 = attach(my_struct,my_sig)("hw2");
d129 1
a129 1
   set_int(int_pod1,4);
d131 1
a131 1
   call(hw2)([int_pod1],int_pod2);
d133 1
a133 1
   get_int(int_pod2);
d136 1
a136 1
   (* TEST 1.8 - Creating C-string pod's *)
d138 3
a140 3
   val str_pod1 =
         pod { ctype     = STRING_CT{ length = 64 },
               hostel    = my_hostel };
d142 2
a143 2
   set_string(str_pod1,"Hello World");
   get_string(str_pod1);
d145 2
a146 2
   val str_pod1_1 = dup_pod(str_pod1);
   cast_pod_type(str_pod1_1, ARRAY_CT{ ctype = CHAR_CT, length = 64 });
d148 3
a150 3
   val char_pod1 =
         pod { ctype     = CHAR_CT,
               hostel    = my_hostel };
d152 2
a153 2
   index_pod{array=str_pod1_1,tgt=char_pod1,index=0};
   get_char(char_pod1);
d155 2
a156 2
   index_pod{array=str_pod1_1,tgt=char_pod1,index=1};
   get_char(char_pod1);
d158 3
a160 3
   val str_pod2 =
         pod { ctype     = STRING_CT{ length = 64 },
               hostel    = my_hostel };
d162 1
a162 1
   set_string(str_pod2,"");
d168 3
a170 3
   def_entry(my_sig, CODE_DI { name = "hw3",
                               source = makeBOX([INT_CT] : c_type list),
                               target = makeBOX(STRING_CT{ length = 64 }) });
d174 1
a174 1
   val hw3 = attach(my_struct,my_sig)("hw3");
d176 1
a176 1
   set_int(int_pod1,24);
d178 1
a178 1
   call(hw3)([int_pod1],str_pod2);
d180 1
a180 1
   get_string(str_pod2);
d188 4
a191 4
   val libc = load_codeset("/lib/libc.so.1",IMMEDIATE_LM)
              handle _ => load_codeset("/usr/lib/libc.so",IMMEDIATE_LM)
              handle _ => load_codeset("/usr/lib/libc.so.1.8",IMMEDIATE_LM)
              handle _ => load_codeset("/usr/lib/libc.so.1.8.1",IMMEDIATE_LM);
d195 3
a197 3
   val libxm = load_codeset("/usr/lib/libXm.so.2.12",IMMEDIATE_LM)
               handle _ => load_codeset("/usr/lib/libXm.so.2.11",IMMEDIATE_LM)
               handle _ => load_codeset("/usr/lib/libXm.so.1.2",IMMEDIATE_LM);
d204 3
a206 3
   def_entry(my_sig, CODE_DI { name = "hw4",
                               source = makeBOX([STRING_CT{ length = 64 }]),
                               target = makeBOX(INT_CT)
d212 1
a212 1
   val hw4 = attach(my_struct,my_sig)("hw4");
d214 1
a214 1
   set_string(str_pod1,"Hope springs Eternal"); 
d216 1
a216 1
   call(hw4)([str_pod1],int_pod1);
d218 1
a218 1
   get_int(int_pod1);
d222 1
a222 1
   (* TEST 1.12 - CodeSets and foreign data maniputlation *)
d225 4
a228 4
       mk_struct_t("my_type",
                   [  ("num",  INT_CT),
                      ("ch",   CHAR_CT),
                      ("iptr", mk_star_t(INT_CT))
d232 3
a234 3
   def_entry(my_sig, TYPE_DI { name = "my_type",
                               defn = makeBOX(my_type),
                               size = voidBOX() }
d237 1
a237 1
   val void_pod_a4_1 = pod { ctype = VOID_CT, hostel = my_hostel_a4 };
d239 3
a241 3
   val struct_pod_a4_1 =
         pod { ctype     = my_type,
               hostel    = my_hostel_a4 };
d243 3
a245 3
   val ch_pod_a4_1 =
         pod { ctype     = CHAR_CT,
               hostel    = my_hostel_a4 };
d247 3
a249 3
   val int_pod_a4_1 =
         pod { ctype     = INT_CT,
               hostel    = my_hostel_a4 };
d251 3
a253 3
   val int_pod_a4_2 =
         pod { ctype     = INT_CT,
               hostel    = my_hostel_a4 };
d255 1
a255 1
   val tmp_pod_a4_1 = tmp_pod( void_pod_a4_1 );
d259 2
a260 2
   select_pod{ record=struct_pod_a4_1, field="num",  tgt=tmp_pod_a4_1};
   set_int(tmp_pod_a4_1,45);
d262 1
a262 1
   disp_pod tmp_pod_a4_1;
d264 2
a265 2
   select_pod{ record=struct_pod_a4_1, field="ch",   tgt=tmp_pod_a4_1};
   set_char(tmp_pod_a4_1,81);
d267 1
a267 1
   disp_pod tmp_pod_a4_1;
d269 1
a269 1
   select_pod{ record=struct_pod_a4_1, field="iptr", tgt=tmp_pod_a4_1};
d271 1
a271 1
   disp_pod tmp_pod_a4_1;
d273 1
a273 1
   set_ptr_addr_of{ ptr=tmp_pod_a4_1, data=int_pod_a4_1 };
d275 1
a275 1
   disp_pod tmp_pod_a4_1;
d277 1
a277 1
   set_int(int_pod_a4_1,2020);
d279 1
a279 1
   disp_pod tmp_pod_a4_1;
d281 2
a282 2
   set_ptr_type{ ptr=tmp_pod_a4_1, data=struct_pod_a4_1};
   set_ptr_addr_of{ ptr=tmp_pod_a4_1, data=struct_pod_a4_1};
d284 1
a284 1
   disp_pod tmp_pod_a4_1;
d286 1
a286 1
   disp_pod struct_pod_a4_1;
d288 3
a290 3
   def_entry(my_sig, CODE_DI { name = "hw5",
                               source = makeBOX([mk_star_t(my_type)]),
                               target = makeBOX(INT_CT)
d296 1
a296 1
   val hw5 = attach(my_struct,my_sig)("hw5");
d298 1
a298 1
   call(hw5)([tmp_pod_a4_1],int_pod_a4_2);
d300 1
a300 1
   get_int(int_pod_a4_2);
d304 1
a304 1
   (* TEST 1.13 - CodeSets and foreign data maniputlation *)
d307 3
a309 3
   def_entry(my_sig, CODE_DI { name = "hw6",
                               source = makeBOX([]),
                               target = makeBOX(UNSIGNED_INT_CT)
d315 1
a315 1
   val uint_pod_a4_1 = pod{ ctype = UNSIGNED_INT_CT, hostel = my_hostel_a4 };
d317 1
a317 1
   val hw6 = attach(my_struct,my_sig)("hw6");
d319 1
a319 1
   call(hw6)([],uint_pod_a4_1);
d321 1
a321 1
   get_word32(uint_pod_a4_1);
d323 1
a323 1
   set_pod_mode(int_pod_a4_1,REMOTE_PM);
d325 1
a325 1
   set_addr{obj=int_pod_a4_1,addr=uint_pod_a4_1};
d327 1
a327 1
   get_int(int_pod_a4_1);
d333 3
a335 3
   val libX11 = load_codeset("/usr/lib/libX11.so.5.0",IMMEDIATE_LM);
   val libXt  = load_codeset("/usr/lib/libXt.so.5.0",IMMEDIATE_LM);
   val libXm  = load_codeset("/usr/lib/libXm.so.1.2",IMMEDIATE_LM);
d339 3
a341 3
   val x_hostel =
         hostel{ alloc    = SUCC_AP,
                 overflow = EXTEND_OV,
d343 1
a343 1
                 status   = RDWR_HS   };
d347 1
a347 1
   val x_struct = load_codeset(x_name,IMMEDIATE_LM);
d354 1
a354 1
   (* TEST 2.2 - Building C POD's *)
d356 3
a358 3
   val x_pod =
         pod { ctype     = STRING_CT{ length = 64 },
               hostel    = x_hostel };
d360 1
a360 1
   val x_pod1 = dup_pod(x_pod);
d363 3
a365 3
   val void_pod =
         pod { ctype     = VOID_CT,
               hostel    = x_hostel };
d368 1
a368 1
   (* TEST 2.3 - Building C CodeInfos *)
d370 1
a370 1
   val x_sig = new_codeinfo();
d373 1
a373 1
             CODE_DI 
d375 2
a376 2
                 source = makeBOX([STRING_CT{ length = 64 }]),
                 target = makeBOX(VOID_CT) });
d378 1
a378 1
   val demo_box = attach(x_struct,x_sig)("demo_box");
d380 1
a380 1
   set_string(x_pod1,"Hope springs Eternal"); 
d382 1
a382 1
   call(demo_box)([x_pod1],void_pod);
@


1.8
log
@Modifications for adding X windows tests.
@
text
@d14 1
a14 1
         hostel{ alloc    = FLOAT_AP,
d17 1
a17 1
                 status   = RDWR_H   };
d23 1
a23 1
                 status   = RDWR_H   };
d29 1
a29 1
   val my_struct = load_structure(f_name,IMMEADIATE_LM);
d41 1
a41 1
         pod { ctype     = VOID_T,
d47 1
a47 1
         pod { ctype     = INT_T,
d53 1
a53 1
         pod { ctype     = INT_T,
d60 1
a60 1
   val my_sig = new_sig();
d65 1
a65 1
   (* TEST 1.3 - Building C Signatures *)
d67 3
a69 3
   def_entry(my_sig, CODE_SE { name = "hw",
                               source = makeDF([] : c_type list),
                               target = makeDF(VOID_T) });
d72 2
a73 2
   def_entry(my_sig, VAR_SE { name  = "my_value",
	 		      ctype = voidDF() });
d89 3
a91 3
   def_entry(my_sig, CODE_SE { name = "hw1",
                               source = makeDF([] : c_type list),
                               target = makeDF(INT_T) });
d104 3
a106 3
   def_entry(my_sig, CODE_SE { name = "hw2",
                               source = makeDF([INT_T] : c_type list),
                               target = makeDF(INT_T) });
d121 3
a123 3
   def_entry(my_sig, CODE_SE { name = "hw2",
                               source = makeDF([INT_T] : c_type list),
                               target = makeDF(INT_T) });
d139 1
a139 1
         pod { ctype     = STRING_T{ length = 64 },
d146 1
a146 1
   cast_pod_type(str_pod1_1, ARRAY_T{ ctype = CHAR_T, length = 64 });
d149 1
a149 1
         pod { ctype     = CHAR_T,
d159 1
a159 1
         pod { ctype     = STRING_T{ length = 64 },
d168 3
a170 3
   def_entry(my_sig, CODE_SE { name = "hw3",
                               source = makeDF([INT_T] : c_type list),
                               target = makeDF(STRING_T{ length = 64 }) });
d188 4
a191 4
   val libc = load_structure("/lib/libc.so.1",IMMEADIATE_LM)
              handle _ => load_structure("/usr/lib/libc.so",IMMEADIATE_LM)
              handle _ => load_structure("/usr/lib/libc.so.1.8",IMMEADIATE_LM)
              handle _ => load_structure("/usr/lib/libc.so.1.8.1",IMMEADIATE_LM);
d195 3
a197 3
   val libxm = load_structure("/usr/lib/libXm.so.2.12",IMMEADIATE_LM)
               handle _ => load_structure("/usr/lib/libXm.so.2.11",IMMEADIATE_LM)
               handle _ => load_structure("/usr/lib/libXm.so.1.2",IMMEADIATE_LM);
d204 3
a206 3
   def_entry(my_sig, CODE_SE { name = "hw4",
                               source = makeDF([STRING_T{ length = 64 }]),
                               target = makeDF(INT_T)
d222 1
a222 1
   (* TEST 1.12 - Structures and foreign data maniputlation *)
d226 3
a228 3
                   [  ("num",  INT_T),
                      ("ch",   CHAR_T),
                      ("iptr", mk_star_t(INT_T))
d232 3
a234 3
   def_entry(my_sig, TYPE_SE { name = "my_type",
                               defn = makeDF(my_type),
                               size = voidDF() }
d237 1
a237 1
   val void_pod_a4_1 = pod { ctype = VOID_T, hostel = my_hostel_a4 };
d244 1
a244 1
         pod { ctype     = CHAR_T,
d248 1
a248 1
         pod { ctype     = INT_T,
d252 1
a252 1
         pod { ctype     = INT_T,
d288 3
a290 3
   def_entry(my_sig, CODE_SE { name = "hw5",
                               source = makeDF([mk_star_t(my_type)]),
                               target = makeDF(INT_T)
d304 1
a304 1
   (* TEST 1.13 - Structures and foreign data maniputlation *)
d307 3
a309 3
   def_entry(my_sig, CODE_SE { name = "hw6",
                               source = makeDF([]),
                               target = makeDF(UNSIGNED_INT_T)
d315 1
a315 1
   val uint_pod_a4_1 = pod{ ctype = UNSIGNED_INT_T, hostel = my_hostel_a4 };
d333 3
a335 3
   val libX11 = load_structure("/usr/lib/libX11.so.5.0",IMMEADIATE_LM);
   val libXt  = load_structure("/usr/lib/libXt.so.5.0",IMMEADIATE_LM);
   val libXm  = load_structure("/usr/lib/libXm.so.1.2",IMMEADIATE_LM);
d340 1
a340 1
         hostel{ alloc    = FLOAT_AP,
d343 1
a343 1
                 status   = RDWR_H   };
d347 1
a347 1
   val x_struct = load_structure(x_name,IMMEADIATE_LM);
d357 1
a357 1
         pod { ctype     = STRING_T{ length = 64 },
d364 1
a364 1
         pod { ctype     = VOID_T,
d368 1
a368 1
   (* TEST 2.3 - Building C Signatures *)
d370 1
a370 1
   val x_sig = new_sig();
d373 1
a373 1
             CODE_SE 
d375 2
a376 2
                 source = makeDF([STRING_T{ length = 64 }]),
                 target = makeDF(VOID_T) });
@


1.7
log
@Addeing new tests ...
@
text
@d6 1
a6 1
   (* LOAD FORM *)
a7 1
   mf "__foreign.sml";
d9 1
a9 15
   open ForeignInterface;
   open Hostel;
   open Debug;
   open C;
   open Structure;
   open Type;
   open Value;
   open Signature;
   open Function;
   open Debug;




(* *)
d329 3
d333 3
a335 1
(*
a338 1

d383 1
a383 1
*)
@


1.6
log
@Adding remote access, diagnostics and other facilities.
@
text
@a344 3
(* *)


@


1.5
log
@Updating to new FI structure ..
@
text
@d3 1
d5 1
d12 1
d19 1
a19 13

(*
   (* TEST 0 - Basic Core *)

   open ForeignCore_;


   (*
   val fpath = "./tst.so";
   val fpath = "./nickb.so";
   *)

   val fpath = "./tst.so";
a20 7
   val fobj = load_object (fpath,LOAD_LATER);

   val obj_lst = list_content fobj;

   val hw = find_value (fobj, "hw");

   val my_value = find_value (fobj, "my_value");
a21 2
   call_unit_fun hw;
*)
d28 1
a28 1
   val my_hostel =
d34 5
a56 1
               currency  = true,
a62 1
               currency  = true,
a68 1
               currency  = true,
d74 3
d78 1
a81 2
   val my_sig = new_sig();

a154 1
               currency  = true,
a164 1
               currency  = true,
d167 1
a167 1
   index_pod{src=str_pod1_1,tgt=char_pod1,index=0};
d170 1
a170 1
   index_pod{src=str_pod1_1,tgt=char_pod1,index=1};
a174 1
               currency  = true,
d211 2
a212 1
               handle _ => load_structure("/usr/lib/libXm.so.2.11",IMMEADIATE_LM);
d236 112
a371 1
               currency  = true,
a378 1
               currency  = true,
d392 1
d394 22
d417 1
d419 1
a419 1
   val demo_box = attach(x_struct,x_sig)("demo_box");
d421 1
a421 1
   set_string(x_pod1,"Hope springs Eternal"); 
d423 1
a423 1
   call(demo_box)([x_pod1],void_pod);
@


1.4
log
@Updating tests.
...
@
text
@d6 1
a6 1
   mf "__c_interface.sml";
d8 8
a15 4
   open CInterface_;



@


1.3
log
@More tests ...
@
text
@d216 4
a219 2
   val libc = load_structure("/usr/lib/libc.so",IMMEADIATE_LM)
              handle _ => load_structure("/usr/lib/libc.so.1.8",IMMEADIATE_LM);
@


1.2
log
@Updating tests to include new material ...
@
text
@d39 1
d214 1
d216 4
a219 2

   val libc = load_structure("/usr/lib/libc.so",IMMEADIATE_LM);
d221 2
a222 1
   symbols(libc);
a223 2
   val libxm = load_structure("/usr/lib/libXm.so.2.12",IMMEADIATE_LM);
   
@


1.1
log
@new unit
No reason given
@
text
@d3 2
a4 1
Shell.Make.make_file "__foreign_interface.sml";
d6 1
a6 5
val load_object   = ForeignInterface_.load_object
and find_value    = ForeignInterface_.find_value
and list_content  = ForeignInterface_.list_content
and call_unit_fun = ForeignInterface_.call_unit_fun
;
d8 5
d14 21
a34 2
val fpath = "./tst.so";
val fpath = "./nickb.so";
d37 14
a50 1
val fpath = "./tst.so";
d52 36
a87 1
val fobj = load_object fpath;
d89 6
a94 1
val obj_lst = list_content fobj;
d96 63
a158 1
val hw = find_value (fobj, "hw");
d160 95
a254 3
val my_value = find_value (fobj, "my_value");
			   
call_unit_fun hw;
d256 42
@
