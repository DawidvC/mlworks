head	1.5;
access;
symbols
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5;
locks; strict;
comment	@ * @;


1.5
date	96.04.18.16.57.57;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	96.03.20.15.07.32;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.04.19.21.32.05;	author brianm;	state Exp;
branches;
next	1.2;

1.2
date	95.03.24.17.58.23;	author brianm;	state Exp;
branches;
next	1.1;

1.1
date	95.03.17.16.46.04;	author brianm;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.5
log
@initbasis becomes basis
@
text
@(*  ==== STATIC BYTEARRAYS ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  
 *
 *  Revision Log
 *  ------------
 *  $Log: _static_bytearray.sml,v $
 * Revision 1.4  1996/03/20  15:07:32  matthew
 * Language revision
 *
 * Revision 1.3  1995/04/19  21:32:05  brianm
 * General updating to reach prototype level for ML FI.
 *
 * Revision 1.2  1995/03/24  17:58:23  brianm
 * Added address_of operator to static_bytearrays and also
 * simplified implementation (mostly casts now).
 *
 * Revision 1.1  1995/03/17  16:46:04  brianm
 * new unit
 * New file.
 *
 *)

require "../basis/__word8array";
require "../basis/__word32";
require "../basis/__word8";

require "../utils/lists";
require "static_bytearray";

functor StaticByteArray(

  structure List      : LISTS

  ) : STATIC_BYTEARRAY =

  struct

    structure ByteArray = MLWorks.ByteArray

    type bytearray = ByteArray.bytearray

    type word8 = Word8.word

    type address = Word32.word

    datatype static_bytearray = STATIC of bytearray

    (* Mapping *)

    val MLWcast = MLWorks.Internal.Value.cast

    local
      val env = MLWorks.Internal.Runtime.environment

    in

      val mk_static_bytearray : int -> bytearray  =
            env "make static bytearray"

      val from_string : string -> static_bytearray  =
            env "static bytearray from string"

      val address_of : (static_bytearray * int) -> address =
            env "static bytearray address of"

    end

    val llength           = List.length

    val fill_ba  :  (bytearray * word8) -> unit  = MLWcast( ByteArray.fill )

    val sub_ba            = ByteArray.sub
    val update_ba         = ByteArray.update
    val length_ba         = ByteArray.length
    val tabulate_ba       = ByteArray.tabulate
    val to_list_ba        = ByteArray.to_list
    val to_string_ba      = ByteArray.to_string

    val unsafe_update_ba : (bytearray * int * word8) -> unit =
        MLWcast( MLWorks.Internal.Value.unsafe_bytearray_update )

 (* Exported Definitions *)

    fun array (size,item : word8) =
       let val sba = mk_static_bytearray(size)
       in
         fill_ba(sba,item);
         STATIC(sba)
       end;

    fun alloc_array(size) = STATIC(mk_static_bytearray(size))
        (* _Unsafe_ version of array above. *)

    val length   : static_bytearray -> int                 =  MLWcast( length_ba )
    val update   : static_bytearray * int * word8 -> unit  =  MLWcast( update_ba )
    val sub      : static_bytearray * int -> word8         =  MLWcast( sub_ba )

    fun from_list (list : word8 list) =
      let
        val sba = mk_static_bytearray(llength(list))

        fun fill (_, []) = ()
          | fill (n, x::xs) =
                (unsafe_update_ba (sba, n, x); fill (n+1, xs))
      in
        fill (0, list);
        STATIC(sba)
      end

    val arrayOfList = from_list

    val tabulate : (int * (int -> word8)) -> static_bytearray  =
          MLWcast( tabulate_ba )

    val to_bytearray  : static_bytearray -> bytearray  =
          MLWcast
        (* This works because MLWorks doesn't generate constructor tags
           for datatypes consisting of single entries.
         *)

    val to_list : static_bytearray -> word8 list =
          MLWcast( to_list_ba )

    val to_string : static_bytearray -> string =
          MLWcast( to_string_ba )



  end;
@


1.4
log
@Language revision
@
text
@d12 3
d18 7
a24 8
# Revision 1.2  1995/03/24  17:58:23  brianm
# Added address_of operator to static_bytearrays and also
# simplified implementation (mostly casts now).
#
# Revision 1.1  1995/03/17  16:46:04  brianm
# new unit
# New file.
#
d28 3
a30 3
require "../initbasis/__word8array";
require "../initbasis/__word32";
require "../initbasis/__word8";
@


1.3
log
@General updating to reach prototype level for ML FI.
@
text
@d12 3
d53 1
a53 1
    val MLWcast = MLWorks.Internal.Value.cast (fn x => x) : 'a -> 'b
d56 1
a56 4

      val MLWenvironment  = MLWorks.Internal.Runtime.environment

      fun env s = MLWcast (MLWenvironment s)
@


1.2
log
@Added address_of operator to static_bytearrays and also
simplified implementation (mostly casts now).
@
text
@d12 4
d23 1
d25 1
d37 1
d42 2
a45 2
    type word8 = int  (* Actually 0 - 255 and will eventually be Word8.word *)

d61 1
a61 1
          env "make static bytearray"
d64 1
a64 1
          env "static bytearray from string"
d67 1
a67 1
          env "static bytearray address of"
d71 1
d73 1
a73 1
    val llength           = List.length
a74 1
    val fill_ba           = ByteArray.fill
d82 2
a83 1
    val unsafe_update_ba  = MLWorks.Internal.Value.unsafe_bytearray_update
d85 1
a85 1
 (* Implementation *)
d90 2
a91 2
	 fill_ba(sba,item);
	 STATIC(sba)
d94 2
a95 3
    val length	 : static_bytearray -> int                 =  MLWcast( length_ba )
    val update	 : static_bytearray * int * word8 -> unit  =  MLWcast( update_ba )
    val sub	 : static_bytearray * int -> word8         =  MLWcast( sub_ba )
d97 4
d105 3
a107 3
	fun fill (_, []) = ()
	  | fill (n, x::xs) =
   	        (unsafe_update_ba (sba, n, x); fill (n+1, xs))
d109 2
a110 2
	fill (0, list);
	STATIC(sba)
d115 16
a130 2
    val tabulate      : (int * (int -> word8)) -> static_bytearray  =  MLWcast( tabulate_ba )
    val to_bytearray  : static_bytearray -> bytearray               =  MLWcast
a131 3
    val to_list	      : static_bytearray -> word8 list              =  MLWcast( to_list_ba )
    val to_string     : static_bytearray -> string                  =  MLWcast( to_string_ba )
      
@


1.1
log
@new unit
New file.
@
text
@d11 5
a15 1
 *  $Log$
d19 2
d31 5
a35 1
    structure ByteArray = MLWorks.ByteArray;
d37 2
a38 2
    type bytearray = ByteArray.bytearray;
            
d41 11
a51 1
   (* Mapping *)
d53 2
a54 2
    val MLWcast         = MLWorks.Internal.Value.cast (fn x => x) : 'a -> 'b;
    val MLWenvironment  = MLWorks.Internal.Runtime.environment;
d56 2
a57 17
    fun env s = MLWcast (MLWenvironment s);
(*
    val mk_static_bytearray : int -> bytearray   = env "make static bytearray";
    val from_string : string -> static_bytearray = env "static from string";
*)
    val mk_static_bytearray : int -> bytearray   = env "make static bytearray";
    val from_string : string -> static_bytearray = env "static bytearray from string";

    val llength           = List.length;

    val fill_ba           = ByteArray.fill;
    val sub_ba            = ByteArray.sub;
    val update_ba         = ByteArray.update;
    val length_ba         = ByteArray.length;
    val to_list_ba        = ByteArray.to_list;
    val to_string_ba      = ByteArray.to_string;
    val unsafe_update_ba  = MLWorks.Internal.Value.unsafe_bytearray_update;
d59 2
a60 1
    (* Implementation *)
d62 18
a79 1
    fun array (size,item) =
d86 3
a88 3
    fun length (STATIC ba) = length_ba(ba);

    fun update (STATIC ba, idx, itm) = update_ba(ba, idx, itm);
d90 1
a90 3
    fun sub (STATIC ba, idx) = sub_ba(ba, idx);

    fun from_list (list : int list) =
d92 1
a92 1
        val new = mk_static_bytearray(llength(list))
d96 1
a96 1
   	        (unsafe_update_ba (new, n, x); fill (n+1, xs))
d99 1
a99 1
	STATIC(new)
d102 1
a102 3
    val arrayoflist = from_list

    fun to_bytearray(STATIC ba) = ba
d104 2
a105 1
    fun to_list (STATIC ba) = to_list_ba(ba);
d107 2
a108 1
    fun to_string (STATIC ba) = to_string_ba(ba);
@
