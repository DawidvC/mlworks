head	1.5;
access;
symbols
	MLW_daveb_inline_1_4_99:1.5.8
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.5
	MLWorks_20c0_1998_08_04:1.5
	MLWorks_20b2c2_1998_06_19:1.5
	MLWorks_20b2_Windows_1998_06_12:1.5
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_workspace_97:1.5.7
	MLWorks_dt_wizard:1.5.6
	MLWorks_10r3:1.5.5.1.3
	MLWorks_10r2_551:1.5.5.1.2
	MLWorks_11:1.5.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.5.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.5.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.5
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.3.1.1
	MLWorks_gui_1996_12_18:1.5.4
	MLWorks_1_0_Win32_1996_12_17:1.5.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.1.1
	MLWorks_1_0_Irix_1996_11_28:1.5.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.2
	MLWorks_1_0_Unix_1996_11_14:1.5.1
	MLWorks_Open_Beta2_1996_10_11:1.3.2
	MLWorks_License_dev:1.3.1
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ *  @;


1.5
date	96.11.06.11.25.09;	author matthew;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1
	1.5.5.1
	1.5.6.1
	1.5.7.1
	1.5.8.1;
next	1.4;

1.4
date	96.10.25.12.52.36;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.09.20.14.48.53;	author io;	state Exp;
branches
	1.3.1.1
	1.3.2.1;
next	1.2;

1.2
date	96.05.22.14.10.32;	author brianm;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	96.05.19.13.59.05;	author brianm;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.11.52;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	96.10.07.16.02.35;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.10.17.11.20.50;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.11.14.12.44.33;	author hope;	state Exp;
branches
	1.5.1.1.1.1;
next	;

1.5.1.1.1.1
date	96.11.28.14.56.30;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.11.22.18.04.57;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.12.17.17.43.54;	author hope;	state Exp;
branches
	1.5.3.1.1.1;
next	;

1.5.3.1.1.1
date	97.02.24.11.33.10;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.12.18.09.37.52;	author hope;	state Exp;
branches;
next	;

1.5.5.1
date	97.05.12.10.30.09;	author hope;	state Exp;
branches
	1.5.5.1.1.1
	1.5.5.1.2.1
	1.5.5.1.3.1;
next	;

1.5.5.1.1.1
date	97.07.28.18.16.33;	author daveb;	state Exp;
branches;
next	;

1.5.5.1.2.1
date	97.09.08.17.10.07;	author daveb;	state Exp;
branches;
next	;

1.5.5.1.3.1
date	97.09.09.14.05.36;	author daveb;	state Exp;
branches;
next	;

1.5.6.1
date	97.09.10.19.20.01;	author brucem;	state Exp;
branches;
next	;

1.5.7.1
date	97.09.11.20.51.14;	author daveb;	state Exp;
branches;
next	;

1.5.8.1
date	99.04.01.17.54.57;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Renamed file.
@


1.5
log
@[Bug #1728]
__integer becomes __int
@
text
@(*  ==== FOREIGN INTERFACE : FOREIGN_OBJECT ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  
 *
 *  Revision Log
 *  ------------
 *  $Log: __object.sml,v $
 *  Revision 1.4  1996/10/25  12:52:36  io
 *  [Bug #1547]
 *  [Bug #1547]
 *  current naming conventions
 *
 *  Revision 1.3  1996/09/20  14:48:53  io
 *  [Bug #1603]
 *  convert ByteArray to Internal.ByteArray
 *
 *  Revision 1.2  1996/05/22  14:10:32  brianm
 *  Beta release modifications.
 *
 *  Revision 1.1  1996/05/19  13:59:07  brianm
 *  new unit
 *  Renamed file.
 *
 * Revision 1.10  1996/05/13  10:01:09  matthew
 * Changes to basis.
 *
 * Revision 1.9  1996/04/30  15:00:29  matthew
 * Removing utils/*integer
 *
 * Revision 1.8  1996/04/18  16:57:04  jont
 * initbasis becomes basis
 *
 * Revision 1.7  1995/09/12  16:26:02  daveb
 * Word conversion functions have changed.
 *
 *  Revision 1.6  1995/09/10  15:25:15  brianm
 *  Further modification for updates and general reorganisation.
 *
 *  Revision 1.5  1995/09/07  22:43:40  brianm
 *  Modifications for reorganisation & documentation.
 *
 *  Revision 1.4  1995/07/18  12:17:13  brianm
 *  Changing names of deferred data-type operators (stream-edit)
 *
 *  Revision 1.3  1995/06/26  12:03:05  brianm
 *  Adding remote access, diagnostics and other facilities.
 *
 *  Revision 1.2  1995/05/04  19:21:25  brianm
 *  Removing restrictive eqtype constraints & introduce abstypes in
 *  various implementing types.
 *
 *  Revision 1.1  1995/04/25  11:35:05  brianm
 *  new unit
 *  New file.
 *
 * Revision 1.1  1995/03/27  15:47:52  brianm
 * new unit
 *
 * New file.
 *
 *)

require "^.basis.__word32";
require "^.basis.__int";

require "types";
require "store";
require "utils";

require "__types";
require "__store";
require "__utils";

require "object";

structure ForeignObject_ : FOREIGN_OBJECT =
   struct

     structure FIStore : FOREIGN_STORE = ForeignStore_
     structure FIUtils : FOREIGN_UTILS = ForeignUtils_
     structure FITypes : FOREIGN_TYPES = ForeignTypes_

   (* Mapping *)
     open FIUtils
     open FITypes

     open FIStore

     structure ByteArray      =  MLWorks.Internal.ByteArray

     val bytearray  =  ByteArray.array
     val copy_ba'   =  ByteArray.copy
     val copy_ba    =
         fn (src,src_st,len,tgt,tgt_st) =>
            copy_ba'(src,src_st,src_st+len,tgt,tgt_st)

     val length_ba  =  ByteArray.length
     val to_list    =  ByteArray.to_list

     val word32_to_hex        =  FIUtils.word32_to_hex
     val bytearray_to_hex     =  FIUtils.bytearray_to_hex
     val bytearray_to_string  =  FIUtils.bytearray_to_string
     val peek_memory          =  FIUtils.peek_memory
     
     val addrToInt          =  Word32.toIntX
     val intToAddr          =  Word32.fromInt
     val pl32               =  Word32.+
     val mi32               =  Word32.-

     infix 6 pl32 mi32

   (* Implementation auxiliaries *)

     val null_addr = intToAddr(0)  (* Need Word32 literals as pattern match objects *) 

     fun new(ref(v)) = ref(v)

     fun addr_plus(a,i)    = a pl32 (intToAddr i)
     fun addr_minus(a1,a2) = addrToInt(a1 mi32 a2)


   (* Exported Definitions *)

     exception OutOfBounds
     exception Currency

     datatype object_mode   = LOCAL_OBJECT | REMOTE_OBJECT
     datatype object_status = PERMANENT_OBJECT | TEMPORARY_OBJECT

     abstype ('l_type) object =
              OBJECT of {
                        store   : store,
                        status   : object_status,
                        currency : bool ref,
                        mode     : object_mode ref,
                        ltype    : 'l_type ref,
                        size     : int ref,
                        base     : address box,
                        offset   : int ref
                     }
     with

	fun object{lang_type,size=object_size,status,mode,currency,store} =
	    let val new_offset = fresh_object_offset(store,object_size)
	    in
	      OBJECT {
		       store      =  store,
		       status     =  status,
		       currency   =  ref(currency),
		       mode       =  ref(mode),
		       ltype      =  ref(lang_type),
		       size       =  ref(object_size),
		       base       =  voidBox(),
		       offset     =  ref(new_offset)
		     }
	    end

	(* NOTE: Allignment constraints on objects come from the allocation
	   policy for stores and only affect the origin at which a object can be
	   located (it's offset) and _not_ the size of the object.  Hence, the
	   offset is calculated from size information and the current store.

	   In particular, the objectSize remains unaffected by the allocation
	   policy.  The function `fresh_object_offset' takes care of checking
	   that the new object fits within the given store - and if not, takes
	   appropriate action.
	*)

	fun object_store(OBJECT{store, ...}) = store

	fun objectStatus(OBJECT{status, ...}) = status

	fun objectLocation(OBJECT{offset, ...}) = !offset

	fun objectMode(OBJECT{mode, ...}) = !mode

	fun objectCurrency(OBJECT{currency, ...}) = !currency
	fun set_object_currency(OBJECT{currency, ...},flag) = (currency := flag)

	fun object_type(OBJECT{ltype, ...}) = !ltype
	fun set_object_type(OBJECT{ltype, ...},new_ltype) = (ltype := new_ltype)

	fun objectSize(OBJECT{size, ...}) = !size
	fun set_object_size'(OBJECT{size, ...},new_size) = (size := new_size)
	fun set_object_size(obj as OBJECT{size, ...},new_size) =
	    ( set_object_size'(obj,new_size);
              if (!size <> new_size) then set_object_currency(obj, false) else ()
            )

        fun object_base(OBJECT{base, ...}) = getBox(base)
	fun set_object_base(OBJECT{base, ...},addr) = setBox(base)(addr)

	local

	   fun object_addr'(store,offset) =
	       let val origin = store_origin(store)
	       in
		   addr_plus(origin,offset)
	       end

           fun update_object_base(OBJECT{store,offset,base, ...})= 
	       let val addr = object_addr'(store,!offset)
	       in
		 setBox(base)(addr)
	       end

	in

	    fun to_location (obj,addr) = 
                case objectMode(obj) of
                  LOCAL_OBJECT =>
		    let val store    = object_store(obj)
			val origin    = store_origin(store)
			val store_sz = storeSize(store)
			val new_locn  = addr_minus(addr,origin)
		    in
			if (0 <= new_locn) andalso (new_locn < store_sz)
			then new_locn
			else raise OutOfBounds
		    end
                | REMOTE_OBJECT => raise OutOfBounds

	    fun to_address (obj,locn) =
                case objectMode(obj) of
                  LOCAL_OBJECT =>
		    let val store    = object_store(obj)
			val store_sz = storeSize(store)
		    in
			if (0 <= locn) andalso (locn < store_sz)
			then let val origin = store_origin(store)
			     in
				 addr_plus(origin,locn)
			     end
			else raise OutOfBounds
		    end
                | REMOTE_OBJECT => raise OutOfBounds

	   fun objectAddress(OBJECT{ base=(ref(SOME(addr))), mode, offset, store, ...} ) =
               (
                 case !mode of
		   LOCAL_OBJECT =>
		     if (addr = null_addr)
		     then object_addr'(store,!offset)
		     else addr
		 | REMOTE_OBJECT => addr
               )

	     | objectAddress(OBJECT{ mode=ref(LOCAL_OBJECT), base, store, offset, ...}) =
	       let val addr     = object_addr'(store,!offset)
		   val new_base = if isStandardStore(store) then addr else null_addr
	       in
		 setBox(base)(new_base);
		 addr
	       end

	     | objectAddress(obj) =
               ( update_object_base(obj);
		 object_base(obj)
               )

	   fun relative_location(obj,addr) =
	       let val object_addr = objectAddress(obj)
	       in
		   addr_minus(addr,object_addr)
	       end

	   fun relative_address(obj,idx) =
	       let val object_addr = objectAddress(obj)
	       in
		   addr_plus(object_addr,idx)
	       end

	   fun set_object_mode(obj as OBJECT{mode, base, ...},new_mode) =
	       (
		 mode := new_mode;
                 case new_mode of
                   LOCAL_OBJECT   => resetBox(base)
                 | REMOTE_OBJECT  => update_object_base(obj)
	       )
	end

	fun object_value(obj, barr, offset) =
	    if not(objectCurrency(obj)) then raise Currency else
	    let val size = objectSize(obj)
	    in
		if (length_ba(barr) < offset + size) then raise OutOfBounds else
                case objectMode(obj) of
                  LOCAL_OBJECT =>
		     let val store = object_store(obj)
		     in
			 case storeStatus(store) of
			   WR_STATUS => raise WriteOnly
			 |
			   LOCKED_STATUS => raise WriteOnly
			 |
			   _ => let val src_ba = store_content(store)
				in
				    copy_ba(src_ba,objectLocation(obj),size,barr,offset)
				end
		     end
                | REMOTE_OBJECT =>
                     peek_memory
                       { loc=objectAddress(obj),
                         arr=barr,
                         start=offset,
                         len=size
                       }
	    end handle Option => raise OutOfBounds

	fun object_value'(obj, barr, offset) =
	    let val size = objectSize(obj)
            in
                case objectMode(obj) of
                  LOCAL_OBJECT =>
		    let val store = object_store(obj)
			val src_ba = store_content(store)
		    in
			copy_ba(src_ba,objectLocation(obj),size,barr,offset)
		    end
                | REMOTE_OBJECT =>
                     peek_memory
                       { loc=objectAddress(obj),
                         arr=barr,
                         start=offset,
                         len=size
                       }
            end

        local
	   fun examine_object'(obj,addr) =
	       ( set_object_currency(obj,true);
		 case objectMode(obj) of
		   LOCAL_OBJECT =>
		     let val store = object_store(obj)
			 val barr   = store_content(store)
			 val offset = objectLocation(obj)
			 val size   = objectSize(obj)
		     in
			 peek_memory{ loc   = addr,
				      arr   = barr,
				      start = offset,
				      len   = size }
		     end
		 | REMOTE_OBJECT =>
		     set_object_base(obj,addr)                 
	       )

        in

            fun examine_object(obj,addr) =
	      ( examine_object'(obj,addr);
	        set_object_currency(obj, true)
              )
        end

	local
	   fun update_store(barr,st,len,store,offset) =
	       let val dest_ba = store_content(store)
	       in
		   copy_ba(barr,st,len,dest_ba,offset)
	       end
	in
	   fun set_object_value(obj,barr,idx) =
               case objectMode(obj) of
                 LOCAL_OBJECT =>
		   let val store  =  object_store(obj)
		   in
		       if storeStatus(store) = RD_STATUS then raise ReadOnly else
		       let val len_barr   =  length_ba(barr)
			   val object_sz     =  objectSize(obj)
			   val upd_sz     =  Int.min(len_barr,object_sz)
			   val object_locn   =  objectLocation(obj)
			   val store_sz  =  storeSize(store)
			   val end_idx    =  idx + upd_sz
		       in
			  if (end_idx <= Int.min(len_barr,store_sz))
			  then update_store(barr,idx,upd_sz,store,object_locn)
			  else if end_idx <= len_barr (* i.e. store too small ... *)
			  then (
				  expand_managed(store,end_idx);
				  update_store(barr,idx,upd_sz,store,object_locn)
			       )
			  else raise OutOfBounds;
			  set_object_currency(obj,true)
		       end handle Option => raise OutOfBounds
		   end
               | REMOTE_OBJECT => raise ReadOnly

	   fun set_object_value'(obj,barr,idx) =
	       let val store     = object_store(obj)
		   val object_sz     = objectSize(obj)
		   val object_locn   = objectLocation(obj)
	       in
		   update_store(barr,idx,object_sz,store,object_locn);
		   set_object_currency(obj,true)
	       end

	   fun copy_object_value{from,to} =
	       let val from_size = objectSize(from)
	       in
                   if not(objectCurrency(from))     then raise Currency     else
		   if (from_size > objectSize(to))  then raise OutOfBounds  else
                   if (objectMode(to) = REMOTE_OBJECT)  then raise OutOfBounds  else
                   case objectMode(from) of
                     LOCAL_OBJECT =>
		       let val from_store = object_store(from)
			   val barr    = store_content(from_store)
			   val idx     = objectLocation(from)
			   val store  = object_store(to)
			   val to_idx  = objectLocation(to)
		       in
			   update_store(barr,idx,from_size,store,to_idx);
 		           set_object_currency(to,true)
		       end
                   | REMOTE_OBJECT =>
		       let val from_addr  = objectAddress(from)
			   val to_store  = object_store(to)
			   val to_idx     = objectLocation(to)
		       in
                           peek_memory
                             { loc=from_addr,
			       arr=store_content(to_store),
			       start=to_idx,
			       len=from_size };
 		           set_object_currency(to,true)
		       end
	       end

	   fun copy_object_value'{from,to} =
	       if (objectMode(to) = REMOTE_OBJECT)  then raise OutOfBounds  else
               let val to_store = object_store(to)
		   val barr      = store_content(to_store)
                   val to_idx    = objectLocation(to)
               in
                   object_value'(from, barr, to_idx)
               end
	end

	fun new_object(OBJECT{status,store,currency,mode,ltype,size,base,offset}) =
	    OBJECT{
                 status    = status,
                 store    = store,
		 currency  = new(currency),
                 mode      = new(mode),
		 ltype     = new(ltype),
		 size      = new(size),
		 base      = newBox(base),
		 offset    = new(offset)
	       }

	fun dup_object(obj as OBJECT{status = TEMPORARY_OBJECT, ...}) = obj
          | dup_object(OBJECT{store,currency,mode,ltype,size,base,offset, ...}) =
	    OBJECT{
                 status    = PERMANENT_OBJECT,
                 store    = store,
		 currency  = new(currency),
                 mode      = new(mode),
		 ltype     = new(ltype),
		 size      = new(size),
		 base      = newBox(base),
		 offset    = new(offset)
	       }

	fun tmp_object(obj as OBJECT{status = TEMPORARY_OBJECT, ...}) =
	    (
              set_object_currency(obj, false);
	      obj
            )
          | tmp_object(OBJECT{store,mode,ltype,size,base,offset, ...}) =
	    OBJECT{
                 status    = TEMPORARY_OBJECT,
                 store    = store,
		 currency  = ref(false),
                 mode      = new(mode),
		 ltype     = new(ltype),
		 size      = new(size),
		 base      = newBox(base),
		 offset    = new(offset)
	       }

	local

	    fun reset_base(base) =
		case extractBox(base) of
		  SOME(addr) =>
		    if (addr = null_addr) then () else resetBox(base)
		|
		   _ => ()

            fun move_object_local(store,size,base,offset,new_offset) =
		(
		  adjust_store(store,new_offset,!size);
		  reset_base(base);
		  offset := new_offset
		)

            fun move_object_remote(base,incr) =
                let val cur_addr = getBox(base)
                    val new_addr = addr_plus(cur_addr,incr)
                in
                    setBox(base)(new_addr)
                end

            fun set_addr_remote(base,addr) = setBox(base)(addr)

            fun set_addr_local(store,size,base,offset,addr) =
                let val origin     = store_origin(store)
                    val new_offset = addr_minus(addr,origin)
                in
                    move_object_local(store,size,base,offset,new_offset)
                end
	in

	    fun move_object'(OBJECT{mode=ref(REMOTE_OBJECT), base, ...}, incr) =
                move_object_remote(base,incr)

              | move_object'(OBJECT{store, base, offset, size, ...}, new_offset) =
                move_object_local(store, size, base, offset, new_offset)

	    fun offset_object'(OBJECT{mode=ref(REMOTE_OBJECT),base, ...}, incr) =
                move_object_remote(base,incr)

              | offset_object'(OBJECT{store, base, offset, size, ...},incr) =
                let val new_offset = (!offset + incr)
                in
                    move_object_local(store, size, base, offset, new_offset)
                end

	    fun set_object_address'(OBJECT{mode=ref(REMOTE_OBJECT),base, ...}, addr) =
                set_addr_remote(base,addr)

              | set_object_address'(OBJECT{store, base, offset, size, ...}, addr) =
                set_addr_local(store, size, base, offset, addr)


	  fun move_object(obj,arg) =
              ( move_object'(obj,arg); set_object_currency(obj,false) )

	  fun offset_object(obj,arg) =
              ( offset_object'(obj,arg); set_object_currency(obj,false) )

          fun set_object_address(obj, arg) =
              ( set_object_address'(obj,arg); set_object_currency(obj,false) )

	end

     (* Diagnostic tools *)

        local

            fun str_object_status (PERMANENT_OBJECT) = "permanent"
              | str_object_status (TEMPORARY_OBJECT) = "temporary"

            fun str_currency(true)  = "valid"
              | str_currency(false) = "not valid"

            fun str_object_mode(LOCAL_OBJECT)  = "local"
              | str_object_mode(REMOTE_OBJECT) = "remote"

            fun str_base((ref(some_addr))) = some_addr

	    fun object_data'(obj,size) =
		let val ba = bytearray(size,0)
		in
		    object_value'(obj,ba,0); (* don't check currency *)
                    ba
                end
        in

	    fun object_info
		  type_info
		  (OBJECT{status, currency, mode, ltype, size, base, offset, store}) =
		{ store    = store,
		  status    = str_object_status(status),
		  currency  = str_currency(!currency),
		  mode      = str_object_mode(!mode),
                  langtype  = type_info(!ltype),
                  size      = !size,
                  base      = str_base(base),
                  offset    = !offset
                }

           fun object_data(obj) =
               let val size = objectSize(obj)
                   val ba   = object_data'(obj,size)
               in
		   to_list(ba)
               end

           fun object_data_hex(obj) =
               let val size = objectSize(obj)
                   val ba   = object_data'(obj,size)
               in
		   bytearray_to_hex{arr=ba,st=0,len=size}
               end

           fun object_data_ascii(obj) =
               let val size = objectSize(obj)
                   val ba   = object_data'(obj,size)
               in
		   bytearray_to_string{arr=ba,st=0,len=size}
               end
        end
     end
   end;  (* structure FOREIGN_OBJECT *) 
@


1.5.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:09  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:09  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:09  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.5.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:09  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 *  Revision 1.5.5.1  1997/05/12  10:30:09  hope
 *  branched from 1.5
 *
@


1.5.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 *  Revision 1.5.5.1  1997/05/12  10:30:09  hope
 *  branched from 1.5
 *
@


1.5.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 *  Revision 1.5.5.1  1997/05/12  10:30:09  hope
 *  branched from 1.5
 *
@


1.5.4.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:09  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.3.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:09  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.3.1.1.1
log
@branched from 1.5.3.1
@
text
@a11 3
 *  Revision 1.5.3.1  1996/12/17  17:43:54  hope
 *  branched from 1.5
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:09  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a11 4
 *  Revision 1.5  1996/11/06  11:25:09  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.5.1.1.1.1
log
@branched from 1.5.1.1
@
text
@a11 3
 *  Revision 1.5.1.1  1996/11/14  12:44:33  hope
 *  branched from 1.5
 *
@


1.4
log
@[Bug #1547]
[Bug #1547]
current naming conventions
@
text
@d12 5
d68 1
a68 1
require "^.basis.__integer";
@


1.3
log
@[Bug #1603]
convert ByteArray to Internal.ByteArray
@
text
@d12 4
d62 2
a63 3
require "../basis/__general";
require "../basis/__word32";
require "../basis/__integer";
a82 6

     val MLWcast  =  MLWorks.Internal.Value.cast : 'a -> 'b;


     open General

a110 6
     val extract            =  General.valOf

     val min                =  Int.min
     val max                =  Int.max


d162 1
a162 1
	   In particular, the object_size remains unaffected by the allocation
d170 1
a170 1
	fun object_status(OBJECT{status, ...}) = status
d172 1
a172 1
	fun object_location(OBJECT{offset, ...}) = !offset
d174 1
a174 1
	fun object_mode(OBJECT{mode, ...}) = !mode
d176 1
a176 1
	fun object_currency(OBJECT{currency, ...}) = !currency
d182 1
a182 1
	fun object_size(OBJECT{size, ...}) = !size
d209 1
a209 1
                case object_mode(obj) of
d213 1
a213 1
			val store_sz = store_size(store)
d223 1
a223 1
                case object_mode(obj) of
d226 1
a226 1
			val store_sz = store_size(store)
d237 1
a237 1
	   fun object_address(OBJECT{ base=(ref(SOME(addr))), mode, offset, store, ...} ) =
d247 1
a247 1
	     | object_address(OBJECT{ mode=ref(LOCAL_OBJECT), base, store, offset, ...}) =
d249 1
a249 1
		   val new_base = if is_standard_store(store) then addr else null_addr
d255 1
a255 1
	     | object_address(obj) =
d261 1
a261 1
	       let val object_addr = object_address(obj)
d267 1
a267 1
	       let val object_addr = object_address(obj)
d282 2
a283 2
	    if not(object_currency(obj)) then raise Currency else
	    let val size = object_size(obj)
d286 1
a286 1
                case object_mode(obj) of
d290 1
a290 1
			 case store_status(store) of
d297 1
a297 1
				    copy_ba(src_ba,object_location(obj),size,barr,offset)
d302 1
a302 1
                       { loc=object_address(obj),
d310 1
a310 1
	    let val size = object_size(obj)
d312 1
a312 1
                case object_mode(obj) of
d317 1
a317 1
			copy_ba(src_ba,object_location(obj),size,barr,offset)
d321 1
a321 1
                       { loc=object_address(obj),
d331 1
a331 1
		 case object_mode(obj) of
d335 2
a336 2
			 val offset = object_location(obj)
			 val size   = object_size(obj)
d363 1
a363 1
               case object_mode(obj) of
d367 1
a367 1
		       if store_status(store) = RD_STATUS then raise ReadOnly else
d369 4
a372 4
			   val object_sz     =  object_size(obj)
			   val upd_sz     =  min(len_barr,object_sz)
			   val object_locn   =  object_location(obj)
			   val store_sz  =  store_size(store)
d375 1
a375 1
			  if (end_idx <= min(len_barr,store_sz))
d390 2
a391 2
		   val object_sz     = object_size(obj)
		   val object_locn   = object_location(obj)
d398 1
a398 1
	       let val from_size = object_size(from)
d400 4
a403 4
                   if not(object_currency(from))     then raise Currency     else
		   if (from_size > object_size(to))  then raise OutOfBounds  else
                   if (object_mode(to) = REMOTE_OBJECT)  then raise OutOfBounds  else
                   case object_mode(from) of
d407 1
a407 1
			   val idx     = object_location(from)
d409 1
a409 1
			   val to_idx  = object_location(to)
d415 1
a415 1
		       let val from_addr  = object_address(from)
d417 1
a417 1
			   val to_idx     = object_location(to)
d429 1
a429 1
	       if (object_mode(to) = REMOTE_OBJECT)  then raise OutOfBounds  else
d432 1
a432 1
                   val to_idx    = object_location(to)
d583 1
a583 1
               let val size = object_size(obj)
d590 1
a590 1
               let val size = object_size(obj)
d597 1
a597 1
               let val size = object_size(obj)
@


1.3.2.1
log
@branched from 1.3
@
text
@a11 4
 *  Revision 1.3  1996/09/20  14:48:53  io
 *  [Bug #1603]
 *  convert ByteArray to Internal.ByteArray
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a11 4
 *  Revision 1.3  1996/09/20  14:48:53  io
 *  [Bug #1603]
 *  convert ByteArray to Internal.ByteArray
 *
@


1.2
log
@Beta release modifications.
@
text
@d11 4
a14 1
 *  $Log: _object.sml,v $
d91 1
a91 1
     structure ByteArray      =  MLWorks.ByteArray
@


1.2.1.1
log
@branched from 1.2
@
text
@d11 1
a11 4
 *  $Log: __object.sml,v $
 *  Revision 1.2  1996/05/22  14:10:32  brianm
 *  Beta release modifications.
 *
@


1.1
log
@new unit
Renamed file.
@
text
@d5 4
d11 9
a19 2
 *  $Log: __data.sml,v $
 * Revision 1.2  1996/04/30  15:01:42  matthew
d22 27
a48 1
 * Revision 1.1  1995/04/25  11:22:53  brianm
d50 1
a52 1
 *
d55 8
a63 1

d67 499
a565 1
require "_data";
d567 7
d575 12
a586 1
structure ForeignObject_ = ForeignObject(
d588 6
a593 3
   structure FIStore  = ForeignStore_
   structure FIUtils   = ForeignUtils_
     structure FITypes = ForeignTypes_
d595 6
a600 1
);
d602 9
@
