head	1.3;
access;
symbols
	ML_final_beta_release_02/03/94:1.3
	mlworks-28-01-1994:1.3
	Release:1.3
	mlworks-beta-01-09-1993:1.3
	MLWorks-1-0-4-29/01/1993:1.3
	MLWorks-1-0-3-21/12/1992:1.3
	MLWorks-1-0-2-15/12/1992:1.3
	MLWorks-1-0-1-04/12/1992:1.3
	checkpoint_17_08_92:1.3
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.1;
locks; strict;


1.3
date	91.11.21.16.31.46;	author jont;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	91.08.11.16.52.59;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.10.59.43;	author colin;	state Exp;
branches;
next	;

1.3.1.1
date	91.11.21.16.31.46;	author jont;	state Exp;
branches;
next	;


desc
@Order modules from require dependencies for NJML batch compiler
@


1.3
log
@Added copyright message
@
text
@(*
$Log:	makeall.sml,v $
Revision 1.2  91/08/11  16:52:59  colin
removed all references to wundt and made the searching for "require"s
smarter.

Revision 1.1  91/06/07  10:59:43  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)
(** From Anel, a function that works out dependencies
    Last updated : Mon Jan 21 16:43:43 1991
**)

fun decompose_path filename =
    let 
      fun stripDots (name) = 
	  if String.substring (name,0,3) = "../" 
	    then String.substring (name,3,String.length name - 3)
	  else name
      val revChars = rev (explode filename)

      fun stripSlash (nil, name) = (nil, name)
	| stripSlash (p as "/" :: rest, name) = (rev p, name)
	| stripSlash (ch :: rest, name) = stripSlash(rest, ch :: name)
    in
      let val (a,b) = stripSlash(revChars, nil)
      in
	(implode a, implode b)
      end
    end
  
fun getImports (openfile,alist) =
  if end_of_stream openfile
    then
      nil
  else
    let
      val line = input_line openfile   (* all of string *)
      fun extract_path line =   (* get part in quotes *)
	let
	  (* a function which removes up 'til a quote *)
	  fun strip ("\""::x) = x     (* Damn emacs messes up \" *)
	    | strip (_::x) = strip x
	    | strip [] = []
	in
	  implode (rev (strip (rev (strip (explode line)))))
	end
    in
      if String.size (line) > 7
	then
	  if String.substring (line,0,7) = "require"
	    then                       (* go for it *)
	      decompose_path (extract_path (line))::getImports (openfile,
								alist)
	  else
	    getImports (openfile,alist)
      else 
	getImports (openfile,alist)
    end

fun member (m,[]) = false
  | member (m,h::t) = #2 (decompose_path m) = #2 (decompose_path h)
    orelse member (m,t)


fun mkFilelist (filename,alist,dir) = 
    let 
      val open_file = open_in filename
      val (topdir,_) = decompose_path (filename)
      val imports = getImports (open_file,[])
    in
      if imports = []
	then
	  (close_in open_file;
	   if member (filename,alist)
	     then alist
	   else alist @@ [filename])
      else
	(close_in open_file;
	 if member (filename,alist)
	   then mkImportFilelist (imports,alist,dir,topdir)
	 else
	   mkImportFilelist (imports,alist,dir,topdir) @@ [filename])
    end
  
and mkImportFilelist ([],alist,_,_) = alist
  | mkImportFilelist ((dir,filename)::names,alist,current_dir,topdir) = 
    let 
      exception Impossible
      fun lastpart (dir) = hd (tl (rev (explode (dir))))
      val new_dir = if lastpart (current_dir) = "src"
		      then 
			if not (dir = "")
			  then 
			    if String.substring (dir,0,3) = "../"
			      then 
				current_dir ^ 
				String.substring (dir,3,
						  (String.length dir)-3)
			    else current_dir ^ dir
			else raise Impossible
		    else 
		      if not (dir = "")
			then 
			  if String.substring (dir,0,3) = "../"
			    then 
			      String.substring (dir,3,(String.length dir)-3)
			  else dir
		      else topdir

      val added =   (* what should we add to the filename? *)
	  let
	    val len = String.length filename
	    val extent =
		if (len < 4) then ""
		else
		  String.substring (filename, len - 4, 4)
	  in
	    if (extent = ".sml" orelse extent = ".str") then "" else ".sml"
	  end

      val fullname = new_dir ^ filename ^ added
    in
      if member (fullname, alist) then
	mkImportFilelist (names, alist, new_dir, topdir)
      else
	mkImportFilelist (names,mkFilelist (fullname,alist,new_dir),
			  new_dir,topdir)
    end

(** Print the filenames to a stream **)
fun mapprint filename rest =
    let
      val stream = open_out filename
    in
      ((output (stream, "!make/require.sml\n");
	(map (fn x => output (stream, "!" ^ x ^ "\n")) rest);
	output (stream, ">batch.save\n"))
       handle exn => (close_out stream; raise exn);
	 close_out stream)
    end

fun makeall (topfile,outfile) =
  mapprint outfile
  let 
    val (path,_) = decompose_path (topfile)
  in
    mkFilelist (topfile,[],path)
  end
@


1.3.1.1
log
@Fork for bug fixing
@
text
@d2 1
a2 4
$Log: makeall.sml,v $
Revision 1.3  1991/11/21  16:31:46  jont
Added copyright message

@


1.2
log
@removed all references to wundt and made the searching for "require"s
smarter.
@
text
@d3 4
d10 1
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d30 4
a34 1
      val first = lookahead openfile   (* first char *)
d37 8
a44 8
	  let
	    (* a function which removes up 'til a quote *)
	    fun strip ("\""::x) = x     (* Damn emacs messes up \" *)
	      | strip (_::x) = strip x
	      | strip [] = []
	  in
	    implode (rev (strip (rev (strip (explode line)))))
	  end
d46 10
a55 11
      if (first = " " orelse first = "\n" orelse first = "\t") then
	getImports (openfile, alist)  (* Skip blank lines *)
      else
	(if String.size (line) > 7
	   then
	     if String.substring (line,0,7) = "require"
	       then                       (* go for it *)
		 decompose_path (extract_path (line))::getImports (openfile,
								   alist)
	     else alist
	 else alist)
d79 2
a80 2
	 else (print filename;
	       mkImportFilelist (imports,alist,dir,topdir) @@ [filename]))
a103 1
			      "/wundt/usr/sml/src/" ^ 
d105 1
a105 1
			  else "/wundt/usr/sml/src/" ^ dir
d133 1
a133 1
      ((output (stream, "!/wundt/usr/sml/src/make/require.sml\n");
d135 1
a135 1
	output (stream, ">batch68.save\n"))
@
