head	1.72;
access;
symbols
	ML_beta_release_12/08/94:1.56
	ML_beta_release_03/08/94:1.56
	ML_revised_beta_release_25/05/94:1.56
	ML_final_beta_release_02/03/94:1.54
	mlworks-28-01-1994:1.52
	Release:1.44
	mlworks-beta-01-09-1993:1.44
	MLWorks-1-0-4-29/01/1993:1.23
	MLWorks-1-0-3-21/12/1992:1.23
	MLWorks-1-0-2-15/12/1992:1.22
	MLWorks-1-0-1-04/12/1992:1.18
	checkpoint_17_08_92:1.6;
locks; strict;


1.72
date	95.09.07.10.43.02;	author jont;	state Exp;
branches;
next	1.71;

1.71
date	95.09.06.10.10.35;	author jont;	state Exp;
branches;
next	1.70;

1.70
date	95.09.05.10.00.11;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	95.04.28.15.38.20;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	95.04.21.14.55.24;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	95.04.06.10.52.45;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	95.03.02.12.59.43;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	95.02.17.14.52.51;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	95.02.10.15.24.18;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	95.01.17.16.19.11;	author daveb;	state Exp;
branches;
next	1.62;

1.62
date	94.12.09.17.01.33;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	94.12.09.15.43.42;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	94.12.08.17.31.46;	author jont;	state Exp;
branches;
next	1.59;

1.59
date	94.12.05.14.26.16;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	94.10.13.11.26.55;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	94.10.06.10.33.12;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	94.04.08.10.54.23;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	94.03.25.18.16.44;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	94.02.08.14.52.42;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	94.02.01.16.28.40;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	94.01.26.18.18.15;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	93.12.23.13.28.04;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	93.12.15.14.29.36;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	93.11.15.14.27.49;	author nickh;	state Exp;
branches;
next	1.48;

1.48
date	93.11.09.13.59.58;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	93.09.27.15.16.50;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	93.09.10.17.39.50;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	93.09.06.15.48.39;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	93.08.28.19.17.25;	author daveb;	state Exp;
branches
	1.44.1.1;
next	1.43;

1.43
date	93.08.28.14.36.11;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	93.08.26.17.40.11;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	93.08.25.13.29.59;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	93.08.25.12.38.56;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	93.08.24.16.17.56;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	93.08.24.15.15.17;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	93.08.19.14.39.46;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	93.08.18.13.40.32;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	93.08.17.11.47.42;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	93.05.28.12.38.12;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	93.05.25.16.08.17;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	93.05.13.13.23.15;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	93.05.11.17.07.25;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	93.03.29.11.06.54;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	93.03.24.14.20.24;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	93.03.11.12.48.41;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.03.04.17.15.20;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.03.01.14.20.37;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.02.19.11.31.59;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	93.02.09.17.51.24;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	92.12.16.18.38.53;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.12.15.17.16.35;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.12.10.15.22.38;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	92.12.09.18.15.20;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	92.12.08.20.25.14;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.12.04.12.02.32;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.12.01.16.20.38;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	92.11.27.17.34.08;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	92.11.19.19.32.47;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.11.17.18.00.55;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.11.03.17.39.42;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.10.27.17.12.17;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.09.04.14.06.02;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.08.25.08.11.17;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.08.21.16.28.04;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.20.17.58.10;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	92.08.17.10.55.34;	author davidt;	state Exp;
branches;
next	1.6;

1.6
date	92.08.14.13.18.28;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	92.08.10.11.49.52;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	92.08.03.12.46.28;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.07.23.12.48.05;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.07.23.09.48.15;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.07.22.14.57.43;	author jont;	state Exp;
branches;
next	;

1.44.1.1
date	93.08.28.19.17.25;	author jont;	state Exp;
branches;
next	1.44.1.2;

1.44.1.2
date	93.09.06.15.45.39;	author jont;	state Exp;
branches;
next	1.44.1.3;

1.44.1.3
date	93.09.10.17.05.35;	author jont;	state Exp;
branches;
next	1.44.1.4;

1.44.1.4
date	93.09.27.11.10.28;	author jont;	state Exp;
branches;
next	1.44.1.5;

1.44.1.5
date	93.10.22.16.02.58;	author daveb;	state Exp;
branches;
next	;


desc
@Batch recompilation system
@


1.72
log
@Use non-faulting form of from_string to allow recompilation
of broken .mo files
@
text
@(* _recompile.sml the functor *)
(*
$Log: _recompile.sml,v $
Revision 1.71  1995/09/06  10:10:35  jont
Modify find_mo_time to atempt to get the true module name
in the case where the .mo file is not found. Remove some
superfluous parent stuff

Revision 1.70  1995/09/05  10:00:11  jont
Ensure error reports are made where pervasive files are missing

Revision 1.69  1995/04/28  15:38:20  jont
Module naming improvements

Revision 1.68  1995/04/21  14:55:24  matthew
Improving check dependencies message

Revision 1.67  1995/04/06  10:52:45  matthew
Get dependencies from sml file when decapsulating fails

Revision 1.66  1995/03/02  12:59:43  matthew
Change to Lexer structure

Revision 1.65  1995/02/17  14:52:51  daveb
Added a diagnostic when extending the source path.

Revision 1.64  1995/02/10  15:24:18  daveb
Removed modpath and level arguments from recompile'', as they were
only used in debugging statements, and level can be computed
(it is the same as Lists.length (doing)).

Revision 1.63  1995/01/17  16:19:11  daveb
Replaced Option structure with references to MLWorks.Option.
Removed obsolete sharing constraint.

Revision 1.62  1994/12/09  17:01:33  daveb
Added location to error message when a module is not found.

Revision 1.61  1994/12/09  15:43:42  daveb
Ensured that imports are traversed in the intuitive order when they
are read from a .mo file, by reversing them at a key point.

Revision 1.60  1994/12/08  17:31:46  jont
Move OS specific stuff into a system link directory

Revision 1.59  1994/12/05  14:26:16  daveb
Avoided unnecessary lexing, when dependencies can be read from .mo file.

Revision 1.58  1994/10/13  11:26:55  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.57  1994/10/06  10:33:12  matthew
Improved module id caching

Revision 1.56  1994/04/08  10:54:23  jont
Add original require file names to consistency info.

Revision 1.55  1994/03/25  18:16:44  daveb
Added recompile_module.

Revision 1.54  1994/02/08  14:52:42  daveb
Module.module_and_path is now Module.find_file, is functional, and is
called on all arguments to compile_file before any compilation is done.

Revision 1.53  1994/02/01  16:28:40  daveb
Module names have been moved to Module from FileName.

Revision 1.52  1994/01/26  18:18:15  matthew
Removed call to set_pervasive_dir

Revision 1.52  1994/01/26  16:28:56  matthew
*** empty log message ***

Revision 1.51  1993/12/23  13:28:04  daveb
Changed error message for non-existent file.

Revision 1.50  1993/12/15  14:29:36  matthew
Renamed Encapsulate.Basistypes to Encapsulate.BasisTypes

Revision 1.49  1993/11/15  14:27:49  nickh
Change to pervasive time structure.

Revision 1.48  1993/11/09  13:59:58  daveb
Merged in bug fix.

Revision 1.47  1993/09/27  15:16:50  jont
Merging in bug fixes

Revision 1.46  1993/09/10  17:39:50  jont
Merging in bug fixes

Revision 1.45  1993/09/06  15:48:39  jont
Merged in bug fixes for speed improvements

Revision 1.44.1.5  1993/10/22  16:02:58  daveb
Removed option of passing long_id to require.

Revision 1.44.1.4  1993/09/27  11:10:28  jont
Changed to pass a pervasive mo cache to compile_file' and to accept
it updated as a return

Revision 1.46  1993/09/10  17:39:50  jont
Merging in bug fixes

Revision 1.45  1993/09/06  15:48:39  jont
Merged in bug fixes for speed improvements

Revision 1.44.1.3  1993/09/10  17:05:35  jont
Modified to make better use of the file caches

Revision 1.44.1.2  1993/09/06  15:45:39  jont
Improvements to use up_to_date information to determine whether to lex files
or not, and to avoid check when some require has been recompiled. Also took
module name disambiguation out of recompile' and put it in the parameters

Revision 1.44.1.1  1993/08/28  19:17:25  jont
Fork for bug fixing

Revision 1.44  1993/08/28  19:17:25  daveb
Removed calls to Io.set_pervasive_dir_from_env and
Io.set_source_path_from_env.  Added these to the daily build script instead.

Revision 1.43  1993/08/28  14:36:11  daveb
Added filename caches.

Revision 1.42  1993/08/26  17:40:11  daveb
Several changes to search for mos along source path and to handle case
where one of mo and sml files doesn't exist.  Some optimisation, and
improvement of error messages.
Use ModuleId.create to check that moduleids in require decs are alphanumeric.

Revision 1.41  1993/08/25  13:29:59  daveb
Io.get_pervasive_dir can raise Io.NotSet.

Revision 1.40  1993/08/25  12:38:56  daveb
Fixed error message.

Revision 1.39  1993/08/24  16:17:56  daveb
ModuleId.from_string now takes a location argument.

Revision 1.38  1993/08/24  15:15:17  jont
Fixed two bugs with the no_execute option.
First stop check complaining about missing .mo files when no_execute is set.
Second ensure that mo consistency takes into account the fact that no
recompilation is done.

Revision 1.37  1993/08/19  14:39:46  daveb
Added MLWORKS_ to the start of UNIX environment variables.

Revision 1.36  1993/08/18  13:40:32  daveb
Added calls to set pervasive_dir and source_path from UNIX environment,
for building under SML/NJ.

Revision 1.35  1993/08/17  11:47:42  daveb
Major changes:
Require declarations now take ModuleIds instead of strings.  These are
checked against a search path.
Also added diagnostics.

Revision 1.34  1993/05/28  12:38:12  jont
Cleaned up after assembly changes

Revision 1.33  1993/05/25  16:08:17  jont
Changes because Assemblies now has Basistypes instead of Datatypes

Revision 1.32  1993/05/13  13:23:15  jont
Changed the crash when an mo is not found during checking to a fatal error
with a message suggesting various things to check

Revision 1.31  1993/05/11  17:07:25  jont
Added make -n type facility

Revision 1.30  1993/03/29  11:06:54  daveb
getToken now takes a LexerState argument.

Revision 1.29  1993/03/24  14:20:24  daveb
Lexer.getToken now takes an options parameter.

Revision 1.28  1993/03/11  12:48:41  matthew
Signature revisions

Revision 1.27  1993/03/04  17:15:20  matthew
Options & Info changes

Revision 1.26  1993/03/01  14:20:37  jont
Added more information to circular require structure error, now gives
list of file names

Revision 1.25  1993/02/19  11:31:59  daveb
Added better error messages when syntax errors found in require expressions.

Revision 1.24  1993/02/09  17:51:24  matthew
Typechecker structure changes

Revision 1.23  1992/12/16  18:38:53  jont
Put a handle Io _ around get_imports to avoid unwanted exceptions
at that stage

Revision 1.22  1992/12/15  17:16:35  jont
Added the missing rev at the end of get_imports_from_stream

Revision 1.21  1992/12/10  15:22:38  daveb
The version of get_imports_from_stream that I checked in last night was
totally broken, so I fixed it.  Also, the lexer version is *7 times*
slower, so we now require "require"s to come at the start of the file.

Revision 1.20  1992/12/09  18:15:20  daveb
Now uses lexer to search for require declarations.

Revision 1.19  1992/12/08  20:25:14  jont
Removed a number of duplicated signatures and structures

Revision 1.18  1992/12/04  12:02:32  jont
Modified handling of corrupt .mo files to force recompilation
instead of halting compilation

Revision 1.17  1992/12/01  16:20:38  daveb
Changes to propagate compiler options as parameters instead of references.

Revision 1.16  1992/11/27  17:34:08  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.15  1992/11/19  19:32:47  jont
Removed Info structure from parser, tidied upderived

Revision 1.14  1992/11/17  18:00:55  matthew
Changed Error structure to Info

Revision 1.13  1992/11/03  17:39:42  richard
Changes to pervasives and representation of time.

Revision 1.12  1992/10/27  17:12:17  jont
Removed Error from toplevel signature

Revision 1.11  1992/09/04  14:06:02  richard
Installed central error reporting mechanism.
Moved the special names out of the compiler as a whole.

Revision 1.10  1992/08/25  08:11:17  richard
Added bytearray and bits to pervasive modules.

Revision 1.9  1992/08/21  16:28:04  jont
Added circularity detection for requires

Revision 1.8  1992/08/20  17:58:10  davidt
Made changes to allow relocation of mo files.

Revision 1.7  1992/08/17  10:55:34  davidt
Changed to use MLWorks.IO.input_line

Revision 1.6  1992/08/14  13:18:28  davidt
Changed to use new Encapsulate interface.

Revision 1.5  1992/08/10  11:49:52  davidt
String structure is now pervasive, added mlworks.sml,
string.sml and array.sml to the list of pervasive
library modules.

Revision 1.4  1992/08/03  12:46:28  jont
Improved get_imports_from_stream

Revision 1.3  1992/07/23  12:48:05  clive
Encapsulator has had its datastructures changed

Revision 1.1  1992/07/22  14:57:43  jont
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "../utils/print";
require "../utils/newmap";
require "../utils/lists";
require "../utils/crash";
require "../basics/module";
require "../basics/module_id";
require "../make/os";
require "../lexer/lexer";
require "../main/encapsulate";
require "../main/toplevel";
require "../main/io";
require "../utils/diagnostic";

require "recompile";

functor Recompile
  (structure Print	: PRINT
   structure NewMap	: NEWMAP
   structure Lists	: LISTS
   structure Crash	: CRASH
   structure Module	: MODULE
   structure Os		: OS
   structure Lexer      : LEXER
   structure Encapsulate	: ENCAPSULATE
   structure TopLevel	: TOPLEVEL
   structure Io		: IO
   structure ModuleId	: MODULE_ID
   structure Diagnostic	: DIAGNOSTIC

   sharing Lexer.Info = TopLevel.Info
   sharing type Lexer.Options = TopLevel.Options.options
   sharing Encapsulate.EnvironTypes = TopLevel.EnvironTypes

   sharing type Encapsulate.BasisTypes.Basis = TopLevel.TypeBasis
   sharing type ModuleId.ModuleId = Module.ModuleId
   sharing type ModuleId.Symbol = Lexer.Token.Symbol.Symbol
   sharing type ModuleId.Location = Lexer.Info.Location.T = Module.Location
   sharing type TopLevel.ModuleCache = Module.Cache
   sharing type TopLevel.Module = Module.Module

) : RECOMPILE =
  struct
    structure Diagnostic = Diagnostic
    structure Lexer = Lexer
    structure Info = Lexer.Info
    structure Token = Lexer.Token
    structure Options = TopLevel.Options

    type Module = Module.Module;

    val _ = Diagnostic.set 0;

    fun diagnostic (level, output_function) =
      Diagnostic.output level
      (fn verbosity => "Recompile " :: (output_function verbosity))

    fun crash message =
      Info.error' Info.default_options
		  (Info.FAULT, Info.Location.UNKNOWN, "Recompile: " ^ message)

    (* Returns reversed list of imports *)
    fun get_imports_from_stream ((error_info,options), ts, imports) =
	case Lexer.getToken error_info (options, Token.PLAIN_STATE, ts) of
	  Lexer.Token.RESERVED Lexer.Token.REQUIRE =>
	    (case Lexer.getToken error_info (options, Token.PLAIN_STATE, ts) of
	       Lexer.Token.STRING filename =>
	         (case Lexer.getToken
			 error_info
			 (options, Token.PLAIN_STATE, ts)
	          of Lexer.Token.RESERVED Lexer.Token.SEMICOLON =>
		    ()
	          |  _ =>
		    Info.error' error_info
				 (Info.RECOVERABLE,
				  Lexer.locate ts,
				  "missing `;' after `require'");
		  get_imports_from_stream
		    ((error_info,options), ts,
		     ModuleId.from_require_string (filename, Lexer.locate ts) ::
		       imports))
	     | _ =>
		 Info.error' error_info
			     (Info.FATAL,
			      Lexer.locate ts,
		              "missing string after `require'"))
	| _ => imports

    (* Returns reversed list of imports *)
    fun get_imports (error_info,options) filename =
      let
	val stream = open_in filename
        val ts = Lexer.mkFileTokenStream (stream, filename)
	val imports = get_imports_from_stream ((error_info,options), ts, [])
      in
	close_in stream;
	imports
      end handle Io _ => []

    fun requires_in_done_list([], _) = false
      | requires_in_done_list((x, _, _) :: xs, done) =
	case NewMap.tryApply'(done, ModuleId.string x) of
	  MLWorks.Option.NONE => requires_in_done_list(xs, done)
	| _ => true

    exception missing_module of Info.Location.T * ModuleId.ModuleId

    (* Search for both .sml and .mo files.  Either or both may exist. *)
    fun find_module
	  (location, error_info, pervasive, mod_path,
	   sml_cache, mo_cache, sub_module_id) =
      (diagnostic (2, fn _ => ["find_module called on ",
		  	       ModuleId.string sub_module_id]);
       if pervasive then
	 let
	   val module = Module.MODULE (Io.get_pervasive_dir(), sub_module_id)
	   val sml_str = Module.sml_name module
	   val mo_str = Module.mo_name module
	   (* No need to check caches in pervasive case -- there aren't
	      enough pervasive files to make it worth the effort. *)
	   val result =
	     (case Os.mtime sml_str of
		Os.EXISTS time =>
		  (MLWorks.Option.SOME(sml_str, module, time), sml_cache)
	      | Os.NOT_EXIST => (MLWorks.Option.NONE, sml_cache),
		  case Os.mtime mo_str of
		    Os.EXISTS time =>
		      (MLWorks.Option.SOME(mo_str, module, time), mo_cache)
		  | Os.NOT_EXIST => (MLWorks.Option.NONE, mo_cache)
		      )
	 in
	   case result of
	     ((MLWorks.Option.NONE, _), (MLWorks.Option.NONE, _)) =>
(*	       Info.error'
	       error_info
	       (Info.FATAL, location,
		implode ["can't find module `",
			 ModuleId.string sub_module_id, "' in pervasive directory"])
*)
	       raise missing_module(location, sub_module_id)
	   | _ => (sub_module_id, result)
	 end
         handle Io.NotSet _ =>
           Info.error'
             error_info
             (Info.FATAL, location, "Pervasive directory not set")
       else
         let
	   val module_id = ModuleId.add_path (mod_path, sub_module_id)
	   val find_sml_result as (option, _) = Module.find_sml (module_id, sml_cache)
	   val module_id = case option of
	     MLWorks.Option.SOME(_, module, _) =>
	       let
		 val module_id = Module.module_id module
	       in
		 diagnostic(2, fn _ =>
			    ["find_module finds source file ",
			     Module.sml_name module,
			     " with module id ",
			     ModuleId.string module_id]);
		 module_id
	       end
	   | _ => module_id
         in
	   case (find_sml_result,
		 Module.find_mo (module_id, mo_cache)) of
	     ((MLWorks.Option.NONE, sml_cache), (MLWorks.Option.NONE, mo_cache)) =>
(*
	       Info.error'
	       error_info
	       (Info.FATAL, location,
		implode ["can't find module `",
			 ModuleId.string sub_module_id, "' on source path"])
*)
	       raise missing_module(location, sub_module_id)
           | x => (module_id, x)
         end)
 
    fun find_mo_time
	  (error_info, pervasive, mod_path, perv_mo_cache, mo_cache,
	   sml_cache, sub_module_id, location) =
      let
	val _ = diagnostic
	  (2, fn _ => ["find_mo_time ", ModuleId.path_string mod_path,
		       " ", ModuleId.string sub_module_id])
	val module_id = ModuleId.add_path (mod_path, sub_module_id)
      in
        if pervasive then
	  case Module.find_pervasive_mo(sub_module_id, perv_mo_cache) of
	    (MLWorks.Option.SOME (_, _, t), perv_mo_cache) => (t, perv_mo_cache,mo_cache)
	  | _ =>
	      Info.error'
	      error_info
	      (Info.FATAL, location, "Can't find pervasive library\n" ^
		"- check MLWORKS_PERVASIVE environment variable or -pervasive_dir argument")
        else
          case Module.find_mo (module_id, mo_cache) of
	    (MLWorks.Option.SOME (_, _, t), mo_cache) => (t, perv_mo_cache,mo_cache)
          | (MLWorks.Option.NONE, mo_cache) =>
	      (* Ok, try to get the sml file name *)
	      (* find_module should have objected if it didn't exist *)
	      (* Then use the module_id from that *)
	      let
		val find_sml_result as (option, _) = Module.find_sml (module_id, sml_cache)
		in
		  case option of
		    MLWorks.Option.SOME(_, module, _) =>
		      let
			val module_id = Module.module_id module
			val _ =
			  diagnostic(2, fn _ =>
				     ["find_mo_time finds source file with module id ",
				      ModuleId.string module_id])
		      in
			case Module.find_mo (module_id, mo_cache) of
			  (MLWorks.Option.SOME (_, _, t), mo_cache) =>
			    (t, perv_mo_cache,mo_cache)
			| _ =>
			    Info.error'
			    error_info
			    (Info.FATAL, location,
			     implode ["Can't find .mo file `",
				      ModuleId.string sub_module_id, "'"])
		      end
		  | _ =>
		      Crash.impossible"find_mo_time: can't find .mo file"
	      end
      end

    (* recompile' arguments:
	 cache:
		A cache of the results of Encapsulate.input_info,
		used by TopLevel.compile_file'.  We should probably use
		it here too.
	 module_id:
		The name of the module that we are about to recompile.
	 sml_cache, perv_mo_cache, mo_cache:
		Maps of module_ids to file names and modification times.
		sml_cache is for .sml files, mo_cache is for .mo files, and
		perv_mo_cache is for pervasive .mo files.
	 done:
		Lists files that have been compiled in this recompilation,
		for reporting in check_dependencies mode.
	 up_to_date:
		A map of module names that have been checked in this
		recompilation.
	 pervasive:
		True if we are compiling the pervasive library.
     *)
    fun recompile'
      error_info
      (options as Options.OPTIONS{compiler_options =
				  Options.COMPILEROPTIONS{no_execute, ...}, ...})
      (cache, module_id, sml_cache, perv_mo_cache, mo_cache,
       done, up_to_date, pervasive) =

      let
        (* Returns reversed list of module imports *)
	fun find_module_list(_, [], _, result) = result
	  | find_module_list
	      (location, list as (sub_module_id :: rest), path,
	       (acc, sml_cache, mo_cache)) =
	    let
	      val (module_id, ((sml_info, sml_cache), (mo_info, mo_cache))) =
		find_module (location, error_info, pervasive, path,
			     sml_cache, mo_cache, sub_module_id)
	    in
	      find_module_list
		(location, rest, path,
		 ((module_id, sml_info, mo_info) :: acc, sml_cache, mo_cache))
	    end

	(* Recompile'' returns a flag that indicates whether any recompilation
	   was done, and updated cache information. *)
        fun recompile''(cache, sml_cache, perv_mo_cache, mo_cache,
			[], done, up_to_date, doing) =

	    (false,
	     (cache, sml_cache, perv_mo_cache, mo_cache, done, up_to_date))
	| recompile''
	    (cache, sml_cache, perv_mo_cache, mo_cache,
	     (module_id, sml_info, mo_info) :: rest, done, up_to_date, doing) =
	    (* These module ids are proper full module_ids *)
	  let
	    val module_str = ModuleId.string module_id

	    val _ = diagnostic
	      (1, fn _ => ["recompile ",
			   MLWorks.Integer.makestring (Lists.length doing),
			   " ", module_str]);

	    (* first define some local functions *)

	    exception bad_require of string

	    fun find_imports (location, import_names) =
	      let
		val current_path = ModuleId.path module_id

		val (import_list, sml_cache', mo_cache') =
		  find_module_list
		    (location, import_names,
		     current_path, ([], sml_cache, mo_cache))
	      in
		(import_list, sml_cache', mo_cache')
	      end

	    fun read_requires sml_file =
	      let
		val filename = Module.sml_name sml_file

		val imports =
		  get_imports (error_info,options) filename
	      in
		find_imports (Info.Location.FILE filename, imports)
	      end
	    handle missing_module(loc, id) =>
	      Info.error'
	      error_info
	      (Info.FATAL, loc,
	       implode ["can't find module `", ModuleId.string id, "'"])


	    fun read_subs (filename, subs) =
	      let
		fun req_name {mod_name, req_name, time} =
		  case ModuleId.from_string' req_name of
		    MLWorks.Option.SOME s => s
		  | _ => raise bad_require req_name

		(* If we are not compiling the pervasive files, then the
		   first entry in the consistency info is the pervasive
		   library. *)
		val subs =
		  if pervasive then
		    subs
		  else
		    case subs of
		      [] =>
		        crash
			  "No entry for pervasive library in consistency info"
		    | (_ :: l) => l

		(* get_imports expects to receive the list of names in
		   reverse order, because that's what read_requires
		   returns.  So we reverse the list of subs here. *)
		val imports = rev (map req_name subs)
	      in
		find_imports (Info.Location.FILE filename, imports)
	      end

	    (* function to check that a module is up to date with its
	       submodules.  The first submodule is the pervasive library.  *)
	    fun check_consistency (_, [], false, perv_mo_cache, mo_cache) =
	      (diagnostic
	       (2, fn _ =>
		[module_str, " is up to date wrt required files"]);
	       (true, perv_mo_cache, mo_cache))
	      | check_consistency (_, [], true, perv_mo_cache, mo_cache) =
		if pervasive then
		  (true, perv_mo_cache, mo_cache)
		else
		  Crash.impossible
		  "Attempt to compile pervasive module in non-pervasive mode"
	      | check_consistency
		(filename,
		 {mod_name=sub_name, req_name=req_name, time=sub_stamp}::rest,
		 first, perv_mo_cache, mo_cache) =
		case ModuleId.from_string' req_name of
		  MLWorks.Option.SOME sub_module_id =>
		    let
		      val perv = first orelse pervasive
		      val (sub_time, perv_mo_cache, mo_cache) =
			find_mo_time
			(error_info, perv, ModuleId.path module_id, perv_mo_cache,
			 mo_cache, sml_cache, sub_module_id, Info.Location.FILE filename)
		    in
		      if sub_time = sub_stamp then
			check_consistency
			(filename, rest, false, perv_mo_cache, mo_cache)
		      else
			(diagnostic
			 (2, fn _ =>
			  [module_str, " is out of date wrt ", req_name]);
			 (false, perv_mo_cache, mo_cache))
		    end
		| _ =>
		    (Info.error
		     error_info
		     (Info.WARNING, Info.Location.FILE filename,
		      "invalid module name " ^ req_name ^
		      " -- treating as out of date");
		     (false, perv_mo_cache, mo_cache))

	    (* If we take dependency information from a .mo file, we get
	       timestamps as well, which we need to check *after* building
	       all the ancestor modules. *)
	    datatype consistency_status =
	      UP_TO_DATE
	    | OUT_OF_DATE
	    | TO_BE_CHECKED of
		string *
		{mod_name: string,
		 req_name: string,
		 time: MLWorks.Time.time} list


	    (* And this is where the story really starts... *)

	    val (consistent, (imports, sml_cache, mo_cache)) =
	      if NewMap.apply_default'(up_to_date, false, module_str) then
		(* Have already recompiled this module *)
		(UP_TO_DATE, ([], sml_cache, mo_cache))
	      else
		if Lists.member(module_str, doing) then
		  (* circular dependency *)
		  Info.error'
		  error_info
		  (Info.FATAL,
		   Info.Location.FILE module_str,
		   implode
		   ("Circular require structure within" ::
		    map (fn x => "\n" ^ x) doing)
		   )
		else
		  case sml_info of
		    MLWorks.Option.NONE =>
		      (* No source file.  We know that the object file exists,
		       because find_module would have complained if it found
		       neither source nor object. *)
		      (diagnostic
		       (2, fn _ => ["Source file for ", module_str,
				    " doesn't exist, assuming up to date"]);
		       (UP_TO_DATE, ([], sml_cache, mo_cache)))
		  | MLWorks.Option.SOME (_, sml_file, source_time) =>
		      case mo_info of
			MLWorks.Option.NONE =>
			  (diagnostic (2, fn _ => ["object file for ", module_str,
						   " doesn't exist"]);
			   (OUT_OF_DATE, read_requires sml_file))
		      | MLWorks.Option.SOME (mo_file, _, mo_time) =>
			  let
			    val mo_name = mo_file
			  in
			    (case Encapsulate.input_info mo_name of
			       {consistency = [], ...} =>
				 crash ("missing consistency info in " ^ mo_name)
			       | {consistency = ({time=source_stamp, ...} :: subs),
				  ...} =>
				 if source_time = source_stamp then
				   (diagnostic
				    (2, fn _ => [MLWorks.Integer.makestring
						 (Lists.length doing),
						 " ", module_str,
						 " is current wrt source"]);
				    let
				      val sub_reqs = read_subs(mo_name, subs)
				    in
				      (TO_BE_CHECKED (mo_name, subs), sub_reqs)
				    end
				  handle bad_require req =>
				    (Info.error
				     error_info
				     (Info.WARNING, Info.Location.FILE mo_name,
				      "invalid module name " ^ req ^
				      " -- treating as out of date");
				     (OUT_OF_DATE, read_requires sml_file))
				    | missing_module(loc, id) =>
					(Info.error
					 error_info
					 (Info.WARNING, loc,
					  implode ["can't find module `",
						   ModuleId.string id,
						   "' -- treating as out of date"]);
					 (OUT_OF_DATE, read_requires sml_file)))
				 else
				   (diagnostic
				    (2, fn _ => [MLWorks.Integer.makestring
						 (Lists.length doing),
						 " ", module_str,
						 " is out of date wrt source"]);
				    (* Can't trust the list of requires in the
				     .mo file *)
				    (OUT_OF_DATE,
				     read_requires sml_file)))
			       handle Encapsulate.BadInput s =>
				 (Info.error
				  error_info
				  (Info.WARNING, Info.Location.FILE mo_name,
				   s ^ " -- treating as out of date");
				  (OUT_OF_DATE, read_requires sml_file))
			  end

	     (* Now recompile the imports *)

	     val (consistent,
		  (cache, sml_cache, perv_mo_cache, mo_cache,
		   done, up_to_date)) =
	       case recompile''
		      (cache, sml_cache, perv_mo_cache, mo_cache,
		       imports, done, up_to_date, module_str :: doing) of
		      (true, x) => (OUT_OF_DATE, x)
		    | (false, x) => (consistent, x)

	     (* If everything so far has been consistent, we just have to
		check that the time stamps in the .mo file match the actual
		modification times of the import files. *)
	     val (consistent_flag, perv_mo_cache, mo_cache) =
	       case consistent of
		 OUT_OF_DATE => (false, perv_mo_cache, mo_cache)
	       | UP_TO_DATE => (true, perv_mo_cache, mo_cache)
	       | TO_BE_CHECKED (mo_file, consistency_info) =>
		   if no_execute
		     andalso requires_in_done_list (imports, done) then
		     (false, perv_mo_cache, mo_cache)
		   else
		     check_consistency
		     (mo_file, consistency_info,
		      true, perv_mo_cache, mo_cache)

	     val _ = diagnostic(2, fn _ => ["adding ", module_str, " to up_to_date"])
	     val up_to_date = NewMap.define (up_to_date, module_str, true)
	   in
             (* Recompile this module if necessary, and continue with the
 	        rest of the argument list. *)
             if consistent_flag then
               (* Deal with the rest of the list, this one proved ok *)
               recompile''
                 (cache, sml_cache, perv_mo_cache, mo_cache,
                  rest, done, up_to_date, doing)
             else
               case sml_info of
		 MLWorks.Option.NONE =>
		   Crash.impossible "No sml file to recompile!"
               | MLWorks.Option.SOME (_, sml_file, _) =>
		   let
		     val (new_cache, new_perv_mo_cache, new_mo_cache) =
		       if no_execute then
			 (cache, perv_mo_cache, mo_cache)
		       else
			 TopLevel.compile_file'
                         error_info
                         (options, cache, sml_cache, perv_mo_cache, mo_cache,
		          sml_file, pervasive)

		     val new_mo_cache =
		       if no_execute then
			 new_mo_cache
		       else
			 (* mo files generated by a compilation are put in the
                          same place as the sml files. *)
			 (* Not necessarily they aren't. Depends on object_path *)
			 let
			   val mo_str = Module.mo_name sml_file
			 in
			   case Os.mtime mo_str of
			     Os.NOT_EXIST =>
			       (* Presumably the compilation has reported an error,
				so we'll just return the old value for form. *)
			       new_mo_cache
			   | Os.EXISTS new_time =>
			       Module.update_cache
			       (new_mo_cache, module_id, (mo_str, sml_file, new_time))
			 end
		   in
		     (true,
		      #2 (recompile''
                          (new_cache, sml_cache, new_perv_mo_cache,
		           new_mo_cache, rest,
		           NewMap.define (done, module_str, true),
                           up_to_date, doing)))
		   end
	  end


	(* Now calculate the full module names of all to be recompiled *)
	val (module_id_list, sml_cache, mo_cache) =
	  find_module_list
	    (Info.Location.UNKNOWN, [module_id], ModuleId.empty_path,
	     ([], sml_cache, mo_cache))
	    handle missing_module(loc, id) =>
	      Info.error'
	      error_info
	      (Info.FATAL, loc,
	       implode["can't find module `",
		       ModuleId.string id, "' on source path"])
      in
	#2 (recompile''
	    (cache, sml_cache, perv_mo_cache, mo_cache,
	     module_id_list, done, up_to_date, []))
      end

    val empty_map = NewMap.empty (String.<,op= : string * string -> bool)

    fun print_dependencies done =
      if NewMap.is_empty  done
        then Print.print "No files to recompile\n"
      else
        (Print.print"Files to recompile:-\n";
         NewMap.iterate
         (fn (name, _) => Print.print(name ^ "\n"))
         done)

    fun recompile_modules
          error_info
          (options as Options.OPTIONS
	     {compiler_options = Options.COMPILEROPTIONS{no_execute, ...}, ...})
          module_names =
      let
	val (_, _, _, _, done, _) =
	  Lists.reducel
	    (fn ((cache, sml_cache, perv_mo_cache, mo_cache, done, up_to_date),
		 module_name) =>
	       recompile'
	         error_info
	         options
	         (cache,
		  ModuleId.from_string (module_name, Info.Location.UNKNOWN),
		  sml_cache, perv_mo_cache, mo_cache, done, up_to_date, false))
	    ((TopLevel.empty_cache, Module.empty_cache, Module.empty_cache, 
	      Module.empty_cache, empty_map, empty_map),
	     module_names)
      in
	if no_execute 
          then print_dependencies done
	else Print.print"Up to date\n"
      end

    fun recompile_files
          error_info
          (options as Options.OPTIONS
	     {compiler_options = Options.COMPILEROPTIONS{no_execute, ...}, ...})
          filenames =
      let
	val modules =
	  map (fn s => Module.find_file (s, Info.Location.UNKNOWN)) filenames
	  handle
	    Module.NoSuchFile s =>
	      Info.error'
	        error_info
	        (Info.FATAL, Info.Location.UNKNOWN, "No such file `" ^ s ^ "'")
      
	val old_source_path = Io.get_source_path ()

        fun recompile_one
	      ((cache, sml_cache, perv_mo_cache, mo_cache, done, up_to_date),
	       (on_path, module)) =
          let
            val _ =
              if not on_path then
                (output
                   (std_out,
                    "Extending source path with directory "
                    ^ Module.module_dir module
                    ^ " for compilation of module "
                    ^ ModuleId.string (Module.module_id module)
                    ^ "\n");
                 Io.set_source_path
                  (Module.module_dir module :: old_source_path))
              else
                ();
  
            val result =
	      recompile'
	        error_info
	        options
	        (cache, Module.module_id module, sml_cache, perv_mo_cache,
 	         mo_cache, done, up_to_date, false)
  
            val _ =
              if not on_path then
                Io.set_source_path old_source_path
              else
                ()
          in
            result
          end
          handle
            x => (Io.set_source_path old_source_path; raise x)

	val (_, _, _, _, done, _) =
	  Lists.reducel
	    recompile_one
	    ((TopLevel.empty_cache, Module.empty_cache, Module.empty_cache, 
	      Module.empty_cache, empty_map, empty_map),
	     modules)
	  handle
	    x => (Io.set_source_path old_source_path; raise x)
      in
	if no_execute 
          then print_dependencies done
	else Print.print"Up to date\n"
      end

    fun recompile_pervasive 
          error_info
          (options as Options.OPTIONS
	     {compiler_options =
	      Options.COMPILEROPTIONS{no_execute, ...}, ...}) =
      let
	val (_, _, _, _, done, _) =
	  recompile'
	    error_info
	    options
	    (TopLevel.empty_cache,
	     ModuleId.from_string
	       (Io.pervasive_library_name, Info.Location.UNKNOWN),
	     Module.empty_cache, Module.empty_cache,
	     Module.empty_cache, empty_map, empty_map, true)
      in
	if no_execute 
          then print_dependencies done
	else Print.print"Up to date\n"
      end
  end
@


1.71
log
@Modify find_mo_time to atempt to get the true module name
in the case where the .mo file is not found. Remove some
superfluous parent stuff
@
text
@d4 5
d30 1
a30 1
(it is the same as Lists.length (doing).
d139 1
a139 1
 ModuleId.from_string now takes a location argument.
d376 2
d404 1
a404 1
	       Info.error'
d409 2
d438 1
d444 2
d564 2
d587 6
d597 3
a599 2
		  ModuleId.from_string
		    (req_name, Info.Location.FILE filename)
d639 24
a662 19
		let
		  val sub_module_id =
		    ModuleId.from_string
		    (req_name, Info.Location.FILE filename)

		  val perv = first orelse pervasive
  
		  val (sub_time, perv_mo_cache, mo_cache) =
		    find_mo_time
		    (error_info, perv, ModuleId.path module_id, perv_mo_cache,
		     mo_cache, sml_cache, sub_module_id, Info.Location.FILE filename)
		in
		  if sub_time = sub_stamp then
		    check_consistency
		    (filename, rest, false, perv_mo_cache, mo_cache)
		  else
		    (diagnostic
		     (2, fn _ =>
		      [module_str, " is out of date wrt ", req_name]);
a663 1
		end
d713 1
a713 1
			    val mo_name = (*Module.mo_name (*mo_file*)sml_file*)mo_file
d726 20
a745 2
				    (TO_BE_CHECKED (mo_name, subs),
				     read_subs (mo_name, subs)))
d851 6
d859 2
a860 2
	      (cache, sml_cache, perv_mo_cache, mo_cache,
	       module_id_list, done, up_to_date, []))
@


1.70
log
@Ensure error reports are made where pervasive files are missing
@
text
@d4 3
d411 14
d426 1
a426 1
	   case (Module.find_sml (module_id, sml_cache),
d438 2
a439 2
	  (error_info, pervasive, mod_path, perv_mo_cache,mo_cache,
	   sub_module_id, location) =
a440 1
	val module_id = ModuleId.add_path (mod_path, sub_module_id)
d444 1
d458 28
a485 9
	      find_mo_time (error_info, pervasive, ModuleId.parent mod_path,
			    perv_mo_cache,mo_cache, sub_module_id, location)
	      handle
              ModuleId.NoParent =>
                Info.error'
		error_info
		(Info.FATAL, location,
		 implode ["Can't find .mo file `",
			  ModuleId.string sub_module_id, "'"])
d604 9
a612 6
	      (true, perv_mo_cache, mo_cache)
	    |   check_consistency (_, [], true, perv_mo_cache, mo_cache) =
	      if pervasive then
	        (true, perv_mo_cache, mo_cache)
	      else
	        Crash.impossible
d614 7
a620 7
	    |   check_consistency
	          (filename,
		   {mod_name=sub_name, req_name=req_name, time=sub_stamp}::rest,
		   first, perv_mo_cache, mo_cache) =
	      let
	        val sub_module_id =
		  ModuleId.from_string
d623 1
a623 1
		val perv = first orelse pervasive
d625 2
a626 2
		val (sub_time, perv_mo_cache, mo_cache) =
		  find_mo_time
d628 4
a631 4
		     mo_cache, sub_module_id, Info.Location.FILE filename)
	      in
		if sub_time = sub_stamp then
		  check_consistency
d633 2
a634 2
		else
		  (diagnostic
d636 3
a638 3
			   [module_str, " is out of date wrt ", req_name]);
		   (false, perv_mo_cache, mo_cache))
	      end
d728 3
a730 3
		       imports, done, up_to_date, module_str :: doing)
	       of (true, x) => (OUT_OF_DATE, x)
	       |  (false, x) => (consistent, x)
d736 9
a744 9
	       case consistent
	       of OUT_OF_DATE => (false, perv_mo_cache, mo_cache)
	       |  UP_TO_DATE => (true, perv_mo_cache, mo_cache)
	       |  TO_BE_CHECKED (mo_file, consistency_info) =>
                 if no_execute
		    andalso requires_in_done_list (imports, done) then
                   (false, perv_mo_cache, mo_cache)
	         else
	           check_consistency
d748 1
d770 1
a770 1
                         (options, cache, perv_mo_cache, mo_cache,
@


1.69
log
@Module naming improvements
@
text
@d4 3
a378 1
	 in
d381 19
a399 10
	   (sub_module_id,
	    (case Os.mtime sml_str of
	       Os.EXISTS time =>
		 (MLWorks.Option.SOME(sml_str, module, time), sml_cache)
	     | Os.NOT_EXIST => (MLWorks.Option.NONE, sml_cache),
		 case Os.mtime mo_str of
		   Os.EXISTS time =>
		     (MLWorks.Option.SOME(mo_str, module, time), mo_cache)
		 | Os.NOT_EXIST => (MLWorks.Option.NONE, mo_cache)
		     ))
d412 5
a416 11
(*	       (find_module
	        (location, error_info, pervasive, ModuleId.parent mod_path,
		 sml_cache, mo_cache, sub_module_id)
	        handle
	        ModuleId.NoParent =>
*)
		  Info.error'
		  error_info
		  (Info.FATAL, location,
		    implode ["can't find module `",
			    ModuleId.string sub_module_id, "' on source path"])
@


1.68
log
@Improving check dependencies message
@
text
@d4 3
d374 2
d380 1
a380 1
	    (case Os.mtime (Module.sml_name module) of
d382 1
a382 1
		 (MLWorks.Option.SOME (module, time), sml_cache)
d384 5
a388 4
	     case Os.mtime (Module.mo_name module) of
	       Os.EXISTS time =>
		 (MLWorks.Option.SOME (module, time), mo_cache)
	     | Os.NOT_EXIST => (MLWorks.Option.NONE, mo_cache)))
d401 1
a401 1
	       (find_module
d406 1
d411 1
a411 1
			    ModuleId.string sub_module_id, "' on source path"]))
d426 1
a426 1
	    (MLWorks.Option.SOME (_, t), perv_mo_cache) => (t, perv_mo_cache,mo_cache)
d434 1
a434 1
	    (MLWorks.Option.SOME (_, t), mo_cache) => (t, perv_mo_cache,mo_cache)
d500 1
d615 4
a618 3
	      else if Lists.member(module_str, doing) then
	        (* circular dependency *)
		Info.error'
d620 56
a675 57
		    (Info.FATAL,
		     Info.Location.FILE module_str,
		     implode
		       ("Circular require structure within" ::
		        map (fn x => "\n" ^ x) doing)
		       )
	      else
                case sml_info
	        of MLWorks.Option.NONE =>
		  (* No source file.  We know that the object file exists,
		     because find_module would have complained if it found
		     neither source nor object. *)
                  (diagnostic
                     (2, fn _ => ["Source file for ", module_str,
                                  " doesn't exist, assuming up to date"]);
		   (UP_TO_DATE, ([], sml_cache, mo_cache)))
                |  MLWorks.Option.SOME (sml_file, source_time) =>
                  case mo_info
	          of MLWorks.Option.NONE =>
                    (diagnostic (2, fn _ => ["object file for ", module_str,
                                             " doesn't exist"]);
		   (OUT_OF_DATE, read_requires sml_file))
                  |  MLWorks.Option.SOME (mo_file, mo_time) =>
                    let
                      val mo_name = Module.mo_name mo_file
                    in
                      (case Encapsulate.input_info mo_name
                       of {consistency = [], ...} =>
                         crash ("missing consistency info in " ^ mo_name)
 		       |  {consistency = ({time=source_stamp, ...} :: subs),
		           ...} =>
                         if source_time = source_stamp then
                           (diagnostic
                              (2, fn _ => [MLWorks.Integer.makestring
					     (Lists.length doing),
                                           " ", module_str,
                                           " is current wrt source"]);
			   (TO_BE_CHECKED (mo_name, subs),
			    read_subs (mo_name, subs)))
                         else
                           (diagnostic
                              (2, fn _ => [MLWorks.Integer.makestring
					     (Lists.length doing),
                                           " ", module_str,
                                           " is out of date wrt source"]);
			    (* Can't trust the list of requires in the
			       .mo file *)
			    (OUT_OF_DATE,
			     read_requires sml_file)))
                      handle Encapsulate.BadInput s =>
                        (Info.error
                           error_info
                           (Info.WARNING, Info.Location.FILE mo_name,
                            s ^ " -- treating as out of date");
                         (OUT_OF_DATE, read_requires sml_file))
		    end

d714 10
a723 10
               case sml_info
 	       of MLWorks.Option.NONE =>
                 Crash.impossible "No sml file to recompile!"
               |  MLWorks.Option.SOME (sml_file, _) =>
                 let
                   val (new_cache, new_perv_mo_cache, new_mo_cache) =
                     if no_execute then
                       (cache, perv_mo_cache, mo_cache)
                     else
                       TopLevel.compile_file'
d728 5
a732 5
                   val new_mo_cache =
                     if no_execute then
                       new_mo_cache
                     else
                       (* mo files generated by a compilation are put in the
d734 16
a749 11
                       case Os.mtime (Module.mo_name sml_file)
		       of Os.NOT_EXIST =>
                           (* Presumably the compilation has reported an error,
                              so we'll just return the old value for form. *)
                         new_mo_cache
                       |  Os.EXISTS new_time =>
                         Module.update_cache
                           (new_mo_cache, module_id, (sml_file, new_time))
                 in
                   (true,
		    #2 (recompile''
d754 2
a755 2
                 end
           end
@


1.67
log
@Get dependencies from sml file when decapsulating fails
@
text
@d4 3
d758 9
d787 3
a789 7
	if no_execute then
	  (Print.print"Files to recompile:-\n";
	   NewMap.iterate
	   (fn (name, _) => Print.print(name ^ "\n"))
	   done)
	else
	  Print.print"Up to date\n"
d853 3
a855 7
	if no_execute then
	  (Print.print"Files to recompile:-\n";
	   NewMap.iterate
	   (fn (name, _) => Print.print(name ^ "\n"))
	   done)
	else
	  Print.print"Up to date\n"
d874 3
a876 7
	if no_execute then
	  (Print.print"Files to recompile:-\n";
	   NewMap.iterate
	   (fn (name, _) => Print.print(name ^ "\n"))
	   done)
	else
	  Print.print"Up to date\n"
@


1.66
log
@Change to Lexer structure
@
text
@d4 3
d662 1
a662 1
                         (OUT_OF_DATE, ([], perv_mo_cache, mo_cache)))
@


1.65
log
@Added a diagnostic when extending the source path.
@
text
@d4 3
d282 1
a282 1
   sharing type Lexer.options = TopLevel.Options.options
@


1.64
log
@Removed modpath and level arguments from recompile'', as they were
only used in debugging statements, and level can be computed
(it is the same as Lists.length (doing).
@
text
@d4 5
d794 36
d832 1
a832 12
	    (fn ((cache, sml_cache, perv_mo_cache, mo_cache, done, up_to_date),
		 (on_path, module)) =>
	       (if not on_path then
		  Io.set_source_path
		    (Module.module_dir module :: old_source_path)
		else
		  ();
	        recompile'
	          error_info
	          options
	          (cache, Module.module_id module, sml_cache, perv_mo_cache,mo_cache,
                   done, up_to_date, false)))
a837 2

	val _ = Io.set_source_path old_source_path
@


1.63
log
@Replaced Option structure with references to MLWorks.Option.
Removed obsolete sharing constraint.
@
text
@d4 4
d444 1
a444 1
		True is we are compiling the pervasive library.
d471 2
a472 2
        fun recompile''(_, cache, sml_cache, perv_mo_cache, mo_cache,
			_, [], done, up_to_date, doing) =
d477 1
a477 1
	    (level, cache, sml_cache, perv_mo_cache, mo_cache, mod_path,
d484 1
a484 2
			   MLWorks.Integer.makestring level,
			   " ", ModuleId.path_string mod_path,
d630 2
a631 2
                              (2, fn _ => [MLWorks.Integer.makestring level,
                                           " ", ModuleId.path_string mod_path,
d638 2
a639 2
                              (2, fn _ => [MLWorks.Integer.makestring level,
                                           " ", ModuleId.path_string mod_path,
d661 2
a662 3
		      (level+1, cache, sml_cache, perv_mo_cache, mo_cache,
		       ModuleId.path module_id, imports, done,
		       up_to_date, module_str :: doing)
d689 2
a690 2
                 (level, cache, sml_cache, perv_mo_cache, mo_cache,
                  mod_path, rest, done, up_to_date, doing)
d723 2
a724 2
                          (level, new_cache, sml_cache, new_perv_mo_cache,
		           new_mo_cache, mod_path, rest,
d738 2
a739 2
	      (0, cache, sml_cache, perv_mo_cache, mo_cache,
	       ModuleId.empty_path, module_id_list, done, up_to_date, []))
@


1.62
log
@Added location to error message when a module is not found.
@
text
@d4 3
a276 1
   sharing type Io.Directory = Module.Directory
d359 2
a360 2
		 (Module.Option.PRESENT (module, time), sml_cache)
	     | Os.NOT_EXIST => (Module.Option.ABSENT, sml_cache),
d363 2
a364 2
		 (Module.Option.PRESENT (module, time), mo_cache)
	     | Os.NOT_EXIST => (Module.Option.ABSENT, mo_cache)))
d376 1
a376 1
	     ((Module.Option.ABSENT, sml_cache), (Module.Option.ABSENT, mo_cache)) =>
d401 1
a401 1
	    (Module.Option.PRESENT (_, t), perv_mo_cache) => (t, perv_mo_cache,mo_cache)
d409 2
a410 2
	    (Module.Option.PRESENT (_, t), mo_cache) => (t, perv_mo_cache,mo_cache)
          | (Module.Option.ABSENT, mo_cache) =>
d511 1
a511 1
		  ModuleId.from_require_string
d551 1
a551 1
		  ModuleId.from_require_string
d602 1
a602 1
	        of Module.Option.ABSENT =>
d610 1
a610 1
                |  Module.Option.PRESENT (sml_file, source_time) =>
d612 1
a612 1
	          of Module.Option.ABSENT =>
d616 1
a616 1
                  |  Module.Option.PRESENT (mo_file, mo_time) =>
d691 1
a691 1
 	       of Module.Option.ABSENT =>
d693 1
a693 1
               |  Module.Option.PRESENT (sml_file, _) =>
d829 1
a829 1
	     ModuleId.from_require_string
@


1.61
log
@Ensured that imports are traversed in the intuitive order when they
are read from a .mo file, by reversing them at a key point.
@
text
@d4 4
d344 1
a344 1
	  (error_info, pervasive, mod_path,
d367 1
a367 3
             (Info.FATAL,
              Info.Location.UNKNOWN,
             "Pervasive directory not set")
d376 1
a376 1
	        (error_info, pervasive, ModuleId.parent mod_path,
d382 1
a382 1
		  (Info.FATAL, Info.Location.UNKNOWN,
d425 1
a425 1
	 module_name:
d449 4
a452 3
	fun find_module_list([], _, result) = result
	  | find_module_list(list as (sub_module_id :: rest), path,
			     (acc, sml_cache, mo_cache)) =
d455 1
a455 1
		find_module (error_info, pervasive, path,
d458 3
a460 2
	      find_module_list(rest, path, ((module_id, sml_info, mo_info) :: acc,
					    sml_cache, mo_cache))
d484 1
a484 1
	    fun find_imports import_names =
d490 2
a491 1
		    (import_names, current_path, ([], sml_cache, mo_cache))
d498 2
d501 1
a501 1
		  get_imports (error_info,options) (Module.sml_name sml_file)
d503 1
a503 1
		find_imports imports
d530 1
a530 1
		find_imports imports
d730 2
a731 1
	    ([module_id], ModuleId.empty_path, ([], sml_cache, mo_cache))
@


1.60
log
@Move OS specific stuff into a system link directory
@
text
@d4 3
d348 2
a349 1
	   (* Should check caches here. *)
a504 2
		val imports = map req_name subs
	      in
d508 16
a523 7
		if pervasive then
		  find_imports imports
		else
		  case imports of
		    [] =>
		      crash "No entry for pervasive library in consistency info"
		  | (_ :: l) => find_imports l
@


1.59
log
@Avoided unnecessary lexing, when dependencies can be read from .mo file.
@
text
@d4 3
d236 1
a236 1
require "../make/unix";
d251 1
a251 1
   structure Unix	: UNIX
d347 2
a348 2
	    (case Unix.mtime (Module.sml_name module) of
	       Unix.EXISTS time =>
d350 3
a352 3
	     | Unix.NOT_EXIST => (Module.Option.ABSENT, sml_cache),
	     case Unix.mtime (Module.mo_name module) of
	       Unix.EXISTS time =>
d354 1
a354 1
	     | Unix.NOT_EXIST => (Module.Option.ABSENT, mo_cache)))
d690 2
a691 2
                       case Unix.mtime (Module.mo_name sml_file)
		       of Unix.NOT_EXIST =>
d695 1
a695 1
                       |  Unix.EXISTS new_time =>
@


1.58
log
@Use pervasive Option.option for return values in NewMap
@
text
@d4 3
d276 3
a278 1
    type Module = Module.Module
d411 20
d435 1
a435 1
      (cache, module_name, sml_cache, perv_mo_cache, mo_cache,
a438 3
	val sml_cache_size = ref 0
	val sml_cache_best = ref Module.empty_cache

d452 2
d456 3
a458 1
	    (cache, sml_cache, perv_mo_cache, mo_cache, done, up_to_date)
d460 2
a461 3
	  (level, cache, sml_cache, perv_mo_cache, mo_cache,
	   mod_path,
	   (module_id, sml_info, mo_info) :: rest, done, up_to_date, doing) =
d471 98
a568 2
	    val _ =
	      if Lists.member(module_str, doing) then
d570 7
a576 7
		error_info
		(Info.FATAL,
		 Info.Location.FILE module_str,
		 implode
		 ("Circular require structure within" ::
		  map (fn x => "\n" ^ x) doing)
		 )
d578 126
a703 1
		()
a704 206
	      (* First do all required files *)
	  in
	    case NewMap.tryApply'(up_to_date, module_str) of
	      MLWorks.Option.SOME _ =>
		recompile''
		(level, cache, sml_cache, perv_mo_cache, mo_cache,
		 mod_path, rest,
		 done, up_to_date, doing)
	    (* Do the rest of the list, this one's ok *)
	    | _ =>
		let
		  val imports =
		    case sml_info of
		      Module.Option.PRESENT (sml_file, _) =>
			get_imports (error_info,options)
			(Module.sml_name sml_file)
		    | Module.Option.ABSENT =>
			[]
		  val current_path = ModuleId.path module_id

		  val (import_list, sml_cache', mo_cache) =
		    find_module_list(imports, current_path, ([], sml_cache, mo_cache))
                  (* import_list is now in forwards order again *)
		  val imports_to_do =
		    Lists.filterp
		    (fn (x, _, _) =>
		     not (NewMap.apply_default' (up_to_date, false, ModuleId.string x)))
		    import_list

		  val (cache', sml_cache'', perv_mo_cache, mo_cache, done, up_to_date) =
		    (diagnostic (2, fn _ => "doing imports:" ::
				 (Lists.reducel
				  (fn (list, (module_id, _, _)) =>
				   " " :: ModuleId.string module_id :: list)
				  ([], imports_to_do)));
		     recompile''
		     (level+1, cache, sml_cache', perv_mo_cache, mo_cache,
		      ModuleId.path module_id, imports_to_do, done,
		      up_to_date, module_str :: doing))

		  (* function to check that a module is up to date with its
		   submodules.  The first submodule is the pervasive library.  *)
		  fun check (_, [], false,perv_mo_cache,mo_cache) =
		    (true, perv_mo_cache,mo_cache)
		    | check (_, [], true, perv_mo_cache,mo_cache) =
		      if pervasive then
			(true, perv_mo_cache,mo_cache)
		      else
			Crash.impossible
			"Attempt to compile pervasive module in non-pervasive mode"
		    | check (filename, {mod_name=sub_name, req_name=req_name, time=sub_stamp}::rest, first, perv_mo_cache,mo_cache) =
		      let
			val sub_module_id =
			  ModuleId.from_require_string
			  (req_name, Info.Location.FILE filename)

			val perv = first orelse pervasive
			val (sub_time, perv_mo_cache,mo_cache) =
			  find_mo_time
			  (error_info, perv,
			   ModuleId.path module_id,
			   perv_mo_cache,mo_cache,
			   sub_module_id, Info.Location.FILE filename)
		      in
			if sub_time = sub_stamp then
			  check (filename, rest, false, perv_mo_cache,mo_cache)
			else
			  (diagnostic (2, fn _ => [module_str,
						   " is out of date wrt ",
						   req_name]);
			   (false, perv_mo_cache,mo_cache))
		      end

		  val (consistent, perv_mo_cache,mo_cache) =
		    (diagnostic (2, fn _ => [MLWorks.Integer.makestring level,
					     " ", "checking consistency of ",
					     module_str]);

		     case mo_info of
		       Module.Option.ABSENT =>
			 (diagnostic (2, fn _ => ["object file for ", module_str,
						  " doesn't exist"]);
			  (false, perv_mo_cache,mo_cache))
		     | Module.Option.PRESENT (mo_file, mo_time) =>
			 if NewMap.apply_default'(up_to_date, false, module_str) then
			   (diagnostic
			    (2, fn _ => [module_str, " cached as up to date"]);
			    (true, perv_mo_cache,mo_cache))
			 else
			   case sml_info of
			     Module.Option.ABSENT =>
			       (diagnostic
				(2, fn _ => ["Source file for ", module_str,
					     " doesn't exist, assuming up to date"]);
				(true, perv_mo_cache,mo_cache))
			   | Module.Option.PRESENT (sml_file, source_time) =>
			       let
				 val mo_name = Module.mo_name mo_file

				 val consistency =
				   MLWorks.Option.SOME (Encapsulate.input_info mo_name)
				   handle Encapsulate.BadInput s =>
				     (Info.error
				      error_info
				      (Info.WARNING, Info.Location.FILE mo_name,
				       s ^ " -- treating as out of date");
				      MLWorks.Option.NONE)
			       in
				 case consistency
				   of MLWorks.Option.NONE => (false,perv_mo_cache,mo_cache)
				 | MLWorks.Option.SOME{consistency, ...} =>
				     let
				       val (source_stamp, subs) =
					 case consistency
					   of [] =>
					     crash ("missing consistency info in " ^
						    mo_name)
					 | {mod_name=_, req_name=_,time=source_stamp} ::
					   subs =>
					     (source_stamp, subs)
				     in
				       if source_time = source_stamp then
					 let
					   val result as (ok, perv_mo_cache,mo_cache) =
					     if requires_in_done_list
					       (import_list,done) then
					       (false,perv_mo_cache,mo_cache)
					     else
					       check(Module.sml_name sml_file,
						     subs, true, perv_mo_cache,mo_cache)
					 in
					   if ok then
					     diagnostic
					     (2,
					      fn _ =>
					      [MLWorks.Integer.makestring level,
					       " ", ModuleId.path_string mod_path,
					       " ", module_str, " is up to date!"])
					   else
					     diagnostic
					     (2,
					      fn _ =>
					      [MLWorks.Integer.makestring level,
					       " ", ModuleId.path_string mod_path,
					       " ", module_str,
					       " is out of date wrt dependencies"]);
					     result
					 end
				       else
					 (diagnostic
					  (2, fn _ =>
					   [MLWorks.Integer.makestring level,
					    " ", ModuleId.path_string mod_path,
					    " ", module_str,
					    " is out of date wrt source"]);
					  (false, perv_mo_cache,mo_cache))
				     end
			       end)

		  val up_to_date = NewMap.define (up_to_date, module_str, true)
		in
		  if consistent then
		    recompile''
		    (level, cache', sml_cache'', perv_mo_cache, mo_cache,
		     mod_path, rest,
		     done, up_to_date, doing)
		  (* Deal with the rest of the list, this one proved ok *)
		  else
		    case sml_info of
		      Module.Option.ABSENT =>
			Crash.impossible "No sml file to recompile!"
		    | Module.Option.PRESENT (sml_file, _) =>
			let
			  val (new_cache, perv_mo_cache,mo_cache) =
			    if no_execute then
			      (cache', perv_mo_cache,mo_cache)
			    else
			      TopLevel.compile_file'
			      error_info
			      (options, cache', perv_mo_cache, mo_cache, sml_file, pervasive)

			  val mo_cache =
			    if no_execute then
			      mo_cache
			    else
			      (* mo files generated by a compilation are put in the
			       same place as the sml files. *)
			      case Unix.mtime (Module.mo_name sml_file) of
				Unix.NOT_EXIST =>
				  (* Presumably the compilation has reported an error,
				   so we'll just return the old value for form. *)
				  mo_cache
			      | Unix.EXISTS new_time =>
				  Module.update_cache
				  (mo_cache, module_id, (sml_file, new_time))
			in
			  recompile''
			  (level, new_cache,
			   sml_cache'', perv_mo_cache, mo_cache,
			   mod_path, rest,
			   NewMap.define (done, module_str, true),
			   up_to_date, doing)
			(* Deal with the rest of the list, this one found to be ok *)
			end
		end
	  end (* of recompile'' *)
d707 1
a707 1
	val (module_id_list, sml_cache', mo_cache) =
d709 1
a709 1
	    ([module_name], ModuleId.empty_path, ([], sml_cache, mo_cache))
d711 3
a713 3
	recompile''
	  (0, cache, sml_cache', perv_mo_cache, mo_cache, ModuleId.empty_path,
	   module_id_list, done, up_to_date, [])
@


1.57
log
@Improved module id caching
@
text
@d4 3
d324 1
a324 1
	  NewMap.NO => requires_in_done_list(xs, done)
d462 1
a462 1
	      NewMap.YES _ =>
d559 1
a559 1
				   NewMap.YES (Encapsulate.input_info mo_name)
d565 1
a565 1
				      NewMap.NO)
d568 2
a569 2
				   of NewMap.NO => (false,perv_mo_cache,mo_cache)
				 | NewMap.YES{consistency, ...} =>
@


1.56
log
@Add original require file names to consistency info.
@
text
@d4 3
d357 1
a357 1
	     ((Module.Option.ABSENT, sml_cache'), (Module.Option.ABSENT, mo_cache')) =>
d360 1
a360 1
		 sml_cache', mo_cache', sub_module_id)
d372 1
a372 1
	  (error_info, pervasive, mod_path, mo_cache,
d381 2
a382 2
	  case Module.find_pervasive_mo(sub_module_id, mo_cache) of
	    (Module.Option.PRESENT (_, t), new_cache) => (t, new_cache)
d390 1
a390 1
	    (Module.Option.PRESENT (_, t), new_cache) => (t, new_cache)
d393 1
a393 1
			    mo_cache, sub_module_id, location)
d407 1
a407 1
      (cache, module_name, sml_cache, mo_cache, perv_mo_cache,
d419 1
a419 1
	      val (module_id, ((sml_info, sml_cache'), (mo_info, mo_cache'))) =
d424 1
a424 1
					    sml_cache', mo_cache'))
d427 1
a427 1
	fun recompile''(_, cache, sml_cache, mo_cache, perv_mo_cache,
d429 1
a429 1
	    (cache, sml_cache, mo_cache, perv_mo_cache, done, up_to_date)
d431 1
a431 1
	  (level, cache, sml_cache, mo_cache, perv_mo_cache,
d461 1
a461 1
		(level, cache, sml_cache, mo_cache, perv_mo_cache,
d476 1
a476 1
		  val (import_list, sml_cache', mo_cache') =
d485 1
a485 1
		  val (cache', sml_cache'', mo_cache'', perv_mo_cache, done, up_to_date) =
d492 1
a492 1
		     (level+1, cache, sml_cache', mo_cache', perv_mo_cache,
d498 3
a500 3
		  fun check (_, [], false, cache) =
		    (true, cache)
		    | check (_, [], true, cache) =
d502 1
a502 1
			(true, cache)
d506 1
a506 1
		    | check (filename, {mod_name=sub_name, req_name=req_name, time=sub_stamp}::rest, first, cache) =
d513 1
a513 1
			val (sub_time, cache') =
d517 1
a517 1
			   if perv then perv_mo_cache else cache,
a518 1
			val cache' = if perv then cache else cache'
d521 1
a521 1
			  check (filename, rest, false, cache')
d526 1
a526 1
			   (false, cache'))
d529 1
a529 1
		  val (consistent, mo_cache''') =
d538 1
a538 1
			  (false, mo_cache''))
d543 1
a543 1
			    (true, mo_cache''))
d550 1
a550 1
				(true, mo_cache''))
d565 1
a565 1
				   of NewMap.NO => (false, mo_cache'')
d579 1
a579 1
					   val result as (ok, _) =
d582 1
a582 1
					       (false, mo_cache'')
d585 1
a585 1
						     subs, true, mo_cache'')
d611 1
a611 1
					  (false, mo_cache''))
d619 1
a619 1
		    (level, cache', sml_cache'', mo_cache''', perv_mo_cache,
d629 1
a629 1
			  val (new_cache, perv_mo_cache) =
d631 1
a631 1
			      (cache', perv_mo_cache)
d635 1
a635 1
			      (options, cache', mo_cache''', perv_mo_cache, sml_file, pervasive)
d637 1
a637 1
			  val new_mo_cache =
d639 1
a639 1
			      mo_cache'''
d647 1
a647 1
				  mo_cache'''
d650 1
a650 1
				  (mo_cache''', module_id, (sml_file, new_time))
d654 1
a654 1
			   sml_cache'', new_mo_cache, perv_mo_cache,
d661 1
a661 1
	  end
d664 1
a664 1
	val (module_id_list, sml_cache', mo_cache') =
d669 1
a669 1
	  (0, cache, sml_cache', mo_cache',  perv_mo_cache, ModuleId.empty_path,
d673 1
a673 1
    val empty_map = NewMap.empty' String.<
d683 1
a683 1
	    (fn ((cache, sml_cache, mo_cache, perv_mo_cache, done, up_to_date),
d690 1
a690 1
		  sml_cache, mo_cache, perv_mo_cache, done, up_to_date, false))
d722 1
a722 1
	    (fn ((cache, sml_cache, mo_cache, perv_mo_cache, done, up_to_date),
d732 2
a733 2
	          (cache, Module.module_id module, sml_cache, mo_cache,
		   perv_mo_cache, done, up_to_date, false)))
@


1.55
log
@Added recompile_module.
@
text
@d4 3
d503 1
a503 1
		    | check (filename, (sub_name, sub_stamp)::rest, first, cache) =
d507 1
a507 1
			  (sub_name, Info.Location.FILE filename)
d523 1
a523 1
						   sub_name]);
d571 2
a572 1
					 | (_, source_stamp) :: subs =>
@


1.54
log
@Module.module_and_path is now Module.find_file, is functional, and is
called on all arguments to compile_file before any compilation is done.
@
text
@d4 4
d264 2
d669 30
a698 1
    fun recompile
@


1.53
log
@Module names have been moved to Module from FileName.
@
text
@d4 3
a263 5
    fun diagnostic_fn (level, output_function) =
      Diagnostic.output_fn level
      (fn (verbosity, stream) =>
	 (output (stream, "Recompile "); output_function (verbosity, stream)))

d283 1
a283 1
				  "missing ; after require");
d292 1
a292 1
		              "missing string after require"))
d316 39
a354 41
(*
	  (output(std_out, "find_module called on " ^
		  ModuleId.string sub_module_id ^ "\n");
*)	   
      if pervasive then
	let
	  val module = Module.MODULE (Io.get_pervasive_dir(), sub_module_id)
	in
	  (* Should check caches here. *)
	  (sub_module_id,
	   (case Unix.mtime (Module.sml_name module) of
	      Unix.EXISTS time =>
		(Module.Option.PRESENT (module, time), sml_cache)
	    | Unix.NOT_EXIST => (Module.Option.ABSENT, sml_cache),
	    case Unix.mtime (Module.mo_name module) of
	      Unix.EXISTS time =>
		(Module.Option.PRESENT (module, time), mo_cache)
	    | Unix.NOT_EXIST => (Module.Option.ABSENT, mo_cache)))
	end
        handle Io.NotSet _ =>
          Info.error'
            error_info
            (Info.FATAL,
             Info.Location.UNKNOWN,
            "Pervasive directory not set")
      else
        let
	  val module_id = ModuleId.add_path (mod_path, sub_module_id)
        in
	  case (Module.find_sml (module_id, sml_cache),
		Module.find_mo (module_id, mo_cache)) of
	    ((Module.Option.ABSENT, sml_cache'), (Module.Option.ABSENT, mo_cache')) =>
	      (find_module
	       (error_info, pervasive, ModuleId.parent mod_path,
		sml_cache', mo_cache', sub_module_id)
	       handle
	       ModuleId.NoParent =>
		 Info.error'
		 error_info
		 (Info.FATAL, Info.Location.UNKNOWN,
		  implode ["can't find module `",
d356 3
a358 3
          | x => (module_id, x)
        end

a400 2
	val utils_lists = ModuleId.from_string("utils.lists", Info.Location.UNKNOWN)
	val found_utils = ref false
d669 10
d682 11
a692 23
		 filename) =>
	       let
		 val (module, old_source_path) =
		   Module.module_and_path (filename, Info.Location.UNKNOWN)

		 val result =
	           recompile'
	             error_info
	             options
	             (cache, Module.module_id module, sml_cache, mo_cache,
		      perv_mo_cache, done, up_to_date, false)
	       in
	         Io.set_source_path old_source_path;
		 result
	       end
	       handle
		 Module.NoSuchFile s =>
		   (Info.error
		      error_info
		      (Info.RECOVERABLE, Info.Location.UNKNOWN,
		       "No such file: " ^ s);
		    (cache, sml_cache, mo_cache, perv_mo_cache,
		     done, up_to_date)))
d694 6
a699 1
	      Module.empty_cache, empty_map, empty_map), filenames)
@


1.52
log
@Removed call to set_pervasive_dir
@
text
@d4 3
d212 1
a212 1
require "../utils/filename";
d228 1
a228 1
   structure FileName	: FILENAME
d242 1
a242 1
   sharing type ModuleId.ModuleId = Io.ModuleId = FileName.ModuleId
d244 4
a247 4
   sharing type ModuleId.Location = Lexer.Info.Location.T
   sharing type Io.Directory = FileName.Directory
   sharing type TopLevel.FileNameCache = FileName.Cache
   sharing type TopLevel.Module = FileName.Module
d288 1
a288 1
		     ModuleId.from_unix_string (filename, Lexer.locate ts) ::
d324 1
a324 1
	  val module = FileName.MODULE (Io.get_pervasive_dir(), sub_module_id)
d328 1
a328 1
	   (case Unix.mtime (FileName.sml_name module) of
d330 3
a332 3
		(FileName.Option.PRESENT (module, time), sml_cache)
	    | Unix.NOT_EXIST => (FileName.Option.ABSENT, sml_cache),
	    case Unix.mtime (FileName.mo_name module) of
d334 2
a335 2
		(FileName.Option.PRESENT (module, time), mo_cache)
	    | Unix.NOT_EXIST => (FileName.Option.ABSENT, mo_cache)))
d347 3
a349 3
	  case (FileName.find_sml (module_id, sml_cache),
		FileName.find_mo (module_id, mo_cache)) of
	    ((FileName.Option.ABSENT, sml_cache'), (FileName.Option.ABSENT, mo_cache')) =>
d373 2
a374 2
	  case FileName.find_pervasive_mo(sub_module_id, mo_cache) of
	    (FileName.Option.PRESENT (_, t), new_cache) => (t, new_cache)
d381 3
a383 3
          case FileName.find_mo (module_id, mo_cache) of
	    (FileName.Option.PRESENT (_, t), new_cache) => (t, new_cache)
          | (FileName.Option.ABSENT, mo_cache) =>
d399 3
a401 1
      (cache, module_id_list, done, up_to_date, pervasive) =
a402 1

d404 1
a404 1
	val sml_cache_best = ref FileName.empty_cache
d421 1
a421 1
	fun recompile''(_, _, sml_cache, mo_cache, perv_mo_cache,
d423 1
a423 1
	    (done, up_to_date, sml_cache, mo_cache, perv_mo_cache)
d463 1
a463 1
		      FileName.Option.PRESENT (sml_file, _) =>
d465 2
a466 2
			(FileName.sml_name sml_file)
		    | FileName.Option.ABSENT =>
d479 1
a479 1
		  val (done, up_to_date, sml_cache'', mo_cache'', perv_mo_cache) =
d503 1
a503 1
			  ModuleId.from_string
d530 1
a530 1
		       FileName.Option.ABSENT =>
d534 1
a534 1
		     | FileName.Option.PRESENT (mo_file, mo_time) =>
d541 1
a541 1
			     FileName.Option.ABSENT =>
d546 1
a546 1
			   | FileName.Option.PRESENT (sml_file, source_time) =>
d548 1
a548 1
				 val mo_name = FileName.mo_name mo_file
d578 1
a578 1
					       check(FileName.sml_name sml_file,
d613 1
a613 1
		    (level, cache, sml_cache'', mo_cache''', perv_mo_cache,
d619 1
a619 1
		      FileName.Option.ABSENT =>
d621 1
a621 1
		    | FileName.Option.PRESENT (sml_file, _) =>
d625 1
a625 1
			      (cache, perv_mo_cache)
d629 1
a629 1
			      (options, cache, mo_cache''', perv_mo_cache, sml_file, pervasive)
d637 1
a637 1
			      case Unix.mtime (FileName.mo_name sml_file) of
d643 1
a643 1
				  FileName.update_cache
d658 3
a660 3
	val (module_id_list, sml_cache, mo_cache) =
	  find_module_list(rev module_id_list, ModuleId.empty_path,
			   ([], FileName.empty_cache, FileName.empty_cache))
d663 2
a664 2
	(0, cache, sml_cache, mo_cache,  FileName.empty_cache,
	 ModuleId.empty_path, module_id_list, done, up_to_date, [])
d670 4
a673 4
      error_info
      (options as Options.OPTIONS{compiler_options =
				  Options.COMPILEROPTIONS{no_execute, ...}, ...})
      module_names =
d675 28
a702 9
	val (done, _, _, _, _) =
	  recompile'
	    error_info
	    options
	    (TopLevel.empty_cache,
	     map
	       (fn name => ModuleId.from_string (name, Info.Location.UNKNOWN))
	       module_names,
	     empty_map, empty_map, false)
d719 1
a719 1
	val (done, _, _, _, _) =
d724 4
a727 3
	     [ModuleId.from_string
	        (Io.pervasive_library_name, Info.Location.UNKNOWN)],
	     empty_map, empty_map, true)
@


1.51
log
@Changed error message for non-existent file.
@
text
@d4 6
a402 9

	val pervasive_dir =
	  Io.get_pervasive_dir ()
	  handle Io.NotSet _ =>
	    Info.error'
	      error_info
	      (Info.FATAL,
	       Info.Location.UNKNOWN,
	       "Pervasive directory not set")
@


1.50
log
@Renamed Encapsulate.Basistypes to Encapsulate.BasisTypes
@
text
@d4 3
d349 2
a350 2
		  implode ["make called on non-existent file `",
			    ModuleId.string sub_module_id, "'"]))
@


1.49
log
@Change to pervasive time structure.
@
text
@d4 3
d229 1
a229 1
   sharing type Encapsulate.Basistypes.Basis = TopLevel.TypeBasis
@


1.48
log
@Merged in bug fix.
@
text
@d4 3
d508 1
a508 1
			if MLWorks.Time.Real.equal (sub_time, sub_stamp) then
d564 1
a564 2
				       if MLWorks.Time.Real.equal
					 (source_time, source_stamp) then
@


1.47
log
@Merging in bug fixes
@
text
@d4 3
d13 3
a271 14
	     | Lexer.Token.LONGID (l, s) =>
	         (case Lexer.getToken
			 error_info
			 (options, Token.PLAIN_STATE, ts)
	          of Lexer.Token.RESERVED Lexer.Token.SEMICOLON =>
		    ()
	          |  _ =>
		    Info.error' error_info
				 (Info.RECOVERABLE,
				  Lexer.locate ts,
				  "missing ; after require");
		  get_imports_from_stream
		    ((error_info,options), ts,
		     ModuleId.create (l, s, Lexer.locate ts) :: imports))
@


1.46
log
@Merging in bug fixes
@
text
@d4 3
d10 10
d308 4
d313 2
a314 1
	let val module = FileName.MODULE (Io.get_pervasive_dir(), sub_module_id)
d318 3
a320 3
	   (case Unix.mtime (FileName.sml_name module)
	    of Unix.EXISTS time =>
	      (FileName.Option.PRESENT (module, time), sml_cache)
d322 3
a324 3
	    case Unix.mtime (FileName.mo_name module)
	    of Unix.EXISTS time =>
	      (FileName.Option.PRESENT (module, time), mo_cache)
d363 7
a369 13
	  (case Unix.mtime
	     (FileName.mo_name
	      (FileName.MODULE (Io.get_pervasive_dir(), sub_module_id)))
	     of Unix.EXISTS time => (time, mo_cache)
	   | Unix.NOT_EXIST =>
	       Info.error'
	       error_info
	       (Info.FATAL, location, "Can't find pervasive library\n" ^
		"- check MLWORKS_PERVASIVE environment variable or -pervasive_dir argument"))
	     handle Io.NotSet _ =>
	       Info.error'
	       error_info
	       (Info.FATAL, location, "Pervasive directory not set")
a405 41
(*
	fun check_cache(sml_cache, doing, message) =
	  let
	    val x = FileName.cache_size sml_cache
	    val list1 = FileName.cache_list sml_cache
	    val list2 = FileName.cache_list(!sml_cache_best)
	    val _ =
	      if not(!found_utils) then
		if Lists.member(utils_lists, list1) then
		  (found_utils := true;
		   output(std_out, "Now found utils.lists\n"))
		else
		  ()
	      else
		if not(Lists.member(utils_lists, list1)) then
		  output(std_out, "Strange, utils.lists has gone again\n")
		else
		  ()
	    val _ =
	      if Lists.sublist(list2, list1) then
		(sml_cache_size := x;
		 sml_cache_best := sml_cache)
	      else
		let
		  val _ = output(std_out, "message" ^ ": sml_cache size has diminished\n")
		  val _ = output(std_out, "While doing:-\n")
		  val _ = Lists.iterate (fn x => output(std_out, x ^ "\n")) doing
		  val diff = Lists.difference(list2, list1)
		  val _ = output(std_out, "The following moduleids have been lost:-\n")
		  val _ = Lists.iterate
		    (fn x => output(std_out, ModuleId.string x ^ "\n"))
		    diff
		in
		  (sml_cache_size := x;
		   sml_cache_best := sml_cache)
		end
	  in
	    ()
	  end
*)

a413 4
(*
	      val _ = check_cache(sml_cache', map ModuleId.string list,
				  "Inside find_module_list")
*)
d419 3
a421 8
	fun recompile''(_, _, sml_cache, mo_cache, _, [], done, up_to_date, doing) =
	  let
(*
	    val _ = check_cache(sml_cache, doing, "recompile'' head [] case")
*)
	  in
	    (done, up_to_date, sml_cache, mo_cache)
	  end
d423 2
a424 1
	  (level, cache, sml_cache, mo_cache, mod_path,
a426 3
(*
	    val _ = check_cache(sml_cache, doing, "recompile'' head :: case")
*)
a428 6
(*
	    val _ = output(std_out, implode["recompile ",
					    MLWorks.Integer.makestring level,
					    " ", ModuleId.path_string mod_path,
					    " ", module_str, "\n"])
*)
d453 2
a454 1
		(level, cache, sml_cache, mo_cache, mod_path, rest,
a470 3
(*
		  val _ = check_cache(sml_cache', doing, "find_module_list case")
*)
d477 1
a477 1
		  val (done, up_to_date, sml_cache'', mo_cache'') =
d484 1
a484 1
		     (level+1, cache, sml_cache', mo_cache',
a486 4
		  (* Deal with the imports. This needs more work *)
(*
		  val _ = check_cache(sml_cache'', doing, "imports_to_do case")
*)
d504 1
d507 3
a509 2
			  (error_info, first orelse pervasive,
			   ModuleId.path module_id, cache,
d511 1
d612 2
a613 1
		    (level, cache, sml_cache'', mo_cache''', mod_path, rest,
d622 1
a622 1
			  val new_cache =
d624 1
a624 1
			      cache
d628 1
a628 1
			      (options, cache, mo_cache''', sml_file, pervasive)
d647 2
a648 1
			   sml_cache'', new_mo_cache, mod_path, rest,
d662 1
a662 1
	(0, cache, sml_cache, mo_cache,
d674 1
a674 1
	val (done, _, _, _) =
d699 1
a699 1
	val (done, _, _, _) =
@


1.45
log
@Merged in bug fixes for speed improvements
@
text
@d4 6
d316 2
a317 1
        let val module_id = ModuleId.add_path (mod_path, sub_module_id)
d320 3
a322 3
		FileName.find_mo (module_id, mo_cache))
	  of ((FileName.Option.ABSENT, _), (FileName.Option.ABSENT, _)) =>
	    (find_module
d324 2
a325 2
		sml_cache, mo_cache, sub_module_id)
	     handle
d327 4
a330 4
	        Info.error'
		  error_info
		  (Info.FATAL, Info.Location.UNKNOWN,
		   implode ["make called on non-existent file `",
d361 1
a361 1
          | (FileName.Option.ABSENT, _) =>
d379 6
d394 41
d437 2
a438 1
	  | find_module_list(sub_module_id :: rest, path, (acc, sml_cache, mo_cache)) =
d443 4
d452 8
a459 2
	fun recompile''(_, _, sml_cache, mo_cache, _, [], done, up_to_date, _) =
	  (done, up_to_date, sml_cache, mo_cache)
d462 1
a462 1
	   (*sub_*)(module_id, sml_info, mo_info) :: rest, done, up_to_date, doing) =
d465 1
a465 3
	    val (module_id, ((sml_info, sml_cache'), (mo_info, mo_cache'))) =
	      find_module (error_info, pervasive, mod_path,
			   sml_cache, mo_cache, sub_module_id)
a466 2
	    val sml_cache' = sml_cache
	    val mo_cache' = mo_cache
d469 6
d499 1
a499 1
		(level, cache, sml_cache', mo_cache', mod_path, rest,
a510 1

d514 1
a514 1
		    find_module_list(imports, current_path, ([], sml_cache', mo_cache'))
d516 3
a518 1

d536 3
a620 1
(*
a621 9
					     if no_execute andalso
					       requires_in_done_list
					       (imports, done) then
					       (false, mo_cache'')
					     else
					       check (FileName.sml_name sml_file,
						      subs, true, mo_cache'')
*)
					   val result as (ok, _) =
d703 1
a706 2

      (* Now calculate the full module names of all to be recompiled *)
@


1.44
log
@Removed calls to Io.set_pervasive_dir_from_env and
Io.set_source_path_from_env.  Added these to the daily build script instead.
@
text
@d4 12
d227 1
d266 1
a266 1
	| _ => rev imports
d268 1
d280 1
a280 1
      | requires_in_done_list(x :: xs, done) =
d331 5
a335 4
      let val module_id = ModuleId.add_path (mod_path, sub_module_id)
          val _ = diagnostic
                    (2, fn _ => ["find_mo_time ", ModuleId.path_string mod_path,
				 " ", ModuleId.string sub_module_id])
d339 12
a350 12
		  (FileName.mo_name
		     (FileName.MODULE (Io.get_pervasive_dir(), sub_module_id)))
	   of Unix.EXISTS time => (time, mo_cache)
	   |  Unix.NOT_EXIST =>
             Info.error'
               error_info
               (Info.FATAL, location, "Can't find pervasive library\n" ^
 	        "- check MLWORKS_PERVASIVE environment variable or -pervasive_dir argument"))
          handle Io.NotSet _ =>
            Info.error'
              error_info
              (Info.FATAL, location, "Pervasive directory not set")
d352 6
a357 6
          case FileName.find_mo (module_id, mo_cache)
          of (FileName.Option.PRESENT (_, t), new_cache) => (t, new_cache)
          |  (FileName.Option.ABSENT, _) =>
            find_mo_time (error_info, pervasive, ModuleId.parent mod_path,
                          mo_cache, sub_module_id, location)
            handle
d360 4
a363 4
                  error_info
                  (Info.FATAL, location,
                   implode ["Can't find .mo file `",
                            ModuleId.string sub_module_id, "'"])
d370 1
a370 1
      (cache, module_id_list, done, up_to_date, doing, pervasive) =
d381 3
a383 5
	fun recompile''(_, _, sml_cache, mo_cache, _, [], done, up_to_date, _) =
	  (done, up_to_date, sml_cache, mo_cache)
	|   recompile''
	      (level, cache, sml_cache, mo_cache, mod_path,
	       sub_module_id :: rest, done, up_to_date, doing) =
d386 1
a386 1
	        find_module (error_info, pervasive, mod_path,
d388 4
a391 1
	      val module_str = ModuleId.string module_id
d393 14
a406 5
	      val _ = diagnostic
			(1, fn _ => ["recompile ",
				     MLWorks.Integer.makestring level,
				     " ", ModuleId.path_string mod_path,
				     " ", module_str]);
d408 5
a412 12
	      val _ =
		if Lists.member(module_str, doing) then
		  Info.error'
		  error_info
		  (Info.FATAL,
		   Info.Location.FILE module_str,
		   implode
		   ("Circular require structure within" ::
		    map (fn x => "\n" ^ x) doing)
		   )
		else
		  ()
d414 13
d428 16
a443 7
	      val imports =
	        case sml_info of
	  	  FileName.Option.PRESENT (sml_file, _) =>
	            get_imports (error_info,options)
				(FileName.sml_name sml_file)
	 	| FileName.Option.ABSENT =>
		    []
d445 1
a445 7
	      val imports_to_do =
		Lists.filterp
		(fn x =>
		 (case NewMap.tryApply' (up_to_date, ModuleId.string x) of
		    NewMap.NO => true
		  | _ => false))
		imports
d447 3
a449 9
	      val (done, up_to_date, sml_cache'', mo_cache'') =
		(diagnostic (2, fn _ => "doing imports:" ::
			     (Lists.reducel
			      (fn (list, module_id) => " " :: ModuleId.string module_id :: list)
			      ([], rev imports_to_do)));
		 recompile''
		   (level+1, cache, sml_cache', mo_cache',
		    ModuleId.path module_id, imports_to_do, done,
		    up_to_date, module_str :: doing))
d451 32
a482 14
	      (* function to check that a module is up to date with its
		 submodules.  The first submodule is the pervasive library.  *)
	      fun check (_, [], false, cache) =
		(true, cache)
	      |   check (_, [], true, cache) =
		if pervasive then
		  (true, cache)
		else
		  Crash.impossible
		    "Attempt to compile pervasive module in non-pervasive mode"
	      |   check (filename, (sub_name, sub_stamp)::rest, first, cache) =
		let
		  val sub_module_id =
			ModuleId.from_string
a483 15
			 
		  val (sub_time, cache') =
		    find_mo_time
		      (error_info, first orelse pervasive,
		       ModuleId.path module_id, cache,
		       sub_module_id, Info.Location.FILE filename)
		in
		  if MLWorks.Time.Real.equal (sub_time, sub_stamp) then
		    check (filename, rest, false, cache')
		  else
		    (diagnostic (2, fn _ => [module_str,
					     " is out of date wrt ",
					     sub_name]);
		     (false, cache'))
	        end
d485 14
a498 4
	      val (consistent, mo_cache''') =
		(diagnostic (2, fn _ => [MLWorks.Integer.makestring level,
					 " ", "checking consistency of ",
					 module_str]);
d500 4
a503 20
		 case mo_info
		 of FileName.Option.ABSENT =>
		   (diagnostic (2, fn _ => ["object file for ", module_str,
					    " doesn't exist"]);
		    (false, mo_cache''))
		 |  FileName.Option.PRESENT (mo_file, mo_time) =>
		   if NewMap.apply_default' (up_to_date, false, module_str) then
		     (diagnostic
			(2, fn _ => [module_str, " cached as up to date"]);
		      (true, mo_cache''))
		   else
		     case sml_info
		     of FileName.Option.ABSENT =>
		       (diagnostic
			  (2, fn _ => ["Source file for ", module_str,
				       " doesn't exist, assuming up to date"]);
			(true, mo_cache''))
		     |  FileName.Option.PRESENT (sml_file, source_time) =>
		       let
			 val mo_name = FileName.mo_name mo_file
d505 13
a517 50
			 val consistency =
			   NewMap.YES (Encapsulate.input_info mo_name)
			   handle Encapsulate.BadInput s =>
			     (Info.error
				error_info
				(Info.WARNING, Info.Location.FILE mo_name,
				 s ^ " -- treating as out of date");
		              NewMap.NO)
		       in
			 case consistency
			 of NewMap.NO => (false, mo_cache'')
		         |  NewMap.YES{consistency, ...} =>
			   let
			     val (source_stamp, subs) =
			       case consistency
			       of [] =>
				 crash ("missing consistency info in " ^
					mo_name)
			       |  (_, source_stamp) :: subs =>
				 (source_stamp, subs)
			   in
			     if MLWorks.Time.Real.equal
				  (source_time, source_stamp) then
			       let val result as (ok, _) =
			             if no_execute andalso
					requires_in_done_list
					  (imports, done) then
				       (false, mo_cache'')
				     else
			               check (FileName.sml_name sml_file,
					      subs, true, mo_cache'')
			       in
				 if ok then
				   diagnostic
				     (2,
				      fn _ =>
					[MLWorks.Integer.makestring level,
				         " ", ModuleId.path_string mod_path,
					 " ", module_str, " is up to date!"])
			         else
				   diagnostic
				      (2,
				       fn _ =>
					 [MLWorks.Integer.makestring level,
				          " ", ModuleId.path_string mod_path,
					  " ", module_str,
					  " is out of date wrt dependencies"]);
				 result
			       end
			     else
d519 6
a524 8
				  (2, fn _ =>
				       [MLWorks.Integer.makestring level,
				        " ", ModuleId.path_string mod_path,
					" ", module_str,
					" is out of date wrt source"]);
				(false, mo_cache''))
			   end
		       end)
d526 69
a594 19
	      val up_to_date = NewMap.define (up_to_date, module_str, true)
	    in
	      if consistent then
		recompile''
		  (level, cache, sml_cache'', mo_cache''', mod_path, rest,
		   done, up_to_date, doing)
	      else
     		case sml_info
                of FileName.Option.ABSENT =>
		  Crash.impossible "No sml file to recompile!"
                |  FileName.Option.PRESENT (sml_file, _) =>
		  let
		    val new_cache =
		      if no_execute then
		        cache
		      else
		        TopLevel.compile_file'
		          error_info
		          (options, cache, mo_cache''', sml_file, pervasive)
d596 3
a598 15
		    val new_mo_cache =
		      if no_execute then
			mo_cache'''
		      else
			(* mo files generated by a compilation are put in the
			   same place as the sml files. *)
			case Unix.mtime (FileName.mo_name sml_file)
			of Unix.NOT_EXIST =>
			  (* Presumably the compilation has reported an error,
			     so we'll just return the old value for form. *)
			  mo_cache'''
			|  Unix.EXISTS new_time =>
			  FileName.update_cache
			    (mo_cache''', module_id, (sml_file, new_time))
		  in
d600 47
a646 6
		      (level, new_cache,
		       sml_cache'', new_mo_cache, mod_path, rest,
		       NewMap.define (done, module_str, true),
		       up_to_date, doing)
		  end
	    end
d649 2
a650 2
	  (0, cache, FileName.empty_cache, FileName.empty_cache,
	   ModuleId.empty_path, module_id_list, done, up_to_date, doing)
d669 1
a669 1
	     empty_map, empty_map, [], false)
d693 1
a693 1
	     empty_map, empty_map, [], true)
@


1.44.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.44  1993/08/28  19:17:25  daveb
Removed calls to Io.set_pervasive_dir_from_env and
Io.set_source_path_from_env.  Added these to the daily build script instead.

@


1.44.1.2
log
@Improvements to use up_to_date information to determine whether to lex files
or not, and to avoid check when some require has been recompiled. Also took
module name disambiguation out of recompile' and put it in the parameters
@
text
@a3 3
Revision 1.44.1.1  1993/08/28  19:17:25  jont
Fork for bug fixing

a218 1
    (* Returns reversed list of imports *)
d257 1
a257 1
	| _ => imports
a258 1
    (* Returns reversed list of imports *)
d270 1
a270 1
      | requires_in_done_list((x, _, _) :: xs, done) =
d321 4
a324 5
      let
	val module_id = ModuleId.add_path (mod_path, sub_module_id)
	val _ = diagnostic
	  (2, fn _ => ["find_mo_time ", ModuleId.path_string mod_path,
		       " ", ModuleId.string sub_module_id])
d328 12
a339 12
	     (FileName.mo_name
	      (FileName.MODULE (Io.get_pervasive_dir(), sub_module_id)))
	     of Unix.EXISTS time => (time, mo_cache)
	   | Unix.NOT_EXIST =>
	       Info.error'
	       error_info
	       (Info.FATAL, location, "Can't find pervasive library\n" ^
		"- check MLWORKS_PERVASIVE environment variable or -pervasive_dir argument"))
	     handle Io.NotSet _ =>
	       Info.error'
	       error_info
	       (Info.FATAL, location, "Pervasive directory not set")
d341 6
a346 6
          case FileName.find_mo (module_id, mo_cache) of
	    (FileName.Option.PRESENT (_, t), new_cache) => (t, new_cache)
          | (FileName.Option.ABSENT, _) =>
	      find_mo_time (error_info, pervasive, ModuleId.parent mod_path,
			    mo_cache, sub_module_id, location)
	      handle
d349 4
a352 4
		error_info
		(Info.FATAL, location,
		 implode ["Can't find .mo file `",
			  ModuleId.string sub_module_id, "'"])
d359 1
a359 1
      (cache, module_id_list, done, up_to_date, pervasive) =
d370 5
a374 3
        (* Returns reversed list of module imports *)
	fun find_module_list([], _, result) = result
	  | find_module_list(sub_module_id :: rest, path, (acc, sml_cache, mo_cache)) =
d377 1
a377 1
		find_module (error_info, pervasive, path,
d379 1
a379 4
	    in
	      find_module_list(rest, path, ((module_id, sml_info, mo_info) :: acc,
					    sml_cache', mo_cache'))
	    end
d381 5
a385 14
	fun recompile''(_, _, sml_cache, mo_cache, _, [], done, up_to_date, _) =
	  (done, up_to_date, sml_cache, mo_cache)
	| recompile''
	  (level, cache, sml_cache, mo_cache, mod_path,
	   (*sub_*)(module_id, sml_info, mo_info) :: rest, done, up_to_date, doing) =
	  let
(*
	    val (module_id, ((sml_info, sml_cache'), (mo_info, mo_cache'))) =
	      find_module (error_info, pervasive, mod_path,
			   sml_cache, mo_cache, sub_module_id)
*)
	    val sml_cache' = sml_cache
	    val mo_cache' = mo_cache
	    val module_str = ModuleId.string module_id
d387 12
a398 5
	    val _ = diagnostic
	      (1, fn _ => ["recompile ",
			   MLWorks.Integer.makestring level,
			   " ", ModuleId.path_string mod_path,
			   " ", module_str]);
a399 13
	    val _ =
	      if Lists.member(module_str, doing) then
		Info.error'
		error_info
		(Info.FATAL,
		 Info.Location.FILE module_str,
		 implode
		 ("Circular require structure within" ::
		  map (fn x => "\n" ^ x) doing)
		 )
	      else
		()

d401 7
a407 16
	  in
	    case NewMap.tryApply'(up_to_date, module_str) of
	      NewMap.YES _ =>
		recompile''
		(level, cache, sml_cache', mo_cache', mod_path, rest,
		 done, up_to_date, doing)
	    (* Do the rest of the list, this one's ok *)
	    | _ =>
		let
		  val imports =
		    case sml_info of
		      FileName.Option.PRESENT (sml_file, _) =>
			get_imports (error_info,options)
			(FileName.sml_name sml_file)
		    | FileName.Option.ABSENT =>
			[]
d409 7
a415 1
		  val current_path = ModuleId.path module_id
d417 9
a425 3
		  val (import_list, sml_cache', mo_cache') =
		    find_module_list(imports, current_path, ([], sml_cache', mo_cache'))
                  (* import_list is now in forwards order again *)
d427 14
a440 32
		  val imports_to_do =
		    Lists.filterp
		    (fn (x, _, _) =>
		     not (NewMap.apply_default' (up_to_date, false, ModuleId.string x)))
		    import_list

		  val (done, up_to_date, sml_cache'', mo_cache'') =
		    (diagnostic (2, fn _ => "doing imports:" ::
				 (Lists.reducel
				  (fn (list, (module_id, _, _)) =>
				   " " :: ModuleId.string module_id :: list)
				  ([], imports_to_do)));
		     recompile''
		     (level+1, cache, sml_cache', mo_cache',
		      ModuleId.path module_id, imports_to_do, done,
		      up_to_date, module_str :: doing))
		  (* Deal with the imports. This needs more work *)

		  (* function to check that a module is up to date with its
		   submodules.  The first submodule is the pervasive library.  *)
		  fun check (_, [], false, cache) =
		    (true, cache)
		    | check (_, [], true, cache) =
		      if pervasive then
			(true, cache)
		      else
			Crash.impossible
			"Attempt to compile pervasive module in non-pervasive mode"
		    | check (filename, (sub_name, sub_stamp)::rest, first, cache) =
		      let
			val sub_module_id =
			  ModuleId.from_string
d442 15
d458 4
a461 14
			val (sub_time, cache') =
			  find_mo_time
			  (error_info, first orelse pervasive,
			   ModuleId.path module_id, cache,
			   sub_module_id, Info.Location.FILE filename)
		      in
			if MLWorks.Time.Real.equal (sub_time, sub_stamp) then
			  check (filename, rest, false, cache')
			else
			  (diagnostic (2, fn _ => [module_str,
						   " is out of date wrt ",
						   sub_name]);
			   (false, cache'))
		      end
d463 20
a482 4
		  val (consistent, mo_cache''') =
		    (diagnostic (2, fn _ => [MLWorks.Integer.makestring level,
					     " ", "checking consistency of ",
					     module_str]);
d484 50
a533 13
		     case mo_info of
		       FileName.Option.ABSENT =>
			 (diagnostic (2, fn _ => ["object file for ", module_str,
						  " doesn't exist"]);
			  (false, mo_cache''))
		     | FileName.Option.PRESENT (mo_file, mo_time) =>
			 if NewMap.apply_default'(up_to_date, false, module_str) then
			   (diagnostic
			    (2, fn _ => [module_str, " cached as up to date"]);
			    (true, mo_cache''))
			 else
			   case sml_info of
			     FileName.Option.ABSENT =>
d535 8
a542 6
				(2, fn _ => ["Source file for ", module_str,
					     " doesn't exist, assuming up to date"]);
				(true, mo_cache''))
			   | FileName.Option.PRESENT (sml_file, source_time) =>
			       let
				 val mo_name = FileName.mo_name mo_file
d544 19
a562 69
				 val consistency =
				   NewMap.YES (Encapsulate.input_info mo_name)
				   handle Encapsulate.BadInput s =>
				     (Info.error
				      error_info
				      (Info.WARNING, Info.Location.FILE mo_name,
				       s ^ " -- treating as out of date");
				      NewMap.NO)
			       in
				 case consistency
				   of NewMap.NO => (false, mo_cache'')
				 | NewMap.YES{consistency, ...} =>
				     let
				       val (source_stamp, subs) =
					 case consistency
					   of [] =>
					     crash ("missing consistency info in " ^
						    mo_name)
					 | (_, source_stamp) :: subs =>
					     (source_stamp, subs)
				     in
				       if MLWorks.Time.Real.equal
					 (source_time, source_stamp) then
					 let
(*
					   val result as (ok, _) =
					     if no_execute andalso
					       requires_in_done_list
					       (imports, done) then
					       (false, mo_cache'')
					     else
					       check (FileName.sml_name sml_file,
						      subs, true, mo_cache'')
*)
					   val result as (ok, _) =
					     if requires_in_done_list
					       (import_list,done) then
					       (false, mo_cache'')
					     else
					       check(FileName.sml_name sml_file,
						     subs, true, mo_cache'')
					 in
					   if ok then
					     diagnostic
					     (2,
					      fn _ =>
					      [MLWorks.Integer.makestring level,
					       " ", ModuleId.path_string mod_path,
					       " ", module_str, " is up to date!"])
					   else
					     diagnostic
					     (2,
					      fn _ =>
					      [MLWorks.Integer.makestring level,
					       " ", ModuleId.path_string mod_path,
					       " ", module_str,
					       " is out of date wrt dependencies"]);
					     result
					 end
				       else
					 (diagnostic
					  (2, fn _ =>
					   [MLWorks.Integer.makestring level,
					    " ", ModuleId.path_string mod_path,
					    " ", module_str,
					    " is out of date wrt source"]);
					  (false, mo_cache''))
				     end
			       end)
d564 15
a578 3
		  val up_to_date = NewMap.define (up_to_date, module_str, true)
		in
		  if consistent then
d580 6
a585 47
		    (level, cache, sml_cache'', mo_cache''', mod_path, rest,
		     done, up_to_date, doing)
		  (* Deal with the rest of the list, this one proved ok *)
		  else
		    case sml_info of
		      FileName.Option.ABSENT =>
			Crash.impossible "No sml file to recompile!"
		    | FileName.Option.PRESENT (sml_file, _) =>
			let
			  val new_cache =
			    if no_execute then
			      cache
			    else
			      TopLevel.compile_file'
			      error_info
			      (options, cache, mo_cache''', sml_file, pervasive)

			  val new_mo_cache =
			    if no_execute then
			      mo_cache'''
			    else
			      (* mo files generated by a compilation are put in the
			       same place as the sml files. *)
			      case Unix.mtime (FileName.mo_name sml_file) of
				Unix.NOT_EXIST =>
				  (* Presumably the compilation has reported an error,
				   so we'll just return the old value for form. *)
				  mo_cache'''
			      | Unix.EXISTS new_time =>
				  FileName.update_cache
				  (mo_cache''', module_id, (sml_file, new_time))
			in
			  recompile''
			  (level, new_cache,
			   sml_cache'', new_mo_cache, mod_path, rest,
			   NewMap.define (done, module_str, true),
			   up_to_date, doing)
			(* Deal with the rest of the list, this one found to be ok *)
			end
		end
	  end

	val (module_id_list, sml_cache, mo_cache) =
	  find_module_list(rev module_id_list, ModuleId.empty_path,
			   ([], FileName.empty_cache, FileName.empty_cache))

      (* Now calculate the full module names of all to be recompiled *)
d588 2
a589 2
	(0, cache, sml_cache, mo_cache,
	 ModuleId.empty_path, module_id_list, done, up_to_date, [])
d608 1
a608 1
	     empty_map, empty_map, false)
d632 1
a632 1
	     empty_map, empty_map, true)
@


1.44.1.3
log
@Modified to make better use of the file caches
@
text
@a3 5
Revision 1.44.1.2  1993/09/06  15:45:39  jont
Improvements to use up_to_date information to determine whether to lex files
or not, and to avoid check when some require has been recompiled. Also took
module name disambiguation out of recompile' and put it in the parameters

d305 1
a305 2
        let
	  val module_id = ModuleId.add_path (mod_path, sub_module_id)
d308 3
a310 3
		FileName.find_mo (module_id, mo_cache)) of
	    ((FileName.Option.ABSENT, sml_cache'), (FileName.Option.ABSENT, mo_cache')) =>
	      (find_module
d312 2
a313 2
		sml_cache', mo_cache', sub_module_id)
	       handle
d315 4
a318 4
		 Info.error'
		 error_info
		 (Info.FATAL, Info.Location.UNKNOWN,
		  implode ["make called on non-existent file `",
d349 1
a349 1
          | (FileName.Option.ABSENT, mo_cache) =>
a366 6

	val sml_cache_size = ref 0
	val sml_cache_best = ref FileName.empty_cache
	val utils_lists = ModuleId.from_string("utils.lists", Info.Location.UNKNOWN)
	val found_utils = ref false

a375 41
(*
	fun check_cache(sml_cache, doing, message) =
	  let
	    val x = FileName.cache_size sml_cache
	    val list1 = FileName.cache_list sml_cache
	    val list2 = FileName.cache_list(!sml_cache_best)
	    val _ =
	      if not(!found_utils) then
		if Lists.member(utils_lists, list1) then
		  (found_utils := true;
		   output(std_out, "Now found utils.lists\n"))
		else
		  ()
	      else
		if not(Lists.member(utils_lists, list1)) then
		  output(std_out, "Strange, utils.lists has gone again\n")
		else
		  ()
	    val _ =
	      if Lists.sublist(list2, list1) then
		(sml_cache_size := x;
		 sml_cache_best := sml_cache)
	      else
		let
		  val _ = output(std_out, "message" ^ ": sml_cache size has diminished\n")
		  val _ = output(std_out, "While doing:-\n")
		  val _ = Lists.iterate (fn x => output(std_out, x ^ "\n")) doing
		  val diff = Lists.difference(list2, list1)
		  val _ = output(std_out, "The following moduleids have been lost:-\n")
		  val _ = Lists.iterate
		    (fn x => output(std_out, ModuleId.string x ^ "\n"))
		    diff
		in
		  (sml_cache_size := x;
		   sml_cache_best := sml_cache)
		end
	  in
	    ()
	  end
*)

d378 1
a378 2
	  | find_module_list(list as (sub_module_id :: rest), path,
			     (acc, sml_cache, mo_cache)) =
a382 4
(*
	      val _ = check_cache(sml_cache', map ModuleId.string list,
				  "Inside find_module_list")
*)
d388 2
a389 8
	fun recompile''(_, _, sml_cache, mo_cache, _, [], done, up_to_date, doing) =
	  let
(*
	    val _ = check_cache(sml_cache, doing, "recompile'' head [] case")
*)
	  in
	    (done, up_to_date, sml_cache, mo_cache)
	  end
d392 1
a392 1
	   (module_id, sml_info, mo_info) :: rest, done, up_to_date, doing) =
d395 3
a397 1
	    val _ = check_cache(sml_cache, doing, "recompile'' head :: case")
d399 2
a402 6
(*
	    val _ = output(std_out, implode["recompile ",
					    MLWorks.Integer.makestring level,
					    " ", ModuleId.path_string mod_path,
					    " ", module_str, "\n"])
*)
d427 1
a427 1
		(level, cache, sml_cache, mo_cache, mod_path, rest,
d443 1
a443 1
		    find_module_list(imports, current_path, ([], sml_cache, mo_cache))
a444 3
(*
		  val _ = check_cache(sml_cache', doing, "find_module_list case")
*)
a462 3
(*
		  val _ = check_cache(sml_cache'', doing, "imports_to_do case")
*)
d545 1
d547 9
a636 1
	(* Now calculate the full module names of all to be recompiled *)
d640 2
@


1.44.1.4
log
@Changed to pass a pervasive mo cache to compile_file' and to accept
it updated as a return
@
text
@a3 9
Revision 1.46  1993/09/10  17:39:50  jont
Merging in bug fixes

Revision 1.45  1993/09/06  15:48:39  jont
Merged in bug fixes for speed improvements

Revision 1.44.1.3  1993/09/10  17:05:35  jont
Modified to make better use of the file caches

a288 4
(*
	  (output(std_out, "find_module called on " ^
		  ModuleId.string sub_module_id ^ "\n");
*)	   
d290 1
a290 2
	let
	  val module = FileName.MODULE (Io.get_pervasive_dir(), sub_module_id)
d294 3
a296 3
	   (case Unix.mtime (FileName.sml_name module) of
	      Unix.EXISTS time =>
		(FileName.Option.PRESENT (module, time), sml_cache)
d298 3
a300 3
	    case Unix.mtime (FileName.mo_name module) of
	      Unix.EXISTS time =>
		(FileName.Option.PRESENT (module, time), mo_cache)
d339 13
a351 7
	  case FileName.find_pervasive_mo(sub_module_id, mo_cache) of
	    (FileName.Option.PRESENT (_, t), new_cache) => (t, new_cache)
	  | _ =>
	      Info.error'
	      error_info
	      (Info.FATAL, location, "Can't find pervasive library\n" ^
		"- check MLWORKS_PERVASIVE environment variable or -pervasive_dir argument")
d388 41
d437 4
d446 8
a453 3
	fun recompile''(_, _, sml_cache, mo_cache, perv_mo_cache,
			_, [], done, up_to_date, doing) =
	    (done, up_to_date, sml_cache, mo_cache, perv_mo_cache)
d455 1
a455 2
	  (level, cache, sml_cache, mo_cache, perv_mo_cache,
	   mod_path,
d458 3
d463 6
d493 1
a493 2
		(level, cache, sml_cache, mo_cache, perv_mo_cache,
		 mod_path, rest,
d505 1
d511 4
d521 1
a521 1
		  val (done, up_to_date, sml_cache'', mo_cache'', perv_mo_cache) =
d528 1
a528 1
		     (level+1, cache, sml_cache', mo_cache', perv_mo_cache,
d531 4
a551 1
			val perv = first orelse pervasive
d554 2
a555 3
			  (error_info, perv,
			   ModuleId.path module_id,
			   if perv then perv_mo_cache else cache,
a556 1
			val cache' = if perv then cache else cache'
d657 1
a657 2
		    (level, cache, sml_cache'', mo_cache''', perv_mo_cache,
		     mod_path, rest,
d666 1
a666 1
			  val (new_cache, perv_mo_cache) =
d668 1
a668 1
			      (cache, perv_mo_cache)
d672 1
a672 1
			      (options, cache, mo_cache''', perv_mo_cache, sml_file, pervasive)
d691 1
a691 2
			   sml_cache'', new_mo_cache, perv_mo_cache,
			   mod_path, rest,
d705 1
a705 1
	(0, cache, sml_cache, mo_cache,  FileName.empty_cache,
d717 1
a717 1
	val (done, _, _, _, _) =
d742 1
a742 1
	val (done, _, _, _, _) =
@


1.44.1.5
log
@Removed option of passing long_id to require.
@
text
@a3 4
Revision 1.44.1.4  1993/09/27  11:10:28  jont
Changed to pass a pervasive mo cache to compile_file' and to accept
it updated as a return

d256 14
@


1.43
log
@Added filename caches.
@
text
@d4 3
a637 4

    (* This is for building MLWorks on top of SML/NJ. *)
    val _ = Io.set_pervasive_dir_from_env ();
    val _ = Io.set_source_path_from_env ();
@


1.42
log
@Several changes to search for mos along source path and to handle case
where one of mo and sml files doesn't exist.  Some optimisation, and
improvement of error messages.
Use ModuleId.create to check that moduleids in require decs are alphanumeric.
@
text
@d4 6
d184 1
a184 2
   sharing type ModuleId.ModuleId = Io.ModuleId =
		FileName.ModuleId = TopLevel.ModuleId
d188 2
a211 2
    val compile = TopLevel.compile_file'

d269 3
a271 1
    fun find_module (error_info, pervasive, mod_path, sub_module_id) =
d275 1
d279 2
a280 2
	      FileName.Option.PRESENT (module, time)
	    | Unix.NOT_EXIST => FileName.Option.ABSENT,
d283 2
a284 2
	      FileName.Option.PRESENT (module, time)
	    | Unix.NOT_EXIST => FileName.Option.ABSENT))
d295 6
a300 4
	  case (FileName.find_sml module_id, FileName.find_mo module_id)
	  of (FileName.Option.ABSENT, FileName.Option.ABSENT) =>
	    (find_module (error_info, pervasive,
			  ModuleId.parent mod_path, sub_module_id)
d312 2
a313 1
	  (error_info, pervasive, mod_path, sub_module_id, location) =
d323 1
a323 1
	   of Unix.EXISTS time => time
d334 3
a336 3
          case FileName.find_mo module_id
          of FileName.Option.PRESENT (_, t) => t
          |  FileName.Option.ABSENT =>
d338 1
a338 1
                          sub_module_id, location)
d363 5
a367 5
	fun recompile''(level, cache, mod_path, [], done, up_to_date, _) =
	  (done, up_to_date)
	  | recompile''
	      (level, cache, mod_path, sub_module_id :: rest,
	       done, up_to_date, doing) =
d369 3
a371 2
	      val (module_id, (sml_info, mo_info)) =
	        find_module (error_info, pervasive, mod_path, sub_module_id)
d410 1
a410 1
	      val (done, up_to_date) =
d416 3
a418 2
		 (level+1, cache, ModuleId.path module_id, imports_to_do, done,
		  up_to_date, module_str :: doing))
d422 7
a428 6
	      fun check (_, [], false) = true
		| check (_, [], true) =
		  if pervasive then
		    true
		  else
		    Crash.impossible
d430 5
a434 5
		| check (filename, (sub_name, sub_stamp)::rest, first) =
		  let
		    val sub_module_id =
			  ModuleId.from_string
			    (sub_name, Info.Location.FILE filename)
d436 13
a448 13
		    val sub_time =
		      find_mo_time
			(error_info, first orelse pervasive,
			 ModuleId.path module_id,
			 sub_module_id, Info.Location.FILE filename)
		  in
		    if MLWorks.Time.Real.equal (sub_time, sub_stamp) then
		      check (filename, rest, false)
		    else
		      (diagnostic (2, fn _ => [module_str,
					       " is out of date wrt ",
					       sub_name]);
		       false)
d451 1
a451 1
	      val consistent =
d460 1
a460 1
		    false)
d465 1
a465 1
		      true)
d472 1
a472 1
			true)
d487 1
a487 1
			 of NewMap.NO => false
d500 2
a501 3
			       if check (FileName.sml_name sml_file,
					 subs, true) andalso
				  (not (no_execute andalso
d503 17
a519 10
					  (imports, done))) then
				 (diagnostic
				    (2, fn _ =>
					 [MLWorks.Integer.makestring level,
				          " ", ModuleId.path_string mod_path,
					  " ", module_str, " is up to date!"]);
				  true)
			       else
				 (diagnostic
				    (2, fn _ =>
d524 2
a525 1
				  false)
d533 1
a533 1
				false)
d540 3
a542 1
		recompile''(level, cache, mod_path, rest, done, up_to_date, doing)
d544 34
a577 11
		recompile''(level,
			    (if no_execute then
			       cache
			     else
			       compile error_info (options, cache, module_id, pervasive)),
			    mod_path,
			    rest,
			    NewMap.define (done, module_str, true),
			    up_to_date,
			    doing
			    )
d581 2
a582 2
	  (0, cache, ModuleId.empty_path, module_id_list,
	   done, up_to_date, doing)
d591 1
a591 1
      module_name =
d593 1
a593 1
	val (done, up_to_date) =
d595 7
a601 5
	  error_info
	  options
	  (TopLevel.empty_cache,
	   [ModuleId.from_string (module_name, Info.Location.UNKNOWN)],
	   empty_map, empty_map, [], false)
d618 1
a618 1
	val (done, up_to_date) =
d620 6
a625 6
	  error_info
	  options
	  (TopLevel.empty_cache,
	   [ModuleId.from_string
	      (Io.pervasive_library_name, Info.Location.UNKNOWN)],
	   empty_map, empty_map, [], true)
@


1.41
log
@Io.get_pervasive_dir can raise Io.NotSet.
@
text
@d4 3
a181 1
   sharing type ModuleId.Path = FileName.ModulePath
a191 4
(*
    val _ = Diagnostic.set 4
*)

d239 1
a239 1
		     ModuleId.MODID (rev l, s) :: imports))
d263 40
a302 1
    fun find_source (error_info, pervasive, mod_path, sub_module_id) =
d304 3
d308 10
a317 2
	if pervasive then
	  FileName.MODULE (Io.get_pervasive_dir(), module_id)
d321 14
a334 16
              (Info.FATAL,
               Info.Location.UNKNOWN,
               "Pervasive directory not set")
	else
	  case FileName.find_file module_id
	  of FileName.Option.PRESENT f => f
	  |  FileName.Option.ABSENT =>
	    find_source (error_info, pervasive,
			 ModuleId.parent mod_path, sub_module_id)
	    handle
	      ModuleId.NoParent =>
	        Info.error'
		  error_info
		  (Info.FATAL, Info.Location.UNKNOWN,
		   implode ["make called on non-existent file `",
			    ModuleId.string sub_module_id, "'"])
d358 2
a359 4
	      val file =
	        find_source (error_info, pervasive, mod_path, sub_module_id)

	      val module_id = FileName.module_id file
a360 4
	      val sml_name = FileName.sml_name file
	      val mo_name = FileName.mo_name file
	      val mo_mod_path = ModuleId.path module_id
	      val dir = FileName.module_dir file
d382 7
a388 1
	      val imports = get_imports (error_info,options) sml_name
d409 2
a410 2
	      fun check ([], false) = true
		| check ([], true) =
d414 3
a416 2
		    Crash.impossible "Missing consistency information"
		| check ((sub_name, sub_stamp)::rest, first) =
d418 9
a426 25
		    val sub_mo =
		      if first orelse pervasive then
			FileName.Option.PRESENT
			  (FileName.mo_name
			     (FileName.MODULE
			        (pervasive_dir,
			           ModuleId.from_string
			             (sub_name, Info.Location.FILE sml_name))))
		      else
			case (FileName.find_mo
			      (mo_mod_path,
			       ModuleId.from_string
				 (sub_name, Info.Location.FILE sml_name),
			       dir))
			  of FileName.Option.PRESENT (f, _, _) =>
			    FileName.Option.PRESENT f
			| FileName.Option.ABSENT =>
			    if no_execute then
			      FileName.Option.ABSENT
			    else
			      Info.error'
			      error_info
			      (Info.FATAL, Info.Location.FILE sml_name,
			       implode
			       ["Required mo `", sub_name, "' does not exist"])
d428 7
a434 19
		    case sub_mo of
		      FileName.Option.PRESENT sub_mo =>
			(case Unix.mtime sub_mo of
			   Unix.EXISTS sub_time =>
			     if MLWorks.Time.Real.equal (sub_time, sub_stamp) then
			       check (rest, false)
			     else
			       (diagnostic
				(2, fn _ => [mo_name, " is out of date wrt ",
					     sub_name]);
				false)
			 | Unix.NOT_EXIST =>
			     Info.error'
			     error_info
			     (Info.FATAL,
			      Info.Location.FILE module_str,
			      sub_mo ^ " missing (check pervasive_dir parameter" ^
			      " or MLWORKS_PERVASIVE environment variable)"))
		    | _ => false
d442 16
a457 10
		 case Unix.mtime mo_name of

		   Unix.NOT_EXIST =>
		     (diagnostic (2, fn _ => [mo_name, " doesn't exist"]);
		      false)

		 | Unix.EXISTS mo_time =>

		     if NewMap.apply_default' (up_to_date, false, module_str) then
		       (diagnostic (2, fn _ => [module_str, " cached as up to date"]);
d459 16
a474 10
		     else

		       case Unix.mtime sml_name of

			 Unix.NOT_EXIST =>
			   (diagnostic (2, fn _ =>
					[sml_name, " doesn't exist, assuming up to date"]);
			    true)

		       | Unix.EXISTS source_time =>
d476 7
a482 7
			     val consistency =
			       NewMap.YES(Encapsulate.input_info mo_name)
			       handle Encapsulate.BadInput s =>
				 (Info.error error_info
				  (Info.WARNING, Info.Location.FILE mo_name,
				   s ^ " -- treating as out of date");
				  NewMap.NO)
d484 9
a492 20
			     case consistency of
			       NewMap.NO => false
			     | NewMap.YES{consistency, ...} =>
				 let
				   val (source_stamp, subs) =
				     case consistency of
				       [] => crash
					 ("missing consistency info in " ^
					  mo_name)
				     | (_, source_stamp) :: subs =>
					 (source_stamp, subs)

				 in
				   if MLWorks.Time.Real.equal
				     (source_time, source_stamp) then
				     if check (subs, true) andalso
				       (not(no_execute andalso
					    requires_in_done_list(imports, done))) then
				       (diagnostic
					(2, fn _ =>
d496 4
a499 4
					true)
				     else
				       (diagnostic
					(2, fn _ =>
d504 4
a507 4
					false)
				   else
				     (diagnostic
				      (2, fn _ =>
d512 3
a514 3
				      false)
				 end
			   end)
@


1.40
log
@Fixed error message.
@
text
@d4 3
d270 6
d297 9
d374 5
a378 5
			(FileName.mo_name
			 (FileName.MODULE
			  (Io.get_pervasive_dir (),
			   ModuleId.from_string
			     (sub_name, Info.Location.FILE sml_name))))
@


1.39
log
@ ModuleId.from_string now takes a location argument.
@
text
@d4 3
d395 2
a396 2
			      sub_mo ^ " missing (check pervasive-dir parameter" ^
			      " or MLWORKS_PERVASIVE_DIR environment variable)"))
@


1.38
log
@Fixed two bugs with the no_execute option.
First stop check complaining about missing .mo files when no_execute is set.
Second ensure that mo consistency takes into account the fact that no
recompilation is done.
@
text
@d4 6
d356 2
a357 1
			   ModuleId.from_string sub_name)))
d360 4
a363 1
			      (mo_mod_path, ModuleId.from_string sub_name, dir))
d510 2
a511 1
	  (TopLevel.empty_cache, [ModuleId.from_string module_name],
d534 2
a535 1
	   [ModuleId.from_string Io.pervasive_library_name],
@


1.37
log
@Added MLWORKS_ to the start of UNIX environment variables.
@
text
@d4 3
d178 4
d249 1
a249 1
	case NewMap.tryApply'(done, x) of
d337 16
a352 15
	      |   check ([], true) =
		if pervasive then
		  true
		else
		  Crash.impossible "Missing consistency information"
	      |   check ((sub_name, sub_stamp)::rest, first) =
	        let
		  val sub_mo =
		    if first orelse pervasive then
      		      FileName.mo_name
			(FileName.MODULE
			   (Io.get_pervasive_dir (),
			    ModuleId.from_string sub_name))
		    else
		      case (FileName.find_mo
d354 31
a384 24
		      of FileName.Option.PRESENT (f, _, _) => f
		      |  FileName.Option.ABSENT =>
                        Info.error'
                          error_info
                          (Info.FATAL, Info.Location.FILE sml_name,
                           implode
			     ["Required mo `", sub_name, "' does not exist"])
	        in
		  case Unix.mtime sub_mo of
		     Unix.EXISTS sub_time =>
		       if MLWorks.Time.Real.equal (sub_time, sub_stamp) then
		         check (rest, false)
		       else
			 (diagnostic
			    (2, fn _ => [mo_name, " is out of date wrt ",
					 sub_name]);
		          false)
		  |  Unix.NOT_EXIST =>
		    Info.error'
		      error_info
		      (Info.FATAL,
		       Info.Location.FILE module_str,
		       sub_mo ^ " missing (check pervasive-dir parameter" ^
		       " or MLWORKS_PERVASIVE_DIR environment variable)")
d428 5
a432 5
				        [] => crash
				       ("missing consistency info in " ^
					mo_name)
				     |  (_, source_stamp) :: subs =>
				       (source_stamp, subs)
d436 4
a439 2
					(source_time, source_stamp) then
				     if check (subs, true) then
@


1.36
log
@Added calls to set pervasive_dir and source_path from UNIX environment,
for building under SML/NJ.
@
text
@d4 4
d369 1
a369 1
		       " or PERVASIVE_DIR environment variable)")
@


1.35
log
@Major changes:
Require declarations now take ModuleIds instead of strings.  These are
checked against a search path.
Also added diagnostics.
@
text
@d4 6
d513 4
@


1.34
log
@Cleaned up after assembly changes
@
text
@d4 3
d120 2
d131 25
a155 15
functor Recompile(structure Print	: PRINT
                  structure NewMap	: NEWMAP
                  structure Lists	: LISTS
                  structure Crash	: CRASH
                  structure Unix	: UNIX
                  structure Lexer       : LEXER
                  structure Encapsulate	: ENCAPSULATE
                  structure TopLevel	: TOPLEVEL
                  structure Io		: IO
                  structure Diagnostic	: DIAGNOSTIC

                  sharing Lexer.Info = TopLevel.Info
                  sharing type Lexer.options = TopLevel.Options.options
                  sharing Encapsulate.EnvironTypes = TopLevel.EnvironTypes
                  sharing type Encapsulate.Basistypes.Basis = TopLevel.TypeBasis
d185 19
a203 2
	         (case Lexer.getToken error_info (options, Token.PLAIN_STATE, ts) of
	            Lexer.Token.RESERVED Lexer.Token.SEMICOLON =>
d205 1
a205 1
	          | _ =>
d210 3
a212 3
		  get_imports_from_stream ((error_info,options), ts,
					   filename :: imports)
		 )
d217 1
a217 2
		              "missing string after require")
	    )
a229 10
    fun relative_mo (path, name) =
      let
        val root = Io.root_name (Io.compilation_name name)
      in
        if Lists.member (root, Io.pervasive_names) then
          Io.mo_name(Io.relative_name(!TopLevel.pervasive_library_dir, root))
        else
          Io.relative_name(path, Io.mo_name name)
      end

d236 20
d259 2
a260 1
				  Options.COMPILEROPTIONS{no_execute, ...}, ...}) =
d262 1
a262 1
	fun recompile''(cache, [], done, up_to_date, _) =
d265 2
a266 1
	    (cache, name :: rest, done, up_to_date, doing) =
d268 2
a269 1
	      val _ = diagnostic (1, fn _ => ["recompile `", name, "'"])
d271 12
a282 4
	      val filename = Io.sml_name name
	      val comp_name = Io.compilation_name filename
	      val mo_name = Io.mo_name name
	      val path = Io.compilation_path filename
d285 1
a285 1
		if Lists.member(comp_name, doing) then
d289 1
a289 1
		   Info.Location.FILE comp_name,
d292 1
a292 1
		    map (fn x => "\n" ^ Io.sml_name x) doing)
d298 1
a298 4
	      val imports = get_imports (error_info,options) filename

	      val import_names =
		map (fn name => Io.relative_name(path, name)) imports
d303 1
a303 1
		 (case NewMap.tryApply' (up_to_date, Io.compilation_name x) of
d306 1
a306 1
		import_names
d311 1
a311 1
			      (fn (list, filename) => " " :: filename :: list)
d314 47
a360 1
		 (cache, imports_to_do, done, up_to_date, comp_name :: doing))
d363 3
a365 1
		(diagnostic (2, fn _ => ["checking consistency of ", comp_name]);
d375 2
a376 2
		     if NewMap.apply_default' (up_to_date, false, comp_name) then
		       (diagnostic (2, fn _ => [comp_name, " cached as up to date"]);
d380 1
a380 1
		       case Unix.mtime filename of
d384 1
a384 1
					[filename, " doesn't exist, assuming up to date"]);
d403 6
a408 27
				       [] => crash
					 ("missing consistency info in " ^ mo_name)
				     | (_, source_stamp) :: subs => (source_stamp, subs)

				   (* function to check that a module is up to *)
				   (* date with its submodules *)
				   fun check [] = true
				     | check ((sub_name, sub_stamp)::rest) =
				       let
					 val sub_mo = relative_mo (path, sub_name)
				       in
					 if
					   (case Unix.mtime sub_mo of
					      Unix.EXISTS sub_time =>
						MLWorks.Time.Real.equal (sub_time, sub_stamp)
					    | Unix.NOT_EXIST =>
						Info.error'
						error_info
						(Info.FATAL,
						 Info.Location.FILE comp_name,
						 sub_mo ^ " missing (check pervasive-dir parameter or PERVASIVE_DIR environment variable)"))
					   then
					     check rest
					 else
					   (diagnostic (2, fn _ => [mo_name, " is out of date wrt ", sub_name]);
					    false)
				       end
d410 3
a412 2
				   if MLWorks.Time.Real.equal(source_time, source_stamp) then
				     if check subs then
d415 3
a417 1
					 [comp_name, " is up to date!"]);
d422 4
a425 1
					 [comp_name, " is out of date wrt depedencies"]);
d430 4
a433 1
				       [comp_name, " is out of date wrt source"]);
d438 1
a438 1
	      val up_to_date = NewMap.define (up_to_date, comp_name, true)
d441 1
a441 1
		recompile''(cache, rest, done, up_to_date, doing)
d443 2
a444 1
		recompile''((if no_execute then
d447 2
a448 1
			       compile error_info (options, cache, filename)),
d450 1
a450 1
			    NewMap.define (done, comp_name, true),
d457 2
d467 23
a489 1
      filename =
d495 3
a497 1
	  (TopLevel.empty_cache, [filename], empty_map, empty_map, [])
@


1.33
log
@Changes because Assemblies now has Basistypes instead of Datatypes
@
text
@d4 3
d140 1
a140 1
                  sharing type Encapsulate.Assemblies.Basistypes.Basis = TopLevel.TypeBasis
@


1.32
log
@Changed the crash when an mo is not found during checking to a fatal error
with a message suggesting various things to check
@
text
@d4 4
d137 1
a137 1
                  sharing type Encapsulate.BasisTypes.Basis = TopLevel.TypeBasis
@


1.31
log
@Added make -n type facility
@
text
@d4 3
d303 2
d311 9
a319 3
					   case Unix.mtime sub_mo of
					     Unix.EXISTS sub_time => MLWorks.Time.Real.equal (sub_time, sub_stamp)
					   | Unix.NOT_EXIST => crash (sub_mo ^ " missing")
d327 1
a327 1
				   if MLWorks.Time.Real.equal (source_time, source_stamp) then
@


1.30
log
@getToken now takes a LexerState argument.
@
text
@d4 3
d206 10
a215 10
	  error_info
	  options
	  (cache, [], done, up_to_date, _) =
	(done, up_to_date)
      | recompile'
          error_info
	  options
	  (cache, name :: rest, done, up_to_date, doing) =
	let
          val _ = diagnostic (1, fn _ => ["recompile `", name, "'"])
d217 4
a220 4
	  val filename = Io.sml_name name
	  val comp_name = Io.compilation_name filename
	  val mo_name = Io.mo_name name
	  val path = Io.compilation_path filename
d222 12
a233 12
	  val _ =
	    if Lists.member(comp_name, doing) then
              Info.error'
		error_info
		(Info.FATAL,
		 Info.Location.FILE comp_name,
		 implode
		 ("Circular require structure within" ::
		  map (fn x => "\n" ^ Io.sml_name x) doing)
		)
	    else
	      ()
d235 2
a236 2
	  (* First do all required files *)
	  val imports = get_imports (error_info,options) filename
d238 2
a239 2
	  val import_names =
	    map (fn name => Io.relative_name(path, name)) imports
d241 7
a247 7
	  val imports_to_do =
	    Lists.filterp
	    (fn x =>
	     (case NewMap.tryApply' (up_to_date, Io.compilation_name x) of
		NewMap.NO => true
	      | _ => false))
	    import_names
d249 7
a255 5
	  val (done, up_to_date) =
            (diagnostic (2, fn _ => "doing imports:" ::
                         (Lists.reducel
                          (fn (list, filename) => " " :: filename :: list)
                          ([], rev imports_to_do)));
d257 2
a258 4
	    recompile'
	      error_info
	      options
	      (cache, imports_to_do, done, up_to_date, comp_name :: doing))
d260 1
a260 2
          val consistent =
            (diagnostic (2, fn _ => ["checking consistency of ", comp_name]);
d262 3
a264 1
             case Unix.mtime mo_name of
d266 1
a266 3
               Unix.NOT_EXIST =>
                 (diagnostic (2, fn _ => [mo_name, " doesn't exist"]);
                  false)
d268 4
a271 1
            | Unix.EXISTS mo_time =>
d273 1
a273 4
                if NewMap.apply_default' (up_to_date, false, comp_name) then
                  (diagnostic (2, fn _ => [comp_name, " cached as up to date"]);
                   true)
                else
d275 4
a278 1
                  case Unix.mtime filename of
d280 19
a298 3
                    Unix.NOT_EXIST =>
                      (diagnostic (2, fn _ => [filename, " doesn't exist, assuming up to date"]);
                       true)
d300 34
a333 9
                  | Unix.EXISTS source_time =>
                    let
		      val consistency =
			NewMap.YES(Encapsulate.input_info mo_name)
                        handle Encapsulate.BadInput s =>
                          (Info.error error_info
			   (Info.WARNING, Info.Location.FILE mo_name,
			    s ^ " -- treating as out of date");
			   NewMap.NO)
d335 18
a352 9
		    in
		      case consistency of
			NewMap.NO => false
		      | NewMap.YES{consistency, ...} =>
			  let
			    val (source_stamp, subs) =
			      case consistency of
				[] => crash ("missing consistency info in " ^ mo_name)
			      | (_, source_stamp) :: subs => (source_stamp, subs)
a353 48
			    fun check [] = true
			      | check ((sub_name, sub_stamp)::rest) =
				let
				  val sub_mo = relative_mo (path, sub_name)
				in
				  if
				    case Unix.mtime sub_mo of
				      Unix.EXISTS sub_time => MLWorks.Time.Real.equal (sub_time, sub_stamp)
				    | Unix.NOT_EXIST => crash (sub_mo ^ " missing")
				    then
				      check rest
				  else
				    (diagnostic (2, fn _ => [mo_name, " is out of date wrt ", sub_name]);
				     false)
				end
			  in
			    if MLWorks.Time.Real.equal (source_time, source_stamp) then
			      if check subs then
				(diagnostic (2, fn _ => [comp_name, " is up to date!"]);
				 true)
			      else
				(diagnostic (2, fn _ => [comp_name, " is out of date wrt depedencies"]);
				 false)
			    else
			      (diagnostic (2, fn _ => [comp_name, " is out of date wrt source"]);
			       false)
			  end
                    end)

          val up_to_date = NewMap.define (up_to_date, comp_name, true)
        in
          if consistent then
            recompile'
	      error_info
	      options
	      (cache, rest, done, up_to_date, doing)
          else
            recompile'
	      error_info
	      options
	      (compile error_info (options, cache, filename),
               rest,
	       NewMap.define (done, comp_name, true),
               up_to_date,
	       doing
	      )
        end

d356 20
a375 7
    fun recompile error_info options filename =
      (recompile'
	 error_info
	 options
	 (TopLevel.empty_cache, [filename], empty_map, empty_map, []);
       Print.print"Up to date\n"
      )
@


1.29
log
@Lexer.getToken now takes an options parameter.
@
text
@d4 3
d134 1
d153 1
a153 1
	case Lexer.getToken error_info (options,ts) of
d155 1
a155 1
	    (case Lexer.getToken error_info (options,ts) of
d157 1
a157 1
	         (case Lexer.getToken error_info (options,ts) of
@


1.28
log
@Signature revisions
@
text
@d4 3
d122 1
d148 2
a149 2
    fun get_imports_from_stream (error_info, ts, imports) =
	case Lexer.getToken error_info ts of
d151 1
a151 1
	    (case Lexer.getToken error_info ts of
d153 1
a153 1
	         (case Lexer.getToken error_info ts of
d157 1
a157 1
		    Info.error' Info.default_options
d161 2
a162 1
		  get_imports_from_stream (error_info, ts, filename :: imports)
d165 1
a165 1
		 Info.error' Info.default_options
d172 1
a172 1
    fun get_imports error_info filename =
d176 1
a176 1
	val imports = get_imports_from_stream (error_info, ts, [])
d229 1
a229 1
	  val imports = get_imports error_info filename
@


1.27
log
@Options & Info changes
@
text
@d4 3
a97 1
require "../utils/diagnostic";
d103 2
d112 1
d117 2
a118 1
                  sharing Encapsulate.BasisTypes = TopLevel.BasisTypes
d120 2
a123 1
    structure MirTypes = TopLevel.MirTypes
d125 1
a125 1
    structure Lexer = TopLevel.Parser.Lexer
d127 1
a127 1
    structure Options = MirTypes.Debugger_Types.Options
@


1.26
log
@Added more information to circular require structure error, now gives
list of file names
@
text
@d4 4
a116 1
    structure Info = MirTypes.Debugger_Types.Info
d119 2
d137 2
a138 2
    fun get_imports_from_stream (info_opts, ts, imports) =
	case Lexer.getToken info_opts ts of
d140 1
a140 1
	    (case Lexer.getToken info_opts ts of
d142 1
a142 1
	         (case Lexer.getToken info_opts ts of
d150 1
a150 1
		  get_imports_from_stream (info_opts, ts, filename :: imports)
d160 1
a160 1
    fun get_imports info_opts filename =
d164 1
a164 1
	val imports = get_imports_from_stream (info_opts, ts, [])
d187 2
a188 2
	  info_opts
	  compiler_opts
d192 2
a193 2
          info_opts
	  compiler_opts
d206 1
a206 1
		info_opts
d217 1
a217 1
	  val imports = get_imports info_opts filename
d237 2
a238 2
	      info_opts
	      compiler_opts
d268 1
a268 1
                          (Info.error info_opts
d316 2
a317 2
	      info_opts
	      compiler_opts
d321 3
a323 3
	      info_opts
	      compiler_opts
	      (compile info_opts (compiler_opts, cache, filename),
d333 1
a333 1
    fun recompile info_opts compiler_opts filename =
d335 2
a336 2
	 info_opts
	 compiler_opts
@


1.25
log
@Added better error messages when syntax errors found in require expressions.
@
text
@d4 3
d204 3
a206 1
		 "Circular require structure"
@


1.24
log
@Typechecker structure changes
@
text
@d4 3
d120 2
a121 1
      (fn (verbosity, stream) => (output (stream, "Recompile "); output_function (verbosity, stream)))
d124 2
a125 1
      Info.error' Info.default_options (Info.FAULT, Info.Location.UNKNOWN, "Recompile: " ^ message)
d136 1
a136 3
		      get_imports_from_stream (info_opts,
					       ts,
					       filename :: imports)
d138 5
a142 1
		     crash "Recompile: missing ; after require"
d145 4
a148 1
		 crash "Recompile: expected to find string following require"
d155 1
a155 1
        val ts = Lexer.mkFileTokenStream (stream, "input to recompile")
@


1.23
log
@Put a handle Io _ around get_imports to avoid unwanted exceptions
at that stage
@
text
@d4 4
d102 2
@


1.22
log
@Added the missing rev at the end of get_imports_from_stream
@
text
@d4 3
d144 1
a144 1
      end
@


1.21
log
@The version of get_imports_from_stream that I checked in last night was
totally broken, so I fixed it.  Also, the lexer version is *7 times*
slower, so we now require "require"s to come at the start of the file.
@
text
@d4 5
d131 1
a131 1
	| _ => imports
@


1.20
log
@Now uses lexer to search for require declarations.
@
text
@d4 3
d110 1
a110 3
    fun get_imports_from_stream info_opts stream =
      let val ts = Lexer.mkFileTokenStream (stream, "input to recompile")
      in
d115 8
a122 1
		 filename :: get_imports_from_stream info_opts stream
d124 1
a124 1
		 get_imports_from_stream info_opts stream
d126 1
a126 2
	| _ => get_imports_from_stream info_opts stream
      end
d131 2
a132 1
	val imports = get_imports_from_stream info_opts stream
@


1.19
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d72 1
d86 2
a87 1
                  structure Diagnostic	: DIAGNOSTIC) : RECOMPILE =
d92 1
d105 1
a105 2
    fun compile options x =
      TopLevel.compile_file' options x
d107 13
a119 38
    fun get_short_line (_, 0) = []
      | get_short_line (stream, n) =
	if end_of_stream stream then
          []
	else
	  let
	    val char = input(stream, 1)
	  in
	    if char = "\n" then
              []
	    else
              char :: get_short_line(stream, n-1)
	  end

    fun get_imports_from_stream stream =
      if end_of_stream stream then
	[]
      else
	(case implode (get_short_line (stream, 7)) of
	   "require" =>
	     let
	       val line = MLWorks.IO.input_line stream
	       val rest_line = Io.ignore_spaces(explode line)
	       val (starts_quote, rest_line) = case rest_line of
		 "\"" :: rest => (true, rest)
	       | _ => (false, rest_line)
	     in
	       if starts_quote andalso Io.strip_to_quote rest_line then
		 Io.extract_path line :: get_imports_from_stream stream
	       else
		 get_imports_from_stream stream
	     end
	 | foo =>
	     ((if size foo >= 7 then
		 Io.ignore_line stream
	       else ());
		 get_imports_from_stream stream))
	   handle Io _ => []
d121 1
a121 1
    fun get_imports filename =
d124 1
a124 1
	val imports = get_imports_from_stream stream
d147 1
a147 1
	  options
d152 1
a152 1
          options
d165 6
a170 1
              Info.error' Info.default_options (Info.FATAL, Info.Location.FILE comp_name, "Circular require structure")
d175 1
a175 1
	  val imports = get_imports filename
d195 1
a195 1
	      options
d226 1
a226 1
                          (Info.error Info.default_options
d274 1
a274 1
	      options
d279 1
a279 1
	      options
d281 1
a281 1
	      (compile options (compiler_opts, cache, filename),
@


1.18
log
@Modified handling of corrupt .mo files to force recompilation
instead of halting compilation
@
text
@d4 4
d85 1
a85 1
    structure Info = MirTypes.Info
@


1.17
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d4 3
d158 3
a160 1
	(NewMap.apply'(done, x); true) handle NewMap.Undefined => requires_in_done_list(xs, done)
d194 3
a196 2
	     ((NewMap.apply' (up_to_date, Io.compilation_name x);
	       false) handle NewMap.Undefined => true))
d234 2
a235 2
                      val {consistency, ...} =
                        Encapsulate.input_info mo_name
d237 4
a240 1
                          Info.error' Info.default_options (Info.FATAL, Info.Location.FILE mo_name, s)
d242 9
a250 4
                      val (source_stamp, subs) =
                        case consistency of
                          [] => crash ("missing consistency info in " ^ mo_name)
                        | (_, source_stamp) :: subs => (source_stamp, subs)
d252 27
a278 26
                      fun check [] = true
                        | check ((sub_name, sub_stamp)::rest) =
                          let
                            val sub_mo = relative_mo (path, sub_name)
                          in
                            if
                              case Unix.mtime sub_mo of
                                Unix.EXISTS sub_time => MLWorks.Time.Real.equal (sub_time, sub_stamp)
                              | Unix.NOT_EXIST => crash (sub_mo ^ " missing")
                            then
                              check rest
                            else
                              (diagnostic (2, fn _ => [mo_name, " is out of date wrt ", sub_name]);
                               false)
                          end
                    in
                      if MLWorks.Time.Real.equal (source_time, source_stamp) then
                        if check subs then
                          (diagnostic (2, fn _ => [comp_name, " is up to date!"]);
                           true)
                        else
                          (diagnostic (2, fn _ => [comp_name, " is out of date wrt depedencies"]);
                           false)
                      else
                        (diagnostic (2, fn _ => [comp_name, " is out of date wrt source"]);
                         false)
@


1.16
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d77 2
a78 1
    structure Info = TopLevel.Parser.Lexer.Info
d92 2
a93 1
    fun compile options x = TopLevel.compile_file' options x
d157 9
a165 2
    fun recompile options (cache, [], done, up_to_date, _) = (done, up_to_date)
      | recompile options (cache, name :: rest, done, up_to_date, doing) =
d199 4
a202 1
	    recompile options (cache, imports_to_do, done, up_to_date, comp_name :: doing))
d269 4
a272 1
            recompile options (cache, rest, done, up_to_date, doing)
d274 9
a282 3
            recompile options (compile options (cache, filename),
                               rest, NewMap.define (done, comp_name, true),
                               up_to_date, doing)
d287 7
a293 3
    val recompile = fn (options: TopLevel.Parser.Lexer.Info.options) => fn filename =>
      (recompile options (TopLevel.empty_cache, [filename], empty_map, empty_map, []);
       Print.print"Up to date\n")
@


1.15
log
@Removed Info structure from parser, tidied upderived
@
text
@d4 3
a83 16
    val dummy_stream = Info.Stream.outstream{output = fn s => output(std_out,s),
                                             flush_out = fn () => (),
                                             close_out = fn () => ()}
    
    val default_options = Info.OPTIONS {error = {outstream = dummy_stream,
                                                 stop = Info.FATAL,
                                                 report = Info.ADVICE,
                                                 worst = ref Info.ADVICE},
                                        information = {outstream = dummy_stream,
                                                       level = 2},
                                        listing = {outstream = dummy_stream,
                                                   level = 2},
                                        diagnostic = {outstream = dummy_stream,
                                                      level = 2}}


d85 1
a85 1
      Info.error' default_options (Info.FAULT, Info.Location.UNKNOWN, "Recompile: " ^ message)
d87 1
a87 1
    fun compile x = TopLevel.compile_file' x
d151 2
a152 2
    fun recompile (cache, [], done, up_to_date, _) = (done, up_to_date)
      | recompile (cache, name :: rest, done, up_to_date, doing) =
d163 1
a163 1
              Info.error' default_options (Info.FATAL, Info.Location.FILE comp_name, "Circular require structure")
d186 1
a186 1
	    recompile (cache, imports_to_do, done, up_to_date, comp_name :: doing))
d215 1
a215 1
                          Info.error' default_options (Info.FATAL, Info.Location.FILE mo_name, s)
d253 1
a253 1
            recompile (cache, rest, done, up_to_date, doing)
d255 3
a257 3
            recompile (compile (cache, filename),
                       rest, NewMap.define (done, comp_name, true),
                       up_to_date, doing)
d262 2
a263 2
    val recompile = fn filename =>
      (recompile(TopLevel.empty_cache, [filename], empty_map, empty_map, []);
@


1.14
log
@Changed Error structure to Info
@
text
@d4 3
d70 1
a70 1
    structure Info = TopLevel.Parser.Info
@


1.13
log
@Changes to pervasives and representation of time.
@
text
@d4 3
d67 1
a67 1
    structure Error = TopLevel.Parser.Error
d78 16
d95 1
a95 1
      Error.report' (Error.ERROR (Error.FAULT, Error.Location.UNKNOWN, "Recompile: " ^ message))
d173 1
a173 2
              Error.report'
              (Error.ERROR (Error.FATAL, Error.Location.FILE comp_name, "Circular require structure"))
d225 1
a225 2
                          Error.report'
                          (Error.ERROR (Error.FATAL, Error.Location.FILE mo_name, s))
@


1.12
log
@Removed Error from toplevel signature
@
text
@d4 3
d47 1
d61 2
a62 1
                  structure Io		: IO) : RECOMPILE =
d65 1
d67 3
a69 1
    fun compile x = TopLevel.compile_file x
d71 13
a83 3
    fun get_short_line(_, 0) = []
      | get_short_line(stream, n) =
	if end_of_stream stream then []
d88 4
a91 2
	    if char = "\n" then []
	    else char :: get_short_line(stream, n-1)
d98 1
a98 1
	(case implode(get_short_line(stream, 7)) of
d128 9
a136 9
      fun relative_mo (path, name) =
	let
	  val root = Io.root_name (Io.compilation_name name)
	in
	  if Lists.member (root, Io.pervasive_names) then
	    Io.mo_name(Io.relative_name(!TopLevel.pervasive_library_dir, root))
	  else
	    Io.relative_name(path, Io.mo_name name)
	end
d142 2
a143 2
    fun recompile([], done, up_to_date, _) = (done, up_to_date)
      | recompile(name :: rest, done, up_to_date, doing) =
d145 2
d161 1
d164 1
d171 1
d173 4
a176 1
	    recompile (imports_to_do, done, up_to_date, comp_name :: doing)
d178 1
a178 33
          val (do_file, mo_time, done, up_to_date) =
            let
              val comp_name = Io.compilation_name name
              val (exists, mo_time as {hi, lo}) =
                case Unix.mtime mo_name of
                  Unix.EXISTS mo_time => (true, mo_time)
                | _ => (false, {hi=0, lo=0})
            in
              if comp_name = Io.builtin_library_name orelse
                Lists.member (comp_name, Io.pervasive_names) then
                (not exists, mo_time, done, up_to_date)
              else
                (* If the file isn't pervasive and is out of date relative *)
                (* to the pervasive library or the pervasive library is *)
                (* nonexistent then do something. *)
                let
                  val pervasive_library =
                    Io.relative_name(!TopLevel.pervasive_library_dir, Io.pervasive_library_name)
                in
                  case Unix.mtime (Io.mo_name pervasive_library) of
                    Unix.EXISTS {hi=hi', lo=lo'} =>
                      (not exists orelse 
                       (hi' > hi orelse (hi = hi' andalso lo' > lo)),
                       mo_time, done, up_to_date)
                  | _ => 
                      let
                        val (done, up_to_date) =
                          recompile ([pervasive_library], done, up_to_date, doing)
                      in
                        (true, mo_time, done, up_to_date)
                      end
                end
            end
d180 2
a181 56
	  val do_file =
            do_file orelse
	    (* Compile if mo_name doesn't exist or recompiled some requires *)
	    (* or out of date with some requires *)
	    ((NewMap.apply'(up_to_date, comp_name);
	      false) handle NewMap.Undefined =>
	     let
	       val {consistency, ...} =
		 Encapsulate.input_info mo_name
		 handle Encapsulate.BadInput s =>
                   Error.report'
                   (Error.ERROR (Error.FATAL, Error.Location.FILE mo_name, s))
	       val (stamp, rest) = case consistency of
		 [] => ({hi=0, lo=0}, [])
	       | (_, (hi, lo)) :: rest => ({hi=hi, lo=lo}, rest)
	       fun check_require(require_name, (time, _)) =
		 let
		   val rel_name = relative_mo (path, require_name)
		   val req_mo_time =
		     case Unix.mtime rel_name of
		       Unix.EXISTS mo_stamp => mo_stamp
		     | _ => Crash.impossible("mo file missing for require '" ^
					      require_name ^ "'\n")
		   val {consistency, ...} =
		     Encapsulate.input_info rel_name
		     handle Encapsulate.BadInput s =>
                       Error.report'
                       (Error.ERROR (Error.FATAL, Error.Location.FILE rel_name, s))
		   val stamp = case consistency of
		     [] => 0
		   | (_, (time, _)) :: _ => time
		 in
		   time <> stamp orelse
		   (case (mo_time, req_mo_time) of
		      ({hi=hi, lo=lo}, {hi=hi', lo=lo'}) =>
			hi' > hi orelse (hi' = hi andalso lo' > lo))
		 (* recompile if mo for require newer than mo for requirer *)
		 end
	     in
               (case Unix.mtime filename of
                  Unix.EXISTS i => i <> stamp
                | _ => false) orelse
	       requires_in_done_list(map Io.compilation_name import_names,
				     done)
	       orelse Lists.exists check_require rest
	     end)
	  val done =
	    if (not do_file) then 
	      done
	    else
	      NewMap.define(done, comp_name, 0)
	  val up_to_date = NewMap.define(up_to_date, comp_name, 0)
	  val _ = if do_file then compile filename else ()
	in
	  recompile(rest, done, up_to_date, doing)
	end
d183 70
d256 1
a256 1
      (recompile([filename], empty_map, empty_map, []);
@


1.11
log
@Installed central error reporting mechanism.
Moved the special names out of the compiler as a whole.
@
text
@d4 4
d59 1
a59 1
    structure Error = TopLevel.Error
@


1.10
log
@Added bytearray and bits to pervasive modules.
@
text
@d4 3
d46 8
a53 10
functor Recompile(
  structure Print : PRINT
  structure NewMap : NEWMAP
  structure Lists : LISTS
  structure Crash : CRASH
  structure Unix : UNIX
  structure Encapsulate : ENCAPSULATE
  structure TopLevel : TOPLEVEL
  structure Io : IO
    ) : RECOMPILE =
d55 2
d104 9
a112 13
    fun get_full_name (path, name) =
      let
	val c_name = Io.compilation_name name
      in
	if
	  c_name = "__pervasive_library" orelse c_name = "mlworks" orelse
	  c_name = "string" orelse c_name = "array" orelse c_name = "bytearray" orelse
          c_name = "bits"
	then
	  Io.mo_name(Io.relative_name(!TopLevel.pervasive_library_dir, c_name))
	else
	  Io.relative_name(path, Io.mo_name name)
      end
a117 2
    exception STOP

d122 4
a125 1
	  val comp_name = Io.compilation_name filename (* Minus the .sml bit *)
d128 2
a129 3
	      (Print.print
	       ("File '" ^ filename ^
		"' being compiled has circular require structure"); raise STOP)
d132 1
a132 5
	  val source_time = case Unix.mtime filename of
	    Unix.EXISTS i => i
	  | _ => (Print.print("File '" ^ filename ^ "' being compiled does not exist"); raise STOP)
	  val pervasive_library_mo = Io.mo_name (Io.relative_name(!TopLevel.pervasive_library_dir, "__pervasive_library"))
	  val object_name = Io.mo_name name
a134 1
	  val path = Io.compilation_path filename
d136 1
a136 3
	    map
	    (fn name => Io.relative_name(path, name))
	    imports
d140 1
a140 1
	     ((NewMap.apply'(up_to_date, Io.compilation_name x);
d144 36
a179 22
	    recompile(imports_to_do, done, up_to_date, comp_name :: doing)
	  val mo_time = Unix.mtime object_name
	  val pervasive_library_has_been_changed =
	    (case Io.compilation_name name of
	       "__builtin_library" => false
	     | "__pervasive_library" => false
	     | "mlworks" => false
	     | "string" => false
	     | "array" => false
             | "bytearray" => false
             | "bits" => false
	     | _ => true)
	    andalso
	    (case (Unix.mtime pervasive_library_mo, mo_time) of
	       (Unix.EXISTS{hi, lo}, Unix.EXISTS{hi=hi', lo=lo'}) =>
		 hi > hi' orelse (hi = hi' andalso lo > lo')
	     | (Unix.EXISTS _,_) => false
	     | _ => Crash.impossible "Can't find the pervasive_library file")
	  val (do_file, mo_time) =
	    case mo_time of
	      Unix.EXISTS mo_time => (false, mo_time)
	    | _ => (true, {hi=0, lo=0})
d181 2
a182 2
	    pervasive_library_has_been_changed orelse do_file orelse
	    (* Compile if mo doesn't exist or recompiled some requires *)
d188 4
a191 2
		 Encapsulate.input_info object_name
		 handle Encapsulate.BadInput s => (Print.print s; raise STOP)
d197 1
a197 1
		   val rel_name = get_full_name(path, require_name)
d205 3
a207 1
		     handle Encapsulate.BadInput s => (Print.print s; raise STOP)
d219 3
a221 1
	       stamp <> source_time orelse
d240 2
a241 11
      let
	val lib_name =
	  Io.sml_name(Io.relative_name(!TopLevel.pervasive_library_dir,
					"__pervasive_library"))
	val (done, up_to_date) =
	  recompile([lib_name],
		    empty_map, empty_map, [])
	val _ = recompile([filename], done, up_to_date, [])
      in
	Print.print"Up to date\n"
      end
@


1.9
log
@Added circularity detection for requires
@
text
@d4 3
d107 2
a108 1
	  c_name = "string" orelse c_name = "array"
d161 2
@


1.8
log
@Made changes to allow relocation of mo files.
@
text
@d4 3
d117 2
a118 2
    fun recompile([], done, up_to_date) = (done, up_to_date)
      | recompile(name :: rest, done, up_to_date) =
d121 8
d147 2
a148 2
	  val (done, up_to_date) = recompile(imports_to_do, done, up_to_date)
	  val comp_name = Io.compilation_name filename (* Minus the .sml bit *)
d216 1
a216 1
	  recompile(rest, done, up_to_date)
d223 3
d227 3
a229 3
	  recompile([Io.sml_name (Io.relative_name(!TopLevel.pervasive_library_dir, "__pervasive_library"))],
		    empty_map, empty_map)
	val _ = recompile([filename], done, up_to_date)
@


1.7
log
@Changed to use MLWorks.IO.input_line
@
text
@d4 3
d57 2
a58 4
	    if char = "\n" then
	      []
	    else
	      char :: get_short_line(stream, n-1)
a89 1
	val _ = close_in stream
d91 1
d95 13
d110 1
a110 2
	(NewMap.apply'(done, x);
	 true) handle NewMap.Undefined => requires_in_done_list(xs, done)
d121 1
a121 1
	  val pervasive_library_mo = Io.mo_name (!TopLevel.pervasive_library_path)
d172 1
a172 2
		   val rel_name =
		     Io.mo_name(Io.relative_name(path, require_name))
d213 1
a213 1
	  recompile([Io.sml_name (! TopLevel.pervasive_library_path)],
@


1.6
log
@Changed to use new Encapsulate interface.
@
text
@d4 3
d67 1
a67 1
	       val line = Io.input_line stream
@


1.5
log
@String structure is now pervasive, added mlworks.sml,
string.sml and array.sml to the list of pervasive
library modules.
@
text
@d4 5
d96 2
d104 2
a105 3
	  | _ => Crash.impossible("File '" ^ filename ^
				   "' being compiled does not exist")
	  val pervasive_library_mo = Io.mo_name (! TopLevel.pervasive_library_path)
d148 4
a151 4
	       val Encapsulate.TOTAL_INPUT{consistency=cons, ...} =
		 Encapsulate.input_file object_name
	       val cons = Encapsulate.decode_cons cons
	       val (stamp, rest) = case cons of
d163 4
a166 4
		   val Encapsulate.TOTAL_INPUT{consistency=cons, ...} =
		     Encapsulate.input_file rel_name
		   val cons = Encapsulate.decode_cons cons
		   val stamp = case cons of
@


1.4
log
@Improved get_imports_from_stream
@
text
@d4 3
a17 1
require "../utils/string";
a28 1
  structure String : STRING
d121 3
a123 1
	     | "__callc_codes" => false
@


1.3
log
@Encapsulator has had its datastructures changed
@
text
@d4 3
d38 13
d55 20
a74 25
	let
	  val line = Io.input_line stream   (* all of string *)
	in
	  if size line > 7
	    then
	      if String.substring (line,0,7) = "require" andalso
		let
		  val rest_line =
		    explode(String.substring(line, 7, size line - 7))
		  val rest_line = Io.ignore_spaces rest_line
		  val starts_quote = case rest_line of
		    "\"" :: rest => true
		  | _ => false
		  val rest_line =
		    if starts_quote then Lists.tl rest_line else rest_line
		in
		  Io.strip_to_quote rest_line
		end
		then                       (* go for it *)
		  Io.extract_path line :: get_imports_from_stream stream
	      else
		get_imports_from_stream stream
	  else
	    get_imports_from_stream stream
	end
@


1.2
log
@input_line needed to be Io.input_line
@
text
@d128 1
a128 1
	       val Encapsulate.TOTAL_OUTPUT{consistency=cons, ...} =
d143 1
a143 1
		   val Encapsulate.TOTAL_OUTPUT{consistency=cons, ...} =
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d40 1
a40 1
	  val line = input_line stream   (* all of string *)
@
