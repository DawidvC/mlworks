head	1.3;
access;
symbols
	ML_final_beta_release_02/03/94:1.3
	mlworks-28-01-1994:1.3
	Release:1.3
	mlworks-beta-01-09-1993:1.3
	MLWorks-1-0-4-29/01/1993:1.3
	MLWorks-1-0-3-21/12/1992:1.3
	MLWorks-1-0-2-15/12/1992:1.3
	MLWorks-1-0-1-04/12/1992:1.3
	checkpoint_17_08_92:1.3;
locks; strict;


1.3
date	92.05.13.11.09.08;	author jont;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	92.01.02.12.31.27;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.12.23.17.55.09;	author jont;	state Exp;
branches;
next	;

1.3.1.1
date	92.05.13.11.09.08;	author jont;	state Exp;
branches;
next	;


desc
@First attempt at make system checking time stamp consistency
@


1.3
log
@Modified for two integer time stamps
@
text
@(* _compilesome.sml the functor *)
(*
$Log: _compilesome.sml,v $
Revision 1.2  1992/01/02  12:31:27  jont
Improved compilesome to force recompilation if a dependent is being
recompiled. Added recompilesome to recompile when the total compilation
order is already known, ie without recompiling.

Revision 1.1  1991/12/23  17:55:09  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "unix";
require "../utils/crash";
require "../utils/lists";
require "../main/encapsulate";
require "compileall";

functor CompileSome(
  structure Crash : CRASH
  structure Lists : LISTS
  structure Unix : UNIX
  structure Encapsulate : ENCAPSULATE
) =
struct

  fun mo_name filename = root_name filename ^ ".mo"

  fun compile_from_names(compile_script, names) =
    let
      fun check_stamp(files_so_far, filename) =
	let
	  val stamp = case Unix.mtime filename of
	    Unix.EXISTS i => i
	  | _ => Crash.impossible("File '" ^ filename ^ "' no longer exists")
	  val mo_name = mo_name filename
	  val mo_exists = case Unix.mtime mo_name of
	    Unix.EXISTS _ => true
	  | _ => false
	  fun in_list([], _) = false
	  | in_list(x :: xs, the_list) =
	    Lists.member(x, the_list) orelse in_list(xs, the_list)
	in
	  (not mo_exists) orelse
	  let
	    val Encapsulate.TOTAL_OUTPUT{consistency=cons, ...} =
	      Encapsulate.input_file mo_name
	    val (_, (st1, st2)) = case Encapsulate.decode_cons cons of
	      x :: _ => x
	    | _ => Crash.impossible("Consistency information missing from '" ^
				    mo_name ^ "'")
	    val rest_names = case Encapsulate.decode_cons cons of
	      _ :: x => map (sml_name o #1) x
	    | _ => Crash.impossible("Consistency information missing from '" ^
				    mo_name ^ "'")
	    in
	      {hi=st1, lo=st2} <> stamp orelse
	      in_list(rest_names, files_so_far)
	  end
	end
      fun do_names([], done) = rev done
      | do_names(x :: xs, done) =
	do_names(xs, if check_stamp(done, x) then x :: done else done)
      val names_to_do = do_names(names, [])
    in
      mapprint (fn x => "compile\"" ^ x ^ "\";\n") compile_script names_to_do
    end

  val names = ref [] : string list ref

  fun compilesome(topfile, compile_script) =
    let
      val _ = names := mkFilelist(topfile, [])
    in
      compile_from_names(compile_script, !names)
    end

  fun recompilesome compile_script = compile_from_names(compile_script, !names)

end
@


1.3.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.3  1992/05/13  11:09:08  jont
Modified for two integer time stamps

@


1.2
log
@Improved compilesome to force recompilation if a dependent is being
recompiled. Added recompilesome to recompile when the total compilation
order is already known, ie without recompiling.
@
text
@d4 5
d59 2
a60 1
	      st1 <> stamp orelse in_list(rest_names, files_so_far)
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d26 1
a26 1
  fun compilesome(topfile, compile_script) =
d28 1
a28 2
      val names = mkFilelist(topfile, [])
      fun check_stamp filename =
d37 3
d49 4
d54 1
a54 1
	      st1 <> stamp
d57 4
a60 1
      val names_to_do = Lists.filterp check_stamp names
d64 12
@
