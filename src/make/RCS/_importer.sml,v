head	1.21;
access;
symbols
	MLWorks_20m1_1997_10_23:1.21
	MLWorks_11r1:1.21.5.1.1.1.1
	MLWorks_workspace_97:1.21.7
	MLWorks_dt_wizard:1.21.6
	MLWorks_11c0_1997_09_09:1.21.5.1.1.1
	MLWorks_10r3:1.21.5.1.3
	MLWorks_10r2_551:1.21.5.1.2
	MLWorks_11:1.21.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.21.5.1
	MLWorks_20m0_1997_06_20:1.21
	MLWorks_1_0_r2c2_1997_06_14:1.21.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.21.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.21.5
	MLWorks_BugFix_1997_04_24:1.21
	MLWorks_1_0_r2_Win32_1997_04_11:1.21
	MLWorks_1_0_r2_Unix_1997_04_04:1.21
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.21.3.1.1
	MLWorks_gui_1996_12_18:1.21.4
	MLWorks_1_0_Win32_1996_12_17:1.21.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.21.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.21.1.1
	MLWorks_1_0_Irix_1996_11_28:1.21.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.21.2
	MLWorks_1_0_Unix_1996_11_14:1.21.1
	MLWorks_Open_Beta2_1996_10_11:1.20.3
	MLWorks_License_dev:1.20.2
	MLWorks_1_open_beta_1996_09_13:1.20.1
	MLWorks_Open_Beta_1996_08_22:1.20
	MLWorks_Beta_1996_07_02:1.20
	MLWorks_Beta_1996_06_07:1.20
	MLWorks_Beta_1996_06_06:1.20
	MLWorks_Beta_1996_06_05:1.20
	MLWorks_Beta_1996_06_03:1.20
	MLWorks_Beta_1996_05_31:1.20
	MLWorks_Beta_1996_05_30:1.20
	ML_beta_release_12/08/94:1.17
	ML_beta_release_03/08/94:1.17
	ML_revised_beta_release_25/05/94:1.17
	ML_final_beta_release_02/03/94:1.16
	mlworks-28-01-1994:1.16
	Release:1.15
	mlworks-beta-01-09-1993:1.15
	MLWorks-1-0-4-29/01/1993:1.15
	MLWorks-1-0-3-21/12/1992:1.15
	MLWorks-1-0-2-15/12/1992:1.15
	MLWorks-1-0-1-04/12/1992:1.15
	checkpoint_17_08_92:1.13
	Ten15_release_21-08-91:1.9
	Ten15_release_19-08-91:1.9
	ten15_release:1.9;
locks; strict;
comment	@ * @;


1.21
date	96.10.29.14.13.32;	author io;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1
	1.21.4.1
	1.21.5.1
	1.21.6.1
	1.21.7.1;
next	1.20;

1.20
date	96.03.26.13.13.20;	author stephenb;	state Exp;
branches
	1.20.1.1
	1.20.2.1
	1.20.3.1;
next	1.19;

1.19
date	95.12.07.11.08.42;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	94.12.09.12.26.10;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	94.03.15.16.09.07;	author nickh;	state Exp;
branches;
next	1.16;

1.16
date	93.11.15.14.24.37;	author nickh;	state Exp;
branches;
next	1.15;

1.15
date	92.10.28.11.57.26;	author richard;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	92.08.26.14.51.47;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.08.10.15.29.14;	author davidt;	state Exp;
branches;
next	1.12;

1.12
date	92.08.07.15.02.58;	author davidt;	state Exp;
branches;
next	1.11;

1.11
date	92.05.13.11.23.41;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.11.21.16.29.20;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.06.24.15.52.50;	author colin;	state Exp;
branches;
next	1.8;

1.8
date	91.06.18.21.02.00;	author colin;	state Exp;
branches;
next	1.7;

1.7
date	91.06.14.19.08.00;	author colin;	state Exp;
branches;
next	1.6;

1.6
date	91.06.12.13.00.11;	author colin;	state Exp;
branches;
next	1.5;

1.5
date	91.06.11.17.56.31;	author colin;	state Exp;
branches;
next	1.4;

1.4
date	91.06.11.16.42.09;	author colin;	state Exp;
branches;
next	1.3;

1.3
date	91.06.10.17.30.48;	author colin;	state Exp;
branches;
next	1.2;

1.2
date	91.06.07.19.14.19;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.10.58.19;	author colin;	state Exp;
branches;
next	;

1.15.1.1
date	92.10.28.11.57.26;	author jont;	state Exp;
branches;
next	;

1.20.1.1
date	96.09.13.11.18.57;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.10.07.16.08.51;	author hope;	state Exp;
branches;
next	;

1.20.3.1
date	96.10.17.11.27.06;	author hope;	state Exp;
branches;
next	;

1.21.1.1
date	96.11.14.12.52.36;	author hope;	state Exp;
branches
	1.21.1.1.1.1;
next	;

1.21.1.1.1.1
date	96.11.28.15.03.36;	author hope;	state Exp;
branches;
next	;

1.21.2.1
date	96.11.22.18.11.42;	author hope;	state Exp;
branches;
next	;

1.21.3.1
date	96.12.17.17.50.13;	author hope;	state Exp;
branches
	1.21.3.1.1.1;
next	;

1.21.3.1.1.1
date	97.02.24.11.40.30;	author hope;	state Exp;
branches;
next	;

1.21.4.1
date	96.12.18.09.44.21;	author hope;	state Exp;
branches;
next	;

1.21.5.1
date	97.05.12.10.36.50;	author hope;	state Exp;
branches
	1.21.5.1.1.1
	1.21.5.1.2.1
	1.21.5.1.3.1;
next	;

1.21.5.1.1.1
date	97.07.28.18.22.07;	author daveb;	state Exp;
branches
	1.21.5.1.1.1.1.1;
next	;

1.21.5.1.1.1.1.1
date	97.10.07.11.47.45;	author jkbrook;	state Exp;
branches;
next	;

1.21.5.1.2.1
date	97.09.08.17.15.29;	author daveb;	state Exp;
branches;
next	;

1.21.5.1.3.1
date	97.09.09.14.11.22;	author daveb;	state Exp;
branches;
next	;

1.21.6.1
date	97.09.10.19.27.27;	author brucem;	state Exp;
branches;
next	;

1.21.7.1
date	97.09.11.20.57.26;	author daveb;	state Exp;
branches;
next	;


desc
@Make system for running on NJML
@


1.21
log
@moving String from toplevel
@
text
@(* _importer.sml the functor *)
(*
$Log: _importer.sml,v $
 * Revision 1.20  1996/03/26  13:13:20  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
 * Revision 1.19  1995/12/07  11:08:42  jont
 * Modify file_modified to raise an exception
 * if the file in question doesn't exist.
 *
Revision 1.18  1994/12/09  12:26:10  jont
Replace use of unix with generic os

Revision 1.17  1994/03/15  16:09:07  nickh
Ditch RCS stuff.

Revision 1.16  1993/11/15  14:24:37  nickh
Change to pervasive time structure.

Revision 1.15  1992/10/28  11:57:26  richard
Changes to pervasives and representation of time.

Revision 1.14  1992/08/26  14:51:47  richard
Rationalisation of the MLWorks structure.

Revision 1.13  1992/08/10  15:29:14  davidt
Changed MLworks structure to MLWorks

Revision 1.12  1992/08/07  15:02:58  davidt
Now uses the structure OldNewJersey to get the use function.

Revision 1.11  1992/05/13  11:23:41  jont
Modified for two integer time stamps

Revision 1.10  1991/11/21  16:29:20  jont
Added copyright message

Revision 1.9  91/06/24  15:52:50  colin
Made exportML return bool (as in original NJML defn) and print out who/when
saved image in next start up message

Added funny_stamps and check_funnies. Each time during a make a file is
recompiled which is older than the timestamp in the database a note is made
and a message at the end of the make is given warning user of all such files

Revision 1.8  91/06/18  21:02:00  colin
Added checkout_old : bool ref. Controls whether on seeing a file with a time
stamp earlier in database we should just recompile or try and checkout latest

Revision 1.7  91/06/14  19:08:00  colin
dependency list now includes a compilation count (make_counter). This fixes
bug with two separate makes from different parts of dependency tree but with
a common recompiled descendent. (second make was not causing a recompile)

Revision 1.6  91/06/12  13:00:11  colin
Fixed check_tree to set the time ref in the dependency list to 0 so that
in subsequent makes the module is recompiled even if errors have occurred 
during compilation of its children

Made children in the dependency list relative paths rather than absolute
paths. This allows images to be built and further developed in a different
source directory tree (typically checked out from main RCS source)


Revision 1.5  91/06/11  17:56:31  colin
Modified co_path to produce system command of form (cd xxxx; yyy zzzz)
instead of (yyy xxxx/zzzz)

Moved check-out message from function file_modified to co_path

Revision 1.4  91/06/11  16:42:09  colin
added reference co_command to allow switching of rcs checkout command

timestamp datatype now replaced by integer - the last modified time of the
file compiled for this module

added a bool ref in dependencies - flags when a module (+ descendents) has
been checked (previously done by CHECKED constructor in timestamp datatype)

added a bool ref - making. Ensures that requires are only done inside of a 
make command (ie not at top level). Necessary to ensure that checked flags
are reset between makes.

file_modified - now returns true if the time stamp on a file is different
(not just later) than in the dependency structure. Warns if time stamp is
earlier

exportML now knows about current directory and ~ (modified to use pathname
stuff + current directory like "use")

*** MAJOR CHANGE ***
Many of the above are details involved in changing the make system to record
in its database the timestamp of a file which is compiled rather than the
time of compilation. This makes things work much better with multiple people
using RCS. The caching of information to avoid repeatedly traversing the
dependency tree used to be tied in with the time stamps in the database.
This is no longer the case (replaced by the bool ref in dependency list)

Revision 1.3  91/06/10  17:30:48  colin
added automatic check out facility for rcs

Revision 1.2  91/06/07  19:14:19  colin
Updated to compare modules based on last component of pathname only
Removed old aliasing facility as no longer needed due to RCS

Revision 1.1  91/06/07  10:58:19  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

(*****
A make system for Standard ML.
*****)

functor Importer
  (structure OldOs    : OLD_OS
   structure PathName : PATHNAME) : IMPORTER =

struct

  fun print str =
    output(std_out, "[" ^ str ^ "]\n")

  val current_dir = ref (PathName.parseDirectory "")

  fun pwd () = PathName.directory_namestring (!current_dir)

  fun cd s =
    let
      val dir = PathName.parseDirectory s
      val _ = current_dir := PathName.resolveRelative (!current_dir, dir);
      val dir_name = pwd ()
      val _ = System.Directory.cd dir_name
    in
      dir_name
    end

  (*****
  Make a file into an absolute file name.
  *****)

  fun resolve_name (old_dir, name, ext) =
    let
      val pathname = PathName.parsePathName name
      val relative_pathname =
	case ext of 
	  "" => pathname
	| _ => PathName.modify_type (pathname,ext)
	  
      val dir =
	PathName.pathname_directory relative_pathname

      val new_dir =
	PathName.resolveRelative (old_dir, dir)

      val resolved_pathname =
	(PathName.modify_directory (relative_pathname, new_dir))
    in
      (resolved_pathname,relative_pathname)
    end

  fun resolve_sml_name name = resolve_name (!current_dir,name,".sml")
  
  (*****
  A new use function which is simply an alias for make.
  *****)

  fun use_path pathname =
    let 
      val old_dir = !current_dir
      val new_dir = PathName.pathname_directory pathname
      val namestring = PathName.pathname_namestring pathname
    in
      (current_dir := new_dir;
       (OldNewJersey.use namestring
	handle exn => (current_dir := old_dir ; raise exn));
       current_dir := old_dir)
    end

  fun use name =
    let
      val (pathname,_) = resolve_sml_name name
    in
      use_path pathname
    end

  (*****
   The files a file depends on.
   *****)

  type children = PathName.PathName list

  (*****
   The list of dependencies.
   *****)

  val dependencies :
    (string * (MLWorks.Time.time ref * int ref * children ref * bool ref)) list ref =
    ref nil

  (*****
   A reference to a reference to the children of the current file.
   *****)

  val current_children = ref (ref (nil : children))

  (*****
   Whether we're in the dynamic extent of make or not
   *****)

  val making = ref false

  val make_counter = ref 0

  val funny_stamps = ref (nil : PathName.PathName list)

  (*****
   Search for the entry associated with name in dependencies.
   ******
   A new entry for name is created is no entry is present.
   *****)

  fun search pathname [] =
      let
	val name = PathName.pathname_name pathname
	val entry = (ref MLWorks.Time.zero, ref ~1, ref [], ref false)
      in
	dependencies := (name,entry) :: !dependencies;
	entry
      end
    | search pathname ((name',entry) :: rest) =
      let 
	val name = PathName.pathname_name pathname
      in
	if (name = name')
	  then
	    entry
	else
	  search pathname rest
      end
	
  exception NotFound of string

  fun file_modified (pathname, build_time) =
    let
      val namestring = PathName.pathname_namestring pathname
    in
      case OldOs.mtime namestring of

	OldOs.EXISTS time => 
          MLWorks.Time.< (build_time, time) orelse
          if time = build_time then
            false
          else
            (print ("** Warning: Timestamp earlier than last build on \n " ^ namestring);
	     (print "** Recompiling" ;
	      funny_stamps := pathname :: (!funny_stamps);
	      true))

      | OldOs.NOT_EXIST => 
	   (*file_modified (pathname, build_time)*)
	  raise NotFound namestring
    end

  (* Check tree, when given a module (as a pathname), returns a boolean
     indicating whether or not that module is up to date. It can in thoery
     descend right through the dependency tree. It will stop when it finds
     something not up to date or when it knows everything has been checked
     (by use of the check ref in the dependency list) *)

  fun check_tree pathname =
    let
      val (time_ref as (ref build_time),
	   ref compiled,
	   ref children,
	   checked_ref as (ref checked)) = search pathname (!dependencies)
    in
      if checked 
	then
	  true
      else
	if compiled = !make_counter
	  then
	    true
	else
	  if file_modified (pathname, build_time)
	    then	  
	      (* easy this module changed - recompile it *)
	      false
	  else
	    (* don't know - better look at the children *)
	    if check_children (pathname,children)
	      then
		(* all the children (+ their children etc) are up to date -
		   cache the information for future checks *)
		(checked_ref := true ; true)
	    else
	      (* some descendent of this module needs recompiling or has been
	         recompiled so we better recompile this one *)
	      false
    end

  and check_children (pathname,children) =
    let
      val directory = PathName.pathname_directory pathname
      val (_,ref compiled,_,_) = search pathname (!dependencies)
	
      fun check_children' nil = true
	| check_children' (child :: children) =
	  let
	    val relative_directory = PathName.pathname_directory child
	    val absolute_directory = 
	      PathName.resolveRelative (directory,relative_directory)
	    val pathname' = 
	      PathName.modify_directory (child,absolute_directory)
	    val (_,ref compiled',_,_) = search pathname' (!dependencies)
	  in
	    if compiled' > compiled
	      then
		false
	    else
	      if check_tree pathname'
		then
		  check_children' children
	      else
		false
	  end
    in
      check_children' children
    end
    
  exception Require

  fun require name =
    if !making then
      let
	val (pathname,relative_pathname) = resolve_sml_name name
	val (time_ref, compiled_ref, children_ref, _) = 
	  search pathname (!dependencies)
	val up_to_date = check_tree pathname
	val _ =
	  if not up_to_date then
            let
              (* Preserve current children *)
              val local_children = !current_children
            in
              (* Reset dependencies for this file *)
              children_ref := nil;

              (* Use file (builds new dependencies) *)
              current_children := children_ref;

              (* we set its time ref to 0 so that if compilation fails it *)
              (* will be forced to be recompiled in subsequent makes *)

              time_ref := MLWorks.Time.zero;

              (use_path pathname) handle exn =>
                (current_children := local_children ; raise exn);

              (* Reset current children *)
              current_children := local_children;

              (* Mark this file as having been built *)
              (* it had better exist - we just compiled it !! *)
              let
                val OldOs.EXISTS mtime =
                  OldOs.mtime (PathName.pathname_namestring pathname)
              in
                time_ref := mtime;
                compiled_ref := !make_counter
              end
            end
          else 
            ()
      in	
	(* Add this import to the list of current children *)
	(!current_children) := relative_pathname :: !(!current_children)
      end
    else
      (print "** Error: require used at top level";
       raise Require)

  fun makeok name =
    let
      val (pathname,_) = resolve_sml_name name
      val (time_ref, compiled_ref, children_ref, checked_ref) =
	search pathname (!dependencies)
      val namestring = PathName.pathname_namestring pathname
      val OldOs.EXISTS mtime = OldOs.mtime namestring
    in
      time_ref := mtime
    end
  
  local
    val top_level_name = ref ""
  in
    fun check_funnies nil = ()
      | check_funnies pathnames = 
	(output (std_out,"\
\******************************************************************\n\
\*** The following files had a timestamp older than in previous ***\n\
\*** compilations and were recompiled. This should not happen ! ***\n\
\******************************************************************\n");
	 map (fn pathname => 
	      (output (std_out,"*** ");
	       output (std_out,PathName.pathname_namestring pathname);
	       output (std_out,"\n"))) pathnames;
	 ())
    
    fun make name =
      ((!current_children) := nil;

       (* reset the cache of checked and compiled modules from last make *)
       app (fn (_,(_,_,_,checked_ref)) => checked_ref := false)
       (!dependencies);

       make_counter := (!make_counter + 1);
	   
       making := true;
       funny_stamps := nil;
       top_level_name := name;
       (require name handle exn => (making := false ; raise exn));
       making := false;
       check_funnies (!funny_stamps);
       print "up to date")
      handle NotFound s =>
	print("file '" ^ s ^ "' not found")
      
    fun again () =
      let
	val name = !top_level_name
      in
	if name = "" then
	  print "error - no object to make again"
	else
	  make name
      end
  end

  (*****
  A new exportML which sets the current directory on entry.
  *****)

  local
    fun init_dir () = cd (OldOs.parse_environ "PWD")
  in
    fun exportML name = 
      let
	val (pathname,_) = resolve_name (!current_dir,name,"")
	val user = OldOs.username ()
	val date = 
	  substring (OldOs.date (),0,10)
	val name = PathName.pathname_name pathname
	val namestring = PathName.pathname_namestring pathname
	val banner = 
	  "\nSaved by " ^ user ^ " on " ^ date ^ " as " ^ name ^ "\n"
      in
	if OldNewJersey.exportML (PathName.pathname_namestring pathname)
	  then
	    (output (std_out,banner);
	     output (std_out,("Current directory is : " ^ init_dir () ^ "\n"));
	     true)
	else
	  false
      end
  end
end
@


1.21.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.21  1996/10/29  14:13:32  io
 * moving String from toplevel
 *
@


1.21.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.21  1996/10/29  14:13:32  io
 * moving String from toplevel
 *
@


1.21.5.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/10/29  14:13:32  io
 * moving String from toplevel
 *
@


1.21.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.21.5.1  1997/05/12  10:36:50  hope
 * branched from 1.21
 *
@


1.21.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.21.5.1  1997/05/12  10:36:50  hope
 * branched from 1.21
 *
@


1.21.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.21.5.1  1997/05/12  10:36:50  hope
 * branched from 1.21
 *
@


1.21.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.21.5.1.1.1  1997/07/28  18:22:07  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.21.4.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/10/29  14:13:32  io
 * moving String from toplevel
 *
@


1.21.3.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/10/29  14:13:32  io
 * moving String from toplevel
 *
@


1.21.3.1.1.1
log
@branched from 1.21.3.1
@
text
@a3 3
 * Revision 1.21.3.1  1996/12/17  17:50:13  hope
 * branched from 1.21
 *
@


1.21.2.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/10/29  14:13:32  io
 * moving String from toplevel
 *
@


1.21.1.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/10/29  14:13:32  io
 * moving String from toplevel
 *
@


1.21.1.1.1.1
log
@branched from 1.21.1.1
@
text
@a3 3
 * Revision 1.21.1.1  1996/11/14  12:52:36  hope
 * branched from 1.21
 *
@


1.20
log
@Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
the deprecated OS interface.
@
text
@d4 4
d455 1
a455 1
	  String.substring (OldOs.date (),0,10)
@


1.20.3.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/03/26  13:13:20  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
@


1.20.2.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/03/26  13:13:20  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/03/26  13:13:20  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
@


1.19
log
@Modify file_modified to raise an exception
if the file in question doesn't exist.
@
text
@d4 4
d114 1
a114 1
  (structure Os       : OS
d246 1
a246 1
      case Os.mtime namestring of
d248 1
a248 1
	Os.EXISTS time => 
d258 1
a258 1
      | Os.NOT_EXIST => 
d365 2
a366 2
                val Os.EXISTS mtime =
                  Os.mtime (PathName.pathname_namestring pathname)
d388 1
a388 1
      val Os.EXISTS mtime = Os.mtime namestring
d444 1
a444 1
    fun init_dir () = cd (Os.parse_environ "PWD")
d449 1
a449 1
	val user = Os.username ()
d451 1
a451 1
	  String.substring (Os.date (),0,10)
@


1.18
log
@Replace use of unix with generic os
@
text
@d4 3
d236 2
d255 2
a256 1
	   file_modified (pathname, build_time)
d421 2
@


1.17
log
@Ditch RCS stuff.
@
text
@d4 3
d107 1
a107 1
  (structure Unix     : UNIX
d237 1
a237 1
      case Unix.mtime namestring of
d239 1
a239 1
	Unix.EXISTS time => 
d249 1
a249 1
      | Unix.NOT_EXIST => 
d355 2
a356 2
                val Unix.EXISTS mtime =
                  Unix.mtime (PathName.pathname_namestring pathname)
d378 1
a378 1
      val Unix.EXISTS mtime = Unix.mtime namestring
d432 1
a432 1
    fun init_dir () = cd (Unix.parse_environ "PWD")
d437 1
a437 1
	val user = Unix.username ()
d439 1
a439 1
	  String.substring (Unix.date (),0,10)
@


1.16
log
@Change to pervasive time structure.
@
text
@d4 3
a152 30
   rcs check out
   *****)

  val co_command = ref "/usr/sml/tools/cout"

  fun co_path pathname =
    let 
      val directory = PathName.pathname_directory pathname
      val dirname = PathName.directory_namestring directory

      val name = PathName.pathname_name pathname
      val _ = print ("** Checking out " ^ name ^ " in " ^ dirname)
      val _ = MLWorks.OS.system ("cd " ^ dirname ^ "; " ^ !co_command ^ " " ^ name ^ ".sml");
    in
      (* hack to check if file exists *)
      case Unix.mtime (PathName.pathname_namestring pathname) of
	Unix.NOT_EXIST => raise (Io "Failure in rcs check out")
      | _ => ()
    end


  fun co name = 
    let
      val (pathname,_) = resolve_sml_name name
    in
      co_path pathname
    end

	
  (*****
d230 1
a230 1
  fun file_modified (pathname, build_time, checkout_old) =
d242 3
a244 7
             if checkout_old then
               (co_path pathname;
                file_modified (pathname, build_time, false))
             else
               (print "** Recompiling" ;
                funny_stamps := pathname :: (!funny_stamps);
                true))
d247 1
a247 2
	  (co_path pathname;
	   file_modified (pathname, build_time, false))
a255 2
  val checkout_old = ref true

d271 1
a271 1
	  if file_modified (pathname, build_time, !checkout_old)
@


1.15
log
@Changes to pervasives and representation of time.
@
text
@d4 3
d213 1
a213 1
    (string * (MLWorks.Time.Real.T ref * int ref * children ref * bool ref)) list ref =
d241 1
a241 1
	val entry = (ref MLWorks.Time.Real.zero, ref ~1, ref [], ref false)
d264 2
a265 2
          MLWorks.Time.Real.< (build_time, time) orelse
          if MLWorks.Time.Real.equal (time, build_time) then
d375 1
a375 1
              time_ref := MLWorks.Time.Real.zero;
@


1.15.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.15  1992/10/28  11:57:26  richard
Changes to pervasives and representation of time.

@


1.14
log
@Rationalisation of the MLWorks structure.
@
text
@d4 3
d209 3
a211 2
  val dependencies = 
    ref (nil : (string * ({hi:int, lo:int} ref * int ref * children ref * bool ref)) list)
d238 1
a238 1
	val entry = (ref {hi= ~1, lo= ~1}, ref ~1, ref [], ref false)
d254 1
a254 1
  fun file_modified (pathname,build_time as {hi=bhi, lo=blo},checkout_old) =
a258 17
	Unix.EXISTS(mtime as {hi=hi, lo=lo}) => 
	  hi > bhi orelse (hi = bhi andalso lo > blo)
	  orelse
	  if mtime = build_time 
	    then
	      false
	  else
	    (print ("** Warning: Timestamp earlier than last build on \n " ^ 
		    namestring);
	     if checkout_old
	       then
		 (co_path pathname;
		  file_modified (pathname,build_time,false))
	     else
	       (print "** Recompiling" ;
		funny_stamps := pathname :: (!funny_stamps);
		true))
d260 14
d275 2
a276 2
	  (co_path pathname ;
	   file_modified (pathname,build_time,false))
d302 1
a302 1
	  if file_modified (pathname,build_time,!checkout_old)
d358 7
a364 11
	  if not up_to_date
	    then
	      let
		(* Preserve current children *)
		val local_children = !current_children
	      in
		(* Reset dependencies for this file *)
		children_ref := nil;
		
		(* Use file (builds new dependencies) *)
		current_children := children_ref;
d366 2
a367 2
		(* we set its time ref to 0 so that if compilation fails it *)
		(* will be forced to be recompiled in subsequent makes *)
d369 23
a391 20
		time_ref := {hi=0, lo=0};
		
		(use_path pathname) handle exn =>
		  (current_children := local_children ; raise exn);
		  
		(* Reset current children *)
		current_children := local_children;
		  
		(* Mark this file as having been built *)
		(* it had better exist - we just compiled it !! *)
		let
		  val Unix.EXISTS mtime =
		    Unix.mtime (PathName.pathname_namestring pathname)
		in
		  time_ref := mtime;
		  compiled_ref := !make_counter
		end
	      end
	    else 
	      ()
@


1.13
log
@Changed MLworks structure to MLWorks
@
text
@d4 3
d156 1
a156 1
      val _ = MLWorks.System.system ("cd " ^ dirname ^ "; " ^ !co_command ^ " " ^ name ^ ".sml");
@


1.12
log
@Now uses the structure OldNewJersey to get the use function.
@
text
@d4 3
d153 1
a153 1
      val _ = MLworks.System.system ("cd " ^ dirname ^ "; " ^ !co_command ^ " " ^ name ^ ".sml");
@


1.11
log
@Modified for two integer time stamps
@
text
@d4 3
d90 1
a90 1
   structure PathName : PATHNAME) (* : IMPORTER *) =
d150 1
a150 3
      val _ =
	Unix.system ("cd " ^ dirname ^ "; " ^ 
		     !co_command ^ " " ^ name ^ ".sml");
d178 1
a178 1
       (NewJersey.use namestring
d467 1
a467 1
	if NewJersey.exportML (PathName.pathname_namestring pathname)
@


1.10
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_importer.sml,v $
d200 1
a200 1
    ref (nil : (string * (int ref * int ref * children ref * bool ref)) list)
d227 1
a227 1
	val entry = (ref ~1, ref ~1, ref [], ref false)
d243 1
a243 1
  fun file_modified (pathname,build_time,checkout_old) =
d248 2
a249 2
	Unix.EXISTS mtime => 
	  mtime > build_time 
d365 1
a365 1
		time_ref := 0;
@


1.9
log
@Made exportML return bool (as in original NJML defn) and print out who/when
saved image in next start up message

Added funny_stamps and check_funnies. Each time during a make a file is
recompiled which is older than the timestamp in the database a note is made
and a message at the end of the make is given warning user of all such files
@
text
@d1 1
d4 8
d75 1
@


1.8
log
@Added checkout_old : bool ref. Controls whether on seeing a file with a time
stamp earlier in database we should just recompile or try and checkout latest
@
text
@d3 4
d203 2
d249 3
a251 1
	       (print "** Recompiling" ; true))
d394 13
d417 1
d421 1
d445 7
d455 3
a457 1
	    print ("Current directory is : " ^ init_dir ())
d459 1
a459 1
	  ()
@


1.7
log
@dependency list now includes a compilation count (make_counter). This fixes
bug with two separate makes from different parts of dependency tree but with
a common recompiled descendent. (second make was not causing a recompile)
@
text
@d3 5
@


1.6
log
@Fixed check_tree to set the time ref in the dependency list to 0 so that
in subsequent makes the module is recompiled even if errors have occurred 
during compilation of its children

Made children in the dependency list relative paths rather than absolute
paths. This allows images to be built and further developed in a different
source directory tree (typically checked out from main RCS source)

@
text
@d3 10
d178 1
a178 1
    ref (nil : (string * int ref * children ref * bool ref) list)
d192 2
d203 1
a203 1
	val (time_ref, children_ref, checked_ref) = (ref 0, ref [], ref false)
d205 2
a206 3
	dependencies :=
	   (name, time_ref, children_ref, checked_ref) :: !dependencies;
	(time_ref, children_ref, checked_ref)
d208 1
a208 1
    | search pathname ((name', time_ref, children_ref, checked_ref) :: rest) =
d212 3
a214 2
	if (name = name') then
	  (time_ref, children_ref, checked_ref)
d219 1
a219 1
  fun file_modified (pathname,build_time) =
d231 8
a238 3
	    (print ("** Warning: Timestamp on " ^ namestring ^ 
		    " earlier than last build - recompiling **");
	     true)
d242 1
a242 1
	   file_modified (pathname,build_time))
d250 3
a252 1
	
d256 1
d260 2
a261 2
      if checked then
	  (* already checked or just recompiled this one before *)
d264 1
a264 1
	if file_modified (pathname,build_time)
d266 1
a266 2
	    (* easy this module changed - recompile it *)
	    false
d268 4
a271 6
	  (* don't know - better look at the children *)
	  if check_children (pathname,children)
	    then
	      (* all the children (+ their children etc) are up to date -
	       cache the information for future checks *)
	      (checked_ref := true ; true)
d273 10
a282 6
	    (* some descendent of this module needs recompiling so we better
	       recompile this one *)
	    (* we set its time ref to 0 so that if compilation fails it will
	       be forced to be recompiled in subsequent makes *)
	    
	    (time_ref := 0 ; false)
d288 1
d296 3
a298 1
	    val pathname = PathName.modify_directory (child,absolute_directory)
d300 1
a300 1
	    if check_tree pathname
d302 1
a302 2
		(* one's ok - what about the others *)
		check_children' children
d304 5
a308 1
	      false
d320 1
a320 1
	val (time_ref, children_ref, checked_ref) = 
d324 2
a325 19
	  if not up_to_date then
	    let
	      (* Preserve current children *)
	      val local_children = !current_children
	    in
	      (* Reset dependencies for this file *)
	      children_ref := nil;
	    
	      (* Use file (builds new dependencies) *)
	      current_children := children_ref;
	    
	      (use_path pathname) handle exn =>
		(current_children := local_children ; raise exn);
	      
	      (* Reset current children *)
	      current_children := local_children;
	      
	      (* Mark this file as having been built *)
	      (* it had better exist - we just compiled it !! *)
d327 2
a328 2
		val Unix.EXISTS mtime =
		  Unix.mtime (PathName.pathname_namestring pathname)
d330 26
a355 3
		time_ref := mtime;
		(* This is now also checked *)
		checked_ref := true
d357 2
a358 3
	    end
	  else
	    ()
d370 1
a370 1
      val (time_ref, children_ref, checked_ref) =
d384 3
a386 2
       (* reset the cache of checked modules from last make *)
       app (fn (_,_,_,checked_ref) => checked_ref := false) (!dependencies);
d388 2
@


1.5
log
@Modified co_path to produce system command of form (cd xxxx; yyy zzzz)
instead of (yyy xxxx/zzzz)

Moved check-out message from function file_modified to co_path
@
text
@d3 6
d55 1
a55 1
   structure PathName : PATHNAME) : IMPORTER =
d97 1
a97 1
      resolved_pathname
d126 7
a132 1
  fun co name = co_path (resolve_sml_name name)
d150 6
a155 1
  fun use name = use_path (resolve_sml_name name)
d250 1
a250 1
	  if check_children children
d253 1
a253 1
	         cache the information for future checks *)
d258 4
a261 1
	    false
d264 23
a286 9
  and check_children nil = true
    | check_children (child :: children) =
      if check_tree child
	then
	  (* one's ok - what about the others *)
	  check_children children
      else
	false

d292 1
a292 1
	val pathname = resolve_sml_name name
d329 1
a329 1
	(!current_children) := pathname :: !(!current_children)
d337 1
a337 1
      val pathname = resolve_sml_name name
d381 1
a381 1
	val pathname = resolve_name (!current_dir,name,"")
@


1.4
log
@added reference co_command to allow switching of rcs checkout command

timestamp datatype now replaced by integer - the last modified time of the
file compiled for this module

added a bool ref in dependencies - flags when a module (+ descendents) has
been checked (previously done by CHECKED constructor in timestamp datatype)

added a bool ref - making. Ensures that requires are only done inside of a 
make command (ie not at top level). Necessary to ensure that checked flags
are reset between makes.

file_modified - now returns true if the time stamp on a file is different
(not just later) than in the dependency structure. Warns if time stamp is
earlier

exportML now knows about current directory and ~ (modified to use pathname
stuff + current directory like "use")

*** MAJOR CHANGE ***
Many of the above are details involved in changing the make system to record
in its database the timestamp of a file which is compiled rather than the
time of compilation. This makes things work much better with multiple people
using RCS. The caching of information to avoid repeatedly traversing the
dependency tree used to be tied in with the time stamps in the database.
This is no longer the case (replaced by the bool ref in dependency list)
@
text
@d3 28
d104 8
a111 1
      val namestring = PathName.pathname_namestring pathname
a112 1
      Unix.system ((!co_command) ^ namestring);
d114 1
a114 1
      case Unix.mtime namestring of
d207 1
a207 2
	  (print ("** Checking out " ^ namestring);
	   co_path pathname ;
@


1.3
log
@added automatic check out facility for rcs
@
text
@d3 3
d46 1
a46 1
  fun resolve_sml_name (old_dir, name) =
d48 1
d50 3
a52 1
	PathName.modify_type (PathName.parsePathName name, ".sml")
d66 2
d72 2
d75 9
a83 1
    Unix.system ("co " ^ PathName.pathname_namestring pathname)
d85 2
a86 1
  fun co name = co_path (resolve_sml_name (!current_dir,name))
d92 1
a92 1
  fun use (name) =
a94 1
      val pathname = resolve_sml_name (old_dir,name)
a96 5

      val _ =
	case Unix.mtime namestring of
	  Unix.EXISTS _ => ()
	| Unix.NOT_EXIST => co_path pathname
d104 1
a106 12
   This is set to the current time when make is called.
   *****)

  val current_time = ref 0

  (*****
   A timestamp for a file.
   *****)

  datatype timestamp = CHECKED of int * int | BUILT of int | OUT_OF_DATE

  (*****
d116 2
a117 1
  val dependencies = ref (nil : (string * timestamp ref * children ref) list)
d126 6
d140 1
a140 1
	val (time_ref, children_ref) = (ref OUT_OF_DATE, ref [])
d142 3
a144 2
	dependencies := (name, time_ref, children_ref) :: !dependencies;
	(time_ref, children_ref)
d146 1
a146 1
    | search pathname ((name', time_ref, children_ref) :: rest) =
d151 1
a151 1
	  (time_ref, children_ref)
a154 7

  (*****
   This function checks the whole dependency tree, setting the timestamps
   for each file. This means that in subsequent imports the status of a file
   may be determined immediately. Note that all out of date files must be
   marked as OUT_OF_DATE (otherwise they may not be built correctly).
   *****)
d156 9
a164 14
  fun file_modified (pathname, build_time) =
    case (Unix.mtime (PathName.pathname_namestring pathname)) of
      Unix.EXISTS mtime => (mtime > build_time)
    | Unix.NOT_EXIST => (co_path pathname ; true)
	
  fun check_tree ([], _) = false
    | check_tree (pathname :: rest, parent_time) =
      let
	val (time_ref,children_ref) = search pathname (!dependencies)
	  
	fun check build_time =
	  if
	    check_tree (!children_ref, build_time) orelse
	    file_modified (pathname, build_time)
d166 1
a166 4
	      (* This file is out of date *)
	      (time_ref := OUT_OF_DATE;
	       check_tree (rest, parent_time);
	       true)
d168 3
a170 24
	    (* This file is up to date *)
	    (time_ref := CHECKED(!current_time, build_time);
	     check_tree (rest, parent_time) orelse
	     (build_time > parent_time))
      in
	case !time_ref of
	  OUT_OF_DATE =>
	    (* This file is out of date *)
	    (check_tree(rest, parent_time) ; true)
	| CHECKED (time, build_time) =>
	    if time = !current_time then
	      (* This file is up to date *)
	      check_tree(rest, parent_time) orelse
	      (build_time > parent_time)
	    else
	      check build_time
	| BUILT build_time =>
	    if build_time = !current_time then
	      (* This file has just been built *)
	      check_tree(rest, parent_time) orelse
	      (build_time > parent_time)
	    else
	      check build_time
      end
d172 13
a184 1
  fun require name =
d186 3
a188 4
      val pathname = resolve_sml_name (!current_dir,name)
      val namestring = (PathName.pathname_namestring pathname)
      val (time_ref, children_ref) = search pathname (!dependencies)
      val out_of_date = check_tree([pathname], !current_time)
d190 20
a209 16
      if out_of_date then
	let
	  (* Preserve current children *)
	  val local_children = !current_children
	in
	  (* Reset dependencies for this file *)
	  children_ref := nil;
	  
	  (* Use file (builds new dependencies) *)
	  current_children := children_ref;
	  
	  (use namestring)
	  handle exn => (current_children := local_children ; raise exn);
	    
	    (* Reset current children *)
	    current_children := local_children;
d211 6
a216 3
	    (* Mark this file as having been built now *)
	    time_ref := BUILT(!current_time)
	end
d218 43
a260 2
	();
	
d263 4
a266 1
    end
d270 5
a274 2
      val pathname = resolve_sml_name (!current_dir,name)
      val (time_ref, children_ref) = search pathname (!dependencies)
d276 1
a276 1
      time_ref := BUILT(Unix.ctime())
d283 6
a288 2
      (current_time := Unix.ctime();
       (!current_children) := nil;
d290 2
a291 1
       require name;
d312 10
a321 5
    fun exportML (s) = 
      if NewJersey.exportML s then
	print ("Current directory is : " ^ init_dir ())
      else
	()
@


1.2
log
@Updated to compare modules based on last component of pathname only
Removed old aliasing facility as no longer needed due to RCS
@
text
@d3 4
d61 9
d79 5
d156 1
a156 1
    | Unix.NOT_EXIST => true
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d14 1
a14 1
   structure PathName : PATHNAME) (*: IMPORTER*) =
d17 1
d25 1
a25 1
  fun cd (s) =
d41 2
a42 8
      val pathname =
	PathName.parsePathName name
	
      val pathname' =
	if (PathName.pathname_type pathname = "") then
	  PathName.modify_type (pathname, ".sml")
	else
	  pathname
d45 1
a45 1
	PathName.pathname_directory pathname'
d50 2
a51 3
      val namestring =
	PathName.pathname_namestring
	(PathName.modify_directory (pathname', new_dir))
d53 1
a53 1
      (new_dir, namestring)
d60 1
a60 1
  fun new_use (name) =
d63 3
a65 1
      val (new_dir, namestring) = resolve_sml_name (old_dir,name)
d73 1
d75 2
a76 2
  The result datatype.
  *****)
d78 1
a78 1
  datatype 'a result = YES of 'a | NO
d81 2
a82 2
  A mapping datatype for aliases.
  *****)
d84 1
a84 12
  abstype map = MAP of (string * string) list
  with
    val empty = MAP []
      
    local
      fun add' (key, value) [] = [(key, value)]
	| add' (key, value) ((key', value') :: rest) =
	  if (key = key') then (key, value) :: rest
	  else (key', value') :: (add' (key, value) rest)
    in
      fun add (key, value) (MAP m) = MAP(add' (key, value) m)
    end
d86 3
a88 8
    local
      fun remove' key [] = []
	| remove' key ((key', value') :: rest) =
	  if (key = key') then rest
	  else (key', value') :: (remove' key rest)
    in
      fun remove key (MAP m) = MAP(remove' key m)
    end
d90 1
a90 8
    local
      fun lookup' key [] = NO
	| lookup' key ((key', value') :: rest) =
	  if (key = key') then YES(value')
	  else lookup' key rest
    in
      fun lookup key (MAP m) = lookup' key m
    end
a91 10
    local
      fun print_map' [] = ()
	| print_map' ((key, value) :: rest) =
	  (output(std_out, key ^ " --> " ^ value ^ "\n");
	   print_map' rest)
    in
      fun print_map (MAP m) = print_map' m
    end
  end

d93 2
a94 2
  This reference holds the alias map.
  *****)
d96 1
a96 1
  val alias_map = ref empty
d99 2
a100 2
  Expand a name (substitiuting aliases).
  *****)
d102 1
a102 8
  fun resolve_aliases name =
    let
      val (_, namestring) = resolve_sml_name(!current_dir, name)
    in
      case (lookup namestring (!alias_map)) of
	NO => (namestring, namestring)
      | YES(alias) => (alias, namestring)
    end
d104 5
a108 4
(*  local*)
    (*****
    This is set to the current time when make is called.
    *****)
d110 12
a121 40
    val current_time = ref 0

    (*****
    A timestamp for a file.
    *****)

    datatype timestamp = CHECKED of int * int | BUILT of int | OUT_OF_DATE

    (*****
    The files a file depends on.
    *****)

    type children = string list

    (*****
    The list of dependencies.
    *****)

    val dependencies = ref (nil : (string * timestamp ref * children ref) list)

    (*****
    A reference to a reference to the children of the current file.
    *****)

    val current_children = ref (ref (nil : children))

    (*****
    Search for the entry associated with name in dependencies.
    ******
    A new entry for name is created is no entry is present.
    *****)

    fun search name [] =
        let
	  val (time_ref, children_ref) = (ref OUT_OF_DATE, ref [])
	in
	  dependencies := (name, time_ref, children_ref) :: !dependencies;
	  (time_ref, children_ref)
	end
      | search name ((name', time_ref, children_ref) :: rest) =
d125 2
a126 1
	  search name rest
d128 21
a148 22
    (*****
    This function checks the whole dependency tree, setting the timestamps
    for each file. This means that in subsequent imports the status of a file
    may be determined immediately. Note that all out of date files must be
    marked as OUT_OF_DATE (otherwise they may not be built correctly).
    *****)

    fun file_modified (name, build_time) =
      case (Unix.mtime name) of
	Unix.EXISTS mtime => (mtime > build_time)
      | Unix.NOT_EXIST => true

    fun check_tree ([], _) = false
      | check_tree (name :: rest, parent_time) =
	let
	  val (alias, _) = resolve_aliases name
	  val (time_ref, children_ref) = search alias (!dependencies)

	  fun check build_time =
	    if
	      check_tree (!children_ref, build_time) orelse
	      file_modified (alias, build_time)
d152 17
a168 2
	      check_tree (rest, parent_time);
	      true)
d170 21
a190 4
	      (* This file is up to date *)
	      (time_ref := CHECKED(!current_time, build_time);
	      check_tree (rest, parent_time) orelse
	      (build_time > parent_time))
d192 9
a200 40
	  case !time_ref of
	    OUT_OF_DATE =>
	      (* This file is out of date *)
	      (check_tree(rest, parent_time) ; true)
	  | CHECKED (time, build_time) =>
	      if time = !current_time then
		(* This file is up to date *)
		check_tree(rest, parent_time) orelse
		(build_time > parent_time)
	      else
		check build_time
	  | BUILT build_time =>
	      if build_time = !current_time then
		(* This file has just been built *)
		check_tree(rest, parent_time) orelse
		(build_time > parent_time)
	      else
		check build_time
	end
(*  in*)
    fun require (name) =
      let
	val (alias, namestring) = resolve_aliases name
	val (time_ref, children_ref) = search alias (!dependencies)
	val out_of_date = check_tree([alias], !current_time)
      in
	if out_of_date then
	  let
	    (* Preserve current children *)
	    val local_children = !current_children
	  in
	    (* Reset dependencies for this file *)
	    children_ref := nil;

	    (* Use file (builds new dependencies) *)
	    current_children := children_ref;

	    (new_use alias)
	    handle exn => (current_children := local_children ; raise exn);

d206 4
a209 4
	  end
	else
	  ();

d211 2
a212 2
	(!current_children) := namestring :: !(!current_children)
      end
d214 4
a217 10
    fun makeok (name) =
      let
	val (alias, _) = resolve_aliases name
	val (time_ref, children_ref) = search alias (!dependencies)
      in
	time_ref := BUILT(Unix.ctime())
      end

    local
      val top_level_name = ref ""
d219 2
a220 20
      fun make (name) =
	(current_time := Unix.ctime();
	 (!current_children) := nil;
	 top_level_name := name;
	 require name;
	 print "up to date")

      fun again () =
	let
	  val name = !top_level_name
	in
	  if name = "" then
	    print "error - no object to make again"
	  else
	    make name
	end

(*      fun use (name) =
	make name
(*    end*) *)
d222 11
a232 1
    fun alias (name) (alias) =
d234 1
a234 6
	fun check (name) =
	  (close_in (open_in name) ; true)
	  handle Io _ => false

	val (_, name_str ) = resolve_sml_name (!current_dir, name)
	val (_, alias_str) = resolve_sml_name (!current_dir, alias)
d236 2
a237 11
	if (check name_str) then
	  if (check alias_str) then
	    let
	      val (time_ref, _) = search alias_str (!dependencies)
	    in
	      time_ref := OUT_OF_DATE;
	      alias_map := add (name_str, alias_str) (!alias_map);
	      print ("aliasing " ^ name_str ^ " and " ^ alias_str)
	    end
	  else
	    print ("error - " ^ alias_str ^ " does not exist")
d239 1
a239 1
	  print ("error - " ^ name_str ^ " does not exist")
a240 20
      
    fun unalias (name) =
      let
	val (_, namestring) = resolve_sml_name (!current_dir, name)
      in
	case (lookup namestring (!alias_map)) of
	  YES _ =>
	    let
	      val (time_ref, _) = search namestring (!dependencies)
	    in
	      time_ref := OUT_OF_DATE;
	      alias_map := remove namestring (!alias_map);
	      print ("unaliasing " ^ namestring)
	    end
	| NO =>
	    print ("error - " ^ namestring ^ " was not aliased")
      end

    fun print_aliases () =
      print_map (!alias_map)
d256 1
a256 1
end;
@
