head	1.113;
access;
symbols
	MLWorks_20m1_1997_10_23:1.113
	MLWorks_11r1:1.113.8.1.1.1.1
	MLWorks_workspace_97:1.113.10
	MLWorks_dt_wizard:1.113.9
	MLWorks_11c0_1997_09_09:1.113.8.1.1.1
	MLWorks_10r3:1.113.8.1.3
	MLWorks_10r2_551:1.113.8.1.2
	MLWorks_11:1.113.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.113.8.1
	MLWorks_20m0_1997_06_20:1.113
	MLWorks_1_0_r2c2_1997_06_14:1.113.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.113.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.113.8
	MLWorks_BugFix_1997_04_24:1.113
	MLWorks_1_0_r2_Win32_1997_04_11:1.113
	MLWorks_1_0_r2_Unix_1997_04_04:1.113
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.113.6.1.1
	MLWorks_gui_1996_12_18:1.113.7
	MLWorks_1_0_Win32_1996_12_17:1.113.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.113.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.113.4.1
	MLWorks_1_0_Irix_1996_11_28:1.113.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.113.5
	MLWorks_1_0_Unix_1996_11_14:1.113.4
	MLWorks_Open_Beta2_1996_10_11:1.113.3
	MLWorks_License_dev:1.113.2
	MLWorks_1_open_beta_1996_09_13:1.113.1
	MLWorks_Open_Beta_1996_08_22:1.113
	MLWorks_Beta_1996_07_02:1.113
	MLWorks_Beta_1996_06_07:1.113
	MLWorks_Beta_1996_06_06:1.113
	MLWorks_Beta_1996_06_05:1.113
	MLWorks_Beta_1996_06_03:1.113
	MLWorks_Beta_1996_05_31:1.113
	MLWorks_Beta_1996_05_30:1.113
	ML_beta_release_12/08/94:1.73
	ML_beta_release_03/08/94:1.73
	ML_revised_beta_release_25/05/94:1.68
	ML_final_beta_release_02/03/94:1.63
	mlworks-28-01-1994:1.57
	Release:1.53
	mlworks-beta-01-09-1993:1.53
	MLWorks-1-0-4-29/01/1993:1.30
	MLWorks-1-0-3-21/12/1992:1.29
	MLWorks-1-0-2-15/12/1992:1.25
	MLWorks-1-0-1-04/12/1992:1.25
	checkpoint_17_08_92:1.8;
locks; strict;
comment	@ * @;


1.113
date	96.04.18.09.15.09;	author stephenb;	state Exp;
branches
	1.113.1.1
	1.113.2.1
	1.113.3.1
	1.113.4.1
	1.113.5.1
	1.113.6.1
	1.113.7.1
	1.113.8.1
	1.113.9.1
	1.113.10.1;
next	1.112;

1.112
date	96.03.28.10.08.24;	author matthew;	state Exp;
branches;
next	1.111;

1.111
date	96.03.08.12.04.29;	author daveb;	state Exp;
branches;
next	1.110;

1.110
date	96.02.22.14.54.37;	author daveb;	state Exp;
branches;
next	1.109;

1.109
date	96.02.16.15.38.29;	author nickb;	state Exp;
branches;
next	1.108;

1.108
date	96.01.23.10.32.07;	author matthew;	state Exp;
branches;
next	1.107;

1.107
date	96.01.22.08.34.29;	author stephenb;	state Exp;
branches;
next	1.106;

1.106
date	96.01.16.12.15.33;	author nickb;	state Exp;
branches;
next	1.105;

1.105
date	96.01.15.16.24.18;	author matthew;	state Exp;
branches;
next	1.104;

1.104
date	96.01.15.11.49.46;	author nickb;	state Exp;
branches;
next	1.103;

1.103
date	96.01.15.09.28.31;	author stephenb;	state Exp;
branches;
next	1.102;

1.102
date	96.01.08.14.28.48;	author nickb;	state Exp;
branches;
next	1.101;

1.101
date	95.12.04.15.46.54;	author daveb;	state Exp;
branches;
next	1.100;

1.100
date	95.11.21.11.23.35;	author jont;	state Exp;
branches;
next	1.99;

1.99
date	95.10.17.12.53.35;	author jont;	state Exp;
branches;
next	1.98;

1.98
date	95.09.18.09.52.54;	author daveb;	state Exp;
branches;
next	1.97;

1.97
date	95.09.18.09.12.57;	author daveb;	state Exp;
branches;
next	1.96;

1.96
date	95.09.13.14.26.22;	author jont;	state Exp;
branches;
next	1.95;

1.95
date	95.09.13.13.44.00;	author daveb;	state Exp;
branches;
next	1.94;

1.94
date	95.09.13.13.08.39;	author daveb;	state Exp;
branches;
next	1.93;

1.93
date	95.08.10.15.42.01;	author jont;	state Exp;
branches;
next	1.92;

1.92
date	95.07.28.08.31.40;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	95.07.25.14.01.17;	author jont;	state Exp;
branches;
next	1.90;

1.90
date	95.07.24.10.06.29;	author jont;	state Exp;
branches;
next	1.89;

1.89
date	95.07.19.15.10.31;	author nickb;	state Exp;
branches;
next	1.88;

1.88
date	95.07.19.13.53.24;	author nickb;	state Exp;
branches;
next	1.87;

1.87
date	95.07.19.13.40.57;	author nickb;	state Exp;
branches;
next	1.86;

1.86
date	95.07.19.09.15.59;	author jont;	state Exp;
branches;
next	1.85;

1.85
date	95.06.02.13.59.54;	author nickb;	state Exp;
branches;
next	1.84;

1.84
date	95.05.23.15.43.53;	author nickb;	state Exp;
branches;
next	1.83;

1.83
date	95.05.11.09.35.56;	author jont;	state Exp;
branches;
next	1.82;

1.82
date	95.05.02.13.13.11;	author matthew;	state Exp;
branches;
next	1.81;

1.81
date	95.04.18.09.06.55;	author jont;	state Exp;
branches;
next	1.80;

1.80
date	95.03.20.10.41.00;	author matthew;	state Exp;
branches;
next	1.79;

1.79
date	95.03.02.13.41.07;	author matthew;	state Exp;
branches;
next	1.78;

1.78
date	95.01.16.10.16.10;	author jont;	state Exp;
branches;
next	1.77;

1.77
date	94.12.09.14.39.46;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	94.11.24.16.13.54;	author matthew;	state Exp;
branches;
next	1.75;

1.75
date	94.09.27.16.05.01;	author matthew;	state Exp;
branches;
next	1.74;

1.74
date	94.08.25.09.12.36;	author matthew;	state Exp;
branches;
next	1.73;

1.73
date	94.07.08.10.13.32;	author nickh;	state Exp;
branches;
next	1.72;

1.72
date	94.07.01.14.58.51;	author jont;	state Exp;
branches;
next	1.71;

1.71
date	94.06.24.09.01.44;	author nickh;	state Exp;
branches;
next	1.70;

1.70
date	94.06.10.10.03.18;	author nosa;	state Exp;
branches;
next	1.69;

1.69
date	94.06.09.15.40.59;	author nickh;	state Exp;
branches;
next	1.68;

1.68
date	94.04.08.08.04.49;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	94.03.24.16.16.24;	author daveb;	state Exp;
branches;
next	1.66;

1.66
date	94.03.24.10.41.48;	author daveb;	state Exp;
branches;
next	1.65;

1.65
date	94.03.23.17.35.08;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	94.03.14.17.37.26;	author nickh;	state Exp;
branches;
next	1.63;

1.63
date	94.03.01.10.08.05;	author nosa;	state Exp;
branches;
next	1.62;

1.62
date	94.02.27.22.01.08;	author nosa;	state Exp;
branches;
next	1.61;

1.61
date	94.02.08.17.27.42;	author nickh;	state Exp;
branches;
next	1.60;

1.60
date	94.02.08.14.26.08;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	94.02.08.10.51.34;	author nickh;	state Exp;
branches;
next	1.58;

1.58
date	94.02.03.09.47.49;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	93.11.26.12.31.52;	author nickh;	state Exp;
branches;
next	1.56;

1.56
date	93.11.22.16.26.36;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	93.11.18.12.16.15;	author nickh;	state Exp;
branches;
next	1.54;

1.54
date	93.11.15.15.18.52;	author nickh;	state Exp;
branches;
next	1.53;

1.53
date	93.08.31.09.52.13;	author daveb;	state Exp;
branches
	1.53.1.1;
next	1.52;

1.52
date	93.08.26.11.13.21;	author richard;	state Exp;
branches;
next	1.51;

1.51
date	93.08.26.10.09.04;	author richard;	state Exp;
branches;
next	1.50;

1.50
date	93.08.26.09.58.26;	author richard;	state Exp;
branches;
next	1.49;

1.49
date	93.08.25.14.01.00;	author richard;	state Exp;
branches;
next	1.48;

1.48
date	93.07.28.11.35.56;	author richard;	state Exp;
branches;
next	1.47;

1.47
date	93.07.19.13.37.03;	author nosa;	state Exp;
branches;
next	1.46;

1.46
date	93.06.10.15.58.25;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	93.05.05.16.05.56;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	93.04.23.14.51.13;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	93.04.22.17.22.21;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.04.22.13.39.46;	author richard;	state Exp;
branches;
next	1.41;

1.41
date	93.04.20.10.12.57;	author richard;	state Exp;
branches;
next	1.40;

1.40
date	93.04.13.09.59.17;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	93.04.08.17.29.56;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	93.04.06.13.00.31;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	93.04.02.15.27.40;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	93.03.26.15.53.27;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	93.03.23.18.32.34;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	93.03.11.18.37.25;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	93.03.10.16.30.56;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	93.02.18.16.56.08;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	93.02.17.11.05.21;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	93.01.05.16.54.24;	author richard;	state Exp;
branches;
next	1.29;

1.29
date	92.12.22.10.50.12;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.12.22.10.25.37;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	92.12.22.10.05.26;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.12.22.10.02.01;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	92.12.01.13.05.26;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	92.12.01.12.45.10;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	92.11.12.15.58.16;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.11.10.13.14.23;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	92.11.02.10.06.49;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	92.09.25.14.36.13;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	92.09.23.16.16.41;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	92.09.01.14.34.40;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	92.08.28.15.00.49;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.08.28.08.26.28;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.08.26.14.34.26;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.08.25.16.27.11;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	92.08.24.14.16.46;	author davidt;	state Exp;
branches;
next	1.12;

1.12
date	92.08.20.12.44.05;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	92.08.20.08.33.04;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.08.18.16.40.49;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.08.18.14.44.59;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.08.17.11.05.12;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.08.15.17.32.57;	author davidt;	state Exp;
branches;
next	1.6;

1.6
date	92.08.13.15.30.59;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.08.13.12.09.24;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.08.12.14.21.36;	author davidt;	state Exp;
branches;
next	1.3;

1.3
date	92.08.11.05.59.23;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.08.10.15.26.16;	author davidt;	state Exp;
branches;
next	1.1;

1.1
date	92.08.07.15.03.28;	author davidt;	state Exp;
branches;
next	;

1.53.1.1
date	93.08.31.09.52.13;	author jont;	state Exp;
branches;
next	;

1.113.1.1
date	96.09.13.11.19.01;	author hope;	state Exp;
branches;
next	;

1.113.2.1
date	96.10.07.16.08.54;	author hope;	state Exp;
branches;
next	;

1.113.3.1
date	96.10.17.11.27.11;	author hope;	state Exp;
branches;
next	;

1.113.4.1
date	96.11.14.12.52.40;	author hope;	state Exp;
branches
	1.113.4.1.1.1;
next	;

1.113.4.1.1.1
date	96.11.28.15.03.39;	author hope;	state Exp;
branches;
next	;

1.113.5.1
date	96.11.22.18.11.46;	author hope;	state Exp;
branches;
next	;

1.113.6.1
date	96.12.17.17.50.16;	author hope;	state Exp;
branches
	1.113.6.1.1.1;
next	;

1.113.6.1.1.1
date	97.02.24.11.40.34;	author hope;	state Exp;
branches;
next	;

1.113.7.1
date	96.12.18.09.44.24;	author hope;	state Exp;
branches;
next	;

1.113.8.1
date	97.05.12.10.36.53;	author hope;	state Exp;
branches
	1.113.8.1.1.1
	1.113.8.1.2.1
	1.113.8.1.3.1;
next	;

1.113.8.1.1.1
date	97.07.28.18.22.10;	author daveb;	state Exp;
branches
	1.113.8.1.1.1.1.1;
next	;

1.113.8.1.1.1.1.1
date	97.10.07.11.47.49;	author jkbrook;	state Exp;
branches;
next	;

1.113.8.1.2.1
date	97.09.08.17.15.34;	author daveb;	state Exp;
branches;
next	;

1.113.8.1.3.1
date	97.09.09.14.11.26;	author daveb;	state Exp;
branches;
next	;

1.113.9.1
date	97.09.10.19.27.30;	author brucem;	state Exp;
branches;
next	;

1.113.10.1
date	97.09.11.20.57.30;	author daveb;	state Exp;
branches;
next	;


desc
@This file is used to convert the NewJersey pervasive
environment to look like the MLworks environment.
@


1.113
log
@Remove exit, terminate, atExit and most of the OS structure since
they are no longer needed now that OS.Process has been updated.
@
text
@(*  ==== MODIFY NEW JERSEY ENVIRONMENT ====
 *
 *  Copyright (C) 1993 Harlequin Ltd
 *
 *  Description
 *  -----------
 *  This New Jersey ML source simulates the MLWorks pervasive environment
 *  under New Jersey, to the extent that we are able to compile the
 *  compiler.
 *
 *  Revision Log
 *  ------------
 *  $Log: change_nj.sml,v $
 * Revision 1.112  1996/03/28  10:08:24  matthew
 * Adding definition of outstream
 *
 * Revision 1.111  1996/03/08  12:04:29  daveb
 * Converted the types Dynamic and Type to the new identifier naming scheme.
 *
 * Revision 1.110  1996/02/22  14:54:37  daveb
 * Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
 * some functionality to the Shell structure.
 *
 * Revision 1.109  1996/02/16  15:38:29  nickb
 * name change fn_save => deliver
 *
 *  Revision 1.108  1996/01/23  10:32:07  matthew
 *  Adding nj-env.sml file
 *
 *  Revision 1.107  1996/01/22  08:34:29  stephenb
 *  OS reorganisation: Remove the OS specific stuff since
 *  this is no longer in the pervasive library.
 *
 *  Revision 1.106  1996/01/16  12:15:33  nickb
 *  Change to GC interface.
 *
 *  Revision 1.105  1996/01/15  16:24:18  matthew
 *  Adding NT directory operations
 *
 *  Revision 1.104  1996/01/15  11:49:46  nickb
 *  Add thread sleep and wake operations.
 *
 *  Revision 1.103  1996/01/15  09:28:31  stephenb
 *  Update wrt change in ../pervasive/__pervasive_library.sml
 *
 *  Revision 1.102  1996/01/08  14:28:48  nickb
 *  Signal reservation removed.
 *
 *  Revision 1.101  1995/12/04  15:46:54  daveb
 *  Pervasive module names now begin with a space.
 *
 *  Revision 1.100  1995/11/21  11:23:35  jont
 *  Add Frame.frame_double for accessing directly spilled reals
 *
 *  Revision 1.99  1995/10/17  12:53:35  jont
 *  Add exec_save for saving executables
 *
 *  Revision 1.98  1995/09/18  09:52:54  daveb
 *  COrrected syntax error.
 *
 *  Revision 1.97  1995/09/18  09:12:57  daveb
 *  Made quot and rem be nonfix.
 *
 *  Revision 1.96  1995/09/13  14:26:22  jont
 *  Add fn_save
 *
 *  Revision 1.95  1995/09/13  13:44:00  daveb
 *  Removed bogus path name that I was using to test previous changes.
 *
 *  Revision 1.94  1995/09/13  13:08:39  daveb
 *  Implemented overloaded types for different sizes of words and ints.
 *
 *  Revision 1.93  1995/08/10  15:42:01  jont
 *  Add ml_char for giving textual representation of chars
 *
 *  Revision 1.92  1995/07/28  08:31:40  matthew
 *  Adding makestring function to Word structure
 *
 *  Revision 1.91  1995/07/25  14:01:17  jont
 *  Add Word structure and Overflow exn
 *
 *  Revision 1.90  1995/07/24  10:06:29  jont
 *  Add Overflow to structure exception
 *
 *  Revision 1.89  1995/07/19  15:10:31  nickb
 *  Two constructors called MLWorks.Profile.Profile.
 *
 *  Revision 1.88  1995/07/19  13:53:24  nickb
 *  Whoops; major type screwups in new profiler.
 *
 *  Revision 1.87  1995/07/19  13:40:57  nickb
 *  Change to profiler interface.
 *
 *  Revision 1.86  1995/07/19  09:15:59  jont
 *  Add chars stuff
 *  Also add new integer functions for hex printing
 *
 *  Revision 1.85  1995/06/02  13:59:54  nickb
 *  Change threads restart system.
 *
 *  Revision 1.84  1995/05/23  15:43:53  nickb
 *  Add threads system.
 *
 *  Revision 1.83  1995/05/11  09:35:56  jont
 *  Bring up to date with revised basis stuff in __pervasive_library.sml
 *
 *  Revision 1.82  1995/05/02  13:13:11  matthew
 *  Adding CAST and UMAP primitives
 *  Removing some stuff from Debugger
 *
 *  Revision 1.81  1995/04/18  09:06:55  jont
 *  Add missing values atExit and terminate
 *
 *  Revision 1.80  1995/03/20  10:41:00  matthew
 *  Adding implode_char
 *
 *  Revision 1.79  1995/03/02  13:41:07  matthew
 *  Unifying Value.Frame and Frame.pointer
 *
 *  Revision 1.78  1995/01/16  10:16:10  jont
 *  Bring into line with current state of Win_nt structure (getcd and get_path_name)
 *
 *  Revision 1.77  1994/12/09  14:39:46  jont
 *  Add OS.Win_nt structure
 *
 *  Revision 1.76  1994/11/24  16:13:54  matthew
 *  Adding new unsafe operations in MLWorks.Internal.Value
 *
 *  Revision 1.75  1994/09/27  16:05:01  matthew
 *  Added pervasive Option structure
 *
 *  Revision 1.74  1994/08/25  09:12:36  matthew
 *  Adding unsafe array operations
 *
 *  Revision 1.73  1994/07/08  10:13:32  nickh
 *  Add event functions for stack overflow and interrupt handlers.
 *
 *  Revision 1.72  1994/07/01  14:58:51  jont
 *  Add messages to Io
 *
 *  Revision 1.71  1994/06/24  09:01:44  nickh
 *  Add trace.restore_all
 *
 *  Revision 1.70  1994/06/10  10:03:18  nosa
 *  Breakpoint settings on function exits.
 *
 *  Revision 1.69  1994/06/09  15:40:59  nickh
 *  Updated runtime system handling.
 *
 *  Revision 1.68  1994/04/08  08:04:49  daveb
 *  Updated with set_file_modified and associated type.
 *
 *  Revision 1.67  1994/03/24  16:16:24  daveb
 *  Adding handler around realpath.
 *
 *  Revision 1.66  1994/03/24  10:41:48  daveb
 *  Fixing typo (braino?).
 *
 *  Revision 1.65  1994/03/23  17:35:08  daveb
 *  Added realpath to NJ runtime.
 *
 *  Revision 1.64  1994/03/14  17:37:26  nickh
 *  Add an fsync when closing files.
 *
 *  Revision 1.63  1994/03/01  10:08:05  nosa
 *  option was missing in structure Debugger.
 *
 *  Revision 1.62  1994/02/27  22:01:08  nosa
 *  Step and breakpoints Debugger.
 *
 *  Revision 1.61  1994/02/08  17:27:42  nickh
 *  Hope it works now :-)
 *
 *  Revision 1.60  1994/02/08  14:26:08  matthew
 *  Added definition for realpath.  This is just the identity function.
 *
 *  Revision 1.59  1994/02/08  10:51:34  nickh
 *  Added MLWorks.String.ml_string
 *
 *  Revision 1.58  1994/02/03  09:47:49  matthew
 *  Added definition for getwd
 *
 *  Revision 1.57  1993/11/26  12:31:52  nickh
 *  Hacks for Elapsed.elapsed, elapsed_since, format.
 *
 *  Revision 1.56  1993/11/22  16:26:36  jont
 *  Changed type of modules to include a time stamp field
 *
 *  Revision 1.55  1993/11/18  12:16:15  nickh
 *  Add to IO and RawIO to provide closed_in and closed_out functions for
 *  testing open/closed status. (also fix Time structure bug).
 *
 *  Revision 1.54  1993/11/15  15:18:52  nickh
 *  New pervasive time structure; in particular extension to encode/decode.
 *
 *  Revision 1.53  1993/08/31  09:52:13  daveb
 *  Added OS.Unix.{unlink,rmdir,mkdir}
 *
 *  Revision 1.52  1993/08/26  11:13:21  richard
 *  Removed the X exception.  It's now in the Motif interface code.
 *
 *  Revision 1.51  1993/08/26  10:09:04  richard
 *  Declared a special version of require for the pervasive modules.  This
 *  is necessary because of changes to the module naming scheme.
 *
 *  Revision 1.50  1993/08/26  09:58:26  richard
 *  Added X exception.
 *
 *  Revision 1.49  1993/08/25  14:01:00  richard
 *  Added dummy MLWorks.OS.Unix.kill.
 *
 *  Revision 1.48  1993/07/28  11:35:56  richard
 *  Changes to MLWORKS signature.  See pervasive/mlworks.sml.
 *
 *  Revision 1.47  1993/07/19  13:37:03  nosa
 *  Added two frame functions for debugger
 *
 *  Revision 1.46  1993/06/10  15:58:25  matthew
 *  Added text_preprocess hook
 *
 *  Revision 1.45  1993/05/05  16:05:56  jont
 *  Added MLWorks.OS.Unix.password_file to get the association list of user names
 *  to home directories necessary for translating ~
 *
 *  Revision 1.44  1993/04/23  14:51:13  jont
 *  Added Integer and Real substructures of MLWorks
 *
 *  Revision 1.43  1993/04/22  17:22:21  jont
 *  Added write_byte for FileIO and output_byte to RawIO
 *
 *  Revision 1.42  1993/04/22  13:39:46  richard
 *  Removed defunct Editor interface and added sytem calls to enable
 *  its replacement.
 *
 *  Revision 1.41  1993/04/20  10:12:57  richard
 *  New Unix and Trace stuff.  See MLWorks signature.
 *
 *  Revision 1.40  1993/04/13  09:59:17  matthew
 *  Changed TypeRep to Dynamic and restructured
 *  Moved break stuff out of tracing.
 *  
 *  Revision 1.39  1993/04/08  17:29:56  jont
 *  Minor modifications to editor structure
 *  
 *  Revision 1.38  1993/04/06  13:00:31  jont
 *  Removed use of pervasive ordof
 *  
 *  Revision 1.37  1993/04/02  15:27:40  jont
 *  Extended images structure to include table of contents reading
 *  
 *  Revision 1.36  1993/03/26  15:53:27  matthew
 *  Added break function to Tracing substructure
 *  
 *  Revision 1.35  1993/03/23  18:32:34  jont
 *  Minor change to interface to edit file
 *  
 *  Revision 1.34  1993/03/11  18:37:25  jont
 *  Added Intermal.Images including save and clean. Added other_operation to
 *  Editor for arbitrary bits of emacs lisp
 *  
 *  Revision 1.33  1993/03/10  16:30:56  jont
 *  Added editor substructure to MLWorks
 *  
 *  Revision 1.32  1993/02/18  16:56:08  matthew
 *  Added TypeRep signature in MLWorks.Internal
 *  
 *  Revision 1.31  1993/02/17  11:05:21  daveb
 *  Corrected string argument to Unimplemented for MLWorks.Time.Real.now.
 *  
 *  Revision 1.30  1993/01/05  16:54:24  richard
 *  Added some extra exceptions for the runtime system.
 *  
 *  Revision 1.29  1992/12/22  10:50:12  clive
 *  ExtendedArray should not be available at the top level
 *  
 *  Revision 1.28  1992/12/22  10:25:37  daveb
 *  Made ExtendedArray visible at top level.
 *  
 *  Revision 1.27  1992/12/22  10:05:26  clive
 *  Needed to define the type T in the Array structure
 *  
 *  Revision 1.26  1992/12/22  10:02:01  matthew
 *  Added 'agreed' Array and Vector structures.
 *  
 *  Revision 1.25  1992/12/01  13:05:26  matthew
 *  Fixed problem with IO
 *  
 *  Revision 1.24  1992/12/01  12:45:10  matthew
 *  Changed IO structure to mirror __pervasive_library
 *  
 *  Revision 1.23  1992/11/12  15:58:16  clive
 *  Added some rts support for tracing
 *  
 *  Revision 1.22  1992/11/10  13:14:23  richard
 *  Added StorageManager exception and changed the type of the
 *  StorageManager interface function.
 *  
 *  Revision 1.21  1992/11/02  10:06:49  richard
 *  Many changes.  See MLWorks signature.
 *  
 *  Revision 1.20  1992/09/25  14:36:13  matthew
 *  Added Internal.string_to_real
 *  
 *  Revision 1.19  1992/09/23  16:16:41  daveb
 *  Added clear_eof function to IO (unimplemented).
 *  
 *  Revision 1.18  1992/09/01  14:34:40  richard
 *  Changed the OS information stuff to functions.  Added Prod and
 *  Value exceptions.
 *  Implemented save.
 *  
 *  Revision 1.17  1992/08/28  15:00:49  clive
 *  Added a function to the pervasive_library to get debug_info from a
 *  function
 *  
 *  Revision 1.16  1992/08/28  08:26:28  richard
 *  Changed call to environment so that environment is not
 *  preserved across images.
 *  Added floating-point exceptions.
 *  
 *  Revision 1.15  1992/08/26  14:34:26  richard
 *  Rationalisation of the MLWorks structure.
 *  
 *  Revision 1.14  1992/08/25  16:27:11  richard
 *  Added ByteArray structure and writebf in FileIO.
 *  
 *  Revision 1.13  1992/08/24  14:16:46  davidt
 *  Added a faster implementation of FileIO.writef which
 *  doesn't allocate as many bytearrays.
 *  
 *  Revision 1.12  1992/08/20  12:44:05  richard
 *  Changed path of require of mlworks to use pervasive directory.
 *  
 *  Revision 1.11  1992/08/20  08:33:04  richard
 *  Enriched the Array structure.
 *  
 *  Revision 1.10  1992/08/18  16:40:49  richard
 *  Added real_to_string.
 *  
 *  Revision 1.9  1992/08/18  14:44:59  richard
 *  Changes to the MLWorks signature.  See mlworks file for
 *  details.
 *  
 *  Revision 1.8  1992/08/17  11:05:12  richard
 *  Added MLWorks.System.Runtime.GC.interface.
 *  
 *  Revision 1.7  1992/08/15  17:32:57  davidt
 *  Put in MLWorks.IO.input_line function.
 *  
 *  Revision 1.6  1992/08/13  15:30:59  clive
 *  Added two functions to the debugger
 *  
 *  Revision 1.4  1992/08/12  14:21:36  davidt
 *  Took out copying of Array and String structures from the
 *  MLWorks structure in an attempt to see if NewJersey was
 *  getting confused and not inlining code for array updates.
 *  
 *  Revision 1.3  1992/08/11  05:59:23  richard
 *  Added load_wordset to Int structure.
 *  
 *  Revision 1.2  1992/08/10  15:26:16  davidt
 *  Changed MLworks structure to MLWorks
 *  
 *  Revision 1.1  1992/08/07  15:03:28  davidt
 *  Initial revision
 *  
 *  Revision 1.1  1992/05/18  15:40:36  clive
 *  Initial revision
 *)

(* This require is just for the pervasive modules. *)

fun require s =
 if ord s = ord " " then
   use ("../pervasive/" ^ String.substring (s, 1, size s - 1) ^ ".sml")
 else
   use ("../pervasive/" ^ s ^ ".sml");

type word = int;

nonfix quot rem;

require "mlworks";

exception Unimplemented of string
fun unimplemented name =
  (output (std_out, "unimplemented MLWorks pervasive: " ^ name ^ "\n");
   raise Unimplemented name)

structure MLWorks : MLWORKS =
  struct

    structure Option = 
      struct
        datatype 'a option = SOME of 'a | NONE 
        datatype ('a,'b) union = INL of 'a | INR of 'b 
      end

    structure Bits =
      struct
	open NewJersey.Bits
	fun arshift _ = unimplemented "MLWorks.Bits.arshift"
      end

    structure Vector =
      struct
        datatype 'a vector = Vector of 'a list

        exception Size
        exception Subscript

	nonfix sub

        val vector = Vector

        fun tabulate (i, f) =
          let fun tab j = if j < i then f j :: tab (j+1) else nil
          in if i < 0 then raise Size else Vector (tab 0)
          end

        fun sub (Vector nil, i) = raise Subscript
        |   sub (Vector (a::r), i) =
          if i > 0 then sub (Vector r, i-1)
          else if i < 0 then raise Subscript
          else a

        fun length (Vector nil) = 0
        |   length (Vector (a::r)) = 1 + length (Vector r)
      end

    structure Array = 
      struct
        open NewJersey.Array
          type 'a T = 'a array
      end

    structure ExtendedArray =
      struct
        open NewJersey.Array

        nonfix sub
        type 'a T = 'a array

        fun tabulate (l, f) =
          if l = 0 then
            arrayoflist []
          else
            let
              val first = f 0
              val a = array (l, first)

              fun init 0 = a
                | init n =
                  (update (a, n-l, f (n-l));
                   init (n-1))
            in
              init (l-1)
            end

        val from_list = arrayoflist

        fun fill (a, x) =
          let
            fun fill' 0 = ()
              | fill' n =
                (update (a, n-1, x);
                 fill' (n-1))
          in
            fill' (length a)
          end

        fun map f a =
          let
            val l = length a
          in
            if l = 0 then
              from_list []
            else
              let
                val first = f (sub (a, 0))
                val new = array (l, first)

                fun map' 0 = new
                  | map' n =
                    (update (new, l-n, f (sub (a, l-n)));
                     map' (n-1))
              in
                map' (l-1)
              end
          end

        fun map_index f a =
          let
            val l = length a
          in
            if l = 0 then
              from_list []
            else
              let
                val first = f (0, sub (a, 0))
                val new = array (l, first)

                fun map' 0 = new
                  | map' n =
                    (update (new, l-n, f (l-n, sub (a, l-n)));
                     map' (n-1))
              in
                map' (l-1)
              end
          end

        fun to_list a =
          let
            fun to_list' (0, list) = list
              | to_list' (n, list) =
                to_list' (n-1, sub (a, n-1) :: list)
          in
            to_list' (length a, nil)
          end

        fun iterate f a =
          let
            val l = length a

            fun iterate' 0 = ()
              | iterate' n =
                (f (sub (a, l-n));
                 iterate' (n-1))
          in
            iterate' l
          end

        fun iterate_index f a =
          let
            val l = length a

            fun iterate' 0 = ()
              | iterate' n =
                (f (l-n, sub (a, l-n));
                 iterate' (n-1))
          in
            iterate' l
          end

        fun rev a =
          let
            val l = length a
          in
            if l = 0 then
              from_list []
            else
              let
                val first = sub (a, 0)
                val new = array (l, first)

                fun rev' 0 = new
                  | rev' n =
                    (update (new, n-1, sub (a, l-n));
                     rev' (n-1))
              in
                rev' (l-1)
              end
          end

        fun duplicate a =
          let
            val l = length a
          in
            if l = 0 then
              from_list []
            else
              let
                val first = sub (a, 0)
                val new = array (l, first)

                fun duplicate' 0 = new
                  | duplicate' n =
                    (update (new, l-n, sub (a, l-n));
                     duplicate' (n-1))
              in
                duplicate' (l-1)
              end
          end

        exception Subarray of int * int
        fun subarray (a, start, finish) =
          let
            val l = length a
          in
            if start < 0 orelse start > l orelse finish > l orelse
               start > finish then
              raise Subarray (start, finish)
            else
              let
                val l' = finish - start
              in
                if l' = 0 then
                  from_list []
                else
                  let
                    val first = sub (a, start)
                    val new = array (l', first)

                    fun copy 0 = new
                      | copy n =
                        (update (new, l'-n, sub (a, start+l'-n));
                         copy (n-1))
                  in
                    copy (l'-1)
                  end
              end
          end

        fun append (array1, array2) =
          let
            val l1 = length array1
            val l2 = length array2
            val l = l1 + l2
          in
            if l = 0 then
              from_list []
            else
              let
                val first =
                  if l1 = 0 then
                    sub (array2, 0)
                  else
                    sub (array1, 0)

                val new = array (l, first)

                fun copy1 0 = new
                  | copy1 n =
                    (update (new, l1-n, sub (array1, l1-n));
                     copy1 (n-1))

                fun copy2 0 = copy1 (l1-1)
                  | copy2 n =
                    (update (new, l-n, sub (array2, l2-n));
                     copy2 (n-1))
              in
                copy2 l2
              end
          end

        fun reducel f (i, a) =
          let
            val l = length a

            fun reducel' (i, 0) = i
              | reducel' (i, n) =
                reducel' (f (i, sub (a, l-n)), n-1)
          in
            reducel' (i, l)
          end

        fun reducel_index f (i, a) =
          let
            val l = length a

            fun reducel' (i, 0) = i
              | reducel' (i, n) =
                reducel' (f (l-n, i, sub (a, l-n)), n-1)
          in
            reducel' (i, l)
          end

        fun reducer f (a, i) =
          let
            val l = length a

            fun reducer' (0, i) = i
              | reducer' (n, i) =
                reducer' (n-1, f (sub (a, n-1), i))
          in
            reducer' (l, i)
          end

        fun reducer_index f (a, i) =
          let
            val l = length a

            fun reducer' (0, i) = i
              | reducer' (n, i) =
                reducer' (n-1, f (n-1, sub (a, n-1), i))
          in
            reducer' (l, i)
          end

        exception Copy of int * int * int
        fun copy (from, start, finish, to, start') =
          let
            val l1 = length from
            val l2 = length to
          in
            if start < 0 orelse start > l1 orelse finish > l1 orelse
               start > finish orelse
               start' < 0 orelse start' + finish - start > l2 then
              raise Copy (start, finish, start')
            else
              let
                fun copy' 0 = ()
                  | copy' n =
                    (update (to, start'+n-1, sub (from, start+n-1));
                     copy' (n-1))
              in
                copy' (finish - start)
              end
          end

        exception Fill of int * int
        fun fill_range (a, start, finish, x) =
          let
            val l = length a
          in
            if start < 0 orelse start > l orelse finish > l orelse
               start > finish then
              raise Fill (start, finish)
            else
              let
                fun fill' 0 = ()
                  | fill' n =
                    (update (a, start+n-1, x);
                     fill' (n-1))
              in
                fill' (finish - start)
              end
          end

        exception Find
        fun find predicate a =
          let
            val l = length a
            fun find' 0 = raise Find
              | find' n = if predicate (sub (a, l-n)) then l-n else find' (n-1)
          in
            find' l
          end

        fun find_default (predicate, default) a =
          let
            val l = length a
            fun find' 0 = default
              | find' n = if predicate (sub (a, l-n)) then l-n else find' (n-1)
          in
            find' l
          end

      end

    structure String =
      struct
	fun ml_string (s,max_size) =
	  let
	    fun to_digit n = chr (n +ord "0")
	      
	    fun aux ([],result,_) = implode (rev result)
	      | aux (_,result,0) = implode (rev ("\\..." :: result))
	      | aux (char::rest,result,n) =
		let val newres =
		  case char of 
		    "\n" => "\\n"::result
		  | "\t" => "\\t"::result
		  | "\"" => "\\\""::result
		  | "\\" => "\\\\"::result
		  | c =>
		      let val n = ord c
		      in
			if n < 32 orelse n >= 127 then
			  let
			    val n1 = n div 10
			  in
			    (to_digit (n mod 10))::
			    (to_digit (n1 mod 10))::
			    (to_digit (n1 div 10))::
			    ("\\")::result
			  end
			else
			  c::result
		      end
		in
		  aux (rest, newres, n-1)
		end
	  in
	    aux (explode s,[],if max_size<0 then ~1 else max_size)
	  end
	open NewJersey.String

        fun implode_char l = implode (map chr l)

      end
    
    structure Char =
      struct
	type char = int
	fun ml_char c = String.ml_string(chr c, ~1)
	val chr = fn x => x
	val ord = fn x => x
	val maxCharOrd = 255
	exception Chr = Chr

	(* Finally define these *)
	val op <  : char * char -> bool = op <
	val op >  : char * char -> bool = op >
	val op <= : char * char -> bool = op <=
	val op >= : char * char -> bool = op >=
      end

    structure ByteArray = 
      struct
        open NewJersey.ByteArray

        exception Range of int
        exception Size

        nonfix sub
        type T = bytearray
 
        val iterate = app

        val array = fn argument => 
          array argument handle Ord => raise Size

        exception Substring = NewJersey.Substring
        fun substring argument =
          extract argument handle _ => raise Substring

        fun to_string b = extract (b, 0, length b)

        fun from_string s =
          let
            val l = size s
            val b = array (l, 0)
            fun from_string' 0 = b
              | from_string' n =
                (update (b, n-1, NewJersey.String.ordof (s, n-1));
                 from_string' (n-1))
          in
            from_string' l
          end

        fun from_list list =
          let
            fun list_length (n, []) = n
              | list_length (n, _::xs) = list_length (n+1, xs)

            val new = array (list_length (0, list), 0)

            fun fill (_, []) = new
              | fill (n, x::xs) =
                (update (new, n, x);
                 fill (n+1, xs))
          in
            fill (0, list)
          end

        val arrayoflist = from_list

        fun tabulate (l, f) =
          if l = 0 then
            arrayoflist []
          else
            let
              val first = f 0
              val a = array (l, first)

              fun init 0 = a
                | init n =
                  (update (a, n-l, f (n-l));
                   init (n-1))
            in
              init (l-1)
            end

        val from_list = arrayoflist

        fun fill (a, x) =
          let
            fun fill' 0 = ()
              | fill' n =
                (update (a, n-1, x);
                 fill' (n-1))
          in
            fill' (length a)
          end

        fun map f a =
          let
            val l = length a
          in
            if l = 0 then
              from_list []
            else
              let
                val first = f (sub (a, 0))
                val new = array (l, first)

                fun map' 0 = new
                  | map' n =
                    (update (new, l-n, f (sub (a, l-n)));
                     map' (n-1))
              in
                map' (l-1)
              end
          end

        fun map_index f a =
          let
            val l = length a
          in
            if l = 0 then
              from_list []
            else
              let
                val first = f (0, sub (a, 0))
                val new = array (l, first)

                fun map' 0 = new
                  | map' n =
                    (update (new, l-n, f (l-n, sub (a, l-n)));
                     map' (n-1))
              in
                map' (l-1)
              end
          end

        fun to_list a =
          let
            fun to_list' (0, list) = list
              | to_list' (n, list) =
                to_list' (n-1, sub (a, n-1) :: list)
          in
            to_list' (length a, nil)
          end

        fun iterate f a =
          let
            val l = length a

            fun iterate' 0 = ()
              | iterate' n =
                (f (sub (a, l-n));
                 iterate' (n-1))
          in
            iterate' l
          end

        fun iterate_index f a =
          let
            val l = length a

            fun iterate' 0 = ()
              | iterate' n =
                (f (l-n, sub (a, l-n));
                 iterate' (n-1))
          in
            iterate' l
          end

        fun rev a =
          let
            val l = length a
          in
            if l = 0 then
              from_list []
            else
              let
                val first = sub (a, 0)
                val new = array (l, first)

                fun rev' 0 = new
                  | rev' n =
                    (update (new, n-1, sub (a, l-n));
                     rev' (n-1))
              in
                rev' (l-1)
              end
          end

        fun duplicate a =
          let
            val l = length a
          in
            if l = 0 then
              from_list []
            else
              let
                val first = sub (a, 0)
                val new = array (l, first)

                fun duplicate' 0 = new
                  | duplicate' n =
                    (update (new, l-n, sub (a, l-n));
                     duplicate' (n-1))
              in
                duplicate' (l-1)
              end
          end

        exception Subarray of int * int
        fun subarray (a, start, finish) =
          let
            val l = length a
          in
            if start < 0 orelse start > l orelse finish > l orelse
               start > finish then
              raise Subarray (start, finish)
            else
              let
                val l' = finish - start
              in
                if l' = 0 then
                  from_list []
                else
                  let
                    val first = sub (a, start)
                    val new = array (l', first)

                    fun copy 0 = new
                      | copy n =
                        (update (new, l'-n, sub (a, start+l'-n));
                         copy (n-1))
                  in
                    copy (l'-1)
                  end
              end
          end

        fun append (array1, array2) =
          let
            val l1 = length array1
            val l2 = length array2
            val l = l1 + l2
          in
            if l = 0 then
              from_list []
            else
              let
                val first =
                  if l1 = 0 then
                    sub (array2, 0)
                  else
                    sub (array1, 0)

                val new = array (l, first)

                fun copy1 0 = new
                  | copy1 n =
                    (update (new, l1-n, sub (array1, l1-n));
                     copy1 (n-1))

                fun copy2 0 = copy1 (l1-1)
                  | copy2 n =
                    (update (new, l-n, sub (array2, l2-n));
                     copy2 (n-1))
              in
                copy2 l2
              end
          end

        fun reducel f (i, a) =
          let
            val l = length a

            fun reducel' (i, 0) = i
              | reducel' (i, n) =
                reducel' (f (i, sub (a, l-n)), n-1)
          in
            reducel' (i, l)
          end

        fun reducel_index f (i, a) =
          let
            val l = length a

            fun reducel' (i, 0) = i
              | reducel' (i, n) =
                reducel' (f (l-n, i, sub (a, l-n)), n-1)
          in
            reducel' (i, l)
          end

        fun reducer f (a, i) =
          let
            val l = length a

            fun reducer' (0, i) = i
              | reducer' (n, i) =
                reducer' (n-1, f (sub (a, n-1), i))
          in
            reducer' (l, i)
          end

        fun reducer_index f (a, i) =
          let
            val l = length a

            fun reducer' (0, i) = i
              | reducer' (n, i) =
                reducer' (n-1, f (n-1, sub (a, n-1), i))
          in
            reducer' (l, i)
          end

        exception Copy of int * int * int
        fun copy (from, start, finish, to, start') =
          let
            val l1 = length from
            val l2 = length to
          in
            if start < 0 orelse start > l1 orelse finish > l1 orelse
               start > finish orelse
               start' < 0 orelse start' + finish - start > l2 then
              raise Copy (start, finish, start')
            else
              let
                fun copy' 0 = ()
                  | copy' n =
                    (update (to, start'+n-1, sub (from, start+n-1));
                     copy' (n-1))
              in
                copy' (finish - start)
              end
          end

        exception Fill of int * int
        fun fill_range (a, start, finish, x) =
          let
            val l = length a
          in
            if start < 0 orelse start > l orelse finish > l orelse
               start > finish then
              raise Fill (start, finish)
            else
              let
                fun fill' 0 = ()
                  | fill' n =
                    (update (a, start+n-1, x);
                     fill' (n-1))
              in
                fill' (finish - start)
              end
          end

        exception Find
        fun find predicate a =
          let
            val l = length a
            fun find' 0 = raise Find
              | find' n = if predicate (sub (a, l-n)) then l-n else find' (n-1)
          in
            find' l
          end

        fun find_default (predicate, default) a =
          let
            val l = length a
            fun find' 0 = default
              | find' n = if predicate (sub (a, l-n)) then l-n else find' (n-1)
          in
            find' l
          end

      end

    structure Integer =
      struct
	val makestring : int -> string = makestring
	val print : int -> unit = fn i => output(std_out, makestring i)
	fun hexmakestring _ = unimplemented"hexmakestring"
	fun hexprint _ = unimplemented"hexprint"
      end

    structure Real =
      struct
	val makestring : real -> string = makestring
	val print : real -> unit = fn r => output(std_out, makestring r)
      end

    structure Time =
      struct

	type time = NewJersey.System.Timer.time
	val zero = NewJersey.System.Timer.TIME {sec=0, usec=0}

	structure Interval =
	  struct
	    type T = time
	    fun to_real _ = unimplemented "MLWorks.Time.Interval.to_real"
	    fun from_real _ =  unimplemented "MLWorks.Time.Interval.from_real"

	    val op+ = NewJersey.System.Timer.add_time
	    val op- = NewJersey.System.Timer.sub_time
	    fun x*y = unimplemented "MLWorks.Time.Interval.*"
	    fun x/y = unimplemented "MLWorks.Time.Interval./"
	    val op< = NewJersey.System.Timer.earlier
	    val decimal_places = ref 2
	    val format = NewJersey.System.Timer.makestring
	  end

	structure Elapsed = 
	  struct
	    datatype T = ELAPSED of {real: Interval.T,
				     user: Interval.T,
				     system: Interval.T,
				     gc: Interval.T}
	      val zero = ELAPSED {real=zero,
				  user=zero,
				  system=zero,
				  gc=zero}
	    fun elapsed () = zero
	    fun elapsed_since _ = zero
	    fun x+y = unimplemented "MLWorks.Time.Elapsed.+"
	    fun x-y = unimplemented "MLWorks.Time.Elapsed.-"
	    fun x*y = unimplemented "MLWorks.Time.Elapsed.*"
	    fun x/y = unimplemented "MLWorks.Time.Elapsed./"
	    fun format _ = ""
	  end
	
	fun now _ = unimplemented "MLWorks.Time.now"
	val op< = NewJersey.System.Timer.earlier

	fun interval _ = unimplemented "MLWorks.Time.interval"

	datatype zone = GREENWICH | LOCAL
	fun format (_, _, time) = NewJersey.System.Timer.makestring time

            (* This must encoded times in the same way as *)
            (* rts/pervasive/time.c and rts/marshal.c *)
	exception MLWorksTimeEncode

	fun encode (NewJersey.System.Timer.TIME {sec, usec}) =
	  let
	    fun marshal_ints [] = []
	      | marshal_ints (x::xs) =
		if x >= 128 then
		  chr ((x mod 128)+128) :: marshal_ints ((x div 128)::xs)
		else
		  chr x :: (marshal_ints xs)
	  in
	    implode (marshal_ints [sec,usec])
	  end
	    
	fun decode s =
	  let
	    fun unmarshal_int (acc,s, []) = raise MLWorksTimeEncode
	      | unmarshal_int (acc,s, c::cs) =
		let
		  val i = ord c
		in
		  if i >= 128 then
		    unmarshal_int (acc+ ((i mod 128) * s),
				   s*128, cs)
		  else
		    (acc+(i * s),cs)
		end
	    val (sec,s') = unmarshal_int (0,1,explode s)
	    val (usec,_) = unmarshal_int (0,1,s')
	  in
	    NewJersey.System.Timer.TIME {sec = sec,usec = usec}
	  end

	val op+ = NewJersey.System.Timer.add_time
	val op- = NewJersey.System.Timer.sub_time
      end

    structure Threads =
      struct
	type 'a thread = unit

	fun fork _ = unimplemented "MLWorks.Threads.fork"
	fun yield _ = unimplemented "MLWorks.Threads.yield"

	datatype 'a result =
	  Running		(* still running *)
	| Waiting		(* waiting *)
	| Sleeping		(* sleeping *)
	| Result of 'a		(* completed, with this result *)
	| Exception of exn	(* exited with this uncaught exn *)
	| Died			(* died (e.g. bus error) *)
	| Killed		(* killed *)
	| Expired		(* no longer exists (from a previous image) *)

	fun result _ = unimplemented "MLWorks.Threads.result"
	fun sleep _ =  unimplemented "MLWorks.Threads.sleep"
	fun wake _ =  unimplemented "MLWorks.Threads.wake"

	structure Internal =
	  struct
	    type thread_id = unit
	    fun id _ = unimplemented "MLWorks.Threads.Internal.id"
	    fun get_id _ = unimplemented "MLWorks.Threads.Internal.get_id"
	    fun children _ = unimplemented "MLWorks.Threads.Internal.children"
	    fun parent _ = unimplemented "MLWorks.Threads.Internal.parent"
	    fun all _ = unimplemented "MLWorks.Threads.Internal.all"
	    fun kill _ = unimplemented "MLWorks.Threads.Internal.kill"
	    fun raise_in _ = unimplemented "MLWorks.Threads.Internal.raise_in"
	    fun yield_to _ = unimplemented "MLWorks.Threads.Internal.yield_to"
	    fun state _ = unimplemented "MLWorks.Threads.Internal.state"
	    fun get_num _ = unimplemented "MLWorks.Threads.Internal.get_num"
	    fun set_handler _ =
	      unimplemented "MLWorks.Threads.Internal.set_handler"
	    fun reset_fatal_status _ = unimplemented "MLWorks.Threads.Internal.reset_fatal_status"
	    structure Preemption = 
	      struct
		fun start _ = unimplemented "MLWorks.Threads.Internal.Preemption.start"
		fun stop _ = unimplemented "MLWorks.Threads.Internal.Preemption.stop"
		fun on _ = unimplemented "MLWorks.Threads.Internal.Preemption.on"
		fun get_interval _ = unimplemented "MLWorks.Threads.Internal.Preemption.get_interval"
		fun set_interval _ = unimplemented "MLWorks.Threads.Internal.Preemption.set_interval"
	      end
	  end
      end

    structure RawIO =
      struct
        open NewJersey (* types instream, outstream,
			  values std_in, std_out, std_err, open_in, open_out, end_of_stream, input,
			         lookahead, output, close_in, close_out *)

	fun output_byte(fd, byte) = output(fd, chr byte)

	fun closed_in _ = unimplemented "MLWorks.IO.closed_in"
	fun closed_out _ = unimplemented "MLWorks.IO.closed_out"
	fun clear_eof _ = unimplemented "MLWorks.IO.clear_eof"
      end

    structure IO =
      struct
        open RawIO
        val terminal_in = std_in
        fun with_standard_input _ = unimplemented "MLWorks.IO.with_standard_input"
        val terminal_out = std_out
	val messages = std_err
        fun instream _ = std_in
        fun outstream _ = std_out
        fun with_standard_output _ = unimplemented "MLWorks.IO.with_standard_output"
        fun with_standard_error _ = unimplemented "MLWorks.IO.with_standard_error"
	datatype modtime = NOW | TIME of Time.time

        fun file_modified filename =
          NewJersey.System.Unsafe.SysIO.mtime
          (NewJersey.System.Unsafe.SysIO.PATH filename)
          handle _ => raise Io (implode ["Cannot mtime ", filename, ": doesn't exist"])

	fun set_file_modified _ = unimplemented "MLWorks.IO.set_file_modified";

      end

    structure Profile =
      struct
	type manner = int
	type function_id = string
	type cost_centre_profile = unit
	  
	datatype object_kind =
	  RECORD
	| PAIR
	| CLOSURE
	| STRING
	| ARRAY
	| BYTEARRAY
	| OTHER		(* includes weak arrays, code objects *)
	| TOTAL		(* used when specifying a profiling manner *)
	  
	datatype large_size =
	  Large_Size of
	  {megabytes : int,
	   bytes : int}	
	  
	datatype object_count =
	  Object_Count of
	  {number : int,
	   size : large_size,
	   overhead : int}
	  
	type object_breakdown = (object_kind * object_count) list
	  
	datatype function_space_profile =
	  Function_Space_Profile of
	  {allocated : large_size,	
	   copied : large_size,		
	   copies : large_size list,
	   allocation : object_breakdown list}
	  
	datatype function_caller =
	  Function_Caller of
	  {id: function_id,
	   found: int,
	   top: int,
	   scans: int,
	   callers: function_caller list}
	  
	datatype function_time_profile =
	  Function_Time_Profile of
	  {found: int,
	   top: int,
	   scans: int,
	   depth: int,
	   self: int,
	   callers: function_caller list}
	  
	datatype function_profile =
	  Function_Profile of
	  {id: function_id,
	   call_count: int,
	   time: function_time_profile,
	   space: function_space_profile}
	  
	datatype general_header = 
	  General of
	  {data_allocated: int,
	   period: Time.Interval.T,
	   suspended: Time.Interval.T}
	  
	datatype call_header = 
	  Call of {functions : int}
	  
	datatype time_header =
	  Time of
	  {data_allocated: int,
	   functions: int,
	   scans: int,
	   gc_ticks: int,
	   profile_ticks: int,
	   frames: real,
	   ml_frames: real,
	   max_ml_stack_depth: int}
	  
	datatype space_header = 
	  Space of
	  {data_allocated: int,
	   functions: int, 
	   collections: int, 
	   total_profiled : function_space_profile} 
	  
	type cost_header = unit
	  
	datatype profile =
	  Profile of
	  {general: general_header,
	   call: call_header,
	   time: time_header,
	   space: space_header,
	   cost: cost_header,
	   functions: function_profile list,
	   centres: cost_centre_profile list}
	  
	datatype options =
	  Options of
	  {scan : int,
	   selector : function_id -> manner}
	  
	datatype 'a result = 
	  Result of 'a
	| Exception of exn
	  
	exception ProfileError of string
	
	fun profile (Options {scan, selector}) f a =
	  unimplemented "MLWorks.Profile.profile"
	  
	fun make_manner {time, space, copies, calls, depth, breakdown} = 
	  unimplemented "MLWorks.Profile.make_manner"
	  
      end

    exception Save of string
    fun save (filename, function) =
      (NewJersey.exportFn (filename, fn _ => (function (); ()));
       function)

    fun deliver _ = unimplemented "MLWorks.deliver"

    fun exec_save _ = unimplemented "MLWorks.exec_save"

    structure OS =
      struct
        fun arguments () =
          case NewJersey.System.argv ()
            of [] => []
             | program_name::rest => rest
      end

    structure Debugger =
      struct
        fun default_break s = IO.output(IO.std_out,"Break at " ^ s ^ "\n")
        val break_hook = ref default_break
        fun break s = (!break_hook) s
      end

    structure Internal =
      struct
        val text_preprocess = ref (fn (f : int -> string ) => f)
        val real_to_string = NewJersey.makestring

        exception StringToReal

        fun string_to_real chars =
          let
            exception too_small
            exception too_big
            fun getint str =
              let
                fun convert res [] = res
                  | convert res (h :: t) =
                    let
                      val d = ord h - ord "0"
                    in
                      if d >= 0 andalso d <= 9 then
                        convert (res * 10 + d) t
                      else
                        raise StringToReal
                    end
              in
                convert 0 str
              end

            fun decode_real x =
              let
                val string_chars = explode x
                val (sign, string_chars) = case string_chars of
                  [] => raise StringToReal
                | "~" :: xs => (true, xs)
                | _ => (false, string_chars)
                val (integer, fraction, exponent) =
                  let
                    fun find_point_exp(integer, fraction, exponent, _, _, []) =
                      (rev integer, rev fraction, rev exponent)
                      | find_point_exp(integer, fraction, exponent, got_point, got_exp,
                                       "." :: xs) =
                        find_point_exp(integer, [], [], true, false, xs)
                      | find_point_exp(integer, fraction, exponent, got_point, got_exp,
                                       "E" :: xs) =
                        find_point_exp(integer, fraction, [], true, true, xs)
                      | find_point_exp(integer, fraction, exponent, got_point, got_exp,
                                       x :: xs) =
                        if got_exp then
                          find_point_exp(integer, fraction, x :: exponent, true, true, xs)
                        else
                          if got_point then
                            find_point_exp(integer, x :: fraction, [], true, false, xs)
                          else
                            find_point_exp(x :: integer, [], [], false, false, xs)
                  in
                    find_point_exp([], [], [], false, false, string_chars)
                  end
                val (exponent_sign, exponent) = case exponent of
                  [] => (false, ["0"])
                | "~" :: xs => (true, xs)
                | _ => (false, exponent)
                val integer = integer @@ fraction
                val exponent =
                  getint exponent
                  handle _ => raise(if exponent_sign then too_small else too_big)
                val exponent =
                  (if exponent_sign then ~exponent else exponent) - length fraction
              in
                (sign, integer, exponent < 0, abs exponent)
              end
            
            
            val (sign, floor, exp_sign, exponent) = decode_real chars
              
            fun floor_to_real([], result) = result
              | floor_to_real(x :: xs, result) =
                floor_to_real(xs, 10.0 * result + real(ord(x) - ord"0"))
            val r = floor_to_real(floor, 0.0)
              
            fun apply_exponent(r, sign, exponent) =
              if exponent = 0 then r
              else
                let
                  val conv = real exponent * ln 10.0
                  val conv = if sign then ~conv else conv
                in
                  r * exp conv handle _ => raise(if sign then too_small else too_big)
                end
            val r = apply_exponent(r, exp_sign, exponent)
          in
            if sign then ~r else r
          end

	structure Images =
	  struct
	    fun clean _ = ()
	    val save = save
	    exception Table of string
	    fun table _ = []
	  end

	structure Types =
	  struct
	    (* These are all somewhat bogus. *)
	    type word8 = int
	    type int8 = int
	    type word16 = int
	    type int16 = int
	    type word32 = int
	    type int32 = int
	  end

        structure Word =
          struct
	    type word = int
	    local
	      open NewJersey.Bits
	    in
	      val word_lshift  : word * word -> word = lshift
	      val word_rshift  : word * word -> word = rshift
	      val word_arshift : word * word -> word =
	        fn _ => unimplemented "MLWorks.Word.arshift"
	      val word_orb  : word * word -> word = orb
	      val word_xorb : word * word -> word = xorb
	      val word_andb : word * word -> word = andb
	      val word_notb : word -> word = notb
	    end
          end

        structure Word32 =
          struct
	    type word = int
	    local
	      open NewJersey.Bits
	    in
	      val word32_lshift  : word * word -> word = lshift
	      val word32_rshift  : word * word -> word = rshift
	      val word32_arshift : word * word -> word =
	        fn _ => unimplemented "MLWorks.Word.arshift"
	      val word32_orb  : word * word -> word = orb
	      val word32_xorb : word * word -> word = xorb
	      val word32_andb : word * word -> word = andb
	      val word32_notb : word -> word = notb
	    end
          end

        structure Value =
          struct
            type T = unit
            type ml_value = T
            exception Value of string
            val cast = NewJersey.System.Unsafe.cast
            val ccast = NewJersey.System.Unsafe.cast
            datatype print_options =
              DEFAULT |
              OPTIONS of {depth_max	  	: int,
                          string_length_max	: int,
                          indent		: bool,
                          tags		  	: bool}

            fun unsafe_plus _ = unimplemented "MLWorks.Internal.Value.unsafe_plus"
            fun unsafe_minus _ = unimplemented "MLWorks.Internal.Value.unsafe_minus"

            val unsafe_array_sub = Array.sub
            val unsafe_array_update = Array.update

            val unsafe_bytearray_sub = ByteArray.sub
            val unsafe_bytearray_update = ByteArray.update

            fun unsafe_record_sub _ = unimplemented "MLWorks.Internal.Value.unsafe_record_sub"
            fun unsafe_record_update _ = unimplemented "MLWorks.Internal.Value.unsafe_record_update"

            fun unsafe_string_sub _ = unimplemented "MLWorks.Internal.Value.unsafe_string_sub"
            fun unsafe_string_update _ = unimplemented "MLWorks.Internal.Value.unsafe_string_update"

            fun alloc_pair _ = unimplemented "MLWorks.Internal.Value.alloc_pair"
            fun alloc_string _ = unimplemented "MLWorks.Internal.Value.alloc_string"
            fun alloc_vector _ = unimplemented "MLWorks.Internal.Value.alloc_vector"

            fun list_to_tuple _ = unimplemented "MLWorks.Internal.Value.list_to_tuple"
            fun tuple_to_list _ = unimplemented "MLWorks.Internal.Value.tuple_to_list"
            fun string_to_real _ = unimplemented "MLWorks.Internal.Value.string_to_real"
            fun real_to_string _ = unimplemented "MLWorks.Internal.Value.real_to_string"
            fun print _ = unimplemented "MLWorks.Internal.Value.print"
            fun primary _ = unimplemented "MLWorks.Internal.Value.primary"
            fun header _ = unimplemented "MLWorks.Internal.Value.secondary"
            fun update_header _ = unimplemented "MLWorks.Internal.Value.update_header"
            fun pointer _ = unimplemented "MLWorks.Internal.Value.pointer"
            fun update _ = unimplemented "MLWorks.Internal.Value.update"
            fun sub _ = unimplemented "MLWorks.Internal.Value.sub"
            fun update_byte _ = unimplemented "MLWorks.Internal.Value.update_byte"
            fun sub_byte _ = unimplemented "MLWorks.Internal.Value.sub_byte"
            fun update_header _ = unimplemented "MLWorks.Internal.Value.update_header"
            fun exn_name _ = unimplemented "MLWorks.Internal.Value.exn_name"
            fun code_name _ = unimplemented "MLWorks.Internal.Value.code_name"
            fun exn_argument _ = unimplemented "MLWorks.Internal.Value.exn_argument"
            fun exn_name_string _ = unimplemented "MLWorks.Internal.Value.exn_name_string"

            structure Frame = 
              struct
                type frame = unit

                fun frame_call _ = unimplemented "MLWorks.Internal.Value.Frame.frame_call"
                fun frame_next _ = unimplemented "MLWorks.Internal.Value.Frame.frame_next"
                fun frame_offset _ = unimplemented "MLWorks.Internal.Value.Frame.frame_offset"
                fun frame_double _ = unimplemented "MLWorks.Internal.Value.Frame.frame_double"
                fun frame_allocations _ = unimplemented "MLWorks.Internal.Value.Frame.frame_allocations"
                fun is_ml_frame _ = unimplemented "MLWorks.Internal.Value.Frame.is_ml_frame"
                fun sub _ = unimplemented "MLWorks.Internal.Value.Frame.sub"
                fun update _ = unimplemented "MLWorks.Internal.Value.Frame.update"
                fun current _ = unimplemented "MLWorks.Internal.Value.Frame.current"
              end
          end

        structure Trace =
          struct
            exception Trace of string
            fun intercept _ = unimplemented "MLWorks.Internal.Trace.intercept"
            fun replace _ = unimplemented "MLWorks.Internal.Trace.replace"
            fun restore _ = unimplemented "MLWorks.Internal.Trace.restore" 
	    fun restore_all _ = unimplemented "MLWorks.Internal.Trace.restore_all" 
            datatype status = INTERCEPT | NONE | REPLACE
            fun status _ = unimplemented "MLWorks.Internal.Trace.status"
          end

        structure Dynamic =
          struct
            type dynamic = int ref * int ref
            type type_rep = int ref
            exception Coerce of type_rep * type_rep

            val generalises_ref : (type_rep * type_rep -> bool) ref =
	      ref (fn _ => false)

	    local
              fun generalises data = (!generalises_ref) data

              val get_type = Value.cast (fn (a,b) => b)
              val get_value = Value.cast (fn (a,b) => a)
	    in
              fun coerce (d,t) =
                if generalises (get_type d,t) then
		  get_value d
                else
		  raise Coerce(get_type d,t)
	    end
          end

        structure FileIO =
          struct
            type fd = NewJersey.System.Unsafe.SysIO.fd * NewJersey.ByteArray.bytearray * int ref
            datatype offset = BEG | CUR | END

            fun flush (fd, buffer, bp) =
              (NewJersey.System.Unsafe.SysIO.write(fd, buffer, !bp); bp := 0)

            fun openf s =
              (NewJersey.System.Unsafe.SysIO.openf(s, NewJersey.System.Unsafe.SysIO.O_WRITE),
               NewJersey.ByteArray.array (4096, 0), ref 0)

	      (* to close:
	       - flush our buffer,
	       - do an fsync,
	       - close the file.
	       The fsync is required to avoid MLWorks bug 561, q.v.
	       The fsync is very ugly. Nick Haines 14-Mar-94 *)
	      
            fun closef (f as (fd, _, _)) =
              (flush f;
	       NewJersey.System.Unsafe.CInterface.wrap_sysfn
	       "fsync"
	       NewJersey.System.Unsafe.CInterface.syscall
	       (95,[NewJersey.System.Unsafe.cast fd]);
	       NewJersey.System.Unsafe.SysIO.closef fd)

            fun seekf (f as (fd, _, _), i, p) =
              let
                val pos = case p of
                  BEG => NewJersey.System.Unsafe.SysIO.L_SET
                | CUR => NewJersey.System.Unsafe.SysIO.L_INCR
                | END => NewJersey.System.Unsafe.SysIO.L_XTND
              in
                flush f; NewJersey.System.Unsafe.SysIO.lseek (fd, i, pos); ()
              end

            fun writebf (f as (fd, _, _), bytearray, start, length) =
              (flush f; NewJersey.System.Unsafe.SysIO.writei (fd, bytearray, start, length))

            fun writef ((fd, buffer, bp), s) =
              let
                val sz = size s

                fun copy (x, ptr) =
                  if x > 4095 then
                    (NewJersey.System.Unsafe.SysIO.write(fd, buffer, 4096); copy(0, ptr))
                  else
                    if ptr < sz then
                      (NewJersey.ByteArray.update(buffer, x, NewJersey.String.ordof(s,ptr)); copy(x+1, ptr+1))
                    else
                      (bp := x)
              in
                copy(!bp, 0)
              end

	    fun write_byte(fd, byte) = writef(fd, chr byte)
          end

        structure Runtime =
	  struct
            exception Unbound of string
            val environment = Value.cast o nj_environment (* Defined in nj_env.sml *)

            val modules = ref ([] : (string * Value.T * Time.time) list)

            structure Loader =
              struct
                exception Load of string
                fun load_module _ = unimplemented "MLWorks.Internal.Runtime.Loader.load_module"
                fun load_wordset _ = unimplemented "MLWorks.Internal.Runtime.Loader.load_wordset"
              end

	    structure Memory =
	      struct
		val gc_message_level = ref 0
		val max_stack_blocks = ref 0
                fun collect _ = unimplemented "MLWorks.Internal.Runtime.Memory.collect"
                fun collect_all _ = unimplemented "MLWorks.Internal.Runtime.Memory.collect_all"
                fun promote_all _ = unimplemented "MLWorks.Internal.Runtime.Memory.promote_all"
                fun collections _ = unimplemented "MLWorks.Internal.Runtime.Memory.collections"
	      end

            structure Event =
              struct
                datatype T = SIGNAL of int
                exception Signal of string
                fun signal _ = unimplemented "MLWorks.Internal.Runtime.Event.signal"
		fun stack_overflow_handler _ = unimplemented "MLWorks.Internal.Runtime.Event.stack_overflow_handler"
		fun interrupt_handler _ = unimplemented "MLWorks.Internal.Runtime.Event.interrput_handler"
		  
              end

          end
      end

  end;

structure Bits = NewJersey.Bits;
structure OldNewJersey = NewJersey;
structure NewJersey = struct end;
@


1.113.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.113.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.113.8.1
log
@branched from 1.113
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.113.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.113.8.1  1997/05/12  10:36:53  hope
 * branched from 1.113
 *
@


1.113.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.113.8.1  1997/05/12  10:36:53  hope
 * branched from 1.113
 *
@


1.113.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.113.8.1  1997/05/12  10:36:53  hope
 * branched from 1.113
 *
@


1.113.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.113.8.1.1.1  1997/07/28  18:22:10  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.113.7.1
log
@branched from 1.113
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.113.6.1
log
@branched from 1.113
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.113.6.1.1.1
log
@branched from 1.113.6.1
@
text
@a13 3
 * Revision 1.113.6.1  1996/12/17  17:50:16  hope
 * branched from 1.113
 *
@


1.113.5.1
log
@branched from 1.113
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.113.4.1
log
@branched from 1.113
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.113.4.1.1.1
log
@branched from 1.113.4.1
@
text
@a13 3
 * Revision 1.113.4.1  1996/11/14  12:52:40  hope
 * branched from 1.113
 *
@


1.113.3.1
log
@branched from 1.113
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.113.2.1
log
@branched from 1.113
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.113.1.1
log
@branched from 1.113
@
text
@a13 4
 * Revision 1.113  1996/04/18  09:15:09  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
@


1.112
log
@Adding definition of outstream
@
text
@d14 3
a392 4
    fun exit _ = unimplemented "MLWorks.exit"
    fun terminate _ = unimplemented "MLWorks.exit"
    fun atExit _ = unimplemented "MLWorks.exit"

a1478 4
        datatype name = UNIX | WIN_NT
        fun name () = UNIX

        val system = NewJersey.System.system
@


1.111
log
@Converted the types Dynamic and Type to the new identifier naming scheme.
@
text
@d14 3
d1336 2
a1337 2
        fun instream _ = unimplemented "MLWorks.IO.instream"
        fun outstream _ = unimplemented "MLWorks.IO.outstream"
@


1.110
log
@Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
some functionality to the Shell structure.
@
text
@d14 4
d1720 3
a1722 3
            type Dynamic = int ref * int ref
            type Type = int ref
            exception Coerce of Type * Type
d1724 1
a1724 1
            val generalises_ref : (Type * Type -> bool) ref =
@


1.109
log
@name change fn_save => deliver
@
text
@d14 3
d1714 23
a1830 20
      end

    structure Dynamic =
      struct
        type Dynamic = int ref * int ref
        type Type = int ref
        exception Coerce of Type * Type
        exception NoGeneralises

        val generalises_ref : (Type * Type -> bool) ref = ref (fn (t,t') => raise NoGeneralises)
        fun generalises data = (!generalises_ref) data

        val get_type = Internal.Value.cast (fn (a,b) => b)
        val get_value = Internal.Value.cast (fn (a,b) => a)

        (* rely on generalises raising an exception *)
        fun coerce (d,t) =
          (if generalises (get_type d,t)
             then get_value d
           else raise Coerce(get_type d,t))
@


1.108
log
@Adding nj-env.sml file
@
text
@d14 3
d1464 1
a1464 1
    fun fn_save _ = unimplemented "MLWorks.fn_save"
@


1.107
log
@OS reorganisation: Remove the OS specific stuff since
this is no longer in the pervasive library.
@
text
@d14 4
a1696 12
        structure Architecture  =
          struct
            datatype name = SPARC
            fun name () = unimplemented "MLWorks.Internal.Architecture.name"

            structure SPARC =
              struct
                fun flush_windows _ =
                  unimplemented "MLWorks.Internal.Architecture.SPARC.flush_windows"
              end
          end

d1770 1
a1770 1
            fun environment _ = unimplemented "MLWorks.Internal.Runtime.environment"
a1800 69
	    structure Exception =
	      struct
		(* Remove the constructor status *)
		structure S :
		  sig
		    type T
		    val Diff : T
		    val Div : T
		    val Floor : T
		    val Io : T
		    val Mod : T
		    val Prod : T
		    val Profile : T
		    val Quot : T
		    val Save : T
		    val Substring : T
		    val Sum : T
                    val Abs : T
                    val Exp : T
                    val Ln : T
                    val Load : T
                    val Signal : T
                    val Sqrt : T
                    val StorageManager : T
                    val StringToReal : T
                    val Trace : T
                    val Unbound : T
                    val Unix : T
		    val WouldBlock : T
                    val Value : T
		    val Overflow : T
		  end =
		  struct
		    datatype T =
                      Io | Prod | Mod | Div | Substring | Save |
                      Profile | Signal | Load | Unbound | StorageManager |
                      Abs | Ln | Sqrt | StringToReal | Exp | Value |
                      Sum | Diff | Quot | Floor | Trace | Unix | WouldBlock |
		      Overflow
		  end
		open S
		  
		exception E
		val Div = ref E
		val Io = ref E
		val Mod = ref E
		val Profile = ref E
		val Save = ref E
		val Substring = ref E
                val Abs = ref E
                val Diff = ref E
                val Exp = ref E
                val Floor = ref E
                val Ln = ref E
                val Load = ref E
		val Overflow = ref E
                val Prod = ref E
                val Quot = ref E
                val Signal = ref E
                val Sqrt = ref E
                val StorageManager = ref E
                val StringToReal = ref E
                val Sum = ref E
                val Trace = ref E
                val Unbound = ref E
                val Unix = ref E
		val WouldBlock = ref E
                val Value = ref E
	      end
@


1.106
log
@Change to GC interface.
@
text
@d14 3
a1470 72

        structure Unix =
          struct
            exception Unix of string
            exception WouldBlock
            datatype sockaddr = SOCKADDR_UNIX of string
            val environment = NewJersey.System.environ
            val setwd = System.Directory.cd
	    fun password_file _ = unimplemented "MLWorks.OS.Unix.password_file"
            val getwd = NewJersey.System.Directory.getWD
            fun realpath (s: string) :string =
	      NewJersey.System.Unsafe.CInterface.c_function
		"realpath"
		(NewJersey.System.Unsafe.CInterface.c_string s)
	      handle NewJersey.System.Unsafe.CInterface.SysError _ =>
		raise Io ("realpath: " ^ s)
            fun rusage _ = unimplemented "MLWorks.OS.Unix.rusage"
	    fun stat _ = unimplemented "MLWorks.OS.Unix.stat"
            fun open_ _ = unimplemented "MLWorks.OS.Unix.open_"
            fun close _ = unimplemented "MLWorks.OS.Unix.close"
            fun unlink _ = unimplemented "MLWorks.OS.Unix.unlink"
	    fun set_block_mode _ = unimplemented "MLWorks.OS.Unix.set_block_mode"
	    fun can_input _ = unimplemented "MLWorks.OS.Unix.can_input"
            fun write _ = unimplemented "MLWorks.OS.Unix.write"
            fun read _ = unimplemented "MLWorks.OS.Unix.read"
            fun seek _ = unimplemented "MLWorks.OS.Unix.seek"
            fun socket _ = unimplemented "MLWorks.OS.Unix.socket"
            fun bind _ = unimplemented "MLWorks.OS.Unix.bind"
            fun getsockname _ = unimplemented "MLWorks.OS.Unix.getsockname"
            fun getpeername _ = unimplemented "MLWorks.OS.Unix.getpeername"
            fun connect _ = unimplemented "MLWorks.OS.Unix.connect"
            fun accept _ = unimplemented "MLWorks.OS.Unix.accept"
            fun listen _ = unimplemented "MLWorks.OS.Unix.listen"
            fun execve _ = unimplemented "MLWorks.OS.Unix.execve"
            fun execv _ = unimplemented "MLWorks.OS.Unix.execv"
            fun execvp _ = unimplemented "MLWorks.OS.Unix.execvp"
            fun vfork_execve _ = unimplemented "MLWorks.OS.Unix.vfork_execve"
            fun vfork_execv _ = unimplemented "MLWorks.OS.Unix.vfork_execv"
            fun vfork_execvp _ = unimplemented "MLWorks.OS.Unix.vfork_execvp"
            fun mkdir _ = unimplemented "MLWorks.OS.Unix.mkdir"
            fun rmdir _ = unimplemented "MLWorks.OS.Unix.rmdir"
            type dir = unit
            fun opendir _ = unimplemented "MLWorks.OS.Unix.opendir"
            fun readdir _ = unimplemented "MLWorks.OS.Unix.readdir"
            fun closedir _ = unimplemented "MLWorks.OS.Unix.closedir"
            datatype passwd =
              PASSWD of {dir	: string,
                         gecos	: string,
                         gid	: int,
                         name	: string,
                         passwd	: string,
                         shell	: string,
                         uid	: int}
            fun getpwent _ = unimplemented "MLWorks.OS.Unix.getpwent"
            fun setpwent _ = unimplemented "MLWorks.OS.Unix.setpwent"
            fun endpwent _ = unimplemented "MLWorks.OS.Unix.endpwent"
            fun getpwuid _ = unimplemented "MLWorks.OS.Unix.getpwuid"
            fun getpwnam _ = unimplemented "MLWorks.OS.Unix.getpwnam"
            fun kill _ = unimplemented "MLWorks.OS.Unix.kill"
          end

	structure Win_nt =
	  struct
	    exception Nt of int
	    val environment = NewJersey.System.environ
            fun get_current_directory _ = unimplemented "MLWorks.OS.Win_nt.get_current_directory"
	    fun get_path_name _ = unimplemented "MLWorks.OS.Win_nt.get_path_name"
            type DirHandle = int
            fun find_first_file _ = unimplemented "MLWorks.OS.Win_nt.find_first_file"
            fun find_next_file _ = unimplemented "MLWorks.OS.Win_nt.find_next_file"
            fun find_close _ = unimplemented "MLWorks.OS.Win_nt.find_close"
	  end
@


1.105
log
@Adding NT directory operations
@
text
@d14 3
d1858 1
a1858 1
	    structure StorageManager =
a1859 1
                exception StorageManager of int
d1861 5
a1865 1
                fun interface _ = unimplemented "MLWorks.Internal.Runtime.StorageManager.interface"
@


1.104
log
@Add thread sleep and wake operations.
@
text
@d14 3
d1532 4
@


1.103
log
@Update wrt change in ../pervasive/__pervasive_library.sml
@
text
@d14 3
d1260 3
@


1.102
log
@Signal reservation removed.
@
text
@d14 3
d1272 1
@


1.101
log
@Pervasive module names now begin with a space.
@
text
@d14 3
a1849 3
		fun reserve_signal _ = unimplemented "MLWorks.Internal.Runtime.Event.reserve_signal"
		fun release_signal _ = unimplemented "MLWorks.Internal.Runtime.Event.release_signal"
		fun signal_reserved _ = unimplemented "MLWorks.Internal.Runtime.Event.signal_reserved"
@


1.100
log
@Add Frame.frame_double for accessing directly spilled reals
@
text
@d14 3
d335 5
a339 1
fun require s = use ("../pervasive/" ^ s ^ ".sml");
@


1.99
log
@Add exec_save for saving executables
@
text
@d14 3
d1723 1
@


1.98
log
@COrrected syntax error.
@
text
@d14 3
d1426 2
@


1.97
log
@Made quot and rem be nonfix.
@
text
@d14 3
d330 1
a330 1
nonfix quot rem
@


1.96
log
@Add fn_save
@
text
@d14 3
d326 2
@


1.95
log
@Removed bogus path name that I was using to test previous changes.
@
text
@d14 3
d1413 2
@


1.94
log
@Implemented overloaded types for different sizes of words and ints.
@
text
@d14 3
d317 1
a317 1
fun require s = use ("../boot/pervasive/" ^ s ^ ".sml");
@


1.93
log
@Add ml_char for giving textual representation of chars
@
text
@d14 3
d314 3
a316 1
fun require s = use ("../pervasive/" ^ s ^ ".sml");
a747 38
    structure Word =
      struct
	type word = int

	val wordSize = 30

	val identity = fn x => x
	val wordToInt = identity
	val signExtend = identity
	val intToWord  = identity

	local
	  open NewJersey.Bits
	in
	  val lshift  : word * word -> word = lshift
	  val rshift  : word * word -> word = rshift
	  val arshift : word * word -> word =
	    fn _ => unimplemented "MLWorks.Word.arshift"
	  val orb  : word * word -> word = orb
	  val xorb : word * word -> word = xorb
	  val andb : word * word -> word = andb
	  val notb : word -> word = notb
	end

	val op+ : word * word -> word = op+
	val op- : word * word -> word = op-
	val op* : word * word -> word = op*
	val op div : word * word -> word = op div
	val op mod : word * word -> word = op mod

	val op>  : word * word -> bool = op>
	val op>= : word * word -> bool = op>=
	val op<  : word * word -> bool = op<
	val op<= : word * word -> bool = op<=

        val makestring : word -> string = makestring
      end

d1594 45
@


1.92
log
@Adding makestring function to Word structure
@
text
@d14 3
d730 1
@


1.91
log
@Add Word structure and Overflow exn
@
text
@d14 3
d774 1
@


1.90
log
@Add Overflow to structure exception
@
text
@d14 3
d734 37
@


1.89
log
@Two constructors called MLWorks.Profile.Profile.
@
text
@d14 3
d1793 1
d1800 2
a1801 1
                      Sum | Diff | Quot | Floor | Trace | Unix | WouldBlock
d1818 1
@


1.88
log
@Whoops; major type screwups in new profiler.
@
text
@d14 3
d1375 1
a1375 1
	exception Profile of string
@


1.87
log
@Change to profiler interface.
@
text
@d14 3
d1327 2
a1328 2
	   period: MLWorks.Time.Interval.T,
	   suspended: MLWorks.Time.Interval.T}
d1351 1
a1351 2
	type cost_header
	sharing cost_header = unit
@


1.86
log
@Add chars stuff
Also add new integer functions for hex printing
@
text
@d14 4
d1263 115
a1377 8
        datatype options =
          OPTIONS of {depth	: int,
                      scan	: int,
                      select	: string list}

        exception Profile of string

        fun profile _ = unimplemented "MLWorks.profile"
@


1.85
log
@Change threads restart system.
@
text
@d14 3
d705 15
d1081 2
@


1.84
log
@Add threads system.
@
text
@d14 3
d1189 2
a1190 2
	    fun set_restart _ =
	      unimplemented "MLWorks.Threads.Internal.set_restart"
@


1.83
log
@Bring up to date with revised basis stuff in __pervasive_library.sml
@
text
@d14 3
d1153 44
@


1.82
log
@Adding CAST and UMAP primitives
Removing some stuff from Debugger
@
text
@d14 4
d1217 2
a1218 1
            exception Unix of int
d1231 1
d1235 2
d1239 1
d1602 1
d1610 1
a1610 1
                      Sum | Diff | Quot | Floor | Trace | Unix
d1637 1
@


1.81
log
@Add missing values atExit and terminate
@
text
@d14 3
a1276 1
        datatype 'a option = ABSENT | PRESENT of 'a
a1279 35
        val step_hook = 
          ref(fn _ : string*exn option => ())
        fun step s = (!step_hook) s
        (* ... runtime call created by lambda translator; 
         if this is changed, will have to change the Lambda Translator accordingly *)
        val set_step_hook = 
          ref(fn _ : (int * string) => IO.output(IO.std_out,"No definition for set_step"))
        fun set_step arg = (!set_step_hook) arg
        val breakpoint_hook = 
          ref(fn _ : string => ())
        fun breakpoint s = (!breakpoint_hook) s
        (* ... runtime call created by lambda translator; 
         if this is changed, will have to change the Lambda Translator accordingly *)
        val set_breakpoint_hook = 
          ref(fn _ : string => IO.output(IO.std_out,"No definition for set_breakpoint"))
        fun set_breakpoint arg = (!set_breakpoint_hook) arg
        val breakpoint_on_exit_hook = 
          ref(fn _ : string => ())
        fun breakpoint_on_exit s = (!breakpoint_on_exit_hook) s
        (* ... runtime call created by lambda translator; 
         if this is changed, will have to change the Lambda Translator accordingly *)
        val set_breakpoint_on_exit_hook = 
          ref(fn _ : string => IO.output(IO.std_out,"No definition for set_breakpoint"))
        fun set_breakpoint_on_exit arg = (!set_breakpoint_on_exit_hook) arg
        val delete_breakpoint_hook = 
          ref(fn _ : string => IO.output(IO.std_out,"No definition for delete_breakpoint"))
        fun delete_breakpoint arg = (!delete_breakpoint_hook) arg
        val delete_breakpoints_hook = 
          ref(fn () => IO.output(IO.std_out,"No definition for delete_breakpoints"))
        fun delete_breakpoints arg = (!delete_breakpoints_hook) arg
        val list_breakpoints_hook = 
          ref(fn _ : unit => 
              (IO.output(IO.std_out,"No definition for list_breakpoints");[""]))
        fun list_breakpoints arg = (!list_breakpoints_hook) arg
        val script : string list ref = ref []
d1388 1
@


1.80
log
@Adding implode_char
@
text
@d14 3
d286 2
@


1.79
log
@Unifying Value.Frame and Frame.pointer
@
text
@d14 3
d679 3
@


1.78
log
@Bring into line with current state of Win_nt structure (getcd and get_path_name)
@
text
@d14 3
d1455 3
a1457 1
            type frame = unit
d1459 9
a1467 6
            fun frame_call _ = unimplemented "MLWorks.Internal.Value.frame_call"
            fun frame_next _ = unimplemented "MLWorks.Internal.Value.frame_next"
            fun frame_sub _ = unimplemented "MLWorks.Internal.Value.frame_sub"
            fun frame_offset _ = unimplemented "MLWorks.Internal.Value.frame_offset"
            fun frame_allocations _ = unimplemented "MLWorks.Internal.Value.frame_allocations"

a1478 10
                structure Frame =
                  struct
                    datatype pointer = POINTER of int
                    fun sub _ =
                      unimplemented "MLWorks.Internal.Architecture.SPARC.Frame.sub"
                    fun update _ =
                      unimplemented "MLWorks.Internal.Architecture.SPARC.Frame.update"
                    fun current _ =
                      unimplemented "MLWorks.Internal.Architecture.SPARC.Frame.current"
                  end
@


1.77
log
@Add OS.Win_nt structure
@
text
@d14 3
d1253 2
@


1.76
log
@Adding new unsafe operations in MLWorks.Internal.Value
@
text
@d14 3
d1182 1
a1182 1
        datatype name = UNIX
d1245 6
@


1.75
log
@Added pervasive Option structure
@
text
@d14 3
d1399 20
a1445 5
            val unsafe_array_sub = Array.sub
            val unsafe_array_update = Array.update

            val unsafe_bytearray_sub = ByteArray.sub
            val unsafe_bytearray_update = ByteArray.update
@


1.74
log
@Adding unsafe array operations
@
text
@d14 3
d268 6
@


1.73
log
@Add event functions for stack overflow and interrupt handlers.
@
text
@d14 3
d1413 6
@


1.72
log
@Add messages to Io
@
text
@d14 3
d1533 3
@


1.71
log
@Add trace.restore_all
@
text
@d14 3
d1126 1
@


1.70
log
@Breakpoint settings on function exits.
@
text
@d14 3
d1432 2
a1433 1
            fun restore _ = unimplemented "MLWorks.Internal.Trace.restore"
@


1.69
log
@Updated runtime system handling.
@
text
@d14 3
d1241 8
@


1.68
log
@Updated with set_file_modified and associated type.
@
text
@d14 3
d1508 3
@


1.67
log
@Adding handler around realpath.
@
text
@d14 3
d1008 87
a1099 4
        fun file_modified filename =
          NewJersey.System.Unsafe.SysIO.mtime
          (NewJersey.System.Unsafe.SysIO.PATH filename)
          handle _ => raise Io (implode ["Cannot mtime ", filename, ": doesn't exist"])
a1102 3
	val output_string = output
	val input_string = input

d1118 9
a1210 87
      end

    structure Time =
      struct

	type time = NewJersey.System.Timer.time
	val zero = NewJersey.System.Timer.TIME {sec=0, usec=0}

	structure Interval =
	  struct
	    type T = time
	    fun to_real _ = unimplemented "MLWorks.Time.Interval.to_real"
	    fun from_real _ =  unimplemented "MLWorks.Time.Interval.from_real"

	    val op+ = NewJersey.System.Timer.add_time
	    val op- = NewJersey.System.Timer.sub_time
	    fun x*y = unimplemented "MLWorks.Time.Interval.*"
	    fun x/y = unimplemented "MLWorks.Time.Interval./"
	    val op< = NewJersey.System.Timer.earlier
	    val decimal_places = ref 2
	    val format = NewJersey.System.Timer.makestring
	  end

	structure Elapsed = 
	  struct
	    datatype T = ELAPSED of {real: Interval.T,
				     user: Interval.T,
				     system: Interval.T,
				     gc: Interval.T}
	      val zero = ELAPSED {real=zero,
				  user=zero,
				  system=zero,
				  gc=zero}
	    fun elapsed () = zero
	    fun elapsed_since _ = zero
	    fun x+y = unimplemented "MLWorks.Time.Elapsed.+"
	    fun x-y = unimplemented "MLWorks.Time.Elapsed.-"
	    fun x*y = unimplemented "MLWorks.Time.Elapsed.*"
	    fun x/y = unimplemented "MLWorks.Time.Elapsed./"
	    fun format _ = ""
	  end
	
	fun now _ = unimplemented "MLWorks.Time.now"
	val op< = NewJersey.System.Timer.earlier

	fun interval _ = unimplemented "MLWorks.Time.interval"

	datatype zone = GREENWICH | LOCAL
	fun format (_, _, time) = NewJersey.System.Timer.makestring time

            (* This must encoded times in the same way as *)
            (* rts/pervasive/time.c and rts/marshal.c *)
	exception MLWorksTimeEncode

	fun encode (NewJersey.System.Timer.TIME {sec, usec}) =
	  let
	    fun marshal_ints [] = []
	      | marshal_ints (x::xs) =
		if x >= 128 then
		  chr ((x mod 128)+128) :: marshal_ints ((x div 128)::xs)
		else
		  chr x :: (marshal_ints xs)
	  in
	    implode (marshal_ints [sec,usec])
	  end
	    
	fun decode s =
	  let
	    fun unmarshal_int (acc,s, []) = raise MLWorksTimeEncode
	      | unmarshal_int (acc,s, c::cs) =
		let
		  val i = ord c
		in
		  if i >= 128 then
		    unmarshal_int (acc+ ((i mod 128) * s),
				   s*128, cs)
		  else
		    (acc+(i * s),cs)
		end
	    val (sec,s') = unmarshal_int (0,1,explode s)
	    val (usec,_) = unmarshal_int (0,1,s')
	  in
	    NewJersey.System.Timer.TIME {sec = sec,usec = usec}
	  end

	val op+ = NewJersey.System.Timer.add_time
	val op- = NewJersey.System.Timer.sub_time
@


1.66
log
@Fixing typo (braino?).
@
text
@d14 3
d1073 6
a1078 1
            val realpath = NewJersey.System.Unsafe.CInterface.c_function "realpath" : string -> string
@


1.65
log
@Added realpath to NJ runtime.
@
text
@d14 3
d1070 1
a1070 1
            fun realpath s = NewJersey.System.Unsafe.CInterface.c_function "realpath" : string -> string
@


1.64
log
@Add an fsync when closing files.
@
text
@d14 3
d1067 1
a1067 1
            fun realpath s = s
@


1.63
log
@option was missing in structure Debugger.
@
text
@d14 3
d1413 7
d1421 6
a1426 1
              (flush f; NewJersey.System.Unsafe.SysIO.closef fd)
@


1.62
log
@Step and breakpoints Debugger.
@
text
@d14 3
d1193 1
@


1.61
log
@Hope it works now :-)
@
text
@d14 3
d1193 27
@


1.60
log
@Added definition for realpath.  This is just the identity function.
@
text
@d14 3
a580 1
	open NewJersey.String
d615 1
@


1.59
log
@Added MLWorks.String.ml_string
@
text
@d14 3
d1052 1
@


1.58
log
@Added definition for getwd
@
text
@d14 3
d573 39
a611 2
    structure String = NewJersey.String

@


1.57
log
@Hacks for Elapsed.elapsed, elapsed_since, format.
@
text
@d14 3
d1008 1
a1008 1
            fun getwd _ = unimplemented "MLWorks.OS.Unix.getwd"
@


1.56
log
@Changed type of modules to include a time stamp field
@
text
@d14 3
d1050 4
d1056 1
a1056 1
	    type T = NewJersey.System.Timer.time
d1075 6
a1080 2
	    fun elapsed _ = unimplemented "MLWorks.Time.Elapsed.elapsed"
	    fun elapsed_since _ = unimplemented "MLWorks.Time.Elapsed.elapsed_since"
d1085 1
a1085 1
	    fun format _ = unimplemented "MLWorks.Time.Elapsed.format"
a1087 3
	type time = NewJersey.System.Timer.time

	val zero = NewJersey.System.Timer.TIME {sec=0, usec=0}
@


1.55
log
@Add to IO and RawIO to provide closed_in and closed_out functions for
testing open/closed status. (also fix Time structure bug).
@
text
@d14 4
d1358 1
a1358 1
            val modules = ref ([] : (string * Value.T) list)
@


1.54
log
@New pervasive time structure; in particular extension to encode/decode.
@
text
@d14 3
d933 3
a935 10
        open NewJersey
        val output_string = output
        fun output_real _ = unimplemented "MLWorks.IO.output_real"
        fun output_int _ = unimplemented "MLWorks.IO.output_int"
        fun output_bool _ = unimplemented "MLWorks.IO.output_bool"
        val input_string = input
        fun input_real _ = unimplemented "MLWorks.IO.input_real"
        fun input_int _ = unimplemented "MLWorks.IO.input_int"
        fun input_bool _ = unimplemented "MLWorks.IO.input_bool"
	fun clear_eof _ = (unimplemented "MLWorks.IO.clear_eof") : unit
d940 1
d942 7
d1065 1
a1080 3
	val op+ = NewJersey.System.Timer.+
	val op- = NewJersey.System.Timer.-

d1086 1
a1086 1
            exception MLWorksTimeEncode
d1088 30
a1117 12
            fun encode (NewJersey.System.Timer.TIME {sec, usec}) =
                let
                  fun marshal_ints [] = []
		    | marshal_ints (x::xs) =
                    if x >= 128 then
                      chr ((x mod 128)+128) :: marshal_ints ((x div 128)::xs)
                    else
                      chr x :: (marshal_ints xs)
                in
                  implode (marshal_ints [sec,usec])
                end
              | encode _ = raise MLWorksTimeEncode
d1119 2
a1120 30
            fun decode s =
              let
                fun unmarshal_int (acc,s, []) = raise MLWorksTimeEncode
                  | unmarshal_int (acc,s, c::cs) =
                    let
                      val i = ord c
                    in
                      if i >= 128 then
                        unmarshal_int (acc+ ((i mod 128) * s),
				       s*128, cs)
                      else
                        (acc+(i * s),cs)
                    end
		val (sec,s') = unmarshal_int (0,1,explode s)
		val (usec,_) = unmarshal_int (0,1,s')
              in
                NewJersey.System.Timer.TIME {sec = sec,usec = usec}
              end
          end

        structure Virtual =
          struct
            type T = NewJersey.System.Timer.time
            val zero = NewJersey.System.Timer.start_timer ()
            fun user () = NewJersey.System.Timer.check_timer zero
            fun system () = NewJersey.System.Timer.check_timer_sys zero
            fun gc () = NewJersey.System.Timer.check_timer_gc zero
            val (op-) = NewJersey.System.Timer.sub_time
            val format = NewJersey.System.Timer.makestring
          end
@


1.53
log
@Added OS.Unix.{unlink,rmdir,mkdir}
@
text
@d14 3
d1039 42
a1080 9
        structure Real =
          struct
            type T = NewJersey.System.Timer.time
            fun now _ = unimplemented "MLWorks.Time.Real.now"
            val equal = op=
            val op< = NewJersey.System.Timer.earlier
            val zero = NewJersey.System.Timer.TIME {sec=0, usec=0}
            datatype zone = GREENWICH | LOCAL
            fun format (_, _, time) = NewJersey.System.Timer.makestring time
d1086 1
a1086 1
            fun encode (NewJersey.System.Timer.TIME {sec, usec = 0}) =
d1088 2
a1089 1
                  fun marshal_int x =
d1091 1
a1091 1
                      chr ((x mod 128)+128) :: marshal_int (x div 128)
d1093 1
a1093 1
                      chr x :: nil
d1095 1
a1095 1
                  implode (marshal_int sec)
d1101 2
a1102 2
                fun unmarshal_int (s, []) = raise MLWorksTimeEncode
                  | unmarshal_int (s, c::cs) =
d1107 2
a1108 1
                        (i mod 128) * s + unmarshal_int (s*128, cs)
d1110 1
a1110 1
                        i * s
d1112 2
d1115 1
a1115 1
                NewJersey.System.Timer.TIME {sec = unmarshal_int (1, explode s), usec = 0}
@


1.53.1.1
log
@Fork for bug fixing
@
text
@a13 3
 *  Revision 1.53  1993/08/31  09:52:13  daveb
 *  Added OS.Unix.{unlink,rmdir,mkdir}
 *
@


1.52
log
@Removed the X exception.  It's now in the Motif interface code.
@
text
@d14 3
d995 1
d1011 2
@


1.51
log
@Declared a special version of require for the pervasive modules.  This
is necessary because of changes to the module naming scheme.
@
text
@d14 4
d1096 1
a1367 1
                    val X : T
d1374 1
a1374 1
                      Sum | Diff | Quot | Floor | Trace | Unix | X
a1401 1
                val X = ref E
@


1.50
log
@Added X exception.
@
text
@d14 3
d179 5
a183 1
require "../pervasive/mlworks";
@


1.49
log
@Added dummy MLWorks.OS.Unix.kill.
@
text
@d14 3
d1356 1
d1363 1
a1363 1
                      Sum | Diff | Quot | Floor | Trace | Unix
d1391 1
@


1.48
log
@Changes to MLWORKS signature.  See pervasive/mlworks.sml.
@
text
@d14 3
d1010 1
@


1.47
log
@Added two frame functions for debugger
@
text
@d14 3
d990 17
@


1.46
log
@Added text_preprocess hook
@
text
@d14 3
d1189 2
@


1.45
log
@Added MLWorks.OS.Unix.password_file to get the association list of user names
to home directories necessary for translating ~
@
text
@d14 4
d1053 1
@


1.44
log
@Added Integer and Real substructures of MLWorks
@
text
@d14 3
d960 1
@


1.43
log
@Added write_byte for FileIO and output_byte to RawIO
@
text
@d14 3
d878 12
@


1.42
log
@Removed defunct Editor interface and added sytem calls to enable
its replacement.
@
text
@d14 4
d893 1
d1239 2
@


1.41
log
@New Unix and Trace stuff.  See MLWorks signature.
@
text
@d14 3
a919 10
    structure Editor =
      struct
	exception NotFound of string * string
	datatype Editor = EMACS | VI
	fun load_file s = raise NotFound("", "Not implemented")
	fun emacs_file s = raise NotFound("", "Not implemented")
	fun vi_file s = raise NotFound("", "Not implemented")
	fun other_operation _ = ()
      end

d950 6
@


1.40
log
@Changed TypeRep to Dynamic and restructured
Moved break stuff out of tracing.
@
text
@d1 145
a145 5
(* 
   Redefine the timer functions to give the same results as our system 
   i.e. to return three integers - the high and low parts of the seconds
   field and the usec field
*)
a146 132
(*
$Log: change_nj.sml,v $
Revision 1.39  1993/04/08  17:29:56  jont
Minor modifications to editor structure

Revision 1.38  1993/04/06  13:00:31  jont
Removed use of pervasive ordof

Revision 1.37  1993/04/02  15:27:40  jont
Extended images structure to include table of contents reading

Revision 1.36  1993/03/26  15:53:27  matthew
Added break function to Tracing substructure

Revision 1.35  1993/03/23  18:32:34  jont
Minor change to interface to edit file

Revision 1.34  1993/03/11  18:37:25  jont
Added Intermal.Images including save and clean. Added other_operation to Editor
for arbitrary bits of emacs lisp

Revision 1.33  1993/03/10  16:30:56  jont
Added editor substructure to MLWorks

Revision 1.32  1993/02/18  16:56:08  matthew
Added TypeRep signature in MLWorks.Internal

Revision 1.31  1993/02/17  11:05:21  daveb
Corrected string argument to Unimplemented for MLWorks.Time.Real.now.

Revision 1.30  1993/01/05  16:54:24  richard
Added some extra exceptions for the runtime system.

Revision 1.29  1992/12/22  10:50:12  clive
ExtendedArray should not be available at the top level

Revision 1.28  1992/12/22  10:25:37  daveb
Made ExtendedArray visible at top level.

Revision 1.27  1992/12/22  10:05:26  clive
Needed to define the type T in the Array structure

Revision 1.26  1992/12/22  10:02:01  matthew
> Added 'agreed' Array and Vector structures.
,

Revision 1.25  1992/12/01  13:05:26  matthew
Fixed problem with IO

Revision 1.24  1992/12/01  12:45:10  matthew
Changed IO structure to mirror __pervasive_library

Revision 1.23  1992/11/12  15:58:16  clive
Added some rts support for tracing

Revision 1.22  1992/11/10  13:14:23  richard
Added StorageManager exception and changed the type of the
StorageManager interface function.

Revision 1.21  1992/11/02  10:06:49  richard
Many changes.  See MLWorks signature.

Revision 1.20  1992/09/25  14:36:13  matthew
Added Internal.string_to_real

Revision 1.19  1992/09/23  16:16:41  daveb
Added clear_eof function to IO (unimplemented).

Revision 1.18  1992/09/01  14:34:40  richard
Changed the OS information stuff to functions.  Added Prod and
Value exceptions.
Implemented save.

Revision 1.17  1992/08/28  15:00:49  clive
Added a function to the pervasive_library to get debug_info from a function

Revision 1.16  1992/08/28  08:26:28  richard
Changed call to environment so that environment is not
preserved across images.
Added floating-point exceptions.

Revision 1.15  1992/08/26  14:34:26  richard
Rationalisation of the MLWorks structure.

Revision 1.14  1992/08/25  16:27:11  richard
Added ByteArray structure and writebf in FileIO.

Revision 1.13  1992/08/24  14:16:46  davidt
Added a faster implementation of FileIO.writef which
doesn't allocate as many bytearrays.

Revision 1.12  1992/08/20  12:44:05  richard
Changed path of require of mlworks to use pervasive directory.

Revision 1.11  1992/08/20  08:33:04  richard
Enriched the Array structure.

Revision 1.10  1992/08/18  16:40:49  richard
Added real_to_string.

Revision 1.9  1992/08/18  14:44:59  richard
Changes to the MLWorks signature.  See mlworks file for
details.

Revision 1.8  1992/08/17  11:05:12  richard
Added MLWorks.System.Runtime.GC.interface.

Revision 1.7  1992/08/15  17:32:57  davidt
Put in MLWorks.IO.input_line function.

Revision 1.6  1992/08/13  15:30:59  clive
Added two functions to the debugger

Revision 1.4  1992/08/12  14:21:36  davidt
Took out copying of Array and String structures from the
MLWorks structure in an attempt to see if NewJersey was
getting confused and not inlining code for array updates.

Revision 1.3  1992/08/11  05:59:23  richard
Added load_wordset to Int structure.

Revision 1.2  1992/08/10  15:26:16  davidt
Changed MLworks structure to MLWorks

Revision 1.1  1992/08/07  15:03:28  davidt
Initial revision

Revision 1.1  1992/05/18  15:40:36  clive
Initial revision

*)

d888 11
a898 11
        structure IO =
          struct
            open RawIO
            val terminal_in = std_in
            fun with_standard_input _ = unimplemented "MLWorks.IO.with_standard_input"
            val terminal_out = std_out
            fun instream _ = unimplemented "MLWorks.IO.instream"
            fun outstream _ = unimplemented "MLWorks.IO.outstream"
            fun with_standard_output _ = unimplemented "MLWorks.IO.with_standard_output"
            fun with_standard_error _ = unimplemented "MLWorks.IO.with_standard_error"
          end
d900 6
a905 2
    exception Profile of string
    fun profile _ = unimplemented "MLWorks.profile"
d907 5
d940 2
d946 11
d1128 6
d1160 1
a1160 1
        structure Tracing =
d1162 18
a1179 6
            fun add_trace _ = unimplemented "MLWorks.Internal.Tracing.add_trace"
            fun remove_trace _ = unimplemented "MLWorks.Internal.Tracing.remove_trace"
            fun with_tracing _ _ _ = unimplemented "MLWorks.Internal.Tracing.with_tracing"
            fun default_break s = IO.output(IO.std_out,"Break at " ^ s ^ "\n")
            val break_hook = ref default_break
            fun break s = (!break_hook) s
d1182 10
d1290 1
d1292 1
d1300 1
a1300 1
                      Sum | Diff | Quot | Floor
d1324 1
d1326 1
@


1.39
log
@Minor modifications to editor structure
@
text
@d9 3
d987 7
a1178 90
        structure TypeRep =
              struct
                datatype Label = LABEL of string
                  
                datatype TyName = TYNAME of (int * string * bool)
                  
                datatype TypeRep =
                  TYVAR of (int * bool * bool)
                | RECTYPE of (Label * TypeRep) list
                | FUNTYPE of (TypeRep * TypeRep)
                | CONSTYPE of (TypeRep list * TyName)
                  
                type Dynamic = int ref * int ref
                  
                exception Coerce
                
                fun generalises (rep1,rep2) =
                  let
                    (* This isn't good enough, but.. *)
                    fun typerep_eq (rep1,rep2) = rep1 = rep2
                      
                    fun get_dom l = map (fn (a,_) => a) l
                    fun get_ran l = map (fn (_,b) => b) l
                      
                    exception LookUp
                    fun lookup_tyvar (tyvar,[]) = raise LookUp
                      | lookup_tyvar (n,(m,rep) :: l) =
                        if n = m then rep else lookup_tyvar (n,l)
                          
                    fun forall f [] = true
                      | forall f (a::l) = f a andalso forall f l
                        
                    fun eqtyperep (TYVAR (_,eq,_)) = eq
                      | eqtyperep (RECTYPE labreplist) =
                        forall (fn (_,typerep) => eqtyperep typerep) labreplist
                      | eqtyperep (FUNTYPE _) = false
                      | eqtyperep (CONSTYPE (replist,tyname)) =
                        let fun eqtyname (TYNAME(_,_,eq)) = eq
                        in
                          eqtyname tyname
                          andalso
                          forall eqtyperep replist
                        end
                      
                    exception FailGeneralises of string
                    
                    (* return a new map if rep1 generalises rep2 *)
                    fun gen (TYVAR (n,eq,imp),rep2,map) =
                      (let val rep1 = lookup_tyvar (n,map)
                      in
                         if typerep_eq (rep1,rep2) then map
                         else raise FailGeneralises "Inconsistent tyvar maps"
                      end
                    handle LookUp =>
                      if eq andalso (not (eqtyperep rep2))
                        then raise FailGeneralises "equality attribute required"
                      else(n,rep2) :: map)
                      | gen (RECTYPE labreplist,RECTYPE labreplist',map) =
                        let
                          val dom = get_dom labreplist
                          val dom' = get_dom labreplist'
                        in
                          if dom = dom'
                            then
                              list_gen (get_ran labreplist,get_ran labreplist',map)
                          else raise FailGeneralises "Record domain mismatch"
                        end
                      | gen (FUNTYPE(rep1,rep1'),FUNTYPE(rep2,rep2'),map) =
                        gen (rep1',rep2',gen(rep1,rep2,map))
                      | gen (CONSTYPE(replist,TYNAME(n,_,_)),
                             CONSTYPE(replist',TYNAME(n',_,_)),
                             map) =
                        if n = n'
                          then list_gen(replist,replist',map)
                        else raise FailGeneralises "Tycon mismatch"
                      | gen _ = raise FailGeneralises "Inconsistent types"
                        
                    and list_gen ([],[],map) = map
                      | list_gen (rep::l,rep'::l',map) =
                        list_gen (l,l',gen(rep,rep',map))
                      | list_gen _ = raise FailGeneralises "Constructor parameter mismatch"
                  in
                    (gen (rep1,rep2,[]);true)
                    handle FailGeneralises s => false
                  end
                
                val get_type = Value.cast (fn (a,b) => b)
                val get_value = Value.cast (fn (a,b) => a)
              end

d1268 20
@


1.38
log
@Removed use of pervasive ordof
@
text
@d9 3
d902 2
@


1.37
log
@Extended images structure to include table of contents reading
@
text
@d9 3
d526 1
a526 1
                (update (b, n-1, ordof (s, n-1));
@


1.36
log
@Added break function to Tracing substructure
@
text
@d9 3
d1070 2
@


1.35
log
@Minor change to interface to edit file
@
text
@d9 3
d1106 3
@


1.34
log
@Added Intermal.Images including save and clean. Added other_operation to Editor
for arbitrary bits of emacs lisp
@
text
@d9 4
d889 1
a889 1
	fun load_file s = raise NotFound(s, "Not implemented")
@


1.33
log
@Added editor substructure to MLWorks
@
text
@d9 3
d886 1
d1055 6
@


1.32
log
@Added TypeRep signature in MLWorks.Internal
@
text
@d9 3
d877 7
@


1.31
log
@Corrected string argument to Unimplemented for MLWorks.Time.Real.now.
@
text
@d9 3
d1126 91
a1216 1
	structure Runtime =
@


1.30
log
@Added some extra exceptions for the runtime system.
@
text
@d9 3
d897 1
a897 1
            fun now _ = unimplemented "MLWorks.Time.now"
@


1.29
log
@ExtendedArray should not be available at the top level
@
text
@d9 3
d1154 3
d1158 1
d1160 3
a1162 2
		    val Mod : T
		    val Div : T
d1164 4
a1167 2
		    val Save : T
		    val Profile : T
a1168 3
                    val Unbound : T
                    val Exp : T
                    val Abs : T
d1171 1
d1173 1
a1173 1
                    val Ln : T
a1174 1
                    val StorageManager : T
d1180 2
a1181 1
                      Abs | Ln | Sqrt | StringToReal | Exp | Value
d1186 1
d1189 2
a1190 1
		val Div = ref E
a1191 4
		val Save = ref E
		val Profile = ref E
                val Load = ref E
                val Unbound = ref E
d1193 1
a1193 2
                val Sqrt = ref E
                val StringToReal = ref E
d1195 1
d1197 1
d1199 1
a1199 1
                val Value = ref E
d1201 1
d1203 4
@


1.28
log
@Made ExtendedArray visible at top level.
@
text
@d9 3
a1200 1
structure ExtendedArray = MLWorks.ExtendedArray;
@


1.27
log
@Needed to define the type T in the Array structure
@
text
@d9 3
d1198 1
@


1.26
log
@> Added 'agreed' Array and Vector structures.
,
@
text
@d9 4
d143 5
a147 1
    structure Array = NewJersey.Array
@


1.25
log
@Fixed problem with IO
@
text
@d9 3
d113 29
a141 1
    structure Array =
@


1.24
log
@Changed IO structure to mirror __pervasive_library
@
text
@d9 3
d803 8
a810 137
            datatype instream =
              instream of {input		: int -> string,
                           lookahead		: unit -> string,
                           end_of_stream	: unit -> bool,
                           clear_eof		: unit -> unit,
                           close_in		: unit -> unit}
              
            fun open_in string =
              let
                val standard_instream = RawIO.open_in string
              in
                instream {input =	  fn int => RawIO.input (standard_instream, int),
                          lookahead =	  fn ()  => RawIO.lookahead standard_instream,
                          end_of_stream = fn ()  => RawIO.end_of_stream standard_instream,
                          clear_eof =	  fn ()  => RawIO.clear_eof standard_instream,
                          close_in =	  fn ()  => RawIO.close_in standard_instream}
              end
            
            fun end_of_stream (instream {end_of_stream, ...}) = end_of_stream ()
            fun input (instream {input, ...}, int) = input int
            val input_string = input
            fun clear_eof (instream {clear_eof, ...}) = clear_eof ()
            fun lookahead (instream {lookahead, ...}) = lookahead ()
            fun close_in (instream {close_in, ...}) = close_in ()
              
            val terminal_in =
              instream {input =	          fn int => RawIO.input (RawIO.std_in, int),
                        lookahead =	  fn ()  => RawIO.lookahead RawIO.std_in,
                        end_of_stream =   fn ()  => RawIO.end_of_stream RawIO.std_in,
                        clear_eof =	  fn ()  => RawIO.clear_eof RawIO.std_in,
                        close_in =	  fn ()  => RawIO.close_in RawIO.std_in}
              
            local
              val stream_ref = ref {input =	          fn int => RawIO.input (RawIO.std_in, int),
                                    lookahead =	  fn ()  => RawIO.lookahead RawIO.std_in,
                                    end_of_stream =   fn ()  => RawIO.end_of_stream RawIO.std_in,
                                    clear_eof =	  fn ()  => RawIO.clear_eof RawIO.std_in,
                                    close_in =	  fn ()  => RawIO.close_in RawIO.std_in}
            in
              val std_in = instream {input =	          fn int => (#input(!stream_ref)) int,
                                    lookahead =	  fn ()  => (#lookahead(!stream_ref)) (),
                                    end_of_stream =   fn () => (#end_of_stream(!stream_ref)) (),
                                    clear_eof =	  fn ()  => (#clear_eof(!stream_ref)) (),
                                    close_in =	  fn ()  => (#close_in(!stream_ref)) ()}
              fun with_standard_input (instream stream) f =
                let
                  val oldstream = (!stream_ref)
                  val _ = stream_ref := stream
                  val result = f () handle exn => (stream_ref := oldstream; raise exn)
                in
                  stream_ref := oldstream;
                  result
                end
            end

	    fun input_line file =
	      let
		fun extend_line line =
		  if end_of_stream file then
		    implode(rev line)
		  else
		    let
		      val char = input(file, 1)
		    in
		      if char = "\n" then implode(rev("\n" :: line))
		      else extend_line(char :: line)
		    end
	      in
		extend_line []
	      end

            datatype outstream =
              outstream of {output	: string -> unit,
                            flush_out	: unit -> unit,
                            close_out	: unit -> unit}
              
              
              
            fun open_out string =
              let
                val standard_outstream = RawIO.open_out string
              in
                outstream {output =	fn string => RawIO.output (standard_outstream, string),
                           flush_out =	fn ()     => RawIO.flush_out standard_outstream,
                           close_out =	fn ()     => RawIO.close_out standard_outstream}
              end
            
            fun output (outstream {output, ...}, string) = output string
            val output_string = output
            fun flush_out (outstream {flush_out, ...}) = flush_out ()
            fun close_out (outstream {close_out, ...}) = close_out ()
              
            val terminal_out =
              outstream {output = fn s => RawIO.output(RawIO.std_out,s),
                         flush_out = fn () => RawIO.flush_out RawIO.std_out,
                         close_out = fn () => RawIO.close_out RawIO.std_out}

            local
              val stream_ref = ref {output = fn s => RawIO.output(RawIO.std_out,s),
                                    flush_out = fn () => RawIO.flush_out RawIO.std_out,
                                    close_out = fn () => RawIO.close_out RawIO.std_out}
            in
              val std_out = outstream {output = fn s => (#output (!stream_ref)) s,
                                       flush_out = fn () => (#flush_out (!stream_ref))(),
                                       close_out = fn () => (#close_out(!stream_ref))()}
              fun with_standard_output (outstream stream) f =
                let
                  val oldstream = (!stream_ref)
                  val _ = stream_ref := stream
                  val result = f () handle exn => (stream_ref := oldstream; raise exn)
                in
                  stream_ref := oldstream;
                  result
                end
            end

            local
              val stream_ref = ref {output = fn s => RawIO.output(RawIO.std_err,s),
                                    flush_out = fn () => RawIO.flush_out RawIO.std_err,
                                    close_out = fn () => RawIO.close_out RawIO.std_err}
            in
              val std_err = outstream {output = fn s => (#output (!stream_ref)) s,
                                       flush_out = fn () => (#flush_out (!stream_ref))(),
                                       close_out = fn () => (#close_out(!stream_ref))()}
              fun with_standard_error (outstream stream) f =
                let
                  val oldstream = (!stream_ref)
                  val _ = stream_ref := stream
                  val result = f () handle exn => (stream_ref := oldstream; raise exn)
                in
                  stream_ref := oldstream;
                  result
                end
            end

            val file_modified = RawIO.file_modified

@


1.23
log
@Added some rts support for tracing
@
text
@d9 3
d780 1
a780 1
    structure IO =
d791 1
a791 1
	fun clear_eof _ = unimplemented "MLWorks.IO.clear_eof"
d797 141
@


1.22
log
@Added StorageManager exception and changed the type of the
StorageManager interface function.
@
text
@d9 4
d969 1
a969 1
        
d1000 7
@


1.21
log
@Many changes.  See MLWorks signature.
@
text
@d9 3
d85 3
d92 1
a92 1
    fun exit _ = raise Unimplemented "MLWorks.exit"
d97 1
a97 1
	fun arshift _ = raise Unimplemented "MLWorks.Bits.arshift"
d777 3
a779 3
        fun output_real _ = raise Unimplemented "MLWorks.IO.output_real"
        fun output_int _ = raise Unimplemented "MLWorks.IO.output_int"
        fun output_bool _ = raise Unimplemented "MLWorks.IO.output_bool"
d781 4
a784 4
        fun input_real _ = raise Unimplemented "MLWorks.IO.input_real"
        fun input_int _ = raise Unimplemented "MLWorks.IO.input_int"
        fun input_bool _ = raise Unimplemented "MLWorks.IO.input_bool"
	fun clear_eof _ = raise Unimplemented "MLWorks.IO.clear_eof"
d792 1
a792 1
    fun profile _ = raise Unimplemented "MLWorks.profile"
d814 2
a815 1
            fun getwd _ = raise Unimplemented "MLWorks.OS.Unix.getwd"
d824 1
a824 1
            fun now _ = raise Unimplemented "MLWorks.Time.now"
d972 18
a989 18
            fun list_to_tuple _ = raise Unimplemented "MLWorks.Internal.Value.list_to_tuple"
            fun tuple_to_list _ = raise Unimplemented "MLWorks.Internal.Value.tuple_to_list"
            fun string_to_real _ = raise Unimplemented "MLWorks.Internal.Value.string_to_real"
            fun real_to_string _ = raise Unimplemented "MLWorks.Internal.Value.real_to_string"
            fun print _ = raise Unimplemented "MLWorks.Internal.Value.print"
            fun primary _ = raise Unimplemented "MLWorks.Internal.Value.primary"
            fun header _ = raise Unimplemented "MLWorks.Internal.Value.secondary"
            fun update_header _ = raise Unimplemented "MLWorks.Internal.Value.update_header"
            fun pointer _ = raise Unimplemented "MLWorks.Internal.Value.pointer"
            fun update _ = raise Unimplemented "MLWorks.Internal.Value.update"
            fun sub _ = raise Unimplemented "MLWorks.Internal.Value.sub"
            fun update_byte _ = raise Unimplemented "MLWorks.Internal.Value.update_byte"
            fun sub_byte _ = raise Unimplemented "MLWorks.Internal.Value.sub_byte"
            fun update_header _ = raise Unimplemented "MLWorks.Internal.Value.update_header"
            fun exn_name _ = raise Unimplemented "MLWorks.Internal.Value.exn_name"
            fun code_name _ = raise Unimplemented "MLWorks.Internal.Value.code_name"
            fun exn_argument _ = raise Unimplemented "MLWorks.Internal.Value.exn_argument"
            fun exn_name_string _ = raise Unimplemented "MLWorks.Internal.Value.exn_name_string"
d993 3
a995 3
            fun frame_call _ = raise Unimplemented "MLWorks.Internal.Value.frame_call"
            fun frame_next _ = raise Unimplemented "MLWorks.Internal.Value.frame_next"
            fun frame_sub _ = raise Unimplemented "MLWorks.Internal.Value.frame_sub"
d1046 1
a1046 1
            fun environment _ = raise Unimplemented "MLWorks.Internal.Runtime.environment"
d1053 2
a1054 2
                fun load_module _ = raise Unimplemented "MLWorks.Internal.Runtime.Loader.load_module"
                fun load_wordset _ = raise Unimplemented "MLWorks.Internal.Runtime.Loader.load_wordset"
d1059 1
d1061 1
a1061 1
                val interface = ref (NewJersey.System.Unsafe.cast () : Value.T)
d1068 1
a1068 1
                fun signal _ = raise Unimplemented "MLWorks.Internal.Runtime.Event.signal"
d1093 1
d1098 1
a1098 1
                      Profile | Signal | Load | Unbound |
d1120 1
@


1.20
log
@Added Internal.string_to_real
@
text
@d9 3
d81 2
a84 1
    exception Unimplemented of string
d86 2
d779 4
d795 2
a796 4
        fun name _    = raise Unimplemented "MLWorks.OS.name"
        fun release _ = raise Unimplemented "MLWorks.OS.release"
        fun version _ = raise Unimplemented "MLWorks.OS.version"
        fun machine _ = raise Unimplemented "MLWorks.OS.machine"
d807 2
d812 57
d873 1
a962 1
            type address = unit
a968 2
            fun output _ = raise Unimplemented "MLWorks.Internal.Value.output"
            fun input _ = raise Unimplemented "MLWorks.Internal.Value.input"
d971 2
a972 2
            fun secondary _ = raise Unimplemented "MLWorks.Internal.Value.secondary"
            fun address _ = raise Unimplemented "MLWorks.Internal.Value.address"
a973 1
            fun length _ = raise Unimplemented "MLWorks.Internal.Value.length"
d975 1
d977 1
d980 1
a982 2
            fun is_pointer _ = raise Unimplemented "MLWorks.Internal.Value.is_pointer"
          end
d984 1
a984 5
        structure Timer =
          struct
            exception TimerOverflow
            type timer = NewJersey.System.Timer.timer
            val start_timer = NewJersey.System.Timer.start_timer
d986 3
a988 16
            val const = 65536;
            fun to_time(x:int,y,z) =
              NewJersey.System.Timer.TIME{sec= Bits.orb(Bits.lshift(x,16),y) ,usec=z}
            fun from_time(NewJersey.System.Timer.TIME{sec,usec}) =
              (sec div const,sec mod const,usec)
            datatype time = TIME of int * int * int
            fun check_timer x =
              TIME(from_time(NewJersey.System.Timer.check_timer x))
            fun check_timer_gc x =
              TIME(from_time(NewJersey.System.Timer.check_timer_gc x))
            fun check_timer_sys x =
              TIME(from_time(NewJersey.System.Timer.check_timer_sys x))
            fun makestring (TIME x) =
              NewJersey.System.Timer.makestring(to_time x)
            fun earlier(TIME(hi,lo,usec),TIME(hi',lo',usec')) =
              (hi < hi') orelse (hi=hi' andalso (lo < lo' orelse (lo=lo' andalso usec < usec')))
a992 10
            exception FileDoesNotExist
            datatype fname = PATH of string

            val p = NewJersey.System.Unsafe.SysIO.PATH

            type time = Timer.time
            fun atime (PATH s) = Timer.TIME(Timer.from_time(NewJersey.System.Unsafe.SysIO.atime (p s)))
            fun ctime (PATH s) = Timer.TIME(Timer.from_time(NewJersey.System.Unsafe.SysIO.ctime (p s)))
            fun mtime (PATH s) = Timer.TIME(Timer.from_time(NewJersey.System.Unsafe.SysIO.mtime (p s)))

a1035 40
        structure Debugger =
          struct
            type StackFrame = unit

            datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of Value.T
            datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of Value.T * int * int

            fun install_debugger _ = ()
            fun call_debugger _ = raise Unimplemented "MLWorks.Internal.Debugger.call_debugger"

            fun get_data_from_frame _ = raise Unimplemented "MLWorks.Internal.Debugger.get_data_from_frame"
            fun get_next_frame _ = raise Unimplemented "MLWorks.Internal.Debugger.get_next_frame"
            fun start_single_stepping _ = raise Unimplemented "MLWorks.Internal.Debugger.start_single_stepping"
            fun stop_single_stepping _ = raise Unimplemented "MLWorks.Internal.Debugger.stop_single_stepping"

            datatype Register = 
              I0 | I1 | I2 | I3 | I4 | I5 | I6 | I7 |
              L0 | L1 | L2 | L3 | L4 | L5 | L6 | L7
            datatype Tag =
              ERROR |
              INTEGER |
              PAIRPTR |
              POINTER |
              REFPTR

            fun get_value_from_frame _ = raise Unimplemented "MLWorks.Internal.Debugger.get_funue_from_frame"

            fun get_primary_tag _ = raise Unimplemented "MLWorks.Internal.Debugger.get_primary_tag"
            fun get_header _ = raise Unimplemented "MLWorks.Internal.Debugger.get_header"

            fun get_object_at_address _ = raise Unimplemented "MLWorks.Internal.Debugger.get_object_at_address"
            fun exit _ = raise Unimplemented "MLWorks.Internal.Debugger.exit"

            fun call_function _ = raise Unimplemented "MLWorks.Internal.Debugger.call_function"
            fun tag_as_interesting _ = raise Unimplemented "MLWorks.Internal.Debugger.tag_as_interesting"
            fun untag_as_interesting _ = raise Unimplemented "MLWorks.Internal.Debugger.untag_as_interesting"
            fun get_code_object_debug_info _ = 
              raise Unimplemented "MLWorks.Internal.Debugger.get_code_object_debug_info"
          end

d1056 7
a1075 1
		    val TimerOverflow : T
d1080 1
d1089 1
a1089 1
                      Profile | TimerOverflow | Load | Unbound |
a1100 1
		val TimerOverflow = ref E
d1110 1
@


1.19
log
@Added clear_eof function to IO (unimplemented).
@
text
@d9 3
d805 20
d826 65
d1077 1
d1085 1
a1085 1
                      Abs | Ln | Sqrt | Exp | Value
d1101 1
@


1.18
log
@Changed the OS information stuff to functions.  Added Prod and
Value exceptions.
Implemented save.
@
text
@d9 5
d769 1
@


1.17
log
@Added a function to the pervasive_library to get debug_info from a function
@
text
@d9 3
d770 3
a772 1
    fun save _ = raise Unimplemented "MLWorks.save"
d776 4
a779 4
        val name = ""
        val release = ""
        val version = ""
        val machine = ""
d782 4
d795 2
d984 1
d990 1
a990 1
                      Abs | Ln | Sqrt | Exp
d1008 2
@


1.16
log
@Changed call to environment so that environment is not
preserved across images.
Added floating-point exceptions.
@
text
@d9 5
d929 2
@


1.15
log
@Rationalisation of the MLWorks structure.
@
text
@d9 3
d775 1
a775 1
            val environment = NewJersey.System.environ ()
d962 4
d970 2
a971 1
                      Profile | TimerOverflow | Load | Unbound
d985 4
@


1.14
log
@Added ByteArray structure and writebf in FileIO.
@
text
@d9 3
a62 99
    structure System =
      struct
        type instream = instream
	type outstream = outstream

	val environ = NewJersey.System.environ
	val system = NewJersey.System.system

        exception Profile of string
        fun profile _ = raise Unimplemented "MLWorks.System.profile"

        exception Save of string
        fun save _ = raise Unimplemented "MLWorks.System.save"

        fun val_print _ = raise Unimplemented "MLWorks.System.val_print"
        val exn_name = NewJersey.System.exn_name

        structure Unsafe =
          struct
            structure Value =
              struct
                type T = unit
                type ml_value = T
                type address = unit
                exception Value of string
                val cast = NewJersey.System.Unsafe.cast
                fun list_to_tuple _ = raise Unimplemented "MLWorks.System.Unsafe.Value.list_to_tuple"
                fun tuple_to_list _ = raise Unimplemented "MLWorks.System.Unsafe.Value.tuple_to_list"
                fun string_to_real _ = raise Unimplemented "MLWorks.System.Unsafe.Value.string_to_real"
                fun real_to_string _ = raise Unimplemented "MLWorks.System.Unsafe.Value.real_to_string"
                fun output _ = raise Unimplemented "MLWorks.System.Unsafe.Value.output"
                fun input _ = raise Unimplemented "MLWorks.System.Unsafe.Value.input"
                fun print _ = raise Unimplemented "MLWorks.System.Unsafe.Value.print"
                fun primary _ = raise Unimplemented "MLWorks.System.Unsafe.Value.primary"
                fun secondary _ = raise Unimplemented "MLWorks.System.Unsafe.Value.secondary"
                fun address _ = raise Unimplemented "MLWorks.System.Unsafe.Value.address"
                fun pointer _ = raise Unimplemented "MLWorks.System.Unsafe.Value.pointer"
                fun length _ = raise Unimplemented "MLWorks.System.Unsafe.Value.length"
                fun update _ = raise Unimplemented "MLWorks.System.Unsafe.Value.update"
                fun update_byte _ = raise Unimplemented "MLWorks.System.Unsafe.Value.update_byte"
                fun update_header _ = raise Unimplemented "MLWorks.System.Unsafe.Value.update_header"
                fun exn_name _ = raise Unimplemented "MLWorks.System.Unsafe.Value.exn_name"
                fun exn_argument _ = raise Unimplemented "MLWorks.System.Unsafe.Value.exn_argument"
                fun exn_name_string _ = raise Unimplemented "MLWorks.System.Unsafe.Value.exn_name_string"
                fun is_pointer _ = raise Unimplemented "MLWorks.System.Unsafe.Value.is_pointer"
              end

            structure Int =
	      struct
                fun load_wordset _ = raise Unimplemented "MLWorks.System.Unsafe.Int.load_wordset"
		fun ml_require _ = raise Unimplemented "MLWorks.System.Unsafe.Int.require"
                fun discard_modules _ = raise Unimplemented "MLWorks.System.Unsafe.Int.discard_modules"
		fun call_ml_value _ = raise Unimplemented "MLWorks.System.Unsafe.Int.call"
	      end
	  end

	structure Runtime =
	  struct
	    structure GC =
	      struct
		val message_level = ref 0
                val interface = ref (Unsafe.Value.cast () : Unsafe.Value.T)
	      end

	    structure Exception =
	      struct
		(* Remove the constructor status *)
		structure S :
		  sig
		    type T
		    val Io : T
		    val Prod : T
		    val Mod : T
		    val Div : T
		    val Substring : T
		    val Save : T
		    val Profile : T
		    val TimerOverflow : T
		  end =
		  struct
		    datatype T = Io | Prod | Mod | Div | Substring | Save | Profile | TimerOverflow
		  end
		open S
		  
		exception E
		val Io = ref E
		val Mod = ref E
		val Div = ref E
		val Substring = ref E
		val Save = ref E
		val Profile = ref E
		val TimerOverflow = ref E
	      end
          end
      end

    val use = NewJersey.use
    val exportML = NewJersey.exportML

d384 1
a741 25

    structure Timer =
      struct
	exception TimerOverflow
	type timer = NewJersey.System.Timer.timer
	val start_timer = NewJersey.System.Timer.start_timer
	  
	val const = 65536;
	fun to_time(x:int,y,z) =
	  NewJersey.System.Timer.TIME{sec= Bits.orb(Bits.lshift(x,16),y) ,usec=z}
	fun from_time(NewJersey.System.Timer.TIME{sec,usec}) =
	  (sec div const,sec mod const,usec)
	datatype time = TIME of int * int * int
	fun check_timer x =
	  TIME(from_time(NewJersey.System.Timer.check_timer x))
	fun check_timer_gc x =
	  TIME(from_time(NewJersey.System.Timer.check_timer_gc x))
	fun check_timer_sys x =
	  TIME(from_time(NewJersey.System.Timer.check_timer_sys x))
	fun makestring (TIME x) =
	  NewJersey.System.Timer.makestring(to_time x)
	fun earlier(TIME(hi,lo,usec),TIME(hi',lo',usec')) =
	  (hi < hi') orelse (hi=hi' andalso (lo < lo' orelse (lo=lo' andalso usec < usec')))
      end
    
d755 7
a761 1
    structure FileIO =
d763 11
a773 51
	exception FileDoesNotExist
	datatype fname = PATH of string
	  
	val p = NewJersey.System.Unsafe.SysIO.PATH
	      
	type time = Timer.time
	fun atime (PATH s) = Timer.TIME(Timer.from_time(NewJersey.System.Unsafe.SysIO.atime (p s)))
	fun ctime (PATH s) = Timer.TIME(Timer.from_time(NewJersey.System.Unsafe.SysIO.ctime (p s)))
	fun mtime (PATH s) = Timer.TIME(Timer.from_time(NewJersey.System.Unsafe.SysIO.mtime (p s)))
	  
	type fd = NewJersey.System.Unsafe.SysIO.fd * NewJersey.ByteArray.bytearray * int ref
	datatype offset = BEG | CUR | END

	fun flush (fd, buffer, bp) =
	  (NewJersey.System.Unsafe.SysIO.write(fd, buffer, !bp); bp := 0)

	fun openf s =
	  (NewJersey.System.Unsafe.SysIO.openf(s, NewJersey.System.Unsafe.SysIO.O_WRITE),
	   NewJersey.ByteArray.array (4096, 0), ref 0)

	fun closef (f as (fd, _, _)) =
	  (flush f; NewJersey.System.Unsafe.SysIO.closef fd)

	fun seekf (f as (fd, _, _), i, p) =
	  let
	    val pos = case p of
	      BEG => NewJersey.System.Unsafe.SysIO.L_SET
	    | CUR => NewJersey.System.Unsafe.SysIO.L_INCR
	    | END => NewJersey.System.Unsafe.SysIO.L_XTND
	  in
	    flush f; NewJersey.System.Unsafe.SysIO.lseek (fd, i, pos); ()
	  end

        fun writebf (f as (fd, _, _), bytearray, start, length) =
          (flush f; NewJersey.System.Unsafe.SysIO.writei (fd, bytearray, start, length))

	fun writef ((fd, buffer, bp), s) =
	  let
	    val sz = size s

	    fun copy (x, ptr) =
	      if x > 4095 then
		(NewJersey.System.Unsafe.SysIO.write(fd, buffer, 4096); copy(0, ptr))
	      else
		if ptr < sz then
		  (NewJersey.ByteArray.update(buffer, x, NewJersey.String.ordof(s,ptr)); copy(x+1, ptr+1))
		else
		  (bp := x)
	  in
	    copy(!bp, 0)
	  end
d776 1
a776 1
    structure Debugger =
d778 93
a870 1
	type StackFrame = unit
d872 64
a935 2
	datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of System.Unsafe.Value.T
	datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of System.Unsafe.Value.T * int * int
d937 5
a941 2
	fun install_debugger _ = ()
	fun call_debugger _ = raise Unimplemented "MLWorks.Debugger.call_debugger"
d943 36
a978 26
	fun get_data_from_frame _ = raise Unimplemented "MLWorks.Debugger.get_data_from_frame"
	fun get_next_frame _ = raise Unimplemented "MLWorks.Debugger.get_next_frame"
	fun start_single_stepping _ = raise Unimplemented "MLWorks.Debugger.start_single_stepping"
        fun stop_single_stepping _ = raise Unimplemented "MLWorks.Debugger.stop_single_stepping"

	datatype Register = 
	  I0 | I1 | I2 | I3 | I4 | I5 | I6 | I7 |
	  L0 | L1 | L2 | L3 | L4 | L5 | L6 | L7
	datatype Tag =
	  ERROR |
	  INTEGER |
	  PAIRPTR |
	  POINTER |
	  REFPTR

	fun get_value_from_frame _ = raise Unimplemented "MLWorks.Debugger.get_funue_from_frame"

	fun get_primary_tag _ = raise Unimplemented "MLWorks.Debugger.get_primary_tag"
	fun get_header _ = raise Unimplemented "MLWorks.Debugger.get_header"
	  
	fun get_object_at_address _ = raise Unimplemented "MLWorks.Debugger.get_object_at_address"
	fun exit _ = raise Unimplemented "MLWorks.Debugger.exit"
      
	fun call_function _ = raise Unimplemented "MLWorks.Debugger.call_function"
	fun tag_as_interesting _ = raise Unimplemented "MLWorks.Debugger.tag_as_interesting"
	fun untag_as_interesting _ = raise Unimplemented "MLWorks.Debugger.untag_as_interesting"
@


1.13
log
@Added a faster implementation of FileIO.writef which
doesn't allocate as many bytearrays.
@
text
@d9 4
d171 17
d458 19
d480 345
a824 1
    structure ByteArray = NewJersey.ByteArray
d826 12
d909 3
@


1.12
log
@Changed path of require of mlworks to use pervasive directory.
@
text
@d9 3
d491 1
a491 1
	type fd = NewJersey.System.Unsafe.SysIO.fd
d494 19
a512 2
	fun openf s = NewJersey.System.Unsafe.SysIO.openf(s, NewJersey.System.Unsafe.SysIO.O_WRITE)
	val closef = NewJersey.System.Unsafe.SysIO.closef
d514 1
a514 8
	fun seekf (os, i, BEG) =
	    (NewJersey.System.Unsafe.SysIO.lseek (os, i, NewJersey.System.Unsafe.SysIO.L_SET); ())
	  | seekf (os, i, CUR) =
	    (NewJersey.System.Unsafe.SysIO.lseek (os, i, NewJersey.System.Unsafe.SysIO.L_INCR); ())
	  | seekf (os, i, END) =
	    (NewJersey.System.Unsafe.SysIO.lseek (os, i, NewJersey.System.Unsafe.SysIO.L_XTND); ())
	    
	fun writef (fd, s) =
d516 10
a525 4
	    val b = NewJersey.ByteArray.array (size s, 0)
	    fun itr x =
	      if x < 0 then () else
		(NewJersey.ByteArray.update(b, x, NewJersey.String.ordof(s,x)); itr (x-1))
d527 1
a527 2
	    itr (size s - 1);
	    NewJersey.System.Unsafe.SysIO.write(fd, b, size s)
@


1.11
log
@Enriched the Array structure.
@
text
@d9 3
d47 1
a47 1
require "../rts/mlworks";
@


1.10
log
@Added real_to_string.
@
text
@d9 3
d73 1
d82 13
d101 1
d155 278
a432 1
    structure Array = NewJersey.Array
d550 1
@


1.9
log
@Changes to the MLWorks signature.  See mlworks file for
details.
@
text
@d9 4
d75 1
@


1.8
log
@Added MLWorks.System.Runtime.GC.interface.
@
text
@d9 3
d43 80
d129 1
a129 1
	fun arshift _ = raise Unimplemented "MLworks.Bits.arshift"
d162 9
a170 4
	type instream = instream
	type outstream = outstream
	val flush_out = NewJersey.flush_out
	val input_line = NewJersey.input_line
a212 1
	type ml_value = unit
d214 2
a215 2
	datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of ml_value
	datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value * int * int
d218 1
a218 1
	fun call_debugger _ = raise Unimplemented "MLworks.Debugger.call_debugger"
d220 4
a223 3
	fun get_data_from_frame _ = raise Unimplemented "MLworks.Debugger.get_data_from_frame"
	fun get_next_frame _ = raise Unimplemented "MLworks.Debugger.get_next_frame"
	fun start_single_stepping _ = raise Unimplemented "MLworks.Debugger.start_single_stepping"
d235 1
a235 1
	fun get_value_from_frame _ = raise Unimplemented "MLworks.Debugger.get_funue_from_frame"
d237 2
a238 2
	fun get_primary_tag _ = raise Unimplemented "MLworks.Debugger.get_primary_tag"
	fun get_header _ = raise Unimplemented "MLworks.Debugger.get_header"
d240 2
a241 2
	fun get_object_at_address _ = raise Unimplemented "MLworks.Debugger.get_object_at_address"
	fun exit _ = raise Unimplemented "MLworks.Debugger.exit"
d243 3
a245 7
	fun coerce_object_to_string _ = raise Unimplemented "MLworks.Debugger.coerce_object_to_string"
	fun coerce_object_to_int _ = raise Unimplemented "MLworks.Debugger.coerce_object_to_int"
	fun coerce_object_to_real _ = raise Unimplemented "MLworks.Debugger.coerce_object_to_real"

	fun call_function _ = raise Unimplemented "MLworks.Debugger.call_function"
	fun tag_as_interesting _ = raise Unimplemented "MLworks.Debugger.tag_as_interesting"
	fun untag_as_interesting _ = raise Unimplemented "MLworks.Debugger.untag_as_interesting"
a247 68
    structure System =
      struct
	val environ = NewJersey.System.environ
	val system = NewJersey.System.system

	type outstream = outstream
        exception Profile of string
        fun profile _ = raise Unimplemented "MLworks.System.profile"

        exception Save of string
        fun save _ = raise Unimplemented "MLworks.System.save"

        fun val_print _ = raise Unimplemented "MLworks.System.val_print"
        val exn_name = NewJersey.System.exn_name

        structure Unsafe =
          struct
            structure Int =
	      struct
		type ml_value = unit
		fun call_ml_value _ = raise Unimplemented "MLworks.System.Unsafe.Int.call_ml_value"
		fun make_ml_value _ = raise Unimplemented "MLworks.System.Unsafe.Int.make_ml_value"
		fun make_ml_value_tuple _ = raise Unimplemented "MLworks.System.Unsafe.Int.make_ml_value_tuple"
		fun ml_value_from_offset _ = raise Unimplemented "MLworks.System.Unsafe.Int.ml_value_from_offset"
		fun ml_require _ = raise Unimplemented "MLworks.System.Unsafe.Int.ml_require"
                fun load_wordset _ = raise Unimplemented "MLWorks.System.Unsafe.Int.load_wordset"
	      end
	  end

	structure Runtime =
	  struct
	    structure GC =
	      struct
		val message_level = ref 0
                val interface = ref 0
	      end

	    structure Exception =
	      struct
		(* Remove the constructor status *)
		structure S :
		  sig
		    type T
		    val Io : T
		    val Prod : T
		    val Mod : T
		    val Div : T
		    val Substring : T
		    val Save : T
		    val Profile : T
		    val TimerOverflow : T
		  end =
		  struct
		    datatype T = Io | Prod | Mod | Div | Substring | Save | Profile | TimerOverflow
		  end
		open S
		  
		exception E
		val Io = ref E
		val Mod = ref E
		val Div = ref E
		val Substring = ref E
		val Save = ref E
		val Profile = ref E
		val TimerOverflow = ref E
	      end
          end
      end
@


1.7
log
@Put in MLWorks.IO.input_line function.
@
text
@d9 3
d198 1
@


1.6
log
@Added two functions to the debugger
@
text
@d9 3
d76 1
d79 1
@


1.5
log
@Added two functions to the debugger
@
text
@d122 1
a122 1
	fun install_debugger _ = raise Unimplemented "MLworks.Debugger.install_debugger"
@


1.4
log
@Took out copying of Array and String structures from the
MLWorks structure in an attempt to see if NewJersey was
getting confused and not inlining code for array updates.
@
text
@d9 5
d140 1
d142 1
d149 1
@


1.3
log
@Added load_wordset to Int structure.
@
text
@d9 3
d115 1
a115 1
	datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value * int
a215 3

structure Array = MLWorks.Array;
structure String = MLWorks.String;
@


1.2
log
@Changed MLworks structure to MLWorks
@
text
@d9 3
d170 1
@


1.1
log
@Initial revision
@
text
@d8 4
a11 1
$Log: redefine_timer_functions.sml,v $
d19 1
a19 1
structure MLworks : MLWORKS =
d62 1
d108 2
a109 2
	datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP
	datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value
d138 2
d147 1
d210 2
a211 2
structure Array = MLworks.Array;
structure String = MLworks.String;
@
