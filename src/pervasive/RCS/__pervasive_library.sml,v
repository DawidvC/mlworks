head	1.228;
access;
symbols
	MLW_daveb_inline_1_4_99:1.227.1
	MLWorks_21c0_1999_03_25:1.227
	MLWorks_20c1_1998_08_20:1.226
	MLWorks_20c0_1998_08_04:1.226
	MLWorks_20b2c2_1998_06_19:1.225
	MLWorks_20b2_Windows_1998_06_12:1.225
	MLWorks_20b1c1_1998_05_07:1.224
	MLWorks_20b0_1998_04_07:1.224
	MLWorks_20b0_1998_03_20:1.222
	MLWorks_20m2_1998_02_16:1.219
	MLWorks_20m1_1997_10_23:1.217
	MLWorks_11r1:1.207.1.1.1.2.1
	MLWorks_workspace_97:1.214.2
	MLWorks_dt_wizard:1.214.1
	MLWorks_11c0_1997_09_09:1.207.1.1.1.2
	MLWorks_10r3:1.207.1.1.3
	MLWorks_10r2_551:1.207.1.1.2
	MLWorks_11:1.207.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.207.1.1
	MLWorks_20m0_1997_06_20:1.212
	MLWorks_1_0_r2c2_1997_06_14:1.207.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.207.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.207.1
	MLWorks_BugFix_1997_04_24:1.207
	MLWorks_1_0_r2_Win32_1997_04_11:1.207
	MLWorks_1_0_r2_Unix_1997_04_04:1.207
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.197.2.1.1
	MLWorks_gui_1996_12_18:1.197.3
	MLWorks_1_0_Win32_1996_12_17:1.197.2
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.196.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.196.1.1
	MLWorks_1_0_Irix_1996_11_28:1.196.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.197.1
	MLWorks_1_0_Unix_1996_11_14:1.196.1
	MLWorks_Open_Beta2_1996_10_11:1.192.2
	MLWorks_License_dev:1.192.1
	MLWorks_1_open_beta_1996_09_13:1.190.1
	MLWorks_Open_Beta_1996_08_22:1.188
	MLWorks_Beta_1996_07_02:1.184
	MLWorks_Beta_1996_06_07:1.183
	MLWorks_Beta_1996_06_06:1.183
	MLWorks_Beta_1996_06_05:1.183
	MLWorks_Beta_1996_06_03:1.182
	MLWorks_Beta_1996_05_31:1.182
	MLWorks_Beta_1996_05_30:1.181
	ML_beta_release_12/08/94:1.121
	ML_beta_release_03/08/94:1.121
	ML_revised_beta_release_25/05/94:1.116
	ML_final_beta_release_02/03/94:1.112
	mlworks-28-01-1994:1.108
	Release:1.104
	mlworks-beta-01-09-1993:1.104
	MLWorks-1-0-4-29/01/1993:1.79
	MLWorks-1-0-3-21/12/1992:1.78
	MLWorks-1-0-2-15/12/1992:1.74
	MLWorks-1-0-1-04/12/1992:1.74
	checkpoint_17_08_92:1.54;
locks; strict;
comment	@ * @;


1.228
date	99.05.12.17.30.39;	author daveb;	state Exp;
branches;
next	1.227;

1.227
date	99.03.11.17.13.38;	author daveb;	state Exp;
branches
	1.227.1.1;
next	1.226;

1.226
date	98.07.07.10.17.13;	author jont;	state Exp;
branches;
next	1.225;

1.225
date	98.05.26.13.56.24;	author mitchell;	state Exp;
branches;
next	1.224;

1.224
date	98.03.26.17.12.16;	author jont;	state Exp;
branches;
next	1.223;

1.223
date	98.03.26.14.12.31;	author jont;	state Exp;
branches;
next	1.222;

1.222
date	98.03.11.14.24.47;	author mitchell;	state Exp;
branches;
next	1.221;

1.221
date	98.02.18.13.21.23;	author mitchell;	state Exp;
branches;
next	1.220;

1.220
date	98.02.10.15.31.47;	author jont;	state Exp;
branches;
next	1.219;

1.219
date	97.11.26.15.45.02;	author johnh;	state Exp;
branches;
next	1.218;

1.218
date	97.11.09.19.12.49;	author jont;	state Exp;
branches;
next	1.217;

1.217
date	97.10.08.17.51.20;	author jont;	state Exp;
branches;
next	1.216;

1.216
date	97.10.07.14.52.54;	author johnh;	state Exp;
branches;
next	1.215;

1.215
date	97.09.17.15.19.51;	author brucem;	state Exp;
branches;
next	1.214;

1.214
date	97.08.04.11.01.01;	author brucem;	state Exp;
branches
	1.214.1.1
	1.214.2.1;
next	1.213;

1.213
date	97.06.17.13.51.31;	author andreww;	state Exp;
branches;
next	1.212;

1.212
date	97.06.12.11.59.32;	author matthew;	state Exp;
branches;
next	1.211;

1.211
date	97.06.12.10.12.49;	author matthew;	state Exp;
branches;
next	1.210;

1.210
date	97.05.28.21.09.15;	author jont;	state Exp;
branches;
next	1.209;

1.209
date	97.05.09.13.39.52;	author jont;	state Exp;
branches;
next	1.208;

1.208
date	97.05.01.11.49.09;	author jont;	state Exp;
branches;
next	1.207;

1.207
date	97.03.25.11.58.36;	author andreww;	state Exp;
branches
	1.207.1.1;
next	1.206;

1.206
date	97.03.21.15.46.05;	author andreww;	state Exp;
branches;
next	1.205;

1.205
date	97.03.18.11.19.28;	author andreww;	state Exp;
branches;
next	1.204;

1.204
date	97.03.12.12.16.42;	author andreww;	state Exp;
branches;
next	1.203;

1.203
date	97.03.03.11.13.15;	author matthew;	state Exp;
branches;
next	1.202;

1.202
date	97.02.07.11.59.53;	author andreww;	state Exp;
branches;
next	1.201;

1.201
date	97.01.27.11.07.12;	author andreww;	state Exp;
branches;
next	1.200;

1.200
date	97.01.21.15.27.58;	author andreww;	state Exp;
branches;
next	1.199;

1.199
date	97.01.07.12.46.48;	author andreww;	state Exp;
branches;
next	1.198;

1.198
date	96.12.18.12.19.23;	author matthew;	state Exp;
branches;
next	1.197;

1.197
date	96.11.18.14.10.04;	author jont;	state Exp;
branches
	1.197.1.1
	1.197.2.1
	1.197.3.1;
next	1.196;

1.196
date	96.11.01.17.07.36;	author io;	state Exp;
branches
	1.196.1.1;
next	1.195;

1.195
date	96.10.21.16.48.56;	author andreww;	state Exp;
branches;
next	1.194;

1.194
date	96.10.21.11.28.20;	author andreww;	state Exp;
branches;
next	1.193;

1.193
date	96.10.21.10.31.41;	author andreww;	state Exp;
branches;
next	1.192;

1.192
date	96.10.03.15.46.53;	author io;	state Exp;
branches
	1.192.1.1
	1.192.2.1;
next	1.191;

1.191
date	96.09.18.15.12.05;	author io;	state Exp;
branches;
next	1.190;

1.190
date	96.09.02.15.38.12;	author jont;	state Exp;
branches
	1.190.1.1;
next	1.189;

1.189
date	96.08.21.12.33.08;	author stephenb;	state Exp;
branches;
next	1.188;

1.188
date	96.08.09.14.19.33;	author daveb;	state Exp;
branches;
next	1.187;

1.187
date	96.07.16.15.41.54;	author andreww;	state Exp;
branches;
next	1.186;

1.186
date	96.07.10.09.34.40;	author andreww;	state Exp;
branches;
next	1.185;

1.185
date	96.07.03.09.46.06;	author andreww;	state Exp;
branches;
next	1.184;

1.184
date	96.06.19.13.42.27;	author nickb;	state Exp;
branches;
next	1.183;

1.183
date	96.06.04.14.21.35;	author io;	state Exp;
branches;
next	1.182;

1.182
date	96.05.30.11.50.26;	author daveb;	state Exp;
branches;
next	1.181;

1.181
date	96.05.29.12.33.56;	author matthew;	state Exp;
branches;
next	1.180;

1.180
date	96.05.28.12.21.57;	author matthew;	state Exp;
branches;
next	1.179;

1.179
date	96.05.28.10.21.26;	author daveb;	state Exp;
branches;
next	1.178;

1.178
date	96.05.22.13.20.11;	author matthew;	state Exp;
branches;
next	1.177;

1.177
date	96.05.21.12.02.30;	author matthew;	state Exp;
branches;
next	1.176;

1.176
date	96.05.17.10.05.09;	author matthew;	state Exp;
branches;
next	1.175;

1.175
date	96.05.16.13.18.10;	author stephenb;	state Exp;
branches;
next	1.174;

1.174
date	96.05.07.10.25.11;	author jont;	state Exp;
branches;
next	1.173;

1.173
date	96.05.03.12.37.49;	author nickb;	state Exp;
branches;
next	1.172;

1.172
date	96.04.30.17.40.34;	author jont;	state Exp;
branches;
next	1.171;

1.171
date	96.04.29.13.53.30;	author matthew;	state Exp;
branches;
next	1.170;

1.170
date	96.04.29.11.06.52;	author jont;	state Exp;
branches;
next	1.169;

1.169
date	96.04.19.16.11.59;	author stephenb;	state Exp;
branches;
next	1.168;

1.168
date	96.04.19.10.48.44;	author matthew;	state Exp;
branches;
next	1.167;

1.167
date	96.04.17.11.02.21;	author stephenb;	state Exp;
branches;
next	1.166;

1.166
date	96.03.20.11.57.15;	author matthew;	state Exp;
branches;
next	1.165;

1.165
date	96.03.08.11.43.08;	author daveb;	state Exp;
branches;
next	1.164;

1.164
date	96.02.22.13.27.22;	author daveb;	state Exp;
branches;
next	1.163;

1.163
date	96.02.16.15.00.34;	author nickb;	state Exp;
branches;
next	1.162;

1.162
date	96.02.09.15.46.02;	author jont;	state Exp;
branches;
next	1.161;

1.161
date	96.01.22.13.53.28;	author matthew;	state Exp;
branches;
next	1.160;

1.160
date	96.01.17.16.06.24;	author stephenb;	state Exp;
branches;
next	1.159;

1.159
date	96.01.16.12.14.05;	author nickb;	state Exp;
branches;
next	1.158;

1.158
date	96.01.15.16.18.01;	author matthew;	state Exp;
branches;
next	1.157;

1.157
date	96.01.15.11.48.33;	author nickb;	state Exp;
branches;
next	1.156;

1.156
date	96.01.12.10.34.02;	author stephenb;	state Exp;
branches;
next	1.155;

1.155
date	96.01.08.14.11.11;	author nickb;	state Exp;
branches;
next	1.154;

1.154
date	95.12.04.15.56.42;	author daveb;	state Exp;
branches;
next	1.153;

1.153
date	95.11.21.11.23.03;	author jont;	state Exp;
branches;
next	1.152;

1.152
date	95.10.17.12.52.49;	author jont;	state Exp;
branches;
next	1.151;

1.151
date	95.09.20.11.53.41;	author matthew;	state Exp;
branches;
next	1.150;

1.150
date	95.09.13.14.24.25;	author jont;	state Exp;
branches;
next	1.149;

1.149
date	95.09.12.15.08.50;	author daveb;	state Exp;
branches;
next	1.148;

1.148
date	95.08.10.15.35.24;	author jont;	state Exp;
branches;
next	1.147;

1.147
date	95.07.28.14.03.11;	author jont;	state Exp;
branches;
next	1.146;

1.146
date	95.07.27.12.14.29;	author jont;	state Exp;
branches;
next	1.145;

1.145
date	95.07.24.14.24.58;	author jont;	state Exp;
branches;
next	1.144;

1.144
date	95.07.20.16.59.25;	author jont;	state Exp;
branches;
next	1.143;

1.143
date	95.07.19.15.21.55;	author nickb;	state Exp;
branches;
next	1.142;

1.142
date	95.07.19.13.52.44;	author nickb;	state Exp;
branches;
next	1.141;

1.141
date	95.07.17.16.27.27;	author nickb;	state Exp;
branches;
next	1.140;

1.140
date	95.07.17.12.19.18;	author jont;	state Exp;
branches;
next	1.139;

1.139
date	95.07.14.10.22.45;	author jont;	state Exp;
branches;
next	1.138;

1.138
date	95.06.02.13.58.48;	author nickb;	state Exp;
branches;
next	1.137;

1.137
date	95.05.26.15.59.40;	author matthew;	state Exp;
branches;
next	1.136;

1.136
date	95.05.23.17.24.18;	author daveb;	state Exp;
branches;
next	1.135;

1.135
date	95.05.22.15.53.18;	author nickb;	state Exp;
branches;
next	1.134;

1.134
date	95.05.19.09.18.49;	author matthew;	state Exp;
branches;
next	1.133;

1.133
date	95.05.10.17.53.30;	author daveb;	state Exp;
branches;
next	1.132;

1.132
date	95.05.02.13.12.17;	author matthew;	state Exp;
branches;
next	1.131;

1.131
date	95.04.19.13.55.36;	author matthew;	state Exp;
branches;
next	1.130;

1.130
date	95.04.13.16.51.43;	author jont;	state Exp;
branches;
next	1.129;

1.129
date	95.04.13.14.07.20;	author jont;	state Exp;
branches;
next	1.128;

1.128
date	95.03.20.10.44.43;	author matthew;	state Exp;
branches;
next	1.127;

1.127
date	95.03.01.11.44.25;	author matthew;	state Exp;
branches;
next	1.126;

1.126
date	95.01.12.15.23.47;	author jont;	state Exp;
branches;
next	1.125;

1.125
date	94.12.09.14.37.33;	author jont;	state Exp;
branches;
next	1.124;

1.124
date	94.11.24.14.32.38;	author matthew;	state Exp;
branches;
next	1.123;

1.123
date	94.09.27.16.04.14;	author matthew;	state Exp;
branches;
next	1.122;

1.122
date	94.08.24.16.33.21;	author matthew;	state Exp;
branches;
next	1.121;

1.121
date	94.07.08.10.12.32;	author nickh;	state Exp;
branches;
next	1.120;

1.120
date	94.06.29.15.16.51;	author nickh;	state Exp;
branches;
next	1.119;

1.119
date	94.06.22.15.28.03;	author nickh;	state Exp;
branches;
next	1.118;

1.118
date	94.06.09.15.37.15;	author nickh;	state Exp;
branches;
next	1.117;

1.117
date	94.06.06.11.44.30;	author nosa;	state Exp;
branches;
next	1.116;

1.116
date	94.03.30.15.03.48;	author daveb;	state Exp;
branches;
next	1.115;

1.115
date	94.03.30.13.55.31;	author daveb;	state Exp;
branches;
next	1.114;

1.114
date	94.03.30.13.23.12;	author daveb;	state Exp;
branches;
next	1.113;

1.113
date	94.03.23.12.39.10;	author nickh;	state Exp;
branches;
next	1.112;

1.112
date	94.02.23.17.04.29;	author nosa;	state Exp;
branches;
next	1.111;

1.111
date	94.02.17.17.54.04;	author matthew;	state Exp;
branches;
next	1.110;

1.110
date	94.02.08.14.38.55;	author matthew;	state Exp;
branches;
next	1.109;

1.109
date	94.02.08.10.45.18;	author nickh;	state Exp;
branches;
next	1.108;

1.108
date	94.01.10.14.16.50;	author matthew;	state Exp;
branches;
next	1.107;

1.107
date	93.12.20.13.12.14;	author matthew;	state Exp;
branches;
next	1.106;

1.106
date	93.11.18.11.20.22;	author nickh;	state Exp;
branches;
next	1.105;

1.105
date	93.11.17.12.30.11;	author nickh;	state Exp;
branches;
next	1.104;

1.104
date	93.08.27.19.13.59;	author daveb;	state Exp;
branches
	1.104.1.1;
next	1.103;

1.103
date	93.08.26.11.13.00;	author richard;	state Exp;
branches;
next	1.102;

1.102
date	93.08.25.14.01.50;	author richard;	state Exp;
branches;
next	1.101;

1.101
date	93.08.18.12.52.40;	author daveb;	state Exp;
branches;
next	1.100;

1.100
date	93.07.23.11.07.49;	author richard;	state Exp;
branches;
next	1.99;

1.99
date	93.07.19.13.55.02;	author nosa;	state Exp;
branches;
next	1.98;

1.98
date	93.06.09.16.10.12;	author matthew;	state Exp;
branches;
next	1.97;

1.97
date	93.05.05.17.25.23;	author jont;	state Exp;
branches;
next	1.96;

1.96
date	93.04.29.11.33.44;	author richard;	state Exp;
branches;
next	1.95;

1.95
date	93.04.23.15.49.58;	author jont;	state Exp;
branches;
next	1.94;

1.94
date	93.04.21.15.58.24;	author richard;	state Exp;
branches;
next	1.93;

1.93
date	93.04.20.13.52.21;	author richard;	state Exp;
branches;
next	1.92;

1.92
date	93.04.13.09.53.27;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	93.04.08.17.39.38;	author jont;	state Exp;
branches;
next	1.90;

1.90
date	93.04.02.14.51.00;	author jont;	state Exp;
branches;
next	1.89;

1.89
date	93.03.26.15.51.39;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	93.03.23.18.38.53;	author jont;	state Exp;
branches;
next	1.87;

1.87
date	93.03.18.13.44.54;	author jont;	state Exp;
branches;
next	1.86;

1.86
date	93.03.11.18.38.01;	author jont;	state Exp;
branches;
next	1.85;

1.85
date	93.03.11.17.29.12;	author jont;	state Exp;
branches;
next	1.84;

1.84
date	93.03.05.12.41.53;	author jont;	state Exp;
branches;
next	1.83;

1.83
date	93.03.01.12.25.53;	author matthew;	state Exp;
branches;
next	1.82;

1.82
date	93.02.26.11.13.42;	author nosa;	state Exp;
branches;
next	1.81;

1.81
date	93.02.25.16.08.56;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	93.02.19.18.26.58;	author matthew;	state Exp;
branches;
next	1.79;

1.79
date	93.01.05.17.06.40;	author richard;	state Exp;
branches;
next	1.78;

1.78
date	92.12.22.12.45.32;	author jont;	state Exp;
branches;
next	1.77;

1.77
date	92.12.22.12.15.36;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	92.12.21.12.19.14;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	92.12.18.14.04.17;	author clive;	state Exp;
branches;
next	1.74;

1.74
date	92.12.03.18.19.09;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	92.12.01.12.13.45;	author matthew;	state Exp;
branches;
next	1.72;

1.72
date	92.11.30.18.51.54;	author matthew;	state Exp;
branches;
next	1.71;

1.71
date	92.11.30.18.27.43;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	92.11.12.17.21.19;	author clive;	state Exp;
branches;
next	1.69;

1.69
date	92.11.10.13.22.27;	author richard;	state Exp;
branches;
next	1.68;

1.68
date	92.10.29.13.18.10;	author richard;	state Exp;
branches;
next	1.67;

1.67
date	92.10.15.07.27.56;	author richard;	state Exp;
branches;
next	1.66;

1.66
date	92.10.06.17.20.49;	author clive;	state Exp;
branches;
next	1.65;

1.65
date	92.09.25.16.48.59;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	92.09.23.16.13.15;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	92.09.04.12.36.58;	author richard;	state Exp;
branches;
next	1.62;

1.62
date	92.08.28.15.18.47;	author clive;	state Exp;
branches;
next	1.61;

1.61
date	92.08.27.15.42.56;	author richard;	state Exp;
branches;
next	1.60;

1.60
date	92.08.27.10.59.18;	author richard;	state Exp;
branches;
next	1.59;

1.59
date	92.08.26.15.44.58;	author richard;	state Exp;
branches;
next	1.58;

1.58
date	92.08.25.08.10.03;	author richard;	state Exp;
branches;
next	1.57;

1.57
date	92.08.20.12.24.42;	author richard;	state Exp;
branches;
next	1.56;

1.56
date	92.08.18.15.44.45;	author richard;	state Exp;
branches;
next	1.55;

1.55
date	92.08.17.13.29.35;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	92.08.17.10.58.46;	author richard;	state Exp;
branches;
next	1.53;

1.53
date	92.08.15.17.31.47;	author davidt;	state Exp;
branches;
next	1.52;

1.52
date	92.08.14.11.16.51;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	92.08.14.11.05.42;	author davidt;	state Exp;
branches;
next	1.50;

1.50
date	92.08.13.11.40.57;	author clive;	state Exp;
branches;
next	1.49;

1.49
date	92.08.11.15.34.29;	author clive;	state Exp;
branches;
next	1.48;

1.48
date	92.08.10.15.28.44;	author davidt;	state Exp;
branches;
next	1.47;

1.47
date	92.08.10.15.27.12;	author richard;	state Exp;
branches;
next	1.46;

1.46
date	92.08.10.12.20.12;	author davidt;	state Exp;
branches;
next	1.45;

1.45
date	92.08.07.16.24.05;	author clive;	state Exp;
branches;
next	1.44;

1.44
date	92.08.05.09.05.39;	author richard;	state Exp;
branches;
next	1.43;

1.43
date	92.07.31.16.03.11;	author clive;	state Exp;
branches;
next	1.42;

1.42
date	92.07.29.14.19.39;	author clive;	state Exp;
branches;
next	1.41;

1.41
date	92.07.28.13.12.03;	author richard;	state Exp;
branches;
next	1.40;

1.40
date	92.07.22.16.43.34;	author clive;	state Exp;
branches;
next	1.39;

1.39
date	92.07.16.15.40.26;	author clive;	state Exp;
branches;
next	1.38;

1.38
date	92.07.14.09.27.53;	author clive;	state Exp;
branches;
next	1.37;

1.37
date	92.07.09.14.48.00;	author clive;	state Exp;
branches;
next	1.36;

1.36
date	92.07.07.16.20.06;	author clive;	state Exp;
branches;
next	1.35;

1.35
date	92.06.25.14.48.03;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	92.06.24.09.35.34;	author clive;	state Exp;
branches;
next	1.33;

1.33
date	92.06.22.16.25.49;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.06.19.16.43.45;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	92.06.18.16.22.57;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.06.15.17.05.12;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	92.06.11.10.48.06;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.05.20.10.24.17;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.05.18.11.54.37;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.05.13.12.51.00;	author clive;	state Exp;
branches;
next	1.25;

1.25
date	92.05.11.09.47.07;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.04.28.10.12.55;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.04.24.15.45.26;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.03.12.16.00.56;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	92.03.10.12.55.28;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.02.25.14.53.38;	author clive;	state Exp;
branches;
next	1.19;

1.19
date	92.02.24.18.15.06;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.02.24.16.56.46;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.02.24.13.42.13;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.02.18.17.58.25;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.02.12.09.29.47;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.02.03.20.12.33;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.02.03.17.34.52;	author clive;	state Exp;
branches;
next	1.12;

1.12
date	92.01.23.10.12.43;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	92.01.21.15.59.18;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.01.21.10.56.50;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.01.17.11.34.40;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.01.16.17.43.28;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.01.13.11.29.13;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.12.20.09.53.51;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.12.16.13.12.54;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	91.12.10.13.57.08;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.12.09.15.46.20;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.12.04.16.00.40;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.11.28.17.06.21;	author richard;	state Exp;
branches;
next	;

1.104.1.1
date	93.08.27.19.13.59;	author jont;	state Exp;
branches;
next	;

1.190.1.1
date	96.09.13.11.20.57;	author hope;	state Exp;
branches;
next	;

1.192.1.1
date	96.10.07.16.10.55;	author hope;	state Exp;
branches;
next	;

1.192.2.1
date	96.10.17.11.29.28;	author hope;	state Exp;
branches;
next	;

1.196.1.1
date	96.11.14.12.55.19;	author hope;	state Exp;
branches
	1.196.1.1.1.1;
next	;

1.196.1.1.1.1
date	96.11.28.15.06.01;	author hope;	state Exp;
branches;
next	;

1.197.1.1
date	96.11.22.18.13.44;	author hope;	state Exp;
branches;
next	;

1.197.2.1
date	96.12.17.17.52.13;	author hope;	state Exp;
branches
	1.197.2.1.1.1;
next	;

1.197.2.1.1.1
date	97.02.24.11.43.00;	author hope;	state Exp;
branches;
next	;

1.197.3.1
date	96.12.18.09.46.38;	author hope;	state Exp;
branches;
next	;

1.207.1.1
date	97.05.12.10.39.07;	author hope;	state Exp;
branches
	1.207.1.1.1.1
	1.207.1.1.2.1
	1.207.1.1.3.1;
next	;

1.207.1.1.1.1
date	97.07.28.18.24.00;	author daveb;	state Exp;
branches;
next	1.207.1.1.1.2;

1.207.1.1.1.2
date	97.08.06.18.39.19;	author daveb;	state Exp;
branches
	1.207.1.1.1.2.1.1;
next	;

1.207.1.1.1.2.1.1
date	97.10.07.11.49.48;	author jkbrook;	state Exp;
branches;
next	;

1.207.1.1.2.1
date	97.09.08.17.17.25;	author daveb;	state Exp;
branches;
next	;

1.207.1.1.3.1
date	97.09.09.14.13.34;	author daveb;	state Exp;
branches;
next	;

1.214.1.1
date	97.09.10.19.29.41;	author brucem;	state Exp;
branches;
next	;

1.214.2.1
date	97.09.11.20.59.29;	author daveb;	state Exp;
branches;
next	;

1.227.1.1
date	99.04.01.17.59.48;	author daveb;	state Exp;
branches;
next	;


desc
@The Pervasive Library.  This structure becomes a module which is linked
to other modules to provide definitions for the pervasives.  It is a
simple structure definition.
@


1.228
log
@[Bug #190553]
Moved exit statuses to mlworks_exit.sml.
@
text
@(*  ==== PERVASIVE LIBRARY ====
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is the file that is implicitly loaded before any of the other files
 *  are compiled.
 *
 *  Revision Log
 *  ------------
 *  $Log: __pervasive_library.sml,v $
 * Revision 1.227  1999/03/11  17:13:38  daveb
 * [Bug #190523]
 * Changed the underlying type of OS.Process.status.
 *
 * Revision 1.226  1998/07/07  10:17:13  jont
 * [Bug #20122]
 * Move pervasive signatures into __pervasive_library.sml
 *
 * Revision 1.225  1998/05/26  13:56:24  mitchell
 * [Bug #30413]
 * Move Exit structure to pervasives
 *
 * Revision 1.224  1998/03/26  17:12:16  jont
 * [Bug #30090]
 * Remove MLWorks.IO and RawIO
 *
 * Revision 1.223  1998/03/26  14:12:31  jont
 * [Bug #30090]
 * Remove almost all of MLWorks.IO
 *
 * Revision 1.222  1998/03/11  14:24:47  mitchell
 * [Bug #70076]
 * Fix exnName so it only returns name of exception, not location info
 *
 * Revision 1.221  1998/02/18  13:21:23  mitchell
 * [Bug #30349]
 * Warn when lhs of semicolon does not have type unit
 *
 * Revision 1.220  1998/02/10  15:31:47  jont
 * [Bug #70065]
 * Remove uses of MLWorks.IO.messages and use the Messages structure
 *
 * Revision 1.219  1997/11/26  15:45:02  johnh
 * [Bug #30134]
 * Change meaning of third arg of deliver and convert to datatype.
 *
 * Revision 1.218  1997/11/09  19:12:49  jont
 * [Bug #30089]
 * Further work on getting rid of MLWorks.Time
 * Also removing {set_,}file_modified
 *
 * Revision 1.217  1997/10/08  17:51:20  jont
 * [Bug #30204]
 * Add update_exn and update_exn_cons
 *
 * Revision 1.216  1997/10/07  14:52:54  johnh
 * [Bug #30226]
 * Add exitFn for storing the function to call when the exe exits normally.
 *
 * Revision 1.215  1997/09/17  15:19:51  brucem
 * [Bug #30268]
 * Clear delivery hooks before delivering.
 *
 * Revision 1.214  1997/08/04  11:01:01  brucem
 * [Bug #30084]
 * Remove option related stuff from structure General.
 * Add datatype MLWorks.Internal.Types.option.
 * Set top-level datatype option to be MLWorks.Internal.Types.option.
 * Add basic option functions to top level.
 * This is for adding the Option structure to the Basis.
 *
 * Revision 1.213  1997/06/17  13:51:31  andreww
 * [Bug #20014]
 * adding MLWorks.name to return the name of the invoking program.
 *
 * Revision 1.212  1997/06/12  11:59:32  matthew
 * [Bug #30101]
 *
 * Using builitin cos & sin
 *
 * Revision 1.211  1997/06/12  10:12:49  matthew
 * Adding print_error to StandardIO
 *
 * Revision 1.210  1997/05/28  21:09:15  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.209  1997/05/09  13:39:52  jont
 * [Bug #30091]
 * Remove MLWorks.Internal.FileIO and related stuff
 *
 * Revision 1.208  1997/05/01  11:49:09  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.207  1997/03/25  11:58:36  andreww
 * [Bug #1989]
 * removing Internal.Value.exn_name_string.
 *
 * Revision 1.206  1997/03/21  15:46:05  andreww
 * [Bug #1968]
 * Altering runtime calls to fetch the values of stdin, stdout and stderr.
 *
 * Revision 1.205  1997/03/18  11:19:28  andreww
 * [Bug #1431]
 * Adding Basis Io exception to MLWorks.Internal.IO so that it
 * can be handled by General.exnMessage neatly.
 *
 * Revision 1.203  1997/03/03  11:13:15  matthew
 * Adding unsafe floatarray operations to Internal.Value
 *
 * Revision 1.202  1997/02/07  11:59:53  andreww
 * [Bug #1911]
 * #put(#output(TerminalIO)) ought to write to stdOut, not stdErr.
 *
 * Revision 1.201  1997/01/27  11:07:12  andreww
 * [Bug #1891]
 * Adding new primitives to enter and exit critical sections in pre-empting
 * threads.
 *
 * Revision 1.200  1997/01/21  15:27:58  andreww
 * [Bug #1896]
 * altering MLWorks.Threads.result to cope with new threads state
 * THREADS_KILLED_SLEEPING.
 *
 * Revision 1.199  1997/01/07  12:46:48  andreww
 * [Bug #1818]
 * Adding new FloatArray primitives.
 *
 * Revision 1.198  1996/12/18  12:19:23  matthew
 * Adding real equality builtin to MLWorks.Internal.Value.
 *
 * Revision 1.197  1996/11/18  14:10:04  jont
 * [bug 1775]
 * Handle all exceptions caused by the profile select function
 *
 * Revision 1.196  1996/11/01  17:07:36  io
 * [Bug #1614]
 * Removing toplevel String structure.
 *
 * Revision 1.195  1996/10/21  16:48:56  andreww
 * [Bug #1682]
 * removing General structure from MLWorks structure.
 *
 * Revision 1.194  1996/10/21  11:28:20  andreww
 * [Bug #1655]
 * Correcting definition of MLWorks.Threads.Internal.children
 * ,
 *
 * Revision 1.193  1996/10/21  10:31:41  andreww
 * [Bug #1666]
 * Hooking runtime exception Threads into pervasive library.
 *
 * Revision 1.192  1996/10/03  15:46:53  io
 * [Bug #1630]
 * fix substring
 *
 * Revision 1.191  1996/09/18  15:12:05  io
 * [Bug #1490]
 * update toplevel String.maxSize
 *
 * Revision 1.190  1996/09/02  15:38:12  jont
 * [Bug #1574]
 * Ensure Vector.vector visible at top level to override the builtin library version
 *
 * Revision 1.189  1996/08/21  12:33:08  stephenb
 * [Bug #1554]
 * Introduce MLWorks.Internal.IO as a repository for file_desc
 * and the read, write, seek, ... etc. stuff.
 *
 * Revision 1.188  1996/08/09  14:19:33  daveb
 * [Bug #1534]
 * before is now infix.
 *
 * Revision 1.187  1996/07/16  15:41:54  andreww
 * Expanding the contents of the StandardIO buffers.
 *
 * Revision 1.186  1996/07/10  09:34:40  andreww
 * Expanding the top level environment to meet the revised basis specification.
 *
 * Revision 1.185  1996/07/03  09:46:06  andreww
 * adding GuiStandardIO structure to pervasives.
 *
 * Revision 1.184  1996/06/19  13:42:27  nickb
 * Extend datatype MLWorks.Internal.Trace.status.
 *
 * Revision 1.183  1996/06/04  14:21:35  io
 * add exception Size
 *
 * Revision 1.182  1996/05/30  11:50:26  daveb
 * Revising top level for revised basis.
 *
 * Revision 1.181  1996/05/29  12:33:56  matthew
 * Fixing problem with SysErr
 *
 * Revision 1.180  1996/05/28  12:21:57  matthew
 * Improving MLWorks.ml_string function
 *
 * Revision 1.179  1996/05/28  10:21:26  daveb
 * Removed RawIO.outstream parameter in Internal.Value.print.
 *
 * Revision 1.178  1996/05/22  13:20:11  matthew
 * Changing type of real_to_string
 *
 * Revision 1.177  1996/05/21  12:02:30  matthew
 * Changing type of word32 shift operations
 *
 * Revision 1.176  1996/05/17  10:05:09  matthew
 * Moving Bits to Internal
 *
 * Revision 1.175  1996/05/16  13:18:10  stephenb
 * MLWorks.Debugger: moved to MLWorks.Internal.Debugger
 * MLWorks.OS.arguments: moved MLWorks.arguments & removed MLWorks.OS
 *
 * Revision 1.174  1996/05/07  10:25:11  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.173  1996/05/03  12:37:49  nickb
 * Add image delivery hooks.
 *
 * Revision 1.172  1996/04/30  17:40:34  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.171  1996/04/29  13:53:30  matthew
 * Removing Real structure
 *
 * Revision 1.170  1996/04/29  11:06:52  jont
 * Modifications to deliver and save
 *
 * Revision 1.169  1996/04/19  16:11:59  stephenb
 * Put MLWorks.exit back to enable boostrapping from older compilers.
 *
 * Revision 1.168  1996/04/19  10:48:44  matthew
 * Removing some exceptions
 *
 * Revision 1.167  1996/04/17  11:02:21  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
 * Revision 1.166  1996/03/20  11:57:15  matthew
 * Changes for value polymorphism
 *
 * Revision 1.165  1996/03/08  11:43:08  daveb
 * Changed MLWorks.Internal.Dynamic types to new identifier convention.
 *
 * Revision 1.164  1996/02/22  13:27:22  daveb
 * Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
 * some functionality to the Shell structure.
 *
 * Revision 1.163  1996/02/16  15:00:34  nickb
 * "fn_save" becomes "deliver".
 *
 *  Revision 1.162  1996/02/09  15:46:02  jont
 *  Add Overflow at top level
 *
 *  Revision 1.161  1996/01/22  13:53:28  matthew
 *  Simplifying treatment of pervasive exceptions
 *
 *  Revision 1.160  1996/01/17  16:06:24  stephenb
 *  OS reorganisation: remove the Unix and NT code as it is going elsewhere.
 *
 *  Revision 1.159  1996/01/16  12:14:05  nickb
 *  Change to GC interface.
 *
 *  Revision 1.158  1996/01/15  16:18:01  matthew
 *  Adding NT directory operations
 *
 *  Revision 1.157  1996/01/15  11:48:33  nickb
 *  Add thread sleep and wake operations.
 *
 *  Revision 1.156  1996/01/12  10:34:02  stephenb
 *  Add FullPervasiveLibrary_.MLWorks.Threads.Internal.reset_signal_status.
 *
 *  Revision 1.155  1996/01/08  14:11:11  nickb
 *  Remove signal reservation.
 *
 *  Revision 1.154  1995/12/04  15:56:42  daveb
 *  pervasive module names now begin with a space.
 *
 *  Revision 1.153  1995/11/21  11:23:03  jont
 *  Add Frame.frame_double for accessing directly spilled reals
 *
 *  Revision 1.152  1995/10/17  12:52:49  jont
 *  Add exec_save for saving executables
 *
 *  Revision 1.151  1995/09/20  11:53:41  matthew
 *  Lifting call to call_c in substring
 *
 *  Revision 1.150  1995/09/13  14:24:25  jont
 *  Add function save to MLWorks for use by exportFn
 *
 *  Revision 1.149  1995/09/12  15:08:50  daveb
 *  Added types for different sizes of words and integers.
 *
 *  Revision 1.147  1995/07/28  14:03:11  jont
 *  Remove div and mod from FullPervasiveLibrary signature
 *
 *  Revision 1.146  1995/07/27  12:14:29  jont
 *  Add makestring to word signature and structure
 *
 *  Revision 1.145  1995/07/24  14:24:58  jont
 *  Add Words signature and structure
 *
 *  Revision 1.144  1995/07/20  16:59:25  jont
 *  Add exception Overflow
 *
 *  Revision 1.143  1995/07/19  15:21:55  nickb
 *  Two constructors called MLWorks.Profile.Profile.
 *
 *  Revision 1.142  1995/07/19  13:52:44  nickb
 *  Whoops; major type screwups in new profiler.
 *
 *  Revision 1.141  1995/07/17  16:27:27  nickb
 *  Change to profiler interface.
 *
 *  Revision 1.140  1995/07/17  12:19:18  jont
 *  Add hex integer printing facilities
 *
 *  Revision 1.139  1995/07/14  10:22:45  jont
 *  Add Char structure
 *
 *  Revision 1.138  1995/06/02  13:58:48  nickb
 *  Change threads restart system.
 *
 *  Revision 1.137  1995/05/26  15:59:40  matthew
 *  Adding ML definition of implode_char
 *  Moving definition of append etc to builtin_library
 *
 *  Revision 1.136  1995/05/23  17:24:18  daveb
 *  Added ML version of substring.
 *
 *  Revision 1.135  1995/05/22  15:53:18  nickb
 *  Add threads interface
 *
 *  Revision 1.134  1995/05/19  09:18:49  matthew
 *  Adding flush to with_standard_output
 *  Adding explode function
 *
 *  Revision 1.133  1995/05/10  17:53:30  daveb
 *  Changed argument of Unix exception from int to string.
 *  Added OS.Unix.{stat,seek,set_block_mode,can_input}.
 *
 *  Revision 1.132  1995/05/02  13:12:17  matthew
 *  Adding CAST and UMAP primitives
 *  Adding new append function
 *  Removing stuff from debugger structure
 *
 *  Revision 1.131  1995/04/19  13:55:36  matthew
 *  Speed improvements to input_line: don't call end_of_stream each time
 *
 *  Revision 1.130  1995/04/13  16:51:43  jont
 *  Change atExit to define a list of functions to be executed
 *
 *  Revision 1.129  1995/04/13  14:07:20  jont
 *  Add terminate, atExit functions
 *
 *  Revision 1.128  1995/03/20  10:44:43  matthew
 *  Adding implode_char function
 *
 *  Revision 1.127  1995/03/01  11:44:25  matthew
 *  Unifying Value.Frame and Frame.pointer
 *
 *  Revision 1.126  1995/01/12  15:23:47  jont
 *  Add Win_nt.get_current_directory
 *  Add Win_nt.get_path_name
 *
 *  Revision 1.125  1994/12/09  14:37:33  jont
 *  Add OS.Win_nt structure
 *
 *  Revision 1.124  1994/11/24  14:32:38  matthew
 *  Added new "unsafe" pervasives
 *
 *  Revision 1.123  1994/09/27  16:04:14  matthew
 *  Added pervasive Option structure
 *
 *  Revision 1.122  1994/08/24  16:33:21  matthew
 *  Added unsafe array operations
 *
 *  Revision 1.121  1994/07/08  10:12:32  nickh
 *  Add event functions for stack overflow and interrupt handlers.
 *
 *  Revision 1.120  1994/06/29  15:16:51  nickh
 *  Add MLWorks messages stream.
 *
 *  Revision 1.119  1994/06/22  15:28:03  nickh
 *  Add Trace.restore_all.
 *
 *  Revision 1.118  1994/06/09  15:37:15  nickh
 *  Updated runtime signal handling.
 *
 *  Revision 1.117  1994/06/06  11:44:30  nosa
 *  Breakpoint settings on function exits.
 *
 *  Revision 1.116  1994/03/30  15:03:48  daveb
 *  Revised MLWorks.IO.set_modified_file to tae a datatype.
 *
 *  Revision 1.115  1994/03/30  13:55:31  daveb
 *  Removed input_string and output_string.
 *
 *  Revision 1.114  1994/03/30  13:23:12  daveb
 *  Added MLWorks.IO.set_file_modified.
 *
 *  Revision 1.113  1994/03/23  12:39:10  nickh
 *  New profiler, with a new interface.
 *
 *  Revision 1.112  1994/02/23  17:04:29  nosa
 *  Step and breakpoints Debugger.
 *
 *  Revision 1.111  1994/02/17  17:54:04  matthew
 *  Changed close_* on std_* streams to raise an Io exception.
 *
 *  Revision 1.110  1994/02/08  14:38:55  matthew
 *  Added realpath function
 *
 *  Revision 1.109  1994/02/08  10:45:18  nickh
 *  Added MLWorks.String.ml_string : (string * int) -> string
 *
 *  Revision 1.108  1994/01/10  14:16:50  matthew
 *  Added call to C for MLWorks.Internal.Runtime.Loader.load_module
 *
 *  Revision 1.107  1993/12/20  13:12:14  matthew
 *   Fixed problems with inexhaustive bindings
 *
 *  Revision 1.106  1993/11/18  11:20:22  nickh
 *  Add to IO and RawIO to provide closed_in and closed_out functions, which
 *  test a stream for closed-ness.
 *
 *  Revision 1.105  1993/11/17  12:30:11  nickh
 *  New time structure, to allow real intervals to be measured, to allow the
 *  user to convert to/from reals, and to optimise the "measure the user/
 *  system/gc/clock time taken by this" path.
 *
 *  Revision 1.104  1993/08/27  19:13:59  daveb
 *  Added MLworks.OS.Unix.{unlink,rmdir,mkdir}.
 *
 *  Revision 1.103  1993/08/26  11:13:00  richard
 *  Removed the X exception.  It's now in the Motif interface code.
 *
 *  Revision 1.102  1993/08/25  14:01:50  richard
 *  Added MLWorks.OS.Unix.kill.
 *
 *  Revision 1.101  1993/08/18  12:52:40  daveb
 *  Added X exception.
 *
 *  Revision 1.100  1993/07/23  11:07:49  richard
 *  Added system calls to read directories and the password file.
 *
 *  Revision 1.99  1993/07/19  13:55:02  nosa
 *  added two debugger functions
 *
 *  Revision 1.98  1993/06/09  16:10:12  matthew
 *  Added text_preprocess hook
 *
 *  Revision 1.97  1993/05/05  17:25:23  jont
 *  Added MLWorks.OS.Unix.password_file to get the association list of user
 *  names to home directories necessary for translating ~
 *
 *  Revision 1.96  1993/04/29  11:33:44  richard
 *  Corrected the call to the profiler.
 *
 *  Revision 1.95  1993/04/23  15:49:58  jont
 *  Added Integer and Real substructures of MLWorks with makestring and
 *  print functions
 *
 *  Revision 1.94  1993/04/21  15:58:24  richard
 *  Removed defunct Editor interface and added sytem calls to enable
 *  its replacement.
 *
 *  Revision 1.93  1993/04/20  13:52:21  richard
 *  Added more Unix system call interfaces.
 *  New Trace structure to go with runtime implementation.
 *  Removed commented out array functions.  (They're in RCS anyway.)
 *
 *  Revision 1.92  1993/04/13  09:53:27  matthew
 *  Moved dynamic stuff from MLWorks.Internal.Typerep to MLWorks.Dynamic
 *  Moved break stuff from MLWorks.Internal.Tracing to MLWorks.Debugger
 *
 *  Revision 1.91  1993/04/08  17:39:38  jont
 *  Minor modifications to editor structure
 *
 *  Revision 1.90  1993/04/02  14:51:00  jont
 *  Extended images structure to include table of contents reading
 *
 *  Revision 1.89  1993/03/26  15:51:39  matthew
 *  Added break function to Tracing substructure
 *
 *  Revision 1.88  1993/03/23  18:38:53  jont
 *  Added vector primitives. Changed editor implementastion slightly.
 *
 *  Revision 1.87  1993/03/18  13:44:54  jont
 *  Rewrote a number of array functions to avoid recalculating numbers like
 *  n-1 and l-n
 *
 *  Revision 1.86  1993/03/11  18:38:01  jont
 *  Added Intermal.Images including save and clean. Added other_operation
 *  to Editor for arbitrary bits of emacs lisp
 *
 *  Revision 1.85  1993/03/11  17:29:12  jont
 *  Added Editor substructure to MLWorks
 *
 *  Revision 1.84  1993/03/05  12:41:53  jont
 *  Added builtin string relationals
 *
 *  Revision 1.83  1993/03/01  12:25:53  matthew
 *  Use builtin array, bytearray and vector types
 *
 *  Revision 1.82  1993/02/26  11:13:42  nosa
 *  Implemented a multi-level profiler
 *
 *  Revision 1.81  1993/02/25  16:08:56  matthew
 *  Used builtin array type.  Removed Array.T from signature
 *
 *  Revision 1.80  1993/02/19  18:26:58  matthew
 *  Reimplemented modifiable streams
 *  Added TypeRep substructure for use with Dynamic objects.
 *
 *  Revision 1.79  1993/01/05  17:06:40  richard
 *  Added extra exceptions to those passed to the runtime system.
 *
 *  Revision 1.78  1992/12/22  12:45:32  jont
 *  Removed references to MLWorks.Vector. Removed ExtendedArray from top level
 *
 *  Revision 1.77  1992/12/22  12:15:36  jont
 *  Removed pervasive vector
 *
 *  Revision 1.76  1992/12/21  12:19:14  daveb
 *  Added support for the 'agreed' Array and Vector structures.
 *  Renamed the old Array to ExtendedArray.
 *
 *  Revision 1.75  1992/12/18  14:04:17  clive
 *  Made the profiler take the generalised streams
 *
 *  Revision 1.74  1992/12/03  18:19:09  jont
 *  Modified FileIO to be in terms of RawIO, in order to avoid type errors
 *  occurring at runtime!
 *
 *  Revision 1.73  1992/12/01  12:13:45  matthew
 *  Fixed small bug with std_err in IO.
 *
 *  Revision 1.72  1992/11/30  18:51:54  matthew
 *  Tidied up IO signature
 *
 *  Revision 1.71  1992/11/30  18:27:43  matthew
 *  Added representation of streams as records.  Old IO is now RawIO.
 *
 *  Revision 1.70  1992/11/12  17:21:19  clive
 *  Added tracing hooks to the runtime system
 *
 *  Revision 1.69  1992/11/10  13:22:27  richard
 *  Added StorageManager exception and changed the type of the
 *  StorageManager interface function.
 *
 *  Revision 1.68  1992/10/29  13:18:10  richard
 *  Removed debugger structure and added time and event structures.
 *
 *  Revision 1.67  1992/10/15  07:27:56  richard
 *  The FullPervasiveLibrary_ structure is now opened so that merely
 *  requiring this file gets you the pervasive environment.
 *
 *  Revision 1.66  1992/10/06  17:20:49  clive
 *  call_debugger now takes the debugger function as well as the exception
 *
 *  Revision 1.65  1992/09/25  16:48:59  matthew
 *  Added string_to_real
 *
 *  Revision 1.64  1992/09/23  16:13:15  daveb
 *  Added clear_eof function to IO.
 *
 *  Revision 1.63  1992/09/04  12:36:58  richard
 *  Corrected the calls to C for some exceptions.
 *  Contrained ARRAY and BITS.
 *
 *  Revision 1.62  1992/08/28  15:18:47  clive
 *  Added a function to get the debug_info from a code string
 *
 *  Revision 1.61  1992/08/27  15:42:56  richard
 *  Added extra floating point exceptions.
 *
 *  Revision 1.60  1992/08/27  10:59:18  richard
 *  Corrected some mistakes.
 *
 *  Revision 1.59  1992/08/26  15:44:58  richard
 *  Rationalisation of the MLWorks structure.
 *
 *  Revision 1.58  1992/08/25  08:10:03  richard
 *  Added ByteArrays and writebf in FileIO.  Bits structure is now
 *  duplicated at top level.
 *
 *  Revision 1.57  1992/08/20  12:24:42  richard
 *  Added extra unsafe value utilities.
 *  Enriched the Array structure using unsafe sub and update operations.
 *
 *  Revision 1.56  1992/08/18  15:44:45  richard
 *  Added Value structure with utilities for dealing with
 *  opaque values and casting.  Removed duplicate functions
 *  elsewhere.
 *  Added output and input functions to deal with more types
 *  than strings.
 *
 *  Revision 1.55  1992/08/17  13:29:35  jont
 *  Added inline ordof
 *
 *  Revision 1.54  1992/08/17  10:58:46  richard
 *  Added MLWorks.System.Runtime.GC.interface.
 *
 *  Revision 1.53  1992/08/15  17:31:47  davidt
 *  Added temporary implementation of MLWorks.IO.input_line
 *
 *  Revision 1.52  1992/08/14  11:16:51  jont
 *  Fixed parameters within ordof
 *
 *  Revision 1.51  1992/08/14  11:05:42  davidt
 *  Moved definition of ord, so that it picks up the integer
 *  comparison operations instead of the string ones.
 *
 *  Revision 1.50  1992/08/13  11:40:57  clive
 *  Added a function to get header information from an ml_object
 *
 *  Revision 1.49  1992/08/11  15:34:29  clive
 *  Work on tracing
 *
 *  Revision 1.48  1992/08/10  15:28:44  davidt
 *  Changed MLworks to MLWorks.
 *
 *  Revision 1.47  1992/08/10  15:27:12  richard
 *  Added load_wordset to interpreter structure.
 *
 *  Revision 1.46  1992/08/10  12:20:12  davidt
 *  Major reorganisation so that we have a MLworks structure, with more
 *  sensibly organised sub-structures.
 *
 *  Revision 1.44  1992/08/05  09:05:39  richard
 *  Added missing binding of runtime exception Prod.
 *
 *  Revision 1.43  1992/07/31  16:03:11  clive
 *  Added debugger.call_function
 *
 *  Revision 1.42  1992/07/29  14:19:39  clive
 *  Cahnges to call_debugger and install_debugger
 *
 *  Revision 1.41  1992/07/28  13:12:03  richard
 *  rather than numeric codes.
 *  Rewrote everything to communicate with C using the runtime environment
 *  rather than numeric codes.
 *  Added a System.Runtime structure.  More to come later.
 *
 *  Revision 1.40  1992/07/22  16:43:34  clive
 *  Added profile,save - hack version of weakarrays
 *
 *  Revision 1.39  1992/07/16  15:40:26  clive
 *  Changed the debugger to return a datatype for its desired result action
 *
 *  Revision 1.38  1992/07/14  09:27:53  clive
 *  get_next_frame now additionally returns the PC offset into the code string
 *
 *  Revision 1.37  1992/07/09  14:48:00  clive
 *  Changed the call_debugger function
 *
 *  Revision 1.36  1992/07/07  16:20:06  clive
 *  Added a manual call of the debugger for the interpreter
 *
 *  Revision 1.35  1992/06/25  14:48:03  jont
 *  Changed MLObject to be the same as ml_value used by the interpreter
 *
 *  Revision 1.34  1992/06/24  09:35:34  clive
 *  Added breakpointing functions
 *
 *  Revision 1.33  1992/06/22  16:25:49  clive
 *  Changes for the debugger
 *
 *  Revision 1.32  1992/06/19  16:43:45  jont
 *  Added ML_REQUIRE builtin for interpreter
 *  Rearranged System to include the unsafe interpreter stuff (was in NJ)
 *
 *  Revision 1.31  1992/06/18  16:22:57  jont
 *  Added new builtin ml_value_from_offset for getting pointers into
 *  middles of code vectors for letrecs
 *
 *  Revision 1.30  1992/06/15  17:05:12  jont
 *  Added extra functions load_var, load_exn, load_struct, load_funct for
 *  interpreter in structure Int inside Unsafe
 *
 *  Revision 1.29  1992/06/11  10:48:06  clive
 *  Added the debugger structure of debugger utilities
 *
 *  Revision 1.28  1992/05/20  10:24:17  clive
 *  Added Bits.arshift - arithmetic right shift
 *
 *  Revision 1.27  1992/05/18  11:54:37  clive
 *  Added timers and code for compiling the make system
 *
 *  Revision 1.26  1992/05/13  12:51:00  clive
 *  Added the Bits structure
 *
 *  Revision 1.25  1992/05/11  09:47:07  jont
 *  Changed pervasive arrayoflist to allow nil arguments
 *
 *  Revision 1.24  1992/04/28  10:12:55  clive
 *  Added NewJersey.Bits.andb so that we can still compile everything with
 *  our compiler
 *
 *  Revision 1.23  1992/04/24  15:45:26  jont
 *  Added exn_name to system structure
 *
 *  Revision 1.22  1992/03/12  16:00:56  richard
 *  Altered file operations and added lookahead function.
 *
 *  Revision 1.21  1992/03/10  12:55:28  clive
 *  Re-did Io to use fprintf etc
 *
 *  Revision 1.20  1992/02/25  14:53:38  clive
 *  Added val_print in the System structure in ML
 *
 *  Revision 1.19  1992/02/24  18:15:06  clive
 *  Took out div definition as it now calls c
 *
 *  Revision 1.18  1992/02/24  16:56:46  clive
 *  end_of_stream defined
 *
 *  Revision 1.17  1992/02/24  13:42:13  clive
 *  Added definition of div for positive arguments
 *
 *  Revision 1.16  1992/02/18  17:58:25  jont
 *  Added New Jersey structure
 *
 *  Revision 1.15  1992/02/12  09:29:47  clive
 *  New pervasive library setup
 *
 *  Revision 1.14  1992/02/03  20:12:33  jont
 *  Added most of the array functions, though with bogus implementations
 *
 *  Revision 1.13  1992/02/03  17:34:52  clive
 *  added the array structure itself
 *
 *  Revision 1.12  1992/01/23  10:12:43  richard
 *  Changed unimplemented pervasives to raise Io instead of Interrupt so
 *  we can tell which one causes a run to fail.
 *
 *  Revision 1.11  1992/01/21  15:59:18  richard
 *  Removed explicit numbering of C routines and replaced by members of the
 *  automatically generated structure CallCCodes_.
 *  Commented out arrayoflist and tabulate until they can be implemented
 *  without depending on themselves.
 *
 *  Revision 1.10  1992/01/21  10:56:50  clive
 *  Spelling mistake in tabulate
 *
 *  Revision 1.9  1992/01/17  11:34:40  clive
 *  array_of_list should have been arrayoflist
 *
 *  Revision 1.8  1992/01/16  17:43:28  clive
 *  Added array code
 *
 *  Revision 1.7  1992/01/13  11:29:13  richard
 *  Added substring as a temporary measure until we bootstrap the compiler.
 *
 *  Revision 1.6  1991/12/20  09:53:51  richard
 *  Implemented the real arithmetic functions.
 *
 *  Revision 1.5  91/12/16  13:12:54  richard
 *  Added error handling to input and output, plus calls to C for various
 *  other functions.
 *
 *  Revision 1.4  91/12/10  13:57:08  richard
 *  Added equal and not_equal.
 *
 *  Revision 1.3  91/12/09  15:46:20  richard
 *  Added a signature constraint so that common sub-functions can be
 *  added freely to the structure.  Wrote file input and output pervasives.
 *
 *  Revision 1.2  91/12/04  16:00:40  jont
 *  Optimised the builtin entirely ml functions
 *
 *  Revision 1.1  91/11/28  17:06:21  richard
 *  Initial revision
 *)

require " __builtin_library";

signature ARRAY =
  sig
    eqtype 'a array
    exception Size
    exception Subscript
    val array: int * '_a -> '_a array
    val arrayoflist: '_a list -> '_a array
    val tabulate: int * (int -> '_a) -> '_a array
    val sub: 'a array * int -> 'a
    val update: 'a array * int * 'a -> unit
    val length: 'a array -> int
  end

signature EXTENDED_ARRAY =
  sig
    (* include "ARRAY" -- omitted to keep SML/NJ happy. *)
    eqtype 'a array
    exception Size
    exception Subscript
    exception Find

    val array		: int * '_a -> '_a array
    val length		: 'a array -> int
    val update		: 'a array * int * 'a -> unit
    val sub		: 'a array * int -> 'a
    val arrayoflist	: '_a list -> '_a array
    val tabulate	: int * (int -> '_a) -> '_a array

    val from_list	: '_a list -> '_a array
    val to_list		: 'a array -> 'a list
    val fill		: 'a array * 'a -> unit
    val map		: ('a -> '_b) -> 'a array -> '_b array
    val map_index	: (int * 'a -> '_b) -> 'a array -> '_b array
    val iterate		: ('a -> unit) -> 'a array -> unit
    val iterate_index	: (int * 'a -> unit) -> 'a array -> unit
    val rev		: '_a array -> '_a array
    val duplicate	: '_a array -> '_a array
    val subarray	: '_a array * int * int -> '_a array
    val append		: '_a array * '_a array -> '_a array
    val reducel		: ('a * 'b -> 'a) -> ('a * 'b array) -> 'a
    val reducer		: ('a * 'b -> 'b) -> ('a array * 'b) -> 'b
    val reducel_index	: (int * 'a * 'b -> 'a) -> ('a * 'b array) -> 'a
    val reducer_index	: (int * 'a * 'b -> 'b) -> ('a array * 'b) -> 'b
    val copy		: 'a array * int * int * 'a array * int -> unit
    val fill_range	: 'a array * int * int * 'a -> unit
    val find		: ('a -> bool) -> 'a array -> int
    val find_default	: (('a -> bool) * int) -> 'a array -> int
    val maxLen          : int
  end;

signature VECTOR =
  sig
    eqtype 'a vector
    exception Size
    exception Subscript
    val vector: 'a list -> 'a vector
    val tabulate: int * (int -> 'a) -> 'a vector
    val sub: 'a vector * int -> 'a
    val length: 'a vector -> int
    val maxLen : int
  end

signature BYTEARRAY =
  sig
    eqtype bytearray

    exception Range of int
    exception Size
    exception Subscript
    exception Substring
    exception Find

    val array		: int * int -> bytearray
    val length		: bytearray -> int
    val update		: bytearray * int * int -> unit
    val sub		: bytearray * int -> int
    val arrayoflist	: int list -> bytearray

    val tabulate	: int * (int -> int) -> bytearray
    val from_list	: int list -> bytearray
    val to_list		: bytearray -> int list
    val from_string	: string -> bytearray
    val to_string	: bytearray -> string
    val fill		: bytearray * int -> unit
    val map		: (int -> int) -> bytearray -> bytearray
    val map_index	: (int * int -> int) -> bytearray -> bytearray
    val iterate		: (int -> unit) -> bytearray -> unit
    val iterate_index	: (int * int -> unit) -> bytearray -> unit
    val rev		: bytearray -> bytearray
    val duplicate	: bytearray -> bytearray
    val subarray	: bytearray * int * int -> bytearray
    val substring	: bytearray * int * int -> string
    val append		: bytearray * bytearray -> bytearray
    val reducel		: ('a * int -> 'a) -> ('a * bytearray) -> 'a
    val reducer		: (int * 'a -> 'a) -> (bytearray * 'a) -> 'a
    val reducel_index	: (int * 'a * int -> 'a) -> ('a * bytearray) -> 'a
    val reducer_index	: (int * int * 'a -> 'a) -> (bytearray * 'a) -> 'a
    val copy		: bytearray * int * int * bytearray * int -> unit
    val fill_range	: bytearray * int * int * int -> unit
    val find		: (int -> bool) -> bytearray -> int
    val find_default	: ((int -> bool) * int) -> bytearray -> int
    val maxLen          : int
  end;

signature FLOATARRAY =
  sig
    eqtype floatarray

    exception Range of int
    exception Size
    exception Subscript
    exception Find

    val array		: int * real -> floatarray
    val length		: floatarray -> int
    val update		: floatarray * int * real -> unit
    val sub		: floatarray * int -> real
    val arrayoflist	: real list -> floatarray

    val tabulate	: int * (int -> real) -> floatarray
    val from_list	: real list -> floatarray
    val to_list		: floatarray -> real list
    val fill		: floatarray * real -> unit
    val map		: (real -> real) -> floatarray -> floatarray
    val map_index	: (int * real -> real) -> floatarray -> floatarray
    val iterate		: (real -> unit) -> floatarray -> unit
    val iterate_index	: (int * real -> unit) -> floatarray -> unit
    val rev		: floatarray -> floatarray
    val duplicate	: floatarray -> floatarray
    val subarray	: floatarray * int * int -> floatarray
    val append		: floatarray * floatarray -> floatarray
    val reducel		: ('a * real -> 'a) -> ('a * floatarray) -> 'a
    val reducer		: (real * 'a -> 'a) -> (floatarray * 'a) -> 'a
    val reducel_index	: (int * 'a * real -> 'a) -> ('a * floatarray) -> 'a
    val reducer_index	: (int * real * 'a -> 'a) -> (floatarray * 'a) -> 'a
    val copy		: floatarray * int * int * floatarray * int -> unit
    val fill_range	: floatarray * int * int * real -> unit
    val find		: (real -> bool) -> floatarray -> int
    val find_default	: ((real -> bool) * int) -> floatarray -> int
    val maxLen          : int
  end;

signature STRING = 
  sig 
    exception Substring
    exception Chr
    exception Ord
    val maxLen : int
    val explode : string -> string list
    val implode : string list -> string
    val chr : int -> string
    val ord : string -> int
    val substring : string * int * int -> string
    val <  : string * string -> bool
    val >  : string * string -> bool
    val <= : string * string -> bool
    val >= : string * string -> bool
    val ordof : string * int -> int

    val ml_string : string * int -> string

    val implode_char : int list -> string

  end;

signature BITS =
  sig
    val andb    : int * int -> int
    val orb     : int * int -> int
    val xorb    : int * int -> int
    val lshift  : int * int -> int
    val rshift  : int * int -> int
    val arshift : int * int -> int
    val notb    : int -> int
  end;

signature GENERAL =
  sig
    eqtype  unit
    type  exn

    exception Bind
    exception Match
    exception Subscript
    exception Size
    exception Overflow
    exception Domain
    exception Div
    exception Chr
    exception Fail of string
    exception Empty

    val exnName : exn -> string
    val exnMessage : exn -> string

    datatype order = LESS | EQUAL | GREATER

    val <> : (''a * ''a) -> bool

    val ! : 'a ref -> 'a

    val := : ('a ref * 'a) -> unit

    val o : (('b -> 'c) * ('a -> 'b)) -> 'a -> 'c

    val before : ('a * unit) -> 'a

    val ignore : 'a -> unit

  end

signature MLWORKS =
  sig

    structure String : STRING

    exception Interrupt

    structure Deliver :
    sig
      datatype app_style = CONSOLE | WINDOWS
      type deliverer = string * (unit -> unit) * app_style -> unit
      type delivery_hook = deliverer -> deliverer
      val deliver : deliverer
      val with_delivery_hook : delivery_hook -> ('a -> 'b) -> 'a -> 'b
      val add_delivery_hook : delivery_hook -> unit
      val exitFn : (unit -> unit) ref
    end
	
    val arguments : unit -> string list
    val name: unit -> string

    structure Threads :
      sig
	type 'a thread
        exception Threads of string
	
	val fork : ('a -> 'b) -> 'a -> 'b thread
	val yield : unit -> unit
	
	datatype 'a result =
	  Running		(* still running *)
	| Waiting		(* waiting *)
	| Sleeping		(* sleeping *)
	| Result of 'a		(* completed, with this result *)
	| Exception of exn	(* exited with this uncaught exn *)
	| Died			(* died (e.g. bus error) *)
	| Killed		(* killed *)
	| Expired		(* no longer exists (from a previous image) *)
	
	val result : 'a thread -> 'a result

	val sleep : 'a thread -> unit
	val wake : 'a thread -> unit

	structure Internal :
	  sig
	    eqtype thread_id
	
	    val id : unit -> thread_id		(* this thread *)
	    val get_id : 'a thread -> thread_id	(* that thread *)
	
	    val children : thread_id -> thread_id list
	    val parent : thread_id -> thread_id
	
	    val all : unit -> thread_id list	 (* all threads *)
	
	    val kill : thread_id -> unit	 (* kill a thread *)
	    val raise_in : thread_id * exn -> unit (* raise E in the thread *)
	    val yield_to : thread_id -> unit	 (* fiddle with scheduling *)
	
	    val state : thread_id -> unit result (* the state of that thread *)
	    val get_num : thread_id -> int	 (* the 'thread number' *)
	
	    val set_handler  : (int -> unit) -> unit
	    	(* fatal signal handler fn for this thread *)
	
	    val reset_fatal_status : unit -> unit
	      (* Mark the thread as being outside of a fatal handler *)

	    structure Preemption :
	      sig
		val start : unit -> unit
		val stop : unit -> unit
		val on : unit -> bool
		val get_interval : unit -> int	(* milliseconds *)
		val set_interval : int -> unit
                val enter_critical_section: unit -> unit
                val exit_critical_section: unit -> unit
                val in_critical_section: unit -> bool
	      end
	  end
      end

    structure Internal :
      sig

	exception Save of string
	val save : string * (unit -> 'a) -> unit -> 'a
	val execSave : string * (unit -> 'a) -> unit -> 'a
        val real_to_string	: real * int -> string
        exception StringToReal
        val string_to_real : string -> real

        val text_preprocess : ((int -> string) -> int -> string) ref

	structure Types :
	  sig
	    type int8
	    type word8
	    type int16
	    type word16
	    type int32
	    type word32
            datatype 'a option = SOME of 'a | NONE
	    datatype time = TIME of int * int * int (* basis time *)
	  end

        structure Error :
          sig
            type syserror
            exception SysErr of string * syserror Types.option
            val errorMsg: syserror -> string
            val errorName: syserror -> string
            val syserror: string -> syserror Types.option
          end


        structure IO :
          sig
            exception Io of {cause: exn, name: string, function: string}

            datatype file_desc = FILE_DESC of int
            val write     : file_desc * string * int * int -> int
            val read      : file_desc * int -> string
            val seek      : file_desc * int * int -> int
            val close     : file_desc -> unit
            val can_input : file_desc -> int
          end


        structure StandardIO :
          sig
            type IOData = {input: {descriptor: IO.file_desc Types.option,
                                   get: int -> string,
                                   get_pos: (unit -> int) Types.option,
                                   set_pos: (int -> unit) Types.option,
                                   can_input: (unit-> bool) Types.option,
                                   close: unit->unit},
              output: {descriptor: IO.file_desc Types.option,
                       put: {buf:string,i:int,sz:int Types.option} -> int,
                       get_pos: (unit -> int) Types.option,
                       set_pos: (int -> unit) Types.option,
                       can_output: (unit-> bool) Types.option,
                       close: unit->unit},
              error: {descriptor: IO.file_desc Types.option,
                      put: {buf:string,i:int,sz:int Types.option} -> int,
                      get_pos: (unit -> int) Types.option,
                      set_pos: (int -> unit) Types.option,
                      can_output: (unit->bool) Types.option,
                      close: unit-> unit},
              access: (unit->unit)->unit}

            val currentIO: unit -> IOData
            val redirectIO: IOData -> unit
            val resetIO: unit -> unit
            val print : string -> unit
            val printError : string -> unit
          end


	structure Images :
	  sig
	    exception Table of string
	    val clean : unit -> unit
	    val save : string * (unit -> 'a) -> unit -> 'a
	    val table : string -> string list
	  end

        structure Bits : BITS

	structure Word32 :
	  sig
            val word32_orb: Types.word32 * Types.word32 -> Types.word32
            val word32_xorb: Types.word32 * Types.word32 -> Types.word32
            val word32_andb: Types.word32 * Types.word32 -> Types.word32
            val word32_notb: Types.word32 -> Types.word32
            val word32_lshift: Types.word32 * word -> Types.word32
            val word32_rshift: Types.word32 * word -> Types.word32
            val word32_arshift: Types.word32 * word -> Types.word32
	  end;

	structure Word :
	  sig
            val word_orb: word * word -> word
            val word_xorb: word * word -> word
            val word_andb: word * word -> word
            val word_notb: word -> word
            val word_lshift: word * word -> word
            val word_rshift: word * word -> word
            val word_arshift: word * word -> word
	  end;

	structure Array : ARRAY
	structure ByteArray : BYTEARRAY
        structure FloatArray: FLOATARRAY
	structure ExtendedArray : EXTENDED_ARRAY
	structure Vector : VECTOR

        structure Value :
          sig
            type ml_value
            type T = ml_value

            exception Value of string

            val cast		: 'a -> 'b
            val ccast		: 'a -> 'b
            val list_to_tuple	: T list -> T
            val tuple_to_list	: T -> T list
            val string_to_real	: string -> real
            val real_to_string	: real -> string

            (* real equality -- needed now real isn't an equality type *)
            val real_equal : real * real -> bool
            val arctan : real -> real
            val cos : real -> real
            val exp : real -> real
            val sin : real -> real
            val sqrt : real -> real

            (* Unchecked arithmetic *)
            val unsafe_plus : int * int -> int
            val unsafe_minus : int * int -> int

            (* Unchecked structure accessing *)
            val unsafe_array_sub : '_a Array.array * int -> '_a
            val unsafe_array_update : '_a Array.array * int * '_a -> unit

            val unsafe_bytearray_sub : ByteArray.bytearray * int -> int
            val unsafe_bytearray_update : ByteArray.bytearray * int * int -> unit

            val unsafe_floatarray_sub : FloatArray.floatarray * int -> real
            val unsafe_floatarray_update : FloatArray.floatarray * int * real -> unit

            val unsafe_record_sub : 'a  * int -> 'b
            (* This is the really nasty one, only use to update a newer object with an older *)
            val unsafe_record_update : 'a  * int * 'b -> unit

            (* Unchecked ordof *)
            val unsafe_string_sub	: string * int -> int

            (* Allows destructive update of strings -- use with care *)
            val unsafe_string_update	: string * int * int -> unit

            (* Allocate an object of the specified type. *)
            (* alloc_pair and alloc_vector initialize slots to 0 *)
            (* alloc_string returns uninitialized string of given size *)
            (* nb. size (alloc_string n) = n-1 as the terminating 0 is counted *)

            val alloc_pair		: unit -> ml_value
            val alloc_vector		: int -> ml_value
            val alloc_string		: int -> string

            datatype print_options =
              DEFAULT |
              OPTIONS of {depth_max	  	: int,
                          string_length_max	: int,
                          indent		: bool,
                          tags		  	: bool}
            val print		: print_options * ml_value -> unit

            val pointer		: T * int -> T
            val primary		: T -> int
            val header		: T -> int * int
            val update_header	: T * int * int -> unit
            val sub		: T * int -> T
            val update		: T * int * T -> unit
            val sub_byte	: T * int -> int
            val update_byte	: T * int * int -> unit

            val exn_name	: exn -> string
            val exn_argument	: exn -> T

            val code_name	: T -> string

	    (* exceptions *)
	    val update_exn : exn * exn ref -> unit
	    val update_exn_cons : ('a -> exn) * ('a -> exn) ref -> unit
	    (* Note well *)
	    (* Since these functions update a pair, which is something *)
	    (* the gc is not expecting to happen, you should take care *)
	    (* that the value being placed into the pair is older *)
	    (* than the pair itself. Also, you should not use the updated *)
	    (* exception within a handler inside the structure in which *)
	    (* it (the exception which has been updated) was originally *)
	    (* defined. This is because the compiler will already have *)
	    (* the original unique available to it, and will use that *)
	    (* when generating the handle, rather then that update value *)
	    (* I would also advise against creating a handler in the same *)
	    (* structure as the one containing the called to update_exn, *)
	    (* for similar reasons *)

            (* This stuff should be implementable in a platform independent way *)
            (* The meaning of frame offsets could be platform dependent though *)
            structure Frame :
              sig
                eqtype frame
                val sub		: frame * int -> T
                val update	: frame * int * T -> unit

                (* Gives the frame of the calling function *)
                val current	: unit -> frame
                val is_ml_frame : frame -> bool

                (* This stuff is required by the debugger but really ought to be *)
                (* chucked out. *)

                val frame_call      : (frame -> 'a) -> 'a
                val frame_next      : frame -> bool * frame * int
                val frame_offset    : frame * int -> T
		val frame_double    : frame * int -> T
                val frame_allocations : frame -> bool
              end
          end

        structure Trace :
          sig
            exception Trace of string
            val intercept	: ('a -> 'b) * (Value.Frame.frame -> unit) -> unit
            val replace		: ('a -> 'b) * (Value.Frame.frame -> unit) -> unit
            val restore		: ('a -> 'b) -> unit
	    val restore_all	: unit -> unit
            datatype status = INTERCEPT | NONE | REPLACE | UNTRACEABLE
            val status		: ('a -> 'b) -> status
          end

        structure Runtime :
          sig
            exception Unbound of string
            val environment	: string -> 'a

            val modules		: (string * Value.T * Value.T) list ref

            structure Loader :
              sig
                exception Load of string
                val load_module		: string -> (string * Value.T)
                val load_wordset :
		  int *
		  {a_names:string list,
		   b:{a_clos:int, b_spills:int, c_saves:int, d_code:string} list,
		   c_leafs:bool list, d_intercept:int list,
		   e_stack_parameters: int list} ->
                  (int * Value.T) list
              end;

            structure Memory :
              sig
                val gc_message_level	: int ref
		val max_stack_blocks    : int ref
		val collect             : int -> unit
		val collect_all         : unit -> unit
		val collections         : unit -> int * int
		val promote_all       : unit -> unit
              end;

            structure Event :
              sig
                datatype T = SIGNAL of int
                exception Signal of string
                val signal : int * (int -> unit) -> unit
		val stack_overflow_handler : (unit -> unit) -> unit
		val interrupt_handler : (unit -> unit) -> unit
              end;
          end

        structure Dynamic :
          sig
	    (* Dynamics are rather special.  They can only be used in the
	       interpreter, and require special compiler support.  The
	       generalises_ref is set in _scheme and used in the coerce
	       function.  The coerce function is called by code that is
	       constructed by code in _typerep_utils. *)

            type dynamic
            type type_rep

            exception Coerce of type_rep * type_rep

            val generalises_ref : ((type_rep * type_rep) -> bool) ref

            (* return a coerced value or raise Coerce Coerce (t,t') if
	       generalisation fails *)
            val coerce : (dynamic * type_rep) -> Value.ml_value
          end

        structure Exit :
        sig
          eqtype key
          type status = Types.word32
          val success : status
          val failure : status
          val atExit : (unit -> unit) -> key
          val removeAtExit : key -> unit
          val exit : status -> 'a
          val terminate : status -> 'a
        end

        structure Debugger :
          sig
            val break_hook : (string -> unit) ref
            val break      : string -> unit
          end

      end (* of structure Internal *)
    structure Profile :
      sig
	type manner
	type function_id = string
	type cost_centre_profile = unit
	
	datatype object_kind =
	  RECORD
	| PAIR
	| CLOSURE
	| STRING
	| ARRAY
	| BYTEARRAY
	| OTHER		(* includes weak arrays, code objects *)
	| TOTAL		(* only used when specifying a profiling manner *)

	datatype large_size =
	  Large_Size of
	  {megabytes : int,
	   bytes : int}	
	
	datatype object_count =
	  Object_Count of
	  {number : int,
	   size : large_size,
	   overhead : int}
	
	datatype function_space_profile =
	  Function_Space_Profile of
	  {allocated : large_size,	
	   copied : large_size,		
	   copies : large_size list,
	   allocation : (object_kind * object_count) list list}
	
	datatype function_caller =
	  Function_Caller of
	  {id: function_id,
	   found: int,
	   top: int,
	   scans: int,
	   callers: function_caller list}
	
	datatype function_time_profile =
	  Function_Time_Profile of
	  {found: int,
	   top: int,
	   scans: int,
	   depth: int,
	   self: int,
	   callers: function_caller list}
	
	datatype function_profile =
	  Function_Profile of
	  {id: function_id,
	   call_count: int,
	   time: function_time_profile,
	   space: function_space_profile}
	
	datatype general_header =
	  General of
	  {data_allocated: int,
	   period: Internal.Types.time,
	   suspended: Internal.Types.time}
	
	datatype call_header =
	  Call of {functions : int}
	
	datatype time_header =
	  Time of
	  {data_allocated: int,
	   functions: int,
	   scans: int,
	   gc_ticks: int,
	   profile_ticks: int,
	   frames: real,
	   ml_frames: real,
	   max_ml_stack_depth: int}
	
	datatype space_header =
	  Space of
	  {data_allocated: int,
	   functions: int,
	   collections: int,
	   total_profiled : function_space_profile}

	type cost_header = unit
	
	datatype profile =
	  Profile of
	  {general: general_header,
	   call: call_header,
	   time: time_header,
	   space: space_header,
	   cost: cost_header,
	   functions: function_profile list,
	   centres: cost_centre_profile list}

	  datatype options =
	    Options of
	    {scan : int,
	     selector : function_id -> manner}

	  datatype 'a result =
	    Result of 'a
	  | Exception of exn

        exception ProfileError of string

	val profile : options -> ('a -> 'b) -> 'a -> ('b result * profile)

	  val make_manner :
	    {time : bool,
	     space : bool,
	     calls : bool,
	     copies : bool,
	     depth : int,
	     breakdown : object_kind list} -> manner
      end

  end (* of structure MLWorks *) ;

structure FullPervasiveLibrary_  :
  sig
    structure MLWorks : MLWORKS

    datatype option = datatype MLWorks.Internal.Types.option

    structure General: GENERAL

    exception Option

    include GENERAL

    eqtype 'a array
    eqtype 'a vector

    val chr		      : int -> char
    val ord		      : char -> int
    val floor                 : real -> int
    val ceil                  : real -> int
    val trunc                 : real -> int
    val round                 : real -> int
    val real                  : int -> real
    val /                     : real * real -> real
    val @@                     : 'a list * 'a list -> 'a list
    val ^                     : string * string -> string
    val map                   : ('a -> 'b) -> 'a list -> 'b list
    val not                   : bool -> bool
    val rev                   : 'a list -> 'a list
    val size                  : string -> int


    val str                   : char -> string
    val concat                : string list -> string
    val implode               : char list -> string
    val explode               : string -> char list
    val substring             : string * int * int -> string

    val null                  : 'a list -> bool
    val hd                    : 'a list -> 'a
    val tl                    : 'a list -> 'a list
    val length                : 'a list -> int

    val app                   : ('a -> unit) -> 'a list -> unit
    val foldr                 : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
    val foldl                 : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b

    val print                 : string -> unit
    val vector                : 'a list -> 'a vector

    val isSome : 'a option -> bool
    val valOf : 'a option -> 'a
    val getOpt : 'a option * 'a -> 'a

  end

=

  struct

    open BuiltinLibrary_

    val chr = char_chr
    val ord = char_ord

    exception Unimplemented of string
    exception Substring

    fun ignore x = ()

    structure MLWorks : MLWORKS =
      struct

	exception Interrupt

        val arguments : unit -> string list = call_c "system os arguments"
        val name: unit -> string = call_c "system os name"

        structure String : STRING =
          struct
            open BuiltinLibrary_
	
            exception Substring = Substring

            val maxLen = 16777195 (* MAGIC: One less than ByteArray.maxLen *)
            val unsafe_substring : (string * int * int) -> string =
              call_c "string unsafe substring"
            fun substring (s, i, n) =
              if n < 0 then raise Substring
              else if i < 0 then raise Substring
              else if i > size s - n then raise Substring
              else if n > 12 then unsafe_substring (s, i, n)
              else
                let
                  val new_s = alloc_string (n + 1)
                  fun copy 0 = new_s
                  |   copy j =
                    let
                      val j' = j - 1
                    in
                      string_unsafe_update
                         (new_s, j', string_unsafe_sub (s, i+j'));
                      copy j'
                    end
                in
                  string_unsafe_update (new_s, n, 0);
                  copy n
                end;

            val c_implode_char : int list * int -> string =
              call_c "string c implode char"

            (* For more than ~30 characters this is slower than the
               C function.*)
            (* We could do something similar with implode too *)
            fun implode_char cl : string =
              let
                fun copyall ([],start,to) = to
                  | copyall (c::cl,start,to) =
                  (string_unsafe_update (to,start,c);
                   copyall (cl,start+1,to))
                fun get_size (a::rest,sz) = get_size (rest,1 + sz)
                  | get_size ([],sz) =
                  if sz > 30 then c_implode_char (cl,sz)
                  else
                    let
                      val result = alloc_string (sz+1)
                      (* set the null terminator *)
                      val _ = string_unsafe_update (result,sz,0)
                    in
                      copyall (cl,0,result)
                    end
              in
                get_size (cl,0)
              end

	    fun ml_string (s,max_size) =
	      let
                val string_abbrev = "\\..."
                val (s,abbrev) =
                  if max_size < 0 orelse size s <= max_size
                    then (s,false)
                  else if max_size < size string_abbrev
                    then ("",true)
                  else (substring (s,0,max_size - size string_abbrev),true)
		fun to_digit n = chr (n +ord "0")
		fun aux ([],result) = implode (rev result)
		  | aux (char::rest,result) =
		    let val newres =
		      case char of
			"\n" => "\\n"::result
		      | "\t" => "\\t"::result
		      | "\"" => "\\\""::result
		      | "\\" => "\\\\"::result
		      | c =>
			  let val n = ord c
			  in
			    if n < 32 orelse n >= 127 then
			      let
				val n1 = n div 10
			      in
				(to_digit (n mod 10))::
				(to_digit (n1 mod 10))::
				(to_digit (n1 div 10))::
				"\\" :: result
			      end
			    else
			      c::result
			  end
		    in
		      aux (rest, newres)
		    end
	      in
                aux (explode s,[]) ^ (if abbrev then string_abbrev else "")
	      end

            (* Finally define these *)
            val op <  : string * string -> bool = string_less
            val op >  : string * string -> bool = string_greater
            val op <= : string * string -> bool = string_less_equal
            val op >= : string * string -> bool = string_greater_equal

          end (* structure String *)

        structure Deliver =
	  struct
	    (* This datatype is passed into the runtime delivery function and 
	     * is tested as an integer in C.  *)
	    datatype app_style = CONSOLE | WINDOWS
	    type deliverer = string * (unit -> unit) * app_style -> unit
	    type delivery_hook = deliverer -> deliverer
	    local
	      val c_deliver : deliverer = call_c "function deliver"
	      val delivery_hooks : delivery_hook list ref = ref []
	      fun true_deliverer (f,[]) = f
		| true_deliverer (f,h::hs) = true_deliverer (h f, hs)
	    in
	      fun add_delivery_hook (h : delivery_hook) =
		delivery_hooks := (h::(!delivery_hooks))

	      fun with_delivery_hook h f x =
		let
		  val hs = !delivery_hooks
		  val _ = delivery_hooks := (h::hs)
		  fun restore () = delivery_hooks := hs
		  val result = f x handle exn => (restore (); raise exn)
		in
		  (restore (); result)
		end

	      val exitFn = ref (fn () => ())

	      fun deliver args =
		let
                  val old_deliverer = true_deliverer(c_deliver, !delivery_hooks)
		  val deliverer =
		    (fn (s, f, b) =>
			old_deliverer (s, fn () => (ignore(f()); (!exitFn) ()), b) )

                  val hooks = !delivery_hooks
		in
                  delivery_hooks := [];
                  deliverer args
                    handle exn =>
                      (delivery_hooks := hooks; raise exn);
                  delivery_hooks := hooks
		end
	    end (* local *)
	  end (* structure Deliver *)

        structure Internal =
          struct

	    exception Save of string

	    structure Types =
	      struct
		type int8 = int8
		type word8 = word8
		type int16 = int16
		type word16 = word16
		type int32 = int32
		type word32 = word32
                datatype 'a option = SOME of 'a | NONE
		datatype time = TIME of int * int * int
              end (* structure Types *)

	    val save : string * (unit -> 'a) -> unit -> 'a =
	      fn x => call_c "image save" x
	    val execSave = fn x => call_c "exec image save" x
            val real_to_string : real * int -> string = call_c "real to string"

            exception StringToReal
            val string_to_real : string -> real = call_c "real from string"

            val text_preprocess = ref (fn (f : int -> string ) => f)


            (* Provide the SysErr excaption as required by the basis OS structure.
             * The exception is defined here so as to avoid the rebinding problem
             * that occurs if the exception was bound in a user loadable file.
             *
             * Any changes made here should be reflected in the runtime, see
             * rts/src/OS/Unix/unix.c and rts/src/OS/Win32/win32.c
             *)
            structure Error =
              struct
                type syserror = int
                exception SysErr of string * syserror Types.option
                val errorMsg  : syserror -> string = call_c "OS.errorMsg"
                val errorName : syserror -> string = call_c "OS.errorName"
                val syserror  : string -> syserror Types.option
                  = call_c "OS.syserror"
              end (* structure Error *)



            (* IO provides some features that are needed to primarily to
             * support MLWorks.Internal.StandardIO.  I pulled them out of
             * StandardIO and added the file_desc type since the routines
             * are also needed elsewhere (for example win32/_win32os.sml).
             *
             * Note at some point the routines [sc]ould be updated to use
             * the same interface as similarly named routines in POSIX.IO
             * and hence avoid code duplication and/or casts.
             *
             * Any changes made here should be reflected in the runtime, see
             * rts/src/OS/Unix/unix.c and rts/src/OS/Win32/win32.c
             *
             * Added exception Io from basis so that it can be handled
             * easily by exnMessage.
             *)
            structure IO =
              struct
                exception Io of {name : string, function : string, cause : exn}

                datatype file_desc = FILE_DESC of int

                val write: file_desc * string * int * int-> int
                  = call_c "system io write"

                val read: file_desc * int -> string
                  = call_c "system io read"

                val seek: file_desc * int * int -> int
                  = call_c "system io seek"

                val close: file_desc -> unit
                  = call_c "system io close"

                val can_input: file_desc -> int
                  = call_c "system io can input"
              end (* structure IO *)

            structure StandardIO =
              struct
                   (* the following determines a "current I/O context" *)
                   (* which is set by each window as it evaluates a    *)
                   (* function.                                        *)
                   (* #input records all data required to manipulate   *)
                   (* standard in.  #output for standard out, and      *)
                   (* #error for standard error.                       *)


                   (* IMPORTANT: if you change this, then change the   *)
                   (* files gui/_listener.sml, gui/_podium.sml,        *)
                   (* gui/_console.sml, gui/console.sml,               *)
                   (* gui/_comp_manager.sml, interpreter/xinterpreter, *)
                   (* pervasive/gui_standard_io.sml, unix/__primio.sml *)
                   (* win_nt/__primio.sml, motif/_menus.sml and last   *)
                   (* mswindows/_menus.sml         .                   *)

                type IOData = {input:{descriptor: IO.file_desc Types.option,
                                      get: int -> string,
                                      get_pos: (unit -> int) Types.option,
                                      set_pos: (int -> unit) Types.option,
                                      close: unit -> unit,
                                      can_input: (unit -> bool) Types.option},
                  output: {descriptor: IO.file_desc Types.option,
                           put: {buf:string, i:int, sz: int Types.option}
                                   -> int,
                           get_pos: (unit -> int) Types.option,
                           set_pos: (int -> unit) Types.option,
                           can_output: (unit->bool) Types.option,
                           close: unit-> unit},
                  error: {descriptor: IO.file_desc Types.option,
                          put: {buf:string, i:int, sz: int Types.option}
                                -> int,
                          get_pos: (unit -> int) Types.option,
                          set_pos: (int -> unit) Types.option,
                          can_output: (unit->bool) Types.option,
                          close: unit->unit},
                  access: (unit->unit)->unit}

                  (* access is a hook for the gui to provide some code
                   * for MLWorks.Threads.Internal.Preemption.stop()
                   * to execute before it actually stops preempting.
                   * This allows guis to actually claim control of the
                   * listener before shutting down preemption.
                   * See <URI:spring://ML_Notebook/Design/GUI/Mutexes>.
                   *)
                local
                  val stdIn: IO.file_desc ref =
                                 call_c "system io standard input";
                  val stdOut: IO.file_desc ref =
                                 call_c "system io standard output";
                  val stdErr: IO.file_desc ref =
                                 call_c "system io standard error";


                  val terminalIO : IOData =
                    {output={descriptor=Types.SOME (!stdOut),
                                         (*YUK*)
                             put=fn {buf,i,sz=Types.NONE} =>
                                       IO.write(!stdOut,buf,i,size buf-i)
                                  | {buf,i,sz=Types.SOME n} =>
                                       IO.write(!stdOut,buf,i,n),
                             get_pos = Types.SOME(fn () =>
                                                       IO.seek(!stdOut,0,1)),

                               (* seek to 0th byte after current (=1) pos*)
                               (* which returns the position in file     *)
                             set_pos = Types.SOME
                                          (fn i => (ignore(IO.seek (!stdOut,i,0));())),
                             can_output = Types.NONE,
                             close = fn () => IO.close (!stdOut)},
                               (* seek to ith byte after beginning(=0) *)
                     error={descriptor=Types.SOME (!stdErr),
                             put=fn {buf,i,sz=Types.NONE} =>
                                       IO.write(!stdErr,buf,i,size buf-i)
                                  | {buf,i,sz=Types.SOME n} =>
                                       IO.write(!stdErr,buf,i,n),
                             get_pos=
                                   Types.SOME
                                    (fn () => IO.seek(!stdErr,0,1)),
                             set_pos= Types.SOME
                                     (fn i => (ignore(IO.seek(!stdErr,i,0)); ())),
                             can_output = Types.NONE,
                             close= fn () => IO.close (!stdErr)},
                     input={descriptor=Types.SOME (!stdIn),
                             get= fn i => IO.read (!stdIn,i),
                             get_pos= Types.SOME
                                       (fn () => IO.seek(!stdIn,0,1)),
                             set_pos= Types.SOME
                                            (fn i => (ignore(IO.seek(!stdIn,i,0));())),
                             close= fn() => IO.close (!stdIn),
                             can_input=
                                  Types.SOME
                                    (fn()=>IO.can_input (!stdIn)>0)},
                     access = fn f =>f()}

                  val currIO: IOData ref = ref terminalIO

                in
                  fun currentIO () = !currIO
                  fun redirectIO (newIO:IOData) =
                    (currIO:=newIO)
                  fun resetIO() = currIO:=terminalIO
                  fun print s = (ignore(#put(#output(currentIO()))
                                          {buf=s,i=0,sz=Types.NONE}); ())
                  fun printError s = (ignore(#put(#error(currentIO()))
                                               {buf=s,i=0,sz=Types.NONE});())
                end

              end (* structure StandardIO *)

            structure Exit =
              struct
                type key = int
                type status = word32
                val success : status = 0w0
                val failure : status = 0w1

                fun terminate (x:status):'a = call_c "system os exit" x

                val exitActions = ref [] : (key * (unit -> unit)) list ref

                val exiting = ref false : bool ref

                (* exit is a little convoluted because it must satisfy the
                 * following requirement on OS.Process.exit :-
                 *
                 *   Calls to *exit* do not return, but should cause the remainder 
                 *   of the functions registered with *atExit* to be executed.
                 *)

                fun exit exitCode =
                  let 
                    fun exit' [] = terminate exitCode
                      | exit' ((_,action)::actions) = 
                          (exitActions := actions;
                           (action () handle _ => ());
                           exit' actions)
                  in
                    exiting := true;
                    exit' (!exitActions)
                  end

                val key = ref 0
                val firstExitFn = ref true

                fun atExit action =
                  if !exiting
                  then 0
                  else
                    (if !firstExitFn then 
	              (Deliver.exitFn := (fn () => (ignore(exit success); ()));
        	       firstExitFn := false)
           	     else ();
                     key := !key + 1;
        	     exitActions := (!key, action)::(!exitActions);
                     !key)

                fun removeAtExit key =
                  if !exiting then ()
                  else
                    let fun rem [] = []
                          | rem ((p as (key',_))::t) = 
                              if key = key' then t else p :: (rem t)
                     in exitActions := rem(!exitActions)
                    end
              end

            structure Debugger =
              struct
                fun default_break s = StandardIO.print("Break at " ^ s ^ "\n")
                val break_hook = ref default_break
                fun break s = (!break_hook) s
              end (* structure Debugger *)



	    structure Images =
	      struct
		exception Table of string
		val clean : unit -> unit = call_c "clean code vectors"
		val save = save
		val table : string -> string list = call_c "image table"
	      end (* structure Images *)

            structure Bits : BITS =
              struct
                open BuiltinLibrary_
              end (* structure Bits *)

            structure Word =
              struct
                open BuiltinLibrary_
        	
                val orb = word_orb
                val xorb = word_xorb
                val andb = word_andb
                val notb = word_notb
                val << = word_lshift
                val >> = word_rshift
                val ~>> = word_arshift
              end (* structure Word *)

            structure Word32 =
              struct
        	val word32_orb = word32_orb
        	val word32_xorb = word32_xorb
        	val word32_andb = word32_andb
        	val word32_notb = word32_notb
        	val word32_lshift = word32_lshift
        	val word32_rshift = word32_rshift
        	val word32_arshift = word32_arshift
	      end (* structure Word32 *)




            structure FloatArray: FLOATARRAY =
              struct
                type floatarray = BuiltinLibrary_.floatarray
                exception Range = BuiltinLibrary_.Range
                exception Size = BuiltinLibrary_.Size
                exception Subscript = BuiltinLibrary_.Subscript
		val array = BuiltinLibrary_.floatarray
		val length = BuiltinLibrary_.floatarray_length
		val update = BuiltinLibrary_.floatarray_update
		val unsafe_update = BuiltinLibrary_.floatarray_unsafe_update
		val sub = BuiltinLibrary_.floatarray_sub
		val unsafe_sub = BuiltinLibrary_.floatarray_unsafe_sub

		val maxLen = 1048575

		fun tabulate (l, f) =
		  let
		    val a = array (l, 0.0)

		    fun init n =
		      if n = l then a
		      else
			(unsafe_update (a, n, f n);
			 init (n+1))
		  in
		    init 0
		  end

		fun from_list list =
		  let
		    fun list_length (n, []) = n
		      | list_length (n, _::xs) = list_length (n+1, xs)

		    val new = array (list_length (0, list), 0.0)

		    fun fill (_, []) = new
		      | fill (n, x::xs) =
		      (unsafe_update (new, n, x);
		       fill (n+1, xs))
		  in
		    fill (0, list)
		  end

		val arrayoflist = from_list

		fun fill (a, x) =
		  let
		    fun fill' 0 = ()
		      | fill' n =
		      let
			val n' = n-1
		      in
			(unsafe_update (a, n', x);
			 fill' n')
		      end
		  in
		    fill' (length a)
		  end

		fun map f a =
		  let
		    val l = length a
		    val new = array (l, 0.0)

		    fun map' n =
		      if n = l then
			new
		      else
			(unsafe_update (new, n, f (unsafe_sub (a, n)));
			 map' (n+1))
		  in
		    map' 0
		  end

		fun map_index f a =
		  let
		    val l = length a
		    val new = array (l, 0.0)

		    fun map' n =
		      if n = l then
			new
		      else
			(unsafe_update (new, n, f (n, unsafe_sub (a, n)));
			 map' (n+1))
		  in
		    map' 0
		  end

		fun to_list a =
		  let
		    fun to_list' (0, list) = list
		      | to_list' (n, list) =
		      let
			val n' = n-1
		      in
			to_list' (n', unsafe_sub (a, n') :: list)
		      end
		  in
		    to_list' (length a, nil)
		  end

		fun iterate f a =
		  let
		    val l = length a

		    fun iterate' n =
		      if n = l then
			()
		      else
			(ignore(f (unsafe_sub (a, n)));
			 iterate' (n+1))
		  in
		    iterate' 0
		  end

		fun iterate_index f a =
		  let
		    val l = length a

		    fun iterate' n =
		      if n = l then
			()
		      else
			(ignore(f (n, unsafe_sub (a, n)));
			 iterate' (n+1))
		  in
		    iterate' 0
		  end

		fun rev a =
		  let
		    val l = length a
		    val new = array (l, 0.0)

		    fun rev' 0 = new
		      | rev' n =
		      let
			val n' = n-1
		      in
			(unsafe_update (new, n', unsafe_sub (a, l-n));
			 rev' n')
		      end
		  in
		    rev' l
		  end

		fun duplicate a =
		  let
		    val l = length a
		    val new = array (l, 0.0)

		    fun duplicate' 0 = new
		      | duplicate' n =
		      let
			val n' = n-1
		      in
			(unsafe_update (new, n', unsafe_sub (a, n'));
			 duplicate' n')
		      end
		  in
		    duplicate' l
		  end

		fun subarray (a, start, finish) =
		  let
		    val l = length a
		  in
		    if start < 0 orelse start > l orelse finish > l orelse
		      start > finish then
		      raise Subscript
		    else
		      let
			val l' = finish - start
			val new = array (l', 0.0)

			fun copy 0 = new
			  | copy n =
			  let
			    val n' = n-1
			  in
			    (unsafe_update (new, n', unsafe_sub (a, start+n'));
			     copy n')
			  end
		      in
			copy l'
		      end
		  end

		fun append (array1, array2) =
		  let
		    val l1 = length array1
		    val l2 = length array2
		    val new = array (l1+l2, 0.0)

		    fun copy1 0 = new
		      | copy1 n =
		      let
			val n' = n-1
		      in
			(unsafe_update (new, n', unsafe_sub (array1, n'));
			 copy1 n')
		      end

		    fun copy2 0 = copy1 l1
		      | copy2 n =
		      let
			val n' = n-1
		      in
			(unsafe_update (new, n'+l1, unsafe_sub (array2, n'));
			 copy2 n')
		      end
		  in
		    copy2 l2
		  end

		fun reducel f (i, a) =
		  let
		    val l = length a

		    fun reducel' (i, n) =
		      if n = l then
			i
		      else
			reducel' (f (i, unsafe_sub (a, n)), n+1)
		  in
		    reducel' (i, 0)
		  end

		fun reducer f (a, i) =
		  let
		    val l = length a

		    fun reducer' (0, i) = i
		      | reducer' (n, i) =
		      let
			val n' = n-1
		      in
			reducer' (n', f (unsafe_sub (a, n'), i))
		      end
		  in
		    reducer' (l, i)
		  end

		fun reducel_index f (i, a) =
		  let
		    val l = length a

		    fun reducel' (i, n) =
		      if n = l then
			i
		      else
			reducel' (f (n, i, unsafe_sub (a, n)), n+1)
		  in
		    reducel' (i, 0)
		  end

		fun reducer_index f (a, i) =
		  let
		    val l = length a

		    fun reducer' (0, i) = i
		      | reducer' (n, i) =
		      let
			val n' = n-1
		      in
			reducer' (n', f (n', unsafe_sub (a, n'), i))
		      end
		  in
		    reducer' (l, i)
		  end

		fun copy (from, start, finish, to, start') =
		  let
		    val l1 = length from
		    val l2 = length to
		  in
		    if start < 0 orelse start > l1 orelse finish > l1 orelse
		      start > finish orelse
		      start' < 0 orelse start' + finish - start > l2 then
		      raise Subscript
		    else
		      let
			fun copydown 0 = ()
			  | copydown n =
			  let
			    val n' = n-1
			  in
			    (unsafe_update (to, start'+n',
                                            unsafe_sub (from, start+n'));
			     copydown n')
			  end
			fun copyup i =
			  if i = finish then ()
			  else
			    (unsafe_update (to,i-start+start',
                                            unsafe_sub (from,i));
			     copyup (i + 1))
		      in
			if start < start'
			  then copydown (finish - start)
			else copyup start
		      end
		  end

	        fun fill_range (a, start, finish, x) =
                  let
                    val l = length a
                  in
                    if start < 0 orelse start > l orelse finish > l orelse
                      start > finish then
                      raise Subscript
                    else
                      let
                        fun fill' 0 = ()
                          | fill' n =
                          let
                            val n' = n-1
                          in
                            (unsafe_update (a, start+n', x);
                             fill' n')
                          end
                      in
                        fill' (finish - start)
                      end
                  end

                exception Find

                fun find predicate a =
                  let
                    val l = length a
                    fun find' n =
                      if n = l then
                        raise Find
                      else
                        if predicate (unsafe_sub (a, n)) then n
                        else find' (n+1)
                  in
                    find' 0
                  end

                fun find_default (predicate, default) a =
                  let
                    val l = length a
                    fun find' n =
                      if n = l then
                        default
                      else
                        if predicate (unsafe_sub (a, n)) then n
                        else find' (n+1)
                  in
                    find' 0
                  end

              end (* FloatArray *)



	    structure ByteArray : BYTEARRAY =
	      struct
		open BuiltinLibrary_
		exception Substring = Substring

		type bytearray = bytearray

		val maxLen = 16777196
		val array = BuiltinLibrary_.bytearray
		val length = BuiltinLibrary_.bytearray_length
		val update = BuiltinLibrary_.bytearray_update
		val unsafe_update = BuiltinLibrary_.bytearray_unsafe_update
		val sub = BuiltinLibrary_.bytearray_sub
		val unsafe_sub = BuiltinLibrary_.bytearray_unsafe_sub

		val to_string : bytearray -> string =
                                         call_c "bytearray to string"
		val from_string : string -> bytearray =
                                         call_c "bytearray from string"
		val substring : bytearray * int * int -> string =
                                         call_c "bytearray substring"

		fun tabulate (l, f) =
		  let
		    val a = array (l, 0)

		    fun init n =
		      if n = l then a
		      else
			(unsafe_update (a, n, f n);
			 init (n+1))
		  in
		    init 0
		  end

		fun from_list list =
		  let
		    fun list_length (n, []) = n
		      | list_length (n, _::xs) = list_length (n+1, xs)

		    val new = array (list_length (0, list), 0)

		    fun fill (_, []) = new
		      | fill (n, x::xs) =
		      (unsafe_update (new, n, x);
		       fill (n+1, xs))
		  in
		    fill (0, list)
		  end

		val arrayoflist = from_list

		fun fill (a, x) =
		  let
		    fun fill' 0 = ()
		      | fill' n =
		      let
			val n' = n-1
		      in
			(unsafe_update (a, n', x);
			 fill' n')
		      end
		  in
		    fill' (length a)
		  end

		fun map f a =
		  let
		    val l = length a
		    val new = array (l, 0)

		    fun map' n =
		      if n = l then
			new
		      else
			(unsafe_update (new, n, f (unsafe_sub (a, n)));
			 map' (n+1))
		  in
		    map' 0
		  end

		fun map_index f a =
		  let
		    val l = length a
		    val new = array (l, 0)

		    fun map' n =
		      if n = l then
			new
		      else
			(unsafe_update (new, n, f (n, unsafe_sub (a, n)));
			 map' (n+1))
		  in
		    map' 0
		  end

		fun to_list a =
		  let
		    fun to_list' (0, list) = list
		      | to_list' (n, list) =
		      let
			val n' = n-1
		      in
			to_list' (n', unsafe_sub (a, n') :: list)
		      end
		  in
		    to_list' (length a, nil)
		  end

		fun iterate f a =
		  let
		    val l = length a

		    fun iterate' n =
		      if n = l then
			()
		      else	
			(ignore(f (unsafe_sub (a, n)));
			 iterate' (n+1))
		  in
		    iterate' 0
		  end

		fun iterate_index f a =
		  let
		    val l = length a

		    fun iterate' n =
		      if n = l then
			()
		      else
			(ignore(f (n, unsafe_sub (a, n)));
			 iterate' (n+1))
		  in
		    iterate' 0
		  end

		fun rev a =
		  let
		    val l = length a
		    val new = array (l, 0)

		    fun rev' 0 = new
		      | rev' n =
		      let
			val n' = n-1
		      in
			(unsafe_update (new, n', unsafe_sub (a, l-n));
			 rev' n')
		      end
		  in
		    rev' l
		  end

		fun duplicate a =
		  let
		    val l = length a
		    val new = array (l, 0)

		    fun duplicate' 0 = new
		      | duplicate' n =
		      let
			val n' = n-1
		      in
			(unsafe_update (new, n', unsafe_sub (a, n'));
			 duplicate' n')
		      end
		  in
		    duplicate' l
		  end

		fun subarray (a, start, finish) =
		  let
		    val l = length a
		  in
		    if start < 0 orelse start > l orelse finish > l orelse
		      start > finish then
		      raise Subscript
		    else
		      let
			val l' = finish - start
			val new = array (l', 0)

			fun copy 0 = new
			  | copy n =
			  let
			    val n' = n-1
			  in
			    (unsafe_update (new, n', unsafe_sub (a, start+n'));
			     copy n')
			  end
		      in
			copy l'
		      end
		  end

		fun append (array1, array2) =
		  let
		    val l1 = length array1
		    val l2 = length array2
		    val new = array (l1+l2, 0)

		    fun copy1 0 = new
		      | copy1 n =
		      let
			val n' = n-1
		      in
			(unsafe_update (new, n', unsafe_sub (array1, n'));
			 copy1 n')
		      end

		    fun copy2 0 = copy1 l1
		      | copy2 n =
		      let
			val n' = n-1
		      in
			(unsafe_update (new, n'+l1, unsafe_sub (array2, n'));
			 copy2 n')
		      end
		  in
		    copy2 l2
		  end

		fun reducel f (i, a) =
		  let
		    val l = length a

		    fun reducel' (i, n) =
		      if n = l then
			i
		      else
			reducel' (f (i, unsafe_sub (a, n)), n+1)
		  in
		    reducel' (i, 0)
		  end

		fun reducer f (a, i) =
		  let
		    val l = length a

		    fun reducer' (0, i) = i
		      | reducer' (n, i) =
		      let
			val n' = n-1
		      in
			reducer' (n', f (unsafe_sub (a, n'), i))
		      end
		  in
		    reducer' (l, i)
		  end

		fun reducel_index f (i, a) =
		  let
		    val l = length a

		    fun reducel' (i, n) =
		      if n = l then
			i
		      else
			reducel' (f (n, i, unsafe_sub (a, n)), n+1)
		  in
		    reducel' (i, 0)
		  end

		fun reducer_index f (a, i) =
		  let
		    val l = length a

		    fun reducer' (0, i) = i
		      | reducer' (n, i) =
		      let
			val n' = n-1
		      in
			reducer' (n', f (n', unsafe_sub (a, n'), i))
		      end
		  in
		    reducer' (l, i)
		  end

		fun copy (from, start, finish, to, start') =
		  let
		    val l1 = length from
		    val l2 = length to
		  in
		    if start < 0 orelse start > l1 orelse finish > l1 orelse
		      start > finish orelse
		      start' < 0 orelse start' + finish - start > l2 then
		      raise Subscript
		    else
		      let
			fun copydown 0 = ()
			  | copydown n =
			  let
			    val n' = n-1
			  in
			    (unsafe_update (to, start'+n',
                                            unsafe_sub (from, start+n'));
			     copydown n')
			  end
			fun copyup i =
			  if i = finish then ()
			  else
			    (unsafe_update (to,i-start+start',
                                            unsafe_sub (from,i));
			     copyup (i + 1))
		      in
			if start < start'
			  then copydown (finish - start)
			else copyup start
		      end
		  end
(*
(* Old version for reference *)
(* This fails when copying a to a *)
	    fun copy (from, start, finish, to, start') =
	      let
		val l1 = length from
		val l2 = length to
	      in
		if start < 0 orelse start > l1 orelse finish > l1 orelse
		  start > finish orelse
		  start' < 0 orelse start' + finish - start > l2 then
		  raise Subscript
		else
		  let
		    fun copy' 0 = ()
		      | copy' n =
			let
			  val n' = n-1
			in
			  (unsafe_update (to, start'+n', unsafe_sub (from, start+n'));
			   copy' n')
			end
		  in
		    copy' (finish - start)
		  end
	      end
*)

	    fun fill_range (a, start, finish, x) =
	      let
		val l = length a
	      in
		if start < 0 orelse start > l orelse finish > l orelse
		  start > finish then
		  raise Subscript
		else
		  let
		    fun fill' 0 = ()
		      | fill' n =
			let
			  val n' = n-1
			in
			  (unsafe_update (a, start+n', x);
			   fill' n')
			end
		  in
		    fill' (finish - start)
		  end
	      end
	
	    exception Find

	    fun find predicate a =
	      let
		val l = length a
		fun find' n =
		  if n = l then
		    raise Find
		  else
		    if predicate (unsafe_sub (a, n)) then n else find' (n+1)
	      in
		find' 0
	      end

	    fun find_default (predicate, default) a =
	      let
		val l = length a
		fun find' n =
		  if n = l then
		    default
		  else
		    if predicate (unsafe_sub (a, n)) then n else find' (n+1)
	      in
		find' 0
	      end

	      end (* structure ByteArray *)

	    structure ExtendedArray : EXTENDED_ARRAY =
	      struct
		open BuiltinLibrary_

		type 'a array = 'a array

                val maxLen = 4194297 (* MAGIC NUMBER *)
		fun tabulate (l, f) =
		  let
		    val a = array (l, 0)

		    fun init n =
		      if n = l then a
		      else
			(unsafe_update (a, n, f n);
			 init (n+1))
		  in
		    init 0
		  end

		fun from_list list =
		  let
		    fun list_length (n, []) = n
		      | list_length (n, _::xs) = list_length (n+1, xs)

		    val new = array (list_length (0, list), 0)

		    fun fill (_, []) = new
		      | fill (n, x::xs) =
			(unsafe_update (new, n, x);
			 fill (n+1, xs))
		  in
		    fill (0, list)
		  end

		val arrayoflist = from_list

		fun fill (a, x) =
		  let
		    fun fill' 0 = ()
		      | fill' n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (a, n', x);
		       fill' n')
		    end
		  in
		    fill' (length a)
		  end

		fun map f a =
		  let
		    val l = length a
		    val new = array (l, 0)

		    fun map' n =
		      if n = l then
			new
		      else
			(unsafe_update (new, n, f (unsafe_sub (a, n)));
			 map' (n+1))
		  in
		    map' 0
		  end

		fun map_index f a =
		  let
		    val l = length a
		    val new = array (l, 0)

		    fun map' n =
		      if n = l then
			new
		      else
			(unsafe_update (new, n, f (n, unsafe_sub (a, n)));
			 map' (n+1))
		  in
		    map' 0
		  end

		fun to_list a =
		  let
		    fun to_list' (0, list) = list
		      | to_list' (n, list) =
			let
			  val n' = n-1
			in
			  to_list' (n', unsafe_sub (a, n') :: list)
			end
		  in
		    to_list' (length a, nil)
		  end

		fun iterate f a =
		  let
		    val l = length a

		    fun iterate' n =
		      if n = l then
			()
		      else
			(ignore(f (unsafe_sub (a, n)));
			 iterate' (n+1))
		  in
		    iterate' 0
		  end

		fun iterate_index f a =
		  let
		    val l = length a

		    fun iterate' n =
		      if n = l then
			()
		      else
			(ignore(f (n, unsafe_sub (a, n)));
			 iterate' (n+1))
		  in
		    iterate' 0
		  end

		fun rev a =
		  let
		    val l = length a
		    val new = array (l, 0)

		    fun rev' 0 = new
		      | rev' n =
			let
			  val n' = n-1
			in
			  (unsafe_update (new, n', unsafe_sub (a, l-n));
			   rev' n')
			end
		  in
		    rev' l
		  end

		fun duplicate a =
		  let
		    val l = length a
		    val new = array (l, 0)

		    fun duplicate' 0 = new
		      | duplicate' n =
			let
			  val n' = n-1
			in
			  (unsafe_update (new, n', unsafe_sub (a, n'));
			   duplicate' n')
			end
		  in
		    duplicate' l
		  end

		exception Subarray of int * int
		fun subarray (a, start, finish) =
		  let
		    val l = length a
		  in
		    if start < 0 orelse start > l orelse finish > l orelse
		      start > finish then
		      raise Subscript
		    else
		      let
			val l' = finish - start
			val new = array (l', 0)

			fun copy 0 = new
			  | copy n =
			    let
			      val n' = n-1
			    in
			      (unsafe_update (new, n', unsafe_sub (a, start+n'));
			       copy n')
			    end
		      in
			copy l'
		      end
		  end

		fun append (array1, array2) =
		  let
		    val l1 = length array1
		    val l2 = length array2
		    val new = array (l1+l2, 0)

		    fun copy1 0 = new
		      | copy1 n =
			let
			  val n' = n-1
			in
			  (unsafe_update (new, n', unsafe_sub (array1, n'));
			   copy1 n')
			end

		    fun copy2 0 = copy1 l1
		      | copy2 n =
			let
			  val n' = n-1
			in
			  (unsafe_update (new, n'+l1, unsafe_sub (array2, n'));
			   copy2 n')
			end
		  in
		    copy2 l2
		  end

		fun reducel f (i, a) =
		  let
		    val l = length a

		    fun reducel' (i, n) =
		      if n = l then
			i
		      else
			reducel' (f (i, unsafe_sub (a, n)), n+1)
		  in
		    reducel' (i, 0)
		  end

		fun reducer f (a, i) =
		  let
		    val l = length a

		    fun reducer' (0, i) = i
		      | reducer' (n, i) =
			let
			  val n' = n-1
			in
			  reducer' (n', f (unsafe_sub (a, n'), i))
			end
		  in
		    reducer' (l, i)
		  end

		fun reducel_index f (i, a) =
		  let
		    val l = length a

		    fun reducel' (i, n) =
		      if n = l then
			i
		      else
			reducel' (f (n, i, unsafe_sub (a, n)), n+1)
		  in
		    reducel' (i, 0)
		  end

		fun reducer_index f (a, i) =
		  let
		    val l = length a

		    fun reducer' (0, i) = i
		      | reducer' (n, i) =
			let
			  val n' = n-1
			in
			  reducer' (n', f (n', unsafe_sub (a, n'), i))
			end
		  in
		    reducer' (l, i)
		  end

		fun copy (from, start, finish, to, start') =
		  let
		    val l1 = length from
		    val l2 = length to
		  in
		    if start < 0 orelse start > l1 orelse finish > l1 orelse
		      start > finish orelse
		      start' < 0 orelse start' + finish - start > l2 then
		      raise Subscript
		    else
		      let
			fun copydown 0 = ()
			  | copydown n =
			    let
			      val n' = n-1
			    in
			      (unsafe_update (to, start'+n', unsafe_sub (from, start+n'));
			       copydown n')
			    end
                        fun copyup i =
                          if i = finish then ()
                          else
                            (unsafe_update (to,i-start+start',unsafe_sub (from,i));
                             copyup (i + 1))
		      in
                        if start < start'
                          then copydown (finish - start)
                        else copyup start
		      end
		  end

		fun fill_range (a, start, finish, x) =
		  let
		    val l = length a
		  in
		    if start < 0 orelse start > l orelse finish > l orelse
		      start > finish then
		      raise Subscript
		    else
		      let
			fun fill' 0 = ()
			  | fill' n =
			    let
			      val n' = n-1
			    in
			      (unsafe_update (a, start+n', x);
			       fill' n')
			    end
		      in
			fill' (finish - start)
		      end
		  end

		exception Find
		fun find predicate a =
		  let
		    val l = length a
		    fun find' n =
		      if n = l then
			raise Find
		      else
			if predicate (unsafe_sub (a, n)) then n else find' (n+1)
		  in
		    find' 0
		  end

		fun find_default (predicate, default) a =
		  let
		    val l = length a
		    fun find' n =
		      if n = l then
			default
		      else
			if predicate (unsafe_sub (a, n)) then n else find' (n+1)
		  in
		    find' 0
		  end

	      end (* structure ExtendedArray *)

	    structure Array : ARRAY = ExtendedArray

	    structure Vector : VECTOR =
	      struct
		open BuiltinLibrary_
		type 'a vector = 'a vector
                val maxLen = 4194299 (* MAGIC NUMBER *)
		fun length' ([],n) = n
		  | length' (a::b,n) = length' (b,unsafe_int_plus (n,1))
		fun length l = length' (l,0)
		fun update ([],n,v) = ()
		  | update (a::rest,n,v) =
		    (record_unsafe_update (v,n,a);
		     update (rest,unsafe_int_plus (n,1),v))
		
		(* This is going to override the definition in the builtin library *)
		fun vector (l : 'a list) : 'a vector =
		  let
		    val len = length l
		    val result = alloc_vector len
		    val _ = update (l,0,result)
		  in
		    result
		  end

		fun tabulate(i, f) =
		  if i < 0 then
		    raise Size
		  else
		    let
		      fun make_list(done, j) =
			if j >= i then done
			else
			  make_list(f j :: done, j+1)
		    in
		      vector (rev (make_list([], 0)))
		    end
		val sub = vector_sub
		val length = vector_length
	      end (* structure Vector *)

            structure Value =
              struct
                open BuiltinLibrary_
                type T = ml_value
                exception Value of string

                (* Many of these operations would be better implemented as *)
                (* built-in code. *)

                val cast = cast
                val ccast = fn x => call_c "value cast" x
                val list_to_tuple : ml_value list -> ml_value = call_c "value list to tuple"
                val tuple_to_list : ml_value -> ml_value list = call_c "value tuple to list"
                val string_to_real : string -> real = call_c "value string to real"
                val real_to_string : real -> string = call_c "value real to string"

                val real_equal : real * real -> bool = real_equal
                val arctan : real -> real = arctan
                val cos : real -> real = cos
                val exp : real -> real = exp
                val sin : real -> real = sin
                val sqrt : real -> real = sqrt

                val unsafe_plus = unsafe_int_plus
                val unsafe_minus = unsafe_int_minus

                val unsafe_array_sub = unsafe_sub
                val unsafe_array_update = unsafe_update

                val unsafe_bytearray_sub = bytearray_unsafe_sub
                val unsafe_bytearray_update = bytearray_unsafe_update

                val unsafe_floatarray_sub = floatarray_unsafe_sub
                val unsafe_floatarray_update = floatarray_unsafe_update

                val unsafe_record_sub = record_unsafe_sub
                val unsafe_record_update = record_unsafe_update

                val unsafe_string_sub = string_unsafe_sub
                val unsafe_string_update = string_unsafe_update

                val alloc_pair = alloc_pair
                val alloc_string = alloc_string
                val alloc_vector = alloc_vector

                (* This datatype is decoded in rts/pervasive/value.c.  You *)
                (* must update that if you change it. *)
                datatype print_options =
                  DEFAULT |
                  OPTIONS of {depth_max	  	: int,
                              string_length_max	: int,
                              indent		: bool,
                              tags		  	: bool}
                val print : print_options * T -> unit = call_c "value print"
                val primary : T -> int = call_c "value primary"
                val header : T -> int * int = call_c "value header"
                val pointer : T * int -> T = call_c "value pointer"
                val update : T * int * T -> unit = call_c "value update value"
                val sub : T * int -> T = call_c "value sub value"
                val update_byte : T * int * int -> unit = call_c "value update byte"
                val sub_byte : T * int -> int = call_c "value sub byte"
                val update_header : T * int * int -> unit = call_c "value update header"
                val code_name : ml_value -> string = call_c "value code name"
                val exn_name : exn -> string = call_c "value exn name"
                val exn_argument : exn -> T = call_c "value exn argument"

		fun update_exn_sub(exn1, exn2) =
		  (* Update the exception constructor unique in exn1 *)
		  (* with that in exn2 *)
		  (* Thus exn1 and exn2 become the same exception *)
		  (* though possibly with different exn_names *)
		  let
		    val constructor1 = unsafe_record_sub(exn1, 0)
		    val constructor2 = unsafe_record_sub(exn2, 0)
		    val unique = unsafe_record_sub(constructor2, 0)
		  in
		    unsafe_record_update(constructor1, 0, unique)
		  end
		fun update_exn(exn1, ref exn2) =
		  update_exn_sub(exn1, exn2)
		fun update_exn_cons(exn1_cons, ref exn2_cons) =
		  update_exn_sub(exn1_cons(cast 0), exn2_cons(cast 0))

                structure Frame =
                  struct
                    datatype frame = FRAME of int

                    val sub : frame * int -> ml_value = call_c "stack frame sub"
                    val update : frame * int * ml_value -> unit = call_c "stack frame update"
                    val current : unit -> frame = call_c "stack frame current"
                    val is_ml_frame : frame -> bool = call_c "stack is ml frame"

                    val frame_call = fn x => call_c "debugger frame call" x
                    val frame_next : frame -> (bool * frame * int) = call_c "debugger frame next"
                    val frame_offset = fn x => call_c "debugger frame offset" x
		    val frame_double = fn x => call_c "debugger frame double" x
                    val frame_allocations : frame -> bool = call_c "debugger frame allocations"
                  end (* structure Frame *)
              end (* structure Value *)

            structure Trace =
              struct
                exception Trace of string
                val intercept = fn x => call_c "trace intercept" x
                val replace = fn x => call_c "trace replace" x
                val restore = fn x => call_c "trace restore" x
		val restore_all : unit -> unit = call_c "trace restore all"
                (* NOTE: This datatype is implicitly understood by the *)
                (* runtime system.  Don't change the constructors without *)
                (* altering rts/pervasive/trace.c *)
                datatype status = INTERCEPT | NONE | REPLACE | UNTRACEABLE
                val status = fn x => call_c "trace status" x
              end (* structure Trace *)

            structure Dynamic =
              struct
                type dynamic = dynamic
                type type_rep = type_rep

                exception Coerce of type_rep * type_rep

                val generalises_ref : (type_rep * type_rep -> bool) ref =
                  ref (fn _ => false)

  		local
                  fun generalises data = (!generalises_ref) data

                  val get_type = Value.cast (fn (a,b) => b)
                  val get_value = Value.cast (fn (a,b) => a)
		in
                  fun coerce (d : dynamic, t:type_rep) : ml_value =
                    if generalises (get_type d,t) then
		      get_value d
                    else
		      raise Coerce(get_type d,t)
		end

              end (* structure Dynamic *)

	    structure Runtime =
	      struct
                exception Unbound of string
                val environment = call_c

                val modules : (string * ml_value * ml_value) list ref = call_c "system module root"

                structure Loader =
                  struct
                    exception Load of string
                    val load_module : string -> (string * ml_value) = call_c "system load link"
                    val load_wordset : int * {a_names : string list,
                                              b: {a_clos: int,
                                                  b_spills: int,
                                                  c_saves: int,
                                                  d_code : string} list,
                                              c_leafs : bool list,
                                              d_intercept : int list,
					      e_stack_parameters : int list} ->
		      (int * ml_value) list = call_c "system load wordset"
                  end (* structure Loader *)

		structure Memory =
		  struct
		    val max_stack_blocks : int ref = call_c "mem max stack blocks"
		    val gc_message_level : int ref = call_c "gc message level"
		    val collect : int -> unit = call_c "gc collect generation"
		    val collect_all : unit -> unit = call_c "gc collect all"
		    val promote_all : unit -> unit = call_c "gc promote all"
		    val collections : unit -> (int * int) = call_c "gc collections"
		  end (* structure Memory *)

                structure Event =
                  struct
                    datatype T = SIGNAL of int
                    exception Signal of string
                    val signal : int * (int -> unit) -> unit = call_c "event signal"

		    val stack_overflow_handler : (unit -> unit) -> unit = call_c "event signal stack overflow"
		    val interrupt_handler : (unit -> unit) -> unit = call_c "event signal interrupt"
                  end (* structure Event *)
              end (* structure Runtime *)

	  end (* structure Internal *)

	structure Threads =
	  struct
            exception Threads of string

	    datatype 'a result =
	      Running		(* still running *)
	    | Waiting		(* waiting *)
	    | Sleeping		(* sleeping *)
	    | Result of 'a	(* completed, with this result *)
	    | Exception of exn	(* exited with this uncaught exn *)
	    | Died		(* died (e.g. bus error) *)
	    | Killed		(* killed *)
	    | Expired		(* no longer exists (from a previous image) *)
	
	    datatype 'a thread =
	      Thread of Internal.Value.T result ref * int
	
	    local
	      val identity = Internal.Value.cast
	    in
              (* r is a number (see rts/src/threads.h) indicating
                 which state the thread is in.  One of these states,
                 THREAD_KILLED_SLEEPING(=8), is used purely to keep
                 the internal thread mechanism secure.  To the user
                 This state should appear to be just THREAD_KILLED(=3).*)

	      fun result (Thread (r,i)) =
                Internal.Value.cast(
                let val y = Internal.Value.cast (!r)
                in if y=8 then 3 else y
                end)
		
	      val c_fork = (fn x => call_c "thread fork" x) : (unit -> 'b) -> 'b thread
		
	      fun fork (f : 'a -> 'b) a = c_fork (fn () => f a)
		
	      val yield = (call_c "thread yield") : unit -> unit

	      val sleep = (fn x => call_c "thread sleep" x) : 'a thread -> unit
	      val wake  = (fn x => call_c "thread wake" x)  : 'a thread -> unit


	      structure Internal =
		struct
		  type thread_id = unit thread
		
		  val id = fn x => call_c "thread current thread" x
		  fun get_id t = (identity t) : thread_id
		  val children = fn x => call_c "thread children" x
		  val parent = fn x => call_c "thread parent" x
		  val all = fn x => call_c "thread all threads" x
		
		  val kill = fn x => call_c "thread kill" x
		  val raise_in = fn x => call_c "thread raise" x
		  val yield_to = fn x => call_c "thread yield to" x
		  val set_handler = fn x => call_c "thread set fatal handler" x
		
		  val reset_fatal_status = fn x => call_c "thread reset fatal status" x

		  val get_num = fn x => call_c "thread number" x
		  fun state t =
		    case (result t) of
		      Running => Running
		    | Waiting => Waiting
		    | Sleeping => Sleeping
		    | Result _ => Result ()
		    | Exception e => Exception e
		    | Died => Died
		    | Killed => Killed
		    | Expired => Expired
			
		  structure Preemption =
		    struct
		      val start : unit -> unit
                        = call_c "thread start preemption"
		      val stop : unit -> unit
                        = fn () =>
                            let val s: unit->unit =
                              call_c "thread stop preemption"
                            in #access(Internal.StandardIO.currentIO()) s
                            end
                     (* see <URI:spring://ML_Notebook/Design/GUI/Mutexes> for
                        an explanation *)

		      val on : unit -> bool
                        = call_c "thread preempting"
		      val get_interval : unit -> int
                        = call_c "thread get preemption interval"
		      val set_interval : int -> unit
                        = call_c "thread set preemption interval"
                      val enter_critical_section : unit -> unit
                        = call_c "thread start critical section"
                      val exit_critical_section : unit -> unit
                        = call_c "thread stop critical section"
                      val in_critical_section: unit -> bool
                        = call_c "thread critical"
		    end (* structure Preemption *)
		end (* structure Internal *)
	    end (* local *)
	  end (* structure Threads *)

        structure Profile =
          struct
	    type manner = int
	    type function_id = string
	    type cost_centre_profile = unit
	
	    datatype object_kind =
	      RECORD
	    | PAIR
	    | CLOSURE
	    | STRING
	    | ARRAY
	    | BYTEARRAY
	    | OTHER		(* includes weak arrays, code objects *)
	    | TOTAL		(* used when specifying a profiling manner *)
	
	    datatype large_size =
	      Large_Size of
	      {megabytes : int,
	       bytes : int}	
	
	    datatype object_count =
	      Object_Count of
	      {number : int,
	       size : large_size,
	       overhead : int}
	
	    type object_breakdown = (object_kind * object_count) list
	
	    datatype function_space_profile =
	      Function_Space_Profile of
	      {allocated : large_size,	
	       copied : large_size,		
	       copies : large_size list,
	       allocation : object_breakdown list}
	
	    datatype function_caller =
	      Function_Caller of
	      {id: function_id,
	       found: int,
	       top: int,
	       scans: int,
	       callers: function_caller list}
	
	    datatype function_time_profile =
	      Function_Time_Profile of
	      {found: int,
	       top: int,
	       scans: int,
	       depth: int,
	       self: int,
	       callers: function_caller list}
	
	    datatype function_profile =
	      Function_Profile of
	      {id: function_id,
	       call_count: int,
	       time: function_time_profile,
	       space: function_space_profile}
	
	    datatype general_header =
	      General of
	      {data_allocated: int,
	       period: Internal.Types.time,
	       suspended: Internal.Types.time}
	
	    datatype call_header =
	      Call of {functions : int}
	
	    datatype time_header =
	      Time of
	      {data_allocated: int,
	       functions: int,
	       scans: int,
	       gc_ticks: int,
	       profile_ticks: int,
	       frames: real,
	       ml_frames: real,
	       max_ml_stack_depth: int}
	
	    datatype space_header =
	      Space of
	      {data_allocated: int,
	       functions: int,
	       collections: int,
	       total_profiled : function_space_profile}
	
	    type cost_header = unit
	
	    datatype profile =
	      Profile of
	      {general: general_header,
	       call: call_header,
	       time: time_header,
	       space: space_header,
	       cost: cost_header,
	       functions: function_profile list,
	       centres: cost_centre_profile list}
	
	    datatype options =
	      Options of
	      {scan : int,
	       selector : function_id -> manner}
	
	    datatype 'a result =
	      Result of 'a
	    | Exception of exn

	    exception ProfileError of string

	    local
	      val rts_profile = (fn x => call_c "profile" x) :
		int * (string->int) * (unit->'b) -> ('b * profile)
	    in
	      fun profile (Options {scan, selector}) f a =
		let
		  fun wrapper () = (Result (f a)) handle e => Exception e
		  fun sel x = selector x handle _ => 0
		in
		  rts_profile (scan, sel, wrapper)
		end
	    end

	    local
	      fun manner_object ARRAY = 1
		| manner_object BYTEARRAY = 2
		| manner_object CLOSURE = 4
		| manner_object OTHER = 8
		| manner_object PAIR = 16
		| manner_object RECORD = 32
		| manner_object STRING = 64
		| manner_object TOTAL = 128

	      fun breakdown_manner [] = 0
		| breakdown_manner (x::xs) =
		  Internal.Bits.orb(manner_object x,breakdown_manner xs)
	    in
	
	      fun make_manner {time, space, copies, calls, depth, breakdown} =
		(if calls then 1 else 0) +
		(if time then 2 else 0) +
		(if space then 4 else 0) +
		(if copies then 8 else 0) +
                   Internal.Bits.lshift(depth,16) +
                   Internal.Bits.lshift(breakdown_manner breakdown, 8)
	    end (* local *)
			
          end (* structure Profile *)

	(*
	structure Char : CHAR =
	  struct
	    open BuiltinLibrary_

	    type char = char
	    val chr = char_chr
	    val ord = char_ord
	    val maxCharOrd = 255

	    (* Finally define these *)
	    val op <  : char * char -> bool = op <
	    val op >  : char * char -> bool = op >
	    val op <= : char * char -> bool = op <=
	    val op >= : char * char -> bool = op >=
	  end
	*)

      end (* structure MLWorks *)

    local
      val exns_initialised =            call_c "exception exns_initialised"
      val SizeExn =                     call_c "exception Size"
      val DivExn =			call_c "exception Div"
      val OverflowExn =			call_c "exception Overflow"
      val ProfileExn =			call_c "exception Profile"
      val SaveExn =			call_c "exception Save"
      val LoadExn =			call_c "exception Load"
      val SignalExn =			call_c "exception Signal"
      val StringToRealExn = 		call_c "exception StringToReal"
      val SubstringExn =		call_c "exception Substring"
      val SysErrExn =                   call_c "exception syserr"
      val TraceExn =			call_c "exception Trace"
      val UnboundExn =			call_c "exception Unbound"
      val ValueExn =			call_c "exception Value"
      val ThreadsExn =                  call_c "exception Threads"
    in
      val _ =
        if !exns_initialised then ()
        else
          (exns_initialised := true;
           SizeExn              := Size;
           DivExn		:= Div;
           LoadExn		:= MLWorks.Internal.Runtime.Loader.Load "";
           OverflowExn		:= Overflow;
           ProfileExn		:= MLWorks.Profile.ProfileError "";
           SaveExn		:= MLWorks.Internal.Save "";
           SignalExn		:= MLWorks.Internal.Runtime.Event.Signal "";
           StringToRealExn	:= MLWorks.Internal.StringToReal;
           SubstringExn		:= MLWorks.String.Substring;
           SysErrExn            := MLWorks.Internal.Error.SysErr ("",MLWorks.Internal.Types.NONE);
           TraceExn		:= MLWorks.Internal.Trace.Trace "";
           UnboundExn		:= MLWorks.Internal.Runtime.Unbound "";
           ValueExn		:= MLWorks.Internal.Value.Value "";
           ThreadsExn           := MLWorks.Threads.Threads "")
    end (* local *)

    (* some more top-level maths functions *)

    val ceil : real -> int = ~ o floor o ~
    val trunc: real -> int = fn x => if x>0.0 then floor x else ceil x
    val round: real -> int = fn x=>
      let
	val near = floor x
	val diff = abs(real near - x)
      in
	if diff < 0.5 then
	  near
	else
	  if diff > 0.5 orelse near mod 2 = 1
	    then near + 1
	  else near
      end


    (* some more top-level string functions *)

    val maxSize = MLWorks.String.maxLen

    fun unsafe_alloc_string (n:int) : string =
      let val alloc_s = alloc_string n
      in
	string_unsafe_update (alloc_s, n-1, 0);
	alloc_s
      end
    fun alloc_string (n:int) : string =
      if n > maxSize then
	raise Size
      else
	unsafe_alloc_string n
	
    fun implode (cl : char list) : string =
      let
	val cl : int list = cast cl
	fun copyall ([],start,to) = to
	  | copyall (c::cl,start,to) =
	  (string_unsafe_update (to,start, c);
	   copyall (cl,start+1,to))
	fun get_size (a::rest,sz) = get_size (rest,1 + sz)
	  | get_size ([],sz) =
	  if sz > 30 then call_c "string c implode char" (cl,sz)
	  else
	    let
	      val result = unsafe_alloc_string (sz+1)
	      (* set the null terminator *)
	      val _ = string_unsafe_update (result,sz,0)
	    in
	      copyall (cl,0,result)
	    end
      in
	get_size (cl,0)
      end

    (*NB concat is old-style string implode*)
    fun concat [] = ""
      | concat xs = call_c "string implode" xs

    fun str (c:char) : string =
      let val alloc_s = unsafe_alloc_string (1+1)
      in
	string_unsafe_update(alloc_s, 0, (cast c):int);
	alloc_s
      end

    fun explode (s:string) : char list =
      let fun aux (i, acc) =
	  if i >= 0 then
	    aux (i-1, (cast (string_unsafe_sub(s, i)):char)::acc)
	  else
	    acc
      in
	aux (size s -1, [])
      end


    fun substring (s, i, n) =
      if i < 0 orelse n < 0 orelse (size s - i) < n then raise Subscript
      else if n <= 12 then
	let
	  val alloc_s = unsafe_alloc_string (n+1)
	  fun copy i' =
	    if i' < 0 then alloc_s
	    else
	      (string_unsafe_update (alloc_s, i', string_unsafe_sub (s, i+i'));
	       copy (i'-1))
	in
	  copy (n-1)
	end
	   else (* n > 12 *)
	     call_c "string unsafe substring" (s, i, n)

    datatype option = datatype MLWorks.Internal.Types.option

    exception Option

    fun isSome (SOME _) = true | isSome _ = false

    fun valOf (SOME x) = x | valOf NONE = raise Option

    fun getOpt (NONE, d) = d
      | getOpt ((SOME x), _) = x

    structure General : GENERAL =
      struct

        open BuiltinLibrary_

        type exn = exn
        type unit = unit

        exception Domain
        exception Fail of string
        exception Empty

        datatype order = LESS | EQUAL | GREATER

        fun exnName e =
          let val full_name = MLWorks.Internal.Value.exn_name e
              fun split [] = []
                | split ("[" :: _) = []
                | split (h :: t) = h :: (split t)
           in implode(split(explode full_name)) end;

        fun exnMessage (MLWorks.Internal.Error.SysErr(s, NONE)) =
                "SysErr: " ^ s
          | exnMessage (MLWorks.Internal.Error.SysErr(s, SOME n)) =
                "SysErr: " ^ (MLWorks.Internal.Error.errorMsg n)
          | exnMessage (Fail s) =
                "Fail: " ^ s
          | exnMessage (MLWorks.Internal.IO.Io {name,function,cause}) =
                "Io: " ^ function ^ " failed on file " ^ name ^ " with "
                ^ exnMessage cause
          | exnMessage e = exnName e


        val (op<>) : ''a * ''a -> bool = (op<>)
        val (op :=) : ('a ref * 'a) -> unit = (op :=)
        val ignore : 'a -> unit = fn (_) => ()

        fun (x before _) = x      (* before is given infix status by
                                     the parser. *)
      end (* structure General *)

    open General

    (* some more top-level list functions *)
	
    fun null [] = true
      | null _ = false

    fun hd [] = raise Empty
      | hd (a::_) = a

    fun tl [] = raise Empty
      | tl (_::a) = a

    fun length l =
      let
	fun loop ([], acc) = acc
	  | loop (_::t, acc) = loop (t, 1+acc)
      in
	loop (l, 0)
      end


    fun app f [] = ()
      | app f (h :: t) = (ignore(f h); app f t)

    fun foldl f i list =
      let
	fun red (acc, []) = acc
	  | red (acc, (x::xs)) = red (f (x, acc), xs)
      in
	red (i, list)
      end


    fun foldr f i list =
      let
	fun red (acc, []) = acc
	  | red (acc, x::xs) = red (f (x,acc), xs)
      in
	red (i, rev list)
      end

    val print = MLWorks.Internal.StandardIO.print
    val vector = MLWorks.Internal.Vector.vector

  end (* structure FullPervasiveLibrary_ *)

open FullPervasiveLibrary_;

@


1.227
log
@[Bug #190523]
Changed the underlying type of OS.Process.status.
@
text
@d13 4
a1387 5
          val uncaughtIOException : status
          val badUsage : status
          val stop : status
          val save : status
          val badInput : status
a1952 5
                val uncaughtIOException : status = 0w2
                val badUsage : status = 0w3
                val stop : status = 0w4
                val save : status = 0w5
                val badInput : status = 0w6
@


1.227.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 4
 * Revision 1.227  1999/03/11  17:13:38  daveb
 * [Bug #190523]
 * Changed the underlying type of OS.Process.status.
 *
@


1.226
log
@[Bug #20122]
Move pervasive signatures into __pervasive_library.sml
@
text
@d13 4
d1381 1
a1381 1
          type status = int
d1951 8
a1958 8
                type status = int
                val success : status = 0
                val failure : status = 1
                val uncaughtIOException : status = 2
                val badUsage : status = 3
                val stop : status = 4
                val save : status = 5
                val badInput : status = 6
d1993 1
a1993 1
	              (Deliver.exitFn := (fn () => (ignore(exit 0); ()));
@


1.225
log
@[Bug #30413]
Move Exit structure to pervasives
@
text
@d13 4
d776 742
a1517 8
require " mlworks";
require " string";
require " array";
require " vector";
require " bytearray";
require " floatarray";
require " bits";
require " general";
@


1.224
log
@[Bug #30090]
Remove MLWorks.IO and RawIO
@
text
@d13 4
d963 2
a964 1
	structure Deliver =
d977 3
d1206 51
d1258 9
@


1.223
log
@[Bug #30090]
Remove almost all of MLWorks.IO
@
text
@d13 4
a958 30




	structure RawIO =
	  struct
            open BuiltinLibrary_

            datatype instream = INSTREAM of ml_value
            datatype outstream = OUTSTREAM of ml_value

            val std_in = call_c "stream std_in"
            val std_out = call_c "stream std_out"
            val std_err = call_c "stream std_err"
            val lookahead = call_c "stream lookahead"
            val open_in : string -> instream = call_c "stream open in"
            val open_out : string -> outstream = call_c "stream open out"
            val input = call_c "stream input string"
	    val clear_eof = call_c "stream clear eof"
            val output = call_c "stream output string"
	    val output_byte = call_c "stream output byte"
            val close_in = call_c "stream close in"
            val close_out = call_c "stream close out"
            fun end_of_stream s = lookahead s = ""
	    val flush_out = call_c "stream flush out"
	    val closed_in = call_c "stream closed"
	    val closed_out = call_c "stream closed"

	  end (* structure RawIO *)

a1001 6

        structure IO =
          struct
	    exception Io of string
          end (* structure IO *)

a2840 1
      val IoExn =			call_c "exception Io"
a2859 1
           IoExn		:= MLWorks.IO.Io "";
@


1.222
log
@[Bug #70076]
Fix exnName so it only returns name of exception, not location info
@
text
@d13 4
a1031 174

            datatype RigidInStream =
              RIGIDINSTREAM of {input		: int -> string,
                                lookahead		: unit -> string,
                                end_of_stream	: unit -> bool,
                                clear_eof		: unit -> unit,
                                close_in		: unit -> unit,
				closed_in               : unit -> bool}
            datatype FlexInStream =
              FLEXINSTREAM of RigidInStream ref

            datatype instream =
              RIGIDIN of RigidInStream
            | FLEXIN of FlexInStream

            fun instream stream_data =
              RIGIDIN (RIGIDINSTREAM stream_data)

            fun open_in string =
              let
                val raw_instream = RawIO.open_in string
              in
                instream {input =	  fn int => RawIO.input (raw_instream, int),
                          lookahead =	  fn ()  => RawIO.lookahead raw_instream,
                          end_of_stream = fn ()  => RawIO.end_of_stream raw_instream,
                          clear_eof =	  fn ()  => RawIO.clear_eof raw_instream,
                          close_in =	  fn ()  => RawIO.close_in raw_instream,
			  closed_in =     fn ()  => RawIO.closed_in raw_instream}
              end

            fun get_rigid_instream (RIGIDIN s) = s
              | get_rigid_instream (FLEXIN (FLEXINSTREAM (ref s))) = s

            fun rigid_end_of_stream (RIGIDINSTREAM {end_of_stream, ...}) = end_of_stream ()
            fun rigid_input (RIGIDINSTREAM  {input, ...}, n) = input n
            fun rigid_clear_eof (RIGIDINSTREAM  {clear_eof, ...}) = clear_eof ()
            fun rigid_lookahead (RIGIDINSTREAM  {lookahead, ...}) = lookahead ()
            fun rigid_close_in (RIGIDINSTREAM  {close_in, ...}) = close_in ()
	    fun rigid_closed_in (RIGIDINSTREAM {closed_in, ...}) = closed_in ()

            fun end_of_stream s = rigid_end_of_stream (get_rigid_instream s)
            fun input (s,n) = rigid_input (get_rigid_instream s, n)
            fun clear_eof s = rigid_clear_eof (get_rigid_instream s)
            fun lookahead s = rigid_lookahead (get_rigid_instream s)
            fun close_in s = rigid_close_in (get_rigid_instream s)
	    fun closed_in s = rigid_closed_in (get_rigid_instream s)

            fun mkFlexInStream s = FLEXIN (FLEXINSTREAM (ref (get_rigid_instream s)))

            val terminal_in =
		instream {input =	          fn int => RawIO.input (RawIO.std_in, int),
			  lookahead =	          fn ()  => RawIO.lookahead RawIO.std_in,
			  end_of_stream =         fn ()  => RawIO.end_of_stream RawIO.std_in,
			  clear_eof =	          fn ()  => RawIO.clear_eof RawIO.std_in,
			  close_in =	          fn ()  => raise Io "<Cannot close std_in>",
			  closed_in =             fn () => false}

            exception GetFlexInStream
            fun getflexinstream (FLEXIN fstr) = fstr
              | getflexinstream _ = raise GetFlexInStream

            val std_in = mkFlexInStream terminal_in

            val flex_std_in = getflexinstream std_in

            fun with_input (FLEXINSTREAM refstream) stream f =
              let
                val oldstream = (!refstream)
                val _ = refstream := get_rigid_instream stream
                val result = f () handle exn => (refstream := oldstream; raise exn)
              in
                refstream := oldstream;
                result
              end

            val with_standard_input = fn x => with_input flex_std_in x

	    fun input_line file =
	      let
		fun extend_line line =
                  let
                    val char = input(file, 1)
                  in
                    if char = "" then implode(rev line)
                    else if char = "\n" then implode(rev("\n" :: line))
                    else extend_line(char :: line)
                  end
	      in
		extend_line []
	      end

            datatype RigidOutStream =
              RIGIDOUTSTREAM of {output	: string -> unit,
				 flush_out	: unit -> unit,
				 close_out	: unit -> unit,
				 closed_out     : unit -> bool}

            datatype FlexOutStream =
              FLEXOUTSTREAM of RigidOutStream ref

            datatype outstream =
              RIGIDOUT of RigidOutStream
            | FLEXOUT of FlexOutStream

            fun outstream stream_data =
              RIGIDOUT (RIGIDOUTSTREAM stream_data)

            fun open_out string =
              let
                val raw_outstream = RawIO.open_out string
              in
                outstream {output =	fn string => RawIO.output (raw_outstream, string),
                           flush_out =	fn ()     => RawIO.flush_out raw_outstream,
                           close_out =	fn ()     => RawIO.close_out raw_outstream,
			   closed_out = fn ()     => RawIO.closed_out raw_outstream}
              end


            fun get_rigid_outstream (RIGIDOUT s) = s
              | get_rigid_outstream (FLEXOUT (FLEXOUTSTREAM (ref s))) = s

            fun mkFlexOutStream s = FLEXOUT (FLEXOUTSTREAM (ref (get_rigid_outstream s)))

            fun rigid_output (RIGIDOUTSTREAM {output, ...}, string) = output string
            fun rigid_flush_out (RIGIDOUTSTREAM  {flush_out, ...}) = flush_out ()
            fun rigid_close_out (RIGIDOUTSTREAM  {close_out, ...}) = close_out ()
	    fun rigid_closed_out (RIGIDOUTSTREAM {closed_out,...}) = closed_out ()

            fun output (stream,string) = rigid_output (get_rigid_outstream stream, string)
            fun flush_out stream = rigid_flush_out (get_rigid_outstream stream)
            fun close_out stream = rigid_close_out (get_rigid_outstream stream)
	    fun closed_out stream = rigid_closed_out (get_rigid_outstream stream)

            fun with_output (FLEXOUTSTREAM refstream) stream f =
              let
                val oldstream = (!refstream)
                val _ = refstream := get_rigid_outstream stream
                val result = f () handle exn => (flush_out stream;
                                                 refstream := oldstream;
                                                 raise exn)
              in
                flush_out stream;
                refstream := oldstream;
                result
              end

            val terminal_out =
	      outstream {output = fn s => RawIO.output(RawIO.std_out,s),
			 flush_out = fn () => RawIO.flush_out RawIO.std_out,
			 close_out = fn () => raise Io "Cannot close std_out",
			 closed_out = fn () => false}

            exception GetFlexOutStream
            fun getflexoutstream (FLEXOUT fstr) = fstr
              | getflexoutstream _ = raise GetFlexOutStream

            val std_out = mkFlexOutStream terminal_out

            val flex_std_out = getflexoutstream std_out

            val with_standard_output = fn x => with_output flex_std_out x

            val terminal_err =
	      outstream {output = fn s => RawIO.output(RawIO.std_err,s),
			 flush_out = fn () => RawIO.flush_out RawIO.std_err,
			 close_out = fn () => raise Io "Cannot close std_err",
			 closed_out = fn () => false}

            val std_err = mkFlexOutStream terminal_err

            val flex_std_err = getflexoutstream std_err

            val with_standard_error = fn x => with_output flex_std_err x

a1061 9
            structure Debugger =
              struct
                fun default_break s = IO.output(IO.std_out,"Break at " ^ s ^ "\n")
                val break_hook = ref default_break
                fun break s = (!break_hook) s
              end (* structure Debugger *)



d1229 9
@


1.221
log
@[Bug #30349]
Warn when lhs of semicolon does not have type unit
@
text
@d13 4
d3197 6
a3202 1
        val exnName = MLWorks.Internal.Value.exn_name
@


1.220
log
@[Bug #70065]
Remove uses of MLWorks.IO.messages and use the Messages structure
@
text
@d13 4
d832 2
d1007 1
a1007 1
			old_deliverer (s, fn () => (f(); (!exitFn) ()), b) )
d1362 1
a1362 1
                                          (fn i => (IO.seek (!stdOut,i,0);())),
d1375 1
a1375 1
                                     (fn i => (IO.seek(!stdErr,i,0); ())),
d1383 1
a1383 1
                                            (fn i => (IO.seek(!stdIn,i,0);())),
d1397 4
a1400 4
                  fun print s = (#put(#output(currentIO()))
                                  {buf=s,i=0,sz=Types.NONE};())
                  fun printError s = (#put(#error(currentIO()))
                                      {buf=s,i=0,sz=Types.NONE};())
d1557 1
a1557 1
			(f (unsafe_sub (a, n));
d1571 1
a1571 1
			(f (n, unsafe_sub (a, n));
d1922 2
a1923 2
		      else
			(f (unsafe_sub (a, n));
d1937 1
a1937 1
			(f (n, unsafe_sub (a, n));
d2297 1
a2297 1
			(f (unsafe_sub (a, n));
d2311 1
a2311 1
			(f (n, unsafe_sub (a, n));
d3238 1
a3238 1
      | app f (h :: t) = (f h; app f t)
@


1.219
log
@[Bug #30134]
Change meaning of third arg of deliver and convert to datatype.
@
text
@d13 4
a1167 7
			 closed_out = fn () => false}

	    val messages =
	      outstream {output = call_c "stream message output",
			 flush_out = call_c "stream message flush",
			 close_out = fn () =>
                                 raise Io "Cannot close messages stream",
@


1.218
log
@[Bug #30089]
Further work on getting rid of MLWorks.Time
Also removing {set_,}file_modified
@
text
@d13 5
d969 4
a972 1
	    type deliverer = string * (unit -> unit) * bool -> unit
@


1.217
log
@[Bug #30204]
Add update_exn and update_exn_cons
@
text
@d13 4
d727 1
a727 1
 *  
d730 1
a730 1
 *  
d734 1
a734 1
 *  
d737 1
a737 1
 *  
d800 1
a800 1
      
d805 1
a805 1
  end 
d830 1
a830 1
	      
d858 1
a858 1
            val c_implode_char : int list * int -> string = 
d871 1
a871 1
                  | get_size ([],sz) = 
d888 1
a888 1
                val (s,abbrev) = 
d898 1
a898 1
		      case char of 
d942 1
a942 1
              
a961 93
        structure Time =
          struct
            structure Interval =
              struct
                datatype T = INTERVAL of ml_value

		val to_real : T -> real = call_c "interval to real"
		val from_real : real -> T = call_c "interval from real"

		(* can use time add, time sub, and time less because
		 * our time and interval representations happen to be
		 * the same *)

		val op- : T * T -> T = call_c "time subtract"
		val op+ : T * T -> T = call_c "time add"
		val op< : T * T -> bool = call_c "time less"

		val real_mul = op* : real*real->real
		val real_div = op/ : real*real->real

		fun x*y = from_real(real_mul((to_real x),y))
		fun x/y = from_real(real_div((to_real x),y))

		val c_format = call_c "time to string"
		val decimal_places = ref 2
		fun format x = c_format (x,!decimal_places)
	      end (* structure Interval *)
	    
	    structure Elapsed =
	      struct
		datatype T = ELAPSED of {real: Interval.T,
					 user: Interval.T,
					 system: Interval.T,
					 gc: Interval.T}
		  
		val elapsed : unit -> T = call_c "time elapsed"
		val elapsed_since : T -> T = call_c "time elapsed since"

		fun project_interval_fn f (ELAPSED{real=real1,
						   user=user1,
						   system=sys1,
						   gc = gc1},
					   ELAPSED{real=real2,
						   user=user2,
						   system=sys2,
						   gc = gc2})
		  = ELAPSED {real = f(real1,real2),
			     user = f(user1,user2),
			     system = f(sys1,sys2),
			     gc = f (gc1,gc2)}
		  
		val op- = project_interval_fn (Interval.-)
		val op+ = project_interval_fn (Interval.+)
		  
		fun project_interval_real_fn f (ELAPSED{real,user,system,gc},
						x) =
		  ELAPSED{real= f(real,x),
			  user = f(user,x),
			  system = f(system,x),
			  gc = f(gc,x)}

		val op* = project_interval_real_fn (Interval.* )
		val op/ = project_interval_real_fn (Interval./ )

		fun format (ELAPSED {real,user,system,gc}) =
		  implode [Interval.format real,
			   " (user: ",
			   Interval.format user,
			   ", system: ",
			   Interval.format system,
			   ", gc: ",
			   Interval.format gc, ")"]

	      end (* structure Elapsed *)

	    datatype time = TIME of ml_value

	    val zero : time = call_c "time zero"
	    val now : unit -> time = call_c "time now"
	    val op< : time * time -> bool = call_c "time less"

	    val interval : time * time -> Interval.T = call_c "time interval"

	    val (op-) : time * Interval.T -> time = call_c "time subtract"
	    val (op+) : time * Interval.T -> time = call_c "time add"

	    datatype zone = GREENWICH | LOCAL
	    val format : string * zone * time -> string = call_c "time format"

	    val encode : time -> string = call_c "time encode"
	    val decode : string -> time = call_c "time decode"
	  end (* structure Time *)

d987 2
a988 2
		  val deliverer = 
		    (fn (s, f, b) => 
d1035 1
a1035 1
            
d1052 1
a1052 1
              
d1123 1
a1123 1
            
d1138 1
a1138 1
              
d1143 1
a1143 1
                val result = f () handle exn => (flush_out stream; 
d1147 1
a1147 1
                flush_out stream; 
d1158 1
a1158 1
	    val messages = 
d1161 1
a1161 1
			 close_out = fn () => 
a1186 10
            val file_modified : string -> Time.time =
              call_c "time file modified"

            (* This datatype is decoded in rts/pervasive/time.c.  You *)
            (* must update that if you change it. *)
	    datatype modtime = NOW | TIME of Time.time

            val set_file_modified : string * modtime -> unit = 
              call_c "time set file modified"

d1203 1
d1239 1
a1239 1
                val syserror  : string -> syserror Types.option 
d1245 1
a1245 1
            (* IO provides some features that are needed to primarily to 
d1329 2
a1330 2
                local 
                  val stdIn: IO.file_desc ref = 
a1335 1
                    
d1337 2
a1338 1
                  val terminalIO : IOData = 
d1341 1
a1341 1
                             put=fn {buf,i,sz=Types.NONE} => 
d1345 1
a1345 1
                             get_pos = Types.SOME(fn () => 
d1356 1
a1356 1
                             put=fn {buf,i,sz=Types.NONE} => 
d1383 1
a1383 1
                  fun redirectIO (newIO:IOData) = 
d1421 1
a1421 1
        
d1724 1
a1724 1
			    (unsafe_update (to, start'+n', 
d1762 1
a1762 1
                
d1772 1
a1772 1
                        if predicate (unsafe_sub (a, n)) then n 
d1777 1
a1777 1
                
d1785 1
a1785 1
                        if predicate (unsafe_sub (a, n)) then n 
d1790 1
a1790 1
                
d1812 1
a1812 1
		val from_string : string -> bytearray = 
d1814 1
a1814 1
		val substring : bytearray * int * int -> string = 
d2090 1
a2090 1
			    (unsafe_update (to, start'+n', 
d2155 1
a2155 1
	    
d2470 1
a2470 1
                          else 
d2540 1
a2540 1
		  | update (a::rest,n,v) = 
d2543 1
a2543 1
		    
d2595 1
a2595 1
                  
d2653 1
a2653 1
                structure Frame = 
d2688 1
a2688 1
                  
d2708 1
a2708 1
            
d2714 1
a2714 1
                val modules : (string * ml_value * Time.time) list ref = call_c "system module root"
d2727 1
a2727 1
					      e_stack_parameters : int list} -> 
d2767 1
a2767 1
	      
d2770 1
a2770 1
	      
d2776 1
a2776 1
                 THREAD_KILLED_SLEEPING(=8), is used purely to keep 
d2799 1
a2799 1
		    
d2805 1
a2805 1
		    
d2810 1
a2810 1
		    
d2815 1
a2815 1
		    case (result t) of 
d2831 1
a2831 1
                            let val s: unit->unit = 
d2838 1
a2838 1
		      val on : unit -> bool 
d2840 1
a2840 1
		      val get_interval : unit -> int 
d2842 1
a2842 1
		      val set_interval : int -> unit 
d2860 1
a2860 1
	  
d2870 1
a2870 1
	      
d2875 1
a2875 1
	      
d2881 1
a2881 1
	      
d2883 1
a2883 1
	      
d2890 1
a2890 1
	      
d2898 1
a2898 1
	      
d2907 1
a2907 1
	      
d2914 2
a2915 2
	      
	    datatype general_header = 
d2918 4
a2921 4
	       period: Time.Interval.T,
	       suspended: Time.Interval.T}
	      
	    datatype call_header = 
d2923 1
a2923 1
	      
d2934 2
a2935 2
	      
	    datatype space_header = 
d2938 4
a2941 4
	       functions: int, 
	       collections: int, 
	       total_profiled : function_space_profile} 
	      
d2943 1
a2943 1
	      
d2953 1
a2953 1
	      
d2958 2
a2959 2
	      
	    datatype 'a result = 
d2992 1
a2992 1
	  
d2998 1
a2998 1
                   Internal.Bits.lshift(depth,16) + 
d3001 1
a3001 1
			  
d3064 1
a3064 1
      
d3067 1
a3067 1
    val round: real -> int = fn x=>      
d3075 1
a3075 1
	  if diff > 0.5 orelse near mod 2 = 1 
d3079 2
a3080 2
    
    
d3082 1
a3082 1
  
d3084 2
a3085 2
      
    fun unsafe_alloc_string (n:int) : string = 
d3093 1
a3093 1
	raise Size 
d3105 1
a3105 1
	  | get_size ([],sz) = 
d3118 1
a3118 1
    
d3122 2
a3123 2
      
    fun str (c:char) : string = 
d3129 2
a3130 2
    
    fun explode (s:string) : char list = 
d3139 3
a3141 3
    
    
    fun substring (s, i, n) = 
d3146 1
a3146 1
	  fun copy i' = 
d3170 1
a3170 1
        
d3172 1
a3172 1
          
d3175 1
a3175 1
          
d3181 1
a3181 1
          
d3183 1
a3183 1
              
d3197 1
a3197 1
        val (op :=) : ('a ref * 'a) -> unit = (op :=)              
d3199 1
a3199 1
              
d3207 1
a3207 1
	     
d3210 1
a3210 1
      
d3213 1
a3213 1
      
d3216 1
a3216 1
      
d3224 2
a3225 2
    
    
d3228 2
a3229 2
      
    fun foldl f i list = 
d3233 1
a3233 1
      in 
d3236 3
a3238 3
    
    
    fun foldr f i list = 
@


1.216
log
@[Bug #30226]
Add exitFn for storing the function to call when the exe exits normally.
@
text
@d13 4
d2733 17
@


1.215
log
@[Bug #30268]
Clear delivery hooks before delivering.
@
text
@d13 4
d1066 3
a1068 1
	      
d1071 5
a1075 1
                  val deliverer = true_deliverer(c_deliver, !delivery_hooks)
@


1.214
log
@[Bug #30084]
Remove option related stuff from structure General.
Add datatype MLWorks.Internal.Types.option.
Set top-level datatype option to be MLWorks.Internal.Types.option.
Add basic option functions to top level.
This is for adding the Option structure to the Basis.
@
text
@d13 8
d1064 9
a1072 2
		let val deliverer = true_deliverer(c_deliver, !delivery_hooks)
		in deliverer args
@


1.214.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 8
 * Revision 1.214  1997/08/04  11:01:01  brucem
 * [Bug #30084]
 * Remove option related stuff from structure General.
 * Add datatype MLWorks.Internal.Types.option.
 * Set top-level datatype option to be MLWorks.Internal.Types.option.
 * Add basic option functions to top level.
 * This is for adding the Option structure to the Basis.
 *
@


1.214.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 8
 * Revision 1.214  1997/08/04  11:01:01  brucem
 * [Bug #30084]
 * Remove option related stuff from structure General.
 * Add datatype MLWorks.Internal.Types.option.
 * Set top-level datatype option to be MLWorks.Internal.Types.option.
 * Add basic option functions to top level.
 * This is for adding the Option structure to the Basis.
 *
@


1.213
log
@[Bug #20014]
adding MLWorks.name to return the name of the invoking program.
@
text
@d13 4
d735 3
d740 2
d781 4
a798 1

d1261 1
d1264 11
d1305 1
a1305 1
                exception SysErr of string * syserror General.option
d1308 1
a1308 1
                val syserror  : string -> syserror General.option 
a1350 2


d1369 1
a1369 1
                type IOData = {input:{descriptor: IO.file_desc General.option,
d1371 2
a1372 2
                                      get_pos: (unit -> int) General.option,
                                      set_pos: (int -> unit) General.option,
d1374 3
a1376 3
                                      can_input: (unit -> bool) General.option},
                  output: {descriptor: IO.file_desc General.option,
                           put: {buf:string, i:int, sz: int General.option}
d1378 3
a1380 3
                           get_pos: (unit -> int) General.option,
                           set_pos: (int -> unit) General.option,
                           can_output: (unit->bool) General.option,
d1382 2
a1383 2
                  error: {descriptor: IO.file_desc General.option,
                          put: {buf:string, i:int, sz: int General.option}
d1385 3
a1387 3
                          get_pos: (unit -> int) General.option,
                          set_pos: (int -> unit) General.option,
                          can_output: (unit->bool) General.option,
d1408 3
a1410 2
                    {output={descriptor=General.SOME (!stdOut),(*YUK*)
                             put= fn {buf,i,sz=General.NONE} => 
d1412 1
a1412 1
                                   | {buf,i,sz=General.SOME n} =>
d1414 1
a1414 1
                             get_pos = General.SOME(fn () => 
d1419 1
a1419 1
                             set_pos = General.SOME
d1421 1
a1421 1
                             can_output = General.NONE,
d1424 2
a1425 2
                     error={descriptor=General.SOME (!stdErr),
                             put= fn {buf,i,sz=General.NONE} => 
d1427 1
a1427 1
                                   | {buf,i,sz=General.SOME n} =>
d1430 3
a1432 2
                                    General.SOME(fn () => IO.seek(!stdErr,0,1)),
                             set_pos= General.SOME
d1434 1
a1434 1
                             can_output = General.NONE,
d1436 1
a1436 1
                     input={descriptor=General.SOME (!stdIn),
d1438 3
a1440 2
                             get_pos= General.SOME(fn () => IO.seek(!stdIn,0,1)),
                             set_pos= General.SOME
d1444 2
a1445 1
                                  General.SOME(fn()=>IO.can_input (!stdIn)>0)},
d1455 4
a1458 2
                  fun print s = (#put(#output(currentIO())) {buf=s,i=0,sz=General.NONE};())
                  fun printError s = (#put(#error(currentIO())) {buf=s,i=0,sz=General.NONE};())
a1472 10
	    structure Types =
	      struct
		type int8 = int8
		type word8 = word8
		type int16 = int16
		type word16 = word16
		type int32 = int32
		type word32 = word32
              end (* structure Types *)

d2803 2
a2804 1
	  end (* structure ??? *)
d3073 1
d3108 1
a3108 1
           SysErrExn            := MLWorks.Internal.Error.SysErr ("",General.NONE);
d3208 12
a3219 1
	     
a3230 1
        
a3231 13
        open General
        exception Option
        
        fun getOpt (NONE, dflt) = dflt
          | getOpt (SOME x, _)  = x
                
        fun isSome NONE     = false
          | isSome (SOME _) = true
                
        fun valOf NONE     = raise Option
          | valOf (SOME x) = x
             
          
d3236 1
a3236 1
        fun exnMessage (MLWorks.Internal.Error.SysErr(s,NONE)) =
d3238 1
a3238 1
          | exnMessage (MLWorks.Internal.Error.SysErr(s,SOME n)) =
a3296 1
    
d3300 1
d3303 2
a3304 1
    open FullPervasiveLibrary_;
@


1.212
log
@[Bug #30101]

Using builitin cos & sin
@
text
@d13 5
d793 1
@


1.211
log
@Adding print_error to StandardIO
@
text
@d13 3
d2632 5
@


1.210
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d13 4
d1420 2
d3267 2
a3268 5
    
    fun print s =
      (#put(#output(MLWorks.Internal.StandardIO.currentIO())) 
       {buf=s,i=0,sz=NONE};())
      
@


1.209
log
@[Bug #30091]
Remove MLWorks.Internal.FileIO and related stuff
@
text
@d13 4
d2740 2
a2741 1
                                              d_intercept : int list} -> 
@


1.208
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d13 4
a2679 1

a2692 13

            structure FileIO =
              struct
                type fd = RawIO.outstream
                datatype offset = BEG | CUR | END

                val seekf : fd * int * offset -> unit = call_c "stream seek out"
                val openf : string -> fd = call_c "stream open update"
                val closef = RawIO.close_out
		val write_byte : fd * int -> unit = RawIO.output_byte
                val writef = RawIO.output
                val writebf : fd * bytearray * int * int -> unit = call_c "stream output bytearray"
              end (* structure FileIO *)
@


1.207
log
@[Bug #1989]
removing Internal.Value.exn_name_string.
@
text
@d13 4
a1225 15
        (* note: the structure Option simply contains the definition
         * of the datatypes 'a option and 'a union.  Eventually this
         * structure will disappear, but since so much code depends on
         * it, it remains.  Note also that the 'a option  datatype will
         * be just the 'a option datatype in General. *)



        structure Option =
          struct
            datatype 'a option = SOME of 'a | NONE
            datatype ('a,'b) union = INL of 'a | INR of 'b 
          end (* structure Option *)


d1260 1
a1260 1
                exception SysErr of string * syserror Option.option
d1263 1
a1263 1
                val syserror  : string -> syserror Option.option 
d1326 1
a1326 1
                type IOData = {input:{descriptor: IO.file_desc Option.option,
d1328 2
a1329 2
                                      get_pos: (unit -> int) Option.option,
                                      set_pos: (int -> unit) Option.option,
d1331 3
a1333 3
                                      can_input: (unit -> bool) Option.option},
                  output: {descriptor: IO.file_desc Option.option,
                           put: {buf:string, i:int, sz: int Option.option}
d1335 3
a1337 3
                           get_pos: (unit -> int) Option.option,
                           set_pos: (int -> unit) Option.option,
                           can_output: (unit->bool) Option.option,
d1339 2
a1340 2
                  error: {descriptor: IO.file_desc Option.option,
                          put: {buf:string, i:int, sz: int Option.option}
d1342 3
a1344 3
                          get_pos: (unit -> int) Option.option,
                          set_pos: (int -> unit) Option.option,
                          can_output: (unit->bool) Option.option,
d1365 2
a1366 2
                    {output={descriptor=Option.SOME (!stdOut),(*YUK*)
                             put= fn {buf,i,sz=Option.NONE} => 
d1368 1
a1368 1
                                   | {buf,i,sz=Option.SOME n} =>
d1370 1
a1370 1
                             get_pos = Option.SOME(fn () => 
d1375 1
a1375 1
                             set_pos = Option.SOME
d1377 1
a1377 1
                             can_output = Option.NONE,
d1380 2
a1381 2
                     error={descriptor=Option.SOME (!stdErr),
                             put= fn {buf,i,sz=Option.NONE} => 
d1383 1
a1383 1
                                   | {buf,i,sz=Option.SOME n} =>
d1386 2
a1387 2
                                    Option.SOME(fn () => IO.seek(!stdErr,0,1)),
                             set_pos= Option.SOME
d1389 1
a1389 1
                             can_output = Option.NONE,
d1391 1
a1391 1
                     input={descriptor=Option.SOME (!stdIn),
d1393 2
a1394 2
                             get_pos= Option.SOME(fn () => IO.seek(!stdIn,0,1)),
                             set_pos= Option.SOME
d1398 1
a1398 1
                                  Option.SOME(fn()=>IO.can_input (!stdIn)>0)},
d3073 1
a3073 1
           SysErrExn            := MLWorks.Internal.Error.SysErr ("",MLWorks.Option.NONE);
d3187 1
a3187 1
        open MLWorks.Option
@


1.207.1.1
log
@branched from 1.207
@
text
@a12 4
 * Revision 1.207  1997/03/25  11:58:36  andreww
 * [Bug #1989]
 * removing Internal.Value.exn_name_string.
 *
@


1.207.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 * Revision 1.207.1.1  1997/05/12  10:39:07  hope
 * branched from 1.207
 *
@


1.207.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 * Revision 1.207.1.1  1997/05/12  10:39:07  hope
 * branched from 1.207
 *
@


1.207.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 * Revision 1.207.1.1  1997/05/12  10:39:07  hope
 * branched from 1.207
 *
@


1.207.1.1.1.2
log
@[Bug #30191]
Removed delivery from Student Edition.
@
text
@a12 3
 * Revision 1.207.1.1.1.1  1997/07/28  18:24:00  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d1004 28
@


1.207.1.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 4
 * Revision 1.207.1.1.1.2  1997/08/06  18:39:19  daveb
 * [Bug #30191]
 * Removed delivery from Student Edition.
 *
@


1.206
log
@[Bug #1968]
Altering runtime calls to fetch the values of stdin, stdout and stderr.
@
text
@d13 4
d2667 1
a2667 1
                val exn_name : exn -> ml_value = call_c "value exn name"
d2669 1
a2669 1
                val exn_name_string : ml_value -> string = call_c "value exn name string"
d3213 1
a3213 2
        val exnName = MLWorks.Internal.Value.exn_name_string o 
                                        MLWorks.Internal.Value.exn_name
@


1.205
log
@[Bug #1431]
Adding Basis Io exception to MLWorks.Internal.IO so that it
can be handled by General.exnMessage neatly.
@
text
@d13 5
d1363 7
a1369 7
                  val stdIn : IO.file_desc = 
                                 call_c "system io standard input"
                  val stdOut : IO.file_desc = 
                                 call_c "system io standard output"
                  val stdErr : IO.file_desc =
                                 call_c "system io standard error"

d1371 2
a1372 2
                  val terminalIO: IOData = 
                    {output={descriptor=Option.SOME stdOut,
d1374 1
a1374 1
                                       IO.write(stdOut,buf,i,size buf-i)
d1376 1
a1376 1
                                       IO.write(stdOut,buf,i,n),
d1378 1
a1378 1
                                                       IO.seek(stdOut,0,1)),
d1383 1
a1383 1
                                          (fn i => (IO.seek (stdOut,i,0);())),
d1385 1
a1385 1
                             close = fn () => IO.close stdOut},
d1387 1
a1387 1
                     error={descriptor=Option.SOME stdErr,
d1389 1
a1389 1
                                       IO.write(stdErr,buf,i,size buf-i)
d1391 1
a1391 1
                                       IO.write(stdErr,buf,i,n),
d1393 1
a1393 1
                                    Option.SOME(fn () => IO.seek(stdErr,0,1)),
d1395 1
a1395 1
                                     (fn i => (IO.seek(stdErr,i,0); ())),
d1397 4
a1400 4
                             close= fn () => IO.close stdErr},
                     input={descriptor=Option.SOME stdIn,
                             get= fn i => IO.read (stdIn,i),
                             get_pos= Option.SOME(fn () => IO.seek(stdIn,0,1)),
d1402 2
a1403 2
                                            (fn i => (IO.seek(stdIn,i,0);())),
                             close= fn() => IO.close stdIn,
d1405 1
a1405 1
                                  Option.SOME(fn()=>IO.can_input stdIn>0)},
d1408 1
a1409 2

                  val currIO: IOData ref = ref terminalIO
@


1.204
log
@[Bug #1677]
add hook for the gui to perform certain code (wait for a mutex)
before it stops pre-empting.  Otherwise the user could
stop pre-emption while the gui was waiting for the listener mutex,
hence turning control over to a concurrent thread.
@
text
@d1263 4
d1282 3
d1288 2
a3082 42
    structure General : GENERAL =
      struct
        
        open BuiltinLibrary_
          
        type exn = exn
        type unit = unit
          
        exception Domain
        exception Fail of string
        exception Empty
        

        open MLWorks.Option
        exception Option
        
        fun getOpt (NONE, dflt) = dflt
          | getOpt (SOME x, _)  = x
                
        fun isSome NONE     = false
          | isSome (SOME _) = true
                
        fun valOf NONE     = raise Option
          | valOf (SOME x) = x
             
          
        datatype order = LESS | EQUAL | GREATER
          
        val exnName = MLWorks.Internal.Value.exn_name_string o 
                                        MLWorks.Internal.Value.exn_name
              
        val exnMessage = exnName
        val (op<>) : ''a * ''a -> bool = (op<>)
        val (op :=) : ('a ref * 'a) -> unit = (op :=)              
        val ignore : 'a -> unit = fn (_) => ()
              
        fun (x before _) = x      (* before is given infix status by
                                     the parser. *)
      end (* structure General *)

    open General

d3177 53
@


1.203
log
@Adding unsafe floatarray operations to Internal.Value
@
text
@d13 3
d1338 2
a1339 1
                          close: unit->unit}}
d1341 7
d1391 2
a1392 1
                                  Option.SOME(fn()=>IO.can_input stdIn>0)}}
d2842 8
a2849 1
                        = call_c "thread stop preemption"
@


1.202
log
@[Bug #1911]
#put(#output(TerminalIO)) ought to write to stdOut, not stdErr.
@
text
@d13 4
d2606 3
@


1.201
log
@[Bug #1891]
Adding new primitives to enter and exit critical sections in pre-empting
threads.
@
text
@d13 5
d1345 1
a1345 1
                                       IO.write(stdErr,buf,i,size buf-i)
d1347 1
a1347 1
                                       IO.write(stdErr,buf,i,n),
@


1.200
log
@[Bug #1896]
altering MLWorks.Threads.result to cope with new threads state
THREADS_KILLED_SLEEPING.
@
text
@d13 5
d2815 16
a2830 5
		      val start : unit -> unit = call_c "thread start preemption"
		      val stop : unit -> unit = call_c "thread stop preemption"
		      val on : unit -> bool = call_c "thread preempting"
		      val get_interval : unit -> int = call_c "thread get preemption interval"
		      val set_interval : int -> unit = call_c "thread set preemption interval"
@


1.199
log
@[Bug #1818]
Adding new FloatArray primitives.
@
text
@d13 4
d2757 11
a2767 1
	      fun result (Thread (r,i)) = Internal.Value.cast (!r);
@


1.198
log
@Adding real equality builtin to MLWorks.Internal.Value.
@
text
@d13 3
d670 1
d1424 362
@


1.197
log
@[bug 1775]
Handle all exceptions caused by the profile select function
@
text
@d13 4
d2211 2
@


1.197.3.1
log
@branched from 1.197
@
text
@a12 4
 * Revision 1.197  1996/11/18  14:10:04  jont
 * [bug 1775]
 * Handle all exceptions caused by the profile select function
 *
@


1.197.2.1
log
@branched from 1.197
@
text
@a12 4
 * Revision 1.197  1996/11/18  14:10:04  jont
 * [bug 1775]
 * Handle all exceptions caused by the profile select function
 *
@


1.197.2.1.1.1
log
@branched from 1.197.2.1
@
text
@a12 3
 * Revision 1.197.2.1  1996/12/17  17:52:13  hope
 * branched from 1.197
 *
@


1.197.1.1
log
@branched from 1.197
@
text
@a12 4
 * Revision 1.197  1996/11/18  14:10:04  jont
 * [bug 1775]
 * Handle all exceptions caused by the profile select function
 *
@


1.196
log
@[Bug #1614]
Removing toplevel String structure.
@
text
@d13 4
d2551 1
d2553 1
a2553 1
		  rts_profile (scan, selector, wrapper)
@


1.196.1.1
log
@branched from 1.196
@
text
@a12 4
 * Revision 1.196  1996/11/01  17:07:36  io
 * [Bug #1614]
 * Removing toplevel String structure.
 *
@


1.196.1.1.1.1
log
@branched from 1.196.1.1
@
text
@a12 3
 * Revision 1.196.1.1  1996/11/14  12:55:19  hope
 * branched from 1.196
 *
@


1.195
log
@[Bug #1682]
removing General structure from MLWorks structure.
@
text
@d13 4
a663 2

    structure String  : STRING
d731 1
d1192 1
a1192 1
          end
d1362 1
a1362 1
              end
d1372 1
a1372 1
	      end
d1382 1
a1382 1
              end
d1387 1
a1387 1
              end
d1400 1
a1400 1
              end
d1411 1
a1411 1
	      end
d2145 1
a2145 1
	      end
d2186 1
a2186 1
	      end
d2258 2
a2259 2
                  end
              end
d2274 1
a2274 1
              end
d2287 1
a2287 1
              end
d2312 1
a2312 1
              end
d2332 2
a2333 2
                                        (int * ml_value) list = call_c "system load wordset"
                  end;
d2343 1
a2343 1
		  end;
d2353 3
a2355 6
                  end;
              end
	  end



d2425 4
a2428 4
		    end
		end
	    end
	  end
d2574 1
a2574 1
	    end
d2576 1
a2576 1
          end
d2595 1
a2595 4
      end
    
    structure String = MLWorks.String

d2628 1
a2628 1
           SubstringExn		:= String.Substring;
d2634 1
a2634 1
    end
d2674 1
a2674 5
      end




d2746 1
a2746 2
      let val size = size s 
	fun aux (i, acc) =
d2752 1
a2752 1
	aux (size-1, [])
d2818 1
a2818 2
      
  end (* FullPervasiveLibrary_ *)
@


1.194
log
@[Bug #1655]
Correcting definition of MLWorks.Threads.Internal.children
,
@
text
@d13 5
d663 1
d731 1
a731 1
            val maxLen = 16777195 (* MAGIC *) (* One less than ByteArray.maxLen *)
d756 2
a757 1
            val c_implode_char : int list * int -> string = call_c "string c implode char"
d759 2
a760 1
            (* For more than ~30 characters this is slower than the C function *)
d1121 3
a1123 1
                val result = f () handle exn => (flush_out stream; refstream := oldstream; raise exn)
d1139 2
a1140 1
			 close_out = fn () => raise Io "Cannot close messages stream",
d1165 2
a1166 1
            val file_modified : string -> Time.time = call_c "time file modified"
d1172 2
a1173 1
            val set_file_modified : string * modtime -> unit = call_c "time set file modified"
d1177 5
a1181 8
        (* note: the structure Option is not signature restricted to 
         * OPTION here. (It is so restricted by the MLWORKS signature.)
         * This allows other structures in the pervasive
         * library to make use of the extra values (the exception and
         * three functions).  Both Internal.StandardIO and
         * General do so.  These extra values are exposed in General
         * and hidden in Option by the MLWORKS signature.
         *)
d1185 3
a1187 3
        structure Option = 
          struct 
            datatype 'a option = SOME of 'a | NONE 
d1189 1
a1189 13

            exception Option

            fun getOpt (NONE, dflt) = dflt
              | getOpt (SOME x, _)  = x
                
            fun isSome NONE     = false
              | isSome (SOME _) = true
                
            fun valOf NONE     = raise Option
              | valOf (SOME x) = x
             
          end (* structure Option *)
d1305 6
a1310 3
                  val stdIn : IO.file_desc = call_c "system io standard input"
                  val stdOut : IO.file_desc = call_c "system io standard output"
                  val stdErr : IO.file_desc = call_c "system io standard error"
d1319 3
a1321 1
                             get_pos = Option.SOME(fn () => IO.seek(stdOut,0,1)),
d1334 2
a1335 1
                             get_pos= Option.SOME(fn () => IO.seek(stdErr,0,1)),
d1344 1
a1344 1
                                              (fn i => (IO.seek(stdIn,i,0);())),
d1346 2
a1347 1
                             can_input= Option.SOME(fn()=>IO.can_input stdIn>0)}}
d1425 6
a1430 3
		val to_string : bytearray -> string = call_c "bytearray to string"
		val from_string : string -> bytearray = call_c "bytearray from string"
		val substring : bytearray * int * int -> string = call_c "bytearray substring"
d1705 2
a1706 1
			    (unsafe_update (to, start'+n', unsafe_sub (from, start+n'));
d1712 2
a1713 1
			    (unsafe_update (to,i-start+start',unsafe_sub (from,i));
a2356 36
        structure General : GENERAL =
          struct
            
            open BuiltinLibrary_

            type exn = exn
            type unit = unit
              
            exception Domain
            exception Fail of string
            exception Empty
            
(*            exception Option*)
            open Option
            (* Provides the datatypes option and union *)
              
(*            val getOpt = getOpt
            val isSome = isSome
            val valOf = valOf
*)
            datatype order = LESS | EQUAL | GREATER
              
            val exnName = Internal.Value.exn_name_string o 
                                             Internal.Value.exn_name
              
            val exnMessage = exnName
            val (op<>) : ''a * ''a -> bool = (op<>)
            val (op :=) : ('a ref * 'a) -> unit = (op :=)              
            val ignore : 'a -> unit = fn (_) => ()
              
            fun (x before _) = x
          end




d2639 45
a2683 1
    open MLWorks.General
@


1.193
log
@[Bug #1666]
Hooking runtime exception Threads into pervasive library.
@
text
@d13 4
d2421 1
a2421 1
		  val children = fn x => call_c "thread children"
@


1.192
log
@[Bug #1630]
fix substring
@
text
@d13 4
d2381 2
d2638 1
d2657 2
a2658 1
           ValueExn		:= MLWorks.Internal.Value.Value "")
@


1.192.2.1
log
@branched from 1.192
@
text
@a12 4
 * Revision 1.192  1996/10/03  15:46:53  io
 * [Bug #1630]
 * fix substring
 *
@


1.192.1.1
log
@branched from 1.192
@
text
@a12 4
 * Revision 1.192  1996/10/03  15:46:53  io
 * [Bug #1630]
 * fix substring
 *
@


1.191
log
@[Bug #1490]
update toplevel String.maxSize
@
text
@d13 4
d2735 1
a2735 1
      if i < 0 orelse n < 0 orelse size s < i+n then raise Subscript
@


1.190
log
@[Bug #1574]
Ensure Vector.vector visible at top level to override the builtin library version
@
text
@d13 4
d809 1
a809 383
          end

	structure ByteArray : BYTEARRAY =
	  struct
	    open BuiltinLibrary_
	    exception Substring = Substring

	    type bytearray = bytearray

            val maxLen = 16777196
	    val array = BuiltinLibrary_.bytearray
	    val length = BuiltinLibrary_.bytearray_length
	    val update = BuiltinLibrary_.bytearray_update
	    val unsafe_update = BuiltinLibrary_.bytearray_unsafe_update
	    val sub = BuiltinLibrary_.bytearray_sub
	    val unsafe_sub = BuiltinLibrary_.bytearray_unsafe_sub

	    val to_string : bytearray -> string = call_c "bytearray to string"
	    val from_string : string -> bytearray = call_c "bytearray from string"
	    val substring : bytearray * int * int -> string = call_c "bytearray substring"

	    fun tabulate (l, f) =
	      let
		val a = array (l, 0)

		fun init n =
		  if n = l then a
		  else
		    (unsafe_update (a, n, f n);
		     init (n+1))
	      in
		init 0
	      end

	    fun from_list list =
	      let
		fun list_length (n, []) = n
		  | list_length (n, _::xs) = list_length (n+1, xs)

		val new = array (list_length (0, list), 0)

		fun fill (_, []) = new
		  | fill (n, x::xs) =
		    (unsafe_update (new, n, x);
		     fill (n+1, xs))
	      in
		fill (0, list)
	      end

	    val arrayoflist = from_list

	    fun fill (a, x) =
	      let
		fun fill' 0 = ()
		  | fill' n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (a, n', x);
		       fill' n')
		    end
	      in
		fill' (length a)
	      end

	    fun map f a =
	      let
		val l = length a
		val new = array (l, 0)

		fun map' n =
		  if n = l then
		    new
		  else
		    (unsafe_update (new, n, f (unsafe_sub (a, n)));
		     map' (n+1))
	      in
		map' 0
	      end

	    fun map_index f a =
	      let
		val l = length a
		val new = array (l, 0)

		fun map' n =
		  if n = l then
		    new
		  else
		    (unsafe_update (new, n, f (n, unsafe_sub (a, n)));
		     map' (n+1))
	      in
		map' 0
	      end

	    fun to_list a =
	      let
		fun to_list' (0, list) = list
		  | to_list' (n, list) =
		    let
		      val n' = n-1
		    in
		      to_list' (n', unsafe_sub (a, n') :: list)
		    end
	      in
		to_list' (length a, nil)
	      end

	    fun iterate f a =
	      let
		val l = length a

		fun iterate' n =
		  if n = l then
		    ()
		  else
		    (f (unsafe_sub (a, n));
		     iterate' (n+1))
	      in
		iterate' 0
	      end

	    fun iterate_index f a =
	      let
		val l = length a

		fun iterate' n =
		  if n = l then
		    ()
		  else
		    (f (n, unsafe_sub (a, n));
		     iterate' (n+1))
	      in
		iterate' 0
	      end

	    fun rev a =
	      let
		val l = length a
		val new = array (l, 0)

		fun rev' 0 = new
		  | rev' n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (new, n', unsafe_sub (a, l-n));
		       rev' n')
		    end
	      in
		rev' l
	      end

	    fun duplicate a =
	      let
		val l = length a
		val new = array (l, 0)

		fun duplicate' 0 = new
		  | duplicate' n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (new, n', unsafe_sub (a, n'));
		       duplicate' n')
		    end
	      in
		duplicate' l
	      end

	    fun subarray (a, start, finish) =
	      let
		val l = length a
	      in
		if start < 0 orelse start > l orelse finish > l orelse
		  start > finish then
		  raise Subscript
		else
		  let
		    val l' = finish - start
		    val new = array (l', 0)

		    fun copy 0 = new
		      | copy n =
			let
			  val n' = n-1
			in
			  (unsafe_update (new, n', unsafe_sub (a, start+n'));
			   copy n')
			end
		  in
		    copy l'
		  end
	      end

	    fun append (array1, array2) =
	      let
		val l1 = length array1
		val l2 = length array2
		val new = array (l1+l2, 0)

		fun copy1 0 = new
		  | copy1 n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (new, n', unsafe_sub (array1, n'));
		       copy1 n')
		    end

		fun copy2 0 = copy1 l1
		  | copy2 n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (new, n'+l1, unsafe_sub (array2, n'));
		       copy2 n')
		    end
	      in
		copy2 l2
	      end

	    fun reducel f (i, a) =
	      let
		val l = length a

		fun reducel' (i, n) =
		  if n = l then
		    i
		  else
		    reducel' (f (i, unsafe_sub (a, n)), n+1)
	      in
		reducel' (i, 0)
	      end

	    fun reducer f (a, i) =
	      let
		val l = length a

		fun reducer' (0, i) = i
		  | reducer' (n, i) =
		    let
		      val n' = n-1
		    in
		      reducer' (n', f (unsafe_sub (a, n'), i))
		    end
	      in
		reducer' (l, i)
	      end

	    fun reducel_index f (i, a) =
	      let
		val l = length a

		fun reducel' (i, n) =
		  if n = l then
		    i
		  else
		    reducel' (f (n, i, unsafe_sub (a, n)), n+1)
	      in
		reducel' (i, 0)
	      end

	    fun reducer_index f (a, i) =
	      let
		val l = length a

		fun reducer' (0, i) = i
		  | reducer' (n, i) =
		    let
		      val n' = n-1
		    in
		      reducer' (n', f (n', unsafe_sub (a, n'), i))
		    end
	      in
		reducer' (l, i)
	      end

            fun copy (from, start, finish, to, start') =
              let
                val l1 = length from
                val l2 = length to
              in
                if start < 0 orelse start > l1 orelse finish > l1 orelse
                  start > finish orelse
                  start' < 0 orelse start' + finish - start > l2 then
                  raise Subscript
                else
                  let
                    fun copydown 0 = ()
                      | copydown n =
                        let
                          val n' = n-1
                        in
                          (unsafe_update (to, start'+n', unsafe_sub (from, start+n'));
                           copydown n')
                        end
                    fun copyup i =
                      if i = finish then ()
                      else
                        (unsafe_update (to,i-start+start',unsafe_sub (from,i));
                         copyup (i + 1))
                  in
                    if start < start'
                      then copydown (finish - start)
                    else copyup start
                  end
              end
(*
(* Old version for reference *)
(* This fails when copying a to a *)
	    fun copy (from, start, finish, to, start') =
	      let
		val l1 = length from
		val l2 = length to
	      in
		if start < 0 orelse start > l1 orelse finish > l1 orelse
		  start > finish orelse
		  start' < 0 orelse start' + finish - start > l2 then
		  raise Subscript
		else
		  let
		    fun copy' 0 = ()
		      | copy' n =
			let
			  val n' = n-1
			in
			  (unsafe_update (to, start'+n', unsafe_sub (from, start+n'));
			   copy' n')
			end
		  in
		    copy' (finish - start)
		  end
	      end
*)

	    fun fill_range (a, start, finish, x) =
	      let
		val l = length a
	      in
		if start < 0 orelse start > l orelse finish > l orelse
		  start > finish then
		  raise Subscript
		else
		  let
		    fun fill' 0 = ()
		      | fill' n =
			let
			  val n' = n-1
			in
			  (unsafe_update (a, start+n', x);
			   fill' n')
			end
		  in
		    fill' (finish - start)
		  end
	      end

	    exception Find

	    fun find predicate a =
	      let
		val l = length a
		fun find' n =
		  if n = l then
		    raise Find
		  else
		    if predicate (unsafe_sub (a, n)) then n else find' (n+1)
	      in
		find' 0
	      end

	    fun find_default (predicate, default) a =
	      let
		val l = length a
		fun find' n =
		  if n = l then
		    default
		  else
		    if predicate (unsafe_sub (a, n)) then n else find' (n+1)
	      in
		find' 0
	      end
a810 1
	  end
d838 1
a838 1
	  end
d866 1
a866 1
	      end
d913 1
a913 1
	      end
d931 1
a931 1
	  end
d957 2
a958 2
	    end
	  end
d1150 1
a1150 1
          end
d1179 1
a1179 1
          end
d1202 1
a1202 1
              end
d1217 1
a1217 1
              end
d1251 1
a1251 1
              end
d1393 1
a1393 1
	    structure ExtendedArray : EXTENDED_ARRAY =
d1396 1
d1398 13
a1410 1
		type 'a array = 'a array
d1412 372
a1783 1
                val maxLen = 4194297 (* MAGIC NUMBER *)
d2649 1
a2649 1
  open MLWorks.General
d2651 19
a2669 16
  (* some more top-level maths functions *)

  val ceil : real -> int = ~ o floor o ~
  val trunc: real -> int = fn x => if x>0.0 then floor x else ceil x
  val round: real -> int = fn x=>      
    let
      val near = floor x
      val diff = abs(real near - x)
    in
      if diff < 0.5 then
        near
      else
        if diff > 0.5 orelse near mod 2 = 1 
          then near + 1
        else near
    end
d2671 2
a2672 13



   (* some more top-level string functions *)

  val maxSize = 8388606 (* 2 ^ 23 - 1 - 1 *)
    (* 2 ^ 24 -1-1 so as not to include null character
     * change this value in synch with ML_MAX_STRING in rts/src/values.h
     *)




d2676 2
a2677 2
        string_unsafe_update (alloc_s, n-1, 0);
        alloc_s
d2681 1
a2681 1
        raise Size 
d2683 2
a2684 4
        unsafe_alloc_string n



d2687 16
a2702 16
        val cl : int list = cast cl
        fun copyall ([],start,to) = to
          | copyall (c::cl,start,to) =
          (string_unsafe_update (to,start, c);
           copyall (cl,start+1,to))
        fun get_size (a::rest,sz) = get_size (rest,1 + sz)
          | get_size ([],sz) = 
          if sz > 30 then call_c "string c implode char" (cl,sz)
          else
            let
              val result = unsafe_alloc_string (sz+1)
              (* set the null terminator *)
              val _ = string_unsafe_update (result,sz,0)
            in
              copyall (cl,0,result)
            end
d2704 1
a2704 1
        get_size (cl,0)
d2706 2
a2707 2

                               (*NB concat is old-style string implode*)
d2714 2
a2715 2
        string_unsafe_update(alloc_s, 0, (cast c):int);
        alloc_s
d2717 1
a2717 1

d2720 5
a2724 5
        fun aux (i, acc) =
          if i >= 0 then
            aux (i-1, (cast (string_unsafe_sub(s, i)):char)::acc)
          else
            acc
d2726 1
a2726 1
        aux (size-1, [])
d2728 2
a2729 2


d2733 13
a2745 17
        let
          val alloc_s = unsafe_alloc_string (n+1)
          fun copy i' = 
            if i' < 0 then alloc_s
            else
              (string_unsafe_update (alloc_s, i', string_unsafe_sub (s, i+i'));
               copy (i'-1))
        in
          copy (n-1)
        end
      else (* n > 12 *)
        call_c "string unsafe substring" (s, i, n)





d2747 1
a2747 1

d2750 1
a2750 1

d2753 1
a2753 1

d2756 1
a2756 1

d2759 2
a2760 2
        fun loop ([], acc) = acc
          | loop (_::t, acc) = loop (t, 1+acc)
d2762 1
a2762 1
        loop (l, 0)
d2764 2
a2765 2


d2768 1
a2768 1

d2771 2
a2772 2
        fun red (acc, []) = acc
          | red (acc, (x::xs)) = red (f (x, acc), xs)
d2774 1
a2774 1
        red (i, list)
d2776 2
a2777 2


d2780 2
a2781 2
        fun red (acc, []) = acc
          | red (acc, x::xs) = red (f (x,acc), xs)
d2783 1
a2783 1
        red (i, rev list)
d2785 2
a2786 2


d2789 2
a2790 2
         {buf=s,i=0,sz=NONE};())

d2792 2
d2795 1
a2795 3
  end

open FullPervasiveLibrary_;
@


1.190.1.1
log
@branched from 1.190
@
text
@a12 4
 * Revision 1.190  1996/09/02  15:38:12  jont
 * [Bug #1574]
 * Ensure Vector.vector visible at top level to override the builtin library version
 *
@


1.189
log
@[Bug #1554]
Introduce MLWorks.Internal.IO as a repository for file_desc
and the read, write, seek, ... etc. stuff.
@
text
@d13 5
d2799 2
@


1.188
log
@[Bug #1534]
before is now infix.
@
text
@d13 4
a1557 1
            exception SysErr of string * int Option.option
d1571 57
d1636 2
a1637 2
                   (* #error for standard error.   It does not "pull   *)
                   (* through" other system IO routines like open.     *)
d1647 1
a1647 1
                type IOData = {input:{descriptor: int Option.option,
d1653 1
a1653 1
                  output: {descriptor: int Option.option,
d1660 1
a1660 1
                  error: {descriptor: int Option.option,
a1667 14


                  val write: int * string * int * int-> int
                            = call_c "system io write"
                  val read: int * int -> string
                            = call_c "system io read"
                  val seek: int * int * int -> int
                            = call_c "system io seek"
                  val close: int -> unit
                            = call_c "system io close"
                  val can_input: int -> int
                            = call_c "system io can input"


d1669 3
a1671 3
                  val std_in = call_c "system io standard input"
                  val std_out = call_c "system io standard output"
                  val std_err = call_c "system io standard error"
d1675 1
a1675 1
                    {output={descriptor=Option.SOME std_out,
d1677 1
a1677 1
                                       write(std_err,buf,i,size buf-i)
d1679 2
a1680 2
                                       write(std_err,buf,i,n),
                             get_pos = Option.SOME(fn () => seek(std_out,0,1)),
d1684 1
a1684 1
                                          (fn i => (seek (std_out,i,0);())),
d1686 1
a1686 1
                             close = fn () => close std_out},
d1688 1
a1688 1
                     error={descriptor=Option.SOME std_err,
d1690 1
a1690 1
                                       write(std_err,buf,i,size buf-i)
d1692 2
a1693 2
                                       write(std_err,buf,i,n),
                             get_pos= Option.SOME(fn () => seek(std_err,0,1)),
d1695 1
a1695 1
                                     (fn i => (seek(std_err,i,0); ())),
d1697 4
a1700 4
                             close= fn () => close std_err},
                     input={descriptor=Option.SOME std_in,
                             get= fn i => read (std_in,i),
                             get_pos= Option.SOME(fn () => seek(std_in,0,1)),
d1702 3
a1704 3
                                              (fn i => (seek(std_in,i,0);())),
                             close= fn() => close std_in,
                             can_input= Option.SOME(fn()=>can_input std_in>0)}}
a1766 8
            structure Debugger =
              struct
                fun default_break s = IO.output(IO.std_out,"Break at " ^ s ^ "\n")
                val break_hook = ref default_break
                fun break s = (!break_hook) s
              end


d2633 1
a2633 1
           SysErrExn            := MLWorks.Internal.SysErr ("",MLWorks.Option.NONE);
@


1.187
log
@Expanding the contents of the StandardIO buffers.
@
text
@d13 3
a2314 1
            val before : ('a * 'b) -> 'a = fn (x,_) => x
d2317 1
@


1.186
log
@Expanding the top level environment to meet the revised basis specification.
@
text
@d13 3
a622 1
require " gui_standard_io";
a657 2
    exception Empty

d1523 1
a1523 1
         * three functions).  Both Internal.GuiStandardIO and
d1566 1
a1566 1
            structure GuiStandardIO  : GUI_STANDARD_IO =
a1567 1
                open Option
d1571 4
a1574 5
                   (* #output_fun: write string to window              *)
                   (* #input_fun:  input string from window            *)
                   (* #eof_flag:   input stream closed?                *)
                   (* #buffer_pos: pos in input buffer                 *)
                   (* #buffer_data: input buffer.                      *)
d1581 23
a1603 1
                   (* and last, win_nt/__primio.sml.                   *)
a1604 5
                type IOData = {output_fun: string->unit, 
                               input_fun: unit->string,  
                               eof_flag: bool ref,
                               buffer_pos: int ref,
                               buffer_data: string ref} 
a1605 3
                local 
                  val currWin: IOData option ref = ref NONE
                  val resetStdIO = ref (fn (f:unit->unit)=>f())
d1607 11
a1617 4
                in
                  exception GuiNotActive
                  
                  fun guiIsActive() = isSome (!currWin)
d1619 37
a1655 5
                     (* inDeliveredImage (used in _podium.sml, the    *)
                     (* delivery_hook function) resets the standard IO*)
                     (* to the terminal for delivered images.  These  *)
                     (* stand alone, not using a gui.  The function is*)
                     (* created by __primio.sml                       *)
a1656 2
                  fun inDeliveredImage(f: unit->unit) = (!resetStdIO) f
                  fun forDelivery (f: (unit->unit)->unit) = (resetStdIO:=f)
a1657 2
                  fun currentWindow () = valOf(!currWin)
                    handle Option => raise GuiNotActive
d1659 6
a1664 2
                  fun setCurrentWindow (newWindow:IOData) = 
                    (currWin:=(SOME newWindow))
d2294 1
a2294 1
            
a2710 2
    exception Empty

a2749 16

    (* The following is a whopping hack.  Basically, we are attempting *)
    (* to provide a system-inspecific function that writes to standard *)
    (* output.  The problem is that this code is system specific...    *)
    (* and involves calls to the runtime.  How do we know which runtime*)
    (* to call?  We don't.  So what we have to do is attempt to write  *)
    (* to one platform (e.g., windows) and if the system call does not *)
    (* exist catch the exception and try the other (e.g., unix).       *)
    (* One major problem here is that call_c is inlined at load time,  *)
    (* NOT runtime, so the exception (Unbound) won't be caught by any  *)
    (* handlers we put into the print code.  So we have to be more     *)
    (* sneaky and use closures to prevent the call being inlined until *)
    (* runtime.   A better way would be to provide the necessary calls *)
    (* in the runtime in a system-inspecific way.  This is what I hope *)
    (* to do with other changes ... but at the moment at least it works*)

d2751 2
a2752 22
      if MLWorks.Internal.GuiStandardIO.guiIsActive() then
        let
          val {output_fun,...} = 
            MLWorks.Internal.GuiStandardIO.currentWindow()
        in output_fun s
        end else
        let
          fun write (system_call:string) (std_out:int) 
            (message:string):unit =
            call_c system_call (std_out,message,0,size message)
            
          fun std_out (system_call:string): int =
            call_c system_call
            
          val unixWrite = write "system os unix write"
          val win32Write = write "system os win32 write"
        in
          win32Write (std_out "system os win32 standard out") s
          handle _ => unixWrite 1 s
        end
      

@


1.185
log
@adding GuiStandardIO structure to pervasives.
@
text
@d13 3
d631 3
d637 3
d648 21
d676 1
a676 1
    open BuiltinLibrary_ 
d2548 192
@


1.184
log
@Extend datatype MLWorks.Internal.Trace.status.
@
text
@d13 3
d617 2
d626 2
a627 8
    exception Bind
    exception Chr
    exception Div
    exception Match
    exception Overflow
    exception Size
    exception Subscript
    
a632 2
    val !                     : 'a ref -> 'a
    val :=                    : 'a ref * 'a -> unit
a633 1
    val o                     : ('b -> 'c) * ('a -> 'b) -> ('a -> 'c)
a636 1
    val <>    		      : ''a * ''a -> bool
d654 1
d1149 1
a1149 5
        structure Option = 
          struct 
            datatype 'a option = SOME of 'a | NONE 
            datatype ('a,'b) union = INL of 'a | INR of 'b 
          end
d1489 29
d1534 56
d2200 39
d2268 1
d2479 1
d2516 2
@


1.183
log
@add exception Size
@
text
@d13 3
d2038 1
a2038 1
                datatype status = INTERCEPT | NONE | REPLACE
@


1.182
log
@Revising top level for revised basis.
@
text
@d13 3
d701 2
a702 2
                    (string_unsafe_update (to,start,c);
                     copyall (cl,start+1,to))
d705 9
a713 9
                    if sz > 30 then c_implode_char (cl,sz)
                    else
                      let
                        val result = alloc_string (sz+1)
                        (* set the null terminator *)
                        val _ = string_unsafe_update (result,sz,0)
                      in
                        copyall (cl,0,result)
                      end
d2361 1
d2380 1
@


1.181
log
@Fixing problem with SysErr
@
text
@d13 3
a612 1
    structure Char    : CHAR
a617 4
    exception Exp
    exception Interrupt
    exception Io of string
    exception Ln
a618 1
    exception Ord
a619 1
    exception Sqrt
d623 2
a630 1
    val arctan                : real -> real
a632 3
    val cos                   : real -> real
    val exp                   : real -> real
    val ln                    : real -> real
a636 1
    val sin                   : real -> real
a637 1
    val sqrt                  : real -> real
d647 3
d656 2
d1299 1
d1302 2
d1496 3
a1498 1
	    val save : string * (unit -> 'a) -> unit -> 'a = fn x => call_c "image save" x
d1501 1
d2335 1
d2351 1
a2354 3
    structure Char = MLWorks.Char

    open MLWorks.IO
a2362 2
      val ExpExn =			call_c "exception Exp"
      val LnExn =			call_c "exception Ln"
a2364 1
      val SqrtExn =			call_c "exception Sqrt"
d2377 1
a2377 3
           ExpExn		:= Exp;
           IoExn		:= Io "";
           LnExn		:= Ln;
a2382 1
           SqrtExn		:= Sqrt;
@


1.180
log
@Improving MLWorks.ml_string function
@
text
@d13 3
d1494 1
a2360 1
      val SubstringExn =		call_c "exception Substring"
d2367 2
d2389 1
@


1.179
log
@Removed RawIO.outstream parameter in Internal.Value.print.
@
text
@d13 3
d717 7
d725 2
a726 4

		fun aux ([],result,_) = implode (rev result)
		  | aux (_,result,0) = implode (rev ("\\..." :: result))
		  | aux (char::rest,result,n) =
d749 1
a749 1
		      aux (rest, newres, n-1)
d752 1
a752 1
		aux (explode s,[],if max_size < 0 then ~1 else max_size)
@


1.178
log
@Changing type of real_to_string
@
text
@d13 3
d1976 1
a1976 1
                val print : print_options * RawIO.outstream * T -> unit = call_c "value print"
@


1.177
log
@Changing type of word32 shift operations
@
text
@d13 3
d1483 1
a1483 1
            val real_to_string : real -> string = call_c "real to string"
@


1.176
log
@Moving Bits to Internal
@
text
@d13 3
d656 1
a751 1

d756 1
a916 2
	    exception Subarray of int * int

d923 1
a923 1
		  raise Subarray (start, finish)
d1025 33
a1057 2
	    exception Copy of int * int * int

d1066 1
a1066 1
		  raise Copy (start, finish, start')
d1081 1
a1081 2

	    exception Fill of int * int
d1089 1
a1089 1
		  raise Fill (start, finish)
d1547 1
d1704 1
a1704 1
		      raise Subarray (start, finish)
a1805 1
		exception Copy of int * int * int
d1814 1
a1814 1
		      raise Copy (start, finish, start')
d1817 2
a1818 2
			fun copy' 0 = ()
			  | copy' n =
d1823 1
a1823 1
			       copy' n')
d1825 5
d1831 3
a1833 1
			copy' (finish - start)
a1836 1
		exception Fill of int * int
d1843 1
a1843 1
		      raise Fill (start, finish)
d1892 1
@


1.175
log
@MLWorks.Debugger: moved to MLWorks.Internal.Debugger
MLWorks.OS.arguments: moved MLWorks.arguments & removed MLWorks.OS
@
text
@d13 4
a594 1
    structure Bits    : BITS
a744 5
        structure Bits : BITS =
          struct
            open BuiltinLibrary_
          end

d1472 5
d2261 1
a2261 1
		  Bits.orb(manner_object x,breakdown_manner xs)
d2269 2
a2270 2
		 Bits.lshift(depth,16) + 
		 Bits.lshift(breakdown_manner breakdown, 8)
a2291 1
    structure Bits = MLWorks.Bits
@


1.174
log
@Array moving to MLWorks.Array
@
text
@d13 3
d643 1
a643 1
        val exit : int -> unit = call_c "system os exit"
d1255 190
d1498 8
a2122 189
        structure IO =
          struct
            datatype RigidInStream =
              RIGIDINSTREAM of {input		: int -> string,
                                lookahead		: unit -> string,
                                end_of_stream	: unit -> bool,
                                clear_eof		: unit -> unit,
                                close_in		: unit -> unit,
				closed_in               : unit -> bool}
            datatype FlexInStream =
              FLEXINSTREAM of RigidInStream ref

            datatype instream =
              RIGIDIN of RigidInStream
            | FLEXIN of FlexInStream

            fun instream stream_data =
              RIGIDIN (RIGIDINSTREAM stream_data)

            fun open_in string =
              let
                val raw_instream = RawIO.open_in string
              in
                instream {input =	  fn int => RawIO.input (raw_instream, int),
                          lookahead =	  fn ()  => RawIO.lookahead raw_instream,
                          end_of_stream = fn ()  => RawIO.end_of_stream raw_instream,
                          clear_eof =	  fn ()  => RawIO.clear_eof raw_instream,
                          close_in =	  fn ()  => RawIO.close_in raw_instream,
			  closed_in =     fn ()  => RawIO.closed_in raw_instream}
              end
            
            fun get_rigid_instream (RIGIDIN s) = s
              | get_rigid_instream (FLEXIN (FLEXINSTREAM (ref s))) = s

            fun rigid_end_of_stream (RIGIDINSTREAM {end_of_stream, ...}) = end_of_stream ()
            fun rigid_input (RIGIDINSTREAM  {input, ...}, n) = input n
            fun rigid_clear_eof (RIGIDINSTREAM  {clear_eof, ...}) = clear_eof ()
            fun rigid_lookahead (RIGIDINSTREAM  {lookahead, ...}) = lookahead ()
            fun rigid_close_in (RIGIDINSTREAM  {close_in, ...}) = close_in ()
	    fun rigid_closed_in (RIGIDINSTREAM {closed_in, ...}) = closed_in ()

            fun end_of_stream s = rigid_end_of_stream (get_rigid_instream s)
            fun input (s,n) = rigid_input (get_rigid_instream s, n)
            fun clear_eof s = rigid_clear_eof (get_rigid_instream s)
            fun lookahead s = rigid_lookahead (get_rigid_instream s)
            fun close_in s = rigid_close_in (get_rigid_instream s)
	    fun closed_in s = rigid_closed_in (get_rigid_instream s)
              
            fun mkFlexInStream s = FLEXIN (FLEXINSTREAM (ref (get_rigid_instream s)))

            val terminal_in =
		instream {input =	          fn int => RawIO.input (RawIO.std_in, int),
			  lookahead =	          fn ()  => RawIO.lookahead RawIO.std_in,
			  end_of_stream =         fn ()  => RawIO.end_of_stream RawIO.std_in,
			  clear_eof =	          fn ()  => RawIO.clear_eof RawIO.std_in,
			  close_in =	          fn ()  => raise Io "<Cannot close std_in>",
			  closed_in =             fn () => false}

            exception GetFlexInStream
            fun getflexinstream (FLEXIN fstr) = fstr
              | getflexinstream _ = raise GetFlexInStream

            val std_in = mkFlexInStream terminal_in

            val flex_std_in = getflexinstream std_in

            fun with_input (FLEXINSTREAM refstream) stream f =
              let
                val oldstream = (!refstream)
                val _ = refstream := get_rigid_instream stream
                val result = f () handle exn => (refstream := oldstream; raise exn)
              in
                refstream := oldstream;
                result
              end

            val with_standard_input = fn x => with_input flex_std_in x

	    fun input_line file =
	      let
		fun extend_line line =
                  let
                    val char = input(file, 1)
                  in
                    if char = "" then implode(rev line)
                    else if char = "\n" then implode(rev("\n" :: line))
                    else extend_line(char :: line)
                  end
	      in
		extend_line []
	      end

            datatype RigidOutStream =
              RIGIDOUTSTREAM of {output	: string -> unit,
				 flush_out	: unit -> unit,
				 close_out	: unit -> unit,
				 closed_out     : unit -> bool}

            datatype FlexOutStream =
              FLEXOUTSTREAM of RigidOutStream ref

            datatype outstream =
              RIGIDOUT of RigidOutStream
            | FLEXOUT of FlexOutStream

            fun outstream stream_data =
              RIGIDOUT (RIGIDOUTSTREAM stream_data)

            fun open_out string =
              let
                val raw_outstream = RawIO.open_out string
              in
                outstream {output =	fn string => RawIO.output (raw_outstream, string),
                           flush_out =	fn ()     => RawIO.flush_out raw_outstream,
                           close_out =	fn ()     => RawIO.close_out raw_outstream,
			   closed_out = fn ()     => RawIO.closed_out raw_outstream}
              end

            
            fun get_rigid_outstream (RIGIDOUT s) = s
              | get_rigid_outstream (FLEXOUT (FLEXOUTSTREAM (ref s))) = s

            fun mkFlexOutStream s = FLEXOUT (FLEXOUTSTREAM (ref (get_rigid_outstream s)))

            fun rigid_output (RIGIDOUTSTREAM {output, ...}, string) = output string
            fun rigid_flush_out (RIGIDOUTSTREAM  {flush_out, ...}) = flush_out ()
            fun rigid_close_out (RIGIDOUTSTREAM  {close_out, ...}) = close_out ()
	    fun rigid_closed_out (RIGIDOUTSTREAM {closed_out,...}) = closed_out ()

            fun output (stream,string) = rigid_output (get_rigid_outstream stream, string)
            fun flush_out stream = rigid_flush_out (get_rigid_outstream stream)
            fun close_out stream = rigid_close_out (get_rigid_outstream stream)
	    fun closed_out stream = rigid_closed_out (get_rigid_outstream stream)
              
            fun with_output (FLEXOUTSTREAM refstream) stream f =
              let
                val oldstream = (!refstream)
                val _ = refstream := get_rigid_outstream stream
                val result = f () handle exn => (flush_out stream; refstream := oldstream; raise exn)
              in
                flush_out stream; 
                refstream := oldstream;
                result
              end

            val terminal_out =
	      outstream {output = fn s => RawIO.output(RawIO.std_out,s),
			 flush_out = fn () => RawIO.flush_out RawIO.std_out,
			 close_out = fn () => raise Io "Cannot close std_out",
			 closed_out = fn () => false}

	    val messages = 
	      outstream {output = call_c "stream message output",
			 flush_out = call_c "stream message flush",
			 close_out = fn () => raise Io "Cannot close messages stream",
			 closed_out = fn () => false}

            exception GetFlexOutStream
            fun getflexoutstream (FLEXOUT fstr) = fstr
              | getflexoutstream _ = raise GetFlexOutStream

            val std_out = mkFlexOutStream terminal_out

            val flex_std_out = getflexoutstream std_out

            val with_standard_output = fn x => with_output flex_std_out x

            val terminal_err =
	      outstream {output = fn s => RawIO.output(RawIO.std_err,s),
			 flush_out = fn () => RawIO.flush_out RawIO.std_err,
			 close_out = fn () => raise Io "Cannot close std_err",
			 closed_out = fn () => false}

            val std_err = mkFlexOutStream terminal_err

            val flex_std_err = getflexoutstream std_err

            val with_standard_error = fn x => with_output flex_std_err x

            val file_modified : string -> Time.time = call_c "time file modified"

            (* This datatype is decoded in rts/pervasive/time.c.  You *)
            (* must update that if you change it. *)
	    datatype modtime = NOW | TIME of Time.time

            val set_file_modified : string * modtime -> unit = call_c "time set file modified"

          end

a2269 85
          end

	structure Integer =
	  struct
	    fun makedigits anint =
	      let
		val digit =
		  if anint >= 0 then
		    anint mod 10
		  else
		    let
		      val res = anint mod 10
		    in
		      if res = 0 then 0 else 10 - res
		    end
		val new_int =
		  if anint >= 0 orelse digit = 0 then
		    anint div 10
		  else 1 + anint div 10
	      in
		(if new_int <> 0
		   then makedigits new_int
		 else
		   "") ^
		   chr (digit + 48)
	      end

	    fun makestring anint =
	      let
		val sign = if anint < 0 then "~" else ""
	      in
		sign ^ makedigits anint
	      end

	    fun print i = IO.output(IO.std_out, makestring i)

	    fun to_hex digit =
	      if digit <= 9 then
		chr(digit + ord"0")
	      else
		chr(digit - 10 + ord"a")

	    fun hexmakedigits anint =
	      let
		val digit =
		  if anint >= 0 then
		    anint mod 16
		  else 
		    let
		      val res = anint mod 16
		    in
		      if res = 0 then 0 else 16 - res
		    end
		val new_int =
		  if anint >= 0 orelse digit = 0 then
		    anint div 16
		  else 1 + anint div 16
	      in
		(if new_int <> 0
		   then hexmakedigits new_int
		 else
		   "") ^
		   to_hex digit
	      end

	    fun hexmakestring anint =
	      let
		val sign = if anint < 0 then "~" else ""
	      in
		sign ^ "0x" ^ hexmakedigits anint
	      end

	    fun hexprint i = IO.output(IO.std_out, hexmakestring i)
	  end

        structure OS =
          struct
            val arguments : unit -> string list = call_c "system os arguments"
          end

        structure Debugger =
          struct
            fun default_break s = IO.output(IO.std_out,"Break at " ^ s ^ "\n")
            val break_hook = ref default_break
            fun break s = (!break_hook) s
@


1.173
log
@Add image delivery hooks.
@
text
@d13 3
a586 3
    structure Array   : ARRAY
    structure ExtendedArray   : EXTENDED_ARRAY
    structure Vector  : VECTOR
d642 1
a642 1
        structure ExtendedArray : EXTENDED_ARRAY =
d645 1
d647 23
a669 1
            type 'a array = 'a array
d671 1
a671 3
            fun tabulate (l, f) =
              let
                val a = array (l, 0)
d673 3
a675 10
                fun init n =
		  if n = l then a
		  else
                    (unsafe_update (a, n, f n);
                     init (n+1))
	      in
                init 0
              end

            fun from_list list =
d677 15
a691 9
                fun list_length (n, []) = n
                  | list_length (n, _::xs) = list_length (n+1, xs)

                val new = array (list_length (0, list), 0)

                fun fill (_, []) = new
                  | fill (n, x::xs) =
                    (unsafe_update (new, n, x);
                     fill (n+1, xs))
d693 1
a693 1
                fill (0, list)
d696 3
a698 1
            val arrayoflist = from_list
d700 24
a723 6
            fun fill (a, x) =
              let
                fun fill' 0 = ()
                  | fill' n =
		    let
		      val n' = n-1
d725 1
a725 2
		      (unsafe_update (a, n', x);
		       fill' n')
d727 3
a729 3
              in
                fill' (length a)
              end
d731 5
a735 286
            fun map f a =
              let
                val l = length a
                val new = array (l, 0)

                fun map' n =
		  if n = l then
		    new
		  else
                    (unsafe_update (new, n, f (unsafe_sub (a, n)));
                     map' (n+1))
              in
                map' 0
              end

            fun map_index f a =
              let
                val l = length a
                val new = array (l, 0)

                fun map' n =
		  if n = l then
		    new
		  else
                    (unsafe_update (new, n, f (n, unsafe_sub (a, n)));
                     map' (n+1))
              in
                map' 0
              end

            fun to_list a =
              let
                fun to_list' (0, list) = list
                  | to_list' (n, list) =
		    let
		      val n' = n-1
		    in
		      to_list' (n', unsafe_sub (a, n') :: list)
		    end
              in
                to_list' (length a, nil)
              end

            fun iterate f a =
              let
                val l = length a

                fun iterate' n =
		  if n = l then
		    ()
		  else
                    (f (unsafe_sub (a, n));
                     iterate' (n+1))
              in
                iterate' 0
              end

            fun iterate_index f a =
              let
                val l = length a

                fun iterate' n =
		  if n = l then
		    ()
		  else
                    (f (n, unsafe_sub (a, n));
                     iterate' (n+1))
              in
                iterate' 0
              end

            fun rev a =
              let
                val l = length a
                val new = array (l, 0)

                fun rev' 0 = new
                  | rev' n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (new, n', unsafe_sub (a, l-n));
		       rev' n')
		    end
              in
                rev' l
              end

            fun duplicate a =
              let
                val l = length a
                val new = array (l, 0)

                fun duplicate' 0 = new
                  | duplicate' n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (new, n', unsafe_sub (a, n'));
		       duplicate' n')
		    end
              in
                duplicate' l
              end

            exception Subarray of int * int
            fun subarray (a, start, finish) =
              let
                val l = length a
              in
                if start < 0 orelse start > l orelse finish > l orelse
                   start > finish then
                  raise Subarray (start, finish)
                else
                  let
                    val l' = finish - start
                    val new = array (l', 0)

                    fun copy 0 = new
                      | copy n =
			let
			  val n' = n-1
			in
			  (unsafe_update (new, n', unsafe_sub (a, start+n'));
			   copy n')
			end
                  in
                    copy l'
                  end
              end

            fun append (array1, array2) =
              let
                val l1 = length array1
                val l2 = length array2
                val new = array (l1+l2, 0)

                fun copy1 0 = new
                  | copy1 n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (new, n', unsafe_sub (array1, n'));
		       copy1 n')
		    end

                fun copy2 0 = copy1 l1
                  | copy2 n =
		    let
		      val n' = n-1
		    in
		      (unsafe_update (new, n'+l1, unsafe_sub (array2, n'));
		       copy2 n')
		    end
              in
                copy2 l2
              end

            fun reducel f (i, a) =
              let
                val l = length a

                fun reducel' (i, n) =
		  if n = l then
		    i
		  else
                    reducel' (f (i, unsafe_sub (a, n)), n+1)
              in
                reducel' (i, 0)
              end

            fun reducer f (a, i) =
              let
                val l = length a

                fun reducer' (0, i) = i
                  | reducer' (n, i) =
		    let
		      val n' = n-1
		    in
		      reducer' (n', f (unsafe_sub (a, n'), i))
		    end
              in
                reducer' (l, i)
              end

            fun reducel_index f (i, a) =
              let
                val l = length a

                fun reducel' (i, n) =
		  if n = l then
		    i
		  else
                    reducel' (f (n, i, unsafe_sub (a, n)), n+1)
              in
                reducel' (i, 0)
              end

            fun reducer_index f (a, i) =
              let
                val l = length a

                fun reducer' (0, i) = i
                  | reducer' (n, i) =
		    let
		      val n' = n-1
		    in
		      reducer' (n', f (n', unsafe_sub (a, n'), i))
		    end
              in
                reducer' (l, i)
              end

            exception Copy of int * int * int
            fun copy (from, start, finish, to, start') =
              let
                val l1 = length from
                val l2 = length to
              in
                if start < 0 orelse start > l1 orelse finish > l1 orelse
                   start > finish orelse
                   start' < 0 orelse start' + finish - start > l2 then
                  raise Copy (start, finish, start')
                else
                  let
                    fun copy' 0 = ()
                      | copy' n =
			let
			  val n' = n-1
			in
			  (unsafe_update (to, start'+n', unsafe_sub (from, start+n'));
			   copy' n')
			end
                  in
                    copy' (finish - start)
                  end
              end

            exception Fill of int * int
            fun fill_range (a, start, finish, x) =
              let
                val l = length a
              in
                if start < 0 orelse start > l orelse finish > l orelse
                   start > finish then
                  raise Fill (start, finish)
                else
                  let
                    fun fill' 0 = ()
                      | fill' n =
			let
			  val n' = n-1
			in
			  (unsafe_update (a, start+n', x);
			   fill' n')
			end
                  in
                    fill' (finish - start)
                  end
              end

            exception Find
            fun find predicate a =
              let
                val l = length a
                fun find' n =
		  if n = l then
		    raise Find
		  else
		    if predicate (unsafe_sub (a, n)) then n else find' (n+1)
              in
                find' 0
              end

            fun find_default (predicate, default) a =
              let
                val l = length a
                fun find' n =
		  if n = l then
		    default
		  else
		    if predicate (unsafe_sub (a, n)) then n else find' (n+1)
              in
                find' 0
              end
d739 1
a739 3
	structure Array : ARRAY = ExtendedArray

        structure ByteArray : BYTEARRAY =
d742 5
d748 1
a748 1
            exception Substring = Substring
d750 1
a750 1
            type bytearray = bytearray
d752 10
a761 10
            val array = BuiltinLibrary_.bytearray
            val length = BuiltinLibrary_.bytearray_length
            val update = BuiltinLibrary_.bytearray_update
            val unsafe_update = BuiltinLibrary_.bytearray_unsafe_update
            val sub = BuiltinLibrary_.bytearray_sub
            val unsafe_sub = BuiltinLibrary_.bytearray_unsafe_sub

            val to_string : bytearray -> string = call_c "bytearray to string"
            val from_string : string -> bytearray = call_c "bytearray from string"
            val substring : bytearray * int * int -> string = call_c "bytearray substring"
d763 3
a765 3
            fun tabulate (l, f) =
              let
                val a = array (l, 0)
d767 1
a767 1
                fun init n =
d770 2
a771 2
                    (unsafe_update (a, n, f n);
                     init (n+1))
d773 2
a774 2
                init 0
              end
d776 4
a779 4
            fun from_list list =
              let
                fun list_length (n, []) = n
                  | list_length (n, _::xs) = list_length (n+1, xs)
d781 1
a781 1
                val new = array (list_length (0, list), 0)
d783 7
a789 7
                fun fill (_, []) = new
                  | fill (n, x::xs) =
                    (unsafe_update (new, n, x);
                     fill (n+1, xs))
              in
                fill (0, list)
              end
d791 1
a791 1
            val arrayoflist = from_list
d793 4
a796 4
            fun fill (a, x) =
              let
                fun fill' 0 = ()
                  | fill' n =
d803 3
a805 3
              in
                fill' (length a)
              end
d807 4
a810 4
            fun map f a =
              let
                val l = length a
                val new = array (l, 0)
d812 1
a812 1
                fun map' n =
d816 5
a820 5
                    (unsafe_update (new, n, f (unsafe_sub (a, n)));
                     map' (n+1))
              in
                map' 0
              end
d822 4
a825 4
            fun map_index f a =
              let
                val l = length a
                val new = array (l, 0)
d827 1
a827 1
                fun map' n =
d831 5
a835 5
                    (unsafe_update (new, n, f (n, unsafe_sub (a, n)));
                     map' (n+1))
              in
                map' 0
              end
d837 4
a840 4
            fun to_list a =
              let
                fun to_list' (0, list) = list
                  | to_list' (n, list) =
d846 3
a848 3
              in
                to_list' (length a, nil)
              end
d850 3
a852 3
            fun iterate f a =
              let
                val l = length a
d854 1
a854 1
                fun iterate' n =
d858 5
a862 5
                    (f (unsafe_sub (a, n));
                     iterate' (n+1))
              in
                iterate' 0
              end
d864 3
a866 3
            fun iterate_index f a =
              let
                val l = length a
d868 1
a868 1
                fun iterate' n =
d872 5
a876 5
                    (f (n, unsafe_sub (a, n));
                     iterate' (n+1))
              in
                iterate' 0
              end
d878 4
a881 4
            fun rev a =
              let
                val l = length a
                val new = array (l, 0)
d883 2
a884 2
                fun rev' 0 = new
                  | rev' n =
d891 3
a893 3
              in
                rev' l
              end
d895 4
a898 4
            fun duplicate a =
              let
                val l = length a
                val new = array (l, 0)
d900 2
a901 2
                fun duplicate' 0 = new
                  | duplicate' n =
d908 3
a910 3
              in
                duplicate' l
              end
d912 1
a912 1
            exception Subarray of int * int
d914 11
a924 11
            fun subarray (a, start, finish) =
              let
                val l = length a
              in
                if start < 0 orelse start > l orelse finish > l orelse
                   start > finish then
                  raise Subarray (start, finish)
                else
                  let
                    val l' = finish - start
                    val new = array (l', 0)
d926 2
a927 2
                    fun copy 0 = new
                      | copy n =
d934 4
a937 4
                  in
                    copy l'
                  end
              end
d939 5
a943 5
            fun append (array1, array2) =
              let
                val l1 = length array1
                val l2 = length array2
                val new = array (l1+l2, 0)
d945 2
a946 2
                fun copy1 0 = new
                  | copy1 n =
d954 2
a955 2
                fun copy2 0 = copy1 l1
                  | copy2 n =
d962 3
a964 3
              in
                copy2 l2
              end
d966 3
a968 3
            fun reducel f (i, a) =
              let
                val l = length a
d970 1
a970 1
                fun reducel' (i, n) =
d974 4
a977 4
                    reducel' (f (i, unsafe_sub (a, n)), n+1)
              in
                reducel' (i, 0)
              end
d979 3
a981 3
            fun reducer f (a, i) =
              let
                val l = length a
d983 2
a984 2
                fun reducer' (0, i) = i
                  | reducer' (n, i) =
d990 3
a992 3
              in
                reducer' (l, i)
              end
d994 3
a996 3
            fun reducel_index f (i, a) =
              let
                val l = length a
d998 1
a998 1
                fun reducel' (i, n) =
d1002 4
a1005 4
                    reducel' (f (n, i, unsafe_sub (a, n)), n+1)
              in
                reducel' (i, 0)
              end
d1007 3
a1009 3
            fun reducer_index f (a, i) =
              let
                val l = length a
d1011 2
a1012 2
                fun reducer' (0, i) = i
                  | reducer' (n, i) =
d1018 3
a1020 3
              in
                reducer' (l, i)
              end
d1022 1
a1022 1
            exception Copy of int * int * int
d1024 13
a1036 13
            fun copy (from, start, finish, to, start') =
              let
                val l1 = length from
                val l2 = length to
              in
                if start < 0 orelse start > l1 orelse finish > l1 orelse
                   start > finish orelse
                   start' < 0 orelse start' + finish - start > l2 then
                  raise Copy (start, finish, start')
                else
                  let
                    fun copy' 0 = ()
                      | copy' n =
d1043 4
a1046 4
                  in
                    copy' (finish - start)
                  end
              end
d1048 1
a1048 1
            exception Fill of int * int
d1050 11
a1060 11
            fun fill_range (a, start, finish, x) =
              let
                val l = length a
              in
                if start < 0 orelse start > l orelse finish > l orelse
                   start > finish then
                  raise Fill (start, finish)
                else
                  let
                    fun fill' 0 = ()
                      | fill' n =
d1067 4
a1070 4
                  in
                    fill' (finish - start)
                  end
              end
d1072 1
a1072 1
            exception Find
d1074 4
a1077 4
            fun find predicate a =
              let
                val l = length a
                fun find' n =
d1082 3
a1084 3
              in
                find' 0
              end
d1086 4
a1089 4
            fun find_default (predicate, default) a =
              let
                val l = length a
                fun find' n =
a1093 91
              in
                find' 0
              end

          end

        structure String : STRING =
          struct
            open BuiltinLibrary_
            exception Substring = Substring

            val unsafe_substring : (string * int * int) -> string =
              call_c "string unsafe substring"
            fun substring (s, i, n) =
              if n < 0 then raise Substring
              else if i < 0 then raise Substring
              else if i > size s - n then raise Substring
              else if n > 12 then unsafe_substring (s, i, n)
              else
                let
                  val new_s = alloc_string (n + 1)
                  fun copy 0 = new_s
                  |   copy j =
                    let
                      val j' = j - 1
                    in
                      string_unsafe_update
                         (new_s, j', string_unsafe_sub (s, i+j'));
                      copy j'
                    end
                in
                  string_unsafe_update (new_s, n, 0);
                  copy n
                end;

            val c_implode_char : int list * int -> string = call_c "string c implode char"

            (* For more than ~30 characters this is slower than the C function *)
            (* We could do something similar with implode too *)
            fun implode_char cl : string =
              let
                fun copyall ([],start,to) = to
                  | copyall (c::cl,start,to) =
                    (string_unsafe_update (to,start,c);
                     copyall (cl,start+1,to))
                fun get_size (a::rest,sz) = get_size (rest,1 + sz)
                  | get_size ([],sz) = 
                    if sz > 30 then c_implode_char (cl,sz)
                    else
                      let
                        val result = alloc_string (sz+1)
                        (* set the null terminator *)
                        val _ = string_unsafe_update (result,sz,0)
                      in
                        copyall (cl,0,result)
                      end
              in
                get_size (cl,0)
              end

	    fun ml_string (s,max_size) =
	      let
		fun to_digit n = chr (n +ord "0")

		fun aux ([],result,_) = implode (rev result)
		  | aux (_,result,0) = implode (rev ("\\..." :: result))
		  | aux (char::rest,result,n) =
		    let val newres =
		      case char of 
			"\n" => "\\n"::result
		      | "\t" => "\\t"::result
		      | "\"" => "\\\""::result
		      | "\\" => "\\\\"::result
		      | c =>
			  let val n = ord c
			  in
			    if n < 32 orelse n >= 127 then
			      let
				val n1 = n div 10
			      in
				(to_digit (n mod 10))::
				(to_digit (n1 mod 10))::
				(to_digit (n1 div 10))::
				"\\" :: result
			      end
			    else
			      c::result
			  end
		    in
		      aux (rest, newres, n-1)
		    end
d1095 1
a1095 1
		aux (explode s,[],if max_size < 0 then ~1 else max_size)
d1098 1
a1098 12
            (* Finally define these *)
            val op <  : string * string -> bool = string_less
            val op >  : string * string -> bool = string_greater
            val op <= : string * string -> bool = string_less_equal
            val op >= : string * string -> bool = string_greater_equal

          end

        structure Bits : BITS =
          struct
            open BuiltinLibrary_
          end
d1159 1
a1159 1
		 
d1185 1
a1185 1
		
d1305 379
a1756 12
	    (*
            structure Architecture =
              struct
                datatype name = SPARC
                fun name () = SPARC

                structure SPARC =
                  struct
                    val flush_windows = call_c "stack flush"
                  end
              end
	    *)
a2344 38
	structure Vector : VECTOR =
	  struct
	    open BuiltinLibrary_
            type 'a vector = 'a vector
            fun length' ([],n) = n
              | length' (a::b,n) = length' (b,unsafe_int_plus (n,1))
            fun length l = length' (l,0)
            fun update ([],n,v) = ()
              | update (a::rest,n,v) = 
                (record_unsafe_update (v,n,a);
                 update (rest,unsafe_int_plus (n,1),v))
            
            (* This is going to override the definition in the builtin library *)
            fun vector (l : 'a list) : 'a vector =
              let
                val len = length l
                val result = alloc_vector len
                val _ = update (l,0,result)
              in
                result
              end

	    fun tabulate(i, f) =
	      if i < 0 then
		raise Size
	      else
		let
		  fun make_list(done, j) =
		    if j >= i then done
		    else
		      make_list(f j :: done, j+1)
		in
		  vector (rev (make_list([], 0)))
		end
	    val sub = vector_sub
	    val length = vector_length
	  end

a2362 3
    structure Array = MLWorks.Array
    structure ExtendedArray = MLWorks.ExtendedArray
    structure Vector = MLWorks.Vector
a2409 9

signature ARRAY = ARRAY;
signature EXTENDED_ARRAY = EXTENDED_ARRAY;
signature VECTOR = VECTOR;
signature MLWORKS = MLWORKS;
signature STRING = STRING;
signature BITS = BITS;
signature CHAR = CHAR;

@


1.172
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d13 6
d1566 26
a1591 1
	val deliver : string * (unit -> unit) * bool -> unit = call_c "function deliver"
@


1.171
log
@Removing Real structure
@
text
@d13 3
a606 1
    val chr                   : int -> string
a610 2
    val explode               : string -> string list
    val implode               : string list -> string
a614 1
    val ord                   : string -> int
a618 16
      
    type instream
    sharing type instream = MLWorks.IO.instream
    type outstream
    sharing type outstream = MLWorks.IO.outstream
      
    val std_in                : instream
    val std_out               : outstream
    val open_in               : string -> instream
    val open_out              : string -> outstream
    val end_of_stream         : instream -> bool
    val input                 : instream * int -> string
    val lookahead             : instream -> string
    val output                : outstream * string -> unit
    val close_in              : instream -> unit
    val close_out             : outstream -> unit
@


1.170
log
@Modifications to deliver and save
@
text
@d13 3
a2290 6
	  end

	structure Real =
	  struct
	    val makestring = Internal.real_to_string
	    fun print r = IO.output(IO.std_out, makestring r)
@


1.169
log
@Put MLWorks.exit back to enable boostrapping from older compilers.
@
text
@d13 3
d1574 1
a1574 5

        exception Save of string
        val save : string * (unit -> 'a) -> unit -> 'a = fn x => call_c "image save" x
	val deliver : string * (unit -> unit) -> unit = call_c "function deliver"
	val exec_save = fn x => call_c "exec image save" x
d1578 3
d2401 1
a2401 1
           SaveExn		:= MLWorks.Save "";
@


1.168
log
@Removing some exceptions
@
text
@d13 3
d644 2
@


1.167
log
@Remove exit, terminate, atExit and most of the OS structure since
they are no longer needed now that OS.Process has been updated.
@
text
@d13 4
a573 1
    exception Abs
a575 1
    exception Diff
a577 1
    exception Floor
a581 2
    exception Mod
    exception Neg
a583 2
    exception Prod
    exception Quot
a584 1
    exception Sum
a2366 1
      val DiffExn =			call_c "exception Diff"
a2367 1
      val FloorExn =			call_c "exception Floor"
a2368 2
      val ModExn =			call_c "exception Mod"
      val ProdExn =			call_c "exception Prod"
a2370 1
      val QuotExn =			call_c "exception Quot"
a2372 2
      val SumExn =			call_c "exception Sum"
      val AbsExn =			call_c "exception Abs"
a2386 2
           AbsExn		:= Abs;
           DiffExn		:= Diff;
a2388 1
           FloorExn		:= Floor;
a2391 1
           ModExn		:= Mod;
a2392 1
           ProdExn		:= Prod;
a2393 1
           QuotExn		:= Quot;
a2398 1
           SumExn		:= Sum;
d2415 1
@


1.166
log
@Changes for value polymorphism
@
text
@d13 3
a645 19
	val exit_fns = ref [] : (unit -> unit) list ref

	fun atExit atExitFn =
	  exit_fns := !exit_fns @@ [atExitFn]

        val terminate : int -> unit = call_c "system exit"

	fun do_exit_fns () =
	  case !exit_fns of
	    [] => ()
	  | f :: fs => (exit_fns := fs; f(); do_exit_fns())

	fun exit exit_val =
	  let
	    val _ = do_exit_fns()
	  in
	    terminate exit_val
	  end

a2294 4
            datatype name = UNIX | WIN_NT
            fun name () = UNIX

            val system : string -> int = call_c "system os system"
a2295 1

@


1.165
log
@Changed MLWorks.Internal.Dynamic types to new identifier convention.
@
text
@d13 3
d648 1
a648 1
        val terminate = call_c "system exit"
d1018 3
a1020 3
            val to_string = call_c "bytearray to string"
            val from_string = call_c "bytearray from string"
            val substring = call_c "bytearray substring"
d1478 2
a1479 2
            val open_in = call_c "stream open in"
            val open_out = call_c "stream open out"
d1493 94
d1588 3
a1590 3
        val save = call_c "image save"
	val deliver = call_c "function deliver"
	val exec_save = call_c "exec image save"
d1594 1
a1594 1
            val real_to_string = call_c "real to string"
d1596 1
a1596 1
            val string_to_real = call_c "real from string"
d1603 1
a1603 1
		val clean = call_c "clean code vectors"
d1605 1
a1605 1
		val table = call_c "image table"
d1652 5
a1656 5
                val ccast = call_c "value cast"
                val list_to_tuple = call_c "value list to tuple"
                val tuple_to_list = call_c "value tuple to list"
                val string_to_real = call_c "value string to real"
                val real_to_string = call_c "value real to string"
d1685 13
a1697 13
                val print = call_c "value print"
                val primary = call_c "value primary"
                val header = call_c "value header"
                val pointer = call_c "value pointer"
                val update = call_c "value update value"
                val sub = call_c "value sub value"
                val update_byte = call_c "value update byte"
                val sub_byte = call_c "value sub byte"
                val update_header = call_c "value update header"
                val code_name = call_c "value code name"
                val exn_name = call_c "value exn name"
                val exn_argument = call_c "value exn argument"
                val exn_name_string = call_c "value exn name string"
d1702 10
a1711 10
                    val sub = call_c "stack frame sub"
                    val update = call_c "stack frame update"
                    val current = call_c "stack frame current"
                    val is_ml_frame = call_c "stack is ml frame"

                    val frame_call = call_c "debugger frame call"
                    val frame_next = call_c "debugger frame next"
                    val frame_offset = call_c "debugger frame offset"
		    val frame_double = call_c "debugger frame double"
                    val frame_allocations = call_c "debugger frame allocations"
d1731 4
a1734 4
                val intercept = call_c "trace intercept"
                val replace = call_c "trace replace"
                val restore = call_c "trace restore"
		val restore_all = call_c "trace restore all"
d1739 1
a1739 1
                val status = call_c "trace status"
d1747 2
a1748 2
                val seekf = call_c "stream seek out"
                val openf = call_c "stream open update"
d1750 1
a1750 1
		val write_byte = RawIO.output_byte
d1752 1
a1752 1
                val writebf = call_c "stream output bytearray"
d1771 1
a1771 1
                  fun coerce (d,t) =
d1785 1
a1785 1
                val modules = call_c "system module root"
d1790 9
a1798 2
                    val load_module = call_c "system load link"
                    val load_wordset = call_c "system load wordset"
d1803 6
a1808 6
		    val max_stack_blocks = call_c "mem max stack blocks"
		    val gc_message_level = call_c "gc message level"
		    val collect = call_c "gc collect generation"
		    val collect_all = call_c "gc collect all"
		    val promote_all = call_c "gc promote all"
		    val collections = call_c "gc collections"
d1815 1
a1815 1
                    val signal = call_c "event signal"
d1817 2
a1818 2
		    val stack_overflow_handler = call_c "event signal stack overflow"
		    val interrupt_handler = call_c "event signal interrupt"
a1822 94
        structure Time =
          struct
            structure Interval =
              struct
                datatype T = INTERVAL of Internal.Value.T

		val to_real = call_c "interval to real"
		val from_real = call_c "interval from real"

		(* can use time add, time sub, and time less because
		 * our time and interval representations happen to be
		 * the same *)

		val op- = call_c "time subtract"
		val op+ = call_c "time add"
		val op< = call_c "time less"

		val real_mul = op* : real*real->real
		val real_div = op/ : real*real->real

		fun x*y = from_real(real_mul((to_real x),y))
		fun x/y = from_real(real_div((to_real x),y))

		val c_format = call_c "time to string"
		val decimal_places = ref 2
		fun format x = c_format (x,!decimal_places)
	      end
		 
	    structure Elapsed =
	      struct
		datatype T = ELAPSED of {real: Interval.T,
					 user: Interval.T,
					 system: Interval.T,
					 gc: Interval.T}
		  
		val elapsed = call_c "time elapsed"
		val elapsed_since = call_c "time elapsed since"

		fun project_interval_fn f (ELAPSED{real=real1,
						   user=user1,
						   system=sys1,
						   gc = gc1},
					   ELAPSED{real=real2,
						   user=user2,
						   system=sys2,
						   gc = gc2})
		  = ELAPSED {real = f(real1,real2),
			     user = f(user1,user2),
			     system = f(sys1,sys2),
			     gc = f (gc1,gc2)}
		  
		val op- = project_interval_fn (Interval.-)
		val op+ = project_interval_fn (Interval.+)
		
		fun project_interval_real_fn f (ELAPSED{real,user,system,gc},
						x) =
		  ELAPSED{real= f(real,x),
			  user = f(user,x),
			  system = f(system,x),
			  gc = f(gc,x)}

		val op* = project_interval_real_fn (Interval.* )
		val op/ = project_interval_real_fn (Interval./ )

		fun format (ELAPSED {real,user,system,gc}) =
		  implode [Interval.format real,
			   " (user: ",
			   Interval.format user,
			   ", system: ",
			   Interval.format system,
			   ", gc: ",
			   Interval.format gc, ")"]

	      end

	    datatype time = TIME of Internal.Value.T

	    val zero = call_c "time zero"
	    val now = call_c "time now"
	    val op< = call_c "time less"

	    val interval = call_c "time interval"

	    val (op-) = call_c "time subtract"
	    val (op+) = call_c "time add"

	    datatype zone = GREENWICH | LOCAL
	    val format = call_c "time format"

	    val encode = call_c "time encode"
	    val decode = call_c "time decode"
	  end


d1839 1
a1839 1
	      val identity = Internal.Value.cast (fn x => x)
d1843 1
a1843 1
	      val c_fork = (call_c "thread fork") : (unit -> 'b) -> 'b thread
d1849 2
a1850 2
	      val sleep = (call_c "thread sleep") : 'a thread -> unit
	      val wake  = (call_c "thread wake")  : 'a thread -> unit
d1856 1
a1856 1
		  val id = call_c "thread current thread"
d1858 3
a1860 3
		  val children = call_c "thread children"
		  val parent = call_c "thread parent"
		  val all = call_c "thread all threads"
d1862 4
a1865 4
		  val kill = call_c "thread kill"
		  val raise_in = call_c "thread raise"
		  val yield_to = call_c "thread yield to"
		  val set_handler = call_c "thread set fatal handler"
d1867 1
a1867 1
		  val reset_fatal_status = call_c "thread reset fatal status"
d1869 1
a1869 1
		  val get_num = call_c "thread number"
d1883 5
a1887 7
		      val start = call_c "thread start preemption"
		      val stop = call_c "thread stop preemption"
		      val on = call_c "thread preempting"
		      val get_interval =
			call_c "thread get preemption interval"
		      val set_interval =
			call_c "thread set preemption interval"
d1968 1
a1968 1
            val with_standard_input = with_input flex_std_in
d2057 1
a2057 1
            val with_standard_output = with_output flex_std_out
d2069 1
a2069 1
            val with_standard_error = with_output flex_std_err
d2071 1
a2071 1
            val file_modified = call_c "time file modified"
d2077 1
a2077 1
            val set_file_modified = call_c "time set file modified"
d2193 1
a2193 1
	      val rts_profile = call_c "profile" :
d2314 2
a2315 2
            val system = call_c "system os system"
            val arguments = call_c "system os arguments"
@


1.164
log
@Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
some functionality to the Shell structure.
@
text
@d13 4
d1660 2
a1661 2
                type Dynamic = Dynamic
                type Type = Type
d1663 1
a1663 1
                exception Coerce of Type * Type
d1665 1
a1665 1
                val generalises_ref : (Type * Type -> bool) ref =
@


1.163
log
@"fn_save" becomes "deliver".
@
text
@d13 3
d1654 25
a2313 22
        structure Dynamic =
          struct
            type Dynamic = Dynamic
            type Type = Type
                  
            exception Coerce of Type * Type
            exception NoGeneralises

            val generalises_ref : (Type * Type -> bool) ref =
              ref (fn (t,t') => raise NoGeneralises)
            fun generalises data = (!generalises_ref) data

            val get_type = Internal.Value.cast (fn (a,b) => b)
            val get_value = Internal.Value.cast (fn (a,b) => a)

            (* rely on generalises raising an exception *)
            fun coerce (d,t) =
              (if generalises (get_type d,t)
                 then get_value d
               else raise Coerce(get_type d,t))
          end
            
@


1.162
log
@Add Overflow at top level
@
text
@d13 3
d1485 1
a1485 1
	val fn_save = call_c "function save"
@


1.161
log
@Simplifying treatment of pervasive exceptions
@
text
@d13 3
d568 1
@


1.160
log
@OS reorganisation: remove the Unix and NT code as it is going elsewhere.
@
text
@d13 3
d1677 1
a1677 67

		structure Exception =
		  struct

		    (* Remove the constructor status from the
		       exception names so that they can be rebound. *)
		    structure S :
		      sig
			type T
			val Diff : T
			val Div : T
			val Floor : T
			val Io : T
			val Mod : T
			val Overflow : T
			val Prod : T
			val Profile : T
			val Quot : T
			val Save : T
			val Substring : T
			val Sum : T
                        val Abs : T
                        val Exp : T
                        val Ln : T
                        val Load : T
                        val Signal : T
                        val Sqrt : T
                        val StringToReal : T
                        val Trace : T
                        val Unbound : T
                        val Value : T
		      end =
		      struct
			datatype T =
                          Io | Prod | Mod | Div | Substring | Save |
                          Profile | Value | Load | Unbound | Signal |
                          Abs | Sqrt | StringToReal | Ln | Exp |
                          Sum | Diff | Quot | Floor | 
                          Trace | Overflow
		      end
		    open S
		      
		    val Diff =			call_c "exception Diff"
		    val Div =			call_c "exception Div"
		    val Floor =			call_c "exception Floor"
		    val Io =			call_c "exception Io"
		    val Mod =			call_c "exception Mod"
		    val Prod =			call_c "exception Prod"
		    val Overflow =		call_c "exception Overflow"
		    val Profile =		call_c "exception Profile"
		    val Quot =			call_c "exception Quot"
		    val Save =			call_c "exception Save"
		    val Substring =		call_c "exception Substring"
		    val Sum =			call_c "exception Sum"
                    val Abs =			call_c "exception Abs"
                    val Exp =			call_c "exception Exp"
                    val Ln =			call_c "exception Ln"
                    val Load =			call_c "exception Load"
                    val Signal =		call_c "exception Signal"
                    val Sqrt =			call_c "exception Sqrt"
                    val StringToReal = 		call_c "exception StringToReal"
                    val Trace =			call_c "exception Trace"
                    val Unbound =		call_c "exception Unbound"
                    val Value =			call_c "exception Value"
		  end
	      end
            
a2353 1

d2355 1
a2355 1

d2363 1
d2365 52
a2416 1
    open MLWorks.IO
d2418 1
a2418 28
    val _ =
      let
        open MLWorks.Internal.Runtime
      in
        Exception.Abs		:= Abs;
        Exception.Diff		:= Diff;
        Exception.Div		:= Div;
        Exception.Exp		:= Exp;
        Exception.Floor		:= Floor;
        Exception.Io		:= Io "";
        Exception.Ln		:= Ln;
        Exception.Load		:= MLWorks.Internal.Runtime.Loader.Load "";
        Exception.Mod		:= Mod;
	Exception.Overflow	:= Overflow;
        Exception.Prod		:= Prod;
        Exception.Profile	:= MLWorks.Profile.ProfileError "";
        Exception.Quot		:= Quot;
        Exception.Save		:= MLWorks.Save "";
        Exception.Signal	:= MLWorks.Internal.Runtime.Event.Signal "";
        Exception.Sqrt		:= Sqrt;
        Exception.StringToReal	:= MLWorks.Internal.StringToReal;
        Exception.Substring	:= String.Substring;
        Exception.Sum		:= Sum;
        Exception.Trace		:= MLWorks.Internal.Trace.Trace "";
        Exception.Unbound	:= MLWorks.Internal.Runtime.Unbound "";
        Exception.Value		:= MLWorks.Internal.Value.Value ""
      end
  end;
@


1.159
log
@Change to GC interface.
@
text
@d13 3
a1703 1
                        val Unix : T
a1704 1
                        val WouldBlock : T
d1711 1
a1711 1
                          Sum | Diff | Quot | Floor | Unix | WouldBlock |
a1736 1
                    val Unix =			call_c "exception Unix"
a1737 1
                    val WouldBlock =		call_c "exception Would Block"
a2332 65
            structure Unix =
              struct
                exception Unix of string
                exception WouldBlock
                datatype sockaddr = SOCKADDR_UNIX of string
                val environment = call_c "system os unix environment"
                val setwd = call_c "system os unix setwd"
                val getwd = call_c "system os unix getwd"
                val realpath = call_c "system os unix realpath"
                val rusage = call_c "system os unix rusage"
                val stat = call_c "system os unix stat"
                val open_ = call_c "system os unix open"
                val close = call_c "system os unix close"
                val unlink = call_c "system os unix unlink"
                val set_block_mode = call_c "system os unix set block mode"
                val can_input = call_c "system os unix can input"
                val seek = call_c "system os unix seek"
                val write = call_c "system os unix write"
                val read = call_c "system os unix read"
                val socket = call_c "system os unix socket"
                val bind = call_c "system os unix bind"
                val getsockname = call_c "system os unix getsockname"
                val getpeername = call_c "system os unix getpeername"
                val connect = call_c "system os unix connect"
                val accept = call_c "system os unix accept"
                val listen = call_c "system os unix listen"
                val execve = call_c "system os unix execve"
                val execv = call_c "system os unix execv"
                val execvp = call_c "system os unix execvp"
                val vfork_execve = call_c "system os unix vfork_execve"
                val vfork_execv = call_c "system os unix vfork_execv"
                val vfork_execvp = call_c "system os unix vfork_execvp"
                datatype dir = DIR of Internal.Value.T
                val opendir = call_c "system os unix opendir"
                val readdir = call_c "system os unix readdir"
                val closedir = call_c "system os unix closedir"
                val mkdir = call_c "system os unix mkdir"
                val rmdir = call_c "system os unix rmdir"
                datatype passwd =
                  PASSWD of {dir	: string,
                             gecos	: string,
                             gid	: int,
                             name	: string,
                             passwd	: string,
                             shell	: string,
                             uid	: int}
                val getpwent = call_c "system os unix getpwent"
                val setpwent = call_c "system os unix setpwent"
                val endpwent = call_c "system os unix endpwent"
                val getpwuid = call_c "system os unix getpwuid"
                val getpwnam = call_c "system os unix getpwnam"
                val kill = call_c "system os unix kill"
              end

	    structure Win_nt =
	      struct
		exception Nt of int
                val environment = call_c "system os win_nt environment"
		val get_current_directory = call_c"system os win_nt getcd"
		val get_path_name = call_c"system os win_nt get_path_name"
                type DirHandle = int
                val find_first_file : string -> string * DirHandle = call_c "system os win_nt find_first_file"
                val find_next_file : DirHandle -> string = call_c "system os win_nt find_next_file"
                val find_close : DirHandle -> unit = call_c "system os win_nt find_close"
	      end
d2455 1
a2455 3
        Exception.Unix		:= MLWorks.OS.Unix.Unix "";
        Exception.Value		:= MLWorks.Internal.Value.Value "";
        Exception.WouldBlock	:= MLWorks.OS.Unix.WouldBlock
@


1.158
log
@Adding NT directory operations
@
text
@d13 3
d1652 1
a1652 1
		structure StorageManager =
d1654 1
d1656 4
a1659 2
                    exception StorageManager of int
                    val interface = call_c "storeman interface"
a1697 1
                        val StorageManager : T
d1710 2
a1711 2
                          StorageManager | Sum | Diff | Quot | Floor |
                          Unix | WouldBlock | Trace | Overflow
a1732 1
                    val StorageManager =	call_c "exception StorageManager"
a2515 1
        Exception.StorageManager:= MLWorks.Internal.Runtime.StorageManager.StorageManager 0;
@


1.157
log
@Add thread sleep and wake operations.
@
text
@d13 3
d2390 4
@


1.156
log
@Add FullPervasiveLibrary_.MLWorks.Threads.Internal.reset_signal_status.
@
text
@d13 3
d1856 4
a1859 1
		
@


1.155
log
@Remove signal reservation.
@
text
@d13 3
d1869 2
@


1.154
log
@pervasive module names now begin with a space.
@
text
@d13 3
a1651 4

		    val reserve_signal = call_c "event signal reserve"
		    val release_signal = call_c "event signal release"
		    val signal_reserved = call_c "event signal reserved"
@


1.153
log
@Add Frame.frame_double for accessing directly spilled reals
@
text
@d13 3
d511 7
a517 7
require "__builtin_library";
require "mlworks";
require "string";
require "array";
require "vector";
require "bytearray";
require "bits";
@


1.152
log
@Add exec_save for saving executables
@
text
@d13 3
d1575 1
@


1.151
log
@Lifting call to call_c in substring
@
text
@d13 3
d1452 1
@


1.150
log
@Add function save to MLWorks for use by exportFn
@
text
@d13 3
d1317 2
d1322 2
a1323 7
              else if i+n > size s then raise Substring
              else if n > 12 then
		let val ss: (string * int * int) -> string =
		      call_c "string unsafe substring"
		in
		  ss (s, i, n)
		end
@


1.149
log
@Added types for different sizes of words and integers.
@
text
@d13 3
d1448 1
@


1.148
log
@Add ml_char for giving textual representation of chars
@
text
@d1370 2
a1371 2
		    let
		      val newres = case char of 
d1377 1
a1377 2
			  let
			    val n = ord c
d1462 34
d1568 1
d1579 1
d2437 2
d2441 1
a2445 43

	    fun ml_char c = String.ml_string(chr(char_ord c), ~1)
	      
	    val chr = char_chr
	    val ord = char_ord
	  end

	structure Word =
	  struct
	    open BuiltinLibrary_
	    type word = word
	    val wordSize = 30
	    val orb = word_orb
	    val xorb = word_xorb
	    val andb = word_andb
	    val notb = word_notb
	    val op+ = word_plus
	    val op- = word_minus
	    val op* = word_star
	    val op div = word_div
	    val op mod = word_mod
	    val lshift = word_lshift
	    val rshift = word_rshift
	    val arshift = word_arshift
	    val op < = word_less
	    val op > = word_greater
	    val op <= = word_less_equal
	    val op >= = word_greater_equal

	    fun makedigits aword =
	      let
		val digit = aword mod 0w10
		val new_word = aword div 0w10
	      in
		(if new_word <> 0w0
		   then makedigits new_word
		 else
		   "") ^
		   chr(wordToInt(digit + 0w48))
	      end

	    fun makestring aword = "0w" ^ makedigits aword

d2456 1
a2456 1
    structure Word = MLWorks.Word
a2500 1
signature WORD = WORD;
@


1.147
log
@Remove div and mod from FullPervasiveLibrary signature
@
text
@d13 3
d1370 2
a1371 2
		    let val newres =
		      case char of 
d1377 2
a1378 1
			  let val n = ord c
a2401 2
	    val chr = char_chr
	    val ord = char_ord
a2403 1
	    (* Finally define these *)
d2408 5
@


1.146
log
@Add makestring to word signature and structure
@
text
@d13 3
a535 1
    val div                   : int * int -> int
a548 1
    val mod                   : int * int -> int
@


1.145
log
@Add Words signature and structure
@
text
@d13 3
d2429 15
@


1.144
log
@Add exception Overflow
@
text
@d13 3
d2405 23
d2436 1
d2481 1
@


1.143
log
@Two constructors called MLWorks.Profile.Profile.
@
text
@d13 3
d1596 1
a1596 1
            
d1610 1
d1637 1
a1637 1
                          Unix | WouldBlock | Trace
d1647 1
d2426 1
@


1.142
log
@Whoops; major type screwups in new profiler.
@
text
@d13 3
d2124 1
a2124 1
	    exception Profile of string
d2422 1
a2422 1
        Exception.Profile	:= MLWorks.Profile.Profile "";
@


1.141
log
@Change to profiler interface.
@
text
@d13 3
d2076 2
a2077 2
	       period: MLWorks.Time.Interval.T,
	       suspended: MLWorks.Time.Interval.T}
d2100 1
a2100 2
	    type cost_header
	    sharing cost_header = unit
@


1.140
log
@Add hex integer printing facilities
@
text
@d13 3
d2012 145
a2156 23
            datatype options =
              OPTIONS of {depth		: int,
                          scan		: int,
                          select	: string list}

            exception Profile of string

            local
              datatype 'a result = RESULT of 'a | EXCEPTION of exn
              val p = call_c "profile"
            in
              fun profile options outstream f a =
                let
                  fun wrapper () =
                    RESULT (f a)
                    handle exn => EXCEPTION exn
		  fun write string = IO.output(outstream,string)
                in
                  case p (options, write, wrapper) of
                    RESULT r => r
                  | EXCEPTION exn => raise exn
                end
            end
@


1.139
log
@Add Char structure
@
text
@d13 3
a479 19
signature CHAR =
  sig

    eqtype char

    exception Chr

    val chr : int -> char
    val ord : char -> int

    val maxCharOrd : int

    val <  : (char * char) -> bool
    val <= : (char * char) -> bool
    val >  : (char * char) -> bool
    val >= : (char * char) -> bool

  end; (* CHAR *)

d2040 2
a2041 2
		    anint mod 10 
		  else 
d2067 38
d2251 16
d2274 1
a2274 16

    structure Char : CHAR =
      struct
	open BuiltinLibrary_

	type char = char
	val chr = char_chr
	val ord = char_ord
	val maxCharOrd = 255

	(* Finally define these *)
	val op <  : char * char -> bool = op <
	val op >  : char * char -> bool = op >
	val op <= : char * char -> bool = op <=
	val op >= : char * char -> bool = op >=
      end
d2317 1
@


1.138
log
@Change threads restart system.
@
text
@d13 3
d477 19
d504 1
a504 1

d2236 16
@


1.137
log
@Adding ML definition of implode_char
Moving definition of append etc to builtin_library
@
text
@d13 4
d1784 1
a1784 1
		  val set_restart = call_c "thread set restart"
@


1.136
log
@Added ML version of substring.
@
text
@d13 3
a554 68
    (* And now we redefine append *)
    (* This function does 2 scans of the first list *)
    (* The first scan, aux1, builds a list of cons cells on *)
    (* the front of the second list *)
    (* The second scan, aux2, destructively updates the new cells *)
    (* to the contents of the first list *)
    (* Note that this is safe for GC *)
    local
      fun aux2 ([],_,res) = res
        | aux2 (a::b,cell,res) =
          (record_unsafe_update (cell,0,a);
           aux2 (b,record_unsafe_sub (cell,1),res))

      fun aux1 ([],res,x) = aux2 (x,res,res)
        | aux1 (a::b,y,x) = 
          let
            val cell = cast (0,y)
          in
            aux1 (b,cell,x)
          end
    in
      (* Wrap this in a test for short cases *)
      fun op @@ (nil,l) = l
        | op @@ ([a],l) = a::l
        | op @@ ([a,b],l) = a::b::l
        | op @@ ([a,b,c],l) = a::b::c::l
        | op @@ ([a,b,c,d],l) = a::b::c::d::l
        | op @@ ([a,b,c,d,e],l) = a::b::c::d::e::l
        | op @@ ([a,b,c,d,e,f],l) = a::b::c::d::e::f::l
        | op @@ ([a,b,c,d,e,f,g],l) = a::b::c::d::e::f::g::l
        | op @@ ([a,b,c,d,e,f,g,h],l) = a::b::c::d::e::f::g::h::l
        | op @@ (a::b::c::d::e::f::g::h::r,l) = a::b::c::d::e::f::g::h:: aux1(r,l,r)
    end 

    (* Redefine the explode function!! *)
    local
      val chars = array (256,"");
      fun setup 256 = ()
        | setup n = (update (chars,n,chr n);
                     setup (n+1))
      val _ = setup 0
    in
      fun explode s : string list =
        let
          (* loop unrolled once *)
          (* chars passed as function argument (so goes in register) *)
          fun aux (n,acc,chars) =
            if n <= 1
              then
                if n = 1
                  then unsafe_sub (chars,string_unsafe_sub (s,0)) :: acc
                else acc
            else
              let
                val n' = n-1
                val n'' = n-2
              in
                aux (n'',
                     unsafe_sub (chars,string_unsafe_sub (s,n'')) ::
                     unsafe_sub (chars,string_unsafe_sub (s,n')) :: 
                     acc,
                     chars)
              end
        in
          aux (size s, [], chars)
        end
    end

d1280 3
a1282 3
              if n < 0 then raise Subscript
              else if i < 0 then raise Subscript
              else if i+n > size s then raise Subscript
d1306 25
d1354 1
a1354 1
				("\\")::result
d1363 1
a1363 1
		aux (explode s,[],if max_size<0 then ~1 else max_size)
d1366 1
a1370 2

            val implode_char : int list -> string = call_c "string implode char"
@


1.135
log
@Add threads interface
@
text
@d13 3
d1343 28
a1370 1
            val substring : string * int * int -> string = call_c "string substring"
@


1.134
log
@Adding flush to with_standard_output
Adding explode function
@
text
@d13 4
d1751 67
@


1.133
log
@Changed argument of Unix exception from int to string.
Added OS.Unix.{stat,seek,set_block_mode,can_input}.
@
text
@d13 4
d539 1
d578 35
a612 1
    
d1885 1
a1885 1
                val result = f () handle exn => (refstream := oldstream; raise exn)
d1887 1
@


1.132
log
@Adding CAST and UMAP primitives
Adding new append function
Removing stuff from debugger structure
@
text
@d13 5
d1571 1
a1572 1
                        val Unbound : T
d1574 1
d1582 1
a1582 1
                          Unix | Trace
d1609 1
d1975 2
a1976 1
                exception Unix of int
d1983 1
d1987 3
d2138 3
a2140 2
        Exception.Unix		:= MLWorks.OS.Unix.Unix 0;
        Exception.Value		:= MLWorks.Internal.Value.Value ""
@


1.131
log
@Speed improvements to input_line: don't call end_of_stream each time
@
text
@d13 3
d535 34
d1402 2
a1403 1
                val cast = call_c "value cast"
a2028 15

            val set_step_hook = ref(fn _ : (int * string) => IO.output(IO.std_out,"No definition for set_step"))
            fun set_step arg = (!set_step_hook) arg

            val set_breakpoint_hook = ref(fn _ : string => IO.output(IO.std_out,"No definition for set_breakpoint"))
            fun set_breakpoint arg = (!set_breakpoint_hook) arg
            val set_breakpoint_on_exit_hook = ref(fn _ : string => IO.output(IO.std_out,"No definition for set_breakpoint"))
            fun set_breakpoint_on_exit arg = (!set_breakpoint_on_exit_hook) arg
            val delete_breakpoint_hook = ref(fn _ : string => IO.output(IO.std_out,"No definition for delete_breakpoint"))
            fun delete_breakpoint arg = (!delete_breakpoint_hook) arg
            val delete_breakpoints_hook = ref (fn () => IO.output(IO.std_out,"No definition for delete_breakpoints"))
            fun delete_breakpoints arg = (!delete_breakpoints_hook) arg
            val list_breakpoints_hook = ref(fn _ : unit => (IO.output(IO.std_out,"No definition for list_breakpoints");[]:string list))
            fun list_breakpoints arg = (!list_breakpoints_hook) arg
            val script : string list ref = ref []
@


1.130
log
@Change atExit to define a list of functions to be executed
@
text
@d13 3
d1744 7
a1750 9
		  if end_of_stream file then
		    implode(rev line)
		  else
		    let
		      val char = input(file, 1)
		    in
		      if char = "\n" then implode(rev("\n" :: line))
		      else extend_line(char :: line)
		    end
@


1.129
log
@Add terminate, atExit functions
@
text
@d13 3
d532 1
a532 1
	val default_exit_fn = fn _ => ()
d534 2
a535 1
	val exit_fn = ref default_exit_fn
d537 1
a537 1
	fun atExit atExitFn = exit_fn := atExitFn
d539 4
a542 1
        val terminate = call_c "system exit"
d546 1
a546 3
	    val atExitFn = !exit_fn
	    val _ = exit_fn := default_exit_fn
	    val _ = atExitFn ()
@


1.128
log
@Adding implode_char function
@
text
@d13 3
d529 16
a544 1
        val exit = call_c "system exit"
@


1.127
log
@Unifying Value.Frame and Frame.pointer
@
text
@d13 3
d1269 2
@


1.126
log
@Add Win_nt.get_current_directory
Add Win_nt.get_path_name
@
text
@d13 4
d1380 14
a1393 6
                datatype frame = FRAME of int
                val frame_call = call_c "debugger frame call"
                val frame_next = call_c "debugger frame next"
                val frame_sub = call_c "debugger frame sub"
                val frame_offset = call_c "debugger frame offset"
                val frame_allocations = call_c "debugger frame allocations"
a1403 7
                    structure Frame =
                      struct
                        datatype pointer = POINTER of int
                        val sub = call_c "stack frame sub"
                        val update = call_c "stack frame update"
                        val current = call_c "stack frame current"
                      end
a1958 1
            datatype 'a option = ABSENT | PRESENT of 'a
d1962 2
a1963 7
            val step_hook = 
              ref(fn _ : string*exn option => ())
            fun step s = (!step_hook) s
            (* ... runtime call created by lambda translator; 
               if this is changed, will have to change the Lambda Translator accordingly *)
            val set_step_hook = 
              ref(fn _ : (int * string) => IO.output(IO.std_out,"No definition for set_step"))
d1965 2
a1966 7
            val breakpoint_hook = 
              ref(fn _ : string => ())
            fun breakpoint s = (!breakpoint_hook) s
            (* ... runtime call created by lambda translator; 
               if this is changed, will have to change the Lambda Translator accordingly *)
            val set_breakpoint_hook = 
              ref(fn _ : string => IO.output(IO.std_out,"No definition for set_breakpoint"))
d1968 1
a1968 7
            val breakpoint_on_exit_hook = 
              ref(fn _ : string => ())
            fun breakpoint_on_exit s = (!breakpoint_on_exit_hook) s
            (* ... runtime call created by lambda translator; 
               if this is changed, will have to change the Lambda Translator accordingly *)
            val set_breakpoint_on_exit_hook = 
              ref(fn _ : string => IO.output(IO.std_out,"No definition for set_breakpoint"))
d1970 1
a1970 2
            val delete_breakpoint_hook = 
              ref(fn _ : string => IO.output(IO.std_out,"No definition for delete_breakpoint"))
d1972 1
a1972 2
            val delete_breakpoints_hook = 
              ref(fn () => IO.output(IO.std_out,"No definition for delete_breakpoints"))
d1974 1
a1974 3
            val list_breakpoints_hook = 
              ref(fn _ : unit => 
                  (IO.output(IO.std_out,"No definition for list_breakpoints");[""]))
@


1.125
log
@Add OS.Win_nt structure
@
text
@d13 3
d1947 2
@


1.124
log
@Added new "unsafe" pervasives
@
text
@d13 3
d1885 1
a1885 1
            datatype name = UNIX
d1939 6
@


1.123
log
@Added pervasive Option structure
@
text
@d13 3
d1330 3
d1339 10
d2007 18
d2035 1
a2035 1
		  vector(rev(make_list([], 0)))
@


1.122
log
@Added unsafe array operations
@
text
@d13 3
d431 1
d1261 6
a2013 1

@


1.121
log
@Add event functions for stack overflow and interrupt handlers.
@
text
@d13 3
d1316 7
@


1.120
log
@Add MLWorks messages stream.
@
text
@d13 3
d1413 1
d1417 3
@


1.119
log
@Add Trace.restore_all.
@
text
@d13 3
d1728 6
@


1.118
log
@Updated runtime signal handling.
@
text
@d13 3
d1360 1
@


1.117
log
@Breakpoint settings on function exits.
@
text
@d13 3
d1402 4
a1405 1
                    val signal = call_c "system event signal"
@


1.116
log
@Revised MLWorks.IO.set_modified_file to tae a datatype.
@
text
@d13 3
d1898 8
@


1.115
log
@Removed input_string and output_string.
@
text
@d13 3
d1265 297
d1738 4
a1773 204
        exception Save of string
        val save = call_c "image save"

        structure Internal =
          struct
            val real_to_string = call_c "real to string"
            exception StringToReal
            val string_to_real = call_c "real from string"

            val text_preprocess = ref (fn (f : int -> string ) => f)

	    structure Images =
	      struct
		exception Table of string
		val clean = call_c "clean code vectors"
		val save = save
		val table = call_c "image table"
	      end

            structure Value =
              struct
                open BuiltinLibrary_
                type T = ml_value
                exception Value of string

                (* Many of these operations would be better implemented as *)
                (* built-in code. *)

                val cast = call_c "value cast"
                val list_to_tuple = call_c "value list to tuple"
                val tuple_to_list = call_c "value tuple to list"
                val string_to_real = call_c "value string to real"
                val real_to_string = call_c "value real to string"
                (* This datatype is decoded in rts/pervasive/value.c.  You *)
                (* must update that if you change it. *)
                datatype print_options =
                  DEFAULT |
                  OPTIONS of {depth_max	  	: int,
                              string_length_max	: int,
                              indent		: bool,
                              tags		  	: bool}
                val print = call_c "value print"
                val primary = call_c "value primary"
                val header = call_c "value header"
                val pointer = call_c "value pointer"
                val update = call_c "value update value"
                val sub = call_c "value sub value"
                val update_byte = call_c "value update byte"
                val sub_byte = call_c "value sub byte"
                val update_header = call_c "value update header"
                val code_name = call_c "value code name"
                val exn_name = call_c "value exn name"
                val exn_argument = call_c "value exn argument"
                val exn_name_string = call_c "value exn name string"
                datatype frame = FRAME of int
                val frame_call = call_c "debugger frame call"
                val frame_next = call_c "debugger frame next"
                val frame_sub = call_c "debugger frame sub"
                val frame_offset = call_c "debugger frame offset"
                val frame_allocations = call_c "debugger frame allocations"
              end

            structure Architecture =
              struct
                datatype name = SPARC
                fun name () = SPARC

                structure SPARC =
                  struct
                    val flush_windows = call_c "stack flush"
                    structure Frame =
                      struct
                        datatype pointer = POINTER of int
                        val sub = call_c "stack frame sub"
                        val update = call_c "stack frame update"
                        val current = call_c "stack frame current"
                      end
                  end
              end

            structure Trace =
              struct
                exception Trace of string
                val intercept = call_c "trace intercept"
                val replace = call_c "trace replace"
                val restore = call_c "trace restore"
                (* NOTE: This datatype is implicitly understood by the *)
                (* runtime system.  Don't change the constructors without *)
                (* altering rts/pervasive/trace.c *)
                datatype status = INTERCEPT | NONE | REPLACE
                val status = call_c "trace status"
              end

            structure FileIO =
              struct
                type fd = RawIO.outstream
                datatype offset = BEG | CUR | END

                val seekf = call_c "stream seek out"
                val openf = call_c "stream open update"
                val closef = RawIO.close_out
		val write_byte = RawIO.output_byte
                val writef = RawIO.output
                val writebf = call_c "stream output bytearray"
              end

	    structure Runtime =
	      struct
                exception Unbound of string
                val environment = call_c

                val modules = call_c "system module root"

                structure Loader =
                  struct
                    exception Load of string
                    val load_module = call_c "system load link"
                    val load_wordset = call_c "system load wordset"
                  end;

		structure StorageManager =
		  struct
		    val gc_message_level = call_c "gc message level"
                    exception StorageManager of int
                    val interface = call_c "storeman interface"
		  end;

                structure Event =
                  struct
                    datatype T = SIGNAL of int
                    exception Signal of string
                    val signal = call_c "system event signal"
                  end;
            
		structure Exception =
		  struct

		    (* Remove the constructor status from the
		       exception names so that they can be rebound. *)
		    structure S :
		      sig
			type T
			val Diff : T
			val Div : T
			val Floor : T
			val Io : T
			val Mod : T
			val Prod : T
			val Profile : T
			val Quot : T
			val Save : T
			val Substring : T
			val Sum : T
                        val Abs : T
                        val Exp : T
                        val Ln : T
                        val Load : T
                        val Signal : T
                        val Sqrt : T
                        val StorageManager : T
                        val StringToReal : T
                        val Trace : T
                        val Unix : T
                        val Unbound : T
                        val Value : T
		      end =
		      struct
			datatype T =
                          Io | Prod | Mod | Div | Substring | Save |
                          Profile | Value | Load | Unbound | Signal |
                          Abs | Sqrt | StringToReal | Ln | Exp |
                          StorageManager | Sum | Diff | Quot | Floor |
                          Unix | Trace
		      end
		    open S
		      
		    val Diff =			call_c "exception Diff"
		    val Div =			call_c "exception Div"
		    val Floor =			call_c "exception Floor"
		    val Io =			call_c "exception Io"
		    val Mod =			call_c "exception Mod"
		    val Prod =			call_c "exception Prod"
		    val Profile =		call_c "exception Profile"
		    val Quot =			call_c "exception Quot"
		    val Save =			call_c "exception Save"
		    val Substring =		call_c "exception Substring"
		    val Sum =			call_c "exception Sum"
                    val Abs =			call_c "exception Abs"
                    val Exp =			call_c "exception Exp"
                    val Ln =			call_c "exception Ln"
                    val Load =			call_c "exception Load"
                    val Signal =		call_c "exception Signal"
                    val Sqrt =			call_c "exception Sqrt"
                    val StorageManager =	call_c "exception StorageManager"
                    val StringToReal = 		call_c "exception StringToReal"
                    val Trace =			call_c "exception Trace"
                    val Unbound =		call_c "exception Unbound"
                    val Unix =			call_c "exception Unix"
                    val Value =			call_c "exception Value"
		  end
	      end
            
	  end

a1947 93
	  end

        structure Time =
          struct
            structure Interval =
              struct
                datatype T = INTERVAL of Internal.Value.T

		val to_real = call_c "interval to real"
		val from_real = call_c "interval from real"

		(* can use time add, time sub, and time less because
		 * our time and interval representations happen to be
		 * the same *)

		val op- = call_c "time subtract"
		val op+ = call_c "time add"
		val op< = call_c "time less"

		val real_mul = op* : real*real->real
		val real_div = op/ : real*real->real

		fun x*y = from_real(real_mul((to_real x),y))
		fun x/y = from_real(real_div((to_real x),y))

		val c_format = call_c "time to string"
		val decimal_places = ref 2
		fun format x = c_format (x,!decimal_places)
	      end
		 
	    structure Elapsed =
	      struct
		datatype T = ELAPSED of {real: Interval.T,
					 user: Interval.T,
					 system: Interval.T,
					 gc: Interval.T}
		  
		val elapsed = call_c "time elapsed"
		val elapsed_since = call_c "time elapsed since"

		fun project_interval_fn f (ELAPSED{real=real1,
						   user=user1,
						   system=sys1,
						   gc = gc1},
					   ELAPSED{real=real2,
						   user=user2,
						   system=sys2,
						   gc = gc2})
		  = ELAPSED {real = f(real1,real2),
			     user = f(user1,user2),
			     system = f(sys1,sys2),
			     gc = f (gc1,gc2)}
		  
		val op- = project_interval_fn (Interval.-)
		val op+ = project_interval_fn (Interval.+)
		
		fun project_interval_real_fn f (ELAPSED{real,user,system,gc},
						x) =
		  ELAPSED{real= f(real,x),
			  user = f(user,x),
			  system = f(system,x),
			  gc = f(gc,x)}

		val op* = project_interval_real_fn (Interval.* )
		val op/ = project_interval_real_fn (Interval./ )

		fun format (ELAPSED {real,user,system,gc}) =
		  implode [Interval.format real,
			   " (user: ",
			   Interval.format user,
			   ", system: ",
			   Interval.format system,
			   ", gc: ",
			   Interval.format gc, ")"]

	      end

	    datatype time = TIME of Internal.Value.T

	    val zero = call_c "time zero"
	    val now = call_c "time now"
	    val op< = call_c "time less"

	    val interval = call_c "time interval"

	    val (op-) = call_c "time subtract"
	    val (op+) = call_c "time add"

	    datatype zone = GREENWICH | LOCAL
	    val format = call_c "time format"

	    val encode = call_c "time encode"
	    val decode = call_c "time decode"
@


1.114
log
@Added MLWorks.IO.set_file_modified.
@
text
@d13 3
a1311 2
            val input_string = input

a1397 2
            val output_string = output

@


1.113
log
@New profiler, with a new interface.
@
text
@d13 3
d1438 2
@


1.112
log
@Step and breakpoints Debugger.
@
text
@d13 3
a1450 1
              fun write (out, string) = (IO.output (out, string); out)
d1454 1
a1454 1
                  fun wrapper a =
d1457 1
d1459 1
a1459 1
                  case p (options, write, outstream, wrapper, a) of
@


1.111
log
@Changed close_* on std_* streams to raise an Io exception.
@
text
@d13 3
d1768 1
d1772 27
@


1.110
log
@Added realpath function
@
text
@d13 3
d1307 2
a1308 2
			  close_in =	          fn ()  => RawIO.close_in RawIO.std_in,
			  closed_in =             fn ()  => RawIO.closed_in RawIO.std_in}
d1403 2
a1404 2
			 close_out = fn () => RawIO.close_out RawIO.std_out,
			 closed_out = fn () => RawIO.closed_out RawIO.std_out}
d1419 2
a1420 2
			 close_out = fn () => RawIO.close_out RawIO.std_err,
			 closed_out = fn () => RawIO.closed_out RawIO.std_err}
@


1.109
log
@Added MLWorks.String.ml_string : (string * int) -> string
@
text
@d13 3
d1717 1
@


1.108
log
@Added call to C for MLWorks.Internal.Runtime.Loader.load_module
@
text
@d13 3
d1171 35
d1210 1
d1866 2
a1867 2
		val op* = project_interval_real_fn (Interval.*)
		val op/ = project_interval_real_fn (Interval./)
@


1.107
log
@ Fixed problems with inexhaustive bindings
@
text
@d13 3
d1531 1
a1531 1
                    fun load_module _ = raise Unimplemented "MLWorks.Internal.Runtime.load_module"
@


1.106
log
@Add to IO and RawIO to provide closed_in and closed_out functions, which
test a stream for closed-ness.
@
text
@d13 4
d1261 8
a1268 2
              
            val std_in as FLEXIN (flex_std_in) = mkFlexInStream terminal_in
d1358 5
a1362 1
            val std_out as (FLEXOUT flex_std_out) = mkFlexOutStream terminal_out
d1364 2
d1374 3
a1376 1
            val std_err as (FLEXOUT flex_std_err) = mkFlexOutStream terminal_err
@


1.105
log
@New time structure, to allow real intervals to be measured, to allow the
user to convert to/from reals, and to optimise the "measure the user/
system/gc/clock time taken by this" path.
@
text
@d13 5
d1193 2
d1205 2
a1206 1
                                close_in		: unit -> unit}
d1219 1
a1219 1
                val standard_instream = RawIO.open_in string
d1221 6
a1226 5
                instream {input =	  fn int => RawIO.input (standard_instream, int),
                          lookahead =	  fn ()  => RawIO.lookahead standard_instream,
                          end_of_stream = fn ()  => RawIO.end_of_stream standard_instream,
                          clear_eof =	  fn ()  => RawIO.clear_eof standard_instream,
                          close_in =	  fn ()  => RawIO.close_in standard_instream}
d1237 1
d1244 1
d1251 6
a1256 5
              instream {input =	          fn int => RawIO.input (RawIO.std_in, int),
                        lookahead =	  fn ()  => RawIO.lookahead RawIO.std_in,
                        end_of_stream =   fn ()  => RawIO.end_of_stream RawIO.std_in,
                        clear_eof =	  fn ()  => RawIO.clear_eof RawIO.std_in,
                        close_in =	  fn ()  => RawIO.close_in RawIO.std_in}
d1290 3
a1292 2
                                flush_out	: unit -> unit,
                                close_out	: unit -> unit}
d1310 2
a1311 1
                           close_out =	fn ()     => RawIO.close_out raw_outstream}
d1323 1
d1328 1
d1343 4
a1346 3
              outstream {output = fn s => RawIO.output(RawIO.std_out,s),
                         flush_out = fn () => RawIO.flush_out RawIO.std_out,
                         close_out = fn () => RawIO.close_out RawIO.std_out}
d1352 5
a1356 3
            val terminal_err = outstream {output = fn s => RawIO.output(RawIO.std_err,s),
                                          flush_out = fn () => RawIO.flush_out RawIO.std_err,
                                          close_out = fn () => RawIO.close_out RawIO.std_err}
@


1.104
log
@Added MLworks.OS.Unix.{unlink,rmdir,mkdir}.
@
text
@d13 3
d1343 1
a1343 1
            val file_modified = call_c "time real file modified"
d1728 1
a1728 1
            structure Real =
d1730 84
a1813 10
                datatype T = REAL_TIME of Internal.Value.T
                val now = call_c "time real now"
                val op< = call_c "time real less"
                val equal = call_c "time real equal"
                val zero = call_c "time real zero"
                datatype zone = GREENWICH | LOCAL
                val format = call_c "time real format"
                val encode = call_c "time real encode"
                val decode = call_c "time real decode"
              end
d1815 3
a1817 10
            structure Virtual =
              struct
                datatype T = VIRTUAL_TIME of Internal.Value.T
                val user = call_c "time virtual user"
                val system = call_c "time virtual system"
                val gc = call_c "time virtual gc"
                val op- = call_c "time virtual difference"
                val format = call_c "time virtual format"
              end
          end
@


1.104.1.1
log
@Fork for bug fixing
@
text
@a12 3
 *  Revision 1.104  1993/08/27  19:13:59  daveb
 *  Added MLworks.OS.Unix.{unlink,rmdir,mkdir}.
 *
@


1.103
log
@Removed the X exception.  It's now in the Motif interface code.
@
text
@d13 3
d1635 1
d1655 2
@


1.102
log
@Added MLWorks.OS.Unix.kill.
@
text
@d13 3
a389 1
    exception X of string
a441 1
    exception X of string
d1379 1
a1533 1
                        val X : T
d1539 3
a1541 2
                          Abs | Sqrt | StringToReal | Ln | Exp | StorageManager |
                          Sum | Diff | Quot | Floor | Unix | Trace | X
a1567 1
                    val X =			call_c "exception X"
d1780 1
a1780 2
        Exception.Value		:= MLWorks.Internal.Value.Value "";
        Exception.X		:= X ""
@


1.101
log
@Added X exception.
@
text
@d13 3
d1663 1
@


1.100
log
@Added system calls to read directories and the password file.
@
text
@d13 3
d384 1
d437 1
d1501 2
a1502 1
		    (* Remove the constructor status from the exception names so that they can be rebound. *)
d1529 1
d1536 1
a1536 1
                          Sum | Diff | Quot | Floor | Unix | Trace
d1563 1
d1775 2
a1776 1
        Exception.Value		:= MLWorks.Internal.Value.Value ""
@


1.99
log
@added two debugger functions
@
text
@d13 3
d20 2
a21 2
 *  Added MLWorks.OS.Unix.password_file to get the association list of user names
 *  to home directories necessary for translating ~
d27 2
a28 1
 *  Added Integer and Real substructures of MLWorks with makestring and print functions
d264 2
a265 1
 *  Added NewJersey.Bits.andb so that we can still compile everything with our compiler
d307 2
a308 2
 *  Commented out arrayoflist and tabulate until they can be implemented without
 *  depending on themselves.
d1343 1
d1348 9
a1356 1
                p (options, write, outstream, f, a)
a1613 1
		val password_file = call_c "system os unix password_file"
d1635 17
@


1.98
log
@Added text_preprocess hook
@
text
@d13 3
d1403 2
@


1.97
log
@Added MLWorks.OS.Unix.password_file to get the association list of user names
to home directories necessary for translating ~
@
text
@d13 4
d1352 1
@


1.96
log
@Corrected the call to the profiler.
@
text
@d13 3
d1590 1
@


1.95
log
@Added Integer and Real substructures of MLWorks with makestring and print functions
@
text
@d13 3
d1329 1
d1332 1
a1332 1
                p (options, IO.output, outstream, f, a)
@


1.94
log
@Removed defunct Editor interface and added sytem calls to enable
its replacement.
@
text
@d13 4
d1150 1
d1429 1
d1528 41
@


1.93
log
@Added more Unix system call interfaces.
New Trace structure to go with runtime implementation.
Removed commented out array functions.  (They're in RCS anyway.)
@
text
@d13 5
a1329 26
	structure Editor =
	  struct
	    datatype Editor = EMACS | VI
	    val emacs_file = call_c"load file"
	    val vi_file = call_c"vi editor"
	    exception NotFound of string * string
	    fun last [] = ""
	      | last [x] = x
	      | last(_::xs) = last xs
	    val emacs_file =
	      fn string_list =>
	      case emacs_file (last string_list) of
		"" => ()
	      | str => raise NotFound (last string_list, str)
	    val vi_file =
	      fn string_list =>
	      case vi_file string_list of
		"" => ()
	      | str =>
		  raise NotFound (last string_list, str)
	    fun load_file str_list =
	      (emacs_file str_list;
	       vi_file str_list)
	    fun other_operation _ = () (* NYI *)
	  end

d1551 6
@


1.92
log
@Moved dynamic stuff from MLWorks.Internal.Typerep to MLWorks.Dynamic
Moved break stuff from MLWorks.Internal.Tracing to MLWorks.Debugger
@
text
@d8 1
a8 3
 *  are compiled It is compiled in a type environment which is the same as
 *  that for the __builtin_library file - i.e. the following types are
 *  defined unit,list and the constructors are ::,nil
a9 7
 *  The following are implicitly defined - see typechecker/_valenv and 
 *            =,~,abs,*,+,-,<,>,<=,>=
 *  at the beginning of each file 
 *
 *  This file could be written in the standard way, but then the BUILTIN's
 *  would not be propogated thorugh the environment
 *
d13 4
d34 2
a35 2
 *  Added Intermal.Images including save and clean. Added other_operation to Editor
 *  for arbitrary bits of emacs lisp
a375 1
    val ordof                 : string * int -> int
a399 2
(* To propogate the environment correctly, do not bind things that are Builtins, but open and 
   use the signature to prune them down *)
a771 1
(*
a775 12
                fun init 0 = a
                  | init n =
                    (unsafe_update (a, l-n, f (l-n));
                     init (n-1))
              in
                init l
              end
*)
            fun tabulate (l, f) =
              let
                val a = array (l, 0)

a784 1
(*
a798 5
*)
            fun from_list list =
              let
                fun list_length (n, []) = n
                  | list_length (n, _::xs) = list_length (n+1, xs)
a799 10
                val new = array (list_length (0, list), 0)

                fun fill (_, []) = new
                  | fill (n, x::xs) =
                    (unsafe_update (new, n, x);
                     fill (n+1, xs))
              in
                fill (0, list)
              end

a801 1
(*
a805 11
                    (unsafe_update (a, n-1, x);
                     fill' (n-1))
              in
                fill' (length a)
              end
*)

            fun fill (a, x) =
              let
                fun fill' 0 = ()
                  | fill' n =
a815 1
(*
a820 14
                fun map' 0 = new
                  | map' n =
                    (unsafe_update (new, l-n, f (unsafe_sub (a, l-n)));
                     map' (n-1))
              in
                map' l
              end
*)

            fun map f a =
              let
                val l = length a
                val new = array (l, 0)

a830 1
(*
a835 14
                fun map' 0 = new
                  | map' n =
                    (unsafe_update (new, l-n, f (l-n, unsafe_sub (a, l-n)));
                     map' (n-1))
              in
                map' l
              end
*)

            fun map_index f a =
              let
                val l = length a
                val new = array (l, 0)

a845 1
(*
a849 10
                    to_list' (n-1, unsafe_sub (a, n-1) :: list)
              in
                to_list' (length a, nil)
              end
*)

            fun to_list a =
              let
                fun to_list' (0, list) = list
                  | to_list' (n, list) =
a858 1
(*
a862 13
                fun iterate' 0 = ()
                  | iterate' n =
                    (f (unsafe_sub (a, l-n));
                     iterate' (n-1))
              in
                iterate' l
              end
*)

            fun iterate f a =
              let
                val l = length a

a872 1
(*
a876 13
                fun iterate' 0 = ()
                  | iterate' n =
                    (f (l-n, unsafe_sub (a, l-n));
                     iterate' (n-1))
              in
                iterate' l
              end
*)

            fun iterate_index f a =
              let
                val l = length a

a886 1
(*
a893 14
                    (unsafe_update (new, n-1, unsafe_sub (a, l-n));
                     rev' (n-1))
              in
                rev' l
              end
*)

            fun rev a =
              let
                val l = length a
                val new = array (l, 0)

                fun rev' 0 = new
                  | rev' n =
a903 1
(*
a910 14
                    (unsafe_update (new, n-1, unsafe_sub (a, n-1));
                     duplicate' (n-1))
              in
                duplicate' l
              end
*)

            fun duplicate a =
              let
                val l = length a
                val new = array (l, 0)

                fun duplicate' 0 = new
                  | duplicate' n =
a921 12
(*
            fun subarray (a, start, finish) =
              let
                val l = length a
              in
                if start < 0 orelse start > l orelse finish > l orelse
                   start > finish then
                  raise Subarray (start, finish)
                else
                  let
                    val l' = finish - start
                    val new = array (l', 0)
a922 10
                    fun copy 0 = new
                      | copy n =
                        (unsafe_update (new, n-1, unsafe_sub (a, start+n-1));
                         copy (n-1))
                  in
                    copy l'
                  end
              end
*)

a947 1
(*
a955 20
                    (unsafe_update (new, n-1, unsafe_sub (array1, n-1));
                     copy1 (n-1))

                fun copy2 0 = copy1 l1
                  | copy2 n =
                    (unsafe_update (new, n-1+l1, unsafe_sub (array2, n-1));
                     copy2 (n-1))
              in
                copy2 l2
              end
*)

            fun append (array1, array2) =
              let
                val l1 = length array1
                val l2 = length array2
                val new = array (l1+l2, 0)

                fun copy1 0 = new
                  | copy1 n =
a974 1
(*
a978 12
                fun reducel' (i, 0) = i
                  | reducel' (i, n) =
                    reducel' (f (i, unsafe_sub (a, l-n)), n-1)
              in
                reducel' (i, l)
              end
*)

            fun reducel f (i, a) =
              let
                val l = length a

a987 1
(*
a993 12
                    reducer' (n-1, f (unsafe_sub (a, n-1), i))
              in
                reducer' (l, i)
              end
*)

            fun reducer f (a, i) =
              let
                val l = length a

                fun reducer' (0, i) = i
                  | reducer' (n, i) =
a1002 1
(*
a1006 12
                fun reducel' (i, 0) = i
                  | reducel' (i, n) =
                    reducel' (f (l-n, i, unsafe_sub (a, l-n)), n-1)
              in
                reducel' (i, l)
              end
*)

            fun reducel_index f (i, a) =
              let
                val l = length a

a1015 1
(*
a1021 12
                    reducer' (n-1, f (n-1, unsafe_sub (a, n-1), i))
              in
                reducer' (l, i)
              end
*)

            fun reducer_index f (a, i) =
              let
                val l = length a

                fun reducer' (0, i) = i
                  | reducer' (n, i) =
a1031 25
(*
            fun copy (from, start, finish, to, start') =
              let
                val l1 = length from
                val l2 = length to
              in
                if start < 0 orelse start > l1 orelse finish > l1 orelse
                   start > finish orelse
                   start' < 0 orelse start' + finish - start > l2 then
                  raise Copy (start, finish, start')
                else
                  let
                    fun copy' 0 = ()
                      | copy' n =
			let
			  val n' = n-1
			in
			  (unsafe_update (to, start'+n', unsafe_sub (from, start+n'));
			   copy' n')
			end
                  in
                    copy' (finish - start)
                  end
              end
*)
a1057 19
(*
            fun fill_range (a, start, finish, x) =
              let
                val l = length a
              in
                if start < 0 orelse start > l orelse finish > l orelse
                   start > finish then
                  raise Fill (start, finish)
                else
                  let
                    fun fill' 0 = ()
                      | fill' n =
                        (unsafe_update (a, start+n-1, x);
                         fill' (n-1))
                  in
                    fill' (finish - start)
                  end
              end
*)
a1081 10
(*
            fun find predicate a =
              let
                val l = length a
                fun find' 0 = raise Find
                  | find' n = if predicate (unsafe_sub (a, l-n)) then l-n else find' (n-1)
              in
                find' l
              end
*)
a1094 1
(*
a1097 10
                fun find' 0 = default
                  | find' n = if predicate (unsafe_sub (a, l-n)) then l-n else find' (n-1)
              in
                find' l
              end
*)

            fun find_default (predicate, default) a =
              let
                val l = length a
d1305 15
a1319 6
	exception Profile of string
        fun profile(profilelevel,profileall,profile_list,stream,time,func) = 
          let
            val the_fn = call_c "profile"
          in
            the_fn (profilelevel,profileall,profile_list,fn s => IO.output(stream,s),time,func)
a1350 17
        structure OS =
          struct
            datatype name = UNIX
            fun name () = UNIX

            val system = call_c "system os system"
            val arguments = call_c "system os arguments"

            structure Unix =
              struct
                val environment = call_c "system os unix environment"
                val setwd = call_c "system os unix setwd"
                val getwd = call_c "system os unix getwd"
                val rusage = call_c "system os unix rusage"
              end
          end

d1371 2
a1372 1
                (* Many of these operations would be better implemented as built-in code. *)
d1379 8
a1399 1

d1401 3
a1403 3
                val frame_call = call_c "stack frame call"
                val frame_next = call_c "stack frame next"
                val frame_sub = call_c "stack frame sub"
d1406 1
a1406 1
            structure Tracing =
d1408 13
a1420 9
                val call_traced_function = call_c "trace call traced function"
                val trace_set = call_c "trace set trace hook"
                fun modify_hook_function user_hook (pair as (arg,function_closure)) =
                  let
                    val after_method = user_hook pair
                    val result = call_traced_function pair
                  in
                    after_method result;
                    result
d1422 1
a1422 16
                fun with_tracing the_hook f argument =
                  let
                    val old_hook = trace_set (modify_hook_function the_hook)
                  in
                    let
                      val result = f argument
                    in
                      trace_set old_hook;
                      result
                    end
                  handle exn =>
                    (trace_set old_hook;
                     raise exn)
                  end
                val add_trace        = call_c "trace add trace"
                val remove_trace     = call_c "trace remove trace"
d1424 11
a1434 3
                fun default_break s = IO.output(IO.std_out,"Break at " ^ s ^ "\n")
                val break_hook = ref default_break
                fun break s = (!break_hook) s
d1503 2
d1513 1
a1513 1
                          Sum | Diff | Quot | Floor
d1536 1
d1538 1
d1545 30
d1675 1
a1675 1
        Exception.Profile	:= MLWorks.Profile "";
d1684 1
d1686 1
@


1.91
log
@Minor modifications to editor structure
@
text
@d22 3
d1850 13
a1862 3
            structure TypeRep =
              struct
                datatype Label = LABEL of string
d1864 16
a1879 85
                datatype TyName = TYNAME of (int * string * bool)
                  
                datatype TypeRep =
                  TYVAR of (int * bool * bool)
                | RECTYPE of (Label * TypeRep) list
                | FUNTYPE of (TypeRep * TypeRep)
                | CONSTYPE of (TypeRep list * TyName)
                  
                type Dynamic = Dynamic
                  
                exception Coerce
                
                fun generalises (rep1,rep2) =
                  let
                    (* This isn't good enough, but.. *)
                    fun typerep_eq (rep1,rep2) = rep1 = rep2
                      
                    fun get_dom l = map (fn (a,_) => a) l
                    fun get_ran l = map (fn (_,b) => b) l
                      
                    exception LookUp
                    fun lookup_tyvar (tyvar,[]) = raise LookUp
                      | lookup_tyvar (n,(m,rep) :: l) =
                        if n = m then rep else lookup_tyvar (n,l)
                          
                    fun forall f [] = true
                      | forall f (a::l) = f a andalso forall f l
                        
                    fun eqtyperep (TYVAR (_,eq,_)) = eq
                      | eqtyperep (RECTYPE labreplist) =
                        forall (fn (_,typerep) => eqtyperep typerep) labreplist
                      | eqtyperep (FUNTYPE _) = false
                      | eqtyperep (CONSTYPE (replist,tyname)) =
                        let fun eqtyname (TYNAME(_,_,eq)) = eq
                        in
                          eqtyname tyname
                          andalso
                          forall eqtyperep replist
                        end
                      
                    exception FailGeneralises of string
                    
                    (* return a new map if rep1 generalises rep2 *)
                    fun gen (TYVAR (n,eq,imp),rep2,map) =
                      (let val rep1 = lookup_tyvar (n,map)
                      in
                         if typerep_eq (rep1,rep2) then map
                         else raise FailGeneralises "Inconsistent tyvar maps"
                      end
                    handle LookUp =>
                      if eq andalso (not (eqtyperep rep2))
                        then raise FailGeneralises "equality attribute required"
                      else(n,rep2) :: map)
                      | gen (RECTYPE labreplist,RECTYPE labreplist',map) =
                        let
                          val dom = get_dom labreplist
                          val dom' = get_dom labreplist'
                        in
                          if dom = dom'
                            then
                              list_gen (get_ran labreplist,get_ran labreplist',map)
                          else raise FailGeneralises "Record domain mismatch"
                        end
                      | gen (FUNTYPE(rep1,rep1'),FUNTYPE(rep2,rep2'),map) =
                        gen (rep1',rep2',gen(rep1,rep2,map))
                      | gen (CONSTYPE(replist,TYNAME(n,_,_)),
                             CONSTYPE(replist',TYNAME(n',_,_)),
                             map) =
                        if n = n'
                          then list_gen(replist,replist',map)
                        else raise FailGeneralises "Tycon mismatch"
                      | gen _ = raise FailGeneralises "Inconsistent types"
                        
                    and list_gen ([],[],map) = map
                      | list_gen (rep::l,rep'::l',map) =
                        list_gen (l,l',gen(rep,rep',map))
                      | list_gen _ = raise FailGeneralises "Constructor parameter mismatch"
                  in
                    (gen (rep1,rep2,[]);true)
                    handle FailGeneralises s => false
                  end
                
                val get_type = Value.cast (fn (a,b) => b)
                val get_value = Value.cast (fn (a,b) => a)
              end
a1880 2
	  end

@


1.90
log
@Extended images structure to include table of contents reading
@
text
@d22 3
a1626 5
	    val emacs_file =
	      fn string =>
	      case emacs_file string of
		"" => ()
	      | str => raise NotFound (string, str)
d1630 5
d1642 2
a1643 2
	      (emacs_file(last str_list);
	       vi_file(str_list))
@


1.89
log
@Added break function to Tracing substructure
@
text
@d22 3
d1669 1
d1672 1
@


1.88
log
@Added vector primitives. Changed editor implementastion slightly.
@
text
@d22 3
d1731 4
@


1.87
log
@Rewrote a number of array functions to avoid recalculating numbers like
n-1 and l-n
@
text
@d22 4
a320 1
(*
a322 1
*)
a1613 1
	    val load_file = call_c"load file"
d1615 2
d1618 1
a1618 1
	    val load_file =
d1620 1
a1620 1
	      case load_file string of
d1623 12
d1926 1
d1928 14
a1941 6
            exception Size = Array.Size
            exception Subscript = Array.Subscript
            val vector = Internal.Value.cast Array.arrayoflist
            val tabulate = Internal.Value.cast Array.tabulate
            val sub = Internal.Value.cast Array.sub
            val length = Internal.Value.cast Array.length
a1973 1
(*
a1975 1
*)
@


1.86
log
@Added Intermal.Images including save and clean. Added other_operation to Editor
for arbitrary bits of emacs lisp
@
text
@d22 4
d416 7
a422 6
                fun init 0 = a
                  | init n =
                    (unsafe_update (a, l-n, f (l-n));
                     init (n-1))
              in
                init l
d446 6
a451 2
                    (unsafe_update (a, n-1, x);
                     fill' (n-1))
d461 6
a466 4
                fun map' 0 = new
                  | map' n =
                    (unsafe_update (new, l-n, f (unsafe_sub (a, l-n)));
                     map' (n-1))
d468 1
a468 1
                map' l
d476 6
a481 4
                fun map' 0 = new
                  | map' n =
                    (unsafe_update (new, l-n, f (l-n, unsafe_sub (a, l-n)));
                     map' (n-1))
d483 1
a483 1
                map' l
d490 5
a494 1
                    to_list' (n-1, unsafe_sub (a, n-1) :: list)
d503 6
a508 4
                fun iterate' 0 = ()
                  | iterate' n =
                    (f (unsafe_sub (a, l-n));
                     iterate' (n-1))
d510 1
a510 1
                iterate' l
d517 6
a522 4
                fun iterate' 0 = ()
                  | iterate' n =
                    (f (l-n, unsafe_sub (a, l-n));
                     iterate' (n-1))
d524 1
a524 1
                iterate' l
d534 6
a539 2
                    (unsafe_update (new, n-1, unsafe_sub (a, l-n));
                     rev' (n-1))
d551 6
a556 2
                    (unsafe_update (new, n-1, unsafe_sub (a, n-1));
                     duplicate' (n-1))
d576 6
a581 2
                        (unsafe_update (new, n-1, unsafe_sub (a, start+n-1));
                         copy (n-1))
d595 6
a600 2
                    (unsafe_update (new, n-1, unsafe_sub (array1, n-1));
                     copy1 (n-1))
d604 6
a609 2
                    (unsafe_update (new, n-1+l1, unsafe_sub (array2, n-1));
                     copy2 (n-1))
d618 5
a622 3
                fun reducel' (i, 0) = i
                  | reducel' (i, n) =
                    reducel' (f (i, unsafe_sub (a, l-n)), n-1)
d624 1
a624 1
                reducel' (i, l)
d633 5
a637 1
                    reducer' (n-1, f (unsafe_sub (a, n-1), i))
d646 5
a650 3
                fun reducel' (i, 0) = i
                  | reducel' (i, n) =
                    reducel' (f (l-n, i, unsafe_sub (a, l-n)), n-1)
d652 1
a652 1
                reducel' (i, l)
d661 5
a665 1
                    reducer' (n-1, f (n-1, unsafe_sub (a, n-1), i))
d684 6
a689 2
                        (unsafe_update (to, start'+n-1, unsafe_sub (from, start+n-1));
                         copy' (n-1))
d707 6
a712 2
                        (unsafe_update (a, start+n-1, x);
                         fill' (n-1))
d722 5
a726 2
                fun find' 0 = raise Find
                  | find' n = if predicate (unsafe_sub (a, l-n)) then l-n else find' (n-1)
d728 1
a728 1
                find' l
d734 5
a738 2
                fun find' 0 = default
                  | find' n = if predicate (unsafe_sub (a, l-n)) then l-n else find' (n-1)
d740 1
a740 1
                find' l
d766 1
d778 4
d783 10
d807 5
d813 10
d825 1
d835 1
d837 15
d864 1
d866 16
d894 1
d896 16
d920 1
d922 14
d947 1
d949 15
d975 1
d977 15
d1004 1
d1006 18
d1036 1
d1038 17
d1056 1
d1077 1
d1079 26
d1123 1
d1125 28
d1163 1
d1165 14
d1189 1
d1191 16
d1217 1
d1219 14
d1243 1
d1245 15
d1261 1
d1275 6
a1280 2
                        (unsafe_update (to, start'+n-1, unsafe_sub (from, start+n-1));
                         copy' (n-1))
d1285 1
d1287 24
d1312 1
d1330 1
d1332 22
d1355 1
d1364 1
d1366 13
d1386 13
@


1.85
log
@Added Editor substructure to MLWorks
@
text
@d22 3
d1186 1
d1211 6
@


1.84
log
@Added builtin string relationals
@
text
@d22 3
d1172 12
@


1.83
log
@Use builtin array, bytearray and vector types
@
text
@d22 3
d968 4
a971 4
            val op <  : string * string -> bool = call_c "string less"
            val op >  : string * string -> bool = call_c "string greater"
            val op <= : string * string -> bool = not o (op >)
            val op >= : string * string -> bool = not o (op <)
@


1.82
log
@Implemented a multi-level profiler
@
text
@d22 3
a398 2
            type 'a T = 'a array

d677 1
a677 2
            datatype T = BYTEARRAY of ml_value
            type bytearray = T
d1449 1
a1449 1
            datatype 'a vector = Vector of 'a Array.array
d1452 4
a1455 6
            val vector =
              Internal.Value.cast (fn l => Vector (Array.arrayoflist l))
            val tabulate =
              Internal.Value.cast (fn (i, f) => Vector (Array.tabulate(i, f)))
            fun sub (Vector a, i) = Array.sub(a, i)
            fun length (Vector a) = Array.length a
@


1.81
log
@Used builtin array type.  Removed Array.T from signature
@
text
@d22 3
d1157 1
a1157 1
        fun profile(stream,time,func) = 
d1161 1
a1161 1
            the_fn (fn s => IO.output(stream,s),time,func)
@


1.80
log
@Reimplemented modifiable streams
Added TypeRep substructure for use with Dynamic objects.
@
text
@d22 4
d391 3
a393 2
            datatype 'a T = ARRAY of ml_value
            type 'a array = 'a T
@


1.79
log
@Added extra exceptions to those passed to the runtime system.
@
text
@d22 3
d993 9
d1003 6
a1008 6
              instream of {input		: int -> string,
                           lookahead		: unit -> string,
                           end_of_stream	: unit -> bool,
                           clear_eof		: unit -> unit,
                           close_in		: unit -> unit}
              
d1020 17
a1036 2
            fun end_of_stream (instream {end_of_stream, ...}) = end_of_stream ()
            fun input (instream {input, ...}, int) = input int
d1038 1
a1038 4
            fun clear_eof (instream {clear_eof, ...}) = clear_eof ()
            fun lookahead (instream {lookahead, ...}) = lookahead ()
            fun close_in (instream {close_in, ...}) = close_in ()
              
d1046 11
a1056 22
            local
              val stream_ref = ref {input =	          fn int => RawIO.input (RawIO.std_in, int),
                                    lookahead =	  fn ()  => RawIO.lookahead RawIO.std_in,
                                    end_of_stream =   fn ()  => RawIO.end_of_stream RawIO.std_in,
                                    clear_eof =	  fn ()  => RawIO.clear_eof RawIO.std_in,
                                    close_in =	  fn ()  => RawIO.close_in RawIO.std_in}
            in
              val std_in = instream {input =	          fn int => (#input(!stream_ref)) int,
                                    lookahead =	  fn ()  => (#lookahead(!stream_ref)) (),
                                    end_of_stream =   fn () => (#end_of_stream(!stream_ref)) (),
                                    clear_eof =	  fn ()  => (#clear_eof(!stream_ref)) (),
                                    close_in =	  fn ()  => (#close_in(!stream_ref)) ()}
              fun with_standard_input (instream stream) f =
                let
                  val oldstream = (!stream_ref)
                  val _ = stream_ref := stream
                  val result = f () handle exn => (stream_ref := oldstream; raise exn)
                in
                  stream_ref := oldstream;
                  result
                end
            end
d1058 2
d1076 8
d1085 6
a1090 6
              outstream of {output	: string -> unit,
                            flush_out	: unit -> unit,
                            close_out	: unit -> unit}
              
              
              
d1093 1
a1093 1
                val standard_outstream = RawIO.open_out string
d1095 3
a1097 3
                outstream {output =	fn string => RawIO.output (standard_outstream, string),
                           flush_out =	fn ()     => RawIO.flush_out standard_outstream,
                           close_out =	fn ()     => RawIO.close_out standard_outstream}
d1099 1
d1101 13
a1113 1
            fun output (outstream {output, ...}, string) = output string
d1115 11
a1125 3
            fun flush_out (outstream {flush_out, ...}) = flush_out ()
            fun close_out (outstream {close_out, ...}) = close_out ()
              
d1131 3
a1133 37
            local
              val stream_ref = ref {output = fn s => RawIO.output(RawIO.std_out,s),
                                    flush_out = fn () => RawIO.flush_out RawIO.std_out,
                                    close_out = fn () => RawIO.close_out RawIO.std_out}
            in
              val std_out = outstream {output = fn s => (#output (!stream_ref)) s,
                                       flush_out = fn () => (#flush_out (!stream_ref))(),
                                       close_out = fn () => (#close_out(!stream_ref))()}
              fun with_standard_output (outstream stream) f =
                let
                  val oldstream = (!stream_ref)
                  val _ = stream_ref := stream
                  val result = f () handle exn => (stream_ref := oldstream; raise exn)
                in
                  stream_ref := oldstream;
                  result
                end
            end

            local
              val stream_ref = ref {output = fn s => RawIO.output(RawIO.std_err,s),
                                    flush_out = fn () => RawIO.flush_out RawIO.std_err,
                                    close_out = fn () => RawIO.close_out RawIO.std_err}
            in
              val std_err = outstream {output = fn s => (#output (!stream_ref)) s,
                                       flush_out = fn () => (#flush_out (!stream_ref))(),
                                       close_out = fn () => (#close_out(!stream_ref))()}
              fun with_standard_error (outstream stream) f =
                let
                  val oldstream = (!stream_ref)
                  val _ = stream_ref := stream
                  val result = f () handle exn => (stream_ref := oldstream; raise exn)
                in
                  stream_ref := oldstream;
                  result
                end
            end
d1135 8
d1346 91
a1516 1

d1521 6
a1526 6
signature ARRAY = ARRAY
signature EXTENDED_ARRAY = EXTENDED_ARRAY
signature VECTOR = VECTOR
signature MLWORKS = MLWORKS
signature STRING = STRING
signature BITS = BITS
@


1.78
log
@Removed references to MLWorks.Vector. Removed ExtendedArray from top level
@
text
@d22 3
d1274 1
d1276 1
d1281 1
d1284 1
d1291 1
a1293 1
                        val StorageManager : T
d1300 2
a1301 1
                          Abs | Sqrt | StringToReal | Ln | Exp | StorageManager
d1305 1
d1307 1
d1312 1
d1315 1
d1322 1
a1324 1
                    val StorageManager =	call_c "exception StorageManager"
d1387 1
d1390 1
d1397 1
d1401 1
d1404 1
d1406 1
a1406 2
        Exception.Value		:= MLWorks.Internal.Value.Value "";
        Exception.StorageManager:= MLWorks.Internal.Runtime.StorageManager.StorageManager 0
@


1.77
log
@Removed pervasive vector
@
text
@d22 3
d288 1
a289 1
(*
d1361 1
d1364 1
@


1.76
log
@Added support for the 'agreed' Array and Vector structures.
Renamed the old Array to ExtendedArray.
@
text
@d22 4
d286 1
d288 1
@


1.75
log
@Made the profiler take the generalised streams
@
text
@d22 3
d273 1
d281 2
d368 1
a368 1
        structure Array : ARRAY =
d645 2
d1309 13
d1352 2
d1385 7
@


1.74
log
@Modified FileIO to be in terms of RawIO, in order to avoid type errors
occurring at runtime!
@
text
@d22 4
d1111 6
a1116 1
        val profile = call_c "profile"
@


1.73
log
@Fixed small bug with std_err in IO.
@
text
@d22 3
d1200 1
a1200 1
                type fd = IO.outstream
d1205 2
a1206 2
                val closef = IO.close_out
                val writef = IO.output
@


1.72
log
@Tidied up IO signature
@
text
@d22 3
d1080 3
a1082 3
              val stream_ref = ref {output = fn s => RawIO.output(RawIO.std_out,s),
                                    flush_out = fn () => RawIO.flush_out RawIO.std_out,
                                    close_out = fn () => RawIO.close_out RawIO.std_out}
d1100 1
a1100 1
          end;
@


1.71
log
@Added representation of streams as records.  Old IO is now RawIO.
@
text
@d22 3
d1084 1
a1084 1
              fun with_standard_err (outstream stream) f =
@


1.70
log
@Added tracing hooks to the runtime system
@
text
@d22 3
d932 1
a932 1
	structure IO =
d945 1
a945 2
            val input_string = call_c "stream input string"
            val input = input_string
d947 1
a947 2
            val output_string = call_c "stream output string"
            val output = output_string
a949 1
              
a950 1
              
d953 58
a1010 1
            val file_modified = call_c "time real file modified"
d1027 69
a1095 1
	  end
a1310 2
    open MLWorks.IO

d1314 3
@


1.69
log
@Added StorageManager exception and changed the type of the
StorageManager interface function.
@
text
@d22 4
d1033 30
@


1.68
log
@Removed debugger structure and added time and event structures.
@
text
@d22 3
d988 1
d1060 2
a1061 1
                    val interface = call_c "gc interface"
d1093 1
d1100 1
a1100 1
                          Abs | Sqrt | StringToReal | Ln | Exp
d1104 17
a1120 16
		    val Div =		call_c "exception Div"
		    val Io =		call_c "exception Io"
		    val Mod =		call_c "exception Mod"
		    val Prod =		call_c "exception Prod"
		    val Profile =	call_c "exception Profile"
		    val Save =		call_c "exception Save"
		    val Substring =	call_c "exception Substring"
                    val Abs =		call_c "exception Abs"
                    val Exp =		call_c "exception Exp"
                    val Ln =		call_c "exception Ln"
                    val Load =		call_c "exception Load"
                    val Signal =	call_c "exception Signal"
                    val Sqrt =		call_c "exception Sqrt"
                    val StringToReal = 	call_c "exception StringToReal"
                    val Unbound =	call_c "exception Unbound"
                    val Value =		call_c "exception Value"
d1178 2
a1179 1
        Exception.Value		:= MLWorks.Internal.Value.Value ""
@


1.67
log
@The FullPervasiveLibrary_ structure is now opened so that merely
requiring this file gets you the pervasive environment.
@
text
@d22 4
d337 2
a937 3
            fun input_real _ = raise Unimplemented "MLWorks.IO.input_real"
            fun input_int _ = raise Unimplemented "MLWorks.IO.input_int"
            fun input_bool _ = raise Unimplemented "MLWorks.IO.input_bool"
a939 4
            val output_real = call_c "stream output real"
            val output_int = call_c "stream output int"
            fun output_bool (stream, true)  = output_string (stream, "true")
              | output_bool (stream, false) = output_string (stream, "false")
d945 1
a945 1
	    val flush_out = call_c "stream flush"
d947 2
d974 2
a975 4
            val name	= call_c "system os name"
            val release	= call_c "system os release"
            val version	= call_c "system os version"
            val machine	= call_c "system os machine"
d983 2
a997 1
                datatype address = ADDRESS of int
d1000 1
a1000 1
                (* Most of these operations would be better implemented as built-in code. *)
d1002 1
a1002 1
                val cast = call_c "identity"
a1006 2
                fun output _ = raise Unimplemented "MLWorks.Internal.Value.output unimplemented"
                fun input _ = raise Unimplemented "MLWorks.Internal.Value.input unimplemented"
d1009 1
a1009 2
                val secondary = call_c "value secondary"
                val address = call_c "value address"
a1010 1
                val length = call_c "value length"
d1012 1
d1014 1
d1016 1
a1019 12
                fun is_pointer value =
                  case primary value
                    of 0 => false
                     | 1 => true
                     | 2 => false
                     | 3 => true
                     | 4 => false
                     | 5 => true
                     | 6 => false
                     | 7 => true
                     | _ => raise Value "Unexpected number returned by Value.primary"
              end
d1021 4
a1024 17
            structure Timer =
              struct
                exception TimerOverflow

                datatype time = TIME of int * int * int
                datatype timer = TIMER of int * int * int * int * int * int

                val start_timer = call_c "timer start"
                val check_timer = call_c "timer check"
                val check_timer_gc = call_c "timer check gc"

                fun check_timer_sys (TIMER x) = TIME(0,0,0)

                val makestring = call_c "timer makestring"

                fun earlier(TIME(hi,lo,usec),TIME(hi',lo',usec')) =
                  (hi < hi') orelse (hi=hi' andalso (lo < lo' orelse (lo=lo' andalso usec < usec')))
a1028 5
                exception FileDoesNotExist
                type time = Timer.time
                datatype fname = PATH of string
                val mtime = call_c "system mtime"

d1033 1
a1033 1
                val openf = call_c "stream reopen out"
a1038 46
            structure Debugger =
              struct
                open BuiltinLibrary_

                datatype StackFrame = STACKFRAME of int

                datatype Register = 
                  I0 | I1 | I2 | I3 | I4 | I5 | I6 | I7 |
                  L0 | L1 | L2 | L3 | L4 | L5 | L6 | L7
                datatype Tag =
                  ERROR |
                  INTEGER |
                  PAIRPTR |
                  POINTER |
                  REFPTR

                val get_data_from_frame = call_c "debugger frame read"
                val get_next_frame  = call_c "debugger frame next"
                val get_value_from_frame = call_c "debugger frame argument"
                val get_primary_tag = call_c "debugger primary"
                val get_header = call_c "debugger header"
                val get_object_at_address = call_c "debugger object"
                val exit = call_c "system exit"

                datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of ml_value
                datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value * int * int

                local
                  val debugger_call = call_c "debugger call" 
                  val debugger_install = call_c "debugger install" 
                  exception SingleStepHook
                  val dummy = Value.cast SingleStepHook
                in
                  fun install_debugger f = 
                    debugger_install (f,fn (x,y,z,t) => f(x, SINGLE_STEP(y,z,t), dummy),Interrupt)
                  fun call_debugger (f,x) = 
                    debugger_call (f,(0,CONTINUABLE,x))
                  val start_single_stepping = call_c "debugger start single stepping"
                  val stop_single_stepping = call_c "debugger stop single stepping"
                  val call_function = call_c "debugger function call"
                  val tag_as_interesting = call_c "debugger tag as interesting"
                  val untag_as_interesting = call_c "debugger untag as interesting"
                  val get_code_object_debug_info = call_c "debugger get debug info"
                end
              end

d1058 7
a1079 1
			val TimerOverflow : T
d1084 1
d1093 1
a1093 1
                          Profile | TimerOverflow | Value | Load | Unbound |
a1104 1
		    val TimerOverflow =	call_c "exception TimerOverflow"
d1109 1
d1117 27
d1166 1
a1169 1
        Exception.TimerOverflow	:= MLWorks.Internal.Timer.TimerOverflow;
@


1.66
log
@call_debugger now takes the debugger function as well as the exception
@
text
@d22 3
d1218 2
@


1.65
log
@Added string_to_real
@
text
@d22 3
d1102 2
a1103 2
                  fun call_debugger x = 
                    debugger_call (0,CONTINUABLE,x)
@


1.64
log
@Added clear_eof function to IO.
@
text
@d22 3
d984 2
d1150 1
d1158 1
a1158 1
                          Abs | Sqrt | Ln | Exp
d1175 1
d1204 1
@


1.63
log
@Corrected the calls to C for some exceptions.
Contrained ARRAY and BITS.
@
text
@d22 4
d922 1
@


1.62
log
@Added a function to get the debug_info from a code string
@
text
@d22 3
d317 1
a317 1
    structure MLWorks =
d320 1
a320 1
        structure Array =
d898 1
a898 1
        structure Bits =
d912 1
d965 1
d975 2
d1159 3
a1161 3
                    val Abs =		call_c "exception Unbound"
                    val Exp =		call_c "exception Unbound"
                    val Ln =		call_c "exception Unbound"
d1163 1
a1163 1
                    val Sqrt =		call_c "exception Unbound"
@


1.61
log
@Added extra floating point exceptions.
@
text
@d22 3
d1089 1
@


1.60
log
@Corrected some mistakes.
@
text
@d22 3
d1116 1
d1118 1
d1120 2
a1121 2
			val Mod : T
			val Div : T
a1122 2
			val Save : T
			val Profile : T
d1124 3
a1126 1
                        val Value : T
d1128 1
d1130 1
d1135 2
a1136 1
                          Profile | TimerOverflow | Value | Load | Unbound
d1140 1
d1142 1
d1144 2
a1145 2
		    val Mod =		call_c "exception Mod"
		    val Div =		call_c "exception Div"
a1146 2
		    val Save =		call_c "exception Save"
		    val Profile =	call_c "exception Profile"
d1148 3
a1150 1
                    val Value =		call_c "exception Value"
d1152 1
d1154 1
a1157 1

d1168 1
a1168 1
        open MLWorks.Internal.Runtime.Exception
d1170 15
a1184 11
        Io		:= Io "";
        Prod		:= Prod;
        Mod		:= Mod;
        Div		:= Div;
        Substring	:= String.Substring;
        Save		:= MLWorks.Save "";
        Profile		:= MLWorks.Profile "";
        TimerOverflow	:= MLWorks.Internal.Timer.TimerOverflow;
        Value		:= MLWorks.Internal.Value.Value "";
        Load		:= MLWorks.Internal.Runtime.Loader.Load "";
        Unbound		:= MLWorks.Internal.Runtime.Unbound ""
d1186 1
@


1.59
log
@Rationalisation of the MLWorks structure.
@
text
@d22 3
d956 2
a957 2
            structure Unix :
              sig
d1093 2
a1094 2
                structure Loader :
                  sig
d1096 1
a1096 1
                    val load_module = raise Unimplemented "MLWorks.Internal.Runtime.load_module"
d1168 1
a1168 1
        Load		:= MLWorks.Internal.Runtime.Load "";
@


1.58
log
@Added ByteArrays and writebf in FileIO.  Bits structure is now
duplicated at top level.
@
text
@d22 4
d278 1
a278 1
    sharing type instream = MLWorks.System.instream
d280 1
a280 1
    sharing type outstream = MLWorks.System.outstream
d938 2
a939 4
	structure System =
	  struct
            type instream = IO.instream
            type outstream = IO.outstream
d941 2
a942 2
            val system = call_c "system system"
            val environ = call_c "system environ"
d944 14
a957 2
	    exception Profile of string
	    val profile = call_c "profile"
d959 123
a1081 2
	    exception Save of string
	    val save = call_c "image save"
d1083 1
a1083 1
	    structure Unsafe =
d1085 4
a1088 40
                structure Value =
                  struct
                    open BuiltinLibrary_
                    type T = ml_value
                    datatype address = ADDRESS of int
                    exception Value of string

                    (* Most of these operations would be better implemented as built-in code. *)

                    val cast = call_c "identity"
                    val list_to_tuple = call_c "value list to tuple"
                    val tuple_to_list = call_c "value tuple to list"
                    val string_to_real = call_c "value string to real"
                    val real_to_string = call_c "value real to string"
                    fun output _ = raise Unimplemented "MLWorks.System.Unsafe.Value.output unimplemented"
                    fun input _ = raise Unimplemented "MLWorks.System.Unsafe.Value.input unimplemented"
                    val print = call_c "value print"
                    val primary = call_c "value primary"
                    val secondary = call_c "value secondary"
                    val address = call_c "value address"
                    val pointer = call_c "value pointer"
                    val length = call_c "value length"
                    val update = call_c "value update value"
                    val update_byte = call_c "value update byte"
                    val update_header = call_c "value update header"
                    val exn_name = call_c "value exn name"
                    val exn_argument = call_c "value exn argument"
                    val exn_name_string = call_c "value exn name string"
                    fun is_pointer value =
                      case primary value
                        of 0 => false
                         | 1 => true
                         | 2 => false
                         | 3 => true
                         | 4 => false
                         | 5 => true
                         | 6 => false
                         | 7 => true
                         | _ => raise Value "Unexpected number returned by Value.primary"
                  end
d1090 4
a1093 3
		structure Int =
		  struct
		    open BuiltinLibrary_
d1095 1
a1095 3
                    val discard_modules = call_c "system module discard"
		  end
	      end
d1097 1
a1097 3
	    structure Runtime =
	      struct
		structure GC =
d1099 1
a1099 1
		    val message_level = call_c "gc message level"
d1101 1
a1101 1
		  end
d1119 2
d1123 3
a1125 1
			datatype T = Io | Prod | Mod | Div | Substring | Save | Profile | TimerOverflow | Value
d1138 2
a1143 84
	structure Timer =
	  struct
	    exception TimerOverflow

	    datatype time = TIME of int * int * int
	    datatype timer = TIMER of int * int * int * int * int * int

	    val start_timer = call_c "timer start"
	    val check_timer = call_c "timer check"
	    val check_timer_gc = call_c "timer check gc"

	    fun check_timer_sys (TIMER x) = TIME(0,0,0)
	      
	    val makestring = call_c "timer makestring"

	    fun earlier(TIME(hi,lo,usec),TIME(hi',lo',usec')) =
	      (hi < hi') orelse (hi=hi' andalso (lo < lo' orelse (lo=lo' andalso usec < usec')))
	  end

	structure FileIO =
	  struct
	    exception FileDoesNotExist
	    type time = Timer.time
	    datatype fname = PATH of string
	    val mtime = call_c "system mtime"

	    type fd = IO.outstream
	    datatype offset = BEG | CUR | END

	    val seekf = call_c "stream seek out"
	    val openf = call_c "stream reopen out"
	    val closef = IO.close_out
	    val writef = IO.output
            val writebf = call_c "stream output bytearray"
	  end

	structure Debugger =
	  struct
	    open BuiltinLibrary_

	    datatype StackFrame = STACKFRAME of int

	    datatype Register = 
	      I0 | I1 | I2 | I3 | I4 | I5 | I6 | I7 |
	      L0 | L1 | L2 | L3 | L4 | L5 | L6 | L7
	    datatype Tag =
	      ERROR |
	      INTEGER |
	      PAIRPTR |
	      POINTER |
	      REFPTR

	    val get_data_from_frame = call_c "debugger frame read"
	    val get_next_frame  = call_c "debugger frame next"
	    val get_value_from_frame = call_c "debugger frame argument"
	    val get_primary_tag = call_c "debugger primary"
            val get_header = call_c "debugger header"
	    val get_object_at_address = call_c "debugger object"
	    val exit = call_c "system exit"
	    val coerce_object_to_string = call_c "identity"
	    val coerce_object_to_int = call_c "identity"
	    val coerce_object_to_real = call_c "identity"
	      
	    datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of ml_value
	    datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value * int * int

	    local
	      val debugger_call = call_c "debugger call" 
	      val debugger_install = call_c "debugger install" 
	      exception SingleStepHook
	      val dummy = call_c "identity" SingleStepHook
	    in
	      fun install_debugger f = 
		debugger_install (f,fn (x,y,z,t) => f(x, SINGLE_STEP(y,z,t), dummy),Interrupt)
	      fun call_debugger x = 
		debugger_call (0,CONTINUABLE,x)
	      val start_single_stepping = call_c "debugger start single stepping"
              val stop_single_stepping = call_c "debugger stop single stepping"
	      val call_function = call_c "debugger function call"
	      val tag_as_interesting = call_c "debugger tag as interesting"
	      val untag_as_interesting = call_c "debugger untag as interesting"
	    end
	  end

d1153 15
a1167 9
      (MLWorks.System.Runtime.Exception.Io := Io "";
       MLWorks.System.Runtime.Exception.Prod := Prod;
       MLWorks.System.Runtime.Exception.Mod := Mod;
       MLWorks.System.Runtime.Exception.Div := Div;
       MLWorks.System.Runtime.Exception.Substring := String.Substring;
       MLWorks.System.Runtime.Exception.Save := MLWorks.System.Save "";
       MLWorks.System.Runtime.Exception.Profile := MLWorks.System.Profile "";
       MLWorks.System.Runtime.Exception.TimerOverflow := MLWorks.Timer.TimerOverflow;
       MLWorks.System.Runtime.Exception.Value := MLWorks.System.Unsafe.Value.Value "")
@


1.57
log
@Added extra unsafe value utilities.
Enriched the Array structure using unsafe sub and update operations.
@
text
@d22 4
d214 2
d222 1
d299 1
d311 302
d850 19
d874 1
a874 1
            exception Substring
d1075 1
d1119 1
a1119 1
              fun stop_single_stepping _ = raise Unimplemented "MLWorks.Debugger.stop_single_stepping"
@


1.56
log
@Added Value structure with utilities for dealing with
opaque values and casting.  Removed duplicate functions
elsewhere.
Added output and input functions to deal with more types
than strings.
@
text
@d22 7
d293 1
a293 1
    structure Array =
d295 7
a301 1
        open BuiltinLibrary_
d303 217
a519 16
        datatype 'a array = Array of ml_value
          
        fun arrayoflist [] = array (0, 0)
          | arrayoflist (x as (h::_)) =
            let
              fun len ([],x) = x
                | len (_::t,x) = len (t,x+1)

              val a = array (len (x,0), h)

              fun set_it ([],_) = a
                | set_it (h::t,x) = (update(a,x,h); set_it(t,x+1))
            in
              set_it(x, 0)
            end
      end
d521 18
a538 10
    structure String : STRING =
      struct
	open BuiltinLibrary_
	exception Substring
	val substring : string * int * int -> string = call_c "string substring"
	val op <  : string * string -> bool = call_c "string less"
	val op >  : string * string -> bool = call_c "string greater"
	val op <= : string * string -> bool = not o (op >)
	val op >= : string * string -> bool = not o (op <)
      end
d540 1
a540 2
    structure MLWorks =
      struct
d542 10
a551 2
        structure Array = Array
        structure String = String
a618 3
	    val val_print = call_c "system value print"
	    val exn_name = call_c "system exception name"

d625 1
d627 3
d637 23
d666 1
d799 4
@


1.55
log
@Added inline ordof
@
text
@d22 3
d206 5
d260 1
d262 1
a274 3
    structure Array   : ARRAY
    structure String  : STRING
    structure MLWorks : MLWORKS
d284 1
a284 1
    exception NotImplemented
a285 1
    (* Define arrays here *)
a311 6
(* And now it is
	(* This should be primitive !! *)
	fun ordof(x, i) =
	  if i < 0 orelse i >= size x then raise Ord
	  else ord(substring(x, i, 1))
*)
a317 15
    datatype instream = INSTREAM of ml_value
    datatype outstream = OUTSTREAM of ml_value
      
    val std_in = call_c "stream std_in"
    val std_out = call_c "stream std_out"
    val lookahead = call_c "stream lookahead"
    val open_in = call_c "stream open in"
    val open_out = call_c "stream open out"
    val input = call_c "stream input"
    val output = call_c "stream output"
    val close_in = call_c "stream close in"
    val close_out = call_c "stream close out"

    fun end_of_stream s = lookahead s = ""
        
d320 1
d331 26
a356 2
	    type instream = instream
	    type outstream = outstream
d376 83
d485 1
a485 1
	    type fd = outstream
d490 2
a491 2
	    val closef = close_out
	    val writef = output
a528 1
	      val start_single_stepping = call_c "debugger start single stepping"
d534 2
a535 1
	      val start_single_stepping = fn () => start_single_stepping ()
d542 1
a542 23
	structure System =
	  struct
            val system = call_c "system system"
            val environ = call_c "system environ"

	    type outstream = outstream
	    exception Profile of string
	    val profile = call_c "profile"

	    exception Save of string
	    val save = call_c "image save"

	    val val_print = call_c "system value print"
	    val exn_name = call_c "system exception name"

	    structure Unsafe =
	      struct
		structure Int =
		  struct
		    open BuiltinLibrary_
                    val load_wordset = call_c "system load wordset"
		  end
	      end
d544 1
a544 10
	    structure Runtime =
	      struct
		structure GC =
		  struct
		    val message_level = call_c "gc message level"
                    val interface = call_c "gc interface"
		  end
            
		structure Exception =
		  struct
a545 31
		    (* Remove the constructor status from the exception names so that they can be rebound. *)
		    structure S :
		      sig
			type T
			val Io : T
			val Prod : T
			val Mod : T
			val Div : T
			val Substring : T
			val Save : T
			val Profile : T
			val TimerOverflow : T
		      end =
		      struct
			datatype T = Io | Prod | Mod | Div | Substring | Save | Profile | TimerOverflow
		      end
		    open S
		      
		    val Io =		call_c "exception Io"
		    val Prod =		call_c "exception Prod"
		    val Mod =		call_c "exception Mod"
		    val Div =		call_c "exception Div"
		    val Substring =	call_c "exception Substring"
		    val Save =		call_c "exception Save"
		    val Profile =	call_c "exception Profile"
		    val TimerOverflow =	call_c "exception TimerOverflow"
		  end
	      end
	  end
      end
    
d554 2
a555 1
       MLWorks.System.Runtime.Exception.TimerOverflow := MLWorks.Timer.TimerOverflow)
@


1.54
log
@Added MLWorks.System.Runtime.GC.interface.
@
text
@d22 3
d245 1
d301 1
a301 1
    structure String =
d303 1
d306 1
d311 1
@


1.53
log
@Added temporary implementation of MLWorks.IO.input_line
@
text
@d22 3
d471 1
@


1.52
log
@Fixed parameters within ordof
@
text
@d22 3
d335 1
d338 16
@


1.51
log
@Moved definition of ord, so that it picks up the integer
comparison operations instead of the string ones.
@
text
@d22 4
d297 1
a297 1
	  if i < 0 orelse i >= size s then raise Ord
@


1.50
log
@Added a function to get header information from an ml_object
@
text
@d22 3
d290 1
a290 5
	val substring = call_c "string substring"
	val op <  = call_c "string less"
	val op >  = call_c "string greater"
	val op <= = not o (op >)
	val op >= = not o (op <)
d293 6
a298 3
	  if i < 0 orelse i >= size x then raise Ord
	  else
	    ord(substring(x, i, 1))
@


1.49
log
@Work on tracing
@
text
@d22 3
d267 1
a267 1
        type 'a array = ml_value
d299 2
a300 2
    type instream = ml_value
    type outstream = ml_value
d369 1
a369 1
	    type StackFrame = int
d385 1
d390 1
@


1.48
log
@Changed MLworks to MLWorks.
@
text
@d22 3
d388 1
a388 1
	    datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value * int
d398 1
a398 1
		debugger_install (f,fn (x,y,z) => f(x, SINGLE_STEP(y,z), dummy),Interrupt)
@


1.47
log
@Added load_wordset to interpreter structure.
@
text
@d22 3
d244 1
a244 1
    structure MLworks : MLWORKS
d308 1
a308 1
    structure MLworks =
d471 8
a478 8
      (MLworks.System.Runtime.Exception.Io := Io "";
       MLworks.System.Runtime.Exception.Prod := Prod;
       MLworks.System.Runtime.Exception.Mod := Mod;
       MLworks.System.Runtime.Exception.Div := Div;
       MLworks.System.Runtime.Exception.Substring := String.Substring;
       MLworks.System.Runtime.Exception.Save := MLworks.System.Save "";
       MLworks.System.Runtime.Exception.Profile := MLworks.System.Profile "";
       MLworks.System.Runtime.Exception.TimerOverflow := MLworks.Timer.TimerOverflow)
@


1.46
log
@Major reorganisation so that we have a MLworks structure, with more
sensibly organised sub-structures.
@
text
@d22 4
d422 1
@


1.45
log
@Changed the functionality of some of the debugger functions - added support
for tracing
@
text
@d168 3
a171 107
signature ARRAY =
  sig
    eqtype 'a array
    exception Size
    exception Subscript
    val array : int * '_a -> '_a array
    val length : 'a array -> int
    val update : 'a array * int * 'a -> unit
    val sub : 'a array * int -> 'a
    val arrayoflist : '_a list -> '_a array 
  end;

signature STRING =
  sig
    val substring : string * int * int -> string
    val < : string * string -> bool
    val > : string * string -> bool
    val <= : string * string -> bool
    val>= : string * string -> bool
  end;

signature SYSIO =
  sig
    exception FileDoesNotExist
    type time
    datatype fname = PATH of string
    val mtime : fname -> time
  end

signature INT =
  sig
    type ml_value
    val call_ml_value         : ml_value -> ml_value list
    val make_ml_value         : 'a -> ml_value
    val make_ml_value_tuple   : ml_value list -> ml_value
    val ml_value_from_offset  : ml_value * int -> ml_value
    val ml_require            : string -> ml_value 
  end
 
signature UNSAFE =
  sig
    structure SysIO : SYSIO
  end

signature TIMER =
  sig
    exception TimerOverflow
    datatype time = TIME of int * int * int
    type timer
    val start_timer : unit -> timer
    val check_timer : timer -> time
    val check_timer_sys : timer -> time
    val check_timer_gc : timer -> time
    val makestring  : time -> string
    val earlier : time * time -> bool
  end

  signature BITS =
    sig
      val andb                  : int * int -> int
      val orb                   : int * int -> int
      val xorb                  : int * int -> int
      val lshift                : int * int -> int
      val rshift                : int * int -> int
      val arshift               : int * int -> int
      val notb                  : int -> int
    end;

signature DEBUGGER = 
  sig
    type StackFrame
    type ml_value

    datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of ml_value
    datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value * int

    val install_debugger : (StackFrame * Type_Of_Exception * ml_value -> Debugger_Result) -> unit
    val call_debugger : exn -> unit

    val get_data_from_frame : StackFrame -> string
    val get_next_frame : StackFrame -> bool * StackFrame * int
    val start_single_stepping : unit -> unit

    datatype Register = 
      I0 | I1 | I2 | I3 | I4 | I5 | I6 | I7 |
      L0 | L1 | L2 | L3 | L4 | L5 | L6 | L7
    datatype Tag =
      ERROR |
      INTEGER |
      PAIRPTR |
      POINTER |
      REFPTR
    val get_value_from_frame : StackFrame * Register -> ml_value
    val get_primary_tag : ml_value -> Tag

    val get_object_at_address : ml_value * int -> ml_value
    val exit : int -> 'a

    val coerce_object_to_string : ml_value -> string
    val coerce_object_to_int : ml_value -> int

    val call_function : ml_value * ml_value * int -> ml_value
    val tag_as_interesting : ml_value -> unit
    val untag_as_interesting : ml_value -> unit

  end;

a172 1

a173 1

a220 2
    structure Array : ARRAY
      
a223 51
    structure System :
      sig
        exception Profile of string
        val profile : outstream * int * (unit -> 'a) -> 'a

        exception Save of string
        val save : string * (unit -> 'a) -> unit -> 'a

        val val_print : 'a * int -> 'a * int
        val exn_name : exn -> string

        structure Unsafe :
          sig
            structure Int : INT
          end

        structure Runtime :
          sig
            structure GC :
              sig
                val message_level : int ref
              end

            structure Exception :
              sig
                val Io : exn ref
                val Mod : exn ref
                val Div : exn ref
                val Substring : exn ref
                val Save : exn ref
                val Profile : exn ref
                val TimerOverflow : exn ref
              end
          end
      end
    
    structure NewJersey :
      sig
        structure Array : ARRAY
        structure String : STRING
        val flush_out : outstream -> unit
        structure Bits : BITS
        structure System :
          sig
            val system : string -> int
            val environ : unit -> string list
            structure Timer : TIMER
            structure Unsafe : UNSAFE
          end
      end
    
d235 3
a237 5
    exception Substring
    val substring : string * int * int -> string
      
    structure Debugger : DEBUGGER
      
d247 2
d271 1
a271 1
    structure System =
d273 12
a284 26
        exception Profile of string
        val profile = call_c "profile"

        exception Save of string
        val save = call_c "image save"

        val val_print = call_c "system value print"
        val exn_name = call_c "system exception name"

	structure Unsafe =
	  struct
	    structure Int =
	      struct
		open BuiltinLibrary_
	      end
	  end

        structure Runtime =
          struct
            structure GC =
              struct
                val message_level = call_c "gc message level"
              end
            
            structure Exception =
              struct
a285 30
                (* Remove the constructor status from the exception names so that they can be rebound. *)
                structure S :
                  sig
                    type T
                    val Io : T
                    val Prod : T
                    val Mod : T
                    val Div : T
                    val Substring : T
                    val Save : T
                    val Profile : T
                    val TimerOverflow : T
                  end =
                  struct
                    datatype T = Io | Prod | Mod | Div | Substring | Save | Profile | TimerOverflow
                  end
                open S

                val Io =		call_c "exception Io"
                val Prod =		call_c "exception Prod"
                val Mod =		call_c "exception Mod"
                val Div =		call_c "exception Div"
                val Substring =		call_c "exception Substring"
                val Save =		call_c "exception Save"
                val Profile =		call_c "exception Profile"
                val TimerOverflow =	call_c "exception TimerOverflow"
              end
          end
      end
    
d301 1
a301 4
    exception Substring
    val substring = call_c "string substring"
          
    structure NewJersey =
d304 3
a306 1
        structure String =
d308 1
a308 9
            val substring = substring
            nonfix <
            nonfix >
            nonfix <=
            nonfix >=
            val < = call_c "string less"
            val > = call_c "string greater"
            val <= = not o >
            val >= = not o <
d311 12
a322 1
        val flush_out = call_c "stream flush"
d324 3
a326 4
        structure Bits : BITS =
          struct
            open BuiltinLibrary_
          end
d328 3
a330 2
        structure System =
          struct
d332 3
a334 2
            val system = call_c "system system"
            val environ = call_c "system environ"
d336 15
a350 3
            structure Timer : TIMER =
              struct
                exception TimerOverflow
d352 3
a354 2
                datatype time = TIME of int * int * int
                datatype timer = TIMER of int * int * int * int * int * int
d356 1
a356 3
                val start_timer = call_c "timer start"
                val check_timer = call_c "timer check"
                val check_timer_gc = call_c "timer check gc"
d358 39
a396 1
                fun check_timer_sys (TIMER x) = TIME(0,0,0)
d398 4
a401 1
                val makestring = call_c "timer makestring"
d403 3
a405 2
                fun earlier(TIME(hi,lo,usec),TIME(hi',lo',usec')) =
                  (hi < hi') orelse (hi=hi' andalso (lo < lo' orelse (lo=lo' andalso usec < usec')))
d407 2
a408 14
              end
            
            structure Unsafe =
              struct
                structure SysIO =
                  struct
                    exception FileDoesNotExist
                    type time = Timer.time
                    datatype fname = PATH of string
                    val mtime = call_c "system mtime"
                  end
              end
          end
      end
d410 2
a411 2
    structure Debugger : DEBUGGER =
      struct
d413 7
a419 1
	open BuiltinLibrary_
d421 9
a429 1
        type StackFrame = int
d431 29
a459 38
        datatype Register = 
          I0 | I1 | I2 | I3 | I4 | I5 | I6 | I7 |
          L0 | L1 | L2 | L3 | L4 | L5 | L6 | L7
        datatype Tag =
          ERROR |
          INTEGER |
          PAIRPTR |
          POINTER |
          REFPTR

        val get_data_from_frame = call_c "debugger frame read"
        val get_next_frame  = call_c "debugger frame next"
        val get_value_from_frame = call_c "debugger frame argument"
        val get_primary_tag = call_c "debugger primary"
        val get_object_at_address = call_c "debugger object"
        val exit = call_c "system exit"
        val coerce_object_to_string = call_c "identity"
        val coerce_object_to_int = call_c "identity"

        datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of ml_value
        datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value * int

        local
          val debugger_call = call_c "debugger call" 
          val debugger_install = call_c "debugger install" 
          exception SingleStepHook
          val dummy = call_c "identity" SingleStepHook
          val start_single_stepping = call_c "debugger start single stepping"
        in
          fun install_debugger f = 
            debugger_install (f,fn (x,y,z) => f(x, SINGLE_STEP(y,z), dummy),Interrupt)
          fun call_debugger x = 
            debugger_call (0,CONTINUABLE,x)
          val start_single_stepping = fn () => start_single_stepping ()
          val call_function = call_c "debugger function call"
          val tag_as_interesting = call_c "debugger tag as interesting"
          val untag_as_interesting = call_c "debugger untag as interesting"
        end
d461 1
a461 1

d463 9
a471 10
      (System.Runtime.Exception.Io := Io "";
       System.Runtime.Exception.Prod := Prod;
       System.Runtime.Exception.Mod := Mod;
       System.Runtime.Exception.Div := Div;
       System.Runtime.Exception.Substring := Substring;
       System.Runtime.Exception.Save := System.Save "";
       System.Runtime.Exception.Profile := System.Profile "";
       System.Runtime.Exception.TimerOverflow := NewJersey.System.Timer.TimerOverflow)
  end

@


1.44
log
@Added missing binding of runtime exception Prod.
@
text
@d22 3
d242 2
a243 2
    datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP
    datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value
d270 3
a272 1
    val call_function : ml_value * ml_value -> ml_value
d595 2
a596 2
        datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP
        datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value
d606 1
a606 1
            debugger_install (f,fn (x,y) => f(x, SINGLE_STEP(y), dummy),Interrupt)
d611 2
@


1.43
log
@Added debugger.call_function
@
text
@d22 3
d459 1
d468 1
a468 1
                    datatype T = Io | Mod | Div | Substring | Save | Profile | TimerOverflow
d473 1
d611 1
@


1.42
log
@Cahnges to call_debugger and install_debugger
@
text
@d22 3
d237 1
a237 1
    datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP
d244 1
d264 2
d586 1
a586 1
        datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP
d591 3
d596 1
a596 1
            debugger_install (f,fn x => f(x, SINGLE_STEP, call_c "identity" ()),Interrupt)
d599 2
@


1.41
log
@rather than numeric codes.
Rewrote everything to communicate with C using the runtime environment
rather than numeric codes.
Added a System.Runtime structure.  More to come later.
@
text
@d22 6
d582 9
a590 8
        fun install_debugger f = 
          call_c "debugger install" (f,fn x => f(x, SINGLE_STEP, call_c "identity" ()),Interrupt)
        fun call_debugger x = 
          let
            val frame = call_c "debugger frame" ()
          in
            call_c "debugger call" () (frame,true,x)
          end
@


1.40
log
@Added profile,save - hack version of weakarrays
@
text
@d5 14
d22 3
a151 17
(*
  This is the file that is implicitly loaded before any of the other files are compiled 
  It is compiled in a type environment which is the same as that for the 
  __builtin_library file - i.e. the following types are defined unit,list
  and the constructors are ::,nil

 The following are implicitly defined - see typechecker/_valenv and 
            =,~,abs,*,+,-,<,>,<=,>=
  at the beginning of each file 

  This file could be written in the standard way, but then the BUILTIN's would not
  be propogated thorugh the environment

*)


require "__callc_codes";
d163 1
a163 1
    val arrayoflist : '_a list -> 'a array 
a165 14
signature WEAKARRAY =
  sig
    eqtype 'a weakarray
    exception Size
    exception Subscript
    datatype 'a Result = InValid | Valid of 'a
    val array : int * '_a -> '_a weakarray
    val length : 'a weakarray -> int
    val update : 'a weakarray * int * 'a -> unit
    val sub : 'a weakarray * int -> 'a Result
    val arrayoflist : '_a list -> 'a weakarray 
  end;
  
  
d260 62
a321 49
      exception Abs
      exception Bind
      exception Chr
      exception Diff
      exception Div
      exception Exp
      exception Floor
      exception Interrupt
      exception Io of string
      exception Ln
      exception Match
      exception Mod
      exception Neg
      exception Ord
      exception Prod
      exception Quot
      exception Sqrt
      exception Sum
      exception Size
      exception Subscript

      val floor                 : real -> int
      val real                  : int -> real
      val /                     : real * real -> real
      val div                   : int * int -> int
      val !                     : 'a ref -> 'a
      val :=                    : 'a ref * 'a -> unit
      val   @@                   : 'a list * 'a list -> 'a list
      val arctan                : real -> real
      val chr                   : int -> string
      val o                     : ('b -> 'c) * ('a -> 'b) -> ('a -> 'c)
      val ^                     : string * string -> string
      val cos                   : real -> real
      val exp                   : real -> real
      val explode               : string -> string list
      val implode               : string list -> string
      val ln                    : real -> real
      val map                   : ('a -> 'b) -> 'a list -> 'b list
      val mod                   : int * int -> int
      val not                   : bool -> bool
      val  <>    		: ''a * ''a -> bool
      val ord                   : string -> int
      val rev                   : 'a list -> 'a list
      val sin                   : real -> real
      val size                  : string -> int
      val sqrt                  : real -> real
        
        structure Array : ARRAY
        structure WeakArray : WEAKARRAY
d323 4
a326 2
        type instream
        type outstream
d328 1
a328 1
        structure System :
d330 1
a330 6
            exception ProfilingFailed
            val profile : (outstream * int) -> ('a -> 'b) -> ('a -> 'b)
            val save : string * ('a -> 'b) -> bool
            val val_print : 'a * int -> 'a * int
            val exn_name : exn -> string
            structure Unsafe :
d332 1
a332 1
                structure Int : INT
a333 2
          end

d335 1
a335 7
	structure NewJersey :
	  sig
	    structure Array : ARRAY
	    structure String : STRING
	    val flush_out : outstream -> unit
            structure Bits : BITS
            structure System :
d337 7
a343 4
                val system : string -> int
                val environ : unit -> string list
                structure Timer : TIMER
                structure Unsafe : UNSAFE
d345 34
a378 18
	  end

        val std_in                : instream
        val std_out               : outstream
        val open_in               : string -> instream
        val open_out              : string -> outstream
        val end_of_stream         : instream -> bool
        val input                 : instream * int -> string
        val lookahead             : instream -> string
        val output                : outstream * string -> unit
        val close_in              : instream -> unit
        val close_out             : outstream -> unit

        exception Substring
        val substring : string * int * int -> string

        structure Debugger : DEBUGGER

d391 3
a393 2
        datatype 'a array = dummy_constructor
        open BuiltinLibrary_ ;
d395 1
a395 1
        fun arrayoflist [] = array(0,0)
d398 7
a404 7
              fun len([],x) = x
                | len(_::t,x) = len(t,x+1)
              val a = array(len (x,0),h)
              fun set_it ([],_) = ()
                | set_it (h::t,x) = 
                  (update(a,x,h) ; 
                   set_it(t,x+1))
d406 2
a407 4
              set_it(x,0) ;
              a
            end 
          
a409 39
    structure WeakArray = 
      struct
        datatype 'a weakarray = dummy_constructor
        datatype 'a Result = InValid | Valid of 'a
        open BuiltinLibrary_ ;
        exception Size
        exception Subscript
        val length = length
        val sub = fn(arr,i) => 
          (let
            val elem = sub(arr,i)
          in
            if call_c(CallCCodes_.check_weak_validity,elem)
              then Valid(elem)
            else InValid
          end
        handle BuiltinLibrary_.Subscript => raise Subscript)
        val update = fn (arr,i,v) => (update(arr,i,v) handle BuiltinLibrary_.Subscript => raise Subscript)
        fun array (arg as (s,el)) =
          if s<0
            then raise Size
          else call_c(CallCCodes_.make_into_weak_array,arg)
        fun arrayoflist [] = array(0,0)
          | arrayoflist (x as (h::_)) =
            let
              fun len([],x) = x
                | len(_::t,x) = len(t,x+1)
              val a = array(len (x,0),h)
              fun set_it ([],_) = ()
                | set_it (h::t,x) = 
                  (update(a,x,h) ; 
                   set_it(t,x+1))
            in
              set_it(x,0) ;
              a
            end 
          
      end
    
d412 2
d415 2
a416 1
        exception ProfilingFailed
d418 3
a420 12
        fun profile (filename,freq) f = 
          case call_c(CallCCodes_.profile,(filename,freq,f)) of
            (true,result) => result
          | (false,_) => raise ProfilingFailed

        fun save x = 
          call_c(CallCCodes_.save_image,x) 

        fun val_print x = 
          call_c(CallCCodes_.val_print,x)
        fun exn_name x = 
          call_c(CallCCodes_.exn_name,x)
d428 37
d467 2
a468 3
    (* define the input/output code here *)
    type instream = int * bool ref
    type outstream = int * bool ref
d470 9
a478 51
    val std_in = (0, ref true)
    val std_out = (1, ref true)
      
    fun lookahead (_, ref false) = ""
      | lookahead (n, ref true) = call_c (CallCCodes_.lookahead, n) : string
        
    fun open_in (s : string) =
      case call_c (CallCCodes_.open_in, s) : (bool * int)
        of (true, stream) => (stream,ref true)
         | (false, _) => raise Io (("Cannot open " ^ s))
             
    fun open_out (s : string) =
      case call_c (CallCCodes_.open_out, s) : (bool * int)
        of (true, stream) => (stream,ref true)
         | (false, _) =>
             raise Io
               ("PervasiveLibrary: A file doesn't exist and cannot be created \
                \due to naming, access, or quota restrictions.  The error \
                \occurred on open_out of " ^ s)
               
    fun input((_,ref false),_) =
        raise Io "Attempt to input from a closed stream"
      | input ((stream,ref true), x : int) =
        case call_c (CallCCodes_.input, (stream, x)) : int * string
          of (0, result) => result
           | (_, _) => 
               raise Io
                 "PervasiveLibrary: An I/O error occurred during reading."

    fun output((_,ref false),_) =
        raise Io "Attempt to output to a closed stream"
      | output ((stream,ref true), s : string) =
        case call_c (CallCCodes_.output, (stream, s)) : int
          of 0 => ()
           | _ => raise Io "PervasiveLibrary: An I/O error occurred during writing."
                 
    fun close_in(_,ref false) =
        raise Io "Attempt to close_in a closed stream"
      | close_in (stream,ref true) =
        if call_c (CallCCodes_.close_in, stream) : bool then
          ()
        else
          raise Io "PervasiveLibrary: The `C' close_in function returned an error condition."
            
    fun close_out(_,ref false) =
        raise Io "Attempt to close_out a closed stream"
      | close_out (stream,ref true) = 
        if call_c (CallCCodes_.close_out, stream) : bool then
          ()
        else
          raise Io "PervasiveLibrary: The `C' close_out function returned an error condition."
a481 2
    (* String code *)
      
d483 1
a483 4
    fun substring x =
      case call_c(CallCCodes_.substring, x) : bool * string of
        (false, _) => raise Substring
      | (_, s) => s
d495 2
a496 2
            fun < x = call_c(CallCCodes_.string_less, x)
            fun > x  = call_c(CallCCodes_.string_greater, x)
d500 3
a502 1
        fun flush_out _ = ()
d505 1
a505 1
            open BuiltinLibrary_;
d511 2
a512 2
            fun system x =  call_c(CallCCodes_.system, x) 
            fun environ x =  call_c(CallCCodes_.environ, x) 
d521 3
a523 14
                fun start_timer () =
                  case call_c(CallCCodes_.start_timer, 0) of
                    (true,x) => TIMER x 
                  | (false,x) => raise TimerOverflow

                fun check_timer(TIMER x) =
                  case call_c(CallCCodes_.check_timer, x) of
                    (true,x) => TIME(x)
                  | (false,x) => raise TimerOverflow

                fun check_timer_gc(TIMER x) =
                  case call_c(CallCCodes_.check_timer_gc, x) of
                    (true,x) => TIME(x)
                  | (false,x) => raise TimerOverflow
d525 1
a525 1
                fun check_timer_sys(TIMER x) = TIME(0,0,0)
d527 1
a527 2
                fun makestring(TIME x) =
                  call_c(CallCCodes_.makestring_timer, x) 
d541 1
a541 4
                    fun mtime (PATH filename) = 
                      case call_c(CallCCodes_.mtime, filename) of
                        (true,x) => Timer.TIME(x)
                      | (false,x) => raise FileDoesNotExist
a548 5
        (* 
           This is the only hack - ml_value could really be anything, but using int is handy,
           since we do a lot of coercing from value to int (constructors tags etc), and hence
           we may do it without any work 
           *)
d564 8
a571 8
        fun get_data_from_frame frame = call_c(CallCCodes_.get_data_from_frame, frame)
        fun get_next_frame frame = call_c(CallCCodes_.get_next_frame, frame)
        fun get_value_from_frame x = call_c(CallCCodes_.get_argument_from_frame, x)
        fun get_primary_tag x = call_c(CallCCodes_.get_primary_tag, x)
        fun get_object_at_address x = call_c(CallCCodes_.get_object_at_address, x)
        fun exit x = call_c(CallCCodes_.exit,x)
        fun coerce_object_to_string x = call_c(CallCCodes_.identity,x)
        fun coerce_object_to_int x = call_c(CallCCodes_.identity,x)
d577 1
a577 1
          call_c(CallCCodes_.install_debugger, (f,fn x => f(x,SINGLE_STEP,0),Interrupt))
d580 1
a580 1
            val frame = call_c(CallCCodes_.get_stack_frame,())
d582 1
a582 1
            (call_c(CallCCodes_.generate_debugger_call,())) (frame,true,x)
d586 8
@


1.39
log
@Changed the debugger to return a datatype for its desired result action
@
text
@d8 3
d166 14
a224 10
  signature SYSTEM =
    sig
      val val_print : 'a * int -> 'a * int
      val exn_name : exn -> string
      structure Unsafe :
	sig
	  structure Int : INT
	end
    end;

d322 1
a323 2
        structure System : SYSTEM

d327 14
d403 39
d445 11
@


1.38
log
@get_next_frame now additionally returns the PC offset into the code string
@
text
@d8 3
d234 4
a237 1
    val install_debugger : (StackFrame * bool * ml_value -> unit) -> unit
a260 3
    val set_breakpoint   : ('a -> 'b) -> bool 
    val unset_breakpoint : ('a -> 'b) -> bool

a560 1
        exception BreakPoint 
d571 2
a572 2
        fun set_breakpoint x = call_c(CallCCodes_.set_breakpoint,x)
        fun unset_breakpoint x = call_c(CallCCodes_.unset_breakpoint,x)
d575 1
a575 1
          call_c(CallCCodes_.install_debugger, (f,Interrupt,BreakPoint))
@


1.37
log
@Changed the call_debugger function
@
text
@d8 3
d235 1
a235 1
    val get_next_frame : StackFrame -> bool * StackFrame
@


1.36
log
@Added a manual call of the debugger for the interpreter
@
text
@d8 3
d571 6
a576 1
        val call_debugger = call_c(CallCCodes_.generate_debugger_call,())
@


1.35
log
@Changed MLObject to be the same as ml_value used by the interpreter
@
text
@d8 3
d225 3
a227 1
    val install_debugger : (StackFrame * bool * ml_value -> bool) -> unit
d249 2
a250 2
    val set_breakpoint   : ml_value -> bool 
    val unset_breakpoint : ml_value -> bool
d553 1
a553 2
        fun install_debugger f = 
          call_c(CallCCodes_.install_debugger, (f,Interrupt,BreakPoint))
d562 1
d565 4
d572 1
@


1.34
log
@Added breakpointing functions
@
text
@d8 3
d213 1
a213 1
      val arshift                : int * int -> int
d220 1
a220 1
    type MlObject
d222 1
a222 1
    val install_debugger : (StackFrame * bool * MlObject -> bool) -> unit
d235 2
a236 2
    val get_value_from_frame : StackFrame * Register -> MlObject
    val get_primary_tag : MlObject -> Tag
d238 1
a238 1
    val get_object_at_address : MlObject * int -> MlObject
d241 2
a242 2
    val coerce_object_to_string : MlObject -> string
    val coerce_object_to_int : MlObject -> int
d244 2
a245 2
    val set_breakpoint   : MlObject -> bool 
    val unset_breakpoint : MlObject -> bool
d529 1
a529 1
           This is the only hack - MlObject could really be anything, but using int is handy,
a532 1
        type MlObject = int
d534 2
d537 1
d557 1
a557 1
        fun coerce_object_to_int x = x
@


1.33
log
@Changes for the debugger
@
text
@d8 3
d168 1
a168 1
    val call_ml_value         : ml_value -> ml_value
d172 1
a172 1
    val ml_require            : string -> ml_value list
d219 1
a219 1
    val install_debugger : (StackFrame * bool * MlObject -> unit) -> unit
d240 4
d542 1
d544 1
a544 1
          call_c(CallCCodes_.install_debugger, (f,Interrupt))
d553 2
@


1.32
log
@Added ML_REQUIRE builtin for interpreter
Rearranged System to include the unsafe interpreter stuff (was in NJ)
@
text
@d8 4
d214 3
a216 1
    val install_debugger : (StackFrame * bool -> unit) -> unit
a219 1
    type MlObject
@


1.31
log
@Added new builtin ml_value_from_offset for getting pointers into
middles of code vectors for letrecs
@
text
@d8 4
d165 1
a170 1
    structure Int : INT
d190 4
d361 7
a506 5
		structure Int =
		  struct
		    open BuiltinLibrary_
		  end

@


1.30
log
@Added extra functions load_var, load_exn, load_struct, load_funct for
interpreter in structure Int inside Unsafe
@
text
@d8 4
d160 1
@


1.29
log
@Added the debugger structure of debugger utilities
@
text
@d8 3
d150 8
d161 1
d487 5
@


1.28
log
@Added Bits.arshift - arithmetic right shift
@
text
@d8 3
d182 27
d296 2
d478 32
@


1.27
log
@Added timers and code for compiling the make system
@
text
@d8 3
d175 1
@


1.26
log
@Added the Bits structure
@
text
@d8 3
d133 26
d239 7
d387 53
@


1.25
log
@Changed pervasive arrayoflist to allow nil arguments
@
text
@d8 3
d138 6
a143 1
      val andb : int * int -> int
d350 1
a350 2
            exception NotDefinedYet
            fun andb _ = raise NotDefinedYet
@


1.24
log
@Added NewJersey.Bits.andb so that we can still compile everything with our compiler
@
text
@d8 3
d233 1
a233 1
        fun arrayoflist [] = raise Size
@


1.23
log
@Added exn_name to system structure
@
text
@d8 3
d130 5
d198 1
d337 5
@


1.22
log
@Altered file operations and added lookahead function.
@
text
@d8 3
d123 2
a124 1
      val val_print : 'a * int -> 'a * int 
d242 2
@


1.21
log
@Re-did Io to use fprintf etc
@
text
@d8 3
d211 32
a242 28
      (* Define arrays here *)
      structure Array =
        struct
          datatype 'a array = dummy_constructor
          open BuiltinLibrary_ ;

          fun arrayoflist [] = raise Size
            | arrayoflist (x as (h::_)) =
              let
                fun len([],x) = x
                  | len(_::t,x) = len(t,x+1)
                val a = array(len (x,0),h)
                fun set_it ([],_) = ()
                  | set_it (h::t,x) = 
                    (update(a,x,h) ; 
                     set_it(t,x+1))
              in
                set_it(x,0) ;
                a
              end 

        end

      structure System =
        struct
          fun val_print x = 
            call_c(CallCCodes_.val_print,x)
        end
d244 2
a245 6
      (* define the input/output code here *)
      type instream = int * bool ref
      type outstream = int * bool ref

      val std_in = (0,ref true)
      val std_out = (1,ref true)
d247 2
a248 2
      fun lookahead _ = 
        raise Io "lookahead unimplemented"
d250 13
a262 4
      fun open_in (s) =
        case call_c (CallCCodes_.open_in, s) : (bool * int)
          of (true, stream) => (stream,ref true)
           | (false, _) => raise Io (("Cannot open " ^ s))
a263 10
      fun open_out (s : string) =
        case call_c (CallCCodes_.open_out, s) : (bool * int)
          of (true, stream) => (stream,ref true)
           | (false, _) =>
               raise Io
                 (
                  ("PervasiveLibrary: A file doesn't exist and cannot be created \
                   \due to naming, access, or quota restrictions.  The error \
                   \occurred on open_out of " ^ s))
                   
d265 1
a265 1
      raise Io "But the stream has already been closed"
d274 1
a274 1
      raise Io "But the stream has already been closed"
d278 1
a278 3
           | _ =>
               raise Io
                 "PervasiveLibrary: An I/O error occurred during writing."
d281 1
a281 1
      raise Io "But the stream has already been closed"
d286 1
a286 2
          raise Io "PervasiveLibrary: The `C' close_in function returned \
           \an error condition."
d289 1
a289 1
      raise Io "But the stream has already been closed"
d294 1
a294 2
          raise Io "PervasiveLibrary: The `C' close_out function returned \
           \an error condition."
d296 1
a296 4
    fun end_of_stream(_,ref false) =
      raise Io "But the stream has already been closed"
      | end_of_stream (stream,ref true) = 
        call_c (CallCCodes_.eof, stream)
d298 25
a322 25
      (* String code *)

      exception Substring
      fun substring x =
	case call_c(CallCCodes_.substring, x) : bool * string of
	  (false, _) => raise Substring
	| (_, s) => s

      structure NewJersey =
	struct
	  structure Array = Array
	  structure String =
	    struct
	      val substring = substring
	      nonfix <
	      nonfix >
	      nonfix <=
	      nonfix >=
	      fun < x = call_c(CallCCodes_.string_less, x)
	      fun > x  = call_c(CallCCodes_.string_greater, x)
	      val <= = not o >
	      val >= = not o <
	    end
	  fun flush_out _ = ()
	end
@


1.20
log
@Added val_print in the System structure in ML
@
text
@d8 3
d238 2
a239 2
      type instream = int
      type outstream = int
d241 2
a242 2
      val std_in = 0
      val std_out = 1
d244 2
a245 1
      fun lookahead (s : int) = raise Io "lookahead unimplemented"
d247 1
a247 1
      fun open_in (s : string) =
d249 7
a255 5
          of (true, stream) => stream
           | (false, 0) => raise Interrupt
           | (false, 1) => raise Io (("Cannot open " ^ s))
           | (false, 2) => raise Io (("Cannot open " ^ s))
           | (false, 3) =>
d258 10
a267 4
                  ("PervasiveLibrary: A serious and unexpected error has been \
                   \returned to the `C' open routine from the operating system \
                   \on open_in of " ^ s))
           | (false, ~1) =>
d269 8
a276 5
                 (
                  ("PervasiveLibrary: An error has been returned by the operating \
                   \system which the `C' open function does not know how to \
                   \interpret.  The error occurred on open_in of " ^ s))
           | (false, _) => 
d278 19
a296 5
                 (
                  ("PervasiveLibrary: An unexpected error condition has been \
                   \returned to me from the `C' open function.  This suggests \
                   \that there is a fault in the ML/`C' interface.  The error \
                   \occurred on open_in of " ^ s))
d298 5
a302 98
    fun open_out (s : string) =
      case call_c (CallCCodes_.open_out, s) : (bool * int)
        of (true, stream) => stream
         | (false, 0) => raise Interrupt
         | (false, 1) =>
           raise Io
             (
              ("PervasiveLibrary: A file doesn't exist and cannot be created \
               \due to naming, access, or quota restrictions.  The error \
               \occurred on open_out of " ^ s))
         | (false, 2) =>
           raise Io
             (
              ("PervasiveLibrary: A serious and unexpected error has been \
               \returned to the `C' open routine from the operating system \
               \on open_out of " ^ s))
         | (false, ~1) =>
           raise Io
             (
              ("PervasiveLibrary: An error has been returned by the operating \
               \system which the `C' open function does not know how to \
               \interpret.  The error occurred on open_out of " ^ s))
         | (false, _) => 
           raise Io
             (
              ("PervasiveLibrary: An unexpected error condition has been \
               \returned to me from the `C' open function.  This suggests \
               \that there is a fault in the ML/`C' interface.  The error \
               \occurred on open_out of " ^ s))


    fun input (stream : int, x : int) =
      case call_c (CallCCodes_.input, (stream, x)) : int * string
        of (0, result) => result
         | (1, _) =>
           raise Io
             "PervasiveLibrary: There has been an attempt to read from \
             \an invalid stream; possibly unopened."
         | (2, _) => 
           raise Io
             "PervasiveLibrary: An I/O error occurred during reading."
         | (3, _) =>
           raise Io
             "PervasiveLibrary: A serious and unexpected error has been \
             \returned to the `C' input routine from the operating system."
         | (~1, _) =>
           raise Io
             "PervasiveLibrary: An error has been returned by the operating \
             \system which the `C' input function does not know how to \
             \interpret."
         | _ => 
           raise Io
             "PervasiveLibrary: An unexpected error condition has been \
             \returned to me from the `C' input function.  This suggests \
             \that there is a fault in the ML/`C' interface."

    fun output (stream : int, s : string) =
      case call_c (CallCCodes_.output, (stream, s)) : int
        of 0 => ()
         | 1 =>
           raise Io
             "PervasiveLibrary: There has been an attempt to write to \
             \an invalid stream; possibly unopened."
         | 2 =>
           raise Io
             "PervasiveLibrary: An I/O error occurred during writing."
         | 3 =>
           raise Io
             "PervasiveLibrary: A serious and unexpected error has been \
             \returned to the `C' output routine from the operating system."
         | ~1 =>
           raise Io
             "PervasiveLibrary: An error has been returned by the operating \
             \system which the `C' output function does not know how to \
             \interpret."
         | _ => 
           raise Io
             "PervasiveLibrary: An unexpected error condition has been \
             \returned to me from the `C' output function.  This suggests \
             \that there is a fault in the ML/`C' interface."

    fun close_in (stream : int) =
      if call_c (CallCCodes_.close_in, stream) : bool then
        ()
      else
        raise Io "PervasiveLibrary: The `C' close_in function returned \
          \an error condition."

    fun close_out (stream : int) = 
      if call_c (CallCCodes_.close_out, stream) : bool then
        ()
      else
        raise Io "PervasiveLibrary: The `C' close_out function returned \
          \an error condition."

    fun end_of_stream (stream : int) = 
      (output(std_out,"End_of_stream returning false\n") ; false)

@


1.19
log
@Took out div definition as it now calls c
@
text
@d8 3
d112 5
d170 2
d226 6
@


1.18
log
@end_of_stream defined
@
text
@d8 3
a193 12

      fun (op div) (x,y) =
        let
          fun div'(x : int,y,z) = 
            if x<y
              then z
            else div'(x-y,y,z+1)
        in
          if x<0 orelse y<0
            then raise Io "Div only implemented for positive values"
          else div'(x,y,0)
        end
@


1.17
log
@Added definition of div for positive arguments
@
text
@d8 3
d76 3
d357 2
a358 1
    fun end_of_stream (stream : int) = raise Io "end_of_stream unimplemented"
@


1.16
log
@Added New Jersey structure
@
text
@d8 3
d185 12
@


1.15
log
@New pervasive library setup
@
text
@d8 3
d76 21
d148 1
a148 11
        structure Array :
          sig
            eqtype 'a array
            exception Size
            exception Subscript
            val array : int * '_a -> '_a array
            val length : 'a array -> int
            val update : 'a array * int * 'a -> unit
            val sub : 'a array * int -> 'a
            val arrayoflist : '_a list -> 'a array 
          end
d152 8
d341 4
a344 1
      fun substring (_,_,_) = raise Io "Someone has to implement substring"
d346 17
a363 1

@


1.14
log
@Added most of the array functions, though with bogus implementations
@
text
@a4 14
 *  Description
 *  -----------
 *  This structure becomes a module which is linked to other modules to
 *  provide definitions for the pervasives.  Many pervasives are compiled
 *  into in-line code, and therefore require no definition.  The list of
 *  pervasives which _are_ defined here is in ../main/_pervasives.sml.
 *
 *  Notes
 *  -----
 *  1.  IT IS IMPORTANT THAT CHANGES HERE ARE REFLECTED IN
 *      ../main/_pervasives.sml.
 *  2.  The identifiers used here are not the same as the pervasive
 *      identifiers, see ../main/_pervasives.sml.
 *
d8 3
d57 5
d63 7
d71 1
d73 1
a74 2
structure PervasiveLibrary_ :

d98 7
a104 1
      val append                : 'a list * 'a list -> 'a list
d107 2
a108 4
      val close_in              : int -> unit
      val close_out             : int -> unit
      val compose               : ('b -> 'c) * ('a -> 'b) -> ('a -> 'c)
      val concatenate           : string * string -> string
a109 2
      val end_of_stream         : int -> bool
      val equal			: ''a * ''a -> bool
a112 13
      val input                 : int * int -> string
      val int_abs               : int -> int
      val int_divide            : int * int -> int
      val int_equal             : int * int -> bool
      val int_greater           : int * int -> bool
      val int_greater_or_equal  : int * int -> bool
      val int_less              : int * int -> bool
      val int_less_or_equal     : int * int -> bool
      val int_minus             : int * int -> int
      val int_multiply          : int * int -> int
      val int_negate            : int -> int
      val int_not_equal         : int * int -> bool
      val int_plus              : int * int -> int
a113 2
      val load_string           : string -> unit
      val lookahead             : int -> string
d115 1
a115 1
      val modulo                : int * int -> int
d117 1
a117 3
      val not_equal		: ''a * ''a -> bool
      val open_in               : string -> int
      val open_out              : string -> int
a118 13
      val output                : int * string -> unit
      val real_abs              : real -> real
      val real_divide           : real * real -> real
      val real_equal            : real * real -> bool
      val real_greater          : real * real -> bool
      val real_greater_or_equal : real * real -> bool
      val real_less             : real * real -> bool
      val real_less_or_equal    : real * real -> bool
      val real_minus            : real * real -> real
      val real_multiply         : real * real -> real
      val real_negate           : real -> real
      val real_not_equal        : real * real -> bool
      val real_plus             : real * real -> real
d123 12
a134 12
      val std_in                : int
      val std_out               : int
      val string_equal          : string * string -> bool
      val string_not_equal      : string * string -> bool
      val substring		: string * int * int -> string (* temporary *)
      val arrayoflist           : '_a list -> '_a Array.array
      val tabulate              : int * (int -> '_a) -> '_a Array.array
      val sub                   : 'a Array.array * int -> 'a
      val update                : 'a Array.array * int * 'a -> unit
      val length                : 'a Array.array -> int
      val array                 : int * '_a -> '_a Array.array
  end
d136 12
a147 1
=
d149 2
a150 1
  struct
d152 1
a152 2
    fun rev' (done, []) = done
      | rev' (done, x::xs) = rev' (x::done, xs)
d154 3
a156 20
    exception Abs
    exception Bind
    exception Chr
    exception Diff
    exception Div
    exception Exp
    exception Floor
    exception Interrupt
    exception Io of string
    exception Ln
    exception Match
    exception Mod
    exception Neg
    exception Ord
    exception Prod
    exception Quot
    exception Sqrt
    exception Sum
    exception Size
    exception Subscript
d158 2
d161 5
d167 14
a180 6
(*
    fun append ([], list') = list'
      | append (list, []) = list
      | append (list, list') = rev' (rev' ([], list), list')
*)
    fun append (list, list') = System.call_c (CallCCodes_.append, (list, list'))
d182 5
a186 1
    fun arctan (r : real) = raise Io "arctan unimplemented"
d188 30
a217 2
    fun chr (c : int) =
      System.call_c (CallCCodes_.chr, c) : string
d219 29
a247 6
    fun close_in (stream : int) =
      if System.call_c (CallCCodes_.close_in, stream) : bool then
        ()
      else
        raise Io "PervasiveLibrary: The `C' close_in function returned \
          \an error condition."
a248 6
    fun close_out (stream : int) = 
      if System.call_c (CallCCodes_.close_out, stream) : bool then
        ()
      else
        raise Io "PervasiveLibrary: The `C' close_out function returned \
          \an error condition."
a249 20
    fun compose (f,g) x = f (g x)

    fun concatenate (s : string, s' : string) =
      System.call_c (CallCCodes_.concatenate, (s, s')) : string

    fun cos (r : real) = raise Io "cos unimplemented"

    fun end_of_stream (stream : int) = raise Io "end_of_stream unimplemented"

    fun equal (x, y) =
      System.call_c (CallCCodes_.equal, (x, y)) : bool

    fun exp (r : real) = raise Io "exp unimplemented"

    fun explode (s : string) =
      System.call_c (CallCCodes_.explode, s) : string list

    fun implode (list : string list) =
      System.call_c (CallCCodes_.implode, list) : string

d251 1
a251 1
      case System.call_c (CallCCodes_.input, (stream, x)) : int * string
a274 117
    fun int_abs 0 = 0
      | int_abs x =
        case System.call_c (CallCCodes_.iabs, x) : int
          of 0 => raise Abs
           | result => result

    fun int_divide (divisor : int, dividend : int) =
      case System.call_c (CallCCodes_.idivide,
                          (divisor, dividend)) : bool * int
        of (true, result) => result
         | _ => raise Div

    fun int_equal (x : int, y : int) = raise Io "int_equal unimplemented"

    fun int_greater (x : int, y : int) = raise Io "int_greater unimplemented"

    fun int_greater_or_equal (x : int, y : int) = raise Io "int_greater_or_equal unimplemented"

    fun int_less (x : int, y : int) = raise Io "int_less unimplemented"

    fun int_less_or_equal (x : int, y : int) = raise Io "int_less_or_equal unimplemented"

    fun int_minus (x : int, y : int) = raise Io "int_minus unimplemented"

    fun int_multiply (multiplier : int, multiplicand : int) =
      case System.call_c (CallCCodes_.imultiply,
                          (multiplier, multiplicand)) : bool * int
        of (true, result) => result
         | _ => raise Prod

    fun int_negate 0 = 0
      | int_negate x =
        case System.call_c (CallCCodes_.inegate, x) : int
          of 0 => raise Neg
           | result => result

    fun int_not_equal (x : int, y : int) = raise Io "int_not_equal unimplemented"

    fun int_plus (x : int, y : int) = raise Io "int_plus unimplemented"

    fun ln (r : real) = raise Io "ln unimplemented"

    fun load_string (s : string) = raise Io "load_string unimplemented"

    fun lookahead (s : int) = raise Io "lookahead unimplemented"

    fun modulo (divisor : int, dividend : int) =
      case System.call_c (CallCCodes_.idivide,
                          (divisor, dividend)) : bool * int
        of (true, result) => result
         | _ => raise Mod

    fun not true = false
      | not false = true

    fun not_equal (x, y) =
      System.call_c (CallCCodes_.not_equal, (x, y)) : bool

    fun open_in (s : string) =
      case System.call_c (CallCCodes_.open_in, s) : (bool * int)
        of (true, stream) => stream
         | (false, 0) => raise Interrupt
         | (false, 1) => raise Io (concatenate ("Cannot open ", s))
         | (false, 2) => raise Io (concatenate ("Cannot open ", s))
         | (false, 3) =>
           raise Io
             (concatenate
              ("PervasiveLibrary: A serious and unexpected error has been \
               \returned to the `C' open routine from the operating system \
               \on open_in of ", s))
         | (false, ~1) =>
           raise Io
             (concatenate
              ("PervasiveLibrary: An error has been returned by the operating \
               \system which the `C' open function does not know how to \
               \interpret.  The error occurred on open_in of ", s))
         | (false, _) => 
           raise Io
             (concatenate
              ("PervasiveLibrary: An unexpected error condition has been \
               \returned to me from the `C' open function.  This suggests \
               \that there is a fault in the ML/`C' interface.  The error \
               \occurred on open_in of ", s))

    fun open_out (s : string) =
      case System.call_c (CallCCodes_.open_out, s) : (bool * int)
        of (true, stream) => stream
         | (false, 0) => raise Interrupt
         | (false, 1) =>
           raise Io
             (concatenate
              ("PervasiveLibrary: A file doesn't exist and cannot be created \
               \due to naming, access, or quota restrictions.  The error \
               \occurred on open_out of ", s))
         | (false, 2) =>
           raise Io
             (concatenate
              ("PervasiveLibrary: A serious and unexpected error has been \
               \returned to the `C' open routine from the operating system \
               \on open_out of ", s))
         | (false, ~1) =>
           raise Io
             (concatenate
              ("PervasiveLibrary: An error has been returned by the operating \
               \system which the `C' open function does not know how to \
               \interpret.  The error occurred on open_out of ", s))
         | (false, _) => 
           raise Io
             (concatenate
              ("PervasiveLibrary: An unexpected error condition has been \
               \returned to me from the `C' open function.  This suggests \
               \that there is a fault in the ML/`C' interface.  The error \
               \occurred on open_out of ", s))

    fun ord (s : string) =
      System.call_c (CallCCodes_.ord, s) : int

d276 1
a276 1
      case System.call_c (CallCCodes_.output, (stream, s)) : int
d300 6
a305 1
    fun real_abs (r : real) = System.call_c (CallCCodes_.rabs, r) : real
d307 6
a312 1
    fun real_divide (x : real, y : real) = System.call_c (CallCCodes_.rdivide, (x, y)) : real
d314 1
a314 1
    fun real_equal (x : real, y : real) = System.call_c (CallCCodes_.requal, (x, y)) : bool
d316 1
a316 1
    fun real_greater (x : real, y : real) = System.call_c (CallCCodes_.rgt, (x, y)) : bool
d318 2
a319 1
    fun real_greater_or_equal (x : real, y : real) = System.call_c (CallCCodes_.rge, (x, y)) : bool
a320 59
    fun real_less (x : real, y : real) = System.call_c (CallCCodes_.rlt, (x, y)) : bool

    fun real_less_or_equal (x : real, y : real) = System.call_c (CallCCodes_.rle, (x, y)) : bool

    fun real_minus (x : real, y : real) = System.call_c (CallCCodes_.rminus, (x, y)) : real

    fun real_multiply (x : real, y : real) = System.call_c (CallCCodes_.rmultiply, (x, y)) : real

    fun real_negate (r : real) = System.call_c (CallCCodes_.rnegate, r) : real

    fun real_not_equal (x : real, y : real) = System.call_c (CallCCodes_.rnequal, (x, y)) : bool

    fun real_plus (x : real, y : real) = System.call_c (CallCCodes_.rplus, (x, y)) : real

    fun rev list = rev' ([], list)

    fun map f [] = []
      | map f x =
        let
          fun map_sub(done, []) = rev done
            | map_sub(done, x :: xs) = map_sub(f x :: done, xs)
        in
          map_sub([], x)
        end

    fun sin (r : real) = raise Io "sin unimplemented"

    fun size (s : string) = System.call_c (CallCCodes_.size, s) : int

    fun sqrt (r : real) = raise Io "sqrt unimplemented"

    val std_in = 0
    val std_out = 1

    fun string_equal (s : string, s' : string) =
      System.call_c (CallCCodes_.string_equal, (s, s')) : bool

    fun string_not_equal (s : string, s' : string) =
      System.call_c (CallCCodes_.string_not_equal, (s, s')) : bool

    fun substring (string, x, y) = raise Io "substring unimplemented"

    fun array_arrayoflist _ = raise Io "array_arrayoflist unimplemented"
    fun array_tabulate _ = raise Io "array_tabulate unimplemented"
    fun array_array(x,y) = raise Io "array_array unimplemented"
    fun array_length(x) = raise Io "array_length unimplemented"
    fun array_sub(x,y) = raise Io "array_sub unimplemented"
    fun array_update(x,y,z) = raise Io "array_update unimplemented"

structure Array =
  struct
    exception Size
    exception Subscript
    fun array (x,y) = array_array(x,y)
    val arrayoflist = array_arrayoflist
    fun length(x) = array_length(x)
    fun sub(x,y) = array_sub(x,y)
    val tabulate = array_tabulate
    fun update(x,y,z) = array_update(x,y,z)
a322 43
val arrayoflist = Array.arrayoflist
val tabulate = Array.tabulate
val array = Array.array
val length = Array.length
val sub = Array.sub
val update = Array.update

structure System =
  struct
    val call_c = System.call_c
  end

(*
    fun arrayoflist l = 
      let
	fun llength ([],x) = x
	  | llength (_::t,x) = llength(t,x+1)
	val (element::_) = l
	val ar = Array.array(llength (l,0),element)
	fun set ([],_) = ()
	  | set (h::t,offset) = (Array.update(ar,offset,h) ;
				 set(t,offset+1))
	val _ = set (l,0)
      in
	ar
      end

    fun tabulate (size,generator) = 
      let
	val first = generator 0
	val ar = Array.array(size,first)
	fun set offset =
	  if offset=size
	    then ()
	  else
	    (Array.update(ar,offset,generator offset);
	     set (offset+1))
      val _ = set 1
      in
	ar
      end
*)
  end
@


1.13
log
@added the array structure itself
@
text
@d22 3
d157 4
d458 6
a463 2
    fun arrayoflist _ = raise Io "arrayoflist unimplemented"
    fun tabulate _ = raise Io "tabulate unimplemented"
d469 6
a474 6
    fun array (x,y) = Array.array(x,y)
    val arrayoflist = Array.arrayoflist
    fun length(x) = Array.length(x)
    fun sub(x,y) = Array.sub(x,y)
    val tabulate = Array.tabulate
    fun update(x,y,z) = Array.update(x,y,z)
d477 7
a518 1

@


1.12
log
@Changed unimplemented pervasives to raise Io instead of Interrupt so
we can tell which one causes a run to fail.
@
text
@d22 4
d453 17
@


1.11
log
@Removed explicit numbering of C routines and replaced by members of the
automatically generated structure CallCCodes_.
Commented out arrayoflist and tabulate until they can be implemented without
depending on themselves.
@
text
@d22 6
d189 1
a189 1
    fun arctan (r : real) = raise Interrupt
d213 1
a213 1
    fun cos (r : real) = raise Interrupt
d215 1
a215 1
    fun end_of_stream (stream : int) = raise Interrupt
d220 1
a220 1
    fun exp (r : real) = raise Interrupt
d265 1
a265 1
    fun int_equal (x : int, y : int) = raise Interrupt
d267 1
a267 1
    fun int_greater (x : int, y : int) = raise Interrupt
d269 1
a269 1
    fun int_greater_or_equal (x : int, y : int) = raise Interrupt
d271 1
a271 1
    fun int_less (x : int, y : int) = raise Interrupt
d273 1
a273 1
    fun int_less_or_equal (x : int, y : int) = raise Interrupt
d275 1
a275 1
    fun int_minus (x : int, y : int) = raise Interrupt
d289 1
a289 1
    fun int_not_equal (x : int, y : int) = raise Interrupt
d291 1
a291 1
    fun int_plus (x : int, y : int) = raise Interrupt
d293 1
a293 1
    fun ln (r : real) = raise Interrupt
d295 1
a295 1
    fun load_string (s : string) = raise Interrupt
d297 1
a297 1
    fun lookahead (s : int) = raise Interrupt
d430 1
a430 1
    fun sin (r : real) = raise Interrupt
d434 1
a434 1
    fun sqrt (r : real) = raise Interrupt
d445 1
a445 1
    fun substring (string, x, y) = raise Interrupt
d447 2
a448 2
    fun arrayoflist _ = raise Interrupt
    fun tabulate _ = raise Interrupt
@


1.10
log
@Spelling mistake in tabulate
@
text
@d22 3
d56 3
d181 1
a181 1
    fun append (list, list') = System.call_c (17, (list, list'))
d186 1
a186 1
      System.call_c (9, c) : string
d189 1
a189 1
      if System.call_c (2, stream) : bool then
d196 1
a196 1
      if System.call_c (5, stream) : bool then
d205 1
a205 1
      System.call_c (11, (s, s')) : string
d212 1
a212 1
      System.call_c (14, (x, y)) : bool
d217 1
a217 1
      System.call_c (12, s) : string list
d220 1
a220 1
      System.call_c (13, list) : string
d223 1
a223 1
      case System.call_c (3, (stream, x)) : int * string
a246 3
    fun int_abs (x : int) = raise Interrupt

(*
d249 1
a249 1
        case System.call_c (????, x) : int
a251 1
*)
d253 5
a257 1
    fun int_divide (divisor : int, dividend : int) = raise Interrupt
d271 5
a275 1
    fun int_multiply (x : int, y : int) = raise Interrupt
d277 5
a281 1
    fun int_negate (x : int) = raise Interrupt
d293 5
a297 1
    fun modulo (x : int, y : int) = raise Interrupt
d303 1
a303 1
      System.call_c (15, (x, y)) : bool
d306 1
a306 1
      case System.call_c (1, s) : (bool * int)
d332 1
a332 1
      case System.call_c (4, s) : (bool * int)
d362 1
a362 1
      System.call_c (10, s) : int
d365 1
a365 1
      case System.call_c (6, (stream, s)) : int
d389 1
a389 1
    fun real_abs (r : real) = System.call_c (18, r) : real
d391 1
a391 1
    fun real_divide (x : real, y : real) = System.call_c (19, (x, y)) : real
d393 1
a393 1
    fun real_equal (x : real, y : real) = System.call_c (20, (x, y)) : bool
d395 1
a395 1
    fun real_greater (x : real, y : real) = System.call_c (21, (x, y)) : bool
d397 1
a397 1
    fun real_greater_or_equal (x : real, y : real) = System.call_c (22, (x, y)) : bool
d399 1
a399 1
    fun real_less (x : real, y : real) = System.call_c (23, (x, y)) : bool
d401 1
a401 1
    fun real_less_or_equal (x : real, y : real) = System.call_c (24, (x, y)) : bool
d403 1
a403 1
    fun real_minus (x : real, y : real) = System.call_c (25, (x, y)) : real
d405 1
a405 1
    fun real_multiply (x : real, y : real) = System.call_c (26, (x, y)) : real
d407 1
a407 1
    fun real_negate (r : real) = System.call_c (27, r) : real
d409 1
a409 1
    fun real_not_equal (x : real, y : real) = System.call_c (28, (x, y)) : bool
d411 1
a411 1
    fun real_plus (x : real, y : real) = System.call_c (29, (x, y)) : real
d426 1
a426 1
    fun size (s : string) = System.call_c (16, s) : int
d434 1
a434 1
      System.call_c (7, (s, s')) : bool
d437 1
a437 1
      System.call_c (8, (s, s')) : bool
d441 4
d473 1
a473 1

@


1.9
log
@array_of_list should have been arrayoflist
@
text
@d22 3
d136 2
a137 2
      val arrayoflist           : '_a list -> '_a array
      val tabulate              : int * (int -> '_a) -> '_a array
d437 1
a437 1
    fun tablulate (size,generator) = 
@


1.8
log
@Added array code
@
text
@d22 3
d133 1
a133 1
      val array_of_list         : '_a list -> '_a array
d420 1
a420 1
    fun array_of_list l = 
@


1.7
log
@Added substring as a temporary measure until we bootstrap the compiler.
@
text
@d22 3
d69 2
d130 2
a131 1

d159 2
d163 1
d416 29
@


1.6
log
@Implemented the real arithmetic functions.
@
text
@d21 4
a24 1
 * $Log:	__pervasive_library.sml,v $
a40 1
 *  
d124 1
d405 2
@


1.5
log
@Added error handling to input and output, plus calls to C for various
other functions.
@
text
@d22 4
d353 1
a353 1
    fun real_abs (r : real) = raise Interrupt
d355 1
a355 1
    fun real_divide (x : real, y : real) = raise Interrupt
d357 1
a357 1
    fun real_equal (x : real, y : real) = raise Interrupt
d359 1
a359 1
    fun real_greater (x : real, y : real) = raise Interrupt
d361 1
a361 1
    fun real_greater_or_equal (x : real, y : real) = raise Interrupt
d363 1
a363 1
    fun real_less (x : real, y : real) = raise Interrupt
d365 1
a365 1
    fun real_less_or_equal (x : real, y : real) = raise Interrupt
d367 1
a367 1
    fun real_minus (x : real, y : real) = raise Interrupt
d369 1
a369 1
    fun real_multiply (x : real, y : real) = raise Interrupt
d371 1
a371 1
    fun real_negate (r : real) = raise Interrupt
d373 1
a373 1
    fun real_not_equal (x : real, y : real) = raise Interrupt
d375 1
a375 1
    fun real_plus (x : real, y : real) = raise Interrupt
@


1.4
log
@Added equal and not_equal.
@
text
@d22 3
d148 1
d152 2
d157 2
a158 1
    fun chr (c : int) = raise Interrupt
d176 2
a177 1
    fun concatenate (s : string, s' : string) = raise Interrupt
d183 2
a184 1
    fun equal (x, y) = raise Interrupt
d188 2
a189 1
    fun explode (s : string) = raise Interrupt
d191 2
a192 1
    fun implode (list : string list) = raise Interrupt
d194 24
a217 2
    fun input (stream : int, x : int) = 
      System.call_c (3, (stream, x)) : string
d221 8
d262 2
a263 1
    fun not_equal (x, y) = raise Interrupt
d321 2
a322 1
    fun ord (s : string) = raise Interrupt
d325 23
a347 1
      System.call_c (6, (stream, s)) : unit
d386 1
a386 1
    fun size (s : string) = raise Interrupt
@


1.3
log
@Added a signature constraint so that common sub-functions can be
added freely to the structure.  Wrote file input and output pervasives.
@
text
@d22 4
d67 1
d90 1
d175 2
d220 2
@


1.2
log
@Optimised the builtin entirely ml functions
@
text
@d22 3
d31 1
a31 1
structure PervasiveLibrary_ =
d33 81
d116 3
d127 1
a127 1
    exception Io
d139 4
d147 6
a152 1
    fun close_in (stream : int) = raise Interrupt
d154 6
a159 1
    fun close_out (stream : int) = raise Interrupt
d175 2
a176 1
    fun input (stream : int, x : int) = raise Interrupt
d213 25
a237 1
    fun open_in (s : string) = raise Interrupt
d239 29
a267 1
    fun open_out (s : string) = raise Interrupt
d272 1
a272 1
      System.call_c (1, (stream, s)) : unit
d298 1
a298 7
    fun rev list =
      let
	fun rev' (done, []) = done
	  | rev' (done, x::xs) = rev' (x::done, xs)
      in
	rev' ([], list)
      end
d302 6
a307 6
	let
	  fun map_sub(done, []) = rev done
	    | map_sub(done, x :: xs) = map_sub(f x :: done, xs)
	in
	  map_sub([], x)
	end
a308 10
    fun append ([], list') = list'
      | append (list, []) = list
      | append (x, y) =
	let
	  fun rev_app([], done) = done
	    | rev_app(x :: xs, done) = rev_app(xs, x :: done)
	in
	  rev_app(rev x, y)
	end

d318 2
a319 1
    fun string_equal (s : string, s' : string) = raise Interrupt
d321 3
a323 1
    fun string_not_equal (s : string, s' : string) = raise Interrupt
@


1.1
log
@Initial revision
@
text
@d21 4
a24 1
 * $Log$
a51 4
    fun append ([], list') = list'
      | append (element::elements, list') =
	element::(append (elements, list'))

a105 3
    fun map f [] = []
      | map f (x::xs) = (f x)::(map f xs)

d151 19
@
